" *************************************************************************
" *                                                                       *
" * Copyright, (C) BULL HN Information Systems Inc., 1990                 *
" *                                                                       *
" * Copyright (c) 1980 by Centre Interuniversitaire de Calcul de Grenoble *
" * and Institut National de Recherche en Informatique et Automatique     *
" *                                                                       *
" *************************************************************************

" HISTORY COMMENTS:
"  1) change(1986-10-09,JMAthane), approve(1986-10-09,MCR7521),
"     audit(1986-10-09,JPFauche), install(1986-11-12,MR12.0-1208):
"     Pascal Version 8.03 for MR12.0.
"  2) change(1990-04-06,Zimmerman), approve(1990-04-06,MCR8170),
"     audit(1990-05-03,Huen), install(1990-05-30,MR12.4-1013):
"     pas_15: Change round_operator to properly handle boundary condition that
"     occurs when rounding real numbers of the form -x.5. (ie -5.5 should be
"     rounded to -6, not -5)
"  3) change(1990-06-07,Zimmerman), approve(1990-06-07,MCR8170),
"     audit(1990-06-11,Huen), install(1990-06-19,MR12.4-1016):
"     PBF: Improve accuracy of round for negative numbers.
"  4) change(2017-01-08,GDixon), approve(2017-01-08,MCR10025),
"     audit(2017-01-08,Swenson), install(2017-01-08,MR12.6f-0008):
"     The Pascal return_zero operator tested for zero arg descriptors
"     improperly, sometimes preventing programs from being invoked as a
"     command.
"                                                      END HISTORY COMMENTS

"	pascal_operators_ :
"
"	OPERATOR ALM SEGMENT FOR MULTICS PASCAL
"
"
"
"	Created J.M.Athane 04/02/80
"
"
	segdef	transfer_vector
	segdef	trace_transfer_vector
	segdef	cleanup_sequence
	segdef	pascal_operators_
	segdef	entry_operators_begin
	segdef	entry_operators_end
	segdef	v6_entry_operators_begin
	segdef	v6_entry_operators_end
	segdef	old_entry_operators_begin
	segdef	old_entry_operators_end
	segdef	pascal_operators_end
"
	segdef	init_fsb_return
	segdef	init_fsb_alloc_return
	segdef	connect_return
	segdef	RESET_file_return
	segdef	REWRITE_return
	segdef	close_return
	segdef	READ_text_return
	segdef	fclose_return
	segdef	READ_sequential_return
	segdef	READLN_return
	segdef	WRITE_text_return
	segdef	WRITE_sequential_return
	segdef	WRITELN_return
	segdef	FLUSH_return
	segdef	defered_GET_text_return
	segdef	PAGE_return
	segdef	PUT_text_return
	segdef	PUT_sequential_return
	segdef	GET_text_return
	segdef	GET_sequential_return
	segdef	SREAD_integer_return
	segdef	SREAD_real_return
	segdef	SWRITE_return
	segdef	NEW_return
	segdef	DISPOSE_return
	segdef	RESET_area_return
	segdef	GET_direct_return
	segdef	PUT_direct_return
	segdef	open_update_return
	segdef	date_return
	segdef	time_return
	segdef	v6_RESET_file_return
	segdef	v6_READLN_return
	segdef	v6_GET_text_return
"
"
"
"
	include 	stack_header

	include	stack_frame
"
	include 	on_unit
"
"
"
	equ	symbol.object_created,6
	equ	link.symbol_ptr,2
"
"
"
"
"		definition of  PASCAL and SIMONE stack frame
"		(words 0 to 95 or 101 of the stack frame are reserved
"		for Multics system and Pascal operators)
"
"
	equ	dlinkw,32			(2 words)
	equ	linkage_ptr,36		(2 words)
	equ	evarea,38			(used by generated code for expression evaluations)
	equ	save_regs,40		(8 words)
	bool	main_bit,400000		(DL)
	bool	fast_bit,200000		(DL)
	bool	check_bit,100000		(DL)
	bool	close_on_cleanup_bit,010000	(DL)
	bool	sol_bit,000040		(DL)
	bool	user_on_cleanup_bit,000020	(DL)
	bool	function_value_bit,000010	(DL)
	bool	french_bit,000004		(DL)
	equ	cleanup_on_unit,48	(6 words)
	equ	math_work_ptr,54		(2 words)
	equ	user_cleanup_ptr,56		(2 words)
	equ	op_args,64			(16 words)
	equ	op_work,80			(16 words)
	equ	first_local_place,96
	equ	sim_first_local_place,112		Size of simone frame

	equ	math_work_size,32

	equ	arg_header,op_args+0
	equ	arg_ptr,op_args+2
	equ	io_block_ptr,op_args+4
	equ	io_two_words_value,op_args+6
	equ	io_type,op_args+8
	equ	io_length,op_args+9
	equ	io_size,op_args+10
	equ	io_dim,op_args+11
	equ	io_stack_frame_ptr,op_args+12
	equ	io_linkage_ptr,op_args+14
	equ	area_block_ptr,op_args+4
	equ	area_block_length,op_args+6
	equ	area_structure_ptr,op_args+8
	equ	arg_1,op_args+4
	equ	err_double,op_args+4
	equ	err_single,op_args+6
	equ	err_code,op_args+7
	equ	err_addr,op_args+8
	equ	indicators,op_args+15
	equ	page,op_args+14
	equ	save_fsb_addr,op_args+14
	equ	cpu,op_args+12
"

"		now special simone definitions
"
	equ	father_ptr,32			same as dlinkw
	equ	decal,64
	equ	save_ptr_regs,80
	equ	locals_ptr,96
	equ	next_simone_frame_ptr,98

	equ	base_process_ptr,100
	equ	left_size,102
	equ	free_block_size,103		size of a free block
	equ	monormod_ptr,104		ptr --> monormod containing the proc
	equ	execution_mo_ptr,106	ptr --> monitor or module acceded by the proc
	equ	work_for_sim,108		work storage
	equ	new_frame_addr,108		used when starting a new process
	equ	next_free_block_ptr,110	free list for garbage collection
"
"
"		definitions of locals in simone
"		stack_frame
"
"
	equ	sim_locs_size,24		Size for simone locals
"
	equ	main_base_ptr,0		ptr on base of the main's stack
	equ	next_process_frame_ptr,2
	equ	next_threaded_process_ptr,4	to chain process in queues
	equ	previous_threaded_process_ptr,6
	equ	waiting_var_sons,20		1 when the process is waiting for its local variables sons 0 otherwise
	equ	father_type,21
	equ	process_return_ptr,10
	equ	max_size,16		max size that can be reached by the stack
	equ	priority,17
	equ	activation_time,17
	equ	number_of_active_sons,18
	equ	exit_ptr,22		for exit in a process
"
"
"
"		 main's stack
"
"
	equ	first_active_process_ptr,14
	equ	bill_book_ptr,8

	equ	hour,19
"
"
"		 monitor's or module ' pseudo_stack
"
"
	equ	mo_dynlk,0
	equ	mo_father_ptr,2
	equ	mo_active_sons,4
	equ	mo_type,5		0 for a monitor or 1 for a module
	equ	mo_arg_list_ptr,6
	equ	prev_exec_mo_ptr,8
	equ	mo_father_type,10
"
"
"		 monitor's pseudo_stack
"
"
	equ	mon_signalers_queue_ptr,12
	equ	mon_fifo_queue_ptr,14

	equ	mon_fifo_queue_end_ptr,16
	equ	mon_tenant_process_ptr,18
	equ	monitor_busy,20
"
"
"		condition
"
"
	equ	cond_queue_ptr,0
	equ	cond_queue_end_ptr,2
	equ	cond_counter,4

"
"
"		old definitions (until PASCAL 5.02)
"
	equ	old_dlinkw,40
	equ	old_linkage_ptr,42
"
"
"
"
"
"		definitions in MAIN static section
"
"
	equ	COND,0		(1 word)
	equ	PARM_count,1	(1 word)
	equ	PARM,2		(25 words = 100 chars)
"
"
"
"		definitions in PASCAL fsb
"
"
	equ	fsb.flags,1
	bool	fsb.flags.open,000002		(DL)
	bool	fsb.flags.get_next_char,000400	(DL)
	bool	fsb.flags.interactive_file,020000	(DL)
	equ	fsb.file_status,5
	equ	fsb.eof,4
	equ	fsb.record_counter,18
	equ	fsb.eoln,27
	equ	fsb.buff_index,28
	equ	fsb.buff_max,29
	equ	fsb.buff_len,30
	equ	fsb.window,38
	equ	fsb.buffer,39
"
"
"
"		definitions in PASCAL area
"
"
	equ	area_block_header_size,4		size of a block header
"
	equ	area.ptr,46			ptr to seg in area structure
"
	equ	area_seg_header.last_free,9		offset of last free block
	equ	area_seg_header.last_block,16		ptr to last block
"
	equ	area_block_header.previous_free,0		(high)
	equ	area_block_header.previous_blk,0		(low)
	equ	area_block_header.used,1			(high)
	equ	area_block_header.length,1			(low)
	equ	area_block_header.clock,2
"
"
"
"		PASCAL translator_id 
"
"
	equ	my_old_id,6		until PASCAL 5.02
	equ	my_id,8			since PASCAL 6.00
"
"
"
"
"
"		run-time transfer vector to operators called
"		by pascal programs
"
"	ORDER MUST NOT BE MODIFIED . ONLY APPEND ALLOWED .
"
"
	tra	restor_prev_mo					-30
	tra	exit						-29
	tra	sim_ext_entry					-28
	tra	pure_int_entry					-27
	tra	randint						-26
	tra	negexp						-25
	tra	normal						-24
	tra	uniform						-23
	tra	mo_waitsons					-22
	tra	terminate						-21
	tra	vtime						-20
	tra	priority_op					-19
	tra	length						-18
	tra	empty						-17
	tra	cwait						-16
	tra	signal						-15
	tra	free_exclusion					-14
	tra	ask_for_exclusion					-13
	tra	init_cond						-12
	tra	monitor_entry					-11
	tra	module_entry					-10
	tra	save_arg_list					-9
	tra	hold						-8
	tra	process_return					-7
	tra	waitsons						-6
	tra	active_process_queuing				-5
	tra	process_entry					-4
	tra	sim_int_return					-3
	tra	sim_int_entry					-2
	tra	SIMONE_MAIN_entry					-1
transfer_vector:
	tra	old_MAIN_entry					0
	tra	old_int_entry					1
	tra	old_ext_entry					2
	tra	go_to_exit_ext					3
	tra	old_SIN						4
	tra	old_COS						5
	tra	old_LOG						6
	tra	old_EXP						7
	tra	old_SQRT						8
	tra	old_ATAN						9
	tra	old_LOG10						10
	tra	RESET_file_call					11
	tra	REWRITE_call					12
	tra	close_call					13
	tra	READ_text						14
	tra	READ_sequential_call				15
	tra	READLN_call					16
	tra	WRITE_text					17
	tra	WRITE_sequential_call				18
	tra	WRITELN_call					19
	tra	PAGE_call						20
	tra	PUT_text						21
	tra	PUT_sequential_call					22
	tra	GET_text						23
	tra	GET_sequential_call					24
	tra	go_to_exit					25
	tra	NEW						26
	tra	DISPOSE_call					27
	tra	RESET_area_call					28
	tra	old_TRUNC						29
	tra	old_ROUND						30
	tra	int_A_to_real					31
	tra	int_Q_to_real					32
	tra	PUT_direct_call					33
	tra	GET_direct_call					34
	tra	open_update_call					35
	tra	connect_call					36
	tra	fclose_call					37
	tra	int_check_error					38
	tra	int_return					39
	tra	ext_return					40
	tra	v6_MAIN_return					41
	tra	int_call						42
	tra	ext_call						43
	tra	old_MAIN_entry_force_fast				44
	tra	old_ext_entry_force_fast				45
	tra	init_fsb_call					46
	tra	date						47
	tra	time						48
	tra	clock						49
	tra	long_profile					50
	tra	v6_MAIN_entry					51
	tra	v6_int_entry					52
	tra	v6_ext_entry					53
	tra	v6_MAIN_entry_force_fast				54
	tra	v6_ext_entry_force_fast				55
	tra	v6_SIN						56
	tra	v6_COS						57
	tra	v6_LOG						58
	tra	v6_EXP						59
	tra	v6_SQRT						60
	tra	v6_ATAN						61
	tra	v6_LOG10						62
	tra	TRUNC						63
	tra	ROUND						64
	tra	FLUSH_call					65
	tra	check_before_EOLN					66
	tra	check_before_EOF					67
	tra	check_before_text_reference				68
	tra	ARGC_short					69
	tra	ARGC						70
	tra	ARGC_ext						71
	tra	init_fsb_alloc					72
	tra	ARGV_short					73
	tra	ARGV						74
	tra	ARGV_ext						75
	tra	STOP_short					76
	tra	STOP						77
	tra	STOP_ext						78
	tra	MAIN_entry					79
	tra	SIN						80
	tra	COS						81
	tra	LOG						82
	tra	EXP						83
	tra	SQRT						84
	tra	ATAN						85
	tra	LOG10						86
	tra	return_zero					87
	tra	ext_entry						88
	tra	int_entry						89
	tra	SREAD_char					90
	tra	SREAD_integer					91
	tra	SREAD_real					92
	tra	SWRITE_char					93
	tra	SWRITE_string					94
	tra	SWRITE_substring					95
	tra	SWRITE_boolean					96
	tra	SWRITE_integer					97
	tra	SWRITE_real_e					98
	tra	SWRITE_real_d					99
	tra	SWRITE_enumerated					100
	tra	check_parm_proc					101
	tra	function_value_set					102
	tra	function_value_check				103
	tra	extend_stack_length					104
	tra	reset_stack_length					105
"
"
"
"
"		run-time transfer vector to operators called
"		by pascal programs UNDER TRACE
"
"	ORDER MUST NOT BE MODIFIED . ONLY APPEND ALLOWED .
"
	tra	restor_prev_mo					-30
	tra	exit						-29
	tra	sim_ext_entry					-28
	tra	pure_int_entry					-27
	tra	randint						-26
	tra	negexp						-25
	tra	normal						-24
	tra	uniform						-23
	tra	mo_waitsons					-22
	tra	terminate						-21
	tra	vtime						-20
	tra	priority_op					-19
	tra	length						-18
	tra	empty						-17
	tra	cwait						-16
	tra	signal						-15
	tra	free_exclusion					-14
	tra	ask_for_exclusion					-13
	tra	init_cond						-12
	tra	monitor_entry					-11
	tra	module_entry					-10
	tra	save_arg_list					-9
	tra	hold						-8
	tra	process_return					-7
	tra	waitsons						-6
	tra	active_process_queuing				-5
	tra	process_entry					-4
	tra	sim_int_return					-3
	tra	sim_int_entry					-2
	tra	SIMONE_MAIN_entry					-1
trace_transfer_vector:
	tra	old_trace_MAIN_entry				0
	tra	old_int_entry					1
	tra	old_trace_ext_entry					2
	tra	go_to_exit_ext					3
	tra	old_SIN						4
	tra	old_COS						5
	tra	old_LOG						6
	tra	old_EXP						7
	tra	old_SQRT						8
	tra	old_ATAN						9
	tra	old_LOG10						10
	tra	RESET_file_call					11
	tra	REWRITE_call					12
	tra	close_call					13
	tra	READ_text						14
	tra	READ_sequential_call				15
	tra	READLN_call					16
	tra	WRITE_text					17
	tra	WRITE_sequential_call				18
	tra	WRITELN_call					19
	tra	PAGE_call						20
	tra	PUT_text						21
	tra	PUT_sequential_call					22
	tra	GET_text						23
	tra	GET_sequential_call					24
	tra	go_to_exit					25
	tra	NEW						26
	tra	DISPOSE_call					27
	tra	RESET_area_call					28
	tra	old_TRUNC						29
	tra	old_ROUND						30
	tra	int_A_to_real					31
	tra	int_Q_to_real					32
	tra	PUT_direct_call					33
	tra	GET_direct_call					34
	tra	open_update_call					35
	tra	connect_call					36
	tra	fclose_call					37
	tra	int_check_error					38
	tra	int_return					39
	tra	ext_return					40
	tra	v6_MAIN_return					41
	tra	int_call						42
	tra	ext_call						43
	tra	old_trace_MAIN_entry_force_fast			44
	tra	old_trace_ext_entry_force_fast			45
	tra	init_fsb_call					46
	tra	date						47
	tra	time						48
	tra	clock						49
	tra	long_profile					50
	tra	trace_v6_MAIN_entry					51
	tra	v6_int_entry					52
	tra	trace_v6_ext_entry					53
	tra	trace_v6_MAIN_entry_force_fast			54
	tra	trace_v6_ext_entry_force_fast				55
	tra	v6_SIN						56
	tra	v6_COS						57
	tra	v6_LOG						58
	tra	v6_EXP						59
	tra	v6_SQRT						60
	tra	v6_ATAN						61
	tra	v6_LOG10						62
	tra	TRUNC						63
	tra	ROUND						64
	tra	FLUSH_call					65
	tra	check_before_EOLN					66
	tra	check_before_EOF					67
	tra	check_before_text_reference				68
	tra	ARGC_short					69
	tra	ARGC						70
	tra	ARGC_ext						71
	tra	init_fsb_alloc					72
	tra	ARGV_short					73
	tra	ARGV						74
	tra	ARGV_ext						75
	tra	STOP_short					76
	tra	STOP						77
	tra	STOP_ext						78
	tra	trace_MAIN_entry					79
	tra	SIN						80
	tra	COS						81
	tra	LOG						82
	tra	EXP						83
	tra	SQRT						84
	tra	ATAN						85
	tra	LOG10						86
	tra	return_zero					87
	tra	trace_ext_entry					88
	tra	int_entry						89
	tra	SREAD_char					90
	tra	SREAD_integer					91
	tra	SREAD_real					92
	tra	SWRITE_char					93
	tra	SWRITE_string					94
	tra	SWRITE_substring					95
	tra	SWRITE_boolean					96
	tra	SWRITE_integer					97
	tra	SWRITE_real_e					98
	tra	SWRITE_real_d					99
	tra	SWRITE_enumerated					100
	tra	check_parm_proc					101
	tra	function_value_set					102
	tra	function_value_check				103
	tra	extend_stack_length					104
	tra	reset_stack_length					105
"
"
"
"
"
"		constants
"
"
	even
mask1:
	oct	000000000000
	oct	777777777777
mask2:
	oct	000000000000
	oct	400000000000
half:
	oct	000400000000
	oct	000000000000
smallhalf:
	oct	000377777777
	oct	777777777777
one_arg_header:
	oct	000002000004
	oct	000000000000
null_ptr:
	its	-1,1
unsnap_ind:
	oct	000000000046
	oct	000000000020
tag_mod_mask:
	oct	000000000077
	oct	000000000077
non_mod_mask:
	oct	777777777700
descriptor_mask:
	oct	000077777777
neg_mask:
	oct	377777777777
fb35_desc:
	oct	004000000043
non_MAIN_mask:
	oct	777777377777
non_get_next_char_mask:
	oct	777777777377
close_on_cleanup_mask:
	oct	777777767777
user_on_cleanup_mask:
	oct	777777777757
bit_29_mask:
	oct	777777777677
"
"
	equ	twoto15,32768
	equ	twoto17,131072
"
"
"
non_last_set_mask:
	oct	777777777776
ring_number_mask:
	oct	777777077777
priority_max:
	oct	377777000000
check_mo_father_type_bit:
	oct	000000000001
moinsun:
	oct	777777777777
"
"
"

"	**********************************************
"	*				     *
"	*        PASCAL OPERATORS CONVENTIONS        *
"	*				     *
"	**********************************************
"
"
"
"	PASCAL generated code assumes that PR0, PR4, PR6 are NOT
"	MODIFIED by operator calls.
"
"		PR0 -> pascal operators runtime transfer vector
"		PR4 -> link section of the pascal program
"		PR6 -> stack frame of the pascal program
"
"	One exception : call to external procedures may modify PR4 (standard Multics)
"
"
"	ALL the operators are called by the following instruction :
"
"		tsp3	0|{operator number}
"
"
"
pascal_operators_:

"	*********************************
"	*                               *
"	*        ENTRY OPERATORS        *
"	*			  *
"	*********************************
"
"
"
entry_operators_begin:
"
"		entry operators for MAIN and exportable procedures
"		--------------------------------------------------
"
"	assumed that:     (Multics convention)
"		PR0 -> parameter list
"		PR6 -> stack frame of the calling procedure
"		PR7 -> stack header
"
"	calling sequence:
"		epp5	0,ic		entry point addr
"		epp2	7|stack_header.trans_op_tv_ptr   MUST BE SECOND WORD (for TRACE)
"		epp2	2|8,*		to get ptr to pascal operators
"		ldq	[PASCAL execution flags],dl
"		eax7	[stack_frame size in words (n * 16)]
"		tsp3	2|{op number}
"
"	Performs the standard push sequence.
"	Sets locals to zero if check mode
"
"	returns:
"		PR0 -> pascal operators transfer vector
"		PR4 -> link section of the procedure
"		PR6 -> stack_frame of the procedure
"		(indicators are reset)
"
MAIN_entry:
	inhibit	on
	epp1	7|stack_header.stack_end_ptr,*
	spri6	1|stack_frame.prev_sp
	spri0	1|stack_frame.arg_ptr	"arg_ptr" in new stack frame
	epp0	1|0,7		get ptr to new stack end
	spri0	1|stack_frame.next_sp
	spri0	7|stack_header.stack_end_ptr 	initiate new stack end
	epp6	1|0		PR6 -> stack frame of the procedure
	inhibit	off
	adq	my_id,du
	stq	6|stack_frame.translator_id
	tra	MAIN_ext_join
"
"
"
"
ext_entry:
	inhibit	on
	epp1	7|stack_header.stack_end_ptr,*
	spri6	1|stack_frame.prev_sp
	spri0	1|stack_frame.arg_ptr	"arg_ptr" in new stack frame
	epp0	1|0,7		get ptr to new stack end
	spri0	1|stack_frame.next_sp
	spri0	7|stack_header.stack_end_ptr 	initiate new stack end
	epp6	1|0		PR6 -> stack frame of the procedure
	inhibit	off
	adq	my_id,du
	stq	6|stack_frame.translator_id
	anq	check_bit,dl
	tze	MAIN_ext_join
	eaa	-first_local_place,x7
	als	2
	mlr	(pr),(pr,rl),fill(040)
	desc9a	6|first_local_place,0
	desc9a	6|first_local_place,au
MAIN_ext_join:
	epaq	3|0
	lprp4	7|stack_header.lot_ptr,*au
	spri4	6|linkage_ptr	"linkage_ptr" in new stack frame
	spri5	6|stack_frame.entry_ptr	"entry_ptr" of new stack frame
	spri2	6|stack_frame.operator_ptr	"operator_ptr" in new stack frame
	epp0	2|0		PR0 -> pascal operators
	epp1	null_ptr,*
	spri1	6|dlinkw
	epbp1	3|0
	spri1	6|stack_frame.return_ptr
	ldi	0,dl		reset indicators
	tra	3|2		return to procedure
"
"
"
"
"		entry operator for internal procedures
"		--------------------------------------
"
"	assumed that:     (PASCAL internal convention)
"		PR0 -> pascal operators
"		PR1 -> dynamic link
"		PR2 -> argument list
"		PR4 -> linkage section
"		PR6 -> stack frame of the calling procedure
"		PR7 -> stack header
"
"	calling sequence:
"		epp5	0,ic		get ptr to the entry point
"		eax7	[stack_frame size in words (n * 16)]
"		tsp3	0|52
"
"	returns:
"		PR0 , PR6 not changed
"		PR6 -> stack frame of the procedure
"
int_entry:
	inhibit	on
	eaa	7|stack_header.stack_end_ptr,*
	spri6	7|stack_frame.prev_sp,au
	spri2	7|stack_frame.arg_ptr,au
	epp2	6|stack_frame.next_sp,*x7
	spri2	7|stack_frame.next_sp,au
	lda	6|stack_frame.translator_id
	epp6	7|stack_header.stack_end_ptr,*
	spri2	7|stack_header.stack_end_ptr
	inhibit	off
	ana	non_MAIN_mask
	sta	6|stack_frame.translator_id
	ana	check_bit,dl
	tze	skip_int_init
	eaa	-first_local_place,x7
	als	2
	mlr	(pr),(pr,rl),fill(040)
	desc9a	pr6|first_local_place,0
	desc9a	pr6|first_local_place,au
skip_int_init:
	spri1	6|dlinkw
	spri4	6|linkage_ptr
	spri0	6|stack_frame.operator_ptr
	spri5	6|stack_frame.entry_ptr
	epbp1	3|0
	spri1	6|stack_frame.return_ptr
	ldi	0,dl
	tra	3|2
"
"
"
"
"	*****************************************************
"	*					  *
"	*	ENTRY OPERATORS DEALING WITH TRACE        *
"	*					  *
"	*****************************************************
"
"
"
"		trace_MAIN_ext_entry operator
"		-----------------------------
"
"
trace_MAIN_entry:
	epp2	7|stack_header.stack_end_ptr,*
	sprp5	2|0
	stq	2|1
	eax5	3|0
	stx5	2|1
"
"	At this moment, first two words of next stack frame, saved by trace,
"	contain:
"		packed ptr to entry point (1 word. required by trace)
"		offset of next word in calling object (1 half word)
"		PASCAL execution flags (1 half word)
"
"	Trace is supposed to restore x7, pr6, pr0, pr7
"
	epaq	0,ic
	lprp4	7|stack_header.lot_ptr,*au
	tsp2	<trace>|[catch_pl1_]
"
	epp2	7|stack_header.stack_end_ptr,*
	spri6	2|stack_frame.prev_sp
	spri0	2|stack_frame.arg_ptr
	epp0	2|0,7
	spri0	2|stack_frame.next_sp
	spri0	7|stack_header.stack_end_ptr
	epp6	2|0
	lda	6|1
	ana	-1,dl
	ada	my_id,du
	sta	6|stack_frame.translator_id
	tra	trace_MAIN_ext_join
"
"
"
"
trace_ext_entry:
	epp2	7|stack_header.stack_end_ptr,*
	sprp5	2|0
	stq	2|1
	eax5	3|0
	stx5	2|1
"
"	At this moment, first two words of next stack frame, saved by trace,
"	contain:
"		packed ptr to entry point (1 word. required by trace)
"		offset of next word in calling object (1 half word)
"		PASCAL execution flags (1 half word)
"
"	Trace is supposed to restore x7, pr6, pr0, pr7
"
	epaq	0,ic
	lprp4	7|stack_header.lot_ptr,*au
	tsp2	<trace>|[catch_pl1_]
"
	epp2	7|stack_header.stack_end_ptr,*
	spri6	2|stack_frame.prev_sp
	spri0	2|stack_frame.arg_ptr
	epp0	2|0,7
	spri0	2|stack_frame.next_sp
	spri0	7|stack_header.stack_end_ptr
	epp6	2|0
	lda	6|1
	ana	-1,dl
	ada	my_id,du
	sta	6|stack_frame.translator_id
	ana	check_bit,dl
	tze	trace_MAIN_ext_join
	eaa	-first_local_place,x7
	als 2
	mlr	(pr),(pr,rl),fill(040)
	desc9a	pr6|first_local_place,0
	desc9a	pr6|first_local_place,au
trace_MAIN_ext_join:
	lprp3	6|0
	spri3	6|stack_frame.entry_ptr
	epaq	3|0
	lprp4	7|stack_header.lot_ptr,*au
	spri4	6|linkage_ptr
	epp0	trace_transfer_vector
	spri0	6|stack_frame.operator_ptr
	epp1	null_ptr,*
	spri1	6|dlinkw
	epbp3	3|0
	spri3	6|stack_frame.return_ptr
	ldx6	6|1
	ldi	0,dl
	tra	3|2,x6
entry_operators_end:
"
"	********************************
"	*			 *
"	*        CALL OPERATORS        *
"	*			 *
"	********************************
"
"
"
"
"		call operator for internal procedures
"		-------------------------------------
"
"	assumed that:
"		PR1 -> dynamic link
"
"	calling sequence:
"		eax1	6|[offset of the arg list in the stack frame]
"		fld	1024*n,dl 	if n = nbr of args
"		epp5	4|[offset of the link to the called proc in the link section]
"		tsp3	0|42
"
"	returns:     (via int_return)
"		PR0 , PR4 , PR6 : not modified
"		PR7 -> stack_header
"		eventually: [E,A,Q] = value
"
int_call:
	epbp7	6|0		restore PR7 (stack base ptr)
	ora	4,dl		code for arg list header
	staq	7|0,x1		store arg list header
	spri3	6|stack_frame.return_ptr	"return ptr" in current frame
	epp2	7|0,x1		PR2 points to the arg list
	call6	5|0		call now the proc
"
"
"
"
"		call operator for DEF (exportable) or REF (imported) procedures
"		---------------------------------------------------------------
"
"	calling sequence:
"		eax1	6|[offset of the arg list in the stack frame]
"		fld	2024*n,dl 	if n = nbr of args
"		epp5	4|[offset of the link to the called proc in the link section]
"		tsp3	0|43
"
"	returns:     - from DEF procedures via ext_return
"		PR0 , PR4 , PR6 : not modified
"		PR7 -> stack header
"
"		   - from REF procedures via standard Multics return :
"		PR0 , PR6 : not modified
"		PR7 -> stack_header
"		PR4 may have been modified and MUST be restored by generated code
"
ext_call:
	epbp7	6|0		restore PR7 (stack base ptr)
	ora	4,dl		code for arg list header
	staq	7|0,x1		store arg list header
	spri3	6|stack_frame.return_ptr	save "return ptr" in current frame
	spri0	6|stack_frame.operator_ptr
	epp0	7|0,x1		PR0 points to the arg list
	call6	5|0		call now the proc
"
"	**********************************
"	*			   *
"	*        RETURN OPERATORS        *
"	*   			   *
"	**********************************
"
"
"
"		return from internal procedures
"		-------------------------------
"
"	MUST NOT MODIFY E,A,Q AND ZERO AND NEGATIVE INDICATORS
"
"	calling sequence:
"		tra	0|39
"
"	Returns to the calling procedure (in the same segment)
"	PR0 , PR4 no to modify  -  PR6 to reset
"
int_return:
	epbp7	6|0		PR7 -> stack header
	inhibit on
	spri6	7|stack_header.stack_end_ptr	new stack end
	epp6	6|stack_frame.prev_sp,*	rPR6 -> stack frame of calling
	inhibit off
	rtcd	6|stack_frame.return_ptr	return to calling proc
"
"
"
"
"		return from exportable procedures and MAIN
"		------------------------------------------
"
"	MUST NOT MODIFY E,A,Q AND ZERO AND NEGATIVE INDICATORS
"
"	calling sequence :
"		tra	0|40
"
"	Returns from exportable procedures (standard Multics return)
"
ext_return:
	epbp7	6|0		PR7 -> current stack header
	inhibit on
	spri6	7|stack_header.stack_end_ptr
	epp6	6|stack_frame.prev_sp,*
	inhibit off
	epbp7	6|0		previous stack header
	epp0	6|stack_frame.operator_ptr,*	restore PR0 to previous ops ptr
	rtcd	6|stack_frame.return_ptr	return to caller
"
"
"
"		go_to_exit operator
"		-------------------
"
"	assumed that:
"		PR1 -> stack of the procedure in which to return
"		PR2 -> addr where to return
"
"	calling sequence:
"		tsp3	0|25
"
"	   Returns to the given addr at the given level,
"	using the Multics unwinder
"
go_to_exit:
	spri2	6|arg_1
	spri0	1|stack_frame.operator_ptr
	spri1	6|arg_1+2		label.frame
	epaq	0		to get my seg nbr
	epbp7	6|0
	lprp4	7|stack_header.lot_ptr,*au	to get PR4 -> my link section
	epp1	<unwinder_>|[unwinder_]		link to the unwinder
	tra	common_op_call	call the Multics unwinder
"
"
"
"
"		go_to_exit_ext operator
"		-----------------------
"
"	assumed that:
"		PR1 -> entry point of the PRocedure in which to return
"		PR2 -> addr where to return (PASCAL label)
"
"	calling sequence:
"		tsp3	0|3
"
"	   Returns to the given procedure, at the given label.
"	Checks if this procedure is active.
"
go_to_exit_ext:
	spri2	6|arg_1		label.addr
	spri1	6|arg_1+2
	ldaq	6|arg_1+2
	epbp7	6|0
	eax1	6|0
go_to_loop:
	eax1	7|stack_frame.prev_sp,x1*
	cmpx1	1,du		previous is null ?
	tnz	go_to_previous
	epp1	<pascal_errors_>|[go_to_exit_error]
	tra	common_op_call
go_to_previous:
	cmpaq	7|stack_frame.entry_ptr,x1
	tnz	go_to_loop
	epp1	7|0,x1		stack frame in which to return
	spri1	6|arg_1+2
	spri0	1|stack_frame.operator_ptr
	epaq	0		get our lp
	lprp4	7|stack_header.lot_ptr,*au
	epp1	<unwinder_>|[unwinder_]
	tra	common_op_call
"
"
"
"
"		STOP_short operator
"		-------------------
"
"	assumed that:
"		PR2 -> return sequence of MAIN
"		A = return code
"
"	calling sequence:
"		tsp3	0|76
"
"	returns from MAIN after setting return code if any in arg list.
"
STOP_short:
	epp3	6|stack_frame.arg_ptr,*
	ldq	3|1
	tze	STOP_short_return
	eax1	0,qu
	qls	1
	eax2	0,qu
	lxl4	3|0
	anx4	8+2,du
	tze	+2,ic
	eax2	2,x2
	ldq	3|0,x2*
	anq	neg_mask
	cmpq	fb35_desc
	tnz	STOP_short_return
	sta	3|0,x1*
STOP_short_return:
	tra	2|0		transfer to return sequence.
"
"
"
"
"		STOP operator
"		-------------
"
"	assumed that:
"		PR1 -> stack frame of MAIN
"		PR2 -> return sequence of MAIN
"		A = return code
"
"	calling sequence:
"		tsp3	0|77
"
"	returns from MAIN after setting return code if any in arg list
"
STOP:
	epp3	1|stack_frame.arg_ptr,*
STOP_join:
	ldq	3|1
	tze	STOP_return
	eax1	0,qu
	qls	1
	eax2	0,qu
	lxl4	3|0
	anx4	8+2,du
	tze	+2,ic
	eax2	2,x2
	ldq	3|0,x2*
	anq	neg_mask
	cmpq	fb35_desc
	tnz	STOP_return
	sta	3|0,x1*
STOP_return:
	tra	go_to_exit
"
"
"
"
"		STOP_ext operator
"		-----------------
"
"	assumed that:
"		PR1 -> entry point of MAIN
"		PR2 -> return sequence of MAIN
"		A = return code
"
"	calling sequence:
"		tsp3	0|78
"
"	returns from MAIN after setting return code if any in arg list
"
STOP_ext:
	sta	6|op_work+2
	spri1	6|op_work+0
	ldaq	6|op_work+0
	epbp7	6|0
	eax1	6|stack_frame.prev_sp,*
STOP_loop:
	cmpaq	7|stack_frame.entry_ptr,x1
	tze	STOP_main_found
	eax1	7|stack_frame.prev_sp,x1*
	cmpx1	1,du
	tnz	STOP_loop
	epp1	<pascal_errors_>|[STOP_error]
	tra	common_op_call
STOP_main_found:
	epp1	7|0,x1
	lda	6|op_work+2
	tra	STOP
"
"
"
"
"	*******************************
"	*       			*
"	*        I/O OPERATORS        *
"	*			*
"	*******************************
"
"	   All the PASCAL I/O operators are written in PL/1 ("pascal_io_.pl1")
"	The following alm sequences are call and return interfaces between
"	the PASCAL generated code and these PL/1 procedures .
"
"	   The parameter list to transmit has the following structure and location :
"
"		6|op_args+0 : arg list header (2 words)
"		6|op_args+2 : arg ptr (2 words - points to 6|op_args+4)
"		6|op_args+4 : block_ptr (2 words)
"		6|op_args+6 : two_words_value (2 words (!))
"		6|op_args+8 : type (1 word)
"		6|op_args+9 : io_length (1 word)
"		6|op_args+10 : size (1 word)
"		6|op_args+12 : stack_frame ptr (2 words)
"
"	(for the meaning and use of these parameters see "pascal_io_.pl1" source)
"
"
"
"		init_fsb_alloc operator
"		-----------------------
"
"	assumed that:
"		6|io_block_ptr contains addr of fsb pointer
"		A = file type :
"		     1 : record permanent
"		     2 : text permanent
"		     3 : record static
"		     4 : text static
"		     5 : record local
"		     6 : text local
"		Q = size (bytes) of record or text buffer
"		x1 = 1 : single file
"		   > 1 nbr of elements of array
"		PR2 -> nom of single file (8 chars)
"		       or array or names (32 chars) of elements of array.
"
"	calling sequence:
"		tsp3	0|72
"
"	Initializes (after allocation if necessary) PASCAL fsb.
"
init_fsb_alloc:
	sta	6|io_type
	stq	6|io_length
	stz	6|io_dim
	sxl1	6|io_dim
	spri2	6|io_two_words_value
	spri6	6|io_stack_frame_ptr
	spri4	6|io_linkage_ptr
check_fsb_links:
	ldaq	6|io_block_ptr,*
	anaq	tag_mod_mask
	cmpaq	unsnap_ind
	tnz	fsb_link_ok
	ldaq	6|io_block_ptr,*
	anq	non_mod_mask
	staq	6|io_block_ptr,*
	epp1	6|io_block_ptr,*
	epp1	1|0,*
	spri1	6|io_block_ptr,*
	ldaq	6|io_block_ptr,*
	orq	16,dl
	staq	6|io_block_ptr,*
	spri1	6|io_block_ptr
	tra	check_fsb_links
fsb_link_ok:
	epp1	<pascal_io_>|[init_fsb_alloc]
	tra	common_op_call
"
"init_fsb_alloc_return:
"	tra	common_op_return
"
"
"
"
"		connect operator
"		----------------
"
"	assumed that:
"		6|io_block_ptr contains the ptr to the pascal file
"		PR2 -> string (name of the target segment)
"		A = length of the string
"
"	calling sequence:
"		tsp3	0|36
"
connect_call:
	spri6	6|io_stack_frame_ptr
	spri2	6|io_type
	sta	6|io_size
	epp1	<pascal_io_>|[connect]
	tra 	common_op_call
"
"connect_return:
"	tra	common_op_return
"
"
"
"
"		RESET_file operator
"		-------------------
"
"	assumed that:
"		6|io_block_ptr contains the ptr to the PASCAL file fsb
"
"	calling sequence:
"		tsp3	0|11
"
RESET_file_call:
	epp1	<pascal_io_>|[RESET]	PL/1 entry point
	spri6	6|io_stack_frame_ptr
	tra	common_op_call
"
"RESET_file_return:
"	tra	common_op_return
"
"
"
"
"		REWRITE operator
"		----------------
"
"	assumed that:
"		6|io_block_ptr contains the ptr to the PASCAL file fsb
"
"	calling sequence:
"		tsp3	0|12
"
REWRITE_call:
	epp1	<pascal_io_>|[REWRITE]	PL/1 entry point
	spri6	6|io_stack_frame_ptr
	tra	common_op_call
"
"REWRITE_return:
"	tra	common_op_return
"
"
"
"
"		fclose operator
"		--------------
"
"	assumed that:
"		6|io_block_ptr contains the ptr to the PASCAL file fsb
"
"	calling sequence:
"		tsp3	0|37
"
fclose_call:
	epp1	<pascal_io_>|[fclose]	PL/1 entry point
	tra	common_op_call
"
"fclose_return:
"	tra	common_op_return
"
"
"
"
"		close operator
"		-------------------
"
"	assumed that:
"		6|io_block_ptr contains the ptr to the PASCAL file fsb
"
"	calling_sequence:
"		tsp3	0|13
"
close_call:
	spri6	6|io_stack_frame_ptr
	epp1	<pascal_io_>|[close]
	tra	common_op_call
"
"close_return:
"	tra	common_op_return
"
"
"
"
"		READ_text operator
"		------------------
"
"	assumed that:
"		6|io_block_ptr contains the ptr to the PASCAL file fsb
"		A contains the type code of the object to read
"
"	calling sequence:
"		tsp3	0|14
"
READ_text:
	cmpa	1,dl		READ(char)
	tnz	READ_text_call
	epp1	6|io_block_ptr,*		fsb_ptr,*
	ldq	1|fsb.flags		open ?
	anq	fsb.flags.open,dl
	tze	READ_text_call
	ldq	1|fsb.file_status		input ?
	cmpq	<pascal_codes_>|[input_mode]
	tnz	READ_text_call
	ldq	1|fsb.flags		get to do ?
	anq	fsb.flags.get_next_char,dl
	tnz	READ_text_call
	ldq	1|fsb.eof			eof ?
	tnz	READ_text_call
READ_text_common:
	ldq	1|fsb.buff_index		buffer empty ?
	cmpq	1|fsb.buff_max
	tze	fast_READ_text_call
	adq	1,dl
	stq	1|fsb.buff_index
	lda	1|fsb.window
	stz	1|fsb.window
	mlr	(pr,ql),(pr)
	desc9a	1|fsb.buffer-1(3),1
	desc9a	1|fsb.window(3),1
	ldq	1|fsb.window
	cmpq	=o000012,dl		RC ?
	tze	READ_text_eoln
	stz	1|fsb.eoln
	tra	3|0		return to caller
READ_text_eoln:
	ldq	1,dl
	stq	1|fsb.eoln
	aos	1|fsb.record_counter
	ldq	=o000040,dl		space
	stq	1|fsb.window
	tra	3|0		return to caller
"
fast_READ_text:
	cmpa	1,dl
	tnz	fast_READ_text_call
	epp1	6|io_block_ptr,*
	ldq	1|fsb.flags
	anq	fsb.flags.get_next_char,dl
	tnz	fast_READ_text_call
	tra	READ_text_common
"
READ_text_call:
	sta	6|io_type
	spri6	6|io_stack_frame_ptr
	epp1	<pascal_io_>|[READ_text]	PL/1 entry point
	tra	common_op_call
"
fast_READ_text_call:
	sta	6|io_type
	spri6	6|io_stack_frame_ptr
	epp1	<pascal_io_>|[fast_READ_text]	PL/1 entry point
	tra	common_op_call
"
READ_text_return:
	epbp7	6|0
	inhibit on
	spri6	7|stack_header.stack_end_ptr
	epp6	6|stack_frame.prev_sp,*
	inhibit off
	epp0	6|stack_frame.operator_ptr,*
	epaq	6|stack_frame.entry_ptr,*
	lprp4	7|stack_header.lot_ptr,*au
	lda	6|io_type
	cmpa	8,dl
	tze	READ_real
	lda	6|io_two_words_value
	rtcd	6|stack_frame.return_ptr
READ_real:
	dfld	6|io_two_words_value
	rtcd	6|stack_frame.return_ptr
"
"
"
"
"		READ_sequential operator
"		------------------------
"
"	assumed that :
"		6|io_block_ptr contains the ptr to the PASCAL file fsb
"		PR1 contains the addr of the user field to fill
"
"	calling sequence:
"		tsp3	0|15
"
READ_sequential_call:
	spri1	6|io_two_words_value
	epp1	<pascal_io_>|[READ_sequential]	PL/1 entry point
	spri6	6|io_stack_frame_ptr
	tra	common_op_call
"
fast_READ_sequential_call:
	spri1	6|io_two_words_value
	epp1	<pascal_io_>|[fast_READ_sequential]	PL/1 entry point
	spri6	6|io_stack_frame_ptr
	tra	common_op_call
"
"READ_sequential_return:
"	tra	common_op_return
"
"
"
"
"		READLN operator
"		---------------
"
"	assumed that:
"		6|io_block_ptr contains the ptr to the PASCAL file fsb
"
"	calling sequence:
"		tsp3	0|16
"
READLN_call:
	spri6	6|io_stack_frame_ptr
	epp1	<pascal_io_>|[READLN]	pl/1 entry point
	tra	common_op_call
"
fast_READLN_call:
	spri6	6|io_stack_frame_ptr
	epp1	<pascal_io_>|[fast_READLN]	pl/1 entry point
	tra	common_op_call
"
"READLN_return:
"	tra	common_op_return
"
"
"
"
"		WRITE_text operator
"		-------------------
"
"	assumed that:
"		6|io_block_ptr contains ptr to the PASCAL file fsb
"		A contains the type of the value to write
"		6|io_length contains the desired length of the output
"		6|io_size contains :
"			- length of the string if type = 32
"			- nbr of dec digits if type = 16
"
"	calling sequence:
"		tsp3	0|17
"
WRITE_text:
	cmpa	1,dl		WRITE(char)
	tnz	WRITE_text_call
	cmpa	6|io_length
	tnz	WRITE_text_call
	epp1	6|io_block_ptr,*		fsb_ptr
	ldq	1|fsb.flags		open ?
	anq	fsb.flags.open,dl
	ldq	1|fsb.flags
	anq	fsb.flags.interactive_file,dl
	tnz	WRITE_text_call
	tze	WRITE_text_call
	ldq	1|fsb.file_status		output?
	cmpq	<pascal_codes_>|[output_mode]
	tnz	WRITE_text_call
	tra	WRITE_text_common
"
fast_WRITE_text:
	cmpa	1,dl
	tnz	fast_WRITE_text_call
	cmpa	6|io_length
	tnz	fast_WRITE_text_call
	epp1	6|io_block_ptr,*
WRITE_text_common:
	ldq	1|fsb.buff_index
	cmpq	1|fsb.buff_len
	tze	fast_WRITE_text_call
	lda	6|io_two_words_value
	sta	1|fsb.window
	tra	PUT_text_common
"
WRITE_text_call:
	sta	6|io_type
	epp1	<pascal_io_>|[WRITE_text]	PL/1 entry point
	spri6	6|io_stack_frame_ptr
	tra	common_op_call
"
fast_WRITE_text_call:
	sta	6|io_type
	epp1	<pascal_io_>|[fast_WRITE_text]	PL/1 entry point
	spri6	6|io_stack_frame_ptr
	tra	common_op_call
"
"WRITE_text_return:
"	tra	common_op_return
"
"
"
"
"		WRITE_sequential operator
"		-------------------------
"
"	assumed that:
"		6|io_block_ptr contains the ptr to the PASCAL file fsb
"		A contains the type of the value to write
"		6|io_two_words_value contains :
"			- value to write (if type = 1, 2, 4, 8)
"			- ptr to the string (if type = 32)
"			- ptr to the field to write (if type = 64)
"
WRITE_sequential_call:
	sta	6|io_type
	epp1	<pascal_io_>|[WRITE_sequential]	PL/1 entry point
	tra	common_op_call
"
fast_WRITE_sequential_call:
	sta	6|io_type
	epp1	<pascal_io_>|[fast_WRITE_sequential]	PL/1 entry point
	tra	common_op_call
"
"WRITE_sequential_return:
"	tra	common_op_return
"
"
"
"
"		check_before_EOF
"		check_before_EOLN
"		check_before_text_reference operators
"		-------------------------------------
"
"	Assumed that :
"		PR5 contains addr of PASCAL fsb
"
"	Calling sequence :
"		tsp3	0|{op number}
"
check_before_EOF:
check_before_EOLN:
check_before_text_reference:
	staq	6|save_regs
	lda	5|fsb.flags
	ana	fsb.flags.get_next_char,dl
	tnz 	defered_GET
	lda	6|save_regs
	tra	3|0		return to caller
defered_GET:
	lda	5|fsb.flags
	ana	fsb.flags.open,dl
	tze	defered_GET_text_call
	lda	5|fsb.file_status		input ?
	cmpa	<pascal_codes_>|[input_mode]
	tnz	defered_GET_text_call
	lda	5|fsb.eof			eof ?
	tnz	defered_GET_text_call
	lda	5|fsb.buff_index		buffer empty ?
	cmpa	5|fsb.buff_max
	tze	fast_defered_GET_text_call
	ada	1,dl
	sta	5|fsb.buff_index
	stz	5|fsb.window
	mlr	(pr,al),(pr)
	desc9a	5|fsb.buffer-1(3),1
	desc9a	5|fsb.window(3),1
	lda	5|fsb.window
	cmpa	=o000012,dl		RC ?
	tze	defered_GET_text_eoln
	stz	5|fsb.eoln
	lda	non_get_next_char_mask
	ansa	5|fsb.flags
	lda	6|save_regs
	tra	3|0		return to caller
defered_GET_text_eoln:
	lda	1,dl
	sta	5|fsb.eoln
	aos	5|fsb.record_counter
	lda	=o000040,dl		space
	sta	5|fsb.window
	lda	non_get_next_char_mask
	ansa	5|fsb.flags
	lda	6|save_regs
	tra	3|0		return to caller
"
defered_GET_text_call:
	spri	6|op_work
	ldaq	6|io_block_ptr
	staq	6|save_fsb_addr		save it if in io statement
	spri5	6|io_block_ptr
	ldaq	6|save_regs
	sreg	6|save_regs
	epp1	<pascal_io_>|[defered_GET_text]	PL/1 entry point
	tra	common_op_call
"
fast_defered_GET_text_call:
	spri	6|op_work
	ldaq	6|io_block_ptr
	staq	6|save_fsb_addr		save it if in io statement
	spri5	6|io_block_ptr
	ldaq	6|save_regs
	sreg	6|save_regs
	epp1	<pascal_io_>|[fast_defered_GET_text]	PL/1 entry point
	tra	common_op_call
"
defered_GET_text_return:
	epbp7	6|0
	inhibit	on
	spri6	7|stack_header.stack_end_ptr
	epp6	6|stack_frame.prev_sp,*
	inhibit	off
	ldaq	6|save_fsb_addr
	staq	6|io_block_ptr
	lpri	6|op_work
	lreg	6|save_regs
	rtcd	6|stack_frame.return_ptr
"
"
"
"
"		FLUSH operator
"		--------------
"
"	assumed that :
"		6|io_block_ptr contains the ptr to the PASCAL file fsb
"
"	calling sequence:
"		tsp3	0|65
"
FLUSH_call:
	epp1	<pascal_io_>|[FLUSH]	PL/1 entry point
	tra	common_op_call
"
fast_FLUSH_call:
	epp1	<pascal_io_>|[fast_FLUSH]	PL/1 entry point
	tra	common_op_call
"
"FLUSH_return:
"	tra	common_op_return
"
"
"
"
"		WRITELN operator
"		----------------
"
"	assumed that :
"		6|io_block_ptr contains the ptr to the PASCAL file fsb
"
"	calling sequence:
"		tsp3	0|19
"
WRITELN_call:
	epp1	<pascal_io_>|[WRITELN]	PL/1 entry point
	tra	common_op_call
"
fast_WRITELN_call:
	epp1	<pascal_io_>|[fast_WRITELN]	PL/1 entry point
	tra	common_op_call
"
"WRITELN_return:
"	tra	common_op_return
"
"
"
"
"		PAGE operator
"		-------------
"
"	assumed that:
"		6|io_block_ptr contains the ptr to the PASCAL file fsb
"
"	calling sequence:
"		tsp3	0|20
"
PAGE_call:
	epp1	<pascal_io_>|[PAGE]		PL/1 entry point
	tra	common_op_call
"
fast_PAGE_call:
	epp1	<pascal_io_>|[fast_PAGE]		PL/1 entry point
	tra	common_op_call
"
"PAGE_return:
"	tra	common_op_return
"
"
"
"
"		PUT_text operator
"		-----------------
"
"	assumed that:
"		6|io_block_ptr contains the ptr to the PASCAL file fsb
"
"	calling sequence:
"		tsp3	0|21
"
PUT_text:
	epp1	6|io_block_ptr,*		fsb_ptr
	lda	1|fsb.flags		interactive ?
	ana	fsb.flags.interactive_file,dl
	tnz	PUT_text_call
	lda	1|fsb.flags		open ?
	ana	fsb.flags.open,dl
	tze	PUT_text_call
	lda	1|fsb.file_status		output ?
	cmpa	<pascal_codes_>|[output_mode]
	tnz	PUT_text_call
	ldq	1|fsb.buff_index
	cmpq	1|fsb.buff_len
	tze	fast_PUT_text_call
PUT_text_common:
	adq	1,dl
	mlr	(pr),(pr,ql)
	desc9a	1|fsb.window(3),1
	desc9a	1|fsb.buffer-1(3),1
	stq	1|fsb.buff_index
	tra	3|0		return to caller
"
fast_PUT_text:
	epp1	6|io_block_ptr,*		fsb_ptr
	ldq	1|fsb.buff_index
	cmpq	1|fsb.buff_len
	tze	fast_PUT_text_call
	tra	PUT_text_common
"
PUT_text_call:
	epp1	<pascal_io_>|[PUT_text]	PL/1 entry point
	tra	common_op_call
"
fast_PUT_text_call:
	epp1	<pascal_io_>|[fast_PUT_text]	PL/1 entry point
	tra	common_op_call
"
"PUT_text_return:
"	tra	common_op_return
"
"
"
"
"		PUT_sequential operator
"		-----------------------
"
"	assumed that:
"		6|io_block_ptr contains the ptr to the PASCAL file fsb
"
"	calling sequence:
"		tsp3	0|22
"
PUT_sequential_call:
	epp1	<pascal_io_>|[PUT_sequential]		PL/1 entry point
	tra	common_op_call
"
fast_PUT_sequential_call:
	epp1	<pascal_io_>|[fast_PUT_sequential]		PL/1 entry point
	tra	common_op_call
"
"PUT_sequential_return:
"	tra	common_op_return
"
"
"
"
"		GET_text operator
"		-----------------
"
"	assumed that:
"		6|io_block_ptr contains the ptr to the PASCAL file fsb
"
"	calling sequence:
"		tsp3	0|23
"
GET_text:
	epp1	6|io_block_ptr,*		fsb_ptr
	lda	1|fsb.flags		open ?
	ana	fsb.flags.open,dl
	tze	GET_text_call
	lda	1|fsb.file_status		input ?
	cmpa	<pascal_codes_>|[input_mode]
	tnz	GET_text_call
	lda	1|fsb.eof			eof ?
	tnz	GET_text_call
GET_text_common:
	lda	1|fsb.buff_index		buffer empty ?
	cmpa	1|fsb.buff_max
	tze	fast_GET_text_call
	ada	1,dl
	sta	1|fsb.buff_index
	stz	1|fsb.window
	mlr	(pr,al),(pr)
	desc9a	1|fsb.buffer-1(3),1
	desc9a	1|fsb.window(3),1
	lda	1|fsb.window
	cmpa	=o000012,dl		RC ?
	tze	GET_text_eoln
	stz	1|fsb.eoln
	tra	3|0		return to caller
GET_text_eoln:
	lda	1,dl
	sta	1|fsb.eoln
	aos	1|fsb.record_counter
	lda	=o000040,dl		space
	sta	1|fsb.window
	tra	3|0		return to caller
"
fast_GET_text:
	epp1	6|io_block_ptr,*
	tra	GET_text_common
"
GET_text_call:
	spri6	6|io_stack_frame_ptr
	epp1	<pascal_io_>|[GET_text]	PL/1 entry point
	tra	common_op_call
"
fast_GET_text_call:
	spri6	6|io_stack_frame_ptr
	epp1	<pascal_io_>|[fast_GET_text]	PL/1 entry point
	tra	common_op_call
"
"GET_text_return:
"	tra	common_op_return
"
"
"
"
"		GET_sequential operator
"		-----------------------
"
"	assumed that:
"		6|io_block_ptr contains the ptr to the PASCAL file fsb
"
"	calling sequence:
"		tsp3	0|24
"
GET_sequential_call:
	epp1	<pascal_io_>|[GET_sequential]		PL/1 entry point
	spri6	6|io_stack_frame_ptr
	tra	common_op_call
"
fast_GET_sequential_call:
	epp1	<pascal_io_>|[fast_GET_sequential]		PL/1 entry point
	spri6	6|io_stack_frame_ptr
	tra	common_op_call
"
"GET_sequential_return:
"	tra	common_op_return
"
"
"
"
"		GET_direct operator
"		-------------------
"
"	assumed that:
"		6|io_block_ptr contains the ptr of the PASCAL file fsb
"		A contains the page number
"
"	calling sequence:
"		tsp3	0|34
"
GET_direct_call:
	sta	6|io_two_words_value
	epp1	<pascal_io_>|[GET_direct]
	spri6	6|io_stack_frame_ptr
	tra	common_op_call
"
fast_GET_direct_call:
	sta	6|io_two_words_value
	epp1	<pascal_io_>|[fast_GET_direct]
	spri6	6|io_stack_frame_ptr
	tra	common_op_call
"
"
"GET_direct_return:
"	tra	common_op_return
"
"
"
"		PUT_direct operator
"		-------------------
"
"	assumed that:
"		6|io_block_ptr contains the ptr to the PASCAL file fsb
"		A contains the page number
"
"	calling sequence:
"		tsp3	0|33
"
PUT_direct_call:
	sta	6|io_two_words_value
	epp1	<pascal_io_>|[PUT_direct]
	tra	common_op_call
"
fast_PUT_direct_call:
	sta	6|io_two_words_value
	epp1	<pascal_io_>|[fast_PUT_direct]
	tra	common_op_call
"
"PUT_direct_return:
"	tra	common_op_return
"
"
"
"
"		open_update operator
"		--------------------
"
"	assumed that:
"		6|io_block_ptr contains a ptr to the PASCAL file fsb
"
"	calling sequence:
"		tsp3	0|35
"
open_update_call:
	epp1	<pascal_io_>|[open_update]
	spri6	6|io_stack_frame_ptr
	tra	common_op_call
"
"open_update_return:
"	tra	common_op_return
"
"
"
"
"
"
"
"
"	************************
"	*		   *
"	* STRING I/O OPERATORS *
"	*		   *
"	************************
"
"
"	constants
"
	equ	sio_addr,0
	equ	sio_maxlen,2
	equ	sio_index,3
	equ	sio_value,4
	equ	sio_output_length,6
	equ	sio_scale,7
	equ	sio_size,7
	equ	sio_subindex,8
	equ	sio_stack_ptr,10
"
"
minus_one:
	dec	-1
vrai_string:
	aci	"VRAI"
faux_string:
	aci	"FAUX"
false_string:
	aci	"FALSE"
true_string:
	aci	"TRUE"
"
"
"
"
"		SREAD_char operator
"		-------------------
"
"	assumed that:
"		PR1 -> parameter structure
"
"	calling sequence:
"		tsp3	0|90
"
"
SREAD_char:
	ldq	1|sio_index
	tmoz	sio_error
	cmpq	1|sio_maxlen
	tpl	sio_error
	sbq	1,dl
	epp2	1|sio_addr,*
	a9bd	2|0,ql
	mrl	(pr),(pr),fill(000)
	desc9a	2|0,1
	desc9a	1|sio_value,4
	lda	1|sio_value
	adq	2,dl
	stq	1|sio_index
	tra	3|0
"
"
"
"
"		SREAD_real operator
"		-------------------
"
"	assumed that:
"		PR1 -> parameter structure
"
"	calling sequence:
"		tsp3	0|92
"
"
SREAD_real:
	epp2	<pascal_io_>|[SREAD_real]
	tra	common_sio_call
"
"
"
"
"		SREAD_integer operator
"		----------------------
"
"	assumed that:
"		PR1 -> parameter structure
"
"	calling sequence:
"		tsp3	0|91
"
"
SREAD_integer:
	epp2	<pascal_io_>|[SREAD_integer]
	tra	common_sio_call
"
"
	macro	swrite_begin
	ldq	1|sio_index
	tmoz	sio_error
	cmpq	1|sio_maxlen
	tpnz	sio_error
	epp2	1|sio_addr,*
	sbq	1,dl
	a9bd	2|0,ql
	adq	1|sio_output_length
	cmpq	1|sio_maxlen
	tpnz	sio_error
	ldq	1|sio_output_length
	&end
"
"
	macro	swrite_end
	asq	1|sio_index
	tra	3|0
	&end
"
"
"
"
"		SWRITE_char operator
"		--------------------
"
"	assumed that:
"		PR1 -> parameter structure
"
"	calling sequence:
"		tsp3	0|93
"
"
SWRITE_char:
	swrite_begin
	mrl	(pr),(pr,rl),fill(040)
	desc9a	1|sio_value(3),1
	desc9a	2|0,ql
	swrite_end
"
"
"
"
"		SWRITE_string operator
"		----------------------
"
"	assumed that:
"		PR1 -> parameter structure
"
"	calling sequence:
"		tsp3	0|94
"
"
SWRITE_string:
	swrite_begin
	epp5	1|sio_value,*
	lda	1|sio_size
common_swrite_string:
	cmpa	1|sio_output_length
	tpl	swrite_trunc
	mrl	(pr,rl),(pr,rl),fill(040)
	desc9a	5|0,al
	desc9a	2|0,ql
	tra	swrite_return
swrite_trunc:
	mlr	(pr,rl),(pr,rl),fill(040)
	desc9a	5|0,al
	desc9a	2|0,ql
swrite_return:
	swrite_end
"
"
"
"
"		SWRITE_boolean operator
"		-----------------------
"
"	assumed that:
"		PR1 -> parameter structure
"
"	calling sequence:
"		tsp3	0|96
"
"
SWRITE_boolean:
	swrite_begin
	lda	1|sio_value
	tnz	SWRITE_true
	lda	6|stack_frame.translator_id
	ana	french_bit,dl
	tnz	SWRITE_faux
	lda	5,dl
	epp5	false_string
	tra	common_swrite_string
SWRITE_faux:
	lda	4,dl
	epp5	faux_string
	tra	common_swrite_string
"
"
SWRITE_true:
	cmpa	1,dl
	tnz	sio_error
	lda	6|stack_frame.translator_id
	ana	french_bit,dl
	tnz	SWRITE_vrai
	lda	4,dl
	epp5	true_string
	tra	common_swrite_string
SWRITE_vrai:
	lda	4,dl
	epp5	vrai_string
	tra	common_swrite_string
"
"
"
"
"		SWRITE_substring operator
"		-------------------------
"
"	assumed that:
"		PR1 -> parameter structure
"
"	calling sequence:
"		tsp3	0|95
"
"
SWRITE_substring:
	swrite_begin
	lda	1|sio_subindex
	tmoz	sio_error
	sba	1,dl
	epp5	1|sio_value,*
	a9bd	5|0,al
	lda	1|sio_size
	sba	1|sio_subindex
	tmi	sio_error
	ada	1,dl
	tra	common_swrite_string
"
"
"
"
"		SWRITE_real_e operator
"		----------------------
"
"	assumed that:
"		PR1 -> parameter structure
"
"	calling sequence:
"		tsp3	0|98
"
"
SWRITE_real_e:
	epp2	<pascal_io_>|[SWRITE_real_e]
	tra	common_sio_call
"
"
"
"
"		SWRITE_real_d operator
"		----------------------
"
"	assumed that:
"		PR1 -> parameter structure
"
"	calling sequence:
"		tsp3	0|99
"
"
SWRITE_real_d:
	epp2	<pascal_io_>|[SWRITE_real_d]
	tra	common_sio_call
"
"
"
"
"		SWRITE_integer operator
"		-----------------------
"
"	assumed that:
"		PR1 -> parameter structure
"
"	calling_sequence:
"		tsp3	0|91
"
"
SWRITE_integer:
	epp2	<pascal_io_>|[SWRITE_integer]
	tra	common_sio_call
"
"
"
"
"		SWRITE_enumerated operator
"		--------------------------
"
"	assumed that:
"		PR1 -> parameter structure
"
"	calling_sequence:
"		tsp3	0|100
"
"
SWRITE_enumerated:
	epp2	<pascal_io_>|[SWRITE_enumerated]
	tra	common_sio_call
"
"
"SWRITE_return:
"	tra	common_op_return
"
"
common_sio_call:
	spri6	1|sio_stack_ptr
	spri0	6|stack_frame.operator_ptr
	spri3	6|stack_frame.return_ptr
	spri1	6|arg_ptr
	ldaq	one_arg_header
	staq	6|arg_header
	epp0	6|arg_header
	epbp7	6|0
	call6	2|0
"
"
sio_error:
	lda	minus_one
	sta	1|sio_index
	tra	3|0
"
"
SREAD_integer_return:
	epbp7	6|0
	inhibit on
	spri6	7|stack_header.stack_end_ptr
	epp6	6|stack_frame.prev_sp,*
	inhibit off
	epp0	6|stack_frame.operator_ptr,*
	epaq	6|stack_frame.entry_ptr,*
	lprp4	7|stack_header.lot_ptr,*au
	epp1	6|arg_ptr,*
	lda	1|sio_value
	rtcd	6|stack_frame.return_ptr
SREAD_real_return:
	epbp7	6|0
	inhibit on
	spri6	7|stack_header.stack_end_ptr
	epp6	6|stack_frame.prev_sp,*
	inhibit off
	epp0	6|stack_frame.operator_ptr,*
	epaq	6|stack_frame.entry_ptr,*
	lprp4	7|stack_header.lot_ptr,*au
	epp1	6|arg_ptr,*
	dfld	1|sio_value
	rtcd	6|stack_frame.return_ptr
"
"	*******************************************
"	*				  *
"	*        AREA MANAGEMENT OPERATORS        *
"	*				  *
"	*******************************************
"
"	   All the PASCAL AREA MANAGEMENT operators are written in PL/1
"	("pascal_area_management_.pl1"). The following alm sequences are call
"	and return interfaces between the PASCAL generated code and these
"	PL/1 procedures.
"
"	  The parameter list to transmit has the following structure and location:
"
"		6|op_args+0 : arg_list header (2 words)
"		6|op_args+2 : arg ptr (2 words - points to 6|op_args+4)
"		6|op_args+4 : block_ptr (2 words)
"		6|op_args+6 : block_length (1 word)
"
"	(for meaning and use of these parameters, see "pascal_area_management_" source)
"
"
"
"
"		NEW operator
"		------------
"
"	assumed that:
"		A contains the length (in words) of the requested block
"
"	calling sequence:
"		tsp3	0|26
"
"	returns:
"		A,Q = two words ITS ptr to the allocated block (null if none)
"
NEW:
	sta	6|area_block_length
	lprp2	4|link.symbol_ptr		get ptr to symb section of caller
	epbp7	6|0
	epaq	0,ic
	lprp4	7|stack_header.lot_ptr,*au
	ldaq	2|symbol.object_created		compile_time of caller as unique id
	ldx0	<pascal_operators_statics_>|[area_operators_info]
	lxl1	<pascal_operators_statics_>|[area_operators_info]
	epp2	<pascal_operators_statics_>|[areas]
	rptx	,50
	cmpaq	2|0,x1
	epp2	2|-50,x1
	spri2	6|area_structure_ptr
	eax2	2|area.ptr,*
	tnz	NEW_call
	epp1	2|area.ptr,*	PR1 -> base of area_seg
	ldx0	1|area_seg_header.last_free
	epp5	1|0,x0		PR5 -> last free block
	lxl1	5|area_block_header.previous_blk
	cmpx1	5|area_block_header.previous_free
	tmoz	NEW_call			if block_header was damaged..
	ldq	5|area_block_header.length
	epp7	5|area_block_header_size,ql	PR7 -> next after last free
	spri7	6|op_work+4
	ldaq	6|op_work+4
	cmpaq	1|area_seg_header.last_block
	tnz	NEW_call			if it is not the last block..
	lda	6|area_block_length
	cmpa	5|area_block_header.length
	tpl	NEW_call			if last free is too small
	ana	1,dl
	ada	6|area_block_length
	sta	6|op_work+0			even number of words
	ada	area_block_header_size,dl
	sta	6|op_work+1			total length of new block + header
	cmpa	5|area_block_header.length
	tmi	NEW_free_block
	ldx4	5|area_block_header.previous_free
	stx4	1|area_seg_header.last_free
short_NEW_return:
	ldx5	-1,du
	stx5	5|area_block_header.previous_free
	lxl3	6|area_block_length
	stx3	5|area_block_header.used
	rccl	<sys_info>|[clock_],*
	staq	5|area_block_header.clock
	epp5	5|area_block_header_size		addr of block to be returned
	spri5	6|area_block_ptr
	epbp7	6|0
	epaq	6|stack_frame.entry_ptr,*
	lprp4	7|stack_header.lot_ptr,*au
	spri3	6|stack_frame.return_ptr
	tra	NEW_return_init
NEW_free_block:
	lxl0	6|op_work+1
	epp2	5|0,x0		PR2 -> new last free block
	ldx1	5|area_block_header.previous_free
	stx1	2|area_block_header.previous_free
	eax1	5|0
	sxl1	2|area_block_header.previous_blk
	lda	5|area_block_header.length
	sba	6|op_work+1
	sta	2|area_block_header.length
	eax3	2|0
	sxl3	7|area_block_header.previous_blk
	stx3	1|area_seg_header.last_free
	lxl0	6|op_work+0
	sxl0	5|area_block_header.length
	tra	short_NEW_return
NEW_call:
	epp1	<pascal_area_management_>|[NEW]		PL/1 entry point
	tra	common_op_call
"
NEW_return:
	epbp7	6|0
	inhibit on
	spri6	7|stack_header.stack_end_ptr
	epp6	6|stack_frame.prev_sp,*
	inhibit off
	epp0	6|stack_frame.operator_ptr,*
	epaq	6|stack_frame.entry_ptr,*
	lprp4	7|stack_header.lot_ptr,*au
NEW_return_init:
	lda	6|stack_frame.translator_id
	ana	check_bit,dl
	tze	NEW_skip_init
	eaa	6|area_block_ptr,*
	cmpa	1,du
	tze	NEW_skip_init
	lda	6|area_block_length
	epp5	6|area_block_ptr,*
	als	2
	lrl	18
	cmpa	0,dl
	tze	NEW_short_init
	ldx1	twoto17,du
	als	1
NEW_init_loop:
	mlr	(pr),(pr),fill(040)
	desc9a	5|0,0
	desc9a	5|0,x1
	epp5	5|twoto15
	sba	1,dl
	tnz	NEW_init_loop
NEW_short_init:
	mlr	(pr),(pr,rl),fill(040)
	desc9a	5|0,0
	desc9a	5|0,qu
NEW_skip_init:
	ldaq	6|area_block_ptr
	rtcd	6|stack_frame.return_ptr
"
"
"
"
"		DISPOSE operator
"		----------------
"
"	assumed that:
"		A,Q = two words ITS ptr to the block to make free
"		x7 = length (in words) of the block
"
"	calling sequence:
"		tsp3	0|27
"
"	   Frees the block (error if given length is not the same than the
"	length found in the block header)
"	   Returns a null ptr in A,Q
"
DISPOSE_call:
	staq	6|area_block_ptr
	stz	6|area_block_length
	sxl7	6|area_block_length
	epp1	<pascal_area_management_>|[DISPOSE]
	tra	common_op_call
"
DISPOSE_return:
	epbp7	6|0
	inhibit on
	spri6	7|stack_header.stack_end_ptr
	epp6	6|stack_frame.prev_sp,*
	inhibit off
	epp0	6|stack_frame.operator_ptr,*
	epaq	6|stack_frame.entry_ptr,*
	lprp4	7|stack_header.lot_ptr,*au
	ldaq	null_ptr
	rtcd	6|stack_frame.return_ptr
"
"
"
"
"		RESET_area operator
"		-------------------
"
"	assumed that:
"		A,Q = two words ITS ptr to the block which must become the last free
"
"	calling sequence:
"		tsp3	0|28
"
"	All the blocks after this address become free and are concatenated
"
RESET_area_call:
	staq	6|area_block_ptr
	epp1	<pascal_area_management_>|[RESET]
	tra	common_op_call
"
RESET_area_return:
"	ldaq	null_ptr		TEMPORARY SKIPPED FOR MENTOR
	tra	common_op_return
"
"
"
"	********************************
"	*                              *
"	*        MATH OPERATORS        *
"	*			 *
"	********************************
"
"	THESE OPERATORS MUST NOT MODIFY ANY REGISTER
"
"	ZERO AND NEGATIVE INDICATORS ARE SET ACCORDING TO THE RESULTS
"
"
"
"		TRUNC operator
"		--------------
"
"	assumed that :
"		E,A,Q contains a real (argument)
"
"	calling sequence:
"		tsp3	0|83
"
"	returns:
"		A = integer pascal TRUNC(argument)
"
TRUNC:
	stx0	6|save_regs	save x0
	dfst	6|op_work+0
	lda	6|op_work+0		
	ars	28
	neg
	ada	35,dl
	tmi	trunc_error
	eax0	0,al	
	dfld	6|op_work+0
	lrs	0,x0
	tpl	2,ic
	adaq	mask1
	ldx0	6|save_regs		restore x0
	ada	0,dl
	tra	3|0			return
trunc_error:
	dfld	6|op_work+0
	dfst	6|err_double
	epp1	<pascal_errors_>|[TRUNC_error]
	tra	common_op_call
"
"
"
"
"		ROUND operator
"		--------------
"
"	assumed that:
"		E,A,Q contains a real (argument)
"
"	calling sequence:
"		tsp3	0|64
"
"	returns:
"		A = integer pascal ROUND(argument)
"
ROUND:
	stx0	6|save_regs	" savex0
	ada	0,dl		" First Round real number
	tpl	pos_val
	dfad	smallhalf		" biggest num < 0.5
	tra	*+2		" skip pos_val add
pos_val:	dfad	half		" 0.5
	dfst	6|op_work+0
	lda	6|op_work+0	" Second Range test
	ars	28
	neg
	ada	35,dl
	tmi	round_error
	eax0	0,al		" Third convert to integer
	dfld	6|op_work+0
	lrs	0,x0
	ldx0	0|save_regs
	ada	0,dl		" set indicators based on A reg
	tra	3|0		" return to user
round_error:
	dfld	6|op_work+0
	dfst	6|err_double
	epp1	<pascal_errors_>|[ROUND_error]
	tra	common_op_call
"
"
"
"
"		int_A_to_real operator
"		----------------------
"
"	assumed that:
"		A contains an integer (argument)
"
"	calling sequence:
"		tsp3	0|31
"
"	returns:
"		E,A,Q = real (argument converted)
"
int_A_to_real:
	ldq	0,dl
	lde	35*1024,du
	fno
	tra	3|0
"
"
"
"
"		int_Q_to_real operator
"		----------------------
"
"	assumed that:
"		Q contains an integer (argument)
"
"	calling sequence:
"		tsp3	0|32
"
"	returns:
"		E,A,Q = real (argument converted)
"
int_Q_to_real:
	lls	36
	lde	35*1024,du
	fno
	tra	3|0
"
"
"
"
"		COS operator
"		------------
"
"	assumed that:
"		E,A,Q contains a real (argument)
"		pr2 contains addr of 36 words area for work
"
"	calling sequence:
"		tsp3	0|81
"
"	returns:
"		E,A,Q = real COS(argument)
"
COS:
	spri	6|op_work
COS_join:
	sreg	6|save_regs
	epaq	0,ic
	epbp7	6|0
	lprp4	7|stack_header.lot_ptr,*au
	ldaq	6|save_regs+4
	tsp3	<double_sine_>|[double_cosine_radians_]
	tra	common_math_return
"
"
"
"
"		SIN operator
"		------------
"
"	assumed that:
"		E,A,Q contains a real (argument)
"		pr2 contains addr of 32 words area for work
"
"	calling sequence:
"		tsp3	0|80
"
"	returns:
"		E,A,Q = real SIN(argument)
"
SIN:
	spri	6|op_work
SIN_join:
	sreg	6|save_regs
	epaq	0,ic
	epbp7	6|0
	lprp4	7|stack_header.lot_ptr,*au
	ldaq	6|save_regs+4
	tsp3	<double_sine_>|[double_sine_radians_]
	tra	common_math_return
"
"
"
"
"		LOG10 operator
"		--------------
"
"	assumed that:
"		E,A,Q contains a real (argument)
"		pr2 contains addr of 32 words area for work
"
"	calling sequence:
"		tsp3	0|86
"
"	returns:
"		E,A,Q = real LOG_base_10(argument)
"
LOG10:
	spri	6|op_work
LOG10_join:
	sreg	6|save_regs
	epaq	0,ic
	epbp7	6|0
	lprp4	7|stack_header.lot_ptr,*au
	ldaq	6|save_regs+4
	tsp3	<double_logarithm_>|[double_log_base_10_]
	tra	common_math_return
"
"
"
"
"		LOG operator
"		------------
"
"	assumed that:
"		E,A,Q contains a real (argument)
"		pr2 contains addr of 32 words area for work
"
"	calling sequence:
"		tsp3	0|82
"
"	returns:
"		E,A,Q = real LOG_base_e(argument)
"
LOG:
	spri	6|op_work
LOG_join:
	sreg	6|save_regs
	epaq	0,ic
	epbp7	6|0
	lprp4	7|stack_header.lot_ptr,*au
	ldaq	6|save_regs+4
	tsp3	<double_logarithm_>|[double_log_base_e_]
	tra	common_math_return
"
"
"
"
"		EXP operator
"		------------
"
"	assumed that:
"		E,A,Q contains a real (argument)
"
"	calling sequence:
"		tsp3	0|83
"
"	returns:
"		E,A,Q = real EXP(argument)
"		pr2 contains addr of 32 words area for work
"
EXP:
	spri	6|op_work
EXP_join:
	sreg	6|save_regs
	epaq	0,ic
	epbp7	6|0
	lprp4	7|stack_header.lot_ptr,*au
	ldaq	6|save_regs+4
	tsp3	<double_exponential_>|[double_exponential_]
	tra	common_math_return
"
"
"
"
"		ATAN operator
"		------------
"
"	assumed that:
"		E,A,Q contains a real (argument)
"
"	calling sequence:
"		tsp3	0|85
"
"	returns:
"		E,A,Q = real ATAN(argument)
"
ATAN:
	spri	6|op_work
ATAN_join:
	sreg	6|save_regs
	epaq	0,ic
	epbp7	6|0
	lprp4	7|stack_header.lot_ptr,*au
	ldaq	6|save_regs+4
	tsp3	<double_arc_tangent_>|[double_arc_tangent_radians_]
	tra	common_math_return
"
"
"
"
"		SQRT operator
"		------------
"
"	assumed that:
"		E,A,Q contains a real (argument)
"		pr2 contains addr of 32 words area for work
"
"	calling sequence:
"		tsp3	0|84
"
"	returns:
"		E,A,Q = real SQRT(argument)
"
SQRT:
	spri	6|op_work
SQRT_join:
	sreg	6|save_regs
	epaq	0,ic
	epbp7	6|0
	lprp4	7|stack_header.lot_ptr,*au
	ldaq	6|save_regs+4
	tsp3	<double_square_root_>|[double_square_root_]
	tra	common_math_return
"
"
common_math_return:
	lpri	6|op_work
	staq	6|save_regs+4
	ste	6|save_regs+6
	lreg	6|save_regs
	szn	6|save_regs+4
	tra	3|0
"
"
"
"	*****************************************
"	*				*
"	*        MISCELLANEOUS OPERATORS	*
"	*				*
"	*****************************************
"
"
"
"
"		extend stack operator
"		---------------------
"
"
"	Assumed that RQ contains size in bytes, extends stack.
"
"
extend_stack_length:
	epbp7	6|0
	stq	6|op_work
	adq	67,dl
	qrs	6
	qls	4
	epp5	7|stack_header.stack_end_ptr,*
	spri5	6|evarea
	epp5	5|0,ql
	spri5	6|stack_frame.next_sp
	spri5	7|stack_header.stack_end_ptr
	ldq	6|op_work
	tra	3|0
"
"
"
"
"		reset stack length
"		-------------------
"
"
"	Assumed that PR1 contains old stack end,
"	resets stack_end to this value.
"
"
reset_stack_length:
	epbp7	6|0
	spri1	6|stack_frame.next_sp
	spri1	7|stack_header.stack_end_ptr
	tra	3|0
"
"
"
"
"		return zero operator
"		--------------------
"
"	calling sequence:
"		tsp3	0|87
"
"	Sets to zero return code if any (last arg must be integer)
"
return_zero:
	epp1	6|stack_frame.arg_ptr,*
	ldx1	1|1
	tze	3|0
	eaq	0,x1
	qls	1
	lda	1|0
	eax1	0,au
	ana	8+2,dl
	tze	+2,ic
	adq	2,du
	lda	1|0,qu*
	ana	neg_mask
	cmpa	fb35_desc
	tnz	3|0
	stz	1|0,x1*
	tra	3|0
"
"
"
"
"		ARGC_short operator
"		___________________
"
"	calling sequence :
"		tsp3	0|69
"
"	returns :
"		A = arg count of MAIN
"
ARGC_short:
	spri1	6|op_work
	epp1	6|stack_frame.arg_ptr,*
	tra	ARGC_join
"
"
"
"
"		ARGC operator
"		_____________
"
"	assumed that:
"		PR1 -> stack frame of MAIN
"
"	calling sequence:
"		tsp3	0|70
"
"	returns:
"		A = arg count of MAIN
"
ARGC:
	spri1	6|op_work
	epp1	1|stack_frame.arg_ptr,*
ARGC_join:
	sreg	6|save_regs
	ldx1	1|0
	tze	ARGC_no_args
	ldx3	1|1
	tze	ARGC_no_desc
	lxl4	1|0
	anx4	8+2,du
	tze	+2,ic
	eax3	2,x3
	eax3	2,x3
	ldx1	0,du
ARGC_desc_loop:
	adx1	2,du
	lda	1|0,3*	descriptor
	ana	=o375700,du	string?
	cmpa	=o124000,du
	tnz	ARGC_check_last
	adx3	2,du
	cmpx1	1|0
	tnz	ARGC_desc_loop
	lda	1|0		all args are strings
	ars	1+18
ARGC_return:
	sta	6|save_regs+4
	lreg	6|save_regs
	epp1	6|op_work,*
	tra	3|0		return to caller
ARGC_check_last:
	cmpx1	1|0
	tnz	ARGC_bad_string_arg
	lda	1|0,3*
	ana	neg_mask
	cmpa	fb35_desc
	tnz	ARGC_bad_last_arg
	lda	1|0		last arg is return code
	arl	1+18
	sba	1,dl
	tra	ARGC_return		return to caller
ARGC_no_args:
	lda	0,dl
	tra	ARGC_return		return to caller
ARGC_no_desc:
	lda	2,dl		no descriptors !!
	tra	ARGC_err_call
ARGC_bad_string_arg:
	eaa	0,x1
	ars	1+18
	sta	6|err_single
	lda	3,dl		this arg is not a string !!
	tra	ARGC_err_call
ARGC_bad_last_arg:
	lda	4,dl		bad last arg !!
ARGC_err_call:
	sta	6|err_code
	epp1	<pascal_errors_>|[ARGC_error]
	tra	common_op_call
"
"
"
"
"		ARGC_ext operator
"		_________________
"
"	assumed that :
"		PR1 -> entry point of MAIN
"
"	calling sequence :
"		tsp3	0|71
"
"	returns:
"		A = arg count of MAIN
"
ARGC_ext:
	spri1	6|op_work+0
	ldaq	6|op_work+0
	epbp7	6|0
	eax1	6|stack_frame.prev_sp,*
ARGC_loop:
	cmpaq	7|stack_frame.entry_ptr,x1
	tze	ARGC_main_found
	eax1	7|stack_frame.prev_sp,x1*
	cmpx1	1,du
	tnz	ARGC_loop
	lda	1,dl		main is not active !!
	tra	ARGC_err_call
ARGC_main_found:
	epp1	7|stack_frame.arg_ptr,x1*
	tra	ARGC_join
"
"
"
"
"		ARGV_short operator
"		-------------------
"
"	assumed that:
"		PR1 -> target string 
"		A = target string length
"		Q = arg no
"
"	calling sequence:
"		tsp3	0|73
"
"	returns:
"		target string is filled with argument
"                 A contains argument length
"
ARGV_short:
	sreg	6|save_regs
	epp2	6|stack_frame.arg_ptr,*
	tra	ARGV_join
"
"
"
"
"		ARGV operator
"		-------------
"
"	assumed that:
"		PR2 -> MAIN stack_frame 
"		PR1 -> target string 
"		A = target argument length
"		Q = arg no
"
"	calling sequence:
"		tsp3	0|74
"
"	returns:
"		target string is filled with argument
"                 A contains argument length
"
ARGV:
	sreg	6|save_regs
	epp2	2|stack_frame.arg_ptr,*
ARGV_join:
	lda	6|save_regs+5	arg no
	tmoz	ARGV_no_exists
	als	1
	eax1	0,al
	cmpx1	2|0
	tpnz	ARGV_no_exists
	ldx3	2|1
	tze	ARGV_no_desc
	eax2	0,x1
	adx2	2|0
	lxl4	2|0
	anx4	8+2,du
	tze	+2,ic
	eax2	2,2
	lda	2|0,x2*
	ana	=o375700,du
	cmpa	=o124000,du
	tnz	ARGV_not_string
	lda	2|0,x2*
	ana	descriptor_mask
	cmpa	6|save_regs+4	target len
	tpnz	ARGV_too_long
	epp2	2|0,x1*
	lxl1	6|save_regs+4	target len
	ldq	6|stack_frame.translator_id
	anq	sol_bit,dl	french SOL standard ?
	tnz	ARGV_fill_with_zeroes
	mlr	(pr,rl),(pr,rl),fill(040)
	desc9a	2|0,al
	desc9a	1|0,x1
          tra       ARGV_return
ARGV_fill_with_zeroes:
	mlr	(pr,rl),(pr,rl),fill(000)
	desc9a	2|0,al
	desc9a	1|0,x1
ARGV_return:
	tra 3|0		return to caller
ARGV_no_exists:
	lda	6|stack_frame.translator_id
	ana	sol_bit,dl
	tze	ARGV_fatal_error
	lda	0,dl
	lxl1	6|save_regs+4
	tra	ARGV_fill_with_zeroes
ARGV_fatal_error:
	lda	1,dl		arg does not exist !!!
	tra	ARGV_err_call
ARGV_no_desc:
	lda	2,dl		arg list has no descriptors !!
	tra	ARGC_err_call
ARGV_not_string:
	lda	3,dl		arg is not a string !!
	tra	ARGV_err_call
ARGV_too_long:
	sta	6|err_single
	lda	4,dl		arg is too long !!
ARGV_err_call:
	sta	6|err_code
	ldaq	6|save_regs+4
	staq	6|err_double
	epp1	<pascal_errors_>|[ARGV_error]
	tra	common_op_call
"
"
"
"
"		ARGV_ext operator
"		-----------------
"
"	assumed that:
"		PR2 -> entry point of MAIN
"		PR1 = target string addr
"		A = target string length
"		Q = arg no
"
"	calling sequence:
"		tsp3	0|75
"
"	returns:
"		target string is filled with argument
"		A contains argument lensth
"
ARGV_ext:
	sreg	6|save_regs
	spri2	6|op_work+0
	ldaq	6|op_work+0
	epbp7	6|0
	eax1	6|stack_frame.prev_sp,*
ARGV_loop:
	cmpaq	7|stack_frame.entry_ptr,x1
	tze	ARGV_main_found
	eax1	7|stack_frame.prev_sp,x1*
	cmpx1	1,du
	tnz	ARGV_loop
	lda	5,dl		MAIN is not active !!
	tra	ARGV_err_call
ARGV_main_found:
	epp2	7|stack_frame.arg_ptr,x1*
	ldaq	6|err_double
	tra	ARGV_join
"
"
"
"
"		int_check_error operator
"		------------------------
"
"	assumed that:
"		x5 = internal code of the detected error
"			1 - index out of bounds
"			2 - chr error
"			3 - previous
"			4 - next
"			5 - inf bound of FOR
"			6 - sup bound of FOR
"			7 - affectation
"			8 - zero_divide or negative arg for mod
"			9 - parameter error
"		x6 = internal code for the concerned register
"			1 - A
"			2 - Q
"			4 - A,Q		pointer
"			8 - E,A,Q  	real
"
"	calling sequence:
"		tsp3	0|38
"
int_check_error:
	epp2	3|-1		place in statement
	spri2	6|err_addr
	cmpx6	8,du
	tze	+3,ic
	staq	6|err_double
	tra	+2,ic
	dfst	6|err_double
	stz	6|err_single
	sxl6	6|err_single
	stz	6|err_code
	sxl5	6|err_code
	epp1	<pascal_errors_>|[except_code_error]
	tra	common_op_call
"
"
"
"
"		long_profile operator
"		---------------------
"
"	calling_sequence:
"		tsp3	0|50
"		(long_profile_header relp),(long_profile_entry relp)
"
	include	long_profile
"
long_profile:
	sti	6|indicators
	sreg	6|save_regs
	spri	6|op_work
	epbp7	6|0
	epaq	0,ic		get our lp
	lprp4	7|stack_header.lot_ptr,*au
	stcd	6|stack_frame.return_ptr
	call6	<cpu_time_and_paging_op_>|[cpu_time_and_paging_op_]
	staq	6|cpu
	stx0	6|page
	sxl1	6|page
	ldx1	6|op_work+3+3,*
	epp5	6|linkage_ptr,*x1
	lxl2	5|long_profile_header.last_offset
	aos	5|long_profile_entry.count,x2		update
	sblaq	5|long_profile_header.last_vcpu
	asq	5|long_profile_entry.vcpu,x2
	ldq	6|page
	sblq	5|long_profile_header.last_pf
	asq	5|long_profile_entry.pf,x2
	ldaq	6|cpu			set up for next time
	staq	5|long_profile_header.last_vcpu
	ldq	6|page
	stq	5|long_profile_header.last_pf
	lxl3	6|op_work+3+3,*
	sxl3	5|long_profile_header.last_offset
	lpri	6|op_work
	lreg	6|save_regs
	ldi	6|indicators
	tra	3|1		return to caller
"
"
"
"
"		date operator
"		-------------
"
"	calling sequence:
"		tsp3	0|47
"
"	returns:
"		(A,Q) = "XX/XX/XX"
"
date:
	epp1	<pascal_time>|[date]
	tra	common_time_call
"
date_return:
	epbp7	6|0
	inhibit on
	spri6	7|stack_header.stack_end_ptr
	epp6	6|stack_frame.prev_sp,*
	inhibit off
	epp0	6|stack_frame.operator_ptr,*
	epaq	6|stack_frame.entry_ptr,*
	lprp4	7|stack_header.lot_ptr,*au
	ldaq	6|op_work+4
	rtcd	6|stack_frame.return_ptr
"
"
"
"
"		time operator
"		-------------
"
"	calling sequence:
"		tsp3	0|48
"
"	returns:
"		(A,Q) = "XX:XX:XX"
"
time:
	epp1	<pascal_time>|[time]
common_time_call:
	ldaq	one_arg_header
	staq	6|op_work+0
	epp2	6|op_work+4
	spri2	6|op_work+2
	spri0	6|stack_frame.operator_ptr
	epp0	6|op_work+0
	spri3	6|stack_frame.return_ptr
	epbp7	6|0
	call6	1|0
"
time_return:
	tra	date_return
"
"
"
"
"		clock operator
"		--------------
"
"	calling sequence:
"		tsp3	0|49
"
"	returns:
"	(A,Q) : (REAL) = milliseconds virtual cpu process time
"
clock:
	sreg	6|save_regs
	spri	6|op_work+0		save pointers
	epaq	0,ic		get our lp
	epbp7	6|0
	lprp4	7|stack_header.lot_ptr,*au
	epp3	return_clock
	spri3	6|stack_frame.return_ptr
	call6	<virtual_cpu_time_op_>|[virtual_cpu_time_op_]
return_clock:
	lpri	6|op_work+0		restore pointers
	staq	6|save_regs+4
	lreg	6|save_regs
	lde	71*1024,du	convert A,Q (virtual cpu) from fixed bin(71) to float bin(63)
	fno
	tra	3|0		return to caller
"
"
"
"
"		check_parm_proc operator
"		------------------------
"
"	assumed that:
"		A contains call operator number
"
"	calling sequence :
"		tsp3	0|101
"
"	Checks if the operator is an ext call op
"
check_parm_proc:
	cmpa	43,dl
	tze	3|0
	spri3	6|err_addr
	epp1	<pascal_errors_>|[parm_proc_error]
	tra	common_op_call
"
"
"
"
"		function_value_set
"		------------------
"
"	assumed that:
"		A contains the difference of proc levels
"
"	calling sequence:
"		tsp3	0|102
"
"	Memorizes the fact that function value has been assigned.
"
function_value_set:
	epp7	6|0
function_stack_loop:
	sba	1,dl
	tmi	function_stack_ok
	epp7	7|dlinkw,*
	tra	function_stack_loop
function_stack_ok:
	lda	function_value_bit,dl
	orsa	7|stack_frame.translator_id
	epbp7	6|0
	tra	3|0
"
"
"
"
"		function_value_check
"		--------------------
"
"	calling sequence:
"		tsp3	0|103
"
"	Checks that function value has been assigned.
"
function_value_check:
	lda 	6|stack_frame.translator_id
	ana	function_value_bit,dl
	tnz	3|0
"			Bad programmer is going to be punished!
	epp1	<pascal_errors_>|[function_value_error]
	tra	common_op_call
"
"
"
"
"
"
"
"		  Pseudo operators :
"
"	procedure pascal_util_$establish_on_unit
"
"
	segdef	establish_on_unit
"
"
blank:	oct	040040040040
cleanup_str:
	aci	"cleanup"
"
establish_on_unit:
	tsx5	on_check_length_and_name
	tnz	on_other
"					special for "cleanup"
	lda	6|stack_frame.prev_sp
	ana	64,dl
	tze	on_only_cleanup
	ldx2	6|stack_frame.on_unit_rel_ptrs
	tsx5	on_loop
	tze	on_cleanup_fill
"					create cleanup on_unit and chain to others
	epp4	6|cleanup_on_unit
	ldx4	6|stack_frame.on_unit_rel_ptrs
	stx4	4|on_unit.next
	eax4	4|0
	stx4	6|stack_frame.on_unit_rel_ptrs
on_cleanup_create:				" fill name length, ptr and ptr to proc
	stq	4|on_unit.size
	epp5	cleanup_sequence
	spri5	4|on_unit.body
	epp5	cleanup_str
	spri5	4|on_unit.name
	tra	on_cleanup_fill
on_only_cleanup:
	epp4	6|cleanup_on_unit
	lda	64,dl
	orsa	6|stack_frame.prev_sp
	stz	4|on_unit.next
	eax3	6|0
	eax2	4|0
	stx3	6|stack_frame.on_unit_rel_ptrs
	ssx2	6|stack_frame.on_unit_rel_ptrs
	tra	on_cleanup_create
on_cleanup_fill:
	lda	user_on_cleanup_bit,dl
	orsa	6|stack_frame.translator_id
	epp5	0|4,*
	epp5	5|0,*
	spri5	6|user_cleanup_ptr
	tra	on_return
"
on_other:					" other than "cleanup"
	lda	6|stack_frame.prev_sp
	ana	64,dl	bit 29 is on if on units exist
	tze	on_build_first
"			look for existing on unit
	ldx2	6|stack_frame.on_unit_rel_ptrs
	tsx5	on_loop
	tze	on_replace
"				at this point : PR2 -> last on_unit
"				add one other on_unit to the list
	tsx5	on_extend_and_fill
	eax3	6|0
	eax2	4|0
	stx3	2|on_unit.next
	ssx2	2|on_unit.next
	tra	on_return
"
"
on_build_first:
	tsx5	on_extend_and_fill
	eax3	6|0
	eax2	4|0
	stx3	6|stack_frame.on_unit_rel_ptrs
	ssx2	6|stack_frame.on_unit_rel_ptrs
	lda	6|stack_frame.prev_sp
	ada	64,dl
	sta	6|stack_frame.prev_sp
	tra	on_return
"
on_replace:
	epp5	0|4,*
	epp5	5|0,*
	spri5	2|on_unit.body
"
"
"
"	procedure pascal_util_$remove_on_unit
"
"
	segdef	remove_on_unit
"
remove_on_unit:
	tsx5	on_check_length_and_name
	tnz	on_remove_other
"
	ldx2	6|stack_frame.on_unit_rel_ptrs
	tsx5	on_loop
	tnz	on_return
	lda	user_on_cleanup_mask
	ansa	6|stack_frame.translator_id
	lda	close_on_cleanup_mask
	ora	6|stack_frame.translator_id
	tnz	on_return
	tra	on_remove
"
on_remove_other:
	ldx2	6|stack_frame.on_unit_rel_ptrs
	tsx5	on_loop
	tnz	on_return
on_remove:
	eax2	2|0
	cmpx2	6|stack_frame.on_unit_rel_ptrs
	tze	on_first_out
	ldx2	2|on_unit.next
	stx2	7|on_unit.next
	tra	on_return
on_first_out:
	ldx2	2|on_unit.next
	tze	on_no_more
	sxl2	6|stack_frame.on_unit_rel_ptrs
	tra	on_return
on_no_more:
	lda	bit_29_mask
	ansa	6|stack_frame.translator_id
	tra	on_return
"
"
"
on_return:
	epp0	6|stack_frame.operator_ptr,*
	tra	3|0
"
"
on_loop:
	epp7	2|0		previous one
	epp2	6|0,x2	PR2 -> next on_unit
	lda	2|on_unit.size
	epp4	2|on_unit.name,*
	cmpc	(pr,rl),(pr,rl),fill(040)
	desc9a	1|0,ql
	desc9a	4|0,al
	tze	0,x5		zero on : found
	ldx2	2|on_unit.next
	tnz	on_loop
	szn	1,dl		zero off : not found
	tra	0,x5
"
"
on_extend_and_fill:
	eaa	84,ql	compute in A length in words for stack extension
	arl	6+18
	als	4
"			grow stack frame
	epbp7	6|0
	epp4	7|stack_header.stack_end_ptr,*
	epp5	4|0,al
	inhibit on
	spri5	6|stack_frame.next_sp
	spri5	7|stack_header.stack_end_ptr
	inhibit off
	stz	4|on_unit.next
	stq	4|on_unit.size
	epp5	0|4,*
	epp5	5|0,*
	spri5	4|on_unit.body
	epp5	4|6
	spri5	4|on_unit.name
	mlr	(pr,rl),(pr,rl),fill(000)
	desc9a	1|0,ql
	desc9a	5|0,ql
	tra	0,x5
"
"
on_check_length_and_name:
	ldq	0|0
	epp1	0|2,qu*	name descriptor addr (1rst desc)
	ldq	1|2	high bound
	sbq	1|1	low bound
	adq	1,dl	name length
"			remove blanks before and after name
	epp2	blank
	epp1	0|2,*	addr of the name
rtrim_ltrim:
	scm	(pr,rl),(pr),mask(000)
	desc9a	1|0,ql
	desc9a	2|0,1
	arg	6|op_work
	ttn	length_ok
	lda	6|op_work
	tnz	rtrim
	sbq	1,dl
	lda	1,dl
	a9bd	1|0,al
	tra	rtrim_ltrim
rtrim:
	ldq	6|op_work
length_ok:
	cmpq	0,dl
	tze	on_return		return if name length is null
	epp2	cleanup_str
	cmpc	(pr,rl),(pr),fill(040)
	desc9a	1|0,ql
	desc9a	2|0,7
	tra	0,x5
"			at this point:	PR1 -> name string, Q = name length
"					zero indic. on if "cleanup"
"
"
"
"
"
"
"
"		    Common call sequence for PL1/subroutines used by
"		operators. (arglist is allways at the same place)
"
"
common_op_call:
	spri0	6|stack_frame.operator_ptr
	spri3	6|stack_frame.return_ptr
	epp2	6|arg_1
	spri2	6|arg_ptr
	ldaq	one_arg_header
	staq	6|arg_header
	epp0	6|arg_header
	epbp7	6|0
	call6	1|0
"
"
"
"
"		   Common return sequence for operators written in PL/1 ,
"		which restores PR4 (not done by standard PL/1 return)
"
"
init_fsb_return:
init_fsb_alloc_return:
connect_return:
RESET_file_return:
REWRITE_return:
fclose_return:
close_return:
READ_sequential_return:
READLN_return:
WRITE_text_return:
SWRITE_return:
WRITE_sequential_return:
WRITELN_return:
FLUSH_return:
PAGE_return:
PUT_text_return:
PUT_sequential_return:
GET_text_return:
GET_sequential_return:
GET_direct_return:
PUT_direct_return:
open_update_return:
v6_RESET_file_return:
v6_READLN_return:
v6_GET_text_return:
common_op_return:
	epbp7	6|0	PR7 -> stack header
	inhibit on
	spri6	7|stack_header.stack_end_ptr	new stack end
	epp6	6|stack_frame.prev_sp,*	previous frame
	inhibit off
	epp0	6|stack_frame.operator_ptr,*	restore op_ptr
	epaq	6|stack_frame.entry_ptr,*
	lprp4	7|stack_header.lot_ptr,*au
	ldi	0,dl		reset indicators
	rtcd	6|stack_frame.return_ptr
"
"
"
"
"	   	Pre entry sequence for the close_level_files procedure
"		(activated by Multics unwinder)
"
"
cleanup_sequence:
	eax6	0,ic
	eax7	96
	epp5	transfer_vector
	tsp3	5|2	ext_entry
"
	epp1	6|stack_frame.arg_ptr,*
	ldx1	1|0
	epp1	1|2,x1*		get ptr to original stack_frame
	spri1	6|op_work
	lda	user_on_cleanup_bit,dl
	ana	1|stack_frame.translator_id
	tze	cleanup_close
"					user's cleanup
	eax1	6|arg_header
	fld	0,dl
	epp5	1|user_cleanup_ptr,*
	tsp3	0|43	ext_call
	epp4	6|linkage_ptr,*
	epp1	6|op_work,*		reset original sp
cleanup_close:
	lda	close_on_cleanup_bit,dl
	ana	1|stack_frame.translator_id
	tze	cleanup_return
"					close files cleanup
	spri1	6|io_stack_frame_ptr
	epp2	6|io_block_ptr
	spri2	6|arg_ptr
	eax1	6|arg_header
	fld	2024,dl
	epp5	<pascal_io_>|[close_level_files]
	tsp3	0|43	ext_call
"
cleanup_return:
	tra	0|40	ext_return
"

	include	simone_operators_
"
"		OPERATOR ENTRIES USED BY OBJECT SEGMENTS
"		       GENERATED WITH PASCAL 6.xx
"		----------------------------------------
"
"
"
v6_entry_operators_begin:
"
"		entry operator for MAIN procedures
"		----------------------------------
"
"	assumed that:     (Multics convention)
"		PR0 -> parameter list
"		PR6 -> stack frame of the calling procedure
"		PR7 -> stack header
"
"	calling sequence:
"		eax6	0,ic		to get offset of entry point
"		eax7	[stack_frame size in words (n * 16)]
"		epaq	0,ic
"		lprp4	7|stack_header.lot_ptr,*au	get ptr to link sect
"		epp2	4|8		get ptr to statics
"		epp5	7|stack_header.trans_op_tv_ptr
"		epp5	5|8,*		to get ptr to pascal operators
"		tsp3	5|(operator nbr)
"
"	   Before the standard push sequence, MAIN_entry checks the
"	parameter list to get the eventual PASCAL (non standard)
"	PARM (100 char input chain) and COND (return value) addrs.
"	   There are three ways to call a MAIN pascal program :
"	1 - Without parameters (empty arg list is transmitted) :
"		call MAIN_pascal       (PL/1)
"		MAIN_pascal            (command)
"	2 - In a PL/1 program, with the following declarations:
"	(two args, two descriptors are transmitted)
"		dcl MAIN_pascal entry(char(*), fixed bin(35)) ;
"		dcl return_code fixed bin(35) ;
"		call MAIN_pascal("parameter list <= 100 chars",return_code) ;
"	or :
"		dcl MAIN_pascal entry(char(*)) returns(fixed bin(35) ;
"		dcl return_code fixed bin(35) ;
"		return_code = MAIN_pascal("parameter list <= 100 chars") ;
"	3 - At the command level (one arg, one descriptor are transmitted) :
"		MAIN_pascal "PARM input chain ....<= 100 chars"
"
"	In any case, and for security, the parameter list has and MUST have descriptors.
"
"	returns:
"		PR0 -> pascal operators transfer vector
"		PR4 -> link section of the procedure
"		PR6 -> stack_frame of the procedure
"		(indicators are reset)
"
v6_MAIN_entry_force_fast:
	ldq	main_bit+fast_bit,dl
	tra	v6_MAIN_join
v6_MAIN_entry:
	ldq	main_bit,dl
v6_MAIN_join:
	stz	2|COND
	ldx0	0|0		x0 : 2*nbr_of_args
	tnz	+3,ic
	stz	2|PARM_count	no args
	tra	v6_ext_common
	cmpx0	6,du
	trc	v6_MAIN_err_1	too much args (>2)
	ldx1	0|1		x1 : 2*nbr_of_descriptors
	tze	v6_MAIN_err_2	no descriptors
	lxl2	0|0		is there a stack_frams ptr ?
	anx2	8+2,du
	tze	+2,ic
	eax1	2,1		if any skip it
	eax1	2,1		x1 : offset of the first desc.
	lda	0|0,1*		first descriptor
	ana	=o375700,du
	cmpa	=o124000,du
	tnz	v6_MAIN_err_3	it is not a char string
	lda	0|0,1*
	tmi	+2,ic
	ana	=o777777,dl	old descriptor
	ana	descriptor_mask
	cmpa	101,dl
	trc	v6_MAIN_err_4	>100 characters. too long!
	epp1	0|2,*		PR1 -> PARM string
	even
	mlr	(pr,rl),(pr,rl)		move PARM string
	desc9a	1|0,al
	desc9a	2|PARM,al
	sta	2|PARM_count
	cmpx0	2,du		is there a second arg ?
	tze	v6_ext_common
	lda	0|2,1*		second arg descriptor
	ana	neg_mask
	cmpa	fb35_desc
	tnz	v6_MAIN_err_5	it is not fixed bin(35) !
	tra	v6_ext_common
v6_MAIN_err_1:
	ldx0	1,du
	tra	v6_MAIN_err_call
v6_MAIN_err_2:
	ldx0	2,du
	tra	v6_MAIN_err_call
v6_MAIN_err_3:
	ldx0	3,du
	tra	v6_MAIN_err_call
v6_MAIN_err_4:
	ldx0	4,du
	tra	v6_MAIN_err_call
v6_MAIN_err_5:
	ldx0	5,du
v6_MAIN_err_call:
	tsp3	v6_ext_common
	nop
	nop
	stz	6|err_code
	sxl0	6|err_code
	epp1	<pascal_errors_>|[v6_MAIN_error]
	tra	common_op_call
"
"
"
"
v6_ext_entry_force_fast:
	epaq	3|0
	lprp4	7|stack_header.lot_ptr,*au
	ldq	fast_bit,dl
	tra	v6_ext_join
v6_ext_entry:
	epaq	3|0
	lprp4	7|stack_header.lot_ptr,*au
	ldq	0,dl
v6_ext_join:
v6_ext_common:
	epp2	7|stack_header.stack_end_ptr,*
	spri6	2|stack_frame.prev_sp
	spri0	2|stack_frame.arg_ptr	"areg_ptr" in new stack frame
	epp0	2|0,7		get ptr to new stack end
	spri0	2|math_work_ptr
	epp0	0|math_work_size
	spri0	2|stack_frame.next_sp
	spri0	7|stack_header.stack_end_ptr 	initiate new stack end
	epp6	2|0		PR6 -> stack frame of the procedure
	adq	my_id,du
	stq	6|stack_frame.translator_id
	spri4	6|linkage_ptr	"linkage_ptr" in new stack frame
	spri1	6|dlinkw
	epbp1	3|0		get ptr to the base of procedure segment
	epp1	1|0,x6		get ptr to entry point of the proc
	spri1	6|stack_frame.entry_ptr	"entry_ptr" of new stack frame
	spri5	6|stack_frame.operator_ptr	"operator_ptr" in new stack frame
	epp0	5|0		PR0 -> pascal operators
	ldi	0,dl		reset indicators
	tra	3|2		return to procedure
"
"
"
"
"		trace_MAIN_entry operator
"		-------------------------
"
"	(see MAIN_entry conventions)
"
trace_v6_MAIN_entry_force_fast:
	ldq	main_bit+fast_bit,dl
	tra	v6_trace_MAIN_join
trace_v6_MAIN_entry:
	ldq	main_bit,dl
v6_trace_MAIN_join:
	stz	2|COND
	ldx0	0|0		x0 : 2*nbr_of_args
	tnz	+3,ic
	stz	2|PARM_count	no args
	tra	v6_trace_MAIN_common
	cmpx0	6,du
	trc	v6_MAIN_err_1	too much args (>2)
	ldx1	0|1		x1 : 2*nbr_of_descriptors
	tze	v6_MAIN_err_2	no descriptors
	lxl2	0|0		is there a stack_frams ptr ?
	anx2	8+2,du
	tze	+2,ic
	eax1	2,1		if any skip it
	eax1	2,1		x1 : offset of the first desc.
	lda	0|0,1*		first descriptor
	ana	=o375700,du
	cmpa	=o124000,du
	tnz	v6_MAIN_err_3	it is not a char string
	lda	0|0,1*
	tmi	+2,ic
	ana	=o777777,dl	old descriptor
	ana	descriptor_mask
	cmpa	101,dl
	trc	v6_MAIN_err_4	>100 characters. too long!
	epp1	0|2,*		PR1 -> PARM string
	even
	mlr	(pr,rl),(pr,rl)		move PARM string
	desc9a	1|0,al
	desc9a	2|PARM,al
	sta	2|PARM_count
	cmpx0	2,du		is there a second arg ?
	tze	v6_trace_MAIN_common
	lda	0|2,1*		second arg descriptor
	ana	neg_mask
	cmpa	fb35_desc
	tnz	v6_MAIN_err_5	it is not fixed bin(35) !
v6_trace_MAIN_common:
	epp1	7|stack_header.stack_end_ptr,*
	sprp3	1|0
	sxl6	1|0
	stq	1|1
	eax5	3|0
	stx5	1|1
"
"	At this moment, first two words of next stack frame, saved by trace,
"	contain:
"		packed ptr to entry point (1 word. required by trace)
"		offset of next word in calling object (1 half word)
"		PASCAL execution flags (1 half word)
"
"	Trace is supposed to restore x7, pr6, pr0, pr7
"
	epaq	0,ic
	lprp4	7|stack_header.lot_ptr,*au
	tsp2	<trace>|[catch_pl1_]
"
	epp2	7|stack_header.stack_end_ptr,*
	spri6	2|stack_frame.prev_sp
	spri0	2|stack_frame.arg_ptr
	epp0	2|0,7
	spri0	2|math_work_ptr
	epp0	0|math_work_size
	spri0	2|stack_frame.next_sp
	spri0	7|stack_header.stack_end_ptr
	epp6	2|0
	lprp3	6|0
	spri3	6|stack_frame.entry_ptr
	epaq	3|0
	lprp4	7|stack_header.lot_ptr,*au
	spri4	6|linkage_ptr
	epp0	trace_transfer_vector
	spri0	6|stack_frame.operator_ptr
	lda	6|1
	ana	-1,dl
	ada	my_id,du
	sta	6|stack_frame.translator_id
	epbp3	3|0
	ldx6	6|1
	ldi	0,dl
	tra	3|2,x6
"
"
"
"
trace_v6_ext_entry_force_fast:
	epp2	7|stack_header.stack_end_ptr,*
	sprp3	2|0
	sprp1	2|1
"
"	At this moment, first two words of next stack frame, saved by trace,
"	contain:
"		packed ptr to entry point (1 word. required by trace)
"		packed dlink ptr (1 word)
"
"	Trace is supposed to restore x7, pr6, pr0, pr7
"
	epaq	0,ic
	lprp4	7|stack_header.lot_ptr,*au
	tsp2	<trace>|[catch_pl1_]
"
	ldq	fast_bit,dl
	tra	trace_v6_ext_join
"
"
"
"
trace_v6_ext_entry:
	epp2	7|stack_header.stack_end_ptr,*
	sprp3	2|0
	sprp1	2|1
"
"	At this moment, first two words of next stack frame, saved by trace,
"	contain:
"		packed ptr to entry point (1 word. required by trace)
"		packed dlink ptr (1 word)
"
"	Trace is supposed to restore x7, pr6, pr0, pr7
"
	epaq	0,ic
	lprp4	7|stack_header.lot_ptr,*au
	tsp2	<trace>|[catch_pl1_]
"
	ldq	0,dl
trace_v6_ext_join:
	epp2	7|stack_header.stack_end_ptr,*
	spri6	2|stack_frame.prev_sp
	spri0	2|stack_frame.arg_ptr
	epp0	2|0,7
	spri0	2|math_work_ptr
	epp0	0|math_work_size
	spri0	2|stack_frame.next_sp
	spri0	7|stack_header.stack_end_ptr
	epp6	2|0
	lprp3	6|0
	spri3	6|stack_frame.entry_ptr
	lprp1	6|1
	spri1	6|dlinkw
	adq	my_id,du
	stq	6|stack_frame.translator_id
	epaq	3|0
	lprp4	7|stack_header.lot_ptr,*au
	spri4	6|linkage_ptr
	epp0	trace_transfer_vector
	spri0	6|stack_frame.operator_ptr
	ldi	0,dl
	tra	3|10
"
"
"
"
v6_int_entry:
	eaa	7|stack_header.stack_end_ptr,*
	spri6	7|stack_frame.prev_sp,au
	spri2	7|stack_frame.arg_ptr,au
	epp2	6|stack_frame.next_sp,*x7
	spri2	7|math_work_ptr,au
	epp2	2|math_work_size
	spri2	7|stack_frame.next_sp,au
	lda	6|stack_frame.translator_id
	epp6	7|stack_header.stack_end_ptr,*
	spri2	7|stack_header.stack_end_ptr
	ana	non_MAIN_mask
	sta	6|stack_frame.translator_id
	spri1	6|dlinkw
	spri4	6|linkage_ptr
	spri5	6|stack_frame.entry_ptr
	ldi	0,dl
	tra	3|2
v6_entry_operators_end:
"
"
"
"
"		return from MAIN pascal
"		-----------------------
"
"	calling sequence:
"		epp2	4|8		to get ptr to statics  (relocatable)
"		tra	0|41
"
"	Returns from MAIN pascal procedure
"
v6_MAIN_return:
	epp0	6|stack_frame.arg_ptr,*
	ldaq	0|0
	lrl	19
	cmpa	2,dl
	tnz	ext_return
	lda	2|0		COND
	sta	0|4,*
	tra	ext_return
"
"
"
"
"		init_fsb operator
"		-----------------
"
"	assumed that :
"		6|io_block_ptr contains the ptr to the PASCAL file fsb
"		A = 0 : non TEXT
"		    1 : TEXT
"		Q = record size in bytes (for non text files)
"		    text buffer length (for TEXT files)
"		PR2 -> 8_char string (name of the file)
"
"	calling sequence:
"		tsp3	6|46
"
init_fsb_call:
	sta	6|io_type
	stq	6|io_size
	spri2	6|io_two_words_value
	spri6	6|io_stack_frame_ptr
"
	epp1	<pascal_io_>|[init_fsb]
	tra	common_op_call
"
"init_fsb_return:
"	tra	common_op_return
"
"
"
"
"		v6_COS operator
"		---------------
"
v6_COS:
	spri	6|op_work
	epp2	6|math_work_ptr,*
	tra	COS_join
"
"
"
"
"		v6_SIN operator
"		---------------
"
v6_SIN:
	spri	6|op_work
	epp2	6|math_work_ptr,*
	tra	SIN_join
"
"
"
"
"		v6_LOG10 operator
"		-----------------
v6_LOG10:
	spri	6|op_work
	epp2	6|math_work_ptr,*
	tra	LOG10_join
"
"
"
"
"		v6_LOG operator
"		---------------
"
v6_LOG:
	spri	6|op_work
	epp2	6|math_work_ptr,*
	tra	LOG_join
"
"
"
"
"		v6_EXP operator
"		---------------
"
v6_EXP:
	spri	6|op_work
	epp2	6|math_work_ptr,*
	tra	EXP_join
"
"
"
"
"		v6_ATAN operator
"		----------------
"
v6_ATAN:
	spri	6|op_work
	epp2	6|math_work_ptr,*
	tra	ATAN_join
"
"
"
"
"		v6_SQRT operator
"		----------------
"
v6_SQRT:
	spri	6|op_work
	epp2	6|math_work_ptr,*
	tra	SQRT_join
"
"
"
"
"
"
"
"
"
"
"
"		OPERATOR ENTRIES USED BY OBJECT SEGMENTS
"		      GENERATED BEFORE PASCAL 6.00
"		****************************************
"
"
"
"
old_entry_operators_begin:
"
"		old entry operator for MAIN procedures
"		--------------------------------------
"
old_MAIN_entry_force_fast:
	ldq	main_bit+fast_bit,dl
	tra	old_MAIN_join
old_MAIN_entry:
	ldq	main_bit,dl
old_MAIN_join:
	stz	2|COND
	ldx0	0|0		x0 : 2*nbr_of_args
	tnz	+3,ic
	stz	2|PARM_count	no args
	tra	old_MAIN_ext_join
	cmpx0	6,du
	trc	old_MAIN_err_1	too much args (>2)
	ldx1	0|1		x1 : 2*nbr_of_descriptors
	tze	old_MAIN_err_2	no descriptors
	lxl2	0|0		is there a stack_frams ptr ?
	anx2	8+2,du
	tze	+2,ic
	eax1	2,1		if any skip it
	eax1	2,1		x1 : offset of the first desc.
	lda	0|0,1*		first descriptor
	ana	=o375700,du
	cmpa	=o124000,du
	tnz	old_MAIN_err_3	it is not a char string
	lda	0|0,1*
	tmi	+2,ic
	ana	=o777777,dl	old descriptor
	ana	descriptor_mask
	cmpa	101,dl
	trc	old_MAIN_err_4	>100 characters. too long!
	epp1	0|2,*		PR1 -> PARM string
	even
	mlr	(pr,rl),(pr,rl)		move PARM string
	desc9a	1|0,al
	desc9a	2|PARM,al
	sta	2|PARM_count
	cmpx0	2,du		is there a second arg ?
	tze	old_MAIN_ext_join
	lda	0|2,1*		second arg descriptor
	ana	neg_mask
	cmpa	fb35_desc
	tnz	old_MAIN_err_5	it is not fixed bin(35) !
old_MAIN_ext_join:
	epp2	7|stack_header.stack_end_ptr,*
	spri6	2|stack_frame.prev_sp
	spri0	2|stack_frame.arg_ptr	"areg_ptr" in new stack frame
	epp0	2|0,7		get ptr to new stack end
	spri0	2|math_work_ptr
	epp0	0|math_work_size
	spri0	2|stack_frame.next_sp
	spri0	7|stack_header.stack_end_ptr 	initiate new stack end
	epp6	2|0		PR6 -> stack frame of the procedure
	spri4	6|old_linkage_ptr	"old_linkage_ptr" in new stack frame
	epbp1	3|0		get ptr to the base of procedure segment
	epp1	1|0,x6		get ptr to entry point of the proc
	spri1	6|stack_frame.entry_ptr	"entry_ptr" of new stack frame
	spri5	6|stack_frame.operator_ptr	"operator_ptr" in new stack frame
	epp0	5|0		PR0 -> pascal operators
	adq	my_old_id,du
	stq	6|stack_frame.translator_id
	epp1	null_ptr,*
	spri1	6|old_dlinkw
	ldi	0,dl		reset indicators
	tra	3|0		return to procedure
old_MAIN_err_1:
	ldx0	1,du
	tra	old_MAIN_err_call
old_MAIN_err_2:
	ldx0	2,du
	tra	old_MAIN_err_call
old_MAIN_err_3:
	ldx0	3,du
	tra	old_MAIN_err_call
old_MAIN_err_4:
	ldx0	4,du
	tra	old_MAIN_err_call
old_MAIN_err_5:
	ldx0	5,du
old_MAIN_err_call:
	tsp3	old_MAIN_ext_join
	stz	6|err_code
	sxl0	6|err_code
	epp1	<pascal_errors_>|[v6_MAIN_error]
	tra	common_op_call
"
"
"
"
"		old entry operator for internal procedures
"		------------------------------------------
"
old_int_entry:
	eaa	7|stack_header.stack_end_ptr,*
	spri6	7|stack_frame.prev_sp,au
	spri2	7|stack_frame.arg_ptr,au
	epp2	6|stack_frame.next_sp,*x7
	spri2	7|math_work_ptr,au
	epp2	2|math_work_size
	spri2	7|stack_frame.next_sp,au
	lda	6|stack_frame.translator_id
	epp6	7|stack_header.stack_end_ptr,*
	spri2	7|stack_header.stack_end_ptr
	ana	non_MAIN_mask
	sta	6|stack_frame.translator_id
	spri1	6|old_dlinkw
	spri4	6|old_linkage_ptr
	spri5	6|stack_frame.entry_ptr
	ldi	0,dl
	tra	3|0
"
"
"
"
"		old entry operator for DEF (exportable) procedures
"		--------------------------------------------------
"
old_ext_entry_force_fast:
	ldq	fast_bit,dl
	tra	old_ext_join
old_ext_entry:
	ldq	0,dl
old_ext_join:
	epaq	3|0		get procedure seg number
	lprp4	7|stack_header.lot_ptr,*au	PR4 -> link sect of procedure
	epp2	7|stack_header.stack_end_ptr,*
	spri6	2|stack_frame.prev_sp
	spri0	2|stack_frame.arg_ptr	"areg_ptr" in new stack frame
	epp0	2|0,7		get ptr to new stack end
	spri0	2|math_work_ptr
	epp0	0|math_work_size
	spri0	2|stack_frame.next_sp
	spri0	7|stack_header.stack_end_ptr 	initiate new stack end
	epp6	2|0		PR6 -> stack frame of the procedure
	spri4	6|old_linkage_ptr	"old_linkage_ptr" in new stack frame
	spri1	6|old_dlinkw
	epbp1	3|0		get ptr to the base of procedure segment
	epp1	1|0,x6		get ptr to entry point of the proc
	spri1	6|stack_frame.entry_ptr	"entry_ptr" of new stack frame
	spri5	6|stack_frame.operator_ptr	"operator_ptr" in new stack frame
	epp0	5|0		PR0 -> pascal operators
	adq	my_old_id,du
	stq	6|stack_frame.translator_id
	ldi	0,dl		reset indicators
	tra	3|0		return to procedure
"
"
"
"
"		old_trace_MAIN_entry operator
"		-----------------------------
"
old_trace_MAIN_entry_force_fast:
	eax5	main_bit+fast_bit
	tra	old_trace_MAIN_join
old_trace_MAIN_entry:
	eax5	main_bit
old_trace_MAIN_join:
	stz	2|COND
	ldx0	0|0		x0 : 2*nbr_of_args
	tnz	+3,ic
	stz	2|PARM_count	no args
	tra	old_trace_join
	cmpx0	6,du
	trc	old_MAIN_err_1	too much args (>2)
	ldx1	0|1		x1 : 2*nbr_of_descriptors
	tze	old_MAIN_err_2	no descriptors
	lxl2	0|0		is there a stack_frams ptr ?
	anx2	8+2,du
	tze	+2,ic
	eax1	2,1		if any skip it
	eax1	2,1		x1 : offset of the first desc.
	lda	0|0,1*		first descriptor
	ana	=o375700,du
	cmpa	=o124000,du
	tnz	old_MAIN_err_3	it is not a char string
	lda	0|0,1*
	tmi	+2,ic
	ana	=o777777,dl	old descriptor
	ana	descriptor_mask
	cmpa	101,dl
	trc	old_MAIN_err_4	>100 characters. too long!
	epp1	0|2,*		PR1 -> PARM string
	even
	mlr	(pr,rl),(pr,rl)		move PARM string
	desc9a	1|0,al
	desc9a	2|PARM,al
	sta	2|PARM_count
	cmpx0	2,du		is there a second arg ?
	tze	old_trace_join
	lda	0|2,1*		second arg descriptor
	ana	neg_mask
	cmpa	fb35_desc
	tnz	old_MAIN_err_5	it is not fixed bin(35) !
old_trace_join:
	epp1	7|stack_header.stack_end_ptr,*
	sprp3	1|0
	sprp3	1|1
	sxl6	1|0
	stx5	1|1
"
"	At this moment, first two words of next stack frame, saved by trace,
"	contain:
"		packed ptr to entry point (1 word. required by trace)
"		PASCAL execution flags (1 half word)
"		offset of next word in calling object (1 half word)
"
"	Trace is supposed to restore x7, pr6, pr0, pr7
"
	epaq	0,ic
	lprp4	7|stack_header.lot_ptr,*au
	tsp2	<trace>|[catch_pl1_]
"
	epp2	7|stack_header.stack_end_ptr,*
	spri6	2|stack_frame.prev_sp
	spri0	2|stack_frame.arg_ptr
	epp0	2|0,7
	spri0	2|math_work_ptr
	epp0	0|math_work_size
	spri0	2|stack_frame.next_sp
	spri0	7|stack_header.stack_end_ptr
	epp6	2|0
	lprp3	6|0
	spri3	6|stack_frame.entry_ptr
	epaq	3|0
	lprp4	7|stack_header.lot_ptr,*au
	spri4	6|old_linkage_ptr
	epp0	trace_transfer_vector
	spri0	6|stack_frame.operator_ptr
	ldx5	6|1
	sxl5	6|stack_frame.translator_id
	eax5	my_old_id
	stx5	6|stack_frame.translator_id
	epp1	null_ptr,*
	spri1	6|old_dlinkw
	epbp3	3|0
	lxl6	6|1
	tra	3|0,x6
"
"
"
"
"		old_trace_ext_entry_operator
"		----------------------------
"
old_trace_ext_entry_force_fast:
	epp2	7|stack_header.stack_end_ptr,*
	sprp3	2|0
	sprp1	2|1
"
"	At this moment, first two words of next stack frame, saved by trace,
"	contain:
"		packed ptr to entry point (1 word. required by trace)
"		packed dlink ptr (1 word)
"
"	Trace is supposed to restore x7, pr6, pr0, pr7
"
	epaq	0,ic
	lprp4	7|stack_header.lot_ptr,*au
	tsp2	<trace>|[catch_pl1_]
"
	ldq	main_bit,dl
	tra	old_trace_ext_join
"
"
"
"
old_trace_ext_entry:
	epp2	7|stack_header.stack_end_ptr,*
	sprp3	2|0
	sprp1	2|1
"
"	At this moment, first two words of next stack frame, saved by trace,
"	contain:
"		packed ptr to entry point (1 word. required by trace)
"		packed dlink ptr (1 word)
"
"	Trace is supposed to restore x7, pr6, pr0, pr7
"
	epaq	0,ic
	lprp4	7|stack_header.lot_ptr,*au
	tsp2	<trace>|[catch_pl1_]
"
	ldq	0,dl
old_trace_ext_join:
	epp2	7|stack_header.stack_end_ptr,*
	spri6	2|stack_frame.prev_sp
	spri0	2|stack_frame.arg_ptr
	epp0	2|0,7
	spri0	2|math_work_ptr
	epp0	0|math_work_size
	spri0	2|stack_frame.next_sp
	spri0	7|stack_header.stack_end_ptr
	epp6	2|0
	lprp3	6|0
	spri3	6|stack_frame.entry_ptr
	lprp1	3|1
	spri1	6|old_dlinkw
	adq	my_id,du
	stq	6|stack_frame.translator_id
	epaq	3|0
	lprp4	7|stack_header.lot_ptr,*au
	spri4	6|old_linkage_ptr
	epp0	trace_transfer_vector
	spri0	6|stack_frame.operator_ptr
	ldi	0,dl
	tra	3|8
old_entry_operators_end:
"
"
"
"		old_TRUNC operator
"		------------------
"
old_TRUNC:
	stx0	6|stack_frame.regs	save x0
	dfst	6|op_work+0
	lda	6|op_work+0		
	ars	28
	neg
	ada	35,dl
	tmi	trunc_error
	eax0	0,al	
	dfld	6|op_work+0
	lrs	0,x0
	tpl	2,ic
	adaq	mask1
	ldx0	6|stack_frame.regs		restore x0
	ada	0,dl
	tra	3|0			return
"
"
"
"
"		old_ROUND operator
"		------------------
old_ROUND:
	stx0	6|stack_frame.regs		save x0
	dfst	6|op_work+0
	lda	6|op_work+0
	ars	28
	neg
	ada	35,dl
	tmi	round_error
	eax0	0,al
	dfld	6|op_work+0
	lrs	0,x0
	adaq	mask2
	ldx0	0|stack_frame.regs
	ada	0,dl
	tra	3|0		return to user
old_trunc_round_zero:
	ldx0	6|stack_frame.regs
	lda	0,dl		return zero value
	tra	3|0
"
"
"
"
"		old_COS operator
"		----------------
"
old_COS:
	spri	6|op_work
	sreg	6|stack_frame.regs
	epaq	0,ic
	epbp7	6|0
	lprp4	7|stack_header.lot_ptr,*au
	epp2	6|math_work_ptr,*
	tsp3	<double_sine_>|[double_cosine_radians_]
	tra	old_common_math_return
"
"
"
"
"		old_SIN operator
"		----------------
"
old_SIN:
	spri	6|op_work
	sreg	6|stack_frame.regs
	epaq	0,ic
	epbp7	6|0
	lprp4	7|stack_header.lot_ptr,*au
	epp2	6|math_work_ptr,*
	tsp3	<double_sine_>|[double_sine_radians_]
	tra	old_common_math_return
"
"
"
"
"		old_LOG10 operator
"		------------------
old_LOG10:
	spri	6|op_work
	sreg	6|stack_frame.regs
	epaq	0,ic
	epbp7	6|0
	lprp4	7|stack_header.lot_ptr,*au
	epp2	6|math_work_ptr,*
	tsp3	<double_logarithm_>|[double_log_base_10_]
	tra	old_common_math_return
"
"
"
"
"		old_LOG operator
"		----------------
"
old_LOG:
	spri	6|op_work
	sreg	6|stack_frame.regs
	epaq	0,ic
	epbp7	6|0
	lprp4	7|stack_header.lot_ptr,*au
	epp2	6|math_work_ptr,*
	tsp3	<double_logarithm_>|[double_log_base_e_]
	tra	old_common_math_return
"
"
"
"
"		old_EXP operator
"		----------------
"
old_EXP:
	spri	6|op_work
	sreg	6|stack_frame.regs
	epaq	0,ic
	epbp7	6|0
	lprp4	7|stack_header.lot_ptr,*au
	epp2	6|math_work_ptr,*
	tsp3	<double_exponential_>|[double_exponential_]
	tra	old_common_math_return
"
"
"
"
"		old_ATAN operator
"		-----------------
"
old_ATAN:
	spri	6|op_work
	sreg	6|stack_frame.regs
	epaq	0,ic
	epbp7	6|0
	lprp4	7|stack_header.lot_ptr,*au
	epp2	6|math_work_ptr,*
	tsp3	<double_arc_tangent_>|[double_arc_tangent_radians_]
	tra	old_common_math_return
"
"
"
"
"		old_SQRT operator
"		-----------------
"
old_SQRT:
	spri	6|op_work
	sreg	6|stack_frame.regs
	epaq	0,ic
	epbp7	6|0
	lprp4	7|stack_header.lot_ptr,*au
	epp2	6|math_work_ptr,*
	tsp3	<double_square_root_>|[double_square_root_]
	tra	old_common_math_return
"
old_common_math_return:
	lpri	6|op_work
	staq	6|stack_frame.regs+4
	ste	6|stack_frame.regs+6
	lreg	6|stack_frame.regs
	szn	6|stack_frame.regs+4
	tra	3|0
"
"
"
pascal_operators_end:
"
"
"
"	pascal_gen_call_ entry point (used for probe call request)
"
"
"
	segdef	pascal_gen_call_
"
"
"	PR0 -> arg list
"		arg 1 : ptr to entry
"		arg 2 : ptr to arg list
"		arg 3 : display ptr
"		arg 4 : operator number
"		arg 5 : return code
"	PR6 -> stack of caller (probe call request)
"	PR7 -> base of stack
pascal_gen_call_:
	stz	0|10,*	return code = 0
	lda	0|8,*	op nbr
	cmpa	43,dl	ext_call ?
	tze 	gen_ext_call
	cmpa	42,dl	int_call ?
	tze	gen_int_call
	lda	1,dl
	sta	0|10,*	code = 1 (invalid op nbr)
	tra	6|stack_frame.return_ptr,*	return to caller
"
gen_ext_call:
	epp5	0|2,*	entry
	epp5	5|0,*
	epp0	0|4,*	arg list
	epp0	0|0,*
	call6	5|0	call it, Sam
"
gen_int_call:
	epp5	gen_ext_call
	epp2	7|stack_header.trans_op_tv_ptr,*
	epp2	2|8,*
	ldq 	0,dl
	ldx7	96,du
	tsp3	MAIN_entry
	nop
	nop
	epp1	6|stack_frame.arg_ptr,*
	epp2	1|4,*	arg list ptr
	epp2	2|0,*	arg list
	epp5	1|2,*	entry ptr
	epp5	5|0,*	entry
	epp1	1|6,*	display ptr
	epp1	1|0,*	display
	epp3	gen_int_return
	spri3	6|stack_frame.return_ptr
	epaq	5|0
	lprp4	7|stack_header.lot_ptr,*au
	call6	5|0	Ykkou !
"
gen_int_return:
	tra 	ext_return
"
"
	end
"
"
