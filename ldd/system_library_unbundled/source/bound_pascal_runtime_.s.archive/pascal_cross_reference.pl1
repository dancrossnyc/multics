/****^  *************************************************************************
        *                                                                       *
        * Copyright (c) 1984 by Centre Interuniversitaire de Calcul de Grenoble *
        * and Institut National de Recherche en Informatique et Automatique     *
        *                                                                       *
        ************************************************************************* */


/****^  HISTORY COMMENTS:
  1) change(86-10-05,JMAthane), approve(86-10-05,MCR7521),
     audit(86-10-09,JPFauche), install(86-11-12,MR12.0-1212):
     Pascal version for MR12.
                                                   END HISTORY COMMENTS */

/* format: style4,^linecom,^ifthendo,^indproc,^indblkcom,initcol1,declareind8,dclind4,struclvlind1 */

pascal_cref:
pascal_cross_reference: proc;


/* Author : JMAthane . February 84 */

/* Multics */

dcl get_temp_segment_ entry (char (*), ptr, fixed bin (35));
dcl define_area_ entry (ptr, fixed bin (35));
dcl release_temp_segment_ entry (char (*), ptr, fixed bin (35));
dcl release_area_ entry (ptr);
dcl sys_info$max_seg_size fixed bin (35) ext;
dcl stu_$find_containing_block entry (ptr, fixed bin (18) unsigned) returns (ptr);
dcl ioa_$ioa_switch entry options (variable);
dcl ioa_$ioa_switch_nnl entry options (variable);
dcl cu_$arg_ptr entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
dcl object_info_$display entry (ptr, fixed bin (24), ptr, fixed bin (35));
dcl com_err_ entry options (variable);
dcl cu_$arg_count entry (fixed bin, fixed bin (35));
dcl hcs_$status_ entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));
dcl hcs_$initiate_count entry
         (char (*), char (*), char (*), fixed bin (24), fixed bin (2), ptr, fixed bin (35));
dcl get_wdir_ entry returns (char (168));
dcl get_pdir_ entry returns (char (168));
dcl unique_bits_ entry returns (bit (70));
dcl unique_chars_ entry (bit (*)) returns (char (15));
dcl iox_$detach_iocb entry (ptr, fixed bin (35));
dcl iox_$attach_name entry (char (*), ptr, char (*), ptr, fixed bin (35));
dcl iox_$close entry (ptr, fixed bin (35));
dcl iox_$open entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
dcl iox_$destroy_iocb entry (ptr, fixed bin (35));
dcl expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));
dcl date_time_ entry (fixed bin (71), char (*));
dcl decode_definition_ entry (ptr, ptr, bit (1) aligned);
dcl stu_$find_runtime_symbol entry (ptr, char (*), ptr, fixed bin) returns (ptr);

/* Automatic */

dcl int_name char (32) var;
dcl origin char (64) var;
dcl int_symbol_area_ptr ptr init (null);
dcl int_symbol_box_ptr ptr;
dcl root_block ptr;
dcl eof bit (1) aligned;
dcl previous_by ptr;
dcl chain_ptr (26) ptr;
dcl (curr_symbol, curr_block, pl1_symb, decl_block, ext_item_box_ptr) ptr;
dcl steps fixed bin;
dcl 1 def_structure like decode_definition_str;
dcl (include_box_ptr, include_ref_box_ptr, symbol_base, base_p) ptr;
dcl module_name_box_ptr ptr;
dcl main_name char (32);
dcl tittle bit (1);
dcl px_area_ptr ptr init (null);
dcl box_ptr ptr;
dcl symb_name char (32);
dcl ext_module_ptr ptr;
dcl long_string char (10000) var;
dcl type_pair_ptr ptr;
dcl (link_ptr, expr_ptr) ptr;
dcl (segname, offsetname) char (32);
dcl arg_count fixed bin;
dcl (code, n_modules) fixed bin (35) init (0);
dcl bc fixed bin (24);
dcl (it1, it2) fixed bin;
dcl arg_len fixed bin (21);
dcl arg_ptr ptr;
dcl dir char (168);
dcl entry char (32);
dcl (info_ptr, module_box_ptr, current, previous) ptr;
dcl 1 (ref_type_info, new_type_info) like runtime_type_info;
dcl (first_module, first_module_name, first_include, first_ext_item, first_compared_types) ptr init (null);
dcl incl_path char (168);
dcl incl_uid bit (36);
dcl auto_refs_only bit (1);
dcl incl_dtm fixed bin (71);
dcl err_in_args bit (1) init ("0"b);
dcl (output, error_ptr, warning_ptr) ptr init (null);
dcl (error_count, warning_count) fixed bin init (0);
dcl output_switch char (32);
dcl output_seg_name char (32) init ("pascal_cross_reference.map");
dcl output_file bit (1) init ("0"b);
dcl time_string char (24);
dcl str_l fixed bin;
dcl str_p ptr;
dcl 1 address_info like runtime_address_info;
dcl 1 type_info like runtime_type_info;
dcl 1 type_type_info like runtime_type_info;
dcl ext_ref_box_ptr ptr;
dcl all_ref_table bit (1) init ("1"b);
dcl (referenced, set) bit (1);
						/* args and default value */
dcl int_refs bit (1) init ("0"b);
dcl ext_refs bit (1) init ("0"b);
dcl hdr_sw bit (1) init ("1"b);
						/* Static */

dcl me char (22) init ("pascal_cross_refence") int static;
dcl 1 my_area_info like area_info int static;
dcl output_suffix char (9) init (".x_map") int static;
						/* Builtin */

dcl (null, length, rtrim, addrel, substr, reverse) builtin;


/* Based */

dcl b_str char (str_l) based (str_p);
dcl error_string char (255 * 1024 * 4 - 4) var based (error_ptr);
dcl warning_string char (255 * 1024 * 4 - 4) var based (warning_ptr);
dcl 1 my_status_branch like status_branch;
dcl arg char (arg_len) based (arg_ptr);
dcl 1 module_box based (module_box_ptr),
     2 module_name char (168),			/* given name */
     2 module_dir char (168),				/* dir name */
     2 module_entry char (32),			/* entry_name */
     2 module_path char (200) var,			/* complete path */
     2 module_next ptr,				/* alfa thread */
     2 module_ptr ptr,				/* ptr to base of segment */
     2 module_names ptr,				/* ptr to names of this module */
     2 module_info ptr;				/* to object info structure */
dcl px_area area (sys_info$max_seg_size) based (px_area_ptr);
dcl int_symbol_area area (sys_info$max_seg_size) based (int_symbol_area_ptr);
dcl 1 module_name_box based (module_name_box_ptr),
     2 module_name_name char (32),			/* the name itself */
     2 module_name_syn ptr,				/* thread of names of this module */
     2 module_name_of ptr,				/* ptr to module box */
     2 module_name_next ptr;				/* alfa thread of module_names */
dcl 1 include_box based (include_box_ptr),
     2 include_path char (168),
     2 include_dtm fixed bin (71),
     2 include_uid bit (36),
     2 include_next ptr,
     2 include_references ptr;
dcl 1 ext_item_box based (ext_item_box_ptr),
     2 ext_item_syn_of ptr,
     2 ext_item_name char (32),
     2 ext_item_from ptr,
     2 ext_item_to ptr,
     2 ext_item_symbol ptr,
     2 ext_item_next ptr,
     2 ext_item_segn char (32),
     2 ext_item_is_variable bit (1),
     2 ext_item_is_main bit (1),
     2 ext_item_linkplace fixed bin (35),
     2 ext_item_location fixed bin (35);
dcl 1 include_ref_box based (include_ref_box_ptr),
     2 include_ref_by ptr,
     2 include_ref_next ptr;
dcl 1 ext_ref_box based (ext_ref_box_ptr),
     2 ext_ref_symbol ptr,
     2 ext_ref_by ptr,
     2 ext_ref_next ptr,
     2 ext_ref_segn char (32),
     2 ext_ref_is_variable bit (1),
     2 ext_ref_offsetn char (32);
dcl 1 int_symbol_box based (int_symbol_box_ptr),
     2 int_symbol_name char (32),
     2 int_symbol_ptr ptr,
     2 int_symbol_next ptr,
     2 int_symbol_proc_name ptr,
     2 int_symbol_class fixed bin,
     2 int_item_location fixed bin (35),
     2 int_item_is_variable bit (1);
dcl 1 link based,
     2 mbz1 bit (36) unal,
     2 exp_ptr bit (18) unal,
     2 mbz2 bit (12) unal,
     2 mod bit (6) unal;

/* conditions */

dcl cleanup condition;
%page;
	call initiate_px;
	on cleanup call terminate_px;

	call cu_$arg_count (arg_count, code);
	if code ^= 0 then call standard_error ("");
	if arg_count = 0 then do;
	     call com_err_ (0, me, "Usage : pascal_cross_reference <names> {-control_args}");
	     return;
	end;

	do it1 = 1 to arg_count;
	     call cu_$arg_ptr (it1, arg_ptr, arg_len, code);
	     if code ^= 0 then call standard_error ("");
	     if substr (arg, 1, 1) ^= "-" then /* seg name */
		if arg_len > 168 then
		     call err_in_arg ("Arg too long (>168 chars) : """ || arg || """");
		else do;
		     allocate module_box in (px_area) set (module_box_ptr);
		     n_modules = n_modules + 1;
		     module_name = arg; module_names = null;
		     call expand_pathname_ ((arg), dir, entry, code);
		     if code ^= 0 then call err_in_arg ((arg));
		     else do;
			module_dir = dir;
			call hcs_$initiate_count (dir, entry, "", bc, 0, module_ptr, code);
			if module_ptr = null then call err_in_arg ((arg));
			else do;
			     allocate object_info in (px_area) set (module_info);
			     module_info -> object_info.version_number = object_info_version_2;
			     call object_info_$display (module_ptr, bc, module_info, code);
			     if code ^= 0 then call err_in_arg ((arg));
			     else do;
				if module_info -> compiler ^= "PASCAL" then
				     call err_in_arg (arg || " is not a Pascal object segment.");
				if module_info -> bound then call err_in_arg (arg || " is a bound segment.");
				else if ^(addrel (module_info -> symbp, module_info -> symbp -> area_pointer)
					-> pl1_symbol_block.table) then
				     call err_in_arg (arg || " has no symbol table.");
						/* get names of module */
				status_ptr = addr (my_status_branch); status_area_ptr = px_area_ptr;
				call hcs_$status_ (dir, entry, 0, status_ptr, px_area_ptr, code);
				if code ^= 0 then
				     call err_in_arg ("Cannot get status of " || arg);
				else do;
				     module_entry = status_entry_names (1);
				     module_path = rtrim (dir) || ">" || rtrim (module_entry);
				     do it2 = 1 to status_branch.nnames;
					allocate module_name_box in (px_area) set (module_name_box_ptr);
					module_name_name = status_entry_names (it2);
					module_name_of = module_box_ptr;
					module_name_syn = module_names; module_names = module_name_box_ptr;
					current = first_module_name; previous = null;
loop_2:
					if current ^= null then
					     if (current -> module_name_name < module_name_name) then do;
						previous = current; current = current -> module_name_next;
						go to loop_2;
					     end;
					     else if (current -> module_name_name = module_name_name) then
						call err_in_arg
						     ("Segment name duplication. Cannot solve references to " || module_name_name);
					if previous = null then first_module_name = module_name_box_ptr;
					else previous -> module_name_next = module_name_box_ptr;
					module_name_next = current;
				     end;
				end;
				current = first_module; previous = null;
loop_1:
				if current ^= null then
				     if (current -> module_entry < module_entry) then do;
					previous = current; current = current -> module_next;
					go to loop_1;
				     end;
				if previous = null then first_module = module_box_ptr;
				else previous -> module_next = module_box_ptr;
				module_next = current;
			     end;
			end;
		     end;
		end;
	     else /* control args */
		if (arg = "-of") | (arg = "-output_file") then do;
		if it1 = arg_count then
		     call err_in_arg ("Argument expected after " || arg || " argument.");
		else do;
		     it1 = it1 + 1;
		     call cu_$arg_ptr (it1, arg_ptr, arg_len, code);
		     if code ^= 0 then call err_in_arg ("");
		     output_file = "1"b;
		     if arg_len > (32 - length (output_suffix)) then
			call err_in_arg ("Name too long : " || arg || output_suffix);
		     else output_seg_name = arg || output_suffix;
		end;
	     end;
	     else if (arg = "-int_refs") | (arg = "-internal_references") then int_refs = "1"b;
	     else if (arg = "-no_int_refs") | (arg = "-no_internal_cross_ref") then int_refs = "0"b;
	     else if (arg = "-ext_refs") | (arg = "-external_references") then ext_refs = "1"b;
	     else if (arg = "-no_ext_refs") | (arg = "-no_external_references") then ext_refs = "0"b;
/*
	     else if (arg = "-hdr") | (arg = "-header") then hdr_sw = "1"b;
	     else if (arg = "-nhdr") | (arg = "-no_header") then hdr_sw = "0"b;
*/
	     else call err_in_arg ("Unknown argument : " || arg);
	end;
	if err_in_args then go to STOP_ON_ERROR;
%page;
	type_type_info.version = RUNTIME_TYPE_INFO_VERSION_1;
	type_info.version = RUNTIME_TYPE_INFO_VERSION_1;
	new_type_info.version = RUNTIME_TYPE_INFO_VERSION_1;
	ref_type_info.version = RUNTIME_TYPE_INFO_VERSION_1;
	address_info.version = RUNTIME_ADDRESS_INFO_VERSION_1;

	output_switch = "pascal_cref" || unique_chars_ (unique_bits_ ());
	if output_file then
	     call iox_$attach_name (output_switch, output, "vfile_ " || output_seg_name, null, code);
	else do;
	     call iox_$attach_name (output_switch, output, "discard_", null, code);
	     hdr_sw = "0"b;
	end;
	if code ^= 0 then call standard_error ("io switch " || output_switch);
	call iox_$open (output, 2, "0"b, code);
	if code ^= 0 then call standard_error ("io switch " || output_switch);

	call ioa_$ioa_switch (output,
	     "			PASCAL SEPARATE COMPILATION CROSS REFERENCE LISTING OF FOLLOWING ^d MODULES:
", n_modules);
	module_box_ptr = first_module;
	do while (module_box_ptr ^= null);
	     symbol_base, base_p = module_info -> symbp;
	     call ioa_$ioa_switch (output, "
	^a", module_path);
	     long_string = "	     Names : ";
	     current = module_names;
	     do while (current ^= null);
		long_string = long_string || " " || rtrim (current -> module_name_name);
		current = current -> module_name_syn;
	     end;
	     call edit_string ((20)" ", 120);
	     str_p = addrel (symbol_base, base_p -> userid.offset); str_l = fixed (base_p -> userid.size);
	     if hdr_sw then
		call ioa_$ioa_switch (output, "	     Compiled by : ^a", b_str);
	     call date_time_ (symbol_base -> object_created, time_string);
	     if hdr_sw then
		call ioa_$ioa_switch (output, "	     Compiled on : ^a", time_string);
	     str_p = addrel (symbol_base, base_p -> std_symbol_header.comment.offset);
	     str_l = fixed (base_p -> std_symbol_header.comment.size);
	     if index (b_str, "reference_table") = 0 then all_ref_table = "0"b;
	     if hdr_sw then
		call ioa_$ioa_switch (output, "	     Options : ^a", b_str);
	     if hdr_sw then
		call ioa_$ioa_switch (output, "	     Source :");
	     base_p = addrel (symbol_base, base_p -> std_symbol_header.source_map);
	     do it1 = 1 to base_p -> source_map.number;
		str_p = addrel (symbol_base, base_p -> source_map.offset (it1));
		str_l = fixed (base_p -> source_map.size (it1));
		call date_time_ (base_p -> source_map.dtm (it1), time_string);
		if hdr_sw then
		     call ioa_$ioa_switch (output, "		^a ^a", time_string, b_str);
	     end;
						/* memorize include file references */
	     do it1 = 2 to base_p -> source_map.number;
		str_l = fixed (base_p -> source_map.size (it1));
		str_p = addrel (symbol_base, base_p -> source_map.offset (it1));
		incl_path = b_str; incl_dtm = base_p -> source_map.dtm (it1);
		incl_uid = base_p -> source_map.uid (it1);
		current = first_include; previous = null;
loop_3:
		if current ^= null then
		     do while (current -> include_uid <= incl_uid);
		     previous = current; current = current -> include_next;
		     go to loop_3;
		end;
		if previous ^= null then
		     if previous -> include_uid = incl_uid then do;
			include_box_ptr = previous;
			go to include_box_allocated;
		     end;
		allocate include_box in (px_area) set (include_box_ptr);
		include_path = incl_path;
		include_dtm = incl_dtm;
		include_uid = incl_uid;
		include_references = null;
		if previous = null then first_include = include_box_ptr;
		else previous -> include_next = include_box_ptr;
		include_next = current;
include_box_allocated:
		allocate include_ref_box in (px_area) set (include_ref_box_ptr);
		include_ref_by = module_box_ptr;
		include_ref_next = include_references;
		include_references = include_ref_box_ptr;
	     end;
						/* create boxes for exported items */
	     pl1_symb = addrel (symbol_base, symbol_base -> area_pointer);
	     curr_block = addrel (symbol_base, pl1_symb -> root);
	     curr_block = addrel (curr_block, curr_block -> symbol_block.son);
	     main_name = addrel (curr_block, curr_block -> symbol_block.name) -> acc_string.string;
	     call decode_definition_ (module_ptr, addr (def_structure), eof);
	     do while (^eof);
		if (def_structure.section = "text") | (def_structure.section = "link") then do;
		     if def_structure.symbol ^= main_name then
			curr_symbol = stu_$find_runtime_symbol (curr_block,
			     rtrim (def_structure.symbol), decl_block, steps);
		     else
			curr_symbol = stu_$find_runtime_symbol (addrel (curr_block, curr_block -> symbol_block.father),
			     rtrim (def_structure.symbol), decl_block, steps);
		     if curr_symbol ^= null then do;
			current = first_ext_item; previous = null;
loop_4:
			if current ^= null then
			     if (current -> ext_item_name <= def_structure.symbol) then do;
				if (current -> ext_item_name = def_structure.symbol) then
				     if current -> ext_item_from = module_box_ptr then do;
					ext_item_box_ptr = current;
					go to ext_item_box_allocated_1;
				     end;
				previous = current; current = current -> ext_item_next;
				go to loop_4;
			     end;
			allocate ext_item_box in (px_area) set (ext_item_box_ptr);
			ext_item_name = def_structure.symbol;
			ext_item_from = module_box_ptr;
			ext_item_to = null;
			if previous = null then first_ext_item = ext_item_box_ptr;
			else previous -> ext_item_next = ext_item_box_ptr;
			ext_item_next = current;
ext_item_box_allocated_1:
			if def_structure.section = "text" then do;
			     ext_item_segn = "*text";
			     ext_item_is_main = (def_structure.symbol = main_name);
			     call runtime_symbol_info_$address (curr_symbol, addr (address_info), code);
			     if code ^= 0 then call standard_error ("Error while getting symbol info.");
			     ext_item_location = address_info.location;
			end;
			else do;
			     ext_item_segn = get_link_segn (module_info, def_structure.offset);
			     ext_item_is_variable = "1"b;
			end;
			ext_item_syn_of = null;
			ext_item_symbol = curr_symbol;
			ext_item_linkplace = def_structure.offset;
		     end;
		end;
		call decode_definition_ ((def_structure.next_def), addr (def_structure), eof);
	     end;
						/* create boxes for imported items */
	     curr_symbol = addrel (curr_block, curr_block -> symbol_block.start);
	     do while (curr_symbol ^= null);
		call runtime_symbol_info_$address (curr_symbol, addr (address_info), code);
		if code ^= 0 then call standard_error ("Error while getting symbol info.");
		if (address_info.class = pascal_ext_file_class_code)
		     | (address_info.class = pascal_external_global_class_code) then do;
		     segname = get_link_segn (module_info, (address_info.location));
		     offsetname =
			addrel (module_info -> defp, type_pair_ptr -> type_pair.offsetname_relp) -> acc_string.string;
		     current = first_ext_item; previous = null;
loop_7:
		     if current ^= null then do;
			if current -> ext_item_from = module_box_ptr then
			     if current -> ext_item_linkplace = address_info.location then go to skip_it;
			previous = current; current = current -> ext_item_next;
			go to loop_7;
		     end;
		     module_name_box_ptr = first_module_name;
		     do while (module_name_box_ptr ^= null);
			if module_name_name = segname then go to seg_found;
			module_name_box_ptr = module_name_next;
		     end;
seg_found:
		     if module_name_box_ptr = null then ext_module_ptr = null;
		     else ext_module_ptr = module_name_of;
		     current = first_ext_item; previous = null;
loop_5:
		     if current ^= null then
			if (current -> ext_item_name <= offsetname) then do;
			     if (current -> ext_item_name = offsetname) then
				if current -> ext_item_from = ext_module_ptr then do;
				     ext_item_box_ptr = current;
				     go to ext_item_box_allocated_2;
				end;
			     previous = current; current = current -> ext_item_next;
			     go to loop_5;
			end;
		     allocate ext_item_box in (px_area) set (ext_item_box_ptr);
		     ext_item_segn = segname;
		     ext_item_linkplace = 0;
		     ext_item_name = offsetname;
		     ext_item_from = ext_module_ptr;
		     ext_item_to = null;
		     if previous = null then first_ext_item = ext_item_box_ptr;
		     else previous -> ext_item_next = ext_item_box_ptr;
		     ext_item_next = current;
		     ext_item_syn_of = null;
		     ext_item_symbol = null;
ext_item_box_allocated_2:
		     allocate ext_ref_box in (px_area) set (ext_ref_box_ptr);
		     ext_ref_by = module_box_ptr;
		     ext_ref_next = ext_item_to;
		     ext_item_to = ext_ref_box_ptr;
		     ext_ref_segn = segname;
		     ext_ref_offsetn = offsetname;
		     ext_ref_symbol = curr_symbol;
		     symb_name = runtime_symbol_info_$name (curr_symbol) -> acc_string.string;
		     if symb_name ^= offsetname then do;
			box_ptr = ext_item_box_ptr;
			allocate ext_item_box in (px_area) set (ext_item_box_ptr);
			ext_item_segn = "";
			current = first_ext_item; previous = null;
loop_6:
			if current ^= null then
			     if (current -> ext_item_name < symb_name) then do;
				previous = current; current = current -> ext_item_next;
				go to loop_6;
			     end;
			if previous = null then first_ext_item = ext_item_box_ptr;
			else previous -> ext_item_next = ext_item_box_ptr;
			ext_item_next = current;
			ext_item_syn_of = box_ptr;
			ext_item_name = symb_name;
			ext_item_from = null;
			ext_item_to = module_box_ptr;
			ext_item_symbol = curr_symbol;
		     end;
		end;
skip_it:
		curr_symbol = runtime_symbol_info_$brother (curr_symbol);
	     end;
	     module_box_ptr = module_next;
	end;
	if (int_refs | ext_refs) & (^all_ref_table) then
	     call standard_error
		("Some modules dont have reference table. Cannot edit variables or procedures references.");

%page;
/* edit external items cross_reference */
	call ioa_$ioa_switch (output, "^|
		EXTERNAL VARIABLES AND PROCEDURES

");
	ext_item_box_ptr = first_ext_item;
	do while (ext_item_box_ptr ^= null);
	     if ext_item_syn_of = null then do;
		call ioa_$ioa_switch (output, "
^a	^[
     Allocation : external_static^]^[
     Allocation : in ^a^]",
		     ext_item_name, ext_item_segn = "*system", index (ext_item_segn, ".defs ") ^= 0, ext_item_segn);
		if ext_item_from ^= null then
		     if ext_item_symbol = null then do;
			call ioa_$ioa_switch (output,
			     "**** SYMBOL INFORMATION NOT AVAILABLE (see error list at the end of the listing) ****");
			error_count = error_count + 1;
			error_string = error_string || "

   " || rtrim (ext_item_name) || " imported by some modules from " ||
			     rtrim (ext_item_from -> module_entry) || "
	does not exist in this module.";
		     end;
		     else do;
			call ioa_$ioa_switch_nnl (output, "     Exported by : ^a^/^-", ext_item_from -> module_entry);
			if ^ext_item_is_main then do;
			     call pascal_symbol_$display_declaration (ext_item_symbol, output, 10, 3, "11001"b, code);
			     if code ^= 0 then call standard_error ("Error while getting symbol info.");
			end;
			else
			     call ioa_$ioa_switch (output, "main procedure");
		     end;
		else
		     call ioa_$ioa_switch (output, "     External link : ^a$^a", ext_item_segn, ext_item_name);
		ext_ref_box_ptr = ext_item_to;
		previous_by = null;
		do while (ext_ref_box_ptr ^= null);
		     int_name = runtime_symbol_info_$name (ext_ref_symbol) -> acc_string.string;
		     if previous_by ^= ext_ref_by then
			call ioa_$ioa_switch (output, "     Imported by : ^a",
			     ext_ref_by -> module_entry);
		     previous_by = ext_ref_by;
		     if (ext_item_from = null) | (ext_item_symbol = null) then do;
			call ioa_$ioa_switch_nnl (output, "^-");
			call pascal_symbol_$display_declaration (ext_ref_symbol, output, 10, 3, "11001"b, code);
			if code ^= 0 then call standard_error ("Error while getting symbol info.");
		     end;
		     else do;
			call runtime_symbol_info_$type (ext_item_symbol, addr (ref_type_info), code);
			if code ^= 0 then call standard_error ("");
			if ref_type_info.type = pascal_exportable_procedure_dtype then do;
			     call runtime_symbol_info_$type (ref_type_info.type_addr, addr (type_type_info), code);
			     if code ^= 0 then call standard_error ("");
			end;
			ext_item_is_variable =
			     (ref_type_info.type = pascal_integer_dtype) |
			     (ref_type_info.type = pascal_real_dtype) |
			     (ref_type_info.type = pascal_char_dtype) |
			     (ref_type_info.type = pascal_boolean_dtype) |
			     (ref_type_info.type = pascal_enumerated_type_instance_dtype) |
			     (ref_type_info.type = pascal_user_defined_type_instance_dtype) |
			     (ref_type_info.type = pascal_text_file_dtype) |
			     ((type_type_info.base_type ^= 0) &
			     (ref_type_info.type = pascal_exportable_procedure_dtype));
			call runtime_symbol_info_$type (ext_ref_symbol, addr (new_type_info), code);
			if code ^= 0 then call standard_error ("");
			ext_ref_is_variable =
			     (new_type_info.type = pascal_integer_dtype) |
			     (new_type_info.type = pascal_real_dtype) |
			     (new_type_info.type = pascal_char_dtype) |
			     (new_type_info.type = pascal_boolean_dtype) |
			     (new_type_info.type = pascal_enumerated_type_instance_dtype) |
			     (new_type_info.type = pascal_user_defined_type_instance_dtype) |
			     (new_type_info.type = pascal_text_file_dtype);
			if ^match_types_of
			     (rtrim (ext_item_name) || " in " || rtrim (ext_item_from -> module_entry),
			     (ref_type_info.type), ref_type_info.type_addr, ref_type_info.size,
			     int_name || " in " || rtrim (ext_ref_by -> module_entry),
			     (new_type_info.type), new_type_info.type_addr, new_type_info.size) then do;
			     call ioa_$ioa_switch_nnl (output, "^-");
			     call pascal_symbol_$display_declaration (ext_ref_symbol, output, 10, 3, "11001"b, code);
			     if code ^= 0 then call standard_error ("Error while getting symbol info.");
			     call ioa_$ioa_switch (output,
				"**** TYPE DOES NOT MATCH REFERENCE TYPE (see error list at the end of the listing) **** ");
			end;
		     end;
		     ext_ref_box_ptr = ext_ref_next;
		end;
		if ext_refs then
		     if all_ref_table then do;
			tittle = "0"b;
			auto_refs_only = "1"b;
			if ext_item_from ^= null then
			     if ext_item_symbol ^= null then
				call edit_refs ("0"b, ext_item_symbol, ext_item_from, tittle, "1"b,
				     ext_item_is_variable, auto_refs_only, ext_item_location);
			ext_ref_box_ptr = ext_item_to;
			do while (ext_ref_box_ptr ^= null);
			     call edit_refs ("0"b, ext_ref_symbol, ext_ref_by, tittle, "1"b,
				ext_ref_is_variable, auto_refs_only, -1);
			     ext_ref_box_ptr = ext_ref_next;
			end;
			referenced = tittle;
			tittle = "0"b;
			if ext_item_from ^= null then
			     if ext_item_symbol ^= null then
				if ext_item_is_variable then
				     call edit_refs ("1"b, ext_item_symbol, ext_item_from, tittle, "1"b,
					ext_item_is_variable, auto_refs_only, ext_item_location);
			ext_ref_box_ptr = ext_item_to;
			do while (ext_ref_box_ptr ^= null);
			     if ext_ref_is_variable then
				call edit_refs ("1"b, ext_ref_symbol, ext_ref_by, tittle, "1"b,
				     ext_ref_is_variable, auto_refs_only, -1);
			     ext_ref_box_ptr = ext_ref_next;
			end;
			set = tittle;
			if ext_item_from = null then origin = "";
			else origin = " exported by " || rtrim (ext_item_from -> module_name);
			if ext_item_is_variable then do;
			     if referenced & (^set) then do;
				warning_count = warning_count + 1;
				warning_string = warning_string || "

   Variable " || rtrim (ext_item_name) || origin || " is referenced and never set.";
			     end;
			     else if ^(referenced | set) then do;
				warning_count = warning_count + 1;
				warning_string = warning_string || "

   Variable " || rtrim (ext_item_name) || origin || " is never used.";
			     end;
			end;
			else
			     if ^ext_item_is_main then
			     if (^referenced) | auto_refs_only then do;
				warning_count = warning_count + 1;
				warning_string = warning_string || "

   Procedure " || rtrim (ext_item_name) || origin || " is never used.";
			     end;
		     end;
	     end;
	     else do;
		call ioa_$ioa_switch (output, "
^a", ext_item_name);
		call ioa_$ioa_switch (output, "     Imported by ^a ( --> see ""^a"")",
		     ext_item_to -> module_name, ext_item_syn_of -> ext_item_name);
	     end;
	     ext_item_box_ptr = ext_item_next;
	end;
%page;
/* edit internal cross references */

	if int_refs then do;
	     module_box_ptr = first_module;
	     do while (module_box_ptr ^= null);
		call ioa_$ioa_switch (output, "^|
		VARIABLES AND PROCEDURES INTERNAL TO ^a

", module_name);
		call get_temp_segment_ (me, int_symbol_area_ptr, code);
		if code ^= 0 then call standard_error ("Unable to get temp seg.");
		my_area_info.areap = int_symbol_area_ptr;
		call define_area_ (addr (my_area_info), code);
		if code ^= 0 then call standard_error ("Unable to get storage area.");
		symbol_base = module_info -> symbp;
		pl1_symb = addrel (symbol_base, symbol_base -> area_pointer);
		root_block = addrel (symbol_base, pl1_symb -> root);
		curr_block = addrel (root_block, root_block -> symbol_block.son);
		chain_ptr = null;
		call chain_symbols (curr_block);
		do it1 = 1 to 26;
		     int_symbol_box_ptr = chain_ptr (it1);
		     do while (int_symbol_box_ptr ^= null);
			call ioa_$ioa_switch_nnl (output, "
^a
     Declared in ^a^/^-", int_symbol_name, int_symbol_proc_name -> acc_string.string);
			call pascal_symbol_$display_declaration (int_symbol_ptr, output, 10, 3, "01001"b, code);
			if code ^= 0 then call standard_error ("Error while getting symbol info.");
			tittle = "0"b;
			auto_refs_only = "1"b;
			call edit_refs ("0"b, int_symbol_ptr, module_box_ptr, tittle, "0"b,
			     int_item_is_variable, auto_refs_only, int_item_location);
			referenced = tittle;
			tittle = "0"b;
			call edit_refs ("1"b, int_symbol_ptr, module_box_ptr, tittle, "0"b,
			     int_item_is_variable, auto_refs_only, int_item_location);
			set = tittle;
			if (int_symbol_class = pascal_local_class_code)
			     | (int_symbol_class = pascal_internal_global_class_code) then do;
			     if referenced & (^set) then do;
				error_count = error_count + 1;
				error_string = error_string || "

   Variable " || rtrim (int_symbol_name) || " declared in " || int_symbol_proc_name -> acc_string.string || " is referenced and never set.";
			     end;
			     else if ^(referenced | set) then do;
				warning_count = warning_count + 1;
				warning_string = warning_string || "

   Variable " || rtrim (int_symbol_name) || " declared in " || int_symbol_proc_name -> acc_string.string || " is never used.";
			     end;
			end;
			else if (int_symbol_class = pascal_parameter_class_code) then do;
			     if ^(referenced | set) then do;
				warning_count = warning_count + 1;
				warning_string = warning_string || "

   Parameter " || rtrim (int_symbol_name) || " of " || int_symbol_proc_name -> acc_string.string || " is never used.";
			     end;
			end;
			else if int_symbol_class = 12 /* text */ then do;
			     if (^referenced) | auto_refs_only then do;
				warning_count = warning_count + 1;
				warning_string = warning_string || "

   Procedure " || rtrim (int_symbol_name) || " declared in " || int_symbol_proc_name -> acc_string.string || " is never used.";
			     end;
			end;
			int_symbol_box_ptr = int_symbol_next;
		     end;
		end;
		module_box_ptr = module_next;
		call release_temp_segment_ (me, int_symbol_area_ptr, code);
		if code ^= 0 then call standard_error ("");
	     end;
	end;
%page;
/* edit include cross references */
	if first_include = null then
	     call ioa_$ioa_switch (output, "^|

NO INCLUDE FILE USED");
	else do;
	     call ioa_$ioa_switch (output, "^|
		INCLUDE FILES REFERENCED :
");
	     include_box_ptr = first_include;
	     do while (include_box_ptr ^= null);
		call date_time_ (include_dtm, time_string);
		call ioa_$ioa_switch (output, "
^a ^a", time_string, rtrim (include_path));
		long_string = "     Referenced by :";
		include_ref_box_ptr = include_references;
		do while (include_ref_box_ptr ^= null);
		     long_string = long_string || " " || rtrim (include_ref_by -> module_entry);
		     include_ref_box_ptr = include_ref_next;
		end;
		include_box_ptr = include_next;
		call edit_string ("          ", 120);
	     end;
	end;
%page;
	tittle = "0"b;
	ext_item_box_ptr = first_ext_item;
	do while (ext_item_box_ptr ^= null);
	     if ext_item_syn_of = null then
		if ext_item_from = null then do;
		     if ^tittle then do;
			call ioa_$ioa_switch (output, "^|

		FOLLOWING ITEMS ARE EXTERNAL TO THE SET OF PROGRAMS

");
			tittle = "1"b;
		     end;
		     call ioa_$ioa_switch (output, "^-^a^-(^a$^a)",
			ext_item_name, ext_item_segn, ext_item_name);
		end;
	     ext_item_box_ptr = ext_item_next;
	end;
%page;
	tittle = "0"b;
	ext_item_box_ptr = first_ext_item;
	do while (ext_item_box_ptr ^= null);
	     if ext_item_syn_of = null then
		if ^ext_item_is_main
		     & (ext_item_from ^= null) & (ext_item_to = null) then do;
		     if ^tittle then do;
			call ioa_$ioa_switch (output, "^|

		FOLLOWING ITEMS ARE EXPORTED BUT NOT IMPORTED IN THE SET OF PROGRAMS

");
			tittle = "1"b;
		     end;
		     call ioa_$ioa_switch (output, "^-^a^-(in ^a)",
			ext_item_name, ext_item_from -> module_name);
		end;
	     ext_item_box_ptr = ext_item_next;
	end;
%page;
/* Edit errors if any */

	if (error_count ^= 0) | (warning_count ^= 0) then do;
	     if output_file then
		call ioa_$ioa_switch (output, "^|");
	     else do;
		call iox_$close (output, code);
		call iox_$detach_iocb (output, code);
		call iox_$attach_name (output_switch, output, "syn_ error_output", null, code);
	     end;
	     if warning_count ^= 0 then
		call ioa_$ioa_switch (output, "
^d WARNING^[S^] :
^a", warning_count, warning_count ^= 1, warning_string);
	     if error_count ^= 0 then
		call ioa_$ioa_switch (output, "
^d ERROR^[S^] :
^a", error_count, error_count ^= 1, error_string);
	end;
	else if output_file then
	     call ioa_$ioa_switch (output, "^|

NO ERROR");
%page;
STOP_ON_ERROR:

	call terminate_px;

	return;
%page;
match_types_of: proc (ref_name, ref_type, ref_type_ptr, ref_size,
	new_name, new_type, new_type_ptr, new_size) returns (bit (1));

dcl (ref_name, new_name) char (*);
dcl (ref_type, new_type) fixed bin (35);
dcl (ref_type_ptr, new_type_ptr) ptr;
dcl (ref_size, new_size) fixed bin (35);

dcl r_size fixed bin (35);
dcl n_size fixed bin (35);

dcl match bit (1);
dcl 1 compared_types based,
     2 new_tp ptr,
     2 ref_tp ptr,
     2 next ptr,
     2 match bit (1);
dcl (work, p1, p2) ptr;
dcl done bit (1);
dcl 1 new_type_info like runtime_type_info;
dcl 1 ref_type_info like runtime_type_info;
dcl 1 elem_type_info like runtime_type_info;
dcl 1 ref_array_info like runtime_array_info;
dcl 1 new_array_info like runtime_array_info;
dcl 1 new_subrange_info like runtime_subrange_info;
dcl 1 ref_subrange_info like runtime_subrange_info;
dcl (i_ref, i_new, i_dim, i_par) fixed bin (35);
dcl (ref_min, ref_max, new_min, new_max) fixed bin (35);

	if (ref_type = new_type)
	     & (ref_type_ptr = new_type_ptr)
	     & (ref_size = new_size) then return ("1"b);

	if ((ref_type = pascal_internal_procedure_dtype)
	     | (ref_type = pascal_exportable_procedure_dtype)
	     | (ref_type = pascal_entry_formal_parameter_dtype)
	     | (ref_type = pascal_imported_procedure_dtype)
	     | (ref_type = pascal_parameter_procedure_dtype))
	     & ((new_type = pascal_internal_procedure_dtype)
	     | (new_type = pascal_exportable_procedure_dtype)
	     | (new_type = pascal_entry_formal_parameter_dtype)
	     | (new_type = pascal_imported_procedure_dtype)
	     | (new_type = pascal_parameter_procedure_dtype))
	then do;
	     p1 = runtime_symbol_info_$son (ref_type_ptr);
	     p2 = runtime_symbol_info_$son (new_type_ptr);
	     do while ((p1 ^= null) & (p2 ^= null));
		p1 = runtime_symbol_info_$brother (p1);
		p2 = runtime_symbol_info_$brother (p2);
	     end;
	     if p1 ^= p2 then do;
		error_count = error_count + 1;
		error_string = error_string || "

   " || ref_name || " and
	" || new_name || " do not have the same number of parameters.";
		return ("0"b);
	     end;
	     ref_type_info.version = RUNTIME_TYPE_INFO_VERSION_1;
	     new_type_info.version = RUNTIME_TYPE_INFO_VERSION_1;
	     call runtime_symbol_info_$type (ref_type_ptr, addr (ref_type_info), code);
	     if code ^= 0 then call standard_error ("");
	     call runtime_symbol_info_$type (new_type_ptr, addr (new_type_info), code);
	     if code ^= 0 then call standard_error ("");
	     if ref_type_info.base_type ^= new_type_info.base_type then do;
		if ref_type_info.base_type = 0 then do;
		     error_count = error_count + 1;
		     error_string = error_string || "

   " || ref_name || " is a procedure and " || new_name || " is a function.";
		end;
		else do;
		     error_count = error_count + 1;
		     error_string = error_string || "

   " || new_name || " is a procedure and " || ref_name || " is a function.";
		end;
	     end;
	     match = "1"b;
	     if ^match_types_of
		("value returned by " || ref_name, (ref_type_info.base_type),
		ref_type_info.base_type_addr, ref_type_info.size,
		"value returned by " || new_name, (new_type_info.base_type),
		new_type_info.base_type_addr, new_type_info.size) then match = "0"b;
	     p1 = runtime_symbol_info_$son (ref_type_ptr);
	     p2 = runtime_symbol_info_$son (new_type_ptr);
	     i_par = 1;
	     do while (p1 ^= null);
		call runtime_symbol_info_$type (p1, addr (ref_type_info), code);
		if code ^= 0 then call standard_error ("");
		call runtime_symbol_info_$type (p2, addr (new_type_info), code);
		if code ^= 0 then call standard_error ("");
		if ref_type_info.type ^= new_type_info.type then do;
parm_kind: proc (i) returns (char (64) var);

dcl i fixed bin (35);

	if i = pascal_value_formal_parameter_dtype then return ("a variable passed by value");
	else if i = pascal_variable_formal_parameter_dtype then return ("a variable passed by address");
	else return ("a procedure or a function");

     end parm_kind;
		     error_count = error_count + 1;
		     error_string = error_string || "

   " || ord (i_par) || " parameter of " || ref_name || " is " || parm_kind ((ref_type_info.type))
			|| " and
	" || ord (i_par) || " parameter of " || new_name || " is " || parm_kind ((new_type_info.type)) || ".";
		     if (ref_type_info.type = pascal_entry_formal_parameter_dtype)
			| (new_type_info.type = pascal_entry_formal_parameter_dtype)
		     then match = "0"b;
		end;
		if ^match_types_of
		     (ord (i_par) || " parameter of " || ref_name, (ref_type_info.base_type),
		     ref_type_info.base_type_addr, ref_type_info.size,
		     ord (i_par) || " parameter of " || new_name, (new_type_info.base_type),
		     new_type_info.base_type_addr, new_type_info.size) then match = "0"b;
		i_par = i_par + 1;
		p1 = runtime_symbol_info_$brother (p1);
		p2 = runtime_symbol_info_$brother (p2);
	     end;
	     return (match);
	end;

	r_size = get_size_in_bits (ref_type, ref_type_ptr, ref_size, code);
	if code ^= 0 then call standard_error ("");
	n_size = get_size_in_bits (new_type, new_type_ptr, new_size, code);
	if code ^= 0 then call standard_error ("");
	if r_size ^= n_size then do;
	     error_count = error_count + 1;
	     error_string = error_string || "

   " || ref_name || " and
	" || new_name || " have different sizes.";
	     return ("0"b);
	end;

	if (ref_type_ptr = null) | (new_type_ptr = null) then
	     if ref_type_ptr ^= new_type_ptr then do;
		error_count = error_count + 1;
		error_string = error_string || "

   " || ref_name || " and
	" || new_name || " have different types (but same size).";
		return ("0"b);
	     end;

	work = first_compared_types;
	do while (work ^= null);
	     if (work -> new_tp = new_type_ptr & work -> ref_tp = ref_type_ptr)
		| (work -> new_tp = ref_type_ptr & work -> ref_tp = new_type_ptr) then
		return (work -> compared_types.match);
	     work = work -> compared_types.next;
	end;
	allocate compared_types in (px_area) set (work);
	work -> compared_types.next = first_compared_types;
	work -> compared_types.new_tp = new_type_ptr;
	work -> compared_types.ref_tp = ref_type_ptr;
	match,
	     work -> compared_types.match = "1"b;
	first_compared_types = work;


	if ref_type = pascal_enumerated_type_instance_dtype then do;
	     p1 = runtime_symbol_info_$son (ref_type_ptr);
	     p2 = runtime_symbol_info_$son (new_type_ptr);
	     do while ((p1 ^= null) & (p2 ^= null));
						/* if runtime_symbol_info_$name (p1) -> acc_string.string
						   ^= runtime_symbol_info_$name (p2) -> acc_string.string then
						   match = "0"b; */
		p1 = runtime_symbol_info_$successor (p1);
		p2 = runtime_symbol_info_$successor (p2);
	     end;
	     if p1 ^= p2 then do;
		error_count = error_count + 1;
		error_string = error_string || "

   types of " || ref_name || " and
	" || new_name || " do not have the same number of elements.";
		match = "0"b;
	     end;
	end;
	else if ref_type = pascal_user_defined_type_instance_dtype then do;
	     ref_type_info.version = RUNTIME_TYPE_INFO_VERSION_1;
	     new_type_info.version = RUNTIME_TYPE_INFO_VERSION_1;
	     call runtime_symbol_info_$type (ref_type_ptr, addr (ref_type_info), code);
	     if code ^= 0 then call standard_error ("");
	     call runtime_symbol_info_$type (new_type_ptr, addr (new_type_info), code);
	     if code ^= 0 then call standard_error ("");
	     if (new_type_info.type ^= ref_type_info.type)
		| (new_type_info.base_type ^= ref_type_info.base_type)
		| (new_type_info.packed ^= ref_type_info.packed)
		| (new_type_info.has_dimensions ^= ref_type_info.has_dimensions)
		| (new_type_info.has_subrange_limits ^= ref_type_info.has_subrange_limits)
	     then match = "0"b;
	     else do;
		if ref_type_info.has_dimensions then do;
		     new_array_info.version = RUNTIME_ARRAY_INFO_VERSION_1;
		     ref_array_info.version = RUNTIME_ARRAY_INFO_VERSION_1;
		     elem_type_info.version = RUNTIME_TYPE_INFO_VERSION_1;
		     call runtime_symbol_info_$array (new_type_ptr, addr (new_array_info), code);
		     if code ^= 0 then call standard_error ("");
		     call runtime_symbol_info_$array (ref_type_ptr, addr (ref_array_info), code);
		     if code ^= 0 then call standard_error ("");
		     done = "0"b; i_new, i_ref, i_dim = 1;
		     do while (^done);
			if i_new > new_array_info.ndims then
			     if new_type_info.base_type_addr = null then done = "1"b;
			     else do;
				call runtime_symbol_info_$type
				     (new_type_info.base_type_addr, addr (elem_type_info), code);
				if code ^= 0 then call standard_error ("");
				if ^elem_type_info.has_dimensions then done = "1"b;
				else do;
				     call runtime_symbol_info_$array
					(new_type_info.base_type_addr, addr (new_array_info), code);
				     if code ^= 0 then call standard_error ("");
				     new_type_info = elem_type_info;
				     i_new = 1;
				end;
			     end;
			if ^done then
			     if i_ref > ref_array_info.ndims then
				if ref_type_info.base_type_addr = null then done = "1"b;
				else do;
				     call runtime_symbol_info_$type
					(ref_type_info.base_type_addr, addr (elem_type_info), code);
				     if code ^= 0 then call standard_error ("");
				     if ^elem_type_info.has_dimensions then done = "1"b;
				     else do;
					call runtime_symbol_info_$array
					     (ref_type_info.base_type_addr, addr (ref_array_info), code);
					if code ^= 0 then call standard_error ("");
					ref_type_info = elem_type_info;
					i_ref = 1;
				     end;
				end;
			if ^done then
			     if ^match_types_of
				(ord (i_dim) || " dimension of " || ref_name, ref_array_info (i_ref).subscript_type,
				ref_array_info (i_ref).subscript_type_addr, 0,
				ord (i_dim) || " dimension of " || new_name, new_array_info (i_new).subscript_type,
				new_array_info (i_new).subscript_type_addr, 0)
			     then do; match = "0"b; done = "1"b; end;
			i_ref = i_ref + 1; i_new = i_new + 1; i_dim = i_dim + 1;
		     end;

		     if ^done then
			if (i_new ^= new_array_info.ndims + 1)
			     | (i_ref ^= ref_array_info.ndims + 1) then match = "0"b;
			else
			     match = match_types_of
				("array elements of " || ref_name, (ref_type_info.base_type),
				ref_type_info.base_type_addr, ref_type_info.size,
				"array elements of " || new_name, (new_type_info.base_type),
				new_type_info.base_type_addr, new_type_info.size);
		end;
		else if ref_type_info.has_subrange_limits then do;
		     if ^match_types_of
			("base type of " || ref_name, (ref_type_info.base_type), ref_type_info.base_type_addr, 0,
			"base type of " || new_name, (new_type_info.base_type), new_type_info.base_type_addr, 0)
		     then match = "0"b;
		     else do;
			ref_subrange_info.version = RUNTIME_SUBRANGE_INFO_VERSION_1;
			new_subrange_info.version = RUNTIME_SUBRANGE_INFO_VERSION_1;
			call runtime_symbol_info_$subrange (ref_type_ptr, addr (ref_subrange_info), code);
			if code ^= 0 then call standard_error ("");
			call runtime_symbol_info_$subrange (new_type_ptr, addr (new_subrange_info), code);
			if code ^= 0 then call standard_error ("");
			ref_min = decode (ref_subrange_info.subrange_lower_bound,
			     ref_subrange_info.lower_bound_is_encoded, ref_type_ptr);
			ref_max = decode (ref_subrange_info.subrange_upper_bound,
			     ref_subrange_info.upper_bound_is_encoded, ref_type_ptr);
			new_min = decode (new_subrange_info.subrange_lower_bound,
			     new_subrange_info.lower_bound_is_encoded, new_type_ptr);
			new_max = decode (new_subrange_info.subrange_upper_bound,
			     new_subrange_info.upper_bound_is_encoded, new_type_ptr);
			match = ((ref_min = new_min) & (ref_max = new_max));
		     end;
		end;
		else if ref_type_info.type = pascal_record_file_type_dtype then
		     match = match_types_of
			("records of file " || ref_name, (ref_type_info.base_type),
			ref_type_info.base_type_addr, ref_type_info.size,
			"records of file " || new_name, (new_type_info.base_type),
			new_type_info.base_type_addr, new_type_info.size);
		else if ref_type_info.type = pascal_set_dtype then
		     match = match_types_of
			("elements of set " || ref_name, (ref_type_info.base_type),
			ref_type_info.base_type_addr, ref_type_info.size,
			"elements of set " || new_name, (new_type_info.base_type),
			new_type_info.base_type_addr, new_type_info.size);
		else if ref_type_info.type = pascal_typed_pointer_type_dtype then
		     match = match_types_of
			("items pointed by " || ref_name, (ref_type_info.base_type),
			ref_type_info.base_type_addr, ref_type_info.size,
			"items pointed by " || new_name, (new_type_info.base_type),
			new_type_info.base_type_addr, new_type_info.size);
		else if ref_type_info.type = pascal_record_type_dtype then
		     match = match_field_list (runtime_symbol_info_$son (ref_type_ptr),
			runtime_symbol_info_$son (new_type_ptr));
	     end;
	end;
	work -> compared_types.match = match;
	if ^match then do;
	     error_count = error_count + 1;
	     error_string = error_string || "

   " || ref_name || " and
	" || new_name || " have different types (but same size).";
	end;
	return (match);

decode: proc (value, encoded, symbp) returns (fixed bin (35));

dcl value fixed bin (35);
dcl encoded bit (1);
dcl symbp ptr;
dcl stu_$block_dcld_in entry (ptr) returns (ptr);

dcl ptr builtin;
dcl stu_$decode_runtime_value_extended
         entry (fixed bin (35), ptr, ptr, ptr, ptr, ptr, ptr, fixed bin (35)) returns (fixed bin (35));
dcl result fixed bin (35);

	if ^encoded then return (value);
	else do;
	     result = stu_$decode_runtime_value_extended (value, stu_$block_dcld_in (symbp), null, null, null,
		null, symbp, code);
	     if code ^= 0 then call standard_error ("");
	     return (result);
	end;
     end decode;

ord: proc (i) returns (char (32) var);

dcl i fixed bin (35);
dcl (ltrim, char) builtin;

	if i = 1 then return ("first");
	if i = 2 then return ("second");
	if i = 3 then return ("third");
	return (ltrim (char (i)) || "th");

     end ord;

match_field_list: proc (Ref_p, New_p) returns (bit (1));

dcl (Ref_p, New_p) ptr;

dcl (ref_p, new_p) ptr;
dcl (p1, p2) ptr;
dcl 1 ref_type_info like runtime_type_info;
dcl 1 new_type_info like runtime_type_info;
dcl 1 subrange_info like runtime_subrange_info;
dcl (match, continue) bit (1);
dcl (s1, s2) fixed bin (35);
dcl fieldname_1 char (40) var;
dcl fieldname_2 char (40) var;
dcl (n1, n2, set_len, i_field, i1, i2) fixed bin (35);
dcl 1 tp_type_info like runtime_type_info;
dcl w ptr;
dcl pascal_set bit (set_len) unal based;

	ref_p = Ref_p;
	new_p = New_p;
	if ref_p = new_p then return ("1"b);
	continue, match = "1"b; i_field = 1;
	ref_type_info.version = RUNTIME_TYPE_INFO_VERSION_1;
	new_type_info.version = RUNTIME_TYPE_INFO_VERSION_1;
	do while ((ref_p ^= null) & (new_p ^= null) & continue);
	     call runtime_symbol_info_$type (ref_p, addr (ref_type_info), code);
	     if code ^= 0 then call standard_error ("");
	     call runtime_symbol_info_$type (new_p, addr (new_type_info), code);
	     if code ^= 0 then call standard_error ("");
	     p1 = runtime_symbol_info_$name (ref_p);
	     p2 = runtime_symbol_info_$name (new_p);
	     if p1 = null then fieldname_1 = "selector field";
	     else fieldname_1 = "field " || p1 -> acc_string.string;
	     if p2 = null then fieldname_2 = "selector field";
	     else fieldname_2 = "field " || p2 -> acc_string.string;
	     if ^match_types_of
		(fieldname_1 || " of " || ref_name, (ref_type_info.type),
		ref_type_info.type_addr, ref_type_info.size,
		fieldname_2 || " of " || new_name, (new_type_info.type),
		new_type_info.type_addr, new_type_info.size) then do;
		match = "0"b;
		s1 = get_size_in_bits ((ref_type_info.type), ref_type_info.type_addr, ref_type_info.size, code);
		if code ^= 0 then call standard_error ("");
		s2 = get_size_in_bits ((new_type_info.type), new_type_info.type_addr, new_type_info.size, code);
		if code ^= 0 then call standard_error ("");
		if s1 = s2 then
		     continue = "1"b;
		else continue = "0"b;
	     end;
	     p1 = ref_p; p2 = new_p;
	     i_field = i_field + 1;
	     ref_p = runtime_symbol_info_$brother (ref_p);
	     new_p = runtime_symbol_info_$brother (new_p);
	end;
	if ^continue then return ("0"b);
	if (ref_p ^= new_p) then do;
	     error_count = error_count + 1;
	     error_string = error_string || "

   " || ref_name || " and
	" || new_name || " dont have the same number of fields.";
	     return ("0"b);
	end;
	n_variants, n1 = runtime_symbol_info_$n_variants (p1);
	n2 = runtime_symbol_info_$n_variants (p2);
	if (n1 = 0) | (n2 = 0) then
	     if n1 ^= n2 then return ("0"b);
	     else return (match);
	else
	     begin;
dcl 1 ref_variant_info like runtime_variant_info;
	     ref_variant_info.version = RUNTIME_VARIANT_INFO_VERSION_1;
	     call runtime_symbol_info_$variant (p1, addr (ref_variant_info), code);
	     if code ^= 0 then call standard_error ("");
	     n_variants = n2;
	     begin;
dcl 1 new_variant_info like runtime_variant_info;
		new_variant_info.version = RUNTIME_VARIANT_INFO_VERSION_1;
		call runtime_symbol_info_$variant (p2, addr (new_variant_info), code);
		if code ^= 0 then call standard_error ("");
		set_len = 0;
		if ref_type_info.type = pascal_boolean_dtype then set_len = 2;
		else if ref_type_info.type = pascal_enumerated_type_instance_dtype then do;
		     w = runtime_symbol_info_$son (ref_type_info.type_addr);
		     set_len = 0;
		     do while (w ^= null);
			set_len = set_len + 1;
			w = runtime_symbol_info_$successor (w);
		     end;
		end;
		else if ref_type_info.type = pascal_user_defined_type_instance_dtype then do; /* user defined subrange */
		     tp_type_info.version = RUNTIME_TYPE_INFO_VERSION_1;
		     call runtime_symbol_info_$type (ref_type_info.type_addr, addr (tp_type_info), code);
		     if code ^= 0 then call standard_error ("");
		     if tp_type_info.has_subrange_limits then do;
			subrange_info.version = RUNTIME_SUBRANGE_INFO_VERSION_1;
			call runtime_symbol_info_$subrange (ref_type_info.type_addr, addr (subrange_info), code);
			if code ^= 0 then call standard_error ("");
			set_len = 1
			     - decode (subrange_info.subrange_lower_bound,
			     subrange_info.lower_bound_is_encoded, ref_type_info.type_addr)
			     + decode (subrange_info.subrange_upper_bound,
			     subrange_info.upper_bound_is_encoded, ref_type_info.type_addr);
		     end;
		end;
		if set_len = 0 then match = "0"b;	/* error somewhere */
		else do i1 = 1 to n1;
		     do i2 = 1 to n2;
			if (ref_variant_info (i1).set_addr -> pascal_set &
			     new_variant_info (i2).set_addr -> pascal_set) ^= "0"b then do;
			     if ^match_field_list
				(ref_variant_info (i1).brother_addr, new_variant_info (i2).brother_addr)
			     then match = "0"b;
			end;
		     end;
		end;
	     end;
	end;
	return (match);
     end match_field_list;
     end match_types_of;
%page;
err_in_arg: proc (str);

dcl str char (*);

	call com_err_ (code, me, str);
	err_in_args = "1"b;

     end err_in_arg;
%page;
standard_error: proc (str);

dcl str char (*);

	call com_err_ (code, me, str);
	call com_err_ (0, me, "Fatal error occurred.");
	go to STOP_ON_ERROR;

     end standard_error;
%page;
initiate_px: proc;


	px_area_ptr = null;
	call get_temp_segment_ (me, error_ptr, code);
	call get_temp_segment_ (me, warning_ptr, code);
	if code ^= 0 then call standard_error ("Unable to get temp seg.");
	error_string = "";
	my_area_info.version = 1;
	my_area_info.extend = "1"b;
	my_area_info.zero_on_alloc = "1"b;
	my_area_info.zero_on_free = "0"b;
	my_area_info.dont_free = "0"b;
	my_area_info.no_freeing = "0"b;
	my_area_info.system = "0"b;
	my_area_info.pad = "0"b;
	my_area_info.owner = me;
	my_area_info.n_components = 0;
	my_area_info.size = sys_info$max_seg_size;
	my_area_info.version_of_area = 1;
	my_area_info.areap = px_area_ptr;
	my_area_info.allocated_blocks,
	     my_area_info.free_blocks,
	     my_area_info.free_words,
	     my_area_info.allocated_words = 0;
	call define_area_ (addr (my_area_info), code);
	if code ^= 0 then call standard_error ("Unable to get storage area.");

	px_area_ptr = my_area_info.areap;

     end initiate_px;
%page;
terminate_px: proc;


	call release_area_ (px_area_ptr);
	call release_temp_segment_ (me, error_ptr, code);
	call release_temp_segment_ (me, warning_ptr, code);
	if output ^= null then do;
	     call iox_$close (output, code);
	     call iox_$destroy_iocb (output, code);
	end;

     end terminate_px;
%page;
get_link_segn: proc (module_info, loc) returns (char (32));

dcl module_info ptr;
dcl loc fixed bin;

	link_ptr = addrel (module_info -> linkp, loc);
	expr_ptr = addrel (module_info -> defp, link_ptr -> link.exp_ptr);
	type_pair_ptr = addrel (module_info -> defp, expr_ptr -> type_relp);
	if type_pair_ptr -> type_pair.type = 5 then return ("*system");
	else return (addrel (module_info -> defp, type_pair_ptr -> type_pair.segname_relp) -> acc_string.string);

     end;
%page;
edit_string: proc (margin, max);

dcl margin char (*);
dcl max fixed bin;

dcl (i, l) fixed bin;

	do while (length (long_string) > max);
	     i = index (reverse (substr (long_string, 1, max)), " ");
	     l = max - i;
	     call ioa_$ioa_switch (output, substr (long_string, 1, l));
	     long_string = margin || substr (long_string, l + 2);
	end;
	call ioa_$ioa_switch (output, long_string);

     end edit_string;
%page;
edit_refs: proc (modif, symb_ptr, mod_box_ptr, tittle, ext, item_is_a_variable, auto_references_only, item_location);

dcl modif bit (1);
dcl symb_ptr ptr;
dcl mod_box_ptr ptr;
dcl tittle bit (1);
dcl ext bit (1);
dcl item_is_a_variable bit (1);
dcl auto_references_only bit (1);
dcl item_location fixed bin (35);

dcl (curr_block, new_block) ptr init (null);
dcl (map_base, map_ptr) ptr;
dcl ref_ptr ptr;
dcl it fixed bin;
dcl any bit (1) init ("0"b);
dcl len fixed bin (21);
dcl ioa_$rsnnl entry options (variable);
dcl symb_base ptr;
dcl root_block ptr;
dcl item_block ptr;
dcl auto_ref bit (1);

edit_tittle: proc;
	if ^tittle then do;
	     if modif then call ioa_$ioa_switch (output, "     Set in :");
	     else call ioa_$ioa_switch (output, "     Referenced in :");
	     tittle = "1"b;
	end;
     end;

	symb_base = mod_box_ptr -> module_info -> symbp;
	root_block = addrel (symb_base, addrel (symb_base, symb_base -> area_pointer) -> pl1_symbol_block.root);
	ref_ptr = addrel (symb_ptr, -1);
	ref_n = ref_ptr -> ref_info_header.nbr;
	ref_info_ptr = addrel (symb_ptr, ref_ptr -> ref_info_header.place);
	map_base = addrel (symb_base, symb_base -> std_symbol_header.area_pointer);
	map_base = addrel (symb_base, map_base -> pl1_symbol_block.map.first);
	if (^item_is_a_variable) & (item_location ^= -1) then
	     item_block = stu_$find_containing_block (symb_base, (item_location));
	else item_block = null;
	if modif then
	     if set_in_value_section then do;
		call edit_tittle;
		if ext then
		     call ioa_$ioa_switch (output, "	^a", mod_box_ptr -> module_name);
		long_string = (15)" " || "Set by $value.";
		any = "1"b;
	     end;
	do it = 1 to ref_n;
	     if (modif = ref_info (it).modified) then do;
		call edit_tittle;
		if ^any then
		     if ext then
			call ioa_$ioa_switch (output, "	^a", mod_box_ptr -> module_name);
		map_ptr = addrel (map_base, ref_info (it).map_index);
		new_block = stu_$find_containing_block (symb_base, fixed (map_ptr -> statement_map.location));
		do while (new_block -> symbol_block.type = PASCAL_WITH_BLOCK);
		     new_block = addrel (new_block, new_block -> symbol_block.father);
		end;
		if new_block ^= curr_block then do;
		     auto_ref = "0"b;
		     curr_block = new_block;
		     if any then
			call edit_string ((20)" ", 120);
		     else any = "1"b;
		     long_string = "";
		     do while (root_block ^= new_block);
			if new_block -> symbol_block.name ^= 0 then do;
			     if long_string ^= "" then long_string = ">" || long_string;
			     long_string = addrel (new_block, new_block -> symbol_block.name) -> acc_string.string || long_string;
			end;
			if new_block = item_block then auto_ref = "1"b;
			new_block = addrel (new_block, new_block -> symbol_block.father);
		     end;
		     long_string = (15)" " || long_string || "	";
		     if ^auto_ref then auto_references_only = "0"b;
		end;
		call ioa_$rsnnl ("^a ^[^d-^;^s^]^d", long_string, len, (long_string), fixed (map_ptr -> statement_map.file) ^= 0,
		     fixed (map_ptr -> statement_map.file), fixed (map_ptr -> statement_map.line));
	     end;
	end;
	if any then call edit_string ((20)" ", 120);
     end edit_refs;
%page;
chain_symbols: proc (block_ptr);

dcl block_ptr ptr;

dcl current ptr;
dcl symb_ptr ptr;
dcl ind fixed bin;
dcl alphabet char (26) init ("abcdefghijklmnopqrstuvwxyz") int static options (constant);

	if block_ptr -> symbol_block.type ^= PASCAL_WITH_BLOCK then do;
	     if block_ptr -> symbol_block.start ^= 0 then do;
		long_string = addrel (block_ptr, block_ptr -> symbol_block.name) -> acc_string.string;
		current = addrel (block_ptr, block_ptr -> symbol_block.father);
		do while (current ^= root_block);
		     if current -> symbol_block.name ^= 0 then do;
			long_string = addrel (current, current -> symbol_block.name) -> acc_string.string || ">" || long_string;
		     end;
		     current = addrel (current, current -> symbol_block.father);
		end;
		acc_string_length = length (long_string);
		allocate acc_string in (int_symbol_area) set (acc_string_ptr);
		acc_string.count = length (long_string);
		acc_string.string = long_string;
		symb_ptr = addrel (block_ptr, block_ptr -> symbol_block.start);
		do while (symb_ptr ^= null);
		     call runtime_symbol_info_$type (symb_ptr, addr (type_info), code);
		     if code ^= 0 then call standard_error ("Error while getting symbol info.");
		     if (type_info.type = pascal_integer_dtype)
			| (type_info.type = pascal_real_dtype)
			| (type_info.type = pascal_internal_procedure_dtype)
			| (type_info.type = pascal_char_dtype)
			| (type_info.type = pascal_boolean_dtype)
			| (type_info.type = pascal_enumerated_type_instance_dtype)
			| (type_info.type = pascal_user_defined_type_instance_dtype)
			| (type_info.type = pascal_text_file_dtype)
			| (type_info.type = pascal_parameter_procedure_dtype) then do;
			call runtime_symbol_info_$address (symb_ptr, addr (address_info), code);
			if code ^= 0 then call standard_error ("Error while getting symbol info.");
			if (address_info.class = pascal_local_class_code)
			     | (address_info.class = pascal_internal_global_class_code)
			     | (address_info.class = pascal_parameter_class_code)
			     | (type_info.type = pascal_internal_procedure_dtype) then do;
			     allocate int_symbol_box in (int_symbol_area) set (int_symbol_box_ptr);
			     int_symbol_class = address_info.class;
			     int_item_location = address_info.location;
			     if (type_info.type = pascal_internal_procedure_dtype) then do;
				call runtime_symbol_info_$type (type_info.type_addr, addr (type_type_info), code);
				if code ^= 0 then call standard_error ("Error while getting symbol info.");
				int_item_is_variable = (type_type_info.base_type ^= 0);
			     end;
			     else int_item_is_variable = "1"b;
			     int_symbol_ptr = symb_ptr;
			     int_symbol_proc_name = acc_string_ptr;
			     int_symbol_name = runtime_symbol_info_$name (symb_ptr) -> acc_string.string;
			     ind = index (alphabet, substr (int_symbol_name, 1, 1));
			     current = chain_ptr (ind); previous = null;
loop_10:
			     if current ^= null then
				if current -> int_symbol_name < int_symbol_name then do;
				     previous = current; current = current -> int_symbol_next;
				     go to loop_10;
				end;
			     if previous ^= null then previous -> int_symbol_next = int_symbol_box_ptr;
			     else chain_ptr (ind) = int_symbol_box_ptr;
			     int_symbol_next = current;
			end;
		     end;
		     symb_ptr = runtime_symbol_info_$brother (symb_ptr);
		end;
	     end;
	end;
	if block_ptr -> symbol_block.son ^= 0 then
	     call chain_symbols (addrel (block_ptr, block_ptr -> symbol_block.son));
	if block_ptr -> symbol_block.brother ^= 0 then
	     call chain_symbols (addrel (block_ptr, block_ptr -> symbol_block.brother));
     end;
%page;
get_size_in_bits: proc (P_type, P_type_ptr, P_size, P_code) returns (fixed bin (35));

/* Input */
dcl P_type fixed bin (35);
dcl P_type_ptr ptr;
dcl P_size fixed bin (35);

/* Output */
dcl P_code fixed bin (35);
dcl Size fixed bin (35);

/* Local */
dcl (current, next) ptr;
dcl 1 type_info like runtime_type_info;
dcl 1 array_info like runtime_array_info;
dcl 1 subrange_info like runtime_subrange_info;

dcl (null, max) builtin;

	P_code = 0; Size = -1;

	if P_size ^= 0 then do;
	     if P_type = pascal_integer_dtype then Size = P_size + 1;
	     else if P_type = pascal_real_dtype then Size = P_size + 9;
	     else Size = P_size;
	end;
	else do;
	     if P_type = pascal_integer_dtype then Size = 36;
	     else if P_type = pascal_real_dtype then Size = 72;
	     else if P_type = pascal_boolean_dtype then Size = 36;
	     else if P_type = pascal_enumerated_type_instance_dtype then Size = 36;
	     else if P_type = pascal_char_dtype then Size = 36;
	     else if P_type = pascal_text_file_dtype then Size = 72;
	     else if P_type = pascal_enumerated_type_element_dtype then Size = 36;
	     else if P_type = pascal_user_defined_type_instance_dtype then
		if P_type_ptr ^= null then do;
		     type_info.version = RUNTIME_TYPE_INFO_VERSION_1;
		     call runtime_symbol_info_$type (P_type_ptr, addr (type_info), P_code);
		     if P_code ^= 0 then go to RETURN_HERE;
		     if type_info.type = pascal_typed_pointer_type_dtype then Size = 72;
		     else if type_info.type = pascal_record_file_type_dtype then Size = 72;
		     else if type_info.type = pascal_set_dtype then
			if type_info.base_type = pascal_char_dtype then Size = 128;
			else if type_info.base_type = pascal_boolean_dtype then Size = 2;
			else do;
			     current = type_info.base_type_addr;
			     call runtime_symbol_info_$type (current, addr (type_info), P_code);
			     if P_code ^= 0 then go to RETURN_HERE;
			     if type_info.has_subrange_limits then do;
				subrange_info.version = RUNTIME_SUBRANGE_INFO_VERSION_1;
				call runtime_symbol_info_$subrange (current, addr (subrange_info), P_code);
				if P_code ^= 0 then go to RETURN_HERE;
				Size = 1 + decode (subrange_info.upper_bound_is_encoded, subrange_info.subrange_upper_bound, current);
			     end;
			     else if type_info.type = pascal_enumerated_type_dtype then do;
				next = runtime_symbol_info_$son (current);
				Size = 0;
				do while (next ^= null);
				     Size = Size + 1;
				     next = runtime_symbol_info_$brother (next);
				end;
			     end;
			end;
		     else if type_info.type = pascal_user_defined_type_dtype then
			if type_info.has_subrange_limits then Size = 36;
			else if type_info.has_dimensions then do;
			     array_info.version = RUNTIME_ARRAY_INFO_VERSION_1;
			     call runtime_symbol_info_$array (P_type_ptr, addr (array_info), P_code);
			     if P_code ^= 0 then go to RETURN_HERE;
			     if array_info.bounds (1).lower_is_encoded /* conformant */ then Size = 0;
			     else do;
				Size = (array_info.bounds (1).upper - array_info.bounds (1).lower + 1)
				     * array_info.bounds (1).multiplier;
				if ^type_info.packed then Size = Size * 36;
			     end;
			end;
		end;
		else if type_info.type = pascal_record_type_dtype then
		     Size = get_field_list_size (runtime_symbol_info_$son (P_type_ptr));
	end;

RETURN_HERE:
	return (Size);

%page;
get_field_list_size: proc (field_ptr) returns (fixed bin (35));

dcl field_ptr ptr;

dcl (next, current) ptr;
dcl 1 type_info like runtime_type_info;
dcl 1 address_info like runtime_address_info;
dcl size fixed bin (35) init (0);
dcl it fixed bin (35);

	if field_ptr ^= null then do;
	     next = runtime_symbol_info_$brother (field_ptr); current = field_ptr;
	     do while (next ^= null);
		current = next;
		next = runtime_symbol_info_$brother (next);
	     end;
	     n_variants = runtime_symbol_info_$n_variants (current);
	     if n_variants ^= 0 then
		begin;
dcl 1 variant_info like runtime_variant_info;
		variant_info.version = RUNTIME_VARIANT_INFO_VERSION_1;
		call runtime_symbol_info_$variant (current, addr (variant_info), P_code);
		if P_code ^= 0 then go to RETURN_HERE;
		do it = 1 to n_variants;
		     size = max (size, get_field_list_size (variant_info (it).brother_addr));
		end;
	     end;
	     else do;
		type_info.version = RUNTIME_TYPE_INFO_VERSION_1;
		address_info.version = RUNTIME_ADDRESS_INFO_VERSION_1;
		call runtime_symbol_info_$type (field_ptr, addr (type_info), P_code);
		if P_code ^= 0 then go to RETURN_HERE;
		call runtime_symbol_info_$address (field_ptr, addr (address_info), P_code);
		if P_code ^= 0 then go to RETURN_HERE;
		size = decode_units (address_info.offset, address_info.units) +
		     get_size_in_bits ((type_info.type), type_info.type_addr, type_info.size, P_code);
	     end;
	end;

	return (size);

decode_units: proc (value, units) returns (fixed bin (35));

dcl value fixed bin (35);
dcl units fixed bin (2) unsigned unal;

	if units = 0 then return (value * 36);
	if units = 1 then return (value);
	if units = 2 then return (value * 9);
	if units = 3 then return (value * 18);

     end decode_units;

     end get_field_list_size;
%page;
decode: proc (is_encoded, value, symbol_ptr) returns (fixed bin (35));

dcl is_encoded bit (1);
dcl value fixed bin (35);
dcl symbol_ptr ptr;
dcl local_code fixed bin;

dcl stu_$decode_runtime_value_extended entry (fixed bin (35), ptr, ptr, ptr, ptr, ptr, ptr, fixed bin) returns (fixed bin (35));
dcl stu_$block_dcld_in entry (ptr) returns (ptr);

dcl returned_value fixed bin (35);

	if is_encoded then do;
	     returned_value = stu_$decode_runtime_value_extended (value, stu_$block_dcld_in (symbol_ptr),
		null, null, null, null, symbol_ptr, local_code);
	     if local_code ^= 0 then do;
		P_code = local_code;
		go to RETURN_HERE;
	     end;
	end;
	else returned_value = value;

	return (returned_value);

     end decode;

     end get_size_in_bits;
%page;
%include pascal_ref_info;
%include object_info;
%include std_symbol_header;
%include pl1_symbol_block;
%include status_structures;
%include area_info;
%include source_map;
%include decode_definition_str;
%include definition_dcls;
%include runtime_symbol_info_;
%include runtime_symbol_block;
%include runtime_block_type;
%include statement_map;
%include pascal_loc_class_codes;
%include pascal_symbol_;
%include std_descriptor_types;
     end pascal_cross_reference;
