/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_report_writer.pl1 Reformatted code to new Cobol standard.
                                                   END HISTORY COMMENTS */


/* Modified on 10/22/82 by FCH, [5.1-3], test for PIC  clauses, phx13531 */
/* Modified on 12/28/81 by FCH, [5.1-2], illegal syntax in report description sometimes causes abort, phx12123(BUG523) */
/* Modified on 12/23/81 by FCH, [5.1-1], wrong file selected for writing report, phx12125(BUG524) */
/* Modified on 08/17/81 by FCH, [5.0-1], reset clause improperly searched for in reset clause chain, BUG507(phx11578) */
/* Modified on 06/29/81 by FCH, [4.4-1], control final without other footing groups caused abort, BUG479(TR09695) */
/* Modified since Version 4.4 */






/* format: style3 */
cobol_report_writer:
     proc;

/*	This program prepares the description of the reports defined by the Report Section.
	The source code which comprises the report is produced from these descriptions by
	cobol_generate_report.pl1. The following trace codes are used:

		-tracerw(10000):	report table (produced by cobol_report_writer)


*/

declare	cobol_rw		entry (ptr);
declare	cobol_class_table_	entry (ptr);
declare	cobol_c_list	entry (ptr);
declare	cobol_syntax_trace_$trace
			entry (ptr, fixed bin (24));
declare	cobol_syntax_trace_$initialize_phase
			entry (ptr, fixed bin (24));
declare	cobol_generate_report
			entry (ptr, fixed bin, bit (1));
declare	cobol_swf_get	entry (ptr, bit (32), ptr, fixed bin);
declare	cobol_io_$cobol_msf_start
			entry (ptr, ptr);
declare	cobol_io_$cobol_save_pos
			entry (ptr, ptr);
declare	cobol_display_report$display_report_tables
			entry (ptr);
declare	cobol_syntax_trace_$trace_loc
			entry returns (ptr);

declare	(addr, string, substr, fixed, size, index, mod, null)
			builtin;


	report_SIZE = size (report);

	sum_ctr_ctr = 0;
	user_word_size = 40;
	non_term_node_SIZE = size (non_term_node);
	term_node_SIZE = size (term_node);

	reset_clause_SIZE = size (reset_clause);
	sum_SIZE = size (sum);
	reset_chain_entry_SIZE = size (reset_chain_entry);
	chain_entry_SIZE = size (chain_entry);
	ident_SIZE = size (ident);

	list_def_SIZE = size (list_def);
	list_link_SIZE = size (list_link);
	root_SIZE = size (root);
	ST.entry.level (0), rep_num = 0;

	integer_spec_size = 36 * size (integer_spec);
	non_term_node_line_size = 36 * size (non_term_node_line);
	term_node_line_size = 36 * size (term_node_line);

	rt_ptr, tn_ptr, ntn_ptr = null ();
	q_ptr = null ();
	prev_token_ptr = null ();
	current_report_loc = null ();
	list_def_ptr, list_link_ptr = null ();


	rwfp1 = cobol_m1fp;
	rwfp2 = cobol_m2fp;
	call cobol_io_$cobol_msf_start (rwfp1, report_first_token);
	ae_addr = addr (ae);

	NODE_line_ptr = addr (NODE.line);

	alloc_area.aa_loc = cobol$alloc (1024);
	alloc_area.aa_size = 1;
	alloc_area.aa_cap = 1024;

	stk_lev = 1;
	token_count = 0;

	call cobol_rw (pointer_to_internal);
	call cobol_class_table_ (class_tab_ptr);

/* initialize diag item */

	dg_ptr = addr (diag_item);
	diag_item.size = 28;
	diag_item.type = 5;
	diag_item.run = 4;

	diag_item.module = 0;

	success = S;
	fail = F;
	DIAG_NUM = 0;

	trace_ptr = addr (interp);
	tbit = fixed_common.syntax_trace;

	if tbit
	then call cobol_syntax_trace_$initialize_phase (trace_ptr, 5);
	trace_env_ptr = cobol_syntax_trace_$trace_loc ();
	current_line = 1;
	rwfp = rwfp1;
	call scan;

	go to new_inst;


/*					*/
/*	 syntax interpreter			*/
/*					*/

declare	(success, fail)	label;

declare	1 cl_token,
	  2 line		fixed bin,
	  2 column	fixed bin;



dcl	1 diag_item,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 run		fixed bin,
	  2 number	fixed bin,
	  2 module	fixed bin;

declare	1 syntax_table	(0:10000) based (pointer_to_internal),
	  2 b1		fixed bin,
	  2 b2		fixed bin,
	  2 b3		fixed bin,
	  2 b4		fixed bin,
	  2 b5		fixed bin;

declare	1 syntax_line	based (syntax_line_ptr),
	  2 s_bit		char (1),
	  2 o_bit		char (1),
	  2 t_type	fixed bin,
	  2 t_field	fixed bin,
	  2 s_exit	fixed bin,
	  2 a_num		fixed bin;

declare	1 c_t		based (class_tab_ptr),
	  2 filler	char (20),
	  2 ct		(1024) fixed bin (18) unal unsigned;
declare	CT		(0:8191) fixed bin based (class_tab_ptr);
declare	cd		(256) fixed bin (9) unal unsigned based;

declare	(rwfp, rwfp1, rwfp2)
			ptr;


declare	1 header		based (addr_record),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin;


declare	1 interp,
	  2 current_line	fixed bin (24),
	  2 phase		fixed bin (24),
	  2 addr_record	ptr,
	  2 pointer_to_internal
			ptr,
	  2 directory_ptr	ptr,
	  2 source_ptr	ptr;

declare	1 trace		based (trace_env_ptr),
	  2 curr_first	fixed bin,
	  2 curr_last	fixed bin,
	  2 phase,
	    3 first	(5) fixed bin,
	    3 last	(5) fixed bin;

declare	1 intrp_stack	(128),
	  2 ret_loc	fixed bin,
	  2 recov_loc	fixed bin;

declare	(DIAG_NUM, tln, act_num, stk_lev, status, token_count)
			fixed bin;
declare	trace_env_ptr	ptr;

declare	tm1		fixed bin (24) init (1);
declare	tm2		fixed bin (24) init (2);
declare	tm3		fixed bin (24) init (3);
declare	tm4		fixed bin (24) init (4);
declare	tm5		fixed bin (24) init (5);

declare	(tbit, ch_bit)	bit (1),
	st		bit (32);


F:						/*failure */
	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm2);

/* next syntax instruction */
next_inst:
	current_line = current_line + 1;

new_inst:						/* new syntax instruction */
	syntax_line_ptr = addr (syntax_table (current_line));

	go to test (syntax_line.t_type);

test (0):						/* reserved word test */
						/* r= son= a= */
						/* r= sn= m= */
	if reserved_word.type ^= 1
	then go to fail;

	if reserved_word.key ^= syntax_line.t_field
	then go to fail;

S:						/* success */
	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm1);

ucon:
	if syntax_line.o_bit ^= " "
	then do;
		if syntax_line.o_bit > fixed_common.comp_level
		then call diag (syntax_line.a_num);
		go to ret;
	     end;

	go to action (syntax_line.a_num);

test (1):						/* check routine test */
						/* c= son= a= */
						/* c= sn= m= */
	go to check (syntax_line.t_field);

test (2):						/* unconditional branch */
						/* son= a= d= */
						/* sn= m= */
	DIAG_NUM = syntax_line.t_field;
	act_num = syntax_line.a_num;

	if syntax_line.o_bit ^= " "
	then do;
		if syntax_line.o_bit > fixed_common.comp_level
		then do;
			diag_item.module = syntax_line.a_num;
			call diag (DIAG_NUM);
		     end;

		DIAG_NUM = 0;
		act_num = 0;
	     end;

	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm1);
						/* execute action routine */
	go to action (act_num);			/* syntax procedure */
						/* s= son= a= */
						/* s= sn= m= */
test (3):
	stk_lev = stk_lev + 1;
	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm3);

	if stk_lev > 128
	then do;
		diag_item.number = 183;
		diag_item.column = header.column;
		diag_item.line = header.line;

		call cobol_c_list (dg_ptr);

		return;
	     end;

	intrp_stack.ret_loc (stk_lev) = current_line;
	intrp_stack.recov_loc (stk_lev) = 0;
	current_line = syntax_line.t_field;

	go to new_inst;

test (4):						/* class test */
						/* k = son = a = */
						/* k = sn = m = */
	call class_test;

	if res = "0"b
	then go to fail;

	go to success;

test (5):						/* class dispatch */
						/* K = n = */
	call class_test;



	if res = "0"b
	then do;
		if tbit
		then call cobol_syntax_trace_$trace (trace_ptr, tm2);

		current_line = syntax_line.s_exit;

		go to new_inst;

	     end;

	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm1);

	current_line = current_line + cl_off;

	go to new_inst;				/* action routines return here */
ret:
action (0):
	if DIAG_NUM ^= 0
	then call diag (DIAG_NUM);

	if syntax_line.s_bit = "s"
	then call scan;

	current_line = syntax_line.s_exit;

	go to new_inst;

action (1):					/* exit true from syntax procedure */
	current_line = intrp_stack.ret_loc (stk_lev);

	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm4);

	syntax_line_ptr = addr (syntax_table (current_line));
	stk_lev = stk_lev - 1;

	go to ucon;

action (2):					/* exit false from syntax procedure */
	current_line = intrp_stack.ret_loc (stk_lev);

	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm5);

	stk_lev = stk_lev - 1;

	go to next_inst;

recov_loc:
action (3):					/* establish recovery routine */
						/* n = RECOV_LOC a = recov_loc */
	intrp_stack.recov_loc (stk_lev) = syntax_line.s_exit;

	go to next_inst;

recvy:
action (4):
	call recovery;

	go to ret;

class_test:
     proc;

	res = "0"b;



	if reserved_word.type ^= 1
	then return;

	cl_off = c_t.ct (reserved_word.key);

	if cl_off = 0
	then return;

	cl_off = addr (CT (cl_off)) -> cd (syntax_line.t_field);


	if cl_off = 0
	then return;

	res = "1"b;
	cl_token.line = header.line;
	cl_token.column = header.column;
     end;

recovery:
     proc;					/* error recovery routine */


	success = S1;
	fail = F1;
	call diag (45);

	do while ("1"b);

	     do i = stk_lev by -1 to 1;

		res = "0"b;
		rl = intrp_stack.recov_loc (i);

		if rl ^= 0
		then do;
			syntax_line_ptr = addr (syntax_table (rl));

			go to RC (syntax_line.t_type);

RC (0):						/* r = */
			if reserved_word.type = 1
			then if reserved_word.key = syntax_line.t_field
			     then res = "1"b;

			go to RC0;

RC (1):						/* c = */
			go to check (syntax_line.t_field);

RC (4):						/* k = */
RC (5):						/* K = */
			call class_test;

			go to RC0;

S1:
			res = "1"b;
F1:
RC (2):
RC (3):
RC0:
		     end;

		if res
		then do;
			syntax_line_ptr = addr (syntax_table (rl));
			success = S;
			fail = F;
			stk_lev = i;

			return;
		     end;


	     end;

	     call scan;

	end;
     end;


diag:
     proc (diag_num);

declare	diag_num		fixed bin;

	diag_item.number = diag_num;
	diag_item.column = header.column;
	diag_item.line = header.line;

	call cobol_c_list (dg_ptr);

	diag_item.module = 0;
     end diag;

DIAG:
     proc (diag_num, line, column);

declare	(diag_num, line, column)
			fixed bin;

	diag_item.number = diag_num;
	diag_item.line = line;
	diag_item.column = column;

	call cobol_c_list (dg_ptr);

	diag_item.module = 0;

     end;						/* get the next token */
scan:
     proc;

declare	st		bit (32),
	rec_size		fixed bin;

	call cobol_swf_get (rwfp, st, addr_record, rec_size);
	token_count = token_count + 1;
	if substr (st, 17, 16) ^= "0"b
	then addr_record = addr (eof_token);

     end;



declare	1 eof_token,
	  2 (size, line, column, type)
			fixed bin init (9999);


/*
	Report Writer Diagnostic Messages

	1: a(14), a(56), a(63)		2:				3:
	4:				5:				6:
	7: a(66)				8: classify_node			9: classify_node
	10: classify_node			11:				12: classify_node
	13: check_line_clause		14:				15: classify_node
	16: classify_node			17:				18: test_for_fields
									    process_present_node
	19: check_line_clause		20: check_line_clause		21:
	22:				23:				24: check_page
	25:				26: form_subseq_fields		27: form_subseq_fields
	28:				29:				30:
	31:				32: check_page			33: check_page,...
	34: check_page			35: check_page			36:
	37:				38:				39:
	40:				41: process_cf_sum_clause		42: process_cf_sum_clause
	43:				44: a(66)				45:
	46: process_cf_reset_clause		47: process_control_group		48:
	49:				50: process_cf_reset_clause		51:
	52:				53:				54:
	55:				56:				57:
	58:				59:				60:
	61: find_use				62:				63:
	64:				65:				66:
	67:				68:				69:
	70:				71:				72:
	73:				74:				75:
	76: check_field_clause		77: check_field_clause		78:
	79:				80:				81: process_control_group
	82: process_control_group		83:				84:
	85:				86:				87:
	88:				89:				90:
	91:				92:				93:
	94:				95:				96:
	97:				98:				99:
	100:				101:				102:
	103:				104:				105:
	106:
*/

declare	(i, rl)		fixed bin;
declare	(trace_ptr, dg_ptr, syntax_line_ptr, class_tab_ptr)
			ptr;
declare	cl_off		fixed bin,
	class_def_ptr	ptr;
declare	(cssub, line_position)
			fixed bin;



declare	(subj_req, line_clause_found)
			bit (1);
declare	prev_token_ptr	ptr;
declare	(rd_clnum, rg_cl_num, pg_clnum)
			fixed bin;
declare	(lv_line, lv_col)	fixed bin;
declare	(node_ptr, up_entry)
			ptr;
declare	(prev_node_ptr, NODE_line_ptr)
			ptr;
declare	gch		char (32) varying;


declare	def_entry_ptr	ptr;
declare	(int_val, def_entry_size)
			fixed bin;
declare	(par_1, par_2)	fixed bin;
declare	(ptr_1, ptr_2)	ptr;
declare	(group_type, sum_count, id_count)
			fixed bin;
declare	(s_ptr, q_ptr)	ptr;
declare	(sum_first_ptr, sum_last_ptr, sum_reset_ptr)
			ptr;
declare	control_ptr	ptr;
declare	(rg_line, rg_column, pg_line, pg_column)
			fixed bin;
declare	(rd_line, rd_column)
			fixed bin;
declare	cd_lit		char (2);
declare	ae_addr		ptr;
declare	(not_found, found, res)
			bit (1);
declare	(ht_ptr, df_ptr, p, q, DF_ptr, HT_ptr, up_ptr)
			ptr;
declare	(control_count, group_number, line_number, field_number)
			fixed bin;

declare	1 group_bits,
	  2 RH		bit (1),			/* RH group */
	  2 PH		bit (1),			/* PH group */
	  2 CH		bit (1),			/* CH group */
	  2 DE		bit (1),			/* DE group */
	  2 CF		bit (1),			/* CF group */
	  2 PF		bit (1),			/* PF group */
	  2 RF		bit (1),			/* RF group */
	  2 BG		bit (1);			/* body group */

declare	rg_cl		bit (18);
declare	rg_cl_bits	(18) bit (1) unal defined rg_cl;

declare	rd_cl		bit (4);
declare	rd_cl_bits	(4) bit (1) unal defined rd_cl;

declare	pg_cl		bit (5);
declare	pg_cl_bits	(5) bit (1) defined pg_cl;

declare	rt_cl		bit (4);
declare	rt_cl_bits	(4) bit (1) defined rt_cl;

/* ACTION ROUTINES */

action (5):
c0s1:
	cssub = 0;
	subj_req = "1"b;
	go to ret;

action (6):
s0:
	subj_req = "0"b;
	go to ret;

action (7):
cdecrs1:
	cssub = cssub - 1;
	subj_req = "1"b;
	go to ret;

action (8):
cincrs1:
	cssub = cssub + 1;
	subj_req = "1"b;
	go to ret;

action (9):
cincr:
	cssub = cssub - 1;
	go to ret;

action (10):
rep_init:						/* initialize report list */
	report_list.count = 0;
	report_list.first, report_list.last = null ();
	prev_node_ptr, sum_chain_ptr = null ();
	group_number = 0;
	go to ret;

action (11):
rep_add:						/* add report to list */
	report_list.count = report_list.count + 1;	/*[5.1-2]*/
	if fatal_no ^= fixed_common.fatal_no
	then report.page.count = 0;			/* fatals occurred */
	call form_de_table;

	call set_cf_sum_chain;

	if last_root_ptr ^= null ()
	then call form_group_tables;

	if report_list.first = null ()
	then report_list.first, report_list.last = current_report_loc;
	else report_list.last -> report.rep_next, report_list.last = current_report_loc;

	current_report_loc = null ();
	go to ret;

action (12):
rg_init:						/* initialize for a report group entry */
	NODE.nd_tok_line = header.line;
	NODE.nd_tok_column = header.column;

	rg_cl = "0"b;				/* set to non term node */

	NODE.nd_name_ptr = null ();

	NODE.nd_level, NODE.next_group.type = 0;
	NODE.line.value = 0;
	NODE.line.type, NODE.column.type = 0;

	addr (NODE.usage_disp) -> bit12 = "0"b;

	NODE.nd_loc, NODE.picture = null ();		/*[5.1-2]*/
	NODE.control_name_ptr, NODE.rep_sum_ptr, NODE.rep_group_ptr = null ();
						/*[5.1-2]*/
	NODE.column.type, NODE.node_type = 0;


	par_1, group_type = 0;
	ptr_1, ptr_2 = null ();

	go to ret;

action (13):
rg_clnum:						/* rg clauses */
	rg_cl_num = cl_off;				/* clause number */
	rg_line = header.line;
	rg_column = header.column;
	go to ret;


action (14):
rg_clause:					/* process report group clause */
	if rg_cl_bits (rg_cl_num)
	then do;
		call DIAG (1, rg_line, rg_column);	/* clause previously defined */

		go to ret;
	     end;

	rg_cl_bits (rg_cl_num) = "1"b;		/* dispatch on clause type */

	go to RG (rg_cl_num);

RG (0):						/* illegal */
	go to RG0;

RG (1):						/* . */
	go to RG0;

RG (2):						/* LINE clause */
	NODE.line.type = par_1;
	NODE.line.value = par_2;
	go to RG0;

RG (3):						/* NEXT GROUP clause */
	NODE.next_group.type = par_1;
	NODE.next_group.value = par_2;
	go to RG0;

RG (4):						/*TYPE clause */
	group_type = par_1;
	go to RG0;

RG (5):						/* USAGE clause */
	NODE.usage_disp = "1"b;
	go to RG0;

RG (6):						/* PRESENT clause */
	go to RG0;

RG (7):						/* BLANK WHEN ZERO clause */
	NODE.blank_zero = "1"b;
	go to RG0;

RG (8):						/* GROUP INDICATE clause */
	NODE.group_ind = "1"b;
	go to RG0;

RG (9):						/* JUSTIFIED clause */
	NODE.just_right = "1"b;
	go to RG0;

RG (10):						/* COLUMN clause */
	NODE.column.type = par_1;
	NODE.column.value = par_2;
	go to RG0;

RG (11):						/* PICTURE clause */
	NODE.picture = addr_record;
	go to RG0;

RG (12):						/* SOURCE clause */
	NODE.data_type = 1;				/* type */
	NODE.nd_loc = ident_ptr;
	go to RG0;

RG (13):						/* VALUE clause */
	NODE.data_type = 2;				/* type */
	NODE.nd_loc = list_def_ptr;
	go to RG0;

RG (14):						/* SUM clause */
	NODE.data_type = 3;				/* type */

/* allocate space for a sum counter */

	call get_space (size (sum_counter), sum_counter_ptr);


	sum_counter.sct_reset_loc = reset_clause_ptr;	/* reset clause loc */
	sum_counter.sct_size = sum_counter_size;	/* sum clause count */

	do i = sum_counter_size by -1 to 1;

	     sum_counter.sct_loc (i) = sum_counter_lifo_ptr -> list_link.loc;
	     sum_counter_lifo_ptr = sum_counter_lifo_ptr -> list_link.next;

	end;

	NODE.nd_loc = sum_counter_ptr;

	go to RG0;

RG (15):						/* sign clause */
	go to RG0;

RG0:
	go to ret;

action (15):
rg_line_1:
	par_2 = int_val;
	if int_val > 999
	then call DIAG (24, cl_token.line, cl_token.column);
	go to ret;

action (16):
rg_line_2:
	par_1 = 1;				/* integer */
	go to ret;

action (17):
rg_line_3:
	par_1 = 2;				/* PLUS integer */
	go to rg_line_1;

action (18):
rg_line_4:
	par_1 = 3;				/* PAGE integer */
	go to ret;

action (19):
rg_group_1:
	par_1 = 3;				/* PLUS integer */
	go to ret;

action (20):
rg_group_2:
	par_1 = 1;				/* NEXT PAGE */
	go to ret;

action (21):
rg_group_3:
	par_1 = 2;				/* integer */
	go to ret;

action (22):
rg_group_4:
	par_2 = int_val;
	if int_val > 999
	then call DIAG (24, cl_token.line, cl_token.column);
	go to ret;

action (23):
rg_type_1:
	par_1 = cl_off;				/* rh,ph,ch,de,cf,pf,rf */
	go to ret;

action (24):
rg_type_2:
	par_1 = 1;				/* REPORT HEADING */
	go to ret;

action (25):
rg_type_3:
	par_1 = 7;				/* REPORT FOOTING */
	go to ret;

action (26):
rg_type_4:
	par_1 = 3;				/* CONTROL HEADING */
	go to ret;

action (27):
rg_type_5:
	par_1 = 5;				/* CONTROL FOOTING */
	go to ret;

action (28):
rg_type_6:
	NODE.control_name_ptr = null ();		/* CONTROL FINAL */
	go to ret;

action (29):
rg_type_7:
	par_1 = 2;				/* PAGE HEADING */
	go to ret;

action (30):
rg_type_8:
	par_1 = 6;				/* PAGE FOOTING */
	go to ret;

action (31):
rg_pres_1:
	par_1 = token_count;
	ptr_1 = addr_record;
	go to ret;

action (32):
rg_pres_2:
	ptr_2 = prev_token_ptr;
	go to ret;

action (33):
rg_col_1:
	par_1 = 2;				/* PLUS integer */
	go to ret;

action (34):
rg_col_2:
	par_1 = 1;				/* integer */
	go to ret;

action (35):
rg_col_3:
	par_2 = int_val;
	if int_val > 999
	then call DIAG (24, cl_token.line, cl_token.column);
	go to ret;

action (36):
q_name_1:						/* count comps in qual name */
	qual_name_size = 0;

	go to ret;

action (37):
q_name_2:						/* allocate space for qual name */
	call get_space (size (qual_name), qual_name_ptr);

	qual_name.qn_size = qual_name_size;

	do i = 1 by 1 to qual_name_size;		/* fill table */

	     qual_name.qn_loc (i) = QUAL_NAME.QN_loc (i);

	end;

	go to ret;

action (38):
id_1:
	call get_space (ident_SIZE, ident_ptr);

	ident.id_name_loc = null ();
	ident.count = 0;

	go to ret;

action (39):
id_2:
	ident.count = token_count - ident.count + 1;	/* compute token count */
	ident.last = addr_record;

	go to ret;

action (40):
sum_1:
	sum_counter_size = 0;
	sum_ctr_ctr = sum_ctr_ctr + 1;

	if NODE.nd_name_ptr = null ()
	then call form_sum_name;

	reset_clause_ptr, sum_counter_lifo_ptr = null ();

	go to ret;

action (41):
sum_2:
	sum_counter_size = sum_counter_size + 1;	/* sum clause count */

	call get_space (list_link_SIZE, list_link_ptr);

	list_link.loc = sum_clause_ptr;
	list_link.next = sum_counter_lifo_ptr;

	sum_counter_lifo_ptr = list_link_ptr;

	go to ret;

action (42):
sum_3:
	reset_clause.rc_loc = qual_name_ptr;


	go to ret;

action (43):
sum_4:
	reset_clause.rc_final = "1"b;

	go to ret;

action (44):
id_4:						/* initialize for subscript parse */
	ident.count = token_count;
	ident.first = addr_record;


	go to ret;

action (45):
sum_ph_1:
	sum_clause_size = 0;
	sum_clause_lifo_ptr, upon_clause_ptr = null ();


	go to ret;

action (46):
sum_ph_2:
	call get_space (size (sum_clause), sum_clause_ptr);

	sum_clause.sc_upon_loc = upon_clause_ptr;	/* upon_clause */
	sum_clause.sc_size = sum_clause_size;		/* ident count */

	do i = sum_clause_size by -1 to 1;

	     sum_clause.sc_loc (i) = sum_clause_lifo_ptr -> list_link.loc;
	     sum_clause_lifo_ptr = sum_clause_lifo_ptr -> list_link.next;

	end;


	go to ret;

action (47):
sum_ph_3:
	sum_clause_size = sum_clause_size + 1;

	call get_space (list_link_SIZE, list_link_ptr);

	list_link.loc = ident_ptr;
	list_link.next = sum_clause_lifo_ptr;

	sum_clause_lifo_ptr = list_link_ptr;


	go to ret;

action (48):
sum_ph_4:
	upon_clause_ptr = qual_name_seq_ptr;


	go to ret;

action (49):
sign_1:						/* TRAILING SEPARATE */
	term_node.sign = 4;
	go to ret;

action (50):
sign_2:						/* TRAILING */
	term_node.sign = 2;
	go to ret;

action (51):
sign_3:						/* LEADING SEPARATE */
	term_node.sign = 3;
	go to ret;

action (52):
sign_4:						/* LEADING */
	term_node.sign = 1;
	go to ret;
declare	rep_num		fixed bin;
action (53):
rd_init:						/* RD clause initialization */
	if current_report_loc = null ()
	then call get_space (report_SIZE, current_report_loc);
						/*[5.1-2]*/
	fatal_no = fixed_common.fatal_no;
	report.rep_next, report.rep_name_ptr = null ();
	report.de, report.ch, report.cf = null ();
	report.rh, report.rf, report.ph, report.pf, report.rep_sum_ptr = null ();
	report.code = " ";
	report.rep_tok_line = header.line;
	report.rep_tok_column = header.column;
	rep_num = rep_num + 1;
	report.rep_num = rep_num;
	report.rep_up = null ();
	report.rep_type, report.rep_level, report.g_i_count = 0;
	report.page.type, report.heading.type, report.footing.type = 0;
	report.first_detail.type, report.last_detail.type = 0;
	report.heading.count, report.footing.count = 0;
	report.page.count = 999;
	report.first_detail.count, report.last_detail.count = 0;
	report.file_name, report.controls.loc = null ();
	string (report.indicators) = "0"b;
	de_table_size = 0;
	ST.entry.node_ptr (0) = current_report_loc;
	rd_cl = "0"b;
	go to ret;

action (54):
rd_name:						/* report name */
	report.rep_name_ptr = addr_record;

	go to ret;

action (55):
rd_cl_num:					/* RD clause number */
	rd_clnum = cl_off;
	rd_line = header.line;
	rd_column = header.column;

	go to ret;

action (56):
rd_clause:					/* process RD clause */
	if rd_cl_bits (rd_clnum)
	then do;
		call DIAG (1, rg_line, rg_column);	/* clause previously defined */
		go to ret;
	     end;

	rd_cl_bits (rd_clnum) = "1"b;

	go to RD (rd_clnum);

RD (0):						/* illegal */
	go to RD0;

RD (1):						/* . */
	go to RD0;

RD (2):						/* CODE clause */
	report.code = cd_lit;
	go to RD0;

RD (3):						/* CONTROL clause */
	report.controls.loc = qual_name_seq_ptr;

	go to RD0;

RD (4):						/* PAGE clause */
	call check_page;
	go to RD0;

RD0:
	go to ret;

action (57):
code:						/* code literal */
	cd_lit = alphanum_lit.string;

	go to ret;

action (58):
con_2:						/* FINAL present 		*/
	report.controls.final = "1"b;

/*[4.4-1]*/
	call form_control_table (qual_name_seq.qns_size); /* form ch_table and cf_table */

	go to ret;

action (59):
con_init:						/*[4.4-1]*/
	qual_name_seq_ptr = null ();
	go to ret;

action (60):
con_name:
	qual_name_seq_size = 0;			/* count qual names in a sequence */
	qual_name_seq_lifo_ptr = null ();

	go to ret;

action (61):
pg_init:
	pg_cl = "0"b;
	report.page.type = 1;
	go to ret;

action (62):
pg_cl_num:
	pg_clnum = cl_off;
	pg_line = header.line;
	pg_column = header.column;
	go to ret;

action (63):
pg_clause:
	if pg_cl_bits (pg_clnum)
	then do;
		call DIAG (1, pg_line, pg_column);
		go to ret;
	     end;

	pg_cl_bits (pg_clnum) = "1"b;

	go to PG (pg_clnum);

PG (0):						/* illegal */
	go to PG0;





PG (1):						/* HEADING */
	report.heading.count = int_val;
	report.heading.type = 1;
	go to PG0;

PG (2):						/* FIRST DETAIL */
	report.first_detail.count = int_val;
	report.first_detail.type = 1;
	go to PG0;

PG (3):						/* LAST DETAIL */
	report.last_detail.count = int_val;
	report.last_detail.type = 1;
	go to PG0;

PG (4):						/* FOOTING */
	report.footing.count = int_val;
	report.footing.type = 1;
	go to PG0;

PG0:
	go to ret;

declare	1 ae		like integer_spec;

action (64):
ae_init:
	ae.count = token_count;
	ae.first = addr_record;
	go to ret;

action (65):
ae_final:
	ae.count = token_count - ae.count;
	ae.last = prev_token_ptr;

	if token_count = 1 & ae.first -> header.type = 2
	then ae.type = 1;
	else ae.type = 2;

	go to ret;

/* process the report node after the	*/
/* clauses have been parsed		*/


check_page:
     proc;					/* establish defaults */

	if report.heading.count = 0
	then report.heading.count = 1;

	if report.first_detail.count = 0
	then report.first_detail.count = report.heading.count;

	if report.last_detail.count = 0 & report.footing.count = 0
	then report.last_detail.count, report.footing.count = report.page.count;

	if report.footing.count ^= 0 & report.last_detail.count = 0
	then report.last_detail.count = report.footing.count;

	if report.last_detail.count ^= 0 & report.footing.count = 0
	then report.footing.count = report.last_detail.count;

	if report.heading.count > 999
	then call DIAG (24, pg_line, pg_column);
	if report.heading.count < 1
	then call DIAG (32, pg_line, pg_column);
	if report.first_detail.count < report.heading.count
	then call DIAG (33, pg_line, pg_column);
	if report.last_detail.count < report.first_detail.count
	then call DIAG (34, pg_line, pg_column);
	if report.footing.count < report.last_detail.count
	then call DIAG (35, pg_line, pg_column);
	if report.page.count < report.footing.count
	then call DIAG (36, pg_line, pg_column);

     end;


action (66):
rep_group:					/* dispatch on the node type:	*/
						/* (1)root, (2)non-term, (3)term	*/
	go to RNT (NODE.node_type);			/*[5.1-2]*/
RNT (0):
	go to RNT0;
RNT (1):						/* root node */
	root.group_type = group_type;

	call set_cf_sum_chain;

	go to REP (group_type);			/*[5.1-2]*/
REP (0):
	go to REP0;
REP (1):						/* RH */
	if report.rh ^= null ()
	then call DIAG (7, rg_line, rg_column);
	report.rh = node_ptr;

	go to REP0;

REP (2):						/* PH */
	if report.ph ^= null ()
	then call DIAG (7, rg_line, rg_column);
	report.ph = node_ptr;

	go to REP0;

REP (6):						/* PF */
	if report.pf ^= null
	then call DIAG (7, rg_line, rg_column);
	report.pf = node_ptr;

	go to REP0;

REP (7):						/* RF */
	if report.rf ^= null ()
	then call DIAG (7, rg_line, rg_column);
	report.rf = node_ptr;

	go to REP0;

REP (3):						/* ch chain */
	call process_control_group (report.ch);


	go to REP0;

REP (5):						/* cf chain */
	call process_control_group (report.cf);

	last_control_num = seq_pos;

	sum_counter_count = 0;

	sum_chain_ptr = null ();


	go to REP0;

REP (4):						/* de chain */
	de_table_size = de_table_size + 1;

	call enter_group_chain (report.de, node_ptr, node_ptr);

	go to REP0;

REP0:
	if last_root_ptr ^= null ()
	then call form_group_tables;

	last_root_ptr = rt_ptr;
	root.nodes.count = 1;
	rt_ptr = null ();


	go to RNT0;

RNT (2):						/* non term node */
	call link_node;
	ntn_ptr = null ();


	go to RNT0;

RNT (3):						/* term node */
	if term_node.data_type = 3			/* sum counter */
	then if last_root_ptr -> root.group_type ^= 5	/* not CF group */
	     then call DIAG (44, term_node.tn_tok_line, term_node.tn_tok_column);

	     else do;				/* add new entry to sum counter chain for the CF group */

		     call enter_group_chain (sum_chain_ptr, sum_counter_ptr, node_ptr);


		     sum_counter_count = sum_counter_count + 1;
		end;


	call link_node;
	tn_ptr = null ();










	go to RNT0;

RNT0:
	go to ret;



link_node:
     proc;

	last_root_ptr -> root.nodes.count = last_root_ptr -> root.nodes.count + 1;

	if last_root_ptr -> root.nodes.first = null ()
	then last_root_ptr -> root.nodes.first, last_root_ptr -> root.nodes.last = node_ptr;
	else last_root_ptr -> root.nodes.last -> term_node.tn_next, last_root_ptr -> root.nodes.last = node_ptr;










     end;



action (67):
id_3:						/* name of identifier */
	ident.id_name_loc = qual_name_ptr;

	go to ret;

action (68):
q_name_3:
	qual_name_size = qual_name_size + 1;		/* save comp in qual name */

	QUAL_NAME (qual_name_size) = addr_record;

	go to ret;

/* initialize for processing a report */


action (69):
rep_group_1:
	ST.st_depth, sum_counter_count = 0;
	last_control_num = 10000;
	last_root_ptr = null ();
	go to ret;



action (70):
rg_entry_1:
	NODE.nd_name_ptr = addr_record;
	go to ret;


find_st_depth:
     proc;

declare	(i, lev)		fixed bin;


	do i = ST.st_depth by -1 to 1;

	     lev = ST.entry.level (ST.st_depth);

	     if NODE.nd_level > lev
	     then do;
		     ST.st_depth = i + 1;
		     return;
		end;
	     else if NODE.nd_level = lev
	     then do;
		     ST.st_depth = i;
		     return;
		end;
	end;

	ST.st_depth = 1;
     end;




/* process the report node after all of	*/
/* the clauses have been parsed	*/

action (71):
rg_entry_2:					/* exit from rg_entry */
	if ST.st_depth = 0
	then ST.st_depth = 1;
	else call find_st_depth;


/* establish the type of the report node	*/
/* (1)root, (2)non-term, (3)term. allocate	*/
/* space for the node, set node_ptr to point	*/
/* to the node				*/


	call classify_node;

	go to NDT (NODE.node_type);			/*[5.1-2]*/
NDT (0):
	go to NDT0;
NDT (1):						/* root node */
	call def_node (root_SIZE, rt_ptr);


	root.rt_type = 3;
	root.next_group.type = NODE.next_group.type;
	root.line.type = NODE.line.type;
	root.next_group.value = NODE.next_group.value;
	root.line.value = NODE.line.value;
	root.usage_disp = NODE.usage_disp;

	root.nodes.count = 0;
	root.nodes.first = null ();


	group_number = group_number + 1;
	root.group_number = group_number;

	root.field_table_ptr, root.line_table_ptr = null ();
	root.use_proc.use_proc_name_ptr, prev_node_ptr = null ();
	root.group_desc.type = 0;



	go to NDT0;

NDT (2):						/* non terminal node */
	call def_node (non_term_node_SIZE, ntn_ptr);


	non_term_node.ntn_type = 1;
	addr (non_term_node.line) -> non_term_node_line_bits = non_term_node_line_bits;



	go to NDT0;

NDT (3):						/* term node */
	call def_node (term_node_SIZE, tn_ptr);


	term_node.tn_type = 2;
	addr (term_node.line) -> term_node_line_bits = term_node_line_bits;

	term_node.data_type = NODE.data_type;


	if NODE.data_type = 3
	then do;
		if report.rep_sum_ptr = null ()
		then term_node.rep_sum_ptr = null ();
		else term_node.rep_sum_ptr = report.rep_sum_ptr;


		report.rep_sum_ptr = tn_ptr;
	     end;
	term_node.nd_loc = NODE.nd_loc;

	if term_node.group_ind
	then do;
		report.g_i_count = report.g_i_count + 1;
		term_node.g_i_count = report.g_i_count;
	     end;
	else term_node.g_i_count = 0;

	term_node.rep_group_ptr = last_root_ptr;




	go to NDT0;

NDT0:						/* complete the entry */
	if prev_node_ptr ^= null ()
	then prev_node_ptr -> term_node.tn_next = node_ptr;

	node_ptr -> term_node.tn_next = null ();
	node_ptr -> term_node.tn_tok_line = NODE.nd_tok_line;
	node_ptr -> term_node.tn_tok_column = NODE.nd_tok_column;
	node_ptr -> term_node.tn_name_ptr = NODE.nd_name_ptr;
	node_ptr -> term_node.tn_level = ST.st_depth;



	if ST.st_depth > 0
	then node_ptr -> term_node.tn_up = ST.node_ptr (ST.st_depth - 1);
	else node_ptr -> term_node.tn_up = null ();



/* maintain up chain, needed to get	*/
/* completely qualified sum counter	*/
/* names				*/
	prev_node_ptr = node_ptr;

/* maintain node chain */

	ST.entry.level (ST.st_depth) = NODE.nd_level;


	ST.entry.node_ptr (ST.st_depth) = node_ptr;

	go to ret;



action (72):
con_name_1:					/* add qual name to lifo chain */
	qual_name_seq_size = qual_name_seq_size + 1;	/* count of entries in chain */
	call get_space (list_link_SIZE, list_link_ptr);

	list_link.loc = qual_name_ptr;		/* qual name chain link */
	list_link.next = qual_name_seq_lifo_ptr;

	qual_name_seq_lifo_ptr = list_link_ptr;		/* head of lifo chain */

	go to ret;

declare	qual_name_seq_lifo_ptr
			ptr;

action (73):
con_name_2:					/* form table describing a sequence	*/
						/* of qual names 			*/
	call get_space (size (qual_name_seq), qual_name_seq_ptr);

	qual_name_seq.qns_size = qual_name_seq_size;	/* size of the chain */

	do i = qual_name_seq_size by -1 to 1;

	     qual_name_seq.qns_loc (i) = qual_name_seq_lifo_ptr -> list_link.loc;

	     qual_name_seq_lifo_ptr = qual_name_seq_lifo_ptr -> list_link.next;

	end;

	go to ret;




action (74):
con_1:						/* form control tables	*/
	report.controls.final = "0"b;

/*[4.4-1]*/
	call form_control_table (qual_name_seq.qns_size); /* form ch_table and cf_table */

	go to ret;








action (75):
rg_type_9:					/* type clause, control name */
	NODE.control_name_ptr = qual_name_ptr;

	go to ret;


action (76):
sum_5:						/* alloc space for reset clause descr */
	call get_space (reset_clause_SIZE, reset_clause_ptr);

	reset_clause.rc_loc = null ();
	reset_clause.rc_final = "0"b;

	go to ret;

action (77):
rs_exit:						/* exit from report section */
	call process_sum_counters;
	call process_report_clauses;

	if report_list.first ^= null ()
	then call cobol_generate_report (report_list.first, trace.phase.first (5), tbit);

	call cobol_io_$cobol_msf_start (rwfp, report_first_token);
	call scan;				/* report section */

	return;
action (78):
	go to ret;




action (79):					/* DETAIL */
rg_type_a:
	par_1 = 4;
	go to ret;


action (80):
pg_set:
	report.page.count = int_val;
	go to ret;

action (81):
lit_1:
	call get_space (list_def_SIZE, list_def_ptr);

	list_def.count = 1;
	list_def.first = addr_record;

	go to ret;

action (82):
lit_2:
	list_def.count = 2;
	list_def.last = addr_record;

	go to ret;

action (83):
con_3:						/*[4.4-1]*/
	report.controls.final = "1"b;			/*[4.4-1]*/
	call form_control_table (0);
	go to ret;




























/* CHECK ROUTINES */




check (1):
eof:
	if header.type = 9999
	then go to success;
	go to fail;




check (2):
lev_num:
	if header.type ^= 2
	then go to fail;

	if numeric_lit.sign ^= " " | ^numeric_lit.integral
	then go to fail;

	NODE.nd_level = fixed (numeric_lit.literal);

	if NODE.nd_level = 0 | NODE.nd_level > 49
	then go to fail;

	lv_line = header.line;
	lv_col = header.column;
	res = "0"b;
	go to success;




check (3):
type2:
	if header.type = 2
	then go to success;
	go to fail;




check (4):
type8:
	if header.type = 8
	then go to success;
	go to fail;




check (5):
code_lit:
	if header.type ^= 3
	then go to fail;

	if alphanum_lit.lit_size > 2
	then go to fail;
	go to success;




check (6):
pic:
	if header.type = 4
	then go to success;
	go to fail;




check (7):
integer:
	if header.type = 1 & reserved_word.key = 180	/* zero */
	then do;
		int_val = 0;
		go to success;
	     end;
	if header.type ^= 2
	then go to fail;

	if numeric_lit.sign ^= " " | ^numeric_lit.integral
	then go to fail;

	int_val = fixed (numeric_lit.literal);
	go to success;


check (8):
literal:
	if header.type = 2 | header.type = 3
	then go to success;
	go to fail;



check (9):
type1:
	if header.type = 1
	then go to success;
	go to fail;




check (10):
is_sub_opt:
	if subj_req
	then go to fail;
	go to success;




check (11):
lptopstk:
	if cssub >= 0
	then go to success;
	go to fail;




check (12):
relop:
	if header.type ^= 1
	then go to fail;

	if reserved_word.rel_op
	then go to success;
	go to fail;




check (13):
type3:
	if header.type = 3
	then go to success;
	go to fail;




check (14):
figconall:
	if header.type ^= 1
	then go to fail;

	if reserved_word.figcon
	then go to success;
	go to fail;




check (15):
arop:
	if header.type ^= 1
	then go to fail;

	if reserved_word.arith_op
	then go to success;
	go to fail;

check (16):
nonumlit:
	if header.type = 3
	then go to success;
	go to fail;

check (17):
illeg_ln:
	if res
	then go to success;
	else go to fail;





























declare	AA		(1024) fixed bin based (alloc_area.aa_loc);

declare	01 alloc_area,
	  02 aa_loc	ptr,			/* aa_location of area */
	  02 aa_size	fixed bin,		/* aa_size of allocated data */
	  02 aa_cap	fixed bin;		/* size of area */








/* allocate space */

get_space:
     proc (size, loc);

declare	sz		fixed bin;
declare	size		fixed bin,
	loc		ptr;

	sz = size + mod (-size, 2);
	loc = addr (AA (alloc_area.aa_size));
	alloc_area.aa_size = alloc_area.aa_size + sz;

	if alloc_area.aa_size > alloc_area.aa_cap
	then do;

		alloc_area.aa_loc, loc = cobol$alloc (1024);
		alloc_area.aa_size = sz + 1;
	     end;

     end;








/* see if a qual name (defined by FIND_name_ptr)	*/
/* appears in a qual name sequence (defined	*/
/* by FIND_seq_ptr):			*/
/*     seq_pos:	>0 found once		*/
/*		=0 not found		*/
/*		<0 found more than once	*/






declare	(FIND_ptr, FIND_name_ptr, FIND_seq_ptr)
			ptr;
declare	(seq_pos, FIND_ctr) fixed bin;



FIND:
     proc (p, q);

declare	(p, q)		ptr;



	FIND_name_ptr = p;
	FIND_seq_ptr = q;
	seq_pos = 0;


	do FIND_ctr = 1 by 1 to FIND_seq_ptr -> qual_name.qn_size;

	     FIND_ptr = FIND_seq_ptr -> qual_name.qn_loc (FIND_ctr);

	     call COMP;

	end;

     end;


def_node:
     proc (sz, p);

declare	sz		fixed bin,
	p		ptr;

	if p = null ()
	then call get_space (sz, p);

	node_ptr = p;
     end;






COMP:
     proc;

declare	(i, j)		fixed bin;
declare	(lp, rp)		ptr,
	(lsz, rsz, lct)	fixed bin;

	lct = FIND_name_ptr -> qual_name.qn_size;
	i = 1;

	lp = FIND_name_ptr -> qual_name.qn_loc (1);
	lsz = lp -> user_word.length;

	do j = 1 by 1 to FIND_ptr -> qual_name.qn_size;

	     rp = FIND_ptr -> qual_name.qn_loc (j);

	     if substr (lp -> user_word.word, 1, lsz) = substr (rp -> user_word.word, 1, rp -> user_word.length)
	     then do;
		     i = i + 1;

		     if i > lct
		     then do;
			     if seq_pos = 0
			     then seq_pos = FIND_ctr;
			     else seq_pos = -seq_pos;

			     return;

			end;

		     lp = FIND_name_ptr -> qual_name.qn_loc (i);
		     lsz = lp -> user_word.length;

		end;
	end;
     end;



declare	(last_control_num, sum_counter_count)
			fixed bin,
	sum_chain_ptr	ptr;

set_cf_sum_chain:
     proc;

	if sum_chain_ptr ^= null () & last_control_num ^= 10000
	then do;

		call form_name_seq (sum_chain_ptr, sum_counter_count, cf_table.cf_sum_name_seq_ptr (last_control_num))
		     ;

		cf_table.cf_sum_chain (last_control_num) = sum_chain_ptr;

	     end;


	last_control_num = 10000;

     end;



classify_node:
     proc;

	NODE.node_type = 0;				/* 0(illegal)1(root)2(non_term)3(term) */

	if substr (rg_cl, 3, 2) ^= "0"b
	then do;
		NODE.node_type = 1;			/* root node */

		if substr (rg_cl, 6) ^= "0"b
		then call DIAG (9, lv_line, lv_col);	/* term node clauses illegal */

		if NODE.nd_level ^= 1
		then call DIAG (10, lv_line, lv_col);	/* should be level 1 */

		if substr (rg_cl, 4, 1) = "0"b
		then call DIAG (8, lv_line, lv_col);	/* TYPE clause missing */

		return;
	     end;

	if substr (rg_cl, 7) ^= "0"b
	then do;
		NODE.node_type = 3;			/* term node */

/*[5.1-3]*/
		if substr (rg_cl, 11, 1) = "0"b	/*[5.1-3]*/
		then call DIAG (126, lv_line, lv_col);	/* PIC clause missing */

		if substr (rg_cl, 12, 3) = "0"b
		then call DIAG (16, lv_line, lv_col);	/* SOURCE/SUM/VALUE missing */

		if NODE.nd_level = 1
		then call DIAG (15, lv_line, lv_col);	/* should not be level 1 */

		return;
	     end;

	if NODE.nd_level = 1
	then do;
		NODE.node_type = 1;			/* root.node */

		call DIAG (8, lv_line, lv_col);	/* TYPE clause missing */

		if substr (rg_cl, 6, 1) ^= "0"b
		then call DIAG (9, lv_line, lv_col);	/* PRESENT illegal */

		return;
	     end;

	NODE.node_type = 2;				/* non_term_NODE.node */

     end;





/* form the line and field tables for 	*/
/* a report group			*/

declare	(ltl, ftl)	fixed bin;		/* pos in line and field tables */

declare	line_status	fixed bin;		/* 0(initial)1(abs)2(rel) */
declare	line_value	fixed bin;		/* line clause parameter */

declare	(lt, lv)		fixed bin;
declare	(ct, cv)		fixed bin;

declare	col_clause	bit (1),
	(last_line_value, TYPE, LINE, SIZE)
			fixed bin;

declare	col_status	fixed bin;		/* 0(initial)1(abs)2(rel) */
declare	col_value		fixed bin;		/* column clause parameter */

declare	line_size		fixed bin;		/* size of the current line */
declare	line_count	fixed bin;		/* number of lines in the group */
declare	field_count	fixed bin;		/* number of fields in the line */



form_group_tables:
     proc;

/* form line and field tables */
declare	ct		fixed bin;


	ct = last_root_ptr -> root.nodes.count;
	line_table_size, field_table_size = ct + 1;

	call get_space (size (LINE_table), LINE_table_ptr);
	call get_space (size (FIELD_table), FIELD_table_ptr);

	LINE_table.LT_size = line_table_size;
	FIELD_table.FT_size = field_table_size;

	ltl, ftl = 0;
	line_status, line_value, line_count = 0;
	node_ptr = last_root_ptr;
	call lt_reset;
	col_clause = "0"b;
	TYPE, LINE, SIZE = 0;

	call group_node;				/* group_node */

	if ct ^= 0
	then do;
		node_ptr = last_root_ptr -> root.nodes.first;

		do while (node_ptr ^= null ());

		     call group_node;		/* subordinate node */

		     node_ptr = node_ptr -> root.rt_next;

		end;
	     end;

	if col_clause
	then SIZE = SIZE + 1;

	last_root_ptr -> root.group_desc.type = TYPE;
	last_root_ptr -> root.group_desc.line = LINE;
	last_root_ptr -> root.group_desc.size = SIZE;


	call set_count_and_size;

	last_root_ptr -> root.field_table_ptr = FIELD_table_ptr;
	last_root_ptr -> root.line_table_ptr = LINE_table_ptr;

	FIELD_table.FT_size = ftl;
	LINE_table.LT_size = ltl;

     end;




group_node:
     proc;

	go to GN (node_ptr -> root.rt_type);

GN (0):
	go to GN0;

GN (1):						/* non_term_node */
GN (3):						/* root node */
	call line_table_entry;

	go to GN0;

GN (2):						/* term node */
	call line_table_entry;

	ct = node_ptr -> term_node.column.type;

	if ct ^= 0
	then do;
		cv = node_ptr -> term_node.column.value;

		call check_field_clause;

	     end;
	go to GN0;

GN0:
     end;




line_table_entry:
     proc;

	lt = node_ptr -> root.line.type;

	if lt ^= 0
	then do;					/* LINE clause exists */
		call set_count_and_size;
		ltl = ltl + 1;
		line_count = line_count + 1;

		LINE_table.LT_first_field (ltl), LINE_table.LT_field_count (ltl), LINE_table.LT_line_size (ltl),
		     LINE_table.LT_line_num (ltl) = 0;

		lv = node_ptr -> root.line.value;

		call check_line_clause;
		call lt_reset;
	     end;
     end;
lt_reset:
     proc;

	col_status, col_value = 0;
	field_count, line_size = 0;
     end;

check_line_clause:
     proc;

	go to CLC (lt);				/* 1(i)2(+i)3(PAGE i) */

CLC (1):						/* LINE integer */
	go to LS1 (line_status);

LS1 (0):						/* undefined */
	line_status = 1;
	call set_line_num (-lv);
	TYPE = 1;
	LINE = lv;
	go to LS10;

LS1 (1):						/* abs */
	call line_incr_test (-lv);
	SIZE = SIZE + lv - last_line_value;
	go to LS10;

LS1 (2):						/* rel */
	call dg (19);
	go to LS10;

LS10:
	col_clause = "0"b;
	last_line_value = lv;

	go to CLC0;

CLC (2):						/* LINE PLUS integer */
	go to LS2 (line_status);

LS2 (0):						/* undefined */
	line_status = 2;
	TYPE = 2;
	LINE = lv;
	go to LS20;

LS2 (1):						/* abs */
	SIZE = SIZE + lv - last_line_value;

	if col_clause
	then SIZE = SIZE + 1;

	go to LS20;

LS2 (2):						/* rel */
	SIZE = SIZE + lv - last_line_value;

	if col_clause
	then SIZE = SIZE + 1;

	go to LS20;

LS20:
	col_clause = "0"b;
	last_line_value = lv;
	call set_line_num (lv);
	go to CLC0;

CLC (3):						/* LINE integer PAGE */
	go to LS3 (line_status);

LS3 (0):						/* undefined */
	call set_line_num (-lv - report.page.count);
	line_status = 1;
	TYPE = 3;
	LINE = lv;
	go to LS30;

LS3 (1):						/* abs */
	SIZE = SIZE + lv - last_line_value;

	go to LS30;

LS3 (2):						/* rel */
	call dg (20);
	go to LS30;

LS30:
	col_clause = "1"b;
	last_line_value = lv;

	go to CLC0;

CLC0:
     end;

dg:
     proc (dn);

declare	dn		fixed bin;

	call DIAG (dn, node_ptr -> term_node.tn_tok_line, node_ptr -> term_node.tn_tok_column);
     end;

set_count_and_size:
     proc;

	if ltl ^= 0
	then do;
		LINE_table.LT_field_count (ltl) = field_count;
		LINE_table.LT_line_size (ltl) = line_size;
	     end;
     end;

set_line_num:
     proc (s);

declare	s		fixed bin;

	line_value = lv;
	LINE_table.LT_line_num (ltl) = s;
     end;

line_incr_test:
     proc (s);

declare	s		fixed bin;

	if lv <= line_value
	then call dg (13);
	else call set_line_num (s);
     end;




check_field_clause:
     proc;

declare	p		ptr;			/*[5.1-3]*/
						/*[5.1-3]*/
dcl	1 PIC		static,			/*[5.1-3]*/
	  2 size		fixed bin init (0),		/*[5.1-3]*/
	  2 line		fixed bin init (0),		/*[5.1-3]*/
	  2 column	fixed bin init (0),		/*[5.1-3]*/
	  2 type		fixed bin init (0),		/*[5.1-3]*/
	  2 length	fixed bin init (1),		/*[5.1-3]*/
	  2 string	char (1) init ("X");


	p = node_ptr -> term_node.picture;		/*[5.1-3]*/
	if p = null ()
	then p = addr (PIC);
	pic_string_ptr = addr (p -> picture.string);
	pic_string_size = p -> picture.length;

	call get_pic_size;
	node_ptr -> term_node.non_num = non_num;
	go to CFC (ct);				/* 1(i)2(+i) */

CFC (1):						/* COLUMN integer */
	go to CS1 (col_status);

CS1 (0):						/* undefined */
	col_status = 1;

	call first_field;

	call set_fields (cv, pic_size, cv - 1);
	line_size = cv + pic_size - 1;
	col_clause = "1"b;

	go to CS10;

CS1 (1):						/* abs */
	if cv <= line_size
	then call dg (77);
	else do;
		call subseq_field;
		call set_fields (cv, pic_size, cv - line_size - 1);
		line_size = cv + pic_size - 1;
		col_clause = "1"b;
	     end;

	go to CS10;

CS1 (2):						/* rel */
	call dg (76);
	go to CS10;

CS10:
	go to CFC0;

CFC (2):						/* COLUMN PLUS integer */
	go to CS2 (col_status);

CS2 (0):						/* undefined */
	col_status = 2;

	call first_field;

	call set_fields (cv + 1, pic_size, cv);
	line_size = cv + pic_size;

	go to CS20;

CS2 (1):						/* abs */
	col_status = 2;
	call subseq_field;
	call set_fields (line_size + cv, pic_size, cv);
	line_size = line_size + cv + pic_size;

	go to CS20;

CS2 (2):						/* rel */
	call subseq_field;
	call set_fields (line_size + cv, pic_size, cv);
	line_size = line_size + cv + pic_size;
	go to CS20;

CS20:
	col_clause = "1"b;

	go to CFC0;

CFC0:
     end;

first_field:
     proc;

	ftl = ftl + 1;
	field_count = field_count + 1;

	LINE_table.LT_first_field (ltl) = ftl;
     end;

subseq_field:
     proc;

	ftl = ftl + 1;
	field_count = field_count + 1;
     end;

set_fields:
     proc (fp, fs, lf);

declare	(fp, fs, lf)	fixed bin;

	FIELD_table.FT_loc (ftl) = node_ptr;
	FIELD_table.FT_field_pos (ftl) = fp;
	FIELD_table.FT_field_size (ftl) = fs;
	FIELD_table.FT_left_fill_size (ftl) = lf;
     end;






declare	pic_string	char (pic_string_size) based (pic_string_ptr);

declare	(pic_loc, pic_size, ch_type, pic_string_size)
			fixed bin;
declare	(rep_spec_size, left_par_loc, right_par_loc, int_size)
			fixed bin;
declare	sep_sign		bit (1);
declare	next_char		char (1);
declare	pic_string_ptr	ptr;
declare	(s_exists, non_num) bit (1);
declare	pic_chars		char (18) init (".SVCDA,X9PZ*B/0+-""");








get_pic_size:
     proc;					/* compute size of field described by a picture string */

	pic_size = 0;				/* size of field */
	pic_loc = 1;				/* picture char being examined */
	s_exists = "0"b;
	non_num = "0"b;
	do while ("1"b);

	     ch_type = index (pic_chars, substr (pic_string, pic_loc, 1));

/* type of picture character */
	     go to PIC (ch_type);




PIC (6):						/* A */
PIC (8):						/* X */
PIC (13):						/* B */
	     non_num = "1"b;
PIC (0):						/* unspecified character */
PIC (1):						/* . */
PIC (7):						/* , */
PIC (9):						/* 9 */
PIC (11):						/* Z */
PIC (12):						/* * */
PIC (14):						/* / */
PIC (15):						/* 0 */
PIC (16):						/* + */
PIC (17):						/* - */
PIC (18):						/* $ */
	     call rep_spec;

	     pic_size = pic_size + rep_spec_size;

	     go to PIC0;

PIC (2):						/* S */
	     if node_ptr -> term_node.sign > 2
	     then pic_size = pic_size + 1;

	     pic_loc = pic_loc + 1;
	     s_exists = "1"b;
	     go to PIC0;

PIC (3):						/* V */
	     pic_loc = pic_loc + 1;

	     go to PIC0;

PIC (4):						/* C */
	     next_char = "r";

	     call test_next;

	     go to PIC0;

PIC (5):						/* D */
	     next_char = "b";

	     call test_next;

	     go to PIC0;

PIC (10):						/* P */
	     call rep_spec;

	     go to PIC0;

PIC0:
	     if pic_loc > pic_string_size
	     then return;

	end;

	if ^s_exists
	then node_ptr -> term_node.sign = 0;

     end;



test_next:
     proc;

	pic_loc = pic_loc + 1;

	if pic_loc > pic_string_size
	then do;
		pic_size = pic_size + 1;		/* ends in C or D */
		return;
	     end;

	if substr (pic_string, pic_loc, 1) = next_char
	then do;
		pic_size = pic_size + 1;		/* CR or DB */
		pic_loc = pic_loc + 1;
	     end;
	else do;
		call rep_spec;			/* not CR or DB */

		pic_size = pic_size + rep_spec_size;
	     end;
     end;








rep_spec:
     proc;

	rep_spec_size = 1;				/* one repetition */
	pic_loc = pic_loc + 1;

	if pic_loc > pic_string_size
	then return;				/* end of string */
	else if substr (pic_string, pic_loc, 1) ^= "("
	then return;				/* not ( */

	left_par_loc = pic_loc;			/* loc of ( */
	right_par_loc = index (substr (pic_string, pic_loc + 1), ")");
						/* loc of ) */

	if right_par_loc = 0
	then return;				/* ) not found */

	right_par_loc = right_par_loc + pic_loc - 1;
	int_size = right_par_loc - left_par_loc;

	if int_size = 0
	then return;				/* () found */

	do i = left_par_loc + 1 by 1 to right_par_loc - 1;

	     if index ("0123456789", substr (pic_string, i, 1)) = 0
	     then return;

/* non-digit found */
	end;

	rep_spec_size = fixed (substr (pic_string, left_par_loc + 1, int_size));
	pic_loc = right_par_loc + 2;

     end;









form_de_table:
     proc;

declare	i		fixed bin;


	call get_space (size (de_table), de_table_ptr);



	de_table.det_size = de_table_size;
	de_table.det_name_seq_ptr = null ();
	de_table.det_subtot_all.count = 0;

	if de_table_size = 0
	then return;

	call form_name_seq (report.de, de_table_size, de_table.det_name_seq_ptr);

	i = de_table_size;
	sum_ptr = report.de;

	do while (sum_ptr ^= null ());

	     de_table.det_loc (i) = sum.sum_loc;
	     de_table.det_subtot.count (i) = 0;

	     i = i - 1;
	     sum_ptr = sum.sum_next;

	end;
	report.de = de_table_ptr;


     end;

/* process the sum counters defined	*/
/* for all of the reports		*/

declare	(current_control_level, sum_clause_num, ident_num, de_table_loc, upon_num)
			fixed bin;

process_sum_counters:
     proc;

	current_report_loc = report_list.first;

	do while (current_report_loc ^= null ());

	     call process_rep_sc;			/* process sum counters for a	*/
						/* particular report	*/
	     current_report_loc = report.rep_next;

	end;
     end;

process_rep_sc:
     proc;

	de_table_ptr = report.de;

	if report.cf ^= null ()
	then do;
		cf_table_ptr = report.cf;


		do current_control_level = 0 by 1 to cf_table.cf_size;

		     call process_cf_sum_chain;

/* process the sum counter chain	*/
/* for a particular CF report group	*/

		end;
	     end;
     end;


process_cf_sum_chain:
     proc;

	sum_ptr = cf_table.cf_sum_chain (current_control_level);

	do while (sum_ptr ^= null ());

	     sum_counter_ptr = sum.sum_loc;

	     if sum_counter_ptr ^= null ()
	     then call process_cf_sum_counter;

	     sum_ptr = sum.sum_next;

	end;
     end;

process_cf_sum_counter:
     proc;

	if sum_counter.sct_size ^= 0
	then do sum_clause_num = 1 by 1 to sum_counter.sct_size;

		sum_clause_ptr = sum_counter.sct_loc (sum_clause_num);


		if sum_clause.sc_size ^= 0
		then call process_cf_sum_clause;
	     end;

	reset_clause_ptr = sum_counter.sct_reset_loc;

	if reset_clause_ptr ^= null ()
	then call process_cf_reset_clause;
	else call enter_reset_chain (current_control_level);
     end;

process_cf_sum_clause:
     proc;

	upon_clause_ptr = sum_clause.sc_upon_loc;

	if upon_clause_ptr = null ()
	then do ident_num = 1 by 1 to sum_clause.sc_size;

		ident_ptr = sum_clause.sc_loc (ident_num);

		call is_sum_counter;

		if hit_count = 1			/* sum counter found */
		then if addend_level < current_control_level
		     then call DIAG (41, report.rep_tok_line, report.rep_tok_column);
		     else if addend_level = current_control_level
		     then call enter_chain (addr (cf_table.cf_crossfoot (addend_level)), ident_ptr, sum.sum_qn_ptr);
		     else call enter_chain (addr (cf_table.cf_rollfwd (addend_level)), ident_ptr, sum.sum_qn_ptr);


		else call enter_chain (addr (de_table.det_subtot_all), ident_ptr, sum.sum_qn_ptr);

/* sum_counter not found */

	     end;
	else do;					/* upon clause missing */

		do upon_num = 1 by 1 to upon_clause.upon_size;

		     qual_name_ptr = upon_clause.upon_loc (upon_num);

		     call FIND (qual_name_ptr, de_table.det_name_seq_ptr);

		     if seq_pos = 0
		     then call DIAG (43, report.rep_tok_line, report.rep_tok_column);

		     else do;
			     de_table_loc = seq_pos;

			     do ident_num = 1 by 1 to sum_clause.sc_size;

				ident_ptr = sum_clause.sc_loc (ident_num);

				call is_sum_counter;

				if hit_count = 1
				then call DIAG (42, report.rep_tok_line, report.rep_tok_column);
				else call enter_chain (addr (de_table.det_subtot (de_table_loc)), ident_ptr,
					sum.sum_qn_ptr);

			     end;

			end;

		end;

	     end;
     end;



process_cf_reset_clause:
     proc;



/* process reset clause */

	if reset_clause.rc_final
	then do;
		seq_pos = 0;

		call enter_reset_chain (seq_pos);

	     end;

	else do;					/*[5.0-1]*/
		call FIND (reset_clause.rc_loc, report.controls.loc);


		if seq_pos = 0
		then call DIAG (50, report.rep_tok_line, report.rep_tok_column);
		else if seq_pos > current_control_level
		then call DIAG (46, report.rep_tok_line, report.rep_tok_column);
		else call enter_reset_chain (seq_pos);
	     end;

     end;



enter_reset_chain:
     proc (pos);
declare	pos		fixed bin;		/* place entry in the reset chain	*/
						/* seq_pos: control level at which to	*/
						/* reset				*/

	call get_space (reset_chain_entry_SIZE, reset_chain_entry_ptr);

	reset_chain_entry.loc = sum.sum_qn_ptr;

	call add_to_list (reset_chain_entry_ptr, addr (cf_table.cf_reset (pos)));

     end;






enter_group_chain:
     proc (entry_loc, data_ptr, chain_ptr);

/* add new entry to a group chain(de,sum)	*/
/* and initialize the entry			*/


declare	(entry_loc, data_ptr, chain_ptr)
			ptr;

	call get_space (sum_SIZE, sum_ptr);		/* allocate space for entry */

	sum.sum_next = entry_loc;
	sum.sum_loc = data_ptr;
	entry_loc = sum_ptr;

	call tree_to_qual (chain_ptr, sum.sum_qn_ptr);	/* qualif name */

     end;

enter_chain:
     proc (list_ptr, ident_ptr, sum_ptr);

declare	(list_ptr, ident_ptr, sum_ptr)
			ptr;

	call get_space (chain_entry_SIZE, chain_entry_ptr);

	chain_entry.ce_loc = ident_ptr;
	chain_entry.ce_sum_loc = sum_ptr;

	call add_to_list (chain_entry_ptr, list_ptr);

     end;


form_control_table:
     proc (siz);

/* allocate the control tables	*/
/*     ch_table and cf_table		*/
/* initialize the tables		*/

/*[4.4-1]*/
declare	(i, siz)		fixed bin;

/*[4.4-1]*/
	ch_table_size, cf_table_size = siz;

	call get_space (size (ch_table), report.ch);
	ch_table_ptr = report.ch;

	ch_table.ch_size = ch_table_size;

	call get_space (size (cf_table), report.cf);
	cf_table_ptr = report.cf;

	cf_table.cf_size = cf_table_size;

	do i = 0 by 1 to ch_table_size;

	     ch_table.ch_loc (i), ch_table.ch_sum_name_seq_ptr (i) = null ();
	     ch_table.ch_sum_chain (i) = null ();
	     ch_table.ch_crossfoot.count (i), ch_table.ch_rollfwd.count (i), ch_table.ch_reset.count (i) = 0;

	     cf_table.cf_loc (i), cf_table.cf_sum_name_seq_ptr (i) = null ();
	     cf_table.cf_sum_chain (i) = null ();
	     cf_table.cf_crossfoot.count (i), cf_table.cf_rollfwd.count (i), cf_table.cf_reset.count (i) = 0;

	end;

     end;

form_name_seq:
     proc (chain_ptr, chain_size, name_seq_ptr);

/* form a qualified name sequence from a chain	*/
/* of qualified names. chain_ptr specifies the	*/
/* location of the chain and chain_size		*/
/* specifies the size of the chain. The location	*/
/* of the qualif name sequence is placed in	*/
/* name_seq_ptr				*/

declare	(chain_ptr, name_seq_ptr)
			ptr;
declare	chain_size	fixed bin;

declare	i		fixed bin,
	p		ptr;






	qual_name_seq_size = chain_size;

	call get_space (size (qual_name_seq), qual_name_seq_ptr);

	qual_name_seq.qns_size = qual_name_seq_size;
	p = chain_ptr;


	do i = qual_name_seq_size by -1 to 1;

	     qual_name_seq.qns_loc (i) = p -> sum.sum_qn_ptr;

	     p = p -> sum.sum_next;

	end;

	name_seq_ptr = qual_name_seq_ptr;

     end;







process_control_group:
     proc (p);

declare	p		ptr;

	if NODE.control_name_ptr = null ()		/* FINAL */
	then do;
		if ^report.controls.final		/* not spec by controls clause */
		then do;
			call DIAG (47, root.rt_tok_line, root.rt_tok_column);

/* FINAL not in CONTROL clause */

			return;

		     end;

		seq_pos = 0;

	     end;
	else do;
		call FIND (NODE.control_name_ptr, report.controls.loc);

		if seq_pos = 0
		then do;
			call DIAG (50, root.rt_tok_line, root.rt_tok_column);

/* data-name not in CONTROL clause */
			seq_pos = 10000;
			return;

		     end;
		else if seq_pos < 0
		then do;
			call DIAG (82, root.rt_tok_line, root.rt_tok_column);

/* data-name appears more than once in CONTROL clause */
			seq_pos = 10000;
			return;

		     end;
	     end;

	if p -> ch_table.ch_loc (seq_pos) ^= null ()	/* already defined */
	then do;
		call DIAG (81, root.rt_tok_line, root.rt_tok_column);

/* data-name appears more than once in CH/CF group */

		return;

	     end;

	p -> ch_table.ch_loc (seq_pos) = node_ptr;
	p -> ch_table.ch_sum_chain (seq_pos) = sum_chain_ptr;
						/* control number to seq_pos */

     end;


declare	(hit_count, addend_level)
			fixed bin;


is_sum_counter:
     proc;

/* is the qual name specified by p a sum	*/
/* counter in the report specified by q. Set	*/
/* hit_count = 0(not found),1(found once),2(found	*/
/* more than once). Set addend_level to the level*/
/* of the CF group containing the sum counter	*/


declare	i		fixed bin;
declare	p		ptr;


	hit_count = 0;

	if cf_table.cf_size = 0 | ident.subscripts.count ^= 0
	then return;

	do i = 1 by 1 to cf_table.cf_size;

	     p = cf_table.cf_sum_name_seq_ptr (i);

	     if p ^= null ()
	     then do;

		     call FIND (ident.id_name_loc, p);

		     if seq_pos < 0
		     then do;
			     hit_count = 2;

			     return;

			end;

		     else if seq_pos > 0
		     then do;
			     hit_count = hit_count + 1;

			     addend_level = i;

			end;

		     if hit_count = 2
		     then return;

		end;

	end;

     end;





add_to_list:
     proc (p, q);

/* add the item specified by p to	*/
/* the list specified by q		*/

declare	(p, q)		ptr;







	p -> list_link.next = null ();

	if q -> list_def.count = 0
	then do;
		q -> list_def.count = 1;
		q -> list_def.first, q -> list_def.last = p;
	     end;
	else do;
		q -> list_def.count = q -> list_def.count + 1;
		q -> list_def.last -> list_link.next, q -> list_def.last = p;
	     end;

     end;

tree_to_qual:
     proc (p, q);

/* transform a tree node specified by p		*/
/* into a qualified name table, store loc of	*/
/* the qualified name table in q. Set q = null()	*/
/* if no qualif name defined			*/

declare	(p, q)		ptr;
declare	r		ptr,
	i		fixed bin;

/* count comps in qualif name */

	r = p;
	qual_name_size = 0;

	do while (r ^= null ());

	     if r -> root.rt_name_ptr ^= null ()
	     then qual_name_size = qual_name_size + 1;

	     r = r -> root.rt_up;

	end;

	if qual_name_size = 0
	then do;
		q = null ();

		return;

	     end;

	call get_space (size (qual_name), qual_name_ptr);

	qual_name.qn_size = qual_name_size;

	r = p;

	i = 1;

	do while (r ^= null ());

	     if r -> root.rt_name_ptr ^= null ()
	     then do;
		     qual_name.qn_loc (i) = r -> root.rt_name_ptr;

		     i = i + 1;

		end;

	     r = r -> root.rt_up;

	end;

	q = qual_name_ptr;

     end;




declare	program		(36) ptr based (directory_ptr);

declare	1 fd_object	based (fd_object_ptr),
	  2 next		ptr,
	  2 loc		ptr,
	  2 rep_loc	ptr;

declare	fd_object_ptr	ptr;

declare	1 use_reporting_object
			based (use_reporting_object_ptr),
	  2 next		ptr,
	  2 loc		ptr,
	  2 proc_loc	ptr,
	  2 suppress	bit (1);

declare	use_reporting_object_ptr
			ptr;

declare	1 use_table	based (use_table_ptr),
	  2 use_size	fixed bin,
	  2 use		(use_table_size refer (use_table.use_size)),
	    3 comp_count	fixed bin,
	    3 usage_count	fixed bin,
	    3 gnl		fixed bin,
	    3 rnl		fixed bin,
	    3 gn_loc	ptr,
	    3 rn_loc	ptr,
	    3 proc_loc	ptr,
	    3 suppress	bit (1);

declare	use_table_ptr	ptr;
declare	use_table_size	fixed bin;

declare	cobol_output_tokens$directory_loc
			entry returns (ptr);

declare	directory_ptr	ptr;
declare	TAB_pos		fixed bin,
	TAB_res		bit (1),
	TAB_ptr		ptr,
	TABTAB_pos	fixed bin;
declare	uwl		fixed bin,
	uw		char (32);
declare	(fd_table_ptr, rep_clause_table_ptr, rep_table_ptr, rd_table_ptr)
			ptr;

process_report_clauses:
     proc;

	directory_ptr = cobol_output_tokens$directory_loc ();


	if program (24) ^= null ()
	then call form_fd_table;
	rwfp = cobol_m2fp;
	call cobol_io_$cobol_save_pos (rwfp2, rwfp2);
	call form_use_table;
	rwfp = cobol_m1fp;
	call cobol_io_$cobol_msf_start (cobol_m2fp, rwfp2);
	call tabtab_to_tab (rep_clause_table_ptr, rep_table_ptr);
	call are_tab_nams_unique (rep_table_ptr, 38);

	if program (22) ^= null ()
	then call form_name_table (program (22), rd_table_ptr);

	call find_rep_names;

	use_table_size = 0;

	call find_file_and_use;

     end;

form_name_table:
     proc (chain_ptr, table_ptr);			/* construct a name table (table_ptr)	*/
						/* from a name chain (chain_ptr)	*/

declare	(chain_ptr, table_ptr)
			ptr;
declare	i		fixed bin;

	if chain_ptr = null ()
	then return;

	list_link_ptr = chain_ptr;
	qual_name_size = 0;

	do while (list_link_ptr ^= null ());		/* find the size of the table */

	     qual_name_size = qual_name_size + 1;
	     list_link_ptr = list_link.next;

	end;

	call get_space (size (qual_name), qual_name_ptr); /* allocate space for the table */
	qual_name.qn_size = qual_name_size;
	list_link_ptr = chain_ptr;

	do i = 1 by 1 to qual_name_size;		/* initialize the table */

	     call get_token (list_link.loc);
	     qual_name.qn_loc (i) = addr_record;
	     list_link_ptr = list_link.next;

	end;

	table_ptr = qual_name_ptr;

     end;

are_tab_nams_unique:
     proc (table_ptr, diag_num);			/* if a non-unique name is found in the		*/
						/* table (table_ptr) then issue a diagnostic	*/
						/* (diag_num)				*/
declare	table_ptr		ptr,
	diag_num		fixed bin;
declare	(line, col)	fixed bin;

	qual_name_ptr = table_ptr;

	if qual_name.qn_size < 2
	then return;

	do TAB_pos = 2 by 1 to qual_name.qn_size;

	     addr_record = qual_name.qn_loc (TAB_pos);
	     uwl = user_word.length;
	     line = user_word.line;
	     col = user_word.column;
	     substr (uw, 1, uwl) = user_word.word;

	     call dup_test;

	     if TAB_res
	     then call DIAG (diag_num, line, col);

	end;
     end;

dup_test:
     proc;

declare	i		fixed bin;

	TAB_res = "0"b;

	do i = TAB_pos - 1 by -1 to 1;

	     addr_record = qual_name.qn_loc (i);

	     if uwl = user_word.length
	     then if substr (uw, 1, uwl) = user_word.word
		then do;
			TAB_res = "1"b;
			return;
		     end;
	end;
     end;

tabtab_to_tab:
     proc (tabtab_ptr, tab_ptr);

declare	(tabtab_ptr, tab_ptr)
			ptr;
declare	(i, j, k)		fixed bin,
	p		ptr;

	qual_name_size = 0;
	qual_name_ptr = tabtab_ptr;

/* compute size of table */


	do i = 1 by 1 to qual_name.qn_size;


	     p = qual_name.qn_loc (i);

	     if p ^= null ()
	     then qual_name_size = qual_name_size + p -> qual_name.qn_size;

	end;

/* allocate space for table */

	call get_space (size (qual_name), tab_ptr);
	tab_ptr -> qual_name.qn_size = qual_name_size;

/* initialize the table */

	k = 1;
	do i = 1 by 1 to qual_name.qn_size;

	     p = qual_name.qn_loc (i);
	     if p ^= null ()
	     then do j = 1 by 1 to p -> qual_name.qn_size;

		     tab_ptr -> qual_name.qn_loc (k) = p -> qual_name.qn_loc (j);
		     k = k + 1;

		end;
	end;
     end;

is_nam_in_tab:
     proc (table_ptr);				/* is name specified by (uwl,uw)	*/
						/* in table (table_ptr)		*/
declare	table_ptr		ptr;
declare	i		fixed bin,
	p		ptr;

	TAB_pos = 0;
	qual_name_ptr = table_ptr;

	do i = 1 by 1 to qual_name.qn_size;

	     p = qual_name.qn_loc (i);

/* compare the names */

	     if uwl = p -> user_word.length
	     then if substr (uw, 1, uwl) = p -> user_word.word
		then do;
			TAB_pos = i;
			return;
		     end;
	end;
     end;

form_fd_table:
     proc;

/* form the fd table */

	call form_name_table (program (24), fd_table_ptr);/* table of pointers to FD names */

/* table of pointers to report clause descriptors */
	qual_name_size = fd_table_ptr -> qual_name.qn_size;
	call get_space (size (qual_name), rep_clause_table_ptr);
	rep_clause_table_ptr -> qual_name.qn_size = qual_name_size;
	fd_object_ptr = program (24);

	do TAB_pos = 1 by 1 to qual_name_size;

	     if fd_object.rep_loc ^= null ()
	     then call form_rep_table;
	     else qual_name_ptr = null ();

	     rep_clause_table_ptr -> qual_name.qn_loc (TAB_pos) = qual_name_ptr;

	     fd_object_ptr = fd_object.next;

	end;
     end;

form_rep_table:
     proc;

/* form the rd table */

declare	i		fixed bin;

	call get_token (fd_object.rep_loc);		/* position to rep name seq */
	if header.type = 1
	then call scan;

	qual_name_size = 0;

	do while (header.type = 8);			/* count the rep names */

	     qual_name_size = qual_name_size + 1;
	     call scan;

	end;

	if qual_name_size = 0
	then return;

	call get_space (size (qual_name), qual_name_ptr); /* allocate space */
	qual_name.qn_size = qual_name_size;

	call get_token (fd_object.rep_loc);		/* position to rep name seq */
	if header.type = 1
	then call scan;

	do i = 1 by 1 to qual_name_size;

	     qual_name.qn_loc (i) = addr_record;
	     call scan;
	end;
     end;

first_token:
     proc (ft);

declare	ft		ptr;

	call cobol_io_$cobol_msf_start (rwfp, ft);
	call scan;
     end;

get_token:
     proc (type_ptr);

declare	type_ptr		ptr;

	call first_token (type_ptr);
	if header.type ^= 1
	then return;

	call scan;

     end;

form_use_table:
     proc;

/* form the use before reporting table */

declare	i		fixed bin;

	use_reporting_object_ptr = program (25);
	use_table_size = 0;				/* get size of table */

	do while (use_reporting_object_ptr ^= null ());

	     use_table_size = use_table_size + 1;
	     use_reporting_object_ptr = use_reporting_object.next;

	end;

/* allocate space for table */

	call get_space (size (use_table), use_table_ptr);
	use_table.use_size = use_table_size;

	use_reporting_object_ptr = program (25);
	if use_table_size ^= 0
	then do TAB_pos = 1 by 1 to use_table_size;

		call get_use_name;
		use_table.usage_count (TAB_pos) = 0;
		use_table.proc_loc (TAB_pos) = use_reporting_object.proc_loc;
		use_table.suppress (TAB_pos) = use_reporting_object.suppress;

		use_reporting_object_ptr = use_reporting_object.next;

	     end;
     end;

get_use_name:
     proc;

/* find a qualified group name */
	use_table.comp_count (TAB_pos) = 0;
	call cobol_io_$cobol_msf_start (rwfp, use_reporting_object.loc);
	if header.type = 1
	then call scan;
	call scan;
	if header.type ^= 8
	then return;

/* group name */

	use_table.gnl (TAB_pos) = user_word.length;
	use_table.gn_loc (TAB_pos) = addr_record;
	use_table.comp_count (TAB_pos) = 1;

	call scan;
	if header.type ^= 1
	then return;

	if reserved_word.key ^= 101 /* in */ & reserved_word.key ^= 133
						/* of */
	then return;

	call scan;
	if header.type ^= 8
	then return;

/* report name */

	use_table.rnl (TAB_pos) = user_word.length;
	use_table.rn_loc (TAB_pos) = addr_record;
	use_table.comp_count (TAB_pos) = 2;

     end;

find_file_and_use:
     proc;

declare	i		fixed bin;

	current_report_loc = report_list.first;

	do while (current_report_loc ^= null ());

/* find the report file */

	     call find_file;

/* find the use before reporting sections */

	     if report.rh ^= null ()
	     then call find_use (report.rh);
	     if report.rf ^= null ()
	     then call find_use (report.rf);
	     if report.ph ^= null ()
	     then call find_use (report.ph);
	     if report.pf ^= null ()
	     then call find_use (report.pf);
	     de_table_ptr = report.de;

	     if de_table_ptr ^= null ()
	     then do i = 1 by 1 to de_table.det_size;

		     if de_table.det_loc (i) ^= null ()
		     then call find_use (de_table.det_loc (i));

		end;

	     ch_table_ptr = report.ch;

	     if ch_table_ptr ^= null ()
	     then do i = 0 by 1 to ch_table.ch_size;

		     if ch_table.ch_loc (i) ^= null ()
		     then call find_use (ch_table.ch_loc (i));

		end;

	     cf_table_ptr = report.cf;

	     if cf_table_ptr ^= null ()
	     then do i = 0 by 1 to cf_table.cf_size;

		     if cf_table.cf_loc (i) ^= null ()
		     then call find_use (cf_table.cf_loc (i));

		end;
	     current_report_loc = report.rep_next;
	end;
     end;
find_rep_names:
     proc;					/* see if names in the reports are clauses	*/
						/* also appear in an RD clause		*/
declare	(line, col)	fixed bin;

	do TABTAB_pos = 1 by 1 to rep_table_ptr -> qual_name.qn_size;

	     TAB_ptr = rep_table_ptr -> qual_name.qn_loc (TABTAB_pos);

	     uwl = TAB_ptr -> user_word.length;
	     substr (uw, 1, uwl) = TAB_ptr -> user_word.word;
	     line = TAB_ptr -> user_word.line;
	     col = TAB_ptr -> user_word.column;

	     call is_nam_in_tab (rd_table_ptr);

	     if TAB_pos = 0
	     then call DIAG (37, line, col);

	end;
     end;

find_use:
     proc (p);					/* see if a group name appears in the	*/
						/* use  before reporting table	*/
declare	p		ptr;
declare	(line, col, use_count)
			fixed bin;

	if use_table.use_size = 0
	then return;

	rt_ptr = p;
	line = root.rt_tok_line;
	col = root.rt_tok_column;
	use_count = 0;
	if root.rt_name_ptr = null ()
	then return;
	do TAB_pos = 1 by 1 to use_table.use_size;

	     call compare_use_name;

	     if TAB_res
	     then do;
		     use_count = use_count + 1;
		     use_table.usage_count (TAB_pos) = use_table.usage_count (TAB_pos) + 1;

		     if use_count = 1
		     then do;
			     root.use_proc.use_proc_name_ptr = use_table.proc_loc (TAB_pos);
			     root.use_proc.suppress = use_table.suppress (TAB_pos);
			end;
		     else do;
			     call DIAG (61, line, col);
			     return;
			end;

		end;
	end;
     end;

compare_use_name:
     proc;

declare	comp_count	fixed bin;

	TAB_res = "0"b;
	comp_count = use_table.comp_count (TAB_pos);

	if comp_count = 1
	then call comp_group_name;
	else if comp_count = 2
	then do;
		call comp_group_name;

		if ^TAB_res
		then return;

		TAB_res = "0"b;
		call comp_rep_name;
	     end;
     end;

comp_group_name:
     proc;

declare	gnl		fixed bin;

	gnl = use_table.gnl (TAB_pos) - 1;

	if gnl = root.rt_name_ptr -> user_word.length
	then if substr (use_table.gn_loc (TAB_pos) -> user_word.word, 2, gnl) = root.rt_name_ptr -> user_word.word
	     then TAB_res = "1"b;
     end;

comp_rep_name:
     proc;

declare	rnl		fixed bin;

	rnl = use_table.rnl (TAB_pos);

	if rnl = report.rep_name_ptr -> user_word.length
	then if substr (use_table.rn_loc (TAB_pos) -> user_word.word, 1, rnl) = report.rep_name_ptr -> user_word.word
	     then TAB_res = "1"b;
     end;

find_file:
     proc;

/* find name of file used	*/
/* by the report		*/

declare	i		fixed bin,
	(p, q)		ptr;

	uwl = report.rep_name_ptr -> user_word.length;
	substr (uw, 1, uwl) = report.rep_name_ptr -> user_word.word;
	q = rep_clause_table_ptr;

	do i = 1 by 1 to q -> qual_name.qn_size;

	     p = q -> qual_name.qn_loc (i);		/*[5.1-1]*/
	     if p ^= null ()
	     then call is_nam_in_tab (p);
	     else TAB_pos = 0;

	     if TAB_pos ^= 0
	     then do;
		     report.file_name = fd_table_ptr -> qual_name.qn_loc (i);
		     return;
		end;
	end;

	call DIAG (108, report.rep_tok_line, report.rep_tok_column);
     end;




declare	ioa_$rsnnl	entry options (variable);

form_sum_name:
     proc;

declare	sum_number	char (4),
	sum_number_size	fixed bin;

	call ioa_$rsnnl ("^d", sum_number, sum_number_size, sum_ctr_ctr);

	call get_space (user_word_size, user_word_ptr);

	user_word_ptr -> user_word.size = user_word_size;
	user_word_ptr -> user_word.line = NODE.nd_tok_line;
	user_word_ptr -> user_word.column = NODE.nd_tok_column;
	user_word_ptr -> user_word.type = 8;
	user_word_ptr -> user_word.length = sum_number_size + 4;
	user_word_ptr -> user_word.word = "SUM-" || substr (sum_number, 1, sum_number_size);

	NODE.nd_name_ptr = user_word_ptr;

     end;







declare	bit12		bit (12) based;

declare	non_term_node_line_bits
			bit (non_term_node_line_size) based (NODE_line_ptr);
declare	term_node_line_bits bit (term_node_line_size) based (NODE_line_ptr);
declare	def_entry_bits	bit (def_entry_size) based (def_entry_ptr);

/* report description chain */


declare	1 report_list	like list_def;








declare	last_root_ptr	ptr;






declare	1 NODE,					/* current node data */
	  2 nd_name_ptr	ptr,
	  2 control_name_ptr
			ptr,
	  2 nd_tok_line	fixed bin,
	  2 nd_tok_column	fixed bin,
	  2 nd_level	fixed bin,
	  2 node_type	fixed bin,
	  2 next_group,
	    3 value	fixed bin,
	    3 type	fixed bin,
	  2 line,
	    3 value	fixed bin,
	    3 type	fixed bin,
	  2 usage_disp	bit (1) unal,
	  2 blank_zero	bit (1) unal,
	  2 group_ind	bit (1) unal,
	  2 just_right	bit (1) unal,
	  2 reset		bit (1) unal,
	  2 non_num	bit (1) unal,
	  2 sign		fixed bin (4) unal unsigned,
	  2 data_type	fixed bin (2) unal unsigned,
	  2 g_i_count	fixed bin,
	  2 rep_sum_ptr	ptr,
	  2 column,
	    3 value	fixed bin,
	    3 type	fixed bin,
	  2 picture	ptr,
	  2 nd_loc	ptr,
	  2 rep_group_ptr	ptr;

declare	1 QUAL_NAME	(50),			/* temp table, comps of qual name */
	  2 QN_loc	ptr;






/* structure sizes */


declare	(root_SIZE, non_term_node_SIZE, term_node_SIZE)
			fixed bin;
declare	(list_def_SIZE, report_SIZE)
			fixed bin;
declare	list_link_SIZE	fixed bin;
declare	(ht_entry_SIZE, def_entry_SIZE, fatal_no)
			fixed bin;

declare	integer_spec_size	fixed bin;
declare	(non_term_node_line_size, term_node_line_size)
			fixed bin;

declare	cobol$alloc	entry (fixed bin) returns (ptr);




declare	1 ST,
	  2 st_depth	fixed bin,		/* current structure depth */
	  2 entry		(0:50),			/* current structure table */
	    3 level	fixed bin,		/* level number */
	    3 node_ptr	ptr;			/* loc of node */








declare	1 reserved_word	based (addr_record),
%include cobol_TYPE1;

declare	1 numeric_lit	based (addr_record),
%include cobol_TYPE2;

declare	1 alphanum_lit	based (addr_record),
%include cobol_TYPE3;

%include cobol_fixed_common;
%include cobol_ext_;
%include cobol_report_writer;

     end cobol_report_writer;
