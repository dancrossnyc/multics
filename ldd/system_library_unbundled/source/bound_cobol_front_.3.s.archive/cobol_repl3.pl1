/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_repl3.pl1 Reformatted code to new Cobol standard.
                                                   END HISTORY COMMENTS */


/* Modified on 10/16/79 by MHD, [4.1-1], increase size of key66area to 200 pointers */
/* Modified on 10/16/78 by RAL, [3.0-1], alternate record keys for MR7.0 */
/* Modified on 10/07/77 by GM to fix check on  qualified search  keys */
/* Modified on 10/06/77 by FH  to prevent abort when search key not in table */
/* 9/19/77, FCH, leveling diags added */
/* Modified on 06/01/77 by GM to fix test on catalog name and additional catalog name.	*/
/* Modified on 03/01/77 by Bob Chang to fix the bug for deletion of name table  buffer.	*/
/* Modified on 02/24/77 by Bob Chang to fix the bug rename clause with qualification.	*/
/* Modified on 01/26/77 by ORN to eliminate name table buffer and process directly from name table */
/* Modified on 12/30/76 by ORN to correct bad diag for OCCURS DEP ON range error and clean up fixed bins */
/* Modified on 11/22/76 by ORN to set cobol_$same_sort_merge_proc when applicable */
/* Modified on 11/18/76 by ORN to eliminate cobol_version_unique include file */
/* Modified on 11/16/76 by ORN to distinguish between sort and merge in setting procname.repl_bits */
/* Modified since Version 2.0 */

/* format: style3 */
cobol_repl3:
     proc (mem_size, ntbuff_ptr);

/*  DECLARATIONS OF THE PARAMETERS  */


dcl	mem_size		fixed bin (24);		/*  contains the number of characters allocated to the replacement name table buffer 
		for this execution of replacement  (input)  */

dcl	ntbuff_ptr	ptr;			/*  contains a pointer to the buffer space used by replacement as
		the name table buffer.  (input)  */

dcl	(linage_ptr, name_ptr, ft_ptr, fkey_ptr)
			ptr;
dcl	com2_ptr		ptr;

/*  INTERNAL VARIABLES  */

dcl /*  pointers used in this procedure  */
	(ntptr, ntprevptr, ntshiftptr, ntendptr, auxptr1)
			ptr;

/*  STRING BASE TABLE  */
dcl	arrpntr		(512) ptr;

/*  name stack pointer table  */
dcl	ptrtable		(50) ptr;

dcl	hashno		fixed bin;
dcl	s		fixed bin (24);


dcl	work_ptr		ptr;
dcl	ntptr2		ptr;
dcl	odo_ptr		ptr;

/*  name table buffer  */
dcl	1 anarea		based (ntbuff_ptr),
	  2 dummy_ptr	ptr,
	  2 ntarea	char (64000);
dcl	1 tntarea		based (ntbuff_ptr),
	  2 dumm_ptr	ptr,
	  2 tarea		(64000) char (1);
dcl	1 bit_ntarea	based (ntbuff_ptr),
	  2 dummy_pntr	ptr,
	  2 ntarea_bits	bit (64000);

/*  DECLARATION OF EXTERNAL ENTRIES  */
dcl	ioa_		entry options (variable);	/* [3.0-1] */
dcl	cobol_usrwd	entry (ptr, fixed bin, ptr, fixed bin, ptr, bit (1), bit (1), bit (1), fixed bin, ptr);
dcl	(diag_no, diag_count, sectno, ln, counter, topstack)
			fixed bin;
dcl	(stackptr, stackbegptr)
			ptr;
dcl	(name_stack_overflow, too_many_qualifiers, was_found, not_found)
			bit (1);
dcl	cobol_replb	entry (ptr, ptr);

dcl	1 procname	based (ntptr),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 string_ptr	pointer,
	  2 prev_rec	pointer,
	  2 info1		bit (1),
	  2 info2		bit (1),
	  2 info3		bit (1),
	  2 info4		bit (1),
	  2 info5		bit (1),
	  2 info6		bit (1),
	  2 info7		bit (1),
	  2 info8		bit (1),
	  2 priority	char (2),
	  2 repl_bits	bit (8),
	  2 section_num	fixed bin,
	  2 proc_num	fixed bin,
	  2 def_line	fixed bin,
	  2 length	fixed bin,
	  2 name		char (30),
	1 data_name	based (ntptr),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 string_ptr	pointer,
	  2 prev_rec	pointer,
	  2 info1		bit (1),
	  2 info2		bit (1),
	  2 info3		bit (1),
	  2 info4		bit (5),
	  2 def_line	fixed bin,
	  2 level		fixed bin,
	  2 linkage	fixed bin,
	  2 file_num	fixed bin,
	  2 size_rtn	fixed bin,
	  2 length	fixed bin (24),
	  2 places_left	fixed bin,
	  2 places_right	fixed bin,
	  2 descr_bit	bit (64),
	  2 descr1	bit (8),
	  2 seg_num	fixed bin,
	  2 offset	fixed bin (24),
	  2 init_ptr	fixed bin,
	  2 edit_ptr	fixed bin,
	  2 occurs_ptr	fixed bin,
	  2 do_rec	char (5),
	  2 do_bit	bit (8),
	  2 max_red_size	fixed bin (24),
	  2 name_size	fixed bin,
	  2 name		char (30);




dcl	save_last_line	fixed bin;
dcl	save_last_column	fixed bin;
dcl	repla_abort	bit (1);

dcl	1 adiag		int static,
	  2 size		fixed bin init (28),
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin init (5),
	  2 run_number	fixed bin init (6),
	  2 diag_number	fixed bin,
	  2 info		bit (8) init ("00000000"b);
dcl	1 temp_fld	based (ntptr),
	  2 tempfld1	char (44),
	  2 temp_desc	char (40),
	  2 tempfld2	char (62);
dcl	curr_work		ptr;
dcl	stack		char (1000);
dcl	temp_stack	(1000) char (1) based (addr (stack));

dcl	addr		builtin;
dcl	addrel		builtin;
dcl	divide		builtin;
dcl	fixed		builtin;
dcl	mod		builtin;
dcl	null		builtin;
dcl	substr		builtin;
dcl	unspec		builtin;

dcl	(i, n, n1)	fixed bin;
dcl	bname		char (30);
dcl	cn1		char (4);
dcl	template		char (recsize) based (ntptr);
dcl	null_key		char (5) static options (constant) init ("00000");
dcl	cobol_c_list	entry (ptr);
dcl	cobol_read_ft_	entry (fixed bin, ptr);
dcl	continue		bit (1);			/* [3.0-1] */
dcl	type_two_sw	bit (1);			/* [3.0-1] */
dcl	file_desc_1_area	char (4200);		/* [3.0-1] */
dcl	1 file_info	based (fkey_ptr),		/* [3.0-1] */
	  2 fill1		char (16),
	  2 file_no	fixed bin,
	  2 type		fixed bin,
	  2 fill2		char (28),
	  2 size		fixed bin (24),
	  2 fill3		char (16),
	  2 seg_num	fixed bin,
	  2 offset	fixed bin (24);


/*************************************/
start:
	file_desc_1_ptr = addr (file_desc_1_area);	/* [3.0-1] */
	stackbegptr = addr (stack);
	mcobol = "1"b;
	mcobol_xref = fixed_common.options.xrn;
	if mcobol_xref
	then do;
		cobol_$xref_bypass = "0"b;
		token_count = 0;
		chain_count = 0;
	     end;

	if fixed_common.rename_info ^= null_key
	then call repl3a;				/* process renames */

	do i = 1 to 512;
	     arrpntr (i) = null ();
	end;
	ntprevptr = null ();
	status = ""b;
	do while (status = ""b);			/* until end of file */
	     call cobol_vdwf_sget (cobol_ext_$cobol_name_fileno_ptr, status, ntptr, recsize, key1);
	     if status = ""b
	     then do;
		     xref_ptr = addrel (ntptr, divide (recsize + 3, 4, 17, 0));
		     xref_ptr -> xref_chain.first = 0;
		     xref_ptr -> xref_chain.last = 0;
		     data_name.info1 = "0"b;
		     data_name.info2 = "0"b;
		     data_name.info3 = "0"b;
		     if procname.type ^= 7
		     then do;
			     data_name.info4 = "0"b;
			end;
		     else do;
			     procname.type = 18;
			     procname.repl_bits = "00000000"b;
			end;
		     n = size_TOKEN (procname.type) - 3;
		     if mcobol_xref
		     then do;
			     token_count = token_count + 1;
			     token_area.token_ptr (token_count) = ntptr;
			     token_area.name_ptr (token_count) = addrel (ntptr, divide (n, 4, 17, 0));
			end;			/* string name table entry */
		     cn1 = substr (template, n, 4);
		     n1 = fixed (unspec (cn1));
		     bname = substr (template, n + 4, n1);
		     hashno = 0;
		     do i = 1 to n1;
			hashno = hashno + fixed (unspec (substr (bname, i, 1)));
		     end;
		     hashno = mod (hashno, 512) + 1;
		     procname.string_ptr = arrpntr (hashno);
		     procname.prev_rec = ntprevptr;
		     arrpntr (hashno) = ntptr;
		     ntprevptr = ntptr;
		     ntptr = addrel (ntptr, divide (recsize + 11, 8, 17, 0) * 2);
		end;
	     else ntendptr = addrel (ntptr, divide (recsize + 11, 8, 17, 0) * 2);
	end;

	if fixed_common.linage_info ^= null_key
	then call repl3ln;				/* process linage info */
	if fixed_common.odo_info ^= null_key
	then call process_odo_keys;
	if fixed_common.file_keys ^= null_key
	then call process_file_keys;
	if fixed_common.search_keys ^= null_key
	then call repl3sk;
	if fixed_common.sort_in_info ^= null_key
	then call repl3s (fixed_common.sort_in_info, "1"b);
	if fixed_common.sort_out_info ^= null_key
	then call repl3s (fixed_common.sort_out_info, "0"b);

	call cobol_replb (ntendptr, addr (arrpntr (1)));

	return;

/*************************************/
repl3a:
     proc;
dcl	cm_ptr		ptr;
dcl	(key, next_key, prev_key)
			char (5);
dcl	1 auser_wd	based (stackptr),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 info_bit	bit (8),
	  2 length	fixed bin,
	  2 name		char (30);
dcl	rename_tempsize	fixed bin;
dcl	rename_tempname	char (30);
dcl	recsize2		fixed bin;
dcl	obj2_key		char (5);
dcl	(obj1_level, obj2_level, obj1_length, obj2_length, obj1_seg_num, obj1_offset, obj2_offset, obj1_name_size)
			fixed bin;
dcl	(obj1_init_ptr, obj1_edit_ptr, obj1_pleft, obj1_pright)
			fixed bin;
dcl	extension_bit	bit (1);
dcl	extension_size	fixed bin;
dcl	extension_temp	char (434);
dcl	n		fixed bin;
dcl	template		char (recsize) based (ntptr);
dcl	(obj1_descr_bit, obj2_descr_bit)
			bit (64);
dcl	obj1_flag		bit (1);
dcl	(obj1ptr, obj2ptr, rename_ptr)
			ptr;
dcl	key66_area	char (1000);		/*[4.1-1]*/
dcl	k66area		(1000) char (1) based (addr (key66_area));
dcl	keyvalue		char (5) based (key66ptr);
dcl	key66ptr		ptr;
dcl	n66		fixed bin;

	obj1_flag = "0"b;
	prev_key = null_key;			/* Get first rename_rec in common */
	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, cm_ptr, ln, fixed_common.rename_info);
la:
	com2_ptr = cm_ptr;
	next_key = rename_rec.next;
	key = rename_rec.rec_no_66;
	obj2_key = rename_rec.obj2;
	rename_tempsize = rename_rec.size;
	substr (rename_tempname, 1, rename_tempsize) = rename_rec.name;

/* Loading name_table buff */
	if key ^= prev_key
	then do;
		key66ptr = addr (key66_area);
		n66 = 1;
		call load_01_66;
	     end;

/* Get object_1 of the rename in common */

	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, cm_ptr, ln, rename_rec.obj1);
	obj1_flag = "1"b;
la1:
	counter = 0;
	topstack = 1;
	stackptr = stackbegptr;
	name_stack_overflow = "0"b;
	too_many_qualifiers = "0"b;
	com2_ptr = cm_ptr;
	auser_wd.length = obj_rec.size;
	substr (auser_wd.name, 1, auser_wd.length) = substr (obj_rec.name, 1, auser_wd.length);
	recsize2 = 24 + auser_wd.length;

/* push name into stack */

	call pushx;
	if obj_rec.qual = null_key
	then go to lb1;

/* Get qualifier of rename object in common */

	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, cm_ptr, ln, obj_rec.qual);
la2:
	com2_ptr = cm_ptr;
	stackptr = addr (temp_stack (topstack));
	auser_wd.length = qual_rec.size;
	substr (auser_wd.name, 1, auser_wd.length) = substr (qual_rec.name, 1, auser_wd.length);
	recsize2 = 24 + auser_wd.length;
	topstack = topstack + recsize2 + 8 - mod (recsize2, 8);
	counter = counter + 1;
	ptrtable (counter) = stackptr;
	if qual_rec.next = null_key
	then go to lb1;

/* Get next qualifier in common */

	call cobol_vdwf_sget (cobol_ext_$cobol_cmfp, status, cm_ptr, ln, qual_rec.next);
	go to la2;

lb1:						/* Look up object of rename in name table buff */
	call cobol_usrwd (addr (ptrtable (1)), counter, addr (arrpntr (1)), sectno, ntendptr, "0"b, was_found,
	     not_found, diag_no, ntptr2);
	if was_found
	then do;
		ntptr = ntptr2;
		if substr (data_name.descr_bit, 42, 1) | substr (data_name.descr1, 2, 1)
		then do;
			adiag.diag_number = 26;
			adiag.line = data_name.line;
			adiag.column = data_name.column;
			call issue_diag;
		     end;
		if obj1_flag
		then do;
			obj1_level = data_name.level;
			obj1_length = data_name.length;
			obj1_seg_num = data_name.seg_num;
			obj1_offset = data_name.offset;
			obj1_descr_bit = data_name.descr_bit;
			obj1_pleft = data_name.places_left;
			obj1_pright = data_name.places_right;
			if substr (data_name.descr_bit, 10, 1) & obj2_key = null_key
			then do;			/* only elementary item with init or edit extension needs  processing */
				if data_name.init_ptr ^= 0 | data_name.edit_ptr ^= 0
				then do;
					extension_bit = "1"b;
					obj1_name_size = data_name.name_size;
					obj1_init_ptr = data_name.init_ptr;
					obj1_edit_ptr = data_name.edit_ptr;
					if obj1_init_ptr ^= 0
					then do;
						extension_size = data_name.size - obj1_init_ptr;
						extension_temp =
						     substr (template, obj1_init_ptr, extension_size);
					     end;
					else do;
						extension_size = data_name.size - obj1_edit_ptr;
						extension_temp =
						     substr (template, obj1_edit_ptr, extension_size);
					     end;
				     end;
			     end;
		     end;
		else do;
			obj2_level = data_name.level;
			obj2_length = data_name.length;
			obj2_offset = data_name.offset;
			obj2_descr_bit = data_name.descr_bit;
		     end;
	     end;
	else do;
		if diag_no = 0
		then adiag.diag_number = 2;
		else adiag.diag_number = diag_no;
		adiag.line = obj_rec.line;
		adiag.column = obj_rec.column;
		call issue_diag;
	     end;
	if obj2_key = null_key
	then go to lc1;

/* Get object_2 of rename in common */

	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, cm_ptr, ln, obj2_key);
	obj2_key = null_key;
	obj1_flag = "0"b;
	go to la1;
lc1:
	counter = 0;
	topstack = 1;
	stackptr = stackbegptr;
	name_stack_overflow = "0"b;
	too_many_qualifiers = "0"b;
	auser_wd.length = rename_tempsize;
	substr (auser_wd.name, 1, rename_tempsize) = substr (rename_tempname, 1, rename_tempsize);
	recsize2 = 24 + auser_wd.length;
	call pushx;

/* Look up 66 in name table buff */

	call cobol_usrwd (addr (ptrtable (1)), counter, addr (arrpntr (1)), sectno, ntendptr, "0"b, was_found,
	     not_found, diag_no, ntptr2);
	if was_found
	then do;
		ntptr = ntptr2;
		if obj1_level = 01 | obj1_level > 49
		then do;
			adiag.diag_number = 27;
			adiag.line = data_name.line;
			adiag.column = data_name.column;
			call issue_diag;
		     end;
		if obj1_flag
		then do;
			data_name.length = obj1_length;
			data_name.seg_num = obj1_seg_num;
			data_name.offset = obj1_offset;
			data_name.descr_bit = obj1_descr_bit;
			data_name.places_left = obj1_pleft;
			data_name.places_right = obj1_pright;
			if extension_bit = "1"b
			then do;
				extension_bit = "0"b;
				n = size_TOKEN (9) + 1 + data_name.name_size;
				n = n + 4 - mod (n, 4);
				n = n + 1;
				if obj1_init_ptr ^= 0
				then data_name.init_ptr = n;
				if obj1_edit_ptr ^= 0
				then data_name.edit_ptr = n;
				substr (template, n, extension_size) = substr (extension_temp, 1, extension_size);
			     end;
		     end;
		else do;
			if obj2_level = 01 | obj2_level > 49
			then do;
				adiag.diag_number = 27;
s_diag:
				adiag.line = data_name.line;
				adiag.column = data_name.column;
				call issue_diag;
				go to s_exit;
			     end;
			if obj1_offset ^< obj2_offset
			then do;

				adiag.diag_number = 28;
				go to s_diag;
			     end;
			data_name.seg_num = obj1_seg_num;
			data_name.offset = obj1_offset;
			data_name.length = obj2_offset - obj1_offset + obj2_length;
			substr (data_name.descr_bit, 1, 6) = substr (obj1_descr_bit, 1, 6);
			substr (data_name.descr_bit, 9, 1) = "1"b;
			substr (data_name.descr_bit, 20, 1) = "1"b;
s_exit:
		     end;
	     end;
	else do;
		if diag_no = 0
		then adiag.diag_number = 2;
		else adiag.diag_number = diag_no;
		adiag.line = data_name.line;
		adiag.column = data_name.column;
		call issue_diag;
		obj1_flag = "0"b;
		go to s_recover;
	     end;
	recsize = data_name.size;
	call cobol_vdwf_dput (cobol_ext_$cobol_name_fileno_ptr, status, ntptr, recsize, keyvalue);
s_recover:
	n66 = n66 + 5;
	key66ptr = addr (k66area (n66));
	if next_key = null_key
	then go to lc2;
	prev_key = key;

/* Get next rename in  common */

	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, cm_ptr, ln, next_key);
	go to la;
lc2:
	call cobol_vdwf_close (cobol_ext_$cobol_name_fileno_ptr, status, ntptr, 0);
	call cobol_vdwf_open (cobol_ext_$cobol_name_fileno_ptr, status);

/* Clear the name table buffer area if mcobol_xref, so cross-reference info
	   at end of each name table buffer entry will initially be zero. */

	if mcobol_xref
	then substr (ntarea_bits, 1, 9 * s) = "0"b;

	return;
pushx:
     proc;
	stackptr = addr (temp_stack (topstack));
	topstack = topstack + recsize2 + 8 - mod (recsize2, 8);
	counter = counter + 1;
	ptrtable (counter) = stackptr;
     end pushx;

load_01_66:
     proc;
dcl	template		char (recsize) based (ntptr),
	newrecord		char (recsize) based (ptr1),
	(i, n, n1, n2)	fixed bin,
	bname		char (30),
	levlim		fixed bin,
	tb_counter	fixed bin,
	ptr1		ptr,
	flag_66		bit (1);

	flag_66 = "0"b;
	s = 1;
	do i = 1 to 512;
	     arrpntr (i) = null ();
	end;

	ntptr = addr (ntarea);
	ntprevptr = null ();
	ntshiftptr = ntptr;
l2:
	call cobol_vdwf_dget (cobol_ext_$cobol_name_fileno_ptr, status, ntptr, recsize, key);

l3:						/* stringnt */
	n = size_TOKEN (procname.type) - 3;
	cn1 = substr (template, n, 4);
	n1 = fixed (unspec (cn1), 15);

	bname = substr (template, n + 4, n1);

	hashno = 0;
	do i = 1 to n1;
	     hashno = hashno + fixed (unspec (substr (bname, i, 1)), 15);
	end;
	hashno = mod (hashno, 512) + 1;
	procname.string_ptr = arrpntr (hashno);
	procname.prev_rec = ntprevptr;
	ntprevptr = ntptr;
	arrpntr (hashno) = ntptr;
	levlim = data_name.level;
	if levlim = 66
	then do;
		flag_66 = "1"b;
		key66ptr = addr (k66area (n66));
		keyvalue = key1;
		n66 = n66 + 5;
	     end;					/* stringnt */
	call cobol_vdwf_sget (cobol_ext_$cobol_name_fileno_ptr, status, ntptr, recsize, key1);
	if status ^= "0"b
	then go to finish_up;

	if flag_66
	then do;
		if levlim ^= 66
		then go to finish_up;
	     end;
	go to l3;
finish_up:
	ntendptr = addrel (ntptr, divide (recsize + 11, 8, 17, 0) * 2);
	ntptr = addr (ntarea);
end1:
	key66ptr = addr (key66_area);
	n66 = 1;
	return;
     end load_01_66;
     end repl3a;


/* This procedure processes sort information */

repl3s:
     proc (sort_info_key, input_proc);

dcl	sort_info_key	char (5);
dcl	input_proc	bit (1);
dcl	sortnext		char (5);
dcl	start_name	char (30);
dcl	fill_sort_info	bit (1);
dcl	not_done		bit (1);
dcl	stop_sec_num	fixed bin;
dcl	template		(200) char (1) based (work_ptr);
dcl	snamearea		char (56);
dcl	srtptr		ptr;
dcl	1 srtname		based (srtptr),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 bit8		bit (8),
	  2 slength	fixed bin,
	  2 sname		char (30);

	srtptr = addr (snamearea);
	ptrtable (1) = srtptr;
	sortnext = sort_info_key;
	do while (sortnext ^= null_key);
	     call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, com2_ptr, recsize, sortnext);
	     sortnext = s_ptr;
	     fill_sort_info = ^(s_info1 & s_info2);
	     work_ptr = addr (ntarea);		/* Set work ptr to start of name table buffer. */
	     start_name = " ";
	     stop_sec_num = 32767;			/* phoney high value */
	     if ^s_info1
	     then do;				/* Process start section name. */
		     slength = s_start_size;
		     sname = substr (s_start, 1, slength);
		     start_name = sname;
		     call cobol_usrwd (addr (ptrtable (1)), 1, addr (arrpntr (1)), 0, ntendptr, "1"b, was_found,
			not_found, diag_no, ntptr);
		     if was_found
		     then do;
			     s_info1 = "1"b;
			     work_ptr = ntptr;	/* Set work ptr to start section entry in name table. */
			     s_start_size = procname.section_num;
			end;
		end;
	     if ^s_info2
	     then do;				/* Process stop section name */
		     if s_stop_size = 0
		     then do;
			     s_info2 = "1"b;
			     stop_sec_num = s_start_size;
			end;
		     else do;
			     slength = s_stop_size;
			     sname = substr (s_stop, 1, slength);
			     if sname = start_name
			     then do;
				     s_info2 = "1"b;
				     s_stop_size = s_start_size;
				     stop_sec_num = s_start_size;
				end;
			     else do;
				     call cobol_usrwd (addr (ptrtable (1)), 1, addr (arrpntr (1)), 0, ntendptr,
					"1"b, was_found, not_found, diag_no, ntptr);
				     if was_found
				     then do;
					     s_info2 = "1"b;
					     s_stop_size = procname.section_num;
					     stop_sec_num = s_stop_size;
					end;
				end;
			end;
		end;
	     if ^s_info3
	     then do;				/* Process sort file name. */
		     slength = s_srtfilename_size;
		     sname = substr (s_srtfilename, 1, slength);
		     call cobol_usrwd (addr (ptrtable (1)), 1, addr (arrpntr (1)), 0, ntendptr, "0"b, was_found,
			not_found, diag_no, ntptr);
		     if was_found
		     then do;
			     s_info3 = "1"b;
			     s_srtfilename_size = ntptr -> fd_token.file_no;
			end;
		end;
	     if fill_sort_info
	     then do;
		     not_done = "1"b;
		     do while (not_done);
			if work_ptr -> procname.section_num >= s_start_size
			then do;
				if s_info4
				then substr (work_ptr -> procname.repl_bits, 4, 1) = "1"b;
						/* MERGE */
				else substr (work_ptr -> procname.repl_bits, 1, 1) = "1"b;
						/*-11/16/76-*/
				if input_proc
				then substr (work_ptr -> procname.repl_bits, 2, 1) = "1"b;
				else do;
					substr (work_ptr -> procname.repl_bits, 3, 1) = "1"b;
					if substr (work_ptr -> procname.repl_bits, 1, 1)
					     & substr (work_ptr -> procname.repl_bits, 4, 1)
					then cobol_$same_sort_merge_proc = "1"b;
				     end;
			     end;
			work_ptr = addrel (work_ptr, divide (work_ptr -> procname.size + 11, 8, 17, 0) * 2);
			if work_ptr = ntendptr
			then not_done = "0"b;
			else if work_ptr -> procname.type ^= 18
			then not_done = "0"b;
			else if work_ptr -> procname.section_num > stop_sec_num
			then not_done = "0"b;
		     end;
		end;
	end;

     end repl3s;

repl3sk:
     proc;					/* process search keys */

dcl	skptr		ptr;
dcl	recsize2		fixed bin;
dcl	1 auser_wd	based (stackptr),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 info_bit	bit (8),
	  2 length	fixed bin,
	  2 name		char (30);
dcl	(nextsk, nextocc)	char (5);
dcl	(save_line, save_column)
			fixed bin;
dcl	template		(200) char (1) based (work_ptr);

/* get  search_keys in common */

	nextocc = search_keys;
sklop:
	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, com2_ptr, recsize, nextocc);
	nextocc = occ_key.next;
	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, com2_ptr, recsize, occ_key.first_key);

skloop:
	counter = 0;
	topstack = 1;
	stackptr = stackbegptr;
	name_stack_overflow = "0"b;
	too_many_qualifiers = "0"b;
	save_line = skey_rec.ref_line;
	save_column = skey_rec.ref_column;
	auser_wd.length = skey_rec.size;
	substr (auser_wd.name, 1, auser_wd.length) = substr (skey_rec.name, 1, auser_wd.length);
	recsize2 = 24 + auser_wd.length;
	nextsk = skey_rec.next;



	counter = counter + 1;
	ptrtable (counter) = stackptr;
	topstack = topstack + recsize2 + 8 - mod (recsize2, 8);
	stackptr = addr (temp_stack (topstack));


skloop1:
	if skey_rec.qual = null_key
	then go to skloop3;
	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, com2_ptr, recsize, skey_rec.qual);


skloop2:
	auser_wd.length = qual_rec.size;
	substr (auser_wd.name, 1, auser_wd.length) = substr (qual_rec.name, 1, auser_wd.length);
	recsize2 = 24 + auser_wd.length;
	counter = counter + 1;
	ptrtable (counter) = stackptr;
	topstack = topstack + recsize2 + 8 - mod (recsize2, 8);
	stackptr = addr (temp_stack (topstack));


	if qual_rec.next = null_key
	then go to skloop3;


	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, com2_ptr, recsize, qual_rec.next);
	go to skloop2;


skloop3:
	call cobol_usrwd (addr (ptrtable (1)), counter, addr (arrpntr (1)), sectno, ntendptr, "0"b, was_found,
	     not_found, diag_no, skptr);


	if was_found
	then do;
		if substr (skey_rec.info, 1, 1)
		then do;
			adiag.diag_number = 1;
			adiag.line = save_line;
			adiag.column = save_column;
			call issue_diag;
			go to skloop4;
		     end;
		substr (skey_rec.info, 1, 1) = "1"b;
		ntptr = skptr;
		if asc_dsc = 1
		then substr (data_name.descr_bit, 44, 1) = "1"b;
		else substr (data_name.descr_bit, 45, 1) = "1"b;
						/* later need to test if both bits are on and issue warning diag */

		work_ptr = ntptr;
		if data_name.occurs_ptr ^= 0
		then do;
			work_ptr = addr (template (data_name.occurs_ptr));
			work_ptr -> occurs.key_number = skey_rec.key_number;
		     end;
	     end;
	else do;
		if substr (skey_rec.info, 1, 1)
		then go to skloop4;

		if not_found
		then adiag.diag_number = 2;
		else adiag.diag_number = diag_no;
		adiag.line = save_line;
		adiag.column = save_column;
		call issue_diag;
	     end;

skloop4:
	if nextsk = null_key
	then go to skexit;

	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, com2_ptr, recsize, nextsk);


	go to skloop;

skexit:
	if nextocc ^= null_key
	then go to sklop;

	return;
     end repl3sk;
repl3ln:
     proc;					/* this procedure process linage info */
dcl	1 linage_temp	based (work_ptr),
	  2 body		fixed bin,
	  2 footing	fixed bin,
	  2 top		fixed bin,
	  2 bottom	fixed bin,
	  2 body_int	fixed bin,
	  2 footing_int	fixed bin,
	  2 top_int	fixed bin,
	  2 bottom_int	fixed bin,
	  2 body_name	char (5),
	  2 footing_name	char (5),
	  2 top_name	char (5),
	  2 bottom_name	char (5),
	  2 name_count	fixed bin,
	  2 gen_seg	fixed bin,
	  2 gen_offset	fixed bin (24),
	  2 name_desc	(name_count) char (40);
dcl	1 auser_wd	based (lname_ptr),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 bit8		bit (8),
	  2 length	fixed bin,
	  2 name		char (30);
dcl	lnamearea		char (56);
dcl	(lname_ptr, ntptrln, linage_ptr)
			ptr;
dcl	(save_desc, save_line, save_column)
			fixed bin;
dcl	ln		fixed bin;
dcl	cur_fileno	fixed bin;
dcl	nextln		char (5);
dcl	outkey		char (5);
dcl	temp_in		char (200) based (linage_ptr);
dcl	template		char (200);


	work_ptr = addr (template);
	lname_ptr = addr (lnamearea);
	ptrtable (1) = lname_ptr;


/* get first linage_name_rec in common */

	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, com2_ptr, recsize, fixed_common.linage_info);
	nextln = linage_name_rec.next;
	cur_fileno = linage_name_rec.fileno;
	save_desc = linage_name_rec.desc;
	save_line = linage_name_rec.line;
	save_column = linage_name_rec.column;
	auser_wd.length = linage_name_rec.size;
	auser_wd.name = linage_name_rec.name;


/* get file table */

lloop:
	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, ft_ptr, recsize, filedescr_offsets (cur_fileno));


/* get linage_info of this file */


	outkey = file_table.linage_info;

	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, linage_ptr, ln, file_table.linage_info);

	template = temp_in;

lloop1:
	call cobol_usrwd (addr (ptrtable (1)), 1, addr (arrpntr (1)), sectno, ntendptr, "0"b, was_found, not_found,
	     diag_no, ntptrln);
	if was_found
	then do;
		ntptr = ntptrln;
		if save_desc = 1
		then linage_temp.name_desc (1) = temp_fld.temp_desc;
		else if save_desc = 2
		then linage_temp.name_desc (linage_temp.footing) = temp_fld.temp_desc;
		else if save_desc = 3
		then linage_temp.name_desc (linage_temp.top) = temp_fld.temp_desc;
		else linage_temp.name_desc (linage_temp.bottom) = temp_fld.temp_desc;
		go to lloop2;
	     end;
	else do;
		if not_found
		then adiag.diag_number = fatal_DATANAME_NOT_DECLARED;
		else adiag.diag_number = diag_no;
		adiag.line = save_line;
		adiag.column = save_column;
		call issue_diag;
	     end;
lloop2:
	if nextln ^= null_key
	then do;
		call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, com2_ptr, recsize, nextln);
		nextln = linage_name_rec.next;
		save_desc = linage_name_rec.desc;
		save_line = linage_name_rec.line;
		save_column = linage_name_rec.column;
		auser_wd.length = linage_name_rec.size;
		auser_wd.name = linage_name_rec.name;
		if linage_name_rec.fileno = cur_fileno
		then go to lloop1;
		cur_fileno = linage_name_rec.fileno;
		call cobol_vdwf_dput (cobol_ext_$cobol_cmfp, status, work_ptr, ln, outkey);
		go to lloop;
	     end;
	call cobol_vdwf_dput (cobol_ext_$cobol_cmfp, status, work_ptr, ln, outkey);
	return;
     end repl3ln;

/*********************************************************/
process_keys:
     proc;
	return;

dcl	1 qual_rec1	based (com2_ptr),
	  2 next		char (5),
	  2 size		fixed bin,
	  2 name		char (30);
dcl	odo_ptr		ptr;
dcl	dn_ptr		ptr;
dcl	1 dn_key		based (addr (dn_ptr)),
	  2 fill		char (4),
	  2 keychars	char (2);
dcl	key		char (5);
dcl	qual_key		char (5);
dcl	1 auser_wd	based (stackptr),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 info_bit	bit (8),
	  2 length	fixed bin,
	  2 name		char (30);

/*************************************/
process_file_keys:
     entry;					/* PROCESS FILE KEYS */

	key = fixed_common.file_keys;
	file_desc_1.alt_key_count = 0;		/* [3.0-1] */
	type_two_sw = "0"b;				/* [3.0-1] */
	do while (key ^= null_key);
	     call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, fkey_ptr, recsize, key);
	     if file_key.key_type < 100
	     then do;				/* non-literal key */
		     counter = 0;
		     stackptr = stackbegptr;
		     auser_wd.line = file_key.line;
		     auser_wd.column = file_key.column;
		     auser_wd.length = file_key.name_size;
		     auser_wd.name = file_key.name;
		     call push;
		     qual_key = file_key.qual;
		     do while (qual_key ^= null_key);
			call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, com2_ptr, recsize, qual_key);
			auser_wd.length = qual_rec1.size;
			auser_wd.name = qual_rec1.name;
			call push;
			qual_key = qual_rec.next;
		     end;

		     call find;
		     if was_found
		     then do;
			     if data_name.type ^= 9
			     then call put (fatal_DATANAME_EXPECTED);
			     else do;
				     file_key.desc = dn_ptr -> temp_fld.temp_desc;
				     call check_dataname;
				     if file_key.key_type = 1
				     then do;	/* relative key */
					     call check_cnst_com_rprt_section;
					     call check_integer;
					     if data_name.file_num = file_key.file_no
					     then do;
						     call put (obs_KEY_NOT_IN_RECORD);

						     if fixed_common.comp_level < "5"
						     then call lev_diag (56);

						end;

					end;
				     else if file_key.key_type = 2 /* record key */ | file_key.key_type = 5
				     then do;	/* alternate record key */
					     call check_cnst_com_rprt_section;
					     if ^data_name.alphanum
					     then call put (warn_DATANAME_NOT_ALPHANUM);
						/*[3.0-1]*/
					     call cobol_read_ft_ (file_key.file_no, ft_ptr);
					     if data_name.file_num ^= file_key.file_no
						/*[3.0-1]*/
					     then do;
						/*[3.0-1]*/
						     if file_table.alternate_keys = 0
						/*[3.0-1]*/
						     then call put (obs_KEY_NOT_IN_RECORD);
						/*[3.0-1]*/
						     else call put (fatal_KEY_NOT_IN_RECORD);

						     if fixed_common.comp_level < "5"
						     then call lev_diag (58);

						end;



					     call build_file_desc (dn_ptr);
						/* [3.0-1] */

					end;
				     else if file_key.key_type = 3
				     then do;	/* file status key 1-2 */
					     if data_name.file_section
					     then call put (warn_ITEM_IN_FILE_SECTION);
					     else call check_cnst_com_rprt_section;
					     if data_name.item_length ^= 2 | ^data_name.alphanum
					     then call put (warn_BAD_STATUS_KEY);
					end;
				     else if file_key.key_type = 4 /* file status key 3 */ | file_key.key_type = 6
				     then do;	/* record contains key */
					     call check_cnst_com_rprt_section;
					     call check_integer;
					end;
				     else if file_key.key_type = 7 /* catalogue name */ | file_key.key_type = 12
				     then do;	/* additional catalogue name */
					     call cobol_read_ft_ (file_key.file_no, ft_ptr);
					     if file_table.device = 5
					     then do;
						/* tape */
						     if (^data_name.alphanum & ^data_name.numeric)
							| data_name.item_length > 6
						     then call put (warn_BAD_TAPE_CATALOG_NAME);
						end;
					     else do;
						     if ^data_name.alphanum | data_name.item_length > 200
						     then call put (warn_BAD_CATALOG_NAME);
						end;
					end;
				     else if file_key.key_type = 8
				     then do;	/* attach-options */
					     if ^data_name.alphanum | data_name.item_length > 256
					     then call put (warn_BAD_ATTACH_OPTIONS);
					end;
				     else if file_key.key_type = 9 /* tape replacement name */
					| file_key.key_type = 13
				     then do;	/* value of id name */
					     if ^data_name.alphanum | data_name.item_length > 17
					     then call put (warn_BAD_VALUE_OF_ID);
					end;
				     else if file_key.key_type = 10
				     then do;	/* device */
					     call check_integer;
					end;
				     else if file_key.key_type = 14
				     then do;	/* value of retention */
					     if data_name.item_length > 3
					     then call put (warn_BAD_VALUE_OF_RETENTION);
					     else call check_integer;
					end;
				end;
			end;
		end;				/* file_key.key_type < 100 */
	     key = file_key.next;
	end;
	return;

/************************************/
process_odo_keys:
     entry;					/* PROCESS OCCURS DEPENDING ON KEYS */

	key = fixed_common.odo_info;
	do while (key ^= null_key);
	     call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, odo_ptr, recsize, key);
	     call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, com2_ptr, ln, odo_ptr -> odo_rec.descr);
	     counter = 0;
	     stackptr = stackbegptr;
	     auser_wd.line = obj_rec.line;
	     auser_wd.column = obj_rec.column;
	     auser_wd.length = obj_rec.size;
	     substr (auser_wd.name, 1, auser_wd.length) = substr (obj_rec.name, 1, auser_wd.length);
	     call push;
	     qual_key = obj_rec.qual;
	     do while (qual_key ^= null_key);
		call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, com2_ptr, ln, qual_key);
		auser_wd.line = qual_rec.line;
		auser_wd.column = qual_rec.column;
		auser_wd.length = qual_rec.size;
		substr (auser_wd.name, 1, auser_wd.length) = substr (qual_rec.name, 1, auser_wd.length);
		call push;
		qual_key = qual_rec.next;
	     end;

	     call find;
	     if was_found
	     then do;
		     if data_name.type ^= 9
		     then call put (fatal_DATANAME_EXPECTED);
		     else do;
			     odo_ptr -> odo_rec.descr = "  " || dn_key.keychars;
						/* design change for SEARCH */
			     call check_dataname;
			     call check_integer;
			     if data_name.seg_num = 2
			     then do;
				     if data_name.offset <= odo_ptr -> odo_rec.offset_r
					& data_name.offset + data_name.item_length > odo_ptr -> odo_rec.offset_l
				     then call put (warn_ODO_RANGE);
				end;
			     else if data_name.constant_section
			     then call put (warn_CONSTANT_ILLOGICAL);
			end;
		end;
	     key = odo_ptr -> odo_rec.next;
	end;
	return;

/*************************************/
/* INTERNAL PROCEDURES */

push:
     proc;
	counter = counter + 1;
	ptrtable (counter) = stackptr;
	stackptr = addrel (stackptr, divide (size_TOKEN (8) + 11 + auser_wd.length, 8, 17, 0) * 2);
	return;
     end push;

find:
     proc;
	call cobol_usrwd (addr (ptrtable (1)), counter, addr (arrpntr (1)), 0, ntendptr, "0"b, was_found, not_found,
	     diag_no, dn_ptr);
	if ^was_found
	then if not_found
	     then call put (fatal_DATANAME_NOT_DECLARED);
	     else call put (fixed (diag_no));
	return;
     end find;

put:
     proc (diag);
dcl	diag		fixed bin;
	adiag.diag_number = diag;
	adiag.line = stackbegptr -> auser_wd.line;
	adiag.column = stackbegptr -> auser_wd.column;
	call cobol_c_list (addr (adiag));
	return;
     end put;

check_dataname:
     proc;
	if data_name.subscripted
	then call put (fatal_DATANAME_SUBSCRIPTED);
	if data_name.variable_length
	then call put (warn_DATANAME_VARLEN);
     end check_dataname;
check_integer:
     proc;
	if ^data_name.numeric
	then call put (fatal_DATANAME_NOT_NUMERIC);
	else if ^data_name.pic_integer | data_name.sign_type ^= ""b
	then call put (warn_DATANAME_NOT_INTEGER);
     end check_integer;
check_cnst_com_rprt_section:
     proc;
	if data_name.constant_section
	then call put (fatal_ITEM_IN_CONSTANT_SECTION);
	else if data_name.communication_section
	then call put (fatal_ITEM_IN_COM_SECTION);
	else if data_name.report_section
	then call put (fatal_ITEM_IN_REPORT_SECTION);
     end check_cnst_com_rprt_section;

/*************************************************/
build_file_desc:
     proc (data_name_ptr);				/* [3.0-1] */
						/*[]*/
						/*[]*/
dcl	data_name_ptr	ptr;			/*[]*/
dcl	word_offset	fixed bin (24),
	i		fixed bin;		/*[]*/
dcl	cobol_pool_	entry (char (*), fixed bin, fixed bin (24));
						/*[]*/
						/*[]*/
	if file_key.key_type = 2			/*[]*/
	then do;					/*[]*/
		type_two_sw = "1"b;			/*[]*/
		file_desc_1.type = 1;		/* always set to 1 */
						/*[]*/
		file_desc_1.prime_key.size = file_info.size;
						/*[]*/
		file_desc_1.prime_key.offset = get_rel_offset (file_info.offset, data_name_ptr);
						/*[]*/
		if file_table.alternate_keys = 0 /*[]*/ | /*[]*/ file_table.alternate_keys = file_desc_1.alt_key_count
						/*[]*/
		then do;				/*[]*/
			call cobol_pool_ (substr (file_desc_1_area, 1, (16 + (file_desc_1.alt_key_count * 8))), 2,
			     word_offset);		/*[]*/
			file_table.file_desc_1_offset = word_offset;
						/*[]*/
			type_two_sw = "0"b;		/*[]*/
			if file_desc_1.alt_key_count > 0
						/*[]*/
			then call check_dup_offset (data_name_ptr);
						/*[]*/
			file_desc_1.alt_key_count = 0;/*[]*/
		     end;				/*[]*/
	     end;					/*[]*/
	else if file_key.key_type = 5			/*[]*/
	then do;					/*[]*/
		file_desc_1.alt_key_count = file_desc_1.alt_key_count + 1;
						/*[]*/
		i = file_table.alternate_keys - file_desc_1.alt_key_count + 1;
						/*[]*/
		file_desc_1.alt_key (i).size = file_info.size;
						/*[]*/
		file_desc_1.alt_key (i).offset = get_rel_offset (file_info.offset, data_name_ptr);
						/*[]*/
		if file_key.duplicates		/*[]*/
		then file_desc_1.alt_key (i).size = file_desc_1.alt_key (i).size * -1;
						/*[]*/
						/*[]*/
		if type_two_sw /*[]*/ & /*[]*/ file_table.alternate_keys = file_desc_1.alt_key_count
						/*[]				Last alternate record key: write table to constants section. */
						/*[]*/
		then do;				/*[]*/
			call cobol_pool_ (substr (file_desc_1_area, 1, (16 + (file_desc_1.alt_key_count * 8))), 2,
			     word_offset);		/*[]*/
			file_table.file_desc_1_offset = word_offset;
						/*[]*/
			call check_dup_offset (data_name_ptr);
						/*[]*/
			type_two_sw = "0"b;		/*[]*/
			file_desc_1.alt_key_count = 0;/*[]*/
		     end;				/*[]*/
	     end;					/*[]*/
	return;					/*[]*/
     end build_file_desc;

check_dup_offset:
     proc (data_name_ptr);				/* [3.0-1] */
						/*[]*/
						/*[]*/
dcl	(j, jj)		fixed bin;		/*[]*/
dcl	data_name_ptr	ptr;			/*[]*/
						/*[]*/
						/* Check prime record key against alternates. */
						/*[]*/
						/*[]*/
	do j = 1 to file_desc_1.alt_key_count;		/*[]*/
	     if file_desc_1.prime_key.offset = file_desc_1.alt_key (j).offset
						/*[]*/
	     then do;				/*[]*/
		     call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, fkey_ptr, recsize, file_table.r_key_info);
						/*[]*/
		     adiag.diag_number = fatal_SAME_RECORD_OFFSET;
						/*[]*/
		     adiag.line = file_key.line;	/*[]*/
		     adiag.column = file_key.column;	/*[]*/
		     call cobol_c_list (addr (adiag));	/*[]*/
		     call put_dup_offset_diag (file_desc_1.prime_key.offset, data_name_ptr);
						/*[]*/
		     go to check_alts;		/*[]*/
		end;				/*[]*/
	end;					/*[]*/
						/*[]*/
check_alts:					/*[]*/
						/*[]*/
						/* Check alternate records keys against alterrnates.  */
						/*[]*/
	do j = 1 to (file_desc_1.alt_key_count - 1);	/*[]*/
	     do jj = (j + 1) to file_desc_1.alt_key_count;/*[]*/
		if file_desc_1.alt_key (j).offset = file_desc_1.alt_key (jj).offset
						/*[]*/
						/*[]*/
		then do;				/*[]*/
			call put_dup_offset_diag (file_desc_1.alt_key (j).offset, data_name_ptr);
						/*[]*/
			return;			/*[]*/
		     end;				/*[]*/
	     end;					/*[]*/
	end;					/*[]*/
     end check_dup_offset;

put_dup_offset_diag:
     proc (dup_offset, data_name_ptr);			/* [3.0-1] */
						/*[]*/
						/*[]*/
dcl	dup_offset	fixed bin;		/*[]*/
dcl	data_name_ptr	ptr;			/*[]*/
						/*[]*/
	key = file_table.alt_key_info;		/*[]*/
	do while (key ^= null_key);			/*[]*/
	     call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, status, fkey_ptr, recsize, key);
						/*[]*/
						/*[]*/
	     if get_rel_offset (file_info.offset, data_name_ptr) = dup_offset
						/*[]*/
	     then do;
		     adiag.diag_number = fatal_SAME_RECORD_OFFSET;
						/*[]*/
		     adiag.line = file_key.line;	/*[]*/
		     adiag.column = file_key.column;	/*[]*/
		     call cobol_c_list (addr (adiag));	/*[]*/
		end;				/*[]*/
	     key = file_key.next_alt;			/*[]*/
	end;					/*[]*/
     end put_dup_offset_diag;


get_rel_offset:
     proc (input_offset, data_name_ptr) /* [3.0-1] */ /*[]*/ returns (fixed bin (24));
						/*[]*/
						/*[]*/
dcl	input_offset	fixed bin (24);		/*[]*/
dcl	rel_offset	fixed bin (24);		/*[]*/
dcl	data_name_ptr	ptr;			/*[]*/
						/*[]*/
	work_ptr = data_name_ptr;			/*[]*/
	if work_ptr -> data_name.level > 1		/*[]*/
	then do;
		work_ptr = work_ptr -> data_name.prev_rec;
						/*[]*/
		continue = "1"b;			/*[]*/
		do while (continue);		/*[]*/
		     if work_ptr -> data_name.level = 1 /*[]*/
		     then continue = "0"b;		/*[]*/
		     else work_ptr = work_ptr -> data_name.prev_rec;
						/*[]*/
		end;				/*[]*/
		rel_offset = input_offset - (work_ptr -> data_name.offset);
						/*[]*/
		file_table.abs_record_offset = work_ptr -> data_name.offset;
						/*[]*/
	     end;					/*[]*/
	else do;					/*[]*/
		rel_offset = 0;			/*[]*/
		file_table.abs_record_offset = work_ptr -> data_name.offset;
						/*[]*/
	     end;					/*[]*/
						/*[]*/
						/*[]*/
	return (rel_offset);			/*[]*/
     end get_rel_offset;

%include cobol_type9;
     end process_keys;


issue_diag:
     proc;
	call cobol_swf_put (cobol_ext_$cobol_curr_out, status, addr (adiag), adiag.size);
     end issue_diag;





lev_diag:
     proc (diag_num);

declare	diag_num		fixed bin,
	lev_diag_ptr	ptr;

declare	1 lev_diag_item,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 run		fixed bin,
	  2 number	fixed bin,
	  2 info		bit (36);

declare	1 auser_wd	based,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 info_bit	bit (8),
	  2 length	fixed bin,
	  2 name		char (30);

	lev_diag_item.size = 28;
	lev_diag_item.type = 5;
	lev_diag_item.run = 9;
	lev_diag_item.info = "0"b;
	lev_diag_item.line = stackbegptr -> auser_wd.line;
	lev_diag_item.column = stackbegptr -> auser_wd.column;
	lev_diag_item.number = diag_num;

	lev_diag_ptr = addr (lev_diag_item);

	call cobol_c_list (lev_diag_ptr);

     end;

%include cobol_ext_;
%include cobol_file_table;
%include cobol_type12;
%include cobol_file_key;
%include cobol_linage_rec;
%include cobol_fixed_common;
%include cobol_com2;
%include cobol_cirst;
%include cobol_io_info;
%include cobol_;
%include cobol_xref;
%include cobol_repl_diag_values;
%include cobol_size_values;
%include cobol_file_desc_1;

     end cobol_repl3;
