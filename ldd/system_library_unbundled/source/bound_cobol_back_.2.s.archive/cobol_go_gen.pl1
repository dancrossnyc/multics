/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_go_gen.pl1 Reformatted code to new Cobol standard.
                                                   END HISTORY COMMENTS */


/* Modified on 01/14/77 by ORN to signal command_abort rather than cobol_compiler_error */
/* Modified since Version 2.0 */

/*{*/
/* format: style3 */
cobol_go_gen:
     proc (in_token_ptr);				/*
The procedure cobol_go_gen generates the code necessary to implement
the COBOL GO statement and, in the case of alterable GO's, pro-
duces the data structures from which initialization code may be
subsequently generated.  The format of the GO statement is:

Format 1  -

  G_O_ TO [procedure-name-1]

Format 2  -

  G_O_ TO procedure-name-1 [,procedure-name-2]..., procedure-name-n

        D_E_P_E_N_D_I_N_G_ ON identifier

The implementation of a GO statement depends upon whether or not
it is the object of an  ALTER statement.  A Format 1 GO statement 
with optional procedure-name-1 present may be modified by an 
ALTER statement; a Format 1 GO statement without optional proce-
dure-name-1 present must be modified by an ALTER statement; and a 
Format 2 GO statement may not be modified by an ALTER statement.
The determination of whether or not the GO statement being pro-
cessed is the object of an ALTER statement is made by examining
the variable cobol_$alter_flag.  A value of 1 indicates that the GO
statement is the object of an ALTER statement and a value of 0,
that it is not.  cobol_$alter_flag is set by cobol_paragraph_gen.

The implementation of a GO statement which is not the object of
an ALTER statement is also dependent upon whether or not the
COBOL segment containing the procedure to which control is to be
transferred must first be initialized.  Segment initialization is
not required if the procedure to which control is to be transfer-
red is in the same COBOL segment as the GO statement being imple-
mented, is in a fixed COBOL segment, or is in an independent
COBOL segment which contains no alterable GO's.  The term alter- 
able GO, as used here, refers to a GO statement that is the ob-
ject of an ALTER statement.

U__s_a_g_e:_

     declare cobol_go_gen entry (ptr);

     call cobol_go_gen (in_token_ptr);

						  */
%include cobol_in_token;

/*
G__e_n_e_r_a_t_e_d_C__o_d_e:_

Format 1  -

The following code is generated for Format 1 GO statements which
are alterable:

  lda    target_a
  tra    0,al

where:

target_a is a 36-bit variable, allocated in COBOL data on a word
         boundary and uniquely associated with the alterable GO 
         being implemented (see alter_list), which contains 
         transfer address data.  For information on the setting 
         of target_a, see cobol_initgo_gen.

If the optional procedure-name-1 is not present, the above two
instructions are followed by an execution time call to cobol_
error_ generated by a compile time call to cobol_process_error.
This call will be executed only in the event that the GO state-
ment is executed prior to the execution of an ALTER statement re-
ferring to this GO statement.  This is accomplished by initializ-
ing target_a such that control is passed to the first instruction
of the call to cobol_error_.  Target_a is otherwise initialized
to pass control to the first instruction of procedure-name-1.
See cobol_seginit_gen for details on initialization.

If it is found that a Format 1 GO statement without the optional
procedure-name-1 present is not the subject of an ALTER statement
then a compile time warning to this effect is issued to the user
via system subroutine signal_ and an execution time call to
cobol_error_ is generated by a call to cobol_process_error to signal
this error to the user at execution time and to prevent further
execution of the program in the event that this GO statement is
executed in the course of executing the program.

In the case of non-alterable Format 1 GO statements, code se-
quence 1, below, is used if no segment initialization is required
and sequence 2, if segment initialization is requierd.

     Sequence 1

  tra    pn_relp,ic

     Sequence 2

  eaa    pn_relp,ic
  tra    s_init_relp,ic

where:

pn_relp     is the offset, relative to the instruction in which
	  it appears, of the first instruction of the procedure
	  to the transfer is being made.

s_init_relp is the offset, relative to the instruction in which
	  it appears, of the first instruction of the code se-
	  quence provided to initialize the alterable GO's in
	  the segment containing the procedure to which the 
	  transfer is being made.

Format 2  -

The code generated to implement Format 2 GO statements is as
follows:

  stz    ident_bin
  dtb    (pr),(pr)
  ndsc9  ident
  ndsc9  ident_bin
  lda    1,du
  ldq    nt,du
  dwl    ident_bin
  tnz    nt+2mt+3,ic
  eax2   ident_bin,*ic
  tra    1,2
  tra    relp1,ic
  tra    relp2,ic
   .       .   .
   .       .   .
   .       .   .
  tra    relpn,ic
  eaa    pn1_relp,ic
  tra    s(pn1)_init_relp,ic
  eaa    pn2_relp,ic
  tra    s(pn2)_init_relp,ic
   .        .    .    .   .
   .        .    .    .   .
   .        .    .    .   .
  eaa    pnm_relp,ic
  tra    s(pnm)_init_relp,ic

where:

ident_bin	       is a fixed bin quantity allocated in the stack.
	       Its function is to contain the binary represen-
	       tation of the value of ident times 2**18.

ident	       is the operand of the DEPENDING ON phrase of the
	       Format 2 GO statement.  It is allocated in COBOL
	       data.

nt	       is the number of procedure names given as oper-
	       ands of the Format 2 GO statement.

mt	       is the number of procedure names given as oper-
	       ands of the Format 2 GO statement which are con-
	       tained in segments that must be initialized be-
	       fore the required transfer of control is made.
	       mt is less than or equal to nt.

relpn	       for n = 1, 2, 3, ... nt is a constant whose
	       value is either:
	       1) The offset, relative to the instruction in
	          which relpn appears, of the first instruction 
	          of procedure pnn (procedure-name-n), if the
	          segment containing procedure pnn does not
	          have to be initialized before control is
	          transferred to the procedure.
	       2) nt-n+2m-1 for n = 1, 2, 3, ... nt and m = 1,
	          2, 3, ...mt if the segment containing proce-
	          dure pnn requires initialization before con-
	          trol is transferred to the procedure.

pnm_relp	       for m = 1, 2, 3, ... mt is the offset, relative
	       to the instruction in which pnm_relp appears, of
	       the first instruction of procedure pnm where 
	       procedure pnm is in a segment requiring initial-
	       ization before control is transferred to it.

s(pnm)_init_relp for m = 1, 2, 3, ... mt is the offset, relative
	       to the instruction in which s(pnm)_init_relp ap-
	       pears, of the first instruction of the sequence
	       provided to initialize the segment containing
	       procedure pnn.

R__e_l_o_c_a_t_i_o_n_I__n_f_o_r_m_a_t_i_o_n:_

All instructions generated directly by procedure cobol_go_gen (as 
opposed to being generated by a utility called by cobol_go_gen) are 
non-relocatable.

						   */
/*
D__a_t_a:_

     % include cobol_;

	Items in cobol_ include file1 used (u) and/or set(s) by
	cobol_go_gen:

	     cobol_ptr (u)
	     alter_flag (u)
	     alter_index (u/s)
	     alter_list_ptr (u)
	     next_tag (u/s)
	     text_wd_off (u)
	     priority_no (u)
	     seg_init_list_ptr (u)

						   */

%include cobol_alter_list;
%include cobol_seg_init_list;
%include cobol_type9;
dcl	dn_ptr		ptr;
%include cobol_type18;
%include cobol_type19;

/*  Input structure for cobol_register$load		   */

declare	1 register_request	aligned static,
	  2 requested_reg	fixed bin aligned,
	  2 assigned_reg	bit (4) aligned,
	  2 lock		fixed bin aligned init (0),
	  2 reg_set_now	fixed bin aligned,
	  2 use_code	fixed bin aligned init (0),
	  2 adjust_ptr_addr fixed bin aligned init (0),
	  2 content_ptr	ptr aligned init (null),
	  2 literal_content bit (36) aligned init ((36)"0"b);

/*
requested_reg   is a code designating the register requested;
		0  - a- or q- or any index-register
		1  - a-register
		2  - q-register
		3  - a- and q-register
		4  - a- or q-register
		5  - any index-register
		1n - index-register n

assigned_reg    is a code designating the register assigned.  It
	      has no significance if a specific register is
	      requested.

lock	      indicates locking requirements; 0 requests that
	      no change be made in register status.

reg_set_now     not applicable for use_code = 0.

use_code 	      specifies how the register is to be used by the
	      requester; 0 signifies that such information is
	      not meaningful for register optimization.

adjust_ptr_addr inserted to make evident that since all pointers
	      must be allocated on even word boundaries, the
	      PLI compiler will allocate structures containing
	      pointers and all pointers therein on even word  
	      boundaries leaving "gaps" where necessary.

content_ptr     not applicable for use_code = 0.

literal_content not applicable for use_code = 0.
						   */


/*  Input structures for cobol_addr			   */

declare	1 target		aligned static,
	  2 type		fixed bin aligned init (1),
	  2 operand_no	fixed bin aligned init (0),
	  2 lock		fixed bin aligned init (0),
	  2 segno		fixed bin aligned,
	  2 char_offset	fixed bin (24) aligned,
	  2 send_receive	fixed bin aligned init (0);

/*
type	   indicates type of addressing requested.  Type 1
	   indicates basic; i.e., data to be addressed is
	   specified by segno and char_offset.

operand_no   not applicable to type 1.

lock	   indicates lock requirements for registers used in
	   addressing;
	     0 - do not lock registers used.
	     1 - lock registers used.

segno	   is the compiler designation of the segment in which
	   the data to be addressed is located.

char_offset  is the character offset within segno of the data to
	   be addressed.

send_receive indicates whether the data being addressed is a
	   sending or receiving field for the instruction whose
	   address field is being set; 0 indicates sending.
						   */

declare	1 input_struc	aligned static,
	  2 type		fixed bin aligned init (4),
	  2 operand_no	fixed bin aligned init (1),
	  2 lock		fixed bin aligned init (0),
	  2 operand,
	    3 token_ptr	ptr aligned init (null),
	    3 send_receive	fixed bin aligned init (0),
	    3 ic_mod	fixed bin aligned,
	    3 size_sw	fixed bin aligned init (0);

/*
type	   indicates type of addressing requested.  
		1  -  no operand, 1 wd, basic
		2  -  1 operand, 1 wd, non-EIS
		3  -  1 operand, 1 wd, EIS
		4  -  1 operand, 1 desc, 2wd, EIS
		5  -  2 operands, 2 desc, 3 wd, EIS
		6  -  3 operands, 3 desc, 4 wd, EIS

operand_no   number of operands associated with requested type.

lock	   indicates lock requirements for registers used in
	   addressing.
		0  -  do not lock registers used
		1  -  lock registers used
		2  -  unlock all registers

token_ptr	   is a pointer to the operand token.

send_receive indicates whether the operand being addressed is a
	   sending or receiving field for the instruction. 
		0  -  sending operand
		1  -  receiving operand

ic_mod	   indicates whether ic modification is specified in
	   the mf field of this operand (set by cobol_addr).
		0  -  no ic modification
		1  -  ic modification

size_sw	   indicates size (length) handlhlng requirements to
	   cobol_addr.
		0  -  cobol_addr may store the operand size in a
		      register or in the instruction
		1  -  cobol_addr need not be concerned with size
						   */

/*  Error message structure.				   */

declare	1 error_info	static aligned,
	  2 name		char (32) aligned init ("cobol_go_gen"),
	  2 message_len	fixed bin aligned,
	  2 message	char (168) aligned;

dcl	1 comp7_type9	static,
	  2 header	(4) fixed bin init (112, 0, 0, 9),
	  2 repl_ptr	(2) ptr init ((2) null ()),
	  2 fill1		bit (108) init (""b),
	  2 file_key_info,
	    3 fb1		(3) fixed bin init (0, 0, 0),
	    3 size	fixed bin init (2),
	    3 fb2		(2) fixed bin init (6, 0),
	    3 flags1	bit (36) init ("000000100100010001000000010000000000"b),
	    3 flags2	bit (36) init (""b),
	    3 seg		fixed bin init (1000),
	    3 off		fixed bin init (160),
	  2 fill2		(7) fixed bin init (0, 0, 0, 0, 0, 0, 0);

dcl	1 type19		static,
	  2 header	(4) fixed bin init (38, 0, 0, 19),
	  2 verb		fixed bin init (0),
	  2 e		fixed bin init (1),
	  2 h		fixed bin init (0),
	  2 ij		(2) fixed bin init (0, 0),
	  2 abcdfgk	bit (16) init ("0000000000000000"b);

dcl	1 mpout		static,
	  2 n		fixed bin init (4),
	  2 pt1		ptr,
	  2 pt2		ptr,
	  2 pt3		ptr,
	  2 pt4		ptr;

dcl	seq_f1_a		(4) bit (18) unaligned static init ("000000000000000000"b, "010011101001001101"b,
						/*  lda    target_a	*/
			"000000000000000000"b, "111001000000000101"b);
						/*  tra    0,al		*/

dcl	seq_f1_b		(2) bit (18) unaligned static init ("000000000000000000"b, "111001000000000100"b);
						/*  tra    0,ic		*/

dcl	seq_f1_c		(4) bit (18) unaligned static init ("000000000000000000"b, "110011101000000100"b,
						/*  eaa    pn_relp,ic	*/
			"000000000000000000"b, "111001000000000100"b);
						/*  tra    s_init_relp,ic	*/

dcl	seq_f2_1		(14) bit (18) unaligned static init ("110000000000101000"b, "100101000001000000"b,
						/*  stz    pr6|40	*/
			"000000000000000001"b, "010011101000000011"b,
						/*  lda    1,du		*/
			"000000000000000000"b, "010011110000000011"b,
						/*  ldq    nt,du	*/
			"110000000000101000"b, "001001001001000000"b,
						/*  cwl    pr6|40	*/
			"000000000000000000"b, "110000001000000100"b,
						/*  tnz    nt+2mt+3,ic	*/
			"110000000000101000"b, "110010010001110100"b,
						/*  eax2   pr6|40,*ic	*/
			"000000000000000001"b, "111001000000001010"b);
						/*  tra    1,2		*/

dcl	trans		(768) bit (36);		/*  Automatic data					   */

declare	s_text_wd		fixed bin,		/* Saved value of cobol_$text_wd_off.	   */
	temp		fixed bin,		/* Temporary used in unspec function. */
	init_req_flag	fixed bin,		/* 1 if seg initialization is not	   */
						/* required; 2 if it is.		   */
	pnn_priority	fixed bin,		/* COBOL seg no of seg containing	   */
						/* procedure-name-n.		   */
	cnt_pri		fixed bin,		/* Priority of current procedure.	   */
	init_tag		fixed bin,		/* Tag associated with 1st inst. of   */
						/* code generated to initialize alter-*/
						/* able GO's in COBOL seg containing  */
						/* procedure-name-n.		   */
	pnn_num		fixed bin,		/* Procedure no (tag) of procedure-   */
						/* name-n.			   */
	index		fixed bin,		/* Do loop index.		   */
	jndex		fixed bin,		/* Do loop index.		   */
	init_ptr		ptr,			/* Ptr to location in seg_init_list   */
						/* where initialization data is to be */
						/* placed.			   */
	nt		fixed bin,		/* Number of procedure names given as */
						/* operands in Format 2 GO statement. */
	sum		fixed bin;		/* nt+2m where m is the current count */
						/* of procedure names given as oper-  */
						/* ands in a Format 2 GO statement    */
						/* that are in segments requiring 	   */
						/* initialization.		   */

/*  Based structure used in placing initialization data in     */
/*  seg_init_list.					   */

declare	1 init_data	aligned based (init_ptr),
	  2 target_a_segno	fixed bin aligned,
	  2 target_a_offset fixed bin aligned,
	  2 pn1		fixed bin unaligned,
	  2 init		fixed bin unaligned;

/*
P__r_o_c_e_d_u_r_e_s_C__a_l_l_e_d:_
						   */

dcl	cobol_addr	entry (ptr, ptr, ptr),
	cobol_define_tag_nc entry (fixed bin, fixed bin),
	cobol_emit	entry (ptr, ptr, fixed bin),
	cobol_make_tagref	entry (fixed bin, fixed bin, ptr),
	cobol_process_error entry (fixed bin, fixed bin, fixed bin),
	cobol_move_gen	entry (ptr),
	cobol_register$load entry (ptr),
	ioa_$rsnnl	entry options (variable),
	signal_		entry (char (*), ptr, ptr);

/*
B__u_i_l_t-__i_n_F__u_n_c_t_i_o_n_s_U__s_e_d:_
						   */

dcl	addr		builtin,
	addrel		builtin,
	binary		builtin,
	null		builtin,
	substr		builtin,
	unspec		builtin;

/*}*/

%include cobol_;


/*************************************/
start:
	if in_token.token_ptr (in_token.n) -> end_stmt.a = "000"b
	then go to format1;
	else go to format2;

/*************************************/
format1:
	proc_ref_ptr = in_token.token_ptr (in_token.n - 1);
	pnn_num = proc_ref.proc_num;
	pnn_priority = binary (unspec (proc_ref.priority), 17);
	if cobol_$alter_flag = 0
	then /*  GO statement is not object of ALTER statement.	   */
	     do;
		if pnn_num = 0
		then /*  Program is in erroor.			   */
		     do;				/* This statement must be revised when two part line */
						/* becomes available.			   */
			call ioa_$rsnnl ("Line no. ^d: GO TO ?", error_info.message, error_info.message_len,
			     in_token.token_ptr (1) -> proc_ref.line);
			call signal_ ("command_error", null, addr (error_info));
			s_text_wd = cobol_$text_wd_off;
			call cobol_process_error (20, in_token.token_ptr (1) -> proc_ref.line, 0);
			temp = s_text_wd - cobol_$text_wd_off;
			seq_f1_b (1) = substr (unspec (temp), 19, 18);
			call cobol_emit (addr (seq_f1_b), null, 1);
		     end;

		else do;
			if cobol_$seg_init_list_ptr = null
			then init_req_flag = 1;

			else call is_init_req;

			if init_req_flag = 1
			then call cobol_emit (addr (seq_f1_b), null, 1);

			else do;
				register_request.requested_reg = 1;
				call cobol_register$load (addr (register_request));
				call cobol_emit (addr (seq_f1_c), null, 2);
				call cobol_make_tagref (init_tag, cobol_$text_wd_off - 1, null);
			     end;

			call cobol_make_tagref (pnn_num, cobol_$text_wd_off - init_req_flag, null);
		     end;

	     end;

	else /*  GO statement is object of ALTER statement.	   */
	     do;
		s_text_wd = cobol_$text_wd_off;
		target.segno = alter_list.goto.target_a_segno (cobol_$alter_index);
		target.char_offset = alter_list.goto.target_a_offset (cobol_$alter_index);
		cobol_$alter_index = cobol_$alter_index + 1;
		call cobol_addr (addr (target), addr (seq_f1_a), null);
		register_request.requested_reg = 1;
		call cobol_register$load (addr (register_request));
		call cobol_emit (addr (seq_f1_a), null, 2);

/*  Store initialization data.			   */

		cnt_pri = cobol_$priority_no;
		if cnt_pri < 50
		then cnt_pri = 0;

		do jndex = 1 to seg_init_list.n;
		     if seg_init_list.seg.priority (jndex) = cnt_pri
		     then do;
			     init_ptr =
				addrel (seg_init_list.seg.init_ptr (jndex),
				3 * seg_init_list.seg.next_init_no (jndex));
			     seg_init_list.seg.next_init_no (jndex) = seg_init_list.seg.next_init_no (jndex) + 1;
			     init_data.target_a_segno = target.segno;
			     init_data.target_a_offset = target.char_offset;
			     init_data.pn1 = pnn_num;
			     call is_init_req;
			     if init_req_flag = 1
			     then init_data.init = 0;

			     else init_data.init = init_tag;

			     goto next_step;
			end;

		end;

next_step:
		if pnn_num = 0
		then do;
			init_data.pn1 = cobol_$next_tag;
			call cobol_define_tag_nc (cobol_$next_tag, cobol_$text_wd_off);
			cobol_$next_tag = cobol_$next_tag + 1;
			call cobol_process_error (20, in_token.token_ptr (1) -> proc_ref.line, 0);
			temp = s_text_wd - cobol_$text_wd_off;
			seq_f1_b (1) = substr (unspec (temp), 19, 18);
			call cobol_emit (addr (seq_f1_b), null, 1);
		     end;

	     end;

	return;


/*************************************/
format2:
	nt = in_token.token_ptr (in_token.n) -> end_stmt.e;
	sum = nt;
	call cobol_emit (addr (seq_f2_1 (1)), null, 1);
	mpout.pt1 = null ();
	mpout.pt2 = in_token.token_ptr (nt + 2);
	comp7_type9.flags1 = "000000100100010001000000010000000000"b;
	mpout.pt3 = addr (comp7_type9);
	mpout.pt4 = addr (type19);
	call cobol_move_gen (addr (mpout));
	seq_f2_1 (5) = substr (unspec (nt), 19, 18);
	if cobol_$seg_init_list_ptr = null
	then do jndex = 1 to nt;
		trans (jndex) = "000000000000000000111001000000000100"b;
		pnn_num = in_token.token_ptr (in_token.n + jndex - nt - 2) -> proc_ref.proc_num;
		call cobol_make_tagref (pnn_num, cobol_$text_wd_off + jndex + 5, addr (trans (jndex)));
	     end;

	else do jndex = 1 to nt;
		trans (jndex) = "000000000000000000111001000000000100"b;
		proc_ref_ptr = in_token.token_ptr (in_token.n + jndex - nt - 2);
		pnn_num = proc_ref.proc_num;
		pnn_priority = binary (unspec (proc_ref.priority), 17);
		call is_init_req;
		if init_req_flag = 1
		then call cobol_make_tagref (pnn_num, cobol_$text_wd_off + jndex + 5, addr (trans (jndex)));

		else do;
			sum = sum + 1;
			temp = sum - jndex;
			substr (trans (jndex), 1, 18) = substr (unspec (temp), 19, 18);
			trans (sum) = "000000000000000000110011101000000100"b;
			call cobol_make_tagref (pnn_num, cobol_$text_wd_off + sum + 5, addr (trans (sum)));
			sum = sum + 1;
			trans (sum) = "000000000000000000111001000000000100"b;
			call cobol_make_tagref (init_tag, cobol_$text_wd_off + sum + 5, addr (trans (sum)));
		     end;

	     end;

	temp = sum + 3;
	seq_f2_1 (9) = substr (unspec (temp), 19, 18);
	register_request.requested_reg = 1;
	call cobol_register$load (addr (register_request));
	register_request.requested_reg = 12;
	call cobol_register$load (addr (register_request));
	call cobol_emit (addr (seq_f2_1 (3)), null, 6);
	call cobol_emit (addr (trans), null, sum);

	return;


is_init_req:
     proc;

	if cobol_$priority_no ^= pnn_priority
	then if pnn_priority > 49
	     then do index = 1 to seg_init_list.n;
		     if seg_init_list.seg.priority (index) = pnn_priority
		     then do;
			     init_req_flag = 2;
			     init_tag = seg_init_list.seg.int_tag_no (index);
			     goto finis;
			end;

		end;
	init_req_flag = 1;

finis:
	return;

     end is_init_req;

     end cobol_go_gen;
