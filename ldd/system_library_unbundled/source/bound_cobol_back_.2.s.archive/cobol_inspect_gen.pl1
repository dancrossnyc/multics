/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_inspect_gen.pl1 Added Trace statements.
                                                   END HISTORY COMMENTS */


/*  Modified on 10/19/84 by FCH, [4.3-1], BUG563(phx18381), new cobol_addr_tokens.incl.pl1 */
/* Modified on 02/13/81 by FCH, cobol_add_gen called with wrong arg count, [4.4-1], BUG463(TR9151) */
/* Modified on 10/10/77 by Bob Chnag to fix the table of substitution. */
/* Modified on 10/06/77 by Bob Chang to fix the bug for replacing optimatization. */
/* Modified on 06/06/77 by Bob Chang to implement further optimization. */
/* Modified on 04/21/77 by Bob Chang to implement optimization for simple cases.	*/
/* Modified on 03/31/77 by Bob Chang to fix the bug for overpunch data.	*/
/* Modified on 03/24/77 by ORN to allocate enough stack for tally and replace structures */
/* Modified since Version 2.0 */

/* format: style3 */
cobol_inspect_gen:
     proc (mp_ptr);

dcl	mp_ptr		ptr;

dcl	1 mp		based (mp_ptr),
	  2 n		fixed bin,
	  2 pt		(0 refer (mp.n)) ptr;

dcl	1 args,
	  2 entryno	fixed bin,
	  2 arglist_off	fixed bin,
	  2 stacktemp_off	fixed bin,
	  2 n		fixed bin,
	  2 arg		(3),
	    3 pt		ptr,
	    3 type	fixed bin,
	    3 off1	fixed bin,
	    3 off2	fixed bin,
	    3 value	bit (18) unal,
	    3 indirect	bit (1) unal,
	    3 overlay	bit (1) unal,
	    3 repeat_nogen	bit (1) unal;
dcl	1 name_arg	static,
	  2 pt		ptr init (null ()),		/* set each time to pt to varying char string containing name of program to be called */
	  2 type		fixed bin init (6),
	  2 zeros		bit (108) init (""b);
dcl	1 ptr_arg		static,
	  2 pt		ptr init (null ()),		/* always null */
	  2 type		fixed bin init (3),
	  2 off1		fixed bin init (50),
	  2 zeros		bit (72) init (""b);
dcl	1 tally_arg	static,
	  2 pt		ptr init (null ()),		/* always null */
	  2 type		fixed bin init (3),
	  2 off1		fixed bin,		/* set each time to allocated stack location */
	  2 zeros		bit (72) init (""b);

dcl	epp2_instr	bit (36) static init ("110000000000000000011101010001000000"b);
						/* epp2	 pr6|-			*/
dcl	spri2_instr	bit (36) static init ("110000000000000000010101010001000000"b);
						/* spri2	pr6|-			*/

dcl	1 pr2_struct	static,
	  2 pr		fixed bin init (2),
	  2 pointer_no	bit (3),
	  2 lock		fixed bin init (0),
	  2 switch	fixed bin init (0),
	  2 segno		fixed bin,
	  2 offset	fixed bin,
	  2 reset		fixed bin;
dcl	1 pr1_struct	static,
	  2 pr		fixed bin init (1),
	  2 pointer_no	bit (3),
	  2 lock		fixed bin init (1),
	  2 switch	fixed bin init (0),
	  2 segno		fixed bin,
	  2 offset	fixed bin,
	  2 reset		fixed bin;
dcl	1 reg_struct	static,
	  2 what_reg	fixed bin init (1),		/* A */
	  2 reg_no	bit (4),
	  2 lock		fixed bin init (0),
	  2 already_there	fixed bin,
	  2 contains	fixed bin init (0),
	  2 pointer	ptr init (null ()),
	  2 literal	bit (36) init (""b);
dcl	1 reg1_struct	static,
	  2 what_reg	fixed bin init (11),	/* x1 */
	  2 reg_no	bit (4),
	  2 lock		fixed bin init (1),
	  2 already_there	fixed bin,
	  2 contains	fixed bin init (0),
	  2 pointer	ptr init (null ()),
	  2 literal	bit (36) init (""b);

dcl	1 mpout		static,
	  2 n		fixed bin init (4),
	  2 pt1		ptr,
	  2 pt2		ptr,
	  2 pt3		ptr,
	  2 pt4		ptr;
dcl	1 type19_move	static,
	  2 header	(4) fixed bin init (38, 0, 0, 19),
	  2 verb		fixed bin init (0),
	  2 e		fixed bin init (1),
	  2 h		fixed bin init (0),
	  2 ij		(2) fixed bin init (0, 0),
	  2 abcdfgk	bit (16) init ("0000000000000000"b);
dcl	1 alpha_type9	static,
	  2 header	(4) fixed bin init (112, 0, 0, 9),
	  2 repl_ptr	(2) ptr init ((2) null ()),
	  2 fill1		bit (108) init (""b),
	  2 file_key_info,
	    3 fb1		(3) fixed bin init (0, 0, 0),
	    3 size	fixed bin init (0),
	    3 fb2		(2) fixed bin init (0, 0),
	    3 flags1	bit (36) init ("000000100100000000010000000100000000"b),
	    3 flags2	bit (36) init (""b),
	    3 seg		fixed bin init (1000),
	    3 off		fixed bin,
	  2 fill2		(7) fixed bin init (0, 0, 0, 0, 0, 0, 0);
dcl	1 type2_static	static,
	  2 header	(4) fixed bin init (40, 0, 0, 2),
	  2 flags		bit (9) init ("000000000"b),
	  2 signs		char (2) init ("  "),
	  2 places	(4) fixed bin init (0, 1, 0, 1),
	  2 lits		char (1) init ("1");
dcl	1 type3,
	  2 alignment	ptr,			/* so as to double word align the space */
	  2 rest		char (26);
dcl	alpha_char	char (112) based (addr (alpha_type9));
dcl	type9		char (112);
dcl	1 addpout		static,
	  2 n		fixed bin init (4),
	  2 pt1		ptr,
	  2 pt2		ptr,
	  2 pt3		ptr,
	  2 pt4		ptr;
dcl	1 type19_add	static,
	  2 header	(4) fixed bin init (38, 0, 0, 19),
	  2 verb		fixed bin init (2),
	  2 e		fixed bin init (1),
	  2 h		fixed bin init (1),
	  2 ij		(2) fixed bin init (0, 0),
	  2 abcdfgk	bit (16) init ("0000000000000000"b);
dcl	1 fb35_type9	static,
	  2 header	(4) fixed bin init (112, 0, 0, 9),
	  2 repl_ptr	(2) ptr init ((2) null ()),
	  2 fill1		bit (108) init (""b),
	  2 file_key_info,
	    3 fb1		(3) fixed bin init (0, 0, 0),
	    3 size	fixed bin init (4),
	    3 places_left	fixed bin init (4),
	    3 places_right	fixed bin init (0),
	    3 flags1	bit (36) init ("000000100100001001000000000000000000"b),
	    3 flags2	bit (36) init (""b),
	    3 seg		fixed bin init (1000),
	    3 off		fixed bin,
	  2 fill2		(7) fixed bin init (0, 0, 0, 0, 0, 0, 0);
dcl	lead_inst		(4) bit (18) static init ("110000000000000000"b, "010011100001000000"b,
						/* szn	pr6	cnt_off	*/
			"000000000000000000"b, "110000001000000100"b);
						/* tnz	exit_tag	*/
dcl	lxl3_inst		(6) bit (18) static init ("110000000000000000"b, "111010011001000000"b,
						/* lxl3	pr6|cnt_off	*/
			"000000000000000001"b, "000110011000000011"b,
						/* adx3	1,du		*/
			"110000000000000000"b, "111100011001000000"b);
						/* stx3	pr6|temp_off	*/
dcl	cmpx_inst		(10) bit (18) static init ("110000000000000000"b, "001000001001000000"b,
						/* cmpx1	pr6|temp_off	*/
			"000000000000000000"b, "110000100100000100"b,
						/* tmoz	exit_tag,ic	*/
			"110000000000000000"b, "001110001001000000"b,
						/* sbx1	pr6|temp_off	*/
			"110000000000000000"b, "000110010001000000"b,
						/* sbx2	pr6|temp_of	*/
			"000000000000000000"b, "111001000000000100"b);
						/* tra	scan_tag,ic	*/
dcl	(scan_tag, exit_tag, length_off, cnt_off)
			fixed bin;
dcl	ttn		bit (36) static init ("000000000000000000110000110100000100"b);
						/* ttn	exit,ic	*/
dcl	scm		(8) bit (18) static init ("000000000000000000"b, "001010100101101010"b,
						/* scm (pr,x2,rl),()	*/
			"001000000000000000"b, "000000000000001001"b,
						/* pr1|0,x1		*/
			"000000000000000000"b, "000000000000000000"b,
						/* sacn chars or offset	*/
			"110000000000000000"b, "000000000001000000"b);
						/* pr6|tally_count_off	*/
dcl	scd		(8) bit (18) static init ("000000000000000000"b, "001010000101101010"b,
						/* scd (pr,x2,rl),()	*/
			"001000000000000000"b, "000000000000001001"b,
						/* pr1|0,x1		*/
			"000000000000000000"b, "000000000000000000"b,
						/* sacn chars or offset	*/
			"110000000000000000"b, "000000000001000000"b);
						/* pr6|tally_count_off	*/

dcl	lxl_inst		(4) bit (18) static init ("110000000000000000"b, "111010001001000000"b,
						/* lxl1	pr6|length_off	*/
			"000000000000000000"b, "010010010000000011"b);
						/* ldx2	0,du	*/
dcl	lda_inst		(8) bit (18) static init ("110000000000000000"b, "010011101001000000"b,
						/* lda	pr6|length_off	*/
			"000000000000000000"b, "001111101000000111"b,
						/* sba	item_len,dl	*/
			"110000000000000000"b, "001111101001000000"b,
						/* sba	pr6|cnt_off	*/
			"110000000000000000"b, "111101101001000000"b);
						/* sta	pr6|cnt_off	*/
dcl	lca_inst		(8) bit (18) static init ("110000000000000000"b, "011011101001000000"b,
						/* lca	pr6|cnt_off	*/
			"000000000000000000"b, "001111101000000111"b,
						/* sba	item_len`sght,dl	*/
			"001000000000000000"b, "101010000101000101"b,
						/* s9bd	pr1|0,al	*/
			"110000000000000000"b, "000101101001000000"b);
						/* asa	pr6|length_off	*/
dcl	before_option	fixed bin,
	after_flag	bit (1);
dcl	(data_len, full_len, prev_scan)
			fixed bin;

dcl	ptr_off		fixed bin static init (50);
dcl	all_key		fixed bin static init (73);
dcl	characters_key	fixed bin static init (83);
dcl	leading_key	fixed bin static init (122);
dcl	before_key	fixed bin static init (80);
dcl	after_key		fixed bin static init (72);
dcl	first_key		fixed bin static init (109);
dcl	replacing_key	fixed bin static init (152);
dcl	mvt_table		char (128);
dcl	mvt_table_static	char (128) static init (" 	
 !""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~");
dcl	mvt		(4) bit (36);
dcl	mrl		(3) bit (36);
dcl	mlr		(3) bit (36);
dcl	mlr_tab		(3) bit (36) static
			init ("000000000001000000001000000100000100"b, "000000000000000000000000000010000000"b,
			"110000000000000000000000000010000000"b);
dcl	ldx1_inst		bit (36) static init ("000000000000000000010010001000000011"b);
dcl	lxl1_inst		bit (36) static init ("110000000000000000111010001001000000"b);
dcl	argb		(3) bit (216) based (addr (args.arg (1)));

dcl	code		bit (18) aligned;
dcl	save_code		bit (18) aligned;
dcl	found		bit (1);
dcl	done		bit (1);
dcl	char1		char (1);
dcl	char1_bit		bit (9) based (addr (char1));
dcl	char1_index	fixed bin;
dcl	rn_opt		bit (1);
dcl	tn_opt		bit (1);
dcl	stack_flag	fixed bin;
dcl	opch_flag		fixed bin;
dcl	con_flag		fixed bin;
dcl	conoff		fixed bin;
dcl	i		fixed bin;
dcl	tn		fixed bin;
dcl	rn		fixed bin;
dcl	j		fixed bin;
dcl	tind		fixed bin;
dcl	toutoff		fixed bin;
dcl	temp		fixed bin;
dcl	stoff		fixed bin;
dcl	aloff		fixed bin;
dcl	dn_ptr		ptr;
dcl	input_area	char (24);
dcl	reloc_area	char (10);
dcl	pr2_struct_ptr	ptr;
dcl	arg_ptr		ptr;
dcl	ttp		(512) ptr;

dcl	cobol_alloc$stack	entry (fixed bin, fixed bin, fixed bin);
dcl	cobol_pointer_register$priority
			entry (fixed bin, fixed bin, bit (3));
dcl	cobol_make_tagref	entry (fixed bin, fixed bin, ptr);
dcl	cobol_define_tag_nc entry (fixed bin, fixed bin); /*[4.4-1]*/
dcl	cobol_add_gen	entry (ptr, fixed bin);
dcl	cobol_emit	entry (ptr, ptr, fixed bin);
dcl	cobol_get_size$omit_sign
			entry (ptr, fixed bin, fixed bin);
dcl	cobol_move_gen	entry (ptr);
dcl	cobol_set_pr$omit_sign
			entry (ptr, ptr);
dcl	cobol_addr	entry (ptr, ptr, ptr);
dcl	cobol_pool	entry (char (*), fixed bin, fixed bin);
dcl	cobol_register$release
			entry (ptr);
dcl	cobol_make_type3$type1
			entry (ptr, ptr);
dcl	cobol_call_op	entry (fixed bin, fixed bin);
dcl	cobol_make_type9$type2_3
			entry (ptr, ptr);
dcl	cobol_io_util$bin_to_t9dec
			entry (bit (3) aligned, fixed bin, ptr);
dcl	cobol_io_util$t9dec_to_bin
			entry (bit (3) aligned, fixed bin, ptr);
dcl	cobol_io_util$move_direct
			entry (bit (3), fixed bin, fixed bin, fixed bin, bit (18) aligned);
dcl	cobol_reset_r$in_line
			entry;
dcl	cobol_register$load entry (ptr);

/*************************************/
start:
	call cobol_register$load (addr (reg_struct));
	arg_ptr = addr (args);
	pr2_struct_ptr = addr (pr2_struct);
	mpout.pt1 = mp.pt (1);
	mpout.pt4 = addr (type19_move);

	call cobol_alloc$stack (16, 2, stoff);
	eos_ptr = mp.pt (mp.n);
	i = 4;
	if end_stmt.a = "000"b
	then /* Format 1 */
	     call tally;
	else if end_stmt.a = "001"b
	then do;
		call replace;
	     end;
	else do;
		if end_stmt.b = "0"b | end_stmt.a = "010"b
		then do;				/* BEFORE REPLACING */
			call tally;
			i = i + 1;
			if end_stmt.a = "011"b
			then i = i + 1;
			call replace;
		     end;
		else do;				/* AFTER REPLACING */
			found = "0"b;
			do i = 7 to mp.n - 1 while (^found);
			     if mp.pt (i) -> data_name.type = 1
			     then if mp.pt (i) -> reserved_word.key = replacing_key
				then do;
					found = "1"b;
					i = i + 1;
					call replace;
					i = 4;
					call tally;
				     end;
			end;
		     end;
	     end;

	call cobol_reset_r$in_line;
	return;


/*************************************/
/* SUBROUTINES */
/*************************************/

tally:
     proc;
	call tally_stack_count;
	if tn_opt
	then do;
		call tally_opt;
		return;
	     end;
	tind = 1;
	tn = 0;
	ttp (1) = mp.pt (i);
	call cobol_io_util$t9dec_to_bin ("110"b, toutoff, ttp (1));
						/* 7/18/76*/

/* BUILD THE FOLLOWING  STRUCTURE:
/*		dcl 1 t,
/*		     2 ssp ptr,
/*		     2 slen fixed bin,
/*		     2 n fixed bin,
/*		     2 tally (0 refer(t.n)),
/*			3 ccode fixed bin,		/* 0=CHARACTERS, 1=LEADING, 2=ALL */
/*			3 lcode fixed bin,		/* 0=unspecified, 1=BEFORE, 2=AFTER */
/*			3 lpos fixed bin,		/* char pos to enable after's or disable before's */
/*			3 llen fixed bin,		/* length of BEFORE/AFTER string */
/*			3 lsp ptr,		/* ptr to BEFORE/AFTER string (if lcode ^= 0) */
/*			3 csp ptr,		/* ptr to LEADING/ALL string (if ccode > 0) */
/*			3 clen fixed bin,		/* length of LEADING/ALL string */
/*			3 ind fixed bin;		tally index		*/
/**/
restart:
	done = "0"b;
	i = i + 1;
	do while (^done);
	     tn = tn + 1;
	     if mp.pt (i) -> reserved_word.key = characters_key
	     then code = ""b;
	     else do;
		     if mp.pt (i) -> reserved_word.key = leading_key
		     then code = "000000000000000001"b;
		     else code = "000000000000000010"b; /* ALL */
		     i = i + 1;
		     dn_ptr = mp.pt (i);
		     if data_name.type ^= 9
		     then call get_type9;
		     call store_pr (dn_ptr, 10 + 10 * (tn - 1));
						/* t.csp(tn) */
		     call cobol_get_size$omit_sign (dn_ptr, stoff + 12 + 10 * (tn - 1), 0);
						/* t.clen(tn) */
		end;
	     call cobol_io_util$move_direct ("110"b, 4 * (stoff + 4 + 10 * (tn - 1)), 4, 1, code);
						/* t.ccode(tn) */
	     i = i + 1;
	     code = ""b;
	     if mp.pt (i) -> data_name.type = 1
	     then do;
		     if mp.pt (i) -> reserved_word.key = before_key | mp.pt (i) -> reserved_word.key = after_key
		     then do;
			     if mp.pt (i + 1) -> data_name.type = 1
			     then if mp.pt (i + 1) -> reserved_word.key = replacing_key
				then go to forget_it;
			     if mp.pt (i) -> reserved_word.key = before_key
			     then code = "000000000000000001"b;
			     else code = "000000000000000010"b;
			     i = i + 1;
			     dn_ptr = mp.pt (i);
			     if data_name.type ^= 9
			     then call get_type9;
			     call store_pr (dn_ptr, 8 + 10 * (tn - 1));
						/* t.lsp(tn) */
			     call cobol_get_size$omit_sign (dn_ptr, stoff + 7 + 10 * (tn - 1), 0);
						/* t.llen(tn) */
			     i = i + 1;
			end;
		end;
forget_it:
	     call cobol_io_util$move_direct ("110"b, 4 * (stoff + 5 + 10 * (tn - 1)), 4, 1, code);
						/* t.lcode(tn) */
	     code = substr (unspec (tind), 19, 18);
	     call cobol_io_util$move_direct ("110"b, 4 * (stoff + 13 + 10 * (tn - 1)), 4, 1, code);
						/* t.lcode(tn) */
	     dn_ptr = mp.pt (i);
	     if data_name.type ^= 1
	     then done = "1"b;
	     else do;
		     temp = dn_ptr -> reserved_word.key;
		     if temp ^= all_key & temp ^= leading_key & temp ^= characters_key
		     then done = "1"b;
		end;
	end;
	if mp.n > i & mp.pt (i) -> data_name.type = 9
	then do;
		tind = tind + 1;
		ttp (tind) = mp.pt (i);
		call cobol_io_util$t9dec_to_bin ("110"b, toutoff + (tind - 1) * 4, ttp (tind));
		goto restart;
	     end;
	call store_pr (mp.pt (2), 0);			/* t.ssp */
	call cobol_get_size$omit_sign (mp.pt (2), stoff + 2, 0);
						/* t.slen */
	substr (epp2_instr, 4, 15) = substr (unspec (stoff), 22, 15);
	code = substr (unspec (tn), 19, 18);
	call cobol_io_util$move_direct ("110"b, 4 * (stoff + 3), 4, 1, code);
						/* t.n */
	call cobol_emit (addr (epp2_instr), null (), 1);
	call cobol_call_op (50, 0);
	do j = 1 to tind;
	     call cobol_io_util$bin_to_t9dec ("110"b, toutoff + (j - 1) * 4, ttp (j));
	end;
exit_tally:
	return;

/*	Calculate the stack needed for tallying.	*/
tally_stack_count:
     proc;

dcl	j		fixed bin;
dcl	done		bit (1);
dcl	off		fixed bin;
dcl	tn		fixed bin;
	tind = 1;
	tn = 0;
	j = i + 1;
	;
	tn_opt = "1"b;
try_again:
	done = "0"b;
	do while (^done);
	     tn = tn + 1;
	     if tn > 1
	     then tn_opt = "0"b;
	     if mp.pt (j) -> reserved_word.key ^= characters_key
	     then j = j + 1;
	     if tn_opt
	     then do;
		     if mp.pt (j) -> data_name.type ^= 1
		     then do;
			     if mp.pt (j) -> data_name.type = 3
			     then if mp.pt (j) -> alphanum_lit.lit_size > 2
				then tn_opt = "0"b;
				else ;
			     else if mp.pt (j) -> data_name.type = 9
			     then do;
				     if mp.pt (j) -> data_name.variable_length
					| mp.pt (j) -> data_name.item_length > 2
				     then tn_opt = "0"b;
				end;
			     else tn_opt = "0"b;
			end;
		     if mp.pt (j + 1) -> data_name.type = 1
			& (mp.pt (j + 1) -> reserved_word.key = after_key
			| mp.pt (j + 1) -> reserved_word.key = before_key)
		     then do;
			     if mp.pt (j + 2) -> data_name.type = 1
				& mp.pt (j + 2) -> reserved_word.key = replacing_key
			     then tn_opt = "0"b;
			     else if mp.pt (j + 2) -> data_name.type = 3
			     then if mp.pt (j + 2) -> alphanum_lit.lit_size > 2
				then tn_opt = "0"b;
				else ;
			     else if mp.pt (j + 2) -> data_name.type = 9
			     then do;
				     if mp.pt (j + 2) -> data_name.variable_length
					| mp.pt (j + 2) -> data_name.item_length > 2
				     then tn_opt = "0"b;
				end;
			     else tn_opt = "0"b;
			end;
		end;
	     j = j + 1;
	     if mp.pt (j) -> data_name.type = 1
	     then do;
		     if mp.pt (j) -> reserved_word.key = before_key | mp.pt (j) -> reserved_word.key = after_key
		     then do;
			     if mp.pt (j + 1) -> data_name.type ^= 1
				| mp.pt (j + 1) -> reserved_word.key ^= replacing_key
			     then j = j + 2;
			end;
		end;
	     if mp.pt (j) -> data_name.type ^= 1
		| (mp.pt (j) -> reserved_word.key ^= all_key & mp.pt (j) -> reserved_word.key ^= characters_key
		& mp.pt (j) -> reserved_word.key ^= leading_key)
	     then done = "1"b;
	end;
	if mp.pt (j) -> data_name.type = 9 & j < mp.n
	then do;
		j = j + 1;
		tind = tind + 1;
		goto try_again;
	     end;
	off = (tind + tn * 10) * 4;
	toutoff = (stoff + tn * 10 + 4) * 4;
	if tn > 1
	then tn_opt = "0"b;
	if tn_opt
	then return;
	call cobol_alloc$stack (off, 2, j);

exit_tally_stack_count:
	return;
     end tally_stack_count;

/*************************************/
tally_opt:
     proc;


	addpout.pt1 = mp.pt (1);
	addpout.pt4 = addr (type19_add);
	if mp.pt (i + 1) -> reserved_word.key = characters_key
	then do;
		full_len = 0;
		if mp.pt (i + 2) -> data_name.type ^= 1
		then full_len = 1;
		else if mp.pt (i + 2) -> reserved_word.key ^= after_key
		     & mp.pt (i + 2) -> reserved_word.key ^= before_key
		then full_len = 1;
		else if mp.pt (i + 3) -> reserved_word.type = 1
		then if mp.pt (i + 3) -> reserved_word.key = replacing_key
		     then full_len = 1;
		if full_len = 1
		then do;
			dn_ptr = mp.pt (2);
			call cobol_alloc$stack (4, 1, length_off);
			call cobol_get_size$omit_sign (dn_ptr, length_off, 0);
			fb35_type9.off = length_off * 4;
			addpout.pt2 = addr (fb35_type9);
			addpout.pt3 = mp.pt (i);	/*[4.4-1]*/
			call cobol_add_gen (addr (addpout), 0);
		     end;
		else do;
			if mp.pt (i + 2) -> reserved_word.key = after_key
			then after_flag = "1"b;
			else after_flag = "0"b;
			call scan_opt_common (i + 3, data_len, "0"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b, after_flag)
			     ;
			if mp.pt (i + 2) -> reserved_word.key = after_key
			then do;
				substr (lda_inst (1), 4, 15) = substr (unspec (length_off), 22, 15);
				substr (lda_inst (3), 1, 18) = substr (unspec (data_len), 19, 18);
				substr (lda_inst (5), 4, 15) = substr (unspec (cnt_off), 22, 15);
				substr (lda_inst (7), 4, 15) = substr (unspec (cnt_off), 22, 15);
				call cobol_emit (addr (lda_inst (1)), null, 4);
			     end;
			fb35_type9.off = cnt_off * 4;
			addpout.pt2 = addr (fb35_type9);
			addpout.pt3 = mp.pt (i);	/*[4.4-1]*/
			call cobol_add_gen (addr (addpout), 0);
			call cobol_define_tag_nc (exit_tag, cobol_$text_wd_off);
			call cobol_register$release (addr (reg1_struct));
			reg1_struct.reg_no = "1010"b;
			call cobol_register$release (addr (reg1_struct));
		     end;
		if full_len = 1
		then i = i + 2;
		else i = i + 4;
		return;
	     end;
	else do;
		prev_scan = 1;
		rw_ptr = mp.pt (i + 3);
		if reserved_word.type ^= 1
		then prev_scan = 0;
		else if reserved_word.key ^= before_key & reserved_word.key ^= after_key
		then prev_scan = 0;
		else if mp.pt (i + 4) -> reserved_word.type ^= 1
		then if mp.pt (i + 4) -> reserved_word.key = replacing_key
		     then prev_scan = 0;
		if prev_scan = 0
		then call scan_opt_common (i + 2, data_len, "1"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "1"b);
		else do;
			if mp.pt (i + 3) -> reserved_word.key = after_key
			then after_flag = "1"b;
			else after_flag = "0"b;
			call scan_opt_common (i + 4, data_len, "0"b, "1"b, "1"b, "1"b, "0"b, after_flag, "1"b,
			     after_flag);
			call scan_opt_common (i + 2, data_len, "1"b, "0"b, "0"b, "0"b, "1"b, "0"b, "0"b, "1"b);
		     end;
	     end;
	if mp.pt (i + 1) -> reserved_word.key = leading_key
	then do;
		substr (lead_inst (1), 4, 15) = substr (unspec (cnt_off), 22, 15);
		call cobol_emit (addr (lead_inst (1)), null, 2);
		call cobol_make_tagref (exit_tag, cobol_$text_wd_off - 1, null);
	     end;
	addpout.pt2 = addr (type2_static);
	addpout.pt3 = mp.pt (i);			/*[4.4-1]*/
	call cobol_add_gen (addr (addpout), 0);
	reg_struct.what_reg = 13;
	call cobol_register$load (addr (reg_struct));
	temp = cnt_off + 1;
	substr (lxl3_inst (1), 4, 15) = substr (unspec (cnt_off), 22, 15);
	substr (lxl3_inst (5), 4, 15) = substr (unspec (temp), 22, 15);
	call cobol_emit (addr (lxl3_inst (1)), null, 3);
	call cobol_register$release (addr (reg_struct));
	reg_struct.what_reg = 1;

	substr (cmpx_inst (1), 4, 15) = substr (unspec (temp), 22, 15);
	substr (cmpx_inst (5), 4, 15) = substr (unspec (temp), 22, 15);
	substr (cmpx_inst (7), 4, 15) = substr (unspec (temp), 22, 15);
	call cobol_emit (addr (cmpx_inst (1)), null, 5);
	call cobol_make_tagref (exit_tag, cobol_$text_wd_off - 4, null);
	call cobol_make_tagref (scan_tag, cobol_$text_wd_off - 1, null);
	call cobol_register$release (addr (reg1_struct));
	reg1_struct.reg_no = "1001"b;
	call cobol_register$release (addr (reg1_struct));
	call cobol_define_tag_nc (exit_tag, cobol_$text_wd_off);
	call cobol_pointer_register$priority (2, 0, "001"b);
	if prev_scan = 1
	then i = i + 5;
	else i = i + 3;
exit_tally_opt:
	return;



     end tally_opt;
/******************************/



     end tally;




/*	scan_opt_common	*/
/****************************************/
scan_opt_common:
     proc (j, data_len, x2_flag, pr1_flag, len_flag, exit_flag, scan_flag, after_flag, x1_flag, ttn_flag);

dcl	j		fixed bin,
	data_len		fixed bin,
	(x2_flag, pr1_flag, len_flag, after_flag, x1_flag, ttn_flag, exit_flag, scan_flag)
			bit (1);

	dn_ptr = mp.pt (2);
	if pr1_flag
	then do;
		if data_name.numeric & data_name.item_signed & ^data_name.sign_separate
		then call opch_move (dn_ptr);
		call cobol_set_pr$omit_sign (addr (pr1_struct), dn_ptr);
	     end;
	if len_flag
	then do;
		call cobol_alloc$stack (20, 1, length_off);
		cnt_off = length_off + 1;
		call cobol_get_size$omit_sign (dn_ptr, length_off, 0);
		call cobol_register$load (addr (reg1_struct));
		reg1_struct.what_reg = 12;
		call cobol_register$load (addr (reg1_struct));
		reg1_struct.what_reg = 11;
		substr (lxl_inst (1), 4, 15) = substr (unspec (length_off), 22, 15);
		call cobol_emit (addr (lxl_inst (1)), null, 1);
	     end;
	if x2_flag
	then do;
		call cobol_emit (addr (lxl_inst (3)), null, 1);
		substr (scm (2), 15, 4) = "1010"b;
		substr (scd (2), 15, 4) = "1010"b;
	     end;
	else do;
		substr (scm (2), 15, 4) = "0000"b;
		substr (scd (2), 15, 4) = "0000"b;
	     end;
	if exit_flag
	then do;
		exit_tag = cobol_$next_tag;
		cobol_$next_tag = cobol_$next_tag + 1;
	     end;
	dn_ptr = mp.pt (j);
	if data_name.type = 1
	then do;
		call cobol_make_type3$type1 (addr (type3), dn_ptr);
		dn_ptr = addr (type3);
	     end;
	if data_name.type = 3
	then do;
		alit_ptr = dn_ptr;
		if scan_flag
		then do;
			scan_tag = cobol_$next_tag;
			cobol_$next_tag = cobol_$next_tag + 1;
			call cobol_define_tag_nc (scan_tag, cobol_$text_wd_off);
		     end;
		if alphanum_lit.lit_size = 1
		then do;
			data_len = 1;
			substr (lxl3_inst (3), 17, 2) = "01"b;
			substr (scm (7), 4, 15) = substr (unspec (cnt_off), 22, 15);
			substr (scm (5), 1, 9) = substr (unspec (alphanum_lit.string), 1, 9);
			substr (scm (5), 10, 9) = "000000000"b;
			substr (scm (1), 12, 7) = "0000011"b;
			call cobol_emit (addr (scm (1)), null, 4);
		     end;
		else do;
			data_len = 2;
			substr (lxl3_inst (3), 17, 2) = "10"b;
			substr (scd (7), 4, 15) = substr (unspec (cnt_off), 22, 15);
			substr (scd (1), 12, 7) = "0000011"b;
			substr (scd (5), 1, 18) = substr (unspec (alphanum_lit.string), 1, 18);
			call cobol_emit (addr (scd (1)), null, 4);
		     end;
	     end;
	else do;
		if data_name.numeric & data_name.item_signed & ^data_name.sign_separate
		then call opch_move (dn_ptr);
		mpout.pt2 = dn_ptr;
		mpout.pt3 = addr (alpha_type9);
		alpha_type9.off = 4 * length_off + 16;
		alpha_type9.size = data_name.item_length;
		call cobol_move_gen (addr (mpout));
		alpha_type9.flags1 = "000000100100000000010000000100000000"b;
		temp = length_off + 4;
		if scan_flag
		then do;
			scan_tag = cobol_$next_tag;
			cobol_$next_tag = cobol_$next_tag + 1;
			call cobol_define_tag_nc (scan_tag, cobol_$text_wd_off);
		     end;
		if data_name.item_length = 1
		then do;
			data_len = 1;
			substr (lxl3_inst (3), 17, 2) = "01"b;
			substr (scm (5), 1, 3) = "110"b;
			substr (scm (5), 4, 15) = substr (unspec (temp), 22, 15);
			substr (scm (7), 4, 15) = substr (unspec (cnt_off), 22, 15);
			substr (scm (1), 12, 7) = "100000"b;
			call cobol_emit (addr (scm (1)), null, 4);
		     end;
		else do;
			data_len = 2;
			substr (lxl3_inst (3), 17, 2) = "10"b;
			substr (scd (5), 1, 3) = "110"b;
			substr (scd (5), 4, 15) = substr (unspec (temp), 22, 15);
			substr (scd (7), 4, 15) = substr (unspec (cnt_off), 22, 15);
			substr (scd (1), 12, 7) = "100000"b;
			call cobol_emit (addr (scd (1)), null, 4);
		     end;
	     end;
	if ttn_flag
	then do;
		call cobol_emit (addr (ttn), null, 1);
		call cobol_make_tagref (exit_tag, cobol_$text_wd_off - 1, null);
	     end;

	if after_flag
	then do;
		substr (lca_inst (1), 4, 15) = substr (unspec (cnt_off), 22, 15);
		substr (lca_inst (3), 1, 18) = substr (unspec (data_len), 19, 18);
		substr (lca_inst (7), 4, 15) = substr (unspec (length_off), 22, 15);
		call cobol_emit (addr (lca_inst (1)), null, 4);
		substr (lxl_inst (1), 4, 15) = substr (unspec (length_off), 22, 15);
	     end;
	else substr (lxl_inst (1), 4, 15) = substr (unspec (cnt_off), 22, 15);
	if x1_flag
	then call cobol_emit (addr (lxl_inst (1)), null, 1);

exit_scan_opt_common:
	return;
     end scan_opt_common;
/****************************************/



/*************************************/
replace:
     proc;					/* BUILD THE FOLLOWING STRUCTURE:
/*		dcl 1 r,
/*		     2 ssp ptr,
/*		     2 slen fixed bin,
/*		     2 n fixed bin,
/*		     2 repl(0 refer(r.n)),
/*			3 ccode fixed bin,		/* 3=FIRST */
						/*			3 lcode fixed bin,
/*			3 lpos fixed bin,
/*			3 llen fixed bin,
/*			3 lsp ptr,
/*			3 csp ptr,
/*			3 clen fixed bin,
/*			3 bsp ptr;		/* ptr to BY string (length must = clen) */
						/**/
	rn = 0;
	save_code = ""b;
	call replacing_stack_count;
	if rn_opt
	then do;
		call repl_opt;
		return;
	     end;
	do while (mp.pt (i) -> data_name.type ^= 19);
	     rn = rn + 1;
	     dn_ptr = mp.pt (i);
	     if data_name.type = 1
	     then do;				/* may be key-word or a fig-con */
		     rw_ptr = dn_ptr;
		     if reserved_word.key = characters_key
		     then save_code = ""b;
		     else do;
			     if reserved_word.key = leading_key
			     then save_code = "000000000000000001"b;
			     else if reserved_word.key = all_key
			     then save_code = "000000000000000010"b;
			     else if reserved_word.key = first_key
			     then save_code = "000000000000000011"b;
			     else i = i - 1;	/* fig-con, save_code will have been set */
			     i = i + 1;
			     dn_ptr = mp.pt (i);
			     if data_name.type ^= 9
			     then call get_type9;
			     call store_pr (dn_ptr, 10 + 12 * (rn - 1));
						/* r.csp(rn) */
			     call cobol_get_size$omit_sign (dn_ptr, stoff + 12 + 12 * (rn - 1), 0);
						/* r.clen(rn) */
			end;
		end;
	     else do;
		     if data_name.type ^= 9
		     then call get_type9;
		     call store_pr (dn_ptr, 10 + 12 * (rn - 1));
						/*r.csp(rn) */
		     call cobol_get_size$omit_sign (dn_ptr, stoff + 12 + 12 * (rn - 1), 0);
						/* r.clen(rn) */
		end;
	     call cobol_io_util$move_direct ("110"b, 4 * (stoff + 4 + 12 * (rn - 1)), 4, 1, save_code);
						/* r.ccode(rn) */
	     i = i + 1;
	     dn_ptr = mp.pt (i);
	     if data_name.type ^= 9
	     then call get_type9;
	     call store_pr (dn_ptr, 14 + 12 * (rn - 1));	/* r.bsp(rn) */
	     i = i + 1;
	     code = ""b;
	     if mp.pt (i) -> data_name.type = 1
	     then do;
		     if mp.pt (i) -> reserved_word.key = before_key | mp.pt (i) -> reserved_word.key = after_key
		     then do;
			     if mp.pt (i) -> reserved_word.key = before_key
			     then code = "000000000000000001"b;
			     else code = "000000000000000010"b;
			     i = i + 1;
			     dn_ptr = mp.pt (i);
			     if data_name.type ^= 9
			     then call get_type9;
			     call store_pr (dn_ptr, 8 + 12 * (rn - 1));
						/* r.lsp(rn) */
			     call cobol_get_size$omit_sign (dn_ptr, stoff + 7 + 12 * (rn - 1), 0);
						/* r.llen(rn) */
			     i = i + 1;
			end;
		end;
	     call cobol_io_util$move_direct ("110"b, 4 * (stoff + 5 + 12 * (rn - 1)), 4, 1, code);
						/* r.lcode(rn) */
	end;
	dn_ptr = mp.pt (2);
	call store_pr (dn_ptr, 0);
	call cobol_get_size$omit_sign (mp.pt (2), stoff + 2, 0);
						/* r.slen */
	code = substr (unspec (rn), 19, 18);
	call cobol_io_util$move_direct ("110"b, 4 * (stoff + 3), 4, 1, code);
						/* r.n */
	substr (epp2_instr, 4, 15) = substr (unspec (stoff), 22, 15);
	call cobol_emit (addr (epp2_instr), null (), 1);
	call cobol_call_op (51, 0);
	if mp.pt (2) -> data_name.numeric & mp.pt (2) -> data_name.item_signed & ^mp.pt (2) -> data_name.sign_separate
	then do;
		mpout.pt2 = addr (alpha_type9);
		mpout.pt3 = mp.pt (2);
		call cobol_move_gen (addr (mpout));
	     end;
	return;


/*	Calculate replacing stack frame requirement.	*/
replacing_stack_count:
     proc;

dcl	j		fixed bin;
dcl	(all_option, leading_option)
			fixed bin;
dcl	k		fixed bin;
dcl	rn		fixed bin;

	all_option, leading_option, before_option = 0;
	rn = 0;
	rn_opt = "1"b;
	con_flag = 1;
	j = i;
	do while (mp.pt (j) -> data_name.type ^= 19);
	     rn = rn + 1;
	     if mp.pt (j) -> data_name.type = 1
	     then do;
		     if mp.pt (j) -> reserved_word.key = leading_key | mp.pt (j) -> reserved_word.key = first_key
			| mp.pt (j) -> reserved_word.key = characters_key
		     then leading_option = leading_option + 1;
		     else if mp.pt (j) -> reserved_word.key = all_key
		     then all_option = all_option + 1;
		     if mp.pt (j) -> reserved_word.key ^= characters_key
		     then do;
			     if mp.pt (j) -> reserved_word.key = leading_key
				| mp.pt (j) -> reserved_word.key = all_key
				| mp.pt (j) -> reserved_word.key = first_key
			     then j = j + 1;
			end;
		end;
	     do k = 1 to 2;
		if mp.pt (j) -> data_name.type = 3
		then if mp.pt (j) -> alphanum_lit.lit_size ^= 1
		     then rn_opt = "0"b;
		     else ;
		else if mp.pt (j) -> data_name.type = 9
		then if (mp.pt (j) -> data_name.item_length ^= 1 | mp.pt (j) -> data_name.variable_length = "1"b)
		     then rn_opt = "0"b;
		if rn_opt
		then if mp.pt (j) -> data_name.type = 9
		     then con_flag = 0;
		j = j + 1;
	     end;
	     if mp.pt (j) -> data_name.type = 1
	     then do;
		     if mp.pt (j) -> reserved_word.key = before_key | mp.pt (j) -> reserved_word.key = after_key
		     then do;
			     if mp.pt (j + 1) -> data_name.type = 3
			     then if mp.pt (j + 1) -> alphanum_lit.lit_size > 2
				then rn_opt = "0"b;
				else ;
			     else if mp.pt (j + 1) -> data_name.type = 9
			     then if (mp.pt (j + 1) -> data_name.item_length > 2
				     | mp.pt (j + 1) -> data_name.variable_length = "1"b)
				then rn_opt = "0"b;
				else rn_opt = "0"b;
			     j = j + 2;
			     before_option = before_option + 1;
			end;
		end;
	end;
	if rn_opt
	then do;
		if (leading_option ^= 0 | (before_option ^= 0 & all_option > 1))
		then rn_opt = "0"b;
		else if (before_option ^= 0 & rn > 1)
		then rn_opt = "0"b;
		else return;
	     end;
	call cobol_alloc$stack (48 * rn, 2, j);
exit_replacing_stack_count:
	return;
     end replacing_stack_count;


/* Generate on line instructions for optimatization of replacing single cahracter.	*/
repl_opt:
     proc;

dcl	j		fixed bin;
dcl	length_off	fixed bin;
dcl	k		fixed bin;

	i = i + 1;
	mvt_table = mvt_table_static;
	input_ptr = addr (input_area);
	reloc_ptr = addr (reloc_area);
	input_struc.type = 5;
	input_struc.operand_no = 2;
	input_struc.lock = 0;
	input_struc.size_sw (1) = 0;
	input_struc.size_sw (2) = 0;
	if before_option ^= 0
	then k = mp.n - 3;
	else k = mp.n - 1;
	if con_flag = 1
	then do;
		stack_flag = 0;
		do j = k to i by -1;
		     if mp.pt (j) -> reserved_word.key = all_key
		     then j = j - 1;
		     j = j - 1;
		     alit_ptr = mp.pt (j);
		     if alphanum_lit.type = 1
		     then do;
			     call cobol_make_type3$type1 (addr (type3), alit_ptr);
			     alit_ptr = addr (type3);
			end;
		     char1 = substr (alphanum_lit.string, 1, 1);
		     char1_index = fixed (char1_bit) + 1;
		     alit_ptr = mp.pt (j + 1);
		     if alphanum_lit.type = 1
		     then do;
			     call cobol_make_type3$type1 (addr (type3), alit_ptr);
			     alit_ptr = addr (type3);
			end;
		     substr (mvt_table, char1_index, 1) = substr (alphanum_lit.string, 1, 1);
		end;
		call cobol_pool (mvt_table, 2, conoff);
		substr (mvt (4), 19, 18) = "000000000000000100"b;
	     end;
	else do;
		stack_flag = 1;
		call cobol_alloc$stack (132, 2, length_off);
		call cobol_register$load (addr (reg1_struct));
		call cobol_pool (mvt_table_static, 2, conoff);
		temp = -conoff - cobol_$text_wd_off;
		substr (mlr_tab (2), 1, 18) = substr (unspec (temp), 19, 18);
		substr (mlr_tab (3), 4, 15) = substr (unspec (length_off), 22, 15);
		call cobol_emit (addr (mlr_tab (1)), null, 3);
		do j = k to i by -1;
		     if mp.pt (j) -> reserved_word.key = all_key
		     then j = j - 1;
		     j = j - 1;
		     if mp.pt (j) -> data_name.type ^= 9
		     then do;
			     alit_ptr = mp.pt (j);
			     if alphanum_lit.type = 1
			     then do;
				     call cobol_make_type3$type1 (addr (type3), alit_ptr);
				     alit_ptr = addr (type3);
				end;
			     substr (ldx1_inst, 10, 9) = substr (unspec (alphanum_lit.string), 1, 9);
			     call cobol_emit (addr (ldx1_inst), null, 1);
			end;
		     else do;
			     input_struc.token_ptr (1) = mp.pt (j);
			     if mp.pt (j) -> data_name.item_signed
			     then call opch_move (input_struc.token_ptr (1));
			     alpha_type9.off = length_off * 4 + 130;
			     alpha_type9.size = 2;
			     input_struc.token_ptr (2) = addr (alpha_type9);
			     call cobol_addr (input_ptr, addr (mrl (1)), reloc_ptr);
			     substr (mrl (1), 19, 10) = "0010000011"b;
			     substr (mrl (2), 21, 8) = "00000000"b;
			     substr (mrl (3), 21, 12) = "0000000000"b;
			     call cobol_emit (addr (mrl (1)), reloc_ptr, 3);
			     temp = length_off + 32;
			     substr (lxl1_inst, 4, 15) = substr (unspec (temp), 22, 15);
			     call cobol_emit (addr (lxl1_inst), null, 1);
			end;
		     if mp.pt (j + 1) -> data_name.type ^= 9
		     then do;
			     dn_ptr = mp.pt (j + 1);
			     if mp.pt (j + 1) -> data_name.type = 1
			     then do;
				     call cobol_make_type3$type1 (addr (type3), dn_ptr);
				     dn_ptr = addr (type3);
				end;
			     call cobol_make_type9$type2_3 (addr (type9), dn_ptr);
			     input_struc.token_ptr (1) = addr (type9);
			end;
		     else input_struc.token_ptr (1) = mp.pt (j + 1);
		     if mp.pt (j + 1) -> data_name.item_signed
		     then call opch_move (input_struc.token_ptr (1));
		     input_struc.token_ptr (2) = addr (alpha_type9);
		     alpha_type9.off = length_off * 4;
		     alpha_type9.size = 1;
		     substr (mlr (1), 19, 10) = "0010000001"b;
		     call cobol_addr (input_ptr, addr (mlr (1)), reloc_ptr);
		     substr (mlr (1), 15, 4) = "1001"b;
		     substr (mlr (2), 21, 8) = "00000000"b;
		     call cobol_emit (addr (mlr (1)), reloc_ptr, 3);
		end;
		substr (mvt (4), 4, 15) = substr (unspec (length_off), 22, 15);
		substr (mvt (4), 1, 3) = "110"b;
		substr (mvt (4), 19, 18) = "000000000001000000"b;
		reg1_struct.lock = 0;
		call cobol_register$release (addr (reg1_struct));
		reg1_struct.lock = 1;
	     end;
	substr (mvt (1), 19, 10) = "0011100001"b;
	if before_option ^= 0
	then do;
		if mp.pt (mp.n - 2) -> reserved_word.key = before_key
		then after_flag = "0"b;
		else after_flag = "1"b;
		call scan_opt_common (mp.n - 1, k, "0"b, "1"b, "1"b, "1"b, "0"b, after_flag, "1"b, after_flag);
		mvt (1) = "000000000001100000001110000101100000"b;
		mvt (2) = "001000000000000000000000000000001001"b;
		mvt (3) = "001000000000000000000000000000001001"b;
		if stack_flag = 0
		then do;
			temp = -conoff - cobol_$text_wd_off;
			substr (mvt (4), 1, 18) = substr (unspec (temp), 19, 18);
		     end;
		call cobol_emit (addr (mvt (1)), null, 4);
		if mp.pt (2) -> data_name.numeric & mp.pt (2) -> data_name.item_signed
		     & ^mp.pt (2) -> data_name.sign_separate
		then do;
			alpha_type9.seg = 5001;
			alpha_type9.off = 0;
			mpout.pt2 = addr (alpha_type9);
			mpout.pt3 = mp.pt (2);
			call cobol_move_gen (addr (mpout));
		     end;
		call cobol_define_tag_nc (exit_tag, cobol_$text_wd_off);
	     end;
	else do;
		input_struc.token_ptr (1) = mp.pt (2);
		if mp.pt (2) -> data_name.numeric & mp.pt (2) -> data_name.item_signed
		     & ^mp.pt (2) -> data_name.sign_separate
		then do;
			call opch_move (input_struc.token_ptr (1));
			opch_flag = 1;
		     end;
		else opch_flag = 0;
		if input_struc.token_ptr (1) -> data_name.numeric
		then input_struc.token_ptr (1) -> data_name.alphanum = "1"b;
		input_struc.token_ptr (2) = input_struc.token_ptr (1);
		call cobol_addr (input_ptr, addr (mvt (1)), reloc_ptr);
		if stack_flag = 0
		then do;
			temp = -conoff - cobol_$text_wd_off;
			substr (mvt (4), 1, 18) = substr (unspec (temp), 19, 18);
		     end;
		call cobol_emit (addr (mvt (1)), reloc_ptr, 4);
		if input_struc.token_ptr (1) -> data_name.numeric
		then input_struc.token_ptr (1) -> data_name.alphanum = "0"b;
		if opch_flag = 1
		then do;
			mpout.pt2 = input_struc.token_ptr (1);
			mpout.pt3 = mp.pt (2);
			call cobol_move_gen (addr (mpout));
		     end;
	     end;
exit_repl_opt:
	return;
     end repl_opt;



     end replace;


/*************************************/
store_pr:
     proc (t9ptr, off);
dcl	i		fixed bin;
dcl	t9ptr		ptr;
dcl	off		fixed bin;

	if t9ptr -> data_name.numeric & t9ptr -> data_name.item_signed & ^t9ptr -> data_name.sign_separate
	then call opch_move (t9ptr);
	call cobol_set_pr$omit_sign (pr2_struct_ptr, t9ptr);
	temp = stoff + off;
	substr (spri2_instr, 4, 15) = substr (unspec (temp), 22, 15);
	call cobol_emit (addr (spri2_instr), null (), 1);
	return;
     end store_pr;

/************************************/
opch_move:
     proc (t9ptr);
dcl	t9ptr		ptr;
dcl	i		fixed bin;
	mpout.pt2 = t9ptr;
	mpout.pt3 = addr (alpha_type9);
	alpha_type9.size = t9ptr -> data_name.item_length;
	call cobol_alloc$stack (alpha_type9.size, 1, i);
	alpha_type9.off = i * 4;
	call cobol_move_gen (addr (mpout));
	type9 = alpha_char;
	t9ptr = addr (type9);
	alpha_type9.flags1 = "000000100100000000010000000100000000"b;
	return;
     end opch_move;



/*************************************/
get_type9:
     proc;
	if data_name.type = 1
	then do;
		call cobol_make_type3$type1 (addr (type3), dn_ptr);
		dn_ptr = addr (type3);
	     end;
	if data_name.type ^= 9
	then do;
		call cobol_make_type9$type2_3 (addr (type9), dn_ptr);
		dn_ptr = addr (type9);
	     end;
	return;
     end get_type9;


/*************************************/
%include cobol_type1;
%include cobol_type2;
%include cobol_type3;
%include cobol_type9;
%include cobol_type19;
%include cobol_;
%include cobol_addr_tokens;
     end cobol_inspect_gen;
