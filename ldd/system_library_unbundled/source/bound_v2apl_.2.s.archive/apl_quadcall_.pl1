/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
   *                                                         *
   *********************************************************** */
apl_quadcall_: proc (operators_argument);

/*  Author:  H. Hoover,  Univeristy of Calgary,  81-06-05.                   */

/*  Modification history:                                                    */
/*                                                                           */
/*  81-12-11 (HH):  Added support for 'options (variable)' description of    */
/*     parameters.                                                           */
/*  82-01-06 (HH):  Added support for parameter type 'entry'.                */
/*  83-11-21 (AD):  Changed addr(substr(foo)) to based character array       */
/*     references (which should be replaced later by addcharno).             */

/*  Function:  an APL system function to provide APL users the ability to    */
/*     call a FORTRAN or PL/I routine.  If the routine is a subroutine, no   */
/*     result is returned to APL.  But if the routine is a function, the     */
/*     function's value is returned as the result.                           */

/*  Syntax:  Function call:  V -< qCALL (entry_dcl; arg1; arg2; ...; argN)    */
/*           Subroutine call:  qCALL (entry_dcl; arg1; arg2; ...; argN)      */
/*                                                                           */
/*   where 'q' is the APL quad symbol.                                       */

/*  Arguments:                                                               */
/*                                                                           */
/*  entry_dcl  (Input)                                                       */
/*     is an APL character value containing a PL/I style entry declaration   */
/*     specifying the routine to be called, the number of arguments it       */
/*     takes, whether it is a subroutine or function, and the types of the   */
/*     arguments and function value.  (See 'Entry Declaration' below for     */
/*     details.)                                                             */
/*                                                                           */
/*  arg1, arg2, ... argN  (Update)                                           */
/*     are the APL variables and values to be used as the arguments of the   */
/*     routine which is being called.  If an argument is a simple variable   */
/*     (as opposed to a constant, an expression or an indexed variable), the */
/*     value of that variable is updated to reflect any changes made by the  */
/*     called routine.                                                       */

/*  Entry Declaration:                                                       */
/*                                                                           */
/*  The entry declaration is identical to that of PL/I (except that the      */
/*  'entry' keyword is optional), with the following restrictions:           */
/*                                                                           */
/*  (1) The attributes in a parameter declaration must be in the folowing    */
/*      order:  dimensions, type, size and alignment.                        */
/*  (2) A lower bound may not be specified for a dimension.                  */
/*  (3) The mode (i.e 'real' or 'complex') may not be specified.             */
/*  (4) The only types supported are:  bit, char, entry, fixed bin, and      */
/*      float bin.                                                           */
/*  (5) Neither dimensions nor parameter descriptions (other than 'options   */
/*      (variable)') may be specified for 'entry' values.                    */
/*  (6) A scale factor may not be specified for 'fixed' values.              */
/*  (7) 'fixed' and 'float' values may not be unaligned.                     */
/*                                                                           */
/*  A typical declaration would be:                                          */
/*    'get_line_length_$stream(char(*), fixed bin(35)) returns(fixed bin)'   */

/*  Notes:                                                                   */
/*                                                                           */
/*  (1) If a simple variable is passed as an argument, that variable need    */
/*      not have been previously assigned a value.  In such a case, the      */
/*      value passed to the called routine for that argument has the shape   */
/*      and type indicated by the entry declaration and is initialized to    */
/*      binary zeroes.                                                       */
/*                                                                           */
/*  (2) The value of an argument must agree with the type specified in the   */
/*      entry declaration.  For example, if an argument is to be passed as a */
/*      'bit' value, it must be numeric and contain only zeroes and ones.    */
/*                                                                           */
/*  (3) The shape of an argument must agree with that specified in the entry */
/*      declaration.  This usually means that an argument has the shape      */
/*      indicated by the declaration.  However, an argument that is to be    */
/*      passed as a 'bit' or 'char' value is also considered to have the     */
/*      correct shape if its rank is one greater than in the declaration,    */
/*      its shape when the last dimension is excluded is the same as in the  */
/*      declaration, and the length of the last dimension is the same as the */
/*      size attribute in the declaration.  For example a 3x4 character      */
/*      matrix may be passed as '(3, 4) char (1)' or '(3) char (4)'.         */
/*                                                                           */
/*  (4) Either a positive integer or an asterisk may be used in the entry    */
/*      declaration to specify the length of a dimension or the size of a    */
/*      'bit' or 'char' value.  An asterisk in a dimension specification     */
/*      means use the current length of the corresponding dimension of the   */
/*      argument.  An asterisk in a size attribute means use the current     */
/*      length of the last dimension of the argument.  Asterisks may not be  */
/*      used when the corresponding argument is a simple variable that has   */
/*      not yet been assigned a value.  Asterisks may only be used in the    */
/*      'returns' attribute if the routine being called was written in PL/I  */
/*      and contains asterisks in the 'returns' attribute of its header.     */
/*                                                                           */
/*  (5) If 'options (variable)' is given in place of parameter declarations, */
/*      any number of arguments may be supplied.  A rank N numeric argument  */
/*      is passed as an N-dimension array of 'float bin(63)' numbers.  A     */
/*      rank N character argument is passed as an (N-1)-dimension array of   */
/*      'char(M)', where M is the size of the argument's last dimension.     */

dcl  cu_$generate_call entry (entry, ptr),
     sys_info$max_seg_size fixed bin (35) ext static;

dcl  null builtin,
     size builtin;

dcl  False bit (1) static options (constant) init ("0"b),
     Function fixed bin static options (constant) init (0),
     Left_arg fixed bin static options (constant) init (1),
     Max_rank fixed bin static options (constant) init (15),
     Right_arg fixed bin static options (constant) init (2),
     Token_chars char (63) static options (constant) init
    ("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"),
     True bit (1) static options (constant) init ("1"b),
     Type_bit fixed bin static options (constant) init (19),
     Type_char fixed bin static options (constant) init (21),
     Type_entry fixed bin static options (constant) init (16),
     Type_fixed_bin_long fixed bin static options (constant) init (2),
     Type_fixed_bin_short fixed bin static options (constant) init (1),
     Type_float_bin_long fixed bin static options (constant) init (4),
     Type_float_bin_short fixed bin static options (constant) init (3);

dcl  aligned_char_vec_len fixed bin (21),
     aligned_char_vec_ptr ptr,
     aligned_char_vec_size fixed bin (21),
     arg_list_arg_count fixed bin,
     argument_desc_ptr ptr,
     argument_list_ptr ptr,
     bit_vec_len fixed bin (24),
     bit_vec_pad fixed bin,
     bit_vec_ptr ptr,
     bit_vec_size fixed bin (24),
     bits_in_result fixed bin (24),
     calling_a_function bit (1),
     declaration_len fixed bin,
     declaration_ptr ptr,
     fixed_bin_long_vec_len fixed bin (17),
     fixed_bin_long_vec_ptr ptr,
     fixed_bin_short_vec_len fixed bin (18),
     fixed_bin_short_vec_ptr ptr,
     float_bin_long_vec_len float bin (17),
     float_bin_long_vec_ptr ptr,
     float_bin_short_vec_len float bin (18),
     float_bin_short_vec_ptr ptr,
     list_ptr ptr,
     marker_ptr ptr,
     routine entry variable,
     token_idx fixed bin,
     token_len fixed bin,
     unaligned_char_vec_len fixed bin (21),
     unaligned_char_vec_ptr ptr,
     unaligned_char_vec_size fixed bin (21);

dcl 01 argument_desc based (argument_desc_ptr),
    02 header like arg_descriptor,
    02 dimension_info (argument_desc.number_dims),
      03 lower_bound fixed bin (35),
      03 upper_bound fixed bin (35),
      03 multiplier fixed bin (35);

dcl 01 argument_list based (argument_list_ptr) like arg_list;

dcl  aligned_char_vec (aligned_char_vec_len) char (aligned_char_vec_size) aligned based (aligned_char_vec_ptr),
     bit_vec (bit_vec_len) bit (bit_vec_size + bit_vec_pad) based (bit_vec_ptr),
     declaration char (declaration_len) based (declaration_ptr),
     fixed_bin_long_vec (fixed_bin_long_vec_len) fixed bin (71) based (fixed_bin_long_vec_ptr),
     fixed_bin_short_vec (fixed_bin_short_vec_len) fixed bin (35) based (fixed_bin_short_vec_ptr),
     float_bin_long_vec (float_bin_long_vec_len) float bin (63) based (float_bin_long_vec_ptr),
     float_bin_short_vec (float_bin_short_vec_len) float bin (27) based (float_bin_short_vec_ptr),
     marker (0:n_members) fixed bin based (marker_ptr),
     dummy_chars (4*sys_info$max_seg_size) char (1) unaligned based,
     token char (token_len) based (addr (declaration_ptr -> dummy_chars (token_idx))),
     unaligned_char_vec (unaligned_char_vec_len) char (unaligned_char_vec_size) unaligned based (unaligned_char_vec_ptr);
	call validate_usage;
	call allocate_table_space;
	call process_declaration;
	call convert_arguments;
	if calling_a_function
	then begin;
dcl  result_buf bit (bits_in_result) aligned init (""b);	/*  Not on APL value stack to simplify garbage collection.  */
	     if bits_in_result = 0
	     then argument_list.arg_ptrs (arg_list_arg_count) = addr (argument_list.arg_ptrs (arg_list_arg_count));
	     else argument_list.arg_ptrs (arg_list_arg_count) = addr (result_buf);
	     call cu_$generate_call (routine, argument_list_ptr);
	     call update_byname_arguments;
	     call collect_garbage;
	     call assign_result;
	end;
	else do;
	     call cu_$generate_call (routine, argument_list_ptr);
	     call update_byname_arguments;
	     call collect_garbage;
	     operators_argument.result = null;
	end;
	operators_argument.error_code = 0;
	return;
allocate_argument_storage: proc (value_ptr);

/*  Function:  to allocate a value bead, from the APL heap, of a size that   */
/*     is appropriate for the current value of an argument.                  */

/*  Arguments:                                                               */
/*                                                                           */
/*  value_ptr  (Output)                                                      */
/*     the address of the value bead that was allocated.                     */

/*  Global Arguments:                                                        */
/*                                                                           */
/*  argument_desc  (Input)                                                   */
/*     the argument descriptor describing the value that will be placed in   */
/*     the value bead to be allocated.                                       */

/*  Notes:                                                                   */
/*                                                                           */
/*  (1)  The value bead is initialized according to the rank, shape and type */
/*       specified by the argument descriptor, but the data area is left for */
/*       for the caller to initialize.                                       */

dcl  value_ptr ptr;

dcl  apl_allocate_words_ entry (fixed bin (18), ptr unaligned);

dcl  bead_size fixed bin (18),
     data_size fixed bin (18),
     i fixed bin,
     last_dimension_implicit bit (1),
     unaligned_value_ptr ptr unaligned,
     value_size fixed bin (18);

/*  Calculate the value's size and allocate storage for it.  */

	     data_elements = 1;
	     number_of_dimensions = argument_desc.number_dims;
	     do i = 1 to number_of_dimensions;
		data_elements = argument_desc.upper_bound (i)*data_elements;
	     end;
	     if (argument_desc.type = Type_bit | argument_desc.type = Type_char) & argument_desc.size > 1
	     then do;
		last_dimension_implicit = True;
		number_of_dimensions = number_of_dimensions + 1;
		data_elements = argument_desc.size*data_elements;
	     end;
	     else last_dimension_implicit = False;
	     bead_size = round_to_even (size (value_bead));
	     if argument_desc.type = Type_char
	     then data_size = round_to_even (size (character_string_overlay));
	     else data_size = size (numeric_datum);
	     value_size = bead_size + data_size;
	     call apl_allocate_words_ (value_size, unaligned_value_ptr);
	     value_ptr = unaligned_value_ptr;

/*  Initialize the bead.  */

	     if argument_desc.type = Type_char
	     then string (value_ptr -> value_bead.type) = character_value_type;
	     else if argument_desc.type = Type_bit
	     then string (value_ptr -> value_bead.type) = zero_or_one_value_type;
	     else if argument_desc.type = Type_fixed_bin_short | argument_desc.type = Type_fixed_bin_long
	     then string (value_ptr -> value_bead.type) = integral_value_type;
	     else string (value_ptr -> value_bead.type) = numeric_value_type;
	     value_ptr -> value_bead.size = bit (value_size, 18);
	     value_ptr -> value_bead.reference_count = 1;
	     value_ptr -> value_bead.total_data_elements = data_elements;
	     value_ptr -> value_bead.rhorho = number_of_dimensions;
	     value_ptr -> value_bead.data_pointer = addrel (value_ptr, bead_size);
	     number_of_dimensions = argument_desc.number_dims;
	     do i = 1 to number_of_dimensions;
		value_ptr -> value_bead.rho (i) = argument_desc.upper_bound (number_of_dimensions - i + 1);
	     end;
	     if last_dimension_implicit
	     then value_ptr -> value_bead.rho (i) = argument_desc.size;
	end allocate_argument_storage;
allocate_table_space: proc;

/*  Function:  to allocate space on the APL value stack to hold the tables   */
/*     created from the declaration:  the argument list (which must be even  */
/*     word aligned), the argument descriptors, and the declaration marker   */
/*     array.                                                                */

/*  Global Arguments:                                                        */
/*                                                                           */
/*  arg_list_arg_count  (Output)                                             */
/*     is set equal to 'n_members', which is either the correct argument     */
/*     count (if we are calling a function), or one more than the correct    */
/*     count (if we are calling a subroutine).                               */
/*                                                                           */
/*  argument_desc_ptr  (Output)                                              */
/*     is the address of the storage allocated for the argument descriptors. */
/*                                                                           */
/*  argument_list_ptr  (Output)                                              */
/*     is the address of the storage allocated for the argument list.  It is */
/*     even-word aligned.                                                    */
/*                                                                           */
/*  list_ptr  (Input)                                                        */
/*     is the address of the list bead for our right argument.               */
/*                                                                           */
/*  marker_ptr  (Output)                                                     */
/*     is the address of the storage allocated for the marker array.         */
/*                                                                           */
/*  n_members  (Input)                                                       */
/*     is the number of members in the list passed as our right argument.    */

dcl  descriptor_space fixed bin,
     i fixed bin,
     member_ptr ptr,
     rank fixed bin;

/*  Calculate the number of words needed to hold the argument descriptors.   */
/*  Each descriptor requires 1 word for the header and, if the argument is   */
/*  not a scalar, 3 words for each dimension.  We can determine the size of  */
/*  the descriptor needed for each input argument from the rank of its       */
/*  value.  However, we won't know the rank of any output only arguments     */
/*  until we have decoded the declaration, so we must assume the maximum     */
/*  rank for these.  Similarly, we do not yet know if we are calling a       */
/*  subroutine or function, so we must assume we are calling a function and  */
/*  that its return value is of maximum rank.                                */

	     descriptor_space = 3*Max_rank + 1;		/*  Space for result descriptor.  */
	     do i = 2 to n_members;			/*  Add space for argument descriptors.  */
		member_ptr = list_ptr -> list_bead.member_ptr (i);
		if member_ptr -> general_bead.symbol
		then if member_ptr -> symbol_bead.meaning_pointer = null
		     then rank = Max_rank;
		     else rank = member_ptr -> symbol_bead.meaning_pointer -> value_bead.rhorho;
		else rank = member_ptr -> value_bead.rhorho;
		descriptor_space = descriptor_space + 3*rank + 1;
	     end;

/*  Allocate one block of storage to contain the argument list, followed by  */
/*  the argument descriptors, followed by the marker array.                  */

	     arg_list_arg_count = n_members;
	     argument_list_ptr = apl_push_stack_ (size (argument_list) + descriptor_space + size (marker));
	     argument_desc_ptr = addrel (argument_list_ptr, size (argument_list));
	     marker_ptr = addrel (argument_desc_ptr, descriptor_space);
	end allocate_table_space;
%include apl_push_stack_fcn;
assign_result: proc;

/*  Function:  to convert the result of the function just called to an APL   */
/*     value and set that value as our result.                               */

/*  Global Arguments:                                                        */
/*                                                                           */
/*  argument_desc  (Input)                                                   */
/*     the argument descriptor for the result.                               */
/*                                                                           */
/*  argument_list  (Input)                                                   */
/*     the argument list for the call that created the result.               */
/*                                                                           */
/*  operators_argument.result  (Output)                                      */
/*     the address of the APL value bead created for the converted result.   */

dcl  bead_ptr ptr,
     bead_size fixed bin (18),
     data_ptr ptr,
     data_size fixed bin (18),
     i fixed bin,
     j fixed bin,
     k fixed bin,
     last_dimension_implicit bit (1);

/*  Create the value bead for the result.  */

	     argument_desc_ptr = argument_list.desc_ptrs (arg_list_arg_count);
	     data_elements = 1;
	     number_of_dimensions = argument_desc.number_dims;
	     do i = 1 to number_of_dimensions;
		data_elements = data_elements*argument_desc.upper_bound (i);
	     end;
	     if (argument_desc.type = Type_bit | argument_desc.type = Type_char) & argument_desc.size > 1
	     then do;
		last_dimension_implicit = True;
		data_elements = data_elements*argument_desc.size;
		number_of_dimensions = number_of_dimensions + 1;
	     end;
	     else last_dimension_implicit = False;
	     bead_size = round_to_even (size (value_bead));
	     if argument_desc.type = Type_char
	     then data_size = round_to_even (divide (data_elements + 3, 4, 18));
	     else data_size = 2*data_elements;
	     if bead_size + data_size > MAX_VALUE_BEAD_SIZE
	     then call error (apl_error_table_$result_size, Function);
	     operators_argument.result, bead_ptr = apl_push_stack_ (bead_size + data_size);
	     bead_ptr -> value_bead.total_data_elements = data_elements;
	     bead_ptr -> value_bead.rhorho = number_of_dimensions;
	     bead_ptr -> value_bead.data_pointer, data_ptr = addrel (bead_ptr, bead_size);
	     do i = 1 to argument_desc.number_dims;
		bead_ptr -> value_bead.rho (i) = argument_desc.upper_bound (argument_desc.number_dims - i + 1);
	     end;
	     if last_dimension_implicit
	     then bead_ptr -> rho (number_of_dimensions) = argument_desc.size;

/*  Convert the result to APL format.  */

	     if argument_desc.type = Type_bit
	     then do;
		string (bead_ptr -> value_bead.type) = zero_or_one_value_type;
		float_bin_long_vec_len = data_elements;
		float_bin_long_vec_ptr = data_ptr;
		if argument_desc.packed | mod (argument_desc.size, 36) = 0
		then do;
		     bit_vec_size = float_bin_long_vec_len;
		     bit_vec_len = 1;
		end;
		else do;
		     bit_vec_size = argument_desc.size;
		     bit_vec_len = divide (float_bin_long_vec_len, bit_vec_size, 24);
		end;
		bit_vec_pad = 36*divide (bit_vec_size + 35, 36, 24) - bit_vec_size;
		bit_vec_ptr = argument_list.arg_ptrs (arg_list_arg_count);
		i = 1;
		do j = 1 to bit_vec_len;
		     do k = 1 to bit_vec_size;
			float_bin_long_vec (i) = float (substr (bit_vec (j), k, 1));
			i = i + 1;
		     end;
		end;
	     end;
	     else if argument_desc.type = Type_char
	     then do;
		string (bead_ptr -> value_bead.type) = character_value_type;
		if ^argument_desc.packed | mod (argument_desc.size, 4) ^= 0
		then do;
		     unaligned_char_vec_size = argument_desc.size;
		     unaligned_char_vec_len = divide (data_elements,
			unaligned_char_vec_size, 21);
		     unaligned_char_vec_ptr = data_ptr;
		     aligned_char_vec_size = unaligned_char_vec_size;
		     aligned_char_vec_len = unaligned_char_vec_len;
		     aligned_char_vec_ptr = argument_list.arg_ptrs (arg_list_arg_count);
		     do i = 1 to aligned_char_vec_len;
			unaligned_char_vec (i) = aligned_char_vec (i);
		     end;
		end;
		else do;
		     unaligned_char_vec_len = 1;
		     unaligned_char_vec_ptr = argument_list.arg_ptrs (arg_list_arg_count);
		     unaligned_char_vec_size = data_elements;
		     data_ptr -> unaligned_char_vec = unaligned_char_vec;
		end;
	     end;
	     else if argument_desc.type = Type_fixed_bin_long
	     then do;
		float_bin_long_vec_len = data_elements;
		float_bin_long_vec_ptr = data_ptr;
		fixed_bin_long_vec_len = float_bin_long_vec_len;
		fixed_bin_long_vec_ptr = argument_list.arg_ptrs (arg_list_arg_count);
		do i = 1 to fixed_bin_long_vec_len	/*  Copy to first non-Boolean.  */
			while (fixed_bin_long_vec (i) = 0 | fixed_bin_long_vec (i) = 1);
		     float_bin_long_vec (i) = fixed_bin_long_vec (i);
		end;
		do j = i to fixed_bin_long_vec_len;	/*  Copy remainder.  */
		     float_bin_long_vec (j) = fixed_bin_long_vec (j);
		end;
		if i > fixed_bin_long_vec_len
		then string (bead_ptr -> value_bead.type) = zero_or_one_value_type;
		else string (bead_ptr -> value_bead.type) = integral_value_type;
	     end;
	     else if argument_desc.type = Type_fixed_bin_short
	     then do;
		float_bin_long_vec_len = data_elements;
		float_bin_long_vec_ptr = data_ptr;
		fixed_bin_short_vec_len = float_bin_long_vec_len;
		fixed_bin_short_vec_ptr = argument_list.arg_ptrs (arg_list_arg_count);
		do i = 1 to fixed_bin_short_vec_len	/*  Copy to first non-Boolean.  */
			while (fixed_bin_short_vec (i) = 0 | fixed_bin_short_vec (i) = 1);
		     float_bin_long_vec (i) = fixed_bin_short_vec (i);
		end;
		do j = i to fixed_bin_short_vec_len;	/*  Copy remainder.  */
		     float_bin_long_vec (j) = fixed_bin_short_vec (j);
		end;
		if i > fixed_bin_short_vec_len
		then string (bead_ptr -> value_bead.type) = zero_or_one_value_type;
		else string (bead_ptr -> value_bead.type) = integral_value_type;
	     end;
	     else if argument_desc.type = Type_float_bin_long
	     then do;
		float_bin_long_vec_len = data_elements;
		float_bin_long_vec_ptr = argument_list.arg_ptrs (arg_list_arg_count);
		do i = 1 to float_bin_long_vec_len	/*  Copy to first non-Boolean.  */
			while (float_bin_long_vec (i) = 0 | float_bin_long_vec (i) = 1);
		     data_ptr -> float_bin_long_vec (i) = float_bin_long_vec (i);
		end;
		do j = i to float_bin_long_vec_len	/*  Copy to first non_integer.  */
			while (float_bin_long_vec (j) = floor (float_bin_long_vec (j)));
		     data_ptr -> float_bin_long_vec (j) = float_bin_long_vec (j);
		end;
		do k = j to float_bin_long_vec_len;	/*  Copy remainder.  */
		     data_ptr -> float_bin_long_vec (k) = float_bin_long_vec (k);
		end;
		if i > float_bin_long_vec_len
		then string (bead_ptr -> value_bead.type) = zero_or_one_value_type;
		else if j > float_bin_long_vec_len
		then string (bead_ptr -> value_bead.type) = integral_value_type;
		else string (bead_ptr -> value_bead.type) = numeric_value_type;
	     end;
	     else if argument_desc.type = Type_float_bin_short
	     then do;
		float_bin_long_vec_len = data_elements;
		float_bin_long_vec_ptr = data_ptr;
		float_bin_short_vec_len = float_bin_long_vec_len;
		float_bin_short_vec_ptr = argument_list.arg_ptrs (arg_list_arg_count);
		do i = 1 to float_bin_short_vec_len	/*  Copy to first non-Boolean.  */
			while (float_bin_short_vec (i) = 0 | float_bin_short_vec (i) = 1);
		     float_bin_long_vec (i) = float_bin_short_vec (i);
		end;
		do j = i to float_bin_short_vec_len	/*  Copy to first non-integer.  */
			while (float_bin_short_vec (j) = floor (float_bin_short_vec (j)));
		     float_bin_long_vec (j) = float_bin_short_vec (j);
		end;
		do k = j to float_bin_short_vec_len;	/*  Copy remainder.  */
		     float_bin_long_vec (k) = float_bin_short_vec (k);
		end;
		if i > float_bin_short_vec_len
		then string (bead_ptr -> value_bead.type) = zero_or_one_value_type;
		else if j > float_bin_short_vec_len
		then string (bead_ptr -> value_bead.type) = integral_value_type;
		else string (bead_ptr -> value_bead.type) = numeric_value_type;
	     end;
	end assign_result;
collect_garbage: proc;

/*  Function:  to free the space in the APL value stack occupied by the      */
/*     arguments, since they are no longer needed.                           */

/*  Global Arguments:                                                        */
/*                                                                           */
/*  list_ptr  (Input)                                                        */
/*     the address of the right argument list bead.                          */
/*                                                                           */
/*  ws_info.value_stack_ptr  (Output)                                        */
/*     the address of the next free location on the APL value stack.         */

dcl  apl_free_bead_ entry (ptr unaligned);

dcl  i fixed bin,
     member_ptr ptr;

/*  Pop the value stack:  The right argument list bead is lowest on the      */
/*  stack, unless some of the list members are also on the stack, in which   */
/*  case the rightmost such member is lowest.  The reference count for each  */
/*  member which is not on the value stack must also be decremented.         */

	     ws_info.value_stack_ptr = list_ptr;
	     do i = 1 to n_members;
		member_ptr = list_ptr -> list_bead.member_ptr (i);
		if list_ptr -> list_bead.semantics_on_stack (i)
		then ws_info.value_stack_ptr = member_ptr;
		else do;
		     member_ptr -> general_bead.reference_count = member_ptr -> general_bead.reference_count - 1;
		     if member_ptr -> general_bead.reference_count < 1
		     then call apl_free_bead_ ((member_ptr));
		end;
	     end;
	end collect_garbage;
convert_arguments: proc;

/*  Function:  to format the arguments to be passed to the routine which is  */
/*     to be called, according to the declaration.                           */

/*  Global Arguments:                                                        */
/*                                                                           */
/*  argument_desc  (Input)                                                   */
/*     the argument descriptors (from which the type of conversion needed is */
/*     discovered).                                                          */
/*                                                                           */
/*  argument_list  (Update)                                                  */
/*     the argument list for the call.  The argument ptrs will be filled in. */
/*                                                                           */
/*  list_ptr  (Input)                                                        */
/*     the address of the list bead for the right argument.                  */
/*                                                                           */
/*  marker  (Input)                                                          */
/*     the indices in 'declaration' of the routine name (element 0) and the  */
/*     start of each parameter declaration (elements 1 -> 'n_members').      */

dcl  arg_num fixed bin,
     entry_ptr ptr,
     i fixed bin,
     j fixed bin,
     k fixed bin,
     member_num fixed bin,
     member_ptr ptr,
     module_name_len fixed bin (21),
     module_name_ptr ptr,
     rank fixed bin,
     routine_name_len fixed bin (21),
     routine_name_ptr ptr,
     size_limit float bin (27),
     status fixed bin (35),
     value_ptr ptr;

dcl  entry entry based (entry_ptr),
     routine_name char (routine_name_len) based (routine_name_ptr),
     module_name char (module_name_len) based (module_name_ptr);

/*  Fill in the argument list argument pointers.  If an argument is already  */
/*  in the format specified in the declaration, and it either is passed by   */
/*  by value on the value stack, or it is passed by name and does not share  */
/*  its value, then we just use it.  Otherwise, we must copy its value onto  */
/*  the value stack in the appropriate format and then use the copy.  If the */
/*  argument is already on the value stack and the desired format does not   */
/*  require any more space, do the conversion in place, rather than allocate */
/*  new storage on the value stack.                                          */

	     do member_num = 2 to n_members;
		arg_num = member_num - 1;
		member_ptr = list_ptr -> list_bead.member_ptr (member_num);
		if member_ptr -> general_bead.symbol
		then value_ptr = member_ptr -> symbol_bead.meaning_pointer;
		else value_ptr = member_ptr;
		argument_desc_ptr = argument_list.desc_ptrs (arg_num);
		if value_ptr = null
		then do;				/*  No initial value, so just allocate space.  */
		     bit_vec_len = 1;
		     rank = argument_desc.number_dims;
		     if rank < 1
		     then if argument_desc.type = Type_bit
			then bit_vec_size = argument_desc.size;
			else if argument_desc.type = Type_char
			then bit_vec_size = 9*argument_desc.size;
			else bit_vec_size = argument_desc.size + 1;
		     else if argument_desc.packed
		     then bit_vec_size = argument_desc.upper_bound (rank)*argument_desc.multiplier (rank);
		     else bit_vec_size = 36*argument_desc.upper_bound (rank)*argument_desc.multiplier (rank);
		     bit_vec_pad = 36*divide (bit_vec_size + 35, 36, 18) - bit_vec_size;
		     bit_vec_ptr = apl_push_stack_ (size (bit_vec));
		     unspec (bit_vec) = ""b;
		     argument_list.arg_ptrs (arg_num) = bit_vec_ptr;
		end;
		else if argument_desc.type = Type_bit
		then do;
		     float_bin_long_vec_len = value_ptr -> value_bead.total_data_elements;
		     float_bin_long_vec_ptr = value_ptr -> value_bead.data_pointer;
		     if argument_desc.packed | mod (argument_desc.size, 36) = 0
		     then do;
			bit_vec_size = float_bin_long_vec_len;
			bit_vec_len = 1;
		     end;
		     else do;
			bit_vec_size = argument_desc.size;
			bit_vec_len = divide (float_bin_long_vec_len, bit_vec_size, 24);
		     end;
		     bit_vec_pad = 36*divide (bit_vec_size + 35, 36, 18) - bit_vec_size;
		     if list_ptr -> list_bead.semantics_on_stack (member_num)
		     then bit_vec_ptr = float_bin_long_vec_ptr;
		     else bit_vec_ptr = apl_push_stack_ (size (bit_vec));
		     i = 1;
		     do j = 1 to bit_vec_len;
			do k = 1 to bit_vec_size;
			     substr (bit_vec (j), k, 1) = (float_bin_long_vec (i) ^= 0);
			     i = i + 1;
			end;
			substr (unspec (bit_vec (j)), k) = ""b; /*  Zero the pad bits.  */
		     end;
		     argument_list.arg_ptrs (arg_num) = bit_vec_ptr;
		end;
		else if argument_desc.type = Type_char
		then do;
		     if ^argument_desc.packed & mod (argument_desc.size, 4) ^= 0
		     then do;			/*  Copy onto value stack in aligned format.  */
			unaligned_char_vec_size = argument_desc.size;
			unaligned_char_vec_len = divide (value_ptr -> value_bead.total_data_elements,
			     unaligned_char_vec_size, 21);
			unaligned_char_vec_ptr = value_ptr -> value_bead.data_pointer;
			aligned_char_vec_size = unaligned_char_vec_size;
			aligned_char_vec_len = unaligned_char_vec_len;
			aligned_char_vec_ptr = apl_push_stack_ (size (aligned_char_vec));
			unspec (aligned_char_vec) = ""b; /*  Ensure padding will be zeroes.  */
			do i = 1 to aligned_char_vec_len;
			     aligned_char_vec (i) = unaligned_char_vec (i);
			end;
			argument_list.arg_ptrs (arg_num) = aligned_char_vec_ptr;
		     end;
		     else if list_ptr -> list_bead.semantics_on_stack (member_num)
		     | (member_ptr -> general_bead.symbol & value_ptr -> value_bead.reference_count < 2)
		     then argument_list.arg_ptrs (arg_num) = value_ptr -> value_bead.data_pointer;
		     else do;			/*  Copy onto value stack without conversion.  */
			unaligned_char_vec_size = value_ptr -> value_bead.total_data_elements;
			unaligned_char_vec_len = 1;
			unaligned_char_vec_ptr = apl_push_stack_ (size (unaligned_char_vec));
			unspec (unaligned_char_vec)
			     = unspec (value_ptr -> value_bead.data_pointer -> unaligned_char_vec);
			argument_list.arg_ptrs (arg_num) = unaligned_char_vec_ptr;
		     end;
		end;
		else if argument_desc.type = Type_entry
		then do;
		     module_name_ptr = value_ptr -> value_bead.data_pointer;
		     module_name_len = value_ptr -> value_bead.total_data_elements;
		     module_name_len = length (rtrim (module_name)); /*  Exclude trailing spaces.  */
		     i = verify (module_name, " ");
		     if i > 1
		     then do;			/*  Exclude leading spaces.  */
			module_name_ptr = addr (module_name_ptr -> dummy_chars (i));
			module_name_len = module_name_len - i + 1;
		     end;
		     i = index (module_name, "$");
		     if i > 0
		     then do;			/*  Routine name is explicit.  */
			routine_name_ptr = addr (module_name_ptr -> dummy_chars (i + 1));
			routine_name_len = module_name_len - i;
			module_name_len = i - 1;
		     end;
		     else do;			/*  Segment name is also routine name.  */
			routine_name_ptr = module_name_ptr;
			routine_name_len = module_name_len;
		     end;
		     if length (module_name) < 1 | length (module_name) > 32 | verify (module_name, Token_chars) > 0
		     | length (routine_name) < 1 | length (routine_name) > 32 | verify (routine_name, Token_chars) > 0
		     then call declaration_error ("invalid entry name", marker (arg_num));
		     entry_ptr = apl_push_stack_ (size (entry));
		     call make_entry (module_name, routine_name, entry, status);
		     if status ^= 0
		     then if routine_name = module_name
			then call declaration_error (rtrim (meaning (status)) || "  " || module_name, marker (arg_num));
			else call declaration_error (rtrim (meaning (status)) || "  " || module_name
			     || "$" || routine_name, marker (arg_num));
		     argument_list.arg_ptrs (arg_num) = entry_ptr;
		end;
		else if argument_desc.type = Type_fixed_bin_long
		then do;
		     float_bin_long_vec_len = value_ptr -> value_bead.total_data_elements;
		     float_bin_long_vec_ptr = value_ptr -> value_bead.data_pointer;
		     fixed_bin_long_vec_len = float_bin_long_vec_len;
		     if list_ptr -> list_bead.semantics_on_stack (member_num)
		     then fixed_bin_long_vec_ptr = float_bin_long_vec_ptr;
		     else fixed_bin_long_vec_ptr = apl_push_stack_ (size (fixed_bin_long_vec));
		     size_limit = 2e0**fixed (argument_desc.size, 7);
		     do i = 1 to fixed_bin_long_vec_len;
			if float_bin_long_vec (i) < -size_limit | float_bin_long_vec (i) >= size_limit
			then goto cannot_convert_argument;
			fixed_bin_long_vec (i) = float_bin_long_vec (i);
		     end;
		     argument_list.arg_ptrs (arg_num) = fixed_bin_long_vec_ptr;
		end;
		else if argument_desc.type = Type_fixed_bin_short
		then do;
		     float_bin_long_vec_len = value_ptr -> value_bead.total_data_elements;
		     float_bin_long_vec_ptr = value_ptr -> value_bead.data_pointer;
		     fixed_bin_short_vec_len = float_bin_long_vec_len;
		     if list_ptr -> list_bead.semantics_on_stack (member_num)
		     then fixed_bin_short_vec_ptr = float_bin_long_vec_ptr;
		     else fixed_bin_short_vec_ptr = apl_push_stack_ (size (fixed_bin_short_vec));
		     size_limit = 2e0**fixed (argument_desc.size, 7);
		     do i = 1 to fixed_bin_short_vec_len;
			if float_bin_long_vec (i) < -size_limit | float_bin_long_vec (i) >= size_limit
			then goto cannot_convert_argument;
			fixed_bin_short_vec (i) = float_bin_long_vec (i);
		     end;
		     argument_list.arg_ptrs (arg_num) = fixed_bin_short_vec_ptr;
		end;
		else if argument_desc.type = Type_float_bin_long
		then if list_ptr -> list_bead.semantics_on_stack (member_num)
		     | (member_ptr -> general_bead.symbol & value_ptr -> value_bead.reference_count < 2)
		     then argument_list.arg_ptrs (arg_num) = value_ptr -> value_bead.data_pointer;
		     else do;			/*  Copy onto value stack without conversion.  */
			float_bin_long_vec_len = value_ptr -> value_bead.total_data_elements;
			float_bin_long_vec_ptr = apl_push_stack_ (size (float_bin_long_vec));
			unspec (float_bin_long_vec)
			     = unspec (value_ptr -> value_bead.data_pointer -> float_bin_long_vec);
			argument_list.arg_ptrs (arg_num) = float_bin_long_vec_ptr;
		     end;
		else if argument_desc.type = Type_float_bin_short
		then do;
		     float_bin_long_vec_len = value_ptr -> value_bead.total_data_elements;
		     float_bin_long_vec_ptr = value_ptr -> value_bead.data_pointer;
		     float_bin_short_vec_len = float_bin_long_vec_len;
		     if list_ptr -> list_bead.semantics_on_stack (member_num)
		     then float_bin_short_vec_ptr = float_bin_long_vec_ptr;
		     else float_bin_short_vec_ptr = apl_push_stack_ (size (float_bin_short_vec));
		     do i = 1 to float_bin_short_vec_len;
			float_bin_short_vec (i) = float_bin_long_vec (i);
		     end;
		     argument_list.arg_ptrs (arg_num) = float_bin_short_vec_ptr;
		end;
		else argument_list.arg_ptrs (arg_num) = null; /*  If we missed a conversion, this will tell us.  */
	     end;
	     return;

/*  One of the elements in the APL value is too large to convert to the      */
/*  required format.  Issue a diagnostic pointing to the size field of the   */
/*  appropriate argument declaration.                                        */

cannot_convert_argument:
	     token_idx = marker (arg_num);
	     token_len = 0;
	     call get_next_token;
	     if token = "(" | token = "dim" | token = "dimension"
	     then do;				/*  Skip dimension specification.  */
		do while (token ^= ")");
		     call get_next_token;
		end;
		call get_next_token;
	     end;
	     call get_next_token;			/*  Skip type specification.  */
	     if token = "bin"
	     then call get_next_token;
	     if token = "("
	     then call get_next_token;
	     call declaration_error ("parameter size incompatible with argument", token_idx);
	end convert_arguments;
declaration_error: proc (error_msg, declaration_idx);

/*  Function:  to display a diagnostic about the declaration, indicating     */
/*     where in the declaration the error occurred.  This is done by         */
/*     printing the declaration with a caret under the indicated character.  */

/*  Arguments:                                                               */
/*                                                                           */
/*  error_msg  (Input)                                                       */
/*     the diagnostic to be printed.                                         */
/*                                                                           */
/*  declaration_idx  (Input)                                                 */
/*     the index of the character in the declaration under which the caret   */
/*     is to appear.                                                         */

/*  Global Arguments:                                                        */
/*                                                                           */
/*  declaration  (Input)                                                     */
/*     the declaration in which the error was detected.                      */

dcl  error_msg char (*),
     declaration_idx fixed bin;

dcl  ioa_$nnl entry options (variable);

	     call ioa_$nnl ("^/declaration error:  ^a^/^6x^a^/^vx^a", error_msg, declaration, declaration_idx+5, QAndSign);
	     call error (apl_error_table_$domain, Right_arg);
	end declaration_error;
error:	proc (status, where);

/*  Function:  to return control to APL upon detection of an error.          */

/*  Arguments:                                                               */
/*                                                                           */
/*  status  (Input)                                                          */
/*     the status code describing the error which is to be returned to APL.  */
/*                                                                           */
/*  where  (Input)                                                           */
/*     'Function' if the error is not in an argument, 'Left_arg' if it is in */
/*     the left argument, and 'Right_arg' if it is in the right argument.    */

dcl  status fixed bin (35),
     where fixed bin;

	     operators_argument.error_code = status;
	     if where = Left_arg
	     then operators_argument.where_error = operators_argument.where_error + 1;
	     else if where = Right_arg
	     then operators_argument.where_error = operators_argument.where_error - 1;
	     goto return;
	end error;
generate_argument_desc: proc (member_ptr);

/*  Function:  to generate an argument descriptor for an argument, based on  */
/*     the type, rank and shape fields of its value bead.                    */

/*  Arguments:                                                               */
/*                                                                           */
/*  member_ptr  (Input)                                                      */
/*     the address of the APL symbol or value bead for the argument for      */
/*     which an argument descriptor is to be generated.                      */

/*  Global Arguments:                                                        */
/*                                                                           */
/*  argument_desc  (Output)                                                  */
/*     the argument descriptor generated for the argument.                   */
/*                                                                           */
/*  token_idx  (Input)                                                       */
/*     the index of the token to be associated with this argument in error   */
/*     messages.                                                             */

dcl  member_ptr ptr;

dcl  i fixed bin,
     j fixed bin,
     multiplier fixed bin (35),
     rank fixed bin,
     value_ptr ptr;

	     if member_ptr -> general_bead.symbol
	     then do;
		value_ptr = member_ptr -> symbol_bead.meaning_pointer;
		if value_ptr = null
		then call declaration_error (member_ptr -> symbol_bead.name || " not defined", token_idx);
	     end;
	     else value_ptr = member_ptr;
	     rank = value_ptr -> value_bead.rhorho;
	     if rank > Max_rank
	     then if member_ptr -> general_bead.symbol
		then call declaration_error (member_ptr -> symbol_bead.name || " rank exceeds "
		     || ltrim (char (Max_rank)), token_idx);
		else call declaration_error ("argument rank exceeds " || ltrim (char (Max_rank)), token_idx);
	     argument_desc.flag = "1"b;
	     if string (value_ptr -> value_bead.type) = character_value_type
	     then if rank = 0
		then do;				/*  Argument is character scalar.  */
		     argument_desc.type = Type_char;
		     argument_desc.packed = True;
		     argument_desc.number_dims = rank;
		     argument_desc.size = 1;
		     multiplier = 9;
		end;
		else do;				/*  Argument is character array.  */
		     argument_desc.type = Type_char;
		     argument_desc.packed = True;
		     argument_desc.number_dims = rank - 1;
		     argument_desc.size = value_ptr -> value_bead.rho (rank);
		     multiplier = 9*value_ptr -> value_bead.rho (rank);
		     rank = rank - 1;
		end;
	     else do;				/*  Argument is numeric scalar or array.  */
		argument_desc.type = Type_float_bin_long;
		argument_desc.packed = False;
		argument_desc.number_dims = rank;
		argument_desc.size = 63;
		multiplier = 2;
	     end;
	     do i = 1 to rank;
		j = rank - i + 1;
		argument_desc.lower_bound (j) = 1;
		argument_desc.upper_bound (j) = value_ptr -> value_bead.rho (i);
		argument_desc.multiplier (i) = multiplier;
		multiplier = value_ptr -> value_bead.rho (j)*multiplier;
	     end;
	end generate_argument_desc;
get_next_token: proc;

/*  Function:  to isolate the next token of the declaration.  A token is a   */
/*     string of consecutive letters, digits and underscores, or any other   */
/*     single character, except space (which has no meaning other than as a  */
/*     string delimiter).                                                    */

/*  Global Arguments:                                                        */
/*                                                                           */
/*  declaration  (Input)                                                     */
/*     the string from which the next token is to be selected.               */
/*                                                                           */
/*  token_idx  (Update)                                                      */
/*     the index of the current token of the declaration.                    */
/*                                                                           */
/*  token_len  (Update)                                                      */
/*     the length of the current token of the declaration.                   */

dcl  spaces fixed bin;

	     token_idx = token_idx + token_len;		/*  Skip over current token.  */
	     spaces = verify (substr (declaration, token_idx), " ") - 1;
	     if spaces < 0
	     then spaces = length (substr (declaration, token_idx));
	     token_idx = token_idx + spaces;		/*  Skip over any spaces before next token.  */
	     token_len = verify (substr (declaration, token_idx), Token_chars) - 1;
	     if token_len < 0
	     then token_len = length (substr (declaration, token_idx));
	     else if token_len = 0 & token_idx <= length (declaration)
	     then token_len = 1;
	end get_next_token;
make_entry: proc (module_name, routine_name, entry, status);

/*  Function:  to form an entry value for a routine, given the names of the  */
/*     routine and the module which contains it.  If the module has not yet  */
/*     been initiated, a segment of the same name as that of the module is   */
/*     searched for using the 'apl' search paths.  If nothing is found, the  */
/*     search is continued using the search rules.                           */

/*  Arguments:                                                               */
/*                                                                           */
/*  module_name  (Input)                                                     */
/*     the name of the module containing the desired routine.                */
/*                                                                           */
/*  routine_name  (Input)                                                    */
/*     the name of the desired routine.                                      */
/*                                                                           */
/*  entry  (Output)                                                          */
/*     the entry value of the routine.                                       */
/*                                                                           */
/*  status  (Output)                                                         */
/*     a standard system status code.                                        */

dcl  module_name char (*),
     routine_name char (*),
     entry entry,
     status fixed bin (35);

dcl  hcs_$fs_get_path_name entry (ptr, char (*), fixed bin, char (*), fixed bin (35)),
     hcs_$fs_get_seg_ptr entry (char (*), ptr, fixed bin (35)),
     hcs_$initiate entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35)),
     hcs_$make_entry entry (ptr, char (*), char (*), entry, fixed bin (35)),
     search_paths_$find_dir entry (char (*), ptr, char (*), char (*), char (*), fixed bin (35));

dcl  codeptr builtin;

dcl  our_dir_name char (168) static init ("");

dcl  dir_name char (168),
     our_dir_name_len fixed bin,
     our_ent_name char (32),
     seg_ptr ptr;

	     call hcs_$fs_get_seg_ptr (module_name, seg_ptr, status);
	     if seg_ptr = null
	     then do;				/*  Module not initiated:  try 'apl' search paths.  */
		if our_dir_name = ""
		then call hcs_$fs_get_path_name (codeptr (make_entry), our_dir_name, our_dir_name_len, our_ent_name, status);
		call search_paths_$find_dir ("apl", null, module_name, our_dir_name, dir_name, status);
		if status = 0
		then call hcs_$initiate (dir_name, module_name, module_name, 0, 0, seg_ptr, status);
	     end;
	     call hcs_$make_entry (codeptr (make_entry), module_name, routine_name, entry, status);
	end make_entry;
meaning:	proc (status) returns (char (100));

/*  Function:  to return the meaning of a status code.                       */

/*  Arguments:                                                               */
/*                                                                           */
/*  status  (Input)                                                          */
/*     the status code whose meaning is desired.                             */

dcl  status fixed bin (35);

dcl  convert_status_code_ entry (fixed bin (35), char (8) aligned, char (100) aligned);

dcl  long_info char (100) aligned,
     short_info char (8) aligned;

	     call convert_status_code_ (status, short_info, long_info);
	     return (long_info);
	end meaning;
process_declaration: proc;

/*  Function:  to supervise the building of the argument list, argument      */
/*     descriptors and marker array from the declaration.                    */

/*  Global Arguments:                                                        */
/*                                                                           */
/*  arg_list_arg_count  (Update)                                             */
/*     the number of arguments if we are calling a subroutine, else that     */
/*     number plus one.                                                      */
/*  argument_desc  (Output)                                                  */
/*     the argument descriptors for the parameters of the declaration.       */
/*                                                                           */
/*  argument_list  (Output)                                                  */
/*     the argument list for the routine which is to be called.  The         */
/*     argument value ptrs still need to be filled in.                       */
/*                                                                           */
/*  bits_in_result  (Output)                                                 */
/*     the number of bits of storage that we need to allocate for the return */
/*     value.  (It is zero if we are calling a subroutine or a function      */
/*     whose value has '*' extents.)                                         */
/*                                                                           */
/*  calling_a_function  (Output)                                             */
/*     a flag indicating whether we are calling a function or subroutine.    */
/*                                                                           */
/*  declaration  (Input)                                                     */
/*     a PL/I style entry declaration for the routine to be called.          */
/*                                                                           */
/*  list_ptr  (Input)                                                        */
/*     the address of the list bead for the right argument.                  */
/*                                                                           */
/*  marker  (Output)                                                         */
/*     the indices in 'declaration' of the routine name (element 0) and the  */
/*     start of each parameter declaration (elements 1 -> 'n_members').      */
/*                                                                           */
/*  n_members  (Input)                                                       */
/*     the number of members in the right argument list.                     */

dcl  Letters char (52) static options (constant) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");

dcl  arg_num fixed bin,
     member_ptr ptr,
     module_name char (32),
     more bit (1),
     rank fixed bin,
     routine_name char (32),
     status fixed bin (35);

/*  Extract the module and routine names from the declaration.  */

	     token_idx = 1;
	     token_len = 0;
	     call get_next_token;
	     marker (0) = token_idx;
	     if index (Letters, substr (token, 1, min (1, token_len))) = 0 | token_len > maxlength (module_name)
	     then call declaration_error ("invalid module name", token_idx);
	     module_name = token;
	     call get_next_token;
	     if token = "$"
	     then do;				/*  Extract routine name.  */
		call get_next_token;
		if index (Letters, substr (token, 1, min (1, token_len))) = 0 | token_len > maxlength (routine_name)
		then call declaration_error ("invalid routine name", token_idx);
		routine_name = token;
		call get_next_token;
	     end;
	     else routine_name = module_name;
	     if token = "entry"
	     then call get_next_token;		/*  Ignore superfluous 'entry' attribute.  */

/*  Initialize argument list header.  */

	     calling_a_function = (index (substr (declaration, token_idx), "returns") > 0);
	     if ^calling_a_function
	     then arg_list_arg_count = arg_list_arg_count - 1;
	     argument_list.arg_count = arg_list_arg_count;
	     argument_list.pad1 = ""b;
	     argument_list.call_type = Interseg_call_type;
	     argument_list.desc_count = arg_list_arg_count;
	     argument_list.pad2 = ""b;

/*  Decode any argument declarations into the corresponding descriptors.  */

	     arg_num = 0;
	     if token = "("
	     then do;				/*  Process parameter declarations.  */
		call get_next_token;
		more = (token ^= ")");
		do while (more);
		     arg_num = arg_num + 1;
		     if arg_num >= n_members
		     then call declaration_error ("more parameters than arguments", token_idx);
		     marker (arg_num) = token_idx;
		     argument_list.desc_ptrs (arg_num) = argument_desc_ptr;
		     member_ptr = list_ptr -> list_bead.member_ptr (arg_num + 1);
		     call process_parameter_dcl (member_ptr);
		     argument_desc_ptr = addrel (argument_desc_ptr, size (argument_desc));
		     if token = ","
		     then call get_next_token;
		     else more = False;
		end;
		if token ^= ")"
		then call declaration_error ("invalid syntax", token_idx);
		call get_next_token;
	     end;
	     else if token = "options"
	     then do;				/*  Process 'options (variable)' attribute.  */
		call get_next_token;
		if token ^= "("
		then call declaration_error ("syntax error", token_idx);
		call get_next_token;
		if token ^= "variable"
		then call declaration_error ("syntax error", token_idx);
		call get_next_token;
		if token ^= ")"
		then call declaration_error ("syntax error", token_idx);
		do while (arg_num + 1 < n_members);
		     arg_num = arg_num + 1;
		     marker (arg_num) = token_idx;
		     argument_list.desc_ptrs (arg_num) = argument_desc_ptr;
		     member_ptr = list_ptr -> list_bead.member_ptr (arg_num + 1);
		     call generate_argument_desc (member_ptr);
		     argument_desc_ptr = addrel (argument_desc_ptr, size (argument_desc));
		end;
		call get_next_token;
	     end;
	     if arg_num ^= n_members - 1
	     then call declaration_error ("more arguments than parameters", token_idx);

/*  Decode 'returns' attribute, if any.  */

	     if token = "returns"
	     then do;
		call get_next_token;
		if token ^= "("
		then call declaration_error ("invalid syntax", token_idx);
		call get_next_token;
		marker (arg_num + 1) = token_idx;
		argument_list.desc_ptrs (arg_num + 1) = argument_desc_ptr;
		call process_parameter_dcl (null);
		if token ^= ")"
		then call declaration_error ("invalid syntax", token_idx);
		call get_next_token;
		rank = argument_desc.number_dims;
		if rank < 1
		then if argument_desc.type = Type_bit
		     then bits_in_result = argument_desc.size;
		     else if argument_desc.type = Type_char
		     then bits_in_result = 9*argument_desc.size;
		     else bits_in_result = argument_desc.size + 1;
		else if argument_desc.packed
		then bits_in_result = argument_desc.upper_bound (rank)*argument_desc.multiplier (rank);
		else bits_in_result = 36*argument_desc.upper_bound (rank)*argument_desc.multiplier (rank);
	     end;
	     else bits_in_result = 0;

/*  Check that we have reached the end of the declaration, then locate the   */
/*  routine to be called.                                                    */

	     if token ^= ""
	     then call declaration_error ("invalid_syntax", token_idx);
	     call make_entry (module_name, routine_name, routine, status);
	     if status ^= 0
	     then if routine_name = module_name
		then call declaration_error (rtrim (meaning (status)) || "  " || module_name, marker (0));
		else call declaration_error (rtrim (meaning (status)) || "  " || rtrim (module_name)
		     || "$" || routine_name, marker (0));
	end process_declaration;
process_parameter_dcl: proc (member_ptr);

/*  Function:  to extract the rank, shape, type, size and alignment from an  */
/*  parameter declaration and use that information to build an argument      */
/*  descriptor.                                                              */

/*  Arguments:                                                               */
/*                                                                           */
/*  member_ptr  (Input)                                                      */
/*     the address of the APL symbol or value bead for the argument which    */
/*     corresponds to the parameter declaration, or null if this declaration */
/*     is for the result value.                                              */

/*  Global Arguments:                                                        */
/*                                                                           */
/*  argument_desc  (Output)                                                  */
/*     the argument descriptor built from the parameter declaration.         */
/*                                                                           */
/*  token  (Update)                                                          */
/*     the current token of the declaration.  On input, it will be the first */
/*     token of the parameter declaration.  On output, it will be the first  */
/*     token following the parameter declaration.                            */
/*                                                                           */
/*  token_idx  (Update)                                                      */
/*     the index in the declaration of the current token.                    */
/*                                                                           */
/*  token_len  (Update)                                                      */
/*     the length of the current token.                                      */

dcl  member_ptr ptr;

dcl  sys_info$max_seg_size fixed bin (19) ext;

dcl  bits_in_value fixed bin (71),
     bits_per_element fixed bin,
     dimensioning_idx fixed bin,
     i fixed bin,
     j fixed bin,
     last_dimension_implicit bit (1) init (False),
     more bit (1),
     multiplier fixed bin (35),
     next_token_idx fixed bin,
     next_token_len fixed bin,
     packed bit (1),
     rank fixed bin,
     shape (Max_rank) fixed bin (35),
     size fixed bin (35),
     type fixed bin,
     value_ptr ptr;

	     value_ptr = member_ptr;
	     if member_ptr ^= null
	     then if member_ptr -> general_bead.symbol
		then value_ptr = member_ptr -> symbol_bead.meaning_pointer;

/*  Verify format of dimension attribute, if any.  */

	     rank = 0;
	     if token = "dim" | token = "dimension"
	     then call get_next_token;		/*  Ignore superfluous 'dim' keyword.  */
	     dimensioning_idx = token_idx;
	     if token = "("
	     then do;
		more = True;
		do while (more);
		     call get_next_token;
		     rank = rank + 1;
		     if rank > Max_rank
		     then call declaration_error ("too many dimensions", token_idx);
		     if token = "*"
		     then if member_ptr = null
			then shape (rank) = 0;
			else if value_ptr = null
			then call declaration_error ("parameter dimension incompatible with argument", token_idx);
			else if rank > value_ptr -> value_bead.rhorho
			then call declaration_error ("parameter has more dimensions than argument", token_idx);
			else shape (rank) = value_ptr -> value_bead.rho (rank);
		     else if verify (token, "0123456789") > 0 | verify (token, "0") = 0 | length (token) > 10
		     then call declaration_error ("invalid dimension", token_idx);
		     else do;
			shape (rank) = bin (token, 35);
			if value_ptr ^= null
			then if rank > value_ptr -> value_bead.rhorho
			     then call declaration_error ("too many dimensions", token_idx);
			     else if shape (rank) ^= value_ptr -> value_bead.rho (rank)
			     then call declaration_error ("parameter dimension incompatible with argument", token_idx);
		     end;
		     call get_next_token;
		     more = (token = ",");
		end;
		if token ^= ")"
		then call declaration_error ("invalid syntax", token_idx);
		call get_next_token;
	     end;

/*  Decode type attribute.  */

	     if token = "bit"
	     then do;
		if value_ptr ^= null
		then if string (value_ptr -> value_bead.type) ^= zero_or_one_value_type
		     then call declaration_error ("parameter type incompatible with argument", token_idx);
		type = Type_bit;
		size = 1;
		packed = True;
		call get_next_token;
	     end;
	     else if token = "char" | token = "character"
	     then do;
		if value_ptr ^= null
		then if string (value_ptr -> value_bead.type) ^= character_value_type
		     then call declaration_error ("parameter type incompatible with argument", token_idx);
		type = Type_char;
		size = 1;
		packed = True;
		call get_next_token;
	     end;
	     else if token = "entry"
	     then do;
		if member_ptr = null
		then call declaration_error ("invalid type for return value", token_idx);
		if rank > 0
		then call declaration_error ("too many dimensions", token_idx);
		if value_ptr = null
		then call declaration_error ("parameter type incompatible with argument", token_idx);
		if string (value_ptr -> general_bead.type) ^= character_value_type
		then call declaration_error ("parameter type incompatible with argument", token_idx);
		type = Type_entry;
		size = 0;
		packed = False;
		last_dimension_implicit = True;
		call get_next_token;
		if token = "options"
		then do;				/*  Flush 'options (variable)' phrase.  */
		     call get_next_token;
		     if token ^= "("
		     then call declaration_error ("invalid syntax", token_idx);
		     call get_next_token;
		     if token ^= "variable"
		     then call declaration_error ("invalid syntax", token_idx);
		     call get_next_token;
		     if token ^= ")"
		     then call declaration_error ("invalid syntax", token_idx);
		     call get_next_token;
		end;
		if token = "("
		then call declaration_error ("invalid syntax", token_idx);
	     end;
	     else if token = "fixed"
	     then do;
		if value_ptr ^= null
		then if string (value_ptr -> value_bead.type) ^= integral_value_type
		     & string (value_ptr -> value_bead.type) ^= zero_or_one_value_type
		     then call declaration_error ("parameter type incompatible with argument", token_idx);
		type = Type_fixed_bin_short;
		size = 17;
		packed = False;
		call get_next_token;
		if token = "bin" | token = "binary"
		then call get_next_token;
		else if token = "dec" | token = "decimal"
		then call declaration_error ("numeric data must be binary", token_idx);
	     end;
	     else if token = "float"
	     then do;
		if value_ptr ^= null
		then if ^value_ptr -> value_bead.numeric_value
		     then call declaration_error ("parameter type incompatible with argument", token_idx);
		type = Type_float_bin_short;
		size = 27;
		packed = False;
		call get_next_token;
		if token = "bin" | token = "binary"
		then call get_next_token;
		else if token = "dec" | token = "decimal"
		then call declaration_error ("numeric data must be binary", token_idx);
	     end;
	     else call declaration_error ("invalid syntax", token_idx);

/*  Decode size attribute, if any.  */

	     if token = "("
	     then do;
		call get_next_token;
		if token = "*"
		then size = 0;
		else if verify (token, "0123456789") = 0 & verify (token, "0") > 0 & token_len <= 10
		then size = bin (token, 35);
		else call declaration_error ("invalid size", token_idx);
		if type = Type_bit
		then do;
		     if size > 36*sys_info$max_seg_size
		     then call declaration_error ("size too big", token_idx);
		     if member_ptr ^= null
		     then if value_ptr = null
			then do;
			     if size = 0
			     then call declaration_error ("parameter size incompatible with argument", token_idx);
			end;
			else if rank = value_ptr -> value_bead.rhorho
			then do;
			     if size = 0
			     then size = 1;
			     else if size ^= 1
			     then call declaration_error ("parameter size incompatible with argument", token_idx);
			end;
			else if rank = value_ptr -> value_bead.rhorho - 1
			then do;
			     if size = 0
			     then size = value_ptr -> value_bead.rho (value_ptr -> value_bead.rhorho);
			     else if size ^= value_ptr -> value_bead.rho (value_ptr -> value_bead.rhorho)
			     then call declaration_error ("parameter size incompatible with argument", token_idx);
			     last_dimension_implicit = True;
			end;
		end;
		else if type = Type_char
		then do;
		     if size > 4*sys_info$max_seg_size
		     then call declaration_error ("size too big", token_idx);
		     if member_ptr ^= null
		     then if value_ptr = null
			then do;
			     if size = 0
			     then call declaration_error ("parameter size incompatible with argument", token_idx);
			end;
			else if rank = value_ptr -> value_bead.rhorho
			then do;
			     if size = 0
			     then size = 1;
			     else if size ^= 1
			     then call declaration_error ("parameter size incompatible with argument", token_idx);
			end;
			else if rank = value_ptr -> value_bead.rhorho - 1
			then do;
			     if size = 0
			     then size = value_ptr -> value_bead.rho (value_ptr -> value_bead.rhorho);
			     else if size ^= value_ptr -> value_bead.rho (value_ptr -> value_bead.rhorho)
			     then call declaration_error ("parameter size incompatible with argument", token_idx);
			     last_dimension_implicit = True;
			end;
		end;
		else if type = Type_fixed_bin_short
		then do;
		     if size > 71
		     then call declaration_error ("size too big", token_idx);
		     else if size > 35
		     then type = Type_fixed_bin_long;
		end;
		else if type = Type_float_bin_short
		then do;
		     if size > 63
		     then call declaration_error ("size too big", token_idx);
		     else if size > 27
		     then type = Type_float_bin_long;
		end;
		call get_next_token;
		if token ^= ")"
		then call declaration_error ("syntax error", token_idx);
		call get_next_token;
	     end;

/*  Decode alignment attribute, if any.  */

	     if token = "al" | token = "aligned"
	     then do;
		packed = False;
		call get_next_token;
	     end;
	     else if token = "unal" | token = "unaligned"
	     then do;
		packed = True;
		if type ^= Type_bit & type ^= Type_char
		then call declaration_error ("numeric data must be aligned", token_idx);
		call get_next_token;
	     end;

/*  Except for possible inconsistencies in the dimensioning, the declaration */
/*  looks good, so fill in the header of the argument descriptor, followed   */
/*  by the dimension info (checking that it is consistent).                  */

	     argument_desc.flag = "1"b;
	     argument_desc.type = type;
	     argument_desc.packed = packed;
	     argument_desc.number_dims = rank;
	     argument_desc.size = size;
	     next_token_idx = token_idx;
	     next_token_len = token_len;
	     token_idx = dimensioning_idx;
	     token_len = 1;
	     if rank > 0
	     then do;
		if type = Type_bit
		then bits_per_element = size;
		else if type = Type_char
		then bits_per_element = 9*size;
		else bits_per_element = size + 1;
		if packed
		then multiplier = bits_per_element;
		else do;
		     multiplier = divide (bits_per_element + 35, 36, 35);
		     bits_per_element = 36*multiplier;
		end;
		bits_in_value = bits_per_element;
		do i = 1 to rank;
		     call get_next_token;
		     bits_in_value = max (1, shape (i))*bits_in_value;
		     if bits_in_value > 36*sys_info$max_seg_size
		     then call declaration_error ("object too large", token_idx);
		     j = rank - i + 1;
		     argument_desc.lower_bound (j) = 1;
		     argument_desc.upper_bound (j) = shape (i);
		     argument_desc.multiplier (i) = multiplier;
		     multiplier = shape (j)*multiplier;
		     call get_next_token;
		end;
	     end;
	     if value_ptr ^= null
	     then if value_ptr -> value_bead.rhorho > rank + fixed (last_dimension_implicit)
		then call declaration_error ("parameter has fewer dimensions than argument", token_idx);
	     token_idx = next_token_idx;
	     token_len = next_token_len;
	end process_parameter_dcl;
round_to_even: proc (num) returns (fixed bin (18));

/*  Function:  to return the smallest even integer not less than a given     */
/*     integer.                                                              */

/*  Arguments:                                                               */
/*                                                                           */
/*  num  (Input)                                                             */
/*     the integer to be rounded.                                            */

dcl  num fixed bin (18);

	     return (num + mod (num, 2));
	end round_to_even;
update_byname_arguments: proc;

/*  Function:  to update the value of all arguments passed by name.          */

/*  Global Arguments:                                                        */
/*                                                                           */
/*  argument_list  (Input)                                                   */
/*     the argument list for the routine just called (so we can find the     */
/*     argument descriptors and values).                                     */
/*                                                                           */
/*  argument_desc  (Input)                                                   */
/*     the argument descriptors (so we can tell the format of the new        */
/*     values).                                                              */
/*                                                                           */
/*  list_ptr  (Input)                                                        */
/*     the address of the list bead for the right argument (so we can find   */
/*     and update the value of the by-name arguments).                       */

dcl  arg_num fixed bin,
     i fixed bin,
     j fixed bin,
     k fixed bin,
     member_num fixed bin,
     member_ptr ptr,
     value_ptr ptr;

	     do member_num = 2 to n_members;
		arg_num = member_num - 1;
		member_ptr = list_ptr -> list_bead.member_ptr (member_num);
		if member_ptr -> general_bead.symbol
		then do;
		     argument_desc_ptr = argument_list.desc_ptrs (arg_num);
		     value_ptr = member_ptr -> symbol_bead.meaning_pointer;
		     if value_ptr = null
		     then do;			/*  Allocate storage for the return value.  */
			call allocate_argument_storage (value_ptr);
			member_ptr -> symbol_bead.meaning_pointer = value_ptr;
		     end;
		     else if value_ptr -> value_bead.reference_count > 1
		     then do;			/*  Allocate unique storage for the return value.  */
			member_ptr -> symbol_bead.meaning_pointer = null;
			value_ptr -> value_bead.reference_count = value_ptr -> value_bead.reference_count - 1;
			call allocate_argument_storage (value_ptr);
			member_ptr -> symbol_bead.meaning_pointer = value_ptr;
		     end;
		     if argument_desc.type = Type_bit
		     then do;
			float_bin_long_vec_len = value_ptr -> value_bead.total_data_elements;
			float_bin_long_vec_ptr = value_ptr -> value_bead.data_pointer;
			if argument_desc.packed | mod (argument_desc.size, 36) = 0
			then do;
			     bit_vec_size = float_bin_long_vec_len;
			     bit_vec_len = 1;
			end;
			else do;
			     bit_vec_size = argument_desc.size;
			     bit_vec_len = divide (float_bin_long_vec_len, bit_vec_size, 24);
			end;
			bit_vec_pad = 36*divide (bit_vec_size + 35, 36, 24) - bit_vec_size;
			bit_vec_ptr = argument_list.arg_ptrs (arg_num);
			i = 1;
			do j = 1 to bit_vec_len;
			     do k = 1 to bit_vec_size;
				float_bin_long_vec (i) = float (substr (bit_vec (j), k, 1));
				i = i + 1;
			     end;
			end;
		     end;
		     else if argument_desc.type = Type_char
		     then do;
			unaligned_char_vec_size = argument_desc.size;
			unaligned_char_vec_len = divide (value_ptr -> value_bead.total_data_elements,
			     unaligned_char_vec_size, 21);
			unaligned_char_vec_ptr = value_ptr -> value_bead.data_pointer;
			if ^argument_desc.packed & mod (argument_desc.size, 4) ^= 0
			then do;
			     aligned_char_vec_size = unaligned_char_vec_size;
			     aligned_char_vec_len = unaligned_char_vec_len;
			     aligned_char_vec_ptr = argument_list.arg_ptrs (arg_num);
			     do i = 1 to aligned_char_vec_len;
				unaligned_char_vec (i) = aligned_char_vec (i);
			     end;
			end;
			else if unaligned_char_vec_ptr ^= argument_list.arg_ptrs (arg_num)
			then unspec (unaligned_char_vec)
			     = unspec (argument_list.arg_ptrs (arg_num) -> unaligned_char_vec);
		     end;
		     else if argument_desc.type = Type_fixed_bin_long
		     then do;
			float_bin_long_vec_len = value_ptr -> value_bead.total_data_elements;
			float_bin_long_vec_ptr = value_ptr -> value_bead.data_pointer;
			fixed_bin_long_vec_len = float_bin_long_vec_len;
			fixed_bin_long_vec_ptr = argument_list.arg_ptrs (arg_num);
			do i = 1 to fixed_bin_long_vec_len /*  Copy to first non-Boolean.  */
				while (fixed_bin_long_vec (i) = 0 | fixed_bin_long_vec (i) = 1);
			     float_bin_long_vec (i) = fixed_bin_long_vec (i);
			end;
			do j = i to fixed_bin_long_vec_len; /*  Copy remainder.  */
			     float_bin_long_vec (j) = fixed_bin_long_vec (j);
			end;
			if i > fixed_bin_long_vec_len
			then string (value_ptr -> value_bead.type) = zero_or_one_value_type;
			else string (value_ptr -> value_bead.type) = integral_value_type;
		     end;
		     else if argument_desc.type = Type_fixed_bin_short
		     then do;
			float_bin_long_vec_len = value_ptr -> value_bead.total_data_elements;
			float_bin_long_vec_ptr = value_ptr -> value_bead.data_pointer;
			fixed_bin_short_vec_len = float_bin_long_vec_len;
			fixed_bin_short_vec_ptr = argument_list.arg_ptrs (arg_num);
			do i = 1 to fixed_bin_short_vec_len /*  Copy to first non-Boolean.  */
				while (fixed_bin_short_vec (i) = 0 | fixed_bin_short_vec (i) = 1);
			     float_bin_long_vec (i) = fixed_bin_short_vec (i);
			end;
			do j = i to fixed_bin_short_vec_len; /*  Copy remainder.  */
			     float_bin_long_vec (j) = fixed_bin_short_vec (j);
			end;
			if i > fixed_bin_short_vec_len
			then string (value_ptr -> value_bead.type) = zero_or_one_value_type;
			else string (value_ptr -> value_bead.type) = integral_value_type;
		     end;
		     else if argument_desc.type = Type_float_bin_long
		     then do;
			float_bin_long_vec_len = value_ptr -> value_bead.total_data_elements;
			float_bin_long_vec_ptr = value_ptr -> value_bead.data_pointer;
			if float_bin_long_vec_ptr ^= argument_list.arg_ptrs (arg_num)
			then unspec (float_bin_long_vec)
			     = unspec (argument_list.arg_ptrs (arg_num) -> float_bin_long_vec);
			do i = 1 to float_bin_long_vec_len /*  Find first non-Boolean.  */
				while (float_bin_long_vec (i) = 0 | float_bin_long_vec (i) = 1);
			end;
			do j = i to float_bin_long_vec_len /*  Find first non-integer.  */
				while (float_bin_long_vec (j) = floor (float_bin_long_vec (j)));
			end;
			if i > float_bin_long_vec_len
			then string (value_ptr -> value_bead.type) = zero_or_one_value_type;
			else if j > float_bin_long_vec_len
			then string (value_ptr -> value_bead.type) = integral_value_type;
			else string (value_ptr -> value_bead.type) = numeric_value_type;
		     end;
		     else if argument_desc.type = Type_float_bin_short
		     then do;
			float_bin_long_vec_len = value_ptr -> value_bead.total_data_elements;
			float_bin_long_vec_ptr = value_ptr -> value_bead.data_pointer;
			float_bin_short_vec_len = float_bin_long_vec_len;
			float_bin_short_vec_ptr = argument_list.arg_ptrs (arg_num);
			do i = 1 to float_bin_short_vec_len /*  Copy to first non-Boolean.  */
				while (float_bin_short_vec (i) = 0 | float_bin_short_vec (i) = 1);
			     float_bin_long_vec (i) = float_bin_short_vec (i);
			end;
			do j = i to float_bin_short_vec_len /*  Copy to first non-integer.  */
				while (float_bin_short_vec (j) = floor (float_bin_short_vec (j)));
			     float_bin_long_vec (j) = float_bin_short_vec (j);
			end;
			do k = j to float_bin_short_vec_len; /*  Copy remainder.  */
			     float_bin_long_vec (k) = float_bin_short_vec (k);
			end;
			if i > float_bin_short_vec_len
			then string (value_ptr -> value_bead.type) = zero_or_one_value_type;
			else if j > float_bin_short_vec_len
			then string (value_ptr -> value_bead.type) = integral_value_type;
			else string (value_ptr -> value_bead.type) = numeric_value_type;
		     end;
		end;
	     end;
	end update_byname_arguments;
validate_usage: proc;

/*  Function:  to ensure that we have been called correctly.                 */

/*  Global Arguments:                                                        */
/*                                                                           */
/*  list_ptr  (Output)                                                       */
/*     the address of the list bead for the right argument list.             */
/*                                                                           */
/*  n_members  (Output)                                                      */
/*     the number of members in the right argument list.                     */

dcl  member_num fixed bin,
     member_ptr ptr;

/*  Insure the usage is monadic and that the right argument is a list.  */

	     if operators_argument.value (Right_arg) = null
	     then call error (apl_error_table_$domain, Function);
	     else if operators_argument.value (Left_arg) ^= null
	     then call error (apl_error_table_$domain, Left_arg);
	     list_ptr = operators_argument.value (Right_arg);
	     if string (list_ptr -> list_bead.type) ^= list_value_type
	     then do;				/*  Convert simple value into 1 member list.  */
		n_members = 1;
		list_ptr = apl_push_stack_ (size (list_bead));
		string (list_ptr -> list_bead.type) = list_value_type;
		list_ptr -> list_bead.number_of_members = 1;
		list_ptr -> list_bead.member_ptr (1) = operators_argument.value (Right_arg);
		unspec (list_ptr -> list_bead.bits) = ""b;
		list_ptr -> list_bead.semantics_on_stack = operators_argument.on_stack (Right_arg);
		operators_argument.value (Right_arg) = list_ptr;
		operators_argument.on_stack = True;
	     end;
	     else n_members = list_ptr -> list_bead.number_of_members;

/*  Find first list member and check that it is of type character.  */

	     member_ptr = list_ptr -> list_bead.member_ptr (1);
	     if string (member_ptr -> value_bead.type) ^= character_value_type
	     then call error (apl_error_table_$domain, Right_arg);
	     declaration_ptr = member_ptr -> value_bead.data_pointer;
	     declaration_len = member_ptr -> value_bead.total_data_elements;

/*  Check that the remaining list members are values, undefined symbols, or  */
/*  symbols pointing to values.                                              */

	     do member_num = 2 to n_members;
		member_ptr = list_ptr -> list_bead.member_ptr (member_num);
		if ^member_ptr -> general_bead.value
		then if ^member_ptr -> general_bead.symbol
		     then call error (apl_error_table_$domain, Right_arg);
		     else if member_ptr -> symbol_bead.meaning_pointer ^= null
		     then if ^member_ptr -> symbol_bead.meaning_pointer -> general_bead.value
			then call error (apl_error_table_$domain, Right_arg);
	     end;
	end validate_usage;
%include apl_characters;
%include apl_external_function;
%include apl_list_bead;
%include apl_operator_bead;
%include apl_symbol_bead;
%include arg_descriptor;
%include arg_list;
return:
     end apl_quadcall_;
