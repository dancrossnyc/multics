/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(87-07-20,Benjamin), approve(87-07-20,MCR7744),
     audit(87-07-21,Lippard), install(87-07-23,MR12.1-1045):
     Fixed so that copy_list will not allow the same segment as input and
     output.  Fixed so that a QUIT and release in the midst of an append_list
     -prompt session will not result in a partial record remaining in the
     database.
                                                   END HISTORY COMMENTS */


/* Command program for the Lister system.

   Written April 20, 1973 by Paul A. Green II
   Modified 740611 by PG to fix duplicate freeing bug
   Modified 740731 by PG to add search function
   Modified 740902 by PG to add expand function
   Modified 741110 by PG to add options to sort and search functions
   Modified 750330 by PG to use assist_delete_
   Modified 750624 by PG to add type function
   Modified 750713 by PG to add command options to print & search
   Modified 760427 by PG to add merge function
   Modified 761101 by PG to convert to Lister command names.
   Modified 770322 by PG to enhance -sm ctl arg to print_list.
   Modified 770606 by PG to enhance sort_list.
   Modified 770630 by PG to have trim_list print number of records deleted.
   Modified 770707 by PG to change calling sequence to lister_sort_.
   Modified 770718 by PG to fix bug 6 (sort_list path fn1 fn2 fails)
   Modified 770718 by PG to implement -sort ctl arg to sort_list and print_list.
   Modified 770721 by PG to rename print_list to process_list.
   Modified 770804 by PG to change from -brief to -totals (bug 7), from suffix_pathname_ to expand_pathname_$add_suffix,
   and to make selecting 0 records an error.
   Modified 770817 by PG to fix bug causing -sort not to work in process_list unless -select also given.
   Modified 770831 by PG to get sort_list to look at all arguments, and to require -select.
   Modified 770913 by PG to eliminate lister_util_ (we can give better error messages w/o it).
   Modified 770921 by PG to get merge_list to agree with revised documentation, and to fix bugs 004 and 013.
   Modified 770922 by PG to rename reduce_list to copy_list, and to add -totals to process_list and copy_list.
   Modified 771018 by PG to fix bug 015 (merge_list path1 path2 failed)
   Modified 780407 by PG to implement -ag for process_list, and to fix bug 16 (delete .lister if error in cls)
   Modified 790620 by PG to fix 032 (mls w/o -fn fails), 033 (mls -fn performs too little validation),
   and 031 (cpls only accepted one control arg!)
   Modified 790711 by PG to fix 036 (pls fails to truncate output seg if no records are selected, and
   -extend is not given), and to do sugg 030 (make argument to -output_file of pls optional).
   Modified 791128 by PG to fix 040 by having everybody check version number of .lister segments.
   Modified 791128 by PG for numeric selection.
   Modified 791211 by PG to bring back expand_list.
   Modified 791217 by PG to fix 047 (change -ex to -ext), and to make default -of ename for pls be listform ename.
   Modified 800306 by PG to fix bug whereby pls -of failed if -of was followed by another ctl arg.
   Modified 800318 by PG to add -all control argument to expand_list.
   Modified 800520 by PB to pass lister_merge_ a status code and check same.
   Modified 800620 by PB to prevent deleting lister file when no w access.
   Modified 800702 by PB to add status_list command.
   Modified 800813 by PB to change status_list to describe_list and add display_list, modify_list and append_list.
   Modified 801008 by PB to have display_list af requote strings.
   Modified 801024 by PB to update v1 files in place and have dils default to display all fields.
   Modified 810106 by PB to allow display_list to specify format > 250 characters.
   Modified 810226 by PB to have pls pass the listform pathname to lister_print_.
   Modified 810615 by PB to distinguish between arguments and control arguments in error messages.
   Modified 810922 by PB to make -bfe work for mdls and have cpls make empty file if no records selected.
   Modified 811022 by PB to have als not allocate null fields.
   Modified 811109 by PB to implement cls -of.
   Modified 830906 by PB to allow -arguments as well as -argument for pls.
   Modified 840521 by PB to add -sort to display_list.
   Modified 840521 by PB to add support for severity.
   Modified 840522 by PB to add -brief_errors to copy_list and sort_list.
   Modified 840524 by PB to add make_list.
   Modified 840615 by PB to add support for archived listforms.
   Modified 840615 by PB to add ssu_ usage stuff.
   Modified 840618 by PB to prevent 0-length output segments from being created
		     by make_list, copy_list, expand_list, and merge_list
		     in error situations.
   Modified 840619 by PB to do general housecleaning and modernization.
   Modified 840621 by PB to change to standalone invocations.
   Modified 840627 by PB to add -prompt to als.
   Renamed  840628 by PB from lister.pl1 to lister_requests_.pl1.
   Modified 841001 by PB to change als -prompt to use command_query_.
   Modified 841024 by PB to comment out the ssu_ usage stuff.
   Modified 841130 by PB to add check in cpls to see if input and output files
		     are the same.
*/

/* format: style3 */
lister_requests_:
     procedure options (packed_decimal);

/* parameters */

dcl  bv_info_ptr ptr parameter;
dcl  bv_sci_ptr ptr parameter;

/* entries */

dcl  adjust_bit_count_ entry (char(168), char(32), bit(1) aligned,
	fixed bin(24), fixed bin(35)),
     com_err_ entry() options(variable),
     command_query_	entry() options(variable),
     cu_$af_arg_ptr_rel entry (fixed bin, ptr, fixed bin (21), fixed bin (35),
	ptr),
     cu_$arg_list_ptr entry () returns (ptr),
     cu_$arg_ptr_rel entry (fixed bin, ptr, fixed bin (21), fixed bin (35), 
	ptr),
     cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin),
     delete_$ptr entry (ptr, bit(36) aligned, char(*), fixed bin(35)),
     expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35)),
     expand_pathname_$add_suffix entry (char(*), char(*), char(*), char(*),
	fixed bin(35)),
     expand_pathname_$component_add_suffix entry (char(*), char(*), char(*),
	char(*), char(*), fixed bin(35)),
     get_pdir_ entry () returns (char (168)),
     get_system_free_area_ entry (ptr),
     get_temp_segment_ entry (char(*), ptr, fixed bin(35)),
     get_wdir_ entry () returns (char (168)),
     ioa_ entry options (variable),
     initiate_file_	entry (char(*), char(*), bit(*), ptr, fixed bin(24),
	fixed bin(35)),
     initiate_file_$component	entry (char(*), char(*), char(*), bit(*), ptr,
	fixed bin(24), fixed bin(35)),
     initiate_file_$create entry (char(*), char(*), bit(*), ptr,
	bit(1) aligned, fixed bin(24), fixed bin(35)),
     iox_$put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35)),
     pathname_ entry (char(*), char(*)) returns(char(168)),
     pathname_$component entry (char(*), char(*), char(*))
	returns(char(194)),
     release_temp_segment_ entry (char(*), ptr, fixed bin(35)),
     ssu_$abort_line entry() options(variable),
     ssu_$arg_list_ptr entry (ptr, ptr),
     ssu_$destroy_invocation entry (ptr),
     ssu_$print_message entry() options(variable),
/*   ssu_$record_usage entry (ptr, ptr, fixed bin(35)), */
     ssu_$return_arg entry (ptr, fixed bin, bit(1) aligned, ptr,
	fixed bin(21)),
     ssu_$standalone_invocation entry (ptr, char(*), char(*), ptr, entry,
	fixed bin(35)),
     suffixed_name_$new_suffix entry (char(*), char(*), char(*), char(32),
	fixed bin(35)),
     terminate_file_ entry (ptr, fixed bin(24), bit(*), fixed bin(35)),
     unique_chars_ entry (bit (*)) returns (char (15));

/* external static */

declare (
         error_table_$active_function fixed bin (35),
         error_table_$bad_arg fixed bin (35),
         error_table_$badopt fixed bin (35),
         error_table_$inconsistent fixed bin (35),
         error_table_$moderr fixed bin (35),
         error_table_$noarg fixed bin (35),
         error_table_$sameseg fixed bin(35),
         error_table_$unimplemented_version fixed bin (35),
         iox_$user_output ptr,
         lister_codes_$cant_convert fixed bin (35),
         lister_codes_$display_unknown_fieldname fixed bin (35),
         lister_codes_$dup_fieldname fixed bin (35),
         lister_codes_$fieldname_not_alpha_start fixed bin (35),
         lister_codes_$listform_unknown_fieldname fixed bin (35),
         lister_codes_$long_fieldname fixed bin (35),
         lister_codes_$master_eq_output fixed bin (35),
         lister_codes_$master_eq_update fixed bin (35),
         lister_codes_$no_current_lister fixed bin (35),
         lister_codes_$undefined_fieldname fixed bin (35),
         lister_codes_$update_eq_output fixed bin (35),
         lister_severity_ fixed bin (35),
         sys_info$max_seg_size fixed bin (19)
     ) external static;

/* automatic */

dcl (
     append_info_ptr ptr,
     arg_already_got bit (1) aligned,
     arg_count fixed bin,
     arg_getter entry (fixed bin, ptr, fixed bin (21), fixed bin (35), ptr) 
	variable,
     arg_index fixed bin,
     arg_length fixed bin (21),
     arg_list_ptr ptr,
     arg_position fixed bin,
     arg_ptr ptr,
     assign_info_ptr ptr,
     brief_errors bit (1) aligned,
     choice_made bit (1) aligned,
     cleanup_handler_established bit (1) aligned,
     code fixed bin (35),
     code2 fixed bin (35),
     command bit (1) aligned,
     componentname char (32),
     delete_output_file_on_error bit (1),
     dummy_bc fixed bin (24),
     dummy_cr bit (1) aligned,
     error_token char (132),
     fdelim char (1),
     first_fn_arg_num fixed bin,
     format_bitcount fixed bin (24),
     format_dname char (168),
     format_ename char (32),
     format_length fixed bin,
     format_ptr ptr,
     function_index fixed bin,
     i fixed bin,
     ignore_code fixed bin (35),
     in_bitcount fixed bin (24),
     in_dname char (168),
     in_ename char (32),
     in_length fixed bin (21),
     input_ptr ptr,
     last_fn_arg_num fixed bin,
     lister_info_ptr ptr,
     my_name char (16),
     n_fields fixed bin,
     name bit (1) aligned,
     next_char_pos_in_listin fixed bin (21),
     out_bitcount fixed bin (24),
     out_dname char (168),
     out_ename char (32),
     output_all_fieldnames bit (1) aligned,
     output_index fixed bin (21),
     output_file_created bit (1) aligned,
     output_ptr ptr,
     overwrite_master_file bit (1) aligned,
     partial_record_appended bit (1) aligned,
     prompting bit (1) aligned,
     saved_version fixed bin,
     sci_ptr ptr,
     segment_output bit (1) aligned,
     select_all bit (1) aligned,
     selected_records_ptr ptr,
     rdelim char (1),
     temp_append_ptr ptr,
     temp_format_len fixed bin (21),
     temp_format_ptr ptr,
     temp_input_len fixed bin (21),
     temp_input_ptr ptr,
     temp_output_ptr ptr,
     truncate bit (1) aligned,
     width fixed bin,
     working_dir char (168)
     ) internal automatic;

dcl 1 local_qi like query_info;

dcl 1 status_info,
    2 print_switches unal,
      3 print_fdelim bit (1),
      3 print_fnames bit (1),
      3 print_rdelim bit (1),
      3 print_totals bit (1),
    2 af bit (1) aligned,
    2 total fixed bin,
    2 retlen fixed bin (21),
    2 retptr ptr,
    2 header bit (1) aligned,
    2 header_specified bit (1) aligned;


declare (first_s, second_s) char (1) aligned,
        (
         flx,
         counts (3),
         merge_type
         ) fixed bin,
        (all_fields, done, fatal_error)
         bit (1) aligned,
         field_list_ptr ptr;

/* based */

dcl  append_str char (append_info.append_length (i)) 
	based (append_info.append_ptr (i)),
     arg_string char (arg_length) based (arg_ptr),
     field_list (n_fields) fixed bin based (field_list_ptr),
     format_string char (format_length) based (format_ptr),
     out_string char (output_index - 1) based (temp_output_ptr),
     ret_string char (retlen) varying based (retptr),
     temp_append_string char ((sys_info$max_seg_size - 1) * 4) varying based (temp_append_ptr),
     temp_input_file char (temp_input_len) based (temp_input_ptr),
     temp_format_string char (temp_format_len) based (temp_format_ptr);

declare 1 append_info (0:field_table.max_field_index) aligned 
	based (append_info_ptr),
        2 append_ptr ptr,
        2 append_length fixed bin (21);

declare 1 assign_info (0:field_table.max_field_index) aligned 
	based (assign_info_ptr),
        2 assign_ptr ptr,
        2 assign_length fixed bin (21);

declare 1 lister_info based (lister_info_ptr),
        2 database,
        3 dname char (168),
        3 ename char (32);

/* builtin functions */

dcl (addr, before, codeptr, dim, divide, hbound, index, lbound, length, null, 
	pointer, rtrim, substr, string, unspec)
     builtin;

/* conditions */

dcl  cleanup condition;

/* internal static */

declare  APPEND fixed bin internal static options (constant) init (13); /* function index */
declare  COPY fixed bin internal static options (constant) init (8); /* function index */
declare  CREATE fixed bin internal static options (constant) init (1); /* function index */
declare  DESCRIBE fixed bin internal static options (constant) init (10); /* function index */
declare  DISPLAY fixed bin internal static options (constant) init (11); /* function index */
declare  EXPAND fixed bin internal static options (constant) init (6); /* function index */
declare  MAKE fixed bin internal static options (constant) init (14); /* function index */
declare  MERGE fixed bin internal static options (constant) init (5); /* function index */
declare  MODIFY fixed bin internal static options (constant) init (12); /* function index */
declare  NL char (1) initial ("
") internal static options (constant);
declare  OFF bit (1) aligned initial ("0"b) internal static options (constant);
declare  ON bit (1) aligned initial ("1"b) internal static options (constant);
declare  PROCESS fixed bin internal static options (constant) init (3); /* function index */
declare  SORT fixed bin internal static options (constant) init (2); /* function index */
declare  TRIM fixed bin internal static options (constant) init (9); /* function index */
declare  process_dir char (168) initial ("") internal static;
declare  lister_version char (6) initial ("11.0d") internal static options (constant);

/* include files */

%include access_mode_values;

%include delete_options;

%include lister_entries;

%include lister_structures;

%include query_info;

%include terminate_file;

/* program */

create_request:
	entry (bv_sci_ptr, bv_info_ptr);
	
	sci_ptr = bv_sci_ptr;
	lister_info_ptr = bv_info_ptr;
	function_index = CREATE;
	my_name = "create";
	command = OFF;
	goto create_common;
	
create_list:
cls:
	entry;

	function_index = CREATE;
	my_name = "create_list";
	command = ON;
	
create_common:
	call initialize;
	out_ename = "";
	
	if ^command
	     then do;
	     if lister_info.database.ename = ""
		then call ssu_$abort_line (sci_ptr, lister_codes_$no_current_lister);
	     out_ename = lister_info.database.ename;
	     out_dname = lister_info.database.dname;
	     arg_ptr = addr (lister_info.database.ename);
	     arg_length = length (rtrim (lister_info.database.ename)) - 7;
	end;
	else do;
	     call get_next_argument;
	     if code ^= 0
		then go to usage_ (function_index);
	end;

	cleanup_handler_established = ON;
	on cleanup call cleanup_handler;

	call get_input_segment ("listin", input_ptr, in_bitcount, code);
	if code ^= 0
	then go to cleanup_and_return;

/* No version number check necessary or possible... */

	print_totals = OFF;
	call get_next_argument;
	do while (code = 0);
	     if arg_string = "-tt" | arg_string = "-totals"
		then print_totals = ON;
	     else if command & (arg_string = "-of" | arg_string = "-output_file")
		then do;
		call get_next_argument;
		if code ^= 0
		     then call ssu_$abort_line (sci_ptr, code, "Following -output_file");
		call expand_pathname_$add_suffix (arg_string, "lister", out_dname, out_ename, code);
		if code ^= 0
		     then call ssu_$abort_line (sci_ptr, code);
	     end;
	     else if ^command & (arg_string = "-if" | arg_string = "-input_file")
		then do;
		call get_next_argument;
		if code ^= 0
		     then call ssu_$abort_line (sci_ptr, code, "Following -input_file");
		call terminate_file_ (input_ptr, 0, TERM_FILE_TERM, code);
		if code ^= 0
		     then call ssu_$abort_line (sci_ptr, code);
		call get_input_segment ("listin", input_ptr, in_bitcount, code);
		if code ^= 0
		     then call ssu_$abort_line (sci_ptr, code);
	     end;
	     else call badarg;
	     		
	     call get_next_argument;
	end;

	if command & out_ename = ""
	     then do;
	     call suffixed_name_$new_suffix (in_ename, "listin", "lister", out_ename, code);
	     if code ^= 0
		then call ssu_$abort_line (sci_ptr, code);
	     out_dname = working_dir;
	end;
			     		
	call get_output_segment (out_dname, out_ename, output_ptr, out_bitcount, code);
	if code ^= 0
	     then goto cleanup_and_return;

	in_length = divide (in_bitcount + 8, 9, 24, 0);
	call lister_compile_listin_ (output_ptr, input_ptr, in_length, area_ptr, n, error_token, code);
	if code ^= 0
	then do;
	     if code ^= error_table_$moderr
	     then do;
		unspec (delete_options) = OFF;
		delete_options.force = ON;
		delete_options.segment = ON;
		delete_options.link = ON;
		delete_options.chase = ON;
		call delete_$ptr (output_ptr, string (delete_options), my_name, ignore_code);
		output_ptr = null;
		call ssu_$abort_line (sci_ptr, code, "^a", error_token);
	     end;
	     else call ssu_$abort_line (sci_ptr, code, "^a", out_ename);
	end;

	if print_totals
	then call ioa_ ("create_list: ^d record^[s^].", n, (n ^= 1));

	call adjust_bit_count_ (out_dname, out_ename, OFF, out_bitcount, code);
	lister_severity_ = 0;

	go to finish;

make_request:
	entry (bv_sci_ptr, bv_info_ptr);
	
	sci_ptr = bv_sci_ptr;
	lister_info_ptr = bv_info_ptr;
	function_index = MAKE;
	my_name = "make";
	command = OFF;
	goto make_common;

make_list:
mkls:	entry;
	
	function_index = MAKE;
	my_name = "make_list";
	command = ON;
	
make_common:
	call initialize;
	delete_output_file_on_error = ON;
		
	if ^command
	     then do;
	     if lister_info.database.ename = ""
		then call ssu_$abort_line (sci_ptr, lister_codes_$no_current_lister);
	     out_dname = lister_info.database.dname;
	     out_ename = lister_info.database.ename;
	     cleanup_handler_established = ON;
	     on cleanup call cleanup_handler;
	end;
	else do;
	     call get_next_argument;
	     if code ^= 0
		then goto usage_ (function_index);

	     cleanup_handler_established = ON;
	     on cleanup call cleanup_handler;
	
	     call expand_pathname_$add_suffix (arg_string, "lister", out_dname, out_ename, code);
	
	     if code ^= 0
		then call ssu_$abort_line (sci_ptr, code);

	end;

	call get_output_segment (out_dname, out_ename, output_ptr, out_bitcount, code);
	if code ^= 0
	     then call ssu_$abort_line (sci_ptr, code);
	
	call get_temp_segment_ (my_name, temp_input_ptr, code);
	
	if code ^= 0
	     then call ssu_$abort_line (sci_ptr, code);

	first_fn_arg_num, last_fn_arg_num = 0;
	
	rdelim = "$";
	fdelim = "=";

	call get_next_argument;

	do while (code = 0);
	     arg_already_got = OFF;
	     if (arg_string = "-delimiter") | (arg_string = "-dm")
		then do;
		call get_next_argument;
		if code ^= 0
		     then call ssu_$abort_line (sci_ptr, code, "Following -delimiter.");
		if arg_length ^= 2
		     then call ssu_$abort_line (sci_ptr, error_table_$bad_arg, "Following -delimiter.  ^a.", arg_string);
		rdelim = substr (arg_string, 1, 1);
		fdelim = substr (arg_string, 2, 1);
	     end;
	     else if (arg_string = "-field_name") | (arg_string = "-fn")
		then do;
		call get_next_argument;
		if code ^= 0
		     then call ssu_$abort_line (sci_ptr, code, "Following -field_name.");
		first_fn_arg_num = arg_index - 1;
		arg_already_got = ON;
		do while (code = 0 & last_fn_arg_num = 0);
		     if arg_length > 0
			then if index (arg_string, "-") = 1
			then last_fn_arg_num = arg_index - 2;
		     else call get_next_argument;
		     else				/* null argument -- compile_listin would choke */
			call ssu_$abort_line (sci_ptr, lister_codes_$fieldname_not_alpha_start, """"".");
		end;
		if last_fn_arg_num = 0
		     then last_fn_arg_num = arg_index - 2;
	     end;
	     else call badarg;
	     if ^arg_already_got
		then call get_next_argument;
	     
	end;
	
	if first_fn_arg_num = 0
	     then call ssu_$abort_line (sci_ptr, error_table_$noarg, "The -field_name control argument is required.");
	
	if first_fn_arg_num > last_fn_arg_num
	     then call ssu_$abort_line (sci_ptr, error_table_$noarg, "Following -field_name.");
	
	temp_input_len = sys_info$max_seg_size * 4;
	substr (temp_input_file, 1, 18) = "Record_delimiter: ";
	substr (temp_input_file, 19, 1) = rdelim; 
	substr (temp_input_file, 20, 2) = ";" || NL;
	substr (temp_input_file, 22, 17) = "Field_delimiter: ";
	substr (temp_input_file, 39, 1) = fdelim;
	substr (temp_input_file, 40, 2) = ";" || NL;
	substr (temp_input_file, 42, 13) = "Field_names: ";
	next_char_pos_in_listin = 55;
	do i = first_fn_arg_num to last_fn_arg_num;
	     call cu_$arg_ptr_rel (i, arg_ptr, arg_length, code, arg_list_ptr);
	     substr (temp_input_file, next_char_pos_in_listin, arg_length + 2) = arg_string || ", ";
	     next_char_pos_in_listin = next_char_pos_in_listin + arg_length + 2;
	end;
	substr (temp_input_file, next_char_pos_in_listin - 2, 2) = ";" || NL;
	substr (temp_input_file, next_char_pos_in_listin, 9) = "Records:" || NL;
	temp_input_len = next_char_pos_in_listin + 8;
	
	call lister_compile_listin_ (output_ptr, temp_input_ptr, temp_input_len, area_ptr, n, error_token, code);

	if code ^= 0
	then do;
	     if code ^= error_table_$moderr
	     then do;
		if index (error_token, " on line") ^= 0
		     then error_token = before (error_token, " on line");
		unspec (delete_options) = OFF;
		delete_options.force = ON;
		delete_options.segment = ON;
		delete_options.link = ON;
		delete_options.chase = ON;
		call delete_$ptr (output_ptr, string (delete_options), my_name, ignore_code);
		output_ptr = null;
		call ssu_$abort_line (sci_ptr, code, "^a", error_token);
	     end;
	     else call ssu_$abort_line (sci_ptr, code, "^a", out_ename);
	end;

	call adjust_bit_count_ (out_dname, out_ename, OFF, out_bitcount, code);

	lister_severity_ = 0;
	
	goto finish;
 
describe_request:
	entry (bv_sci_ptr, bv_info_ptr);
	
	sci_ptr = bv_sci_ptr;
	lister_info_ptr = bv_info_ptr;
	function_index = DESCRIBE;
	my_name = "describe";
	command = OFF;
	goto describe_common;

describe_list:
dls:	entry;

	function_index = DESCRIBE;
	my_name = "describe_list";
	command = ON;

describe_common:
	call initialize;

	if command 
	     then do;
	     call get_next_argument;

	     if code ^= 0
		then goto usage_ (function_index);
	end;

	cleanup_handler_established = ON;
	on cleanup call cleanup_handler;

	call get_input_segment ("lister", in_file_ptr, 0, code);
	if code ^= 0
	then goto cleanup_and_return;
	
	call check_version_number (in_file_ptr, in_dname, in_ename, code);
	if code ^= 0 & saved_version ^= 1		/* OK to process old file. */
	then call ssu_$abort_line (sci_ptr, code, "^a>^a", in_dname, in_ename);

	select_all = ON;
	header_specified = OFF;

	call get_next_argument;
	
	if code ^= 0				/* No more args--give 'em everything. */
	     then unspec (print_switches) = "1111"b;
	else unspec (print_switches) = "0000"b;

	do while (code = 0);
	     arg_already_got = OFF;
	     if (arg_string = "-sel") | (arg_string = "-select")
	     then do;
		select_all = OFF;
		call get_select_arg;
		if code ^= 0
		then call ssu_$abort_line (sci_ptr, code, "^a", arg_string);
	     end;
	     else if (arg_string = "-dm") | (arg_string = "-delimiter")
	     then do;
		call get_next_argument;
		if arg_string = "field"
		then print_fdelim = ON;
		else if arg_string = "record"
		then print_rdelim = ON;
		else do;
		     arg_already_got = ON;
		     print_fdelim = ON;
		     print_rdelim = ON;
		end;
	     end;
	     else if (arg_string = "-fn") | (arg_string = "-field_name")
	     then print_fnames = ON;
	     else if (arg_string = "-tt") | (arg_string = "-totals")
	     then print_totals = ON;
	     else if (arg_string = "-he") | (arg_string = "-header")
	     then do;
		if af
		then call ssu_$abort_line (sci_ptr, error_table_$inconsistent, "^a not allowed for active function usage.", arg_string);
		header = ON;
		header_specified = ON;
	     end;
	     else if (arg_string = "-nhe") | (arg_string = "-no_header")
	     then do;
		header = OFF;
		header_specified = ON;
	     end;
	     else call badarg;
	     if ^arg_already_got
	     then call get_next_argument;
	end;

	if unspec (print_switches) = "0000"b		/* Used -sel alone, */
	then unspec (print_switches) = "1111"b;		/* Gets everything. */
	else if ^select_all then print_totals = ON;	/* -sel implies -tt. */

	if print_totals
	then if ^select_all
	     then total = lister_select_ (in_file_ptr, select_ptr, area_ptr, selected_records_ptr);
	     else total = input_file.n_records;

	call lister_status_ (in_file_ptr, in_ename, select_all, addr (status_info));
	if print_totals & total = 0 & ^select_all
	     then lister_severity_ = 1;
	     else lister_severity_ = 0;

	goto finish;

modify_request:
	entry (bv_sci_ptr, bv_info_ptr);
	
	sci_ptr = bv_sci_ptr;
	lister_info_ptr = bv_info_ptr;
	function_index = MODIFY;
	my_name = "modify";
	command = OFF;
	goto modify_common;

modify_list:
mdls:	entry;

	function_index = MODIFY;
	my_name = "modify_list";
	command = ON;

modify_common:
	call initialize;

	if command
	     then do;
	     call get_next_argument;

	     if code ^= 0
		then goto usage_ (function_index);
	end;

	cleanup_handler_established = ON;
	on cleanup call cleanup_handler;

	call get_input_segment ("lister", in_file_ptr, 0, code);
	if code ^= 0
	then goto cleanup_and_return;

	call check_version_number (in_file_ptr, in_dname, in_ename, code);

	if code ^= 0
	then do;
	     if saved_version = 1
	     then call lister_convert_ (in_file_ptr, code);
	     if code ^= 0
	     then call ssu_$abort_line (sci_ptr, code, "^a>^a", in_dname, in_ename);
	end;

	select_all = ON;
	print_totals = OFF;

	call get_next_argument;
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, error_table_$noarg, "The ""-field_name"" control argument must be specified.");

	do while (code = 0);
	     if (arg_string = "-fn") | (arg_string = "-field_name")
	     then do;
		if assign_info_ptr = null ()
		then do;
		     field_table_ptr = input_file.field_table_offset;
		     allocate assign_info;
		     do i = 0 to field_table.max_field_index;
			assign_ptr (i) = null;
			assign_length (i) = 0;
		     end;
		end;
		call get_next_argument;
		if code ^= 0 
		then call ssu_$abort_line (sci_ptr, error_table_$noarg, "Following ""-field_name"".");
		if index (arg_string, "-") = 1
		then call ssu_$abort_line (sci_ptr, error_table_$noarg, "Following ""-field_name"".");
		i = lister_hash_fid_ (in_file_ptr, (arg_string)); /* Weird stuff happens if not passed by value. */
		if i < 0
		then call ssu_$abort_line (sci_ptr, lister_codes_$undefined_fieldname, "^a", arg_string);
		if assign_ptr (i) ^= null ()
		then call ssu_$abort_line (sci_ptr, error_table_$inconsistent, "Multiple assignments to field ""^a"".", arg_string);
		call get_next_argument;
		name = OFF;
		if code = 0 
		then if (arg_string = "-str" | arg_string = "-string")
		then do;
		     call get_next_argument;
		     name = ON;
		end;
		if code ^= 0 
		then call ssu_$abort_line (sci_ptr, error_table_$noarg, "^/Usage:  -field_name name {-string} value.");
		if (index (arg_string, "-") = 1 & name = OFF)
		then call ssu_$abort_line (sci_ptr, error_table_$noarg, "^/Usage:  -field_name name {-string} value.");
		assign_ptr (i) = arg_ptr;
		assign_length (i) = arg_length;
	     end;
	     else if (arg_string = "-sel") | (arg_string = "-select")
	     then do;
		select_all = OFF;
		call get_select_arg;
		if code ^= 0
		then call ssu_$abort_line (sci_ptr, code, "^a", arg_string);
	     end;
	     else if (arg_string = "-tt") | (arg_string = "-total") | (arg_string = "-totals")
	     then print_totals = ON;
	     else if (arg_string = "-bfe") | (arg_string = "-brief_errors")
	     then brief_errors = ON;
	     else call badarg;
	     call get_next_argument;
	end;

	if assign_info_ptr = null ()
	then call ssu_$abort_line (sci_ptr, error_table_$noarg, "The ""-field_name"" control argument must be specified.");


	if ^select_all
	then do;
	     n = lister_select_ (in_file_ptr, select_ptr, area_ptr, selected_records_ptr);
	     if n = 0 
		then do;
		lister_severity_ = 1;
		if ^brief_errors
		     then call ssu_$abort_line (sci_ptr, 0, "No records were selected.  ^a>^a", in_dname, in_ename);
		call cleanup_handler;
		return;
	     end;
	end;

	call lister_assign_ (in_file_ptr, select_all, selected_records_ptr, assign_info_ptr);

	if print_totals
	then call ioa_ ("^a:  ^d record^[s^] modified.", my_name, n, (n ^= 1));
	lister_severity_ = 0;

	goto finish;

display_request:
	entry (bv_sci_ptr, bv_info_ptr);
	
	sci_ptr = bv_sci_ptr;
	lister_info_ptr = bv_info_ptr;
	function_index = DISPLAY;
	my_name = "display";
	command = OFF;
	goto display_common;

display_list:
dils:	entry;

	function_index = DISPLAY;
	my_name = "display_list";
	command = ON;

display_common:
	call initialize;

	if command 
	     then do;
	     call get_next_argument;
	     if code ^= 0
		then goto usage_ (function_index);
	end;
	
	cleanup_handler_established = ON;
	on cleanup call cleanup_handler;

	call get_input_segment ("lister", in_file_ptr, 0, code);
	if code ^= 0
	then goto cleanup_and_return;

	call check_version_number (in_file_ptr, in_dname, in_ename, code);
	if code ^= 0 & saved_version ^= 1		/* Try to process old file. */
	then call ssu_$abort_line (sci_ptr, code, "^a>^a", in_dname, in_ename);

	select_all = ON;
	call get_temp_segment_ (my_name, temp_format_ptr, code);
	temp_format_len = 0;

	call get_next_argument;

	do while (code = 0);
	     arg_already_got = OFF;
	     if (arg_string = "-fn") | (arg_string = "-field_name")
	     then do;
		call get_next_argument;
		if code ^= 0 
		then call ssu_$abort_line (sci_ptr, error_table_$noarg, "Following ""-field_name"".");
		if index (arg_string, "-") = 1
		then call ssu_$abort_line (sci_ptr, error_table_$noarg, "Following ""-field_name"".");
		temp_format_len = temp_format_len + arg_length + 3;
		substr (temp_format_string, temp_format_len - (arg_length + 2)) = "<" || arg_string || "> ";
		do while ((code = 0) & (^arg_already_got));
		     call get_next_argument;
		     if code = 0
		     then if index (arg_string, "-") = 1
			then arg_already_got = ON;
			else do;
			     temp_format_len = temp_format_len + arg_length + 3;
			     substr (temp_format_string, temp_format_len - (arg_length + 2)) = "<" || arg_string || "> ";
			end;
		end;
	     end;
	     else if (arg_string = "-sel") | (arg_string = "-select")
	     then do;
		select_all = OFF;
		call get_select_arg;
		if code ^= 0
		then call ssu_$abort_line (sci_ptr, code, "^a", arg_string);
	     end;
	     else if (arg_string = "-bfe") | (arg_string = "-brief_errors")
	     then brief_errors = ON;
	     else if arg_string = "-st" | arg_string = "-sort"
	     then do;
		select_all = OFF;
		call get_sort_arg;
		if code ^= 0
		then do;
		     call cleanup_handler;
		     return;
		end;
	     end;
	     else call badarg;
	     if ^arg_already_got
	     then call get_next_argument;
	end;

	if temp_format_len = 0
	then do;
	     field_table_ptr = input_file.field_table_offset;
	     do i = 0 to hbound (field_table.index_to_field_id (*), 1);
		fidp = pointer (field_table.index_to_field_id (i), input_file.area);
		if i ^= 0
		then do;
		     temp_format_len = temp_format_len + 1;
		     substr (temp_format_string, temp_format_len) = " ";
		end;
		temp_format_len = temp_format_len + field_identifier.size + 2;
		substr (temp_format_string, temp_format_len - (field_identifier.size + 1)) = "<" || field_identifier.string || ">";
	     end;
	end;

	if ^select_all | sort_list_ptr ^= null
	then do;
	     n = lister_select_ (in_file_ptr, select_ptr, area_ptr, selected_records_ptr);
	     if n = 0 
	     then do;
		lister_severity_ = 1;
		if ^brief_errors
		     then call ssu_$abort_line (sci_ptr, 0, "No records were selected.  ^a>^a", in_dname, in_ename);
		call cleanup_handler;
		return;
	     end;
	     if sort_list_ptr ^= null
	     then call lister_sort_ (in_file_ptr, selected_records_ptr, sort_list_ptr);
	end;

	if saved_version = 1
	then if index (temp_format_string, ":uid") ^= 0
	     then do;
		call lister_convert_ (in_file_ptr, code);
		if code ^= 0
		then do;
		     code = lister_codes_$cant_convert;
		     call ssu_$abort_line (sci_ptr, code, "^a>^a", in_dname, in_ename);
		end;
	     end;

	if af
	then call lister_format_parse_ (in_file_ptr, area_ptr, "<Begin record:>" || rtrim (temp_format_string) || " <end;>", format_table_ptr, error_token, code);
	else call lister_format_parse_ (in_file_ptr, area_ptr, "<Begin record:>" || rtrim (temp_format_string) || "
<end;>", format_table_ptr, error_token, code);
	if code ^= 0
	then do;
	     if code = lister_codes_$listform_unknown_fieldname /* message would reference LISTFORM & line # */
	     then do;
		code = lister_codes_$display_unknown_fieldname;
		call ssu_$abort_line (sci_ptr, code, "^a", substr (error_token, 1, index (error_token, "
" /* NL */) - 1));
	     end;
	     else call ssu_$abort_line (sci_ptr, code);
	end;

	call get_temp_segment_ (my_name, temp_output_ptr, code);
	if code ^= 0
	then do;
	     call cleanup_handler;
	     return;
	end;
	output_index = 1;

	call lister_print_ (in_file_ptr, format_table_ptr, temp_output_ptr, output_index, select_all, selected_records_ptr, null (), 0, ON, af, "");

	if af
	then ret_string = out_string;
	else call ioa_ ("^a", out_string);

	if n = 0 & ^select_all
	     then lister_severity_ = 1;
	else lister_severity_ = 0;
	
	goto finish;

append_request:
	entry (bv_sci_ptr, bv_info_ptr);
	
	sci_ptr = bv_sci_ptr;
	lister_info_ptr = bv_info_ptr;
	function_index = APPEND;
	my_name = "append";
	command = OFF;
	goto append_common;

append_list:
als:	entry;

	function_index = APPEND;
	my_name = "append_list";
	command = ON;

append_common:
	call initialize;

	if command 
	     then do;
	     call get_next_argument;
	     if code ^= 0
		then goto usage_ (function_index);
	end;

	cleanup_handler_established = ON;
	on cleanup call cleanup_handler;

	call get_input_segment ("lister", in_file_ptr, 0, code);
	if code ^= 0
	then goto cleanup_and_return;

	call check_version_number (in_file_ptr, in_dname, in_ename, code);

	if code ^= 0
	then do;
	     if saved_version = 1
	     then call lister_convert_ (in_file_ptr, code);
	     if code ^= 0
	     then call ssu_$abort_line (sci_ptr, code, "^a>^a", in_dname, in_ename);
	end;

	call get_next_argument;

	field_table_ptr = input_file.field_table_offset;
	allocate append_info set (append_info_ptr);
	append_info.append_length (*) = 0;
	append_info.append_ptr (*) = null ();

	prompting = ON;
	choice_made = OFF;

	do while (code = 0);
	     if (arg_string = "-prompt" | arg_string = "-pmt")
		then do;
		if choice_made = ON & prompting = OFF
		     then call ssu_$abort_line (sci_ptr, error_table_$inconsistent, "-prompt and -field_name.");
		choice_made = ON;
		prompting = ON;
	     end;
	     else if (arg_string = "-fn" | arg_string = "-field_name")
	     then do;
		if choice_made = ON & prompting = ON
		     then call ssu_$abort_line (sci_ptr, error_table_$inconsistent, "-prompt and -field_name.");
		choice_made = ON;
		prompting = OFF;
		call get_next_argument;
		if code ^= 0 
		then call ssu_$abort_line (sci_ptr, error_table_$noarg, "Following ""-field_name"".");
		if index (arg_string, "-") = 1
		then call ssu_$abort_line (sci_ptr, error_table_$noarg, "Following ""-field_name"".");
		i = lister_hash_fid_ (in_file_ptr, (arg_string));
		if i < 0
		then call ssu_$abort_line (sci_ptr, lister_codes_$undefined_fieldname, "^a", arg_string);
		if append_info.append_ptr (i) ^= null
		then call ssu_$abort_line (sci_ptr, error_table_$inconsistent, "Multiple occurrences of field ""^a"".", arg_string);
		call get_next_argument;
		name = OFF;
		if code = 0 
		then if (arg_string = "-str" | arg_string = "-string")
		then do;
		     call get_next_argument;
		     name = ON;
		end;
		if code ^= 0 
		then call ssu_$abort_line (sci_ptr, error_table_$noarg, "^/Usage:  -field_name name {-string} value.");
		if (index (arg_string, "-") = 1 & name = OFF)
		then call ssu_$abort_line (sci_ptr, error_table_$noarg, "^/Usage:  -field_name name {-string} value.");
		append_info.append_ptr (i) = arg_ptr;
		append_info.append_length (i) = arg_length;
		call get_next_argument;
	     end;
	     else call badarg;
	end;

	if prompting
	     then do;
	     call get_temp_segment_ (my_name, temp_append_ptr, code);
	     if code ^= 0
		then call ssu_$abort_line (sci_ptr, code);
	     local_qi.version = query_info_version_5;
	     local_qi.switches.suppress_name_sw = ON;
	     local_qi.switches.cp_escape_control = "01"b;	/* ".." is data */
	     local_qi.switches.suppress_spacing = ON;
	     local_qi.status_code = 0;
	     local_qi.query_code = 0;
	     local_qi.question_iocbp = null;
	     local_qi.answer_iocbp = null;
	     local_qi.repeat_time = 0;
	     local_qi.explanation_ptr = null;
	     local_qi.explanation_len = 0;
	     recordp = lister_create_record_ (in_file_ptr);
	     partial_record_appended = ON;
	     do i = 0 to hbound (field_table.index_to_field_id (*), 1);
		fidp = pointer (field_table.index_to_field_id (i), input_file.area);
		call command_query_ (addr (local_qi), temp_append_string, 
		     my_name, "^/^a:^2x", field_identifier.string);
		if code ^= 0
		     then call ssu_$abort_line (sci_ptr, code);
		if length (temp_append_string) > 0
		     then do;
		     atom_length = length (temp_append_string);
		     allocate atom in (input_file.area) set (atomp);
		     atom = temp_append_string;
		     input_record.field (i) = atomp;
		end;
	     end;
	     partial_record_appended = OFF;
	     call release_temp_segment_ (my_name, temp_append_ptr, code);
	     if code ^= 0
		then call ssu_$abort_line (sci_ptr, code);
	end;
	    
	else do;
	     recordp = lister_create_record_ (in_file_ptr);    /* get pointer to a new record */
	     partial_record_appended = ON;
	     do i = 0 to field_table.max_field_index;
		if append_info.append_length (i) ^= 0	/* allocate each non-null field */
		     then do;
		     atom_length = append_info.append_length (i);
		     allocate atom in (input_file.area) set (atomp);
		     atom = append_str;
		     input_record.field (i) = atomp;
		end;
	     end;
	     partial_record_appended = OFF;
	end;

	lister_severity_ = 0;
	
	free append_info;
	goto finish;

expand_request:
	entry (bv_sci_ptr, bv_info_ptr);
	
	sci_ptr = bv_sci_ptr;
	lister_info_ptr = bv_info_ptr;
	function_index = EXPAND;
	my_name = "expand";
	command = OFF;
	goto expand_common;

expand_list:
els:
	entry;

	function_index = EXPAND;
	my_name = "expand_list";
	command = ON;

expand_common:
	call initialize;

	delete_output_file_on_error = ON;
	
	if command
	     then do;
	     call get_next_argument;
	     if code ^= 0
		then go to usage_ (function_index);
	end;

	cleanup_handler_established = ON;
	on cleanup call cleanup_handler;

	call get_input_and_output_segs ("lister", "listin");
	if code ^= 0
	then go to cleanup_and_return;

	call check_version_number (input_ptr, in_dname, in_ename, code);
	if code ^= 0 & saved_version ^= 1		/* OK to process v1 file. */
	then call ssu_$abort_line (sci_ptr, code, "^a>^a", in_dname, in_ename);

	width = 0;				/* use default width if none given */
	print_totals = OFF;			/* default value */
	output_all_fieldnames = OFF;			/* .. */

	code = 0;
	call get_next_argument;

	do while (code = 0);
	     if arg_string = "-tt" | arg_string = "-totals"
	     then print_totals = ON;
	     else if arg_string = "-ll" | arg_string = "-line_length"
	     then do;
		call get_next_argument;
		if code ^= 0
		then call ssu_$abort_line (sci_ptr, code, "-line_length must be followed by decimal integer.");

		width = cv_dec_check_ (arg_string, code);
		if code ^= 0
		then call ssu_$abort_line (sci_ptr, 0, "^a contains a non-decimal digit in position ^d.", arg_string,
			code);
	     end;
	     else if arg_string = "-a" | arg_string = "-all"
	     then output_all_fieldnames = ON;
	     else call badarg;
	     call get_next_argument;
	end;

	output_index = 1;
	n = lister_expand_ (input_ptr, output_ptr, output_index, width, output_all_fieldnames);

	if print_totals
	then call ioa_ ("expand_list: ^d record^[s^].", n, (n ^= 1));

	out_bitcount = 9 * (output_index - 1);
	call close_output_segment (working_dir, out_ename, output_ptr, out_bitcount, code);
	
	lister_severity_ = 0;
	
	go to finish;

merge_request:
	entry (bv_sci_ptr, bv_info_ptr);
	
	sci_ptr = bv_sci_ptr;
	lister_info_ptr = bv_info_ptr;
	function_index = MERGE;
	my_name = "merge";
	command = OFF;
	goto merge_common;

merge_list:
mls:
	entry;

	function_index = MERGE;
	my_name = "merge_list";
	command = ON;

merge_common:
	call initialize;

	delete_output_file_on_error = ON;
	output_file_created = OFF;

	if command
	     then do;
	     call get_next_argument;
	     if code ^= 0
		then go to usage_ (function_index);
	end;
	
	cleanup_handler_established = ON;
	on cleanup call cleanup_handler;

	call get_input_segment ("lister", in_file_ptr, 0, code);
	if code ^= 0
	then go to cleanup_and_return;

	call check_version_number (in_file_ptr, in_dname, in_ename, code);

	if code ^= 0
	then do;
	     if saved_version = 1
	     then call lister_convert_ (in_file_ptr, code);
	     if code ^= 0
	     then call ssu_$abort_line (sci_ptr, code, "^a>^a", in_dname, in_ename);
	end;

	out_dname = in_dname;			/* default, unless changed */
	out_ename = in_ename;			/* .. */

	n_fields = dim (input_file.field_table_offset -> field_table.index_to_field_id, 1);
	allocate field_list set (field_list_ptr) in (system_area);

	call get_next_argument;			/* get update file */
	if code ^= 0
	then go to usage_ (function_index);

	call get_input_segment ("lister", up_file_ptr, 0, code);
	if code ^= 0
	then go to cleanup_and_return;

	call check_version_number (up_file_ptr, in_dname, in_ename, code);
	if code ^= 0 & saved_version ^= 1		/* OK if update is v1 file. */
	then call ssu_$abort_line (sci_ptr, code, "^a>^a", in_dname, in_ename);

	if in_file_ptr = up_file_ptr			/* oh oh */
	then call ssu_$abort_line (sci_ptr, lister_codes_$master_eq_update, "^a>^a", in_dname, in_ename);

	call get_next_argument;			/* get output file (optional) */
	if code = 0
	then if index (arg_string, "-") ^= 1
	     then do;
		call expand_pathname_$add_suffix (arg_string, "lister", out_dname, out_ename, code);
		if code ^= 0
		then call ssu_$abort_line (sci_ptr, code, "^a", arg_string);

		call initiate_file_$create (
		     out_dname, out_ename, RW_ACCESS, out_file_ptr, 
		     output_file_created, dummy_bc, code);
		if out_file_ptr = null
		then call ssu_$abort_line (sci_ptr, code, "^a>^a", out_dname, out_ename);

		call get_next_argument;
	     end;

	if in_file_ptr = out_file_ptr			/* oh oh (2) */
	then call ssu_$abort_line (sci_ptr, lister_codes_$master_eq_output, "^a>^a", out_dname, out_ename);

	if up_file_ptr = out_file_ptr			/* oh oh (3) */
	then call ssu_$abort_line (sci_ptr, lister_codes_$update_eq_output, "^a>^a", out_dname, out_ename);

	if out_file_ptr = null			/* user didn't specify...overwrite master at end */
	then do;
	     call initiate_file_$create (
		process_dir, "!lister." || unique_chars_ (""b), RW_ACCESS,
		out_file_ptr, dummy_cr, dummy_bc, code2);
	     if out_file_ptr = null
	     then call ssu_$abort_line (sci_ptr, code2, "Trying to create temporary segment in process dir.");
	     overwrite_master_file = ON;
	end;
	else overwrite_master_file = OFF;

	merge_type = MERGE_ADD;			/* defaults */
	flx = 0;					/* .. */
	done = OFF;				/* .. */
	print_totals = OFF;			/* .. */
	all_fields = ON;				/* .. */
	fatal_error = OFF;

	do while (code = 0);
	     if arg_string = "-add"
	     then merge_type = MERGE_ADD;

	     else if arg_string = "-and"
	     then merge_type = MERGE_AND;

	     else if arg_string = "-or"
	     then merge_type = MERGE_OR;

	     else if arg_string = "-sub" | arg_string = "-subtract"
	     then merge_type = MERGE_SUBTRACT;

	     else if arg_string = "-tt" | arg_string = "-totals"
	     then print_totals = ON;

	     else if arg_string = "-fn" | arg_string = "-field_name"
	     then do;
		all_fields = OFF;			/* user is about to specify which fields are wanted */

		call get_next_argument;
		if code ^= 0
		then call ssu_$abort_line (sci_ptr, 0, "-field_name must be followed by one or more field names.");

		done = OFF;
		do while (^done);
		     if index (arg_string, "-") = 1
		     then done = ON;		/* drop out of -field_name loop */
		     else do;
			if length (arg_string) > 32
			then do;
			     call ssu_$print_message (sci_ptr, lister_codes_$long_fieldname, arg_string);
			     fatal_error = ON;
			     n = -2;
			end;
			else n = lister_hash_fid_ (in_file_ptr, (arg_string));
			if n = -1
			then do;
			     call ssu_$print_message (sci_ptr, lister_codes_$undefined_fieldname, arg_string);
			     fatal_error = ON;
			end;

			do i = lbound (field_list, 1) to flx while (field_list (i) ^= n);
			end;

			if i <= flx
			then do;
			     call ssu_$print_message (sci_ptr, lister_codes_$dup_fieldname, arg_string);
			     fatal_error = ON;
			end;

			if flx = hbound (field_list, 1)
			then do;
			     call ssu_$print_message (sci_ptr, 0, "Too many fieldnames after -fn. Limit ^d",
				hbound (field_list, 1));
			     fatal_error = ON;
			end;

			if ^fatal_error
			then do;
			     flx = flx + 1;
			     field_list (flx) = n;
			end;

			call get_next_argument;
			if code ^= 0
			then done = ON;
		     end;
		end;				/* end of do while (^done); */
	     end;
	     else call badarg;

	     if done				/* skip call if just came out of -field_name section */
	     then done = OFF;			/* but call next time */
	     else call get_next_argument;
	end;

	if fatal_error
	then go to cleanup_and_return;

	if all_fields
	then do;
	     field_table_ptr = input_file.field_table_offset;
	     n = MIN_FIELD_INDEX;
	     do flx = lbound (field_list, 1) to hbound (field_list, 1);
		field_list (flx) = n;
		n = n + 1;
	     end;
	     flx = flx - 1;
	end;

	counts = lister_merge_ (in_file_ptr, up_file_ptr, out_file_ptr, field_list, flx, merge_type, code);

	if code ^= 0 
	     then call ssu_$abort_line (sci_ptr, code);

	if print_totals
	then do;
	     if counts (1) = 1 & counts (2) = 1
	     then first_s = "";
	     else first_s = "s";

	     if counts (3) = 1
	     then second_s = "";
	     else second_s = "s";

	     call ioa_ ("merge_list: ^d master and ^d update record^a merged into ^d output record^a.", counts (1),
		counts (2), first_s, counts (3), second_s);
	end;

	free field_list;
	if overwrite_master_file
	then do;

/* Copy the items individually in order to generate a call to area_assign_.
   This routine will optimize copying the area, whereas assigning the
   whole level-1 structures will generate inline code to copy all 255K */

	     input_file.field_table_offset = output_file.field_table_offset;
	     input_file.record_head = output_file.record_head;
	     input_file.record_tail = output_file.record_tail;
	     input_file.unused (*) = output_file.unused (*);
	     input_file.next_uid = output_file.next_uid;
	     input_file.version = output_file.version;
	     input_file.n_records = output_file.n_records;
	     input_file.area = output_file.area;
	     unspec (delete_options) = OFF;
	     delete_options.force = ON;
	     delete_options.segment = ON;
	     delete_options.link = ON;
	     delete_options.chase = ON;
	     call delete_$ptr (out_file_ptr, string (delete_options), my_name, code);
	     out_file_ptr = null;
	end;

	call adjust_bit_count_ (out_dname, out_ename, OFF, out_bitcount, code);

	lister_severity_ = 0;
	
	go to finish;

process_request:
	entry (bv_sci_ptr, bv_info_ptr);
	
	sci_ptr = bv_sci_ptr;
	lister_info_ptr = bv_info_ptr;
	function_index = PROCESS;
	my_name = "process";
	command = OFF;
	goto process_common;

process_list:
pls:
	entry;

	function_index = PROCESS;
	my_name = "process_list";
	command = ON;

process_common:
	call initialize;

	delete_output_file_on_error = ON;

	if command
	     then do;
	     call get_next_argument;
	     if code ^= 0
		then go to usage_ (function_index);
	end;

	cleanup_handler_established = ON;
	on cleanup call cleanup_handler;

	call get_input_segment ("lister", in_file_ptr, in_bitcount, code);
	if code ^= 0
	then go to cleanup_and_return;

	call check_version_number (in_file_ptr, in_dname, in_ename, code);
	if code ^= 0 & saved_version ^= 1		/* try to process v1 file. */
	then call ssu_$abort_line (sci_ptr, code, "^a>^a", in_dname, in_ename);

/* Set default listform segment pathname. */

	format_dname = working_dir;
	componentname = "";
	
	call suffixed_name_$new_suffix (in_ename, "lister", "listform", format_ename, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code, "^a", in_ename);

/* Set default list segment pathname. */

	out_dname = working_dir;
	out_ename = substr (format_ename, 1, length (rtrim (format_ename)) - 4);

/* Set defaults for control arguments. */

	segment_output = OFF;			/* .. */
	truncate = ON;				/* .. */
	select_all = ON;				/* .. */
	arg_position = 0;				/* .. */
	print_totals = OFF;			/* .. */

/* Look for user-specified listform pathname. */

	call get_next_argument;
	if code = 0
	then if index (arg_string, "-") ^= 1
	     then do;
		call expand_pathname_$component_add_suffix (arg_string, "listform", format_dname, format_ename, componentname, code);
		if code ^= 0
		then call ssu_$abort_line (sci_ptr, code, "^a", arg_string);
		out_ename = substr (format_ename, 1, length (rtrim (format_ename)) - 4);

		call get_next_argument;
	     end;

/* Process control arguments. */

	do while (code = 0);
	     if (arg_string = "-ext") | (arg_string = "-extend") | (arg_string = "-ex" /* OBSOLETE */)
	     then truncate = OFF;
	     else if arg_string = "-of" | arg_string = "-output_file"
	     then do;
		segment_output = ON;
		call get_next_argument;
		if code = 0
		then if index (arg_string, "-") ^= 1
		     then do;
			call expand_pathname_ (arg_string, out_dname, out_ename, code);
			if code ^= 0
			then call ssu_$abort_line (sci_ptr, code, "^a", arg_string);
		     end;
		     else arg_index = arg_index - 1;
						/* look at this arg again, later */
	     end;
	     else if arg_string = "-sel" | arg_string = "-select"
	     then do;
		select_all = OFF;
		call get_select_arg;
		if code ^= 0
		then do;
		     call cleanup_handler;
		     return;
		end;
	     end;
	     else if arg_string = "-st" | arg_string = "-sort"
	     then do;
		select_all = OFF;
		call get_sort_arg;
		if code ^= 0
		then do;
		     call cleanup_handler;
		     return;
		end;
	     end;
	     else if arg_string = "-tt" | arg_string = "-totals"
	     then print_totals = ON;
	     else if arg_string = "-bfe" | arg_string = "-brief_errors"
	     then brief_errors = ON;
	     else if arg_string = "-ag" | arg_string = "-argument" | arg_string = "-arguments"
	     then do;
		arg_position = arg_index - 1;
		arg_index = arg_count + 1;		/* force loop termination */
	     end;
	     else call badarg;
	     call get_next_argument;
	end;

	if ^segment_output				/* user didn't specify -output_file */
	then do;
	     out_dname = process_dir;
	     out_ename = "!lister." || unique_chars_ (""b);
	end;

	call get_output_segment (out_dname, out_ename, output_ptr, out_bitcount, code);
	if code ^= 0
	then do;
	     call cleanup_handler;
	     return;
	end;

	if truncate
	then output_index = 1;
	else output_index = divide (out_bitcount + 8, 9, 24, 0) + 1;

	if componentname = ""
	     then do;

	     call initiate_file_ (format_dname, format_ename, R_ACCESS, format_ptr, format_bitcount, code);
	     if format_ptr = null
		then call ssu_$abort_line (sci_ptr, code, "^a>^a", format_dname, format_ename);
	end;
	else do;
	     call initiate_file_$component (format_dname, format_ename, componentname, R_ACCESS, format_ptr, format_bitcount, code);
	     if format_ptr = null
		then call ssu_$abort_line (sci_ptr, code, 
		pathname_$component (format_dname, format_ename, componentname));
	end;

	format_length = divide (format_bitcount + 8, 9, 24, 0);

	if saved_version = 1
	then if index (format_string, ":uid") ^= 0
	     then do;
		call lister_convert_ (in_file_ptr, code);
		if code ^= 0
		then call ssu_$abort_line (sci_ptr, lister_codes_$cant_convert, "^a>^a", in_dname, in_ename);
	     end;

	call lister_format_parse_ (in_file_ptr, area_ptr, format_string, format_table_ptr, error_token, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code, "^a", error_token);

	if select_ptr ^= null | sort_list_ptr ^= null
	then do;
	     n = lister_select_ (in_file_ptr, select_ptr, area_ptr, selected_records_ptr);

	     if select_ptr ^= null & n = 0		/* user wanted selection, but we didn't find any */
	     then do;
		out_bitcount = 9 * (output_index - 1);
						/* truncate seg, if necessary */
		call close_output_segment (out_dname, out_ename, output_ptr, out_bitcount, code);

		lister_severity_ = 1;
		if ^brief_errors
		then call ssu_$abort_line (sci_ptr, 0, "No records were selected.  ^a>^a", in_dname, in_ename);
		call cleanup_handler;
		return;
	     end;

	     if sort_list_ptr ^= null
	     then call lister_sort_ (in_file_ptr, selected_records_ptr, sort_list_ptr);
	end;
	else n = input_file.n_records;

	call lister_print_ (in_file_ptr, format_table_ptr, output_ptr, output_index, select_all, selected_records_ptr,
	     arg_list_ptr, arg_position, brief_errors, OFF, rtrim (format_dname) || ">" || format_ename);

	if ^segment_output
	then do;
	     call iox_$put_chars (iox_$user_output, output_ptr, output_index - 1, code);
	     if code ^= 0
	     then call ssu_$abort_line (sci_ptr, code, "While writing on user_output");

	     unspec (delete_options) = OFF;
	     delete_options.force = ON;
	     delete_options.segment = ON;
	     delete_options.link = ON;
	     delete_options.chase = ON;
	     call delete_$ptr (output_ptr, string (delete_options), my_name, code);
	     output_ptr = null;
	end;
	else do;
	     out_bitcount = 9 * (output_index - 1);
	     call close_output_segment (out_dname, out_ename, output_ptr, out_bitcount, code);
	end;
	
	if print_totals
	then call ioa_ ("process_list: ^d record^[s^] processed.", n, (n ^= 1));

	lister_severity_ = 0;
	
	go to finish;

copy_request:
	entry (bv_sci_ptr, bv_info_ptr);
	
	sci_ptr = bv_sci_ptr;
	lister_info_ptr = bv_info_ptr;
	function_index = COPY;
	my_name = "copy";
	command = OFF;
	goto copy_common;

copy_list:
cpls:
	entry;

	function_index = COPY;
	my_name = "copy_list";
	command = ON;

copy_common:
	call initialize;
	
	delete_output_file_on_error = ON;

	if command
	     then do;
	     call get_next_argument;
	     if code ^= 0
		then go to usage_ (function_index);
	end;

	cleanup_handler_established = ON;
	on cleanup call cleanup_handler;

	call get_input_segment ("lister", in_file_ptr, 0, code);
	if code ^= 0
	then go to cleanup_and_return;

	call check_version_number (in_file_ptr, in_dname, in_ename, code);
	if code ^= 0 & saved_version ^= 1		/* Try to process v1 file. */
	then call ssu_$abort_line (sci_ptr, code, "^a>^a", in_dname, in_ename);

	call get_next_argument;
	if code ^= 0
	then go to usage_ (function_index);

	call expand_pathname_$add_suffix (arg_string, "lister", out_dname, out_ename, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code, "^a", arg_string);

	call initiate_file_$create (
	     out_dname, out_ename, RW_ACCESS, out_file_ptr, 
	     output_file_created, dummy_bc, code);
	if out_file_ptr = null
	then call ssu_$abort_line (sci_ptr, code, "^a>^a", out_dname, out_ename);

	if in_file_ptr = out_file_ptr
	     then call ssu_$abort_line (sci_ptr, error_table_$sameseg, 
	     "^a", pathname_ (out_dname, out_ename));

	print_totals = OFF;			/* default value */
	select_ptr = null;				/* .. */

	call get_next_argument;
	do while (code = 0);
	     if arg_string = "-sel" | arg_string = "-select"
	     then do;
		call get_select_arg;
		if code ^= 0
		then do;
		     call cleanup_handler;
		     return;
		end;
	     end;
	     else if arg_string = "-tt" | arg_string = "-totals"
	     then print_totals = ON;
	     else if arg_string = "-bfe" | arg_string = "-brief_errors"
	     then brief_errors = ON;
	     else call badarg;
	     call get_next_argument;
	end;

	n = lister_select_ (in_file_ptr, select_ptr, area_ptr, selected_records_ptr);

	call lister_copy_file_head_ (in_file_ptr, out_file_ptr);
	if n ^= 0					/* Only copy when some are selected */
	     then call lister_copy_records_ (in_file_ptr, out_file_ptr, selected_records_ptr);
	else if ^brief_errors 
	     then call ssu_$print_message (sci_ptr, 0, "No records were selected.  ^a>^a", in_dname, in_ename);

	call adjust_bit_count_ (out_dname, out_ename, OFF, out_bitcount, code);
	
	if print_totals
	then call ioa_ ("copy_list: ^d record^[s^] copied.", n, (n ^= 1));

	if select_ptr ^= null & n = 0
	     then lister_severity_ = 1;
	else lister_severity_ = 0;
	
	go to finish;

sort_request:
	entry (bv_sci_ptr, bv_info_ptr);
	
	sci_ptr = bv_sci_ptr;
	lister_info_ptr = bv_info_ptr;
	function_index = SORT;
	my_name = "sort";
	command = OFF;
	goto sort_common;

sort_list:
sls:
	entry;

	function_index = SORT;
	my_name = "sort_list";
	command = ON;

sort_common:
	call initialize;

	if command
	     then do;
	     call get_next_argument;
	     if code ^= 0
		then go to usage_ (function_index);
	end;

	cleanup_handler_established = ON;
	on cleanup call cleanup_handler;

	call get_input_segment ("lister", in_file_ptr, 0, code);
	if code ^= 0
	then go to cleanup_and_return;

	call check_version_number (in_file_ptr, in_dname, in_ename, code);

	if code ^= 0
	then do;
	     if saved_version = 1
	     then call lister_convert_ (in_file_ptr, code);
	     if code ^= 0
	     then call ssu_$abort_line (sci_ptr, code, "^a>^a", in_dname, in_ename);
	end;

	call get_next_argument;
	do while (code = 0);
	     if arg_string = "-st" | arg_string = "-sort"
	     then do;
		call get_sort_arg;
		if code ^= 0
		then do;
		     call cleanup_handler;
		     return;
		end;
	     end;
	     else if arg_string = "-bfe" | arg_string = "-brief_errors"
	     then brief_errors = ON;
	     else call badarg;

	     call get_next_argument;
	end;

	if sort_list_ptr = null
	then go to usage_ (function_index);

	n = lister_select_ (in_file_ptr, null, area_ptr, selected_records_ptr);

	if n = 0					/* no records selected */
	then do;
	     lister_severity_ = 1;
	     if ^brief_errors
	     then call ssu_$abort_line (sci_ptr, 0, "No records were selected.  ^a>^a", in_dname, in_ename);
	     call cleanup_handler;
	     return;
	end;

	call lister_sort_ (in_file_ptr, selected_records_ptr, sort_list_ptr);

	input_file.record_head = selected_records_ptr -> list_node.list (1);

	do i = 1 to n - 1;
	     selected_records_ptr -> list_node.list (i) -> input_record.next =
		selected_records_ptr -> list_node.list (i + 1);
	end;

	selected_records_ptr -> list_node.list (n) -> input_record.next = null;
	input_file.record_tail = selected_records_ptr -> list_node.list (n);

	lister_severity_ = 0;
	
	go to finish;

trim_request:
	entry (bv_sci_ptr, bv_info_ptr);
	
	sci_ptr = bv_sci_ptr;
	lister_info_ptr = bv_info_ptr;
	function_index = TRIM;
	my_name = "trim";
	command = OFF;
	goto trim_common;

trim_list:
tls:
	entry;

	function_index = TRIM;
	my_name = "trim_list";
	command = ON;

trim_common:
	call initialize;

	if command
	     then do;
	     call get_next_argument;
	     if code ^= 0
		then go to usage_ (function_index);
	end;

	cleanup_handler_established = ON;
	on cleanup call cleanup_handler;

	call get_input_segment ("lister", in_file_ptr, 0, code);
	if code ^= 0
	then go to cleanup_and_return;

	call check_version_number (in_file_ptr, in_dname, in_ename, code);

	if code ^= 0
	then do;
	     if saved_version = 1
	     then call lister_convert_ (in_file_ptr, code);
	     if code ^= 0
	     then call ssu_$abort_line (sci_ptr, code, "^a>^a", in_dname, in_ename);
	end;

	print_totals = OFF;
	call get_next_argument;

	do while (code = 0);
	     if arg_string = "-sel" | arg_string = "-select"
	     then do;
		call get_select_arg;
		if code ^= 0
		then do;
		     call cleanup_handler;
		     return;
		end;
	     end;
	     else if arg_string = "-tt" | arg_string = "-totals"
	     then print_totals = ON;
	     else call badarg;

	     call get_next_argument;
	end;

	if select_ptr = null			/* -select not given */
	then call ssu_$abort_line (sci_ptr, error_table_$noarg, "-select must be specified.");

	n = lister_select_ (in_file_ptr, select_ptr, area_ptr, selected_records_ptr);
	call lister_delete_ (in_file_ptr, selected_records_ptr);

	if print_totals
	then call ioa_ ("trim_list: ^d record^[s^] deleted.", n, (n ^= 1));

	if n = 0
	     then lister_severity_ = 1;
	else lister_severity_ = 0;
	
	go to finish;

finish:
	if arg_index <= arg_count
	then call ssu_$print_message (sci_ptr, 0, "Extra arguments after #^d ignored.", arg_index - 1);
	delete_output_file_on_error = OFF;		/* no errors when going to finish */

cleanup_and_return:
	if command
	     then call ssu_$destroy_invocation (sci_ptr);
	     
	if cleanup_handler_established
	     then call cleanup_handler;
	return;

usage_ (1):					/* create */
	call ssu_$abort_line (sci_ptr, 0, "Usage: ^a path {-totals(-tt)}", my_name);

usage_ (2):					/* sort */
	call ssu_$abort_line (sci_ptr, 0,
	     "Usage: ^a path -sort ""sort string"" {-brief_errors(-bfe)}^/where sort string is: " ||
	     "field_name {-ascending(-asc)|-descending(-dsc)|-numeric(-num)|-alphabetic(-alp)}...",
	     my_name);

usage_ (3):					/* process */
	call ssu_$abort_line (sci_ptr, 0,
	     "Usage: ^a path {fmt_path} {-output_file(-of) {path}|-select(-sel) " || 
	     "select_expr|-sort(-st) sort_string|-extend(-ext)|-totals(-tt)", my_name);

usage_ (5):					/* merge */
	call ssu_$abort_line (sci_ptr, 0,
	     "Usage: ^a in_path up_path {out_path} {-add|-and|-or|-subtract(-sub)" || 
	     "|-field_name(-fn) fn1 ... fnK|-totals(-tt)}", my_name);

usage_ (6):					/* expand */
	call ssu_$abort_line (sci_ptr, 0, "Usage: ^a path {-totals(-tt)|-line_length(-ll) N|-all(-a)}",
	     my_name);

usage_ (8):					/* copy */
	call ssu_$abort_line (sci_ptr, 0, "Usage: ^a in_path out_path {-select(-sel) " ||
	     "select_expr|-totals(-tt)|-brief_errors(-bfe)}", my_name);

usage_ (9):					/* trim */
	call ssu_$abort_line (sci_ptr, 0, "Usage: ^a path -select(-sel) select_expr {-totals(-tt)}", 
	     my_name);
usage_ (10):					/* describe */
	call ssu_$abort_line (sci_ptr, 0, "Usage: ^a path {-field_name(-fn)|-totals(-tt)|" ||
	     "-delimiter(-dm) {record|field}|-select(-sel) select_expr}", my_name);
usage_ (11):					/* display */
	call ssu_$abort_line (sci_ptr, 0, "Usage: ^a path -field_name(-fn) name1 ... nameN " ||
	     "{-select(-sel) select_expr|-brief_errors(-bfe)}", my_name);
usage_ (12):					/* modify	     */
	call ssu_$abort_line (sci_ptr, 0, "Usage: ^a path -field_name(-fn) field_name " ||
	     "{-string(-str)} field_value {-select(-sel) select_expr|-total(-tt)|-brief_errors(-bfe)}", my_name);
usage_ (13):					/* append	     */
	call ssu_$abort_line (sci_ptr, 0, "Usage: ^a path {-field_name(-fn) field_name " || 
	     "{-string(-str)} field_value}", my_name);
usage_ (14):					/* make	     */
	call ssu_$abort_line (sci_ptr, 0, "Usage: ^a path -field_name(-fn) name1 ... nameN " ||
	     "{-delimiter(-dm) RF}", my_name);

badarg:	proc;
	
	if arg_length < 1
	     then call ssu_$abort_line (sci_ptr, error_table_$bad_arg, "Null argument encountered.");
	else if index (arg_string, "-") = 1
	     then call ssu_$abort_line (sci_ptr, error_table_$badopt, "^a", arg_string);
	else call ssu_$abort_line (sci_ptr, error_table_$bad_arg, "^a", arg_string);

     end badarg;

check_version_number:
	procedure (P_file_ptr, P_dname, P_ename, P_code);

/* parameters */

declare (
         P_file_ptr ptr,
         P_dname char (*),
         P_ename char (*),
         P_code fixed bin (35)
         ) parameter;

/* program */

	     saved_version = P_file_ptr -> input_file.version;
	     if saved_version ^= lister_file_version_2
	     then P_code = error_table_$unimplemented_version;
	     else P_code = 0;
	     return;

	end check_version_number;

cleanup_handler:
	procedure;

/* program */

	     if assign_info_ptr ^= null		/* extents defined in input file. */
	     then free assign_info;			/* so must free first. */

	     if output_ptr ^= null
	     then do;
		if output_file_created & delete_output_file_on_error
		     then do;
		     unspec (delete_options) = OFF;
		     delete_options.force = ON;
		     delete_options.segment = ON;
		     delete_options.link = ON;
		     delete_options.chase = ON;
		     call delete_$ptr (output_ptr, string (delete_options), my_name, ignore_code);
		end;
		else call terminate_file_ (output_ptr, 0, TERM_FILE_TERM, ignore_code);
		output_ptr = null;
	     end;

	     if format_ptr ^= null
	     then do;
		call terminate_file_ (format_ptr, 0, TERM_FILE_TERM, ignore_code);
		format_ptr = null;
	     end;

	     if temp_append_ptr ^= null
		then call release_temp_segment_ (my_name, temp_append_ptr, ignore_code);

	     if temp_format_ptr ^= null
		then call release_temp_segment_ (my_name, temp_format_ptr, ignore_code);

	     if temp_output_ptr ^= null
		then call release_temp_segment_ (my_name, temp_output_ptr, ignore_code);

	     if temp_input_ptr ^= null
		then call release_temp_segment_ (my_name, temp_input_ptr, ignore_code);

	     if input_ptr ^= null
	     then do;
		call terminate_file_ (input_ptr, 0, TERM_FILE_TERM, ignore_code);
		input_ptr = null;
	     end;

	     if partial_record_appended
		then do;
		n = 1;
		allocate list_node 
		     set (selected_records_ptr) in (system_area);
		selected_records_ptr -> list_node.size = 1;
		selected_records_ptr -> list_node.list (1) = recordp;
		call lister_delete_ (in_file_ptr, selected_records_ptr);
		free selected_records_ptr -> list_node in (system_area);
		input_file.next_uid = input_file.next_uid - 1;
	     end;
	     
	     if in_file_ptr ^= out_file_ptr
	     then do;
		if out_file_ptr ^= null
		then do;
		     if output_file_created & delete_output_file_on_error
			then do;
			unspec (delete_options) = OFF;
			delete_options.force = ON;
			delete_options.segment = ON;
			delete_options.link = ON;
			delete_options.chase = ON;
			call delete_$ptr (out_file_ptr, string (delete_options), my_name, code);
		     end;
		     else call terminate_file_ (out_file_ptr, 0, TERM_FILE_TERM, ignore_code);
		     out_file_ptr = null;
		end;
	     end;

	     if in_file_ptr ^= null
	     then do;
		call terminate_file_ (in_file_ptr, 0, TERM_FILE_TERM, ignore_code);
		in_file_ptr = null;
	     end;

	     if up_file_ptr ^= null
	     then do;
		call terminate_file_ (up_file_ptr, 0, TERM_FILE_TERM, ignore_code);
		up_file_ptr = null;
	     end;

	     if select_ptr ^= null
	     then call free_select_expr;

	     if sort_list_ptr ^= null
	     then call free_sort_expr;

	     if format_table_ptr ^= null
	     then call free_format_table;

	     if selected_records_ptr ^= null
	     then do;
		free selected_records_ptr -> list_node in (system_area);
		selected_records_ptr = null;
	     end;

	     return;

	end cleanup_handler;

/* Subroutine to close our output segment (truncate, set bitcount) */

close_output_segment:
	procedure (bv_dir, bv_name, bv_output_ptr, bv_bitcount, bv_code);

/* parameters */

declare (
         bv_dir char (*),
         bv_name char (*),
         bv_output_ptr ptr,
         bv_bitcount fixed bin (24),
         bv_code fixed bin (35)
         ) parameter;

/* program */

	     bv_code = 0;

	     call terminate_file_ (bv_output_ptr, bv_bitcount, TERM_FILE_TRUNC_BC, bv_code);
	     if bv_code ^= 0
		then call ssu_$abort_line (sci_ptr, bv_code, "Attempting to truncate and set bit count on ^a>^a.", bv_dir, bv_name);

	     return;

	end close_output_segment;

free_format_table:
	procedure ();

	     if format_table.literal_table ^= null
	     then do;
		ltp = format_table.literal_table;

		do i = 1 to literal_table.n_literals;
		     atomp = literal_table.literal (i);
		     atom_length = length (atom);
		     free atom in (system_area);
		end;

		free literal_table in (system_area);
	     end;

	     free format_table in (system_area);
	     format_table_ptr = null;
	     return;

	end free_format_table;

free_select_expr:
	procedure ();

/* automatic */

dcl  ltx fixed bin;

/* program */

	     ltp = select_expression.literal_table_ptr;

	     if ltp ^= null
	     then do;
		do ltx = 1 to literal_table.n_literals;
		     atomp = literal_table.literal (ltx);

		     if numeric_atom.flag = numeric_flag
		     then free numeric_atom in (system_area);
		     else do;
			atom_length = length (atom);
			free atom in (system_area);
		     end;
		end;

		free literal_table in (system_area);
	     end;

	     free select_expression in (system_area);
	     select_ptr = null;
	     return;

	end free_select_expr;

free_sort_expr:
	procedure ();

/* program */

	     free sort_list in (system_area);
	     sort_list_ptr = null;
	     return;

	end free_sort_expr;

get_next_argument:
	procedure ();

	     call arg_getter (arg_index, arg_ptr, arg_length, code, arg_list_ptr);
	     arg_index = arg_index + 1;

	end get_next_argument;

get_input_segment:
	procedure (bv_suffix, bv_ptr, bv_bitcount, bv_code);

/* parameters */

declare (
         bv_suffix char (*),
         bv_ptr ptr,
         bv_bitcount fixed bin (24),
         bv_code fixed bin (35)
         ) parameter;

/* program */

	     if command | bv_suffix ^= "lister"
		then do;
		call expand_pathname_$add_suffix (arg_string, bv_suffix, in_dname, in_ename, bv_code);
		if bv_code ^= 0
		     then call ssu_$abort_line (sci_ptr, bv_code, "^a", arg_string);
	     end;
	     else do;
		if lister_info.database.ename = ""
		     then call ssu_$abort_line (sci_ptr, lister_codes_$no_current_lister);
		in_dname = lister_info.database.dname;
		in_ename = lister_info.database.ename;
	     end;

	     call initiate_file_ (in_dname, in_ename, R_ACCESS, bv_ptr, bv_bitcount, bv_code);
	     if bv_ptr = null
	     then call ssu_$abort_line (sci_ptr, bv_code, "^a>^a", in_dname, in_ename);

	     bv_code = 0;
	     return;

	end get_input_segment;

get_input_and_output_segs:
	procedure (bv_in_suffix, bv_out_suffix);

/* parameters */

dcl (
     bv_in_suffix char (*),
     bv_out_suffix char (*)
     ) parameter;

/* program */

	     if command
		then do;
		call expand_pathname_$add_suffix (arg_string, bv_in_suffix, in_dname, in_ename, code);
		if code ^= 0
		     then call ssu_$abort_line (sci_ptr, code, "^a", arg_string);
	     end;
	     else do;
		if lister_info.database.ename = ""
		     then call ssu_$abort_line (sci_ptr, lister_codes_$no_current_lister);
		in_dname = lister_info.database.dname;
		in_ename = lister_info.database.ename;
	     end;

	     call suffixed_name_$new_suffix (in_ename, bv_in_suffix, bv_out_suffix, out_ename, code);
	     if code ^= 0
	     then call ssu_$abort_line (sci_ptr, code, "^a", in_ename);

	     call initiate_file_ (in_dname, in_ename, R_ACCESS, input_ptr, in_bitcount, code);
	     if input_ptr = null
	     then call ssu_$abort_line (sci_ptr, code, "^a>^a", in_dname, in_ename);

	     out_dname = working_dir;
	     call initiate_file_$create (
		out_dname, out_ename, RW_ACCESS, 
		output_ptr, output_file_created, dummy_bc, code);
	     if output_ptr = null
	     then call ssu_$abort_line (sci_ptr, code, "^a>^a", out_dname, out_ename);

	     code = 0;
	     return;

	end get_input_and_output_segs;

/* Subroutine to create (if necessary) our output segment */

get_output_segment:
	procedure (bv_dir, bv_name, bv_output_ptr, bv_bitcount, bv_code);

/* parameters */

declare (
         bv_dir char (*),
         bv_name char (*),
         bv_output_ptr ptr,
         bv_bitcount fixed bin (24),
         bv_code fixed bin (35)
         ) parameter;

/* program */

	     bv_code = 0;

	     call initiate_file_$create (
		bv_dir, bv_name, RW_ACCESS, bv_output_ptr, 
		output_file_created, bv_bitcount, bv_code);
	     if bv_output_ptr = null
	     then call ssu_$abort_line (sci_ptr, bv_code, "Unable to create ^a>^a.", bv_dir, bv_name);

	     return;

	end get_output_segment;

get_select_arg:
	procedure ();

	     call get_next_argument;
	     if code ^= 0
	     then call ssu_$abort_line (sci_ptr, code, "-select must be followed by a select expression.");

	     if saved_version = 1
	     then if index (arg_string, ":uid") ^= 0
		then do;
		     call lister_convert_ (in_file_ptr, code);
		     if code ^= 0
		     then do;
			code = lister_codes_$cant_convert;
			call ssu_$abort_line (sci_ptr, code, "^a>^a", in_dname, in_ename);
		     end;
		end;

	     call lister_compile_select_ (arg_string, in_file_ptr, area_ptr, select_ptr, error_token, code);
	     if code ^= 0
	     then call ssu_$abort_line (sci_ptr, code, "^a", error_token);

	     return;

	end get_select_arg;

get_sort_arg:
	procedure ();

	     call get_next_argument;
	     if code ^= 0
	     then call ssu_$abort_line (sci_ptr, code, "-sort must be followed by a sort string.");

	     call lister_compile_sort_ (arg_string, in_file_ptr, area_ptr, sort_list_ptr, error_token, code);
	     if code ^= 0
	     then call ssu_$abort_line (sci_ptr, code, "^a", error_token);
	     return;

	end get_sort_arg;

abort_entry:
	proc;
	
/* This is where ssu_$abort_line returns for standalone invocations */
/* The charter is to do a non-local goto. */

	goto cleanup_and_return;
	
     end abort_entry;

/* Procedure to initialize a bunch of variables used by most entries, and to initialize
   all variables used by the cleanup handler. NB: this procedure must be quick. */

initialize:
	procedure ();

	     cleanup_handler_established = OFF;
	     if command 
		then do;
		call ssu_$standalone_invocation (sci_ptr, my_name, 
		     lister_version, cu_$arg_list_ptr (), abort_entry,
		     code);
		if code ^= 0
		     then do;
		     call com_err_ (code, my_name);
		     goto cleanup_and_return;
		end;
/*		call ssu_$record_usage (sci_ptr, codeptr (process_list), code);
		if code ^= 0
		     then call ssu_$abort_line (sci_ptr, code); */
	     end;
	     
	     call ssu_$return_arg (sci_ptr, arg_count, af, retptr, retlen);
	     if af				/* Only dls & dils callable as AF, for now. */
	     then if function_index = DESCRIBE | function_index = DISPLAY
		then arg_getter = cu_$af_arg_ptr_rel;
		else call ssu_$abort_line (sci_ptr, error_table_$active_function);
	     else do;
		retptr = null ();
		arg_getter = cu_$arg_ptr_rel;
	     end;
	     arg_index = 1;
	     call ssu_$arg_list_ptr (sci_ptr, arg_list_ptr);

	     brief_errors = OFF;
	     print_totals = OFF;
	     delete_output_file_on_error = OFF;
	     partial_record_appended = OFF;
	     input_ptr = null;			/* initialize variables used in cleanup handler */
	     output_ptr = null;
	     format_ptr = null;
	     in_file_ptr = null;
	     up_file_ptr = null;
	     out_file_ptr = null;
	     area_ptr = null;
	     select_ptr = null;
	     selected_records_ptr = null;
	     sort_list_ptr = null;
	     assign_info_ptr = null;
	     format_table_ptr = null;
	     temp_append_ptr = null;
	     temp_format_ptr = null;
	     temp_output_ptr = null;
	     lister_severity_ = 2;
	     working_dir = get_wdir_ ();

	     if process_dir = ""
	     then process_dir = get_pdir_ ();

	     call get_system_free_area_ (area_ptr);

	end initialize;

     end;
