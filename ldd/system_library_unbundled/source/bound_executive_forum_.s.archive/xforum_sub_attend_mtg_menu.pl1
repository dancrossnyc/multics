/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1985 *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(85-02-19,Davids), approve(86-02-04,MCR7350),
     audit(86-04-24,Gilcrease), install(86-04-24,MR12.0-1048):
     Created by copying the xforum_ent_attend_mtg_menu module.
     
     85-03-19 Davids: Fixed the next_subject procedure so that if no
     unread subject is found it will still update the status
     information.  this requires re-reading the old current message to
     get the status.  This is needed so that deleted and expunged
     transactions found during the search for a new subject are removed
     from unread count displayed in the status line.  Also fixed a
     problem with referencing the last seen transaction when the user
     has just entered a meeting.  The user's current transaction is set
     to his last seen transaction.  The transaction is read, the
     subject recorded and the transaction freed.  If the last seen
     transaction was deleted an error will occur when the transaction
     is freed - the error code returned from the read was not checked.
     Now if the last seen transaction cannot be read the current
     transaction is set to the first transaction (first
     undeleted/unreaped).  If an attempt to read the first transaction
     fails an error is reported and the procedured is exited.
  2) change(85-03-25,Davids), approve(86-02-07,MCR7350),
     audit(86-04-24,Gilcrease), install(86-04-24,MR12.0-1048):
     Added code to options 6 and 9 so that enter_trans is only called
     if the read_only flag for the meeting is off.  If its on an error
     message is output.  This saves the user from having to enter a
     comment only to find out that he cannot do anything with it.
     
     85-03-27 Davids: Replaced code in attend_a_meeting that now is in
     the set_up_meeting entry of xforum_attend_mtg_utilities with a
     call to that entry.  Also modified the code handling the help
     function to reset the title line of the status window and
     redisplay the status and help line windows.  This is needed if the
     user had the general topics menu display.
     
     85-04-04 Davids: Implemented the select_subject procedure and
     added the transactions_processed_message procedure which is used
     by the select_subject procedure.
     
     85-05-06 Davids: Added a test of aam_fidx after the call to
     set_up_meeting in attend_a_meeting.  If aam_fidx is 0 the meeting
     was not opened so a return is done.  Any error message was output
     by set_up_meeting.
  3) change(85-06-05,Davids), approve(86-02-04,MCR7350),
     audit(86-04-24,Gilcrease), install(86-04-24,MR12.0-1048):
     In the select_comment procedure, moved the call to
     xforum_help_line_$push so that it occurs before the ioa call which
     outputs the prompt.  It was after the prompt which caused it to be
     executed after every invalid entry in which case the prompt was
     reissued.  This would cause the help_line stack to fill up.  Also
     added a call to clear the window before an error message is
     output.
     
     85-06-20 Davids: Changed calling sequence of xforum_format_$append
     so that the bit_count parameter which is input/output comes after
     all the input parameters (i.e.  the bit (1) switch).
  4) change(86-02-18,LJAdams), approve(86-02-18,MCR7350),
     audit(86-04-24,Gilcrease), install(86-04-24,MR12.0-1048):
     Setting xforum_meeting_info.current to 0 prior to closing meeting or quit.
  5) change(87-04-15,LJAdams), approve(87-04-22,MCR7684),
     audit(87-07-30,Blair), install(87-08-06,MR12.1-1065):
     Changed to allow_command_processor_ escapes.  Used constants for screen
     options to get rid of magic numbers.
                                                   END HISTORY COMMENTS */

xforum_sub_attend_mtg_menu: proc (xsamm_curr_meeting_index, xsamm_match_bits, xsamm_spy_ptr);

/*
   BEGIN DESCRIPTION

   function:
      This module creates, displays and destroys the subject oriented attend
      meeting menu. It also implements all the functions related to the options
      in the menu.

   description of entry points:
      xforum_sub_attend_mtg_menu: This entry is a simple loop that calls
      the internal procedure attend_a_meeting and then gets the next meeting
      index and calls attend_a_meeting again. The loop is broken when the
      user exits a meeting and indicates that he does not want to go to another
      meeting (attend_a_meeting returns xsamm_more as false) or
      attend_a_meeting is given an invalid meeting index (which will happen if
      there is no next meeting, xsamm_more is again returned as false).

   description of internal procedures:
      attend_a_meeting: This procedure is used to attend a meeting. It first
      checks to be sure that the input meeting index is valid, if not it
      returns (the more flag is false). If it is a valid index it sets up
      condition handlers, initializes the meeting_info structure, gets all
      the forum info on the meeting, and creates the menu. It then displays
      the menu and loops getting user selections and calling procedures to
      execute those selections. When the user stops attending the meeting
      the meeting is closed and the menu destroyed.

      display_trans: This procedure is used to display transaction. The bottom
      window is first cleared. A loop is entered which calls
      xforum_get_selected_trans to get a pointer to a selected transaction,
      the transaction number is used to update the status window and the
      transaction displayed via xforum_format_. The loop continues until
      a invalid_trans_idx error code is returned. Other error codes are
      ignored. The loop is initialized via a call to xforum_get_selected_trans.
      Xforum_get_selected_trans handles all the details of determining what
      transactions have been selected and how to get them in sequential order.

      enter_trans: This procedure is called when replying to a transaction or
      when entering a new transaction. An input flag indicates which operation
      the user is performing. The emacs extension is found by absolute pathname
      passed into emacs_. The absolute pathname is determined by finding the
      absolute pathname of the current module and then changing the entry name.
      This is done via the calls to hcs_$make_ptr and hcs_$fs_get_path_name
      after the here label. A special segment is created in the process dir for
      storing the users transaction. If the user is replying then another
      segment is created for storing the transaction the user is replying to.
      The pointers to these transactions are stored as internal static so the
      segments can be reused. The user's comemnt is added to the forum meeting
      via a call to forum_$enter_trans.

      next_trans: This procedure selects the next transaction as the current
      transaction and displays the transaction via a call to xforum_format_.
      The next transaction is found via a call to xforum_trans_. A subject
      chain will not be followed. The current transaction must be either a
      single transaction or a range of transaction, i.e. I:J for there to be
      a next transaction.

      prev_trans: This procedure selects the previous transaction as the
      current transaction and displays the transaction via a call to
      xforum_format_. The previous transaction is found via a call to
      xforum_trans_. A subject chain will not be followed. The current
      transaction must be either a single transaction or a range of
      transaction, i.e  I:J for there to be a previous transaction.

      list_transaction: This procedure looks remarkably like the display
      procedure. The only differences are that xforum_format_$list is called
      instead of xforum_format_$display.

      select_trans_spec: This procedure prompts the user for a transaction
      spec. Once the spec has been input a call is made to
      xforum_validate_trans_spec to check the spec and set the current
      transactions. The prompting is done via ioa_ instead of via
      command_query. Help processing is handling by actually checking to see if
      the input was a "?" character an calling xcforum_help_$display if it was.

      copy_comments: This procedure uses ioa_ to query the user for a file
      name. A name of ? is checked for an a help message is output via
      xforum_help_. A name of ?? is checked for and a message indicating that
      no menu is available is output. Invalid names are determined
      For the case of a ?, ??, or invalid name the prompt is repeated.
      The users ?, ??, invalid file names and valid file names are recorded
      in the spy structure. invalid file names all have the name "invalid".
      valid file names are recorded as "name" or "pathname" depending on if 
      they contain a > or <. The actual names are not recorded.
      For a valid file name the segment is initiated, if it does not exist it
      is created. If it cannot be created an error is output and the code
      returns. A message is then output saying that the writting is taking
      place. The second part of this procedure looks exactly like the display
      procedure. The only difference is xforum_format_$append is called instead
      of $display and that the number of comments actually processed is
      counted. The last thing that this procedure does is clear the bottom
      window and output a message saying how many transactions were output
      and giving the file name.

      next_unread_trans: This procedure set the current transaction to the next
      unread transaction and then display teh current transaction. The value of
      the next unread transaction is updated by the call to update_status.

      meeting_maintenance: This procedure will be used to generate the meeting
      maintenance menu and respond to selections made from that menu. Currently
      it just outputs a message saying that it is unimplemented.

      update_status: This procedure has three functions. First it updates
      the forum statistics. It sets the seen flag for version 2 forums and
      the last_seen_idx for version 1 meetings (if of course the input trans
      idx is larger than the current last seen idx). Second it updates the
      statistics kept in the meeting list by calling forum_ to get the lastest
      statistics, these statistics of course reflect the updates just entered.
      Third it uses the new statistics to output updated totals and new in the
      status line. NOTE that this procedure is called right BEFORE the
      transaction is displayed. There is therefore a small window when forum
      thinks that the user has seen a transaction but it has not yet been
      displayed. Things were done this way so that the status line could
      reflect the current transaction and the number of new transaction minus
      the transaction just selected before the display was started. The
      alternative would be to have the forum and xforum statics out of sync.

      collect_spy_data: This is exactly the same as every other
      collect_spy_data. See xforum_main_options.

      error: This is exactly the same as every other error. See
      xforum_main_options.

   END DESCRIPTION
*/

/* PARAMETERS */

	dcl     xsamm_curr_meeting_index fixed bin;	/* (input) */
	dcl     xsamm_match_bits	 bit (36) aligned;
	dcl     xsamm_spy_ptr	 ptr;

/* GLOBAL */

/* EXTERNAL STATIC */

	dcl     forum_error_table_$invalid_trans_idx fixed bin (35) ext static;
	dcl     forum_error_table_$trans_deleted fixed bin (35) ext static;
	dcl     forum_error_table_$trans_reaped fixed bin (35) ext static;
	dcl     iox_$user_io	 ptr ext static;


/* ENTRIES */

	dcl     com_err_$suppress_name entry () options (variable);
	dcl     get_temp_segments_	 entry (char (*), (*) ptr, fixed bin (35));
	dcl     ioa_		 entry () options (variable);
	dcl     ioa_$rsnnl		 entry () options (variable);
	dcl     iox_$control	 entry (ptr, char (*), ptr, fixed bin (35));
	dcl     release_temp_segments_ entry (char (*), (*) ptr, fixed bin (35));
	dcl     timer_manager_$sleep	 entry (fixed bin (71), bit (2));
	dcl     window_$bell	 entry (ptr, fixed bin (35));
	dcl     window_$clear_window	 entry (ptr, fixed bin (35));
	dcl     window_$overwrite_text entry (ptr, char (*), fixed bin (35));
	dcl     window_$position_cursor 
                                         entry (ptr, fixed bin, fixed bin, fixed bin (35));
	dcl     window_$sync	 entry (ptr, fixed bin (35));
	dcl     xforum_attend_mtg_utilities$close_meeting
			           entry (ptr, ptr, fixed bin, fixed bin, ptr);
	dcl     xforum_attend_mtg_utilities$copy_to_name
                                         entry (ptr, char (32), ptr, fixed bin (24));
	dcl     xforum_attend_mtg_utilities$enter_trans 
                                         entry (ptr, fixed bin, ptr, bit (1) aligned, bit (1) aligned);
	dcl     xforum_attend_mtg_utilities$next_unread_comment
                                         entry (ptr, fixed bin, fixed bin, ptr);
	dcl     xforum_attend_mtg_utilities$set_up_meeting
                                         entry (ptr, ptr, fixed bin, bit (1) aligned, fixed bin, char (256), char (256));
	dcl     xforum_attend_mtg_utilities$update_status
                                         entry (ptr, fixed bin, char (*), fixed bin, fixed bin);
	dcl     xforum_create_menu_	 entry ((*) char (*) var, ptr, ptr, fixed bin (35));
	dcl     xforum_dyn_menu_$display_and_get_choice
                                         entry ((*) char (*), fixed bin, char (*), char (*), char (*), 
                                         fixed bin, ptr, fixed bin);
	dcl     xforum_dyn_menu_$prompt_instead_of_menu
                                         entry (char (*), char (*), char (*), char (*), char (*), fixed bin,
				 ptr, char (*) var);
	dcl     xforum_format_$append	 entry (ptr, ptr, bit (1) aligned, fixed bin (24), fixed bin (35));
	dcl     xforum_format_$display entry (ptr, bit (1) aligned, fixed bin (35));
	dcl     xforum_get_selected_trans$first
                                         entry (ptr, ptr, fixed bin (35));
	dcl     xforum_get_selected_trans$next
                                         entry (ptr, ptr, fixed bin (35));
	dcl     xforum_get_str_	 entry (char(*) var, ptr, char(*), char(*), char(*) var, fixed bin(35));
	dcl     xforum_help_$get_help	 entry (ptr, char (*), (*) char (*) var, ptr, ptr);
	dcl     xforum_help_line_$change
                                         entry (bit (8), char (*), char (*), char (*));
	dcl     xforum_help_line_$push entry (bit (8), char (*), char (*), char (*));
	dcl     xforum_help_line_$pop	 entry options (variable);
	dcl     xforum_main_options$index_of_next_meeting entry (bit (36) aligned, ptr) returns (fixed bin);
	dcl     xforum_multics_mode	 entry (fixed bin);
	dcl     xforum_redisplay_	 entry options (variable);
	dcl     xforum_status_$update_title
                                         entry (char (*));
	dcl     xforum_status_$redisplay
                                         entry (fixed bin (35));
	dcl     xforum_trans_$next_ref entry (fixed bin, ptr, fixed bin (35));
	dcl     xforum_trans_$prev_ref entry (fixed bin, ptr, fixed bin (35));
	dcl     xforum_trans_$read	 entry (fixed bin, ptr, fixed bin (35));
	dcl     xforum_user_profile$get_menu_always
                                         entry () returns (bit (1));
	dcl     xforum_user_profile$get_multics_mode
                                         entry () returns (bit (1));
	dcl     xforum_window_mgr$check_window_status
                                         entry options (variable);
	dcl     xforum_window_mgr$menu_display
                                         entry (ptr);
	dcl     xforum_window_mgr$menu_get_choice
                                         entry (ptr, bit (1) aligned, fixed bin);
	dcl     xforum_window_mgr$resynch_windows
                                         entry (fixed bin, bit (1));

/* CONDITIONS */

	dcl     cleanup		 condition;
	dcl     exit_executive_forum	 condition;
	dcl     quit		 condition;
	dcl     xforum_redisplay_menu	 condition;

/* INTERNAL AUTOMATIC */

	dcl     xsamm_next_mtg_index	 fixed bin;
	dcl     xsamm_more		 bit (1) aligned;

/* INTERNAL STATIC */


/* CONSTANTS */

	dcl     ALL		 bit (36) aligned init ("111111110000000000000000000000000000"b) internal static options (constant);
	dcl     CHANGED		 bit (36) aligned init ("000000010000000000000000000000000000"b) internal static options (constant);
	dcl     FALSE		 bit (1) aligned init ("0"b) internal static options (constant);
          dcl     MAX_LEN                fixed bin init (256) internal static options (constant); 
	dcl     ME		 char (26) init ("xforum_sub_attend_mtg_menu")
				 internal static options (constant);
	dcl     NL		 char (1) init ("
") internal static options (constant);
	dcl     ON		 bit (1) aligned init ("1"b) internal static options (constant);
	dcl     PARTICIPANT		 bit (36) aligned init ("000100000000000000000000000000000000"b) internal static options (constant);
	dcl     QUERY_USAGE		 char (69) init ("Press  ? and RETURN:help   BREAK:To leave current comments unchanged")
				 internal static options (constant);
          dcl (                          /* SUBJECT MTG CHOICES */
              DISPLAY_UNREAD             fixed bin init (1),
	    DISPLAY_CURRENT            fixed bin init (2),
	    DISPLAY_NEXT               fixed bin init (3),
	    DISPLAY_PREV               fixed bin init (4),
	    DISPLAY_ALL		 fixed bin init (5),
	    REPLY			 fixed bin init (6),
	    NEXT_SUBJ_UNREAD           fixed bin init (7),
	    GET_SUBJECT		 fixed bin init (8),
	    TALK			 fixed bin init (9),
	    COPY_SUBJECT		 fixed bin init (10),
	    SKIP_REST_SUBJ		 fixed bin init (11),
	    GET_COMMENT		 fixed bin init (12),
	    GET_NEXT_MTG		 fixed bin init (13),
	    MTG_MAINTENANCE		 fixed bin init (14)
              )			 int static options (constant);


          dcl (                          /* mtg type */
              GET_ATTENDED               fixed bin init (2),
	    GET_CHANGED		 fixed bin init (3),
              GET_ELIGIBLE               fixed bin init (1)
	    )			 int static options (constant);

/* BUILTINS */

	dcl     addr		 builtin;
	dcl     char		 builtin;
	dcl     convert		 builtin;
	dcl     index		 builtin;
	dcl     length		 builtin;
	dcl     ltrim		 builtin;
	dcl     mod		 builtin;
	dcl     null		 builtin;
	dcl     rtrim		 builtin;
	dcl     string		 builtin;
	dcl     substr		 builtin;
	dcl     verify		 builtin;

/* BASED */


/* INCLUDE FILES */

%include access_mode_values;
%page;
%include forum_dcls;
%page;
%include forum_flags;
%page;
%include forum_user_trans;
%page;
%include menu_dcls;
%page;
%include xforum_error_info;
%page;
%include xforum_meeting_info;
%page;
%include xforum_meeting_list;
%page;
%include xforum_ptr_struct_;
%page;
%include xforum_spy;
%page;
%include xforum_windows;
%page;
%include xforum_answers;



%include xforum_prompts;


%include xforum_help_infos;


	call attend_a_meeting (xsamm_curr_meeting_index, xsamm_match_bits, xsamm_more, xsamm_spy_ptr);
	do while (xsamm_more);
	     xsamm_next_mtg_index = xforum_main_options$index_of_next_meeting (xsamm_match_bits, xsamm_spy_ptr);
	     call attend_a_meeting (xsamm_next_mtg_index, xsamm_match_bits, xsamm_more, xsamm_spy_ptr);
	end;

	call window_$clear_window (xforum_windows.bottom.iocb, (0));
	call window_$clear_window (xforum_windows.menu.iocb, (0));

	return;

attend_a_meeting: proc (aam_midx, aam_match_bits, aam_more, aam_spy_ptr);

	dcl     aam_subject		 char (256);
	dcl     aam_match_bits	 bit (36) aligned;
	dcl     aam_midx		 fixed bin;
	dcl     aam_more		 bit (1) aligned;
	dcl     aam_chairman_msg_exists bit (1) aligned init (FALSE);
	dcl     aam_print_chairman_msg bit (1) aligned init (FALSE);
	dcl     aam_chairman_msg	 char (256);
	dcl     aam_fidx		 fixed bin;
	dcl     aam_type		 fixed bin;
	dcl     aam_meeting_type	 (3) char (9) varying
				 init ("Eligible ", "Changed ", "Attended ");
	dcl     aam_headers		 (1) char (44) varying;
						/* control strings   */
	dcl     aam_total_ctl	 char (9) init ("Total: ^d");
	dcl     aam_new_ctl		 char (10) init ("Unread: ^d");
	dcl     aam_current_ctl	 char (23) init ("Current Subject: ^a:^i");
	dcl     aam_choices		 (14) char (40) varying
				 init (
				 "Display Unread Comment(s)",
				 "Display Current Comment",
				 "Display Next Comment",
				 "Display Previous Comment",
				 "Display All Comments",
				 "Reply To Current Comment",
				 "Next Subject With Unread Comments",
				 "Select Subject",
				 "Start New Discussion",
				 "Copy Current Subject",
				 "Skip Rest of Current Subject",
				 "Select/Display Comment Number",
				 "",
				 "Meeting Maintenance");
	dcl     aam_mtg_menu_height	 fixed bin init (8);
	dcl     aam_menu_window_height fixed bin;
	dcl     1 aam_mtg_requirements like menu_requirements;
	dcl     aam_mtg_menu_ptr	 ptr init (null);
	dcl     aam_code		 fixed bin (35);
	dcl     aam_spy_ptr		 ptr;
	dcl     aam_current_menu_ptr	 ptr;
	dcl     aam_fkey		 bit (1) aligned;
	dcl     aam_choice		 fixed bin;
	dcl     aam_multics_mode	 bit (1);

/* CONSTANTS */

	dcl     (
	        aam_FIRST_MENU	 fixed bin init (2),
	        aam_FIRST_MENU2	 fixed bin init (9),
	        aam_HELP		 fixed bin init (1),
	        aam_MULTICS		 fixed bin init (8),
	        aam_MULTICS2	 fixed bin init (15),
	        aam_PREV_MENU	 fixed bin init (3),
	        aam_PREV_MENU2	 fixed bin init (10),
	        aam_QUIT		 fixed bin init (4),
	        aam_QUIT2		 fixed bin init (11),
	        aam_READ_ONLY_MESSAGE	 char (150) init (
				 "You are not allowed to enter comments in this meeting." ||
				 "^/Send mail to ^a for an explanation and/or a change in status."),
	        aam_REDISPLAY	 fixed bin init (5),
	        aam_REDISPLAY2	 fixed bin init (12),
	        aam_REPLY		 bit (1) aligned init ("1"b),
	        aam_TALK		 bit (1) aligned init ("0"b)
	        )			 internal static options (constant);

	aam_more = "0"b;

	if aam_midx < 1 | aam_midx > no_selected
	then return;

	spy_ptr = aam_spy_ptr;

	aam_multics_mode = xforum_user_profile$get_multics_mode ();

	on quit
	     begin;
		call xforum_window_mgr$check_window_status;
		call window_$bell (xforum_windows.menu.iocb, (0));
		call xforum_help_line_$change ("10110000"b, "Leave Meeting", "", "");
		call xforum_status_$redisplay ((0));
		call collect_spy_data (SPY_AT_7, "QUIT");
		xforum_meeting_info.current = 0;
		goto meeting_get_choice;
	     end;

	on cleanup
	     begin;
		if aam_fidx ^= -1 then do;
                         xforum_meeting_info.current = 0;
		     call xforum_attend_mtg_utilities$close_meeting (xforum_meeting_info_ptr,
			xforum_meeting_list_ptr, aam_midx, aam_fidx, aam_mtg_menu_ptr);
                    end;
	     end;

	call xforum_attend_mtg_utilities$set_up_meeting (xforum_meeting_list_ptr, xforum_meeting_info_ptr, aam_midx, "1"b,
	     aam_fidx, aam_subject, aam_chairman_msg);
	if aam_fidx = 0
	then return;

	if aam_match_bits = ALL then
	     aam_type = GET_ELIGIBLE;
	else if aam_match_bits = CHANGED then
	     aam_type = GET_ATTENDED;
	else if aam_match_bits = PARTICIPANT then
	     aam_type = GET_CHANGED;

	aam_headers (1) = "Attending " || rtrim (xforum_meeting_info.name) || " meeting";
	call xforum_status_$update_title ((aam_headers (1)));

	aam_choices (13) = "Go To Next " || aam_meeting_type (aam_type) || "Meeting";

	call xforum_attend_mtg_utilities$update_status (xforum_meeting_info_ptr,
	     0, aam_subject, 0, aam_fidx);
	call xforum_window_mgr$resynch_windows (aam_mtg_menu_height, "1"b);

	aam_mtg_requirements.version = menu_requirements_version_1;

	call xforum_create_menu_ (aam_choices, addr (aam_mtg_requirements), aam_mtg_menu_ptr, aam_code);
	if aam_code ^= 0 then do;
	     call com_err_$suppress_name (aam_code, ME, "Trying to create meeting menu.");
	     goto exit_attend_a_meeting;
	end;

	call xforum_window_mgr$menu_display (aam_mtg_menu_ptr);

	on xforum_redisplay_menu
	     call xforum_window_mgr$menu_display (aam_mtg_menu_ptr); /* for redisplay function	      */

	if rtrim (aam_chairman_msg) ^= ""
	then call ioa_ ("^a", aam_chairman_msg);

	aam_current_menu_ptr = aam_mtg_menu_ptr;

/* get choice					*/

meeting_get_choice:
	do while (ON);
	     call xforum_window_mgr$menu_get_choice (aam_mtg_menu_ptr, aam_fkey, aam_choice);

	     if aam_fkey
	     then call collect_spy_data (SPY_AT_7, "F" || rtrim (ltrim (char (aam_choice))));
	     else call collect_spy_data (SPY_AT_7, rtrim (ltrim (char (aam_choice))));

	     if aam_fkey then
		if aam_choice = aam_HELP
		then do;
		     call xforum_help_$get_help (aam_mtg_menu_ptr, "Meeting", aam_choices,
			spy_ptr, xforum_system_area_ptr);
		     call xforum_status_$update_title ((aam_headers (1)));
		     call xforum_attend_mtg_utilities$update_status (xforum_meeting_info_ptr,
			0, aam_subject, 0, aam_fidx);
		     call xforum_status_$redisplay ((0));
		     call xforum_window_mgr$resynch_windows (aam_mtg_menu_height, "0"b);
		     call xforum_window_mgr$menu_display (aam_mtg_menu_ptr);
		end;
		else if aam_choice = aam_FIRST_MENU | aam_choice = aam_FIRST_MENU2
		then goto exit_attend_a_meeting;
		else if aam_choice = aam_PREV_MENU | aam_choice = aam_PREV_MENU2
		then goto exit_attend_a_meeting;
		else if aam_choice = aam_QUIT | aam_choice = aam_QUIT2
		then do;
                         xforum_meeting_info.current = 0;
		     call xforum_attend_mtg_utilities$close_meeting (xforum_meeting_info_ptr,
			xforum_meeting_list_ptr, aam_midx, aam_fidx, aam_mtg_menu_ptr);
		     signal exit_executive_forum;
		end;
		else if aam_choice = aam_REDISPLAY | aam_choice = aam_REDISPLAY2
		then call xforum_redisplay_;
		else if (aam_choice = aam_MULTICS | aam_choice = aam_MULTICS2) & aam_multics_mode
		then do;
		     call xforum_multics_mode (aam_menu_window_height);
		     call xforum_window_mgr$resynch_windows (aam_menu_window_height, "0"b);
		     call xforum_attend_mtg_utilities$update_status (xforum_meeting_info_ptr,
			0, aam_subject, 0, aam_fidx);
		     call xforum_window_mgr$menu_display (aam_mtg_menu_ptr);
		     goto meeting_get_choice;
		end;
		else call window_$bell (xforum_windows.menu.iocb, (0));
	     else do;
		if aam_choice = DISPLAY_UNREAD
		then call display_unread (aam_fidx, forums (aam_midx).forum_version);
		else
		     if aam_choice = DISPLAY_CURRENT
		then call display_current (aam_fidx, forums (aam_midx).forum_version);
		else
		     if aam_choice = DISPLAY_NEXT
		then call display_next (aam_fidx, forums (aam_midx).forum_version);
		else
		     if aam_choice = DISPLAY_PREV
		then call display_previous (aam_fidx, forums (aam_midx).forum_version);
		else
		     if aam_choice = DISPLAY_ALL
		then call display_all (aam_fidx, forums (aam_midx).forum_version);
		else
		     if aam_choice = REPLY
		then do;
		     if ^forums (aam_midx).flags.read_only
		     then do;
			call xforum_attend_mtg_utilities$enter_trans (xforum_meeting_info_ptr, aam_fidx, spy_ptr, aam_REPLY, "1"b);
			aam_current_menu_ptr = null ();
		     end;
		     else do;
			call window_$clear_window (xforum_windows.bottom.iocb, (0));
			call ioa_ (aam_READ_ONLY_MESSAGE, forums (aam_midx).chairman);
		     end;
		end;
		else
		     if aam_choice = NEXT_SUBJ_UNREAD
		then call next_subject (aam_fidx, forums (aam_midx).forum_version, aam_subject);
		else
		     if aam_choice = GET_SUBJECT
		then do;
		     call select_subject (spy_ptr);
		     call display_current (aam_fidx, forums (aam_midx).forum_version);
		end;
		else
		     if aam_choice = TALK
		then do;
		     if ^forums (aam_midx).flags.read_only
		     then do;
			call xforum_attend_mtg_utilities$enter_trans (xforum_meeting_info_ptr, aam_fidx, spy_ptr, aam_TALK, "1"b);
			aam_current_menu_ptr = null ();
		     end;
		     else do;
			call window_$clear_window (xforum_windows.bottom.iocb, (0));
			call ioa_ (aam_READ_ONLY_MESSAGE, forums (aam_midx).chairman);
		     end;
		end;
		else
		     if aam_choice = COPY_SUBJECT
		then call copy_comments (spy_ptr, aam_fidx, forums (aam_midx).forum_version);
		else
		     if aam_choice = SKIP_REST_SUBJ
		then call skip_rest_of_subject (aam_fidx, forums (aam_midx).forum_version, aam_subject);
		else
		     if aam_choice = GET_COMMENT
		then do;
		     call select_comment (spy_ptr, aam_subject);
		     call display_current (aam_fidx, forums (aam_midx).forum_version);
		end;
		else
		     if aam_choice = GET_NEXT_MTG
		then do;
                         xforum_meeting_info.current = 0;
		     call xforum_attend_mtg_utilities$close_meeting (xforum_meeting_info_ptr,
			xforum_meeting_list_ptr, aam_midx, aam_fidx, aam_mtg_menu_ptr);
		     aam_more = "1"b;
		     return;
		end;
		else
		     if aam_choice = MTG_MAINTENANCE
		then call meeting_maintenance;
	     end;

	     call iox_$control (xforum_windows.bottom.iocb, "reset_more",
		null, (0));			/* get back in step		      */

	     if aam_current_menu_ptr ^= aam_mtg_menu_ptr
	     then do;
		call xforum_window_mgr$resynch_windows (aam_mtg_menu_height, "1"b);
		call window_$clear_window (xforum_windows.bottom.iocb, (0));
		call xforum_status_$update_title ((aam_headers (1)));
		call xforum_attend_mtg_utilities$update_status (xforum_meeting_info_ptr,
		     0, aam_subject, 0, aam_fidx);
		call xforum_window_mgr$menu_display (aam_mtg_menu_ptr);

		aam_current_menu_ptr = aam_mtg_menu_ptr;
	     end;
	end;

exit_attend_a_meeting:
          xforum_meeting_info.current = 0;
	call xforum_attend_mtg_utilities$close_meeting (xforum_meeting_info_ptr,
	     xforum_meeting_list_ptr, aam_midx, aam_fidx, aam_mtg_menu_ptr);

     end attend_a_meeting;

display_unread: proc (du_fidx, du_version);

/* PARAMETERS */

	dcl     du_fidx		 fixed bin;
	dcl     du_version		 fixed bin;

/* AUTOMATIC */

	dcl     du_code		 fixed bin (35);
	dcl     du_is_first		 bit (1) aligned;

	call window_$clear_window (xforum_windows.bottom.iocb, (0));

	du_code = 0;
	du_is_first = "1"b;

	xforum_meeting_info.flags.allref = "1"b;
	xforum_meeting_info.current_ref = xforum_meeting_info.current;

	call xforum_get_selected_trans$first (xforum_meeting_info_ptr, forum_user_trans_ptr, du_code);
	do while (du_code ^= forum_error_table_$invalid_trans_idx);
	     if du_code = 0
	     then do;
		if xforum_meeting_info.seen_map_ptr -> seen_map (forum_user_trans.trans_no)
		then free forum_user_trans;
		else do;
		     xforum_meeting_info.current = forum_user_trans.trans_no;
		     call xforum_attend_mtg_utilities$update_status
			(xforum_meeting_info_ptr, forum_user_trans.trans_no, forum_user_trans.subject, du_version, du_fidx);
		     call xforum_format_$display (forum_user_trans_ptr, du_is_first, du_code);
		     du_is_first = "0"b;
		end;
	     end;
	     call xforum_get_selected_trans$next (xforum_meeting_info_ptr, forum_user_trans_ptr, du_code);
	end;

	xforum_meeting_info.flags.allref = "0"b;

	if du_is_first
	then call ioa_ ("All comments on this subject have been read");

	return;

     end display_unread;

display_current: proc (dc_fidx, dc_version);

/* PARAMETERS */

	dcl     dc_fidx		 fixed bin;
	dcl     dc_version		 fixed bin;

/* AUTOMATIC */

	dcl     dc_code		 fixed bin (35);

	call window_$clear_window (xforum_windows.bottom.iocb, (0));

	dc_code = 0;

	call xforum_trans_$read (xforum_meeting_info.current, forum_user_trans_ptr, dc_code);
	if dc_code ^= 0
	then call com_err_$suppress_name (dc_code, ME, "Could not read current comment");
	else do;
	     call xforum_attend_mtg_utilities$update_status
		(xforum_meeting_info_ptr, forum_user_trans.trans_no, forum_user_trans.subject, dc_version, dc_fidx);
	     call xforum_format_$display (forum_user_trans_ptr, "1"b, dc_code);
	end;

	return;

     end display_current;

display_next: proc (dn_fidx, dn_version);

/* PARAMETERS */

	dcl     dn_fidx		 fixed bin;
	dcl     dn_version		 fixed bin;

/* AUTOMATIC */

	dcl     dn_code		 fixed bin (35);

	call window_$clear_window (xforum_windows.bottom.iocb, (0));

	dn_code = 0;

	call xforum_trans_$next_ref (xforum_meeting_info.current, forum_user_trans_ptr, dn_code);
	if dn_code = forum_error_table_$invalid_trans_idx
	then call ioa_ ("There is no next comment on this subject.");
	else
	     if dn_code ^= 0
	then call com_err_$suppress_name (dn_code, ME, "Could not read next comment");
	else do;
	     xforum_meeting_info.current = forum_user_trans.trans_no;
	     call xforum_attend_mtg_utilities$update_status
		(xforum_meeting_info_ptr, forum_user_trans.trans_no, forum_user_trans.subject, dn_version, dn_fidx);
	     call xforum_format_$display (forum_user_trans_ptr, "1"b, dn_code);
	end;

	return;

     end display_next;

display_previous: proc (dp_fidx, dp_version);

/* PARAMETERS */

	dcl     dp_fidx		 fixed bin;
	dcl     dp_version		 fixed bin;

/* AUTOMATIC */

	dcl     dp_code		 fixed bin (35);

	call window_$clear_window (xforum_windows.bottom.iocb, (0));

	dp_code = 0;

	call xforum_trans_$prev_ref (xforum_meeting_info.current, forum_user_trans_ptr, dp_code);
	if dp_code = forum_error_table_$invalid_trans_idx
	then call ioa_ ("There is no previous comment on this subject.");
	else
	     if dp_code ^= 0
	then call com_err_$suppress_name (dp_code, ME, "Could not read previous comment");
	else do;
	     xforum_meeting_info.current = forum_user_trans.trans_no;
	     call xforum_attend_mtg_utilities$update_status
		(xforum_meeting_info_ptr, forum_user_trans.trans_no, forum_user_trans.subject, dp_version, dp_fidx);
	     call xforum_format_$display (forum_user_trans_ptr, "1"b, dp_code);
	end;

	return;

     end display_previous;

display_all: proc (da_fidx, da_version);

/* PARAMETERS */

	dcl     da_fidx		 fixed bin;
	dcl     da_version		 fixed bin;

/* AUTOMATIC */

	dcl     da_code		 fixed bin (35);
	dcl     da_is_first		 bit (1) aligned;

	call window_$clear_window (xforum_windows.bottom.iocb, (0));

	da_code = 0;
	da_is_first = "1"b;

	xforum_meeting_info.flags.allref = "1"b;
	xforum_meeting_info.current_ref = xforum_meeting_info.current;

	call xforum_get_selected_trans$first (xforum_meeting_info_ptr, forum_user_trans_ptr, da_code);
	do while (da_code ^= forum_error_table_$invalid_trans_idx);
	     if da_code = 0
	     then do;
		xforum_meeting_info.current = forum_user_trans.trans_no;
		call xforum_attend_mtg_utilities$update_status
		     (xforum_meeting_info_ptr, forum_user_trans.trans_no, forum_user_trans.subject, da_version, da_fidx);
		call xforum_format_$display (forum_user_trans_ptr, da_is_first, da_code);
		da_is_first = "0"b;
	     end;
	     call xforum_get_selected_trans$next (xforum_meeting_info_ptr, forum_user_trans_ptr, da_code);
	end;

	xforum_meeting_info.flags.allref = "0"b;

	return;

     end display_all;

next_subject: proc (ns_fidx, ns_version, ns_subject);

/* PARAMETERS */

	dcl     ns_fidx		 fixed bin;
	dcl     ns_version		 fixed bin;
	dcl     ns_subject		 char (256);

/* AUTOMATIC */

	dcl     ns_code		 fixed bin (35);
	dcl     ns_old_current	 fixed bin;




	ns_old_current = xforum_meeting_info.current;

	call window_$clear_window (xforum_windows.bottom.iocb, (0));

	call xforum_attend_mtg_utilities$next_unread_comment (xforum_meeting_info_ptr,
	     ns_fidx, ns_version, forum_user_trans_ptr);

	if forum_user_trans_ptr = null ()
	then do;
	     call ioa_ ("No unread subjects.");
	     xforum_meeting_info.current = ns_old_current;
	     call xforum_trans_$read (xforum_meeting_info.current, forum_user_trans_ptr, ns_code);
	     if forum_user_trans.subject_length <= MAX_LEN
	     then ns_subject = forum_user_trans.subject;
	     else ns_subject = substr (forum_user_trans.subject, 1, MAX_LEN);
	     call xforum_attend_mtg_utilities$update_status
		(xforum_meeting_info_ptr, forum_user_trans.trans_no, forum_user_trans.subject, ns_version, ns_fidx);
	     free forum_user_trans;
	end;
	else do;
	     if forum_user_trans.subject_length <= MAX_LEN
	     then ns_subject = forum_user_trans.subject;
	     else ns_subject = substr (forum_user_trans.subject, 1, MAX_LEN);
	     call xforum_attend_mtg_utilities$update_status
		(xforum_meeting_info_ptr, forum_user_trans.trans_no, forum_user_trans.subject, ns_version, ns_fidx);
	     call xforum_format_$display (forum_user_trans_ptr, "1"b, ns_code);
	end;


	return;

     end next_subject;

select_subject: proc (ss_spy_ptr);

/* PARAMETERS */

	dcl     ss_spy_ptr		 ptr;

/* AUTOMATIC */

	dcl     ss_code		 fixed bin (35);
	dcl     ss_i		 fixed bin;
	dcl     ss_last_reference_ptr	 ptr;
	dcl     ss_old_current	 fixed bin;
	dcl     ss_next_trans	 fixed bin;
	dcl     ss_response		 char (256) varying;
	dcl     ss_response_len	 fixed bin;
	dcl     ss_seen_for_subject_ptr ptr;
	dcl     ss_selected_index	 fixed bin;
	dcl     ss_subject_index	 fixed bin;
	dcl     ss_subjects_ptr	 ptr;
	dcl     ss_transactions_processed fixed bin;
	dcl     ss_working_segs_ptr	 (3) ptr;

/* CONSTANT */

	dcl     ss_NAME		 char (14) init ("select subject") internal static options (constant);

/* BASED */

	dcl     ss_seen_for_subject	 (xforum_meeting_info.last_trans + 1) bit (1) unaligned based (ss_seen_for_subject_ptr);
	dcl     ss_last_reference	 (ss_subject_index) fixed bin based (ss_last_reference_ptr);
	dcl     ss_subjects		 (ss_subject_index) char (32) based (ss_subjects_ptr);


	call window_$clear_window (xforum_windows.bottom.iocb, (0));

	call ioa_ ("Building a list of subjects, this may take a while.");

	ss_old_current = xforum_meeting_info.current;
	ss_working_segs_ptr (1) = null ();
	ss_working_segs_ptr (2) = null ();
	ss_working_segs_ptr (3) = null ();

	call xforum_help_line_$push ("0"b, "", "Leave current subject unchanged", "");

	on quit
	     begin;
		xforum_meeting_info.current = ss_old_current;
		goto exit_select_subject;
	     end;

	call get_temp_segments_ (ss_NAME, ss_working_segs_ptr, ss_code);
	if ss_code ^= 0
	then do;
	     call com_err_$suppress_name (ss_code, ss_NAME, "Could not get a segment to store subjects - aborting select subject request.");
	     goto exit_select_subject;
	end;


	ss_seen_for_subject_ptr = ss_working_segs_ptr (1);
	ss_subjects_ptr = ss_working_segs_ptr (2);
	ss_last_reference_ptr = ss_working_segs_ptr (3);
	string (ss_seen_for_subject) = "0"b;
	ss_subject_index = 0;
	ss_next_trans = 1;
	ss_transactions_processed = 0;

	do while (ss_next_trans <= xforum_meeting_info.last_trans);
	     call xforum_trans_$read (ss_next_trans, forum_user_trans_ptr, ss_code);
	     if ss_code = 0
	     then do;
		ss_transactions_processed = ss_transactions_processed + 1;
		if mod (ss_transactions_processed, 200) = 0
		then call transactions_processed_message (ss_transactions_processed);
		ss_subject_index = ss_subject_index + 1;
		if forum_user_trans.subject_length > 32
		then ss_subjects (ss_subject_index) = substr (forum_user_trans.subject, 1, 29) || "...";
		else ss_subjects (ss_subject_index) = forum_user_trans.subject;
		ss_i = index (ss_subjects (ss_subject_index), NL);
		if ss_i ^= 0
		then do;
		     if ss_i > 29
		     then ss_subjects (ss_subject_index) = substr (forum_user_trans.subject, 1, 29) || "...";
		     else ss_subjects (ss_subject_index) = substr (forum_user_trans.subject, 1, ss_i - 1) || "...";
		end;
		ss_seen_for_subject (ss_next_trans) = "1"b;
		ss_last_reference (ss_subject_index) = ss_next_trans;
		free forum_user_trans;
		ss_i = ss_next_trans;
		call xforum_trans_$next_ref (ss_i, forum_user_trans_ptr, ss_code);
		do while (ss_code = 0);
		     ss_transactions_processed = ss_transactions_processed + 1;
		     if mod (ss_transactions_processed, 200) = 0
		     then call transactions_processed_message (ss_transactions_processed);
		     ss_seen_for_subject (forum_user_trans.trans_no) = "1"b;
		     ss_last_reference (ss_subject_index) = forum_user_trans.trans_no;
		     ss_i = forum_user_trans.trans_no;
		     free forum_user_trans;
		     call xforum_trans_$next_ref (ss_i, forum_user_trans_ptr, ss_code);
		end;
	     end;

	     ss_next_trans = ss_next_trans + 1;
	     do while (ss_seen_for_subject (ss_next_trans) & ss_next_trans <= xforum_meeting_info.last_trans);
		ss_next_trans = ss_next_trans + 1;
	     end;
	end;

	if xforum_user_profile$get_menu_always ()
	then do;
display_menu:
	     call xforum_dyn_menu_$display_and_get_choice (ss_subjects, ss_subject_index, "Comment Subject Selection",
		"ENTER SUBJECT", "Leave current subject unchanged", SPY_AT_19, ss_spy_ptr, ss_selected_index);
	     if ss_selected_index = -1
	     then goto prompt_for_subject;
	     else
		if ss_selected_index = 0
	     then xforum_meeting_info.current = ss_old_current;
	     else xforum_meeting_info.current = ss_last_reference (ss_selected_index);
	     goto exit_select_subject;
	end;
	else do;
prompt_for_subject:
	     call xforum_dyn_menu_$prompt_instead_of_menu ("Leave current subject unchanged", "Enter Subject", "Subjects",
		"subjects", "select_subject", SPY_AT_19, ss_spy_ptr, ss_response);

	     if ss_response = "??"
	     then goto display_menu;

	     ss_response_len = length (ss_response);
	     if ss_response_len = 0
	     then xforum_meeting_info.current = ss_old_current;
	     else do;
		xforum_meeting_info.current = 0;
		do ss_i = 1 to ss_subject_index while (xforum_meeting_info.current = 0);
		     if ss_response = substr (ss_subjects (ss_i), 1, ss_response_len)
		     then xforum_meeting_info.current = ss_last_reference (ss_i);
		end;
		if xforum_meeting_info.current = 0
		then do;
		     call ioa_ ("No comment chain could be found on the subject of ^a", ss_response);
		     call ioa_ ("Please re-enter the subject or ?? for a menu of subjects");
		     goto prompt_for_subject;
		end;
	     end;
	end;

exit_select_subject:
	if ss_working_segs_ptr (1) ^= null ()
	then call release_temp_segments_ (ss_NAME, ss_working_segs_ptr, ss_code);

	call xforum_help_line_$pop;

	return;

     end select_subject;

copy_comments: proc (cc_spy_ptr, cc_fidx, cc_version);

/* PARAMETERS */

	dcl     cc_spy_ptr		 ptr;
	dcl     cc_fidx		 fixed bin;
	dcl     cc_version		 fixed bin;

/* AUTOMATIC */

	dcl     cc_bc		 fixed bin (24);
	dcl     cc_code		 fixed bin (35);
	dcl     cc_entry_name	 char (32);
	dcl     cc_number_of_comments	 fixed bin;
	dcl     cc_seg_ptr		 ptr;

	call xforum_attend_mtg_utilities$copy_to_name (cc_spy_ptr, cc_entry_name, cc_seg_ptr, cc_bc);
	if cc_seg_ptr = null ()
	then goto exit_copy_comments;

	cc_number_of_comments = 0;
	call ioa_ ("^/^/   Comments are being copied to ^a.", cc_entry_name);
	call xforum_help_line_$push ("0"b, "", "Return to Meeting menu", "");

	on quit
	     begin;
		call xforum_window_mgr$check_window_status;
		call window_$clear_window (xforum_windows.bottom.iocb, (0));
		call xforum_help_line_$pop;
		call collect_spy_data (SPY_AT_15, "QUIT");
		goto exit_copy_comments;
	     end;

	xforum_meeting_info.flags.allref = "1"b;
	xforum_meeting_info.current_ref = xforum_meeting_info.current;

	call xforum_get_selected_trans$first (xforum_meeting_info_ptr, forum_user_trans_ptr, cc_code);
	do while (cc_code ^= forum_error_table_$invalid_trans_idx);
	     if cc_code = 0
	     then do;
		cc_number_of_comments = cc_number_of_comments + 1;
		call xforum_attend_mtg_utilities$update_status
		     (xforum_meeting_info_ptr, forum_user_trans.trans_no, forum_user_trans.subject, cc_version, cc_fidx);
		call xforum_format_$append (forum_user_trans_ptr, cc_seg_ptr, "0"b, cc_bc, cc_code);
	     end;
	     call xforum_get_selected_trans$next (xforum_meeting_info_ptr, forum_user_trans_ptr, cc_code);
	end;

	call window_$clear_window (xforum_windows.bottom.iocb, (0));
	call ioa_ ("^d comments copied to file ^a.", cc_number_of_comments, cc_entry_name);

exit_copy_comments:
	return;

     end copy_comments;

skip_rest_of_subject: proc (sros_fidx, sros_version, sros_subject);

/* PARAMETERS */

	dcl     sros_fidx		 fixed bin;
	dcl     sros_version	 fixed bin;
	dcl     sros_subject	 char (256);

/* AUTOMATIC */

	dcl     sros_code		 fixed bin (35);





	call window_$clear_window (xforum_windows.bottom.iocb, (0));

	call ioa_ ("Skipping rest of subject.");

	xforum_meeting_info.flags.allref = "1"b;
	xforum_meeting_info.current_ref = xforum_meeting_info.current;

	call xforum_get_selected_trans$first (xforum_meeting_info_ptr, forum_user_trans_ptr, sros_code);
	do while (sros_code ^= forum_error_table_$invalid_trans_idx);
	     if sros_code = 0
	     then do;
		xforum_meeting_info.current = forum_user_trans.trans_no;
		call xforum_attend_mtg_utilities$update_status
		     (xforum_meeting_info_ptr, forum_user_trans.trans_no, forum_user_trans.subject, sros_version, sros_fidx);
		free forum_user_trans;
	     end;
	     call xforum_get_selected_trans$next (xforum_meeting_info_ptr, forum_user_trans_ptr, sros_code);
	end;

	xforum_meeting_info.allref = "0"b;

	call next_subject (sros_fidx, sros_version, sros_subject);

	return;

     end skip_rest_of_subject;

select_comment: proc (sc_spy_ptr, sc_subject);

/* PARAMETERS */

	dcl     sc_spy_ptr		 ptr;
	dcl     sc_subject		 char (256);

/* AUTOMATIC */

          dcl     error_table_$long_record 
                                         fixed bin(35) ext static;
	dcl     sc_code		 fixed bin (35);
	dcl     sc_comment_number	 fixed bin;
	dcl     sc_reply		 char (132);
          dcl     reply		 char (132) varying;

	spy_ptr = sc_spy_ptr;

	on quit
	     begin;
		call xforum_window_mgr$check_window_status;
		call window_$clear_window (xforum_windows.bottom.iocb, (0));
		call xforum_help_line_$pop;
		call xforum_status_$redisplay ((0));
		call collect_spy_data (SPY_AT_10, "QUIT");
		goto exit_select_comment;
	     end;

	call window_$clear_window (xforum_windows.bottom.iocb, (0));

	call xforum_help_line_$push ("0"b, "", "", QUERY_USAGE);

select_comment_prompt:
          answer_array.N = 0;                               /* All answers acceptable			*/
          answer_array.max_length = MAX_LEN;		/* max length of comment specifier		*/
          call xforum_get_str_ ((COMMENT_PROMPT), addr(answer_array), PROMPT_HELP, "select_comment", reply, sc_code);

          if sc_code = error_table_$long_record
          then do;
               call window_$clear_window (xforum_windows.bottom.iocb, (0));
	     call ioa_ ("^/Max length (^d) for comment specifiers exceeded - please reenter^/  (or press BREAK to return to menu).", MAX_LEN);
	     goto select_comment_prompt;
	     end;

	if length(reply) = 0
	then call collect_spy_data (SPY_AT_10, "RETURN");
	else do;
	     if reply = "?"
	     then call collect_spy_data (SPY_AT_10, "?");
	     else if verify (reply, "0123456789") ^= 0
	     then call collect_spy_data (SPY_AT_10, "number");
	     else call collect_spy_data (SPY_AT_10, "ERROR");

	     if verify (reply, "0123456789") ^= 0
	     then do;
		call window_$clear_window (xforum_windows.bottom.iocb, (0));
		call ioa_ ("Only a single comment number may be entered");
		goto select_comment_prompt;
	     end;

	     sc_comment_number = convert (xforum_meeting_info.current, substr (reply, 1));
	     call xforum_trans_$read (sc_comment_number, forum_user_trans_ptr, sc_code);
	     if sc_code = forum_error_table_$invalid_trans_idx
	     then do;
		call window_$clear_window (xforum_windows.bottom.iocb, (0));
		call ioa_ ("Comment ^i does not exist.", sc_comment_number);
		goto select_comment_prompt;
	     end;
	     else
		if sc_code = forum_error_table_$trans_deleted | sc_code = forum_error_table_$trans_reaped
	     then do;
		call window_$clear_window (xforum_windows.bottom.iocb, (0));
		call ioa_ ("Comment ^i has been deleted.", sc_comment_number);
		goto select_comment_prompt;
	     end;
	     else
		if sc_code ^= 0
	     then do;
		call window_$clear_window (xforum_windows.bottom.iocb, (0));
		call ioa_ ("Comment ^i cannot be read, please choose another comment.", sc_comment_number);
		goto select_comment_prompt;
	     end;
	     else do;
		if forum_user_trans.subject_length <= MAX_LEN
		then sc_subject = forum_user_trans.subject;
		else sc_subject = substr (forum_user_trans.subject, 1, MAX_LEN);
		free forum_user_trans;
		xforum_meeting_info.current = sc_comment_number;
	     end;
	end;

	call xforum_help_line_$pop;

exit_select_comment:
	return;

     end select_comment;

meeting_maintenance: proc;



	call ioa_ ("Meeting Maintenance has not yet been implemented.");
	call timer_manager_$sleep (4, "11"b);

	return;

     end meeting_maintenance;

transactions_processed_message: proc (tpm_number);

/* PARAMETERS */

	dcl     tpm_number		 fixed bin;

/* AUTOMATIC */

	dcl     tpm_message		 char (50);


	call window_$position_cursor (iox_$user_io, 3, 22, (0));
	call ioa_$rsnnl ("^d out of ^d comments processed.", tpm_message, (0), tpm_number, xforum_meeting_info.last_trans);
	call window_$overwrite_text (iox_$user_io, rtrim (tpm_message), (0));
	call window_$sync (iox_$user_io, (0));

	return;

     end transactions_processed_message;

collect_spy_data: proc (csd_where, csd_response);

	dcl     csd_where		 fixed bin;
	dcl     csd_response	 char (*);

	spy.count = spy.count + 1;
	spy.choices (count).at = csd_where;
	spy.choices (count).choice = csd_response;

	return;

     end collect_spy_data;

     end xforum_sub_attend_mtg_menu;
