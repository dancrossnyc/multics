/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(85-02-26,Davids), approve(86-02-04,MCR7350),
     audit(86-04-24,Gilcrease), install(86-04-24,MR12.0-1048):
     Deleted the internal proc prompt_help which was outputting a
     canned messaged in response to a ?  from the meeting name prompt.
     Replaced it with a call to xforum_help_$display to output the help
     message in the info file.  Also added the gm_help_name variable to
     hold the name of the help section (i.e., changed, attended, or
     eligible).  Bob Kress found this error while he was going over the
     documentation.
     
     85-03-01 Davids: Corrected next_meeting so it uses its own nm_*
     variables to call the attend_mtg_menu modules instead of the gm_*
     variables.  I obviously copied the code and didn't change the
     variables and didn't test it until now.
     
     85-03-07 Davids: Corrected the get_choice_from_menu procedure so
     that it pops the help_line when a choice has been made and the
     routine is about to exit.  It was just doing a
     xforum_help_line_$redisplay.  When enough of the meeting list
     menus were displayed a help_line stack overflow would occur.  Also
     had to reorange the way that get_curr_meeting handled the
     help_line.  A new help line was being pushed for every prompt and
     no pops were being done.
  2) change(85-04-02,Davids), approve(86-02-04,MCR7350),
     audit(86-04-24,Gilcrease), install(86-04-24,MR12.0-1048):
     Removed code from the get_choice_from_menu procedure that dealt
     with constructing the array of names to be used in the dynamic
     menus and the creation of the menus and the handling of the
     function keys.  Replaced it all with a call to
     xforum_dyn_menu_$display_and_get_choice.
     
     85-04-03 Davids: Removed code from the get_curr_meeting procedure
     that dealt with prompting the user for a meeting name and
     processing the response, i.e.  too long or blank input, or ?.
     Replaced it with a call to
     xforum_dyn_menu_$prompt_instead_of_menu.
     
     85-04-22 Davids: Added code to the find_meeting procedure to copy
     the search paths to the end of the extended meeting list before
     the meeting info is moved.  This keeps the search paths from
     getting zaped when the meeting info is extened and prevents the
     "Warning your search paths have changed" message from appearing
     when you add a new meeting to your meeting list by searching for
     it after the meeting list proper has been created.  This is error
     list entry number 4.
     
     85-05-01 Davids: Changed the loop in next_meeting_internal that
     goes from 1 to nmi_curr_mtg looking for a meeting that meets the
     criteria so that it goes to nmi_curr_mtg - 1.  This is needed so
     that you do not get a subscript range error when nmi_curr_mtg is
     set to the max meeting index.  It will be so set after you have
     cycled through all the meetings.
     
     85-06-17 Davids: Modified call to xforum_find_path_ so that the
     fm_dir output paramater comes after all the input paramaters.
  3) change(87-07-21,LJAdams), approve(87-07-21,MCR7684),
     audit(87-07-24,Blair), install(87-08-06,MR12.1-1065):
     Declared constants for menu choices to get rid of magic numbers.
                                                   END HISTORY COMMENTS */


xforum_main_options: proc;

/*
   BEGIN DESCRIPTION

   function:
      This module implements all the functions related to the options
      in the xforum main menu.

   description of entry points:
      goto_meeting: this entry is used to "goto" a meeting. An input value
      determines if the meeting type is a changed, attended, or eligible one.
      If the indicated type is changed and there are no more changed meetings
      the handle_no_changed_mtgs procedure is called. If there are no meetings
      of the indicated type (after the call to handle...) a message to that
      effect is output. If there is only 1 meeting of the given type it is
      automatically selected. If there is more than 1 meeting a call is made
      to the internal procedure get_curr_meeting to let the user select the
      meeting he wishes to goto. Once the meeting is selected a call is made
      to the internal proc attend_meetings.

      next_meeting: This entry is used to "goto" the next meeting. An
      input value determines if the meeting type is a changed, attended, or
      eligible one. The work of selecting the next meeting is done by calling
      next_meeting_internal. Once a meeting is selected a call is made to the
      internal proc attend_meetings.

      index_of_next_meeting: This entry is used to determine the index of the
      next meeting of the given type. The work of selecting the next meeting
      is done by next_meeting_internal.

      modify_meeting_list: This entry will be used to modify the contents
      meeting list, i.e. add new meetings and resign from currently attended
      meetings. Currently the only thing implemented is a call to ioa_ which
      outputs a message saying that the function has not yet been implemented.

   description of internal procedures:
      get_curr_meeting: This procedure queries the user for the name of the
      meeting he wants to go to. If the menu_always flag is set to true (input
      from the caller of goto_meeting entry) a dynamic menu of all the meetings
      of the given type is displayed in the bottom window (via a call to 
      get_choice_from_menu). If the meeting index returned by
      get_choice_from_menu is -1 it means that the user selected the "ENTER
      NAME" meeting which indicates that the user wants to be prompted for the
      meeting name. The users response is checked in the find_meeting
      procedure to be sure that it is on the meeting list. The meeting is also
      checked to be sure that it is the right type. If the meeting is not on
      the list or the types do not match an error message is output and no
      meeting is selected. The user aborts the query (or dynamic menu) by
      signaling quit. The quit handler in xforum will trap the quit, reset
      all the windows, and unwind the stack back to xforum by doing a non-local
      goto to the menu display and get_choice loop.

      get_choice_from_menu: this manages a dynanic menu of the meeting names
      for the given type of meeting. The xforum_dyn_menu routines are utilized
      to create and display the menu and get the users choice. the function
      keys REDISPLAY, SCROLL_UP, and SCROLL_DOWN are active. The user can abort
      the menu by signalling quit (see discussion in get_curr_meeting).
      The dynamic menu contains the list of meetings plus the special meeting
      "ENTER NAME" as the last item on the last menu. This special meeting
      has a meeting list index of -1 which get_curr_meeting recognizes as
      a request for a prompt. A title line that describes the type of meetings
      being selected is written over the trailer line of the top menu. This was
      done so that you did not end up with 2 lines of dashes. The title is
      positioned over the trailer line via position_cursor and then
      ovewrite_text.

      find_meeting: locates the requested meeting in the xforum meeting list.
      If the meeting is not in the meeting list it calls xforum_find_path_
      to use the forum search rules to locate the meeting. forum_info is 
      called to get info about the meeting and the meeting is then
      added to the xforum meeting list. The name used in the xforum meeting
      list is the name the user used, not the name of the actual meeting.

      next_meeting_internal: finds the next meeting in the meeting list.
      The meeting may be constrained to have been changed or attended.
      If the meeting is a changed meeting and there are no changed meeting in 
      the list then handle_no_changed_meetings is called. If no meetings of
      the requested type can be found a message is output and the process put
      to sleep for 4 seconds to allow time to read the message.

      prompt_help: outputs a help message about the "Enter name of meeting"
      prompt issued in the get_curr_meeting procedure. This procedure is called
      if the user answers the prompt with a "?". The text of the help message
      varies slightly depending on the type of meeting, i.e. changed, attended
      or eligible.

      handle_no_changed_meetings: will prompt the user to see if he wants the
      meetings in his meeting list checked for changes. ONLY the meetings
      in the meeting list that the user participats in are checked.
      command_query is used to query the user and the help text printed in
      response to a "?" is part of the command_query call. If the user answers
      yes, a message indicating that the meeting are being checked and that it
      will take a while is output. A call is made to forum_$forum_info for
      each meeting the user participats in. If the meeting is changed the
      meeting is marked as changed and the changed count is incremented.
      Before the module exits the banner containing the counts of eligible,
      atteneded, and changed meetings is updated - but it is only printed if
      the number of changed meetings and attended meetings are both non-zero.
      This prevents the banner for being updated while the "No changed
      meetings" message is output.

      collect_spy_data: this procedure is called from all locations that take 
      user input. Its input is the user's input and a location ID. It writes
      that information in a special spy structure based on a pointer that
      was passed in to the orginal entry. Note that collect_spy_data is the
      same in all xforum modules. It is not a separate module because it
      consists on only 3 assignment statements.

      error: this is called when a fatal error has been detected by xforum.
      A fatal error happens when an unexpected error code is returned from
      a system routine, i.e. a non-zero code returned from forum_limits, or
      an inconsistency in the input parameters is found. It signals the
      xforum_fatal_error condition. There is a condition handler for this
      in the xforum module.

   known bugs:
      84-07-31 Davids: help messages need to set up for escape sequence mode.

   notes:

   history:
      84-07-09 Davids: created by extracting the relavent internal procedures
      from the xforum module.

      84-07-18 Davids: Added the handle_no_changed_mtgs procedure

      84-07-27 Davids: Added a confirmation message in the
      handle_no_changed_mtgs procedure so that if the user answered with a
      yes he knows that the answer was accepted and that the meetings are
      being checked. If he answered no there is no need for a confirmation
      message since the menu is updated very quickly.

      84-07-31 Davids: Modified the handle_no_changed_meetings so that:
      1) it had a quit handler, 2) there are calls to collect_spy_data
      and 3) it updates the banner before it leaves. Also cleaned things
      up so that the code looks better and removed unneeded dcls. Finally
      added a call to the error procedure if the main entry point is called.
      Modified the usage message in get_choice_from_menu to conform with MTB.
      Created an internal procedure called next_meeting_internal. This
      procedure is called by the next_meeting entry point (its the only thing
      the entry does) and the goto_meeting entry point if there is only 1
      meeting that can be gone to. A message telling the user that the meeting
      was automatically selected is also output.

      84-08-13 Davids: Changed Attended, Changed and Meetings to attended,
      changed and meetings in error messages. Changed Meetings in the banner
      to Eligible. Changed the error message reported in find_meeting if
      xforum_find_path_ fails to find the meeting to reflect the MTB.

      84-08-15 Davids: Modified so that all entry points used the
      xforum_info_ptr as their only parameter. Added entry points
      modify_meeting_list, personlize, and getting_started. These entry points
      just report that the code has not yet been implemented. Deleted entry
      points resign_from_meeting, and list_meetings since these are no longer
      main menu options.

      84-08-29 Davids: Added the internal routines attend_meetings and
      attend_a_meeting. These additions need to be cleaned up but they are
      now in place.

      84-08-31 Davids: Added sleep statements after the You have no * meetings
      messages in the next_meeting_internal proc. This was needed to keep the
      messages on the screen so that the user can read them. Also the status
      window is not updated if there are no changes. This prevents the status
      window from changing to that of the main menu while the menu remains that
      of the attending meeting and the You have... message is displayed.

      84-09-04 Davids: Added code to find_mmeting. The name_entered is now
      compared against the long_names in the meeting list instead of the short
      names since the rest of the list is sorted by long_name. no_selected is
      incremented before the loop that shifts the list to make room for the
      new name - this prevents a subscript range condition.

      84-09-05 Davids: Added the variable fm_meeting_version to find_meeting.
      also added code to set the xforum_meeting_list.forums (i).forum_version
      element. This was preventing version 1 meetings from being found after
      they are added to the meeting list (since the version was not 1 it was
      assumed to be 2).

      84-09-06 Davids: Changed the Select options in the attend meeting menu to
      Select/Display. Changed option 4 in the menu from just selecting comments
      to both selecting and displaying comments.

      84-09-17 Davids: Added processing for uppercase escape sequences. This
      was done by declaring XXX2 constants for the uppercase escape sequences
      and inserting them in the if statements along with the XXX constants.
      The constants declared were REDISPLAY2, QUIT2, PREV_MENU2, SCROLL_UP2,
      SCROLL_DOWN2. For the main entry and aam and gs.

      84-09-24 Davids: Modified get_choice_from_menu so that it adds to the
      list of meetings the choice ENTER NAME. This "meeting" has a meeting
      list index of -1. Modified get_curr_meeting so that if the meeting
      selected has an index of -1 if will goto the display_prompt label
      instead of assuming that a meeting has been selected.

      84-09-25 Davids: Removed references to xforum_trans_array. The array is
      being deleted because it enforces an upper limit on the number of
      transaction that xforum can handle.

      84-09-27 Davids: Modified the get_choice_from_menu option so that a
      title of "T Meetings Selection" is output over the trailer line of the
      main menu. It is centered by determining where on the screen it should
      start, positioning the cursor there, and overwritting the text. This has
      the effect of a title line which is padded with dashes but does not
      produce two lines with dashes, i.e. the main trailer line and the new
      dynamic menu header line. The T stands for Eligible, Attended, or Changed
      depending on the type of meetings requested. Also modified the call to
      copy_comments so that it reflected the new calling sequence.

      84-09-28 Davids: Modified to use the xforum_help_line module instead of 
      the xforum_status_ entries that manipulated the help line.

      84-10-03 Davids: Added code in attend_a_meeting to get the seen
      transaction bit map and the xforum_meeting_info next_unread and
      unread_count elements. Added code in reinstate_mtg_status to update
      the bit map and unread values if there were transactions entered since
      the last time the bit map was updated. Changed the label in the new field
      to Unread:

      84-10-11 Davids: Changed the Current transaction string for the
      attend meeting menu to Current comment.

      84-10-16 Davids: Changed Select/Display Comments to
      Select/Display Any Comment(s)

      84-10-26 Davids: Changed List Current Comment(s) to Select/List Any
      Comment(s). Also swaped the menu position of Copy Comments with
      Select/List so that all the Select options are in a group.

      84-10-29 Davids: Added a test for the input of a null meeting name in
      the get_curr_meeting procedure. A appropriate message is now output
      instead of letting the null name pass and giving the user: The "" meeting
      could not be found.

      84-11-06 Davids: Changed references to xforum_help_line to
      xforum_help_line_.

      84-11-15 Davids: Auding changes: 1) Fixed output messages to begin with
      an upper case letter and end with a period.

      84-12-13 Davids: added code in handle_no_changed_meetings so that if a
      call to forum to get meeting info fails a message is output saying that
      the meeting has been deleted or renamed and tells how to update the
      meeting list. This is nicer then just aborting xforum. It also sets the
      participant flag for the meeting to false. The same messages are
      output in the attend_a_meeting procedure if the call to open a meeting
      fails the participant and changed flags for the meeting are 0'ed and the
      no_participant and no_changed counts are decremented if need be.

     85-01-08 Davids: Changed calling sequence of xforum_multics_mode to remove
     the handle_interactive_messages_flag. Also changed the calling sequence of
     xforum_help_$get_help to remove the handle_interactive_messages_flag and
     the function_key_data_ptr. Changed calling sequence of
     xforum_window_mgr$menu_get_choice to remove the arguments
     function_key_data_ptr and handle_interactive_messages. Also change the
     assignment of gs_multics_mode and aam_multics_mode to be from a call to
     xforum_user_profile instead of from the xforum_info structure
     Changed calling sequence of xforum_dyn_menu_$get_choice to remove the
     function_key_data_ptr argument.

     85-01-10 Davids: Modified the internal proc get_curr_meeting to call
     xforum_user_profile$get_menu_always instead of relying on a static
     value passed into xforum_main_options.

     85-01-16 Davids: Changed QUERY_USAGE the help line text output for a
     meeting name query to have the same format as the rest of the help lines.

     85-01-24 Davids: Added handling of the xforum_meeting_info.flags.set
     switch to the reinstate_mtg_status internal proc.

     85-01-25 Davids: Modified the internal proc get_choice_from_menu so that
     the list of menu options includes a "ENTER MEETING NAME" as every Nth
     option, where N is set to be the last option on each menu.

     85-01-28 Davids: Modified the internal proc find_meeting so that the
     fields, changed, been_to, and mbz are set correctly. NONE of these
     fields were been set! Also changed how no_participant was being
     incremented to be based on the participant field instead of the attended
     field. Also corrected the if statement that positions a new meeting in
     the meeting list so that it looks for the meeting with a name that occurs
     after it and stops instead of a name that occurs before it and stops.
     Its old behavior usually made it the first meeting in the list.

     85-02-05 Davids: Removed the getting_started entry. Also removed the
     personalization entry which has not been used for some time.

     85-02-11 Davids: Removed the internal procs attend_meetings,
     attend_a_meeting, reinstate_mtg_status, and close_meeting. Added the entry
     index_of_next_meeting. Changed all calls to attend_meetings to calls to
     xforum_ent_attend_mtg_menu. Removed quite a few now unused declarations.

     85-02-13 Davids: Changed calling sequence of xforum_help_line_$push
     to include the new F3_message argument.

     85-02-19 Davids: Added calls to xforum_sub_attend_mtg_menu.
   END DESCRIPTION
*/

/* PARAMETERS */

/* EXTERNAL STATIC */


/* ENTRIES */

	dcl     com_err_$suppress_name entry () options (variable);
	dcl     command_query_$yes_no	 entry () options (variable);
	dcl     ioa_		 entry () options (variable);
	dcl     ioa_$rsnnl		 entry () options (variable);
	dcl     signal_		 entry () options (variable);
	dcl     timer_manager_$sleep	 entry (fixed bin (71), bit (2));
	dcl     window_$clear_window	 entry (ptr, fixed bin (35));
	dcl     xforum_dyn_menu_$display_and_get_choice entry ((*) char (*), fixed bin, char (*), char (*), char (*),
				 fixed bin, ptr, fixed bin);
	dcl     xforum_dyn_menu_$prompt_instead_of_menu entry (char (*), char (*), char (*), char (*), char (*), fixed bin,
				 ptr, char (*) var);
	dcl     xforum_ent_attend_mtg_menu entry (fixed bin, bit (36) aligned, ptr);
	dcl     xforum_find_path_ entry (char(*), fixed bin, char(*), char(*), fixed bin(35));
	dcl     xforum_help_line_$push entry (bit (8), char (*), char (*), char (*));
	dcl     xforum_help_line_$pop	 entry options (variable);
	dcl     xforum_status_$redisplay entry (fixed bin (35));
	dcl     xforum_status_$update_banner entry (char (*));
	dcl     xforum_sub_attend_mtg_menu entry (fixed bin, bit (36) aligned, ptr);
	dcl     xforum_user_profile$get_menu_always entry () returns (bit (1));
	dcl     xforum_user_profile$get_read_comments_by_subject entry () returns (bit (1));
	dcl     xforum_window_mgr$check_window_status entry options (variable);

/* CONDITIONS */

	dcl     quit		 condition;

/* INTERNAL STATIC */

	dcl     01 xmo_xforum_error_info like xforum_error_info internal static;

/* CONSTANTS */

	dcl     (
	        ALL		 bit (36) aligned init ("111111110000000000000000000000000000"b),
	        CHANGED		 bit (36) aligned init ("000000010000000000000000000000000000"b),
	        FALSE		 bit (1) aligned init ("0"b),
	        GET_ATTENDED	 fixed bin init (2),
	        GET_CHANGED            fixed bin init (3),
                  GET_ELIGIBLE           fixed bin init (1),
	        ME		 char (19) init ("xforum_main_options"),
	        PARTICIPANT		 bit (36) aligned init ("000100000000000000000000000000000000"b),
	        QUERY_USAGE		 char (67) init ("Press  ? and RETURN:help   BREAK:Return to Executive Forum menu"),
	        REDISPLAY		 fixed bin init (5),
	        REDISPLAY2		 fixed bin init (12),
	        TRUE		 bit (1) aligned init ("1"b)
	        )			 internal static options (constant);

/* BUILTINS */

	dcl     (
	        addr,
	        clock,
	        null,
	        rtrim,
	        unspec
	        )			 builtin;

/* BASED */

/* INCLUDE FILES */
%page;
%include forum_dcls;
%page;
%include forum_flags;
%page;
%include forum_info;
%page;
%include forum_user_trans;
%page;
%include menu_dcls;
%page;
%include xforum_error_info;
%page;
%include xforum_info;
%page;
%include xforum_meeting_info;
%page;
%include xforum_meeting_list;
%page;
%include xforum_ptr_struct_;
%page;
%include xforum_spy;
%page;
%include xforum_windows;

	call error (0, "Internal programming error - xforum_main_options$xforum_main_options called.");

goto_meeting: entry (gm_xforum_info_ptr);


/* PARAMETERS */

	dcl     gm_xforum_info_ptr	 ptr;		/* (input) */

/* AUTOMATIC */

	dcl     gm_count_ptr	 ptr;
	dcl     gm_curr_meeting	 fixed bin;
	dcl     gm_help_name	 char (17);
	dcl     gm_match_bits	 bit (36) aligned;
	dcl     gm_type		 fixed bin;

/* BASED */

	dcl     gm_count		 fixed bin based (gm_count_ptr);

	xforum_info_ptr = gm_xforum_info_ptr;
	spy_ptr = xforum_info.main_options.spy_ptr;
	gm_curr_meeting = 0;

	on quit
	     begin;
		call xforum_window_mgr$check_window_status;
		call window_$clear_window (xforum_windows.bottom.iocb, (0));
		call xforum_help_line_$pop;
		call xforum_status_$redisplay ((0));
		call collect_spy_data (SPY_AT_4, "QUIT");
		gm_curr_meeting = 0;
		goto exit_goto_meeting;
	     end;

	call window_$clear_window (xforum_windows.bottom.iocb, (0));

	if xforum_info.main_options.choice = ELIGIBLE_MTG
	then do;
	     gm_type = GET_ELIGIBLE;
	     gm_help_name = "eligible_mtg_name";
	     gm_count_ptr = addr (no_selected);
	     gm_match_bits = ALL;
	end;
	else if xforum_info.main_options.choice = ATTENDED_MTG
	then do;
	     gm_type = GET_ATTENDED;
	     gm_help_name = "attended_mtg_name";
	     gm_count_ptr = addr (no_participant);
	     gm_match_bits = PARTICIPANT;
	end;
	else if xforum_info.main_options.choice = CHANGED_MTG
	then do;
	     gm_type = GET_CHANGED;
	     gm_help_name = "changed_mtg_name";
	     gm_count_ptr = addr (no_changed);
	     gm_match_bits = CHANGED;
	end;
	else call error (0, "Internal error in next_meeting proc.");

	if gm_count = 0 & gm_type = GET_CHANGED
	then call handle_no_changed_mtgs;		/* gm_count is set globally */

	if gm_count = 0 then do;
	     call ioa_ ("You have no ^[^;attended^;changed^] meetings.", gm_type);
	     return;
	end;

	if gm_count = 1
	then do;
	     call next_meeting_internal (gm_match_bits,
		gm_curr_meeting,
		xforum_info.main_options.spy_ptr);
	     call ioa_ ("^a meeting automatically selected,^/   it is your only ^[^;attended^;changed^] meeting.",
		forums (gm_curr_meeting).long_name, gm_type);
	     call timer_manager_$sleep (4, "11"b);
	end;
	else call get_curr_meeting (gm_match_bits, SPY_AT_4, gm_help_name, gm_curr_meeting);

	if gm_curr_meeting ^= 0
	then do;
	     if xforum_user_profile$get_read_comments_by_subject ()
	     then call xforum_sub_attend_mtg_menu (gm_curr_meeting, gm_match_bits, spy_ptr);
	     else call xforum_ent_attend_mtg_menu (gm_curr_meeting, gm_match_bits, spy_ptr);
	end;

exit_goto_meeting:
	return;

next_meeting: entry (nm_xforum_info_ptr);


/* PARAMETERS */

	dcl     nm_xforum_info_ptr	 ptr;

/* AUTOMATIC */

	dcl     nm_match_bits	 bit (36) aligned;
	dcl     nm_next_mtg_index	 fixed bin;




	xforum_info_ptr = nm_xforum_info_ptr;
	spy_ptr = xforum_info.spy_ptr;

/* Note that choices 1 through 3 (CHANGED_MTG, ATTENDED_MTD, and ELIGIBLE_MTG)
   are checked because those are the choices that will be set if the user
   does a next meetings from within in the attend meeting menu.
*/

	if xforum_info.main_options.choice = NEXT_MTG | 
             xforum_info.main_options.choice = CHANGED_MTG
	then nm_match_bits = CHANGED;
	else
	     if xforum_info.main_options.choice = MULTICS_MODE |
                  xforum_info.main_options.choice = ATTENDED_MTG
	then nm_match_bits = PARTICIPANT;
	else
	     if xforum_info.main_options.choice = XFORUM_MENU |
                  xforum_info.main_options.choice = ELIGIBLE_MTG
	then nm_match_bits = ALL;

	call next_meeting_internal (nm_match_bits, nm_next_mtg_index, spy_ptr);

	xforum_info.main_options.curr_meeting_index = nm_next_mtg_index;

	if nm_next_mtg_index < no_selected + 1
	then do;
	     if xforum_user_profile$get_read_comments_by_subject ()
	     then call xforum_sub_attend_mtg_menu (nm_next_mtg_index, nm_match_bits, spy_ptr);
	     else call xforum_ent_attend_mtg_menu (nm_next_mtg_index, nm_match_bits, spy_ptr);
	end;

	return;

index_of_next_meeting: entry (ionm_match_bits, ionm_spy_ptr) returns (fixed bin);

/* PARAMETERS */

	dcl     ionm_match_bits	 bit (36) aligned;
	dcl     ionm_spy_ptr	 ptr;

/* AUTOMATIC */

	dcl     ionm_meeting_index	 fixed bin;



	call next_meeting_internal (ionm_match_bits, ionm_meeting_index, ionm_spy_ptr);

	return (ionm_meeting_index);

modify_meeting_list: entry (mml_xforum_info_ptr);


/* PARAMETERS */

	dcl     mml_xforum_info_ptr	 ptr;


	call ioa_ ("Modify Meeting List has not yet been implemented.");

	return;

get_curr_meeting: proc (gcm_match_bits, gcm_spy_id, gcm_help_name, gcm_curr_meeting);


/* PARAMETERS */

	dcl     gcm_match_bits			/* (input) */
				 bit (36) aligned;
	dcl     gcm_spy_id				/* (input) */
				 fixed bin;
	dcl     gcm_help_name			/* (input) */
				 char (17);
	dcl     gcm_curr_meeting			/* (output) */
				 fixed bin;

/* AUTOMATIC */

	dcl     gcm_name_entered	 char (32) varying;


	gcm_curr_meeting = 0;

	if xforum_user_profile$get_menu_always ()
	then do;
display_menu:
	     call get_choice_from_menu (gcm_match_bits, gcm_curr_meeting, gcm_name_entered);
	     if gcm_curr_meeting = -1
	     then goto display_help;
	end;
	else do;
display_help:
	     call xforum_dyn_menu_$prompt_instead_of_menu ("Return to Executive Forum menu", "Enter name of meeting",
		"Meeting names", "meeting name", gcm_help_name, gcm_spy_id, spy_ptr, gcm_name_entered);
	     if gcm_name_entered = "??"
	     then goto display_menu;

	     if gcm_name_entered = ""
	     then gcm_curr_meeting = 0;
	     else call find_meeting (gcm_name_entered, gcm_curr_meeting);

	     if gcm_curr_meeting ^= 0
	     then do;
		if ((unspec (forums (gcm_curr_meeting).flags) & gcm_match_bits) = FALSE)
		then do;				/* ^right type   */
		     if gcm_match_bits = PARTICIPANT
		     then call com_err_$suppress_name (0, ME,
			     "You are not a participant of the ""^a"" meeting.", gcm_name_entered);
		     else call com_err_$suppress_name (0, ME,
			     "The ""^a"" meeting has not changed.", gcm_name_entered);
		     gcm_curr_meeting = 0;
		end;
	     end;
	end;

	return;

     end get_curr_meeting;

get_choice_from_menu: proc (gcfm_match_bits, gcfm_curr_meeting, gcfm_name_entered);


/* PARAMETERS */

	dcl     gcfm_match_bits			/* (input) */
				 bit (36) aligned;
	dcl     gcfm_curr_meeting			/* (output) */
				 fixed bin;
	dcl     gcfm_name_entered			/* (output) */
				 char (32) varying;

/* AUTOMATIC */

	dcl     gcfm_count		 fixed bin;
	dcl     gcfm_option_index	 fixed bin;
	dcl     gcfm_title		 char (50) varying;


	if gcfm_match_bits = ALL
	then do;
	     gcfm_count = no_selected;
	     gcfm_title = " Eligible Meetings Selection ";
	end;
	else if gcfm_match_bits = PARTICIPANT
	then do;
	     gcfm_count = no_participant;
	     gcfm_title = " Attended Meetings Selection ";
	end;
	else if gcfm_match_bits = CHANGED
	then do;
	     gcfm_count = no_changed;
	     gcfm_title = " Changed Meeting Selection ";
	end;

	begin;
	     dcl	   (gcfm_i, gcfm_j)	      fixed bin;
	     dcl	   gcfm_names	      (gcfm_count) char (32) aligned;
	     dcl	   gcfm_nindex	      (gcfm_count) fixed bin;

	     gcfm_i = 0;

	     do gcfm_j = 1 to no_selected;
		if (unspec (forums (gcfm_j).flags) & gcfm_match_bits)
		then do;
		     gcfm_i = gcfm_i + 1;
		     gcfm_names (gcfm_i) = forums (gcfm_j).long_name;
		     gcfm_nindex (gcfm_i) = gcfm_j;
		end;
	     end;

	     call xforum_dyn_menu_$display_and_get_choice ((gcfm_names), gcfm_i, (gcfm_title), "ENTER MEETING NAME",
		"Return to Executive Forum menu", SPY_AT_5, spy_ptr, gcfm_option_index);

	     if gcfm_option_index > 0
	     then do;
		gcfm_curr_meeting = gcfm_nindex (gcfm_option_index);
		gcfm_name_entered = gcfm_names (gcfm_option_index);
	     end;
	     else do;
		gcfm_curr_meeting = gcfm_option_index;
		gcfm_name_entered = "";
	     end;
	end;

     end get_choice_from_menu;

find_meeting: proc (fm_name_entered, fm_midx);


/* PARAMETERS */

	dcl     fm_name_entered			/* (input) */
				 char (32) varying;
	dcl     fm_midx				/* (output) */
				 fixed bin;

/* AUTOMATIC */

	dcl     fm_code		 fixed bin (35);
	dcl     fm_dir		 char (168);
	dcl     fm_fname		 char (32);
	dcl     fm_i		 fixed bin;
	dcl     fm_j		 fixed bin;
	dcl     fm_meeting_version	 fixed bin;
	dcl     fm_new_paths_ptr	 ptr;
	dcl     fm_old_paths_ptr	 ptr;
	dcl     1 fm_fi		 like forum_info;

/* BASED */

	dcl     01 fm_paths_ovly	 based,
		02 npaths		 fixed bin,
		02 paths		 (200) char (168) varying; /* a large constant is need because */
						/* the new npaths will probbaly overlap one of the search */
						/* directories and there fore cannot be set until all the */
						/* serach directories have been moved */




	fm_midx = 0;

	do fm_i = 1 to no_selected;			/* look for it		      */
	     if fm_name_entered = forums (fm_i).long_name
		| fm_name_entered = forums (fm_i).short_name then do;
		fm_midx = fm_i;
		return;
	     end;
	end;					/* not in list - oh dear	      */

	fm_meeting_version = 1;			/* assume its a version 1 meeting */
	call xforum_find_path_ ((fm_name_entered), 1, fm_dir, fm_fname, fm_code);
	if fm_code ^= 0				/* Its not a version 1 meeting */
	then do;
	     fm_meeting_version = 2;			/* now assume its a version 2 meeting */
	     call xforum_find_path_ ((fm_name_entered), 2, fm_dir, fm_fname, fm_code);
	     if fm_code ^= 0
	     then do;
		call ioa_ ("The ""^a"" meeting cannot be found.", fm_name_entered);
		call timer_manager_$sleep (4, "11"b);
		return;
	     end;
	end;

	fm_fi.version = forum_info_version_1;

	call forum_$forum_info (fm_dir, fm_fname, "", clock (), addr (fm_fi), fm_code);
	if fm_code ^= 0 then do;
	     call com_err_$suppress_name (fm_code, ME, fm_name_entered);
	     return;
	end;					/* now find where to put it in list */
	do fm_i = 1 to no_selected;
	     if fm_name_entered < forums (fm_i).long_name then do;
		goto found_in_list;
	     end;
	end;
found_in_list:
	if current_participant ^< fm_i then
	     current_participant = current_participant + 1;

	if current_changed ^< fm_i then
	     current_changed = current_changed + 1;

	fm_old_paths_ptr = addr (xforum_meeting_list.npaths);

	no_selected = no_selected + 1;

	fm_new_paths_ptr = addr (xforum_meeting_list.npaths); /* move the search paths down */
	do fm_j = fm_old_paths_ptr -> fm_paths_ovly.npaths to 1 by -1;
	     fm_new_paths_ptr -> fm_paths_ovly.paths (fm_j) = fm_old_paths_ptr -> fm_paths_ovly.paths (fm_j);
	end;
	fm_new_paths_ptr -> fm_paths_ovly.npaths = fm_old_paths_ptr -> fm_paths_ovly.npaths;


	if fm_i < (no_selected - 1) then		/* ripple rest of list up	      */
	     do fm_j = (no_selected - 1) to fm_i by -1;
		forums (fm_j + 1) = forums (fm_j);
	     end;

	forums (fm_i).long_name = fm_name_entered;
	forums (fm_i).short_name = fm_name_entered;
	forums (fm_i).directory = fm_dir;
	forums (fm_i).forum_version = fm_meeting_version;
	forums (fm_i).two_names = FALSE;
	forums (fm_i).uid = fm_fi.forum_uid;
	forums (fm_i).eligible = fm_fi.eligible;
	forums (fm_i).removed = fm_fi.removed;
	forums (fm_i).notify = fm_fi.notify;
	forums (fm_i).read_only = fm_fi.read_only;
	forums (fm_i).attended = (fm_fi.last_time_attended ^= 0);
	forums (fm_i).participant = forums (fm_i).attended & ^fm_fi.removed;
	if forums (fm_i).participant then
	     no_participant = no_participant + 1;
	if fm_fi.changes_count ^= 0 & forums (fm_i).participant
	then do;
	     no_changed = no_changed + 1;
	     forums (fm_i).changed = "1"b;
	end;
	else forums (fm_i).changed = "0"b;
	forums (fm_i).been_to = "0"b;
	forums (fm_i).mbz = "0"b;
	forums (fm_i).chairman =
	     rtrim (fm_fi.chairman.username) || "." || (fm_fi.chairman.project);

	fm_midx = fm_i;

	return;
     end find_meeting;

next_meeting_internal: proc (nmi_match_bits, nmi_next_mtg_index, nmi_spy_ptr);


/* PARAMETERS */

	dcl     nmi_match_bits			/* (input) */
				 bit (36) aligned;
	dcl     nmi_next_mtg_index			/* (input) */
				 fixed bin;
	dcl     nmi_spy_ptr				/* (input) */
				 ptr;

/* AUTOMATIC */

	dcl     nmi_count_ptr	 ptr;
	dcl     nmi_curr_mtg_ptr	 ptr;
	dcl     nmi_i		 fixed bin;
	dcl     nmi_name_entered	 char (32) varying;
	dcl     nmi_type		 fixed bin;

/* BASED */

	dcl     nmi_count		 fixed bin based (nmi_count_ptr);
	dcl     nmi_curr_mtg	 fixed bin based (nmi_curr_mtg_ptr);


	spy_ptr = nmi_spy_ptr;

	on quit
	     begin;
		call xforum_window_mgr$check_window_status;
		call window_$clear_window (xforum_windows.bottom.iocb,
		     (0));
		call xforum_help_line_$pop;
		call xforum_status_$redisplay ((0));
		nmi_next_mtg_index = no_selected + 1;
		goto exit_next_meeting_internal;
	     end;

	if nmi_match_bits = ALL then do;
	     nmi_type = GET_ELIGIBLE;
	     nmi_count_ptr = addr (no_selected);
	     nmi_curr_mtg_ptr = addr (current_selected);
	end;
	else if nmi_match_bits = PARTICIPANT then do;
	     nmi_type = GET_ATTENDED;
	     nmi_count_ptr = addr (no_participant);
	     nmi_curr_mtg_ptr = addr (current_participant);
	end;
	else if nmi_match_bits = CHANGED then do;
	     nmi_type = GET_CHANGED;
	     nmi_count_ptr = addr (no_changed);
	     nmi_curr_mtg_ptr = addr (current_changed);
	end;
	else call error (0, "Internal error in next_meeting proc.");

	if nmi_count = 0 & nmi_type = GET_CHANGED
	then call handle_no_changed_mtgs;

	if nmi_count = 0 then do;
	     call ioa_ ("You have no ^[^;attended^;changed^] meetings.", nmi_type);
	     call timer_manager_$sleep (4, "11"b);
	     nmi_curr_mtg = no_selected + 1;
	     nmi_next_mtg_index = nmi_curr_mtg;
	     goto exit_next_meeting_internal;
	end;

	do nmi_i = nmi_curr_mtg + 1 to no_selected;
	     if (unspec (forums (nmi_i).flags) & nmi_match_bits)
	     then
		if (nmi_match_bits = CHANGED | ^forums (nmi_i).been_to)
		then goto next_found;
	end;

          do nmi_i = 1 to nmi_curr_mtg;
	     if (unspec (forums (nmi_i).flags) & nmi_match_bits)
	     then
		if (nmi_match_bits = CHANGED | ^forums (nmi_i).been_to)
		then goto next_found;
	end;


/* obviously none left	      */
	nmi_curr_mtg = no_selected + 1;
	nmi_next_mtg_index = nmi_curr_mtg;
	call ioa_ ("You have no ^[^;attended^;changed^] meetings.", nmi_type);
	call timer_manager_$sleep (4, "11"b);

	goto exit_next_meeting_internal;
	

next_found:
	nmi_curr_mtg = nmi_i;
	nmi_next_mtg_index = nmi_curr_mtg;

	nmi_name_entered = "";

exit_next_meeting_internal:
	return;

     end next_meeting_internal;

handle_no_changed_mtgs: proc;


/* PARAMETERS */

/* INTERNAL AUTOMATIC */

	dcl     hncm_i		 fixed bin;
	dcl     hncm_banner		 char (40);
	dcl     hncm_code		 fixed bin (35);
	dcl     hncm_name		 char (32);
	dcl     hncm_yes_ans	 bit (1);
	dcl     01 hncm_fi		 like forum_info;

	on quit
	     begin;
		call collect_spy_data (SPY_AT_11, "QUIT");
		goto exit_handle_no_changed_mtgs;
	     end;

	hncm_fi.version = forum_info_version_1;

	call window_$clear_window (xforum_windows.bottom.iocb, (0));

	call xforum_help_line_$push ("0"b, "", "", QUERY_USAGE);

	call command_query_$yes_no (hncm_yes_ans, 0, "",
	     "     Your meeting list shows no changed meetings.  If you answer" ||
	     "^/yes, each of the meetings you participate in will be checked for" ||
	     "^/changes and your meeting list will be updated.  This process can" ||
	     "^/take several minutes." ||
	     "^/^/Do you want to have your meetings checked and the list updated? ",
	     "You have no changed meetings according to the current changed meeting list." ||
	     "^/Do you want to have your meetings checked and the list updated? ");

	if ^hncm_yes_ans
	then do;
	     call collect_spy_data (SPY_AT_11, "no");
	     goto exit_handle_no_changed_mtgs;
	end;

	call ioa_ ("^/Checking meetings, this may take a while.");

	call collect_spy_data (SPY_AT_11, "yes");

	call xforum_help_line_$push ("0"b, "", "Return to Executive Forum menu", "");

	do hncm_i = 1 to xforum_meeting_list.no_selected;
	     if xforum_meeting_list.forums (hncm_i).participant
	     then do;
		if xforum_meeting_list.forums (hncm_i).forum_version = 1
		then hncm_name = rtrim (xforum_meeting_list.forums (hncm_i).long_name) || ".control";
		else hncm_name = rtrim (xforum_meeting_list.forums (hncm_i).long_name) || ".forum";

		call forum_$forum_info (xforum_meeting_list.forums (hncm_i).directory, hncm_name,
		     "", clock (), addr (hncm_fi), hncm_code);
		if hncm_code ^= 0
		then do;
		     call ioa_ ("The ^a meeting^/has been deleted or renamed since your meeting list was created.",
			xforum_meeting_list.forums (hncm_i).long_name);
		     call ioa_ ("To update your meeting list exit Executive Forum^/and reinvoke it with the -force control argument.");
		     xforum_meeting_list.forums (hncm_i).participant = "0"b;
		     call timer_manager_$sleep (4, "11"b);
		end;
		if hncm_fi.changes_count > 0
		then do;
		     xforum_meeting_list.no_changed = xforum_meeting_list.no_changed + 1;
		     xforum_meeting_list.forums (hncm_i).changed = TRUE;
		end;
	     end;
	end;

exit_handle_no_changed_mtgs:
	call window_$clear_window (xforum_windows.bottom.iocb, (0));
	call xforum_help_line_$pop;
	call ioa_$rsnnl ("Eligible ^d, Attended ^d, Changed ^d",
	     hncm_banner, (0), no_selected, no_participant, no_changed);
	call xforum_status_$update_banner (hncm_banner);
	if no_participant ^= 0 & no_changed ^= 0
	then call xforum_status_$redisplay ((0));

	return;

     end handle_no_changed_mtgs;

collect_spy_data: proc (csd_where, csd_response);


/* PARAMETERS */

	dcl     csd_where				/* (input) */
				 fixed bin;
	dcl     csd_response			/* (input) */
				 char (*);



	spy.count = spy.count + 1;
	spy.choices (count).at = csd_where;
	spy.choices (count).choice = csd_response;

	return;

     end collect_spy_data;

error: proc (e_code, e_reason);


/* PARAMETERS */

	dcl     e_code				/* (input) */
				 fixed bin (35);
	dcl     e_reason				/* (input) */
				 char (512);




	xmo_xforum_error_info.name = "xforum_main_options";
	xmo_xforum_error_info.entry = "";
	xmo_xforum_error_info.doing = "";
	xmo_xforum_error_info.code = e_code;
	xmo_xforum_error_info.reason = e_reason;

	call signal_ ("xforum_fatal_error", null (), addr (xmo_xforum_error_info), null ());

     end error;

     end xforum_main_options;
