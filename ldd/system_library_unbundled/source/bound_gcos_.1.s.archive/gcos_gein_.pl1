/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   *********************************************************** */
gcos_gein_: proc;

/*
   This module receives control from the gcos command procedure. It is the
   "main loop" of the simulator; it controls the running of the entire job.

   It calls gcos_gein_pass1_ which performs (optional) cannonicalization (on an
   ASCII segment), copies $ SELECTed files into the job stream,
   and looks for activity-defining cards in the job.

   The input file must contain a job deck. It may be either an ASCII segment,
   as created by one of the Multics editors, or a gcos standard system format file,
   as created by the gcos daemon from a deck or an IMCV tape.  The appendage ".gcos" is one of
   two ways of identifying the latter type of job deck segment, the other being
   the -gcos (-gc) control argument.

   This procedure also initializes all the external static variables
   in gcos_ext_stat_ which need initialization and it opens a number of gcos files.

   Once initialization is complete, it reads card images from the
   job stream file and passes these on to the appropriate processing routines.

   When all the cards defining an activity have been processed, gcos_run_activity_
   will be called to run the activity. Processing will then continue with the
   cards for subsequent activities. When a $ ENDJOB card is read, its
   processing routine, gcos_cc_endjob_ will clean up all open files, perform
   other end-of-job bookkeeping, and then transfer to the label "normal_termination"
   in this procedure, via a non local goto, thus cleaning up the stack. However,
   if execution of the simulator (not a gcos activity) is aborted because of
   some error, control will be passed to the label "fatalerror" in the command
   procedure, gcos, causing the stack frame for this procedure to be cleaned
   up, and its cleanup handler, gein_cleanup, to be invoked.
*/
%page;
/*
   Author: DICK SNYDER AUGUST 4,1970
   Change: T.CASEY APRIL 1973, OCTOBER 1973, DECEMBER 1973, FEBRUARY 1974, APRIL 1974, AUGUST 1974
   Change: D. KAYDEN  MAY 1974, JULY 1974, FEBRUARY 1975
   Change: R.H. MORRISON MAY 1975
   Change: M. WEAVER JUNE 1975
   Change: M. R. Jordan, August 1977
   Change: A. N. Kepner, March 1978 to allow courtesy call i/o  within cc routines
   Change: Dave Ward, March 1978 to report $ SNUMB not first jcl card.
   Change: Mel Wilson, March, 1979 to remove snumb_then_ident check for gtss
   Change: Dave Ward	08/18/81 cleanup. octal constants.
   Change: Dave Ward	09/09/81 replaced use of alm vector gcos_cc_caller_ with goto cc.
   Change: Dave Ward	09/11/81 changed search_rules from allocated to auto.
   Change: Dave Ward	09/13/81 converted fibs & buffers from allocated space
			         to arrays in a temp segment.
   Change: Dave Ward	09/17/81 removed fctptr. clock_ to clock. unspec init.
   Change: Scott C. Akers	12/21/81	Fix bugs wherein GEIN references the wrong
				directory (syot_dir and save_dir get confused with
				wdir and each other).
   Change: Ron Barstad         11/12/82 Add cleanup handler for attached IDS2 files
   Change: Ron Barstad         12/02/82 Fix bug; $SELECT not writing binary object records to R*
   Change: Ron Barstad  83-08-02  Add 4JS3 to version message and 4js3 cards.
*/
%page;
/* INITIALIZE THE SIMULATOR -
   START BY CLEARING THE FILE INFORMATION BLOCKS,
   AND THEN OPENING THE FILES THAT ARE USED DURING THE WHOLE JOB
*/

start:	;
	unspec (save_data.fibs) = "0"b;

	fct.filecode = "";				/* clear the file code table */
	fct.sysout = "0"b;
	fct.fibptr = null ();

	on condition (cleanup) call gein_cleanup;	/* establish cleanup handler before opening any files */

/* Once per process initialization		 */
	if ^initialized then do;
	     initialized = "1"b;
	     gcos_ext_stat_$gcos_slave_area_seg = null;	/* init ptr to gcos seg once per process */
	     gcos_ext_stat_$max_mem = sys_info$max_seg_size; /* and max memory size */
	end;

	gcos_ext_stat_$save_data.endjob = "1"b;		/* Tell gcos_error_ to not call cc_endjob_ if we */
						/* abort during init.  Instead use gein_cleanup_. */


/* Use the search rules to search for the gcos libraries */
	if gcos_ext_stat_$save_data.userlib then do;	/* if user wants his own libraries */
						/* move "referencing_dir" to end of search rules,
						   to allow user's libraries to be found */
	     call hcs_$get_search_rules (addr (search_rules));

	     do i = 1 to search_rules.number
		     while (search_rules.names (i) ^= "referencing_dir");
	     end;

	     if i < search_rules.number then do;	/* if "referencing_dir" was found */
						/* and it was not last */
		search_rules.names (i) = "";		/* delete it from its present position */
		if search_rules.number = 21 then	/* if rule structure full */
		     do j = i to 20;		/* move the remaining rules up 1 */
		     search_rules.names (j) = search_rules.names (j+1);
		end;
		else search_rules.number = search_rules.number + 1; /* otherwise, save time */

		search_rules.names (search_rules.number) = "referencing_dir"; /* put it last */
	     end;

	     lib_count = 4;				/* allow search for gcos_second_software_ */
	end;
	else lib_count = 3;				/* -userlib not given so do not search for second software */

	do i = 1 to lib_count;

	     if gcos_ext_stat_$save_data.userlib then
		call execute_search_rules_$s_r_ptr (
		lib_names (i)
		, "1"b				/* (input) return target type & bit count. */
		||"1"b				/* (input) return target path. */
		||"1"b				/* (input) return primary name on entry. */
		|| (5)"0"b			/* (NOT USED). */
		, addr (search_rules)
		, fullname
		, ename
		, type
		, bit_count
		, code
		);
	     else
	     call execute_search_rules_ (
		lib_names (i)
		, "1"b				/* (input) return target type & bit count. */
		||"1"b				/* (input) return target path. */
		||"1"b				/* (input) return primary name on entry. */
		|| (5)"0"b			/* (NOT USED). */
		, fullname
		, ename
		, type
		, bit_count
		, code
		);
	     if code ^= 0 then do;
		if code = error_table_$noentry then do;
		     if i = 4 then do;		/* not error if second software not found */
			gcos_ext_stat_$save_data.userlib = "0"b; /* reset so gcos_mme_call_ will not try to use it */
			goto cont_init;
		     end;
		     else
		     if i = 2 then do;
			gcos_ext_stat_$patchfile_ptr = null ();
			goto end_lib_loop;
		     end;

		     if type = 0 then		/* if it was a link */
			err_msg = "target of link to system library ^a in ^a";
		     else
		     err_msg = "system library ^a";
		end;
		else
		err_msg = "while searching for system library ^a in ^a";
lib_err:		;
		call com_err_ (
		     code
		     , "gcos_gein_"
		     , err_msg
		     , lib_names (i)
		     , fullname
		     );
		if code ^= error_table_$no_s_permission then do;
fatal_error:	     ;
		     call gein_cleanup;
		     return;
		end;

	     end;

	     if bit_count = 0 then do;
		code = 0;
		err_msg = "zero bit count for system library ^a";
		goto lib_err;
	     end;


/* make full pathname of library */
	     lib_path = rtrim (fullname) || ">" || ename;
	     if i = 1 then do;			/* save subroutine library pathname */
		call gcos_open_file_ ("", "l*$", fibptr, sw);

		fib.pathnm = lib_path;
		fib.type = "1"b;			/* random file */
		fib.read = "1"b;			/* read only */
		fib.disp = "10"b;			/* disposition = save */
		fib.perm = "1"b;			/* do not delete when detaching */
	     end;
	     else
	     if i = 2 then do;
		gcos_ext_stat_$patchfile_ptr = null ();
		call hcs_$initiate (
		     fullname
		     , (ename)
		     , ""
		     , 0
		     , 0
		     , gcos_ext_stat_$patchfile_ptr
		     , code
		     );
	     end;
	     else do;
		call ios_$attach (
		     lib_streams (i-2)
		     , "file"
		     , lib_path
		     , "r"
		     , status
		     );
		if code ^= 0 then do;
lib_att_err:	     ;
		     err_msg = "trying to attach system library ^a";
		     goto lib_err;
		end;
		call ios_$setsize (lib_streams (i-2), 36, status);
		if code ^= 0 then goto lib_att_err;
	     end;
end_lib_loop:  ;
	end;

cont_init: ;

/* Obtain temporary segment for fibs and buffers. */

	call get_temp_segment_ (
	     "gcos"
	     , gcos_ext_stat_$temp_seg_ptr
	     , code
	     );
	if code ^= 0 then do;
	     call com_err_ (			/* Can not obtain temp segment. */
		code
		, "gcos"
		, "^/Attempting to get temporary segment."
		);
	     goto fatal_error;
	end;

/* INITIALIZE MISCELLANEOUS VARIABLES */
	gcos_ext_stat_$snumb = "4546452520"b3 ;		/* 4546452520 => "NONE" in bcd. */
	save_data.actid = "   NONE ";

	gcos_ext_stat_$normal_return = normal_termination; /* set up normal termination nonlocal goto */
	gcos_ext_stat_$default_nondollar,
	     gcos_ext_stat_$sought_label,
	     gcos_ext_stat_$abort_reason = "";

	unspec (gcos_ext_stat_$statistics) = "0"b;	/* 3*mme number word array being zeroed */

/* Indicate that cc_queue is initially empty. */
	courtesy_call.next_avail = 1;			/* next available empty location */
	courtesy_call.next_out = 1;			/* next entry to remove from queue */

	gcos_ext_stat_$job_real_time = clock ();	/* save job start time */
	call date_time_ (
	     gcos_ext_stat_$job_real_time
	     , execution_msg.date_time
	     );					/* put date and time in execution */
						/* report header message */

	call hcs_$get_usage_values (k, gcos_ext_stat_$job_cpu_time, k); /* get cpu time at start of job */

/* RESTART */

	if ^gcos_ext_stat_$save_data.nosave then do;
	     call hcs_$make_seg (
		(gcos_ext_stat_$save_dir)
		, gcos_ext_stat_$job_id || ".save_data"
		, ""
		, 11
		, gcos_ext_stat_$saveseg_ptr
		, code
		);

	     if gcos_ext_stat_$saveseg_ptr = null then
		call gcos_error_ (
		code
		, "creating ^a>^a.save_data"
		, gcos_ext_stat_$save_dir
		, gcos_ext_stat_$job_id
		);

	     if restart_control.saved then do;		/* job was interrupted */
		call gcos_restart_ (i);		/* do restart */
		goto restart (i);			/* (i) depends on restart options and saved data */

restart (1):	;				/* job restart if activity restart failed */

		call gein_cleanup;
		goto start;			/* start over from scratch */
	     end;
	end;

restart (4): ;					/* job restart if act. restart not attempted */
	save_data.psw = "0"b;			/* clear pgm sw. word */

	save_data.sqindex = 1;			/* init sysout queue index */

	save_data.activity_no = 0;			/* use activity number of zero in job file pathnames */

/* 	"Open" the following files		 */

/*	sysprint collector file */
/*	syspunch collector file */
/* 	execution report		 */
/*	geload r* collector file	*/


	do i = 1 to 4;
	     call gcos_open_file_ ("", "", fibptr, sw);	/* get a fib */
	     fib.disp = "10"b;			/* set disp = save for each file */
	     goto fib_init (i);			/* goto init rtn */
continue:	     ;					/* init rtns return here */
	end;

/*  Write head of form with report code 74 and header message on execution report */
	call gcos_write_$ptr (gcos_ext_stat_$er, FF, "11111100"b); /* write head-of-form */
	call gcos_write_$ptr (
	     gcos_ext_stat_$er
	     , string (execution_msg)
	     , "11111100"b
	     );					/* execution report header */

/* Get information from object or bound segment, and print it on execution
   report and console, to identify the version of the simulator being used */

	gptr = addr (gcos$);			/* get address of object or bound segment */
	call hcs_$status_mins (gptr, type, bit_count, code); /* get its bit count */
	if code ^= 0 then goto skip_version;		/* don't abort job - just skip printing version.
						   user might not have s access on the directory */
	obj_info.version_number = object_info_version_2;
	call object_info_$display (gptr, bit_count, addr (obj_info), code);
	if code ^= 0 then goto skip_version;
	call date_time_ (obj_info.compile_time, vrsn_msg.date_time); /* format time into message */
	call gcos_write_$ptr (
	     gcos_ext_stat_$er
	     , string (vrsn_msg)
	     , "11111100"b
	     );					/* write it on execution report */
	if ^gcos_ext_stat_$save_data.brief then		/* and, if user did not say -brief, */
	     call ioa_$nnl ("GCOS 4JS3 ^a", string (vrsn_msg)); /* on console */

	if gcos_ext_stat_$save_data.debug then do;	/* for benefit of debugger of simulator,
						   print pathname, author, and whether bound or not */
	     call hcs_$fs_get_path_name (
		gptr
		, fullname
		, i
		, ename
		, code
		);
	     if code ^= 0 then goto skip_version;
	     if obj_info.format.bound then seg_type = "bound";
	     else seg_type = "compiled";
	     call ioa_$rs (
		"^a>^a ^a by ^a^/"
		, err_msg
		, j
		, fullname
		, ename
		, seg_type
		, obj_info.userid
		);
	     if gcos_ext_stat_$save_data.long then	/* if user said -long, */
		call ioa_$nnl ("^a", err_msg);	/* print it on the terminal */
	     call gcos_write_$ascii_ptr (
		gcos_ext_stat_$er
		, var_msg
		, "11111100"b
		);				/* and always on ex rpt, in ASCII */

	end;

skip_version: ;
						/* come here on any error getting version information */

	gcos_ext_stat_$save_data.endjob = "0"b;		/* Initialization complete, reset flag */

pass1:	;
	call gcos_gein_pass1_;			/* go put job stream in shape to run job */

	if save_data.last_execute_act_no > 0 then	/* if job contains any EXECUTE cards */
	     save_data.psw = "01"b3 ;			/* turn on psw bit 5 */

	if ^gcos_ext_stat_$save_data.nosave then do;	/* save restart data */
	     call gcos_write_$force_ptr (gcos_ext_stat_$er);
	     call gcos_restart_$save;
	end;


/* Write header record on sysout print collector file. This record identifies
   the file as sysout (to be sorted) rather than print (not to be sorted). It
   also reserves space for the snumb and the offset within the file where the
   execution report begins, to be put in later */

restart (2): ;
	call gcos_write_$record_ptr (
	     gcos_ext_stat_$prt
	     , firstrecord
	     , (8)"0"b
	     );
						/* come here for activity restart of first act. */

restart (3): ;					/* come here for activity restart */
%page;
/* Initialization is now complete. Here begins the main processing loop of GEIN.
   Cards or line images are read here from the job stream file
   and then looked up in a table to obtain a pointer to the appropriate
   processing routine.  Some cards are processed in-line, however. */


/* Come here after each card is processed, to read the next card */

loop:	;
	call gcos_read_card_ (gcos_ptr, gcos_len, card, dollar_sw); /* get card image */
	gcos_ext_stat_$gf = 0;			/* init sw for gcos_get_cc_field_ rtn */

	if ^dollar_sw then goto nondollar;		/* if not a dollar card */

/* WE HAVE A $ CONTROL CARD;
   CHECK FOR VARIOUS SPECIAL CASES BEFORE LOOKING IT UP IN THE TABLE */

	dollar_card_count = dollar_card_count+1;
	card_type = translate (substr (card, 8, 6), LOWER_CASE, UPPER_CASE); /* pick out card type, for faster access */

	if gcos_ext_stat_$save_data.copy then do;	/* copy $ control cards */
	     if card_type ^= "endcop" then goto nondollar; /* go write on file */
	     if gcos_ext_stat_$save_data.endfc then
		if gcos_ext_stat_$endfc ^= translate (substr (card, 16, 2), LOWER_CASE, UPPER_CASE) then goto nondollar;
	     gcos_ext_stat_$save_data.copy
		, gcos_ext_stat_$save_data.nondollar
		, gcos_ext_stat_$save_data.endfc
		= "0"b;				/* turn off sw if endcopy card */
	     gcos_ext_stat_$nondollar = "";		/* no nondollar file is defined now */
	     goto loop;				/* get another card */
	end;

	if ^gcos_ext_stat_$save_data.brief then		/* unless told not to */
	     if nondollar_cards_skipped > 0 then do;	/* warn user of out-of-place nondollar cards
						   that preceeded this one */
		call ioa_ (
		     "^d nondollar cards skipped before:^/^a"
		     , nondollar_cards_skipped
		     , card
		     );
		nondollar_cards_skipped = 0;		/* reset the count */
	     end;
	     else if cc_print_sw then call ioa_ ("^a", card); /* print card if requested, for debugging */

	if substr (card, 1, 7) ^= "$" then		/* possible label card */
	     goto label_card;			/* go see if we are looking for one */

	if card_type ^= "etc   " then
	     gcos_ext_stat_$save_data.write_etc = "0"b;	/* the only way to make sure this switch is not
						   left on too long is to turn it off every time a
						   non-ETC card is read */

	if card_type ^= "incode" then
	     if gcos_ext_stat_$save_data.nondollar then do; /* if we were reading nondollar cards */
		gcos_ext_stat_$save_data.nondollar = "0"b; /* we aren't any more */
		gcos_ext_stat_$nondollar = "";	/* and no nondollar file is defined now */
		gcos_ext_stat_$incode = 0;		/* turn off any incode processing */
	     end;

/* Look up card in table */
	do i = 1 to gcos_control_tables_$tablelen;
	     if card_type = gcos_control_tables_$cardtable (i) then goto found; /* look for card type */
	end;

/* An unknown card is not an error, in real GCOS */

unknown_card: ;
	if gcos_ext_stat_$save_data.long then		/* if told to do so, warn user of bad $ card */
	     call ioa_ (
	     "gcos simulator will ignore the following unknown dollar card:^/^a"
	     , card
	     );
	goto loop;

found:	;					/* come here when card is found in cardtable;
						   "i" is its position in the table, and is used from here on */



/* BEFORE CALLING THE PROCESSOR FOR THIS CARD, CHECK VARIOUS SPECIAL CASES */
	if dollar_card_count = 1 then
	     if card_type ^= "snumb" then goto no_snumb;

/* FIRST, ARE WE SKIPPING THROUGH THE DECK, LOOKING FOR SOMETHING? */


	if gcos_ext_stat_$save_data.seeking then do;	/* if we are seeking a label or terminator */
						/* "seeking" do group */
	     if gcos_ext_stat_$sought_label ^= "" then do; /* if we are seeking a label */
						/* we already know we do not have one */
						/* "seeking label" do group (for GOTO, IF, or WHEN card) */
		if i >= gcos_control_tables_$exc_offset then
		     if i < gcos_control_tables_$nonact then do; /* if this is an activity card, */
						/* we will delete the activity */

delete_activity:		;			/* come here from below to delete activities */
						/* of aborts or compilation errors in previous */
						/* activities */
			gcos_ext_stat_$save_data.this_act_abort = "0"b; /* make sure this switch does not stay on
						   past the end of the aborting activity */

/*  Bump the activity number 	 */

			save_data.activity_no = save_data.activity_no + 1;

/* Write activity deletion messages on console and execution report */

/* format the message */
			call ioa_$rs (
			     "* ^a ACTIVITY -^2d- DELETED"
			     , err_msg
			     , j
			     , card_type
			     , save_data.activity_no
			     );

/* write it on the console, for the benefit of the interactive user */
			if gcos_ext_stat_$save_data.long then /* provided he said -long */
			     call ioa_$nnl ("^a", var_msg);

/* and on the execution report */
			call gcos_write_$ptr (
			     gcos_ext_stat_$er
			     , var_msg
			     , "11111100"b
			     );


			goto loop;		/* go read next card */

		     end;



		if i = gcos_control_tables_$tablelen then /* if ENDJOB card, */
		     goto call_caller;		/* then terminate job normally */

		goto loop;			/* if not from $ WHEN card, or if current card is
						   not a terminator, then keep looking for the label */
	     end;					/* end of "seeking label" do group */

/* So we are just seeking a terminator. We could be skipping an abort subactivity,
   or skipping a deleted execution activity. In either case, a $ ABORT card is not
   an acceptable terminator for the search */

	     if i < gcos_control_tables_$exc_offset then goto loop; /* not a terminator. keep looking for one */

/* it is a terminator - it might be a $ ABORT card, though */
	     if i = gcos_control_tables_$nonact then goto loop; /* if so keep looking */

/* We found a terminator. Turn off the switches that make us look for one */
	     gcos_ext_stat_$save_data.seeking, gcos_ext_stat_$save_data.seeking_terminator = "0"b;

/* And fall thru to process the terminator */
	end;					/* end of "seeking" do group */



/* SECOND, WE WILL ENFORCE RESTRICTIONS ON POSITION OF SNUMB AND IDENT CARDS */

	if gcos_ext_stat_$save_data.flgs.ident then goto activtst; /* snumb and ident already found ? */
	if card_type = "snumb " then goto activtst;	/* snumb? */
	if ^gcos_ext_stat_$save_data.snumb then goto loop; /* no..if none read yet continue */



/* THIRD, ACTIVITY TERMINATING CARDS NEED SOME SPECIAL HANDLING */

activtst:	;
	if i >= gcos_control_tables_$exc_offset then do;	/* if this card is an activity terminator */
	     if gcos_ext_stat_$save_data.activ then do;	/* and an activity was being defined, run it now */

		if ^gcos_ext_stat_$save_data.flgs.ident then
		     goto jobort;			/* require $ident before first activity execution */

		if ^gcos_ext_stat_$save_data.nosave then
		     restart_control.na_restart = restart_control.na_hold; /* copy activity restart option */

		call gcos_run_activity_;

		if ^gcos_ext_stat_$save_data.nosave then do; /* if user requested save */
		     call gcos_write_$force_ptr (gcos_ext_stat_$er);
		     call gcos_write_$force_ptr (gcos_ext_stat_$rs);
		     call gcos_write_$force_ptr (gcos_ext_stat_$pch);
		     call gcos_restart_$save;		/* save state of simulator at activity end */
		end;
						/* so that we could restart from the beginning
						   of the next activity if we had to */
	     end;

/* Control also comes here to continue after running an activity,
   or after skipping a deleted activity. */

/* Here, check for two types of activity deletion, before beginning to
   define the next activity:
   1) run only compilations after an abort (and before a $ BREAK)
   2) if a compiler turns off psw bit 5, delete all execution activities,
   until somebody turns it back on.


   Execution activities are $ EXECUTE and $ 355SIM */
	     if i >= gcos_control_tables_$comp_offset then
		goto dont_delete;			/* never delete a compilation activity */
	     if gcos_ext_stat_$save_data.prev_act_abort then
		goto do_delete;			/* after an abort, delete all non-compilation activities */

	     if i > gcos_control_tables_$exc_offset + 1 then /* if not EXECUTE or 355SIM */
		goto dont_delete;			/* run regardless of PSW bit 5 */

	     if substr (save_data.psw, 6, 1) then	/* if PSW bit 5 is on */
		goto dont_delete;			/* then run EXECUTE OR 355SIM */


do_delete:     ;
	     gcos_ext_stat_$save_data.seeking
		, gcos_ext_stat_$save_data.seeking_terminator
		= "1"b;				/* set save_data to look for next terminator card */

	     goto delete_activity;			/* go print message and increment activity number */

dont_delete:   ;

	end;

	if (gcos_ext_stat_$activity_name = "geload")	/* if we are defining an EXECUTE activity */
	& (i <= gcos_control_tables_$filecard_count) then do; /* and this is a file card */
	     call gcos_write_$record ("r*", gcos_record, (8)"0"b); /* write it on R* */
	     gcos_ext_stat_$save_data.write_etc = "1"b;	/* and remember to write its continuation */
	     gcos_ext_stat_$etc_filecode = "r*";	/* (if any) on R* too */
	end;



/* FINALLY, CALL THE PROCESSOR FOR THIS CARD */


call_caller: ;
	goto cc (i);

cc (001):	;
	call gcos_cc_file_cards_$cc_print (card);	/* print card */
	goto loop;

cc (002):	;
	call gcos_cc_file_cards_$cc_punch (card);	/* punch card */
	goto loop;

cc (004):	;
/* disc card */

cc (005):	;
/* drum card */

cc (006):	;
/* file card */

cc (007):	;
/* mass card */

cc (003):	;
	call gcos_cc_file_cards_$cc_file (card);	/* disk card */
	goto loop;

cc (008):	;
	call gcos_cc_file_cards_$cc_prmfl (card);	/* prmfl card */
	goto loop;

cc (009):	;
	call gcos_cc_data_ (card);			/* data card */
	goto loop;

cc (010):	;
	call gcos_cc_file_cards_$cc_tape (card);	/* tape card */
	goto loop;

cc (011):	;
	call gcos_cc_file_cards_$cc_tape7 (card);	/* tape7 card */
	goto loop;

cc (012):	;
	call gcos_cc_file_cards_$cc_tape9 (card);	/* tape9 card */
	goto loop;

cc (013):	;
/* sysout card */

cc (014):	;
	call gcos_cc_file_cards_$cc_sysout (card);	/* remote card */
	goto loop;

cc (015):	;
	call gcos_cc_file_cards_$cc_dac (card);		/* dac card */
	goto loop;

cc (016):	;
	call gcos_cc_file_cards_$cc_type (card);	/* type card */
	goto loop;

cc (017):	;
	call gcos_cc_file_cards_$cc_read (card);	/* read card */
	goto loop;

cc (018):	;
	call gcos_cc_snumb_ (card);			/* snumb card */
	goto loop;

cc (019):	;
	call gcos_cc_misc_cards_$cc_comment (card);	/* comment card */
	goto loop;

cc (020):	;
	call gcos_cc_incode_ (card);			/* incode card */
	goto loop;

cc (021):	;
	call gcos_cc_misc_cards_$cc_etc (card, i, gcos_record); /* etc card */
	goto loop;

cc (022):	;
	call gcos_cc_misc_cards_$cc_endcopy (card);	/* endcopy card */
	goto loop;

cc (023):	;
	call gcos_cc_update_ (card, i, gcos_record);	/* update card */
	goto loop;

cc (024):	;
	call gcos_cc_limits_ (card);			/* limits card */
	goto loop;

cc (025):	;
	call gcos_cc_misc_cards_$cc_msg1 (card);	/* msg1 card */
	goto loop;

cc (026):	;
	call gcos_cc_misc_cards_$cc_msg2 (card);	/* msg2 card */
	goto loop;

cc (027):	;
	call gcos_cc_misc_cards_$cc_msg3 (card);	/* msg3 card */
	goto loop;

cc (028):	;
	call gcos_cc_misc_cards_$cc_userid (card);	/* userid card */
	goto loop;

cc (029):	;
	call gcos_cc_misc_cards_$cc_alter (card);	/* alter card */
	goto loop;

cc (030):	;
	call gcos_cc_set_ (card);			/* set card */
	goto loop;

cc (032):	;
/* copy card */

cc (033):	;
/* delete card */

cc (034):	;
/* endedit card */

cc (039):	;
/* include card */

cc (042):	;
/* list card */

cc (043):	;
/* modify card */

cc (045):	;
/* patch card */

cc (047):	;
/* seq card */

cc (048):	;
/* setsq card */

cc (053):	;
/* assem card */

cc (055):	;
/* get card */

cc (056):	;
/* getrwd card */

cc (058):	;
/* setsq1 card */

cc (031):	;
	call gcos_cc_directive_cards_$cc_editor (card, i, gcos_record); /* compile card */
	goto loop;

cc (036):	;
	call gcos_cc_directive_cards_$cc_ffile (card, i, gcos_record); /* ffile card */
	goto loop;

cc (040):	;
/* input card */

cc (041):	;
/* output card */

cc (044):	;
/* multi card */

cc (037):	;
	call gcos_cc_directive_cards_$cc_bmc (card, i, gcos_record); /* form card */
	goto loop;

cc (038):	;
/* futil card */
cc (046):	;
	call gcos_cc_directive_cards_$cc_utility (card, i, gcos_record); /* qutil card */
	goto loop;

cc (035):	;
/* endld card */

cc (049):	;
	call gcos_cc_directive_cards_$cc_sysedit (card, i, gcos_record); /* sysld card */
	goto loop;

cc (050):	;
	call gcos_cc_goto_$cc_when (card);		/* when card */
	goto loop;

cc (051):	;
	call gcos_cc_abort_ (card);			/* abort card */
	goto loop;

cc (052):	;
	call gcos_cc_directive_cards_$cc_dump (card, i, gcos_record); /* dump card */
	goto loop;

cc (054):	;
	call gcos_cc_directive_cards_$cc_sced (card, i, gcos_record); /* change card */
	goto loop;

cc (057):	;
	call gcos_cc_misc_cards_$cc_need (card);	/* need card */
	goto loop;

cc (059):	;
	call gcos_cc_param_ (card);			/* param card */
	goto loop;

cc (061):	;
/* library card */

cc (062):	;
/* lowload card */

cc (063):	;
/* use card */

cc (064):	;
/* entry card */

cc (065):	;
/* nolib card */

cc (066):	;
/* equate card */

cc (067):	;
/* link card */

cc (068):	;
/* relcom card */

cc (069):	;
/* source card */

cc (070):	;
/* dkend card */

cc (071):	;
/* nload card */

cc (060):	;
	call gcos_cc_loader_cards_ (card, i, gcos_record); /* option card */
	goto loop;

cc (104):	;    
	call gcos_cc_loader_cards_$cc_object (card, i, gcos_record); /* object card */
	goto loop;

cc (073):	;
/* 355sim card */

cc (074):	;
/* program card */

cc (075):	;
/* conver card */

cc (076):	;
/* filedit card */

cc (077):	;
/* sysedit card */

cc (078):	;
/* utility card */

cc (079):	;
/* utl2 card */

cc (080):	;
/* convrt card */

cc (081):	;
/* fortran card */

cc (082):	;
/* pl1 card */

cc (083):	;
/* cobol card */

cc (084):	;
/* gmap card */

cc (085):	;
/* 355map card */

cc (086):	;
/* algol card */

cc (087):	;
/* forta card */

cc (088):	;
/* forty card */

cc (089):	;
/* jovial card */

cc (090):	;
/* asm66 card */

cc (091):	;
/* cbl74 card */

cc (092):	;
/* cbl68 card */

cc (093):	;
/* malt card */

cc (094):	;
/* ilang card */

cc (095):	;
/* ids card */

cc (096):	;
/* ids2 card */

cc (097):	;
/* 4tran card */

cc (098):	;
/* g3edit card */

cc (099):	;
/* fort77 card */

cc (100):	;
/* fortx card */

cc (101):	;
/* cids2 card */

cc (102):	;
/* rpg2 card */

cc (072):	;
	call gcos_cc_activity_cards_ (card, i, gcos_record); /* execute card */
	goto loop;

cc (103):	;
	call gcos_cc_ident_ (card);			/* ident card */
	goto loop;

cc (105):	;
	call gcos_cc_misc_cards_$cc_break (card);	/* break card */
	goto loop;

cc (106):	;
	call gcos_cc_goto_ (card);			/* goto card */
	goto loop;

cc (107):	;
	call gcos_cc_goto_$cc_if (card);		/* if card */
	goto loop;

cc (108):	;
	call gcos_cc_endjob_ (card);			/* endjob card */
	goto loop;				/* continue processing */

/* Come here to abort job if snumb-ident sequence is not right */

no_snumb:	;
	call gcos_error_ (
	     gcos_et_$cc_bad_card
	     , "$ SNUMB must be first control card.^/^a^2x^a"
	     , gcos_ext_stat_$card_num
	     , card
	     );

jobort:	;
	call gcos_error_ (
	     gcos_et_$cc_bad_card
	     , "$ IDENT must follow $ SNUMB imediately.^/^a^2x^a"
	     , gcos_ext_stat_$card_num
	     , card
	     );


/* Come here when a nondollar card is read */

nondollar: ;
	if gcos_ext_stat_$save_data.seeking then goto loop; /* if we are seeking a label or terminator,
						   we skip over all nondollar cards */

	gcos_ext_stat_$save_data.write_etc = "0"b;	/* the only way to be sure this switch does not get
						   left on too long is to turn it off every time we read
						   a non-etc card */

	if gcos_ext_stat_$save_data.nondollar then goto nondl_write; /* skip if already processing nondollar cards */

/* Enforce restriction on position of snumb and ident cards */
	if ^gcos_ext_stat_$save_data.snumb then goto loop; /* skip cards before snumb */
	if ^gcos_ext_stat_$save_data.flgs.ident then goto jobort; /* abort if cards between snumb and ident */

/* Write the nondollar card on a file (maybe) */

/* we are starting a new nondollar file */
	gcos_ext_stat_$nondollar =			/* whose filecode will be */
	     gcos_ext_stat_$default_nondollar;		/* the default nondollar filecode */
						/* which could be blank if we have already "used it up" */
	gcos_ext_stat_$default_nondollar = "";		/* we have used it up now, if not before */

	if gcos_ext_stat_$nondollar = "" then do;	/* if we had used it up previously */
	     nondollar_cards_skipped = nondollar_cards_skipped + 1; /* skip over the cards */
	     goto loop;
	end;					/* otherwise fall thru and write it on the file */

	gcos_ext_stat_$save_data.nondollar = "1"b;	/* set flag to say processing a data deck */

nondl_write: ;
	if gcos_ext_stat_$nondollar ^= "" then		/*  check for writing to geload r* file */
	     call gcos_write_$record (
	     gcos_ext_stat_$nondollar
	     , gcos_record
	     , (8)"0"b
	     );
	else
	call gcos_write_$record_ptr (
	     gcos_ext_stat_$rs
	     , gcos_record
	     , "0"b
	     );					/* write to r* collector file */
	goto loop;				/* continue */


/* Come here to process possible label cards */

label_card: ;					/* columns 2-7 were not completely blank */

/* get label */
	do j = 3 to 7
		while (substr (card, j, 1) = " ");	/* find beginning of label */
	end;
						/* j now points to its first character */
	k = index (substr (card, j), " ") - 2;		/* get length of label */
	if k < 1 then goto unknown_card;		/* bad label */
	if k > 6 then goto unknown_card;		/* bad label */
	if substr (card, j+k, 1) ^= ":" then		/* if it does not end in colon */
	     if substr (card, j+k, 1) ^= "." then	/* or period */
		goto unknown_card;			/* bad label */

/* good label */
	if ^gcos_ext_stat_$save_data.seeking then goto loop; /* skip it if not looking for anything */
	if gcos_ext_stat_$sought_label = "" then goto loop; /* or if not seeking a label */
	if substr (card, j, k) ^=			/* if the label */
	gcos_ext_stat_$sought_label then		/* is not the one we sought */
	     goto loop;				/* then keep looking for it */

/* we found it */
	gcos_ext_stat_$sought_label = "";		/* so stop looking */
	gcos_ext_stat_$save_data.seeking, gcos_ext_stat_$save_data.seeking_terminator = "0"b;

	goto loop;				/* and go get next card to process */

/* Control comes here from gcos_cc_endjob_ via a nonlocal goto,
   if that procedure was able to complete the termination of the job. */

normal_termination: ;
	call release_temp;
	return;
%page;

/* 	File information block initialization routines	 */


/* 	Fib initialization for syspunch	 */

fib_init (1): ;
	gcos_ext_stat_$pch = fibptr;			/* save sysout punch collector fib pointer */
	fib.stream = "syspunch";			/* file id is "syspunch" */
	fib.punch = "1"b;				/* punch file */
	goto continue;				/* return to processing loop */


/* 	Fib initialization for sysprint	 */

fib_init (2): ;
	gcos_ext_stat_$prt = fibptr;			/* save sysout print collector fib pointer */
	fib.stream = "sysprint";			/* file id is "sysprint" */
	fib.print = "1"b;				/* print file */
	goto continue;				/* return to processing loop */

/* 	Fib initialization for execution report file	 */

fib_init (3): ;
	gcos_ext_stat_$er = fibptr;			/* save execution report fib pointer */
	fib.stream = "exec_rpt";			/* file id is "exec_rpt" */
	fib.print = "1"b;				/* print file */
	goto continue;				/* return to processing loop */

/*	Fib initialization for geload r* collector file 	*/

fib_init (4): ;
	gcos_ext_stat_$rs = fibptr;			/* save fib pointer */
	fib.stream = "rstar";			/* file id is "rstar" */
	goto continue;				/* return to processing loop */
%page;
dollar_print: entry;

/* 	Enter here to set switch to cause control cards to be printed			 */
	cc_print_sw = ^cc_print_sw;			/* flip switch */
	if cc_print_sw then msg_var = "on";
	else msg_var = "off";
	call ioa_ ("control card printing turned ^a", msg_var);
	return;
%page;
gein_cleanup: proc;					/*     CLEANUP HANDLER FOR ENTIRE SIMULATOR EXCEPT PASS1   */
	     do i = 1 to hbound (save_data.fibs, 1);	/* go thru all fibs */
		fibptr = addr (save_data.fibs (i));
		if ^fib.used then goto get_next_fib;	/* if unused, skip to next one */
		if ^fib.attached then goto get_next_fib; /* file not attached, skip to next */
		if fib.console then goto get_next_fib;	/* a console device is never really attached */
		if fib.null then goto get_next_fib;	/* neither is a null file */
		call ios_$detach (fib.stream, "", "", status);
						/* ignore errors */

/* NOTE THAT ALL THE SPECIAL CASE CHECKS FOLLOWING MUST BE REVIEWED, AFTER ANY
   MAJOR CHANGE TO THE SIMULATOR, TO MAKE CERTAIN THEY ARE STILL VALID.  */
		if fib.print then goto keep_it;	/* don't delete print files */
		if fib.punch then goto keep_it;	/* ... or punch files */
		if fib.tape then goto keep_it;	/* nothing to delete here */
		call expand_pathname_ (
		     fib.pathnm
		     , fullname
		     , ename
		     , code
		     );
		if code ^= 0 then goto keep_it;	/* ignore errors, but don't get into trouble doing it */
		if fib.perm then goto keep_it;	/* don't delete perm files */
		call delete_$path (
		     fullname
		     , ename
		     , "07"b3			/* noforce,noquestion,nodirs,segs,links,chase */
		     , "gcos"
		     , code
		     );
						/* ignore errors */
keep_it:		;

/* Clean up any possible IDS2 locked files */
		if fib.perm & fib.type /* rand */
		     then if gcos_ids2_concur_$have_xid(fullname,ename,code)
		         then call gcos_ids2_concur_$deallocate(
		              fullname,ename,fib.read, fib.write,code);
		

/* Make buffer available. */
		if fib.buffer_indx > 0 then do;
		     fib_buffers.buffer_in_use (fib.buffer_indx) = "0"b;
		     fib.buffer_indx = 0;
		     fib.buffer = null ();
		end;
get_next_fib:	;
	     end;					/* fall thru when all fibs examined */
	     call ios_$detach ((lib_streams (1)), "", "", status); /* detach the system libraries */
	     call ios_$detach ((lib_streams (2)), "", "", status);
	     call ios_$detach ("gcos_job_stream_", "", "", status); /* it could be attached if:
						   1) we were still in pass1, or
						   2) it was a msf */
	     call delete_$path (
		string (gcos_ext_stat_$save_dir)
		, gcos_ext_stat_$job_id || ".job_deck"
		, "07"b3
		, "gcos"
		, code
		);
	     call delete_$path (
		string (gcos_ext_stat_$save_dir)
		, gcos_ext_stat_$job_id || ".save_data"
		, "07"b3
		, "gcos"
		, code
		);
	     if gcos_ext_stat_$gcos_slave_area_seg ^= null then
		call hcs_$truncate_seg (
		gcos_ext_stat_$gcos_slave_area_seg
		, 0
		, code
		);
	     if gcos_ext_stat_$temp_seg_ptr ^= null () then do;
		call release_temp;
	     end;
	     return;

	end gein_cleanup;
%page;
release_temp: proc;

	     call release_temp_segment_ (
		"gcos"
		, gcos_ext_stat_$temp_seg_ptr
		, code
		);
	     if code ^= 0 then
		call com_err_ (			/* Could not release temp segment. */
		code
		, "gcos"
		, "^/Releasing temp segment (^p)"
		, gcos_ext_stat_$temp_seg_ptr
		);
	     return;

	end release_temp;
%page;
/*   Variables for gcos_gein_:		 */
/*   IDENTIFIER		ATTRIBUTES	 */
dcl  addr                     builtin;
dcl  addrel                   builtin;
dcl  baseno                   builtin;
dcl  bit_count                fixed bin(24)	/* length of input segment in bits */;
dcl  card                     char(80)	/* card image returned by gcos_read_card_ */;
dcl  card_type                char(8) aligned	/* card type extracted from dollar card image */;
dcl  cc_print_sw              bit(1) int static init ("0"b);
dcl  char                     builtin;
dcl  cleanup                  condition;
dcl  clock                    builtin;
dcl  code                     fixed bin(35) based (addr (status))	/* return param. for passing error codes */;
dcl  com_err_                 entry() options(variable);
dcl  date_time_               ext entry (fixed bin(71), char(*));
dcl  delete_$path             entry (char(*), char(*), bit(6), char(*), fixed bin(35));
dcl  dollar_card_count        fixed bin(24)init (0)		/* Count of "$" cards. */;
dcl  dollar_sw                bit(1) ;
dcl  ename                    char(32) 	/* holds entry name of input seg */;
dcl  error_table_$noentry     ext fixed bin(35);
dcl  error_table_$no_s_permission ext fixed bin(35);
dcl  err_msg                  char(150)	/* for com_err calls */;
dcl  expand_pathname_         entry (char(*), char(*), char(*), fixed bin(35));
dcl  firstrecord              char(60) based (addr (first_record))	/* overlay for 15-word first_record structure */;
dcl  fullname                 char(168)	/* holds pathname of input seg */;
dcl  gcos$                    ext;
dcl  gcos_cc_abort_           entry options(variable);
dcl  gcos_cc_activity_cards_  entry (char(80), fixed bin(24), char(*));
dcl  gcos_cc_data_            entry (char(80));
dcl  gcos_cc_directive_cards_$cc_bmc entry (char(80), fixed bin(24), char(*));
dcl  gcos_cc_directive_cards_$cc_dump entry (char(80), fixed bin(24), char(*));
dcl  gcos_cc_directive_cards_$cc_editor entry (char(80), fixed bin(24), char(*));
dcl  gcos_cc_directive_cards_$cc_ffile entry (char(80), fixed bin(24), char(*));
dcl  gcos_cc_directive_cards_$cc_sced entry (char(80), fixed bin(24), char(*));
dcl  gcos_cc_directive_cards_$cc_sysedit entry (char(80), fixed bin(24), char(*));
dcl  gcos_cc_directive_cards_$cc_utility entry (char(80), fixed bin(24), char(*));
dcl  gcos_cc_endjob_          entry (char(80));
dcl  gcos_cc_file_cards_$cc_dac entry (char(80));
dcl  gcos_cc_file_cards_$cc_file entry (char(80));
dcl  gcos_cc_file_cards_$cc_print entry (char(80));
dcl  gcos_cc_file_cards_$cc_prmfl entry (char(80));
dcl  gcos_cc_file_cards_$cc_punch entry (char(80));
dcl  gcos_cc_file_cards_$cc_read entry (char(80));
dcl  gcos_cc_file_cards_$cc_sysout entry (char(80));
dcl  gcos_cc_file_cards_$cc_tape entry (char(80));
dcl  gcos_cc_file_cards_$cc_tape7 entry (char(80));
dcl  gcos_cc_file_cards_$cc_tape9 entry (char(80));
dcl  gcos_cc_file_cards_$cc_type entry (char(80));
dcl  gcos_cc_goto_            entry (char(80));
dcl  gcos_cc_goto_$cc_if      entry (char(80));
dcl  gcos_cc_goto_$cc_when    entry (char(80));
dcl  gcos_cc_ident_           entry (char(80));
dcl  gcos_cc_incode_          entry (char(80));
dcl  gcos_cc_limits_          entry (char(80));
dcl  gcos_cc_loader_cards_    entry (char(80), fixed bin(24), char(*));
dcl  gcos_cc_loader_cards_$cc_object   entry (char(80), fixed bin(24), char(*));
dcl  gcos_cc_misc_cards_$cc_alter entry (char(80));
dcl  gcos_cc_misc_cards_$cc_break entry options(variable);
dcl  gcos_cc_misc_cards_$cc_comment entry (char(80));
dcl  gcos_cc_misc_cards_$cc_endcopy entry (char(80));
dcl  gcos_cc_misc_cards_$cc_etc entry (char(80), fixed bin(24), char(*));
dcl  gcos_cc_misc_cards_$cc_msg1 entry options(variable);
dcl  gcos_cc_misc_cards_$cc_msg2 entry (char(80));
dcl  gcos_cc_misc_cards_$cc_msg3 entry options(variable);
dcl  gcos_cc_misc_cards_$cc_need entry (char(80));
dcl  gcos_cc_misc_cards_$cc_userid entry (char(80));
dcl  gcos_cc_param_           entry (char(80));
dcl  gcos_cc_set_             entry (char(80));
dcl  gcos_cc_snumb_           entry (char(80));
dcl  gcos_cc_update_          entry (char(80), fixed bin(24), char(*));
dcl  gcos_error_              ext entry options (variable);
dcl  gcos_et_$cc_bad_card     fixed bin(35) ext;
dcl  gcos_gein_pass1_         ext entry;
dcl  gcos_ids2_concur_$deallocate ext entry (char(*), char(*), bit(1), bit(1), fixed bin(35));
dcl  gcos_ids2_concur_$have_xid ext entry (char(*), char(*), fixed bin(35)) returns (bit(1));
dcl  gcos_len                 fixed bin(24);
dcl  gcos_open_file_          ext entry (char(*), char(*), pointer, bit(1));
dcl  gcos_ptr                 ptr;
dcl  gcos_read_card_          entry (ptr, fixed bin(24), char(80), bit(1));
dcl  gcos_record              char(gcos_len) based (gcos_ptr);
dcl  gcos_restart_            entry (fixed bin(24));
dcl  gcos_restart_$save       ext entry;
dcl  gcos_run_activity_       ext entry;
dcl  gcos_write_$ascii_ptr    ext entry (ptr, char(*), bit(8));
dcl  gcos_write_$force_ptr    ext entry (ptr);
dcl  gcos_write_$ptr          ext entry (ptr, char(*), bit(8));
dcl  gcos_write_$record       ext entry (char(*), char(*), bit(8));
dcl  gcos_write_$record_ptr   ext entry (ptr, char(*), bit(8));
dcl  get_temp_segment_        entry (char(*), ptr, fixed bin(35));
dcl  gptr                     ptr	/* pointer to gcos bound segment, for object_info_ */;
dcl  hbound                   builtin;
dcl  hcs_$fs_get_path_name    entry (ptr, char(*), fixed bin(24), char(*), fixed bin(35));
dcl  hcs_$get_search_rules    ext entry (ptr);
dcl  hcs_$get_usage_values    ext entry (fixed bin(24), fixed bin(71), fixed bin(24));
dcl  hcs_$initiate            entry (char(*), char(*), char(*), fixed bin(1), fixed bin(2), ptr, fixed bin(35));
dcl  hcs_$make_seg            ext entry (char(*), char(*), char(*), fixed bin(5), ptr, fixed bin(35));
dcl  hcs_$status_mins         ext entry (ptr, fixed bin(2), fixed bin(24), fixed bin(35));
dcl  hcs_$truncate_seg        ext entry (ptr, fixed bin(24), fixed bin(35));
dcl  i                        fixed bin(24);
dcl  index                    builtin;
dcl  initialized              bit(1) internal static init ("0"b);
dcl  ioa_                     entry() options(variable);
dcl  ioa_$nnl                 entry() options(variable);
dcl  ioa_$rs                  entry() options(variable);
dcl  ios_$attach              ext entry (char(*) aligned, char(*), char(*) aligned, char(*), bit(72) aligned);
dcl  ios_$detach              ext entry (char(*), char(*) aligned, char(*), bit(72) aligned);
dcl  ios_$setsize             ext entry (char(*) aligned, fixed bin(24), bit(72) aligned);
dcl  j                        fixed bin(24);
dcl  k                        fixed bin(24)/* temp */;
dcl  lib_count                fixed bin(24)/* number of libraries in use (2 or 3) */;
dcl  lib_path                 char(168) aligned	/* temporary for library pathnames */;
dcl  lib_streams              (2)char(4)aligned int static options(constant)init("glib", "slib") /* software library streams */;
dcl  LOWER_CASE               char(26) static internal options (constant) init ("abcdefghijklmnopqrstuvwxyz");
dcl  msg_var                  char(4);
dcl  nondollar_cards_skipped  fixed bin(24)init (0)	/* to count skipped nondollar cards, for debugging */;
dcl  null                     builtin;
dcl  object_info_$display     ext entry (ptr, fixed bin(24), ptr, fixed bin(35));
dcl  release_temp_segment_    entry (char(*), ptr, fixed bin(35));
dcl  rtrim                    builtin;
dcl  seg_type                 char(8) aligned	/* segment type (bound or compiled)  */;
dcl  size                     builtin;
dcl  status                   bit(72) aligned;
dcl  string                   builtin;
dcl  substr                   builtin;
dcl  sw                       bit(1)	/* sw set by open. Not used here */;
dcl  sys_info$max_seg_size    ext fixed bin(24)/* 64K or 256K ? */;
dcl  translate                builtin;
dcl  type                     fixed bin(2);
dcl  UPPER_CASE               char(26) static internal options (constant) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
dcl  user_info_$homedir       entry (char(*));
dcl  var_msg                  char(j) based (addr (err_msg))	/* variable length overlay for above */;
dcl  word                     bit(36) aligned based	/* to put bits into a word */;

dcl  execute_search_rules_    entry (
			char(32)
,			bit(8) aligned
,			char(168)
,			char(32)
,			fixed bin(2)
,			fixed bin(24)
,			fixed bin(35)
);

dcl  execute_search_rules_$s_r_ptr entry (
			char(32)
,			bit(8) aligned
,			ptr
,			char(168)
,			char(32)
,			fixed bin(2)
,			fixed bin(24)
,			fixed bin(35)
);

dcl  lib_names                (4)char(32)int static options(constant) init (	/* names of libraries */
     "gcos_library_subroutines_",			/* geload l* file */
     "gcos_system_patchfile_",			/* patch file */
     "gcos_system_software_",				/* glib file */
     "gcos_second_software_");						/* slib file */

dcl 1 execution_msg int static aligned,			/* execution report header msg */
    2 part1 char(54) unaligned initial ("EXECUTION REPORT, MULTICS GCOS ENVIRONMENT SIMULATOR "),
    2 date_time char(24) unaligned,
    2 spacing char(1) unaligned initial ("
");						/* newline */


dcl 1 vrsn_msg int static aligned,
    2 part1 char(11) unaligned init ("Version of "),
    2 date_time char(24) unaligned,
    2 spacing char(2) unaligned init ("

");						/* two newlines */


dcl 1 first_record int static aligned,			/* first record on sysout print collector file */
    2 rcw bit(36) init ("000016000374"b3                       ),
						/* length=14, media code=3 (bcd print), report code=74 */
    2 newline_word bit(36) init ("770100000000"b3                       ),
						/* the 7701 (bcd newline) prevents gcos_sys_xlate_ from
						   trying to translate the stuff that follows */
    2 rec1 char(4) init ("rec1"),			/* to verify that this is the sysout header record */
						/* NOTE: the ASCII characters in a record whose media code
						   says BCD is deliberate - not an error */
    2 er_offset fixed bin(24)aligned init (0),		/* a word in which the offset of the execution report in the
						   sysout file will be written, later, by gcos_cc_endjob_ */
    2 jobs_snumb char(5) init ("NONE "),		/* place for gcos_cc_endjob_ to put snumb */
    2 pad1 char(3),					/* to pad out to a full word */
    2 pad2 (9) fixed bin(24)aligned			/* 9 spare words, making a 14-data-word record */;

dcl 1 search_rules	aligned
,     2 number	fixed bin(24)
,     2 names	(21)char(168)aligned
;

dcl  FF                       char(1) static int options(constant)init("");
%page;
%include gcos_fibs;
%page;
dcl 1 obj_info aligned like object_info;
%include object_info;
%page;
%include gcos_restart_control_;
%page;
%include gcos_control_tables_;
%page;
%include gcos_gtss_dcls;
%page;
%include gcos_ext_stat_;
     end gcos_gein_;
