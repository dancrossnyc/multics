/****^  **************************************************************
        *                                                            *
        * Copyright, (C) BULL HN Information Systems Inc., 1992      *
        *                                                            *
        * Copyright, (C) Massachusetts Institute of Technology, 1984 *
        *                                                            *
        ************************************************************** */



/****^  HISTORY COMMENTS:
  1) change(86-07-29,Pattin), approve(86-07-29,MCR7356),
     audit(86-08-07,Margolin), install(86-08-16,MR12.0-1128):
     Added $rechain entry point.
  2) change(86-07-30,Pattin), approve(86-07-30,MCR7354),
     audit(86-08-07,Margolin), install(86-08-16,MR12.0-1128):
     Added (next previous)_transaction entries.  Improved handling of RQO
     during salvage/copy and transaction entering.  Fixed some looping bugs in
     trans_time_info.  Fixed trans_time_info error return.  Other performance
     improvements in forum_limits and trans_ref_info.
  3) change(92-10-07,Vu), approve(92-10-07,MCR8273), audit(92-10-08,Zimmerman),
     install(92-10-19,MR12.5-1027):
     Forum will go into an infinite loop for any date_time string which falls
     between transaction blocks.
                                                   END HISTORY COMMENTS */


/* SECURITY/AUDITING NOTE:
   The enter_trans and rechain entrypoints reference the string arguments
   (P_input_string and P_subject) twice.  Since neither of these strings
   are used in any security or integrity checking, this should not be
   considered a violation of the standard that states that gates should
   only reference their arguments twice.  */

/* format: style3,ifthen,ifthendo,ifthenstmt,^indnoniterdo,^inditerdo,idind30 */

forum_trans_mgr_$enter_trans:
     procedure (P_forum_idx, P_input_string, P_pref, P_subject, P_filled_sw, P_trans_idx, P_status);

/*  Version 2 Forum -
   This module deals with entering and reading transactions, and
   managing information relating to transactions.

   Jay Pattin 1/2/83
   8/19/83 Jay Pattin new notifications
   Modified 11/20/83 by Jeffrey I. Schiller to allow expunging of
   forums with multiple proceedings segments (prior behavior was
   an FPE). Also bugfixes to support large (upto one segment) transactions. 
   Modified 12/22/83 by Jeffrey I. Schiller to fix bug in forum_limits
   as applied to expunged transactions.
   Audit changes, J. Spencer Love 10/05/84 */

declare  (
         P_attendee_offset bit (18),
         P_bit_map bit (*),
         P_deleted_sw bit (1) aligned,
         P_directory char (*),
         P_filled_sw bit (1) aligned,
         P_first_trans_idx fixed bin,
         P_flags_word bit (36) aligned,
         P_forum_idx fixed bin,
         (P_high_time, P_low_time) fixed bin (71),
         (P_high_trans, P_low_trans) fixed bin,
         P_input_string char (*),
         P_last_trans_idx fixed bin,
         P_last_seen_trans_idx fixed bin,
         P_name char (*),
         P_new_trans_count fixed bin,
        (P_next, P_previous) fixed bin,
         P_open_data_ptr ptr,
         P_area_ptr ptr,
         P_trans_ptr ptr,
         (P_pref, P_nref) fixed bin,
         P_status fixed bin (35),
         P_subject char (*),
         P_trans_idx fixed bin,
         P_type fixed bin,
         P_uid bit (36) aligned,
         P_user_name char (*),
         P_value_sw bit (1) aligned
         ) parameter;

declare  chairman bit (1) aligned,
         directory char (168),
         done bit (1) aligned,
         forum_idx fixed bin,
         input_len fixed bin (21),
         (high_time, low_time) fixed bin (71),
         (high_trans, low_trans) fixed bin,
         idx fixed bin,
         loading bit (1) aligned,
         message char (256),
         name char (32),
         new_trans_count fixed bin,
         next_trans_ptr ptr,
         next_word fixed bin (35),
         (nref, pref) fixed bin,
         privileged bit (1) aligned,
         status fixed bin (35),
         subject_len fixed bin (21),
         subject_offset bit (18) aligned,
         text_offset bit (18) aligned,
         trans_idx fixed bin,
         trans_ptr ptr,
         type fixed bin,
         user_name char (32),
         value_sw bit (1) aligned,
         xacl bit (36) aligned,
         (any_other, area, record_quota_overflow, seg_fault_error, cleanup) condition,
         (addr, binary, bit, clock, copy, divide, index, length, null, ptr, rel, rtrim, string, substr) builtin;

declare  person_id char (22) static,
         project_id char (9) static,
         static_init bit (1) aligned static init ("0"b);

declare  1 forum_message aligned,
	 2 forum_uid bit (36),
	 2 attendee_offset bit (18);

declare  ipc_message fixed bin (71) based (addr (forum_message));
declare  forum_logger_ entry options (variable),
         forum_logger_$any_other entry options (variable),
         forum_notify_gate_$lookup entry (char (*), bit (1) aligned, fixed bin (35)),
         forum_open_mgr_$lookup_forum_idx entry (fixed bin, ptr, bit (36) aligned, fixed bin (35)),
         forum_seg_mgr_$create_segment entry (ptr, fixed bin (35)),
         forum_seg_mgr_$initiate entry (char (*), char (*), bit (1) aligned, ptr, ptr, bit (36) aligned, fixed bin (35)),
         forum_seg_mgr_$initiate_seg entry (ptr, fixed bin, fixed bin (35)),
         forum_seg_mgr_$terminate entry (ptr, ptr),
         forum_seg_mgr_$unlock entry (ptr),
         forum_space_mgr_$allocate_bit_map entry (ptr, ptr, fixed bin, ptr, fixed bin (35)),
         forum_space_mgr_$find_attendee entry (ptr, char (*), ptr, fixed bin (35)),
	forum_space_mgr_$find_next_transaction entry (ptr, fixed bin, fixed bin, fixed bin(35)),
	forum_space_mgr_$find_prev_transaction entry (ptr, fixed bin, fixed bin, fixed bin(35)),
         forum_space_mgr_$find_transaction entry (ptr, fixed bin, ptr, fixed bin (35)),
         forum_space_mgr_$get_transaction_slot entry (ptr, ptr, fixed bin (35)),
         forum_space_mgr_$get_highest_seen entry (ptr, ptr, bit (1) aligned, fixed bin, ptr, fixed bin (35)),
         get_temp_segment_ entry (char (*), ptr, fixed bin (35)),
         hcs_$force_write entry (ptr, bit (36), fixed bin (35)),
         hcs_$wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35)),
         ioa_$rsnnl entry options (variable),
         send_mail_ entry (char (*), char (*), ptr, fixed bin (35)),
         sys_info$max_seg_size fixed bin(35) ext static,
         user_info_$login_data
	    entry (char (*), char (*), char (*), fixed bin, fixed bin, fixed bin, fixed bin (71), char (*));

declare  (
         error_table_$noalloc,
         error_table_$rqover,
         error_table_$seg_busted,
         forum_et_$cant_notify,
         forum_et_$no_message,
         forum_et_$not_eligible,
         forum_et_$meeting_bloat,
         forum_et_$message_too_long,
         forum_et_$incorrect_uid,
         forum_et_$read_only,
         forum_et_$rqo,
         forum_et_$rqo_load,
         forum_et_$trans_deleted,
         forum_et_$chairman_only,
         forum_et_$invalid_att_idx,
         forum_et_$unexpected_fault
         ) fixed bin (35) external;

declare  (
         forum_data_$print_eligibility_messages,
         forum_data_$chairman_override
         ) bit (1) aligned external;

declare  egress label variable,
         output_area area based (P_area_ptr),
         proceeding_string char (alloc_text_length) based (trans_ptr),
         subject char (subject_len) based,
         text char (input_len) based;
%page;
%include forum_structures;
%page;
%include forum_open_data;
%page;
%include forum_flags;
%page;
%include forum_user_trans;
%page;
%include send_mail_info;
%page;
/* forum_trans_mgr_$enter_trans:
   procedure (P_forum_idx, P_input_string, P_pref, P_subject, P_filled_sw, P_trans_idx, P_status); */

	loading = "0"b;
	goto ENTER_COMMON;

forum_trans_mgr_$load_trans:
     entry (P_open_data_ptr, P_input_string, P_pref, P_subject, P_filled_sw, P_trans_idx, P_status);

	loading = "1"b;
ENTER_COMMON:
	call initialize (ENTER_PUNT);

	on cleanup call forum_seg_mgr_$unlock (attendee_seg_ptr);
	on seg_fault_error call error (error_table_$seg_busted);
	on any_other call any_other_handler ();

	if ^loading then do;
	     forum_idx = P_forum_idx;
	     call forum_open_mgr_$lookup_forum_idx (forum_idx, open_data_ptr, xacl, status);
	     if status ^= 0
	     then call error (status);
	end;
	else open_data_ptr = P_open_data_ptr;

	transaction_seg_ptr = open_data.transaction_seg_ptr;
	attendee_seg_ptr = open_data.attendee_seg_ptr;
	if ^loading then do;
	     if xacl = R_XACL
	     then call error (forum_et_$read_only);
	     attendee_ptr = open_data.attendee_ptr;
	     bit_map_ptr = open_data.bit_map_ptr;
	end;

	pref = P_pref;
	if pref ^= 0 then do;
	     call forum_space_mgr_$find_transaction (transaction_seg_ptr, pref, trans_ptr, status);
	     if status ^= 0
	     then if loading
		then pref = 0;
		else call error (status);
	end;

	idx = transaction_seg.current_segno;
	if open_data.proceedings_ptrs (idx) = null () then do;
	     if ^attendee_seg.salvaging then
		call forum_seg_mgr_$initiate_seg (open_data_ptr, idx, status);
	     else call get_temp_segment_ ("forum_salvager_", open_data.proceedings_ptrs (idx), status);
	     if status ^= 0
	     then call error (status);
	end;

	next_word = binary (transaction_seg.next_trans_offset, 35);
	input_len = length (rtrim (P_input_string));
	subject_len = length (rtrim (P_subject));

	if (next_word + divide (subject_len + input_len + 3, 4, 35) + 2) > sys_info$max_seg_size
	     then do; 
	     call get_new_seg ();
	     next_word = 0;
	end;

	next_trans_ptr = ptr (open_data.proceedings_ptrs (idx), next_word);

	on record_quota_overflow begin;
	     if loading then call error (forum_et_$rqo_load);
	     else call error (forum_et_$rqo);
	end;

	next_trans_ptr -> subject = P_subject;
	subject_offset = rel (next_trans_ptr);
	next_word = next_word + divide (subject_len + 3, 4, 35);
	next_trans_ptr = ptr (next_trans_ptr, next_word);
	next_trans_ptr -> text = P_input_string;
	text_offset = rel (next_trans_ptr);
	next_word = next_word + divide (input_len + 3, 4, 35);
	transaction_seg.next_trans_offset = bit (binary (next_word, 18), 18);

	call forum_space_mgr_$get_transaction_slot (transaction_seg_ptr, transaction_ptr, status);
	if status ^= 0
	then call error (status);

	transaction.segno = idx;
	transaction.subject_offset = subject_offset;
	transaction.subject_length = subject_len;
	transaction.text_offset = text_offset;
	transaction.text_length = input_len;

	if ^loading then do;
	     call hcs_$force_write (open_data.proceedings_ptrs (idx), (""b), (0));
	     transaction.person_id = person_id;
	     transaction.project_id = project_id;
	     transaction.time = clock ();
	end;

	transaction.nref_offset = ""b;
	string (transaction.flags) = ""b;
	transaction.unfilled = P_filled_sw;

	if pref ^= 0 then do;			/* link this transaction into reply chain if apropriate */
	     done = "0"b;
	     do while (^done);
		if trans_ptr -> transaction.nref_offset = ""b
		then done = "1"b;
		else trans_ptr = ptr (transaction_seg_ptr, trans_ptr -> transaction.nref_offset);
	     end;
	     trans_ptr -> transaction.nref_offset = rel (transaction_ptr);
	     transaction.pref_offset = rel (trans_ptr);
	end;

	if ^loading then call set_seen_switch (transaction.trans_idx, "1"b);
	P_trans_idx = transaction.trans_idx;

	revert seg_fault_error;
	revert record_quota_overflow;

	on any_other
	     begin;
		on any_other system;
		call forum_logger_$any_other (0, "forum_trans_mgr_ (notify)", open_data.forum_name);
		call error (forum_et_$cant_notify);
	     end;

	status = 0;

	if ^loading then do;
	     forum_message.forum_uid = open_data.forum_uid;
						/* for validation purposes */
	     forum_message.attendee_offset = rel (attendee_ptr);

	     call ioa_$rsnnl ("A new transaction has just been added to the ^a meeting.", message, (0),
		open_data.forum_name);

	     send_mail_info.version = 2;
	     send_mail_info.sent_from = "forum";
	     string (send_mail_info.switches) = ""b;
	     send_mail_info.wakeup, send_mail_info.always_add = "1"b;

	     attendee_ptr = ptr (attendee_seg_ptr, attendee_seg.first_attendee_offset);
	     do while (attendee_ptr ^= null ());
		if attendee.person_id = person_id
		then goto NEXT;
		if attendee.attending & attendee.participating
		then call hcs_$wakeup (attendee.process_id, attendee.event_channel, ipc_message, (0));
		else if attendee.notify & attendee.participating then do;
		     call forum_notify_gate_$lookup ((attendee.person_id), done, status);
		     if done & status = 0
		     then call send_mail_ (rtrim (attendee.person_id) || "." || rtrim (attendee.project_id),
			     rtrim (message), addr (send_mail_info), (0));
		end;
NEXT:
		if attendee.next_offset = ""b
		then attendee_ptr = null ();
		else attendee_ptr = ptr (attendee_seg_ptr, attendee.next_offset);
	     end;
	     status = 0;
	     call forum_seg_mgr_$unlock (attendee_seg_ptr);
	end;
	P_status = status;
	return;

ENTER_PUNT:
	if ^loading
	then call forum_seg_mgr_$unlock (attendee_seg_ptr);
	P_status = status;
	return;
%page;
get_new_seg:
     proc ();

	if attendee_seg.salvaging then do;
	     idx, transaction_seg.current_segno = transaction_seg.current_segno + 1;
	     transaction_seg.next_trans_offset = ""b;
	     call get_temp_segment_ ("forum_salvager_", open_data.proceedings_ptrs (idx), status);
	     if status ^= 0
	     then call error (status);
	end;
	else do;
	     call forum_seg_mgr_$create_segment (open_data_ptr, status);
	     if status ^= 0
	     then call error (status);

	     idx = transaction_seg.current_segno;

	     call forum_seg_mgr_$initiate_seg (open_data_ptr, idx, status);
	     if status ^= 0
	     then call error (status);
	end;

	next_trans_ptr = open_data.proceedings_ptrs (idx);
	return;

     end get_new_seg;
%page;
forum_trans_mgr_$rechain:
     entry (P_forum_idx, P_trans_idx, P_pref, P_subject, P_status);

	call initialize (CHAIN_PUNT);

	on cleanup call forum_seg_mgr_$unlock (attendee_seg_ptr);
	on any_other call any_other_handler ();

	forum_idx = P_forum_idx;
	trans_idx = P_trans_idx;
	pref = P_pref;

	call forum_open_mgr_$lookup_forum_idx (forum_idx, open_data_ptr, xacl, status);
	if status ^= 0 then call error (status);

	attendee_seg_ptr = open_data.attendee_seg_ptr;
	transaction_seg_ptr = open_data.transaction_seg_ptr;
	if xacl ^= RWC_XACL then call error (forum_et_$chairman_only);

	call forum_space_mgr_$find_transaction (transaction_seg_ptr, trans_idx, transaction_ptr, status);
	if status ^= 0 then call error (status);

	call change_subject (P_subject);

	if pref ^= 0 then do;
	     call forum_space_mgr_$find_transaction (transaction_seg_ptr, pref, trans_ptr, status);
	     if status ^= 0 then call error (status);

	     if pref > trans_idx then do;
		done = "0"b;
		do while (^done);
		  if trans_ptr -> transaction.pref_offset = ""b then done = "1"b;
		  else if trans_ptr -> transaction.trans_idx <= trans_idx then done = "1"b;
		  else trans_ptr = ptr (trans_ptr, trans_ptr -> transaction.pref_offset);
		end;

		if trans_ptr -> transaction.trans_idx > trans_idx then do;	/* first in chain */
		     call remove_from_chain ();
		  transaction.pref_offset = ""b;
		  transaction.nref_offset = rel (trans_ptr);
		  trans_ptr -> transaction.pref_offset = rel (transaction_ptr);
		  goto CHAIN_PUNT;		/* done */
		end;
	     end;

	     done = "0"b;
	     do while (^done);
		if trans_ptr -> transaction.nref_offset = ""b then done = "1"b;
		else if ptr (trans_ptr, trans_ptr -> transaction.nref_offset) -> transaction.trans_idx >= trans_idx then done = "1"b;
		else trans_ptr = ptr (trans_ptr, trans_ptr -> transaction.nref_offset);
	     end;

	     if trans_ptr = transaction_ptr then goto CHAIN_PUNT;    /* already chained */
	end;

	call remove_from_chain ();

	if pref ^= 0 then do;			/* If this had a reply, unthread it */
	     transaction.nref_offset = trans_ptr -> transaction.nref_offset; 	/* and thread in new one */
	     if transaction.nref_offset ^= ""b then
		ptr (transaction_ptr, transaction.nref_offset) -> transaction.pref_offset = rel (transaction_ptr);
	     transaction.pref_offset = rel (trans_ptr);
	     trans_ptr -> transaction.nref_offset = rel (transaction_ptr);
	end;
	else do;
	     transaction.pref_offset = ""b;		/* Not in reply to anything anymore */
	     transaction.nref_offset = ""b;
	end;

	status = 0;

CHAIN_PUNT:
	call forum_seg_mgr_$unlock (attendee_seg_ptr);
	P_status = status;
	return;
%page;
remove_from_chain:
     procedure ();

	if transaction.pref_offset ^= ""b then		/* remove from original chain */
	     ptr (transaction_ptr, transaction.pref_offset) -> transaction.nref_offset = transaction.nref_offset;
	if transaction.nref_offset ^= ""b then
	     ptr (transaction_ptr, transaction.nref_offset) -> transaction.pref_offset = transaction.pref_offset;

     end remove_from_chain;

change_subject:
     procedure (new_subject);

declare new_subject char (*) parameter;

	subject_len = length (rtrim (new_subject));
	if subject_len = 0 then return;

/* easy case. it's short enough to just overwrite the old one */

	if subject_len <= transaction.subject_length then do;
	     idx = transaction.segno;
	     if open_data.proceedings_ptrs (idx) = null () then
		call forum_seg_mgr_$initiate_seg (open_data_ptr, idx, status);
	     if status ^= 0 then call error (status);

	     ptr (open_data.proceedings_ptrs (idx), transaction.subject_offset) -> subject = new_subject;
	     transaction.subject_length = subject_len;
	     return;
	end;

	if transaction.segno ^= transaction_seg.current_segno then call error (forum_et_$meeting_bloat);

/* If it won't fit in the new segment, shoudl we copy the transaction ?? */

	next_word = binary (transaction_seg.next_trans_offset, 35);

	if next_word + divide (subject_len + 3, 4, 35) + 2 > sys_info$max_seg_size then call error (forum_et_$meeting_bloat);
	/* lose, lose */

	next_trans_ptr = ptr (open_data.proceedings_ptrs (transaction_seg.current_segno), next_word);

	on record_quota_overflow call error (forum_et_$rqo);

	next_trans_ptr -> subject = new_subject;
	revert record_quota_overflow;

	transaction.subject_offset = rel (next_trans_ptr);
	transaction.subject_length = subject_len;
	next_word = next_word + divide (subject_len + 3, 4, 35);
	transaction_seg.next_trans_offset = bit (binary (next_word, 18), 18);
	
	return;
     end change_subject;
%page;
forum_trans_mgr_$read_trans:
     entry (P_forum_idx, P_trans_idx, P_area_ptr, P_trans_ptr, P_status);

	call initialize (READ_PUNT);

	on cleanup call forum_seg_mgr_$unlock (attendee_seg_ptr);
	on seg_fault_error call error (error_table_$seg_busted);
	on any_other call any_other_handler ();

	forum_idx = P_forum_idx;
	trans_idx = P_trans_idx;

	call forum_open_mgr_$lookup_forum_idx (forum_idx, open_data_ptr, xacl, status);
	if status ^= 0
	then call error (status);

	transaction_seg_ptr = open_data.transaction_seg_ptr;
	attendee_seg_ptr = open_data.attendee_seg_ptr;

	call forum_space_mgr_$find_transaction (transaction_seg_ptr, trans_idx, transaction_ptr, status);
	if status ^= 0
	then call error (status);

	if transaction.deleted
	then if xacl ^= RWC_XACL & person_id ^= transaction.person_id
	     then call error (forum_et_$trans_deleted);

	idx = transaction.segno;
	if open_data.proceedings_ptrs (idx) = null () then do;
	     call forum_seg_mgr_$initiate_seg (open_data_ptr, idx, status);
	     if status ^= 0 then call error (status);
	end;

	subject_len, alloc_subject_length = transaction.subject_length;
	alloc_text_length = transaction.text_length;

	on area call error (error_table_$noalloc);
	on record_quota_overflow call error (error_table_$rqover);
	allocate forum_user_trans in (output_area) set (forum_user_trans_ptr);
	revert area;
	revert record_quota_overflow;

	forum_user_trans.type = user_trans_type;
	forum_user_trans.person_id = transaction.person_id;
	forum_user_trans.project_id = transaction.project_id;
	forum_user_trans.trans_no = trans_idx;
	forum_user_trans.time = transaction.time;
	forum_user_trans.prev_trans_ptr, forum_user_trans.next_trans_ptr = null ();
						/* these are used by user ring status */
	forum_user_trans.unfilled = transaction.unfilled;

	trans_ptr = ptr (open_data.proceedings_ptrs (idx), transaction.subject_offset);
	forum_user_trans.subject = trans_ptr -> subject;

	trans_ptr = ptr (trans_ptr, transaction.text_offset);
	forum_user_trans.text = proceeding_string;

	if transaction.deleted
	then P_status = forum_et_$trans_deleted;
	else P_status = 0;

	P_trans_ptr = forum_user_trans_ptr;
	call forum_seg_mgr_$unlock (attendee_seg_ptr);

	return;

READ_PUNT:
	call forum_seg_mgr_$unlock (attendee_seg_ptr);
	P_trans_ptr = null ();
	P_status = status;
	return;
%page;
forum_trans_mgr_$set_message:
     entry (P_forum_idx, P_input_string, P_status);

	call initialize (SET_MESSAGE_EXIT);

	on cleanup call forum_seg_mgr_$unlock (attendee_seg_ptr);
	on any_other call any_other_handler ();

	forum_idx = P_forum_idx;
	if length (rtrim (P_input_string)) > 256
	then call error (forum_et_$message_too_long);

	call forum_open_mgr_$lookup_forum_idx (forum_idx, open_data_ptr, xacl, status);
	if status ^= 0
	then call error (status);

	attendee_seg_ptr = open_data.attendee_seg_ptr;

	if xacl ^= RWC_XACL
	then call error (forum_et_$chairman_only);

	attendee_seg.chairman_message = P_input_string;

	attendee_ptr = ptr (attendee_seg_ptr, attendee_seg.first_attendee_offset);
	do while (attendee_ptr ^= null ());
	     attendee.message_change_pending = "1"b;
	     if attendee.next_offset = ""b
	     then attendee_ptr = null ();
	     else attendee_ptr = ptr (attendee_seg_ptr, attendee.next_offset);
	end;

	status = 0;

SET_MESSAGE_EXIT:
	call forum_seg_mgr_$unlock (attendee_seg_ptr);
	P_status = status;
	return;
%page;
forum_trans_mgr_$get_message:
     entry (P_forum_idx, P_input_string, P_status);

	call initialize (GET_MESSAGE_EXIT);

	on cleanup call forum_seg_mgr_$unlock (attendee_seg_ptr);
	on any_other call any_other_handler ();

	forum_idx = P_forum_idx;
	call forum_open_mgr_$lookup_forum_idx (forum_idx, open_data_ptr, xacl, status);
	if status ^= 0
	then call error (status);

	attendee_seg_ptr = open_data.attendee_seg_ptr;

	if attendee_seg.chairman_message = ""
	then call error (forum_et_$no_message);
	P_input_string = attendee_seg.chairman_message;

GET_MESSAGE_EXIT:
	call forum_seg_mgr_$unlock (attendee_seg_ptr);
	P_status = status;
	if status ^= 0
	then P_input_string = "";
	return;
%page;
forum_trans_mgr_$trans_time_info:
     entry (P_forum_idx, P_low_time, P_high_time, P_low_trans, P_high_trans, P_status);

	call initialize (TRANS_TIME_PUNT);

	on any_other call any_other_handler ();
	on cleanup call forum_seg_mgr_$unlock (attendee_seg_ptr);

	forum_idx = P_forum_idx;
	call forum_open_mgr_$lookup_forum_idx (forum_idx, open_data_ptr, xacl, status);
	if status ^= 0
	then call error (status);

	attendee_seg_ptr = open_data.attendee_seg_ptr;
	transaction_seg_ptr = open_data.transaction_seg_ptr;

	low_time = P_low_time;
	high_time = P_high_time;
	low_trans = 1;
	high_trans = transaction_seg.transaction_count;

	transaction_block_ptr = ptr (transaction_seg_ptr, transaction_seg.first_block_offset);
	transaction_ptr = ptr (transaction_seg_ptr, transaction_seg.last_trans_offset);

	if transaction_seg.last_trans_offset = ""b then do;   /* see TR 19266 */
	     high_trans = 0;
	     low_trans = 0;
	end;
	else if high_time ^= 0 & high_time < transaction_block.time then high_trans = 0;
	else if low_time > transaction.time then low_trans = high_trans;
	else do;
	     if low_time > transaction_block.time
	     then low_trans = find (low_time, "1"b);
	     if high_time ^= 0 & high_time < transaction.time
	     then high_trans = find (high_time, "0"b);
	end;

	P_high_trans = high_trans;
	P_low_trans = low_trans;
	call forum_seg_mgr_$unlock (attendee_seg_ptr);
	P_status = 0;
	return;

TRANS_TIME_PUNT:
	call forum_seg_mgr_$unlock (attendee_seg_ptr);
	P_high_trans = 0;
	P_low_trans = 0;
	P_status = status;
	return;
%page;
find:
     proc (t, low_end) returns (fixed bin);

declare  t fixed bin (71),
	low_end bit (1) aligned,
         trans_ptr ptr,
         1 trans like transaction based (trans_ptr),
         (idx, low, high, h, l) fixed bin;

	done = "0"b;
	transaction_block_ptr = ptr (transaction_seg_ptr, transaction_seg.current_block_offset);
	do while (^done);
	     if t < transaction_block.time
	     then transaction_block_ptr = ptr (transaction_seg_ptr, transaction_block.prev_block_offset);
	     else done = "1"b;
	end;

	low = 1;
	high = transaction_block.last_trans_idx;
	do idx = divide (high + low, 2, 17, 0) repeat idx;
	     if transaction_block.offset (idx) = EXPUNGED then do;
		do h = idx to high while (transaction_block.offset (h) = EXPUNGED);
		end;
		do l = idx to low by -1 while (transaction_block.offset (l) = EXPUNGED);
		end;

		if h > high then do;		/* all expunged */
		     if l = 0 then
			if low_end then return (ptr (transaction_seg_ptr, transaction_seg.first_trans_offset) -> transaction.trans_idx);
			else return (0);
		     else high = l;
		end;
		else if t < ptr (transaction_seg_ptr, transaction_block.offset (h)) -> trans.time then high = l;
		else low = h;

		if idx > high then idx = high;
		else if idx < low then idx = low;
	     end;
	     else do;
		trans_ptr = ptr (transaction_seg_ptr, transaction_block.offset (idx));
		if trans.time < t then do;
		     if ptr (transaction_seg_ptr, trans.next_offset) -> trans.time > t
		     then return (idx + transaction_block.first_trans_idx - 1);
		     else do;
			low = idx + 1;
			idx = divide (high + low, 2, 17, 0);
		     end;
		end;
		else if ptr (transaction_seg_ptr, trans.prev_offset) -> trans.time <= t
		then return (idx + transaction_block.first_trans_idx - 2);
		else do;
		     high = idx - 1;
		     idx = divide (high + low, 2, 17, 0);
		end;
	     end;
	end;
     end find;
%page;
forum_trans_mgr_$trans_ref_info:
     entry (P_forum_idx, P_trans_idx, P_type, P_pref, P_nref, P_deleted_sw, P_status);

	call initialize (TRANS_REF_PUNT);

	on any_other call any_other_handler ();
	on cleanup call forum_seg_mgr_$unlock (attendee_seg_ptr);

	forum_idx = P_forum_idx;
	call forum_open_mgr_$lookup_forum_idx (forum_idx, open_data_ptr, xacl, status);
	if status ^= 0
	then call error (status);

	attendee_seg_ptr = open_data.attendee_seg_ptr;
	transaction_seg_ptr = open_data.transaction_seg_ptr;

	trans_idx = P_trans_idx;
	type = P_type;

	call forum_space_mgr_$find_transaction (transaction_seg_ptr, trans_idx, transaction_ptr, status);
	if status ^= 0
	then call error (status);

	chairman = (person_id = attendee_seg.chairman.person_id);
	P_deleted_sw = transaction.deleted;

	pref, nref = 0;
	done = "0"b;
	trans_ptr = transaction_ptr;
	do while (^done);
	     if trans_ptr -> transaction.pref_offset = ""b then done = "1"b;
	     else do;
		trans_ptr = ptr (transaction_seg_ptr, trans_ptr -> transaction.pref_offset);
		done = check ();
		if done then pref = trans_ptr -> transaction.trans_idx;
	     end;
	end;

	done = "0"b;
	trans_ptr = transaction_ptr;
	do while (^done);
	     if trans_ptr -> transaction.nref_offset = ""b then done = "1"b;
	     else do;
		trans_ptr = ptr (transaction_seg_ptr, trans_ptr -> transaction.nref_offset);
		done = check ();
		if done then nref = trans_ptr -> transaction.trans_idx;
	     end;
	end;

	P_pref = pref;
	P_nref = nref;

TRANS_REF_PUNT:
	call forum_seg_mgr_$unlock (attendee_seg_ptr);
	if status ^= 0 then do;
	     P_pref, P_nref = 0;
	     P_deleted_sw = "0"b;
	end;
	P_status = status;
	return;
%page;
forum_trans_mgr_$set_delete_sw:
     entry (P_forum_idx, P_trans_idx, P_value_sw, P_status);

	call initialize (SET_DELETE_EXIT);

	on any_other call any_other_handler ();
	on cleanup call forum_seg_mgr_$unlock (attendee_seg_ptr);

	forum_idx = P_forum_idx;
	trans_idx = P_trans_idx;
	value_sw = P_value_sw;

	call forum_open_mgr_$lookup_forum_idx (forum_idx, open_data_ptr, xacl, status);
	if status ^= 0
	then call error (status);

	attendee_seg_ptr = open_data.attendee_seg_ptr;
	transaction_seg_ptr = open_data.transaction_seg_ptr;

	call forum_space_mgr_$find_transaction (transaction_seg_ptr, trans_idx, transaction_ptr, status);
	if status ^= 0
	then call error (status);

	if person_id = transaction.person_id
	then privileged = "0"b;
	else if xacl = RWC_XACL
	then privileged = "1"b;
	else call error (forum_et_$chairman_only);

	if ^value_sw & ^privileged & ^transaction.deleted_by_author
	then call error (forum_et_$chairman_only);

	transaction.deleted_by_author = value_sw & ^privileged & (^transaction.deleted | value_sw);

	if transaction.deleted & value_sw
	then goto SET_DELETE_EXIT;
	if ^transaction.deleted & ^value_sw
	then goto SET_DELETE_EXIT;

	transaction.deleted = value_sw;

	if value_sw
	then transaction_seg.deleted_count = transaction_seg.deleted_count + 1;
	else transaction_seg.deleted_count = transaction_seg.deleted_count - 1;

SET_DELETE_EXIT:
	call forum_seg_mgr_$unlock (attendee_seg_ptr);
	P_status = status;
	return;
%page;
forum_trans_mgr_$set_seen_switch:
     entry (P_forum_idx, P_user_name, P_trans_idx, P_value_sw, P_status);

	call initialize (SET_SEEN_EXIT);

	on cleanup call forum_seg_mgr_$unlock (attendee_seg_ptr);

	forum_idx = P_forum_idx;
	user_name = P_user_name;
	trans_idx = P_trans_idx;
	value_sw = P_value_sw;

	call forum_open_mgr_$lookup_forum_idx (forum_idx, open_data_ptr, xacl, status);
	if status ^= 0
	then call error (status);

	attendee_seg_ptr = open_data.attendee_seg_ptr;
	transaction_seg_ptr = open_data.transaction_seg_ptr;

	if user_name = "" | user_name = person_id
	then attendee_ptr = open_data.attendee_ptr;
	else do;
	     if xacl ^= RWC_XACL
	     then call error (forum_et_$chairman_only);
	     call forum_space_mgr_$find_attendee (attendee_seg_ptr, user_name, attendee_ptr, status);
	     if status ^= 0
	     then call error (status);
	end;

	call forum_space_mgr_$find_transaction (transaction_seg_ptr, trans_idx, transaction_ptr, status);
	if status ^= 0
	then call error (status);

	call set_seen_switch (trans_idx, value_sw);

SET_SEEN_EXIT:
	call forum_seg_mgr_$unlock (attendee_seg_ptr);
	P_status = status;
	return;

set_seen_switch:
     proc (trans_idx, value);

declare  trans_idx fixed bin,
         value bit (1) aligned;

	idx = trans_idx - attendee.bit_map_first_trans + 1;
	bit_map_ptr = ptr (attendee_seg_ptr, attendee.bit_map_offset);

	if idx < 1 then do;
	     if value then return;
	     call forum_space_mgr_$allocate_bit_map (open_data_ptr, attendee_ptr, trans_idx, bit_map_ptr, status);
	     if status ^= 0 then call error (status);
	end;

	else if idx > bit_map.length then do;
	     if ^value then return;
	     idx = index (bit_map.map, "0"b);
	     if idx = 0 then idx = bit_map.length;
	     idx = idx + attendee.bit_map_first_trans - 1;
	     call forum_space_mgr_$allocate_bit_map (open_data_ptr, attendee_ptr, idx, bit_map_ptr, status);
	     if status ^= 0 then call error (status);
	end;

	idx = trans_idx - attendee.bit_map_first_trans + 1;
	open_data.bit_map_ptr = bit_map_ptr;
	substr (bit_map.map, idx, 1) = value;

	return;
     end set_seen_switch;
%page;
forum_trans_mgr_$get_transaction_map:
     entry (P_directory, P_name, P_user_name, P_bit_map, P_status);

	call initialize (GET_MAP_EXIT);

	on cleanup call forum_seg_mgr_$terminate (attendee_seg_ptr, transaction_seg_ptr);

	directory = P_directory;
	name = P_name;
	call forum_seg_mgr_$initiate (directory, name, "1"b, attendee_seg_ptr, transaction_seg_ptr, xacl, status);
	if status ^= 0
	then call error (status);
	if xacl = ""b
	then call error (forum_et_$not_eligible);

	call get_seen_map ();

	call forum_seg_mgr_$terminate (attendee_seg_ptr, transaction_seg_ptr);
	P_status = 0;
	return;

GET_MAP_EXIT:
	call forum_seg_mgr_$terminate (attendee_seg_ptr, transaction_seg_ptr);
	P_bit_map = ""b;
	P_status = status;
	return;

forum_trans_mgr_$get_transaction_map_idx:
     entry (P_forum_idx, P_user_name, P_bit_map, P_status);

	call initialize (GET_MAP_IDX_EXIT);

	on cleanup call forum_seg_mgr_$unlock (attendee_seg_ptr);

	forum_idx = P_forum_idx;

	call forum_open_mgr_$lookup_forum_idx (forum_idx, open_data_ptr, xacl, status);
	if status ^= 0
	then call error (status);

	attendee_seg_ptr = open_data.attendee_seg_ptr;
	transaction_seg_ptr = open_data.transaction_seg_ptr;

	call get_seen_map ();

	call forum_seg_mgr_$unlock (attendee_seg_ptr);
	P_status = 0;
	return;

GET_MAP_IDX_EXIT:
	call forum_seg_mgr_$unlock (attendee_seg_ptr);
	P_status = status;
	P_bit_map = ""b;
	return;
%page;
get_seen_map:
     proc ();

declare  seen_map bit (transaction_seg.transaction_count);

	user_name = P_user_name;
	if open_data_ptr ^= null () & (user_name = "" | user_name = person_id)
	then attendee_ptr = open_data.attendee_ptr;
	else do;
	     call forum_space_mgr_$find_attendee (attendee_seg_ptr, user_name, attendee_ptr, status);
	     if status ^= 0
	     then call error (status);
	end;

	if attendee.bit_map_offset = ""b
	then seen_map = ""b;
	else do;
	     bit_map_ptr = ptr (attendee_seg_ptr, attendee.bit_map_offset);
	     idx = attendee.bit_map_first_trans - 1;
	     if idx = 0
	     then seen_map = bit_map.map;
	     else do;
		substr (seen_map, 1, idx) = copy ("1"b, idx);
		substr (seen_map, idx + 1) = bit_map.map;
	     end;
	end;

	P_bit_map = seen_map;
     end get_seen_map;
%page;
forum_trans_mgr_$forum_limits:
     entry (P_forum_idx, P_type, P_last_seen_trans_idx, P_first_trans_idx, P_last_trans_idx, P_new_trans_count,
	P_flags_word, P_status);

	call initialize (FORUM_LIMITS_PUNT);

	on cleanup call forum_seg_mgr_$unlock (attendee_seg_ptr);

	forum_idx = P_forum_idx;
	type = P_type;

	call forum_open_mgr_$lookup_forum_idx (forum_idx, open_data_ptr, xacl, status);
	if status ^= 0 then call error (status);

	attendee_seg_ptr = open_data.attendee_seg_ptr;
	transaction_seg_ptr = open_data.transaction_seg_ptr;
	attendee_ptr = open_data.attendee_ptr;

	chairman = (xacl = RWC_XACL);
	forum_flags_word = ""b;
	forum_flags.chairman = chairman;
	forum_flags.adjourned = attendee_seg.adjourned;
	forum_flags.read_only = (xacl = R_XACL);
	forum_flags.print_cm_message = attendee.message_change_pending;
	forum_flags.acl_has_changed = attendee.acl_change_pending;

/* The following statement is dedicated to IS-14 and HBD */

	forum_flags.print_acl_message =
	     attendee_seg.cm_print_acl_msg | (attendee_seg.am_init & attendee_seg.am_print_acl_msg)
	     | (forum_data_$print_eligibility_messages & ^(attendee_seg.am_init & ^attendee_seg.am_print_acl_msg)
	     & ^(forum_data_$chairman_override & attendee_seg.cm_init & ^attendee_seg.cm_print_acl_msg));

	P_flags_word = forum_flags_word;

	if transaction_seg.first_trans_offset = ""b then do;
	     P_first_trans_idx, P_last_trans_idx, P_last_seen_trans_idx, P_new_trans_count = 0;
	     goto FORUM_LIMITS_PUNT;
	end;

	done = "0"b;
	trans_ptr = ptr (transaction_seg_ptr, transaction_seg.first_trans_offset);
	do idx = 1 to transaction_seg.transaction_count while (^done);
	     done = check ();
	     if trans_ptr -> transaction.next_offset = ""b then done = "1"b;
	     else if ^done then
		trans_ptr = ptr (transaction_seg_ptr, trans_ptr -> transaction.next_offset);
	end;
	if ^done then call looping ();

/* Check to make sure we actually found a transaction that meets the select type */
	if trans_ptr -> transaction.next_offset = ""b then do;
	     done = check ();
	     if ^done then do;
		P_first_trans_idx, P_last_trans_idx, P_last_seen_trans_idx, P_new_trans_count = 0;
		goto FORUM_LIMITS_PUNT;
	     end;
	end;
		
	P_first_trans_idx = trans_ptr -> transaction.trans_idx;

	done = "0"b;
	trans_ptr = ptr (transaction_seg_ptr, transaction_seg.last_trans_offset);
	do idx = 1 to transaction_seg.transaction_count while (^done);
	     done = check ();
	     if trans_ptr -> transaction.prev_offset = ""b then done = "1"b;
	     else if ^done then trans_ptr = ptr (transaction_seg_ptr, trans_ptr -> transaction.prev_offset);
	end;
	if ^done then call looping ();
	P_last_trans_idx = trans_ptr -> transaction.trans_idx;

	call forum_space_mgr_$get_highest_seen (attendee_ptr, transaction_seg_ptr, "1"b, high_trans,
	     transaction_ptr, status);
	if status ^= 0 then call error (status);

	P_last_seen_trans_idx = high_trans;

	new_trans_count = 0;
	done = (transaction_ptr = null ());
	do idx = 1 to transaction_seg.transaction_count while (^done);
	     if transaction.person_id ^= person_id & ^transaction.deleted
	     then new_trans_count = new_trans_count + 1;
	     if transaction.next_offset = ""b then done = "1"b;
	     else transaction_ptr = ptr (transaction_seg_ptr, transaction.next_offset);
	end;
	if ^done then call looping ();

	P_new_trans_count = new_trans_count;

FORUM_LIMITS_PUNT:
	call forum_seg_mgr_$unlock (attendee_seg_ptr);
	P_status = status;
	return;
%page;
check:
     proc () returns (bit (1) aligned);

	if type = ONLY_UNDELETED & trans_ptr -> transaction.deleted	then
	     return ("0"b);
	else if type = ONLY_DELETED & ^trans_ptr -> transaction.deleted
	then return ("0"b);
	else if trans_ptr -> transaction.deleted & ^chairman & trans_ptr -> transaction.person_id ^= person_id
	then return ("0"b);
	else return ("1"b);

     end check;


looping:
     proc;

	call forum_logger_ (0, "forum_trans_mgr_", "Loop detected in ^a, trans_ptr = ^p.", open_data.forum_name,
	     trans_ptr);
	call error (forum_et_$unexpected_fault);

     end looping;
%page;
forum_trans_mgr_$check_user:
     entry (P_forum_idx, P_user_name, P_trans_idx, P_status);

	call initialize (CHECK_USER_EXIT);

	on any_other call any_other_handler ();
	on cleanup call forum_seg_mgr_$unlock (attendee_seg_ptr);

	forum_idx = P_forum_idx;
	call forum_open_mgr_$lookup_forum_idx (forum_idx, open_data_ptr, xacl, status);
	if status ^= 0
	then call error (status);

	attendee_seg_ptr = open_data.attendee_seg_ptr;
	transaction_seg_ptr = open_data.transaction_seg_ptr;

	user_name = P_user_name;
	P_trans_idx = 0;

	done = "0"b;
	transaction_ptr = ptr (transaction_seg_ptr, transaction_seg.last_trans_offset);
	do while (^done);
	     if transaction.person_id = user_name
	     then done = "1"b;
	     else if transaction.prev_offset = ""b
	     then done = "1"b;
	     else transaction_ptr = ptr (transaction_seg_ptr, transaction.prev_offset);
	end;
	if transaction.person_id = user_name
	then P_trans_idx = transaction.trans_idx;

CHECK_USER_EXIT:
	call forum_seg_mgr_$unlock (attendee_seg_ptr);
	P_status = status;
	return;
%page;
forum_trans_mgr_$convert_attendee_idx:
     entry (P_forum_idx, P_attendee_offset, P_user_name, P_status);

	call initialize (CONV_ATT_EXIT);
	P_user_name = "";

	on cleanup call forum_seg_mgr_$unlock (attendee_seg_ptr);
	on any_other call any_other_handler ();

	forum_idx = P_forum_idx;
	call forum_open_mgr_$lookup_forum_idx (forum_idx, open_data_ptr, xacl, status);
	if status ^= 0
	then call error (status);

	attendee_seg_ptr = open_data.attendee_seg_ptr;
	attendee_ptr = ptr (attendee_seg_ptr, P_attendee_offset);

	if attendee.version ^= ATTENDEE_VERSION_1
	then call error (forum_et_$invalid_att_idx);

	P_user_name = rtrim (attendee.person_id) || "." || attendee.project_id;

CONV_ATT_EXIT:
	call forum_seg_mgr_$unlock (attendee_seg_ptr);
	P_status = status;
	return;
%page;
forum_trans_mgr_$validate_uid:
     entry (P_forum_idx, P_uid, P_status);

	call initialize (VALIDATE_UID_EXIT);

	on cleanup call forum_seg_mgr_$unlock (attendee_seg_ptr);
	on any_other call any_other_handler ();

	forum_idx = P_forum_idx;
	call forum_open_mgr_$lookup_forum_idx (forum_idx, open_data_ptr, xacl, status);
	if status ^= 0
	then call error (status);

	attendee_seg_ptr = open_data.attendee_seg_ptr;
	if open_data.forum_uid ^= P_uid
	then call error (forum_et_$incorrect_uid);

VALIDATE_UID_EXIT:
	call forum_seg_mgr_$unlock (attendee_seg_ptr);
	P_status = status;
	return;
%page;
forum_trans_mgr_$next_transaction:
     entry (P_forum_idx, P_trans_idx, P_next, P_status);

	call initialize (NEXT_PUNT);

	on any_other call any_other_handler;
	on cleanup call forum_seg_mgr_$unlock (attendee_seg_ptr);

	forum_idx = P_forum_idx;
	trans_idx = P_trans_idx;
	call forum_open_mgr_$lookup_forum_idx (forum_idx, open_data_ptr, xacl, status);
	if status ^= 0 then call error (status);

	attendee_seg_ptr = open_data.attendee_seg_ptr;

	call forum_space_mgr_$find_next_transaction (open_data.transaction_seg_ptr, trans_idx, high_trans, status);
	if status ^= 0 then call error (status);

	P_next = high_trans;
	status = 0;

NEXT_PUNT:
	if status ^= 0 then P_next = 0;
	call forum_seg_mgr_$unlock (attendee_seg_ptr);
	P_status = status;
	return;
%page;
forum_trans_mgr_$previous_transaction:
     entry (P_forum_idx, P_trans_idx, P_previous, P_status);

	call initialize (PREV_PUNT);

	on any_other call any_other_handler;
	on cleanup call forum_seg_mgr_$unlock (attendee_seg_ptr);

	forum_idx = P_forum_idx;
	trans_idx = P_trans_idx;
	call forum_open_mgr_$lookup_forum_idx (forum_idx, open_data_ptr, xacl, status);
	if status ^= 0 then call error (status);

	attendee_seg_ptr = open_data.attendee_seg_ptr;
	call forum_space_mgr_$find_prev_transaction (open_data.transaction_seg_ptr, trans_idx, low_trans, status);
	if status ^= 0 then call error (status);

	P_previous = low_trans;
	status = 0;

PREV_PUNT:
	if status ^= 0 then P_previous = 0;
	call forum_seg_mgr_$unlock (attendee_seg_ptr);
	P_status = status;
	return;
%page;
initialize:
     procedure (P_egress);

declare  P_egress label variable,
         anon fixed bin;

	egress = P_egress;

	if ^static_init then do;
	     call user_info_$login_data (person_id, project_id, (""), anon, 0, 0, 0, (""));
	     if anon = 1
	     then person_id = "*" || person_id;
	     static_init = "1"b;
	end;

	attendee_seg_ptr, transaction_seg_ptr, open_data_ptr = null ();
	status = 0;

	return;
     end initialize;

any_other_handler:
     proc ();

	on any_other system;
	if open_data_ptr ^= null ()
	then directory = open_data.forum_name;
	else directory = "";

	call forum_logger_$any_other (0, "forum_trans_mgr_", directory);
	status = forum_et_$unexpected_fault;
	goto egress;

     end any_other_handler;

error:
     procedure (P_status);

declare  P_status fixed bin (35);

	status = P_status;
	goto egress;

     end error;

     end forum_trans_mgr_$enter_trans;
