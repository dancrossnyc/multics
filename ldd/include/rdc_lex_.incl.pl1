/* START OF:	rdc_lex_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* N__a_m_e:  rdc_lex_.incl.pl1							*/
	/*									*/
	/*      This include segment is used by compilers generated by the reduction_compiler.	*/
	/* It contains the LEX subroutine which is used to manipulate the pointer to the	*/
	/* "current" token, Pthis_token.						*/
	/*									*/
	/* E__n_t_r_y:  LEX								*/
	/*									*/
	/*      This entry makes the |_nth|-next (or -preceding) token the "current" token, where	*/
	/* _n is its positive (or negative) input argument.				*/
	/*									*/
	/* U__s_a_g_e									*/
	/*									*/
	/*      call LEX(n);							*/
	/*									*/
	/* 1) n   is the number of the token to be made the "current" token, relative to the	*/
	/*        token identified by Pthis_token (the present "current" token).  If n is	*/
	/*        positive, the nth token following the "current" token made "current".  If n	*/
	/*        is negative, the nth token preceding the "current" token is made "current".	*/
	/*									*/
	/* S__t_a_t_u_s									*/
	/*									*/
	/* 0) Created by:  G. C. Dixon  in  February, 1975				*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

LEX:	procedure (n);

     dcl	n			fixed bin,
	i			fixed bin;

	Ptoken = Pthis_token;			/* do everything relative to "current" token.	*/
	if Ptoken = null then return;			/* can't lex if token list exhausted.		*/
	if n >= 0 then do;				/* new "current" token will follow present one.	*/
	     do i = 1 to n while (token.Pnext ^= null);	/* find new "current" token, taking care not to	*/
		Ptoken = token.Pnext;		/*   run off end of token list.		*/
		end;
	     if ^SPDL then if i <= n then Ptoken = null;	/* if not in 'PUSH DOWN LANGUAGE' mode, allow	*/
						/*   running off end of token list.		*/
	     end;
	else					/* new "current" token precedes present one.	*/
	     do i = -1 to n by -1 while (token.Plast ^= null);
		Ptoken = token.Plast;
		end;
	Pthis_token = Ptoken;			/* simple wasn't it.			*/

	end LEX;

/* END OF:	rdc_lex_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
