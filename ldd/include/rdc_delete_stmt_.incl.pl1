/* START OF:	rdc_delete_stmt_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* N__a_m_e:  rdc_delete_stmt_.incl.pl1						*/
	/*									*/
	/*      This include segment is used by compilers generated by the reduction_compiler.	*/
	/* It includes a procedure which deletes all of the tokens associated with the current	*/
	/* statement (i.e., the statement which contains the token identified by Pthis_token).	*/
	/*									*/
	/* S__t_a_t_u_s									*/
	/*									*/
	/* 0) created by:  G. C. Dixon  in  February, 1975.				*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


DELETE_STMT: procedure;

     dcl (Plast, Pnext)		ptr,		/* ptr to (first, last) token to be deleted.	*/
	Ssearching		bit(1) aligned;	/* on if scan for first/last token continuing.	*/

	if Pthis_token = null then return;		/* if input list exhausted, we can't do anything.	*/
	Pstmt = Pthis_token -> token.Pstmt;		/* address the statement descriptor of "current"	*/
	if Pstmt = null then return;			/*   token, if it exists.			*/
	Plast = Pthis_token;			/* start scanning with "current" token.		*/
	Ssearching = "1"b;				/* set switch indicating search still continuing.	*/
	do while (Ssearching & Plast -> token.Plast ^= null);
	     if Plast -> token.Plast -> token.Pstmt = Pstmt then
		Plast = Plast -> token.Plast;		/* scan backward for 1st _n_o_n-__d_e_l_e_t_e_d token of stmt*/
	     else Ssearching = "0"b;			/* when found, stop searching.		*/
	     end;					/* Recall that 1st token of stmt (ie, token	*/
						/*   pointed to by stmt.Pfirst_token) may have	*/
						/*   been deleted.				*/
	Pnext = Pthis_token;			/* start scanning forward with "current" token.	*/
	Ssearching = "1"b;
	do while (Ssearching & Pnext -> token.Pnext ^= null);
	     if Pnext -> token.Pnext -> token.Pstmt = Pstmt then
		Pnext = Pnext -> token.Pnext;		/* scan forward for last _n_o_n-__d_e_l_e_t_e_d token of stmt*/
	     else Ssearching = "0"b;			/* when found, stop searching.		*/
	     end;
	if Pnext -> token.Pnext = null then		/* if there is no next statement, and		*/
	     if SPDL then				/*   if in PUSH DOWN LANGUAGE mode, and		*/
		if Plast -> token.Plast = null then	/*   if there are no more tokens before the	*/
		     Ptoken, Pthis_token = null;	/*   "current" statement, then input exhausted.	*/
		else do;
		     Ptoken, Pthis_token = Plast -> token.Plast;
						/*   otherwise, make token preceding the "current"*/
						/*   statement the "current" token.		*/
		     token.Pnext = null;		/*   indicate that input list exhausted.  Only the*/
						/*   tokens before the new "current" token exist.	*/
		     end;
	     else Ptoken, Pthis_token = null;		/* not in PUSH DOWN LANGUAGE - input exhausted.	*/
	else do;
	     Ptoken, Pthis_token = Pnext -> token.Pnext;	/* normally, token following "current" statement	*/
						/*   becomes the "current" token.		*/
	     token.Plast = Plast -> token.Plast;	/* unthread the deleted tokens.		*/
	     if Plast -> token.Plast ^= null then
		Plast -> token.Plast -> token.Pnext = Ptoken;
	     end;

	if Pnext -> token.Pnext = null then		/* unthread statement descriptor from list.	*/
	     Pnext = null;
	else Pnext = Pnext -> token.Pnext -> token.Pstmt;
	if Plast -> token.Plast = null then
	     Plast = null;
	else Plast = Plast -> token.Plast -> token.Pstmt;
	if Pnext ^= null then
	     Pnext -> stmt.Plast = Plast;
	if Plast ^= null then
	     Plast -> stmt.Pnext = Pnext;

	end DELETE_STMT;

/* END OF:	rdc_delete_stmt_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
