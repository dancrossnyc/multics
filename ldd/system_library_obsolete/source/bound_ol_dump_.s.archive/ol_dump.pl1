/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */


ol_dump: proc;

/* Modification history - ol_dump:
   Origially coded by Steve Webber - Date unknown
   Extensive Modification to allow more options by J. A. Bush - Dec. 1975
   Modified May 1976 by J. A. Bush for NSS compatibility
   New ast/pt command extensivly cribed from BSG's new pap command
   Extensively modified in Oct. 1976 by J. A. Bush to split up functions into
   several modules to form bound_ol_dump_.
   Modified June 1977 by J. A. Bush for "mc" function and to use new
   entry ring0_get_$definitions_given_slt to find hardcore definitions
   Modified Oct 1979 by J. A. Bush for new -pathname arg and to
   fix to work with ring_0 stack sharing
   Modified July, 1980 to add dumpdir option
   Modified April 1981 by Rich Coppola to add call to J. Bongiovanni's
   display_dump_events, and add erf? command.
   Modified June 1982 by Rich Coppola to always allow dbr to be set for proc 0
   or inzr.
   Modified August 1982 by E. N. Kittlitz to move core_map out of sst.
   Modified Oct 1982 by Rich Coppola to set boot dbr to first proc dumped
   so that support routines could make use of it.
   Modified Oct 1982 by Rich Coppola to set the proc table (dump_info) after
   'why' is called.
*/

% include ol_dump_struc;


/* External entry declarations */

dcl  gm_path_list$ ext;
dcl  error_table_$segknown fixed bin (35) ext static;
dcl  error_table_$incorrect_access fixed bin (35) ext static;
dcl  error_table_$moderr fixed bin (35) ext static;
dcl  error_table_$no_dir fixed bin (35) ext static;
dcl  error_table_$no_r_permission fixed bin (35) ext static;
dcl  error_table_$noentry fixed bin (35) ext static;
dcl  error_table_$noarg fixed bin (35) ext static;
dcl  error_table_$badopt fixed bin (35) ext static;
dcl  error_table_$inconsistent fixed bin (35) ext static;
dcl  absolute_pathname_ entry (char (*), char (*), fixed bin (35));
dcl  hcs_$make_seg entry (char (*) aligned, char (*) aligned, char (*) aligned, fixed bin (5), ptr, fixed bin (35));
dcl  hcs_$initiate entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
dcl  hcs_$fs_get_mode entry (ptr, fixed bin (5), fixed bin (35));
dcl (ioa_, ioa_$nnl, ioa_$rsnnl, hcs_$star_, ioa_$ioa_switch_nnl, hcs_$get_max_length, com_err_) entry options (variable);
dcl  ring0_get_$segptr_given_slt entry (char (*) aligned, char (*) aligned, ptr, fixed bin (35), ptr, ptr);
dcl  ring0_get_$definition_given_slt entry (ptr, char (*), char (*), fixed bin (18),
     fixed bin, fixed bin (35), ptr, ptr, ptr);
dcl  cv_oct_check_ entry (char (*), fixed bin (35)) returns (fixed bin);
dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
dcl  expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));
dcl  get_dump_ptrs_$dump_dir entry (char (*), char (*) aligned, (0: 31) ptr, (0: 31) fixed bin,
     fixed bin, char (32) aligned);
dcl  copy_dump_seg_ entry (fixed bin, fixed bin, (0:31) ptr, (0:31) fixed bin, ptr, fixed bin);
dcl  date_time_ entry (fixed bin (71), char (*) aligned);
dcl  cu_$arg_count entry (fixed bin);
dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
dcl  cu_$cp entry (ptr, fixed bin, fixed bin (35));
dcl  get_system_free_area_ entry (ptr);
dcl  iox_$get_line entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
dcl (iox_$user_input, iox_$error_output) ptr ext;
dcl  find_condition_info_ entry (ptr, ptr, fixed bin (35));
dcl  continue_to_signal_ entry (fixed bin (35));
dcl  display_dump_events$display_dump_events_ entry (char (32), char (168), fixed bin, fixed bin (71), bit (1));
dcl (temp_pds_ptr, temp_prds_ptr, temp_kst_ptr) ptr;


dcl  cond_infop ptr;				/* pointer to condition info */

dcl 1 cond_info aligned,
    2 mc_ptr ptr,
    2 version fixed bin,
    2 condition_name char (32) varying,
    2 info_ptr ptr,
    2 wc_ptr ptr,
    2 loc_ptr ptr,
    2 flags,
      3 crawlout bit (1) unaligned,
      3 mbz1 bit (35) unaligned,
    2 mbz2 bit (36) aligned,
    2 user_loc_ptr ptr,
    2 mbz4 bit (36) aligned;

dcl  condition_interpreter_ entry (ptr, ptr, fixed bin, fixed bin, ptr, char (*), ptr, ptr);
dcl  conversion condition;


/* ol_dump subroutine entry declarations */

dcl  display_dump_ entry (ptr);			/* Subroutine to display console dump */
dcl  display_ast_ entry (ptr);			/* Subroutine to display ast entry */
dcl  display_ast_$absadr entry (ptr);
dcl  display_process_$apt entry (ptr);			/* Subroutine to display APT entry */
dcl  display_process_$tcq entry (ptr, ptr);		/* Subroutine to display the traffic controller queue */
dcl  display_process_$fdi entry (ptr, ptr);
dcl  display_stack_ entry (ptr);			/* Subroutine to display/trace stacks */
dcl  display_segment_$dseg entry (ptr);			/* Subroutine to display descriptor seg */
dcl  display_regs_$hregs entry (ptr);			/* Subroutine to display history regs */
dcl  display_segment_$config entry (ptr);		/* Subroutine to display config deck */
dcl  display_am_$sdw entry (ptr, fixed bin (3));		/* Subroutine to display SDW assoiate memory */
dcl  display_am_$ptw entry (ptr, fixed bin (3));		/* Subroutine to display PTW assoiate memory */
dcl  display_am_$validate_am_btld entry (ptr, fixed bin (35), fixed bin (3), fixed bin (35));
dcl  display_regs_$dump entry (ptr);			/* Subroutine to display regs from dump */
dcl  display_regs_$mcpds entry (ptr);			/* Subroutine to display PDS machine conditions */
dcl  display_regs_$mcprds entry (ptr);			/* Subroutine to display PRDS machine conditions */
dcl  display_regs_$mc entry (ptr);			/* Subroutine to display any machine condition */
dcl  display_syserr_$log entry (ptr);			/* Subroutine to display syserr_log */
dcl  display_syserr_$data entry (ptr);			/* Subroutine to display syserr_data */
dcl  display_segment_$name entry (ptr);			/* Subroutine to display segment name */
dcl  display_segment_$number entry (ptr);		/* Subroutine to display segment number */
dcl  ol_dump_util_$get_ptr entry (fixed bin, ptr, fixed bin (35), ptr); /* :: */
dcl  ol_dump_util_$get_ptr_quiet entry (fixed bin, ptr, fixed bin (35), ptr); /* :: */
dcl  ol_dump_util_$get_ptr_given_dbr entry (fixed bin (24), fixed bin, ptr, fixed bin (35), ptr);
dcl  ol_dump_util_$fnd_dbr entry (fixed bin (24), fixed bin (35), fixed bin, ptr);
dcl  ol_dump_util_$fnd_hcseg entry (char (32) aligned, ptr, fixed bin (24), ptr); /* :: */
dcl  ol_dump_util_$get_segno entry (char (32) varying, ptr) returns (fixed bin); /* :: */
dcl  ol_dump_util_$val_ptr entry (ptr) returns (char (16) aligned); /* :: */
dcl  display_mchist_ entry (ptr);			/* Subroutine to display machine condition history */
dcl  ol_dump_why_ entry (ptr);
dcl  pds_trace_ entry (ptr);

/* Automatic */

dcl (edoc, nsegs, mci, segno, last_segment, type, proc_no, last_segno,
     dump_segno, sstlen, sstntlen, tc, i, j, lin, lp, count, icode) fixed bin;
dcl  offset fixed bin;
dcl  ll fixed bin (21);
dcl  WS char (2) int static options (constant) init (" 	");
dcl (dbr, new_dbr, saved_dbr) fixed bin (24);
dcl (ap, eptr, nptr, p, tp, imcp, cpup, phcsp) ptr;
dcl (code, segln) fixed bin (35);
dcl  def_offset fixed bin (18);
dcl  seg_mode fixed bin (5) int static init (1011b);
dcl  tag (0 : 7) char (1) int static options (constant) init
    ("a", "b", "c", "d", "e", "f", "g", "h");
dcl  sys_ver_id char (8) aligned based (imcp);
dcl  rs_mode fixed bin (5);
dcl  display_dump_dir bit (1) init ("0"b);
dcl  execute bit (5) init ("00100"b);
dcl  stkout char (70);
dcl  cmdarg char (32);
dcl  targ char (32);
dcl  cnum char (1);
dcl  pnum char (4) var;
dcl (tmr, pn_sw, erf_sw, dpn) bit (1) init ("0"b);
dcl  a_name char (tc) based (tp);
dcl (null, length, addr, addrel, baseno, divide, fixed, rel, hbound, substr, index, ltrim, rtrim, size, search) builtin;
dcl (program_interrupt, any_other) condition;
dcl (dump_dir, tdump_dir) char (168) init ("");
dcl  dump_name char (32) aligned;
dcl (ename, tname) char (32);
dcl  name char (32) aligned;
dcl  acl_classp ptr;
dcl  time char (24) aligned;
dcl  inited bit (1) aligned int static init ("0"b);
dcl  have_erf bit (1) init ("0"b);
dcl  based_ptr ptr based;
dcl  com_string char (132) aligned;
dcl  why char (32) varying;
dcl  number_events fixed bin init (0);
dcl  time_interval fixed bin (71) init (0);
dcl (long_flag, short_flag, dde_mode) bit (1) init ("0"b);
dcl  dsegptr ptr;
dcl  path_list_name char (168) aligned init ("");

dcl 1 astruc like ol_dump_struc;			/* make an automatic structure */

dcl 1 entries (1) based (eptr),
    2 pad bit (18) unal,
    2 nindex bit (18) unal;

dcl  names (1) char (32) aligned based (nptr);

dcl  cpu_no fixed bin (3) based (cpup) aligned;
dcl  CPU_NO fixed bin (3) internal static;


dcl 1 mem_data (0 : 7) based (p) aligned,
    2 size fixed bin (17) unal,
    2 base fixed bin (17) unal,
    2 pad1 bit (36),
    2 online bit (1) unal,
    2 pad2 bit (35) unal,
    2 pad3 bit (36);

dcl  msg_ptr ptr;					/* for condition interpreter */
dcl  msg_len fixed bin;
dcl  int_cond_name char (32);
dcl  proc_state (0:6) char (9) varying init
    ("empty", "running", "ready", "waiting", "blocked", "stopped", "ptlocking");

dcl  dump_infop ptr;
dcl 1 dump_info based (dump_infop),
    2 no_procs fixed bin,
    2 proc_data (proc_no refer (no_procs)) aligned,
      3 process_no fixed bin,
      3 proc_dbr fixed bin (24),
      3 apte_offs fixed bin,
      3 apte_flags like apte.flags unal,
      3 apte_state bit (18),
      3 apte_process_id bit (36);



	odsp = addr (astruc);			/* set up ptr to ol_dump structure */
	call set_default_search_dirs;

	astruc.phcs_ok = "0"b;			/* intialially set phcs_ access to no */
	call hcs_$initiate (">system_library_1", "phcs_", "", 0, 0, phcsp, code);
	if phcsp ^= null then do;			/* if can be initiated */
	     call hcs_$fs_get_mode (phcsp, rs_mode, code); /* check caller's access */
	     if code = 0 then
		if bit (rs_mode) & execute then	/* if execute, then priv. process */
		     astruc.phcs_ok = "1"b;		/* user has access to phcs_, set switch */
	end;
	dump_dir = ">dumps";			/* set default dump dir */
	pn_sw, erf_sw = "0"b;			/* reset switches */
	call cu_$arg_count (count);			/* any args */
	if count ^= 0 then				/* if args process same */
	     do i = 1 to count;
	     call cu_$arg_ptr (i, tp, tc, code);	/* get arg */
	     if code ^= 0 then do;			/* some error */
		call com_err_ (code, "ol_dump", "getting  arg # ^d", i);
		return;
	     end;
	     if pn_sw then do;			/* user wants some other pathname for dump */
		call expand_pathname_ (a_name, dump_dir, ename, code); /* expand it */
		if code ^= 0 then do;		/* user goofed */
		     call com_err_ (code, "ol_dump", "expanding pathname ""^a""", a_name);
		     return;
		end;
		dump_dir = rtrim (dump_dir) || ">" || ename; /* put it all together */
		if substr (dump_dir, 1, 2) = ">>" then
		     dump_dir = substr (dump_dir, 2);
		pn_sw = "0"b;
	     end;
	     else if a_name = "-pathname" | a_name = "-pn" then
		pn_sw = "1"b;
	     else do;				/* must be erfno */
		astruc.arg (1) = a_name;		/* copy erf no */
		erf_sw = "1"b;			/* set switch */
	     end;
	end;

	on condition (program_interrupt) go to request;	/* set up program interrupt handler */

	if erf_sw then				/* if erf was specified go do it */
	     go to doerf;
request:


handl_cond:

	on condition (any_other) begin;

	     cond_infop = addr (cond_info);
	     call find_condition_info_ (null (), cond_infop, code);
	     int_cond_name = cond_info.condition_name;


	     if cond_info.condition_name = "quit" |	/* dont bother with these */
	     cond_info.condition_name = "command_error" |
	     cond_info.condition_name = "command_question" |
	     cond_info.condition_name = "finish" then

		call continue_to_signal_ (code);

	     else do;
		if cond_info.condition_name = "out_of_bounds" then
		     call ioa_ ("ol_dump: out_of_bounds condition raised, possible invalid pointer.");
		else call condition_interpreter_ (null (), msg_ptr, msg_len, 3,
		     cond_info.mc_ptr, int_cond_name,
		     cond_info.wc_ptr, cond_infop);
		call ioa_ ("ol_dump: Returning to request loop.");
		go to request;
	     end;


	end;					/* end any_other */


	com_string, cmdarg = "";			/* clear out last command */
	call ioa_$nnl ("^/---   ");			/* print out prompt for user */
get_inp:	call iox_$get_line (iox_$user_input, addr (com_string), length (com_string), ll, code);
	if code ^= 0 then do;			/* error reading from  terminal */
	     call com_err_ (code, "ol_dump", "reading input from user_input");
	     go to request;
	end;
	substr (com_string, ll) = "";			/* strip out new_line */
	if ll = 1 then go to get_inp;			/* ignor white space */

/* separate arguments into arg array */

	lp = 1;					/* start at beginning of line */
	do i = 1 to hbound (ol_dump_struc.arg, 1) while (lp < ll);
	     j = length (ltrim (substr (com_string, lp, ll), WS)); /* strip off leading white space */
	     lp = (ll - j) + lp;			/* lp = starting position of next string */
	     j = search (substr (com_string, lp), WS);	/* find end of string */
	     if i = 1 then				/* if first arg, fill in command arg */
		cmdarg = substr (com_string, lp, j - 1);
	     else astruc.arg (i - 1) = substr (com_string, lp, j - 1);
	     lp = lp + (j - 1);			/* update line position */
	end;
	astruc.argcnt = i - 2;			/* set arg count for user */

%page;


	if cmdarg = "erf" then do;			/* we better have an erf specified */
	     if astruc.argcnt < 1 then do;
erf_label:
		call ioa_ ("erf no/last");
		go to request;
	     end;
doerf:
	     if astruc.arg (1) = "last" then do;	/* user wants latest dump */
		call get_system_free_area_ (ap);	/* get a pointer to an area to use */
		call hcs_$star_ (dump_dir, "*.*.0.*", 2, ap, count, eptr, nptr, code);
		if code ^= 0 then do;
		     call com_err_ (code, "ol_dump", "referencing directory ""^a""", dump_dir);
		     go to request;
		end;
		i = fixed (eptr -> entries (count).nindex);
		dump_name = substr (nptr -> names (i), index (nptr -> names (i), ".0.") + 3, 4);
	     end;
	     else dump_name = astruc.arg (1);		/* must be erf number */
	     call get_dump_ptrs_$dump_dir (dump_dir, dump_name, astruc.dumpp, astruc.dumpln,
		nsegs, name);			/* get ptrs to the segments */
	     if nsegs = 0 then do;			/* couldn't find the erf in >dumps */

		tname = name;
		code = 0;
		call hcs_$initiate (dump_dir, tname, "", 0, 1, acl_classp, code); /* see if its an access problem */
		if code ^= 0 then do;
		     if code = error_table_$incorrect_access then
			call ioa_ ("Incorrect access to directory ""^a""",
			dump_dir);
		     else if code = error_table_$moderr | code = error_table_$no_r_permission then
			call ioa_ ("Incorrect access to dump number ""^a"" in directory ""^a""", dump_name, dump_dir);

		     else if code = error_table_$no_dir then
			call ioa_ ("Some directory in path ""^a"" does not exist", dump_dir);

		     else if code = error_table_$noentry then
			call ioa_ ("Can't find dump number ""^a"" in directory ""^a""", dump_name, dump_dir);


		     else call ioa_ ("Can't find dump number ""^a"" in directory ""^a""", dump_name, dump_dir);
		end;

		name = "";
		go to request;
	     end;

	     call hcs_$get_max_length (dump_dir, name, astruc.max_length, code);
	     if code ^= 0 then go to fatal;
	     astruc.dbr_offset = 1;			/* default process is first */
	     astruc.proc_offset = size (dump);		/* .... */

	     call date_time_ (astruc.dumpp (0) -> dump.time, time); /* get the time of the dump */
	     call ol_dump_util_$get_ptr (7, sltp, segln, odsp); /* get pointer to the slt */
	     if sltp = null then go to request;
	     astruc.sltptr = sltp;			/* set up our structure */
	     stkout = ol_dump_util_$val_ptr (addr (sltp -> based_ptr));
	     if index (stkout, "Invalid") ^= 0 then go to fatal;
	     astruc.hcscnt = sltp -> slt.last_sup_seg;	/* Last hardcore seg number */
	     call ol_dump_util_$get_ptr (fixed (baseno (sltp -> based_ptr)), astruc.sltnp, segln, odsp);
	     if astruc.sltnp = null then go to request;
	     call ring0_get_$segptr_given_slt ("", "pds", temp_pds_ptr, code, sltp, astruc.sltnp); /* get a ptr to a pds */
	     if temp_pds_ptr ^= null then
		astruc.pdsseg = fixed (baseno (temp_pds_ptr), 18);
	     else do;
		call ioa_ ("Cannot find PDS in SLT");
		go to fatal;
	     end;
	     call ring0_get_$segptr_given_slt ("", "prds", temp_prds_ptr, code, sltp, astruc.sltnp); /* get a ptr to a prds */
	     if temp_prds_ptr ^= null then
		astruc.prdsseg = fixed (baseno (temp_prds_ptr), 18);
	     else do;
		call ioa_ ("Cannot find PRDS in SLT");
		go to fatal;
	     end;
	     call ring0_get_$segptr_given_slt ("", "kst_seg", temp_kst_ptr, code, sltp, astruc.sltnp); /* get a ptr to a kst */
	     if temp_kst_ptr ^= null then
		astruc.kstseg = fixed (baseno (temp_kst_ptr), 18);
	     else do;
		call ioa_ ("Cannot find KST in SLT");
		go to fatal;
	     end;

	     call ring0_get_$segptr_given_slt ("", "dseg", astruc.dsegp, code, sltp, astruc.sltnp); /* get dseg ptr */
	     if astruc.dsegp = null then do;
fatal:		call com_err_ (0, "ol_dump", "Insufficient or incomplete dump: ^a", dump_name);
		go to request;
	     end;
	     astruc.dsegno = fixed (baseno (astruc.dsegp)); /* get segment number of dseg */
	     call ol_dump_util_$get_ptr (astruc.dsegno, astruc.dsegp, segln, odsp); /* get ptr to dseg within the dump */
	     if astruc.dsegp = null then go to request;
	     astruc.defptr = null;			/*  get ptr to definitions seg */
	     call ring0_get_$segptr_given_slt ("", "definitions_", p, code, sltp, astruc.sltnp);
	     if code = 0 then
		call ol_dump_util_$get_ptr (fixed (baseno (p)), astruc.defptr, segln, odsp);
	     astruc.dbrsv = fixed (astruc.dsegp -> sdwa (astruc.dsegno).add, 24); /* get address field from dbr */
	     call ioa_ ("Using ERF ^d, dumped ^a", astruc.dumpp (0) -> dump.erfno, time);
	     have_erf, inited = "1"b;
	     call ring0_get_$segptr_given_slt ("", "sst", sstp, code, sltp, astruc.sltnp); /* try to get pointer to sst */
	     astruc.coremapptr = null;
	     call ring0_get_$segptr_given_slt ("", "tc_data", astruc.tcdp, code, sltp, astruc.sltnp); /* get tc_data ptr */
	     call ring0_get_$segptr_given_slt ("", "sst_names_", astruc.sstnp, code, sltp, astruc.sltnp);
	     call ring0_get_$segptr_given_slt ("", "active_all_rings_data", p, code, sltp, astruc.sltnp);
	     if code ^= 0 then go to ck_tcdp;
	     segno = fixed (baseno (p), 18);
	     call ol_dump_util_$get_ptr (segno, p, segln, odsp);
	     if p = null then go to ck_tcdp;
	     call ring0_get_$definition_given_slt (null, "active_all_rings_data", "system_id",
		def_offset, type, code, sltp, astruc.sltnp, astruc.defptr);
	     if code ^= 0 then go to ck_tcdp;
	     imcp = addrel (p, def_offset);

	     call ioa_$rsnnl ("System - ^a ", stkout, mci, sys_ver_id);
	     call ring0_get_$definition_given_slt (null, "active_all_rings_data", "version_id",
		def_offset, type, code, sltp, astruc.sltnp, astruc.defptr);
	     if code ^= 0 then go to prtsys;
	     imcp = addrel (p, def_offset);
	     call ioa_$rsnnl ("^a Version - ^a", stkout, mci, stkout, sys_ver_id);
prtsys:
	     call ioa_ ("^a", stkout);
ck_tcdp:
	     if astruc.tcdp = null then
		call ioa_ ("dbr = ^o^/NO TC_DATA", astruc.dbrsv);
	     else do;
		astruc.tcdseg = fixed (baseno (astruc.tcdp));
		call ol_dump_util_$get_ptr (fixed (baseno (astruc.tcdp)), astruc.tcdp, segln, odsp);
		if astruc.tcdp = null then go to request;
		call ring0_get_$segptr_given_slt ("", "prds", p, code, sltp, astruc.sltnp);
		astruc.prdsseg = fixed (baseno (p), 18);

		astruc.aptap = addrel (astruc.tcdp, fixed (astruc.tcdp -> tcm.apt_offset)); /* get ptr to the apt array */
		astruc.apt_entry_size = astruc.tcdp -> tcm.apt_entry_size; /* get the size of an entry */
		astruc.no_apt = astruc.tcdp -> tcm.apt_size; /* get the number of apt entries */

		call ring0_get_$segptr_given_slt ("", "scs", p, code, sltp, astruc.sltnp);
		call ol_dump_util_$get_ptr (fixed (baseno (p)), p, segln, odsp);
		call ring0_get_$definition_given_slt (null, "scs", "bos_processor_tag",
		     def_offset, type, code, sltp, astruc.sltnp, astruc.defptr);
		cpup = addrel (p, def_offset);	/* Get ptr to bos procssor tag */
		call ring0_get_$definition_given_slt (null, "scs", "controller_data",
		     def_offset, type, code, sltp, astruc.sltnp, astruc.defptr);
		p = addrel (p, def_offset);		/* Get ptr to controller data structure */
		do i = 0 to hbound (mem_data, 1);
		     if mem_data.online (i) then
			if mem_data.base (i) = 0 then
			     go to found_blscu;
		end;
found_blscu:
		CPU_NO = cpu_no;
		call ioa_ ("Bootload cpu - ^a (#^o), Bootload Memory  - ^a",
		     tag (CPU_NO), CPU_NO, tag (i));

		if sstp = null then do;
		     call ioa_ ("NO SST");
		     astruc.coremapptr = null;
		end;
		else do;
		     i = fixed (baseno (sstp));
		     call hcs_$make_seg ("", "ol_dump.sst--", "", seg_mode, sstp, code);
		     call copy_dump_seg_ (i, astruc.dbr_offset, astruc.dumpp, astruc.dumpln, sstp, sstlen);
		     astruc.sstptr = sstp;		/* set up pointer in structure */
		     if i = fixed (baseno (sst.cmp)) then /* core_map is in same segment as sst */
			astruc.coremapptr = ptr (sstp, rel (sst.cmp));
		     else do;
			call hcs_$make_seg ("", "ol_dump.core-map", "", seg_mode, astruc.coremapptr, code);
			call copy_dump_seg_ (fixed (baseno (sst.cmp)), astruc.dbr_offset, astruc.dumpp, astruc.dumpln, astruc.coremapptr, (0));
		     end;
		end;


		if astruc.sstnp = null then call ioa_ ("NO SSTNT");
		else do;
		     i = fixed (baseno (astruc.sstnp));
		     call hcs_$make_seg ("", "ol_dump.sstnt", "", seg_mode, astruc.sstnp, code);
		     call copy_dump_seg_ (i, astruc.dbr_offset, astruc.dumpp, astruc.dumpln, astruc.sstnp, sstntlen);
		end;
		call ring0_get_$segptr_given_slt ("", "kst_seg", p, code, sltp, astruc.sltnp);
		if p = null then
		     call ioa_ ("NO KST");
		else do;
		     astruc.kstseg = fixed (baseno (p));
		     call ol_dump_util_$get_ptr (astruc.kstseg, astruc.kstptr, segln, odsp);
		end;
		call hcs_$make_seg ("", "ol_dump_info", "", seg_mode, dump_infop, code);

		call display_process_$fdi (dump_infop, odsp);

		call display_am_$validate_am_btld (odsp, segln, CPU_NO, code); /* now check the validity of AMs */

		tmr, dpn = "0"b;
						/* attempt to settle in on a running process */

		dumpptr = ol_dump_struc.dumpp (0);
		ol_dump_struc.boot_dbr = fixed (substr (dump.dbr, 1, 24), 24);
		astruc.boot_dbr = ol_dump_struc.boot_dbr;
		do i = 1 to dump_info.no_procs while (tmr = "0"b);

		     if dump_info.apte_state (i) = "000001"b3 then do;
			call ol_dump_util_$get_ptr_given_dbr (dump_info.proc_dbr (i),
			     astruc.prdsseg, cpup, segln, odsp);

			if cpup = null then
			     go to runapt_lp;
			call ring0_get_$definition_given_slt (null, "prds", "processor_tag",
			     def_offset, type, code, sltp, astruc.sltnp, astruc.defptr);
			cpup = addrel (cpup, def_offset); /* Get ptr to cpu # in prds. */
			astruc.dbrsv, dbr = dump_info.proc_dbr (i);
			call ol_dump_util_$fnd_dbr (dbr, segln, icode, odsp);
			if icode = -1 then
			     go to runapt_lp;

			else do;
			     call ol_dump_util_$get_ptr (astruc.kstseg, astruc.kstptr, segln, odsp);
			     proc_no = dump_info.process_no (i);
			     dpn = "1"b;
			     tmr = "1"b;
			end;
		     end;
runapt_lp:
		end;


		call ioa_ ("^/Process^[ ^d^;^s^]: dbr = ^o, on cpu ^a (#^o)",
		     dpn, proc_no, astruc.dbrsv, tag (cpu_no), cpu_no);

		CPU_NO = cpu_no;
	     end;

	     call ring0_get_$segptr_given_slt ("", "pds", p, code, sltp, astruc.sltnp);
	     astruc.pdsseg = fixed (baseno (p), 18);

	end;

%page;
	else if cmdarg = "quit" | cmdarg = "q" then do;
	     inited = "0"b;
	     return;
	end;
%page;
	else if cmdarg = "debug" | cmdarg = "db" then do;
	     if astruc.argcnt < 1 then do;
bd_db_arg:	call ioa_ ("Improper command syntax; proper syntax is: ""debug on/off""");
		go to request;
	     end;


	     if astruc.arg (1) = "on" then
		on condition (any_other) go to handl_cond;
	     else if astruc.arg (1) = "off" then
		revert condition (any_other);
	     else go to bd_db_arg;

	     go to request;
	end;


%page;
	else if cmdarg = "command" |cmdarg = "c" then do;
	     j = length (rtrim (cmdarg)) + 1;
	     i = ll - j;
	     com_string = substr (com_string, j, i);
com:	     call cu_$cp (addr (com_string), i, code);
	end;

	else if substr (cmdarg, 1, 2) = ".." then do;
	     j = length (rtrim (com_string)) -2;
	     com_string = substr (com_string, 3, j);
	     call cu_$cp (addr (com_string), j, code);
	end;

%page;
	else if cmdarg = "list" | cmdarg = "l" then do;
	     call get_system_free_area_ (ap);		/* get a pointer to an area to use */
	     call hcs_$star_ (dump_dir, "*.*.0.*", 2, ap, count, eptr, nptr, code);
	     if code ^= 0 then do;
		call com_err_ (code, "ol_dump", "referencing directory ""^a""", dump_dir);
		go to request;
	     end;
	     call ioa_ ("ERFs contained in directory - ""^a"":^/", dump_dir);
	     do i = count to 1 by - 1;
		call ioa_ ("^a", nptr -> names (fixed (eptr -> entries (i).nindex)));
	     end;
	     free eptr -> entries;
	     free nptr -> names;
	end;

%page;
	else if cmdarg = "?" | cmdarg = "help" then do;	/* tell user what he can do */
ol_help:	     call ioa_ ("erf^/erf?^/quit (q)^/command (c)(..)^/list (l)^/dump (d)^/dbr");
	     call ioa_ ("ast (pt)^/name (n)^/proc (p)^/queue (tcq)^/stack (s)^/segno (segn)");
	     call ioa_ ("syserdta (sdta)^/syserlog (slog)^/mcpds (mcp)");
	     call ioa_ ("mcprds (mcpr)^/mc^/dumpregs (dregs)^/lrn^/ssd^/hisregs (hregs)");
	     call ioa_ ("pcd^/amsdw (ams)^/amptw (amp)^/mchist (mch)");
	     call ioa_ ("dumpdir (dmpd)^/debug (db)");
	     call ioa_ ("dump_events (de)^/absadr^/dbr?^/proc?");
	     call ioa_ ("why {lg}^/pds_trace {N}");
	end;

%page;
	else if cmdarg = "ssd" then do;
	     if astruc.argcnt < 1 | astruc.argcnt > 3 then do;
ssd_label:
		call ioa_ ("Usage is: ssd paths | def | pr^/^10xMaximum of 3 paths.");
		go to request;
	     end;
	     if astruc.argcnt = 1 & astruc.arg (1) = "pr" then go to egnor_ssd;
	     if astruc.argcnt = 1 & astruc.arg (1) = "def" then do;
		call set_default_search_dirs;
		go to egnor_ssd;
	     end;


	     do i = 1 to astruc.argcnt;
		call absolute_pathname_ ((astruc.arg (i)), tdump_dir, code);
		if code ^= 0 then do;
		     call com_err_ (code, "ol_dump", astruc.arg (i));
		     go to ssd_label;
		end;
	     end;
	     astruc.search_dirs = "";
	     do i = 1 to astruc.argcnt;
		call absolute_pathname_ ((astruc.arg (i)), tdump_dir, code);

		astruc.search_dirs (i) = tdump_dir;
	     end;
egnor_ssd:
	     call ioa_ ("Directories Searched:");
	     do i = 1 to hbound (astruc.search_dirs, 1);
		call ioa_ ("^a", astruc.search_dirs (i));
		if i + 1 <= hbound (astruc.search_dirs, 1) then
		     if astruc.search_dirs (i) = astruc.search_dirs (i+1) then go to request;
	     end;
	end;

%page;
	else if cmdarg = "dumpdir" | cmdarg = "dmpd" then do; /* user wants to look in another dump dir */
	     if astruc.argcnt < 1 then do;
		call ioa_ ("dumpdir PATH");
		go to request;
	     end;

	     tname = astruc.arg (1);
	     call expand_pathname_ (tname, dump_dir, ename, code);
	     if code ^= 0 then do;			/* user goofed */
		call com_err_ (code, "ol_dump", "expanding pathname ""^a""", a_name);
		go to request;
	     end;

	     if substr (dump_dir, 1, 3) = ">  " then
		dump_dir = "";

	     dump_dir = rtrim (dump_dir) || ">" || ename; /* put it all together */
	     inited = "0"b;
	     go to request;
	end;


%page;
	else if cmdarg = "dump_events" | cmdarg = "de" then do;

	     if astruc.argcnt < 1 then		/* ensure ERF selected */
		if ^have_erf then
		     go to NOT_INITED;

	     tname = dump_name;
	     tdump_dir = dump_dir;
	     long_flag, short_flag = "0"b;


	     if astruc.argcnt < 1 then do;		/* use defaults */
		call display_dump_events$display_dump_events_ (tname, tdump_dir, 0, 0, "1"b);
		go to request;
	     end;


	     else do i = 1 to astruc.argcnt;		/* get and validate args */
		if astruc.arg (i) = "-dump_dir" | astruc.arg (i) = "-dmpd" then do;
		     i = i + 1;
		     if i > astruc.argcnt then do;
			why = "dump_dir";
MISSING:			call com_err_ (error_table_$noarg, "display_events", why);
			go to USE;
		     end;

		     targ = astruc.arg (i);
		     call absolute_pathname_ (targ, tdump_dir, code);
		     if code ^= 0 then do;
			call com_err_ (code, "dump_events", astruc.arg (i));
			go to USE;
		     end;
		end;

		else if astruc.arg (i) = "-erf" then do;
		     i = i + 1;
		     why = "erf";
		     if i > astruc.argcnt then goto MISSING;
		     tname = astruc.arg (i);
		     have_erf = "1"b;
		end;

		else if astruc.arg (i) = "-last" | astruc.arg (i) = "-lt" then do;
		     why = "Number events";
		     i = i + 1;
		     if i > astruc.argcnt then goto MISSING;
		     on conversion goto BAD_ARGUMENT;
		     number_events = fixed (astruc.arg (i));
		     revert conversion;
		end;

		else if astruc.arg (i) = "-time" | astruc.arg (i) = "-tm" then do;
		     why = "Time interval";
		     i = i + 1;
		     if i > astruc.argcnt then goto MISSING;
		     on conversion goto BAD_ARGUMENT;
		     time_interval = fixed (astruc.arg (i)) * 1000000;
		     revert conversion;
		end;
		else if astruc.arg (i) = "-brief" | astruc.arg (i) = "-bf"
		then short_flag = "1"b;
		else if astruc.arg (i) = "-long" | astruc.arg (i) = "-lg"
		then long_flag = "1"b;

		else do;
		     call com_err_ (error_table_$badopt, "dump_events", astruc.arg (i));
USE:		     call ioa_ ("Usage is: display_events {control_args}^/^10xControl Arguments: -time, -tm {interval in sec.}     -brief, -bf     -long, -lg");
		     go to request;
		end;
	     end;

	     if short_flag & long_flag then do;
		call com_err_ (error_table_$inconsistent, "-brief and -long");
		go to request;
	     end;

	     if ^have_erf then
		go to NOT_INITED;


	     if short_flag then
		dde_mode = "0"b;
	     else dde_mode = "1"b;

	     call display_dump_events$display_dump_events_ (tname, tdump_dir, number_events,
		time_interval, dde_mode);

	     if ^inited then			/* reset ERF ind */
		have_erf = "0"b;

	     go to request;


BAD_ARGUMENT:
	     call com_err_ (error_table_$badopt, "dump_events", why);
	     go to USE;
	end;


%page;
	else if ^inited then do;			/* we haven't been given an erf yet */
NOT_INITED:    call ioa_ ("Please specify an ERF number.");
	     go to request;
	end;


%page;
	else if cmdarg = "erf?" then do;

	     call ioa_ ("Using ERF ^d, dumped ^a", astruc.dumpp (0) -> dump.erfno, time);

	     call ioa_ ("^[Proc ^d, ^;^s^]dbr = ^o on cpu ^a (#^d).", dpn, proc_no, astruc.dbrsv, tag (CPU_NO), CPU_NO);
	     go to request;
	end;


%page;
	else if cmdarg = "dbr" then do;
	     if astruc.argcnt < 1 then do;
dbr_label:	call ioa_ ("dbr value|cpun|cpu n|cpu tag|proc n |inzr");
		go to request;
	     end;

	     saved_dbr = astruc.dbrsv;

	     if astruc.arg (1) = "inzr" then do;	/* he/she wants the initializer's dbr */
set_up_inzr:	aptep = astruc.aptap;		/* get inzrs dbr */
		sdwp = addr (apte.dbr);
		new_dbr = fixed (sdw.add, 24);
		go to get_new_dbr;
	     end;


	     if astruc.arg (1) ^= "proc" & substr (astruc.arg (1), 1, 3) ^= "cpu" then do;
		new_dbr = cv_oct_check_ ((astruc.arg (1)), code);
		if code ^= 0 then go to dbr_label;
get_new_dbr:	call ol_dump_util_$get_ptr_given_dbr (new_dbr, astruc.prdsseg, cpup, segln, odsp);
		if cpup = null then do;
		     call ioa_ ("Cannot find a CPU for this dbr (^8o)", new_dbr);
		     go to request;
		end;

		astruc.dbrsv, dbr = new_dbr;

		call ring0_get_$definition_given_slt (null, "prds", "processor_tag",
		     def_offset, type, code, sltp, astruc.sltnp, astruc.defptr);
		cpup = addrel (cpup, def_offset);	/* Get ptr to cpu # in prds. */
		dpn = "0"b;
		do j = 1 to dump_info.no_procs;
		     if astruc.dbrsv = dump_info.proc_dbr (j) then do;
			proc_no = dump_info.process_no (j);
			dpn = "1"b;
			go to dbr_com;
		     end;
		end;

		go to dbr_com;
	     end;


	     if astruc.arg (1) = "proc" then do;
		if astruc.argcnt < 2 then go to dbr_label;
		pnum = astruc.arg (2);
		edoc = cv_dec_check_ (ltrim (rtrim (pnum)), code);
		if code ^= 0 then
		     go to dbr_label;
		dpn, tmr = "0"b;
		do i = 1 to dump_info.no_procs while (^tmr);
		     if edoc = dump_info.process_no (i) then do;
			call ol_dump_util_$get_ptr_given_dbr (dump_info.proc_dbr (i),
			     astruc.prdsseg, cpup, segln, odsp);

			if cpup = null then do;
			     call ioa_ ("Cannot find a CPU for this process.");
			     if edoc = 0 then go to set_up_inzr;
			     go to request;
			end;
			call ring0_get_$definition_given_slt (null, "prds", "processor_tag",
			     def_offset, type, code, sltp, astruc.sltnp, astruc.defptr);
			cpup = addrel (cpup, def_offset);
			dpn = "1"b;
			proc_no = edoc;
			tmr = "1"b;
			astruc.dbrsv, dbr = dump_info.proc_dbr (i);
			go to dbr_com;
		     end;
		end;
		if ^tmr then do;			/* couldn't find it */
		     if edoc = 0 then go to set_up_inzr;
		     call ioa_ ("Could not find ^a in process table.", astruc.arg (2));
		     go to request;
		end;
	     end;


	     else if substr (astruc.arg (1), 1, 3) = "cpu" then do;
		if length (astruc.arg (1)) > 3 then
		     cnum = substr (astruc.arg (1), 4, 1);
		else if astruc.argcnt > 1 then
		     cnum = substr (astruc.arg (2), 1, 1);
		else go to dbr_label;
		edoc = cv_oct_check_ (cnum, code);
		if code ^= 0 then do;
		     tmr = "0"b;
		     do i = 0 to hbound (tag, 1) while (^tmr);
			if cnum = tag (i) then
			     tmr = "1"b;
		     end;
		     if ^tmr then go to dbr_label;
		     edoc = i - 1;
		end;
		do i = 0 to astruc.no_apt;
		     aptep = addrel (astruc.aptap, i*astruc.apt_entry_size);
		     if apte.state = "000001"b3 then do;
			sdwp = addr (aptep -> apte.dbr); /* running */
			call ol_dump_util_$get_ptr_given_dbr (fixed (sdw.add, 24), astruc.prdsseg, cpup, segln, odsp);
			if cpup = null then go to fdbrlp;
			call ring0_get_$definition_given_slt (null, "prds", "processor_tag",
			     def_offset, type, code, sltp, astruc.sltnp, astruc.defptr);
			cpup = addrel (cpup, def_offset); /* Get ptr to cpu # in prds. */
			dpn = "0"b;
			if cpu_no = edoc then do;
			     do j = 1 to dump_info.no_procs;
				if fixed (sdw.add, 24) = dump_info.proc_dbr (j) then do;
				     proc_no = dump_info.process_no (j);
				     dpn = "1"b;
				     go to got_cpu;
				end;
			     end;
			end;
		     end;
fdbrlp:
		end;
		call ioa_ ("No running process for cpu ^a (#^o) found", tag (edoc), edoc);
		go to request;
got_cpu:
		astruc.dbrsv, dbr = fixed (sdw.add, 24);
		go to dbr_com;
	     end;

dbr_com:
	     call ol_dump_util_$fnd_dbr (dbr, segln, i, odsp);

	     if i = -1 then do;
		call ioa_ ("dbr ^o not found in erf ^a", dbr, dump_name);
						/* ensure dbr is what it was */
		astruc.dbrsv, dbr = saved_dbr;
		call ol_dump_util_$fnd_dbr (dbr, segln, i, odsp);
	     end;

	     else do;
		call ol_dump_util_$get_ptr (astruc.kstseg, astruc.kstptr, segln, odsp);
		call ioa_ ("^[Proc ^d, ^;^s^]dbr = ^o on cpu ^a (#^o)",
		     dpn, proc_no, astruc.dbrsv, tag (cpu_no), cpu_no);
		CPU_NO = cpu_no;
		astruc.dbrsv = dbr;
		go to request;
	     end;
	end;


%page;
	else if cmdarg = "tcq" | cmdarg = "queue" then
	     call display_process_$tcq (dump_infop, odsp); /* print traffic controller queue */
	else if cmdarg = "dump" | cmdarg = "d" then
	     call display_dump_ (odsp);		/* display requested dump */
	else if cmdarg = "ast" | cmdarg = "pt" then
	     call display_ast_ (odsp);		/* print the requested AST entry */
	else if cmdarg = "name" | cmdarg = "n" then
	     call display_segment_$name (odsp);		/* display the requested segment name */
	else if cmdarg = "segno" | cmdarg = "segn" then
	     call display_segment_$number (odsp);	/* display the requested segment number */
	else if cmdarg = "p" | cmdarg = "proc" then
	     call display_process_$apt (odsp);		/* display the requested APT entries */
	else if cmdarg = "stack" | cmdarg = "s" then
	     call display_stack_ (odsp);		/* trace the requested stack segment */
	else if cmdarg = "syserdta" | cmdarg = "sdta" then
	     call display_syserr_$data (odsp);		/* display the message entries in syserr_data */
	else if cmdarg = "syserlog" | cmdarg = "slog" then
	     call display_syserr_$log (odsp);		/* display the requested message entries in syserr_log */
	else if cmdarg = "mcp" | cmdarg = "mcpds" then
	     call display_regs_$mcpds (odsp);		/* display the requested pds machine conditions */
	else if cmdarg = "mcpr" |cmdarg = "mcprds" then
	     call display_regs_$mcprds (odsp);		/* display the requested prds machine machine conditions */
	else if cmdarg = "mc" then
	     call display_regs_$mc (odsp);		/* display requested machine condition */
	else if cmdarg = "dumpregs" | cmdarg = "dregs" then
	     call display_regs_$dump (odsp);		/* display the processor regs at the time of the dump */
	else if cmdarg = "lrn" then
	     call display_segment_$dseg (odsp);		/* display the descriptor segment */
	else if cmdarg = "hisregs" | cmdarg = "hregs" then
	     call display_regs_$hregs (odsp);		/* display the requested history registers */
	else if cmdarg = "pcd" then
	     call display_segment_$config (odsp);	/* display the config deck */
	else if cmdarg = "amsdw" | cmdarg = "ams" then
	     call display_am_$sdw (odsp, CPU_NO);	/* display the SDW assos. memory */
	else if cmdarg = "amptw" | cmdarg = "amp" then
	     call display_am_$ptw (odsp, CPU_NO);	/* display the PTW assos. memory */
	else if cmdarg = "mchist" | cmdarg = "mch" then
	     call display_mchist_ (odsp);		/* display sorted machine conditions */
	else if cmdarg = "absadr" then
	     call display_ast_$absadr (odsp);
	else if cmdarg = "proc?" | cmdarg = "dbr?" then

	     call ioa_ ("ERF ^d, dumped ^a^/^[Proc ^d, ^;^s^]dbr = ^o on cpu ^a (#^d).",
	     astruc.dumpp (0) -> dump.erfno, time, dpn, proc_no, astruc.dbrsv, tag (CPU_NO), CPU_NO);
	else if cmdarg = "." then do;
	     if dump_dir ^= ">dumps" then
		display_dump_dir = "1"b;
	     call ioa_ ("^/ol_dump version 10.1:^/ERF ^d, dumped ^a ^[ Dump Dir = ^a^]",
		astruc.dumpp (0) -> dump.erfno, time, display_dump_dir, ltrim (rtrim (dump_dir)));
	     call ioa_ ("^[Proc ^d, ^;^s^]dbr = ^o on cpu ^a (#^d).",
		dpn, proc_no, astruc.dbrsv, tag (CPU_NO), CPU_NO);
	end;


	else if cmdarg = "pds_trace" then call pds_trace_ (odsp);

	else if cmdarg = "why" then do;
	     call ol_dump_why_ (odsp);
	     new_dbr = astruc.dbrsv;
	     go to get_new_dbr;
	end;


	else					/*  must be invalid command, let user know and go to request */
	call ioa_ ("Invalid command argument ""^a""; type ""help"" for a list of valid commands", cmdarg);


	go to request;				/* return to get next command */
%page;
set_default_search_dirs: proc;

dcl  default_path_list_name char (1024) var;
dcl (i, j) fixed bin;
dcl  ec fixed bin (35);
dcl  cu_$evaluate_active_string entry (ptr, char (*), fixed bin, char (*) var, fixed bin (35));

%include cp_active_string_types;

	     call cu_$evaluate_active_string (null (), "library_descriptor pathname h.e", ATOMIC_ACTIVE_STRING, default_path_list_name, ec);
	     if ec ^= 0 then do;
		call com_err_ (ec, "ol_dump", "From call to library_descriptor active function.  Cannot set default search directories.");
		astruc.search_dirs (*) = "";
	     end;
	     j = 1;
	     do while (j <= hbound (astruc.search_dirs, 1) & default_path_list_name ^= "");
		astruc.search_dirs (j) = before (default_path_list_name, " ");
		default_path_list_name = ltrim (after (default_path_list_name, " "));
		j = j + 1;
	     end;
	     do i = j to hbound (astruc.search_dirs, 1);	/* The rest get filled with dummies. */
		astruc.search_dirs (i) = astruc.search_dirs (j - 1);
	     end;
	end set_default_search_dirs;


%page;
% include slt;
%page;
% include sst;
%page;
% include aste;
%page;
% include sdw;
%page;
% include bos_dump;
%page;
% include apte;
%page;
% include tcm;
%page;


     end ol_dump;
