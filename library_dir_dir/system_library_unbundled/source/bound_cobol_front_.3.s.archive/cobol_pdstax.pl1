/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8063),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8063 cobol_pdstax.pl1 Fix bug in abbreviated conditionals.
  2) change(89-04-23,Zimmerman), approve(89-04-23,MCR8082),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8082 cobol_pdstax.pl1 Fix wild array subscript.
                                                   END HISTORY COMMENTS */


/* Modified on 01/24/85 by FCH, [5.3-2], RLS for cond statements drastically changed, BUG561 */
/* Modified on 11/04/83 by FCH, [5.3-1], illegal abbrev rel cond caused abort, BUG563(phx16292) */
/* Modified on 07/11/83 by FCH, [5.2-1], SUPPRESS verb does not work, BUG553(phx15481) */
/* Modified on 11/1/82 by FCH, [5.1-5], delete certain diags concerning files, BUG542(phx13372) */
/* Modified on 03/10/82 by FCH, [5.1-4], dont set file_table.read_next, BUG529 */
/* Modified on 03/05/82 by FCH, [5.1-3], NEXT STATEMENT sometimes blows conpiler, BUG527 */
/* Modified on 12/22/81 by FCH, [5.1-2], set LTP = "1"b, phx12120(BUG5.1) */
/* Modified on 12/17/81 by FCH, [5.1-1], fix bug in NOT(condition), BUG300 */
/* Modified on 10/02/81 by FCH, [5.0-1], fix flagging for validation-81, BUG501 */
/* Modified on 06/23/81 by FCH, [4.4-12], SUBJ_REQ saved in cstack, BUG487 */
/* Modified on 06/11/81 by FCH, [4.4-11], end_stmt.a = "010"b for STOP RUN if CD INITIAL, BUG468 */
/* Modified on 05/19/81 by FCH, [4.4-10], using param not 01 or 77 must begin on full word, TR9918(BUG483) */
/* Modified on 04/17/81 by FCH, [4.4-9], Format 1 SEND statement incorrectly parsed, BUG478 */
/* Modified on 04/06/81 by FCH, [4.4-8], fix bugs in leveling for validation-81, BUG477 */
/* Modified on 02/21/81 by FCH, [4.4-7], receive statement syntax incorrect, new actions added */
/* Modified on 01/17/81 by FCH, [4.4-6], bug 5-206 illegally issued on subscripted refs, BUG460(phx08894) */
/* Modified on 12/10/80 by FCH, [4.4-5], report writer added */
/* Modified on 12/08/80 by FCH, [4.4-4], reset UB_ind if end word */
/* Modified on 11/26/80 by FCH, [4.4-3] diag 5-274 added added, BUG456(phx08316) */
/* Modified on 11/04/80 by FCH, [4.4-2], BUG454(TR3324), action 300,diag 279 on prev tok */
/* Modified on 11/04/80 by FCH, [4.4-1], fix leveling diags in ae */
/* Modified on 04/08/80 by FCH, [4.2-8], diags not issued on class tests, BUG434(TR5876) */
/* Modified on 04/05/80 by FCH, [4.2-7], fix out-of-range checking, BUG430(TR4533) */
/* Modified on 03/22/80 by FCH, [4.2-6], corrections to leveling diags for conditions */
/* Modified on 03/13/80/by FCH, [4.2-5], num.edit to alphabetic move not detected, BUG431 */
/* Modified on 03/13/80 by FCH, [4.2-4], BUG429, L-11 issued illegally when two numeric items compared, SQ431 */
/* Modified on 02/08/80 by MHD,[4.2-3], fixed leveling problem on condition names and more than one SORT */
/* Modified on 12/20/79 by MHD,[4.2-2], fixed bug 416, OCCURS DEPENDING ON *
/* Modified on 11/20/79 by  MHD, [4.2-1], check for both debug and use_debug */
/* Modified on 10/30/79 by MHD, [4.1-1], diagnostic is put out on previous token if current line = 0 */
/* Modified on 09/27/79 by MHD, [4.1-7], put diagnostics on correct symbol */
/* Modified on 08/29/79 by FCH, [4.0-6], L-11 at correct token */
/* Modified on 06/26/79 by FCH, [4.0-5], stream files allowed in sort */
/* Modified on 05/11/79 by FCH, [4.0-4], debug */
/* Modified on 04/02/79 by FCH, [4.0-3], mixed subs and indexing illegal */
/* Modified on 03/28/79 by FCH, [4.0-2], fix leveling diags */
/* Modified on 03/21/79 by FCH, [4.0-1], dont test sizes if numeric */
/* Modified on 12/20/78 by RAL, [3.0-16] added check seqstmfil using savitmptr */
/* Modified on 10/27/78 by RAL, [3.0-15] rewote check (158) and added action (288) for alternate record keys */
/* Modified on 09/13/78 by RAL, [3.0-14] check(210) is file device suffix printer */
/* Modified on 06/15/78 by RAL, [3.0-13], action(287) check to issue leveling diag 172 */
/* Modified on 06/08/78 by RAL, [3.0-12], action(286) issue leveling diag 169 */
/* Modified on 05/16/78 by FCH, [3.0-11], diag 147 issued illegally */
/* Modified on 05/05/78 by FCH, [3.0-10], flag illegal comparisions as extensions */
/* Modified on 05/03/78 by FCH, [3.0-9], when(search) sets UB_ind to 0 */
/* Modified on 04/24/78 by FCH, [3.0-8], check for section name */
/* Modified on 04/20/78 by FCH, [3.0-7], check(28):sizlit, inspect statement */
/* Modified on 03/23/78 by FCH, [3.0-6],  lev diag, non-positive integer */
/* Modified on 03/08/78 by FCH, [3.0-5], action(211), test for index name */
/* Modified on 02/17/78 by FCH, [3.0-4], correct values for mnemonic_name.iw_key */
/* Modified on 01/05/78 by FCH, [3.0-3], check170(ckintbit) fixed, used by perform */
/* Modified on 12/27/77 by FCH, [3.0-2], write stream file required invalid option */
/* Modified on 09/08/77 by FCH, [3.0-1], emit level for levelling diags 11,12,13 fixed */
/* Changes made since Version 3.0 */








/* format: style3 */
cobol_pdstax:
     proc;

/*[4.1-7]*/
	prev_token_ptr = null ();			/*[4.1-7]*/
	mptr = null ();
	seg_usage_ptr = addr (seg_usage_string);
	sort_count = 0;
	O1_ptr = addr (O1);
	O2_ptr = addr (O2);
	message_ind = 0;
	comsrtrngptr = (null ());
	addr (stat.procdef) -> bit9 = "0"b;
	next_sent_label = 0;
	perflink, perflink1 = "00000";
	perfext = 0;
	gotodep, preospn_bit, srchfm2bit, ns_found = "0"b;


/*[5.3-2]*/
	nest_lev = 1;				/*[5.3-2]*/
	call reset_st;

	fircar = "1"b;
	dbp, drc = 1;
	common_eof = "0"b;

	act_log_ptr = addr (act_log);
	act_log_ptr -> bit16 = "0"b;			/*[5.3-2]*/
	addr (ST (0)) -> bit180 = "0"b;		/*[5.0-1]*/
	seg_limit = cobol_idedsyn$get_seg_limit ();

	cssub, assub, mod_num, decswitch, secswitch, debugsw, diagno, cursecnum = 0;

	i1 = 0;
	syntax_line_ptr = addr (sline);
	sline.s_exit = 70;

	end_stmt.size = 38;
	end_stmt.line = 0;
	end_stmt.column = 0;
	end_stmt.type = 19;
	end_stmt.verb = 0;

	seq, input, rewind = 1;
	output = 2;

	dumprocname.size = 49;
	dumprocname.line = 0;
	dumprocname.column = 0;
	dumprocname.type = 18;
	dumprocname.searched = "0"b;
	dumprocname.duplicate = "0"b;

	dpnptr = addr (dumprocname);			/*[5.2-1]*/
	end_decl_bit = "1"b;
	sav_ptr = addr (saveitem);
	head_ptr = addr (header);

	work_ptr = addr (work);
	subject_ptr = addr (subject);
	soperator_ptr = addr (soperator);
	coperator_ptr = addr (coperator);
	end_stmt_ptr = addr (end_stmt.verb);
	es_ptr = addr (end_stmt);
	sav_bit, arith_op = "0"b;

	c_ptr = addr (coperator.c);

	code_env_ptr = addr (code_env);
	code_env.arg_1 = addr (end_stmt);
	code_env.arg_2 = addr (opeos);
	code_env.arg_3 = addr (dumprocname);
	code_env.arg_4 = addr (code_env);
	code_env.arg_5 = addr (code_option);

	code_env.arg_6 = addr (DATA);
	call cobol_pd_code$initialize (code_env_ptr);

	addr_record = addr (header);
	cdtoken_ptr = addr_record;
	op_ptr = addr (op);				/*[3.0-10]*/
	left_ptr = addr (left);			/*[3.0-10]*/

/* end of init changed to assign */

	savidptr = addr (saveident);			/* init to saved identifier*/
	opeosptr = addr (opeos);			/*initialize opeosptr to addr of operation eos */
	savitmptr = addr (saveitem);
	eosptr = addr (end_stmt);			/*  used for i-o */


	call cobol_pdst (pointer_to_internal, dumfix);	/* initialize diag item */
	dg_ptr = addr (diag_item);
	diag_item.size = 28;
	diag_item.type = 5;
	diag_item.run = 5;				/*[4.4-5]*/
	eos_perform_ptr = addr (eos_perform);
	rw_perform_ptr = addr (rw_perform);		/*[5.2-1]*/
	rw_move_ptr = addr (rw_move);			/*[5.2-1]*/
	supp_lit_ptr = addr (supp_lit);		/*[5.2-1]*/
	eos_move_ptr = addr (eos_move);
	lev_dg_ptr = addr (lev_diag_item);
	lev_diag_item.size = 28;
	lev_diag_item.type = 5;
	lev_diag_item.run = 9;

	decswitch = 0;
	diag_item.info = "00000000"b;

	DIAG_NUM = 0;
	trace_ptr = addr (interp);
	tbit = fixed_common.syntax_trace;

	if tbit
	then call cobol_syntax_trace_$initialize_phase (trace_ptr, 3);

	call SCAN;

	current_line = syntax_line.s_exit;

	go to new_inst;

/*					*/
/*	 syntax interpreter			*/
/*					*/

fail:						/*failure */
	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm2);

next_inst:
	current_line = current_line + 1;

new_inst:						/* new instruction */
	syntax_line_ptr = addr (syntax_table (current_line));

	go to test (syntax_line.t_type);

test (0):						/* reserved word test */
	if reserved_word.type ^= 1
	then go to fail;

	if reserved_word.key ^= syntax_line.t_field
	then go to fail;

success:						/* success */
	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm1);

ucon:
	if syntax_line.o_bit ^= " "
	then if syntax_line.o_bit ^= "o"
	     then do;
		     if syntax_line.o_bit > fixed_common.comp_level
						/*[4.4-2]*/
		     then do;
			     if sav_bit		/*[4.4-2]*/
			     then call LEV_DIAG (syntax_line.a_num, sav.line, sav.column);
						/*[4.4-2]*/
			     else call lev_diag (syntax_line.a_num);

/*[4.4-2]*/
			end;

/*[4.4-2]*/
		     sav_bit = "0"b;

		     go to ret;
		end;

	go to action (syntax_line.a_num);

test (1):						/* check routine test */
	go to check (syntax_line.t_field);

test (2):						/* unconditional branch */
	DIAG_NUM = syntax_line.t_field;
	act_num = syntax_line.a_num;

	if syntax_line.o_bit ^= " "
	then if syntax_line.o_bit ^= "o"
	     then do;
		     if syntax_line.o_bit > fixed_common.comp_level
		     then do;
			     mod_num = syntax_line.a_num;

/*[4.4-2]*/
			     if sav_bit		/*[4.4-2]*/
			     then call LEV_DIAG (DIAG_NUM, sav.line, sav.column);
						/*[4.4-2]*/
			     else call lev_diag (DIAG_NUM);

			end;

		     DIAG_NUM = 0;
		     act_num = 0;			/*[4.4-2]*/
		     sav_bit = "0"b;
		end;

	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm1);

	go to action (act_num);

test (3):
	i1 = i1 + 1;
	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm3);

	if i1 > 75
	then go to comp_error;

	intrp_stack (i1) = current_line;
	current_line = syntax_line.t_field;

	go to new_inst;

ret:
action (0):
	if DIAG_NUM ^= 0
	then do;
		if message_ind = 0			/*[4.1-1]*/
		then if header.line ^= 0
		     then call diag (DIAG_NUM);	/*[4.1-1]*/
		     else call DIAG_PREV_TOKEN (DIAG_NUM);
		message_ind, DIAG_NUM = 0;
	     end;

	if syntax_line.o_bit = "o"
	then if ^ST.skip_ind (nest_lev)
	     then call put;

	if syntax_line.s_bit = "s"
	then call SCAN;

	current_line = syntax_line.s_exit;

	go to new_inst;

action (1):					/* exit true */
	current_line = intrp_stack (i1);

	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm4);

	syntax_line_ptr = addr (syntax_table (current_line));
	i1 = i1 - 1;

	go to ucon;

action (2):					/* exit false */
	current_line = intrp_stack (i1);

	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm5);

	i1 = i1 - 1;

	go to next_inst;

comp_error:
	diag_item.number = 183;
	diag_item.column = header.column;
	diag_item.line = header.line;

	call cobol_c_list (dg_ptr);

	return;

SCAN:
     proc;

	do while ("1"b);

/*[4.1-7]*/
	     prev_token_ptr = mptr;			/* saves pointer to previous token_ptr */

/*[4.4-2]*/
	     LTP = last_wd_per;			/*[4.4-2]*/
	     last_wd_per = "0"b;

	     call cobol_swf_get (cobol_rm2fp, st, mptr, tln);

	     if substr (st, 17, 16) ^= "0"b
	     then go to endint;

	     substr (addr_record -> itemsize1, 1, headerb.size) = mptr -> itemsize1;

	     if header.type = 5
	     then do;
		     call cobol_c_list (addr_record);

		     if message.rep_bit = "0"b
		     then message_ind = 1;

		     else if diag_file.diag_table.d_type (diag_file.run_table.base (message.run) + message.number) = 3
		     then return;

		end;

	     else if header.type = 6
	     then call cobol_c_list (addr_record);

/*[5.2-1]*/
	     else if header.type = 9 & ^end_decl_bit	/*[5.2-1]*/
	     then if substr (data_name.name, 1, 2) = "SS" /*[5.2-1]*/
		then data_name.type = 91;
	     return;
	end;

     end;

put:
     proc;					/* routine to output the window token */
	seqvarptr = addr_record;
	seqvarleng = header.size;
	call seqput;
     end put;

diag:
     proc (diag_num);

declare	diag_num		fixed bin;

	if header.type = 5 & (syntax_line.t_field = 7 | syntax_line.t_field ^= 164)
	then return;
	else do;
		diag_item.number = diag_num;
		diag_item.column = header.column;
		diag_item.line = header.line;
		call cobol_c_list (dg_ptr);
	     end;
     end diag;

lev_diag:
     proc (diag_num);

declare	diag_num		fixed bin;

	lev_diag_item.line = header.line;
	lev_diag_item.column = header.column;
	lev_diag_item.number = diag_num;
	lev_diag_item.module = mod_num;

	call cobol_c_list (lev_dg_ptr);

	mod_num = 0;

     end;

/*[4.1-7]*/
DIAG_PREV_TOKEN:
     proc (diag_num);

/* This procedure emits a diagnostic message referenced by diag_num and puts it at the */
/* previous token.  Used when look-ahead is needed to determine the error */

declare	diag_num		fixed bin;

	diag_item.number = diag_num;
	diag_item.column = prev_token_ptr -> source.column;
	diag_item.line = prev_token_ptr -> source.line;
	call cobol_c_list (dg_ptr);

     end DIAG_PREV_TOKEN;

/*[4.1-7]*/
DIAG:
     proc (diag_num);

/* This procedure emits a diagnostic message reference by diag_num and  puts it at locatiion */
/* represented in prev_diag.  This is used when look-ahead for more than 1 symbol  needed to determine the error */
/* For look-ahead for only 1 symbol see DIAG_PREV_TOKEN above */

declare	diag_num		fixed bin;

	diag_item.number = diag_num;
	diag_item.column = prev_diag.column_num;
	diag_item.line = prev_diag.line_num;
	call cobol_c_list (dg_ptr);

     end DIAG;

/*[4.0-1]*/
LEV_DIAG:
     proc (diag_num, line_num, col_num);

/*[4.0-1]*/
dcl	(diag_num, line_num, col_num)
			fixed bin;

/*[4.0-1]*/
	lev_diag_item.line = line_num;		/*[4.0-1]*/
	lev_diag_item.column = col_num;		/*[4.0-1]*/
	lev_diag_item.number = diag_num;		/*[4.0-1]*/
	lev_diag_item.module = mod_num;

/*[4.0-6]*/
	call cobol_c_list (lev_dg_ptr);

     end;						/*[4.0-1]*/

seqput:
     proc;

	if ^ST.skip_ind (nest_lev)
	then call cobol_swf_put (cobol_pdofp, st, seqvarptr, seqvarleng);

     end seqput;

seqputeos:
     proc;

	if ^ST.skip_ind (nest_lev)
	then call cobol_swf_put (cobol_pdofp, st, eosptr, end_stmt.size);

     end seqputeos;

vardget:
     proc;

	call cobol_vdwf_dget (cobol_cmfp, st, seqvarptr, common_recsize, varrecaddr);

     end vardget;

vardput:
     proc;

	if ^ST.skip_ind (nest_lev)
	then call cobol_vdwf_dput (cobol_cmfp, st, seqvarptr, seqvarleng, varrecaddr);

     end vardput;


/* the following are the check routines */

/* is dd cd initial bit not set */




check (1):
inbit:
	if ^init_cd
	then go to success;
	go to fail;

/* is item an 01 or 77 item in linkage section */



check (2):
lident:
	if (header.type = 9) & ((data_name.level = 01) | (data_name.level = 77)) & data_name.linkage_section
	then go to success;
	go to fail;
check (3):
linktot:
	if end_stmt.e = number_of_ls_pointers
	then go to success;
	go to fail;				/* is it a section header */
check (4):
sechdr:
	if (header.type = 7) & (proc_def.section_name = "1"b)
	then go to success;
	go to fail;				/* is it a non sort file name */



check (5):
filenm:
	if header.type = 12
	then if fd_token.file_no ^= 0
	     then do;
		     call cobol_read_ft_ (fd_token.file_no, ft_ptr);

		     file_org = file_table.organization;
		     go to success;
		end;

	go to fail;				/* is it not format 2 or
			is it format 2 without  labels are omitted clause */



check (6):
formtlb:
	if (end_stmt.a ^= "001"b)			/* chk filtbl for no labels if frmt 2 */
	then go to success;
	go to fail;				/* is it a report section  group item */
check (7):
rident:
	if header.type = 21
	then go to success;
	go to fail;				/* is it a procedure definition */
check (8):
paranm:
prdef:
	if (header.type = 7 & proc_def.section_name = "0"b)
	then go to success;
	go to fail;				/* is it a verb */



check (9):
verb:						/*[5.2-1]*/
	if ((header.type = 1) & (reserved_word.verb = "1"b)) | header.type = 91
	then do;
		if UB_ind
		then call diag (126);

		UB_ind = "0"b;
		go to success;
	     end;
	go to fail;				/* is section number legitimate */


check (10):
prnum:
	if header.type = 2 & numeric_lit.integral = "1"b & numeric_lit.sign = " " & numeric_lit.seg_range = "1"b
	then go to success;
	go to fail;				/* is saved item not alphabetic */
check (11):
sina:
	if (savitmptr -> data_name.numeric) | (savitmptr -> data_name.numeric_edited)
	     | (savitmptr -> data_name.alphanum)
	then go to success;
	go to fail;				/* is it a numeric literal */


check (12):
numlit:						/*[5.0-1]*/
	if header.type = 2				/*[5.0-1]*/
	then seg_num = fixed (numeric_lit.literal);	/*[5.0-1]*/
	else seg_num = 0;

	if fixed_common.comp_level < "4"
	then do;
		if last_seg_num ^= 1000
		then do;
			if seg_usage (seg_num) & seg_num ^= last_seg_num
			then call lev_diag (81);

		     end;

		last_seg_num = seg_num;
		seg_usage (seg_num) = "1"b;

	     end;

	if header.type = 2
	then go to success;
	go to fail;				/* is it an alterable procedure name reference */


check (13):
altprnm:
	if (header.type = 18 & proc_def.alterable = "1"b)
	then go to success;
	go to fail;				/* is it a procedure name reference */


check (14):
prnm:
	if header.type = 18
	then go to success;
	go to fail;				/* is it a non numeric literal */
check (15):
nonumlit:
	if header.type = 3
	then go to success;
	go to fail;				/* is it an 01 or 77 item within file working-storage communication or link section */


check (16):
useid:
	if header.type = 2 | header.type = 3
	then do;

		if fixed_common.comp_level < "5"
		then call lev_diag (153);

		go to success;
	     end;

	if header.type = 9
	then do;
		if ((data_name.level = 1 | data_name.level = 77)
		     & (data_name.file_section | data_name.working_storage | data_name.communication_section
		     | data_name.linkage_section | data_name.constant_section))
		then go to success;
	     end;

	go to fail;

/* is it a non sort file name */


check (17):
nsfilnm:
	if header.type = 12
	then if fd_token.file_no ^= 0
	     then do;
		     call cobol_read_ft_ (fd_token.file_no, ft_ptr);
		     file_org = file_table.organization;
		     go to success;
		end;
	go to fail;				/* is it an input cd name */


check (18):
incdnm:
	if (header.type = 13 & cdtoken.options.input)
	then go to success;
	go to fail;				/* is it an output cd name */


check (19):
outcdnm:
	if (cdtoken.type = 13 & cdtoken.output)
	then go to success;
	go to fail;

/*is saved file indexed */



check (20):
ixfil:
	if savitmptr -> fd_token.file_no = 0
	then go to fail;

	file_number = savitmptr -> fd_token.file_no;
	call cobol_read_ft_ (file_number, ft_ptr);

	if organization = 3
	then go to success;
	go to fail;

/* is it a literal */



check (21):
lit:
	if header.type = 2 | header.type = 3
	then go to success;
	go to fail;				/* is item a figurative constant except all */
check (22):
figconall:
	if fixed_common.comp_level < "3"
	then do;
		if header.type = 1 & reserved_word.figcon
		then do;
			if reserved_word.end_dec
			then call lev_diag (154);
			go to success;
		     end;
	     end;
	else do;
		if header.type = 1 & reserved_word.figcon
		then go to success;
	     end;

	go to fail;

/* does file have sequential access or dynamic access */

check (23):
sqacdyac:
	if savitmptr -> fd_token.file_no = 0
	then go to fail;

	file_number = savitmptr -> fd_token.file_no;
	call cobol_read_ft_ (file_number, ft_ptr);

	if access < 2 | access = 3
	then go to success;
	go to fail;

check (24):
is_cobol:
	if lang_num = 1
	then go to success;

	go to fail;

check (25):
rpid:						/*[4.4-5]*/
	if header.type = 18
	then go to success;
	go to fail;				/* is it a declarative section name reference */
check (26):
descnm:
	if header.type = 18 & proc_def.section_name & proc_def.declarative_proc
	then go to success;
	go to fail;				/* is it an rd report name */
check (27):
repnm:						/*[4.4-5]*/
	if header.type = 18
	then go to success;
	go to fail;				/* is current size = to saved item size */
check (28):
sizlit:						/*[3.0-7]*/
						/*[]*/
	if header.type = 1
	then go to success;				/* fig_con */
						/*[]*/
						/*[]*/
	if saveitem.type = 3			/*[]*/
	then do;
		LL = savitmptr -> alphanum_lit.lit_size;/*[]*/
						/*[]*/
		if header.type = 3			/*[]*/
		then do;
			if LL = alphanum_lit.lit_size
			then go to success;		/*[]*/
		     end;				/*[]*/
		else /*[]*/ /*[]*/
		     if header.type = 9		/*[]*/
		then do;
			call sizedn (addr_record);	/*[]*/
						/*[]*/
			if LL = L
			then go to success;		/*[]*/
		     end;				/*[]*/
	     end;					/*[]*/
	else /*[]*/ /*[]*/
	     if saveitem.type = 9			/*[]*/
	then do;
		call sizedn (savitmptr);		/*[]*/
						/*[]*/
		if header.type = 3			/*[]*/
		then do;
			if L = alphanum_lit.lit_size
			then go to success;		/*[]*/
		     end;				/*[]*/
		else /*[]*/ /*[]*/
		     if header.type = 9		/*[]*/
		then do;
			LL = L;			/*[]*/
			call sizedn (addr_record);	/*[]*/
						/*[]*/
			if LL = L
			then go to success;		/*[]*/
		     end;				/*[]*/
	     end;					/*[]*/
	else /*[]*/ /*[]*/
	     if saveitem.type = 1			/*[]*/
	then do;
		if header.type = 3			/*[]*/
		then do;
			if alphanum_lit.lit_size = 1
			then go to success;		/*[]*/
		     end;				/*[]*/
		else /*[]*/ /*[]*/
		     if header.type = 9		/*[]*/
		then do;
			call sizedn (addr_record);	/*[]*/
						/*[]*/
			if L = 1
			then go to success;		/*[]*/
		     end;				/*[]*/
	     end;

	go to fail;


sizedn:
     proc (p);

/*[]*/
declare	p		ptr;			/*[]*/
						/*[]*/
	if p -> data_name.numeric | p -> data_name.numeric_edited
						/*[]*/
	then L = p -> data_name.places_left + p -> data_name.places_right;
						/*[]*/
	else L = p -> data_name.item_length;

     end;						/*[3.0-7]*/

/*is file not sequentila access
	not file table already in core from check 38 */

check (29):
notseqac:
	if access > 1
	then go to success;
	go to fail;

/* is saved item not mass storage and
			is it sequential and is it single reel */


check (30):
nomsss:
	if savitmptr -> fd_token.file_no ^= 0
	then do;
		file_number = savitmptr -> fd_token.file_no;
		call cobol_read_ft_ (file_number, ft_ptr);
	     end;
	else go to fail;

	if organization = 1
	then go to success;
	go to fail;				/* is it a non sort mass storage file */
check (31):
msfilnm:						/*  according to ron ham we do not check for ms file regardless of codasyl rules */
	if header.type = 12
	then go to success;
	go to fail;

/* is there a format 1 use procedure associated with the delete statement
	note file table already in core from check 38 */

check (32):
useform1:
	if error_exit ^= 0
	then go to success;
	go to fail;

/* is it an index name */
check (33):
xnm:
	if header.type = 10
	then do;
		min_index = max (min_index, 0);	/*[4.2-7]*/
		max_index = min (max_index, index_name.max);
		go to success;
	     end;
	go to fail;

/* no more than 2 afters in a perform statement */

check (34):
ecnt:
	if end_stmt.e = 3
	then go to success;
	go to fail;				/* is item a declarative section name reference */
						/* and is it a random processing section */



check (35):
descnmra:
	if header.type = 18 & proc_def.section_name	/*[3.0-8]*/
	then go to success;
	go to fail;				/* is it an sa area name */
check (36):
saanm:
	if header.type = 15
	then go to success;
	go to fail;				/* is it an  01 data name under sa */
check (37):
said:
	if header.type = 9 & data_name.level_01 & data_name.exp_redefining
	then go to success;
	go to fail;

/* is file not sequential organization */

check (38):
notseqfl:
	if fd_token.file_no ^= 0
	then do;
		file_number = fd_token.file_no;
		call cobol_read_ft_ (file_number, ft_ptr);
	     end;
	else go to fail;

	if organization ^= 1 & organization ^= 5
	then go to success;				/*[3.0-2]*/
	go to fail;

/* is it end cobol statement */
check (39):
endcob:
	if header.type = 1 & reserved_word.end_cobol = "1"b
	then go to success;
	go to fail;				/* was previous eos a special case */


check (40):
preosp:
	if end_stmt.verb = 12 & reserved_word.imper_verb = "0"b
	then go to success;
	go to fail;				/* is verb an imperative verb */
check (41):
impvrb:						/*[5.3-2]*/
	if data_name.type = 91			/* suppress */
						/*[5.3-2]*/
	then go to success;				/*[5.3-2]*/
	else if reserved_word.type = 1		/*[5.3-2]*/
	then if reserved_word.verb			/*[5.3-2]*/
	     then go to success;			/*[5.3-2]*/
	     else if reserved_word.key = 500		/* evaluate */
						/*[5.3-2]*/
	     then go to success;			/*[5.3-2]*/
	     else ;				/*[5.3-2]*/
	else ;
	go to fail;

/* are records fixed length */



check (42):
varsiz:
	if savitmptr -> fd_token.file_no = 0
	then go to fail;

	file_number = savitmptr -> fd_token.file_no;
	call cobol_read_ft_ (file_number, ft_ptr);

	if file_table.variable = "0"b
	then go to success;
	go to fail;

/* is item file no not equal to saved file no */
check (43):
fileno:
	if header.type = 9
	then if data_name.file_num ^= savitmptr -> data_name.file_num
	     then goto success;
	     else goto fail;
	else if data_name.file_num ^= savitmptr -> fd_token.file_no
	then go to success;
	go to fail;				/* is saved item filename isn sequential mode */



check (44):
sqfl:						/*	if savitmptr -> seqbit then go to success;
go to fail;	*/				/* is saved file in random access mode */
check (45):
rafl:
	if savitmptr -> fd_token.file_no ^= 0
	then do;
		file_number = savitmptr -> fd_token.file_no;
		call cobol_read_ft_ (file_number, ft_ptr);
	     end;
	else go to fail;

	if access = 2
	then go to success;
	go to fail;				/* is this item a record within the associated sort file */
check (46):
recnm:
	if header.type ^= 9
	then go to fail;

	sort_key = sort_in_info;

	do while ("1"b);
	     if sort_key = "00000"
	     then go to fail;

	     varrecaddr = sort_key;
	     call vardget;
	     srtrngptr = seqvarptr;

	     if (cursecnum > sstop) | (cursecnum < sstart) | (data_name.file_num ^= srtfilno)
	     then sort_key = sptr;
	     else go to success;
	end;

/* are we in an input sort range */
check (47):
inrng:
	if sv_isrbit
	then go to success;
	go to fail;

/* are we in an output sort range */
check (48):
outrng:
	if sv_osrbit
	then go to success;
	go to fail;

/* is this file the same as associated file in the sort statement */
check (49):
asfil:
	if header.type ^= 16
	then go to fail;

	sort_key = sort_out_info;

	do while ("1"b);
	     if sort_key = "00000"
	     then go to fail;

	     varrecaddr = sort_key;
	     call vardget;
	     srtrngptr = seqvarptr;

	     if (cursecnum > sstop) | (cursecnum < sstart) | (fd_token.file_no ^= srtfilno)
	     then sort_key = sptr;
	     else go to success;
	end;

/* is item not subscripted and not indexed */
/* but still has the occurs and indexed by clauses */
check (50):
srchid:
	if header.type = 9 & data_name.subscripted & data_name.indexed_by
	then go to success;
	else go to fail;				/* is item an integer type or is it usage is index */
check (51):
usornm:
	if header.type = 9 & (data_name.pic_integer | data_name.usage_index)
	then go to success;
	else go to fail;				/* does item have the key is clause */
check (52):
keylbl:
	if data_name.key_a | data_name.key_d
	then go to success;
	else go to fail;

/* is it a sequential file */



check (53):
seqfil:
	if fd_token.file_no = 0
	then go to fail;

	file_number = fd_token.file_no;
	call cobol_read_ft_ (file_number, ft_ptr);

/*[4.0-5]*/
	if organization = 1 | organization = 5
	then go to success;
	go to fail;

/* is it a one character integer without an operational sign */



check (54):
onechnosn:
	if data_name.item_length = 1 & data_name.pic_integer & ^data_name.item_signed
	then go to success;
	go to fail;

/* is saved file sequential or relative and does it have sequential access mode */

check (55):
sqrlsqac:
	if savitmptr -> data_name.file_num = 0
	then go to fail;

	file_number = savitmptr -> data_name.file_num;
	call cobol_read_ft_ (file_number, ft_ptr);

	if (organization = 1 | organization = 2) & (access < 2)
	then go to success;
	go to fail;

/* is it a mneemonic name */
check (56):
mnenm:
	if header.type = 17
	then go to success;
	go to fail;

/* does the file have an associated format 1 use procedure */

check (57):
useform1a:
	if savitmptr -> data_name.file_num = 0
	then go to fail;
	go to useform1;

/* is it  an index data item or
			is it  an elementary integer item */
check (58):
xint:
	if header.type = 9 & data_name.elementary & data_name.usage_index = "1"b
	then do;
		set_sop.int_lit = "1"b;
		set_sop.int_data = "1"b;
		go to success;
	     end;

	if header.type = 9 & data_name.elementary = "1"b & data_name.pic_integer = "1"b
	then do;
		set_sop.int_lit = "1"b;
		set_sop.int_data = "1"b;
		set_sop.ind_data = "1"b;
		go to success;
	     end;
	go to fail;				/* is it a positive integer literal  */



check (59):
posint:
	if header.type = 2 & numeric_lit.integral = "1"b & numeric_lit.sign ^= "-"
	then go to success;
	go to fail;				/* is it a sortt file */



check (60):
srtfil:
	if header.type = 16
	then go to success;
	go to fail;				/* is itt a data_name within the saved file */


check (61):
dninfl:
	if header.type = 9 & data_name.file_num = savitmptr -> fd_token.file_no
	then go to success;
	go to fail;				/* does item have usage is display clause */

check (62):
usisds:
	if data_name.non_elementary | (data_name.elementary & data_name.display)
	then go to success;
	go to fail;				/* is item fixed length with usage is display clause */
check (63):
flusisds:
	if data_name.display & ^data_name.variable_length
	then go to success;
	go to fail;				/* is item an elementary data item with usage is display clause
			and with no edit symbols */
check (64):
elneds:
	if data_name.elementary & data_name.display & ^data_name.numeric_edited & ^data_name.alphanum_edited
	     & ^data_name.alphabetic_edited
	then go to success;
	go to fail;				/* is itt an elementary numeric integer data item */
check (65):
elnuindi:
	if data_name.elementary & data_name.numeric & data_name.pic_integer
	then go to success;
	go to fail;				/* is it an elementary numeric item */



check (66):
elnuit:
	if header.type = 9 & data_name.elementary & data_name.numeric
	then go to success;
	go to fail;				/* is it a file name */



check (67):
file:
	if header.type = 12 | header.type = 16
	then go to success;
	go to fail;				/* is it an alphanumeric data item */
check (68):
andait:
	if data_name.alphanum | data_name.alphanum_edited
	then go to success;
	go to fail;				/* is contents of e counter greater than 0 ? */
check (69):
egrze:
	if end_stmt.e > 0
	then go to success;
	go to fail;				/* is item a non_sort record name */



check (70):
nsrecnm:
	if header.type = 9 & data_name.file_section & data_name.file_num ^= 0 & data_name.level_01
	then go to check70a;
	go to fail;
check70a:
	file_number = data_name.file_num;
	call cobol_read_ft_ (file_number, ft_ptr);

	file_org = file_table.organization;

	if ^sort_file
	then go to success;
	go to fail;				/* does saved item have linage clause */
						/* not to be executed until common is all set */
check (71):
linage:
	if file_table.linage
	then go to success;

	go to fail;



/* is saved item a mass storage file */
/*  the filetable is already in core from doing check 70  */
/*  used by the write verb  */
check (72):
msfile:						/*  is saved item a mass storage file with other than sequential organization  */
						/*is file not stream organization */
	if organization ^= 1 & organization ^= 5
	then go to success;				/*[3.0-2]*/
	go to fail;

/* is item an unsubscripted data name excluding index data names */



check (73):
undana:
	if header.type = 9 & ^data_name.subscripted & ^data_name.usage_index
	then go to success;
	else go to fail;

/* is item a subscripted data name excluding  index data names */

check (74):
sudana:
	if header.type = 9 & data_name.subscripted & ^data_name.usage_index
	then go to success;
	else go to fail;

/* is subcnt less than level of occurs in the saved ident */
check (75):
ieqlvl:						/*[4.0-3]*/
	if subcnt = 0				/*[4.0-3]*/
	then do;
		if header.type = 2			/*[4.0-3]*/
		then format = 0;			/*[4.0-3]*/
		else if header.type = 10		/*[4.0-3]*/
		then format = 2;			/*[4.0-3]*/
		else format = 1;			/*[4.0-3]*/
		err = 0;				/*[4.0-3]*/
	     end;					/*[4.0-3]*/
	else do;
		if header.type ^= 1			/*[4.0-3]*/
		then /*[4.0-3]*/
		     if format = 0			/*[4.0-3]*/
		     then if header.type = 2		/*[4.0-3]*/
			then ;			/*[4.0-3]*/
			else if header.type = 10	/*[4.0-3]*/
			then format = 2;		/*[4.0-3]*/
			else format = 1;		/*[4.0-3]*/
		     else if format = 1		/*[4.0-3]*/
		     then if header.type = 10		/*[4.0-3]*/
			then err = 167;		/*[4.0-3]*/
			else ;			/*[4.0-3]*/
		     else if header.type ^= 10 & header.type ^= 2
						/*[4.0-3]*/
		     then err = 167;		/*[4.0-3]*/
		     else ;			/*[4.0-3]*/
	     end;

	if subcnt < dimensions
	then go to success;
	go to fail;				/* is the saved ident indexed at this level */
check (76):
indexed:
	if indexedno (subcnt) ^= 0
	then do;
		sub_loc = sub_loc + 1;
		go to success;
	     end;
	go to fail;				/* is index no of curent item = to
			index no of saved item */
check (77):
indeqind:
	if index_name.index_no = indexedno (subcnt)
	then go to success;
	go to fail;				/* is item a positive integer whose value is greater than zero */
check (78):
pigz:
	call pigz_sub;

	if pigz_res = 0
	then go to success;
	else go to fail;

pigz_sub:
     proc;

	pigz_res = 0;
	litcnt = 1;

	if header.type = 2 & numeric_lit.integral & numeric_lit.sign ^= "-"
	then do while ("1"b);

		if substr (numeric_lit.literal, litcnt, 1) ^= "0"
		then return;

		if litcnt = numeric_lit.places
		then do;
			pigz_res = 1;
			return;
		     end;

		litcnt = litcnt + 1;

	     end;

	pigz_res = 1;

     end;

/* is item an unsigned integer */
check (79):
unsint:
	if header.type = 2 & numeric_lit.integral & numeric_lit.sign = " "
	then go to success;
	go to fail;				/* is item an arithemetic operator */
check (80):
arop:
	if header.type = 1 & reserved_word.arith_op
	then go to success;
	go to fail;				/* is item a single character non numeric literal or a fig con */
check (81):
examlitid:
	if header.type = 9 & data_name.display & data_name.item_length = 1
	then go to check81a;

	if header.type = 1 & reserved_word.figcon
	then go to check81b;

	if header.type = 3 & alphanum_lit.lit_size = 1
	then go to check81d;

	if header.type = 2 & numeric_lit.places = 1 & numeric_lit.sign = " "
	then go to check81c;
	go to fail;

check81a:
	if savitmptr -> data_name.numeric = data_name.numeric
	then go to success;
	go to fail;

check81b:
	if savitmptr -> data_name.numeric & reserved_word.jump_index ^= 1
	then go to fail;
	go to success;

check81c:
	if savitmptr -> data_name.numeric
	then go to success;
	go to fail;

check81d:
	if ^savitmptr -> data_name.numeric
	then go to success;
	go to fail;				/* is item elementary or redefined */

check (82):
elemred:
	if data_name.elementary | data_name.s_of_rdf | data_name.o_of_rdf
	then go to success;
	go to fail;

/* is saved file indexed or relative and is access random or dynamic */

check (83):
ixrlrady:
	if savitmptr -> data_name.file_num = 0
	then go to fail;

	if (organization = 2 | organization = 3) & (access = 2 | access = 3)
	then go to success;
	go to fail;

/* does program contain sections */
check (84):
secsw:						/*[4.4-6]*/
	if fixed_common.report
	then go to success;
	if secswitch = 1
	then go to success;
	go to fail;				/* does imperative switch = 0 */


check (85):
is_rel:						/*[5.3-2]*/
	if reserved_word.type ^= 1
	then go to fail;

/*[5.3-2]*/
	ky = reserved_word.key;			/*[5.3-2]*/
	if ky = 130 | ky = 118 | ky = 113 | ky = 117 | ky = 141 | ky = 127 | ky = 180 | ky = 181 | ky = 74
						/*[5.3-2]*/
	then go to success;

/*  not,is,=,exceeds,unequal,positive,negative,zero,numeric,alphabetic */

	go to fail;				/* is there no previous sections within declaratives */



check (86):
deswz:
	if debugsw = 0
	then go to success;
	go to fail;				/* is it a cdname */
check (87):
cdname:
	if header.type = 13
	then go to success;
	go to fail;				/* is it a data name not in report section */
check (88):
dana:
	if header.type = 9 & data_name.report_section = "0"b
	then go to success;
	go to fail;

/* is there a format 1 use verb associated with this verb */



check (89):
useform1b:
	if savitmptr -> fd_token.file_no = 0
	then go to fail;

	file_number = savitmptr -> fd_token.file_no;
	call cobol_read_ft_ (file_number, ft_ptr);

	go to useform1;

/*is declarative switch = 1 */

check (90):
deswon:
	if decswitch = 1
	then go to success;
	go to fail;

/* is saved file sequential  or was NEXT option used */

check (91):
seqnext:
	if end_stmt.d
	then go to success;

	if savitmptr -> fd_token.file_no = 0
	then go to fail;

	file_number = savitmptr -> fd_token.file_no;
	call cobol_read_ft_ (file_number, ft_ptr);

	if access < 2
	then go to success;
	go to fail;

/* is it an unsubscripted elementary data name */

check (92):
unelnudn:
	if header.type = 9 & ^data_name.subscripted & data_name.elementary & ^data_name.constant_section
	     & data_name.numeric
	then go to success;
	go to fail;				/* is it a statement termiator */
check (93):
sterm:
	if header.type = 1 & reserved_word.terminator
	then go to success;

	if header.type = 7
	then go to success;
	go to fail;				/* is it a group item or does it have usage is display */



check (94):
usagid:
	if header.type = 9 & (data_name.non_elementary | data_name.display)
	then do;
		repcsbit = data_name.constant_section;	/*[4.1-7]*/
		prev_diag.line_num = header.line;	/*[4.1-7]*/
		prev_diag.column_num = header.column;
		go to success;
	     end;
	go to fail;

/*  is item an elementary item with usage is display clause */
check (95):
eldis:
	if header.type = 9 & data_name.display & data_name.elementary
	then go to success;
	go to fail;				/* was previous eos a paragraph definition */



check (96):
preospn:
	if end_stmt.verb = 55
	then go to success;
	go to fail;				/* are both saved and current item elementary numeric */
						/* and are both signed or unsigned */
						/* and is left of dp in saved item le than current item*/
						/* and is right of dp in saved item le than current item */
						/* and does saved item not share core with current item */
check (97):
nues:
	if saveitem.type = 2
	then if data_name.numeric_edited
	     then if savitmptr -> numeric_lit.places_left <= data_name.places_left
		     & savitmptr -> numeric_lit.places_right <= data_name.places_right
		then go to success;
		else go to fail;
	     else if data_name.alphanum | data_name.alphanum_edited
	     then if savitmptr -> numeric_lit.sign = " " & savitmptr -> numeric_lit.integral
		     & savitmptr -> numeric_lit.places_left <= data_name.places_left
		then go to success;
		else go to fail;
	     else if data_name.elementary & data_name.numeric
		& (data_name.item_signed | (^data_name.item_signed & savitmptr -> numeric_lit.sign = " "))
		& savitmptr -> numeric_lit.places_left <= data_name.places_left
		& savitmptr -> numeric_lit.places_right <= data_name.places_right
	     then go to success;
	     else go to fail;
	else if saveitem.type = 1 & savitmptr -> reserved_word.key = 192
						/*SPACES*/
	then go to fail;
	else if saveitem.type = 1 & savitmptr -> reserved_word.figcon
	then if data_name.numeric | ^data_name.alphabetic
	     then go to success;
	     else go to fail;
	else if saveitem.type = 3
	then if data_name.elementary & (data_name.numeric | data_name.numeric_edited)
		& savitmptr -> alphanum_lit.lit_size <= data_name.places_left
	     then go to success;
	     else go to fail;
	else if data_name.elementary & savitmptr -> data_name.elementary & data_name.numeric
	     & savitmptr -> data_name.numeric
	     & ((data_name.item_signed & savitmptr -> data_name.item_signed)
	     | (^data_name.item_signed & ^savitmptr -> data_name.item_signed))
	     & savitmptr -> data_name.places_left <= data_name.places_left
	     & savitmptr -> data_name.places_right <= data_name.places_right
	then do;
		call overlap;
		if res
		then go to success;
		else go to fail;
	     end;
	go to fail;

overlap:
     proc;

	if data_name.type ^= 9 | saveitem.type ^= 9
	then do;
		res = "1"b;
		return;
	     end;

	if data_name.seg_num ^= savitmptr -> data_name.seg_num | data_name.def_line = savitmptr -> data_name.def_line
	then do;
		res = "1"b;
		return;
	     end;

/*[3.0-11]*/
/*[]*/
	if data_name.linkage_section | savitmptr -> data_name.linkage_section
						/*[]*/
	then do;
		if data_name.linkage_section & savitmptr -> data_name.linkage_section
						/*[]*/
		then do;
			if data_name.linkage ^= savitmptr -> data_name.linkage
						/*[]*/
			then do;
				res = "1"b;	/*[]*/
				return;		/*[]*/
			     end;			/*[]*/
		     end;				/*[]*/
		else do;
			res = "1"b;		/*[]*/
			return;			/*[]*/
		     end;				/*[]*/
	     end;					/*[3.0-11]*/

	call get_pos (addr_record, O1_ptr);
	call get_pos (savitmptr, O2_ptr);

	if (O1.o1 < O2.o2 & O1.o1 + O1.l1 <= O2.o2) | O2.o2 + O2.l2 <= O1.o1
	then res = "1"b;
	else res = "0"b;

get_pos:
     proc (p, q);

declare	(p, q)		ptr;

declare	1 O		based (q),
	  2 o		fixed bin,
	  2 l		fixed bin;

	O.o = p -> data_name.offset;
	O.o = O.o + O.o;

	if p -> data_name.ascii_packed_dec_h
	then do;
		if p -> data_name.bit_offset
		then O.o = O.o + 1;			/* comp-8 */

		O.l = p -> data_name.places_left + p -> data_name.places_right;

		if p -> data_name.item_signed
		then O.l = O.l + 1;
	     end;
	else do;
		O.l = p -> data_name.item_length;
		O.l = O.l + O.l;
	     end;
     end;
     end;						/* are both saved and current item alphanumeic */
						/*and is saved item le current item */
						/* and does saved item not share core with current item */
check (98):
anes:
	if saveitem.type = 2
	then go to fail;
	else if saveitem.type = 1 & savitmptr -> reserved_word.figcon
	then if data_name.alphanum | data_name.non_elementary | data_name.alphanum_edited
	     then go to success;
	     else if savitmptr -> reserved_word.key = 180 /*ZERO*/
	     then go to fail;
	     else if data_name.alphabetic
	     then go to success;
	     else go to fail;
	else if saveitem.type = 3
	then if (data_name.alphanum | data_name.alphanum_edited)
		& data_name.item_length >= savitmptr -> alphanum_lit.lit_size
	     then go to success;
	     else if data_name.non_elementary & data_name.item_length >= savitmptr -> alphanum_lit.lit_size
	     then go to success;
	     else go to fail;
	else if savitmptr -> data_name.numeric_edited
	then if (data_name.alphanum | data_name.alphanum_edited)
		& data_name.item_length >= savitmptr -> data_name.item_length
	     then do;
		     call overlap;
		     if res
		     then go to success;
		     else go to fail;
		end;
	     else go to fail;
	else if (data_name.alphanum | data_name.alphanum_edited)
	     & (savitmptr -> data_name.alphanum | savitmptr -> data_name.alphanum_edited
	     | savitmptr -> data_name.alphabetic) & data_name.item_length >= savitmptr -> data_name.item_length
	then do;
		call overlap;
		if res
		then go to success;
		else go to fail;
	     end;
	go to fail;

/* is either saved item or current item a group item */
check (99):
group:
	if data_name.non_elementary
	then go to success;

	else if saveitem.type = 2
	then go to fail;

	else if saveitem.type = 9 & savitmptr -> data_name.non_elementary
	then go to success;
	go to fail;

/* is sending item size le receiving size + 1 */
check (100):
sler:
	if saveitem.type = 2
	then if savitmptr -> numeric_lit.places <= data_name.item_length
	     then go to success;
	     else go to fail;
	else if saveitem.type = 3
	then if savitmptr -> alphanum_lit.lit_size <= data_name.item_length
	     then go to success;
	     else go to fail;
	else if savitmptr -> data_name.item_length <= data_name.item_length
	then go to success;
	go to fail;

/* does sending item not overlap receiving item */

check (101):
snor:
	if saveitem.type = 3 | saveitem.type = 2
	then go to success;
	else do;
		call overlap;
		if res
		then go to success;
		else go to fail;
	     end;

/* is it alphaanumeric or alphanumeric_edited */

check (102):
an:
	if data_name.alphanum | data_name.alphanum_edited
	then go to success;
	go to fail;

/* does sending item not have any digits to right of dp */
check (103):
sndrdp:
	if saveitem.type = 3 | (saveitem.type = 2 & savitmptr -> numeric_lit.integral)
	     | (savitmptr -> data_name.numeric_edited | savitmptr -> data_name.places_right <= 0)
	then go to success;
	go to fail;

/* is sending item not signed */
check (104):
snos:
	if saveitem.type = 3 | ^(savitmptr -> data_name.item_signed)
	then go to success;
	go to fail;

/* is it alphabetic */
check (105):
alph:
	if data_name.alphabetic | data_name.alphabetic_edited
	then go to success;
	go to fail;

/* is sending item not numeric */
check (106):
snon:						/*[4.2-5]*/
	if saveitem.type = 9			/*[4.2-5]*/
	then do;
		if savitmptr -> data_name.numeric	/*[4.2-5]*/
		then do;
			call diag (151);		/*[4.2-5]*/
			go to fail;		/*[4.2-5]*/
		     end;

/*[4.2-5]*/
		if savitmptr -> data_name.numeric_edited/*[4.2-5]*/
		then do;
			call diag (136);		/*[4.2-5]*/
			go to fail;		/*[4.2-5]*/
		     end;

/*[4.2-5]*/
		go to success;			/*[4.2-5]*/
	     end;

/*[4.2-5]*/
	if saveitem.type = 3 | saveitem.type = 1
	then go to success;

/*[4.2-5]*/
	call diag (151);

	go to fail;

/* is sending field not alphabetic */
check (107):
snal:
	if saveitem.type = 3 | saveitem.type = 2 | (saveitem.type = 9 & ^(savitmptr -> data_name.alphabetic))
	then go to success;
	go to fail;

/* is sending field not alphanumeric edited */
check (108):
snae:
	if saveitem.type = 3 | saveitem.type = 2 | ^(savitmptr -> data_name.alphanum_edited)
	then go to success;
	go to fail;

/* is sending field not numeric edited */
check (109):
snne:
	if saveitem.type = 3
	then go to success;				/*  sending field is alphanumeric literal */

	if saveitem.type = 2
	then go to success;

	if ^savitmptr -> data_name.numeric_edited
	then go to success;
	go to fail;				/* is sending item alphanumeric */
check (110):
san:
	if saveitem.type = 2
	then go to fail;

	if saveitem.type = 3
	then go to success;				/* sending field is alphanumeric literal */

	if savitmptr -> data_name.alphanum
	then go to success;
	go to fail;				/* is sending right of dp le receiving right of dp */
check (111):
ritdep:
	if saveitem.type = 2
	then go to check111a;

	if savitmptr -> data_name.places_right <= data_name.places_right
	then go to success;
	go to fail;

check111a:
	if savitmptr -> numeric_lit.places_right <= data_name.places_right
	then go to success;
	go to fail;				/* is sending left of dp le receiving lift of dp */
check (112):
lefdep:
	if saveitem.type = 2
	then go to check112a;

	if savitmptr -> data_name.places_left <= data_name.places_left
	then go to success;
	go to fail;

check112a:
	if savitmptr -> numeric_lit.places_left <= data_name.places_left
	then go to success;
	go to fail;				/* is sending field signed and receiveng field unsigned */
check (113):
stun:
	if saveitem.type = 2
	then go to check113a;			/* numeric literal */

	if savitmptr -> data_name.item_signed & ^data_name.item_signed
	then go to success;
	go to fail;

check113a:					/* numeric literal */
	if savitmptr -> numeric_lit.sign ^= " " & ^data_name.item_signed
	then go to success;
	go to fail;				/* is sending item total size le left of dp redeiving field */
check (114):
slelef:
	if (saveitem.type = 3 & savitmptr -> alphanum_lit.lit_size <= data_name.places_left)
	     | (saveitem.type = 9 & savitmptr -> data_name.item_length <= data_name.places_left)
	then go to success;
	go to fail;

/* is it end declaratives */


check (115):
enddec:						/*[5.2-1]*/
	if header.type = 1 & reserved_word.key = 98 /*[5.2-1]*/ & reserved_word.end_dec = "1"b
	then do;
		end_decl_bit = "1"b;
		go to success;
	     end;
	go to fail;				/* is item alterable */

check (116):
edalit:
	if header.type = 9 & data_name.constant_section = "0"b
	then go to success;
	go to fail;				/* is it an alterable elementary numeric item */
check (117):
alelnuitm:
	if header.type = 9 & data_name.constant_section = "0"b & data_name.elementary = "1"b & data_name.numeric = "1"b
	then go to success;
	go to fail;				/* is it an integer */
check (118):
elnuint:
	if header.type = 2 & numeric_lit.integral
	then go to success;
	go to fail;				/*  is it an elementary numeric data name and an integer */
check (119):
elnudnint:
	if header.type = 9 & data_name.elementary & data_name.pic_integer
	then go to success;
	go to fail;				/* is it an edited or non edited alterable
			elementary numeric item */
check (120):
edalelnue:
	if header.type = 9 & ^data_name.constant_section & data_name.elementary
	     & (data_name.numeric | data_name.numeric_edited)
	then go to success;
	go to fail;				/* is curerent item file number not equal to saved item file number */

check (121):
filno:
	if data_name.file_num ^= savitmptr -> data_name.file_num
	then go to success;
	go to fail;				/* is item alphabetic or alphanumeric */
check (122):
alphoral:
	if data_name.alphanum | data_name.alphabetic
	then go to success;
	go to fail;				/* is item an arithmetic operator or right paren */
check (123):
aroprp:
	if header.type = 1 & reserved_word.arith_op
	then go to success;

	if header.type = 1 & reserved_word.key = 188
	then go to success;
	go to fail;				/* is item a relation operator */

check (124):
relop:
	if fixed_common.comp_level < "3"
	then do;
		if header.type = 1 & reserved_word.rel_op
		then do;
			if reserved_word.end_dec
			then call lev_diag (10);
			go to success;
		     end;

	     end;
	else do;
		if header.type = 1 & reserved_word.rel_op
		then go to success;
	     end;

	go to fail;				/* is token res word positive or negative or zero */
check (125):
pnz:
	if header.type = 1 & reserved_word.key = 141 | reserved_word.key = 127 | reserved_word.key = 180
	then go to success;
	go to fail;				/* is subject not = 0 --- do we have a subject present */
check (126):
is_sub_opt:
	if SUBJ_REQ
	then go to fail;
	else go to success;

/* is item on stack numeric */
check (127):					/* sign condition test */
numstak:						/*[4.2-8]*/
	if op.loc = null ()
	then go to success;

/*[4.2-8]*/
	if op.loc -> data_name.type ^= 9
	then go to fail;

/*[4.2-8]*/
	if op.loc -> data_name.non_elementary
	then go to fail;

/*[4.2-8]*/
	if ^op.loc -> data_name.numeric
	then go to fail;

/*[4.2-8]*/
	go to success;				/* is item on stack not numerical */
check (128):					/* alphabetic class condition */
notnumstk:					/*[4.2-8]*/
	if op.loc = null ()
	then go to fail;

/*[4.2-8]*/
	if op.loc -> data_name.type ^= 9
	then go to fail;

/*[4.2-8]*/
	if op.loc -> data_name.elementary		/*[4.2-8]*/
	then if ^op.loc -> data_name.display		/*[4.2-8]*/
	     then go to fail;			/*[4.2-8]*/
	     else if op.loc -> data_name.numeric	/*[4.2-8]*/
	     then go to fail;

/*[4.2-8]*/
	go to success;				/* is item on stack not alphabetic */
check (129):					/* numeric condition test */
notalpstk:					/*[4.2-8]*/
	if op.loc = null ()
	then go to fail;

/*[4.2-8]*/
	if op.loc -> data_name.type ^= 9
	then go to fail;

/*[4.2-8]*/
	if op.loc -> data_name.elementary		/*[4.2-8]*/
	then if ^op.loc -> data_name.display		/*[4.2-8]*/
	     then go to fail;			/*[4.2-8]*/
	     else if op.loc -> data_name.alphabetic	/*[4.2-8]*/
	     then go to fail;

/*[4.2-8]*/
	go to success;				/* is arithmetic stack = 0 */
check (130):
zerstk:
	if assub = 1 | assub = 0
	then go to success;
	go to fail;				/* does item on arithmetic stack = left parenthesis */
check (131):
lefparstk:
	if assub = 0
	then go to fail;
	if astack.lefpar (assub)
	then go to success;
	else go to fail;				/* is the logical stack = ( and is bit logical = 0   */
check (132):
logbitstk:
	if cssub = 0
	then go to fail;

	if cstack.leftpar (cssub) & ^cstack.logical (cssub)
	then go to success;
	go to fail;				/* is logical stack = ( */
check (133):
logstk:
	if cstack.leftpar (cssub)
	then go to success;
	go to fail;				/* is item a status switch condition name */
check (134):
sscondnm:
	if mnemonic_name.type = 17 & mnemonic_name.class.switch_condition
	then go to success;

	go to fail;

/* to be done later */

/* are the arguments of the relation compatible */
check (135):
argscomp:
	go to success;				/* is item in active logical a left parenthesis */
check (136):
actloglp:
	if act_log.leftpar
	then go to success;
	go to fail;				/* is top of stack a left parenthesis */
check (137):
lptopstk:
	if cstack.leftpar (cssub)
	then go to success;
	go to fail;

/* is item an unsubscripted index data name */

check (138):
unxdnm:
	if header.type = 9 & ^data_name.subscripted & data_name.usage_index
	then go to success;
	go to fail;				/* can we expect another else or a period at this point */
check (139):
is_imp:						/*[5.3-2]*/
	if ST.cond (nest_lev + 1)
	then go to fail;
	else go to success;

/* are the subscripts compatible */
check (140):
daib:
	if data_name_bit ^= index_name_bit
	then go to success;
	go to fail;


check (141):
	go to fail;				/* NOT USED */
						/* NOT USED */


check (142):
	go to fail;				/* NOT USED */
						/* NOT USED */

/*  is present file number not equal to saved file number  */

check (143):
filnefil:
	if data_name.file_num ^= savitmptr -> data_name.file_num
	then go to success;
	go to fail;

check (144):
indxfile:
	if data_name.file_num ^= 0
	then do;
		file_number = data_name.file_num;
		call cobol_read_ft_ (file_number, ft_ptr);
	     end;
	else go to fail;

	if organization = 3
	then go to success;
	go to fail;

check (145):
gotod:						/*  are we processing a go to depending in if statement */
	if gotodep
	then go to success;
	go to fail;				/*  is the justified right bit not set */
check (146):
njustr:
	if ^data_name.just_right
	then go to success;
	go to fail;

/* is item alphanumeric */

check (147):
nonumdn:
	if header.type = 9 & data_name.alphanum
	then go to success;
	go to fail;				/* is receiving field alphanumeric edited */



check (148):
rae:
	if data_name.alphanum_edited
	then go to success;
	go to fail;

/* is item elementary alphabetic,alphanumeric or numeric edited or a group item */



check (149):
elaanne:
	if header.type = 9
	     & ((data_name.elementary & (data_name.numeric_edited | data_name.alphanum | data_name.alphabetic))
	     | data_name.non_elementary)
	then go to success;
	go to fail;

/* is item a subscribted idndex data name */



check (150):
suxdnm:
	if header.type = 9 & data_name.subscripted & data_name.usage_index
	then go to success;
	go to fail;				/* does declarative portion reference non-declarative portion or vice versa */

check (151):
decnondec:
	if decswitch = 1 | ^proc_def.declarative_proc
	then go to success;
	go to fail;

/* was there a procedure definition before the EXIT verb */



check (152):
ckprpnbit:
	if preospn_bit
	then go to success;
	go to fail;

/* is this MNEMONIC NAME an input device */



check (153):
indev:
	if mnemonic_name.iw_key = 3 | mnemonic_name.iw_key = 1
	then go to success;				/*[3.0-4]*/
	go to fail;

/* is MNEMONIC NAME input device */

check (154):
outdev:
	if mnemonic_name.iw_key = 3 | mnemonic_name.iw_key = 2
	then go to success;				/*[3.0-4]*/
	go to fail;

/* is file either relative or INDEXED */
/* is ACCESS either SEQUENTIAL or DYNAMIC */
/* used for START verb */

check (155):
ixrlsqdy:
	if fd_token.file_no ^= 0
	then do;
		file_number = fd_token.file_no;
		call cobol_read_ft_ (file_number, ft_ptr);
	     end;
	else go to fail;

	if (organization = 2 & relative_key) | organization = 3
	then if access < 2 | access = 3
	     then go to success;
	go to fail;

/* is file ORGANIZATION RELATIVE */
/* used for START verb */
/* buffer already has record from common */

check (156):
relfile:
	if organization = 2
	then go to success;
	go to fail;

/* is ITEM NAME & ADDRESS same as info in KEY NAME in SELECT clause */
/* FILE TABLE already in core */
/* processing START verb */

check (157):
keyiskey:
	if r_key_info = "00000"
	then go to fail;

	varrecaddr = r_key_info;
	call vardget;
	fkey_ptr = seqvarptr;

	if substr (data_name.name, 1, data_name.name_size) = substr (fkname, 1, file_key.fkname_size)
	     & data_name.seg_num = fkseg_num & data_name.offset = fkoffset
	then go to success;
	go to fail;

/* is ADDRESS same as FILE KEY in COMMON */
/* FILE TABLE already in core */
/* processing START verb */

check (158):					/*[3.0-15]*/
adrisadr:						/*[]*/
	if alternate_keys = 0			/*[]*/
	then if r_key_info = "00000"			/*[]*/
	     then go to fail;			/*[]*/
	     else ;				/*[]*/
	else if alt_key_info = "00000"		/*[]*/
	then go to fail;				/*[]*/
						/*[]*/
	file_desc_1_ptr = addrel (cobol_$con_end_ptr, -(file_desc_1_offset - 1));
						/*[]*/
						/*[]*/
	if header.type = 9 /*[]*/ & /*[]*/ (data_name.file_num = file_table.file_no | alternate_keys = 0)
						/*[]*/
	then do;					/*[]*/
		if get_rel_offset (data_name.offset) = file_desc_1.prime_key.offset
						/*[]*/
		then do;				/*[]*/
			vfile_key = 511;		/* prime vfile_ key */
						/*[]*/
			go to success;		/*[]*/
		     end;				/*[]*/
		else do kc = 1 to alternate_keys;	/*[]*/
			if get_rel_offset (data_name.offset) = file_desc_1.alt_key (kc).offset
						/*[]*/
			then do;			/*[]*/
				vfile_key = kc;	/*[]*/
				go to success;	/*[]*/
			     end;			/*[]*/
		     end;				/*[]*/
	     end;					/*[]*/
						/*[]*/
						/*[]*/
	go to fail;


get_rel_offset:
     proc (abs_offset) /*[]*/ returns (fixed bin (24));

/*[]*/
dcl	abs_offset	fixed bin (24);		/*[]*/
dcl	rel_offset	fixed bin (24);		/*[]*/
						/*[]*/
	rel_offset = abs_offset - file_table.abs_record_offset;
						/*[]*/
	return (rel_offset);			/*[]*/
     end get_rel_offset;

check (159):
ssnm:
	if mnemonic_name.type = 17 & mnemonic_name.class.switch_name
	then go to success;

	go to fail;

check (160):					/* enter, routine name */
is_rout:
	if lang_num = 1
	then go to fail;

	if header.type = 8
	then go to success;

	go to fail;

check (161):
edick:
	if data_name.alphanum | data_name.alphabetic
	     | (data_name.numeric & data_name.places_left ^< 0 & data_name.places_right ^< 0)
	then go to success;
	go to fail;

check (162):
cktp25:
	if header.type = 25
	then go to success;
	go to fail;

/* range check for set verb format 1 */
check (163):
ckrng1:
	convtemp = 0;

	do ii = 1 to numeric_lit.places;
	     tempchar1 = substr (numeric_lit.literal, ii, 1);
	     convtemp = convtemp * 10 + fixed (unspec (tempchar1), 8) - convalue;
	end;

	if convtemp ^> savitmptr -> index_name.max
	then go to success;
	go to fail;

/* range check for set verb format 2 */
check (164):
ckrng2:
	convtemp = 0;

	do ii = 1 to numeric_lit.places;
	     tempchar1 = substr (numeric_lit.literal, ii, 1);
	     convtemp = convtemp * 10 + fixed (unspec (tempchar1), 8) - convalue;
	end;

	if convtemp < savitmptr -> index_name.max
	then go to success;
	go to fail;

/* check ssf or dof in file table - already in core from check(70) */

check (165):
ckrcpref:
	if (record_prefix = 2 | record_prefix = 3)
	then go to success;
	go to fail;

/* check to insure that the literal used for the program-id is less than 13 characters */



check (166):
cklit:
	if header.type = 3 & alphanum_lit.lit_size < 31
	then go to success;
	go to fail;

/* are both proc-names non-declaratives or both declaratives in same declarative section */

check (167):
ckdecpn:
	if ^proc_def.declarative_proc & ^(savitmptr -> proc_def.declarative_proc)
	then go to success;

	if (proc_def.declarative_proc & savitmptr -> proc_def.declarative_proc)
	     & (proc_def.section_num = savitmptr -> proc_def.section_num)
	then go to success;
	go to fail;

/* independent & non-independent segment checks for perform verb */
check (168):
cksegm:
	if secswitch = 0
	then go to success;
	if shprio > 99
	then go to fail;

	prio1 = fixed (unspec (savitmptr -> proc_def.priority), 16);

	if prio1 > 99
	then go to fail;

	prio2 = fixed (unspec (proc_def.priority), 16);

	if prio2 > 99
	then go to fail;
	if shprio > 49
	then go to check168a;
	if prio1 < 50 & prio2 < 50
	then go to success;
	if prio1 = prio2
	then go to success;
	go to fail;
check168a:
	if prio1 < 50 & prio2 < 50
	then go to success;

	if (prio1 = prio2) & (prio1 = shprio)
	then go to success;
	go to fail;

/* check for a nonzero numeric literal */
check (169):
nznumlit:
	if header.type = 2
	then do;
		litcnt = 1;

		do while ("1"b);

		     if substr (numeric_lit.literal, litcnt, 1) ^= "0"
		     then go to success;

		     if litcnt = numeric_lit.places
		     then go to fail;

		     litcnt = litcnt + 1;

		end;
	     end;

	go to fail;

/* check integer bit in saved identifier */
check (170):
ckintbit:
	if numeric_lit.integral
	then go to success;				/*[3.0-3]*/
	go to fail;

/* check segment number in declaratives */


check (171):
ckdsegnum:
	if perfprio < 50
	then go to success;
	go to fail;

/* is a use procedure already associated with this file */

check (172):
ckerrex:
	if end_stmt.a = "000"b & fd_token.file_no ^= 0
	then do;

		file_number = fd_token.file_no;
		call cobol_read_ft_ (file_number, ft_ptr);

		if error_exit = 0
		then go to success;
		else go to fail;

	     end;
	go to fail;

/* is a use procedure already associated with input */

check (173):
ckinput:
	if input_error_exit = 0
	then go to success;
	else go to fail;

/* is a use procedure already associated with output */

check (174):
ckoutput:
	if output_error_exit = 0
	then go to success;
	else go to fail;

/* is a use procedure already associated with i-o */

check (175):
ckio:
	if i_o_error_exit = 0
	then go to success;
	else go to fail;

/* is a use procedure already associated with extend */

check (176):
ckextend:
	if extend_error_exit = 0
	then go to success;
	else go to fail;

/* for delete and start verbs - does a use procedure exist */

check (177):
useformds:
	if error_exit ^= 0
	then go to success;
	if input_error_exit ^= 0
	then go to success;
	if output_error_exit ^= 0
	then go to success;
	if i_o_error_exit ^= 0
	then go to success;
	if extend_error_exit ^= 0
	then go to success;
	go to fail;

/* for read verb - does a use procedure exist */

check (178):
useformr:
	if error_exit ^= 0
	then go to success;
	if input_error_exit ^= 0
	then go to success;
	if i_o_error_exit ^= 0
	then go to success;
	go to fail;

/* for write and rewrite verbs - does a use procedure exist */

check (179):
useformrw:
	if error_exit ^= 0
	then go to success;
	if output_error_exit ^= 0
	then go to success;
	if i_o_error_exit ^= 0
	then go to success;
	if extend_error_exit ^= 0
	then go to success;
	go to fail;

/* is an lit < 32 chars for CALL */

check (180):
cklit1:
	if alphanum_lit.lit_size < 32
	then go to success;
	go to fail;

/* are we executing multics cobol compiler */

check (181):
mcobol:
	if compiler_id = 3
	then go to success;
	go to fail;

/* is an lit < 66 chars for CALL */

check (182):
cklit2:
	if alphanum_lit.lit_size < 66
	then go to success;
	go to fail;

/* is organization not stream */

check (183):
nstream:
	if header.type = 12
	then do;

		if fd_token.file_no ^= 0
		then do;

			file_number = fd_token.file_no;
			call cobol_read_ft_ (file_number, ft_ptr);

			if organization ^= 5
			then go to success;		/*[3.0-2]*/
			go to fail;

		     end;

	     end;
	go to fail;

/* is orgganization stream */

check (184):
stream:
	if fd_token.file_no = 0
	then go to fail;

	file_number = fd_token.file_no;
	call cobol_read_ft_ (file_number, ft_ptr);

	if organization = 5
	then go to success;				/*[3.0-2]*/
	go to fail;

/* is organization not stream */

check (185):
nstorg:
	if organization ^= 5
	then go to success;				/*[3.0-2]*/
	go to fail;

/* is item unsubscripted data name excluding index data names, and,
		is it elementary, numeric ,integer data item. */
check (186):
udneli:
	if header.type = 9 & ^data_name.subscripted & ^data_name.usage_index & data_name.elementary
	     & data_name.numeric & data_name.pic_integer
	then do;
		sub_loc = sub_loc + 1;
		go to success;
	     end;
	go to fail;

check (187):
cstst:
	if ^data_name.constant_section
	then go to success;
	else go to fail;

check (188):
altst:
	if header.type = 9 & data_name.elementary & data_name.numeric
	then go to success;
	else go to fail;

check (189):
edaltst:
	if header.type = 9 & data_name.elementary & (data_name.numeric | data_name.numeric_edited)
	then go to success;
	else go to fail;

check (190):
csstst:
	if ^cssavebit
	then go to success;
	else go to fail;

check (191):
altlegal:
	if declprocbit | ^proc_def.declarative_proc
	then go to success;
	else go to fail;

check (192):
lev_test:
	if lev_save = cssub
	then go to success;
	else go to fail;

check (193):
resword:						/*[4.2-6]*/
	oploc.line = reserved_word.line;		/*[4.2-6]*/
	oploc.col = reserved_word.column;

/*[4.2-6]*/
	if reserved_word.type = 1			/*[4.2-6]*/
	then go to success;				/*[4.2-6]*/
	else go to fail;

check (194):
type9:
	if header.type = 9
	then go to success;
	else go to fail;

check (195):
alphnm:						/* check for alphabet name token */
	if alphabet_name.type = 40
	then do;
		end_stmt.i = alphabet_name.iw_key;
		end_stmt.d = "10"b;
	     end;
	else go to fail;

	go to success;

check (196):
on_off:						/* test for ON or OFF */
	if reserved_word.type ^= 1
	then go to fail;

	key = reserved_word.key;

	if key = 134
	then end_stmt.c = "1"b;			/* is_word("ON") */
	else if key = 574
	then end_stmt.c = "0"b;			/* is_word("OFF") */
	else go to fail;

	end_stmt.a = "010"b;

	go to success;

acc_dev:
check (197):					/* test for accept device */
	if mnemonic_name.type = 17 & mnemonic_name.class.accept_device
	then go to success;

	go to fail;

disp_dev:
check (198):					/* test for display device */
	if mnemonic_name.type = 17 & mnemonic_name.class.display_device
	then go to success;

	go to fail;

prt_con:
check (199):					/* test for printer control */
	if mnemonic_name.type = 17 & mnemonic_name.class.printer_control
	then go to success;

	go to fail;

check (200):					/* enter, language name */
is_lang:
	lang_num = cobol_imp_word$lang_name (addr_record);

	if lang_num = 0
	then go to fail;

	go to success;

check (201):
amarg:
	if header.column < 12
	then go to success;
	go to fail;

check (202):
set_xint:
	if header.type = 9 & data_name.elementary
	then go to success;

	go to fail;

check (203):
set_pigz:
	call pigz_sub;

	if pigz_res = 0
	then go to success;

	go to fail;

check (204):
tst_xint:
	if data_name.usage_index
	then do;
		if set_sop.ind_data
		then do;
			call diag (280);
			go to fail;
		     end;
		go to success;
	     end;

	if data_name.pic_integer
	then do;
		if set_sop.int_data
		then do;
			call diag (281);
			go to fail;
		     end;

		go to success;
	     end;

	call diag (178);

	go to fail;

check (205):
tst_pigz:
	if set_sop.int_lit
	then do;
		call diag (282);
		go to fail;
	     end;

	go to success;

check (206):
is_user_word:
	if data_name.type = 9
	then go to success;

	go to fail;

check (207):
open_mode:
	if reserved_word.type = 1
	then do;
		if reserved_word.key = 115
		then op_mode = 1;			/* input */
		else if reserved_word.key = 137
		then op_mode = 2;			/* output */
		else if reserved_word.key = 119
		then op_mode = 3;			/* i-o */
		else if reserved_word.key = 216	/* extend */
						/*[4.4-8]*/
		then do;
			op_mode = 4;		/*[4.4-8]*/
			if fixed_common.comp_level < "3"
			then call lev_diag (39);	/*[4.4-8]*/
		     end;
		else go to fail;
		go to success;
	     end;

	go to fail;

check (208):
nlit:
	if header.type = 2
	then go to success;

	go to fail;

check (209):					/*[3.0-6]*/
pigz_by:						/*[3.0-6]*/
	litcnt = 1;				/*[3.0-6]*/

	if header.type = 2 /*[3.0-6]*/ & /*[3.0-6]*/ numeric_lit.integral
						/*[3.0-6]*/
	then do while ("1"b);			/*[3.0-6]*/

		if substr (numeric_lit.literal, litcnt, 1) ^= "0"
						/*[3.0-6]*/
		then do;
			if numeric_lit.sign = "-"	/*[3.0-6]*/
			then do;
				if fixed_common.comp_level < "5"
						/*[3.0-6]*/
				then call lev_diag (40);
						/*[3.0-6]*/
			     end;			/*[3.0-6]*/

			go to success;		/*[3.0-6]*/
		     end;				/*[3.0-6]*/

		if litcnt = numeric_lit.places
		then go to fail;			/*[3.0-6]*/

		litcnt = litcnt + 1;		/*[3.0-6]*/

	     end;					/*[3.0-6]*/

	go to fail;				/*[3.0-10]*/

/* the following proc is used by the action routines
			ieo means exclusive or
			set coperator.not to coperator.not eo lognot eo parameter
			clear lognot
			if param = 0 move use (true of active ) to tag field of coperator and go to second next inst
			if param not 0 then move use (false of active ) to tag field of coperator and go to next inst
			output the coperator
			clear operator
			return*/

/*   	if file device suffix printer */

check (210):					/*[3.0-14]*/
devptr:						/*[3.0-14]*/
	if savitmptr -> data_name.file_num = 0		/*[3.0-14]*/
	then goto fail;				/*[3.0-14]*/

	file_number = savitmptr -> data_name.file_num;	/*[3.0-14]*/
	call cobol_read_ft_ (file_number, ft_ptr);	/*[3.0-14]*/

	if file_table.device = 1
	then goto success;				/*[3.0-14]*/

	goto fail;				/*[3.0-14]*/



/*[3.0-16]*/
/* check for sequential file using savitmptr */

check (211):
seqstmfil:
	if savitmptr -> data_name.file_num = 0
	then go to fail;

	file_number = savitmptr -> data_name.file_num;
	call cobol_read_ft_ (file_number, ft_ptr);

	if organization = 1 | organization = 5
	then go to success;

	go to fail;

/*[4.0-1]*/
check (212):
cond_name:					/*[4.0-1]*/
	if reserved_word.section_header
	then go to success;
	else go to fail;

check (213):
pn_pres:						/*[4.0-4]*/
	if end_stmt.d = "00"b
	then go to success;
	else go to fail;

check (214):
debug:						/*[4.4-5]*/
	if fixed_common.debug & fixed_common.use_debug
	then go to success;				/*[4.4-5]*/
	if fixed_common.use_reporting			/*[4.4-5]*/
	then do while (addr_record -> reserved_word.column = 9999);
						/*[4.4-5]*/
		call SCAN;			/*[4.4-5]*/
	     end;

/*[5.1-2]*/
	LTP, last_wd_per = "1"b;			/*[4.4-5]*/
	if fixed_common.report
	then go to success;
	else go to fail;

check (215):
not_opt:						/*[5.3-2]*/
	if ST.not_opt (nest_lev)
	then go to success;
	else go to fail;

check (216):					/* check for figurative constant ZERO */
figzero:						/*[4.2-3]*/
	if reserved_word.type = 1 & reserved_word.key = 180
	then if fixed_common.comp_level < "3" & reserved_word.end_dec
	     then call lev_diag (154);
	     else /* do nothing */
		;
	else go to fail;

	go to success;

check (217):
noo:						/*[5.3-2]*/
	if reserved_word.type = 1			/*[5.3-2]*/
	then if reserved_word.key = 130 | reserved_word.key = 134 | reserved_word.key = 6
						/*[5.3-2]*/
	     then go to success;			/*[5.3-2]*/
	     else go to fail;			/*[5.3-2]*/
	else go to fail;








check (218):
is_cond:
	if iscond
	then go to success;
	else go to fail;

check (219):
period:						/*[4.4-2]*/
	if reserved_word.type = 1			/*[4.4-2]*/
	then if reserved_word.key = 189		/* . */
						/*[4.4-2]*/
	     then do;
		     last_wd_per = "1"b;

/*[4.4-2]*/
		     go to success;			/*[4.4-2]*/
		end;				/*[4.4-2]*/
	go to fail;

check (220):
nae:						/*[5.3-2]*/
	if reserved_word.type = 1			/*[5.3-2]*/
	then if reserved_word.key = 130 | reserved_word.key = 79 | reserved_word.key = 100
						/*not,at,eop */
						/*[5.3-2]*/
	     then go to success;			/*[5.3-2]*/
	     else go to fail;



/***********************************************:*****************************/
/*****		PLACE NEW CHECKS BEFORE THIS COMMENT		********/
/*****************************************************************************/

EQ:
     proc (tag1, tag2);

/*[4.4-5]*/
declare	(tag1, tag2)	fixed bin;

/*[5.1-1]*/
	if tag1 = 0
	then return;				/*[5.1-1]*/
	if tag2 = 0				/*[5.1-1]*/
	then do;
		tag2 = tag1;
		return;
	     end;					/*[5.1-1]*/
	else call out_equiv (tag1, tag2);

     end;

TEST:
     proc (tag, bool_fcn);

/*[4.4-5]*/
declare	tag		fixed bin,
	bool_fcn		bit (4);

/*[5.1-1]*/
	coperator.not = bool (coperator.not, lognot, bool_fcn);

/*[4.4-5]*/
	if tag = 0				/*[4.4-5]*/
	then tag, coperator.tag = assign_value ();	/*[4.4-5]*/
	else coperator.tag = tag;

	lognot = "0"b;
	unspec (opeos.i) = cop_c_bits;

	call emit_type_13 (coperator.op, coperator.tag);

	coperator_bits = "0"b;

     end;						/* the param is usually a tag name
				if param = 0 return to caller
				if not output a pseudo-procedure-definition
				with param as an operand
				move t zero to param return to caller */

DEF:
     proc (param);


dcl	param		fixed bin;

	if param = 0
	then return;

	dumprocname.type = 30;

	dumprocname.proc_num = param;
	seqvarptr = dpnptr;
	seqvarleng = dumprocname.size;

	call seqput;

	param = 0;

     end DEF;					/* the parameters are usually tag names or procedure names
				if paramerer 1 = 0 return to caller
				if paramerer w 2   0 move paramerer 1 to parameter 2
				and return to caller
				all othe cases output an equivalence operator with
				paramerer1 and parameter2 as opearands then return
				to caller */

out_equiv:
     proc (param1, param2);

dcl	param1		fixed bin;
dcl	param2		fixed bin;

/*[4.4-5]*/
	if param1 = param2
	then return;

	if param1 = 0 | param2 = 0
	then return;

	opeos.e = param1;
	opeos.h = param2;
	opeos.type = 31;
	seqvarptr = opeosptr;
	seqvarleng = opeos.size;

	call seqput;

	opeos.type = 19;				/* restore to eos type */

     end out_equiv;

/*output eos */

action (3):
	call seqputeos;
	go to ret;

/* after in use verb */
/* reel or unit in close verb  */
/* invalid present in delete statement */
/* repeated tallying phrase in INSPECT verb */

action (4):
	end_stmt.b = "1"b;
	go to ret;

/* for INVALID clear eos, move 3 to verb type in eos*/

action (5):
	end_stmt_bits = "0"b;
	end_stmt.verb = 3;
	go to ret;

action (6):					/*NOT USED*/
	go to ret;

/* filename is present in use verb and add 1 to filename counter */

action (7):
	end_stmt.d = "00"b;
	end_stmt.e = end_stmt.e + 1;
	go to ret;

/* count params after using */
/* count procedure names for go to depending */
/* count operands after to in move statement */
/* count TALLYINGS in inspect statement */
/* count operands of display statement  and set statement*?*/

action (8):
	end_stmt.e = end_stmt.e + 1;
	go to ret;

/* descending bit for sort */

action (9):
	end_stmt.b = "0"b;
	go to ret;				/* set leading bit in eos for examine verb */
						/* input is present in use verb */
						/* REMOVAL is present in CLOSE verb */
						/* RANDOM is present in SORT verb */

action (10):
	go to IOM (op_mode);

IOM (1):
	end_stmt.d = "00"b;
	go to ret;				/* input */

IOM (2):
	end_stmt.d = "01"b;
	go to ret;				/* output */

IOM (3):
	end_stmt.d = "10"b;
	go to ret;				/* i-o */

IOM (4):
	end_stmt.d = "11"b;
	go to ret;				/* extend */

action (11):
	current_line = current_line + op_mode + 1;

	go to new_inst;

action (12):
	current_line = current_line + file_org + 1;

	go to new_inst;

/* format 2 and no standard in use verb */

action (13):
	end_stmt.a = "001"b;
	end_stmt.c = "0"b;
	go to ret;

/* beginning in use verb */
/* LOCK is present in CLOSE verb */

action (14):
	end_stmt.f = "01"b;
	go to ret;				/* reel in use verb */

action (15):
	end_stmt.g = "01"b;
	go to ret;				/* file in use verb */
action (16):
	end_stmt.g = "10"b;
	go to ret;				/* unit in use verb */
action (17):
	end_stmt.g = "11"b;
	go to ret;				/* ending in use verb */

action (18):
	end_stmt.f = "10"b;
	go to ret;

/* format 4 in use verb */
/* BCD-1400 is present in SORT verb */

action (19):
	end_stmt.a = "011"b;
	go to ret;

/* standard in use verb */
/* repeated replacing phrase in INSPECT verb */

action (20):					/*  from is present in write verb */
	end_stmt.c = "1"b;
	go to ret;

/* using is present */
/* all iis present in search verb */
/* ASCII is present in SORT verb */

action (21):
	end_stmt.a = "001"b;
	go to ret;

/* for INSPECT  format 3   add rePLACINGS  */

action (22):
	end_stmt.a = "010"b;
	end_stmt.h = end_stmt.h + 1;
	if repcsbit
	then call DIAG (248);
	go to ret;

action (23):					/* enter */
	end_stmt.a = "000"b;
	end_stmt.e = 0;
	end_stmt.verb = 5;
	end_stmt.h = lang_num;
	go to action (3);

/* format 3 in use verb */
/* H-200 is present in SORT verb */

action (24):
	end_stmt.a = "010"b;
	go to ret;

/*  format 2 in use verb and standard present */

action (25):
	end_stmt.a = "001"b;
	end_stmt.c = "1"b;
	go to ret;

/* format 5 in use verb */
/* JIS in SORT verb */

action (26):
	end_stmt.a = "100"b;
	go to ret;

action (27):					/*[4.0-1]*/
	if reserved_word.key = 2
	then END_WORD = 1;				/* add */
						/*[4.0-1]*/
	else if reserved_word.key = 11
	then END_WORD = 17;				/* subtract */
						/*[4.0-1]*/
	else if reserved_word.key = 40
	then END_WORD = 3;				/* compute */
						/*[4.0-1]*/
	else if reserved_word.key = 10
	then END_WORD = 8;				/* multiply */
						/*[4.0-1]*/
	else if reserved_word.key = 9
	then END_WORD = 5;				/* divide */
	call NL;
	go to ret;

NL:
     proc;					/*[5.3-2]*/
	ST.option (nest_lev), ST.not_opt (nest_lev) = "0"b;
	call sav_lin_col;				/*[5.3-2]*/
	ST.end_wd (nest_lev) = END_WORD;

/*[4.0-1]*/
	call act87;
     end;

action (28):
	call act28;
	go to ret;

act28:
     proc;
	substr (addr (saveitem) -> itemsize, 1, header.size) = substr (head_ptr -> itemsize, 1, header.size);
     end;

/* save item and add 1 to operand count after giving in divide verb */

action (29):
	substr (addr (saveitem) -> itemsize, 1, header.size) = substr (head_ptr -> itemsize, 1, header.size);
	end_stmt.h = end_stmt.h + 1;
	go to ret;

/* set rounded bit in saved item */

action (30):
	savitmptr -> data_name.rounded = "1"b;
	go to ret;

/* output saved item save current item
			add 1 to operand count after giving for divide verb */

action (31):
	arg_1 = savitmptr;
	code_option = 31;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	substr (addr (saveitem) -> itemsize, 1, header.size) = substr (head_ptr -> itemsize, 1, header.size);
	go to ret;

/* output saved item in compute verb */

action (32):
	call act32;
	go to ret;

act32:
     proc;
	arg_1 = savitmptr;
	code_option = 32;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
     end;

/* compute the composite */

action (33):
	if header.type = 1				/* fig con */
	then ;
	else if header.type = 2			/* num lit */
	then do;

		if numeric_lit.places_left > end_stmt.i
		then end_stmt.i = numeric_lit.places_left;
		if numeric_lit.places_right > end_stmt.j
		then end_stmt.j = numeric_lit.places_right;

	     end;
	else do;

		if data_name.places_left > end_stmt.i
		then end_stmt.i = data_name.places_left;
		if data_name.places_right > end_stmt.j
		then end_stmt.j = data_name.places_right;
	     end;

	end_stmt.e = end_stmt.e + 1;

	go to ret;

/* compute the composite count arguments and save item */

action (34):
	end_stmt.h = end_stmt.h + 1;
	cssavebit = data_name.constant_section;

/*[4.1-7]*/
	prev_diag.line_num = header.line;		/*[4.1-7]*/
	prev_diag.column_num = header.column;

	call act28;
	go to ret;

/* set rounded bit in saved item for add verb */
action (35):
	savitmptr -> data_name.rounded = "1"b;
	go to ret;				/* add 1 to operand count
			output saved item
			save current item for add verb*/

action (36):
	arg_1 = savitmptr;
	code_option = 17;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	substr (sav_ptr -> itemsize, 1, header.size) = substr (addr_record -> itemsize, 1, header.size);
	go to ret;

/* program in exit verb  or on size error in compute verb output eos */
/* or at end in search verb */

action (37):
	call act37;
	go to ret;

act37:
     proc;
	end_stmt.b = "1"b;
	call seqputeos;
     end;

action (38):					/* type 8 to type 3 */
	if alphanum_lit.type = 8
	then do;
		alphanum_lit.type = 3;
		alphanum_lit.lit_type = "0"b;
		alphanum_lit.all_lit = "0"b;
	     end;
	else alphanum_lit.type = 8;

	go to ret;

/* output eos */

action (39):
	call seqputeos;
	go to ret;

action (40):					/* merge statement */
	call PERF (44);
	call act145;
	go to ret;

action (41):					/* sort statement */
	end_stmt.d = "01"b;
	file_count, key_count = 0;
	call act28;
	go to ret;

action (42):					/*[4.0-1]*/
	if reserved_word.key = 47
	then END_WORD = 7;				/*if */
						/*[4.0-1]*/
	else if reserved_word.key = 5
	then END_WORD = 2;				/* call */
						/*[4.0-1]*/
	else if reserved_word.key = 34
	then END_WORD = 16;				/* string */
						/*[4.0-1]*/
	else if reserved_word.key = 37
	then END_WORD = 18;				/* unstring */
						/*[4.0-1]*/
	else if reserved_word.key = 25
	then END_WORD = 12;				/* return */

/*[4.0-1]*/
	call NL;
	go to ret;

/* lock present in close verb and output eos */
action (43):
	end_stmt.f = "01"b;
	call seqputeos;
	go to ret;

action (44):					/*[4.0-1]*/
	if reserved_word.key = 21
	then END_WORD = 10;				/* read */
						/*[4.0-1]*/
	else if reserved_word.key = 38
	then END_WORD = 19;				/* write */
						/*[4.0-1]*/
	else if reserved_word.key = 27
	then END_WORD = 13;				/* rewrite */
						/*[4.0-1]*/
	else if reserved_word.key = 56
	then END_WORD = 15;				/* start */
						/*[4.0-1]*/
	else if reserved_word.key = 22
	then END_WORD = 4;				/* delete */

/*[4.0-1]*/
	call NL;
	go to ret;


/* count operands to be computed for compute verb */
/* save item add 1 to operand count in format 1 of multiply verb */


action (45):
	substr (sav_ptr -> itemsize, 1, header.size) = substr (addr_record -> itemsize, 1, header.size);
	end_stmt.e = end_stmt.e + 1;
	cssavebit = data_name.constant_section;

/*[4.1-7]*/
	prev_diag.line_num = header.line;		/*[4.1-7]*/
	prev_diag.column_num = header.column;
	go to ret;				/* output saved item
			save current item
			add 1 to operand count in format 1 of multiply verb */
action (46):
	arg_1 = savitmptr;
	code_option = 33;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;

	substr (sav_ptr -> itemsize, 1, header.size) = substr (addr_record -> itemsize, 1, header.size);
	go to ret;

/* count REPLACINGS for insPECT verb */
/* set format 2 */

action (47):
	end_stmt.a = "001"b;
	end_stmt.h = end_stmt.h + 1;
	if repcsbit
	then call DIAG (248);
	go to ret;

/* set a to format 4 or format 5 for divide verb
			and ioutput saved item */
action (48):
	arg_1 = savitmptr;
	code_option = 34;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/* output a generated procedure name reference and then an eos */

action (49):
	call act49;
	go to ret;

act49:
     proc;
	arg_1 = dpnptr;
	code_option = 35;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
     end;

action (50):					/*[4.0-4]*/
	if reserved_word.key = 20			/* perform */
						/*[4.0-4]*/
	then do;
		END_WORD = 9;			/*[4.0-4]*/
		end_stmt.d, end_stmt.f = "00"b;	/*[4.0-4]*/
	     end;					/*[4.0-1]*/
	else if reserved_word.key = 26
	then END_WORD = 14;				/* search */
						/*[4.0-1]*/
	else if reserved_word.key = 23
	then END_WORD = 11;				/* receive */
						/*[4.0-1]*/
	else if reserved_word.key = 500
	then END_WORD = 6;				/* evaluate */

/*[4.0-1]*/
	call NL;
	go to ret;

save_skip_ind:
     proc;					/*[5.3-2]*/
	ST.save_skip_ind (nest_lev) = ST.skip_ind (nest_lev);
						/*[5.3-2]*/
	ST.skip_ind (nest_lev) = "1"b;
     end;

action (52):					/*[5.3-2]*/
	ST.skip_ind (nest_lev) = ST.save_skip_ind (nest_lev);
	go to ret;

action (53):					/*NOT USED*/
	go to ret;

/* puts missing period diagnostic on correct line */

action (54):					/*[4.1-7]*/
	call DIAG_PREV_TOKEN (7);
	go to ret;

action (55):
action (56):
action (57):
action (58):
action (59):
action (60):
action (61):					/*NOT USED*/
	go to ret;

/* set a to format 1 and output saved item */

action (62):
	arg_1 = savitmptr;
	code_option = 36;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/* format 4 in perform verb */

action (63):
	end_stmt.a = "011"b;
	go to ret;

/* day in accept verb */

action (64):
	end_stmt.e = end_stmt.e + 1;
	go to ret;

action (65):					/*NOT USED*/
	go to ret;

/* output a generated then */

action (66):
	code_option = 15;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/* esi in send verb */
action (67):
	end_stmt.d = "01"b;
	go to ret;				/* emi in send verb */
action (68):
	end_stmt.d = "10"b;
	go to ret;				/* eti in send verb */
action (69):
	end_stmt.d = "11"b;
	go to ret;

action (70):					/*NOT USED*/
	go to ret;

/*  format 2 and before in send verb */

action (71):
	end_stmt.a = "001"b;
	end_stmt.f = "01"b;
	go to ret;

/* format 2 and after in send verb */

action (72):
	end_stmt.a = "001"b;
	end_stmt.f = "10"b;
	go to ret;

/* set ascending ascending bit in item
			add 1 to data item count for sort verb */
/* compute offset from beginning of record and put it in operand */

action (74):
	key_count = key_count + 1;
	data_name.ad_bit = end_stmt.b;
	data_name.linkage_section = "1"b;		/* set for generator */
	data_name.compare_argument = "1"b;		/* set for generator */
	linkage = 1;				/* argument no set for generator */
	end_stmt.e = end_stmt.e + 1;			/* count operands */

	if data_name.seg_num = 0
	then go to ret;				/* locate mode all done */

	file_number = data_name.file_num;
	call cobol_read_ft_ (file_number, ft_ptr);

/* above gets pointer to filetable */
	data_name.offset = data_name.offset - cra_offset;
	go to ret;

/* format 2 and output saved item in subtract verb */

action (75):
	end_stmt.a = "001"b;
	call act32;
	go to ret;

action (76):
action (77):					/*NOT USED*/
	go to ret;

/* count REPLACINGS in INSPECT verb */
/* count of operands after into for unstring verb */
/* count of file names after USING in SORT verb */

action (78):
	end_stmt.h = end_stmt.h + 1;
	go to ret;

action (79):
action (80):
action (81):
action (82):
action (83):					/*NOT USED*/
	go to ret;

/* set diagno to 1 */
action (84):
	diagno = 1;
	go to ret;

action (85):					/*[5.3-2]*/
	ST.cond (nest_lev) = "1"b;
	go to ret;

/* reset and clear diagnostic switch */

action (86):
	diagno = 0;
	go to ret;				/* clear eos, moven token to eos */

action (87):
	call act87;
	go to ret;

act87:
     proc;
	end_stmt_bits = "0"b;
	end_stmt.verb = reserved_word.key;
     end;

/* program has declaratives section */
/* set switch to indicate we are processing inside declarative section */

action (88):
	decswitch = 1;
	go to ret;

/* program contains sections */

action (89):
	secswitch = 1;
	go to ret;

/* save eos for write and compute  and error verb */

action (90):
	saveos = end_stmt_chars;
	go to ret;

action (91):					/*[5.3-2]*/
	call inc_nest_lev;
	go to ret;

action (92):					/*NOT USED*/
	go to ret;

action (93):					/*[5.3-2]*/
	call dec_nest_lev;
	go to ret;

/* turn on debug switch because use for debugging is present */

action (94):
	debugsw = 1;
	go to ret;

/* set all bit in data name for use verb */

action (95):
	data_name.debug_all = "1"b;
	go to ret;

/* the end declaratives has been reached */

action (96):
	decswitch = 2;
	go to ret;

/*[4.4-5]*/
declare	first		bit (1);

action (97):					/*NOT USED*/
	go to ret;

pop_perf:
     proc;

/*[5.3-2]*/
	if ST.e (nest_lev) ^= 0
	then call emit_eos_perf;

     end;

pop_if:
     proc;

/*[5.3-2]*/
	if ST.option (nest_lev)			/*[5.3-2]*/
	then call DEF (ST.h (nest_lev));		/*[5.3-2]*/
	else if cssub ^= 0				/*[5.3-2]*/
	then call DEF (cstack.false (cssub));		/*[5.3-2]*/
	else ;

     end;

pop_other:
     proc;

/*[5.3-2]*/
	end_stmt.a = "0"b;

/*[5.3-2]*/
	if ST.option (nest_lev)
	then call emit_eos;

     end;

pop_state:
     proc;

/*[5.3-2]*/
	END_WORD = ST.end_wd (nest_lev);

/*[5.3-2]*/
	if END_WORD = 7				/*[5.3-2]*/
	then call pop_if;				/*[5.3-2]*/
	else if END_WORD = 9			/*[5.3-2]*/
	then call pop_perf;				/*[5.3-2]*/
	else call pop_other;

     end;

emit_eos:
     proc;

/*[4.0-4]*/
	end_stmt.verb = 3;				/*[4.0-4]*/
	end_stmt.b = "0"b;				/*[4.0-4]*/
	end_stmt.e, end_stmt.h, end_stmt.i = 0;		/*[4.0-4]*/
	call seqputeos;

     end;

/* for accept   set device to default or console and output eos */

action (98):
	end_stmt.e = 9;
	call seqputeos;
	go to ret;

/* device 2 or card-reader in accept verband output eos */

action (99):
	end_stmt.e = 10;
	call seqputeos;
	go to ret;

/* device 3 in accept verb and output eos */

action (100):
	end_stmt.e = 11;
	call seqputeos;
	go to ret;

/* time in accept verb */

action (101):
	end_stmt.e = 2;
	go to ret;				/* output saved item and output eos */

action (102):
	arg_1 = savitmptr;
	code_option = 37;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/* size error follows --output saved item--output eos for add verb */

action (103):
	arg_1 = savitmptr;
	code_option = 38;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/* output a generaTED ALTER FOR ALTER VERB  */

action (104):
	code_option = 5;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;				/* output a generated cancel and an eos for cancel verb */
action (105):
	code_option = 6;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/*set chain bit for close verb
			put out eos */
/* output a generated close for the close verb */

action (106):
	code_option = 8;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

action (107):					/*NOT USED*/
	go to ret;

/* restore eos for compute verb */

action (108):
	end_stmt_chars = saveos;
	go to ret;

/* device no 2 or printer for display verb and output eos*/

action (109):
	call act109;
	go to ret;

act109:
     proc;
	end_stmt.a = "001"b;
	call seqputeos;
     end;

action (110):					/*[5.3-2]*/
	ST.option (nest_lev) = "1"b;			/*[5.3-2]*/
	EW = ST.end_wd (nest_lev);

/*[5.3-2]*/
	if EW = 10				/* read */
						/*[5.3-2]*/
	then end_stmt.a = "010"b;			/*[5.3-2]*/
	else end_stmt.b = "1"b;

/*[5.3-2]*/
	call seqputeos;				/*[5.3-2]*/
	end_stmt_bits = "0"b;			/*[5.3-2]*/
	end_stmt.verb = 3;
	go to ret;

/* output a generated initiate for initiate verb */

action (111):					/*[4.4-5]*/
	call cobol_swf_put (cobol_pdofp, st, rw_perform_ptr, rw_perform_size);

	go to ret;

action (112):					/*[5.3-2]*/
	if reserved_word.type = 1			/*[5.3-2]*/
	then if reserved_word.key < 70		/*[5.3-2]*/
	     then current_line = reserved_word.key;	/*[5.3-2]*/
	     else current_line = 29;			/* evaluate */
						/*[5.3-2]*/
	else current_line = 57;			/* suppress */

	go to new_inst;

/* save item inside saveident */
/* save offset for occurs extension */
/* compute address of occurs extension */
/* clear the subscript type bits */

action (113):
	call act113;
	go to ret;

act113:
     proc;
	substr (addr (saveident) -> itemsize, 1, header.size) = substr (head_ptr -> itemsize, 1, header.size);
	savoccptr = data_name.occurs_ptr;
	occptr = addr (savidptr -> exten (savoccptr));
	data_name_bit, index_name_bit = "0"b;		/*[4.4-6]*/
	call set_op_loc;
     end;

/* set bit to indicate this literal is a subscript */

action (114):
	numeric_lit.subscript = "1"b;
	go to ret;

action (115):
action (116):
action (117):					/*NOT USED*/
	go to ret;


/* restore item from saveident to its window position */


action (118):
	substr (addr_record -> savidsize, 1, saveident.size) =
	     substr (addr (saveident) -> savidsize, 1, saveident.size);

/*[4.0-3]*/
	if err ^= 0
	then call diag (err);

	call test_subs;

	if res
	then call diag (269);

	go to ret;

test_subs:
     proc;

declare	(i, val)		fixed bin;

	occptr = addr (addr_record -> exten (data_name.occurs_ptr));

	do i = 1 by 1 to occurs.dimensions;

	     val = subs (i);

	     if val = 0 | /*[4.2-2]*/ (val > 0 & val > occurs.level.max (i))
	     then do;
		     res = "1"b;
		     return;
		end;
	end;

	res = "0"b;
     end;

/* output eos-- output a generated open-clear eos-set eos to type open for open verb */
/* set chain bit for OPEN verb */

action (119):
	call act119;
	go to ret;
act119:
     proc;
	go to OM (op_mode);
OM (1):
	code_option = 9;
	go to OM1;				/* input */

OM (2):
	code_option = 10;
	go to OM1;				/* output */

OM (3):
	code_option = 11;
	go to OM1;				/* io */

OM (4):
	code_option = 12;
	go to OM1;				/* extend */

OM1:
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;

     end;

action (120):
	end_stmt.d = "10"b;
	go to ret;

action (121):
	end_stmt.d = "01"b;
	go to ret;

action (122):
	end_stmt.d = "11"b;
	go to ret;

/* output eos -- output a generated suspend --clear eos */
/* set eos to suspend type for suspend verb */


action (123):
	code_option = 13;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/* output a generate terminate for terminate veb */

action (124):					/*[4.4-5]*/
	call cobol_swf_put (cobol_pdofp, st, eos_perform_ptr, eos_perform_size);
	go to ret;

/* reset subscript counter to zero */

action (125):
	subcnt = 0;
	subs (1), subs (2), subs (3) = -1;
	go to ret;

/* add 1 to subscript counter */

action (126):
	subcnt = subcnt + 1;
	go to ret;

/* clear eos set eos to procedure */

action (127):
	end_stmt_bits = "0"b;

	end_stmt.verb = 52;
	go to ret;

/* clear eos set type to section header and build entry for perform alter range table for use */

action (128):					/*[4.4-2]*/
	if ^LTP
	then call DIAG_PREV_TOKEN (279);

	if decswitch ^= 0
	then do;
		perfcode = 0;
		perfprocnum = proc_def.proc_num;
		perfprio = fixed (unspec (proc_def.priority));
	     end;

	shprio = fixed (unspec (proc_def.priority));

	end_stmt_bits = "0"b;

	end_stmt.verb = 54;
	cursecnum = proc_def.section_num;		/* save the current section number */
	addr (stat.procdef) -> bit9 = addr (proc_def.sort_range) -> bit9;
	go to ret;

/* clear eos set type to paragraph header */

action (129):					/*[4.4-2]*/
	if ^LTP
	then call DIAG_PREV_TOKEN (279);

	end_stmt_bits = "0"b;

	end_stmt.verb = 55;
	go to ret;

/* reset subroutine stack pointer to zero and also nested if counter  */
/* reset imp switch to show we are no longer looking for an imperative verb */
/* reset conditional stack pointer to zero */
/* reset eos verb type to 0 */

action (130):
	nest_lev = 1;
	i1, cssub, end_stmt.verb = 0;			/*[5.3-2]*/
	call reset_st;

	go to ret;

/* set bit to indicate this data name is a subscript */

action (131):
	data_name.used_as_sub = "1"b;
	go to ret;

/* set bit to indicate this index is a subscript */

action (132):
	index_name.subscript = "1"b;
	go to ret;

/* clear eos set eos to declaratives */

action (133):
	end_stmt_bits = "0"b;			/*[5.2-1]*/
	end_decl_bit = "0"b;
	end_stmt.verb = 53;
	go to ret;

/* add 1 to nested if statement counter */

action (134):					/*NOT USED*/
	go to ret;

/* index name is predent as  a subscript */

action (135):
	index_name_bit = "1"b;
	go to ret;

/* data name is present as a subscript */

action (136):
	data_name_bit = "1"b;
	data_name.used_as_sub = "1"b;
	go to ret;

/* overlap between sending and receiving item */


action (137):
	data_name.overlap = "1"b;
	go to ret;

/* end of job when end cobol is encountered */

action (138):
endjob:
	go to endint;

/* set bit to show we are processing a search verb */

action (139):					/*[4.4-5]*/
	ST.option (nest_lev) = "1"b;
	go to ret;

/* output a then eos */

action (140):
	end_stmt.verb = 64;
	call seqputeos;
	go to ret;

/* output a search eos
			show we are no longer processing a search verb
			show we are not looking for a imperative verb */

action (141):
	srchfm2bit = "0"b;				/* no longer in format 2 */
	end_stmt.verb = 26;
	call seqputeos;
	go to ret;

/* set bit to indicate we are processing format 2 of the search verb */
action (142):
	srchfm2bit = "1"b;
	UB_ind = "0"b;				/*[3.0-9]*/
	go to ret;

/* build an entry for the perform alter range table */

action (143):
	perfcode = 0;				/* end of perform range */
	call act143;
	go to ret;

act143:
     proc;

	perfprocnum = proc_def.proc_num;
	perfprio = fixed (unspec (proc_def.priority), 16);
	call act145;
     end;

/* build an entry for the perform alter range table */

action (144):
	perfprocnum = savitmptr -> proc_def.proc_num;
	perfcode = 0;
	perfprio = fixed (unspec (savitmptr -> proc_def.priority), 16);
	call act145;
	go to ret;

/* write the perform entry and update the old entry **/

action (145):
	call act145;
	go to ret;

act145:
     proc;
	perform_range_key = perf_alter_info;

	do while (perform_range_key ^= "00000");
	     varrecaddr = perform_range_key;
	     call vardget;
	     jkpfm_ptr = seqvarptr;

	     if (perfprocnum = jkperfprocnum) & (perfcode = jkperfcode)
	     then go to ret;
	     if jkperflink = "00000"
	     then do;
		     call act145b;
		     return;
		end;
	     perform_range_key = jkperflink;
	end;
	call act145b;
     end;

act145b:
     proc;

	call cobol_vdwf_sput (cobol_cmfp, st, addr (perfrange), fb26, common_key);

	if substr (st, 17, 16) ^= "0"b
	then go to write_error;

	if perf_alter_info = "00000"
	then do;
		perf_alter_info = common_key;
		addr (saveperfrange) -> c26 = addr (perfrange) -> c26;
		savlaskey = common_key;
	     end;
	else do;
		sperlin = common_key;
		varrecaddr = savlaskey;
		call vardget;
		junk_ptr = seqvarptr;
		seqvarptr = addr (saveperfrange);
		seqvarleng = fb26;
		varrecaddr = savlaskey;
		call vardput;
		addr (saveperfrange) -> c26 = addr (perfrange) -> c26;
		savlaskey = common_key;
	     end;
     end;

/* set argument no for sort and merge verb  for generatotr */

action (146):
	linkage = 2;				/* argument no */
	go to ret;

/* build entry for perform alter table */

action (147):
	declprocbit = proc_def.declarative_proc;
	perfcode = 1;				/* alter procedure name */

	call act143;				/*  continue building */
	go to ret;

action (148):					/*  output a go
	output a proc name
	output a proc name  */
	gotodep = "0"b;				/*  clear the switch */

	arg_1 = addr (store_label_1);
	arg_2 = addr (store_label_2);

	code_option = 16;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/*  set all bit in literal */

action (149):
	alphanum_lit.all_lit = "1"b;
	go to ret;

/* set numeric condition bit in common area */

action (150):					/*[4.4-12]*/
	num_cond = "1"b;
	is_not_rel = "1"b;
	SUBJ_REQ = "1"b;				/*[5.3-1]*/
	if cssub > 0
	then cstack.c.logical (cssub - 1) = "1"b;
	go to ret;

/* set alphabetic bit in common area */

action (151):					/*[4.4-12]*/
	alpha_cond = "1"b;
	is_not_rel = "1"b;
	SUBJ_REQ = "1"b;				/*[5.3-1]*/
	if cssub > 0
	then cstack.c.logical (cssub - 1) = "1"b;
	go to ret;

/* set delete bit in file table */

action (152):
	delete = "1"b;
	go to ret;

/* if we are processing a format 1 use statement put the error rroutine address
	in the associated file table - table already in core from check (172) */

action (153):
	error_exit = cursecnum;
	seqvarptr = ft_ptr;
	seqvarleng = common_recsize;
	file_number = fd_token.file_no;
	call cobol_read_ft_ (file_number, ft_ptr);
	ft_ptr = seqvarptr;
	go to ret;

/* reset a bit to indicate that the EXIT verb
	was not preceded by a procedure definition */


action (154):
	preospn_bit = "0"b;
	go to ret;

/* set a bit to indicate that the EXIT verb
	was preceeded by a procedure definition */

action (155):
	preospn_bit = "1"b;
	go to ret;

/* get collating sequence from common
	and put it into EOS for sort verb*/

action (156):
	end_stmt.i = prog_coll_seq;
	end_stmt.d = "00"b;
	go to ret;

/* save the FILE  after GIVING or USING in SORT statement */

action (157):
	substr (addr (sv_usfil) -> itemsize, 1, header.size) = substr (addr_record -> itemsize, 1, header.size);
	go to ret;

/* output a OPEN, FILENAM, EOS, PROCDEF, RETURN, FILENAM, */
/* RECORDNAM, EOS, GOTOPROC, EOSATEND, WRITE, RECORDNAM, EOS, */
/* GOTOPROC, PROCDEF, CLOSE, FILENAM, EOS, EOS90  */

action (158):
	spec_tag_counter = spec_tag_counter + 2;
	save_gentag = spec_tag_counter - 1;

	arg_1 = addr (sv_usfil);
	arg_2 = addr (spec_tag_counter);
	arg_3 = savitmptr;
	arg_4 = addr_record;

	code_option = 1;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/* output a OPEN, FILENAM, EOS, PROCDEF, READ, FILENAM, */
/* EOS, GOTOPROC, EOSATEND, RELEASE, SORTREC, FILEREC, */
/* EOS, GOTOPROC, PROCDEF, CLOSE, FILENAM, EOS, */

action (159):
	spec_tag_counter = spec_tag_counter + 2;
	save_gentag = spec_tag_counter - 1;

	arg_1 = addr (sv_usfil);
	arg_2 = addr (spec_tag_counter);
	arg_3 = addr (sv_srtfil_rec);
	arg_4 = addr_record;

	code_option = 2;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/* set e to proper INPUT DEVICE */

action (160):
	if mnemonic_name.iw_key = 3
	then end_stmt.e = 9;			/*[3.0-4]*/
	else end_stmt.e = 10;
	go to ret;

/* set DAYOFWEEK for ACCEPT */

action (161):
	end_stmt.e = 3;
	go to ret;

/* output an EOS91 for the SORT statement */

action (162):
	code_option = 18;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;


/* set a to proper OUTPUT DEVICRE */

action (163):
	if mnemonic_name.iw_key = 3
	then end_stmt.a = "000"b;			/*[3.0-4]*/
	else end_stmt.a = "001"b;
	go to ret;

/* do out_operator with param =1*/
/* output EOS3 ffor SEARCH */
/* declare all true and false labels */

action (164):
	call TEST (act_log.false, "1001"b);

	code_option = 19;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;

	UB_ind = "0"b;				/*[3.0-9]*/
	call act200;
	go to ret;

/* save procedure definition in SORT statement */

action (165):
	substr (addr (sv_proc_def) -> itemsize, 1, header.size) = substr (addr_record -> itemsize, 1, header.size);
	perfcode = 2;
	perfprocnum = proc_def.proc_num;
	perfprio = fixed (unspec (proc_def.priority), 16);
	go to ret;

/* output a PERFORM, sec-nm, sec-nm2, performeos, EOS91 */

action (166):
	call PERF (3);
	call act145;
	go to ret;

/* output a PERFORM, PROCNAMR, procname, PERFORMeos, EOS91 */

action (167):
	arg_1 = addr (sv_proc_def);

	code_option = 4;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	call act145;
	go to ret;

/* output a PERFORM, PROCNAM, PROCNAM, EOSperform, EOS90 */

action (168):
	call PERF (39);
	call act145;
	go to ret;

PERF:
     proc (val);

declare	val		fixed bin;

	arg_1 = addr (sv_proc_def);
	arg_2 = addr_record;

	code_option = val;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;

	perfprocnum = proc_def.proc_num;
	perfprio = fixed (unspec (proc_def.priority), 16);
	perfcode = 2;

     end;

/* output a PERFORM, PROCNAM, PROCNAM, PERFORMeos, EOS90 */

action (169):
	arg_1 = addr (sv_proc_def);
	code_option = 40;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	call act145;
	go to ret;

/* save the SORTFILE RECORD */

action (170):
	substr (addr (sv_srtfil_rec) -> itemsize, 1, header.size) = substr (addr_record -> itemsize, 1, header.size);
	go to ret;

/*output EOS4 for SEARCH */

action (171):
	code_option = 20;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	call setabit;
	code_option = 24;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;

/* output EOS4 for SEARCH verb */

action (172):
	code_option = 21;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/* output EOS2 for SEARCH */

action (173):
	call setabit;
	code_option = 22;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/* output final EOS2 for SEARCH */

action (174):
	call act174;
	go to ret;

act174:
     proc;
	if ^srchfm2bit
	then end_stmt.a = "000"b;
	code_option = 23;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	srchfm2bit = "0"b;
     end;

action (175):					/*NOT USED*/
	go to ret;

/* output EOS3 for SEARCH */

action (176):
	code_option = 25;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	call act174;
	go to ret;

/* output EOS3 for SEARCH */

action (177):
	code_option = 26;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/* output final EOS2 for SEARCH */

action (178):
	call setabit;
	code_option = 27;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	srchfm2bit = "0"b;
	go to ret;

setabit:
     proc;

	if srchfm2bit
	then end_stmt.a = "001"b;
	else end_stmt.a = "000"b;

     end;

/* set HISTORY bits in file tables */

action (179):
	call act179;
	go to ret;

act179:
     proc;
	if fd_token.file_no = 0
	then return;
	file_number = fd_token.file_no;
	call cobol_read_ft_ (file_number, ft_ptr);
	go to subact (histno);

subact (1):
	close = "1"b;
	return;

subact (2):
	open_ext = "1"b;
	return;

subact (3):
	open_in = "1"b;
	return;

subact (4):
	open_out = "1"b;
	return;

subact (5):
	open_io = "1"b;
     end;

/* set CLOSE history bit in file table */

action (180):
	histno = 1;
	call act179;
	go to ret;

/* set OPEN_EX history bit in file table */

action (181):
	histno = 2;
	call act179;
	go to ret;

/* set OPEN_IN history bit in file table */

action (182):
	histno = 3;
	call act179;
	go to ret;

/* set OPEN OUT history bit in file table */

action (183):
	histno = 4;
	call act179;
	go to ret;

/* set OPEN_IO history bit in file table */

action (184):
	histno = 5;
	call act179;
	go to ret;

action (185):
	file_count = 0;

	go to ret;

action (186):
	file_count = file_count + 1;
	go to ret;

action (187):
	arg_1 = addr_record;
	arg_2 = addr (sv_usfil);
	code_option = 42;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

action (188):
	file_count, key_count = 0;
	call act28;
	go to ret;

action (189):
	arg_1 = addr (key_count);
	arg_2 = addr (file_count);
	code_option = 41;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

action (190):
	arg_1 = addr (sv_proc_def);

	code_option = 43;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	call act145;
	go to ret;

action (191):
	substr (end_stmt.f, 1, 1) = stat.procdef.mrg_range;
	substr (end_stmt.f, 2, 1) = stat.procdef.srt_range;
	call act28;
	go to ret;

action (192):
	UB_ind = "1"b;
	go to ret;

action (193):
	UB_ind = "1"b;
	call seqputeos;
	go to ret;

action (194):
	UB_ind = "1"b;
	call act37;
	go to ret;

action (195):
	UB_ind = "0"b;
	go to ret;

action (196):
action (197):
action (198):
action (199):					/*NOT USED*/
	go to ret;

/* do an out_operator with parameter = 1
	set dumprocname.searched and true bit for PERFORM verb
	do an DEFlaration with parameter = to true of active
	clear the bits
	put active on stack*/
/* declare all true and false labels for the PERFORM verb */


action (200):
	call TEST (act_log.false, "1001"b);
	call act200;
	go to ret;

act200:
     proc;
	dumprocname.searched = "1"b;
	dumprocname.duplicate = "1"b;
	if act_log.true ^= 0
	then call DEF (act_log.true);
	dumprocname.duplicate = "0"b;
	if act_log.false ^= 0
	then call DEF (act_log.false);
	dumprocname.searched = "0"b;
     end;

/* put unary - on arithmetic stack */

action (201):
	assub = assub + 1;
	SAE = "0"b;				/*[3.0-10]*/
						/* AS(assub) = 0 */

	astack_ptr = addr (astack (assub));
	astack_bits = "0"b;

	astack.unmin (assub) = "1"b;
	astack.key (assub) = 187;
	go to ret;

/* put left parenthesis on arithmetic stack */

action (202):					/*[4.2-3]*/
	if reserved_word.column ^= 0
	then do;
		expind = "1"b;			/*[4.4-1]*/
		arith_op = "1"b;
		SAE = "0"b;
	     end;

	assub = assub + 1;				/* AS(assub) = 0 */

	astack_ptr = addr (astack (assub));
	astack_bits = "0"b;

	astack.lefpar (assub) = "1"b;
	go to ret;

/* if the priority of the operator being processed
			id greater than hthe priority of operator
			on arithmetic stack put operator being
			processed on stack otherwise output one
			stack item and go back to beginning. */

action (203):
	expind = "1"b;
	SAE = "0"b;				/*[3.0-10]*/
						/*[4.4-1]*/
	arith_op = "1"b;

	do while ("1"b);

	     if (reserved_word.key = 185) | (reserved_word.key = 183)
	     then tempkey = reserved_word.key - 1;
	     else tempkey = reserved_word.key;

	     if tempkey > astack.key (assub)
	     then do;
		     assub = assub + 1;		/*AS(assub) = 0 */

		     astack_ptr = addr (astack (assub));
		     astack_bits = "0"b;

		     astack.key (assub) = reserved_word.key;
		     go to ret;
		end;
	     else do;
		     opeos.verb = 28;		/* arithmetic operatotr */
		     opeos.e = astack.key (assub);	/* actual operation */
		     seqvarptr = opeosptr;
		     seqvarleng = opeos.size;
		     call seqput;
		     assub = assub - 1;
		end;
	end;

/* output the arithmetic stack elements
			al long as they belong to class 1 */

action (204):
	do while ("1"b);

	     if assub = 0
	     then go to ret;

	     if astack.key (assub) = 0
	     then go to ret;

	     opeos.verb = 28;			/* arithmetic operation */
	     opeos.e = astack.key (assub);		/* specific operation */
	     seqvarptr = opeosptr;
	     seqvarleng = opeos.size;
	     call seqput;
	     assub = assub - 1;
	end;

/* pop the arithmetic stack */

action (205):					/*[4.2-6]*/
	if reserved_word.column ^= 0
	then expind = "1"b;
	assub = assub - 1;				/*[4.4-1]*/
	arith_op = "1"b;
	go to ret;

/* pop the logical stack and set lognot
			equal to not field from item that was judt
			popped */

action (206):					/*[4.2-6]*/
	if reserved_word.column ^= 0
	then expind = "1"b;
	lognot = cstack.not (cssub);
	cssub = cssub - 1;				/*[4.4-1]*/
	arith_op = "1"b;				/*[4.4-12]*/
	SUBJ_REQ = cstack.subj_req (cssub);
	go to ret;

/* put zero on arithmetic stack */

action (207):
	expind = "0"b;
	assub = 1;
	SAE = "1"b;				/*[3.0-10]*/
						/*[4.4-1]*/
	arith_op = "0"b;

/*[4.0-1]*/
	ae.line = header.line;			/*[4.0-1]*/
	ae.column = header.column;			/* AS(assub) = 0 */

	astack_ptr = addr (astack (assub));
	astack_bits = "0"b;

	op.op_lit = "1"b;
	go to ret;

action (208):					/*[4.4-1]*/
	arith_op = "1"b;
	go to ret;

action (209):					/*[4.4-1]*/
	arith_op = "0"b;
	go to ret;

action (210):					/*[4.4-12]*/
	SUBJ_REQ = "0"b;				/*[4.4-1]*/
	if arith_op				/*[4.4-1]*/
	then do;
		call ae_diag (13);			/* ae in rel cond */
						/*[4.4-1]*/
		arith_op = "0"b;			/*[4.4-1]*/
	     end;
	go to ret;

ae_diag:
     proc (dn);

/*[4.4-1]*/
declare	dn		fixed bin;

/*[4.4-1]*/
	if fixed_common.comp_level < "3"		/*[4.4-1]*/
	then if arith_op				/*[4.4-1]*/
	     then call LEV_DIAG (dn, ae.line, ae.column);

     end;

/* put the item on conditional stack */

action (211):					/*[4.4-6]*/
	call act211;				/*[4.4-6]*/
	op.loc = mptr;
	go to ret;

act211:
     proc;
	cssub = cssub + 1;
	cstack_ptr = addr (cstack (cssub));
	cstack_bits = "0"b;
	cstack.true (cssub) = header.type;
	cstack.operand (cssub) = "1"b;

	call TOK_TYPE;				/*[3.0-10]*/
     end;

TOK_TYPE:
     proc;					/*[3.0-10]*/



/*[4.4-6]*/
	string (op.descr) = "0"b;


/*[4.0-6]*/
	op.line = header.line;
	op.col = header.column;

	if reserved_word.type > 10
	then return;				/*[3.0-10]*/

	go to CS (reserved_word.type);		/*[3.0-10]*/

CS (1):						/* reserved word */
	op.op_lit = "1"b;

	if reserved_word.key = 180			/* zero */
	then do;
		op.numeric = "1"b;			/*[3.0-10]*/
		op.integer = "1"b;			/*[3.0-10]*/
	     end;					/*[3.0-10]*/
	else op.non_numeric = "1"b;			/*[3.0-10]*/

	return;

CS (2):						/* numeric literal */
	op.op_lit = "1"b;
	op.numeric = "1"b;				/*[3.0-10]*/
	if numeric_lit.places_right = 0
	then op.integer = "1"b;			/*[3.0-10]*/

	op.length = op.length + numeric_lit.places_right + numeric_lit.places_left;
						/*[3.0-10]*/

/*[4.0-1]*/
	op.length = 0;

	return;					/*[3.0-10]*/

CS (3):						/* alphanumeric literal */
	op.op_lit = "1"b;
	op.non_numeric = "1"b;			/*[3.0-10]*/

	op.length = alphanum_lit.lit_size;		/*[3.0-10]*/

	return;					/*[3.0-10]*/

CS (9):						/* data name */
	op.op_lit = "0"b;
	if data_name.usage_index			/*[3.0-10]*/
	then op.index = "1"b;			/*[3.0-10]*/
	else /*[3.0-10]*/
	     if data_name.non_elementary		/*[3.0-10]*/
	then op.non_numeric = "1"b;			/*[3.0-10]*/
	else if data_name.numeric | data_name.numeric_edited
						/*[3.0-10]*/
	then do;
		op.numeric = "1"b;			/*[3.0-10]*/
		if data_name.places_right = 0		/*[3.0-10]*/
		then op.integer = "1"b;		/*[3.0-10]*/
	     end;					/*[3.0-10]*/
	else op.non_numeric = "1"b;			/*[3.0-10]*/


	if fixed_common.comp_level < "5"
	then do;
		call field_length;			/*[3.0-1]*/
		op.length = L;
	     end;

	return;					/*[3.0-10]*/

CS (10):						/*[3.0-10]*/
	op.index = "1"b;				/*[3.0-10]*/


CS (4):
CS (5):
CS (6):
CS (7):
CS (8):
     end;

field_length:
     proc;

	L = 0;

	if data_name.non_elementary
	then L = data_name.item_length;
	else if data_name.numeric | data_name.numeric_edited
	then do;
		if data_name.item_signed
		then L = 1;

		L = L + data_name.places_left + data_name.places_right;
	     end;
	else if data_name.alphabetic | data_name.alphanum_edited | data_name.alphanum
	then L = data_name.item_length;

     end;

/* put the arithmetic expression symbol on stack */

action (212):
	cssub = cssub + 1;				/* CS(cssub) = 0 */

	cstack_ptr = addr (cstack (cssub));
	cstack_bits = "0"b;

/*[5.3-1]*/
	if SAE
	then go to ret;

/*[3.0-10]*/
	op_bits = "0"b;				/*[3.0-10]*/
	op.numeric = "1"b;
	op.loc = null ();

	go to ret;

/* pop the stack */

action (213):
	cssub = cssub - 1;
	go to ret;

action (214):
	if fixed_common.comp_level < "3"
	then do;
		if (header.type = 3 & alphanum_lit.lit_size ^= 1) | (header.type = 9 & data_name.item_length ^= 1)
		then call lev_diag (124);

	     end;

	go to ret;

action (215):					/*[5.2-1]*/
	call cobol_swf_put (cobol_pdofp, st, rw_move_ptr, rw_move_size);
						/*[5.2-1]*/
	call cobol_swf_put (cobol_pdofp, st, supp_lit_ptr, supp_lit_size);
						/*[5.2-1]*/
	call cobol_swf_put (cobol_pdofp, st, ss_tok_ptr, ss_tok_size);
						/*[5.2-1]*/
	call cobol_swf_put (cobol_pdofp, st, eos_move_ptr, eos_move_size);

	go to ret;

/*[5.2-1]*/
dcl	ss_tok_ptr	ptr,
	ss_tok_size	fixed bin;

action (216):					/*[5.2-1]*/
	ss_tok_ptr = mptr;				/*[5.2-1]*/
	ss_tok_size = data_name.size;			/*[5.2-1]*/
	data_name.type = 9;

	go to ret;

action (217):
action (218):					/*NOT USED*/
	go to ret;

/*  unknown at this time */

action (219):					/* SUB = 0 */
	subject_bits = "0"b;
	subject.true = 17;
	cstack.logical (cssub) = "1"b;
	coperator.comp = "0"b;
	coperator.op = 17;
	cssub = cssub + 1;				/*[4.4-12]*/
	SUBJ_REQ = "1"b;				/* CS(cssub) = 0 */
	cstack_ptr = addr (cstack (cssub));
	cstack_bits = "0"b;				/*[4.4-3]*/
	is_not_rel = "1"b;

	cstack.true (cssub) = 17;
	cstack.operand (cssub) = "1"b;
	soperator.op = coperator.op;
	soperator.not = coperator.not;

	go to ret;				/* initialize all conditions
			put an initialized item on condition stack
			clear log not switch
			clear the condition operator clear subject */

action (220):
	lev_save = cssub;
	cssub = cssub + 1;
	SUBJ_REQ = "1"b;				/* CS(cssub) = 0 */

	cstack_ptr = addr (cstack (cssub));
	cstack_bits, lognot, coperator_bits, subject_bits = "0"b;
						/*[5.3-2]*/
	iscond = "0"b;

	go to ret;				/* put on stack the following item
			(  logical  not  true  false
			within this item set not = log_not
			set logical true false = 0
			set log_not = 0 */

action (221):					/*[4.4-12]*/
	cstack.subj_req (cssub) = SUBJ_REQ;
	cssub = cssub + 1;
	SUBJ_REQ = "1"b;

	cstack_ptr = addr (cstack (cssub));
	cstack_bits = "0"b;

	cstack.leftpar (cssub) = "1"b;
	cstack.not (cssub) = lognot;
	cstack.parity (cssub) = bool (cstack.parity (cssub - 1), lognot, "0110"b);

	lognot = "0"b;
	go to ret;

/* set log_not = to 1 */

action (222):
	lognot = "1"b;
	go to ret;

/* set not field in operation = to 1 */

action (223):
	coperator.not = "1"b;
	go to ret;

/* move operation type from item in window to condition operator */

action (224):
	coperator.op = reserved_word.key;
	go to ret;

/* pop stack to subject
			set bit logical on cstack to 1
			set bit compare on type inside coperator to 0 normal compare
			move operation type from window to cop*/

action (225):					/* SUB = CS(cssub) */
	cstack_ptr = addr (cstack (cssub));
	subject_bits = cstack_bits;			/*[4.4-3]*/
	is_not_rel = "0"b;

	cssub = cssub - 1;
	cstack.logical (cssub) = "1"b;
	coperator.comp = "0"b;

	go to ret;

/* set bit compare type to 1 ( abbreviated relation ) */

action (226):
	coperator.comp = "1"b;

/*[4.4-3]*/
	if is_not_rel				/*[4.4-3]*/
	then call diag (274);			/*[4.4-3]*/
	else /*[4.2-6]*/
	     if fixed_common.comp_level <= "2"
	then call lev_diag (18);			/* abbrev rel cond */
	go to ret;

/* clear the subject */

action (227):					/* SUB = 0 */
	subject_bits = "0"b;

	go to ret;

/* move stored_operation to cop fields
			and set bit compare type to 1 for abbreviation */

action (228):
	coperator.op = soperator.op;
	coperator.not = soperator.not;
	coperator.comp = "1"b;

/*[4.2-6]*/
	if fixed_common.comp_level <= "2"
	then call LEV_DIAG (18, oploc.line, oploc.col);	/* abbrev rel cond */
	go to ret;

/* move cop and coperator.not fields from coperation to soperation */

action (229):
	if fixed_common.comp_level < "3"		/*[4.2-4]*/
	then do;
		if op.non_numeric | left.non_numeric	/*[4.2-4]*/
		then /*[4.2-4]*/
		     if op.length ^= 0 & left.length ^= 0 /*[4.2-4]*/ & /*[4.2-4]*/ op.length ^= left.length
						/*[4.0-6]*/
		     then call LEV_DIAG (11, left.line, left.col);
						/* unequal size operands */
	     end;

	if fixed_common.comp_level < "5"
	then call type_comp;			/*[3.0-10]*/

/*[4.4-1]*/
	if arith_op				/*[4.4-1]*/
	then do;
		call ae_diag (13);			/* ae in rel cond */
						/*[4.4-1]*/
		arith_op = "0"b;			/*[4.4-1]*/
	     end;

	soperator.op = coperator.op;
	soperator.not = coperator.not;
	go to ret;

/*[3.0-10]*/
type_comp:
     proc;

/*[]*/
	if left.index				/*[]*/
	then if op.index				/*[]*/
	     then return;				/*[]*/
	     else if op.numeric			/*[]*/
	     then if op.integer			/*[]*/
		then return;			/*[]*/
		else call lev_diag (171);		/*[]*/
	     else call lev_diag (170);		/*[]*/
	else /*[]*/
	     if op.index				/*[]*/
	then if left.numeric			/*[]*/
	     then if left.integer			/*[]*/
		then return;			/*[]*/
		else call lev_diag (171);		/*[]*/
	     else call lev_diag (170);		/*[]*/
	else /*[]*/
	     if left.numeric			/*[]*/
	then if op.numeric				/*[]*/
	     then return;				/*[]*/
	     else if left.integer			/*[]*/
	     then return;				/*[]*/
	     else call lev_diag (171);		/*[]*/
	else /*[]*/
	     if op.numeric				/*[]*/
	then if op.integer				/*[]*/
	     then return;				/*[]*/
	     else call lev_diag (171);		/*[]*/
						/*[]*/
	return;

     end;

/*[3.0-10]*/
/* pop condition stack by one
			move stack ite m to active logical */
action (230):					/*[4.0-6]*/
	if lognot					/*[4.0-6]*/
	then if fixed_common.comp_level <= "2"		/*[4.0-6]*/
	     then call LEV_DIAG (16, not.line, not.col);	/*negated simple condition */

	cssub = cssub - 1;

/* AL = CS(cssub) */

	cstack_ptr = addr (cstack (cssub));
	act_log_bits = cstack_bits;

	cssub = cssub - 1;
	go to ret;

/* if not field in active logical = 1 ,
			exchange true and false tag fields,
			and reverse the log_not switch*/
/* then set not in active logical to    */

action (231):
	if act_log.not
	then do;					/* act_log.true == act_log.false */
		holdatrue = act_log.true;
		act_log.true = act_log.false;
		act_log.false = holdatrue;
		lognot = ^lognot;
		act_log.not = "0"b;
	     end;
	go to ret;

/* pop stack to work.
			if bit not in work  = 1
			then exchange true and false in work .
			output equivalince ( true of work, tuue of active).
			output equivalince (false of work, false of active ) */

action (232):					/* WK = CS(cssub) */
	cstack_ptr = addr (cstack (cssub));
	work_bits = cstack_bits;

	cssub = cssub - 1;

/*[5.1-1]*/
	call EQ (work.true, act_log.true);

/*[5.1-1]*/
	call EQ (work.false, act_log.false);

/*[5.1-1]*/
	if work.not				/* work.true == work.false */
						/*[5.1-1]*/
	then do;
		holdatrue = act_log.true;		/*[5.1-1]*/
		act_log.true = act_log.false;		/*[5.1-1]*/
		act_log.false = holdatrue;		/*[5.1-1]*/
		lognot = ^lognot;			/*[5.1-1]*/
	     end;

	go to ret;

/* do an out_operator with param = 1
			put active logical on stack */

action (233):					/*[4.2-6]*/
	andor.line = reserved_word.line;
	andor.col = reserved_word.column;		/* save loc of ANDOR */

	call TEST (act_log.false, "1001"b);
	cssub = cssub + 1;				/* CS(cssub) = AL */

	cstack_ptr = addr (cstack (cssub));
	cstack_bits = act_log_bits;

	go to ret;				/* do an out_operator with parameter = 0 .
			do an out_odeclatation with paramerer = false of active.
			put active logical on stack */
action (234):					/*[4.2-6]*/
	andor.line = reserved_word.line;
	andor.col = reserved_word.column;		/* save loc of ANDOR */

	call TEST (act_log.true, "0110"b);
	if act_log.false ^= 0
	then call DEF (act_log.false);
	cssub = cssub + 1;				/* CS(cssub) = AL */

	cstack_ptr = addr (cstack (cssub));
	cstack_bits = act_log_bits;

	go to ret;

/* do an out_operator with parameter = 1.
			do an out_equivalence with parameter = false of active and false of stack.
			do an out declatation with paramiter =
			true of acteve */

action (235):					/*[4.2-6]*/
	andor.line = reserved_word.line;
	andor.col = reserved_word.column;		/* save loc of ANDOR */

	call TEST (act_log.false, "1001"b);

/*[4.4-5]*/
	call EQ (act_log.false, cstack.false (cssub));




	if act_log.true ^= 0
	then call DEF (act_log.true);
	go to ret;

/* exchange active with top of stack. */

action (236):					/* AL == CS(cssub) */
	cstack_ptr = addr (cstack (cssub));
	work_bits = act_log_bits;
	act_log_bits = cstack_bits;
	cstack_bits = work_bits;

	go to ret;				/* do an out operator with parameter = 1 */
						/* do an out declaration with parameter = true of active
			put active on stack*/
action (237):
	call TEST (act_log.false, "1001"b);

	if act_log.true ^= 0
	then call DEF (act_log.true);
	cssub = cssub + 1;				/* CS(cssub) = AL */
	cstack_ptr = addr (cstack (cssub));
	cstack_bits = act_log_bits;
	go to ret;

dcl	EOF		fixed bin;

action (238):					/*[4.4-5]*/
	call emit_type_13 (63, EOF);

/*[4.4-5]*/
	call def_false;



	go to ret;				/* pop stack to active */
action (239):					/* AL = CS(cssub) */
						/*[5.3-2]*/
	ST.option (nest_lev) = "1"b;			/*[5.3-2]*/
	if EOF ^= 0
	then call out_equiv (EOF, ST.h (nest_lev));	/*[5.3-2]*/
	EOF = ST.h (nest_lev);
	cstack_ptr = addr (cstack (cssub));
	act_log_bits = cstack_bits;
	cssub = cssub - 1;
	UB_ind = "0"b;
	go to ret;

/* do an out declaration with param = false of active
			put active logical on stack and sub 1 from nested if statenent counter  */

action (240):					/*[4.4-5]*/
	call def_false;



	go to ret;

/* move window item to store _label_1. */

action (241):
	substr (addr (store_label_1) -> itemsize, 1, header.size) = substr (head_ptr -> itemsize, 1, header.size);
	go to ret;

/* move window item to store_label_2.
			move special operator go depending to window.      not done noow
			note the go depending is recognized
			by verv subroutine and appropriate
			processing takes paace to deal
			with stored label_1 and label_2 . *?*/

action (242):
	substr (addr (store_label_2) -> itemsize, 1, header.size) = substr (head_ptr -> itemsize, 1, header.size);
	header.type = 1;
	reserved_word.verb = "1"b;
	reserved_word.imper_verb = "1"b;
	reserved_word.key = 14;
	gotodep = "1"b;
	go to ret;				/* do an out_operator with parameter = 0.
	do an out_equivalence with paaramiter  =
	true of active and stored_lavel_1.
	move zero to true of active . */

action (243):
	call TEST (act_log.true, "0110"b);

/*[4.4-5]*/
	call EQ (act_log.true, store_label_1.proc_num);




	act_log.true = 0;
	go to ret;				/* do an out operator with param = 0 */
action (244):
	call TEST (act_log.true, "0110"b);

	ST.h (nest_lev) = 0;

	call EQ (act_log.true, next_sent_label);




	act_log.true = 0;
	go to ret;

/* pop stack to logical active
			do an out declaration with param = false of active
			do an out declaration with param = true of active 
			and reset nested if statement counter*/

action (245):					/*NOT USED */
						/*[4.4-5]*/
	call act245;
	go to ret;

act245:
     proc;



/* AL = CS(cssub) */
	cstack_ptr = addr (cstack (cssub));
	act_log_bits = cstack_bits;

	cssub = cssub - 1;


	if act_log.false ^= 0
	then call DEF (act_log.false);
	if act_log.true ^= 0
	then call DEF (act_log.true);



     end;						/* output an unconditional branch to use(true of stack) */
action (246):
	if cssub = 0
	then go to ret;

	TAG = cstack.true (cssub);

	if TAG = 0
	then cstack.true (cssub), opeos.h = assign_value ();


	else opeos.h = TAG;

	opeos.verb = 13;
	opeos.e = 63;
	seqvarptr = opeosptr;
	seqvarleng = opeos.size;
	call seqput;
	go to ret;

/* declare all true and false labels for the PERFORM verb*/

action (247):
	dumprocname.searched = "1"b;
	dumprocname.duplicate = "1"b;

	if next_sent_label ^= 0
	then call DEF (next_sent_label);

	if cssub ^= 0
	then do;					/* AL = CS(cssub) */

		cstack_ptr = addr (cstack (cssub));
		act_log_bits = cstack_bits;

		cssub = cssub - 1;
		if act_log.true ^= 0
		then call DEF (act_log.true);
		dumprocname.duplicate = "0"b;
		if act_log.false ^= 0
		then call DEF (act_log.false);

	     end;

	dumprocname.searched = "0"b;

	go to ret;

action (248):					/* default device for accept */
	code_option = 29;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

action (249):					/* default device for display */
	code_option = 30;
	if ^ST.skip_ind (nest_lev)
	then call cobol_pd_code$code;
	go to ret;

/* compiler error */
action (250):
	return;

action (251):
	if fatal_no ^= 0
	then go to endint;
	else go to ret;

/* save smallest range -- used for set verb */
action (252):
	if savitmptr -> index_name.max ^> index_name.max
	then go to ret;
	call act28;
	go to ret;				/* set input_error_exit for use procedure */

action (253):
	input_error_exit = cursecnum;
	go to ret;

/* set output_error_exit for use procedure */

action (254):
	output_error_exit = cursecnum;
	go to ret;

/* set i_o_error_exit for use procedure */

action (255):
	i_o_error_exit = cursecnum;
	go to ret;

/* set extend_error_exit for use procedure */

action (256):
	extend_error_exit = cursecnum;
	go to ret;

/* set read bit in file_table - in core from check (89) */

action (257):
	file_table.read = "1"b;
	go to ret;

/* set read_next bit in file_table - in core from check (23) */

action (258):					/*[5.3-2]*/
	iscond = "1"b;
	go to ret;

/* set read_key bit in file_table - in core from check (20) */

action (259):
	file_table.read_key = "1"b;
	go to ret;

/* set rewrite bit in file_table - in core from check (70) */

action (260):
	file_table.rewrite = "1"b;
	call act28;
	go to ret;				/* set write bit in file_table - in core from check (70) */

action (261):
	file_table.write = "1"b;
	call act28;
	go to ret;				/* set start bit in file_table - in core from check (155) */

action (262):
	file_table.start = "1"b;
	go to ret;

/* set open_in bit in file_table - not in core */

action (263):
	if fd_token.file_no = 0
	then go to ret;

	call cobol_read_ft_ (fd_token.file_no, ft_ptr);

	go to SM (op_mode);

SM (1):
	open_in = "1"b;
	go to SM1;				/* input */

SM (2):
	open_out = "1"b;
	go to SM1;				/* output */

SM (3):
	open_io = "1"b;
	go to SM1;				/* io */

SM (4):
	open_ext = "1"b;
	go to SM1;				/* extend */

SM1:
	go to action (28);

action (264):
	left_bits = op_bits;

	go to ret;

action (265):					/*[4.4-6]*/
	call set_op_loc;

	go to ret;

action (266):					/*[5.3-2]*/
	ST.cond (nest_lev) = "0"b;			/*[5.3-2]*/
	if ST.end_wd (nest_lev) = 14
	then if ST.ns (nest_lev)
	     then call diag (316);
	     else ;
	else call pop_state;

	go to ret;				/* set rounded bit in saved item --- output saved item */
action (267):
	savitmptr -> data_name.rounded = "1"b;
	seqvarptr = savitmptr;
	seqvarleng = saveitem.size;
	call seqput;
	go to ret;				/* output saved item */

action (268):
	seqvarptr = savitmptr;
	seqvarleng = saveitem.size;
	call seqput;
	go to ret;				/* add 1 to operand count
			save current item for add verb*/
action (269):
	end_stmt.h = end_stmt.h + 1;
	substr (sav_ptr -> itemsize, 1, header.size) = substr (addr_record -> itemsize, 1, header.size);
	go to ret;

action (270):					/*[5.3-2]*/
	ST.option (nest_lev) = "1"b;			/*[5.3-2]*/
	end_stmt.b = "1"b;				/*[5.3-2]*/
	call seqputeos;				/*[5.3-2]*/
	if ST.end_wd (nest_lev) = 2
	then call save_skip_ind;			/* CALL */


	go to ret;

/* add 1 to operand count in format 1 of multiply verb
	save current item */

action (271):
	end_stmt.e = end_stmt.e + 1;
	substr (sav_ptr -> itemsize, 1, header.size) = substr (addr_record -> itemsize, 1, header.size);
	cssavebit = data_name.constant_section;
	go to ret;

action (272):
	if decswitch = 1 & ^proc_def.declarative_proc
	then call diag (263);
	go to ret;

end_sent:
     proc;

/*[5.1-2]*/
	LTP, last_wd_per = "1"b;

/*[4.4-8]*/
	sav_bit = "0"b;

/*[4.4-5]*/
	if next_sent_label ^= 0
	then call DEF (next_sent_label);

/*[4.4-5]*/
	do while (cssub > 0);
	     call act245;
	end;

     end;

action (273):					/*[4.4-1]*/
	call end_sent;
	go to ret;

action (274):					/*[4.4-1]*/
	call end_sent;
	call seqputeos;
	go to ret;

action (275):
	call act275;
	go to ret;
act275:
     proc;

/*[5.3-2]*/
	nest_lev = 1;
	call reset_st;
	call act49;
     end;

action (276):
	coperator.not = "0"b;
	go to ret;

action (277):
	end_stmt.d = "01"b;
	go to ret;

action (278):					/*[4.1-7]*/
	call DIAG (248);				/* Item declared in CONSTANT section */
	go to ret;

action (279):					/*[4.4-6]*/
	sub_loc = 0;
	call set_op_loc;
	call act113;
	go to ret;

action (280):
	sub_loc = sub_loc + 1;

	subs (sub_loc) = fixed (numeric_lit.literal);
	numeric_lit.subscript = "1"b;
	go to ret;

action (281):
	key = fixed (numeric_lit.literal);

	if key < min_index | key > max_index
	then call diag (270);			/* DIAG(270) */

	go to ret;

action (282):
	min_index = 0;
	max_index = 99999;

	addr (set_sop) -> set_sop_mask = "0"b;

	go to ret;

action (283):					/*[5.3-2]*/
	if ST.nif (nest_lev) > 1			/*[5.3-2]*/
	then if fixed_common.comp_level < "3"		/*[5.3-2]*/
	     then call lev_diag (12);





	go to action (42);

action (284):
	SAE = "0"b;

	go to ret;

action (285):					/*[3.0-10]*/
	call set_op_loc;				/*[4.4-6]*/

	go to ret;				/*[3.0-10]*/

action (286):					/*[3.0-12] issue leveling diag 169 */
	if fixed_common.comp_level < "5"
	then call lev_diag (169);

	call end_sent;
	call seqputeos;
	go to ret;
action (287):					/*[3.0-13]  issue leveling diag 172 */
	if data_name.level ^= 1
	then if data_name.level ^= 77			/*[4.4-10]*/
	     then do;
		     if fixed_common.comp_level < "5"
		     then call lev_diag (172);

/*[4.4-10]*/
		     if mod (data_name.offset, 4) ^= 0
		     then call diag (30);

/*[4.4-10]*/
		end;

	end_stmt.e = end_stmt.e + 1;
	go to ret;


action (288):					/*[3.0-15] Set vfile_ key in opeos.e for start and read statements */
	if header.type = 12
	then end_stmt.e = 511;
	else end_stmt.e = vfile_key;

	go to ret;

action (289):					/* in-line perform */
						/*[4.0-4]*/
	end_stmt.d = "01"b;

/*[4.4-5]*/
	ST.e (nest_lev) = assign_value ();		/*[4.4-5]*/
	ST.h (nest_lev) = assign_value ();



/*[4.0-4]*/
	call emit_pn (ST.e (nest_lev));		/*[4.0-4]*/
	call emit_pn (ST.h (nest_lev));

	go to ret;

emit_pn:
     proc (tagno);

/*[4.0-4]*/
declare	tagno		fixed bin;

/*[4.0-4]*/
	dumprocname.type = 18;			/*[4.0-4]*/
	dumprocname.proc_num = tagno;

/*[4.0-4]*/
	seqvarptr = dpnptr;				/*[4.0-4]*/
	seqvarleng = dumprocname.size;

/*[4.0-4]*/
	call seqput;

     end;

action (290):					/*[5.3-2]*/
	if nest_lev > 1
	then call test_stack;

/*[5.3-2]*/
	nest_lev = 1;				/*[5.3-2]*/
	call reset_st;

	go to ret;

test_stack:
     proc;

/*[5.3-2]*/
dcl	i		fixed bin,
	res		bit (1);

/*[5.3-2]*/
	i = nest_lev;				/*[5.3-2]*/
	EW = ST.end_wd (i);

/*[5.3-2]*/
	if EW ^= 7				/* if */
						/*[5.3-2]*/
	then do;
		i = i - 1;			/*[5.3-2]*/
		EW = ST.end_wd (i);			/*[5.3-2]*/
	     end;

/*[5.3-2]*/
	res = "0"b;

/*[5.3-2]*/
	do i = i by -1 to 1 while (res = "0"b);		/*[5.3-2]*/
	     if ST.end_wd (nest_lev) ^= 7
	     then res = "1"b;			/*[5.3-2]*/
	end;

/*[5.3-2]*/
	if res
	then call diag (145);

     end;

emit_eos_perf:
     proc;

/*[4.0-4]*/
	end_stmt.verb = 20;				/*[4.0-4]*/
	if ST.a (nest_lev) = "000"b
	then end_stmt.a = "000"b;
	else end_stmt.a = "110"b;			/*[4.0-4]*/
	end_stmt.e = ST.e (nest_lev);			/* L1 */
						/*[4.0-4]*/
	end_stmt.h = ST.h (nest_lev);			/* L3 */

/*[4.0-4]*/
	call seqputeos;

     end;

action (291):					/* dispatch on end word */
	go to ret;

/*[4.0-4]*/

action (292):					/* not form of an option */
						/*[5.3-2]*/
	ST.not_opt (nest_lev) = "1"b;			/*[4.0-4]*/
	end_stmt.f = "01"b;
	go to ret;

action (293):					/* option code terminator, type=19, vt=3 */
						/*[5.3-2]*/
	call a294 ("00"b);

	go to ret;






action (294):					/* option code terminator, type=19, vt=3 */
	call a294 ("01"b);
	go to ret;

a294:
     proc (f);					/*[5.3-2]*/
dcl	f		bit (2);			/*[5.3-2]*/
	end_stmt_chars = saveos;			/*[5.3-2]*/
	end_stmt.verb = 3;				/*[4.0-4]*/
	end_stmt.b = "1"b;				/* option code follows */
						/*[5.3-2]*/
	end_stmt.f = f;				/*[4.0-4]*/
	call seqputeos;
     end;

action (295):					/*[4.0-4]*/
	string (ST.desc (nest_lev)) = addr (end_stmt.a) -> bit16;
	go to ret;

action (296):					/*[4.0-4]*/
	addr (end_stmt.a) -> bit16 = string (ST.desc (nest_lev));
	go to ret;

action (297):					/*[4.2-6]*/
	not.line = reserved_word.line;		/*[4.2-6]*/
	not.col = reserved_word.column;		/* save loc of NOT */

	go to ret;

action (298):					/*[4.2-6]*/
	if fixed_common.comp_level <= "2"		/*[4.2-6]*/
	then do;
		if reserved_word.section_header	/*[4.2-6]*/
		then call LEV_DIAG (16, not.line, not.col);
						/* negated simple condition */
						/*[4.2-6]*/
		else call LEV_DIAG (215, not.line, not.col);
						/* negated combined condition */
						/*[4.2-6]*/
	     end;
	go to ret;

action (299):					/*[4.4-3]*/
	is_not_rel = "1"b;

/*[5.3-1]*/
	if cssub > 0
	then cstack.c.logical (cssub - 1) = "1"b;

/*[4.4-1]*/
	if arith_op				/*[4.4-1]*/
	then do;
		call ae_diag (177);			/* ae in rel cond */
						/*[4.4-1]*/
		arith_op = "0"b;			/*[4.4-1]*/
	     end;					/*[4.4-1]*/
	go to action (224);

action (300):					/*[4.4-2]*/
	if ^LTP
	then call DIAG_PREV_TOKEN (279);		/* missing period */
	call act87;
	go to ret;

action (301):					/*[5.3-2]*/
	ST.option (nest_lev) = "1"b;
	call act37;
	go to ret;

action (302):					/*[5.3-2]*/
	ST.option (nest_lev) = "1"b;
	end_stmt.a = "001"b;
	call act109;
	go to ret;

action (303):					/*[5.3-2]*/
	ST.option (nest_lev) = "1"b;
	end_stmt.b = "1"b;
	call seqputeos;
	go to ret;
action (304):					/*[5.3-2]*/
	ST.option (nest_lev) = "1"b;
	end_stmt.b = "1"b;
	go to ret;

action (305):					/*[5.3-2]*/
	ST.cond (nest_lev - 1) = "0"b;

/*[5.3-2]*/
	if ST.e (nest_lev) ^= 0
	then call emit_eos_perf;
	go to ret;


action (306):					/*[4.4-5]*/
	ST.option (nest_lev) = "0"b;			/* else has not occurred */
						/*[5.3-2]*/
	ST.nif (nest_lev) = ST.nif (nest_lev) + 1;	/*[4.4-5]*/
	ST.h (nest_lev) = assign_value ();		/*[4.4-5]*/
	EOF = 0;
	go to ret;

set_op_loc:
     proc;					/*[4.4-6]*/
	call TOK_TYPE;				/*[4.4-6]*/
	op.loc = mptr;
     end;

action (307):					/*[4.4-6]*/
	call act211;
	go to ret;

emit_type_13:
     proc (op, tag);

declare	(op, tag)		fixed bin;

	opeos.verb = 13;
	opeos.e = op;
	opeos.h = tag;
	seqvarptr = opeosptr;
	seqvarleng = opeos.size;

	call seqput;

     end;

action (308):					/*[5.1-3]*/
	ST.h (nest_lev) = assign_value ();		/*[5.3-2]*/
	ST.option (nest_lev) = "1"b;			/*[4.4-5]*/
	if act_log.false ^= 0
	then call DEF (act_log.false);

/*[4.4-5]*/
	UB_ind = "0"b;

	go to ret;

def_false:
     proc;

/*[4.4-5]*/
	if act_log.false ^= 0
	then call DEF (act_log.false);		/*[4.4-5]*/
	UB_ind = "0"b;

     end;

action (309):					/*[4.4-6]*/
	call set_op_loc;
	go to ret;


action (310):					/*[5.3-2]*/
	end_stmt_bits = "0"b;
	end_stmt.verb = 3;
	call seqputeos;
	go to ret;

assign_value:
     proc returns (fixed bin);

	spec_tag_counter = spec_tag_counter + 1;

	return (spec_tag_counter);

     end;

action (311):
	if next_sent_label = 0
	then next_sent_label = assign_value ();

	go to ret;

action (312):					/*[5.3-2]*/
	ST.cond (nest_lev) = "0"b;

	go to ret;

action (313):
	call def_false;
	call DEF (ST.h (nest_lev));
	go to ret;

action (314):					/*NOT USED*/
	go to ret;

action (315):					/*[5.3-2]*/
	ST.not_opt (nest_lev) = "1"b;
	end_stmt.f = "01"b;
	ST.option (nest_lev) = "1"b;
	call act37;
	go to ret;

action (316):					/*NOT USED*/
	go to ret;

action (317):
	call a294 ("01"b);
	UB_ind = "0"b;
	go to ret;

action (318):					/*[4.4-8]*/
	call sav_lin_col;
	call act87;
	go to ret;

sav_lin_col:
     proc;

/*[4.4-8]*/
	sav.line = header.line;
	sav.column = header.column;			/*[4.4-8]*/
	sav_bit = "1"b;

     end;

action (319):					/*[4.4-8]*/
	sav_bit = "0"b;
	go to ret;

action (320):					/*[4.4-8]*/
	call sav_lin_col;
	call act119;
	go to ret;

action (321):					/*[4.4-8]*/
	call sav_lin_col;
	go to ret;

inc_nest_lev:
     proc;

/*[5.3-2]*/
	ST.srchfm2bit (nest_lev) = srchfm2bit;		/*[5.3-2]*/
	nest_lev = nest_lev + 1;			/*[5.3-2]*/
	call reset_st;				/*[5.3-2]*/
	ST.nif (nest_lev) = ST.nif (nest_lev - 1);	/*[5.3-2]*/
	ST.skip_ind (nest_lev) = ST.skip_ind (nest_lev - 1);
     end;

dec_nest_lev:
     proc;

/*[5.3-2]*/
	nest_lev = nest_lev - 1;			/*[5.3-2]*/
	ST.ns (nest_lev) = bool (ST.ns (nest_lev), ST.ns (nest_lev + 1), "0111"b);
						/*[5.3-2]*/
	if ST.end_wd (nest_lev) = 7
	then if ST.option (nest_lev)
	     then call DEF (ST.h (nest_lev));		/*[5.3-2]*/
	srchfm2bit = ST.srchfm2bit (nest_lev);
     end;

reset_st:
     proc;

/*[5.3-2]*/
	addr (ST (nest_lev)) -> bit180 = "0"b;



     end;

action (322):					/*[4.4-8]*/
	sort_count = sort_count + 1;			/*[4.4-8]*/
	if fixed_common.comp_level < "4"		/*[4.4-8]*/
	then if sort_count > 1			/*[4.4-8]*/
	     then call lev_diag (165);

	go to ret;

action (323):					/*[4.4-9]*/
	end_stmt.a = "000"b;
	go to action (3);

action (324):					/* STOP RUN */
						/*[4.4-11]*/
	if fixed_common.init_cd
	then end_stmt.a = "010"b;

/*[4.4-11]*/
	UB_ind = "1"b;
	go to ret;

action (325):					/*[4.4-12]*/
	SUBJ_REQ = "1"b;
	go to ret;

action (326):					/*[4.4-12]*/
	SUBJ_REQ = cstack.subj_req (cssub);
	go to ret;

action (327):					/*[4.4-12]*/
	SUBJ_REQ = "0"b;
	go to ret;

action (328):					/*[4.4-2]*/
	call DIAG_PREV_TOKEN (279);
	call end_sent;
	call seqputeos;
	go to ret;

action (329):					/*[4.4-2]*/
	call DIAG_PREV_TOKEN (279);
	go to ret;

action (330):					/*[4.4-2]*/
	call DIAG_PREV_TOKEN (279);
	call act275;
	go to ret;

action (331):					/*[4.4-2]*/
	call DIAG_PREV_TOKEN (279);
	call seqputeos;
	go to ret;

/*[5.0-1]*/
dcl	cobol_idedsyn$get_seg_limit
			entry returns (fixed bin);

/*[5.0-1]*/
dcl	seg_limit		fixed bin;

action (332):					/*[5.0-1]*/
	if seg_limit = 0				/*[5.0-1]*/
	then call ESD ("2", 7, 79);			/* 1SEG, LI */
						/*[5.0-1]*/
	else if seg_num ^= 0			/*[5.0-1]*/
	then if seg_num < seg_limit			/*[5.0-1]*/
	     then call ESD ("2", 7, 79);		/* 1SEG, LI */
						/*[5.0-1]*/
	     else call ESD ("4", 8, 222);		/* 2SEG, H */

/*[5.0-1]*/
	go to ret;

action (333):					/*[5.3-2]*/
	ST.ns (nest_lev) = "1"b;
	go to ret;

action (334):					/*[5.3-2]*/
	if ST.ns (nest_lev)				/*[5.1-3]*/
	then do;
		call diag (304);			/*[5.1-3]*/
		ns_found = "0"b;			/*[5.1-3]*/
	     end;					/*[5.3-2]*/
	ST.cond (nest_lev) = "0"b;			/*[5.3-2]*/
	call pop_if;
	go to ret;

ESD:
     proc (cl, md_num, dg_num);

/*[5.0-1]*/
dcl	cl		char (1),
	(md_num, dg_num)	fixed bin;

/*[5.0-1]*/
	if fixed_common.comp_level < cl		/*[5.0-1]*/
	then do;
		mod_num = md_num;			/*[5.0-1]*/
		call lev_diag (dg_num);		/*[5.0-1]*/
	     end;

     end;


declare	(key, min_index, max_index)
			fixed bin;


/* source card entry to print routine */

read_error:
	go to endint;

write_error:
	go to endint;

endint:						/* check all files for mismatches on history bits */
						/*[5.1-5]*/
						/* These diags were never issued and dont make much sense

	diag_item.line=0;
	diag_item.column=0;
	fi_ct=0;
nxtfilchk:
	fi_ct=fi_ct+1;

	if fi_ct > fixed_common.file_count then go to endhist;

	call cobol_read_ft_(fi_ct ,  ft_ptr);

	if file_table.external then go to nxtfilchk;

	if close & ( open_in | open_out |open_io | open_ext )
		then go to nxtfilchk;

	diag_item.number=192;
	if close then go to nxtdiag;

	diag_item.number=193;
	if (open_in | open_out | open_io | open_ext ) then go to nxtdiag;

	diag_item.number=194;
	if delete then go to nxtdiag;
	diag_item.number=195;
	if read then go to nxtdiag;
	diag_item.number=196;
	if rewrite then go to nxtdiag;
	diag_item.number=197;
	if write then go to nxtdiag;
	diag_item.number=198;
	if read_next then go to nxtdiag;
	diag_item.number=199;
	if read_key then go to nxtdiag;
	diag_item.number=200;
	if file_table.start then go to nxtdiag;

go to nxtfilchk;

nxtdiag:
	call cobol_c_list(dg_ptr);
go to nxtfilchk;

*/						/*[5.1-5]*/
endhist:
	diag_item.column = header.column;
	diag_item.line = header.line;
	call cobol_c_list (null ());
	return;


declare	(addr, fixed, null, substr, unspec, min, max, bool, string, abs, mod)
			builtin;

declare	(sav_ptr, head_ptr) ptr;

/* The following pointers are used to overlay structures as bit strings */

declare	(act_log_ptr, work_ptr, subject_ptr, soperator_ptr, es_ptr)
			ptr;
declare	(coperator_ptr, cstack_ptr, astack_ptr, end_stmt_ptr)
			ptr;

/* the following bit strings are used to overlay structures */

declare	act_log_bits	bit (124) based (act_log_ptr);
declare	work_bits		bit (124) based (work_ptr);
declare	subject_bits	bit (124) based (subject_ptr);
declare	soperator_bits	bit (124) based (soperator_ptr);
declare	coperator_bits	bit (124) based (coperator_ptr);
declare	cstack_bits	bit (124) based (cstack_ptr);
declare	astack_bits	bit (88) based (astack_ptr);
declare	end_stmt_bits	bit (197) based (end_stmt_ptr);
declare	op_bits		bit (185) based (op_ptr);
declare	left_bits		bit (185) based (left_ptr);

/*[5.3-2]*/
dcl	bit180		bit (180) based;		/*[5.3-2]*/
dcl	bit16		bit (16) based;		/*[5.3-2]*/
dcl	iscond		bit (1);			/*[5.3-2]*/
dcl	ky		fixed bin;

declare	(file_org, seg_num, op_mode, mod_num, act_num, EW)
			fixed bin;
declare	last_seg_num	fixed bin init (1000);	/*[3.0-10]*/
						/*[]*/
declare	(op_ptr, left_ptr)	ptr;			/*[]*/
declare	bit5		bit (5) based;		/*[]*/
						/*[]*/
declare	1 op,					/*[]*/
	  2 loc		ptr,			/*[]*/
	  2 length	fixed bin,		/*[]*/
	  2 line		fixed bin,		/*[]*/
	  2 col		fixed bin,		/*[]*/
	  2 descr,				/*[]*/
	    3 index	bit (1),			/*[]*/
	    3 numeric	bit (1),			/*[]*/
	    3 non_numeric	bit (1),			/*[]*/
	    3 integer	bit (1),			/*[]*/
	    3 op_lit	bit (1);			/*[]*/
						/*[]*/
declare	1 left,					/*[]*/
	  2 loc		ptr,			/*[]*/
	  2 length	fixed bin,		/*[]*/
	  2 line		fixed bin,		/*[]*/
	  2 col		fixed bin,		/*[]*/
	  2 descr,				/*[]*/
	    3 index	bit (1),			/*[]*/
	    3 numeric	bit (1),			/*[]*/
	    3 non_numeric	bit (1),			/*[]*/
	    3 integer	bit (1),			/*[]*/
	    3 left_lit	bit (1);			/*[3.0-10]*/

/*[4.2-6]*/
declare	1 not,					/*[4.2-6]*/
	  2 line		fixed bin,		/*[4.2-6]*/
	  2 col		fixed bin;

/*[4.2-6]*/
declare	1 andor,					/*[4.2-6]*/
	  2 line		fixed bin,		/*[4.2-6]*/
	  2 col		fixed bin;


declare	sort_count	fixed bin;


/*[4.2-6]*/
declare	1 oploc,					/*[4.2-6]*/
	  2 line		fixed bin,		/*[4.2-6]*/
	  2 col		fixed bin;

declare	seg_usage		(0:99) bit (1) based (seg_usage_ptr);

declare	seg_usage_string	bit (100) init ("0"b);
declare	seg_usage_ptr	ptr;

declare	expind		bit (1);

/*[4.0-1]*/
declare	1 ae,					/*[4.0-1]*/
	  2 line		fixed bin,		/*[4.0-1]*/
	  2 column	fixed bin;

declare	1 set_sop,
	  2 int_lit	bit (1),
	  2 int_data	bit (1),
	  2 ind_data	bit (1);

declare	set_sop_mask	bit (3) based;

declare	pigz_res		fixed bin;

/*[4.0-4]*/
dcl	(KEY, END_WORD, nest_lev)
			fixed bin;



/*[4.0-4]*/
declare	1 ST		(0:255),			/*[4.0-4]*/
	  2 end_wd	fixed bin,		/*[4.0-4]*/
	  2 desc,					/*[4.0-4]*/
	    3 a		bit (3),			/*[4.0-4]*/
	    3 b		bit (1),			/*[4.0-4]*/
	    3 c		bit (1),			/*[4.0-4]*/
	    3 d		bit (2),			/*[4.0-4]*/
	    3 f		bit (2),			/*[4.0-4]*/
	    3 g		bit (2),			/*[4.0-4]*/
	    3 k		bit (5),			/*[4.4-5]*/
	  2 option	bit (1),			/*[5.3-2]*/
	  2 not_opt	bit (1),			/*[5.3-2]*/
	  2 cond		bit (1),			/*[5.3-2]*/
	  2 ns		bit (1),			/*[5.3-2]*/
	  2 skip_ind	bit (1),			/*[5.3-2]*/
	  2 save_skip_ind	bit (1),			/*[5.3-2]*/
	  2 srchfm2bit	bit (1),			/*[5.3-2]*/
	  2 nif		fixed bin,		/*[4.0-4]*/
	  2 e		fixed bin,		/*[4.0-4]*/
	  2 h		fixed bin;


/* The following structure is used when look-ahead is needed to determine if the current symbol is in error */
/* It will contain the column and line number of the current symbol */
/* USED in: MULTIPLY - if identifier-2 followed by GIVING */
/*          DIVIDE - if identifier-2 followed by GIVING */
/*          INSPECT - if REPLACING is used */
/*[4.1-7]*/
declare	01 prev_diag,				/*[4.1-7]*/
	  02 line_num	fixed bin,		/*[4.1-7]*/
	  02 column_num	fixed bin;

/*  This pointer points to the previous token.  It is used when you need some */
/* information on the previous token.   */
/* USED in:	procedure DIAG_PREV_TOKEN */

/*[4.1-7]*/
declare	prev_token_ptr	pointer;
declare	cobol_syntax_trace_$trace
			entry (ptr, fixed bin (24));
declare	cobol_syntax_trace_$initialize_phase
			entry (ptr, fixed bin (24));
declare	(DIAG_NUM, message_ind)
			fixed bin;
declare	tm1		fixed bin (24) init (1),
	tm2		fixed bin (24) init (2),
	tm3		fixed bin (24) init (3),
	tm4		fixed bin (24) init (4),
	tm5		fixed bin (24) init (5);
declare	declprocbit	bit (1);
declare	fi_ct		fixed bin;

/*[3.0-15]*/
dcl	vfile_key		fixed bin;		/*[3.0-15]*/
dcl	kc		fixed bin;

declare	lev_save		fixed bin (24);
declare	subs		(3) fixed bin;
declare	sub_loc		fixed bin;


declare	1 indicators,
	  2 tbit		bit (1),
	  2 res		bit (1),
	  2 SAE		bit (1),			/*[3.0-10]*/
	  2 UB_ind	bit (1) init ("0"b),	/*[4.4-3]*/
	  2 is_not_rel	bit (1),
	  2 SUBJ_REQ	bit (1),
	  2 ns_found	bit (1);

dcl	cobol_swf_get	entry (ptr, bit (32), ptr, fixed bin) ext;
dcl	st		bit (32);
dcl	tln		fixed bin;
dcl	cobol_vdwf_dget	entry (ptr, bit (32), ptr, fixed bin, char (5)) ext;
dcl	cobol_swf_put	entry (ptr, bit (32), ptr, fixed bin) ext;
dcl	cobol_vdwf_sput	entry (ptr, bit (32), ptr, fixed bin, char (5)) ext;
dcl	cobol_vdwf_dput	entry (ptr, bit (32), ptr, fixed bin, char (5)) ext;

/* common area */
dcl	comsrtrngptr	ptr static;		/* points to sort range entry */
						/* the following is a description of common*/
declare	(O1_ptr, O2_ptr)	ptr;

declare	1 O1,
	  2 o1		fixed bin,
	  2 l1		fixed bin;

declare	1 O2,
	  2 o2		fixed bin,
	  2 l2		fixed bin;

declare	cobol_read_ft_	entry (fixed bin, ptr);
declare	cobol_pd_code$initialize
			entry (ptr);
declare	cobol_pd_code$code	entry;

declare	code_env_ptr	ptr;

declare	code_option	fixed bin;

declare	1 code_env,
	  2 arg_1		ptr,
	  2 arg_2		ptr,
	  2 arg_3		ptr,
	  2 arg_4		ptr,
	  2 arg_5		ptr,
	  2 arg_6		ptr;

declare	1 DATA,
	  2 ptr		(100) ptr,
	  2 code_area	(5000) fixed bin (35);

declare	file_number	fixed bin;


dcl	filtabptr		ptr;			/* used to base the file table above */
dcl	ft_ptr		ptr;

/* the following is a layout of the FILE KEY record in COMMON */

dcl	1 file_key	based (fkey_ptr),
	  2 fknext	char (5),
	  2 fknext_alt	char (5),
	  2 fkqual	char (5),
	  2 fkinfo	bit (8),
	  2 fkfile_no	fixed bin,
	  2 fkey_type	fixed bin,
	  2 fkline	fixed bin,
	  2 fkcolumn	fixed bin,
	  2 fb_seg	fixed bin,
	  2 fb_offset	fixed bin (24),
	  2 fklinkage	fixed bin,
	  2 fkfilenum	fixed bin,
	  2 fksize_rtn	fixed bin,
	  2 fklength	fixed bin (24),
	  2 fkplacesleft	fixed bin,
	  2 fkplacesright	fixed bin,
	  2 fkdescription	bit (36),
	  2 fkdescriptiona	bit (36),
	  2 fkseg_num	fixed bin,
	  2 fkoffset	fixed bin (24),
	  2 fkname_size	fixed bin,
	  2 fkname	char (30);

dcl	fkey_ptr		ptr;			/*[4.0-3]*/
dcl	(err, format)	fixed bin;		/* work area */

dcl	sort_key		char (5);			/* used for sort in common */

declare	1 stat		static internal,
	  2 procdef,
	    3 srt_range	bit (1),			/* sort */
	    3 sv_isrbit	bit (1),			/* input range */
	    3 sv_osrbit	bit (1),			/* output range */
	    3 mrg_range	bit (1);			/* merge */

declare	bit9		bit (9) based;

dcl	fi		fixed bin;		/* file index used by history check routine */
dcl	next_sent_label	fixed bin static;		/* uset to store tag number of next sentence after if */

dcl	gotodep		bit (1) static;		/*  for go to depending verb found in an if statement */

dcl	preospn_bit	bit (1) static;		/* used by EXIT verb */
dcl	(dg_ptr, lev_dg_ptr)
			ptr;			/* pointer to diag item passed to print routine*/
						/*  type 5 structure used to construct diagnostics issued by pdsyntax */
dcl	1 diag_item,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 run		fixed bin,
	  2 number	fixed bin,
	  2 info		bit (8),
	  2 multics	char (3);

declare	1 lev_diag_item,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 run		fixed bin,
	  2 number	fixed bin,
	  2 module	fixed bin;

dcl	01 jkperfrng	based (jkpfm_ptr),
	  02 jkperfprocnum	fixed bin,
	  02 jkperfcode	fixed bin,
	  02 jkperflink	char (5),
	  02 jkperflink1	char (5),
	  02 jkperfprio	fixed bin,
	  02 jkperfext	fixed bin;
dcl	jkpfm_ptr		ptr;			/*pointer to junk perform range structure*/
dcl	perform_range_key	char (5);			/*[4.4-1]*/
dcl	(sav_bit, arith_op) bit (1);			/*[5.2-1]*/
dcl	end_decl_bit	bit (1);			/*[4.4-1]*/
declare	1 sav,					/*[4.4-1]*/
	  2 line		fixed bin,		/*[4.4-1]*/
	  2 column	fixed bin;		/* entry for perform alter range table */
dcl	01 perfrange	static,
	  02 perfprocnum	fixed bin,
	  02 perfcode	fixed bin,
	  02 perflink	char (5),
	  02 perflink1	char (5),
	  02 perfprio	fixed bin,
	  02 perfext	fixed bin;


declare	cssavebit		bit (1);
dcl	01 saveperfrange,
	  02 sperpronum	fixed bin,
	  02 spercod	fixed bin,
	  02 sperlin	char (5),
	  02 sperlin1	char (5),
	  02 sperpri	fixed bin,
	  02 sperext	fixed bin;

dcl	savlaskey		char (5);			/* save last key of perform ranfe entry */
dcl	junk_ptr		ptr;			/* used to store ptr from dummy reads */
dcl	shprio		fixed bin;
dcl	prio1		fixed bin;
dcl	prio2		fixed bin;
dcl	srchfm2bit	bit (1) static;		/* format 2 of search verb */
dcl	data_name_bit	bit (1);			/* used by subscript routine */
dcl	index_name_bit	bit (1);			/* used by subscript routine */
dcl	fircar		bit (1) static;		/* firdt card switch for print routine */
dcl	dbp		fixed bin static;		/* diagnostic buffer pointer */
dcl	drc		fixed bin (9) static;	/* diagnostic reference counter */
dcl	common_key	char (5);			/* record no of common file just read or to be read */
dcl	common_recsize	fixed bin;		/* size of record just read from common file */
dcl	common_eof	bit (1) static;		/* set on if eof encountered on read of common */

/* needed for function call */
/* parmeter used for action 233 */
dcl	param		bit (1);			/* active logical */
						/* arithmetic stack */
declare	1 astack		(25),
	  2 key		fixed bin,
	  2 filler	fixed bin,
	  2 a,
	    3 unmin	bit (1),			/* unary minus */
	    3 lefpar	bit (1),			/* left paren */
	    3 filler	bit (14);

/* conditional stack */

declare	1 cstack		(75),
	  2 true		fixed bin,
	  2 false		fixed bin,
	  2 length	fixed bin,
	  2 c,
	    3 logical	bit (1),
	    3 not		bit (1),
	    3 numerical	bit (1),
	    3 operand	bit (1),
	    3 alphabetic	bit (1),
	    3 arithexp	bit (1),
	    3 leftpar	bit (1),
	    3 parity	bit (1),
	    3 data_name	bit (1),
	    3 subj_req	bit (1),
	    3 filler	bit (5);

/* active logical */

declare	1 act_log,
	  2 true		fixed bin,
	  2 false		fixed bin,
	  2 length	fixed bin,
	  2 a,
	    3 logical	bit (1),
	    3 not		bit (1),
	    3 numerical	bit (1),
	    3 operand	bit (1),
	    3 alphabetic	bit (1),
	    3 arithexp	bit (1),
	    3 leftpar	bit (1),
	    3 parity	bit (1),
	    3 filler1	bit (8);

/* work area */

declare	1 work,
	  2 true		fixed bin,
	  2 false		fixed bin,
	  2 length	fixed bin,
	  2 w,
	    3 logical	bit (1),
	    3 not		bit (1),
	    3 filler1	bit (5),
	    3 parity	bit (1),
	    3 filler	bit (8);

/* subject of relation */

declare	1 subject,
	  2 true		fixed bin,
	  2 false		fixed bin,
	  2 length	fixed bin,
	  2 s,
	    3 logical	bit (1),
	    3 not		bit (1),
	    3 filler1	bit (5),
	    3 parity	bit (1),
	    3 filler	bit (8);

/* stored operator */

declare	1 soperator,
	  2 op		fixed bin,
	  2 filler	fixed bin,
	  2 length	fixed bin,
	  2 s,
	    3 logical	bit (1),
	    3 not		bit (1),
	    3 filler1	bit (5),
	    3 parity	bit (1),
	    3 filler	bit (8);

/* condition operator */

declare	1 coperator,
	  2 op		fixed bin,
	  2 tag		fixed bin,
	  2 length	fixed bin,
	  2 c,
	    3 logical	bit (1),
	    3 not		bit (1),
	    3 comp	bit (1),
	    3 filler1	bit (4),
	    3 parity	bit (1),
	    3 filler2	bit (8);

declare	lang_num		fixed bin;
declare	(L, LL, L1, L2)	fixed bin;

declare	cobol_imp_word$lang_name
			entry (ptr) returns (fixed bin);

/* used for transposing */
dcl	holdatrue		fixed bin;		/* used for conditional stack */
declare	cop_c_bits	bit (16) based (c_ptr);

/* arithemetic stack */

dcl	cssub		fixed bin static;		/* conditional stack subscript */
dcl	TAG		fixed bin;
dcl	c_ptr		ptr;			/*[4.4-2]*/
dcl	(lognot, last_wd_per, LTP)
			bit (1);
dcl	assub		fixed bin static;		/* arithemetic stack subscript */
dcl	tempkey		fixed bin;		/* used to hold res word key */
dcl	itemsize1		char (512) based;		/*length in bytes of based current record*/
dcl	savidsize		char (512) based;		/* length in bytes of saved identifier record */
dcl	opeosptr		ptr;			/* pointer for operation eos */
dcl	litcnt		fixed bin;		/* used for size of numeric literal */
dcl	daptr		ptr;			/* pointer for dummy alter verb */
dcl	saveos		char (44);		/* used to save eos record */
dcl	end_stmt_chars	char (44) based (es_ptr);	/* used for eos record */
dcl	savoccptr		fixed bin;		/* used to save offset of occurs extension */
						/* used to save the subscript count */
dcl	subcnt		fixed bin;
dcl	decswitch		fixed bin static;		/* if prog has sectons */
dcl	secswitch		fixed bin static;		/* used for sections */
						/* used for debugging sections */
dcl	debugsw		fixed bin static;
dcl	curmax		fixed bin;		/* upper bound of current type 9 item */
dcl	savmax		fixed bin;		/* upper bound plus one of saved type 9 item */
						/* above used for overlapping */
						/* used for diagnostics in note routine */
dcl	diagno		fixed bin static;
dcl	srtrngptr		ptr;			/* used for sort range chain */
						/* an entry in sor range chain*/
dcl	01 srtrng		based (srtrngptr),
	  02 sptr		char (5),			/* points to next entry */
	  02 sstart	fixed bin,		/* start section number of sort range */
	  02 s_start	char (30),
	  02 sstop	fixed bin,		/* stop section number of sort range */
	  02 s_stop	char (30),
	  02 savsecnum	fixed bin,		/* save current section number */
	  02 srtfilno	fixed bin,		/* associated sort file number */
	  02 s_srtfilename	char (30),
	  02 sio		bit (1),			/* input output indicator  0=in  1=out */
	  02 srel		bit (1),			/* release fond within range */
	  02 sret		bit (1);			/* return found within range */

dcl	cursecnum		fixed bin static;		/* save current section number */
						/* this routine is the interpreter for the pd syntax */
						/* label arrays */


/* syntax line work area */
dcl	cobol_c_list	entry (ptr) ext;		/*  cal.led to print sources and diags */
dcl	(pp, id_loc)	ptr;
dcl	x		bit (8) based;		/* length of one line in syntax table */
dcl	bit18		bit (18) based;		/* used for eos record */

declare	1 interp,
	  2 current_line	fixed bin (24),
	  2 phase		fixed bin (24),
	  2 addr_record	ptr,
	  2 pointer_to_internal
			ptr,
	  2 directory_ptr	ptr,
	  2 source_ptr	ptr;

/* the following dcls are used in conjunction with the syntax table subroutines */
/* the current nested limit is 75 */
declare	intrp_stack	(75) fixed bin (24),	/* used for syntax subroutine */
	i1		fixed bin static;		/* syntax table */
dcl	p		ptr;
declare	trace_ptr		ptr;
dcl	dumfix		fixed bin;
dcl	tempchar1		char (1);

declare	1 syntax_table	(0:10000) based (pointer_to_internal),
	  2 b1		fixed bin,
	  2 b2		fixed bin,
	  2 b3		fixed bin,
	  2 b4		fixed bin,
	  2 b5		fixed bin;

declare	1 syntax_line	based (syntax_line_ptr),
	  2 s_bit		char (1),
	  2 o_bit		char (1),
	  2 t_type	fixed bin,
	  2 t_field	fixed bin,
	  2 s_exit	fixed bin,
	  2 a_num		fixed bin;

declare	syntax_line_ptr	ptr;

declare	1 sline,
	  2 s_bit		char (1),
	  2 o_bit		char (1),
	  2 t_type	fixed bin,
	  2 t_field	fixed bin,
	  2 s_exit	fixed bin,
	  2 a_num		fixed bin;

/*[5.3-2]*/
declare	(ii, key_count, file_count)
			fixed bin;


declare	1 header,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 body		char (2000);

dcl	1 message		based (addr_record),	/* 2 header */
	  02 size		fixed bin,
	  02 line		fixed bin,
	  02 column	fixed bin,
	  02 type		fixed bin,
	  02 run		fixed bin,		/*  phase no issuing diagnostic   for pd it is  */
						/* 2 body */
	  02 number	fixed bin,
	  02 info		bit (15),			/*  bit1 means parameter to be inserted  */
	  02 rep_bit	bit (15),			/*  bit2 maans token has been replaced */
	  02 infoa	bit (6),
	  02 length	fixed bin,
	  02 body		char (message.length);


dcl	01 source		based (addr_record),	/* 2 header */
	  02 size		fixed bin,
	  02 line		fixed bin,
	  02 column	fixed bin,
	  02 type		fixed bin,		/* 2 body */
	  02 info		bit (8),
	  02 length	fixed bin,
	  02 image	char (source.length);

dcl	01 satoken	based (addr_record),	/* 2 header */
	  03 size		fixed bin,
	  02 line		fixed bin,
	  02 column	fixed bin,
	  02 type		fixed bin,		/* 2 body */
	  02 stringptr	ptr,
	  02 defline	fixed bin,
	  02 address	bit (32),
	  02 sanum	fixed bin,
	  02 numrecs	fixed bin,
	  02 minchars	fixed bin,
	  02 maxchars	fixed bin,
	  02 namesize	fixed bin,
	  02 name		char (30);

declare	eosptr		ptr;

/* based area to get pointer */
dcl	01 headerb	based (mptr),
	  02 size		fixed bin,
	  02 line		fixed bin,
	  02 column	fixed bin,
	  02 type		fixed bin,
	  02 body		char (header.size - 16);	/* general form of internal record */
						/* current word buffer */
						/* used for i-o operations */
dcl	seq		fixed bin static;
dcl	mptr		ptr;			/* points to record of input minpral file */
dcl	input		fixed bin static;
dcl	rewind		fixed bin static;
dcl	output		fixed bin static;

dcl	itemsize		char (512) based;		/*length in bytes of current record */
dcl	savitmptr		ptr;			/* a dummy procedure name reference type 18 used for go to  action 49 */
						/* pointer for dummy procedure name */
dcl	dpnptr		ptr;			/* pointer for dummy procedure name */
						/* used to save the item for ident subrouttines */

declare	1 saveident	static internal,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 body		char (430);

dcl	savidptr		ptr;			/* pointer for saved identifier */
						/* used to reference the extensions of type 9 records */
dcl	exten		(430) char (1) based;
dcl	occptr		ptr;			/* used to reference the subscript extension of type 9 */

/* save the SORTFILE RECORD here */

dcl	01 sv_srtfil_rec	static internal,		/* header */
	  2 size		fixed bin,
	  2 body		char (300);

/* temp patch*/
dcl	convtemp		fixed bin;
dcl	histno		fixed bin;		/* used for IO verbs */

/* save  procedure definition from sort statement here */

dcl	01 sv_proc_def	static internal,
	  2 size		fixed bin,
	  2 body		char (300);

/* save the FILE after USING or GIVING in SORT statement here */

dcl	01 sv_usfil	static internal,		/* header */
	  2 size		fixed bin,
	  2 body		char (300);

/* save the generated tag number here */

dcl	save_gentag	fixed bin;
dcl	seqvarptr		ptr;
dcl	seqvarleng	fixed bin;
dcl	varrecaddr	char (5);
declare	repcsbit		bit (1);

declare	cobol_pdst	entry (ptr, fixed bin) ext;



dcl	c26		char (28) based;		/* used to move perform range entry */

dcl	fb26		fixed bin static init (28);	/* used to write perform range entry */

dcl	convalue		fixed bin static init (48);	/* used for range check in set verb */


dcl	01 line		static internal,
	  02 scan_bit	char (1),
	  02 output_bit	char (1),
	  02 test_type	fixed bin,
	  02 test_field	fixed bin,
	  02 success_exit	fixed bin,
	  02 action_number	fixed bin;

declare	1 saveitem	static internal,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 boby		char (512);

/*[4.4-5]*/
declare	eos_perform_ptr	ptr,
	eos_perform_size	fixed bin init (40);

/*[4.4-5]*/
declare	1 eos_perform,				/*[4.4-5]*/
	  2 size		fixed bin init (40),	/*[4.4-5]*/
	  2 line		fixed bin init (0),		/*[4.4-5]*/
	  2 column	fixed bin init (0),		/*[4.4-5]*/
	  2 type		fixed bin init (19),	/*[4.4-5]*/
	  2 verb		fixed bin init (20),	/*[4.4-5]*/
	  2 e		fixed bin init (0),		/*[4.4-5]*/
	  2 h		fixed bin init (0),		/*[4.4-5]*/
	  2 i		fixed bin init (0),		/*[4.4-5]*/
	  2 j		fixed bin init (0),		/*[4.4-5]*/
	  2 status	bit (36) init ("0"b);

/*[4.4-5]*/
declare	rw_perform_ptr	ptr,
	rw_perform_size	fixed bin init (28);

/*[4.4-5]*/
declare	1 rw_perform,				/*[4.4-5]*/
	  2 size		fixed bin init (28),	/*[4.4-5]*/
	  2 line		fixed bin init (0),		/*[4.4-5]*/
	  2 column	fixed bin init (0),		/*[4.4-5]*/
	  2 type		fixed bin init (1),		/*[4.4-5]*/
	  2 key		fixed bin init (20),	/*[4.4-5]*/
	  2 status	bit (36) init ("10010010000000001"b),
						/*[4.4-5]*/
	  2 jmp_ndx	fixed bin init (0);

/*[5.2-1]*/
dcl	rw_move_ptr	ptr,
	rw_move_size	fixed bin init (28);

/*[5.2-1]*/
dcl	1 rw_move,				/*[5.2-1]*/
	  2 size		fixed bin init (28),	/*[5.2-1]*/
	  2 line		fixed bin init (0),		/*[5.2-1]*/
	  2 column	fixed bin init (0),		/*[5.2-1]*/
	  2 type		fixed bin init (1),		/*[5.2-1]*/
	  2 key		fixed bin init (18),	/*[5.2-1]*/
	  2 status	bit (36) init ("10010010000000001"b),
						/*[5.2-1]*/
	  2 jmp_ndx	fixed bin init (0);

/*[5.2-1]*/
dcl	supp_lit_ptr	ptr,
	supp_lit_size	fixed bin init (37);

/*[5.2-1]*/
dcl	1 supp_lit,				/*[5.2-1]*/
	  2 size		fixed bin init (37),	/*[5.2-1]*/
	  2 line		fixed bin init (0),		/*[5.2-1]*/
	  2 column	fixed bin init (0),		/*[5.2-1]*/
	  2 type		fixed bin init (2),		/*[5.2-1]*/
	  2 lit_type	bit (36) init ("1000000000001000000001"b),
						/*[5.2-1]*/
	  2 exp_places	fixed bin init (0),		/*[5.2-1]*/
	  2 places_left	fixed bin init (1),		/*[5.2-1]*/
	  2 places_right	fixed bin init (0),		/*[5.2-1]*/
	  2 places	fixed bin init (1),		/*[5.2-1]*/
	  2 literal	char (1) init ("1");

/*[5.2-1]*/
dcl	eos_move_ptr	ptr,
	eos_move_size	fixed bin init (40);

/*[5.2-1]*/
dcl	1 eos_move,				/*[5.2-1]*/
	  2 size		fixed bin init (40),	/*[5.2-1]*/
	  2 line		fixed bin init (0),		/*[5.2-1]*/
	  2 column	fixed bin init (0),		/*[5.2-1]*/
	  2 type		fixed bin init (19),	/*[5.2-1]*/
	  2 verb		fixed bin init (18),	/*[5.2-1]*/
	  2 e		fixed bin init (0),		/*[5.2-1]*/
	  2 h		fixed bin init (0),		/*[5.2-1]*/
	  2 i		fixed bin init (0),		/*[5.2-1]*/
	  2 j		fixed bin init (0),		/*[5.2-1]*/
	  2 status	bit (36) init ("0"b);

%include cobol_ext_;


/* the following is a description of common*/

%include cobol_fixed_common;


/* the layout of a file table */


%include cobol_file_table;
%include cobol_diag_file;
%include cobol_;

declare	1 alphabet_name	based (addr_record),
%include cobol_TYPE40;


dcl	1 reserved_word	based (addr_record),
%include cobol_TYPE1;

dcl	1 numeric_lit	based (addr_record),
%include cobol_TYPE2;

dcl	1 alphanum_lit	based (addr_record),
%include cobol_TYPE3;


dcl	1 proc_def	based (addr_record),
%include cobol_TYPE7;

dcl	1 data_name	based (addr_record),
%include cobol_TYPE9;

dcl	1 occurs		based (occptr),
%include cobol_OCCURS;

dcl	1 index_name	based (addr_record),
%include cobol_TYPE10;

dcl	1 fd_token	based (addr_record),
%include cobol_TYPE12;


%include cobol_type13;

dcl	1 mnemonic_name	based (addr_record),
%include cobol_TYPE17;


dcl	1 end_stmt	static,
%include cobol_TYPE19;



/* a dummy procedure name reference type 18 used for go to  action 49 */
dcl	01 dumprocname	static,
%include cobol_TYPE18;

dcl	01 opeos		static,
%include cobol_TYPE19;
/* dummy open verb for acton 119 */
/* type18 procedure name stored here for go to depending */
dcl	01 store_label_1	static internal,
%include cobol_TYPE18;
/* store type 18 for go dependig */
dcl	01 store_label_2	static internal,
%include cobol_TYPE18;
%include cobol_file_desc_1;

     end cobol_pdstax;
