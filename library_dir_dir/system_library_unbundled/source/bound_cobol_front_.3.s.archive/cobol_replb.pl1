/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_replb.pl1 Reformatted code to new Cobol standard.
                                                   END HISTORY COMMENTS */


/* Modified on 07/11/81 by FCH, [4.4-3], work files incorrectly written, phx10380(BUG492) */
/* Modified on 04/09/81 by FCH, [4.4-2], fix bugs in leveling for validation-81, BUG477 */
/* Modified on 12/10/80 by FCH, [4.4-1], report writer added */
/* Modified on 03/24/80 by FCH, [4.2-7], Emit correct line number with L-14 */
/* Modified on 03/24/80 by FCH, [4.2-6], flag "(" as generated by cond-name ref */
/* Modified on 07/11/79 by FCH, [4.0-5], debug statement */
/* Modified on 06/26/79 by MD, [4.0-4], in-line perform */
/* Modified on 06/02/78 by RAL, [3.0-3], check lnk for redefines in linkage section */
/* Modified on 01/03/78 by FCH, [3.0-2], leveling diag 14 issued */
/* Modified on 12/28/77 by FCH, [3.0-1], numeric procedure names handled correctly */
/* Modified since Version 3.0 */






/* format: style3 */
cobol_replb:
     proc (ntendptr, string_ptr);

/*  DECLARATION OF THE PARAMETERS  */

dcl	ntendptr		ptr;			/*  points to the byte following the last entry in the name table buffer (input)  */
dcl	string_ptr	ptr;			/*  points to the string base table (input)  */


/*  INTERNAL VARIABLES  */

dcl	eof		bit (1) int static init ("0"b);
dcl	ntptr		ptr;
dcl	s		fixed bin (15);		/*[4.0-5]*/
declare	sz		fixed bin;		/*[4.0-5]*/
declare	ch32		char (32) based;

declare	(P1, P2)		ptr;			/*[3.0-2]*/

/*  the name stack pointer table  */

dcl	ptrtable		(50) ptr;


/*  INTERNAL STATIC  */

dcl	false		bit (1) int static init ("0"b);
dcl	true		bit (1) int static init ("1"b);





/*  DECLARATION OF EXTERNAL ENTRIES  */


dcl	cobol_usrwd	ext
			entry (ptr, fixed bin (15), ptr, fixed bin (15), ptr, bit (1), bit (1), bit (1),
			fixed bin (15), ptr);

dcl	cobol_repl3_expand	ext entry (ptr, ptr, ptr, fixed bin (15), fixed bin (7));


dcl	cobol_find_secdef	ext entry (ptr, fixed bin (15), ptr, ptr);

dcl	dn_ptr		ptr;
dcl	temp_ptr		ptr;
dcl	1 shdr		based (cobol_curr_out),
	  2 filler	char (12),
	  2 next		fixed bin (24);
dcl	1 picture		based (ptr2),
	  2 size		fixed bin (15),
	  2 line		fixed bin (15),
	  2 column	fixed bin (7),
	  2 type		fixed bin (7),
	  2 length	fixed bin (7),
	  2 string	char (120),
	1 message		based (ptr2),
	  2 size		fixed bin (15),
	  2 line		fixed bin (15),
	  2 column	fixed bin (7),
	  2 type		fixed bin (7),
	  2 number	fixed bin (15),
	  2 info		fixed bin (15),
	1 source		based (ptr2),
	  2 size		fixed bin (15),
	  2 line		fixed bin (15),
	  2 column	fixed bin (7),
	  2 type		fixed bin (7),
	  2 info		fixed bin (7),
	  2 length	fixed bin (7),
	  2 image		char (200),
	1 user_word	based (ptr2),
	  2 size		fixed bin (15),
	  2 line		fixed bin (15),
	  2 column	fixed bin (7),
	  2 type		fixed bin (7),
	  2 info1		bit (1),
	  2 info2		bit (1),
	  2 info3		bit (6),			/*  2 multics char(3),  */
	  2 length	fixed bin (7),
	  2 word		char (30);


dcl	1 db_token	based (ptr2),
	  2 size		fixed bin (15),
	  2 line		fixed bin (15),
	  2 column	fixed bin (7),
	  2 type		fixed bin (7),
	  2 db_index	fixed bin (15),
	  2 db_switch	bit (8);



dcl	minpr_record	char (recsize2) based (ptr2),
	stackrecord	char (recsize2) based (stackptr),
	template		char (500) based (ntptr),
	(stackptr, stackbegptr, ptr2, ptr2_1, save_ptr2)
			pointer,
	(counter, topstack) fixed bin (15),
	(ntptr1, ntptr2)	pointer,
	(i, j)		fixed bin,
	was_found		bit (1),
	not_found		bit (1);			/*[4.4-2]*/
declare	qualif		bit (1),
	sav_ptr		ptr;

dcl	stack		char (1000);
dcl	temp_stack	(1000) char (1) based (addr (stack));
dcl	template1		(500) char (1) based (addr (template));

dcl	1 auser_word	based (stackptr),
	  2 size		fixed bin (15),
	  2 line		fixed bin (15),
	  2 column	fixed bin (7),
	  2 type		fixed bin (7),
	  2 info1		bit (1),
	  2 info2		bit (1),
	  2 info3		bit (6),			/*  2 multics char(3),  */
	  2 length	fixed bin (7),
	  2 word		char (30);

dcl	1 res_word_of	auto,
	  2 size		fixed bin (15) init (28),
	  2 line		fixed bin (15) init (0),
	  2 column	fixed bin (7) init (0),
	  2 type		fixed bin (7) init (1),
	  2 key		fixed bin (15) init (133),
	  2 class1	bit (16) init ("000000001"b), /*[4.2-6]*/
	  2 class2	bit (4) init ("0001"b),
	  2 class3	bit (1) init ("1"b),
	  2 class4	bit (3) init ("0"b),	/*  2 multics char(1) init(" "),  */
	  2 jump_index	fixed bin (7) init (0);

dcl	1 adiag		auto,
	  2 size		fixed bin init (28),
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin init (5),
	  2 run_number	fixed bin init (6),
	  2 number	fixed bin,
	  2 info		bit (8) initial ("01000000"b),
	  2 image_size	fixed bin init (0),
	  2 image		char (8);

dcl	sectno		fixed bin (15),
	rw_switch		bit (1),
	ptr3		pointer,
	levstack		(50) fixed bin (15);


dcl	1 data_based	based,
	  02 filler	char (24),
	  02 offset	fixed bin;

dcl	startlevel	fixed bin (31);
dcl	tlevel		fixed bin (31);
dcl	continue		bit (1);
dcl	diag_no		fixed bin (15);
dcl	save_line		fixed bin (15);
dcl	save_column	fixed bin (7);
dcl	save_length	fixed bin (31);
dcl	first_time	bit (1);
dcl	first_workfile_ref	bit (1) int static init ("1"b);



dcl	t26_ptr		ptr;
dcl	t26_size		fixed bin (15) int static init (16);

dcl	1 t26_token	int static,
	  2 size		fixed bin (15) init (16),
	  2 line		fixed bin (15),
	  2 column	fixed bin (7),
	  2 type		fixed bin (7) init (26);	/*  =26  */




dcl	1 t88_token	int static,
	  2 size		fixed bin (15) init (16),
	  2 line		fixed bin (15),
	  2 column	fixed bin (7),
	  2 type		fixed bin (7) init (88);

dcl	t88_ptr		ptr;


dcl	rw_corresponding	bit (1);
dcl	rw_initialize	bit (1);
dcl	expand_condition_names
			bit (1);
dcl	rw_sort_etc	bit (1);			/* 2/26/74 */
						/*[4.4-1]*/
dcl	(rw_debugging, rw_initterm, rw_generate)
			bit (1);
dcl	rw_perform	bit (1);
dcl	rw_search		bit (1);
dcl	rw_exception	bit (1);
dcl	already_replaced	bit (1);
dcl	processing_subscript
			bit (1);
dcl	lev_from_srchloop	bit (1);
dcl	too_many_qualifiers bit (1);
dcl	name_stack_overflow bit (1);
dcl	subscript_stack_overflow
			bit (1);
dcl	recovered_to_thru	bit (1);
dcl	ss_recovered	bit (1);
dcl	num_literal	bit (1);

dcl	ft_ptr		ptr;

/*  VARIABLES REQUIRED FOR PROCESSING CONDITION NAMES  */

dcl	cname_ptr		ptr;
dcl	cvar_ptr		ptr;
dcl	temp_cname_ptr	ptr;
dcl	temp_cvar_ptr	ptr;
dcl	cname_size	fixed bin (15);
dcl	cvar_size		fixed bin (15);
dcl	ss_stack_ptr	ptr;
dcl	ssname_ptr	ptr;

dcl	cobol_cvar_record	char (500);
dcl	cobol_cname_record	char (500);
dcl	cobol_ss_name	char (500);

dcl	1 cobol_ss_stack,
	  2 no_entries	fixed bin (15),
	  2 dummy_ptr	ptr,
	  2 stack		char (1000);












dcl	ss_template	(1000) char (1) based (addr (cobol_ss_stack.stack));

dcl	ss_recsize	fixed bin (15);
dcl	cobol_ss_stackrecord
			char (ss_recsize) based (ss_stack_ptr);
dcl	ss_ptrtable	(1:50) ptr;
dcl	ss_topstack	fixed bin (15);

dcl	next_state	fixed bin (15);
dcl	rwkey		fixed bin (15);

dcl	name_stack_size	fixed bin (15) int static init (1000);
dcl	subscript_stack_size
			fixed bin (15) int static init (1000);





/*  DECLARATIONS REQUIRED FOR PROCESSINNG DEBUGGING STATEMENTS  */

dcl	call_scan		bit (1);
dcl	recover_code	fixed bin (15);
dcl	stmt_term		fixed bin (15) int static init (1),
	a_dataname	fixed bin (15) int static init (2),
	resword_all	fixed bin (15) int static init (3),
	eof_found		fixed bin (15) int static init (4);


dcl	1 debug_alit	based (ss_stack_ptr),
	  2 size		fixed bin (15),
	  2 line		fixed bin (15),
	  2 column	fixed bin (15),
	  2 type		fixed bin (15),
	  2 info		bit (8),
	  2 multics	char (3),
	  2 length	fixed bin (15),
	  2 string	char (31);

dcl	lit_of		char (4) int static init (" of ");
dcl	inext		fixed bin (15);
dcl	ilength		fixed bin (15);
dcl	all_flag		bit (1);


/*  DECLARAATIONS REQUIRED FOR PROCESSING "PROCEDURE DIVISION USING"  */

dcl	rw_using		bit (1);
dcl	using_count	fixed bin (15);




/*  VARIABLES REQUIRED FOR PROCESSING TYPE 1 RECORDS WITH REPLACEMENT JUMP INDEX=7  */


dcl	1 special_usrwd	int static,
	  2 size		fixed bin (15),		/*  MUST CHANGE INIT VALUE FOR NPL VERSION  */
	  2 line		fixed bin (15),
	  2 column	fixed bin (7),
	  2 type		fixed bin (7) init (8),
	  2 info		bit (8) init ("0"b),
	  2 multics	char (3),
	  2 length	fixed bin (7),
	  2 name		char (30);		/*  large enough to hold maximum size name  */


dcl	clinage_counter	char (14) int static init ("LINAGE-COUNTER"),
	cline_counter	char (12) int static init ("LINE-COUNTER"),
	cpage_counter	char (12) int static init ("PAGE-COUNTER"),
	csystem_status	char (13) int static init ("SYSTEM-STATUS"),
	ctally		char (5) int static init ("TALLY");


/*  VARIABLES REQUIRED FOR PROCESSING "SEARCH {ALL}"  */

dcl	error_cond	bit (1);
dcl	search_all	bit (1);
dcl	save_ntptr	ptr;
dcl	save_type10_ptr	ptr;





/*  DEFINE MNEMONIC RETURN CODES FOR THE INTERNAL SCAN PROCEDURE  */


dcl	rcode_NO_INTEREST	fixed bin static options (constant) init (1);
dcl	rcode_RESWORD_REC	fixed bin static options (constant) init (2);
dcl	rcode_DNAME_REC	fixed bin static options (constant) init (3);
dcl	rcode_ERROR_DETECTED
			fixed bin static options (constant) init (4);
dcl	rcode_SCAN_CURRENT	fixed bin static options (constant) init (5);
dcl	rcode_SCAN_NEXT	fixed bin static options (constant) init (6);


dcl	type25_flag	bit (1);






dcl	saved_storage_type	bit (1);
dcl	searching_for_another
			bit (1);
dcl	return_code	fixed bin (15);
dcl	string		builtin;
dcl	addr		builtin;
dcl	addrel		builtin;
dcl	divide		builtin;
dcl	fixed		builtin;
dcl	mod		builtin;
dcl	null		builtin;
dcl	(substr, size)	builtin;

dcl	1 linage_counter_type9
			static,
	  2 size		fixed bin init (112),
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin init (9),
	  2 repl_ptr	(2) ptr init ((2) null ()),
	  2 fill1		bit (108) init (""b),
	  2 file_key_info,
	    3 fb1		(3) fixed bin init (0, 0, 0),
	    3 size	fixed bin init (6),
	    3 places_left	fixed bin init (6),
	    3 places_right	fixed bin init (0),
	    3 flags1	bit (36) init ("001000100100000001000000000100000000"b),
						/* constant lev77 elem numeric display */
	    3 flags2	bit (36) init (""b),
	    3 seg		fixed bin,
	    3 off		fixed bin init (352),
	  2 fill2		(7) fixed bin init (0, 0, 0, 0, 0, 0, 0);
dcl	1 type17		static,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin init (17),
	  2 string_ptr	ptr init (null ()),
	  2 prev_rec	ptr init (null ()),
	  2 info		bit (8) init (""b),
	  2 class,
	    3 switch_condition
			bit (1),
	    3 switch_name	bit (1),
	    3 accept_device bit (1),
	    3 display_device
			bit (1),
	    3 printer_control
			bit (1),
	    3 alphabet_name bit (1),
	  2 on_status	bit (1) init (""b),
	  2 off_status	bit (1) init (""b),
	  2 def_line	fixed bin init (0),
	  2 iw_key	fixed bin,
	  2 reserved	bit (36) init (""b),
	  2 alphabet_offset fixed bin init (0),
	  2 name_size	fixed bin,
	  2 name		char (8);
dcl	1 type40		auto,			/* due to size */
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 string_ptr	ptr,
	  2 prev_rec	ptr,
	  2 info		bit (10),
	  2 hival_char	char (1),
	  2 loval_char	char (1),
	  2 iw_key	fixed bin,
	  2 def_line	fixed bin,
	  2 char_size	fixed bin,
	  2 he_value	char (1),
	  2 segno		fixed bin,
	  2 offset	fixed bin,
	  2 dn_offset	fixed bin,
	  2 table		char (512),
	  2 name_size	fixed bin,
	  2 name		char (8);

dcl	temp_char		char (1);
dcl	rw_key		fixed bin;
dcl	replb_compile_count fixed bin static init (0);
dcl	cobol_read_ft_	entry (fixed bin, ptr);
dcl	cobol_c_list	entry (ptr);
dcl	cobol_set_type40_$ebcdic
			entry (ptr);


/*************************************/
start:
	mcobol = fixed_common.compiler_id = 3;
	rw_sort_etc = "0"b;
	rw_corresponding = "0"b;
	rw_initialize = "0"b;
	rw_search = "0"b;
	expand_condition_names = "0"b;		/*[4.0-5]*/
	rw_debugging = "0"b;
	rw_perform = "0"b;
	rw_using = "0"b;
	rw_exception = "0"b;
	already_replaced = "0"b;
	processing_subscript = "0"b;
	lev_from_srchloop = "0"b;
	subscript_stack_overflow = "0"b;
	name_stack_overflow, too_many_qualifiers = "0"b;	/*[3.0-1]*/
	ss_stack_ptr = addr (cobol_ss_stack.stack);
	cobol_ss_stack.no_entries = 0;
	st_ptr = addr (status);
	sectno = 1;
	using_count = 0;
	search_all = "0"b;
	type25_flag = "0"b;
	t26_ptr = addr (t26_token);
	t88_ptr = addr (t88_token);
	ssname_ptr = addr (cobol_ss_name);
	stackbegptr = addr (stack);
	rw_switch = false;

	call swfget;				/* Read the first record from the input file. */
	do while (user_word.type = 5);		/* Scan over diagnostic records writing them to output file. */
	     call swfput;
	     call swfget;
	end;

	next_state = 1;
	go to using_scan;

using_read:
	call swfget;
using_scan:
	call repl3_scan (status, return_code);
	if status_right ^= "0"b
	then go to rend;
using_switch:
	go to using_state (next_state);

using_state (1):
	if return_code = rcode_RESWORD_REC & ptr2 -> reserved_word.key = 142
						/* PROCEDURE */
	then do;
		next_state = 2;
		call swfput;			/* Write the reserved word to the output file. */
		go to using_read;
	     end;
	else go to using_exit;
using_state (2):
	if return_code = rcode_RESWORD_REC & ptr2 -> reserved_word.key = 94
						/* DIVISION */
	then do;
		next_state = 3;
		call swfput;			/* Write the reserved word to the output file. */
		go to using_read;
	     end;
	else go to using_exit;
using_state (3):
	if return_code = rcode_RESWORD_REC & ptr2 -> reserved_word.key = 176
						/* USING */
	then do;
		next_state = 4;
		rw_using = "1"b;
		call swfput;			/* Write the reserved word to the output file. */
		go to using_read;
	     end;
	else go to using_exit;
using_state (4):
	if return_code = rcode_ERROR_DETECTED | return_code = rcode_SCAN_CURRENT
	then go to using_scan;			/* The current record in the read buffer is to be scanned next. */
	if return_code = rcode_NO_INTEREST & user_word.type = 5
	then do;					/* diagnostic record */
		call swfput;
		go to using_read;
	     end;
	if return_code = rcode_DNAME_REC
	then do;					/* The record scanned is an identifier following "USING". */
		using_count = using_count + 1;
		if ^ntptr -> data_name.saved & ntptr -> data_name.linkage ^= 0
		then do;				/* This name has not been in the name table buffer on a
					   previous load, but the linkage entry has already been set.
					   Therefore, this name must have appeared already in the
					   using clause and this occurrence is illegal. */

			adiag.number = 14;		/* Identifier must not appear in "using" more than once. */
			adiag.line = stackbegptr -> auser_word.line;
			adiag.column = stackbegptr -> auser_word.column;
			call issue_diag;
			go to using_scan;
		     end;				/*		call unload;		/* Unload the user words from the name stack. */
		if ntptr -> data_name.linkage_section
		then ntptr -> data_name.linkage = using_count;
		save_line = ntptr -> data_name.line;
		save_column = ntptr -> data_name.column;
		ntptr -> data_name.line = stackbegptr -> auser_word.line;
		ntptr -> data_name.column = stackbegptr -> auser_word.column;
						/*[4.0-5]*/
		call swfput2 (ntptr);		/* Write out the name table buffer entry. */
		ntptr -> data_name.line = save_line;	/* Restore correct line and column numbers */
		ntptr -> data_name.column = save_column;/* to name table buffer entry. */

		if (ntptr -> data_name.level = 1 | ntptr -> data_name.level = 77) & ntptr -> data_name.linkage_section
		then do;				/* Level 1 entry in the linkage section. Step linearly thru the name table buffer
			   marking all subordinate type 9 entries with the relative position of this
			   identifier in the using clause. */

/* If redefine, back up the name table buffer          [3.0-3]
                                          until level 1 of an object of redefine is found. */

/*[]*/
			if ntptr -> data_name.s_of_rdf = "1"b
						/*[]*/
			then do;			/*[]*/
				ntptr = ntptr -> data_name.prev_rec;
						/*[]*/
				continue = "1"b;	/*[]*/
				do while (continue);/*[]*/
				     if ntptr -> data_name.level = 1 | ntptr -> data_name.level = 77
						/*[]*/
				     then if ntptr -> data_name.o_of_rdf = "1"b
						/*[]*/
					then continue = "0"b;
						/*[]*/
					else ntptr = ntptr -> data_name.prev_rec;
						/*[]*/
				     else ntptr = ntptr -> data_name.prev_rec;
						/*[]*/
				end;		/*[]*/
				ntptr -> data_name.linkage = using_count;
			     end;			/*[3.0-3]*/


			continue = "1"b;
			do while (continue);
			     ntptr = addrel (ntptr, divide (ntptr -> data_name.size + 11, 8, 17, 0) * 2);
			     if ntptr = ntendptr
			     then continue = "0"b;	/* end of name table buffer */
			     else if ntptr -> data_name.level < 2 | ntptr -> data_name.level = 77
			     then continue = "0"b;
			     else if ntptr -> data_name.type = 9
			     then ntptr -> data_name.linkage = using_count;
			end;

/* Step thru name table buffer to handle all subject          [3.0-3]
                                of redefines and their subordinates. */


/*[]*/
			do while ((ntptr -> data_name.level = 1 | ntptr -> data_name.level = 77)
			     & ntptr -> data_name.s_of_rdf = "1"b);
						/*[]*/
			     ntptr -> data_name.linkage = using_count;
						/*[]*/
			     continue = "1"b;	/*[]*/
			     do while (continue);	/*[]*/
				ntptr = addrel (ntptr, divide (ntptr -> data_name.size + 11, 8, 17, 0) * 2);
						/*[]*/
				if ntptr = ntendptr /*[]*/
				then continue = "0"b;
						/* end of name table buffer */
						/*[]*/
				else if ntptr -> data_name.level < 2 /*[]*/ | ntptr -> data_name.level = 77
						/*[]*/
				then continue = "0"b;
						/*[]*/
				else if ntptr -> data_name.type = 9
						/*[]*/
				then ntptr -> data_name.linkage = using_count;
						/*[]*/
			     end;			/*[]*/
			end;			/*[3.0-3]*/


		     end;
		if user_word.type > 8
		then go to using_read;		/* This user word has been replaced before. The read
					   buffer contains type 9 (or greater) record that
					   replaced it during a previous load of the name table buffer. */
		else go to using_scan;
	     end;
	else rw_using = "0"b;			/* Record just scanned is a reserved word or some rcode_NO_INTEREST
					   type other than a diagnistic record. */
using_exit:
	call swfput;				/* Write out the current record in the read buffer. */
rloop:
	call swfget;
rloop1:
	call repl3_scan (status, return_code);
rloop2:
	if status_right ^= "0"b
	then go to rend;
	if return_code = rcode_NO_INTEREST
	     | (return_code = rcode_RESWORD_REC & ^rw_perform & ^rw_search & ^rw_exception)
	then do;					/* Simply write out this record. */
		call swfput;
		go to rloop;
	     end;
	if return_code = rcode_ERROR_DETECTED | return_code = rcode_SCAN_CURRENT
	then go to rloop1;				/* Record in read buffer is the one to be processed next. */
	if return_code = rcode_SCAN_NEXT
	then go to rloop;

	if rw_search
	then do;					/* Process "SEARCH". */
		call swfput;			/* Write out reserved word for "SEARCH". */
		call swfget;			/* Read next record and check for "ALL". */
		if ptr2 -> reserved_word.type = 1 & ptr2 -> reserved_word.key = 73
						/* "ALL" */
		then do;				/* "all" follows "SEARCH" */
			search_all = "1"b;
			call swfput;		/* Write out reserved word record "ALL". */
			call swfget;		/* Read next record. */
		     end;
		call repl3_scan (status, return_code);
		if status_right ^= "0"b
		then go to rend;
		if return_code = rcode_DNAME_REC
		then do;				/* data name follows "SEARCH {ALL}" */
			error_cond = "0"b;
			if ^ntptr -> data_name.subscripted
			then do;			/* Identifier following "SEARCH {ALL}" must have an
					   OCCURS clause in its description. */

				adiag.number = 15;
				error_cond = "1"b;
			     end;
			else if ^ntptr -> data_name.indexed_by
			then do;			/* Identifier following "SEARCH {ALL}" must have an
					   INDEXED BY clause in its description. */

				adiag.number = 16;
				error_cond = "1"b;
			     end;
			else if search_all
			then do;			/* "ALL" present, check that "KEY IS" is also present. */
				if ^ntptr -> data_name.subject_of_keyis
				then do;
					adiag.number = 17;
					error_cond = "1"b;
				     end;
				search_all = "0"b;
			     end;
			if ^error_cond
			then do;			/* Check if identifier has an index associated with it. */
				save_ntptr = ntptr; /* save ptr to identifier following "SEARCH ALL". */
				ntptr = ntptr -> data_name.prev_rec;
				if ntptr -> data_name.type = 10
				then do;		/* The identifier has an INDEXED BY clause. */
					do while (ntptr -> data_name.type = 10);
						/* Find 1st index name. */
					     save_type10_ptr = ntptr;
					     ntptr = ntptr -> data_name.prev_rec;
					end;
					ntptr = save_ntptr;
						/* Point at the identifier. */
					save_line = ntptr -> data_name.line;
					save_column = ntptr -> data_name.column;
					ntptr -> data_name.line = stackbegptr -> auser_word.line;
					ntptr -> data_name.column = stackbegptr -> auser_word.column;
						/*[4.0-5]*/
					call swfput2 (ntptr);
						/* Write out data name record. */
					ntptr -> data_name.line = save_line;
						/* Restore line and column */
					ntptr -> data_name.column = save_column;
					ntptr = save_type10_ptr;
						/* Point to 1st index name. */
					save_line = ntptr -> data_name.line;
					save_column = ntptr -> data_name.column;
					ntptr -> data_name.line = stackbegptr -> auser_word.line;
					ntptr -> data_name.column = stackbegptr -> auser_word.column;
						/*[4.0-5]*/
					call swfput2 (ntptr);
						/* Write index name record. */
					ntptr -> data_name.line = save_line;
						/* Restore line and column. */
					ntptr -> data_name.column = save_column;
				     end;
				else do;		/* INDEXED BY clause is missing. */
					adiag.number = 16;
					error_cond = "1"b;
				     end;
			     end;
			if error_cond
			then call issue_diag;
			rw_search = "0"b;		/* Turn off "SEARCH" flag. */
			go to rloop1;		/* Read buffer contains next record. */
		     end;
		else do;				/* Some other type record follows "SEARCH {ALL}". */
			rw_search = "0"b;		/* Turn off "SEARCH" flag. */
			if return_code = rcode_NO_INTEREST & ptr2 -> reserved_word.type = 5
						/* diagnostic */
			then call swfput;		/* Write out the diagnostic record. */
			else if return_code = rcode_RESWORD_REC | return_code = rcode_NO_INTEREST
			then do;			/* Must issue diagnostic. */
				adiag.number = 18;	/* Identifier expected here */
				adiag.line = user_word.line;
				adiag.column = user_word.column;
				ptr3 = addr (adiag);
				call swfput1 (ptr3);
			     end;
			if return_code = rcode_NO_INTEREST | return_code = rcode_RESWORD_REC
			then go to rloop;		/* Read next record and continue. */
			else go to rloop1;		/* Process current record in read buffer. */
		     end;
	     end;					/* Process "SEARCH". */

	if rw_exception
	then do;

		rw_exception = "0"b;
		call swfput;			/* Write out the reserved word. */
		call swfget;			/* Get the next token. */
		call repl3_scan (status, return_code);
		if status_right ^= "0"b
		then go to rend;
		if return_code = rcode_RESWORD_REC & ptr2 -> reserved_word.key = 142
						/* "PROCEDURE" */
		then do;
			call swfput;
			rw_switch = "0"b;		/* Next token should be either a file name or a
						   reserved word, but never a section or paragraph name.
						   See the writeup on the "USE" verb. */
			go to rloop;
		     end;
		else go to rloop1;			/* Rescan the current token. */

	     end;

	if rw_perform
	then do;					/* Process "PERFORM". */
		next_state = 1;
perform_write:
		call swfput;
perform_read:
		call swfget;
perform_scan:
		call repl3_scan (status, return_code);
		if status_right ^= "0"b
		then go to rend;
perform_switch:
		go to perform_state (next_state);

perform_state (1):
		if return_code = rcode_DNAME_REC
		then do;				/* a data name */
						/*[4.4-1]*/
			if ^rw_initterm & ^rw_generate
			then next_state = 2;
			rw_switch = "0"b;		/* Turn off the switch so that if a numeric literal is the next
					   record, it is treated like a numeric literal, and not like
					   a numeric paragraph name. */
perform_write_dname:
			save_line = ntptr -> data_name.line;
			save_column = ntptr -> data_name.column;
			ntptr -> data_name.line = stackbegptr -> auser_word.line;
			ntptr -> data_name.column = stackbegptr -> auser_word.column;
						/*[4.0-5]*/
			call swfput2 (ntptr);
			ntptr -> data_name.line = save_line;
			ntptr -> data_name.column = save_column;
						/*[4.4-1]*/
			if rw_initterm | rw_generate
			then do;
				rw_switch = "1"b;
				go to perform_scan;
			     end;
			go to perform_scan;
		     end;
		else if return_code = rcode_ERROR_DETECTED
		then do;				/* Error detected by repl3_scan. */
			next_state = 2;
			go to perform_scan;
		     end;
		else do;				/* any other return code */
			call perform_recover (status, recovered_to_thru);
			if status_right ^= "0"b
			then go to rend;
			if recovered_to_thru
			then do;			/* Recovered to "THRU". */
				next_state = 3;
				go to perform_write;
			     end;
			else go to perform_exit;
		     end;
perform_state (2):
		if return_code = rcode_RESWORD_REC & ptr2 -> reserved_word.key = 166
						/* "THRU" */
		then do;
			next_state = 3;
			rw_switch = "1"b;		/* Turn on this switch so that if a numeric literal is the
					   next record, the numeric literal will be treated as a
					   numeric paragraph name. */
			go to perform_write;
		     end;
		else if return_code = rcode_ERROR_DETECTED
		then do;				/* Error detected by repl3_scan. */
			next_state = 4;
			go to perform_scan;
		     end;
		else go to perform_exit;		/* any other type record */
perform_state (3):
		if return_code = rcode_DNAME_REC
		then do;				/* a data name */
			next_state = 4;
			rw_switch = "0"b;		/* Turn off the switch that tells repl3_scan to process
					   numeric literals as numeric paragraph names. */
			go to perform_write_dname;
		     end;
		else if return_code = rcode_ERROR_DETECTED
		then do;				/* Error detected by repl3_scan. */
			next_state = 4;
			rw_switch = "0"b;
			go to perform_scan;
		     end;
		else go to perform_exit;		/* any other type record */
perform_state (4):
		;				/*  EMPTY STATEMENT  */

perform_exit:
		rw_perform = "0"b;
		rw_switch = "0"b;
		if return_code = rcode_DNAME_REC
		then do;
			next_state = 4;
			go to perform_write_dname;
		     end;
		else go to rloop1;			/* Rescan the current token. */
	     end;					/* Processing "PERFORM". */

/* At this point, a data name has been successfully processed and the following conditions are true:
		1. ntptr points to the name table entry of the data name.
		2. The data name stack has already been unloaded.
		3. The record currently in the read buffer is the record following the data name. */

	if ntptr -> data_name.type = 11 & expand_condition_names
	then do;					/* process condition-name */
		cname_size = ntptr -> data_name.size;
		cname_ptr = ntptr;			/* save ptr to the condition name */
cvar_loop:					/* find the condition variable */
		ntptr = ntptr -> data_name.prev_rec;
		if ntptr -> data_name.type = 11
		then go to cvar_loop;
		else cvar_ptr = ntptr;		/* save ptr to the condition variable */
		cvar_size = ntptr -> data_name.size;	/* save size of the condition variable */
						/* We drop thru to here on the final iteration when the condition-name must be expanded
		   into a CONDITION which references the CONDITIONAL VARIABLE. */

		cobol_ss_stack.no_entries = 0;	/* MUST set to zero. Repl3_expand interprets
						   non-zero value to mean there is a subscript. */
		if user_word.type = 1
		then if ptr2 -> reserved_word.key = reschar_LPARENS
		     then do;			/* process SUBSCRIPT */
			     call process_subscript ("1"b);
			     if subscript_stack_overflow | ss_recovered
			     then go to rloop1;
			end;

/* Expand the CONDITION NAME to the CONDITIONAL RELATION. */
		ss_stack_ptr = addr (cobol_ss_stack);
		cobol_ss_stack.dummy_ptr = addr (ss_ptrtable);

/* Insert "(" & ")" for PDSYN. */
		res_word_of.key = reschar_LPARENS;
		call swfput1 (addr (res_word_of));
		call cobol_repl3_expand (cname_ptr, cvar_ptr, ss_stack_ptr, stackbegptr -> auser_word.line,
		     stackbegptr -> auser_word.column + stackbegptr -> auser_word.length);
		res_word_of.key = reschar_RPARENS;
		call swfput1 (addr (res_word_of));
		res_word_of.key = reswd_OF;		/* restore key value of OF */

		if fixed_common.comp_level < "3"	/*[3.0-2]*/
		then do;
			P1 = ptr2;		/*[3.0-2]*/
			ptr2 = P2;		/*[3.0-2]*/
						/*[4.4-2]*/
			call lev_diag (14, ptr2);	/*[3.0-2]*/
			ptr2 = P1;		/*[3.0-2]*/
		     end;				/*[3.0-2]*/

		go to rloop1;
	     end;					/* process condition-name */

	if ntptr -> data_name.type = 17 & expand_condition_names
	then /*-07/01/76-*/
	     if ntptr -> mnemonic_name.class.switch_condition
	     then do;				/* process conditional mnemonic-name */
		     res_word_of.key = reschar_LPARENS;
		     call swfput1 (addr (res_word_of));
		     call cobol_repl3_expand (ntptr, null (), null (), stackbegptr -> auser_word.line,
			stackbegptr -> auser_word.column + stackbegptr -> auser_word.length);
		     res_word_of.key = reschar_RPARENS;
		     call swfput1 (addr (res_word_of));
		     res_word_of.key = reswd_OF;	/* restore to original value */
		     go to rloop1;
		end;

/* Write the name table entry to the output file. */

	save_line = ntptr -> data_name.line;
	save_column = ntptr -> data_name.column;
	ntptr -> data_name.line = stackbegptr -> auser_word.line;
	ntptr -> data_name.column = stackbegptr -> auser_word.column;
						/*[4.0-5]*/
	call swfput2 (ntptr);
	ntptr -> data_name.line = save_line;		/* Restore correct line and column to name table buffer entry. */
	ntptr -> data_name.column = save_column;

	if rw_sort_etc & (ntptr -> data_name.type = 12 | ntptr -> data_name.type = 16)
	then do;					/* We have just written the record for a FILE or SORT FILE, follow this
			   with the token for the 1st file record immediately following it in the
			   name table, but change the file record length to reflect the largest
			   record size (variable length records). */

		ntptr = addrel (ntptr, divide (ntptr -> data_name.size + 11, 8, 17, 0) * 2);
		save_line = ntptr -> data_name.line;
		ntptr -> data_name.line = stackbegptr -> auser_word.line;
		save_length = ntptr -> data_name.item_length;
		call cobol_vdwf_dget (cobol_cmfp, status, ft_ptr, recsize2,
		     filedescr_offsets (ntptr -> data_name.file_num));
		ntptr -> data_name.item_length = file_table.max_cra_size;
						/*[4.0-5]*/
		call swfput2 (ntptr);
		ntptr -> data_name.line = save_line;
		ntptr -> data_name.item_length = save_length;
	     end;

	if rw_corresponding | rw_initialize
	then do;					/* Output subordinate entries for CORRESPONDING or INITIALIZE. */

		if ntptr -> data_name.saved
		then do;				/* This name table entry has been in memory before. */
			startlevel = ntptr -> data_name.level;
read_more:
			call swfget;		/* Read next record from input file. */
			if user_word.type ^= 26
			then do;			/* Write the record to the output file. */
				startlevel = ptr2 -> data_name.level;
				call swfput;
				go to read_more;
			     end;

/* The last record read was a type 26 record. All of the data-name records placed
			   onto the input file by previous iterations of replacement have been written
			   onto the output file. Now process the record following the type 26 record. */

			call swfget;
			if startlevel ^= ntptr -> data_name.level
			then do;			/* Search linearly thru the name table for the 1st entry that
					   has the same level number as the last entry read. */

srchloop:
				ntptr = addrel (ntptr, divide (ntptr -> data_name.size + 11, 8, 17, 0) * 2);
				if startlevel ^= ntptr -> data_name.level
				then go to srchloop;
			     end;
			if ntptr -> data_name.level ^= 1
			then startlevel = ntptr -> data_name.level - 1;
			else startlevel = 1;
			lev_from_srchloop = "1"b;
		     end;

/* Ntptr points to the name table entry just written onto the output file. 
		   We now write all of that entry's subordinate items. */

		if ntptr -> data_name.level <= 49
		then do;				/* Current qualified name not a condition-name. */
			if lev_from_srchloop
			then lev_from_srchloop = "0"b;/* Already have startlevel. */
			else startlevel = ntptr -> data_name.level;
						/* Get startlevel from current entry. */
			continue = "1"b;
			do while (continue);
			     ntptr = addrel (ntptr, divide (ntptr -> data_name.size + 11, 8, 17, 0) * 2);
			     if ntptr = ntendptr
			     then continue = "0"b;	/* end of name table */
			     else if ntptr -> data_name.type ^= 9 & ntptr -> data_name.type ^= 10
				& ntptr -> data_name.type ^= 11
						/* condition name */
			     then continue = "0"b;
			     else do;
				     tlevel = ntptr -> data_name.level;
				     if tlevel > startlevel & tlevel ^= 77
				     then do;	/* Write entry out if not a level 88. */
					     if tlevel ^> 50 & ^ntptr -> data_name.filler_item
					     then do;
						     ntptr -> data_name.line = stackbegptr -> auser_word.line;
						     ntptr -> data_name.column =
							stackbegptr -> auser_word.column;
						/*[4.0-5]*/
						     call swfput2 (ntptr);
						end;
					end;
				     else continue = "0"b;
				end;
			end;
			if user_word.type = 1	/* reserved word */
			then if ptr2 -> reserved_word.key = 187
						/* "(" */
			     then call process_subscript ("0"b);
		     end;

/* All subordinate entries have been written. Now write the type 26 token. */

		t26_token.line = stackbegptr -> auser_word.line;
		t26_token.column = stackbegptr -> auser_word.column;
		call swfput1 (t26_ptr);
	     end;					/* Output subordinate entries for CORRESPONDING or INITIALIZE. */

	go to rloop1;

repl3_scan:
     proc (status, return_code);

dcl	status		bit (32);
dcl	return_code	fixed bin (15);
dcl	1 status_word	based (st_ptr),
	  2 status_left	bit (16),
	  2 status_right	bit (16);
dcl	st_ptr		ptr;

	st_ptr = addr (status);			/*[4.0-4]*/
	num_literal = "0"b;
	if user_word.type > 8
	then do;					/* Check for type 24 token. */
		if user_word.type = 25
		then type25_flag = "1"b;		/* Set indicator for DDALLOC Append Item. */
		go to put;
	     end;
	go to replab (user_word.type);


/*************************************/
replab (1):					/* RESERVED WORD */
	if ptr2 -> reserved_word.key = 49 /* sort */ | ptr2 -> reserved_word.key = 112 /* giving */
	     | ptr2 -> reserved_word.key = 176		/* using */
	then rw_sort_etc = "1"b;
	else rw_sort_etc = "0"b;

	if rw_corresponding
	then do;
		s = ptr2 -> reserved_word.key;
		if s ^= 182 /* "+" */ & s ^= 183 /* "-" */ & s ^= 187 /* "(" */ & s ^= 188 /* ")" */
		     & s ^= 170 /* "TO" */ & s ^= 111	/* "FROM" */
		then rw_corresponding = "0"b;

	     end;
	if rw_initialize
	then do;
		s = ptr2 -> reserved_word.key;
		if s ^= 182 /* "+" */ & s ^= 183 /* "-" */ & s ^= 187 /* "(" */ & s ^= 188
						/* ")" */
		then do;
			rw_initialize = "0"b;
			call swfput1 (t26_ptr);	/* Write type 26 token to terminate INITIALIZE string. */
		     end;
	     end;
	if ptr2 -> reserved_word.key = 47 /* "IF" */ | ptr2 -> reserved_word.key = 173 /* "UNTIL" */
	     | ptr2 -> reserved_word.key = 77 /* "AND" */ | ptr2 -> reserved_word.key = 178
						/* "WHEN" */
	then expand_condition_names = "1"b;
	else if ptr2 -> reserved_word.terminator
	then expand_condition_names = "0"b;		/* statement terminator (other than "IF") */
	if ptr2 -> reserved_word.key ^= 170		/* "TO" - go to numeric paragraph needs switch on */
	then if ptr2 -> reserved_word.key ^= 144	/* "PROCEED" */
	     then if ptr2 -> reserved_word.key ^= 118	/* "IS" , "ARE" */
		then if ptr2 -> reserved_word.key ^= 166/* THRU */
		     then rw_switch = false;		/* rw_switch="1"b means the next token is expected to be
						   a parname - interpret type 2 tokens as such */
	if ptr2 -> reserved_word.key = 107 /* "EXCEPTION" */ | ptr2 -> reserved_word.key = 3
						/* "ERROR" */
	then rw_exception = "1"b;

	go to rw (fixed (ptr2 -> reserved_word.repl_jump_ind, 15));

rw (0):						/* Nothing required of REPLACEMENT. */
						/*[4.0-5]*/
	if ptr2 -> reserved_word.key = 189
	then rw_debugging = "0"b;			/* . */
	go to put1;
rw (1):						/* Nothing required of REPLACEMENT. */
	go to put1;
rw (2):						/* Reserved word which numeric paragraph name may follow. */
	rw_switch = true;
	go to put1;

rw (3):						/* Reserved word which only non-numeric data names may follow. */
	rw_switch = false;
	go to put1;

rw (4):						/* Reserved word "INITIALIZE" */
	rw_initialize = "1"b;
	go to put1;
rw (5):						/* Reserved word "CORRESPONDING" */
	rw_corresponding = "1"b;
	go to put1;
rw (6):						/* Reserved word "DEBUGGING" */
						/*[4.0-5]*/
	rw_debugging = "1"b;
	go to put1;

rw (7):						/* One of the following reserved words:
				   DEBUG-CONTENTS, DEBUG-ITEM, DEBUG-LINE, DEBUG-NAME,
				   DEBUG-SUB-1, DEBUG-SUB-2, DEBUG-SUB-3,
				   LINAGE-COUNTER, LINE-COUNTER, PAGE-COUNTER, TALLY. */
	special_usrwd.line = ptr2 -> reserved_word.line;
	special_usrwd.column = ptr2 -> reserved_word.column;
	s = ptr2 -> reserved_word.key;

/*[4.4-2]*/
	if fixed_common.comp_level < "3"
	then call lev_diag (42, ptr2);

	adiag.number = 0;				/* none yet */
	linage_counter_type9.line = ptr2 -> reserved_word.line;
	linage_counter_type9.column = ptr2 -> reserved_word.column;
	linage_counter_type9.seg = 0;
	adiag.line = user_word.line;
	adiag.column = user_word.column;
	call swfget;
	if user_word.type = 1 & (ptr2 -> reserved_word.key = reswd_IN | ptr2 -> reserved_word.key = reswd_OF)
	then do;
		return_code = rcode_SCAN_NEXT;
		call swfget;
		if user_word.type ^= 8
		then adiag.number = fatal_INVALID_QUALIFIER;
		else do;
			adiag.line = user_word.line;
			adiag.column = user_word.column;
			counter = 1;
			ptrtable (1) = ptr2;
			call cobol_usrwd (addr (ptrtable (1)), counter, string_ptr, 0, ntendptr, "0"b, was_found,
			     not_found, diag_no, ntptr2);
			if not_found
			then adiag.number = fatal_FILE_NAME_EXPECTED;
			else if ^was_found
			then adiag.number = diag_no;
			else do;
				if ntptr2 -> fd_token.type = 12
				then do;
					call cobol_read_ft_ (ntptr2 -> fd_token.file_no, ft_ptr);
					if file_table.linage
					then linage_counter_type9.seg = file_table.fsb.seg;
					else adiag.number = fatal_NO_LINAGE_FOR_THIS_FILE;
				     end;
				else adiag.number = fatal_FILE_NAME_EXPECTED;
			     end;
		     end;
	     end;					/* qualifier specified */
	else do;					/* there must be only one file with linage then */
		return_code = rcode_SCAN_CURRENT;
		do i = 1 to fixed_common.file_count;
		     call cobol_read_ft_ (i, ft_ptr);
		     if file_table.linage
		     then do;
			     if linage_counter_type9.seg ^= 0
			     then do;
				     adiag.number = fatal_AMBIGUOUS_LINAGE_REF;
				     i = fixed_common.file_count;
				end;
			     else linage_counter_type9.seg = file_table.fsb.seg;
			end;
		end;
		if linage_counter_type9.seg = 0
		then adiag.number = fatal_NO_LINAGE_FOR_ANY_FILE;
	     end;					/* no qualifier specified */
	call swfput1 (addr (linage_counter_type9));
	if adiag.number ^= 0
	then call swfput1 (addr (adiag));
	return;					/*		     end;
/*	else	if s = 565
/*		then do;		/* LINE-COUNTER */
						/*			special_usrwd.length = 12;
/*			special_usrwd.name = cline_counter;
/*		    end;
/*	else	if s = 578
/*		then do;		/* PAGE-COUNTER */
						/*			special_usrwd.length = 12;
/*			special_usrwd.name = cpage_counter;
/*		    end;
/*	else	if s = 440
/*		then do;		/* SYSTEM-STATUS */
						/*			special_usrwd.length = 13;
/*			special_usrwd.name = csystem_status;
/*		    end;
/*	else do;			/* Assume TALLY. */
						/*		special_usrwd.length = 5;
/*		special_usrwd.name = ctally;
/*	    end;
/*	special_usrwd.size = size_TOKEN(8) + special_usrwd.length;
/*	recsize2 = special_usrwd.size;
/*	ptr2 = addr(special_usrwd);
/*	go to replab(8);		/* Process as a user word. */
						/* RFI */

rw (9):						/* Reserved word "SEARCH" */
	rw_search = "1"b;
	go to put1;

rw (8):
	rw_initterm, rw_generate = "0"b;		/* Reserved words PERFORM, INITIATE, TERMINATE, GENERATE */
	rw_switch = "1"b;
	rw_perform = "1"b;				/*[4.4-1]*/
	if ptr2 -> reserved_word.key = reswd_INITIATE | ptr2 -> reserved_word.key = reswd_TERMINATE
						/*[4.4-1]*/
	then rw_initterm = "1"b;
	else if ptr2 -> reserved_word.key = reswd_GENERATE
	then rw_generate = "1"b;
	go to put1;
rw (10):						/* Reserved words SEQUENCE, UPON, FROM, SET */
	rw_key = ptr2 -> reserved_word.key;
	call swfput;
	call swfget;
	return_code = rcode_SCAN_CURRENT;
	if rw_key = reswd_UPON
	then do;					/* DISPLAY UPON {SYSOUT | CONSOLE} */
		if user_word.type = 8
		then if substr (user_word.word, 1, user_word.length) = "console"
			| substr (user_word.word, 1, user_word.length) = "sysout"
		     then do;
			     counter = 1;
			     ptrtable (1) = ptr2;
			     call cobol_usrwd (addr (ptrtable (1)), counter, string_ptr, 0, ntendptr, "0"b,
				was_found, not_found, diag_no, ntptr2);
			     if not_found
			     then do;
				     call issue_obsolete_warning;
				     string (type17.class) = "000100"b;
						/* display device */
				     if user_word.length = 6
				     then type17.iw_key = 10;
						/* SYSOUT */
				     else type17.iw_key = 11;
						/* CONSOLE */
				     call put_type17;
				end;
			end;
	     end;

	else if rw_key = reswd_FROM
	then do;					/* ACCEPT FROM {SYSIN | CONSOLE} */
		rw_switch = "0"b;			/* as with rw(3) */
		if user_word.type = 8
		then if substr (user_word.word, 1, user_word.length) = "console"
			| substr (user_word.word, 1, user_word.length) = "sysin"
		     then do;
			     counter = 1;
			     ptrtable (1) = ptr2;
			     call cobol_usrwd (addr (ptrtable (1)), counter, string_ptr, 0, ntendptr, "0"b,
				was_found, not_found, diag_no, ntptr2);
			     if not_found
			     then do;
				     call issue_obsolete_warning;
				     string (type17.class) = "001000"b;
						/* accept device */
				     if user_word.length = 5
				     then type17.iw_key = 9;
						/* SYSIN */
				     else type17.iw_key = 11;
						/* CONSOLE */
				     call put_type17;
				end;
			end;
	     end;

	else if rw_key = reswd_SET
	then do;					/* SET SWITCH-n */
		rw_switch = "0"b;			/* as with rw(3) */
		if user_word.type = 8
		then if user_word.length = 8 & substr (user_word.word, 1, 7) = "switch-"
		     then do;
			     temp_char = substr (user_word.word, 8, 1);
			     if temp_char >= "1" & temp_char <= "8"
			     then do;
				     counter = 1;
				     ptrtable (1) = ptr2;
				     call cobol_usrwd (addr (ptrtable (1)), counter, string_ptr, 0, ntendptr,
					"0"b, was_found, not_found, diag_no, ntptr2);
				     if not_found
				     then do;
					     call issue_obsolete_warning;
					     string (type17.class) = "010000"b;
						/* switch_name */
					     type17.iw_key = fixed (temp_char);
					     call put_type17;
					end;
				end;
			end;
	     end;

	else if rw_key = reswd_SEQUENCE
	then do;					/* {SORT | MERGE} ... SEQUENCE {IS} {ASCII | EBCDIC} */
		if user_word.type = 1
		then if ptr2 -> reserved_word.key = reswd_IS
		     then do;
			     call swfput;
			     call swfget;
			end;
		if user_word.type = 8
		then if substr (user_word.word, 1, user_word.length) = "ascii"
			| substr (user_word.word, 1, user_word.length) = "ebcdic"
		     then do;
			     counter = 1;
			     ptrtable (1) = ptr2;
			     call cobol_usrwd (addr (ptrtable (1)), counter, string_ptr, 0, ntendptr, "0"b,
				was_found, not_found, diag_no, ntptr2);
			     if not_found
			     then do;
				     call issue_obsolete_warning;
				     type40.line, type40.def_line = adiag.line;
				     type40.column = adiag.column;
				     type40.type = 40;
				     type40.name_size = user_word.length;
				     type40.name = substr (user_word.word, 1, user_word.length);
				     type40.size = size_TOKEN (40) + type40.name_size;
				     if user_word.length = 5
				     then type40.iw_key = 11;
						/* ASCII */
				     else call cobol_set_type40_$ebcdic (addr (type40));
						/* EBCDIC */
						/*-07/26/76-*/
				     call swfput1 (addr (type40));
				     return_code = rcode_SCAN_NEXT;
				end;
			end;
	     end;

	return;


put_type17:
     proc;
	type17.line, type17.def_line = user_word.line;
	type17.column = user_word.column;
	type17.name_size = user_word.length;
	type17.name = substr (user_word.word, 1, user_word.length);
	type17.size = size_TOKEN (17) + type17.name_size;
	call swfput1 (addr (type17));
	return_code = rcode_SCAN_NEXT;
	return;
     end put_type17;

issue_obsolete_warning:
     proc;
	adiag.line = user_word.line;
	adiag.column = user_word.column;
	adiag.number = warn_OBSOLETE_MNEMONIC_NAME;
	call cobol_c_list (addr (adiag));
	if cobol_$compile_count ^= replb_compile_count
	then do;					/* once per compilation */
		adiag.number = obs_SPECIAL_NAMES_NOTE;
		call cobol_c_list (addr (adiag));

/*[4.4-2]*/
		if fixed_common.comp_level < "5"
		then call lev_diag (125, ptr2);

		replb_compile_count = cobol_$compile_count;
	     end;
	adiag.number = warn_SPECIAL_NAMES_RECOVERY;
	adiag.size = 40;
	substr (adiag.info, 1, 1) = "1"b;
	adiag.image_size = user_word.length;
	adiag.image = substr (user_word.word, 1, user_word.length);
	call cobol_c_list (addr (adiag));
	adiag.size = 28;
	substr (adiag.info, 1, 1) = "0"b;
	adiag.image_size = 0;
	return;
     end issue_obsolete_warning;			/*-07/07/76-*/


/*************************************/
replab (2):					/* numeric literal */
	if rw_switch
	then if ptr2 -> numeric_lit.sign = " " & ptr2 -> numeric_lit.exp_sign = " " & ptr2 -> numeric_lit.integral
	     then do;				/* unsigned integer with no exponent */
		     ptr2_1 = ptr2;
		     num_literal = "1"b;
		     counter = 0;
		     topstack = 1;
		     call push1;
		     go to usw1;
		end;
	go to put;
replab (3):
	;
replab (4):
	;
replab (5):
	;
replab (6):					/* alphanumeric literal, picture string, message, source card */
	go to put;
replab (7):					/* section or paragraph name definition */
	if type25_flag
	then go to put;				/* Simply write out DDALLOC appended type 7 */
	if ^ptr2 -> proc_def.searched
	then do;					/* This section or paragraph name not replaced yet. */
		special_usrwd.column = ptr2 -> proc_def.proc_num;
		special_usrwd.length = ptr2 -> proc_def.name_size;
		substr (special_usrwd.name, 1, special_usrwd.length) =
		     substr (ptr2 -> proc_def.name, 1, ptr2 -> proc_def.name_size);
		save_ptr2 = ptr2;
		ptr2 = addr (special_usrwd);

/* Try to find this section or paragraph name in the name table buffer. */

		call cobol_find_secdef (ptr2, sectno, string_ptr, ntptr);
		if ntptr ^= null ()
		then do;				/* found the name table buffer entry */
						/*			ntptr->proc_def.searched = "1"b;  /* Mark as "already replaced". */
						/*-11/11/76-*/
			ntptr -> proc_def.type = 7;
			call swfput1 (ntptr);	/* Write out entry from name table buffer. */
			ntptr -> proc_def.type = 18;	/* Restore type in name table buffer to 18. */
			call swfget;		/* Read next record from input file. */
			return_code = rcode_SCAN_CURRENT;
						/* Scan current record next. */
			return;
		     end;
		else ptr2 = save_ptr2;		/* Section or paragraph name not found - Restore ptr2. */
	     end;
	go to put;
replab (8):
	counter = 0;
	topstack = 1;
	stackbegptr = addr (stack);
	name_stack_overflow = "0"b;
	too_many_qualifiers = "0"b;			/*[4.2-7]*/
	P2 = ptr2;				/* save loc of user word token */
uswo:
	call push;
usw1:
	sav_ptr = ptr2;
	call swfget;
	qualif = "0"b;				/*[4.4-2]*/
usw2:
	if ptr2 -> reserved_word.type = 1 /*[4.4-2]*/
	     & (ptr2 -> reserved_word.key = 133 | ptr2 -> reserved_word.key = 101)
						/* "OF" or "IN" */
	then do;					/*[4.0-4]*/
		num_literal = "0"b;
again:
		call swfget;
		if user_word.type = 8
		then do;				/* Qualification test for leveling*/
			if fixed_common.comp_level < "3"
			then qualif = "1"b;		/*[4.4-1]*/
			call push;
			call swfget;
			go to usw2;
		     end;
		if user_word.type = 2 & rw_switch
		then do;
			if ptr2 -> numeric_lit.sign = " " & ptr2 -> numeric_lit.exp_sign = " "
			     & ptr2 -> numeric_lit.integral
			then do;			/* unsigned integer with no exponent */
						/*[4.4-2]*/
				call push1;
				call swfget;	/*[4.4-2]*/
				go to usw2;
			     end;
		     end;
		if ptr2 -> reserved_word.type = 1 & ptr2 -> reserved_word.key = 531
						/* DEBUG-ITEM */
		then go to rw (7);			/* special processing for reserved word "DEBUG-ITEM" */

/* The current record follows "OF" or "IN", but is not a type 8 token. */

diag1:
		adiag.number = 10;
		adiag.line = user_word.line;
		adiag.column = user_word.column;
		ptr3 = addr (adiag);
		call swfput1 (ptr3);		/* Write out the diagnostic record. */
		return_code = rcode_ERROR_DETECTED;
		return;
	     end;

	if name_stack_overflow | too_many_qualifiers
	then do;
		return_code = rcode_ERROR_DETECTED;
		return;
	     end;

/*[4.0-4]*/
	if ptr2 -> reserved_word.type = 1 & ptr2 -> reserved_word.key = 168
						/* times */
						/*[4.0-4]*/
	then do;					/*[4.0-4]*/
		rw_switch = "0"b;			/*[4.0-4]*/
		if num_literal			/*[4.0-4]*/
		then do;				/*[4.0-4]*/
			num_literal = "0"b;		/*[4.0-4]*/
			ntptr = ptr2_1;		/*[4.0-4]*/
			go to found1;		/*[4.0-4]*/
		     end;				/*[4.0-4]*/
	     end;

	call cobol_usrwd (addr (ptrtable (1)), counter, string_ptr, sectno, ntendptr, rw_switch, was_found, not_found,
	     diag_no, ntptr2);

	if was_found
	then go to found;
	if not_found				/*[4.0-5]*/
	then if rw_debugging			/*[4.0-5]*/
	     then do;
		     call cobol_usrwd (addr (ptrtable (1)), counter, string_ptr, sectno,
						/*[4.0-5]*/
			ntendptr, ^rw_switch,	/*[4.0-5]*/
			was_found, not_found, diag_no, ntptr2);

/*[4.0-5]*/
		     if was_found
		     then go to found;		/*[4.0-5]*/
		     if not_found
		     then go to notfound;		/*[4.0-5]*/
		end;

/*[4.0-5]*/
	     else go to notfound;

	adiag.number = diag_no;
	call issue_diag;
	return_code = rcode_ERROR_DETECTED;
	return;

notfound:
	if ^rw_switch
	then adiag.number = fatal_DATANAME_NOT_DECLARED;
	else adiag.number = fatal_PROCNAME_NOT_DECLARED;
	call issue_diag;
	return_code = rcode_ERROR_DETECTED;
	return;

put:
	return_code = rcode_NO_INTEREST;
	return;
put1:
	return_code = rcode_RESWORD_REC;
	return;
found:						/*[4.4-2]*/
	if qualif
	then call lev_diag (5, sav_ptr);		/*[4.4-2]*/
	call l66_test;

	ntptr = ntptr2;
found1:
	if fixed_common.options.xrn
	then if auser_word.line > 0
	     then do;
		     chain_count = chain_count + 1;
		     chain_area.ref_line (chain_count) = auser_word.line;
		     chain_area.next (chain_count) = 0;
		     xref_ptr = addrel (ntptr, divide (ntptr -> data_name.size + 3, 4, 17, 0));
		     if xref_chain.last = 0
		     then xref_chain.first = chain_count;
		     else chain_area.next (xref_chain.last) = chain_count;
		     xref_chain.last = chain_count;
		end;				/**/
						/*	if ^rw_using
/*	then call unload;
/**/
	return_code = rcode_DNAME_REC;
	return;
     end repl3_scan;

rend:
	return;					/* Have just read an End Of File - Exit from REPLB. */

push:
     proc;

	if name_stack_overflow | too_many_qualifiers
	then return;

	if counter = 50
	then do;					/* too many qualifiers in this reference */
		adiag.number = 11;
		call issue_diag;
		too_many_qualifiers = "1"b;
		return;
	     end;
	stackptr = addr (temp_stack (topstack));
	topstack = topstack + recsize2 + 4 - mod (recsize2, 4);

	if topstack > name_stack_size
	then do;					/* NAME STACK OVERFLOW */
		adiag.number = 12;
		call issue_diag;
		name_stack_overflow = "1"b;
		return;
	     end;
	stackrecord = minpr_record;
	counter = counter + 1;
	ptrtable (counter) = stackptr;

     end push;

/**/
/*unload:	proc;
/*
/*	if final_iter
/*	then return;
/*
/*	do j = 1 to counter;
/*		ptr3 = ptrtable(j);
/*		stackptr = ptrtable(j);
/*		call swfput1(ptr3);
/*		if j ^= counter
/*		then call swfput1(addr(res_word_of));
/*	end;
/*	return;
/*
/*end unload;
/**/

swfget:
     proc;

	call cobol_swf_get (cobol_curr_in, status, ptr2, recsize2);
	if status_right ^= "0"b
	then go to rend;
	return;

     end swfget;

swfput:
     proc;

	temp_ptr = addrel (cobol_curr_out, shdr.next + 1);
	call cobol_swf_put (cobol_curr_out, status, ptr2, ptr2 -> data_name.size);
	if temp_ptr -> data_name.type = 9
	then temp_ptr -> data_based.offset = binary (rel (ptr2));
	return;

     end swfput;

swfput1:
     proc (out_ptr);

dcl	out_ptr		ptr;

	temp_ptr = addrel (cobol_curr_out, shdr.next + 1);
	call cobol_swf_put (cobol_curr_out, status, out_ptr, out_ptr -> data_name.size);
	if temp_ptr -> data_name.type = 9
	then temp_ptr -> data_based.offset = binary (rel (out_ptr));
	return;

     end swfput1;

swfput2:
     proc (out_ptr);

/*[4.0-5]*/
/* obtain name as qualified in the	*/
/*[4.0-5]*/
/* source program when debugging mode	*/
/*[4.0-5]*/
/* used				*/

/*[4.0-5]*/
declare	out_ptr		ptr;			/*[4.0-5]*/
declare	sz		fixed bin,
	p		ptr;

/*[4.0-5]*/
declare	nt_entry		char (2048);		/*[4.0-5]*/
declare	nam_tab		char (2048) based;

/*[4.4-3]*/
	if ^fixed_common.debug | (fixed_common.debug & counter = 1)
						/*[4.0-5]*/
	then do;
		call swfput1 (out_ptr);		/* debugging not used */
						/*[4.0-5]*/
		return;				/*[4.0-5]*/
	     end;

/*[4.0-5]*/
	p = addr (nt_entry);

/*[4.4-3]*/
	sz = out_ptr -> data_name.size;		/*[4.4-3]*/
	substr (nt_entry, 1, sz) = substr (out_ptr -> nam_tab, 1, sz);

/* qualify the data name */

/*[4.4-3]*/
	substr (addr (p -> data_name.name) -> ch32, 1, 32) =
	     /*[4.4-3]*/ substr (addr (ptrtable (1) -> user_word.word) -> ch32, 1, 32);
						/*[4.4-3]*/
	p -> data_name.name_size = 32;

/*[4.0-5]*/
	call swfput1 (p);

     end;

issue_diag:
     proc;

	adiag.line = stackbegptr -> auser_word.line;
	adiag.column = stackbegptr -> auser_word.column;
	ptr3 = addr (adiag);
	call swfput1 (ptr3);
     end issue_diag;

push1:
     proc;

	if name_stack_overflow | too_many_qualifiers
	then return;

	if counter = 50
	then do;					/* too many qualifiers in this reference */
		adiag.number = 11;
		call issue_diag;
		too_many_qualifiers = "1"b;
		return;
	     end;
	stackptr = addr (temp_stack (topstack));
	if topstack > name_stack_size
	then do;					/* NAME STACK OVERFLOW */
		adiag.number = 12;
		call issue_diag;
		name_stack_overflow = "1"b;
		return;
	     end;
	auser_word.line = ptr2 -> numeric_lit.line;
	auser_word.column = ptr2 -> numeric_lit.column;
	auser_word.type = 8;
	auser_word.info1 = false;
	auser_word.info2 = false;
	auser_word.length = ptr2 -> numeric_lit.places;
	auser_word.word = ptr2 -> numeric_lit.literal;
	auser_word.size = 24 + ptr2 -> numeric_lit.places;

	counter = counter + 1;
	topstack = topstack + auser_word.size + mod (-auser_word.size, 4);
						/*[3.0-1]*/
	ptrtable (counter) = stackptr;

     end push1;

process_subscript:
     proc (stack);

/* Processes subscripts in cases where speciaal processing is required.
		   (i.e.:
			1) expand_condition_names - the subscript tokens are stacked for special
			   processing by repl3_expand.
			2) INITIALIZE - the subscript tokens should be written out with no
			   intervening type 26 tokens.) */

dcl	stack		bit (1);			/* if "1"b, stack tokens in ss_stack, else write to output file. */

	processing_subscript = "1"b;
	ss_recovered = "0"b;
	next_state = 1;
	if stack
	then do;					/* Initialize ss_stack variables and stack "(" token. */
		cobol_ss_stack.no_entries = 0;
		subscript_stack_overflow = "0"b;
		ss_topstack = 1;
		call push_special;
	     end;
	else call swfput;				/* Write "(" token. */
ss_read:
	call swfget;
ss_scan:
	call repl3_scan (status, return_code);
	if return_code = rcode_NO_INTEREST & user_word.type > 4
	then do;
		call swfput;			/* Write out current record in read buffer. */
		if user_word.type = 5
		then do;				/* diagnostic record */
			call swfget;
			go to ss_recover;
		     end;
		else go to ss_read;
	     end;
	go to ss_state (next_state);
ss_state (1):
	if return_code = rcode_NO_INTEREST & user_word.type = 2
						/* numeric literal */
	then do;
		next_state = 1;
		if stack
		then call push_special;
		else call swfput;
		go to ss_read;
	     end;
	else if return_code = rcode_RESWORD_REC
	then do;					/* a reserved word */
		if ptr2 -> reserved_word.key = 188	/* ")" */
		then do;
			if stack
			then call push_special;
			else call swfput;
			call swfget;
			go to ss_finish;
		     end;
		else if ptr2 -> reserved_word.key = 182 /* "+" */
		then do;
			next_state = 4;
			if stack
			then call push_special;
			else call swfput;
			go to ss_read;
		     end;
		else do;				/* Bad component in subscript */
			adiag.number = 7;
			go to ss_error;
		     end;
	     end;
	else if return_code = rcode_DNAME_REC
	then do;					/* a user name */
		next_state = 2;
		if stack
		then call push_name;
		else do;
			save_line = ntptr -> data_name.line;
			save_column = ntptr -> data_name.column;
			ntptr -> data_name.line = stackbegptr -> auser_word.line;
			ntptr -> data_name.column = stackbegptr -> auser_word.column;
						/*[4.0-5]*/
			call swfput2 (ntptr);
			ntptr -> data_name.line = save_line;
			ntptr -> data_name.column = save_column;
		     end;
		go to ss_scan;
	     end;
	else do;					/* Bad component in subscript */
		adiag.number = 7;
		go to ss_error;
	     end;
ss_state (2):
	if return_code = rcode_RESWORD_REC & ptr2 -> reserved_word.key = 183
						/* "-" */
	then do;
		next_state = 3;
		if stack
		then call push_special;
		else call swfput;
		go to ss_read;
	     end;
	else do;
		next_state = 1;
		if return_code = rcode_DNAME_REC
		then if stack
		     then call push_name;
		     else do;
			     save_line = ntptr -> data_name.line;
			     save_column = ntptr -> data_name.column;
			     ntptr -> data_name.line = stackbegptr -> auser_word.line;
			     ntptr -> data_name.column = stackbegptr -> auser_word.column;
						/*[4.0-5]*/
			     call swfput2 (ntptr);
			     ntptr -> data_name.line = save_line;
			     ntptr -> data_name.column = save_column;
			end;
		go to ss_scan;
	     end;
ss_state (3):
	if return_code = rcode_NO_INTEREST & user_word.type = 2
						/* numeric literal */
	then do;
		next_state = 1;
		if stack
		then call push_special;
		else call swfput;
		go to ss_read;
	     end;
	else do;
		adiag.number = 9;			/* numeric literal expected here */
		go to ss_error;
	     end;
ss_state (4):
	if return_code = rcode_NO_INTEREST & user_word.type = 2
						/* numeric literal */
	then do;
		next_state = 1;
		if stack
		then call push_special;
		else call swfput;
		go to ss_read;
	     end;
	else if return_code = rcode_DNAME_REC
	then do;					/* a data name */
		next_state = 1;
		if stack
		then call push_name;
		else do;
			save_line = ntptr -> data_name.line;
			save_column = ntptr -> data_name.column;
			ntptr -> data_name.line = stackbegptr -> auser_word.line;
			ntptr -> data_name.column = stackbegptr -> auser_word.column;
						/*[4.0-5]*/
			call swfput2 (ntptr);
			ntptr -> data_name.line = save_line;
			ntptr -> data_name.column = save_column;
		     end;
		go to ss_scan;
	     end;
	else do;					/* numeric literal, data-name, or index-name expected here */
		adiag.number = 8;
		go to ss_error;
	     end;
ss_error:
	if return_code = rcode_ERROR_DETECTED
	then go to ss_recover;			/* An error message has already been issued. */
	if return_code = rcode_DNAME_REC
	then do;
		adiag.line = stackbegptr -> auser_word.line;
		adiag.column = stackbegptr -> auser_word.column;
	     end;
	else do;
		adiag.line = user_word.line;
		adiag.column = user_word.column;
	     end;
	ptr3 = addr (adiag);
	call swfput1 (ptr3);			/* Write out the diagnostic. */
ss_recover:					/* Attempt to recover to the 1st statement terminator,
				   or to a suitable key reserved word. */
	do while (^ss_recovered);
	     call repl3_scan (status, return_code);
	     if return_code = rcode_RESWORD_REC
	     then do;
		     if ptr2 -> reserved_word.terminator
		     then ss_recovered = "1"b;
		     else do;
			     rwkey = ptr2 -> reserved_word.key;
			     if expand_condition_names
			     then do;
				     if rwkey = 77 /* "AND" */ | rwkey = 135
						/* "OR" */
				     then ss_recovered = "1"b;
				end;
			     else if rw_corresponding
			     then do;
				     if rwkey = 170 /* "TO" */ | rwkey = 111
						/* "FROM" */
				     then ss_recovered = "1"b;
				end;
			end;
		end;
	     else if return_code = rcode_NO_INTEREST
	     then if user_word.type = 5
		then call swfput;			/* Write out diagnostic */
	     if ^ss_recovered
	     then call swfget;
	end;
ss_finish:
	processing_subscript = "0"b;

     end process_subscript;

push_special:
     proc;

	if subscript_stack_overflow
	then return;

	ss_stack_ptr = addr (ss_template (ss_topstack));
	ss_recsize = recsize2;
	ss_topstack = ss_topstack + ss_recsize + 4 - mod (ss_recsize, 4);

	if ss_topstack > subscript_stack_size
	then do;					/* SUBSCRIPT STACK OVERFLOW */
		stackbegptr = ptr2;
		adiag.number = 13;
		call issue_diag;
		subscript_stack_overflow = "1"b;
		return;
	     end;
	cobol_ss_stackrecord = minpr_record;
	cobol_ss_stack.no_entries = cobol_ss_stack.no_entries + 1;
	ss_ptrtable (cobol_ss_stack.no_entries) = ss_stack_ptr;
						/**/
						/*	if ^final_iter
/*	then call swfput;
/**/
     end push_special;

push_name:
     proc;

dcl	ntrecord		char (ss_recsize) based (ntptr);

	if subscript_stack_overflow
	then return;

	save_line = ntptr -> data_name.line;
	save_column = ntptr -> data_name.column;
	ntptr -> data_name.line = stackbegptr -> auser_word.line;
	ntptr -> data_name.column = stackbegptr -> auser_word.column;
	ss_recsize = ntptr -> data_name.size;
	ss_stack_ptr = addr (ss_template (ss_topstack));
	ss_topstack = ss_topstack + ss_recsize + 4 - mod (ss_recsize, 4);

	if ss_topstack > subscript_stack_size
	then do;					/* SUBSCRIPT STACK OVERFLOW */
		stackbegptr = ptr2;
		adiag.number = 13;
		call issue_diag;
		subscript_stack_overflow = "1"b;
		return;
	     end;
	cobol_ss_stackrecord = ntrecord;
	cobol_ss_stack.no_entries = cobol_ss_stack.no_entries + 1;
	ss_ptrtable (cobol_ss_stack.no_entries) = ss_stack_ptr;
	ntptr -> data_name.line = save_line;		/* Restore correct line & column to name table entry. */
	ntptr -> data_name.column = save_column;

     end push_name;

/* RFI */

perform_recover:
     proc (status, recovered_to_thru);

dcl	status		bit (32);
dcl	recovered_to_thru	bit (1);			/* Set to "1"b by this procedure if a "THRU" is found before
					   any occurrence of:
						TIMES, UNTIL, VARYING, or a statement terminator. */
dcl	1 status_word	based (st_ptr),
	  2 status_left	bit (16),
	  2 status_right	bit (16);
dcl	st_ptr		ptr;

	st_ptr = addr (status);
	status = "0"b;
	recovered_to_thru = "0"b;
recover_analysis:
	if return_code = rcode_RESWORD_REC
	then do;					/* a reserved word */
		if ptr2 -> reserved_word.key = 166	/* "THRU" */
		then do;
			recovered_to_thru = "1"b;
			return;
		     end;
		else if ptr2 -> reserved_word.key = 168 /* "TIMES" */
		     | ptr2 -> reserved_word.key = 173 /* "UNTIL" */
		     | ptr2 -> reserved_word.key = 177 /* "VARYING" */ | ptr2 -> reserved_word.terminator
		then return;
		else go to recover_write;
	     end;
	if return_code = rcode_ERROR_DETECTED
	then go to recover_scan;
	if return_code = rcode_DNAME_REC
	then do;					/* Write out the name table entry. */
		save_line = ntptr -> data_name.line;
		save_column = ntptr -> data_name.column;
		ntptr -> data_name.line = stackbegptr -> auser_word.line;
		ntptr -> data_name.column = stackbegptr -> auser_word.column;
						/*[4.0-5]*/
		call swfput2 (ntptr);
		ntptr -> data_name.line = save_line;	/* Restore correct line and column to name table entry. */
		ntptr -> data_name.column = save_column;
		go to recover_scan;
	     end;

/* The current record is a no interest record and is simply written out. */

recover_write:
	call swfput;
recover_read:
	call swfget;
	if status_right ^= "0"b
	then go to rend;
recover_scan:
	call repl3_scan (status, return_code);
	if status_right ^= "0"b
	then go to rend;
	else go to recover_analysis;

     end perform_recover;

/*======================================*/

lev_diag:
     proc (diag_num, p);				/*[4.4-2]*/
declare	p		ptr;
dcl	diag_num		fixed bin;
dcl	lev_diag_ptr	ptr;
dcl	1 lev_diag_item,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 run		fixed bin,
	  2 number	fixed bin,
	  2 info		bit (32);

	lev_diag_item.size = 28;
	lev_diag_item.type = 5;
	lev_diag_item.run = 9;
	lev_diag_item.info = "0"b;			/*[4.4-2]*/
	lev_diag_item.line = p -> user_word.line;	/*[4.4-2]*/
	lev_diag_item.column = p -> user_word.column;
	lev_diag_item.number = diag_num;

	lev_diag_ptr = addr (lev_diag_item);
	call cobol_c_list (lev_diag_ptr);

     end lev_diag;

/*[4.4-2]*/
l66_test:
     proc;					/* emit lev diag 220 if ref to level 66 item found */
						/*[4.4-2]*/
	if fixed_common.comp_level < "3"		/*[4.4-2]*/
	then if ntptr2 -> data_name.type = 9 & ntptr2 -> data_name.level = 66
						/*[4.4-2]*/
	     then call lev_diag (220, sav_ptr);

     end;						/*[4.4-2]*/





/*************************************/
/* INCLUDE FILES */

%include cobol_ext_;
%include cobol_io_info;
%include cobol_fixed_common;
%include cobol_file_table;
%include cobol_type17;
%include cobol_type1;
%include cobol_type2;
%include cobol_type7;
%include cobol_type9;
%include cobol_type12;
%include cobol_xref;
%include cobol_;

%include cobol_repl_diag_values;
%include cobol_size_values;
%include cobol_reswd_values;
     end cobol_replb;
