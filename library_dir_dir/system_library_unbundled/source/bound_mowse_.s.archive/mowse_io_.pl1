/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1987 *
        *                                                         *
        *********************************************************** */

/* format: style4,indattr,ifthen,^indcomtxt,thendo,^indproc,^indblkcom,initcol1,declareind8,dclind4,struclvlind3,comcol55 */
mowse_io_:
     proc ();


/* PROGRAM FUNCTION

This is the main driver for "mowse_io_" module which includes I/O protocols
between a user's process on Multics and a Personal Computer (PC) through which
the user has logged into using the PC version of MOWSE.  The following I/O
system calls are provided for this module:

   attach		mowse_io_$mowse_io_attach
   close		mowse_io_$mowse_io_close
   close_file	mowse_io_$mowse_io_close_file
   control	mowse_io_$mowse_io_control
   detach_iocb	mowse_io_$mowse_io_detach_iocb
   get_chars	mowse_io_$mowse_io_get_chars
   get_line	mowse_io_$mowse_io_get_line
   modes		mowse_io_$mowse_io_modes
   open		mowse_io_$mowse_io_open
   open_file	mowse_io_$mowse_io_open_file
   put_chars	mowse_io_$mowse_io_put_chars
*/


/* NOTES
*/

/****^  HISTORY COMMENTS:
  1) change(87-04-16,Flegel), approve(87-06-23,MCR7649),
     audit(87-07-30,RBarstad), install(87-08-07,MR12.1-1075):
     Created.
  2) change(87-08-18,LJAdams), approve(87-08-18,PBF7649),
     audit(87-08-18,Wallman), install(87-08-18,MR12.1-1091):
     Changed references to editing_chars_version to editing_chars_version_3.
  3) change(88-10-06,Flegel), approve(88-11-16,MCR8023), audit(88-12-12,Lee),
     install(89-01-24,MR12.3-1012):
     phx21215 - Changed (read write)_status control to use a mowse created
                event channel as the channel information returned.  This
                channel will have events transmitted on it when foregrond data
                is processed.
              - Added control order "get_event_channel".
                                                   END HISTORY COMMENTS */

/* INPUT PARAMETERS */
dcl p_newmodes	       char (*) parameter;	    /* Modes string */
dcl p_descrip	       char (*) parameter;	    /* Open description */
dcl p_unused	       bit (1) parameter;
dcl p_mode	       fixed bin parameter;	    /* Open mode */
dcl p_buf_len	       fixed bin (21) parameter;  /* Buffer length */
dcl p_buf_ptr	       ptr parameter;	    /* buffer pointer */
dcl p_order	       char (*) parameter;	    /* Control order */
dcl p_info_ptr	       ptr parameter;	    /* Control info pointer */
dcl p_options	       (*) char (*) var parameter;/* Option array */
dcl p_loud	       bit (1) aligned parameter; /* Turn on error printing here */
dcl p_iocb_ptr	       ptr parameter;	    /* IOCB structure pointer */

/* OUTPUT PARAMETERS */
dcl p_oldmodes	       char (*) parameter;	    /* Old modes string */
dcl p_chars_read	       fixed bin (21) parameter;
dcl p_code	       fixed bin (35) parameter;  /* Error code */

/* MISC VARIABLES */
dcl new_modes	       char (512);		    /* Mode string */
dcl confirmed_disconnect   bit (1);		    /* If disconnect will require confirmation */
dcl printer_msg	       char (5);		    /* POx00 message to WSTERM */
dcl order		       char (32) var;	    /* Control order */
dcl pl		       fixed bin;		    /* Page length */
dcl ll		       fixed bin;		    /* Line length */
dcl erkl_esc	       char (3);		    /* Erase, Kill, Escape chars */
dcl i		       fixed bin;
dcl iocb_ptr	       ptr;		    /* IOCB */
dcl system_free_area       area based (system_free_area_ptr);
dcl system_free_area_ptr   ptr;
dcl ind		       fixed bin;		    /* Index counter */
dcl target_iocb_ptr	       ptr;
dcl mask		       bit (36) aligned;	    /* IPS mask */
dcl mio_data_ptr	       ptr;		    /* mowse_io_ data */

/* STRUCTURES */
dcl fixedbin21	       fixed bin (21) based;
dcl fixedbin71al	       fixed bin (71) aligned based;
dcl 01 ipc_arg	       like ipc_create_arg_structure aligned automatic;
dcl 01 trans	       like cv_trans_struc aligned automatic;
dcl ll_overlay	       fixed bin (9) based;	    /* Info for line_length order */
dcl buf		       (p_buf_len) char (1) based (p_buf_ptr);
dcl 01 mio_data	       like mowse_io_data based (mio_data_ptr);
dcl 01 fatal_error_info    aligned,
       02 version	       fixed bin,		    /* Must be 0 */
       02 status_code      fixed bin (35);	    /* Error code */

/* SYSTEM CALLS */
dcl ipc_$create_event_channel entry (ptr, fixed bin (71), fixed bin (35));
dcl clock_	       entry () returns (fixed bin (71));
dcl ttt_info_$initial_string entry (char (*), char (*) var, fixed bin (35));
dcl ttt_info_$modes	       entry (char (*), char (*), fixed bin (35));
dcl ipc_$delete_ev_chn     entry (fixed bin (71), fixed bin (35));
dcl sct_manager_$get       entry (fixed bin, ptr, fixed bin (35));
dcl sct_manager_$set       entry (fixed bin, ptr, fixed bin (35));
dcl mode_string_$get_mode  entry (char (*), char (*), ptr, fixed bin (35));
dcl mode_string_$parse     entry (char (*), ptr, ptr, fixed bin (35));
dcl ipc_$create_ev_chn     entry (fixed bin (71), fixed bin (35));
dcl get_process_id_	       entry () returns (bit (36));
dcl iox_$modes	       entry (ptr, char (*), char (*), fixed bin (35));
dcl iox_$put_chars	       entry (ptr, ptr, fixed bin (21), fixed bin (35));
dcl iox_$get_line	       entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
dcl iox_$control	       entry (ptr, char (*), ptr, fixed bin (35));
dcl iox_$get_chars	       entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
dcl terminate_process_     entry (char (*), ptr);
dcl iox_$propagate	       entry (ptr);
dcl hcs_$reset_ips_mask    entry (bit (36) aligned, bit (36) aligned);
dcl com_err_	       entry () options (variable);
dcl hcs_$set_ips_mask      entry (bit (36) aligned, bit (36) aligned);
dcl get_system_free_area_  entry () returns (ptr);
dcl iox_$look_iocb	       entry (char (*), ptr, fixed bin (35));

/* SYSTEM CALL SUPPORT */
dcl error_table_$no_initial_string fixed bin (35) ext static;
dcl error_table_$unsupported_operation fixed bin (35) ext static;
dcl error_table_$unimplemented_version fixed bin (35) ext static;
dcl error_table_$null_info_ptr fixed bin (35) ext static;
dcl error_table_$long_record fixed bin (35) ext static;
dcl iox_$err_no_operation  entry () options (variable);
dcl error_table_$bad_mode  fixed bin (35) ext static;
dcl iox_$err_not_open      entry () options (variable);
dcl error_table_$unable_to_do_io fixed bin (35) ext static;
dcl error_table_$invalid_device fixed bin (35) ext static;
dcl error_table_$wrong_no_of_args fixed bin (35) ext static;
dcl error_table_$not_detached fixed bin (35) ext static;

/* EXTERNAL CALLS */
dcl ws_timer_$reset_connect entry ();
dcl ws_debug_$line	       entry () options (variable);
dcl ws_packet_transmitter_$terminate entry (ptr);
dcl ws_packet_transmitter_$local_data entry (ptr, fixed bin, ptr, fixed bin (21), fixed bin);
dcl ws_packet_dispatcher_$terminate entry ();
dcl ws_packet_dispatcher_$initialize entry (ptr, fixed bin (35)
		       );
dcl ws_timer_$queue_sleeper entry (fixed bin (71));
dcl ws_$find_capability_number entry (char (*), fixed bin, fixed bin, fixed bin (35));
dcl capability_$pack       entry (fixed bin, fixed bin, fixed bin, fixed bin (35));
dcl terminate_mowse_       entry (ptr, fixed bin (35));
dcl bound_process_env_$err_no_operation entry options (variable);
dcl ws_timer_$terminate    entry ();
dcl ws_timer_$reset_disconnect entry ();
dcl ws_timer_$initialize   entry (ptr);
dcl ws_channel_$wait_block entry (ptr, ptr, char (*), ptr);
dcl ws_tools_$reset_data   entry (ptr);
dcl ws_packet_transmitter_$supervisory entry (ptr, char (1));
dcl ws_channel_$wait_wakeup entry (ptr, ptr);
dcl ws_packet_transmitter_$reset entry (ptr);
dcl ws_packet_transmitter_$initialize entry (ptr, ptr, fixed bin (35));
dcl ws_debug_$trace_open   entry (ptr, ptr, fixed bin (35));
dcl ws_debug_$trace_close  entry (ptr, fixed bin (35));
dcl ws_debug_$debug_open   entry (ptr, ptr, fixed bin (35));
dcl ws_debug_$debug_close  entry (ptr, fixed bin (35));
dcl mowse_io_call_control_ entry (ptr, char (*), ptr, fixed bin (35));
dcl ws_packet_receiver_$sus_handler entry ();
dcl ws_packet_receiver_$terminate entry (fixed bin (35));
dcl ws_packet_receiver_$initialize entry (ptr, ptr, fixed bin (35));
dcl ws_packet_transmitter_$data entry (ptr, fixed bin, ptr, fixed bin (21), fixed bin);

/* EXTERNAL CALL SUPPORT */
dcl ws_error_$unsupported_ws_terminal
		       fixed bin (35) ext static;
dcl ws_error_$already_sleeping fixed bin (35) ext static;
dcl ws_error_$invalid_sleep_interval fixed bin (35) ext static;
dcl ws_error_$inconsistent_mowse_tables fixed bin (35) ext static;

/* BUILTINS */
dcl ltrim		       builtin;
dcl divide	       builtin;
dcl convert	       builtin;
dcl codeptr	       builtin;
dcl byte		       builtin;
dcl addr		       builtin;
dcl rank		       builtin;
dcl rtrim		       builtin;
dcl mod		       builtin;
dcl unspec	       builtin;
dcl substr	       builtin;
dcl length	       builtin;
dcl index		       builtin;
dcl null		       builtin;
dcl hbound	       builtin;

/* CONDITIONS */
dcl any_other	       condition;
dcl cleanup	       condition;

/* CONSTANTS */
dcl False		       bit (1) int static options (constant) init ("0"b);
dcl True		       bit (1) int static options (constant) init ("1"b);
dcl Stream_input_output_mode fixed bin int static options (constant) init (3);

/**/

/* INITIALIZATION */

/* MAIN */

	return;

/**/

%page;

/* INTERNAL ENTRIES */


/* *** Entry: mowse_io_attach - Internal entry for mowse_io_  *** */

mowse_io_attach:
     entry (p_iocb_ptr, p_options, p_loud, p_code);


/* ENTRY FUNCTION

Attach the MOWSE io module and allocate the MOWSE data space from system
free area.
*/

/* NOTES

MOWSE will not be up until the call to iox_$open is performed by the caller.
*/

	call setup_entry ();
	mask = ""b;
	target_iocb_ptr = null;

/* If the current iocb is not detached, error! */

	if iocb_ptr -> iocb.attach_descrip_ptr ^= null then do;
	     p_code = error_table_$not_detached;
	     if p_loud then
		call com_err_ (p_code, "mowse_io_");
	     return;
	end;

/* Check number of arguments */

	if hbound (p_options, 1) ^= 1 then do;
	     p_code = error_table_$wrong_no_of_args;
	     if p_loud then
		call com_err_ (p_code, "mowse_io_");
	     return;
	end;

/* Get an iocb for mowse_io_ */

	call iox_$look_iocb ((p_options (1)), target_iocb_ptr, p_code);
	if p_code ^= 0 then do;
	     if p_loud then
		call com_err_ (p_code, "mowse_io_");
	     return;
	end;

/* Is the device valid */

	if target_iocb_ptr -> iocb.attach_descrip_ptr = null then do;
	     p_code = error_table_$invalid_device;
	     if p_loud then
		call com_err_ (p_code, "mowse_io_");
	     return;
	end;

/* Is the description valid */

	if target_iocb_ptr -> iocb.open_descrip_ptr = null then do;
	     p_code = error_table_$invalid_device;
	     if p_loud then
		call com_err_ (p_code, "mowse_io_");
	     return;
	end;

/* Get attach data space from system free */

	mio_data_ptr = null;
	system_free_area_ptr = null;
	on cleanup call clean_up_mio_data ();
	system_free_area_ptr = get_system_free_area_ ();
	allocate mio_data in (system_free_area) set (mio_data_ptr);
	unspec (mio_data) = ""b;

/* Set options on the attach description */

	ind = index (p_options (1), " ");
	if ind = 0 then
	     ind = length (p_options (1));
	mio_data.attach_descrip =
	     "mowse_io_ " || substr (p_options (1), 1, ind);
	do i = 2 to hbound (p_options, 1);
	     mio_data.attach_descrip = mio_data.attach_descrip || " ";
	     mio_data.attach_descrip
		= mio_data.attach_descrip || p_options (i);
	end;

/* Initialize the fields of mowse_io_data (attach data) */

	mio_data.iocb_ptr = target_iocb_ptr;
	mio_data.default_iocb_ptr = iocb_ptr;
	call initialize_attach_data (p_code);
	if p_code ^= 0 then do;
	     if p_loud then
		call com_err_ (p_code, "mowse_io_");
	     call clean_up_mio_data ();
	     return;
	end;

/* Set up the iocb for mowse_io_ */

	on any_other begin;
	     fatal_error_info.version = 0;
	     fatal_error_info.status_code = error_table_$unable_to_do_io;
	     call terminate_process_ ("fatal_error", addr (fatal_error_info));
	end;

	call hcs_$set_ips_mask (""b, mask);
	iocb_ptr -> iocb.attach_data_ptr = mio_data_ptr;
	iocb_ptr -> iocb.attach_descrip_ptr = addr (mio_data.attach_descrip);
	iocb_ptr -> iocb.detach_iocb = mowse_io_detach_iocb;
	iocb_ptr -> iocb.open = mowse_io_open;
	iocb_ptr -> iocb.open_file = mowse_io_open_file;
	iocb_ptr -> iocb.close = iox_$err_not_open;
	iocb_ptr -> iocb.close_file = iox_$err_not_open;
	call iox_$propagate (iocb_ptr);
	call hcs_$reset_ips_mask (mask, mask);
	revert any_other;

	return;

/**/

/* *** Entry: mowse_io_close - Internal entry for mowse_io_  *** */

/* ENTRY FUNCTION

There are two entries into this section, dtm (detach_mowse) calls with options
(confirmed_disconnect) and other routines call without options, or to close.
*/

/* NOTES
*/

mowse_io_close:
     entry (p_iocb_ptr, p_code);

	call setup_entry ();

	confirmed_disconnect = False;

	goto JOIN_CLOSE;

mowse_io_close_file:
     entry (p_iocb_ptr, p_descrip, p_code);

	call setup_entry ();

	confirmed_disconnect = False;
	if length (p_descrip) > 0 then
	     confirmed_disconnect = (p_descrip = "confirmed_disconnect");

JOIN_CLOSE:

	mask = ""b;

	mio_data.disconnect_active = True;

/* Check the sus_ flag to determine if this process has been disconnected,
   if so, then DO NOT TELL THE TERMINAL as it is no longer valid otherwise,
   perform the necessary to notify the terminal */

	if ^mio_data.sus_data.activated then do;
	     if mio_data.info_ptr ^= null then do;
		call terminate_mowse_ (mio_data.info_ptr, (0));
		if mio_data.info_ptr ^= null then do;
		     free mio_data.info_ptr -> mowse_info;
		     mio_data.info_ptr = null;
		end;
	     end;

/* Perform the requested disconnect type */

	     call disconnect (confirmed_disconnect);

/* Turn off the the protocol stuff */

	     call ws_packet_receiver_$terminate ((0));
	     call ws_timer_$terminate ();
	     call ws_packet_dispatcher_$terminate ();
	     call ws_packet_transmitter_$terminate (mio_data_ptr);

/* MF - phx21215 - Return the foreground events channel to the system */

	     call ipc_$delete_ev_chn (
		mio_data.channel_info.foreground.channel, (0));

/* Close the trace and debug mechanisms */

	     call ws_debug_$debug_close (mio_data.debug_iocb_ptr, (0));
	     call ws_debug_$trace_close (mio_data.trace_iocb_ptr, (0));
	end;

/* Adjust the IOCB */

	on any_other begin;
	     fatal_error_info.version = 0;
	     fatal_error_info.status_code = error_table_$unable_to_do_io;
	     call terminate_process_ ("fatal_error", addr (fatal_error_info));
	end;

/* Must be masked */

	call hcs_$set_ips_mask (""b, mask);

/* Replace the sus_signal_handler_ to what it use to be */

	if ^mio_data.sus_data.activated then do;
	     call sct_manager_$set (susp_sct_index,
		mio_data.sus_data.sus_entry, p_code);
	     if p_code ^= 0 then do;
		call hcs_$reset_ips_mask (mask, mask);
		return;
	     end;
	end;

/* Fix iocb data */

	call initialize_iocb (iocb_ptr -> iocb.actual_iocb_ptr);
	iocb_ptr -> iocb.actual_iocb_ptr -> iocb.open_descrip_ptr
	     = null;
	iocb_ptr -> iocb.actual_iocb_ptr -> iocb.detach_iocb
	     = mowse_io_detach_iocb;
	iocb_ptr -> iocb.actual_iocb_ptr -> iocb.open
	     = mowse_io_open;
	iocb_ptr -> iocb.actual_iocb_ptr -> iocb.open_file
	     = mowse_io_open_file;
	iocb_ptr -> iocb.actual_iocb_ptr -> iocb.close_file
	     = iox_$err_not_open;
	iocb_ptr -> iocb.actual_iocb_ptr -> iocb.close
	     = iox_$err_not_open;
	call iox_$propagate (iocb_ptr);

	if ^mio_data.sus_data.activated then
	     call iox_$modes (mio_data.iocb_ptr, mio_data.old_modes, "", (0));

	call hcs_$reset_ips_mask (mask, mask);
	revert any_other;

	if ^mio_data.sus_data.activated then
	     call iox_$control (mio_data.iocb_ptr, "quit_enable", null, (0));
	return;

/**/

/* *** Entry: mowse_io_control - Internal entry for mowse_io_  *** */

mowse_io_control:
     entry (p_iocb_ptr, p_order, p_info_ptr, p_code);


/* ENTRY FUNCTION

Handle the following iox_$control orders:

      MOWSE Specific:
      ---------------

	debug_off			debug_on
	flush_subchannel		get_mowse_info
	get_terminal_emulator_state	put_to_sleep
	send_local_message		send_message
	set_video_mode		store_mowse_info
	trace_off			trace_on

      Multics Specific (requiring special support):
      ---------------------------------------------

	abort		 get_editing_chars
	get_event_channel	 get_input_conversion
	io_call		 io_call_af
	line_length	 printer_off
	printer_on	 quit_disable
	quit_enable	 reconnection
	resetread		 resetwrite
	read_status	 set_default_modes
	set_editing_chars	 set_input_conversion
	set_term_type	 write_status
*/

/* NOTES
*/

	call setup_entry ();
	order = ltrim (rtrim (p_order));

/* <<<<<<<<<<<<< MOWSE Specific Control Orders >>>>>>>>>>>>>> */

/* debug_off */

	if order = "debug_off" then
	     call ws_debug_$debug_close (mio_data.debug_iocb_ptr, p_code);

/* debug_on */

	else if order = "debug_on" then do;
	     call ws_debug_$debug_open (p_info_ptr, mio_data.debug_iocb_ptr,
		p_code);
	     if p_code = 0 then
		call ws_debug_$line (mio_data.debug_iocb_ptr,
		     "Process ID: ^b^/"
		     || "Channel ID: user_input^9x^24d^/"
		     || "^12xpacket_receiver^4x^24d^/"
		     || "^12xpacket_transmitter ^24d^/"
		     || "Dispatcher: async channel^6x^24d^/"
		     || "^12xsync channel^7x^24d^/^/",
		     mio_data.channel_info.process_id,
		     mio_data.channel_info.user_input.channel,
		     mio_data.channel_info.packet_receiver.channel,
		     mio_data.channel_info.packet_transmitter.channel,
		     mio_data.channel_info.packet_dispatcher.async_channel,
		     mio_data.channel_info.packet_dispatcher.sync_channel);
	end;

/* flush_subchannel */

	else if order = "flush_subchannel" then
	     call flush_subchannel (p_info_ptr, p_code);

/* get_mowse_info */

	else if order = "get_mowse_info" then do;
	     if ^check_validity (p_info_ptr, mowse_io_info_version_1, p_code) then
		return;

	     p_info_ptr -> mowse_io_info.mcb_ptr = mio_data.mcb_ptr;
	     p_info_ptr -> mowse_io_info.info_ptr = mio_data.info_ptr;
	end;

/* get_terminal_emulator_state */

	else if order = "get_terminal_emulator_state" then
	     call get_emulator_state (p_info_ptr, p_code);

/* put_to_sleep */

	else if order = "put_to_sleep" then
	     call insert_sleeper (p_info_ptr, p_code);

/* send_local_message */

	else if order = "send_local_message" then do;
	     if ^check_validity (p_info_ptr, mowse_io_info_version_1, p_code) then
		return;

	     call ws_packet_transmitter_$local_data (mio_data_ptr,
		p_info_ptr -> mowse_io_message.channel,
		p_info_ptr -> mowse_io_message.io_message_ptr,
		p_info_ptr -> mowse_io_message.io_message_len,
		NO_MINOR);
	end;

/* send_message */

	else if order = "send_message" then do;
	     if ^check_validity (p_info_ptr, mowse_io_info_version_1, p_code) then
		return;

	     call ws_packet_transmitter_$data (mio_data_ptr,
		p_info_ptr -> mowse_io_message.channel,
		p_info_ptr -> mowse_io_message.io_message_ptr,
		p_info_ptr -> mowse_io_message.io_message_len,
		NO_MINOR);
	end;

/* set_video_mode */

	else if order = "set_video_mode" then do;
	     if ^check_validity (p_info_ptr, mowse_io_info_version_1, p_code) then
		return;

	     mio_data.ws.flags.video_mode
		= p_info_ptr -> mowse_io_set_video_mode_info.mode;
	     substr (unspec (mio_data.WSTERM_modes (WST_MODES)), 9, 1)
		= mio_data.ws.flags.video_mode;
	     call send_terminal_modes (byte (0) || byte (0) || byte (0), -1, -1);
	end;

/* store_mowse_info */

	else if order = "store_mowse_info" then do;
	     if ^check_validity (p_info_ptr, mowse_io_info_version_1, p_code) then
		return;

	     mio_data.info_ptr = p_info_ptr -> mowse_io_store_info.info_ptr;
	     mio_data.info_stored = True;
	     mio_data.mcb_ptr -> mcb.mowse_info_ptr = mio_data.info_ptr;
	end;

/* trace_off */

	else if order = "trace_off" then do;
	     call ws_debug_$trace_close (mio_data.trace_iocb_ptr, p_code);
	     mio_data.info_ptr -> mowse_info.mowse_flags.trace = False;
	     mio_data.info_ptr -> mowse_info.mowse_flags.trace_file_iocb
		= null;
	end;

/* trace_on */

	else if order = "trace_on" then do;
	     call ws_debug_$trace_open (p_info_ptr, mio_data.trace_iocb_ptr,
		p_code);
	     if p_code = 0 then do;
		mio_data.info_ptr -> mowse_info.mowse_flags.trace = True;
		mio_data.info_ptr -> mowse_info.mowse_flags.trace_file_iocb
		     = mio_data.trace_iocb_ptr;
	     end;
	end;

/* <<<<<<<<<<<< Multics Specific Control Orders >>>>>>>>>>>>> */

/* abort */

	else if order = "abort" then
	     mio_data.user_input.out = mio_data.user_input.in;

/* get_editing_chars */

	else if order = "get_editing_chars" then do;
	     if ^check_validity_int (p_info_ptr, editing_chars_version_3, p_code) then
		return;

	     p_info_ptr -> editing_chars.kill = mio_data.WSTERM_modes (WST_KILL);
	     p_info_ptr -> editing_chars.erase = mio_data.WSTERM_modes (WST_ERASE);
	end;

/* MF - phx21215 - get_event_channel */

	else if order = "get_event_channel" then do;
	     p_info_ptr -> fixedbin71al
		= mio_data.channel_info.foreground.channel;
	end;

/* io_call, io_call_af */

	else if order = "io_call" | order = "io_call_af" then
	     call mowse_io_call_control_ (p_iocb_ptr, p_order, p_info_ptr,
		p_code);

/* line_length */

	else if order = "line_length" then do;
	     ll = convert (ll, p_info_ptr -> ll_overlay);
	     call send_terminal_modes ("", -1, ll);
	end;

/* printer_off */

	else if order = "printer_off" then do;
	     printer_msg = "POF" || byte (0) || byte (0);
	     call ws_packet_transmitter_$data (mio_data_ptr, FG,
		addr (printer_msg), convert (fixedbin21, MinPktLen),
		FG_CONTROL_MESSAGE);
	end;

/* printer_on */

	else if order = "printer_on" then do;
	     printer_msg = "PON" || byte (0) || byte (0);
	     call ws_packet_transmitter_$data (mio_data_ptr, FG,
		addr (printer_msg), convert (fixedbin21, MinPktLen),
		FG_CONTROL_MESSAGE);
	end;

/* quit_disable */

	else if order = "quit_disable" then
	     mio_data.switches.quit_enable = False;

/* quit_enable */

	else if order = "quit_enable" then
	     mio_data.switches.quit_enable = True;

/* reconnection */

	else if order = "reconnection" then
	     call iox_$control (mio_data.iocb_ptr, p_order, p_info_ptr,
		p_code);

/* resetread */

	else if order = "resetread" then
	     mio_data.user_input.in = mio_data.user_input.out;

/* resetwrite */

	else if order = "resetwrite" then
	     mio_data.switches.reset_write = True;

/* read_status */

	else if order = "read_status" then do;
	     if p_info_ptr = null then do;
		p_code = error_table_$null_info_ptr;
		return;
	     end;
	     p_info_ptr -> tty_read_status_info.event_channel
		= mio_data.channel_info.foreground.channel; /* MF - phx21215 */
	     p_info_ptr -> tty_read_status_info.input_pending
		= (mio_data.user_input.out ^= mio_data.user_input.in);
	end;

/* set_default_modes */

	else if order = "set_default_modes" then
	     call send_terminal_modes ("@#\", WST_INIT_PL, WST_INIT_LL);

/* set_editing_chars */

	else if order = "set_editing_chars" then do;
	     if ^check_validity_int (p_info_ptr, 1, p_code) then
		return;

	     call send_terminal_modes (
		p_info_ptr -> editing_chars.kill
		|| p_info_ptr -> editing_chars.erase
		|| byte (0),
		-1, -1);
	end;

/* set_input_conversion */

	else if order = "set_input_conversion" then do;
	     if ^check_validity_int (p_info_ptr, 1, p_code) then
		return;

	     trans.version = 1;
	     call iox_$control (mio_data.iocb_ptr, "get_input_conversion",
		addr (trans), p_code);
	     if p_code ^= 0 then
		return;
	     call send_terminal_modes (
		byte (0) || byte (0) || get_escape_char (addr (trans)),
		-1, -1);
	end;

/* set_term_type */

	else if order = "set_term_type" then
	     call set_terminal (p_info_ptr, p_code);

/* start */

	else if order = "start" then do;
	     mio_data.switches.start_issued = True;
	     call ws_channel_$wait_wakeup (mio_data_ptr,
		addr (mio_data.channel_info.user_input));
	     call iox_$control (mio_data.iocb_ptr, p_order, p_info_ptr,
		p_code);
	end;

/* write_status */

	else if order = "write_status" then do;
	     if p_info_ptr = null then do;
		p_code = error_table_$null_info_ptr;
		return;
	     end;
	     p_info_ptr -> tty_read_status_info.event_channel
		= mio_data.channel_info.foreground.channel; /* MF - phx21215 */
	     p_info_ptr -> tty_read_status_info.input_pending
		= (mio_data.user_input.out ^= mio_data.user_input.in);
	end;

/* Bad order? YES - reject it;  NO - pass to tty_ */

	else do;
	     do i = 1 to N_BAD_CONTROL;
		if order = MOWSE_IO_BAD_CONTROL (i) then do;
		     p_code = error_table_$unsupported_operation;
		     return;
		end;
	     end;

	     call iox_$control (mio_data.iocb_ptr, p_order, p_info_ptr,
		p_code);
	     return;
	end;

	return;

/**/

/* *** Entry: mowse_io_detach - Internal entry for mowse_io_  *** */

mowse_io_detach_iocb:
     entry (p_iocb_ptr, p_code);


/* ENTRY FUNCTION

Detach the mowse i/o module.
*/

/* NOTES
*/

	call setup_entry ();
	mask = ""b;

/* Get rid of used space */

	call clean_up_mio_data ();

/* Adjust the iocb */

	on any_other begin;
	     fatal_error_info.version = 0;
	     fatal_error_info.status_code = error_table_$unable_to_do_io;
	     call terminate_process_ ("fatal_error", addr (fatal_error_info));
	end;

	call hcs_$set_ips_mask (""b, mask);
	iocb_ptr -> iocb.attach_descrip_ptr = null;
	call iox_$propagate (iocb_ptr);
	call hcs_$reset_ips_mask (mask, mask);

	revert any_other;
	return;

/**/

/* *** Entry: mowse_io_get_chars - Internal entry for mowse_io_  *** */

mowse_io_get_chars:
     entry (p_iocb_ptr, p_buf_ptr, p_buf_len, p_chars_read, p_code);


/* ENTRY FUNCTION

Retrieve "interactive" data from the terminal buffer.
*/

/* NOTES

This routine is the counterpart of the PC routine "gettdata" which retrieves
data which is destined to be displayed on the crt.  In this case (since there
is no crt associated at the Multics end, it is usually destined to be
processed by the Multics as "raw" character data.
*/

	p_chars_read = 0;
	call setup_entry ();

/* Buffer large enough ? */

	if p_buf_len < 1 then
	     return;
	if p_buf_ptr = null then
	     return;

/* Block while no data is ready on user_input */

	mio_data.switches.start_issued = False;
	do while (mio_data.user_input.in = mio_data.user_input.out
	     & ^mio_data.switches.start_issued);

	     call ws_channel_$wait_block (mio_data_ptr,
		addr (mio_data.channel_info.user_input),
		"user_input (get_chars)", mio_data.debug_iocb_ptr);
	end;

/* If a start was issued to break the loop, then we're done */

	if mio_data.switches.start_issued then do;
	     mio_data.switches.start_issued = False;
	     return;
	end;

/* Load the caller's buffer */

	do while (p_chars_read < p_buf_len
	     & mio_data.user_input.in ^= mio_data.user_input.out);

	     p_chars_read = p_chars_read + 1;

	     buf (p_chars_read)
		= mio_data.user_input.queue (mio_data.user_input.out);

	     mio_data.user_input.out
		= mod (mio_data.user_input.out + 1,
		hbound (mio_data.user_input.queue, 1) + 1);
	end;

	return;

/**/

/* *** Entry: mowse_io_get_line - Internal entry for mowse_io_  *** */

mowse_io_get_line:
     entry (p_iocb_ptr, p_buf_ptr, p_buf_len, p_chars_read, p_code);


/* ENTRY FUNCTION

Retrieve one line of "interactive" data from the terminal buffer.
*/

/* NOTES

This routine is the counterpart of the PC routine "gettdata" which retrieves
data which is destined to be displayed on the crt.  In this case (since there
is no crt associated at the Multics end), it is usually destined to be
processed by the Multics end as "raw" character data.
*/

	p_chars_read = 0;
	call setup_entry ();

/* Supplied buffer large enough */

	if p_buf_len < 1 then
	     return;
	if p_buf_ptr = null then
	     return;

/* While there is still room in the supplied buffer */

	do while (p_chars_read < p_buf_len);

/* - While the buffer is empty
     -- Block until something is read from tty_ */

	     mio_data.switches.start_issued = False;
	     do while (mio_data.user_input.out = mio_data.user_input.in
		& ^mio_data.switches.start_issued);

		call ws_channel_$wait_block (mio_data_ptr,
		     addr (mio_data.channel_info.user_input),
		     "user_input (get_line)", mio_data.debug_iocb_ptr);
	     end;

/* - If start caused the loop to break, quit here */

	     if mio_data.switches.start_issued then do;
		mio_data.switches.start_issued = False;
		return;
	     end;

/* - Copy the character into the supplied buffer */

	     p_chars_read = p_chars_read + 1;
	     buf (p_chars_read) =
		mio_data.user_input.queue (mio_data.user_input.out);
	     mio_data.user_input.out
		= mod (mio_data.user_input.out + 1,
		hbound (mio_data.user_input.queue, 1) + 1);

/* - <LF> found then return */

	     if buf (p_chars_read) = LF then do;
		return;
	     end;
	end;

/* Too much data for supplied buffer */

	p_code = error_table_$long_record;
	return;

/**/

/* *** Entry: mowse_io_modes - Internal entry for mowse_io_  *** */

mowse_io_modes:
     entry (p_iocb_ptr, p_newmodes, p_oldmodes, p_code);


/* ENTRY FUNCTION

Handle the following iox_$modes orders:

	pl = nn;
	ll = nn;
	crecho
	lfecho
	more	(ignored)
	more_mode (ignored)

Remaining control orders are NOT acceptable as MOWSE needs full control over
the communications line, thus only "terminal description" modes are
acceptable.
*/

/* NOTES
*/

	call setup_entry ();

/* Parse the new_modes string and update the MOWSE modes and send the modes
   message */

	call get_new_modes (p_newmodes, p_oldmodes, erkl_esc, pl, ll, p_code);
	if p_code ^= 0 then do;
	     p_oldmodes = "";
	     return;
	end;

/* wake_tbl can only be altered by mowse, if it is specified, then
   initialization / termination is occuring and it is NOT to be sent */

	if index (p_newmodes, "wake_tbl") = 0 then
	     call send_terminal_modes (erkl_esc, pl, ll);

	return;

/**/

/* *** Entry: mowse_io_open_file - Internal entry for mowse_io_  *** */

/* ENTRY FUNCTION

Open MOWSE io module.  Performs all of the necessary functions that open MOWSE
IO; starts up the "tasking" (scheduler); and sends a reset to the "other"
MOWSE (PC) to tell it that this one is up and running.
*/

/* NOTES
*/

mowse_io_open:
     entry (p_iocb_ptr, p_mode, p_unused, p_code);

	call setup_entry ();
	open_struc_ptr = null;
	goto JOIN_OPEN;

mowse_io_open_file:
     entry (p_iocb_ptr, p_mode, p_descrip, p_unused, p_code);

	call setup_entry ();
	open_struc_ptr = null;

	if length (p_descrip) <= 0 then
	     goto JOIN_OPEN;

	open_struc_ptr = addr (p_descrip);

JOIN_OPEN:

	mask = ""b;

/* Check the requested mode setting */

	if p_mode ^= Stream_input_output_mode then do;
	     p_code = error_table_$bad_mode;
	     return;
	end;

/* Initialize the mowse_io_ iocb */

	on any_other begin;
	     fatal_error_info.version = 0;
	     fatal_error_info.status_code = error_table_$unable_to_do_io;
	     call terminate_process_ ("fatal_error", addr (fatal_error_info));
	end;

/* Must be masked */

	call hcs_$set_ips_mask (""b, mask);

/* Establish sus_signal_handler replacement */

	call sct_manager_$get (susp_sct_index, mio_data.sus_data.sus_entry,
	     p_code);
	if p_code ^= 0 then do;
	     call hcs_$reset_ips_mask (mask, mask);
	     return;
	end;

	call sct_manager_$set (susp_sct_index,
	     codeptr (ws_packet_receiver_$sus_handler), p_code);
	if p_code ^= 0 then do;
	     call hcs_$reset_ips_mask (mask, mask);
	     return;
	end;

/* Set up the iocb */

	call initialize_iocb (iocb_ptr -> iocb.actual_iocb_ptr);
	iocb_ptr -> iocb.actual_iocb_ptr -> iocb.close
	     = mowse_io_close;
	iocb_ptr -> iocb.actual_iocb_ptr -> iocb.close_file
	     = mowse_io_close_file;
	iocb_ptr -> iocb.actual_iocb_ptr -> iocb.control
	     = mowse_io_control;
	iocb_ptr -> iocb.actual_iocb_ptr -> iocb.get_chars
	     = mowse_io_get_chars;
	iocb_ptr -> iocb.actual_iocb_ptr -> iocb.get_line
	     = mowse_io_get_line;
	iocb_ptr -> iocb.actual_iocb_ptr -> iocb.put_chars
	     = mowse_io_put_chars;
	iocb_ptr -> iocb.actual_iocb_ptr -> iocb.modes
	     = mowse_io_modes;
	iocb_ptr -> iocb.open_descrip_ptr = addr (mio_data.open_descrip);
	mio_data.open_descrip = "stream_input_output";
	call iox_$propagate (iocb_ptr);
	call hcs_$reset_ips_mask (mask, mask);

	revert any_other;

/* Set the mcb.iocb_ptr to mowse_i/o */

	mio_data.mcb_ptr -> mcb.iocb_ptr = p_iocb_ptr;

/* Turn OFF quit processing */

	call iox_$control (mio_data.iocb_ptr, "quit_disable", null, (0));

/* Set the modes on the line */

	new_modes
	     = "force,^crecho,^lfecho,^echoplex,^tabecho,rawi,rawo";
	call iox_$modes (mio_data.iocb_ptr, rtrim (new_modes),
	     mio_data.old_modes, (0));

	mio_data.current_modes = mio_data.old_modes;
	call adjust_modes ("^echoplex,tabs,^tabecho,rawi,rawo");

/* Set up a foreground event channel */

	ipc_arg.version = ipc_create_arg_structure_v1;
	ipc_arg.channel_type = FAST_EVENT_CHANNEL_TYPE;
	ipc_arg.call_entry = mowse_io_dummy;
	ipc_arg.call_data_ptr = null;
	ipc_arg.call_priority = 0;
	call ipc_$create_event_channel (addr (ipc_arg),
	     mio_data.channel_info.foreground.channel, p_code); /* MF - phx21215 */
	if (p_code ^= 0) then
	     goto CREATE_CHANNEL_ERROR;

/* Initialize protocol */

	call ws_timer_$initialize (mio_data_ptr);
	call ws_tools_$reset_data (mio_data_ptr);

	call ws_packet_transmitter_$initialize (mio_data_ptr, open_struc_ptr,
	     p_code);
	if p_code ^= 0 then
	     goto OPEN_TRANSMITTER_ERROR;

	call ws_packet_dispatcher_$initialize (mio_data_ptr, p_code);
	if p_code ^= 0 then
	     goto OPEN_DISPATCHER_ERROR;

	call ws_packet_receiver_$initialize (mio_data_ptr, open_struc_ptr,
	     p_code);
	if p_code ^= 0 then
	     goto OPEN_RECEIVER_ERROR;

	call connect (p_code);
	if p_code ^= 0 then
	     goto OPEN_CONNECT_ERROR;

	return;

OPEN_CONNECT_ERROR:
	call ws_packet_receiver_$terminate ((0));
OPEN_RECEIVER_ERROR:
	call ws_packet_dispatcher_$terminate ();
OPEN_DISPATCHER_ERROR:
	call ws_packet_transmitter_$terminate (mio_data_ptr);
OPEN_TRANSMITTER_ERROR:
	call ws_timer_$terminate ();
CREATE_CHANNEL_ERROR:
	call ipc_$delete_ev_chn (
	     mio_data.channel_info.foreground.channel, (0)); /* MF - phx21215 */

/* Put the IOCB back into a closed state */

	call hcs_$set_ips_mask (""b, mask);

	call initialize_iocb (iocb_ptr -> iocb.actual_iocb_ptr);
	iocb_ptr -> iocb.actual_iocb_ptr -> iocb.open_descrip_ptr
	     = null;
	iocb_ptr -> iocb.actual_iocb_ptr -> iocb.detach_iocb
	     = mowse_io_detach_iocb;
	iocb_ptr -> iocb.actual_iocb_ptr -> iocb.open
	     = mowse_io_open;
	iocb_ptr -> iocb.actual_iocb_ptr -> iocb.open_file
	     = mowse_io_open_file;
	iocb_ptr -> iocb.actual_iocb_ptr -> iocb.close_file
	     = iox_$err_not_open;
	iocb_ptr -> iocb.actual_iocb_ptr -> iocb.close
	     = iox_$err_not_open;
	call iox_$propagate (iocb_ptr);

	call iox_$modes (mio_data.iocb_ptr, mio_data.old_modes, "", (0));

	call hcs_$reset_ips_mask (mask, mask);

	return;

/**/

/* *** Entry: mowse_io_put_chars - Internal entry for mowse_io_  *** */

mowse_io_put_chars:
     entry (p_iocb_ptr, p_buf_ptr, p_buf_len, p_code);


/* ENTRY FUNCTION

Handle transmission of foreground terminal data to the remote (PC).
*/

/* NOTES
*/

	call setup_entry ();

	call ws_packet_transmitter_$data (mio_data_ptr, FG, p_buf_ptr,
	     p_buf_len, FG_TERMINAL_DATA);
	return;

/**/

/* *** Entry: mowse_io_tty_control   - Internal entry for mowse_io_  *** */
/* *** Entry: mowse_io_tty_get_chars - Internal entry for mowse_io_  *** */
/* *** Entry: mowse_io_tty_get_line  - Internal entry for mowse_io_  *** */
/* *** Entry: mowse_io_tty_put_chars - Internal entry for mowse_io_  *** */
/* *** Entry: mowse_io_tty_modes     - Internal entry for mowse_io_  *** */
/* *** Entry: mowse_io_dummy	       - Internal entry for mowse_io_  *** */

/* ENTRY FUNCTION

These entries are designed to merely pass on control to tty_ while mowse_i/o
is attached but not open.  Except for the dummy entry, it is used on the
foreground event wait channel and shold never be called.
*/

mowse_io_tty_control:
     entry (p_iocb_ptr, p_order, p_info_ptr, p_code);
	call setup_entry ();
	call iox_$control (mio_data.iocb_ptr, p_order, p_info_ptr,
	     p_code);
	return;

mowse_io_tty_get_chars:
     entry (p_iocb_ptr, p_buf_ptr, p_buf_len, p_chars_read, p_code);
	call setup_entry ();
	call iox_$get_chars (mio_data.iocb_ptr, p_buf_ptr, p_buf_len,
	     p_chars_read, p_code);
	return;

mowse_io_tty_get_line:
     entry (p_iocb_ptr, p_buf_ptr, p_buf_len, p_chars_read, p_code);
	call setup_entry ();
	call iox_$get_line (mio_data.iocb_ptr, p_buf_ptr, p_buf_len,
	     p_chars_read, p_code);
	return;

mowse_io_tty_put_chars:
     entry (p_iocb_ptr, p_buf_ptr, p_buf_len, p_code);
	call setup_entry ();
	call iox_$put_chars (mio_data.iocb_ptr, p_buf_ptr, p_buf_len,
	     p_code);
	return;

mowse_io_tty_modes:
     entry (p_iocb_ptr, p_newmodes, p_oldmodes, p_code);
	call setup_entry ();
	call iox_$modes (mio_data.iocb_ptr, p_newmodes, p_oldmodes,
	     p_code);
	return;

mowse_io_dummy:
     entry ();
	return;

/**/

%page;

/* INTERNAL PROCEDURES */


/* *** Procedure: adjust_modes - Internal proc for mowse_io_  *** */

adjust_modes:
     proc (p_newmodes);


/* PROCEDURE FUNCTION

Adjust the current mode settings maintained by mowse_io_ to the new modes
supplied.
*/

/* NOTES
*/

/* INPUT PARAMETERS */
dcl p_newmodes	       char (*) parameter;	    /* New modes settings */

/* MISC VARIABLES */
dcl new_mode	       char (32) var;	    /* New mode value */
dcl j		       fixed bin;
dcl found		       bit (1);
dcl i		       fixed bin;
dcl newmodes_ptr	       ptr;		    /* Mode value info ptr fot new modes */
dcl oldmodes_ptr	       ptr;		    /* Mode value info ptr for old modes */
dcl recover_modes	       char (256);		    /* In case of cleanup these are old values */

/* INITIALIZATION */
	recover_modes = mio_data.current_modes;
	oldmodes_ptr = null;
	newmodes_ptr = null;
	on cleanup begin;
	     call cleanup_modes_info (oldmodes_ptr);
	     call cleanup_modes_info (newmodes_ptr);
	     mio_data.current_modes = recover_modes;
	end;

/* MAIN */

/* Form two mode_string_info structures and then recombine them to one
   to form the resultant modes character string in mio_data.current_modes */

	call mode_string_$parse (mio_data.current_modes, null, oldmodes_ptr,
	     (0));
	call mode_string_$parse (p_newmodes, null, newmodes_ptr, (0));

/* For each of the modes in the old string, look in the new string to see if
   it exists, put the new value into the current modes (if it exists else put
   the old one back) */

	mio_data.current_modes = "";
	do i = 1 to oldmodes_ptr -> mode_string_info.number;
	     found = "0"b;
	     do j = 1 to newmodes_ptr -> mode_string_info.number;
		if oldmodes_ptr -> mode_string_info.modes (i).mode_name
		     = newmodes_ptr -> mode_string_info.modes (j).mode_name
		then do;
		     found = "1"b;
		     newmodes_ptr -> mode_string_info.modes (j).code = 1;
		     call parse_modes (
			addr (newmodes_ptr -> mode_string_info.modes (j)),
			("0"b), (0), new_mode);
		end;
	     end;

/* If the newmode changes an old mode, then insert it
   Else put the old mode in the string */

	     if found then
		mio_data.current_modes
		     = rtrim (mio_data.current_modes) || "," || new_mode;
	     else do;
		call parse_modes (
		     addr (oldmodes_ptr -> mode_string_info.modes (i)),
		     ("0"b), (0), new_mode);
		mio_data.current_modes
		     = rtrim (mio_data.current_modes) || "," || new_mode;
	     end;
	end;

/* For each of the modes in the new string that were not seen, append */

	do i = 1 to newmodes_ptr -> mode_string_info.number;
	     if newmodes_ptr -> mode_string_info.modes (i).code ^= 1 then do;
		call parse_modes (
		     addr (newmodes_ptr -> mode_string_info.modes (i)),
		     ("0"b), (0), new_mode);
		mio_data.current_modes
		     = rtrim (mio_data.current_modes) || "," || new_mode;
	     end;
	end;

/* Strip off the leading "," that was placed in */

	mio_data.current_modes = substr (rtrim (mio_data.current_modes), 2);

/* Release the space occupied back to the system */

	call cleanup_modes_info (oldmodes_ptr);
	call cleanup_modes_info (newmodes_ptr);

     end adjust_modes;

/**/

/* *** Procedure: check_validity - Internal proc for mowse_io_  *** */

check_validity:
     proc (p_info_ptr, p_version, p_code) returns (bit (1));


/* PROCEDURE FUNCTION


*/

/* NOTES
*/

/* INPUT PARAMETERS */
dcl p_info_ptr	       ptr parameter;	    /* Info structure */
dcl p_version	       char (8) parameter;	    /* Version number in characters */

/* OUTPUT PARAMETERS */
dcl p_code	       fixed bin (35) parameter;

/* MISC VARIABLES */

/* STRUCTURES */
dcl 01 struc	       based (p_info_ptr),
       02 version	       char (8);

/* INITIALIZATION */
	p_code = 0;

/* MAIN */
	if p_info_ptr = null then do;
	     p_code = error_table_$null_info_ptr;
	     return (False);
	end;

	if p_info_ptr -> struc.version ^= p_version then do;
	     p_code = error_table_$unimplemented_version;
	     return (False);
	end;

	return (True);

     end check_validity;

/**/

/* *** Procedure: check_validity_int - Internal proc for mowse_io_  *** */

check_validity_int:
     proc (p_info_ptr, p_version, p_code) returns (bit (1));


/* PROCEDURE FUNCTION

Check the validity of an integer version field as well as test for null info.
*/

/* NOTES

Version number of the structure must be in the first field and fixed bin (17).
*/

/* INPUT PARAMETERS */
dcl p_info_ptr	       ptr parameter;	    /* Info structure */
dcl p_version	       fixed bin parameter;	    /* Structure version field */

/* OUTPUT PARAMETERS */
dcl p_code	       fixed bin (35) parameter;

/* MISC VARIABLES */

/* STRUCTURES */
dcl 01 structure	       based (p_info_ptr),
       02 version	       fixed bin;

/* INITIALIZATION */
	p_code = 0;

/* MAIN */
	if p_info_ptr = null then do;
	     p_code = error_table_$null_info_ptr;
	     return (False);
	end;

	if p_info_ptr -> structure.version ^= p_version then do;
	     p_code = error_table_$unimplemented_version;
	     return (False);
	end;

	return (True);

     end check_validity_int;

/**/

/* *** Procedure: clean_up_cv_trans - Internal proc for mowse_io_  *** */

clean_up_cv_trans:
     proc (p_cv_trans_ptr);


/* PROCEDURE FUNCTION

Free the cv_trans_struc associated with the pointer provided.
*/

/* NOTES
*/

/* INPUT PARAMETERS */
dcl p_cv_trans_ptr	       ptr parameter;

/* OUTPUT PARAMETERS */

/* MISC VARIABLES */

/* STRUCTURES */

/* INITIALIZATION */

/* MAIN */

	if p_cv_trans_ptr ^= null then do;
	     free p_cv_trans_ptr -> cv_trans_struc;
	     p_cv_trans_ptr = null;
	end;

     end clean_up_cv_trans;

/**/

/* *** Procedure: clean_up_mio_data - Internal proc for mowse_io_  *** */

clean_up_mio_data:
     proc ();


/* PROCEDURE FUNCTION

Free allocated attach data space back to the system, including possible
existence of the mcb.
*/

/* NOTES
*/

/* MISC VARIABLES */
dcl temp_ptr	       ptr;
dcl data		       char (data_len) based (data_ptr);
dcl data_len	       fixed bin (21);
dcl data_ptr	       ptr;
dcl node_ptr	       ptr;
dcl i		       fixed bin;

/* MAIN */

/* If mio_data is not null */

	if mio_data_ptr ^= null then do;
	     if mio_data.channel_info.user_input.channel ^= 0 then
		call ipc_$delete_ev_chn (
		     mio_data.channel_info.user_input.channel, (0));

	     if mio_data.mcb_ptr ^= null then do;
		free mio_data.mcb_ptr -> mcb;
		mio_data.mcb_ptr = null;
	     end;

	     call clean_up_cv_trans (mio_data.cv_trans_struc_ptr);

	     do i = 0 to ChnCnt - 1;
		node_ptr = mio_data.l_dat (i).out_ptr;
		do while (node_ptr ^= null);
		     data_ptr = node_ptr -> local_data_node.data_ptr;
		     data_len = node_ptr -> local_data_node.data_len;
		     free data_ptr -> data;
		     temp_ptr = node_ptr;
		     node_ptr = node_ptr -> local_data_node.next;
		     free temp_ptr -> local_data_node;
		end;
	     end;

	     free mio_data_ptr -> mowse_io_data;
	     mio_data_ptr = null;
	end;

     end clean_up_mio_data;

/**/

/* *** Procedure: cleanup_modes_info - Internal proc for mowse_io_  *** */

cleanup_modes_info:
     proc (p_info_ptr);


/* PROCEDURE FUNCTION

Release the modes info structure back to the system_free if it exists.
*/

/* NOTES
*/

/* INPUT PARAMETERS */
dcl p_info_ptr	       ptr parameter;

/* MAIN */

	if p_info_ptr ^= null then
	     free p_info_ptr -> mode_string_info;

     end cleanup_modes_info;

/**/

/* *** Procedure: connect - Internal proc for mowse_io_  *** */

connect:
     proc (p_code);


/* PROCEDURE FUNCTION

Perform the necessary functions to establish connection with the remote.
*/

/* NOTES
*/

/* INPUT PARAMETERS */

/* OUTPUT PARAMETERS */
dcl p_code	       fixed bin (35) parameter;

/* MISC VARIABLES */

/* STRUCTURES */

/* INITIALIZATION */
	p_code = 0;

/* MAIN */

	mio_data.switches.connect_active = True;
	call ws_timer_$reset_connect ();
	call ws_packet_transmitter_$reset (mio_data_ptr);

	do while (mio_data.switches.rs_pending (1) & mio_data.switches.connect_active);
	     call ws_channel_$wait_block (mio_data_ptr,
		addr (mio_data.channel_info.user_input),
		"user_input (connect)", mio_data.debug_iocb_ptr);
	end;

	if ^mio_data.switches.connect_active then do;
	     p_code = ws_error_$unsupported_ws_terminal;
	     return;
	end;

	call ws_channel_$wait_wakeup (mio_data_ptr,
	     addr (mio_data.channel_info.user_input));

     end connect;

/**/

/* *** Procedure: disconnect - Internal proc for mowse_io_  *** */

disconnect:
     proc (p_confirmed);


/* PROCEDURE FUNCTION

Perform the necessary functions to establish a disconnection from the PC
MOWSE in the following manner:

	send disconnect message;
	(accept only disconnect confirmation messages)
	block until disconnect confirmation received;
	send confirmation to disconnect message confirmation;
	return to caller;
*/

/* NOTES
*/

/* INPUT PARAMETERS */
dcl p_confirmed	       bit (1) parameter;	    /* Fast or confirmed disconnect */

/* OUTPUT PARAMETERS */

/* MISC VARIABLES */

/* STRUCTURES */

/* INITIALIZATION */

/* MAIN */

/* If interactive_initiated_disconnect is False, then process no further */

	if ^p_confirmed then do;
	     call ws_packet_transmitter_$supervisory (mio_data_ptr,
		byte (FastDis));
	     return;
	end;

/* Send the disconnect request message */

	call ws_timer_$reset_disconnect ();
	call ws_packet_transmitter_$supervisory (mio_data_ptr,
	     byte (DisCon + Request));

/* Block until disconnect confirmation received */

	mio_data.ds_pending (1) = True;
	do while (mio_data.ds_pending (1));
	     call ws_channel_$wait_block (mio_data_ptr,
		addr (mio_data.channel_info.user_input),
		"user_input (disconnect)", mio_data.debug_iocb_ptr);
	end;
	call ws_channel_$wait_wakeup (mio_data_ptr,
	     addr (mio_data.channel_info.user_input));

/* Send the disconnect confirm confirmation */

	call ws_packet_transmitter_$supervisory (mio_data_ptr,
	     byte (DisCon + Confirm));

	call ws_tools_$reset_data (mio_data_ptr);

     end disconnect;

/**/

/* *** Procedure: flush_subchannel - Internal proc for mowse_io_  *** */

flush_subchannel:
     proc (p_info_ptr, p_code);


/* PROCEDURE FUNCTION

Wait until the specified subchannel has been cleared of all pending packets.
*/

/* NOTES
*/

/* INPUT PARAMETERS */
dcl p_info_ptr	       ptr parameter;	    /* Flush info */

/* OUTPUT PARAMETERS */
dcl p_code	       fixed bin (35) parameter;

/* MISC VARIABLES */
dcl channel	       fixed bin;		    /* Channel ID */

/* STRUCTURES */

/* INITIALIZATION */
	p_code = 0;

/* MAIN */
	if ^check_validity (p_info_ptr, mowse_io_info_version_1, p_code) then
	     return;

	channel = p_info_ptr -> mowse_io_flush_subchannel_info.subchannel;
	do while (mio_data.s.psn (channel) ^= mio_data.r.asn (channel));
	     call ws_channel_$wait_block (mio_data_ptr,
		addr (mio_data.channel_info.user_input),
		"flush_subchannel", mio_data.debug_iocb_ptr);
	end;
	call ws_channel_$wait_wakeup (mio_data_ptr,
	     addr (mio_data.channel_info.user_input));

     end flush_subchannel;

/**/

/* *** Procedure: get_emulator_state - Internal proc for mowse_io_  *** */

get_emulator_state:
     proc (p_info_ptr, p_code);


/* PROCEDURE FUNCTION

Determine whether or not WSTERM is attached, if so return True in the info.
*/

/* NOTES
*/

/* INPUT PARAMETERS */
dcl p_info_ptr	       ptr parameter;	    /* Info structure */

/* OUTPUT PARAMETERS */
dcl p_code	       fixed bin (35) parameter;

/* MISC VARIABLES */
dcl code		       fixed bin (35);
dcl cap_num	       fixed bin;		    /* Capability number of WSTERM */

/* STRUCTURES */

/* INITIALIZATION */
	cap_num = 0;
	p_code = 0;

/* MAIN */
	if ^check_validity (p_info_ptr, mowse_io_info_version_1, p_code) then
	     return;

/* Look for WSTERM on the remote system */

	cap_num = 0;
	call ws_$find_capability_number ("WSTERM", REMOTE_SYSTEM,
	     cap_num, code);

/* Code = 0, there; code = ^0, not there */

	if code ^= 0 then
	     p_info_ptr -> mowse_io_terminal_state.state = False;
	else
	     p_info_ptr -> mowse_io_terminal_state.state = True;

	if code = ws_error_$inconsistent_mowse_tables then
	     p_code = code;

     end get_emulator_state;

/**/

/* *** Procedure: get_escape_char - Internal proc for mowse_io_  *** */

get_escape_char:
     proc (p_cv_trans_ptr) returns (char (1));


/* PROCEDURE FUNCTION

Extracts the escape character from the conversion table.
*/

/* NOTES
*/

/* INPUT PARAMETERS */
dcl p_cv_trans_ptr	       ptr parameter;	    /* Pointer to conversion table */

/* MISC VARIABLES */
dcl i		       fixed bin;

/* INITIALIZATION */

/* MAIN */

/* Get a copy of the new translation */

	mio_data.cv_trans_struc_ptr -> cv_trans_struc =
	     p_cv_trans_ptr -> cv_trans_struc;

/* If there exists a "\" then return it */

	if p_cv_trans_ptr -> cv_trans_struc.cv_trans.value (rank ("\"))
	     = INPUT_CONVERT_ESCAPE
	     then
	     return ("\");

	else do;
	     i = 0;
	     do while (i < 256);		    /* There are 256 elements */
		if p_cv_trans_ptr -> cv_trans_struc.value (i)
		     = INPUT_CONVERT_ESCAPE
		     then
		     return (byte (i));
		else
		     i = i + 1;
	     end;
	     return ("\");
	end;

     end get_escape_char;

/**/

/* *** Procedure: get_new_modes - Internal proc for mowse_io_  *** */

get_new_modes:
     proc (p_newmodes, p_oldmodes, p_erkl_esc, p_pl, p_ll, p_code);


/* PROCEDURE FUNCTION

Parse the p_newmodes string and extract the necessary information, setting
p_oldmodes to the new modes setting, p_erkl_esc, p_pl, and p_ll to their new
values unless they haven't been changed.
*/

/* NOTES
*/

/* INPUT PARAMETERS */
dcl p_newmodes	       char (*) parameter;	    /* New modes string */

/* OUTPUT PARAMETERS */
dcl p_ll		       fixed bin parameter;	    /* Line length */
dcl p_code	       fixed bin (35) parameter;
dcl p_oldmodes	       char (*) parameter;	    /* Modes string */
dcl p_erkl_esc	       char (3) parameter;	    /* Erase, Kill, Escape */
dcl p_pl		       fixed bin parameter;	    /* Page length */

/* MISC VARIABLES */
dcl boolean_val	       bit (1);		    /* Boolean mode value */
dcl temp_chmod	       char (32) var;	    /* Single mode value string */
dcl i		       fixed bin;
dcl force_flag	       bit (1);		    /* Force reqyested */
dcl chmod		       char (512) var;	    /* New modes to be changed */
dcl r_len		       fixed bin (21);	    /* Return string length */
dcl code		       fixed bin (35);

/* INITIALIZATION */
	boolean_val = ""b;
	temp_chmod = "";
	force_flag = ""b;
	chmod = "";
	code = 0;
	r_len = 0;
	p_erkl_esc = byte (0) || byte (0) || byte (0);
	p_pl = -1;
	p_ll = -1;
	p_code = 0;

/* MAIN */

/* Set the oldmodes value to current settings */

	if length (p_oldmodes) > 0 then
	     p_oldmodes = mio_data.current_modes;

/* If there are no newmodes (0 length) then return */

	if length (p_newmodes) <= 0 then
	     return;

/* Parse the new modes string */

	mode_string_info_ptr = null;
	on cleanup call cleanup_modes_info (mode_string_info_ptr);
	call mode_string_$parse (p_newmodes, null, mode_string_info_ptr,
	     p_code);
	if p_code ^= 0 then do;
	     call cleanup_modes_info (mode_string_info_ptr);
	     return;
	end;

/* Check and interpret each */

	do i = 1 to mode_string_info.number;
	     if mode_string_info.modes (i).mode_name = "force" then
		force_flag = True;

	     else if mode_string_info.modes (i).mode_name = "pl" then do;
		call parse_modes (addr (mode_string_info.modes (i)),
		     ("0"b), p_pl, temp_chmod);
		chmod = chmod || ",";
		chmod = chmod || temp_chmod;
	     end;

	     else if mode_string_info.modes (i).mode_name = "ll" then do;
		call parse_modes (addr (mode_string_info.modes (i)),
		     ("0"b), p_ll, temp_chmod);
		chmod = chmod || ",";
		chmod = chmod || temp_chmod;
	     end;

	     else if mode_string_info.modes (i).mode_name = "wake_tbl"
	     then do;
		call parse_modes (addr (mode_string_info.modes (i)),
		     ("0"b), (0), temp_chmod);
		chmod = chmod || ",";
		chmod = chmod || temp_chmod;
	     end;

	     else if mode_string_info.modes (i).mode_name = "more"
		| mode_string_info.modes (i).mode_name = "more_mode"
		then
		;			    /* IGNORE */

	     else if mode_string_info.modes (i).mode_name = "crecho" then do;
		call parse_modes (addr (mode_string_info.modes (i)),
		     boolean_val, (0), temp_chmod);

		substr (unspec (mio_data.WSTERM_modes (WST_MODES)), 8, 1)
		     = boolean_val;
		chmod = chmod || ",";
		chmod = chmod || temp_chmod;
	     end;

	     else if mode_string_info.modes (i).mode_name = "lfecho" then do;
		call parse_modes (
		     addr (mode_string_info.modes (i)), boolean_val,
		     (0), temp_chmod);

		substr (unspec (mio_data.WSTERM_modes (WST_MODES)), 7, 1)
		     = boolean_val;
		chmod = chmod || ",";
		chmod = chmod || temp_chmod;
	     end;

	     else if ^force_flag then do;
		call cleanup_modes_info (mode_string_info_ptr);
		p_code = error_table_$bad_mode;
		return;
	     end;
	end;

/* Save the new settings in the current modes */

	if length (chmod) ^= 0 then
	     call adjust_modes (substr (chmod, 2, length (chmod) - 1));

/* Release the space to system */

	call cleanup_modes_info (mode_string_info_ptr);

     end get_new_modes;

/**/

/* *** Procedure: initialize_attach_data - Internal proc for mowse_io_  *** */

initialize_attach_data:
     proc (p_code);


/* PROCEDURE FUNCTION

Initialize the mowse_io_ data.
*/

/* NOTES
*/

/* INPUT PARAMETERS */

/* OUTPUT PARAMETERS */
dcl p_code	       fixed bin (35) parameter;

/* MISC VARIABLES */
dcl system_free_area_ptr   ptr;
dcl system_free_area       area based (system_free_area_ptr);
dcl code		       fixed bin (35);

/* STRUCTURES */
dcl 01 mode_val	       like mode_value automatic;
dcl 01 trans	       like cv_trans_struc automatic;
dcl 01 ed_chars	       like editing_chars automatic;

/* INITIALIZATION */
	system_free_area_ptr = get_system_free_area_ ();
	p_code = 0;

/* MAIN */

/* Modes */

	call iox_$modes (mio_data.iocb_ptr, "", mio_data.old_modes, p_code);
	if p_code ^= 0 then
	     return;
	mio_data.current_modes = mio_data.old_modes;

/* Channel info */

	mio_data.channel_info.process_id = get_process_id_ ();
	mio_data.channel_info.packet_receiver.channel = 0;

	mio_data.channel_info.user_input.count = 0;
	mio_data.channel_info.user_input.flags.transmitted = False;
	call ipc_$create_ev_chn (mio_data.channel_info.user_input.channel,
	     p_code);
	if p_code ^= 0 then
	     return;

/* Get the current conversion table */

	mio_data.cv_trans_struc_ptr = null;
	on cleanup call clean_up_cv_trans (mio_data.cv_trans_struc_ptr);
	allocate cv_trans_struc in (system_free_area)
	     set (mio_data.cv_trans_struc_ptr);
	mio_data.cv_trans_struc_ptr -> cv_trans_struc.version = 1;
	call iox_$control (mio_data.iocb_ptr, "get_input_conversion",
	     mio_data.cv_trans_struc_ptr, code);
	if code ^= 0 then
	     mio_data.cv_trans_struc_ptr -> cv_trans_struc.default = 1;

/* WSTERM modes header */

	mio_data.WSTERM_modes (WST_HEADER_1) = "S";
	mio_data.WSTERM_modes (WST_HEADER_2) = "T";
	mio_data.WSTERM_modes (WST_HEADER_3) = "M";
	mio_data.WSTERM_modes (WST_LENGTH_HIGH) = byte (0);
	mio_data.WSTERM_modes (WST_LENGTH_LOW) = byte (6);

/* WSTERM modes modes (00000xy0 forced) lfecho,crecho,video_mode */

	mio_data.WSTERM_modes (WST_MODES) = byte (0);
	mode_val.version = mode_value_version_3;
	call mode_string_$get_mode (mio_data.old_modes, "crecho",
	     addr (mode_val), (0));
	substr (unspec (mio_data.WSTERM_modes (WST_MODES)), 8, 1)
	     = mode_val.flags.boolean_value;
	call mode_string_$get_mode (mio_data.old_modes, "lfecho",
	     addr (mode_val), (0));
	substr (unspec (mio_data.WSTERM_modes (WST_MODES)), 7, 1)
	     = mode_val.flags.boolean_value;

/* WSTERM modes Kill / Erase chars */

	ed_chars.version = editing_chars_version_3;
	call iox_$control (mio_data.iocb_ptr, "get_editing_chars",
	     addr (ed_chars), code);
	if code ^= 0 then do;
	     mio_data.WSTERM_modes (WST_KILL) = "@";
	     mio_data.WSTERM_modes (WST_ERASE) = "#";
	end;
	else do;
	     mio_data.WSTERM_modes (WST_KILL) = ed_chars.kill;
	     mio_data.WSTERM_modes (WST_ERASE) = ed_chars.erase;
	end;

/* WSTERM modes Escape character */

	trans.version = 1;
	call iox_$control (mio_data.iocb_ptr, "get_input_conversion",
	     addr (trans), code);
	if code ^= 0 then
	     mio_data.WSTERM_modes (WST_ESCAPE) = "\";
	else
	     mio_data.WSTERM_modes (WST_ESCAPE) = get_escape_char (addr (trans));

/* WSTERM modes PL and LL */

	mode_val.version = mode_value_version_3;
	call mode_string_$get_mode (mio_data.old_modes, "pl",
	     addr (mode_val), code);
	if code ^= 0 then
	     mio_data.WSTERM_modes (WST_PAGE_LENGTH) = byte (24);
	else
	     mio_data.WSTERM_modes (WST_PAGE_LENGTH) = byte (mode_val.numeric_value);

	call mode_string_$get_mode (mio_data.old_modes, "ll",
	     addr (mode_val), code);
	if code ^= 0 then
	     mio_data.WSTERM_modes (WST_LINE_LENGTH) = byte (79);
	else
	     mio_data.WSTERM_modes (WST_LINE_LENGTH) = byte (mode_val.numeric_value);

/* Application control info segment */

	mio_data.switches.info_stored = False;
	mio_data.info_ptr = null;
	mio_data.sleepers = null;
	mio_data.dozers = 0;

/* Get an MCB */

	allocate mcb in (system_free_area) set (mio_data.mcb_ptr);
	mio_data.mcb_ptr -> mcb.version = MOWSE_VERSION_;
	mio_data.mcb_ptr -> mcb.capability_name = "internal_mowse_";
	call capability_$pack (LOCAL_SYSTEM, INTERNAL,
	     mio_data.mcb_ptr -> mcb.major_capability, (0));
	mio_data.mcb_ptr -> mcb.inbuff_length = 0;
	mio_data.mcb_ptr -> mcb.inbuff_position_index = 0;
	mio_data.mcb_ptr -> mcb.inbuff_data_length = 0;
	mio_data.mcb_ptr -> mcb.outbuff_length = 0;
	mio_data.mcb_ptr -> mcb.mbz1 = ""b;
	mio_data.mcb_ptr -> mcb.entry_var = bound_process_env_$err_no_operation;
	mio_data.mcb_ptr -> mcb.data_block_ptr = null;
	mio_data.mcb_ptr -> inbuff = null;
	mio_data.mcb_ptr -> mcb.outbuff_list_start = null;
	mio_data.mcb_ptr -> mcb.outbuff_list_end = null;
	mio_data.mcb_ptr -> mcb.iocb_ptr = null;
	mio_data.mcb_ptr -> mcb.mowse_info_ptr = mio_data.info_ptr;

/* Video system (ws_tty) information */

	mio_data.ws.flags.trace = False;
	mio_data.ws.flags.debug = False;
	mio_data.ws.flags.mark_set = False;
	mio_data.ws.flags.video_mode = False;
	mio_data.ws.flags.more_input = False;
	mio_data.ws.flags.pad = ""b;
	mio_data.ws.ips_mask = ""b;

/* Local message data */

	mio_data.l_dat (*).in_ptr = null;
	mio_data.l_dat (*).out_ptr = null;

/* sus_ handler information */

	mio_data.sus_data.activated = False;
	mio_data.sus_data.pad = ""b;
	mio_data.sus_data.sus_entry = null;

/* Buffer space */

	mio_data.user_input.in = 0;
	mio_data.user_input.out = 0;

/* State control switches */

	mio_data.switches.quit_enable = True;
	mio_data.switches.reset_write = False;
	mio_data.switches.disconnect_active = False;
	mio_data.switches.rs_pending (*) = False;
	mio_data.switches.ds_pending (*) = False;
	mio_data.switches.brk_pending = False;
	mio_data.switches.br_pending = False;
	mio_data.switches.connect_active = False;
	mio_data.switches.start_issued = False;

/* Tasking data */

	mio_data.task.active (*) = False;

/* Debug information */

	mio_data.debug_iocb_ptr = null;
	mio_data.trace_iocb_ptr = null;

     end initialize_attach_data;

/**/

/* *** Procedure: initialize_iocb - Internal proc for mowse_io_  *** */

initialize_iocb:
     proc (p_iocb_ptr);


/* PROCEDURE FUNCTION

Initialize the fields of the IOCB.
*/

/* NOTES
*/

/* INPUT PARAMETERS */
dcl p_iocb_ptr	       ptr parameter;	    /* IOCB to be initialized */

/* MAIN */

	p_iocb_ptr -> iocb.detach_iocb = iox_$err_no_operation;
	p_iocb_ptr -> iocb.open = iox_$err_no_operation;
	p_iocb_ptr -> iocb.open_file = iox_$err_no_operation;
	p_iocb_ptr -> iocb.close = iox_$err_no_operation;
	p_iocb_ptr -> iocb.close_file = iox_$err_no_operation;
	p_iocb_ptr -> iocb.get_line = iox_$err_no_operation;
	p_iocb_ptr -> iocb.get_chars = iox_$err_no_operation;
	p_iocb_ptr -> iocb.put_chars = iox_$err_no_operation;
	p_iocb_ptr -> iocb.modes = iox_$err_no_operation;
	p_iocb_ptr -> iocb.position = iox_$err_no_operation;
	p_iocb_ptr -> iocb.control = iox_$err_no_operation;
	p_iocb_ptr -> iocb.read_record = iox_$err_no_operation;
	p_iocb_ptr -> iocb.write_record = iox_$err_no_operation;
	p_iocb_ptr -> iocb.rewrite_record = iox_$err_no_operation;
	p_iocb_ptr -> iocb.delete_record = iox_$err_no_operation;
	p_iocb_ptr -> iocb.seek_key = iox_$err_no_operation;
	p_iocb_ptr -> iocb.read_key = iox_$err_no_operation;
	p_iocb_ptr -> iocb.read_length = iox_$err_no_operation;
     end initialize_iocb;

/**/

/* *** Procedure: insert_sleeper - Internal proc for mowse_io_  *** */

insert_sleeper:
     proc (p_info_ptr, p_code);


/* PROCEDURE FUNCTION

Insert the application to be put to sleep in the sleeper queue positioned 
according to when it will wake up.
*/

/* NOTES
*/

/* INPUT PARAMETERS */
dcl p_info_ptr	       ptr parameter;	    /* Info structure */

/* OUTPUT PARAMETERS */
dcl p_code	       fixed bin (35) parameter;

/* MISC VARIABLES */
dcl fixed71	       fixed bin (71) based;
dcl current_time	       fixed bin (71);
dcl new_ptr	       ptr;		    /* New node */
dcl system_free_area       area based (system_free_area_ptr);
dcl system_free_area_ptr   ptr;
dcl look_ptr	       ptr;		    /* Sleep list search ptr */

/* STRUCTURES */
dcl 01 node	       like mowse_io_sleep_node based;

/* INITIALIZATION */
	p_code = 0;

/* MAIN */
	if ^check_validity (p_info_ptr, mowse_io_info_version_1, p_code) then
	     return;

/* Make sure it is not trying for <= 0 sleep time */

	if p_info_ptr -> mowse_io_sleep_info.sleep_seconds <= 0 then do;
	     p_code = ws_error_$invalid_sleep_interval;
	     return;
	end;

/* Make sure caller is not already sleeping */

	look_ptr = mio_data.sleepers;
	do while (look_ptr ^= null);
	     if look_ptr -> mowse_io_sleep_node.major
		= p_info_ptr -> mowse_io_sleep_info.major_index
	     then do;
		p_code = ws_error_$already_sleeping;
		return;
	     end;
	     look_ptr = look_ptr -> mowse_io_sleep_node.next;
	end;

/* Get a node and set the info fields */

	system_free_area_ptr = get_system_free_area_ ();
	allocate node in (system_free_area) set (new_ptr);

	new_ptr -> node.major =
	     p_info_ptr -> mowse_io_sleep_info.major_index;
	new_ptr -> node.last = null;
	new_ptr -> node.next = null;
	current_time = divide (clock_ (), 1000000, 0);
	new_ptr -> node.when =
	     convert (fixed71,
	     p_info_ptr -> mowse_io_sleep_info.sleep_seconds) + current_time;

/* Insert the node into the list
   - Null list */

	if mio_data.sleepers = null then do;
	     mio_data.sleepers = new_ptr;
	     call ws_timer_$queue_sleeper (new_ptr -> node.when);
	     return;
	end;

/* Insert somewhere else
   -- End of list */

	look_ptr = mio_data.sleepers;
	do while (new_ptr -> node.when >= look_ptr -> node.when);
	     if look_ptr -> node.next = null then do;
		new_ptr -> node.last = look_ptr;
		look_ptr -> node.next = new_ptr;
		call ws_timer_$queue_sleeper (new_ptr -> node.when);
		return;
	     end;
	     look_ptr = look_ptr -> node.next;
	end;

/* -- Front of list */

	if look_ptr -> node.last = null then do;
	     new_ptr -> node.next = mio_data.sleepers;
	     mio_data.sleepers = new_ptr;
	     look_ptr -> node.last = new_ptr;
	     call ws_timer_$queue_sleeper (new_ptr -> node.when);
	     return;
	end;

/* Between two nodes */

	else do;
	     new_ptr -> node.next = look_ptr;
	     new_ptr -> node.last = look_ptr -> node.last;
	     look_ptr -> node.last -> node.next = new_ptr;
	     look_ptr -> node.last = new_ptr;
	     call ws_timer_$queue_sleeper (new_ptr -> node.when);
	     return;
	end;

     end insert_sleeper;

/**/

/* *** Procedure: parse_modes - Internal proc for mowse_io_  *** */

parse_modes:
     proc (p_mode_info_ptr, p_boolean_value, p_numeric_value,
	p_char_value);


/* PROCEDURE FUNCTION

Look at the mode_value structure and return the appropriate data.
*/

/* NOTES
*/

/* INPUT PARAMETERS */
dcl p_mode_info_ptr	       ptr parameter;	    /* mode_value structure */

/* OUTPUT PARAMETERS */
dcl p_boolean_value	       bit (1) parameter;	    /* Boolean value of mode */
dcl p_numeric_value	       fixed bin parameter;	    /* Numeric value of mode */
dcl p_char_value	       char (*) var parameter;    /* Character value of mode */

/* MISC VARIABLES */

/* INITIALIZATION */
	p_boolean_value = "0"b;
	p_numeric_value = 0;
	p_char_value = rtrim (p_mode_info_ptr -> mode_value.mode_name);

/* MAIN */

	if p_mode_info_ptr -> mode_value.flags.boolean_valuep then do;
	     p_boolean_value
		= p_mode_info_ptr -> mode_value.flags.boolean_value;
	     if ^p_mode_info_ptr -> mode_value.flags.boolean_value then
		p_char_value = "^" || p_char_value;
	end;

	else if p_mode_info_ptr -> mode_value.flags.numeric_valuep then do;
	     p_numeric_value
		= p_mode_info_ptr -> mode_value.numeric_value;
	     p_char_value
		= p_char_value || p_mode_info_ptr -> mode_value.char_value;
	end;

	else if p_mode_info_ptr -> mode_value.flags.char_valuep then do;
	     p_char_value
		= p_char_value || "=" || p_mode_info_ptr -> mode_value.char_value;
	end;

     end parse_modes;

/**/

/* *** Procedure: send_terminal_modes - Internal proc for mowse_io_  *** */

send_terminal_modes:
     proc (p_chars, p_PL, p_LL);


/* PROCEDURE FUNCTION

Send a predefined mode message string to the MOWSE terminal emulator WSTERM.

A modes message is formulated and sent through the foreground channel to
be interpretted by WSTERM - the smart terminal emulator.
*/

/* NOTES

If WSTERM does not exist in the Capability Address Table the message will not
be sent and the error code error_table_$incompatible_term_type will be
returned.

Below is the format of the modes message:

 --------------------------------------------------------------
|S|T|M|0|6|mode_switches|kill|erase|esc|line_length|page_length|
 --------------------------------------------------------------

	STM	    - message header
	06	    - "\000\006" length of data of message
	mode_switches - "00000111" lfecho, crecho, video mode
	kill	    - kill character
	erase	    - erase character
         *esc	    - escape character
	page_length   - lines per page
	line_length   - columns per line

         *If more than one escape characters are defined, then if one of the
	characters is "\" it will be specified, otherwise the first
	character in the list will be used.

Values of p_chars, p_PL, or p_LL which are invalid will be looked for in the
current settings and filled in.  Invalid settings are as follows:

	p_chars(1:3)     = "";
	p_PL	       < 0;
	p_LL	       < 0:
*/

/* INPUT PARAMETERS */
dcl p_chars	       char (3) parameter;	    /* Kill, Erase, Escape chars */
dcl p_PL		       fixed bin parameter;	    /* Page length */
dcl p_LL		       fixed bin parameter;	    /* Line length */

/* MISC VARIABLES */
dcl r_len		       fixed bin (21);

/* INITIALIZATION */
	r_len = 0;

/* MAIN */

/* Set the kill character */

	if substr (p_chars, 1, 1) ^= byte (0) then
	     mio_data.WSTERM_modes (WST_KILL) = substr (p_chars, 1, 1);

/* Set the erase character */

	if substr (p_chars, 2, 1) ^= byte (0) then
	     mio_data.WSTERM_modes (WST_ERASE) = substr (p_chars, 2, 1);

/* Set the escape character */

	if substr (p_chars, 3, 1) ^= byte (0) then
	     mio_data.WSTERM_modes (WST_ESCAPE) = substr (p_chars, 3, 1);

/* Set the line length */

	if p_LL >= 0 then
	     mio_data.WSTERM_modes (WST_LINE_LENGTH) = byte (p_LL);

/* Set the page length */

	if p_PL >= 0 then
	     mio_data.WSTERM_modes (WST_PAGE_LENGTH) = byte (p_PL);

/* Send the modes message to the Foreground channel */

	call ws_packet_transmitter_$data (mio_data_ptr, FG,
	     addr (mio_data.WSTERM_modes), 11, FG_CONTROL_MESSAGE);

     end send_terminal_modes;

/**/

/* *** Procedure: set_terminal - Internal proc for mowse_io_  *** */

set_terminal:
     proc (p_info_ptr, p_code);


/* PROCEDURE FUNCTION

Parse through the termianal info and handle accordingly.
*/

/* NOTES
*/

/* INPUT PARAMETERS */
dcl p_info_ptr	       ptr parameter;	    /* set_term_type_info pointer */

/* OUTPUT PARAMETERS */
dcl p_code	       fixed bin (35) parameter;

/* MISC VARIABLES */
dcl code		       fixed bin (35);
dcl ll		       fixed bin;		    /* Line length */
dcl pl		       fixed bin;		    /* Page length */
dcl erkl_esc	       char (3);		    /* Erase, kill, escape chars */
dcl initial_modes	       char (256);		    /* Initial modes */
dcl initial_string	       char (512) var;	    /* Initial terminal string */

/* STRUCTURES */
dcl 01 initial_string_struc based (addr (initial_string)),
       02 data_len	       fixed bin (21) aligned,
       02 data	       char (512);
dcl 01 term_info	       like terminal_info aligned automatic;
dcl 01 stty_info	       like set_term_type_info automatic;

/* INITIALIZATION */
	if ^check_validity_int (p_info_ptr, 1, p_code) then
	     return;

/* MAIN */

/* Copy callers set_term_type_info structure */

	stty_info = p_info_ptr -> set_term_type_info;

/* Tell tty_ of the change in terminal info, send init string and set modes
   must be nulled out as they are handled differently  */

	stty_info.flags.send_initial_string = False;
	stty_info.flags.set_modes = False;
	stty_info.ignore_line_type = True;
	call iox_$control (mio_data.iocb_ptr, "set_term_type",
	     addr (stty_info), p_code);
	if p_code ^= 0 then
	     return;

/* Get terminal info from tty_ */

	term_info.version = 1;
	call iox_$control (mio_data.iocb_ptr, "terminal_info",
	     addr (term_info), p_code);
	if p_code ^= 0 then
	     return;

/* If terminal modes are to be set, set default modes from the TTT and
   ^video_mode and send */

	if p_info_ptr -> set_term_type_info.flags.set_modes then do;
	     call ttt_info_$modes (rtrim (term_info.term_type),
		initial_modes, p_code);
	     if p_code ^= 0 then
		return;

	     if length (rtrim (initial_modes)) > 0 then do;
		call get_new_modes ("force," || initial_modes, "",
		     erkl_esc, pl, ll, p_code);
		if p_code ^= 0 then
		     return;
	     end;

	     substr (unspec (mio_data.WSTERM_modes (WST_MODES)), 9, 1) = "0"b;
	     call send_terminal_modes (erkl_esc, pl, ll);
	end;

	if p_info_ptr -> set_term_type_info.flags.send_initial_string then do;
	     call ttt_info_$initial_string (rtrim (term_info.term_type),
		initial_string, code);
	     if code = 0 then do;
		if initial_string_struc.data_len = 0 then do;
		     p_code = error_table_$no_initial_string;
		     return;
		end;

		call ws_packet_transmitter_$data (mio_data_ptr, FG,
		     addr (initial_string_struc.data),
		     initial_string_struc.data_len, FG_TERMINAL_DATA);
	     end;
	end;

     end set_terminal;

/**/

/* *** Procedure: setup_entry - Internal proc for mowse_io_  *** */

setup_entry:
     proc ();


/* PROCEDURE FUNCTION

Initialize all the ENTRY point parameters and mowsish stuff.
*/

/* NOTES
*/

/* MISC VARIABLES */

/* INITIALIZATION */

/* MAIN */

	p_code = 0;
	iocb_ptr = p_iocb_ptr;
	mio_data_ptr
	     = iocb_ptr -> iocb.actual_iocb_ptr -> iocb.attach_data_ptr;

     end setup_entry;

/**/

%page;

/* INCLUDE FILES */
%include ipc_create_arg;
%include mowse_io_structures;
%include mowse_mcb;
%include mowse_io_control_info;
%include mowse_info;
%include tty_read_status_info;
%include terminal_info;
%include set_term_type_info;
%include mowse_io_bad_control;
%include static_handlers;
%include tty_convert;
%include tty_editing_chars;
%include iox_modes;
%include mode_string_info;
%include mowse;
%include mowse_messages;
%include mowse_io_constants;
%include mowse_io_data;
%include iocbx;

     end;
