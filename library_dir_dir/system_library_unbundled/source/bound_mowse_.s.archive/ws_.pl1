/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1986 *
        *                                                         *
        *********************************************************** */

/****^  HISTORY COMMENTS:
  1) change(86-04-04,Smith), approve(87-07-15,MCR7580),
     audit(87-07-30,RBarstad), install(87-08-07,MR12.1-1075):
     Coded execute_command
  2) change(86-04-15,Flegel), approve(87-07-15,MCR7580),
     audit(87-07-30,RBarstad), install(87-08-07,MR12.1-1075):
     Coded create_instance, destroy_instance
  3) change(86-04-17,Flegel), approve(87-07-15,MCR7580),
     audit(87-07-30,RBarstad), install(87-08-07,MR12.1-1075):
     Coded find_capability_name, find_capability_number
  4) change(86-04-30,Smith), approve(87-07-15,MCR7580),
     audit(87-07-30,RBarstad), install(87-08-07,MR12.1-1075):
     Coded execute_capability
  5) change(86-06-11,Smith), approve(87-07-15,MCR7580),
     audit(87-07-30,RBarstad), install(87-08-07,MR12.1-1075):
     Coded suspend_capability, resume_capability, terminate_capability
  6) change(86-06-23,Smith), approve(87-07-15,MCR7580),
     audit(87-07-30,RBarstad), install(87-08-07,MR12.1-1075):
     Coded reset_capability, put_background_message
  7) change(86-07-01,Smith), approve(87-07-15,MCR7580),
     audit(87-07-30,RBarstad), install(87-08-07,MR12.1-1075):
     Coded connect_request, connect_response, get_status, put_status, sleep,
     disconnect_request, disconnect_response
  8) change(86-10-22,Smith), approve(87-07-15,MCR7580),
     audit(87-07-30,RBarstad), install(87-08-07,MR12.1-1075):
     Modified connect_request so that capability is created is it doesn't
     already exist.
  9) change(86-10-22,Smith), approve(87-07-15,MCR7580),
     audit(87-07-30,RBarstad), install(87-08-07,MR12.1-1075):
     Mofidied destroy instance so that capability name not sent in
     delete_from_remote_cat_ message.
 10) change(86-11-07,Flegel), approve(87-07-15,MCR7580),
     audit(87-07-30,RBarstad), install(87-08-07,MR12.1-1075):
     Changed put_background_message to split long messages into multiple
     pieces up to a length of MAXIMUM_BG_SIZE (mowse.incl.pl1).
 11) change(86-11-27,Flegel), approve(86-11-27,MCR7580),
     audit(87-07-30,RBarstad), install(87-08-07,MR12.1-1075):
     Approved.
 12) change(86-11-27,Flegel), approve(86-11-27,MCR7580),
     audit(87-07-30,RBarstad), install(87-08-07,MR12.1-1075):
     If a long message is pending from the caller to execute_capability, an
     error code is returned because MOWSE protocol will not provide for
     multiple pending long messages.
 13) change(86-12-05,Flegel), approve(86-12-05,MCR7580),
     audit(87-07-30,RBarstad), install(87-08-07,MR12.1-1075):
     Added chacks fo null MOWSE tables, if it occurs, then a new_process is
     generated.
 14) change(86-12-10,Flegel), approve(86-12-10,MCR7580),
     audit(87-07-30,RBarstad), install(87-08-07,MR12.1-1075):
     Replaced signalling of mowse_fatal_error with a call to fatal_mowse_trap_
                                                   END HISTORY COMMENTS */
/* format: style4,indattr,ifthen,^indcomtxt,thendo,^indproc,^indblkcom,initcol1,declareind8,dclind4,struclvlind3,comcol55 */
ws_:
     proc ();


/* : PROCEDURE FUNCTION

MOWSE Subroutine Library which provides a means with which applications can
communicate with MOWSE.

Entry Points:

     connect_request	connect_response
     create_instance	destroy_instance
     disconnect_request	disconnect_response
     execute_capability	execute_command
     find_capability_name	find_capability_number
     get_background_message	get_status
     put_background_message	resume_capability
     send_query_reply	sleep
     suspend_capability	terminate_capability
*/

/**/

/* INPUT PARAMETERS */
dcl p_args	       char (*) parameter;
dcl p_reply_string	       char (*) parameter;
dcl p_status	       fixed bin parameter;
dcl p_capability_number    fixed bin parameter;
dcl p_time	       fixed bin (35) parameter;
dcl p_status_result	       char (*) parameter;
dcl p_status_request       char (*) parameter;
dcl p_capability_name      char (*) parameter;
dcl p_command	       char (*) parameter;
dcl p_data_block_ptr       ptr parameter;
dcl p_data_len	       fixed bin (17) parameter;
dcl p_data_ptr	       ptr parameter;
dcl p_entry_name	       char (*) parameter;
dcl p_inbuff_length	       fixed bin (17) parameter;
dcl p_major	       fixed bin (17) parameter;
dcl p_mcb_ptr	       ptr parameter;
dcl p_minor	       fixed bin (17) parameter;
dcl p_outbuff_length       fixed bin (17) parameter;
dcl p_system	       fixed bin (17) parameter;


/* OUTPUT PARAMETERS */
dcl p_cmd_id	       fixed bin (17) parameter;
dcl p_code	       fixed bin (35) parameter;

/* MISC VARIABLES */
dcl connect_request_len    fixed bin (17);
dcl connect_request_string char (MAXIMUM_PACKET_SIZE);
dcl arguments	       char (MAXIMUM_PACKET_SIZE - 33) var;
dcl capname	       char (32) var;
dcl mowse_mcb_ptr	       ptr;
dcl mowse_iocb_ptr	       ptr;
dcl temp_major	       fixed bin;
dcl sysid		       fixed bin;
dcl search_name	       char (32);		    /* Temporary name for cap */
dcl mowse_info_ptr	       ptr;		    /* Pointer to mowse info structure */
dcl temp_mcb_ptr	       ptr;
dcl temp_char	       char;
dcl minor_num	       fixed bin;		    /* minor capability number */
dcl first_byte	       fixed bin;
dcl longinfo_length	       fixed bin;		    /* length of error_table_ longinofo */
dcl longinfo	       char (100) aligned;	    /* longinfo status string */
dcl shortinfo	       char (8) aligned;	    /* shortinfo status string */

dcl formatted_string       char (MAXIMUM_BG_SIZE);    /* generated formatted string */
dcl formatted_string_length
		       fixed bin;		    /* length of string generated by ioa_ call */
dcl result_string	       char (MAXIMUM_BG_SIZE);    /* generated result string */
dcl result_string_length   fixed bin;		    /* length of result string */

dcl arg_ptr	       ptr;		    /* pointer to general argument */
dcl arg_len	       fixed bin (21);	    /* length of arguments */
dcl caller_name_length     fixed bin (21);	    /* length of caller name */
dcl based_caller_name      char (32) based (arg_ptr); /* overlay for caller's name */
dcl caller_name	       char (32);		    /* caller's name as in com_err_ */
dcl based_code	       fixed bin based (arg_ptr); /* overlay for code */
dcl based_mcb_ptr	       ptr based (arg_ptr);	    /* overlay for mcb_ptr */
dcl arg_list_ptr	       ptr;		    /* pointer to arg list used in put_background_message */
dcl errcode	       fixed bin (35);
dcl arg_count	       fixed bin;
dcl system_free_area       area based (system_free_area_ptr);
					    /* area used for the allocation of mowse structures */
dcl system_free_area_ptr   ptr;
dcl cap_index	       fixed bin (17);	    /* index into CAT tables */
dcl cap_num	       fixed bin (17);	    /* index into CAT tables or a major capability */
dcl destination	       fixed bin (17);	    /* major capability */
dcl ecode		       fixed bin (35);
dcl entry_point	       entry variable;
dcl i		       fixed bin (17);
dcl in_space	       char (
		       get_buff_length (p_inbuff_length,
		       MINIMUM_BUFFER_SIZE, MAXIMUM_BUFFER_SIZE)) based;
					    /* space for application buffers */
dcl major_num	       fixed bin (17);	    /* capability number */
dcl message_str	       char (MAXIMUM_PACKET_SIZE);
					    /* MOWSE system id */
dcl source_major	       fixed bin (17);
dcl source_system	       fixed bin (17);
dcl temp_buff_ptr	       ptr;
dcl input_buffer_length    fixed bin;
dcl input_buffer_data      char (input_buffer_length) based (temp_buff_ptr);
					    /* temporary application buffers */

/* STRUCTURES */

dcl 01 mio_info	       like mowse_io_info automatic;
					    /* Automatic mowse info */
dcl 01 mio_sleep	       like mowse_io_sleep_info automatic;
					    /*  Automatic sleep info structure */
					    /* used by create_instance to compose message destined for add_to_remote_cat_
   (internal mowse routine) */

dcl 01 alter_remote_cat_msg,
       02 major	       char (1) unal,
       02 major_name       char (CAPABILITY_NAME_LENGTH) unal;

/* SYSTEM CALLS */
dcl iox_$control	       entry (ptr, char (*), ptr, fixed bin (35));
dcl iox_$close	       entry (ptr, fixed bin (35));
dcl terminate_process_     entry (char (*), ptr);
dcl com_err_$convert_status_code_
		       entry (fixed bin (35), char (8) aligned,
		       char (100) aligned);
dcl ioa_$general_rs	       entry (ptr, fixed bin, fixed bin, char (*),
		       fixed bin (21), bit (1) aligned, bit (1) aligned);
dcl cu_$arg_ptr	       entry (fixed bin, ptr, fixed bin (21),
		       fixed bin (35));
dcl cu_$arg_list_ptr       entry (ptr);
dcl cu_$arg_count	       entry (fixed bin, fixed bin (35));
dcl get_system_free_area_  entry () returns (ptr);
dcl hcs_$make_entry	       entry (ptr, char (*), char (*), entry,
		       fixed bin (35));

/* SYSTEM CALL SUPPORT */
dcl ws_error_$invalid_sleep_interval
		       fixed bin (35) ext static;
dcl ws_error_$inconsistent_mowse_tables
		       fixed bin (35) ext static;
dcl error_table_$unimplemented_version
		       fixed bin (35) ext static;
dcl error_table_$no_table  fixed bin (35) ext static;
dcl ws_error_$invalid_connect_status
		       fixed bin (35) ext static;
dcl ws_error_$not_available
		       fixed bin (35) ext static;
dcl ws_error_$sleeping     fixed bin (35) ext static;
dcl ws_error_$cant_create_instance
		       fixed bin (35) ext static;
dcl ws_error_$invalid_minor_capability
		       fixed bin (35) ext static;
dcl ws_error_$suspended    fixed bin (35) ext static;
dcl ws_error_$not_suspended
		       fixed bin (35) ext static;
dcl ws_error_$invalid_capability_name
		       fixed bin (35) ext static;
dcl ws_error_$invalid_capability_number
		       fixed bin (35) ext static;
dcl ws_error_$invalid_mcb  fixed bin (35) ext static;
dcl ws_error_$invalid_system_id
		       fixed bin (35) ext static;
dcl ws_error_$buffer_overflow
		       fixed bin (35) ext static;

/* EXTERNAL CALLS */
dcl send_mowse_message_    entry (ptr, fixed bin, fixed bin, fixed bin,
		       fixed bin, fixed bin, fixed bin, ptr, fixed bin,
		       fixed bin, fixed bin (35));
dcl find_mowse_io_	       entry (ptr, fixed bin (35));
dcl get_mowse_info_ptr_    entry (ptr, ptr, fixed bin (35));
dcl send_msg_	       entry (ptr, fixed bin, fixed bin, ptr, fixed bin,
		       fixed bin, fixed bin (35));
dcl capability_$unpack     entry (fixed bin, fixed bin, fixed bin,
		       fixed bin (35));
dcl capability_$pack       entry (fixed bin, fixed bin, fixed bin,
		       fixed bin (35));
dcl find_free_cat_entry_   entry (ptr, fixed bin, fixed bin (35));
dcl release_outbuffer_     entry (ptr);
dcl fatal_mowse_trap_      entry (fixed bin (35));

/* EXTERNAL CALL SUPPORT */

/* BUILTINS */
dcl min		       builtin;
dcl null		       builtin;
dcl addr		       builtin;
dcl byte		       builtin;
dcl length	       builtin;
dcl round		       builtin;
dcl rtrim		       builtin;
dcl substr	       builtin;

/* CONDITIONS */

/* CONSTANTS */
dcl VERSION	       char (8) int static options (constant)
		       init ("version1");
dcl CMD_ID_CNT	       fixed bin int static init (1);
dcl TRUE		       bit (1) int static options (constant) init ("1"b);
dcl FALSE		       bit (1) int static options (constant) init ("0"b);

/**/
/* INITIALIZATION */

/* MAIN */
	return;

/**/

/* ENTRY POINTS */

/* : *** Entry: connect_request - internal entry for ws_ ****/

/* ENTRY FUNCTION

Request a connection to an application.
*/

connect_request:
     entry (p_capability_name, p_args, p_system, p_mcb_ptr, p_code);

	p_code = 0;

/* : check mcb pointer */

	call check_mcb_ptr (p_mcb_ptr, p_code);
	if p_code ^= 0 then
	     return;

	mowse_info_ptr = p_mcb_ptr -> mcb.mowse_info_ptr;
	capname = p_capability_name;
	capname = rtrim (capname);
	connect_request_string = capname;
	connect_request_len = length (capname);
	arguments = p_args;

	if (length (rtrim (arguments)) ^= 0) then do;
	     connect_request_string = capname || " " || rtrim (arguments);
	     connect_request_len = length (capname) + 1 +
		length (rtrim (arguments));
	end;

	call capability_$pack (p_system, INTERNAL, destination, p_code);
	if p_code ^= 0 then
	     return;

	call send_msg_ (p_mcb_ptr, destination, REQUEST_CONNECT,
	     addr (connect_request_string), connect_request_len, BG, p_code);
	if p_code ^= 0 then do;
	     call fatal_mowse_trap_ (p_code);
	     return;
	end;

	return;

/**/

/* : *** Entry: connect_response - internal entry for ws_ *** */

/* : ENTRY FUNCTION

Allows an application to respond to a connect request from some application.
*/

connect_response:
     entry (p_status, p_major, p_mcb_ptr, p_code);

	p_code = 0;

	call check_mcb_ptr (p_mcb_ptr, p_code);
	if p_code ^= 0 then
	     return;

/* : check major capability_number */

	call capability_$unpack (sysid, major_num, p_major, p_code);
	if p_code ^= 0 then
	     return;

/* : check the status being sent as response */

	if (p_status ^= ACCEPT) & (p_status ^= REJECT) then do;
	     p_code = ws_error_$invalid_connect_status;
	     return;
	end;

	call verify_capability (p_mcb_ptr -> mcb.mowse_info_ptr,
	     p_major, p_code);
	if p_code ^= 0 then
	     return;

/* : Send RESPONSE DISCONNECT message with status as data */

	temp_char = byte (p_status);
	call send_msg_ (p_mcb_ptr, p_major, RESPONSE_CONNECT,
	     addr (temp_char), 1, BG, p_code);
	if p_code ^= 0 then do;
	     call fatal_mowse_trap_ (p_code);
	     return;
	end;

	return;

/**/

/* : *** Entry: create_instance - internal entry for ws_ *** */

/* : ENTRY FUNCTION

Register the calling routine with MOWSE by assigning it a major capability
number and adding it to MOWSE's capability table. The calling routine must
supply the name by which it is to be known to MOWSE, and the entry point
describing where it is to be invoked by an execute capability.
*/

/* : NOTES

All applications which expect to receive messages must have registered with
MOWSE (through create_instance) in order to receive messages. A message is
provided to the application when a the destination of the message specifies
the major capability number of the application. The application will then be
invoked at the entry name provided with the message (argument data), its
length, and a pointer to the applications data_block as follows:

        application_$entry_point (minor_capability, major_sender,
                                  arg_ptr, arg_len, p_mcb_ptr, data_blk_ptr);

The buffers inbuff and outbuff allow MOWSE to send and receive messages
longer than one communications packet defined by PACKET_SIZE) in a manner
transparent to the capability.
*/

create_instance:
     entry (p_capability_name, p_entry_name, p_inbuff_length,
	p_outbuff_length, p_data_block_ptr, p_mcb_ptr, p_code);

	p_code = 0;
	cap_index = 0;

/* : Get mowse info required before allocation of new mcb */

/* : - get mowse iocb_ptr */
	call find_mowse_io_ (mowse_iocb_ptr, p_code);
	if p_code ^= 0 then
	     return;

/* : - get mowse mcb_ptr */
	mio_info.version = mowse_io_info_version_1;
	call iox_$control (mowse_iocb_ptr, "get_mowse_info",
	     addr (mio_info), p_code);
	if p_code ^= 0 then
	     return;
	mowse_mcb_ptr = mio_info.mcb_ptr;

/* : - get mowse info_ptr */

	call get_mowse_info_ptr_ (mowse_mcb_ptr, mowse_info_ptr, p_code);
	if p_code ^= 0 then
	     return;

	if mowse_info_ptr = null then
	     call null_mowse_info_handler ();

	if mowse_info_ptr -> mowse_info.version ^= VERSION then do;
	     p_code = error_table_$unimplemented_version;
	     return;
	end;

/* : If no free entry in local CAT, return error */

	call find_free_cat_entry_ (mowse_info_ptr, cap_index, p_code);
	if (p_code ^= 0) then
	     return;

/* : Create entry point call hcs_$make_entry */

	call hcs_$make_entry (null, p_capability_name, p_entry_name,
	     entry_point, p_code);
	if (p_code ^= 0) then
	     return;

/* : Make major_capability number */

	call capability_$pack (LOCAL_SYSTEM, cap_index, cap_num, p_code);
	if (p_code ^= 0) then do;
	     p_code = ws_error_$cant_create_instance;
	     return;
	end;

/* : allocate MCB */

	system_free_area_ptr = get_system_free_area_ ();
	allocate mcb in (system_free_area) set (p_mcb_ptr);

/* : Set mcb_ptr stored in the local CAT table */

	mowse_info_ptr -> mowse_info.local_cat (cap_index).mcb_ptr =
	     p_mcb_ptr;

/* : Initialize CAT flags */

	mowse_info_ptr -> mowse_info.local_cat (cap_index).flags.reset
	     = "0"b;
	mowse_info_ptr -> mowse_info.local_cat (cap_index).flags.suspended
	     = "0"b;
	mowse_info_ptr -> mowse_info.local_cat (cap_index).flags.status
	     = "0"b;
	mowse_info_ptr -> mowse_info.local_cat (cap_index).sleep_time
	     = 0;

/* : Initialize the mcb */

	p_mcb_ptr -> mcb.version = VERSION;
	p_mcb_ptr -> mcb.iocb_ptr = mowse_iocb_ptr;
	p_mcb_ptr -> mcb.major_capability = cap_num;
	p_mcb_ptr -> mcb.capability_name = p_capability_name;
	p_mcb_ptr -> mcb.entry_var = entry_point;
	p_mcb_ptr -> mcb.data_block_ptr = p_data_block_ptr;

	allocate in_space in (system_free_area)
	     set (p_mcb_ptr -> mcb.inbuff);
	p_mcb_ptr -> mcb.inbuff_length
	     =
	     get_buff_length (p_inbuff_length, MINIMUM_BUFFER_SIZE,
	     MAXIMUM_BUFFER_SIZE);
	p_mcb_ptr -> mcb.inbuff_position_index = 0;
	p_mcb_ptr -> mcb.inbuff_data_length = 0;

	p_mcb_ptr -> mcb.outbuff_length
	     =
	     get_buff_length (p_outbuff_length, MINIMUM_BUFFER_SIZE,
	     MAXIMUM_BUFFER_SIZE);

	p_mcb_ptr -> mcb.outbuff_list_start = null;
	p_mcb_ptr -> mcb.outbuff_list_end = null;
	p_mcb_ptr -> mcb.mowse_info_ptr = mowse_info_ptr;

/* : Send ADD_TO_REMOTE_CAT message to remote 
     capability_number + capability_name (not padded) */

	alter_remote_cat_msg.major = byte (cap_index);
	alter_remote_cat_msg.major_name =
	     substr (p_capability_name, 1, length (p_capability_name));
	call capability_$pack (REMOTE_SYSTEM, INTERNAL, destination,
	     p_code);
	call send_msg_ (mowse_mcb_ptr, destination, ADD_TO_REMOTE_CAT,
	     addr (alter_remote_cat_msg), length (p_capability_name) + 1,
	     BG, p_code);

	if p_code ^= 0 then do;
	     p_code = ws_error_$cant_create_instance;
	     free p_mcb_ptr -> mcb;
	     p_mcb_ptr = null;
	     mowse_info_ptr -> mowse_info.local_cat (cap_index).mcb_ptr
		= null;
	end;

	return;

/**/


/* : *** Entry: destroy_instance - internal entry for ws_ *** */

/* : ENTRY FUNCTION

Remove all reference to the calling application from MOWSE.  This will include
freeing all MOWSE associated buffers and control information blocks.
*/

destroy_instance:
     entry (p_mcb_ptr, p_code);

	p_code = 0;

	call check_mcb_ptr (p_mcb_ptr, p_code);
	if p_code ^= 0 then
	     return;

/* : Get capability index */
	call capability_$unpack (sysid, cap_index,
	     p_mcb_ptr -> mcb.major_capability, p_code);

/* : Get mowse info pointer */
	mowse_info_ptr = p_mcb_ptr -> mcb.mowse_info_ptr;

/* : send DELETE_FROM_REMOTE_CAT message to remote system
     {capability_number} */

	alter_remote_cat_msg.major = byte (cap_index);
	call capability_$pack (REMOTE_SYSTEM, INTERNAL, destination,
	     p_code);

	call send_msg_ (p_mcb_ptr, destination, DELETE_FROM_REMOTE_CAT,
	     addr (alter_remote_cat_msg.major), 1, BG, p_code);

	if p_code ^= 0 then do;
	     call fatal_mowse_trap_ (p_code);
	     return;
	end;

/* : Free message buffers and mcb */

	temp_buff_ptr = p_mcb_ptr -> mcb.inbuff;
	input_buffer_length = p_mcb_ptr -> mcb.inbuff_data_length;
	free input_buffer_data;
	temp_buff_ptr = null;
	p_mcb_ptr -> mcb.inbuff = null;

	call release_outbuffer_ (p_mcb_ptr);

	free p_mcb_ptr -> mcb;
	p_mcb_ptr = null;
	mowse_info_ptr -> mowse_info.local_cat (cap_index).mcb_ptr =
	     null;

	p_code = 0;
	return;

/**/

/* : *** Entry: disconnect_request - internal entry for ws_ *** */

/* : ENTRY FUNCTION

Request a disconnection to an application.
*/

disconnect_request:
     entry (p_capability_number, p_mcb_ptr, p_code);

	p_code = 0;

	call check_mcb_ptr (p_mcb_ptr, p_code);
	if p_code ^= 0 then
	     return;

/* : check the capability_number */

	mowse_info_ptr = p_mcb_ptr -> mcb.mowse_info_ptr;
	call verify_capability (mowse_info_ptr, p_capability_number, p_code);
	if p_code ^= 0 then
	     return;

/* : Send the REQUEST_DISCONNECT message */

	call send_msg_ (p_mcb_ptr, p_capability_number,
	     REQUEST_DISCONNECT, null, 0, BG, p_code);
	if p_code ^= 0 then do;
	     call fatal_mowse_trap_ (p_code);
	     return;
	end;

	return;

/**/

/* : *** Entry: disconnect_response - internal entry for ws_ *** */

/* : ENTRY FUNCTION

Allows some application to responds to a disconnect request from some
application.
*/

disconnect_response:
     entry (p_status, p_major, p_mcb_ptr, p_code);

	p_code = 0;

	call check_mcb_ptr (p_mcb_ptr, p_code);
	if p_code ^= 0 then
	     return;

/* : check the response to request */

	if (p_status ^= ACCEPT) & (p_status ^= REJECT) then do;
	     p_code = ws_error_$invalid_connect_status;
	     return;
	end;

/* : verify that the capability for which the response is destined exists */

	mowse_info_ptr = p_mcb_ptr -> mcb.mowse_info_ptr;
	call verify_capability (mowse_info_ptr, p_major, p_code);
	if p_code ^= 0 then
	     return;

/* : Send message containing response to requesting application */

	temp_char = byte (p_status);
	call send_msg_ (p_mcb_ptr, p_major, RESPONSE_DISCONNECT,
	     addr (temp_char), 1, BG, p_code);
	if p_code ^= 0 then do;
	     call fatal_mowse_trap_ (p_code);
	     return;
	end;

	return;

/**/

/* : *** Entry: execute_capability - internal entry for ws_ *** */

/* ENTRY FUNCTION

Executes a loaded capability locally or remotely.
*/

execute_capability:
     entry (p_major, p_minor, p_data_ptr, p_data_len, p_mcb_ptr, p_code);

/* : Look up major_capability number in the local and remote CAT tables. */

	p_code = 0;

	call check_mcb_ptr (p_mcb_ptr, p_code);
	if p_code ^= 0 then
	     return;

	call capability_$unpack (sysid, major_num, p_major, p_code);
	if p_code ^= 0 then
	     return;

/* : Get mowse info pointer */
	mowse_info_ptr = p_mcb_ptr -> mcb.mowse_info_ptr;

/* : Check if minor is valid */

	if p_minor < MINIMUM_USER_MINOR | p_minor > MAXIMUM_USER_MINOR
	then do;
	     p_code = ws_error_$invalid_minor_capability;
	     return;
	end;

/* : Check that the capability being executed exists */

	call verify_capability (mowse_info_ptr, p_major, p_code);
	if p_code ^= 0 then
	     return;

/* : Check if capability to be executed has been suspended or reset
     and the minor is not one of the dedicated (system)  minors.
     If it is then return ws_error_$suspended */

	if sysid = LOCAL_SYSTEM then do;
	     if ((mowse_info_ptr
		-> mowse_info.local_cat (major_num).flags.reset)
		| (mowse_info_ptr
		-> mowse_info.local_cat (major_num).flags.suspended)
		& ^(p_minor < MINIMUM_USER_MINOR)) then do;

		p_code = ws_error_$suspended;
		return;
	     end;
	end;
	else if
	     ((mowse_info_ptr
	     -> mowse_info.remote_cat (major_num).flags.reset)
	     | (mowse_info_ptr
	     -> mowse_info.remote_cat (major_num).flags.suspended)
	     & ^(p_minor < MINIMUM_USER_MINOR)) then do;

	     p_code = ws_error_$suspended;
	     return;
	end;

/* : Check if the capability is sleeping.
     - If it is then return ws_error_$sleeping */

	if sysid = LOCAL_SYSTEM then do;
	     if (mowse_info_ptr
		-> mowse_info.local_cat (major_num).sleep_time ^= 0)
	     then do;
		p_code = ws_error_$sleeping;
		return;
	     end;
	end;
	else if (mowse_info_ptr
	     -> mowse_info.remote_cat (major_num).sleep_time ^= "0"b)
	then do;
	     p_code = ws_error_$sleeping;
	     return;
	end;

/* : If the buffer is too small to handle that the information
     then return with p_code set to ws_error_$buffer_overflow
     OR if the message to be sent is long and there is a pending message in
     the outbuffer, return buffer overflow because protocol will not allow for
     more than one pending message */

	if p_data_len > p_mcb_ptr -> mcb.outbuff_length
	     | (p_data_len > PACKET_SIZE - 6
	     & p_mcb_ptr -> mcb.outbuff_list_start ^= null)
	then do;
	     p_code = ws_error_$buffer_overflow;
	     return;
	end;

/* : Send message to the capability to be executed */

	call send_msg_ (p_mcb_ptr, p_major, p_minor, p_data_ptr,
	     p_data_len, BG, p_code);
	if p_code ^= 0 then do;
	     call fatal_mowse_trap_ (p_code);
	     return;
	end;

	return;

/**/

/* : *** Entry: execute_command - internal entry for ws_ *** */

/* ENTRY FUNCTION

Performs the execution of a command on either the remote or local systems.
*/

execute_command:
     entry (p_command, p_system, p_cmd_id, p_mcb_ptr, p_code);

	p_code = 0;

	call check_mcb_ptr (p_mcb_ptr, p_code);
	if p_code ^= 0 then
	     return;

/* : Check for valid system */
	if p_system ^= LOCAL_SYSTEM & p_system ^= REMOTE_SYSTEM then do;
	     p_code = ws_error_$invalid_system_id;
	     return;
	end;

/* : Get mowse_info_ptr */
	mowse_info_ptr = p_mcb_ptr -> mcb.mowse_info_ptr;

/* : Check for command which are too long */
	if length (p_command) > PACKET_SIZE - 2 then do;
	     p_code = ws_error_$buffer_overflow;
	     return;
	end;

/* : Generate unique command identification number. */
	p_cmd_id = CMD_ID_CNT;
	CMD_ID_CNT = CMD_ID_CNT + 1;

/* : If the system was local then execute command locally */
	if p_system = LOCAL_SYSTEM then
	     call capability_$pack (LOCAL_SYSTEM, INTERNAL, destination,
		p_code);
	else
	     call capability_$pack (REMOTE_SYSTEM, INTERNAL, destination,
		p_code);
	if p_code ^= 0 then
	     return;

/* : formulate message to be sent to remote or local mowse internal */

	first_byte = round ((p_cmd_id / 256), 0);
	message_str =
	     byte (first_byte)
	     || byte ((p_cmd_id - (first_byte * 256))) || p_command;

/* : send message to destination */
	call send_msg_ (p_mcb_ptr, destination, EXECUTE_COMMAND,
	     addr (message_str), length (p_command) + 2, BG, p_code);
	if p_code ^= 0 then do;
	     call fatal_mowse_trap_ (p_code);
	     return;
	end;

	return;

/**/

/* : *** Entry: find_capability_name - internal entry for ws_ *** */

/* : ENTRY FUNCTION

Find the name of a capability given its major capability number.
*/

find_capability_name:
     entry (p_major, p_capability_name, p_code);

	p_code = 0;

	call find_mowse_io_ (mowse_iocb_ptr, p_code);
	if p_code ^= 0 then
	     return;

	mio_info.version = mowse_io_info_version_1;
	call iox_$control (mowse_iocb_ptr, "get_mowse_info",
	     addr (mio_info), p_code);
	if p_code ^= 0 then
	     return;
	mowse_info_ptr = mio_info.info_ptr;
	if mowse_info_ptr = null then
	     call null_mowse_info_handler ();

/* : Extract the system id and CAT index */

	call capability_$unpack (sysid, cap_num, p_major, p_code);
	if (p_code ^= 0) then do;
	     p_code = ws_error_$invalid_capability_number;
	     return;
	end;

/* : If system is LOCAL_SYSTEM then
     - Check for validity
     - Invalid CAT index or inactive mcb return invalid_capability_number */

	if (sysid = LOCAL_SYSTEM) then do;
	     if (cap_num < MINIMUM_CAT_ENTRY)
		| (cap_num > MAXIMUM_CAT_ENTRY) then do;
		p_code = ws_error_$invalid_capability_number;
		return;
	     end;

	     if (mowse_info_ptr
		-> mowse_info.local_cat (cap_num).mcb_ptr = null)
	     then do;
		p_code = ws_error_$invalid_capability_number;
		return;
	     end;

/* : get the name */

	     p_capability_name =
		mowse_info_ptr
		-> mowse_info.local_cat (cap_num).mcb_ptr
		-> mcb.capability_name;
	     return;
	end;

/* : Else search remote CAT */

	i = cap_num;
	do while ((i < MAXIMUM_CAT_ENTRY + 1) &
	     (mowse_info_ptr
	     -> mowse_info.remote_cat (i).major_capability ^= p_major));
	     i = i + 1;
	end;

/* : if not found or inactive return invalid_capability_number */
	if (i > MAXIMUM_CAT_ENTRY) then do;
	     p_code = ws_error_$invalid_capability_number;
	     return;
	end;

/* : Otherwise, return the name */
	p_capability_name =
	     mowse_info_ptr
	     -> mowse_info.remote_cat (i).capability_name;
	p_code = 0;
	return;

/**/

/* : *** Entry: find_capability_number - internal entry for ws_ *** */

/* : ENTRY FUNCTION

Find the major capability number of an application given a capability name.
*/

/* : NOTES

MOWSE looks for the capability name in its capability table in the following
fashion:
            1) If the provided major capability number is invalid,
            MOWSE will begin searching from the top of the specified system
            table.
            2) If the major capability number is valid, MOWSE will
            begin searching from the next entry in the table specified by
            the system.
*/

find_capability_number:
     entry (p_capability_name, p_system, p_major, p_code);

	p_code = 0;

/* : Make sure requested system is acceptable */

	if p_system ^= LOCAL_SYSTEM & p_system ^= REMOTE_SYSTEM then do;
	     p_code = ws_error_$invalid_system_id;
	     return;
	end;

/* : Get MOWSE information for CATs */

	call find_mowse_io_ (mowse_iocb_ptr, p_code);
	if p_code ^= 0 then
	     return;

	mio_info.version = mowse_io_info_version_1;
	call iox_$control (mowse_iocb_ptr, "get_mowse_info",
	     addr (mio_info), p_code);
	if p_code ^= 0 then
	     return;

	mowse_info_ptr = mio_info.info_ptr;
	if mowse_info_ptr = null then
	     call null_mowse_info_handler ();

	call capability_$unpack (sysid, cap_index, p_major, p_code);
	if p_code ^= 0 then
	     cap_index = MINIMUM_CAT_ENTRY - 1;

/* : Search through the CAT specified by the system id sequentially */

	p_code = 0;
	do cap_index = cap_index + 1 to MAXIMUM_CAT_ENTRY;
	     if p_system = LOCAL_SYSTEM then do;
		if mowse_info_ptr
		     -> mowse_info.local_cat (cap_index).mcb_ptr
		     ^= null then do;
		     search_name =
			mowse_info_ptr
			-> mowse_info.local_cat (cap_index).mcb_ptr
			-> mcb.capability_name;
		     temp_major =
			mowse_info_ptr
			-> mowse_info.local_cat (cap_index).mcb_ptr
			-> mcb.major_capability;
		end;
		else
		     search_name = "";
	     end;
	     else do;
		search_name =
		     mowse_info_ptr
		     -> mowse_info.remote_cat (cap_index)
		     .capability_name;
		temp_major =
		     mowse_info_ptr
		     -> mowse_info.remote_cat (cap_index)
		     .major_capability;
	     end;

	     if p_capability_name = rtrim (search_name) then do;
		p_major = temp_major;
		return;
	     end;
	end;

/* : Nothing was found, return invalid_capability_name */

	p_code = ws_error_$invalid_capability_name;
	return;

/**/

/* : *** Entry: get_background_message - internal entry for ws_ *** */

/* : ENTRY FUNCTION

This entry point include for consistency with MTB741 but can never be used
in this implementatiuon of MOWSE 

NOT AVAILABLE (Can only be use by foreground applications. This implementation
of mowse does not support such applications.
*/

get_background_message:
     entry (p_reply_string, p_code);
	p_code = ws_error_$not_available;
	return;

/**/

/* : *** Entry: get_status - internal entry for ws_ *** */


/* : ENTRY FUNCTION

Request status information from a specified applicatiion. Since this can only
be called from a foreground application and MOWSE is not able to support such
applications this function need not be inplemented.  It will return an error
code (ws_error_$not_available) if called.
*/

get_status:
     entry (p_major, p_status_request, p_status_result, p_code);
	p_code = ws_error_$not_available;
	return;

/**/

/* : *** Entry: put_background_message - internal entry for ws_ *** */

/* : ENTRY FUNCTION

Provides a background application with the means of displaying one of two
types of messages through the foreground channel to a foreground application.
*/


/* : NOTES

p_code is one of the following:

     0 -- indicating that the background message consist only of the
	contents of the control_string.

     SEND_QUERY -- indicating that the control string will be used as a
          prompt requiring user INPUT.

     A standard Multics error code -- indicating that the background message
          will consist of the converted error code to com_err_ format of
	message
*/

put_background_message:
     entry options (variable);

/* : Find the number of arguments passed to this routine */

	errcode = 0;
	call cu_$arg_count (arg_count, errcode);

/* : If the number of arguments is less than 3 then return */

	if arg_count < 3 then
	     return;

/* : Get the first argument (mcb_ptr) and return if it is null */

	call cu_$arg_list_ptr (arg_list_ptr);
	call cu_$arg_ptr (1, arg_ptr, arg_len, errcode);
	if errcode ^= 0 then
	     return;
	if arg_ptr -> based_mcb_ptr = null then
	     return;
	temp_mcb_ptr = arg_ptr -> based_mcb_ptr;

/* : Check mcb_ptr */

	call check_mcb_ptr (temp_mcb_ptr, ecode);
	if ecode ^= 0 then
	     return;

/* : Get mowse info pointer */

	mowse_info_ptr = temp_mcb_ptr -> mcb.mowse_info_ptr;

/* : Get the second argument (code) and perform the following
     assignment:
        code = 0	      minor = PUT_TO_BACKGROUND_BUFFER
        code = SEND_QUERY minor = PUT_TO_QUERY_MESSAGE_BUFFER
        otherwise	      minor = -1 */

	call cu_$arg_ptr (2, arg_ptr, arg_len, errcode);
	if errcode ^= 0 then
	     return;
	ecode = arg_ptr -> based_code;

	if ecode = 0 then
	     minor_num = PUT_TO_BACKGROUND_BUFFER;
	else if ecode = SEND_QUERY then
	     minor_num = PUT_TO_QUERY_MESSAGE_BUFFER;
	else
	     minor_num = -1;

/* : get caller's name */

	call cu_$arg_ptr (3, arg_ptr, arg_len, errcode);
	if errcode ^= 0 then
	     return;
	caller_name = arg_ptr -> based_caller_name;
	caller_name_length = min (arg_len, MAXIMUM_BG_SIZE);

	formatted_string_length = 0;
	longinfo_length = 0;

/* : create destination = remote_system|internal */

	call capability_$pack (REMOTE_SYSTEM, INTERNAL, destination,
	     errcode);
	if errcode ^= 0 then
	     return;

/* : If minor = PUT_TO_BACKGROUND_BUFFER then
     - if there is a fourth variable (control_string) get it.
     -- create a formatted string */

	if minor_num = PUT_TO_BACKGROUND_BUFFER then
	     if arg_count >= 4 then do;
		call ioa_$general_rs (arg_list_ptr, 4, 5,
		     formatted_string, arg_len, "0"b, "0"b);
		formatted_string_length =
		     min (arg_len, MAXIMUM_BG_SIZE);
	     end;

/* : If minor = PUT_TO_QUERY_MESSAGE_BUFFER then
     - if the control string argument is present then
     -- generate the formatted string. */

	if minor_num = PUT_TO_QUERY_MESSAGE_BUFFER then
	     if arg_count > 3 then do;
		call ioa_$general_rs (arg_list_ptr, 4, 5,
		     formatted_string, arg_len, "0"b, "0"b);
		formatted_string_length =
		     min (arg_len, MAXIMUM_BG_SIZE);
	     end;

/* : If minor = -1 then
     - convert the error code to a error string.
     - if a control string is present then
     -- convert it to a formatted string. */

	if minor_num = -1 then do;
	     minor_num = PUT_TO_BACKGROUND_BUFFER;
	     call com_err_$convert_status_code_ (ecode, shortinfo,
		longinfo);
	     do longinfo_length = length (longinfo) by -1 to 1
		while (substr (longinfo, longinfo_length, 1) = " ");
	     end;

	     if arg_count > 3 then do;
		call ioa_$general_rs (arg_list_ptr, 4, 5,
		     formatted_string, arg_len, "0"b, "0"b);
		formatted_string_length = min (arg_len, MAXIMUM_BG_SIZE);
	     end;
	end;

/* : Concatenate "caller_name: longinfo formatted_string"
     send the message */

	result_string =
	     substr (caller_name, 1, caller_name_length)
	     || ": "
	     || substr (longinfo, 1, longinfo_length)
	     || " "
	     || substr (formatted_string, 1, formatted_string_length);
	result_string_length =
	     min (caller_name_length + longinfo_length
	     + formatted_string_length + 3, MAXIMUM_BG_SIZE);
	call send_bg (temp_mcb_ptr, destination, minor_num,
	     addr (result_string), result_string_length, FG, errcode);

	return;

/**/

/* : *** Entry: put_status - internal entry for ws_ *** */

/* : ENTRY FUNCTION

Send status information to the capability application requesting it.
*/

put_status:
     entry (p_major, p_status_result, p_mcb_ptr, p_code);

/* : check the mcb pointer */

	call check_mcb_ptr (p_mcb_ptr, p_code);
	if p_code ^= 0 then
	     return;

/* : Get mowse info pointer */

	mowse_info_ptr = p_mcb_ptr -> mcb.mowse_info_ptr;

/* : unpack and check the major capability given as input */

	call capability_$unpack (sysid, major_num, p_major, p_code);
	if p_code ^= 0 then
	     return;

/* : Verify that the capability for which the status is destined exists */

	call verify_capability (mowse_info_ptr, p_major, p_code);
	if p_code ^= 0 then
	     return;

/* : The maximum size which may be sent is one packet */

	formatted_string_length =
	     min ((length (p_status_result)), MAXIMUM_PACKET_SIZE);

/* : Send status reply messsage */

	call send_msg_ (p_mcb_ptr, p_major, STATUS_REPLY,
	     addr (p_status_result), formatted_string_length, FG,
	     p_code);
	if p_code ^= 0 then do;
	     call fatal_mowse_trap_ (p_code);
	     return;
	end;

	return;

/**/

/* : *** Entry: reset_capability - internal entry for ws_ *** */

/* : ENTRY FUNCTION

Resetting a capability on a remote or local system.
*/

reset_capability:
     entry (p_major, p_mcb_ptr, p_code);

/* : Check the mcb_ptr */

	call check_mcb_ptr (p_mcb_ptr, p_code);
	if p_code ^= 0 then
	     return;

/* : Get mowse info pointer */

	mowse_info_ptr = p_mcb_ptr -> mcb.mowse_info_ptr;

/* : Set reset flag of application issuing this call to prevent
     any messages destined for the aplication from being sent
     to it. */

	call capability_$unpack (sysid, major_num,
	     p_mcb_ptr -> mcb.major_capability, p_code);
	if p_code ^= 0 then
	     return;

/* : if application on remote system then set the remote reset flag */

	if sysid = REMOTE_SYSTEM then
	     mowse_info_ptr -> mowse_info.remote_cat (major_num).flags.reset
		= TRUE;
	else
	     mowse_info_ptr -> mowse_info.local_cat (major_num).flags.reset
		= TRUE;

/* : send a RESET_APPLICATION message  */

	call send_msg_ (p_mcb_ptr, p_major, RESET_APPLICATION, null, 0,
	     BG, p_code);
	if p_code ^= 0 then do;
	     call fatal_mowse_trap_ (p_code);
	     return;
	end;

	return;

/**/

/* : *** Entry: resume_capability - internal entry for ws_ *** */

/* : ENTRY FUNCTION

Tells MOWSE to resume a specified application
*/

/* : NOTES
 
"major" identifies both the capability and the system on which it is running.
*/

resume_capability:
     entry (p_major, p_mcb_ptr, p_code);

	p_code = 0;

/* : Check mcb_ptr */

	call check_mcb_ptr (p_mcb_ptr, p_code);
	if p_code ^= 0 then
	     return;

/* : Get mowse info pointer */

	mowse_info_ptr = p_mcb_ptr -> mcb.mowse_info_ptr;
	call capability_$unpack (source_system, source_major,
	     p_mcb_ptr -> mcb.major_capability, p_code);
	if p_code ^= 0 then
	     return;

/* : Unpack the major capability into a system and capability number. */

	call capability_$unpack (sysid, major_num, p_major, p_code);
	if p_code ^= 0 then
	     return;

/* : Check if capability is suspended */

	if sysid = LOCAL_SYSTEM then do;
	     if ^mowse_info_ptr
		-> mowse_info.local_cat (major_num).flags.suspended then

		p_code = ws_error_$not_suspended;
	end;
	else if sysid = REMOTE_SYSTEM then do;
	     if ^mowse_info_ptr
		-> mowse_info.remote_cat (major_num).flags.suspended then

		p_code = ws_error_$not_suspended;

	     mowse_info_ptr
		-> mowse_info.remote_cat (major_num).flags.suspended
		= FALSE;
	end;
	else
	     p_code = ws_error_$invalid_system_id;

	if p_code ^= 0 then
	     return;

/* : - Call the application via the predefined minor capability
     - RESUME_APPLICATION by sending a message */

	call send_msg_ (p_mcb_ptr, p_major, RESUME_APPLICATION, null,
	     0, BG, p_code);
	if p_code ^= 0 then do;
	     call fatal_mowse_trap_ (p_code);
	     return;
	end;

/* : If resuming a capability on the local system, send a RESET_SUSPEND to
     the remote */

	if sysid = LOCAL_SYSTEM then do;
	     call capability_$pack (REMOTE_SYSTEM, INTERNAL,
		temp_major, (0));
	     call send_mowse_message_ (p_mcb_ptr, LOCAL_SYSTEM, major_num,
		REMOTE_SYSTEM, INTERNAL, RESET_SUSPEND, LAST, null, 0, BG,
		p_code);
	end;
	return;

/**/

/* : *** Entry: send_query_reply - internal entry for ws_ *** */

/* : ENTRY FUNCTION

NOT AVAILABLE.
*/

send_query_reply:
     entry (p_reply_string, p_major, p_code);
	p_code = ws_error_$not_available;
	return;

/**/

/* : *** Entry: sleep - internal entry for ws_ *** */

/* : ENTRY FUNCTION 

Puts the caller to sleep (suspends it) for a given number of seconds.
*/

sleep:
     entry (p_mcb_ptr, p_time, p_code);

	p_code = 0;

/* : Check the mcb pointer */

	call check_mcb_ptr (p_mcb_ptr, p_code);
	if p_code ^= 0 then
	     return;

/* : Get mowse info pointer */

	mowse_info_ptr = p_mcb_ptr -> mcb.mowse_info_ptr;

/* : If the time requested is zero do nothing */

	if (p_time <= 0) then do;
	     p_code = ws_error_$invalid_sleep_interval;
	     return;
	end;

/* : Allocate control order structure, fill it with the required infomation
     and issue a control order to start application sleeping. */

	call capability_$unpack (sysid, major_num,
	     p_mcb_ptr -> mcb.major_capability, p_code);
	if p_code ^= 0 then do;
	     call fatal_mowse_trap_ (p_code);
	     return;
	end;

	mio_sleep.version = mowse_io_info_version_1;
	mio_sleep.major_index = major_num;
	mio_sleep.sleep_seconds = p_time;
	call iox_$control (p_mcb_ptr -> mcb.iocb_ptr, "put_to_sleep",
	     addr (mio_sleep), p_code);
	if p_code ^= 0 then
	     return;

/* : Send message to remote system telling it to update the remote
     CAT table entry for this application. */

	call capability_$pack (REMOTE_SYSTEM, INTERNAL, destination,
	     p_code);
	if p_code ^= 0 then do;
	     call fatal_mowse_trap_ (p_code);
	     return;
	end;

	call send_msg_ (p_mcb_ptr, destination, SET_SLEEP_FLAG, null,
	     0, BG, p_code);

	mowse_info_ptr -> mowse_info.local_cat (major_num).sleep_time =
	     p_time;

	return;

/**/

/* : *** Entry: suspend_capability - internal entry for ws_ *** */

/* : ENTRY FUNCTION

Tells MOWSE to suspend a given application.
*/

/* : NOTES

"major" identifies both the capability and the system on which it is running.
*/

suspend_capability:
     entry (p_major, p_mcb_ptr, p_code);

	p_code = 0;

/* : Check mcb_ptr */

	call check_mcb_ptr (p_mcb_ptr, p_code);
	if p_code ^= 0 then
	     return;

/* : Get capability number and sytem id of capability to suspend */

	call capability_$unpack (sysid, major_num, p_major, p_code);
	if p_code ^= 0 then
	     return;

/* : Get mowse info pointer */

	mowse_info_ptr = p_mcb_ptr -> mcb.mowse_info_ptr;
	if mowse_info_ptr = null then do;
	     p_code = ws_error_$invalid_mcb;
	     return;
	end;

/* : Check if the capability is not already suspended */

	if sysid = LOCAL_SYSTEM then do;
	     if mowse_info_ptr
		-> mowse_info.local_cat (major_num).flags.suspended then

		p_code = ws_error_$suspended;
	end;
	else if sysid = REMOTE_SYSTEM then do;
	     if mowse_info_ptr
		-> mowse_info.remote_cat (major_num).flags.suspended then

		p_code = ws_error_$suspended;

	     mowse_info_ptr
		-> mowse_info.remote_cat (major_num).flags.suspended
		= TRUE;
	end;
	else
	     p_code = ws_error_$invalid_system_id;

	if p_code ^= 0 then
	     return;

/* : - Call the application with the predefined minor capability
       SUSPEND_APPLICATION by sending a message */

	call send_msg_ (p_mcb_ptr, p_major, SUSPEND_APPLICATION, null, 0,
	     BG, p_code);
	if p_code ^= 0 then do;
	     call fatal_mowse_trap_ (p_code);
	     return;
	end;

/* : If suspending a capability on the local system, send a SET_SUSPEND to
     the remote */

	if sysid = LOCAL_SYSTEM then do;
	     call capability_$pack (REMOTE_SYSTEM, INTERNAL,
		temp_major, (0));
	     call send_mowse_message_ (p_mcb_ptr, LOCAL_SYSTEM, major_num,
		REMOTE_SYSTEM, INTERNAL, SET_SUSPEND, LAST, null, 0, BG,
		p_code);
	end;
	return;

/**/

/* : *** Entry: terminate_capability - internal entry for ws_ *** */


/* ENTRY FUNCTION

Tells MOWSE to terminate a specified application MOWSE directs an application
to terminate itself.
*/

terminate_capability:
     entry (p_major, p_mcb_ptr, p_code);

	p_code = 0;
	call check_mcb_ptr (p_mcb_ptr, p_code);
	if p_code ^= 0 then
	     return;

/* : Unpack the major capability into major capability number and system
     id. */

	call capability_$unpack (sysid, cap_num, p_major, p_code);
	if p_code ^= 0 then
	     return;

/* : Get mowse info pointer */

	mowse_info_ptr = p_mcb_ptr -> mcb.mowse_info_ptr;

	call verify_capability (mowse_info_ptr, p_major, p_code);
	if p_code ^= 0 then
	     return;

/* : If system id is LOCAL_SYSTEM or REMOTE_SYSTEM then
     - call the capability with minor capability TERMINATE_APPLICATION */

	call send_msg_ (p_mcb_ptr, p_major, TERMINATE_APPLICATION,
	     null, 0, BG, p_code);
	if p_code ^= 0 then do;
	     call fatal_mowse_trap_ (p_code);
	     return;
	end;

	return;

/**/

/* INTERNAL PROCEDURES */


/* *** Procedure: send_bg - Internal proc for COMMENTS  *** */


send_bg:
     proc (p_mcb_ptr, p_major, p_minor, p_data_ptr, p_data_len, p_channel,
	p_code);

/* : PROCEDURE FUNCTION

Split a background message into pieces in the event that the message is
greater than on mowse_io_ packet worth.
*/

/* INPUT PARAMETERS */
dcl p_channel	       fixed bin;		    /* Message channel */
dcl p_code	       fixed bin (35) parameter;
dcl p_data_len	       fixed bin parameter;	    /* Length of data */
dcl p_data_ptr	       ptr parameter;	    /* Data to send */
dcl p_major	       fixed bin parameter;	    /* Destination major */
dcl p_minor	       fixed bin parameter;	    /* Destination minor */
dcl p_mcb_ptr	       ptr parameter;	    /* caller's mcb */


/* MISC VARIABLES */
dcl data_length	       fixed bin;		    /* Length of partial message */
dcl send_data_pos	       fixed bin;		    /* Current position in send_data */
dcl send_data	       char (p_data_len);
dcl data_overlay	       char (p_data_len) based (p_data_ptr);


/* INITIALIZATION */
	send_data_pos = 1;

	do while (send_data_pos <= p_data_len);
	     data_length =
		min (p_data_len - send_data_pos + 1, MAXIMUM_PACKET_SIZE);
	     send_data = substr (data_overlay, send_data_pos, data_length);
	     send_data_pos = send_data_pos + data_length;

	     call send_msg_ (p_mcb_ptr, p_major, p_minor, addr (send_data),
		data_length, FG, p_code);
	     if p_code ^= 0 then do;
		call fatal_mowse_trap_ (p_code);
		return;
	     end;
	end;
     end send_bg;

/**/

/* : *** Procedure: check_mcb_ptr - internal proc for ws_ *** */

/* : PROCEDURE FUNCTION

Check the mcb_ptr to ensure that it is valid and that the major capability
it contains is valid
*/

check_mcb_ptr:
     proc (p_mcb_ptr, p_code);

/* INPUT PARAMETER */
dcl p_mcb_ptr	       ptr;

/* OUTPUT PARAMETERS */
dcl p_code	       fixed bin (35);

/* MISC VARIABLES */
dcl code		       fixed bin (35);
dcl system	       fixed bin;
dcl major		       fixed bin;


	p_code = ws_error_$invalid_mcb;
	if p_mcb_ptr = null then
	     return;

	if p_mcb_ptr -> mcb.version ^= VERSION then do;
	     p_code = error_table_$unimplemented_version;
	     return;
	end;

	mowse_info_ptr = p_mcb_ptr -> mcb.mowse_info_ptr;
	if mowse_info_ptr = null then
	     return;

	call capability_$unpack (system, major,
	     p_mcb_ptr -> mcb.major_capability, code);
	if code ^= 0 then
	     return;
	if system ^= LOCAL_SYSTEM then
	     return;
	if major = INTERNAL then do;
	     search_name = "internal_mowse_";
	     if p_mcb_ptr -> mcb.capability_name ^= search_name then
		return;
	     p_code = 0;
	     return;
	end;
	if mowse_info_ptr -> mowse_info.local_cat (major).mcb_ptr
	     ^= p_mcb_ptr then
	     return;
	p_code = 0;
     end check_mcb_ptr;

/**/

/* : *** Procedure: get_buff_length - internal procedure for ws_ *** */

/* : PROCEDURE FUNCTION

Returns a valid buffer length in case the one the user passed is out of
bounds.
*/

get_buff_length:
     proc (length, min, max) returns (fixed bin (17));

/* INPUT PARAMETERS */
dcl length	       fixed bin (17);
dcl min		       fixed bin (17);
dcl max		       fixed bin (17);

	if (length < min) then
	     return (min);
	else if (length > max) then
	     return (max);
	else
	     return (length);

     end get_buff_length;

/**/

/* : *** Procedure: null_mowse_info_handler.  Internal procedure for ws_ *** */


null_mowse_info_handler:
     proc ();

/* : PROCEDURE FUNCTION

Terminate the process as the MOWSE tables have disappeared, first tell
mowse_io_ to close so that the PC can be told of the event.
*/

/* : NOTES
*/

/* INPUT PARAMETERS */

/* OUTPUT PARAMETERS */

/* MISC VARIABLES */
dcl mowse_iocb_ptr	       ptr;		    /* mowse_io_ iocb */
dcl 01 fatal_error_info    aligned,
       02 version	       fixed bin,		    /* Must be 0 */
       02 status_code      fixed bin (35);	    /* Error code to terminate_process_ */

/* INITIALIZATION */

	call find_mowse_io_ (mowse_iocb_ptr, (0));
	call iox_$close (mowse_iocb_ptr, (0));

	fatal_error_info.version = 0;
	fatal_error_info.status_code = error_table_$no_table;
	call terminate_process_ ("fatal_error", addr (fatal_error_info));

     end null_mowse_info_handler;

/**/

/* : *** Procedure: verify_capability.  Internal procedure for ws_ *** */


verify_capability:
     proc (p_mowse_info_ptr, p_capability_id, p_code);

/* : PROCEDURE FUNCTION

Verify that a capability exists by checking the respective CAT table
*/

/* : NOTES
*/

/* INPUT PARAMETERS */
dcl p_mowse_info_ptr       ptr;
dcl p_capability_id	       fixed bin (17);

/* OUTPUT PARAMETERS */
dcl p_code	       fixed bin (35);

/* MISC VARIABLES */
dcl system_id	       fixed bin (17);
dcl capability_number      fixed bin (17);


	p_code = 0;

	if p_mowse_info_ptr = null then do;
	     p_code = ws_error_$invalid_capability_number;
	     return;
	end;

	call capability_$unpack (system_id, capability_number,
	     p_capability_id, p_code);
	if p_code ^= 0 then
	     return;
	if (system_id = LOCAL_SYSTEM) then do;
	     call check_mcb_ptr ((p_mowse_info_ptr
		-> mowse_info.local_cat (capability_number).mcb_ptr),
		p_code);
	     if p_code ^= 0 then do;
		p_code = ws_error_$invalid_capability_number;
		return;
	     end;
	end;
	else if (system_id = REMOTE_SYSTEM) then do;
	     if (p_mowse_info_ptr
		-> mowse_info.remote_cat (capability_number).
		major_capability = 0) then do;
		p_code = ws_error_$invalid_capability_number;
		return;
	     end;
	end;
	else
	     p_code = ws_error_$invalid_capability_number;
     end verify_capability;

/**/

/* INCLUDE FILES */
%include mowse_info;
%include mowse;
%include mowse_mcb;
%include mowse_messages;
%include mowse_io_control_info;
%include access_mode_values;
     end ws_;
