/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1990   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1987 *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        *********************************************************** */

/* format: style4,indattr,ifthen,^indcomtxt,thendo,^indproc,^indblkcom,initcol1,declareind8,dclind4,struclvlind3,comcol55 */
ws_packet_receiver_:
     proc ();


/* PROGRAM FUNCTION

This routine is responsible for the receipt of data from the remote (PC).
It's ONLY entry is through the immediate call event channel mechanism
released with MR12.0.  An event is signalled on the channel when tty_
(hcs_) has received the EOP character from the remote (PC) and wake up
immediately to process the packet.
*/


/* NOTES

Certain situations require that this be recursively called in order that
events for which a previous invocation of this call handler is waiting
can be received.  Such is performed by the calls to ipc_$resetev_call_chn
*/

/****^  HISTORY COMMENTS:
  1) change(87-04-20,Flegel), approve(87-06-23,MCR7649),
     audit(87-07-30,RBarstad), install(87-08-07,MR12.1-1075):
     Created.
  2) change(87-09-02,RBarstad), approve(87-09-02,PBF7649),
     audit(87-09-02,LJAdams), install(87-09-02,MR12.1-1096):
     Fixed to wrap mio_data.user_input.queue at (0) and not (1).
  3) change(88-11-08,Flegel), approve(88-11-16,MCR8023), audit(88-12-12,Lee),
     install(89-01-24,MR12.3-1012):
     phx21215 - Added support for a foreground event channel upon which
                events are transmitted when foreground data has been
                received.
  4) change(90-09-20,Bubric), approve(90-10-01,MCR8211), audit(90-10-01,Itani),
     install(90-10-17,MR12.4-1044):
     Have the calls to the routine 'nothing' changed to calls to
     'null_entry_'.
                                                   END HISTORY COMMENTS */

/* INPUT PARAMETERS */
dcl p_open_struc_ptr       ptr parameter;	    /* User control info */
dcl p_mio_data_ptr	       ptr parameter;	    /* mowse_io_ data */

/* OUTPUT PARAMETERS */
dcl p_code	       fixed bin (35) parameter;

/* MISC VARIABLES */
dcl input_ready	       bit (1);		    /* Data from the PC */
dcl i		       fixed bin;

/* STATIC */
dcl mio_data_ptr	       ptr int static init (null);/* mowse_io_ data */

/* STRUCTURES */
dcl fixedbin21	       fixed bin (21) based;
dcl 01 cond_info	       like condition_info aligned automatic;
dcl 01 mio_data	       like mowse_io_data based (mio_data_ptr);

/* SYSTEM CALLS */
dcl hcs_$wakeup	       entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
dcl ipc_$reset_ev_call_chn entry (fixed bin (71), fixed bin (35));
dcl signal_	       entry () options (variable);
dcl null_entry_	       entry options (variable);
dcl ipc_$create_event_channel entry (ptr, fixed bin (71), fixed bin (35));
dcl hcs_$reset_ips_mask    entry (bit (36) aligned, bit (36) aligned);
dcl iox_$modes	       entry (ptr, char (*), char (*), fixed bin (35));
dcl hcs_$set_ips_mask      entry (bit (36) aligned, bit (36) aligned);
dcl ipc_$unmask_ev_calls   entry (fixed bin (35));
dcl ipc_$mask_ev_calls     entry (fixed bin (35));
dcl ipc_$delete_ev_chn     entry (fixed bin (71), fixed bin (35));
dcl sct_manager_$call_handler entry (ptr, char (*), ptr, ptr, bit (1) aligned);
dcl find_condition_info_   entry (ptr, ptr, fixed bin (35));
dcl sct_manager_$set       entry (fixed bin, ptr, fixed bin (35));
dcl iox_$get_chars	       entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
dcl iox_$control	       entry (ptr, char (*), ptr, fixed bin (35));

/* SYSTEM CALL SUPPORT */
dcl error_table_$line_status_pending fixed bin (35) ext static;

/* EXTERNAL CALLS */
dcl ws_debug_$line	       entry () options (variable);
dcl ws_channel_$call_wakeup entry (ptr, fixed bin (71));
dcl ws_tools_$getdat       entry (ptr, fixed bin, ptr, fixed bin (21)) returns (fixed bin (21));
dcl ws_packet_transmitter_$data entry (ptr, fixed bin, ptr, fixed bin (21), fixed bin);
dcl ws_timer_$reset_disconnect entry options (variable);
dcl ws_timer_$reset_break  entry options (variable);
dcl ws_packet_transmitter_$ack entry (fixed bin, ptr);
dcl ws_packet_transmitter_$resend entry (ptr, fixed bin);
dcl ws_packet_transmitter_$supervisory entry (ptr, char (1));
dcl ws_tools_$reset_data   entry (ptr);
dcl ws_packet_transmitter_$nak entry (fixed bin, ptr);
dcl ws_tools_$ars	       entry (fixed bin, fixed bin) returns (fixed bin);
dcl ws_tools_$check_length entry (fixed bin (21)) returns (char (1));
dcl ws_tools_$crc_char     entry (char (1), fixed bin) returns (fixed bin);
dcl ws_debug_$packet       entry (char (*), ptr, fixed bin (21), ptr);
dcl ws_channel_$wait_wakeup entry (ptr, ptr);

/* EXTERNAL CALL SUPPORT */

/* BUILTINS */
dcl unspec	       builtin;
dcl length	       builtin;
dcl hbound	       builtin;
dcl bool		       builtin;
dcl byte		       builtin;
dcl mod		       builtin;
dcl substr	       builtin;
dcl rank		       builtin;
dcl null		       builtin;
dcl convert	       builtin;
dcl addr		       builtin;

/* CONDITIONS */
dcl cleanup	       condition;
dcl mowse_io_error	       condition;

/* CONSTANTS */
dcl False		       bit (1) int static options (constant) init ("0"b);
dcl True		       bit (1) int static options (constant) init ("1"b);

/**/

/* INITIALIZATION */

/* MAIN */

/* Debugging information */

	if mio_data.debug_iocb_ptr ^= null then do;
	     call ws_debug_$line (mio_data.debug_iocb_ptr,
		"   tasks:^[Modem ^]^[FG ^]^[BG^]",
		mio_data.task.active (0), mio_data.task.active (1),
		mio_data.task.active (2));
	end;

/* Process all interrupts, even those which occurred while this processing
   occurred */

	if ^mio_data.task.active (Modem_Reader_Task) then do;
	     mio_data.task.active (Modem_Reader_Task) = ^Idle;

	     input_ready = True;
	     do while (input_ready);
		call modem_reader ();
		input_ready = prime_tty ();
	     end;

	     mio_data.task.active (Modem_Reader_Task) = Idle;
	end;

/* Allow recursive calls and schedule all data that has arrived */

	call ipc_$reset_ev_call_chn (
	     mio_data.channel_info.packet_receiver.channel, (0));
	call scheduler ();

/* Keep the receive windows active (if they are close to being full, then
   send an ack to open them */

	do i = 0 to ChnCnt - 1;
	     if mod (mio_data.r.psn (i) - mio_data.s.lasn (i), SeqCnt)
		>= RWS - 1
		then
		call ws_packet_transmitter_$ack (i, mio_data_ptr);
	end;

	return;

/**/

%page;

/* INTERNAL ENTRIES */


/* *** Entry: initialize - Internal entry for ws_packet_receiver_  *** */

initialize:
     entry (p_mio_data_ptr, p_open_struc_ptr, p_code);


/* ENTRY FUNCTION

Initialize the packet receiver.
*/

/* NOTES
*/
	mio_data_ptr = p_mio_data_ptr;
	open_struc_ptr = p_open_struc_ptr;

	if open_struc_ptr ^= null then
	     if open_struc.flags.network_sw then
		mio_data.r.eop = CR;
	     else
		mio_data.r.eop = LF;

	mio_data.r.sop = SOH;
	mio_data.r.esc (0) = ESC;
	mio_data.r.esc (1) = SI;
	mio_data.r.esc (2) = SO;
	mio_data.r.esc_count = 0;
	mio_data.r.asn (*) = 0;
	mio_data.r.dat (*, *) = "";
	mio_data.r.esckey = ""b;
	mio_data.r.ignoring (*) = False;
	mio_data.r.pkt (*) = " ";
	mio_data.r.pktin = 0;
	mio_data.r.pktout = 0;
	mio_data.r.psn (*) = 0;

	call setup_wakeup (p_code);
	return;

/**/

/* *** Entry: sus_handler - Internal entry for ws_packet_receiver_  *** */

sus_handler:
     entry ();


/* ENTRY FUNCTION

This entry is invoked whenever the process receives a sus_signal.  This is
in order for mowse_io_ to detect that the process has been detached from the
terminal in which case future talks to the terminal are impossible.
*/

/* NOTES

All that is done is that a flag (sus_data.activated) is set, alarms are turned
off, and then control is passed on to the sus_signal_handler_ that existed
before MOWSE was attached.
*/

	mio_data.sus_data.activated = True;

	call ws_debug_$line (mio_data.debug_iocb_ptr,
	     "===== SUS Activated =====");

	call sct_manager_$set (susp_sct_index, mio_data.sus_data.sus_entry,
	     (0));
	cond_info.version = condition_info_version_1;
	call find_condition_info_ (null, addr (cond_info), (0));
	call sct_manager_$call_handler (cond_info.mc_ptr, "sus_", null, null,
	     ("0"b));

	return;

/**/

/* *** Entry: terminate - Internal entry for ws_packet_receiver_  *** */

terminate:
     entry (p_code);


/* ENTRY FUNCTION

Perform the necessary functions to turn off the receiver wakeups.
*/

/* NOTES
*/

	call reset_wakeup (p_code);
	return;

/**/

%page;

/* INTERNAL PROCEDURES */


/* *** Procedure: accept_ack - Internal proc for ws_packet_receiver_  *** */

accept_ack:
     proc (p_channel, p_asn) returns (bit (1));


/* PROCEDURE FUNCTION

Update the flow control with the provided acknowledge sequence number.
*/

/* NOTES
*/

/* INPUT PARAMETERS */
dcl p_channel	       fixed bin parameter;	    /* Channel ID */
dcl p_asn		       fixed bin parameter;	    /* Ack sequenc number */

/* OUTPUT PARAMETERS */

/* MISC VARIABLES */
dcl asn_valid	       bit (1);		    /* Sequence number validation */

/* STRUCTURES */

/* INITIALIZATION */

/* MAIN */

/* If the acknowledgement sequence number is invalid, reject the packet. */

	if mio_data.r.asn (p_channel) <= mio_data.s.psn (p_channel) then
	     asn_valid =
		(mio_data.r.asn (p_channel) <= p_asn
		& p_asn <= mio_data.s.psn (p_channel));
	else
	     asn_valid =
		(mio_data.r.asn (p_channel) <= p_asn
		| p_asn <= mio_data.s.psn (p_channel));

	if ^asn_valid then
	     return (False);

/* Save the new acknowledgement sequence number */

	mio_data.r.asn (p_channel) = p_asn;

/* Generate a wakeup to something which may be waiting for a send queue to
   open (which is done when an ack is received) */

	call ws_channel_$wait_wakeup (mio_data_ptr,
	     addr (mio_data.channel_info.packet_transmitter));

/* Indicate packet was valid */

	return (True);

     end accept_ack;

/**/

/* *** Procedure: approve_packet - Internal proc for ws_packet_receiver_  *** */

approve_packet:
     proc (p_packet_ptr, p_packet_len);


/* PROCEDURE FUNCTION

Approve a packet.  If the packet appears to valid, dispatch it to the
appropriate parser for further analysis, otherwise reject it.
*/

/* NOTES
*/

/* INPUT PARAMETERS */
dcl p_packet_len	       fixed bin (21) parameter;  /* Packet length */
dcl p_packet_ptr	       ptr parameter;	    /* Packet to be approved */

/* OUTPUT PARAMETERS */

/* MISC VARIABLES */
dcl type		       fixed bin (8);	    /* Type character */
dcl chkidx	       fixed bin;		    /* Index of chkcrc character */
dcl lenidx	       fixed bin;		    /* Index of chklen character */

/* STRUCTURES */
dcl 01 packet	       based (p_packet_ptr),
       02 length	       fixed bin (21) aligned,
       02 data	       char (p_packet_len) unal;

/* INITIALIZATION */


/* MAIN */

/* If packet is too short or too long, reject it. */

	if packet.length < MinPktLen | packet.length > MaxPktLen then do;
	     if mio_data.debug_iocb_ptr ^= null then
		call ws_debug_$packet ("---R:PKT/SIZ-->",
		     addr (packet.data), packet.length,
		     mio_data.debug_iocb_ptr);
	     return;
	end;

/* If check-length is incorrect, reject it */

	lenidx = packet.length - EOPLen - ChkLen - LenLen + 1;
	if ws_tools_$check_length (packet.length + mio_data.r.esc_count)
	     ^= substr (packet.data, lenidx, LenLen)
	then do;
	     if mio_data.debug_iocb_ptr ^= null then
		call ws_debug_$packet ("---R:PKT/LEN-->",
		     addr (packet.data), packet.length,
		     mio_data.debug_iocb_ptr);
	     return;
	end;

/* If CRC is incorrect, reject packet. */

	chkidx = lenidx + ChkLen;
	if check_crc (addr (packet.data), chkidx - 1)
	     ^= substr (packet.data, chkidx, ChkLen)
	then do;
	     if mio_data.debug_iocb_ptr ^= null then
		call ws_debug_$packet ("---R:PKT/CRC-->",
		     addr (packet.data), packet.length,
		     mio_data.debug_iocb_ptr);
	     return;
	end;

/* If packet type is valid, dispatch accordingly; else reject packet. */

	type = rank (substr (packet.data, SOPLen + 1, 1));
	if ^mio_data.rs_pending (1) & ^mio_data.rs_pending (2) then do;
	     if DatOff <= type & type < DatOff + DatCnt then
		call parse_data (p_packet_ptr, p_packet_len);
	     else if AckOff <= type & type < AckOff + AckCnt then
		call parse_ack (p_packet_ptr, p_packet_len);
	     else if NakOff <= type & type < NakOff + NakCnt then
		call parse_nak (p_packet_ptr, p_packet_len);
	     else if BrkOff <= type & type < BrkOff + BrkCnt then
		call parse_break (p_packet_ptr, p_packet_len);
	     else if RstOff <= type & type < RstOff + RstCnt then
		call parse_reset (p_packet_ptr, p_packet_len);
	     else if FastDis = type then
		call remote_disconnect (True);
	     else do;
		call ws_debug_$packet ("---R:TYPE-->",
		     addr (packet.data), packet.length,
		     mio_data.debug_iocb_ptr);
	     end;
	end;
	else if RstOff <= type & type < RstOff + RstCnt then
	     call parse_reset (p_packet_ptr, p_packet_len);

     end approve_packet;

/**/

/* *** Procedure: check_crc - Internal proc for ws_packet_receiver_  *** */

check_crc:
     proc (p_packet_ptr, p_packet_len) returns (char (1));


/* PROCEDURE FUNCTION

Calculate the printable ascii character of the CRC that should have been used
on this packet data
*/

/* NOTES
*/

/* RETURNS

The desired CRC character.
*/

/* INPUT PARAMETERS */
dcl p_packet_ptr	       ptr parameter;	    /* Packet */
dcl p_packet_len	       fixed bin (21) parameter;  /* length of packet */

/* MISC VARIABLES */
dcl string	       (0:p_packet_len - 1) char (1) unal based (p_packet_ptr); /* String overlay */
dcl i		       fixed bin;
dcl crc		       fixed bin;		    /* Accumulated CRC */

/* INITIALIZATION */

/* MAIN */

/* Sum the ranks of the characters in the string. */

	crc = INIT_CRC;
	do i = 0 to p_packet_len - 1;
	     crc = ws_tools_$crc_char (string (i), crc);
	end;

/* Return a printable ASCII character between ' ' and '~'. */

	return (byte (crc + 32));

     end check_crc;

/**/

/* *** Procedure: get_channel - Internal proc for ws_packet_receiver_  *** */

get_channel:
     proc (p_channel_id, p_type, p_handler, p_code);


/* PROCEDURE FUNCTION

Get ahold of a channel of the specified type.
*/

/* NOTES
*/

/* INPUT PARAMETERS */
dcl p_handler	       variable entry (ptr);	    /* Call handler */
dcl p_type	       fixed bin parameter;	    /* Channel type */

/* OUTPUT PARAMETERS */
dcl p_channel_id	       fixed bin (71) aligned parameter; /* Channel gotten */
dcl p_code	       fixed bin (35) parameter;

/* MISC VARIABLES */

/* STRUCTURES */
dcl 01 ipc_arg	       like ipc_create_arg_structure aligned automatic;

/* INITIALIZATION */
	p_code = 0;

/* MAIN */

	ipc_arg.version = ipc_create_arg_structure_v1;
	ipc_arg.channel_type = p_type;
	ipc_arg.call_entry = ws_packet_receiver_;
	ipc_arg.call_data_ptr = null;
	ipc_arg.call_priority = 0;
	call ipc_$create_event_channel (addr (ipc_arg), p_channel_id,
	     p_code);

     end get_channel;

/**/

/* *** Procedure: handle_fg_break - Internal proc for ws_packet_receiver_  *** */

handle_fg_break:
     proc ();


/* PROCEDURE FUNCTION

Perform the necessary functions to signal a break on the foreground channel.
*/

/* NOTES
*/

/* INPUT PARAMETERS */

/* OUTPUT PARAMETERS */

/* MISC VARIABLES */
dcl message	       char (5);		    /* FG_BREAK data */

/* STRUCTURES */

/* INITIALIZATION */
	mio_data.switches.brk_pending = False;
	message = "BRK  ";

/* MAIN */

/* If quits have been disabled, return */

	if ^mio_data.switches.quit_enable then
	     return;

/* Send a data message to the remote with the FG_BREAK minor cap number */

	call ws_packet_transmitter_$data (mio_data_ptr, FG, addr (message),
	     convert (fixedbin21, MinPktLen), FG_BREAK);

/* Clear user buffer and signal quit */

	mio_data.user_input.out = mio_data.user_input.in;
	call signal_ ("quit", null (), null (), null ());

     end handle_fg_break;

/**/

/* *** Procedure: modem_reader - Internal proc for ws_packet_receiver_  *** */

modem_reader:
     proc ();


/* PROCEDURE FUNCTION

Read data from tty_.
*/

/* NOTES
*/

/* INPUT PARAMETERS */

/* OUTPUT PARAMETERS */

/* MISC VARIABLES */
dcl line_status_info       bit (72) aligned;
dcl input_buffer	       (1024) char (1);	    /* Input packet */
dcl i		       fixed bin (21);
dcl n_chars_read	       fixed bin (21);
dcl code		       fixed bin (35);

/* STRUCTURES */
dcl 01 read_status_info    like tty_read_status_info aligned automatic;

/* INITIALIZATION */

/* MAIN */

/* See if there really is data */

	code = error_table_$line_status_pending;
	do while (code = error_table_$line_status_pending);
	     call iox_$control (mio_data.iocb_ptr, "read_status",
		addr (read_status_info), code);
	     if code = error_table_$line_status_pending then
		call iox_$control (mio_data.iocb_ptr, "line_status",
		     addr (line_status_info), (0));
	end;
	if code ^= 0 then
	     signal mowse_io_error;

/* NO, then lets forget it */

	if ^read_status_info.input_pending then
	     return;

/* Yes, then process it a character at a time */

	call iox_$get_chars (mio_data.iocb_ptr, addr (input_buffer),
	     hbound (input_buffer, 1), n_chars_read, code);
	if code ^= 0 then
	     signal mowse_io_error;

/* Process each of the characters received */

	do i = 1 to n_chars_read;
	     call receive_char (input_buffer (i));
	end;

     end modem_reader;

/**/

/* *** Procedure: parse_ack - Internal proc for ws_packet_receiver_  *** */

parse_ack:
     proc (p_packet_ptr, p_packet_len);


/* PROCEDURE FUNCTION

Parse an Ack-packet.  If the packet is valid, flow control information is
updated accordingly
*/

/* NOTES
*/

/* INPUT PARAMETERS */
dcl p_packet_ptr	       ptr parameter;	    /* Packet */
dcl p_packet_len	       fixed bin (21) parameter;  /* Length of packet */

/* OUTPUT PARAMETERS */

/* MISC VARIABLES */
dcl channel	       fixed bin;		    /* Channel number */
dcl asn		       fixed bin;		    /* Acknowledge sequence number */
dcl fields	       fixed bin;		    /* Packet type */

/* STRUCTURES */
dcl 01 packet	       based (p_packet_ptr),
       02 length	       fixed bin (21) aligned,
       02 data	       char (p_packet_len) unal;

/* INITIALIZATION */

/* MAIN */

/* If packet length incorrect, reject packet. */

	if p_packet_len ^= MinPktLen then
	     return;

/* Extract the acknowledgement sequence number and the channel number. */

	fields = rank (substr (packet.data, SOPLen + 1, 1)) - AckOff;
	asn = mod (fields, SeqCnt);
	channel = ws_tools_$ars (fields, SeqFld);

/* Accept the ack sequence number */

	if ^accept_ack (channel, asn) then do;
	     if mio_data.debug_iocb_ptr ^= null then
		call ws_debug_$packet ("---R:ACK/PSN-->",
		     addr (packet.data), packet.length,
		     mio_data.debug_iocb_ptr);

	     return;
	end;

	if mio_data.debug_iocb_ptr ^= null then
	     call ws_debug_$packet ("R:ACK---->", addr (packet.data),
		packet.length, mio_data.debug_iocb_ptr);

     end parse_ack;

/**/

/* *** Procedure: parse_break - Internal proc for ws_packet_receiver_  *** */

parse_break:
     proc (p_packet_ptr, p_packet_len);


/* PROCEDURE FUNCTION

Parse a break packet and perform the associated functions.
*/

/* NOTES
*/

/* INPUT PARAMETERS */
dcl p_packet_ptr	       ptr parameter;	    /* Packet */
dcl p_packet_len	       fixed bin (21) parameter;  /* Packet length */

/* OUTPUT PARAMETERS */

/* MISC VARIABLES */

/* STRUCTURES */
dcl 01 packet	       based (p_packet_ptr),
       02 length	       fixed bin (21) aligned,
       02 data	       char (p_packet_len) unal;

/* INITIALIZATION */

/* MAIN */

/* If a foreground break */

	if rank (substr (packet.data, SOPLen + 1, 1)) = FGBrk + Request
	then do;
	     if mio_data.debug_iocb_ptr ^= null then
		call ws_debug_$packet ("R:FGBrk-->",
		     addr (packet.data), packet.length,
		     mio_data.debug_iocb_ptr);

/* - Send the confirmation */

	     call ws_timer_$reset_break ();
	     call ws_packet_transmitter_$supervisory (mio_data_ptr,
		byte (FGBrk + Confirm));

/* - Set the appropriate flags indicating a break is pending */

	     mio_data.br_pending = True;
	     mio_data.brk_pending = True;
	end;

/* Else if receiving FG break confirmation confirmation
     - clear pending flag */

	else if rank (substr (packet.data, SOPLen + 1, 1)) = FGBrk + Confirm
	then do;
	     mio_data.br_pending = False;
	     if mio_data.debug_iocb_ptr ^= null then
		call ws_debug_$packet ("R:FGBrk-C>",
		     addr (packet.data), packet.length,
		     mio_data.debug_iocb_ptr);
	end;

/* Else if receiving Disconnect confirmation */

	else if rank (substr (packet.data, SOPLen + 1, 1)) = DisCon + Confirm
	then do;
	     if mio_data.debug_iocb_ptr ^= null then
		call ws_debug_$packet ("R:DisCn-C>",
		     addr (packet.data), packet.length,
		     mio_data.debug_iocb_ptr);

/* - Set flag */

	     mio_data.ds_pending (1) = False;

/* - If remote initiated, then handle accordingly */

	     if mio_data.ds_pending (2) then
		call remote_disconnect (False);
	end;

/* Else if PC originated disconnect */

	else if rank (substr (packet.data, SOPLen + 1, 1)) = DisCon + Request
	then do;

	     if mio_data.debug_iocb_ptr ^= null then
		call ws_debug_$packet ("R:DisCon-R-->",
		     addr (packet.data), packet.length,
		     mio_data.debug_iocb_ptr);

/* - Set flag and send a confirmation */

	     mio_data.ds_pending (2) = True;
	     call ws_timer_$reset_disconnect ();
	     call ws_packet_transmitter_$supervisory (mio_data_ptr,
		byte (DisCon + Confirm));
	end;

     end parse_break;

/**/

/* *** Procedure: parse_data - Internal proc for ws_packet_receiver_  *** */

parse_data:
     proc (p_packet_ptr, p_packet_len);


/* PROCEDURE FUNCTION

Parse a data packet.  If the packet is valid, the data is stored in the
receive data queue for extraction at an appropriate time.
*/

/* NOTES
*/

/* INPUT PARAMETERS */
dcl p_packet_ptr	       ptr parameter;	    /* Packet */
dcl p_packet_len	       fixed bin (21) parameter;  /* Length of packet */

/* OUTPUT PARAMETERS */

/* MISC VARIABLES */
dcl data_len	       fixed bin (21);	    /* Length of data */
dcl psn		       fixed bin;		    /* Packet sequence number */
dcl asn		       fixed bin;		    /* Ack sequence number */
dcl channel	       fixed bin;		    /* Channel ID of packet */
dcl fields	       fixed bin;		    /* Packet type */

/* STRUCTURES */
dcl 01 packet	       based (p_packet_ptr) unal,
       02 length	       fixed bin (21) aligned,
       02 data	       char (p_packet_len) unal;

/* INITIALIZATION */

/* MAIN */

/* Extract the acknowledgement sequence number, packet sequence number and
   channel number from the type char. */

	fields = rank (substr (packet.data, SOPLen + 1, 1)) - DatOff;
	asn = mod (fields, SeqCnt);
	psn = mod (ws_tools_$ars (fields, SeqFld), SeqCnt);
	channel = ws_tools_$ars (fields, SeqFld + SeqFld);

/* Accept the acknowledge sequence number */

	if ^accept_ack (channel, asn) then do;
	     if mio_data.debug_iocb_ptr ^= null then
		call ws_debug_$packet ("---R:DAT/ASN-->",
		     addr (packet.data), packet.length,
		     mio_data.debug_iocb_ptr);

	     return;
	end;

/* If we are disconnecting, then ignore the data */

	if mio_data.ds_pending (1) | mio_data.ds_pending (2) then
	     return;

/* If the send sequence number is not the one we expect, send a Nak-packet,
   (unless one has already been sent) and ignore this packet. */

	if psn ^= mio_data.r.psn (channel) then do;
	     if mio_data.debug_iocb_ptr ^= null then
		call ws_debug_$packet ("---R:DAT/PSN-->",
		     addr (packet.data), packet.length,
		     mio_data.debug_iocb_ptr);

	     if ^mio_data.r.ignoring (channel) then do;
		call ws_packet_transmitter_$nak (channel, mio_data_ptr);
		mio_data.r.ignoring (channel) = True;
	     end;

	     return;
	end;

/* Accept the data. */

	data_len = packet.length - MinPktLen;
	mio_data.r.dat (channel, psn) =
	     substr (packet.data, SOPLen + TypLen + 1, data_len);
	mio_data.r.ignoring (channel) = False;
	mio_data.r.psn (channel) = mod (psn + 1, SeqCnt);
	if mio_data.debug_iocb_ptr ^= null then
	     call ws_debug_$packet ("R:DAT---->", addr (packet.data),
		packet.length, mio_data.debug_iocb_ptr);

     end parse_data;

/**/

/* *** Procedure: parse_nak - Internal proc for ws_packet_receiver_  *** */

parse_nak:
     proc (p_packet_ptr, p_packet_len);


/* PROCEDURE FUNCTION

Parse a Nak-packet.  If the packet is valid, any data packets that have been
sent but have not been acknowledged by this Nak are resent.
*/

/* NOTES
*/

/* INPUT PARAMETERS */
dcl p_packet_ptr	       ptr parameter;	    /* Packet */
dcl p_packet_len	       fixed bin (21) parameter;  /* Packet_length */

/* OUTPUT PARAMETERS */

/* MISC VARIABLES */
dcl channel	       fixed bin;		    /* Channel ID */
dcl asn		       fixed bin;		    /* Acknowledge sequence number */
dcl fields	       fixed bin;		    /* Packet type */

/* STRUCTURES */
dcl 01 packet	       based (p_packet_ptr),
       02 length	       fixed bin (21) aligned,
       02 data	       char (p_packet_len) unal;

/* INITIALIZATION */

/* MAIN */

/* If packet length is incorrect, reject the packet. */

	if packet.length ^= MinPktLen then
	     return;

/* Extract field information (sequence number, channel number, etc.) */

	fields = rank (substr (packet.data, SOPLen + 1, 1)) - NakOff;
	asn = mod (fields, SeqCnt);
	channel = ws_tools_$ars (fields, SeqFld);

/* Accept the acked sequence number in the nak packet */

	if ^accept_ack (channel, asn) then do;
	     if mio_data.debug_iocb_ptr ^= null then
		call ws_debug_$packet ("---R:NAK/PSN-->",
		     addr (packet.data), packet.length,
		     mio_data.debug_iocb_ptr);
	     return;
	end;

	if mio_data.debug_iocb_ptr ^= null then
	     call ws_debug_$packet ("R:NAK---->", addr (packet.data),
		packet.length, mio_data.debug_iocb_ptr);

/* Resend any data in the send data queue. */

	call ws_packet_transmitter_$resend (mio_data_ptr, channel);

     end parse_nak;

/**/

/* *** Procedure: parse_reset - Internal proc for ws_packet_receiver_  *** */

parse_reset:
     proc (p_packet_ptr, p_packet_len);


/* PROCEDURE FUNCTION

Parse a reset packet and handle accordingly.
*/

/* NOTES
*/

/* INPUT PARAMETERS */
dcl p_packet_ptr	       ptr parameter;	    /* Packet */
dcl p_packet_len	       fixed bin (21) parameter;  /* Packet length */

/* OUTPUT PARAMETERS */

/* MISC VARIABLES */

/* STRUCTURES */
dcl 01 packet	       based (p_packet_ptr),
       02 length	       fixed bin (21) aligned,
       02 data	       char (p_packet_len) unal;

/* INITIALIZATION */

/* MAIN */

/* If in process of disconnecting, then ignore reset */

	if mio_data.ds_pending (1) | mio_data.ds_pending (2) then
	     return;

/* If PC requested reset: reset and send confirmation */

	if rank (substr (packet.data, SOPLen + 1, 1)) = RstOff + Request
	then do;
	     if mio_data.debug_iocb_ptr ^= null then
		call ws_debug_$packet ("R:RST-R-->", addr (packet.data),
		     packet.length, mio_data.debug_iocb_ptr);

	     mio_data.rs_pending (2) = True;
	     call ws_tools_$reset_data (mio_data_ptr);
	     mio_data.r.pktin = 1;
	     call ws_packet_transmitter_$supervisory (mio_data_ptr,
		byte (RstOff + Confirm));
	end;

/* Else if Confirmation */

	else if rank (substr (packet.data, SOPLen + 1, 1)) = RstOff + Confirm
	then do;
	     if mio_data.debug_iocb_ptr ^= null then
		call ws_debug_$packet ("R:RST-C-->", addr (packet.data),
		     packet.length, mio_data.debug_iocb_ptr);

/* - Send the confirmation */

	     if mio_data.rs_pending (1) then
		call ws_packet_transmitter_$supervisory (mio_data_ptr,
		     byte (RstOff + Confirm));
	     mio_data.rs_pending (*) = False;
	end;

     end parse_reset;

/**/

/* *** Procedure: prime_tty - Internal proc for ws_packet_receiver_  *** */

prime_tty:
     proc () returns (bit (1));


/* PROCEDURE FUNCTION

Perform a read status control order to tty_ in order to pprime it for the
next event.
*/

/* NOTES
*/

/* INPUT PARAMETERS */

/* OUTPUT PARAMETERS */

/* MISC VARIABLES */

/* STRUCTURES */
dcl 01 read_status_info    like tty_read_status_info aligned automatic;

/* INITIALIZATION */

/* MAIN */

	call iox_$control (mio_data.iocb_ptr, "read_status",
	     addr (read_status_info), (0));
	return (read_status_info.input_pending);

     end prime_tty;

/**/

/* *** Procedure: receive_char - Internal proc for ws_packet_receiver_  *** */

receive_char:
     proc (p_chr);


/* PROCEDURE FUNCTION

To receive the next character detected by the interrupt handler for input from
the remote.  If the character is valid, it is added to the packet currently
being assembled.
*/

/* NOTES
*/

/* INPUT PARAMETERS */
dcl p_chr		       char (1) parameter;	    /* character received */

/* OUTPUT PARAMETERS */

/* MISC VARIABLES */
dcl nextin	       fixed bin;		    /* Next packet in */
dcl test_ds	       (2) bit (1);		    /* Testing disconnect status */
dcl packet	       char (MaxDatLen) var based (packet_ptr); /* Packet to be built */
dcl packet_ptr	       ptr;		    /* Building packet pointer */

/* STRUCTURES */

/* INITIALIZATION */

/* MAIN */

/* Assemble the packet in the next slot of the receive packet queue. */

	packet_ptr = addr (mio_data.r.pkt (mio_data.r.pktin));

/* If the received char is the SOP char, start a new packet. */

	if p_chr = mio_data.r.sop then do;
	     mio_data.r.esckey = "000"b3;
	     packet = p_chr;
	end;

/* Else if we are not assembling a packet, discard the received char. */

	else if length (packet) = 0 then
	     return;

/* Else if the received char is the EOP char, append it to the packet.  If
   there is room in the received packet queue, make the packet visible (by
   updating the "in" pointer); otherwise flush the packet. */

	else if p_chr = mio_data.r.eop then do;
	     packet = packet || p_chr;

	     if mio_data.r.pktin < RQS then
		nextin = mio_data.r.pktin + 1;
	     else
		nextin = 0;

	     if nextin ^= mio_data.r.pktout then do;
		mio_data.r.pktin = nextin;
		mio_data.r.pkt (nextin) = "";
	     end;
	     else
		packet = "";
	end;

/* Else append the character (or what it stands for if it was preceded
   by an escape character) to the buffer, unless it is an escape
   character.  If this fills the packet (in which case there will be
   no room for the EOP character), flush the packet. */

	else do;
	     if mio_data.r.esckey ^= "000"b3 then do;
		unspec (p_chr) =
		     bool (unspec (p_chr), mio_data.r.esckey, XOR);
		mio_data.r.esckey = "000"b3;
	     end;
	     else if p_chr = mio_data.r.esc (0) then do;
		mio_data.r.esc_count = mio_data.r.esc_count + 1;
		mio_data.r.esckey = "100"b3;
	     end;
	     else if p_chr = mio_data.r.esc (1) then do;
		mio_data.r.esc_count = mio_data.r.esc_count + 1;
		mio_data.r.esckey = "200"b3;
	     end;
	     else if p_chr = mio_data.r.esc (2) then do;
		mio_data.r.esc_count = mio_data.r.esc_count + 1;
		mio_data.r.esckey = "300"b3;
	     end;

	     if mio_data.r.esckey = "000"b3 then do;
		if length (packet) < MaxPktLen then
		     packet = packet || p_chr;
		else
		     packet = "";
	     end;
	end;

/* Approve completed packets and handle accordingly */

	do while (mio_data.r.pktin ^= mio_data.r.pktout);
	     test_ds = mio_data.ds_pending;
	     call approve_packet (addr (mio_data.r.pkt (mio_data.r.pktout)),
		length (mio_data.r.pkt (mio_data.r.pktout)));
	     mio_data.r.esc_count = 0;
	     if mio_data.r.pktout < RQS then
		mio_data.r.pktout = mio_data.r.pktout + 1;
	     else
		mio_data.r.pktout = 0;
	     if test_ds (2) then
		call remote_disconnect (False);
	end;

     end receive_char;

/**/

/* *** Procedure: receive_fg - Internal proc for ws_packet_receiver_  *** */

receive_fg:
     proc ();


/* PROCEDURE FUNCTION

Extract all Foreground data from the protocol queues and insert into
the user_input queues for extraction through iox_$get_(line chars).
*/

/* NOTES
*/

/* INPUT PARAMETERS */

/* OUTPUT PARAMETERS */

/* MISC VARIABLES */
dcl fixedbin21	       fixed bin (21) based;
dcl data		       (MaxDatLen) char (1);	    /* Message buffer */
dcl i		       fixed bin (21);
dcl data_len	       fixed bin (21);	    /* Message length */

/* STRUCTURES */

/* INITIALIZATION */

/* MAIN */

/* Initiate the processing FG loop, if no data then return */

	data_len
	     = ws_tools_$getdat (mio_data_ptr, FG, addr (data),
	     convert (fixedbin21, MaxDatLen));

/* Process pending foreground channel packets */

	do while (data_len > 0);
	     do i = 2 to data_len;
		mio_data.user_input.queue (mio_data.user_input.in)
		     = data (i);

		if mio_data.user_input.in
		     < hbound (mio_data.user_input.queue, 1)
		     then
		     mio_data.user_input.in = mio_data.user_input.in + 1;
		else
		     mio_data.user_input.in = 0;  /* hcom 2. */
	     end;

	     data_len
		= ws_tools_$getdat (mio_data_ptr, FG, addr (data),
		convert (fixedbin21, MaxDatLen));
	end;

/* Wakeup blocked procedure on user_input */

	call ws_channel_$wait_wakeup (mio_data_ptr,
	     addr (mio_data.channel_info.user_input));

/* MF - phx21215 - Send a signal on the foreground event channel that data
 * has arrived
 */
	call hcs_$wakeup (mio_data.channel_info.process_id,
	     mio_data.channel_info.foreground.channel, 0, (0));

     end receive_fg;

/**/

/* *** Procedure: remote_disconnect - Internal proc for ws_packet_receiver_  *** */

remote_disconnect:
     proc (p_fast);


/* PROCEDURE FUNCTION

This is a null routine which will be used to implement mowse_io_ detachment
at the request of the PC.
*/

/* NOTES
*/

/* INPUT PARAMETERS */
dcl p_fast	       bit (1) parameter;	    /* Fast (non-confirmed) request */

/* OUTPUT PARAMETERS */

/* MISC VARIABLES */

/* STRUCTURES */

/* INITIALIZATION */

/* MAIN */

	mio_data.ds_pending (*) = False;

     end remote_disconnect;

/**/

/* *** Procedure: reset_wakeup - Internal proc for ws_packet_receiver_  *** */

reset_wakeup:
     proc (p_code);


/* PROCEDURE FUNCTION

Reset the wakeup mechanism for the packet_receiver.
*/

/* NOTES
*/

/* INPUT PARAMETERS */

/* OUTPUT PARAMETERS */
dcl p_code	       fixed bin (35) parameter;

/* MISC VARIABLES */
dcl input_pending	       bit (1);		    /* Data arrived */
dcl tty_channel	       fixed bin (71) aligned;    /* tty_channel to install */
dcl mask		       bit (36) aligned;

/* STRUCTURES */
dcl 01 wake_info	       like swt_info aligned automatic;

/* INITIALIZATION */
	p_code = 0;

/* If we came in from a sus_ signal, then get the heck out */

	if mio_data.sus_data.activated then
	     return;

/* Have we really initialized ? */

	if mio_data.channel_info.packet_receiver.channel = 0 then
	     return;

/* Mask the world according to Multics */

	call hcs_$set_ips_mask (""b, mask);
	call ipc_$mask_ev_calls (p_code);
	if p_code ^= 0 then
	     goto EXIT_RESET_WAKEUP;

/* MAIN */

/* Turn wakeups off */

	call iox_$modes (mio_data.iocb_ptr, "^wake_tbl", "", p_code);
	if p_code ^= 0 then
	     goto EXIT_RESET_WAKEUP;

	wake_info.version = swt_info_version_1;
	wake_info.new_table = mio_data.channel_info.wake_info;
	call iox_$control (mio_data.iocb_ptr, "set_wakeup_table",
	     addr (wake_info), p_code);
	if p_code ^= 0 then
	     goto EXIT_RESET_WAKEUP_MODES;

/* Restore the tty event channel with a fast channel.  If can't get a
   fast channel, then try for a wait channel */

	call get_channel (tty_channel, FAST_EVENT_CHANNEL_TYPE,
	     null_entry_, p_code);
	if p_code ^= 0 then
	     call get_channel (tty_channel, WAIT_EVENT_CHANNEL_TYPE,
		null_entry_, p_code);

	call iox_$control (mio_data.iocb_ptr, "set_event_channel",
	     addr (tty_channel), p_code);
	if p_code ^= 0 then
	     goto EXIT_RESET_WAKEUP_RESTORE;

/* Delete the old channel */

	call ipc_$delete_ev_chn (
	     mio_data.channel_info.packet_receiver.channel, (0));
	mio_data.channel_info.packet_receiver.channel = 0;
	goto EXIT_RESET_WAKEUP;

EXIT_RESET_WAKEUP_RESTORE:

	wake_info.new_table.wake_map (*) = "0"b;
	wake_info.new_table.wake_map (rank (mio_data.r.eop)) = "1"b;
	call iox_$control (mio_data.iocb_ptr, "set_wakeup_table",
	     addr (wake_info), (0));

EXIT_RESET_WAKEUP_MODES:

	call iox_$modes (mio_data.iocb_ptr, "wake_tbl", "", p_code);

EXIT_RESET_WAKEUP:

	call ipc_$unmask_ev_calls ((0));
	call hcs_$reset_ips_mask (mask, mask);

/* tty_ needs to be primed due to the event channel change */

	input_pending = prime_tty ();

     end reset_wakeup;

/**/

/* *** Procedure: scheduler - Internal proc for ws_packet_receiver_  *** */

scheduler:
     proc ();


/* PROCEDURE FUNCTION

Process any received data.
*/

/* NOTES
*/

/* INPUT PARAMETERS */

/* OUTPUT PARAMETERS */

/* MISC VARIABLES */

/* STRUCTURES */

/* INITIALIZATION */

/* MAIN */

/* Check for input from the PC on the foreground channel */

	if ^mio_data.task.active (FG_task) then do;
	     on cleanup mio_data.task.active (FG_task) = Idle;
	     mio_data.task.active (FG_task) = ^Idle;
	     call receive_fg ();
	     mio_data.task.active (FG_task) = Idle;
	     revert cleanup;
	end;

/* Check for input on the background channel, local or remote */

	if ^mio_data.task.active (BG_task) then do;
	     if mio_data.l_dat (BG).out_ptr ^= null
		| mio_data.r.psn (BG) ^= mio_data.s.nasn (BG)
		then
		call ws_channel_$call_wakeup (mio_data_ptr,
		     mio_data.channel_info.packet_dispatcher.async_channel);
	end;

/* Process any break requests */

	if ^mio_data.task.active (BG_task) & mio_data.switches.brk_pending then do;
	     call handle_fg_break ();
	end;

     end scheduler;

/**/

/* *** Procedure: setup_wakeup - Internal proc for ws_packet_receiver_  *** */

setup_wakeup:
     proc (p_code);


/* PROCEDURE FUNCTION

Set up the appropriate functions to have the packet_receiver_ awaken properly.
*/

/* NOTES
*/

/* INPUT PARAMETERS */

/* OUTPUT PARAMETERS */
dcl p_code	       fixed bin (35) parameter;

/* MISC VARIABLES */
dcl input_pending	       bit (1);		    /* Data arrived from PC */
dcl tty_channel	       fixed bin (71) aligned;    /* Old tty channel */
dcl mask		       bit (36) aligned;	    /* IPS mask */

/* STRUCTURES */
dcl 01 wake_info	       like swt_info aligned automatic;

/* INITIALIZATION */
	p_code = 0;
	call hcs_$set_ips_mask (""b, mask);
	call ipc_$mask_ev_calls (p_code);
	if p_code ^= 0 then
	     goto EXIT_SETUP_WAKEUP;

	mio_data.channel_info.packet_receiver.channel = 0;
	call iox_$control (mio_data.iocb_ptr, "get_event_channel",
	     addr (tty_channel), (0));

/* MAIN */

/* Create an event call channel and attach it so that we get the wakeups
   on the call channel */

	call get_channel (mio_data.channel_info.packet_receiver.channel,
	     ASYNC_CALL_EVENT_CHANNEL_TYPE, ws_packet_receiver_, p_code);
	if p_code ^= 0 then
	     goto EXIT_SETUP_WAKEUP;

	call iox_$control (mio_data.iocb_ptr, "set_event_channel",
	     addr (mio_data.channel_info.packet_receiver.channel), p_code);
	if p_code ^= 0 then
	     goto EXIT_SETUP_WAKEUP_DELETE;

/* Delete the old tty_channel as it is no longer valid */

	call ipc_$delete_ev_chn (tty_channel, (0));

/* Set the wakeup table to be the EOP character */

	call iox_$modes (mio_data.iocb_ptr, "^wake_tbl", "", p_code);
	if p_code ^= 0 then
	     goto EXIT_SETUP_WAKEUP_RESTORE;

	wake_info.version = swt_info_version_1;
	wake_info.new_table.wake_map (*) = "0"b;
	wake_info.new_table.wake_map (rank (mio_data.r.eop)) = "1"b;
	wake_info.new_table.mbz = ""b;
	call iox_$control (mio_data.iocb_ptr, "set_wakeup_table",
	     addr (wake_info), p_code);
	mio_data.channel_info.wake_info = wake_info.old_table;
	if p_code ^= 0 then
	     goto EXIT_SETUP_WAKEUP_RESTORE;

	call iox_$modes (mio_data.iocb_ptr, "wake_tbl", "", p_code);
	call iox_$modes (mio_data.default_iocb_ptr, "wake_tbl", "", (0));
	if p_code = 0 then
	     goto EXIT_SETUP_WAKEUP;

EXIT_SETUP_WAKEUP_MODES:

	call iox_$modes (mio_data.iocb_ptr, "^wake_tbl", "", (0));
	call iox_$modes (mio_data.default_iocb_ptr, "^wake_tbl", "", (0));

EXIT_SETUP_WAKEUP_RESTORE:

	call get_channel (tty_channel, FAST_EVENT_CHANNEL_TYPE,
	     null_entry_, (0));
	call iox_$control (mio_data.iocb_ptr, "set_event_channel",
	     addr (tty_channel), (0));

EXIT_SETUP_WAKEUP_DELETE:

	call ipc_$delete_ev_chn (
	     mio_data.channel_info.packet_receiver.channel, (0));
	mio_data.channel_info.packet_receiver.channel = 0;

EXIT_SETUP_WAKEUP:

/* Turn events back on */

	call ipc_$unmask_ev_calls ((0));
	call hcs_$reset_ips_mask (mask, mask);

/* tty_ needs to be primed due to the event channel change */

	input_pending = prime_tty ();

     end setup_wakeup;

/**/

%page;

/* INCLUDE FILES */
%include mowse;
%include mowse_messages;
%include mowse_info;
%include ipc_create_arg;
%include set_wakeup_table_info;
%include static_handlers;
%include condition_info;
%include mowse_io_data;
%include mowse_io_constants;
%include tty_read_status_info;

     end;
