" **************************************************************
" *                                                            *
" * Copyright, (C) Massachusetts Institute of Technology, 1973 *
" *                                                            *
" **************************************************************
"		LISP Operators

" these operators provide run time support for compiled lisp functions
" they are called by tspbp through pointers in the lisp stack header

" Written by D A Moon 21 Aug 72
" modified 15 Oct 72 by DAM for some evidently secret reason
" modified 74.05.17 by DAM for "new" arrays and to speed up some oprs by using more pointer regs
" modified 74.12.06 by DAM for external arrays



	macro	enter_pl1_code
	epplp	ab|system_lp,*
	stx7	lisp_static_vars_$unmkd_ptr+1
	spriap	lisp_static_vars_$stack_ptr
	stc1	ab|in_pl1_code
	ife	&1,push
	push	&2
	eppbp	lisp_subr_tv_$..lisp..
	spribp	sp|stack_frame.entry_ptr
	ifend
	&end

	macro	exit_pl1_code
	ife	&1,pop
	eppbp	sp|0
	inhibit	on
	spribp	sb|stack_header.stack_end_ptr
	eppsp	sp|stack_frame.prev_sp,*
	inhibit	off
	ifend
	epbpab	lisp_static_vars_$unmkd_ptr,*
	eppap	lisp_static_vars_$stack_ptr,*
	ldx7	lisp_static_vars_$unmkd_ptr+1
	stz	ab|in_pl1_code
	&end

	equ	his_lp,-4			where on unmkd pdl caller's lp kept
	equ	his_bp,-2			where on unmkd pdl caller's
					" bp (= return addr) is kept
	equ	form,-8			dcl from lisp_
	equ	fcn,-6
	equ	argl,-4
	equ	plist,-2
	include	lisp_unmkd_pdl
	include	lisp_stack_seg
	include	lisp_array_fmt
	include	lisp_name_codes
	include	lisp_object_types
	include	stack_header
	include	stack_frame


" routine to set up operator pointers in the stack header
" called during initialization of the lisp environment,
" every time the 'lisp' command is issued.

	entry	init

init:	getlp
	epbpab	<lisp_static_vars_>|[unmkd_ptr],*	-> stack header
	ldaq	gensym_init-*,ic
	staq	ab|gensym_data		" initialize data for gensym function.
	ldaq	fault_tag_3_number_1-*,ic	kill old array store pointer
	staq	ab|array_pointer
	eppbp	array_reference_op-*,ic
	spribp	ab|array_operator
	eppbp	dead_array_reference_op-*,ic
	spribp	ab|dead_array_operator
	eppbp	array_link_snap_op-*,ic
	spribp	ab|array_link_snap_opr
	eppbp	store_op-*,ic
	spribp	ab|store_operator
	eppbp	floating_store_op-*,ic
	spribp	ab|floating_store_operator
	ldaq	fault_tag_3_number_2-*,ic
	staq	ab|array_info_for_store
	eppbp	bind-*,ic
	spribp	ab|bind_op
	eppbp	unbind-*,ic
	spribp	ab|unbind_op
	eppbp	errset1-*,ic
	spribp	ab|errset1_op
	eppbp	errset2-*,ic
	spribp	ab|errset2_op
	eppbp	unerrset-*,ic
	spribp	ab|unerrset_op
	eppbp	call-*,ic
	spribp	ab|call_op
	eppbp	catch1-*,ic
	spribp	ab|catch1_op
	eppbp	catch2-*,ic
	spribp	ab|catch2_op
	eppbp	uncatch-*,ic
	spribp	ab|uncatch_op
	eppbp	iogbind-*,ic
	spribp	ab|iogbind_op
	eppbp	obscene_go_tag-*,ic
	spribp	ab|unseen_go_tag_op
	eppbp	throw1-*,ic
	spribp	ab|throw1_op
	eppbp	throw2-*,ic
	spribp	ab|throw2_op
	eppbp	signp-*,ic
	spribp	ab|signp_op
	eppbp	return-*,ic
	spribp	ab|return_op
	eppbp	err-*,ic
	spribp	ab|err_op
	sprilp	ab|system_lp		set up for later use.
	eppbp	pl1_interfacer-*,ic
	spribp	ab|pl1_interface
	eppbp	pl1_lsubr_interfacer-*,ic
	spribp	ab|pl1_lsubr_interface
	eppbp	<lisp_alloc_>|[cons_opr]
	spribp	ab|cons_op
	eppbp	<lisp_alloc_>|[ncons_opr]
	spribp	ab|ncons_op
	eppbp	<lisp_alloc_>|[xcons_opr]
	spribp	ab|xcons_op
	eppbp	<lisp_alloc_>|[begin_list_opr]
	spribp	ab|begin_list_op
	eppbp	<lisp_alloc_>|[append_list_opr]
	spribp	ab|append_list_op
	eppbp	<lisp_alloc_>|[terminate_list_opr]
	spribp	ab|terminate_list_op
	eppbp	compare
	spribp	ab|compare_op
	eppbp	link_operator
	spribp	ab|link_opr
	lda	fixnum_type,dl
	ldq	flonum_type,dl
	staq	ab|type_fields
	eppbp	<lisp_alloc_>|[cons_string]
	spribp	ab|cons_string_op
	eppbp	pl1_call_operator
	spribp	ab|pl1_call_op
	eppbp	create_string_descriptor
	spribp	ab|create_string_desc_op
	eppbp	create_varying_string
	spribp	ab|create_varying_string_op
	eppbp	create_array_descriptor
	spribp	ab|create_array_desc_op
	eppbp	unwind_protect-*,ic
	spribp	ab|unwp1_op
	spribp	ab|unwp2_op
	eppbp	unwind_protect_end
	spribp	ab|ununwp_op
	eppbp	irest_return
	spribp	ab|irest_return_op
	eppbp	pl1_call_nopop
	spribp	ab|pl1_call_nopop_op
	eppbp	rcv_char_star
	spribp	ab|rcv_char_star_op
	short_return
patch_instruction:
	tra	ab|call_op,*
	even
gensym_init:
	aci	"g"
	dec	0

""" Operators having to do with arrays.

	even
fault_tag_3_number_1:
	arg	1,f3
	arg	0
fault_tag_3_number_2:
	arg	2,f3
	arg	0

array_reference_op:
	epplb	ab|system_lp,*			check for *rset t mode
	link	star_rset,<lisp_static_vars_>|[star_rset],*
	ldaq	lb|star_rset,*
	epplb	bb|array_data_ptr-2,*		-> array_data block (dope vector)
	lxl4	bb|array_info.2ndims-2		number of subscripts * -2
	tze	external_array_reference-*,ic		tra if ext array flag set
	cmpaq	ab|nil
	tnz	array_ref_with_full_checking-*,ic

array_ref_without_checking:
	eaq	0				compute offset in q

	adq	ap|1,x4				add in a subscript
	mpy	lb|1,x4				multiply by multiplier
	eax4	2,x4
	tnz	-3,ic

	lxl4	bb|array_info.2ndims-2		pop subscripts off stack
	eppap	ap|0,x4				..

	spribb	ab|array_info_for_store		save data for store
	stq	ab|array_offset_for_store
	tra	bb|array_load_sequence-2		use code in array to load and return

array_ref_with_full_checking:

array_checking_loop:
	ldaq	ap|0,x4				get a subscript
	cmpa	fixnum_type,dl			fixnum?
	tnz	bad_subscript-*,ic			no, barf
	cmpq	lb|0,x4				compare against bounds
	trc	bad_subscript-*,ic			out of bounds or negative
	eax4	2,x4
	tnz	array_checking_loop-*,ic
	lxl4	bb|array_info.2ndims-2		number of subscripts * -2
	tra	array_ref_without_checking-*,ic	reference is OK, proceed.

external_array_reference:
	cmpaq	ab|nil
	tze	ext_array_ref_no_check-*,ic
	ldaq	ap|-2			check bound
	cmpa	fixnum_type,dl
	tnz	bad_subscript-*,ic
	cmpq	bb|array_load_sequence-2	which is stored in kludgey way
	trc	bad_subscript-*,ic		out of bounds or negative
ext_array_ref_no_check:
	ldq	ap|-1			get subscript
	eppap	ap|-2			pop subscript
	spribb	ab|array_info_for_store	save data for store
	stq	ab|array_offset_for_store
	lda	fixnum_type,dl		ext arrays are always fixnum
	tra	bb|array_load_sequence-2+1	use code in array to load and return

bad_subscript:
	lxl1	<lisp_error_table_>|[bad_array_subscript]	better not need lp
array_reference_err:
	eppap	ap|4		get set to push args to lisp_error_
	staq	ap|-2		the bad subscript
	eppbb	bb|-2		the array pointer
	spribb	sb|stack_header.stack_end_ptr,*
	ldaq	sb|stack_header.stack_end_ptr,*
	ora	Array+35,dl	turn on array type bit and its tag
	staq	ap|-4
	ldaq	ap|-2		make list of array pointer and subscript
	tspbp	ab|ncons_op,*
	spribb	ap|-2
	ldaq	ap|-4
	tspbp	ab|cons_op,*
	ldaq	ap|-2
	staq	bb|2
	eppap	ap|-2
	spribb	ap|-2
	eaa	0,x1		get error code.
	arl	18
	lcq	-fn_store,dl	if fn code requuired, was store
	tsx0	Lisp_Error-*,ic	go signal uncorrectable error.

dead_array_reference_op:
	eppap	ap|2		will pass array pointer to lisp_error_
	eppbb	bb|-2		the array pointer
	spribb	sb|stack_header.stack_end_ptr,*
	ldaq	sb|stack_header.stack_end_ptr,*
	ora	Array+35,dl
	staq	ap|-2
	lda	<lisp_error_table_>|[dead_array_reference]	better not need lp
	ldx1	bb|array_info.type-2	perhaps is really a readtable
	cmpx1	Readtable_array,du
	tnz	2,ic
	 lda	 <lisp_error_table_>|[cant_subscript_readtable]	better not need lp
	tsx0	Lisp_Error-*,ic	go signal uncorrectable error.


""" compiled store comes here.  locations in stack header have been set up
""" by a previous array reference.  value to store is in aq. (or just q if
""" compiler knows it to be a fixnum or flonum array)

store_op:	eppbb	ab|array_info_for_store,*	-> array_info, fault if bad.
	lxl1	ab|array_offset_for_store	get index value
	ldx0	bb|array_info.type-2	get array type
	xec	store_table,x0		do store seq. depending on type
	tra	bp|0			and return.  aq is unchanged.

store_table:
	staq	bb|array_data_ptr-2,*x1	S-expr array
	staq	bb|array_data_ptr-2,*x1	Un-gc array
	stq	bb|array_data_ptr-2,*x1	fixnum array
	stq	bb|array_data_ptr-2,*x1	flonum array
	tra	not_allowed_to_store	readtable
	tra	not_allowed_to_store	obarray
	tra	store_into_dead_array	dead.

" operator similar to store_op but value to be stored is in EAQ.
" type checking is performed.

floating_store_op:
	eppbb	ab|array_info_for_store,*
	lxl1	ab|array_offset_for_store
	ldx0	bb|array_info.type-2
	xec	floating_store_table,x0
	tra	bp|0

floating_store_table:
	tra	move_EAQ_to_Q_then_store
	tra	move_EAQ_to_Q_then_store
	tra	not_allowed_to_store_f		flonum -> fixnum array
	fstr	bb|array_data_ptr-2,*x1		flonum -> flonum array
	tra	not_allowed_to_store_f
	tra	not_allowed_to_store_f
	tra	not_allowed_to_store_f

not_allowed_to_store_f:
	eax7	2,x7
	fstr	ab|-1,x7
	ldq	ab|-1,x7
	lda	flonum_type,dl
	tra	not_allowed_to_store-*,ic

move_EAQ_to_Q_then_store:
	eax7	2,x7
	fstr	ab|-1,x7
	ldq	ab|-1,x7
	lda	flonum_type,dl
	eax7	-2,x7
	staq	bb|array_data_ptr-2,*x1
	tra	bp|0

not_allowed_to_store:  store_into_dead_array:
	lxl1	<lisp_error_table_>|[store_not_allowed]		better not need lp
	tra	array_reference_err-*,ic


""" This operator is used by compiled code to get an array pointer
""" from an atomic symbol which is alleged to be the name of an array
""" It is called by xec'ing a 4-word block in the comp_subr_block,
""" which contains a tspbp to this operator
""" and a word in the form  vfd 9/type,9/ndims,18/constant
""" constant is the offset relative to lp (in the constants area)
""" of the atomic symbol which names the array.
""" The first word in the block is changed to eppbb *+2,*
""" and the last words are changed to point to the array_info block.

""" Registers:
"""	lp = caller's lp
"""	bp -> calling xec instruction + 1
"""	lb = system lp
"""	bb = clobberable, set on return to -> array_info
"""	aq and x5 are unchanged.

	link	array_atom,<lisp_static_vars_>|[array_atom]
	link	no_snapped_links_flag,<lisp_static_vars_>|[no_snapped_links]

array_link_snap_op:
	epplb	ab|system_lp,*
	eppap	ap|2		save aq
	staq	ap|-2
	ldx1	bp|-1		-> array_link block (relative to lp)
	anx1	=o077777,du
	lxl0	lp|1,x1		offset from lp to symbol naming array
	eppbb	lp|0,x0*		-> symbol
continue_array_search:
	ldaq	bb|2
	cana	lisp_ptr.type,dl	end?
	tnz	couldnt_snap_array_link-*,ic
	eppbb	bb|2,*		next piece of property list
	ldaq	bb|0
	cmpaq	lb|array_atom,*
	tnz	continue_array_search-*,ic
	eppbb	bb|2,*
	eppbb	bb|0,*		array pointer
	ldx0	lp|1,x1		ndims
	anx0	=o000777,du
	cmpx0	bb|array_info.ndims
	tnz	couldnt_snap_array_link-*,ic
	lda	lp|1,x1		get required type
	arl	27
	tze	check_for_Sexpr_array-*,ic
	eax0	0,al
	cmpx0	bb|array_info.type	check against actual type
	tnz	couldnt_snap_array_link-*,ic
could_snap_array_link:
	spribb	lp|2,x1		snap the link
	stz	lb|no_snapped_links_flag
	eaa	-1
	ansa	lp|-6		turn off flags for unlinker
	eaa	2,x1
	ora	link_snap_instruction-*,ic
	sta	lp|0,x1		put in eppbb instruction
	ldaq	ap|-2		restore aq
	eppap	ap|-2
	tra	bp|0		exit.  bb has been set.

link_snap_instruction:  eppbb lp|0,*

check_for_Sexpr_array:
	ldx0	bb|array_info.type
	szn	ok_to_link_table,x0
	tnz	could_snap_array_link-*,ic
couldnt_snap_array_link:
	lxl0	lp|1,x1
	ldaq	lp|0,x0		name of array
	eppap	ap|2
	staq	ap|-2
	lda	<lisp_error_table_>|[not_an_array]		better not need lp
	eaq	0		"function ? wanted an array, not foo"
	tra	Lisp_Error-*,ic


ok_to_link_table:
	vfd	36/1,36/1,36/0,36/0,36/0,36/1,36/0

""" Interpreted store function.  similar to store operator
"""	but makes more checks.

	segdef	store

store:	eppap	ap|4		extract args from arglist (fsubr)
	eppbb	ap|-6,*		-> arglist
	ldaq	bb|2,*		cadr is 2nd arg
	staq	ap|-2
	ldaq	bb|0		car is 1st arg
	staq	ap|-4
	eax7	8,x7		going to make two calls to eval
	sprilp	ab|his_lp,x7
	eax5	-2
	stcd	ab|his_bp,x7
	tra	<lisp_>|[eval_]	evaluate 2nd arg
	staq	ap|-4		save the value to be stored
	sprilp	ab|his_lp,x7
	eax5	-2
	stcd	ab|his_bp,x7
	tra	<lisp_>|[eval_]	evaluate first arg (array reference)

	ldaq	ap|-2		pick up value to be stored
	eppap	ap|-2		clear the stack
	eppbb	ab|array_info_for_store,*	get ptr to array_info block
	lxl1	ab|array_offset_for_store	get subscript
	ldx0	bb|array_info.type-2	check type of array and of value to store
	xec	store_test,x0
	tnz	not_allowed_to_store-*,ic	type mismatch
	xec	store_table,x0	OK to store, do so.
	tra	return-*,ic

store_test:
	eax2	0		S-expr - can always store
	eax2	0		Un-gc - can always store
	cmpa	fixnum_type,dl	Fixnum
	cmpa	flonum_type,dl	Flonum
	tra	not_allowed_to_store  Readtable
	tra	not_allowed_to_store  Obarray
	tra	store_into_dead_array Dead

""" Routine to signal a LISP error

Lisp_Error:
	eax7	8,x7		save bp, lp, bb, lb, x0, and room to push error code.
	sprpbp	ab|-8,x7
	sprplp	ab|-7,x7
	sprpbb	ab|-6,x7
	sprplb	ab|-5,x7
	stx0	ab|-4,x7

	staq	ab|-2,x7		error code, fn code

" prepare to call pl1 program

	enter_pl1_code	push
	eppap	null_argl-*,ic		pass no args to pl1 error routine.
	short_call lisp_error_$lisp_error_
	exit_pl1_code	pop

	ldx0	ab|-2,x7		restore saved registers
	lprplb	ab|-3,x7
	lprpbb	ab|-4,x7
	lprplp	ab|-5,x7
	lprpbp	ab|-6,x7
	eax7	-6,x7

	tra	0,x0		return from call to Lisp_Error

" two routines which are the operators for pl1 compiled subrs.
" These routines generate a standard Multics call, and keep track
" of the lisp stacks so that interrupts can be handled correctly.
" The calling sequence, which appears in the subr block in the lisp
" static storage segment, is:
"
"	eax7	2,x7
"	spribp	ab|-2,x7
"	tspbp	ab|pl1_interface_op,*	for the appropiate interface....
"	its	<routine>			link to routine....
"
pl1_lsubr_interfacer:
	eppap	ap|2			get room for saving x5.
	eaq	0,x5
	qrs	18
	lda	fixnum_type,dl
	staq	ap|-2
pl1_interfacer:
	eax7	4,x7			get room to save lp
	sprilp	ab|-4,x7			save callers lp
	epplp	bp|0,*			get pointer to pl1 entry to call.
	sprilp	ab|-2,x7			and save through the save sequence.
	enter_pl1_code	push
	eppbp	<lisp_static_vars_>|[unmkd_ptr],*
	eppap	null_argl-*,ic			must set up arg list.
	short_call bp|-2,*			call the target fo the call.
	exit_pl1_code	pop
	epplp	ab|-4,x7*
	eppbp	ab|-6,x7*
	eax7	-6,x7
	ldaq	ap|-2
	eppap	ap|-2
	tra	bp|0
	even
null_argl:oct	4,0



" link opertor for compiled code

link_operator:
	eax7	8,x7
	sprplp	ab|-8,x7
	stx0	ab|-7,x7
	sxl5 	ab|-7,x7
	eppbp	lp|-1
	adwpbp	bp|0		" get pointer to itp.
	spribp	ab|-6,x7
	eppbp	ab|-6,x7
	spribp	ab|-2,x7
	ldaq	one_arg
	staq	ab|-4,x7
	enter_pl1_code	push
	eppap	lisp_static_vars_$unmkd_ptr,*
	eppap	ap|-4
	short_call lisp_linker_$lisp_linker_
	exit_pl1_code	pop
	lprplp	ab|-8,x7
	ldx0	ab|-7,x7
	lxl5	ab|-7,x7
	eppbp	ab|-6,x7*
	eax7	-8,x7
	tra	bp|0,*

one_arg:	zero	2,4
	zero	0,0

" bind operator.
" the calling tspbp is followed by a word with 4*number bindings in
" left half
" Following this is one word for each binding, in the form:
"	vfd	3/flags, 15/atom_loc, 18/value_loc
" where atom_loc is offset from lp of ptr to atom, value_loc is
" offset of new value to be given it, flags tells where value_loc
" is offset from: 0=ab, 1=ap, 2=lp, 3=addr of this word (bp)
"    If flags is >3, means one of these special cases:
"	4  bind the argatom according to x5 (for compiled lexpr's)
"			(atom_loc better be 0!!!)
"	5  obtain value from x5 (for compiled lexpr's)
"	6  same as 1 except take the car of the value
"	7  same as 2 except take the car of the value
"
"   NB: offset from ap is from ap after 4*number_bindings
"       has been added to it.
" The marked pdl portion of the binding block is allocated
" by this operator, and the unmarked pdl portion
" must be allocated here.
" this operator destroys the contents of aq and all the index registers
"
" Usage of index registers in this operator:
"
" x0   not used
" x1   temp.
" x2   saves value of ap when operator was called
" x3   counts number of bindings to be done
" x4   points at current 4-word slot in binding block
" x5   not changed, for flags = 4 or 5, should be -2*#args to lsubr
" x6   temp
" x7   unmarked pdl ptr, as usual
"
" Pointer Registers
"
" bp -> control words in caller
" lp    left as caller's lp
" lb    system lp
" bb    temporary


	link	binding_top_plus_1,<lisp_static_vars_>|[binding_top]+1
	link	argatom,<lisp_static_vars_>|[argatom]

bind:
	eax7	2,x7			room for binding block
	epplb	ab|system_lp,*
	ldx3	bp|0			4*number_bindings
	lcx4	bp|0			offset of first binding from top of stack
	eax2	ap|0			save ap in case of flags=4
	eppap	ap|0,x3			make room for binding block.
	ldq	lb|binding_top_plus_1,*	make binding block
	stq	ab|-1,x7			binding_block.back_ptr (clear rev_ptr)
	stx2	ab|-2,x7			set binding_block.top_block
	sxl2	ab|-2,x7			set binding_block.bot_block
	eax1	ab|-2,x7			and thread onto list of binding blocks
	stx1	lb|binding_top_plus_1,*

bind_loop:
	eppbp	bp|1			-> next binding descrip word
	ldx1	bp|0			get atom to be bound
	anx1	=o077777,du
	tze	flags4-*,ic		not an atom (for flags=4)
	ldaq	lp|0,x1
	staq	ap|2,x4
	ldaq	ap|2,x4*
	staq	ap|0,x4			save old value
	eax4	4,x4			-> next slot in binding block
	eax1	ap|0,x4			update binding_block.top_block
	stx1	ab|-2,x7
	lxl1	bp|0			get new value to give to atom
	lda	bp|0			use 'flags' as xec vector index
	arl	15
	xec	bind_vec,au		get new value in aq
xec_ret:
	staq	ap|2-4,x4*
	eax3	-4,x3			count bindings
	tnz	bind_loop-*,ic
	tra	bp|1			all done

bind_vec:
	ldaq	ab|0,x1
	ldaq	ap|0,x1
	ldaq	lp|0,x1
	ldaq	bp|0,x1
	tra	flags4			4  - special case
	tra	flags5			5  - get value from x5 reg.
	ldaq	ap|0,x1*
	ldaq	lp|0,x1*


flags5:	eaa	0,x5			get -2*nargs
	neg	0
	lrs	19+36			c(q) = nargs
	lda	fixnum_type,dl
	tra	xec_ret-*,ic

flags4:	eax4	4,x4			adjust x4 for next binding
	epaq	lb|argatom,*		-> argatom
	eaa	0,au			clear ring number
	ora	Uncollectable+35,dl		type bit and its tag
	staq	ap|2-4,x4			put in binding block
	ldaq	ap|2-4,x4*		save old value
	staq	ap|0-4,x4
	eax6	ap|0,x4			update binding_block.top_block
	stx6	ab|-2,x7
	eaa	0,x5			-2 * nargs
	neg	0
	ars	1			nargs to au
	ora	Uncollectable,dl		special kludge thing argatom is bound to
	eppbb	ap|2-4,x4*		-> value cell of argatom
	sta	bb|0			store first word
	lxl1	bp|0			stack offset due to compiled code
	stx1	bb|1			build up second word.
	asx2	bb|1			stack pointer when operator called
	asx5	bb|1			stack offset to get to arguments
	tra	xec_ret+1-*,ic		and return to normal sequence


" unbind operator.
" unbinds the binding block which must be located at top of unmkd pdl
"preserves aq but
" changes index registers, decrements x7 by 2, 
" de-allocates the binding block allocated by bind operator, hence changes ap


unbind:	eax7	4,x7		save aq + temp.
	staq	ab|-4,x7
	epplb	ab|system_lp,*
	lxl1	ab|-6,x7			binding_block.bot_block
	stx1	ab|-1,x7			save for cmpx1
	eax6	0,x1			save base of binding block for eppap below.
	epbpbb	ap|0			baseptr of marked pdl
	ldx1	ab|-6,x7			binding_block.top_block

" now proceed to unbind top down

unbind_loop:
	cmpx1	ab|-1,x7			reached bottom?
	tze	unbind_end-*,ic		 yes.
	eax1	-4,x1			 no, do next.
	ldaq	bb|0,x1			get old value
	staq	bb|2,x1*			put back on atom
	tra	unbind_loop-*,ic		and keep it up.

unbind_end:
	ldx1	ab|-5,x7			unthread this binding block
	stx1	lb|binding_top_plus_1,*
	eppap	bb|0,x6			pop binding block storage off of marked pdl
	ldaq	ab|-4,x7			restore aq
	eax7	-6,x7			clear save area and binding_block from pdl
	tra	bp|0			& return

" errset1 operator.
" sets up an errset with no suppression of error messages
" destroys contents of x0-x6 and aq. x7 is bumped by 12,
" ap is bumped by 2.
" *** 22 SEP 72 - DAM -- no longer makes a stack frame,
" just saves the rtcd loc in the stack frame, which is destroyed
" by the Multics non local go to mechanism.

" call is:
"	tspbp	ab|errset1,*
"	tra	eob			return here if error occurs
"					"with nil or value of err in aq
"	- compiled first arg to errset -
" eob:	tspbp	ab|unerrset,*


errset1:	eppap	ap|2			temp for use if error occurs
	eax2	0			this is not errset with nil 2nd arg
	tra	errset_com-*,ic


" errset2 operator.
" sets up an errset with 2nd arg to errset determining
" suppression of error messages. destroys contents of aq
" and x0-x6, x7 is bumped by 12, ap is unchanged. Call is
" same as errset1 except that top of marked pdl
" contains evaluated second arg to errset.


errset2:	ldaq	ap|-2			get 2nd arg to errset
	cmpaq	ab|nil			if nil, suppress error msgs
	tnz	errset1+1-*,ic		not nil, allow msgs
	ldx2	=o400000,du		nil, set x2 to "1"b

errset_com:
	eax7	12,x7			size(frame)+save lp,bp,sp|20
	sprilp	ab|his_lp,x7
	spribp	ab|his_bp,x7		save caller's stuff for return
	epplp	ab|system_lp,*
	ldaq	sp|20			save ret addr in stack frame we are sharing
	staq	ab|-6,x7

" set up errset frame on unmarked pdl
" above errset frame our caller's lp, bp will be
" saved so that error routine can return to him.

	eax1	ap|0
	sxl1	ab|frame.stack_ptr-12,x7
	ldx1	<lisp_static_vars_>|[err_frame]+1
	stx1	ab|frame.prev_frame-12,x7
	stz	ab|frame.dat2-12,x7		set to "1"b by err if eval needed
	stx2	ab|frame.dat1-12,x7		set suppress-msgs flag
	eppbp	err_return-*,ic
	spribp	ab|frame.ret-12,x7
	sprisp	ab|frame.ret+2-12,x7
	eax1	ab|-12,x7
	stx1	<lisp_static_vars_>|[err_frame]+1

" return to compiled first arg to errset

	epplp	ab|his_lp,x7*
	eppbp	ab|his_bp,x7*
	tra	bp|1

" come here if error occurs, value to return is on top of
" marked pdl, frame.dat2 is "1"b if it hasn't been evaled yet (from fcn 'err')

err_return:
	getlp			" in pl1 code mode, must get lp from lot.
	push				"stack frame to call out with
	eppbp	<lisp_static_vars_>|[unmkd_ptr],*    push onto unmkd pdl...
	eppbp	bp|2
	spribp	<lisp_static_vars_>|[unmkd_ptr]
	eppap	<lisp_static_vars_>|[err_frame],*
	eppap	ap|12			... the addr to unwind to
	spriap	bp|-2			which is just above our errset frame
	eppbp	<lisp_static_vars_>|[stack_ptr],*    copy value to be returned down
	lxl1	ap|frame.stack_ptr-12
	ldaq	bp|-2
	epbpbb	bp|0
	staq	bb|-2,x1
	eppap	null_argl-*,ic		get null arg list for call.
	short_call  <lisp_prog_fns_>|[lisp_unwinder]
	eppbp	<lisp_static_vars_>|[err_frame],*  should we eval the returned value?
	lxl1	bp|frame.stack_ptr
	epbpab	<lisp_static_vars_>|[stack_ptr],*
	eppap	ab|0,x1
	spriap	<lisp_static_vars_>|[stack_ptr]
	lxl0	bp|frame.dat2
	tze	err_ret_0-*,ic
	eppap	null_argl-*,ic		get null arg list for call to pl1 entry in eval.
	short_call  <lisp_>|[eval]
err_ret_0:

" now go from pl1_code mode to lisp_code mode, and
" return to error return loc in errset caller, with errset frame still around

	exit_pl1_code	pop
	ldaq	ab|-6,x7			restore ret addr in stack frame
	staq	sp|20
	epplp	ab|his_lp,x7*
	eppbp	ab|his_bp,x7*
	ldaq	ap|-2			value of the errset
	tra	bp|0			return to caller, who will do an unerrset.
 
" unerrset operator.
" this operator removes the errset frame which must be at the top of
" the unmarked pdl.  It does not disturb the aq or the ap, it
" decrements x7 by 12, and the other index registers are destroyed.
" doesn't have to restore sp|20 since that is only
" destroyed by a non-local goto and our non-local-goto reciever has
" already fixed it.

	link	err_frame_plus_1,<lisp_static_vars_>|[err_frame]+1

unerrset:
	epplb	ab|system_lp,*		get lp for this program.
	ldx1	ab|frame.prev_frame-12,x7	remove err frame from pdl
	stx1	lb|err_frame_plus_1,*
	eax7	-12,x7
	eppap	ap|-2		get rid of value pushed on by caller.
	tra	bp|0


" call operator.
" this operator is used to provide call_outs from lisp-compiled
" code to external functions.  It is called by tspbp lp|link,*
" where the doubleword link in the linkage section is:

" link:	vfd  3/ab, 15/fcn_offset, 1/snap, 1/constant, 1/fsubr, 9/nargs, 6/itb
"	vfd  18/call_oper, 12/0, 6/20
" where fcn_offset is offset from ap (constant = 0)
"  or from lp (constant = 1)
" snap is 1 if the link is to be changed to point directly
"  at the function if possible
" fsubr is 1 if the top of the pdl contains the unevaluated
"  list of args, 0 if top of pdl contains spread, evaluated args
" nargs is o777 if arg count times -2 is in x5, otherwise is arg count
" the remaining fields look like  itb  ab,call_oper,*
" so that the tspbp has the effect of tspbp ab|call_oper,*
" this operator destroys all the index registers, it returns
" with x7 unchanged, result of function in aq, and the
" args or arglist popped off the marked pdl.


call:	eax7	6,x7		push lp, bp, addr of link
	sprilp	ab|his_lp,x7
	spribp	ab|his_bp,x7
	ldx0	bp|-1		get addr of link
	anx0	=o077777,du
	eppbp	lp|0,x0
	spribp	ab|-6,x7
	lda	bp|0		get the function into aq
	als	3		spread sign bit (3) into (0-2)
	ars	3
	cana	=o200000,dl	test constant bit
	tnz	3,ic
	ldaq	ap|0,au		not constant, get from stack
	tra	2,ic
	ldaq	lp|0,au		constant, get from linkage section
	eppap	ap|-form
	staq	ap|form
	lda	bp|0			check for f_type function
	cana	=o100000,dl
	tnz	call_2_f-*,ic
	epplp	ab|system_lp,*


" set x5 to number of args if not already so set

	lda	ab|-6,x7*
	ana	=o77700,dl
	cmpa	=o77700,dl
	tze	already_got_x5-*,ic
	  ars	  5
	  neg	  0
	  eax5	  0,al
already_got_x5:

" go to routine in lisp_ to do rest of work

	tra	<lisp_>|[call1]

" call with unevaled arg list

call_2_f:
	ldaq	ap|form-2			arg list
	eppap	ap|-2
	staq	ap|argl
	ldaq	ap|fcn
	staq	ap|form
	epplp	ab|system_lp,*
	tra	<lisp_>|[callf]


" catch1 operator.
" is the compiled form of a catch with one argument
" destroys contents of aq and x0-x6, x7 is bumped by 12,
" ap is bumped by 2.
" call is:
"	tspbp	ab|catch1,*
"	tra	eoc			return here if throw occurs
"					with the value thrown in aq
"	- compiled first arg to catch -
" eoc:	tspbp	ab|uncatch,*
"	"result of catch is now in aq
"
" also saves sp|20 and restores it if it gets destroyed
" by unwinder_



catch1:	eppap	ap|2			make fake catch tag
	ldaq	nultag-*,ic
	staq	ap|-2
					" fall into catch2



" catch2 operator.
" is compiled form of catch with a second arg, which is the catch tag.
" call is same as catch1 except ap is not bumped and top of marked pdl
" contains the unevaluated second arg to catch.


catch2:
	eax7	12,x7
	sprilp	ab|his_lp,x7
	spribp	ab|his_bp,x7
	epplp	ab|system_lp,*
	ldaq	sp|20			save ret addr in stack frame we are sharing
	staq	ab|-6,x7

" set up catch frame on unmarked pdl.  Above the
" catch frame our caller's lp, bp will be saved
" so that we can return to him if a throw occurs.

	eax1	ap|0			-> just above catch label (for throw)
	sxl1	ab|frame.stack_ptr-12,x7
	ldx1	<lisp_static_vars_>|[catch_frame]+1
	stx1	ab|frame.prev_frame-12,x7
	eppbp	throw_ret-*,ic
	spribp	ab|frame.ret-12,x7
	sprisp	ab|frame.ret+2-12,x7
	eax1	ab|-12,x7
	stx1	<lisp_static_vars_>|[catch_frame]+1

" go elaborate the compiled first arg to catch

	epplp	ab|his_lp,x7*
	eppbp	ab|his_bp,x7*
	tra	bp|1


" come here (in pl1_code mode) if a throw occurs.  The value
" thrown is at top of marked pdl.  The unmarked pdl has not
" yet been unwound.
" We move the thrown value down, unwind the unmarked pdl to
" just above our catch_frame, put the thrown value
" in aq, and return to the location after
" the call to catch1 or catch2.  The caller will do an uncatch.

throw_ret:
	getlp				" get lp from lot, as we are in pl1 code mode here.
	push
	eppbp	<lisp_static_vars_>|[unmkd_ptr],*
	eppbp	bp|2			push onto unmarked pdl...
	spribp	<lisp_static_vars_>|[unmkd_ptr]
	eppap	<lisp_static_vars_>|[catch_frame],*
	eppap	ap|12			...the addr to unwind to...
	spriap	bp|-2			...which is just above our catch frame
	eppbp	<lisp_static_vars_>|[stack_ptr],*
	ldaq	bp|-2			get the thrown value
	lxl1	ap|frame.stack_ptr-12
	epbpbb	bp|0
	staq	bb|-2,x1			and put it into our part of marked pdl
	eppap	null_argl-*,ic		call the unwinder with no pl1 arguments.
	short_call  <lisp_prog_fns_>|[lisp_unwinder]

" switch to lisp_code mode (ptrs in ap, x7)

	exit_pl1_code	pop
	epbpbb	ap|0			adjust stack_ptr to value when catch wsa done
	lxl1	ab|frame.stack_ptr-12,x7
	eppap	bb|0,x1
	ldaq	ab|-6,x7			restore sp|20
	staq	sp|20
	ldaq	ap|-2			return thrown value in aq
	epplp	ab|his_lp,x7*
	eppbp	ab|his_bp,x7*
	tra	bp|0			return to caller who will do an uncatch



" uncatch operator.
" this operator removes the catch frame which must be at the top
" of the unmarked pdl.  It does not disturb the aq or the ap,
" it decrements x7 by 12, and the other index registers are
" destroyed.

	link	catch_frame_plus_1,<lisp_static_vars_>|[catch_frame]+1

uncatch:	epplb	ab|system_lp,*
	ldx1	ab|frame.prev_frame-12,x7	unthread this catch_frame
	stx1	lb|catch_frame_plus_1,*
	eax7	-12,x7
	eppap	ap|-2		get rid of value pushed by caller.
	tra	bp|0

 
" operator to bind for iog.  Allows iog to be compiled as
"	tspbp	ab|iogbind_op,*
"	<call>	<function ioc>
"	<eval>	2nd arg to iog
"	tspbp	ab|unbind_op,*
"
" binds ^q, ^r, ^w to nil.
" destroys the contents of aq and all the index registers, bumps x7 by 2
" bumps ap by 16, but only 12 of those words are currently used.

	
iogbind:	eax7	6,x7			room for binding block, save lp,bp
	sprilp	ab|his_lp,x7
	spribp	ab|his_bp,x7
	epplp	ab|system_lp,*
	eppap	ap|16			make room for binding block
	ldaq	ab|true			" KLUDGE to take up space...rebind t to t.
	staq	ap|-14
	staq	ap|-16			" END KLUDGE
	ldaq	<lisp_static_vars_>|[ctrlQ]	put ^q in binding block
	staq	ap|-10
	ldaq	<lisp_static_vars_>|[ctrlR]	put ^r in binding block
	staq	ap|-6
	ldaq	<lisp_static_vars_>|[ctrlW]	put ^w in binding block
	staq	ap|-2
	ldaq	ap|-10,*			now save old values.
	staq	ap|-12
	ldaq	ap|-6,*
	staq	ap|-8
	ldaq	ap|-2,*
	staq	ap|-4
	ldq	<lisp_static_vars_>|[binding_top]+1
	stq	ab|-5,x7			make binding_block in unmkd pdl
	eax1	ap|-16
	sxl1	ab|-6,x7			binding_block.bot_block
	eax1	ap|0
	stx1	ab|-6,x7			binding_block.top_block
	eax1	ab|-6,x7			and thread onto list of b.b.'s
	stx1	<lisp_static_vars_>|[binding_top]+1


	ldaq	ab|nil			now reset ^q, ^r, ^w to nil
	staq	<lisp_static_vars_>|[ctrlQ],*
	staq	<lisp_static_vars_>|[ctrlR],*
	staq	<lisp_static_vars_>|[ctrlW],*

	tra	return-*,ic



" unseen_go_tag operator
" this operator is called by the compiled form of the go function
" when the argument is non-atomic and, having been evaled, is not
" found in the table of known tags.
" Called by tspbp with the losing tag in the aq.  Returns with
" ap, x7 unchanged, better tag in the aq, index regs destroyed.
"
" If the aq contains an atom, it is really a losing tag
" and a call to lisp_error_ is constructed.
" If the aq contains a list, then it is evaluated and returned
" to caller, just like the interpreted go function.

obscene_go_tag:
	eax7	4,x7			save caller's lp,bp
	spribp	ab|his_bp,x7
	sprilp	ab|his_lp,x7
	eppap	ap|2			save tag on pdl for lisp_error_ or eval
	staq	ap|-2
	cana	lisp_ptr.type,dl		atomic tag?
	tze	re_eval_tag-*,ic		no, eval it again.
	lda	<lisp_error_table_>|[unseen_go_tag]
	tsx0	Lisp_Error-*,ic
	ldaq	ap|-2			get replacement tag
	eppap	ap|-2
	tra	return-*,ic

" come here to eval the tag again

re_eval_tag:
	eax5	-2			calling eval with 1 arg
	epplp	ab|system_lp,*		get right lp for eval
	tra	<lisp_>|[eval_]		eval the tag and return to our caller. (clever)


" return operator.
" called by tra ab|return_op,*
" This operator is used to return from a type 1 subr
" after the unmkd pdl has been cleared, and the args, temps,
" and local variables have been removed from the marked pdl.
" the value to be returned should be in the aq.

return:	epplp	ab|his_lp,x7*
	eppbp	ab|his_bp,x7*
	eax7	-4,x7
	tra	bp|0





" signp operator.
" called by tspbp ab|signp_op,*
" This operator sets the indicators from the number in the aq.
" If C(aq) is not a number, indicators are set randomly.
" Changes no registers except aq.

signp:	cana	Float,dl			flonum?
	tnz	signp_fl-*,ic		yes.
	cana	Big_fixed,dl		bignum?
	tnz	signp_big-*,ic

" fixnum - set indicators from q<0:35>

	cmpq	0,du			set indicators for fixnum in q.
	tra	bp|0

" flonum - set indicators from fraction, q<8:35>

signp_fl:	canq	=o1000,du			set zero indicator from sign bit of float.
	tnz	set_minus_indicator-*,ic	and if negative float, set negative indicator.
	cmpq	=0.0,du			otherwise, compare with floating point zero (= least fixed number)
	tra	bp|0
set_minus_indicator:
	szn	=o777777,du		turn on minus indicator.
	tra	bp|0			return.

signp_big: easpbb	0,au			move pointer from AQ to BB
	eawpbb	0,qu			..
	szn	bb|0			get sign from bignum.  works because
	"				no bignum is zero, and RH of header is nonzero
	tra	bp|0

" compare operator.
" takes arg in AQ, bb points at thing to be compared with.
" sets indicators, returns.

compare:	cmpa	fixnum_type,dl
	tnz	floatcomp
	cmpq	bb|1
	tra	bp|0		return

floatcomp:eppap	ap|2
	staq	ap|-2
	fld	ap|-1
	eax0	1
	fcmp	bb|1
	tpnz	4,ic
	tze	2,ic
	eax0	-1,x0
	eax0	-1,x0
	ldaq	ap|-2		" reload the aq.
	eppap	ap|-2
	cmpx0	0,du
	tra	bp|0

" err operator.

" (err x) compiles into:
"	ldaq	(eval x)
"	tra	ab|err_op,*
"	-- never returns --
"
" err with no args is the same as (err nil)
" err with 2 args cannot be compiled!!

err:	eppap	ap|2			push value of err onto pdl
	staq	ap|-2			for use of lisp_error_$err_op
	enter_pl1_code
	tra	lisp_error_$err_op		go join interpreter's err fcn.

" throw operators.
" these operators execute those cases of the compiled throw
" function that cannot be done in-line.

" throw1 operator.
" takes value to be thrown in aq.  There is no tag.
" called by tra ab|throw1_op,*

throw1:	eppap	ap|4			get room to store value being thrown
	staq	ap|-2
	ldaq	nultag-*,ic		get null tag and fall into throw2 operator





" throw2 operator.
" takes value to be thrown on top of marked pdl,
"  with an empty slot beneath it, tag in aq.
" Called by tra ab|throw2_op,*
" the unmarked pdl is searched for catches using the same
" algorithm as the throw function in the interpreter.  When the catch
" to be thrown to is found, control is transferred to it.  The catch
" has the responsiblity of unwinding the pdl's and resuming execution
" at the point where catch was called.


throw2:
	epplp	ab|system_lp,*
	ldx1	<lisp_static_vars_>|[catch_frame]+1
catch_search:
	tze	bad_throw-*,ic	tra if no more catch frames
	epbplb	ap|0			get pointer to base of marked stack
	lxl6	ab|frame.stack_ptr,x1	get pdl area of catch
	cmpaq	lb|-2,x6			is our tag = tag of catch?
	tze	throw_1-*,ic		yes, win.
	cmpaq	nultag-*,ic		if null tag in throw, any catch will do.
	tze	throw_1-*,ic		so go there.
	lxl2	lb|-2,x6			no, check for nultag
	cmpx2	nulfu,du
	tze	throw_1-*,ic		this is unlabeled catch, it catches us.
	ldx1	ab|frame.prev_frame,x1	not our catch, keep looking.
	tra	catch_search-*,ic

" come here with x1 pointing at catch frame of catch that catches us.

throw_1:	stx1	lisp_static_vars_$catch_frame+1   discard any intervening catches
	enter_pl1_code
	eax2	sp|0			which is the catch.
	cmpx2	ab|frame.ret+3,x1
	tze	throw_to_same_sp-*,ic
"
"	Build arglist to call the Multics unwinder
"	(Started using Multics unwinder 12/6/78 -BSG)
"
	eppbp	ab|frame.ret,x1		Point at label var
	spribp	sp|2
	ldaq	argl_h_of_1
	staq	sp|0
	eppap	sp|0
	short_call unwinder_$unwinder_

	even
argl_h_of_1:
	zero	2,0
	zero	0,04
throw_to_same_sp:

	eppbp	ab|frame.ret,x1*
	spribp	sp|20
	short_return

" come here when an unseen throw tag condition occurrs.

bad_throw:
	eppap	ap|2			place to store bad tag
	staq	ap|-2
	lda	<lisp_error_table_>|[throw_to_no_catch]
	tsx0	Lisp_Error-*,ic
	ldaq	ap|-2			get replacement tag
	eppap	ap|-2
	tra	throw2+1-*,ic		and go try again

	equ	nulfu,Numeric		= type field of nultag

	even
nultag:	zero	0,nulfu		tag used by catch/throw with no tag.
	dec	0			tag is two words....

" Operator to create a string descriptor for PL/I calls
" bb -> place to put descriptor
" aq has the string (or atomic symbol)
" returns with lb the appropriate argument ptr to store
" clobbers regs

create_string_descriptor:
	easplb	0,au		move aq to lb and
	eawplb	1,qu		make it point at first char
	cana	String,dl		check type
	tnz	csd00-*,ic
	cana	Atsym,dl
	tze	csd_barf-*,ic	bad type
	epplb	lb|4		symbol - skip header
csd00:	lda	lb|-1		pick up length
	ora	=o524000,du	set type in desc
	sta	bb|0		store descriptor
	tra	bp|0		return

csd_barf:	epplp	ab|system_lp,*
	lda	<lisp_error_table_>|[csd_op_barf]
	tra	Lisp_Error-*,ic


"
create_varying_string:

" aq contains the symbol or string to initialize it with
" bb -> where to put the descriptor
" word after call contains the declared length of the string
" return with aq containing the new string as a lisp object, and
" return with lb -> the data portion of the string.  due to
" a pl1 crock this points at the chars rather than the length

	eppap	ap|4			save stuff so can cons string
	staq	ap|-2
	eax7	2,x7
	ldq	bp|0			pick up length
	eppbp	bp|1
	spribp	ab|-2,x7
	orq	=o530000,du		make varying string descrip
	stq	bb|0			put in user's descriptor
	anq	-1,dl			clear qu again
	tspbp	ab|cons_string_op,*
	epplb	bb|1		set up return addr of string
	eppbp	ab|-2,x7*
	eax7	-2,x7
	staq	ap|-4			save value we want to return in aq
	ldaq	ap|-2
	easpbb	0,au		copy au to bb
	eawpbb	1,qu
	cana	Atsym,dl
	tze	cvs00-*,ic
	eppbb	bb|4
	tra	cvs01-*,ic

cvs00:	cana	String,dl
	tze	csd_barf-*,ic
cvs01:	lxl2	bb|-1
	sxl2	lb|-1		set current length of varying string
	mlr	(pr,rl),(pr,rl)
	desc9a	bb|0,x2
	desc9a	lb|0,x2
	ldaq	ap|-4			pick up the string into aq
	eppap	ap|-4			for benefit of caller
	tra	bp|0			done


"
" create an array descriptor for a PL/I call
" bb -> the place to put it.  Sufficient words must have been allocated
" aq contains the array (as an array-ptr or a symbol)
" word following the call has type in left half, ndims in right half
" returns with lb -> the data
" clobbers regs

create_array_descriptor:
	easplb	0,au		move aq into lb
	eawplb	0,qu
	cana	Array,dl		got array-ptr?
	tze	cadget-*,ic	no, go get one
cad00:	lxl0	bp|0		get number of dimensions
	cmpx0	lb|array_info.ndims	check it
	tnz	cad_barf-*,ic
	ldx1	lb|array_info.type	check type of array
	cmpx1	bp|0
	tnz	cad_barf-*,ic
	eaa	0,x0		put ndims in descriptor
	als	6
	ora	type_table,x1	and type bits
	sta	bb|0		stor first descriptor word

	eax1	0		the array descriptor is stored backwards!
	epplb	lb|array_data_ptr,*
cad01:	eax1	-2,x1		scan lisp dope vector backwards
	stz	bb|1		lower bound
	ldq	lb|0,x1		upper bound
	sbq	1,dl
	stq	bb|2
	ldq	lb|1,x1		multiplier
	stq	bb|3
	eppbb	bb|3		advance to next dimension
	eax0	-1,x0		count dimensions
	tnz	cad01-*,ic
	tra	bp|1		done, return

" do a get

cadget:	cana	Atsym,dl		better be a symbol
	tze	cad_barf-*,ic
	eppsb	ab|system_lp,*
	link	array_atom,<lisp_static_vars_>|[array_atom]
	ldaq	sb|array_atom,*
	epbpsb	sp|0
cadget0:	lxl0	lb|2		check for end
	canx0	lisp_ptr.type,du
	tnz	cad_barf-*,ic	reached end - no array property
	epplb	lb|2,*		-> next plist cell
	cmpaq	lb|0		array property?
	tze	cadget1-*,ic	yes -use it
	epplb	lb|2,*		no - take next property
	tra	cadget0-*,ic

cadget1:	epplb	lb|2,*		-> plist value
	epplb	lb|0,*		get the array pointer
	tra	cad00-*,ic	and resume normal operation

cad_barf:	epplp	ab|system_lp,*
	lda	<lisp_error_table_>|[cad_op_barf]
	tra	Lisp_Error-*,ic

type_table:
	oct	410000000107	Sexpr
	oct	410000000107	Sexpr
	oct	404000000043	fixnum
	oct	414000000033	flonum


"
" PL/I call operator
" bb -> arg list
" a contains argcount*2 in left half
" bp is return address
" instruction following tspbp is callsp indirect through link.
" At first I had this an epplb that was xec'ed,
" but the crufty hardware then goes to the wrong segment if it is bound

pl1_call_operator:
	eax7	4,x7		save caller's lp and address
	stcd	ab|-4,x7		save ingenious internal return pt
	tra	pl1_call_common
	exit_pl1_code	pop
pl1_call_ret_common:
	lprpbp	ab|-1,x7
	lprplp	ab|-2,x7
	eax7	-4,x7
	tra	bp|1		return skipping callsp inst

pl1_call_nopop:
	eax7	4,x7
	stcd	ab|-4,x7
	tra	pl1_call_common
	exit_pl1_code "nopop
	tra	pl1_call_ret_common

rcv_char_star:
	ldq	bb|0		get length from lisp string
	mlr	(pr,rl),(pr,rl)	move from bp to bb
	desc9a	lb|0,ql
	desc9a	bb|1,ql		body of lisp code
	"			Now pop PL/I stack
	epbpsb	sp|0
	epplb	sp|0
	even
	inhibit	on
	eppsp	sp|stack_frame.prev_sp,*
	sprilb	sb|stack_header.stack_end_ptr
	inhibit	off
	tra	bp|0

pl1_call_common:
	eaq	0,au		set descriptor counter
	ora	4,dl		and arglist type
	staq	bb|0		and finish arg list
	sprplp	ab|-2,x7
	sprpbp	ab|-1,x7

	enter_pl1_code	push,64 "for pl1 vars
	eppap	bb|0		make the call

	eppbp	lisp_static_vars_$unmkd_ptr,*	get back return address
	lprpbp	bp|-1
	epaq	bp|0		get caller's linkage
	lprplp	sb|stack_header.lot_ptr,*au
	stcd	sp|stack_frame.return_ptr
	callsp	bp|0		call to caller's callsp
				" can't use short_call, clobbers pr4
	epplp	sp|stack_frame.lp_ptr,*
	eppbp	lisp_static_vars_$unmkd_ptr,*
	rtcd	bp|-4

"
"
"	Unwind Protect Feature
"	Greenberg, 9/10/78
"

"Called as follows:
"	tspbp	ab|unwp1,*
"	 tra	cleanup_handler
"	code......


unwind_protect:
	eax7	6,7		Push unmarked frame
	eax1	-6,7		Get pointer to it.
	sprilp	ab|frame.ret+2,1	Save LP for both us and handler.
	epplp	ab|system_lp,*
	ldx6	lisp_static_vars_$unwp_frame+1 Get thread.
	stx6	ab|frame.prev_frame,1
	eax6	ap|0		Save marked pdl.
	sxl6	ab|frame.stack_ptr,1
	stc1	ab|frame.dat1,1	Let interpreter know we are compiled.
	spribp	ab|frame.ret,1	Fake lisp PL/I environment closure.
	stx1	lisp_static_vars_$unwp_frame+1 Now we're official.
	epplp	ab|frame.ret+2,1*	Restore his Lisp LP.
	tra	bp|1		Execute protected code.

"Un-unwind-protect operator.  Assumes top unwp frame is the right one.
"Called as:
"	tspbp	ab|ununwp,*


unwind_protect_end:
	epplb	lp|0		Save his Lisp LP
	epplp	ab|system_lp,*
	ldx1	lisp_static_vars_$unwp_frame+1
	ldx6	ab|frame.prev_frame,1 Get last frame, this MUST be unm top.
	stx6	lisp_static_vars_$unwp_frame+1
	ldq	lisp_static_vars_$masked Save interrupt state
	lca	1,dl		Mask all interrupts
	sta	lisp_static_vars_$masked
	epplp	ab|frame.ret+2,1*	Get Handler's Lisp LP.
	eppbb	ab|frame.ret,1*	BB = handler address
	eax7	6,1		Pop unwp frame, set ret block, intsav
	spribp	ab|his_bp-2,7	Save return address.
	sprilb	ab|his_lp-2,7	Save his LP, too.
	stq	ab|-2,7		Store the interrupt system state.
	tra	bb|0		Go execute the handler.


"This next guy is called by the end of interrupt-inhibited handlers.
" As:
"	tspbp	ab|irest_return_op,*

irest_return:
	epplp	ab|system_lp,*	Restore linkage
	ldq	ab|-2,7		Get old interrupt state
	eax7	-2,7		Get PDL back.
	stq	lisp_static_vars_$masked
	szn	lisp_static_vars_$deferred_interrupt Any?
	tze	return		Finish normal return

	enter_pl1_code	push
	eppap	null_argl
	short_call lisp_fault_handler_$interrupt_poll
	exit_pl1_code	pop
	tra	return


"This next character is called by lisp_prog_fns_, to accomplish quite
"the same when the interpreter unwinds an unwp frame.  We are coming
"from the PL/I environment, and we must pop the unm frame as well.

	segdef	xec_unwprot_compiled_handler
xec_unwprot_compiled_handler:
	getlp
	exit_pl1_code
	tspbp	unwind_protect_end	Hah, hah hah.
	enter_pl1_code
	short_return

	end
