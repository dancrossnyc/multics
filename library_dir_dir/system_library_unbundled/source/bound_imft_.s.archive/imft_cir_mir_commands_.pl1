/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   *********************************************************** */


/* Cancels and moves Inter-Multics File Transfer (IMFT) requests */

/* Created:  May 1982 by G. Palter */
/* Modified: 16 July 1982 by G. Palter to make the commands recognize "-a" as the synonym of "-all" */
/* Modified: March 1983 by Robert Coren to recognize "-source" */
/* Modified: July 1984 by C. Marker to search all queues by default. */
 /* Modified: 1984-10-11 BIM for mseg_message_info */

/* format: style4,delnl,insnl,ifthenstmt,ifthen */


imft_cir_mir_commands_:
     procedure ();


dcl  system_area area based (system_area_ptr);
dcl  system_area_ptr pointer;

dcl  1 local_sb aligned like status_branch;
dcl  1 local_mmi aligned like mseg_message_info;

dcl  1 message_ids (n_requests_selected) aligned based (message_ids_ptr),
       2 id bit (72),
       2 queue fixed binary,
       2 pad bit (36);
dcl  message_ids_ptr pointer;
dcl  (n_requests_selected, n_requests_moved, n_previous_requests, message_idx) fixed binary;

dcl  argument character (argument_lth) unaligned based (argument_ptr);
dcl  id_qualifier character (id_qualifier_lth) unaligned based (id_qualifier_ptr);
dcl  (the_argument_list, argument_ptr, id_qualifier_ptr) pointer;
dcl  (argument_lth, id_qualifier_lth) fixed binary (21);
dcl  (n_arguments, id_qualifier_idx, argument_idx) fixed binary;

dcl  function fixed binary (1);			/* whether to cancel or move requests */
dcl  command_name character (32);

dcl  1 n_identifiers aligned,
       2 path fixed binary,				/* # of pathname identifiers */
       2 entry fixed binary,				/* # of -entry STR identifiers */
       2 id fixed binary;				/* # of request ID identifiers */

dcl  (request_type, target_request_type) character (24);
dcl  (foreign_system, target_foreign_system) character (24);
dcl  (
     queue_indeces (4),
     target_queue_index
     ) fixed binary;
dcl  (queue, target_queue, default_queue, max_queues, target_max_queues, queue_idx) fixed binary;
dcl  (remote, target_remote) bit (1) aligned;
dcl  (generic_type, queue_string) character (32);
dcl  (opened_a_queue, all_queues) bit (1) aligned;

dcl  user_selection fixed binary (2);
dcl  long bit (1) aligned;

dcl  (user_id, person_id, project_id) character (32);
dcl  (match_any_person, match_any_project) bit (1) aligned;

dcl  a_dirname character (168);
dcl  an_ename character (32);

dcl  request_id_nonvarying character (19);
dcl  request_id character (19) varying;

dcl  add_entry entry () options (variable) variable;	/* just used to check access */

dcl  access_required bit (36) aligned;

dcl  answer character (16) varying;

dcl  code fixed binary (35);

/* format: off */
dcl (CANCEL	initial (0b),			/* cancel requests */
     MOVE		initial (1b))			/* move requests */
	fixed binary (1) static options (constant);

dcl (USER		initial (01b),			/* -own */
     SUBSET	initial (10b),			/* -user STR: doesn't match any user */
     ALL		initial (11b),			/* -user STR: matches everyone */

     NONE		initial (00b),			/* not a request_identifier control argument */
     PATH		initial (01b),			/* pathname */
     ENTRY	initial (10b),			/* -entry STR */
     ID		initial (11b),			/* -id STR */

     MATCH_ONE	initial (00b),			/* this identifier matches exactly one request */
     MATCH_SUBSET	initial (01b),			/* this identifier matches some but not all requests */
     MATCH_ALL	initial (10b))			/* this identifier matches all requests */
	fixed binary (2) static options (constant);

dcl (A_EXTENDED_ACCESS	initial ("400000000000"b3),
     O_EXTENDED_ACCESS	initial ("040000000000"b3),
     RD_EXTENDED_ACCESS	initial ("300000000000"b3))
	bit (36) aligned static options (constant);
/* format: on */

dcl  CHASE fixed binary (1) static options (constant) initial (1);


dcl  CANCEL_IMFT_REQUEST character (32) static options (constant) initial ("cancel_imft_request");
dcl  MOVE_IMFT_REQUEST character (32) static options (constant) initial ("move_imft_request");

dcl  imft_data_$queue_dirname character (168) external;

/* format: off */
dcl (error_table_$bad_segment, error_table_$badopt, error_table_$id_not_found, error_table_$inconsistent,
     error_table_$moderr, error_table_$no_message, error_table_$no_s_permission, error_table_$noarg)
	fixed binary (35) external;
/* format: on */

dcl  check_star_name_$entry entry (character (*), fixed binary (35));
dcl  com_err_ entry () options (variable);
dcl  com_err_$suppress_name entry () options (variable);
dcl  command_query_ entry () options (variable);
dcl  cu_$arg_count entry (fixed binary, fixed binary (35));
dcl  cu_$arg_list_ptr entry () returns (pointer);
dcl  cu_$arg_ptr_rel entry (fixed binary, pointer, fixed binary (21), fixed binary (35), pointer);
dcl  cv_dec_check_ entry (character (*), fixed binary (35)) returns (fixed binary (35));
dcl  expand_pathname_ entry (character (*), character (*), character (*), fixed binary (35));
dcl  get_system_free_area_ entry () returns (pointer);
dcl  get_temp_segment_ entry (character (*), pointer, fixed binary (35));
dcl  hcs_$status_long entry (character (*), character (*), fixed binary (1), pointer, pointer, fixed binary (35));
dcl  imft_default_rqt_ entry () returns (char (*));
dcl  ioa_ entry () options (variable);
dcl  iod_info_$generic_type entry (character (*), character (32), fixed binary (35));
dcl  iod_info_$queue_data entry (character (*), fixed binary, fixed binary, fixed binary (35));
dcl  match_request_id_ entry (fixed binary (71), character (*)) returns (bit (1) aligned);
dcl  match_star_name_ entry (character (*), character (*), fixed binary (35));
dcl  message_segment_$add_index entry (fixed binary, pointer, fixed binary (24), bit (72) aligned, fixed binary (35));
dcl  message_segment_$close entry (fixed binary, fixed binary (35));
dcl  message_segment_$delete_index entry (fixed binary, bit (72) aligned, fixed binary (35));
dcl  message_segment_$get_message_count_index entry (fixed binary, fixed binary, fixed binary (35));
dcl  message_segment_$get_mode_index entry (fixed binary, bit (36) aligned, fixed binary (35));
dcl  message_segment_$read_message_index entry (fixed binary, pointer, pointer, fixed binary (35));
dcl  message_segment_$open entry (character (*), character (*), fixed binary, fixed binary (35));
dcl  pathname_ entry (character (*), character (*)) returns (character (168));
dcl  queue_admin_$add_index entry (fixed binary, pointer, bit (72) aligned, fixed binary (35));
dcl  release_temp_segment_ entry (character (*), pointer, fixed binary (35));
dcl  request_id_ entry (fixed binary (71)) returns (character (19));

dcl  (cleanup, linkage_error) condition;

dcl  (addr, after, before, convert, currentsize, index, length, null, rtrim, substr, verify) builtin;

/**/

/* Cancels IMFT requests */

cancel_imft_request:
cir:
     entry () options (variable);

	function = CANCEL;
	command_name = CANCEL_IMFT_REQUEST;
	go to BEGIN_PROCESSING;


/* Moves IMFT requests between queues and even between destinations */

move_imft_request:
mir:
     entry () options (variable);

	function = MOVE;
	command_name = MOVE_IMFT_REQUEST;
	go to BEGIN_PROCESSING;


BEGIN_PROCESSING:
	call cu_$arg_count (n_arguments, code);
	if code ^= 0 then do;
	     call com_err_ (code, command_name);
	     return;
	end;

	if n_arguments = 0 then do;
PRINT_USAGE_MESSAGE:
	     call com_err_$suppress_name (0, command_name, "Usage:  ^a request_identifiers -control_args", command_name)
		;
	     return;
	end;

	the_argument_list = cu_$arg_list_ptr ();


/* Establish defaults */

	n_identifiers = 0;				/* no path, entry, or ID identifiers */

	request_type = imft_default_rqt_ ();		/* gets real name of default request type */
	target_request_type = "";			/* for move: default is to same request type */
	foreign_system = after (request_type, "To_");
	if foreign_system = "" then foreign_system = request_type;
						/* name apparently not of standard form */
	target_foreign_system = foreign_system;		/* reasonable default */
	remote, target_remote = "0"b;
	queue = -1;				/* search all queues by default. */
	target_queue = 0;				/* use default queue */

	user_selection = USER;			/* default is -own */
	long = "1"b;				/* default is -long */

	unspec (local_mmi) = ""b;
	local_mmi.version = MSEG_MESSAGE_INFO_V1;

MAIN_CIR_MIR_BLOCK:
	begin;

dcl  identifier_types (n_arguments) fixed binary (2);	/* type of identifier indicated by this argument */
dcl  star_types (n_arguments) fixed binary (2);		/* type of starname for path and entry identifiers */
dcl  dir_uids (n_arguments) bit (36) aligned;		/* UIDs of directory part of pathname identifiers */

	     identifier_types (*) = NONE;
	     star_types (*) = MATCH_ONE;
	     dir_uids (*) = ""b;
	     id_qualifier_idx = 0;			/* index of first -id STR */


/* Scan the argument list, verify the syntax of all request_identifiers, process all control arguments, and apply other
   appropriate defaults */

	     do argument_idx = 1 to n_arguments;

		call cu_$arg_ptr_rel (argument_idx, argument_ptr, argument_lth, code, the_argument_list);
		if code ^= 0 then do;
		     call com_err_ (code, command_name, "Accessing argument #^d.", argument_idx);
		     return;
		end;

		if index (argument, "-") = 1 then	/* a control argument */
		     if (argument = "-destination") | (argument = "-ds") then do;
			remote = "0"b;
			go to FOREIGN_SYSTEM;
		     end;

		     else if (argument = "-source") | (argument = "-sc") then do;
			remote = "1"b;
FOREIGN_SYSTEM:
			call get_next_argument ("A system name", foreign_system);
			if remote then
			     request_type = "From_" || foreign_system;
			else request_type = "To_" || foreign_system;

			call iod_info_$generic_type (request_type, generic_type, code);
			if code ^= 0 then do;	/* couldn't lookup the specified destination */
INVALID_DESTINATION_SPECIFICATION:
			     if code = error_table_$id_not_found then
				call com_err_ (0, command_name, "Unknown ^[source^;destination^].  ""^a""",
				     remote, foreign_system);
			     else call com_err_ (code, command_name, "-^[source^;destination^] ""^a""", remote,
				     foreign_system);
			     return;
			end;
			if generic_type ^= FT_GENERIC_TYPE then do;
			     call com_err_ (0, command_name, "Unknown ^[source^;destination^].  ""^a""", remote,
				foreign_system);
			     return;
			end;
		     end;

		     else if (argument = "-queue") | (argument = "-q") then do;
			call get_next_argument ("A number", queue_string);
			queue = cv_dec_check_ (queue_string, code);
			if code ^= 0 then do;
INVALID_QUEUE_SPECIFICATION:
			     call com_err_ (0, command_name,
				"The queue must be a number between 1 and 4; not ""^a"".", queue_string);
			     return;
			end;
			if (queue < 1) | (queue > 4) then go to INVALID_QUEUE_SPECIFICATION;
		     end;				/* will check if queue is OK for destination later */

		     else if (argument = "-all") | (argument = "-a") then queue = -1;
						/* special indicator to match all queues */

		     else if (argument = "-long") | (argument = "-lg") then long = "1"b;
		     else if (argument = "-brief") | (argument = "-bf") then long = "0"b;

		     else if argument = "-own" then user_selection = USER;
		     else if argument = "-user" then do;
			call get_next_argument ("A user ID", user_id);
			if after (after (user_id, "."), ".") ^= "" then do;
			     call com_err_ (0, command_name, "Invalid syntax for user ID.  ""^a""", user_id);
			     return;
			end;
			match_any_person = (before (user_id, ".") = "") | (before (user_id, ".") = "*");
			match_any_project = (after (user_id, ".") = "") | (after (user_id, ".") = "*");
			if match_any_person & match_any_project then
			     user_selection = ALL;
			else do;			/* matches a subset of all users */
			     user_selection = SUBSET;
			     person_id = before (user_id, ".");
			     if person_id = "" then person_id = "*";
			     project_id = after (user_id, ".");
			     if project_id = "" then project_id = "*";
			     user_id = rtrim (person_id) || "." || project_id;
			end;
		     end;

		     else if (function = MOVE) & ((argument = "-to_destination") | (argument = "-tods")) then do;
			target_remote = "0"b;
			go to TARGET_FOREIGN_SYSTEM;
		     end;

		     else if (function = MOVE) & ((argument = "-to_source") | (argument = "-tosc")) then do;
			target_remote = "1"b;
TARGET_FOREIGN_SYSTEM:
			call get_next_argument ("A system name", target_foreign_system);
			if target_remote then
			     target_request_type = "From_" || target_foreign_system;
			else target_request_type = "To_" || target_foreign_system;

			call iod_info_$generic_type (target_request_type, generic_type, code);
			if code ^= 0 then do;	/* couldn't lookup the specified destination */
INVALID_TARGET_DESTINATION_SPECIFICATION:
			     if code = error_table_$id_not_found then
				call com_err_ (0, command_name, "Unknown ^[source^;destination^].  ""^a""",
				     target_remote, target_foreign_system);
			     else call com_err_ (code, command_name, "-^[source^;destination^] ""^a""",
				     target_remote, target_foreign_system);
			     return;
			end;
			if generic_type ^= FT_GENERIC_TYPE then do;
			     call com_err_ (0, command_name, "Unknown ^[source^;destination^].  ""^a""",
				target_remote, target_foreign_system);
			     return;
			end;
		     end;

		     else if (function = MOVE) & ((argument = "-to_queue") | (argument = "-tq")) then do;
			call get_next_argument ("A number", queue_string);
			target_queue = cv_dec_check_ (queue_string, code);
			if code ^= 0 then do;
INVALID_TARGET_QUEUE_SPECIFICATION:
			     call com_err_ (0, command_name,
				"The target queue must be a number between 1 and 4; not ""^a"".", queue_string);
			     return;
			end;
			if (target_queue < 1) | (target_queue > 4) then go to INVALID_TARGET_QUEUE_SPECIFICATION;
		     end;				/* will check if queue is OK for destination later */

		     else if (argument = "-entry") | (argument = "-et") then do;
			call get_next_argument ("A starname", an_ename);
			call check_star_name_$entry (an_ename, code);
			if (code ^= 0) & (code ^= 1) & (code ^= 2) then do;
			     call com_err_ (code, command_name, "^a", an_ename);
			     return;
			end;
			n_identifiers.entry = n_identifiers.entry + 1;
			identifier_types (argument_idx) = ENTRY;
			star_types (argument_idx) = code;
		     end;

		     else if argument = "-id" then do;
			call get_next_argument ("A request ID match strin", request_id_nonvarying);
			request_id = rtrim (request_id_nonvarying);
			if verify (request_id, "0123456789.") ^= 0 then do;
INVALID_REQUEST_ID:
			     call com_err_ (0, command_name,
				"Improper syntax for a request ID match string.  ""^a""", request_id);
			     return;
			end;
			if after (after (request_id, "."), ".") ^= "" then go to INVALID_REQUEST_ID;
			if length (before (request_id, ".")) > length ("YYMMDDHHMMSS") then
			     go to INVALID_REQUEST_ID;
			if length (after (request_id, ".")) > length ("FFFFFF") then go to INVALID_REQUEST_ID;
			n_identifiers.id = n_identifiers.id + 1;
			identifier_types (argument_idx) = ID;
			star_types (argument_idx) = MATCH_SUBSET;
			if id_qualifier_idx = 0 then id_qualifier_idx = argument_idx;
		     end;				/* record index of first -id STR */

		     else do;
			call com_err_ (error_table_$badopt, command_name, """^a""", argument);
			return;
		     end;

		else do;				/* a pathname identifier */
		     call expand_pathname_ (argument, a_dirname, an_ename, code);
		     if code ^= 0 then do;
			call com_err_ (code, command_name, "^a", argument);
			return;
		     end;
		     call check_star_name_$entry (an_ename, code);
		     if (code ^= 0) & (code ^= 1) & (code ^= 2) then do;
			call com_err_ (code, command_name, "^a", pathname_ (a_dirname, an_ename));
			return;
		     end;
		     n_identifiers.path = n_identifiers.path + 1;
		     identifier_types (argument_idx) = PATH;
		     star_types (argument_idx) = code;
		     call hcs_$status_long (a_dirname, "", CHASE, addr (local_sb), null (), code);
		     if (code = 0) | (code = error_table_$no_s_permission) then
			dir_uids (argument_idx) = local_sb.uid;
		end;				/* get the UID now: will need it later */
	     end;

	     if (n_identifiers.path + n_identifiers.entry + n_identifiers.id) = 0 then go to PRINT_USAGE_MESSAGE;

	     if ((n_identifiers.path + n_identifiers.entry) > 0) & (n_identifiers.id > 1) then do;
		call com_err_ (error_table_$inconsistent, command_name,
		     "More than one ""-id"" control argument with path/entry identifiers.");
		return;
	     end;

	     call iod_info_$queue_data (request_type, default_queue, max_queues, code);
	     if code ^= 0 then go to INVALID_DESTINATION_SPECIFICATION;
	     if queue = 0 then queue = default_queue;	/* supply default if needed */
	     if queue > max_queues then do;
		call com_err_ (0, command_name, "^[Source^;Destination^] ^a has only ^d queue^[s^]; you specified queue ^d.",
		     remote, request_type, max_queues, (max_queues ^= 1), queue);
		return;
	     end;

	     if function = MOVE then do;		/* apply defaults for -to_destination and -to_queue */
		if (remote & ^target_remote) | (^remote & target_remote) then do;
		     call com_err_ (error_table_$inconsistent, command_name,
			"Cannot move a request ^[from^;to^] a destination queue ^[to^;from^] a source queue.",
			target_remote, target_remote);
		     return;
		end;

		if target_request_type = "" then target_request_type = request_type;
		call iod_info_$queue_data (target_request_type, default_queue, target_max_queues, code);
		if code ^= 0 then go to INVALID_TARGET_DESTINATION_SPECIFICATION;
		if target_queue = 0 then target_queue = default_queue;
		if target_queue > target_max_queues then do;
		     call com_err_ (0, command_name, "^[Source^;Destination^] ^a has only ^d queue^[s^]; you specified queue ^d.",
			target_remote, target_request_type, target_max_queues, (target_max_queues ^= 1), target_queue);
		     return;
		end;
		if (target_request_type = request_type) & (target_queue = queue) then do;
		     call com_err_ (0, command_name,
			"^a queue ^d was specified as the source and target for moving requests.", request_type,
			queue);
		     return;
		end;
	     end;

/**/

/* Fetch the next argument */

get_next_argument:
     procedure (p_arg_description, p_argument);

dcl  p_arg_description character (*) parameter;
dcl  p_argument character (*) parameter;
dcl  control_argument character (32);

	control_argument = argument;			/* save control arg's name for error messages */

	if argument_idx = n_arguments then do;		/* there is no next argument */
	     call com_err_ (error_table_$noarg, command_name, "^a must follow ""^a"".", p_arg_description,
		control_argument);
	     go to ABORT_ARGUMENT_PARSE;
	end;

	argument_idx = argument_idx + 1;

	call cu_$arg_ptr_rel (argument_idx, argument_ptr, argument_lth, code, the_argument_list);
	if code ^= 0 then do;
	     call com_err_ (code, command_name, "Accessing argument #^d.", argument_idx);
	     go to ABORT_ARGUMENT_PARSE;
	end;

	if argument_lth > length (p_argument) then do;	/* it's too long */
	     call com_err_ (0, command_name, "Value after ""^a"" may not be longer than ^d characters.  ""^a""",
		control_argument, length (p_argument), argument);
	     go to ABORT_ARGUMENT_PARSE;
	end;

	p_argument = argument;			/* it's OK */

	return;

     end get_next_argument;

/**/

/* Argument parsing completed: open the appropriate queues and determine if the user has sufficient access */

	     system_area_ptr = get_system_free_area_ ();

	     queue_indeces (*), target_queue_index = 0;	/* for cleanup handler */
	     message_ids_ptr, ft_request_ptr = null ();

	     on condition (cleanup) call cleanup_handler ();

	     if user_selection = USER then do;
		access_required = O_EXTENDED_ACCESS;
		local_mmi.own = "1"b;
	     end;
	     else 				/* user wants to manipulate someone else's requests */
		access_required = RD_EXTENDED_ACCESS;


	     on condition (linkage_error)
		begin;				/* in case the user doesn't have access to queue_admin_ */
		     call com_err_ (0, command_name, "You do not have permission to move other users' requests.");
		     go to RETURN_FROM_CIR_MIR_COMMANDS;
		end;

	     if function = MOVE then			/* moving requests ... */
		if user_selection = USER then		/* ... only moving our own requests */
		     add_entry = message_segment_$add_index;
		else add_entry = queue_admin_$add_index;/* ... moving others' requests: need to preserve user ID */

	     if queue = -1 then do;			/* want to examine all the queues */
		all_queues = "1"b;			/* need to remember this option later */
		opened_a_queue = "0"b;
		do queue_idx = 1 to max_queues;
		     if (function = MOVE) & (request_type = target_request_type) & (queue = target_queue) then
			;			/* won't be moving things out of this queue */
		     else call open_single_queue (request_type, queue_idx, queue_indeces (queue_idx), access_required,
			     "0"b, (0));
		     if queue_indeces (queue_idx) ^= 0 then opened_a_queue = "1"b;
		end;
		if ^opened_a_queue then go to RETURN_FROM_CIR_MIR_COMMANDS;
	     end;

	     else do;				/* just one queue please */
		call open_single_queue (request_type, queue, queue_indeces (queue), access_required, "0"b, (0));
		if queue_indeces (queue) = 0 then go to RETURN_FROM_CIR_MIR_COMMANDS;
	     end;					/* couldn't open it: nothing we can do */

	     if function = MOVE then do;		/* open the target queue */
		call open_single_queue (target_request_type, target_queue, target_queue_index, A_EXTENDED_ACCESS,
		     "1"b, n_previous_requests);
		if target_queue_index = 0 then go to RETURN_FROM_CIR_MIR_COMMANDS;
	     end;

/**/

/* Opens a single queue's message segment, validates access, and returns the number of messages therein if desired */

open_single_queue:
     procedure (p_request_type, p_queue, p_queue_index, p_access_required, p_get_message_count, p_message_count);

dcl  p_request_type character (24) parameter;
dcl  (p_queue, p_queue_index, p_message_count) fixed binary parameter;
dcl  p_access_required bit (36) aligned parameter;
dcl  p_get_message_count bit (1) aligned parameter;

dcl  queue_ename character (32);
dcl  queue_picture picture "9";
dcl  queue_mode bit (36) aligned;

	queue_ename = rtrim (p_request_type) || "_" || convert (queue_picture, p_queue) || ".ms";

	call message_segment_$open (imft_data_$queue_dirname, queue_ename, p_queue_index, code);
	if code ^= 0 then do;
	     call com_err_ (code, command_name, "Opening ^a.", pathname_ (imft_data_$queue_dirname, queue_ename));
	     go to RETURN_FROM_CIR_MIR_COMMANDS;
	end;

	call message_segment_$get_mode_index (p_queue_index, queue_mode, code);
	if code ^= 0 then do;
	     call com_err_ (code, command_name, "Determining access to ^a.",
		pathname_ (imft_data_$queue_dirname, queue_ename));
	     go to RETURN_FROM_CIR_MIR_COMMANDS;
	end;

	if (queue_mode & p_access_required) ^= p_access_required then do;
	     call com_err_ (error_table_$moderr, command_name,
		"You do not have ""^[a^s^;^[o^;rd^]^]"" access to ^a queue ^d.",
		(p_access_required = A_EXTENDED_ACCESS), (p_access_required = O_EXTENDED_ACCESS), p_request_type,
		p_queue);
	     call message_segment_$close (p_queue_index, (0));
	     p_queue_index = 0;			/* caller will decide whether or not to punt */
	end;

	if p_get_message_count then do;
	     call message_segment_$get_message_count_index (p_queue_index, p_message_count, code);
	     if code ^= 0 then p_message_count = -1;	/* let caller know we couldn't tell */
	end;

	return;

     end open_single_queue;

/**/

/* Process the requests identifiers:  For each identifier, construct a list of matching messages.  If the identifier is
   not a starname or if it is a starname path/entry identifier and there is also a request ID qualifier, refuse to cancel
   or move any requests if more than one match is found.  Otherwise, perform the cancel or moves as desired */

	     call get_temp_segment_ (command_name, message_ids_ptr, code);
	     if code ^= 0 then do;
		call com_err_ (code, command_name, "Getting a temporary segment.");
		go to RETURN_FROM_CIR_MIR_COMMANDS;
	     end;

	     n_requests_moved = 0;			/* haven't moved anything yet */

	     if ((n_identifiers.path + n_identifiers.entry) > 0) & (n_identifiers.id = 1) then
		call cu_$arg_ptr_rel (id_qualifier_idx, id_qualifier_ptr, id_qualifier_lth, (0), the_argument_list);
	     else do;				/* no -id STR qualifier present: avoid faults */
		id_qualifier_ptr = addr (command_name);
		id_qualifier_lth = 0;
	     end;

	     query_info.version = query_info_version_5;
	     query_info.yes_or_no_sw, query_info.suppress_name_sw = "1"b;

	     do argument_idx = 1 to n_arguments;

		if identifier_types (argument_idx) ^= NONE then do;

		     if (id_qualifier = "") | (identifier_types (argument_idx) ^= ID) then do;
						/* don't bother if this is the -id STR qualifier */

			call cu_$arg_ptr_rel (argument_idx, argument_ptr, argument_lth, (0), the_argument_list);

			if identifier_types (argument_idx) = PATH then
			     call expand_pathname_ (argument, a_dirname, an_ename, (0));

			if star_types (argument_idx) = MATCH_ALL then do;
			     call command_query_ (addr (query_info), answer, command_name,
				"Do you want to ^[cancel^;move^] all ^[your ^]requests^[ for ^a^;^s^]^[ from directory ^a^;^s^] in ^[all ^;^]^a queue^[ ^d^;s^]?"
				, (function = CANCEL), (user_selection = USER), (user_selection = SUBSET),
				user_id, (identifier_types (argument_idx) = PATH), a_dirname, all_queues,
				request_type, (queue ^= -1), queue);
			     if answer = "no" then go to PROCESS_NEXT_IDENTIFIER;
			end;

			n_requests_selected = 0;

			do queue_idx = 1 to max_queues;
			     if queue_indeces (queue_idx) ^= 0 then call scan_single_queue (queue_idx);
			end;

			if n_requests_selected = 0 then do;
			     if long then		/* nothing found that matches */
				call com_err_ (0, command_name,
				     "No matching requests found in ^a queue^[s^s^; ^d^] for ^[^a^s^s^;^s^[-entry^;-id^] ^a^]^[ -id ^a^]."
				     , request_type, all_queues, queue, (identifier_types (argument_idx) = PATH),
				     pathname_ (a_dirname, an_ename), (identifier_types (argument_idx) = ENTRY),
				     argument, (id_qualifier ^= ""), id_qualifier);
			     go to PROCESS_NEXT_IDENTIFIER;
			end;

			if ((star_types (argument_idx) = MATCH_ONE) | (id_qualifier ^= ""))
						/* non-starname or a qualified starname ... */
			     & (n_requests_selected > 1) then do;
						/* ... should only match one request */
			     call com_err_ (0, command_name,
				"^d matching requests found in ^a queue^[s^s^; ^d^] for ^[^a^s^s^;^s^[-entry^;-id^] ^a^]^[ -id ^a^;^s^]; no requests will be ^[cancelled^;moved^]."
				, n_requests_selected, request_type, all_queues, queue,
				(identifier_types (argument_idx) = PATH), pathname_ (a_dirname, an_ename),
				(identifier_types (argument_idx) = ENTRY), argument, (id_qualifier ^= ""),
				id_qualifier, (function = CANCEL));
			     go to PROCESS_NEXT_IDENTIFIER;
			end;

			do message_idx = 1 to n_requests_selected;
			     if function = CANCEL then
				call cancel_single_request ();
			     else call move_single_request ();
			end;
		     end;
		end;

PROCESS_NEXT_IDENTIFIER:
	     end;

	     if (function = MOVE) & (n_requests_moved > 0) & long then
		call ioa_ ("^d request^[s^] moved^[; ^d already in^;to^s^] ^a queue ^d.", n_requests_moved,
		     (n_requests_moved > 1), (n_previous_requests ^= -1), n_previous_requests, target_request_type,
		     target_queue);

/**/

/* Scan a single queue for matching requests and record their message IDs */

scan_single_queue:
     procedure (p_queue);

dcl  p_queue fixed binary parameter;

dcl  user_id character (30);
dcl  previous_message_id bit (72) aligned;
dcl  request_uid bit (36) aligned;
dcl  retry_read bit (1) aligned;

	retry_read = "0"b;				/* this isn't a retry */

RETRY_FIRST_READ:
	local_mmi.message_code = MSEG_READ_FIRST;
	call message_segment_$read_message_index (queue_indeces (p_queue), system_area_ptr, addr (local_mmi), code);
	if ^retry_read then
	     if code = error_table_$bad_segment then do;
		retry_read = "1"b;			/* queue might have been salvaged: try again */
		go to RETRY_FIRST_READ;
	     end;


	do while (code = 0);			/* while we've got a message */

	     previous_message_id = local_mmi.ms_id;	/* needed to read the next message */

	     ft_request_ptr = local_mmi.ms_ptr;
	     user_id = substr (local_mmi.sender_id, 1, (length (rtrim (local_mmi.sender_id)) - 2));

	     if (ft_request.hdr_version ^= queue_msg_hdr_version_1) | (ft_request.version ^= FT_REQUEST_VERSION_1)
	     then do;				/* unrecognized message format */
		if user_selection = SUBSET then do;	/* ... check if it's from the right user anyway */
		     if person_id ^= "*" then
			if before (user_id, ".") ^= person_id then go to SKIP_THIS_MESSAGE;
		     if project_id ^= "*" then
			if after (user_id, ".") ^= project_id then go to SKIP_THIS_MESSAGE;
		end;
		if (identifier_types (argument_idx) ^= ENTRY) | (star_types (argument_idx) ^= MATCH_ALL) then
		     go to SKIP_THIS_MESSAGE;		/* ... not cancelling/moving any request in the queue */
		go to ADD_THIS_MESSAGE;		/* get here iff it's OK as far as we can tell */
	     end;

	     if user_selection = SUBSET then do;	/* check if it's from the correct user */
		if person_id ^= "*" then
		     if before (user_id, ".") ^= person_id then go to SKIP_THIS_MESSAGE;
		if project_id ^= "*" then
		     if after (user_id, ".") ^= project_id then go to SKIP_THIS_MESSAGE;
	     end;

	     if identifier_types (argument_idx) = PATH then do;
		call match_star_name_ ((ft_request.ename), an_ename, code);
		if code ^= 0 then go to SKIP_THIS_MESSAGE;
		call hcs_$status_long ((ft_request.dirname), "", CHASE, addr (local_sb), null (), code);
		if (code = 0) | (code = error_table_$no_s_permission) then
		     request_uid = local_sb.uid;	/* need UID of directory to test for a match */
		else request_uid = ""b;
		if (request_uid ^= ""b) & (dir_uids (argument_idx) ^= ""b) then
		     if request_uid = dir_uids (argument_idx) then
			;			/* directory UIDs match: this is still a candidate */
		     else go to SKIP_THIS_MESSAGE;
		else if (request_uid = ""b) & (dir_uids (argument_idx) = ""b) then
		     if ft_request.dirname = a_dirname then
			;			/* directory pathnames match */
		     else go to SKIP_THIS_MESSAGE;
		else go to SKIP_THIS_MESSAGE;		/* could get one dir UID but not the other: can't match */
	     end;

	     else if identifier_types (argument_idx) = ENTRY then do;
		call match_star_name_ ((ft_request.ename), argument, code);
		if code ^= 0 then go to SKIP_THIS_MESSAGE;
	     end;					/* entry names only need to match */

	     else do;				/* must be a request ID match string */
		if ^match_request_id_ (ft_request.msg_time, argument) then go to SKIP_THIS_MESSAGE;
	     end;

	     if ((identifier_types (argument_idx) = PATH) | (identifier_types (argument_idx) = ENTRY))
		& (id_qualifier ^= "") then do;	/* further qualified by a request ID match string */
		if ^match_request_id_ (ft_request.msg_time, id_qualifier) then go to SKIP_THIS_MESSAGE;
	     end;

ADD_THIS_MESSAGE:					/* here iff it matches */
	     n_requests_selected = n_requests_selected + 1;
	     message_ids.id (n_requests_selected) = local_mmi.ms_id;
	     message_ids.queue (n_requests_selected) = p_queue;

SKIP_THIS_MESSAGE:
	     free ft_request in (system_area);		/* done with this request for now */
	     ft_request_ptr = null ();

	     retry_read = "0"b;			/* first attempt to read the next message */

RETRY_READ_NEXT_MESSAGE:
	     local_mmi.message_code = MSEG_READ_AFTER_SPECIFIED;
	     local_mmi.ms_id = previous_message_id;
	     call message_segment_$read_message_index (queue_indeces (p_queue), system_area_ptr, addr (local_mmi), code);
	     if ^retry_read then
		if code = error_table_$bad_segment then do;
		     retry_read = "1"b;		/* message segment may have been salvaged */
		     go to RETRY_READ_NEXT_MESSAGE;
		end;
	end;

	if (code ^= 0) & (code ^= error_table_$no_message) then do;
	     call com_err_ (code, command_name, "Reading from ^a queue ^d.", request_type, p_queue);
	     call message_segment_$close (queue_indeces (p_queue), (0));
	     queue_indeces (p_queue) = 0;		/* fatal error while reading: drop this queue */
	end;

	return;

     end scan_single_queue;

/**/

/* Cancel a single IMFT request unless it is already running */

cancel_single_request:
     procedure ();

dcl  user_id character (30);
dcl  message_id bit (72) aligned;
dcl  queue fixed binary;
dcl  (retry_operation, supported_version) bit (1) aligned;

	queue = message_ids.queue (message_idx);	/* make local copies for future reference */
	message_id = message_ids.id (message_idx);

	retry_operation = "0"b;
READ_THE_MESSAGE:
	local_mmi.message_code = MSEG_READ_SPECIFIED;
	local_mmi.ms_id = message_id;
	call message_segment_$read_message_index (queue_indeces (queue), system_area_ptr, addr (local_mmi), code);
	if ^retry_operation then
	     if code = error_table_$bad_segment then do;
		retry_operation = "1"b;		/* message segment has been salvaged */
		go to READ_THE_MESSAGE;
	     end;

	if code ^= 0 then do;			/* couldn't get the message: OK if someone else deleted it */
	     if code ^= error_table_$no_message then
		call com_err_ (code, command_name, "Attempting to read message ^24.3b from ^a queue ^d.", message_id,
		     request_type, queue);
	     return;
	end;

	ft_request_ptr = local_mmi.ms_ptr;
	user_id = substr (local_mmi.sender_id, 1, (length (rtrim (local_mmi.sender_id)) - 2));

	if (ft_request.hdr_version = queue_msg_hdr_version_1) & (ft_request.version = FT_REQUEST_VERSION_1) then do;
	     supported_version = "1"b;		/* understand this request: check if it's running */
	     if ft_request.state = STATE_RUNNING then do;
		call com_err_ (0, command_name,
		     "IMFT request ^a^[ for ^a^;^s^] is already running and will not be cancelled.", ft_request.ename,
		     (user_selection ^= USER), user_id);
		go to RETURN_FROM_CANCEL_SINGLE_REQUEST;
	     end;
	end;
	else supported_version = "0"b;		/* controls the message that's printed */

	retry_operation = "0"b;			/* now to try to delete (cancel) the message */
RETRY_DELETE_MESSAGE:
	call message_segment_$delete_index (queue_indeces (queue), message_id, code);
	if ^retry_operation then
	     if code = error_table_$bad_segment then do;
		retry_operation = "1"b;		/* message segment was salvaged: try again */
		go to RETRY_DELETE_MESSAGE;
	     end;

	if (code ^= 0) & (code ^= error_table_$no_message) then do;
	     call com_err_ (code, command_name,
		"Unable to cancel IMFT request ^[^a^s^;^s^24.3b^]^[ for ^a^;^s^] from ^a queue ^d.",
		supported_version, ft_request.ename, message_id, (user_selection ^= USER), user_id, request_type,
		queue);
	     go to RETURN_FROM_CANCEL_SINGLE_REQUEST;
	end;

	if long & ((star_types (argument_idx) ^= MATCH_ONE) | all_queues) then
	     call ioa_ ("IMFT request ^[^a^s^;^s^24.3b^]^[ for ^a^;^s^] cancelled^[ from queue ^d^].",
		supported_version, ft_request.ename, message_id, (user_selection ^= USER), user_id, all_queues, queue)
		;

RETURN_FROM_CANCEL_SINGLE_REQUEST:
	free ft_request in (system_area);
	ft_request_ptr = null ();

	return;

     end cancel_single_request;

/**/

/* Move a single IMFT request to the target queue unless it is already running */

move_single_request:
     procedure ();

dcl  user_id character (30);
dcl  request_id character (8);
dcl  message_id bit (72) aligned;
dcl  queue fixed binary;
dcl  (retry_operation, supported_version) bit (1) aligned;

	queue = message_ids.queue (message_idx);	/* make local copies for future reference */
	message_id = message_ids.id (message_idx);

	retry_operation = "0"b;
READ_THE_MESSAGE:
	local_mmi.message_code = MSEG_READ_SPECIFIED;
	local_mmi.ms_id = message_id;
	call message_segment_$read_message_index (queue_indeces (queue), system_area_ptr, addr (local_mmi), code);
	if ^retry_operation then
	     if code = error_table_$bad_segment then do;
		retry_operation = "1"b;		/* message segment has been salvaged */
		go to READ_THE_MESSAGE;
	     end;

	if code ^= 0 then do;			/* couldn't get the message: OK if someone else deleted it */
	     if code ^= error_table_$no_message then
		call com_err_ (code, command_name, "Attempting to read message ^24.3b from ^a queue ^d.", message_id,
		     request_type, queue);
	     return;
	end;

	ft_request_ptr = local_mmi.ms_ptr;
	user_id = substr (local_mmi.sender_id, 1, (length (rtrim (local_mmi.sender_id)) - 2));

	if (ft_request.hdr_version = queue_msg_hdr_version_1) & (ft_request.version = FT_REQUEST_VERSION_1) then do;
	     supported_version = "1"b;		/* understand this request: check if it's running */
	     if ft_request.state = STATE_RUNNING then do;
		call com_err_ (0, command_name,
		     "IMFT request ^a^[ for ^a^;^s^] is already running and will not be moved.", ft_request.ename,
		     (user_selection ^= USER), user_id);
		go to RETURN_FROM_MOVE_SINGLE_REQUEST;
	     end;
	end;
	else supported_version = "0"b;		/* controls the message that's printed */

	ft_request.state = STATE_UNPROCESSED;

	if user_selection = USER then
	     call message_segment_$add_index (target_queue_index, ft_request_ptr, (36 * currentsize (ft_request)),
		((72)"0"b), code);
	else call queue_admin_$add_index (target_queue_index, addr (local_mmi), ((72)"0"b), code);

	if code ^= 0 then do;			/* couldn't move the request (sigh) */
	     call com_err_ (code, command_name,
		"Unable to move IMFT request ^[^a^s^;^s^24.3b^]^[ for ^a^;^s^] from ^a queue ^d to ^[^a ^;^s]queue ^d."
		, supported_version, ft_request.ename, message_id, (user_selection ^= USER), user_id, request_type,
		queue, (request_type ^= target_request_type), target_request_type, target_queue);
	     go to RETURN_FROM_MOVE_SINGLE_REQUEST;
	end;

	n_requests_moved = n_requests_moved + 1;	/* it now counts as being moved */

	if long then do;
	     request_id = substr ((request_id_ (ft_request.msg_time)), 7, 8);
	     call ioa_ ("IMFT request ^[^a^s^;^s^24.3b^]^[ for ^a^;^s^] moved from ^a queue ^d; ID: ^a.",
		supported_version, ft_request.ename, message_id, (user_selection ^= USER), user_id, request_type,
		queue, request_id);
	end;					/* target destination/queue are given in summary message */

	retry_operation = "0"b;			/* now to try to delete the original copy */
RETRY_DELETE_MESSAGE:
	call message_segment_$delete_index (queue_indeces (queue), message_id, code);
	if ^retry_operation then
	     if code = error_table_$bad_segment then do;
		retry_operation = "1"b;		/* message segment was salvaged: try again */
		go to RETRY_DELETE_MESSAGE;
	     end;

	if (code ^= 0) & (code ^= error_table_$no_message) then
	     call com_err_ (code, command_name,
		"IMFT request ^[^a^s^;^s^24.3b^]^[ for ^a^;^s^] added to ^a queue ^d but could not be deleted from ^a queue ^d."
		, supported_version, ft_request.ename, message_id, (user_selection ^= USER), user_id,
		target_request_type, target_queue, request_type, queue);

RETURN_FROM_MOVE_SINGLE_REQUEST:
	free ft_request in (system_area);
	ft_request_ptr = null ();

	return;

     end move_single_request;

	end MAIN_CIR_MIR_BLOCK;

/**/

RETURN_FROM_CIR_MIR_COMMANDS:
	call cleanup_handler ();

ABORT_ARGUMENT_PARSE:
	return;


/* Cleanup after an invocation of cancel_imft_request or move_imft_request */

cleanup_handler:
     procedure ();

	if ft_request_ptr ^= null () then do;
	     free ft_request in (system_area);
	     ft_request_ptr = null ();
	end;

	if message_ids_ptr ^= null () then do;
	     call release_temp_segment_ (command_name, message_ids_ptr, (0));
	     message_ids_ptr = null ();
	end;

	do queue_idx = 1 to max_queues;
	     if queue_indeces (queue_idx) ^= 0 then do;
		call message_segment_$close (queue_indeces (queue_idx), (0));
		queue_indeces (queue_idx) = 0;
	     end;
	end;

	if target_queue_index ^= 0 then do;
	     call message_segment_$close (target_queue_index, (0));
	     target_queue_index = 0;
	end;

	return;

     end cleanup_handler;

/**/

%include mseg_message_info;
%page;
%include queue_msg_hdr;
%page;
%include "_imft_ft_request";
%page;
%include status_structures;
%page;
%include query_info;

     end imft_cir_mir_commands_;
