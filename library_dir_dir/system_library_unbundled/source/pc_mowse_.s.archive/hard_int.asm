; ***********************************************************
; *                                                         *
; * Copyright, (C) Honeywell Bull Inc., 1987                *
; *                                                         *
; * Copyright, (C) Honeywell Information Systems Inc., 1986 *
; *                                                         *
; ***********************************************************

PAGE 55,132
; HISTORY COMMENTS:
;  1) change(85-12-18,Flegel), approve(87-07-13,MCR7580),
;     audit(87-07-13,Leskiw), install(87-08-07,MR12.1-1072):
;     Created.
;  2) change(86-01-30,Flegel), approve(87-07-13,MCR7580),
;     audit(87-07-13,Leskiw), install(87-08-07,MR12.1-1072):
;     Handle 4 types of interrupts: receive data,
;      transmit holding empty, break character/framing error, change in modem
;      status.
;  3) change(86-04-26,Westcott), approve(87-07-13,MCR7580),
;     audit(87-07-13,Leskiw), install(87-08-07,MR12.1-1072):
;     Installed circular input buffer (inbuff) to
;      store error messages.
;  4) change(86-08-29,Flegel), approve(87-07-13,MCR7580),
;     audit(87-07-13,Leskiw), install(87-08-07,MR12.1-1072):
;     Check line status for DR (data ready) when
;      done current interrupt.
;  5) change(86-09-12,Flegel), approve(87-07-13,MCR7580),
;     audit(87-07-13,Leskiw), install(87-08-07,MR12.1-1072):
;     Removed calls to stack alteration routines and
;     left interrupts masked in order to provide faster service to comm line
;     thus removing numerous line overrun errors on the line.
;  6) change(88-01-27,Flegel), approve(88-02-29,MCR7853),
;     audit(88-03-10,Nakaska):
;     Added test in MODEM interrupt section to look for a delta_CTS so that
;     transmitting will begin when a modem connection completes a dial-up
;     and CTS is finally raised.
;                                                      END HISTORY COMMENTS

; PROCEDURE FUNCTION (hardware_interrupt_handler):
;
; Handle all hardware interrupts which are generated by the RS232 port (pass
; control to message handler).

; NOTES:
;
; ES register will be set to contain the DS of the routine which was
; interrupted.

include dos.mac                 ; Lattice include file
include mowsdefs.mac            ; Assembler Definitions
include rs232err.mac            ; Error definitions
include wsmincap.mac            ; Predefined mincaps
include ws_buf.mac              ; Circular buffer definitions
include util.mac                ; macros for saving registers

page
;**************************************************************
;                                       DATA
;**************************************************************
dseg

;--------- External Declarations

extrn transmit_active:word
extrn COM_PORT:word
extrn send_buffer:word

;--------- Structures

dbgs    struc                          ; Debugging structure
old_bp  dw     ?
dbgret  dw     ?
arg1    dw     ?
dbgs    ends

endds

page
;**************************************************************
;                                       MAIN
;**************************************************************
pseg

;-------- External Procedures
extrn   packet_mode:word
extrn   data_seg:word                  ; MOWSE data segment
extrn   put_inbuff:near
extrn   RS232_OUT:near

;-------- Publics

public  sdbgchr
public  hardware_interrupt_handler

hardware_interrupt_handler proc near

        push    ax                     
        push    ds                     ; save interrupted DS register
        SAVEALL                        ; save all registers (except ax)
        mov     ds,CS:data_seg         ; swap in MOWSE's DS

; /* Get interrupt identification

        mov     dx,IIR
        add     dx,COM_PORT
        in      al,dx

; If break character interrupt (BI)
;     - Read LSR to reset interrupt

process_int:
        and     al,MASKBREAK
        cmp     al,LSR_LSTATUS
        jne     test_rcv

break_int:
        push    ax
        mov     dx,LSR                 ;Read the LSR to reset the interrupt
        add     dx,COM_PORT
        in      al,dx
        shr     al,1
        and     al,0fh                 ; mask non_error bits
        mov     ah,LINE_STATUS         ; store LSR error
        call    put_inbuff
        pop     ax
        jmp     done_int

; Else if Data ready (DR)
;      - get character
;      - if (char = ESCAPE_STATUS or LINE_STATUS) escape the character
;        (this is necessary for recording errors received)
;      - store char in buffer

test_rcv:
        cmp     al,LSR_RCV
        jne     sending_int

        mov     dx,RBR                 ;Receive buffer
        add     dx,COM_PORT
        in      al,dx                  ;the char in al

        xor     ah,ah
        cmp     al,ESCAPE_STATUS
        ja      rcv_ok                 ; if received a reserved byte

        cmp     al,LINE_STATUS
        jb      rcv_ok

        mov     ah,ESCAPE_STATUS

rcv_ok:
        call put_inbuff
        jmp  done_int

; Else if transmit holding register clear (THRE)
;      - If character in send buffer, transmit the character

sending_int:
        cmp     al,LSR_THRE
        jne     modem_int

        push    ax

delta_cts_send:                        ; From modem interrupt

        get_buf send_buffer            ; get another character from send buffer
        jnc     done_trans             ; if send buffer empty

        call    RS232_OUT              ; send the character
        pop     ax
        jmp     done_int

; - Else clear transmit active flag

done_trans:
        mov     transmit_active,0
        pop     ax
        jmp     done_int

; Else if Modem error (OE | PE | FE)
;      - Read MSR to reset interrupt
;      - Store the status character into receive buffer

modem_int:
        cmp     al,MASKMCHNG
        jne     done_int

; What happened on the modem

        push    ax
        mov     dx,MSR                 ;Read the MSR to reset the interrupt
        add     dx,COM_PORT
        in      al,dx
        and     al,0fh                 ; mask non_error bits

; If it was a delta CTS and CTS went high, then try and send data

        test    al,00000001b           ; Delta CTS (change in CTS) ?
        je      no_delta_cts           ;  NO - an error

        test    al,MSRCTS              ; Clear to send?
        jne     delta_cts_send         ; YES - try and send something

no_delta_cts:

        mov     ah,MODEM_STATUS
        call    put_inbuff             ; store modem status
        pop     ax

; Check the IIR if there is a pending interrupt

done_int:
        mov     dx,IIR                 ;IIR register
        add     dx,COM_PORT
        in      al,dx
        test    al,IIR_PENDING         ; test pending flag
        jne     test_dr
        jmp     process_int

; Check DR from the LSR

test_dr:
        mov     dx,LSR
        add     dx,COM_PORT
        in      al,dx
        test    al,1
        je      finished_int
        jmp     process_int

; Signal 8259 that we are done

finished_int:
        mov     al,MASKEOI             ;Non-Specific EOI (end-of-interrupt)
        out     OMR8259,al             ;Send it out port 20h ie 8259 INT CON

        RESTOREALL                     ; restore all registers (except ax)
        pop     ds
        pop     ax
        iret

;END hardware_interrupt_handler

hardware_interrupt_handler endp


; INTERNAL PROCEDURE FUNCTION (sdbgchr):
;
; Write debug char to screen

sdbgchr proc near
        push    bp
        mov     bp,sp
        mov     ax,arg1[bp]
        mov     ah,0Eh          ;Force character to screen function
        and     al,7fh          ;ensure highlight bit is off
        xor     bx,bx
        int     10h             ;send char to screen
        pop     bp
        ret

sdbgchr endp
        endps
        end
