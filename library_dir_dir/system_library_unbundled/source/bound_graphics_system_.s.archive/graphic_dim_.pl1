/* ***********************************************************
   *                                                         *
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
   *                                                         *
   *                                                         *
   *********************************************************** */

/* ******************************************************
   *                                                    *
   *                                                    *
   * Copyright (c) 1972 by Massachusetts Institute of   *
   * Technology and Honeywell Information Systems, Inc. *
   *                                                    *
   *                                                    *
   ****************************************************** */

/* format: style1,^inddcls,ifthenstmt,ifthendo,ifthen,indcomtxt,dclind5 */
graphic_dim_: proc; return;

/* This routine is a graphic device interface module.
   It handles both dynamic and static devices.		*/

/* Written on July 1, 1973 by C. D. Tavares
   Modified 08/79 by CDT to use get_temp_segments_
   Modified 04/25/80 by CDT to replace random signals with calls to sub_err_.
   Modified 08/26/80 by CDT to fix bug leaving user in rawo if GSP close entry
   did any output.  The fix was wrong, by the way, but fixed on 11/18/80.
   Last modified 11/18/80 by CDT-- totally rewritten, and two-pass MSGC parsing
   with blocked, interleaved output implemented.
*/


/* STATIC */

dcl  1 static_stuff	        static,
       2 sys_area_p	        pointer initial (null),
       2 first_dsb_ptr      pointer initial (null),
       2 stack_p	        pointer initial (null),
       2 stack_size	        fixed bin initial (0),
       2 max_string_size    fixed bin (21) fixed bin initial (0),
       2 noecho_mode        char (40)
		        initial ("^echoplex,^tabecho,^crecho,^lfecho,rawi"),
       2 rawo_mode	        char (12) initial ("rawo."),
       2 rawi_mode	        char (16) initial ("^can,^esc,^erkl");

/* we use ^can,^esc,^erkl instead of rawi because ttydim doesn't always wait
   for newlines in rawi mode also because ARPANET software doesn't honor
   rawi. */


/* BASED */

dcl  1 switch_data_block    based (sdb_ptr),
       2 target_switch_ptr  pointer,
       2 graphic	        bit (1),
       2 device_state_block_ptr
		        pointer,
       2 from_switch        char (32),
       2 n_buffers	        fixed bin,
       2 output_buffer_ptr  pointer,
       2 expansion_buffer_ptr
		        pointer,
       2 node_table_ptr     pointer,
       2 n_nodes_in_list    fixed bin,
       2 status_buffer      char (100),
       2 attach_description char (128) varying,
       2 open_description   char (64) varying,
       2 atd_len_no_gdt     fixed bin;

dcl  1 device_state_block   based (cur_dsb_ptr),
       2 in_rawo_mode       bit (1),
       2 gdt_ptr	        pointer,
       2 gdt_name	        char (32),
       2 gdt_proc	        entry (fixed bin, char (*), char (*),
		        fixed bin (21), pointer, fixed bin (35)) variable,
       2 gdt_opened	        bit (1),
       2 dynamic	        bit (1),
       2 gdt_message_size   fixed bin (21),
       2 reference_count    fixed bin,
       2 switch_name        char (32),
       2 target_ptr	        pointer,
       2 old_output_modes   char (512) initial (""),
       2 old_input_modes    char (512) initial (""),
       2 gdt_data_ptr       pointer,
       2 next_dsb_ptr       pointer;

dcl  based_buffer_ptrs      (switch_data_block.n_buffers) pointer
		        based (addr (switch_data_block.output_buffer_ptr)),
     char_array	        (static_stuff.max_string_size)
		        char (1) unaligned based,
     output_buffer	        char (max_string_size)
		        based (switch_data_block.output_buffer_ptr),
     sys_area	        area based (sys_area_p);


/* ENTRIES */

dcl  com_err_	        ext entry options (variable),
     expand_pathname_       ext entry
		        (char (*), char (*), char (*), fixed bin (35)),
     find_command_$fc_no_message
		        ext entry
		        (pointer, fixed bin, pointer, fixed bin (35)),
     get_system_free_area_  ext entry returns (pointer),
     get_temp_segments_     ext entry
		        (char (*), pointer dimension (*), fixed bin (35)),
     graphic_compiler_$expand_string
		        entry
		        (char (*), fixed bin (21), ptr, fixed bin (21),
		        fixed bin (35)),
     graphic_element_length_
		        entry
		        (char (*), fixed bin (21)) returns (fixed bin),
     graphic_terminal_status_$decode
		        ext entry (char (*), fixed bin (35)),
     hcs_$make_entry        ext entry
		        (ptr, char (*), char (*), entry, fixed bin (35)),
     ioa_$rsnnl	        ext entry options (variable),
     ipc_$mask_ev_calls     ext entry (fixed bin (35)),
     ipc_$unmask_ev_calls   ext entry (fixed bin (35)),
     release_temp_segments_ ext entry
		        (char (*), pointer dimension (*), fixed bin (35)),
     sub_err_	        ext entry options (variable);

/* EXTERNAL STATIC */

dcl  (error_table_$bad_index,
     error_table_$badopt,
     error_table_$invalid_mode,
     error_table_$long_record,
     error_table_$negative_nelem,
     error_table_$noarg,
     error_table_$not_attached,
     error_table_$not_detached,
     error_table_$unimplemented_version)
		        fixed bin (35) external static;

dcl  (graphic_error_table_$gdt_missing,
     graphic_error_table_$impossible_effector_length,
     graphic_error_table_$incomplete_structure,
     graphic_error_table_$invalid_node_no,
     graphic_error_table_$node_not_active,
     graphic_error_table_$nongraphic_switch,
     graphic_error_table_$not_a_gdt,
     graphic_error_table_$recursive_structure,
     graphic_error_table_$too_many_node_ends,
     graphic_error_table_$unimplemented_effector,
     graphic_error_table_$unrecognized_effector)
		        fixed bin (35) external static;

dcl  sys_info$max_seg_size  fixed bin (35) external static;

/* CONDITIONS */

dcl  cleanup	        condition;

/* BUILTINS */

dcl  (addr, before, binary, dim, hbound, index, length, max, min, null,
     rank, rtrim, string, substr, unspec)
		        builtin;
%page;
%include iox_dcls;
%page;
%include iocbv;
%page;
%include iox_modes;
%page;
%include graphic_device_table;
%page;
%include graphic_code_dcl;
%page;
%include io_call_info;
%page;
graphic_dim_attach: entry (iocb_ptr, option_array, com_err_sw, code);

/* PARAMETERS */

dcl  (iocb_ptr	        pointer,
     option_array	        (*) char (*) varying,
     com_err_sw	        bit (1) aligned,
     code		        fixed bin (35)) parameter;

/* AUTOMATIC */

dcl  cur_dsb_ptr	        pointer,
     found	        bit (1),
     gdt_name_copy	        char (168),
     output_buffer_outdx    fixed bin (21),
     sdb_ptr	        pointer,
     tp		        pointer;


	sdb_ptr, cur_dsb_ptr = null;

	if iocb.attach_descrip_ptr ^= null then		/* switch in use */
	     call attach_error (error_table_$not_detached);

	if static_stuff.sys_area_p = null then do;	/* initialize it */
		static_stuff.sys_area_p = get_system_free_area_ ();
		static_stuff.max_string_size = sys_info$max_seg_size * 4;
	     end;

	allocate switch_data_block in (sys_area) set (sdb_ptr);

/* Locate the switch which we will be talking to for this attachment. */

	call iox_$find_iocb ((option_array (1)),
	     switch_data_block.target_switch_ptr, code);
	if code ^= 0 then call attach_error (code);

/* Try to find the device state block, if any, already associated with our
   target switch. */

	do tp = static_stuff.first_dsb_ptr repeat (tp -> next_dsb_ptr)
	     while (tp ^= null & cur_dsb_ptr = null);

	     if tp -> device_state_block.switch_name = option_array (1) then
		cur_dsb_ptr = tp;
	end;

/* If we have found an existing dsb, then use it. */

	if cur_dsb_ptr ^= null then do;
		device_state_block.target_ptr =
		     switch_data_block.target_switch_ptr;
		device_state_block.reference_count =
		     device_state_block.reference_count + 1;
	     end;

/* If no dsb for this target switch, create one. */

	else do;
		allocate device_state_block in (sys_area);

		device_state_block.switch_name = option_array (1);
		device_state_block.gdt_ptr,
		     device_state_block.gdt_data_ptr,
		     device_state_block.next_dsb_ptr = null;
		device_state_block.gdt_name = "";
		device_state_block.gdt_proc = not_setup;
		device_state_block.gdt_opened,
		     device_state_block.dynamic,
		     device_state_block.in_rawo_mode = ""b;
		device_state_block.gdt_message_size =
		     static_stuff.max_string_size;
		device_state_block.reference_count = 1;

		if static_stuff.first_dsb_ptr = null then
		     static_stuff.first_dsb_ptr = cur_dsb_ptr;
		else tp -> device_state_block.next_dsb_ptr = cur_dsb_ptr;
	     end;

	switch_data_block.device_state_block_ptr = cur_dsb_ptr;

	switch_data_block.from_switch = iocb.name;
	switch_data_block.output_buffer_ptr,
	     switch_data_block.expansion_buffer_ptr,
	     switch_data_block.node_table_ptr = null;
	switch_data_block.n_nodes_in_list = 0;
	switch_data_block.status_buffer = "";

	if hbound (option_array, 1) < 2 then
	     switch_data_block.graphic = ""b;
	else if option_array (2) = "graphic" then
	     switch_data_block.graphic = "1"b;
	else if option_array (2) = "^graphic" then
	     switch_data_block.graphic = ""b;
	else call attach_error (error_table_$badopt);

	if switch_data_block.graphic then switch_data_block.n_buffers = 2;
	else switch_data_block.n_buffers = 1;

	call get_temp_segments_
	     (temp_seg_name ("graphic_dim_", switch_data_block.from_switch),
	     based_buffer_ptrs, code);
	if code ^= 0 then call attach_error (code);

	switch_data_block.attach_description =
	     "graphic_dim_ " || option_array (1);
	if switch_data_block.graphic then
	     attach_description = attach_description || " graphic";
	switch_data_block.atd_len_no_gdt =
	     length (switch_data_block.attach_description);

	if hbound (option_array, 1) > 2 then do;
		gdt_name_copy = option_array (3);
		call associate_gdt (gdt_name_copy, code);
		if code ^= 0 then call attach_error (code);
	     end;

	iocb.attach_descrip_ptr = addr (attach_description);
	iocb.attach_data_ptr = sdb_ptr;

	iocb.open = graphic_dim_open;
	iocb.detach_iocb = graphic_dim_detach;

	code = 0;

	call iox_$propagate (iocb_ptr);

	return;
%skip (3);
attach_error: proc (code);

dcl  code		        fixed bin (35) parameter;

	if com_err_sw then call com_err_ (code, "graphic_dim_", "");

	if sdb_ptr ^= null then do;
		if cur_dsb_ptr ^= null then
		     if device_state_block.reference_count = 1 then
			call free_dsb (cur_dsb_ptr);
		if switch_data_block.output_buffer_ptr ^= null then
		     call release_temp_segments_
			(temp_seg_name ("graphic_dim_",
			switch_data_block.from_switch),
			based_buffer_ptrs, 0);
		free switch_data_block in (sys_area);
	     end;
	goto attach_error_return;
     end attach_error;

attach_error_return:
	return;
%skip (3);
temp_seg_name: proc (prefix, suffix) returns (char (32));

dcl  (prefix, suffix)       char (*) parameter,
     char32	        char (32) varying;

	char32 = prefix;
	char32 = char32 || " ";
	char32 = char32 || suffix;
	return (char32);
     end temp_seg_name;
%skip (3);
free_dsb: proc (dsb_ptr);

/* PARAMETERS */

dcl  dsb_ptr	        pointer parameter;

/* AUTOMATIC */

dcl  found	        bit (1),
     prev_tp	        pointer,
     tp		        pointer;


	found = ""b;				/* begin to search for block */

/* is this dsb first one on the chain? */

	if dsb_ptr = static_stuff.first_dsb_ptr then do;
		found = "1"b;
		prev_tp = null;
	     end;

/* otherwise, chain down blocks until this dsb found */

	do tp = static_stuff.first_dsb_ptr
	     repeat (tp -> device_state_block.next_dsb_ptr)
	     while (tp ^= null & ^found);
	     prev_tp = tp;
	     if tp -> device_state_block.next_dsb_ptr = dsb_ptr then
		found = "1"b;
	end;

	if ^found then
	     call sub_err_ (error_table_$bad_index, "graphic_dim_", "s",
		null, 0,
		"Cannot find chain predecessor to DSB for ^a.",
		device_state_block.switch_name);	/* stop cold */

/* rechain the chain around this block */

	tp = prev_tp;

	if tp = null then
	     static_stuff.first_dsb_ptr = dsb_ptr -> next_dsb_ptr;
	else tp -> next_dsb_ptr = dsb_ptr -> next_dsb_ptr;


	free dsb_ptr -> device_state_block in (sys_area); /* wham. */

	return;

     end free_dsb;
%skip (3);
associate_gdt: proc (table_name, code);

/* PARAMETERS */

dcl  (table_name	        char (*),
     code		        fixed bin (35)) parameter;

/* AUTOMATIC */

dcl  gdt_entrypoint_name    char (168),
     gdt_ptr	        pointer;

/* BASED */

dcl  1 gdt	        like graphic_device_table aligned based (gdt_ptr);


	if ^switch_data_block.graphic then do;
		code = graphic_error_table_$nongraphic_switch;
		return;
	     end;

/* Find the GDT to be used.  Get a pointer to the start of the table. */

	gdt_entrypoint_name = before (table_name, " ") || "$table_start";

	call find_command_$fc_no_message (addr (gdt_entrypoint_name),
	     length (gdt_entrypoint_name), gdt_ptr, code);
	if code ^= 0 then return;

	if gdt.version_number ^= gdt_version_2 then
	     if gdt.version_number ^= 1 then do;
		     code = error_table_$unimplemented_version;
		     return;
		end;

/* version 1 OK-- differs only in existence of "modes" call */

	if gdt.terminal_type ^= "dyna" then
	     if gdt.terminal_type ^= "stat" then do;	/* must be one! */
		     code = graphic_error_table_$not_a_gdt;
		     return;
		end;

	device_state_block.gdt_ptr = gdt_ptr;

	device_state_block.dynamic = (gdt.terminal_type = "dyna");
	device_state_block.gdt_message_size = gdt.message_size;
	call expand_pathname_
	     (table_name, "", device_state_block.gdt_name, 0);

	switch_data_block.attach_description =
	     substr (switch_data_block.attach_description, 1,
	     switch_data_block.atd_len_no_gdt)
	     || " " || device_state_block.gdt_name;

	call hcs_$make_entry (gdt_ptr, (device_state_block.gdt_name),
	     "gdt_proc", device_state_block.gdt_proc, code);
	if code ^= 0 then return;

/* open the GDT now, unless this switch is not yet opened itself. */

	if iocb.open_descrip_ptr ^= null then
	     call try_to_open_gdt (gdt_ptr, code);

	return;

     end associate_gdt;
%skip (3);
try_to_open_gdt: proc (gdt_ptr, code);

/* PARAMETERS */

dcl  (gdt_ptr	        pointer,
     code		        fixed bin (35)) parameter;

/* BASED */

dcl  1 gdt	        like graphic_device_table aligned based (gdt_ptr);


	if ^device_state_block.gdt_opened then
	     if gdt.effector_data (Open).call then do;
		     call gdt_caller
			(Open, device_state_block.switch_name, code);
		     if code ^= 0 then return;

		     call force_out_buffer ("1"b, code);
		     if code ^= 0 then return;
		end;

	device_state_block.gdt_opened = "1"b;
	return;

     end try_to_open_gdt;
%page;
not_setup: entry (a_effnum, a_instring, a_obuffer, a_nchars, a_statptr, code);

/* This entry exists for the sole purpose of returning an error code.  It is
   called only by mistake when somebody tries to call an entry in the GSP at
   a time when no GDT is yet been associated with the I/O switch. */

/* PARAMETERS */

dcl  (a_effnum	        fixed bin,
     a_instring	        char (*),
     a_obuffer	        char (*),
     a_nchars	        fixed bin (21),
     a_statptr	        pointer) parameter;

	code = graphic_error_table_$gdt_missing;
	return;
%skip (5);
no_entry: entry (a_effnum, a_instring, a_obuffer, a_nchars, a_statptr, code);

/* This entry exists because the graphic_dim_ occasionally tries to "call" an
   operator which has not been given the "call" attribute in the gdt.  (This
   is the default entry that compile_gdt places in the GDT if no call is
   specified.)  Yes, this is dirty.  However, graphic_dim_ only tries to call
   the Prepare_for_graphics and Prepare_for_text entries without actually
   checking if they are callable.  These really should have either the "call"
   or the "ignore"attribute on - others make no sense.  */

	code = 0;
	return;
%page;
graphic_dim_open: entry (iocb_ptr, open_mode, ignore, code);

/* PARAMETERS */

dcl  (open_mode	        fixed bin,
     ignore	        bit (1)) parameter;

	call setup;

	if (open_mode ^= Stream_input)
	     & (open_mode ^= Stream_output)
	     & (open_mode ^= Stream_input_output) then do;
		code = error_table_$invalid_mode;
		return;
	     end;

	if open_mode ^= Stream_input then
	     actual_iocb_ptr -> iocb.put_chars = graphic_dim_write;

	if open_mode ^= Stream_output then do;
		actual_iocb_ptr -> iocb.get_line = graphic_dim_get_line;
		if ^switch_data_block.graphic then
		     actual_iocb_ptr -> get_chars = graphic_dim_get_chars;
	     end;

	actual_iocb_ptr -> iocb.modes = graphic_dim_changemode;
	actual_iocb_ptr -> iocb.control = graphic_dim_order;
	actual_iocb_ptr -> iocb.close = graphic_dim_close;

	switch_data_block.open_description = iox_modes (open_mode);
	iocb.open_descrip_ptr = addr (open_description);

	call iox_$propagate (actual_iocb_ptr);

	if switch_data_block.graphic then
	     call try_to_open_gdt
		(switch_data_block.device_state_block_ptr ->
		device_state_block.gdt_ptr, code);

	return;
%skip (3);
setup: proc;

	sdb_ptr = actual_iocb_ptr -> iocb.attach_data_ptr;
	cur_dsb_ptr = switch_data_block.device_state_block_ptr;
	gdt_pointer = device_state_block.gdt_ptr;
	output_buffer_outdx = 0;
	code = 0;

	return;

     end setup;
%page;
graphic_dim_close: entry (iocb_ptr, code);

	call setup;

	if switch_data_block.graphic then do;

		if device_state_block.gdt_opened then do;
			if device_state_block.in_rawo_mode then do;
				call get_to_text_mode (code);
				if code ^= 0 then return;
			     end;
			if graphic_device_table.effector_data (Close).call
			then do;
				call gdt_caller (Close,
				     device_state_block.switch_name, code);
				if code ^= 0 then return;

				call force_out_buffer ("1"b, code);
				if code ^= 0 then return;

				device_state_block.gdt_opened = ""b;
			     end;
		     end;
	     end;

	actual_iocb_ptr -> iocb.open_descrip_ptr = null;

	actual_iocb_ptr -> iocb.detach_iocb = graphic_dim_detach;
	actual_iocb_ptr -> iocb.open = graphic_dim_open;
	actual_iocb_ptr -> iocb.control = iox_$err_no_operation;

	call iox_$propagate (actual_iocb_ptr);

	code = 0;

	return;
%page;
graphic_dim_detach: entry (iocb_ptr, code);

	call setup;

	call release_temp_segments_
	     (temp_seg_name ("graphic_dim_", switch_data_block.from_switch),
	     based_buffer_ptrs, code);
	if code ^= 0 then return;

	device_state_block.reference_count =
	     device_state_block.reference_count - 1;

	if device_state_block.reference_count = 0 then
	     call free_dsb (cur_dsb_ptr);

	free switch_data_block in (sys_area);

	iocb.attach_descrip_ptr = null;

	call iox_$propagate (iocb_ptr);

	return;
%page;
graphic_dim_order: entry (iocb_ptr, request_arg, data_ptr, code);

/* PARAMETERS */

dcl  (request_arg	        char (*),
     data_ptr	        pointer) parameter;

/* AUTOMATIC */

dcl  active_fn	        bit (1),
     command_level	        bit (1),
     request	        char (168),
     table_name	        char (168);

/* BASED */

dcl  1 device_info	        aligned based (data_ptr),
       2 gdt_name	        char (32) aligned,
       2 info_gdt_ptr       pointer,
       2 device_data        like graphic_device_table.device_data aligned;

dcl  based_char_168	        char (168) based (data_ptr);


	call setup;

	if request_arg = "io_call" then do;
		io_call_infop = data_ptr;
		request = io_call_info.order_name;
		command_level = "1"b;
		active_fn = (request_arg = "io_call_af");
		if io_call_info.version ^= 1 then do;
			code = error_table_$unimplemented_version;
			request = "io_call_info structure";
		     end;
	     end;

	else do;
		request = request_arg;
		command_level, active_fn = ""b;
	     end;

	if request = "set_table" then do;
		if command_level then
		     if io_call_info.nargs < 1 then do;
			     code = 0;
			     call io_call_info.error (error_table_$noarg,
				io_call_info.caller_name,
				"Need name of GDT.");
			     return;
			end;
		     else table_name = io_call_info.args (1);
		else table_name = data_ptr -> based_char_168;

		call associate_gdt (table_name, code);

/* if woopsed, at least make the error message pretty. */
		if code ^= 0 then request = table_name;
	     end;

	else if request = "get_sdb" then do;
		if ^command_level then data_ptr = addr (switch_data_block);
		else if active_fn then
		     call ioa_$rsnnl ("^p", io_call_af_ret, 0,
			addr (switch_data_block));
		else call io_call_info.report ("^p",
			addr (switch_data_block));
	     end;

	else if request = "device_info" then do;

		if ^switch_data_block.graphic then
		     code = graphic_error_table_$nongraphic_switch;

		else if command_level then
		     if active_fn then
			io_call_af_ret = device_state_block.gdt_name;
		     else call io_call_info.report ("
GDT: ^a (^p) for ^a (^a)^/Character height: ^f, width: ^f, spacing: ^f
Message size: ^d chars^/Points per inch: ^f",
			     device_state_block.gdt_name,
			     device_state_block.gdt_ptr,
			     graphic_device_table.terminal_name,
			     graphic_device_table.terminal_type,
			     graphic_device_table.charsizes (*),
			     graphic_device_table.message_size,
			     graphic_device_table.points_per_inch);

		else do;
			device_info.gdt_name =
			     device_state_block.gdt_name;
			device_info.info_gdt_ptr =
			     device_state_block.gdt_ptr;
			unspec (device_info.device_data) =
			     unspec (graphic_device_table.device_data);
		     end;
	     end;

	else if request = "debug" then
	     rawi_mode, rawo_mode, noecho_mode = "";

	else if request = "nodebug" then do;
		rawi_mode = "^can,^esc,^erkl";
		rawo_mode = "rawo.";
		noecho_mode = "^echoplex,^tabecho,^crecho,^lfecho,rawi";
	     end;

/* If we don't recognize the control order, pass it downstream and hope. */

	else call iox_$control
		(switch_data_block.target_switch_ptr, request_arg,
		data_ptr, code);

	if code ^= 0 then
	     if command_level then do;
		     call io_call_info.error (code,
			io_call_info.caller_name, request);
		     code = 0;
		end;

	return;
%page;
graphic_dim_changemode: entry (iocb_ptr, new_modes, old_modes, code);

/* PARAMETERS */

dcl  (new_modes	        char (*),
     old_modes	        char (*)) parameter;

/* AUTOMATIC */

dcl  (i, j)	        fixed bin,
     new_modes_len	        fixed bin,
     (old_sw_modes, old_gdt_modes)
		        char (512),
     single_mode	        char (32);

	call setup;

	if device_state_block.in_rawo_mode then do;
		call get_to_text_mode (code);
		if code ^= 0 then return;
	     end;

/* If the GSP keeps modes, obtain their current state. */

	if switch_data_block.graphic then do;
		call gdt_caller (Modes, "", code);
		if code ^= 0 then return;

		old_gdt_modes =
		     substr (output_buffer, 1, output_buffer_outdx);
		output_buffer_outdx = 0;
	     end;

	else old_gdt_modes = "";

/* Now get the modes from "downstream". */

	call iox_$modes (switch_data_block.target_switch_ptr, "",
	     old_sw_modes, code);

	if code ^= 0 then
	     old_modes = old_gdt_modes;
	else if old_gdt_modes = "" then
	     old_modes = old_sw_modes;
	else call ioa_$rsnnl ("^a,^a", old_modes, 0,
		rtrim (old_sw_modes, " ."), old_gdt_modes);

/* Try simple case - see if ttydim accepts all of these new modes */

	call iox_$modes (switch_data_block.target_switch_ptr, new_modes,
	     old_sw_modes, code);
	if code ^= 0 then do;

/* Since the ttydim rejected the modes, if the switch is nongraphic or the GDT
   doesn't know or care about modes, we must give up. */

		if ^switch_data_block.graphic then return;
		if graphic_device_table.version_number < gdt_version_2 then
		     return;
		if ^graphic_device_table.effector_data (Modes).call then
		     return;

/* We have to break apart the new_modes string and feed each bite to the
   ttydim_ and to the GDT to see if it is swallowed.  If both chuck up the same
   token, we can the whole modes operation and return a bad code. */

		i = 1;
		new_modes_len = length (rtrim (new_modes));
		code = 0;

		do while (i < new_modes_len);
		     j = index (substr (new_modes, i), ",");
		     if j = 0 then
			j = length (substr (new_modes, i)) + 1;
		     single_mode =
			rtrim (substr (new_modes, i, j - 1), ". ");
		     i = i + j;

		     call iox_$modes (switch_data_block.target_switch_ptr,
			single_mode, "", code);

		     if code ^= 0 then do;

/* ttydim upchucked it, try it on GDT */

			     call gdt_caller (Modes, single_mode, code);
			     output_buffer_outdx = 0;
			     if code ^= 0 then do;

/* Both the ttydim and the GSP rejected it.  Reset everything and punt. */

				     call iox_$modes
					(switch_data_block.target_switch_ptr,
					new_modes, old_sw_modes,
					code);
				     call gdt_caller (Modes,
					old_gdt_modes, 0);
				     return;
				end;
			end;
		end;
	     end;

	return;
%page;
graphic_dim_get_chars: entry (iocb_ptr, io_buffer_ptr, io_buffer_len,
	n_chars_read, code);

/* PARAMETERS */

dcl  (io_buffer_ptr	        pointer,
     io_buffer_len	        fixed bin (21),
     n_chars_read	        fixed bin (21)) parameter;



	call setup;

/* Simple read of text from one switch to another.  This entry is not reachable
   from graphic swithes. */

	if in_rawo_mode then do;
		call get_to_text_mode (code);
		if code ^= 0 then return;
	     end;

	call iox_$get_chars (target_switch_ptr, io_buffer_ptr,
	     io_buffer_len, n_chars_read, code);
	return;
%page;
graphic_dim_get_line: entry (iocb_ptr, io_buffer_ptr, io_buffer_len,
	n_chars_read, code);

/* BASED */

dcl  io_buffer	        char (io_buffer_len) based (io_buffer_ptr);


	call setup;

	if ^switch_data_block.graphic then do;

/* Simple read of text from one switch to another-- just pass it on. */

		if in_rawo_mode then do;
			call get_to_text_mode (code);
			if code ^= 0 then return;
		     end;

		call iox_$get_line (target_switch_ptr, io_buffer_ptr,
		     io_buffer_len, n_chars_read, code);
		return;
	     end;

/* If we get here, we are doing a graphic read (graphic input). */

	n_chars_read = 0;

	if io_buffer_len < 0 then do;
		code = error_table_$negative_nelem;
		return;
	     end;

	if io_buffer_len = 0 then return;

	if graphic_device_table.effector_data (Process_input).ignore then
	     return;

	if graphic_device_table.effector_data (Process_input).error then do;
		code = graphic_error_table_$unimplemented_effector;
		return;
	     end;

	device_state_block.old_input_modes = "";

	on cleanup call reset_input;

	call ipc_$mask_ev_calls (0);

	call iox_$modes (switch_data_block.target_switch_ptr,
	     static_stuff.rawi_mode, device_state_block.old_input_modes,
	     code);

/* This call is made separately because the ARPANET rejects it */

	call iox_$modes (switch_data_block.target_switch_ptr, noecho_mode,
	     "", code);

/* If the GSP wants to handle the input, let it handle everything including
   the read (who knows what weird multi-line formats non-intelligent devices
   might use?!) */

	if graphic_device_table.effector_data (Process_input).call then do;
		call gdt_caller (Process_input,
		     device_state_block.switch_name, code);
		call reset_input;
		if code ^= 0 then return;

		if output_buffer_outdx <= io_buffer_len then
		     n_chars_read = output_buffer_outdx;
		else do;
			code = error_table_$long_record;
			n_chars_read = io_buffer_len;
		     end;

		substr (io_buffer, 1, n_chars_read) =
		     substr (output_buffer, 1, n_chars_read);

	     end;

/* Otherwise, assume the virtual terminal, and expect real MSGC from it. */

	else do;
		call iox_$get_line (switch_data_block.target_switch_ptr,
		     io_buffer_ptr, io_buffer_len, n_chars_read, code);
		call reset_input;
	     end;

	return;
%skip (3);
reset_input: proc;

	call iox_$modes (switch_data_block.target_switch_ptr,
	     device_state_block.old_input_modes, "", 0);

	return;

     end reset_input;
%page;
graphic_dim_write: entry (iocb_ptr, io_buffer_ptr, io_buffer_len, code);

/* AUTOMATIC */

dcl  n_chars_out	        fixed bin (21),
     new_nodes_idx	        fixed bin,
     new_top_idx	        fixed bin;

/* BASED */

dcl  expansion_buffer       char (max_string_size)
		        based (switch_data_block.expansion_buffer_ptr);


	call setup;

	if io_buffer_len < 0 then do;
		code = error_table_$negative_nelem;
		return;
	     end;

	if io_buffer_len = 0 then return;


	if ^switch_data_block.graphic then do;

/* This is a simple write call over a non-graphic switch. */

		if device_state_block.in_rawo_mode then do;
			call get_to_text_mode (code);
			if code ^= 0 then return;
		     end;

		substr (output_buffer, output_buffer_outdx + 1,
		     io_buffer_len) = io_buffer;
		output_buffer_outdx = output_buffer_outdx + io_buffer_len;

		call force_out_buffer (""b, code);
		return;
	     end;
%skip (4);

/* If we're here, this is a graphic write over a graphic switch */
/* First, parse, track, and otherwise massage whatever it is we have to
   write to the terminal. */


	call preexpand_graphic_code (io_buffer, expansion_buffer,
	     n_chars_out, new_nodes_idx, new_top_idx, code);

/* Mark the limits of the nodes that we're sure are good in terminal memory.
   Note that we are not sure of the ones we just added or changed until we
   actually put them out to the terminal and it accepts them as OK. */

	switch_data_block.n_nodes_in_list = new_nodes_idx - 1;

	if code ^= 0 then return;

/* The string seems fine.  Plow it out there. */
/* Mask event-calls, to prevent damn send_message from blurting in rawmode */

	on cleanup call ipc_$unmask_ev_calls (0);

	call ipc_$mask_ev_calls (code);
	if code ^= 0 then return;

	call translate_and_output_graphic_code (expansion_buffer,
	     n_chars_out, code);

	call ipc_$unmask_ev_calls (0);

	return;
%page;
/* format: ind3 */
preexpand_graphic_code: proc (instring, outstring, n_chars_out,
      first_node_this_call, node_list_top, code);

/* PARAMETERS */

dcl  (instring	        char (*),
     outstring	        char (*),
     n_chars_out	        fixed bin (21),
     first_node_this_call   fixed bin,
     node_list_top	        fixed bin,
     code		        fixed bin (35)) parameter;

/* AUTOMATIC */

dcl  already_there	        bit (1),
     based_string_length    fixed bin (21),
     based_string_ptr       pointer,
     cur_level	        fixed bin,
     dynamic	        bit (1),
     effector_char	        char (1),
     effector_length        fixed bin (21),
     expanded_indx	        fixed bin (21),
     expanded_effector_len  fixed bin (21),
     gdt_ptr	        pointer,
     i		        fixed bin (21),
     indx		        fixed bin (21),
     instring_length        fixed bin (21),
     list_level	        fixed bin,
     new_node_list_size     fixed bin,
     node_list_ptr	        pointer,
     node_uid	        char (3),
     number_output	        fixed bin (21),
     number_used	        fixed bin (21),
     outdx	        fixed bin (21),
     save_outdx	        fixed bin (21),
     save_indx	        fixed bin (21),
     temp_p	        pointer,
     validate_this_node     bit (1),
     zero_ok	        bit (1);

dcl  1 effector_data_copy   like graphic_device_table.effector_data aligned;

/* BASED AND DEFINED */

dcl  1 stack	        based (static_stuff.stack_p),
       2 stack_size	        fixed bin,
       2 frames	        (static_stuff.stack_size refer (stack.stack_size)),
         3 list_indx        fixed bin (21),
         3 list_outdx       fixed bin (21),
         3 first_owned_node fixed bin;

dcl  1 static_node_table    aligned based (node_table_ptr),
       2 node_list_size     fixed bin,
       2 node_list	        (new_node_list_size
		        refer (static_node_table.node_list_size)) char (3);

dcl  based_string	        char (based_string_length)
		        based (based_string_ptr),
     based_string_array     (based_string_length) char (1) unaligned
		        based (based_string_ptr);

dcl  outstring_char	        (length (outstring)) char (1) unaligned
		        defined (outstring);


      node_table_ptr = switch_data_block.node_table_ptr;
      gdt_ptr = device_state_block.gdt_ptr;
      gdt_pointer = null;				/* for debugging */

      dynamic = device_state_block.dynamic;
      instring_length = length (instring);
      node_list_top = switch_data_block.n_nodes_in_list;
      first_node_this_call = node_list_top + 1;
      n_chars_out, outdx, list_level = 0;

      call ipc_$unmask_ev_calls (0);

/* Scan the string.  Do pre-expansion and track levels and multiple node
   references.  Do everything before calling the GSP for code conversion. */

      do indx = 1 repeat (indx) while (indx <= instring_length);

         save_indx = indx;
         save_outdx = outdx;

         call get_effector_info (addr (instring), indx, effector_char,
	  effector_length, effector_data_copy);
%skip (2);

/* Check for special action characters */

         if effector_char = Node_begin_char then do;

	     node_uid = substr (instring, save_indx + 2, 3);

/* Check to see if we have run out of stack.  If so, grow it. */

	     if list_level + 1 > static_stuff.stack_size then do;
		 static_stuff.stack_size = static_stuff.stack_size + 50;
		 temp_p = static_stuff.stack_p;

		 allocate stack in (sys_area) set (static_stuff.stack_p);

		 if temp_p ^= null then do;

/* Copy old stack into new stack */
		       unspec (stack.frames) =
			unspec (temp_p -> stack.frames);

		       free temp_p -> stack in (sys_area);
		    end;
	        end;

	     list_level = list_level + 1;		/* bump stack */

/* If we are communicating with an intelligent, dynamic terminal, we must
   keep a list of nodes which are resident in the terminal memory.  We use
   this list to optimize the sending of shared graphic objects by replacing
   them with Reference effectors.  Note that we only do this if the referenced
   object was sent over in the same structure we are processing at the
   moment (i.e., in the same write call)-- otherwise, we assume the user is
   resending it to redefine it. */

	     if ^dynamic then
		already_there = ""b;
	     else do;
		 call add_node (node_uid, first_node_this_call,
		    node_list_top, already_there, code);
		 if code ^= 0 then return;
	        end;

	     if already_there then do;

		 if list_level = 1 then do;
		       code = graphic_error_table_$recursive_structure;
		       return;
		    end;

		 else do;
		       substr (outstring, save_outdx + 1, 1)
			= Reference_char;
		       substr (outstring, save_outdx + 2, 3) = node_uid;
		       outdx = save_outdx + 4;
		    end;

		 cur_level = list_level;

/* Now scan the input string to throw away all the contents of the item that
   was just replaced by the Reference. */

		 do i = indx + effector_length
		    repeat (i + effector_length)
		    while (list_level >= cur_level);

		    if i > instring_length then do;
			code = graphic_error_table_$incomplete_structure;
			return;
		       end;

		    effector_char = substr (instring, i, 1);
		    if effector_char = Node_begin_char then
		         list_level = list_level + 1;
		    else if effector_char = Node_end_char then
		         list_level = list_level - 1;
		    effector_length =
		       compute_effector_length (addr (instring), i, code);
		    if code ^= 0 then return;
		 end;

		 effector_char = Reference_char;
		 indx = i;
		 unspec (effector_data_copy) =
		    unspec (gdt_ptr ->
		    graphic_device_table.effector_data (Reference));
		 effector_data_copy.expand = ""b;
	        end;

	     else do;
		 stack (list_level).list_indx = save_indx;
		 stack (list_level).list_outdx = save_outdx;
		 stack (list_level).first_owned_node = node_list_top;
	        end;
	  end;

         else if effector_char = Node_end_char then do;
	     list_level = list_level - 1;

	     if list_level < 0 then do;
		 code = graphic_error_table_$too_many_node_ends;
		 return;
	        end;
	  end;

         else if dynamic then do;

/* If this is one of the dynamic effectors listed below, check to see what
   effect it will have on the nodes stored in the terminal. */

	     validate_this_node = "1"b;

	     if (effector_char = Increment_char
	        | effector_char = Alter_char
	        | effector_char = Control_char
	        | effector_char = Display_char) then
		zero_ok = ""b;
	     else if effector_char = Delete_char then zero_ok = "1"b;
	     else validate_this_node = ""b;

	     if validate_this_node then
		if ^validate_node (node_uid, node_list_top, zero_ok)
		then do;
		      code = graphic_error_table_$node_not_active;
		      return;
		   end;

	     if effector_char = Delete_char then do;
		 if node_uid = zero_node_id then do;
		       first_node_this_call = 1;
		       node_list_top = 0;
		    end;

		 else do;
		       do i = 1 to node_list_top
			while (static_node_table.node_list (i)
			^= node_uid);
		       end;

		       if i > node_list_top then do;
			   code = graphic_error_table_$node_not_active;
			   return;
			end;

		       if i < first_node_this_call then
			  first_node_this_call =
			     first_node_this_call - 1;
		       node_list_top = node_list_top - 1;

		       do i = i to node_list_top;
			static_node_table.node_list (i) =
			   static_node_table.node_list (i + 1);
		       end;
		    end;
	        end;
	  end;
%skip (2);

/* Now do expansion and error checks as specified for this effector in the
   GDT. */

         if effector_char = Node_end_char then
	    effector_data_copy.expand = "0"b;

         if effector_data_copy.expand then do;

/* we have hit an effector which the terminal cannot handle in a stacked
   fashion.  We expand the list containing it (taking care to account for the
   effector's own list level if it has one). */

	     if effector_char ^= Node_begin_char then
		list_level = max (list_level - 1, 1);

	     i = stack (list_level).list_indx;
	     outdx = stack (list_level).list_outdx;
	     node_list_top = stack (list_level).first_owned_node;

	     based_string_length = instring_length - i + 1;
	     based_string_ptr =
	        addr (addr (instring) -> based_string_array (i));

	     call graphic_compiler_$expand_string (based_string, number_used,
	        addr (outstring_char (outdx + 1)), number_output, code);

	     if code ^= 0 then return;

/* Scan the expanded string for error-producing effectors. We know that
   this array will contain no unique ID's for us to keep track of, nor will it
   contain dynamic effectors that would make us update our node list. */

	     do expanded_indx = outdx + 1
	        repeat (expanded_indx + expanded_effector_len)
	        while (expanded_indx <= outdx + number_output);

	        call get_effector_info (addr (outstring), expanded_indx, "",
		 expanded_effector_len, effector_data_copy);

	        if effector_data_copy.error then do;
		    code = graphic_error_table_$unimplemented_effector;
		    return;
		 end;
	     end;

	     indx = stack (list_level).list_indx + number_used;
	     outdx = outdx + number_output;
	     list_level = list_level - 1;
	  end;

         else if effector_data_copy.error then do;
	     code = graphic_error_table_$unimplemented_effector;
	     return;
	  end;

/* Or if there's no processing to do, just copy it into the output buffer. */

         else if effector_char ^= Reference_char then do;
	     substr (outstring, outdx + 1, effector_length) =
	        substr (instring, indx, effector_length);
	     indx = indx + effector_length;
	     outdx = outdx + effector_length;

	  end;
      end;

      if list_level > 0 then do;
	  code = graphic_error_table_$incomplete_structure;
	  return;
         end;

      n_chars_out = outdx;
      code = 0;

      return;
%page;
/* format: revert */
add_node: proc (node_uid, first_node_this_call, node_list_top, already_there,
	code);

/* This routine keeps track of the resident node list. */

/* PARAMETERS */

dcl  (node_uid	        char (3),
     first_node_this_call   fixed bin,
     node_list_top	        fixed bin,
     already_there	        bit (1),
     code		        fixed bin (35)) parameter;

/* AUTOMATIC */

dcl  i		        fixed bin;


	code = 0;

	if node_table_ptr = null then call grow_node_table (100);

	do i = 1 to node_list_top
	     while (static_node_table.node_list (i) ^= node_uid);
	end;

	if i > node_list_top then do;
		if node_uid = zero_node_id then do;
			code = graphic_error_table_$invalid_node_no;

			call sub_err_ (code, "graphic_dim_",
			     "h", null, 0,
			     "Internal error while accounting for nodes in terminal memory.
Please report this occurrence to system maintenance personnel.");
			return;
		     end;

		if i > dim (static_node_table.node_list, 1) then
		     call grow_node_table (i + 99);

		static_node_table.node_list (i) = node_uid; /* add it */
		node_list_top = node_list_top + 1;
		already_there = ""b;		/* but is now! */
	     end;

	else if i < first_node_this_call then do;

/* This node is in the terminal memory, but was put there during graphic
   output previous to this call-- assume user is redefining. */

		static_node_table.node_list (node_list_top + 1) =
		     static_node_table.node_list (i);

		do i = i to node_list_top;
		     static_node_table.node_list (i) =
			static_node_table.node_list (i + 1);
		end;

		first_node_this_call = first_node_this_call - 1;
		already_there = ""b;
	     end;

	else already_there = "1"b;

	return;

     end add_node;
%page;
validate_node: proc (node_uid, node_list_top, zero_ok) returns (bit (1));

/* PARAMETERS */

dcl  (node_uid	        char (3),
     node_list_top	        fixed bin,
     zero_ok	        bit (1)) parameter;

/* AUTOMATIC */

dcl  i		        fixed bin;

	do i = 1 to node_list_top
	     while (static_node_table.node_list (i) ^= node_uid);
	end;

	if i <= node_list_top then return ("1"b);	/* it's there */
	if ((node_uid = zero_node_id) & zero_ok) then return ("1"b);
	return (""b);				/* punt */

     end validate_node;
%page;
grow_node_table: proc (new_table_size);

dcl  new_table_size	        fixed bin;

dcl  i		        fixed bin,
     temp_ptr	        pointer;


	temp_ptr = node_table_ptr;
	new_node_list_size = new_table_size;

	allocate static_node_table in (sys_area) set (node_table_ptr);

	if temp_ptr ^= null then do;
		unspec (static_node_table.node_list) =
		     unspec (temp_ptr -> static_node_table.node_list);

		free temp_ptr -> static_node_table in (sys_area);
	     end;

	return;

     end grow_node_table;
   end preexpand_graphic_code;
%page;
get_effector_info: proc (str_ptr, idx, eff_char, eff_len, eff_data);

/* PARAMETERS */

dcl  (str_ptr	        pointer,
     idx		        fixed bin (21),
     eff_char	        char (1),
     eff_len	        fixed bin (21),
     1 eff_data	        like graphic_device_table.effector_data aligned)
		        parameter;

/* BASED */

dcl  str		        char (sys_info$max_seg_size) based (str_ptr);

/* This misdeclaration is unfortunate, but it keeps get_effector_info
   from needing descriptors which is a great efficiency consideration */


	eff_char = substr (str, idx, 1);
	eff_len = compute_effector_length (str_ptr, idx, code);
	if code ^= 0 then return;

	unspec (eff_data) = unspec (gdt_ptr ->
	     graphic_device_table.effector_data (rank (eff_char)));
	return;

     end get_effector_info;
%skip (3);
compute_effector_length: proc (str_ptr, idx, code) returns (fixed bin (21));

/* PARAMETER */

dcl  (str_ptr	        pointer,
     idx		        fixed bin (21),
     code		        fixed bin (35)) parameter;

/* AUTOMATIC */

dcl  effector_rank	        fixed bin,
     effector_length        fixed bin (21);

/* BASED */

dcl  str		        char (sys_info$max_seg_size) based (str_ptr);

/* See comment in get_effector_info about such misdeclarations. */


	code = 0;

	effector_rank = rank (substr (str, idx, 1));

	if effector_rank < 32 then goto unrecognized;
	if effector_rank > 63 then do;
unrecognized:	code = graphic_error_table_$unrecognized_effector;
		return (0);
	     end;

	effector_length = Graphic_Element_Lengths (effector_rank);

/* length = 0 is a special case for a variable-length effector */

	if effector_length = 0 then
	     effector_length = graphic_element_length_ (str, idx);

	if effector_length <= 0 then do;
		code = graphic_error_table_$impossible_effector_length;
		return (0);
	     end;

	return (effector_length);
     end compute_effector_length;
%page;
translate_and_output_graphic_code: proc (instring, instring_len, code);

/* PARAMETERS */

dcl  (instring	        char (*),
     instring_len	        fixed bin (21),
     code		        fixed bin (35)) parameter;

/* AUTOMATIC */

dcl  1 effector_data_copy   like graphic_device_table.effector_data
		        aligned automatic;

dcl  effector_char	        char (1),
     indx		        fixed bin (21),
     effector_length        fixed bin (21),
     based_effector_ptr     pointer;

/* BASED */

dcl  based_string_array     (max_string_size) based char (1) unaligned,
     based_effector	        char (effector_length) based (based_effector_ptr);


	code = 0;

/* At this point, the expanded and massaged graphics code is in
   expansion_buffer.  Now we simply gallop down the string, calling the GSP
   entries if appropriate and generally putting out scads and scads of
   terminal-dependent graphics code. */


	if ^device_state_block.in_rawo_mode then do;
		call set_modes_rawo;

		call gdt_caller (Prepare_for_graphics,
		     (device_state_block.switch_name), code);
		if code ^= 0 then return;
	     end;


	do indx = 1 repeat (indx + effector_length)
	     while (indx <= instring_len);

	     call get_effector_info (addr (expansion_buffer), indx,
		effector_char, effector_length, effector_data_copy);

	     if effector_data_copy.flush then do;
		     call force_out_buffer ("1"b, code);
		     if code ^= 0 then return;
		end;

	     if effector_data_copy.ignore then ;	/* skip it */

	     else if effector_data_copy.call then do;

/* The GSP wants to get its hands on this one and translate it. */

		     based_effector_ptr = addr (addr (instring) ->
			based_string_array (indx));

		     call gdt_caller (rank (effector_char), based_effector,
			code);
		     if code ^= 0 then return;
		end;

	     else do;
		     substr (output_buffer, output_buffer_outdx + 1,
			effector_length) = based_effector; /* pass it on */
		     output_buffer_outdx =
			output_buffer_outdx + effector_length;
		end;
	end;

	call force_out_buffer ("1"b, code);

	return;

     end translate_and_output_graphic_code;
%page;
gdt_caller: proc (effector_no, effector, code);

/* PARAMETERS */

dcl  (effector_no	        fixed bin,
     effector	        char (*),
     code		        fixed bin (35)) parameter;

/* AUTOMATIC */

dcl  number_output	        fixed bin (21),
     part_output_len        fixed bin (21),
     part_output_ptr        pointer;

/* BASED */

dcl  part_output_buffer     char (part_output_len) based (part_output_ptr);


	part_output_ptr = addr (switch_data_block.output_buffer_ptr ->
	     char_array (output_buffer_outdx + 1));
	part_output_len =
	     length (substr (output_buffer, output_buffer_outdx + 1));
	number_output, code = 0;

	call device_state_block.gdt_proc (effector_no, effector,
	     part_output_buffer, number_output,
	     device_state_block.gdt_data_ptr, code);

/* check for the obsolete error code convention from before GSP error codes. */

	if number_output < 0 then code = -number_output;

	if code ^= 0 then return;

	output_buffer_outdx = output_buffer_outdx + number_output;
	call try_buffered_output ("1"b, code);

	return;

     end gdt_caller;
%page;
try_buffered_output: proc (graphical, code);

/* This routine writes the contents of the output buffer to the terminal if
   the message size in the GDT has been attained. */

/* PARAMETERS */

dcl  (graphical	        bit (1),
     code		        fixed bin (35)) parameter;


	code = 0;

/* If we have reached the message_size threshhold, do output. */

	if output_buffer_outdx
	     >= device_state_block.gdt_message_size then
	     call force_out_buffer (graphical, code);

	return;

     end try_buffered_output;
%skip (2);
force_out_buffer: proc (graphical, code);

/* This routine pumps the output buffer out to the terminal.  It also performs
   the status requests and interpretations from intelligent graphics
   terminals.  */

/* PARAMETERS */

dcl  (graphical	        bit (1),
     code		        fixed bin (35)) parameter;

/* AUTOMATIC */

dcl  buffer_ptr	        pointer,
     dynamic	        bit (1),
     message_size	        fixed bin (21),
     my_io_buffer_len       fixed bin (21),
     n_chars_read	        fixed bin (21);

	code = 0;

	if output_buffer_outdx = 0 then return;

/* get into proper mode-- raw or not-- depending on output type. */

	if (graphical & ^device_state_block.in_rawo_mode) then
	     call set_modes_rawo;

	else if (^graphical & device_state_block.in_rawo_mode) then
	     call set_modes_not_rawo;

	if graphical then do;
		message_size = device_state_block.gdt_message_size;
		dynamic = device_state_block.dynamic;
	     end;
	else do;
		message_size = static_stuff.max_string_size;
		dynamic = ""b;
	     end;

	on cleanup call cleanerup (0);

/* If we are talking to an intelligent terminal, activate the ACK strategy. */

	if dynamic then do;
		call iox_$modes (switch_data_block.target_switch_ptr,
		     rawi_mode, device_state_block.old_input_modes, code);

/* The following call is made separately because the ARPANET rejects it. */

		call iox_$modes (switch_data_block.target_switch_ptr,
		     noecho_mode, "", code);

/* We can't handle any typeahead that may be waiting now, so flush it. */

		call iox_$control (switch_data_block.target_switch_ptr,
		     "resetread", null, code);
	     end;

	buffer_ptr = switch_data_block.output_buffer_ptr;


	do while (output_buffer_outdx > 0);

	     my_io_buffer_len = min (output_buffer_outdx, message_size);
	     call iox_$put_chars (switch_data_block.target_switch_ptr,
		buffer_ptr, my_io_buffer_len, code);
	     if code ^= 0 then goto error_return;

	     output_buffer_outdx = output_buffer_outdx - my_io_buffer_len;
	     buffer_ptr =
		addr (buffer_ptr -> char_array (my_io_buffer_len + 1));

/* If doing graphics to an intelligent terminal, get an ACK from it now. */

	     if dynamic then do;
		     call iox_$put_chars
			(switch_data_block.target_switch_ptr,
			addr (request_for_status),
			length (request_for_status), code);
		     if code ^= 0 then goto error_return;

		     call iox_$get_line
			(switch_data_block.target_switch_ptr,
			addr (switch_data_block.status_buffer),
			length (switch_data_block.status_buffer),
			n_chars_read, code);
		     if code ^= 0 then goto error_return;

		     call graphic_terminal_status_$decode
			(substr (switch_data_block.status_buffer, 1,
			n_chars_read), code);
		     if code ^= 0 then goto error_return;
		end;
	end;

	call cleanerup (code);

	output_buffer_outdx = 0;
	return;

error_return:
	call cleanerup (0);
	return;
%skip (3);
cleanerup: proc (code);

dcl  code		        fixed bin (35) parameter;

	if dynamic then
	     call iox_$modes (switch_data_block.target_switch_ptr,
		device_state_block.old_input_modes, "", code);
	device_state_block.old_input_modes = "";

	return;
     end cleanerup;
     end force_out_buffer;
%skip (3);
set_modes_rawo: proc;

	call iox_$modes (switch_data_block.target_switch_ptr,
	     rawo_mode, device_state_block.old_output_modes, code);
	device_state_block.in_rawo_mode = "1"b;

	return;

     end set_modes_rawo;
%skip (3);
set_modes_not_rawo: proc;

	call iox_$modes (switch_data_block.target_switch_ptr,
	     device_state_block.old_output_modes, "", 0);

	device_state_block.old_output_modes = "";
	device_state_block.in_rawo_mode = ""b;

	return;

     end set_modes_not_rawo;
%page;
get_to_text_mode: proc (code);

/* PARAMETERS */

dcl  code		        fixed bin (35) parameter;


	call gdt_caller (Prepare_for_text, (device_state_block.switch_name),
	     code);
	if code ^= 0 then return;

	call force_out_buffer ("1"b, code);
	if code ^= 0 then return;

	call set_modes_not_rawo;

	return;

     end get_to_text_mode;

     end graphic_dim_;
