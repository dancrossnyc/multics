/* ***********************************************************
   *                                                         *
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
   *                                                         *
   *                                                         *
   *********************************************************** */

/* ******************************************************
   *                                                    *
   *                                                    *
   * Copyright (c) 1972 by Massachusetts Institute of   *
   * Technology and Honeywell Information Systems, Inc. *
   *                                                    *
   *                                                    *
   ****************************************************** */

graphic_compiler_: gc_: procedure; return;

/* Originally coded 7/20/73 by Lee J. Scheffler */
/* Major rewrite 07/79 by C. D. Tavares-- added internal array linearization,
   position roundoff tracking inside arrays, and premapping of objects inside
   arrays.  Also included entrypoint expand_string to replace functionality of
   make_graphic_array_. */
/* Modified 08/29/80 by CDT to fix bug where if a mode or mapping occurred
   as last element of array, gc_ locked up and looped.  Also modified it not to
   put out trailing mode/mapping revocations in a top-level array. */
/* Last modified 10/14/80 by CDT to understand about elements with trailing
   zero coordinates unstored, and to add entrypoint prune_tree. */

/* PARAMETERS */

dcl (desired_switch pointer,				/* I/O switch for output */
     display_name char (*),				/* name of graphic symbol being displayed */
     display_node fixed bin (18),			/* number of node being displayed */
     err_code fixed bin (35),				/* error code */
     number_used fixed bin (21),			/* number of input_chars used by expand_string */
     return_p pointer,				/* pointer to returned string in return_string entry point */
     return_len fixed bin (21)) parameter;		/* length of returned string */


/* AUTOMATIC */

dcl  Array_header_chars char (2) aligned,
     List_header_chars char (2) aligned,
     Null_node_chars char (5) aligned,
     abs_move_needed bit (1) aligned,
     auto_temp_seg_ptr pointer initial (null),
     char char (1),
     copy_direct bit (1) aligned,
     contents_p pointer,
     datap pointer,
     done bit (1) aligned,
     effector_char char (1),
     fixed_buffer (3) fixed bin,
     float_buffer (3) float bin,
     frame_ptr pointer,
     graphic_output pointer,
     i fixed bin,
     ini fixed bin (21) init (1),			/* index for input string */
     input_string char (*),				/* string of MSGC to expand and recompile */
     item_environment_wall bit (1) aligned,
     j fixed bin,
     max_levels fixed bin,
     must_put_out bit (1) aligned,
     n_elements fixed bin,
     node_no fixed bin (18),
     node_p pointer,
     outi fixed bin (21) init (1),			/* index for output string */
     sym_len fixed bin,
     sym_node fixed bin (18),
     sym_p pointer,
     sym_type fixed bin,
     temp_length fixed bin (21),
     temp_matrix (3, 3) float bin,
     temp_ptr pointer,
     temp_scaled (3) fixed bin (35, 6),
     type fixed bin,
     value_node fixed bin (18),
     waiting_to_make_array bit (1) aligned automatic initial (""b),
						/* informs lower levels not to waste time making graphic
						   arrays if someone above them is waiting to make one */

     wgs_p pointer;					/* pointer to the current working graphic seg */

dcl 1 control automatic,				/* central repository of operation flags */
    2 (erase,
     display,
     return_string,
     from_wgs) bit (1),
    2 output_string_ptr pointer,
    2 cur_switch pointer;

dcl 1 position automatic,
    2 absolute bit (1) aligned,
    2 desired (3) float bin,
    2 current (3) fixed bin (35, 6);


/* ENTRIES */

dcl  get_temp_segment_ ext entry (char (*), pointer, fixed bin (35)),
     get_system_free_area_ ext entry returns (pointer),
     hcs_$truncate_seg entry (pointer, fixed bin (18), fixed bin (35)),
     sub_err_ ext entry options (variable);






dcl (graphic_code_util_$encode_spi,
     graphic_code_util_$encode_dpi,
     graphic_code_util_$encode_uid) entry (dimension (*) fixed bin, fixed bin, pointer),
     graphic_code_util_$encode_scl entry (dimension (*) float bin, fixed bin, pointer),
    (graphic_code_util_$decode_spi,
     graphic_code_util_$decode_dpi,
     graphic_code_util_$decode_uid) entry (pointer, fixed bin, dimension (*) fixed bin),
    (graphic_code_util_$decode_scl,
     graphic_code_util_$decode_scl_nozero) entry (pointer, fixed bin, dimension (*) float bin);

dcl  graphic_element_length_ entry (char (*), fixed bin (21)) returns (fixed bin),
     graphic_manipulator_$segp entry (pointer, fixed bin (35));


/* INTERNAL STATIC */

dcl  temp_seg_ptr pointer static initial (null);		/* pointer to temp seg in which graphic string is compiled */

dcl  max_string_size fixed bin (21) static,
     sys_area_p pointer static initial (null);

dcl  tree_ptr pointer static initial (null);

dcl  scaled_zeroes (3) fixed bin (35, 6) internal static initial ((3)0.0);


/* EXTERNAL STATIC */

dcl (graphic_error_table_$no_wgs_yet,			/* No graphic structure to compile yet */
     graphic_error_table_$recursive_structure,		/* graphic structure is recursive */
     graphic_error_table_$compiler_error,		/* no comment necessary */
     graphic_error_table_$bad_node,			/* bad node type in graphic structure   */
     graphic_error_table_$not_a_structure,		/* malformed MSGC was input */
     graphic_error_table_$abs_pos_in_clipping)		/* absolute position element within clipping domain */
     fixed bin (35) external static;

dcl (error_table_$out_of_sequence,
     error_table_$smallarg) fixed bin (35) external static;

dcl  sys_info$max_seg_size fixed bin (35) external;


/* BASED */

dcl  output_string char (max_string_size) based (output_string_ptr), /* compiled string */
     output_string_array (max_string_size) char (1) unaligned based (output_string_ptr), /* overlay of output_string */
     input_string_array (max_string_size) char (1) unaligned based (addr (input_string)), /* overlay of input_string */
     char_str char (max_string_size) based,
     fixed_contents (n_elements) fixed bin based (contents_p),
     float_contents (n_elements) float bin based (contents_p),
     node_array (1) fixed bin based (addr (node_no)),	/* To get around compiler bug */
     sys_area area based (sys_area_p),
     dumaray based fixed bin dimension (1);		/* 03/21/75 since symbol table processor doesn't like
						   use of (fixed bin) in array arg position */


/* The tree is a pseudo stack used to keep track of not only the current position in the graphic tree structure
   but also the current graphic environment when making arrays out of lists. */

dcl 1 tree aligned based (tree_ptr),
    2 level fixed bin init (1),			/* Current list or array level */
    2 max_level fixed bin,
    2 node (0 : max_levels refer (max_level)),		/* Nodes in path of current compilation */
      3 trace aligned,
        4 id fixed bin (18) init (0),			/* unique id of list node at this level */
        4 idx fixed bin init (0),			/* index in this list of next level node */
        4 max_idx fixed bin init (0),			/* number of elements in this item */
        4 node_p pointer init (null),			/* pointer to node in WGS */
        4 environment_wall bit (1),			/* input array marker-- should never collapse past this level */
        4 output_array_sentinel bit (1),		/* this level marks the boundary of the output array */
        4 precollapsed bit (1),			/* the level above this has been collapsed but not popped */
      3 environment aligned,
        4 intensity fixed bin,
        4 linetype fixed bin,
        4 sensitivity fixed bin,
        4 blinking fixed bin,
        4 color (3) fixed bin,
        4 matrix (3, 3) float bin,			/* linear transformation matrix for scaling and rotation */
        4 clipping_boundaries (3, 2) float bin,		/* current boundaries of clipping effector (not used) */
        4 active aligned,
	5 (transformation, clipping) bit (1),
      3 this_level aligned,
        4 scaling (3) float bin,
        4 clipping (3, 2) float bin;

dcl 1 tree_frame aligned based (frame_ptr) like tree.node;


/* BUILTINS AND CONDITIONS */

dcl (addr, cosd, fixed, float, length, mod, null, round, rtrim, sind, string, substr, sum, unspec) builtin;

dcl (cleanup, underflow) condition;

dcl  subscriptrange condition;			/* GET RID OF THIS BEFORE INSTALLATION */
%page;
%include graphic_comp_specs;
%page;
%include graphic_etypes;
%page;
%include graphic_templates;
%page;
%include lsm_formats;
%page;
%include iox_dcls;
%page;
%include lsm_entry_dcls;
%page;
/* ------------------------------------------------------------------------- */

/* These entries display the substructure subordinate to a given node */


/* This is the normal display entry point - it erases the screen first */

display: d: entry (display_node, err_code);

	control.erase,
	     control.display = "1"b;
	control.return_string = "0"b;
	control.cur_switch = null;
	go to node_common;
%skip (2);
display_switch: d_switch: entry (display_node, err_code, desired_switch);

	control.erase,
	     control.display = "1"b;
	control.return_string = "0"b;
	control.cur_switch = desired_switch;
	goto node_common;
%skip (5);

/* These entry points do not erase the screen first */

display_append: da: entry (display_node, err_code);

	control.display = "1"b;
	control.erase,
	     control.return_string = "0"b;
	control.cur_switch = null;
	go to node_common;
%skip (2);
display_append_switch: da_switch: entry (display_node, err_code, desired_switch);

	control.display = "1"b;
	control.erase,
	     control.return_string = "0"b;
	control.cur_switch = desired_switch;
	goto node_common;
%skip (5);

/* These entry points load the substructure subordinate to a node into the
   terminal processor memory, but do not display it */

load: l:	entry (display_node, err_code);

	control.display,
	     control.erase,
	     control.return_string = "0"b;
	control.cur_switch = null;
	goto node_common;
%skip (2);
load_switch: l_switch: entry (display_node, err_code, desired_switch);

	control.display,
	     control.erase,
	     control.return_string = "0"b;
	control.cur_switch = desired_switch;
	goto node_common;
%skip (5);

/* Return the compiled string corresponding to the node */

return_string: rs: entry (display_node, return_p, return_len, err_code);
	control.display,
	     control.erase = "0"b;
	control.return_string = "1"b;
	go to node_common;
%skip (6);
node_common:					/* Common code for compilations starting with a node number */

	control.from_wgs = "1"b;
	call initialize;				/* Get ptr to current working graphic seg */

	on cleanup call cleaner_up;

	call compile_node (display_node);		/* Compile and dispatch it */

	call cleaner_up;
	return;
%page;
/* These entries display the structure subordinate to a graphic symbol, given
   its name.  See comments on above similar entrypoints for explanation.  */


display_name: dn: entry (display_name, err_code);

	control.erase,
	     control.display = "1"b;
	control.return_string = "0"b;
	control.cur_switch = null;
	go to name_common;
%skip (2);
display_name_switch: dn_switch: entry (display_name, err_code, desired_switch);

	control.erase,
	     control.display = "1"b;
	control.return_string = "0"b;
	control.cur_switch = desired_switch;
	goto name_common;
%skip (5);
display_name_append: dna: entry (display_name, err_code);

	control.display = "1"b;
	control.erase,
	     control.return_string = "0"b;
	control.cur_switch = null;
	go to name_common;
%skip (2);
display_name_append_switch: dna_switch: entry (display_name, err_code, desired_switch);

	control.display = "1"b;
	control.erase,
	     control.return_string = "0"b;
	control.cur_switch = desired_switch;
	goto name_common;
%skip (5);
load_name: ln: entry (display_name, err_code);

	control.display,
	     control.erase,
	     control.return_string = "0"b;
	control.cur_switch = null;
	goto name_common;
%skip (2);
load_name_switch: ln_switch: entry (display_name, err_code, desired_switch);

	control.display,
	     control.erase,
	     control.return_string = "0"b;
	control.cur_switch = desired_switch;
	goto name_common;
%skip (6);
name_common:					/* Common code for compilations starting with a symbol name */

	control.from_wgs = "1"b;
	call initialize;

	call lsm_sym_$symk (wgs_p, Find_symbol, display_name, sym_node, value_node, err_code);
	if err_code ^= 0 then return;

	on cleanup call cleaner_up;

	call compile_node (value_node);

	call cleaner_up;

	return;
%page;
/* This entrypoint uses a graphic structure supplied as a string of MSGC as
   opposed to a graphic structure in the WGS.  It implements the "expand"
   function found in GDT's. */

expand_string: entry (input_string, number_used, return_p, return_len, err_code);

	control.display,
	     control.erase,
	     control.from_wgs = "0"b;
	control.return_string = "1"b;
	control.cur_switch = null;

	call initialize;

	call compile_node (0);

	number_used = ini - 1;

	return;
%skip (8);

/* Arbitrary entrypoints and exitpoints */

/* Entry to return information about where in a graphic structure the last error occurred,
   without having to know the format of the tree. */

error_path: entry (top_level_node, struc_depth, index_array, err_code);

dcl (top_level_node fixed bin (18),
     struc_depth fixed bin,
     index_array fixed bin dimension (*)) parameter;

	if tree_ptr = null then do;
	     err_code = error_table_$out_of_sequence;
	     return;
	end;

	struc_depth = tree.level - 1;			/* Any leftover index on the last level is not interesting */
	top_level_node = tree.node (1).id;

	if struc_depth > dim (index_array, 1) then do;
	     err_code = error_table_$smallarg;
	     return;
	end;

	do i = 1 to struc_depth;
	     index_array (lbound (index_array, 1) + i - 1) = tree.node (i).idx;
	end;

	err_code = 0;
	return;
%skip (5);

/* Entrypoint to reset the tree to minimal size. */

prune_tree: entry (err_code);

	err_code = 0;
	if tree_ptr = null then return;

	free tree in (sys_area);
	tree_ptr = null;
	return;
%skip (5);

/* Various matrix-hacking entrypoints, since we have engulfed the old graphic_matrix_util_ within ourselves */

make_matrix: entry (arg_rots, arg_scls, arg_matrix);

dcl  arg_rots (3) fixed bin parameter,
     arg_scls (3) float bin parameter,
     arg_matrix (3, 3) float bin parameter;

	call make_matrix (arg_rots, arg_scls, arg_matrix);
	return;



multiply_3x3_x_3x3: entry (arg_lmatrix, arg_rmatrix, arg_matrix);

dcl (arg_lmatrix, arg_rmatrix) (3, 3) float bin parameter;

	call multiply_3x3_x_3x3 (arg_lmatrix, arg_rmatrix, arg_matrix);
	return;
%skip (3);
multiply_3x3_x_1x3: entry (arg_lmatrix, arg_rvector, arg_vector);

dcl (arg_rvector, arg_vector) (3) float bin parameter;

	call multiply_3x3_x_1x3 (arg_lmatrix, arg_rvector, arg_vector);
	return;
%skip (5);
sub_err_caller: proc (excuse);

dcl  excuse char (*);

	     call sub_err_ (graphic_error_table_$compiler_error, "graphic_compiler_", "h", null, "",
		"^a^/Please contact system maintenance personnel.", excuse);
	     goto non_local_return;
	end sub_err_caller;

recursive_structure:
	err_code = graphic_error_table_$recursive_structure;
	goto non_local_return;

bad_type:	err_code = graphic_error_table_$bad_node;
	goto non_local_return;

not_valid_msgc:
	err_code = graphic_error_table_$not_a_structure;
	goto non_local_return;

non_local_return:
	call cleaner_up;
	return;
%skip (5);
cleaner_up: proc;

	     if auto_temp_seg_ptr ^= null then
		call hcs_$truncate_seg (auto_temp_seg_ptr, 0, 0);
	     return;
	end cleaner_up;
%page;
compile_node: procedure (node_no_arg);

/* Internal procedure compiles the node and dispatches it */

dcl  node_no_arg fixed bin (18) parameter;


	     err_code = 0;

	     if control.return_string then output_string_ptr = return_p;
	     else output_string_ptr = auto_temp_seg_ptr;

	     List_header_chars = Node_begin_char || List_char;
	     Array_header_chars = Node_begin_char || Array_char;
	     Null_node_chars = List_header_chars || zero_node_id;

	     if control.erase then do;
		substr (output_string, 1, length (Erase_char)) = Erase_char;
		outi = length (Erase_char) + 1;	/* Compilation starts at second char */
	     end;
	     else outi = 1;
%skip (5);

/* Here begins the actual compilation of the list structure */

	     unspec (tree.node) = ""b;		/* clear out the tree */

	     tree.level = 0;

/* Initialize the base of the tree */

	     frame_ptr = addr (tree.node (0));
	     tree_frame.id,
		tree_frame.idx,
		tree_frame.max_idx = 0;
	     tree_frame.precollapsed = ""b;
	     tree_frame.environment_wall = "0"b;
	     tree_frame.environment.matrix = Identity_matrix;
	     tree_frame.environment.clipping_boundaries,
		tree_frame.this_level.clipping = Clipping_default;
	     tree_frame.this_level.scaling = Scaling_default;
	     tree_frame.environment.intensity = Intensity_default;
	     tree_frame.environment.linetype = Linetype_default;
	     tree_frame.environment.sensitivity = Sensitivity_default;
	     tree_frame.environment.color = Color_default;
	     tree_frame.active = ""b;

	     if control.from_wgs then
		node_no = node_no_arg;

	     else do;
		if substr (input_string, 1, length (List_header_chars)) = List_header_chars then
		     ini = length (List_header_chars) + 1;
		else if substr (input_string, 1, length (Array_header_chars)) = Array_header_chars then
		     ini = length (Array_header_chars) + 1;
		else goto not_valid_msgc;

		substr (output_string, outi, length (Array_header_chars)) = Array_header_chars;
		outi = outi + length (Array_header_chars);
		substr (output_string, outi, UI_arg_length) = substr (input_string, ini, UI_arg_length);
		outi = outi + UI_arg_length;

		call graphic_code_util_$decode_uid (addr (input_string_array (ini)), 1, node_array);
		ini = ini + UI_arg_length;
	     end;

	     if ^control.from_wgs then do;
		waiting_to_make_array = "1"b;
		position.current,
		     position.desired = 0;
		position.absolute = "0"b;
	     end;

	     call push_level (node_no, waiting_to_make_array);

	     tree_frame.output_array_sentinel = waiting_to_make_array;
%skip (5);

/* Walk the tree, compiling each node and keeping track of the level and environment. */

	     do while (tree.level > 0);

		node_no = tree_frame.id;

/* Trace the structure, popping old detritus as necessary, until we get to a
   new element to examine. */

		if control.from_wgs then
		     do while ((tree_frame.idx ^= 0) & (tree.level > 0)); /* find ONE node */

		     if tree_frame.idx > tree_frame.max_idx then /* we're finished with this list */
			call pop_level;

		     else do;
			node_no = tree_frame.node_p -> list_node.node (tree_frame.idx);
			call push_level (node_no, "0"b); /* we don't know if it's an array yet */
						/* but if so the proper indicator will be set later, not now */
		     end;
		end;

		else do;				/* interpreting input MSGC */
		     done = "0"b;
		     do while (^done);
			if substr (input_string, ini, length (Node_end_char)) = Node_end_char then do;
			     ini = ini + length (Node_end_char);
			     call pop_level;
			end;

			else if substr (input_string, ini, 1) = Node_begin_char then do;
			     ini = ini + length (Node_begin_char);
			     item_environment_wall = (substr (input_string, ini, 1) = Array_char);

			     ini = ini + length (List_char);
			     call graphic_code_util_$decode_uid (addr (input_string_array (ini)), 1, node_array);
			     ini = ini + UI_arg_length;

			     call push_level (node_no, item_environment_wall);
			end;

			else done = "1"b;

			if tree.level <= 0 then done = "1"b;
		     end;
		end;

		if tree.level <= 0 then goto Loop_end;	/* done, drop out of loop */

/* Now compile the new element we have just found. */

		if tree_frame.idx = 0 then tree_frame.idx = 1;
						/* even terminal elements count */

		if node_no = 0 then
		     call compile_null_element;

		else do;				/* must actually compile this node */
		     if control.from_wgs then
			call find_node (node_no, type, node_ptr, contents_p, copy_direct, n_elements);
		     else call decode_effector (ini, type, node_ptr, contents_p, copy_direct, n_elements);

		     effector_char = structural_effector_codes (type);

		     if ^waiting_to_make_array then do; /* put out list header */
			if type = Array then do;	/* this is an array itself */
			     substr (output_string, outi, length (Array_header_chars)) = Array_header_chars;
			     outi = outi + length (Array_header_chars);
			end;
			else do;
			     substr (output_string, outi, length (List_header_chars)) = List_header_chars;
			     outi = outi + length (List_header_chars);
			end;

			call graphic_code_util_$encode_uid (node_array, 1, addr (output_string_array (outi)));
			outi = outi + UI_arg_length;
		     end;


		     goto Type (type);


/* Array */

Type (33):	     if ^waiting_to_make_array then do; /* no one above me is waiting to make one */
			waiting_to_make_array,
			     tree_frame.output_array_sentinel = "1"b;
			position.current, position.desired = 0;
						/* Until seeing abs pos, we will compute using rel pos */
			position.absolute = ""b;
		     end;

		     tree_frame.environment_wall = "1"b;

/* List */

Type (32):	     tree_frame.idx = 1;		/* array drops thru here */
		     tree_frame.node_p = node_ptr;
		     tree_frame.max_idx = n_elements;

		     goto Type_end;

/* Symbol */

Type (24):	     if ^waiting_to_make_array then do;
			call find_node (node_ptr -> symbol_node.name_node, sym_type, sym_p, contents_p, copy_direct, sym_len);

			substr (output_string, outi, length (effector_char)) = effector_char;
			outi = outi + length (effector_char);

			call graphic_code_util_$encode_dpi (addr (sym_len) -> dumaray, 1,
			     addr (output_string_array (outi)));
						/* stick in char string length */
			outi = outi + DPI_arg_length;

			substr (output_string, outi, sym_len) = sym_p -> char_node.string;
			outi = outi + sym_len;
		     end;

/* Now masquerade as an unfinished array by simulating a push-pop and continuing */
		     tree_frame.max_idx = 2;		/* with 2 elements */
		     tree_frame.idx = 2;		/* and have already processed the first */
		     tree_frame.node_p = node_ptr;

		     goto Type_end;

/* Positional effectors */

Type (0):						/* setposition */
Type (1):						/* setpoint */
Type (2):						/* vector */
Type (3):						/* shift */
Type (4):						/* point */
		     if control.from_wgs then do;
			float_buffer (*) = 0e0;
			addr (float_buffer) -> float_contents (*) =
			     contents_p -> float_contents (*);
						/* copy out the data, may be "short" */
			contents_p = addr (float_buffer);
		     end;

		     if waiting_to_make_array then do;

			if tree_frame.active.transformation then
			     call multiply_3x3_x_1x3 (tree_frame.matrix, (float_buffer), float_buffer);

			if type = Setpoint then abs_move_needed = "1"b;
			else if type = Setposition then
			     if ^position.absolute then
				abs_move_needed = "1"b;
			     else abs_move_needed = ""b;
			else abs_move_needed = ""b;

			if abs_move_needed then do;

/* Check for absolute positionings within relative clippings.  No way to
   do this correctly, so complain to the user. */

			     if tree_frame.active.clipping then do;
				err_code = graphic_error_table_$abs_pos_in_clipping;
				goto non_local_return;
			     end;

			     position.absolute = "1"b; /* we know exactly where we want to go, */
			     position.current,	/* but we don't know exactly where we are NOW */
				position.desired = 0; /* so let's get to where we're going */
			     must_put_out = "1"b;	/* while we still remember how to get there */
			end;

			else if tree_frame.environment.intensity = 0 then goto invisible;
						/* no class, but efficiency critical here */
			else if type = Shift then do;
invisible:		     position.desired = position.desired + float_buffer;
			     must_put_out = ""b;	/* skip everything else you can't see */
			end;

			else must_put_out = "1"b;	/* it's visible and relevant */

			if ^must_put_out then goto Type_end;

/* Before we do anything, first get to where we should be starting from. */

			if ^abs_move_needed then call get_to_cur_pos;

/* Now keep track of where the positions will be after we actually compile the element. */

			position.desired = position.desired + float_buffer;
			float_buffer = position.desired - position.current;
			temp_scaled = round (fixed (float_buffer, 35, 8), 6);
			position.current = position.current + temp_scaled;
		     end;

		     call compile_simple_element (effector_char, type, contents_p);
		     goto Type_end;

/* Mapping Effectors */

Type (8):						/* scaling */
		     if control.from_wgs then do;
			float_buffer (*) = 1e-6;
			addr (float_buffer) -> float_contents (*) =
			     contents_p -> float_contents (*);
						/* copy out the data, may be "short" */
			contents_p = addr (float_buffer);
		     end;

		     if waiting_to_make_array then do;
			call collapse_level;

			do i = 1 to 3;
			     if float_buffer (i) = 0e0 then
				float_buffer (i) = 1e-6;
			end;

			do i = 1 to 3;
			     do j = 1 to 3;
				tree_frame.matrix (j, i) = tree_frame.matrix (j, i)
				     * float_buffer (i) / tree_frame.this_level.scaling (i);
			     end;
			end;

			tree_frame.this_level.scaling = float_buffer;

			tree_frame.active.transformation =
			     (unspec (tree_frame.environment.matrix) ^= unspec (Identity_matrix));
		     end;

		     else call compile_simple_element (effector_char, type, contents_p);
		     goto Type_end;

Type (9):						/* rotation */
		     if control.from_wgs then do;
			float_buffer (*) = 0e0;
			addr (float_buffer) -> float_contents (*) =
			     contents_p -> float_contents (*);
						/* copy out the data, may be "short" */
			contents_p = addr (float_buffer);
		     end;

		     if waiting_to_make_array then do;
			call collapse_level;

			fixed_buffer (*) = float_buffer (*);

			call make_matrix (fixed_buffer, tree_frame.this_level.scaling (*), temp_matrix (*, *));

			call multiply_3x3_x_3x3 (tree.node (tree.level - 1).matrix (*, *),
			     temp_matrix (*, *), tree_frame.matrix (*, *)); /* create new master matrix */

			tree_frame.active.transformation =
			     (unspec (tree_frame.environment.matrix) ^= unspec (Identity_matrix));
		     end;

		     else call compile_simple_element (effector_char, type, contents_p);
		     goto Type_end;

Type (10):					/* clipping */

/* WRITE THIS CODE LATER */

		     goto Type_end;


/* Modal effectors */

Type (16):					/* intensity */
		     if waiting_to_make_array then do;
			call collapse_level;
			tree_frame.environment.intensity = fixed_contents (1);
		     end;

		     if tree_frame.environment.intensity > 0 then goto mode_common;
						/* if not in array, will always be "visible" */
		     else goto Type_end;

Type (17):					/* linetype */
		     if waiting_to_make_array then do;
			call collapse_level;
			tree_frame.environment.linetype = fixed_contents (1);
		     end;

		     goto mode_common;

Type (18):					/* sensitivity */
		     if waiting_to_make_array then do;
			call collapse_level;
			tree_frame.environment.sensitivity = fixed_contents (1);
		     end;

		     goto mode_common;

Type (19):					/* blink */
		     if waiting_to_make_array then do;
			call collapse_level;
			tree_frame.environment.blinking = fixed_contents (1);
		     end;

		     goto mode_common;


Type (20):					/* color */
		     if waiting_to_make_array then do;
			call collapse_level;
			tree_frame.environment.color = fixed_contents;
		     end;

mode_common:	     call compile_simple_element (effector_char, type, contents_p);
		     goto Type_end;

/* Text */

Type (25):	     if tree_frame.environment.intensity = 0 then goto Type_end;

		     if waiting_to_make_array then call get_to_cur_pos;
		     call compile_text_element (effector_char, n_elements, contents_p, copy_direct);
		     goto Type_end;

/* Datablock */

Type (26):	     call compile_data_block (effector_char, n_elements, contents_p, copy_direct);
		     goto Type_end;

/* These labels represent node types which are undefined.  If we get here, something is wrong. */

Type (5):
Type (6):
Type (7):
Type (11):
Type (12):
Type (13):
Type (14):
Type (15):
Type (21):
Type (22):
Type (23):
Type (27):
Type (28):
Type (29):
Type (30):
Type (31):	     goto bad_type;

Type_end:
		end;
Loop_end:
	     end;

/* End the actual compilation of the list structure. */
	     if display then do;			/* If displaying... */
		substr (output_string, outi, length (Display_char)) = Display_char; /* ... then stick display command in */
		outi = outi + length (Display_char);
		node_no = node_no_arg;
		call graphic_code_util_$encode_uid (node_array, 1, addr (output_string_array (outi)));
						/* Stick in top level node # */
		outi = outi + UI_arg_length;
	     end;

	     if control.return_string then		/* If returning the compiled string... */
		return_len = outi - 1;		/* Set the length of the string */

	     else do;
write_it:		if control.cur_switch = null then control.cur_switch = graphic_output;

		call iox_$put_chars (control.cur_switch, addr (output_string), outi - 1, err_code);
						/* Write it out */
		if err_code ^= 0 then return;
	     end;

	     return;
%page;
get_to_cur_pos: proc;

dcl  float_temp (3) float bin;

		float_temp = position.desired - position.current;
		temp_scaled = round (fixed (float_temp, 35, 8), 6);

		if unspec (temp_scaled) ^= unspec (scaled_zeroes) then
		     call compile_simple_element (Shift_char, Shift, addr (float_temp));

		position.current = position.current + temp_scaled;
	     end get_to_cur_pos;
%page;
push_level:    proc (node_no, environment_wall);

dcl (node_no fixed bin (18),
     environment_wall bit (1) aligned) parameter;

		if tree.level + 1 > tree.max_level then call grow_tree;
		tree.level = tree.level + 1;
		frame_ptr = addr (tree.node (tree.level));
		tree_frame.id = node_no;
		tree_frame.idx = 0;			/* claim to be working on node itself */
		if control.from_wgs then
		     tree_frame.max_idx = 0;
		else tree_frame.max_idx = max_string_size; /* impossibly large value */
		tree_frame.environment_wall = environment_wall;
		tree_frame.node_p = null;

		tree_frame.this_level.scaling = Scaling_default;
		tree_frame.this_level.clipping = Clipping_default;

		unspec (tree_frame.environment) = unspec (tree.node (tree.level - 1).environment);

		return;
	     end push_level;
%skip (5);
pop_level:     proc;

dcl 1 prev_tree_frame like tree.node aligned based (prev_tree_framep);

dcl  prev_tree_framep pointer;

		if ^tree_frame.precollapsed then do;

		     if (waiting_to_make_array & ^tree_frame.output_array_sentinel) then do;
						/* no need to reset environment if */
						/* all done or returning into list */

			prev_tree_framep = addr (tree.node (tree.level - 1));

/* Pop out of the current graphic environment, restoring previous modes and mappings */
/* Only modes need be explicitly restored, as we hack all the mappings ourselves */

			if tree_frame.environment.intensity ^= prev_tree_frame.environment.intensity then
			     if prev_tree_frame.environment.intensity > 0 then
				call compile_simple_element (Intensity_char, Intensity,
				addr (prev_tree_frame.environment.intensity));

			if tree_frame.environment.linetype ^= prev_tree_frame.environment.linetype then
			     call compile_simple_element (Linetype_char, Linetype,
			     addr (prev_tree_frame.environment.linetype));

			if tree_frame.environment.sensitivity ^= prev_tree_frame.environment.sensitivity then
			     call compile_simple_element (Sensitivity_char, Sensitivity,
			     addr (prev_tree_frame.environment.sensitivity));

			if tree_frame.environment.blinking ^= prev_tree_frame.environment.blinking then
			     call compile_simple_element (Blinking_char, Blinking,
			     addr (prev_tree_frame.environment.blinking));

			if unspec (tree_frame.environment.color) ^= unspec (prev_tree_frame.environment.color) then
			     call compile_simple_element (Color_char, Color,
			     addr (prev_tree_frame.environment.color));
		     end;

		     tree_frame.environment_wall = ""b; /* force the collapse */
		     call collapse_level;
		end;

		tree_frame.precollapsed = ""b;	/* otherwise, mode or mapping as last element */
						/* of array "locks" this frame forever */

		if ^waiting_to_make_array then do;
		     substr (output_string, outi, 1) = Node_end_char;
		     outi = outi + length (Node_end_char);
		end;

		return;
	     end pop_level;
%skip (5);
collapse_level: proc;

		if tree.level <= 0 then
		     call sub_err_caller ("Attempt to pop past start of graphic tree.");

		if tree_frame.precollapsed then return;

		if tree_frame.environment_wall = "1"b then return;

/* Above occurs when attempt is made to collapse past a graphic array, which one shouldn't normally do.
   This will happen when expanding certain old-format MSGC where mappings could appear inside arrays. */

		if tree_frame.output_array_sentinel then do;
		     call get_to_cur_pos;		/* don't optimize trailing position changes away!! */
		     waiting_to_make_array = ""b;
		end;

		unspec (tree_frame) = ""b;		/* clear out level */

		tree.level = tree.level - 1;
		frame_ptr = addr (tree.node (tree.level));

		tree_frame.idx = tree_frame.idx + 1;
						/* move to next item in parent list */
		tree_frame.precollapsed = "1"b;

		return;
	     end collapse_level;
%page;
/* Internal procedure to check that node is in bounds, determine its graphic type and obtain its length */

find_node:     procedure (node_no, type, node_ptr, contents_p, copy_direct, n_elements);

dcl (node_no fixed bin (18),
     type fixed bin,
     n_elements fixed bin,
     copy_direct bit (1) aligned,
     node_ptr pointer,
     contents_p pointer) parameter;

dcl  lsm_type fixed bin;

		copy_direct = ""b;			/* always is for this entry */

		call lsm_$get_blk (wgs_p, node_no, lsm_type, n_elements, node_ptr, err_code);
		if err_code ^= 0 then go to non_local_return;

		if lsm_type > lsm_constants.n_types then goto bad_type;
		if lsm_type < 1 then goto bad_type;

		contents_p = addr (node_ptr -> any_node.data_space);

		goto Type (lsm_type);

Type (8):		type = List;
		return;

Type (9):		type = Array;
		return;

Type (3):						/* float */
Type (2):						/* fixed */
		type = contents_p -> effector.effector_code;
		if (type < Setposition) | (type > Color) then
		     goto bad_type;

		contents_p = addr (contents_p -> effector.data);
		n_elements = n_elements - 1;
		return;

Type (5):		type = Text;			/* char */
		return;

Type (4):		type = Datablock;			/* bit */
		contents_p = node_ptr;
		return;

Type (7):		type = Symbol;
		return;

Type (6):		goto bad_type;			/* symtab */
	     end find_node;
%page;
decode_effector: proc (ini, type, node_p, contents_p, copy_direct, n_elements);

dcl (ini fixed bin (21),
     type fixed bin,
     node_p pointer,
     contents_p pointer,
     copy_direct bit (1) aligned,
     n_elements fixed bin) parameter;

dcl  arg_type fixed bin;

dcl  fixed_contents (3) fixed bin based (contents_p),
     float_contents (3) float bin based (contents_p);

		node_p = null;			/* always is from this entry */
		copy_direct = ""b;			/* generally the case but not always */

		char = substr (input_string, ini, 1);
		ini = ini + 1;
		datap = addr (input_string_array (ini));

		type = index (string (structural_effector_codes), char) - 1;
		if type < 0 then goto not_valid_msgc;
		n_elements = no_args (type);
		arg_type = arg_types (type);
		ini = ini + n_elements * arg_lengths (arg_type);

		goto process (arg_type);

process (1): spi:	contents_p = addr (fixed_buffer);
		call graphic_code_util_$decode_spi (datap, n_elements, fixed_contents);
		return;

process (2): dpi:	contents_p = addr (float_buffer);
		call graphic_code_util_$decode_dpi (datap, n_elements, fixed_buffer);
		float_buffer (*) = fixed_buffer (*);
		return;

process (3): scl:	contents_p = addr (float_buffer);
		if type = Scaling then
		     call graphic_code_util_$decode_scl_nozero (datap, n_elements, float_contents);
		else begin;

/* forgive us this little while lie; graphic_code_util_ is written in ALM and
   couldn't care less about descriptors-- and this misdeclaration knocks 20%
   off this call, which is one of the two most heavily used in the program. */

dcl  graphic_code_util_$decode_scl entry (pointer, fixed bin, float bin dimension (3));

		     call graphic_code_util_$decode_scl (datap, n_elements, float_contents);
		end;
		return;

process (5): t: process (6): d:
		n_elements = graphic_element_length_ (input_string, ini-1) - 1;
		ini = ini + n_elements;		/* got bumped by zero above, do it right */

		if type = Symbol then contents_p = null;

		else do;				/* Text and Datablock */
		     copy_direct = "1"b;
		     contents_p = datap;
		end;

		return;

process (0): process (4):				/* illegal and uid */
		goto not_valid_msgc;

	     end decode_effector;
%page;
compile_null_element: proc;

/* compiles a null node, which is a pretty boring job. */

		if waiting_to_make_array then return;	/* no use fouling the water */
		substr (output_string, outi, length (Null_node_chars)) = Null_node_chars;
		outi = outi + length (Null_node_chars);
		return;
	     end compile_null_element;
%page;
/* Internal procedure to compile a simple node */

compile_simple_element: procedure (effector_char, node_type, contents_p);

dcl  effector_char char (1) parameter,
     node_type fixed bin parameter,
     contents_p pointer parameter;

dcl  fill_p pointer,
     arg_format fixed bin,
     fixed_contents (3) fixed bin based (contents_p),
     float_contents (3) float bin based (contents_p),
     temp_array (3) fixed bin,
    (nargs, nchars) fixed bin;


		if effector_char = Illegal_char then goto bad_type;
		substr (output_string, outi, 1) = effector_char;
		outi = outi + 1;

		fill_p = addr (output_string_array (outi));
		arg_format = arg_types (node_type);
		nargs = no_args (node_type);
		nchars = arg_lengths (arg_format) * nargs;

		go to encode (arg_format);


encode (1): spi:	call graphic_code_util_$encode_spi (fixed_contents, nargs, fill_p);
		go to encode_common;

encode (2): dpi:	temp_array = fixed (float_contents);	/* Float to fixed conversion for floating point coordinates */
		call graphic_code_util_$encode_dpi (temp_array, nargs, fill_p);
		go to encode_common;

encode (3): scl:	begin;

/* See comment at "decode (3): scl:" above. */

dcl  graphic_code_util_$encode_scl entry (float bin dimension (3), fixed bin, pointer);

		     call graphic_code_util_$encode_scl (float_contents, nargs, fill_p);
		end;
		go to encode_common;

encode (4): uid:	call graphic_code_util_$encode_uid (fixed_contents, nargs, fill_p);
		go to encode_common;

encode (5): t: encode (6): d:
		call sub_err_caller ("Attempt to encode text or datablock as simple effector.");

encode_common:	outi = outi + nchars;

		return;

	     end compile_simple_element;
%page;
/* Internal procedure to compile a text node */

compile_text_element: procedure (effector_char, count, contents_p, copy_direct);

dcl  effector_char char (1) parameter,
     count fixed bin parameter,
     contents_p pointer parameter,
     copy_direct bit (1) aligned;

dcl  fixed_array (1) fixed bin,
     to_ptr pointer,
     direct_text_copy char (count) based;

		substr (output_string, outi, 1) = effector_char;
		outi = outi + 1;

		if copy_direct then do;
		     to_ptr = addr (output_string_array (outi));
		     to_ptr -> direct_text_copy = contents_p -> direct_text_copy;
		     outi = outi + count;
		     return;
		end;

		fixed_array (1) = fixed (contents_p -> text_effector.alignment, 17);
		call graphic_code_util_$encode_spi (fixed_array, 1, addr (output_string_array (outi)));
		outi = outi + SPI_arg_length;

		fixed_array (1) = count - 1;
		call graphic_code_util_$encode_dpi (fixed_array, 1, addr (output_string_array (outi)));
						/* Stick in char string length */
		outi = outi + DPI_arg_length;


		substr (output_string, outi, count - 1) = substr (contents_p -> text_effector.text, 1, count - 1);
		outi = outi + count -1;

		return;
	     end compile_text_element;
%page;
/* Internal procedure to compile a data_block node */

compile_data_block: procedure (effector_char, count, contents_p, copy_direct);

dcl (effector_char char (1),
     count fixed bin,
     contents_p pointer,
     copy_direct bit (1) aligned) parameter;

dcl  output_string_bit_array (max_string_size) bit (9) unaligned based (output_string_ptr),
     direct_datablock_copy char (count) based,
     bit_contents bit (count) based (bcp),
     bcp pointer,
     to_ptr pointer,
     fixed_array (1) fixed bin,
     one bit (3) unaligned init ("001"b),
     i fixed bin;

		substr (output_string, outi, 1) = effector_char;
		outi = outi + 1;

		if copy_direct then do;		/* copy direct from old MSGC */
		     to_ptr = addr (output_string_array (outi));
		     to_ptr -> direct_datablock_copy = contents_p -> direct_datablock_copy;
		     outi = outi + count;
		     return;
		end;

		fixed_array (1) = count;		/* else assemble the data from the wgs */
		call graphic_code_util_$encode_dpi (fixed_array, 1, addr (output_string_array (outi)));
		outi = outi + DPI_arg_length;

		bcp = addr (contents_p -> bit_node.string);

		do i = 1 to count -6 by 6;
		     output_string_bit_array (outi) = one || substr (bit_contents, i, 6);
		     outi = outi + 1;
		end;

		output_string_bit_array (outi) = one || substr (bit_contents, i, mod (count, 6));
		outi = outi + 1;

		return;

	     end compile_data_block;

	end compile_node;
%page;
/* Internal procedure gets pointer to current working graphic seg */

initialize: procedure;

	     err_code = 0;

	     if control.from_wgs then do;
		call graphic_manipulator_$segp (wgs_p, err_code); /* Get a ptr to the w.g.s. */
		if err_code ^= 0 then go to non_local_return;
		if wgs_p = null () then do;		/* If no w.g.s. yet */
		     err_code = graphic_error_table_$no_wgs_yet;
		     go to non_local_return;
		end;
	     end;

	     else wgs_p = null;

	     if temp_seg_ptr = null then do;
		call get_temp_segment_ ("graphic_compiler_", temp_seg_ptr, err_code);
		if err_code ^= 0 then goto non_local_return;

		max_string_size = sys_info$max_seg_size * 4;
		sys_area_p = get_system_free_area_ ();
	     end;

	     if tree_ptr = null then call grow_tree;	/* initialize tree */

	     if ^control.return_string then do;
		if control.cur_switch = null then do;
		     call iox_$look_iocb ("graphic_output", graphic_output, err_code);
		     if err_code ^= 0 then goto non_local_return;
		end;

		auto_temp_seg_ptr = temp_seg_ptr;
	     end;

	     else auto_temp_seg_ptr = null;

	end initialize;
%skip (5);
grow_tree: proc;

dcl  i fixed bin,
     current_node fixed bin (18);

	     if tree_ptr ^= null then do;
		current_node = tree.node (tree.level).id;

		do i = tree.level - 1 to 1 by -1;
		     if current_node = tree.node (i).id then goto recursive_structure;
		end;

		max_levels = tree.max_level + 50;	/* increase levels by 50 */
	     end;

	     else max_levels = 10;			/* start with small tree */

	     temp_ptr = tree_ptr;

	     allocate tree in (sys_area);		/* get a bigger tree */

	     if temp_ptr ^= null then do;		/* if there is an old stack */

		unspec (tree_ptr -> tree) = unspec (temp_ptr -> tree);

		free temp_ptr -> tree in (sys_area);	/* get rid of it */

	     end;

	     tree.max_level = max_levels;

	end grow_tree;
%page;

/* Various matrix-hacking routines, stolen from the standalone graphic_matrix_util_. */

make_matrix: proc (rotations, scalings, matrix);		/* construct a graphic rotation/scaling matrix */

dcl  rotations (3) fixed bin parameter,
     scalings (3) float bin parameter,
     matrix (3, 3) float bin parameter;

dcl (sx, cx, sy, cy, sz, cz) float bin;			/* various sines and cosines */

	     cx = cosd (float (rotations (1))); sx = sind (float (rotations (1))); /* get sines and */
	     cy = cosd (float (rotations (2))); sy = sind (float (rotations (2))); /* cosines of angles */
	     cz = cosd (float (rotations (3))); sz = sind (float (rotations (3))); /* for use later on */

	     on underflow;				/* We ignore these */

/* take it on faith: this is a graphic rotation/scaling matrix */

	     matrix (1, 1) = cz * cy * scalings (1);
	     matrix (1, 2) = (-sz * cx + cz * sy * sx) * scalings (2);
	     matrix (1, 3) = (sz * sx + cx * cz * sy) * scalings (3);
	     matrix (2, 1) = cy * sz * scalings (1);
	     matrix (2, 2) = (cz * cx + sx * sy * sz) * scalings (2);
	     matrix (2, 3) = (-sx * cz + cx * sy * sz) * scalings (3);
	     matrix (3, 1) = -sy * scalings (1);
	     matrix (3, 2) = sx * cy * scalings (2);
	     matrix (3, 3) = cy * cx * scalings (3);

	     return;

multiply_3x3_x_3x3: entry (left_matrix, right_matrix, matrix); /* is a comment really necessary? */

dcl (left_matrix, right_matrix) (3, 3) float bin parameter;

dcl (i, j) fixed bin;

	     on underflow;

	     do i = 1 to 3;
		do j = 1 to 3;
		     matrix (i, j) = sum (left_matrix (i, *) * right_matrix (*, j)); /* 'cause the CRC says. */
		end;
	     end;

	     return;

multiply_3x3_x_1x3: entry (left_matrix, right_vector, vector);

dcl (right_vector, vector) (3) float bin parameter;

	     on underflow;				/* These are the bane of graphics programs */
	     do i = 1 to 3;
		vector (i) = sum (left_matrix (i, *) * right_vector); /* same principle */
	     end;

	     return;

	end make_matrix;

     end graphic_compiler_;
