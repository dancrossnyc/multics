/* ******************************************************
   *                                                    *
   *                                                    *
   * Copyright (c) 1972 by Massachusetts Institute of   *
   * Technology and Honeywell Information Systems, Inc. *
   *                                                    *
   *                                                    *
   ****************************************************** */

/* All scalar monadic and dyadic operators are implemented in this module,
   including reduction, outer and inner product, and scan.

	Created by G. Gordon Benedict on 06/23/73
	Modified on 740508 by PG to fix bug in 0!0
	Modified on 740614 by PG and GGB to fix bug in 10*^3 (was wrong data type)
	Modified on 741115 by PG to fix logarithm to check for errors properly,
		and fix (and, or, nand, nor) to work with vectors.
	Modified 750331 by PG to fix inner product to call do_many subroutine properly
		for each operator.
	Modified 750714 by PG to fix residue to use special apl_floor_ operator.
	Modified 760901 by PG to get 0*0 to work, to make trig operator validate left arg in
		all cases, and to fix = and /= of chars not to overlay the operands.
	Modified 760902 by PG to redo handling of data types so that all results are numeric except
		when reduction or scan just drops a dimension. Bug fixed that caused result of operating
		on null vectors when one arg is numeric and the other character to have no type bits.
	Modified 780210 by PG to use apl_push_stack_ (bug 278), and to fix 310
		(scanning with a non-commutative operator overlayed result on input operand and clobbered it).
	Modified 780303 by PG to fix bug 189 by making 0-:0 be 1, and to signal a zerodivide domain error
		if the divisor is equal to zero.
	Modified 780510 by William York to fix bug 322 by un-special-casing scalar operands to the scan
		operator that are on the value stack.
	Modified 781011 by WMY to fix bugs 311, 338, and 341.
	Modified 781101 by PG to fix bug 348 (reducing dimensions of unity extent fails),
		which was introduced 781011 when bug 338 was fixed.
	Modified 790122 by PG to use apl_error_table_$invalid_circular_fcn.
	Modified 790124 by PG to fix bug 360 (or-scan and and-scan of Booleans fail) and 359 (+/'' is not
		double-word aligned).
	Modified 790326 by PG to add monadic not equal, and to call apl_display_bead_.
	Modified 790618 by PG to fix 327 (binomial coefficients fails for negative args).
	Modified 790713 by PG to fix 407 (1-,'A' worked because type of operand
		was tested after overlayed result type was set!)
	Modified 790717 by PG for sugg 405 to change computation of the gamma
		function to use a more accurate algorithm.
	Modified 790727 by PG to put divide-reduction back into assembly language subroutine.
	Modified 800131 by BIM and PG to use new apl_monadic_not_appendage_ alm procedure.
	Modified 800302 by BIM to use new apl_dyadic_bool_appendage_ alm procedure.
	Modified 820429 by JRG to allow 50 choose 0 (0 ! 50). Used to give domain errors.
*/

apl_monadic_:
     procedure (operators_argument);		/* procedure to handle monadic type operators */

/* automatic */

declare
	copy_up_needed bit (1) aligned,	/* ON if a stack operand could not be overlayed */
	left_chars bit (1) aligned,		/* ON if left opnd is character */
	right_chars bit (1) aligned,		/* ON if right opnd is character */
	swapped_flag bit (1) aligned;		/* ON if order of operands was exchanged */

dcl	(
	copy_rho_vb,			/* ptr to value bead to take rho from for result */
	right_vb,				/* pointer to value bead for operand to right of operator */
	right_array,			/* ptr to right operand itself (data ptr from right v.b.) */
	left_vb,				/* ptr to v.b. to left of operator */
	left_array,			/* ptr to left operand */
	result_vb,			/* ptr to result v.b. */
	result_array			/* where result array will be stored */
			) pointer aligned;

dcl	(
	subscript,
	right_data_elements,		/* number of elements in right array */
	left_data_elements,			/* number of elements in left array */
	plane_base,			/* used in reduction; base of plane in operand array */
	column_base,			/* base of column in reduction currently being reduced */
	interval_between_elements,		/* interval between elements in same column being reduced */
	column_skip_interval,		/* how many times column_base is to be incremented by 1 before plane_base is */
	highest_column_element,		/* subscript into right operand array of highest subscript element in
					   column referenced during reduction -- first referenced */
	column_skip_interval_minus_1,		/* just to save subtracting 1 in a loop */
	rho_sub_dimension,			/* the extent of that dimension (copied for efficiency) */
	last_column_on_this_plane,		/* in reduction, last column base address + 1 */
	data_elements			/* used to tell stack_allocate_known how many elements are needed */
			) fixed binary precision (21);

declare	(data_words_needed,			/* to tell stack_allocate_known how many words needed */
	number_to_copy,			/* number of words in word_copy_overlay for copying */
	words_needed,			/* words needed to get from value stack. set by stack_allocate_known */
	words_needed_in_bead		/* words needed in value bead to be allocated. */
			) fixed binary precision (19);	/* for word counts */

dcl	(left_rhorho,			/* no of dimensions of left operand */
	dimension,			/* the dimension to reduce along (for reduction) */
	right_rhorho,			/* same for right */
	rhorho,				/* used to tell stack_allocate_known how much space needed in value bead */
	rho_subscript,			/* steps thru rho arrays, and as a temp in monadic */
	trig_integer,			/* integer which is left arg to circle functions */
	dyadic_action_place,		/* for dyadic routines */
	many_action_place,			/* which complicated operation to do (log, exp, binomial coefficients, etc.) */
	special_case,			/* added to many_action_place to get label - either 0 or 1 */
	action_place,			/* label array subscript identifying action routine in subroutines */
	op1				/* copy of operator code */
			) fixed binary;

dcl	(single_element_fl_1,		/* used to hold one arg if it is a scalar and the other an array */
	single_element_fl_2,		/* used if both operands are scalars (holds right element) */
	fuzz,				/* copy of fuzz in ws_info for efficiency */
	integer_fuzz,			/* copy of integer_fuzz */
	float_temp,			/* temporary for float -> integer conversions */
	boolean_both,			/* set to 1 for and/nand 0 for or/nor */
	set_on_equal,			/* used in char compare; what result is set to on equal compare */
	dyadic_set_on_equal,		/* value of set_on_equal for dyadic operations */
	dyadic_set_on_not_equal,		/* value of set_on_not_equal for dyadic operations */
	dyadic_boolean_both,		/* value of boolean_both for dyadic operations */
	dyadic_boolean_neither,		/* value of boolean_neither for dyadic operations */
	reduction_set_on_equal,		/* value of set_on_equal for reduction operations */
	reduction_set_on_not_equal,		/* value of set_on_not_equal for reduction operations */
	reduction_boolean_both,		/* value of boolean_both for reduction operations */
	reduction_boolean_neither,		/* value of boolean_neither for reduction operations */
	result_accumulator) float;		/* steps 1 by 1 to fill in iota array */

declare	1 reduction_type aligned like general_bead.type;	/* so reduction knows what type of operand it's getting */
declare	1 free_type aligned like general_bead.type;
declare	1 save_free_type aligned like general_bead.type;

/* entries */

declare	apl_display_bead_ entry (ptr, bit (1) aligned),
	apl_monadic_not_appendage_ entry (ptr, fixed bin (21), ptr, fixed bin),
          apl_monadic_not_appendage_$in_place entry (ptr, fixed bin (21)),
	(apl_dyadic_bool_appendage_$and,
           apl_dyadic_bool_appendage_$nand,
	 apl_dyadic_bool_appendage_$or,
	 apl_dyadic_bool_appendage_$nor,
	 apl_dyadic_bool_appendage_$eq,
	 apl_dyadic_bool_appendage_$neq)
	      entry (ptr, ptr, ptr, fixed bin (21)),
	apl_reduction_appendage_ entry (pointer, fixed bin (21), fixed bin (21), fixed bin (21), fixed bin, float bin (63)),
	apl_reduction_appendage_$divide entry (pointer, fixed bin (21), fixed bin (21), fixed bin (21), fixed bin, float bin (63),
	     label);

/* external static */

declare	(apl_error_table_$compatibility_error,
	apl_error_table_$display_disabled,
	apl_error_table_$domain,
	apl_error_table_$invalid_circular_fcn,
	apl_error_table_$length,
	apl_error_table_$no_identity,
	apl_error_table_$rank,
	apl_error_table_$zerodivide) fixed bin (35) external static;

/* builtins */

declare	(abs, addr, addrel, binary, ceil, complex, divide, exp, fixed, floor, imag, log,
	max, min, mod, real, rel, sign, substr, size, string, unspec) builtin;

/* based */

dcl	unal_fl_bit_ovly bit (72) aligned based;	/* for copying either a char on a word boundary
						or a floating pt number, without knowing which */
dcl	word_copy_overlay based dimension (number_to_copy) fixed bin (35);	/* for aggregate array copies */

/* internal static */

dcl	pi static internal float init		/* a bit string rendering of pi */
	( .110010010000111111011010101000100010000101101000110000100011010e+2b);

declare	booleans (11 : 14) static internal float initial
		(1, 0, 1, 0);

dcl	identity (0 : 20) float static internal init	/* identity for this operator */
		((2) 0, (2) 1,
		- .1701411834604692317e+39,
		.1701411834604692317e+39,
		1, (2) 0, 1, 0, 1,
		(2) 0, 1, 0,  (3) 1, (2) 0);

dcl	1 operator_info (0:20) static internal aligned,	/* gives info about operators */
	  2 identity_type bit (18) unal init	/* the type of the identity -- an error if ""b (no ident for this op) */
		((4)("001000000011100000"b),(2)("001000000010000000"b), (1) ("001000000011100000"b), (1) (""b),
		(2)("001000000011100000"b), (1) (""b),(2)("001000000011100000"b),(2)(""b),(6)("001000000011100000"b)),
	  2 eq_or_not_eq bit (1) unal init ((17) ("0"b), "1"b, (2) ("0"b), "1"b),
	  2 padding bit (17) unal;

dcl	(scalar init (0),			/* when added to 4 * op1 gives label subscript for routine to handle it */
	vector init (1),			/* similarly when added this is for vector routines */
	scalar_vector init (2),		/* for scalar on left, vector on right */
	vector_scalar init (3),		/* for vector on left, scalar on right */
	char_compare init (-4))		/* when subtracted from 1 of the above values gives subscript into
					   label array in dyadic_operate subr. of char comparison routines */
		static internal fixed bin;

/* include files */

%include apl_number_data;
%include apl_operators_argument;
%include apl_bead_format;
%include apl_value_bead;
%include apl_ws_info;
%include apl_operator_codes;

/* procedure to handle monadic operators. first copy info from argument structure for efficiency */

	call monadic_extract ();
	go to monadic_common;

/* this entry is called only for monadic not. it is not with the other monadic operators because it cannot be
   use dyadically (thus cannot participate in reduction, inner product, etc). Therefore its operator code
   is not contiguous with the others, making the monadic_do label array hard to use. In order to use common code,
   since monadic not otherwise acts like all the other monadic operators, it is given an operator code contiguous
   to the others (16) solely for use within this program */

apl_monadic_not_:
	entry (operators_argument);

	call monadic_extract ();
	op1 = 16;				/* assign dummy operation code */

monadic_common:
	rhorho = right_rhorho;			/* will want result to conform with arg operand */
	data_elements = right_data_elements;

	if operators_argument.operands (2).on_stack then do;	/* can overlay result on operand completely */
	     operators_argument.result,		/* parse wants address of result too */
	     result_vb = right_vb;			/* overlay result v.b. on operand v.b. */
	     result_array = right_array;		/* and result array on operand array */
	end;
	else do;					/* not such good luck, operand not on stack */
	     if right_chars
	     then call stack_allocate_char ();
	     else call stack_allocate_numeric ();

	     if right_vb -> value_bead.rhorho > 0
	     then result_vb -> value_bead.rho (*) = right_vb -> value_bead.rho (*);

	     string (result_vb -> value_bead.header.type) = string (free_type);
	end;

	if right_data_elements = 0			/* nothing to do */
	then if (op1 ^= equal_code) & (op1 ^= not_equal_code) /* unless debugging operators */
	     then return;

/* note all monadic operators must not have a character operand -- check this */

	if right_chars
	then if (op1 ^= equal_code) & (op1 ^= not_equal_code) /* let debugging operators thru */
	     then go to domain_error_right;

	goto monadic_do (op1);			/* go to action code for this operator */

/* Here begins the actual monadic operator action routines */

monadic_do (0):					/* PLUS. just return */
	if operators_argument.operands (2).on_stack then return;	/* with same thing as called with */
	result_array -> numeric_datum =
	     right_array -> numeric_datum;		/* copy data because operand was not on the stack */
	return;

monadic_do (1):					/* MINUS. negate each element of argument */
	result_vb -> value_bead.header.type.zero_or_one_value = "0"b;	/* probably will not make just 0s or 1s */

	result_array -> numeric_datum = - right_array -> numeric_datum;
	return;

monadic_do (2):					/* SIGNUM. 0 if 0, -1 if <0, 1 if >0 */
	result_vb -> value_bead.header.type.integral_value = "1"b;

	do subscript = 0 by 1 while (subscript < data_elements);
	     if abs (right_array -> numeric_datum (subscript)) < integer_fuzz then
		result_array -> numeric_datum (subscript) = 0;	/* equal to zero within integer_fuzz */
	     else if  right_array -> numeric_datum (subscript) < 0 then	/* negative, set result element to -1 */
		result_array -> numeric_datum (subscript) = -1;
		else result_array -> numeric_datum (subscript) = 1;
	end;
	return;

monadic_do (3):					/* INVERT. invert each element of arg operand */
	string (result_vb -> value_bead.header.type) = numeric_value_type;
	do subscript = 0 by 1 while (subscript < data_elements);
	     if right_array -> numeric_datum (subscript) = 0e0
	     then go to zerodivide_error_right;
	     else result_array -> numeric_datum (subscript) = 1e0 / right_array -> numeric_datum (subscript);
	end;
	return;

	/* N.B. For both ceiling and floor, if the input argument is
	   within "integer fuzz" of its integer value, the result
	   is this integer value.  Otherwise, the result is the value
	   of the respective function. */

monadic_do (4):					/* CEILING. smallest integer greater than arg. */
	string (result_vb -> value_bead.header.type) = integral_value_type;
 	do subscript = 0 by 1 while (subscript < data_elements);
	     single_element_fl_1 = right_array -> numeric_datum (subscript);
	     result_accumulator = floor (single_element_fl_1 + .5e0);

	     if abs (result_accumulator - single_element_fl_1) >= integer_fuzz
	     then result_accumulator = ceil (single_element_fl_1);

	     result_array -> numeric_datum (subscript) = result_accumulator;
	end;
	return;

monadic_do (5):					/* FLOOR. greatest integer smaller than arg. */
	string (result_vb -> value_bead.header.type) = integral_value_type;
 	do subscript = 0 by 1 while (subscript < data_elements);
	     single_element_fl_1 = right_array -> numeric_datum (subscript);
	     result_accumulator = apl_floor_ (single_element_fl_1);
	     result_array -> numeric_datum (subscript) = result_accumulator;
	end;
	return;


monadic_do (6):					/* EXPONENTIATION. raise to e'th power */
	string (result_vb -> value_bead.header.type) = numeric_value_type;
 	do subscript = 0 by 1 while (subscript < data_elements);

	      result_array -> numeric_datum (subscript) =		/* exponentiate it */
		exp (right_array -> numeric_datum (subscript));
	end;
	return;

monadic_do (7):					/* BASE E LOGARITHM. */
	string (result_vb -> value_bead.header.type) = numeric_value_type;
 	do subscript = 0 by 1 while (subscript < data_elements);
	     if right_array -> numeric_datum (subscript) < integer_fuzz then
		goto domain_error;
	     result_array -> numeric_datum (subscript) =
		log (right_array -> numeric_datum (subscript));
	end;
	return;

monadic_do (8):					/* ABSOLUTE VALUE. */
	if right_vb -> value_bead.zero_or_one_value
	then go to monadic_do (0);			/* treat like monadic plus */

	result_array -> numeric_datum =
	     abs (right_array -> numeric_datum);
	return;

monadic_do (9):					/* FACTORIAL. */
	do subscript = 0 by 1 while (subscript < data_elements);
	     result_array -> numeric_datum (subscript) =
		gamma (right_array -> numeric_datum (subscript) + 1e0);
	end;
	return;

monadic_do (10):					/* PI TIMES. */
	string (result_vb -> value_bead.header.type) = numeric_value_type;
	result_array -> numeric_datum =
	     pi * right_array -> numeric_datum;
	return;

monadic_do (16):					/* MONADIC NOT. */
	if right_vb -> value_bead.header.type.zero_or_one_value then do;	/* known is 0 or 1, optimize */
	     if operators_argument.operands (2).on_stack
	     then call apl_monadic_not_appendage_$in_place (right_array, right_data_elements);
	     else call apl_monadic_not_appendage_ (right_array, right_data_elements, result_array, rho_subscript);

/* The following statement is the old PL/I code that the above subroutine calls replaced.
   It is retained here to make it easy to revert the ALM version.

	     result_array -> numeric_datum (*) = 1 - right_array -> numeric_datum (*); */

	     return;
	end;

	string (result_vb -> value_bead.header.type) = zero_or_one_value_type;

 	do subscript = 0 by 1 while (subscript < data_elements);
	     if abs (right_array -> numeric_datum (subscript)) < integer_fuzz then	/* = 0, return 1 */
		result_array -> numeric_datum (subscript) = 1;	/* set to 1 */
	     else
		if abs (right_array -> numeric_datum (subscript) - 1) < integer_fuzz then	/* = 1, return 0 */
		     result_array -> numeric_datum (subscript) = 0;	/* set to 0 */
		else goto domain_error;	/* monadic not must have either 0 or 1 */
	end;
	return;

monadic_do (17):					/* MONADIC EQUAL. (display long) */
monadic_do (20):					/* MONADIC NOT EQUAL. (display brief) */
	if ^ws_info.debug_mode			/* Don't let random users trip over this...got to know the secret */
	then go to display_disabled;

	call apl_display_bead_ (right_vb, (op1 = not_equal_code));	/* brief if op is not equal */

	if ^operators_argument.operands (2).on_stack
	then result_array -> numeric_datum (*) = right_array -> numeric_datum (*);

	return;

/* The following entry point handles all dyadic operators */

apl_dyadic_:
	entry (operators_argument);

	call dyadic_extract ();
	call dyadic_result_lowest ();		/* point result_vb at operand lowest in stack */

/* check conformity of operands. either one (or both) must be effective scalars, i.e., have only
   one element, or they must have the same number of dimensions (rank error if not true) and each dimension
   must have the same length (length error if not) */

	if left_data_elements ^= 1 then do;		/* left is not scalar; check right */     
	     data_elements = left_data_elements;	/* since left is not scalar, result must be equal to it in size */

	     if right_data_elements ^= 1 then do;
		if left_rhorho ^= right_rhorho then goto rank_error;	/* loses */
		do subscript = 0 by 1 while (subscript < left_rhorho);	/* make sure each element of rho vectors are equal */
		     if left_vb -> value_bead.rho (subscript + 1) ^= right_vb -> value_bead.rho (subscript + 1) then
			goto length_error;			/* same no of dims but bounds don't match */
		end;
		dyadic_action_place = vector;		/* routine for vectors (or scalars) as both operands */
	     end;
	     else do;
		unspec (single_element_fl_1) = right_array -> unal_fl_bit_ovly;
		right_array = left_array;		/* reverse order of arrays; action routines use right_array as
						  operand pointers when one arg is scalar */
		swapped_flag = "1"b;		/* indicate swap for error handlers */
		dyadic_action_place = vector_scalar;	/* action routine for left vector, right scalar */
	     end;
copy_left:
	     rhorho = left_rhorho;			/* use dimensionality of left operand */
	     copy_rho_vb = left_vb;			/* .. */
	end;
	else do;					/* left scalar, right vector */
	     data_elements = right_data_elements;	/* since left is scalar, result has length of right */
	     if right_data_elements = 1 then do;	/* both scalar */
		dyadic_action_place = scalar;		/* action routine if both are scalars */
		unspec (single_element_fl_2) = right_array -> unal_fl_bit_ovly;	/* copy right scalar */
		unspec (single_element_fl_1) = left_array -> unal_fl_bit_ovly;	/* copy left scalar */
		if left_rhorho > right_rhorho then
		     goto copy_left;			/* both have 1 element, but use left rhorho */
	     end;
	     else do;			/* right is not scalar */
		dyadic_action_place = scalar_vector;		/* scalar on left, vector on right */
		unspec (single_element_fl_1) = left_array -> unal_fl_bit_ovly;	/* copy left scalar */
	     end;
	     rhorho = right_rhorho;
	     copy_rho_vb = right_vb;
	end;

	call stack_allocate_numeric ();

	if copy_rho_vb -> value_bead.rhorho > 0
	then result_vb -> value_bead.rho (*) = copy_rho_vb -> value_bead.rho (*);

	call fill_type ();			/* fill type field of result operand */

	if data_elements = 0 then return;		/* both operands null, return null vector */

	dyadic_set_on_equal = set_on_equal;
	dyadic_set_on_not_equal = 1 - set_on_equal;

	dyadic_boolean_both = boolean_both;
	dyadic_boolean_neither = 1 - boolean_both;

	if left_chars | right_chars
	then do;
		if ^ operator_info (op1).eq_or_not_eq then do;	/* only = and /= can take chars */
		     if left_chars then
			goto domain_error_left;
		     goto domain_error_right;
		end;
		if left_chars ^= right_chars
		then do;				/* chars on one side, numbers on other */
		     result_array -> numeric_datum = dyadic_set_on_not_equal;	/* 1s if /=, 0s if = */
		     return;
		end;
		dyadic_action_place = dyadic_action_place +
		     char_compare;	/* transform to label subscript of char compares in dyadic subr. */
	     end;
	else dyadic_action_place = dyadic_action_place + (4 * op1);	/* transform to correct label subscript */

	call dyadic_operate ();

	if copy_up_needed
	then go to copy_up_stack;

	return;

apl_reduction_:
	entry (operators_argument);

	call monadic_extract ();

/* Scalars need special treatment. */

	if right_rhorho = 0
	then do;
		if dimension > 1
		then go to rank_error;

		if operators_argument.operands (2).on_stack	/* try to special-case scalars on the stack */
		then do;
			operators_argument.result = right_vb;	/* still protected; just return it */
			return;
		     end;

		rhorho = 0;
		rho_sub_dimension = 1;
	     end;
	else do;
		rhorho = right_rhorho - 1;
		if dimension > right_rhorho then goto rank_error;	/* dimension is out of bounds */
		rho_sub_dimension = right_vb -> value_bead.rho (dimension);	/* the dimension which is to be deleted */
	     end;

 	call monadic_result_lowest ();		/* try to overlay result on right operand */
	string (reduction_type) = string (free_type);	/* copy type field so reduction subroutine knows type */

/* Check for null operands here. */

	if right_data_elements = 0 then do;	/* operand was null, return either identities or null array */
	     if rho_sub_dimension = 0 then do;	/* dropping null dimension; find out how many elements in result */
		data_elements = 1;	/* multiply all other dimensions except one to be dropped */
		do rho_subscript = 0 to dimension - 2, dimension by 1 while (rho_subscript < right_rhorho);
		     data_elements = data_elements * right_vb -> value_bead.rho (rho_subscript + 1);
		end;
	     end;
	     else			/* not dropping null dimension */
		data_elements = divide (right_data_elements, rho_sub_dimension, 21, 0);	/* drop a dimension */

	     call stack_allocate_numeric ();	/* get a value bead plus data_elements number of identities */
	     call fill_rho ();		/* fill rho vector from operand, leaving out rho (dimension) */
identity_fill:			/* inner product comes to here if inner dim is 0 */
	     string (result_vb -> value_bead.header.type) =
		operator_info (op1).identity_type;	/* assign result value bead correct type */
	     if data_elements = 0 then return;	/* return a null vector */
	     if operator_info (op1).identity_type = "0"b then
		goto no_identity_error;		/* this operator cannot operate on a null vector */
	     result_array -> numeric_datum = identity (op1);	/* assign identity */
	     return;

	end;

/* Check for scalars and dimensions of unity extent here. */

	if rho_sub_dimension = 1 then do;	/* just return operand with this rho dropped out */
	     data_elements = right_data_elements;	/* as many elements as in operand */
	     if right_chars then
		call stack_allocate_char ();
	     else				/* numeric type */
		call stack_allocate_numeric ();

	     call fill_rho ();		/* fill rho vector from operand, leaving out rho (dimension) */

	     /* Recover proper data type...free_type is never character, but right operand might have been. */

	     string (result_vb -> value_bead.type) = string (right_vb -> value_bead.type);
	     number_to_copy = data_words_needed;	/* copy data */
	     if number_to_copy > 0 then		/* avoid zero length array (illegal PL/I) */
		result_array -> word_copy_overlay =	/* copy arrays word by word */
		     right_array -> word_copy_overlay;
	     return;
	end;

/* Not a strange case. Calculate how many elements there will be in result by dividing number in operand
   by length of dimension to be reduced */

	data_elements = divide (right_data_elements, rho_sub_dimension, 21, 0);

/* calculate various intervals in operand array */

	interval_between_elements = 1;		/* the interval between elements within a column
						   being reduced is the product of all dimensions after the
						   one being reduced */
	do rho_subscript = dimension by 1 while (rho_subscript < right_rhorho);	/* multiply them */
	     interval_between_elements = interval_between_elements *
		right_vb -> value_bead.rho (rho_subscript + 1);
	end;

	column_skip_interval = interval_between_elements * rho_sub_dimension;
	column_skip_interval_minus_1 = column_skip_interval - interval_between_elements -
		interval_between_elements;	/* to save subtracting in loop */

	call stack_allocate_numeric ();
	call fill_rho ();
	call fill_type ();				/* subroutine to copy type field with exceptions */

/* if operator is = or /=, can take chars */

/* if operand is character type, must special case it */

	if right_chars
	then do;
	     if  ^ operator_info (op1).eq_or_not_eq then
		goto domain_error_right;			/* only = and /= can take chars */
	     if rho_sub_dimension > 2 then do;	/* can optimize heavily */
		result_array -> numeric_datum = 1 - set_on_equal;	/* = always returns 0 for more than 2
						chars, /= always returns 1 */
		return;
	     end;     

/* must be just 2 chars in dimension to reduce; 1 or 0 were special-cased before */     

	     element_size = 1;			/* one char per element */
	     action_place = -1;			 /* label subscript in reduction_operate routine for chars */
	end;     
	else				 /* not character, numeric */
	     element_size = NumberSize;	/* that many chars per number (for assignments with variable length) */

	reduction_set_on_equal = set_on_equal;
	reduction_set_on_not_equal = 1 - set_on_equal;

	reduction_boolean_both = boolean_both;
	reduction_boolean_neither = 1 - boolean_both;

/* Perform the reduction */

	subscript = 0;		/* initialize to first result element */
	do plane_base = 0 repeat (plane_base + column_skip_interval) while (plane_base < right_data_elements);
	     last_column_on_this_plane = plane_base + interval_between_elements;
	     do column_base = plane_base by 1 while (column_base < last_column_on_this_plane);

		highest_column_element = column_base + column_skip_interval_minus_1;
		addr (result_accumulator) -> char_string_overlay =
		     substr (right_array -> character_string_overlay, (highest_column_element +
		     interval_between_elements) * element_size + 1, element_size);
		call reduction_operate ();		/* reduce one column of this vector or array */

		result_array -> numeric_datum (subscript) = result_accumulator;
		subscript = subscript + 1;
	     end;
	end;
	if copy_up_needed
	then go to copy_up_stack;

	return;

/* the following module implements the outer product construct in APL.  This consists of applying the
   basic operator (in op1) to each pair of elements in the left and right arguments. Thus the total number
   of elements in the result equals the product of the numbers in the operands, the rho vector is the
   concatenation of the operand rho vectors, and the dimensionality (rank) is the sum of the operand ranks.
   The operation is performed by stepping thru each element of the left vector and storing it in the variable
   single_element_fl_1. The dyadic scalar_vector routine is then called */

apl_outer_product_:
	entry (operators_argument);

	call dyadic_extract ();			/* copy info from operands */
	data_elements = right_data_elements * left_data_elements;	/* result size = prod of operand sizes */
	rhorho = right_rhorho + left_rhorho;		/* result rhorho is sum of operand rhorho's */
						/* cannot overlay result on operands */
	call stack_allocate_numeric ();		/* get a result operand bead and value space */
	call fill_type ();			/* fill in result type, set other goodies */
	dyadic_set_on_equal = set_on_equal;
	dyadic_set_on_not_equal = 1 - set_on_equal;

	dyadic_boolean_both = boolean_both;
	dyadic_boolean_neither = 1 - boolean_both;

	dyadic_action_place = 4 * op1 + scalar_vector;		/* to which label to transfer in dyadic_operate */

/* now fill the rho vector of result. this will be the left rho vector concatenated
   with the right rho vector */

	number_to_copy = left_rhorho;	/* copy left rhorho */
	if number_to_copy > 0 then		/* avoid zero length array (illegal PL/I) */
	     addr (result_vb -> value_bead.rho (1)) -> word_copy_overlay =
		addr (left_vb -> value_bead.rho (1)) -> word_copy_overlay;

	number_to_copy = right_rhorho;	/* copy right rho after left rho */
	if number_to_copy > 0 then		/* avoid zero length array (illegal PL/I) */
	     addr (result_vb -> value_bead.rho (left_rhorho + 1)) -> word_copy_overlay =
		addr (right_vb -> value_bead.rho (1)) -> word_copy_overlay;

	if data_words_needed = 0 then		/* null operands */
	     goto copy_up_stack;		/* copy up stack */

	if left_chars | right_chars
	then do;
		if ^ operator_info (op1).eq_or_not_eq then do;	/* only = and /= can take chars */
		     if left_chars then
			goto domain_error_left;
		     goto domain_error_right;
		end;
		if left_chars ^= right_chars
		then do;				/* chars on one side, numbers on other */
			result_array -> numeric_datum = dyadic_set_on_not_equal;	/* 1s if /=, 0s if = */
			goto copy_up_stack;		/* copy result up stack */
		     end;
		dyadic_action_place =
		     scalar_vector + char_compare;	/* subscript of char scalar-vector compare in dyadic_operate */
		element_size = 1;	/* one char per element */
	end;
	else do;					/* not character, numeric */
	     element_size = NumberSize;	/* that many chars per number, for variable length assignments */
	     left_data_elements = left_data_elements * NumberSize;
	end;

	data_elements = right_data_elements;	/* use right for inner loop */
	do column_base = 0 repeat (column_base + element_size)
	     while (column_base < left_data_elements);	/* step thru left array */
		addr (single_element_fl_1) -> char_string_overlay =	/* extract a left element */
		     substr (left_array -> character_string_overlay, column_base + 1, element_size);
		call dyadic_operate ();		/* perform a scalar/ vector operation */
		result_array = addr (result_array -> numeric_datum (data_elements));	/* move to next result vector */
	end;
	goto copy_up_stack;			/* copy words up stack into operands */
/* This module implements the APL inner product construct.  The general algorithm is to copy into a
   temporary a row of the right array, then apply each row of the left array using a dyadic op1 operation.
   The result vector of this is then reduced, using op2 */

apl_inner_product_:
	entry (operators_argument);

dcl	(ip_subscript,			/* just another subscript, for inner product's use */
	left_total_chars,			/* total number of chars in left operand...for my kludgy overlays */
	right_move_count,			/* number of elements in each row of right operand */
	right_count,			/* number of rows on right */
	left_count,			/* number of rows on left */
	op2) fixed bin (21);		/* 2nd operator (user typed op2.op1) */

dcl	element_size fixed bin (4);		/* used in char string overlay hack */

dcl	(actual_left_array,			/* saves left array for recopying in loops */
	actual_right_array,			/* same for right array */
	actual_result_array,		/* same for result */
	temp_right_array,			/* points to temp right array, used for dyadic routines */
	recover_right_array,		/* this points at which pointer right_array should be loaded with */
	recover_single_element) ptr;		/* this points at which pointer points at the element single_element_fl_1 gets */

dcl	based_pointer ptr based;		/* used as dummy for recover_ pointers to point at */

dcl	char_string_overlay char (element_size) based unal;	/* can process either double-words or chars */

	call dyadic_extract ();			/* copy info from operands. */
						/* cannot overlay result on operands */
	column_base,		/* lower subscript bound used by reduction */
	rhorho = 0;			/* start off with 0 result rhorho */
	interval_between_elements,			/* reduction will always get contiguous arrays */
	right_count = 1;

	do rho_subscript = 2 by 1 while (rho_subscript <= right_rhorho);	/* same for right but drop 1st dim */
	     right_count = right_count *
		right_vb -> value_bead.rho (rho_subscript);
	     rhorho = rhorho + 1;		/* rhorho of result is sum of rhorho's of operands, minus dropped dimension */
	end;

	data_elements = right_count;		/* now multiply by same for left operand, giving result size */

	do rho_subscript = 1 by 1 while (rho_subscript < left_rhorho);
	     data_elements = data_elements *
		left_vb -> value_bead.rho (rho_subscript);	/* mpy all dimensions but last */
	     rhorho = rhorho + 1;		/* for each dim, add 1 to result dims */
	end;
	data_words_needed = size (numeric_datum);	/* words for stack_allocate_known and copy_up_stack */

/* check conformity of operands. The conformity rules for inner product are as follows: A scalar
   operand conforms to any other operand. A left operand with an inner (i.e., last) dimension of 1 conforms with
   any right operand. A right operand with an inner (i.e., first) dimension of 1 conforms with any left operand.
   Otherwise, the two inner dimensions must be the same.  There is no constraint on the rank of the operans */

	if left_data_elements ^= 1 then		/* not effective scalar */
	     left_count = left_vb -> value_bead.rho (left_rhorho);	/* number of elements in a left row */
	else
	     left_count = left_data_elements;	/* set to 1 because it is a scalar */

	if right_data_elements = 1 then		/* scalar */
	     right_move_count = right_data_elements;	/* set to 1, a scalar */
	else
	     right_move_count = right_vb -> value_bead.rho (1);	/* inner dimension of right operand */

/* now test conformity */

	if right_move_count ^= 1 then do;		/* neither an effective scalar, nor is inner dim 1 */
	     rho_sub_dimension = right_move_count;	/* take number of elements dyadic will process from right */
	     recover_right_array = addr (temp_right_array);	/* we will want right array to point here */
	     recover_single_element = addr (left_array);	/* single element will come from left */

	     if left_count ^= 1 then do;		/* also not scalar nor inner dim 1 */

		if left_count ^= right_move_count then	/* inner dims must agree if not 1 or scalar */
		     goto length_error;

		dyadic_action_place = vector;		/* since both inner dims are not 1 */
	     end;
	     else				/* left inner = 1 (or is a scalar), right vector */
		dyadic_action_place = scalar_vector;	/* left scalar, right vector */
	end;

	else do;					/* right is scalar or inner dim = 1 */
	     rho_sub_dimension = left_count;		/* left operand dominates, as right is scalar or inner dim 1 */
	     dyadic_action_place = vector_scalar;
	     recover_right_array = addr (left_array);	/* point right array at left in loop */
	     recover_single_element = addr (temp_right_array);	/* take scalar from right */
	     swapped_flag = "1"b;
	end;

	if rho_sub_dimension = 0 then do;	/* a null vector, return identities */
	     op1 = op2;				/* return identity of left operator */
	     call dyadic_result_lowest ();		/* put result_vb lowest on stack */
	end;
	else do;		/* test if a character operand */
		if left_chars | right_chars
		then do;
		     if ^ operator_info (op1).eq_or_not_eq then do;	/* only = and /= can take chars */
			if left_chars then
			     goto domain_error_left;
			goto domain_error_right;
		     end;
		     if left_chars & right_chars
		     then do;
			element_size = 1;		/* for certain overlay hacks */
			dyadic_action_place = dyadic_action_place + char_compare;
			if right_rhorho = 1 then	/* right is also vector, result will be scalar */
			     if op1 = equal_code then	/* for special case op2 must be and */
				if op2 = and_code then goto inner_product_compare_strings;
				else;
			     else			/* is not_equal_code, op2 must be or */
				if op2 = or_code then do; 	/* is or.not_equals */

inner_product_compare_strings:
				     call stack_allocate_numeric ();	/* get storage */
				     string (result_vb -> value_bead.header.type) = zero_or_one_value_type;
				     dyadic_set_on_equal = identity (op1);

				     dyadic_set_on_not_equal = 1 - dyadic_set_on_equal;
				     subscript = 0;
				     do ip_subscript = 0 repeat (ip_subscript + right_data_elements)
					while (ip_subscript < left_data_elements);

					if substr (left_array -> character_string_overlay, ip_subscript + 1, right_data_elements) =
					     substr (right_array -> character_string_overlay, 1, right_data_elements) then
					     result_array -> numeric_datum (subscript) = dyadic_set_on_equal;
					else
					     result_array -> numeric_datum (subscript) = dyadic_set_on_not_equal;

					subscript = subscript + 1;	/* next result element */
				     end;
			     /* now copy rho vector into result array value bead */
			     
				     subscript,
				     number_to_copy = max (left_rhorho - 1, 0);	/* if negative or 0, no rho elements to copy */
				     if number_to_copy > 0 then		/* copy, > 0 */
					addr (result_vb -> value_bead.rho) -> word_copy_overlay =
					     addr (left_vb -> value_bead.rho) -> word_copy_overlay;
				     number_to_copy = right_rhorho - 1;	/* if negative or 0, no rho elements to copy */
				     if number_to_copy > 0 then		/* copy, > 0 */
					addr (result_vb -> value_bead.rho (subscript + 1)) -> word_copy_overlay =
					     addr (right_vb -> value_bead.rho (2)) -> word_copy_overlay;
				     goto copy_up_stack;


				end;
		     end;

		     data_words_needed =
			data_words_needed + divide (right_move_count + 3, 4, 21, 0);
	     end;
	     else do;			/* not chars, set counts and flags appropriately */
		data_words_needed =		/* for temporary result array */
		     (size (result_accumulator) * right_move_count) + data_words_needed;
		dyadic_action_place = dyadic_action_place + (4 * op1);	/* add in operator to label subscript */
		element_size = NumberSize;
	     end;
	     data_words_needed = data_words_needed +	/* add more for temporaries needed */
		(size (result_accumulator) * rho_sub_dimension);	/* temporary result array */
	end;

	call stack_allocate_known ();		/* get storage for result and temps */

/* insert correct type into result */

	call fill_type ();		/* insert type after dyadic operator */
	dyadic_set_on_equal = set_on_equal;
	dyadic_set_on_not_equal = 1 - set_on_equal;

	dyadic_boolean_both = boolean_both;
	dyadic_boolean_neither = 1 - boolean_both;

	string (save_free_type) = string (free_type);
	string (reduction_type),		/* set for reduction to be type going into reduction */
	     string (free_type) =
	     string (result_vb -> value_bead.type);	/* copy out for next operator */
	action_place = op2;
	call fill_type ();
	string (free_type) = string (save_free_type);
	reduction_set_on_equal = set_on_equal;
	reduction_set_on_not_equal = 1 - set_on_equal;

	reduction_boolean_both = boolean_both;
	reduction_boolean_neither = 1 - boolean_both;

/* now copy rho vector into result array value bead */

	subscript,
	number_to_copy = max (left_rhorho - 1, 0);	/* if negative or 0, no rho elements to copy */
	if number_to_copy > 0 then		/* copy, > 0 */
	     addr (result_vb -> value_bead.rho) -> word_copy_overlay =
		addr (left_vb -> value_bead.rho) -> word_copy_overlay;

	number_to_copy = right_rhorho - 1;	/* if negative or 0, no rho elements to copy */
	if number_to_copy > 0 then		/* copy, > 0 */
	     addr (result_vb -> value_bead.rho (subscript + 1)) -> word_copy_overlay =
		addr (right_vb -> value_bead.rho (2)) -> word_copy_overlay;

	if rho_sub_dimension = 0 then			/* null array, return identities */
	     goto identity_fill;			/* same place reduction returns identities */

/* save ptrs to the operands and to the temporaries I have allocated on the stack because the dyadic and reduction
   routines expect these ptrs to be loaded with various things that will force them to be smashed */

	actual_result_array = result_array;		/* ptr to block allocated */
	result_array = addr (actual_result_array ->
	     numeric_datum (data_elements));	/* ptr to first temp block after; where dyadic will store result */

	data_elements = rho_sub_dimension;		/* so dyadic knows how much to do */
	temp_right_array = addr (result_array -> numeric_datum (data_elements));	/* ptr to 2nd temp block; where right row is built */
	actual_left_array = left_array;
	actual_right_array = right_array;

	highest_column_element = rho_sub_dimension - 2;	/* subtract 2 because reduction starts at next to last element */
	column_skip_interval = right_count * element_size;	/* offsets between right rows in characters */
	left_count = left_count * element_size;		/* length of a left row in characters */
	left_total_chars = left_data_elements * element_size;	/* total size of left array in characters */
	right_move_count = right_move_count * element_size;

/* Now comes the main loop */

	do plane_base = 0 by 1 while (plane_base < right_count);
	     subscript = plane_base * element_size;	/* copy an entire (not-contiguous, generally) right row */
	     do ip_subscript = 0 repeat (ip_subscript + element_size)
		while (ip_subscript < right_move_count);	/* into temp right array */

		     addr (temp_right_array -> character_data_structure.character_datum (ip_subscript))
   			-> char_string_overlay  =	/* copy an element */
		     addr (actual_right_array -> character_data_structure.character_datum (subscript))
			-> char_string_overlay;

		subscript = subscript + column_skip_interval;		/* offset to next element in right operand */
	     end;

	     ip_subscript = plane_base;		/* go thru each row of left, dyadicing it with temp right */

	     do subscript = 0 repeat (subscript + left_count) while (subscript < left_total_chars);

		left_array =
		     addr (actual_left_array -> character_data_structure.character_datum (subscript));	/* a left row */
		right_array =		/* point right_array at vector argument (if both vector, right one) */
		     recover_right_array -> based_pointer;
		addr (single_element_fl_1) -> char_string_overlay =	/* copy a scalar */
		     recover_single_element -> based_pointer -> char_string_overlay;

		call dyadic_operate ();		/* do dyadic operator */

		right_array = result_array;	/* now reduce result by op2 returned by dyadic */
		result_accumulator = result_array ->
		     numeric_datum (highest_column_element + 1);	/* initialize first reduction result */

		call reduction_operate ();

		actual_result_array -> numeric_datum (ip_subscript) =
		     result_accumulator;		/* put away result */
		ip_subscript = ip_subscript + right_count;	/* an element further on */
	     end;
	end;


	data_words_needed = size (result_accumulator) *
	     result_vb -> value_bead.total_data_elements;
	goto copy_up_stack;

/* The following module implements the scan construct in apl.  This is
   essentially a repeated application of reduction to its operand.  Thus result (1)
   = operand (1), result (2) = operand (1) <op> operand (2), etc.  Note that as
   usual in this losing language the reductions are applied right to left and thus except
   for commutative operators (such as plus, times, or, and, max, min) the result of scan
   is not the intermediate results from a reduction. Scan returns a result conforming with
   operand */

apl_scan_operator_:
	entry (operators_argument);

declare	actual_highest_column_element fixed binary precision (21, 0);	/* last element in column to reduce */
declare	flip_flag bit (1) aligned;	/* indicates whether processing even or odd element */

	call monadic_extract ();		/* pull information from right (and only) operand */

	if op1 <= min_code			/* plus thru min are commutative, and so it is */
	then call monadic_result_lowest ();	/* OK to overlay result completely on operand */
	else copy_up_needed = operators_argument.operands (2).on_stack;

	string (reduction_type) = string (free_type);	/* extract type to here for reduction_operate's sake */

/* result will conform with operand  -- make result that large and of those dimensions */

	rhorho = right_rhorho;		/* result has same number of dimensions as operand */
	data_elements = right_data_elements;	/* and same array elements */

	if data_elements = 0 then		/* null operand, return it */
	     goto return_right_scan;

	if rhorho = 0 then			/* scalar, return it */
	     goto return_right_scan;

	rho_sub_dimension = right_vb -> value_bead.rho (dimension);
	if rho_sub_dimension = 1 then do;	/* dimension to scan is 1, return operand */
return_right_scan:
	     if right_chars
	     then call stack_allocate_char ();
	     else call stack_allocate_numeric ();

	     if right_vb -> value_bead.rhorho > 0
	     then result_vb -> value_bead.rho (*) = right_vb -> value_bead.rho (*);

	     number_to_copy = data_words_needed;	/* copy data */
	     if number_to_copy > 0 then
		result_array -> word_copy_overlay =
		     right_array -> word_copy_overlay;

	     /* Recover proper data type...free_type is never character, but right operand might have been. */

	     string (result_vb -> value_bead.type) = string (right_vb -> value_bead.type);
	     return;			/* have made copy of operand, return it */
	end;

	if right_chars
	then go to domain_error_right;		/* can't scan character data */

/* get an array and bead of numeric type but conforming with operand */

	call stack_allocate_numeric ();	/* numeric type */
	call fill_type ();

	reduction_boolean_both = boolean_both;
	reduction_boolean_neither = 1 - boolean_both;

	reduction_set_on_equal = set_on_equal;
	reduction_set_on_not_equal = 1 - set_on_equal;

	if right_vb -> value_bead.rhorho > 0
	then result_vb -> value_bead.rho (*) = right_vb -> value_bead.rho (*);

/* calculate various intervals in operand array */

	interval_between_elements = 1;		/* the interval between elements within a column
						   being reduced is the product of all dimensions after the
						   one being reduced */
	do rho_subscript = dimension by 1 while (rho_subscript < right_rhorho);	/* multiply them */
	     interval_between_elements = interval_between_elements *
		right_vb -> value_bead.rho (rho_subscript + 1);
	end;

	column_skip_interval = interval_between_elements * rho_sub_dimension;
	column_skip_interval_minus_1 = column_skip_interval - interval_between_elements;

/* go thru actual scan loop now. note similarity to reduction */

	do  plane_base = 0 repeat (plane_base + column_skip_interval)
	     while (plane_base < right_data_elements);

	     last_column_on_this_plane = plane_base + interval_between_elements;

	     do column_base = plane_base by 1 while (column_base < last_column_on_this_plane);

		actual_highest_column_element = column_base + column_skip_interval_minus_1;

		result_accumulator,		/* set this so can be referenced as previous element */
		result_array -> numeric_datum (column_base) =	/* set first element of result to be first of operand */
		     right_array -> numeric_datum (column_base);

		goto scan_do (action_place);		/* perform actual operation */

scan_do (0):					/* scan plus */
		do subscript = column_base + interval_between_elements repeat (subscript + interval_between_elements)
		     while (subscript <= actual_highest_column_element);

			result_accumulator,
			result_array -> numeric_datum (subscript) =
			     right_array -> numeric_datum (subscript) +	/* add operand element */
			     result_accumulator;	/* to previous result */
		end;
		goto next_scan;

scan_do (1):					/* scan minus */
		flip_flag = "0"b;			/* indicate on even one */
		do subscript = column_base + interval_between_elements repeat (subscript + interval_between_elements)
		     while (subscript <= actual_highest_column_element);

			if flip_flag then
			     result_accumulator,
			     result_array -> numeric_datum (subscript) =
				right_array -> numeric_datum (subscript) +
				result_accumulator;

			else			/* even, subtract */
			     result_accumulator,
			     result_array -> numeric_datum (subscript) =
				result_accumulator -
				right_array -> numeric_datum (subscript);
			flip_flag = ^ flip_flag;		/* so reverse operation for next time */
		end;
		goto next_scan;

scan_do (2):					/* scan multiply */
		do subscript = column_base + interval_between_elements repeat (subscript + interval_between_elements)
		     while (subscript <= actual_highest_column_element);

			result_accumulator,
			result_array -> numeric_datum (subscript) =
			     right_array -> numeric_datum (subscript) *	/* multiply operand element */
			     result_accumulator;	/* to previous result */
		end;
		goto next_scan;

scan_do (3):					/* scan divide */
		flip_flag = "0"b;			/* indicate on even one */
		do subscript = column_base + interval_between_elements repeat (subscript + interval_between_elements)
		     while (subscript <= actual_highest_column_element);

			if flip_flag
			then result_accumulator = right_array -> numeric_datum (subscript) * result_accumulator;
			else			/* even, divide */
			     if right_array -> numeric_datum (subscript) = 0e0 /* divisor = 0? */
			     then if result_accumulator = 0e0 /* dividend = 0? */
				then result_accumulator = 1e0;
				else go to zerodivide_error_right;
			     else result_accumulator = result_accumulator / right_array -> numeric_datum (subscript);
			result_array -> numeric_datum (subscript) = result_accumulator;
			flip_flag = ^ flip_flag;		/* so reverse operation for next time */
		end;
		goto next_scan;

scan_do (4):			/* scan max */
		do subscript = column_base + interval_between_elements repeat (subscript + interval_between_elements)
		     while (subscript <= actual_highest_column_element);

			result_accumulator,
			result_array -> numeric_datum (subscript) =
			     max (right_array -> numeric_datum (subscript),	/* max operand element */
			     result_accumulator);	/* to previous result */
		end;
		goto next_scan;

scan_do (5):			/* scan min */
		do subscript = column_base + interval_between_elements repeat (subscript + interval_between_elements)
		     while (subscript <= actual_highest_column_element);

			result_accumulator,
			result_array -> numeric_datum (subscript) =
			     min (right_array -> numeric_datum (subscript),	/* min operand element */
			     result_accumulator);	/* to previous result */
		end;
		goto next_scan;

/* ones for all other operators follow. Will just call reduction repeatedly */

scan_do (6):	/* power */
scan_do (7):	/* log */
scan_do (8):	/* residue */
scan_do (9):	/* factorial */
scan_do (10):	/* circle */
scan_do (11):	/* and */
scan_do (12):	/* or */
scan_do (13):	/* nand */
scan_do (14):	/* nor */
scan_do (15):	/* < */
scan_do (16):	/* <_ */
scan_do (17):	/* /= */
scan_do (18):	/* >_ */
scan_do (19):	/* > */
scan_do (20):	/* = */
		do highest_column_element = column_base repeat (highest_column_element + interval_between_elements)
		     while (highest_column_element < actual_highest_column_element);

			result_accumulator = right_array -> numeric_datum
			     (highest_column_element + interval_between_elements);

			call reduction_operate ();

			result_array -> numeric_datum
			     (highest_column_element + interval_between_elements) =
			     result_accumulator;
		end;

next_scan:
	     end;
	end;
	if copy_up_needed
	then go to copy_up_stack;

	return;

/* procedure to copy garbage up stack. assumes variable words_needed_in_bead contains number of words
   in bead, data_words_needed contains words in data */

copy_up_stack:		/* not really a subroutine, just gone to */
	if ^ operators_argument.operands (2).on_stack then do;	/* right is not on stack */
	     if ^ operators_argument.operands (1).on_stack then do;	/* left is not on stack */
		operators_argument.result = result_vb;	/* leave answer where it is */
		return;
	     end;
	     right_vb = left_vb;		/* left is on stack and right is not -- overlay on left operand */
	end;
	if binary (rel (right_vb), 18, 0) + words_needed > ws_info.maximum_value_stack_size then do;
	     operators_argument.result = result_vb;		/* result will be where it is */
	     return;
	end;

/* the following kludges are used to copy the result operand lowest in the stack. Kludgy code using overlays
   and unspecs will be used until such time as the PL/I compiler can generate structure assignments
   without moving one bit at a time.  Note that previous code has set the right_vb ptr to point to the operand
   lowest in the stack; thus it may not still be pointing at the right value bead. */

/* now find the next doubleword boundary on which to put the result data. Note that if decimal data is
   someday used, alignment will not be necessary; in that case both the bead and data can be copied in one move */

	number_to_copy = words_needed_in_bead;	/* the words in the bead for the result, from stack_allocate */
	right_vb -> word_copy_overlay =	/* copy words from bead to end bead */
	     result_vb -> word_copy_overlay;
	right_array = addrel (right_vb, words_needed_in_bead);	/* try next word after bead */
	if substr (rel (right_array), 18, 1) then	/* if a 1 in low order bit, odd aligned */
	     right_array = addrel (right_array, 1);
	right_vb -> value_bead.data_pointer = right_array;	/* pointer to data */
	number_to_copy = data_words_needed;			/* number of data words to move */
	if number_to_copy > 0 then				/* zero length arrays are illegal PL/I */
	     right_array -> word_copy_overlay =		/* move in data */
		result_vb -> value_bead.data_pointer -> word_copy_overlay;
	result_array = addr (result_vb -> value_bead.rho (rhorho + 1));	/* word after value bead */
	ws_info.value_stack_ptr = addrel (right_array, data_words_needed);
	operators_argument.result = right_vb;
	return;

/* places to go to when an error is found */

compatibility_error_left:
	operators_argument.error_code = apl_error_table_$compatibility_error;
	operators_argument.where_error = operators_argument.where_error + 1;
	return;

display_disabled:					/* CONTEXT ERROR in brief mode */
	operators_argument.error_code = apl_error_table_$display_disabled;
	return;

domain_error_left_maybe:
	if swapped_flag then
	     goto domain_error_right;
	goto domain_error_left;

domain_error_right_maybe:
	if swapped_flag then
	     goto domain_error_left;

domain_error_right:
	operators_argument.where_error = operators_argument.where_error - 2;

domain_error_left:
	operators_argument.where_error = operators_argument.where_error + 1;

domain_error:
	operators_argument.error_code = apl_error_table_$domain;
	return;

invalid_circular_fcn_left:				/* DOMAIN ERROR in brief mode */
	operators_argument.where_error = operators_argument.where_error + 1;
	operators_argument.error_code = apl_error_table_$invalid_circular_fcn;
	return;

length_error:
	operators_argument.error_code = apl_error_table_$length;
	return;

no_identity_error:					/* DOMAIN ERROR in brief mode */
	operators_argument.error_code = apl_error_table_$no_identity;
	return;

rank_error:
	operators_argument.error_code = apl_error_table_$rank;
	return;

zerodivide_error_right:				/* DOMAIN ERROR in brief mode */
	operators_argument.where_error = operators_argument.where_error - 1;
	operators_argument.error_code = apl_error_table_$zerodivide;
	return;

/* The following subroutine is used to allocate a result value bead and a result array on the value stack.
   The rhorho of the result v.b. is given in variable rhorho, and the number of data elements in the result array
   is given in data_elements.  It sets result_vb to point to allocated value_bead and result_array to point to the
   array.  All fields in the value bead are filled in except value_bead.header.type and value_bead.rho.
   The bead is allocated on such a boundary that the next word after it (the first word of the result array) is
   doubleword aligned. */

stack_allocate_numeric:
	procedure ();

/* automatic */

declare	numeric bit (1) aligned;

/* program */

	data_words_needed = size (numeric_datum);	/* get result length from data_elements */
	numeric = "1"b;
	goto stack_allocate_known_common;		/* common code */

stack_allocate_char:				/* entry to assume thing to alloc is char */
	entry ();

	data_words_needed = size (character_string_overlay);	/* no. of chars */
	numeric = "0"b;
	go to stack_allocate_known_common;

stack_allocate_known:
	entry ();					/* caller has set data_words_needed */

	numeric = "1"b;

stack_allocate_known_common:				/* to transfer from above */
	number_of_dimensions = rhorho;
	words_needed_in_bead = size (value_bead);
	words_needed = words_needed_in_bead + data_words_needed + 1;	/* addition of 1 to doubleword align */
	result_vb = apl_push_stack_ (words_needed);
	result_array = addr (result_vb -> value_bead.rho (rhorho + 1));	/* word after value bead */
	if numeric
	then if substr (rel (result_array), 18, 1)
	     then result_array = addrel (result_array, 1);	/* if next word is odd-aligned, bump by 1 word */

	result_vb -> value_bead.total_data_elements = data_elements;
	result_vb -> value_bead.rhorho = rhorho;		/* make result conform with original operand */
	result_vb -> value_bead.data_pointer = result_array;	/* pointer to actual array */
	operators_argument.result = result_vb;		/* let parse know where I put result when I return */

end stack_allocate_numeric;

%include apl_push_stack_fcn;

/* The folowing subroutine is used to return a type field for a given scalar dyadic function. The variable op1
   must contain the operator code. The variable free_type must contain the AND of the types the operands */

fill_type:
	procedure ();

	goto get_type (action_place);		/* goto label array */

/* the following ones return the same type as the AND of the operands */

get_type (8):				/* residue */
	if ws_info.compatibility_check_mode then	/* check for negative left arg */
	     special_case = 1;		/* will cause do_many subroutine to check */

get_type (2):				/* multiply */
get_type (4):				/* max */
get_type (5):				/* min */
get_type (9):				/* binomial coefficients */
	string (result_vb -> value_bead.header.type) = string (free_type);	/* fill in result type */
	return;

/* the following ones can return non-Booleans and non-integers, no matter what the input type is. */

get_type (7):				/* log */
get_type (10):				/* trig functions */
	string (result_vb -> value_bead.header.type) = numeric_value_type;
	return;

/* the following one preserves integralness but not zero-or-one-ness */

get_type (0):				/* plus */
get_type (1):				/* subtract */
	string (result_vb -> value_bead.header.type)
	     = string (free_type) & not_zero_or_one_mask;	/* fill in result type */
	return;

/* the following one preserves booleanness but not integrallness (that is, result is guaranteed to be an
   integer and boolean only if operand(s) is (are), but not guaranteed to produce even an integer is
   the operand is integral but not boolean */

get_type (3):				/* divide */
get_type (6):				/* power */
	if free_type.data_type.zero_or_one_value then	/* preserves booleanness */
	     string (result_vb -> value_bead.header.type) = string (free_type);	/* fill in result type */
	else
	     string (result_vb -> value_bead.header.type) = numeric_value_type;	/* otherwise preserves nothing */
	return;

/* boolean operations. set boolean_both to be the value (either 0 or 1) to which the operands will be compared.
   If both operands are equal to this value, answer will be set to set_on_equal, otherwise set to set_on_not_equal.
   set_on_equal will have the identity of operator (if and or or) or 1 - identity (for nand, inverse of and; for
   nor, inverse of or). */

get_type (11):				/* and */
get_type (12):				/* or */
get_type (13):				/* nand */
get_type (14):				/* nor */
	boolean_both = booleans (action_place);

/* the following comparisons can only return boolean values */

get_type (15):					/* < */
get_type (16):					/* <_ */
get_type (17):					/* = */
get_type (18):					/* >_ */
get_type (19):					/* > */
get_type (20):					/*  /= */
	set_on_equal = identity (action_place);	/* identity for this operator */
	string (result_vb -> value_bead.header.type) = zero_or_one_value_type;
	return;

end fill_type;

/* subroutine to fill rho vector of newly created value bead from reduction.  The rho vector is merely copied from
   the right operand except that the dimension indicated by the variable dimension is not copied.  Note that if
   the result rho rho is to be 0 nothing need be copied; if it is to be 1, then the right operand rhorho was 2.
   Therefore if dimension = 1 then rho (2) is to copied, if dimension = 2 then rho (1) is to be copied */

fill_rho:
	procedure ();

	if rhorho = 0 then return;		/* result is scalar, no rho anyway */
	if rhorho = 1 then do;
	     result_vb -> value_bead.rho (1) =	/* copy 1 if dimension = 2, 2 if dimension = 1 */
	     right_vb -> value_bead.rho (3 - dimension);
	     return;
	end;

	number_to_copy = dimension - 1;	/* copy all dimensions before one to reduce */
	if number_to_copy > 0 then	/* check if zero length array (illegal PL/I) */
	     addr (result_vb -> value_bead.rho) -> word_copy_overlay =
		addr (right_vb -> value_bead.rho) -> word_copy_overlay;

	number_to_copy = rhorho - number_to_copy;	/* copy all after dimension to reduce */
	if number_to_copy > 0 then
	     addr (result_vb -> value_bead.rho (dimension)) -> word_copy_overlay =
		addr (right_vb -> value_bead.rho (dimension + 1)) -> word_copy_overlay;
	return;

end fill_rho;

/* procedure to extract information from operators_argument */

dyadic_extract:
	procedure ();

declare	dyadic bit (1) aligned init ("0"b);

/* copy information from argument structure */

	dyadic = "1"b;
	left_vb = operators_argument.operands (1).value;
	left_array = left_vb -> value_bead.data_pointer;
	left_data_elements = left_vb -> value_bead.total_data_elements;
	left_rhorho = left_vb -> value_bead.rhorho;
	left_chars = left_vb -> value_bead.character_value;

monadic_extract:			/* repeat for right operand */
	entry ();

	right_vb = operators_argument.operands (2).value;
	right_array = right_vb -> value_bead.data_pointer;
	right_data_elements = right_vb -> value_bead.total_data_elements;
	right_rhorho = right_vb -> value_bead.rhorho;
	right_chars = right_vb -> value_bead.character_value;

	if dyadic
	then do;
		string (free_type) = string (left_vb -> value_bead.type) & string (right_vb -> value_bead.type);
		if string (free_type.data_type) = ""b		/* aarghh!  mixed char and numeric operands */
		     | string (free_type) = character_value_type	/* both args are character */
		then string (free_type) = numeric_value_type;	/* just happens that all scalar ops return numbers */
	     end;
	else string (free_type) = string (right_vb -> value_bead.type);

	action_place,
	op1 = operators_argument.operator.op1;		/* copy out primary operator code */
	many_action_place = 2 * action_place;	/* for do_many subroutine */
	op2 = operators_argument.operator.op2;	/* 2nd operator for inner product (user typed op2.op1) */
	dimension = operators_argument.operator.dimension;	/* dimension over which to apply reduction */

	fuzz = ws_info.fuzz;		/* extract for efficiency */
	integer_fuzz = ws_info.integer_fuzz;
	special_case = 0;			/* not known to be a special case for do_many yet */
	swapped_flag = "0"b;

end dyadic_extract;

/* Subroutine to compute whether result can overlay one or more of the operands */

dyadic_result_lowest:
	procedure ();

	if left_chars & right_chars
	then copy_up_needed = "1"b;			/* can't overlay because result is numeric */
	else do;
		copy_up_needed = "0"b;
		if operators_argument.operands (2).on_stack	/* can overlay totally */
		then ws_info.value_stack_ptr = right_vb;			/* overlay on right value bead */
		else if operators_argument.operands (1).on_stack
		     then ws_info.value_stack_ptr = left_vb;		/* overlay on left value bead */
	     end;

end dyadic_result_lowest;

/* the same, for monadic routines */

monadic_result_lowest:
	procedure ();

	if ^right_chars & operators_argument.operands (2).on_stack
	then do;
		ws_info.value_stack_ptr = right_vb;		/* Overlay numeric right operand if it is on stack */
		copy_up_needed = "0"b;
	     end;
	else copy_up_needed = operators_argument.operands (2).on_stack;	/* copy if arg is on stack */

end monadic_result_lowest;

/* the following subroutine does dyadic operations. it expects result_array to point to
   the result array, action_place to contain the appropriate label for which operation to do, and data_elements
   to contain the number of result elements. if scalars are involved they must be in single_element_fl_1 and
   single_element_fl_2 */

/* The following is a short lecture on relative and integer fuzz. Despite what you might think, a fair amount
   of time and effort has gone into making sure that this program correctly handles the two types of fuzz.
   Relative fuzz is "how close" two numbers must be before they can be considered equal.  If we were
   in assembly language, we might do this test with a "test under mask" instruction.  But we aren't,
   and so we've devised a simple arithmetic scheme which works despite the magnitude of the numbers.
   When you look at the code, you may wonder why we actually test to see that two numbers are really equal before
   we actually test to see if they are "fuzz equal." Well, besides perhaps being faster,
   it seems that  zero does not compare fuzz equal to itself!  So, assuming A and B are both not zero,
   they are equal within relative fuzz iff:
		|A-B|
		----- < fuzz
		|A+B|
   As for integer fuzz (which is how close a floating-point number must be to an integer before it can be
   considered an integer; and note that there is no requirement that integer fuzz = relative fuzz),
   a number F is considered to be the integer floor(F+0.5) iff:
		abs(floor(F+0.5) - F) < integer_fuzz
   For testing F to be within integer fuzz of zero, this simplifies to:
		abs(F) < integer_fuzz

   For testing F to be equal to a specific integer I,
		abs (F - I) < integer_fuzz

   Class dismissed. */

dyadic_operate:
	procedure ();

dcl	subscript fixed bin (21);		/* provides a random subscript... don't use one in outer block,
					   in order to avoid naming conflicts */

	goto dyadic_do (dyadic_action_place);	/* select correct action routine depending upon variable action_place */


/* actual action routines for various operators.  note that those that are commutative have the same routine for
   <vector> <op1> <scalar> and <scalar> <op1> <vector>. Note that this includes the comparison operators
   which are not commutative (< <_ > >_); merely the results have been changed.(ie., set_on_equal is opposite, etc.). */

dyadic_do (0):				/* both scalar, + */
	result_array -> numeric_datum (0) =
	     single_element_fl_1 +
	     single_element_fl_2;
	return;

dyadic_do (1):			/* vector handler for PLUS */
	do subscript = 0 by 1 while (subscript < data_elements);
	     result_array -> numeric_datum (subscript) =
		left_array -> numeric_datum (subscript) +
		right_array -> numeric_datum (subscript);
	end;
	return;

dyadic_do (2):					/* left sc, right vc */
dyadic_do (3):					/* left vc, right sc */
	do subscript = 0 by 1 while (subscript < data_elements);
	     result_array -> numeric_datum (subscript) =
		single_element_fl_1 /* the scalar */ +
		right_array -> numeric_datum (subscript);	/* the vector */
	end;
	return;

dyadic_do (4):			/* both scalar, - */
	result_array -> numeric_datum (0) =
	     single_element_fl_1 -
	     single_element_fl_2;
	return;

dyadic_do (5):			/* vector handler for MINUS */
	do subscript = 0 by 1 while (subscript < data_elements);
	     result_array -> numeric_datum (subscript) =
		left_array -> numeric_datum (subscript) -
		right_array -> numeric_datum (subscript);
	end;
	return;

dyadic_do (6):			/* left sc, right vc */
	do subscript = 0 by 1 while (subscript < data_elements);
	     result_array -> numeric_datum (subscript) =
		single_element_fl_1 /* the scalar */ -
		right_array -> numeric_datum (subscript);	/* the vector */
	end;
	return;

dyadic_do (7):			/* left vc, right sc */
	do subscript = 0 by 1 while (subscript < data_elements);
	     result_array -> numeric_datum (subscript) =
		right_array -> numeric_datum (subscript) -
		single_element_fl_1;
	end;
	return;

dyadic_do (8):				/* both scalar, * */
	result_array -> numeric_datum (0) =
	     single_element_fl_1 *
	     single_element_fl_2;
	return;

dyadic_do (9):			/* both vector, times */
	do subscript = 0 by 1 while (subscript < data_elements);
	     result_array -> numeric_datum (subscript) =
		left_array -> numeric_datum (subscript) *
		right_array -> numeric_datum (subscript);
	end;
	return;

dyadic_do (10):			/* left sc, right vc */
dyadic_do (11):			/* but multiplication is commutative */
	do subscript = 0 by 1 while (subscript < data_elements);
	     result_array -> numeric_datum (subscript) =
		single_element_fl_1 /* the scalar */ *
		right_array -> numeric_datum (subscript);	/* the vector */
	end;
	return;

dyadic_do (12):			/* both scalar, divide */
	if single_element_fl_2 = 0e0
	then if single_element_fl_1 = 0e0	/* dividend =0? */
	     then result_array -> numeric_datum (0) = 1e0;
	     else go to zerodivide_error_right;
	else result_array -> numeric_datum (0) = single_element_fl_1 / single_element_fl_2;
	return;

dyadic_do (13):			/* both vectors, divide */
	do subscript = 0 by 1 while (subscript < data_elements);
	     if right_array -> numeric_datum (subscript) = 0e0 /* divisor =0? */
	     then if left_array -> numeric_datum (subscript) = 0e0 /* dividend =0? */
		then result_array -> numeric_datum (subscript) = 1e0;
		else go to zerodivide_error_right;
	     else result_array -> numeric_datum (subscript) =
		     left_array -> numeric_datum (subscript) /
		     right_array -> numeric_datum (subscript);
	end;
	return;

dyadic_do (14):			/* left sc, right vc, divide */
	do subscript = 0 by 1 while (subscript < data_elements);
	     if right_array -> numeric_datum (subscript) = 0e0 /* divisor =0? */
	     then if single_element_fl_1 = 0e0	/* dividend =0? */
		then result_array -> numeric_datum (subscript) = 1e0;
		else go to zerodivide_error_right;
	     else result_array -> numeric_datum (subscript) =
		     single_element_fl_1 / right_array -> numeric_datum (subscript);
	end;
	return;

dyadic_do (15):			/* left vector, right scalar, divide */
	do subscript = 0 by 1 while (subscript < data_elements);
	     if single_element_fl_1 = 0e0	/* divisor 0? */
	     then if right_array -> numeric_datum (subscript) = 0e0 /* dividend =0? */
		then result_array -> numeric_datum (subscript) = 1e0;
		else go to zerodivide_error_right;
	     else result_array -> numeric_datum (subscript) =
		     right_array -> numeric_datum (subscript) / single_element_fl_1;
	end;
	return;

dyadic_do (16):			/* both scalar, max */
	result_array -> numeric_datum (0) = max (single_element_fl_1, single_element_fl_2);
	return;

dyadic_do (17):			/* both vector, max */
	do subscript = 0 by 1 while (subscript < data_elements);
	     result_array -> numeric_datum (subscript) =
		max (left_array -> numeric_datum (subscript), right_array -> numeric_datum (subscript));
	end;
	return;

dyadic_do (18):			/* left sc, right vc, max */
dyadic_do (19):			/* right sc, left vc, max */
	do subscript = 0 by 1 while (subscript < data_elements);
	     result_array -> numeric_datum (subscript) =
		max (single_element_fl_1, right_array -> numeric_datum (subscript));
	end;
	return;

dyadic_do (20):			/* both scalar, min */
	result_array -> numeric_datum (0) = min (single_element_fl_1, single_element_fl_2);
	return;

dyadic_do (21):			/* both vector, min */
	do subscript = 0 by 1 while (subscript < data_elements);
	     result_array -> numeric_datum (subscript) =
		min (left_array -> numeric_datum (subscript), right_array -> numeric_datum (subscript));
	end;
	return;

dyadic_do (22):			/* left sc, right vc, min */
dyadic_do (23):			/* right sc, left vc, min */
	do subscript = 0 by 1 while (subscript < data_elements);
	     result_array -> numeric_datum (subscript) =
		min (single_element_fl_1, right_array -> numeric_datum (subscript));
	end;
	return;

dyadic_do (24):			/* both scalar, exponentiate */
dyadic_do (28):			/* both scalar, log */
dyadic_do (32):			/* both scalar, residue */
dyadic_do (36):			/* both scalar, binomial coefficients */
dyadic_do (40):			/* both scalar, trig */
	call do_many ();			/* perform operation depending on many_action_place */
	result_array -> numeric_datum (0) = result_accumulator;
	return;

dyadic_do (25):				/* both vector, exp */
dyadic_do (29):			/* both vectors, log */
dyadic_do (33):			/* both vectors, residue */
dyadic_do (37):			/* both vectors, binomial coefficients */
dyadic_do (41):				/* both vector, trig */
	do subscript = 0 by 1 while (subscript < data_elements);
	     single_element_fl_1 = left_array -> numeric_datum (subscript);
	     single_element_fl_2 = right_array -> numeric_datum (subscript);
	     call do_many ();
	     result_array -> numeric_datum (subscript) =
		result_accumulator;
	end;
	return;

dyadic_do (42):			/* left scalar, right vector, trig */
	float_temp = floor(single_element_fl_1 + 0.5);	/* convert arg to fixed */
	if abs(float_temp - single_element_fl_1) > integer_fuzz then goto domain_error_left;
	if abs(float_temp) > 7 then goto domain_error_left;
	trig_integer = fixed(float_temp, 3);	/* convert to integer between -7 and +7 */
	special_case = 1;			/* is special case because we know left is integral */

dyadic_do (26):				/* left scalar, right vector, exp */
dyadic_do (30):			/* left scalar, right vector, log */
dyadic_do (34):			/* left scalar, right vector, residue */
dyadic_do (38):			/* left scalar, right vector, binomial coefficients */
	do subscript = 0 by 1 while (subscript < data_elements);
	     single_element_fl_2 = right_array -> numeric_datum (subscript);
	     call do_many ();
	     result_array -> numeric_datum (subscript) =
		result_accumulator;
	end;
	return;

dyadic_do (27):			/* left vector, right scalar, exp */
	float_temp = floor(single_element_fl_1 + 0.5);
	if abs(float_temp - single_element_fl_1) <= integer_fuzz then
	     if abs(float_temp) < 1e17b then do;	/* integer */
		trig_integer = fixed(float_temp, 17);		/* yes, it is integer exponent */
		special_case = 1;
	     end;

dyadic_do (31):			/* right scalar, left vector, log */
dyadic_do (35):			/* right scalar, left vector, residue */
dyadic_do (39):			/* right scalar, left vector, binomial coefficients */
dyadic_do (43):			/* left vector, right scalar, trig */
	single_element_fl_2 = single_element_fl_1;
	do subscript = 0 by 1 while (subscript < data_elements);
	     single_element_fl_1 = right_array -> numeric_datum (subscript);
	     call do_many ();
	     result_array -> numeric_datum (subscript) =
		result_accumulator;
	end;
	return;

dyadic_do (44):			/* both scalar, and */
dyadic_do (48):			/* both scalar, or */
dyadic_do (52):			/* both scalar, nand */
dyadic_do (56):			/* both scalar, nor */
	if abs (single_element_fl_1 - dyadic_boolean_both) < integer_fuzz then do;
	     if abs (single_element_fl_2 - dyadic_boolean_both) < integer_fuzz then do;
		result_array -> numeric_datum (0) = dyadic_set_on_equal;
		return;
	     end;
	     if abs (single_element_fl_2 - dyadic_boolean_neither) >= integer_fuzz then goto domain_error_right;
	end;
	else
	     if abs (single_element_fl_1 - dyadic_boolean_neither) >= integer_fuzz then goto domain_error_left;

	if abs (single_element_fl_2 - dyadic_boolean_both) >= integer_fuzz then	/* check 2nd operand */
	     if abs (single_element_fl_2 - dyadic_boolean_neither) >= integer_fuzz then	/* doom */
		goto domain_error_right;		/* neither 0 nor 1 */

	result_array -> numeric_datum (0) = dyadic_set_on_not_equal;
	return;

dyadic_do (45):			/* both vector, and */
	if free_type.zero_or_one_value then do;
	     call apl_dyadic_bool_appendage_$and (left_array, right_array, result_array, data_elements);
	     return;
	end;
	else goto dyadic_do_bool_vector;

dyadic_do (49):			/* both vector, or */
	if free_type.zero_or_one_value then do;
	     call apl_dyadic_bool_appendage_$or (left_array, right_array, result_array, data_elements);
	     return;
	end;
	else goto dyadic_do_bool_vector;

dyadic_do (53):			/* both vector, nand */
	if free_type.zero_or_one_value then do;
	     call apl_dyadic_bool_appendage_$nand (left_array, right_array, result_array, data_elements);
	     return;
	end;
	else goto dyadic_do_bool_vector;

dyadic_do (57):			/* both vector, nor */
	if free_type.zero_or_one_value then do;
	     call apl_dyadic_bool_appendage_$nor (left_array, right_array, result_array, data_elements);
	     return;
	end;

/* The following block of code has now been replaced by apl_dyadic_bool_appendage_.
   It is retained here to make it easy to revert the ALM procedure.

dyadic_do (45):					!* both vector, and *!
dyadic_do (49):					!* both vector, or *!
dyadic_do (53):					!* both vector, nand *!
dyadic_do (57):					!* both vector, nor *!
	if free_type.zero_or_one_value then do;
	     do subscript = 0 by 1 while (subscript < data_elements);
		if left_array -> numeric_datum (subscript) = dyadic_boolean_both then
		     if right_array -> numeric_datum (subscript) = dyadic_boolean_both then
			result_array -> numeric_datum (subscript) = dyadic_set_on_equal;
		     else
			result_array -> numeric_datum (subscript) = dyadic_set_on_not_equal;
		else
		     result_array -> numeric_datum (subscript) = dyadic_set_on_not_equal;
	     end;
	     return;
	end;
*/

dyadic_do_bool_vector:
	do subscript = 0 by 1 while (subscript < data_elements);
	     if abs (left_array -> numeric_datum (subscript) - dyadic_boolean_both) < integer_fuzz then do;
		if abs (right_array -> numeric_datum (subscript) - dyadic_boolean_both) < integer_fuzz then do;
		     result_array -> numeric_datum (subscript) = dyadic_set_on_equal;
		     goto get_next_element_45;
		end;
		if abs (right_array -> numeric_datum (subscript) - dyadic_boolean_neither) >= integer_fuzz then
		     goto domain_error_right;
	     end;
	     else
		if abs (left_array -> numeric_datum (subscript) - dyadic_boolean_neither) >= integer_fuzz then
		     goto domain_error_left;

	     if abs (right_array -> numeric_datum (subscript) - dyadic_boolean_both) >= integer_fuzz
	     then if abs (right_array -> numeric_datum (subscript) - dyadic_boolean_neither) >= integer_fuzz
		then go to domain_error_right;	/* opnd 2 is neither 0 nor 1 */

	     result_array -> numeric_datum (subscript) = dyadic_set_on_not_equal;
get_next_element_45:
	end;
	return;

dyadic_do (54):			/* left sc, right vc, nand */
dyadic_do (58):			/* left sc, right vc, nor */
dyadic_do (55):			/* left vc, right sc, nand */
dyadic_do (59):			/* left vc, right sc, nor */
	if free_type.zero_or_one_value then do;	/* known that both are zero or one */
     	     if single_element_fl_1 = dyadic_boolean_both then do;
		result_array -> numeric_datum =
		     1 - right_array -> numeric_datum;	/* invert each one */
		return;
	     end;

	     result_array -> numeric_datum = dyadic_set_on_not_equal;
	     return;
	end;

	single_element_fl_1 = 1 - single_element_fl_1;	/* invert for not types */
dyadic_do (46):			/* left sc, right vc, and */
dyadic_do (50):			/* left sc, right vc, or */
dyadic_do (47):			/* left vc, right sc, and */
dyadic_do (51):			/* left vc, right sc, or */
	if free_type.zero_or_one_value then do;	/* must be and  | or, because of test above */
	     if single_element_fl_1 = dyadic_boolean_neither then do;	/* 0 clears and, 1 sets or */
		result_array -> numeric_datum = dyadic_set_on_not_equal;	/* set whole array */
		return;
	     end;

	     if result_array ^= right_array then	/* 1 and X is X; 0 or X is X */
		result_array -> numeric_datum =
		     right_array -> numeric_datum;	/* move whole array, pointers not same */
	     return;
	end;

	if abs (single_element_fl_1 - dyadic_boolean_both) > integer_fuzz then
	     if abs (single_element_fl_1 - dyadic_boolean_neither) > integer_fuzz
	     then goto domain_error_left_maybe;			/* neither 0 nor 1 */
	do subscript = 0 by 1 while (subscript < data_elements);
	     if abs (right_array -> numeric_datum (subscript) - dyadic_boolean_both) < integer_fuzz then
		result_array -> numeric_datum (subscript) = single_element_fl_1;
	     else if abs (right_array -> numeric_datum (subscript) - dyadic_boolean_neither) < integer_fuzz then
		result_array -> numeric_datum (subscript) = dyadic_set_on_not_equal;
		else goto domain_error_right_maybe;
	end;
	return;

dyadic_do (80):				/* scalar /= */
dyadic_do (68):				/* scalar = */
	if single_element_fl_1 = single_element_fl_2 then
	     result_array -> numeric_datum (0) = dyadic_set_on_equal;
	else
	     if abs (single_element_fl_2 - single_element_fl_1) <
			abs(fuzz * (single_element_fl_1 + single_element_fl_2)) then
			result_array -> numeric_datum (0) = dyadic_set_on_equal;
		else
		     result_array -> numeric_datum (0) = dyadic_set_on_not_equal;
	return;

dyadic_do (81):			/* /= for vectors */
	if free_type.zero_or_one_value then do;
	     call apl_dyadic_bool_appendage_$neq (left_array, right_array, result_array, data_elements);
	     return;
	end;
	else goto dyadic_do_eq_neq_vector;

dyadic_do (69):			/* = for vectors */
	if free_type.zero_or_one_value then do;
	     call apl_dyadic_bool_appendage_$eq (left_array, right_array, result_array, data_elements);
	     return;
	end;

dyadic_do_eq_neq_vector:
	do subscript = 0 by 1 while (subscript < data_elements);
	     if left_array -> numeric_datum (subscript) =
		right_array -> numeric_datum (subscript) then
		     result_array -> numeric_datum (subscript) = dyadic_set_on_equal;
	     else
		if abs(left_array -> numeric_datum(subscript) - right_array -> numeric_datum(subscript)) <
		     abs(fuzz * (left_array -> numeric_datum(subscript) + right_array -> numeric_datum(subscript))) then
			result_array -> numeric_datum (subscript) = dyadic_set_on_equal;
		else
		     result_array -> numeric_datum (subscript) = dyadic_set_on_not_equal;
	end;
	return;

dyadic_do (82):				/* left sc, right vc, /= */
dyadic_do (83):				/* left vc, right sc, /= */
dyadic_do (70):				/* left sc, right vc, = */
dyadic_do (71):				/* right sc, left vc, = */
	do subscript = 0 by 1 while (subscript < data_elements);
	     if single_element_fl_1 = right_array -> numeric_datum (subscript) then
		result_array -> numeric_datum (subscript) = dyadic_set_on_equal;
	     else
		if abs (single_element_fl_1 -
		     right_array -> numeric_datum (subscript) ) <
		     abs(fuzz * (single_element_fl_1 + right_array -> numeric_datum(subscript))) then
			result_array -> numeric_datum (subscript) = dyadic_set_on_equal;
		else
		     result_array -> numeric_datum (subscript) = dyadic_set_on_not_equal;
	end;
	return;

dyadic_do (64):				/* scalar <_ */
dyadic_do (76):				/* scalar > */
	if single_element_fl_1 <=
	     single_element_fl_2  then
		     result_array -> numeric_datum (0) = dyadic_set_on_equal;
	     else if abs(single_element_fl_1 - single_element_fl_2) <
		abs(fuzz * (single_element_fl_1 + single_element_fl_2)) then
		     result_array -> numeric_datum (0) = dyadic_set_on_equal;
	     else
		result_array -> numeric_datum (0) = dyadic_set_on_not_equal;
	return;

dyadic_do (65):			/* <_ for vectors */
dyadic_do (77):			/* > for vectors */
	do subscript = 0 by 1 while (subscript < data_elements);
	     if left_array -> numeric_datum (subscript) <=
		right_array -> numeric_datum (subscript)  then
		     result_array -> numeric_datum (subscript) = dyadic_set_on_equal;
	     else if abs(left_array -> numeric_datum(subscript) - right_array -> numeric_datum(subscript)) <
		abs(fuzz * (left_array -> numeric_datum(subscript) + right_array -> numeric_datum(subscript))) then
		     result_array -> numeric_datum(subscript) = dyadic_set_on_equal;
	     else
		result_array -> numeric_datum (subscript) = dyadic_set_on_not_equal;
	end;
	return;

dyadic_do (63):			/* left vc, right sc, < */
dyadic_do (75):			/* left vc, right sc, >_ */
dyadic_do (66):			/* left sc, right vc, <_ */
dyadic_do (78):			/* left sc, right vc, > */
	do subscript = 0 by 1 while (subscript < data_elements);
	     if single_element_fl_1 <=
		right_array -> numeric_datum (subscript)  then
		     result_array -> numeric_datum (subscript) = dyadic_set_on_equal;
	     else if abs(single_element_fl_1 - right_array -> numeric_datum(subscript)) <
		abs(fuzz * (single_element_fl_1 + right_array -> numeric_datum(subscript))) then
		     result_array -> numeric_datum (subscript) = dyadic_set_on_equal;
	     else
		result_array -> numeric_datum (subscript) = dyadic_set_on_not_equal;
	end;
	return;

dyadic_do (60):				/* scalar < */
dyadic_do (72):				/* scalar >_ */
	if single_element_fl_1 >=
	     single_element_fl_2  then
		     result_array -> numeric_datum (0) = dyadic_set_on_equal;
	     else if abs(single_element_fl_1 - single_element_fl_2) <
		abs(fuzz * (single_element_fl_1 + single_element_fl_2)) then
		     result_array -> numeric_datum (0) = dyadic_set_on_equal;
	     else
		result_array -> numeric_datum (0) = dyadic_set_on_not_equal;
	return;

dyadic_do (61):			/* < for vectors */
dyadic_do (73):			/* >_ for vectors */
	do subscript = 0 by 1 while (subscript < data_elements);
	     if left_array -> numeric_datum (subscript) >=
		right_array -> numeric_datum (subscript)  then
		     result_array -> numeric_datum (subscript) = dyadic_set_on_equal;
	     else if abs(left_array -> numeric_datum(subscript) - right_array -> numeric_datum(subscript)) <
		abs(fuzz * (left_array -> numeric_datum(subscript) + right_array -> numeric_datum(subscript))) then
		     result_array -> numeric_datum (subscript) = dyadic_set_on_equal;
	     else
		result_array -> numeric_datum (subscript) = dyadic_set_on_not_equal;
	end;
	return;

dyadic_do (67):			/* left vc, right sc, <_ */
dyadic_do (79):			/* left vc, right sc, > */
dyadic_do (62):			/* left sc, right vc, < */
dyadic_do (74):			/* left sc, right vc, >_ */
	do subscript = 0 by 1 while (subscript < data_elements);
	     if single_element_fl_1 >=
		right_array -> numeric_datum (subscript)  then
		     result_array -> numeric_datum (subscript) = dyadic_set_on_equal;
	     else if abs(single_element_fl_1 - right_array -> numeric_datum(subscript)) <
		abs(fuzz * (single_element_fl_1 + right_array -> numeric_datum(subscript))) then
		     result_array -> numeric_datum (subscript) = dyadic_set_on_equal;
	     else
		result_array -> numeric_datum (subscript) = dyadic_set_on_not_equal;
	end;
	return;

dyadic_do (-4):			/* both scalar, character, = */
	if addr (single_element_fl_1) -> character_data_structure.character_datum (0) =
	     addr (single_element_fl_2) -> character_data_structure.character_datum (0) then
		result_array -> numeric_datum (0) = dyadic_set_on_equal;
	else
	     result_array -> numeric_datum (0) = dyadic_set_on_not_equal;
	return;

dyadic_do (-3):			/* both vector, character, = (and /=) */
	do subscript = data_elements - 1 to 0 by -1;
	     if left_array -> character_data_structure.character_datum (subscript) =
		right_array -> character_data_structure.character_datum (subscript) then
		     result_array -> numeric_datum (subscript) = dyadic_set_on_equal;
	     else
		result_array -> numeric_datum (subscript) = dyadic_set_on_not_equal;
	end;
	return;

dyadic_do (-1):			/* left vector, right scalar, characters, = and /= */
dyadic_do (-2):			/* left scalar, right vector, characters, = and /= */
	do subscript = data_elements - 1 to 0 by -1;
	     if addr (single_element_fl_1) -> character_data_structure.character_datum (0) =
		right_array -> character_data_structure.character_datum (subscript) then
		     result_array -> numeric_datum (subscript) = dyadic_set_on_equal;
		else
		     result_array -> numeric_datum (subscript) = dyadic_set_on_not_equal;
	end;
	return;

end dyadic_operate;
/* Subroutine to perform reductions. Called by reduction and scan. All parameters are global variables. */

reduction_operate:
	procedure;

/* pseudo-parameters */

/* dcl	right_array ptr,			ptr to result array.
	column_base fixed bin (21),		subscript (0 origin) of first element in vector.
	highest_column_element fixed bin (21),	subscript (0 origin) of next to last element.
	interval_between_elements fixed bin (21),	number of elements between each element of the vector.
	action_place fixed bin (8),		which operator to perform.
	result_accumulator float,		the result of the reduction.
	(reduction_boolean_both, reduction_boolean_neither, reduction_set_on_equal, reduction_set_on_not_equal)
		float;			inputs to comparison operators. */

/* The rest of the global variables this routine references are not really parameters...just ordinary global vars. */

/* automatic */

dcl	subscript fixed bin (21);		/* provides a random subscript... don't use one in outer block,
					   in order to avoid naming conflicts */
declare	save_special_case fixed binary;	/* if we must call do_many, we must set special_case
					   to zero. therefore we must save it and restore
					   it because others may depend on it being saved */
declare	save_many_action_place fixed binary;	/* .. */

/* program */

	goto reduction_do (action_place);

reduction_do (0):					/* reduction add */
reduction_do (1):					/* reduction subtract. note alternating signs */
reduction_do (2):					/* reduction multiply */
reduction_do (4):					/* reduction max */
reduction_do (5):					/* reduction min */
	call apl_reduction_appendage_ (right_array, column_base, highest_column_element + interval_between_elements,
	     interval_between_elements, action_place, result_accumulator);
	return;

reduction_do (3):					/* reduction divide */
	call apl_reduction_appendage_$divide (right_array, column_base, highest_column_element + interval_between_elements,
	     interval_between_elements, action_place, result_accumulator, zerodivide_error_right);
	return;

reduction_do (6):					/* power reduction */
reduction_do (7):					/* logarithm reduction */
reduction_do (8):					/* residue reduction */
reduction_do (9):					/* binomial coefficients reduction */
reduction_do (10):				/* one of the truly worthless things in this language, circle reduction */
	save_special_case = special_case;	/* so we can restore this later */
	save_many_action_place = many_action_place;	/* .. */
	many_action_place = 2 * action_place;		/* done here mainly for inner product's benefit */
	special_case = 0;			/* reduction itself will not use this */
	do subscript = highest_column_element repeat (subscript - interval_between_elements)
	     while (subscript >= column_base);

	     single_element_fl_2 = result_accumulator;
	     single_element_fl_1 = right_array -> numeric_datum (subscript);

	     call do_many ();
	end;
	special_case = save_special_case;	/* restore cause others may need it (cf. dyadic in inner_product) */
	many_action_place = save_many_action_place;	/* .. */
	return;

reduction_do (13):					/* nand */
reduction_do (14):					/* nor */
	result_accumulator = 1 - result_accumulator;
reduction_do (11):					/* and */
reduction_do (12):					/* or */
	if reduction_type.data_type.zero_or_one_value
	then do;
		call apl_reduction_appendage_ (right_array, column_base,
		     highest_column_element + interval_between_elements, interval_between_elements, action_place,
		     result_accumulator);
		return;
	     end;

	if abs (result_accumulator - reduction_boolean_both) > integer_fuzz then
	     if abs (result_accumulator - reduction_boolean_neither) > integer_fuzz
	     then goto domain_error;			/* neither 0 nor 1 */
	do subscript = highest_column_element repeat (subscript - interval_between_elements)
	     while (subscript >= column_base);

	     if abs (right_array -> numeric_datum (subscript) - reduction_boolean_both) > integer_fuzz then do;
		if abs (right_array -> numeric_datum (subscript) - reduction_boolean_neither) > integer_fuzz then
		     goto domain_error;

		result_accumulator = reduction_set_on_not_equal;
	     end;
	end;
	return;

reduction_do (15):					/* another winner, < reduction */
reduction_do (18):					/* >_ reduction */
	do subscript = highest_column_element repeat (subscript - interval_between_elements)
	     while (subscript >= column_base);

	     if right_array -> numeric_datum (subscript) >= result_accumulator then
		result_accumulator = reduction_set_on_equal;
	     else if abs(right_array -> numeric_datum(subscript) - result_accumulator) <
		abs(fuzz * (right_array -> numeric_datum(subscript) + result_accumulator)) then
		result_accumulator = reduction_set_on_equal;
	     else
		result_accumulator = reduction_set_on_not_equal;
	end;
	return;

reduction_do (16):					/* <_ reduction */
reduction_do (19):					/* > reduction */
	do subscript = highest_column_element repeat (subscript - interval_between_elements)
	     while (subscript >= column_base);

	     if right_array -> numeric_datum (subscript) <= result_accumulator then
		result_accumulator = reduction_set_on_equal;
	     else if abs(right_array -> numeric_datum(subscript) - result_accumulator) <
		abs(fuzz * (right_array -> numeric_datum(subscript) + result_accumulator)) then
		result_accumulator = reduction_set_on_equal;
	     else
		result_accumulator = reduction_set_on_not_equal;
	end;
	return;

reduction_do (17):					/* /= */
reduction_do (20):					/* = */
	do subscript = highest_column_element repeat (subscript - interval_between_elements)
	     while (subscript >= column_base);

	     if right_array -> numeric_datum (subscript) = result_accumulator
	     then result_accumulator = reduction_set_on_equal;
	     else if abs (result_accumulator - right_array -> numeric_datum (subscript)) <
		     abs(fuzz * (result_accumulator + right_array -> numeric_datum(subscript))) then
		     result_accumulator = reduction_set_on_equal;
		else
		     result_accumulator = reduction_set_on_not_equal;
	end;
	return;

reduction_do (-1):					/* = and /= for characters */
	if right_array -> character_data_structure.character_datum (column_base) =
	     right_array -> character_data_structure.character_datum (column_base + interval_between_elements) then
		result_accumulator = reduction_set_on_equal;	/* comparison succeeded */
	else
	     result_accumulator = reduction_set_on_not_equal;
	return;

end reduction_operate;
/* many subroutine. will do operation signified by many_action_place + special_case */

do_many:
	procedure ();

/* automatic */

declare	(b, c, d, left_arg, right_arg, sign_result) float,
	casex fixed bin,
	resultc complex float;

/* builtins */

declare	(acos, asin, atan, atanh, cos, cosh, sin, sinh, sqrt, tan, tanh) builtin;

/* constants */

declare	(POSITIVE init (+1),
	NEGATIVE init (-1)) fixed bin internal static options (constant);

/* program */

	goto many_actions (many_action_place + special_case);

/* subroutine to do trig operations. entered with single_element_fl_1 being left arg and single_element_fl_2
   being right arg.  Left will be checked for integerness and being >= -7 and <= 7.  If this is already known,
   trig_integer can be set equal to left arg and do_trig_integral called instead */

/* No domain errors are checked for here; instead we will let each trigonometric builtin function
   signal the "error" condition, and the default handler in apl_parse_ will transform "error"
   (with oncodes between 1 and 100, indicating math errors) into a domain error. */

many_actions (20):					/* TRIG: left arg is floating */
	result_accumulator = floor (single_element_fl_1 + 0.5);
	if abs (result_accumulator - single_element_fl_1) > integer_fuzz | abs (result_accumulator) >= 1e17b
	then go to invalid_circular_fcn_left;

	trig_integer = fixed (result_accumulator, 35);
	if abs (trig_integer) > 7
	then go to invalid_circular_fcn_left;

many_actions (21):					/* TRIG: left is integral and from -7 to 7 */
	goto trig_array (trig_integer);

trig_array (-7):					/* hyperbolic arctangent */
	result_accumulator = atanh(single_element_fl_2);
	return;

trig_array (-6):					/* hyperbolic arccosine */
	result_accumulator = atanh(sqrt(single_element_fl_2*single_element_fl_2 - 1.0e0)/single_element_fl_2);
	return;

trig_array (-5):					/* hyperbolic arcsine */
	result_accumulator = atanh(single_element_fl_2/sqrt(1.0e0 + single_element_fl_2*single_element_fl_2));
	return;

trig_array (-4):					/* sqrt (X**2 - 1) */
	result_accumulator = sqrt(-1.0e0 + single_element_fl_2*single_element_fl_2);
	return;

trig_array (-3):					/* arctangent */
	result_accumulator = atan(single_element_fl_2);
	return;

trig_array (-2):					/* arccosine */
	result_accumulator = acos (single_element_fl_2);
	return;

trig_array (-1):					/* arcsine */
	result_accumulator = asin (single_element_fl_2);
	return;

trig_array (0):					/* sqrt (1 - X**2) */
	result_accumulator = sqrt(1.0e0 - single_element_fl_2*single_element_fl_2);
	return;

trig_array (1):					/* sine */
	result_accumulator = sin(single_element_fl_2);
	return;

trig_array (2):					/* cosine */
	result_accumulator = cos(single_element_fl_2);
	return;

trig_array (3):					/* tangent */
	result_accumulator = tan(single_element_fl_2);
	return;

trig_array (4):					/* sqrt (X**2 + 1) */
	result_accumulator = sqrt(1.0e0 + single_element_fl_2*single_element_fl_2);
	return;

trig_array (5):					/* hyperbolic sine */
	result_accumulator = sinh(single_element_fl_2);
	return;

trig_array (6):					/* hyperbolic cosine */
	result_accumulator = cosh(single_element_fl_2);
	return;

trig_array (7):					/* hyperbolic tangent */
	result_accumulator = tanh(single_element_fl_2);
	return;

many_actions (17):				/* RESIDUE:	 check for compatibility error */
	if single_element_fl_1 <= 0 then	/* neg or zero */
	     goto compatibility_error_left;

many_actions (16):				/* RESIDUE */
	if abs (single_element_fl_1) > fuzz then do;	/* not equal to zero */
	     result_accumulator = single_element_fl_2 -
		apl_floor_ (single_element_fl_2 / single_element_fl_1) * single_element_fl_1;
	     return;
	end;
	result_accumulator = single_element_fl_2;
	return;

many_actions (14):					/* LOGARITHM: log (right arg) to base (left arg) */
many_actions (15):
	if single_element_fl_1 < 0e0 then do;
	     if single_element_fl_2 = 1e0 then do;
		result_accumulator = 0e0;
		return;
	     end;

	     if single_element_fl_2 ^= single_element_fl_1 then
		goto domain_error;
	     result_accumulator = 1e0;
	     return;
	end;

	if single_element_fl_1 = 1e0			/* avoid zerodivide, below */
	then go to domain_error_left;
	else if single_element_fl_1 = 0e0
	     then go to domain_error_left;
	     else if single_element_fl_2 <= 0e0
		then go to domain_error_right;

	result_accumulator = log (single_element_fl_2) / log (single_element_fl_1);
	return;

many_actions (12):					/* EXPONENTIATION: right arg (exponent) floating */
	result_accumulator = floor (single_element_fl_2 + 0.5);
	if (abs (result_accumulator - single_element_fl_2) > integer_fuzz)
	     | (abs (result_accumulator) > 1e17b)
	then do;

		/* exponent is not integral. */

		if single_element_fl_1 > 0
		then result_accumulator = single_element_fl_1 ** single_element_fl_2;		/* (+F)**F */
		else if single_element_fl_1 = 0
		     then do;
			     if single_element_fl_2 < 0
			     then go to domain_error;					/* 0**(-F) */

			     result_accumulator = 0;					/* 0**(+F) */
			end;
		     else do;							/* (-F)**F */
			     resultc = complex (single_element_fl_1, 0) ** single_element_fl_2;
			     result_accumulator = real (resultc);
			     if result_accumulator < 100 * imag (resultc)
			     then go to domain_error;
			end;
		return;
	     end;

	trig_integer = fixed (result_accumulator, 35);

many_actions (13):					/* EXPONENTIATION: right arg (exponent) integral */
	if single_element_fl_1 = 0
	then do;
		if trig_integer < 0
		then goto domain_error;				/* 0**(-I) */
		else if trig_integer = 0
		     then result_accumulator = 1;			/* 0**0 */
		     else result_accumulator = 0;			/* 0**(+I) */
		return;
	     end;

	result_accumulator = single_element_fl_1 ** trig_integer;		/* I**I */
	return;

many_actions (18):					/* BINOMIAL COEFFICIENTS */
many_actions (19):
	if integer (single_element_fl_1, NEGATIVE)
	then casex = 4;
	else casex = 0;

	if integer (single_element_fl_2, NEGATIVE)
	then casex = casex + 2;

	if integer (single_element_fl_2 - single_element_fl_1, NEGATIVE)
	then casex = casex + 1;

	go to case (casex);

						/* A B B-A (1 --> negative integer, 0 otherwise */
						/* ------- */
case (1):						/* 0 0 1  -> 0e0 */
case (4):						/* 1 0 0  -> 0e0 */
case (7):						/* 1 1 1  -> 0e0 */
	result_accumulator = 0e0;
	return;

case (2):						/* 0 1 0 -> DOMAIN ERROR */
case (5):						/* 1 0 1 -> Impossible */
	go to domain_error;

case (0):						/* 0 0 0 -> (!B)-:(!A)x!B-A */
	sign_result = 1;
	left_arg = single_element_fl_1;
	right_arg = single_element_fl_2;
	go to combinations_common;

case (3):						/* 0 1 1 -> (^1*A)xA!A-B+1 */
	left_arg = single_element_fl_1;
	right_arg = single_element_fl_1 - (single_element_fl_2 + 1e0);
	if mod (single_element_fl_1, 2) = 0		/* even */
	then sign_result = 1;
	else sign_result = -1;
	go to combinations_common;

case (6):						/* 1 1 0 -> (^1*B-A)x(|B+1)!|A+1 */
	left_arg = abs (single_element_fl_2 + 1e0);
	right_arg = abs (single_element_fl_1 + 1e0);
	if mod (single_element_fl_2 - single_element_fl_1, 2) = 0 /* even */
	then sign_result = 1;
	else sign_result = -1;

combinations_common:
	if (integer (left_arg, POSITIVE) | (abs(left_arg) < integer_fuzz) ) & (integer (right_arg, POSITIVE))
	then do;
		if right_arg - left_arg > left_arg
		then c = right_arg - left_arg;
		else c = left_arg;

		b = -(c - right_arg);
		c = c + 1e0;
		result_accumulator = 1e0;

		do d = result_accumulator by 1e0 while (d <= b);
		     result_accumulator = (result_accumulator * c) / d;
		     c = c + 1e0;
		end;
		result_accumulator = sign_result * result_accumulator;
		return;
	     end;

	result_accumulator = sign_result * gamma (right_arg + 1) / (gamma (left_arg + 1) * gamma (right_arg - left_arg + 1))
	     ;
	return;

/* Function to determine whether its argument is an integer, positive or negative */

integer:
	procedure (P_arg, P_sign) returns (bit (1) aligned);

/* parameters */

declare 	(P_arg float,
	P_sign fixed bin) parameter;

/* automatic */

declare	trial_val float;

/* program */

	trial_val = floor (P_arg + .5e0);

	if (abs (trial_val - P_arg) < ws_info.integer_fuzz) & sign (trial_val) = P_sign
	then return ("1"b);
	else return ("0"b);

     end integer;

end do_many;

/* ALGORITHM 80
   [RECIPROCAL] GAMMA FUNCTION OF REAL ARGUMENT.
   Published March, 1962 by William Holsten, in CACM
   Modified 790716 by PG to return gamma(x), rather than reciprocal.

   This function computes the Gamma function for all real values of x, using the identities:
	Gamma(x-1) = Gamma(x)/(x-1)	for x < -1
	Gamma(x+1) = x*Gamma(x)	for x > 1

   I have tested this algorithm versus a 12-place table and have found that is
   accurate to 11 decimal places between 0 and 1. It is also more accurate over
   the entire interval than the Taylor series expansion given in the Handbook
   of Mathematical Functions, Abramowitz and Stegun editors, Dover Publications,
   New York, 1972, page 256.

   The reference for the 12-place table is British Association for the
   Advancement of Science, Mathematical Tables, Volume 1, University Press,
   Cambridge, England, 1951, page 40. */

gamma:
     procedure (P_x) returns (float);

/* parameters */

declare	P_x		float parameter;

/* automatic */

declare	(result, x, y)	float;

/* program */

	x = P_x;

	if x = 0
	then go to domain_error;

	else if x = 1
	then result = 1;

	else if x >= 1
	then do;
		y = 1;
aa:		x = x - 1;
		y = y * x;
		if x > 1
		then go to aa;

		if x = 1
		then result = y;
		else result = y / rgamma_int (x);
	     end;

	else if x = -1
	then go to domain_error;

	else if x > -1
	then result = 1 / rgamma_int (x);

	else do;
		y = x;
cc:		x = x + 1;
		if x < -1
		then do;
			y = y * x;
			go to cc;
		     end;

		if x = -1
		then go to domain_error;

		result = 1 / (rgamma_int (x) * y);
	     end;
	return (result);

/* This function computes the real reciprocal Gamma function of real x for -1 < x < 1,
   utilizing Horner's method for polynomial evaluation of the approximation polynomial. */

rgamma_int:
     procedure (P_x) returns (float);

/* parameter */

declare	P_x		float parameter;

/* automatic */

declare	(x, y)		float;

/* program */

	x = P_x;
	y = x + 1e0;
	return (y * (x * (1e0 + x * (-.422784335092 + x * (-.233093736365 + x *
	     (+.191091101162 + x * (-.024552490887 + x * (-.017645242118 + x * (+.008023278113 + x *
	     (-.000804341335 + x * (-.000360851496 + x * (+.000145624324 + x * (-.000017527917 + x *
	     (-.000002625721 + x * (+.000001328554 + x * -.000000181220)))))))))))))));

     end rgamma_int;

     end gamma;

%include apl_floor_fcn;
end /* apl_monadic_ */;
