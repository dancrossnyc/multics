/* ******************************************************
   *                                                    *
   *                                                    *
   * Copyright (c) 1972 by Massachusetts Institute of   *
   * Technology and Honeywell Information Systems, Inc. *
   *                                                    *
   *                                                    *
   ****************************************************** */

/* format: style3 */
apl_parse_:
     procedure;

/* This routine sets up a suspended frame on the parse stack, and
   runs apl.

	Initially written July 1973 by Dan Bricklin */

/* Modified 26 January 1974 by PG to handle "finish" and "error" conditions.
   Modified 740131 by PG to fix bugs.
   Modified 740226 by PG to add QuadIT, QuadEC, and QuadAF.
   Modified 740307 by PG to change call to apl_editor_, and to validate number of args in function calls.
   Modified 740624 by PG to fix assign to copy rho vector in inline case, fix stop/trace to not bomb out
	if given bad function name, initialize operators_argument before calling external functions,
	fix niladic external functions to work, to do a resetread & resetwrite after a quit,
	and to call the format operator.
   Modified 740829 by PG to fix assign to not copy rho vector if rhorho is zero, move resetread & resetwrite
	into the dim, and trap the record_quota_overflow condition.
   Modified 751231 by PG to fix setup_monadic to clear the left opnd on_stack bit so lazy operators won't get confused.
   Modified 760413 by PG to fix "(OP VAL RE" reduction to stop marking return value as being on the value stack,
	so "(FCN VAL RE" would work (return value is in heap).
   Modified 760914 by PG to make setup_(monadic dyadic)_operator_routine_call quick, and to fix bug 241
	that had caused trace output to be surpressed for lines that contained function calls.
   Modified 761011 by PG for new parse_frame declaration (first step in flushing excessive use of addr).
   Modified 770120 by PG to experiment with reverting user_input back to user_i/o if user quits.
   Modified 770121 by PG to get QUITs to work if user is &attached to an exec_com.
   Modified 770204 by PG to get all cases of assignment to handle reference counts properly, fixing bug
	264 (RQO during case 3 of assignment gives ref count errors), and an unnumbered bug that
	left the values of labels around after the function was freed.
   Modified 770222 by PG to fix bug 232 (ref count of params too high) that was caused by the function
	call/return code forgetting to wash the rs.semantics ptr(s) that pointed to the arguments.
   Modified 770225 by PG to allow operators and external functions to just return with operators_argument.error_code
	set to a non-zero value, instead of forcing them to signal apl_operator_error_.
   Modified 770310 by PG to fix bug 251 ('FOO';A-<1 wouldn't cause mixed output).
   Modified 770315 by PG to cleanup handling of buffer for input line.
   Modified 770317 by PG to get latent expression executed when ws is auto-loaded (bug 156),
	and handle multi-line input correctly (bug 148).
   Modified 770322 by PG to fix bug in handling of depth error (bug 223).
   Modified 771104 by PG to fix decrement_reference_count to null its argument in all cases, thus fixing (I hope)
	bug 290 and all of the reference count errors that happen after a RQO.  Also changed all calls
	to apl_copy_value_ so that dont_interrupt_parse flag is off during the call.
   Modified 771121 by PG to cleanup handling of system errors generated by the parse itself, and to change the
	underflow handler to work with the current fim.
   Modified 780403 by PG to fix bug 239 (permit _ei0), and to fix bug 296 whereby latent expression could not
	always be executed if the SI was left uninitialized by )LOAD.
   Modified 780426 by Bill York to fix bug 283 (Assigning to a function causes a non_in_read_bracket fault)
	by initializing some rs state bits.
   Modified 780504 by PG to add diamond processing
   Modified 780927 by PG to fix default handler to pull current instruction out of executing segment,
	instead of trusting unreliable SCU data, to cleanup diamond implementation, to implement
	branches out of diamond lines and mixed-output lines (bug 333), and to reattach user_input to
	user_i/o if EOF is discovered while reading input lines.
   Modified 781102 by PG to fix 349 (branch out of diamond-lines was always taken!),
	and to eliminate the prompt for multi-line quoted strings (sugg 350).
   Modified 781106 by PG to add argument list processing.
   Modified 781108 by PG to perform read_back_spaces order on user_i/o, to
	fix problem whereby using &attach caused apl to run in read_back_input mode forever.
   Modified 781118 by PG to have successful branch abort mixed output for the
	containing line, unless the line is being traced.
   Modified 790209 by WMY to add (monadic dyadic)_action (9) for file system functions.
   Modified 790212 by WMY to add separate call for niladic file system functions.
   Modified 790305 by WMY to check for the monadic laminate case, and cause a
	context error if it occurs.
   Modified 790326 by WMY to handle functions with no body, just a header (bug 388).
   Modified 790523 by WMY to fix bug 88 (!), automatic saving of continue workspaces
	on a hangup doesn't work.  Bug was put on list 731013!!
   Modified 790917 by PG to eliminate handling of apl_operator_error_ (obsolete), and to interface
	to new apl_print_value_.
   Modified 791023 by PG to let the FIM perform all of the modifications to the machine conditions for
	underflow, since the 34-9 (MR8.0) FIM does it right.
   Modified 800129 by PG to implement localized system variables.
   Modified 800204 by PG to change execute of an assignment print nothing.
   Modified 800206 by BIM to make branches inside of execute(s) work (bug 452).
   Modified 800226 by PG to switch to iox_.
   Modified 810125 by WMY to fix bug 480, depending on order of evaluation in
	a statement can cause a reference through a null pointer.
   Modified 810528 by WMY to fix the above fix (misplaced end statement)
   Modified 811211 by HH to add 'qCALL' system function.
   Modified 811211 by HH to correctly handle expressions left of argument list semicolons.
   Modified 841022 by WAAnderson to fix diamond line storage cleanup.
*/

/* automatic */

declare	assignment_done	bit (1) aligned,
	branch_pf_ptr	ptr,			/* ptr to "parent" of execute frame, used by branch */
	input_buffer_ptr	ptr,
	input_line_position fixed bin (21),
	max_input_line	fixed bin (21),
	n_underflows	fixed bin,
	scan_token_type	fixed bin,
	temp18		bit (18) aligned,
	trace_branch_line	bit (1) aligned,		/* ON when result of branch is traced */
	was_branch	bit (1) aligned,		/* ON if branch seen on this line */
	was_branch_value	bit (1) aligned,		/* ON if branch had non-null operand */
	(x, xx)		float;			/* temporaries for fuzz computations */

/* based */

declare	1 input_buffer	aligned based (input_buffer_ptr),
	  2 n_read	fixed bin (21),
	  2 line		char (max_input_line refer (input_buffer.n_read)) unaligned;

/* internal static initial */

declare	read_back_spaces_order
			char (16) initial ("read_back_spaces") internal static options (constant);

/* conditions */

declare	(apl_dirty_stop_, apl_quit_)
			condition;

/* builtins */

declare	(abs, addr, addrel, binary, divide, fixed, floor, length, max, null, rel, size, string, substr, unspec, verify)
			builtin;

/* Multics entries */

declare	timer_manager_$alarm_call
			entry (fixed bin (71), bit (2), entry),
	timer_manager_$reset_alarm_call
			entry (entry),
	condition_	entry (char (*), entry),
	cu_$ptr_call	entry (ptr, 1 aligned like operators_argument),
	iox_$attach_ptr	entry (ptr, char (*), ptr, fixed bin (35)),
	iox_$close	entry (ptr, fixed bin (35)),
	iox_$control	entry (ptr, char (*), ptr, fixed bin (35)),
	iox_$detach_iocb	entry (ptr, fixed bin (35)),
	iox_$get_line	entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35)),
	iox_$put_chars	entry (ptr, ptr, fixed bin (21), fixed bin (35));

/* APL entries */

declare	(apl_dyadic_, apl_dyadic_format_, apl_inner_product_, apl_monadic_, apl_monadic_format_, apl_monadic_not_,
	apl_outer_product_, apl_reduction_, apl_scan_operator_, apl_subscript_a_value_)
			entry (1 aligned like operators_argument);

declare	apl_editor_	entry (char (*), fixed bin (21), fixed bin (35)),
	apl_flush_buffer_nl_
			entry (),
	apl_print_value_	entry (ptr unal, bit (1) aligned, bit (1) aligned),
	apl_print_string_	entry (char (*)),
	apl_scan_		entry (char (*), fixed bin (21), fixed bin (21), fixed bin (21), fixed bin, unaligned pointer),
	apl_subscripted_assignment_
			entry (1 aligned like operators_argument, ptr);

/* external static */

declare	(
	apl_static_$apl_input,
	apl_static_$apl_output,
	iox_$user_input,
	iox_$user_io
	)		ptr external static;

declare	(
	apl_error_table_$not_end_with_value,
	apl_error_table_$cant_read_input,
	apl_error_table_$pull_system_error,
	apl_error_table_$pull_assign_system_error,
	apl_error_table_$report_error_system_error,
	apl_error_table_$done_line_system_error,
	apl_error_table_$ws_full_no_quota,
	apl_error_table_$improper_niladic_usage,
	apl_error_table_$too_much_input,
	apl_error_table_$locked_function_error,
	apl_error_table_$assign_to_value,
	apl_error_table_$super_dirty_stop,
	apl_error_table_$interrupt,
	apl_error_table_$cant_get_stop_trace,
	apl_error_table_$depth,
	apl_error_table_$ws_cleared,
	apl_error_table_$ws_loaded,
	apl_error_table_$return_from_apl,
	apl_error_table_$execute,
	apl_error_table_$bad_execute,
	apl_error_table_$bad_evaluated_input,
	apl_error_table_$assign_to_label,
	apl_error_table_$bad_assignment,
	apl_error_table_$rank,
	apl_error_table_$operator_subscript_range,
	apl_error_table_$context,
	apl_error_table_$improper_monadic_usage,
	apl_error_table_$improper_dyadic_usage,
	apl_error_table_$domain,
	apl_error_table_$value,
	error_table_$end_of_info,
	error_table_$not_closed,
	error_table_$short_record
	)		fixed bin (35) external static;

/* declarations */

dcl	parse_frame_ptr	ptr,
          diamond_temp        fixed bin init(0),
          tmp_parseme         fixed bin,
	rsp		ptr,
	have_a_line	bit (1),			/* "1"b means OK to print line in error message */
	in_printer	bit (1),			/* "1"b means interrupt terminates printing */
	current_parseme	fixed bin,
	current_lexeme	fixed bin,
	lexed_function_bead_ptr
			ptr,
	based_unaligned_ptr based unaligned ptr,
	operator_ptr	ptr,
	execute_value_ptr	ptr,
	where_execute_error fixed bin,
	apl_error_	entry (fixed bin (35), bit (36) aligned, fixed bin, char (*), ptr unaligned, fixed bin),
	was_error		bit (1) aligned,
	apl_line_lex_	entry (char (*), ptr unaligned, bit (1) aligned, fixed bin, ptr),
	apl_execute_lex_	entry (char (*) aligned, ptr unaligned, bit (1) aligned, fixed bin, ptr),
	apl_function_lex_	entry (char (*) aligned, ptr unaligned, bit (1) aligned, fixed bin, ptr),
	apl_function_lex_no_messages_
			entry (char (*) aligned, ptr unaligned, bit (1) aligned, fixed bin, ptr, fixed bin),
	apl_command_	entry (char (*), fixed bin (21), fixed bin (35)),
	apl_monadic_iota_	entry (1 aligned like operators_argument),
	apl_monadic_rho_	entry (1 aligned like operators_argument),
	apl_copy_value_	entry (ptr unaligned, ptr unaligned),
	apl_dyadic_epsilon_ entry (1 aligned like operators_argument),
	apl_encode_	entry (1 aligned like operators_argument),
	apl_decode_	entry (1 aligned like operators_argument),
	apl_ibeam_	entry (1 aligned like operators_argument),
	apl_dyadic_ibeam_	entry (1 aligned like operators_argument),
	apl_system_variables_
			entry (1 aligned like operators_argument),
	apl_system_functions_
			entry (1 aligned like operators_argument),
	apl_file_system_	entry (1 aligned like operators_argument),
	apl_file_system_$niladic_functions
			entry (1 aligned like operators_argument),
	apl_dyadic_iota_	entry (1 aligned like operators_argument),
	apl_take_		entry (1 aligned like operators_argument),
	apl_drop_		entry (1 aligned like operators_argument),
	apl_ravel_	entry (1 aligned like operators_argument),
	apl_catenate_	entry (1 aligned like operators_argument),
	apl_laminate_	entry (1 aligned like operators_argument),
	apl_dyadic_rho_	entry (1 aligned like operators_argument),
	apl_domino_operator_
			entry (1 aligned like operators_argument),
	apl_compression_	entry (1 aligned like operators_argument),
	apl_expansion_	entry (1 aligned like operators_argument),
	apl_reverse_	entry (1 aligned like operators_argument),
	apl_rotate_	entry (1 aligned like operators_argument),
	apl_transpose_	entry (1 aligned like operators_argument),
	apl_random_	entry (1 aligned like operators_argument),
	apl_grade_up_	entry (1 aligned like operators_argument),
	apl_grade_down_	entry (1 aligned like operators_argument),
          apl_quadcall_       entry (1 aligned like operators_argument),
	apl_external_fcn_addr_
			entry (char (*) aligned, ptr unaligned),
	external_function_ptr
			ptr,
	symbol_ptr_unal	ptr unaligned,
	meaning_ptr_unal	ptr unaligned,
	temp_ptr		ptr,
	value_bead_ptr	ptr,
	data_elements	fixed bin,
	start		fixed bin,
	put_result	fixed bin,
	return_point	fixed bin,
	number_of_arguments fixed bin,
	print_final_value	bit (1) aligned,
	code		fixed bin (35),
	error_mark_structure_ptr
			ptr unaligned,
	ok_to_stop_control	bit (1),
	apl_free_bead_	entry (ptr unaligned),
	i		fixed bin,
	packed_temp_ptr	ptr unaligned,
	ptr_to_returned_value
			ptr,
	bits_for_returned_value
			bit (36) aligned,
	number_of_non_labels
			fixed bin,
	monadic_table	(0:124) fixed bin int static init ((21) 1,
						/* 0-20 monadic scalar operators */
			(15) 1,			/* 21-35 unused */
			24,			/* 36 rho */
			4,			/* 37 comma */
			23,			/* 38 iota */
			(2) 1,			/* 39-40 take, drop (not monadic) */
			27,			/* 41 grade up */
			28,			/* 42 grade down */
			(2) 1,			/* 43-44 compress, expand last (not monadic) */
			11,			/* 45 reverse-last */
			(2) 1,			/* 46-47 compress, expand first (not monadic) */
			12,			/* 48 reverse-first */
			13,			/* 49 transpose */
			(3) 1,			/* 50-52 epsilon, decode, encode (not monadic) */
			14,			/* 53 execute */
			15,			/* 54 format */
			16,			/* 55 i-beam */
			10,			/* 56 not */
			26,			/* 57 roll */
			(9) 21,			/* 58-66 system functions */
			3,			/* 67 branch */
			25,			/* 68 domino */
			21,			/* 69 QuadSVR system function */
			21,			/* 70 QuadEC system function */
			21,			/* 71 QuadAF system function */
			1,			/* 72 semicolon cons (dyadic only) */
			(4) 1,			/* 73-76 dyadic file system functions */
			9,			/* 77 qFDROP file system function */
			1,			/* 78 qFERASE dyadic file system function */
			9,			/* 79 qFHOLD file system function */
			9,			/* 80 qFLIB file system function */
			9,			/* 81 qFLIM file system function */
			9,			/* 82 qFLISTACL file system function */
			(2) 1,			/* 83-84 niladic file system functions */
			9,			/* 85 qFRDCI file system function */
			9,			/* 86 qFREAD file system function */
			(3) 1,			/* 87-89 dyadic file system functions */
			9,			/* 90 qFSIZE */
			(2) 1,			/* 91-92 dyadic file system functions */
			29,			/* 93 laminate (dyadic only) */
			5,			/* 94 reduction last */
			6,			/* 95 reduction first */
			7,			/* 96 scan last */
			8,			/* 97 scan first */
			1,			/* 98 outer product */
			2,			/* 99 invoke function */
			1,			/* 100 stop control */
			1,			/* 101 trace control */
			1,			/* 102 assignment */
			1,			/* 103 subscripted assignment */
			17,			/* 104 quad gets */
			18,			/* 105 quad-quote gets */
			(6) 19,			/* 106-111 assign to system variable */
			(2) 22,			/* 112-113 assign to stop/trace */
			20,			/* 114 assign to system variable which ignores assignment */
			(5) 1,			/* 115-119 ignore */
			19,			/* 120 QuadIT system variable */
			9,			/* 121 qFUNTIE file system function */
			1,			/* 122 catenate first (dyadic only) */
                              30,                           /* 123 qCALL system function */
                              1),                           /* 124 qCALL semicolon (dyadic only) */
	dyadic_table	(0:124) fixed bin int static init ((21) 1,
						/* 0-20 dyadic scalar operators */
			(15) 1,			/* 21-35 unused */
			10,			/* 36 rho */
			6,			/* 37 comma */
			4,			/* 38 iota */
			15,			/* 39 take */
			16,			/* 40 drop */
			(2) 1,			/* 41-42 (grade up, grade down; not dyadic) */
			7,			/* 43 compress last */
			8,			/* 44 expand last */
			17,			/* 45 rotate-last */
			12,			/* 46 compress first */
			13,			/* 47 expand first */
			18,			/* 48 rotate-first */
			19,			/* 49 transpose */
			3,			/* 50 epsilon */
			20,			/* 51 decode */
			21,			/* 52 encode */
			1,			/* 53 execute (not dyadic) */
			23,			/* 54 format */
			29,			/* 55 dyadic i-beam */
			1,			/* 56 not (not dyadic) */
			25,			/* 57 deal */
			(9) 26,			/* 58-66 system functions */
			1,			/* 67 branch (not dyadic) */
			27,			/* 68 domino */
			(3) 1,			/* 69-71 monadic system functions */
			24,			/* 72 semicolon cons */
			9,			/* 73 qFADDACL file system function */
			9,			/* 74 qFAPPEND file system function */
			9,			/* 75 qFCREATE file system function */
			9,			/* 76 qFDELETEACL file system function */
			1,			/* 77 qFDROP monadic file system function */
			9,			/* 78 qFERASE file system function */
			(4) 1,			/* 79-82 monadic file system functions */
			(2) 1,			/* 83-84 niladic file system functions */
			(2) 1,			/* 85-86 monadic file system functions */
			9,			/* 87 qFRENAME file system function */
			9,			/* 88 qFREPLACE file system function */
			9,			/* 89 qFSETACL file system function */
			1,			/* 90 qFSIZE monadic file system function */
			9,			/* 91 qFSTIE file system function */
			9,			/* 92 qFTIE file system function */
			11,			/* 93 laminate */
			(4) 1,			/* 94-97 (reduction, scan; not dyadic) */
			14,			/* 98 outer product */
			5,			/* 99 invoke function */
			(2) 1,			/* 100-101 (stop, trace; not dyadic) */
			2,			/* 102 simple assignment */
			28,			/* 103 subscripted assignment */
			(18) 1,			/* 104-121 (various; not dyadic) */
			22,			/* 122 catenate first */
                              1,                            /* 123 qCALL system function (monadic only) */
                              24),                          /* 124 qCALL semicolon */
	value_bits	bit (36) aligned int static init ("0000001"b),
	computed_value_bits bit (36) aligned int static init ("0000001001"b),
	external_function_bits
			(2:4) bit (36) aligned int static
			init ("000001000010000000000000000001100011"b, "000011000010000000000000000001100011"b,
			"000101000010000000000000000001100011"b),
	1 rs		(1000) aligned based (rsp),
	  2 type		fixed bin,
	  2 bits		unaligned like operator_bead.bits_for_parse,
	  2 semantics	ptr unaligned,
	  2 lexeme	fixed bin,
	1 rs_for_op	(1000) aligned based (rsp),
	  2 type		fixed bin,
	  2 bits		unaligned like operator_bead.bits_for_parse,
	  2 semantics	fixed bin,
	  2 lexeme	fixed bin,
	1 rs_overlay	aligned based,
	  2 type		fixed bin,
	  2 bits		unaligned like operator_bead.bits_for_parse,
	  2 semantics	ptr unaligned,
	  2 lexeme	fixed bin,
	1 error_mark_structure
			aligned based (error_mark_structure_ptr),
	  2 error_line_number
			fixed bin,
	  2 error_line_index
			fixed bin (21),
	  2 error_index_within_line
			fixed bin,
	  2 length_of_line	fixed bin;

/* include files */

%include apl_number_data;
%include apl_characters;
%include apl_ws_info;
%include apl_bead_format;
%include apl_function_bead;
%include apl_lexed_function_bead;
%include apl_operator_bead;
%include apl_operators_argument;
%include apl_parse_frame;
%include apl_symbol_bead;
%include apl_value_bead;
%include apl_list_bead;
%include apl_operator_codes;

/* Initialize interrupt masking bits and mask parse against interrupts. Actually, there is
   a very small window between the time we turn on the bits and the time we establish the default
   handler. If the user sneaks in a quit in the window, he'd better type start and not program_interrupt... */

	call reset_interrupt_info;
	call condition_ ("any_other", apl_default_handler_);

/* We should really do the following order on user_input, and check the
   status code if it fails. (Which it would in &attach mode in an ec).
   Probably we should not use read_back_spaces at all... */

	call iox_$control (iox_$user_io, read_back_spaces_order, null, (0));
	n_underflows = 0;

start_anew:
	ws_info.current_parse_frame_ptr -> parse_frame.last_parse_frame_ptr = null;
						/* sb in other pgm */
	parse_frame_ptr = ws_info.current_parse_frame_ptr;/* copy frame ptr into auto */
	call initialize_suspended_frame;

ws_just_loaded:
	if parse_frame.parse_frame_type = evaluated_frame_type
	then go to read_and_lex_line;

	if ws_info.wsid = "clear ws"			/* skip latent expression */
	then go to read_and_lex_line;

	number_of_ptrs = 1;				/* so size builtin will work, below. */
	input_buffer_ptr = addrel (parse_frame_ptr, size (parse_frame) - 1);
	input_buffer.n_read = 5;
	input_buffer.line = QExecuteSign || QQuad || "lx" || QNewLine;
						/* _eqLX */
	parse_frame.current_line_number = 1;
	call lex_input_line (code);
	go to start_line;

next_line:
	if parse_frame.lexed_function_bead_ptr ^= null
	then call decrement_reference_count (parse_frame.lexed_function_bead_ptr);

read_and_lex_line:
	code = 1;
	do while (code ^= 0);
	     call read_executable_input_line;
	     call lex_input_line (code);
	end;

start_line:
	lexed_function_bead_ptr = parse_frame.lexed_function_bead_ptr;
						/* copy into auto */
						/* If there are no statements, this is an empty function and we are done. */

	if lexed_function_bead_ptr -> lexed_function_bead.number_of_statements = 0
	then go to function_return;

	current_lexeme = lexed_function_bead_ptr -> statement_map (parse_frame.current_line_number) + 1;
						/* end of line is after line */
	have_a_line = "1"b;				/* if interrupt, we now have a line to print */
	if parse_frame_type = function_frame_type
	then if parse_frame.function_bead_ptr -> stop_control_pointer ^= null
	     then if this_statement_is_one (parse_frame.current_line_number,
		     parse_frame.function_bead_ptr -> stop_control_pointer)
		then if ok_to_stop_control
		     then do;
			     call print_where_I_am (parse_frame_ptr, "0"b, "1"b);
			     call save_state;
			     call push_new_frame;
			     call initialize_suspended_frame;
			     go to read_and_lex_line;
			end;

	ok_to_stop_control = "1"b;
	print_final_value = "1"b;
	was_branch = "0"b;
	was_branch_value = "0"b;
	trace_branch_line = "0"b;
	current_parseme = 1;			/* fill in first parseme - end of line */
	parse_frame.initial_value_stack_ptr = ws_info.value_stack_ptr;
	rs (current_parseme).type = eol_type;		/* fill in first parseme on reduction stack */
	unspec (rs (current_parseme).bits) = ""b;
	if clean_interrupt_pending
	then do;
		dont_interrupt_parse = "0"b;
		current_lexeme = current_lexeme - 1;
		go to dirty_stop;
	     end;

	go to re;					/* get into reductions at re (right end) */

/*		A P L    R E D U C T I O N S

   These reductions are the heart of the APL interpreter.  Using the lexeme array
   produced by apl_lex_, the following code determines the next action to be
   performed, calls the necessary operator routines, and "reduces" the stack
   by the work just done, putting the result in place of the operator and
   input arguments. */

re:
	return_point = 8;
	go to pull;
operator_return (8):
	go to x_re (rs (current_parseme).type);		/* dispatch on what it was */

x_re (1):						/* BOL RE */
bol_re:
	if parse_frame_type = evaluated_frame_type
	then if rs (current_parseme - 1).semantics_valid
	     then go to bad_evaluated_input;
	     else go to next_line;

	if parse_frame_type = execute_frame_type
	then if rs (current_parseme - 1).semantics_valid
	     then go to bad_execute;
	     else do;
		     ptr_to_returned_value = null;
		     bits_for_returned_value = value_bits;
		     go to eval_execute_return;
		end;

	go to done_line;

x_re (2):						/* VAL RE */
val_re:
	return_point = 9;
	go to pull;
operator_return (9):
	go to x_val_re (rs (current_parseme).type);

x_re (3):						/* OP  RE */
	if rs (current_parseme).op1 ^= branch_code	/* allow only -> here */
	then go to not_end_with_value;

pop_stack:
	call clean_up_rs;
	if last_parse_frame_ptr = null
	then go to next_line;
	if parse_frame.lexed_function_bead_ptr ^= null
	then do;
		lexed_function_bead_ptr = parse_frame.lexed_function_bead_ptr;
		call restore_old_meanings;
		call decrement_reference_count (parse_frame.lexed_function_bead_ptr);
		if parse_frame.parse_frame_type = function_frame_type
		then call decrement_reference_count (parse_frame.function_bead_ptr);
	     end;
	parse_frame_ptr = last_parse_frame_ptr;
	call restore_state;
	if parse_frame_type ^= suspended_frame_type
	then go to pop_stack;
	else go to next_line;

x_re (4):						/* (   RE */
	go to context_error_0;

x_re (5):						/* )   RE */
	go to re;

x_re (6):						/* [   RE */
	call append_to_list_bead (addr (rs (current_parseme - 1)) -> rs_overlay);
	rs (current_parseme - 1).semantics -> list_bead.member_ptr (1) = null;
	unspec (rs (current_parseme - 1).semantics -> list_bead.bits (1)) = ""b;
	rs (current_parseme - 1).lexeme = rs (current_parseme).lexeme;
	current_parseme = current_parseme - 1;
	rs (current_parseme).type = subscript_type;
	go to sub;

x_re (7):						/* ]SB RE */
	go to re;

x_re (8):						/* ]RK RE */
	go to context_error_0;

x_re (9):						/* ;   RE */
	print_final_value = "1"b;
	call append_to_list_bead (addr (rs (current_parseme - 1)) -> rs_overlay);
	rs (current_parseme - 1).semantics -> list_bead.member_ptr (1) = null;
	unspec (rs (current_parseme - 1).semantics -> list_bead.bits (1)) = ""b;
						/* bits.op1 = 0 means print value */
	current_parseme = current_parseme - 1;
	go to re;

x_re (10):					/* <>   RE */
	call print_value;
	current_parseme = current_parseme - 1;
	print_final_value = "1"b;
	go to re;

x_val_re (1):					/* BOL VAL RE */
bol_val_re:
	if rs (current_parseme - 2).semantics_valid
	then do;					/* if line had any mixed-output semicolons */
		call append_to_list_bead (addr (rs (current_parseme - 2)) -> rs_overlay);
		if print_final_value		/* set up bits.op1 for whether to print value */
		then rs (current_parseme - 1).bits.op1 = 0;
		else rs (current_parseme - 1).bits.op1 = 1;
		unspec (rs (current_parseme - 2).semantics -> list_bead.bits (1)) =
		     unspec (rs (current_parseme - 1).bits);
		rs (current_parseme - 2).semantics -> list_bead.member_ptr (1) = rs (current_parseme - 1).semantics;
		rs (current_parseme - 1) = rs (current_parseme);
		current_parseme = current_parseme - 1;
		go to bol_re;
	     end;

	if parse_frame.parse_frame_type = evaluated_frame_type | parse_frame.parse_frame_type = execute_frame_type
	then do;
		ptr_to_returned_value = rs (current_parseme - 1).semantics;
		bits_for_returned_value = unspec (rs (current_parseme - 1).bits);

eval_execute_return:
		call decrement_reference_count (parse_frame.lexed_function_bead_ptr);
		parse_frame_ptr = last_parse_frame_ptr;
		call restore_state_after_execute;
		rs (put_result).type = val_type;
		rs (put_result).semantics = ptr_to_returned_value;
		unspec (rs (put_result).bits) = bits_for_returned_value;
		go to operator_return (return_point);
	     end;

	go to done_line;

x_val_re (2):					/* VAL VAL RE */
	go to context_error_0;

x_val_re (3):					/* OP  VAL RE */
op_val_re:
          if rs (current_parseme).op1 = semicolon_cons_code | rs (current_parseme).op1 = quadcall_semicolon_code
          then if rs (current_parseme-2).op1 = semicolon_cons_code | rs (current_parseme-2).op1 = quadcall_semicolon_code
               then do;                                     /* Do previously deferred semicolon. */
                    current_parseme = current_parseme - 1;
                    current_lexeme = current_lexeme + 1;
                    goto val_op_val_re;
               end;
               else do;                                     /* Defer semicolon until its left arg is evaluated. */
                    rs (current_parseme).type = close_paren_type; /* Evaluation deferred by pretending it's a ')'. */
                    goto re;
               end;
	return_point = 10;

	if (rs (current_parseme).op1 = assignment_code) | (rs (current_parseme).op1 = subscripted_assignment_code)
	then go to pull_assignment_variable;

	go to pull;
operator_return (10):
	go to x_op_val_re (rs (current_parseme).type);

x_val_re (4):					/* (   VAL RE */
          if rs (current_parseme-2).op1 = semicolon_cons_code | rs (current_parseme-2).op1 = quadcall_semicolon_code
          then do;                                          /* Do previously deferred semicolon. */
               current_parseme = current_parseme - 1;
               current_lexeme = current_lexeme + 1;
               goto val_op_val_re;
          end;
	print_final_value = "1"b;
	rs (current_parseme - 2) = rs (current_parseme - 1);
	current_parseme = current_parseme - 2;
	if rs (current_parseme - 1).type = op_type
	then go to val_op_val_re;
	else if rs (current_parseme - 1).type = subscript_type
	then go to val_sub;
	else go to val_re;

x_val_re (5):					/* )   VAL RE */
	go to context_error_0;

x_val_re (6):					/* [   VAL RE */
open_bracket_val_re:
	rs (current_parseme - 2).type = subscript_type;
	call append_to_list_bead (addr (rs (current_parseme - 2)) -> rs_overlay);
	unspec (rs (current_parseme - 2).semantics -> list_bead.bits (1)) = unspec (rs (current_parseme - 1).bits);
	rs (current_parseme - 2).semantics -> list_bead.member_ptr (1) = rs (current_parseme - 1).semantics;
	rs (current_parseme - 2).lexeme = rs (current_parseme).lexeme;
	current_parseme = current_parseme - 2;
	go to sub;

x_val_re (7):					/* ]SB VAL RE */
	go to context_error_0;

x_val_re (8):					/* ]RK VAL RE */
	go to re;

x_val_re (9):					/* ;   VAL RE */
semi_colon_val_re:
	call append_to_list_bead (addr (rs (current_parseme - 2)) -> rs_overlay);
	rs (current_parseme - 1).bits.op1 = binary (^print_final_value, 1);
						/* 1 if assignment, else 0 */
	unspec (rs (current_parseme - 2).semantics -> list_bead.bits (1)) = unspec (rs (current_parseme - 1).bits);
	rs (current_parseme - 2).semantics -> list_bead.member_ptr (1) = rs (current_parseme - 1).semantics;
	current_parseme = current_parseme - 2;
	print_final_value = "1"b;
	go to re;

x_val_re (10):					/* <>   VAL RE */
diamond_val_re:
          diamond_temp = current_parseme;
          tmp_parseme  = parse_frame.current_parseme;
	call print_value;
          call clean_up_rs;
          current_parseme = diamond_temp;
          parse_frame.current_parseme = tmp_parseme;
	print_final_value = "1"b;
	go to re;

x_op_val_re (1):					/* BOL OP  VAL RE */
	start = current_parseme - 1;
	put_result = current_parseme - 2;
	return_point = 1;
	go to do_monadic;
operator_return (1):
	rs (put_result).lexeme = rs (current_parseme - 1).lexeme;
	rs (current_parseme - 1).type = bol_type;
	current_parseme = current_parseme - 1;
	go to bol_val_re;

x_op_val_re (2):					/* VAL OP  VAL RE */
val_op_val_re:
	start = current_parseme;
	put_result = current_parseme - 2;
	return_point = 2;
	go to do_dyadic;
operator_return (2):
	rs (put_result).lexeme = rs (current_parseme).lexeme;
	current_parseme = current_parseme - 2;
	go to val_re;

x_op_val_re (3):					/* OP  OP  VAL RE */
	start = current_parseme - 1;
	put_result = current_parseme - 2;
	return_point = 3;
	go to do_monadic;
operator_return (3):
	rs (put_result).lexeme = rs (current_parseme - 1).lexeme;
	rs (current_parseme - 1) = rs (current_parseme);
	current_parseme = current_parseme - 1;
	go to op_val_re;

x_op_val_re (4):					/* (   OP  VAL RE */
          if rs (current_parseme-3).op1 = semicolon_cons_code | rs (current_parseme-3).op1 = quadcall_semicolon_code
          then do;                                          /* Change from (OP VAL1;VAL2)... TO (OP VAL1);VAL2... */
               rs (current_parseme-5) = rs (current_parseme-4);
               rs (current_parseme-4) = rs (current_parseme-3);
               rs (current_parseme-4).type = op_type;       /* Remember we pretended the ';' was a ')'. */
          end;
	start = current_parseme - 1;
	put_result = current_parseme - 3;
	return_point = 4;
	go to do_monadic;
operator_return (4):
	print_final_value = "1"b;
	rs (current_parseme - 3).lexeme = rs (current_parseme - 2).lexeme;
	current_parseme = current_parseme - 3;
	if rs (current_parseme - 1).type = op_type
	then go to val_op_val_re;
	else if rs (current_parseme - 1).type = subscript_type
	then go to val_sub;
	else go to val_re;

x_op_val_re (5):					/* )   OP  VAL RE */
	go to re;

x_op_val_re (6):					/* [   OP  VAL RE */
	start = current_parseme - 1;
	put_result = current_parseme - 2;
	return_point = 5;
	go to do_monadic;
operator_return (5):
	rs (current_parseme - 1) = rs (current_parseme);
	current_parseme = current_parseme - 1;
	go to open_bracket_val_re;

x_op_val_re (7):					/* ]SB OP  VAL RE */
	go to re;

x_op_val_re (8):					/* ]RK OP  VAL RE */
	start = current_parseme - 1;
	put_result = current_parseme - 2;
	return_point = 6;
	go to do_monadic;
operator_return (6):
	rs (current_parseme - 1) = rs (current_parseme);
	current_parseme = current_parseme - 1;
	go to re;

x_op_val_re (9):					/* ;   OP  VAL RE */
	start = current_parseme - 1;
	put_result = current_parseme - 2;
	return_point = 7;
	go to do_monadic;
operator_return (7):
	rs (current_parseme - 1) = rs (current_parseme);
	current_parseme = current_parseme - 1;
	if was_branch_value
	then go to bol_val_re;
	go to semi_colon_val_re;

x_op_val_re (10):					/* <>   OP VAL RE */
	start = current_parseme - 1;
	put_result = current_parseme - 2;
	return_point = 12;
	go to do_monadic;
operator_return (12):
	rs (current_parseme - 1) = rs (current_parseme);
	current_parseme = current_parseme - 1;
	if was_branch_value
	then go to bol_val_re;
	go to diamond_val_re;

sub:
	return_point = 11;
	go to pull;
operator_return (11):
	go to x_sub (rs (current_parseme).type);

x_sub (1):					/* BOL SUB */
	go to context_error_0;

x_sub (2):					/* VAL SUB */
val_sub:
	if rs (current_parseme).semantics = null
	then call value_error_reporter (current_lexeme);

	operators_argument.value (1) = rs (current_parseme).semantics;
	operators_argument.value (2) = rs (current_parseme - 1).semantics;
	operators_argument.on_stack (1) = rs (current_parseme).bits.semantics_on_stack;
	operators_argument.where_error = current_parseme - 1;
	operators_argument.error_code = 0;

	call apl_subscript_a_value_ (operators_argument);

	if operators_argument.error_code ^= 0
	then go to report_error_from_operator;

	if ^operators_argument.on_stack (1)
	then call decrement_reference_count (rs (current_parseme).semantics);
	rs (current_parseme - 1).semantics = operators_argument.result;
	unspec (rs (current_parseme - 1).bits) = computed_value_bits;
	rs (current_parseme - 1).type = val_type;
	rs (current_parseme - 1).lexeme = rs (current_parseme).lexeme;
	print_final_value = "1"b;
	current_parseme = current_parseme - 1;
	if rs (current_parseme - 1).type = op_type
	then go to val_op_val_re;
	else if rs (current_parseme - 1).type = subscript_type
	then go to val_sub;
	else go to val_re;

x_sub (3):					/* OP  SUB */
	if ^rs (current_parseme - 1).semantics_valid
	then go to value_error_1;
	if rs (current_parseme).op1 = subscripted_assignment_code
	then do;
		rs (current_parseme).semantics = rs (current_parseme - 1).semantics;
		rs (current_parseme).semantics_valid = "1"b;
		rs (current_parseme).semantics_on_stack = "1"b;
		rs (current_parseme).has_list = "1"b;
		rs (current_parseme - 1) = rs (current_parseme);
		current_parseme = current_parseme - 1;
		go to op_val_re;
	     end;
	temp_ptr = rs (current_parseme - 1).semantics;
	if temp_ptr -> list_bead.number_of_members ^= 1
	then go to rank_error_1;
	temp_ptr = temp_ptr -> list_bead.member_ptr (1);
	if temp_ptr = null
	then go to value_error_1;
	if temp_ptr -> value_bead.total_data_elements ^= 1
	then go to rank_error_1;
	if ^temp_ptr -> value_bead.numeric_value
	then go to domain_error_1;
	x = temp_ptr -> value_bead.data_pointer -> numeric_datum (0);

/* make sure the rank-subscript is an integer */

	xx = floor (x + 0.5);
	if abs (xx - x) >= integer_fuzz
	then do;					/* not an integer - allow if laminate */
		if rs (current_parseme).op1 ^= ravel_code
		then go to rank_error_1;

		rs (current_parseme).op1 = laminate_code;
		xx = floor (x);			/* set up value to pass to laminate routine */
	     end;					/* fix the rank-subscript */

	if abs (xx) > 100000
	then go to rank_error_1;
	i = fixed (xx, 17) + 1 - index_origin;		/* convert to 1-origin for operators */
	if i <= 0
	then if rs (current_parseme).op1 ^= laminate_code /* if not laminate, which is special, */
	     then go to rank_error_1;			/* then barf if not a good number */
	     else if i ^= 0
	     then go to rank_error_1;			/* if laminate, then barf if negative, but */
	     else ;				/* laminate on zero'th dimension is allowed. */
	rs_for_op (current_parseme).semantics = i;
	rs (current_parseme).semantics_valid = "1"b;
	if ^rs (current_parseme - 1).semantics -> list_bead.semantics_on_stack (1)
	then call decrement_reference_count (rs (current_parseme - 1).semantics -> list_bead.member_ptr (1));
	rs (current_parseme - 1) = rs (current_parseme);
	current_parseme = current_parseme - 1;
	go to op_val_re;

x_sub (4):					/* (   SUB */
	go to context_error_0;

x_sub (5):					/* )   SUB */
	go to re;

x_sub (6):					/* [   SUB */
	go to context_error_0;

x_sub (7):					/* ]SB SUB */
	go to re;

x_sub (8):					/* ]RK SUB */
	go to context_error_0;

x_sub (9):					/* ;   SUB */
	go to context_error_0;

x_sub (10):					/* <>   SUB */
	go to context_error_0;

done_line:
	if parse_frame.parse_frame_type = function_frame_type
	then if parse_frame.function_bead_ptr -> function_bead.trace_control_pointer ^= null
	     then call check_trace_vector;

	print_final_value = print_final_value | trace_branch_line;

	if ^was_branch_value | trace_branch_line	/* branch aborts mixed output, unless traced */
	then call print_value;

	call clean_up_rs;

	if parse_frame.parse_frame_type = suspended_frame_type
	then do;
		if ^was_branch
		then go to next_line;

		if last_parse_frame_ptr = null
		then go to next_line;

		if was_branch_value
		then last_parse_frame_ptr -> parse_frame.current_line_number = parse_frame.current_line_number;

		call decrement_reference_count (parse_frame.lexed_function_bead_ptr);
		ok_to_stop_control = "0"b;
		parse_frame_ptr = last_parse_frame_ptr;
		call restore_state;
		go to increment_function_line_number;
	     end;

	if parse_frame_type = function_frame_type
	then do;
increment_function_line_number:
		parse_frame.current_line_number = parse_frame.current_line_number + 1;
		if parse_frame.current_line_number < 1
		     | parse_frame.current_line_number > lexed_function_bead_ptr -> number_of_statements
		then go to function_return;
		go to start_line;
	     end;

	go to done_line_system_error;			/* workspace is screwed up */

function_return:
	ptr_to_returned_value = lexed_function_bead_ptr -> localized_symbols (ReturnSymbol);
	if ptr_to_returned_value ^= null
	then do;
		ptr_to_returned_value = ptr_to_returned_value -> meaning_pointer;
		if ptr_to_returned_value ^= null
		then ptr_to_returned_value -> general_bead.reference_count =
			ptr_to_returned_value -> general_bead.reference_count + 1;
	     end;

	call restore_old_meanings;
	call decrement_reference_count (parse_frame.lexed_function_bead_ptr);
	call decrement_reference_count (parse_frame.function_bead_ptr);
	parse_frame_ptr = last_parse_frame_ptr;
	call restore_state;

	if number_of_arguments = 2
	then do;					/* dyadic case */

/* arguments are known to be in the heap, not on the stack. */

		call decrement_reference_count (rs (start).semantics);
		call decrement_reference_count (rs (start - 2).semantics);
	     end;
	else if number_of_arguments = 1
	then call decrement_reference_count (rs (start - 1).semantics);
						/* monadic case */
	else ;					/* niladic...no arguments */


	rs (put_result).semantics = ptr_to_returned_value;
	rs (put_result).type = val_type;
	unspec (rs (put_result).bits) = value_bits;
	go to operator_return (return_point);

return_statement:
	return;

context_error_0:
	operators_argument.error_code = apl_error_table_$context;
	go to report_error;

value_error_1:
	operators_argument.error_code = apl_error_table_$value;
	current_lexeme = rs (current_parseme - 1).lexeme;
	go to report_error;

domain_error:
	operators_argument.error_code = apl_error_table_$domain;
	current_lexeme = rs (operators_argument.where_error).lexeme;
	go to report_error;

domain_error_1:
	operators_argument.error_code = apl_error_table_$domain;
	current_lexeme = rs (current_parseme - 1).lexeme;
	go to report_error;

value_error_s2:
	operators_argument.error_code = apl_error_table_$value;
	current_lexeme = rs (start - 2).lexeme;
	go to report_error;

value_error_s0:
	operators_argument.error_code = apl_error_table_$value;
	current_lexeme = rs (start).lexeme;
	go to report_error;

value_error_s1:
	operators_argument.error_code = apl_error_table_$value;
	current_lexeme = rs (start - 1).lexeme;
	go to report_error;

improper_dyadic_usage:
	operators_argument.error_code = apl_error_table_$improper_dyadic_usage;
	current_lexeme = rs (start - 1).lexeme;
	go to report_error;

improper_monadic_usage:
	operators_argument.error_code = apl_error_table_$improper_monadic_usage;
	current_lexeme = rs (start).lexeme;
	go to report_error;

improper_niladic_usage:
	operators_argument.error_code = apl_error_table_$improper_niladic_usage;
	current_lexeme = rs (start + 1).lexeme;
	go to report_error;

rank_error_1:
	operators_argument.error_code = apl_error_table_$operator_subscript_range;
	current_lexeme = rs (current_parseme - 1).lexeme;
	go to report_error;

bad_assignment:
	operators_argument.error_code = apl_error_table_$bad_assignment;
	current_lexeme = rs (operators_argument.where_error).lexeme;
	go to report_error;

bad_assign_to_label:
	operators_argument.error_code = apl_error_table_$assign_to_label;
	current_lexeme = rs (operators_argument.where_error).lexeme;
	go to report_error;

bad_evaluated_input:
	operators_argument.error_code = apl_error_table_$bad_evaluated_input;
	current_lexeme = current_lexeme + 1;		/* assumes only called from bol_re */
	go to report_error;

bad_execute:
	operators_argument.error_code = apl_error_table_$bad_execute;
	call clean_up_rs;
	parse_frame_ptr = last_parse_frame_ptr;
	call restore_state;
	current_lexeme = 2;
	go to report_error;

domain_error_s1:
	operators_argument.error_code = apl_error_table_$domain;
	current_lexeme = rs (start - 1).lexeme;
	go to report_error;

rank_error_s1:
	operators_argument.error_code = apl_error_table_$rank;
	current_lexeme = rs (start - 1).lexeme;
	go to report_error;

execute_error_s0:
	parse_frame_ptr = last_parse_frame_ptr;
	call restore_state;
	operators_argument.error_code = apl_error_table_$execute;
	current_lexeme = rs (current_parseme - 1).lexeme;
	go to report_error;

depth_error:
	operators_argument.error_code = apl_error_table_$depth;
						/* depth errors get special handling. */

join_depth_handler:
	call apl_error_ (operators_argument.error_code, ""b, 0, "", null, 0);
	call reset_interrupt_info;
	call initialize_suspended_frame;
	go to read_and_lex_line;

cant_get_stop_trace:
	operators_argument.error_code = apl_error_table_$cant_get_stop_trace;
	go to report_error;

not_end_with_value:
	operators_argument.error_code = apl_error_table_$not_end_with_value;
	go to report_error;

ws_full_no_quota_error:
	ws_info.dont_interrupt_parse = "1"b;
	operators_argument.error_code = apl_error_table_$ws_full_no_quota;

/* because the apl_lex_ routine which is used to help position the error marker uses
   several pages of free storage (on the various stacks), we would probably take a
   fatal process error if the quota fault is on the process directory. Until this
   code can be upgraded to check the pdir quota, or to check the quota on the directory
   containing the segment on which we faulted, we will just play it safe and not
   call the lex. (thus avoiding recursive RQO faults). sigh. */

	have_a_line = "0"b;
	go to report_error;

dirty_stop:
	call reset_interrupt_info;
	operators_argument.error_code = apl_error_table_$interrupt;
	go to report_error;

pull_system_error:
	operators_argument.error_code = apl_error_table_$pull_system_error;
	go to report_error;

pull_assign_system_error:
	operators_argument.error_code = apl_error_table_$pull_assign_system_error;
	go to report_error;

report_error_system_error:
	operators_argument.error_code = apl_error_table_$report_error_system_error;
	go to join_depth_handler;			/* special action to avoid loop */

done_line_system_error:
	operators_argument.error_code = apl_error_table_$done_line_system_error;
	go to report_error;

report_error_from_operator:
	current_lexeme = rs (operators_argument.where_error).lexeme;

report_error:
	if (parse_frame.parse_frame_type = suspended_frame_type) | (parse_frame.parse_frame_type = evaluated_frame_type)
	then do;
		if have_a_line
		then call apl_line_lex_ (input_buffer.line, error_mark_structure_ptr, was_error, current_lexeme,
			addr (rs (current_parseme + 1)));
		else do;
			n_read = 0;		/* if no line, pass a null string to apl_error_ */
			error_mark_structure_ptr = parse_frame_ptr;
						/* (KLUDGE) values won't be used, can point anywhere. */
		     end;

		packed_temp_ptr = null;
		call apl_error_ (operators_argument.error_code, ""b, error_index_within_line, input_buffer.line,
		     packed_temp_ptr, 0);
	     end;
	else if parse_frame_type = function_frame_type
	then do;
		symbol_ptr_unal = parse_frame.lexed_function_bead_ptr -> lexed_function_bead.name;
		meaning_ptr_unal = parse_frame.function_bead_ptr;
		if meaning_ptr_unal -> function_bead.class ^= 0
		then do;

/* error while executing in locked function - cause domain error in caller */

			operators_argument.error_code = apl_error_table_$locked_function_error;
			parse_frame_ptr = parse_frame.last_parse_frame_ptr;
						/* unwind */
			call restore_state;
			go to report_error;
		     end;

		call apl_function_lex_ (meaning_ptr_unal -> function_bead.text, error_mark_structure_ptr, was_error,
		     current_lexeme, addr (rs (current_parseme + 1)));
		call apl_error_ (operators_argument.error_code, ""b, error_index_within_line,
		     substr (meaning_ptr_unal -> function_bead.text, error_line_index, length_of_line), symbol_ptr_unal,
		     parse_frame.current_line_number);

	     end;
	else if parse_frame.parse_frame_type = execute_frame_type
	then do;
		call clean_up_rs;
		where_execute_error = current_lexeme;
		if parse_frame.lexed_function_bead_ptr ^= null
		then call decrement_reference_count (parse_frame.lexed_function_bead_ptr);
		parse_frame_ptr = last_parse_frame_ptr;
		call restore_state;

		if ws_info.long_error_mode
		then do;
			execute_value_ptr = rs (current_parseme - 2).semantics;
			data_elements = execute_value_ptr -> value_bead.total_data_elements;
			call apl_execute_lex_ (execute_value_ptr -> value_bead.data_pointer -> character_string_overlay,
			     error_mark_structure_ptr, was_error, where_execute_error, addr (rs (current_parseme + 1)));
			packed_temp_ptr = null;
			call apl_error_ (operators_argument.error_code, ""b, error_index_within_line,
			     substr (execute_value_ptr -> value_bead.data_pointer -> character_string_overlay, 1),
			     packed_temp_ptr, 0);
		     end;

		current_lexeme = rs (current_parseme - 1).lexeme;
		operators_argument.error_code = apl_error_table_$execute;
		go to report_error;
	     end;
	else go to report_error_system_error;		/* workspace is screwed up */

recover_from_error:
	call reset_interrupt_info;
	call clean_up_rs;

	if parse_frame_type = suspended_frame_type
	then go to next_line;
	if parse_frame_type = evaluated_frame_type
	then go to next_line;

	call save_state;
	call push_new_frame;
	call initialize_suspended_frame;
	go to read_and_lex_line;

/* Called on simple assignmnet and subscripted assignment to get the variable being assigned to. */

pull_assignment_variable:
	current_parseme = current_parseme + 1;		/* bump parseme number */
	current_lexeme = current_lexeme - 1;		/* and move to the left to get next lexeme */
	rs (current_parseme).lexeme = current_lexeme;	/* remember where we got it */
	unspec (rs (current_parseme).bits) = ""b;	/* initialize state bits */
	operator_ptr = lexed_function_bead_ptr -> lexeme_array_ptr -> lexed_function_lexeme_array (current_lexeme);

	if ^operator_ptr -> general_bead.type.symbol
	then go to pull_assign_system_error;		/* lex is supposed to check */

	rs (current_parseme).semantics = operator_ptr -> symbol_bead.meaning_pointer;
	if rs (current_parseme).semantics = null
	then go to pull_null_var;			/* not yet assigned */
	if rs (current_parseme).semantics -> general_bead.type.value
	then do;					/* pull variable action - has value that will be replaced */
		rs (current_parseme).type = val_type;
		unspec (rs (current_parseme).bits) = value_bits;
		rs (current_parseme).semantics -> general_bead.reference_count =
		     rs (current_parseme).semantics -> general_bead.reference_count + 1;
		go to operator_return (return_point);
	     end;

/* assign to a function or something - barf */

	operators_argument.error_code = apl_error_table_$assign_to_value;
	go to report_error;

pull:
	current_parseme = current_parseme + 1;		/* bump parseme number */
	current_lexeme = current_lexeme - 1;		/* and move to the left to get next lexeme */
	rs (current_parseme).lexeme = current_lexeme;	/* remember where we got it */
	operator_ptr = lexed_function_bead_ptr -> lexeme_array_ptr -> lexed_function_lexeme_array (current_lexeme);

/* Until the compiler optimizes repeated references to bits in the same word, we'll do it by hand
   in the following case statement. (We really just want to check general_bead.type.operator, etc). */

	temp18 = string (operator_ptr -> general_bead.type);
						/* copy for speed */

	if temp18 = operator_type			/* is it an operator? */
	then do;
		rs (current_parseme).type = operator_ptr -> operator_bead.type_code;
		unspec (rs (current_parseme).bits) = unspec (operator_ptr -> operator_bead.bits_for_parse);

/* Until compiler combines tests before it combines common subexpressions, the
   following kludgy code is the only way to test both the system_variable and stop_trace bits */

		if (unspec (rs (current_parseme).bits) & "101000000000000000"b) ^= ""b
		then if rs (current_parseme).stop_trace_control
		     then go to pull_stop_trace;
		     else go to pull_system_variable;
		else go to operator_return (return_point);
	     end;
	else if temp18 = symbol_type			/* is it a symbol? */
	then do;
	     if current_lexeme > 1
	     & current_lexeme < lexed_function_bead_ptr -> statement_map (parse_frame.current_line_number)
	     then do;				/*  Check if symbol should be passed by name.  */
		temp_ptr = operator_ptr -> symbol_bead.meaning_pointer;
		if temp_ptr ^= null
		then if ^temp_ptr -> general_bead.value
		     then goto not_by_name;		/*  Must be undefined or a value.  */
		temp_ptr = lexed_function_bead_ptr -> lexeme_array_ptr
		     -> lexed_function_lexeme_array (current_lexeme - 1);
		if string (temp_ptr -> general_bead.type) ^= operator_type
		then goto not_by_name;		/*  Must be preceded by a 'qCALL' ";".  */
		if temp_ptr -> operator_bead.op1 ^= quadcall_semicolon_code
		then goto not_by_name;		/*  Must be preceded by a 'qCALL' ";".  */
		temp_ptr = lexed_function_bead_ptr -> lexeme_array_ptr
		     -> lexed_function_lexeme_array (current_lexeme + 1);
		if string (temp_ptr -> general_bead.type) ^= operator_type
		then goto not_by_name;		/*  Must be followed by a 'qCALL' ";" or ")".  */
		if temp_ptr -> operator_bead.op1 ^= quadcall_semicolon_code
		& temp_ptr -> operator_bead.type_code ^= close_paren_type
		then goto not_by_name;		/*  Must be followed by a 'qCALL' ";" or ")".  */
		rs (current_parseme).semantics = operator_ptr; /*  semantics is symbol itself  */
		rs (current_parseme).type = val_type;
		unspec (rs (current_parseme).bits) = value_bits;
		rs (current_parseme).semantics -> general_bead.reference_count = rs (current_parseme).
		     semantics -> general_bead.reference_count + 1;
		go to operator_return (return_point);
not_by_name:
	     end;
		rs (current_parseme).semantics = operator_ptr -> symbol_bead.meaning_pointer;
						/* semantics is where symbol pts */
		if rs (current_parseme).semantics = null/* no value yet */
		then do;

pull_null_var:
			rs (current_parseme).type = val_type;
			unspec (rs (current_parseme).bits) = ""b;
			if rs (current_parseme - 1).type ^= op_type
			then call value_error_reporter (current_lexeme);
			if rs (current_parseme - 1).op1 ^= assignment_code
			then call value_error_reporter (current_lexeme);

			unspec (rs (current_parseme).bits) = value_bits;
			go to operator_return (return_point);
		     end;

		if rs (current_parseme).semantics -> general_bead.type.value
		then do;
			rs (current_parseme).type = val_type;
			unspec (rs (current_parseme).bits) = value_bits;
			rs (current_parseme).semantics -> general_bead.reference_count =
			     rs (current_parseme).semantics -> general_bead.reference_count + 1;
			go to operator_return (return_point);
		     end;

		if rs (current_parseme).semantics -> general_bead.type.function
		then do;
			temp_ptr = rs (current_parseme).semantics -> function_bead.lexed_function_bead_pointer;
			rs (current_parseme).type = op_type;
			unspec (rs (current_parseme).bits) = ""b;
			if temp_ptr = null		/* unlexed function */
			then do;
				temp_ptr = rs (current_parseme).semantics;

				if temp_ptr -> function_bead.class > 1
						/* external function */
				then do;
					call apl_external_fcn_addr_ (temp_ptr -> function_bead.text,
					     temp_ptr -> function_bead.lexed_function_bead_pointer);
					if temp_ptr -> function_bead.lexed_function_bead_pointer = null
					then go to recover_from_error;
				     end;
				else do;
					call apl_function_lex_no_messages_ (operator_ptr
					     -> symbol_bead.meaning_pointer -> function_bead.text,
					     temp_ptr -> function_bead.lexed_function_bead_pointer, was_error, 0,
					     addr (rs (current_parseme + 1)), (0));
					if was_error
					then go to recover_from_error;
				     end;
				temp_ptr = temp_ptr -> function_bead.lexed_function_bead_pointer;
			     end;
			rs (current_parseme).semantics -> general_bead.reference_count =
			     rs (current_parseme).semantics -> general_bead.reference_count + 1;

			if rs (current_parseme).semantics -> function_bead.class > 1
			then unspec (rs (current_parseme).bits) =
				external_function_bits (rs (current_parseme).semantics -> function_bead.class);
			else unspec (rs (current_parseme).bits) =
				unspec (temp_ptr -> lexed_function_bead.bits_for_parse);
			rs (current_parseme).semantics_valid = "1"b;

			if ^rs (current_parseme).bits.monadic
			then if ^rs (current_parseme).bits.dyadic
			     then do;
				     number_of_arguments = 0;
				     put_result = current_parseme;
				     start = current_parseme - 1;
				     go to invoke_niladic_function;
				end;
			go to operator_return (return_point);
		     end;

		rs (current_parseme).type = val_type;	/* get here if symbol isn't bound to a value */
		unspec (rs (current_parseme).bits) = ""b;
						/* or function...make rs consistent */
		rs (current_parseme).semantics = null;	/* again so we can keep running. */
	     end;
	else if (temp18 & value_type) = value_type	/* is it a value? */
	then do;
		operator_ptr -> general_bead.reference_count = operator_ptr -> general_bead.reference_count + 1;
		rs (current_parseme).semantics = operator_ptr;
		rs (current_parseme).type = val_type;
		unspec (rs (current_parseme).bits) = value_bits;
		go to operator_return (return_point);
	     end;

	go to pull_system_error;			/* invalid lexeme or invalid meaning for name */

pull_system_variable:
	if rs (current_parseme).op1 ^= 0
	then do;
		operators_argument.op1 = rs (current_parseme).op1;
		operators_argument.where_error = current_parseme;
		operators_argument.error_code = 0;

/* If op1 is code for niladic file system functions qFNAMES
   or qFNUMS, call the file system. */

		if (operators_argument.op1 = fnames_code) | (operators_argument.op1 = fnums_code)
		then call apl_file_system_$niladic_functions (operators_argument);
		else call apl_system_variables_ (operators_argument);
		if operators_argument.error_code ^= 0
		then go to report_error_from_operator;

		rs (current_parseme).semantics = operators_argument.result;
		unspec (rs (current_parseme).bits) = computed_value_bits;
						/* force the right bits on */
		rs (current_parseme).type = val_type;
		go to operator_return (return_point);
	     end;

	put_result = current_parseme;
	call save_state;
	call push_new_frame;
	parse_frame_type = evaluated_frame_type;
	parse_frame.number_of_ptrs, number_of_ptrs = 3;
	go to read_and_lex_line;

pull_stop_trace:
	current_lexeme = current_lexeme - 1;
	temp_ptr = operator_ptr;
	operator_ptr = lexed_function_bead_ptr -> lexeme_array_ptr -> lexed_function_lexeme_array (current_lexeme);
	rs (current_parseme).semantics = null;
	if operator_ptr -> meaning_pointer = null
	then go to cant_get_stop_trace;
	operator_ptr = operator_ptr -> meaning_pointer;
	if ^operator_ptr -> general_bead.function
	then go to cant_get_stop_trace;

	if temp_ptr -> operator_bead.op1 = stop_code
	then rs (current_parseme).semantics = operator_ptr -> function_bead.stop_control_pointer;
	else if temp_ptr -> operator_bead.op1 = trace_code
	then rs (current_parseme).semantics = operator_ptr -> function_bead.trace_control_pointer;
	else if temp_ptr -> operator_bead.op1 = assign_to_stop_code
	then rs (current_parseme).semantics = operator_ptr;
	else rs (current_parseme).semantics = operator_ptr;

	if rs (current_parseme).semantics = null
	then go to cant_get_stop_trace;

	rs (current_parseme).semantics -> general_bead.reference_count =
	     rs (current_parseme).semantics -> general_bead.reference_count + 1;

	go to operator_return (return_point);

do_dyadic:
	print_final_value = "1"b;
	operators_argument.where_error = start - 1;
	if ^rs (start - 1).bits.dyadic
	then go to improper_dyadic_usage;
	if rs (start - 1).bits.inner_product
	then go to do_inner_product;
	go to dyadic_action (dyadic_table (rs (start - 1).bits.op1));

dyadic_action (1):					/* scalar dyadic operators */
	call setup_dyadic_operator_routine_call;
	call apl_dyadic_ (operators_argument);
	call finish_dyadic_operator_routine_call;
	go to operator_return (return_point);

dyadic_action (2):					/* (non-subscripted) assignment */
	print_final_value = "0"b;

	if rs (start - 2).semantics = null		/* rhs */
	then go to value_error_s2;

	if rs (start).semantics_valid			/* lhs was pulled onto rs, but we don't */
	then if ^rs (start).semantics_on_stack		/* need it ... wash the ptr to it. */
	     then if rs (start).semantics ^= null
		then call decrement_reference_count (rs (start).semantics);

	temp_ptr =
	     lexed_function_bead_ptr -> lexed_function_bead.lexeme_array_ptr
	     -> lexed_function_lexeme_array (rs (start).lexeme);
						/* get ptr to symbol_bead for lhs */

	if ^temp_ptr -> general_bead.symbol		/* lhs must be a symbol */
	then go to bad_assignment;

	if temp_ptr -> symbol_bead.meaning_pointer ^= null
	then if temp_ptr -> symbol_bead.meaning_pointer -> general_bead.label
	     then go to bad_assign_to_label;		/* lhs cannot be a label */

/* CASE 1: If the rhs is already in the heap (and isn't a label) we can assign it by reference.
	 The reference count of the rhs is bumped by 2 because both the meaning_pointer
	 and rs (put_result).semantics point to it.  The fact that rs (start-2).semantics also
	 also points to it is already counted for...it will be washed away, below. */

	if ^rs (start - 2).semantics_on_stack /* if rhs on heap */ & ^rs (start - 2).semantics -> value_bead.label
						/* if rhs is not a label */
	then do;
		if temp_ptr -> symbol_bead.meaning_pointer ^= null
		then call decrement_reference_count (temp_ptr -> symbol_bead.meaning_pointer);
						/* drop lhs ref ct */

		rs (start - 2).semantics -> general_bead.reference_count =
		     rs (start - 2).semantics -> general_bead.reference_count + 2;

		temp_ptr -> symbol_bead.meaning_pointer = rs (start - 2).semantics;
						/* assign it */
	     end;

	else if temp_ptr -> symbol_bead.meaning_pointer ^= null /* lhs has meaning */
	     then if temp_ptr -> symbol_bead.meaning_pointer -> general_bead.reference_count = 1
		& string (rs (start - 2).semantics -> general_bead.bead_type)
		= string (temp_ptr -> symbol_bead.meaning_pointer -> general_bead.bead_type)
		& substr (string (rs (start - 2).semantics -> general_bead.data_type), 1, 3)
		= substr (string (temp_ptr -> symbol_bead.meaning_pointer -> general_bead.data_type), 1, 3)
		& rs (start - 2).semantics -> value_bead.total_data_elements
		= temp_ptr -> symbol_bead.meaning_pointer -> value_bead.total_data_elements
		& rs (start - 2).semantics -> value_bead.rhorho
		= temp_ptr -> symbol_bead.meaning_pointer -> value_bead.rhorho
	then do;

/* CASE 2: lhs has a value, it is unshared, and it occupies
   the same number of words as the rhs.  The rhs is just copied over the lhs */

		string (temp_ptr -> symbol_bead.meaning_pointer -> value_bead.data_type) =
		     string (rs (start - 2).semantics -> value_bead.data_type);

		data_elements = temp_ptr -> symbol_bead.meaning_pointer -> value_bead.total_data_elements;

		if temp_ptr -> symbol_bead.meaning_pointer -> value_bead.character_value
		then temp_ptr -> symbol_bead.meaning_pointer -> value_bead.data_pointer -> character_string_overlay =
			rs (start - 2).semantics -> value_bead.data_pointer -> character_string_overlay;
		else temp_ptr -> symbol_bead.meaning_pointer -> value_bead.data_pointer -> numeric_datum (*) =
			rs (start - 2).semantics -> value_bead.data_pointer -> numeric_datum (*);

		if temp_ptr -> symbol_bead.meaning_pointer -> value_bead.rhorho ^= 0
						/* make check 'cause PL/I won't */
		then temp_ptr -> symbol_bead.meaning_pointer -> value_bead.rho (*) =
			rs (start - 2).semantics -> value_bead.rho (*);

/* The reference count is 2 because both the meaning_pointer and rs (put_result).semantics
		        point to the bead. */

		temp_ptr -> symbol_bead.meaning_pointer -> value_bead.reference_count = 2;
		temp_ptr -> symbol_bead.meaning_pointer -> value_bead.label = "0"b;
	     end;

	else goto case_3;	/* else clause for multiple "and" clause test above */

	else do;	/* else clause for null pointer test */

/* CASE 3: Everything else comes here. We have to copy the rhs into the heap
   and make the lhs point to it.  The reference count of the lhs is bumped by 1
   because both the meaning_pointer and rs (put_result).semantics point to it. */

case_3:
		if temp_ptr -> symbol_bead.meaning_pointer ^= null
						/* drop old meaning */
		then call decrement_reference_count (temp_ptr -> symbol_bead.meaning_pointer);

		ws_info.dont_interrupt_parse = "0"b;	/* unmask so RQO handler can get control */
		call apl_copy_value_ (rs (start - 2).semantics, temp_ptr -> symbol_bead.meaning_pointer);
		ws_info.dont_interrupt_parse = "1"b;	/* remask */
		temp_ptr -> symbol_bead.meaning_pointer -> value_bead.label = "0"b;
		temp_ptr -> symbol_bead.meaning_pointer -> value_bead.reference_count =
		     temp_ptr -> symbol_bead.meaning_pointer -> value_bead.reference_count + 1;
	     end;

	if rs (start - 2).semantics_on_stack
	then ws_info.value_stack_ptr = rs (start - 2).semantics;
	else call decrement_reference_count (rs (start - 2).semantics);
						/* wash rs ptr to rhs */

	rs (put_result).semantics = temp_ptr -> symbol_bead.meaning_pointer;
	unspec (rs (put_result).bits) = value_bits;
	go to operator_return (return_point);

dyadic_action (3):					/* dyadic epsilon */
	call setup_dyadic_operator_routine_call;
	call apl_dyadic_epsilon_ (operators_argument);
	call finish_dyadic_operator_routine_call;
	go to operator_return (return_point);

dyadic_action (4):					/* index */
	call setup_dyadic_operator_routine_call;
	call apl_dyadic_iota_ (operators_argument);
	call finish_dyadic_operator_routine_call;
	go to operator_return (return_point);

dyadic_action (5):					/* invoke dyadic function */
	number_of_arguments = 2;

	if ^rs (start - 2).semantics_valid
	then call value_error_reporter (start - 2);
	if rs (start - 2).semantics = null
	then call value_error_reporter (start - 2);
	if ^rs (start).semantics_valid
	then call value_error_reporter (start);
	if rs (start).semantics = null
	then call value_error_reporter (start);

invoke_niladic_function:
invoke_monadic_function:
	temp_ptr = rs (start - number_of_arguments + 1).semantics;

	if temp_ptr -> function_bead.class > 1
	then go to invoke_external_function;

	temp_ptr = temp_ptr -> function_bead.lexed_function_bead_pointer;

	if number_of_arguments = 2
	then if ^temp_ptr -> lexed_function_bead.bits_for_parse.dyadic
	     then go to improper_dyadic_usage;
	     else ;
	else if number_of_arguments = 1
	then if ^temp_ptr -> lexed_function_bead.bits_for_parse.monadic
	     then go to improper_monadic_usage;
	     else ;
	else if temp_ptr -> lexed_function_bead.bits_for_parse.monadic
		| temp_ptr -> lexed_function_bead.bits_for_parse.dyadic
	then go to improper_niladic_usage;

	call save_state;
	call push_new_frame;

/* Initialize the new function frame. */

	parse_frame.parse_frame_type = function_frame_type;
	parse_frame.current_line_number = 1;
	parse_frame.initial_value_stack_ptr = ws_info.value_stack_ptr;

	parse_frame.function_bead_ptr = rs (start - number_of_arguments + 1).semantics;
	lexed_function_bead_ptr,
	     parse_frame.lexed_function_bead_ptr =
	     parse_frame.function_bead_ptr -> function_bead.lexed_function_bead_pointer;
	lexed_function_bead_ptr -> general_bead.reference_count =
	     lexed_function_bead_ptr -> general_bead.reference_count + 1;

/* Localize local names and labels. */

	parse_frame.number_of_ptrs,
	     number_of_ptrs = lexed_function_bead_ptr -> lexed_function_bead.number_of_localized_symbols;
	do i = 1 to lexed_function_bead_ptr -> lexed_function_bead.number_of_localized_symbols;
	     temp_ptr = lexed_function_bead_ptr -> lexed_function_bead.localized_symbols (i);
	     if temp_ptr ^= null
	     then if temp_ptr -> general_bead.symbol
		then do;
			parse_frame.old_meaning_ptrs (i) = temp_ptr -> symbol_bead.meaning_pointer;
			temp_ptr -> symbol_bead.meaning_pointer = null;
		     end;
		else do;				/* must be operator bead for localized system variable */
			parse_frame.old_meaning_ptrs (i) = save_system_variable_value (temp_ptr);
		     end;
	     else parse_frame.old_meaning_ptrs (i) = null;
	end;

	number_of_non_labels =
	     lexed_function_bead_ptr -> number_of_localized_symbols - lexed_function_bead_ptr -> number_of_labels;

	do i = lexed_function_bead_ptr -> number_of_localized_symbols to number_of_non_labels + 1 by -1;
	     temp_ptr = lexed_function_bead_ptr -> localized_symbols (i);
	     temp_ptr -> meaning_pointer =
		lexed_function_bead_ptr -> label_values_ptr -> lexed_function_label_values (i - number_of_non_labels);
	     temp_ptr -> meaning_pointer -> general_bead.reference_count =
		temp_ptr -> meaning_pointer -> general_bead.reference_count + 1;
	end;

/* Copy the arguments into the heap...arguments must look like real values, not stack temps. */

	temp_ptr = rsp;
	rsp, reduction_stack_ptr = addrel (parse_frame_ptr, size (parse_frame));

	if number_of_arguments = 2
	then do;
		call fill_in_arguments (temp_ptr, start - 2, (RightArgSymbol));
		call fill_in_arguments (temp_ptr, start, (LeftArgSymbol));
	     end;
	else if number_of_arguments = 1
	then call fill_in_arguments (temp_ptr, start - 1, (RightArgSymbol));

	go to start_line;

invoke_external_function:
	external_function_ptr = rs (start - number_of_arguments + 1).semantics;

	if number_of_arguments + 2 ^= external_function_ptr -> function_bead.class
	then go to context_error_0;

	operators_argument.result = null;

	if number_of_arguments = 0
	then do;
		operators_argument.value (1) = null;
		operators_argument.value (2) = null;
		operators_argument.on_stack (1) = "0"b;
		operators_argument.on_stack (2) = "0"b;
		operators_argument.error_code = 0;
		dont_interrupt_parse = "0"b;
		if dirty_interrupt_pending
		then go to dirty_stop;
	     end;
	else if number_of_arguments = 1
	then call setup_monadic_operator_routine_call;
	else call setup_dyadic_operator_routine_call;

	call cu_$ptr_call ((external_function_ptr -> function_bead.lexed_function_bead_pointer), operators_argument);
	call decrement_reference_count (rs (start - number_of_arguments + 1).semantics);

	if number_of_arguments = 0
	then do;
		if operators_argument.error_code ^= 0
		then go to report_error_from_operator;

		dont_interrupt_parse = "1"b;
		rs (put_result).semantics = operators_argument.result;
		unspec (rs (put_result).bits) = computed_value_bits;
	     end;
	else if number_of_arguments = 1
	then call finish_monadic_operator_routine_call;
	else call finish_dyadic_operator_routine_call;

	rs (put_result).type = val_type;
	go to operator_return (return_point);

dyadic_action (6):					/* catenate */
	call setup_dyadic_operator_routine_call;

	if rs (start - 1).bits.semantics_valid
	then operators_argument.dimension = rs_for_op (start - 1).semantics;
	else operators_argument.dimension =
		max (rs (start).semantics -> value_bead.rhorho, rs (start - 2).semantics -> value_bead.rhorho);

join_catenate:
	call apl_catenate_ (operators_argument);
	call finish_dyadic_operator_routine_call;
	go to operator_return (return_point);

dyadic_action (7):					/* compression last */
	call setup_dyadic_operator_routine_call;
	operators_argument.dimension = rs (start - 2).semantics -> value_bead.rhorho;

join_compression:
	if rs (start - 1).semantics_valid
	then operators_argument.dimension = rs_for_op (start - 1).semantics;

	call apl_compression_ (operators_argument);
	call finish_dyadic_operator_routine_call;
	go to operator_return (return_point);

dyadic_action (8):					/* expansion last */
	call setup_dyadic_operator_routine_call;
	operators_argument.dimension = rs (start - 2).semantics -> value_bead.rhorho;

join_expansion:
	if rs (start - 1).semantics_valid
	then operators_argument.dimension = rs_for_op (start - 1).semantics;

	call apl_expansion_ (operators_argument);
	call finish_dyadic_operator_routine_call;
	go to operator_return (return_point);

dyadic_action (9):					/* dyadic file system functions */
	call setup_dyadic_operator_routine_call;
	call apl_file_system_ (operators_argument);
	call finish_dyadic_operator_routine_call;
	go to operator_return (return_point);

dyadic_action (10):					/* dyadic rho */
	call setup_dyadic_operator_routine_call;
	call apl_dyadic_rho_ (operators_argument);
	call finish_dyadic_operator_routine_call;
	go to operator_return (return_point);

dyadic_action (11):					/* laminate */
	call setup_dyadic_operator_routine_call;
	operators_argument.dimension = rs_for_op (start - 1).semantics;
	call apl_laminate_ (operators_argument);
	call finish_dyadic_operator_routine_call;
	go to operator_return (return_point);

dyadic_action (12):					/* compression first */
	call setup_dyadic_operator_routine_call;
	operators_argument.dimension = 1;
	go to join_compression;

dyadic_action (13):					/* expansion first */
	call setup_dyadic_operator_routine_call;
	operators_argument.dimension = 1;
	go to join_expansion;

dyadic_action (14):					/* outer product */
	call setup_dyadic_operator_routine_call;
	operators_argument.op1 = rs (start - 1).bits.op2;
	call apl_outer_product_ (operators_argument);
	call finish_dyadic_operator_routine_call;
	go to operator_return (return_point);

dyadic_action (15):					/* take */
	call setup_dyadic_operator_routine_call;
	call apl_take_ (operators_argument);
	call finish_dyadic_operator_routine_call;
	go to operator_return (return_point);

dyadic_action (16):					/* drop */
	call setup_dyadic_operator_routine_call;
	call apl_drop_ (operators_argument);
	call finish_dyadic_operator_routine_call;
	go to operator_return (return_point);

dyadic_action (17):					/* rotate last */
	call setup_dyadic_operator_routine_call;
	if rs (start - 1).semantics_valid
	then operators_argument.dimension = rs_for_op (start - 1).semantics;
	else operators_argument.dimension = rs (start - 2).semantics -> value_bead.rhorho;

rotate_either:
	call apl_rotate_ (operators_argument);
	call finish_dyadic_operator_routine_call;
	go to operator_return (return_point);

dyadic_action (18):					/* rotate first */
	call setup_dyadic_operator_routine_call;
	if rs (start - 1).semantics_valid
	then operators_argument.dimension = rs_for_op (start - 1).semantics;
	else operators_argument.dimension = 1;
	go to rotate_either;

dyadic_action (19):					/* dyadic transpose */
	call setup_dyadic_operator_routine_call;
	call apl_transpose_ (operators_argument);
	call finish_dyadic_operator_routine_call;
	go to operator_return (return_point);

dyadic_action (20):					/* decode */
	call setup_dyadic_operator_routine_call;
	call apl_decode_ (operators_argument);
	call finish_dyadic_operator_routine_call;
	go to operator_return (return_point);

dyadic_action (21):					/* encode */
	call setup_dyadic_operator_routine_call;
	call apl_encode_ (operators_argument);
	call finish_dyadic_operator_routine_call;
	go to operator_return (return_point);

dyadic_action (22):					/* catenate first */
	call setup_dyadic_operator_routine_call;
	operators_argument.dimension = 1;
	go to join_catenate;

dyadic_action (23):					/* format */
	call setup_dyadic_operator_routine_call;
	call apl_dyadic_format_ (operators_argument);
	call finish_dyadic_operator_routine_call;
	go to operator_return (return_point);

dyadic_action (24):					/* semicolon cons */
	if rs (start).semantics = null
	then go to value_error_s0;

	if rs (start - 2).semantics = null
	then go to value_error_s2;

	call append_to_list_bead (addr (rs (start - 2)) -> rs_overlay);
	rs (start - 2).semantics -> list_bead.member_ptr (1) = rs (start).semantics;
	unspec (rs (start - 2).semantics -> list_bead.bits (1)) = unspec (rs (start).bits);

/* the reference counts are OK... */

	rs (put_result).semantics = rs (start - 2).semantics;
	unspec (rs (put_result).bits) = unspec (rs (start - 2).bits);
	go to operator_return (return_point);

dyadic_action (25):					/* deal */
	call setup_dyadic_operator_routine_call;
	call apl_random_ (operators_argument);
	call finish_dyadic_operator_routine_call;
	go to operator_return (return_point);

dyadic_action (26):					/* system functions */
	call setup_dyadic_operator_routine_call;
	parse_frame.current_parseme = current_parseme;
	call apl_system_functions_ (operators_argument);
	call finish_dyadic_operator_routine_call;
	go to operator_return (return_point);

dyadic_action (27):					/* dyadic domino */
	call setup_dyadic_operator_routine_call;
	call apl_domino_operator_ (operators_argument);
	call finish_dyadic_operator_routine_call;
	go to operator_return (return_point);

dyadic_action (28):					/* subscripted assignment */
	print_final_value = "0"b;
	operators_argument.error_code = 0;
	call apl_subscripted_assignment_ (operators_argument, addr (rs (start)));

	if operators_argument.error_code ^= 0
	then go to report_error_from_operator;

	rs (put_result).semantics = rs (start - 2).semantics;
	unspec (rs (put_result).bits) = unspec (rs (start - 2).bits);
	go to operator_return (return_point);

dyadic_action (29):					/* dyadic ibeam */
	call setup_dyadic_operator_routine_call;
	call apl_dyadic_ibeam_ (operators_argument);
	call finish_dyadic_operator_routine_call;
	go to operator_return (return_point);

do_inner_product:
	call setup_dyadic_operator_routine_call;
	operators_argument.op2 = rs (start - 1).bits.op2;
	call apl_inner_product_ (operators_argument);
	call finish_dyadic_operator_routine_call;
	go to operator_return (return_point);

do_monadic:
	print_final_value = "1"b;
	operators_argument.where_error = start;
	if ^rs (start).bits.monadic
	then go to improper_monadic_usage;
	go to monadic_action (monadic_table (rs (start).bits.op1));

monadic_action (1):					/* monadic scalar operators */
	call setup_monadic_operator_routine_call;
	call apl_monadic_ (operators_argument);
	call finish_monadic_operator_routine_call;
	go to operator_return (return_point);

monadic_action (2):					/* monadic functions */
	number_of_arguments = 1;

	if ^rs (start - 1).semantics_valid
	then call value_error_reporter (start - 1);
	if rs (start - 1).semantics = null
	then call value_error_reporter (start - 1);

	go to invoke_monadic_function;

monadic_action (3):					/* branch */
	print_final_value = "0"b;
	if rs (start - 1).semantics = null
	then go to value_error_s0;

/* Get out of any execute frame(s) we are in, and back to the last function frame. */

	do branch_pf_ptr = parse_frame_ptr repeat (branch_pf_ptr -> parse_frame.last_parse_frame_ptr)
	     while (branch_pf_ptr -> parse_frame.parse_frame_type = execute_frame_type);
	end;

	if branch_pf_ptr -> parse_frame.parse_frame_type = function_frame_type
	then if branch_pf_ptr -> parse_frame.function_bead_ptr -> function_bead.trace_control_pointer ^= null
	     then if this_statement_is_one (branch_pf_ptr -> parse_frame.current_line_number,
		     branch_pf_ptr -> parse_frame.function_bead_ptr -> function_bead.trace_control_pointer)
		then do;
			call print_where_I_am (branch_pf_ptr, "1"b, "0"b);
			trace_branch_line = "1"b;
		     end;
	if rs (start - 1).semantics -> value_bead.total_data_elements > 0
	then do;
		if ^rs (start - 1).semantics -> value_bead.numeric_value
		then go to domain_error;
		x = rs (start - 1).semantics -> value_bead.data_pointer -> numeric_datum (0);
		xx = floor (x + 0.5);
		if abs (xx - x) > integer_fuzz
		then go to domain_error;
		if abs (xx) > 131071
		then go to domain_error;		/* check if integer & fixable in parse_frame.current_line_number */

		branch_pf_ptr -> parse_frame.current_line_number = fixed (xx, 17) - 1;
						/* subtract 1 so that adding 1 later will cancel out */
		was_branch_value = "1"b;
	     end;
	else was_branch_value = "0"b;
	was_branch = "1"b;
	rs (put_result).semantics = rs (start - 1).semantics;
	unspec (rs (put_result).bits) = unspec (rs (start - 1).bits);
	go to operator_return (return_point);

monadic_action (4):					/* ravel */
	call setup_monadic_operator_routine_call;
	call apl_ravel_ (operators_argument);
	call finish_monadic_operator_routine_call;
	go to operator_return (return_point);

monadic_action (5):					/* reduction last */
	call setup_monadic_operator_routine_call;

	if rs (start).bits.semantics_valid
	then operators_argument.dimension = rs_for_op (start).semantics;
	else operators_argument.dimension = rs (start - 1).semantics -> value_bead.rhorho;

	operators_argument.op1 = rs (start).bits.op2;
	call apl_reduction_ (operators_argument);
	call finish_monadic_operator_routine_call;
	go to operator_return (return_point);

monadic_action (6):					/* reduction first */
	call setup_monadic_operator_routine_call;

	if rs (start).bits.semantics_valid
	then operators_argument.dimension = rs_for_op (start).semantics;
	else operators_argument.dimension = 1;

	operators_argument.op1 = rs (start).bits.op2;
	call apl_reduction_ (operators_argument);
	call finish_monadic_operator_routine_call;
	go to operator_return (return_point);


monadic_action (7):					/* scan last */
	call setup_monadic_operator_routine_call;
	if rs (start).semantics_valid
	then operators_argument.dimension = rs_for_op (start).semantics;
	else operators_argument.dimension = rs (start - 1).semantics -> value_bead.rhorho;

	operators_argument.op1 = rs (start).op2;
	call apl_scan_operator_ (operators_argument);
	call finish_monadic_operator_routine_call;
	go to operator_return (return_point);

monadic_action (8):					/* scan first */
	call setup_monadic_operator_routine_call;
	if rs (start).semantics_valid
	then operators_argument.dimension = rs_for_op (start).semantics;
	else operators_argument.dimension = 1;

	operators_argument.op1 = rs (start).op2;
	call apl_scan_operator_ (operators_argument);
	call finish_monadic_operator_routine_call;
	go to operator_return (return_point);

monadic_action (9):					/* monadic file system functions */
	call setup_monadic_operator_routine_call;
	call apl_file_system_ (operators_argument);
	call finish_monadic_operator_routine_call;
	go to operator_return (return_point);

monadic_action (10):				/* monadic not */
	call setup_monadic_operator_routine_call;
	call apl_monadic_not_ (operators_argument);
	call finish_monadic_operator_routine_call;
	go to operator_return (return_point);

monadic_action (11):				/* reverse last */
	call setup_monadic_operator_routine_call;

	if rs (start).bits.semantics_valid
	then operators_argument.dimension = rs_for_op (start).semantics;
	else operators_argument.dimension = rs (start - 1).semantics -> value_bead.rhorho;

reverse_either:
	call apl_reverse_ (operators_argument);
	call finish_monadic_operator_routine_call;
	go to operator_return (return_point);

monadic_action (12):				/* reverse first */
	call setup_monadic_operator_routine_call;

	if rs (start).bits.semantics_valid
	then operators_argument.dimension = rs_for_op (start).semantics;
	else operators_argument.dimension = 1;

	go to reverse_either;

monadic_action (13):				/* monadic transpose */
	call setup_monadic_operator_routine_call;
	call apl_transpose_ (operators_argument);
	call finish_monadic_operator_routine_call;
	go to operator_return (return_point);

monadic_action (14):				/* execute */
	execute_value_ptr = rs (start - 1).semantics;
	if execute_value_ptr = null
	then go to value_error_s1;
	data_elements = execute_value_ptr -> value_bead.total_data_elements;
	if ^execute_value_ptr -> value_bead.character_value
	then if execute_value_ptr -> value_bead.numeric_value & data_elements > 0
	     then go to domain_error_s1;
	if execute_value_ptr -> value_bead.rhorho > 1
	then go to rank_error_s1;

	call save_state;
	call push_new_frame;
	parse_frame_type = execute_frame_type;
	parse_frame.number_of_ptrs, number_of_ptrs = 3;
	rsp, reduction_stack_ptr = addrel (parse_frame_ptr, size (parse_frame));

	current_parseme = 0;			/* in case of errors */
	parse_frame.current_parseme = 0;
	call apl_execute_lex_ (execute_value_ptr -> value_bead.data_pointer -> character_string_overlay,
	     parse_frame.lexed_function_bead_ptr, was_error, 0, rsp);
	if was_error
	then go to execute_error_s0;
	parse_frame.current_line_number = 1;
	go to start_line;

monadic_action (15):				/* format */
	call setup_monadic_operator_routine_call;
	call apl_monadic_format_ (operators_argument);
	call finish_monadic_operator_routine_call;
	go to operator_return (return_point);

monadic_action (16):				/* ibeam */
	call setup_monadic_operator_routine_call;
	call apl_ibeam_ (operators_argument);
	call finish_monadic_operator_routine_call;
	go to operator_return (return_point);

monadic_action (17):				/* assign to quad */
	if rs (start - 1).semantics = null
	then go to value_error_s1;
	in_printer = "1"b;
	call apl_print_value_ (rs (start - 1).semantics, "1"b, "1"b);
	in_printer = "0"b;
	go to nop_operator;

monadic_action (18):				/* assign to quote quad */
	if rs (start - 1).semantics = null
	then go to value_error_s1;
	in_printer = "1"b;
	call apl_print_value_ (rs (start - 1).semantics, "0"b, "1"b);
	in_printer = "0"b;
	go to nop_operator;

monadic_action (19):				/* assign to system variables */
	call setup_monadic_operator_routine_call;
	call apl_system_variables_ (operators_argument);
	if operators_argument.error_code ^= 0
	then go to report_error_from_operator;

nop_operator:
	dont_interrupt_parse = "1"b;
	print_final_value = "0"b;
	rs (put_result).semantics = rs (start - 1).semantics;
	unspec (rs (put_result).bits) = unspec (rs (start - 1).bits);
	go to operator_return (return_point);

monadic_action (20):				/* assign to system variable which ignores assignment */
	go to nop_operator;

monadic_action (21):				/* monadic system functions */
	call setup_monadic_operator_routine_call;
	parse_frame.current_parseme = current_parseme;
	call apl_system_functions_ (operators_argument);
	call finish_monadic_operator_routine_call;
	go to operator_return (return_point);

monadic_action (22):				/* assign to stop/trace */
	print_final_value = "0"b;
	if rs (start - 1).semantics = null
	then go to value_error_s2;

	temp_ptr = rs (start - 1).semantics;
	if rs (start).op1 = assign_to_stop_code
	then value_bead_ptr = addr (rs (start).semantics -> function_bead.stop_control_pointer);
	else value_bead_ptr = addr (rs (start).semantics -> function_bead.trace_control_pointer);

	if temp_ptr -> value_bead.character_value
	then if temp_ptr -> value_bead.total_data_elements ^= 0
						/* not '' */
	     then go to domain_error;

	if value_bead_ptr -> based_unaligned_ptr ^= null
	then call decrement_reference_count (value_bead_ptr -> based_unaligned_ptr);

	assignment_done = "0"b;			/* we will turn this on if we are resetting stop/trace */

	if temp_ptr -> value_bead.total_data_elements = 0
	then assignment_done = "1"b;
	else if (temp_ptr -> value_bead.total_data_elements = 1
		& temp_ptr -> value_bead.data_pointer -> numeric_datum (0) = 0.0e0)
	then assignment_done = "1"b;

	if ^assignment_done
	then do;
		ws_info.dont_interrupt_parse = "0"b;	/* unmask so RQO handler can get control */
		call apl_copy_value_ (rs (start - 1).semantics, value_bead_ptr -> based_unaligned_ptr);
		ws_info.dont_interrupt_parse = "1"b;	/* remask */
		value_bead_ptr -> based_unaligned_ptr -> value_bead.label = "0"b;
		value_bead_ptr -> based_unaligned_ptr -> value_bead.reference_count =
		     value_bead_ptr -> based_unaligned_ptr -> value_bead.reference_count + 1;
	     end;

	call decrement_reference_count (rs (start).semantics);
	rs (put_result).semantics = rs (start - 1).semantics;
	unspec (rs (put_result).bits) = unspec (rs (start - 1).bits);
	go to operator_return (return_point);

monadic_action (23):				/* monadic iota */
	call setup_monadic_operator_routine_call;
	call apl_monadic_iota_ (operators_argument);
	call finish_monadic_operator_routine_call;
	go to operator_return (return_point);

monadic_action (24):				/* monadic rho */
	call setup_monadic_operator_routine_call;
	call apl_monadic_rho_ (operators_argument);
	call finish_monadic_operator_routine_call;
	go to operator_return (return_point);

monadic_action (25):				/* monadic domino */
	call setup_monadic_operator_routine_call;
	call apl_domino_operator_ (operators_argument);
	call finish_monadic_operator_routine_call;
	go to operator_return (return_point);

monadic_action (26):				/* roll */
	call setup_monadic_operator_routine_call;
	call apl_random_ (operators_argument);
	call finish_monadic_operator_routine_call;
	go to operator_return (return_point);

monadic_action (27):				/* grade up */
	call setup_monadic_operator_routine_call;
	if rs (start).semantics_valid
	then operators_argument.dimension = rs_for_op (start).semantics;
	else operators_argument.dimension = rs (start - 1).semantics -> value_bead.rhorho;

	call apl_grade_up_ (operators_argument);
	call finish_monadic_operator_routine_call;
	go to operator_return (return_point);

monadic_action (28):				/* grade down */
	call setup_monadic_operator_routine_call;
	if rs (start).semantics_valid
	then operators_argument.dimension = rs_for_op (start).semantics;
	else operators_argument.dimension = rs (start - 1).semantics -> value_bead.rhorho;

	call apl_grade_down_ (operators_argument);
	call finish_monadic_operator_routine_call;
	go to operator_return (return_point);

monadic_action (29):				/* monadic laminate (invalid) */
	go to context_error_0;

monadic_action (30):				/* monadic qCALL system function */
	call setup_monadic_operator_routine_call;
	call apl_quadcall_ (operators_argument);
	call finish_monadic_operator_routine_call;
	goto operator_return (return_point);
/* INTERNAL PROCEDURES */

setup_dyadic_operator_routine_call:
     proc;

	if rs (start).semantics = null
	then go to value_error_s0;
	if rs (start - 2).semantics = null
	then go to value_error_s2;

	operators_argument.value (1) = rs (start).semantics;
	operators_argument.value (2) = rs (start - 2).semantics;
	operators_argument.on_stack (1) = rs (start).bits.semantics_on_stack;
	operators_argument.on_stack (2) = rs (start - 2).bits.semantics_on_stack;
	operators_argument.op1 = rs (start - 1).bits.op1;
	operators_argument.error_code = 0;

	dont_interrupt_parse = "0"b;
	if dirty_interrupt_pending
	then go to dirty_stop;

	return;

     end;


finish_dyadic_operator_routine_call:
     proc;

	if operators_argument.error_code ^= 0		/* Operator discovered an error... */
	then go to report_error_from_operator;

	ws_info.dont_interrupt_parse = "1"b;

	if ^operators_argument.on_stack (1)
	then call decrement_reference_count (rs (start).semantics);

	if ^operators_argument.on_stack (2)
	then call decrement_reference_count (rs (start - 2).semantics);

	rs (put_result).semantics = operators_argument.result;
	unspec (rs (put_result).bits) = computed_value_bits;
						/* force the right bits on */

	return;

     end;

setup_monadic_operator_routine_call:
     procedure;

	if rs (start - 1).semantics = null
	then go to value_error_s1;

	operators_argument.value (1) = null;
	operators_argument.value (2) = rs (start - 1).semantics;
	operators_argument.on_stack (1) = "0"b;
	operators_argument.on_stack (2) = rs (start - 1).bits.semantics_on_stack;
	operators_argument.op1 = rs (start).bits.op1;
	operators_argument.error_code = 0;

	dont_interrupt_parse = "0"b;
	if dirty_interrupt_pending
	then go to dirty_stop;

	return;

     end;


finish_monadic_operator_routine_call:
     proc;

	if operators_argument.error_code ^= 0		/* Operator ran into a problem... */
	then go to report_error_from_operator;

	ws_info.dont_interrupt_parse = "1"b;

	if ^operators_argument.on_stack (2)
	then call decrement_reference_count (rs (start - 1).semantics);

	rs (put_result).semantics = operators_argument.result;
	unspec (rs (put_result).bits) = computed_value_bits;
						/* force the right bits on */

	return;

     end;

/* Function to restore the value of a system variable. In the current implementation,
   we get the old value out of a value_bead, and put it back into ws_info. */

restore_system_variable_value:
     procedure (P_operator_bead_ptr, P_bead_ptr);

/* parameters */

declare	(
	P_operator_bead_ptr ptr,
	P_bead_ptr	ptr unal
	)		parameter;

/* automatic */

declare	bead_ptr		ptr unal,
	value		float;

/* builtins */

declare	fixed		builtin;

/* program */

	bead_ptr = P_bead_ptr;

	if P_operator_bead_ptr -> operator_bead.op2 ^= 4	/* qLX */
	then value = bead_ptr -> value_bead.data_pointer -> numeric_datum (0);

	go to set_value (P_operator_bead_ptr -> operator_bead.op1);

set_value (2):					/* qCT */
	ws_info.fuzz = value;
	go to end_set_value;

set_value (3):					/* qIO */
	ws_info.float_index_origin = value;
	ws_info.index_origin = fixed (value, 35);
	go to end_set_value;

set_value (4):					/* qLX */
	call decrement_reference_count (ws_info.latent_expression);
	bead_ptr -> general_bead.reference_count = bead_ptr -> general_bead.reference_count + 1;
	ws_info.latent_expression = bead_ptr;
	go to end_set_value;

set_value (5):					/* qPP */
	ws_info.digits = fixed (value, 35);
	go to end_set_value;

set_value (6):					/* qPW */
	ws_info.width = fixed (value, 35);
	go to end_set_value;

set_value (7):					/* qRL */
	ws_info.random_link = fixed (value, 35);
	go to end_set_value;

set_value (16):					/* qIT */
	ws_info.integer_fuzz = value;
	go to end_set_value;

end_set_value:
	call decrement_reference_count (bead_ptr);
	return;

     end restore_system_variable_value;

/* Function to localize a system variable. In the current implementation,
   we must turn the current value of the system variable into a value_bead,
   and return a pointer to that value_bead. */

save_system_variable_value:
     procedure (P_bead_ptr) returns (ptr);

/* parameters */

declare	P_bead_ptr	ptr parameter;

/* automatic */

declare	bead_ptr		ptr unal,
	data_ptr		ptr,
	n_words		fixed bin (19),
	value		float;

/* builtins */

declare	(addrel, float, rel, size, string)
			builtin;

/* entries */

declare	apl_allocate_words_ entry (fixed bin (19), ptr unal);

/* program */

	bead_ptr = P_bead_ptr;

/* We assume that the lex has validated the function so that only system variables
   that can actually be localized every reach us. */

	go to get_value (bead_ptr -> operator_bead.op1);

get_value (2):					/* qCT */
	value = ws_info.fuzz;
	go to end_get_value;

get_value (3):					/* qIO */
	value = ws_info.float_index_origin;
	go to end_get_value;

get_value (4):					/* qLX */
	ws_info.latent_expression -> general_bead.reference_count =
	     ws_info.latent_expression -> general_bead.reference_count + 1;
	return (ws_info.latent_expression);

get_value (5):					/* qPP */
	value = float (ws_info.digits, 63);
	go to end_get_value;

get_value (6):					/* qPW */
	value = float (ws_info.width, 63);
	go to end_get_value;

get_value (7):					/* qRL */
	value = float (ws_info.random_link, 63);
	go to end_get_value;

get_value (16):					/* qIT */
	value = ws_info.integer_fuzz;
	go to end_get_value;

end_get_value:
	number_of_dimensions = 0;
	data_elements = 1;
	n_words = size (value_bead) + size (numeric_datum) + 1;
	call apl_allocate_words_ (n_words, bead_ptr);

	string (bead_ptr -> value_bead.type) = numeric_value_type;
	bead_ptr -> value_bead.total_data_elements = data_elements;
	bead_ptr -> value_bead.rhorho = 0;
	data_ptr = addrel (bead_ptr, size (value_bead));
	if substr (rel (data_ptr), 18, 1)
	then data_ptr = addrel (data_ptr, 1);

	bead_ptr -> value_bead.data_pointer = data_ptr;
	data_ptr -> numeric_datum (0) = value;
	return (bead_ptr);

     end save_system_variable_value;

print_value:
     procedure;

/* automatic */

dcl	val_ptr		ptr unal;

/* program */

	if rs (current_parseme - 1).semantics_valid
	then if rs (current_parseme - 1).semantics ^= null
	     then do;
		     val_ptr = rs (current_parseme - 1).semantics;

		     if ^print_final_value
		     then if val_ptr -> general_bead.type.list_value
			then do;			/* check for list of all assignments, suppress printing */
				do i = 1 to val_ptr -> list_bead.number_of_members;
				     if val_ptr -> list_bead.members (i).bits.op1 = 0 /* non-assignment */
					& val_ptr -> list_bead.member_ptr (i) ^= null
						/* non-null list (i.e. not ;;) */
				     then print_final_value = "1"b;
						/* non assignment appears in list */
				end;
			     end;

		     if print_final_value
		     then do;
			     in_printer = "1"b;
			     call apl_print_value_ (val_ptr, "1"b, "1"b);
			     in_printer = "0"b;
			end;
		end;

     end /* print_value */;

read_executable_input_line:
     proc;

/* automatic */

declare	in_constant	bit (1) aligned,
	n_read_more	fixed bin (21),
	prompt_length	fixed bin (21),
	prompt_ptr	ptr;

/* entries */

declare	apl_system_error_	entry (fixed bin (35));

/* program */

read_again:
	have_a_line = "0"b;				/* if interrupt, cannot display current line */
	current_parseme = 0;
	parse_frame.current_parseme = 0;
	parse_frame.initial_value_stack_ptr = ws_info.value_stack_ptr;
	parse_frame.lexed_function_bead_ptr = null;
	parse_frame.number_of_ptrs, number_of_ptrs = 1;	/* we'd say 0, except that's not good PL/I */

/* In a suspended frame (or evaluated input frame) the input buffer overlays the area normally
   used by the old meaning ptrs */

	input_buffer_ptr = addrel (parse_frame_ptr, size (parse_frame) - 1);
	input_buffer.n_read = 0;
	ok_to_stop_control = "1"b;

	call check_for_interrupt_while_input;

	if parse_frame_type = suspended_frame_type
	then do;
		prompt_ptr = addr (ws_info.immediate_input_prompt);
		prompt_length = length (ws_info.immediate_input_prompt);
	     end;
	else do;
		prompt_ptr = addr (ws_info.evaluated_input_prompt);
		prompt_length = length (ws_info.evaluated_input_prompt);
	     end;

	prompt_ptr = addrel (prompt_ptr, 1);		/* point to chars in the varying string */
	call iox_$put_chars (apl_static_$apl_output, prompt_ptr, prompt_length, (0));

	max_input_line = 4 * (65536 - binary (rel (input_buffer_ptr), 18));

	call append_to_input_buffer;
	can_be_interrupted = "0"b;

	packed_temp_ptr = null;
	call apl_scan_ (input_buffer.line, 1, input_line_position, (0), scan_token_type, packed_temp_ptr);

	if scan_token_type = 1
	then if substr (input_buffer.line, input_line_position, 1) = QRightParen
	     then do;
		     dont_interrupt_parse = "0"b;
		     if dirty_interrupt_pending
		     then go to dirty_stop;
		     call apl_command_ (input_buffer.line, input_line_position, code);
		     dont_interrupt_parse = "1"b;

		     if code = 0
		     then go to read_again;		/* nothing special this time */

		     if code = apl_error_table_$return_from_apl
		     then go to return_statement;

		     if code = apl_error_table_$ws_cleared
		     then go to start_anew;

		     parse_frame_ptr = ws_info.current_parse_frame_ptr;
		     rsp = parse_frame.reduction_stack_ptr;

		     if code = apl_error_table_$ws_loaded
		     then go to ws_just_loaded;

		     go to read_again;		/* this stmt should never be executed */
		end;
	     else if substr (input_buffer.line, input_line_position, 1) = QDel
		     | substr (input_buffer.line, input_line_position, 1) = QDelTilde
	     then do;
		     dont_interrupt_parse = "0"b;
		     if dirty_interrupt_pending
		     then go to dirty_stop;
		     call apl_editor_ (input_buffer.line, input_line_position, code);
		     dont_interrupt_parse = "1"b;
		     if code = apl_error_table_$return_from_apl
		     then go to return_statement;
		     if code = apl_error_table_$ws_cleared
		     then go to start_anew;
		     go to read_again;
		end;

/* check for use of multi-line character constant */

	in_constant = "0"b;
scan_for_constants_again:
	do input_line_position = input_line_position by 1 while (input_line_position <= input_buffer.n_read);
	     if substr (input_buffer.line, input_line_position, 1) = QApostrophe
	     then in_constant = ^in_constant;
	     else if ^in_constant
	     then if substr (input_buffer.line, input_line_position, 1) = QLamp
		then go to exitloop;
	end;

exitloop:
	if in_constant				/* constant extends to next line */
	then do;
		call check_for_interrupt_while_input;
		if max_input_line - input_buffer.n_read < 500
		then call apl_system_error_ (apl_error_table_$too_much_input);

		call append_to_input_buffer;
		can_be_interrupted = "0"b;
		input_line_position = input_buffer.n_read - n_read_more + 1;
						/* scan the line that was read */
		go to scan_for_constants_again;
	     end;

	parse_frame.current_line_number = 1;
	return;

append_to_input_buffer:
     procedure;

/* automatic */

declare	got_line		bit (1) aligned,
	input_read_ptr	ptr,
	user_input_attachment_known
			bit (1) aligned;

/* based */

declare	input_buffer_array	(max_input_line) char (1) based (addr (input_buffer.line));

/* program */

	user_input_attachment_known = "0"b;
	got_line = "0"b;

	do while (^got_line);

	     ws_info.dont_interrupt_parse = "0"b;
	     input_read_ptr = addr (input_buffer_array (input_buffer.n_read + 1));
	     call iox_$get_line (apl_static_$apl_input, input_read_ptr, max_input_line - input_buffer.n_read, n_read_more,
		code);
	     ws_info.dont_interrupt_parse = "1"b;
	     if code = 0
	     then got_line = "1"b;
	     else if code = error_table_$short_record	/* no trailing NL */
	     then do;
		     n_read_more = n_read_more + 1;
		     substr (input_buffer.line, input_buffer.n_read + n_read_more, 1) = QNewLine;
		     got_line = "1"b;
		end;
	     else if code = error_table_$end_of_info
	     then do;
		     if user_input_attachment_known
		     then call apl_system_error_ (apl_error_table_$cant_read_input);

		     call reattach_user_input;
		     user_input_attachment_known = "1"b;
		end;
	end;
	input_buffer.n_read = input_buffer.n_read + n_read_more;

     end /* append_to_input_buffer */;

check_for_interrupt_while_input:
     procedure;

	can_be_interrupted = "1"b;
	if clean_interrupt_pending
	then do;
		call apl_error_ (apl_error_table_$interrupt, ""b, 0, "", packed_temp_ptr, 0);
		go to recover_from_error;
	     end;

     end /* check_for_interrupt_while_input */;

     end /* read_executable_input_line */;

lex_input_line:
     procedure (bv_code);

/* parameters */

declare	bv_code		fixed bin (35) parameter;

/* program */

	was_error = "0"b;
	parse_frame.number_of_ptrs, number_of_ptrs = 1 + divide (input_buffer.n_read + 3, 4, 21, 0);
	parse_frame.reduction_stack_ptr, rsp = addrel (parse_frame_ptr, size (parse_frame));
	call apl_line_lex_ (input_buffer.line, parse_frame.lexed_function_bead_ptr, was_error, 0, rsp);
	if was_error
	then bv_code = 1;
	else bv_code = 0;
	return;

     end lex_input_line;

initialize_suspended_frame:
     procedure;

	parse_frame.parse_frame_type = suspended_frame_type;
						/* it is a suspended frame */
	parse_frame.number_of_ptrs, number_of_ptrs = 3;	/* put reduction stack next */
	parse_frame.reduction_stack_ptr, rsp = addrel (parse_frame_ptr, size (parse_frame));
	parse_frame.initial_value_stack_ptr = ws_info.value_stack_ptr;
	return;

     end initialize_suspended_frame;

/* Procedure to wash a pointer (decrement the reference count of the bead pointed at, free the bead
   if necessary, and wipe out the original pointer).  */

decrement_reference_count:
     procedure (bv_bead_ptr);

/* parameters */

declare	bv_bead_ptr	ptr unaligned;

/* program */

	bv_bead_ptr -> general_bead.reference_count = bv_bead_ptr -> general_bead.reference_count - 1;

	if bv_bead_ptr -> general_bead.reference_count < 1
	then call apl_free_bead_ (bv_bead_ptr);

	bv_bead_ptr = null;				/* since heap ptrs are passed by reference, this will */
	return;					/* actually null out whatever variable pointer here. */

     end decrement_reference_count;

clean_up_rs:
     proc;

	do current_parseme = current_parseme to 1 by -1;
	     if rs (current_parseme).bits.has_list
	     then call free_list_bead (rs (current_parseme).semantics);

	     if rs (current_parseme).type = val_type
	     then if rs (current_parseme).bits.semantics_valid
		then if rs (current_parseme).semantics ^= null
		     then if ^rs (current_parseme).bits.semantics_on_stack
			then call decrement_reference_count (rs (current_parseme).semantics);
	end;

	parse_frame.current_parseme = 0;
	ws_info.value_stack_ptr = parse_frame.initial_value_stack_ptr;
	return;

     end;

save_state:
     proc;

	parse_frame.current_parseme = current_parseme;
	parse_frame.current_lexeme = current_lexeme;
	parse_frame.return_point = return_point;
	parse_frame.put_result = put_result;
	parse_frame.print_final_value = print_final_value;
	return;

     end;

restore_state:
     proc;

	print_final_value = parse_frame.print_final_value;
	was_branch = "0"b;
	was_branch_value = "0"b;
	trace_branch_line = "0"b;

restore_state_after_execute:
     entry ();

	current_parseme = parse_frame.current_parseme;
	current_lexeme = parse_frame.current_lexeme;
	return_point = parse_frame.return_point;
	put_result = parse_frame.put_result;
	lexed_function_bead_ptr = parse_frame.lexed_function_bead_ptr;
	ws_info.current_parse_frame_ptr = parse_frame_ptr;
	rsp = parse_frame.reduction_stack_ptr;

	number_of_ptrs = 1;				/* I'm not sure these stmts are necessary */
	input_buffer_ptr = addrel (parse_frame_ptr, size (parse_frame) - 1);
						/* .. */

/* Due to an oversight in the original implementation, the variables
   "start" and "number_of_arguments" were not saved in the parse_frame.
   Since the format of saved workspaces would have to be changed to save them
   now (and we would still have to be able to run with old workspaces), it seems
   easier to recalculate them here. */

	if return_point = 2
	then do;
		start = current_parseme;
		number_of_arguments = 2;
	     end;
	else do;
		start = current_parseme - 1;

		if return_point >= 8
		then number_of_arguments = 0;
		else number_of_arguments = 1;
	     end;

	return;

     end;

value_error_reporter:
     proc (where);

dcl	where		fixed bin;

	operators_argument.error_code = apl_error_table_$value;
	current_lexeme = where;
	go to report_error;

     end;

push_new_frame:
     proc;

	temp_ptr = addr (rs (current_parseme + 1));
	temp_ptr -> last_parse_frame_ptr = parse_frame_ptr;
	parse_frame_ptr = temp_ptr;
	ws_info.current_parse_frame_ptr = parse_frame_ptr;
	parse_frame.lexed_function_bead_ptr = null;
	parse_frame.current_parseme = 0;
	current_parseme = 0;

	if fixed (rel (ws_info.current_parse_frame_ptr), 18) > max_parse_stack_depth
	then go to depth_error;

	return;

     end;

/* Mixed output hangs a list_bead off of the right-end (RE) parseme.
   This procedure knows how to (re)allocate it so that a new value can be added on the front. */

append_to_list_bead:
     proc (reduction);

/* parameters */

dcl	1 reduction	aligned,
	  2 type		fixed bin,
	  2 bits		unaligned like operator_bead.bits_for_parse,
	  2 semantics	ptr unaligned,
	  2 lexeme	fixed bin;

/* program */

	if reduction.semantics_valid
	then if reduction.semantics -> general_bead.list_value
	     then n_members = reduction.semantics -> list_bead.number_of_members + 1;
	     else n_members = 2;
	else n_members = 1;

	temp_ptr = apl_push_stack_ (size (list_bead));
	unspec (temp_ptr -> list_bead.type) = list_value_type;
	temp_ptr -> list_bead.reference_count = -1;
	temp_ptr -> list_bead.number_of_members = n_members;

	if ^reduction.semantics_valid
	then do;
		reduction.semantics_valid = "1"b;
		reduction.semantics_on_stack = "1"b;
		reduction.has_list = "1"b;
		reduction.semantics = temp_ptr;
		return;
	     end;

	if reduction.semantics -> general_bead.list_value
	then do i = 2 to temp_ptr -> list_bead.number_of_members;
		unspec (temp_ptr -> list_bead.members (i)) = unspec (reduction.semantics -> list_bead.members (i - 1));
	     end;
	else do;
		temp_ptr -> list_bead.member_ptr (2) = reduction.semantics;
		unspec (temp_ptr -> list_bead.bits (2)) = unspec (reduction.bits);
		unspec (reduction.bits) = ""b;
		reduction.semantics_valid = "1"b;
		reduction.semantics_on_stack = "1"b;
		reduction.has_list = "1"b;
	     end;

	reduction.semantics = temp_ptr;
	return;

     end;

free_list_bead:
     proc (which);

dcl	i		fixed bin,
	which		ptr unal;

	do i = 1 to which -> list_bead.number_of_members;
	     if which -> list_bead.member_ptr (i) ^= null
	     then if ^which -> list_bead.bits (i).semantics_on_stack
		then call decrement_reference_count (which -> list_bead.member_ptr (i));
	end;

	return;

     end;


restore_old_meanings:
     procedure;

	do i = 1 to lexed_function_bead_ptr -> lexed_function_bead.number_of_localized_symbols;
	     temp_ptr = lexed_function_bead_ptr -> lexed_function_bead.localized_symbols (i);
	     if temp_ptr ^= null
	     then if temp_ptr -> general_bead.symbol
		then do;
			if temp_ptr -> symbol_bead.meaning_pointer ^= null
			then call decrement_reference_count (temp_ptr -> symbol_bead.meaning_pointer);

			temp_ptr -> symbol_bead.meaning_pointer = parse_frame.old_meaning_ptrs (i);
		     end;
		else do;				/* must be a localized system var */
			call restore_system_variable_value (temp_ptr, parse_frame.old_meaning_ptrs (i));
		     end;
	end;

	return;

     end /* restore_old_meanings */;

check_trace_vector:
     procedure;

/* program */

	if ^was_branch
	then if this_statement_is_one (parse_frame.current_line_number,
		parse_frame.function_bead_ptr -> function_bead.trace_control_pointer)
	     then do;
		     print_final_value = "1"b;
		     if ^rs (current_parseme - 1).semantics_valid | rs (current_parseme - 1).semantics = null
		     then call print_where_I_am (parse_frame_ptr, "0"b, "1"b);
		     else call print_where_I_am (parse_frame_ptr, "0"b, "0"b);
		end;

     end /* check_trace_vector */;

this_statement_is_one:
     procedure (P_line_number, P_ptr_to_vb) returns (bit (1) aligned);

/* parameters */

declare	(
	P_line_number	fixed bin,
	P_ptr_to_vb	ptr unal
	)		parameter;

/* automatic */

declare	ptr_to_vb		pointer;

/* program */

	ptr_to_vb = P_ptr_to_vb;
	x = P_line_number;

	do i = 0 by 1 while (i < ptr_to_vb -> value_bead.total_data_elements);
	     xx = ptr_to_vb -> value_bead.data_pointer -> numeric_datum (i);
	     if x = xx
	     then return ("1"b);
	     if abs (x - xx) < fuzz * abs (x + xx)
	     then return ("1"b);
	end;
	return ("0"b);

     end /* this_statement_is_one */;

print_where_I_am:
     procedure (P_frame_ptr, P_add_arrow, P_add_nl);

/* parameters */

declare	(
	P_frame_ptr	ptr,
	(P_add_arrow, P_add_nl)
			bit (1) aligned
	)		parameter;

/* pictures */

declare	line_number	picture "zzzzzzzzzz9";	/* 11 digits */

/* automatic */

declare	(first_nonblank, line_len, linex, n_nonblank)
			fixed bin (21),
	sp		ptr;

/* based */

declare	line		char (line_len) based (addr (rs (current_parseme + 1)));

/* program */

	sp = P_frame_ptr -> parse_frame.lexed_function_bead_ptr -> lexed_function_bead.name;
	linex = length (sp -> symbol_bead.name);
	substr (line, 1, linex) = sp -> symbol_bead.name;
	linex = linex + 1;

	substr (line, linex, 1) = QLeftBracket;
	linex = linex + 1;

	line_number = P_frame_ptr -> parse_frame.current_line_number;
	first_nonblank = verify (line_number, " ");
	n_nonblank = length (line_number) - first_nonblank + 1;
	substr (line, linex, n_nonblank) = substr (line_number, first_nonblank, n_nonblank);
	linex = linex + n_nonblank;

	substr (line, linex, 1) = QRightBracket;
	linex = linex + 1;

	if P_add_arrow
	then do;
		substr (line, linex, 2) = " " || QRightArrow;
		linex = linex + 2;
	     end;

	if ^P_add_nl
	then do;
		substr (line, linex, 1) = " ";
		linex = linex + 1;
	     end;

	line_len = linex - 1;
	call apl_print_string_ (line);

	if P_add_nl
	then call apl_flush_buffer_nl_;

	return;

     end;

initial_interrupt:
     procedure;

declare	(
	four_seconds	fixed binary (71) initial (4),
	relative_seconds	bit (2) initial ("11"b)
	)		internal static options (constant);

/* Re-syn user_input to user_i/o so that &attach effect of exec_coms will be undone if
   user QUITS while in an exec_com that &attaches. */

	call reattach_user_input;
	call iox_$control (apl_static_$apl_input, "resetread", null, (0));

	if in_printer /* in apl_print_value_, stop typing and INTERRUPT now */
	     | can_be_interrupted & ^clean_interrupt_pending
	then do;

/* interrupt now. */

		operators_argument.error_code = apl_error_table_$interrupt;
		go to report_error;			/* go print "INTERRUPT" and maybe the line being executed */
	     end;
	else if clean_interrupt_pending		/* ignore multiple interrupts */
	then return;

/* we cannot take the interrupt now. defer it until later. */

	clean_interrupt_pending = "1"b;

	call timer_manager_$alarm_call (four_seconds, relative_seconds, first_timer);

	return;

     end;

/* Small procedure to attach user_input back to user_i/o. Handles case where user_input is presently
   attached via syn_, and case where user_input is attached via regular IO module. */

reattach_user_input:
     procedure;

	call iox_$detach_iocb (iox_$user_input, code);
	if code ^= 0
	then if code = error_table_$not_closed
	     then do;				/* means was vfile_ or something */
		     call iox_$close (iox_$user_input, code);
		     call iox_$detach_iocb (iox_$user_input, code);
		end;
	call iox_$attach_ptr (iox_$user_input, "syn_ user_i/o", null, code);

     end /* reattach_user_input */;

reset_interrupt_info:
     procedure;

	call timer_manager_$reset_alarm_call (first_timer);
	call timer_manager_$reset_alarm_call (second_timer);
	ws_info.dont_interrupt_parse = "1"b;
	ws_info.dont_interrupt_operator = "0"b;
	ws_info.dont_interrupt_storage_manager = "0"b;
	ws_info.dont_interrupt_command = "0"b;
	ws_info.can_be_interrupted = "0"b;
	ws_info.clean_interrupt_pending = "0"b;
	ws_info.dirty_interrupt_pending = "0"b;
	in_printer = "0"b;

	return;

     end;

first_timer:
     procedure;

declare	(
	ten_seconds	fixed binary (71) initial (10),
	relative_seconds	bit (2) initial ("11"b)
	)		internal static options (constant);

	dirty_interrupt_pending = "1"b;
	signal apl_dirty_stop_;

	call timer_manager_$alarm_call (ten_seconds, relative_seconds, second_timer);

	return;

     end;


second_timer:
     procedure;

/* entries */

declare	apl_system_error_	entry (fixed bin (35));

/* program */

	call apl_system_error_ (apl_error_table_$super_dirty_stop);
	return;

     end second_timer;

fill_in_arguments:
     procedure (bv_rsp, from_which, to_where);

/* parameters */

declare	(
	bv_rsp		ptr,
	from_which	fixed bin,
	to_where		fixed bin
	)		parameter;

/* program */

	if bv_rsp -> rs (from_which).semantics_on_stack
	then do;
		ws_info.dont_interrupt_parse = "0"b;	/* unmask so RQO handler can get control */
		call apl_copy_value_ (bv_rsp -> rs (from_which).semantics, packed_temp_ptr);
		ws_info.dont_interrupt_parse = "1"b;	/* remask */
		bv_rsp -> rs (from_which).semantics = packed_temp_ptr;
		bv_rsp -> rs (from_which).semantics_on_stack = "0"b;
	     end;

	lexed_function_bead_ptr -> lexed_function_bead.localized_symbols (to_where) -> symbol_bead.meaning_pointer =
	     bv_rsp -> rs (from_which).semantics;
	bv_rsp -> rs (from_which).semantics -> general_bead.reference_count =
	     bv_rsp -> rs (from_which).semantics -> general_bead.reference_count + 1;

	return;

     end fill_in_arguments;

%include apl_push_stack_fcn;

/* this internal proc is invoked for every condition that is signalled during the execution of APL.
   It handles quits and pi's, makes the hardware faults into the appropriate APL action
   such as domain error, and processes those conditions which are used for internal
   communication within APL.
   Added 73.9.17 by DAM
 */

apl_default_handler_:
     procedure (mc_ptr, condition_name, wc_mc_ptr, info_ptr, continue_switch);

/* parameters */

declare	(
	mc_ptr		pointer,
	condition_name	char (*),
	wc_mc_ptr		pointer,
	info_ptr		pointer,
	continue_switch	bit (1) aligned
	)		parameter;

/* automatic */

declare	oncode_number	fixed bin;

/* builtins */

declare	oncode		builtin;

/* entries */

declare	apl_save_command_	entry (char (*), char (*), fixed bin (35));

/* program */

	if ws_info.transparent_to_signals		/* )E or something - we're not supposed to be here */
	then if condition_name ^= "program_interrupt"	/* but let pi's get back into APL */
	     then do;
		     continue_switch = "1"b;
		     return;
		end;
	     else ws_info.transparent_to_signals = "0"b;	/* pi - clear flag since re-entering APL */

/* conditions used for communication with the outside world */

	if condition_name = "quit"
	then do;
		if ws_info.switches.no_quit_handler
		then do;
			continue_switch = "1"b;
			return;
		     end;

		call iox_$control (apl_static_$apl_input, "process_quit", null, code);
						/* check for editing-attention */
		if code ^= 0			/* if APL dim isn't there, we have to do it ourselves */
		then do;				/* assume quit was interrupt, since we can't edit here anyway */
			call iox_$control (apl_static_$apl_output, "resetwrite", null, (0));
						/* flush output */
			call iox_$put_chars (apl_static_$apl_output, addr (QNewLine), length (QNewLine), (0));
			signal apl_quit_;
		     end;
	     end;

	else if condition_name = "program_interrupt"
	then go to recover_from_error;		/* we probably faulted out; treat as system error */

/* conditions used for internal communication */

	else if condition_name = "apl_system_error_"	/* message already has been printed; just bomb out */
	then go to recover_from_error;

	else if condition_name = "apl_dirty_stop_"
	then do;					/* stopping in the middle of a line, between operators */

		if dont_interrupt_parse
		then go to on_return;
		if dont_interrupt_operator
		then go to on_return;
		if dont_interrupt_storage_manager
		then go to on_return;
		if dont_interrupt_command
		then go to on_return;
		go to dirty_stop;

on_return:
	     end;

	else if condition_name = "apl_quit_"		/* DIM decided this attention was an "interrupt" */
	then call initial_interrupt;			/* set up to stop later at some more convenient time */

	else do;

/* hardware conditions */
/* make sure that we are interruptible.  If we are not interruptible, then we are not
   in an operator and any faults that occur are not domain errors but system errors.
   In this case we would let them out to default_error_handler_ so we can get a nice message.
 */

		if ws_info.dont_interrupt_parse | ws_info.dont_interrupt_storage_manager
		     | ws_info.dont_interrupt_operator | ws_info.dont_interrupt_command
		then do;
			continue_switch = "1"b;
			return;
		     end;

/* Note that a zerodivide condition is treated as a real error, and not an APL 0-:0 -> 1, because
   all of the APL divides are supposed to special-case 0-:0. */

		if (condition_name = "fixedoverflow") | (condition_name = "overflow") | (condition_name = "zerodivide")
		then go to domain_error;

		else if condition_name = "underflow"
		then do;

/* The FIM has made the following changes to the machine conditions:
   1. The AQ is "0"b.
   2. The E is -128 (Thus, the EAQ is a normalized floating-point zero).
   3. The ILC has been incremented if the instruction was not FSTR or DFSTR.
   4. The RFI and IF bits in the SCU.CU data have been turned on.

   Thus, all we have to do is return, and the underflow will be changed into a zero.
   The FIM has the capability to restore the fault right in ring 0, but there
   is no way at present to turn that on. When a way is added, APL should be changed.
   PG 10/23/79 */

			n_underflows = n_underflows + 1;
						/* meter these */
		     end;

		else if condition_name = "error"
		then do;
			oncode_number = oncode ();	/* magic number which tells something about error */
			if oncode_number > 0
			then if oncode_number <= 100	/* 1-100 are math errors */
			     then go to domain_error;

			continue_switch = "1"b;	/* unknown problem. let system print message */
		     end;

		else if condition_name = "finish"	/* signalled when process is being bumped */
		then do;
			if ^ws_info.restrict_save	/* sigh */
			then call apl_save_command_ ("continue", "", code);

			continue_switch = "1"b;	/* let default system action be taken, too. */
		     end;

		else if condition_name = "record_quota_overflow"
						/* hmm. if it's on the process dir, be careful! */
		then go to ws_full_no_quota_error;

/* some condition that we don't know about.  Either a timer went off
   or the guy just lost.  In either case, let it out to default_error_handler_
   so we can see the message; user can get back into APL with the program_interrupt command. */

		else continue_switch = "1"b;
	     end;					/* hardware conditions */
	return;

     end /* apl_default_handler_ */;

     end /* apl_parse_ */;
