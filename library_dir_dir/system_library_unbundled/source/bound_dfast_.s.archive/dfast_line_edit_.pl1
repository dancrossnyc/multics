/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */


dfast_line_edit_: proc (line, arg_edit_info_ptr, sort, code);

dcl  line char (256) var;				/* input line with edit request */
dcl  arg_edit_info_ptr ptr;				/* ptr to edit_info structure */
dcl  sort bit (1) unal;				/* ON for edit; OFF for editns */
dcl  code fixed bin (35);				/* fast error code */

/* automatic */

dcl  edit_info_ptr ptr;				/* ptr to edit_info structure */
dcl  start_index fixed bin (21);			/* index in the line table "t" to first number in block */
dcl  num_1 fixed bin (21);
dcl  num_2 fixed bin (21);
dcl  end_index fixed bin (21);			/* index in the line table "t" to last number in block */
dcl  line_start fixed bin (21);
dcl  line_end fixed bin (21);
dcl  num_3 fixed bin (21);
dcl  t_index fixed bin (21);				/* index into line table */
dcl  seq_number fixed bin (21);			/* sequence number for move, sequence, and resequence commands */
dcl  line_number fixed bin (21);
dcl  string char (10);
dcl  line_length fixed bin (21);			/*  length of the line */
dcl  last_index fixed bin (21);
dcl  block_length fixed bin (21);			/* number of characters in the block */
dcl  block_start fixed bin (21);
dcl  block_end fixed bin (21);
dcl  basic_resq_tbl_ptr ptr ;
dcl  temp_ptr ptr;
dcl  cur_ptr ptr;
dcl  cur_length fixed bin (21);
dcl  request char (3);				/* EDIT request */
dcl  arg char (256) var;				/* argument for dfast_get_arg_ */
dcl  num_pic pic "zzzzz9";
dcl  temp_length fixed bin (21);
dcl (i, j) fixed bin (21);
dcl  k fixed bin (21);				/* temporary used in request routines: list, move, etc. */
dcl  print_message bit (1) unal;			/* ON if the error message should be printed */
dcl  increment fixed bin (21);

dcl  old_string char (256) var;
dcl  new_string char (256) var;
dcl  length_old_string fixed bin (21);
dcl  length_new_string fixed bin (21);
dcl  check bit (1);					/* ON To prevent substitution of line number */
dcl  replace_OK bit (1);				/* ON if replace is allowed;  OFF if replace would
						   change the line number */


dcl 1 block (16),
    2 start fixed bin (21),
    2 end fixed bin (21);

dcl 1 seq (16),
    2 number fixed bin (21),
    2 incr fixed bin (21);
dcl  num_blocks fixed bin (21);

dcl 1 copy_info aligned,
    2 copy_ptr ptr,					/* ptr to base of target segment */
    2 old_length fixed bin (21),			/* length of segment before the copy */
    2 new_length fixed bin (21);			/* length of segment after the copy */

dcl  cleanup condition;


/* constants */

dcl  max_digits_line_num fixed bin int static options (constant) init (5); /* must match number_pic */
dcl  number_pic pic "99999";				/* used to convert number strings to fixed binary */
dcl  new_line char (1) int static options (constant) init ("
");
dcl  white_space char (2) int static options (constant) init ("	 "); /* tab & blank */
dcl  arg_delimiter char (4) int static options (constant) init ("	 ,;"); /* tab & blank & comma & semi-colon */
dcl  digit char (10) int static options (constant) init ("0123456789");
dcl  blank char (1) int static options (constant) init (" ");
dcl  COPY fixed bin int static options (constant) init (5);
dcl  REPLACE fixed bin int static options (constant) init (0); /* replace:  simple replace */
dcl  PREFIX fixed bin int static options (constant) init (1); /* replace:  prefix request */
dcl  SUFFIX fixed bin int static options (constant) init (2); /* replace:  suffix request */

/* based */

dcl 1 f aligned based (edit_info_ptr) like dfast_edit_info;
dcl  temp_seg char (f.max_seg_size) based (temp_ptr);
dcl  cur_seg char (cur_length) based (cur_ptr);
dcl 1 basic_resq_tbl aligned based (basic_resq_tbl_ptr),
    2 num_lines fixed bin (21),
    2 t (2) aligned,
      3 old_number fixed bin (17) unal,
      3 new_number fixed bin (17) unal;
dcl  based_arr (1) ptr based;

dcl (addr, divide, index, length, null, ptr, reverse, search, substr, translate, verify) builtin;

/* external */

dcl  iox_$user_output ptr ext;

dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin);
dcl  ioa_$rsnnl entry options (variable);
dcl  get_temp_segments_ entry (char (*), (*) ptr, fixed bin (35));
dcl  release_temp_segments_ entry (char (*), (*) ptr, fixed bin (35));
dcl  dfast_directory_ entry (fixed bin, char (*), ptr, ptr, fixed bin (35));
dcl  dfast_merge_ entry (bit (1) unal, ptr, fixed bin (35));
dcl  dfast_explain_ entry (char (*) var, char (*), fixed bin (35));
dcl  dfast_error_ entry (fixed bin (35), char (*), char (*));
dcl  dfast_get_arg_ entry (char (256) var, char (256) var) returns (bit (1) unal);
dcl  dfast_basic_resequence_ entry (fixed bin (21), ptr, char (*), bit (1), ptr, fixed bin (21), fixed bin (35));
dcl  iox_$put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35));

/* include files */

%include dfast_error_codes;
%include dfast_edit_info;
/*  */

	edit_info_ptr = arg_edit_info_ptr;
	print_message = "1"b;
	basic_resq_tbl_ptr = null;

	if dfast_get_arg_ (line, arg) then do;
	     request = arg;
	     request = translate (request, "abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ");

	     if f.alter_length > 0 then call dfast_merge_ ("0"b, edit_info_ptr, code);

	     if code = 0 then do;
		cur_ptr = f.current_ptr;
		cur_length = f.current_length;


		if request = "loc" then call locate;
		else if request = "lis" then call list;
		else if request = "exp" then call dfast_explain_ (line, "edit", code);
		else do;
		     temp_length = 0;
		     temp_ptr = f.alter_ptr;
		     on cleanup begin;
			if basic_resq_tbl_ptr ^= null then call free_buffers;
		     end;
		     if request = "joi" then call join ("0"b);
		     else if request = "mer" then call merge;
		     else if request = "app" then call append;
		     else if cur_length > 0 then do;	/* following request edit current segment */
			if request = "ins" then call insert;
			else if request = "rep" then call replace (REPLACE);
			else if request = "pre" then call replace (PREFIX);
			else if request = "suf" then call replace (SUFFIX);
			else if request = "des" then call desequence;
			else if request = "del" then call delete;
			else if request = "ext" then call extract;
			else if request = "mov" then call move;
			else if request = "res" then call resequence;
			else if request = "seq" then call sequence;
			else if request = "str" then call string_request;
			else code = error_unknown_arg;
			if code = 0 then f.edit_done = "1"b;
		     end;
		     else code = error_cur_empty;
		end;
	     end;
	end;
	else do;
	     code = error_request_miss;
	     arg = "";
	end;

	if code ^= 0 then if print_message then do;
		if code = error_no_num then arg = "";
		call dfast_error_ (code, "edit", (arg));
	     end;

	if basic_resq_tbl_ptr ^= null then call free_buffers;
	return;

/*  */
free_buffers: proc;

dcl  acode fixed bin (35);

	     if basic_resq_tbl_ptr ^= null then call release_temp_segments_ ("fast", addr (basic_resq_tbl_ptr) -> based_arr, acode);
	     if acode ^= 0 then call dfast_error_ (acode, "edit", "resequence_table");

	     return;

	end free_buffers;

/*  */
/* * This procedure deletes lines from the current segment.  The current segment is copied in portions (excluding
   * the line blocks)  into a temporary segment.
   *
   *	delete [<line list>]
   *
   *	code = 0		Lines were deleted.
   *	code ^= 0		Error code from parse_block_spec
   *
   * In case of error, the current segment is not changed.
*/
delete:	proc;

	     call parse_line_list;
	     if code = 0 then do;
		if num_blocks > 0 then do;
		     last_index = 0;
		     do k = 1 to num_blocks ;
			call copy_block (last_index + 1, block (k).start - 1);
			last_index = block (k).end;
		     end;
		     if code = 0 then do;
			call copy_block (last_index + 1, f.current_length);
			call switch_buffers;
		     end;
		end;
	     end;
	     else code = error_no_num;

	     return;

	end delete;

/*  */
/*  * This procedure extracts lines from the current segment.  The lines to be extracted are copied into a temporary
   *  buffer which becomes the current buffer if there are no errors.
   *
   *	extract [<line list>]
   *
   *	code = 0			Lines were extracted.
   *	code = error_no_num		No lines were requested.
   *	code ^= 0			Error code from parse_block_spec
   *
   *
*/
extract:	proc;

	     call parse_line_list;
	     if code ^= 0 then return;
	     if num_blocks > 0 then do;
		do k = 1 to num_blocks;

		     call copy_block ((block (k).start), (block (k).end));
		     if code ^= 0 then return;
		end;

		call switch_buffers;
	     end;

	     else code = error_line_miss;

	     return;

	end extract;

/*  */
/* * This procedure lists the lines requested.
   *
   *	list	[<line list>]
   *
   *	code = 0		Lines were printed
   *	code ^= 0		Error code from parse_block_spec
   *
   * Lines will be listed until the line list is exhausted or until the first error.
   *
*/

list:	proc;

	     if cur_length > 0 then do;

		call parse_line_list;
		if code ^= 0 then return;
		if num_blocks = 0 then do;
		     num_blocks = 1;
		     block (1).start = 1;
		     block (1).end = cur_length;
		end;

		do k = 1 to num_blocks;

		     call iox_$put_chars (iox_$user_output, addr (substr (cur_seg, block (k).start, 1)), block (k).end -
			block (k).start + 1, code);
		     call iox_$put_chars (iox_$user_output, addr (new_line), 1, code);
		end;
	     end;
	     else code = error_cur_empty;

	     return;

	end list;

/*  */
/* *  This procedure parses a list of segment pathnames and appends the segments onto the end of the current segment.
*/
join:	proc (fill_block_table);

dcl  fill_block_table bit (1) unal;			/* ON if should fill in block structure */

	     copy_info.copy_ptr = temp_ptr;
	     copy_info.old_length = 0;
	     num_blocks = 0;

	     do while (copy_seg ());
		if fill_block_table then do;
		     if num_blocks < 16 then do;
			num_blocks = num_blocks + 1;
			block (num_blocks).start = copy_info.old_length + 1;
			block (num_blocks).end = copy_info.new_length;
		     end;
		     else do;
			code = error_max_lines;
			return;
		     end;
		end;
		copy_info.old_length = copy_info.new_length;
	     end;

	     if code = 0 then do;
		temp_length = copy_info.old_length;
		call switch_buffers;
	     end;

	     return;

	end join;

/*  */
/* *  The append command reads one or more segments and resequences them.
   *
   *	append	seg_1 [, seg_2>] . . .
*/
append:	proc;

	     call join (f.basic_system);
	     if code = 0 then do;
		temp_length = 0;
		seq_number = 100;
		increment = 10;

		cur_ptr = f.current_ptr;		/* re-initialize, since JOIN called switched buffers */
		temp_ptr = f.alter_ptr;
		cur_length = f.current_length;
		if ^f.basic_system then do;
		     call renumber (1, cur_length, seq_number, increment);
		     if code = 0 then call switch_buffers;
		end;
		else do;
		     call get_temp_segments_ ("fast", addr (basic_resq_tbl_ptr) -> based_arr, code);
		     if code = 0 then do;
			do i = 1 to num_blocks while (code = 0);
			     num_lines = 0;
			     call fill_basic_tbl (basic_resq_tbl_ptr, "0"b, block (i).start, block (i).end, seq_number, increment);
			     if code = 0 then call copy_resq ("1"b, block (i).start, block (i).end);
			end;
			if code = 0 then call switch_buffers;
		     end;
		end;
	     end;

	     return;

	end append;

/*  */
/*  This procedure merges one or more segments.  The segments are copied into a tempory buffer and then sorted
   using the edit rules of dfast_merge_.
*/
merge:	proc;

	     call join ("0"b);

	     if code = 0 then call dfast_merge_ ("1"b, edit_info_ptr, code);

	     return;

	end merge;

/*  */
/* This procedure copies all the segments into the current segment.  It then copies and renumbers the entire segment.
   *
   *	insert	seg_name [;seg_name, line_number]
*/
insert:	proc;

dcl  index_arr (16) fixed bin (21);
dcl  second_tbl_ptr ptr;

dcl  k fixed bin (21);
dcl 1 second_tbl aligned based (second_tbl_ptr) like basic_resq_tbl;

	     call get_temp_segments_ ("fast", addr (basic_resq_tbl_ptr) -> based_arr, code);
	     seq_number = 100;
	     increment = 10;
	     num_blocks = 0;
	     basic_resq_tbl.num_lines = 0;
	     last_index = 0;
	     copy_info.copy_ptr = cur_ptr;
	     copy_info.old_length = 0;

	     if copy_seg () then do;
		cur_length, copy_info.old_length = copy_info.new_length;

		do while (copy_seg () & code = 0);
		     if num_blocks < 16 then do;
			num_blocks = num_blocks + 1;
			if find_line ((0), index_arr (num_blocks)) then do;
			     if index_arr (num_blocks) >= last_index then do;
				block (num_blocks).start = copy_info.old_length + 1;
				block (num_blocks).end = copy_info.new_length;
				copy_info.old_length = copy_info.new_length;
				if f.basic_system then do;
				     call fill_basic_tbl (basic_resq_tbl_ptr, "0"b, last_index + 1, index_arr (num_blocks),
					seq_number, increment);

				     seq (num_blocks).number = seq_number;
				     i = block (num_blocks).start;
				     do while (i <= block (num_blocks).end);
					j = index (substr (cur_seg, i, block (num_blocks).end - i + 1), new_line);
					if j > 0 then do;
					     seq_number = seq_number + increment;
					     i = i + j;
					end;
					else i = block (num_blocks).end + 1;
				     end;
				end;
				last_index = index_arr (num_blocks);
			     end;
			     else code = error_line_order;
			end;
		     end;
		     else code = error_max_lines;
		end;
		if num_blocks = 0 then code = error_request_miss;

	     end;
	     else code = error_request_miss;
	     if code ^= 0 then return;

	     if f.basic_system then call fill_basic_tbl (basic_resq_tbl_ptr, "0"b, last_index + 1, cur_length, seq_number, increment);
	     k = cur_length;
	     cur_length = block (num_blocks).end;
	     last_index = 0;

/* If the system is not basic the segment is just copied and renumbered */

	     if ^f.basic_system then do;
		do i = 1 to num_blocks while (code = 0);
		     call renumber (last_index + 1, index_arr (i), seq_number, increment);
		     call renumber (block (i).start, block (i).end, seq_number, increment);
		     last_index = index_arr (i);
		end;
		call renumber (last_index + 1, k, seq_number, increment);
		if code = 0 then call switch_buffers;
		return;
	     end;


	     second_tbl_ptr = addr (basic_resq_tbl_ptr -> basic_resq_tbl.t (basic_resq_tbl.num_lines + 1).old_number);
	     second_tbl.num_lines = 0;
	     do i = 1 to num_blocks while (code = 0);
		if last_index < index_arr (i) then call copy_resq ("1"b, last_index + 1, index_arr (i));
		last_index = index_arr (i);
		second_tbl.num_lines = 0;
		call fill_basic_tbl (second_tbl_ptr, "0"b, block (i).start, block (i).end, seq (i).number, increment);
		call dfast_basic_resequence_ (f.max_seg_size, second_tbl_ptr, substr (cur_seg, block (i).start, block (i).end - block (i).start + 1),
		     "1"b, temp_ptr, temp_length, code);
	     end;

	     if code = 0 then do;
		if last_index < k then call copy_resq ("1"b, last_index + 1, k);
		if code = 0 then call switch_buffers;
	     end;

	     return;

	end insert;

/*  */
/* This procedure moves one block of lines to a position following a given line number
   *
   *	move	num_1 - num_2, num_3
   *
   * If line_num is not present, the block is moved to a position following the logical spot for line_num.
   * The block that was moved is resequence with an initial value of line_num + 1 and  an increment of 1.
   * Lines following the block are resequenced if the block renumbering caused duplicate line numbers.
   *
   *	code = 0			successful
   *				line_num is within the range of the block.
   *	     = error_block_spec	the block contains no numbers
*/
move:	proc;

	     if parse_block_spec (1, start_index, end_index) then do;
		if find_line (line_start, line_end) then do;

		     seq_number = num_3 +1;

		     if f.basic_system then call basic_move;
		     else do;
			if num_3 < num_1 then do;
			     call copy_block (1, line_end);
			     call renumber (start_index, end_index, seq_number, 1);
			     call renumber_if_necessary (line_end + 1, start_index -1, seq_number);
			     call renumber_if_necessary (end_index +1, cur_length, seq_number);
			end;

			else if num_2 < num_3 then do;
			     call copy_block (1, start_index -1);
			     call copy_block (end_index + 1, line_end);
			     if end_index > start_index then call renumber (start_index, end_index, seq_number, 1);
			     call renumber_if_necessary (line_end + 1, cur_length, seq_number);
			end;

			else code = error_block_spec;
		     end;
		     if code = 0 then call switch_buffers;
		end;
		else code = error_no_num;
	     end;
	     else code = error_request_miss;

	     return;

	end move;

/*  */
/* *  This procedure resequences the file and edits the source code to reflect the new numbers.
   *  There are two types of editing done.
   *	"0"b	the line keeps its line number, but line references are changed.
   *	"1"b	both the line and any line  references are changed.
*/
basic_move: proc;


	     call get_temp_segments_ ("fast", addr (basic_resq_tbl_ptr) -> based_arr, code);
	     if code ^= 0 then return;
	     num_lines = 0;

	     call fill_basic_tbl (basic_resq_tbl_ptr, "0"b, start_index, end_index, seq_number, 1);

	     if num_3 < num_1 then do;
		call fill_basic_tbl (basic_resq_tbl_ptr, "1"b, line_end +1, start_index -1, seq_number, 1);
		call fill_basic_tbl (basic_resq_tbl_ptr, "1"b, end_index + 1, cur_length, seq_number, 1);

		if sort then do;
		     call copy_resq ("0"b, 1, line_end);
		     call copy_resq ("1"b, start_index, end_index);
		     call copy_resq ("1"b, line_end + 1, start_index -1);
		     call copy_resq ("1"b, end_index +1, cur_length);
		end;

		else call copy_resq ("1"b, 1, cur_length);
	     end;

	     else if num_2 < num_3 then do;
		call fill_basic_tbl (basic_resq_tbl_ptr, "1"b, line_end + 1, cur_length, seq_number, 1);

		if sort then do;
		     call copy_resq ("0"b, 1, start_index -1);
		     call copy_resq ("0"b, end_index + 1, line_end);
		     if end_index > start_index then call copy_resq ("1"b, start_index, end_index);
		     call copy_resq ("1"b, line_end + 1, cur_length);
		end;

		else call copy_resq ("1"b, 1, cur_length);
	     end;

	     else code = error_block_spec;


	     return;

	end basic_move;

/*   */
/* *  This procedure calls dfast_basic_resequence_.  It operates in two ways.
   *
   *	"1"b	Both the line number and any line references are changed.
   *	"0"b	Just the line references are changed.
*/
copy_resq: proc (resequence_lines, start, end);

dcl  resequence_lines bit (1);
dcl  start fixed bin (21);
dcl  end fixed bin (21);

	     call dfast_basic_resequence_ (f.max_seg_size, basic_resq_tbl_ptr, substr (cur_seg, start, end - start + 1),
		resequence_lines, temp_ptr, temp_length, code);

	     return;
	end copy_resq;

/*  */
/* This procedure prints all lines that contain the given string.
   *
   *	locate /old_string/  [<line list>]
   *
   *	(Any character except blank or tab may be used as a delimiter.)
   *
   *	code = 0			At least one string found.
   *	     = error_no_string	String was not found.
   *	     = error_no_nl		Segment does not end in a new_line.  (presumably not source)
*/
locate:	proc;

dcl  string_found bit (1) unal;			/*  ON if string was found at least once */

	     if cur_length > 0 then do;
		if parse_string_args ("1"b) then do;

		     string_found = "0"b;
		     do k = 1 to num_blocks;
			start_index = block (k).start;
			block_length = block (k).end - block (k).start + 1;

			do while (block_length > 0 & code = 0);
			     i = index (substr (cur_seg, start_index, block_length), old_string);
			     if i > 0 then do;
				j = index (reverse (substr (cur_seg, start_index, i)), new_line);
				if j > 0 then do;
				     block_length = block_length +j -i -1;
				     start_index = start_index +i -j +1;
				end;
				j = index (substr (cur_seg, start_index, block_length), new_line);
				if j > 0 then do;
				     call iox_$put_chars (iox_$user_output, addr (substr (cur_seg, start_index, 1)), j, code);
				     start_index = start_index + j;
				     block_length = block_length - j;
				     string_found = "1"b;
				end;
				else code = error_no_nl;
			     end;
			     else block_length = 0;

			end;
		     end;

		     if code = 0 then if ^string_found then code = error_no_string;
		end;
	     end;
	     else code = error_cur_empty;

	     return;

	end locate;



/*  */
/* *  This procedure replaces old_string with new_string for a given block of lines.
   *  The line numbers can not be changed.
   *
   *	replace	/<old string>/<new string>/ [<line list>]	(REPLACE)
   *
   *	prefix	/<old string>/<new string>/ [<line list>]	(PREFIX)
   *
   *	suffix	/<old string>/<new string>/ [<line list>]	(SUFFIX)
   *
   *		(Any character except blank or tab may be used as a delimiter)
*/
replace:	proc (replace_type);

dcl  replace_type fixed bin;

	     if parse_string_args ("0"b) then do;
		if replace_type ^= REPLACE then do;
		     length_new_string = length_new_string + length_old_string;
		     if length_new_string <= 256 then do;
			if replace_type = PREFIX then new_string = new_string || old_string;
			else new_string = old_string || new_string;
		     end;
		     else do;
			code = error_string_size;
			return;
		     end;
		end;


/*  Search through blocks of lines and replace  the string.  The new code is stored in temp_seg */

		last_index = 0;
		do k = 1 to num_blocks;
		     start_index = block (k).start;
		     block_length = block (k).end - block (k).start;
		     do while (block_length > 0);
			i = index (substr (cur_seg, start_index, block_length), old_string) -1;
			if i > - 1 then do;

/*  This check is done if old_string begins with a digit.  It searches back for the first non-digit.
   * It sets replace_OK = 1, if the replacement would not change a line number.
   *
   *	j = 0				A line number at the start of a block.
   *	j > 0 & character = new_line		The first non-digit is new_line.
   *	j > 0 & character ^= new_line		A string inside a line.
*/

			     if check then do;
				j = verify (reverse (substr (cur_seg, 1, start_index + i -1)), digit);
				if j > 0 then do;
				     if substr (cur_seg, start_index + i - j, 1) = new_line then replace_OK = "0"b;
				     else replace_OK = "1"b;
				end;
				else replace_OK = "0"b;
			     end;

			     if replace_OK then do;
				i = start_index + i - 1;
				call copy_block (last_index + 1, i);
				substr (temp_seg, temp_length +1, length_new_string) = new_string;
				temp_length = temp_length + length_new_string;
				last_index = i + length_old_string;
				block_length = block_length - last_index + start_index - 1;
				start_index = last_index + 1;
			     end;
			     else do;
				replace_OK = "1"b;
				start_index = start_index + i + length_old_string;
				block_length = block_length - i - length_old_string + 1;
			     end;
			end;
			else block_length = 0;
		     end;
		end;

		if last_index ^= 0 then do;
		     call copy_block (last_index + 1, cur_length);
		     call switch_buffers;
		end;

		else do;
		     code = error_no_string;
		     arg = old_string;
		end;

	     end;

	     return;

	end replace;

/*  */
/* *  This procedure parses the argument list for LOCATE, REPLACE, PREFIX, SUFFIX
   *
   *	/old_string/new_string/ line_list
   *
   *  If line_list is missing, LOCATE uses the entire text.  The line_list must be  present for
   *  REPLACE, PREFIX and SUFFIX.  These global variables are set:
   *
   *	old_string
   *	old_string_length
   *	new_string
   *	new_string_length
   *	num_blocks
   *	block (1, num_block)
   */
parse_string_args: proc (one_string_sw) returns (bit (1));

dcl  one_string_sw bit (1) unal;			/* ON if only one string is expected -- LOCATE */

dcl (i, j) fixed bin;
dcl  delimiter char (1);

	     i = verify (line, white_space);
	     if i > 0 then do;
		delimiter = substr (line, i, 1);
		arg = delimiter;
		j = index (substr (line, i + 1), delimiter);
		if j > 1 then do;
		     old_string = substr (line, i +1, j - 1);
		     arg = old_string;		/* for error message */
		     length_old_string = j -1;
		     i = i + j + 1;
		     if one_string_sw then line = substr (line, i);
		     else do;
			j = index (substr (line, i), delimiter);
			if j > 0 then do;
			     new_string = substr (line, i, j-1);
			     length_new_string = j -1;
			     line = substr (line, i +j);
			end;
			else code = error_delimiter_miss;
		     end;
		end;
		else if j = 1 then code = error_syntax_string;
		else code = error_delimiter_miss;
	     end;
	     else do;
		code = error_delimiter_miss;
		arg = "";
	     end;

	     if code = 0 then do;
		call parse_line_list;
		if code = 0 then do;

		     if index (digit, substr (old_string, 1, 1)) ^= 0 then check = "1"b;
		     else if index (digit, substr (new_string, 1, 1)) ^= 0 then check = "1"b;
		     else check = "0"b;
		     replace_OK = "1"b;

		     if num_blocks > 0 then return ("1"b);
		     else if request = "loc" then do;
			num_blocks = 1;
			block (1).start = 1;
			block (1).end = cur_length;
			return ("1"b);
		     end;
		     else code = error_no_num;
		end;
	     end;
	     return ("0"b);

	end parse_string_args;

/*  */
/* * This procedure removes a number followed by a blank on each line.  If there is no number present, the
   * line is copied as is.  If there is no blank following the number, just the number is removed.
   *
   *	desequence
   *
*/
desequence: proc;

	     start_index = 1;

	     do while (start_index <= cur_length & code = 0);

		i = verify (substr (cur_seg, start_index), digit) -1;
		if i > -1 then do;
		     if i > 0 then if substr (cur_seg, start_index + i, 1) = blank then i = i + 1;
		     start_index = start_index + i;

		     j = index (substr (cur_seg, start_index), new_line);
		     if j > 0 then do;
			call copy_block (start_index, start_index + j -1);
			start_index = start_index + j;
		     end;

		     else code = error_no_nl;
		end;
		else code = error_no_nl;
	     end;

	     if code = 0 then call switch_buffers;

	     return;

	end desequence;

/*  */
/* * This procedure adds a sequence number and one blank to each line.  It uses new_number for the first line
   * and adds increment to get the next line number.  The default is to start with 100 and increment
   * by 10.
   *
   *	sequence	new_number,  increment
   *
*/

sequence:	proc;

	     seq_number = 100;
	     increment = 10;

	     if parse_number (seq_number) then if parse_number (increment) then;

	     if code = 0 then do;
		if cur_length > 0 then do;

		     start_index = 1;

		     do while (start_index <= cur_length);

			i = index (substr (cur_seg, start_index), new_line);
			if i > 0 then do;
			     call ioa_$rsnnl ("^d ", string, j, seq_number);
			     if temp_length + j + i <= f.max_seg_size then do;

				substr (temp_seg, temp_length + 1, j) = string;
				temp_length = temp_length + j;
				substr (temp_seg, temp_length + 1, i) = substr (cur_seg, start_index, i);
				temp_length = temp_length + i;
				start_index = start_index + i;
				seq_number = seq_number + increment;
			     end;

			     else do;
				code = error_max_size;
				return;
			     end;
			end;
			else code = error_no_nl;
		     end;
		     if code = 0 then call switch_buffers;
		end;
		else code = error_cur_empty;
	     end;

	     return;

	end sequence;

/*  */
/*  This procedure has an optional argument list:
   *
   *	resequence  [<new number>]  [,<line_number>] [,<increment>]
   *
   *		new number	Line number to use for the resequencing.
   *		line_number	Line at which to begin resequencing.
   *		increment		Increment added each time to new_number.
   *
*/
resequence: proc;

	     call resequence_args;

	     last_index = 0;

	     if f.basic_system then do;
		call get_temp_segments_ ("fast", addr (basic_resq_tbl_ptr) -> based_arr, code);
		if code ^= 0 then return;
		num_lines = 0;

		do k = 1 to num_blocks;
		     call fill_basic_tbl (basic_resq_tbl_ptr, "0"b, block (k).start, block (k).end, seq (k).number, seq (k).incr);
		end;

		do k = 1 to num_blocks while (code = 0);

		     call copy_resq ("0"b, last_index + 1, block (k).start -1);
		     call copy_resq ("1"b, block (k).start, block (k).end);

		     last_index = block (k).end;
		end;

		if code = 0 then call copy_resq ("0"b, last_index + 1, cur_length);

	     end;

	     else do;
		do k = 1 to num_blocks while (code = 0);

		     if block (k).start > last_index then do;
			call copy_block (last_index + 1, block (k).start -1);
			call renumber (block (k).start, block (k).end, seq (k).number, seq (k).incr);
			last_index = block (k).end;
		     end;
		     else code = error_line_order;
		end;

		if code = 0 then call copy_block (last_index + 1, cur_length);

	     end;

	     if code = 0 then do;
		call switch_buffers;
		if sort then call dfast_merge_ ("1"b, edit_info_ptr, code);
	     end;

	     return;

	end resequence;

/*  */
/*  This procedure parses the user's input line for a resequence spceifcation.
   It returns "1"b if some of the block specification was found  and returns "0"b if the argument list
   is exhausted.  If errors occur code is set and "0"b is returned.

*/
resequence_args: proc ();

	     num_blocks = 0;
	     do while (code = 0);
		if parse_number (seq_number) then do;
		     if get_numbers (num_1, num_2) then do;
			if get_equal_lower_line (1, num_1, block_start, block_end) then do;
			     if block_start = 0 then block_start = 1;
			     if num_1 = num_2 then block_end = cur_length;
			     else if ^get_equal_lower_line (1, num_2, block_start, block_end) then code = error_line_miss;
			     if ^parse_number (increment) then increment = 10;

			end;
			else code = error_line_miss;
		     end;
		     else do;
			if num_blocks = 0 then block_start = 1;
			else block_start = block_end + 1;
			block_end = cur_length;
			increment = 10;
		     end;
		end;

		else do;
		     if num_blocks > 0 then return;
		     block_start = 1;
		     block_end = cur_length;
		     seq_number = 100;
		     increment = 10;
		end;

		num_blocks = num_blocks + 1;
		if num_blocks <= 16 then do;
		     block (num_blocks).start = block_start;
		     block (num_blocks).end = block_end;
		     seq (num_blocks).number = seq_number;
		     seq (num_blocks).incr = increment;
		end;
	     end;

	     return;

	end resequence_args;

/*  */
/* *  This request converts the segment into fixed record format.
   *
   *	string	<record length>
*/
string_request: proc;

dcl  bit_count fixed bin (24);
dcl  directory char (168) ;
dcl  directory_length fixed bin;
dcl  entry_name char (32) ;
dcl  iocb_ptr ptr;					/* ptr to iocb in creating blocked file */
dcl  record_length fixed bin (21);			/* length of records in new file */

dcl  cleanup condition;
dcl  hcs_$set_bc_seg entry (ptr, fixed bin (24), fixed bin (35));
dcl  hcs_$fs_get_path_name entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
dcl  hcs_$status_mins entry (ptr, fixed bin (2), fixed bin (24), fixed bin (35));
dcl  iox_$attach_ioname entry (char (*), ptr, char (*), fixed bin (35));
dcl  iox_$open entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
dcl  iox_$write_record entry (ptr, ptr, fixed bin (21), fixed bin (35));

	     arg = "";

	     if parse_number (record_length) then do;
		if record_length ^= 0 then do;
		     call hcs_$fs_get_path_name (temp_ptr, directory, directory_length, entry_name, code);
		     if code = 0 then do;
			call hcs_$set_bc_seg (temp_ptr, 0, code);
			if code ^= 0 then call dfast_error_ (code, "string","");
			num_pic = record_length;
			iocb_ptr = null;
			on cleanup call cleanup_iocb (iocb_ptr);
			call iox_$attach_ioname ("string", iocb_ptr, "vfile_ " || substr (directory, 1, directory_length)
			     || ">" || entry_name || " -blocked " || num_pic || " -ssf", code);
			if code = 0 then do;
			     call iox_$open (iocb_ptr, 5, "0"b, code);

			     start_index = 1;
			     do while (start_index <= cur_length & code = 0);
				i = index (substr (cur_seg, start_index), new_line) -1;
				if i >= 0 then do;
				     if i <= record_length then do;
					call iox_$write_record (iocb_ptr, addr (substr (cur_seg, start_index,1)),
					     i, code);
					start_index = start_index + i +1;
				     end;
				     else do;
					code = error_size_fixed_record;
					num_pic = i;
					arg = num_pic;
				     end;
				end;
				else code = error_no_nl;
			     end;
			     call cleanup_iocb (iocb_ptr);
			     if code = 0 then do;
				call hcs_$status_mins (temp_ptr, 0, bit_count, code);
				temp_length = divide (bit_count + 8, 9, 21, 0);
			     end;
			end;
		     end;
		end;

		else code = error_bad_rec_len;
	     end;
	     else code = error_bad_rec_len;

	     if code = 0 then call switch_buffers;

	     return;

	end string_request;

cleanup_iocb: proc (iocb_ptr);

dcl  iocb_ptr ptr;

dcl  code fixed bin (35);

dcl  iox_$close entry (ptr, fixed bin (35));
dcl  iox_$destroy_iocb entry (ptr, fixed bin (35));
dcl  iox_$detach_iocb entry (ptr, fixed bin (35));

%include iocb;

/*  */

	code = 0;
	     if iocb_ptr ^= null then do;
		if iocb_ptr -> iocb.open_descrip_ptr ^= null then call iox_$close (iocb_ptr, code);
		if code = 0 then do;
		     call iox_$detach_iocb (iocb_ptr, code);
		     call iox_$destroy_iocb (iocb_ptr, code);
		end;
	     end;

	     if code ^= 0 then call dfast_error_ (code, "string","");

	     return;


	end cleanup_iocb;

/*  */
/*  This procedure copies a block of characters from the current segment into the temporary segment.
   If the procedure is called with end_index > start_index no coping is done.
*/
copy_block: proc (start_index, end_index);

dcl  start_index fixed bin (21);
dcl  end_index fixed bin (21);

dcl  block_length fixed bin (21);

	     if start_index <= end_index then do;
		block_length = end_index - start_index + 1;
		if temp_length + i <= f.max_seg_size then do;
		     substr (temp_seg, temp_length + 1, block_length) =
			substr (cur_seg, start_index, block_length);
		     temp_length = temp_length + block_length;
		end;

		else code = error_max_size;
	     end;

	     return;

	end copy_block;

/*  */
/* This procedure renumbers a block of lines and copies the lines into the temporary segment.
*/
renumber:	proc (start_index, end_index, new_number, increment);

dcl  start_index fixed bin (21);
dcl  end_index fixed bin (21);
dcl  new_number fixed bin (21);
dcl  increment fixed bin (21);

dcl (i, j) fixed bin (21);

	     t_index = start_index;
	     do while (t_index <= end_index);

		line_length = index (substr (cur_seg, t_index, end_index - t_index + 1), new_line);
		if line_length > 0 then do;
		     i = verify (substr (cur_seg, t_index, line_length), digit);
		     call ioa_$rsnnl ("^d", string, j, new_number);
		     line_length = line_length - i + 1;
		     substr (temp_seg, temp_length + 1, j) = string;
		     temp_length = temp_length + j;
		     substr (temp_seg, temp_length + 1, line_length) =
			substr (cur_seg, t_index + i -1, line_length);
		     temp_length = temp_length + line_length;
		     new_number = new_number + increment;
		     t_index = t_index + line_length + i;
		end;
	     end;

	     return;

	end renumber;

/*  */
renumber_if_necessary: proc (start_index, end_index, new_number);

dcl  start_index fixed bin (21);
dcl  end_index fixed bin (21);
dcl  new_number fixed bin (21);
	     t_index = start_index;
	     do while (t_index <= end_index);
		i = verify (substr (cur_seg, t_index, end_index - t_index + 1), digit);
		if i > 1 then do;
		     num_1 = cv_dec_check_ (substr (cur_seg, t_index, i-1), code);
		     if code = 0 then do;
			line_length = index (substr (cur_seg, t_index, end_index - t_index + 1), new_line);
			if num_1 < new_number then call renumber (t_index, line_length, new_number, 1);

			else do;
			     call copy_block (t_index, end_index);
			     return;
			end;
			t_index = t_index + line_length;
		     end;
		end;
	     end;

	     return;

	end renumber_if_necessary;

/*  */
/* This procedure switches the pointers so that the temporary buffer becomes the current segment */

switch_buffers: proc;

	     f.current_ptr = temp_ptr;
	     f.current_length = temp_length;
	     f.alter_ptr = cur_ptr;

	     return;

	end switch_buffers;

/*  */
/* * The procedure parses the line for a line number or block specification.
   * There are two forms:
   *
   *	1.  One line number:  [<line>]
   *	    block_start, block_end = the index in the line.
   *
   *	2.  Block specification:   [<line> - <line>]
   *
   *	    block_start	The index of the line OR the next higher line that is <= the block_end.
   *	    block_end	The index of the end of the line OR the next lower line that is >= block_start.
   *
   *	code = 0			The line index was found.
   *	     = error_line_miss	The line could not be found.
   *	     = error_bad_line	Format error in line specification.
   */

parse_block_spec: proc (search_start, block_start, block_end) returns (bit (1));

dcl  search_start fixed bin (21);
dcl  block_start fixed bin (21);
dcl  block_end fixed bin (21);

dcl  line_start fixed bin (21);			/* beginning of line being looked at */
dcl  num_chars fixed bin (21);			/* num characters  in line */

	     arg = line;
	     if ^parse_two_numbers (num_1, num_2) then return ("0"b);

	     line_start = search_start;
	     do while (line_start <= cur_length);
		call get_line_number (line_start, num_chars, line_number);
		if num_1 <= line_number then do;
		     block_start = line_start;
		     block_end = line_start + num_chars -1;
		     if num_1 = num_2 then do;
			if num_1 = line_number then return ("1"b);
			else code = error_line_miss;
		     end;
		     if line_number <= num_2 then do;
			if get_equal_lower_line (block_end + 1, num_2, (0), block_end) then return ("1"b);
			if code = 0 then return ("1"b);
		     end;
		     else code = error_line_miss;
		     return ("0"b);
		end;
		line_start = line_start + num_chars;
	     end;

	     if code = 0 then code = error_line_miss;
	     return ("0"b);

	end parse_block_spec;

/*  */
parse_two_numbers: proc (num_1, num_2) returns (bit (1) unal);

dcl  num_1 fixed bin (21);
dcl  num_2 fixed bin (21);

	     if parse_number (num_1) then do;
		line_start = verify (line, white_space);
		if line_start > 0 then do;
		     if substr (line, line_start, 1) = "-" then do;
			if line_start < length (line) then do;
			     line = substr (line, line_start + 1);
			     if parse_number (num_2) then do;
				if num_1 > num_2 then code = error_block_spec;
			     end;
			     else code = error_block_spec;
			end;
			else code = error_block_spec;
		     end;
		     else num_2 = num_1;
		end;
		else num_2 = num_1;
	     end;
	     else return ("0"b);

	     if code = 0 then return ("1"b);

	end parse_two_numbers;


/*  */
get_equal_lower_line: proc (search_start, num, line_start, line_end) returns (bit (1) unal);

dcl  search_start fixed bin (21);
dcl  num fixed bin (21);
dcl  line_start fixed bin (21);
dcl  line_end fixed bin (21);

	     i = search_start;

	     do while (i <= cur_length);
		call get_line_number (i, j, line_number);
		if code = 0 then do;
		     if line_number > num then do;
			if i = search_start then return ("0"b);
			line_start, line_end = i -1;
			return ("1"b);
		     end;

		     else if line_number = num then do;
			line_start = i;
			line_end = i + j -1;
			return ("1"b);
		     end;
		     i = i + j;
		end;

		else return ("0"b);
	     end;

	     line_start, line_end = cur_length;

	     return ("1"b);

	end get_equal_lower_line;


/*  */
/* * This procedure parses the input line for a line number.  It returns the indices of the start and end of
   * of the line.
   *
   *	1.  The line exists:
   *		line_start	index of start of the line.
   *		line_end		index of end of the line.
   *
   *	2.  The line does not exits:
   *		line_start	the index of the end of the line which would logically preceed the
   *				missing line.
   *		line_end		= line_start
*/
find_line: proc (line_start, line_end) returns (bit (1));

dcl  line_start fixed bin (21);
dcl  line_end fixed bin (21);

	     if parse_number (num_3) then do;
		if get_equal_lower_line (1, num_3, line_start, line_end) then return ("1"b);

		else if code = 0 then do;
		     line_start, line_end = 0;
		     return ("1"b);
		end;
	     end;

	     else if code = 0 then code = error_request_miss;

	     return ("0"b);

	end find_line;

/*  */
/*  After the first number is found, a search is made for a minus sign preceeded by blanks or tabs.
   *
   *	1.  Minus sign is found:  The next item must be a valid number or an error code is returned.
   *
   *	2.  Minus sign is not found:  The first number is returned.
*/
get_numbers: proc (num_1, num_2) returns (bit (1));

dcl  num_1 fixed bin (21);
dcl  num_2 fixed bin (21);

/*  Save the current argument for an error message */

	     i = search (line, ",;");
	     if i = 0 then i = length (line);
	     arg = substr (line, 1, i);

	     if parse_number (num_1) then do;
		num_2 = num_1;
		i = verify (line, white_space);
		if i = 0 then return ("1"b);
		if substr (line, i, 1) ^= "-" then return ("1"b);

		if length (line) > i then do;
		     line = substr (line, i+1);
		     if parse_number (num_2) then return ("1"b);
		end;
		else code = error_bad_line;
	     end;

	     return ("0"b);

	end get_numbers;

/*  */
/*  This procedure parses a line in the current segment and returns its line number.

   *	code = 0		Line begins with a positive or 0 number.
   *	       no_nl	Segment does not end with a new_line.
   *	       bad_sort	Line has no number,  editing can't continue.
*/
get_line_number: proc (start, num_chars, line_number);

/* parameters */

dcl  start fixed bin (21);
dcl  num_chars fixed bin (21);
dcl  line_number fixed bin (21);


	     num_chars = verify (substr (cur_seg, start), digit) - 1;
	     if num_chars > 0 then do;
		if num_chars <= max_digits_line_num then do;
		     number_pic = 0;
		     substr (number_pic, max_digits_line_num - num_chars + 1, num_chars) =
			substr (cur_seg, start, num_chars);
		     line_number = number_pic;
		end;
		else do;
		     code = error_max_line_number;
		     arg = substr (cur_seg, start, num_chars);
		end;
	     end;
	     else code = error_bad_sort;
	     num_chars = index (substr (cur_seg, start), new_line);
	     if num_chars = 0 then code = error_no_nl;

	     return;
	end get_line_number;

/*  */
/* This procedure parses the line for a number of the form:
   *	[blank]... [<unsigned number>]
*/

parse_number: proc (num) returns (bit (1));

dcl  num fixed bin (21);

dcl (start, num_chars) fixed bin (21);
dcl  num_string char (10);

	     start = verify (line, white_space);
	     if start > 0 then do;
		num_chars = verify (substr (line, start), digit);
		if num_chars = 0 then num_chars = length (line) - start +1;
		else num_chars = num_chars -1;

		if num_chars > 0 then do;
		     if num_chars <= max_digits_line_num then do;
			num_string = substr (line, start, num_chars);
			number_pic = 0;
			substr (number_pic, max_digits_line_num - num_chars + 1, num_chars) =
			     substr (line, start, num_chars);
			num = number_pic;
			start = num_chars + start;
			if start <= length (line) then do;
			     num_chars = verify (substr (line, start), arg_delimiter);
			     if num_chars > 0 then start = start+num_chars-1;
			end;
			line = substr (line, start);
			return ("1"b);
		     end;
		     else code = error_max_line_number;
		end;

		else code = error_bad_line;
	     end;

	     return ("0"b);

	end parse_number;

/*  */
/*  This procedure parses the user input line for a pathname and copies the segment onto the end of the current
   segment.
*/

copy_seg:	proc () returns (bit (1));

	     if dfast_get_arg_ (line, arg) then do;
		call dfast_directory_ (COPY, (arg), edit_info_ptr, addr (copy_info), code);
		if code = 0 then return ("1"b);
		print_message = "0"b;
	     end;

	     return ("0"b);

	end copy_seg;


/*  */
parse_line_list: proc;

dcl  search_start fixed bin (21);			/* index in cur_seg to begin search */
dcl  last_num fixed bin (21);				/* highest number so far in the line list */

	     num_blocks = 0;
	     search_start = 1;
	     last_num = -1;

	     do while (parse_block_spec (search_start, block_start, block_end));

		if num_blocks < 16 then do;
		     if num_1 > last_num then do;
			num_blocks = num_blocks + 1;
			block (num_blocks).start = block_start;
			block (num_blocks).end = block_end;
		     end;
		     else code = error_line_order;
		end;

		else code = error_max_lines;
		if code ^= 0 then return;

		search_start = block_end + 1;
		last_num = num_2;
	     end;

	     if code = error_line_miss then if last_num > num_1 then code = error_line_order;

	     return;

	end parse_line_list;


/*  */
fill_basic_tbl: proc (table_ptr, conditional, start, end, seq_number, increment);

dcl  table_ptr ptr;					/* ptr to structure to be filled in */
dcl  conditional bit (1);				/* ON set entry only if number < seq_number */
dcl  start fixed bin (21);				/* index on current_segment of start of block being checked */
dcl  end fixed bin (21);				/* index on current_segment of end of block */
dcl  seq_number fixed bin (21);			/* new sequence number to use  */
dcl  increment fixed bin (21);			/* increment for sequence number */

dcl  index fixed bin (21);


dcl 1 tbl aligned based (table_ptr) like basic_resq_tbl;
	     index = start;

	     do while (index < end & code = 0);
		call get_line_number (index, j, line_number);
		if conditional then if line_number >= seq_number then return;
		num_lines = num_lines + 1;
		t (num_lines).old_number = line_number;
		t (num_lines).new_number = seq_number;
		seq_number = seq_number + increment;
		index = index + j;
	     end;

	     return;

	end fill_basic_tbl;

     end dfast_line_edit_;
