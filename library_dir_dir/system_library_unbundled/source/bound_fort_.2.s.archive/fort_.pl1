/* ******************************************************
   *                                                    *
   * Copyright, (C) Honeywell Limited, 1983             *
   *                                                    *
   * Copyright (c) 1972 by Massachusetts Institute of   *
   * Technology and Honeywell Information Systems, Inc. *
   *                                                    *
   ****************************************************** */

/* Created:	June 1976

   Modified:
	22 Jun 84, MM - Install typeless functions support.
	28 Mar 84, MM - Install HFP support.
	12 Jul 83, MM - 379: Add references to fort_declared and replace code
		to generate options string with a call to fort_defaults_.
	19 Jun 83, HH - 145: Add display of new 'label' node fields.
	17 Jun 83, HH - 383: Add "process_param_list" to 'op_names'.
	13 Jan 83, HH - Add "form_VLA_packed_ptr" to 'op_names' and remove
		references to the obsolete 'indirect_scan_op'.
	22 September 1982, TO - Add VLA_is_256K for shared vars.
	 7 May 82, TO - To re-compute options string to reflect '%global's.
	 7 May 82, TO - To include multiply check in options string.
	15 March 82,	TO - Add source_line_number, source_file_number.
	15 March 82,	TO - Add "on or after line 16384" message.
	2 December 81, MEP - add "round" to options string.
	24 October 81, MEP - new operator for inquire statement.
	20 October 1981, CRD - new operators for internal files.
	12 May 1981, MEP - Added two new operators for display routines: equiv and not_equiv.
	17 February 1981, CRD - Change display routines for new dimension
		node layout.
	8 January 1981, CRD - Change display routines for new bit
		label.not_referencable.
	18 December 1980, CRD - Change display routines for new bit
		opt_statement.removable.
	9 December 1980, CRD - Change display routines for three new
		operators - block_if, else_if, and else.
	1 September 1980, CRD - Change diaplay routines for new bit
		array_ref.has_address.
	18 July 1980, CRD - Change display routines for new bit 
		symbol.variable_arglist.
	19 June 1980, MEP - fort_display now prints the source statments
                    when it encounters a source node or quad.      
	7 March 1980, CRD - change multi_position bit to stack_indirect.
	29 February 1980, CRD - change options string to properly reflect
		the new default of -relocatable.
	31 January 1980, CRD - changes for new stringrange option.
	23 January 1980, CRD - changes to header node and fix offset_unit_names.
	21 December 1979, RAB - more register optimizer changes and call probe instead of debug.
	5 November 1979, RAB - change display progs for register optimizer
	19 October 1979, CRD - increase length of phase names, and always
		display octal numbers with a trailing  "o".
	5 October 1979, CRD - node changes for new EAQ scheme.
	17 September 1979, RAB - for register optimizer (node changes)
	12 September 1979, CRD - fix minor glitch in decode_source_id.
	13 August 1979, RAB - add cat_op & substr_op
	19 July 1979, RAB - change fort_display for char_mode incl file changes
	4 July 1979, RAB - have temporary.loop_end_fu_pos and header.length
			print out in decimal.
	28 Jun 1979, PES - Initialize parameter math entry arrays.
	20 Jun 1979, PES - Fix unreported bug in which QUIT/RL before parse is called caused fault.
	18 Dec 1978, PES - Make auto_zero and do_rounding the defaults for FAST, DFAST, and run units.
	09 Dec 1978, PES - Change so fort_display will show options.
	05 Dec 1978, PES - Remove kludge of Jul 31, changes for new options.
	25 Oct 1978, PES - Changes for larger common and arrays.
	25 Sep 1978, RAB - c/loop_end_fu_num/loop_end_fu_pos/ to help fix 187
	31 Jul 1978, PES - Kludge around bug in PLI compiler.
	27 Jul 1978, PES - remove references to full and simple command arguments.
	26 Jun 1978, DSL - move create_constant to fort_utilities.incl.pl1.
	26 Jan 1978, RAB - Change for loop optimizer.
	10 Jan 1978, DSL - Implement once_per_statement and once_per_subprogram for error
		messages, and control them and once_per_compilation using options.brief.
		See comments in procedure print_meessage_op.
	27 Dec 1977, DSL - implement print once per compilation for error messages.
	30 Aug 1977, DSL - implement fortran_severity_; display changes: print common
		block nodes for "dcl", print summary of polish; NOTE -- value of bias
		changed from 65536 to 131072.
	05 Jul 1977, DSL - 1) 3 new operators; 2) remove refs to block_data_subprogram.
	03 May 1977, DSL - restore timing info to old format; add trim_floating.
	28 Apr 1977, DSL - recompile for new operator, xmit_vector.
	25 Mar 1977, DSL - improve error messages, improve display prgms,
		include counts with timing info only if debugging.
	24 Feb 1977, GDC - add optimize capability.
	09 Dec 1976, DSL - new compiler_source_info.incl.pl1;
		new fort_command_structure.incl.pl1; completely rewrite display code.
	20 Oct 1976, RAB - add relocation bits, variable max_lens.
	12 Sep 1976, DSL - add listing capability, clean up display programs.
*/

/* format: style3,^delnl,linecom */
fort_:
     procedure (source_info_ptr,			/* input; pointer to source info structure */
	object_base_ptr,
						/* input; pointer to object segment */
	object_length,				/* output; word length of object segment */
	options_ptr,
						/* input; pointer to fort options structure */
	declared_ptr,				/* input; pointer to fort declared structure */
	get_next_source_seg_entry,
						/* input; routine to provide next source seg or null entry value */
	add_to_lib_list_entry,
						/* input; routine to handle lib pathnames or null entry value */
	code);
						/* output; error code */

/* PARAMETERS */

dcl	add_to_lib_list_entry
			entry variable;
dcl	code		fixed bin (35);
dcl	get_next_source_seg_entry
			entry variable;
dcl	object_base_ptr	pointer;
dcl	object_length	fixed bin (19);
dcl	options_ptr	pointer;
dcl	declared_ptr	pointer;
dcl	source_info_ptr	pointer;

/* This is the main entry point to the new fortran compiler. */

%include fort_nodes;

%include fort_opt_nodes;

%include fort_listing_nodes;

%include fort_system_constants;

dcl	1 shared_globals	structure aligned,
%include fort_shared_vars;

dcl	1 parse_globals	structure aligned,
%include fort_parse_vars;

dcl	1 cg_globals	structure aligned,
%include fort_cg_vars;
%include fort_message_table_;

%include fort_options;

dcl	1 csi		aligned based (source_info_ptr) like compiler_source_info;

%include compiler_source_info;

%include relocation_bits;

dcl	(addr, addrel, baseno, binary, bool, convert, divide, fixed, hbound, lbound, index, length, max, min, mod, null,
	ptr, rel, size, string, substr, unspec, verify)
			builtin;

dcl	cleanup		condition;

dcl	get_temp_segments_	entry (char (*), (*) ptr, fixed bin (35));
dcl	release_temp_segments_
			entry (char (*), (*) ptr, fixed bin (35));

dcl	get_temp_segment_	entry (char (*), ptr, fixed bin (35));
dcl	release_temp_segment_
			entry (char (*), ptr, fixed bin (35));

dcl	display_entries$fdisplay
			entry (ptr) external static variable;

dcl	error_table_$translation_aborted
			fixed bin (35) external static;
dcl	error_table_$translation_failed
			fixed bin (35) external static;

dcl	x		(0:operand_max_len - 1) fixed bin (35) based (operand_base);

dcl	1 polish_region	structure aligned based (polish_base),
	  2 polish_string	(0:polish_max_len - 1) fixed bin (18) aligned;

dcl	quad		(0:quad_max_len - 1) fixed bin (18) based (quadruple_base);

dcl	intermediate_base	ptr;

dcl	hash_table_size	init (211) fixed bin int static options (constant);
dcl	hash_table	(0:hash_table_size - 1) fixed bin (35) based (operand_base);

dcl	node_offset	fixed bin (18);
dcl	phase		fixed bin (18);

dcl	(
	node_ptr,
	tsegp		(10)
	)		ptr;
dcl	allocate_temp_segs	(number_of_temps) ptr based;
dcl	number_of_temps	fixed bin (18);

dcl	num_opt_segs	fixed bin (18);

dcl	i		fixed bin (18);
dcl	max_length	fixed bin (19);
dcl	(p, q)		pointer;

dcl	1 packed_ptr_st	based aligned,
	  2 packed_ptr	pointer unaligned;

dcl	1 meter_info	aligned structure,
	  2 per_phase_info	(0:7) aligned structure,
	    3 npages	fixed bin (17),
	    3 ncpu	fixed bin (52),
	    3 polish_count	fixed bin (18),
	    3 operand_count fixed bin (18),
	    3 quadruple_count
			fixed bin (18),
	    3 opt_count	fixed bin (18);

dcl	(cpu, total_cpu)	fixed bin (52);
dcl	last_phase	fixed bin (18);

dcl	last_error_subprogram
			fixed bin (18);
dcl	last_error_statement
			fixed bin (18);
dcl	begin_subprogram_errors
			fixed bin (18);
dcl	begin_statement_errors
			fixed bin (18);
dcl	msg_table_len	fixed bin (18);

dcl	1 error_msg	(200) aligned,
	  2 number	fixed bin (18),
	  2 opnd		fixed bin (18),
	  2 count		fixed bin (18),
	  2 statement	fixed bin (18);

dcl	fortran_severity_	fixed bin (35) ext static;


dcl	message_printed	bit (550) aligned init ("0"b);
dcl	produce_listing	bit (1) aligned;

dcl	(
	initialization	init (1),
	in_parse		init (2),
	in_converter	init (3),
	in_optimizer	init (4),
	in_code_generator	init (5),
	in_listing_generator
			init (6),
	in_clean_up	init (7)
	)		fixed bin int static options (constant);

dcl	phase_name	(7) char (16) aligned int static options (constant)
			init ("setup", "parse", "converter", "optimizer", "code generator", "listing", "cleanup");

dcl	date_string	char (24);
dcl	user_id		char (32) aligned;
dcl	static_user_id	char (32) varying int static init ("");

dcl	clock_		ext entry (fixed bin (71));
dcl	cu_$decode_entry_value
			entry (entry, pointer, pointer);
dcl	date_time_	ext entry (fixed bin (71), char (*));
dcl	fort_defaults_$options_string
			ext entry (ptr, char (256) varying, fixed bin (19));
dcl	get_group_id_	ext entry (char (*) aligned);
dcl	ioa_		ext entry options (variable);
dcl	ioa_$nnl		ext entry options (variable);
dcl	ioa_$rsnp		ext entry options (variable);
dcl	probe		ext entry options (variable);
dcl	hcs_$terminate_noname
			ext entry (ptr, fixed bin (35));
dcl	hcs_$usage_values	ext entry (fixed bin (17), fixed bin (52));
dcl	pl1_operators_$VLA_words_per_seg_
			fixed bin (19) ext;



/* Main entry into the new fortran compiler */

	unspec (shared_globals) = "0"b;

/* get caller's source routine or use the compiler's internal one */

	call cu_$decode_entry_value (get_next_source_seg_entry, p, q);
	if p = null
	then get_next_source_seg = get_next_source_seg_comp;
						/* use the compiler's routine */
	else get_next_source_seg = get_next_source_seg_entry;
						/* use the caller's routine */

/* get caller's lib list routine or use internal one */

	call cu_$decode_entry_value (add_to_lib_list_entry, p, q);
	if p = null
	then shared_globals.options.compile_only = "1"b;	/* use the compiler's routine */
	else do;					/* use the caller's routine */
		shared_globals.options.compile_only = "0"b;
		add_to_lib_list_run = add_to_lib_list_entry;
	     end;

/* pick up the declared fortran options */

	shared_globals.declared_options = declared_ptr -> fortran_declared;

/* set Multics/FAST switch */

	shared_globals.options.is_fast = "0"b;
	max_length = sys_info$max_seg_size;
	goto initialize;


/* entry to compile one source segment from within FAST/DFAST */

compile:
     entry (source_info_ptr,				/* input; pointer to source info structure */
	object_base_ptr,
						/* input; pointer to object segment */
	object_length,				/* output; word length of object segment */
	options_ptr,
						/* input; pointer to fort options structure */
	code);
						/* output; error code */

/* use compiler's internal routines */

	get_next_source_seg = get_next_source_seg_comp;
	unspec (shared_globals) = "0"b;
	shared_globals.options.compile_only = "1"b;
	shared_globals.options.is_fast = "1"b;		/* Multics/FAST switch */
	unspec (shared_globals.declared_options) = "0"b;
	max_length = 65536;
	goto initialize;


/* entry called by run unit man to compile source programs for execution */

compile_run:
     entry (source_info_ptr,				/* input; pointer to source info structure */
	object_base_ptr,
						/* input; pointer to object segment */
	object_length,				/* output; word length of object segment */
	options_ptr,
						/* input; pointer to fort options structure */
	get_next_source_seg_entry,
						/* input; routine to provide next source seg or null entry value */
	add_to_lib_list_entry,
						/* input; routine to handle lib pathnames or null entry value */
	code);
						/* output; error code */

/* use caller's routines */

	get_next_source_seg = get_next_source_seg_entry;
	add_to_lib_list_run = add_to_lib_list_entry;
	unspec (shared_globals) = "0"b;
	shared_globals.options.compile_only = "0"b;
	shared_globals.options.is_fast = "1"b;		/* Multics/FAST switch */
	unspec (shared_globals.declared_options) = "0"b;
	max_length = 65536;

initialize:					/*  initialize local variables and pick up the user options	*/
	if csi.version ^= compiler_source_info_version_2
	then do;
		code = error_table_$translation_aborted;
		return;
	     end;

	phase = initialization;

	shared_globals.options.user_options = options_ptr -> fortran_options;
	produce_listing = string (shared_globals.options.listing) ^= "0"b;

	if shared_globals.options.time
	then do;
		unspec (meter_info) = "0"b;		/* Initialize the metering array. */

		call hcs_$usage_values (npages (0), ncpu (0));
	     end;

	display_entries$fdisplay = fort_display;

/* derive objectname */

	if csi.given_ename = ""
	then objectname = "object";
	else if length (csi.given_ename) > 8
	then if substr (csi.given_ename, length (csi.given_ename) - 7, 8) = ".fortran"
	     then objectname = substr (csi.given_ename, 1, length (csi.given_ename) - 8);
	     else objectname = csi.given_ename;
	else objectname = csi.given_ename;

/* set date time compiled */

	call clock_ (date_time_compiled);

/* determine user id */

	if length (static_user_id) = 0
	then do;
		call get_group_id_ (user_id);

		i = index (user_id, " ") - 1;
		if i < 0
		then i = length (user_id);

		static_user_id = substr (user_id, 1, i);
	     end;

	vuser_id = static_user_id;

/* initialize global variables	*/

	num_of_lib_names, first_lib_name, last_lib_name, num_of_word_constants, first_word_constant, last_word_constant,
	     num_of_dw_constants, first_dw_constant, last_dw_constant, num_of_char_constants, first_char_constant,
	     last_char_constant, num_of_block_constants, first_block_constant, last_block_constant = 0;

	num_opt_segs = 0;

	polish_max_len, operand_max_len, quad_max_len, object_max_len = max_length;

	opt_max_len = sys_info$max_seg_size;

	next_free_temp, next_free_array_ref = 0;

	next_free_object = 0;
	next_free_opt, next_free_polish, next_free_quad = 1;
						/*   must be initialized to non-zero for the optimizer   */
	next_free_operand = hash_table_size;

	cur_statement, cur_subprogram, first_subprogram, last_subprogram = 0;

	first_entry_name, last_entry_name = 0;

	error_level, msg_table_len, begin_statement_errors, begin_subprogram_errors, incl_count, last_error_subprogram =
	     0;

	last_error_statement = -1;


/* make sure window is shut tight for cleanup handler */

	number_of_temps = 0;
	tsegp (*) = null;
	opt_base = null;


/* set up a cleanup handler */

	on cleanup
	     call clean_up;

/*  get work segments	*/

	number_of_temps = 3;			/* require at least three temp segs */

	if produce_listing
	then number_of_temps = number_of_temps + 3;	/* cref, listing_info, source_line */

	if shared_globals.options.optimize
	then number_of_temps = number_of_temps + 2;	/* quadruples & optimizer stuff */

	call get_temp_segments_ ("fort_", addr (tsegp) -> allocate_temp_segs, code);
	if code ^= 0
	then return;

/* set work area pointers and zero object length */

	intermediate_base, polish_base = tsegp (1);
	operand_base = tsegp (2);
	relocation_base = tsegp (3);
	object_base = object_base_ptr;
	object_length = 0;

/* if a listing is to be produced, set appropriate global variables */

	if produce_listing
	then do;
		cref_base = tsegp (4);		/* contains cross ref info */
		source_line_base = tsegp (5);		/* char offset for each source line */
		listing_base = tsegp (6);		/* error text and listing info nodes */

/* build node for errors before the first subprogram */

		cur_listing = listing_base;
		unspec (listing_info) = "0"b;		/* initialize */

		number_of_crefs = 0;
		next_free_listing = size (listing_info);
	     end;

/* if optimizing set up for those phases */

	if shared_globals.options.optimize
	then do;
		opt_base = tsegp (number_of_temps);	/* get last temp_base seg pointer */
		opt_base -> packed_ptr = null;
		num_opt_segs = 1;
		quadruple_base = tsegp (number_of_temps - 1);
	     end;

	call BEGIN_COMPILER_PHASE (in_parse, "0"b);

	source_line_number, source_file_number = 0;
	use_source_info = "0"b;			/* Turn off source numbers */
	call parse_source (source_info_ptr);
	source_line_number, source_file_number = 0;
	use_source_info = "0"b;			/* Turn off source numbers */

/* compute options string to reflect control arguments and '%global' cards. */

	call fort_defaults_$options_string (addr (shared_globals.options), options_string,
	     pl1_operators_$VLA_words_per_seg_);

/*  if no fatal errors in parse then invoke (optimizer and) code generator	*/

	if error_level < unrecoverable_error & ^shared_globals.options.check
	then do;



		if shared_globals.options.optimize
		then do;
			call BEGIN_COMPILER_PHASE (in_converter, (shared_globals.options.stop_after_parse));

			call converter;

			intermediate_base = quadruple_base;

			call BEGIN_COMPILER_PHASE (in_optimizer, (shared_globals.options.stop_after_parse));

			call optimizer;

			call BEGIN_COMPILER_PHASE (in_code_generator, (shared_globals.options.stop_after_parse));

			call optimizing_cg;
		     end;

		else do;
			call BEGIN_COMPILER_PHASE (in_code_generator, (shared_globals.options.stop_after_parse));

			call code_generator;
		     end;

		object_length = next_free_object;
	     end;

/* set return code and object length */

	if error_level > unrecoverable_error
	then do;
fort_abort:
		code = error_table_$translation_aborted;
		object_length = 0;
	     end;
	else if error_level = unrecoverable_error
	then do;
		code = error_table_$translation_failed;
		object_length = 0;
	     end;
	else code = 0;

/* Before a listing can be produced, all error messages must be printed. */

	call print_message_op$epilogue;		/* Prints outstanding message counts. */

/* if user requested a listing, produce it now */

	if produce_listing
	then do;
		call BEGIN_COMPILER_PHASE (in_listing_generator, (shared_globals.options.stop_after_cg));

		call listing_generator;
	     end;

/* clean up and return */

	call BEGIN_COMPILER_PHASE (in_clean_up, shared_globals.options.stop_after_cg & ^produce_listing);

	call clean_up;

	if shared_globals.options.time
	then do;
		call hcs_$usage_values (npages (hbound (per_phase_info, 1)), ncpu (hbound (per_phase_info, 1)));
		polish_count (hbound (per_phase_info, 1)) = next_free_polish;
		operand_count (hbound (per_phase_info, 1)) = next_free_operand;
		quadruple_count (hbound (per_phase_info, 1)) = next_free_quad;
		opt_count (hbound (per_phase_info, 1)) = next_free_opt;

		call date_time_ (date_time_compiled, date_string);

		call ioa_
		     (
		     "^/Segment ^a (^d lines)^/Compiled by ^a on ^a^/
Phase               CPU     %   Pages   Polish   Operand^[   Quadruple Optimizer^]"
		     , objectname, number_of_lines, compiler_name, date_string, shared_globals.options.optimize);


		total_cpu = ncpu (hbound (per_phase_info, 1)) - ncpu (0);
		last_phase = 0;

		do i = 1 to hbound (per_phase_info, 1);

/* if phase was skipped, do not print a line for it */

		     if ncpu (i) > 0
		     then do;

/* compute time for this phase */

			     cpu = ncpu (i) - ncpu (last_phase);

/* print info for this phase */

			     call ioa_ ("^15a^9.3f^6.1f^6d^9o^10o^[^11o^10o^]", phase_name (i), cpu / 1.0e6,
				100.0e0 * cpu / total_cpu, npages (i) - npages (last_phase), polish_count (i),
				operand_count (i), shared_globals.options.optimize, quadruple_count (i),
				opt_count (i));
			     last_phase = i;
			end;
		end;

/* print totals */

		call ioa_ ("TOTAL          ^9.3f^12d^/", total_cpu / 1.0e6,
		     npages (hbound (per_phase_info, 1)) - npages (0));

		if num_opt_segs > 1
		then call ioa_ ("^/^d temp segments were used by the optimizer.", num_opt_segs);

	     end;

	return;

clean_up:
     proc;

dcl	code		fixed bin (35);
dcl	i		fixed bin;
dcl	p		ptr;

	do i = 1 to shared_globals.incl_count;
	     call hcs_$terminate_noname ((shared_globals.incl_ptr (i)), code);
	end;

	code = 0;

	if opt_base ^= null & baseno (opt_base) ^= "0"b
	then do;

		do while (opt_base ^= null & baseno (opt_base) ^= "0"b);
		     p = opt_base;
		     opt_base = p -> packed_ptr;
		     call release_temp_segment_ ("fort_", p, code);
		end;

		number_of_temps = number_of_temps - 1;
	     end;

	call release_temp_segments_ ("fort_", addr (tsegp) -> allocate_temp_segs, code);
	polish_base, operand_base, quadruple_base, opt_base, object_base = null;

     end clean_up;

BEGIN_COMPILER_PHASE:
     proc (new_phase, call_probe);

dcl	new_phase		fixed bin (17);
dcl	call_probe	bit (1) aligned;


	if shared_globals.options.time
	then do;
		call hcs_$usage_values (npages (phase), ncpu (phase));
		polish_count (phase) = next_free_polish;
		operand_count (phase) = next_free_operand;
		quadruple_count (phase) = next_free_quad;
		opt_count (phase) = next_free_opt;
	     end;

	if call_probe
	then do;
		call ioa_$nnl ("^a done! pb:", phase_name (phase));
		call probe ();
	     end;

	phase = new_phase;
     end BEGIN_COMPILER_PHASE;

abort_compiler:
     proc (msg);

dcl	msg		char (*);


	call ioa_ ("Compiler Error: ^a", msg);
	goto fort_abort;
     end abort_compiler;

parse_source:
     proc (source_ptr);

dcl	source_ptr	ptr;
dcl	ext_parse		entry (ptr, ptr);

	shared_globals.create_constant = create_constant;
	shared_globals.create_char_constant = create_char_constant;
	shared_globals.print_message = print_message;
	shared_globals.get_next_temp_segment = get_next_temp_segment;

	parse_globals.source_info_ptr = source_ptr;

	if shared_globals.options.compile_only
	then parse_globals.add_to_lib_list_run = add_to_lib_list;

	parse_globals.add_to_lib_list = parse_globals.add_to_lib_list_run;

	call ext_parse (addr (shared_globals), addr (parse_globals));

     end parse_source;

converter:
     proc;

dcl	fort_converter	entry (ptr);

	call fort_converter (addr (shared_globals));

     end converter;

optimizer:
     proc;

dcl	fort_optimizer	entry (ptr);

	call fort_optimizer (addr (shared_globals));

     end optimizer;

code_generator:
     proc;

dcl	ext_code_generator	entry (ptr, ptr);

	shared_globals.create_constant = create_constant;
	shared_globals.create_char_constant = create_char_constant;
	shared_globals.print_message = print_message;

	cg_globals.print_message_op = print_message_op;
	cg_globals.create_constant_block = create_constant_block;

	call ext_code_generator (addr (shared_globals), addr (cg_globals));

     end code_generator;

optimizing_cg:
     proc;

dcl	fort_optimizing_cg	entry (ptr, ptr);

	shared_globals.create_constant = create_constant;
	shared_globals.create_char_constant = create_char_constant;
	shared_globals.print_message = print_message;

	cg_globals.print_message_op = print_message_op;
	cg_globals.create_constant_block = create_constant_block;

	call fort_optimizing_cg (addr (shared_globals), addr (cg_globals));

     end optimizing_cg;

listing_generator:
     proc;

dcl	ext_listing_generator
			entry (ptr, ptr, ptr);

	call ext_listing_generator (addr (shared_globals), addr (parse_globals), addr (cg_globals));

     end listing_generator;

%include fort_utilities;

create_char_constant:
     proc (value) returns (fixed bin (18));

dcl	value		char (*);
dcl	a_value		char (char_constant_length) aligned based (addr (string_bit_array));
dcl	cc_offset		fixed bin (18);
dcl	cc_ptr		pointer;
dcl	hash_index	fixed bin (18);

dcl	(i, j, k, which)	fixed bin (18);
dcl	mod_2_sum		bit (36) aligned;
dcl	string_bit_array	(0:255) bit (36) aligned;

dcl	mask		(3) bit (36) int static aligned
			init ("111111111000000000000000000000000000"b, "111111111111111111000000000000000000"b,
			"111111111111111111111111111000000000"b);


	char_constant_length = length (value);
	a_value = value;
	which = 3;

/* calculate the hash index for the constant */

join:
	if length (a_value) = 0
	then hash_index = 0;
	else if length (a_value) = 1
	then do;
		hash_index = binary (unspec (substr (a_value, 1, 1)) & "001111111"b, 9);
	     end;
	else do;
		mod_2_sum = "0"b;

		j = divide (length (a_value) - 1, 4, 17, 0);
		k = length (a_value) - 4 * j;

		if k ^= 4
		then string_bit_array (j) = string_bit_array (j) & mask (k);

		do i = 0 to j;
		     mod_2_sum = bool (mod_2_sum, string_bit_array (i), "0110"b);
		end;

		hash_index = mod (binary (substr (mod_2_sum, 2, 35), 35), hash_table_size);
	     end;

/* search the hash table bucket for the constant */

	cc_offset = hash_table (hash_index);
	do while (cc_offset > 0);			/* search the entire bucket */
	     cc_ptr = addr (x (cc_offset));

	     if cc_ptr -> node.node_type = char_constant_node
						/* all constants in same hash table */
	     then if cc_ptr -> char_constant.length = char_constant_length
		then if cc_ptr -> char_constant.value = a_value
		     then return (cc_offset);

	     cc_offset = cc_ptr -> node.hash_chain;	/* will point to last item in bucket. get offset of next const */
	end;

/* a new constant node must be created */

	cc_offset = create_node (char_constant_node, size (char_constant));

	if hash_table (hash_index) = 0		/* Is this the first item in this bucket? */
	then hash_table (hash_index) = cc_offset;	/* yes */
	else cc_ptr -> node.hash_chain = cc_offset;	/* no, add it to end */

	cc_ptr = addr (x (cc_offset));
	cc_ptr -> char_constant.data_type = char_mode;
	cc_ptr -> char_constant.operand_type = constant_type;
	cc_ptr -> char_constant.length = char_constant_length;
	cc_ptr -> char_constant.value = a_value;
	cc_ptr -> char_constant.is_addressable = "1"b;
	cc_ptr -> char_constant.reloc = rc_t;

	constant_count (which) = constant_count (which) + 1;

	if first_constant (which) = 0			/* is this the first char constant? */
	then first_constant (which) = cc_offset;	/* yes */
	else addr (x (last_constant (which))) -> char_constant.next_constant = cc_offset;
						/* no, add it to list */

	last_constant (which) = cc_offset;

	return (cc_offset);


create_constant_block:
     entry (pt, nwords) returns (fixed bin (18));

dcl	pt		ptr,			/* points at block of data */
	nwords		fixed bin (18);		/* length of data */

dcl	b_value		char (char_constant_length) based (pt) aligned;

	which = 4;
	char_constant_length = chars_per_word * nwords;
	a_value = b_value;
	go to join;

     end create_char_constant;

add_to_lib_list:
     proc (pathname, code);

dcl	pathname		char (*);
dcl	a_pathname	char (256) var;
dcl	code		fixed bin (35);
dcl	char_node_offset	fixed bin (18);


	a_pathname = pathname;
	code = 0;					/* No error possible, except to abort compilation. */

/*  create character constant node and/or get its offset	*/

	char_node_offset = create_char_constant (pathname);
	addr (x (char_node_offset)) -> char_constant.allocate = "1"b;
						/* Force allocation of the constant. */

/*  is the list of library names non-empty	*/

	if first_lib_name > 0
	then do;
		node_offset = first_lib_name;

/*  yes, search the library list	*/

		do while (node_offset > 0);
		     node_ptr = addr (x (node_offset));
		     if node_ptr -> library.character_operand = char_node_offset
		     then return;
		     node_offset = node_ptr -> library.next_library_node;
		end;

	     end;


/* build a new library node and thread it into the chain. */

	num_of_lib_names = num_of_lib_names + 1;

	node_offset = create_node (library_node, size (library));

	addr (x (node_offset)) -> library.character_operand = char_node_offset;

	if last_lib_name = 0
	then first_lib_name = node_offset;
	else addr (x (last_lib_name)) -> library.next_library_node = node_offset;

	last_lib_name = node_offset;

     end add_to_lib_list;

get_next_source_seg_comp:
     proc (p);

dcl	p		ptr;

	p -> compiler_source_info.input_pointer = null ();

     end get_next_source_seg_comp;

get_next_temp_segment:
     proc (seg_base, next_free) returns (ptr);

dcl	seg_base		ptr;			/* -> base of temp segment (input/output) */
dcl	next_free		fixed bin (18);		/* used for making allocations (output) */

dcl	p		ptr;
dcl	code		fixed bin (35);

	call get_temp_segment_ ("fort_", p, code);

	if code ^= 0
	then call abort_compiler ("Can't get new temp segment.");

	num_opt_segs = num_opt_segs + 1;

	p -> packed_ptr = seg_base;
	seg_base = p;
	next_free = 1;

	return (p);

     end get_next_temp_segment;

/* Message printing utilizes "cur_statement" as the address of the word      */
/* starting a statement node.  However this functionality does not work for  */
/* some messages called from "ext_parse" and perhaps other areas.  Two fields*/
/* have been added to shared_structure.incl.pl1, source_line_number, and     */
/* source_file_number.  These are used rather than the numbers from the nodes*/
/* if "use_source_info is set.				       */

print_message:
     proc options (variable, no_quick_blocks);

dcl	cu_$arg_list_ptr	entry (ptr);
dcl	cu_$arg_count	entry (fixed bin);
dcl	cu_$arg_ptr	entry (fixed bin, ptr, fixed bin, fixed bin (35));
dcl	decode_descriptor_	entry (ptr, fixed bin, fixed bin, bit (1) aligned, fixed bin, fixed bin, fixed bin);

dcl	(arg_list_ptr, arg_ptr)
			ptr;
dcl	packed		bit (1) aligned;
dcl	fixed_bin		fixed bin (18) based;
dcl	code		fixed bin (35);
dcl	(nargs, i, arg_len, a_type, ndims, size, scale)
			fixed bin (17);

dcl	(
	real_fixed_bin	init (1),
	character_string	init (21),
	char_string_varing	init (22)
	)		fixed bin int static options (constant);

dcl	bad_arg		char (12) aligned int static options (constant) init ("BAD ARGUMENT");


/*  get the number of arguments	*/

	call cu_$arg_count (nargs);
	message_structure.number_of_operands = nargs - 1;

/*  get the argument list pointer	*/

	call cu_$arg_list_ptr (arg_list_ptr);

/*  get the first argument	*/

	call cu_$arg_ptr (1, arg_ptr, arg_len, code);
	message_structure.message_number = arg_ptr -> fixed_bin;

/*  get one to three optional arguments	*/

	do i = 2 to nargs;
	     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
	     call decode_descriptor_ (arg_list_ptr, i, a_type, packed, ndims, size, scale);

	     if a_type = real_fixed_bin
	     then do;
		     message_structure.operands (i - 1).is_string = "0"b;
		     message_structure.operands (i - 1).operand_index = arg_ptr -> fixed_bin;
		end;
	     else if a_type = character_string | a_type = char_string_varing
	     then do;
		     message_structure.operands (i - 1).is_string = "1"b;
		     if a_type = character_string
		     then message_structure.operands (i - 1).string_length = arg_len;
		     else message_structure.operands (i - 1).string_length = addrel (arg_ptr, -1) -> fixed_bin;
		     message_structure.operands (i - 1).string_ptr = arg_ptr;
		end;

	     else do;				/* Bad  argument. */
		     message_structure.operands (i - 1).is_string = "1"b;
		     message_structure.operands (i - 1).string_length = length (bad_arg);
		     message_structure.operands (i - 1).string_ptr = addr (bad_arg);
		end;
	end;

	call print_message_op;

     end print_message;

print_message_op:
     proc;

dcl	(node_ptr, table_base)
			ptr;
dcl	(a_message_number, opnd)
			fixed bin (18);
dcl	(i, arg_length, noprds, new_slot, message_length, message_offset)
			fixed bin (18);

dcl	arg_string	(3) char (256) var;
dcl	arg_char_string	char (arg_length) based;

dcl	header_line	char (128) varying;

dcl	print_on_terminal	bit (1) aligned;

dcl	(a_node_type, an_error_level)
			fixed bin (4) aligned;

dcl	1 table_overlay	aligned based (table_base),
	  2 spacer	(message_offset) fixed bin,
	  2 formating_string
			char (message_length) unal;


/* First, get and validate error message number. If severity is zero or message length is
	   zero, chances are that message is not in table. Then, get its severity level. */

	a_message_number = message_structure.message_number;

	if a_message_number <= 0 | a_message_number > hbound (fort_message_table$fort_message_table.descrip, 1)
	     | fort_message_table$fort_message_table.descrip (a_message_number).level = 0
	     | fixed (fort_message_table$fort_message_table.descrip (a_message_number).length, 17) = 0
	then do;
		a_message_number = hbound (fort_message_table$fort_message_table.descrip, 1);
		message_structure.number_of_operands = 1;
		message_structure.operands (1).operand_index = message_structure.message_number - bias;
		message_structure.operands (1).is_string = "0"b;
	     end;

	an_error_level = fort_message_table$fort_message_table.descrip (a_message_number).level;

	print_on_terminal = an_error_level >= shared_globals.options.severity;
						/* Decide if user wants it online. */


/* Format the error message only if it is to be printed somewhere. */

	if print_on_terminal | produce_listing
	then do;

/* The following block of code implements restricted message printing. This is simply
		 effort to reduce the number of redundant error messages printed, without reducing
		formation available to the user. Use of the -brief control argument reduces the number
		 times a given message is printed, also.

		     Three flags control the number of times a message is printed and they are part of
		e message table entry for each error message. The flag "print_once" must be set to "1"b
		r messages that participate in this feature. Additionally, the flag "once_per_stmnt"
		 the flag "once_per_subpgm" may be "1"b. It is an error if all three are "1"b.

		     If only "print_once" is "1"b, the message is printed once per subprogram if
		rief is not specified, and once per compilation if it is. If "print_once" and
		nce_per_subpgm" are "1"b, the message is printed once per statement if -brief is not
		ecified, and once per subprogram if it is. if "print_once" and "once_per_stmnt" are
		"b, the message is always printed once per statement. */

		if fort_message_table$fort_message_table.descrip (a_message_number).print_once
		then do;

/* If match includes an operand, extract operand from current message. */

			opnd =
			     binary (fort_message_table$fort_message_table.descrip (a_message_number).saved_operand)
			     ;
			if opnd ^= 0
			then if message_structure.operands (opnd).is_string
			     then do;
				     arg_length = message_structure.operands (opnd).string_length;
				     opnd =
					create_char_constant
					((message_structure.operands (opnd).string_ptr -> arg_char_string));
				end;
			     else opnd = message_structure.operands (opnd).operand_index;

/* If previous message was from a different statement or subprogram, eliminate all messages
		     from the list that are no longer relavant. */

			if begin_statement_errors ^= 0 & last_error_statement ^= cur_statement
			then do;
				do i = begin_statement_errors to msg_table_len;
				     call print_message_summary (i, "statement");
				end;

				msg_table_len = begin_statement_errors - 1;
				begin_statement_errors = 0;
			     end;

			if begin_subprogram_errors ^= 0 & cur_subprogram ^= 0
			     & cur_subprogram ^= last_error_subprogram
			then do;
				do i = begin_subprogram_errors to msg_table_len;
				     call print_message_summary (i, "subprogram");
				end;

				msg_table_len = begin_subprogram_errors - 1;
				begin_subprogram_errors = 0;
				begin_statement_errors = 0;
			     end;

			last_error_statement = cur_statement;

/* Look new message up in the table. */

			do i = 1 to msg_table_len;
			     if a_message_number = error_msg (i).number
			     then if opnd = error_msg (i).opnd
				then do;

/* This message has already been printed. Update its count if necessary. */

					if cur_statement ^= error_msg (i).statement
					then do;	/* A new line. */
						error_msg (i).statement = cur_statement;
						error_msg (i).count = error_msg (i).count + 1;
					     end;

					else if fort_message_table$fort_message_table.descrip (a_message_number)
						.once_per_stmnt
					then error_msg (i).count = error_msg (i).count + 1;
						/* Multiple occurances on the line. */

					last_error_subprogram = cur_subprogram;
					return;
				     end;		/* message has occured before */
			end;			/* loop to look up message */

/* First time for this message, find appropriate slot. */

			if msg_table_len < hbound (error_msg, 1)
						/* Allocate a new slot if there's room, */
			then msg_table_len = msg_table_len + 1;

			else do;			/* or reuse one if there's not. */
				if begin_statement_errors = 1
				then call print_message_summary (1, "statement");
				else if begin_subprogram_errors = 1
				then call print_message_summary (1, "subprogram");
				else call print_message_summary (1, "compilation");

				do i = 2 to msg_table_len;
				     error_msg (i - 1) = error_msg (i);
				end;

				if begin_statement_errors > 0
				then begin_statement_errors = begin_statement_errors - 1;
				if begin_subprogram_errors > 0
				then begin_subprogram_errors = begin_subprogram_errors - 1;
			     end;

/* Now decide what type of message it is. */

			if fort_message_table$fort_message_table.descrip (a_message_number).once_per_stmnt
			     | (fort_message_table$fort_message_table.descrip (a_message_number).once_per_subpgm
			     & ^shared_globals.options.brief)
			then do;
				if begin_statement_errors = 0
				then begin_statement_errors = msg_table_len;
				new_slot = msg_table_len;
			     end;

			else if fort_message_table$fort_message_table.descrip (a_message_number).once_per_subpgm
				| ^shared_globals.options.brief
			then do;
				if begin_statement_errors = 0
				then new_slot = msg_table_len;

				else do;
					new_slot = begin_statement_errors;
					begin_statement_errors = begin_statement_errors + 1;

					do i = begin_statement_errors to msg_table_len;
					     error_msg (i) = error_msg (i - 1);
					end;
				     end;
				if begin_subprogram_errors = 0
				then begin_subprogram_errors = new_slot;
			     end;

			else do;
				if begin_subprogram_errors > 0
				then do;
					new_slot = begin_subprogram_errors;
					begin_subprogram_errors = begin_subprogram_errors + 1;
					if begin_statement_errors > 0
					then begin_statement_errors = begin_statement_errors + 1;

					do i = begin_subprogram_errors to msg_table_len;
					     error_msg (i) = error_msg (i - 1);
					end;
				     end;

				else if begin_statement_errors > 0
				then do;
					new_slot = begin_statement_errors;
					begin_statement_errors = begin_statement_errors + 1;

					do i = begin_statement_errors to msg_table_len;
					     error_msg (i) = error_msg (i - 1);
					end;
				     end;

				else new_slot = msg_table_len;
			     end;

			error_msg (new_slot).number = a_message_number;
			error_msg (new_slot).opnd = opnd;
			error_msg (new_slot).count = 0;
			error_msg (new_slot).statement = cur_statement;
		     end;


/* Produce a header for terminal output. */

		if print_on_terminal		/* if message to appear on the terminal */
		     & cur_subprogram ^= 0		/* and a subprogram node exisits */
		     & cur_subprogram ^= last_error_subprogram
						/* and message is for a new subprogram */
		     & (cur_subprogram ^= first_subprogram | cur_subprogram ^= last_subprogram)
						/* but not the only subprogram */
		then do;
			node_ptr = addr (x (cur_subprogram));
			if node_ptr -> subprogram.symbol ^= 0
						/* name is associated with the program unit */
			then do;
				call ioa_ ("^/^-Messages for ^a:",
				     addr (x (node_ptr -> subprogram.symbol)) -> symbol.name);

				last_error_subprogram = cur_subprogram;
			     end;
		     end;


/* expand error text if needed for listing or terminal */

		arg_string (1) = "";
		arg_string (2) = "";
		arg_string (3) = "";

		noprds = message_structure.number_of_operands;

		do i = 1 to noprds;

/* Caller can provide a character string */

		     if message_structure.operands (i).is_string
		     then do;
			     arg_length = message_structure.operands (i).string_length;
			     arg_string (i) = message_structure.operands (i).string_ptr -> arg_char_string;
			end;

/* or caller can provide a count */

		     else if message_structure.operands (i).operand_index < 0
		     then arg_string (i) = binary_to_char (bias + message_structure.operands (i).operand_index);

/* or caller can provide an operand offset */

		     else do;
			     arg_string (i) =
				identify_node (addr (x (message_structure.operands (i).operand_index)));
			end;			/* code for operand offset */
		end;				/* loop thru args */

/* get message out of error message table  */

		message_length = fixed (fort_message_table$fort_message_table.descrip (a_message_number).length, 17);
		message_offset = fixed (fort_message_table$fort_message_table.descrip (a_message_number).offset, 17);

		table_base = ptr (addr (fort_message_table$fort_message_table), 0);


/* build header string for error message */

		if an_error_level = 1
		then do;
			header_line = "WARNING ";
			header_line = header_line || binary_to_char (a_message_number);
		     end;

		else if an_error_level = max_error_level
		then do;
			header_line = "FATAL ERROR ";
			header_line = header_line || binary_to_char (a_message_number);
		     end;

		else do;
			header_line = "ERROR ";
			header_line = header_line || binary_to_char (a_message_number);
			header_line = header_line || ", severity ";
			header_line = header_line || binary_to_char ((an_error_level));
		     end;

/* add source line info, if it exists */

		header_line = header_line || decode_source_id ((cur_statement), intermediate_base, use_source_info);

/* print message on terminal if requested by user */

		if print_on_terminal
		then do;

			call ioa_ ("^/^a", header_line);
						/* print header for this error message */

/* determine if message text is necessary */

			if shared_globals.options.brief | substr (message_printed, a_message_number, 1)
			then if noprds > 0
			     then call ioa_ ("^v(^a^x^)", noprds, arg_string (1), arg_string (2), arg_string (3));
			     else ;
			else do;
				call ioa_ (formating_string, arg_string (1), arg_string (2), arg_string (3));
				substr (message_printed, a_message_number, 1) = "1"b;
			     end;

/* if debugging call probe */

			if string (shared_globals.options.system_debugging) ^= "0"b
			then do;
				call ioa_$nnl ("Calling probe:");
				call probe ();
			     end;
		     end;

/* save error text if producing a listing */

		if produce_listing
		then do;

/* Make educated guess for returned string length. Actual string may be shorter. */

			call create_listing_node (length (header_line) + 2 + message_length
			     + length (arg_string (1))
			     + length (arg_string (2)) + length (arg_string (3)));

/* Have ioa_ do the hard work for us. Just the control string is copied by compiler. */

			call ioa_$rsnp ("^/^a^/" || formating_string,
						/* control string */
			     p -> error_text.string,
						/* target string */
			     error_text_length,	/* actual length of error message */
			     header_line,
			     arg_string (1), arg_string (2), arg_string (3));
						/* substituted strings */

			call finish_listing_node;
		     end;
	     end;


	error_level = max (error_level, an_error_level);

	fortran_severity_ = error_level;

	if error_level >= max_error_level
	then goto fort_abort;
	return;


print_message_op$epilogue:
     entry;					/* Prints outstanding count information at end of compilation. */

	if begin_statement_errors > 0
	then do;
		do i = begin_statement_errors to msg_table_len;
		     call print_message_summary (i, "statement");
		end;
		msg_table_len = begin_statement_errors - 1;
	     end;

	if begin_subprogram_errors > 0
	then do;
		do i = begin_subprogram_errors to msg_table_len;
		     call print_message_summary (i, "subprogram");
		end;
		msg_table_len = begin_subprogram_errors - 1;
	     end;

	do i = 1 to msg_table_len;
	     call print_message_summary (i, "compilation");
	end;
	return;


print_message_summary:
     procedure (entry, type);				/* Procedure to print summary lines. */

dcl	entry		fixed bin (18);
dcl	lvl		fixed bin (18);
dcl	msg		fixed bin (18);
dcl	type		char (32) varying;

	if error_msg (entry).count = 0
	then return;

	msg = error_msg (entry).number;
	lvl = fort_message_table$fort_message_table.descrip (msg).level;

	if ^produce_listing & (lvl < shared_globals.options.severity)
	then return;

	if lvl = 1
	then header_line = "^/WARNING ^d";
	else header_line = "^/ERROR ^d";

	if error_msg (entry).opnd > 0
	then do;
		header_line = header_line || ", for ";
		header_line = header_line || identify_node (addr (x (error_msg (entry).opnd)));
		header_line = header_line || ",";
	     end;

	header_line = header_line || " has occurred an additional ";

	if error_msg (entry).count = 1
	then header_line = header_line || "time in this ^a.";
	else do;
		header_line = header_line || binary_to_char ((error_msg (entry).count));
		header_line = header_line || " times in this ^a.";
	     end;

	if lvl >= shared_globals.options.severity
	then call ioa_ (header_line, msg, type);

	if produce_listing
	then do;
		call create_listing_node (length (header_line) + length (type) + 3);

		call ioa_$rsnp (header_line,		/* control string */
		     p -> error_text.string,
						/* target string */
		     error_text_length,		/* actual length */
		     msg, type);
						/* substituted strings */

		call finish_listing_node;
	     end;
     end /* print_message_summary */;


create_listing_node:
     procedure (estimated_length);

dcl	estimated_length	fixed bin (18);

/* except during the parse, this routine must first find the correct listing_info node */

	if listing_info.subprogram ^= cur_subprogram
	then do;
		node_ptr = cur_listing;		/* remember current node to prevent infinite loop */
		do cur_listing = addr (listing_seg (listing_info.next))
		     repeat addr (listing_seg (listing_info.next))
		     while (cur_listing ^= node_ptr & listing_info.subprogram ^= cur_subprogram);
		end;

		if listing_info.subprogram ^= cur_subprogram
		then call abort_compiler ("Cannot find listing_info node for the current subprogram.");
	     end;

	p = addr (listing_seg (next_free_listing));	/* point to new error_text node */

	p -> error_text.length = estimated_length;
     end /* create_listing_node */;



finish_listing_node:
     procedure;

	p -> error_text.length = error_text_length;

	if last_error = 0
	then first_error = next_free_listing;
	else addr (listing_seg (last_error)) -> error_text.next = next_free_listing;

	last_error = next_free_listing;

	next_free_listing = next_free_listing + size (error_text);
     end /* finish_listing_node */;


identify_node:
     procedure (a_node_ptr) returns (char (260) varying);

dcl	a_node_ptr	ptr;

	node_ptr = a_node_ptr;
	a_node_type = node_ptr -> node.node_type;

	if a_node_type = constant_node
	then do;
		return (print_constant_value (node_ptr, "1"b));
	     end;

	else if a_node_type = char_constant_node
	then do;
		return (print_constant_value (node_ptr, "1"b));
	     end;

	else if a_node_type = temporary_node
	then return ("an expression");

	else if a_node_type = array_ref_node
	then do;
		node_ptr = addr (x (node_ptr -> array_ref.parent));
		return ("element in array " || node_ptr -> symbol.name);
	     end;

	else if a_node_type = symbol_node
	then return (node_ptr -> symbol.name);

	else if a_node_type = label_node
	then return (binary_to_char ((node_ptr -> label.name)));

	else if a_node_type = header_node
	then if node_ptr -> header.in_common
	     then return (node_ptr -> header.block_name);
	     else return ("equivalence group");

	else do;
		return ("NODE" || binary_to_char ((message_structure.operands (i).operand_index)));
	     end;
     end /* identify_node */;
     end /* print_message_op */;



binary_to_char:
     proc (value) returns (char (12) varying);

dcl	value		fixed bin (18);
dcl	output		picture "(11)-9";

	output = value;
	return (substr (output, verify (output, " ")));
     end binary_to_char;


/* If line number = 0 then output "on or after line 16384", THIS IS A SPECIAL CASE. */

decode_source_id:
     proc (stmnt_off, int_base, use_source_info) returns (char (64) varying);

dcl	stmnt_off		fixed bin (18);
dcl	int_base		ptr;
dcl	use_source_info	bit (1) aligned;

dcl	id_line		char (64) varying;
dcl	i		fixed bin (18);
dcl	1 source_id	auto unaligned like statement.source_id;

	id_line = "";

	if stmnt_off > 0
	then do;
		if int_base = polish_base
		then source_id = addr (polish_string (stmnt_off)) -> statement.source_id;
		else source_id = addr (quad (stmnt_off)) -> opt_statement.source_id;

		if source_id.line ^= "0"b | use_source_info = "1"b
		then do;
			i = binary (source_id.statement, 5);
			if use_source_info = "1"b &
			     source_line_number ^= binary (source_id.line, 14)
			then i = 0;		/* If not right statement */
			if i > 1			/* don't mention statement no. 1 explicitly */
			then do;
				id_line = id_line || " in statement ";
				id_line = id_line || binary_to_char (i);
			     end;

			if use_source_info
			then i = source_line_number;
			else i = binary (source_id.line, 14);

			if i = 0
			then
			     id_line = id_line || " on or after line 16384";
			else do;
				id_line = id_line || " on line ";
				id_line = id_line || binary_to_char (i);
			     end;

			if use_source_info
			then i = source_file_number;
			else i = binary (source_id.file, 8);

			if i ^= 0			/* only print file no for second thru nth file */
			then do;
				id_line = id_line || " of file ";
				id_line = id_line || binary_to_char (i);
			     end;
		     end;
	     end;
	else if use_source_info
	then do;					/* NO CURRENT STATEMENT */
		id_line = id_line || " on line " || binary_to_char ((source_line_number));
		if source_file_number > 0
		then id_line = id_line || " of file " || binary_to_char ((source_file_number));
	     end;
	return (id_line);
     end decode_source_id;

print_constant_value:
     procedure (n_ptr, need_hdr) returns (char (256) varying);

dcl	based_bit		bit (1) aligned based;
dcl	1 based_double	aligned based,
	  2 based_dp	float bin (63) unaligned;
dcl	based_integer	fixed bin (35) aligned based;
dcl	based_real	float bin (27) aligned based;
dcl	chars		(2) char (4) aligned;
dcl	cs		char (256) varying;
dcl	(i, j, k, l)	fixed bin (18);
dcl	ltrim		builtin;
dcl	min		builtin;
dcl	n_ptr		pointer;
dcl	need_hdr		bit (1) aligned;
dcl	node_ptr		pointer;
dcl	piece		char (24);
dcl	rtrim		builtin;
dcl	value_ptr		pointer;

	node_ptr = n_ptr;

	if node_ptr -> node.data_type <= 0 | node_ptr -> node.data_type > hbound (print_routine, 1)
	then return ("UNKNOWN DATA TYPE");

	cs = "";					/* initialize */
	value_ptr = addr (node_ptr -> constant.value);
	goto print_routine (node_ptr -> node.data_type);


print_routine (1):					/* integer */
	if need_hdr
	then cs = "integer constant ";

	cs = cs || ltrim (convert (cs, value_ptr -> based_integer));
	return (cs);


print_routine (2):					/* real */
	if need_hdr
	then cs = "real constant ";

	cs = cs || trim_floating (value_ptr, "e");
	return (cs);


print_routine (3):					/* double precision */
	if need_hdr
	then cs = "double precision constant ";

	cs = cs || trim_floating (value_ptr, "d");
	return (cs);


print_routine (4):					/* complex */
	if need_hdr
	then cs = "complex constant ";

	cs = cs || "(";
	cs = cs || trim_floating (value_ptr, "e");
	cs = cs || ", ";
	cs = cs || trim_floating (addrel (value_ptr, 1), "e");
	cs = cs || ")";
	return (cs);


print_routine (5):					/* logical */
	if need_hdr
	then cs = "logical value ";

	if value_ptr -> based_bit
	then cs = cs || ".true.";
	else cs = cs || ".false.";
	return (cs);


print_routine (6):					/* character */
	if node_ptr -> char_constant.no_value_stored
	then return ("NO VALUE STORED");

	if verify (node_ptr -> char_constant.value,
	     " !""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~") = 0
	then do;
		if need_hdr
		then cs = """";
		cs = cs || node_ptr -> char_constant.value;
		if need_hdr
		then cs = cs || """";
	     end;

	else do;
		cs = "
";
		do i = 1 to node_ptr -> char_constant.length by chars_per_word;
		     l = min (chars_per_word, node_ptr -> char_constant.length - i + 1);

		     chars (1) = substr (node_ptr -> char_constant.value, i, l);
		     chars (2) = chars (1);

		     do j = 1 to l;
			k = binary (unspec (substr (chars (2), j, 1)), 9);
			if k < 32 | k > 127		/* i.e. non-printable */
			then substr (chars (2), j, 1) = ".";
		     end;

		     call ioa_$rsnp ("^-^wo  ^a", piece, k, unspec (chars (1)), substr (chars (2), 1, l));
		     if l < chars_per_word
		     then substr (piece, l * 3 + 2, (chars_per_word - l) * 3) = " ";

		     if length (cs) + k > 256
		     then do;
			     call ioa_ ("^/String too long for format.");
			     cs = substr (cs, 1, length (cs) - 1);
						/* remove final newline char */
			     call ioa_ (cs);
			     cs = "
";
			end;

		     cs = cs || substr (piece, 1, k);
		end;

		cs = substr (cs, 1, length (cs) - 1);	/* remove final newline char */
	     end;
	return (cs);



trim_floating:
     proc (fpn_ptr, expon_char) returns (char (36) varying);


dcl	expon_char	char (1) aligned;
dcl	fpn_ptr		ptr;

dcl	assign_		entry (ptr, fixed bin, fixed bin (35), ptr, fixed bin, fixed bin (35));

dcl	fpn_prec		fixed bin (35);
dcl	fpn_type		fixed bin;
dcl	ret_value		char (36) varying;
dcl	temp		char (36) varying;
%include std_descriptor_types;

	if expon_char = "d"
	then do;
		fpn_prec = 63;
		if shared_globals.options.hfp
		then fpn_type = ft_hex_double_dtype;
		else fpn_type = ft_double_dtype;
	     end;
	else do;
		fpn_prec = 27;
		if shared_globals.options.hfp
		then fpn_type = ft_hex_real_dtype;
		else fpn_type = ft_real_dtype;
	     end;
	call assign_ (addr (temp), 2 * varying_char_dtype, maxlength (temp), fpn_ptr, 2 * fpn_type + 1, fpn_prec);
	temp = ltrim (rtrim (temp));			/* trim off all blanks */

/* trim off low order zeroes */

	if substr (temp, 1, 1) = "0"
	then ret_value = rtrim (substr (temp, 1, length (temp) - 5), "0");
						/* all digits are significant */
	else ret_value = rtrim (substr (temp, 1, length (temp) - 6), "0");
						/* last digit is really noise */

	if substr (ret_value, length (ret_value), 1) = "."
	then ret_value = ret_value || "0";

	if substr (temp, length (temp) - 4, 5) ^= "e+000" /* convert exponent if not zero */
	then do;
		temp = substr (temp, length (temp) - 4, 5);
						/* makes the rest easier to read */

		ret_value = ret_value || expon_char;	/* get proper character */
		ret_value = ret_value || substr (temp, 2, 1);
						/* exponent sign */
		if substr (temp, 3, 1) ^= "0"
		then ret_value = ret_value || substr (temp, 3, 3);
		else if substr (temp, 4, 1) ^= "0"
		then ret_value = ret_value || substr (temp, 4, 2);
		else ret_value = ret_value || substr (temp, 5, 1);
						/* exponent value */
	     end;

	return (ret_value);
     end /* trim_floating */;
     end print_constant_value;

fort_display:
     proc (command_structure_ptr);


/* Operator Names */
declare	count_array	(-3:109) fixed bin (18),	/* must have same upper bound as op_names */
	op_names		(-3:109) char (20) aligned int static options (constant)
			initial (/* WARNING - change "count_array" */ "quadruple", "operand", "count", "zero",
			"assign",
			"add", "sub", "mult", "div", "exponentiation", "negate", "less", "less_or_equal", "equal",
			"not_equal", "greater_or_equal", "greater", "or", "and", "not", "jump", "jump_logical",
			"jump_arithmetic", "jump_computed", "jump_assigned", "assign_label", "read", "write",
			"format",
			"end_label", "error_label", "xmit_scalar", "xmit_array", "xmit_vector", "endfile", "rewind",
			"backspace", "margin", "openfile", "closefile", "record_number", "string", "string_length",
			"terminate", "return", "pause", "stop", "item", "exit", "eol", "do", "builtin", "sf",
			"sf_def",
			"subscript", "func_ref", "block_data", "increment_polish", "main", "function", "subroutine",
			"stat", "label", "call", "chain", "endunit", "non_executable", "no_op",
			"form_VLA_packed_ptr",
			"opt_subscript", "left_shift", "right_shift", "store_zero", "storage_add", "storage_sub",
			"neg_storage_add", "storage_add_one", "namelist", "open", "close", "iostat",
			"convert_to_int",
			"convert_to_real", "convert_to_dp", "convert_to_cmpx", "read_scalar", "read_array",
			"read_vector", "write_scalar", "write_array", "write_vector", "jump_true", "jump_false",
			"sub_index", "loop_end", "read_namelist", "write_namelist", "decode_string",
			"encode_string",
			"cat", "substr", "load_xreg", "load_preg", "block_if", "else_if", "else", "equiv",
			"not_equiv", "read_internal_file", "write_internal_file", "inquire", "process_param_list",
			"lhs_fld");


dcl	node_names	(0:15) char (24)
			init ("filler", "source", "symbol", "dimension", "temporary", "constant", "label", "header",
			"character constant", "array_ref", "proc_frame", "library", "subprogram", "arg_desc",
			"pointer",
			"machine_state") int static options (constant);



dcl	node_size		(0:15) fixed bin (18);

	node_size (0) = 1;				/* filler */
	node_size (1) = 0;				/* source */
	node_size (2) = 0;				/* symbol */
	node_size (3) = 0;				/* dimension */
	node_size (4) = size (temporary);		/* temporary */
	node_size (5) = size (constant);		/* constant */
	node_size (6) = size (label);			/* label */
	node_size (7) = 0;				/* header */
	node_size (8) = 0;				/* character constant */
	node_size (9) = size (array_ref);		/* array ref */
	node_size (10) = 12;			/* proc frame */
	node_size (11) = size (library);		/* library */
	node_size (12) = size (subprogram);		/* subprogram */
	node_size (13) = 0;				/* arg desc */
	node_size (14) = size (pointer);		/* pointer */
	node_size (15) = size (machine_state);		/* machine_state */



dcl	mode_names	(0:7) char (24)
			init ("undefined", "integer", "real", "double precision", "complex", "logical", "character",
			"typeless")
			int static options (constant);



dcl	operand_names	(0:12) char (24)
			init ("undefined", "variable", "constant", "array reference", "temporary", "count",
			"relative constant", "bif", "statement function", "external", "entry", "dummy", "error")
			int static options (constant);

dcl	offset_unit_names	(0:7) character (16)
			initial ("word_units", "bit_units", "char_units", "halfword_units",
			"UNUSED", "UNUSED", "UNUSED", "UNUSED")
			int static options (constant);

dcl	subr_type		(0:3) char (12) int static options (constant)
			init ("main program", "block data  ", "subroutine  ", "function    ");

dcl	(
	all_fields	init ("1"b),
	(just_name, dont_walk)
			init ("0"b)
	)		bit (1) aligned int static options (constant);

dcl	ons		char (256) varying;
dcl	source_segment	character (csi.input_lng) based (csi.input_pointer);
dcl	stat_start	fixed binary (27);
dcl	stat_length	fixed binary (9);
dcl	cs		ptr;
dcl	sp		ptr;

dcl	first_time	bit (1) aligned;

dcl	n		fixed bin (18),
	nodetype		fixed bin (18),
	offset		fixed bin (18);

dcl	command_structure_ptr
			ptr;
dcl	i		fixed bin (18);
dcl	(subp, next_one, item)
			fixed bin (18);

dcl	1 command_structure structure aligned based (command_structure_ptr),
%include fort_command_structure;

/* display polish for the current statement */

	if command_structure.cur_stmnt
	then do;
		if cur_statement < 0		/* no current statement */
		then do;
			call ioa_ ("cur_statement = ^oo", cur_statement);
			return;
		     end;

		if intermediate_base = polish_base
		then do;
			if polish_string (cur_statement) ^= stat_op
						/* cur_statement does not point to correct polish */
			then do;
				call ioa_ ("cur_statement = ^oo", cur_statement);
				call display_int_text ((cur_statement), (cur_statement));
				return;
			     end;

/* Get offset of last polish word. If next statement exists, last polish word
		   is one less than next statement's first word. If next does not exist, this
		   is last statement of a subprogram or the last statement parsed so far. It is
		   the last statement parsed if subprogram.last_polish is still zero. */

			offset = binary (addr (polish_string (cur_statement)) -> statement.next, 18) - 1;

			if offset < 0
			then if addr (x (cur_subprogram)) -> subprogram.last_polish = 0
			     then offset = next_free_polish - 1;
			     else offset = addr (x (cur_subprogram)) -> subprogram.last_polish;

			call display_int_text ((cur_statement), (offset));
		     end;

		else do;
			sp = addr (quad (cur_statement));

			if sp -> opt_statement.op_code ^= stat_op
			then do;
				call ioa_ ("cur_statement = ^oo", cur_statement);
				call display_quadruples ((cur_statement), (cur_statement));
				return;
			     end;

			offset = binary (sp -> opt_statement.next, 18);

			if offset > 0
			then offset = addr (quad (offset)) -> opt_statement.prev_operator;

			call display_quadruples ((cur_statement), (offset));
		     end;
	     end;


/* display all polish for all statements whose line number is "starting_offset" */

	if command_structure.stmnt & ^region.quadruple
	then do;
		first_time = "1"b;			/* to get into the inner loop the first time */

		do subp = first_subprogram repeat cs -> subprogram.next_subprogram while (subp > 0);
		     cs = addr (x (subp));

		     do item = cs -> subprogram.first_polish repeat next_one while (item > 0 | first_time);
			sp = addr (polish_string (item));
			next_one = binary (sp -> statement.next, 18);

			if binary (sp -> statement.line, 18) = starting_offset
			then do;

/* Get offset of last polish word. If next statement exists, last polish word
			   is one less than next statement's first word. If next does not exist, this
			   is last statement of a subprogram or the last statement parsed so far. It is
			   the last statement parsed if subprogram.last_polish is still zero. */

				offset = next_one - 1;

				if offset < 0
				then if cs -> subprogram.last_polish = 0
				     then offset = next_free_polish - 1;
				     else offset = cs -> subprogram.last_polish;

				call display_int_text ((item), (offset));
			     end;

			first_time = "0"b;
		     end;

		end;

		call ioa_ ("Search for line ^d completed.", starting_offset);
	     end;

/* display all quads for all statements whose line number is starting_offset */

	if command_structure.stmnt & region.quadruple
	then do;
		do subp = first_subprogram repeat cs -> subprogram.next_subprogram while (subp > 0);
		     cs = addr (x (subp));

		     do item = cs -> subprogram.first_quad repeat next_one while (item > 0);
			sp = addr (quad (item));
			next_one = binary (sp -> opt_statement.next, 18);

			if binary (sp -> opt_statement.line, 18) = starting_offset
			then do;
				if next_one > 0
				then offset = addr (quad (next_one)) -> opt_statement.prev_operator;
				else offset = next_one;

				call display_quadruples ((item), (offset));
			     end;
		     end;
		end;

		call ioa_ ("Search for line ^d completed.", starting_offset);
	     end;


/* display all symbols whose name is specified in "dcl_name" */

	if command_structure.declaration
	then do;
						/* look thru entire operand region */

		do offset = hash_table_size repeat offset + get_node_size (node_ptr)
		     while (offset < next_free_operand);

		     node_ptr = addr (x (offset));

		     if node_ptr -> node.node_type = symbol_node
		     then if node_ptr -> symbol.name = dcl_name
			then call display_node ((offset), ^command_structure.brief, (command_structure.walk));

		     if node_ptr -> node.node_type = header_node
		     then if node_ptr -> header.in_common
			then if node_ptr -> header.block_name = dcl_name
			     then call display_node ((offset), ^command_structure.brief, (command_structure.walk));
		end;

		call ioa_ ("Search for symbol ^a completed.", dcl_name);
	     end;


/* display a portion of the operand region or the polish region */

	if command_structure.display
	then do;
		if region.operand
		then do;
			offset = max (starting_offset, hash_table_size);
			stopping_offset = max (stopping_offset, offset);

			do while (offset <= stopping_offset);
			     call display_node ((offset), ^command_structure.brief, (command_structure.walk));
			     offset = offset + get_node_size (addr (x (offset)));
			end;
		     end;

		else if region.polish
		then call display_int_text ((starting_offset), (stopping_offset));

		else if region.quadruple
		then call display_quadruples ((starting_offset), (stopping_offset));

		else do;
			call ioa_ ("polish- ^p, operand- ^p, object- ^p", polish_base, operand_base, object_base);
		     end;
	     end;


/* dump an entire region */

	if command_structure.dump
	then do;

		if region.operand
		then do offset = hash_table_size repeat offset + get_node_size (addr (x (offset)))
			while (offset < next_free_operand);
			call display_node ((offset), ^command_structure.brief, dont_walk);
		     end;

		if region.polish
		then call display_int_text (1, next_free_polish - 1);

		else if region.quadruple
		then do subp = first_subprogram repeat cs -> subprogram.next_subprogram while (subp > 0);
			cs = addr (x (subp));
			call display_quadruples ((cs -> subprogram.first_quad), 0);
		     end;

	     end;


/* display all known numeric and logical constants */

	if command_structure.list_word_consts
	then do;

		do offset = first_word_constant repeat addr (x (offset)) -> constant.next_constant while (offset > 0);
		     call display_node ((offset), ^command_structure.brief, dont_walk);
		end;

		do offset = first_dw_constant repeat addr (x (offset)) -> constant.next_constant while (offset > 0);
		     call display_node ((offset), ^command_structure.brief, dont_walk);
		end;

		if first_word_constant = 0 & first_dw_constant = 0
		then call ioa_ ("No numeric or logical constants.");
	     end;


/* display all known character constants */

	if command_structure.list_char_constants
	then if first_char_constant = 0
	     then call ioa_ ("No character constants.");
	     else do offset = first_char_constant repeat addr (x (offset)) -> char_constant.next_constant
		     while (offset > 0);

		     call display_node ((offset), ^command_structure.brief, dont_walk);
		end;


/* display all character constants on library chain */

	if command_structure.list_lib_names
	then if first_lib_name = 0
	     then call ioa_ ("No library names.");
	     else do offset = first_lib_name repeat addr (x (offset)) -> library.next_library_node while (offset > 0);

		     call display_node ((addr (x (offset)) -> library.character_operand), ^command_structure.brief,
			dont_walk);
		end;


/* count nodes in operand region */

	if command_structure.node_summary
	then do;
		unspec (count_array) = "0"b;

		call ioa_ ("^/^-  #^-Node^/");

		do n = hash_table_size repeat n + get_node_size (node_ptr) while (n < next_free_operand);
		     node_ptr = addr (x (n));
		     nodetype = node_ptr -> node.node_type;

		     count_array (nodetype) = count_array (nodetype) + 1;
		end;

		do n = 0 to hbound (node_names, 1);
		     if count_array (n) > 0
		     then call ioa_ ("^-^5d ^a", count_array (n), node_names (n));
		end;

		unspec (count_array) = "0"b;

		call ioa_ ("^/^-  #^-Operator/Operand^/");

		i = 1;
		do while (i < next_free_polish);

		     n = polish_string (i);
		     i = i + 1;

		     if n < 0
		     then count_array (-1) = count_array (-1) + 1;
						/* a count */

		     else if n = 0
		     then count_array (0) = count_array (0) + 1;
						/* a zero */

		     else if n <= hbound (op_names, 1)
		     then do;
			     count_array (n) = count_array (n) + 1;
						/* an operator */

			     if n = stat_op
			     then i = i + size (statement) - 1;

			     else if n = increment_polish_op
			     then i = i + polish_string (i) + 1;
			end;

		     else count_array (-2) = count_array (-2) + 1;
						/* an operand */
		end;

		do i = lbound (op_names, 1) to hbound (op_names, 1);

		     if count_array (i) > 0
		     then call ioa_ ("^-^5d ^a", count_array (i), op_names (i));
		end;
	     end;


/* display all subprogram nodes */

	if command_structure.list_subprograms
	then do offset = first_subprogram repeat addr (x (offset)) -> subprogram.next_subprogram while (offset > 0);
		call display_node ((offset), ^command_structure.brief, (command_structure.walk));
	     end;


/* display specified buckets in all subprograms */

	if command_structure.bucket
	then do;
		starting_offset = max (1, starting_offset);
		stopping_offset = min (stopping_offset, hbound (node_ptr -> subprogram.storage_info, 1));

		do subp = first_subprogram repeat cs -> subprogram.next_subprogram while (subp > 0);
		     cs = addr (x (subp));

		     first_time = "1"b;		/* only print info if a bucket is found */

		     do i = starting_offset to stopping_offset;
			offset = cs -> subprogram.storage_info (i).first;

			if offset ^= 0
			then do;
				if first_time
				then call display_node ((subp), just_name, dont_walk);
				first_time = "0"b;
				call ioa_ ("^/Bucket ^d", i);
			     end;

			do while (offset > 0);
			     call display_node ((offset), just_name, dont_walk);
			     offset = addr (x (offset)) -> node.next;
			end;			/* loop thru a single bucket chain */
		     end;				/* loop thru a subprogram's buckets */
		end;				/* loop thru subprograms */

		call ioa_ ("Search for buckets ^d thru ^d completed.", starting_offset, stopping_offset);
	     end;

abort_display:
	return;

display_int_text:
     proc (start, stop);				/* displays a portion of the polish string */

dcl	(an_offset, content)
			fixed bin (18);
dcl	(start, stop)	fixed bin (18);
dcl	op_ptr		ptr;

	an_offset = start;

	do while (an_offset <= stop);

	     content = polish_string (an_offset);
	     an_offset = an_offset + 1;		/* move to next polish word */

	     if content < 0				/* COUNT */
	     then call ioa_ ("^/COUNT: ^d", content + bias);

	     else if content = 0			/* ZERO */
	     then call ioa_ ("^/ZERO");

	     else if content <= hbound (op_names, 1)	/* printable OPERATOR */
	     then do;
		     call ioa_ ("^/OPERATOR @ ^oo: ^a", an_offset - 1, op_names (content));

		     if content = stat_op
		     then do;
			     op_ptr = addr (polish_string (an_offset - 1));
			     stat_start = binary (op_ptr -> statement.start, 26);
			     stat_length = binary (op_ptr -> statement.length, 9);

			     call ioa_ ("^4x^a start ^d, length ^d,  next ^oo, obj ^oo",
				decode_source_id (an_offset - 1, polish_base, "0"b), stat_start,
				stat_length, binary (op_ptr -> statement.next, 18),
				binary (op_ptr -> statement.location, 18));

			     if op_ptr -> statement.put_in_profile
			     then call ioa_ ("^5xPut in profile.");
			     else if op_ptr -> statement.put_in_map
			     then call ioa_ ("^5xPut in map.");
			     else call ioa_ ("^5xNot in map or profile.");
			     call ioa_ ("^/^5x^a", substr (source_segment, stat_start + 1, stat_length));
			     an_offset = an_offset + size (statement) - 1;
						/* stat_op is more than one word long */
			end;

		     else if content = increment_polish_op
		     then do;
			     if command_structure.walk
			     then call dump_words (addr (polish_string (an_offset + 1)), polish_string (an_offset));

			     an_offset = an_offset + polish_string (an_offset) + 1;
						/* skip over data words */
			end;
		end;				/* printable operator */

	     else if content < hash_table_size		/* unknown OPERATOR */
	     then call ioa_ ("^/OPERATOR @ ^oo: ^d", an_offset - 1, content);

	     else if content < next_free_operand	/* OPERAND */
	     then call display_node ((content), just_name, dont_walk);

	     else call ioa_ ("^/VALUE: ^wo", content);
	end;

     end display_int_text;

dump_words:
     proc (a_base, a_count);

dcl	a_base		ptr;
dcl	a_count		fixed bin (18);
dcl	bp		ptr;
dcl	(count, i)	fixed bin (18);
dcl	w		(4) bit (36) aligned based;

	bp = a_base;
	count = a_count;

	do i = 0 to count - 1 by 4;
	     call ioa_ ("^12oo:^v(^x^wo^)", binary (rel (bp), 18), min (4, count - i), bp -> w);
	     bp = addrel (bp, 4);
	end;
     end /* dump_words */;

get_node_size:
     proc (pt) returns (fixed bin (18));

dcl	(p, pt)		ptr;
dcl	node_type		fixed bin (18);
dcl	currentsize	builtin;

	p = pt;
	node_type = p -> node.node_type;

	if node_type < 0 | node_type > hbound (node_size, 1)
	then do;
unknown_node:
		call ioa_ ("Compiler error: Unknown node ^d at ^p to ""get_node_size"".", node_type, p);
		goto abort_display;
	     end;

	if node_size (node_type) ^= 0
	then return (node_size (node_type));

	if node_type = symbol_node
	then do;
		return (currentsize (p -> symbol));
	     end;

	if node_type = header_node
	then do;
		return (currentsize (p -> header));
	     end;

	if node_type = char_constant_node
	then do;
		if p -> char_constant.no_value_stored
		then char_constant_length = 0;
		else char_constant_length = p -> char_constant.length;

		return (size (char_constant));
	     end;

	if node_type = dimension_node
	then return (currentsize (p -> dimension));

	if node_type = source_node
	then return (size (source) - divide (256 - length (p -> source.pathname), 4, 17, 0));

	if node_type = arg_desc_node
	then do;
		return (currentsize (p -> arg_desc));
	     end;

	goto unknown_node;
     end get_node_size;

display_node:
     proc (an_offset, dump_sw, walk_sw);

dcl	a_node_type	fixed bin (18);
dcl	an_offset		fixed bin (18);
dcl	chain		fixed bin (18);
dcl	dump_sw		bit (1) aligned;
dcl	eaq_names		(0:17) char (8) aligned int static options (constant)
			init ("EMPTY", "Q", "A", "AQ", "EAQ", "DEAQ", "IEAQ", "IQ", "IND", "INVALID", "TZE", "TNZ",
			"TMI", "TPL", "TMOZ", "TPNZ", "TNC", "TRC");
dcl	eaq_regs		(4) char (4) aligned int static options (constant)
			init ("A", "Q", "EAQ", "IND");
dcl	everything	bit (1) aligned;
dcl	(ft, ls, nx)	fixed bin (18);
dcl	node_offset	fixed bin (18);
dcl	node_ptr		ptr;
dcl	prt_sw		bit (1) aligned;
dcl	walk_chains	bit (1) aligned;
dcl	walk_sw		bit (1) aligned;
dcl	i		fixed bin;

/* copy input arguments */

	node_offset = an_offset;
	everything = dump_sw;
	walk_chains = walk_sw | ^everything;		/* make sure brief means BRIEF!! */

/* validate our input */

	if node_offset < hash_table_size | node_offset >= next_free_operand
	then do;
		call ioa_ ("Operand offset ^oo is not valid.", node_offset);
		return;
	     end;

	node_ptr = addr (x (node_offset));

	a_node_type = node_ptr -> node.node_type;

	if a_node_type >= 0 & a_node_type <= hbound (node_names, 1)
	then call ioa_ ("^/^a NODE: ^oo", node_names (a_node_type), node_offset);
	else do;
unknown_node:
		call ioa_ ("^/unknown NODE ^d: ^oo", a_node_type, node_offset);
		return;
	     end;

	goto output_node (a_node_type);


output_node (0):					/* FILLER */
	if x (an_offset) ^= 0
	then call ioa_ ("^/^5x^wo", x (an_offset));
	return;


output_node (1):					/* SOURCE */
	if ^everything
	then return;

	call ioa_ ("^/^5xuid: ^wo, dtm: ^oo^/^5xnext: ^oo, subprogram: ^oo^/^5xpath: ^a", node_ptr -> source.uid,
	     node_ptr -> source.dtm, node_ptr -> source.next, node_ptr -> source.initial_subprogram,
	     node_ptr -> source.pathname);
	return;


output_node (2):					/* SYMBOL */
	call ioa_ ("^2xoperand type: ^a, data type: ^a, name: ^a", operand_names (node_ptr -> node.operand_type),
	     mode_names (node_ptr -> node.data_type), node_ptr -> symbol.name);

	if ^everything
	then return;

	call get_addressing_attributes;

/* special SYMBOL addressing attributes */

	if node_ptr -> symbol.initialed
	then ons = ons || "initialed ";
	if node_ptr -> symbol.variable_arglist
	then ons = ons || "variable_arglist ";
	if node_ptr -> symbol.dummy_arg
	then ons = ons || "dummy_arg ";
	if node_ptr -> symbol.variable_extents
	then ons = ons || "variable_extents ";
	if node_ptr -> symbol.needs_descriptors
	then ons = ons || "needs_descriptors ";
	if node_ptr -> symbol.put_in_symtab
	then ons = ons || "put_in_symtab ";
	if node_ptr -> symbol.by_compiler
	then ons = ons || "by_compiler ";

	if node_ptr -> symbol.aliasable
	then ons = ons || "aliasable ";
	if node_ptr -> symbol.has_constant_value
	then ons = ons || "has_constant_value ";
	if node_ptr -> symbol.new_induction_var
	then ons = ons || "new_induction_var ";

	if node_ptr -> symbol.integer
	then ons = ons || "integer ";
	if node_ptr -> symbol.real
	then ons = ons || "real ";
	if node_ptr -> symbol.double_precision
	then ons = ons || "double_precision ";
	if node_ptr -> symbol.complex
	then ons = ons || "complex ";
	if node_ptr -> symbol.logical
	then ons = ons || "logical ";
	if node_ptr -> symbol.character
	then do;
		ons = ons || "character(";
		ons = ons || binary_to_char (node_ptr -> symbol.char_size + 1);
		ons = ons || ") ";
	     end;
	if node_ptr -> symbol.label_value
	then ons = ons || "label_value ";
	if node_ptr -> symbol.entry_value
	then ons = ons || "entry_value ";
	if node_ptr -> symbol.function
	then ons = ons || "function ";
	if node_ptr -> symbol.subroutine
	then ons = ons || "subroutine ";
	if node_ptr -> symbol.entry_point
	then ons = ons || "entry_point ";
	if node_ptr -> symbol.external
	then ons = ons || "external ";
	if node_ptr -> symbol.builtin
	then do;
		ons = ons || "builtin(";
		ons = ons || binary_to_char ((node_ptr -> symbol.char_size));
		ons = ons || ") ";
	     end;
	if node_ptr -> symbol.stmnt_func
	then do;
		ons = ons || "stmnt_func(";
		ons = ons || binary_to_char ((node_ptr -> symbol.char_size));
		ons = ons || ") ";
	     end;
	if node_ptr -> symbol.namelist
	then ons = ons || "namelist ";
	if node_ptr -> symbol.dimensioned
	then ons = ons || "dimensioned ";
	if node_ptr -> symbol.automatic
	then ons = ons || "automatic ";
	if node_ptr -> symbol.static
	then ons = ons || "static ";
	if node_ptr -> symbol.in_common
	then ons = ons || "in_common ";
	if node_ptr -> symbol.equivalenced
	then ons = ons || "equivalenced ";
	if node_ptr -> symbol.parameter
	then ons = ons || "parameter ";
	if node_ptr -> symbol.constant
	then ons = ons || "constant ";
	if node_ptr -> symbol.named_constant
	then ons = ons || "named_constant ";
	if node_ptr -> symbol.variable
	then ons = ons || "variable ";
	if node_ptr -> symbol.in_equiv_stmnt
	then ons = ons || "in_equiv_stmnt ";
	if node_ptr -> symbol.star_extents
	then ons = ons || "star_extents ";
	if node_ptr -> symbol.descriptor
	then ons = ons || "descriptor ";

	call print_common_fields ("hash_chain");

	if node_ptr -> symbol.location ^= 0
	then call ioa_ ("^5xlocation: ^oo", node_ptr -> symbol.location);

	if node_ptr -> symbol.loop_ref_count ^= 0
	then call ioa_ ("^5xloop_ref_count: ^d", node_ptr -> symbol.loop_ref_count);

	if node_ptr -> symbol.element_size ^= 0
	then call ioa_ ("^5xelement_size: ^oo", node_ptr -> symbol.element_size);

	if node_ptr -> symbol.offset ^= 0
	then call ioa_ ("^5xoffset: ^oo", node_ptr -> symbol.offset);

	if node_ptr -> symbol.general ^= 0
	then call ioa_ ("^5xgeneral: ^oo", node_ptr -> symbol.general);

	if node_ptr -> symbol.parent ^= 0
	then call ioa_ ("^5xparent: ^oo", node_ptr -> symbol.parent);

	if node_ptr -> symbol.next_member ^= 0
	then call ioa_ ("^5xnext_member: ^oo", node_ptr -> symbol.next_member);

	if node_ptr -> symbol.v_length ^= 0
	then call ioa_ ("^5xv_length: ^oo", node_ptr -> symbol.v_length);

	if node_ptr -> symbol.dimension ^= 0
	then do;
		call ioa_ ("^5xdimension: ^oo", node_ptr -> symbol.dimension);
		if walk_chains
		then call display_node ((node_ptr -> symbol.dimension), all_fields, dont_walk);
	     end;

	if node_ptr -> symbol.initial ^= 0
	then do;
		call ioa_ ("^5xinitial: ^oo", node_ptr -> symbol.initial);
		if walk_chains & ^node_ptr -> symbol.namelist
		then do chain = node_ptr -> symbol.initial repeat polish_string (chain) while (chain > 0);
			call ioa_ ("^5x^5d * (^oo): ^a", polish_string (chain + 1), polish_string (chain + 2),
			     print_constant_value (addr (x (polish_string (chain + 2))), "1"b));
		     end;
	     end;

	if node_ptr -> symbol.runtime ^= "0"b
	then call ioa_ ("^5xruntime: ^oo", node_ptr -> symbol.runtime);

	if node_ptr -> symbol.coordinate ^= 0
	then call ioa_ ("^5xcoordinate: ^d", node_ptr -> symbol.coordinate);

	if node_ptr -> symbol.secondary ^= null & unspec (node_ptr -> symbol.secondary) ^= "0"b
	then call ioa_ ("^5xsecondary: ^p", node_ptr -> symbol.secondary);
	return;


output_node (3):					/* DIMENSION */
	if ^everything
	then return;

	if node_ptr -> dimension.assumed_size
	then call ioa_ ("^/^5xassumed_size");

	call ioa_ ("^/^5xndims: ^d", node_ptr -> dimension.number_of_dims);

	if node_ptr -> dimension.has_virtual_origin
	then if node_ptr -> dimension.variable_virtual_origin
	     then call ioa_ ("^5xv org operand: ^oo", node_ptr -> dimension.virtual_origin);
	     else call ioa_ ("^5xv org: ^d units", node_ptr -> dimension.virtual_origin);

	if node_ptr -> dimension.element_count ^= 0
	then call ioa_ ("^5xelement_count: ^d", node_ptr -> dimension.element_count);

	if node_ptr -> dimension.has_array_size
	then if node_ptr -> dimension.variable_array_size
	     then call ioa_ ("^5xarray size operand: ^oo", node_ptr -> dimension.array_size);
	     else call ioa_ ("^5xarray size: ^d units", node_ptr -> dimension.array_size);

	do chain = 1 to node_ptr -> dimension.number_of_dims;
	     call ioa_ ("^5xdimension ^d info:", chain);

	     if node_ptr -> dimension.v_bound (chain).lower
	     then do;
		     call ioa_ ("^10xlower bound operand: ^oo", node_ptr -> dimension.lower_bound (chain));
		     if walk_chains
		     then call display_node ((node_ptr -> dimension.lower_bound (chain)), all_fields, dont_walk);
		end;
	     else call ioa_ ("^10xlower bound: ^d", node_ptr -> dimension.lower_bound (chain));

	     if node_ptr -> dimension.v_bound (chain).upper
	     then do;
		     call ioa_ ("^10xupper bound operand: ^oo", node_ptr -> dimension.upper_bound (chain));
		     if walk_chains
		     then call display_node ((node_ptr -> dimension.upper_bound (chain)), all_fields, dont_walk);
		end;
	     else call ioa_ ("^10xupper bound: ^d", node_ptr -> dimension.upper_bound (chain));

	     if node_ptr -> dimension.has_dim_sizes
	     then if string (node_ptr -> dimension.v_bound (chain)) = "00"b
		then call ioa_ ("^10xsize: ^d", node_ptr -> dimension.size (chain));
		else call ioa_ ("^10xsize operand: ^oo", node_ptr -> dimension.size (chain));

	end;
	return;


output_node (4):					/* TEMPORARY */
	call ioa_ ("^2xoperand type: ^a, data type ^a", operand_names (node_ptr -> node.operand_type),
	     mode_names (node_ptr -> node.data_type));

	if node_ptr -> temporary.ref_count ^= 0
	then call ioa_ ("^5xref_count: ^d", node_ptr -> temporary.ref_count);

	if node_ptr -> temporary.ms_ref_count ^= 0
	then call ioa_ ("^5xMS ref_count: ^d", node_ptr -> temporary.ms_ref_count);

	if node_ptr -> temporary.ref_count_copy ^= 0
	then call ioa_ ("^5xref_count_copy: ^d", node_ptr -> temporary.ref_count_copy);

	if ^everything
	then return;

	call get_addressing_attributes;

	if node_ptr -> temporary.variable_length
	then ons = ons || "variable_length ";
	if node_ptr -> temporary.invariant
	then ons = ons || "invariant ";
	if node_ptr -> temporary.irreducible
	then ons = ons || "irreducible ";
	if node_ptr -> temporary.used_across_loops
	then ons = ons || "used_across_loops ";
	if node_ptr -> temporary.used_as_subscript
	then ons = ons || "used_as_subscript ";
	if node_ptr -> temporary.frozen_for_do
	then ons = ons || "frozen_for_do ";

	call print_common_fields ("loop_end_fu_pos");

	if node_ptr -> temporary.location ^= 0
	then call ioa_ ("^5xlocation: ^oo", node_ptr -> temporary.location);

	if node_ptr -> temporary.loop_ref_count ^= 0
	then call ioa_ ("^5xloop_ref_count: ^d", node_ptr -> temporary.loop_ref_count);

	if node_ptr -> temporary.length ^= 0
	then call ioa_ ("^5xchar length: ^[^oo^;^d^]", node_ptr -> temporary.variable_length,
		node_ptr -> temporary.length);

	if node_ptr -> temporary.size ^= 0
	then call ioa_ ("^5xsize in words: ^oo", node_ptr -> temporary.size);

	if node_ptr -> temporary.output_by ^= 0
	then call ioa_ ("^5xoutput_by: ^oo", node_ptr -> temporary.output_by);

	if node_ptr -> temporary.start_input_to ^= 0
	then call ioa_ ("^5xstart_input_to: ^oo", node_ptr -> temporary.start_input_to);

	if node_ptr -> temporary.end_input_to ^= 0
	then call ioa_ ("^5xend_input_to: ^oo", node_ptr -> temporary.end_input_to);
	return;


output_node (5):					/* CONSTANT */
	call ioa_ ("^2xoperand type: ^a, data type ^a, value ^a", operand_names (node_ptr -> node.operand_type),
	     mode_names (node_ptr -> node.data_type), print_constant_value (node_ptr, "0"b));

	if ^everything
	then return;

	call get_addressing_attributes;
	call print_common_fields ("hash_chain");
	return;


output_node (6):					/* LABEL */
	call ioa_ ("^2xoperand type: ^a, data type ^a, name ^d", operand_names (node_ptr -> node.operand_type),
	     mode_names (node_ptr -> node.data_type), node_ptr -> label.name);

	if ^everything
	then return;

	call get_addressing_attributes;

	if node_ptr -> label.executable
	then if node_ptr -> label.format
	     then ons = ons || "declarative ";
	     else ons = ons || "executable ";
	else if node_ptr -> label.format
	then ons = ons || "format ";
	else ons = ons || "no_usage_attrs ";

	if node_ptr -> label.restore_prs
	then ons = ons || "restore_prs ";
	if node_ptr -> label.referenced_executable
	then ons = ons || "referenced_executable ";
	if node_ptr -> label.not_referencable
	then ons = ons || "not_referencable ";
	if node_ptr -> label.branched_to
	then ons = ons || "branched_to ";
	if node_ptr -> label.ends_do_loop
	then ons = ons || "ends_do_loop ";

	call print_common_fields ("hash_chain");

	if node_ptr -> label.loop_end ^= 0
	then call ioa_ ("^5xloop_end: ^oo", node_ptr -> label.loop_end);

	if node_ptr -> label.statement ^= 0
	then do;
		call ioa_ ("^5xstatement: ^oo", node_ptr -> label.statement);
		if walk_chains
		then call display_quadruples ((node_ptr -> label.statement), (node_ptr -> label.statement));
	     end;

	if node_ptr -> label.format_var ^= 0
	then do;
		call ioa_ ("^5xformat_var: ^oo", node_ptr -> label.format_var);
		if walk_chains
		then call display_node ((node_ptr -> label.format_var), all_fields, dont_walk);
	     end;
	return;


output_node (7):					/* HEADER */
	call ioa_ ("^2xoperand type: ^a, data type ^a", operand_names (node_ptr -> node.operand_type),
	     mode_names (node_ptr -> node.data_type));

	if node_ptr -> header.in_common
	then call ioa_ ("^5xcommon block: ^a", node_ptr -> header.block_name);

	if ^everything
	then return;

	call get_addressing_attributes;

/* get HEADER addressing attributes */

	if node_ptr -> header.initialed
	then ons = ons || "initialed ";
	if node_ptr -> header.even
	then ons = ons || "even ";
	if node_ptr -> header.odd
	then ons = ons || "odd ";
	if node_ptr -> header.character
	then ons = ons || "character ";
	if node_ptr -> header.automatic
	then ons = ons || "automatic ";
	if node_ptr -> header.static
	then ons = ons || "static ";
	if node_ptr -> header.in_common
	then ons = ons || "in_common ";

	call print_common_fields ("pad");

	if node_ptr -> header.length ^= 0
	then call ioa_ ("^5xlength: ^d", node_ptr -> header.length);

	if node_ptr -> header.location ^= 0
	then call ioa_ ("^5xlocation: ^oo", node_ptr -> header.location);

	if node_ptr -> header.first_element ^= 0
	then call ioa_ ("^5xfirst_element: ^oo", node_ptr -> header.first_element);

	if node_ptr -> header.last_element ^= 0
	then call ioa_ ("^5xlast_element: ^oo", node_ptr -> header.last_element);

	if walk_chains
	then do chain = node_ptr -> header.first_element repeat addr (x (chain)) -> symbol.next_member
		while (chain > 0);
		call ioa_ ("^8oo ^a", chain, addr (x (chain)) -> symbol.name);
	     end;
	return;


output_node (8):					/* CHARACTER CONSTANT */
	call ioa_ ("^2xoperand type: ^a, data type ^a(^d), value ^a", operand_names (node_ptr -> node.operand_type),
	     mode_names (node_ptr -> node.data_type), node_ptr -> char_constant.length,
	     print_constant_value (node_ptr, "1"b));

	if ^everything
	then return;

	call get_addressing_attributes;

	if node_ptr -> char_constant.no_value_stored
	then ons = ons || "no_value_stored ";

	call print_common_fields ("hash_chain");
	return;


output_node (9):					/* ARRAY_REF */
	call ioa_ ("^2xoperand type: ^a, data type ^a", operand_names (node_ptr -> node.operand_type),
	     mode_names (node_ptr -> node.data_type));

	if node_ptr -> array_ref.ref_count ^= 0
	then call ioa_ ("^5xref_count: ^d", node_ptr -> array_ref.ref_count);

	if node_ptr -> array_ref.ref_count_copy ^= 0
	then call ioa_ ("^5xref_count_copy: ^d", node_ptr -> array_ref.ref_count_copy);

	if ^everything
	then return;

	call get_addressing_attributes;

	if node_ptr -> array_ref.has_address
	then ons = ons || "has_address ";

	if node_ptr -> array_ref.variable_offset
	then ons = ons || "variable_offset ";

	if node_ptr -> array_ref.variable_length
	then ons = ons || "variable_length ";

	if node_ptr -> array_ref.invariant
	then ons = ons || "invariant ";
	if node_ptr -> array_ref.irreducible
	then ons = ons || "irreducible ";
	if node_ptr -> array_ref.used_across_loops
	then ons = ons || "used_across_loops ";

	if node_ptr -> array_ref.large_offset
	then ons = ons || "large_offset ";

	call print_common_fields ("loop_end_fu_pos");

	if node_ptr -> array_ref.location ^= 0
	then call ioa_ ("^5xlocation: ^oo", node_ptr -> array_ref.location);

	if node_ptr -> array_ref.parent ^= 0
	then call ioa_ ("^5xparent: ^oo", node_ptr -> array_ref.parent);

	if node_ptr -> array_ref.v_offset ^= 0
	then call ioa_ ("^5xv_offset: ^oo", node_ptr -> array_ref.v_offset);

	if node_ptr -> array_ref.length ^= 0
	then call ioa_ ("^5xlength: ^[^oo^;^d^]", node_ptr -> array_ref.variable_length, node_ptr -> array_ref.length);

	if node_ptr -> array_ref.output_by ^= 0
	then call ioa_ ("^5xoutput_by: ^oo", node_ptr -> array_ref.output_by);

	if node_ptr -> array_ref.start_input_to ^= 0
	then call ioa_ ("^5xstart_input_to: ^oo", node_ptr -> array_ref.start_input_to);

	if node_ptr -> array_ref.end_input_to ^= 0
	then call ioa_ ("^5xend_input_to: ^oo", node_ptr -> array_ref.end_input_to);

	if walk_chains
	then call display_node ((node_ptr -> array_ref.parent), all_fields, dont_walk);
	return;


output_node (10):					/* PROC_FRAME */
	if ^everything
	then return;

	call ioa_ ("");
	call dump_words (node_ptr, get_node_size (node_ptr));
	return;


output_node (11):					/* LIBRARY */
	if ^everything
	then return;

	if node_ptr -> library.next_library_node ^= 0
	then call ioa_ ("^5xnext_library_node: ^oo", node_ptr -> library.next_library_node);

	if node_ptr -> library.character_operand ^= 0
	then call ioa_ ("^5xcharacter_operand: ^oo", node_ptr -> library.character_operand);

	if walk_chains
	then call ioa_ ("^5xpath: ^a", print_constant_value (addr (x (node_ptr -> library.character_operand)), "0"b));
	return;


output_node (12):					/* SUBPROGRAM */
	chain = node_ptr -> subprogram.symbol;
	if chain <= 0
	then call ioa_ ("^2x^a: NO NAME!", subr_type (node_ptr -> subprogram.subprogram_type));
	else call ioa_ ("^2x^a: ^a", subr_type (node_ptr -> subprogram.subprogram_type),
		addr (x (chain)) -> symbol.name);

	if ^everything
	then return;

	ons = "";
	call ioa_ ("");

	if node_ptr -> subprogram.options.ansi_77
	then ons = ons || "ansi77 ";
	else ons = ons || "ansi66 ";

	if node_ptr -> subprogram.options.card
	then ons = ons || "card ";
	else ons = ons || "free ";

	if node_ptr -> subprogram.options.fold
	then ons = ons || "fold ";

	if ^node_ptr -> subprogram.options.ignore_articulation_blocks
	then ons = ons || "safe ";

	if node_ptr -> subprogram.options.subscriptrange
	then ons = ons || "subrg ";
	else ons = ons || "nosubrg ";

	if node_ptr -> subprogram.options.stringrange
	then ons = ons || "stringrange ";

	if node_ptr -> subprogram.options.auto_zero
	then ons = ons || "auto_zero ";
	else ons = ons || "no_auto_zero ";

	if node_ptr -> subprogram.options.do_rounding
	then ons = ons || "round ";
	else ons = ons || "truncate ";

	if node_ptr -> subprogram.options.relocatable
	then ons = ons || "rlc ";
	else ons = ons || "nrlc ";

	if ons ^= ""
	then call ioa_ ("^5xoptions: ^a", ons);

	ons = "";
	if node_ptr -> subprogram.default_is.auto
	then ons = ons || "default_is.auto ";
	if node_ptr -> subprogram.default_is.static
	then ons = ons || "default_is.static ";
	if node_ptr -> subprogram.need_PS
	then ons = ons || "need_PS ";
	if node_ptr -> subprogram.need_prologue
	then ons = ons || "need_prologue ";
	if node_ptr -> subprogram.multiple_entry
	then ons = ons || "multiple_entry ";
	if node_ptr -> subprogram.namelist_used
	then ons = ons || "namelist_used ";
	if node_ptr -> subprogram.has_parameters
	then ons = ons || "has_parameters ";

	if ons ^= ""
	then call ioa_ ("^5xattr: ^a", ons);

	if node_ptr -> subprogram.previous_subprogram ^= 0 | node_ptr -> subprogram.next_subprogram ^= 0
	then call ioa_ ("^5xprevious: ^oo, next: ^oo", node_ptr -> subprogram.previous_subprogram,
		node_ptr -> subprogram.next_subprogram);

	if node_ptr -> subprogram.common_chain ^= 0 | node_ptr -> subprogram.equiv_chain ^= 0
	then call ioa_ ("^5xcommon: ^oo, equiv: ^oo", node_ptr -> subprogram.common_chain,
		node_ptr -> subprogram.equiv_chain)
		;

	if node_ptr -> subprogram.first_symbol ^= 0 | node_ptr -> subprogram.last_symbol ^= 0
	then call ioa_ ("^5xsymbols: ^oo ^oo", node_ptr -> subprogram.first_symbol, node_ptr -> subprogram.last_symbol);

	if node_ptr -> subprogram.first_label ^= 0 | node_ptr -> subprogram.last_label ^= 0
	then call ioa_ ("^5xlabels: ^oo ^oo", node_ptr -> subprogram.first_label, node_ptr -> subprogram.last_label);

	if node_ptr -> subprogram.first_polish ^= 0 | node_ptr -> subprogram.last_polish ^= 0
	then call ioa_ ("^5xpolish: ^oo ^o", node_ptr -> subprogram.first_polish, node_ptr -> subprogram.last_polish);

	if node_ptr -> subprogram.first_quad ^= 0 | node_ptr -> subprogram.last_quad ^= 0
	then call ioa_ ("^5xquad: ^oo ^oo", node_ptr -> subprogram.first_quad, node_ptr -> subprogram.last_quad);

	if node_ptr -> subprogram.map.first ^= 0 | node_ptr -> subprogram.map.last ^= 0
	then call ioa_ ("^5xmap.first: ^oo ^oo", node_ptr -> subprogram.map.first, node_ptr -> subprogram.map.last);

	if node_ptr -> subprogram.entry_info ^= 0
	then call ioa_ ("^5xentry_info: ^oo", node_ptr -> subprogram.entry_info);

	if node_ptr -> subprogram.runtime ^= 0
	then call ioa_ ("^5xruntime: ^oo", node_ptr -> subprogram.runtime);

	prt_sw = "1"b;				/* print header if interesting bucket is found */
	do chain = 1 to hbound (node_ptr -> subprogram.storage_info, 1);

	     ft = node_ptr -> subprogram.storage_info (chain).first;
	     ls = node_ptr -> subprogram.storage_info (chain).last;
	     nx = node_ptr -> subprogram.storage_info (chain).next_loc;

	     if ft ^= 0 | ls ^= 0 | nx ^= 0
	     then do;
		     if prt_sw
		     then call ioa_ ("^/^5xbucket	first	last	next_loc");
		     prt_sw = "0"b;

		     call ioa_ ("^8d^10oo^10oo^10oo", chain, ft, ls, nx);
		end;
	end;

	if node_ptr -> subprogram.n_loops > 0
	then call ioa_ ("^5xloop_vector: ^p, n_loops: ^d, max_operators: ^d, max_sym ^d",
		node_ptr -> subprogram.loop_vector_p, node_ptr -> subprogram.n_loops,
		node_ptr -> subprogram.max_operators,
		node_ptr -> subprogram.max_sym);

	return;


output_node (13):					/* ARG_DESC */
	if ^everything
	then return;

	call ioa_ ("^/^-^8d args^/^3xNumber^-Data Type^-^-Attributes", node_ptr -> arg_desc.n_args);
	do chain = 1 to node_ptr -> arg_desc.n_args;

	     ons = "";

	     if node_ptr -> arg_desc.arg (chain).must_be.array
	     then ons = ons || "must_be.array ";
	     if node_ptr -> arg_desc.arg (chain).must_be.scalar
	     then ons = ons || "must_be.scalar ";
	     if node_ptr -> arg_desc.arg (chain).star_extents
	     then ons = ons || "star_extents ";

	     call ioa_ ("^3d ^a ^a", chain, mode_names (node_ptr -> arg_desc.arg (chain).data_type), ons);
	end;
	return;


output_node (14):					/* POINTER */
	call ioa_ ("^5xcode: ^d, var: ^d, offset: ^d, count: ^d, hash_chain: ^oo",
	     node_ptr -> pointer.code, node_ptr -> pointer.variable,
	     node_ptr -> pointer.offset, node_ptr -> pointer.count,
	     node_ptr -> pointer.hash_chain);
	return;


output_node (15):					/* MACHINE_STATE */
	if node_ptr -> machine_state.next ^= null
	then call ioa_ ("^5xnext: ^p", node_ptr -> machine_state.next);

	call ioa_ ("^/EAQ state:");
	do i = 1 to 4;				/* A, Q, EAQ, IND */

	     call ioa_ ("^/^5x^a: name ^a, number ^d.",
		eaq_regs (i),
		eaq_names (node_ptr -> machine_state.eaq (i).name),
		node_ptr -> machine_state.eaq (i).number);

	     do chain = 1 to hbound (node_ptr -> machine_state.eaq.variable, 1);
		if node_ptr -> machine_state.eaq (i).variable (chain) ^= 0
		then call ioa_ ("^10x#^2d: ^oo", chain,
			node_ptr -> machine_state.eaq (i).variable (chain));
	     end;

	end;

	if node_ptr -> machine_state.indicators_valid > 0
	then call ioa_ ("^/^5xIndicators valid for ^a.",
		eaq_regs (node_ptr -> machine_state.indicators_valid));

	call ioa_ ("^/^5xType Variable  Last used Offset^2/Index registers");
	do chain = 0 to 7;
	     call ioa_ ("^5x^5d^10oo^10oo^10x^[ global^;^]^[ reserved^;^]",
		node_ptr -> machine_state.index_regs (chain).type,
		node_ptr -> machine_state.index_regs (chain).variable,
		node_ptr -> machine_state.index_regs (chain).used,
		node_ptr -> machine_state.index_regs (chain).global,
		node_ptr -> machine_state.index_regs (chain).reserved);
	end;

	call ioa_ ("^/Base registers");
	do chain = 0 to 7;
	     call ioa_ ("^5x^5d^10oo^10oo^10d^[ global^;^]^[ reserved^;^]",
		node_ptr -> machine_state.base_regs (chain).type,
		node_ptr -> machine_state.base_regs (chain).variable,
		node_ptr -> machine_state.base_regs (chain).used,
		node_ptr -> machine_state.base_regs (chain).offset,
		node_ptr -> machine_state.base_regs (chain).global,
		node_ptr -> machine_state.base_regs (chain).reserved);
	end;

	if node_ptr -> machine_state.stack_extended
	then call ioa_ ("^/Stack is extended^[; last_dynamic_temp = ^oo^].",
		(node_ptr -> machine_state.last_dynamic_temp ^= 0),
		node_ptr -> machine_state.last_dynamic_temp);

	return;


get_addressing_attributes:
     procedure;					/* creates string from addressing attribute bits */

	ons = "";

	if node_ptr -> node.is_addressable
	then ons = ons || "is_addressable ";
	if node_ptr -> node.value_in.eaq
	then ons = ons || "value_in.eaq ";
	if node_ptr -> node.value_in.x
	then ons = ons || "value_in.x ";
	if node_ptr -> node.allocated
	then ons = ons || "allocated ";
	if node_ptr -> node.needs_pointer
	then ons = ons || "needs_pointer ";
	if node_ptr -> node.stack_indirect
	then ons = ons || "stack_indirect ";
	if node_ptr -> node.large_address
	then ons = ons || "large_address ";
	if node_ptr -> node.address_in_base
	then ons = ons || "address_in_base ";
	if node_ptr -> node.allocate
	then ons = ons || "allocate ";
	if node_ptr -> node.set
	then ons = ons || "set ";
	if node_ptr -> node.referenced
	then ons = ons || "referenced ";
	if node_ptr -> node.passed_as_arg
	then ons = ons || "passed_as_arg ";
	if node_ptr -> node.dont_update
	then ons = ons || "dont_update ";
	if node_ptr -> node.not_in_storage
	then ons = ons || "not_in_storage ";
	if node_ptr -> node.globally_assigned
	then ons = ons || "globally_assigned ";

     end /* get_addressing_attributes */;


print_common_fields:
     procedure (name2);				/* prints string and address field */

dcl	name2		char (*);

	if ons ^= ""
	then call ioa_ ("^/^5xattr: ^a", ons);
	else call ioa_ ("");
	ons = "";

	if unspec (node_ptr -> node.address) ^= "0"b
	then call ioa_ ("^5xaddress: ^wo", unspec (node_ptr -> node.address));

	if node_ptr -> node.units ^= 0
	then call ioa_ ("^5xunits: ^a", offset_unit_names (node_ptr -> node.units));

	call ioa_ ("^5xrelocation: ^b (^b)", node_ptr -> node.reloc, node_ptr -> node.reloc_hold);

	if node_ptr -> node.addr_hold ^= "0"b
	then call ioa_ ("^5xaddr_hold: ^oo", node_ptr -> node.addr_hold);

	if node_ptr -> node.next ^= 0
	then call ioa_ ("^5xnext: ^oo", node_ptr -> node.next);

	if node_ptr -> node.hash_chain ^= 0
	then call ioa_ ("^5x^a: ^[^oo^;^d^]", name2, name2 = "hash_chain", node_ptr -> node.hash_chain);
     end /* print_common_fields */;

     end display_node;

display_quadruples:
     proc (start, stop);

dcl	(start, stop)	fixed bin (18);
dcl	last		fixed bin (18);

dcl	(op, i)		fixed bin (18);
dcl	o		ptr;

	last = -1;

	do op = start repeat o -> operator.next while (last ^= stop & op > 0);
	     o = addr (quad (op));
	     last = op;

	     if o -> operator.op_code = stat_op
	     then do;
		     stat_start = binary (o -> opt_statement.start, 26);
		     stat_length = binary (o -> opt_statement.length, 9);
		     call ioa_
			(
			"^/STAT:  ^oo  ^a start ^d, length ^d
         ^/^a^/
     next ^oo, back ^oo
     first_op ^oo, prev_op ^oo, obj ^oo",
			op, decode_source_id (op, quadruple_base, "0"b), stat_start, stat_length,
			substr (source_segment, stat_start + 1, stat_length), binary (o -> opt_statement.next, 18),
			binary (o -> opt_statement.back, 18), binary (o -> opt_statement.first_operator, 18),
			binary (o -> opt_statement.prev_operator, 18), binary (o -> opt_statement.location, 18));

		     ons = "";
		     if o -> opt_statement.put_in_profile
		     then ons = "put_in_profile ";
		     else if o -> opt_statement.put_in_map
		     then ons = "put_in_map ";

		     if o -> opt_statement.referenced_backwards
		     then ons = ons || "referenced_backwards ";

		     if o -> opt_statement.referenced_by_assign
		     then ons = ons || "referenced_by_assign ";

		     if o -> opt_statement.moved
		     then ons = ons || "moved ";

		     if o -> opt_statement.removable
		     then ons = ons || "removable ";

		     call ioa_ ("^5x^a", ons);

		     if o -> opt_statement.flow_unit ^= null
		     then call ioa_ ("^5xflow_unit: ^p", o -> opt_statement.flow_unit);

		     if o -> opt_statement.has_operator_list
		     then call ioa_ ("^5xoperator_list: ^p", o -> opt_statement.operator_list);

		     if o -> opt_statement.machine_state ^= 0
		     then call ioa_ ("^5xmachine_state: ^oo", o -> opt_statement.machine_state);

		     if o -> opt_statement.label ^= 0
		     then call display_node ((o -> opt_statement.label), just_name, dont_walk);
		end;

	     else do;
		     if o -> operator.op_code >= lbound (op_names, 1) & o -> operator.op_code <= hbound (op_names, 1)
		     then call ioa_ ("^/OPERATOR: ^oo ^a^[  FREED^;^]", op, op_names (o -> operator.op_code),
			     o -> operator.freed);
		     else call ioa_ ("^/OPERATOR: ^oo ^d^[  FREED^;^]", op, binary (o -> operator.op_code, 8),
			     o -> operator.freed);

		     call display_operand ((o -> operator.output));

		     do i = 1 to o -> operator.number;
			call display_operand ((o -> operator.operand (i)));
		     end;
		end;
	end;

	return;


display_operand:
     proc (content);

dcl	content		fixed bin (18);

	if content < 0
	then call ioa_ ("^/COUNT: ^d", content + bias);
	else if content > 0
	then call display_node (content, just_name, dont_walk);
	else call ioa_ ("^/ZERO");

     end display_operand;

     end display_quadruples;

     end fort_display;

     end fort_;
