/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(86-02-06,Blair), approve(86-02-26,MCR7358),
     audit(86-04-18,RBarstad), install(86-05-28,MR12.0-1062):
     85-02-28  JG Backs: Modified to allow selection of messages by date or
     range of dates.  Added 3 new internal procedures to do this: date_search,
     convert_date, and date_current.  Also added an include file for date
     conversions: time_value.incl.pl1 and clock builtin.
     85-03-11  JG Backs: Modified to allow responses of short forms of keywords.
     Allow a for all, l for last, f for first, n for next, and p for prev.
     Include file xmail_responses.incl.pl1 was also modified to add short forms.
  2) change(86-02-06,Blair), approve(86-02-26,MCR7358),
     audit(86-04-18,RBarstad), install(86-05-28,MR12.0-1062):
     Add new procs to process "new", "seen", and "unseen" selection specifiers.
     Note that the previous meaning of "new" is preserved in the new_current
     procedure whereas the new meaning of "new" (unseen since last seen)
     requires a new entrypoint.  The old is retained so that
     xmail_Process_Mail_ can update mail file counts as new messages arrive.
  3) change(86-02-25,Blair), approve(86-02-25,MCR7358),
     audit(86-04-18,RBarstad), install(86-05-28,MR12.0-1062):
     Change the interpret_list routine so that swn seen and swf seen can
     be processed.  This required changes to when the message structure gets
     allocated for SEEN UNSEEN NEW and ALL messages.  It is now possible to
     process lists of messages in conjunction with ranges.
  4) change(87-01-14,Blair), approve(87-02-05,MCR7618),
     audit(87-04-10,RBarstad), install(87-04-26,MR12.1-1025):
     Initialize the count variable in new_current to alleviate a size error
     problem when we create a new current msgs structure.
                                                   END HISTORY COMMENTS */


xmail_select_msgs_: proc (P_mailbox_ptr, P_curr_msgsp, P_seen_msgs, P_switch_on_off, P_pos_line);

/* BEGIN DESCRIPTION

history:
   Created 06/17/81 by Suzanne Krupp 

   83-07-14  DJ Schimke: Modified to use new mail_system calls and version 2
   mailboxes.

   84-11-09  JG Backs: Modified interpret_range internal procedure to make
   sure the largest number in the range is not above the number of messages
   in the mailbox. 

END DESCRIPTION
*/

/* PARAMETERS */

	dcl     P_curr_msgsp	 ptr parameter;
	dcl     P_deleted_msgsp	 ptr parameter;
	dcl     P_mailbox_ptr	 ptr parameter;
	dcl     P_pos_line		 char (*) parameter;
	dcl     P_spec_msgsp	 ptr parameter;
          dcl     P_switch_on_off        bit (2) aligned parameter;
	dcl     P_seen_msgs                ptr;
		

/* AUTOMATIC */

	dcl     area_ptr		 ptr;
	dcl     code		 fixed bin (35);
          dcl     hold_code              fixed bin (35);
	dcl     i			 fixed bin;
	dcl     line		 char (256) var;
          dcl     list_any               bit (1) aligned;
	dcl     need_answer		 bit (1) aligned;
	dcl     n_new_msgs             fixed bin;
	dcl     prompt_sw		 bit (1) aligned;
          dcl     switch_on              bit (1) aligned;
          dcl     switch_off             bit (1) aligned;
	dcl     unused_return_length	 fixed bin;
	dcl     want_deleted_msgs	 bit (1) aligned;
	dcl     want_seen_messages     bit (1) aligned;
		

/* BASED */

	dcl     based_area		 area based (area_ptr);

/* BUILTINS */

	dcl     (addr, after, before, char, index, length, ltrim, null, rtrim, verify) builtin;

/* CONDITIONS */

          dcl     cleanup                condition;

/* CONSTANTS */

	dcl     DUMMY_ANSWER_ARRAY	 (1) char (1) var static options (constant) init ("");
	dcl     ME_CHAR		 char (17) int static options (constant) init ("xmail_select_msgs");
	dcl     ONE_DAY		 fixed binary (71) static options (constant) init (86399999999);  /* one microsecond less than 1 day */
	dcl     SECONDS                bit (2) int static options (constant) init ("11"b);
	dcl     TODAY		 char (5) int static options (constant) init ("today");
		

/* ENTRIES */

	dcl     com_err_$suppress_name entry () options (variable);
	dcl     convert_date_to_binary_ entry (char(*), fixed bin(71), fixed bin(35));
	dcl     cv_dec_check_	 entry (char (*), fixed bin (35)) returns (fixed bin (35));
	dcl     date_time_$format      entry (char(*), fixed bin(71), char(*), char(*)) returns(char(250) var);
	dcl     date_time_$from_clock  entry (fixed bin(71), char(*), ptr, fixed bin(35));
	dcl     date_time_$to_clock    entry (ptr, fixed bin(71), fixed bin(35));
	dcl     get_system_free_area_	 entry () returns (ptr);
	dcl     ioa_		 entry () options (variable);
	dcl     ioa_$rsnnl		 entry () options (variable);
	dcl     mail_system_$read_message entry (ptr, fixed bin, fixed bin (35));
	dcl     mail_system_$read_new_messages entry (ptr, fixed bin, fixed bin, fixed bin, fixed bin (35));
	dcl     mlsys_utils_$search_message entry (ptr, char (*), ptr, fixed bin (35)) returns (bit (1) aligned);
	dcl     timer_manager_$sleep   entry (fixed bin(71), bit(2));
	dcl     xmail_error_$code_first entry () options (variable);
	dcl     xmail_error_$no_code	 entry () options (variable);
	dcl     xmail_get_str_	 entry (char (*) var, (*) char (*) var, char (*), char (*), char (*) var);
	dcl     xmail_get_str_$yes_no	 entry (char (*) var, bit (1) aligned);
	dcl     xmail_list_msgs_	 entry (ptr, ptr, ptr);
	dcl     xmail_list_msgs_$selected entry (ptr, ptr, ptr);
	dcl     xmail_validate_$curr_msgs entry (ptr, fixed bin (35));
	dcl     xmail_validate_$mbx	 entry (ptr, fixed bin (35));

/* EXTERNAL STATIC */

	dcl     (mlsys_et_$no_more_messages,
	        xmail_err_$bad_response,
                  xmail_err_$int_prog_err,
	        xmail_err_$invalid_list,
	        xmail_err_$invalid_range,
	        xmail_err_$list_requested,
	        xmail_err_$mailbox_empty,
	        xmail_err_$no_msgs_exist,
	        xmail_err_$some_del_msgs_exist,
	        xmail_err_$some_msgs_exist,
	        xmail_err_$date_not_found,
	        xmail_err_$str_not_found) fixed bin (35) ext static;

	dcl     iox_$user_output	 ptr ext static;

/* INCLUDE FILES */

%page;
%include mlsys_message;
%page;
%include mlsys_mailbox;
%page;
%include time_value;
%page;
%include xmail_curr_msg_info;
%page;
%include xmail_prompts;
%page;
%include xmail_responses;
%page;
%include xmail_help_infos;
%page;
%include mlsys_search_options;
%page;
%include xmail_data;

/* Initialization */

	want_deleted_msgs, want_seen_messages, switch_on, switch_off, list_any = "0"b;
	P_switch_on_off = "00"b;
	P_seen_msgs = null;
	
	call init (P_mailbox_ptr, P_curr_msgsp, P_pos_line);

	need_answer = "1"b;
	do while (need_answer);

	     call xmail_get_str_ ((MSG_SELECT_PROMPT), DUMMY_ANSWER_ARRAY, PROMPT_REPLIES_HELP, MSG_SELECT_INFO, line);

	     code, count = 0;
	     curr_msgsp, nonexist_msgsp = null;

/* Look to see if more messages are in the mailbox.   */

	     call mail_system_$read_new_messages (mailbox_ptr, n_new_msgs, (0), (0), code);
	     if code ^= 0 & code ^= mlsys_et_$no_more_messages
		then call xmail_error_$no_code (code, ME_CHAR, "q", "Unable to look for new messages. This is an internal programming error.");
	     
	     hold_code = code;
	     code = 0;

	     if line = A | line = ALL | line = SEEN | line = UNSEEN | line = NEW 
               then call alloc_msg_struct (mailbox.n_messages, curr_msgsp);
                  
	     if line = ALL | line = A
	     then call all_current (count);
	     else if line = FIRST | line = F
	     then call first_current ();
	     else if line = LAST | line = L
	     then call last_current ();
	     else if line = NEXT | line = N
	     then call next_current (P_curr_msgsp);
	     else if line = PREV | line = P
	     then call prev_current (P_curr_msgsp);
	     else if line = NEW 
	     then call new_since_last_seen (count);
	     else if line = SEARCH
	     then call search (code);
	     else if line = SEEN
	     then call seen_current (count);
	     else if line = UNSEEN
	     then call unseen_current (count);
	     else if line = DATE
	     then call date_search (code);
/*	     else if index (line, ":") > 0
	     then call interpret_range (line, code); 
	     else if verify (line, "0123456789 ") = 0 
	     then call interpret_list (line, code); */
	     else if line = LIST
	     then code = xmail_err_$list_requested;
	     else call interpret_list (line,code);
	     
	     if code = 0				/* Everything ok */
	     then do;
		if line = A | line = ALL | line = NEW | line = SEEN | line = UNSEEN
		then curr_msgs.count = count;
		need_answer = "0"b;
		if ^(switch_on | switch_off)
		then call ioa_$rsnnl ("^(^d ^)", P_pos_line, unused_return_length, curr_msgs.numbers);
	     end;
	     else if code = xmail_err_$list_requested	/* User wanted a list */
	     then do;
		call ioa_ ("^/^a", MSG_LIST_MSG);
		call xmail_list_msgs_ (mailbox_ptr, P_curr_msgsp, iox_$user_output);
	     end;
	     else do;				/* Something went wrong */
		call com_err_$suppress_name (code, ME_CHAR);
		if code = xmail_err_$some_msgs_exist
		then do;
		     if want_some ()
		     then do;
			need_answer = "0"b;
			call ioa_$rsnnl ("^(^d ^)", P_pos_line, unused_return_length, curr_msgs.numbers);
		     end;
		end;
		else if code ^= xmail_err_$invalid_range &
		     code ^= xmail_err_$invalid_list &
		     code ^= xmail_err_$no_msgs_exist &
		     code ^= xmail_err_$str_not_found &
		     code ^= xmail_err_$date_not_found &
		     code ^= xmail_err_$bad_response
		then call xmail_error_$no_code (code, ME_CHAR, "q", "Unable to interpret response.  This is an internal programming error.");
	     end;

	     if need_answer				/* get rid of what we don't need. */
	     then if curr_msgsp ^= null then free curr_msgs;
	     if nonexist_msgsp ^= null then free nonexist_msgs;

	end;					/* do while */

          if switch_on | switch_off then P_seen_msgs = curr_msgsp;
	else
	call use_spec_msgs (P_curr_msgsp, curr_msgsp);

	if switch_on then P_switch_on_off = "10"b;
	if switch_off then P_switch_on_off = "01"b;

	return;


/* ENTRYPOINTS */

all: entry (P_mailbox_ptr, P_curr_msgsp, P_pos_line);

          dcl  msg_count               fixed bin;

	want_deleted_msgs = "0"b;
	msg_count = 0;
	call init (P_mailbox_ptr, P_curr_msgsp, P_pos_line);
	call alloc_msg_struct (mailbox.n_messages, curr_msgsp);
	call all_current (msg_count);
	P_pos_line = "all";
	call use_spec_msgs (P_curr_msgsp, curr_msgsp);

	return;					/* all */

new: entry (P_mailbox_ptr, P_curr_msgsp, P_pos_line);

	want_deleted_msgs = "0"b;

	call xmail_validate_$mbx (P_mailbox_ptr, code);
	if code ^= 0
	then call xmail_error_$no_code (code, ME_CHAR, "q", "Invalid mailbox structure. This is an internal programming error.");

	if P_curr_msgsp ^= null
	then do;
	     call xmail_validate_$curr_msgs (P_curr_msgsp, code);
	     if code ^= 0
	     then call xmail_error_$no_code (code, ME_CHAR, "q", "Invalid message structure. This is an internal programming error.");
	end;

	mailbox_ptr = P_mailbox_ptr;
	area_ptr = get_system_free_area_ ();

	if mailbox.n_messages = 0
	then do;
	     call use_spec_msgs (P_curr_msgsp, null);
	     P_pos_line = "NONE";
	     call xmail_error_$code_first (xmail_err_$mailbox_empty, ME_CHAR, "i");
	end;

          call mail_system_$read_new_messages (mailbox_ptr, n_new_msgs, (0), (0), code);
	if code ^= 0 & code ^= mlsys_et_$no_more_messages
	then call xmail_error_$no_code (code, ME_CHAR, "q", "Unable to look for new messages. This is an internal programming error.");

	call new_current (n_new_msgs, code);
	call ioa_$rsnnl ("^(^d ^)", P_pos_line, unused_return_length, curr_msgs.numbers);
						/*     P_pos_line = "newly arrived"; */
	call use_spec_msgs (P_curr_msgsp, curr_msgsp);

	return;					/* first */

first: entry (P_mailbox_ptr, P_curr_msgsp, P_pos_line);

	want_deleted_msgs = "0"b;

	call init (P_mailbox_ptr, P_curr_msgsp, P_pos_line);
	call first_current ();
	P_pos_line = ltrim (rtrim (char (curr_msgs.numbers (1))));
	call use_spec_msgs (P_curr_msgsp, curr_msgsp);

	return;					/* first */

last: entry (P_mailbox_ptr, P_curr_msgsp, P_pos_line);

	want_deleted_msgs = "0"b;

	call init (P_mailbox_ptr, P_curr_msgsp, P_pos_line);
	call last_current ();
	P_pos_line = ltrim (rtrim (char (curr_msgs.numbers (1))));
	call use_spec_msgs (P_curr_msgsp, curr_msgsp);

	return;					/* last */

next: entry (P_mailbox_ptr, P_curr_msgsp, P_pos_line);

	want_deleted_msgs = "0"b;

	call init (P_mailbox_ptr, P_curr_msgsp, P_pos_line);
	call next_current (P_curr_msgsp);
	P_pos_line = ltrim (rtrim (char (curr_msgs.numbers (1))));
	call use_spec_msgs (P_curr_msgsp, curr_msgsp);

	return;					/* next */

prev: entry (P_mailbox_ptr, P_curr_msgsp, P_pos_line);

	want_deleted_msgs = "0"b;
	
	call init (P_mailbox_ptr, P_curr_msgsp, P_pos_line);
	call prev_current (P_curr_msgsp);
	P_pos_line = ltrim (rtrim (char (curr_msgs.numbers (1))));
	call use_spec_msgs (P_curr_msgsp, curr_msgsp);

	return;					/* prev */

deleted: entry (P_mailbox_ptr, P_deleted_msgsp, P_flavor);

	dcl     P_flavor		 char (*) parameter;
          dcl     count                  fixed bin;

          count = 0;
	want_deleted_msgs = "1"b;
          switch_on, switch_off = "0"b;
	P_deleted_msgsp = null;

	call xmail_validate_$mbx (P_mailbox_ptr, code);
	if code ^= 0
	then call xmail_error_$no_code (code, ME_CHAR, "q", "Invalid mailbox structure.  This is an internal programming error.");

	if P_deleted_msgsp ^= null
	then do;
	     call xmail_validate_$curr_msgs (P_deleted_msgsp, code);
	     if code ^= 0
	     then call xmail_error_$no_code (code, ME_CHAR, "q", "Invalid message structure. This is an internal programming error.");
	end;

	mailbox_ptr = P_mailbox_ptr;
	area_ptr = get_system_free_area_ ();

	if mailbox.n_deleted_messages <= 0
	then do;
	     if ^xmail_data.cleanup_signalled
	     then call ioa_ ("There are no discarded messages.");
	     P_deleted_msgsp = null ();
	     return;
	end;
	if P_flavor ^= ""
	then do;
	     line = P_flavor;
	     prompt_sw = "0"b;
	end;
	else prompt_sw = "1"b;
	need_answer = "1"b;

	do while (need_answer);
	     if xmail_data.cleanup_signalled then do;
		prompt_sw = "0"b;
		line = ALL;
		end;
	     if prompt_sw
	     then call xmail_get_str_ ((DEL_MSG_SELECT_PROMPT), DUMMY_ANSWER_ARRAY, PROMPT_REPLIES_HELP, DEL_MSG_SELECT_INFO, line);

	     prompt_sw = "1"b;
	     code = 0;
	     curr_msgsp, nonexist_msgsp = null;

	     if line = ALL | line = A | line = NEW | line = SEEN | line = UNSEEN 
	     then call alloc_msg_struct (mailbox.n_messages, curr_msgsp);

	     if line = ALL | line = A
	     then do;
		count = 0;
		call all_current (count);
		curr_msgs.count = count;
		end;
	     else if line = FIRST | line = F
	     then call first_current ();
	     else if line = LAST | line = L
	     then call last_current ();
/*	     else if index (line, ":") > 0
	     then call interpret_range (line, code);
	     else if verify (line, "0123456789 ") = 0
	     then call interpret_list (line, code);      */
	     else if line = LIST
	     then code = xmail_err_$list_requested;
	     else call interpret_list (line,code);
	     
	     if code = 0
	     then need_answer = "0"b;
	     else if code = xmail_err_$list_requested
	     then do;				/* User requested a list */
		count = 0;
		call alloc_msg_struct (mailbox.n_messages, curr_msgsp);
		call all_current (count);
		curr_msgsp -> curr_msgs.count = count;
		call ioa_ ("^/^a^/", DEL_MSG_LIST_MSG);
		call xmail_list_msgs_$selected (mailbox_ptr, curr_msgsp, iox_$user_output);
	     end;
	     else do;
		call com_err_$suppress_name (code, ME_CHAR);
		if code = xmail_err_$some_del_msgs_exist
		then do;
		     if want_some ()
		     then need_answer = "0"b;
		end;
		else if code ^= xmail_err_$invalid_range &
		     code ^= xmail_err_$invalid_list &
		     code ^= xmail_err_$no_msgs_exist &
		     code ^= xmail_err_$bad_response
		then call xmail_error_$no_code (code, ME_CHAR, "q", "Unable to interpret user response. This is an internal programming error.");
	     end;

	     if need_answer
	     then if curr_msgsp ^= null
		then free curr_msgs;
	     if nonexist_msgsp ^= null
	     then free nonexist_msgs;

	end;

	P_deleted_msgsp = curr_msgsp;
	
	return;					/* deleted */

replace_curr: entry (P_curr_msgsp, P_spec_msgsp, P_pos_line);

	call use_spec_msgs (P_curr_msgsp, P_spec_msgsp);
	call ioa_$rsnnl ("^(^d ^)", P_pos_line, unused_return_length, P_curr_msgsp -> curr_msgs.numbers);

	return;					/* replace_curr */


/* INTERNAL PROCEDURES */

init: proc (P_mailbox_ptr, P_curr_msgsp, P_pos_line);

	dcl     (P_mailbox_ptr, P_curr_msgsp) ptr;
	dcl     P_pos_line		 char (*);

	dcl     code		 fixed bin (35);


	call xmail_validate_$mbx (P_mailbox_ptr, code);
	if code ^= 0
	then call xmail_error_$no_code (code, ME_CHAR, "q", "Invalid mailbox structure. This is an internal programming error.");

	if P_curr_msgsp = null
	then ;
	else do;
	     call xmail_validate_$curr_msgs (P_curr_msgsp, code);
	     if code ^= 0
	     then call xmail_error_$no_code (code, ME_CHAR, "q", "Invalid message structure. This is an internal programming error.");
	end;

	mailbox_ptr = P_mailbox_ptr;
	area_ptr = get_system_free_area_ ();

	if mailbox.n_messages = 0
	then do;
	     call use_spec_msgs (P_curr_msgsp, null);
	     P_pos_line = "NONE";
	     go to INIT_EXIT;
	end;

	if mailbox.n_messages <= mailbox.n_deleted_messages
	then do;
	     call use_spec_msgs (P_curr_msgsp, null);
	     P_pos_line = "NONE";
	     call xmail_error_$no_code (code, ME_CHAR, "i");
	end;

INIT_EXIT: return;
     end init;

all_current: proc (P_count);

	dcl     P_count      fixed bin;
	dcl     i, count	 fixed bin;

          count = P_count;

	do i = 1 to mailbox.n_messages;
	     if want_deleted_msgs = msg_deleted (i)
	     then if ^already_specified (i, curr_msgsp)
	     then call add_to_msg_struct (curr_msgsp, count, i);
	end;

	P_count = count;

     end all_current;

first_current: proc ();

	call alloc_msg_struct (1, curr_msgsp);

	if want_deleted_msgs
	then curr_msgs.numbers (1) = first_deleted ();
	else curr_msgs.numbers (1) = first_existing ();

     end first_current;

last_current: proc ();

	call alloc_msg_struct (1, curr_msgsp);	

	if want_deleted_msgs
	then curr_msgs.numbers (1) = last_deleted ();
	else curr_msgs.numbers (1) = last_existing ();

     end last_current;

next_current: proc (P_curr_msgsp);

	dcl     P_curr_msgsp	 ptr;

	dcl     found		 bit (1) aligned;
	dcl     (i, highest)	 fixed bin;

	highest = 0;
	if P_curr_msgsp ^= null
	then do i = 1 to P_curr_msgsp -> curr_msgs.count;
		if highest < P_curr_msgsp -> curr_msgs.numbers (i)
		then highest = P_curr_msgsp -> curr_msgs.numbers (i);
	     end;


	call alloc_msg_struct (1, curr_msgsp);
	found = "0"b;

	do i = highest + 1 to mailbox.n_messages while (^found);	
	     if ^msg_deleted (i)
	     then do;
		curr_msgs.numbers (1) = i;
		found = "1"b;
	     end;
	end;

	do i = 1 to highest while (^found);
	     if ^msg_deleted (i)
	     then do;
		curr_msgs.numbers (1) = i;
		found = "1"b;
	     end;
	end;

     end next_current;

prev_current: proc (P_curr_msgsp);

	dcl     P_curr_msgsp	 ptr;

	dcl     found		 bit (1) aligned;
	dcl     (i, lowest)		 fixed bin;

	lowest = mailbox.n_messages + 1;

	if P_curr_msgsp ^= null
	then do i = 1 to P_curr_msgsp -> curr_msgs.count;
		if lowest > P_curr_msgsp -> curr_msgs.numbers (i)
		then lowest = P_curr_msgsp -> curr_msgs.numbers (i);
	     end;

	call alloc_msg_struct (1, curr_msgsp);
	found = "0"b;

	do i = lowest - 1 to 1 by -1 while (^found);
	     if ^msg_deleted (i)
	     then do;
		curr_msgs.numbers (1) = i;
		found = "1"b;
	     end;
	end;

	do i = mailbox.n_messages to lowest by -1 while (^found);
	     if ^msg_deleted (i)
	     then do;
		curr_msgs.numbers (1) = i;
		found = "1"b;
	     end;
	end;

     end prev_current;

new_current: proc (P_new_msgs, P_code);

	dcl     P_code		 fixed bin (35);
          dcl     count                  fixed bin;
	dcl     i			 fixed bin;
	dcl     P_new_msgs		 fixed bin;


	if P_code = mlsys_et_$no_more_messages
	then call xmail_error_$code_first (P_code, ME_CHAR, "i");
	
	call alloc_msg_struct (P_new_msgs, curr_msgsp);
	count = 0;
		
	do i = mailbox.n_messages - P_new_msgs + 1 to mailbox.n_messages;
	     call mail_system_$read_message (mailbox_ptr, i, code);
	     if code ^= 0
		then call xmail_error_$no_code (code, ME_CHAR, "l", "Unable to read message ^d. This is a n internal programming error.", i);
/*	     message_ptr = mailbox.messages (i). message_ptr;       */
	     call add_to_msg_struct (curr_msgsp, count, i);
	end;

     end new_current;

new_since_last_seen:  proc (P_count);
		  
            dcl  P_count                             fixed bin;
	  dcl  (count, i, first_unseen, last_seen) fixed bin;

            want_seen_messages = "0"b;		  
	  count = P_count;

	  do i = mailbox.n_messages by -1 to 1 while (want_seen_messages = msg_seen (i));
	       end;
	  last_seen = i;

	  if last_seen < mailbox.n_messages then do;
	       first_unseen = last_seen +1;
	       do i = first_unseen to mailbox.n_messages;
		  if ^already_specified (i, curr_msgsp)
		  then call add_to_msg_struct (curr_msgsp, count, i);
		  end;
	       end;
	  P_count = count;
	  
	  if count = 0
	  then call xmail_error_$no_code ((0), ME_CHAR, "i", "There are no ""new"" messages in this mailbox.");

     end new_since_last_seen;

seen_current:  proc(P_count);
	     
               dcl     P_count           fixed bin;
	     dcl     (count,i)         fixed bin;

	     want_seen_messages = "1"b;
	     count = P_count;
	     
	     do i = 1 to mailbox.n_messages;
		if want_seen_messages = msg_seen(i)
		then if ^already_specified (i, curr_msgsp)
		then call add_to_msg_struct (curr_msgsp, count, i);
		end;
	     
	     P_count = count;

	     if count = 0 
	     then	call xmail_error_$no_code ((0),ME_CHAR,"i","There are no ""seen"" messages in this mailbox.");
	     end seen_current;

unseen_current: proc (P_count);
	      
	      dcl     P_count       fixed bin;
	      dcl     (count,i)     fixed bin;

	      want_seen_messages = "0"b;
	      count = P_count;
	      
	      do i = 1 to mailbox.n_messages;
		 if want_seen_messages = msg_seen (i)
		      then if ^already_specified (i, curr_msgsp)
		      then call add_to_msg_struct (curr_msgsp, count ,i);
		 end;
	      
	      P_count = count;

	      if count = 0 
                then call xmail_error_$no_code ((0), ME_CHAR, "i", "There are no ""unseen"" messages in this mailbox.");
	      	      
	      end unseen_current;

interpret_range: proc (P_str,P_left_num, P_right_num, P_code);

	dcl     P_str		 char (*) var;
          dcl     P_left_num             fixed bin;
          dcl     P_right_num            fixed bin;
	dcl     P_code		 fixed bin (35);

	dcl     (curr_count, nonexist_count) fixed bin;
	dcl     (left_num, right_num)	 fixed bin;
	dcl     (left_str, right_str)	 char (length (P_str)) var;
	dcl     code		 fixed bin (35);

	P_code = 0;
	left_str = ltrim (rtrim (before (P_str, ":")));
	right_str = ltrim (rtrim (after (P_str, ":")));

	if left_str = "" | right_str = ""
	then do;
	     P_code = xmail_err_$invalid_range;
	     go to RANGE_EXIT;
	end;

	left_num = get_num ((left_str), code);
	if code ^= 0
	then do;
	     P_code = xmail_err_$invalid_range;
	     go to RANGE_EXIT;
	end;

	right_num = get_num ((right_str), code);

	if code ^= 0
	then do;
	     P_code = xmail_err_$invalid_range;
	     go to RANGE_EXIT;
	end;

	if left_num > right_num
	then do;
	     P_code = xmail_err_$invalid_range;
	     go to RANGE_EXIT;
	end;

/* None of the specified messages exist. */

	if right_num < 1 | left_num > mailbox.n_messages
	then do;
	     P_code = xmail_err_$no_msgs_exist;
	     go to RANGE_EXIT;
	end;

/* Test if right number is more that the total messages */

	if right_num > mailbox.n_messages
	then do;
	     P_code = xmail_err_$invalid_range;
	     go to RANGE_EXIT;
	end;

          P_left_num = left_num;
          P_right_num = right_num;

	if ^list_any then do;
	     curr_count, nonexist_count = 0;
	     call alloc_msg_struct (right_num - left_num + 1, curr_msgsp);
	     call alloc_msg_struct (right_num - left_num + 1, nonexist_msgsp);

	     do  i = left_num to right_num;
		if want_deleted_msgs = msg_deleted (i)
		then call add_to_msg_struct (curr_msgsp, curr_count, i);
		else call add_to_msg_struct (nonexist_msgsp, nonexist_count, i);
		end;
	     
	     call set_counts (curr_count, nonexist_count, P_code); 
	end;
     

RANGE_EXIT: return;
     end interpret_range;

interpret_list: proc (P_str, P_code);

	dcl     P_str		 char (*) var;
	dcl     P_code		 fixed bin (35);

	dcl     (copy_str)	 char (length (P_str)) var;
	dcl     (curr_count, nonexist_count) fixed bin;
	dcl     (msg_num, n_tokens, token_index) fixed bin;
	dcl     code		 fixed bin (35);
          dcl     first_token            fixed bin;
          dcl     now_in_struct          bit (1) aligned;
          dcl     have_range             bit (1) aligned;
	dcl     left_num               fixed bin;
          dcl     right_num              fixed bin;
	dcl     get_temp_segment_ entry (char(*), ptr, fixed bin(35));
          dcl     release_temp_segment_ entry (char(*), ptr, fixed bin(35));
	dcl     token_array_ptr        ptr;
	dcl     1 token_array          based (token_array_ptr) aligned,
	          2 Ntokens            fixed bin,
	          2 token              (0 refer (Ntokens)) char (10) var;
      
	token_array_ptr = null;
          have_range = "0"b;
	list_any = "1"b;
          left_num, right_num, n_tokens, first_token = 0;
	P_code, code = 0;
	copy_str = P_str;

	call get_temp_segment_ (ME_CHAR, token_array_ptr, code);
	if code ^= 0 then do;
	     code = xmail_err_$int_prog_err;
	     goto LIST_EXIT;
	     end;

	on cleanup begin;
	     if token_array_ptr ^= null
	     then call release_temp_segment_ (ME_CHAR, token_array_ptr, (0));
	     end;

	Ntokens = 1;
	token_array.token(Ntokens) = next_token (copy_str);
	do while (token_array.token(Ntokens) ^= "");
	    if index (token_array.token(Ntokens) ,":") > 0 then do;
	         call interpret_range ((token_array.token(Ntokens)), left_num, right_num, P_code);
		if P_code ^= 0
		then goto LIST_EXIT;
		n_tokens = n_tokens + (right_num - left_num);
		end;

	     Ntokens = Ntokens + 1;	     	
	     token_array.token(Ntokens) = next_token (copy_str);
	end;

/* what have we got here? */

     first_token = 1;
     if token_array.token(1) = "switch_on" | token_array.token(1) = "swn"
     then if token_array.token(2) = SEEN 
          then do;
	     switch_on = "1"b;
	     if Ntokens > 2 then first_token = 3;
	     end;
          else  do;
	     P_code = xmail_err_$bad_response;
	     goto LIST_EXIT;
	     end;
	
     if token_array.token(1) = "switch_off" | token_array.token(1) = "swf"
     then if token_array.token(2) = SEEN
	then do;
	     switch_off = "1"b;
	     if Ntokens > 2 then first_token = 3;
	     end;
          else do;
	     P_code = xmail_err_$bad_response;
	     goto LIST_EXIT;
	     end;

          if (switch_on | switch_off)
	then n_tokens = (Ntokens + n_tokens - 3);
	else n_tokens = (Ntokens + n_tokens -1);                             /* take off the "" */

     do token_index = first_token to Ntokens;
	if token_array.token(token_index) = SEEN |
	     token_array.token(token_index) = ALL | token_array.token(token_index) = A | 
	     token_array.token(token_index) = NEW | 
	     token_array.token(token_index) = UNSEEN
	     then n_tokens = mailbox.n_messages;
	end;

     call alloc_msg_struct (n_tokens, curr_msgsp);	
     call alloc_msg_struct (n_tokens, nonexist_msgsp);
     curr_count, nonexist_count = 0;

     do token_index = first_token to Ntokens while (token_array.token(token_index) ^= "");     
	now_in_struct = "0"b;
	if index (token_array.token(token_index), ":") > 0             /* we have a range */
		then have_range = "1"b;
	     else
	     if token_array.token(token_index) = LAST | token_array.token(token_index) = L      /* want the last msg */
	     then msg_num = get_num((token_array.token(token_index)), code);
	     else
	     if token_array.token(token_index) = FIRST | token_array.token(token_index) = F     /* want the first msg */
               then msg_num = get_num((token_array.token(token_index)), code);
	     else
               if verify (token_array.token(token_index), "0123456789") = 0   /* single msg number */
	     then msg_num = cv_dec_check_ ((token_array.token(token_index)), code); 
	     else
	     if token_array.token(token_index) = NEW then do;
	     call new_since_last_seen (curr_count);
	     now_in_struct = "1"b;
	     end;
	     else
	     if token_array.token(token_index) = SEEN then do;
	     call seen_current (curr_count);
	     now_in_struct = "1"b;
	     end;
	     else
	     if token_array.token(token_index) = UNSEEN then do;
	     call unseen_current (curr_count);
	     now_in_struct = "1"b;
	     end;
	     else
	     if token_array.token(token_index) = ALL | token_array.token(token_index) = A then do;
	     call all_current (curr_count);
	     now_in_struct = "1"b;
	     end;
	     else code = xmail_err_$invalid_list;

	     if code ^= 0
	     then do;
		P_code = xmail_err_$invalid_list;
		go to LIST_EXIT;
	     end;
	     if have_range 
		then do msg_num = left_num to right_num;
		if ^already_specified (msg_num, curr_msgsp)
		then if want_deleted_msgs = msg_deleted (msg_num)
		     then call add_to_msg_struct (curr_msgsp, curr_count, msg_num);
		     else call add_to_msg_struct (nonexist_msgsp, nonexist_count ,msg_num);
		     have_range = "0"b;
		     end;
	     else
	     if ^now_in_struct & (^already_specified (msg_num, curr_msgsp))
	     then do;
		if msg_num >= 1 & msg_num <= mailbox.n_messages
		then do;
		     if want_deleted_msgs = msg_deleted (msg_num)
		     then call add_to_msg_struct (curr_msgsp, curr_count, msg_num);
		     else call add_to_msg_struct (nonexist_msgsp, nonexist_count, msg_num);
		end;
		else call add_to_msg_struct (nonexist_msgsp, nonexist_count, msg_num);
		end;

	     end;

	     curr_msgs.count = curr_count;
	     call set_counts (curr_count, nonexist_count, P_code);

LIST_EXIT: 
	     if token_array_ptr ^= null then do;
		call release_temp_segment_ (ME_CHAR, token_array_ptr, (0));
		token_array_ptr = null;
		end;
	     return;
     end interpret_list;

search: proc (P_code);

	dcl     P_code		 fixed bin (35);
	dcl     search_str		 char (256) var;

	P_code = 0;

	search_str = "";
	do while (search_str = "");
	     call xmail_get_str_ ((SEARCH_STR_PROMPT), DUMMY_ANSWER_ARRAY, PROMPT_REPLIES_HELP, SEARCH_STR_INFO, search_str);
	end;

	call search_current ((search_str));

	if curr_msgs.count = 0
	then P_code = xmail_err_$str_not_found;

	return;
     end search;

search_current: proc (P_search_str);

	dcl     P_search_str	 char (*);

	dcl     i			 fixed bin;
	dcl     count		 fixed bin;
	dcl     msg_has_str		 bit (1) aligned;

	dcl     1 auto_search_options	 like search_options;

	auto_search_options.version = SEARCH_OPTIONS_VERSION_2;
	auto_search_options.regexp_search = "0"b;
	auto_search_options.case_insensitive = "0"b;
	auto_search_options.search_envelope = "1"b;
	auto_search_options.search_header = "1"b;
	auto_search_options.search_redistributions_list = "1"b;
	auto_search_options.search_body = "1"b;
	auto_search_options.mbz = "0"b;

	call alloc_msg_struct (mailbox.n_messages, curr_msgsp);
	count = 0;

	do i = 1 to mailbox.n_messages;
	     if ^msg_deleted (i)
	     then do;
		if mailbox.messages (i).message_ptr = null
		then do;
		     call mail_system_$read_message (mailbox_ptr, i, code);
		     if code ^= 0
		     then call xmail_error_$no_code (code, ME_CHAR, "l", "Unable to read message ^d. This is an internal programming error.", i);
		end;
		message_ptr = mailbox.messages (i).message_ptr;
		msg_has_str = mlsys_utils_$search_message (message_ptr, P_search_str, addr (auto_search_options), code);
		if code = 0
		then do;
		     if msg_has_str
		     then call add_to_msg_struct (curr_msgsp, count, i);
		end;
	     end;
	end;					/* do i = ... */

	curr_msgs.count = count;
	return;
     end search_current;

date_search: proc (P_code);

	dcl     P_code		 fixed bin (35);    /* output */

	dcl     ds_ascii_date_1	 char (22);         /* formatted */
	dcl     ds_ascii_date_2	 char (22);         /* formatted */
	dcl     ds_clock_value_1       fixed bin (71);    /* converted */
	dcl     ds_clock_value_2       fixed bin (71);    /* converted */
	dcl     ds_date_str_1	 char (256) var;    /* user input */
	dcl     ds_date_str_2	 char (256) var;    /* user input */

/* BEGIN */

	P_code = 0;
RESTART:	   
	ds_clock_value_1 = 0;
	ds_clock_value_2 = 0;

	do while (ds_clock_value_1 = 0);
	     ds_date_str_1 = "";
               call xmail_get_str_ ((DATE_1_PROMPT), DUMMY_ANSWER_ARRAY, PROMPT_REPLIES_HELP, DATE_INFO, ds_date_str_1);
	     if ds_date_str_1 = ""                        /* 1st date null, check 2nd */
	     then go to DATE2;
	     else ds_clock_value_1 = convert_date ((ds_date_str_1));
	end;

DATE2:
	do while (ds_clock_value_2 = 0);
	     ds_date_str_2 = "";
	     call xmail_get_str_ ((DATE_2_PROMPT), DUMMY_ANSWER_ARRAY, PROMPT_REPLIES_HELP, DATE_INFO, ds_date_str_2);

/* If there are two dates entered, make the 2nd date with 23:59 time */

	     if ds_date_str_1 ^= "" & ds_date_str_2 ^= "" 
	     then do;
		ds_clock_value_2 = convert_date ((ds_date_str_2));
		if ds_clock_value_2 ^= 0
		then ds_clock_value_2 = ds_clock_value_2 + ONE_DAY;
	     end;
	                                                  
/* If both dates are null, use current date with 00:00 time as 1st clock
   date.  The 2nd date will be current date with 23:59 time.  */

	     else if ds_date_str_1 = "" & ds_date_str_2 = "" /* both null */
	     then do;
		ds_date_str_1 = TODAY;
		ds_clock_value_1 = convert_date ((ds_date_str_1));
	          if ds_clock_value_1 ^= 0
                    then ds_clock_value_2 = ds_clock_value_1 + ONE_DAY;  /* add one day minus one microsecond to get the full day. */
	     end;

/* If either dates are null, make the entered date the 1st clock 
   date with 00:00 time.  The 2nd clock date will be the same 
   date with 23:59 time.  */

               else do;
	          if ds_date_str_1 = "" & ds_date_str_2 ^= ""  /* 1st null */
    	          then ds_clock_value_1 = convert_date ((ds_date_str_2));
	          else ds_clock_value_1 = convert_date ((ds_date_str_1));

                    if ds_clock_value_1 ^= 0
                    then ds_clock_value_2 = ds_clock_value_1 + ONE_DAY;  /* add one day minus one microsecond to get the full day of the 1st date */
	     end;
	end;                                              /* do while */

/* Convert new clock values to ascii date strings for message to user */

          ds_ascii_date_1 = date_time_$format ("^my/^dm/^yc  ^Hd:^MH ^xxxxza", (ds_clock_value_1), "", "");
          ds_ascii_date_2 = date_time_$format ("^my/^dm/^yc  ^Hd:^MH ^xxxxza", (ds_clock_value_2), "", "");

	if ds_clock_value_1 >= ds_clock_value_2           /* check if dates backwards */
	then do;
	     call ioa_ ("The range of ^/  ""^a"" thru ""^a"" is empty or backwards.", ds_ascii_date_1, ds_ascii_date_2);
	     go to RESTART;
	end;

	call ioa_ ("Selecting messages from ^/  ""^a"" thru ""^a"".", ds_ascii_date_1, ds_ascii_date_2);
	call timer_manager_$sleep (8, SECONDS);           /* let user read */
	
	call date_current ((ds_clock_value_1), (ds_clock_value_2));

	if curr_msgs.count = 0
	then P_code = xmail_err_$date_not_found;

	return;
     end date_search;

/* Internal function to convert a date string into a clock value
   and clear out the time to 00:00 (midnight).         */

convert_date: proc (P_date_string) returns (fixed bin (71));

	dcl     P_date_string          char (*);          /* input */

	dcl     cd_clock_value         fixed bin (71);    /* output */
	dcl     cd_code                fixed bin (35);

	cd_clock_value = 0;
	Ptime_value = null;                               /* clear ptr */

	call convert_date_to_binary_ ((P_date_string), cd_clock_value, cd_code);
          if cd_code ^= 0 
          then do;
	     call ioa_ ("There is something wrong with the date or time as entered. ^/  Try again or use ? to get help.");
	     go to cd_EXIT;
	end;

/* Zero out the time */

          allocate time_value in (based_area);
	time_value.version = Vtime_value_3; 

	call date_time_$from_clock ((cd_clock_value), "", addr (time_value), cd_code);
          if cd_code ^= 0 
          then do;
               call ioa_ ("There is a problem with converting the date entered. ^/  Try again or use ? to get help.");
	     go to cd_EXIT;
	end;

/* Zero out all but day in calendar value to get date with zero time */

          time_value.yc = 0;      
	time_value.my = 0;
	time_value.dm = 0;
	time_value.Hd = 0;
	time_value.MH = 0;
	time_value.SM = 0;
	time_value.US = 0;
	time_value.fw = 0;
	time_value.dw = 0;
	time_value.dy = 0;
	time_value.Uc = 0;
	time_value.leap_year = 0;

	call date_time_$to_clock (addr (time_value), cd_clock_value, cd_code);
          if cd_code ^= 0 
          then do;
	     call ioa_ ("There is a problem with converting the date entered. ^/  Try again or use ? to get help.");
	     go to cd_EXIT;
	end;
	
cd_EXIT:
	if Ptime_value ^= null then free time_value;      /* free if allocated */
	return (cd_clock_value);
     end convert_date;

date_current: proc (P_clock_value_1, P_clock_value_2);

	dcl     P_clock_value_1	 fixed bin (71);    /* input */
	dcl     P_clock_value_2	 fixed bin (71);    /* input */

	dcl     i			 fixed bin;
	dcl     dc_count		 fixed bin;

	call alloc_msg_struct (mailbox.n_messages, curr_msgsp);
	dc_count = 0;

	do i = 1 to mailbox.n_messages;
	     if ^msg_deleted (i)
	     then do;
		if mailbox.messages (i).message_ptr = null
		then do;
		     call mail_system_$read_message (mailbox_ptr, i, code);
		     if code ^= 0
		     then call xmail_error_$no_code (code, ME_CHAR, "l", "Unable to read message ^d. This is an internal programming error.", i);
		end;
		message_ptr = mailbox.messages (i).message_ptr;

/* Test if date created in message header is between 1st and 2nd date/time */

		if (message.date_time_created >= P_clock_value_1) & (message.date_time_created <= P_clock_value_2)
		
		then call add_to_msg_struct (curr_msgsp, dc_count, i);
	     end;
	end;					/* do i = ... */

	curr_msgs.count = dc_count;
	return;
     end date_current;

next_token: proc (P_token_list) returns (char (*) var);

	dcl     P_token_list	 char (*) var;
	dcl     token		 char (length (P_token_list)) var;

	token = before (ltrim (P_token_list), " ");
	P_token_list = after (P_token_list, token);

	return (token);

     end next_token;

add_to_msg_struct: proc (P_msg_structp, P_count, P_msg_num);

	dcl     P_msg_structp	 ptr;
	dcl     (P_count, P_msg_num)	 fixed bin;

	msg_structp = P_msg_structp;
	P_count = P_count + 1;
	msg_struct.numbers (P_count) = P_msg_num;

	return;
     end add_to_msg_struct;

use_spec_msgs: proc (P_curr_msgsp, P_spec_msgsp);

	dcl     (P_curr_msgsp, P_spec_msgsp) ptr;

	if P_curr_msgsp ^= null then free P_curr_msgsp -> curr_msgs;
	P_curr_msgsp = P_spec_msgsp;

	return;
     end use_spec_msgs;

want_some: proc () returns (bit (1));

	dcl     yes_sw		 bit (1) aligned;

	call ioa_ ("^[^s^]^a", want_deleted_msgs, CURR_SET_MSG, CURR_DEL_SET_MSG);
	call ioa_ ("^(^-^d^/^)", curr_msgs.numbers);

	call xmail_get_str_$yes_no ((USE_SPEC_SET_PROMPT), yes_sw);

	return (yes_sw);

     end want_some;

msg_deleted: proc (P_msg_num) returns (bit (1));

	dcl     P_msg_num		 fixed bin;

	if mailbox.messages (P_msg_num).message_ptr = null
	then do;
	     call mail_system_$read_message (mailbox_ptr, P_msg_num, code);
	     if code ^= 0
	     then call xmail_error_$no_code (code, ME_CHAR, "l", "Unable to read message ^d. This is an internal programming error.", P_msg_num);
	end;
	message_ptr = mailbox.messages (P_msg_num).message_ptr;
	if message.marked_for_deletion
	then return ("1"b);
	else return ("0"b);

     end msg_deleted;

msg_seen: proc (P_msg_num) returns (bit (1));
	
	dcl   P_msg_num          fixed bin;
	
	if mailbox.messages (P_msg_num).message_ptr = null
	     then do;
	     call mail_system_$read_message (mailbox_ptr, P_msg_num, code);
	     if code ^= 0
		then call xmail_error_$no_code ( code, ME_CHAR, "l", "Unable to read message ^d. This is an interna;
	 programming error.", P_msg_num);
	     end;
	message_ptr = mailbox.messages (P_msg_num).message_ptr;
	if message.seen then return ("1"b);
	else return ("0"b);
	
	end msg_seen;

set_counts: proc (P_curr_count, P_nonexist_count, P_code);

	dcl     (P_curr_count, P_nonexist_count) fixed bin;
	dcl     P_code		 fixed bin (35);

	P_code = 0;

	if P_curr_count = 0				/* None of the specified messages exist. */
	then do;
	     free curr_msgs;
	     free nonexist_msgs;
	     P_code = xmail_err_$no_msgs_exist;
	     return;
	end;
	else curr_msgs.count = P_curr_count;

	if P_nonexist_count = 0			/* All exist. */
	then free nonexist_msgs;
	else do;					/* Some exist. */
	     nonexist_msgs.count = P_nonexist_count;
	     if want_deleted_msgs
	     then P_code = xmail_err_$some_del_msgs_exist;
	     else P_code = xmail_err_$some_msgs_exist;
	end;

	return;
     end set_counts;

alloc_msg_struct: proc (P_n_messages, P_msg_structp);

	dcl     P_n_messages	 fixed bin;
	dcl     P_msg_structp	 ptr;

	n_messages = P_n_messages;
	allocate msg_struct in (based_area);
	msg_struct.version = MSG_STRUCT_VERSION_1;
	P_msg_structp = msg_structp;

	return;
     end alloc_msg_struct;

get_num: proc (P_str, P_code) returns (fixed bin);

	dcl     P_code		 fixed bin (35);
	dcl     P_str		 char (*);

	P_code = 0;

	if P_str = FIRST | P_str = F
	then do;
	     if want_deleted_msgs
	     then return (first_deleted ());
	     else return (first_existing ());
	end;
	else if P_str = LAST | P_str = L
	then do;
	     if want_deleted_msgs
	     then return (last_deleted ());
	     else return (last_existing ());
	end;
	else return (cv_dec_check_ (P_str, P_code));

     end get_num;

first_existing: proc () returns (fixed bin);

	dcl     existing		 fixed bin;
	dcl     i			 fixed bin;

	existing = 0;
	do i = 1 to mailbox.n_messages while (existing = 0);
	     if ^msg_deleted (i) then existing = i;
	end;

	return (existing);

     end first_existing;

first_deleted: proc () returns (fixed bin);

	dcl     deleted		 fixed bin;
	dcl     i			 fixed bin;

	deleted = 0;
	do i = 1 to mailbox.n_messages while (deleted = 0);
	     if msg_deleted (i) then deleted = i;
	end;

	return (deleted);

     end first_deleted;

last_existing: proc () returns (fixed bin);

	dcl     existing		 fixed bin;
	dcl     i			 fixed bin;

	existing = 0;
	do i = mailbox.n_messages to -1 by -1 while (existing = 0);
	     if ^msg_deleted (i) then existing = i;
	end;

	return (existing);

     end last_existing;

last_deleted: proc () returns (fixed bin);

	dcl     deleted		 fixed bin;
	dcl     i			 fixed bin;

	deleted = 0;
	do i = mailbox.n_messages to 1 by -1 while (deleted = 0);
	     if msg_deleted (i) then deleted = i;
	end;

	return (deleted);

     end last_deleted;

already_specified: proc (P_msg_num, P_curr_msgsp) returns (bit (1));

	dcl     i			 fixed bin;
	dcl     P_curr_msgsp	 ptr;
	dcl     P_msg_num		 fixed bin;

	do i = 1 to P_curr_msgsp -> curr_msgs.count;
	     if P_msg_num = P_curr_msgsp -> curr_msgs.numbers (i)
	     then return ("1"b);
	end;

	return ("0"b);

     end already_specified;

   end xmail_select_msgs_;
