/****^  *************************************************************************
        *                                                                       *
        * Copyright (c) 1984 by Centre Interuniversitaire de Calcul de Grenoble *
        * and Institut National de Recherche en Informatique et Automatique     *
        *                                                                       *
        ************************************************************************* */


/****^  HISTORY COMMENTS:
  1) change(86-10-05,JMAthane), approve(86-10-05,MCR7521),
     audit(86-10-09,JPFauche), install(86-11-12,MR12.0-1212):
     Pascal version for MR12.
                                                   END HISTORY COMMENTS */

/* format: style4,^linecom,^ifthendo,^indproc,^indblkcom,initcol1,declareind8,dclind4,struclvlind1 */
pascal_symbol_: proc;

	return;

%page;

dcl memorize_refs bit (1) int static init ("0"b);

dcl 1 referenced_item based (ref_ptr),
     2 item_addr ptr,
     2 item_next ptr,
     2 item_type fixed bin (35),
     2 item_size fixed bin (35),
     2 item_nbr fixed bin (35),
     2 item_displayed bit (1),
     2 item_type_addr ptr;

dcl probe_check_ptr_$check entry (ptr, fixed bin (35));
dcl probe_check_ptr_$convert entry (ptr, bit (*)) returns (char (256) varying);
dcl probe_check_ptr_$check_packed entry (ptr unal, fixed bin (35));
dcl probe_check_ptr_$indirectable entry (ptr, fixed bin (35));

dcl error_code fixed bin (35);

dcl any bit (1);
dcl (ref_ptr, item_place, prev_ref, this_ref, sttm_p) ptr;
dcl 1 empty_subscripts like pascal_subscript_info;

dcl (first_ref, last_ref) ptr int static init (null);

memorize_refs_on: entry;

	memorize_refs = "1"b;
	return;

memorize_refs_off: entry;

	memorize_refs = "0"b;
	return;

clear_references: entry;

clear:
	ref_ptr = first_ref;
	do while (ref_ptr ^= null);
	     first_ref = item_next;
	     free referenced_item;
	     ref_ptr = first_ref;
	end;
	last_ref = null;
	return;

display_references: entry (P_output_switch, P_margin, P_ind_units, P_code);

	long_switch = "1"b;
	name_sw = "1"b;
	P_code = 0;
	nl_sw = "1"b;
	done = "0"b;
	Base_addr,
	     Linkage_ptr,
	     Stack_ptr,
	     Block_ptr = null;
	empty_subscripts.number = 0;
again:
	this_ref = first_ref;
	any = "0"b;
	do while (this_ref ^= null);
	     if ^(this_ref -> item_displayed) then do;
		if ^any then call ioa_ ("
		---------------------------");
		call ioa_ ("
. item at " ||
		     probe_check_ptr_$convert (this_ref -> item_addr, ""b));
		call print_thing (0, this_ref -> item_type, this_ref -> item_type_addr, this_ref -> item_size, this_ref -> item_addr,
		     "(" || short_type_name (this_ref -> item_type, this_ref -> item_type_addr) || ")",
		     empty_subscripts, done);
		this_ref -> item_displayed = "1"b;
		any = "1"b;
	     end;
	     this_ref = this_ref -> item_next;
	end;
	if any then go to again;
	go to clear;
%page;
display_declaration: entry (P_symbp, P_output_switch, P_margin, P_ind_units, P_switches, P_code);

dcl P_symbp ptr;					/* ptr to PASCAL symbol node */
dcl P_output_switch ptr;				/* io switch for output */
dcl P_margin fixed bin (35);				/* margin (left) */
dcl P_ind_units fixed bin (35);			/* indentation units */
dcl 1 P_switches,
     2 name bit (1) unal,				/* if name must be printed */
     2 declaration bit (1) unal,			/* if declaration must be printed */
     2 status bit (1) unal,				/* if status must be printed */
     2 long bit (1) unal,
     2 nl bit (1) unal;				/* if new_line must be printed after */
dcl P_code fixed bin (35);				/* output : standard error code */


dcl Ind fixed bin (35) init (0);
dcl Sym ptr;
dcl ioa_$ioa_switch entry options (variable);
dcl ioa_ entry options (variable);
dcl ioa_$ioa_switch_nnl entry options (variable);
dcl iox_$put_chars entry (ptr, ptr, fixed bin (35), fixed bin (35));
dcl c fixed bin;
dcl (long_switch, name_sw, status_sw, dcl_sw, nl_sw) bit (1) init ("0"b);
dcl Name_p ptr;
dcl (p1, p2) ptr;
dcl 1 P_type_info like runtime_type_info;
dcl 1 P_address_info like runtime_address_info;
dcl 1 pascal_char based,
     2 pad bit (27) unal,
     2 char char (1) unal;
dcl (addr, addrel, copy, length, null, rtrim, substr, unspec, collate, fixed) builtin;

%page;

	if P_symbp = null then return;

	long_switch = P_switches.long;
	dcl_sw = P_switches.declaration;
	status_sw = P_switches.status;
	name_sw = P_switches.name;
	nl_sw = P_switches.nl;
	P_code = 0;
	Sym = P_symbp;
	Name_p = runtime_symbol_info_$name (Sym);
	P_type_info.version = RUNTIME_TYPE_INFO_VERSION_1;
	call runtime_symbol_info_$type (Sym, addr (P_type_info), P_code);
	if P_code ^= 0 then go to RETURN_HERE;

	if (P_type_info.type = pascal_typed_pointer_type_dtype)
	     | (P_type_info.type = pascal_record_file_type_dtype)
	     | (P_type_info.type = pascal_record_type_dtype)
	     | (P_type_info.type = pascal_set_dtype)
	     | (P_type_info.type = pascal_enumerated_type_dtype)
	     | (P_type_info.type = pascal_string_type_dtype)
	     | (P_type_info.type = pascal_user_defined_type_dtype) then do;
	     if name_sw then
		if Name_p ^= null then
		     call ioa_$ioa_switch_nnl (P_output_switch, "^a = ", Name_p -> acc.string);
	     if dcl_sw then do;
		call print_type_value (Sym, Ind);
	     end;
	     if status_sw then do;
		if dcl_sw then do;
		     call ioa_$ioa_switch (P_output_switch, "");
		     call indent (0);
		end;
		call ioa_$ioa_switch_nnl (P_output_switch,
		     "type declared in ^a", get_dcl_block_name (Sym));
	     end;
	end;

	else if P_type_info.type = pascal_value_formal_parameter_dtype then do;
	     if name_sw then
		if Name_p ^= null then
		     call ioa_$ioa_switch_nnl (P_output_switch, "^a : ", Name_p -> acc.string);
	     if dcl_sw then do;
		call print_pascal_var_type ((P_type_info.type), P_type_info.type_addr, Ind);
	     end;
	     if status_sw then do;
		if dcl_sw then do;
		     call ioa_$ioa_switch (P_output_switch, "");
		     call indent (0);
		end;
		call ioa_$ioa_switch_nnl (P_output_switch,
		     "formal variable parameter to ^a, passed by address", get_dcl_block_name (Sym));
	     end;
	end;

	else if P_type_info.type = pascal_variable_formal_parameter_dtype then do;
	     if name_sw then
		if Name_p ^= null then
		     call ioa_$ioa_switch_nnl (P_output_switch, "^a : ", Name_p -> acc.string);
	     if dcl_sw then do;
		call print_pascal_var_type ((P_type_info.type), P_type_info.type_addr, Ind);
	     end;
	     if status_sw then do;
		if dcl_sw then do;
		     call ioa_$ioa_switch (P_output_switch, "");
		     call indent (0);
		end;
		call ioa_$ioa_switch_nnl (P_output_switch,
		     "formal variable parameter to ^a, passed by value", get_dcl_block_name (Sym));
	     end;
	end;

	else if P_type_info.type = pascal_entry_formal_parameter_dtype then do;
	     if ^dcl_sw then
		if name_sw then
		     if Name_p ^= null then
			call ioa_$ioa_switch_nnl (P_output_switch, "^a : ", Name_p -> acc.string);
	     if dcl_sw then do;
		if name_sw & (Name_p ^= null) then
		     call print_proc_type (P_type_info.type_addr, " " || Name_p -> acc.string);
		else
		     call print_proc_type (P_type_info.type_addr, "");
	     end;
	     if status_sw then do;
		if dcl_sw then do;
		     call ioa_$ioa_switch (P_output_switch, "");
		     call indent (0);
		end;
		call ioa_$ioa_switch_nnl (P_output_switch,
		     "formal procedure parameter to ^a", get_dcl_block_name (Sym));
	     end;
	end;

	else if P_type_info.type = pascal_label_dtype then do;
	     if name_sw then
		if Name_p ^= null then
		     call ioa_$ioa_switch_nnl (P_output_switch, "^a : ", Name_p -> acc.string);
	     if status_sw then do;
		if dcl_sw then do;
		     call ioa_$ioa_switch (P_output_switch, "");
		     call indent (0);
		end;
		call ioa_$ioa_switch_nnl (P_output_switch,
		     "label of ^a", get_dcl_block_name (Sym));
	     end;
	end;

	else if P_type_info.type = pascal_parameter_procedure_dtype then do;
	     if ^dcl_sw then
		if name_sw then
		     if Name_p ^= null then
			call ioa_$ioa_switch_nnl (P_output_switch, "^a : ", Name_p -> acc.string);
	     if dcl_sw then do;
		if name_sw & (Name_p ^= null) then
		     call print_proc_type (P_type_info.type_addr, " " || Name_p -> acc.string);
		else
		     call print_proc_type (P_type_info.type_addr, "");
	     end;
	     if status_sw then do;
		if dcl_sw then do;
		     call ioa_$ioa_switch (P_output_switch, "");
		     call indent (0);
		end;
		call ioa_$ioa_switch_nnl (P_output_switch, "procedure parameter of ^a", get_dcl_block_name (Sym));
	     end;
	end;

	else if P_type_info.type = pascal_internal_procedure_dtype then do;
	     if ^dcl_sw then
		if name_sw then
		     if Name_p ^= null then
			call ioa_$ioa_switch_nnl (P_output_switch, "^a : ", Name_p -> acc.string);
	     if dcl_sw then do;
		if name_sw & (Name_p ^= null) then
		     call print_proc_type (P_type_info.type_addr, " " || Name_p -> acc.string);
		else
		     call print_proc_type (P_type_info.type_addr, "");
	     end;
	     if status_sw then do;
		if dcl_sw then do;
		     call ioa_$ioa_switch (P_output_switch, "");
		     call indent (0);
		end;
		call ioa_$ioa_switch_nnl (P_output_switch, "procedure internal to ^a", get_dcl_block_name (Sym));
	     end;
	end;

	else if P_type_info.type = pascal_exportable_procedure_dtype then do;
	     if ^dcl_sw then
		if name_sw then
		     if Name_p ^= null then
			call ioa_$ioa_switch_nnl (P_output_switch, "^a : ", Name_p -> acc.string);
	     if dcl_sw then do;
		if name_sw & (Name_p ^= null) then
		     call print_proc_type (P_type_info.type_addr, " " || Name_p -> acc.string);
		else
		     call print_proc_type (P_type_info.type_addr, "");
	     end;
	     if status_sw then do;
		if dcl_sw then do;
		     call ioa_$ioa_switch (P_output_switch, "");
		     call indent (0);
		end;
		if runtime_symbol_info_$father (Sym) ^= null then
		     if runtime_symbol_info_$father (Sym) -> runtime_block.name = "0"b then
			call ioa_$ioa_switch_nnl (P_output_switch, "main procedure");
		     else
			call ioa_$ioa_switch_nnl (P_output_switch, "procedure exported by program ^a", get_dcl_block_name (Sym));
	     end;
	end;

	else if P_type_info.type = pascal_imported_procedure_dtype then do;
	     if ^dcl_sw then
		if name_sw then
		     if Name_p ^= null then
			call ioa_$ioa_switch_nnl (P_output_switch, "^a : ", Name_p -> acc.string);
	     if dcl_sw then do;
		if name_sw & (Name_p ^= null) then
		     call print_proc_type (P_type_info.type_addr, " " || Name_p -> acc.string);
		else
		     call print_proc_type (P_type_info.type_addr, "");
	     end;
	     if status_sw then do;
		if dcl_sw then do;
		     call ioa_$ioa_switch (P_output_switch, "");
		     call indent (0);
		end;
		call ioa_$ioa_switch_nnl (P_output_switch, "procedure imported by program ^a", get_dcl_block_name (Sym));
	     end;
	end;

	else do;					/* fields or variables */
	     if name_sw then
		if Name_p ^= null then
		     call ioa_$ioa_switch_nnl (P_output_switch, "^a : ", Name_p -> acc.string);
	     if dcl_sw then do;
		call print_pascal_var_type ((P_type_info.type), P_type_info.type_addr, Ind);
	     end;
	     if status_sw then do;
		if dcl_sw then do;
		     call ioa_$ioa_switch (P_output_switch, "");
		     call indent (0);
		end;
		if runtime_symbol_info_$level (P_symbp) = 2 then do;
		     p1 = runtime_symbol_info_$father (P_symbp);
		     p2 = runtime_symbol_info_$name (p1);
		     if p2 ^= null then
			call ioa_$ioa_switch_nnl (P_output_switch,
			     "^[selector ^]field in record type ^a",
			     runtime_symbol_info_$n_variants (P_symbp) ^= 0,
			     p2 -> acc.string);
		     else
			call ioa_$ioa_switch_nnl (P_output_switch, "^[selector ^]field",
			     runtime_symbol_info_$n_variants (P_symbp) ^= 0);
		end;
		else if Sym -> pascal_symbol_node_header.in_with_block then do;
		     p1 = runtime_symbol_info_$father (Sym);
		     if p1 -> with_symbol_block.map.first = 0 then sttm_p = null;
		     else sttm_p = addrel (p1, p1 -> with_symbol_block.map.first);
		     call ioa_$ioa_switch_nnl (P_output_switch,
			"field in ""with ^a"" block^[ beginning at line ^[^d-^;^s^]^d^]",
			addrel (p1, p1 -> with_symbol_block.with_string) -> acc.string,
			sttm_p ^= null, sttm_p -> statement_map.file ^= "0"b,
			fixed (sttm_p -> statement_map.file, 8), fixed (sttm_p -> statement_map.line, 14));
		end;
		else do;
		     P_address_info.version = RUNTIME_ADDRESS_INFO_VERSION_1;
		     call runtime_symbol_info_$address (Sym, addr (P_address_info), P_code);
		     if P_code ^= 0 then go to RETURN_HERE;
		     if P_address_info.class = pascal_local_class_code then
			call ioa_$ioa_switch_nnl (P_output_switch,
			     "variable local to ^a", get_dcl_block_name (Sym));
		     else if P_address_info.class = pascal_internal_global_class_code then
			call ioa_$ioa_switch_nnl (P_output_switch,
			     "variable global of program ^a", get_dcl_block_name (Sym));
		     else if P_address_info.class = pascal_external_global_class_code
			     | P_address_info.class = pascal_ext_file_class_code then
			call ioa_$ioa_switch_nnl (P_output_switch,
			     "variable global of ^a, external", get_dcl_block_name (Sym));
		     else if P_address_info.class = pascal_parameter_class_code then
			call ioa_$ioa_switch_nnl (P_output_switch,
			     "variable parameter of ^a", get_dcl_block_name (Sym));
		     else if P_address_info.class = pascal_constant_in_symbol_class_code then
			call ioa_$ioa_switch_nnl (P_output_switch,
			     "constant declared in ^a", get_dcl_block_name (Sym));
		     else call ioa_$ioa_switch_nnl (P_output_switch,
			     "(unknown class) declared in ^a", get_dcl_block_name (Sym));
		end;
	     end;
	end;

	if nl_sw then
	     call ioa_$ioa_switch (P_output_switch, "");

RETURN_HERE:
	return;
%page;
display_var_type: entry (P_type, P_type_ptr, P_output_switch, P_margin, P_ind_units, P_sw, P_code);

dcl P_type fixed bin (35);
dcl P_type_ptr ptr;
dcl 1 P_sw,
     2 long bit (1) unal,
     2 nl bit (1) unal;

	long_switch = P_sw.long;
	nl_sw = P_sw.nl;
	P_code = 0;

	call print_pascal_var_type (P_type, P_type_ptr, Ind);
	if nl_sw then
	     call ioa_$ioa_switch (P_output_switch, "");

	return;
%page;
display_data: entry (P_type, P_type_ptr, P_output_switch, P_margin, P_ind_units,
	P_sws, P_stack_ptr, P_linkage_ptr, P_block_ptr, P_subscripts, P_address, P_name, P_size, P_code);

dcl P_stack_ptr ptr;
dcl Stack_ptr ptr;
dcl 1 P_sws,
     2 name bit (1) unal,
     2 long bit (1) unal,
     2 nl bit (1) unal;
dcl P_size fixed bin (35);
dcl P_name char (256) var;
dcl Base_addr ptr;
dcl P_address ptr;
dcl P_linkage_ptr ptr;
dcl Linkage_ptr ptr;
dcl P_block_ptr ptr;
dcl Block_ptr ptr;
dcl 1 P_subscripts like pascal_subscript_info;
dcl done bit (1) aligned;

	long_switch = P_sws.long;
	Stack_ptr = P_stack_ptr;
	Block_ptr = P_block_ptr;
	Linkage_ptr = P_linkage_ptr;
	name_sw = P_sws.name;
	P_code = 0;
	nl_sw = P_sws.nl;
	done = "0"b;
	Base_addr = null;

	call print_thing (0, P_type, P_type_ptr, P_size, P_address, P_name, P_subscripts, done);



	return;

%page;
get_real_type: proc (P_type, P_type_ptr, P_real_type, P_real_type_ptr);

dcl (P_type, P_real_type) fixed bin (35);
dcl (P_type_ptr, P_real_type_ptr) ptr;

dcl 1 type_info like runtime_type_info;

	if P_type = pascal_user_defined_type_instance_dtype then do;
	     type_info.version = RUNTIME_TYPE_INFO_VERSION_1;
	     call runtime_symbol_info_$type (P_type_ptr, addr (type_info), P_code);
	     if P_code ^= 0 then go to RETURN_HERE;
	     if type_info.has_subrange_limits then do;
		P_real_type = type_info.base_type;
		P_real_type_ptr = type_info.base_type_addr;
		return;
	     end;
	end;
	P_real_type = P_type;
	P_real_type_ptr = P_type_ptr;
	return;

     end get_real_type;
%page;
indice_id: proc (P_type, P_type_ptr, P_value) returns (char (32) varying);

dcl P_type fixed bin (35);
dcl P_type_ptr ptr;
dcl P_value fixed bin (35);


dcl (null, maxlength) builtin;
dcl pascal_char char (1);
dcl arithmetic_to_ascii_ entry (ptr, fixed bin, bit (1), fixed bin, fixed bin, char (132) var);
dcl result_string char (132) varying;
dcl real_type fixed bin (35);
dcl type_ptr ptr;
dcl i fixed bin (35);
dcl p1 ptr;


	call get_real_type (P_type, P_type_ptr, real_type, type_ptr);

	if real_type = pascal_integer_dtype then do;
	     call arithmetic_to_ascii_ (addr (P_value), (real_type), "0"b, 35, 0, result_string);
	     return (rtrim (result_string));
	end;
	else if real_type = pascal_char_dtype then do;
	     unspec (pascal_char) = substr (unspec (P_value), 28, 9);
	     return ("'" || pascal_char || "'");
	end;
	else if real_type = pascal_boolean_dtype then do;
	     if P_value = 0 then
		return ("false");
	     else return ("true");
	end;
	else if real_type = pascal_enumerated_type_instance_dtype then do;
	     p1 = runtime_symbol_info_$son (type_ptr);
	     i = 0;
	     do while (p1 ^= null);
		if i = P_value then
		     return (runtime_symbol_info_$name (p1) -> acc.string);
		i = i + 1;
		p1 = runtime_symbol_info_$successor (p1);
	     end;
	end;

	return ("???");				/* never if valid symbol table */
     end;
%page;
get_dcl_block_name: proc (SP) returns (char (32) var);

dcl SP ptr;					/* input : Pointer to the symbol node */
						/* returns the name of the block where it is declared */

dcl work ptr;

	work = runtime_symbol_info_$father (SP);
	if work = null then return ("???");
	if work -> runtime_block.name = "0"b then return ("???");
	return (addrel (work, work -> runtime_block.name) -> acc.string);
     end get_dcl_block_name;
%page;
display_field_list: proc (FP, IND);

dcl FP ptr;					/* Field symbol node Ptr */
dcl IND fixed bin (35);				/* INDentation column */

dcl (it, off) fixed bin (35);
dcl p1 ptr;
dcl n_var fixed bin;
dcl 1 type_info_1 like runtime_type_info;
dcl name_p ptr;

	p1 = FP;
	type_info_1.version = RUNTIME_TYPE_INFO_VERSION_1;
	do while (p1 ^= null);
	     name_p = runtime_symbol_info_$name (p1);
	     call runtime_symbol_info_$type (p1, addr (type_info_1), P_code);
	     if P_code ^= 0 then go to RETURN_HERE;
	     n_variants,
		n_var = runtime_symbol_info_$n_variants (p1);
	     if n_var ^= 0 then begin;
dcl 1 this_variant_info like runtime_variant_info;
		this_variant_info.version = RUNTIME_VARIANT_INFO_VERSION_1;
		call runtime_symbol_info_$variant (p1, addr (this_variant_info), P_code);
		if P_code ^= 0 then go to RETURN_HERE;
		name_p = runtime_symbol_info_$name (p1);
		if name_p ^= null then
		     call ioa_$ioa_switch_nnl (P_output_switch, "case ^a : ", name_p -> acc.string);
		else call ioa_$ioa_switch_nnl (P_output_switch, "case ");
		call runtime_symbol_info_$type (p1, addr (type_info_1), P_code);
		if P_code ^= 0 then go to RETURN_HERE;
		call print_pascal_var_type ((type_info_1.type), type_info_1.type_addr, IND);
		call ioa_$ioa_switch_nnl (P_output_switch, " of");
		off = this_variant_info.first_value_in_set;
		do it = 1 to n_var;
		     if it = 1 then
			call ioa_$ioa_switch (P_output_switch, "");
		     else
			call ioa_$ioa_switch (P_output_switch, ";");
		     call indent (IND + 1);
		     call display_pascal_set ((type_info_1.type), type_info_1.type_addr,
			this_variant_info.set_addr (it), off);
		     call ioa_$ioa_switch_nnl (P_output_switch, " : (");
		     if this_variant_info.case (it).brother_addr ^= null then
			call display_field_list (this_variant_info (it).brother_addr, IND + 2);
		     call ioa_$ioa_switch_nnl (P_output_switch, ")");
		end;
	     end;
	     else do;
		call ioa_$ioa_switch_nnl (P_output_switch, "^[^a^] : ",
		     name_p ^= null, name_p -> acc.string);
		call print_pascal_var_type ((type_info_1.type), type_info_1.type_addr, IND);
	     end;
	     p1 = runtime_symbol_info_$brother (p1);
	     if p1 ^= null then do;
		call ioa_$ioa_switch (P_output_switch, ";");
		call indent (IND);
	     end;
	end;
     end display_field_list;
%page;
display_pascal_set: proc (TC, TP, SP, OF);
dcl TC fixed bin (35);				/* Type Code for elements of set */
dcl TP ptr;					/* Type symbol node Ptr */
dcl SP ptr;					/* set String Ptr */
dcl OF fixed bin (35);				/* Offset in string (value of first bit) */

dcl first bit (1) init ("1"b);
dcl (p2, p1) ptr;
dcl bs bit (100000) unal based (SP);
dcl it fixed bin (35);
dcl 1 type_info_1 like runtime_type_info;
dcl 1 subrange_info_1 like runtime_subrange_info;
dcl fb35b fixed bin (35) based;
dcl max fixed bin (35);

	if TC = pascal_boolean_dtype then do;
	     call ioa_$ioa_switch_nnl (P_output_switch,
		"^[false^]^[,^]^[true^]", substr (bs, 1, 1), substr (bs, 1, 2) = "11"b, substr (bs, 2, 1));
	     return;
	end;
	if TC = pascal_char_dtype then do;
	     do it = 1 to 256;
		if substr (bs, it, 1) = "1"b then do;
		     call ioa_$ioa_switch_nnl (P_output_switch,
			"^[,^]'^a'", first = "0"b, substr (collate (), it, 1));
		     first = "0"b;
		end;
	     end;
	     return;
	end;
	if TP ^= null then do;
	     p1 = TP;
	     type_info_1.version = RUNTIME_TYPE_INFO_VERSION_1;
	     subrange_info_1.version = RUNTIME_SUBRANGE_INFO_VERSION_1;
restart:
	     call runtime_symbol_info_$type (p1, addr (type_info_1), P_code);
	     if P_code ^= 0 then go to RETURN_HERE;
	     if type_info_1.type = pascal_enumerated_type_dtype then do;
		p2 = runtime_symbol_info_$son (p1);
		it = 0;
		do while (p2 ^= null);
		     if it >= OF then do;
			if substr (bs, it - OF + 1, 1) = "1"b then do;
			     call ioa_$ioa_switch_nnl (P_output_switch,
				"^[,^]^a", first = "0"b, runtime_symbol_info_$name (p2) -> acc.string);
			     first = "0"b;
			end;
		     end;
		     p2 = runtime_symbol_info_$successor (p2);
		     it = it + 1;
		end;
		return;
	     end;
	     if (type_info_1.type = pascal_user_defined_type_dtype)
		& (type_info_1.has_subrange_limits)
		& (type_info_1.base_type ^= 0) then do;
		call runtime_symbol_info_$subrange (p1, addr (subrange_info_1), P_code);
		if P_code ^= 0 then return;
		if type_info_1.base_type = pascal_integer_dtype then do;
		     if subrange_info_1.upper_bound_is_encoded then
			max = 0;			/* not yet used . To be modified later */
		     else max = subrange_info_1.subrange_upper_bound;
		     do it = OF to max;
			if substr (bs, it - OF + 1, 1) = "1"b then do;
			     call ioa_$ioa_switch_nnl (P_output_switch,
				"^[,^]^d", first = "0"b, it);
			     first = "0"b;
			end;
		     end;
		     return;
		end;
		if type_info_1.base_type = pascal_char_dtype then do;
		     if subrange_info_1.upper_bound_is_encoded then
			max = 0;			/* not yet used . To be modified later */
		     else max = subrange_info_1.subrange_upper_bound;
		     do it = OF to max;
			if substr (bs, it - OF + 1, 1) = "1"b then do;
			     call ioa_$ioa_switch_nnl (P_output_switch,
				"^[,^]'^a'", first = "0"b, substr (collate (), it + 1, 1));
			     first = "0"b;
			end;
		     end;
		     return;
		end;
		else if type_info_1.base_type = pascal_enumerated_type_instance_dtype then do;
		     p1 = type_info_1.base_type_addr;
		     go to restart;
		end;
	     end;
	end;

	call ioa_$ioa_switch_nnl (P_output_switch, "(unable to print set of values)");

     end display_pascal_set;
%page;
print_proc_type: proc (SP, NAME);

dcl SP ptr;					/* (input) ptr to proc type symbol node */
dcl NAME char (33) varying;				/* (input) name to be printed (if necessary) */

dcl is_function bit (1) init ("0"b);
dcl 1 proc_type_info like runtime_type_info;
dcl 1 param_type_info like runtime_type_info;
dcl p ptr;
dcl np ptr;
dcl name char (32) varying;

	if SP = null then do;
	     call ioa_$ioa_switch_nnl (P_output_switch, "procedure^a", NAME);
	     return;
	end;

	proc_type_info.version = RUNTIME_TYPE_INFO_VERSION_1;
	param_type_info.version = RUNTIME_TYPE_INFO_VERSION_1;

	call runtime_symbol_info_$type (SP, addr (proc_type_info), P_code);
	if P_code ^= 0 then go to RETURN_HERE;
	if proc_type_info.base_type ^= 0 then do;
	     is_function = "1"b;
	     call ioa_$ioa_switch_nnl (P_output_switch, "function^a ", NAME);
	end;
	else
	     call ioa_$ioa_switch_nnl (P_output_switch, "procedure^a ", NAME);

	p = runtime_symbol_info_$son (SP);
	if p ^= null then do;
	     call ioa_$ioa_switch_nnl (P_output_switch, "(");
next_param:
	     np = runtime_symbol_info_$name (p);
	     if np ^= null then name = np -> acc.string;
	     else name = "";
	     call runtime_symbol_info_$type (p, addr (param_type_info), P_code);
	     if P_code ^= 0 then go to RETURN_HERE;
	     if param_type_info.type = pascal_entry_formal_parameter_dtype then
		call print_proc_type (param_type_info.type_addr, " " || name);
	     else do;
		if param_type_info.type = pascal_variable_formal_parameter_dtype then
		     call ioa_$ioa_switch_nnl (P_output_switch, "var ^a : ", name);
		else
		     call ioa_$ioa_switch_nnl (P_output_switch, "^a : ", name);
		call print_pascal_var_type ((param_type_info.base_type), param_type_info.base_type_addr, Ind);
	     end;
	     p = runtime_symbol_info_$brother (p);
	     if p = null then
		call ioa_$ioa_switch_nnl (P_output_switch, ")");
	     else do;
		call ioa_$ioa_switch_nnl (P_output_switch, "; ");
		go to next_param;
	     end;
	end;
	if is_function then do;
	     call ioa_$ioa_switch_nnl (P_output_switch, ": ");
	     call print_pascal_var_type ((proc_type_info.base_type), proc_type_info.base_type_addr, Ind);
	end;

	return;

     end print_proc_type;
%page;

print_pascal_var_type: proc (TC, TP, IND);

dcl TC fixed bin (35);				/* type_code */
dcl TP ptr;					/* corresponding type ptr (Null if none) */
dcl IND fixed bin (35);				/* INDentatoon column */
dcl name_p ptr;

	if TC = pascal_integer_dtype then
	     call ioa_$ioa_switch_nnl (P_output_switch, "integer");
	else if TC = pascal_real_dtype then
	     call ioa_$ioa_switch_nnl (P_output_switch, "real");
	else if TC = pascal_char_dtype then
	     call ioa_$ioa_switch_nnl (P_output_switch, "char");
	else if TC = pascal_boolean_dtype then
	     call ioa_$ioa_switch_nnl (P_output_switch, "boolean");
	else if TC = pascal_enumerated_type_element_dtype then
	     call ioa_$ioa_switch_nnl (P_output_switch, "enumerated type element");
	else if (TC = pascal_user_defined_type_instance_dtype)
		| (TC = pascal_enumerated_type_instance_dtype) then do;
	     name_p = runtime_symbol_info_$name (TP);
	     if name_p ^= null then
		call ioa_$ioa_switch_nnl (P_output_switch, "^a",
		     runtime_symbol_info_$name (TP) -> acc.string);
	     else
		call print_type_value (TP, IND);
	end;
	else if TC = pascal_text_file_dtype then
	     call ioa_$ioa_switch_nnl (P_output_switch, "text file");
	else if TC = pascal_parameter_procedure_dtype then
	     call print_proc_type (TP, "");
	else
	     call ioa_$ioa_switch_nnl (P_output_switch, "(unknown variable type)");

     end print_pascal_var_type;

%page;

print_type_value: proc (TP, IND);

dcl TP ptr;					/* ptr to Type symbol node */
dcl IND fixed bin (35);				/* INDentation column */

dcl p1 ptr;
dcl p2 ptr;
dcl first bit (1) init ("1"b);
dcl type_code fixed bin (35);
dcl fb35b fixed bin (35) based;
dcl it fixed bin (35);
dcl (p3, p4) ptr;

dcl 1 TP_type_info like runtime_type_info;
dcl 1 TP_subrange_info like runtime_subrange_info;
dcl 1 TP_array_info like runtime_array_info;

	TP_type_info.version = RUNTIME_TYPE_INFO_VERSION_1;
	call runtime_symbol_info_$type (TP, addr (TP_type_info), P_code);
	if P_code ^= 0 then go to RETURN_HERE;
	if TP_type_info.packed then
	     call ioa_$ioa_switch_nnl (P_output_switch, "packed ");

	if TP_type_info.has_dimensions then do;		/* user defined array */
	     TP_array_info.version = RUNTIME_ARRAY_INFO_VERSION_1;
	     call runtime_symbol_info_$array (TP, addr (TP_array_info), P_code);
	     if P_code ^= 0 then go to RETURN_HERE;
	     call ioa_$ioa_switch_nnl (P_output_switch, "array [");
	     do it = 1 to TP_array_info.ndims;
		type_code = TP_array_info.bounds (it).subscript_type;
		if TP_array_info.bounds (it).lower_is_encoded then do; /* conformant */
		     if ^first then call ioa_$ioa_switch_nnl (P_output_switch, "; ");
		     else first = "0"b;
		     call ioa_$ioa_switch_nnl (P_output_switch, "^a..^a : ",
			runtime_symbol_info_$name (addrel (TP,
			addr (TP_array_info.bounds (it).lower) -> pascal_encoded_value.n3)) -> acc.string,
			runtime_symbol_info_$name (addrel (TP,
			addr (TP_array_info.bounds (it).upper) -> pascal_encoded_value.n3)) -> acc.string);
		     call print_pascal_var_type ((TP_array_info.bounds (it).subscript_type),
			TP_array_info.bounds (it).subscript_type_addr, IND + 1);
		end;
		else do;
		     if ^first then call ioa_$ioa_switch_nnl (P_output_switch, ", ");
		     else first = "0"b;
		     if TP_array_info.bounds (it).subscript_type_addr = null then
			call ioa_$ioa_switch_nnl (P_output_switch, "^a",
			     indice_id (type_code, null, TP_array_info.bounds (it).lower) || ".."
			     || indice_id (type_code, null, TP_array_info.bounds (it).upper));
		     else
			call ioa_$ioa_switch_nnl (P_output_switch, "^a",
			     indice_id (type_code,
			     TP_array_info.bounds (it).subscript_type_addr, TP_array_info.bounds (it).lower) || ".."
			     || indice_id (type_code,
			     TP_array_info.bounds (it).subscript_type_addr, TP_array_info.bounds (it).upper));
		end;
	     end;
	     call ioa_$ioa_switch_nnl (P_output_switch, "] of ");
	     call print_pascal_var_type ((TP_type_info.base_type), TP_type_info.base_type_addr, IND + 1);
	     return;
	end;

	if TP_type_info.has_subrange_limits then do;	/* user defined subrange */
	     TP_subrange_info.version = RUNTIME_SUBRANGE_INFO_VERSION_1;
	     call runtime_symbol_info_$subrange (TP, addr (TP_subrange_info), P_code);
	     if P_code ^= 0 then go to RETURN_HERE;
	     if TP_type_info.base_type = pascal_integer_dtype then do;
		if TP_subrange_info.lower_bound_is_encoded then
		     ;
		else
		     call ioa_$ioa_switch_nnl (P_output_switch, "^d", TP_subrange_info.subrange_lower_bound);
		call ioa_$ioa_switch_nnl (P_output_switch, "..");
		if TP_subrange_info.upper_bound_is_encoded then
		     ;
		else
		     call ioa_$ioa_switch_nnl (P_output_switch, "^d", TP_subrange_info.subrange_upper_bound);
		return;
	     end;
	     if TP_type_info.base_type = pascal_char_dtype then do;
		if TP_subrange_info.lower_bound_is_encoded then
		     ;
		else
		     call ioa_$ioa_switch_nnl (P_output_switch, "'^a'",
			addr (TP_subrange_info.subrange_lower_bound) -> pascal_char.char);
		call ioa_$ioa_switch_nnl (P_output_switch, "..");
		if TP_subrange_info.upper_bound_is_encoded then
		     ;
		else
		     call ioa_$ioa_switch_nnl (P_output_switch, "'^a'",
			addr (TP_subrange_info.subrange_upper_bound) -> pascal_char.char);
		return;
	     end;
	     if TP_type_info.base_type = pascal_enumerated_type_instance_dtype then do;
		p1 = TP_type_info.base_type_addr;
		p2 = runtime_symbol_info_$son (p1);
		p3 = addrel (TP,
		     addr (TP_subrange_info.subrange_lower_bound) -> pascal_encoded_value.n3);
		p4 = addrel (TP,
		     addr (TP_subrange_info.subrange_upper_bound) -> pascal_encoded_value.n3);
		do while (p2 ^= null);
		     if p2 = p3 then
			call ioa_$ioa_switch_nnl (P_output_switch, "^a..", runtime_symbol_info_$name (p2) -> acc.string);
		     if p2 = p4 then
			call ioa_$ioa_switch_nnl (P_output_switch, "^a", runtime_symbol_info_$name (p2) -> acc.string);
		     p2 = runtime_symbol_info_$successor (p2);
		end;
		return;
	     end;
	     call ioa_$ioa_switch_nnl (P_output_switch, "(unknown subrange type)");
	     return;
	end;

	if TP_type_info.type = pascal_record_file_type_dtype then do;
	     call ioa_$ioa_switch_nnl (P_output_switch, "file of ");
	     call print_pascal_var_type ((TP_type_info.base_type), TP_type_info.base_type_addr, IND);
	     return;
	end;

	if TP_type_info.type = pascal_set_dtype then do;
	     call ioa_$ioa_switch_nnl (P_output_switch, "set of ");
	     call print_pascal_var_type ((TP_type_info.base_type), TP_type_info.base_type_addr, IND);
	     return;
	end;

	if TP_type_info.type = pascal_typed_pointer_type_dtype then do;
	     call ioa_$ioa_switch_nnl (P_output_switch, "^");
						/* this ptr may be null in case of "p = ^p" type declaration */
	     if TP_type_info.base_type_addr = null then
		TP_type_info.base_type_addr = TP;
	     call print_pascal_var_type ((TP_type_info.base_type), TP_type_info.base_type_addr, IND);
	     return;
	end;

	if TP_type_info.type = pascal_record_type_dtype then do;
	     if ^long_switch then
		call ioa_$ioa_switch_nnl (P_output_switch, "record");
	     else do;
		call ioa_$ioa_switch (P_output_switch, "record");
		call indent (IND + 1);
		call display_field_list (runtime_symbol_info_$son (TP), IND + 1);
		call ioa_$ioa_switch (P_output_switch, "");
		call indent (IND);
		call ioa_$ioa_switch_nnl (P_output_switch, "end");
	     end;
	     return;
	end;

	if TP_type_info.type = pascal_enumerated_type_dtype then do;
	     if ^long_switch then
		call ioa_$ioa_switch_nnl (P_output_switch, "enumerated");
	     else do;
		call ioa_$ioa_switch_nnl (P_output_switch, "(");
		p1 = runtime_symbol_info_$son (TP);
		do while (p1 ^= null);
		     call ioa_$ioa_switch_nnl (P_output_switch, "^[,^]^a",
			^first, runtime_symbol_info_$name (p1) -> acc.string);
		     first = "0"b;
		     p1 = runtime_symbol_info_$successor (p1);
		end;
		call ioa_$ioa_switch_nnl (P_output_switch, ")");
	     end;
	     return;
	end;

	if TP_type_info.type = pascal_procedure_type_dtype then do;
	     call print_proc_type (TP, "");
	     return;
	end;

	if TP_type_info.type = pascal_user_defined_type_dtype then do; /* alias type */
	     call print_pascal_var_type ((TP_type_info.base_type), TP_type_info.base_type_addr, IND);
	     return;
	end;

	if TP_type_info.type = pascal_string_type_dtype then do; /* string */
	     call ioa_$ioa_switch_nnl (P_output_switch, "string^[ (^d)^]",
		^TP_type_info.size_is_encoded, TP_type_info.size);
	end;

     end print_type_value;
%page;

indent: proc (IND);

dcl IND fixed bin (35);

dcl blanks char (IND * P_ind_units + P_margin) init ("");

	call iox_$put_chars (P_output_switch, addr (blanks), length (blanks), P_code);
	if P_code ^= 0 then go to RETURN_HERE;

     end indent;
%page;
short_type_name: proc (TC, TP) returns (char (50) var);

dcl TC fixed bin (35);
dcl TP ptr;
dcl name_ptr ptr;
dcl 1 type_info like runtime_type_info;

	if TC = pascal_integer_dtype then return ("integer");

	if TC = pascal_char_dtype then return ("char");

	if TC = pascal_real_dtype then return ("real");

	if TC = pascal_boolean_dtype then return ("boolean");

	if TC = pascal_text_file_dtype then return ("file");

	if TC = pascal_enumerated_type_instance_dtype then return ("enumerated");

	if TC = pascal_user_defined_type_instance_dtype then do;
	     name_ptr = runtime_symbol_info_$name (TP);
	     if name_ptr = null then do;
		if runtime_symbol_info_$array_dims (TP) ^= 0 then return ("array");
		if runtime_symbol_info_$level (TP) = 1 then return ("record");
		if runtime_symbol_info_$n_variants (TP) ^= 0 then do;
		     type_info.version = RUNTIME_TYPE_INFO_VERSION_1;
		     call runtime_symbol_info_$type (TP, addr (type_info), P_code);
		     if P_code ^= 0 then go to RETURN_HERE;
		     return (short_type_name ((type_info.base_type), type_info.base_type_addr) || " subrange");
		end;
	     end;
	     else return (name_ptr -> acc.string);
	end;

	return ("???");

     end short_type_name;
%page;
print_thing: proc (IND, TC, TP, SIZ, ADD, NAME, SUBSCRIPT_INFO, DONE);


dcl IND fixed bin (35);				/* indentation count for display */
dcl TC fixed bin (35);				/* type code */
dcl TP ptr;					/* type ptr - if any */
dcl ADD ptr;					/* address of thing */
dcl SIZ fixed bin (35);				/* size of thing */
dcl NAME char (256) varying;				/* name of the thing */
dcl 1 SUBSCRIPT_INFO like pascal_subscript_info;
dcl DONE bit (1) aligned;				/* set if successfull */

dcl 1 subrange_info like runtime_subrange_info;
dcl value fixed bin (35);
dcl p1 ptr;
dcl probe_increment_indices_ entry (bit (1) aligned, (*) fixed bin, (2, *) fixed bin (24),
         fixed bin, bit (1) aligned, bit (1) aligned);
dcl probe_check_ptr_$convert_packed entry (ptr unal, bit (*)) returns (char (256) varying);
dcl fx35b fixed bin (35) based unaligned;
dcl b_str bit (SIZ) based (ADD) unaligned;
dcl fl63b float bin (63) based unaligned;
dcl (done, Done) bit (1) aligned;
dcl name_string char (256) var;
dcl brother_offset fixed bin (35);
dcl pascal_char char (1);
dcl i fixed bin (35);
dcl probe_et_$dim_limit fixed bin (35) ext;
dcl probe_et_$no_address fixed bin (35) ext;
dcl pascal_display_file_value entry (ptr, ptr, ptr);
dcl window_place ptr;
dcl ptr_based ptr based;
dcl packed_ptr_based ptr unal based;
dcl 1 s_val based (ADD) unal,
     2 sign bit (1) unal,
     2 val bit (SIZ) unal;
dcl 1 subscript_info like pascal_subscript_info;
dcl (min, max) fixed bin (35);

dcl 1 last_displayed int static,
     2 value fixed bin (35),
     2 valid bit (1);

	last_displayed.value = 0;
	last_displayed.valid = "1"b;
	DONE = "1"b;

	call indent (IND);

	if TC = pascal_label_dtype then do;
						/* not supported */
	end;

	else if TC = pascal_internal_procedure_dtype
		| TC = pascal_exportable_procedure_dtype
		| TC = pascal_imported_procedure_dtype then do;
	     call ioa_$ioa_switch (P_output_switch, "^a", probe_check_ptr_$convert (ADD, ""b));
	end;

	else if TC = pascal_parameter_procedure_dtype then
	     call ioa_$ioa_switch (P_output_switch, "^a", probe_check_ptr_$convert (ADD -> ptr_based, ""b));

	else if TC = pascal_integer_dtype then do;
	     if baseno (ADD) = baseno (null ()) then go to NO_ADDRESS;
	     last_displayed.value = ADD -> fx35b;
	     call ioa_$ioa_switch (P_output_switch, "^a = ^d", NAME, ADD -> fx35b);
	end;

	else if TC = pascal_real_dtype then do;
	     if baseno (ADD) = baseno (null ()) then go to NO_ADDRESS;
	     call ioa_$ioa_switch (P_output_switch, "^a = ^f", NAME, ADD -> fl63b);
	end;

	else if TC = pascal_char_dtype then do;
	     unspec (pascal_char) = substr (b_str, SIZ - 8, 9);
	     last_displayed.value = bin (b_str);
	     call ioa_$ioa_switch (P_output_switch, "^a = '^a'", NAME, pascal_char);
	end;

	else if TC = pascal_boolean_dtype then do;
	     last_displayed.value = bin (b_str);
	     if substr (b_str, 1, SIZ - 1) ^= "0"b then
		call out_of_range ((bin (b_str)), NAME);
	     else
		call ioa_$ioa_switch (P_output_switch, "^a = ^[true^;false^]", NAME, substr (b_str, SIZ, 1));
	end;

	else if TC = pascal_enumerated_type_element_dtype then do;
	     call ioa_$ioa_switch (P_output_switch, "^a = ^a", NAME, NAME);
	end;

	else if TC = pascal_enumerated_type_instance_dtype then do;
	     p1 = runtime_symbol_info_$son (TP);
	     done = "0"b;
	     value = bin (b_str);
	     last_displayed.value = value;
	     i = 0;
	     do while (p1 ^= null);
		if i = value then do;
		     done = "1"b;
		     call ioa_$ioa_switch (P_output_switch, "^a = ^a", NAME,
			runtime_symbol_info_$name (p1) -> acc.string);
		     p1 = null;
		end;
		else do;
		     p1 = runtime_symbol_info_$successor (p1);
		     i = i + 1;
		end;
	     end;
	     if ^done then call out_of_range (value, NAME);
	end;

	else if TC = pascal_text_file_dtype then do;
	     call ioa_$ioa_switch (P_output_switch, "^a = ", NAME);
	     call pascal_display_file_value (ADD, window_place, P_output_switch);
	     if window_place ^= null then do;
		call print_thing (IND, (pascal_char_dtype), null, 36, window_place, NAME || "^", SUBSCRIPT_INFO, Done);
		if ^Done then go to RETURN_HERE;
	     end;
	end;

	else if TC = pascal_user_defined_type_instance_dtype then do;

	     type_info.version = RUNTIME_TYPE_INFO_VERSION_1;
	     call runtime_symbol_info_$type (TP, addr (type_info), P_code);
	     if P_code ^= 0 then go to RETURN_HERE;

	     if type_info.has_dimensions then do;	/* array ... */
dcl indice_string char (32 * 16 + 3) var;
dcl n_dims fixed bin;
dcl indices (16) fixed bin;
dcl bounds (2, 16) fixed bin (24);
dcl origin (16) fixed bin (24);
dcl 1 type_info like runtime_type_info;
dcl mult (16) fixed bin (35);
dcl 1 array_info like runtime_array_info;
dcl index fixed bin (35);
dcl set_string bit (100000) unal based;
dcl (char_offset, char_len) fixed bin;
dcl 1 array_element_info based,
     2 address ptr,
     2 indice_string char (33 + 16 + 4) var;
dcl 1 first_elem like array_element_info;
dcl 1 current_elem like array_element_info;
dcl 1 previous_elem like array_element_info;
dcl get_size_in_bits_ entry (fixed bin, fixed bin (35), bit (1)) returns (fixed bin (35));
dcl array_element bit (elem_size) unal based;
dcl elem_size fixed bin (35);

		array_info.version = RUNTIME_ARRAY_INFO_VERSION_1;
		call runtime_symbol_info_$array (TP, addr (array_info), P_code);
		if P_code ^= 0 then go to RETURN_HERE;

		n_dims = array_info.ndims;
		if n_dims > 16 then do;
		     P_code = probe_et_$dim_limit;	/* dommage ! */
		     goto RETURN_HERE;
		end;

		do i = 1 to n_dims;
		     if (SUBSCRIPT_INFO.number ^= 0) & (i <= SUBSCRIPT_INFO.number) then do;
			origin (i) =
			     decode (array_info.bounds (i).lower, array_info.bounds (i).lower_is_encoded, TP);
			indices (i), bounds (1, i) = SUBSCRIPT_INFO.value (1, i);
			bounds (2, i) = SUBSCRIPT_INFO.value (2, i);
		     end;
		     else do;
			indices (i), bounds (1, i), origin (i) =
			     decode (array_info.bounds (i).lower, array_info.bounds (i).lower_is_encoded, TP);
			bounds (2, i) =
			     decode (array_info.bounds (i).upper, array_info.bounds (i).upper_is_encoded, TP);
		     end;
		     mult (i) = convert_units (
			decode (array_info.bounds (i).multiplier, array_info.bounds (i).multiplier_is_encoded, TP),
			(array_info.array_units));
		end;
		if (n_dims = 1) & (type_info.packed) & (type_info.base_type = pascal_char_dtype) then do;
						/* character string */
		     value = bounds (2, 1) - bounds (1, 1) + 1;
		     char_offset = indices (1) - origin (1);
		     char_len = value + char_offset;

dcl pascal_char_string char (char_len) unal based (ADD);
dcl pascal_chars (char_len) char (1) unal based (ADD);

		     value = length (rtrim (substr (pascal_char_string, 1 + char_offset))); if value = 0 then value = 2;
		     call ioa_$ioa_switch_nnl (P_output_switch, "^a^[ [^d:^d]^] = ",
			NAME, SUBSCRIPT_INFO.number ^= 0, bounds (1, 1), bounds (2, 1));
		     if value > 200 then do;
			call ioa_$ioa_switch_nnl (P_output_switch,
			     "(only 200 first of ^d chars are displayed) ", value);
			value = 200;
		     end;
		     call ioa_$ioa_switch_nnl (P_output_switch, "'");
		     call iox_$put_chars (P_output_switch, addr (pascal_chars (1 + char_offset)), value, P_code);
		     call ioa_$ioa_switch (P_output_switch, "'");
		end;
		else do;

get_array_info: proc (p_elem);

dcl 1 p_elem like array_element_info;

	index = 0;
	p_elem.indice_string = "";
	do i = 1 to n_dims;
	     if i ^= 1 then p_elem.indice_string = p_elem.indice_string || ",";
	     index = index + mult (i) * (indices (i) - origin (i));
	     if array_info.bounds (i).subscript_type_addr ^= null then
		p_elem.indice_string = p_elem.indice_string ||
		     indice_id ((array_info.bounds (i).subscript_type),
		     array_info.bounds (i).subscript_type_addr,
		     (indices (i)));
	     else p_elem.indice_string = p_elem.indice_string || indice_id
		     ((array_info.bounds (i).subscript_type), null, (indices (i)));
	end;
	p_elem.address = bitrel (ADD, index);
     end;

display_array_elements: proc (p_from, p_to);

dcl 1 p_from like array_element_info;
dcl 1 p_to like array_element_info;

	if p_from.address = p_to.address then
	     call print_thing (IND + 1, (type_info.base_type), type_info.base_type_addr,
		type_info.size, p_from.address, NAME || " [" || p_from.indice_string || "]", subscript_info, Done);
	else
	     call print_thing (IND + 1, (type_info.base_type), type_info.base_type_addr,
		type_info.size, p_from.address, NAME || " [" || p_from.indice_string || ".." || p_to.indice_string || "]", subscript_info, Done);
	if ^Done then go to RETURN_HERE;

     end;
		     call ioa_$ioa_switch (P_output_switch, "^a =", NAME);
		     done = "0"b;
		     elem_size = get_size_in_bits_ ((type_info.base_type), type_info.size, type_info.packed);
		     if n_dims < SUBSCRIPT_INFO.number then do;
			subscript_info.number = SUBSCRIPT_INFO.number - n_dims;
			do i = 1 to subscript_info.number;
			     subscript_info.value (1, i) = SUBSCRIPT_INFO.value (1, i + n_dims);
			     subscript_info.value (2, i) = SUBSCRIPT_INFO.value (2, i + n_dims);
			end;
		     end;
		     else subscript_info.number = 0;

		     call get_array_info (first_elem);
		     previous_elem, current_elem = first_elem;
scan_array:
		     call probe_increment_indices_ ("0"b, indices, bounds, n_dims, done, ("0"b));
		     if done then
			call display_array_elements (first_elem, current_elem);
		     else do;
			call get_array_info (current_elem);
			if current_elem.address -> array_element ^= previous_elem.address -> array_element then do;
			     call display_array_elements (first_elem, previous_elem);
			     first_elem = current_elem;
			end;
			previous_elem = current_elem;
			go to scan_array;
		     end;
		end;

	     end;
	     else if type_info.has_subrange_limits then do; /* subrange */
		subrange_info.version = RUNTIME_SUBRANGE_INFO_VERSION_1;
		call runtime_symbol_info_$subrange (TP, addr (subrange_info), P_code);
		if P_code ^= 0 then go to RETURN_HERE;
		min = decode (subrange_info.subrange_lower_bound,
		     subrange_info.lower_bound_is_encoded, TP);
		max = decode (subrange_info.subrange_upper_bound,
		     subrange_info.upper_bound_is_encoded, TP);
		if type_info.base_type = pascal_integer_dtype then do;
		     unspec (value) = copy (s_val.sign, 36 - SIZ) || s_val.val;
		     last_displayed.value = value;
		     if value < min | value > max then
			call out_of_range (value, NAME);
		     else
			call ioa_$ioa_switch (P_output_switch, "^a = ^d", NAME, value);
		end;
		else do;
		     value = bin (b_str);
		     last_displayed.value = value;
		     if value < min | value > max then
			call out_of_range (value, NAME);
		     else
			if type_info.base_type = pascal_char_dtype then do;
			unspec (pascal_char) = substr (unspec (value), 28, 9);
			call ioa_$ioa_switch (P_output_switch, "^a = ^'a'", NAME, pascal_char);
		     end;
		     else if type_info.base_type = pascal_enumerated_type_instance_dtype then do;
			p1 = runtime_symbol_info_$son (type_info.base_type_addr);
			i = min;
			do while (p1 ^= null);
			     if i = value then do;
				call ioa_$ioa_switch (P_output_switch, "^a = ^a",
				     NAME, runtime_symbol_info_$name (p1) -> acc.string);
				p1 = null;
			     end;
			     else do;
				i = i + 1;
				p1 = runtime_symbol_info_$successor (p1);
			     end;
			end;
		     end;
		end;
	     end;

	     else if type_info.type = pascal_record_file_type_dtype then do;
		call pascal_display_file_value (ADD, window_place, P_output_switch);
		if window_place ^= null then
		     call print_thing (IND, (type_info.base_type), type_info.base_type_addr,
			type_info.size, window_place, NAME || "^", SUBSCRIPT_INFO, Done);
		if ^Done then go to RETURN_HERE;
	     end;

	     else if type_info.type = pascal_set_dtype then do;
		call ioa_$ioa_switch_nnl (P_output_switch, "^a = [", NAME);
		call display_pascal_set ((type_info.base_type), type_info.base_type_addr, ADD, 0);
		call ioa_$ioa_switch (P_output_switch, "]");
	     end;

	     else if type_info.type = pascal_typed_pointer_type_dtype then do;
		if memorize_refs then do;
		     if SIZ = 72 then do;
			call probe_check_ptr_$check (ADD -> ptr_based, error_code);
			if error_code ^= 0 then go to dont_remember;
			call probe_check_ptr_$indirectable (ADD -> ptr_based, error_code);
			if error_code ^= 0 then go to dont_remember;
			item_place = ADD -> ptr_based;
		     end;
		     else do;
			call probe_check_ptr_$check_packed (ADD -> packed_ptr_based, error_code);
			if error_code ^= 0 then go to dont_remember;
			call probe_check_ptr_$indirectable ((ADD -> packed_ptr_based), error_code);
			if error_code ^= 0 then go to dont_remember;
			item_place = ADD -> packed_ptr_based;
		     end;
		     ref_ptr = first_ref;
		     prev_ref = null;
		     do while (ref_ptr ^= null);
			if item_addr = item_place then go to dont_remember;
			if (baseno (item_addr) > baseno (item_place)) then go to remember;
			if (baseno (item_addr) = baseno (item_place))
			     & (fixed (rel (item_addr), 18) > fixed (rel (item_place), 18)) then go to remember;
			prev_ref = ref_ptr;
			ref_ptr = item_next;
		     end;
remember:
		     if first_ref = null then do;
			allocate referenced_item set (first_ref);
			ref_ptr = first_ref;
			item_next = null;
		     end;
		     else do;
			if prev_ref = null then do;
			     allocate referenced_item set (prev_ref);
			     prev_ref -> item_next = first_ref;
			     ref_ptr,
				first_ref = prev_ref;
			end;
			else do;
			     allocate referenced_item set (prev_ref -> item_next);
			     prev_ref -> item_next -> item_next = ref_ptr;
			     ref_ptr = prev_ref -> item_next;
			end;
		     end;
		     item_addr = item_place;
		     item_type = type_info.base_type;
		     item_type_addr = type_info.base_type_addr;
		     item_size = type_info.size;
		     item_displayed = "0"b;
		end;
dont_remember:
		if SIZ = 72 then
		     call ioa_$ioa_switch (P_output_switch, "^a = ^a", NAME,
			probe_check_ptr_$convert (ADD -> ptr_based, ""b));
		else if SIZ = 36 then
		     call ioa_$ioa_switch (P_output_switch, "^a = ^a", NAME,
			probe_check_ptr_$convert_packed (ADD -> packed_ptr_based, ""b));
	     end;

	     else if type_info.type = pascal_record_type_dtype then do;
		p1 = runtime_symbol_info_$son (TP);
		if p1 = null then
		     call ioa_$ioa_switch (P_output_switch, "^a = (empty record)", NAME);
		else do;
		     call ioa_$ioa_switch (P_output_switch, "^a =", NAME);
		     call print_field_list (p1, IND + 1, ADD);
		end;
	     end;

	     else if type_info.type = pascal_string_type_dtype then do;
dcl len fixed bin (35);
		len = decode (type_info.size, type_info.size_is_encoded, TP);
		begin;
dcl pascal_string char (len) varying based (ADD);
		     if length (pascal_string) > len then
			call ioa_$ioa_switch (P_output_switch, "^a = (actual length of string (^d) is out of range (0..^d))", NAME, length (pascal_string), len);
		     else
			if length (pascal_string) > 200 then
			call ioa_$ioa_switch (P_output_switch, "^a = (only 200 first chars of ^d are displayed) ""^a""", NAME, length (pascal_string), substr (pascal_string, 1, 200));
		     else
			call ioa_$ioa_switch (P_output_switch, "^a = ""^a""", NAME, pascal_string);
		end;
	     end;
	end;
	else DONE = "0"b;				/* unknown */

print_field_list: proc (FP, IND, BASE);

dcl FP ptr;					/* Field symbol node Ptr */
dcl IND fixed bin (35);				/* INDentation column */
dcl BASE ptr;					/* BASE address of the record */

dcl (it, off, n_loop) fixed bin (35);
dcl p1 ptr;
dcl 1 type_info like runtime_type_info;
dcl 1 address_info like runtime_address_info;
dcl name_addr ptr;
dcl (valid, done) bit (1) aligned;

	p1 = FP;
	do while (p1 ^= null);
	     type_info.version = RUNTIME_TYPE_INFO_VERSION_1;
	     address_info.version = RUNTIME_ADDRESS_INFO_VERSION_1;
	     call runtime_symbol_info_$type (p1, addr (type_info), P_code);
	     if P_code ^= 0 then go to RETURN_HERE;
	     call runtime_symbol_info_$address (p1, addr (address_info), P_code);
	     if P_code ^= 0 then go to RETURN_HERE;
	     n_loop, n_variants = runtime_symbol_info_$n_variants (p1);
	     name_addr = runtime_symbol_info_$name (p1);
	     if name_addr = null then
		name_string = short_type_name ((type_info.type), type_info.type_addr);
	     else
		name_string = name_addr -> acc.string;
	     if name_addr = null then do;
		call indent (IND);
		call ioa_$ioa_switch (P_output_switch, "case ^a of", name_string);
		begin;
dcl 1 variant_info like runtime_variant_info;

		     variant_info.version = RUNTIME_VARIANT_INFO_VERSION_1;
		     call runtime_symbol_info_$variant (p1, addr (variant_info), P_code);
		     if P_code ^= 0 then go to RETURN_HERE;
		     off = variant_info.first_value_in_set;
		     do it = 1 to n_loop;
			call indent (IND + 1);
			call display_pascal_set ((type_info.type), type_info.type_addr,
			     variant_info.case (it).set_addr, off);
			call ioa_$ioa_switch (P_output_switch, " : ");
			if variant_info.case (it).brother_addr ^= null then
			     call print_field_list
				(variant_info.case (it).brother_addr, IND + 2, BASE);
		     end;
		     p1 = null;
		end;				/* begin block */
	     end;
	     else do;
		if n_loop ^= 0 then
		     name_string = name_string || " (selector)";
		call print_thing (IND, (type_info.type), type_info.type_addr, type_info.size,
		     bitrel (ADD, convert_units (decode (address_info.offset,
		     address_info.offset_is_encoded, p1), (address_info.units))),
		     name_string, SUBSCRIPT_INFO, done);
		if ^done then go to RETURN_HERE;
		if n_loop ^= 0 then begin;
dcl 1 variant_info like runtime_variant_info;

		     variant_info.version = RUNTIME_VARIANT_INFO_VERSION_1;
		     call runtime_symbol_info_$variant (p1, addr (variant_info), P_code);
		     if P_code ^= 0 then go to RETURN_HERE;
		     if last_displayed.valid then
			do it = 1 to n_loop;
			if substr (variant_info.case (it).set_addr -> set_string,
			     last_displayed.value - variant_info.first_value_in_set + 1, 1) = "1"b then do;
			     call print_field_list
				(variant_info.case (it).brother_addr, IND + 1, BASE);
			     it = n_loop;
			end;
		     end;
		     p1 = null;
end_loop:
		end;
		else p1 = runtime_symbol_info_$brother (p1);
	     end;
	end;
     end print_field_list;


bitrel: proc (P_ptr, P_bit_offset) returns (ptr);
dcl P_ptr ptr parameter;
dcl P_bit_offset fixed bin (35) parameter;

dcl 1 str unal based (P_ptr),
     2 filler unal bit (P_bit_offset),
     2 target unal bit (1);

	if P_bit_offset < 0 then return (null);
	return (addr (str.target));
     end bitrel;

decode: proc (value, encoded, symbp) returns (fixed bin (35));

dcl value fixed bin (35);
dcl encoded bit (1);
dcl symbp ptr;

dcl ptr builtin;
dcl stu_$decode_runtime_value_extended
         entry (fixed bin (35), ptr, ptr, ptr, ptr, ptr, ptr, fixed bin (35)) returns (fixed bin (35));
dcl result fixed bin (35);

	if ^encoded then return (value);
	else do;
	     result = stu_$decode_runtime_value_extended (value, Block_ptr, Stack_ptr, Linkage_ptr, ptr (Block_ptr, 0),
		Base_addr, symbp, P_code);
	     if P_code ^= 0 then go to RETURN_HERE;
	     return (result);
	end;
     end decode;

out_of_range: proc (VALUE, NAME);

dcl VALUE fixed bin (35);
dcl NAME char (256) var;

	call ioa_$ioa_switch (P_output_switch, "^a = (internal value out of range : ^d)", NAME, VALUE);

	last_displayed.valid = "0"b;

     end out_of_range;

convert_units: proc (value, unit_code) returns (fixed bin (35));
dcl value fixed bin (35) parameter;			/* offset in raw */
dcl unit_code fixed bin (2) parameter unsigned;


	goto units_case (unit_code);

units_case (0): return (value * bits_per_word);		/* word */
units_case (1): return (value);			/* bit */
units_case (2): return (value * bits_per_character);	/* char */
units_case (3): return (value * bits_per_half);		/* halfword */
     end convert_units;

	return;

NO_ADDRESS:
	P_code = probe_et_$no_address;
	go to RETURN_HERE;

     end print_thing;
%page;
%include pascal_loc_class_codes;
%include std_descriptor_types;
%include acc;
%include runtime_symbol;
%include runtime_symbol_block;
%include runtime_block_type;
%include runtime_symbol_info_;
%include data_type_info_;
%include linkdcl;
%include computational_data;
%include encoded_precision;
%page;
%include pascal_symbol_node;
%page;
%include pascal_symbol_;
%page;
%include statement_map;
%page;
%include system;
     end pascal_symbol_;
