/****^  *************************************************************************
        *                                                                       *
        * Copyright (c) 1984 by Centre Interuniversitaire de Calcul de Grenoble *
        * and Institut National de Recherche en Informatique et Automatique     *
        *                                                                       *
        ************************************************************************* */


/****^  HISTORY COMMENTS:
  1) change(86-10-05,JMAthane), approve(86-10-05,MCR7521),
     audit(86-10-09,JPFauche), install(86-11-12,MR12.0-1212):
     Pascal version for MR12.
                                                   END HISTORY COMMENTS */

/* format: style4,^linecom,^ifthendo,^indproc,^indblkcom,initcol1,declareind8,dclind4,struclvlind1 */


pascal_display: proc;

/* pascal_display command

   Usage : pascal_display [1 to 10 <paths>]

   Dumps statics and locals of the named programs, or, if no
   name is given, of all the active PASCAL procedures. (Named programs must be
   generated by PASCAL compiler)

*/

/* Multics entry points */

dcl cu_$arg_count entry (fixed bin);
dcl com_err_ entry options (variable);
dcl cu_$arg_ptr entry (fixed bin, ptr, fixed bin (17), fixed bin (35));
dcl cu_$stack_frame_ptr entry (ptr);
dcl hcs_$initiate_count entry (char (*), char (*), char (*), fixed bin (24), fixed bin (2), ptr, fixed bin (35));
dcl iox_$user_output ext ptr;
dcl object_info_$display entry (ptr, fixed bin (24), ptr, fixed bin (35));
dcl component_info_$offset entry (ptr, fixed bin (18), ptr, fixed bin (35));
dcl ioa_ entry options (variable);
dcl get_entry_name_ entry (ptr, char (*), fixed bin (18), char (8) aligned, fixed bin (35));
dcl error_table_$segknown fixed bin (35) ext;
dcl dump_segment_ entry (ptr, ptr, fixed bin, fixed bin (18), fixed bin (18), bit (18));
dcl hcs_$fs_get_path_name entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
dcl stu_$get_runtime_address entry (ptr, ptr, ptr, ptr, ptr, ptr, ptr) returns (ptr);
dcl stu_$find_containing_block entry (ptr, fixed bin (18) unsigned) returns (ptr);

/* PASCAL entry points */


/* conditions */

dcl cleanup condition;

/* automatics */

dcl symbolname char (256);
dcl (file_no, line_no) fixed bin (35);
dcl segnbr fixed bin (18);
dcl lang char (8) aligned;
dcl error bit (1);
dcl code fixed bin (35);
dcl arg_count fixed bin;
dcl (i, j, index) fixed bin (35);
dcl arg_len fixed bin (17);
dcl arg_ptr ptr;
dcl bc fixed bin (24);
dcl offset fixed bin (18);
dcl count fixed bin (18);
dcl seg ptr;
dcl ldn fixed bin;
dcl dirname char (168);
dcl entryname char (32);
dcl np ptr;
dcl nl fixed bin;
dcl bmp ptr;
dcl first ptr;
dcl procname (10) char (32);
dcl 1 oi like object_info;
dcl segs_nbr fixed bin;
dcl based_name char (nl) based (np);
dcl 1 segs (300),
     2 first ptr,
     2 linkage_ptr ptr,
     2 seg_base ptr,
     2 pl1_symb_ptr ptr,
     2 symb_hdr_ptr ptr,
     2 count fixed bin (18),
     2 dirname char (168),
     2 component_name char (32),
     2 entryname char (32);
dcl lp ptr;
dcl 1 type_info like runtime_type_info;
dcl 1 subscript_info like pascal_subscript_info;

/* based */

dcl arg char (arg_len) based (arg_ptr);

/* builtin */

dcl (null, fixed, rel, baseno) builtin;

/**/

	type_info.version = RUNTIME_TYPE_INFO_VERSION_1;
	subscript_info.number = 0;
	segs_nbr = 0;
	error = "0"b;
	call cu_$arg_count (arg_count);

	call pascal_symbol_$clear_references;
	call pascal_symbol_$memorize_refs_on;

	on cleanup begin;
		call pascal_symbol_$clear_references;
		call pascal_symbol_$memorize_refs_off;
	     end;

	do i = 1 to arg_count;
	     call cu_$arg_ptr ((i), arg_ptr, arg_len, code);
	     if code ^= 0 then do;
		call com_err_ (code, "pascal_display");
		error = "1"b;
		go to findo;
	     end;
	     if arg_len > 32 then do;
		call com_err_ (0, "pascal_display", "error : procedure name is > 32 chars : ^a", arg);
		error = "1"b;
		go to findo;
	     end;
	     procname (i) = arg;
findo:
	end;
	if error = "1"b then return;

	call ioa_ ("	Active procedures in the Multics stack are:");

	call cu_$stack_frame_ptr (sp);

	do while (sp -> prev_sp ^= null);
	     sp = sp -> prev_sp;
	     call hcs_$fs_get_path_name (sp -> entry_ptr, dirname, ldn, entryname, code);
	     if code ^= 0 then do;
		go to no_edition;
	     end;
	     call hcs_$initiate_count (dirname, entryname, "", bc, 0, seg, code);
	     if (code ^= 0) & (code ^= error_table_$segknown) then do;
		call com_err_ (code, "pascal_display", "^a>^a", rtrim (dirname), rtrim (entryname));
		go to no_edition;
	     end;
	     oi.version_number = object_info_version_2;
	     call object_info_$display (ptr (sp -> entry_ptr, 0), bc, addr (oi), code);
	     if code ^= 0 then do;
		call com_err_ (code, "pascal_display", "^a", symbolname);
		go to no_edition;
	     end;
	     if oi.format.bound = "1"b then do;
		ci.dcl_version = 1;
		call component_info_$offset (seg, fixed (rel (sp -> entry_ptr), 18), addr (ci), code);
		if code ^= 0 then do;
		     call com_err_ (code, "pascal_display");
		     go to no_edition;
		end;
		symbolname = get_proc_name (ci.symb_start);
		call source_info (ci.symb_start);
		call ioa_ ("^o|^o^-^a^[$^a^;^s^]|^o (^a|^o) (^a)^[ (line ^[^d-^;^s^]^d)^]",
		     fixed (baseno (sp)), fixed (rel (sp)), rtrim (ci.name), symbolname ^= "",
		     symbolname, fixed (rel (sp -> entry_ptr)) - fixed (rel (ci.text_start)), rtrim (entryname),
		     fixed (rel (sp -> entry_ptr)), lang, line_no ^= 0, file_no ^= 0, file_no, line_no);
		if lang ^= "PASCAL" then go to no_edition;
		bmp = addrel (oi.symbp, oi.symbp -> area_pointer);
		do i = 1 to bmp -> n_components;
		     if sp -> translator_id = "000006"b3 then
			lp = sp -> old_pascal_stack_frame.linkage_ptr;
		     else
			lp = sp -> pascal_stack_frame.linkage_ptr;
		     first = addrel (lp, 8 + fixed (bmp -> component (i).stat_start));
		     count = fixed (bmp -> component (i).stat_lng);
		     do j = 1 to segs_nbr;
			if segs.first (j) = first then do;
			     segs.entryname (j) = entryname;
			     index = j;
			     go to known;
			end;
		     end;
		     segs_nbr = segs_nbr + 1;
		     np = addrel (oi.symbp, bmp -> component (i).name_ptr);
		     nl = fixed (bmp -> component (i).name_lng);
		     segs.component_name (j) = based_name;
		     segs.dirname (j) = dirname;
		     segs.entryname (j) = entryname;
		     segs.count (j) = count;
		     segs.first (j) = first;
		     segs (j).linkage_ptr = lp;
		     segs (j).seg_base = ptr (sp -> entry_ptr, 0);
		     segs (j).symb_hdr_ptr = addrel (oi.symbp, bmp -> component (i).symb_start);
		     segs (j).pl1_symb_ptr = addrel (segs (j).symb_hdr_ptr, segs (j).symb_hdr_ptr -> area_pointer);
		     index = j;
		end;
	     end;
	     else do;
		symbolname = get_proc_name (oi.symbp);
		call source_info (oi.symbp);
		call ioa_ ("^o|^o^-^a^[$^a^;^s^]|^o (^a)^[ (line ^[^d-^;^s^]^d)^]",
		     fixed (baseno (sp)), fixed (rel (sp)), rtrim (entryname), symbolname ^= "",
		     symbolname, fixed (rel (sp -> entry_ptr)), lang,
		     line_no ^= 0, file_no ^= 0, file_no, line_no);
		if lang ^= "PASCAL" then go to no_edition;
		if sp -> translator_id = "000006"b3 then
		     lp = sp -> old_pascal_stack_frame.linkage_ptr;
		else
		     lp = sp -> pascal_stack_frame.linkage_ptr;
		first = addrel (lp, 8);
		count = oi.ilng;
		do i = 1 to segs_nbr;
		     if segs.first (i) = first then do;
			segs.entryname (i) = entryname;
			index = i;
			go to known;
		     end;
		end;
		segs.component_name (i) = "";
		segs_nbr = segs_nbr + 1;
		segs.dirname (i) = dirname;
		segs.entryname (i) = entryname;
		segs.count (i) = count;
		segs.first (i) = first;
		segs (i).linkage_ptr = lp;
		segs (i).seg_base = ptr (sp -> entry_ptr, 0);
		segs (i).symb_hdr_ptr = oi.symbp;
		segs (i).pl1_symb_ptr = addrel (oi.symbp, oi.symbp -> area_pointer);
		index = i;
	     end;
known:
	     if arg_count = 0 then do;
		go to edit_variables;
	     end;
	     do i = 1 to arg_count;
		if procname (i) = symbolname then do;
		     go to edit_variables;
		end;
	     end;
	     go to no_edition;
edit_variables:
	     offset = 36;
	     if sp -> main = "0"b then do;
		call ioa_ ("   - locals are :");
		if segs (index).pl1_symb_ptr -> pl1_symbol_block.table then
		     call display_symbols (index, sp);
		else do;
		     first = addrel (sp, 96);
		     offset = 96;
		     count = fixed (rel (sp -> next_sp), 18) - (fixed (rel (sp), 18)) - 96;
		     call dump_segment_ (iox_$user_output, first, 0, offset, count, "01001000000"b);
		end;
	     end;
	     else call ioa_ ("   - main -");
no_edition:
	end;
	do i = 1 to segs_nbr;
	     call ioa_ ("
	- globals for ^a>^a^[ (component ^a)^] are :",
		segs.dirname (i), segs.entryname (i), segs.component_name (i) ^= "", segs.component_name (i));
	     if segs (i).pl1_symb_ptr -> pl1_symbol_block.table then
		call display_symbols (i, null);
	     else
		call dump_segment_ (iox_$user_output, segs.first (i), 0, 8, segs.count (i), "01001000000"b);
	end;

	call ioa_ ("

");
	call pascal_symbol_$display_references (iox_$user_output, 2, 3, code);
	call pascal_symbol_$memorize_refs_off;
display_symbols: proc (index, sp);

dcl index fixed bin (35);
dcl sp ptr;

dcl (name_ptr, symbol_ptr, curr_block, symbol_base) ptr;

	if sp = null then do;
	     curr_block = addrel (segs (index).symb_hdr_ptr, segs (index).pl1_symb_ptr -> root);
	     curr_block = addrel (curr_block, curr_block -> symbol_block.son);
	end;
	else curr_block = stu_$find_containing_block (segs (index).symb_hdr_ptr, fixed (rel (sp -> entry_ptr)));
	symbol_ptr = addrel (curr_block, curr_block -> symbol_block.start);
	if symbol_ptr ^= curr_block then
	     do while (symbol_ptr ^= null);
	     name_ptr = runtime_symbol_info_$name (symbol_ptr);
	     if name_ptr ^= null then do;
		call runtime_symbol_info_$type (symbol_ptr, addr (type_info), code);
		if code ^= 0 then do;
		     call com_err_ (code, "pascal_display");
		     return;
		end;
		if ^data_type_info_$info.type (type_info.type) then do;
		     if type_info.type ^= pascal_internal_procedure_dtype
			& type_info.type ^= pascal_exportable_procedure_dtype
			& type_info.type ^= pascal_imported_procedure_dtype
			& type_info.type ^= pascal_enumerated_type_element_dtype
			& type_info.type ^= pascal_label_dtype
		     then do;
			call pascal_symbol_$display_data ((type_info.type), type_info.type_addr, iox_$user_output, 2,
			     3, "111"b, sp, segs (index).linkage_ptr, curr_block, subscript_info,
			     stu_$get_runtime_address (curr_block, symbol_ptr,
			     sp, segs (index).linkage_ptr,
			     segs (index).seg_base, null, null),
			     (name_ptr -> acc.string), type_info.size, code);
		     end;
		end;
	     end;
	     symbol_ptr = runtime_symbol_info_$brother (symbol_ptr);
	end;
     end display_symbols;

get_proc_name: proc (symb_base) returns (char (256));

dcl symb_base ptr;
dcl pl1_symb ptr;
dcl new_block ptr;
dcl symbolname char (265);

	pl1_symb = addrel (symb_base, symb_base -> area_pointer);
	call get_entry_name_ (sp -> entry_ptr, symbolname, segnbr, lang, code);
	if code ^= 0 then symbolname = "";
	if symbolname = "" then
	     if (lang = "PASCAL") & (pl1_symb -> pl1_symbol_block.table) then do;
		new_block = stu_$find_containing_block (symb_base, fixed (rel (sp -> entry_ptr)));
		do while (new_block -> symbol_block.type = PASCAL_WITH_BLOCK);
		     new_block = addrel (new_block, new_block -> symbol_block.father);
		end;
		if new_block -> symbol_block.name ^= 0 then
		     symbolname = addrel (new_block, new_block -> symbol_block.name) -> acc.string;
	     end;
	return (symbolname);
     end get_proc_name;
%page;

source_info: proc (symb_base);

dcl stu_$get_statement_map entry (ptr, ptr, ptr, fixed bin);
dcl first_stt ptr;
dcl last_stt ptr;
dcl (next_stt, curr_stt) ptr;
dcl symb_base ptr;
dcl map_size fixed bin;
dcl place fixed bin (35);

	file_no,
	     line_no = 0;

	call stu_$get_statement_map (symb_base, first_stt, last_stt, map_size);
	if first_stt = null then return;
	curr_stt = first_stt;
	place = fixed (rel (sp -> return_ptr)) - 1;
loop:
	next_stt = addrel (curr_stt, map_size);
	if fixed (next_stt -> statement_map.location) > place then do;
	     file_no = fixed (curr_stt -> statement_map.file);
	     line_no = fixed (curr_stt -> statement_map.line);
	     return;
	end;
	curr_stt = next_stt;
	if curr_stt ^= last_stt then go to loop;
     end;
%include stack_frame;
%include component_info;
%include pascal_stack_frame;
%include object_info;
%include bind_map;
%include std_symbol_header;
%include data_type_info_;
%include pascal_symbol_;
%include acc;
%include pl1_symbol_block;
%include std_descriptor_types;
%include runtime_symbol_info_;
%include runtime_symbol_block;
%include statement_map;
%include runtime_block_type;
     end pascal_display;
