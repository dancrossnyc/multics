/****^  *************************************************************************
        *                                                                       *
        * Copyright (c) 1980 by Centre Interuniversitaire de Calcul de Grenoble *
        * and Institut National de Recherche en Informatique et Automatique     *
        *                                                                       *
        ************************************************************************* */


/****^  HISTORY COMMENTS:
  1) change(86-10-05,JMAthane), approve(86-10-05,MCR7521),
     audit(86-10-09,JPFauche), install(86-11-12,MR12.0-1212):
     Pascal version for MR12.
                                                   END HISTORY COMMENTS */

/* format: style4,^linecom,^ifthendo,^indproc,^indblkcom,initcol1,declareind8,dclind4,struclvlind1 */

pascal_indent: proc;


dcl simone bit (1);
dcl my_name char (6);

/* The INDENT command indents PASCAL programs to make them more readable.
*/

dcl suffix_len fixed bin;

dcl (n1, n2) char (168) aligned,			/* input and output segment pathnames */
    dn char (168) aligned,				/* directory name */
    en char (32) aligned,				/* entry name */
    temp_en char (32) aligned,			/* entry name of temp seg. */
    ap ptr,					/* ptr to argument */
    al fixed bin,					/* lth of argument */
    an fixed bin,					/* current arg number */
    nargs fixed bin,				/* number of arguments */
    expecting fixed bin init (0),			/* ^=0 if expecting a numeric arg following a control arg */
    bchr char (al) based (ap) unaligned,		/* based char string */
    (linno, indent, ntab) fixed bin,			/* misc counters */
    ec fixed bin (35) init (0),			/* error code */
    offset fixed bin (24),				/* char offset in input */
    (string_offset, line_offset) fixed bin (24),		/* offsets where current string and line started */
    string_len fixed bin,				/* length of current string, for error checking */
    (p, p1) ptr,					/* pointers to input, output */
    (icb, ice, icol) fixed bin,			/* indices in line */
    (chars, temchars) char (400),			/* Working storage */
    char char (1),					/* temp */
    n fixed bin,					/* length of working line */
    lth fixed bin (24),				/* number of chars in input */
    (lth1, lth2) fixed bin,				/* length of args */
    if_count fixed bin,				/* count of IF's encountered */
    old_if_count fixed bin,				/* previous value. */
    (scolsw,					/* TRUE if semicolon on line */
    in_inc_opt,					/* TRUE if in $include or $options */
    report_inc_opt,					/* TRUE if $include or $options begins the line */
    dclfnd,					/* TRUE if DECLARE statement on line. */
    dclsw,					/* TRUE if in a declaration */
    condsw,					/* TRUE if now in if statement. */
    ifsw,						/* TRUE for if but not for else. */
    begin_ok,					/* TRUE if in an ON statement. */
    else_ok,					/* TRUE if else is now permitted. */
    strut,					/* TRUE if in structure */
    sixty,					/* TRUE if comment is to be pushed to col. 60 */
    bos,						/* TRUE if current char could be beginning of stmnt */
    blsw,						/* TRUE if preceding line blank */
    newpage,					/* TRUE if line contains newpage character */
    string,					/* TRUE if currently in string */
    pstring) bit (1) aligned,				/* TRUE if previous line ended in string */
    (up, low, inlist) bit (1) init ("0"b),		/* UPPER CASE letters switch */
    bfsw bit (1) aligned init ("0"b),			/* Brief mode switch */
    string_error bit (1) aligned init ("0"b),
    (false init ("0"b), true init ("1"b)) int static bit (1) aligned, /* named bit values */
    (in, dent, dclind) fixed bin,			/* indentation */
    LMARGIN fixed bin init (10),			/* left margin */
    IN fixed bin init (3),				/* subsequent indent */
    CMC fixed bin init (61),				/* comment column */
    TABCOL fixed bin init (60),			/* nearest mult of 10 < CMC */
    NTAB fixed bin init (6),				/* number of tabs to get to TABCOL */
    nout fixed bin (24),				/* number of chars in output */
    colpos fixed bin,				/* Column pointer in output line. (last filled col) */
    parcnt fixed bin init (0),			/* paren count. must be 0 at semicolon */
    bracnt fixed bin init (0),			/* braces count */
    (bcr_count, unt_count, rpt_count, pro_count, end_count) fixed bin init (0),
    if_pdlx fixed bin,
    ifdent fixed bin,
    suffix char (7),
    suffix_assumed bit (1) init ("0"b),			/* set if indent is assuming the suffix */
    (i, j, k, kk, m) fixed bin (24);
dcl (directive, par_right, par_left) fixed bin init (0);
dcl (symbol, SYMBOL) char (9);
dcl section fixed bin init (0);


dcl proc int static init (1);
dcl label int static init (2);
dcl const int static init (3);
dcl type int static init (4);
dcl var int static init (5);
dcl value int static init (6);
dcl body int static init (7);
dcl impexp int static init (8);
dcl nn fixed bin (24);
dcl case_label fixed bin;

dcl (last_indent, decaler, reporter) fixed bin;
dcl 1 if_pdl (200) aligned,				/* Pushdown list. */
     2 level fixed bin unal,
     2 string char (100) varying,
     2 old_if_count fixed bin unal;
dcl level fixed bin;
dcl 1 do_pdl (200),
     2 level fixed bin unal,
     2 do_count fixed bin unal,
     2 old_do_count fixed bin;

dcl comment fixed bin init (0);
dcl end_com (2) char (2) varying int static init ("}", "*)");
dcl do_pdlx fixed bin;
dcl case_pdlx fixed bin;
dcl 1 case_pdl (200),
     2 (level, otherwise) fixed bin (35);
dcl do_count fixed bin;
dcl SP char (1) int static init (" ");			/* Single space. */
dcl SP_TAB char (2) int static init (" 	");		/* Tab and space, for verify etc. */
dcl SP_LP_NOT char (4) int static init (" ([^");
dcl NOT_LES_GRT char (3) int static init ("^<>");
dcl SP_TAB_COM_SEMI char (4) int static init (" ,;	");
dcl NL char (1) int static init ("
");
dcl TABS char (40) int static init ((40)"	");
dcl UCASE char (26) int static init ("ABCDEFGHIJKLNMOPQRSTUVWXYZ");
dcl LCASE char (26) int static init ("abcdefghijklnmopqrstuvwxyz");
dcl DIG_LET char (63) int static init ("abcdefghijklnmopqrstuvwxyzABCDEFGHIJKLNMOPQRSTUVWXYZ0123456789_");
dcl BPP char (3) int static init ("([.");
dcl DIGITS char (10) int static init ("0123456789");
dcl SIGNS char (8) int static init ("+<>-/*=.");

dcl bcs char (lth) based (p) aligned;
dcl bcso char (1048576) based (p1) aligned;

dcl cv_dec_check_ entry (char (*) aligned, fixed bin (35)) returns (fixed bin),
    ioa_ entry options (variable),
    com_err_ entry options (variable),
    cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35)),
    cu_$arg_count entry (fixed bin),
    expand_path_ entry (ptr, fixed bin, ptr, ptr, fixed bin (35)),
    hcs_$delentry_seg entry (ptr, fixed bin (35)),
    hcs_$truncate_seg entry (ptr, fixed bin, fixed bin (35)),
    hcs_$terminate_noname entry (ptr, fixed bin (35)),
    hcs_$make_seg entry (char (*) aligned, char (*) aligned, char (*) aligned, fixed bin (5),
         ptr, fixed bin (35)),
    hcs_$initiate_count entry (char (*) aligned, char (*) aligned, char (*) aligned, fixed bin (24),
         fixed bin (2), ptr, fixed bin (35)),
    get_pdir_ entry () returns (char (168) aligned),
    hcs_$set_bc_seg entry (ptr, fixed bin (24), fixed bin (35));

dcl (output_path_given, error_occurred, pretty, french) bit (1) aligned init ("0"b);



dcl moveseg char (nout) based aligned;			/* For copy of whole segment. */

dcl err_msg char (100) varying;

dcl error_table_$bad_arg fixed bin (35) ext;		/* Illegal command argument */
dcl error_table_$badopt fixed bin (35) ext;		/* Specified control arg not implemented by this command */
dcl error_table_$noarg fixed bin (35) ext;		/* Expected argument missing */
dcl error_table_$noentry fixed bin (35) ext;

dcl (null, substr, index, verify, reverse, unspec) builtin;
dcl (addr, divide, fixed, mod) builtin;

/* * * * * * * * * * * * * * * * * * * * * * * * */

/* pascal_indent: entry; */
pind: entry;

	simone = "0"b;
	my_name = "pascal";

	go to COMMON_INDENT;


simone_indent: entry;
sind: entry;

	simone = "1"b;
	my_name = "simone";

COMMON_INDENT:


	call cu_$arg_count (nargs);			/* get number of args */
	if nargs = 0 then do;			/* gripe if no args */
	     call com_err_ (0, my_name, "Usage: " || my_name || " old_path [new_path] {-control_args}");
	     return;
	end;

	lth1, lth2 = 0;				/* so we can tell if we have the pathnames yet */
arg_loop: do an = 1 to nargs;
	     call cu_$arg_ptr (an, ap, al, ec);		/* pick off next arg */

	     if ec ^= 0 then do;
print_bad_arg:	err_msg = "^a";			/* control string to just print argument */
arg_error:	call com_err_ (ec, my_name, err_msg, bchr);
		return;
	     end;

	     if expecting ^= 0 then do;

		en = bchr;			/* cv_dec_check_ needs aligned arg */
		i = cv_dec_check_ (en, ec);

		if expecting = 1 then do;		/* expecting left margin */
		     expecting = 0;
		     if ec ^= 0 then do;
blm:			err_msg = "illegal left margin arg ^a";
cv_dec_error:		ec = 0;			/* cv_dec_check_ does not return an error_table_ code */
			goto arg_error;		/* go call com_err_ */
		     end;
		     if i < 0 then goto blm;
		     if i > 100 then goto blm;
		     LMARGIN = i;
		end;

		else if expecting = 2 then do;	/* expecting indent spaces */
		     expecting = 0;
		     if ec ^= 0 then do;
bint:			err_msg = "illegal indent arg ^a";
			goto cv_dec_error;
		     end;
		     if i < 0 then goto bint;
		     if i > 100 then goto bint;
		     IN = i;
		end;

		else do;				/* must be expecting comment column */
		     expecting = 0;
		     if ec ^= 0 then do;
bcmc:			err_msg = "illegal comment column arg ^a";
			goto cv_dec_error;
		     end;
		     if i < 1 then goto bcmc;
		     if i > 350 then goto bcmc;
		     CMC = i;
		     TABCOL = 10 * divide (CMC - 1, 10, 17, 0);
		     NTAB = divide (TABCOL, 10, 17, 0);
		end;

	     end;					/* end of expecting argument do group */

	     else do;				/* not-expected-argument */

		if substr (bchr, 1, 1) = "-" then do;	/* Control argument? */
		     if bchr = "-brief" then bfsw = true;
		     else if bchr = "-bf" then bfsw = true;
		     else if bchr = "-lmargin" then expecting = 1;
		     else if bchr = "-lm" then expecting = 1;
		     else if bchr = "-indent" then expecting = 2;
		     else if bchr = "-in" then expecting = 2;
		     else if bchr = "-comment" then expecting = 3;
		     else if bchr = "-com" then expecting = 3;
		     else if bchr = "-highlight" then pretty = "1"b;
		     else if bchr = "-hl" then pretty = "1"b;
		     else if bchr = "-no_highlight" then pretty = "0"b;
		     else if bchr = "-nhl" then pretty = "0"b;
		     else if (bchr = "-lower_case") | (bchr = "-lc") then do;
			low = "1"b; up = "0"b;
		     end;
		     else if (bchr = "-upper_case") | (bchr = "-uc") then do;
			low = "0"b; up = "1"b;
		     end;
		     else if (bchr = "-long") | (bchr = "-lg") then bfsw = false;
		     else if bchr = "-french" then french = "1"b;
		     else if bchr = "-english" then french = "0"b;
		     else if (bchr = "-no_case_translation") | (bchr = "-nct") then
			low, up = "0"b;
		     else do;
			ec = error_table_$badopt;
			goto print_bad_arg;
		     end;
		end;

		else do;				/* Not control arg, must be filename */
		     if lth1 = 0 then do;		/* if we don't have input filename then this is it */
			n1 = bchr;		/* Pick up arg 1, input name */
			lth1 = al;		/* Remember length for expand path */
		     end;
		     else if lth2 = 0 then do;	/* if we don't have output filename, this is it */
			n2 = bchr;		/* User gave second name. Set it up. */
			lth2 = al;		/* Set length of second arg. */
			output_path_given = "1"b;
		     end;
		     else do;
			ec = error_table_$bad_arg;	/* "Illegal command argument" */
			goto print_bad_arg;		/* go call com_err_ to print the bad arg */
		     end;
		end;
	     end;					/* end of not-expected-argument do group */
	end arg_loop;				/* end of argument processing do group */

	if lth1 = 0 then do;			/* if input filename not given */
	     err_msg = "pathname of input file";
noarg_err:     ec = error_table_$noarg;
	     goto arg_error;
	end;

	if expecting ^= 0 then do;
	     err_msg = "after ^a";
	     goto noarg_err;
	end;

	if lth2 = 0 then do;			/* if output path not given, use input path */
	     n2 = n1;
	     lth2 = lth1;
	end;

	if pretty & (up = "0"b) & (low = "0"b) then low = "1"b;

/* END OF ARGUMENT PROCESSING */

/* Initialization */

	LMARGIN = LMARGIN - IN + 1;
	in = 1;
	case_label = 0;
	level = 0;
	ifdent, if_count, old_if_count = 0;
	strut, dclsw, condsw, ifsw, begin_ok, else_ok, sixty, string, pstring = false;
	bos, blsw = true;				/* Pretend line zero was empty. */
	in_inc_opt = false;
	case_pdlx = 0;
	if_pdlx = 1;				/* Set pushdown list to empty. */
	if_pdl (if_pdlx).level = -1;
	if_pdl (if_pdlx).string = " ";
	do_pdlx = 1;
	do_pdl (do_pdlx).level = -1;
	do_pdl (do_pdlx).do_count = 0;
	do_count = 0;
	do_pdl (do_pdlx).old_do_count = 0;
	linno = 1;				/* This is line 1. */
	offset, nout = 1;				/* read and write pointers */

	i = index (reverse (substr (n1, 1, lth1)), ".");	/* get last component */
	if i = 0 then go to in_suffix;		/* wrong size, don't bother */
	suffix = substr (n1, lth1 - i + 1, i);		/* includes "." */
	if suffix = "." || my_name
	then do;
	     suffix_len = 7;
	     go to good_suffix;
	end;

/* Didn't match list of good suffices */

in_suffix: suffix = "." || my_name;			/* a good guess */
	suffix_len = 7;
	substr (n1, lth1 + 1, suffix_len) = suffix;	/* add to name */
	lth1 = lth1 + suffix_len;			/* adjust length */
	suffix_assumed = "1"b;			/* remember, this was only a guess */

good_suffix:
	call expand_path_ (addr (n1), lth1, addr (dn), addr (en), ec);
	if ec ^= 0 then go to error;
	call hcs_$initiate_count (dn, en, "", lth, 0, p, ec);
	if p = null then go to error;			/* didn't find input seg */
	if substr (n2, lth2 - (suffix_len - 1), suffix_len) ^= substr (suffix, 1, suffix_len)
	then do;					/* output suffix must match input */
	     substr (n2, lth2 + 1, suffix_len) = substr (suffix, 1, suffix_len);
	     lth2 = lth2 + suffix_len;
	end;
	lth = divide (lth + 8, 9, 17, 0);		/* compute bit count of input seg */

	temp_en = en;				/* Generate name of temp file. */
	call hcs_$make_seg ((get_pdir_ ()), temp_en, "", 1010b, p1, ec);
	if p1 = null then go to error;
	call expand_path_ (addr (n2), lth2, addr (dn), addr (en), ec);
	if ec ^= 0 then go to error;

/* This is the loop for each line in the input segment. Starting at "offset" a line of "n" chars
   is moved to the temporary buffer "chars". Trailing tabs and blanks are trimmed. */

loop:	pstring = string;				/* remember if previous line ended inside quotes */
	if offset > lth then go to eof;
	i = index (substr (bcs, offset), NL);		/* Find length of line. */
	if i = 0 then i = lth - offset + 1;		/* .. in case did not end in NL */
	else if i = 1 then do;			/* Check for empty line. */
	     offset = offset + 1;
empty_line:
	     substr (bcso, nout, 1) = NL;		/* insert in output */
	     nout = nout + 1;
	     linno = linno + 1;
	     blsw = true;
	     go to loop;
	end;
	k = i - 1;
	if k > 400 then do;				/* Line too big? */
	     k, i = 385;				/* Take first 385 chars. */
	     call ioa_ (my_name || " : line ^d of ""^a"" was too long & has been split.", linno, en);
	     error_occurred = "1"b;
	end;
	chars = substr (bcs, offset, k);		/* Pick up line. */
	substr (chars, k + 1, 1) = NL;		/* Put in NL */
	line_offset = offset;			/* remember where line started */
	offset = offset + i;			/* Increase index. */
	n = k + 1;				/* Set up length of line. */
	if n = 1 then do;				/* Empty line? */
	     blsw = true;				/* Yes, set switch. */
	     go to cpy;				/* And just copy line. */
	end;

	decaler, reporter = 0;
	icb, ice, icol = 0;				/* Set up for loop. */
	scolsw, dclfnd, newpage, report_inc_opt = false;

/* The following section examines each character in the current line in "chars".
   In this section, "i" is the character index which may be from 1 to "n". */

	if pstring then do;				/* If we are now in a string, */
	     kk = index (substr (chars, 1, n - 1), "'");	/* .. See if it ends on this line. */
	     if kk = 0 then go to cpy;		/* Nope. Can't touch line at all. */
	     else i = kk;				/* Yes. Skip string content. */
	end;
	else i = 1;				/* Examine each character in line. */
	if case_label = 1 then reporter = 1;
	if (parcnt ^= 0) & (section = body) then decaler = 1;
	if inlist then decaler = 1;
	if if_pdl (if_pdlx).level = level then do;
	     if substr (if_pdl (if_pdlx).string, 1, 1) = "I" then decaler = 1;
	end;
l2s:	char = substr (chars, i, 1);			/* Pick up a character. */
	if string then do;				/* Now in a string ? */
	     if char = "'" then do;			/* Watch for end */
		string = false;			/* not any more */
						/* While this ignoring of possible double quotes within a
						   string works ok for indenting, it throws off string
						   length checking. However, since this checking is to
						   help locate missing quotes, it is not really necessary
						   to check for double quotes here. */
		string_len = line_offset + i - string_offset - 1; /* compute length, excluding the quotes */
		if string_len > 254 then /* if string is too long, report line number
						   to aid user in finding missing quote */
		     if ^bfsw then /* but only if user wants to be warned */
			if ^string_error then do;	/* report only the first one - if there is a missing quote,
						   there are probably a lot more long strings */
			     call ioa_
				(my_name || " : possible syntax error in line ^d of ^a: string length (^d) > pascal max.",
				linno, en, string_len);
			     string_error = "1"b;	/* remember not to report any more of these */
			     error_occurred = "1"b;
			end;
	     end;
	     go to nextch;				/* ... leaving all other chars */
	end;
	if comment ^= 0 then do;			/* are we now in a comment ? */
	     if substr (chars, i, comment) = end_com (comment) then do; /* comment ends ? */
		if i > 1 then if index (SP_TAB, substr (chars, i - 1, 1)) = 0
		     then call inb (i);		/* no we aren't, insert blank */
		ice = i;				/* Yes, save index. */
		if i < n - comment then /* Stuff after comment? */
		     if index (SP_TAB_COM_SEMI, substr (chars, i + comment, 1)) = 0 then
			if directive = 0 then call inb (i + comment); /* Nice blank after comment */
			else directive = 0;
		i = i + comment - 1;		/* Don't scan slash again. */
		comment = 0;
		go to nextch;			/* Comment leaves state unchanged. */
	     end;
	     if i = 1 then do;			/* Continue comment. Trim leading blanks and tabs. */
		k = verify (substr (chars, 1, n - 1), SP_TAB) - 1;
		if k = -1 then do;			/* if line of just white space inside comment */
		     chars = "";			/* replace it wich just a newline */
		     substr (chars, 1, 1) = NL;
		     n = 1;
		     go to cpy;
		end;
		substr (temchars, 1, n - k) = substr (chars, k + 1, n - k);
		substr (chars, 1, comment + 1) = "";	/* Stick in three or two blanks. */
		substr (chars, comment + 2, n - k) = substr (temchars, 1, n - k);
		i = comment + 2;
		n = n - k + comment + 1;
	     end;
	     kk = index (substr (chars, i, n - i), end_com (comment)); /* Character inside comment. Skip out to end. */
	     if kk = 0 then i = n - 1;
	     else i = i + kk - 2;			/* Set so we scan the 2 end next. */
	     go to nextch;
	end;
	k = fixed (unspec (char), 9);			/* See if char is ASCII */
	if k < 0 then go to ilchr;
	if k > 126 then go to ilchr;
	go to case (k);				/* Dispatch on character. */

/* Handlers for each character. */

/* Punctuation. */

case (009):					/* HT, octal 011 */
	substr (chars, i, 1) = SP;
case (032):					/* blank, octal 040 */
	if i = 1 then do;
	     call outb (i);
	     if n = 1 then go to empty_line;
	     go to nextch;
	end;
	if substr (chars, i - 1, 1) = SP then do;
squidge:	     call outb (i);
	end;
	go to nextch;				/* Ignore blank */
case (035):					/* "#", octal 043 */
	call isolate (1);
	go to cbs;
case (039):					/* "'", octal 047 */
	string = true;				/* now in string */
	string_offset = line_offset + i;		/* remember where it started, for length checking */
	kk = index (substr (chars, i + 1, n - i), "'");	/* Does string end on this line? */
	if kk > 0 then i = i + kk - 1;		/* Yes. Skip string contents. */
	else i = n - 1;				/* No. Skip rest of line. */
	go to nextch;
case (040):					/* "(", octal 050 */
	if in_inc_opt then call syntax;
	if i < n - 1 then do;
	     if substr (chars, i + 1, 1) = "*" then do;	/* comment */
		comment = 2;
		go to scan_com;
	     end;
	     if substr (chars, i + 1, 1) = "." then do;	/* synonym of "[" */
		call isolate (2);
		bracnt = bracnt + 1;
		go to cbs;
	     end;
	     if substr (chars, i + 1, 1) = "/" then do;
		call isolate (2);
		go to nextch;
	     end;
	end;
	if i = 1 then decaler = 1;
	parcnt = parcnt + 1;			/* Increase count. */
	if (section ^= body) & (section ^= proc) then par_right = par_right + 1;
	if i > 1 then if index (SP_LP_NOT, substr (chars, i - 1, 1)) = 0 then call inb (i);
	if i < n - 1 then call outb (i + 1);
	go to in_stat;				/* Condition prefix begins with paren. */
case (041):					/* ")", octal 051 */
	if in_inc_opt then call syntax;
	if i > 1 then call outb (i - 1);
	if i < n - 1 then if index (SP_TAB, substr (chars, i + 1, 1)) = 0 then call inb (i + 1);
	parcnt = parcnt - 1;			/* decrease parenthesis count. */
	if parcnt < 0 then do;			/* Check for more closes than opens. */
	     call ioa_ (my_name || " : line ^d of ""^a"" has an extra "")"".", linno, en);
	     error_occurred = "1"b;
	     parcnt = 0;
	end;
	else do;
	     if (section ^= body) & (section ^= proc) then par_left = par_left + 1;
	end;
	go to cbs;
case (042):					/* "*", octal 052 */
	call isolate (1);
	go to cbs;
case (043):					/* "+", octal 053 */
	go to tpm;
case (044):					/* ",", octal 054 */
	if i > 1 then call outb (i - 1);
	if i < n - 1 then if substr (chars, i + 1, 1) ^= SP then call inb (i + 1);
	go to nextch;
case (045):					/* "-", octal 055 */
tpm:
	if i > 2 then
	     if index ("eE", substr (chars, i - 1, 1)) ^= 0 then
		if index (DIGITS, substr (chars, i - 2, 1)) ^= 0 then do; /* real ? */
		     k = i - 3;
		     do while (k >= 1 & index (DIGITS, substr (chars, k, 1)) ^= 0);
			k = k - 1;
		     end;
		     if (k ^= 0) & (index (DIG_LET, substr (chars, k, 1)) = 0) then go to in_stat;
		end;
	if i = 1 then go to in_stat;
	if index (BPP, substr (chars, i - 1, 1)) ^= 0 then go to unaire;
	if i = 2 then go to in_stat;
	if index (SIGNS || ",", substr (chars, i - 2, 1)) ^= 0 then go to unaire;
	if i > 4 then if substr (chars, i - 4, 4) = " to " then go to unaire;
	if i > 7 then if substr (chars, i - 7, 7) = " downto " then go to unaire;
	call isolate (1);
	go to in_stat;
unaire:	call outb (i + 1);
	go to in_stat;
case (046):					/* ".", octal 056 */
	if in_inc_opt then call syntax;
	if i > 1 then call outb (i - 1);
	if i < n - 1 then do;
	     if substr (chars, i + 1, 1) = "." then do;
		if i < n - 2 then call outb (i + 2);
		i = i + 1;
		go to cbs;
	     end;
	     if substr (chars, i + 1, 1) = ")" then do;
		if i < n - 2 then if index (SP_TAB, substr (chars, i + 2, 1)) = 0 then call inb (i + 2);
		i = i + 1;
		if bracnt = 0 then do;
		     call ioa_ (my_name || " : line ^d of ""^a"" has one extra "".)"".", linno, en);
		     error_occurred = "1"b;
		end;
		else bracnt = bracnt - 1;
		go to cbs;
	     end;
	     call outb (i + 1);
	end;
	if end_count ^= bcr_count then
	     go to cbs;
	else go to nextch;
case (047):					/* "/", octal 057 */
	if i < n - 1 then if substr (chars, i + 1, 1) = ")" then do;
		call isolate (2);
		go to nextch;
	     end;
	call isolate (1);
	go to cbs;				/* Statement don't begin with slash */
case (058):					/* ":", octal 072 */
	if substr (chars, i + 1, 1) = "=" then do;	/* affectation */
	     if ^in_inc_opt then
		if bcr_count = end_count then call syntax;
	     if i > 1 then if substr (chars, i - 1, 1) ^= SP then call inb (i);
	     if i < n - 2 then if index (SP_TAB, substr (chars, i + 2, 1)) = 0 then call inb (i + 2);
	     i = i + 1;
	     go to in_stat;
	end;
	if section = impexp then inlist = "1"b;
	call isolate (1);
	if (parcnt > 0) | (section ^= body) then go to no_lab;
	bos = true;				/* This is label. keyword ok */
	if case_label = 1 then do;
	     if i < IN then do;
		do k = 2 to IN - i;
		     call inb (i + 1);
		end;
		i = IN;
	     end;
	     case_label = 0;
	end;
	else icol = i + 1;				/* Save index. */
no_lab:
	go to nextch;
case (059):					/* ";", octal 073 */
	if section = impexp then inlist = "0"b;
	call isolate (1);
	if parcnt ^= 0 then go to nextch;
	if section = proc then do;
	     pro_count = pro_count + 1;
	     section = 0;
	end;
	scolsw, bos = true;				/* Semicolon. End of statement. */
	if section = body then do;
	     if case_pdlx ^= 0 then
		if level = case_pdl (case_pdlx).level + 1 then
		     if case_pdl (case_pdlx).otherwise = 0 then
			case_label = 1;
	     if if_pdl (if_pdlx).level = level then do;
		if_count = if_pdl (if_pdlx).old_if_count;
		if index (if_pdl (if_pdlx).string, "I") ^= 0 then call syntax;
		if_pdlx = if_pdlx - 1;
	     end;
	     do while (do_pdl (do_pdlx).level >= level + if_count);
		do_count = do_pdl (do_pdlx).old_do_count;
		do_pdlx = do_pdlx - 1;
	     end;
	end;
	if bcr_count > end_count then
	     if parcnt > 0 then do;			/* Parenthesis count should be zero. */
		call ioa_ (my_name || " : ^d extra ""(""s at line ^d of ""^a"".",
		     parcnt, linno, en);		/* Complain. */
		error_occurred = "1"b;
		parcnt = 0;			/* Start over on count. */
	     end;
	go to nextch;
case (060):					/* "<", octal 074 */
	if in_inc_opt then call syntax;
	if i < n - 1 then if (substr (chars, i + 1, 1) = "=") | (substr (chars, i + 1, 1) = ">") then call isolate (2);
	     else call isolate (1);
	go to cbs;
case (061):					/* "=", octal 075 */
	if i < n - 1 then if substr (chars, i + 1, 1) ^= SP then call inb (i + 1);
	m = 1;
	if i > 1 then if index (NOT_LES_GRT, substr (chars, i - 1, 1)) ^= 0 then m = 2;
	if i > m then if substr (chars, i - m, 1) ^= SP then call inb (i - m + 1);
	go to cbs;
case (062):					/* ">", octal 076 */
	if in_inc_opt then call syntax;
	if i < n - 1 then if substr (chars, i + 1, 1) = "=" then call isolate (2);
	     else call isolate (1);
	go to cbs;
case (091):					/* "[", octal 133 */
	if in_inc_opt then call syntax;
	bracnt = bracnt + 1;
	if i > 1 then if index (SP_LP_NOT, substr (chars, i - 1, 1)) = 0 then call inb (i);
	if i < n - 1 then call outb (i + 1);
	go to in_stat;
case (093):					/* "]", octal 135 */
	if in_inc_opt then call syntax;
	if i > 1 then call outb (i - 1);
	if i < n - 1 then if index (SP_TAB, substr (chars, i + 1, 1)) = 0 then call inb (i + 1);
	if bracnt = 0 then do;
	     call ioa_ (my_name || " : line ^d of ""^a"" has one extra ""]"".", linno, en);
	     error_occurred = "1"b;
	end;
	else bracnt = bracnt - 1;
	go to cbs;
case (094):					/* "^", octal 136 */
	if in_inc_opt then call syntax;
	if i < n - 1 then if substr (chars, i + 1, 1) = "=" then call isolate (2);
	go to cbs;
case (123):					/* "{", octal 173 */
	comment = 1;
scan_com:
	if i > 1 then if substr (chars, i - 1, 1) ^= SP then call inb (i);
	icb = i;
	if i < n - comment then if index (SP_TAB, substr (chars, i + comment, 1)) = 0 then do;
		if substr (chars, i + comment, 1) ^= "$" then call inb (i + comment);
		else directive = 1;
	     end;
	kk = index (substr (chars, i + comment, n - i - comment), end_com (comment));
	if kk = 0 then i = n - 1;
	else i = i + kk - (2 - comment);
	go to nextch;
case (125):					/* "}", octal 175 */
	call ioa_ (my_name || " : one extra ""}"" at line ^d of ""^a"".", linno, en);
	go to cbs;

/* This section checks for reserved words . */

case (036):					/* "$", octal 044 */
case (065):					/* letter "A", octal 101 */
case (066):					/* letter "B", octal 102 */
case (067):					/* letter "C", octal 103 */
case (068):					/* letter "D", octal 104 */
case (069):					/* letter "E", octal 105 */
case (070):					/* letter "F", octal 106 */
case (071):					/* letter "G", octal 107 */
case (072):					/* letter "H", octal 110 */
case (073):					/* letter "I", octal 111 */
case (074):					/* letter "J", octal 112 */
case (075):					/* letter "K", octal 113 */
case (076):					/* letter "L", octal 114 */
case (077):					/* letter "M", octal 115 */
case (078):					/* letter "N", octal 116 */
case (079):					/* letter "O", octal 117 */
case (080):					/* letter "P", octal 120 */
case (081):					/* letter "Q", octal 121 */
case (082):					/* letter "R", octal 122 */
case (083):					/* letter "S", octal 123 */
case (084):					/* letter "T", octal 124 */
case (085):					/* letter "U", octal 125 */
case (086):					/* letter "V", octal 126 */
case (087):					/* letter "W", octal 127 */
case (088):					/* letter "X", octal 130 */
case (089):					/* letter "Y", octal 131 */
case (090):					/* letter "Z", octal 132 */
case (097):					/* letter "a", octal 141 */
case (098):					/* letter "b", octal 142 */
case (099):					/* letter "c", octal 143 */
case (100):					/* letter "d", octal 144 */
case (101):					/* letter "e", octal 145 */
case (102):					/* letter "f", octal 146 */
case (103):					/* letter "g", octal 147 */
case (104):					/* letter "h", octal 150 */
case (105):					/* letter "i", octal 151 */
case (106):					/* letter "j", octal 152 */
case (107):					/* letter "k", octal 153 */
case (108):					/* letter "l", octal 154 */
case (109):					/* letter "m", octal 155 */
case (110):					/* letter "n", octal 156 */
case (111):					/* letter "o". octal 157 */
case (112):					/* letter "p", octal 160 */
case (113):					/* letter "q", octal 161 */
case (114):					/* letter "r", octal 162 */
case (115):					/* letter "s", octal 163 */
case (116):					/* letter "t", octal 164 */
case (117):					/* letter "u", octal 165 */
case (118):					/* letter "v", octal 166 */
case (119):					/* letter "w", octal 167 */
case (120):					/* letter "x", octal 170 */
case (121):					/* letter "y", octal 171 */
case (122):					/* letter "z", octal 172 */
	j = i + 1;
	do while ((j < n) & (index (DIG_LET, substr (chars, j, 1)) ^= 0));
	     j = j + 1;
	end;
	j = j - i;
	if j <= 12 then do;
	     SYMBOL, symbol = translate (substr (chars, i, j), LCASE, UCASE);
	     if french then do;
		go to scanf (j);
scanf (1):
		go to scan (1);
scanf (2):	if SYMBOL = "de" then SYMBOL = "of";
		else if SYMBOL = "si" then SYMBOL = "if";
		go to scan (2);
scanf (3):
		if SYMBOL = "cas" then do;
		     SYMBOL = "case"; goto scan (4);
		end;
		if SYMBOL = "fin" then SYMBOL = "end";
		go to scan (3);
scanf (4):
		go to scan (4);
scanf (5):
		if SYMBOL = "faire" then do;
		     SYMBOL = "do"; go to scan (2);
		end;
		if SYMBOL = "alors" then do;
		     SYMBOL = "then"; go to scan (4);
		end;
		if SYMBOL = "sinon" then do;
		     SYMBOL = "else"; go to scan (4);
		end;
		if SYMBOL = "debut" then SYMBOL = "begin";
		go to scan (5);
scanf (6):
		if SYMBOL = "jusque" then do;
		     SYMBOL = "until"; go to scan (5);
		end;
		if simone & (SYMBOL = "module") then go to scan (6);
		go to scan (6);
scanf (7):
		if SYMBOL = "externe" then do;
		     SYMBOL = "external"; go to scan (8);
		end;
		if SYMBOL = "$valeur" then do;
		     SYMBOL = "$value"; go to scan (6);
		end;
		if SYMBOL = "repeter" then do;
		     SYMBOL = "repeat"; go to scan (6);
		end;
		if SYMBOL = "article" then do;
		     SYMBOL = "record"; go to scan (6);
		end;
		go to scan (7);
scanf (8):
		if SYMBOL = "plusloin" then do;
		     SYMBOL = "forward"; go to scan (7);
		end;
		if SYMBOL = "fonction" then
		     SYMBOL = "function";
		if simone & (SYMBOL = "moniteur") then do;
		     SYMBOL = "monitor";
		     go to scan (7);
		end;
		go to scan (8);
scanf (9):
		if SYMBOL = "etiquette" then do;
		     SYMBOL = "label"; go to scan (5);
		end;
		if SYMBOL = "programme" then do;
		     SYMBOL = "program"; go to scan (7);
		end;
		if SYMBOL = "autrement" then do;
		     SYMBOL = "otherwise"; go to scan (9);
		end;
		if simone & (SYMBOL = "processus") then do;
		     SYMBOL = "process";
		     go to scan (7);
		end;
		go to scan (9);
scanf (10):
		go to endscan;
scanf (11):
		go to endscan;
scanf (12):
		if simone & (SYMBOL = "finalisation") then do;
		     SYMBOL = "inner";
		     go to scan (5);
		end;
		go to endscan;
	     end;
	     go to scan (j);
scan (1):
	     if SYMBOL = "$" then
		if in_inc_opt then do;
		     in_inc_opt = false;
		     if report_inc_opt then icol = i + 1;
		end;
		else
		     if (section = impexp) then do;
		     inlist = "0"b;
		     section = proc;
		     if i = 1 then do;
			reporter = 1;
			if (n > 2) & (IN > 2) then do;
			     do k = 1 to IN - 2;
				call inb (i + 1);
			     end;
			     j = IN;
			end;
		     end;
		end;
		else if section ^= value then call syntax;
	     go to endscan;
scan (2):
	     if ^in_inc_opt then
		if SYMBOL = "of" then do;
		     if (parcnt = 0) & (section = body) then case_label = 1;
		end;
		else if SYMBOL = "if" then do;
		     if section ^= body then call syntax;
		     else do;
			if if_pdl (if_pdlx).level = level then do;
			     if substr (if_pdl (if_pdlx).string, 1, 1) = "I" then call syntax;
			     else if_pdl (if_pdlx).string = "I" || if_pdl (if_pdlx).string;
			end;
			else do;
			     if_pdlx = if_pdlx + 1;
			     if_pdl (if_pdlx).old_if_count = if_count;
			     if_pdl (if_pdlx).string = "I";
			     if_pdl (if_pdlx).level = level;
			end;
		     end;
		end;
		else if SYMBOL = "do" then do;
		     if section ^= body then call syntax;
		     else do;
			if do_pdl (do_pdlx).level = level + if_count then
			     do_pdl (do_pdlx).do_count = do_pdl (do_pdlx).do_count + 1;
			else do;
			     do_pdlx = do_pdlx + 1;
			     do_pdl (do_pdlx).level = level + if_count;
			     do_pdl (do_pdlx).do_count = 1;
			     do_pdl (do_pdlx).old_do_count = do_count;
			end;
			do_count = do_count + 1;
		     end;
		end;
	     go to endscan;
scan (3):
	     if ^in_inc_opt then
		if SYMBOL = "end" then do;
		     if section = body then call check_pb;
		     if end_count = bcr_count then do;
			call ioa_ (my_name || " : line ^d of ""^a"" has one extra ""end"".", linno, en);
			error_occurred = "1"b;
		     end;
		     else do;
			if section = body then do;
			     if if_pdl (if_pdlx).level = level then do;
				if i = icol + 1 then in = in - (if_count - if_pdl (if_pdlx).old_if_count);
				if_count = if_pdl (if_pdlx).old_if_count;
				if index (if_pdl (if_pdlx).string, "I") ^= 0 then call syntax;
				if_pdlx = if_pdlx - 1;
			     end;
			     do while (do_pdl (do_pdlx).level >= level + if_count);
				if i = icol + 1 then in = in - (do_count - do_pdl (do_pdlx).old_do_count);
				do_count = do_pdl (do_pdlx).old_do_count;
				do_pdlx = do_pdlx - 1;
			     end;
			end;
			end_count = end_count + 1;
			level = level - 1;
			if case_pdlx ^= 0 then if case_pdl (case_pdlx).level = level then do;
				case_pdlx = case_pdlx - 1;
				end_count = end_count + 1;
				level = level - 1;
				if i = icol + 1 then in = in - 1;
				case_label = 0;
			     end;
			if i = icol + 1 then reporter = 1;
		     end;
		end;
		else if SYMBOL = "var" then if parcnt = 0 then do;
			section = var;
			call check_blocks;
			if i = 1 then do;
			     reporter = 1;
			     if (n > 4) & (IN > 4) then do;
				do k = 1 to IN - 4;
				     call inb (i + 3);
				end;
				j = IN;
			     end;
			end;
		     end;
	     go to endscan;
scan (4):
	     if ^in_inc_opt then
		if SYMBOL = "then" then do;
		     if section ^= body then call syntax;
		     else do;
			if if_pdl (if_pdlx).level ^= level then call syntax;
			else do;
			     if substr (if_pdl (if_pdlx).string, 1, 1) ^= "I" then call syntax;
			     else do;
				substr (if_pdl (if_pdlx).string, 1, 1) = "T";
				if i = 1 then reporter = 1;
				if_count = if_count + 1;
			     end;
			end;
		     end;
		end;
		else if (SYMBOL = "else") then do;
		     if section ^= body then call syntax;
		     else do;
			if if_pdl (if_pdlx).level ^= level then call syntax;
			else do;
			     k = index (if_pdl (if_pdlx).string, "T");
			     if k = 0 then call syntax;
			     else if index (substr (if_pdl (if_pdlx).string, 1, k), "T") ^= 0 then do;
				if_pdl (if_pdlx).string = "E" || substr (if_pdl (if_pdlx).string, k + 1);
				k = k - 1;
				if_count = if_count - k;
				if i = icol + 1 then in = in - k;
				do while (do_pdl (do_pdlx).level >= level + if_count);
				     if i = icol + 1 then in = in - (do_count - do_pdl (do_pdlx).old_do_count);
				     do_count = do_pdl (do_pdlx).old_do_count;
				     do_pdlx = do_pdlx - 1;
				end;
				if i = icol + 1 then reporter = 1;
			     end;
			end;
		     end;
		end;
		else if SYMBOL = "case" then do;
		     if section = body then do;
			bcr_count = bcr_count + 2;
			level = level + 1;
			case_pdlx = case_pdlx + 1;
			case_pdl (case_pdlx).level = level;
			case_pdl (case_pdlx).otherwise = 0;
			level = level + 1;
		     end;
		end;
		else if SYMBOL = "type" then do;
		     call check_blocks;
		     section = type;
		     if i = 1 then do;
			reporter = 1;
			if (n > 5) & (IN > 5) then do;
			     do k = 1 to IN - 5;
				call inb (i + 4);
			     end;
			     j = IN;
			end;
		     end;
		end;
	     go to endscan;
scan (5):
	     if ^in_inc_opt then
		if SYMBOL = "until" then do;
		     if section ^= body then call syntax;
		     else do;
			call check_pb;
			if rpt_count = unt_count then do;
			     call ioa_ (my_name || " : line ^d of ""^a"" has one extra ""until"".", linno, en);
			     error_occurred = "1"b;
			end;
			else do;
			     if if_pdl (if_pdlx).level = level then do;
				if i = icol + 1 then in = in - (if_count - if_pdl (if_pdlx).old_if_count);
				if_count = if_pdl (if_pdlx).old_if_count;
				if index (if_pdl (if_pdlx).string, "I") ^= 0 then call syntax;
				if_pdlx = if_pdlx - 1;
			     end;
			     do while (do_pdl (do_pdlx).level >= level + if_count);
				if i = icol + 1 then in = in - (do_count - do_pdl (do_pdlx).old_do_count);
				do_count = do_pdl (do_pdlx).old_do_count;
				do_pdlx = do_pdlx - 1;
			     end;
			     unt_count = unt_count + 1;
			     level = level - 1;
			     if i = icol + 1 then reporter = 1;
			end;
		     end;
		end;
		else if SYMBOL = "begin" then do;
		     if (section ^= body) | (bcr_count = end_count) then do;
			call check_blocks;
			section = body;
			pro_count = pro_count - 1;
			bos = true;
			if i = icol + 1 then in = in - 1;
		     end;
		     call check_pb;
		     bcr_count = bcr_count + 1;
		     level = level + 1;
		end;
		else if SYMBOL = "const" then do;
		     call check_blocks;
		     section = const;
		     if i = 1 then do;
			reporter = 1;
			if (n > 6) & (IN > 6) then do;
			     do k = 1 to IN - 6;
				call inb (i + 5);
			     end;
			     j = IN;
			end;
		     end;
		end;
		else if SYMBOL = "label" then do;
		     call check_blocks;
		     section = label;
		     if i = 1 then do;
			reporter = 1;
			if (n > 6) & (IN > 6) then do;
			     do k = 1 to IN - 6;
				call inb (i + 5);
			     end;
			     j = IN;
			end;
		     end;
		end;
		else if simone & (SYMBOL = "inner") then
		     if i = 1 then reporter = 1;
	     go to endscan;
scan (6):
	     if ^in_inc_opt then
		if SYMBOL = "repeat" then do;
		     call check_pb;
		     rpt_count = rpt_count + 1;
		     level = level + 1;
		end;
		else if SYMBOL = "record" then do;
		     bcr_count = bcr_count + 1;
		     level = level + 1;
		end;
		else if ((SYMBOL = "pascal") & (section = 0)) then do;
		     call check_pb;
		     pro_count = pro_count - 1;
		end;
		else if SYMBOL = "$value" then do;
		     call check_blocks;
		     section = value;
		     if i = 1 then do;
			reporter = 1;
			if (n > 6) & (IN > 6) then do;
			     do k = 1 to IN - 6;
				call inb (i + 5);
			     end;
			     j = IN;
			end;
		     end;
		end;
		else if simone & (SYMBOL = "module") then do;
		     section = proc;
		     call check_blocks;
		     if i = 1 then reporter = 1;
		end;
	     go to endscan;
scan (7):
	     if ^in_inc_opt then
		if (SYMBOL = "forward") then do;
		     call check_pb;
		     pro_count = pro_count - 1;
		end;
		else if SYMBOL = "program" then do;
		     section = proc;
		     call check_pb;
		     pro_count = pro_count + 1;
		     if i = 1 then reporter = 1;
		end;
		else if (SYMBOL = "$import") | (SYMBOL = "$export") then do;
		     section = impexp;
		     call check_blocks;
		     if i = 1 then do;
			reporter = 1;
			if (n > 8) & (IN > 8) then do;
			     do k = 1 to IN - 8;
				call inb (i + 7);
			     end;
			     j = IN;
			end;
		     end;
		end;
		else if simone & ((SYMBOL = "process") | (SYMBOL = "monitor")) then do;
		     section = proc;
		     call check_blocks;
		     if i = 1 then reporter = 1;
		end;
	     go to endscan;
scan (8):
	     if ^in_inc_opt then do;
		if SYMBOL = "external" then do;
		     call check_blocks;
		     pro_count = pro_count - 1;
		end;
		else if SYMBOL = "function" then do;
		     if parcnt = 0 then do;
			section = proc;
			call check_blocks;
			if i = 1 then reporter = 1;
		     end;
		end;
	     end;
	     if (SYMBOL = "$include") | (SYMBOL = "$options") then do;
		if in_inc_opt then call syntax;
		in_inc_opt = true;
		if i = 1 then report_inc_opt = true;
	     end;
	     go to endscan;
scan (9):
	     if ^in_inc_opt then
		if SYMBOL = "procedure" then do;
		     if parcnt = 0 then do;
			section = proc;
			call check_blocks;
			if i = 1 then reporter = 1;
		     end;
		end;
		else if symbol = "otherwise" then
		     if case_label = 1 then do;
			case_label = 0;
			case_pdl (case_pdlx).otherwise = 1;
		     end;
scan (10):
scan (11):
scan (12):
endscan:
	     if pretty then
		if (french &
		     ((simone & ((symbol = "module") | (symbol = "processus")
		     | (symbol = "moniteur") | (symbol = "finalisation") | (symbol = "exit") | (symbol = "lancer") | (symbol = "terminaison")))
		     | (symbol = "si") | (symbol = "de") | (symbol = "et") | (symbol = "ou")
		     | (symbol = "fin") | (symbol = "div") | (symbol = "cas") | (symbol = "nil") | (symbol = "mod") | (symbol = "non") | (symbol = "var") | (symbol = "bas")
		     | (symbol = "avec") | (symbol = "dans") | (symbol = "haut") | (symbol = "pour") | (symbol = "type")
		     | (symbol = "alors") | (symbol = "sinon") | (symbol = "debut") | (symbol = "const") | (symbol = "faire")
		     | (symbol = "paquet") | (symbol = "allera") | (symbol = "jusque")
		     | (symbol = "fichier") | (symbol = "tantque") | (symbol = "article") | (symbol = "externa") | (symbol = "tableau") | (symbol = "repeter") | (symbol = "$valeur")
		     | (symbol = "fonction") | (symbol = "$importe") | (symbol = "$exporte") | (symbol = "$include") | (symbol = "$options") | (symbol = "plusloin")
		     | (symbol = "procedure") | (symbol = "programme") | (symbol = "etiquette")))
		     | (^french &
		     ((simone & ((symbol = "module") | (symbol = "process")
		     | (symbol = "monitor") | (symbol = "inner") | (symbol = "exit") | (symbol = "start") | (symbol = "terminate")))
		     | (symbol = "do") | (symbol = "of") | (symbol = "if") | (symbol = "to") | (symbol = "in") | (symbol = "or")
		     | (symbol = "end") | (symbol = "div") | (symbol = "and") | (symbol = "nil") | (symbol = "mod") | (symbol = "not") | (symbol = "for") | (symbol = "var") | (symbol = "set")
		     | (symbol = "then") | (symbol = "case") | (symbol = "file") | (symbol = "else") | (symbol = "with") | (symbol = "goto") | (symbol = "type")
		     | (symbol = "while") | (symbol = "label") | (symbol = "begin") | (symbol = "array") | (symbol = "until") | (symbol = "const")
		     | (symbol = "record") | (symbol = "repeat") | (symbol = "packed") | (symbol = "downto") | (symbol = "$value")
		     | (symbol = "program") | (symbol = "$import") | (symbol = "$export") | (symbol = "forward")
		     | (symbol = "function") | (symbol = "$include") | (symbol = "$options") | (symbol = "external")
		     | (symbol = "procedure")))
		then do;
		     if up then substr (chars, i, j) = translate (substr (chars, i, j), LCASE, UCASE);
		     else substr (chars, i, j) = translate (substr (chars, i, j), UCASE, LCASE);
		     i = i + j - 1;
		     go to in_stat;
		end;
	end;
	if up = "1"b then substr (chars, i, j) = translate (substr (chars, i, j), UCASE, LCASE);
	if low = "1"b then substr (chars, i, j) = translate (substr (chars, i, j), LCASE, UCASE);
	i = i + j - 1;
	go to in_stat;

/* Illegal characters. Squawk and continue. */

case (000):					/* NUL, octal 000 */
case (001):					/* undefined, octal 001 */
case (002):					/* undefined, octal 002 */
case (003):					/* undefined, octal 003 */
case (004):					/* undefined, octal 004 */
case (005):					/* undefined, octal 005 */
case (006):					/* undefined, octal 006 */
case (007):					/* BEL, octal 007 */
case (008):					/* BS, octal 010 */
case (013):					/* CR, octal 015 */
case (014):					/* RRS, octal 016 */
case (015):					/* BRS, octal 017 */
case (016):					/* undefined, octal 020 */
case (017):					/* undefined, octal 021 */
case (018):					/* undefined, octal 022 */
case (019):					/* undefined, octal 023 */
case (020):					/* undefined, octal 024 */
case (021):					/* undefined, octal 025 */
case (022):					/* undefined, octal 026 */
case (023):					/* undefined, octal 027 */
case (024):					/* undefined, octal 030 */
case (025):					/* undefined, octal 031 */
case (026):					/* undefined, octal 032 */
case (027):					/* undefined, octal 033 */
case (028):					/* undefined, octal 034 */
case (029):					/* undefined, octal 035 */
case (030):					/* undefined, octal 036 */
case (031):					/* EGM, octal 037 */
ilchr:	call ioa_ (my_name || " : warning: illegal character (octal ^3.3b) in line ^d of ""^a""",
	     unspec (substr (chars, i, 1)), linno, en);
	error_occurred = "1"b;
	go to nextch;

case (010):					/* NL, octal 012 */
case (011):					/* VT, octal 013 */
case (012):					/* NP, octal 014 */
case (033):					/* "!", octal 041 */
case (034):					/* """, octal 042 */
case (037):					/* "%", octal 045 */
case (038):					/* "&", octal 046 */
case (063):					/* "?", octal 077 */
case (092):					/* "\", octal 134 */
case (096):					/* "`", octal 140 */
case (095):					/* "_", octal 137 */
case (124):					/* "|", octal 174 */
case (126):					/* "~", octal 176 */
	if ^bfsw then do;				/* Unless brief mode, gripe */
	     call ioa_ (my_name || " : warning: non-pascal char ""^a"" outside string in line ^d of ""^a""",
		substr (chars, i, 1), linno, en);
	     error_occurred = "1"b;
	end;
	go to nextch;

/* Chars which are legal but cannot begin a statement. */

case (064):					/* "@", octal 100 */
cbs:	if bos then if ^bfsw then do;
		call ioa_ (my_name || " : possible syntax error in line ^d of ^a detected at char ""^a""",
		     linno, en, substr (chars, i, 1));
		error_occurred = "1"b;
	     end;

/* Chars which are legal beginnings of statement. */

case (048):					/* digit "0", octal 060 */
case (049):					/* digit "1", octal 061 */
case (050):					/* digit "2", octal 062 */
case (051):					/* digit "3", octal 063 */
case (052):					/* digit "4", octal 064 */
case (053):					/* digit "5", octal 065 */
case (054):					/* digit "6", octal 066 */
case (055):					/* digit "7", octal 067 */
case (056):					/* digit "8", octal 070 */
case (057):					/* digit "9", octal 071 */
in_stat:	bos = false;				/* No longer at beginning of statement. */
	else_ok = false;				/* ELSE no longer legal. */
nextch:	i = i + 1;				/* Increase index in working array. */
	if i < n then go to l2s;			/* If any chars left, go thru again. */

	if n > 1 then do;				/* remove last blank if any */
	     if substr (chars, n - 1, 1) = " " then do;
		n = n - 1;
		substr (chars, n, 1) = NL;
	     end;
	end;

/* come here when all characters in line examined */

	i = 1;					/* "i" will be the index in the "chars" buffer. */
	if icb = 1 then do;				/* Does line start with comment? */
	     if blsw then do;			/* Yes. Previous line empty? */
		sixty = false;			/* Yes, start in column 1. */
		go to cpy;			/* Just copy line. */
	     end;
push:	     sixty = true;				/* Comment goes in column 60. */
	     ntab = NTAB;
	     i = 1; colpos = 0;
	     go to nimcom;
	end;
	if icb = 0 then if (comment ^= 0 | ice > 0) then do; /* Continuation of comment ^= 0 ? */
		if sixty then go to push;		/* Do we indent it? */
cpy:		substr (bcso, nout, n) = substr (chars, 1, n); /* Copy whole line. */
		nout = nout + n;
		go to finish_line;
	     end;

/* This section computes the left margin for each line. */

	blsw = false;				/* Not empty line. */
	if pstring then do;
	     indent = 0;				/* don't indent inside quoted string */
	     icol = 0;
	end;
	else do;
	     indent = (in - 1) * IN + LMARGIN;		/* Compute indentation. */
	     if decaler ^= 0 then indent = indent + (decaler * IN);
	     if reporter ^= 0 then indent = indent - (reporter * IN);
	     if indent < 0 then indent = 0;
	     last_indent = indent;
	end;

/* This section copies the line into the output seg, inserting blanks and tabs. */

	if icol >= n then go to cpy;			/* If line is just a label, do it the easy way. */
	colpos = 0;				/* Remember where started. */
	if icol ^= 0 then do;
	     substr (bcso, nout, icol) = substr (chars, 1, icol); /* Copy label section if any. */
	     nout = nout + icol;			/* Increase offset. */
	     colpos = colpos + icol;			/* and column. */
	end;
	i = icol + 1;
	if i ^= icb then /* Handle case of just label and comment. */
	     if indent > icol then do;		/* Must insert blanks. */
		if substr (chars, icol, 1) = SP then do;/* a blank was included in icol for labels */
		     icol = icol - 1;		/* Back up by one char, to prevent space-tab. */
		     colpos = colpos - 1;
		     nout = nout - 1;
		end;
		k = indent - icol - 1;		/* Calculate number of blanks required. */
		colpos = colpos + k;		/* Calculate new column position in output. */
		if colpos >= 10 then do;		/* Replace blanks by tabs if possible */
		     kk = divide (colpos, 10, 17, 0) - divide (icol, 10, 17, 0);
		     if kk > 0 then do;
			substr (bcso, nout, kk) = substr (TABS, 1, kk);
			nout = nout + kk;
			k = mod (colpos, 10);	/* Tab column might not be multiple of 10 */
		     end;
		end;
		if k ^= 0 then do;
		     substr (bcso, nout, k) = "";	/* Run in blanks. */
		     nout = nout + k;
		end;
	     end;
	if ice ^= 0 then if ice >= n - 2 then go to havcom; /* If comment is last thing on line, */
						/* or if comment is last on line except end of statement, */
	if ice = 0 then if icb > 0 then do;		/* or if comment starts on this line and doesn't end.. */
havcom:		sixty = true;			/* Yes, move comment to column 60. */
		k = icb - i;			/* Copy statement part. */
		if k ^= 0 then do;
		     substr (bcso, nout, k) = substr (chars, i, k);
		     nout = nout + k;
		     colpos = colpos + k;		/* Keep track of column. */
		     i = i + k;
		end;
nimcom:
		k = CMC - colpos - 1;		/* In case tab column not 10 * x + 1 */
		if k > 0 then do;
		     substr (bcso, nout, k) = "";	/* Run in blanks */
		     nout = nout + k;
		end;
	     end;
	k = n - i + 1;
	if k ^= 0 then do;
	     substr (bcso, nout, k) = substr (chars, i, k); /* Copy remainder of line. */
	     nout = nout + k;
	end;

	in = do_count + if_count + bcr_count + rpt_count + pro_count - unt_count - end_count + par_right - par_left; /* compute indentation base for next line */
	dclsw = dclsw & ^scolsw;			/* In declaration if were in and no semicolon. */

/* Finished with the line. Go get another. */

finish_line:
	linno = linno + 1;				/* Count line. */
	if nout ^> 2 then go to loop;			/* too short to check */
	i = verify (reverse (substr (bcso, 1, nout - 2)), SP_TAB); /* check for trailing white space in line copied */
	if i = 1 then go to loop;			/* there was none */
	if i = 0 then i = nout - 2;			/* there was a lot */
	else i = i - 1;				/* there was some */
	if string then do;				/* if in a string, bad news because its invisible */
	     if ^bfsw then call ioa_
		     (my_name || " : Line ^d of ""^a"" contains trailing white space that is part of a string.",
		     linno - 1, en);
	     go to loop;				/* Don't change */
	end;
	nout = nout - i;				/* back up end over white space */
	substr (bcso, nout - 1, 1) = NL;		/* put in a new newline */
	unspec (substr (bcso, nout, i)) = "0"b;		/* clean out the extra stuff that was moved in */
	go to loop;

/* Control comes here when the input segment is exhausted. */

eof:
	if end_count < bcr_count then do;
	     call ioa_ (my_name || " : ""^a"" has ^d too few ""end""s.", en, bcr_count - end_count);
	     error_occurred = "1"b;
	end;
	if unt_count < rpt_count then do;
	     call ioa_ (my_name || " : ""^a"" has ^d too few ""until""s.", en, rpt_count - unt_count);
	     error_occurred = "1"b;
	end;
	if string then do;
	     call ioa_ (my_name || " : ""^a"" ends in a string.", en);
	     error_occurred = "1"b;
	end;
	if comment ^= 0 then do;
	     call ioa_ (my_name || " : ""^a"" ends in a comment.", en);
	     error_occurred = "1"b;
	end;
	if parcnt > 0 then do;
	     call ioa_ (my_name || " : ""^a"" has ^d extra ""(""s.", en, parcnt);
	     error_occurred = "1"b;
	end;
	if bracnt > 0 then do;
	     call ioa_ (my_name || " : ""^a"" has ^d extra ""[""s.", en, bracnt);
	     error_occurred = "1"b;
	end;

	call hcs_$terminate_noname (p, ec);		/* Terminate input segment. */

	lth = 9 * (nout - 1);			/* Compute bit count. */
	call hcs_$set_bc_seg (p1, lth, ec);		/* Set bit count on temp, in case of error. */

	if error_occurred then
	     if ^output_path_given then do;
		call com_err_ (0, my_name, "Input segment not replaced. Indented copy is in [pd]>^a", temp_en);
		return;
	     end;

	call hcs_$make_seg (dn, en, "", 1011b, p, ec);	/* Get ptr to final output. Make if necessary */
	if p = null then go to error1;
	call hcs_$truncate_seg (p, 0, ec);		/* Truncate target. */
	if ec ^= 0 then do;
error1:	     call com_err_ (ec, my_name, "Cannot copy ^a from [pd]>^a", en, temp_en);
	     return;
	end;
	p -> moveseg = p1 -> moveseg;			/* Zap. */
	call hcs_$set_bc_seg (p, lth, ec);		/* Set bit count. */
	call hcs_$terminate_noname (p, ec);		/* Terminate output. */
	call hcs_$delentry_seg (p1, ec);		/* Delete scratch segment. */
	return;					/* Happy return. */

error:	call com_err_ (ec, my_name, n1);		/* Here to gripe to user */
	return;					/* And give up */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* Insert a blank at "ix" */

inb: proc (ix);
dcl ix fixed bin (24);				/* Index in work array where blank goes. */
	substr (temchars, 1, n - ix + 1) = substr (chars, ix, n - ix + 1);
	substr (chars, ix + 1, n - ix + 1) = substr (temchars, 1, n - ix + 1);
	substr (chars, ix, 1) = SP;			/* Insert blank. */
	n = n + 1;				/* Up the line length. */
	if ix <= i then i = i + 1;			/* did we change the character looked at? */
     end inb;

/* This procedure removes all consecutive blanks starting at "ix" */

outb: proc (ix);
dcl ix fixed bin (24);

	nn = verify (substr (chars, ix, n - ix + 1), SP_TAB) - 1;
	if nn > 0 then do;
	     substr (temchars, 1, n - ix - nn + 1) = substr (chars, ix + nn, n - ix - nn + 1);
	     substr (chars, ix, n - ix - nn + 1) = substr (temchars, 1, n - ix - nn + 1);
	     n = n - nn;
	     if ix = i then i = i - 1;		/* Back up one if now looking at new char. */
	     else if ix < i then i = i - nn;
	end;
     end outb;

/* this procedure checks that reserved words are not between parenthesis or braces */

check_pb: proc;
	if parcnt > 0 then do;
	     call ioa_ (my_name || " : ^d "")""s missing at line ^d of ""^a"".", parcnt, linno, en);
	     parcnt = 0;
	end;
	if bracnt > 0 then do;
	     call ioa_ (my_name || " : ^d ""]""s missing at line ^d of ""^a"".", bracnt, linno, en);
	     bracnt = 0;
	end;
	par_right, par_left = 0;

	return;

     end check_pb;

/* this procedure signals possible syntax error */

syntax: proc;
	call ioa_ (my_name || " : possible syntax error in line ^d of ""^a"".", linno, en);
	error_occurred = "1"b;
	return;

     end syntax;

/* this procedure to insert one blank after and before */

isolate: proc (k);
dcl k fixed bin;
	if i > 1 then if substr (chars, i - 1, 1) ^= SP then call inb (i);
	if i < n - k then do;
	     if index (SP_TAB, substr (chars, i + k, 1)) = 0 then
		call inb (i + k);
	end;
	i = i + k - 1;
	return;
     end isolate;

/* this procedure to check if all blocks are closed */

check_blocks: proc;

	call check_pb;

	if bcr_count ^= end_count then do;
	     if bcr_count > end_count then
		call ioa_ (my_name || " : ^d ""end""s missing before or in line ^d of ""^a"".",
		     bcr_count - end_count, linno, en);
	     else if bcr_count < end_count then
		call ioa_ (my_name || " : ^d extra ""end""s before or in line ^d of ""^a"".", end_count - bcr_count, linno, en);
	     error_occurred = "1"b;
	end;
	bcr_count, end_count = 0;

	if rpt_count ^= unt_count then do;
	     if rpt_count > unt_count then
		call ioa_ (my_name || " : ^d ""until""s missing before or in line ^d of ""^a"".",
		     rpt_count - unt_count, linno, en);
	     else if rpt_count < unt_count then
		call ioa_ (my_name || " : ^d extra ""until""s before or in line ^d of ""^a"".",
		     unt_count - rpt_count, linno, en);
	     error_occurred = "1"b;
	end;
	rpt_count, unt_count = 0;

	return;

     end check_blocks;
     end pascal_indent;
