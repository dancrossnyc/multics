" ******************************************************
" *                                                    *
" * Copyright, (C) Honeywell Limited, 1983             *
" *                                                    *
" * Copyright (c) 1972 by Massachusetts Institute of   *
" * Technology and Honeywell Information Systems, Inc. *
" *                                                    *
" ******************************************************

" HISTORY COMMENTS:
"  1) change(86-07-14,BWong), approve(86-07-14,MCR7286),
"     audit(86-07-17,Ginter), install(86-07-28,MR12.0-1105):
"     Fix fortran bugs 430 and 463.
"  2) change(86-07-14,BWong), approve(86-07-14,MCR7442),
"     audit(86-07-17,Ginter), install(86-07-28,MR12.0-1105):
"     Fix fortran bug 410.
"  3) change(88-04-28,RWaters), approve(88-04-28,MCR7875),
"     audit(88-07-13,Huen), install(88-11-10,MR12.2-1209):
"     Implement SCP 6339: Removed the special case code for constants since
"     they can now be up to 128K characters long.
"                                                      END HISTORY COMMENTS


" Written:	January 1976, by G. D. Chang
" Rewritten:	November 1977, by D. S. Levin for optimizing code generator.
"
" Modified:
"         08 Mar 86, SH - 410: Fix bug in cv_bif_to_external where offsets 
"		into vector for dtan, asin, dasin and acos were out
"		of order.
"	08 Aug 85, BW - 430: Prevent emission of deallocation code for
"		automatic LA's and VLA's when they don't exist in the
"		compilation unit.
"	02 Aug 85, BW - 463: Removed code to save and restore stack
"		extents in 'quick_return' and 'make_quick_entry'.
"		This was only done when char star-extent variables
"		were concatenated.
"         12 May 95, BW - 452: Fix looping problem when a vla array is
"		incorrectly used as a format in a write statement.
"	16 Jan 85, MM - 446: Computed GOTO must save state before branching
"		but after loading the Q register and setting indicators.
"	10 Oct 84, MM - Change "fno" to "fad =0.0,du".
"	22 Jun 84, MM - Install typeless functions support.
"	28 Mar 84, HH - Install HFP support.
"	27 Jul 83, HH - 390: Computed GOTO must save state before branching.
"	17 Jun 83, HH - 383: Replace 'scan_parameter_list' subroutine with
"		'prepare_for_namelists' subr and 'process_param_list' proc.
"	 7 June 83, TO: 381 - Fix pr0|shorten_stack for registers pr1,x1.
"	14 Apr 83, HH - 376: Add support for 'len' builtin.
"	31 Jan 83, TO & HH - Install LA/VLA support.
"	10 January  1982, TO - Add 'emit_entry_defs' call to entries.
"	18 Dec 82, TO - Add 'emit_profile_entry' simple operator.
"	27 July 1982, TO - Fix check in relational operators to permit
"	     temporary nodes, such as expressions and function returns in
"	     relationals with character constants.
"	13 May 1982, HH - Add "fixedoverflow" check for multiplies.
"	 6 May 1982, TO - Add shorten stack to return from char*(*) function.
"	 3 May 1982, TO - Add arithmetic 'if' optimization for constant
"		expressions.
"	 1 April   1982, TO  - External intrinsic references to builtins.
"	29 October 1981, CRD - Inquire statement.
"	20 October 1981, CRD - Internal files.
"	4 September 1981, CRD - Fix bug 339.
"	27 August 1981, CRD - More general UNIT field in OPEN/CLOSE stmts.
"	21 August 1981, CRD - Blank field in OPEN statement.
"	31 July 1981, CRD - Add code to optimize jump_true and jump_false
"		operators with constant inputs.
"	28 July 1981, CRD - Allow format labels in assign_label operator,
"		and allow integer scalars in format operator.
"	10 June 1981, CRD - New polish for backspace/endfile/rewind.
"	12 May 1981, CRD - Add equiv_op, not_equiv_op.
"	23 April 1981, CRD - Fix bug 317.
"	13 March 1981, CRD - Modifications for assumed size arrays.
"	9 December 1980, CRD - Modifications for Fortran 77 block IF.  Also
"		moved error 330's to end of segment.
"	19 November 1980, CRD - Change several I/O routines to issue load_pr
"		macros BEFORE loading the A or Q.  This is necessary as
"		loading a pointer to a character array element may use the
"		A or Q.
"	28 October 1980, CRD - Add new intrinsics for Fortran 77.
"	24 September 1980, CRD - Change make_quick_entry to assert that pr1
"		contains the arg list ptr.
"	15 August 1980, CRD - Fix ref count bugs in variable length I/O.
"	13 August 1980, CRD - Add error_macro segdef.
"	16 July 1980, CRD - Key argument list consistency checking off
"		variable_arglist bit, not needs_descriptors bit.
"	15 July 1980, CRD - Centralize call-side descriptor checking in
"		descriptor_check subroutine.  Change logic so that
"		descriptors are automatically generated for calls with
"		character mode arguments in ansi77 mode.
"	27 June 1980, CRD - Add code to allow I/O of strings of variable
"		length.  Also insert check to make sure character valued
"		functions are not of *-length.
"	17 April 1980, CRD - Add code to implement concatenation.
"	26 March 1980, CRD - Fix bug in xmit_scalar - temps in Q not getting saved.
"	23 Feb 1980, RAB - improve code for conversion from float to integer,
"		add code to use ADE in multiply/divide by power of two for
"		floating point, fix glitch in open.
"	11 Feb 1980, CRD - add code for eight new builtins: CHAR, ICHAR,
"		INDEX, LEN, LGE, LGT, LLE, and LLT.
"	4 Feb 1980, CRD - add support for entries requiring descriptors.
"	27 Jan 1980, RAB - to improve code for jump_computed.
"	27 Jan 1980, RAB - to change most conversions from integer to float
"		from calls to pl1_operators_ to inline code.
"	27 Dec 1979, RAB - load pr2 before pr1 in the exponentiation operators,
"		add refresh_regs_if_next_is_jump and note_eligible_ind_var_use
"		in the relational operators, add note_eligible_ind_var_use
"		in the incrementing operators.  These changes will improve
"		object code generated by the register optimizer.
"	30 Nov 1979, RAB - Add support for certain operations in index registers
"		for the register optimizer.
"	03 Nov 1979, RAB - Add load_xreg, load_preg procs; use refresh_regs
"		macros for register optimizer.
"	03 Nov 1979, RAB - Remove lots of set_inds_valid macros having
"		changed return eaq_name to do the job.
"	31 Oct 1979, CRD - Add mpy to single_inst table.
"	17 Oct 1979, CRD - Insert lots of set_inds_valid macros, change
"		jump_true and jump_false to use ind_to_a.
"	09 Aug 1979, CRD - Fix bug 221 (dmod implemented incorrectly)
"	18 Jul 1979, CRD - Fix bug 226 re reference counts of complex temps.
"		convert_to_cmpx macro was erroneously swapping its operands
"		in the real and dp cases.
"	12 Jul 1979, PES - More forgiving encode/decode statement.  The string may
"		now be an array, simple variable, or array element of any type
"		but logical.
"	09 Jul 1979, CRD - Changes to fix bug 220, in which files do not
"		get closed if there is no STOP or CALL EXIT statement in the
"		main program.
"	02 May 1979, RAB - adds adwpn instructions to single_inst to support new
"		scheme for dealing with addresses >= 16K by using ptr regs.
"	18 Nov 1978, RAB - Centralizes rounding decisions in "round" and
"		"store" macros.  Precedes many floating compares
"		with rounds.
"	13 Sep 1978, PES - Changes to fix bug 183, in which fortran sometimes decides that
"		external subroutine names passed out as arguments in a call should be
"		treated as character strings.
"	05 Sep 1978, PES - Don't round in real & dp assignments if source was in storage.
"	27 Jul 1978, PES - Fix bug in handling of character function return args.
"	05 Apr 1978, DSL - Implement save_state,protect_indicators, fix bugs in
"		jump_true/jump_false.
"	30 Mar 1978, DSL - Use new macro, free_temp, to free arg list temp after
"		func ref.
"	22 Mar 1978, DSL - Bug fixes and min/max ref count changes.
"	15 Feb 1978, DSL - Changes for push_operand macro.
"	13 Feb 1978, DSL - Fix bug in atan2 bifs in which a "load_pr pr1"
"		made other operand references impossible.
"	02 Feb 1978, DSL - Fix jump_true/jump_false inversion. Add drop_counts
"		around (if unless)_ind. Make round_dp_to_real a function. Have assign_i
"		and assign_l perform stz optimization when appropriate.
"	05 Jan 1978, DSL - Implement double precision to complex conversion for
"		arithmetic infix oprs and for assignment.
"	04 Jan 1978, DSL - Implement rel ops for one char const opnd and one
"		arith opnd. Fix bug in func ref (unreported) in which no warning is
"		printed if return value is char and may need descriptors.
"	27 Dec 1977, DSL - fix bug in cv_bif_to_external (136); use new macros
"		pad_char_const_to_(word dw) in assign, fix bug in func_ref (130),
"		change macros to truncate on store when appropriate, introduce use
"		of new macro, dt_jump1.
"	15 Sep 1977, DSL - interim fix to abs bif until load_for_test macro
"		is available.
"	19 Jul 1977, DSL - fix bugs in open/close.
"	14 Jul 1977, DSL - 1) fix sf def for simple references.
"		2) change implementation of open/close. 3) fix sf ref for
"		logical sf. 4) prevent parameters from reaching
"		make_external_variable.
"	26 May 1977, GDC - allow statement functions to take character
"		arguments with character data-types.
"
	maclist	object
	include		fort_macros
	include		fort_equs

	include		stack_header
	include		stack_frame

	name		fort_opt_macros_

	segdef		operator_table
	segdef		single_inst
	segdef		interpreter_macros
	segdef		first_scan
	segdef		abort_list
	segdef		error_macro
	use		.text.

	include	fort_operator_table

	include	fort_single_inst

interpreter_macros:
	zero	check_subscript			1
	zero	subscript_mpy			2
	zero	move_eis				3


check_subscript:
	func	2

	if	arg1,=,op1,ret_sub

	load	q,arg2

	lda	1,dl
	cwl	arg1
	tze	2,ic
	tsx0	pr0|bound_ck_signal

ret_sub:
	return	arg1


subscript_mpy:
	proc	1


	if	arg1,=,1,ret_mpy

	if_check_multiply	subscript_mpy.1

	if	arg1,=,2,qls1

subscript_mpy.1:
	mpy	arg1

	unless_check_multiply	subscript_mpy.2
	tsx0		pr0|mpy_overflow_check

subscript_mpy.2:
	set_inds_valid	q

ret_mpy:	return

qls1:	emit_inst	1

	qls	1

	return


move_eis:
	proc	2

	emit_eis
	mlr	(),(pr),fill(040)
	desc9a	arg1
	desc9a	arg2

	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

first_scan:
	scan		continue,continue


abort_list:
	scan		continue,(continue,next)


error_macro:
	error

assign:	proc		1

	push_output
	swap		op2	" Put in expected order.

	dt_jump		(assign_ii,assign_ri,assign_di,assign_ci,assign_ir,assign_rr,assign_dr,assign_cr,assign_id,assign_rd,assign_dd,assign_cd,assign_ic,assign_rc,assign_dc,assign_cc,assign_e2,assign_e1,assign_t,assign_t)

assign_ii:
	unless_optype	constant,assign_ii.not_zero
	unless_zero	op1,assign_ii.not_zero
	stz		arg1
	flush_ref		arg1
	return

assign_ii.not_zero:
	if_global		arg1,assign_ii.check_induction_var
	if_global		arg2,assign_ii.check_induction_var

assign_ii.normal:
	load		q,arg2
	store		q,arg1
	return

assign_ii.check_induction_var:
	unless_induction_var	arg1,assign_ii.normal
	unless_induction_var	arg2,assign_ii.normal

	assign_index
	return

assign_ir:
	unless_optype	constant,assign_ir.not_const

assign_i.check_zero:
	convert_constant	int
	unless_zero	op1,assign_ii.not_zero
	stz		arg1
	flush_ref		arg1
	return

assign_ir.not_const:
	s_call		cv_load.ri_not_const
	store		q,arg1
	return

assign_ri:
	s_call		cv_load.ir
	store		eaq,arg1
	return

assign_id:
	if_optype		constant,assign_i.check_zero
	s_call		cv_load.di_not_const
	store		q,arg1
	return

assign_di:
	s_call		cv_load.id
	store		deaq,arg1
	return

assign_rr:
	load		eaq,arg2
	store		eaq,arg1
	return

assign_dd:
	load		deaq,arg2
	store		deaq,arg1
	return

assign_rd:
	load		deaq,arg2
	fstr		arg1
	return

assign_dr:
	load		eaq,arg2
	store		deaq,arg1,no_update
	return

assign_ic:
	if_optype		constant,assign_i.check_zero
	s_call		cv_load.ri_not_const
	store		q,arg1
	return

assign_ci:
	s_call		cv_load.ir
	jump		assign_cr.01

assign_rc:
	load		eaq,arg2
	store		eaq,arg1
	return

assign_cr:
	load		eaq,arg2
assign_cr.01:
	bump		arg1
	store		eaq,arg1,no_update
	fld		=0.,du
	fst		arg1+1
	return

assign_dc:
	load		eaq,arg2
	store		deaq,arg1,no_update
	return

assign_cd:
	load		deaq,arg2
	jump		assign_cr.01

assign_cc:
	load		aq,arg2
	store		aq,arg1
	return

assign_e2:
	if_dt		logical,assign_l
	if_dt		char,assign_h
	error		310,op1

assign_l:
	swap		arg1
	unless_dt		logical,logical.p
	swap		arg1
	unless_optype	constant,assign_l.not_zero
	unless_zero	arg2,assign_l.not_zero
	stz		arg1
	flush_ref		arg1
	return

assign_l.not_zero:
	load		a,arg2
	store		a,arg1
	return

assign_h:		" Modified 12/27/77 to allow char consts for all arith data types
	dt_jump1		arg1,(assign_ih,assign_rh,assign_dh,assign_ch,assign_lh,assign_hh,assign_th)

assign_ih:
assign_rh:
assign_lh:
assign_th:
	unless_optype	constant,char2.p
	pad_char_const_to_word	op1
	load		a,op1
	store		a,op2
	return

assign_dh:
assign_ch:
	unless_optype	constant,char2.p
	pad_char_const_to_dw	op1
	load		aq,op1
	store		aq,op2
	return


assign_hh:
	emit_eis
	mlr		(pr),(pr),fill(040)
	desc9a		arg2
	desc9a		arg1

	return

logical.p:
	print		338,arg1,op1
	return

char2.p:
	print		337,op1
	return

assign_e1:
	print		309,arg1
	return

assign_t:
	dt_jump1		arg1,(assign_t.normal,assign_t.normal,assign_e1,assign_e1,assign_t.to_logical,assign_t.normal)

assign_t.normal:
	unless_optype	constant,assign_t.not_zero
	unless_zero	op1,assign_t.not_zero
	stz		arg1
	flush_ref		arg1
	return

assign_t.not_zero:
	unless_one_word_dt	arg1,assign_e1		"trap assignments to invalid character vars
	load		tq,arg2
	store		tq,arg1
	return

assign_t.to_logical:
	unless_optype	constant,assign_t.logical.var
	unless_zero	op1,assign_t.logical.not_zero
	stz		arg1
	flush_ref		arg1
	return

assign_t.logical.var:
	load_for_test	tq,arg2
	emit		2
	tze		2,ic
	ldq		131072,du
	store		tq,arg1
	return

assign_t.logical.not_zero:
	use_q
	emit		1
	ldq		131072,du
	stq		arg1
	flush_ref		arg1
	return

add:	func		2

	dt_jump		(add_ii,add_ri,add_di,add_ci,add_ir,add_rr,add_dr,add_cr,add_id,add_rd,add_dd,add_cd,add_ic,add_rc,add_dc,add_cc,add_e2,add_e1,add_tl,add_tl)

add_ii:
	load_top		q
	adq		arg1
	return		q

add_ir:
	swap		arg1

add_ri:
	s_call		cv_load.ir
	fad		arg1
	return		eaq

add_id:
	swap		arg1

add_di:
	s_call		cv_load.id
	dfad		arg1
	return		deaq

add_rr:
	load_top		eaq
	fad		arg1
	return		eaq

add_dd:
	load_top		deaq
	dfad		arg1
	return		deaq

add_rd:
	swap		arg1

add_dr:
	if_eaq		eaq,arg2,add_dr.1

	load		deaq,arg1
	fad		arg2
	return		deaq

add_dr.1:
	dfad		arg1
	return		deaq

add_ic:
	swap		arg1

add_ci:
	bump		arg1
	s_call		cv_load.ir
	push_output
	bump		op1
	jump		add_cr.1

add_rc:
	swap		arg1

add_cr:
	bump		arg1
	push_output
	bump		op1

	if_eaq		eaq,arg2,add_cr.1
	if_eaq		eaq,arg1,add_cr.2

	load		ieaq,arg1
	store		ieaq,op1,no_update
	fld		arg1
	fad		arg2
	in_reg		eaq,op1
	return		op1

add_cr.1:
	fad		arg1
add_cr.11:
	store		eaq,op1,no_update
	fld		arg1+1
	in_reg		ieaq,op1
	return		op1

add_cr.2:
	fad		arg2
	jump		add_cr.11

add_dc:
	swap		arg1

add_cd:
	bump		arg1
	push_output
	bump		op1

	if_eaq		deaq,arg2,add_cd.1
	if_eaq		eaq,arg1,add_cd.2

	load		ieaq,arg1
	store		ieaq,op1,no_update
	fld		arg1
	dfad		arg2
	in_reg		eaq,op1
	return		op1

add_cd.1:
	fad		arg1
add_cd.11:
	store		eaq,op1,no_update
	fld		arg1+1
	in_reg		ieaq,op1
	return		op1

add_cd.2:
	dfad		arg2
	jump		add_cd.11

add_cc:
	bump		arg1
	bump		arg2
	push_output
	bump		op1
	if_eaq		eaq,arg2,add_cc.1
	if_eaq		ieaq,arg2,add_cc.2
	if_eaq		eaq,arg1,add_cc.3

	load		ieaq,arg1
	fad		arg2+1
add_cc.01:
	store		ieaq,op1,no_update
	fld		arg1
	fad		arg2
	in_reg		eaq,op1
	return		op1

add_cc.1:
	fad		arg1
add_cc.11:
	store		eaq,op1,no_update
	fld		arg1+1
	fad		arg2+1
	in_reg		ieaq,op1
	return		op1

add_cc.2:
	fad		arg1+1
	jump		add_cc.01

add_cc.3:
	fad		arg2
	jump		add_cc.11

add_e1:
	error		309,arg1

add_e2:
	error		310,arg2

add_tl:
	load_top		tq
	dt_jump1		arg1,(add_tl.1,add_e1,add_e1,add_e1,add_e1,add_e1,add_tl.1)

add_tl.1:
	adq		arg1
	return		tq

sub:	func		2

	dt_jump		(sub_ii,sub_ri,sub_di,sub_ci,sub_ir,sub_rr,sub_dr,sub_cr,sub_id,sub_rd,sub_dd,sub_cd,sub_ic,sub_rc,sub_dc,sub_cc,sub_e2,sub_e1,sub_tl,sub_tl)

sub_ii:
	load		q,arg1
	sbq		arg2
	return		q

sub_ir:
	swap		arg1

	s_call		cv_load.ir
	fsb		arg1
	return		eaq

sub_ri:
	if_eaq		q,arg2,sub_ri.1

	if_optype		constant,conv_sub_ri

	lcq		arg2
	s_call		cv_q_to_real
	fad		arg1
	return		eaq

conv_sub_ri:
	convert_constant	real
	load		eaq,arg1
	fsb		arg2
	return		eaq

sub_ri.1:
	s_call		cv_q_to_real
	emit_inst		1
	fneg
	fad		arg1
	return		eaq

sub_id:
	swap		arg1

	s_call		cv_load.id
	dfsb		arg1
	return		deaq

sub_di:
	if_eaq		q,arg2,sub_di.1

	if_optype		constant,conv_sub_di

	lcq		arg2
	s_call		cv_q_to_dp
	dfad		arg1
	return		deaq

conv_sub_di:
	convert_constant	dp
	load		deaq,arg1
	dfsb		arg2
	return		deaq

sub_di.1:
	s_call		cv_q_to_dp
	emit_inst		1
	fneg
	dfad		arg1
	return		deaq

sub_rr:
	if_eaq		eaq,arg2,sub_rr.1

	load		eaq,arg1
	fsb		arg2
	return		eaq

sub_rr.1:
	emit_inst		1
	fneg
	fad		arg1
	return		eaq

sub_dd:
	if_eaq		deaq,arg2,sub_dd.1

	load		deaq,arg1
	dfsb		arg2
	return		deaq

sub_dd.1:
	emit_inst		1
	fneg
	dfad		arg1
	return		deaq

sub_rd:
	if_eaq		deaq,arg2,sub_rd.1

	load		eaq,arg1
	dfsb		arg2
	return		deaq

sub_rd.1:
	emit_inst		1
	fneg
	fad		arg1
	return		deaq

sub_dr:
	if_eaq		eaq,arg2,sub_dr.1

	load		deaq,arg1
	fsb		arg2
	return		deaq

sub_dr.1:
	emit_inst		1
	fneg
	dfad		arg1
	return		deaq

sub_ic:
	bump		arg2
	push_output
	bump		op1

	swap		arg1
	s_call		cv_load.ir
	swap		arg1
	jump		sub_rc.1

sub_ci:
	bump		arg1
	push_output
	bump		op1

	swap		arg2

	if_optype		constant,conv_sub_ci

	swap		arg2
	lcq		arg2
	s_call		cv_q_to_real
	jump		sub_cr.10

conv_sub_ci:
	convert_constant	real

	swap		arg2
	load		eaq,arg2
	jump		sub_cr.1

sub_rc:
	bump		arg2
	push_output
	bump		op1

	if_eaq		eaq,arg1,sub_rc.1
	if_eaq		eaq,arg2,sub_rc.2

	load		ieaq,arg2
	emit_inst		1
	fneg
	store		ieaq,op1,no_update
	fld		arg1
	fsb		arg2
	in_reg		eaq,op1
	return		op1

sub_rc.1:
	fsb		arg2
sub_rc.11:
	store		eaq,op1,no_update
	fld		arg2+1
	emit_inst		1
	fneg
	in_reg		ieaq,op1
	return		op1

sub_rc.2:
	emit_inst		1
	fneg
	fad		arg1
	jump		sub_rc.11

sub_cr:
	bump		arg1
	push_output
	bump		op1

	if_eaq		eaq,arg2,sub_cr.1
	if_eaq		eaq,arg1,sub_cr.2

	load		ieaq,arg1
	store		ieaq,op1,no_update
	fld		arg1
	fsb		arg2
	in_reg		eaq,op1
	return		op1

sub_cr.1:
	emit_inst		1
	fneg
sub_cr.10:
	fad		arg1
sub_cr.11:
	store		eaq,op1,no_update
	fld		arg1+1
	in_reg		ieaq,op1
	return		op1

sub_cr.2:
	fsb		arg2
	jump		sub_cr.11

sub_dc:
	bump		arg2
	push_output
	bump		op1

	if_eaq		deaq,arg1,sub_dc.1
	if_eaq		eaq,arg2,sub_dc.2

	load		ieaq,arg2
	emit_inst		1
	fneg
	store		ieaq,op1,no_update
	dfld		arg1
	fsb		arg2
	in_reg		eaq,op1
	return		op1

sub_dc.1:
	fsb		arg2
sub_dc.11:
	store		eaq,op1,no_update
	fld		arg2+1
	emit_inst		1
	fneg
	in_reg		ieaq,op1
	return		op1

sub_dc.2:
	emit_inst		1
	fneg
	dfad		arg1
	jump		sub_dc.11

sub_cd:
	bump		arg1
	push_output
	bump		op1

	if_eaq		deaq,arg2,sub_cd.1
	if_eaq		eaq,arg1,sub_cd.2

	load		ieaq,arg1
	store		ieaq,op1,no_update
	fld		arg1
	dfsb		arg2
	in_reg		eaq,op1
	return		op1

sub_cd.1:
	emit_inst		1
	fneg
sub_cd.10:
	fad		arg1
sub_cd.11:
	store		eaq,op1,no_update
	fld		arg1+1
	in_reg		ieaq,op1
	return		op1

sub_cd.2:
	dfsb		arg2
	jump		sub_cd.11

sub_cc:
	bump		arg1
	bump		arg2
	push_output
	bump		op1

	if_eaq		eaq,arg2,sub_cc.1
	if_eaq		ieaq,arg2,sub_cc.2
	if_eaq		eaq,arg1,sub_cc.3

	load		ieaq,arg1
	fsb		arg2+1
sub_cc.01:
	store		ieaq,op1,no_update
	fld		arg1
	fsb		arg2
	in_reg		eaq,op1
	return		op1

sub_cc.1:
	emit_inst		1
	fneg
	fad		arg1
sub_cc.11:
	store		eaq,op1,no_update
	fld		arg1+1
	fsb		arg2+1
	in_reg		ieaq,op1
	return		op1

sub_cc.2:
	emit_inst		1
	fneg
	fad		arg1+1
	jump		sub_cc.01

sub_cc.3:
	fsb		arg2
	jump		sub_cc.11

sub_e1:
	error		309,arg1

sub_e2:
	error		310,arg2

sub_tl:
	unless_dt		(int,typeless),sub_e2
	dt_jump1		arg1,(sub_tl.1,sub_e1,sub_e1,sub_e1,sub_e1,sub_e1,sub_tl.1)

sub_tl.1:
	load		tq,arg1
	sbq		arg2
	return		tq

mult:	func		2

	dt_jump		(mult_ii,mult_ri,mult_di,mult_ci,mult_ir,mult_rr,mult_dr,mult_cr,mult_id,mult_rd,mult_dd,mult_cd,mult_ic,mult_rc,mult_dc,mult_cc,mult_e2,mult_e1,mult_tl,mult_tl)

mult_ii:
	if_check_multiply	mult_ii.1
	power_of_two	arg1,mult_ii.one_is
	power_of_two	arg2,mult_ii.two_is

mult_ii.1:
	load_top		q
	mpy		arg1

	unless_check_multiply	mult_ii.2
	tsx0		pr0|mpy_overflow_check

mult_ii.2:
	return		q

mult_ii.one_is:
	load		q,arg2
	qls		arg1
	return		q

mult_ii.two_is:
	load		q,arg1
	qls		arg2
	return		q

mult_ir:
	swap		arg1

mult_ri:
	s_call		cv_load.ir
	fmp		arg1
	return		eaq

mult_id:
	swap		arg1

mult_di:
	s_call		cv_load.id
	dfmp		arg1
	return		deaq

mult_rr:
	float_power_of_fpbase	arg1,mult_rr.one_is
	float_power_of_fpbase	arg2,mult_rr.two_is
	load_top		eaq
	fmp		arg1
	return		eaq

mult_rr.one_is:
	swap		arg1

mult_rr.two_is:
	load_for_test	eaq,arg1
	use_eaq
	tze		2,ic
	ade		arg2
	jump		mm_ret_eaq

mult_dd:
	float_power_of_fpbase	arg1,mult_dd.one_is
	float_power_of_fpbase	arg2,mult_dd.two_is
	load_top		deaq
	dfmp		arg1
	return		deaq

mult_dd.one_is:
	swap		arg1

mult_dd.two_is:
	load_for_test	deaq,arg1

use_ade.dd:
	use_eaq
	tze		2,ic
	ade		arg2
	jump		mm_ret_deaq

mult_rd:
	swap		arg1

mult_dr:
	float_power_of_fpbase	arg1,mult_dr.one_is
	float_power_of_fpbase	arg2,mult_dd.two_is
	if_eaq		eaq,arg2,mult_dr.1

	load		deaq,arg1
	fmp		arg2
	return		deaq

mult_dr.1:
	dfmp		arg1
	return		deaq

mult_dr.one_is:
	load_for_test	eaq,arg2
	swap		arg1
	jump		use_ade.dd

mult_ic:
	swap		arg1

mult_ci:
	bump		arg1
	push_output
	bump		op1

	swap		arg2

	if_optype		constant,conv_mult_ci

	swap		arg2
	push_temp		real
	bump		op1	" temp becomes arg2

	load		q,arg2
	use_eaq
	tsx0		pr0|integer_to_real

	swap		arg2
	store		eaq,arg2,no_update
	pop		op1
	jump		mult_cr.1

conv_mult_ci:
	convert_constant	real

	swap		arg2
	load		eaq,arg2
	jump		mult_cr.1

mult_rc:
	swap		arg1

mult_cr:
	bump		arg1
	bump		arg2
	push_output
	bump		op1

	if_eaq		eaq,arg2,mult_cr.1
	if_eaq		eaq,arg1,mult_cr.2

	load		ieaq,arg1
	fmp		arg2
	store		ieaq,op1,no_update
	fld		arg1
	fmp		arg2
	in_reg		eaq,op1
	return		op1

mult_cr.1:
	fmp		arg1
mult_cr.11:
	store		eaq,op1,no_update
	fld		arg2
	fmp		arg1+1
	in_reg		ieaq,op1
	return		op1

mult_cr.2:
	fmp		arg2
	jump		mult_cr.11

mult_dc:
	swap		arg1

mult_cd:
	bump		arg1
	bump		arg2
	push_output
	bump		op1

	if_eaq		deaq,arg2,mult_cd.1
	if_eaq		eaq,arg1,mult_cd.2

	load		ieaq,arg1
	dfmp		arg2
	store		ieaq,op1,no_update
	fld		arg1
	dfmp		arg2
	in_reg		eaq,op1
	return		op1

mult_cd.1:
	fmp		arg1
mult_cd.11:
	store		eaq,op1,no_update
	dfld		arg2
	fmp		arg1+1
	in_reg		ieaq,op1
	return		op1

mult_cd.2:
	dfmp		arg2
	jump		mult_cd.11

mult_cc:
	load		aq,arg1
	bump		arg2
	load_pr		pr2,arg2
	use_eaq
	tsx0		pr0|complex_multiply
	drop		arg2
	ldaq		pr6|complex
	free_regs
	return		aq

mult_e1:
	error		309,arg1

mult_e2:
	error		310,arg2

mult_tl:
	unless_dt		(int,typeless),mult_e2
	dt_jump1		arg1,(mult_tl.1,mult_e1,mult_e1,mult_e1,mult_e1,mult_e1,mult_tl.1)

mult_tl.1:
	if_check_multiply	mult_tl.2
	power_of_two	arg1,mult_tl.one_is
	power_of_two	arg2,mult_tl.two_is

mult_tl.2:
	load_top		tq
	mpy		arg1

	unless_check_multiply	mult_tl.3
	tsx0		pr0|mpy_overflow_check

mult_tl.3:
	return		tq

mult_tl.one_is:
	load		tq,arg2
	qls		arg1
	return		tq

mult_tl.two_is:
	load		tq,arg1
	qls		arg2
	return		tq

div:	func		2

	dt_jump		(div_ii,div_ri,div_di,div_ci,div_ir,div_rr,div_dr,div_cr,div_id,div_rd,div_dd,div_cd,div_ic,div_rc,div_dc,div_cc,div_e2,div_e1,div_tl,div_tl)

div_ii:
	load		q,arg1
	div		arg2
	return		q

div_ir:
	swap		arg1

	s_call		cv_load.ir
	fdv		arg1
	return		eaq

div_ri:
	s_call		cv_load.ir
	fdi		arg1
	return		eaq

div_id:
	swap		arg1

	s_call		cv_load.id
	dfdv		arg1
	return		deaq

div_di:
	s_call		cv_load.id
	dfdi		arg1
	return		deaq

div_rr:
	float_power_of_fpbase	arg2,div_r.power_of_two,for_divide
	if_eaq		eaq,arg2,div_rr.1

	load		eaq,arg1
	fdv		arg2
	return		eaq

div_rr.1:
	fdi		arg1
	return		eaq

div_r.power_of_two:
	load_for_test	eaq,arg1
	use_eaq
	tze		2,ic
	ade		arg2
	jump		mm_ret_eaq

div_dd:
	float_power_of_fpbase	arg2,div_d.power_of_two,for_divide
	if_eaq		deaq,arg2,div_dd.1

	load		deaq,arg1
	dfdv		arg2
	return		deaq

div_dd.1:
	dfdi		arg1
	return		deaq


div_d.power_of_two:
	load_for_test	deaq,arg1
	use_eaq
	tze		2,ic
	ade		arg2
	jump		mm_ret_deaq

div_rd:
	float_power_of_fpbase	arg2,div_rd.power_of_two,for_divide
	load		eaq,arg1
	dfdv		arg2
	return		deaq

div_rd.power_of_two:
	load_for_test	eaq,arg1
	use_eaq
	tze		2,ic
	ade		arg2
	jump		mm_ret_deaq

div_dr:
	float_power_of_fpbase	arg2,div_d.power_of_two,for_divide
	load		eaq,arg2
	dfdi		arg1
	return		deaq

div_ic:
	swap		arg1

	if_optype		constant,conv_div_ic

	s_call		cv_load.ir

	swap		arg1
	fstr		sp|double_temp
	lda		sp|double_temp
	jump		div_rc.01

conv_div_ic:
	convert_constant	real
	swap		arg1
	jump		div_rc

div_ci:
	bump		arg1
	push_output
	bump		op1

	swap		arg2

	if_optype		constant,conv_div_ci

	swap		arg2
	push_temp		real
	bump		op1	" temp becomes arg2

	load		q,arg2
	use_eaq
	tsx0		pr0|integer_to_real

	swap		arg2
	store		eaq,arg2,no_update
	pop		op1
	jump		div_cr.1

conv_div_ci:
	convert_constant	real

	swap		arg2
	load		eaq,arg2
	jump		div_cr.1

div_rc:
	load		a,arg1
div_rc.01:
	ldq		=0.,du
	bump		arg2
	load_pr		pr2,arg2
	use_eaq
	tsx0		pr0|complex_divide
	drop		arg2
	ldaq		pr6|complex
	free_regs
	return		aq

div_cr:
	bump		arg1
	bump		arg2
	push_output
	bump		op1

	if_eaq		eaq,arg2,div_cr.1
	if_eaq		eaq,arg1,div_cr.2

	load		ieaq,arg1
	fdv		arg2
div_cr.01:
	store		ieaq,op1,no_update
	fld		arg1
	fdv		arg2
	in_reg		eaq,op1
	return		op1

div_cr.1:
	fdi		arg1+1
	jump		div_cr.01

div_cr.2:
	fdv		arg2
	store		eaq,op1,no_update
	fld		arg1+1
	fdv		arg2
	in_reg		ieaq,op1
	return		op1

div_dc:
	swap		arg1
	call		round_dp_to_real
	swap		arg1
	jump		div_rc

div_cd:
	bump		arg1
	bump		arg2
	push_output
	bump		op1

	if_eaq		deaq,arg2,div_cd.1
	if_eaq		eaq,arg1,div_cd.2

	load		ieaq,arg1
	dfdv		arg2
div_cd.01:
	store		ieaq,op1,no_update
	fld		arg1
	dfdv		arg2
	in_reg		eaq,op1
	return		op1

div_cd.1:
	fdi		arg1+1
	jump		div_cd.01

div_cd.2:
	dfdv		arg2
	store		eaq,op1,no_update
	fld		arg1+1
	dfdv		arg2
	in_reg		ieaq,op1
	return		op1

div_cc:
	load		aq,arg1
	bump		arg2
	load_pr		pr2,arg2
	use_eaq
	tsx0		pr0|complex_divide
	drop		arg2
	ldaq		pr6|complex
	free_regs
	return		aq

div_e1:
	error		309,arg1

div_e2:
	error		310,arg2

div_tl:
	unless_dt		(int,typeless),div_e2
	dt_jump1		arg1,(div_tl.1,div_e1,div_e1,div_e1,div_e1,div_e1,div_tl.1)
	load		tq,arg1

div_tl.1:
	use_eaq
	div		arg2
	return		tq

cv_load.ir:
	if_optype		constant,conv_ir

	s_call		cv_int_to_float

	set_inds_valid	eaq
	s_return

conv_ir:
	convert_constant	real
	load		eaq,op1
	s_return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

cv_load.ri:
	if_optype		constant,conv_ri

cv_load.ri_not_const:
	load		eaq,op1
	round		eaq
	s_call		cv_real_to_int
	set_inds_valid	q
	s_return

conv_ri:
	convert_constant	int
	load		q,op1
	s_return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

cv_load.id:
	if_optype		constant,conv_id

	s_call		cv_int_to_float

	set_inds_valid	deaq
	s_return

conv_id:
	convert_constant	dp
	load		deaq,op1
	s_return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

cv_load.di:
	if_optype		constant,conv_di

cv_load.di_not_const:
	load		deaq,op1
	round		deaq
	s_call		cv_dp_to_int
	set_inds_valid	q
	s_return

conv_di:
	convert_constant	int
	load		q,op1
	s_return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

cv_int_to_float:
	if_eaq		q,op1,cv_int_to_float.q_loaded
	if_hfp		cv_int_to_hfp

cv_int_to_bfp:
	lda		op1
	emit_inst		3
	lrs		36
	lde		=71b25,du
	fad		=0.,du

	s_return

cv_int_to_hfp:
	lda		op1
	emit_inst		4
	lrs		36
	lde		=18b25,du
	fad		=0.,du
	fmp		P0.5H,du

	s_return

cv_q_to_real:
cv_q_to_dp:
cv_int_to_float.q_loaded:
	if_hfp		cv_int_to_hfp.q_loaded

cv_int_to_bfp.q_loaded:
	emit_inst		3
	lls		36
	lde		=35b25,du
	fad		=0.,du

	s_return

cv_int_to_hfp.q_loaded:
	emit_inst		3
	lls		36
	lde		=9b25,du
	fmp		P0.5H,du

	s_return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

cv_real_to_int:
	if_ind		eaq,cv_float_to_int
	fcmp		=0.,du
	jump		cv_float_to_int

cv_dp_to_int:
	if_ind		deaq,cv_float_to_int
	fcmp		=0.,du

cv_float_to_int:
	if_hfp		cv_hfp_to_int

cv_bfp_to_int:
	use_eaq
	tpl		2,ic
	dufa		pr0|almost_one
	ufa		=71b25,du

	s_return

cv_hfp_to_int:
	use_eaq
	tpl		2,ic
	dufa		pr0|almost_one
	ufm		P2.0H,du
	ufa		=18b25,du

	s_return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

"	This function expects the top of the stack to be a dp operand. The top of the stack
"	is replaced by a real constant derived from the dp one. If the dp operand is not a
"	constant, a real temp is created. Ref count should be such that use of eaq causes the
"	temp to be stored.

round_dp_to_real:
	func		1

	if_optype		constant,round_dp_const
	push_temp		real
	load		deaq,op2
	return		eaq

round_dp_const:
	convert_constant	real
	return		op1

from_logical:
	error		309,arg1

from_char:
	error		310,arg1

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

convert_to_int:
	func		1

	dt_jump1		arg1,(to_int.int,to_int.real,to_int.dp,to_int.cmpx,from_logical,from_char,to_int.tl)

to_int.tl:
to_int.int:
	load		q,arg1
	return		q

to_int.real:
to_int.cmpx:
	s_call		cv_load.ri
	return		q

to_int.dp:
	s_call		cv_load.di
	return		q

convert_to_real:
	func		1

	dt_jump1		arg1,(to_real.int,to_real.real,to_real.dp,to_real.cmpx,from_logical,from_char)

to_real.int:
	s_call		cv_load.ir
	return		eaq

to_real.real:
	load		eaq,arg1
	return		eaq

to_real.dp:
	load		deaq,arg1
	return		eaq

to_real.cmpx:
	load		eaq,arg1
	return		eaq

convert_to_dp:
	func		1

	dt_jump1		arg1,(to_dp.int,to_dp.real,to_dp.dp,to_dp.cmpx,from_logical,from_char)

to_dp.int:
	s_call		cv_load.id
	return		deaq

to_dp.real:
	load		eaq,arg1
	return		deaq

to_dp.dp:
	load		deaq,arg1
	return		deaq

to_dp.cmpx:
	load		eaq,arg1
	return		deaq

convert_to_cmpx:
	func		1

	dt_jump1		arg1,(to_cmpx.int,to_cmpx.real,to_cmpx.dp,to_cmpx.cmpx,from_logical,from_char)

to_cmpx.int:
	push_output
	bump		op1
	fld		=0.0,du
	fst		op1+1
	swap		op2
	s_call		cv_load.ir
	return		eaq

to_cmpx.real:
	push_output
	bump		op1
	fld		=0.0,du
	fst		op1+1
	load		eaq,arg1
	return		eaq

to_cmpx.dp:
	push_output
	bump		op1
	fld		=0.0,du
	fst		op1+1
	load		deaq,arg1
	return		eaq

to_cmpx.cmpx:
	load		aq,arg1
	return		aq

exponentiation:
	func		2

	dt_jump		(exponentiation_ii,exponentiation_ri,exponentiation_di,exponentiation_ci,exponentiation_ir,exponentiation_rr,exponentiation_dr,exponentiation_cr,exponentiation_id,exponentiation_rd,exponentiation_dd,exponentiation_cd,exponentiation_ic,exponentiation_rc,exponentiation_dc,exponentiation_cc,exponentiation_e2,exponentiation_e1,exponentiation_e2,exponentiation_e1)

exponentiation_ii:
	push_temp		32

	load		q,arg1
	bump		arg2
	load_pr		pr2,op1
	load_pr		pr1,arg2
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr3,pr4,pr5,pr7)
	tsp3		pr0|int_p_int
	drop		arg2
	free_regs
	return		q

exponentiation_ir:
	push_temp		32

	swap		arg1

	s_call		cv_load.ir

	swap		arg1

	jump		exponentiation_rr.02

exponentiation_ri:
	push_temp		32

	load		eaq,arg1
	bump		arg2
	load_pr		pr2,op1
	load_pr		pr1,arg2
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr3,pr4,pr5,pr7)
	tsp3		pr0|real_p_int
	drop		arg2
	free_regs
	return		eaq

exponentiation_id:
	push_temp		32

	swap		arg1

	s_call		cv_load.id

	swap		arg1

	jump		exponentiation_dd.02

exponentiation_di:
	push_temp		32

	load		deaq,arg1
	bump		arg2
	load_pr		pr2,op1
	load_pr		pr1,arg2
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr3,pr4,pr5,pr7)
	tsp3		pr0|dbl_p_int
	drop		arg2
	free_regs
	return		deaq

exponentiation_rr:
	push_temp		32

	load		eaq,arg1
exponentiation_rr.02:
	bump		arg2
	load_pr		pr2,op1
	load_pr		pr1,arg2
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr3,pr4,pr5,pr7)
	tsp3		pr0|real_p_real
	drop		arg2
	free_regs
	return		eaq

exponentiation_dd:
	push_temp		32

	load		deaq,arg1
exponentiation_dd.02:
	bump		arg2
	load_pr		pr2,op1
	load_pr		pr1,arg2
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr3,pr4,pr5,pr7)
	tsp3		pr0|dbl_p_dbl
	drop		arg2
	free_regs
	return		deaq

exponentiation_rd:
	push_temp		32

	load		eaq,arg1
	jump		exponentiation_dd.02

exponentiation_dr:
	push_temp		32

	load		deaq,arg1
	bump		arg2
	load_pr		pr2,op1
	load_pr		pr1,arg2
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr3,pr4,pr5,pr7)
	tsp3		pr0|dbl_p_real
	drop		arg2
	free_regs
	return		deaq

exponentiation_ic:
	push_temp		32
	load_pr		pr2,op1
	swap		arg1

	if_optype		constant,conv_exponentiation_ic

	swap		arg1
	push_output
	bump		op1,3		" temp becomes arg1 and is used 3 times
	load		q,arg1
	use_eaq
	tsx0		pr0|integer_to_real
	store		eaq,op1,no_update
	fld		=0.,du
	fst		op1+1
	ldaq		op1
	jump		exponentiation_cc.01

conv_exponentiation_ic:
	convert_constant	cmpx

	swap		arg1
	load		aq,arg1
	jump		exponentiation_cc.01

exponentiation_ci:
	push_temp		32
	load_pr		pr2,op1
	push_output
	bump		op1,2		" temp is used at least twice

	swap		arg2

	if_optype		constant,conv_exponentiation_ci

	swap		arg2
	bump		op1,2		" conversion requires 2 more refs
	load		q,arg2
	use_eaq
	tsx0		pr0|integer_to_real
	store		eaq,op1,no_update
	fld		=0.,du
	fst		op1+1
	jump		exponentiation_cr.01

conv_exponentiation_ci:
	convert_constant	cmpx

	swap		arg2
	load		aq,arg2
	staq		op1
	jump		exponentiation_cr.01

exponentiation_dc:
	swap		arg1
	call		round_dp_to_real
	swap		arg1

exponentiation_rc:
	push_temp		32
	load_pr		pr2,op1

	load		a,arg1
	ldq		=0.,du
	jump		exponentiation_cc.01

exponentiation_cd:
	call		round_dp_to_real

exponentiation_cr:
	push_temp		32
	load_pr		pr2,op1
	push_output
	bump		op1,2		" temp is used twice

	load		a,arg2
	ldq		=0.,du
	staq		op1
exponentiation_cr.01:
	ldaq		arg1
	bump		op1
	load_pr		pr1,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr3,pr4,pr5,pr7)
	tsp3		pr0|cmpx_p_cmpx
	drop		op1
	ldaq		pr6|temp_pt
	free_regs
	return		aq

exponentiation_cc:
	push_temp		32
	load_pr		pr2,op1
	load		aq,arg1
exponentiation_cc.01:
	bump		arg2
	load_pr		pr1,arg2
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr3,pr4,pr5,pr7)
	tsp3		pr0|cmpx_p_cmpx
	drop		arg2
	ldaq		pr6|temp_pt
	free_regs
	return		aq

exponentiation_e1:
	error		309,arg1

exponentiation_e2:
	error		310,arg2

negate:	func		1

	dt_jump1		op1,(negate_i,negate_r,negate_d,negate_c,negate_l,negate_h,negate_t)

negate_l:
negate_h:
	error		315,op1

negate_i:
negate_t:
	lcq		op1
	return		q

negate_r:
	load		eaq,op1
	emit_inst		1
	fneg
	return		eaq

negate_d:
	load		deaq,op1
	emit_inst		1
	fneg
	return		deaq

negate_c:
	push_output
	bump		op1
	bump		op2

	if_eaq		eaq,op2,negate_c.1

	load		ieaq,op2
	emit_inst		1
	fneg
	store		ieaq,op1,no_update
	load		eaq,op2
	emit_inst		1
	fneg
	in_reg		eaq,op1
	return		op1

negate_c.1:
	emit_inst		1
	fneg
	store		eaq,op1,no_update
	load		ieaq,op2
	emit_inst		1
	fneg
	in_reg		ieaq,op1
	return		op1

builtin:	func		2			last assigned number = 93
"
"	The builtin code depends on 3 indexed operators. Two uses are here. The other
"	appears in the cv_bif_to_external code. Remember to change ALL three.
"

	push_bif_index	arg1
	push_count_indexed	arg3,(1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,2,2,2,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-1,1,1,1,1,1,1,1,1,1,2,1,2,2,2,2,1,1,1,1,1,1,1,1,1,1,2,-1,1,1,3,2,2,2,2,-1,-1)

	if		arg4,<,0,builtin_var
	if		arg2,=,op1,builtin2

wrong_number.p:
	error		319,arg1

builtin_var:
builtin2:
	push_operand	builtin3
	jump		builtin2

builtin3:
	jump_indexed	arg3,(abs,iabs,dabs,cabs,alog,dlog,clog,alog10,dlog10,atan,datan,atan2,datan2,cos,dcos,ccos,dim,idim,ddim,exp,dexp,cexp,max,amax0,amax1,max0,max1,dmax1,min,amin0,amin1,min0,min1,dmin1,mod,amod,dmod,sign,isign,dsign,sin,dsin,csin,sqrt,dsqrt,csqrt,tanh,int_builtin,aint,idint,float,ifix,sngl,real_builtin,aimag,dble,cmplx,conjg,tan,dtan,asin,dasin,acos,dacos,char_builtin,ichar,index,len,lge,lgt,lle,llt,cosh,sinh,dcosh,dsinh,dtanh,dint,anint,dnint,nint,idnint,dprod,and.tl,bool.tl,compl.tl,fld.tl,ilr.tl,ils.tl,irl.tl,irs.tl,or.tl,xor.tl)

mm_ret_q:
	push_output
	in_reg		q,op1
	use_ind
	return		op1

mm_ret_eaq:
	push_output
	in_reg		eaq,op1
	use_ind
	return		op1

mm_ret_deaq:
	push_output
	in_reg		deaq,op1
	use_ind
	return		op1

mm_ret_tq:
	push_output
	in_reg		tq,op1
	return		op1

wrong_type.p:
	error		320,arg1,op1

abs:						" builtin 01
	dt_jump1		op1,(iabs.1,abs.1,dabs.1,cabs.1,wrong_type.p,wrong_type.p,wrong_type.p)

iabs:						" builtin 02
	unless_dt		int,iabs.p
iabs.1:
	load_for_test	q,arg5
	use_eaq		protect_indicators		" save all temps before transfer
	tpl		3,ic
	erq		pr0|all_ones
	adq		1,dl
	return		q

abs.1:
	load_for_test	eaq,arg5
	use_eaq		protect_indicators		" save all temps before transfer
	tpl		2,ic
	emit_inst		1
	fneg
	return		eaq

dabs:						" builtin 03
	unless_dt		dp,dabs.p
dabs.1:
	load_for_test	deaq,arg5
	use_eaq		protect_indicators		" save all temps before transfer
	tpl		2,ic
	emit_inst		1
	fneg
	return		deaq

cabs:						" builtin 04
	unless_dt		cmpx,cabs.p
cabs.1:
	load		aq,arg5
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|cabs_
	fld		pr6|temp_pt
	free_regs
	return		eaq

iabs.p:
	jump		bu_dt5.p

dabs.p:
	jump		bu_dt5.p

cabs.p:
	jump		bu_dt5.p

alog:						" builtin 05
	dt_jump1		op1,(alog_i,alog.1,dlog.1,clog.1,wrong_type.p,wrong_type.p,wrong_type.p)

alog.1:
	load		eaq,arg5
	jump		alog.2

alog_i:
	s_call		cv_load.ir

alog.2:
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|log_
	free_regs
	return		eaq

dlog:						" builtin 06
	unless_dt		dp,bu_dt5.p
dlog.1:
	load		deaq,arg5
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|dlog_
	free_regs
	return		deaq

clog:						" builtin 07
	unless_dt		cmpx,bu_dt5.p
clog.1:
	load		aq,arg5
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|clog_
	ldaq		pr6|temp_pt
	free_regs
	return		aq

alog10:						" builtin 08
	dt_jump1		op1,(alog10_i,alog10.1,dlog10.1,bu_dt5.p,wrong_type.p,wrong_type.p,wrong_type.p)

alog10.1:
	load		eaq,arg5
	jump		alog10.2

alog10_i:
	s_call		cv_load.ir

alog10.2:
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|alog10_
	free_regs
	return		eaq

dlog10:						" builtin 09
	unless_dt		dp,bu_dt5.p
dlog10.1:
	load		deaq,arg5
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|dlog10_
	free_regs
	return		deaq

atan:						" builtin 10
	dt_jump1		op1,(atan_i,atan.1,datan.1,bu_dt5.p,wrong_type.p,wrong_type.p,wrong_type.p)

atan.1:
	load		eaq,arg5
	jump		atan.2

atan_i:
	s_call		cv_load.ir

atan.2:
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|atan_
	free_regs
	return		eaq

datan:						" builtin 11
	unless_dt		dp,bu_dt5.p
datan.1:
	load		deaq,arg5
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|datan_
	free_regs
	return		deaq

atan2:						" builtin 12
	dt_jump		(atan2_ii,atan2_ri,atan2_di,atan2_ci,atan2_ir,atan2_rr,atan2_dr,atan2_cr,atan2_id,atan2_rd,atan2_dd,atan2_cd,atan2_ic,atan2_rc,atan2_dc,atan2_cc,atan2_e2,atan2_e1,atan2_e2,atan2_e1)

atan2_ii:
	s_call		builtin_2args_ii
	jump		atan2.1

atan2_ir:
	s_call		builtin_2args_ir
	jump		atan2.1

atan2_ri:
	s_call		builtin_2args_ri
	jump		atan2.1

atan2_id:
	s_call		builtin_2args_id
	jump		datan2.1

atan2_di:
	s_call		builtin_2args_di
	jump		datan2.1

atan2_rr:
	jump		atan2.1

atan2_dd:
	jump		datan2.1

atan2_rd:
	load		eaq,arg5
	push_temp		32
	load_pr		pr2,op1
	bump		arg6
	load_pr		pr1,arg6
	jump		datan2.2

atan2_dr:
	push_temp		dp
	load		eaq,arg6
	store		deaq,op1,no_update
	swap		arg6
	pop		op1
	jump		datan2.1

atan2_ic:
	jump		bu_dt6.p

atan2_ci:
	jump		bu_dt5.p

atan2_rc:
	jump		bu_dt6.p

atan2_cr:
	jump		bu_dt5.p

atan2_dc:
	jump		bu_dt6.p

atan2_cd:
	jump		bu_dt5.p

atan2_cc:
	jump		bu_dt5.p

atan2_e1:
	jump		bu_dt5.p

atan2_e2:
	jump		bu_dt6.p

atan2.1:
	load		eaq,arg5
	push_temp		32
	load_pr		pr2,op1
	bump		arg6
	load_pr		pr1,arg6
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr3,pr4,pr5,pr7)
	tsp3		pr0|atan2_
	drop		arg6
	free_regs
	return		eaq

datan2:						" builtin 13
	swap		arg5
	unless_dt		dp,atan2.p
	swap		arg5
	unless_dt		dp,atan2_ee

datan2.1:
	load		deaq,arg5
	push_temp		32
	load_pr		pr2,op1
	bump		arg6
	load_pr		pr1,arg6
datan2.2:
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr3,pr4,pr5,pr7)
	tsp3		pr0|datan2_
	drop		arg6
	free_regs
	return		deaq

atan2.p:
atan2_ee:
	jump		bu_dt6.p

cos:						" builtin 14
	dt_jump1		op1,(cos_i,cos.1,dcos.1,ccos.1,wrong_type.p,wrong_type.p,wrong_type.p)

cos.1:
	load		eaq,arg5
	jump		cos.2

cos_i:
	s_call		cv_load.ir

cos.2:
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|cos_
	free_regs
	return		eaq

dcos:						" builtin 15
	unless_dt		dp,dcos.p
dcos.1:
	load		deaq,arg5
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|dcos_
	free_regs
	return		deaq

ccos:						" builtin 16
	unless_dt		cmpx,ccos.p
ccos.1:
	load		aq,arg5
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|ccos_
	ldaq		pr6|temp_pt
	free_regs
	return		aq

dcos.p:
	jump		bu_dt5.p

ccos.p:
	jump		bu_dt5.p

dim:						" builtin 17
	dt_jump		(dim_ii,dim_ri,dim_di,dim_ci,dim_ir,dim_rr,dim_dr,dim_cr,dim_id,dim_rd,dim_dd,dim_cd,dim_ic,dim_rc,dim_dc,dim_cc,dim_e2,dim_e1,dim_e2,dim_e1)

idim:						" builtin 18
	swap		arg5
	unless_dt		int,idim.p
	swap		arg5
	unless_dt		int,idim.p

dim_ii:
	push_temp		int
	bump		op1		" temp is freed after 2nd ref
	bump		arg5
	bump		arg6

	load		q,arg5
	use_eaq
	make_addressable	arg5,arg6
	compare		q,arg6
	tmi		2,ic
	ldq		arg6
	stq		op1
	ldq		arg5
	sbq		op1
	return		q

dim_ir:
	s_call		builtin_2args_ir
	jump		dim.1

dim_ri:
	s_call		builtin_2args_ri
	jump		dim.1

dim_id:
	s_call		builtin_2args_id
	jump		ddim.1

dim_di:
	s_call		builtin_2args_di
	jump		ddim.1

dim_rr:
	jump		dim.1

dim_dd:
	jump		ddim.1

dim_rd:
	jump		rddim.1

dim_dr:
	jump		drdim.1

dim_ic:
	jump		bu_dt6.p

dim_ci:
	jump		bu_dt5.p

dim_rc:
	jump		bu_dt6.p

dim_cr:
	jump		bu_dt5.p

dim_dc:
	jump		bu_dt6.p

dim_cd:
	jump		bu_dt5.p

dim_cc:
	jump		bu_dt5.p

dim_e1:
	jump		bu_dt5.p

dim_e2:
	jump		bu_dt6.p

dim.1:
	bump		arg5
	bump		arg6
	load		eaq,arg5
	make_addressable	arg5,arg6
	compare		eaq,arg6		"saves arg5, if necessary
	tmi		2,ic
	fld		arg6
	emit_inst		1
	fneg
	fad		arg5
	return		eaq

ddim:						" builtin 19
	swap		arg5
	unless_dt		dp,ddim.p
	swap		arg5
	unless_dt		dp,ddim.p

ddim.1:
	bump		arg5
	bump		arg6
	load		deaq,arg5
	make_addressable	arg5,arg6
	compare		deaq,arg6		"saves arg5, if necessary
	tmi		2,ic
	dfld		arg6
	emit_inst		1
	fneg
	dfad		arg5
	return		deaq

rddim.1:
	bump		arg5
	bump		arg6
	load		eaq,arg5
	make_addressable	arg5,arg6
	compare		deaq,arg6		"saves arg5, if necessary
	tmi		2,ic
	dfld		arg6
	emit_inst		1
	fneg
	fad		arg5
	return		deaq

drdim.1:
	bump		arg5
	bump		arg6
	load		deaq,arg5
	make_addressable	arg5,arg6
	compare		eaq,arg6		"saves arg5, if necessary
	tmi		2,ic
	fld		arg6
	emit_inst		1
	fneg
	dfad		arg5
	return		deaq

idim.p:
ddim.p:
	jump		bu_dt6.p

exp:						" builtin 20
	dt_jump1		op1,(exp_i,exp.1,dexp.1,cexp.1,wrong_type.p,wrong_type.p)

exp.1:
	load		eaq,arg5
	jump		exp.2

exp_i:
	s_call		cv_load.ir

exp.2:
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|exp_
	free_regs
	return		eaq

dexp:						" builtin 21
	unless_dt		dp,dexp.p

dexp.1:
	load		deaq,arg5
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|dexp_
	free_regs
	return		deaq

cexp:						" builtin 22
	unless_dt		cmpx,cexp.p

cexp.1:
	load		aq,arg5
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|cexp_
	ldaq		pr6|temp_pt
	free_regs
	return		aq

dexp.p:
	jump		bu_dt5.p

cexp.p:
	jump		bu_dt5.p

max:						" builtin 23
	unless		arg2,>,1,wrong_number.p
	dt_jump		(max_ii,max_ri,max_di,max_ci,max_ir,max_rr,max_dr,max_cr,max_id,max_rd,max_dd,max_cd,max_ic,max_rc,max_dc,max_cc,max_e2,max_e1,max_e2,max_e1)

max_ii:
	jump		g.max0

max_ir:
	s_call		builtin_2args_ir
	jump		g.amax1

max_ri:
	s_call		builtin_2args_ri
	jump		g.amax1

max_id:
	s_call		builtin_2args_id
	jump		g.dmax1

max_di:
	s_call		builtin_2args_di
	jump		g.dmax1

max_rr:
	jump		g.amax1

max_dd:
	jump		g.dmax1

max_rd:
	swap		op2
	load		eaq,op1
	pop		op1
	unless		arg2,>,2,g.dmax1.loop.1
	round		deaq
	jump		g.dmax1.loop.1

max_dr:
	swap		op2
	jump		max_rd

max_ic:
	jump		mm_dt1.p

max_ci:
	jump		mm_dt2.p

max_rc:
	jump		mm_dt1.p

max_cr:
	jump		mm_dt2.p

max_dc:
	jump		mm_dt1.p

max_cd:
	jump		mm_dt2.p

max_cc:
	jump		mm_dt1.p

max_e1:
	jump		mm_dt2.p

max_e2:
	jump		mm_dt1.p

g.max0:
	load_top		q
	pop		op1
	jump		g.max0.loop.1

g.max0.loop:
	use_eaq				" save temps before test and transfer
	dt_jump1		op1,(g.max0.loop.1,g.max0.real,g.max0.dp,mm_dt1.p,wrong_type.p,wrong_type.p,wrong_type.p)

g.max0.real:
	s_call		cv_q_to_real
	jump		g.amax1.loop.1

g.max0.dp:
	s_call		cv_q_to_dp
	jump		g.dmax1.loop.1

g.max0.loop.1:
	bump		op1		" because it is ref'd twice
	compare		q,op1
	tpl		2,ic
	ldq		op1
	pop		op1
	use_ind				" invalidate indicators

	if		arg2,=,2,mm_ret_q
	decrement		arg2,1
	jump		g.max0.loop

g.amax1:
	load_top		eaq
	pop		op1
	unless		arg2,>,2,g.amax1.loop.1
	round		eaq
	jump		g.amax1.loop.1

g.amax1.loop:
	use_eaq				" save temps before test and transfer
	set_rounded
	dt_jump1		op1,(g.amax1.int,g.amax1.loop.1,g.amax1.dp,mm_dt1.p,wrong_type.p,wrong_type.p,wrong_type.p)

g.amax1.int:
	push_temp		real
	bump		op1
	store		eaq,op1,no_update
	swap		op2
	s_call		cv_load.ir
	pop		op1		" remove int and use real temp
	jump		g.amax1.loop.1

g.amax1.dp:
	jump		g.dmax1.loop.1

g.amax1.loop.1:
	bump		op1		" because it is ref'd twice
	compare		eaq,op1
	tpl		2,ic
	fld		op1
	pop		op1
	use_ind				" invalidate indicators

	if		arg2,=,2,mm_ret_eaq
	decrement		arg2,1
	jump		g.amax1.loop

g.dmax1:
	load_top		deaq
	pop		op1
	unless		arg2,>,2,g.dmax1.loop.1
	round		deaq
	jump		g.dmax1.loop.1

g.dmax1.loop:
	use_eaq				" save temps before test and transfer
	set_rounded
	dt_jump1		op1,(g.dmax1.int,g.dmax1.real,g.dmax1.loop.1,mm_dt1.p,wrong_type.p,wrong_type.p,wrong_type.p)

g.dmax1.int:
	push_temp		dp
	bump		op1
	store		deaq,op1,no_update
	swap		op2
	s_call		cv_load.id
	pop		op1		" remove int and use dp temp
	jump		g.dmax1.loop.1

g.dmax1.real:
	bump		op1		" because it is ref'd twice
	compare		eaq,op1
	tpl		2,ic
	fld		op1
	jump		g.dmax1.loop.2

g.dmax1.loop.1:
	bump		op1
	compare		deaq,op1
	tpl		2,ic
	dfld		op1

g.dmax1.loop.2:
	pop		op1
	use_ind				" invalidate indicators

	if		arg2,=,2,mm_ret_deaq
	decrement		arg2,1
	jump		g.dmax1.loop

amax0:						" builtin 24
	unless		arg2,>,1,wrong_number.p
	unless_dt		int,amax0.p
	swap		op2
	unless_dt		int,amax0.p

	load_top		q
	pop		op1

amax0.loop:
	bump		op1		" because it is ref'd twice
	use_eaq				" save temps before test and transfer
	compare		q,op1
	tpl		2,ic
	ldq		op1
	pop		op1
	use_ind				" invalidate indicators

	if		arg2,=,2,amax0.r
	decrement		arg2,1
	if_dt		int,amax0.loop
	jump		amax0.p

amax0.r:
	s_call		cv_q_to_real
	jump		mm_ret_eaq

amax0.p:
	jump		mm_dt1.p

amax1:						" builtin 25
	unless		arg2,>,1,wrong_number.p
	unless_dt		real,amax1.p
	swap		op2
	unless_dt		real,amax1.p

	load_top		eaq
	pop		op1
	unless		arg2,>,2,amax1.loop.1
	round		eaq
	jump		amax1.loop.1

amax1.loop:
	use_eaq				"save temps before test and transfer
	set_rounded

amax1.loop.1:
	bump		op1		" because it is ref'd twice
	compare		eaq,op1
	tpl		2,ic
	fld		op1
	pop		op1
	use_ind				" invalidate indicators

	if		arg2,=,2,mm_ret_eaq
	decrement		arg2,1
	if_dt		real,amax1.loop

amax1.p:
	jump		mm_dt1.p

max0:						" builtin 26
	unless		arg2,>,1,wrong_number.p
	unless_dt		int,max0.p
	swap		op2
	unless_dt		int,max0.p

	load_top		q
	pop		op1

max0.loop:
	bump		op1		" because it is ref'd twice
	use_eaq				" save temps before test and transfer
	compare		q,op1
	tpl		2,ic
	ldq		op1
	pop		op1
	use_ind				" invalidate indicators

	if		arg2,=,2,mm_ret_q
	decrement		arg2,1
	if_dt		int,max0.loop

max0.p:
	jump		mm_dt1.p

max1:						" builtin 27
	unless		arg2,>,1,wrong_number.p
	unless_dt		real,max1.p
	swap		op2
	unless_dt		real,max1.p

	load_top		eaq
	pop		op1
	unless		arg2,>,2,max1.loop.1
	round		eaq
	jump		max1.loop.1

max1.loop:
	use_eaq				"save temps before test and transfer
	set_rounded

max1.loop.1:
	bump		op1		" because it is ref'd twice
	compare		eaq,op1
	tpl		2,ic
	fld		op1
	pop		op1
	use_ind				" invalidate indicators

	if		arg2,=,2,max1.r
	decrement		arg2,1
	if_dt		real,max1.loop
	jump		max1.p

max1.r:
	use_ind
	round		eaq
	s_call		cv_real_to_int
	jump		mm_ret_q

max1.p:
	jump		mm_dt1.p

dmax1:						" builtin 28
	unless		arg2,>,1,wrong_number.p
	unless_dt		dp,dmax1.p
	swap		op2
	unless_dt		dp,dmax1.p

	load_top		deaq
	pop		op1
	unless		arg2,>,2,dmax1.loop.1
	round		deaq
	jump		dmax1.loop.1

dmax1.loop:
	use_eaq				"save temps before test and transfer
	set_rounded

dmax1.loop.1:
	bump		op1		" because it is ref'd twice
	compare		deaq,op1
	tpl		2,ic
	dfld		op1
	pop		op1
	use_ind				" invalidate indicators

	if		arg2,=,2,mm_ret_deaq
	decrement		arg2,1
	if_dt		dp,dmax1.loop

dmax1.p:
	jump		mm_dt1.p

min:						" builtin 29
	unless		arg2,>,1,wrong_number.p
	dt_jump		(min_ii,min_ri,min_di,min_ci,min_ir,min_rr,min_dr,min_cr,min_id,min_rd,min_dd,min_cd,min_ic,min_rc,min_dc,min_cc,min_e2,min_e1,min_e2,min_e1)

min_ii:
	jump		g.min0

min_ir:
	s_call		builtin_2args_ir
	jump		g.amin1

min_ri:
	s_call		builtin_2args_ri
	jump		g.amin1

min_id:
	s_call		builtin_2args_id
	jump		g.dmin1

min_di:
	s_call		builtin_2args_di
	jump		g.dmin1

min_rr:
	jump		g.amin1

min_dd:
	jump		g.dmin1

min_rd:
	swap		op2
	load		eaq,op1
	pop		op1
	unless		arg2,>,2,g.dmin1.loop.1
	round		deaq
	jump		g.dmin1.loop.1

min_dr:
	swap		op2
	jump		min_rd

min_ic:
	jump		mm_dt1.p

min_ci:
	jump		mm_dt2.p

min_rc:
	jump		mm_dt1.p

min_cr:
	jump		mm_dt2.p

min_dc:
	jump		mm_dt1.p

min_cd:
	jump		mm_dt2.p

min_cc:
	jump		mm_dt1.p

min_e1:
	jump		mm_dt2.p

min_e2:
	jump		mm_dt1.p

g.min0:
	load_top		q
	pop		op1
	jump		g.min0.loop.1

g.min0.loop:
	use_eaq				" save temps before test and transfer
	dt_jump1		op1,(g.min0.loop.1,g.min0.real,g.min0.dp,mm_dt1.p,wrong_type.p,wrong_type.p,wrong_type.p)

g.min0.real:
	s_call		cv_q_to_real
	jump		g.amin1.loop.1

g.min0.dp:
	s_call		cv_q_to_dp
	jump		g.dmin1.loop.1

g.min0.loop.1:
	bump		op1		" because it is ref'd twice
	compare		q,op1
	tmoz		2,ic
	ldq		op1
	pop		op1
	use_ind				" invalidate indicators

	if		arg2,=,2,mm_ret_q
	decrement		arg2,1
	jump		g.min0.loop

g.amin1:
	load_top		eaq
	pop		op1
	unless		arg2,>,2,g.amin1.loop.1
	round		eaq
	jump		g.amin1.loop.1

g.amin1.loop:
	use_eaq				" save temps before test and transfer
	set_rounded
	dt_jump1		op1,(g.amin1.int,g.amin1.loop.1,g.amin1.dp,mm_dt1.p,wrong_type.p,wrong_type.p,wrong_type.p)

g.amin1.int:
	push_temp		real
	bump		op1
	store		eaq,op1,no_update
	swap		op2
	s_call		cv_load.ir
	pop		op1		" remove int and use real temp
	jump		g.amin1.loop.1

g.amin1.dp:
	jump		g.dmin1.loop.1

g.amin1.loop.1:
	bump		op1		" because it is ref'd twice
	compare		eaq,op1
	tmoz		2,ic
	fld		op1
	pop		op1
	use_ind				" invalidate indicators

	if		arg2,=,2,mm_ret_eaq
	decrement		arg2,1
	jump		g.amin1.loop

g.dmin1:
	load_top		deaq
	pop		op1
	unless		arg2,>,2,g.dmin1.loop.1
	round		deaq
	jump		g.dmin1.loop.1

g.dmin1.loop:
	use_eaq				" save temps before test and transfer
	set_rounded
	dt_jump1		op1,(g.dmin1.int,g.dmin1.real,g.dmin1.loop.1,mm_dt1.p,wrong_type.p,wrong_type.p,wrong_type.p)

g.dmin1.int:
	push_temp		dp
	bump		op1
	store		deaq,op1,no_update
	swap		op2
	s_call		cv_load.id
	pop		op1		" remove int and use dp temp
	jump		g.dmin1.loop.1

g.dmin1.real:
	bump		op1		" because it is ref'd twice
	compare		eaq,op1
	tmoz		2,ic
	fld		op1
	jump		g.dmin1.loop.2

g.dmin1.loop.1:
	bump		op1
	compare		deaq,op1
	tmoz		2,ic
	dfld		op1

g.dmin1.loop.2:
	pop		op1
	use_ind				" invalidate indicators

	if		arg2,=,2,mm_ret_deaq
	decrement		arg2,1
	jump		g.dmin1.loop

amin0:						" builtin 30
	unless		arg2,>,1,wrong_number.p
	unless_dt		int,amin0.p
	swap		op2
	unless_dt		int,amin0.p

	load_top		q
	pop		op1

amin0.loop:
	bump		op1		" because it is ref'd twice
	use_eaq				" save temps before test and transfer
	compare		q,op1
	tmoz		2,ic
	ldq		op1
	pop		op1
	use_ind				" invalidate indicators

	if		arg2,=,2,amin0.r

	decrement		arg2,1
	if_dt		int,amin0.loop
	jump		amin0.p

amin0.r:
	s_call		cv_q_to_real
	jump		mm_ret_eaq

amin0.p:
	jump		mm_dt1.p

amin1:						" builtin 31
	unless		arg2,>,1,wrong_number.p
	unless_dt		real,amin1.p
	swap		op2
	unless_dt		real,amin1.p

	load_top		eaq
	pop		op1
	unless		arg2,>,2,amin1.loop.1
	round		eaq
	jump		amin1.loop.1

amin1.loop:
	use_eaq				"save temps before test and transfer
	set_rounded

amin1.loop.1:
	bump		op1		" because it is ref'd twice
	compare		eaq,op1
	tmoz		2,ic
	fld		op1
	pop		op1
	use_ind				" invalidate indicators

	if		arg2,=,2,mm_ret_eaq
	decrement		arg2,1
	if_dt		real,amin1.loop

amin1.p:
	jump		mm_dt1.p

min0:						" builtin 32
	unless		arg2,>,1,wrong_number.p
	unless_dt		int,min0.p
	swap		op2
	unless_dt		int,min0.p

	load_top		q
	pop		op1

min0.loop:
	bump		op1		" because it is ref'd twice
	use_eaq				" save temps before test and transfer
	compare		q,op1
	tmoz		2,ic
	ldq		op1
	pop		op1
	use_ind				" invalidate indicators

	if		arg2,=,2,mm_ret_q
	decrement		arg2,1
	if_dt		int,min0.loop

min0.p:
	jump		mm_dt1.p

min1:						" builtin 33
	unless		arg2,>,1,wrong_number.p
	unless_dt		real,min1.p
	swap		op2
	unless_dt		real,min1.p

	load_top		eaq
	pop		op1
	unless		arg2,>,2,min1.loop.1
	round		eaq
	jump		min1.loop.1

min1.loop:
	use_eaq				"save temps before test and transfer
	set_rounded

min1.loop.1:
	bump		op1		" because it is ref'd twice
	compare		eaq,op1
	tmoz		2,ic
	fld		op1
	pop		op1
	use_ind				" invalidate indicators

	if		arg2,=,2,min1.r
	decrement		arg2,1
	if_dt		real,min1.loop
	jump		min1.p

min1.r:
	use_ind
	round		eaq
	s_call		cv_real_to_int
	jump		mm_ret_q

min1.p:
	jump		mm_dt1.p

dmin1:						" builtin 34
	unless		arg2,>,1,wrong_number.p
	unless_dt		dp,dmin1.p
	swap		op2
	unless_dt		dp,dmin1.p

	load_top		deaq
	pop		op1
	unless		arg2,>,2,dmin1.loop.1
	round		deaq
	jump		dmin1.loop.1

dmin1.loop:
	use_eaq				"save temps before test and transfer
	set_rounded

dmin1.loop.1:
	bump		op1		" because it is ref'd twice
	compare		deaq,op1
	tmoz		2,ic
	dfld		op1
	pop		op1
	use_ind				" invalidate indicators

	if		arg2,=,2,mm_ret_deaq
	decrement		arg2,1
	if_dt		dp,dmin1.loop

dmin1.p:
	jump		mm_dt1.p

mod:						" builtin 35
	dt_jump		(mod_ii,mod_ri,mod_di,mod_ci,mod_ir,mod_rr,mod_dr,mod_cr,mod_id,mod_rd,mod_dd,mod_cd,mod_ic,mod_rc,mod_dc,mod_cc,mod_e2,mod_e1,mod_e2,mod_e1)

mod_ii:
	jump		mod.1

mod_ir:
	s_call		builtin_2args_ir
	jump		amod.1

mod_ri:
	s_call		builtin_2args_ri
	jump		amod.1

mod_id:
	s_call		builtin_2args_id
	jump		dmod.1

mod_di:
	s_call		builtin_2args_di
	jump		dmod.1

mod_rr:
	jump		amod.1

mod_dd:
	jump		dmod.1

mod_rd:
	jump		rdmod.1

mod_dr:
	jump		dmod.1

mod_ic:
	jump		bu_dt6.p

mod_ci:
	jump		bu_dt5.p

mod_rc:
	jump		bu_dt6.p

mod_cr:
	jump		bu_dt5.p

mod_dc:
	jump		bu_dt6.p

mod_cd:
	jump		bu_dt5.p

mod_cc:
	jump		bu_dt5.p

mod_e1:
	jump		bu_dt5.p

mod_e2:
	jump		bu_dt6.p

mod.1:
	load		q,arg5
	div		arg6
	emit_inst		1
	lrs		36
	return		q

amod:						" builtin 36
	swap		arg5
	unless_dt		real,amod.p
	swap		arg5
	unless_dt		real,amod.p

amod.1:
	load		eaq,arg5
	bump		arg6
	load_pr		pr2,arg6
	use_eaq
	tsx0		pr0|fort_modfl
	drop		arg6
	free_regs
	return		eaq

dmod:						" builtin 37
	swap		arg5
	unless_dt		dp,dmod.p
	swap		arg5
	unless_dt		dp,dmod.p

dmod.1:
	load		deaq,arg5
dmod.2:
	use_eaq
	bump		arg6
	load_pr		pr2,arg6
	tsx0		pr0|fort_dmod
	drop		arg6
	free_regs
	return		deaq

rdmod.1:
	load		eaq,arg5
	jump		dmod.2

amod.p:
dmod.p:
	jump		bu_dt6.p

sign:						" builtin 38
	dt_jump		(sign_ii,sign_ri,sign_di,sign_ci,sign_ir,sign_rr,sign_dr,sign_cr,sign_id,sign_rd,sign_dd,sign_cd,sign_ic,sign_rc,sign_dc,sign_cc,sign_e2,sign_e1,sign_e2,sign_e1)

isign:						" builtin 39
	swap		arg5
	unless_dt		int,isign.p
	swap		arg5
	unless_dt		int,isign.p

sign_ii:
	bump		arg6
	load_pr		pr2,arg6
	load_for_test	q,arg5
	use_eaq		protect_indicators
	tsx0		pr0|sign_fx
	drop		arg6
	free_regs
	return		q

sign_ir:
	s_call		builtin_2args_ir
	jump		sign.1

sign_ri:
	s_call		builtin_2args_ri
	jump		sign.1

sign_id:
	s_call		builtin_2args_id
	jump		dsign.1

sign_di:
	s_call		builtin_2args_di
	jump		dsign.1

sign_rr:
	jump		sign.1

sign_dd:
	jump		dsign.1

sign_rd:
	jump		rdsign.1

sign_dr:
	jump		dsign.1

sign_ic:
	jump		bu_dt6.p

sign_ci:
	jump		bu_dt5.p

sign_rc:
	jump		bu_dt6.p

sign_cr:
	jump		bu_dt5.p

sign_dc:
	jump		bu_dt6.p

sign_cd:
	jump		bu_dt5.p

sign_cc:
	jump		bu_dt5.p

sign_e1:
	jump		bu_dt5.p

sign_e2:
	jump		bu_dt6.p

sign.1:
	bump		arg6
	load_pr		pr2,arg6
	load_for_test	eaq,arg5
	use_eaq		protect_indicators
	tsx0		pr0|sign_fl
	drop		arg6
	free_regs
	return		eaq

dsign:						" builtin 40
	swap		arg5
	unless_dt		dp,dsign.p
	swap		arg5
	unless_dt		dp,dsign.p

dsign.1:
	bump		arg6
	load_pr		pr2,arg6
	load_for_test	deaq,arg5
dsign.2:
	use_eaq		protect_indicators
	tsx0		pr0|sign_fl
	drop		arg6
	free_regs
	return		deaq

rdsign.1:
	bump		arg6
	load_pr		pr2,arg6
	load_for_test	eaq,arg5
	jump		dsign.2

isign.p:
dsign.p:
	jump		bu_dt6.p

builtin_2args_ii:
	swap		op2

	if_optype		constant,conv_bu_ii.1

	push_temp		real

	load		q,op2
	use_eaq
	tsx0		pr0|integer_to_real
	in_reg		eaq,op1
	swap		op2
	pop		op1
	swap		op2
	jump		builtin_2args_ii.1

conv_bu_ii.1:
	convert_constant	real

	swap		op2

builtin_2args_ii.1:
	if_optype		constant,conv_bu_ii.2

	push_temp		real

	load		q,op2
	use_eaq
	tsx0		pr0|integer_to_real
	in_reg		eaq,op1
	swap		op2
	pop		op1
	s_return

conv_bu_ii.2:
	convert_constant	real

	s_return

builtin_2args_ir:
	swap		op2

	if_optype		constant,conv_bu_ir

	push_temp		real

	load		q,op2
	use_eaq
	tsx0		pr0|integer_to_real
	in_reg		eaq,op1
	swap		op2
	pop		op1
	swap		op2
	s_return

conv_bu_ir:
	convert_constant	real

	swap		op2
	s_return

builtin_2args_ri:
	if_optype		constant,conv_bu_ri

	push_temp		real

	load		q,op2
	use_eaq
	tsx0		pr0|integer_to_real
	in_reg		eaq,op1
	swap		op2
	pop		op1
	s_return

conv_bu_ri:
	convert_constant	real

	s_return

builtin_2args_id:
	swap		op2

	if_optype		constant,conv_bu_id

	push_temp		dp

	load		q,op2
	use_eaq
	tsx0		pr0|integer_to_double
	in_reg		deaq,op1
	swap		op2
	pop		op1
	swap		op2
	s_return

conv_bu_id:
	convert_constant	dp

	swap		op2
	s_return

builtin_2args_di:
	if_optype		constant,conv_bu_di

	push_temp		dp

	load		q,op2
	use_eaq
	tsx0		pr0|integer_to_double
	in_reg		deaq,op1
	swap		op2
	pop		op1
	s_return

conv_bu_di:
	convert_constant	dp

	s_return

sin:						" builtin 41
	dt_jump1		op1,(sin_i,sin.1,dsin.1,csin.1,wrong_type.p,wrong_type.p,wrong_type.p)

sin.1:
	load		eaq,arg5
	jump		sin.2

sin_i:
	s_call		cv_load.ir

sin.2:
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|sin_
	free_regs
	return		eaq

dsin:						" builtin 42
	unless_dt		dp,dsin.p
dsin.1:
	load		deaq,arg5
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|dsin_
	free_regs
	return		deaq

csin:						" builtin 43
	unless_dt		cmpx,csin.p
csin.1:
	load		aq,arg5
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|csin_
	ldaq		pr6|temp_pt
	free_regs
	return		aq

dsin.p:
csin.p:
	jump		bu_dt5.p

sqrt:						" builtin 44
	dt_jump1  	op1,(sqrt_i,sqrt.1,dsqrt.1,csqrt.1,wrong_type.p,wrong_type.p,wrong_type.p)

sqrt.1:
	load		eaq,arg5
	jump		sqrt.2

sqrt_i:
	s_call		cv_load.ir

sqrt.2:
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|sqrt_
	free_regs
	return		eaq

dsqrt:						" builtin 45
	unless_dt		dp,dsqrt.p
dsqrt.1:
	load		deaq,arg5
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|dsqrt_
	free_regs
	return		deaq

csqrt:						" builtin 46
	unless_dt		cmpx,csqrt.p
csqrt.1:
	load		aq,arg5
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|csqrt_
	ldaq		pr6|temp_pt
	free_regs
	return		aq

dsqrt.p:
csqrt.p:
	jump		bu_dt5.p

tanh:						" builtin 47
	dt_jump1		arg5,(tanh.int,tanh.real,tanh.dp,tanh.p,tanh.p,tanh.p,tanh.p)

tanh.int:
	s_call		cv_load.ir
	jump		tanh.1

tanh.real:
	load		eaq,arg5

tanh.1:
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|tanh_
	fld		pr6|temp_pt
	free_regs
	return		eaq

tanh.dp:
	load		deaq,arg5
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|dtanh_
	dfld		pr6|temp_pt
	free_regs
	return		deaq


dtanh:						" builtin 77
	unless_dt		dp,dtanh.p
	jump		tanh.dp


tanh.p:
dtanh.p:
	jump		bu_dt5.p

sinh:						" builtin 74
	dt_jump1		arg5,(sinh.int,sinh.real,sinh.dp,sinh.p,sinh.p,sinh.p,sinh.p)

sinh.int:
	s_call		cv_load.ir
	jump		sinh.1

sinh.real:
	load		eaq,arg5

sinh.1:
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|sinh_
	fld		pr6|temp_pt
	free_regs
	return		eaq

sinh.dp:
	load		deaq,arg5
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|dsinh_
	dfld		pr6|temp_pt
	free_regs
	return		deaq


dsinh:						" builtin 76
	unless_dt		dp,dsinh.p
	jump		sinh.dp


sinh.p:
dsinh.p:
	jump		bu_dt5.p

cosh:						" builtin 73
	dt_jump1		arg5,(cosh.int,cosh.real,cosh.dp,cosh.p,cosh.p,cosh.p,cosh.p)

cosh.int:
	s_call		cv_load.ir
	jump		cosh.1

cosh.real:
	load		eaq,arg5

cosh.1:
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|cosh_
	fld		pr6|temp_pt
	free_regs
	return		eaq

cosh.dp:
	load		deaq,arg5
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|dcosh_
	dfld		pr6|temp_pt
	free_regs
	return		deaq


dcosh:						" builtin 75
	unless_dt		dp,dcosh.p
	jump		cosh.dp


cosh.p:
dcosh.p:
	jump		bu_dt5.p

int_builtin:					" builtin 48
	dt_jump1		arg5,(int_builtin.int,int_builtin.real,int_builtin.dp,int_builtin.cmpx,int.p,int.p,int_builtin.tl)

int_builtin.int:
	load		q,arg5
	return		q

int_builtin.real:
	s_call		cv_load.ri
	return		q

int_builtin.dp:
	s_call		cv_load.di
	return		q

int_builtin.cmpx:
	s_call		cv_load.ri
	return		q

int_builtin.tl:
	load		q,arg5
	return		q


ifix:						" builtin 52
	unless_dt		real,ifix.p
	jump		int_builtin.real


idint:						" builtin 50
	unless_dt		dp,idint.p
	jump		int_builtin.dp


int.p:
ifix.p:
idint.p:
	jump		bu_dt5.p

aint:						" builtin 49
	dt_jump1		arg5,(aint.int,aint.real,aint.dp,aint.p,aint.p,aint.p,aint.p)

aint.int:
	s_call		cv_load.ir
	return		eaq

aint.real:
	load_for_test	eaq,arg5
	use_eaq		protect_indicators
	tsx0		pr0|trunc_fl
	return		eaq

aint.dp:
	load_for_test	deaq,arg5
	use_eaq		protect_indicators
	tsx0		pr0|trunc_fl
	return		deaq


dint:						" builtin 78
	unless_dt		dp,dint.p
	jump		aint.dp


aint.p:
dint.p:
	jump		bu_dt5.p

anint:						" builtin 79
	dt_jump1		arg5,(anint.int,anint.real,anint.dp,anint.p,anint.p,anint.p,anint.p)

anint.int:
	s_call		cv_load.ir
	return		eaq

anint.real:
	load_for_test	eaq,arg5
	use_eaq		protect_indicators
	tsx0		pr0|nearest_whole_number
	return		eaq

anint.dp:
	load_for_test	deaq,arg5
	use_eaq		protect_indicators
	tsx0		pr0|nearest_whole_number
	return		deaq


dnint:						" builtin 80
	unless_dt		dp,dnint.p
	jump		anint.dp


anint.p:
dnint.p:
	jump		bu_dt5.p

nint:						" builtin 81
	dt_jump1		arg5,(nint.int,nint.real,nint.dp,nint.p,nint.p,nint.p,nint.p)

nint.int:
	load		q,arg5
	return		q

nint.real:
	load_for_test	eaq,arg5
	use_eaq		protect_indicators
	tsx0		pr0|nearest_integer
	return		q

nint.dp:
	load_for_test	deaq,arg5
	use_eaq		protect_indicators
	tsx0		pr0|nearest_integer
	return		q


idnint:						" builtin 82
	unless_dt		dp,idnint.p
	jump		nint.dp


nint.p:
idnint.p:
	jump		bu_dt5.p

real_builtin:					" builtin 54
	dt_jump1		arg5,(real_builtin.int,real_builtin.real,real_builtin.dp,real_builtin.cmpx,real.p,real.p,real.p)

real_builtin.int:
	s_call		cv_load.ir
	return		eaq

real_builtin.real:
	load		eaq,arg5
	return		eaq

real_builtin.dp:
	load		deaq,arg5
	emit_inst		1
	frd		0
	return		eaq

real_builtin.cmpx:
	load		eaq,arg5
	return		eaq


float:						" builtin 51
	unless_dt		int,float.p
	jump		real_builtin.int


sngl:						" builtin 53
	unless_dt		dp,sngl.p
	jump		real_builtin.dp


real.p:
float.p:
sngl.p:
	jump		bu_dt5.p

aimag:						" builtin 55
	unless_dt		cmpx,aimag.p

	load		ieaq,arg5
	return		eaq

aimag.p:
	jump		bu_dt5.p

dble:						" builtin 56
	dt_jump1		arg5,(dble.int,dble.real,dble.dp,dble.cmpx,dble.p,dble.p,dble.p)

dble.int:
	s_call		cv_load.id
	return		deaq

dble.real:
	load		eaq,arg5
	return		deaq

dble.dp:
	load		deaq,arg5
	return		deaq

dble.cmpx:
	load		eaq,arg5
	return		deaq

dble.p:
	jump		bu_dt5.p

cmplx:						" builtin 57
	if		arg2,=,1,cmplx.one
	if		arg2,=,2,cmplx.two

cmplx.one:
	dt_jump1		arg5,(cmplx.one.int,cmplx.one.real,cmplx.one.dp,cmplx.one.cmpx,cmplx.one.p,cmplx.one.p,cmplx.one.p)

cmplx.one.int:
	s_call		cv_load.ir
	jump		cmplx.one.join

cmplx.one.real:
	load		eaq,arg5
	jump		cmplx.one.join

cmplx.one.dp:
	load		deaq,arg5
	emit_inst		1
	frd		0
	jump		cmplx.one.join

cmplx.one.cmpx:
	load		aq,arg5
	return		aq

cmplx.one.join:
	push_output
	store		eaq,op1,no_update
	bump		op1
	fld		=0.0,du
	fst		op1+1
	return		op1

cmplx.one.p:
	jump		bu_dt5.p

cmplx.two:
	dt_jump		(cmplx.two.ii,cmplx.two.ri,cmplx.two.di,cmplx.two.e1,cmplx.two.ir,cmplx.two.rr,cmplx.two.dr,cmplx.two.e1,cmplx.two.id,cmplx.two.rd,cmplx.two.dd,cmplx.two.e1,cmplx.two.e2,cmplx.two.e2,cmplx.two.e2,cmplx.two.e1,cmplx.two.e2,cmplx.two.e1,cmplx.two.e2,cmplx.two.e1)

cmplx.two.ii:
	push_output
	if_eaq		q,arg6,cmplx.two.ii.1
	swap		arg5
	s_call		cv_load.ir
	swap		arg5
	store		eaq,op1,no_update
	swap		arg6
	s_call		cv_load.ir
	swap		arg6
	in_reg		ieaq,op1
	return		op1

cmplx.two.ii.1:
	bump		arg6
	swap		arg6
	s_call		cv_load.ir
	swap		arg6
	store		ieaq,op1,no_update
	swap		arg5
	s_call		cv_load.ir
	swap		arg5
	in_reg		eaq,op1
	return		op1

cmplx.two.rr:
	push_output
	if_eaq		eaq,arg6,cmplx.two.rr.1
	load		eaq,arg5
	store		eaq,op1,no_update
	fld		arg6
	in_reg		ieaq,op1
	return		op1

cmplx.two.rr.1:
	store		ieaq,op1,no_update
	fld		arg5
	in_reg		eaq,op1
	return		op1

cmplx.two.dd:
	push_output
	if_eaq		deaq,arg6,cmplx.two.dd.1
	load		deaq,arg5
	emit_inst		1
	frd		0
	store		eaq,op1,no_update
	dfld		arg6
	emit_inst		1
	frd		0
	in_reg		ieaq,op1
	return		op1

cmplx.two.dd.1:
	emit_inst		1
	frd		0
	store		ieaq,op1,no_update
	dfld		arg5
	emit_inst		1
	frd		0
	in_reg		eaq,op1
	return		op1

cmplx.two.e1:
	jump		bu_dt5.p

cmplx.two.e2:
	jump		bu_dt6.p

cmplx.two.ri:
cmplx.two.di:
cmplx.two.ir:
cmplx.two.dr:
cmplx.two.id:
cmplx.two.rd:
	error		314,arg1

conjg:						" builtin 58
	bump		arg5
	unless_dt		cmpx,conjg.p

	push_output
	bump		op1

	if_eaq		ieaq,arg5,conjg.1

	load		eaq,arg5
	store		eaq,op1,no_update
	fld		arg5+1
	emit_inst		1
	fneg
	in_reg		ieaq,op1

	return		op1

conjg.1:
	emit_inst		1
	fneg
	store		ieaq,op1,no_update
	fld		arg5
	in_reg		eaq,op1

	return		op1

conjg.p:
	jump		bu_dt5.p

tan:						" builtin 59
	dt_jump1		op1,(tan_i,tan.1,dtan.1,bu_dt5.p,wrong_type.p,wrong_type.p,wrong_type.p)

tan.1:
	load		eaq,arg5
	jump		tan.2

tan_i:
	s_call		cv_load.ir

tan.2:
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|tan_
	free_regs
	return		eaq

dtan:						" builtin 60
	unless_dt		dp,bu_dt5.p
dtan.1:
	load		deaq,arg5
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|dtan_
	free_regs
	return		deaq

asin:						" builtin 61
	dt_jump1		op1,(asin_i,asin.1,dasin.1,bu_dt5.p,wrong_type.p,wrong_type.p,wrong_type.p)

asin.1:
	load		eaq,arg5
	jump		asin.2

asin_i:
	s_call		cv_load.ir

asin.2:
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|asin_
	free_regs
	return		eaq

dasin:						" builtin 62
	unless_dt		dp,bu_dt5.p
dasin.1:
	load		deaq,arg5
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|dasin_
	free_regs
	return		deaq

acos:						" builtin 63
	dt_jump1		op1,(acos_i,acos.1,dacos.1,bu_dt5.p,wrong_type.p,wrong_type.p,wrong_type.p)

acos.1:
	load		eaq,arg5
	jump		acos.2

acos_i:
	s_call		cv_load.ir

acos.2:
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|acos_
	free_regs
	return		eaq

dacos:						" builtin 64
	unless_dt		dp,bu_dt5.p
dacos.1:
	load		deaq,arg5
	push_temp		32
	load_pr		pr2,op1
	use_eaq
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)
	tsp3		pr0|dacos_
	free_regs
	return		deaq

char_builtin:					" builtin 65
	unless_dt		int,bu_dt5.p

	if_optype		constant,char.constant

	push_output

	load		q,op2

	emit_inst		1
	qls		27

	bump		op1,1

	stq		op1

	return		op1

char.constant:
	int_to_char1
	return		op1

ichar:						" builtin 66
	unless_dt		char,bu_dt5.p

	if_optype		constant,ichar.constant

	push_output

	if_aligned	op2,ichar.aligned

	emit_eis
	mrl		(pr),(pr),fill(0)
	desc9a		op2,1
	desc9a		op1,4

	return		op1

ichar.aligned:
	ldq		op2

	emit_inst		1
	qrl		27

	return		q

ichar.constant:
	char1_to_int
	return		op1

index:						" builtin 67
	unless_dt		char,bu_dt5.p
	swap		op2
	unless_dt		char,bu_dt5.p

	push_length	op2
	if		op1,=,1,index.1
	if		op1,=,2,index.2

	" Length of second string is not known to be 1 or 2

	push_length	op2

	load_pr		pr2,op3
	load		q,op1
	use_a
	tsx0		pr0|set_cs_eis

	free_regs

	load_pr		pr2,op4
	load		q,op2
	use_eaq
	tsx0		pr0|index_cs_eis

	free_regs

	return		q

index.1:

	" Length of second string is known to be 1

	emit_eis
	scm		(pr),(pr),mask(0)
	desc9a		op2
	desc9a		op3,1

	arg		pr6|double_temp

	ldq		pr6|double_temp
	ttf		2,ic
	lcq		1,dl
	adq		1,dl

	return		q

index.2:

	" Length of second string is known to be 2

	emit_eis
	scd		(pr),(pr)
	desc9a		op2
	desc9a		op3,2

	arg		pr6|double_temp

	ldq		pr6|double_temp
	ttf		2,ic
	lcq		1,dl
	adq		1,dl

	return		q

len:						" builtin 68
	unless_dt		char,bu_dt5.p
	push_length	op1
	return		op1

lge:						" builtin 69
	unless_dt		char,bu_dt5.p
	swap		op2
	unless_dt		char,bu_dt5.p

	use_ind

	emit_eis
	cmpc		(pr),(pr),fill(040)
	desc9a		op1
	desc9a		op2

	return		trc

lgt:						" builtin 70
	unless_dt		char,bu_dt5.p
	swap		op2
	unless_dt		char,bu_dt5.p

	use_ind

	emit_eis
	cmpc		(pr),(pr),fill(040)
	desc9a		op2
	desc9a		op1

	return		tnc

lle:						" builtin 71
	unless_dt		char,bu_dt5.p
	swap		op2
	unless_dt		char,bu_dt5.p

	use_ind

	emit_eis
	cmpc		(pr),(pr),fill(040)
	desc9a		op2
	desc9a		op1

	return		trc

llt:						" builtin 72
	unless_dt		char,bu_dt5.p
	swap		op2
	unless_dt		char,bu_dt5.p

	use_ind

	emit_eis
	cmpc		(pr),(pr),fill(040)
	desc9a		op1
	desc9a		op2

	return		tnc

dprod:						" builtin 83
	swap		arg5
	unless_dt		real,dprod.p
	swap		arg5
	unless_dt		real,dprod.p

	load_top		eaq
	fmp		op2
	return		deaq

dprod.p:
	jump		bu_dt6.p

and.tl:						" builtin 84
	unless		arg2,>,1,wrong_number.p
	unless_one_word_dt	op1,mm_dt1.p
	load_top		tq
	copy		op2

and.tl.loop:
	unless_one_word_dt	op1,mm_dt1.p
	anq		op1
	pop		op1
	if		arg2,=,2,and.tl.r
	copy		arg2
	copy		opv
	decrement		arg2,1
	jump		and.tl.loop

and.tl.r:
	jump		mm_ret_tq

bool.tl:						" builtin 85
	unless_one_word_dt	arg5,bu_dt5.p
	load		tq,arg5
	jump		mm_ret_tq

compl.tl:						" builtin 86
	unless_one_word_dt	arg5,bu_dt5.p
	use_eaq
	lcq		1,dl
	erq		arg5
	jump		mm_ret_tq

fld.tl:						" builtin 87
	rhs_fld
	jump		mm_ret_tq

ilr.tl:						" builtin 88
	dt_jump1		arg5,(ilr.1,bu_dt5.p,bu_dt5.p,bu_dt5.p,bu_dt5.p,bu_dt5.p,ilr.1)

ilr.1:
	dt_jump1		arg6,(ilr.2,bu_dt6.p,bu_dt6.p,bu_dt6.p,bu_dt6.p,bu_dt6.p,bu_dt6.p)

ilr.2:
	load		q,arg5
	load		ia,arg6
	qlr		0,al
	jump		mm_ret_q

ils.tl:						" builtin 89
	dt_jump1		arg5,(ils.1,bu_dt5.p,bu_dt5.p,bu_dt5.p,bu_dt5.p,bu_dt5.p,ils.1)

ils.1:
	dt_jump1		arg6,(ils.2,bu_dt6.p,bu_dt6.p,bu_dt6.p,bu_dt6.p,bu_dt6.p,bu_dt6.p)

ils.2:
	load		q,arg5
	load		ia,arg6
	qls		0,al
	jump		mm_ret_q

irl.tl:						" builtin 90
	dt_jump1		arg5,(irl.1,bu_dt5.p,bu_dt5.p,bu_dt5.p,bu_dt5.p,bu_dt5.p,irl.1)

irl.1:
	dt_jump1		arg6,(irl.2,bu_dt6.p,bu_dt6.p,bu_dt6.p,bu_dt6.p,bu_dt6.p,bu_dt6.p)

irl.2:
	load		q,arg5
	load		ia,arg6
	qrl		0,al
	jump		mm_ret_q

irs.tl:						" builtin 91
	dt_jump1		arg5,(irs.1,bu_dt5.p,bu_dt5.p,bu_dt5.p,bu_dt5.p,bu_dt5.p,irs.1)

irs.1:
	dt_jump1		arg6,(irs.2,bu_dt6.p,bu_dt6.p,bu_dt6.p,bu_dt6.p,bu_dt6.p,bu_dt6.p)

irs.2:
	load		q,arg5
	load		ia,arg6
	qrs		0,al
	jump		mm_ret_q

or.tl:						" builtin 92
	unless		arg2,>,1,wrong_number.p
	unless_one_word_dt	op1,mm_dt1.p
	load_top		tq
	copy		op2

or.tl.loop:
	unless_one_word_dt	op1,mm_dt1.p
	orq		op1
	pop		op1
	if		arg2,=,2,or.tl.r
	copy		arg2
	copy		opv
	decrement		arg2,1
	jump		or.tl.loop

or.tl.r:
	jump		mm_ret_tq

xor.tl:						" builtin 93
	unless		arg2,>,1,wrong_number.p
	unless_one_word_dt	op1,mm_dt1.p
	load_top		tq
	copy		op2

xor.tl.loop:
	unless_one_word_dt	op1,mm_dt1.p
	erq		op1
	pop		op1
	if		arg2,=,2,xor.tl.r
	copy		arg2
	copy		opv
	decrement		arg2,1
	jump		xor.tl.loop

xor.tl.r:
	jump		mm_ret_tq

bu_dt5.p:
	error		321,arg1,arg5

bu_dt6.p:
	error		321,arg1,arg6

mm_dt1.p:
	error		321,arg1,op1

mm_dt2.p:
	error		321,arg1,op2

"		Errors common to all relational operators.
logical_op1:
	error		339,op1

logical_op2:
	error		339,op2

typeless_op1:
	error		362,op1

typeless_op2:
	error		362,op2

invalid_opnd:
	error		340,op2

not_scalar:
	error		340,op1
"
"		Begin relational operators.
"
less:	func		2

	refresh_regs_if_next_is_jump

	dt_jump		(less_ii,less_ri,less_di,less_ci,less_ir,less_rr,less_dr,less_cr,less_id,less_rd,less_dd,less_cd,less_ic,less_rc,less_dc,less_cc,less_e2,less_e1,less_tl,less_tl)

less_ii:
	note_eligible_ind_var_use
	if_global_ind_var	arg1,less_ii.global
	if_global_ind_var	arg2,less_ii.global.1

	if_eaq		q,arg2,less_ii.1

	load		q,arg1
	compare		q,arg2
	return		tmi

less_ii.1:
	compare		q,arg1
	return		tpnz

less_ii.global:
	compare_index
	if_fb17		arg1,less_ii.global.fb17
	return		tnc
less_ii.global.fb17:
	return		tmi

less_ii.global.1:
	swap		arg1
	compare_index
	if_fb17		arg1,less_ii.global.1.fb17
	return		j_g_s
less_ii.global.1.fb17:
	return		tpnz

less_ir:
	swap		arg1

	s_call		cv_load.ir
	compare		eaq,arg1
	return		tmi

less_ri:
	s_call		cv_load.ir
	compare		eaq,arg1
	return		tpnz

less_id:
	swap		arg1

	s_call		cv_load.id
	compare		deaq,arg1
	return		tmi

less_di:
	s_call		cv_load.id
	compare		deaq,arg1
	return		tpnz

less_rr:
	if_eaq		eaq,arg2,less_rr.1

	load		eaq,arg1
	compare		eaq,arg2
	return		tmi

less_rr.1:
	compare		eaq,arg1
	return		tpnz

less_dd:
	if_eaq		deaq,arg2,less_dd.1

	load		deaq,arg1
	compare		deaq,arg2
	return		tmi

less_dd.1:
	compare		deaq,arg1
	return		tpnz

less_rd:
	if_eaq		deaq,arg2,less_rd.1

	load		eaq,arg1
	compare		deaq,arg2
	return		tmi

less_rd.1:
	compare		eaq,arg1
	return		tpnz

less_dr:
	if_eaq		eaq,arg2,less_dr.1

	load		deaq,arg1
	compare		eaq,arg2
	return		tmi

less_dr.1:
	compare		deaq,arg1
	return		tpnz

less_ic:
	error		323,arg2

less_ci:
	error		323,arg1

less_rc:
	error		323,arg2

less_cr:
	error		323,arg1

less_dc:
	error		312,arg1,arg2

less_cd:
	error		311,arg1,arg2

less_cc:
	error		328,arg1,arg2

less_e2:
	if_dt		logical,logical_op1
	dt_jump1		arg1,(less_ih,less_rh,less_dh,less_ch,logical_op2,less_hh,less_th)

less_ih:
less_rh:
less_th:
	unless_optype	constant,invalid_opnd

	swap		arg1
	unless_optype	(variable,array_ref,temp),not_scalar

	pad_char_const_to_word	arg1	" the two operands remain swapped

	load		a,arg2
	cmpa		arg1
	return		tnc

less_dh:
less_ch:
	unless_optype	constant,invalid_opnd

	swap		arg1
	unless_optype	(variable,array_ref,temp),not_scalar

	pad_char_const_to_dw	arg1	" the two operands remain swapped

	load		aq,arg2
	cmpaq		arg1
	return		tnc

less_hh:
	use_eaq

	emit_eis
	cmpc		(pr),(pr),fill(040)
	desc9a		arg1
	desc9a		arg2

	return		tnc

less_e1:
	unless_optype	(variable,array_ref,temp),not_scalar

	swap		arg1
	unless_optype	constant,invalid_opnd
"				Operands remain swapped.
	dt_jump1		arg2,(less_hi,less_hr,less_hd,less_hc,logical_op1,less_hh,less_ht)

less_hi:
less_hr:
less_ht:
	pad_char_const_to_word	arg2

	load		a,arg2
	cmpa		arg1
	return		tnc

less_hd:
less_hc:
	pad_char_const_to_dw	arg2

	load		aq,arg2
	cmpaq		arg1
	return		tnc

less_tl:
	unless_dt		(int,typeless),typeless_op1
	dt_jump1		op2,(less_tl.1,typeless_op2,typeless_op2,typeless_op2,typeless_op2,typeless_op2,less_tl.1)

less_tl.1:
	if_eaq		tq,arg2,less_tl.2

	load		tq,arg1
	compare		tq,arg2
	return		tmi

less_tl.2:
	compare		tq,arg1
	return		tpnz


less_or_equal:
	func		2

	refresh_regs_if_next_is_jump

	dt_jump		(less_or_equal_ii,less_or_equal_ri,less_or_equal_di,less_or_equal_ci,less_or_equal_ir,less_or_equal_rr,less_or_equal_dr,less_or_equal_cr,less_or_equal_id,less_or_equal_rd,less_or_equal_dd,less_or_equal_cd,less_or_equal_ic,less_or_equal_rc,less_or_equal_dc,less_or_equal_cc,less_or_equal_e2,less_or_equal_e1,less_or_equal_tl,less_or_equal_tl)

less_or_equal_ii:
	note_eligible_ind_var_use
	if_global_ind_var	arg1,less_or_equal_ii.global
	if_global_ind_var	arg2,less_or_equal_ii.global.1

	if_eaq		q,arg2,less_or_equal_ii.1

	load		q,arg1
	compare		q,arg2
	return		tmoz

less_or_equal_ii.1:
	compare		q,arg1
	return		tpl

less_or_equal_ii.global:
	compare_index
	if_fb17		arg1,less_or_equal_ii.global.fb17
	return		j_le_s
less_or_equal_ii.global.fb17:
	return		tmoz

less_or_equal_ii.global.1:
	swap		arg1
	compare_index
	if_fb17		arg1,less_or_equal_ii.global.1.fb17
	return		trc
less_or_equal_ii.global.1.fb17:
	return		tpl

less_or_equal_ir:
	swap		arg1

	s_call		cv_load.ir
	compare		eaq,arg1
	return		tmoz

less_or_equal_ri:
	s_call		cv_load.ir
	compare		eaq,arg1
	return		tpl

less_or_equal_id:
	swap		arg1

	s_call		cv_load.id
	compare		deaq,arg1
	return		tmoz

less_or_equal_di:
	s_call		cv_load.id
	compare		deaq,arg1
	return		tpl

less_or_equal_rr:
	if_eaq		eaq,arg2,less_or_equal_rr.1

	load		eaq,arg1
	compare		eaq,arg2
	return		tmoz

less_or_equal_rr.1:
	compare		eaq,arg1
	return		tpl

less_or_equal_dd:
	if_eaq		deaq,arg2,less_or_equal_dd.1

	load		deaq,arg1
	compare		deaq,arg2
	return		tmoz

less_or_equal_dd.1:
	compare		deaq,arg1
	return		tpl

less_or_equal_rd:
	if_eaq		deaq,arg2,less_or_equal_rd.1

	load		eaq,arg1
	compare		deaq,arg2
	return		tmoz

less_or_equal_rd.1:
	compare		eaq,arg1
	return		tpl

less_or_equal_dr:
	if_eaq		eaq,arg2,less_or_equal_dr.1

	load		deaq,arg1
	compare		eaq,arg2
	return		tmoz

less_or_equal_dr.1:
	compare		deaq,arg1
	return		tpl

less_or_equal_ic:
	error		323,arg2

less_or_equal_ci:
	error		323,arg1

less_or_equal_rc:
	error		323,arg2

less_or_equal_cr:
	error		323,arg1

less_or_equal_dc:
	error		312,arg1,arg2

less_or_equal_cd:
	error		311,arg1,arg2

less_or_equal_cc:
	error		328,arg1,arg2

less_or_equal_e2:
	if_dt		logical,logical_op1
	dt_jump1		arg1,(less_or_equal_ih,less_or_equal_rh,less_or_equal_dh,less_or_equal_ch,logical_op2,less_or_equal_hh,less_or_equal_th)

less_or_equal_ih:
less_or_equal_rh:
less_or_equal_th:
	unless_optype	constant,invalid_opnd

	swap		arg1
	unless_optype	(variable,array_ref,temp),not_scalar

	pad_char_const_to_word	arg1	" the two operands remain swapped

	load		a,arg1
	cmpa		arg2
	return		trc

less_or_equal_dh:
less_or_equal_ch:
	unless_optype	constant,invalid_opnd

	swap		arg1
	unless_optype	(variable,array_ref,temp),not_scalar

	pad_char_const_to_dw	arg1	" the two operands remain swapped

	load		aq,arg1
	cmpaq		arg2
	return		trc

less_or_equal_hh:
	use_eaq

	emit_eis
	cmpc		(pr),(pr),fill(040)
	desc9a		arg2
	desc9a		arg1

	return		trc

less_or_equal_e1:
	unless_optype	(variable,array_ref,temp),not_scalar

	swap		arg1
	unless_optype	constant,invalid_opnd
"				Operands remain swapped.
	dt_jump1		arg2,(less_or_equal_hi,less_or_equal_hr,less_or_equal_hd,less_or_equal_hc,logical_op1,less_or_equal_hh,less_or_equal_ht)

less_or_equal_hi:
less_or_equal_hr:
less_or_equal_ht:
	pad_char_const_to_word	arg2

	load		a,arg1
	cmpa		arg2
	return		trc

less_or_equal_hd:
less_or_equal_hc:
	pad_char_const_to_dw	arg2

	load		aq,arg1
	cmpaq		arg2
	return		trc

less_or_equal_tl:
	unless_dt		(int,typeless),typeless_op1
	dt_jump1		op2,(less_or_equal_tl.1,typeless_op2,typeless_op2,typeless_op2,typeless_op2,typeless_op2,less_or_equal_tl.1)

less_or_equal_tl.1:
	if_eaq		tq,arg2,less_or_equal_tl.2

	load		tq,arg1
	compare		tq,arg2
	return		tmoz

less_or_equal_tl.2:
	compare		tq,arg1
	return		tpl

equal:	func		2

	refresh_regs_if_next_is_jump

	dt_jump		(equal_ii,equal_ri,equal_di,equal_ci,equal_ir,equal_rr,equal_dr,equal_cr,equal_id,equal_rd,equal_dd,equal_cd,equal_ic,equal_rc,equal_dc,equal_cc,equal_e2,equal_e1,equal_tl,equal_tl)

equal_ii:
	note_eligible_ind_var_use
	if_global_ind_var	arg1,equal_ii.global
	if_global_ind_var	arg2,equal_ii.global.1

	load_top		q
	compare		q,arg1
	return		tze

equal_ii.global.1:
	swap		arg1

equal_ii.global:
	compare_index
	return		tze

equal_ir:
	swap		arg1

equal_ri:
	s_call		cv_load.ir
	compare		eaq,arg1
	return		tze

equal_id:
	swap		arg1

equal_di:
	s_call		cv_load.id
	compare		deaq,arg1
	return		tze

equal_rr:
	load_top		eaq
	compare		eaq,arg1
	return		tze

equal_dd:
	load_top		deaq
	compare		deaq,arg1
	return		tze

equal_rd:
	swap		arg1

equal_dr:
	if_eaq		eaq,arg2,equal_dr.1

	load		deaq,arg1
	compare		eaq,arg2
	return		tze

equal_dr.1:
	compare		deaq,arg1
	return		tze

equal_ic:
	error		323,arg2

equal_ci:
	error		323,arg1

equal_rc:
	error		323,arg2

equal_cr:
	error		323,arg1

equal_dc:
	error		312,arg1,arg2

equal_cd:
	error		311,arg1,arg2

equal_cc:
	load_top		aq
	cmpaq		arg1
	return		tze

equal_e2:
	if_dt		char,equal_ah
	swap		arg1	" top is logical, so swap and test

	if_dt		logical,equal_ll
	error		313,op1

equal_ll:
	load_top		a
	compare		a,arg1
	return		tze

equal_ah:
	dt_jump1		arg1,(equal_ih,equal_rh,equal_dh,equal_ch,logical_op2,equal_hh,equal_th)

equal_ih:
equal_rh:
equal_th:
	unless_optype	constant,invalid_opnd

	swap		arg1
	unless_optype	(variable,array_ref,temp),not_scalar

	pad_char_const_to_word	arg1	" the two operands remain swapped

	load_top		a
	cmpa		arg1
	return		tze

equal_dh:
equal_ch:
	unless_optype	constant,invalid_opnd

	swap		arg1
	unless_optype	(variable,array_ref,temp),not_scalar

	pad_char_const_to_dw	arg1	" the two operands remain swapped

	load_top		aq
	cmpaq		arg1
	return		tze

equal_hh:
	use_eaq

	emit_eis
	cmpc		(pr),(pr),fill(040)
	desc9a		arg1
	desc9a		arg2

	return		tze

equal_e1:
	unless_optype	(variable,array_ref,temp),not_scalar

	swap		arg1
	unless_optype	constant,invalid_opnd
"				Operands remain swapped.
	dt_jump1		arg2,(equal_hi,equal_hr,equal_hd,equal_hc,logical_op1,equal_hh,equal_ht)

equal_hi:
equal_hr:
equal_ht:
	pad_char_const_to_word	arg2

	load_top		a
	cmpa		arg1
	return		tze

equal_hd:
equal_hc:
	pad_char_const_to_dw	arg2

	load_top		aq
	cmpaq		arg1
	return		tze

equal_tl:
	unless_dt		(int,typeless),typeless_op1
	dt_jump1		op2,(equal_tl.1,typeless_op2,typeless_op2,typeless_op2,typeless_op2,typeless_op2,equal_tl.1)

equal_tl.1:
	load_top		tq
	compare		tq,arg1
	return		tze

not_equal:
	func		2

	refresh_regs_if_next_is_jump

	dt_jump		(not_equal_ii,not_equal_ri,not_equal_di,not_equal_ci,not_equal_ir,not_equal_rr,not_equal_dr,not_equal_cr,not_equal_id,not_equal_rd,not_equal_dd,not_equal_cd,not_equal_ic,not_equal_rc,not_equal_dc,not_equal_cc,not_equal_e2,not_equal_e1,not_equal_tl,not_equal_tl)

not_equal_ii:
	note_eligible_ind_var_use
	if_global_ind_var	arg1,not_equal_ii.global
	if_global_ind_var	arg2,not_equal_ii.global.1

	load_top		q
	compare		q,arg1
	return		tnz

not_equal_ii.global.1:
	swap		arg1

not_equal_ii.global:
	compare_index
	return		tnz

not_equal_ir:
	swap		arg1

not_equal_ri:
	s_call		cv_load.ir
	compare		eaq,arg1
	return		tnz

not_equal_id:
	swap		arg1

not_equal_di:
	s_call		cv_load.id
	compare		deaq,arg1
	return		tnz

not_equal_rr:
	load_top		eaq
	compare		eaq,arg1
	return		tnz

not_equal_dd:
	load_top		deaq
	compare		deaq,arg1
	return		tnz

not_equal_rd:
	swap		arg1

not_equal_dr:
	if_eaq		eaq,arg2,not_equal_dr.1

	load		deaq,arg1
	compare		eaq,arg2
	return		tnz

not_equal_dr.1:
	compare		deaq,arg1
	return		tnz

not_equal_ic:
	error		323,arg2

not_equal_ci:
	error		323,arg1

not_equal_rc:
	error		323,arg2

not_equal_cr:
	error		323,arg1

not_equal_dc:
	error		312,arg1,arg2

not_equal_cd:
	error		311,arg1,arg2

not_equal_cc:
	load_top		aq
	cmpaq		arg1
	return		tnz

not_equal_e2:
	if_dt		char,not_equal_ah
	swap		arg1	" top is logical, so swap and test other

	if_dt		logical,not_equal_ll
	error		313,op1

not_equal_ll:
	load_top		a
	compare		a,arg1
	return		tnz

not_equal_ah:
	dt_jump1		arg1,(not_equal_ih,not_equal_rh,not_equal_dh,not_equal_ch,logical_op2,not_equal_hh,not_equal_th)

not_equal_ih:
not_equal_rh:
not_equal_th:
	unless_optype	constant,invalid_opnd

	swap		arg1
	unless_optype	(variable,array_ref,temp),not_scalar

	pad_char_const_to_word	arg1	" the two operands remain swapped

	load_top		a
	cmpa		arg1
	return		tnz

not_equal_dh:
not_equal_ch:
	unless_optype	constant,invalid_opnd

	swap		arg1
	unless_optype	(variable,array_ref,temp),not_scalar

	pad_char_const_to_dw	arg1	" the two operands remain swapped

	load_top		aq
	cmpaq		arg1
	return		tnz

not_equal_hh:
	use_eaq

	emit_eis
	cmpc		(pr),(pr),fill(040)
	desc9a		arg1
	desc9a		arg2

	return		tnz

not_equal_e1:
	unless_optype	(variable,array_ref,temp),not_scalar

	swap		arg1
	unless_optype	constant,invalid_opnd
"				Operands remain swapped.
	dt_jump1		arg2,(not_equal_hi,not_equal_hr,not_equal_hd,not_equal_hc,logical_op1,not_equal_hh,not_equal_ht)

not_equal_hi:
not_equal_hr:
not_equal_ht:
	pad_char_const_to_word	arg2

	load_top		a
	cmpa		arg1
	return		tnz

not_equal_hd:
not_equal_hc:
	pad_char_const_to_dw	arg2

	load_top		aq
	cmpaq		arg1
	return		tnz

not_equal_tl:
	unless_dt		(int,typeless),typeless_op1
	dt_jump1		op2,(not_equal_tl.1,typeless_op2,typeless_op2,typeless_op2,typeless_op2,typeless_op2,not_equal_tl.1)

not_equal_tl.1:
	load_top		tq
	compare		tq,arg1
	return		tnz

greater_or_equal:
	func		2

	refresh_regs_if_next_is_jump

	dt_jump		(greater_or_equal_ii,greater_or_equal_ri,greater_or_equal_di,greater_or_equal_ci,greater_or_equal_ir,greater_or_equal_rr,greater_or_equal_dr,greater_or_equal_cr,greater_or_equal_id,greater_or_equal_rd,greater_or_equal_dd,greater_or_equal_cd,greater_or_equal_ic,greater_or_equal_rc,greater_or_equal_dc,greater_or_equal_cc,greater_or_equal_e2,greater_or_equal_e1,greater_or_equal_tl,greater_or_equal_tl)

greater_or_equal_ii:
	note_eligible_ind_var_use
	if_global_ind_var	arg1,greater_or_equal_ii.global
	if_global_ind_var	arg2,greater_or_equal_ii.global.1

	if_eaq		q,arg2,greater_or_equal_ii.1

	load		q,arg1
	compare		q,arg2
	return		tpl

greater_or_equal_ii.1:
	compare		q,arg1
	return		tmoz

greater_or_equal_ii.global:
	compare_index
	if_fb17		arg1,greater_or_equal_ii.global.fb17
	return		trc
greater_or_equal_ii.global.fb17:
	return		tpl

greater_or_equal_ii.global.1:
	swap		arg1
	compare_index
	if_fb17		arg1,greater_or_equal_ii.glob.1.fb17
	return		j_le_s
greater_or_equal_ii.glob.1.fb17:	"ALM won't handle symbols longer than 32 chars
	return		tmoz

greater_or_equal_ir:
	swap		arg1

	s_call		cv_load.ir
	compare		eaq,arg1
	return		tpl

greater_or_equal_ri:
	s_call		cv_load.ir
	compare		eaq,arg1
	return		tmoz

greater_or_equal_id:
	swap		arg1

	s_call		cv_load.id
	compare		deaq,arg1
	return		tpl

greater_or_equal_di:
	s_call		cv_load.id
	compare		deaq,arg1
	return		tmoz

greater_or_equal_rr:
	if_eaq		eaq,arg2,greater_or_equal_rr.1

	load		eaq,arg1
	compare		eaq,arg2
	return		tpl

greater_or_equal_rr.1:
	compare		eaq,arg1
	return		tmoz

greater_or_equal_dd:
	if_eaq		deaq,arg2,greater_or_equal_dd.1

	load		deaq,arg1
	compare		deaq,arg2
	return		tpl

greater_or_equal_dd.1:
	compare		deaq,arg1
	return		tmoz

greater_or_equal_rd:
	if_eaq		deaq,arg2,greater_or_equal_rd.1

	load		eaq,arg1
	compare		deaq,arg2
	return		tpl

greater_or_equal_rd.1:
	compare		eaq,arg1
	return		tmoz

greater_or_equal_dr:
	if_eaq		eaq,arg2,greater_or_equal_dr.1

	load		deaq,arg1
	compare		eaq,arg2
	return		tpl

greater_or_equal_dr.1:
	compare		deaq,arg1
	return		tmoz

greater_or_equal_ic:
	error		323,arg2

greater_or_equal_ci:
	error		323,arg1

greater_or_equal_rc:
	error		323,arg2

greater_or_equal_cr:
	error		323,arg1

greater_or_equal_dc:
	error		312,arg1,arg2

greater_or_equal_cd:
	error		311,arg1,arg2

greater_or_equal_cc:
	error		328,arg1,arg2

greater_or_equal_e2:
	if_dt		logical,logical_op1
	dt_jump1		arg1,(greater_or_equal_ih,greater_or_equal_rh,greater_or_equal_dh,greater_or_equal_ch,logical_op2,greater_or_equal_hh,greater_or_equal_th)

greater_or_equal_ih:
greater_or_equal_rh:
greater_or_equal_th:
	unless_optype	constant,invalid_opnd

	swap		arg1
	unless_optype	(variable,array_ref,temp),not_scalar

	pad_char_const_to_word	arg1	" the two operands remain swapped

	load		a,arg2
	cmpa		arg1
	return		trc

greater_or_equal_dh:
greater_or_equal_ch:
	unless_optype	constant,invalid_opnd

	swap		arg1
	unless_optype	(variable,array_ref,temp),not_scalar

	pad_char_const_to_dw	arg1	" the two operands remain swapped

	load		aq,arg2
	cmpaq		arg1
	return		trc

greater_or_equal_hh:
	use_eaq

	emit_eis
	cmpc		(pr),(pr),fill(040)
	desc9a		arg1
	desc9a		arg2

	return		trc

greater_or_equal_e1:
	unless_optype	(variable,array_ref,temp),not_scalar

	swap		arg1
	unless_optype	constant,invalid_opnd
"				Operands remain swapped.
	dt_jump1		arg2,(greater_or_equal_hi,greater_or_equal_hr,greater_or_equal_hd,greater_or_equal_hc,logical_op1,greater_or_equal_hh,greater_or_equal_ht)

greater_or_equal_hi:
greater_or_equal_hr:
greater_or_equal_ht:
	pad_char_const_to_word	arg2

	load		a,arg2
	cmpa		arg1
	return		trc

greater_or_equal_hd:
greater_or_equal_hc:
	pad_char_const_to_dw	arg2

	load		aq,arg2
	cmpaq		arg1
	return		trc

greater_or_equal_tl:
	unless_dt		(int,typeless),typeless_op1
	dt_jump1		op2,(greater_or_equal_tl.1,typeless_op2,typeless_op2,typeless_op2,typeless_op2,typeless_op2,greater_or_equal_tl.1)

greater_or_equal_tl.1:
	if_eaq		tq,arg2,greater_or_equal_tl.2

	load		tq,arg1
	compare		tq,arg2
	return		tpl

greater_or_equal_tl.2:
	compare		tq,arg1
	return		tmoz

greater:	func		2

	refresh_regs_if_next_is_jump

	dt_jump		(greater_ii,greater_ri,greater_di,greater_ci,greater_ir,greater_rr,greater_dr,greater_cr,greater_id,greater_rd,greater_dd,greater_cd,greater_ic,greater_rc,greater_dc,greater_cc,greater_e2,greater_e1,greater_tl,greater_tl)

greater_ii:
	note_eligible_ind_var_use
	if_global_ind_var	arg1,greater_ii.global
	if_global_ind_var	arg2,greater_ii.global.1

	if_eaq		q,arg2,greater_ii.1

	load		q,arg1
	compare		q,arg2
	return		tpnz

greater_ii.1:
	compare		q,arg1
	return		tmi

greater_ii.global:
	compare_index
	if_fb17		arg1,greater_ii.global.fb17
	return		j_g_s
greater_ii.global.fb17:
	return		tpnz

greater_ii.global.1:
	swap		arg1
	compare_index
	if_fb17		arg1,greater_ii.global.1.fb17
	return		tnc
greater_ii.global.1.fb17:
	return		tmi

greater_ir:
	swap		arg1

	s_call		cv_load.ir
	compare		eaq,arg1
	return		tpnz

greater_ri:
	s_call		cv_load.ir
	compare		eaq,arg1
	return		tmi

greater_id:
	swap		arg1

	s_call		cv_load.id
	compare		deaq,arg1
	return		tpnz

greater_di:
	s_call		cv_load.id
	compare		deaq,arg1
	return		tmi

greater_rr:
	if_eaq		eaq,arg2,greater_rr.1

	load		eaq,arg1
	compare		eaq,arg2
	return		tpnz

greater_rr.1:
	compare		eaq,arg1
	return		tmi

greater_dd:
	if_eaq		deaq,arg2,greater_dd.1

	load		deaq,arg1
	compare		deaq,arg2
	return		tpnz

greater_dd.1:
	compare		deaq,arg1
	return		tmi

greater_rd:
	if_eaq		deaq,arg2,greater_rd.1

	load		eaq,arg1
	compare		deaq,arg2
	return		tpnz

greater_rd.1:
	compare		eaq,arg1
	return		tmi

greater_dr:
	if_eaq		eaq,arg2,greater_dr.1

	load		deaq,arg1
	compare		eaq,arg2
	return		tpnz

greater_dr.1:
	compare		deaq,arg1
	return		tmi

greater_ic:
	error		323,arg2

greater_ci:
	error		323,arg1

greater_rc:
	error		323,arg2

greater_cr:
	error		323,arg1

greater_dc:
	error		312,arg1,arg2

greater_cd:
	error		311,arg1,arg2

greater_cc:
	error		328,arg1,arg2

greater_e2:
	if_dt		logical,logical_op1
	dt_jump1		arg1,(greater_ih,greater_rh,greater_dh,greater_ch,logical_op2,greater_hh,greater_th)

greater_ih:
greater_rh:
greater_th:
	unless_optype	constant,invalid_opnd

	swap		arg1
	unless_optype	(variable,array_ref,temp),not_scalar

	pad_char_const_to_word	arg1	" the two operands remain swapped

	load		a,arg1
	cmpa		arg2
	return		tnc

greater_dh:
greater_ch:
	unless_optype	constant,invalid_opnd

	swap		arg1
	unless_optype	(variable,array_ref,temp),not_scalar

	pad_char_const_to_dw	arg1	" the two operands remain swapped

	load		aq,arg1
	cmpaq		arg2
	return		tnc

greater_hh:
	use_eaq

	emit_eis
	cmpc		(pr),(pr),fill(040)
	desc9a		arg2
	desc9a		arg1

	return		tnc

greater_e1:
	unless_optype	(variable,array_ref,temp),not_scalar

	swap		arg1
	unless_optype	constant,invalid_opnd
"				Operands remain swapped.
	dt_jump1		arg2,(greater_hi,greater_hr,greater_hd,greater_hc,logical_op1,greater_hh,greater_ht)

greater_hi:
greater_hr:
greater_ht:
	pad_char_const_to_word	arg2

	load		a,arg1
	cmpa		arg2
	return		tnc

greater_hd:
greater_hc:
	pad_char_const_to_dw	arg2

	load		aq,arg1
	cmpaq		arg2
	return		tnc

greater_tl:
	unless_dt		(int,typeless),typeless_op1
	dt_jump1		op2,(greater_tl.1,typeless_op2,typeless_op2,typeless_op2,typeless_op2,typeless_op2,greater_tl.1)

greater_tl.1:
	if_eaq		tq,arg2,greater_tl.2

	load		tq,arg1
	compare		tq,arg2
	return		tpnz

greater_tl.2:
	compare		tq,arg1
	return		tmi

or:	func		2

	unless_dt		logical,or_e2
	swap		arg1
	unless_dt		logical,or_e1

	load_top		a
	ora		arg1
	return		a

or_e1:
	error		313,arg1

or_e2:
	error		313,arg2

and:	func		2

	unless_dt		logical,and_e2
	swap		arg1
	unless_dt		logical,and_e1

	load_top		a
	ana		arg1
	return		a

and_e1:
	error		313,arg1

and_e2:
	error		313,arg2

not:	func		1

	unless_dt		logical,not.e

	if_eaq		ind,op1,not_ind

	load		a,op1
	era		=o400000,du
	return		a

not_ind:
	ind_jump		(not_tze,not_tnz,not_tmi,not_tpl,not_tmoz,not_tpnz,not_tnc,not_trc,not_j_le_s,not_j_g_s)

not_tze:
	return		tnz

not_tnz:
	return		tze

not_tmi:
	return		tpl

not_tpl:
	return		tmi

not_tmoz:
	return		tpnz

not_tpnz:
	return		tmoz

not_tnc:
	return		trc

not_trc:
	return		tnc

not_j_le_s:
	return		j_g_s

not_j_g_s:
	return		j_le_s

not.e:
	error		313,op1

equiv:	func		2

	unless_dt		logical,equiv.p
	swap		arg1
	unless_dt		logical,equiv.p

	refresh_regs_if_next_is_jump

	load_top		a
	compare		a,arg1
	return		tze


not_equiv:
	func		2

	unless_dt		logical,not_equiv.p
	swap		arg1
	unless_dt		logical,not_equiv.p

	refresh_regs_if_next_is_jump

	load_top		a
	compare		a,arg1
	return		tnz


equiv.p:
not_equiv.p:
	error		313,op1

jump:	proc		1

	if_next_statement	arg1,jump_is_nop
	shorten_stack
	refresh_regs
	save_state	arg1,discard
	tra		arg1

jump_is_nop:
	return

jump_false:
	proc		2

	swap		op2

	unless_dt		logical,jump_false.p

	if_optype		constant,jump_false_const
	if_eaq		ind,op1,jump_false_ind

	shorten_stack
	refresh_regs

	load_for_test	a,op1

jump_false_using_a:
	save_state	arg1
	tze		arg1
	return

jump_false_const:
	unless_zero	op1,jump_false_is_nop

	shorten_stack
	refresh_regs
	save_state	arg1
	tra		arg1

jump_false_is_nop:
	return

jump_false_ind:
	unless_optype	temp,jump_false_using_ind " not a temp, so only used once
	push_ref_count	arg2		" if value is to be used again, put it in A
	unless		op1,>,0,jump_false_using_ind " last ref so dont change it
	ind_to_a				" forces value to A
	shorten_stack	protect_indicators
	refresh_regs	protect_indicators
	jump		jump_false_using_a

jump_false_using_ind:
	shorten_stack	protect_indicators
	refresh_regs	protect_indicators
	save_state	arg1

	ind_jump		(jump_false_tze,jump_false_tnz,jump_false_tmi,jump_false_tpl,jump_false_tmoz,jump_false_tpnz,jump_false_tnc,jump_false_trc,jump_false_j_le_s,jump_false_j_g_s)

jump_false_tze:
	tnz		arg1
	return

jump_false_tnz:
	tze		arg1
	return

jump_false_tmi:
	tpl		arg1
	return

jump_false_tpl:
	tmi		arg1
	return

jump_false_tmoz:
	tpnz		arg1
	return

jump_false_tpnz:
	tmoz		arg1
	return

jump_false_tnc:
	trc		arg1
	return

jump_false_trc:
	tnc		arg1
	return

jump_false_j_le_s:
	tze		2,ic
	trc		arg1
	return

jump_false_j_g_s:
	tnc		arg1
	tze		arg1
	return

jump_false.p:
	print		324,op1
	return



jump_true:
	proc		2

	swap		op2

	unless_dt		logical,jump_false.p

	if_optype		constant,jump_true_const
	if_eaq		ind,op1,jump_true_ind

	shorten_stack
	refresh_regs

	load_for_test	a,op1

jump_true_using_a:
	save_state	arg1
	tnz		arg1
	return

jump_true_const:
	if_zero		op1,jump_true_is_nop

	shorten_stack
	refresh_regs
	save_state	arg1
	tra		arg1

jump_true_is_nop:
	return

jump_true_ind:
	unless_optype	temp,jump_true_using_ind " not a temp, so only used once
	push_ref_count	arg2		" if value is to be used again, put it in A
	unless		op1,>,0,jump_true_using_ind " last ref so dont change it
	ind_to_a				" forces value to A
	shorten_stack	protect_indicators
	refresh_regs	protect_indicators
	jump		jump_true_using_a

jump_true_using_ind:
	shorten_stack	protect_indicators
	refresh_regs	protect_indicators
	save_state	arg1
	ind_jump		(jump_false_tnz,jump_false_tze,jump_false_tpl,jump_false_tmi,jump_false_tpnz,jump_false_tmoz,jump_false_trc,jump_false_tnc,jump_false_j_g_s,jump_false_j_le_s)

jump_arithmetic:
	proc		4

	shorten_stack
	refresh_regs

	swap	arg1	" optimize for consants
	if_optype	constant,jump_arith_const
	swap	arg1
	
	dt_jump1		arg1,(jump_arithmetic_i,jump_arithmetic_r,jump_arithmetic_d,jump_arithmetic.e,jump_arithmetic.e,jump_arithmetic.e,jump_arithmetic.e)

jump_arithmetic_d:
	unless_eaq	deaq,arg1,jump_arithmetic_r.1
	if_ind		deaq,jump_arithmetic.01
	fcmp		=0.0,du
	set_inds_valid	deaq
	jump		jump_arithmetic.01

jump_arithmetic_i:
	unless_global_ind_var	arg1,jump_arithmetic_i.check_eaq
	test_index
	jump		jump_arithmetic.01

jump_arithmetic_i.check_eaq:
	unless_eaq	q,arg1,jump_arithmetic_i.1
	if_ind		q,jump_arithmetic.01
	cmpq		0,dl
	set_inds_valid	q
	jump		jump_arithmetic.01

jump_arithmetic_i.1:
	szn		arg1
	jump		jump_arithmetic.01

jump_arithmetic_r:

	unless_eaq	eaq,arg1,jump_arithmetic_r.1
	if_ind		eaq,jump_arithmetic.01
	fcmp		=0.0,du
	set_inds_valid	eaq
	jump		jump_arithmetic.01

jump_arithmetic_r.1:
	use_ind
	use_eaq			" so we dont have to invent use_eaq protect_indicators
	fszn		arg1

jump_arithmetic.01:
	swap		arg3			" order is now 1 3 2
	if		arg2,=,op1,jump_arith_12	" 1 & 2 are the same label
	swap		arg3			" order is now 1 2 3
	if		arg2,=,op1,jump_arith_13	" 1 & 3 are the same label
	if		arg3,=,op1,jump_arith_23	" 2 & 3 are the same label

"				All labels are different
"
	if_next_statement	arg2,jump_arith_1next	" 1st label is next statement
	if_next_statement	arg3,jump_arith_2next	" 2nd label is next statement
	if_next_statement	arg4,jump_arith_3next	" 3rd label is next statement

	save_state	arg2			" all labels are different and none
	tmi		arg2			" is next statement
	save_state	arg3
	tze		arg3

jump_arith_all:					" all labels are the same but not
	save_state	arg4,discard		" the next statement
	tra		arg4
	return

jump_arith_1next:					" all labels are different and 1st
	save_state	arg3			" is next statement
	tze		arg3

jump_arith_to3:					" 1 & 2 are the next statement, but
	save_state	arg4			" 3 is not
	tpnz		arg4
	return

jump_arith_2next:					" all labels are different and 2nd
	save_state	arg4			" is next_statement
	tpnz		arg4

jump_arith_to1:					" 2 & 3 are the next statement, but
	save_state	arg2			" 1 is not
	tmi		arg2
	return

jump_arith_3next:					" all labels are different and 3rd
	save_state	arg2			" is next statement
	tmi		arg2

jump_arith_to2:					" 1 & 3 are the next statement, but
	save_state	arg3			" 2 is not
	tze		arg3
	return

jump_arith_12:					" order is now 1 3 2
	swap		arg3			" restore order to 1 2 3
	unless		arg2,=,op1,jump_arith_12.c	" compare 1 and 3
	unless_next_statement	arg2,jump_arith_all
	return					" all jump to next statement

jump_arith_12.c:
	if_next_statement	arg2,jump_arith_to3

	save_state	arg2
	tmoz		arg2
	unless_next_statement	arg4,jump_arith_all
	return

jump_arith_13:
	if_next_statement	arg2,jump_arith_to2

	save_state	arg2
	tnz		arg2
	if_next_statement	arg3,jump_arith_return

	save_state	arg3,discard
	tra		arg3
	return

jump_arith_23:
	if_next_statement	arg3,jump_arith_to1

	save_state	arg3
	tpl		arg3

	if_next_statement	arg2,jump_arith_return

	save_state	arg2,discard
	tra		arg2
	return


jump_arith_const:
	if_zero		op1,jump_arith_const2
	if_negative	op1,jump_arith_const1
	swap		arg1
	if_next_statement	arg4,jump_arith_return
	tra		arg4		" simple transfer
	return

jump_arith_const1:
	swap		arg1
	if_next_statement	arg2,jump_arith_return
	tra		arg2
	return

jump_arith_const2:
	swap		arg1
	if_next_statement	arg3,jump_arith_return
	tra		arg3
	return
	
jump_arith_return:
	return

jump_arithmetic.e:
	error		325,op1

jump_computed:
	proc		1		" <count>
"					Rest of operands are: label list, expre

	shorten_stack
	refresh_regs

	if		arg1,<,1,jc_list.p

	push_label		" arg2 - label to skip goto, expre out-of-range
	push_label		" arg3 - address of transfer vector

jump_computed.get_operands:		" loop to pick up label list and jump expression
	push_operand	jump_computed.stack_ready
	jump		jump_computed.get_operands

jump_computed.stack_ready:		" <# lbls> <skip lbl> <vect lbl> <lbl list> <expre>
	dt_jump1		op1,(jump_computed_i,jump_computed_r,jump_computed_d,jump_computed_r,jump_computed.p,jump_computed.p,jump_computed.p)

jump_computed_i:
	load		q,op1
	jump		jc_transfer

jump_computed_r:
	s_call		cv_load.ri
	jump		jc_transfer

jump_computed_d:
	s_call		cv_load.di

jc_transfer:

	use_eaq		protect_indicators		" save all temps before transfer

	increment		arg1,1	" adjust count so that compare is against
"				   arg1+1 and so that loops exclude <count copy>

	compare		q,arg1

	pop		op1		" expre no longer needed

	copy		arg1	" <# lbls> <skip lbl> <vect lbl> <lbl list> <count>

jc_save_state:
	copy		op1
	copy		opv
	save_state	op1
	pop		op1
	decrement		op1,1		" arg1 is saved for the next loop
	if		op1,>,1,jc_save_state

	tnc		arg3
	force_ql			"forces last inst to be tnc  arg3,ql

	label		arg3	" define beginning of transfer vector
	tra		arg2	" first word in transfer vector

jc_labels:
	copy		arg1

	copy		opv
	tra		op1
	pop		op1

	decrement		arg1,1
	if		arg1,>,1,jc_labels

jc_ret:
	label		arg2	" define skip label after computed goto code
	return

jc_list.p:
	print		327

	jump		jc_ret

jump_computed.p:
	print		326,arg1
	return

jump_assigned:
	proc		1

	shorten_stack
	refresh_regs

	unless_dt		int,jump_assigned.e

	unless_array	jump_assigned.1

	print		300,op1

jump_assigned.1:
	use_eaq			" save all temps now

	ldx0		arg1

	tra		0,0
	discard_state
	return

jump_assigned.e:
	print		301,op1
	return

assign_label:
	proc		1

	push_output
	unless_dt		int,assign_label.e
	unless_array	assign_label.1

	print		300,op1

assign_label.1:
	swap		arg1
	if_optype		rel_constant,assign_label.2

	" The label is on a format statement.

	load_pr		pr2,arg2
	sprp2		arg1
	flush_ref		arg1
	free_regs
	return

	" The label is on an executable statement.

assign_label.2:
	eax0		arg2
	stx0		arg1
	flush_ref		arg1
	return

assign_label.e:
	print		301,op1
	return

read:	proc		2

	swap		arg1

	unless_dt		int,read.p

	swap		arg1
	load		q,arg1
	lda		arg2
	reserve_regs	(x6,pr1,pr2,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_read
	free_regs
	return

read.p:
	print		302,op1
	return

write:	proc		2

	swap		arg1

	unless_dt		int,write.p

	swap		arg1
	load		q,arg1
	lda		arg2
	reserve_regs	(x6,pr1,pr2,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_write
	free_regs
	return

write.p:
	print		302,op1
	return

format:	proc		1

	if_dt		char,format_c
	unless_dt		int,format.pp
	if_array		format_c

	" Must be an integer variable defined with a format value in an
	" ASSIGN statement.  The variable will contain a packed pointer
	" which locates the format string.

	reserve_regs	pr2
	lprp2		arg1
	push_builtin	ps
	spri2		op1+format_slot
	free_regs
	return

format.pp:
	error		329,arg1

format.pv:
	error		358,arg1

format_c:
	if_VLA		arg1,format.pv	" cannot be a Very Large Array
	load_pr		pr2,arg1
	push_builtin	ps
	spri2		op1+format_slot
	free_regs
	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

end_label:
	proc		1
	load_pr		pr5,arg1
	push_builtin	ps
	spri5		op1+end_label_slot
	free_regs
	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

error_label:
	proc		1

	load_pr		pr5,arg1
	push_builtin	ps
	spri5		op1+error_label_slot
	free_regs
	return

read_scalar:
	proc		0

	push_output
	flush_ref		arg1
	jump		scalar_common

write_scalar:
	proc		1

scalar_common:

	use_eaq

	bump		arg1
	load_pr		pr2,arg1

	dt_jump1		op1,(xs_i,xs_r,xs_d,xs_c,xs_l,xs_h,xs_t)

xs_i:
xs_t:
	lda		=1b18,du		=o400000
	jump		xs_transfer

xs_r:
	lda		=1b19,du		=o200000
	jump		xs_transfer

xs_d:
	lda		=1b20,du		=o100000
	jump		xs_transfer

xs_c:
	lda		=1b21,du		=o040000
	jump		xs_transfer

xs_l:
	lda		=1b22,du		=o020000
	jump		xs_transfer

xs_h:
	push_length	arg1

	bump		op1
	lda		op1

	emit_inst		1
	als		4

	ora		4096,du		=o010000

xs_transfer:
	reserve_regs	(x6,pr1,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_scalar_xmit
	free_regs
	drop		arg1
	return

read_array:
	proc		0

	push_output
	flush_ref		op1
	jump		array_common

write_array:
	proc		1

array_common:

	dt_jump1		op1,(xa_i,xa_r,xa_d,xa_c,xa_l,xa_h,xa_t)

xa_i:
xa_t:
	if_VLA		op1,xa_i_VLA
	lda		=65b24,du		=o404000
	jump		xa_transfer

xa_i_VLA:
	lda		=o406000,du
	jump		xa_transfer

xa_r:
	if_VLA		op1,xa_r_VLA
	lda		=33b24,du		=o204000
	jump		xa_transfer

xa_r_VLA:
	lda		=o206000,du
	jump		xa_transfer

xa_d:
	if_VLA		op1,xa_d_VLA
	lda		=17b24,du		=o104000
	jump		xa_transfer

xa_d_VLA:
	lda		=o106000,du
	jump		xa_transfer

xa_c:
	if_VLA		op1,xa_c_VLA
	lda		=9b24,du		=o044000
	jump		xa_transfer

xa_c_VLA:
	lda		=o046000,du
	jump		xa_transfer

xa_l:
	if_VLA		op1,xa_l_VLA
	lda		=5b24,du		=o024000
	jump		xa_transfer

xa_l_VLA:
	lda		=o026000,du
	jump		xa_transfer

xa_h:
	push_length	arg1

	bump		op1
	lda		op1

	emit_inst		1
	als		4

	ora		6144,du		=o014000

xa_transfer:
	push_array_size	arg1
	bump		arg1
	load_pr		pr2,arg1
	ldq		op1

	reserve_regs	(x6,pr1,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_array_xmit
	free_regs
	drop		arg1
	return

read_vector:
	proc		1

	push_output
	flush_ref		op1
	swap		arg1		"make consistent with write_vector
	jump		vector_common

write_vector:
	proc		2

vector_common:
	bump		arg1

	load_pr		pr2,arg1

	load		q,arg2		" collapsed implied loop provides the count

	swap		arg1		"Note arguments remain swapped

	dt_jump1		op1,(xv_i,xv_r,xv_d,xv_c,xv_l,xv_h,xv_t)

xv_i:
xv_t:
	if_VLA		op1,xv_i_VLA
	lda		=65b24,du		=o404000
	jump		xv_transfer

xv_i_VLA:
	lda		=o406000,du
	jump		xv_transfer

xv_r:
	if_VLA		op1,xv_r_VLA
	lda		=33b24,du		=o204000
	jump		xv_transfer

xv_r_VLA:
	lda		=o206000,du
	jump		xv_transfer

xv_d:
	if_VLA		op1,xv_d_VLA
	lda		=17b24,du		=o104000
	jump		xv_transfer

xv_d_VLA:
	lda		=o106000,du
	jump		xv_transfer

xv_c:
	if_VLA		op1,xv_c_VLA
	lda		=9b24,du		=o044000
	jump		xv_transfer

xv_c_VLA:
	lda		=o046000,du
	jump		xv_transfer

xv_l:
	if_VLA		op1,xv_l_VLA
	lda		=5b24,du		=o024000
	jump		xv_transfer

xv_l_VLA:
	lda		=o026000,du
	jump		xv_transfer

xv_h:
	push_length	arg2

	bump		op1
	lda		op1

	emit_inst		1
	als		4

	ora		6144,du		=o014000
	pop		op1

xv_transfer:

	reserve_regs	(x6,pr1,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_array_xmit
	free_regs
	drop		op1
	return

endfile:	proc		2

	swap		arg1
	unless_dt		int,endfile.p

	load		q,arg2
	lda		arg1
	reserve_regs	(x6,pr1,pr2,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_manip
	free_regs
	return

endfile.p:
	print		302,op1
	return

rewind:	proc		2

	swap		arg1
	unless_dt		int,rewind.p

	load		q,arg2
	lda		arg1
	reserve_regs	(x6,pr1,pr2,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_manip
	free_regs
	return

rewind.p:
	print		302,op1
	return

backspace:
	proc		2

	swap		arg1
	unless_dt		int,backspace.p

	load		q,arg2
	lda		arg1
	reserve_regs	(x6,pr1,pr2,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_manip
	free_regs
	return

backspace.p:
	print		302,op1
	return

margin:	proc		2

	unless_dt		int,margin2.p
	swap		arg1
	unless_dt		int,margin1.p
	swap		arg1

	load		q,arg1
	push_builtin	ps
	lda		arg2
	sta		op1+margin_slot
	lda		=3b27,du		=o001400
	reserve_regs	(x6,pr1,pr2,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_manip
	free_regs
	return

margin1.p:
	print		302,op1
	return

margin2.p:
	print		331,op1
	return

openfile:	proc		3

	swap		arg1
	unless_dt		int,openfile1.p
	swap		arg1
	swap		arg2
	unless_dt		char,openfile2.p
	if_array		openfile2.p
	swap		arg2
	unless_dt		char,openfile3.p
	if_array		openfile3.p

	push_length	arg2
	push_builtin	ps
	load_pr		pr2,arg2
	spri2		op1+file_name_slot
	load_pr		pr2,arg3
	spri2		op1+file_type_slot
	lda		op2
	sta		op1+string_length_slot
	lda		=5b28,du		=o001200
	load		q,arg1
	reserve_regs	(x6,pr1,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_manip
	free_regs
	return

openfile1.p:
	print		302,op1
	return

openfile2.p:
	print		332,op1
	return

openfile3.p:
	print		333,op1
	return

open:
close:
	proc		4

"			arg1 - file number expre. must be integer
"			arg2 - job_bits const generated by compiler.
"			arg3 - open/close stmnt const generated by compiler.
"			arg4 - A count. Number of fields that follow. (This count is never used.
"				In fact, it is overwritten by the ps_area_ptr builtin.)
"			arg5 to argN - Pairs of values. They are processed top down and then
"				popped off the stack.
"			     op2 - A value. See individual field (below) for data type, etc.
"			     op1 - A count. Implementation defined index value for the field.

	use_eaq
	reserve_regs	(x6,pr1,pr2,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_get_area_ptr	" returns ptr in PS.buffer_p
	free_regs

"		Make the ps_area_ptr builtin arg4. Pop original arg4.

	pop		op1
	push_builtin	ps_area_ptr

	lda		arg3		" fields-specified bit string
	emit_inst		1
	eax1		0		" index value for fields-specified bit string

	load_pr_value	pr3,arg4		" load pr3
	tsx0		pr0|ftn_open_element

"		Note - This loop is order sensitive. As it processes a pair of values on the stack,
"			they are popped. The loop terminates when arg4 is the top of the stack.

open_loop:
	push_operand	open_return	" if no more, then done
	push_operand	open_loop.e	" if no more, then error

	jump_indexed	op1,(opencase1,opencase2,opencase3,opencase4,opencase5,opencase6,opencase7,opencase8,opencase9,opencase10,opencase11,opencase12,opencase13,opencase14)

opencase1:		" status
opencase2:		" io switch
opencase3:		" attach
opencase4:		" file
opencase5:		" mode
opencase6:		" access
opencase7:		" form
opencase13:		" blank
	swap		op2			" check data type
	unless_dt		char,open_loop1.p
	push_length	op1
	load_pr		pr2,op2			" point to string
	load_pr_value	pr3,arg4			" reloads pr3 only if necessary
	load		q,op1			" load string length
	eax1		op3			" load index value into xr

	tsx0		pr0|ftn_open_element
	free_regs
	pop		op3			" pop all three things
	jump		open_loop

opencase8:		" recl
	swap		op2			" check data type
	unless_dt		int,open_loop2.p

	load		q,op1			" load the value

	load_pr_value	pr3,arg4			" reloads pr3 only if necessary

	eax1		op2			" load index value into xr

	tsx0		pr0|ftn_open_element
	pop		op2			" pop value and index
	jump		open_loop

opencase9:		" binary
opencase10:		" prompt
opencase11:		" carriage
opencase12:		" defer
	swap		op2			" check data type

	unless_dt		logical,open_loop3.p

	load		a,op1

	load_pr_value	pr3,arg4			" reloads pr3 only if necessary

	eax1		op2			" load index value into xr

	tsx0		pr0|ftn_open_element
	pop		op2			" pop value and index
	jump		open_loop

opencase14:		" unit
	swap		op2
	swap		arg1
	pop		op2
	jump		open_loop

open_loop.e:
	print		349
	return

open_loop1.p:
	print		351,op1
	pop		op2
	jump		open_loop

open_loop2.p:
	print		352,op1
	pop		op2
	jump		open_loop

open_loop3.p:
	print		353,op1
	pop		op2
	jump		open_loop

open_return:
	swap		arg1			" get file number expre.
	unless_dt		int,open.p		" must be integer
	load		q,op1
	lda		arg2
	reserve_regs	(x6,pr1,pr2,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_manip
	free_regs
	return

open.p:
	print		302,op1
	return

inquire:
	proc		3

	" arg1 - job bits
	" arg2 - fields specified mask
	" arg3 - field count

	" First get pointer to work area.

	use_eaq
	reserve_regs	(x6,pr1,pr2,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_get_area_ptr
	free_regs

	pop		op1		" Pop field count
	push_builtin	ps_area_ptr	" This becomes arg3

	" Next emit fields-specified mask.

	lda		arg2		" The mask
	emit_inst		1
	eax1		0		" The field index

	load_pr_value	pr3,arg3		" Load pr3 with area pointer
	tsx0		pr0|ftn_inquire_element

	" Loop over the remaining operand pairs, of the form (datum, index).
	" As each pair is processed, it is popped from the stack.

inquire_loop:
	push_operand	inquire_return	" Done if no more opnds
	push_operand	inquire_loop.e	" Error if no more opnds

	jump_indexed	op1,(inquire_case_1,inquire_case_2,inquire_case_3,inquire_case_4,inquire_case_5,inquire_case_6,inquire_case_7,inquire_case_8,inquire_case_9,inquire_case_10,inquire_case_11,inquire_case_12,inquire_case_13,inquire_case_14,inquire_case_15,inquire_case_16,inquire_case_17,inquire_case_18,inquire_case_19,inquire_case_20,inquire_case_21,inquire_case_22,inquire_case_23,inquire_case_24,inquire_case_25,inquire_case_26)


inquire_case_4:		" file
inquire_case_6:		" access
inquire_case_7:		" form
inquire_case_13:		" blank
inquire_case_21:		" name
inquire_case_22:		" sequential
inquire_case_23:		" formatted
inquire_case_24:		" unformatted
inquire_case_26:		" direct

	" First check data type.

	swap		op2
	unless_dt		char,inquire_loop.not_char

	" Load pointer to string in pr2, length of string in Q.

	push_length	op1
	load_pr		pr2,op2
	load		q,op1

	load_pr_value	pr3,arg3		" Reload pr3 if necessary
	eax1		op3		" Load field index
	tsx0		pr0|ftn_inquire_element
	free_regs

	pop		op3		" Pop all three operands
	jump		inquire_loop


inquire_case_8:		" recl
inquire_case_19:		" number
inquire_case_25:		" nextrec

	" First check data type.

	swap		op2
	unless_dt		int,inquire_loop.not_int

	load_pr		pr2,op1		" Load pointer to datum

	load_pr_value	pr3,arg3		" Reload pr3 if necessary
	eax1		op2		" Load field index
	tsx0		pr0|ftn_inquire_element
	free_regs

	pop		op2		" Pop both operands
	jump		inquire_loop


inquire_case_14:		" unit

	" First check data type.

	swap		op2
	unless_dt		int,inquire_loop.not_int

	load		q,op1		" Load unit number in Q

	load_pr_value	pr3,arg3		" Reload pr3 if necessary
	eax1		op2		" Load field index
	tsx0		pr0|ftn_inquire_element

	pop		op2		" Pop both operands
	jump		inquire_loop


inquire_case_17:		" exist
inquire_case_18:		" opened
inquire_case_20:		" named

	" First check data type.

	swap		op2
	unless_dt		logical,inquire_loop.not_logical

	load_pr		pr2,op1		" Load pointer to datum

	load_pr_value	pr3,arg3		" Reload pr3 if necessary
	eax1		op2		" Load field index
	tsx0		pr0|ftn_inquire_element
	free_regs

	pop		op2		" Pop both operands
	jump		inquire_loop


inquire_case_1:		" Invalid inquire fields
inquire_case_2:
inquire_case_3:
inquire_case_5:
inquire_case_9:
inquire_case_10:
inquire_case_11:
inquire_case_12:
inquire_case_15:
inquire_case_16:
	print		357,op1
	return


inquire_loop.e:
	print		356
	return


inquire_loop.not_char:
	print		351,op1
	pop		op2
	jump		inquire_loop


inquire_loop.not_int:
	print		352,op1
	pop		op2
	jump		inquire_loop


inquire_loop.not_logical:
	print		353,op1
	pop		op2
	jump		inquire_loop


inquire_return:
	push_count	0		" Dummy unit number
	load		q,op1		" Get unit in Q
	lda		arg1		" Get job bits in A
	reserve_regs	(x6,pr1,pr2,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_manip
	free_regs
	return

closefile:
	proc		1

	unless_dt		int,closefile.p

	load		q,arg1
	lda		=3b28,du		=o000600
	reserve_regs	(x6,pr1,pr2,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_manip
	free_regs
	return

closefile.p:
	print		302,arg1
	return

iostat:
	proc		0

	push_output
	unless_dt		int,iostat.p

	push_builtin	ps
	load_pr		pr2,arg1
	spri2		op1+iostat_slot
	free_regs

	return

iostat.p:
	print		350,op1
	return

record_number:
	proc		1

	unless_dt		int,record_number.p

	load		q,arg1
	push_builtin	ps
	stq		op1+record_number_slot
	return

record_number.p:
	print		304,arg1
	return

encode_string:
	proc		0
	push_output
	jump		string_common

decode_string:
string:
	proc		1

string_common:
	unless_dt		logical,string_c

	print		305,arg1

string_c:
	load_pr		pr2,arg1
	push_builtin	ps
	spri2		op1+string_slot
	free_regs
	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

string_length:
	proc		1

	load		q,arg1
	push_builtin	ps
	stq		op1+string_length_slot
	return

write_internal_file:
	proc		0

	push_output
	jump		internal_file_common


read_internal_file:
	proc		1


internal_file_common:
	unless_dt		char,internal_file.p

	push_builtin	ps

	load_pr		pr2,arg1
	spri2		arg2+string_slot

	push_length	arg1
	bump		op1
	load		q,op1
	stq		arg2+string_length_slot
	pop		op1

	swap		arg1
	if_array		internal_file.array

	stz		arg1+buffer_size_slot
	jump		internal_file.ret

internal_file.array:
	push_array_size	op1
	load		q,op1
	stq		arg1+buffer_size_slot

internal_file.ret:
	free_regs
	return


internal_file.p:
	error		303

terminate:
	proc		0

	reserve_regs	(x6,pr1,pr2,pr3,pr4,pr5,pr7)
	tsx0		pr0|ftn_terminate
	free_regs
	return

return:	proc		0

	unless_main	quick_return

	tra	pr0|fortran_end

	discard_state
	return

quick_return:
	push_builtin entry_info

	rtcd		op1

	discard_state
	return

pause:	proc		1

	push_length	arg1
	if		op1,=,0,short_pause

	load_pr		pr2,arg1
	ldq		op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)

pause.1:
	tsx0		pr0|fortran_pause
	free_regs
	return

short_pause:
	ldq		op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr2,pr3,pr4,pr5,pr7)
	jump		pause.1

stop:	proc		1

	push_length	arg1
	if		op1,=,0,short_stop

	load_pr		pr2,arg1
	ldq		op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr3,pr4,pr5,pr7)

stop.1:
	tsx0		pr0|fortran_stop
	discard_state
	return

short_stop:
	ldq		op1
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr2,pr3,pr4,pr5,pr7)
	jump		stop.1

func_ref:	func		2

	s_call		evaluate_arglist

	push_output
	bump		op1
	set_in_storage	op1

	increment		arg2,1	function result becomes last arg

	unless_dt		char,func_join
	push_length	op1
	unless_optype	count,func_ref.star_extent
	pop		op1

	s_call		descriptor_check

func_join:

	s_call		make_call

	return		op2		arglist temp is now op1

func_ref.star_extent:
	error		355,arg1

main:	proc		2

	emit_entry_defs
	emit_data		1
	oct		000000300000	" revision_1, entry_defs

	s_call		make_entry
	s_call		prepare_for_namelists
	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

subr:	proc		2

	emit_entry_defs
	emit_data		1
	oct		000000300000	" revision_1, entry_defs

	s_call		make_entry
	s_call		make_quick_entry
	s_call		prepare_for_namelists
	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

func:	proc		2

	emit_entry_defs
	emit_data		1
	oct		000000320000	" revision_1, entry_defs, func

	s_call		make_entry
	s_call		make_quick_entry
	s_call		prepare_for_namelists
	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

block_data:
	proc		0

	return

make_entry:
	assign_entry	arg1

	emit_inst		1
	eax7		0

	epp2		pr7|stack_header.pl1_operators_ptr,*

	if_needs_descriptors arg1,make_et_desc
	tsp2		pr2|ext_entry
	jump		make_et_join

make_et_desc:
	tsp2		pr2|ext_entry_desc

make_et_join:
	copy		arg2
	multiply		op1,2
	zero		op1
	pop		op1

	emit_data		1
	zero

	emit_profile_entry		" if we will do long_profile set it up

	unless_hfp	make_et_init_auto
	tsx0		pr0|enter_HFP_mode

make_et_init_auto:
	call		init_auto

	unless_cleanup	make_et_no_cleanup	"no cleanup needed

	tsx0		pr0|fort_cleanup
	emit_cleanup_args

make_et_no_cleanup:
	push_builtin	null
	push_builtin	ps

	if		op2,=,op1,pop_ps

	load_pr		pr2,op1
	spri2		pr6|ps_ptr
	spri6		pr2|0
	free_regs

pop_ps:	pop		op2
	unless_storage_created make_et_descp		is there external storage?
	reserve_regs	all			calling external routines
	tsx0		pr0|fort_storage		request storage create/init
	emit_storage_args
	free_regs

make_et_descp:

	epp1		pr6|stack_frame.arg_ptr,*

	unless_needs_descriptors arg1,make_et_ret

	epp3		pr6|descriptor_ptr,*	Load desc ptr

make_et_ret:
	s_return

prepare_for_namelists:
	unless_namelist_used  pfn_ret

	push_builtin	star_symbol
	push_builtin	ps

	load_pr		pr2,op2
	spri2		op1+2

	set_runtime_block_loc

	adwp2		0,du
	spri2		op1+4

	free_regs
	pop		op2

pfn_ret:

	s_return

init_auto:
	proc		0

	push_builtin	auto_overlay

	push_length	op1

	if		op1,=,0,init_return

	push_builtin	auto_template

	emit_eis

	mlr		(pr),(pr),fill(0)
	desc9a		op1
	desc9a		op3

init_return:
	return

make_quick_entry:
	copy		arg1	Copy original symbol for entry
	get_quick_label	arg1	replace arg1 with label for quick entry pt

"If storage space needs to be created then we substitute fort_return_mac for
"return_op to get the storage released at the end of the external call.

	unless_cleanup	mqe_no_storage
	epp2		pr0|fort_return_mac
	jump		mqe_end_storage

mqe_no_storage:
	epp2		pr0|return_op

mqe_end_storage:

	label		arg1
	push_builtin	entry_info

	spri2		op1
	spri1		op1+2	Store arg pointer
	arg_ptr_in_pr1		Update machine state

	unless_needs_descriptors op2,mqe_no_desc
	spri3		op1+4	Store descriptor pointer
	desc_ptr_in_pr3		Update machine state

mqe_no_desc:
	swap		op2	Get original entry symbol on top
	pop		op1	Pop it off

	s_return

process_param_list:
	proc		1

ppl.loop:
	push_operand	ppl.done
	jump		ppl.loop

ppl.done:
	check_parameters
	return

descriptor_check:

	" Subroutine to check to see whether or not descriptors might be
	" required for a subroutine call or function reference.  In ansi66
	" mode, we print a message warning the user that descriptors might
	" be necessary.  In ansi77 mode, we go ahead and cause descriptors
	" to be used (silently).  In either mode, if the called subprogram
	" is local to this compilation, then it will already have been taken
	" care of by the storage allocator.

	" Called from func_ref (to check the function return value of
	" character valued functions) and from evaluate_arglist.

	" Assumes that arg1 is the external symbol.

	if_local		arg1,descriptor_check.return
	if_needs_descriptors arg1,descriptor_check.return
	if_ansi77		descriptor_check.set

	" Print a warning that this call might need descriptors

	print		348,arg1
	jump		descriptor_check.return

descriptor_check.set:

	" Cause descriptors to be generated for this call

	set_needs_descriptors		" arg1 implied

descriptor_check.return:
	s_return

increment_polish:
	proc		0

	skip_data

	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

label_operator:
	proc		1

	label		arg1

	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

stat:	proc		0

	shorten_stack

	stat

	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

call:	proc		2

"
	s_call		evaluate_arglist
	s_call		make_call

	return

evaluate_arglist:
	push_operand	check_args
	if_optype		bif,conv_bif
	if_optype		external,conv_external

	unless_dt		char,evaluate_arglist

	" If argument is of data type character, check to see if we should
	" warn the user about descriptors or just use them.

	s_call		descriptor_check

	jump		evaluate_arglist

conv_bif:
	call		cv_bif_to_external
	jump		evaluate_arglist

conv_external:
	if_parameter	op1,evaluate_arglist " parameters already are external variables

	call		make_external_variable
	jump		evaluate_arglist

check_args:
	check_arg_list
	s_return

cv_bif_to_external:
	func		1

	push_bif_index	arg1	" get index into big table
"				now get offset into vector
	push_count_indexed	op1,(38,39,40,19,2,12,21,3,13,4,14,5,15,7,17,23,41,42,43,1,11,20,0,0,0,0,0,0,0,0,0,0,0,0,57,58,10,44,45,46,6,16,22,9,18,24,8,0,47,0,0,0,0,0,48,0,0,49,26,27,28,29,30,31,0,0,32,50,0,0,0,0,36,34,37,35,33,51,52,53,54,55,56,0,0,0,0,59,60,61,62,0,0)

	if		op1,=,0,not_external_bif

	reserve_regs	(x2,pr2,pr4)
	eax2		op1
	tsx0		pr0|get_math_entry

	jump		ext_join

not_external_bif:
	error		461,arg1

make_external_variable:
	func		1

	load_pr		pr2,arg1

ext_join:
	push_builtin	null_ptr
	push_temp		4
	bump		op1
	bump		op1

	spri2		op1
	load		aq,op2
	staq		op1+2

	free_regs
	return		op1

make_call:
	copy		arg2		get nargs

	unless_needs_descriptors	arg1,inc_for_hdr
	multiply		op1,2

inc_for_hdr:
	increment		op1,1		(for header)

	unless_parameter	arg1,double_count
	increment		op1,1		for display pointer

double_count:
	multiply		op1,2		double to get size of temp

	if_local		arg1,local_call

	push_temp		var

	bump_args

	store_arg_addrs

	make_descriptors

	use_eaq				" any temps that need to be saved...
	reserve_regs	indices		... must be saved now
	free_regs				we still might need xregs for > 16K addressing

	eax1		op1

	copy		arg2
	multiply		op1,2048
	fld		op1
	pop		op1

	load_pr		pr2,arg1

	reserve_regs	all		all regs may be used by the call programs

	if_parameter	arg1,call_variable

	if_needs_descriptors	arg1,call_ext_desc

	tsx0		pr0|call_ext_out
	jump		call_join

call_ext_desc:
	tsx0		pr0|call_ext_out_desc
	jump		call_join

call_variable:
	if_needs_descriptors	arg1,call_variable_desc

	tsx0		pr0|call_var
	jump		call_join

call_variable_desc:
	tsx0		pr0|call_var_desc

call_join:
	free_regs
	free_temp		op1		" free argument list temporary
	free_descriptors
	drop_args
	s_return


local_call:
	bump_args

	if_constant_addrs	use_itp

	push_temp		var

	store_arg_addrs

	make_descriptors

	use_eaq

	copy		arg2
	multiply		op1,2048
	fld		op1
	pop		op1

	staq		op1
	load_pr		pr1,op1

	unless_needs_descriptors arg1,lc_no_desc

	lda		pr1|0	Get 2*nargs in au
	epp3		pr1|2,au	Load descriptor pointer

lc_no_desc:
	get_quick_label	arg1	replace external ref with label for quick entry point

	reserve_regs	all-pr4

	tsp2		arg1

	free_regs
 	free_temp		op1		" free argument list temporary
	free_descriptors
	drop_args
	s_return

use_itp:
	gen_itp_list		replaces top of stack with constant arg list
	use_eaq
	load_pr		pr1,op1

	unless_needs_descriptors arg1,itp_no_desc

	lda		pr1|0	Get 2*nargs in au
	epp3		pr1|2,au	Load descriptor pointer

itp_no_desc:
	get_quick_label	arg1	replace external ref with label for quick entry point
	reserve_regs	all-pr4
	tsp2		arg1
	free_regs
	free_descriptors
	drop_args
	s_return

chain:	proc		3

	swap		arg1

	if_dt		char,chain2
	unless_dt		int,chain_path.p
	unless_array	chain_path.p

chain2:
	swap		arg1

	swap		arg2

	if_dt		char,chain3
	unless_dt		int,chain_sys.p
	unless_array	chain_sys.p

chain3:
	swap		arg2

	copy		arg3
	increment		op1,47
	push_temp		var

chain_fill:
	use_eaq

	ldq		arg3
	stq		op1

	emit_eis
	mlr		(pr),(pr)
	desc9a		arg1,168
	desc9a		op1+1,168

	ldaq		arg2
	staq		op1+45

	load_pr		pr2,op1
	emit_inst		1
	eax0		0

chain_next_file:

	push_operand	chain_ret
	ldq		op1
	stq		op2+47,0
	pop		op1
	eax0		1,0
	jump		chain_next_file

chain_ret:
	reserve_regs	(x1,x2,x3,x4,x5,x6,x7,pr1,pr2,pr3,pr4,pr5,pr7)

	tsx0		pr0|fortran_chain
	free_regs
	free_temp		op2		" free arglist temp
	reset_eaq

	return

chain_path.p:
	print		335,op1
	return

chain_sys.p:
	print		336,op1
	return

endunit:	proc		0

	end_unit
	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

non_executable:
	proc		0
	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

no_op:	proc		0
	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

form_VLA_packed_ptr:
	func		1
	load		q,arg1
	div		pr0|VLA_words_per_seg
	emit_inst		2
	als		18
	llr		18
	return		q

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

opt_subscript:
	proc		3

	optimized_subscript
	return

left_shift:
	func		2

	load		q,arg1
	qls		arg2

	return		q

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

right_shift:
	func		2

	load		q,arg1
	qrs		arg2

	return		q

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

store_zero:
	proc		0

	push_output

	stz		arg1
	flush_ref		arg1

	return

storage_add:
	proc		1

	push_output

	note_eligible_ind_var_use

	if_global		arg2,storage_add.global

	load		q,arg1
	asq		arg2
	flush_ref		arg2

	return

storage_add.global:
	increment_index
	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

storage_sub:
	proc		1

	push_output

	load		q,arg1
	ssq		arg2
	flush_ref		arg2

	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

neg_storage_add:
	proc		1

	push_output

	note_eligible_ind_var_use

	if_global		arg2,neg_storage_add.global

	lcq		arg1
	asq		arg2
	flush_ref		arg2

	return

neg_storage_add.global:
	decrement_index
	return

storage_add_one:
	proc		0

	push_output

	note_eligible_ind_var_use

	if_global		arg1,storage_add_one.global


	aos		op1
	flush_ref		op1

	return

storage_add_one.global:
	push_builtin	one
	swap		arg1
	increment_index
	return

read_namelist:
write_namelist:
namelist:	proc		1

	push_builtin	ps
	load_pr		pr2,arg1
	spri2		op1+namelist_slot

	free_regs
	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

sub_index:
	func		1
	if_eaq		q,arg1,subscript_in_q	" easy, subscript is already in q
	push_output

	sub_index					" loads op1 into any xr, sets
						" output.value_in.x
	return		op1

subscript_in_q:
	return		q

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

loop_end:
	proc		var

	drop_all_counts
	return

cat:	func		var

	pop		arg1
	set_next_operand	1

	push_operand_count
	decrement		arg1,1

	" arg1 is now the number of strings to be moved.  Push all operands
	" next, so start_cat can look at them.

cat.push_all_operands:
	push_operand	cat.all_operands_pushed
	jump		cat.push_all_operands

cat.all_operands_pushed:
	start_cat		cat.dont_move_op1

	" Move all operands, starting with the first one.  Get the result
	" temp (which was pushed by start_cat) on the stack as arg1.  Get
	" the count of operands to move on the stack as arg2.

	swap		arg2
	pop		arg3
	swap		arg1
	set_next_operand	1
	jump		cat.process_next_operand

cat.dont_move_op1:

	" Move all operands EXCEPT the first one.  Get the result temp on
	" the stack as arg1.  Get the first operand on the top of the
	" stack for data type checking and address manipulation.  Get the
	" count of operands to move on the stack as arg2.

	swap		arg3
	pop		arg4
	swap		arg1
	swap		arg2
	unless_dt		char,cat.bad_data_type
	set_next_operand	2
	decrement		arg2,1
	jump		cat.adjust_result_address

cat.process_next_operand:

	" Get the next operand on top of the stack, check its data type,
	" and emit code to move it to the end of the result temp.

	push_operand
	unless_dt		char,cat.bad_data_type

	emit_eis		equal_lengths
	mlr		(pr),(pr),fill(040)
	desc9a		op1
	desc9a		arg1

	" If that was the last operand to be moved, quit.

	decrement		arg2,1
	if		arg2,=,0,cat.moved_last_operand

cat.adjust_result_address:
	continue_cat
	jump		cat.process_next_operand

cat.moved_last_operand:

	" All operands have been moved.  Clean up, and return the temp.

	finish_cat
	return		arg1

cat.bad_data_type:
	error		354,op1

lhs_fld:
	proc		3

	push_output
	swap		arg3		"put the stack in expected order
	lhs_fld
          return

lhs_.p1:
	error		359,arg1

lhs_.p2:
	error		359,arg2

lhs_.p3:
	error		360,arg3

lhs_.p4:
	error		361

load_xreg:
	proc		2

	load_xreg
	return

"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *

load_preg:
	proc		1

	load_preg

	return

do:	error	330,ascii,do
jump_logical:
	error	330,ascii,jump_logical
xmit_scalar:
	error	330,ascii,xmit_scalar
xmit_array:
	error	330,ascii,xmit_array
xmit_vector:
	error	330,ascii,xmit_vector
sf_def:	error	330,ascii,sf_def
sf:	error	330,ascii,sf
item:	error	330,ascii,item
exit:	error	330,ascii,exit
eol:	error	330,ascii,eol
subscript:
	error	330,ascii,subscript
substr:	error	330,ascii,substr
block_if:	error	330,ascii,block_if
else_if:	error	330,ascii,else_if
else:	error	330,ascii,else

	end
