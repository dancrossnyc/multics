/****^  *********************************************************
        *                                                       *
        * Copyright, (C) BULL HN Information Systems Inc., 1990 *
        *                                                       *
        * Copyright, (C) Honeywell Limited, 1983                *
        *                                                       *
        * Copyright (c) 1972 by Massachusetts Institute of      *
        * Technology and Honeywell Information Systems, Inc.    *
        *                                                       *
        ********************************************************* */




/****^  HISTORY COMMENTS:
  1) change(86-07-14,BWong), approve(86-07-14,MCR7286), audit(86-07-17,Ginter),
     install(86-07-28,MR12.0-1105):
     Fix fortran bugs 430, 449, 452, 455, 460, 463, and 492.
  2) change(86-07-14,BWong), approve(86-07-14,MCR7382), audit(86-07-17,Ginter),
     install(86-07-28,MR12.0-1105):
     Fix fortran bugs 411, 425, and 473.
  3) change(86-10-17,Ginter), approve(86-10-17,MCR7556), audit(86-10-22,Huen),
     install(86-11-13,MR12.0-1216):
     Fixed fortran bugs 496 and 502.
  4) change(90-04-27,Huen), approve(90-04-27,MCR8155), audit(90-05-16,Gray),
     install(90-05-30,MR12.4-1011):
     ft_508 : Generate correct code for index intrinsic on a substring of a
     static character variable.
                                                   END HISTORY COMMENTS */


/* format: style4,delnl,insnl,^ifthendo,indnoniterend,inditerdo,indend,^indproc,indcom,declareind5 */
fort_optimizing_cg:
     procedure (p1, p2);

dcl  (p1, p2, shared_struc_ptr, cg_struc_ptr) pointer;
dcl  (object_base, operand_base, polish_base, relocation_base, quadruple_base, opt_base) pointer;
dcl  (object_max_len, operand_max_len, polish_max_len, opt_max_len) fixed binary (19);

%include fort_nodes;
%include fort_opt_nodes;

%include fort_listing_nodes;

%include fort_system_constants;

dcl  1 shared_globals structure aligned based (shared_struc_ptr),
%include fort_shared_vars;

%include fort_options;

dcl  1 cg_globals structure aligned based (cg_struc_ptr),
%include fort_cg_vars;

%include definition;
%include segname_def;

dcl  1 symtab_parameters structure aligned,
%include fort_symtab_parms;
%include long_profile;

dcl  fort_make_symbol_section entry (ptr, ptr, ptr, fixed bin (18), fixed bin (18));


	shared_struc_ptr = p1;
	cg_struc_ptr = p2;
	object_max_len = shared_globals.object_max_len;
	operand_max_len = shared_globals.operand_max_len;
	polish_max_len = shared_globals.polish_max_len;
	opt_max_len = shared_globals.opt_max_len;


	object_base = shared_globals.object_base;
	operand_base = shared_globals.operand_base;
	polish_base = shared_globals.polish_base;
	relocation_base = shared_globals.relocation_base;
	quadruple_base = shared_globals.quadruple_base;
	opt_base = shared_globals.opt_base;


	call code_generator;

%include fort_utilities;

code_generator:
     procedure ();

/****^ Written: 1 February 1976 by Richard A. Barnes


Modified: 31 Mar 90, SH - 508: When necessary, reset pr4 to linkage ptr.  
          Avoid inserting an instruction in the middle of the scm arg sequence
          for index intrinsic when pr4 is valid. Also, remove "restore_prs".
Modified: 16 Oct 86, AG - 502a:  Change make_symbol_descriptor so it always
	generates correctly formatted char (*) descriptors.  Change
	make_entry_descriptor so it never "adjusts" incorrectly formatted
	char (*) descriptors.  Change get_param_char_size so that it always
	expects correctly formatted char (*) descriptors.
Modified: 22 Sep 86, AG - 502:  Set descriptor size field to "1"b only for
	character *(*) variables in make_entry_descriptor.
Modified: 22 Sep 86, AG - 496a:  Oops -- forgot that array symbols can
	be accessed directly in "call" statements.  Explicitly check
	for symbol.dimensioned when restoring symbol.address.offset.
Modified: 04 Sep 86, AG - 496:  For non-array symbols in very large common,
	use symbol.addr_hold instead of symbol.address.offset to hold the
	offset in the linkage section of the pointer to the symbol.  Too
	much code counts on symbol.address.offset holding the offset from
	the pointer of the symbol (always 0).  Also made create_storage_entry
	save info in a_name about symbols used in create_entry structures.
Modified: 08 Jul 86, AG - 449.a: Use "anq/stq" instructions rather than "orsq"
	to update length field in character* (*) dummy arg descriptors.
Modified: 19 Feb 86, BW & AG - 473.a: Flag error if passing VLA type arguments
	to non-VLA type arguments in the same compilation unit.
Modified: 03 Feb 86, SH - 425: Passing hollerith (i.e. character) constant
	data types as arguments to other data types will no longer
	produce error 401 (inconsistent argument types).
Modified: 29 Oct 85, BW - 411: Make sure common block units are the same when
	comparing maximum lengths.
Modified: 08 Aug 85, BW - 430: Prevent emission of deallocation code for auto-
	matic LA's and VLA's when they don't exist in the compilation unit.
Modified: 02 Aug 85, BW - 463: Remove code for action (56) since the macros
          no longer require this action after the bug fix.
Modified: 04 Jul 85, BW - 460: Fix addressing of complex number arrays.
Modified: 21 May 85, BW - 455: Ensure auto ptrs to parameters are allocated
          on even word boundaries.
Modified: 24 Apr 85, MM - 449: Create the routine 'make_entry_descriptor' as
	'make_symbol_descriptor' can't be used by the code that makes
	entrys.
Modified: 30 Jan 85, MM - 447: Allow base_man_load_any_pr to set the bit
	address_in_base for VLA elements.
Modified: 19 Oct 84, MM - 443: Fix list_init_ array initialization.
Modified: 22 Aug 84, HH - 439: 'make_symbol_descriptor' sets lower bound to
	-2**35 if lower bound is constant but upper bound is not.
Modified: 22 Jun 84, MM - Install typeless functions support.
Modified: 09 Apr 84, MM - 417: character elements are incorrectly assumed to
	be word aligned in ansi77 mode if lower bound of array is 0.
Modified: 04 Apr 84, HH - 416: 'add' and 'sub' need to support -ve constants.
Modified: 28 Mar 84, HH: Install HFP support.
Modified: 13 Mar 84, HH - 415: Incorrect relocation information generated for
		entry point declarations.
Modified: 26 Jan 84, TO: 414 - Fix bug in char(*) sizing introduced by entry
	definition code.  We need to emit an extra constant word for char(*)
	descriptors, rather than mangle the real word that ORQ will refer to.
Modified: 19 Sep 83, RG & MM - 242/370: Use entry-defined arg_desc if one exists.
Modified: 27 Jul 83, HH - 371: 'mult' needs to support -ve constants.
Modified:	17 Jun 83, HH - 383: Simplify input to 'check_parameters'.
Modified:  8 June 83, TO: 382 - Fix size of entry_info (builtin(8)) to
	correspond to reality (it is 7 words long).
	Update documentation of builtin (8).
Modified:  8 June 83, TO: 381 - Fix register reservation mask for shorten_stack
	renamed from reserve_pr1_mask (which reserved pr0 instead) to
	shorten_stack_mask which reserves pr1, x1.
Modified:	14 April 83, RG: 377 - Fix flush_ref to use flag 'in_equiv_stmnt'
	not 'aliasable'.
Modified: 14 April 83, TO - fix 'make_create_entry' to correctly address
	'create_entry.next' when setting 't' relocation.
Modified:  5 April 83, TO - fix 'check_parameters' to ensure parameter is
	a symbol and not a return constant.
Modified:  5 April 83, TO - fix list_template_init of common bugs.
Modified:  5 April 83, TO - fix 'allocate', 'free' bug in VLA common
	cleanup, have cleanup done by common cleanup routine.  Chain headers
	were being free'd twice, and cleanup during processing was
	inconsistent.
Modified: 31 March 1983, TO: 374 - Fix bug in large_address array_ref in
	finish_subscript in which the constant offset of the array_ref
	backs up before the 16K bound, leaving array_ref base wrong and
	large_address flag off preventing re-calc of base in 
	m_a_check_large_address.
Modified: 31 Jan 83, TO & HH: Install LA/VLA support.
Modified: 10 January  1982, TO - Add 'emit_entry_def (simple (56)) operation
	from macros to create an entry definition entry.  Added code to
	gen_entry_defs to copy text position of definition to table.  Added
	code to 'check_parameters' (simple (15)) to fill in descriptors.
Modified: 31 December 1982, TO: 367 - Cause allocation of named constants if
	we want a symbol_table.
Modified: 22 Dec 82, TO - 358:  use 'lock_base' in 'load_preg' to correct 
	running out of pointer registers.
Modified: 18 Dec 82, TO - Add '-long_profile' support.
Modified: 17 Nov 82, HH - 361:  'get_format_var' operator no longer exists.
Modified: 05 August 1982, HH - Fix bug 357:  Pad char constants with spaces
	rather than NUL's.
Modified: 16 July, 1982, TO - fix bug introduced in fix of bug345.  We
	     incorrectly mixed the index of the global and free register in
	     "base_man_load_large_base".
Modified: 21 May 1982, TO - Fix bug in check_arg_list where 'n' is used in
	     place of 'num_args'.
Modified: 20 May 1982, TO - Fix bug where virtual_origin automatic is not
          allocated for star_extent array in 'get_array_size'.
Modified: 20 May 1982, TO - Fix descriptor bug where char*(*) multiplier is
	only calculated for last dimension, leaving an unprobe-able, and at
	times (dims>2) unrunnable binary.
Modified: 20 May 1982, TO - Fix probe bug where char*(*) multiplier calculated
	for descriptor in bits is used for probe runtime_symbol in chars.
	This causes an extended descriptor to be allocated in the stack and
	the intermediate character multiplier to be stored in the extended
	area to be picked up by runtime_symbol.bound(n).multiplier.
Modified:  9 May 1982, TO - Fix (if unless)_negative to know about other than
	integer.
Modified:  7 May 1982, TO - Fix use of EAQ register and move_logical_to_a.
	previously move_logical_to_a used and reset A, but didn't consider
	those things in EAQ, which subsiquently got lost and not stored.
Modified:  5 May 1982, TO - Allocate char_star_function return_value.
Modified:  5 May 1982, TO - Add action (74) (if unless)_char_star_function.
Modified:  5 May 1982, TO - Add action (75) (if unless)_check_multiply.
Modified: 26 April 1982    , TO  - fix navytest3 bug.  Cause flush_ref to
	remove ALL equivalenced refs in this chain.
Modified: 26 April 1982    , TO  - fix navytest16 bug in optimized_subscript.
	char_num of array base was not added to calculated character number.
Modified: 15 April 1982    , TO  - Implement extended information for stack and
	linkage overflow message (error 414).
Modified: 12 April 1982    , TO  - Fix bug 344, stack_indirect in set_itp_addr.
Modified: 05 April 1982    , TO  - Fix register reservation in argument and descriptor processing.
Modified: 15 September 1981, CRD - Change check_comparisons_and_increments to
	put left shift on operator list of loop entry statement if back
	target does not fall through.
Modified: 17 June 1981, CRD - Fix bug 322.
Modified: 12 May 1981, CRD - Add equiv_op, not_equiv_op.
Modified: 23 April 1981, CRD - Fix bug 319.
Modified: 20 April 1981, CRD - Fix bug 316.
Modified: 19 March 1981, CRD - Fix bug 311.
Modified: 12 March 1981, CRD - Implement assumed size arrays.
Modified: 27 February 1981, CRD - Implement array lower bounds ^= 1.
Modified: 9 December 1980, CRD - Change upper bound of
	operator_table array to 102 for block_if, else_if, and
	else operators.
Modified: 25 November 1980, CRD - Improve fix to bug 289.
Modified: 19 November 1980, CRD - Fix bug in which star extent arrays
	did not have their virtual_origin and array_size symbols
	set properly unless the first dimension was variable.
	Also fixed bug in which an attempt to use an ITP argument
	list was made when passing descriptors.
Modified: 31 October 1980, CRD - Change propagate_and_eliminate_assignment
	not to eliminate assignments if the RHS is a symbol and is
	subsequently set in the flow unit.  This fixes bug 289.
Modified: 22 October 1980, CRD - Change load to call move_logical_to_a
	unless the Q is being loaded.  This fixes bug 288.
Modified: 6 October 1980, CRD - Change flush_ref to restore the
	address of aligned character strings.  This fixes bug 282.
	Also some changes mandated by audit.  Also moved symbolic
	names of instructions in single_inst array to the include
	file fort_single_inst_names.incl.pl1.
Modified: 24 September 1980, CRD - Add pointer register 1 to the pool
	of registers available for addressing, etc.
Modified: 24 September 1980, CRD - Change desc_ptr_in_base to be a
	simple macro (desc_ptr_in_pr3), and add arg_ptr_in_pr1.
Modified: 23 September 1980, CRD - Make refresh_regs refresh pointer
	registers with zero offsets first.
Modified: 16 September 1980, CRD - Remove code in optimized_subscript
	which bumped ref counts of length and offset temporaries.
	Also changed drop_count to ignore operand offsets <= 0.
Modified: 15 August 1980, CRD - Fix large address bug in
	continue_cat.
Modified: 13 August 1980, CRD - Catch negative length substrings.
Modified: 12 August 1980, CRD - Fix bug in (if unless)_ansi77.
Modified: 30 July 1980, CRD - Add code to avoid redundant virtual
	origin computation.
Modified: 28 July 1980, CRD - Change optimized_subscript to deal
	with named constants.  Also change convention for detecting
	unprocessed array_ref nodes to use array_ref.has_address.
Modified: 22 July 1980, CRD - Fix bug in optimized_subscript.
Modified: 16 July 1980, CRD - Add (if unless)_variable_arglist macro.
Modified: 15 July 1980, CRD - Changes for generating descriptors
	on calls - copy needs_descriptors bit from entry_point
	symbol to external symbol in assign_storage, and add
	set_needs_descriptors macro.
Modified: 23 June 1980, CRD - Add (if unless)_ansi77.
Modified: 17 June 1980, CRD - Change assign_address_to_temp to copy
	over length information, and to properly extract addresses
	for dynamic temporaries.
Modified: 21 April 1980, CRD - Implement concatenation.
Modified: 18 April 1980, RAB - fix an ureported bug in which load_preg
	loads a global value into a register that should have been
	avoided.
Modified:	18 March 1980, RAB - fix a bug in which
	check_comparisons_and_increments was calling connect_expression with
	the order of the last 2 arguments reversed.  This caused a strange
	instability in temporary allocation, although the code was correct.
Modified:	9 March 1980, RAB - fix a bug in reset_scan: the processing
	that occurs if we have passed over flow_units from other
	loops should occur before we check to see if this loop is
	finished.
Modified:	9 March 1980, RAB - fix several bugs:  make free_temp
	zero temporary.globally_assigned; have reset_scan not
	call save_state if the statement is referenced by assign
	or referenced backwards; have reset_scan discard the
	machine_state at the end of the loop.
Modified:	7 March 1980, RAB - fix a bug in load_preg.  It
	should worry about avoiding prs in next_lp not cur_lp.
Modified:	6 March 1980, RAB - fix a bug in merge_state.  In order
	to refresh the global bits when the state is discarded,
	merge_state should call refresh_global_bits rather than
	enter_loop, since lp_msp might be null.
Modified:	24 February 1980, RAB - add floating_power_of_two
Modified: 15 February 1980, CRD - change return macro to allow
	returning operands other than temporaries.
Modified:	9 February 1980, RAB - allow variables busy_on_exit from a
	loop to be kept in an index register.
Modified: 8 February 1980, CRD - Add char1_to_int, int_to_char1,
	and (if unless)_aligned macros; fix text_ref to work
	with char constants; and change the return macro to
	convert counts to integer constants.
Modified: 3 February 1980, CRD - add code to support star extent
	character strings, to support Fortran entries which require
	descriptors, and to implement substrings.
Modified:	30 January 1980, RAB - to fix a bug in which an empty
	globally assigned register was erroneously loaded with
	a local value.  The fix involved adding an argument to
	get_free_reg to distinguish between a register preselected
	because it was globally assigned the desired item and
	a register preselected because it was empty.
Modified:	27 January 1980, RAB - add force_ql macro to improve jump_computed
	code.
Modified:	8 January 1980, RAB -alter reset_subprogram to reset temporaries in
	ALL loops.
Modified:	8 January 1980, RAB - fix reference count bugs in gen_itp_list and
	base_man_load_pr.
Modified:	2 January 1980, RAB - fix a bunch of bugs.
Modified:	1 January 1980, RAB - added propagate_and_eliminate_assignment.
	Also, loop.all_xrs_globally_assigned.
Modified:	28 December 1979, RAB - made changes to prevent trouble if
	more than one register were locked for arguments to pl1_operators;
	implemented refresh_regs_if_next_is_jump macro to allow
	refresh_regs before relational operator; implemented
	note_eligible_ind_var_use to allow the counting of an
	incrementing or comparison as an index register use during
	analysis; made changes to allow all registers of a class
	to be globally assigned if there are no local uses and
	there are enough registers to assign all global items; and
	made changes to force doubleword alignment for all innermost
	loops.  Also, removed reset_regs.
Modified:	22 December 1979, RAB - make round of bugfixes to register optimizer.
Modified:	18 December 1979, RAB - make bulk of changes to implement
	the REGISTER OPTIMIZER!!
Modified:	1 December 1979, RAB - change ERROR to not push an error
	operand for the scan frame as this is wrong for the
	optimizing cg.
Modified:	30 November 1979, RAB - to add second set of changes for
	the register optimizer.
Modified:	3 November 1979, RAB - to add first set of changes for
	the register optimizer.
Modified: 31 October 1979, CRD - fix bugs caught by audit, and add
	code to get_param_array_size to fill in descriptors for
	packed character string correctly.
Modified: 29 October 1979, CRD - add register reservation for the
	A and Q for EIS instruction offsets.
Modified: 25 October 1979, CRD - invent make_both_addressable, and
	change emit_eis to call it.  Invent eaq_man_load_a_or_q,
	and change m_a to call it.  Invent a new eaq name, in_ia,
	for integers in the A register.
Modified: 23 October 1979, CRD - assorted changes to allow the code
	generator to be compiled with subscriptrange enabled; and a
	bug fix to allow the load macro to handle counts properly.
Modified: 17 October 1979, CRD - changes due to audit and enlightenment.
Modified:	5 October 1979, CRD - change EAQ management to consider
	the EAQ to be four registers.
Modified: 20 September 1979, CRD - added code in base_man_load_pr
	to load addresses of unaligned character strings.
Modified: 19 September 1979, CRD - change register reservation to
	use logic planned for register optimizer.
Modified: 12 September 1979, CRD - change large address scheme to
	use full 32K addressing capability of 15 bit offset.
Modified: 5 September 1979, CRD - make changes to storage allocator
	for ANSI 77 character mode.
Modified: 28 August 1979, CRD - fix bug 233 (%options round and
	%options truncate in the same compilation don't work).
Modified: 24 August 1979, CRD - fix bug 232, in which descriptors
	are copied onto the stack incorrectly due to the data_type
	field of symbols created by the CG not being set.
Modified: 23 August 1979, CRD - move code to build runtime symbol
	table to separate external procedure, fort_make_symbol_table.
Modified:	6 August 1979, RAB - fix 230 (FATAL ERROR 418 in free_regs for large stackframes)
Modified: 25 July 1979, CRD - rearrange more simple macro
	instructions to have opcodes in the left half.
Modified: 24 July 1979, CRD - fix bug 229, in which parent chain
	of runtime symbol table was being built incorrectly.
Modified: 23 July 1979, CRD - compress the opcodes for certain
	if/unless macro pairs into a single opcode by using
	macro_cond_inst.if_test.
Modified: 23 July 1979, CRD - put op codes of simple macro
	instructions in the left half of the instruction word.
Modified: 16 July 1979, CRD - changes parallel to those made to
	ext_code_generator in fixing bug 225.
Modified:	11 June 1979, RAB fix bug 209 (temp space not being reused)
Modified:	2 May 1979, RAB - (1) Change scheme for addresses >= 16K to use ptr
	regs instead of xregs; (2) Change action of OPT_SUBSCRIPT to NEVER
	create temps  (xr_man now calls a subroutine of m_a to get the
	address of nonaddressable operands) fixing bug 203; and (3) Change 
	get_free_reg to get usage counts of temps by following input_to chain
	and adding ref_counts of array_refs.
Modified:	17 January 1979, RAB - to speed up reg management by using
	machine_state.value_in_xr.
Modified:	5 January 1979, RAB - to make get_free_reg use ref_counts
	in deciding which register to flush, and to improve the
	> 16k case for array elements.
Modified: 6 December 1978, PES - for %options and %global.
Modified:	4 December 1978, RAB - for option to initialize auto storage to zero
Modified: 01 December 1978, RAB - Improve handling of round before compare.
Modified: 30 November 1978, PES - Key rounding off of fortran_options.
Modified:	19 November 1978, RAB - Centralize control of rounding
	by use of eaq.rounded.
Modified: 25 October 1978, PES -Changes for larger common blocks and arrays.
Modified:	11 October 1978, RAB - Fix bug 184 in which bad code is
	produced if an increment causes an address to cross a 16K
	boundary.  Also checks were put in for invalid data_type
	and operand_type fields and for uninitialized
	array_ref nodes.
Modified: 12 Sept 1978, PES - Move PS from static to automatic storage, to fix
	bug 182 in which fortran_io_ fails in the event of a segment loop,
	e.g. a subr in segment <a> calls a subr in segment <b>, which in
	turn calls another subr in segment <a>.
Modified: 06 Sept 1978, PES - Fix (masked) bug which might cause a register not
	to be reloaded before being used as an index, even if the value has
	been changed in storage.  This bug is in a currently unused block of
	code, but future changes could cause it to surface.
Modified: 27 July 1978, PES - Fix bug in handling of nested subscripts; fix bug
	in setting of symbol.simple for parameters.
Modified: 23 June 1978, DSL - Fixes generated by audit. Allocate ps as first
	thing in static in order to prevent problems if ps overlaps 16K
	boundary; some speed up changes; add machine state ref count
	(temporary.ms_ref_count) to handle temp node's second purpose, place
	holding in machine states; temporary's storage is freed when normal
	ref count is zero; temporary is only freed if ms_ref_count is zero
	too. Fix ref count bug in emit_eis; set symbol.element_size for
	descriptors generated by code generator.

	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Rewritten starting 9 November 1977 by David S. Levin to create the optimizing code generator.

	* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Modified: 4 November 1977, DSL - Use maximum length when allocating common
	blocks.
Modified:	31 October 1977, RAB - Fix bug 129 where large virtual origins get
	bad code. Also, implement DL modification for negative constants.
Modified:	6 October 1977, DSL - Fix bug in subscripting code for the following:
	array i(3,3),j(3); i(j(l), l) = m(l)
Modified: 30 August 1977, DSL - coordinated change with listing generator to
	mark entry "data" words; base_man_load_pr_value fails to set reloc
	info and symbol info; multiply macro does not check for product >
	bias. Fix "load" to set proper ref count for complex vars.
	NOTE -- in this compilation the value of bias changed from 65536 to
	131072.
Modified: 21 July 1977, DSL - fix bug in itp list reloc info.
Modified: 14 July 1977 by DSL - 1) add new builtin, ps_area_ptr, for open and
	close; 2) add new macro load_pr_value, to load a pr with the contents
	of a location; 3) give relocation info for automatic storage template
	(bug fix).
Modified: 5 July 1977 by DSL - 1) fort_system_constants.incl.pl1 change;
	2) print message for multiple initialization of a single common
	block. 3)  Change if_ind and unless_ind to always work even if the
	eaq appears empty, fixing 108. THIS CONFLICTS WITH PUBLISHED
	DOCUMENTATION !!!
Modified: 26 May 1977 by DSL to always generate ERROR operand if an error
	occurs in a function frame; THIS CHANGE EXACTLY CONFLICTS WITH THE
	ORIGINAL DOCUMENTATION OF THE MACRO LANGUAGE. Refer to code for
	action 66 (error) for complete details.
Modified:	3 May 1977 by RAB for store macro.
Modified: 28 April 1977 by DSL - for new fort_system_constants.incl.pl1
Modified: 28 March 1977 by DSL for new stmnt label handling; interface with new
	node formats; recompile because of PL/I bug 1599 (in compile_link for
	A$B common names).
Modified: Feb 1977 by GDC for the optimizer
Modified: 31 Jan 1977 by DSL to allow type-3 links for common block names of
	the form a$.
Modified: 9 Dec 1976 by DSL to reference fort_version_info$version_name
Modified: 7 Dec 1976 by RAB to fix bugs in make_symbol_table
Modified:	22 Nov 1976 by RAB to add -profile
Modified:	November 1976 by David Levin to add make_symbol_table
Modified:	19 Oct 1976 by RAB for ok_lists and runtime symbol table hooks
Modified:	14 Oct 1976 by RAB for relocation bits
Modified:	7 Oct 1976 by RAB for optional descriptors
Modified:	30 Sept 1976 by RAB for object listings and local object, operand,
	and polish bases
Modified:	5 July 1976 by RAB for addrs >= 16K

END Modifications */

dcl  first_frame ptr;

dcl  next_free_ms ptr;				/* free chain of machine state nodes in the operand region */

dcl  cleanup_body_address fixed bin (18) unsigned;
dcl  alloc_auto_cleanup bit (1) aligned;

dcl  (c, lib_pt, p) ptr;

dcl  (n, text_pos, link_pos, def_pos, sym_pos, begin_links, linkrel, defrel, symrel, lib_pos, last_pos, profile_start,
     profile_pos) fixed bin (18);

dcl  (begin_external_list, end_external_list) fixed bin (18);

dcl  begin_forward_refs fixed bin (18);

dcl  (first_namelist, last_namelist) fixed bin (18);
dcl  (first_header, last_header) ptr init (null ());	/* header chain */

dcl  (link_base, def_base, lib_list_ptr, a_base, parm_desc_ptrsp) ptr;
dcl  (link_reloc_base, def_reloc_base, lib_reloc_ptr) ptr;


dcl  free (2:4) ptr;				/* free chains of optimizer nodes */
dcl  freei ptr;					/* .. */

dcl  (generate_long_profile, generate_profile, generate_symtab, assembly_list, do_rounding, init_auto_to_zero)
	bit (1) aligned;

dcl  builtins (0:11) fixed bin (18);			/* format: off */
/* builtins are:
   0:  zero	     integer zero constant
   1:  one	     integer one constant
   2:  ps		     symbol for fortran I/O arglist
   3:  auto_template     Initialization template for auto storage
   4:  auto_overlay	     array reference overlay of automatic storage
   5:  null_ptr	     initialized to a null pointer value
   6:  null	     value of 0 as a null
   7:  two	     integer two constant
   8:  entry_info	     place to store quick proc info
	word 0 - Return address pointer (ITS).
	word 2 - Argument pointer (ITS).
	word 4 - Descriptor pointer (ITS).
	word 6 - Permanent Stack extension value (18-bit offset, 1 word).
   9:  star_symbol	     <*symbol>|0
  10:  ps_area_ptr	     symbol for ps.buffer_p
  11:  desc_overlay	     symbol for accessing a descriptor
*/
/* format: on */

dcl  image (amt) fixed bin (18) aligned based;
dcl  char_image char (4 * amt) aligned based;
dcl  (zero_def, last_def, seg_def) bit (18) aligned;
dcl  def_pool (20) fixed bin (18);

dcl  (amt, con, i, j, lib) fixed bin (18);

dcl  rands (0:operand_max_len - 1) fixed bin (18) aligned based (operand_base);

dcl  polish (0:polish_max_len - 1) fixed bin (18) aligned based (polish_base);

dcl  a_name (0:261119 - 2 * (number_of_lines + 1)) fixed bin (18) aligned based (a_base);

dcl  quad (0:quad_max_len - 1) fixed bin (18) aligned based (quadruple_base);

dcl  opt (0:opt_max_len - 1) fixed bin (35) aligned based (opt_base);

dcl  1 external_list based (polish_base) aligned,
       2 ext_ref (0:polish_max_len - 1) ptr unal;

dcl  last_auto_loc fixed bin (18);

dcl  linkage_pad fixed bin (18);			/* linkage pad of LA and VLA pointers */
dcl  first_auto_var_loc fixed bin (18);
dcl  free_temps (3) fixed bin (18);
dcl  auto_template fixed bin (18);

dcl  (hold_text_pos, hold_last_auto_loc) fixed bin (18);

dcl  1 text_halfs (0:262143) aligned based (object_base),
       2 left fixed bin (17) unal,
       2 right fixed bin (17) unal;

dcl  1 reloc_halfs (0:262143) aligned based (relocation_base),
       2 left bit (18) unal,
       2 right bit (18) unal;

dcl  reloc (0:3) bit (36) aligned based;

dcl  1 forward_refs (0:next_free_polish - 1) based (polish_base) aligned,
       2 instruction fixed bin (17) unal,
       2 operand fixed bin (18) unsigned unal;

dcl  vsegname char (32) varying defined (objectname);

dcl  1 saved_lib_list aligned based (lib_list_ptr),
       2 nlibs fixed bin (18),
       2 names (n refer (nlibs)),
         3 offset bit (18) unal,
         3 lng fixed bin (17) unal;

dcl  1 saved_lib_reloc_list aligned based (lib_reloc_ptr),
       2 mlibs fixed bin (18),
       2 names (n),
         3 reloc bit (18) unal,
         3 pad bit (18) unal;

dcl  1 parm_desc_ptrs aligned based (parm_desc_ptrsp),
       2 n_args fixed bin (18) unaligned unsigned,
       2 descriptor_relp (0 refer (parm_desc_ptrs.n_args)) fixed bin (18) unsigned unaligned;


dcl  segname char (32) aligned;

dcl  bases (0:7) bit (3) aligned internal static options (constant)
	initial ("0"b3, "4"b3, "1"b3, "2"b3, "3"b3, "5"b3, "7"b3, "6"b3);

dcl  (
     ap defined (bases (0)),
     ab defined (bases (2)),
     bp defined (bases (3)),
     bb defined (bases (4)),
     lp defined (bases (1)),
     lb defined (bases (5)),
     sp defined (bases (7)),
     sb defined (bases (6))
     ) bit (3) aligned;

dcl  which_base (0:7) fixed binary (3) internal static options (constant) initial (0, 2, 3, 4, 1, 5, 7, 6);

dcl  (
     INDEX init (1),
     BASE init (2)
     ) fixed bin int static options (constant);

dcl  (
     DU_mod initial ("03"b3),
     DL_mod initial ("07"b3),
     AL_mod initial ("05"b3),
     AU_mod initial ("01"b3),
     QL_mod initial ("06"b3),
     QU_mod initial ("02"b3),
     X0_mod initial ("10"b3),
     X1_mod initial ("11"b3),
     RI_mod initial ("20"b3),
     ITP_mod initial ("41"b3),
     FT2_mod initial ("46"b3)
     ) bit (6) aligned internal static options (constant);

dcl  01 descriptor_type_word (0:1, 7) aligned,
       02 flag bit (1) unaligned init ((14) ("1"b)),
       02 type fixed bin (6) unsigned unaligned
	  init (ft_integer_dtype, ft_real_dtype, ft_double_dtype, ft_complex_dtype, ft_logical_dtype, ft_char_dtype,
	  ft_external_dtype, ft_integer_dtype, ft_hex_real_dtype, ft_hex_double_dtype, ft_hex_complex_dtype,
	  ft_logical_dtype, ft_char_dtype, ft_external_dtype),
       02 packed bit (1) unaligned init ((14) ("0"b)),
       02 number_dims fixed bin (3) unaligned init ((14) 0),
       02 size fixed bin (23) unaligned init ((2) (35, 27, 63, 27, 1, 0, 0));
dcl  fptype fixed bin (1) init (bin (shared_globals.hfp, 1));

dcl  ext_base_on bit (36) aligned internal static options (constant) initial ("000000000100"b3);

dcl  max_address_offset fixed bin (14) static options (constant) init (16383);
dcl  max_linkage_size fixed binary (18) internal static options (constant) initial (131071);
dcl  max_stack_size fixed bin (18) int static init (62000) options (constant);

dcl  (abs, addr, addrel, bin, binary, bit, bool, byte, char, cleanup, copy,
     currentsize, divide, fixed, hbound, index, lbound, ltrim, max, min, mod,
     null, ptr, rank, rel, reverse, size, string, substr, unspec, verify) builtin;

%include linkdcl;
%include object_map;
%include relbts;
%include reloc_lower;
%include its;
%include profile_entry;
%include fortran_storage;
%include std_descriptor_types;

	/* initialize */

	cur_statement = -1;				/* Until a st node exists, there is no st text for errors */
	allocate_symbol_name = 0;			/* no names for symbols created by code generator */
	unspec (def_pool) = "0"b;
	first_frame = null;
	next_free_ms = null;
	auto_template = 0;
	unspec (builtins) = "0"b;
	text_pos, link_pos, def_pos, sym_pos, lib_pos, profile_start = 0;
	first_namelist, last_namelist = 0;
	free_temps (1), free_temps (2), free_temps (3) = 0;
	segname = vsegname;

	free (*) = shared_globals.free (*);
	freei = shared_globals.freei;

	assembly_list = shared_globals.options.list;
	if assembly_list
	then a_base = addr (source_list (number_of_lines + 2));
	else a_base = null;

	/* allocate all constants passed as arg */

	call alloc_constants (first_dw_constant, 2);
	call alloc_constants (first_word_constant, 1);
	call alloc_char_constants (first_char_constant);

	/* allocate storage */

	begin_external_list = next_free_polish;

	call assign_storage;

	/*  set up for interpreting */

	end_external_list = next_free_polish;

	/* Perform Register Usage Analysis and Global Register Allocation by
	   running a special pass of the interpreter. */

	call save_before_analysis;

	call interpreter ("1"b);

	call restore_after_analysis;

	if error_level >= unrecoverable_error
	then return;

	begin_forward_refs = next_free_polish;

	/* interpret for code generation */

	call interpreter ("0"b);

	last_pos = text_pos;

	/* allocate all constants  that need storage */

	text_pos = text_pos + mod (text_pos, 2);

	call alloc_char_constants (first_block_constant);
	call alloc_constants (first_dw_constant, 2);
	call alloc_constants (first_word_constant, 1);
	call alloc_char_constants (first_char_constant);

	/*  resolve all forward references */

	do i = begin_forward_refs to hbound (forward_refs, 1);
	     j = forward_refs (i).instruction;
	     text_halfs (j).left = text_halfs (j).left + addr (rands (forward_refs (i).operand)) -> label.location;
	     end;

	/* free up space so name_assign can use */

	next_free_polish = begin_forward_refs;

	/* allocate library structure */

	if first_lib_name ^= 0
	then do;
	     lib_pos = text_pos;
	     lib_list_ptr = addrel (object_base, lib_pos);
	     lib_reloc_ptr = addrel (relocation_base, lib_pos);
	     n = num_of_lib_names;
	     saved_lib_list.nlibs = n;
	     text_pos = text_pos + size (saved_lib_list);

	     i = 1;
	     do lib = first_lib_name repeat lib_pt -> library.next_library_node while (lib > 0);
		lib_pt = addr (rands (lib));
		c = addr (rands (lib_pt -> library.character_operand));
		saved_lib_list.offset (i) = unspec (c -> char_constant.location);
		saved_lib_list.lng (i) = c -> char_constant.length;
		saved_lib_reloc_list.reloc (i) = rc_t;
		i = i + 1;
		end;
	     end;

	/* initialize static */

	linkrel = divide (text_pos + 1, 2, 17, 0) * 2;
	link_base = addrel (object_base, linkrel);
	link_reloc_base = addrel (relocation_base, linkrel);

	call initialize_static;

	/* generate links */

	defrel = link_pos + linkrel;
	def_base = addrel (object_base, defrel);
	def_reloc_base = addrel (relocation_base, defrel);

	call init_linkage;
	call gen_linkage;

	/* generate entry definitions */

	call gen_entry_defs;

	/* generate library definition */

	if lib_pos ^= 0
	then call generate_definition ("library_list_", 0, bit (lib_pos, 18));

	/* free up space for make symbol_table that is no longer used */

	next_free_polish = begin_forward_refs;

	/* generate symbol section */

	symrel = divide (defrel + def_pos + 1, 2, 17, 0) * 2;

	symtab_parameters.link_base_ptr = link_base;
	symtab_parameters.link_reloc_base_ptr = link_reloc_base;
	symtab_parameters.def_reloc_base_ptr = def_reloc_base;
	symtab_parameters.current_text_offset = text_pos;
	symtab_parameters.current_def_offset = def_pos;
	symtab_parameters.current_link_offset = link_pos;
	symtab_parameters.final_text_offset = last_pos;
	symtab_parameters.profile_offset = profile_start;
	symtab_parameters.star_symbol_link = builtins (9);
	symtab_parameters.first_namelist_symbol = first_namelist;

	call fort_make_symbol_section (shared_struc_ptr, cg_struc_ptr, addr (symtab_parameters), symrel, sym_pos);

	/* finish up the object segment by filling in the
	   standard object map */

	n = divide (symrel + sym_pos + 1, 2, 17, 0) * 2;
	p = addrel (object_base, n);

	p -> object_map.decl_vers = object_map_version_2;
	p -> object_map.identifier = "obj_map";
	p -> object_map.text_length = bit (text_pos, 18);
	p -> object_map.definition_offset = bit (defrel, 18);
	p -> object_map.definition_length = bit (def_pos, 18);
	p -> object_map.linkage_offset = bit (linkrel, 18);
	p -> object_map.linkage_length = bit (link_pos, 18);
	p -> object_map.static_offset = bit (fixed (linkrel + size (virgin_linkage_header), 18), 18);
	p -> object_map.static_length = bit (fixed (begin_links - size (virgin_linkage_header), 18), 18);
	p -> object_map.symbol_offset = bit (symrel, 18);
	p -> object_map.symbol_length = bit (sym_pos, 18);

	p -> object_map.format.separate_static = "0"b;

	p -> object_map.format.relocatable = shared_globals.options.relocatable;

	p -> object_map.format.procedure, p -> object_map.format.standard = "1"b;

	addrel (p, size (p -> object_map)) -> map_ptr = bit (n, 18);

	/* set next_free_object  and  return */

	next_free_object = n + size (p -> object_map) + 1;
	return;

get_subr_options:
     procedure (cs);

	/* Sets various global flags to correspond to the options in
	   effect for the given program unit. */

dcl  cs pointer;					/* Pointer to subprogram node */

	do_rounding = cs -> subprogram.options.do_rounding;
	init_auto_to_zero = cs -> subprogram.options.auto_zero;
	generate_profile = cs -> subprogram.options.profile;
	generate_long_profile = cs -> subprogram.options.long_profile;
	generate_symtab = cs -> subprogram.options.table | shared_globals.options.namelist_used;

	return;

     end get_subr_options;

/**** CONSTANT ALLOCATION ****/

alloc_constants:
     procedure (start, amt);

	/* Allocates constants in the text section */

dcl  (amt, n) fixed binary;
dcl  start fixed binary (18);

	n = amt;

	do con = start repeat c -> constant.next_constant while (con > 0);
	     c = addr (rands (con));
	     if ^c -> constant.allocated
	     then if c -> constant.allocate | c -> constant.passed_as_arg
		then do;
		     c -> constant.location = text_pos;
		     addrel (object_base, text_pos) -> image = addr (c -> constant.value) -> image;
		     text_pos = text_pos + n;
		     c -> constant.allocated = "1"b;
		     end;
	     end;

     end alloc_constants;

alloc_char_constants:
     procedure (start);

	/* Allocates character constants in the text section */

dcl  start fixed binary (18);
dcl  relocate_itp bit (1) aligned;

	relocate_itp = start = first_block_constant;

	do con = start repeat c -> char_constant.next_constant while (con > 0);
	     c = addr (rands (con));
	     if ^c -> char_constant.allocated
	     then if c -> char_constant.allocate | c -> char_constant.passed_as_arg
		then do;
		     if c -> char_constant.length = chars_per_dw
						/* a double word constant */
		     then text_pos = text_pos + mod (text_pos, 2);
						/* get even address */

		     amt = divide (c -> char_constant.length + chars_per_word - 1, chars_per_word, 17, 0);
		     c -> char_constant.location = text_pos;
		     addrel (object_base, text_pos) -> char_image = c -> char_constant.value;
		     if relocate_itp
		     then call relocate_itp_list;
		     text_pos = text_pos + amt;
		     c -> char_constant.allocated = "1"b;
		     end;
	     end;

     end alloc_char_constants;

relocate_itp_list:
     procedure ();

	/* Generates relocation bits for an itp argument list */

dcl  q pointer;
dcl  rscan fixed binary (18);

	do rscan = text_pos + 2 to text_pos + amt - 1 by 2;
	     q = addrel (object_base, rscan);

	     if q -> itp.itp_mod = ITP_mod		/* ITP word */
	     then if q -> itp.pr_no = lp
		then reloc_halfs (rscan + 1).left = rc_is18;
		else ;
	     else if q -> itp.itp_mod = "00"b3		/* ordinary indirect word */
	     then reloc_halfs (rscan).left = rc_t;
	     end;

     end relocate_itp_list;

assign_address_offset:
     procedure (p, inc, size, units);

	/* This procedure sets node.address.offset and node.location
	   from node.location and the offset increment inc. */

dcl  p pointer;					/* Node pointer */
dcl  inc fixed binary (18);				/* Offset increment */
dcl  size fixed binary (18);				/* Size of datum */
dcl  units fixed binary (3);				/* Units of size */

	call set_address_offset ((p), (p -> node.location + inc), (size), (units));

     end assign_address_offset;

set_address_offset:
     procedure (p, off, size, units);

	/* Sets p -> node.address.offset and p -> node.location to
	   the correct values for the offset off. */

dcl  p pointer;
dcl  (off, loc, offset) fixed binary (18);
dcl  size fixed binary (18);
dcl  units fixed binary (3);

	offset = off;

	if abs (offset) + get_size_in_words ((size), (units)) - 1 >= 16384
	then do;
	     loc = offset;
	     p -> node.large_address = "1"b;
	     p -> node.is_addressable = "0"b;
	     offset = mod (offset + 16384, 32768) - 16384;
	     p -> node.location = loc - offset;
	     end;

	p -> node.address.offset = offset;

     end set_address_offset;

get_size_in_words:
     procedure (size, units) returns (fixed binary (18));

	/* Converts a size in the specified units to word units */

dcl  size fixed binary (18);
dcl  (units, u) fixed binary (3);

dcl  factor (0:3) fixed binary (18) internal static options (constant) initial (1, 36, 4, 2);

	u = mod (units, 4);

	if u = word_units
	then return (size);				/* For speed */

	return (divide (size + factor (u) - 1, factor (u), 18, 0));

     end get_size_in_words;

get_size_in_bits:
     procedure (size, units) returns (fixed binary (18));

	/* Converts a size in the specified units to bits */

dcl  size fixed binary (18);
dcl  (units, u) fixed binary (3);

dcl  factor (0:3) fixed binary (18) internal static options (constant) initial (36, 1, 9, 18);

	u = mod (units, 4);
	return (size * factor (u));

     end get_size_in_bits;

save_before_analysis:
     procedure ();

	/* Saves vars neded for code generation. */

	hold_last_auto_loc = last_auto_loc;
	hold_text_pos = text_pos;

     end save_before_analysis;

restore_after_analysis:
     procedure ();

dcl  (cs, s) pointer;
dcl  sym fixed binary (18);

	/* Restores labels and entry points */

	do sym = first_entry_name repeat s -> symbol.next_symbol while (sym > 0);
	     s = addr (rands (sym));
	     s -> symbol.allocated = "0"b;
	     if s -> symbol.initial ^= 0
	     then addr (rands (s -> symbol.initial)) -> label.allocated = "0"b;
	     end;

	do cur_subprogram = first_subprogram repeat cs -> subprogram.next_subprogram while (cur_subprogram > 0);
	     cs = addr (rands (cur_subprogram));
	     do sym = cs -> subprogram.first_label repeat s -> label.next_label while (sym > 0);
		s = addr (rands (sym));
		s -> label.allocated = "0"b;
		end;
	     end;

	/* Restore saved values. */

	if generate_long_profile
	then profile_pos = size (long_profile_header);
	else profile_pos = profile_start;
	text_pos = hold_text_pos;
	last_auto_loc = hold_last_auto_loc;

     end restore_after_analysis;

assign_storage:
     procedure ();

	/* STORAGE ALLOCATOR

	   subprogram.storage_info is organized into 17 buckets to aid in
	   storage allocation.   The buckets are assigned as follows:

	   1	auto	double	init
	   2	auto	single	init
	   3	auto	double
	   4	auto	single
	   5	static	double	init
	   6	static	single	init
	   7	static	double
	   8	static	single
	   9	common & external constants
	   10	parameters
	   11	others
	   12	not allocated
	   13	Large Array Automatic
	   14	Large Array Static
	   15	Very Large Array Automatic
	   16	Very Large Array Static
	   17	Very Large Array Common
	*/

dcl  (cs, h, os, clp, psp, psap, s, ssp) pointer;
dcl  (hdr, sym, i, vsize, other_sym) fixed binary (18);
dcl  loc fixed binary (18);
dcl  not_found bit (1) aligned;
dcl  alloc_ps bit (1) aligned;

%include relocation_bits;

	/* 78.06.12 The parse now sets the following fields formerly set by the storage allocator.
	   Note that these fields are only set for those variables that need them:

	   symbol.data_type
	   symbol.element_size
	   symbol.auto		} One of these is set but only if the symbol
	   symbol.static		} is a variable without a storage class
	*/

	last_auto_loc = first_auto_loc;

	/* link_pos is the current offset of linkage entries from the end of static
	   for the duration of external assignement.  Then it transforms to be the
	   current address in the linkage section of relocation of static.
	   linkage_pad is the space which is occupied by the
	   LA and VLA base pointers for static variables.  linkage_pad delineates a
	   section which is within static, but which is not filled with normal variables. */

	linkage_pad = 0;

	Area_create_first, Area_init_first = -1;	/* flag off */

	alloc_ps, alloc_auto_cleanup = "0"b;

	/* setup for cleanup of VLA common processing lists */

	on cleanup call cleanup_VLA_common;

	/* allocate entry points */

	do sym = first_entry_name repeat s -> symbol.next_symbol while (sym > 0);
	     s = addr (rands (sym));

	     s -> symbol.operand_type = entry_type;
	     s -> symbol.hash_chain = 0;
	     s -> symbol.is_addressable = "1"b;
	     s -> symbol.reloc = rc_t;

	     /* associate a quick entry point with a subprogram entry pt */

	     if s -> symbol.name ^= main_entry_point_name
	     then s -> symbol.initial = create_rel_constant (null);
	     end;

	/* do allocation for each subprogram */

	do cur_subprogram = first_subprogram repeat cs -> subprogram.next_subprogram while (cur_subprogram > 0);
	     cs = addr (rands (cur_subprogram));
	     call get_subr_options (cs);

	     /* see if ps needed */

	     alloc_ps = alloc_ps | cs -> subprogram.need_PS;

	     /* allocate labels */

	     do sym = cs -> subprogram.first_label repeat s -> label.next_label while (sym > 0);
		s = addr (rands (sym));
		s -> label.is_addressable = "1"b;
		s -> label.reloc = rc_t;
		end;

	     /* initialize storage info */

	     unspec (cs -> subprogram.storage_info) = "0"b;

	     /* Allocate vars in LA chain */

	     hdr = cs -> subprogram.LA_chain;
	     do while (hdr > 0);
		h = addr (rands (hdr));
		if h -> header.allocate
		then do;
		     h -> header.needs_pointer = "1"b;
		     unspec (h -> header.address) = ext_base_on;
		     h -> header.allocated = "1"b;

		     call alloc_members;

		     h -> header.reloc = RI_mod;

		     /* Allocate the unpacked pointer storage in either static or automatic */

		     if h -> header.static
		     then do;
			i = 14;			/* LA static */
			if mod (linkage_pad + size (virgin_linkage_header), 2) ^= 0
			then linkage_pad = linkage_pad + 1;
			h -> header.location = linkage_pad + size (virgin_linkage_header);
			h -> header.base = lp;
			linkage_pad = linkage_pad + 2;/* assign double word */
			end;
		     else do;
			i = 13;			/* LA auto */
			if mod (last_auto_loc, 2) ^= 0
			then last_auto_loc = last_auto_loc + 1;
						/* even word aligned */

			h -> header.location = last_auto_loc;
			h -> header.base = sp;
			last_auto_loc = last_auto_loc + 2;
			end;


		     call create_storage_entry (h);

		     /* relocate members of Large Arrays */

		     do sym = h -> header.first_element repeat s -> symbol.next_member while (sym > 0);
			s = addr (rands (sym));
			call assign_address_offset (s, 0, (s -> symbol.element_size), (s -> symbol.units));
			end;

		     if h -> header.initialed
		     then call list_initialize (addrel (object_base, text_pos), hdr, text_pos);

		     /* thread the block on the LA lists */

		     if cs -> subprogram.storage_info.last (i) = 0
		     then cs -> subprogram.storage_info.first (i) = hdr;
		     else addr (rands (cs -> subprogram.storage_info.last (i))) -> header.next_header = hdr;
		     cs -> subprogram.storage_info.last (i) = hdr;

		     end;

		/* on to the next header */

		hdr = h -> header.next_header;
		h -> header.next_header = 0;
		end;

	     /* Allocate vars in VLA chain */

	     hdr = cs -> subprogram.VLA_chain;
	     do while (hdr > 0);
		h = addr (rands (hdr));
		if h -> header.allocate
		then do;
		     h -> header.allocated = "1"b;
		     h -> header.needs_pointer = "1"b;
		     unspec (h -> header.address) = ext_base_on;
		     if h -> header.automatic
		     then h -> header.address.base = sp;
		     else do;
			h -> header.address.base = lp;
			h -> header.reloc = rc_is15;
			end;

		     call alloc_members;

		     /*  Allocate the base addressor.  */

		     s = addr (rands (h -> header.VLA_base_addressor));
		     s -> symbol.is_addressable = "1"b;
		     s -> symbol.allocated = "1"b;
		     s -> symbol.address = h -> header.address;
		     s -> symbol.reloc = h -> header.reloc;

		     if h -> header.in_common
		     then do;
			i = 17;			/* VLA common */
			call note_VLA_common (h);
			end;
		     else do;

			/* Allocate the addressor storage in either static or automatic */

			if h -> header.static
			then do;
			     i = 16;		/* VLA static */
			     h -> header.location, h -> header.address.offset =
				linkage_pad + size (virgin_linkage_header);
			     linkage_pad = linkage_pad + 1;
						/* space for base addressor */
			     end;
			else do;
			     i = 15;		/* VLA auto */

			     h -> header.location, h -> header.address.offset = last_auto_loc;
			     last_auto_loc = last_auto_loc + 1;
						/* space for base addressor */
			     end;
			call set_address_offset (s, (h -> header.location), 1, word_units);
			call create_storage_entry (h);
			if h -> header.initialed
			then call list_initialize (addrel (object_base, text_pos), hdr, text_pos);
			end;

		     /* thread the block on the VLA lists */

		     if cs -> subprogram.storage_info.last (i) = 0
		     then cs -> subprogram.storage_info.first (i) = hdr;
		     else addr (rands (cs -> subprogram.storage_info.last (i))) -> header.next_header = hdr;
		     cs -> subprogram.storage_info.last (i) = hdr;

		     end;

		/* on to the next header */

		hdr = h -> header.next_header;
		h -> header.next_header = 0;
		end;

	     /* Allocate vars in common chain */

	     hdr = cs -> subprogram.common_chain;
	     do while (hdr > 0);
		h = addr (rands (hdr));
		if h -> header.allocate
		then do;
		     h -> header.needs_pointer = "1"b;
		     unspec (h -> header.address) = ext_base_on;
		     h -> header.allocated = "1"b;

		     call alloc_members;

		     h -> header.location = alloc_external (h);

		     /* thread the block on the linkage list */

		     if cs -> subprogram.storage_info.last (9) = 0
		     then cs -> subprogram.storage_info.first (9) = hdr;
		     else addr (rands (cs -> subprogram.storage_info.last (9))) -> header.next_header = hdr;
		     cs -> subprogram.storage_info.last (9) = hdr;

		     end;

		/* on to the next header */

		hdr = h -> header.next_header;
		h -> header.next_header = 0;
		end;

	     /* Allocate other equivalence blocks */

	     hdr = cs -> subprogram.equiv_chain;
	     do while (hdr > 0);
		h = addr (rands (hdr));
		if h -> header.allocate
		then do;

		     /* get subclass of equivalence group */

		     if h -> header.even
		     then i = 1;
		     else i = 2;
		     if ^h -> header.initialed
		     then i = i + 2;
		     if h -> header.static
		     then i = i + 4;

		     /* allocate */

		     if h -> header.odd
		     then if mod (cs -> subprogram.next_loc (i), 2) = 0
			then cs -> subprogram.next_loc (i) = cs -> subprogram.next_loc (i) + 1;

		     loc = cs -> subprogram.next_loc (i);
		     cs -> subprogram.next_loc (i) = cs -> subprogram.next_loc (i) + h -> header.length;
		     if mod (i, 2) ^= 0
		     then cs -> subprogram.next_loc (i) = cs -> subprogram.next_loc (i) + mod (h -> header.length, 2);


		     unspec (h -> header.address) = ext_base_on;
		     h -> header.location = loc;
		     if h -> header.static
		     then do;
			h -> header.base = lp;
			h -> header.reloc = rc_is15;
			end;
		     else h -> header.base = sp;
		     h -> header.is_addressable = "1"b;
		     h -> header.allocated = "1"b;

		     /* allocate elements of equiv chain */

		     call alloc_members;
		     end;

		else i = 12;

		/* thread the header in */

		if cs -> subprogram.storage_info.last (i) = 0
		then cs -> subprogram.storage_info.first (i) = hdr;
		else addr (rands (cs -> subprogram.storage_info.last (i))) -> header.next_header = hdr;
		cs -> subprogram.storage_info.last (i) = hdr;

		hdr = h -> header.next_header;
		h -> header.next_header = 0;
		end;

	     /* Allocate non-equivalenced symbols */

	     sym = cs -> subprogram.first_symbol;
	     do while (sym > 0);
		s = addr (rands (sym));
		if ^s -> symbol.allocated
		then do;
		     if s -> symbol.parameter
		     then s -> symbol.hash_chain = 0;	/* Required by 'make_symbol_descriptor'. */

		     /* Fix up request for 'PARAMETER' variables fully probe-able by allocating if
		        we want a symbol table. */

		     if s -> symbol.named_constant & cs -> subprogram.options.table
		     then do;
			s -> symbol.allocate = "1"b;
			addr (rands (s -> symbol.initial)) -> node.allocate = "1"b;
			end;

		     if s -> symbol.allocate
		     then do;
			unspec (s -> symbol.address) = "0"b;

			s -> symbol.hash_chain = 0;

			if s -> symbol.stmnt_func
			then do;
			     s -> symbol.operand_type = statement_function;
			     i = 11;
			     end;
			else if s -> symbol.builtin
			then do;
			     s -> symbol.operand_type = bif;
			     i = 11;
			     end;
			else if s -> symbol.named_constant
			then i = 11;
			else if s -> symbol.namelist
			then do;
			     s -> label.location = text_pos;
			     s -> symbol.is_addressable = "1"b;
			     s -> symbol.reloc = rc_t;

			     vsize = divide (polish (s -> symbol.initial) + 4, 2, 17, 0);
			     text_pos = text_pos + vsize;

			     if last_namelist = 0
			     then first_namelist = sym;
			     else addr (rands (last_namelist)) -> symbol.next_member = sym;
			     last_namelist = sym;

			     i = 11;
			     end;
			else if s -> symbol.parameter | s -> symbol.stack_indirect
			then do;
			     i = 10;
			     if s -> symbol.external
			     then s -> symbol.operand_type = external;
			     else s -> symbol.operand_type = variable_type;

			     if s -> symbol.VLA
			     then do;

				/*  Allocate the base addressor of the VLA.  */
				other_sym = addr (rands (s -> symbol.dimension)) -> dimension.VLA_base_addressor;
				os = addr (rands (other_sym));
				os -> symbol.is_addressable = "1"b;
				os -> symbol.allocated = "1"b;
				unspec (os -> symbol.address) = ext_base_on;
				os -> symbol.address.base = sp;
				os -> symbol.address.offset = last_auto_loc;
				if ^VLA_is_256K
				then last_auto_loc = last_auto_loc + 1;

				/*  Allocate the packed ptr to the VLA.  */
				if last_auto_loc > max_address_offset
				then call print_message (414, "The location of a VLA parameter base pointer",
					max_address_offset - bias);
				s -> symbol.needs_pointer = "1"b;
				s -> symbol.address.base = sp;
				s -> symbol.address.offset = last_auto_loc;
				last_auto_loc = last_auto_loc + 1;
				s -> symbol.location = s -> symbol.location * 2;
				end;

			     else if s -> symbol.stack_indirect
			     then do;

				/* multiple positions -- we need an auto
				   ptr to point at the parameter */

				if mod (last_auto_loc, 2) ^= 0
				then last_auto_loc = last_auto_loc + 1;
						/* even word aligned */
				s -> symbol.location = last_auto_loc;
				last_auto_loc = last_auto_loc + 2;
				if last_auto_loc > max_stack_size
				then call print_message (414,
					"in making multiple position parameter temporary the stack frame",
					max_stack_size - bias);
				end;

			     else			/*  the actual ptr location is twice the parameter number */
				s -> symbol.location = s -> symbol.location * 2;

			     /* set up address field */

			     s -> symbol.ext_base = "1"b;

			     if s -> symbol.dimensioned
			     then do;
				s -> symbol.needs_pointer = "1"b;
				vsize = get_array_size (s);
				end;
			     else if s -> symbol.data_type = cmpx_mode
			     then s -> symbol.needs_pointer = "1"b;
			     else if s -> symbol.data_type = char_mode
			     then do;
				s -> symbol.needs_pointer = "1"b;
				if s -> symbol.variable_extents | s -> symbol.star_extents
				then if s -> symbol.needs_descriptors | s -> symbol.passed_as_arg
					| s -> symbol.put_in_symtab | shared_globals.options.table
				     then vsize = make_symbol_descriptor (fixed (rel (s), 18));
				end;
			     else do;
				if ^s -> symbol.VLA
				then do;
				     s -> symbol.address.offset = s -> symbol.location;
				     s -> symbol.tag = RI_mod;
						/* RI */
				     end;
				else s -> symbol.tag = rc_a;
						/* stack */
				if s -> symbol.stack_indirect
				then do;
				     s -> symbol.address.base = sp;
				     s -> symbol.is_addressable = "1"b;
				     end;
				end;
			     end;
			else if s -> symbol.external
			then do;

			     /* function or subroutine reference */

			     s -> symbol.operand_type = external;

			     /* check if name is on subprogram in this compilation */

			     not_found = "1"b;
			     other_sym = first_entry_name;
			     do while (other_sym > 0 & not_found);
				os = addr (rands (other_sym));
				if s -> symbol.name = os -> symbol.name
				then not_found = "0"b;
				else other_sym = os -> symbol.next_symbol;
				end;

			     if not_found
			     then do;
				s -> symbol.ext_base = "1"b;
				s -> symbol.base = lp;
				s -> symbol.location = alloc_external (s);
				s -> symbol.tag = RI_mod;
						/* RI */
				s -> symbol.reloc = rc_lp15;
				s -> symbol.is_addressable = "1"b;
				end;

			     else do;
				s -> symbol.is_addressable = "0"b;
				s -> symbol.reloc = rc_t;
				s -> symbol.initial = other_sym;
				s -> symbol.needs_descriptors = os -> symbol.needs_descriptors;
				end;

			     i = 9;
			     end;
			else do;

			     /* data type and storage class (must be auto or static) assigned by the parse */

			     s -> symbol.operand_type = variable_type;

			     if s -> symbol.dimensioned
			     then vsize = get_array_size (s);
			     else vsize = get_size_in_words ((s -> symbol.element_size), (s -> symbol.units));

			     /* get subclass */

			     if data_type_size (s -> symbol.data_type) = 2
			     then i = 1;
			     else i = 2;
			     if ^s -> symbol.initialed
			     then i = i + 2;
			     if s -> symbol.static
			     then i = i + 4;

			     /* allocate */

			     loc = cs -> subprogram.next_loc (i);
			     cs -> subprogram.next_loc (i) = cs -> subprogram.next_loc (i) + vsize;

			     /* set up addressing */

			     if s -> symbol.static
			     then do;
				s -> symbol.base = lp;
				s -> symbol.reloc = rc_is15;
				end;
			     else s -> symbol.base = sp;
			     s -> symbol.location = loc;
			     s -> symbol.ext_base = "1"b;

			     s -> symbol.is_addressable = "1"b;
			     end;

			/* set allocated bit */

			s -> symbol.allocated = "1"b;
			end;

		     else i = 12;

		     /* thread symbol into new list */

		     if cs -> subprogram.storage_info.last (i) = 0
		     then cs -> subprogram.storage_info.first (i) = sym;
		     else addr (rands (cs -> subprogram.storage_info.last (i))) -> symbol.next_symbol = sym;
		     cs -> subprogram.storage_info.last (i) = sym;
		     end;

		sym = s -> symbol.next_symbol;
		s -> symbol.next_symbol = 0;
		end;

	     end;

	/* Allocate <*symbol>|0 link, if necessary */

	if generate_symtab
	then do;

	     /* compile_link depends on symbol.name_length being 0 */

	     builtins (9) = create_node (symbol_node, size (symbol));
	     ssp = addr (rands (builtins (9)));
	     ssp -> symbol.operand_type = dummy;
	     ssp -> symbol.by_compiler = "1"b;
	     ssp -> symbol.external, ssp -> symbol.allocate, ssp -> symbol.allocated, ssp -> symbol.is_addressable,
		ssp -> symbol.ext_base = "1"b;
	     ssp -> symbol.base = lp;
	     ssp -> symbol.tag = RI_mod;		/* RI */
	     ssp -> symbol.reloc = rc_lp15;
	     ssp -> symbol.location = alloc_external (ssp);
	     end;
	else builtins (9) = 0;

	/* If a ps is needed, allocate it first to prevent problems with 16K boundary.
	   ps must be in automatic storage because namelist, err=, and end= require current stack
	   ptr to be in ps at all times, even after return from a->b->a segment flow.  */

	if alloc_ps
	then do;
	     builtins (2) = create_node (symbol_node, size (symbol));
	     psp = addr (rands (builtins (2)));
	     psp -> symbol.operand_type = dummy;
	     psp -> symbol.by_compiler = "1"b;
	     psp -> symbol.automatic, psp -> symbol.allocate, psp -> symbol.allocated, psp -> symbol.is_addressable,
		psp -> symbol.ext_base = "1"b;
	     psp -> symbol.base = sp;
	     psp -> symbol.reloc = rc_a;
	     last_auto_loc = divide (last_auto_loc + 1, 2, 17, 0) * 2;
						/* EVEN WORD NEEDED */
	     call assign_address_offset (psp, last_auto_loc, 48, word_units);
	     last_auto_loc = last_auto_loc + 48;
	     if last_auto_loc > max_stack_size
	     then call print_message (414, "in making parameter storage for IO the stack frame", max_stack_size - bias);

	     /*	Build a symbol that overlays the PS at the field buffer_p (offset 20b3). This symbol
	        is used to load the value of this pointer by the object segment. */

	     builtins (10) = create_node (symbol_node, size (symbol));
	     psap = addr (rands (builtins (10)));
	     psap -> symbol = psp -> symbol;		/* use PS symbol as template to create this one */
	     psap -> symbol.address.offset = psap -> symbol.address.offset + 16;
						/* = 20b3 */
	     end;

	else builtins (2), builtins (10) = 0;

	/* If a cleanup body is needed, allocate it.  */

	if alloc_auto_cleanup
	then do;
	     cleanup_body_address = create_node (symbol_node, size (symbol));
	     clp = addr (rands (cleanup_body_address));
	     clp -> symbol.operand_type = dummy;
	     clp -> symbol.by_compiler = "1"b;
	     clp -> symbol.automatic, clp -> symbol.allocate, clp -> symbol.allocated, clp -> symbol.is_addressable,
		clp -> symbol.ext_base = "1"b;
	     clp -> symbol.base = sp;
	     clp -> symbol.reloc = rc_a;
	     last_auto_loc = divide (last_auto_loc + 1, 2, 17, 0) * 2;
						/* EVEN WORD NEEDED */
	     call assign_address_offset (clp, last_auto_loc, 8, word_units);
	     cleanup_body_address = last_auto_loc;
	     last_auto_loc = last_auto_loc + 8;
	     if last_auto_loc > max_stack_size
	     then call print_message (414, "in making cleanup body the stack frame", max_stack_size - bias);
	     end;
	else cleanup_body_address = 0;

	/* Allocate space for all VLA COMMON */

	call allocate_VLA_common;

	/* All subprograms done, relocate auto & static items */

	link_pos = divide (size (virgin_linkage_header) + linkage_pad + 1, 2, 18, 0) * 2;
	first_auto_var_loc = last_auto_loc;

	/* now relocate all other static and auto items */

	call relocate (1, last_auto_loc, max_stack_size, "stack frame");
	call relocate (5, link_pos, max_linkage_size, "linkage section");

	/* allocate profile space, if -profile */

	if generate_profile
	then do;
	     profile_start, profile_pos = link_pos;
	     if generate_long_profile
	     then do;
		profile_pos = size (long_profile_header);
		link_pos = link_pos + size (long_profile_header) + size (long_profile_entry) * (profile_size + 1);
		end;
	     else link_pos = link_pos + size (profile_entry) * (profile_size + 1);

	     link_pos = link_pos + mod (link_pos, 2);
	     if link_pos > max_linkage_size
	     then call print_message (414, "when allocating PROFILE information the linkage section",
		     char (max_linkage_size));
	     end;

	/* Finally, relocate common + external refs */

	begin_links = link_pos;

	do cur_subprogram = first_subprogram repeat cs -> subprogram.next_subprogram while (cur_subprogram > 0);
	     cs = addr (rands (cur_subprogram));
	     call get_subr_options (cs);

	     /* relocate external refs for VLA common */

	     do hdr = cs -> subprogram.storage_info.first (17) repeat h -> node.next while (hdr > 0);
		h = addr (rands (hdr));
		h -> node.location = h -> node.location + link_pos;
		end;

	     /* relocate common and external */
	     do hdr = cs -> subprogram.storage_info.first (9) repeat h -> node.next while (hdr > 0);
		h = addr (rands (hdr));

		if h -> node.node_type = header_node
		then do;
		     h -> node.location = h -> node.location + link_pos;
		     do sym = h -> header.first_element repeat s -> symbol.next_member while (sym > 0);
			s = addr (rands (sym));
			call assign_address_offset (s, 0, (s -> symbol.element_size), (s -> symbol.units));
			end;
		     end;

		else do;
		     if h -> symbol.initial = 0
		     then call assign_address_offset (h, link_pos, 2, word_units);
		     else h -> symbol.allocated = "0"b;
		     end;
		end;


	     end;


	/* Relocate the link pointer in the 'create_entry' for common. */

	call VLA_reloc_common_link;


	if generate_symtab
	then call assign_address_offset (ssp, link_pos, 2, word_units);

	link_pos = link_pos + (next_free_polish - begin_external_list) - ((next_free_polish - begin_external_list) / 3);
						/* i.e., two words per link */
	if link_pos > max_linkage_size
	then call print_message (414,
		"after allocating SYMTAB space for " || addr (rands (cs -> subprogram.symbol)) -> symbol.name
		|| " the linkage section", char (max_linkage_size));

	return;

alloc_external:
     procedure (pt) returns (fixed binary (18));

	/* Searches the external_list to see if a common block or
	   external reference has already been allocated before
	   allocating a new link to it.

	   The current implementation for the external list consists of
	   three items per external variable. The first item is a pointer
	   to a symbol node (for external entry points) or a pointer to
	   a header node (for common blocks). The second item is only
	   used for common blocks and specifies the (maximum) length for
	   the common block.  The third item is also only used for common
	   block and indicates the units (words or characters of the
	   maximum length. */

dcl  (p, pt) pointer;
dcl  loc fixed binary (18);
dcl  i fixed binary (18);
dcl  ceil builtin;
dcl  header_length fixed binary (24);

	p = pt;

	if p -> node.node_type = symbol_node
	then do i = begin_external_list to next_free_polish - 1 by 3;
		if ext_ref (i) -> node.node_type = symbol_node
		then if p -> symbol.name = ext_ref (i) -> symbol.name
		     then return (ext_ref (i) -> symbol.location);
		end;

	else do i = begin_external_list to next_free_polish - 1 by 3;
		if ext_ref (i) -> node.node_type = header_node
		then if p -> header.block_name = ext_ref (i) -> header.block_name
		     then do;
			loc = ext_ref (i) -> header.location;

			if p -> header.block_name = blank_common_name
			then do;
			     if p -> header.units = polish (i + 2)
			     then header_length = p -> header.length;
			     else if polish (i + 2) = word_units
			     then header_length = ceil (p -> header.length / 4);
			     else header_length = p -> header.length * 4;
						/* change to character units */
			     if header_length > polish (i + 1)
						/* current max length */
			     then polish (i + 1) = header_length;
						/* update max length for unlabelled common */
			     end;
			else do;
			     if p -> header.units = polish (i + 2)
			     then header_length = p -> header.length;
			     else if polish (i + 2) = word_units
			     then header_length = ceil (p -> header.length / 4);
			     else header_length = p -> header.length * 4;
						/* change to character units */
			     if header_length > polish (i + 1)
						/* current max length for block */
			     then do;
				polish (i + 1) = header_length;
						/* update length for common block */
				if polish (i + 2) = word_units
				then call print_message (426, fixed (rel (p), 18), ltrim (char (header_length)),
					"words");
				else call print_message (426, fixed (rel (p), 18), ltrim (char (header_length)),
					"characters");
				end;
			     else if header_length < polish (i + 1)
						/* check for different length */
			     then call print_message (434, fixed (rel (p), 18));

			     if p -> header.initialed
			     then if ext_ref (i) -> header.initialed
				then call print_message (432, fixed (rel (p), 18));
				else ext_ref (i) = p;
			     end;

			return (loc);
			end;
		end;

	/* allocate new entry in external list */

	if next_free_polish + 2 < polish_max_len
	then do;
	     ext_ref (next_free_polish) = p;

	     if p -> node.node_type = header_node	/* for common blocks, save block length */
	     then do;
		polish (next_free_polish + 1) = p -> header.length;
		polish (next_free_polish + 2) = p -> header.units;
		end;
	     next_free_polish = next_free_polish + 3;

	     loc = link_pos;
	     link_pos = link_pos + 2;
	     if link_pos > max_linkage_size
	     then call print_message (414, "linkage section", char (max_linkage_size));

	     return (loc);
	     end;

	else call print_message (407, "polish region", char (polish_max_len));

     end alloc_external;

alloc_members:
     procedure ();

	/* Allocates members of common blocks and equivalence groups. */

	do sym = h -> header.first_element repeat s -> symbol.next_member while (sym > 0);
	     s = addr (rands (sym));
	     substr (string (s -> symbol.storage_class), 1, 3) = string (h -> header.storage_class);
	     unspec (s -> symbol.address) = unspec (h -> header.address);
	     s -> symbol.reloc = h -> header.reloc;
	     if s -> symbol.units = char_units
	     then do;
		s -> symbol.location = h -> header.location + divide (s -> symbol.offset, chars_per_word, 18, 0);
		s -> symbol.address.char_num = mod (s -> symbol.offset, chars_per_word);
		end;
	     else s -> symbol.location = h -> header.location + s -> symbol.offset;
	     s -> symbol.operand_type = variable_type;
	     string (s -> symbol.addressing_bits) = string (h -> header.addressing_bits);
	     s -> symbol.hash_chain = 0;
	     if s -> symbol.dimensioned
	     then vsize = get_array_size (s);
	     end;

     end alloc_members;

create_storage_entry:
     proc (h);

	/* Purpose:  Create a creation list entry in the text section, and link it to
	   the last such entry.  Information required is taken from the chain
	   header supplied. */


dcl  h ptr;					/* Incoming header pointer */

dcl  cur_pos fixed bin (18) unsigned;			/* current position in text section */
dcl  listp ptr;
dcl  i fixed bin;


dcl  (currentsize, length) builtin;

	call make_create_entry (h);

	if h -> header.VLA				/* setup pointers */
	then do sym = h -> header.first_element repeat s -> symbol.next_member while (sym > 0);
		s = addr (rands (sym));
		if s -> symbol.offset = 0 & VLA_is_256K
		then call set_address_offset (s, (h -> header.location), 1, word_units);
		else do;
		     listp -> create_entry.pointer_count = listp -> create_entry.pointer_count + 1;
		     call set_address_offset (s, h -> header.location + listp -> create_entry.pointer_count, 1,
			word_units);
		     listp -> create_entry.pointer_offsets (listp -> create_entry.pointer_count).offset =
			s -> symbol.offset;
		     if h -> header.static
		     then linkage_pad = linkage_pad + 1;
		     else last_auto_loc = last_auto_loc + 1;

		     /* save the symbol name for the listing */
		     if assembly_list
		     then do;
			cur_pos =
			     fixed (
			     rel (
			     addr (listp -> create_entry.pointer_offsets (listp -> create_entry.pointer_count))));
			a_name (cur_pos) = fixed (rel (s));
			end;
		     end;
		end;

	/* increment past all information */

	text_pos = text_pos + currentsize (listp -> create_entry);
	return;

note_VLA_common:
     entry (h);


	/* Take note of common blocks in VLA common, and combine them into single
	   composite representations for each common of every definition of that
	   common.  This means determining the maximum length, the number of unique
	   offsets into the common (to build pointer information), and any init
	   information. */

dcl  chain_head ptr;				/* head of current chain */
dcl  hdr ptr;					/* current entry node */
dcl  looping bit (1);				/* scanning chain */
dcl  s ptr;					/* current symbol */
dcl  sym fixed bin (18);				/* current symbol node */
dcl  this_chain ptr;				/* last header of current chain */


	/* entry for headers and symbols. */

dcl  1 entry based (hdr),
       2 next ptr,					/* next entry in header list */
       2 chain ptr,					/* next entry in chain */
       2 node ptr,					/* pointer node in rands */
       2 header bit (1) unaligned,			/* node is a header */
       2 offset fixed bin (35) unsigned unaligned;	/* symbol offset */

	if first_header = null ()			/* no list */
	then goto create_header;

	/* find header chain. */

	do hdr = first_header repeat entry.next while (hdr ^= null ());
	     if entry.node -> header.block_name = h -> header.block_name
	     then goto add_header;			/* in right chain */
	     end /* do hdr */;

	/* at this point we don't have the right chain, but we do have a list */

	if hdr = null ()
	then do;

create_header:
	     call make_entry;
	     if first_header = null ()		/* chain to list */
	     then first_header = hdr;
	     else last_header -> entry.next = hdr;
	     last_header = hdr;
	     end;
	else do;					/* cannot enter through the do, it is just for blocking */

	     /* form maximum length */

add_header:
	     chain_head = hdr;
	     if h -> header.length ^= entry.node -> header.length
	     then do;

		/* form maximum common block lengths */

		if h -> header.block_name ^= blank_common_name
		then if h -> header.length > entry.node -> header.length
		     then call print_message (426, fixed (rel (h), 18), ltrim (char (h -> header.length)));
		     else call print_message (434, fixed (rel (h), 18));

		if h -> header.length > entry.node -> header.length
		then h -> header.length = entry.node -> header.length;
		end;


	     /* find end of headers in chain list. */

	     do hdr = chain_head repeat entry.chain while (entry.chain -> entry.header = "1"b);
		end;				/* leave hdr pointing at last header of chain */

	     /* Link new entry into chain as last header in header portion of chain */

	     this_chain = hdr;
	     call make_entry;
	     entry.chain = this_chain -> entry.chain;
	     this_chain -> entry.chain = hdr;
	     end;


	/* Add list of symbols to chain.  Last header of chain is at 'hdr' */
	/* This leaves a list sorted by symbol offset. */

add_symbols:
	chain_head = hdr;
	do sym = h -> header.first_element repeat s -> symbol.next_member while (sym > 0);
	     s = addr (rands (sym));

	     /* add total if chain is empty of symbols. */

	     this_chain = chain_head;
	     if this_chain -> entry.chain ^= null ()
	     then do;
		looping = "1"b;
		do while (looping);
		     this_chain = this_chain -> entry.chain;
		     if this_chain -> entry.chain = null ()
		     then looping = "0"b;
		     else if this_chain -> entry.chain -> entry.offset > s -> symbol.offset
		     then looping = "0"b;
		     end;
		end;

	     /* hdr points at add_point to chain */

	     call make_entry;
	     entry.offset = s -> symbol.offset;
	     entry.chain = this_chain -> entry.chain;
	     entry.node = s;
	     entry.header = "0"b;
	     this_chain -> entry.chain = hdr;
	     end /* do sym */;
	return;

	/*	   Assign Storage to VLA common. */
allocate_VLA_common:
     entry;

	/* Assign storage address and storage creation information.  This is done
	   by scanning the finalized lists and copying the maximum length through all
	   headers for the multiple uses of that common, then creating a storage
	   creation entry for the common, and then assigning a pointer location
	   to each unique offset, and copying that pointer location into the symbols
	   mapped into that unique offset.  At the same point a storage creation
	   pointer is created and assigned that offset.  Initialization information
	   is picked up in a separate pass through the symbols. */

dcl  common_length fixed bin (35);			/* common_length of the common block */
dcl  current_offset fixed bin (35);			/* current symbol offset processing */
dcl  location fixed bin (18);				/* location of packed pointers */

	/* scan commons */

	do chain_head = first_header repeat chain_head while (chain_head ^= null ());

	     /* pick up the maximum length and propagate it through the multiple copies of headers */

	     common_length = chain_head -> entry.node -> header.length;

	     /* 'header.location' is the normal location in which the
	        external link would be found and will be later relocated
	        and external reference made. */

	     /* At this point header.location is the pointer to the first PP. */

	     /* NOTE - you will see the strange construction 'copy ("0"b, 18 - length (x)) || x'
	        in setting 'reloc_halfs' in this code.  This is because of the use to two
	        different definitions for 'rc_t' and 'rc_lp18', one for 6-bits and the
	        other for 18-bits.  Why they have the same name I do not know, but I do know
	        that the binder is very unhappy to receive a 6-bit relocation value left
	        adjusted in an 18-bit field, hence the padding.  If some turkey changes the
	        definition in the future, and I get the 18-bitter, it will still work. */

	     location, chain_head -> entry.node -> header.location = linkage_pad + size (virgin_linkage_header);
	     linkage_pad = linkage_pad + 1;		/*  space for base addressor  */
	     call make_create_entry (chain_head -> entry.node);
	     chain_head -> entry.node -> header.location, listp -> create_entry.common_link =
		alloc_external (chain_head -> entry.node);
	     reloc_halfs (text_pos + 3).left = copy ("0"b, 18 - length (rc_lp18)) || rc_lp18;
	     call set_address_offset (addr (rands (chain_head -> entry.node -> header.VLA_base_addressor)), (location),
		1, word_units);

	     do hdr = chain_head -> entry.chain repeat entry.chain while (entry.header = "1"b);
		entry.node -> header.length = common_length;
		entry.node -> header.location = alloc_external (entry.node);
		call set_address_offset (addr (rands (entry.node -> header.VLA_base_addressor)), (location), 1,
		     word_units);
		end;

	     if VLA_is_256K
	     then current_offset = 0;			/*  Base addressor is a packed ptr to offset 0.  */
	     else current_offset = -1;		/*  Base addressor is logical address of offset 0.  */
	     i = 0;				/* current pointer */
	     do hdr = hdr repeat entry.chain while (hdr ^= null ());
		s = entry.node;
		if s -> symbol.offset ^= current_offset
		then i = i + 1;			/* count unique pointer */
		call set_address_offset (s, location + i, 1, word_units);

		/* Save a copy of the offset information */
		s -> symbol.addr_hold = substr (unspec (s -> symbol.address), 1, 18);

		/* create a pointer for all but possibly the first unique entry */

		if s -> symbol.offset ^= current_offset
		then do;
		     current_offset = s -> symbol.offset;
		     listp -> create_entry.pointer_count = i;
		     listp -> create_entry.pointer_offsets (i).offset = s -> symbol.offset;
		     linkage_pad = linkage_pad + 1;

		     /* save the symbol name for the listing */
		     if assembly_list
		     then do;
			cur_pos = fixed (rel (addr (listp -> create_entry.pointer_offsets (i))));
			a_name (cur_pos) = fixed (rel (s));
			end;
		     end /* do */;
		end /* do hdr */;

	     text_pos = text_pos + currentsize (listp -> create_entry);

	     chain_head = chain_head -> entry.next;
	     end /* do chain_head */;

	call cleanup_VLA_common;			/* Use common cleanup */
	return;

	/* Entry to relocate the link relative offset left in the create_entry for
	   common VLA, to become a true linkage section offset. */

VLA_reloc_common_link:
     entry;


	looping = "1"b;				/* loop through list */

	location = Area_create_first;
	if Area_create_first ^= -1
	then do while (looping = "1"b);
		listp = addrel (object_base, location);
		if listp -> create_entry.common
		then listp -> create_entry.common_link = listp -> create_entry.common_link + link_pos;
		location = listp -> create_entry.next;
		if location = 0
		then looping = "0"b;
		end;
	return;



cleanup_VLA_common:
     entry;

	/* Cleanup vla common allocation lists when cleanup encountered. */

	if first_header = null ()
	then return;

	do first_header = first_header repeat first_header while (first_header ^= null ());
	     chain_head = first_header;
	     first_header = first_header -> entry.next;
	     do this_chain = chain_head repeat this_chain while (this_chain ^= null ());
		hdr = this_chain;
		this_chain = entry.chain;
		free entry;
		end /* do this_chain */;
	     end /* do first_header */;

	return /* cleanup_VLA_common */;


	/* create an entry for a header/symbol */
make_entry:
     proc;

	allocate entry;
	entry.node = h;
	entry.chain, entry.next = null ();
	entry.offset = 0;
	entry.header = "1"b;
	return;
     end make_entry;				/*						   Make the basic creation list entry. */
make_create_entry:
     proc (h);

dcl  h ptr;
dcl  i fixed bin (18);				/* index in text */
dcl  last_listp ptr;				/* -> last create_entry */

	listp = addrel (object_base, text_pos);

	/* Set location of base pointer in section and set relocation of pointer */

	listp -> create_entry.location = h -> header.location;
	if h -> header.static | h -> header.in_common
	then reloc_halfs (text_pos).left = copy ("0"b, 18 - length (rc_is15)) || rc_is15;
	else if h -> header.automatic
	then reloc_halfs (text_pos).left = copy ("0"b, 18 - length (rc_a)) || rc_a;

	listp -> create_entry.auto = h -> header.automatic;
	listp -> create_entry.static = h -> header.static;
	listp -> create_entry.common = h -> header.in_common;
	listp -> create_entry.LA = h -> header.LA;
	listp -> create_entry.VLA = h -> header.VLA;
	listp -> create_entry.K256 = VLA_is_256K;
	listp -> create_entry.init = h -> header.initialed;
	listp -> create_entry.length = h -> header.length;
	listp -> create_entry.next = 0;
	listp -> create_entry.name_length = h -> header.name_length;
	if listp -> create_entry.name_length ^= 0
	then listp -> create_entry.block_name = h -> header.block_name;

	listp -> create_entry.pointer_count = 0;

	if h -> header.automatic
	then alloc_auto_cleanup = "1"b;		/* cleanup automatic LA's and VLA's */

	if Area_create_first < 0			/* flagged empty */
	then Area_create_first = text_pos;
	else do;

	     /* Link previous entry to this one and set relocation too. */

	     last_listp = addrel (object_base, Area_create_last);
	     last_listp -> create_entry.next = text_pos;
	     i = fixed (rel (addr (last_listp -> create_entry.next)), 18, 0) - fixed (rel (object_base), 18, 0);
	     reloc_halfs (i).left = copy ("0"b, 18 - length (rc_t)) || rc_t;
	     end;
	Area_create_last = text_pos;

     end make_create_entry;
     end create_storage_entry;

relocate:
     procedure (which, locn, limit, section_name);

	/* Relocates items in each bucket. */

dcl  which fixed binary (18),
     locn fixed binary (18),
     limit fixed binary (18),				/* limit of section */
     section_name char (*);				/* name of section */

dcl  (i, loc, start) fixed binary (18);

	loc = locn;

	do start = which to which + 2 by 2;
	     do cur_subprogram = first_subprogram repeat cs -> subprogram.next_subprogram while (cur_subprogram > 0);
		cs = addr (rands (cur_subprogram));
		call get_subr_options (cs);

		do i = start to start + 1;
		     cs -> subprogram.next_loc (i) = cs -> subprogram.next_loc (i) + loc;

		     do hdr = cs -> subprogram.storage_info.first (i) repeat h -> node.next while (hdr > 0);
			h = addr (rands (hdr));

			if h -> node.node_type = header_node
			then do;
			     call assign_address_offset (h, loc, 1, word_units);
			     do sym = h -> header.first_element repeat s -> symbol.next_member while (sym > 0);
				s = addr (rands (sym));
				call relocate_error (s);
				call assign_address_offset (s, loc, (s -> symbol.element_size),
				     (s -> symbol.units));
				end;
			     end;

			else do;
			     call relocate_error (h);
			     call assign_address_offset (h, loc, (h -> symbol.element_size), (h -> symbol.units));
			     end;
			end;

		     loc = cs -> subprogram.next_loc (i);
		     end;

		loc = loc + mod (loc, 2);
		end;
	     end;

	locn = loc;

	/* Test if variable will fit within region. */

relocate_error:
     proc (s);

dcl  s ptr;					/* pointer to node */
dcl  next_loc fixed bin (18);

	if s -> node.next ^= 0
	then next_loc = addr (rands (s -> node.next)) -> node.location;
	else next_loc = cs -> subprogram.next_loc (i) - loc;

	if loc + next_loc > limit
	then call print_message (414,
		"with relocation of " || s -> symbol.name || " in "
		|| addr (rands (cs -> subprogram.symbol)) -> symbol.name || " the " || section_name,
		ltrim (char (limit)));
     end relocate_error;
     end relocate;

get_array_size:
     procedure (pt) returns (fixed binary (18));

	/* Calculates the size of an array, and computes its virtual
	   origin if constant. */

dcl  (pt, s, d) pointer;
dcl  (cm, i, n, v) fixed binary (18);
dcl  ndims fixed binary (3);
dcl  constant_vo bit (1) aligned;

	n = 0;
	s = pt;
	d = addr (rands (s -> symbol.dimension));

	if ^s -> symbol.variable_extents & ^s -> symbol.star_extents
	then do;
	     d -> dimension.array_size = d -> dimension.element_count * s -> symbol.element_size;
	     d -> dimension.has_array_size = "1"b;
	     n = get_size_in_words ((d -> dimension.array_size), (s -> symbol.units));

	     /* calculate virtual origin */

	     v = 0;
	     cm = s -> symbol.element_size;
	     do i = 1 to d -> dimension.number_of_dims;
		v = v + cm * d -> dimension.lower_bound (i);
		cm = cm * d -> dimension.size (i);
		end;

	     d -> dimension.virtual_origin = v;
	     d -> dimension.has_virtual_origin = "1"b;
	     end;

	else do;

	     /* Make a descriptor for the array */

	     if s -> symbol.needs_descriptors | s -> symbol.put_in_symtab | shared_globals.options.table
	     then i = make_symbol_descriptor (fixed (rel (s), 18));

	     /* Allocate a symbol for the array size */

	     if ^d -> dimension.has_array_size
	     then do;
		d -> dimension.array_size = create_automatic_integer (cs);
		d -> dimension.has_array_size = "1"b;
		d -> dimension.variable_array_size = "1"b;
		end;

	     ndims = d -> dimension.number_of_dims;

	     /* Allocate a virtual origin symbol if necessary */

	     if ^d -> dimension.has_virtual_origin
	     then do;
		constant_vo = ^d -> dimension.v_bound (ndims).lower;
		do i = 1 to ndims - 1 while (constant_vo);
		     constant_vo = (string (d -> dimension.v_bound (i)) = "00"b);
		     end;
		if ^constant_vo | s -> symbol.star_extents
						/* either case requires vo */
		then do;
		     d -> dimension.virtual_origin = create_automatic_integer (cs);
		     d -> dimension.has_virtual_origin = "1"b;
		     d -> dimension.variable_virtual_origin = "1"b;
		     end;
		end;

	     /* Allocate symbols for dimension.size (*) */

	     if ^d -> dimension.has_dim_sizes
	     then do;
		do i = 1 to ndims - binary (d -> dimension.assumed_size, 1);
		     if string (d -> dimension.v_bound (i)) = "00"b
		     then d -> dimension.size (i) =
			     d -> dimension.upper_bound (i) - d -> dimension.lower_bound (i) + 1;
		     else if ^d -> dimension.v_bound (i).lower & d -> dimension.lower_bound (i) = 1
		     then d -> dimension.size (i) = d -> dimension.upper_bound (i);
		     else d -> dimension.size (i) = create_automatic_integer (cs);
		     end;
		d -> dimension.has_dim_sizes = "1"b;
		end;

	     end;

	return (n);

     end get_array_size;

     end assign_storage;

create_automatic_integer:
     procedure (cs) returns (fixed binary (18));

	/* Creates an automatic integer variable. */

dcl  sym fixed binary (18);
dcl  s pointer;
dcl  cs pointer;

	sym = create_node (symbol_node, size (symbol));
	s = addr (rands (sym));
	s -> symbol.data_type = int_mode;
	s -> symbol.by_compiler, s -> symbol.integer, s -> symbol.allocate, s -> symbol.automatic = "1"b;
	s -> symbol.element_size = 1;
	s -> symbol.units = word_units;

	addr (rands (cs -> subprogram.last_symbol)) -> node.next = sym;
	cs -> subprogram.last_symbol = sym;

	return (sym);

     end create_automatic_integer;

/**** CREATE_REL_CONSTANT ****/

create_rel_constant:
     procedure (cs) returns (fixed binary (18));

	/* Creates a rel_constant */

dcl  cs pointer;					/* current subprogram node */

dcl  var fixed binary (18);
dcl  p pointer;

%include relocation_bits;

	var = create_node (label_node, size (label));
	p = addr (rands (var));

	p -> label.operand_type = rel_constant;
	p -> label.reloc = rc_t;
	p -> label.referenced, p -> label.referenced_executable, p -> label.is_addressable = "1"b;

	if cs ^= null
	then do;
	     if cs -> subprogram.last_label = 0
	     then cs -> subprogram.first_label = var;
	     else addr (rands (cs -> subprogram.last_label)) -> label.next_label = var;
	     cs -> subprogram.last_label = var;
	     end;

	return (var);

     end create_rel_constant;

interpreter:
     procedure (p_analyzing);

	/* Written by R. A. Barnes 1 January 1976 */

dcl  (analyzing, p_analyzing) bit (1) aligned;		/* "1"b - Performing Register Usage Analysis
						   ``           and Global Register Allocation. */

dcl  base fixed bin (18);				/* subscript of arg1 */
dcl  top fixed bin (18);				/* subscript of op1 */

dcl  cur_frame ptr;					/* ptr to current procedure frame */
dcl  mac_base ptr;					/* ptr to base of macro segment */

dcl  cs ptr;					/* ptr to current subprogram node */
dcl  statement_ptr ptr;				/* ptr to current opt_statement node */
dcl  quad_ptr ptr;					/* ptr to current operator node */

dcl  cur_lp ptr;					/* ptr to current loop node */
dcl  fu ptr;					/* ptr to current flow_unit */
dcl  lp_msp ptr;					/* cur_lp -> loop.msp (mach state template) */

dcl  next_lp ptr;					/* ptr to loop we are about to enter */

dcl  imac fixed bin (18);				/* index into fort_opt_macros_ */
dcl  iquad fixed bin (18);				/* index into quadruples */
dcl  next_operand fixed bin (18);			/* Index to get next "scanned" operand. */

dcl  left fixed bin (18);				/* left half of macro instructiin */
dcl  mopnd fixed bin (18);				/* operand index in macro instruction */
dcl  mop fixed bin (18);

dcl  next_free_opt_ms ptr;				/* free chain of machine_state nodes in opt region */

dcl  avail_pregs fixed bin (4);			/* number of ptr registers in the pool */
dcl  avail_xregs fixed bin (4);			/* number of index registers in the pool */

dcl  desc_temp_chain fixed binary (18) unsigned;
dcl  op_code fixed bin (18);

dcl  discard fixed bin (18);
dcl  (i, k, n, op1, op2, next_base, relation, scan_proc, skip, temp, zarg, desc, eaq_name, sym) fixed bin (18);
dcl  regno fixed bin (3);
dcl  (cdt, dt, dt1, dt2) fixed bin (4);
dcl  xr fixed bin (3);
dcl  char1 character (1);

dcl  (p, st, lbl, s) ptr;
dcl  (b1, b2, err_flag, state_discarded) bit (1) aligned;
dcl  bit3 bit (3) aligned;
dcl  bit6 bit (6) aligned;

dcl  from_base_man bit (1) aligned;			/* "1"b if base_man_load_pr is active */

dcl  stack (300) fixed bin (18);

dcl  computed_virtual_origin (25) fixed binary (18);
dcl  virtual_origin_count fixed binary (17);

dcl  i_loop fixed bin;				/* index of loop being analyzed */
dcl  loop_vector_p ptr;				/* -> loop_vector */
dcl  n_loops fixed bin (18);				/* number of loops in loop_vector */
dcl  max_operators fixed bin (18);			/* length(obits) */
dcl  max_sym fixed bin (18);				/* length(bits) */

dcl  (
     fort_opt_macros_$first_scan,
     fort_opt_macros_$abort_list,
     fort_opt_macros_$error_macro
     ) bit (36) aligned ext static;

dcl  1 fort_opt_macros_$interpreter_macros (4) aligned ext static,
       2 entry fixed bin (17) unal,
       2 pad fixed bin (17) unal;

dcl  1 fort_opt_macros_$operator_table (109) aligned ext static,
       2 entry fixed bin (17) unal,
       2 pad fixed bin (17) unal;

dcl  1 fort_instruction_info_$fort_instruction_info_ (0:1023) aligned ext static,
       2 alters unaligned structure,
         3 A bit (1),
         3 Q bit (1),
         3 indicators bit (1),
         3 PR (6) bit (1),
         3 XR bit (8),				/* can't use (0:7) because of PL/I ERROR 338 */
         3 pad1 bit (1),
       2 directable bit (1) unaligned,
       2 pad2 bit (17) unaligned;

dcl  (
     variable_count init (-1),
     not_given init (-2)
     ) fixed bin (18) int static options (constant);

dcl  ERROR fixed bin (18) int static options (constant) init (-1);
						/* ERROR operand */

dcl  mask_left bit (36) aligned int static options (constant) init ("000000777777"b3);

dcl  (
     first_base initial (2),
     last_base initial (6),
     escape_index initial (1),
     first_index initial (2),
     last_index initial (7),
     linkage_ptr initial (36),
     arg_ptr initial (26),
     descriptor_ptr initial (34)
     ) fixed binary (18) internal static options (constant);

dcl  1 fort_opt_macros_$single_inst (158) aligned ext static like machine_instruction;

%include fort_single_inst_names;

dcl  dt_from_reg (20) fixed bin (4) int static options (constant)
	init (1, 5, 4, 2, 3, 2, 2, 1, 7, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5);

dcl  eaq_name_to_reg (20) fixed bin internal static options (constant)
	init (2, 1, 3, 3, 3, 3, 2, 1, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4);

dcl  (
     A initial (1),
     Q initial (2),
     EAQ initial (3),
     IND initial (4)
     ) fixed bin (18) internal static options (constant);

dcl  (
     in_q init (1),					/* integer value in the Q */
     in_a init (2),					/* logical value in the A */
     in_aq init (3),				/* complex value in the AQ */
     in_eaq init (4),				/* real value in the EAQ */
     in_deaq init (5),				/* dp value in the EAQ */
     in_ieaq init (6),				/* imag value in EAQ */
     in_iq init (7),				/* second word of doubleword in Q */
     in_ia init (8),				/* integer value in the A */
     in_tq init (9),				/* typeless value in the Q */
     in_ind init (10),				/* wildcard for logical value in IND */
     tze init (11),					/* .eq. */
     tnz init (12),					/* .ne. */
     tmi init (13),					/* .lt. */
     tpl init (14),					/* .ge. */
     tmoz init (15),				/* .le. */
     tpnz init (16),				/* .gt. */
     tnc init (17),					/* j_l_s */
     trc init (18),					/* j_ge_s */
     j_le_s init (19),				/* j_le_s */
     j_g_s init (20)				/* j_g_s */
     ) fixed bin (18) int static options (constant);

dcl  (						/* op_base equ 361 */
     VLA_words_per_seg initial (361 - 476),		/* SPECIAL conversion */
     allocate_char_string initial (361 + 0),
     reallocate_char_string initial (361 + 29),
     alloc_auto_adj initial (361 + 72),
     shorten_stack initial (361 + 163),
     long_profile initial (361 + 426),
     shorten_stack_protect_ind initial (361 + 451)
     ) fixed binary (14) internal static options (constant);

dcl  shorten_stack_mask bit (14) aligned internal static options (constant) initial ("01000000010000"b);
						/* Reserve pr1,x1 */

dcl  highest_ind_state fixed bin options (constant) int static init (19);

dcl  zero_for_dt (0:7) fixed bin (18);

dcl  function fixed bin (18) int static init (13) options (constant);

dcl  (
     check_subscript init (1),
     subscript_mpy init (2),
     move_eis init (3),
     check_stringrange init (4)
     ) fixed bin (18) int static options (constant);

dcl  entry_info_size fixed bin (18) int static init (7) options (constant);

dcl  descriptor_mask_addr bit (36) aligned internal static options (constant) initial ("000250000100"b3);
						/* pr0|168 = 000077777777 */

dcl  (result, source) bit (72) aligned;

dcl  based_integer fixed bin (35) based;

dcl  1 inst_address aligned like symbol.address;

dcl  1 saved_cat_address aligned like node.address automatic;
dcl  cat_offset_temp fixed binary (18);

dcl  char_temp char (8);

dcl  1 base_man_args,
       2 code fixed bin (18),
       2 variable fixed bin (18),
       2 offset fixed bin (18);

dcl  hold_pr_locks (6) bit (1) aligned;

dcl  1 loop_vector_st based (loop_vector_p) aligned,
       2 loop_vector (n_loops) pointer unaligned;

dcl  bits bit (max_sym) based aligned;			/* symbol bits */
dcl  obits bit (max_operators) based aligned;		/* operator bits */


dcl  int_image fixed bin (35) based;
dcl  real_image float bin (27) based;
dcl  dp_image float bin (63) based;
dcl  cmpx_image complex float bin (27) based;
dcl  bit_image bit (72) aligned based;

dcl  ind_word bit (36) aligned based;

dcl  1 current_ms like machine_state aligned;

dcl  1 loop_state based (lp_msp) aligned like machine_state;

dcl  1 proc_frame based (cur_frame) aligned,
       2 node_type fixed bin (4) unal,
       2 flags structure unaligned,
         3 func bit (1),
         3 scan_interpreter_frame,
	 4 interpreter_called bit (1) unal,
	 4 scan_called bit (1) unal,
         3 pad bit (28) unal,
       2 prev ptr unal,
       2 next ptr unal,
       2 return fixed bin (18),
       2 base fixed bin (18),
       2 error_label fixed bin (18),
       2 interpreter_return label local,
       2 nshort fixed bin (18),
       2 short (3) fixed bin (18);

	/* BEGIN Register Analysis Database */

dcl  1 ptr_data,
       2 local fixed bin,
       2 locked fixed bin,
       2 max_local fixed bin,
       2 max_locked fixed bin,
       2 n_global fixed bin,
       2 item_st structure aligned,
         3 item (100) ptr unaligned;

dcl  last_pr_locked_for_pl1_ops_arg fixed bin (3);

dcl  1 index_data like ptr_data;

dcl  ptr_hash_table (0:210) fixed bin (18);

	/* END Register Analysis Database */

dcl  1 hast based (addr (macro_instruction (imac))),
       2 instruction_word bit (36) aligned,
       2 half_array (100) fixed bin (17) unaligned;

dcl  1 macro_instruction (0:262143) based (mac_base) aligned,
       2 left fixed bin (17) unal,			/* left half - label or integer */
       2 operand fixed bin (3) unal,
       2 eaq_name fixed bin (5) unal,
       2 inhibit bit (1) unal,
       2 op_code bit (7) unal;

dcl  1 machine_instruction (0:262143) based (mac_base) aligned,
       2 operand fixed bin (3) unal,
       2 increment fixed bin (13) unal,
       2 op_code bit (10) unal,
       2 inhibit bit (1) unal,
       2 ext_base_and_tag unal,
         3 ext_base bit (1) unal,
         3 tag bit (6) unal;

dcl  1 macro_dt_inst (0:262143) based (mac_base) aligned,
       2 number fixed bin (17) unal,
       2 data_type fixed bin (9) unal,
       2 inhibit bit (1) unal,
       2 op_code bit (7) unal;

dcl  1 macro_bits_inst (0:262143) based (mac_base) aligned,
       2 left fixed bin (17) unal,
       2 bits bit (10) unal,
       2 inhibit bit (1) unal,
       2 op_code bit (7) unal;

dcl  1 macro_if_inst (0:262143) based (mac_base) aligned,
       2 left fixed bin (17) unal,
       2 operand fixed bin (3) unal,
       2 relation bit (3) unal,
       2 with fixed bin (2) unal,
       2 inhibit bit (1) unal,
       2 op_code bit (7) unal;

dcl  1 macro_regs_inst (0:262143) based (mac_base) aligned,
       2 regs bit (18) unal,
       2 pad bit (10) unal,
       2 inhibit bit (1) unal,
       2 op_code bit (7) unal;

dcl  1 macro_cond_inst (0:262143) based (mac_base) aligned,
       2 left bit (18) unal,
       2 operand bit (4) unal,
       2 pad bit (5) unal,
       2 if_test bit (1) unal,
       2 inhibit bit (1) unal,
       2 op_code bit (7) unal;

dcl  1 instruction (0:262143) aligned based (object_base),
       2 base bit (3) unal,
       2 offset fixed bin (14) unal,
       2 op bit (10) unal,
       2 inhibit bit (1) unal,
       2 ext_base_and_tag unal,
         3 ext_base bit (1) unal,
         3 tag bit (6) unal;

dcl  text_word (0:262143) bit (36) aligned based (object_base);

dcl  1 reloc (0:262143) aligned based (relocation_base),
       2 skip1 bit (12) unal,
       2 left_rel bit (6) unal,
       2 skip2 bit (12) unal,
       2 right_rel bit (6) unal;

dcl  1 half based aligned,
       2 left fixed bin (17) unal,
       2 right fixed bin (17) unal;

dcl  1 arg_list auto aligned,
       2 header aligned,
         3 arg_count fixed bin (17) unal,
         3 code bit (18) unal,
         3 desc_count fixed bin (17) unal,
         3 pad bit (18) unal,
       2 itp_list (254) like itp aligned;		/* Big enough for 127 args
						   and descriptors */

dcl  1 entry_descriptor aligned,
       2 type_bits bit (12) unaligned,
       2 char_size bit (24) unaligned;

dcl  1 floating_value auto aligned,
       2 exponent fixed binary (7) unaligned,
       2 mantissa bit (64) unaligned;

dcl  mantissa_of_power_of_fpbase bit (64);

dcl  (length, mod) builtin;

%include relocation_bits;

	/* copy in parameter and set up */

	analyzing = p_analyzing;

	if analyzing
	then do;
	     unspec (ptr_hash_table), unspec (ptr_data), unspec (index_data) = "0"b;
	     last_pr_locked_for_pl1_ops_arg = 0;
	     avail_pregs = last_base - first_base + 1;
	     avail_xregs = last_index - first_index + 1;
	     end;

	/* initialize cur_subprogram and friend */

	cur_subprogram = first_subprogram;

	cur_statement = -1;

	/* initialize constant builtins */

	builtins (0) = create_integer_constant (0);
	builtins (1) = create_integer_constant (1);
	builtins (5) = create_constant (dp_mode, unspec (null));
	builtins (6) = 0;
	builtins (7) = create_integer_constant (2);

	/* initialize array of zero constants */

	zero_for_dt (0) = ERROR;			/* for invalid register states */
	zero_for_dt (1) = builtins (0);		/* integer */
	addr (result) -> real_image = 0.0;
	zero_for_dt (2) = create_constant (real_mode, result);
						/* real */
	addr (result) -> dp_image = 0.0;
	zero_for_dt (3) = create_constant (dp_mode, result);
						/* double precision */
	addr (result) -> cmpx_image = 0.0;
	zero_for_dt (4) = create_constant (cmpx_mode, result);
						/* complex */
	result = "0"b;
	zero_for_dt (5) = create_constant (logical_mode, result);
						/* logical */
	zero_for_dt (6) = ERROR;			/* character */
	zero_for_dt (7) = builtins (0);		/* typeless */

	/* initialize automatic vars for this program */

	call initialize_auto;

	/* initialize builtins for auto template and overlay */

	char_constant_length = 0;			/* do not allocate the value field */

	if builtins (3) = 0
	then do;
	     builtins (3) = create_node (char_constant_node, size (char_constant));
	     p = addr (rands (builtins (3)));
	     p -> char_constant.operand_type = constant_type;
	     p -> char_constant.data_type = char_mode;
	     p -> char_constant.is_addressable, p -> char_constant.allocated = "1"b;
	     p -> char_constant.reloc = rc_t;
	     p -> char_constant.length =
		chars_per_word * (addr (rands (last_subprogram)) -> subprogram.next_loc (2) - first_auto_var_loc);
	     p -> char_constant.no_value_stored = "1"b;	/* value is already in the text */
	     end;
	else p = addr (rands (builtins (3)));

	p -> char_constant.location = auto_template;

	if builtins (4) = 0
	then do;
	     builtins (4) = create_node (array_ref_node, size (array_ref));
	     p = addr (rands (builtins (4)));
	     p -> array_ref.operand_type = array_ref_type;
	     p -> array_ref.data_type = char_mode;
	     p -> array_ref.is_addressable, p -> array_ref.allocated, p -> array_ref.ext_base = "1"b;
	     p -> array_ref.base = sp;
	     p -> array_ref.address.offset = first_auto_var_loc;
	     end;
	else p = addr (rands (builtins (4)));
	if init_auto_to_zero
	then p -> array_ref.length = chars_per_word * (last_auto_loc - first_auto_var_loc);
	else p -> array_ref.length = addr (rands (builtins (3))) -> char_constant.length;
	p -> array_ref.ref_count = 131071;		/* prevent deletion */

	if builtins (8) = 0
	then do;
	     builtins (8) = create_node (symbol_node, size (symbol));
	     p = addr (rands (builtins (8)));
	     p -> symbol.operand_type = dummy;
	     p -> symbol.by_compiler = "1"b;
	     p -> symbol.allocated, p -> symbol.is_addressable, p -> symbol.ext_base = "1"b;
	     p -> symbol.base = sp;
	     end;

	if builtins (11) = 0
	then do;
	     builtins (11) = create_node (symbol_node, size (symbol));
	     p = addr (rands (builtins (11)));
	     p -> symbol.operand_type = variable_type;
	     p -> symbol.data_type = int_mode;
	     p -> symbol.by_compiler = "1"b;
	     p -> symbol.needs_pointer = "1"b;
	     p -> symbol.descriptor = "1"b;
	     p -> symbol.address.ext_base = "1"b;
	     end;

	/* perform other initializations */

	desc_temp_chain = 0;
	state_discarded = "1"b;
	unspec (current_ms) = "0"b;
	from_base_man = "0"b;
	next_free_opt_ms = null;
	if shared_globals.hfp
	then mantissa_of_power_of_fpbase = "00001"b;
	else mantissa_of_power_of_fpbase = "01"b;

	/* initialize scanners */

	mac_base = ptr (addr (fort_opt_macros_$first_scan), 0);
	imac = fixed (rel (addr (fort_opt_macros_$first_scan)), 18) - 1;

	/* get first procedure frame and initialize operand stack */

	if first_frame = null
	then do;
	     cur_frame = null;

	     cur_frame, first_frame = create_proc_frame ();
	     end;

	else cur_frame = first_frame;

	base, top = 0;

	/* set up for subprogram */

	call start_subprogram;

	/* MAIN LOOP! */

	do while ("1"b);

	     imac = imac + 1;

	     /* look at next instruction */

loop:
	     if ^macro_instruction (imac).inhibit
	     then do;

		/* have machine instruction */

		call emit_inst;
		go to step;
		end;

	     /* have macro instruction */

	     mopnd = macro_instruction (imac).operand;
	     left = macro_instruction (imac).left;
	     mop = fixed (macro_instruction (imac).op_code, 7);

	     go to action (mop);

action (1):					/* copy */
	     op1 = stack (get_operand (mopnd));
	     call copy (op1);
	     go to step;

action (2):					/* swap */
	     op1 = get_operand (mopnd);

	     k = stack (top);
	     stack (top) = stack (op1);
	     stack (op1) = k;

	     go to step;

action (3):					/* pop */
	     op1 = get_operand (mopnd);
	     call pop (op1);
	     go to step;

action (4):					/* push_temp */
	     dt = macro_dt_inst (imac).data_type;

	     if dt ^= 0
	     then call push (assign_temp (dt));

	     else do;

		/* have block of words */

		if left < 0
		then do;

		     /* have count */

		     b1 = "1"b;			/* have count */
		     left = stack (top) + bias;
		     top = top - 1;
		     end;
		else b1 = "0"b;			/* don't have count */

		call push (assign_block (left));

		/* if "push_temp var" then ref_count is infinite 78.03.29 */

		if b1				/* ref_count for var length temp is infinite 78.03.28 */
		then if analyzing
		     then addr (rands (stack (top))) -> temporary.ref_count_copy = 131071;
		     else addr (rands (stack (top))) -> temporary.ref_count = 131071;
		end;

	     go to step;

action (6):					/* dispatch for simple macro instructions */
	     go to simple (left);

simple (1):					/* push_label */
simple (2):					/* push_rel_constant */
	     call push (create_rel_constant (cs));
	     go to step;

action (8):					/* push_constant */
	     dt = macro_dt_inst (imac).data_type;

	     if dt ^= 0
	     then do;
		call push (create_constant (dt, addr (machine_instruction (imac + 1)) -> bit_image));
		imac = imac + data_type_size (dt);
		end;

	     else do;
		if left < 0
		then do;
		     left = stack (top) + bias;
		     top = top - 1;
		     end;
		call print_message (427, "push_constant_block");
		end;

	     go to step;

action (9):					/* convert_constant */
	     source = addr (rands (stack (top))) -> constant.value;
	     cdt = addr (rands (stack (top))) -> constant.data_type;
	     dt = macro_dt_inst (imac).data_type;
	     result = conv_round (dt, cdt) ((source), 0);
	     stack (top) = create_constant (dt, result);
	     go to step;

action (54):					/* push_count */
	     call push (left - bias);
	     go to step;

action (10):					/* push_count_indexed */
	     op1 = get_operand (mopnd);
	     i = stack (op1) + bias;

	     if i <= 0 | i > left
	     then call print_message (402, "push_count_indexed");

	     call push (half_array (i) - bias);

	     imac = imac + divide (left + 1, 2, 17, 0);
	     go to step;

action (11):					/* push_builtin */
	     call push ((builtins (left)));
	     go to step;

action (14):					/* call without error exit */
action (70):					/* call with error exit */
	     if mop = 14
	     then call setup_call (left, imac, 0, 0);
	     else do;
		imac = imac + 1;
		call setup_call (left, imac, (macro_instruction (imac).left), 0);
		end;

	     imac = left;
	     go to step;

action (15):					/* return */
	     if left = 0
	     then do;

		/* should be a proc invocation */

		if proc_frame.func
		then call print_message (403);

		call pop (base);
		end;

	     else do;

		/* should be a func invocation */

		if ^proc_frame.func
		then call print_message (404);

		i = macro_instruction (imac).eaq_name;
		if i = 0
		then do;

		     /* return operand name */

		     if proc_frame.scan_called
		     then do;

			/* When returning a temporary to the scan frame,
			   copy the attributes of the returned temporary
			   to the output temporary.  When returning a
			   non-temporary to the scan frame, replace
			   instances of the output temporary by the
			   returned operand. */

			op1 = stack (get_operand (mopnd));

			if op1 < 0		/* a count */
			then op1 = create_integer_constant (op1 + bias);

			if addr (rands (op1)) -> node.node_type ^= temporary_node
			then if op1 ^= quad_ptr -> operator.output
			     then if addr (rands (quad_ptr -> operator.output)) -> node.node_type = temporary_node
				then call replace_inputs ((quad_ptr -> operator.output), op1);
				else call print_message (465);
			     else ;		/* Just pop */
			else if op1 ^= quad_ptr -> operator.output
			then do;
			     k = quad_ptr -> operator.output;

			     /* Copy relevant attributes from specified operand to output temporary of
			        current operator. */

			     call assign_address_to_temp (k, op1);

			     /* change occurances of op1 in machine state to k */

			     if addr (rands (op1)) -> temporary.value_in.eaq
			     then do;
				do regno = 1 to hbound (current_ms.eaq, 1);
						/* A, Q, EAQ, IND */
				     do i = 1 to current_ms.eaq (regno).number;
					if current_ms.eaq (regno).variable (i) = op1
					then current_ms.eaq (regno).variable (i) = k;
					end;
				     end;

				addr (rands (op1)) -> temporary.value_in.eaq = "0"b;
				addr (rands (k)) -> temporary.value_in.eaq = "1"b;
				end;

			     if addr (rands (op1)) -> temporary.value_in.x
			     then do;
				do i = first_index to last_index;
				     if current_ms.index_regs (i).type = 1
				     then if current_ms.index_regs (i).variable = op1
					then current_ms.index_regs (i).variable = k;
				     end;

				addr (rands (op1)) -> temporary.value_in.x = "0"b;
				addr (rands (k)) -> temporary.value_in.x = "1"b;
				end;

			     if addr (rands (op1)) -> temporary.address_in_base
			     then do;
				do i = first_base to last_base;
				     if current_ms.base_regs (i).type = 1
				     then if current_ms.base_regs (i).variable = op1
					then current_ms.base_regs (i).variable = k;
				     end;

				addr (rands (op1)) -> temporary.address_in_base = "0"b;
				addr (rands (k)) -> temporary.address_in_base = "1"b;
				end;

			     if current_ms.last_dynamic_temp = op1
			     then current_ms.last_dynamic_temp = k;

			     end;

			else call assign_address_to_temp (op1, 0);

			call pop (base);
			end;

		     else do;			/* Not the scan frame. */
			op1 = get_operand (mopnd);
			k = stack (op1);
			stack (op1) = stack (base);
			if k < 0
			then stack (base) = create_integer_constant (k + bias);
			else stack (base) = k;

			call pop (base + 1);
			end;
		     end;

		else do;

		     /* return eaq_name */

		     call pop (base);

		     dt = dt_from_reg (i);

		     if proc_frame.scan_called
		     then do;
			temp = quad_ptr -> operator.output;

			call assign_address_to_temp (temp, 0);
			end;

		     else do;
			temp = assign_temp (dt);

			call push (temp);
			end;

		     /* Note:  return eaq_name should not be used to evaluate
		        a function such as min or max since the indicators
		        do not reflect the sign of the result.	*/

		     call in_reg (temp, i);
		     if i < in_ind
		     then current_ms.indicators_valid = eaq_name_to_reg (i);

		     end;
		end;

	     p = cur_frame;

	     call pop_frame;

	     /* now, actually return */

	     imac = p -> proc_frame.return;

	     if p -> proc_frame.interpreter_called
	     then do;
		go to p -> proc_frame.interpreter_return;
		end;

	     go to step;

action (16):					/* jump */
	     imac = left;
	     go to loop;

action (17):					/* scan */
rescan:
	     quad_ptr = addr (quad (iquad));
	     iquad = quad_ptr -> operator.next;
	     op_code = quad_ptr -> operator.op_code;
	     scan_proc = fort_opt_macros_$operator_table (op_code).entry;

	     err_flag = quad_ptr -> operator.output = ERROR;
						/* To check for ERROR operands */

	     next_operand = macro_dt_inst (scan_proc).data_type;
	     if next_operand = variable_count
	     then next_operand = quad_ptr -> operator.number;

	     do i = 1 by 1 while (i <= next_operand);
		if quad_ptr -> operator.operand (i) = ERROR
		then err_flag = "1"b;
		call push ((quad_ptr -> operator.operand (i)));
		end;

	     next_base = get_nextbase (scan_proc, next_operand);

	     if err_flag
	     then do;

operand_is_ERROR:
		call pop (next_base);

		if fixed (macro_instruction (scan_proc).op_code, 7) = function
		then call push (ERROR);

		i = macro_instruction (scan_proc).left;
		if i = 0
		then go to rescan;

		call setup_call (i, imac - 1, left, 0);
		imac = i;
		end;

	     else do;
		call setup_call (scan_proc, imac - 1, left, next_base);
		imac = scan_proc;
		end;

	     proc_frame.scan_called = "1"b;
	     go to step;

action (19):					/* s_call */
	     proc_frame.nshort = proc_frame.nshort + 1;
	     if proc_frame.nshort > hbound (proc_frame.short, 1)
	     then call print_message (407, "s_call stack", hbound (proc_frame.short, 1) - bias);
	     else proc_frame.short (proc_frame.nshort) = imac;
	     imac = left;
	     go to loop;

simple (3):					/* s_return */
	     if proc_frame.nshort < 0
	     then call print_message (408);
	     else do;
		imac = proc_frame.short (proc_frame.nshort);
		proc_frame.nshort = proc_frame.nshort - 1;
		end;

	     go to step;

action (21):					/* if_dt */
	     b2 = "1"b;
	     go to dt_join;

action (22):					/* unless_dt */
	     b2 = "0"b;

dt_join:
	     i = addr (rands (stack (top))) -> symbol.data_type;

	     if i <= 0 | i > length (macro_bits_inst (imac).bits)
	     then call print_message (445, stack (top), "data_type");
	     else b1 = substr (macro_bits_inst (imac).bits, i, 1);

	     go to if_join;

action (23):					/* if_optype */
	     b2 = "1"b;
	     go to optype_join;

action (24):					/* unless_optype */
	     b2 = "0"b;

optype_join:
	     if stack (top) > 0			/* item can be operand or count */
	     then do;
		i = addr (rands (stack (top))) -> symbol.operand_type;
						/* an operand */

		if i <= 0 | i > length (macro_bits_inst (imac).bits)
		then do;
		     call print_message (445, stack (top), "operand_type");
		     stop;
		     end;
		end;

	     else i = count_type;			/* a count */

	     b1 = substr (macro_bits_inst (imac).bits, i, 1);

	     go to if_join;

action (25):					/* (if unless)_array */
	     b2 = macro_cond_inst (imac).if_test;
	     p = addr (rands (stack (top)));
	     if p -> node.node_type = symbol_node
	     then b1 = p -> symbol.dimensioned;
	     else b1 = "0"b;
	     go to if_join;

action (26):					/* (if unless)_aligned */
	     b2 = macro_cond_inst (imac).if_test;
	     p = addr (rands (stack (get_operand (mopnd))));

	     if p -> node.units = char_units
	     then do;
		if p -> node.node_type = symbol_node
		then if p -> symbol.parameter
		     then b1 = "0"b;
		     else b1 = (p -> symbol.address.char_num = 0);

		else if p -> node.node_type = array_ref_node
		then if addr (rands (p -> array_ref.parent)) -> symbol.parameter
		     then b1 = "0"b;
		     else b1 = (p -> array_ref.address.char_num = 0 & ^cs -> subprogram.options.ansi_77);

		else b1 = (p -> node.address.char_num = 0);
		end;
	     else b1 = "1"b;

	     go to if_join;

action (27):					/* if_eaq */
	     b2 = "1"b;
	     go to eaq_join;

action (28):					/* unless_eaq */
	     b2 = "0"b;

eaq_join:
	     op1 = stack (get_operand (mopnd));

	     if addr (rands (op1)) -> node.value_in.eaq
	     then do;
		eaq_name = get_eaq_name (op1);
		if macro_instruction (imac).eaq_name = in_ind
		then b1 = (eaq_name > in_ind);
		else b1 = (eaq_name = macro_instruction (imac).eaq_name);
		end;

	     else b1 = "0"b;			/* op1 not in any eaq register */


	     /* Modified 2/2/78 to drop ref count if the argument is in the eaq. */

	     if b1
	     then call drop_count (op1, 1);

	     go to if_join;

action (29):					/* dt_jump */
	     dt1 = addr (rands (stack (top))) -> symbol.data_type;
	     dt2 = addr (rands (stack (top - 1))) -> symbol.data_type;

	     if dt1 <= 0
	     then call print_message (445, stack (top), "data_type");

	     else if dt1 = typeless_mode
	     then i = 19;

	     else if dt1 > cmpx_mode
	     then i = 17;

	     else if dt2 <= 0
	     then call print_message (445, stack (top - 1), "data_type");

	     else if dt2 = typeless_mode
	     then i = 20;

	     else if dt2 > cmpx_mode
	     then i = 18;

	     else i = 4 * (dt1 - 1) + dt2;

	     imac = half_array (i);
	     go to loop;

action (124):					/* dt_jump1 */
	     dt = addr (rands (stack (get_operand (mopnd)))) -> symbol.data_type;

	     if dt <= 0 | dt > last_assigned_mode
	     then do;
		call print_message (445, stack (get_operand (mopnd)), "data_type");
		stop;
		end;

	     imac = half_array (dt);
	     goto loop;

action (30):					/* ind_jump */
	     if current_ms.eaq (IND).name < tze
	     then call print_message (409);
	     else imac = half_array (current_ms.eaq (IND).name - tze + 1);

	     go to loop;

action (72):					/* if_ind */
	     b2 = "1"b;
	     go to ind_join;

action (73):					/* unless_ind */
	     b2 = "0"b;

ind_join:
	     if current_ms.eaq (IND).name >= in_ind & current_ms.eaq (IND).number > 0
	     then call print_message (410);

	     eaq_name = macro_instruction (imac).eaq_name;
	     regno = eaq_name_to_reg (eaq_name);
	     b1 = (current_ms.indicators_valid = regno);
	     go to if_join;

action (81):					/* (if unless)_parameter */
	     b2 = macro_cond_inst (imac).if_test;
	     op1 = get_operand (mopnd);
	     b1 = addr (rands (stack (op1))) -> symbol.parameter;
	     go to if_join;

action (82):					/* (if unless)_global */
	     b2 = macro_cond_inst (imac).if_test;
	     op1 = stack (get_operand (mopnd));
	     b1 = addr (rands (op1)) -> node.globally_assigned;
	     go to if_join;

action (83):					/* (if unless)_induction_var */
	     b2 = macro_cond_inst (imac).if_test;
	     p = addr (rands (stack (get_operand (mopnd))));
	     b1 = is_induction_var (p);
	     go to if_join;

action (84):					/* (if unless)_fb17 */
	     b2 = macro_cond_inst (imac).if_test;
	     op1 = stack (get_operand (mopnd));
	     p = find_range (addr (rands (op1)), cur_lp);
	     b1 = p -> range.fb17;
	     go to if_join;

action (85):					/* (if unless)_negative */
	     b2 = macro_cond_inst (imac).if_test;
	     op1 = get_operand (mopnd);
	     b1 = check_negative (stack (op1));
	     go to if_join;

action (86):					/* (if unless)_global_ind_var */
	     b2 = macro_cond_inst (imac).if_test;
	     p = addr (rands (stack (get_operand (mopnd))));
	     b1 = "0"b;
	     if p -> node.globally_assigned
	     then if is_induction_var (p)
		then b1 = "1"b;
	     go to if_join;

action (87):					/* (if unless)_local */
	     b2 = macro_cond_inst (imac).if_test;
	     op1 = stack (get_operand (mopnd));
	     b1 = addr (rands (op1)) -> symbol.external & addr (rands (op1)) -> symbol.initial > 0;
	     go to if_join;

action (89):					/* (if unless)_main */
	     b2 = macro_cond_inst (imac).if_test;
	     b1 = cs -> subprogram.subprogram_type = main_program;
	     go to if_join;

action (95):					/* (if unless)_needs_descriptors */
	     b2 = macro_cond_inst (imac).if_test;
	     op1 = stack (get_operand (mopnd));
	     b1 = addr (rands (op1)) -> symbol.needs_descriptors;
	     go to if_join;

action (99):					/* (if unless)_namelist_used */
	     b2 = macro_cond_inst (imac).if_test;
	     b1 = cs -> subprogram.namelist_used;
	     go to if_join;

action (118):					/* (if unless)_zero */
	     b2 = macro_cond_inst (imac).if_test;
	     b1 = check_zero ((stack (get_operand (mopnd))));
	     goto if_join;

action (101):					/* if_next_statement */
	     b2 = "1"b;
	     goto next_stmnt_join;

action (102):					/* unless_next_statement */
	     b2 = "0"b;

next_stmnt_join:
	     b1 = "0"b;				/* target is not next statement */
	     op1 = fixed (statement_ptr -> opt_statement.next, 18);

	     do while (op1 > 0);			/* find next executable st */
		if addr (quad (op1)) -> opt_statement.put_in_map
						/* an executable statement */
		then do;				/* return "1"b if lbl on next st */
		     b1 = addr (rands (stack (get_operand (mopnd)))) -> label.statement = op1;
		     goto if_join;
		     end;
		op1 = fixed (addr (quad (op1)) -> opt_statement.next, 18);
		end;
	     goto if_join;				/* no next st, no match */

action (31):					/* if */
	     b2 = "1"b;
	     go to unless_join;

action (32):					/* unless */
	     b2 = "0"b;

unless_join:
	     op1 = get_operand (mopnd);
	     op1 = stack (op1) + bias;

	     op2 = macro_if_inst (imac).with;
	     if op2 = 3
	     then op2 = stack (top) + bias;

	     relation = fixed (macro_if_inst (imac).relation, 3);
	     go to comp (relation);

comp (0):
	     b1 = op1 < op2;
	     go to if_join;

comp (1):
	     b1 = op1 > op2;
	     go to if_join;

comp (2):
	     b1 = op1 = op2;
	     go to if_join;

comp (3):
	     b1 = op1 ^= op2;
	     go to if_join;

comp (4):
	     b1 = op1 <= op2;
	     go to if_join;

comp (5):
	     b1 = op1 >= op2;

if_join:
	     if b1 = b2
	     then do;
		imac = left;
		go to loop;
		end;

	     go to step;

action (33):					/* jump_indexed */
	     op1 = get_operand (mopnd);
	     i = stack (op1) + bias;

	     if i <= 0 | i > left
	     then call print_message (402, "jump_indexed");
	     else imac = half_array (i);

	     go to loop;

action (34):					/* emit_inst & emit_data */
	     if mopnd = 0				/*  =0 is emit_data */
	     then do imac = imac + 1 to imac + left;
		     text_word (text_pos) = unspec (machine_instruction (imac));
		     text_pos = text_pos + 1;
		     end;
	     else do imac = imac + 1 to imac + left;	/* ^=0 is emit_inst */
		     call check_machine_state (fixed (machine_instruction (imac).op_code, 10), 0);
		     text_word (text_pos) = unspec (machine_instruction (imac));
		     text_pos = text_pos + 1;
		     end;
	     go to loop;

action (78):					/* assign_entry */
	     state_discarded = "0"b;

action (36):					/* rel_con */
	     call alloc_relcon ((stack (get_operand (mopnd))), text_pos);
	     goto step;

action (35):					/* label */
	     call alloc_label ((stack (get_operand (mopnd))), text_pos);
	     goto step;

action (37):					/* set_rel_constant */
	     call alloc_relcon ((stack (get_operand (mopnd))), stack (top) + bias);
	     top = top - 1;
	     go to step;

action (38):					/* add_to_address */
	     if left = 0
	     then do;
		if ^analyzing
		then instruction (text_pos - 1).offset = instruction (text_pos - 1).offset + stack (top) + bias;
		top = top - 1;
		end;

	     else do;
		op1 = get_operand (mopnd);

		if ^analyzing
		then do;
		     p = addr (rands (stack (op1)));

		     if p -> label.operand_type ^= rel_constant
		     then call print_message (411, stack (op1));

		     i = p -> label.location + stack (top - 1) + bias;
		     instruction (i).offset = instruction (i).offset + stack (top) + bias;
		     end;

		top = top - 2;
		end;

	     go to step;

action (39):					/* free_temp */
	     p = addr (rands (stack (get_operand (mopnd))));
	     if analyzing
	     then p -> temporary.ref_count_copy = 0;
	     else p -> temporary.ref_count = 0;
	     call free_temp (p);
	     go to step;

action (40):					/* reserve_regs */
	     call reserve_regs ((macro_regs_inst (imac).regs));
	     go to step;

action (41):					/* load_pr */
	     op1 = stack (get_operand (mopnd));

	     if assembly_list & addr (rands (op1)) -> node.node_type = symbol_node
	     then a_name (text_pos) = op1;

	     call base_man_load_pr (op1, left, "1"b);
	     go to step;

action (112):					/* load_pr_value */
	     op1 = stack (get_operand (mopnd));

	     if assembly_list & addr (rands (op1)) -> node.node_type = symbol_node
	     then a_name (text_pos) = op1;

	     call base_man_load_pr_value (op1, left);
	     go to step;

simple (49):					/* desc_ptr_in_pr3 */
	     current_ms.base_regs (which_base (3)).type = 9;
	     current_ms.base_regs (which_base (3)).used = text_pos;
	     current_ms.base_regs (which_base (3)).variable = 0;
	     current_ms.base_regs (which_base (3)).offset = 0;
	     go to step;

simple (50):					/* arg_ptr_in_pr1 */
	     current_ms.base_regs (which_base (1)).type = 5;
	     current_ms.base_regs (which_base (1)).used = text_pos;
	     current_ms.base_regs (which_base (1)).variable = 0;
	     current_ms.base_regs (which_base (1)).offset = 0;
	     go to step;

simple (4):					/* free_regs */
	     call free_regs;
	     go to step;

action (44):					/* make_addressable */
action (71):
	     op1 = get_operand (mopnd);
	     call m_a (addr (rands (stack (op1))));

	     if mop = 71
	     then do;
		op2 = get_operand ((machine_instruction (imac).operand));
		call m_a (addr (rands (stack (op2))));
		end;

	     go to step;

action (42):					/* use_a */
	     call use_eaq (0, A, left);
	     go to step;

action (43):					/* use_q */
	     call use_eaq (0, Q, left);
	     go to step;

action (45):					/* use_eaq */
	     call use_eaq (0, EAQ, left);
	     go to step;

action (46):					/* load */
	     op1 = stack (get_operand (mopnd));

	     if op1 < 0				/* a count */
	     then op1 = create_integer_constant (op1 + bias);

	     call load (op1, (macro_instruction (imac).eaq_name));
	     go to step;

action (47):					/* load_top */
	     eaq_name = macro_instruction (imac).eaq_name;/* copy in case imac is changed */
	     temp = 0;				/* swap flag */

	     /* If both operands are in the eaq, and we are loading a
	        logical into the A, get any logical that might be in the
	        indicators into the A first.  This is a kludge, but it
	        prevents useless stores in some cases. */

	     if eaq_name = in_a
	     then if current_ms.eaq (IND).number > 0
		then if addr (rands (stack (top))) -> node.value_in.eaq
		     then if addr (rands (stack (top - 1))) -> node.value_in.eaq
			then call move_logical_to_a ();

	     /* If both operands are in the eaq, check the eaq names
	        and swap if the top operand is the wrong name but the
	        lower one is the right name. */

	     if addr (rands (stack (top))) -> node.value_in.eaq
	     then if addr (rands (stack (top - 1))) -> node.value_in.eaq
		then if get_eaq_name (stack (top)) ^= eaq_name
		     then if get_eaq_name (stack (top - 1)) = eaq_name
			then temp = 1;

	     /* If the top operand is not in the eaq, and the lower one is
	        or the top operand is constant, swap the operands. */

	     if ^addr (rands (stack (top))) -> node.value_in.eaq
	     then if addr (rands (stack (top - 1))) -> node.value_in.eaq
		     | addr (rands (stack (top))) -> node.node_type = constant_node
		     | addr (rands (stack (top))) -> node.node_type = char_constant_node
		then temp = 1;

	     if temp > 0
	     then do;
		k = stack (top - 1);
		stack (top - 1) = stack (top);
		stack (top) = k;

		/* If operands are swapped and a label is given, transfer to that label. */

		if left > 0
		then imac = left - 1;
		end;

	     call load ((stack (top)), eaq_name);

	     go to step;

action (113):					/* load_for_test */
	     op1 = stack (get_operand (mopnd));
	     op2 = macro_instruction (imac).eaq_name;
	     regno = eaq_name_to_reg (op2);

	     call load (op1, op2);

	     /* if indicators are invalid, set them with a compare */

	     if current_ms.indicators_valid ^= regno
	     then do;
		call emit_single ((compare_inst (op2)), (zero_for_dt (dt_from_reg (op2))));
		current_ms.indicators_valid = regno;
		end;
	     goto step;

action (111):					/* store */
	     op1 = stack (get_operand (mopnd));
	     call store (op1, (macro_instruction (imac).eaq_name), left);
	     go to step;

action (48):					/* in_reg */
	     op1 = stack (get_operand (mopnd));
	     call in_reg (op1, (macro_instruction (imac).eaq_name));
	     go to step;

action (49):					/* refresh_regs */
	     call refresh_regs (left);
	     go to step;

simple (6):					/* reset_eaq */
	     call reset_eaq (EAQ);
	     call reset_eaq (IND);
	     go to step;

simple (7):					/* use_ind */
	     call use_ind;
	     go to step;

simple (33):					/* ind_to_a */
	     call move_logical_to_a ();
	     go to step;

action (20):					/* set_inds_valid */
	     eaq_name = macro_instruction (imac).eaq_name;
	     current_ms.indicators_valid = eaq_name_to_reg (eaq_name);
	     go to step;

action (51):					/* increment */
	     op1 = get_operand (mopnd);
	     stack (op1) = stack (op1) + left;
	     go to step;

action (52):					/* decrement */
	     op1 = get_operand (mopnd);
	     stack (op1) = stack (op1) - left;
	     go to step;

action (53):					/* multiply */
	     op1 = get_operand (mopnd);

	     k = (stack (op1) + bias) * left;		/* form product */
	     if k >= bias
	     then call print_message (433, stack (op1), left - bias);
						/* product is too large to be count */
	     else stack (op1) = k - bias;		/* product ok */
	     go to step;

action (55):					/* push_bif_index */
	     op1 = get_operand (mopnd);
	     i = addr (rands (stack (op1))) -> symbol.char_size - bias;
	     call push (i);
	     go to step;

simple (21):					/* optimized_subscript */
	     call optimized_subscript (quad_ptr);
	     goto step;

action (64):					/* push_array_size */
	     op1 = get_operand (mopnd);
	     p = addr (rands (stack (op1)));
	     p = addr (rands (p -> symbol.dimension));

	     if p -> dimension.variable_array_size
	     then op1 = p -> dimension.array_size;
	     else op1 = create_integer_constant ((p -> dimension.array_size));

	     call push (op1);
	     go to step;

action (65):					/* print */
	     call setup_message_structure;
	     call print_message_op;
	     go to step;

action (66):					/* error */
	     if left ^= 0
	     then do;
		call setup_message_structure;
		call print_message_op;
		end;

	     do while (proc_frame.error_label = 0);
		cur_frame = proc_frame.prev;
		end;

	     /* In order to prevent errors later on, all operators to which this one is an input are
	        marked as receiving an ERROR operand. */

	     call replace_inputs ((quad_ptr -> operator.output), ERROR);

	     call pop (proc_frame.base);

	     p = cur_frame;

	     call pop_frame;

	     if ^p -> proc_frame.interpreter_called
	     then do;
		imac = p -> proc_frame.error_label;
		go to loop;
		end;

	     else do;
		imac = p -> proc_frame.return;
		go to p -> proc_frame.interpreter_return;
		end;

action (68):					/* push_length */
	     op1 = get_operand (mopnd);
	     p = addr (rands (stack (op1)));
	     call push (get_char_size (p));
	     go to step;

action (7):					/* emit_eis */
	     call emit_eis;
	     go to step;

simple (13):					/* end_unit */
	     if top ^= 0 | base > 1
	     then call print_message (425);

	     call leave_loop (lp_msp);

	     if analyzing & n_loops > 1
	     then do;
		call process_loop_end_lists;
		call reset_subprogram;
		end;

	     cur_subprogram = cs -> subprogram.next_subprogram;
	     if cur_subprogram = 0
	     then return;

	     call cleanup_loop_state_nodes;

	     call start_subprogram;
	     go to step;

action (76):					/* make_io_desc */
	     result = macro_regs_inst (imac).regs | bit (fixed (stack (top) + bias, 36), 36);
	     stack (top) = create_constant (int_mode, result);
	     go to step;

action (77):					/* (if unless)_one_word_dt */
	     b2 = macro_cond_inst (imac).if_test;
	     p = addr (rands (stack (get_operand (mopnd))));
	     if (p -> node.data_type = int_mode) | (p -> node.data_type = real_mode)
		| (p -> node.data_type = typeless_mode)
	     then b1 = "1"b;
	     else if (p -> node.data_type = char_mode)
	     then if (p -> node.node_type = symbol_node)
		then b1 = p -> symbol.char_size = 3 & ^p -> symbol.aliasable;
		else if (p -> node.node_type = char_constant_node)
		then b1 = p -> char_constant.length = 4;
		else b1 = "0"b;
	     else b1 = "0"b;
	     goto if_join;

simple (14):					/* stat */
	     cur_statement = fixed (rel (quad_ptr), 18);
	     statement_ptr = quad_ptr;

	     if fu ^= statement_ptr -> opt_statement.flow_unit
	     then do;

		/* changing flow_units - refresh the globally assigned registers */

		if fu ^= null
		then call refresh_regs (0);

		if analyzing & fu ^= null
		then call reset_scan (cur_statement, statement_ptr, iquad, fu, cur_lp);

		else do;
		     fu = statement_ptr -> opt_statement.flow_unit;

		     if fu -> flow_unit.loop ^= cur_lp
		     then do;

			/* changing loops - reset machine states accordingly */

			cur_lp = fu -> flow_unit.loop;
			call leave_loop (lp_msp);
			call enter_loop (cur_lp, lp_msp);
			end;
		     end;
		end;

	     if statement_ptr -> opt_statement.label ^= 0
	     then do;
		call alloc_label ((statement_ptr -> opt_statement.label), text_pos);
		end;

	     statement_ptr -> opt_statement.location = bit (text_pos, 18);

	     if generate_profile
	     then if statement_ptr -> opt_statement.put_in_profile
		then call build_profile_entry;
	     go to step;

simple (15):					/* check_parameters */
	     /*** Expects:

		count of parameters
		param1
		param2
		.
		.
		.
		paramn ***/
	     zarg = base;
	     n = stack (zarg) + bias;
	     virtual_origin_count = 0;

	     /* Perform entry descriptor processing to fill in arguments. */
	     /* We will put the node offset to the descriptor into the text section.
	        gen_entry_defs will later fill in the true text offset from the allocated
	        nodes. */
	     /* NOTE. We depend upon parm_desc_ptrsp being left set to the descriptor
	        block.  This is a relatively safe assumption however. */

	     do i = 1 to n;
		parm_desc_ptrs.descriptor_relp (i) = make_entry_descriptor ((stack (zarg + i)));

		k = fixed (rel (addr (parm_desc_ptrs.descriptor_relp (i))));
		if mod (i, 2) = 0
		then reloc (k).left_rel = rc_t;
		else reloc (k).right_rel = rc_t;
		end;

	     /* Next store pointers to multi-position parameters, and VLA
	        parameters. */

	     do i = 1 to n;
		p = addr (rands (stack (zarg + i)));

		if assembly_list & p -> node.node_type = symbol_node
		then a_name (text_pos) = stack (zarg + i);

		if p -> node.node_type = symbol_node
		then if p -> symbol.VLA
		     then do;

			/* Store pointers to Very Large Array parameters in the
			   VLA pointer blocks.  */

			bit3 = base_man_load_any_pr (2, 2 * i, 0);
			sym = addr (rands (p -> symbol.dimension)) -> dimension.VLA_base_addressor;
			s = addr (rands (sym));
			if VLA_is_256K
			then call emit_c_a_var ((store_packed_base (which_base (fixed (bit3, 3)))), s);
			else do;			/* 255K addressing */
			     if assembly_list
			     then a_name (text_pos) = fixed (rel (p));
			     unspec (inst_address) = "0"b;
			     inst_address.base = bit3;
			     inst_address.ext_base = "1"b;
			     call emit_c_a ((epaq), unspec (inst_address));
			     call emit_single ((qrl), 18 - bias);
			     call emit_c_a_var ((stq), s);
			     call emit_single ((lrl), 54 - bias);
			     inst_address.base = "000"b;
			     inst_address.offset = VLA_words_per_seg;
			     call emit_c_a ((mpy), unspec (inst_address));
			     call emit_c_a_var ((asq), s);
			     if assembly_list
			     then a_name (text_pos) = fixed (rel (p));
			     call emit_c_a ((store_packed_base (which_base (fixed (bit3, 3)))),
				c_a ((p -> symbol.address.offset), 6));
			     end;
			end;

		     else if p -> symbol.stack_indirect
		     then do;
			bit3 = base_man_load_any_pr (2, 2 * i, 0);
			if assembly_list & p -> node.node_type = symbol_node
			then a_name (text_pos) = stack (zarg + i);
			call emit_c_a ((store_base (which_base (fixed (bit3, 3)))), c_a ((p -> symbol.location), 6))
			     ;
			end;
		end;

	     /* Next store length of star extent character strings */

	     do i = 1 to n;
		p = addr (rands (stack (zarg + i)));

		if p -> node.node_type = symbol_node
		then if p -> symbol.v_length ^= 0
		     then do;
			if assembly_list & p -> node.node_type = symbol_node
			then a_name (text_pos) = stack (zarg + i);
			call get_param_char_size (p, i);
			end;
		end;

	     /* Finally compute bounds, etc. of variable extent arrays */

	     do i = 1 to n;
		p = addr (rands (stack (zarg + i)));
		if p -> node.node_type = symbol_node
		then if p -> symbol.dimensioned
		     then if p -> symbol.variable_extents | p -> symbol.star_extents
			then if p -> symbol.allocate
			     then do;
				if assembly_list & p -> node.node_type = symbol_node
				then a_name (text_pos) = stack (zarg + i);
				call get_param_array_size (p);
				end;
		end;

	     /* Last but not least emit code for star extent function allocation. */

	     if cs -> subprogram.star_extent_function
	     then do;
		p = addr (rands (cs -> subprogram.first_symbol));

		/* THIS DEPENDS UPON return_value BEING THE FIRST DEFINED SYMBOL IN THE FUNCTION. */

		call emit_single ((load_inst (in_q)), (p -> symbol.v_length));
		call emit_single ((adfx1), 3 - bias);	/* adq 3 */
		call emit_single ((qrs), 2 - bias);	/* qrs 2 */
		call flush_base (which_base (2));
		call emit_operator_call ((alloc_auto_adj));
		call emit_c_a ((store_base (which_base (2))), c_a ((p -> symbol.location), 6));

		/* If the return_value_param has a descriptor, copy to our descriptor. */

		if addr (rands (stack (zarg + n))) -> symbol.hash_chain ^= 0 & p -> symbol.hash_chain ^= 0
		then do;
		     call emit_single ((load_inst (in_q)), (addr (rands (stack (zarg + n))) -> symbol.hash_chain));
		     call emit_single ((store_inst (in_q)), (p -> symbol.hash_chain));
		     end;
		call reset_eaq (Q);
		end;

	     go to step;

action (80):					/* push_char_temp */
	     if left < 0
	     then do;

		/* have count */

		left = stack (top) + bias;
		top = top - 1;
		end;

	     call push (assign_char_temp (left));
	     go to step;

simple (16):					/* check_arg_list */
	     call check_arg_list;
	     go to step;

simple (17):					/* store_arg_addrs */
	     /*** Expects:

		external reference
		number of arguments
		arg1
		arg2
		.
		.
		.
		argn
		arglist temp ***/
	     zarg = base + 1;
	     n = stack (zarg) + bias;
	     temp = stack (zarg + n + 1);

	     do i = 1 to n;				/* Modification to reserve base register used for source, so that "m_a" will
						   not re-use it if > 16K addresses are present in the store. */

		k = get_free_reg (current_ms.base_regs, first_base, last_base, 0, 0);
		call base_man_load_pr ((stack (zarg + i)), k, "0"b);
		current_ms.base_regs (k).reserved = "1"b;
						/* Protect Register */

		if assembly_list & addr (rands (stack (zarg + i))) -> node.node_type = symbol_node
		then a_name (text_pos) = stack (zarg + i);

		call emit_single_with_inc (store_base (k), temp, 2 * i);
		current_ms.base_regs (k).reserved = "0"b;
						/* Release base */
		end;

	     go to step;

action (91):					/* (if unless)_constant_addrs */
	     b2 = macro_cond_inst (imac).if_test;
	     zarg = base + 1;
	     n = stack (zarg) + bias;
	     b1 = n <= hbound (itp_list, 1);

	     /* If descriptors must be supplied with this call, we cannot use
	        an ITP argument list.  This is because the constant nodes for
	        the argument list and the descriptors will not be allocated
	        until later, and we must know the addresses now. */

	     /* If we have a VLA parameter then we MUST make a correct
	        pointer to it, since we cannot indirect through the stack
	        or the linkage section through a packed pointer. */

	     if addr (rands (stack (base))) -> symbol.needs_descriptors
	     then b1 = "0"b;

	     do i = 1 to n while (b1);
		p = addr (rands (stack (zarg + i)));

		if assembly_list & p -> node.node_type = symbol_node
		then a_name (text_pos) = stack (zarg + i);

		if p -> node.node_type = symbol_node & p -> symbol.VLA
		then b1 = "0"b;			/* VLA is non-constant */

		if ^p -> node.is_addressable | ^p -> node.allocated
		     | p -> node.ext_base & ^(p -> node.base = sp | p -> node.base = lp)
		then b1 = "0"b;
		end;

	     go to if_join;

action (93):					/* get_quick_label */
	     op1 = get_operand (mopnd);
	     k = stack (op1);
	     if addr (rands (k)) -> symbol.external
	     then k = addr (rands (k)) -> symbol.initial;
	     stack (op1) = addr (rands (k)) -> symbol.initial;
	     go to step;

simple (18):					/* gen_itp_list */
	     unspec (arg_list.header) = "0"b;
	     zarg = base + 1;
	     n = stack (zarg) + bias;
	     arg_list.arg_count = 2 * n;

	     do i = 1 to n;
		p = addr (rands (stack (zarg + i)));
		call set_itp_addr (p, i);
		call drop_count ((stack (zarg + i)), 1);
		end;

	     stack (top) = create_constant_block (addr (arg_list), 2 * n + 2);
	     go to step;

simple (19):					/* make_descriptors */
	     if addr (rands (stack (base))) -> symbol.needs_descriptors
	     then do;
		zarg = base + 1;
		n = stack (zarg) + bias;
		temp = stack (zarg + n + 1);

		skip = 2 * n;
		if addr (rands (stack (base))) -> symbol.parameter
		then skip = skip + 2;

		do i = 1 to n;
		     desc = make_descriptor ((stack (zarg + i)));
						/* Modification to reserve base register in case "emit_single_with_inc" causes
						   long (>16K) addressing and "m_a" requires extra pointer. */

		     k = get_free_reg (current_ms.base_regs, first_base, last_base, 0, 0);

		     if assembly_list & addr (rands (stack (zarg + i))) -> node.node_type = symbol_node
		     then a_name (text_pos) = stack (zarg + i);

		     call base_man_load_pr (desc, k, "0"b);
		     current_ms.base_regs (k).reserved = "1"b;
						/* Protect Register */
		     call emit_single_with_inc (store_base (k), temp, skip + 2 * i);
		     current_ms.base_regs (k).reserved = "0"b;
						/* Release base */
		     end;

		end;

	     go to step;

simple (42):					/* free_descriptors */
	     do while (desc_temp_chain ^= 0);
		p = addr (rands (desc_temp_chain));
		desc_temp_chain = p -> temporary.next;
		call free_temp (p);
		end;

	     go to step;

simple (20):					/* set_runtime_block_loc */
	     addr (rands (stack (base))) -> symbol.hash_chain = text_pos;
	     go to step;

action (104):					/* push_operand */
	     next_operand = next_operand + 1;

	     if next_operand > quad_ptr -> operator.number
	     then do;
		imac = left;
		goto loop;
		end;

	     if quad_ptr -> operator.operand (next_operand) = ERROR
	     then goto operand_is_ERROR;

	     call push ((quad_ptr -> operator.operand (next_operand)));
	     goto step;

action (105):					/* compare */
	     op1 = stack (get_operand (mopnd));
	     b1 = check_zero (op1);
	     eaq_name = macro_instruction (imac).eaq_name;
	     regno = eaq_name_to_reg (eaq_name);

	     /* Force temps in any eaq register to storage before eaq state
	        is destroyed or branch is taken.  Do NOT remove this stmt
	        without checking min/max/dim code */

	     call save_eaq_temps (op1, EAQ, 0);

	     if current_ms.indicators_valid ^= regno | ^b1
	     then do;

		if do_rounding & ^current_ms.rounded
		then if (eaq_name = in_eaq) | (eaq_name = in_deaq)
		     then if (eaq_name = current_ms.eaq (regno).name) | (eaq_name ^= in_deaq)
			     | (current_ms.eaq (regno).name = 0)
			then do;
			     if current_ms.eaq (regno).name ^= 0
			     then i = round_inst (current_ms.eaq (regno).name);
			     else i = round_inst (eaq_name);
			     call emit_zero (i);
			     current_ms.rounded = "1"b;
			     end;

		call emit_single ((compare_inst (eaq_name)), op1);

		if b1
		then current_ms.indicators_valid = regno;
		else current_ms.indicators_valid = 0;

		end;

	     goto step;

simple (22):					/* sub_index */
	     op1 = quad_ptr -> operator.operand (1);	/* subscript expression */
	     op2 = quad_ptr -> operator.output;

	     p = addr (rands (op1));
	     if ^p -> node.is_addressable
	     then call m_a (p);

	     xr = fixed (substr (xr_man_load_any_xr (p), 4, 3), 3);
						/* get index reg no */
	     call drop_count (op1, 1);
	     p -> node.value_in.x = "0"b;

	     call xr_man_update_xr (op2, xr);
	     goto step;

simple (32):					/* drop_all_counts */
	     do i = top - quad_ptr -> operator.number + 1 to top;
		call drop_count ((stack (i)), 1);
		end;
	     goto step;

action (109):					/* flush_ref */
	     op1 = stack (get_operand (mopnd));
	     call flush_ref (op1);
	     goto step;

action (110):					/* save_state */
	     op1 = stack (get_operand (mopnd));
	     lbl = addr (rands (op1));

	     if left >= 2
	     then discard = left;
	     else discard = 0;

	     if ^lbl -> label.allocated		/* i.e., this is a forward reference */
	     then if ^addr (quad (lbl -> label.statement)) -> opt_statement.referenced_by_assign
		then do;
		     st = addr (quad (lbl -> label.statement));

		     /* If target has an operator list, insure that all temporaries on that list that
		        are in registers but not in storage are stored. */

		     do p = st -> opt_statement.operator_list repeat p -> primary.next while (p ^= null);

			k = p -> primary.expression -> operator.output;
			if k > 0			/* Might be ERROR or 0 if temp was freed */
			then if addr (rands (k)) -> node.not_in_storage
			     then if addr (rands (k)) -> temporary.value_in.eaq
				then do;		/* Value in eaq */

				     eaq_name = get_eaq_name (k);

				     if eaq_name > in_ind
				     then do;
					call move_logical_to_a ();
					eaq_name = in_a;
					end;

				     if ^do_rounding | current_ms.rounded
				     then i = store_no_round_inst (eaq_name);
				     else i = store_inst (eaq_name);

				     call emit_temp_store (i, k);

				     end;

				else if addr (rands (k)) -> temporary.value_in.x
				then do;		/* Value in an index reg. */
				     do i = first_index to last_index
					while (current_ms.index_regs (i).type ^= 1
					| current_ms.index_regs (i).variable ^= k);
					end;
				     call emit_temp_store (sxl0 + i, k);
				     end;
			end;			/* loop thru operator list */

		     /* Now save the state at the target, but only if target is not backward ref. */

		     if ^st -> opt_statement.referenced_backwards
		     then call save_state (op1);

		     end;				/* code to process target label */

	     if discard = 0
	     then goto step;			/* simple(23), discard_state, must follow. */

simple (23):					/* discard_state */
						/* Must immediately follow action(110), save_state */
	     call discard_state;
	     goto step;

action (114):					/* set_in_storage */
	     op1 = stack (get_operand (mopnd));
	     addr (rands (op1)) -> node.not_in_storage = "0"b;
	     goto step;

action (115):					/* bump */
	     call bump_count ((stack (get_operand (mopnd))), left);
	     goto step;

action (116):					/* drop */
	     call drop_count ((stack (get_operand (mopnd))), left);
	     goto step;

simple (24):					/* push_output */
	     op1 = quad_ptr -> operator.output;
	     if addr (rands (op1)) -> node.node_type = temporary_node
	     then call assign_address_to_temp (op1, 0);
	     call push (op1);
	     goto step;

action (121):					/* push_ref_count */
	     call push (get_ref_count (addr (rands (stack (get_operand (mopnd))))) - bias);
	     goto step;

simple (25):					/* bump_args */
	     do i = base + 2 to base + 2 + stack (base + 1) + bias - 1;
		op1 = stack (i);
		if op1 > 0
		then if addr (rands (op1)) -> node.node_type = temporary_node
		     then call bump_count (op1, 1);
		end;
	     goto step;

simple (26):					/* drop_args */
	     do i = base + 2 to base + 2 + stack (base + 1) + bias - 1;
		op1 = stack (i);
		if op1 > 0
		then if addr (rands (op1)) -> node.node_type = temporary_node
		     then call drop_count (op1, 1);
		end;
	     goto step;

action (123):					/* float_power_of_fpbase */
	     op1 = get_operand (mopnd);
	     p = addr (rands (stack (op1)));

	     /* If we have a floating power of fpbase > -127, then replace operand
	        with proper exponent for ADE instruction. */

	     if p -> node.node_type = constant_node
	     then if p -> constant.data_type = real_mode | p -> constant.data_type = dp_mode
		then do;
		     unspec (floating_value) = p -> constant.value;

		     if floating_value.mantissa = mantissa_of_power_of_fpbase & floating_value.exponent > -127
		     then do;
			floating_value.mantissa = "0"b;
			floating_value.exponent = floating_value.exponent - 1;
			if macro_instruction (imac).eaq_name ^= 0
			then floating_value.exponent = -floating_value.exponent;
			stack (op1) = create_constant (real_mode, unspec (floating_value));
			imac = left;
			go to loop;
			end;
		     end;

	     go to step;

action (125):					/* pad_char_const_to_word */
	     op1 = get_operand (mopnd);

	     if addr (rands (stack (op1))) -> char_constant.length = chars_per_word
	     then goto step;

	     else if addr (rands (stack (op1))) -> char_constant.length > chars_per_word
	     then call print_message (443, chars_per_word - bias, (stack (op1)));

	     substr (char_temp, 1, chars_per_word) = addr (rands (stack (op1))) -> char_constant.value;
	     stack (op1) = create_char_constant (substr (char_temp, 1, chars_per_word));
	     goto step;

action (126):					/* pad_char_const_to_dw */
	     op1 = get_operand (mopnd);

	     if addr (rands (stack (op1))) -> char_constant.length = chars_per_dw
	     then goto step;

	     else if addr (rands (stack (op1))) -> char_constant.length > chars_per_dw
	     then call print_message (443, chars_per_dw - bias, (stack (op1)));

	     substr (char_temp, 1, chars_per_dw) = addr (rands (stack (op1))) -> char_constant.value;
	     stack (op1) = create_char_constant (substr (char_temp, 1, chars_per_dw));
	     goto step;

action (127):					/* power_of_two */
	     op1 = get_operand (mopnd);
	     p = addr (rands (stack (op1)));

	     /* If power of two then replace operand with power of two and jump to address. */

	     if p -> node.node_type ^= constant_node
	     then goto step;

	     if p -> constant.data_type ^= int_mode
	     then goto step;

	     if addr (p -> constant.value) -> int_image <= 0
	     then goto step;

	     i = index (p -> constant.value, "1"b);	/* find high-order bit */

	     if substr (p -> constant.value, i + 1, 36 - i) = "0"b
						/* all other bits are zero */
	     then do;
		stack (op1) = (36 - i) - bias;	/* Replace power of two with count. */

		imac = left;			/* set transfer location. */
		goto loop;
		end;
	     goto step;

simple (29):					/* set_rounded */
	     current_ms.rounded = "1"b;
	     go to step;

action (108):					/* round */
	     if do_rounding & ^current_ms.rounded
	     then do;
		eaq_name = macro_instruction (imac).eaq_name;
		call emit_zero ((round_inst (eaq_name)));
		current_ms.rounded = "1"b;
		current_ms.indicators_valid = eaq_name_to_reg (eaq_name);
		end;

	     go to step;

simple (30):					/* load_xreg */
	     next_lp = fu -> flow_unit.successors -> edge.to.value -> flow_unit.loop;

	     /* This assigns an index register to stack(base) over the loop
	        nest following this flow_unit.  We attempt to avoid x6 because
	        that register is modified by I/O operations.  Note
	        that stack(top) is actually loaded. */

	     if ^next_lp -> loop.all_xrs_globally_assigned
	     then do;
		b1 = current_ms.index_regs (6).reserved;
		if ^current_ms.index_regs (6).global
		then current_ms.index_regs (6).reserved = "1"b;
		end;

	     if analyzing | stack (base) = stack (top)
	     then do;
		p = addr (rands (stack (base)));
		bit6 = xr_man_load_any_xr (p);
		regno = fixed (substr (bit6, 4, 3), 3);

		/* Deal with strange case of induction var busy_on_exit
		   from loop, but which might not be initialized on entry
		   to the loop. */

		if p -> node.node_type = symbol_node
		then do;
		     i = p -> symbol.coordinate;
		     if substr (next_lp -> loop.induction_var -> bits, i, 1)
			& substr (next_lp -> loop.busy_on_exit -> bits, i, 1)
		     then if ^definitely_initialized (i, fu)
			then do;
			     call emit_temp_store (stz, (stack (base)));
			     if substr (fu -> flow_unit.busy_on_exit -> bits, i, 1)
			     then call emit_temp_store (sxl0 + regno, (stack (base)));
			     end;
		     end;
		end;

	     else do;
		call flush_ref ((stack (base)));
		regno = get_free_reg (current_ms.index_regs, first_index, last_index, 0, 0);
		call xr_man_load_xr (addr (rands (stack (top))), regno, (stack (base)));
		if next_lp -> loop.erases.xr (regno)
		then call emit_temp_store (sxl0 + regno, (stack (base)));
		end;

	     if ^next_lp -> loop.all_xrs_globally_assigned
	     then current_ms.index_regs (6).reserved = b1;

	     call drop_count ((stack (top)), 1);
	     call drop_count ((stack (base)), 1);

	     current_ms.index_regs (regno).reserved = "1"b;

	     if ^analyzing
	     then call assign_register (next_lp, INDEX, regno, 1, (stack (base)), 0);
	     go to step;

simple (31):					/* load_preg */
	     next_lp = fu -> flow_unit.successors -> edge.to.value -> flow_unit.loop;
	     p = addr (rands (stack (top)));

	     /* This assigns a base register to stack(top) over the loop nest
	        following this flow_unit. */

	     base_man_args.code = p -> pointer.code;
	     base_man_args.variable = p -> pointer.variable;
	     base_man_args.offset = p -> pointer.offset;

	     if string (next_lp -> loop.avoid_pr)
	     then call avoid_prs (string (next_lp -> loop.avoid_pr));

	     bit3 = base_man_dispatch (base_man_args.code, base_man_args.variable, base_man_args.offset);
	     regno = which_base (fixed (bit3, 3));

	     if next_lp -> loop.avoid_pr (regno)
	     then do;

		/* This register was supposed to have been avoided.
		   Erase and try again!! */

		call flush_base (regno);
		current_ms.base_regs (regno).type = -1;
		bit3 = base_man_dispatch (base_man_args.code, base_man_args.variable, base_man_args.offset);
		regno = which_base (fixed (bit3, 3));
		end;

	     if string (next_lp -> loop.avoid_pr)
	     then call restore_pr_locks;

	     /* Fix for bug 358.  Correctly lock a base reserved by a 'load_preg'.
	        by not doing this the count of ptr_data.max_locked, and ptr_data.locked is
	        too low and we have a good chance of running out of registers. */

	     call lock_base (regno);

	     if ^analyzing
	     then call assign_register (next_lp, BASE, regno, base_man_args.code, base_man_args.variable,
		     base_man_args.offset);
	     go to step;

simple (34):					/* assign_index */
	     call assign_index ((stack (base)), (stack (base + 1)));
	     go to step;

simple (35):					/* compare_index */
	     call compare_index ((stack (base)), (stack (base + 1)));
	     go to step;

simple (36):					/* test_index */
	     call compare_index ((stack (base)), builtins (0));
	     go to step;

simple (37):					/* increment_index */
	     call increment_index ((stack (base + 1)), (stack (base)), +1);
	     go to step;

simple (38):					/* decrement_index */
	     call increment_index ((stack (base + 1)), (stack (base)), -1);
	     go to step;

simple (40):					/* refresh_regs_if_next_is_jump */
	     /*** This code attempts to eliminate flushing of indicators by
		refresh_regs before a conditional jump at the end of a flow_unit. ***/
	     if lp_msp ^= null
	     then if addr (quad (iquad)) -> operator.operand (1) = quad_ptr -> operator.output
		then if addr (quad (iquad)) -> operator.op_code = jump_true_op
			| addr (quad (iquad)) -> operator.op_code = jump_false_op
		     then call refresh_regs (0);

	     go to step;

simple (41):					/* note_eligible_ind_var_use */
	     /*** If an eligible induction variable appears in an incrementing
		or comparison context and index registers are not erased in this
		loop, then the use should be recorded in the global database. ***/
	     if analyzing
	     then if substr (string (cur_lp -> loop.erases.xr), 3) ^= "111111"b
		then do i = base by 1 while (i <= top);
			if stack (i) > 0
			then do;
			     p = addr (rands (stack (i)));
			     if is_induction_var (p)
			     then if eligible (p)
				then call add_global_index (p);
			     end;
			end;

	     go to step;

simple (43):					/* force_ql */
	     if ^analyzing
	     then instruction (text_pos - 1).tag = QL_mod;

	     go to step;

simple (44):					/* int_to_char1 */
	     p = addr (rands (stack (top)));
	     if p -> node.node_type = constant_node & p -> node.data_type = int_mode
	     then do;
		char1 = byte (addr (p -> constant.value) -> int_image);
		call push (create_char_constant (char1));
		end;
	     else call print_message (462);

	     go to step;

simple (45):					/* char1_to_int */
	     p = addr (rands (stack (top)));
	     if p -> node.node_type = char_constant_node
	     then do;
		temp = rank (substr (p -> char_constant.value, 1, 1));
		call push (create_integer_constant ((temp)));
		end;
	     else call print_message (463);

	     go to step;

action (59):					/* set_next_operand */
	     next_operand = left - 1;
	     go to step;


action (57):					/* start_cat */
	     call start_cat (b1);
	     if b1
	     then do;				/* Skip first mlr */
		imac = left;
		go to loop;
		end;
	     else go to step;

simple (46):					/* continue_cat */
	     call continue_cat ();
	     go to step;

simple (47):					/* finish_cat */
	     call finish_cat ();
	     go to step;

action (58):					/* shorten_stack */
	     if current_ms.stack_extended
	     then do;
		call reserve_regs (shorten_stack_mask);
		if left > 0			/* Protect indicators? */
		then call emit_operator_call (shorten_stack_protect_ind);
		else do;
		     call use_ind ();
		     call emit_operator_call (shorten_stack);
		     end;

		current_ms.stack_extended = "0"b;
		current_ms.last_dynamic_temp = 0;

		call free_regs ();
		end;

	     go to step;

simple (27):					/* push_operand_count */
	     call push (quad_ptr -> operator.number - bias);
	     go to step;

action (60):					/* (if unless)_ansi77 */
	     b2 = macro_cond_inst (imac).if_test;
	     b1 = cs -> subprogram.options.ansi_77;
	     go to if_join;

simple (48):					/* set_needs_descriptors */
	     addr (rands (stack (base))) -> symbol.needs_descriptors = "1"b;
	     go to step;

action (69):					/* (if unless)_variable_arglist */
	     b2 = macro_cond_inst (imac).if_test;
	     op1 = stack (get_operand (mopnd));
	     b1 = addr (rands (op1)) -> symbol.variable_arglist;
	     go to if_join;

action (74):					/* (if unless)_char_star_function */
	     b2 = macro_cond_inst (imac).if_test;
	     b1 = cs -> subprogram.star_extent_function;
	     go to if_join;

action (75):					/* (if unless)_check_multiply */
	     b2 = macro_cond_inst (imac).if_test;
	     b1 = cs -> subprogram.options.check_multiply;
	     go to if_join;


action (79):					/* (if unless)_storage_created */
	     b2 = macro_cond_inst (imac).if_test;
	     if Area_create_first >= 0
	     then b1 = "1"b;
	     else b1 = "0"b;
	     go to if_join;

action (88):					/* (if unless)_VLA */
	     b2 = macro_cond_inst (imac).if_test;
	     op1 = stack (get_operand (mopnd));

	     /* Only VLA if it is a symbol, which is VLA. */

	     if addr (rands (op1)) -> node.node_type = symbol_node
	     then b1 = addr (rands (op1)) -> symbol.VLA;
	     else b1 = "0"b;
	     go to if_join;

action (90):					/* (if unless)_cleanup */
	     b2 = macro_cond_inst (imac).if_test;
	     b1 = alloc_auto_cleanup;
	     go to if_join;


simple (52):					/* emit_cleanup_args */
	     text_halfs (text_pos).left = cleanup_body_address;
	     if assembly_list
	     then a_name (text_pos) = -1;		/* tell listing generator this is not an inst */
	     text_pos = text_pos + 1;
	     go to step;


simple (53):					/* emit_storage_args */
	     if Area_create_first < 0			/* See if storage */
	     then do;
		text_halfs (text_pos).left = fixed ("777777"b3, 18);
		reloc (text_pos).left_rel = rc_a;	/* leave absolute */
		end;
	     else do;
		text_halfs (text_pos).left = Area_create_first;
		reloc (text_pos).left_rel = rc_t;	/* relocate in text */
		end;

	     if Area_init_first < 0			/* See if initialization */
	     then do;
		text_halfs (text_pos).right = fixed ("777777"b3, 18);
		reloc (text_pos).right_rel = rc_a;	/* leave absolute */
		end;
	     else do;
		text_halfs (text_pos).right = Area_init_first;
		reloc (text_pos).right_rel = rc_t;	/* relocate in text */
		end;

	     if assembly_list
	     then a_name (text_pos) = -1;		/* list in octal */

	     text_pos = text_pos + 1;
	     goto step;


simple (54):					/* emit_profile_entry */
	     if ^(generate_profile & generate_long_profile)
	     then goto step;

	     call emit_profile_dummy;
	     call emit_profile_dummy;

	     call emit_profile_control;
	     call emit_profile_control;

	     call emit_profile_dummy;

	     goto step;


emit_profile_dummy:
     proc;

	/* emit a long_profile reference to long_profile_header.dummy */

	call emit_operator_call (long_profile);
	text_halfs (text_pos).left = profile_start;
	reloc (text_pos).left_rel = rc_is18;

	/* emit relative offset from long_profile_header to dummy entry */

	text_halfs (text_pos).right = 5;		/* dummy offset */
	reloc (text_pos).right_rel = rc_a;
	text_pos = text_pos + 1;
	return;
     end emit_profile_dummy;


emit_profile_control:
     proc;

	/* emit a long_profile reference to long_profile_header.control */

	call emit_operator_call (long_profile);
	text_halfs (text_pos).left = profile_start;
	reloc (text_pos).left_rel = rc_is18;

	/* emit relative offset from long_profile_header to control entry */

	text_halfs (text_pos).right = 9;		/* control offset */
	reloc (text_pos).right_rel = rc_a;
	text_pos = text_pos + 1;
	return;
     end emit_profile_control;

simple (56):					/* emit_entry_defs */
	     /*** Expects:

		entry label
		count of parameters


		Make pointer to descriptor area we will build later.

		We will allocate space to put the node offset to the
		descriptor in the text section. This will later be filled
		by 'check_parameters' to hold the index of the constant
		node, then gen_entry_defs will later fill in the true text
		offset from the allocated nodes.

		This code is split into the three sections, this,
		check_parameters, and gen_entry_defs, since at this point
		we need to reserve space, but have not yet seen the quads
		or polish defining the parameters. At check parameters we
		put in the node offset to the descriptor, since it may not
		have been allocated, and forward refs only relocate the
		left half of an instruction. Finally at gen_entry_defs time
		we convert the node index to a text offset because all text
		allocations have been made at that time. ***/
	     zarg = base + 2;
	     n = stack (base + 1) + bias;

	     parm_desc_ptrsp = addr (text_word (text_pos));
	     parm_desc_ptrs.n_args = n;
	     k = text_pos;

	     /* Skip allocated area, and setup descr_relp_offset */

	     text_pos = text_pos + divide (n, 2, 18) + 1;
	     text_halfs (text_pos).left = k;
	     text_halfs (text_pos).right = 0;

	     reloc (text_pos).left_rel = rc_t;
	     reloc (text_pos).right_rel = rc_a;
	     text_pos = text_pos + 1;
	     go to step;

simple (57):					/* rhs_fld */
	     call rhs_fld;
	     goto step;

simple (58):					/* lhs_fld */
	     call lhs_fld;
	     goto step;

action (92):					/* (if unless)_hfp */
	     b2 = macro_cond_inst (imac).if_test;
	     b1 = cs -> subprogram.options.hfp;
	     goto if_join;

	     /* These macro opcodes are unused, or (if named) are used only by the
	        non-optimizing code generator. */

simple (5):					/* reset_regs */
simple (8):					/* start_subscript */
simple (9):					/* next_subscript */
simple (10):					/* finish_suscript */
simple (11):					/* subscript_error */
simple (12):					/* s_func_finish */
simple (28):					/* skip_data */
simple (39):					/* make_substring */
simple (51):
	     call print_message (436, left - bias);
	     goto step;

action (5):					/* push_variable */
action (18):					/* exit */
action (50):					/* push_sf_arg_count */
action (56):					/* (if unless)_saving_stack_extent */
action (61):					/* s_func_label */
action (62):					/* push_s_func_label */
action (63):					/* push_s_func_var */
action (94):
action (96):
action (97):
action (98):
action (100):
action (103):
action (106):
action (107):
action (117):
action (119):
action (120):
action (122):
	     call print_message (436, mop - bias);
	     goto step;

	     /* THESE SHOULD NOT EXECUTE */
action (0):					/* undefined */
action (12):					/* func */
action (13):					/* proc */
action (67):					/* used by rest_of_error */
	     call print_message (413);

step:
	     end;

/**** STACK FRAME MANIPULATION ****/

push:
     procedure (i);

	/* Pushes an item onto the operand stack */

dcl  i fixed binary (18);

	top = top + 1;

	if top > hbound (stack, 1)
	then do;
	     call print_message (407, "operand stack", hbound (stack, 1) - bias);
	     return;
	     end;

	stack (top) = i;

     end push;

copy:
     procedure (opnd);

	/* Copies an operand onto the top of the stack */

dcl  (opnd, op) fixed binary (18);

	op = opnd;

	call push (op);

     end copy;

pop:
     procedure (thru);

	/* Pops the stack through thru -- top becomes thru - 1 */

dcl  thru fixed binary (18);				/* pop through thru */

	top = thru - 1;

     end pop;

pop_frame:
     procedure ();

	/* Pops a procedure frame */

	cur_frame = cur_frame -> proc_frame.prev;
	base = cur_frame -> proc_frame.base;

     end pop_frame;

get_operand:
     procedure (opnd) returns (fixed binary (18));

	/* Takes an operand number as specified in a macro and returns
	   the corresponding operand stacksubscript. */

dcl  opnd fixed binary (18);				/* Operand number specified in macro */

dcl  i fixed binary (18);

	if opnd < 0
	then return (top + opnd + 1);			/* opn */
	else if opnd > 0
	then return (base + opnd - 1);		/* argn */
	else do;

	     /* opv */

	     i = stack (top) + bias;
	     top = top - 1;
	     return (top - i + 1);
	     end;

     end get_operand;

interpreter_proc:
     procedure (mac_num, ret_lab);

	/* Calls an interpreter macro procedure.  ret_lab must
	   be set to the label of the stmt immediately following
	   the call to interpreter_proc.

	   Note that this scheme is really an attempt to escape the
	   necessity for recursion in invoking interpreter macro
	   procedures.  To be truly safe, this should have recursively
	   invoked the entire interpreter.  For this scheme to work,
	   all procedures between the caller and the interpreter MUST
	   be quick, and none of them (including the caller) must be
	   invoked during the processing of the interpreter macro
	   procedure.  This is necessary to ensure that no local
	   variables are destroyed.  Obviously a procedure is safe if
	   its last statement results in a call to interpreter_proc;
	   the interesting cases arise when some other statement in
	   a procedure directly or indirectly invokes interpreter_proc.

	   Of course, this is illegal PL/I. */

dcl  mac_num fixed binary (18),			/* Macro number of interpreter procedure */
     ret_lab label local;				/* Label to return to */

dcl  macro_proc fixed binary (18);

	macro_proc = fort_opt_macros_$interpreter_macros (mac_num).entry;

	call setup_call (macro_proc, imac, imac, 0);

	proc_frame.interpreter_called = "1"b;
	proc_frame.interpreter_return = ret_lab;

	imac = macro_proc;
	go to step;

     end interpreter_proc;

setup_call:
     procedure (macro_proc, return, error_exit, nb);

	/* Pushes a new procedure frame and sets it up for a call */

dcl  macro_proc fixed binary (18),			/* Procedure being called */
     return fixed binary (18),			/* Location from which the call is being made */
     error_exit fixed binary (18),			/* Location to jump to if errors occur */
     nb fixed binary (18);				/* Presupplied next_base if ^= 0 */

dcl  (mac_proc, next_base) fixed binary (18);

	mac_proc = macro_proc;

	if nb = 0
	then next_base = get_nextbase (mac_proc, not_given);
	else next_base = nb;

	/* get next procedure frame */

	if cur_frame -> proc_frame.next ^= null
	then cur_frame = cur_frame -> proc_frame.next;
	else cur_frame = create_proc_frame ();

	/* initialize next procedure frame */

	string (proc_frame.flags) = "0"b;

	if fixed (macro_instruction (mac_proc).op_code, 7) = function
	then proc_frame.func = "1"b;

	proc_frame.return = return;
	proc_frame.error_label = error_exit;
	base, proc_frame.base = next_base;
	proc_frame.nshort = 0;

     end setup_call;

create_proc_frame:
     procedure () returns (pointer);

	/* Allocates a procedure frame in the operand region */

dcl  p pointer;

	if mod (next_free_operand, 2) ^= 0
	then do;
	     rands (next_free_operand) = 0;		/* for debugging */
	     next_free_operand = next_free_operand + 1;
	     end;


	p = addr (rands (next_free_operand));
	next_free_operand = next_free_operand + size (proc_frame);

	if next_free_operand >= operand_max_len
	then do;
	     call print_message (407, "operand region", char (operand_max_len));
						/* FATAL */
	     return (null);				/* should never be executed */
	     end;

	if cur_frame ^= null
	then cur_frame -> proc_frame.next = p;

	unspec (p -> proc_frame) = "0"b;
	p -> proc_frame.prev = cur_frame;
	p -> proc_frame.next = null;
	return (p);

     end create_proc_frame;

get_nextbase:
     procedure (macro_proc, args) returns (fixed binary (18));

	/* Calculates base of new stack frame */

dcl  macro_proc fixed binary (18);			/* Proc being called */

dcl  (args, nargs) fixed binary (18);

	nargs = args;

	if nargs = not_given
	then nargs = macro_dt_inst (macro_proc).data_type;

	if nargs = variable_count
	then if mop = 17				/* scan macro */
	     then nargs = quad_ptr -> operator.number;
	     else call print_message (437);		/* must be scan frame */
	else if mop = 17				/* scan macro */
	then if nargs > quad_ptr -> operator.number	/* for DEBUGGING */
	     then call print_message (438, nargs - bias, quad_ptr -> operator.number - bias);
						/* for DEBUGGING */
	return (top - nargs + 1);

     end get_nextbase;

/**** TEMPORARY MANAGEMENT ****/

assign_temp:
     procedure (data_type) returns (fixed binary (18));

	/* Assigns a temporary of a specific data type */

dcl  data_type fixed binary (4);

dcl  (clength, dt, size, temp) fixed binary (18);

	dt = data_type;
	size = data_type_size (dt);
	go to join;


assign_char_temp:
     entry (char_length) returns (fixed binary (18));

	/* Assigns a character temporary */

dcl  char_length fixed binary (18);

	dt = char_mode;
	clength = char_length;
	size = divide (clength + chars_per_word - 1, chars_per_word, 17, 0);
	go to join;


assign_block:
     entry (block_size) returns (fixed binary (18));

	/* Assigns a doubleword aligned block */

dcl  block_size fixed binary (18);

	size = block_size;
	size = size + mod (size, 2);
	dt = 0;

join:
	temp = get_temp (size);
	addr (rands (temp)) -> temporary.data_type = dt;
	if analyzing
	then addr (rands (temp)) -> temporary.ref_count_copy = 1;
	else addr (rands (temp)) -> temporary.ref_count = 1;
	addr (rands (temp)) -> temporary.dont_update = "0"b;
	addr (rands (temp)) -> temporary.used_as_subscript = "0"b;
	addr (rands (temp)) -> temporary.units = word_units;

	if dt = char_mode
	then do;
	     addr (rands (temp)) -> temporary.length = clength;
	     if cs -> subprogram.options.ansi_77
	     then addr (rands (temp)) -> temporary.units = char_units;
	     end;

	return (temp);

get_temp:
     procedure (amount) returns (fixed binary (18));

	/* Finds a free temporary of the desired size */

dcl  (amt, amount, i, prev, temp) fixed binary (18);

	amt = amount;

	if amt <= 2
	then do;
	     i = amt;
	     temp = free_temps (i);

	     if temp ^= 0
	     then do;
		free_temps (i) = addr (rands (temp)) -> temporary.next;
		return (temp);
		end;
	     end;

	else do;
	     i = 3;
	     prev = 0;
	     temp = free_temps (3);

	     do while (temp ^= 0);

		if addr (rands (temp)) -> temporary.size >= amt
		then do;
		     if prev = 0
		     then free_temps (3) = addr (rands (temp)) -> temporary.next;
		     else addr (rands (prev)) -> temporary.next = addr (rands (temp)) -> temporary.next;
		     return (temp);
		     end;

		prev = temp;
		temp = addr (rands (temp)) -> temporary.next;
		end;
	     end;

	if i > 1
	then if mod (last_auto_loc, 2) ^= 0
	     then do;

		/* force doubleword alignment */

		temp = create_temp (1);
		addr (rands (temp)) -> temporary.next = free_temps (1);
		free_temps (1) = temp;
		end;

	return (create_temp (amt));

     end get_temp;

     end assign_temp;

get_temp_node:
     procedure () returns (fixed binary (18));

	/* Gets a temp node off the free chain or allocates a new one. */

dcl  size builtin;
dcl  temp fixed binary (18);

	if next_free_temp = 0
	then temp = create_node (temporary_node, size (temporary));
	else do;
	     temp = next_free_temp;
	     next_free_temp = addr (rands (temp)) -> temporary.next;

	     unspec (addr (rands (temp)) -> temporary) = "0"b;
	     addr (rands (temp)) -> temporary.node_type = temporary_node;
	     end;

	return (temp);

     end get_temp_node;

create_temp:
     procedure (amount) returns (fixed binary (18));

	/* Creates a new temporary, possibly reusing a discarded
	   temporary node. */

dcl  (amount, op_type, temp) fixed binary (18);
dcl  amt fixed binary (18);
dcl  loc fixed binary (18);
dcl  p pointer;

	temp = get_temp_node ();
	op_type = temp_type;
	amt = amount;
	loc = last_auto_loc;

	if loc + amt > max_stack_size
	then call print_message (414, "in making a temporary the stack frame", max_stack_size - bias);
	else last_auto_loc = loc + amt;

	p = addr (rands (temp));

	p -> temporary.operand_type = op_type;
	string (p -> temporary.addressing_bits), string (p -> temporary.bits) = "0"b;

	p -> temporary.is_addressable, p -> temporary.allocate, p -> temporary.allocated = "1"b;

	unspec (p -> temporary.address) = ext_base_on;
	p -> temporary.base = sp;

	if op_type = temp_type
	then do;
	     p -> temporary.size = amt;
	     p -> temporary.not_in_storage = "1"b;
	     end;

	p -> temporary.next = 0;

	p -> temporary.units = word_units;

	call set_address_offset (p, loc, amt, word_units);

	return (temp);

     end create_temp;

assign_address_to_temp:
     procedure (a_temp, a_new);

	/* Assigns address to temp from second arg, or
	   insures that first arg has an address. In the
	   latter case, the second arg must be zero. */

dcl  a_temp fixed binary (18);			/* Temp that may need an address */
dcl  a_new fixed binary (18);				/* Temp that provides an address */

dcl  (temp, new) fixed binary (18);
dcl  (temp_pt, new_pt) pointer;

	temp = a_temp;
	temp_pt = addr (rands (temp));
	new = a_new;
	new_pt = addr (rands (new));

	/* Make sure we are not processing temp with ref_count of 0 */

	if get_ref_count (temp_pt) = 0
	then do;
	     if ^analyzing
	     then call print_message (454, temp);
	     return;
	     end;

	/* if temp has address, return; in this case, arg 2 must be zero */

	if unspec (temp_pt -> temporary.address) ^= "0"b
	then do;
	     if new ^= 0 & ^analyzing
	     then do;
		call print_message (442);
		call free_temp (new_pt);
		end;
	     return;
	     end;

	/* get address if not provided by caller */

	if new = 0
	then do;
	     if temp_pt -> temporary.data_type = char_mode
	     then new = assign_char_temp ((temp_pt -> temporary.length));
	     else new = assign_temp ((temp_pt -> temporary.data_type));
	     new_pt = addr (rands (new));
	     end;

	/* copy address over to target temp */

	string (temp_pt -> temporary.addressing_bits) =
	     string (temp_pt -> temporary.addressing_bits) | string (new_pt -> temporary.addressing_bits);
	if new_pt -> temporary.stack_indirect		/* Dynamic temp */
	then temp_pt -> temporary.addr_hold = new_pt -> temporary.addr_hold;

	temp_pt -> temporary.address = new_pt -> temporary.address;

	temp_pt -> temporary.location = new_pt -> temporary.location;
	temp_pt -> temporary.dont_update = "0"b;	/* because analysis may have left this on */

	/* copy size over to target temp */

	temp_pt -> temporary.size = new_pt -> temporary.size;
	if temp_pt -> temporary.data_type = char_mode
	then do;
	     temp_pt -> temporary.variable_length = new_pt -> temporary.variable_length;
	     temp_pt -> temporary.length = new_pt -> temporary.length;
	     new_pt -> temporary.variable_length = "0"b;
	     new_pt -> temporary.length = 0;
	     end;

	/* take address from source temp, then free it */

	unspec (new_pt -> temporary.address) = "0"b;
	call free_temp (new_pt);

     end assign_address_to_temp;

free_temp:
     procedure (temp_ptr);

	/* Procedure to free a temporary.  If the temporary has
	   variable length, the reference count of the associated
	   length temporary is decremented, and that temporary is
	   freed if necessary. */

dcl  temp_ptr pointer;				/* Pointer to temp node */

dcl  (tp, ltp) pointer;				/* To temp, length temp */
dcl  count fixed binary (18);				/* Reference count */

	tp = temp_ptr;

	if tp -> temporary.variable_length
	then do;

	     /* Must deal with associated length temporary */

	     ltp = addr (rands (tp -> temporary.length));
	     if ltp -> node.node_type = temporary_node
	     then do;
		if analyzing
		then count, ltp -> temporary.ref_count_copy = ltp -> temporary.ref_count_copy - 1;
		else count, ltp -> temporary.ref_count = ltp -> temporary.ref_count - 1;
		if count <= 0
		then call free_one_temp (ltp);
		tp -> temporary.length = 0;
		tp -> temporary.variable_length = "0"b;
		end;
	     end;

	call free_one_temp (tp);

     end free_temp;

free_one_temp:
     procedure (temp_ptr);

	/* This procedure flushes a temporary from the machine state
	   and threads it onto the appropriate free list. */

dcl  temp_ptr pointer;				/* Pointer to temp node */

dcl  tp pointer;					/* To temp node */
dcl  (temp, prev_temp, this_temp) fixed binary (18);
dcl  temp_size fixed binary (18);

	tp = temp_ptr;
	temp = fixed (rel (tp), 18);

	if tp -> temporary.ms_ref_count < 0 | tp -> temporary.ref_count < 0 | tp -> temporary.ref_count_copy < 0
	then do;
	     call print_message (415, temp);
	     return;
	     end;

	if unspec (tp -> temporary.address) = "0"b
	then do;

	     /* This temp has no address; it was either used as a
	        place holder or to give another temp an address. */

	     if tp -> temporary.ms_ref_count > 0	/* temp is still a place holder */
		| tp -> temporary.output_by ^= 0	/* temp will be reused in CG pass */
	     then return;
	     tp -> temporary.next = next_free_temp;
	     next_free_temp = temp;
	     return;
	     end;

	tp -> temporary.not_in_storage = "1"b;
	tp -> temporary.dont_update = "1"b;
	tp -> temporary.globally_assigned = "0"b;

	temp_size = tp -> temporary.size;

	call flush_ref (temp);
	call flush_addr (temp);
	call disconnect_temp (tp);

	/* If the machine state ref count is > 0, the temp cannot be
	   freed but its storage can be freed. To free the storage,
	   allocate a new temp and give it the storage; then put the new
	   temp on the free list.  During the analysis pass, temporaries
	   that are connected to operators cannot be freed because they
	   will be needed by the CG pass. */

	if tp -> temporary.ms_ref_count > 0 | tp -> temporary.output_by > 0
	then do;
	     this_temp = get_temp_node ();

	     addr (rands (this_temp)) -> temporary = tp -> temporary;
	     unspec (tp -> temporary.address) = "0"b;

	     temp = this_temp;
	     tp = addr (rands (this_temp));
	     tp -> temporary.output_by = 0;
	     end;

	if tp -> temporary.stack_indirect
	then do;

	     /* Restore the address of a dynamic temporary */

	     unspec (tp -> temporary.address) = tp -> temporary.addr_hold;
	     tp -> temporary.address.ext_base = "1"b;
	     tp -> temporary.needs_pointer = "0"b;
	     tp -> temporary.is_addressable = ^tp -> temporary.large_address;
	     tp -> temporary.stack_indirect = "0"b;
	     end;

	/* One and two word temps have their own free lists */

	if temp_size < 3
	then do;
	     call thread_temp (temp, temp_size, 0);
	     return;
	     end;

	/* Larger temps go on the third free list, sorted by size */

	prev_temp = 0;
	this_temp = free_temps (3);
	do while (this_temp ^= 0);

	     if temp_size <= addr (rands (this_temp)) -> temporary.size
	     then do;
		call thread_temp (temp, 3, prev_temp);
		return;
		end;

	     prev_temp = this_temp;
	     this_temp = addr (rands (this_temp)) -> temporary.next;

	     end;

	/* Temp is larger than any on the free list. */

	call thread_temp (temp, 3, prev_temp);

     end free_one_temp;

thread_temp:
     procedure (temp, chain, prev);

	/* Threads temp onto the free list specified by chain after
	   the temp prev. */

dcl  (temp, chain, prev) fixed binary (18);

	if prev = 0
	then do;

	     /* Put temp at beginning of free list */

	     addr (rands (temp)) -> temporary.next = free_temps (chain);
	     free_temps (chain) = temp;
	     end;

	else do;
	     addr (rands (temp)) -> temporary.next = addr (rands (prev)) -> temporary.next;
	     addr (rands (prev)) -> temporary.next = temp;
	     end;

     end thread_temp;

disconnect_temp:
     procedure (p);

	/* Disconnects temp or array_ref from operator that produced it */

dcl  p pointer;

dcl  o pointer;

	if ^analyzing & p -> temporary.output_by > 0
	then do;
	     o = addr (quad (p -> temporary.output_by));
	     o -> operator.output = 0;
	     p -> temporary.output_by = 0;
	     end;

     end disconnect_temp;

/**** DYNAMIC TEMPORARY MANAGEMENT ****/

assign_dynamic_temp:
     procedure () returns (fixed binary (18));

	/* This procedure allocates and initializes a dynamic
	   character temporary, but emits no code.  Dynamic temps
	   are implemented as two word temporaries which hold a
	   pointer to the actual stack extension. */

dcl  t fixed binary (18);				/* Two word temp */
dcl  p pointer;					/* Pointer to it */

	t = assign_block (2);
	p = addr (rands (t));

	p -> temporary.data_type = char_mode;
	p -> temporary.stack_indirect = "1"b;
	p -> temporary.needs_pointer = "1"b;
	p -> temporary.is_addressable = "0"b;

	p -> temporary.addr_hold = substr (unspec (p -> temporary.address), 1, 18);
	p -> temporary.reloc_hold = p -> temporary.reloc;

	unspec (p -> temporary.address) = ext_base_on;
	p -> temporary.reloc = rc_a;

	return (t);

     end assign_dynamic_temp;

allocate_dynamic_temp:
     procedure (temp, tv_offset);

	/* Emits code to extend the stack for a dynamic temporary.
	   The parameter tv_offset should be set to either
	   allocate_char_string or reallocate_char_string. */

dcl  temp fixed binary (18);				/* Temporary node */
dcl  tv_offset fixed binary (14);			/* Operator offset */

dcl  p pointer;

	p = addr (rands (temp));

	call bump_count ((p -> temporary.length), 1);
	call load ((p -> temporary.length), in_q);
	call use_eaq (0, EAQ, 0);
	call flush_base (which_base (2));
	call emit_operator_call ((tv_offset));

	current_ms.stack_extended = "1"b;
	current_ms.address_in_base = "1"b;
	p -> temporary.address_in_base = "1"b;
	p -> temporary.address.base = bases (which_base (2));

	cur_lp -> loop.avoid_pr (which_base (2)) = "1"b;

	current_ms.last_dynamic_temp = temp;

	current_ms.base_regs (which_base (2)).variable = temp;
	current_ms.base_regs (which_base (2)).type = 1;
	current_ms.base_regs (which_base (2)).used = text_pos;
	current_ms.base_regs (which_base (2)).offset = 0;

     end allocate_dynamic_temp;

/**** EMISSION OF OBJECT CODE ****/

emit_inst:
     procedure ();

	/* Emits an instruction of object code */

dcl  (inc, rand) fixed binary (18);

	if string (machine_instruction (imac).ext_base_and_tag) ^= "0"b
	then do;
	     call check_machine_state (fixed (machine_instruction (imac).op_code, 10), 0);
	     text_word (text_pos) = unspec (machine_instruction (imac));
	     end;

	else do;

	     /* have an operand */

	     inc = machine_instruction (imac).increment;
	     rand = get_operand ((machine_instruction (imac).operand));

	     call put_word ((machine_instruction (imac)), (stack (rand)), inc);
	     end;

	text_pos = text_pos + 1;

     end emit_inst;

emit_single:
     procedure (mac_num, rand);

	/* Emits an instruction from a table of single instructions */

dcl  mac_num fixed binary (18),			/* Single instruction number */
     rand fixed binary (18);				/* Operand for the inst */
dcl  inc fixed binary (18);

	inc = fort_opt_macros_$single_inst (mac_num).increment;

	call put_word ((fort_opt_macros_$single_inst (mac_num)), (rand), inc);

	text_pos = text_pos + 1;
	return;


emit_single_with_inc:
     entry (mac_num, rand, incr);

	/* Emits an instruction with a specified address increment */

dcl  incr fixed binary (18);

	inc = incr;


	call put_word ((fort_opt_macros_$single_inst (mac_num)), (rand), inc);

	text_pos = text_pos + 1;

     end emit_single;

emit_with_tag:
     procedure (mac_num, address, tag);

	/* Emits an instruction with a constant address and a tag field */

dcl  mac_num fixed binary (18),
     address fixed binary (18),
     tag bit (6) aligned;

dcl  1 inst like machine_instruction aligned;

	text_word (text_pos) = unspec (fort_opt_macros_$single_inst (mac_num)) & mask_left;
	instruction (text_pos).tag = tag;
	text_halfs (text_pos).left = address;
	text_pos = text_pos + 1;
	return;
     end emit_with_tag;

emit_zero:
     procedure (mac_num);

	/* Emits an instruction without operands */

dcl  mac_num fixed binary (18);

	if analyzing
	then return;

	text_word (text_pos) = unspec (fort_opt_macros_$single_inst (mac_num));
	text_pos = text_pos + 1;

     end emit_zero;

emit_c_a:
     procedure (mac_num, address);

	/* Emits an instruction given an address probably supplied by c_a */

dcl  mac_num fixed binary (18);			/* Single instruction number */
dcl  address bit (36) aligned;

	if analyzing
	then return;

	text_word (text_pos) = (unspec (fort_opt_macros_$single_inst (mac_num)) & mask_left) | address;

	if fort_opt_macros_$single_inst (mac_num).increment ^= 0
	then if instruction (text_pos).ext_base
	     then instruction (text_pos).offset =
		     instruction (text_pos).offset + fort_opt_macros_$single_inst (mac_num).increment;
	     else text_halfs (text_pos).left =
		     text_halfs (text_pos).left + fort_opt_macros_$single_inst (mac_num).increment;

	text_pos = text_pos + 1;

     end emit_c_a;

emit_c_a_var:
     procedure (mac_num, var_ptr);

	/* Emits an instruction and reloc and listing info given an operand whose address
	   must already be filled in so that m_a need not be called. */

dcl  mac_num fixed binary (18);			/* Single instruction number */
dcl  var_ptr pointer;				/* Pointer to node for operand */

	if analyzing
	then return;

	reloc (text_pos).left_rel = var_ptr -> node.reloc;

	if assembly_list
	then if var_ptr -> node.node_type = array_ref_node
	     then a_name (text_pos) = var_ptr -> array_ref.parent;
	     else a_name (text_pos) = binary (rel (var_ptr), 18, 0);

	call emit_c_a ((mac_num), unspec (var_ptr -> node.address));

     end emit_c_a_var;

emit_c_a_const:
     procedure (mac_num, c_off);

	/* Emits an instruction referencing a constant */

dcl  mac_num fixed binary (18);			/* Instruction template offset */
dcl  c_off fixed binary (18);				/* Const node offset to be used */
dcl  const pointer;
dcl  1 inst like machine_instruction aligned;

	if analyzing
	then return;

	inst = fort_opt_macros_$single_inst (mac_num);
	const = addr (rands (c_off));

	text_word (text_pos) = (unspec (inst) & mask_left) | unspec (const -> constant.address);

	reloc (text_pos).left_rel = const -> constant.reloc;

	call text_ref (const, (inst.increment), fixed (inst.op_code, 10), 0);

	text_pos = text_pos + 1;

     end emit_c_a_const;

emit_temp_store:
     procedure (mac_no, temp);

	/* Emits code to store a temporary, indicators are not affected */

dcl  mac_no fixed binary (18);			/* Mac num of inst to store temp */
dcl  temp fixed binary (18);				/* Node to be stored */

dcl  mac_num fixed binary (18);
dcl  p pointer;

	mac_num = mac_no;
	p = addr (rands (temp));

	if ^p -> node.is_addressable
	then call m_a_except_xreg (p);

	call emit_c_a_var (mac_num, p);
	p -> node.not_in_storage = "0"b;

     end emit_temp_store;

emit_operator_call:
     procedure (tv_offset);

	/* Emits an instruction of the form tsx0 pr0|tv_offset. */

dcl  tv_offset fixed binary (14);
dcl  1 inst aligned like instruction;

	if analyzing
	then return;

	unspec (inst) = ext_base_on;
	inst.offset = tv_offset;
	inst.op = "1110000000"b;			/* 700 (0) - tsx0 */

	text_word (text_pos) = unspec (inst);
	text_pos = text_pos + 1;

     end emit_operator_call;

put_word:
     procedure (inst, p_rand, inc);

	/* Uses inst as a template to put out an instruction with
	   rand as an operand and inc as the increment */

dcl  1 inst like machine_instruction parameter aligned,
     p_rand fixed binary (18),
     inc fixed binary (18);

dcl  p pointer;

dcl  rand fixed binary (18);
dcl  mop fixed binary (18);
dcl  decrement_address bit (1);

	mop = fixed (inst.op_code, 10);

	rand = p_rand;

	if rand < 0
	then do;
	     if fort_instruction_info_$fort_instruction_info_ (mop).A
		| fort_instruction_info_$fort_instruction_info_ (mop).Q
		| fort_instruction_info_$fort_instruction_info_ (mop).indicators
	     then call check_machine_state (mop, 0);

	     if analyzing
	     then return;

	     /* have a count, make it the address */

	     text_word (text_pos) = unspec (inst) & mask_left;

	     /* use direct modifier if possible */

	     if directable (mop)
	     then instruction (text_pos).tag = DL_mod;	/* dl */

	     text_halfs (text_pos).left = rand + bias + inc;
	     return;
	     end;

	p = addr (rands (rand));

	if ^p -> node.is_addressable
	then do;
	     if inc ^= 0
	     then do;
		if p -> node.node_type = array_ref_node
		then if ^p -> array_ref.has_address
		     then if analyzing
			then call optimized_subscript (addr (quad (p -> array_ref.output_by)));
			else do;
			     call print_message (446, fixed (rel (p), 18));
			     stop;
			     end;

		if p -> node.address.ext_base
		then do;
		     call increment_address (p, (inc));
		     decrement_address = "1"b;
		     end;
		end;
	     call m_a (p);
	     end;
	else decrement_address = "0"b;

	if fort_instruction_info_$fort_instruction_info_ (mop).A
	     | fort_instruction_info_$fort_instruction_info_ (mop).Q
	     | fort_instruction_info_$fort_instruction_info_ (mop).indicators
	then call check_machine_state (mop, rand);

	if analyzing
	then do;
	     if decrement_address
	     then call increment_address (p, -inc);
	     call drop_count (rand, 1);
	     return;
	     end;

	text_word (text_pos) = (unspec (inst) & mask_left) | unspec (p -> node.address);

	reloc (text_pos).left_rel = p -> node.reloc;

	if assembly_list
	then if p -> node.node_type = array_ref_node
	     then a_name (text_pos) = p -> array_ref.parent;
	     else a_name (text_pos) = rand;

	if substr (unspec (p -> node.address), 30, 7) = "0000000"b
	then call text_ref (p, (inc), mop, 0);
	else if inc ^= 0
	then if instruction (text_pos).ext_base
	     then if decrement_address
		then call increment_address (p, -inc);
		else instruction (text_pos).offset = instruction (text_pos).offset + inc;
	     else text_halfs (text_pos).left = text_halfs (text_pos).left + inc;

	call drop_count (rand, 1);

     end put_word;

check_machine_state:
     procedure (inst_op_code, sym);

	/* Checks if inst to be emitted modifies machine state, if so use_eaq or use_ind is called */

dcl  inst_op_code fixed binary (18);			/* Op code of instr to be emitted */
dcl  sym fixed binary (18);				/* Variable currently in q or zero */
dcl  opc fixed binary (18);
dcl  s fixed binary (18);
dcl  reg fixed binary (18);
dcl  (
     fstr initial (624),
     dfstr initial (628)
     ) fixed binary internal static;

	opc = inst_op_code;
	s = sym;

	if fort_instruction_info_$fort_instruction_info_ (opc).A & fort_instruction_info_$fort_instruction_info_ (opc).Q
	then reg = EAQ;

	else if fort_instruction_info_$fort_instruction_info_ (opc).A
	then reg = A;

	else if fort_instruction_info_$fort_instruction_info_ (opc).Q
	then reg = Q;

	else reg = 0;

	if reg > 0
	then call use_eaq (s, reg, 0);

	if fort_instruction_info_$fort_instruction_info_ (opc).indicators
	then if reg > 0
	     then current_ms.indicators_valid = reg;

	     else if fort_instruction_info_$fort_instruction_info_ (opc).XR
	     then current_ms.indicators_valid =
		     index (fort_instruction_info_$fort_instruction_info_ (opc).XR, "1"b) + highest_ind_state;

	     else if opc = fstr & current_ms.eaq (EAQ).name = in_eaq | opc = dfstr & current_ms.eaq (EAQ).name = in_deaq
	     then current_ms.indicators_valid = EAQ;

	     else call use_ind ();

     end check_machine_state;

text_ref:
     procedure (pt, inc, mop, desc_no);

	/* Handles reference to the text section */

dcl  pt pointer;					/* Points to addressed node */
dcl  inc fixed binary (18);				/* Address increment */
dcl  mop fixed binary (18);				/* Instruction opcode */
dcl  desc_no fixed binary (18);			/* EIS descriptor number, or 0 */

dcl  temp fixed binary (18);
dcl  (p, q) pointer;
dcl  use_dl bit (1) aligned;
dcl  value bit (36) aligned;

dcl  (
     ldq initial ("236"b3),
     lcq initial ("336"b3),
     adq initial ("076"b3),
     sbq initial ("176"b3)
     ) bit (10) aligned internal static options (constant);

dcl  mf (0:2) fixed binary (6) internal static options (constant) initial (31, 31, 13);
						/* Location of MF within instruction */


	p = pt;

	q = null ();
	if p -> node.node_type = constant_node
	then q = addr (p -> constant.value);
	else if p -> node.node_type = char_constant_node
	then do;
	     value = unspec (p -> char_constant.value);
	     q = addr (value);
	     end;

	if q ^= null ()
	then if inc = 0
	     then if directable (mop)
		then do;

		     /* Attempt to use DL modification for any constant,
		        unless it is an operand of an EIS instruction. */

		     if (q -> half.left = 0) & (desc_no = 0)
		     then do;
			text_halfs (text_pos).left = q -> half.right;
			instruction (text_pos).tag = DL_mod;
						/* dl */
			reloc (text_pos).left_rel = rc_a;
			return;
			end;

		     /* Attempt to use DU modification for any constant,
		        unless it is the first operand of an EIS instruction. */

		     if (q -> half.right = 0) & (desc_no ^= 1)
		     then do;
			text_halfs (text_pos).left = q -> half.left;
			substr (text_word (text_pos - desc_no), mf (desc_no), 6) = DU_mod;
			reloc (text_pos).left_rel = rc_a;
			return;
			end;

		     if q -> int_image < 0
		     then do;

			/* attempt to optimize negative constants */

			temp = -q -> int_image;
			q = addr (temp);

			if q -> half.left = 0
			then do;
			     use_dl = "1"b;

			     if instruction (text_pos).op = ldq
			     then instruction (text_pos).op = lcq;

			     else if instruction (text_pos).op = adq
			     then instruction (text_pos).op = sbq;

			     else if instruction (text_pos).op = sbq
			     then instruction (text_pos).op = adq;

			     else if instruction (text_pos).op = lcq
			     then instruction (text_pos).op = ldq;

			     else use_dl = "0"b;

			     if use_dl
			     then do;
				text_halfs (text_pos).left = q -> half.right;
				instruction (text_pos).tag = DL_mod;
				reloc (text_pos).left_rel = rc_a;
				return;
				end;
			     end;
			end;
		     end;

	p -> node.allocate = "1"b;

	if ^p -> node.allocated
	then do;
	     text_halfs (text_pos).left = inc;

	     /* add this forward reference to a list of forward refs */

	     if next_free_polish >= polish_max_len
	     then call print_message (407, "polish region", char (polish_max_len));

	     if p -> node.operand_type = external
	     then p = addr (rands (p -> symbol.initial));

	     next_free_polish = next_free_polish + 1;

	     forward_refs (next_free_polish - 1).operand = fixed (rel (p), 18);
	     forward_refs (next_free_polish - 1).instruction = text_pos;

	     end;

	else if inc ^= 0
	then text_halfs (text_pos).left = text_halfs (text_pos).left + inc;

	/* try to use a direct modifier with a rel_constant */

	if p -> node.operand_type = rel_constant
	then if directable (mop)
	     then instruction (text_pos).tag = DL_mod;	/* dl */

     end text_ref;

emit_eis:
     procedure ();

	/* Emits a single EIS instruction, presently assumed to
	   be 1 instruction word + 2 descriptor words.  Only
	   desc9a is allowed for now.  An example follows:

	   emit_eis

	   mlr	(pr),(pr),fill(040)
	   desc9a	op1
	   desc9a	arg2+3

	   If the length field is omitted, which is the usual
	   case, the interpreter supplies it.  The interpreter
	   supplies the Modification Fields.  All operands are
	   assumed to be character strings.  If the equal_lengths
	   keyword is given, the length of the second operand is
	   taken to be identical to the length of the first. */

dcl  arg (2) pointer;
dcl  op (2) fixed binary (18);
dcl  len (2) fixed binary (18);
dcl  lreg (2) bit (6) aligned;
dcl  inc (2) fixed binary (18);
dcl  opcode bit (10) aligned;

dcl  1 descriptor (0:262143) based (object_base) aligned,
       2 word_address bit (18) unaligned,
       2 char bit (2) unaligned,
       2 bit bit (4) unaligned,
       2 length bit (12) unaligned;

dcl  mf (3) fixed binary (6) internal static options (constant) initial (30, 12, 3);

dcl  (
     cmpc initial ("0010001101"b),			/* 106 (1) */
     scm initial ("0010101001"b),			/* 124 (1) */
     scd initial ("0010100001"b)
     )						/* 120 (1) */
	bit (10) aligned internal static options (constant);

dcl  (i, inst_pos) fixed binary (18);

dcl  bit builtin;

	imac = imac + 1;				/* point at the instruction */

	/* pick up the operands and address increments */

	do i = 1 to 2;
	     op (i) = stack (get_operand ((machine_instruction (imac + i).operand)));
	     arg (i) = addr (rands (op (i)));
	     inc (i) = machine_instruction (imac + i).increment;
	     lreg (i) = "00"b3;
	     end;

	/* Make operands addressable, reserving registers as needed */

	call make_both_addressable (arg, inc);

	/* Get lengths of operands, reserving registers as needed */

	call get_eis_length (1);			/* Get length of 1st opnd */

	if left > 0				/* Equal lengths? */
	then if mac_base -> descriptor (imac + 2).length = "000"b3
	     then do;

		/* Copy length info from 1st opnd to 2nd */

		len (2) = len (1);
		lreg (2) = lreg (1);
		end;

	     else call print_message (466);

	else call get_eis_length (2);			/* Get length for opnd 2 */

	/* Move in the instruction word */

	inst_pos = text_pos;
	text_word (text_pos) = unspec (machine_instruction (imac));
	opcode = machine_instruction (imac).op_code;

	/* fill in the descriptors and modification fields */

	do i = 1 to 2;
	     imac = imac + 1;
	     text_pos = text_pos + 1;

	     substr (text_word (inst_pos), mf (i), 7) = substr (unspec (arg (i) -> node.address), 30, 7);

	     if lreg (i)
	     then substr (text_word (inst_pos), mf (i) + 1, 1) = "1"b;

	     /* Fill in address of descriptor, including char and bit offsets */

	     substr (unspec (descriptor (text_pos)), 1, 24) = substr (unspec (arg (i) -> node.address), 1, 20);

	     if lreg (i)
	     then descriptor (text_pos).length = (6)"0"b || lreg (i);
	     else descriptor (text_pos).length = bit (fixed (len (i), 12), 12);

	     if ^analyzing
	     then reloc (text_pos).left_rel = arg (i) -> node.reloc;

	     if assembly_list & ^analyzing
	     then if arg (i) -> node.node_type = array_ref_node
		then a_name (text_pos) = arg (i) -> array_ref.parent;
		else a_name (text_pos) = op (i);

	     if substr (unspec (arg (i) -> node.address), 30, 7) = "0"b & ^analyzing
	     then call text_ref (arg (i), inc (i), fixed (opcode, 10), i);
	     else if inc (i) ^= 0
	     then if arg (i) -> node.ext_base
		then if ^arg (i) -> node.is_addressable
		     then call increment_address (arg (i), -inc (i));
		     else instruction (text_pos).offset = instruction (text_pos).offset + inc (i);
		else text_halfs (text_pos).left = text_halfs (text_pos).left + inc (i);

	     /* If the output of this EIS instruction (its second
	        operand) is a temporary, do not drop its reference
	        count.  Note that the cmpc, scd, and scm instructions
	        have no outputs in this sense. */

	     if i = 1				/* Always drop 1st operand */
		| arg (i) -> node.node_type = array_ref_node
						/* Always drop array refs */
		| opcode = cmpc			/* Has no output */
		| opcode = scd			/* Has no output */
		| opcode = scm			/* Has no output */
	     then call drop_count ((op (i)), 1);

	     end;

	text_pos = text_pos + 1;

	/* Free regs used by addresses and lengths of EIS operands */

	call free_regs ();

	return;

get_eis_length:
     procedure (opno);

	/* Internal procedure to emit_eis.  Computes the length of the
	   specified operand of the EIS instruction, setting len and
	   lreg. */

dcl  (opno, i) fixed binary;				/* Operand number */
dcl  csize fixed binary (18);				/* Character size of opnd */

	i = opno;

	if mac_base -> descriptor (imac + i).length = "000"b3
	then do;

	     /* Length not given, figure it out */

	     csize = get_char_size ((arg (i)));
	     if csize < 0
	     then len (i) = csize + bias;
	     else do;
		if addr (rands (csize)) -> node.value_in.eaq
		then lreg (i) = eaq_man_load_a_or_q (addr (rands (csize)));
		else lreg (i) = xr_man_load_any_xr (addr (rands (csize)));
		len (i) = 0;
		end;
	     end;

	else len (i) = fixed (mac_base -> descriptor (imac + i).length, 12);

	/* If constant length will not fit in 12 bits, put it in an index register */

	if len (i) > 4095
	then lreg (i) = xr_man_load_const (len (i));

	/* Reserve the register used for length */

	call lock_tag_register ((lreg (i)));

     end get_eis_length;

     end emit_eis;

/**** ADDRESSING SECTION ****/

m_a:
     procedure (pt);

	/* make_addressable */

dcl  (p, pt, s, v) pointer;
dcl  off fixed binary (18);

	p = pt;

	if p -> node.is_addressable
	then return;

	if p -> node.address_in_base
	then do;
	     p -> node.address.base = base_man_load_any_pr (1, fixed (rel (p), 17), 0);
	     return;
	     end;

	if p -> node.node_type = array_ref_node
	then do;
	     s = addr (rands (p -> array_ref.parent));
	     if ^p -> array_ref.has_address
	     then if analyzing
		then call optimized_subscript (addr (quad (p -> array_ref.output_by)));
		else do;
		     call print_message (446, fixed (rel (p), 18));
		     stop;
		     end;

	     if p -> array_ref.variable_offset
	     then do;
		off = p -> array_ref.v_offset;
		v = addr (rands (off));
		if p -> array_ref.large_offset | (^analyzing & v -> node.value_in.eaq)
		then do;

		     /* Process array-ref of VLA.  'v' is the total Packed Pointer.  If it is in
		        the Q or A register then we leave it and will later use epp,easp, else if
		        it is in storage then we can use an lprp. */

		     if ^s -> symbol.VLA
		     then p -> array_ref.address.tag = eaq_man_load_a_or_q (v);
		     end;
		else p -> array_ref.address.tag = xr_man_load_any_xr (v);
		end;

	     end;

	call m_a_except_xreg (p);

	if p -> node.data_type = char_mode & p -> node.units ^= char_units
	then do;
	     if ^from_base_man
	     then if p -> node.address.tag
		then do;
		     p -> node.addr_hold = substr (unspec (p -> node.address), 1, 18);
		     p -> node.reloc_hold = p -> node.reloc;
		     p -> node.address.base = base_man_load_any_pr (1, fixed (rel (p), 17), 0);
		     p -> node.address.offset = 0;
		     p -> node.address.tag = "0"b;
		     p -> node.reloc = rc_a;
		     end;
	     end;

     end m_a;

m_a_except_xreg:
     procedure (pt);

	/* make_addressable, but don't call xr_man and don't do special aligned character addressing */

dcl  (p, pt) pointer;				/* Node to be made addressable */
dcl  p1 pointer;					/* Node to get addressing info from */
dcl  (i, offset) fixed binary (18);

	p = pt;

	if p -> node.node_type = array_ref_node
	then p1 = addr (rands (p -> array_ref.parent));
	else do;
	     p1 = p;
	     if analyzing
	     then if unspec (p -> node.address) = "0"b
		then if p -> node.node_type = temporary_node
		     then call assign_address_to_temp (fixed (rel (p), 18), 0);
	     end;

	if p1 -> node.needs_pointer
	then do;

	     if last_pr_locked_for_pl1_ops_arg > 0
	     then cur_lp -> loop.avoid_pr (last_pr_locked_for_pl1_ops_arg) = "1"b;

	     /* prevent a multi-position VLA parameter from missing VLA processing. */

	     if p1 -> node.stack_indirect & ^(p1 -> node.node_type = symbol_node & p1 -> symbol.VLA)
	     then do;
		i = 4;
		if p1 -> node.node_type = temporary_node
		then do;
		     offset = fixed (substr (p1 -> node.addr_hold, 4, 15), 15);
		     if offset >= 16384
		     then offset = offset - 32768;
		     if p1 -> temporary.large_address
		     then offset = offset + p1 -> temporary.location;
		     p -> temporary.address.base = base_man_load_any_pr (i, offset, 0);
		     return;
		     end;
		end;

	     /* Must be a symbol node */

	     else if p1 -> symbol.VLA
	     then do;
		p -> node.address.base = base_man_load_any_pr (1, fixed (rel (p), 17, 0), 0);
		return;
		end;				/* we are pointer at our pointer */
	     else if p1 -> symbol.LA
	     then do;
		if p1 -> symbol.static
		then i = 11;			/* static indirect */
		else i = 4;			/* stack */
		p1 = addr (rands (p1 -> symbol.parent));
		end;
	     else if p1 -> symbol.in_common
	     then do;
		i = 3;
		p1 = addr (rands (p1 -> symbol.parent));
		end;
	     else if p1 -> symbol.parameter
	     then i = 2;
	     else if p1 -> symbol.descriptor
	     then i = 10;
	     else do;
		call print_message (417, fixed (rel (p), 18));
		return;
		end;

	     if ^p -> symbol.large_address
	     then p -> symbol.address.base = base_man_load_any_pr (i, (p1 -> node.location), 0);
	     else p -> symbol.address.base = base_man_load_any_pr (i, (p1 -> node.location), (p -> symbol.location));
	     end;

	else if p1 -> node.node_type = symbol_node
	then do;
	     if p1 -> symbol.external & p1 -> symbol.initial ^= 0
	     then do;

		/* have an  external subr or func reference
		   that is really local */

		p1 = addr (rands (p1 -> symbol.initial));

		if p1 -> symbol.allocated & ^analyzing
		then do;
		     unspec (p -> symbol.address) = unspec (p1 -> symbol.address);
		     p -> symbol.allocated, p -> symbol.is_addressable = "1"b;
		     end;
		end;

	     else if p1 -> symbol.parameter
	     then p -> node.address.base = base_man_load_arg_ptr ();

	     else call m_a_check_large_address (p, p1);
	     end;

	else call m_a_check_large_address (p, p1);

     end m_a_except_xreg;

m_a_check_large_address:
     procedure (pt, pt1);

	/* Handles large addresses */

dcl  (pt, p, pt1, p1) pointer;
dcl  usual_base bit (3) aligned;
dcl  i fixed binary (18);

	p = pt;
	p1 = pt1;

	if p -> node.large_address
	then do;

	     /* have abs(address) >= 16K */

	     if last_pr_locked_for_pl1_ops_arg > 0
	     then cur_lp -> loop.avoid_pr (last_pr_locked_for_pl1_ops_arg) = "1"b;

	     usual_base = sp;
	     if p1 -> node.node_type = symbol_node
	     then if p1 -> symbol.static | p1 -> symbol.external
		then usual_base = lp;

	     i = p -> node.location;

	     if i ^= 0
	     then p -> node.address.base = base_man_load_large_base (i, usual_base);

	     else p -> node.address.base = usual_base;

	     end;

     end m_a_check_large_address;

increment_address:
     procedure (p, inc);

	/* Applies increment to address of node */

dcl  p pointer,
     inc fixed binary (18);

dcl  (loc, offset) fixed binary (18);

	if ^p -> node.large_address
	then p -> node.address.offset = p -> node.address.offset + inc;

	else do;
	     loc, offset = p -> node.address.offset + p -> node.location + inc;
	     offset = mod (offset + 16384, 32768) - 16384;
	     p -> node.location = loc - offset;
	     p -> node.address.offset = offset;
	     end;

     end increment_address;

c_a:
     procedure (c, code) returns (bit (36) aligned);

	/* Fabricates a constant address to be used with emit_c_a */

dcl  (c, n, code) fixed binary (18);

dcl  1 inst_address aligned like symbol.address;

	n = c;
	unspec (inst_address) = "0"b;
	go to sw (code);

sw (1):						/* n,ql */
	inst_address.tag = QL_mod;
	go to exit;

sw (5):						/* location n in the linkage section */
	inst_address.base = lp;
	go to set_ext_base;

sw (6):						/* location n in the stack */
	inst_address.base = sp;
	go to set_ext_base;

sw (3):						/* location n indirect in linkage section */
sw (11):						/* location n indirect in static section */
	inst_address.base = lp;
	go to indirect;

sw (4):						/* location n indirect in stack */
	inst_address.base = sp;

indirect:
	inst_address.tag = inst_address.tag | "010000"b;

set_ext_base:
	inst_address.ext_base = "1"b;

	if n >= 16384
	then do;
	     n = mod (n + 16384, 32768) - 16384;
	     inst_address.base = base_man_load_large_base (c - n, (inst_address.base));
	     end;

exit:
	inst_address.offset = n;
	return (unspec (inst_address));

     end c_a;

c_a_18:
     procedure (n, code) returns (bit (36) aligned);

	/* Fabricates a constant address with 18 bit offset field for use with emit_c_a */

dcl  n fixed binary (18),				/* Offset */
     code fixed binary (18);				/* 1 = DU */

dcl  1 inst_address aligned,
       2 offset fixed binary (17) unaligned,
       2 op_code bit (10) unaligned,
       2 inhibit bit (1) unaligned,
       2 ext_base bit (1) unaligned,
       2 tag bit (6) unaligned;

	unspec (inst_address) = "0"b;

	inst_address.offset = n;

	if code = 1
	then inst_address.tag = DU_mod;

	return (unspec (inst_address));

     end c_a_18;

c_a_tag:
     procedure (n) returns (bit (36) aligned);

	/* Fabricates a constant address with a specified tag */

dcl  n fixed binary (3);
dcl  1 inst_address aligned like symbol.address;

	unspec (inst_address) = "0"b;
	inst_address.tag = "001"b || bit (n, 3);
	return (unspec (inst_address));

     end c_a_tag;

make_both_addressable:
     procedure (arg, inc);

	/* Makes two operands simultaneously addressable by reserving
	   registers as it goes. */

dcl  arg (2) pointer;
dcl  inc (2) fixed binary (18);
dcl  (i, reg) fixed binary (3);
dcl  p pointer;

	do i = 1 to 2;

	     p = arg (i);

	     if ^p -> node.is_addressable
	     then do;

		if inc (i) ^= 0
		then do;
		     if p -> node.node_type = array_ref_node
		     then if ^p -> array_ref.has_address
			then if analyzing
			     then call optimized_subscript (addr (quad (p -> array_ref.output_by)));
			     else do;
				call print_message (446, fixed (rel (p), 18));
				stop;
				end;
		     if p -> node.address.ext_base
		     then call increment_address (p, (inc (i)));
		     end;

		call m_a (p);

		/* Reserve any XRs or EAQ registers used */

		call lock_tag_register ((p -> node.address.tag));

		/* Reserved any base registers used */

		if p -> node.address.ext_base
		then do;
		     reg = which_base (fixed (p -> node.address.base, 3));
		     call lock_base (reg);
		     end;

		end;

	     end;

     end make_both_addressable;

/**** POINTER REGISTER MANAGEMENT ****/

	/* The contents of the pointer registers are determined by the
	   value of the type field as follows:
	   (v = variable field)

	   -1		UNKNOWN
	   0		EMPTY
	   1		address of operand specified by v (usually an aligned char-string)
	   2		ptr to loc v in arg list
	   3		ptr thru link with offset v
	   4		ptr at stack offset v
	   5		arg list ptr
	   6		linkage ptr
	   7		value of operand specified by v
	   8		stack ptr
	   9		ptr to arg descriptor list
	   10		ptr to loc v in desc list
	   11		ptr thru static with offset v
	*/

base_man_load_any_pr:
     procedure (code, num, offset) returns (bit (3) aligned);

dcl  (n, code) fixed binary (18),			/* type of operation */
     (v, num) fixed binary (18),			/* location of ptr to be loaded */
     (off, offset) fixed binary (18);			/* offset to be added to pointer */

dcl  VLA bit (1);					/* True if VLA */
dcl  s ptr;

dcl  (i, j, k) fixed binary (3);
dcl  address bit (36) aligned;
dcl  diff fixed binary (18);

	n = code;
	v = num;
	diff, off = offset;

	if analyzing
	then if n ^= 1
	     then call add_global_ptr (n, v, off);

	j, k = 0;

	do i = first_base to last_base;
	     if current_ms.base_regs (i).type = 0
	     then k = i;
	     else if current_ms.base_regs (i).type = n
	     then if current_ms.base_regs (i).variable = v
		then if current_ms.base_regs (i).offset = off
		     then do;
			current_ms.base_regs (i).used = text_pos;
			return (bases (i));
			end;
		     else j = i;
	     end;

	if j > 0
	then do;

	     /* we've got the right storage area, but the wrong offset */

	     diff = off - current_ms.base_regs (j).offset;
	     address = c_a (0, 6);
	     substr (address, 1, 3) = bases (j);

	     i = get_free_reg (current_ms.base_regs, first_base, last_base, find_global_base (n, v, off), k);

	     call flush_base (i);

	     call emit_c_a ((load_base (i)), address);
	     end;

	else if n = 1
	then do;
	     s = addr (rands (v));
	     if s -> node.node_type = symbol_node
	     then VLA = s -> symbol.VLA;
	     else if s -> node.node_type = array_ref_node
	     then VLA = addr (rands (s -> array_ref.parent)) -> symbol.VLA;
	     else VLA = "0"b;
	     s -> node.address_in_base = "1"b;
	     current_ms.address_in_base = "1"b;

	     i = get_free_reg (current_ms.base_regs, first_base, last_base, find_global_base (n, v, off), k);

	     call flush_base (i);

	     /* A very large reference can be of two types:
	        1. array-reference.  in this case the vsum of the reference is in memory
	        and is the total addressor needed by lprp.
	        2. normal-reference. in this case the address in the symbol node is
	        sufficient to address directly a base to the variable for
	        lprp.
	     */

	     if VLA
	     then call base_man_load_VLA (v, i);
	     else call emit_c_a_var ((load_base (i)), addr (rands (v)));

	     if analyzing
	     then call add_local_ptr;
	     end;

	else if n = 2 | n = 10
	then do;
	     address = c_a (v, 4);
	     if n = 2
	     then substr (address, 1, 3) = base_man_load_arg_ptr ();
	     else substr (address, 1, 3) = base_man_load_desc_ptr ();

	     i = get_free_reg (current_ms.base_regs, first_base, last_base, find_global_base (n, v, off), 0);

	     call flush_base (i);

	     call emit_c_a ((load_base (i)), address);
	     end;

	else do;
	     address = c_a (v, n);

	     if v >= 16384
	     then k = 0;				/* base_regs state was changed. */

	     i = get_free_reg (current_ms.base_regs, first_base, last_base, find_global_base (n, v, off), k);

	     call flush_base (i);

	     if ^analyzing
	     then if n = 3				/* linkage indirect */
		then reloc (text_pos).left_rel = rc_lp15;
		else if n = 11			/* static indirect */
		then reloc (text_pos).left_rel = rc_is15;

	     call emit_c_a ((load_base (i)), address);
	     end;

	if diff ^= 0
	then call emit_c_a ((add_base (i)), c_a_18 (diff, 1));

	current_ms.base_regs (i).type = n;
	current_ms.base_regs (i).variable = v;
	current_ms.base_regs (i).offset = off;
	current_ms.base_regs (i).used = text_pos;
	return (bases (i));

     end base_man_load_any_pr;

base_man_load_VLA:
     proc (opnd, which);

dcl  opnd fixed bin (18),
     which fixed bin (3);

dcl  llr_18_instruction bit (36) aligned static options (constant) init ("00002277700"b3);

dcl  offset fixed bin (18),
     p ptr,
     storage_class fixed bin (18),
     v ptr,
     v_offset fixed bin (18);

	p = addr (rands (opnd));
	if p -> node.node_type = array_ref_node
	then do;
	     v_offset = p -> array_ref.v_offset;
	     v = addr (rands (v_offset));
	     if ^v -> node.not_in_storage
	     then call emit_c_a_var (load_packed_base (which), v);
	     else if get_eaq_name (v_offset) ^= in_q & ^analyzing
	     then call print_message (440, "addressing a VLA element");
						/*  Addressor must be in Q if not in storage.  */
	     else if text_word (max (0, text_pos - 1)) = llr_18_instruction
	     then do;				/*  We just expanded a 'form_VLA_packed_ptr' macro.  */
		text_pos = text_pos - 2;		/*  Backup to 'div pr0|VLA_words_per_seg'.  */
		call emit_c_a (load_base (which), (30)"0"b || AL_mod);
		call emit_c_a (load_segment_num (which), (30)"0"b || QL_mod);
		if get_ref_count (p) > 1 | get_ref_count (v) > 1
		then call emit_temp_store (store_packed_base (which), v_offset);
		else v -> temporary.not_in_storage = "0"b;
						/*  A small lie to prevent storing of the subscript.  */
		end;
	     else if get_ref_count (p) > 1 | get_ref_count (v) > 1
	     then do;
		call emit_temp_store (store_inst (get_eaq_name (v_offset)), v_offset);
		call emit_c_a_var (load_packed_base (which), v);
		end;
	     else do;
		call emit_c_a (load_base (which), (30)"0"b || QL_mod);
		call emit_c_a (load_segment_num (which), (30)"0"b || QU_mod);
		v -> temporary.not_in_storage = "0"b;	/*  A small lie to prevent storing of the subscript.  */
		end;
	     end;
	else if p -> node.node_type = symbol_node
	then do;

	     /* for non-dimensioned symbols, use the saved offset information. */
	     if ^p -> symbol.dimensioned
	     then substr (unspec (p -> symbol.address), 1, 18) = p -> symbol.addr_hold;
	     offset = p -> symbol.address.offset;
	     if p -> symbol.large_address
	     then offset = offset + p -> symbol.location;
	     if p -> symbol.in_common | p -> symbol.static
	     then storage_class = 5;
	     else storage_class = 6;
	     if assembly_list
	     then a_name (text_pos) = opnd;
	     reloc (text_pos).left_rel = p -> symbol.reloc;
	     call emit_c_a (load_packed_base (which), c_a (offset, storage_class));

	     /* Zero the offset in non-dimensioned symbols since all
	        references through the pointer just created must be
	        prN|0 references. */
	     if ^p -> symbol.dimensioned
	     then p -> symbol.address.offset = 0;
	     end;
	else call print_message (470, opnd, "base_man_load_VLA");
     end base_man_load_VLA;

flush_base:
     procedure (i);

	/* Empties a pointer register prior to reuse. */

dcl  i fixed binary (3);				/* base reg to flush */
dcl  p pointer;

	if current_ms.base_regs (i).type = 1
	then do;
	     p = addr (rands (current_ms.base_regs (i).variable));
	     p -> node.address_in_base = "0"b;

	     if p -> node.stack_indirect
	     then if p -> node.node_type = temporary_node
		then if p -> temporary.not_in_storage
		     then do;

			/* Store pointer to dynamic temp */

			call base_man_store_temp (p, (i));
			ptr_data.local = ptr_data.local - 1;
			return;
			end;

	     /* Restore address of aligned character string */

	     substr (unspec (p -> node.address), 1, 18) = p -> node.addr_hold;
	     p -> node.reloc = p -> node.reloc_hold;
	     ptr_data.local = ptr_data.local - 1;
	     end;

	else if current_ms.base_regs (i).type = 7
	then ptr_data.local = ptr_data.local - 1;

     end flush_base;

base_man_load_pr:
     procedure (opnd, which, lock_it);

	/* Loads the address of an operand into the
	   specified register and reserves the register
	   if asked to do so */

dcl  opnd fixed binary (18),				/* Index of operand */
     which fixed binary (18),				/* Register to use */
     lock_it bit (1) aligned;

dcl  i fixed binary (3);
dcl  op fixed binary (18);
dcl  p pointer;
dcl  1 inst_address aligned like node.address;
dcl  tag_hold bit (6) aligned;
dcl  char_num_hold fixed binary (2) aligned;
dcl  VLA bit (1);

	from_base_man = "1"b;

	i = which;
	op = opnd;
	p = addr (rands (op));

	/* force addressability so we can look at the address */

	if p -> node.node_type = symbol_node
	then VLA = p -> symbol.VLA;
	else if p -> node.node_type = array_ref_node
	then VLA = addr (rands (p -> array_ref.parent)) -> symbol.VLA;
	else VLA = "0"b;

	if ^p -> node.is_addressable & ^VLA		/* VLA is always addressable */
	then call m_a (p);

	if p -> node.units = char_units
	then do;

	     /* Tag specifies a character offset in a register.  Save
	        the tag, so epp does not use it, and deal with it
	        manually below. Do the same for char_num. */

	     tag_hold = p -> node.address.tag;
	     p -> node.address.tag = "00"b3;
	     char_num_hold = p -> node.address.char_num;
	     p -> node.address.char_num = 0;
	     end;

	call flush_base (i);

	/* If we are dealing in char_units, then we want to avoid
	   calling m_a and setting node.address.tag.  Therefore,
	   we use emit_c_a_var instead of emit_single. */

	if p -> node.address.base ^= bases (i) | ^p -> node.address.ext_base | p -> node.address.offset ^= 0
	     | p -> node.address.tag ^= "00"b3
	then if p -> node.units = char_units		/* characters cannot be VLA's so no code here. */
	     then do;
		call emit_c_a_var ((load_base (i)), p);
		call drop_count (op, 1);
		end;
	     else if VLA
	     then call base_man_load_VLA (op, i);
	     else call emit_single ((load_base (i)), op);
	else call drop_count (op, 1);

	if p -> node.units = char_units
	then do;

	     /* Handle character offsets */

	     unspec (inst_address) = ext_base_on;	/* Initialize address for a9bd instructions */
	     inst_address.base = bases (i);

	     if char_num_hold ^= 0
	     then if tag_hold & "001000"b
		then do;

		     /* Have constant offset + offset in XR */

		     inst_address.tag = xr_man_add_const (binary (substr (tag_hold, 4, 3), 3), (char_num_hold));
		     call emit_c_a (a9bd, unspec (inst_address));
		     end;

		else if tag_hold ^= "00"b3
		then do;

		     /* have constant offset + offset not in XR */

		     inst_address.tag = xr_man_load_const ((char_num_hold));
		     call emit_c_a (a9bd, unspec (inst_address));
		     inst_address.tag = tag_hold;
		     call emit_c_a (a9bd, unspec (inst_address));
		     end;

		else do;

		     /* Constant offset only */

		     inst_address.tag = xr_man_load_const ((char_num_hold));
		     call emit_c_a (a9bd, unspec (inst_address));
		     end;

	     else if tag_hold ^= "00"b3
	     then do;

		/* Variable offset only */

		inst_address.tag = tag_hold;
		call emit_c_a (a9bd, unspec (inst_address));
		end;

	     p -> node.address.tag = tag_hold;		/* Restore original tag */
	     p -> node.address.char_num = char_num_hold;	/* and char_num */

	     end;

	current_ms.base_regs (i).variable = op;		/* debugging */
	current_ms.base_regs (i).offset = 0;
	current_ms.base_regs (i).used = text_pos;

	if lock_it
	then do;
	     current_ms.base_regs (i).type = -1;	/* unknown value */
	     call lock_base (i);
	     if analyzing & i >= first_base & i <= last_base
	     then last_pr_locked_for_pl1_ops_arg = i;
	     end;
	else current_ms.base_regs (i).type = 0;		/* empty */

	if analyzing
	then do;
	     cur_lp -> loop.erases.pr (i) = "1"b;
	     ptr_data.max_local = max (ptr_data.max_local, ptr_data.local + 1);
	     end;

	from_base_man = "0"b;

     end base_man_load_pr;

base_man_load_pr_value:
     procedure (opnd, which);

	/* Loads the value of an operand into the specified register */

dcl  opnd fixed binary (18),				/* Index of operand */
     which fixed binary (18);				/* Register to use */

dcl  i fixed binary (3);
dcl  op fixed binary (18);
dcl  p pointer;

	op = opnd;
	p = addr (rands (op));
	i = which;

	/* load value if it is not loaded already */

	if current_ms.base_regs (i).type ^= 7 | current_ms.base_regs (i).variable ^= op
	     | current_ms.base_regs (i).offset ^= 0
	then do;

	     /*  force addressability so we can look at the address */

	     if ^p -> node.is_addressable
	     then call m_a (p);

	     call flush_base (i);

	     if substr (p -> node.address.tag, 1, 2)	/* node addr already has a modifier */
	     then call print_message (416, op);		/* illegal address field */

	     substr (p -> node.address.tag, 1, 2) = "01"b;/* RI */

	     call emit_c_a_var ((load_base (i)), p);

	     substr (p -> node.address.tag, 1, 2) = "00"b;/* restore tag */

	     current_ms.base_regs (i).type = 7;		/* value of op in pr */
	     current_ms.base_regs (i).variable = op;	/* debugging */
	     current_ms.base_regs (i).offset = 0;

	     if analyzing
	     then do;
		cur_lp -> loop.erases.pr (i) = "1"b;
		call add_local_ptr;
		end;
	     end;

	current_ms.base_regs (i).used = text_pos;

     end base_man_load_pr_value;

base_man_load_large_base:
     procedure (offset, base) returns (bit (3) aligned);

	/* Loads pointer register with contents(base) + offset.
	   This routine is used to deal with address offsets >= 16K. */

dcl  (off, offset) fixed binary (18),
     base bit (3) aligned;				/* MUST BE sp or lp */

dcl  (i, k) fixed binary (3);
dcl  code fixed binary (18);
dcl  1 inst_address aligned like symbol.address;

	off = offset;

	if base = lp
	then code = 6;
	else code = 8;

	if analyzing
	then call add_global_ptr (code, 0, off);

	i = 0;

	do k = first_base to last_base;
	     if current_ms.base_regs (k).type = 0 & ^current_ms.base_regs (k).reserved
	     then i = k;
	     else if current_ms.base_regs (k).type = code & current_ms.base_regs (k).offset = off
	     then do;
		current_ms.base_regs (k).used = text_pos;
		return (bases (k));
		end;
	     end;

	/* At this stage "i" is the free register.  The following code assumes that
	   "k" is the global register.  (bug fix 82-08-16) TO. */

	/* Here we go through a long chain of finding potential free registers.  The
	   reason for this is that we may be within a loop and have to take one of the
	   globally assigned registers. */

	k = find_global_base (code, 0, off);		/* See if we are already assigned. */
	if i = 0 & k = 0
	then do;
	     do i = last_base to first_base by -1 while (k = 0);
						/* Find loc v in arg list */

		/* Scan order chosen to pick out globally assigned registers in order of least use. */

		if ^current_ms.base_regs (i).reserved & current_ms.base_regs (i).type = 2
		then k = i;
		end;

	     do i = last_base to first_base by -1 while (k = 0);
						/* Find link with offset v */
		if ^current_ms.base_regs (i).reserved & current_ms.base_regs (i).type = 3
		then k = i;
		end;

	     do i = last_base to first_base by -1 while (k = 0);
						/* Find ptr at stack offset v */
		if ^current_ms.base_regs (i).reserved & current_ms.base_regs (i).type = 4
		then k = i;
		end;

	     do i = last_base to first_base by -1 while (k = 0);
						/* Find operand spec by v */
		if ^current_ms.base_regs (i).reserved & current_ms.base_regs (i).type = 7
		then k = i;
		end;

	     end;
	else if k = 0
	then k = i;				/* Use global register */

	i = get_free_reg (current_ms.base_regs, first_base, last_base, k, k);

	call flush_base (i);

	unspec (inst_address) = ext_base_on;
	inst_address.base = base;

	call emit_c_a ((load_base (i)), unspec (inst_address));
	call emit_c_a ((add_base (i)), c_a_18 (off, 1));

	if current_ms.base_regs (i).type ^= code	/* If we stole one */
	then current_ms.base_regs (i).global = "0"b;

	current_ms.base_regs (i).type = code;
	current_ms.base_regs (i).variable = 0;
	current_ms.base_regs (i).offset = off;
	current_ms.base_regs (i).used = text_pos;

	return (bases (i));

     end base_man_load_large_base;

base_man_load_large_base_no_flush:
     procedure (offset, base, which) returns (bit (3) aligned);

	/* Analogous to base_man_load_large_base, except that the
	   register to load is specified and flush_base is not called,
	   to avoid recursion. */

dcl  offset fixed binary (18);
dcl  base bit (3) aligned;
dcl  which fixed binary (3);

dcl  1 inst_address like node.address;

	unspec (inst_address) = ext_base_on;
	inst_address.base = base;

	call emit_c_a ((load_base (which)), unspec (inst_address));
	call emit_c_a ((add_base (which)), c_a_18 ((offset), 1));

	if base = sp
	then current_ms.base_regs (which).type = 8;
	else current_ms.base_regs (which).type = 6;
	current_ms.base_regs (which).variable = 0;
	current_ms.base_regs (which).offset = offset;
	current_ms.base_regs (which).used = text_pos;

	return (bases (which));

     end base_man_load_large_base_no_flush;

base_man_load_arg_ptr:
     procedure () returns (bit (3) aligned);

	/* Loads a pointer register with a pointer to the argument list. */

dcl  (i, k) fixed binary (3);
dcl  n fixed binary (18);

	if analyzing
	then call add_global_ptr (5, 0, 0);

	k = 0;

	do i = first_base to last_base;
	     if current_ms.base_regs (i).type = 0
	     then k = i;
	     else if current_ms.base_regs (i).type = 5
	     then do;
		current_ms.base_regs (i).used = text_pos;
		return (bases (i));
		end;
	     end;

	i = get_free_reg (current_ms.base_regs, first_base, last_base, find_global_base (5, 0, 0), k);
	call flush_base (i);

	if cs -> subprogram.subprogram_type = main_program
	then n = arg_ptr;
	else n = cs -> subprogram.entry_info + 2;

	call emit_c_a ((load_base (i)), c_a (n, 4));

	current_ms.base_regs (i).type = 5;
	current_ms.base_regs (i).variable = 0;
	current_ms.base_regs (i).used = text_pos;
	current_ms.base_regs (i).offset = 0;

	return (bases (i));

     end base_man_load_arg_ptr;

base_man_load_desc_ptr:
     procedure () returns (bit (3) aligned);

	/* Loads a pointer register with a pointer to the argument
	   descriptor list. */

dcl  (i, k) fixed binary (3);
dcl  n fixed binary (18);

	if analyzing
	then call add_global_ptr (9, 0, 0);

	k = 0;

	do i = first_base to last_base;
	     if current_ms.base_regs (i).type = 0
	     then k = i;
	     else if current_ms.base_regs (i).type = 9
	     then do;
		current_ms.base_regs (i).used = text_pos;
		return (bases (i));
		end;
	     end;

	i = get_free_reg (current_ms.base_regs, first_base, last_base, find_global_base (9, 0, 0), k);
	call flush_base (i);

	if cs -> subprogram.subprogram_type = main_program
	then n = descriptor_ptr;
	else n = cs -> subprogram.entry_info + 4;

	call emit_c_a ((load_base (i)), c_a (n, 4));

	current_ms.base_regs (i).type = 9;
	current_ms.base_regs (i).variable = 0;
	current_ms.base_regs (i).used = text_pos;
	current_ms.base_regs (i).offset = 0;

	return (bases (i));

     end base_man_load_desc_ptr;

base_man_store_temp:
     procedure (temp_ptr, which);

	/* Emits code to store a pointer temporary.  Note that since
	   this routine is called from flush_base, we must be careful
	   to not use any pointer registers which might require flushing
	   (to avoid recursion). */

dcl  (temp_ptr, tp) pointer;
dcl  (which, temp_reg) fixed binary (3);

dcl  1 inst_address like node.address;
dcl  (large_base_reg, i, free_reg) fixed binary (3);
dcl  was_reserved bit (1) aligned;

	tp = temp_ptr;
	temp_reg = which;

	unspec (inst_address) = tp -> temporary.addr_hold;
	inst_address.ext_base = "1"b;

	/* If the temp is simply addressible, just store it */

	if ^tp -> temporary.large_address
	then do;
	     call emit_c_a ((store_base (temp_reg)), unspec (inst_address));
	     return;
	     end;

	/* See if there is a pointer register which already points to
	   the correct region for the large address. */

	free_reg, large_base_reg = 0;
	do i = first_base to last_base while (large_base_reg = 0);
	     if current_ms.base_regs (i).type = 0
	     then free_reg = i;
	     else if current_ms.base_regs (i).type = 8 & current_ms.base_regs (i).offset = tp -> temporary.location
	     then large_base_reg = i;
	     end;

	/* If there is no such pointer register, see if there is one
	   globally assigned. */

	if large_base_reg = 0
	then large_base_reg = find_global_base (8, 0, (tp -> temporary.location));

	/* If we have found a register to use, use it. */

	if large_base_reg > 0
	then do;
	     current_ms.base_regs (large_base_reg).used = text_pos;
	     inst_address.base = bases (large_base_reg);
	     call emit_c_a ((store_base (temp_reg)), unspec (inst_address));
	     return;
	     end;

	/* Try to get an empty register, or any register which does not
	   require flushing.  Avoid the register we are trying to store
	   by pretending it is reserved for the moment. */

	was_reserved = current_ms.base_regs (temp_reg).reserved;
	current_ms.base_regs (temp_reg).reserved = "1"b;
	i = get_free_reg (current_ms.base_regs, first_base, last_base, 0, free_reg);
	current_ms.base_regs (temp_reg).reserved = was_reserved;

	if current_ms.base_regs (i).type ^= 1 & current_ms.base_regs (i).type ^= 7
	then do;
	     inst_address.base = base_man_load_large_base_no_flush ((tp -> temporary.location), sp, i);
	     call emit_c_a ((store_base (temp_reg)), unspec (inst_address));
	     return;
	     end;

	/* Try to use pr4 as a last resort */

	i = which_base (4);

	if current_ms.base_regs (i).reserved
	then call print_message (467);		/* Sigh */

	inst_address.base = base_man_load_large_base_no_flush ((tp -> temporary.location), sp, i);
	call emit_c_a ((store_base (temp_reg)), unspec (inst_address));

	call emit_zero (getlp);			/* Restore pr4 */

     end base_man_store_temp;

find_global_base:
     procedure (p_code, p_var, p_off) returns (fixed binary (3));

	/* Searches for base register globally assigned to code,var,off.
	   If found, returns the register, otherwise, 0. */

dcl  (code, p_code) fixed binary (18),			/* Type of item */
     (var, p_var) fixed binary (18),			/* Operand offset */
     (off, p_off) fixed binary (18);			/* Offset to be added to ptr */

dcl  i fixed binary;

	if lp_msp ^= null
	then do;
	     code = p_code;
	     var = p_var;
	     off = p_off;

	     do i = first_base to last_base;
		if loop_state.base_regs (i).type = code
		then if loop_state.base_regs (i).variable = var
		     then if loop_state.base_regs (i).offset = off
			then if ^current_ms.base_regs (i).reserved
			     then return (i);
			     else call print_message (453);
		end;
	     end;

	return (0);

     end find_global_base;

lock_base:
     procedure (reg);

	/* Locks a base register for use in addressing */

dcl  reg fixed binary (3);

	if analyzing & ^current_ms.base_regs (reg).reserved & reg >= first_base & reg <= last_base
	then do;
	     ptr_data.locked = ptr_data.locked + 1;
	     ptr_data.max_locked = max (ptr_data.max_locked, ptr_data.locked);
	     end;

	/* Bug 508: If pr4 found to be empty, reset it to linkage ptr */

	if reg = which_base (4) & current_ms.base_regs (reg).type = 0
	then current_ms.base_regs (reg).type = 6;     /* linkage_ptr */

	current_ms.base_regs (reg).reserved = "1"b;

     end lock_base;

base_man_dispatch:
     procedure (p_code, p_var, p_off) returns (bit (3) aligned);

	/* Calls the proper base_man routine depending on args */

dcl  (code, p_code) fixed binary (18),
     (var, p_var) fixed binary (18),
     (off, p_off) fixed binary (18);

dcl  base bit (3) aligned;

	code = p_code;
	var = p_var;
	off = p_off;

	if code = 6 | code = 8
	then do;
	     if code = 6
	     then base = lp;
	     else base = sp;
	     base = base_man_load_large_base (off, base);
	     end;

	else if code = 5
	then base = base_man_load_arg_ptr ();

	else if code = 9
	then base = base_man_load_desc_ptr ();

	else base = base_man_load_any_pr (code, var, off);

	return (base);

     end base_man_dispatch;

avoid_prs:
     procedure (p_which);

	/* Marks the specified base registers reserved so they are not used for global items. */

dcl  (which, p_which) bit (6) aligned;			/* "1"b for each register to avoid */

dcl  i fixed binary (3);

	which = p_which;

	do i = first_base to last_base;
	     hold_pr_locks (i) = current_ms.base_regs (i).reserved;
	     if substr (which, i, 1)
	     then current_ms.base_regs (i).reserved = "1"b;
	     end;

     end avoid_prs;

restore_pr_locks:
     procedure ();

	/* Restores state of base register reservations after avoid_prs */

dcl  i fixed binary (3);

	do i = first_base to last_base;
	     current_ms.base_regs (i).reserved = hold_pr_locks (i);
	     end;

     end restore_pr_locks;

add_local_ptr:
     procedure ();

	/* Maintains statistics on local pointer use */

	ptr_data.local = ptr_data.local + 1;
	ptr_data.max_local = max (ptr_data.max_local, ptr_data.local);

     end add_local_ptr;

add_global_ptr:
     procedure (code, num, offset);

	/* Adds one to usage count of pointer node for this loop */

dcl  (code, num, offset) fixed binary (18);

dcl  p pointer;

	p = find_ptr ((code), (num), (offset));

	if p -> pointer.count = 0
	then do;
	     if ptr_data.n_global >= hbound (ptr_data.item, 1)
	     then do;
		call print_message (451, "pointer");
		return;
		end;

	     ptr_data.n_global = ptr_data.n_global + 1;
	     ptr_data.item (ptr_data.n_global) = p;
	     end;

	p -> pointer.count = p -> pointer.count + 1;

     end add_global_ptr;

find_ptr:
     procedure (p_code, p_num, p_offset) returns (pointer);

	/* Finds a pointer node in the hash_table.  If not found, inserts it.  */

dcl  (code, p_code) fixed binary (18),
     (num, p_num) fixed binary (18),
     (offset, p_offset) fixed binary (18);

dcl  node_ptr pointer;
dcl  node_offset fixed binary (18);

dcl  hash_index fixed binary;
dcl  mod_2_sum bit (36) aligned;
dcl  dim builtin;

	code = p_code;
	num = p_num;
	offset = p_offset;

	/* Form hash_index. */

	mod_2_sum = bool (bool (unspec (code), unspec (num), "0110"b), unspec (offset), "0110"b);
	hash_index = mod (binary (mod_2_sum, 35), dim (ptr_hash_table, 1));

	/* Search the hash table for the pointer node */

	do node_offset = ptr_hash_table (hash_index) repeat node_ptr -> pointer.hash_chain while (node_offset > 0);

	     node_ptr = addr (rands (node_offset));

	     if node_ptr -> pointer.variable = num
	     then if node_ptr -> pointer.code = code
		then if node_ptr -> pointer.offset = offset
		     then return (node_ptr);
	     end;

	/* Create on since we didn't find one. */

	node_offset = create_node (pointer_node, size (pointer));
	node_ptr = addr (rands (node_offset));


	node_ptr -> pointer.code = code;
	node_ptr -> pointer.variable = num;
	node_ptr -> pointer.offset = offset;

	/* Insert it in ptr_hash_table. */

	node_ptr -> pointer.hash_chain = ptr_hash_table (hash_index);
	ptr_hash_table (hash_index) = node_offset;

	return (node_ptr);

     end find_ptr;

/**** GET_FREE_REG ****/

get_free_reg:
     procedure (regs, first, last, global_reg, empty_reg) returns (fixed binary (3));

	/* Implements register searching algorithm */

dcl  1 regs (0:7) aligned like machine_state.base_regs,
     (first, last) fixed binary (18),			/* Limits of search */
     global_reg fixed binary (3),			/* Register preselected because it is globally assigned to the desired item */
     empty_reg fixed binary (3);			/* Register preselected because it is empty */

dcl  (i, j, count, lused, lowest_count) fixed binary (18);

	if global_reg > 0
	then return (global_reg);

	if empty_reg > 0
	then if ^regs (empty_reg).reserved & ^regs (empty_reg).global
	     then return (empty_reg);

	j = -1;
	lowest_count = max_fixed_bin_18;

	do i = first to last;
	     if ^regs (i).reserved & ^regs (i).global
	     then do;
		if regs (i).type = 0
		then return (i);

		if regs (i).type = 1
		then count = get_usage_count (addr (rands (regs (i).variable)));
		else count = 1;

		if count < lowest_count
		then do;
		     lowest_count = count;
		     lused = regs (i).used;
		     j = i;
		     end;

		else if count = lowest_count
		then if regs (i).used < lused
		     then do;
			lused = regs (i).used;
			j = i;
			end;

		end;

	     end;

	if j < 0
	then call print_message (418);
	else return (j);

     end get_free_reg;

get_usage_count:
     procedure (pt) returns (fixed binary (18));

	/* Gets effective usage count of an operand.  For temps that
	   are offsets of array_refs, the sum of the ref_counts of all
	   array_refs that a temp is used by is a better figure for
	   its usage count than its ref count.  */

dcl  (p, pt) pointer;

dcl  (inp, o, outp) pointer;
dcl  count fixed binary (18);

	p = pt;

	if p -> node.node_type = temporary_node
	then do;

	     /* operand is probably variable offset of array_refs.
	        To find real number of times needed in an xreg, get
	        sum of ref_counts of array_refs. */

	     if p -> temporary.start_input_to = 0 | ^p -> temporary.used_as_subscript
	     then return (get_ref_count (p));

	     count = 0;

	     do inp = addr (polish (p -> temporary.start_input_to)) repeat inp -> input_to.next while (inp ^= null);
		if inp -> input_to.which > 0
		then do;
		     o = inp -> input_to.operator;
		     if o -> operator.output > 0
		     then do;
			outp = addr (rands (o -> operator.output));
			count = count + get_ref_count (outp);
			end;
		     end;
		end;

	     return (count);
	     end;

	else if p -> node.node_type = array_ref_node
	then return (get_ref_count (p));

	else return (1);

     end get_usage_count;

/**** INDEX REGISTER MANAGEMENT ****/

	/* The contents of the index registers are determined by the
	   value of the type field as follows:
	   (v = variable field)

	   -1		UNKNOWN
	   0		EMPTY
	   1		value v
	   2		constant value c
	*/

xr_man_load_any_xr:
     procedure (pt) returns (bit (6) aligned);

dcl  pt pointer;					/* Points at value to be loaded */

dcl  p pointer;
dcl  v fixed binary (18);
dcl  i fixed binary (3);
dcl  have_eligible bit (1) aligned;

	p = pt;
	v = fixed (rel (p), 18);

	if analyzing
	then do;
	     have_eligible = eligible (p);
	     if have_eligible
	     then call add_global_index (p);
	     end;

	if p -> node.value_in.x
	then do;
	     do i = first_index to last_index;
		if current_ms.index_regs (i).type = 1
		then if current_ms.index_regs (i).variable = v
		     then do;
			current_ms.index_regs (i).used = text_pos;
			return ("001"b || bit (i, 3));
			end;
		end;
	     call print_message (430, v);
	     return ("00"b3);
	     end;

	i = get_free_reg (current_ms.index_regs, first_index, last_index, find_global_index (v), 0);

	call flush_xr (i);

	call use_ind;

	if p -> node.value_in.eaq
	then call emit_c_a (eax0 + i, c_a (0, 1));

	else do;
	     if p -> node.not_in_storage & ^analyzing
	     then do;
		call print_message (419, v);
		stop;
		end;

	     if ^p -> node.is_addressable
	     then call m_a_except_xreg (p);

	     call emit_c_a_var (lxl0 + i, p);
	     end;

	current_ms.indicators_valid = i + highest_ind_state + 1;

	call xr_man_update_xr (v, i);

	if analyzing
	then if ^have_eligible
	     then call add_local_index;

	return ("001"b || bit (i, 3));

     end xr_man_load_any_xr;

flush_xr:
     procedure (which);

	/* Empties an index register prior to reuse */

dcl  which fixed binary (3);				/* Index reg to flush */
dcl  i fixed binary (18);
dcl  p pointer;

	if current_ms.index_regs (which).type ^= 1
	then do;
	     if analyzing & current_ms.index_regs (which).type ^= 0
	     then index_data.local = index_data.local - 1;
	     return;
	     end;

	i = which;

	p = addr (rands (current_ms.index_regs (i).variable));
	p -> node.value_in.x = "0"b;

	/* the value has not been previously stored, so do so */

	if p -> temporary.not_in_storage
	then call emit_temp_store (sxl0 + i, (current_ms.index_regs (i).variable));

	if analyzing
	then if ^eligible (p)
	     then index_data.local = index_data.local - 1;

     end flush_xr;

xr_man_load_const:
     procedure (csize) returns (bit (6) aligned);

	/* Loads a constant into any index register */

dcl  csize fixed binary (18);				/* Size to be loaded */

dcl  (i, k) fixed binary (3);
dcl  c fixed binary (18);

	c = csize;

	if const_in_xr (c, first_index, k)
	then do;
	     current_ms.index_regs (k).used = text_pos;
	     return ("001"b || bit (binary (k, 3), 3));
	     end;

	i = get_free_reg (current_ms.index_regs, first_index, last_index, 0, k);

	call flush_xr (i);

	call use_ind;

	call emit_c_a (eax0 + i, c_a_18 (c, 0));

	current_ms.indicators_valid = i + highest_ind_state + 1;

	current_ms.index_regs (i).type = 2;
	current_ms.index_regs (i).variable = c;
	current_ms.index_regs (i).used = text_pos;

	if analyzing
	then call add_local_index;

	return ("001"b || bit (i, 3));

     end xr_man_load_const;

xr_man_update_xr:
     procedure (ref, ip);

	/* Updates index register machine state */

dcl  ref fixed binary (18);
dcl  (ip, i) fixed binary (3);
dcl  rp pointer;

	rp = addr (rands (ref));
	i = ip;

	if ^rp -> node.dont_update
	then do;
	     current_ms.value_in_xr = "1"b;
	     current_ms.index_regs (i).type = 1;
	     current_ms.index_regs (i).variable = ref;
	     rp -> node.value_in.x = "1"b;
	     end;
	else current_ms.index_regs (i).type = 0;

	current_ms.index_regs (i).used = text_pos;

     end xr_man_update_xr;

const_in_xr:
     procedure (value, first_xr, reg) returns (bit (1) aligned);

	/* Searches x-regs for particular const value or first empty x-reg */

dcl  value fixed binary (18);				/* offset of const node */
dcl  first_xr fixed binary (18);			/* first xr to search */
dcl  reg fixed binary (3);				/* xr that contains const or is empty */
dcl  (i, c) fixed binary (18);

	c = value;
	reg = 0;

	do i = first_xr to last_index;
	     if current_ms.index_regs (i).type = 0
	     then reg = i;
	     else if current_ms.index_regs (i).type = 2
	     then if current_ms.index_regs (i).variable = c
		then do;
		     reg = i;
		     return ("1"b);			/* const in xr */
		     end;
	     end;

	return ("0"b);				/* const not in xr */

     end const_in_xr;

xr_man_add_const:
     procedure (which, csize) returns (bit (6) aligned);

	/* Adds a constant to the value in an index register */

dcl  which fixed binary (3);
dcl  csize fixed binary (18);

dcl  (i, c) fixed binary (18);
dcl  j fixed binary (3);
dcl  address bit (36) aligned;


	i = which;
	c = csize;
	address = (36)"0"b;
	substr (address, 1, 18) = bit (c, 18);		/* Set offset portion */
	substr (address, 31, 6) = bit (fixed (i + 8, 6), 6);
						/* Set tag portion */

	j = get_free_reg (current_ms.index_regs, first_index, last_index, 0, 0);

	call flush_xr (j);
	call use_ind ();
	call emit_c_a (eax0 + j, address);		/* Emit eaxm_ const,n */

	/* Although the index register we just loaded is not really empty,
	   we will say it is because xr_man does not have the notion
	   of a variable plus a constant in a register.  This will only work
	   if the next instruction emitted uses the index register and
	   does not call for some other index register to be loaded. */

	current_ms.indicators_valid = j + highest_ind_state + 1;

	current_ms.index_regs (j).type = 0;		/* Empty */
	current_ms.index_regs (j).variable = 0;
	current_ms.index_regs (j).used = text_pos;

	if analyzing
	then index_data.max_local = max (index_data.max_local, index_data.local + 1);

	return (bit (fixed (j + 8, 6), 6));		/* Return XR modifier */

     end xr_man_add_const;

find_global_index:
     procedure (var) returns (fixed binary (3));

	/* Searches for a register globally assigned to var.  Returns 0 if not found. */

dcl  (v, var) fixed binary (18);

dcl  i fixed binary;

	v = var;

	if addr (rands (v)) -> node.globally_assigned
	then do i = first_index to last_index;
		if loop_state.index_regs (i).type = 1
		then if loop_state.index_regs (i).variable = v
		     then if ^current_ms.index_regs (i).reserved
			then return (i);
			else call print_message (453);
		end;

	return (0);

     end find_global_index;

xr_man_load_xr:
     procedure (p_load_p, p_xr, p_update_opnd);

	/* Loads operand into specified index register and updates
	   machine state with another operand. */

dcl  (load_p, p_load_p) pointer,			/* -> opnd to be loaded */
     (xr, p_xr) fixed binary (3),			/* Xreg to load into */
     (update_opnd, p_update_opnd) fixed binary (18);	/* Opnd to be added to state */

dcl  i fixed binary (3);
dcl  load_opnd fixed binary (18);

	load_p = p_load_p;
	load_opnd = fixed (rel (load_p), 18);
	xr = p_xr;
	update_opnd = p_update_opnd;

	call flush_xr (xr);

	call use_ind;

	if load_p -> node.value_in.x
	then do;
	     i = fixed (substr (xr_man_load_any_xr (load_p), 4, 3), 3);

	     call emit_c_a (eax0 + xr, c_a_tag (i));
	     current_ms.indicators_valid = xr + highest_ind_state + 1;
	     end;

	else do;
	     if load_p -> node.not_in_storage & ^analyzing
	     then do;
		call print_message (419, load_opnd);
		stop;
		end;

	     call emit_single (lxl0 + xr, load_opnd);
	     end;

	call xr_man_update_xr (update_opnd, xr);

     end xr_man_load_xr;

lock_index:
     procedure (reg);

	/* Locks an index register for use in addressing */

dcl  reg fixed binary (3);

	if analyzing & ^current_ms.index_regs (reg).reserved
	then do;
	     index_data.locked = index_data.locked + 1;
	     index_data.max_locked = max (index_data.max_locked, index_data.locked);
	     end;

	current_ms.index_regs (reg).reserved = "1"b;

     end lock_index;

eligible:
     procedure (p) returns (bit (1) aligned);

	/* Determines if an operand may be globally assigned to an
	   index register. */

dcl  p pointer;					/* -> operand node */

dcl  o pointer;

	if p -> node.node_type = symbol_node
	then if p -> symbol.coordinate > 0
	     then return (substr (cur_lp -> loop.may_keep_in_xr -> bits, p -> symbol.coordinate, 1));
	     else ;

	else if p -> node.node_type = temporary_node
	then do;
	     o = addr (quad (p -> temporary.output_by));
	     if o -> operator.coordinate > 0
	     then return (^substr (cur_lp -> loop.computed -> obits, o -> operator.coordinate, 1));
	     end;

	return ("0"b);

     end eligible;

add_global_index:
     procedure (p);

	/* Adds one to loop_ref_count to opnd for this loop */

dcl  p pointer;					/* -> symbol or temporary */

	if p -> node.loop_ref_count = 0
	then do;
	     if index_data.n_global >= hbound (index_data.item, 1)
	     then do;
		call print_message (451, "index");
		return;
		end;

	     index_data.n_global = index_data.n_global + 1;
	     index_data.item (index_data.n_global) = p;
	     end;

	p -> node.loop_ref_count = p -> node.loop_ref_count + 1;

     end add_global_index;

add_local_index:
     procedure ();

	/* Updates local index statistics */

	index_data.local = index_data.local + 1;
	index_data.max_local = max (index_data.max_local, index_data.local);

     end add_local_index;

/**** NON-ADDRESSING INDEX REGISTER OPERATIONS ****/

assign_index:
     procedure (p_dest, p_source);

	/* Effects an assignment via an index register. */

dcl  (dest, p_dest) fixed binary (18),			/* destination */
     (source, p_source) fixed binary (18);

dcl  xr fixed binary (3);

dcl  (source_p, dest_p) pointer;
dcl  p pointer;

	dest = p_dest;
	dest_p = addr (rands (dest));
	source = p_source;
	source_p = addr (rands (source));

	if string (dest_p -> symbol.value_in)
	then call flush_ref (dest);

	if dest_p -> symbol.globally_assigned
	then do;

	     /* destination will be in an index register */

	     xr = find_global_index (dest);

	     call xr_man_load_xr (source_p, xr, dest);

	     /* If the xr is erased in this loop, or if the variable is
	        busy_on_exit from this loop, we must save a copy in storage. */

	     if cur_lp -> loop.erases.xr (xr)
		| substr (cur_lp -> loop.busy_on_exit -> bits, dest_p -> symbol.coordinate, 1)
	     then call emit_temp_store (sxl0 + xr, dest);
	     end;

	else do;

	     /* destination is not kept in an index register */

	     xr = fixed (substr (xr_man_load_any_xr (source_p), 4, 3), 3);

	     p = find_range (dest_p, cur_lp);

	     if p = null
	     then call emit_temp_store (sxl0 + xr, dest);

	     else if p -> range.fb18_uns
	     then do;
		call emit_temp_store (stz, dest);
		call emit_temp_store (sxl0 + xr, dest);
		end;

	     else do;
		call use_eaq (0, Q, 0);

		call emit_c_a (eaq, c_a_tag (xr));
		call emit_c_a (qrs, c_a_18 (18, 0));

		current_ms.indicators_valid = Q;

		call store (dest, in_q, 0);
		end;
	     end;

     end assign_index;

compare_index:
     procedure (p_induction_var, p_invariant);

	/* Compares an induction variable in an index register against
	   a loop invariant in storage */

dcl  (induction_var, p_induction_var) fixed binary (18),
     (invariant, p_invariant) fixed binary (18);

dcl  (indp, invp) pointer;

dcl  have_zero bit (1) aligned;
dcl  regno fixed binary (3);

	induction_var = p_induction_var;
	indp = addr (rands (induction_var));
	invariant = p_invariant;
	invp = addr (rands (invariant));

	/* Process the invariant.  If it is a constant, make a new one
	   by shifting left 18 bits.  Also, find out if it is zero.
	   Variable comparands have already been left shifted. */

	have_zero = "0"b;
	if invp -> node.node_type = constant_node
	then if addr (invp -> constant.value) -> int_image = 0
	     then have_zero = "1"b;
	     else invariant = create_constant (int_mode, substr (invp -> constant.value, 19));

	/* Find the register for the induction variable, and do the
	   comparison, if necessary. */

	regno = fixed (substr (xr_man_load_any_xr (indp), 4, 3), 3);

	if ^have_zero | current_ms.indicators_valid ^= regno + highest_ind_state + 1
	then do;
	     call emit_single (cmpx0 + regno, invariant);

	     if have_zero
	     then current_ms.indicators_valid = regno + highest_ind_state + 1;
	     else current_ms.indicators_valid = 0;
	     end;

     end compare_index;

increment_index:
     procedure (p_induction_var, p_value, sign);

	/* Increments an induction variable in an index register by a value */

dcl  (induction_var, p_induction_var) fixed binary (18),
     (value, p_value) fixed binary (18),
     sign fixed binary;

dcl  regno fixed binary (3);

dcl  mac fixed binary (18);

dcl  indp pointer;

	/* copy arguments and if the value is a constant, shift it by 18 bits */

	induction_var = p_induction_var;
	indp = addr (rands (induction_var));

	if addr (rands (p_value)) -> node.node_type = constant_node
	then value = create_constant (int_mode, substr (addr (rands (p_value)) -> constant.value, 19));
	else value = p_value;

	/* find the induction variable */

	regno = fixed (substr (xr_man_load_any_xr (indp), 4, 3), 3);

	/* increment it */

	if sign < 0
	then mac = sblx0 + regno;
	else mac = adlx0 + regno;

	call emit_single (mac, value);

	/* save the result, if necessary */

	if cur_lp -> loop.erases.xr (regno) | substr (cur_lp -> loop.busy_on_exit -> bits, indp -> symbol.coordinate, 1)
	then call emit_temp_store (sxl0 + regno, induction_var);

     end increment_index;

/**** GENERAL REGISTER MANAGEMENT ****/

reserve_regs:
     procedure (what);

	/* Reserves index and base registers */

dcl  (what, reserve) bit (14) aligned;			/* Mask specifying which regs to reserve */
dcl  i fixed binary (18);
dcl  j fixed binary (3);
dcl  length builtin;

	reserve = what;

	if analyzing
	then string (cur_lp -> loop.erases) = string (cur_lp -> loop.erases) | reserve;

	do i = 1 to length (reserve);
	     if substr (reserve, i, 1)
	     then if i <= 8
		then do;
		     j = i - 1;
		     call flush_xr (j);
		     current_ms.index_regs (j).reserved = "1"b;
		     current_ms.index_regs (j).type = -1;
						/* Unknown value */
		     end;
		else do;
		     j = i - 8;
		     call flush_base (j);
		     current_ms.base_regs (j).reserved = "1"b;
		     current_ms.base_regs (j).type = -1;/* Unknown value */
		     current_ms.base_regs (j).variable = 0;
						/* debugging */
		     current_ms.base_regs (j).offset = 0;
		     end;
	     end;

     end reserve_regs;

free_regs:
     procedure ();

dcl  i fixed binary (18);

	/* Frees all reserved registers (index, base, and eaq)
	   reloading pr4 if necessary */

	last_pr_locked_for_pl1_ops_arg, index_data.locked, ptr_data.locked = 0;

	current_ms.eaq (*).reserved = "0"b;

	do i = escape_index to last_index;
	     if current_ms.index_regs (i).reserved
	     then do;
		current_ms.index_regs (i).reserved = "0"b;
		if current_ms.index_regs (i).type < 0	/* Unknown? */
		then current_ms.index_regs (i).type = 0;
		end;
	     end;

	do i = first_base to last_base;		/* Normal bases */
	     if current_ms.base_regs (i).reserved
	     then do;
		current_ms.base_regs (i).reserved = "0"b;
		if current_ms.base_regs (i).type < 0	/* Unknown? */
		then current_ms.base_regs (i).type = 0;
		end;
	     end;

          /* Bug 508: Reload pr4 with linkage ptr value only if necessary */

	i = which_base (4);
	if current_ms.base_regs (i).reserved & current_ms.base_regs (i).type ^= 6
	then do;
	     call emit_zero (getlp);                         /* Emit code to restore pr4 */
	     current_ms.base_regs (i).type = 6; /* Linkage_ptr */
     	     end;

	current_ms.base_regs (i).reserved = "0"b;

     end free_regs;

flush_ref:
     procedure (index);

	/* Flush complex reference.  This is an aliased reference.  Here we find the
	   parent header node and scan through the equivalenced list to find another
	   node which has "value_in.eaq" set.  Cause that node to be flushed too. */

dcl  (index, i) fixed binary (18);
dcl  p ptr;


	call flush_simple_ref (index);		/* Flush primary */
	p = addr (rands (index));
	if p -> node.node_type = symbol_node
	then if (p -> symbol.in_equiv_stmnt) & (p -> symbol.parent ^= 0)
	     then do;
		p = addr (rands (p -> symbol.parent));	/* point to list */
		do i = p -> header.first_element repeat p -> symbol.next_member while (i ^= 0);
		     p = addr (rands (i));
		     if p -> symbol.value_in.eaq
		     then call flush_simple_ref (i);
		     end;
		end;



flush_simple_ref:
     procedure (temp_index);

	/* Removes an item from the machine state */

dcl  (temp, temp_index) fixed binary (18);
dcl  p pointer;
dcl  (i, r) fixed binary (18);

	temp = temp_index;

	p = addr (rands (temp));

	if p -> node.value_in.eaq
	then do;
	     do r = 1 to hbound (current_ms.eaq, 1);	/* A, Q, EAQ, IND */
		do i = 1 by 1 while (i <= current_ms.eaq (r).number);
		     if current_ms.eaq (r).variable (i) = temp
		     then do;
			do i = i + 1 by 1 while (i <= current_ms.eaq (r).number);
			     current_ms.eaq (r).variable (i - 1) = current_ms.eaq (r).variable (i);
			     end;

			current_ms.eaq (r).number = current_ms.eaq (r).number - 1;

			/* eaq.name is not set to zero here because the jump_true and
			   jump_false macro procedures use an if_eaq macro, which drops
			   the reference count if the value is in the eaq, followed by an
			   ind_jump macro which requires that eaq.name be one of the
			   indicators substates.  Since if_eaq could drop the reference
			   count to 0, flush_ref could be called and the temporary could
			   be removed from the machine state.  However, eaq.name must be
			   preserved for subsequent use by ind_jump. */

			end;
		     end;
		end;
	     end;

	if p -> node.value_in.x
	then do i = first_index repeat i + 1 while (i <= last_index);
		if current_ms.index_regs (i).type = 1
		then if current_ms.index_regs (i).variable = temp
		     then do;
			current_ms.index_regs (i).type = 0;
			if analyzing
			then if ^eligible (p)
			     then index_data.local = index_data.local - 1;
			end;
		end;

	string (p -> node.value_in) = "0"b;

     end flush_simple_ref;
     end flush_ref;

flush_addr:
     procedure (temp_index);

	/* Removes the address of an item from the machine state */

dcl  (temp, temp_index) fixed binary (18);
dcl  p pointer;
dcl  i fixed binary (18);

	temp = temp_index;
	p = addr (rands (temp));

	if p -> node.address_in_base
	then do;
	     do i = first_base repeat i + 1 while (i <= last_base);
		if current_ms.base_regs (i).type = 1
		then if current_ms.base_regs (i).variable = temp
		     then do;
			current_ms.base_regs (i).type = 0;
			if analyzing
			then do;
			     ptr_data.local = ptr_data.local - 1;
			     if p -> node.data_type = char_mode & p -> node.units ^= char_units
			     then do;

				/* Restore address of aligned character string */

				substr (unspec (p -> node.address), 1, 18) = p -> node.addr_hold;
				p -> node.reloc = p -> node.reloc_hold;
				end;
			     end;
			end;
		end;
	     p -> node.address_in_base = "0"b;
	     end;

     end flush_addr;

lock_tag_register:
     procedure (tag);

	/* Reserves the register specified by the address tag */

dcl  (tag, t) bit (6) aligned;

	t = tag;

	if substr (t, 3, 1)				/* XR modification */
	then call lock_index (fixed (t, 6) - 8);
	else if t = QL_mod
	then call lock_eaq (Q);
	else if t = AL_mod
	then call lock_eaq (A);

     end lock_tag_register;

/**** EAQ MANAGEMENT ****/

eaq_man_load_a_or_q:
     procedure (pt) returns (bit (6) aligned);

	/* Loads an integer value into the A or Q. */

dcl  (pt, p) pointer;
dcl  v fixed binary (18);
dcl  name fixed binary (18);

	p = pt;
	v = fixed (rel (p), 18);

	/* If the operand is already in the A or Q, no need to load it */

	if p -> node.value_in.eaq
	then do;
	     name = get_eaq_name (v);
	     if name = in_q
	     then return (QL_mod);
	     else if name = in_ia
	     then return (AL_mod);
	     end;

	/* Must load the operand.  If one of the A or Q is reserved, we must
	   load the other one.  If neither is reserved, we favor the Q. */

	if current_ms.eaq (A).reserved & current_ms.eaq (Q).reserved
	then call print_message (449);		/* Oops */

	if current_ms.eaq (A).reserved
	then name = in_q;
	else if current_ms.eaq (Q).reserved
	then name = in_ia;
	else if current_ms.eaq (Q).number > 0 & current_ms.eaq (A).number = 0 & current_ms.eaq (IND).number = 0
	then name = in_ia;
	else name = in_q;

	call use_eaq (v, name, 0);

	if ^p -> node.is_addressable
	then call m_a_except_xreg (p);

	call emit_c_a_var (load_inst (name), p);

	current_ms.indicators_valid = eaq_name_to_reg (name);

	call in_reg (v, name);

	if name = in_q
	then return (QL_mod);
	else return (AL_mod);

     end eaq_man_load_a_or_q;

get_eaq_name:
     procedure (opnd) returns (fixed binary (18));

	/* Search the eaq state for opnd and return its eaq name */

dcl  (op, opnd) fixed binary (18);
dcl  (r, v) fixed binary (18);

	op = opnd;

	if ^addr (rands (op)) -> node.value_in.eaq
	then return (0);				/* Don't even look */

	do r = 1 to hbound (current_ms.eaq, 1);

	     do v = 1 to current_ms.eaq (r).number;

		if current_ms.eaq (r).variable (v) = op
		then return (current_ms.eaq (r).name);

		end;

	     end;

	/* If we get here, the node has value_in.eaq on but the operand
	   is not in the eaq. */

	call print_message (450);
	return (0);

     end get_eaq_name;

in_reg:
     procedure (v, name);

	/* Puts an operand in an eaq register */

dcl  (var, v) fixed binary (18),
     name fixed binary (18),
     (i, n, regno) fixed binary (18);

	var = v;

	if addr (rands (var)) -> node.dont_update
	then return;

	regno = eaq_name_to_reg (name);

	if current_ms.eaq (regno).name > 0 & current_ms.eaq (regno).name ^= name
	then call use_eaq (0, (regno), 0);

	current_ms.eaq (regno).name = name;

	if name = in_ind
	then do;
	     call print_message (420, var);
	     return;
	     end;

	addr (rands (var)) -> node.value_in.eaq = "1"b;

	if current_ms.eaq (regno).number < hbound (current_ms.eaq.variable, 2)
	then do;
	     n, current_ms.eaq (regno).number = current_ms.eaq (regno).number + 1;
	     current_ms.eaq (regno).variable (n) = var;
	     return;
	     end;

	do i = 1 to hbound (current_ms.eaq.variable, 2);	/* Guaranteed to be an opening */

	     if addr (rands (current_ms.eaq (regno).variable (i))) -> node.node_type ^= temporary_node
	     then do;
		addr (rands (current_ms.eaq (regno).variable (i))) -> node.value_in.eaq = "0"b;
		current_ms.eaq (regno).variable (i) = var;
		return;
		end;
	     end;

	call print_message (448);

     end in_reg;

use_eaq:
     procedure (array_sym, reg_number, protect_ind);

	/* Stores values of all temps currently in eaq and required later on.
	   The eaq is then emptied. */

dcl  array_sym fixed binary (18);
dcl  reg_number fixed binary (18);
dcl  protect_ind fixed binary (18);

	call save_eaq_temps ((array_sym), (reg_number), (protect_ind));
	call reset_eaq ((reg_number));

     end use_eaq;

save_eaq_temps:
     procedure (array_sym, reg_no, protect_ind);

	/* Stores temp values for all temps currently in eaq and required later on.
	   Subscript values can be stored in an index reg or not stored at all.
	   All others are stored in storage. The machine state is not directly affected. */

dcl  array_sym fixed binary (18);			/* zero or sym offset of sym changing eaq state. */
dcl  reg_no fixed binary (18);			/* eaq register */
dcl  protect_ind fixed binary (18);			/* if ^= 0 then protect ind state while storing temps */

dcl  asp pointer;					/* null or -> node changing eaq state. */

	if array_sym > 0
	then asp = addr (rands (array_sym));
	else asp = null;

	if current_ms.eaq (IND).number > 0 & protect_ind = 0
	then call use_ind ();

	if reg_no ^= IND
	then call save (EAQ);			/* Only IND does not affect EAQ */

	if reg_no = EAQ
	then do;					/* EAQ affects both A and Q */
	     call save (A);
	     call save (Q);
	     end;
	else call save ((reg_no));

	return;

save:
     procedure (reg);

	/* Internal procedure of save_eaq_temps.  Saves temps in
	   one of the eaq registers. */

dcl  (reg, r) fixed binary (18);
dcl  bit6 bit (6) aligned;
dcl  i fixed binary (18);
dcl  own_sub pointer;
dcl  p pointer;
dcl  saved_state fixed binary (18);
dcl  st_inst fixed binary (18);

	/* If symbol causing eaq state change is an array ref node, the value in the
	   eaq is the value of the subscript, and this is the last reference for
	   this value, then we don't have to store the value anywhere. */

	r = reg;

	if current_ms.eaq (r).number = 0
	then return;

	own_sub = null ();
	saved_state = 0;

	if r = Q					/* Subscripts can only be in the Q */
	then if array_sym > 0
	     then if asp -> node.node_type = array_ref_node
		then if asp -> array_ref.variable_offset
		     then if get_ref_count (asp) = 1
			then if addr (rands (asp -> array_ref.v_offset)) -> node.value_in.eaq
			     then own_sub = addr (rands (asp -> array_ref.v_offset));

	if ^do_rounding | current_ms.rounded
	then st_inst = store_no_round_inst (current_ms.eaq (r).name);
	else st_inst = store_inst (current_ms.eaq (r).name);

	do i = 1 by 1 while (i <= current_ms.eaq (r).number);

	     p = addr (rands (current_ms.eaq (r).variable (i)));

	     if p -> node.not_in_storage & ^p -> node.value_in.x
	     then do;
		if p -> temporary.used_as_subscript
		then if p = own_sub & get_ref_count (p) = 1
		     then ;
		     else do;
			if protect_ind ^= 0 & saved_state = 0
			then call save_ind_state (saved_state);
			bit6 = xr_man_load_any_xr (p);
			end;

		else call emit_temp_store (st_inst, (current_ms.eaq (r).variable (i)));
		end;

	     end;

	if saved_state ^= 0
	then call restore_ind_state (saved_state);

     end save;

     end save_eaq_temps;

use_ind:
     procedure ();

	/* If the indicators contain a logical value, it is saved
	   in the a. Then the indicators are set invalid. */

	call move_logical_to_a ();
	current_ms.indicators_valid = 0;

     end use_ind;

move_logical_to_a:
     procedure ();

	/* Moves logical value from indicators to A-reg if the value needs to be stored */

dcl  p pointer;
dcl  var fixed binary (18);

	if current_ms.eaq (IND).name > in_ind
	then if current_ms.eaq (IND).number > 0
	     then do;
		p = addr (rands (current_ms.eaq (IND).variable (1)));
		if p -> node.node_type = temporary_node
		then do;
		     call save_logical_temps ();
		     call emit_zero ((ind_to_a (current_ms.eaq (IND).name - in_ind)));

		     /* Update machine state */

		     var = current_ms.eaq (IND).variable (1);
		     call reset_eaq (IND);
		     current_ms.eaq (A).number = 1;
		     current_ms.eaq (A).name = in_a;
		     current_ms.eaq (A).variable (1) = var;
		     p -> node.value_in.eaq = "1"b;
		     current_ms.indicators_valid = A;

		     end;

		end;

save_logical_temps:
     procedure ();

	/* This procedure is analogous to save_eaq_temps, but is used
	   to save temps in the A register only.  It is called by
	   move_logical_to_a to avoid recursion. */

dcl  i fixed binary (18);
dcl  p ptr;
dcl  saved_state fixed bin (18);
dcl  bit6 bit (6) aligned;
dcl  st_inst fixed bin (18);

	do i = 1 by 1 while (i <= current_ms.eaq (A).number);
	     if addr (rands (current_ms.eaq (A).variable (i))) -> node.not_in_storage
	     then call emit_temp_store (sta, (current_ms.eaq (A).variable (i)));
	     end;

	if current_ms.eaq (EAQ).number > 0
	then do;
	     saved_state = 0;
	     if ^do_rounding | current_ms.rounded
	     then st_inst = store_no_round_inst (current_ms.eaq (EAQ).name);
	     else st_inst = store_inst (current_ms.eaq (EAQ).name);

	     do i = 1 to current_ms.eaq (EAQ).number;
		p = addr (rands (current_ms.eaq (EAQ).variable (i)));

		if p -> node.not_in_storage & ^p -> node.value_in.x
		then do;
		     if p -> temporary.used_as_subscript
		     then do;
			call save_ind_state (saved_state);
			bit6 = xr_man_load_any_xr (p);
			end;

		     else call emit_temp_store (st_inst, (current_ms.eaq (EAQ).variable (i)));
		     end;

		end;

	     if saved_state ^= 0
	     then call restore_ind_state (saved_state);
	     end;

	call reset_eaq (A);

     end save_logical_temps;
     end move_logical_to_a;

flush_eaq:
     procedure ();

	/* Flushes eaq without moving temps to x-regs */

dcl  r fixed binary (18);
dcl  i fixed binary (18);
dcl  p pointer;
dcl  st_inst fixed binary (18);

	if current_ms.eaq (IND).number > 0
	then call use_ind ();

	do r = 1 to 3;				/* A, Q, EAQ */

	     if current_ms.eaq (r).number > 0
	     then do;

		if ^do_rounding | current_ms.rounded
		then st_inst = store_no_round_inst (current_ms.eaq (r).name);
		else st_inst = store_inst (current_ms.eaq (r).name);

		do i = 1 to current_ms.eaq (r).number;

		     p = addr (rands (current_ms.eaq (r).variable (i)));

		     if p -> node.node_type = temporary_node
		     then if p -> temporary.not_in_storage
			then if get_ref_count (p) > 0
			     then call emit_temp_store (st_inst, (current_ms.eaq (r).variable (i)));

		     p -> node.value_in.eaq = "0"b;	/* no longer in eaq */
		     end;

		current_ms.eaq (r).name = 0;
		current_ms.eaq (r).number = 0;

		end;

	     end;

	current_ms.rounded = "0"b;

     end flush_eaq;

load:
     procedure (vp, name);

	/* Loads an operand into an eaq register */

dcl  vp fixed binary (18),				/* operand to be loaded */
     name fixed binary (18);				/* eaq_name to be loaded */
dcl  (var, eaq_name, regno, i) fixed binary (18);

	eaq_name = name;

	if eaq_name <= 0 | eaq_name > in_ind
	then do;
	     call print_message (421, vp);
	     return;
	     end;

	var = vp;

	/* If this load would destroy the A, and if there are
	   logical values in the indicators, we must get the
	   indicators into the A now, before the load takes place.
	   Otherwise, a subsequent call to use_ind could
	   destroy the load.  This is a kludge. */

	if eaq_name_to_reg (eaq_name) ^= Q & current_ms.eaq (IND).number > 0
	then call move_logical_to_a ();

	if addr (rands (var)) -> node.value_in.eaq
	then do;

	     /* Search the machine state; the operand may already be
	        in the desired register */

	     do regno = 1 to hbound (current_ms.eaq, 1);	/* A, Q, EAQ, IND */

		do i = 1 by 1 while (i <= current_ms.eaq (regno).number);

		     if var = current_ms.eaq (regno).variable (i)
		     then do;

			if eaq_name = in_tq | eaq_name = in_q
			then if current_ms.eaq (regno).name = in_tq | current_ms.eaq (regno).name = in_q
			     then current_ms.eaq (regno).name = eaq_name;

			if eaq_name = current_ms.eaq (regno).name
			then do;
			     call drop_count (var, 1);
			     return;
			     end;

			if eaq_name = in_ind
			then do;
			     if regno = IND
			     then do;
				call drop_count (var, 1);
				return;
				end;

			     if current_ms.eaq (regno).name = in_a
			     then if current_ms.indicators_valid = A
				then do;
				     call flush_ref (var);
				     if current_ms.eaq (A).number = 0
				     then current_ms.eaq (A).name = 0;
				     call in_reg (var, tnz);
						/* Put it in INDs */
				     call drop_count (var, 1);
				     return;
				     end;

			     end;

			else if eaq_name = in_a & regno = IND
			     & addr (rands (var)) -> node.node_type = temporary_node
			then do;
			     call move_logical_to_a ();
			     call drop_count (var, 1);
			     return;
			     end;

			end;

		     end;

		end;

	     end;

	call emit_single ((load_inst (eaq_name)), var);

	if eaq_name = in_ind
	then eaq_name = tnz;

	call in_reg (var, eaq_name);

	current_ms.rounded = "1"b;

     end load;

check_zero:
     procedure (opnd) returns (bit (1) aligned);

	/* Returns true if operand is "zero value" for its data type */

dcl  opnd fixed binary (18);

	if opnd < 0				/* a count */
	then return (opnd = -bias);

	if addr (rands (opnd)) -> node.node_type = constant_node
	then return (opnd = zero_for_dt (addr (rands (opnd)) -> constant.data_type));
	else return ("0"b);

     end check_zero;

check_negative:
     procedure (opnd) returns (bit (1) aligned);

	/* return true if operand is "negative" for its data type */

dcl  opnd fixed bin (18);
dcl  (p, val_ptr) ptr;
dcl  based_integer fixed bin (35) aligned based;
dcl  based_real float bin (27) aligned based;
dcl  1 based_double aligned based,
       2 based_dp float bin (63) unaligned;

	if opnd < 0				/* a count */
	then return (opnd < -bias);

	p = addr (rands (opnd));
	if p -> node.data_type < 1 | p -> node.data_type > 4
	then return ("0"b);				/* cannot be neg if not numeric */
	val_ptr = addr (p -> constant.value);
	goto return_neg (p -> node.data_type);

return_neg (1):					/* INTEGER */
	return (val_ptr -> based_integer < 0);

return_neg (2):					/* REAL */
return_neg (4):					/* COMPLEX */
	return (val_ptr -> based_real < 0.0);

return_neg (3):					/* DOUBLE PRECISION */
	return (val_ptr -> based_dp < 0.0);

     end check_negative;

reset_eaq:
     procedure (reg_number);

	/* Resets the specified eaq register to the empty state */

dcl  reg_number fixed binary (18);

	if reg_number ^= IND
	then call reset (EAQ);			/* Only IND does not affect EAQ */

	if reg_number = EAQ
	then do;					/* EAQ affects both A and Q */
	     call reset (A);
	     call reset (Q);
	     end;
	else call reset (reg_number);

	current_ms.rounded = "0"b;

	return;

reset:
     procedure (r);

	/* Resets a single eaq register */

dcl  (i, r, regno) fixed binary (18);

	regno = r;

	do i = 1 by 1 while (i <= current_ms.eaq (regno).number);
	     addr (rands (current_ms.eaq (regno).variable (i))) -> node.value_in.eaq = "0"b;
	     end;

	current_ms.eaq (regno).number = 0;
	current_ms.eaq (regno).name = 0;

     end reset;

     end reset_eaq;

store:
     procedure (vp, name, update_flag);

dcl  vp fixed binary (18);				/* Operand to be stored */
dcl  name fixed binary (18);				/* Eaq_name from which storing takes place */
dcl  update_flag fixed binary (18);			/* =0 if store should update ms */

dcl  (var, eaq_name, inst_number) fixed binary (18);
dcl  v pointer;

	eaq_name = name;
	var = vp;
	v = addr (rands (var));

	if do_rounding & ^current_ms.rounded
	then inst_number = store_inst (eaq_name);
	else inst_number = store_no_round_inst (eaq_name);

	if v -> node.node_type = temporary_node
	then call bump_count (var, 1);

	call emit_single (inst_number, var);

	if eaq_name = in_q
	then if string (v -> node.value_in)
	     then call flush_ref (var);

	if update_flag = 0
	then do;
	     v -> node.not_in_storage = "0"b;
	     call in_reg (var, eaq_name);
	     end;

     end store;

lock_eaq:
     procedure (reg);

	/* Locks an EAQ register for use in addressing */

dcl  reg fixed binary (18);

	current_ms.eaq (reg).reserved = "1"b;

     end lock_eaq;

/**** INDICATOR SAVING AND RESTORING ****/

save_ind_state:
     procedure (a_state);

	/* Saves (and restores) indicator state if compiler must emit
	   instructions that modify the indicators. */

dcl  a_state fixed binary (18);			/* output - see below */
dcl  saved_state fixed binary (18);

	/* The parameter a_state is set as follows to indicate how the
	   indicators should be restored:
	   = 0: the indicators are meaningless, or the reg is empty;
	   the indicators need not be restored.
	   > 0: the indicators contain a logical value which was stored;
	   the indicators can be reloaded directly.
	   < 0: the indicators reflect the sign of a register;
	   the indicators can be restored with a comparison against 0. */

dcl  escape_address bit (36) aligned internal static options (constant) initial ("600056000100"b3);
						/* address of sp|46 */

	if current_ms.indicators_valid > 0 & current_ms.eaq (IND).name = 0
	then if current_ms.indicators_valid <= highest_ind_state
	     then saved_state = -current_ms.eaq (current_ms.indicators_valid).name;
	     else if current_ms.index_regs (current_ms.indicators_valid - highest_ind_state - 1).type > 0
	     then saved_state = -current_ms.indicators_valid;
	     else saved_state = 0;
	else if current_ms.eaq (IND).name >= in_ind
	then do;					/* logical value */
	     saved_state = current_ms.eaq (IND).name;
	     if current_ms.eaq (IND).name > in_ind
	     then current_ms.eaq (IND).name = in_ind;
	     call emit_c_a (store_ind, escape_address);
	     end;
	else saved_state = 0;

	a_state = saved_state;
	return;

restore_ind_state:
     entry (a_state);

	saved_state = a_state;

	if saved_state < 0
	then do;					/* inds reflect sign of reg, compare to zero */
	     saved_state = -saved_state;

	     if saved_state <= highest_ind_state
	     then do;
		call emit_c_a_const ((compare_inst (saved_state)), (zero_for_dt (dt_from_reg (saved_state))));
		current_ms.indicators_valid = eaq_name_to_reg (saved_state);
		end;

	     else do;
		call emit_c_a_const (cmpx0 + saved_state - highest_ind_state - 1, (zero_for_dt (int_mode)));
		saved_state = 0;
		end;
	     end;

	else if saved_state > 0
	then call emit_c_a (load_ind, escape_address);	/* ind state was stored, load it back */

	if saved_state > in_ind
	then current_ms.eaq (IND).name = saved_state;

     end save_ind_state;

/**** STATE MANAGEMENT ****/

save_state:
     procedure (lbl);

	/* Given a label operand, merge the current ms into the label's statement's machine state */

dcl  (lbl, msp, stmnt) fixed binary (18);
dcl  msp_ptr pointer;

	stmnt = addr (rands (lbl)) -> label.statement;
	if stmnt > 0
	then do;
	     msp = addr (quad (stmnt)) -> opt_statement.machine_state;
	     if msp = 0
	     then do;				/* No previous ms for statement */

		/* reuse an old machine_state node or allocate a new one */

		if next_free_ms = null
		then do;
		     msp = create_node (machine_state_node, size (machine_state));
		     msp_ptr = addr (rands (msp));
		     end;

		else do;
		     msp_ptr = next_free_ms;
		     msp = fixed (rel (msp_ptr), 18);
		     next_free_ms = msp_ptr -> machine_state.next;
		     unspec (msp_ptr -> machine_state) = "0"b;
		     msp_ptr -> machine_state.node_type = machine_state_node;
		     end;

		msp_ptr -> machine_state.next = null;
		addr (quad (stmnt)) -> opt_statement.machine_state = msp;

		/* if machine state exists, copy to target; empty state is initial value for node */

		if ^state_discarded
		then do;
		     call bump_all_ms_ref_counts;	/* mark everything in ms as saved */
		     msp_ptr -> machine_state.ms = current_ms.ms;
						/* copy ms to target label ms */
		     end;
		end;
	     else do;				/* Machine state exists, merge them. */
		msp_ptr = addr (rands (msp));

		if state_discarded
		then do;
		     call drop_all_ms_ref_counts (msp_ptr -> machine_state);
						/* all are unsaved */
		     unspec (msp_ptr -> machine_state.ms) = "0"b;
						/* empty state */
		     end;
		else call merge_state (msp_ptr -> machine_state, current_ms, "0"b);
		end;
	     end;

     end save_state;

merge_state:
     procedure (existing_state, a_new_state, update_flag);

	/* Merge new_state into existing_state. */

dcl  1 (existing_state, a_new_state, new_state) like machine_state aligned;
dcl  (update_flag, updating_ms) bit (1) aligned;
dcl  (i, j, r) fixed binary (18);
dcl  reg fixed binary (3);

	new_state = a_new_state;
	updating_ms = update_flag;			/* ="1"b if merging into current state. */

	if updating_ms				/* Merging states at a label, ms is freed when done. */
	then do;
	     new_state.next = next_free_ms;
	     next_free_ms = addr (a_new_state);
	     call drop_all_ms_ref_counts (new_state);
	     end;

	if state_discarded & updating_ms		/* make the current machine state be new_state */
	then do;
	     existing_state.ms = new_state.ms;		/* note this assignment destroys **.global */

	     do r = 1 to hbound (current_ms.eaq, 1);	/* A, Q, EAQ, IND */
		do i = 1 to new_state.eaq (r).number;
		     addr (rands (new_state.eaq (r).variable (i))) -> node.value_in.eaq = "1"b;
		     end;
		end;

	     if new_state.value_in_xr
	     then do i = first_index to last_index;
		     existing_state.index_regs (i).global = "0"b;
						/* invalid anyhow */
		     if new_state.index_regs (i).type = 1
		     then if new_state.index_regs (i).variable ^= 0
			then do;
			     addr (rands (new_state.index_regs (i).variable)) -> node.value_in.x = "1"b;
			     if analyzing
			     then if ^eligible (addr (rands (new_state.index_regs (i).variable)))
				then index_data.local = index_data.local + 1;
			     end;
			else ;
		     else if new_state.index_regs (i).type ^= 0
		     then index_data.local = index_data.local + 1;
		     end;

	     if new_state.address_in_base
	     then do i = first_base to last_base;
		     existing_state.base_regs (i).global = "0"b;
						/* invalid anyhow */
		     if new_state.base_regs (i).type = 1
		     then if new_state.base_regs (i).variable ^= 0
			then do;
			     j = new_state.base_regs (i).variable;
			     addr (rands (j)) -> node.addr_hold =
				substr (unspec (addr (rands (j)) -> node.address), 1, 18);
			     addr (rands (j)) -> node.reloc_hold = addr (rands (j)) -> node.reloc;
			     addr (rands (j)) -> node.address.base = bases (i);
			     addr (rands (j)) -> node.address.offset = 0;
			     addr (rands (j)) -> node.address.tag = "0"b;
			     addr (rands (j)) -> node.reloc = rc_a;
			     addr (rands (j)) -> node.address_in_base = "1"b;
			     ptr_data.local = ptr_data.local + 1;
			     end;
			else ;
		     else if new_state.base_regs (i).type = 7
		     then ptr_data.local = ptr_data.local + 1;
		     end;

	     /* Because the global bits have been wiped out by the structure
	        assignment to existing_state.ms, we refresh them by calling
	        refresh_global_bits. */

	     call refresh_global_bits (cur_lp);

	     return;
	     end;

	/* Form intersection of EAQ states. */

	do r = 1 to hbound (current_ms.eaq, 1);		/* A, Q, EAQ, IND */

	     if existing_state.eaq (r).number = 0 | new_state.eaq (r).number = 0
	     then call empty_the_eaq (r);

	     else if existing_state.eaq (r).name ^= new_state.eaq (r).name
	     then call empty_the_eaq (r);

	     else do;				/* Form intersection */

		i = 1;
		do while (i <= existing_state.eaq (r).number);

		     do j = 1 to new_state.eaq (r).number
			while (existing_state.eaq (r).variable (i) ^= new_state.eaq (r).variable (j));
			end;

		     if j > new_state.eaq (r).number
		     then do;			/* no match */

			if updating_ms
			then addr (rands (existing_state.eaq (r).variable (i))) -> node.value_in.eaq = "0"b;
			else call drop_ms_ref_count (addr (rands (existing_state.eaq (r).variable (i))), ("0"b));

			/* remove item from eaq variable list */

			do j = i to existing_state.eaq (r).number - 1;
			     existing_state.eaq (r).variable (j) = existing_state.eaq (r).variable (j + 1);
			     end;

			existing_state.eaq (r).number = existing_state.eaq (r).number - 1;

			end;

		     else i = i + 1;		/* matched, proceed */

		     end;				/* end intersection loop */

		if existing_state.eaq (r).number = 0
		then existing_state.eaq (r).name = 0;

		end;				/* end intersection code */

	     end;					/* end loop over eaq registers */

	/* Form intersection of rounded states. */

	existing_state.rounded = existing_state.rounded & new_state.rounded;

	/* Form intersection of indicator states. */

	if existing_state.indicators_valid ^= new_state.indicators_valid
	then existing_state.indicators_valid = 0;

	/* Form intersection of index regs states. */

	do reg = lbound (current_ms.index_regs, 1) to hbound (current_ms.index_regs, 1);

	     if existing_state.index_regs (reg).type = new_state.index_regs (reg).type
	     then if existing_state.index_regs (reg).variable ^= new_state.index_regs (reg).variable
		then call empty_xr;			/* Implied argument is "reg" */
		else ;				/* index reg the same in both states */
	     else call empty_xr;			/* not the same, flush the reg */
	     end;

	if ^new_state.value_in_xr
	then existing_state.value_in_xr = "0"b;

	/* Form intersection of base regs states. */

	do reg = lbound (current_ms.base_regs, 1) to hbound (current_ms.base_regs, 1);

	     if existing_state.base_regs (reg).type ^= new_state.base_regs (reg).type
		| existing_state.base_regs (reg).variable ^= new_state.base_regs (reg).variable
		| existing_state.base_regs (reg).offset ^= new_state.base_regs (reg).offset
	     then call empty_base;			/* implied arg is reg */

	     end;

	if ^new_state.address_in_base
	then existing_state.address_in_base = "0"b;

	/* Form intersection of dynamic temp states */

	if existing_state.stack_extended ^= new_state.stack_extended
	then existing_state.stack_extended = "1"b;

	if existing_state.last_dynamic_temp ^= new_state.last_dynamic_temp
	then existing_state.last_dynamic_temp = 0;

	return;					/* code for merging states */

flush_state:
     entry;

	call flush_eaq ();

	if current_ms.value_in_xr
	then do reg = first_index to last_index;
		call flush_xr (reg);
		end;

	if current_ms.address_in_base
	then do reg = first_base to last_base;
		call flush_base (reg);
		end;

	unspec (current_ms) = "0"b;

	current_ms.base_regs (which_base (4)).type = 6;	/* linkage_ptr */

	index_data.local, ptr_data.local = 0;

	return;					/* code to flush state */

empty_the_eaq:
     procedure (r);

	/* Marks the specified eaq register as empty. */

dcl  (r, n) fixed binary (18);

	existing_state.eaq (r).name = 0;

	n = existing_state.eaq (r).number;
	do while (n > 0);

	     if updating_ms
	     then addr (rands (existing_state.eaq (r).variable (n))) -> node.value_in.eaq = "0"b;
	     else call drop_ms_ref_count (addr (rands (existing_state.eaq (r).variable (n))), ("0"b));

	     n = n - 1;

	     end;

	existing_state.eaq (r).number = 0;
	existing_state.rounded = "0"b;

     end empty_the_eaq;

empty_xr:
     procedure ();

	/* Marks the specified index register as empty */

	if updating_ms
	then call flush_xr (reg);
	else if existing_state.index_regs (reg).type = 1
	then call drop_ms_ref_count (addr (rands (existing_state.index_regs (reg).variable)), ("0"b));

	existing_state.index_regs (reg).type = 0;
	existing_state.index_regs (reg).variable = 0;

     end empty_xr;

empty_base:
     procedure ();

	/* Marks the specified base register as empty */

	if updating_ms
	then call flush_base (reg);
	else if existing_state.base_regs (reg).type = 1
	then call drop_ms_ref_count (addr (rands (existing_state.base_regs (reg).variable)), ("0"b));

	existing_state.base_regs (reg).type = 0;
	existing_state.base_regs (reg).variable = 0;
	existing_state.base_regs (reg).offset = 0;

     end empty_base;

     end merge_state;

discard_state:
     procedure ();

	/* Discard the machine state. Empty all the registers. */

dcl  i fixed binary (3);

	if state_discarded
	then return;

	if current_ms.address_in_base
	then do i = first_base to last_base;
		call flush_base (i);
		end;

	call reset_eaq (EAQ);
	call reset_eaq (IND);

	if current_ms.value_in_xr
	then do i = first_index to last_index;
		if current_ms.index_regs (i).type = 1
		then if current_ms.index_regs (i).variable ^= 0
		     then addr (rands (current_ms.index_regs (i).variable)) -> node.value_in.x = "0"b;
		end;

	unspec (current_ms) = "0"b;

	index_data.local, ptr_data.local = 0;

	state_discarded = "1"b;

     end discard_state;

/**** GLOBAL REGISTER MANAGEMENT (See also find_global_base and find_global_index) ****/

leave_loop:
     procedure (lp_msp);

	/* Turns off global bits in current_ms and globally_assigned bits for
	   operands globally assigned in this loop */

dcl  (msp, lp_msp) pointer;				/* -> loop node's machine_state template */

dcl  1 loop_state based (msp) aligned like machine_state;

dcl  i fixed binary;

	msp = lp_msp;

	if msp ^= null
	then do;
	     do i = first_base to last_base;
		current_ms.base_regs (i).global = "0"b;
		end;

	     do i = first_index to last_index;
		current_ms.index_regs (i).global = "0"b;

		if loop_state.index_regs (i).type = 1
		then addr (rands (loop_state.index_regs (i).variable)) -> node.globally_assigned = "0"b;
		end;
	     end;

     end leave_loop;

enter_loop:
     procedure (lp, lp_msp);

	/* Sets lp_msp for a new loop.  Turns on the proper global bits in
	   current_ms and turns on the globally_assigned bits for globally
	   assigned operands */

dcl  lp pointer,					/* -> loop node */
     lp_msp pointer;				/* loop_node's machine_state pointer (output) */

dcl  msp pointer;
dcl  1 loop_state based (msp) aligned like machine_state;

dcl  i fixed binary;

	if lp ^= null
	then do;
	     lp_msp, msp = lp -> loop.msp;

	     if msp ^= null
	     then do;
		do i = first_base to last_base;
		     current_ms.base_regs (i).global = loop_state.base_regs (i).global;
		     end;

		do i = first_index to last_index;
		     current_ms.index_regs (i).global = loop_state.index_regs (i).global;

		     if loop_state.index_regs (i).type = 1
		     then addr (rands (loop_state.index_regs (i).variable)) -> node.globally_assigned = "1"b;
		     end;
		end;
	     end;

     end enter_loop;

refresh_global_bits:
     procedure (p_lp);

	/* Refreshes the global bits in current_ms by copying them from the
	   loop template, if it exists, or by zeroing them. */

dcl  (lp, p_lp) pointer;				/* -> loop node */

dcl  i fixed binary;
dcl  useless pointer;

	lp = p_lp;

	if lp ^= null
	then if lp -> loop.msp ^= null
	     then call enter_loop (lp, useless);
	     else do;
		do i = first_base to last_base;
		     current_ms.base_regs (i).global = "0"b;
		     end;

		do i = first_index to last_index;
		     current_ms.index_regs (i).global = "0"b;
		     end;
		end;

     end refresh_global_bits;

adjust_state_for_globals:
     procedure ();

	/* This is called when processing a label that has a backwards reference.
	   It adds the globally assigned items to the current machine_state by
	   looking in the loop node's template.	*/

dcl  i fixed binary;

	if lp_msp ^= null
	then do;
	     do i = first_base to last_base;
		if loop_state.base_regs (i).type ^= 0
		then current_ms.base_regs (i) = loop_state.base_regs (i);
		end;

	     do i = first_index to last_index;
		if loop_state.index_regs (i).type ^= 0
		then do;

		     /* type should be 1 (a variable or temp) */

		     current_ms.index_regs (i) = loop_state.index_regs (i);
		     addr (rands (current_ms.index_regs (i).variable)) -> node.value_in.x = "1"b;
		     end;
		end;

	     current_ms.value_in_xr = loop_state.value_in_xr;
	     current_ms.address_in_base = loop_state.address_in_base;
	     end;

     end adjust_state_for_globals;

cleanup_loop_state_nodes:
     procedure ();

dcl  i fixed binary;
dcl  lp pointer;

	do i = 1 to n_loops - 1;
	     lp = loop_vector (i);
	     if lp -> loop.msp ^= null
	     then do;
		lp -> loop.msp -> machine_state.next = next_free_opt_ms;
		next_free_opt_ms = lp -> loop.msp;
		lp -> loop.msp = null;
		end;
	     end;

     end cleanup_loop_state_nodes;

refresh_regs:
     procedure (protect_ind);

	/* This is called at the end of a flow_unit to ensure that all globally
	   assigned values are in their proper registers.  All registers are
	   unlocked at the end of the routine.	*/

dcl  (protect_ind, protect_indicators) fixed binary (18);	/* if ^= 0, protect indicators
						   when loading xregs. */

dcl  saved_state fixed binary (18);

dcl  (i, pass) fixed binary;
dcl  bit6 bit (6) aligned;
dcl  bit3 bit (3) aligned;

	if ^fu -> flow_unit.refreshed & lp_msp ^= null
	then do;
	     saved_state = 0;
	     protect_indicators = protect_ind;

	     /* Refresh the index registers. */

	     do i = first_index to last_index;
		if current_ms.index_regs (i).global & current_ms.index_regs (i).type <= 0
		then do;
		     if protect_indicators ^= 0 & saved_state = 0
		     then call save_ind_state (saved_state);
		     bit6 = xr_man_load_any_xr (addr (rands (loop_state.index_regs (i).variable)));
		     end;
		end;

	     /* Refresh the base registers.  First refresh all the registers
	        with offset = 0, then refresh the others.  This avoids
	        generating code to add an offset and then subtract it again
	        if two pointers into the same region (stack, linkage, common
	        block) with different offsets are to be loaded. */

	     do pass = 1 to 2;
		do i = first_base to last_base;
		     if current_ms.base_regs (i).global
			& (current_ms.base_regs (i).type <= 0 | current_ms.base_regs (i).type = 7)
						/* kludge for load_pr_value */
		     then if (pass = 1 & loop_state.base_regs (i).offset = 0)
			     | (pass = 2 & loop_state.base_regs (i).offset ^= 0)
			then bit3 =
				base_man_dispatch (loop_state.base_regs (i).type,
				loop_state.base_regs (i).variable, loop_state.base_regs (i).offset);
		     end;
		end;

	     /* Restore the indicators if xr_man altered them and they were protected. */

	     if saved_state ^= 0
	     then call restore_ind_state (saved_state);

	     /* Mark the flow_unit as refreshed so that we don't process redundantly. */

	     fu -> flow_unit.refreshed = "1"b;
	     end;

	/* Free all locked registers. */

	call free_regs ();

     end refresh_regs;

assign_register:
     procedure (p_adam, p_reg_type, p_regno, p_code, p_var, p_off);

	/* Assigns an item to a register across adam and all loops contained in adam */

dcl  (adam, p_adam) pointer,				/* -> loop nest over which reg is assigned */
     (reg_type, p_reg_type) fixed binary,		/* INDEX, BASE */
     (regno, p_regno) fixed binary (3),			/* register number */
     (code, p_code) fixed binary (18),
     (var, p_var) fixed binary (18),
     (off, p_off) fixed binary (18);

dcl  p pointer;

	/* copy in the parameters */

	adam = p_adam;
	reg_type = p_reg_type;
	regno = p_regno;
	code = p_code;
	var = p_var;
	off = p_off;

	/* assign the item to the register in adam */

	call assign (adam);

	if adam -> loop.son = null
	then return;

	/* By using a simulated recursive walk, assign the item to the register
	   in all loops contained in adam. */

	p = adam -> loop.son;

	do while ("1"b);
	     call assign (p);

	     if p -> loop.son ^= null
	     then p = p -> loop.son;

	     else do;
		do while (p -> loop.brother = null);
		     p = p -> loop.father;
		     if p = adam
		     then return;
		     end;

		p = p -> loop.brother;
		end;

	     end;

	return;

assign:
     procedure (lp);

dcl  lp pointer;					/* -> loop node */

dcl  msp pointer;

	if lp -> loop.msp ^= null
	then msp = lp -> loop.msp;
	else lp -> loop.msp, msp = create_machine_state ();

	if reg_type = INDEX
	then do;
	     msp -> machine_state.index_regs (regno).global = "1"b;
	     msp -> machine_state.index_regs (regno).type = code;
	     msp -> machine_state.index_regs (regno).variable = var;
	     msp -> machine_state.value_in_xr = "1"b;
	     end;

	else do;
	     msp -> machine_state.base_regs (regno).global = "1"b;
	     msp -> machine_state.base_regs (regno).type = code;
	     msp -> machine_state.base_regs (regno).variable = var;
	     msp -> machine_state.base_regs (regno).offset = off;
	     if code = 1
	     then msp -> machine_state.address_in_base = "1"b;
	     end;

     end assign;

     end assign_register;

create_machine_state:
     procedure () returns (pointer);

	/* Allocates a machine_state node */

dcl  msp pointer;

	if next_free_opt_ms = null
	then msp = get_opt_space (size (machine_state));
	else do;
	     msp = next_free_opt_ms;
	     next_free_opt_ms = msp -> machine_state.next;
	     unspec (msp -> machine_state) = "0"b;
	     end;

	msp -> machine_state.node_type = machine_state_node;
	msp -> machine_state.next = null;

	return (msp);

     end create_machine_state;

is_induction_var:
     procedure (p) returns (bit (1) aligned);

	/* Returns "1"b if p -> symbol for an induction variable in cur_lp */

dcl  p pointer;

	if p -> node.node_type = symbol_node
	then if p -> symbol.coordinate > 0
	     then return (substr (cur_lp -> loop.induction_var -> bits, p -> symbol.coordinate, 1));

	return ("0"b);

     end is_induction_var;

find_range:
     procedure (pt, lp) returns (pointer);

	/* Finds range data for a variable. */

dcl  (
     p unaligned,
     pt
     ) pointer,					/* -> symbol node */
     lp pointer;					/* -> loop node */

dcl  r pointer;

	p = pt;

	do r = lp -> loop.range_list repeat r -> range.next while (r ^= null);
	     if p = r -> range.variable
	     then return (r);
	     end;

	return (null);

     end find_range;

definitely_initialized:
     procedure (coord, start_fu) returns (bit (1) aligned);

dcl  coord fixed binary (18),				/* Coordinate of symbol that we're checking out */
     start_fu pointer;				/* Flow_unit in which we're trying to check out the symbol */

dcl  i fixed binary;
dcl  fu pointer;

	/* We attempt to determine if a symbol has been definitely
	   initialized by searching back along the dominator chain.
	   This is not really the best method for accuracy or speed.
	   If this is important, it should be done by a more formal
	   data_flow_analysis method in fort_optimizer.  This algorithm
	   does err on the side of safety. */

	i = coord;

	do fu = start_fu repeat fu -> flow_unit.dominator while (fu ^= null);
	     if substr (fu -> flow_unit.always_completely_set -> bits, i, 1)
	     then return ("1"b);
	     end;

	return ("0"b);

     end definitely_initialized;

/**** REFERENCE COUNTS ****/

get_ref_count:
     procedure (p) returns (fixed binary (18));

	/* Returns temporary.ref_count or temporary.ref_count_copy depending
	   on whether we are analyzing or generating code. */

dcl  p pointer;					/* -> temporary node or array_ref node */

	if analyzing
	then return (p -> temporary.ref_count_copy);
	else return (p -> temporary.ref_count);

     end get_ref_count;

bump_count:
     procedure (opnd, incre);

	/* Increments ref count of opnd by incre */

dcl  opnd fixed binary (18);
dcl  incre fixed binary (18);				/* amount to bump ref count */

dcl  p pointer;

	p = addr (rands (opnd));

	if p -> node.node_type = array_ref_node | p -> node.node_type = temporary_node
	then if analyzing
	     then p -> temporary.ref_count_copy = p -> temporary.ref_count_copy + incre;
	     else p -> temporary.ref_count = p -> temporary.ref_count + incre;

     end bump_count;

drop_count:
     procedure (opnd, incre);

	/* Decrement ref count of opnd by incre */

dcl  opnd fixed binary (18);
dcl  incre fixed binary (18);				/* amount to drop ref count */
dcl  tp pointer;
dcl  n fixed binary;

	if opnd > 0
	then do;
	     tp = addr (rands (opnd));

	     if tp -> node.node_type = array_ref_node
	     then do;
		if analyzing
		then n, tp -> array_ref.ref_count_copy = tp -> array_ref.ref_count_copy - incre;
		else n, tp -> array_ref.ref_count = tp -> array_ref.ref_count - incre;
		if n <= 0
		then call free_array_ref (tp);
		end;

	     else if tp -> node.node_type = temporary_node
	     then do;
		if analyzing
		then n, tp -> temporary.ref_count_copy = tp -> temporary.ref_count_copy - incre;
		else n, tp -> temporary.ref_count = tp -> temporary.ref_count - incre;
		if n <= 0
		then call free_temp (tp);
		end;
	     end;

     end drop_count;

bump_all_ms_ref_counts:
     procedure ();

	/* Bumps ms_ref_count for everything currently in the machine state */

dcl  (i, r) fixed binary (18);

	do r = 1 to hbound (current_ms.eaq, 1);		/* A, Q, EAQ, IND */
	     do i = 1 to current_ms.eaq (r).number;
		call bump_ms_ref_count (addr (rands (current_ms.eaq (r).variable (i))));
		end;
	     end;

	if current_ms.value_in_xr
	then do i = first_index to last_index;
		if current_ms.index_regs (i).type = 1
		then call bump_ms_ref_count (addr (rands (current_ms.index_regs (i).variable)));
		end;

	if current_ms.address_in_base
	then do i = first_base to last_base;
		if current_ms.base_regs (i).type = 1
		then call bump_ms_ref_count (addr (rands (current_ms.base_regs (i).variable)));
		end;

	return;

bump_ms_ref_count:
     procedure (node_pt);

	/* Bumps ms ref count for the given operand */

dcl  node_pt pointer;

	if node_pt -> node.node_type = temporary_node
	then node_pt -> temporary.ms_ref_count = node_pt -> temporary.ms_ref_count + 1;

     end bump_ms_ref_count;

     end bump_all_ms_ref_counts;

drop_all_ms_ref_counts:
     procedure (affected_ms);

	/* Drops ms_ref_count for everything in specified machine state */

dcl  1 affected_ms aligned like machine_state;
dcl  count_is_zero bit (1) aligned;
dcl  (i, j, r) fixed binary (18);

	do r = 1 to hbound (current_ms.eaq, 1);		/* A, Q, EAQ, IND */
	     do i = affected_ms.eaq (r).number to 1 by -1;
		call drop_ms_ref_count (addr (rands (affected_ms.eaq (r).variable (i))), count_is_zero);

		if count_is_zero
		then do;
		     affected_ms.eaq (r).number = affected_ms.eaq (r).number - 1;
		     do j = i to affected_ms.eaq (r).number;
			affected_ms.eaq (r).variable (j) = affected_ms.eaq (r).variable (j + 1);
			end;
		     end;
		end;

	     if affected_ms.eaq (r).number = 0
	     then affected_ms.eaq (r).name = 0;

	     end;

	if affected_ms.value_in_xr
	then do i = first_index to last_index;
		if affected_ms.index_regs (i).type = 1
		then do;
		     call drop_ms_ref_count (addr (rands (affected_ms.index_regs (i).variable)), count_is_zero);

		     if count_is_zero
		     then affected_ms.index_regs (i).type, affected_ms.index_regs (i).variable = 0;
		     end;
		end;

	if affected_ms.address_in_base
	then do i = first_base to last_base;
		if affected_ms.base_regs (i).type = 1
		then do;
		     call drop_ms_ref_count (addr (rands (affected_ms.base_regs (i).variable)), count_is_zero);

		     if count_is_zero
		     then affected_ms.base_regs (i).type, affected_ms.base_regs (i).variable = 0;
		     end;
		end;

     end drop_all_ms_ref_counts;

drop_ms_ref_count:
     procedure (node_pt, ref_count_is_zero);

	/* Drops the ms ref_count of the given operand */

dcl  node_pt pointer;
dcl  ref_count_is_zero bit (1) aligned;			/* true ref_count, not ms_ref_count, is zero */

	if node_pt -> node.node_type = temporary_node
	then do;
	     node_pt -> temporary.ms_ref_count = node_pt -> temporary.ms_ref_count - 1;

	     if get_ref_count (node_pt) <= 0
	     then do;
		ref_count_is_zero = "1"b;
		if node_pt -> temporary.ms_ref_count <= 0
		then call free_temp ((node_pt));
		end;
	     else ref_count_is_zero = "0"b;
	     end;
	else ref_count_is_zero = "0"b;

     end drop_ms_ref_count;

/**** REL_CONSTANTS ****/

alloc_relcon:
     procedure (opnd, value);

	/* Allocates a rel_constant */

dcl  opnd fixed binary (18),				/* Operand offset in region */
     value fixed binary (18);				/* Value to be assigned to operand */

dcl  p pointer;

	p = addr (rands (opnd));

	p -> label.location = value;
	p -> label.allocated = "1"b;

     end alloc_relcon;

alloc_label:
     procedure (a_opnd, value);

	/* Does everything required to "define" an executable rel const. */

dcl  a_opnd fixed binary (18);
dcl  value fixed binary (18);
dcl  opnd fixed binary (18);
dcl  (lbl, st) pointer;

	opnd = a_opnd;
	lbl = addr (rands (opnd));

	if lbl -> label.referenced_executable
	then if lbl -> label.statement > 0
	     then do;
		st = addr (quad (lbl -> label.statement));

		/* set up correct machine state; flush state if label is backward ref */

		if st -> opt_statement.referenced_backwards | st -> opt_statement.referenced_by_assign
		then if st -> opt_statement.machine_state = 0
		     then do;
			call flush_state;		/* flush machine state since we have no info on regs */
			call adjust_state_for_globals;/* any globally assigned items can be added to ms */

			/* force doubleword alignment for entry of innermost loop */

			if mod (value, 2) ^= 0 & cur_lp -> loop.son = null & cur_lp -> loop.entry_unit = fu
			then call emit_zero (nop);
			end;

		     else do;			/* statement cannot have a machine state!!! */
			call print_message (444);	/* fatal */
			return;
			end;

		else if st -> opt_statement.machine_state > 0
		then do;
		     call merge_state (current_ms, addr (rands (st -> opt_statement.machine_state)) -> machine_state,
			"1"b);
		     st -> opt_statement.machine_state = 0;
		     end;

		state_discarded = "0"b;
		end;

	call alloc_relcon (opnd, (value));

	if lbl -> label.restore_prs
	then call emit_zero (getlp);                 /* Restore frozen ptr reg (pr4) */

     end alloc_label;

/**** BUILD PROFILE ENTRY ****/

build_profile_entry:
     procedure ();

	if ^generate_long_profile
	then call use_ind;				/* aos sets indicators */

	if analyzing
	then return;				/* modified to produce both long and short profile. */

	if generate_long_profile
	then do;					/* long_profile */
	     call emit_operator_call (long_profile);

	     /* emit internal static relative offset to long_profile_header */

	     text_halfs (text_pos).left = profile_start;
	     reloc (text_pos).left_rel = rc_is18;

	     /* emit relative offset from long_profile_header to entry */

	     text_halfs (text_pos).right = profile_pos;
	     reloc (text_pos).right_rel = rc_a;
	     text_pos = text_pos + 1;
	     profile_pos = profile_pos + size (long_profile_entry);
	     end;
	else do;					/* short profile */
	     call emit_c_a (aos, c_a (profile_pos + 1, 5));
	     reloc (text_pos - 1).left_rel = rc_is15;

	     profile_pos = profile_pos + size (profile_entry);
	     end;

     end build_profile_entry;

setup_message_structure:
     procedure ();

	/* Sets up message_structure for print & error macros */

dcl  i fixed binary (18);

	message_structure.message_number = left;
	message_structure.number_of_operands = macro_dt_inst (imac).data_type;

	do i = 1 to message_structure.number_of_operands;
	     imac = imac + 1;

	     left = macro_instruction (imac).left;
	     if left = 0
	     then do;

		/* have an operand as argument */

		message_structure.is_string (i) = "0"b;
		message_structure.operand_index (i) = stack (get_operand ((macro_instruction (imac).operand)));
		end;

	     else do;

		/* have a string as argument */

		message_structure.is_string (i) = "1"b;
		message_structure.string_length (i) = macro_dt_inst (imac).data_type;
		message_structure.string_ptr (i) = addrel (mac_base, macro_instruction (imac).left);
		end;
	     end;

     end setup_message_structure;

create_integer_constant:
     procedure (value) returns (fixed binary (18));

dcl  value fixed binary (35) aligned;
dcl  bvalue bit (72) aligned;

	bvalue = unspec (value);
	return (create_constant (int_mode, bvalue));

     end create_integer_constant;

/**** SUBSCRIPTING CODE ****/

	/* format: style4,delnl,insnl,^ifthendo,indnoniterend,inditerdo,indend,^indproc,indcom,declareind5 */
optimized_subscript:
     procedure (quad_ptr);

	/* Prepares an array_ref node by using the operands of the
	   opt_subscript operator that produced it. */

dcl  quad_ptr pointer;				/* -> opt_subscript producing the array_ref */

dcl  (symbol_ptr, t, len) pointer;
dcl  (i, csize) fixed binary (18);

dcl  1 constant_address aligned,
       2 location fixed binary (17) unaligned,
       2 fill bit (11) unaligned,
       2 ext_base bit (1) unaligned,
       2 tag bit (6) unaligned;

	t = addr (rands (quad_ptr -> operator.output));

	if get_ref_count (t) = 0
	then do;
	     if ^analyzing
	     then call print_message (454, (quad_ptr -> operator.output));
	     return;
	     end;

	t -> array_ref.dont_update = "0"b;

	if t -> array_ref.has_address			/* see if already done */
	then return;

	symbol_ptr = addr (rands (quad_ptr -> operator.operand (1)));

	if quad_ptr -> operator.operand (3) = 0		/* =0 if no variable offset */
	then t -> array_ref.variable_offset = "0"b;
	else do;
	     t -> array_ref.variable_offset = "1"b;
	     t -> array_ref.v_offset = quad_ptr -> operator.operand (3);
	     end;

	t -> array_ref.variable_length = "0"b;

	if symbol_ptr -> symbol.VLA
	then do;
	     t -> array_ref.needs_pointer = "1"b;
	     unspec (t -> array_ref.address) = ""b;
	     t -> array_ref.ext_base = "1"b;
	     end;
	else do;
	     if quad_ptr -> operator.number = 4
	     then do;

		/* Fourth operand is length of substring reference */

		len = addr (rands (quad_ptr -> operator.operand (4)));
		if len -> node.operand_type = constant_type
		then do;
		     csize = addr (len -> constant.value) -> int_image;
		     if csize < 1
		     then do;
			call print_message (460, quad_ptr -> operator.operand (1));
			imac = fixed (rel (addr (fort_opt_macros_$error_macro)), 18);
			go to loop;
			end;
		     t -> array_ref.length = csize;
		     end;
		else do;
		     t -> array_ref.variable_length = "1"b;
		     t -> array_ref.length = quad_ptr -> operator.operand (4);
		     end;
		end;

	     else if t -> array_ref.data_type = char_mode
	     then do;
		csize = get_char_size (symbol_ptr);
		if csize < 0
		then t -> array_ref.length = csize + bias;
		else do;
		     t -> array_ref.variable_length = "1"b;
		     t -> array_ref.length = csize;
		     end;
		end;

	     t -> array_ref.needs_pointer = symbol_ptr -> symbol.needs_pointer;

	     if symbol_ptr -> symbol.named_constant
	     then do;
		unspec (t -> array_ref.address) = (36)"0"b;
		t -> array_ref.reloc = rc_t;
		i = addr (rands (symbol_ptr -> symbol.initial)) -> char_constant.address.location;
		end;
	     else do;
		unspec (t -> array_ref.address) = unspec (symbol_ptr -> symbol.address);
		t -> array_ref.reloc = symbol_ptr -> symbol.reloc;
		i = symbol_ptr -> symbol.address.offset;
		end;

	     if ^t -> array_ref.variable_offset
	     then t -> array_ref.is_addressable = ^t -> array_ref.needs_pointer;

	     t -> array_ref.units = symbol_ptr -> symbol.units;

	     if symbol_ptr -> symbol.large_address
	     then i = i + symbol_ptr -> symbol.location;

	     if symbol_ptr -> symbol.units = char_units
	     then i = i * chars_per_word + symbol_ptr -> symbol.address.char_num;

	     i = i + addr (addr (rands (quad_ptr -> operator.operand (2))) -> constant.value) -> int_image;

	     if symbol_ptr -> symbol.units = char_units
	     then do;
		t -> array_ref.address.char_num = mod (i, chars_per_word);
		if (i < 0) & (t -> array_ref.address.char_num ^= 0)
		then i = divide (i, chars_per_word, 18, 0) - 1;
		else i = divide (i, chars_per_word, 18, 0);
		end;

	     if symbol_ptr -> symbol.named_constant
	     then do;
		constant_address.location = i;
		substr (unspec (t -> array_ref.address), 1, 18) = unspec (constant_address.location);
		end;
	     else do;

		/* If the symbol node had large_addressing then the base in the array_ref
		   node will be incorrect if the array ref is a ^large_address.  Therefore
		   or large_address flags to cause base re-evaluation if required. */


		call set_address_offset (t, i, (symbol_ptr -> symbol.element_size), (symbol_ptr -> symbol.units));
		t -> array_ref.large_address = t -> array_ref.large_address | symbol_ptr -> symbol.large_address;
		end;
	     end;

	t -> array_ref.has_address = "1"b;

	/* The opt_subscript operator counts as a use of the offset
	   and length temporaries, which should decrement their ref
	   counts.  However, we also connect these temporaries to the
	   output array_ref node, which should increment their ref
	   counts.  Thus, the two operations cancel, and we do nothing
	   to the reference counts. */

     end optimized_subscript;

get_param_array_size:
     procedure (sym);

	/* Figures out the size of parameter arrays of
	   expression extents */

dcl  (d, s) pointer;
dcl  (vsum, i) fixed binary (18);
dcl  code_emitted bit (1) aligned;

dcl  sym pointer;

dcl  (virtual_origin, array_size, c_virtual_origin, c_multiplier, ndims, c_mult_offset, desc) fixed binary (18);
dcl  v_multiplier bit (1) aligned;
dcl  vo_already_set bit (1) aligned;

	s = sym;

	if ^s -> symbol.variable_extents & ^s -> symbol.star_extents
	then return;

	desc = s -> symbol.hash_chain;

	/* If there is a descriptor template node, but it has not been
	   assigned storage, then it is only needed to build the entry
	   point definitions and we can ignore it. */

	if desc ^= 0
	then if ^addr (rands (desc)) -> symbol.allocated
	     then desc = 0;

	d = addr (rands (s -> symbol.dimension));

	ndims = d -> dimension.number_of_dims;

	/* Get array_size symbol */

	array_size = d -> dimension.array_size;

	/* Copy descriptor template to automatic storage, but only
	   if get_param_char_size has not done so already. */

	if desc ^= 0 & s -> symbol.v_length = 0
	then call copy_array_desc_template (s);

	/* The rest of the code concerns itself with computing
	   the array size and virtual origin, and with initializing
	   the bound information in the descriptor. */

	/* For some 1 dimensional arrays, we can emit a more efficient
	   code sequence than is possible in the general case. */

	if ndims = 1 & desc = 0 & s -> symbol.v_length = 0 & ^d -> dimension.v_bound (1).lower
	then do;
	     d -> dimension.virtual_origin = s -> symbol.element_size * d -> dimension.lower_bound (1);
	     d -> dimension.has_virtual_origin = "1"b;
	     d -> dimension.variable_virtual_origin = "0"b;

	     code_emitted = "1"b;
	     call compute_dimension_size (1);

	     if ^d -> dimension.assumed_size
	     then do;
		call load ((d -> dimension.size (1)), in_q);
		call mult (s -> symbol.element_size - bias);
		call store (array_size, in_q, 0);
		end;
	     return;
	     end;

	/* The more general sequence must be used. */

	code_emitted = "0"b;
	virtual_origin = 0;
	c_virtual_origin = 0;

	if s -> symbol.v_length = 0
	then do;
	     c_multiplier = s -> symbol.element_size;
	     v_multiplier = "0"b;
	     end;
	else do;
	     c_multiplier = 1;
	     v_multiplier = "1"b;
	     end;

	if s -> symbol.units = char_units & desc ^= 0 & v_multiplier & shared_globals.user_options.table
	then c_mult_offset = ndims * 3;		/* possible variable dims */
	else c_mult_offset = 0;			/* constant dims */

	do i = 1 to ndims;

	     /* This section of code accumulates the virtual origin
	        and array size as long as the dimension bounds remain
	        constant.  When a variable bound is encountered, code
	        is emitted to initialize the virtual origin and array
	        size to the accumulated partial result. */
	     /* if we start with a variable multiplier (i.e. symbol.v_length
	        ^= 0 then ALL MULTIPLIERS MUST BE CALCULATED, not just the
	        LAST one. */

	     if ^code_emitted
	     then do;
		if string (d -> dimension.v_bound (i)) = "00"b & i < ndims & ^v_multiplier
		then do;
		     c_virtual_origin = c_virtual_origin + c_multiplier * d -> dimension.lower_bound (i);
		     c_multiplier = c_multiplier * d -> dimension.size (i);
		     end;
		else do;
		     code_emitted = "1"b;
		     if i = ndims & ^v_multiplier & ^d -> dimension.v_bound (i).lower
		     then do;

			/* The virtual origin is constant. */

			d -> dimension.virtual_origin =
			     c_virtual_origin + c_multiplier * d -> dimension.lower_bound (i);
			d -> dimension.has_virtual_origin = "1"b;
			d -> dimension.variable_virtual_origin = "0"b;
			end;
		     else do;

			/* The virtual origin is variable. */

			virtual_origin = get_virtual_origin (s, vo_already_set);

			if ^vo_already_set
			then do;
			     if c_virtual_origin = 0
			     then call emit_single (stz, virtual_origin);
			     else do;
				if v_multiplier
				then do;
				     call load ((s -> symbol.v_length), in_q);
				     call mult (c_virtual_origin - bias);
				     end;
				else call load (create_integer_constant ((c_virtual_origin)), in_q);
				call store (virtual_origin, in_q, 0);
				end;
			     end;
			end;

		     /* Initialize the array size. */

		     if v_multiplier
		     then do;
			call load ((s -> symbol.v_length), in_q);
			call mult (c_multiplier - bias);
			end;
		     else call load (create_integer_constant ((c_multiplier)), in_q);

		     /* The array size is left in the Q register. */

		     call in_reg (array_size, in_q);
		     end;
		end;

	     /* The following block of code is executed once a variable
	        array bound has been encountered. */

	     if code_emitted
	     then do;

		/* Store the multiplier for this dimension in the
		   descriptor if appropriate. */
		/* If we will generate a runtime symbol entry and we have
		   star_extents in a character string  then save the byte
		   length in the runtime multiplier and the bit length will
		   be concocted later and stored in the true descriptor. */

		if desc ^= 0 & v_multiplier
		then if c_mult_offset ^= 0
		     then call emit_single_with_inc (store_inst (in_q), desc, c_mult_offset + i);
		     else call emit_single_with_inc (store_inst (in_q), desc, 3 * i);

		/* Store the array size if necessary.  If the lower
		   bound is known to be 1, we do not need to store the
		   array size because (1) multiplying it by 1 to compute
		   the virtual origin doesn't change it and (2) the Q
		   is left intact by compute_dimension_size in this
		   particular case. */

		if d -> dimension.v_bound (i).lower | d -> dimension.lower_bound (i) ^= 1
		then call store (array_size, in_q, 1);

		/* Update the virtual origin. */

		if virtual_origin ^= 0 & ^vo_already_set
		then do;
		     if d -> dimension.v_bound (i).lower
		     then call mult ((d -> dimension.lower_bound (i)));
		     else if d -> dimension.lower_bound (i) ^= 1
		     then call mult (d -> dimension.lower_bound (i) - bias);

		     call emit_single (asq, virtual_origin);
		     end;

		/* Compute the size of this dimension, and store the
		   bounds in the array's descriptor. */

		call compute_dimension_size (i);

		/* Update the array size to include the size of this
		   dimension.  One of two code sequences is chosen
		   depending on what is in the Q register.  This need
		   not be done if this is the last dimension of an
		   assumed size array. */

		if i < ndims | ^d -> dimension.assumed_size
		then do;
		     if get_eaq_name (array_size) = in_q
		     then do;

			/* Multiply by dimension size. */

			call load (array_size, in_q);
			if string (d -> dimension.v_bound (i)) = "00"b
			then call mult (d -> dimension.size (i) - bias);
			else call mult ((d -> dimension.size (i)));
			end;
		     else do;

			/* Multiply by array size. */

			if string (d -> dimension.v_bound (i)) = "00"b
			then call load (create_integer_constant ((d -> dimension.size (i))), in_q);
			else call load ((d -> dimension.size (i)), in_q);
			call mult (array_size);
			end;

		     /* The updated array size is left in the Q. */

		     call in_reg (array_size, in_q);
		     end;

		/* If bounds are variable, so is multiplier. */

		v_multiplier = v_multiplier | (string (d -> dimension.v_bound (i)) ^= "00"b);
		end;

	     end;

	/* Store the array size. */

	if ^d -> dimension.assumed_size
	then call store (array_size, in_q, 1);

	/* If the array is in character units and there is a descriptor,
	   the mulipliers must be converted from characters to bits. */

	if s -> symbol.units = char_units & desc ^= 0
	then do;
	     if s -> symbol.v_length ^= 0
	     then i = 1;
	     else i = 2;
	     do i = i to ndims;
		if c_mult_offset ^= 0
		then call emit_single_with_inc (load_inst (in_q), desc, c_mult_offset + i);
		else call emit_single_with_inc (load_inst (in_q), desc, 3 * i);
		call emit_single (mpy, bits_per_char - bias);
		call emit_single_with_inc (store_inst (in_q), desc, 3 * i);
		end;
	     call reset_eaq (Q);
	     end;

	return;

compute_dimension_size:
     procedure (dim_no);

	/* Emits code to compute the number of elements in a given
	   dimension.  Also stores variable array bounds in the array
	   descriptor. */

dcl  dim_no fixed binary (18);
dcl  i fixed binary (3);

	i = dim_no;

	/* If this is the last dimension of an assumed size array,
	   the dimension size must not be calculated.  Simply copy
	   the lower bound to the descriptor if necessary. */

	if (i = ndims) & d -> dimension.assumed_size
	then do;
	     if (desc ^= 0) & d -> dimension.v_bound (i).lower
	     then do;
		call emit_single (load_inst (in_a), (d -> dimension.lower_bound (i)));
		call emit_single_with_inc (store_inst (in_a), desc, 3 * i - 2);
		end;
	     return;
	     end;

	/* The dimension size must be computed. */

	if string (d -> dimension.v_bound (i)) = "01"b
	then do;
	     if d -> dimension.lower_bound (i) = 1
	     then do;

		/* Lower bound is the constant 1.  The dimension size
		   is already correct.  If the upper bound needs to be
		   copied to the descriptor, we use the A register, as
		   the main loop in get_param_array_size depends on
		   the Q register remaining intact. */

		if desc ^= 0
		then do;
		     call emit_single (load_inst (in_a), (d -> dimension.upper_bound (i)));
		     call emit_single_with_inc (store_inst (in_a), desc, 3 * i - 1);
		     end;
		end;
	     else do;

		/* Lower bound is some constant other than 1. */

		call load ((d -> dimension.upper_bound (i)), in_q);
		if desc ^= 0
		then call emit_single_with_inc (store_inst (in_q), desc, 3 * i - 1);
		call sub (d -> dimension.lower_bound (i) - 1 - bias);
		call store ((d -> dimension.size (i)), in_q, 0);
		end;
	     end;

	else if string (d -> dimension.v_bound (i)) = "10"b
	then do;
	     if desc ^= 0
	     then do;
		call emit_single (load_inst (in_a), (d -> dimension.lower_bound (i)));
		call emit_single_with_inc (store_inst (in_a), desc, 3 * i - 2);
		end;
	     call load (create_integer_constant (1 + d -> dimension.upper_bound (i)), in_q);
	     call sub ((d -> dimension.lower_bound (i)));
	     call store ((d -> dimension.size (i)), in_q, 0);
	     end;

	else if string (d -> dimension.v_bound (i)) = "11"b
	then do;
	     if desc ^= 0
	     then do;
		call emit_single (load_inst (in_a), (d -> dimension.lower_bound (i)));
		call emit_single_with_inc (store_inst (in_a), desc, 3 * i - 2);
		end;
	     call load ((d -> dimension.upper_bound (i)), in_q);
	     if desc ^= 0
	     then call emit_single_with_inc (store_inst (in_q), desc, 3 * i - 1);
	     call sub ((d -> dimension.lower_bound (i)));
	     call add (1 - bias);
	     call store ((d -> dimension.size (i)), in_q, 0);
	     end;

     end compute_dimension_size;

load_vsum:
     procedure ();

	/* Emits code to load the variable sum into the Q */

	call load (vsum, in_q);
	code_emitted = "1"b;

     end load_vsum;

mult:
     procedure (op);

	/* Emits code to multiply the variable sum by op */

dcl  op fixed binary (18);

	if ^code_emitted
	then call load_vsum;

	if op + bias < 0
	then call copy (create_integer_constant (op + bias));
	else call copy (op);
	call interpreter_proc (subscript_mpy, r2);
r2:
	call reset_eaq (Q);				/* Value has been modified */

     end mult;

add:
     procedure (op);

	/* Emits code to add op to the variable sum in the Q */

dcl  (mac, op) fixed binary (18);

	mac = adfx1;
	go to join;


sub:
     entry (op);

	/* Emits code to subtract op from the variable sum in the Q */

	mac = sbfx1;

join:
	if ^code_emitted
	then call load_vsum ();

	if op + bias < 0
	then call emit_single (mac, create_integer_constant (op + bias));
	else call emit_single (mac, op);

	call reset_eaq (Q);

     end add;

     end get_param_array_size;

get_virtual_origin:
     procedure (symbol_ptr, found) returns (fixed binary (18));

	/* Returns the operand offset of an array's virtual origin
	   symbol.  found is turned on if the virtual origin is found in
	   the list of those virtual origins that have already been
	   computed in the current entry sequence. */

dcl  symbol_ptr pointer;
dcl  found bit (1) aligned;

dcl  (s, d) pointer;
dcl  i fixed binary (17);

	s = symbol_ptr;
	d = addr (rands (s -> symbol.dimension));

	if s -> symbol.star_extents
	then do;
	     found = "0"b;
	     return (d -> dimension.virtual_origin);
	     end;

	do i = 1 by 1 while (i <= virtual_origin_count);
	     if computed_virtual_origin (i) = d -> dimension.virtual_origin
	     then do;
		found = "1"b;
		return (d -> dimension.virtual_origin);
		end;
	     end;

	found = "0"b;
	if virtual_origin_count < hbound (computed_virtual_origin, 1)
	then do;
	     virtual_origin_count = virtual_origin_count + 1;
	     computed_virtual_origin (virtual_origin_count) = d -> dimension.virtual_origin;
	     end;

	return (d -> dimension.virtual_origin);

     end get_virtual_origin;

free_array_ref:
     procedure (pt);

	/* Frees an array_ref.  The variable length and offset
	   temporaries are also freed if necessary. */

dcl  (pt, p, t) pointer;
dcl  (a_ref, n) fixed binary (18);

	p = pt;
	a_ref = fixed (rel (p), 18);

	if get_ref_count (p) < 0
	then do;
	     call print_message (415, a_ref);
	     return;
	     end;

	if p -> array_ref.v_offset ^= 0
	then do;
	     t = addr (rands (p -> array_ref.v_offset));
	     if t -> node.node_type = temporary_node
	     then do;
		if analyzing
		then n, t -> temporary.ref_count_copy = t -> temporary.ref_count_copy - 1;
		else n, t -> temporary.ref_count = t -> temporary.ref_count - 1;
		if n <= 0
		then call free_temp (t);
		end;
	     end;

	if p -> array_ref.variable_length
	then do;
	     t = addr (rands (p -> array_ref.length));
	     if t -> node.node_type = temporary_node
	     then do;
		if analyzing
		then n, t -> temporary.ref_count_copy = t -> temporary.ref_count_copy - 1;
		else n, t -> temporary.ref_count = t -> temporary.ref_count - 1;
		if n <= 0
		then call free_temp (t);
		end;
	     end;

	call flush_ref (a_ref);
	call flush_addr (a_ref);
	call disconnect_temp (p);

	p -> array_ref.dont_update = "1"b;

	if p -> array_ref.output_by = 0
	then do;
	     p -> array_ref.next = next_free_array_ref;
	     next_free_array_ref = a_ref;
	     end;

     end free_array_ref;

/**** CONCATENATION CODE ****/

start_cat:
     procedure (reallocated);

	/* Expects the stack to contain all the concatenation operands.
	   Computes the length of the result (emitting code if necessary),
	   and allocates the temporary for the result (which is pushed on
	   the stack.)  The parameter reallocated is turned on in the case
	   where the first operand of the concatenation is the most recently
	   allocated dynamic temporary.  (In this case the result temporary
	   is merely an extension of the first operand). */

dcl  reallocated bit (1) aligned;			/* (Output) */

dcl  alloc_length fixed binary (18);			/* Total of operand lengths */
dcl  result fixed binary (18);			/* Result temporary (pushed on stack) */
dcl  star_extent bit (1) aligned;			/* On if any operand is of * extent */
dcl  tv_offset fixed binary (14);			/* Operator offset */
dcl  i fixed binary;				/* Loop variable */

	/* Get total of allocated lengths of operands. */

	alloc_length = 0;
	star_extent = "0"b;
	do i = (top - quad_ptr -> operator.number + 1) to (top - 1) while (^star_extent);
	     alloc_length = alloc_length + get_cat_alloc_length ((stack (i)), star_extent);
	     end;

	if star_extent
	then do;

	     /* At least one of the operands was of star extent.  A dynamic
	        temporary is used for the result in this case. */

	     reallocated = (stack (base) = current_ms.last_dynamic_temp);

	     if reallocated
	     then tv_offset = reallocate_char_string;
	     else tv_offset = allocate_char_string;

	     result = assign_dynamic_temp ();
	     call assign_length_to_cat_result (result);
	     call allocate_dynamic_temp (result, tv_offset);
	     end;

	else do;

	     /* No star extents are involved - use an ordinary temp */

	     reallocated = "0"b;
	     result = assign_char_temp (alloc_length);
	     call assign_length_to_cat_result (result);
	     end;

	/* Initialize some variables that will be used as the concatenation
	   continues. */

	cat_offset_temp = 0;
	saved_cat_address = addr (rands (result)) -> temporary.address;

	call push (result);

     end start_cat;

continue_cat:
     procedure ();

	/* Adds the length of the most recently processed concatenation
	   operand into the address of the result.  The result is assumed
	   to be at the base of the stack, and the most recently processed
	   operand is assumed to be at the top. */

dcl  (p, p1) pointer;				/* To result, operand */
dcl  csize fixed binary (18);				/* Length of operand */
dcl  off fixed binary (18);				/* Total char offset */
dcl  regno fixed binary (3);				/* Base register number */

	p = addr (rands (stack (base)));
	p1 = addr (rands (stack (top)));

	csize = get_char_size (p1);
	if csize < 0
	then do;

	     /* Length of the operand is constant.  Try adding the length
	        to the address of the result, avoiding large address. */

	     off = p -> temporary.address.char_num + (p -> temporary.address.offset * chars_per_word) + (csize + bias);
	     if off < 16384 * chars_per_word
	     then do;
		p -> temporary.address.char_num = mod (off, chars_per_word);
		if (off < 0) & (p -> temporary.address.char_num ^= 0)
		then p -> temporary.address.offset = divide (off, chars_per_word, 18, 0) - 1;
		else p -> temporary.address.offset = divide (off, chars_per_word, 18, 0);
		return;
		end;
	     else csize = create_integer_constant (csize + bias);
	     end;

	/* The length will have to be kept in a register.  We use the Q,
	   so that the lengths of subsequent operands can be added. */

	if cat_offset_temp = 0
	then do;

	     /* This is the first operand length we have had to put in a
	        register.  Allocate a temporary to hold the variable offset
	        and load the length into the Q. */

	     cat_offset_temp = assign_temp (int_mode);
	     if analyzing
	     then addr (rands (cat_offset_temp)) -> temporary.ref_count_copy = 131071;
	     else addr (rands (cat_offset_temp)) -> temporary.ref_count = 131071;
	     call bump_count (csize, 1);
	     call load (csize, in_q);
	     call use_eaq (0, Q, 0);
	     call in_reg (cat_offset_temp, in_q);
	     end;

	else do;

	     /* Add the operand length into the variable offset. */

	     call load (cat_offset_temp, in_q);
	     addr (rands (cat_offset_temp)) -> temporary.not_in_storage = "0"b;
	     call bump_count (csize, 1);
	     call emit_single (adfx1, csize);
	     call in_reg (cat_offset_temp, in_q);
	     addr (rands (cat_offset_temp)) -> temporary.not_in_storage = "1"b;
	     end;

	/* Prevent emit_eis from using the Q in addressing by reserving it.
	   This is safe because at most one of the operands of the EIS
	   instruction can have a large offset. */

	call lock_eaq (Q);
	p -> temporary.address.tag = p -> temporary.address.tag | QL_mod;

	/* If the address of the result temporary is in a base register,
	   prevent m_a from using it by pretending it is reserved. */

	if p -> temporary.address_in_base
	then do;
	     regno = which_base (fixed (p -> temporary.address.base, 3));
	     current_ms.base_regs (regno).reserved = "1"b;
	     end;

     end continue_cat;

finish_cat:
     procedure ();

	/* Restores the original address of the result temporary, and
	   perform other cleanups now that the concatenation has been
	   completely compiled. */

	addr (rands (stack (base))) -> temporary.address = saved_cat_address;

	if cat_offset_temp ^= 0
	then call free_temp (addr (rands (cat_offset_temp)));

	call free_regs ();

     end finish_cat;

get_cat_alloc_length:
     procedure (opnd, star_extent) returns (fixed binary (18));

	/* Returns the allocation length of the character string operand
	   opnd.  If opnd is a star extent parameter, the star_extent bit
	   is turned on. */

dcl  opnd fixed binary (18);				/* Operand offset */
dcl  star_extent bit (1) aligned;
dcl  p pointer;					/* Pointer to operand */
dcl  csize fixed binary (18);				/* Character length */

	p = addr (rands (opnd));

	csize = get_char_size (p);
	if csize < 0
	then do;

	     /* Constant length */

	     star_extent = "0"b;
	     return (csize + bias);
	     end;

	/* If the operand is not of constant length, but is a substring or
	   array reference whose parent is of constant length, return the
	   parent's length as the length for allocation. */

	if p -> node.node_type = array_ref_node
	then do;
	     csize = get_char_size (addr (rands (p -> array_ref.parent)));
	     if csize < 0
	     then do;
		star_extent = "0"b;
		return (csize + bias);
		end;
	     end;

	/* If the operand is a variable length temporary that is not of star
	   extent, use the allocated length of the temporary. */

	else if p -> node.node_type = temporary_node
	then if ^p -> temporary.stack_indirect
	     then do;
		star_extent = "0"b;
		return (p -> temporary.size * chars_per_word);
		end;

	/* The operand must have been of star extent. */

	star_extent = "1"b;
	return (0);

     end get_cat_alloc_length;

assign_length_to_cat_result:
     procedure (cat_result);

	/* Puts the proper length onto the temporary which is the result of
	   concatenation operator currently being compiled.  The length is
	   taken from the last operand of the cat_op. */

dcl  cat_result fixed binary (18);

dcl  (length, result) pointer;

	result = addr (rands (cat_result));
	length = addr (rands (stack (top)));

	if length -> node.operand_type = constant_type
	then do;

	     /* Length is constant, so put it right in the temporary */

	     result -> temporary.length = addr (length -> constant.value) -> int_image;
	     result -> temporary.variable_length = "0"b;
	     end;

	else do;

	     /* Length is not constant - chain it to the temporary */

	     result -> temporary.length = stack (top);
	     result -> temporary.variable_length = "1"b;
	     end;

     end assign_length_to_cat_result;

/**** DESCRIPTOR RELATED CODE ****/

get_param_char_size:
     procedure (sym, arg_no);

	/* This procedure generates code to extract the length of a
	   star extent character string from the argument list
	   descriptor and store it in the symbol.v_length variable
	   allocated by the parse.  Also, if the character string is
	   passed as an argument and requires a descriptor of its own,
	   code is generated to initialize the automatic descriptor
	   from the template in the text section and to fill in the
	   length field. */

dcl  (s, sym) pointer;
dcl  arg_no fixed binary (18);

dcl  desc fixed binary (18);
dcl  mask fixed binary (18);				/* mask off high bits of Q register */

	s = sym;
	desc = s -> symbol.hash_chain;

	/* If there is a descriptor template node, but it has not been
	   assigned storage, then it is only needed to build the entry
	   point definitions and we can ignore it. */

	if desc ^= 0
	then if ^addr (rands (desc)) -> symbol.allocated
	     then desc = 0;

	/* Initialize the automatic descriptor if array */

	if desc ^= 0 & s -> symbol.dimensioned
	then call copy_array_desc_template (s);

	/* Extract length from descriptor and store it in symbol.v_length */

	addr (rands (builtins (11))) -> symbol.location = 2 * arg_no - 2;
	call emit_single ((load_inst (in_q)), (builtins (11)));
	call emit_c_a (anq, descriptor_mask_addr);
	call emit_single ((store_inst (in_q)), (s -> symbol.v_length));

	/* Put length into automatic descriptor */

	if desc ^= 0
	then do;
	     mask = create_constant (int_mode, "777700000000"b3);
	     if s -> symbol.dimensioned
	     then do;
		call emit_single (orq, mask);
		call emit_single (anq, desc);
		call emit_single (stq, desc);
		end;

	     else do;

		/* Get type bits while we're at it */
		call emit_single (orq, mask);
		call emit_single (anq, (addr (rands (desc)) -> symbol.general));
		call emit_single ((store_inst (in_q)), desc);
		end;
	     end;

	call reset_eaq (Q);

     end get_param_char_size;

copy_array_desc_template:
     procedure (sym);

	/* Generates code to copy the descriptor template for an array
	   from the text into automatic storage. */

dcl  (s, sym) pointer;
dcl  desc fixed binary (18);

	s = sym;
	desc = s -> symbol.hash_chain;

	call push ((addr (rands (desc)) -> symbol.general));
	call push (desc);
	call interpreter_proc (move_eis, r3);
r3:
	return;

     end copy_array_desc_template;

make_descriptor:
     procedure (var) returns (fixed binary (18));

	/* Builds a descriptor for var, which must be either a temporary,
	   an array reference, or a symbol of constant extent (variable-
	   and star-extent symbols have been dealt with at storage
	   allocation time.)  If the temporary or arry_ref is a character
	   string of star extent, code is emitted to fill in the length
	   field of the descriptor. */

dcl  var fixed binary (18);				/* argument that needs a descriptor */
dcl  p pointer;
dcl  (desc, const, dt, csize) fixed binary (18);
dcl  v_length bit (1) aligned;

dcl  1 descriptor aligned,				/* Scalars only */
       2 type_word aligned,
         3 bit_type unaligned,
	 4 flag bit (1) unaligned,
	 4 type bit (6) unaligned,
	 4 packed bit (1) unaligned,
         3 number_dims fixed binary (3) unaligned,
         3 size fixed binary (23) unaligned;

	p = addr (rands (var));
	unspec (descriptor) = "0"b;
	v_length = "0"b;

	/* Handle symbols */

	if p -> node.node_type = symbol_node
	then if p -> symbol.hash_chain ^= 0
	     then return (p -> symbol.hash_chain);
	     else return (make_symbol_descriptor ((var)));

	/* Initialize the descriptor's type word */

	if p -> node.operand_type >= bif
	then unspec (descriptor.type_word) = unspec (descriptor_type_word (fptype, 7));
	else do;
	     dt = p -> node.data_type;
	     unspec (descriptor.type_word) = unspec (descriptor_type_word (fptype, dt));
	     if dt = char_mode
	     then do;
		if p -> node.units = char_units
		then descriptor.packed = "1"b;
		csize = get_char_size (p);
		if csize < 0
		then descriptor.size = csize + bias;
		else v_length = "1"b;
		end;
	     end;

	/* Create a constant node for the descriptor */

	const = create_constant (int_mode, unspec (descriptor.type_word));

	/* If the descriptor must be filled in at runtime, allocate a
	   temporary for it, and emit code to initialize it. */

	if v_length
	then do;
	     desc = assign_temp (int_mode);
	     if analyzing
	     then addr (rands (desc)) -> temporary.ref_count_copy = 131071;
	     else addr (rands (desc)) -> temporary.ref_count = 131071;
	     call load (get_char_size (p), in_q);
	     call emit_c_a (anq, descriptor_mask_addr);
	     call emit_single (orq, const);
	     call emit_single (store_inst (in_q), desc);
	     call reset_eaq (Q);

	     /* Chain this descriptor so that it can be freed after
	        the call has been compiled. */

	     addr (rands (desc)) -> temporary.next = desc_temp_chain;
	     desc_temp_chain = desc;
	     end;
	else desc = const;

	return (desc);

     end make_descriptor;

set_itp_addr:
     procedure (pt, pos);

	/* Sets one element of an ITP list to contain the
	   address of the operand pointed to by pt. */

dcl  (pt, p) pointer;
dcl  (pos, i) fixed binary (18);

	p = pt;
	i = pos;

	string (itp_list (i)) = "0"b;

	if p -> node.ext_base
	then do;
	     itp_list (i).pr_no = p -> node.base;
	     itp_list (i).itp_mod = ITP_mod;
	     itp_list (i).offset = bit (fixed (p -> node.address.offset, 18), 18);
	     itp_list (i).bit_offset = bit (fixed (p -> node.address.char_num * bits_per_char, 6), 6);

	     /* Fix bug344 - stack_indirect ITP needs RI (*n) indirect modification */

	     if p -> node.stack_indirect
	     then itp_list (i).mod = RI_mod;
	     end;
	else addr (itp_list (i)) -> ind_word = unspec (p -> node.address);

     end set_itp_addr;

check_arg_list:
     procedure ();

	/* Checks argument lists for consistency, using subprogram
	   definition if possible otherwise using the first invoction
	   of each subprogram as a model for checking.  If the call is
	   to an external (descriptors) procedure, consistency is not
	   checked, but assumed size arrays as arguments are diagnosed.
	   The stack looks like:

	   external reference
	   count
	   arg1
	   arg2
	   .
	   .
	   .
	   argn
	*/

dcl  (adesc, i) fixed binary (18);
dcl  (a, p, s) pointer;

	num_args = stack (base + 1) + bias;
	s = addr (rands (stack (base)));

	if s -> symbol.variable_arglist
	then do;

	     /* Must diagnose assumed size arrays as arguments */

	     do i = 1 to num_args;
		p = addr (rands (stack (base + i + 1)));
		if p -> node.node_type = symbol_node
		then if p -> symbol.dimensioned
		     then if addr (rands (p -> symbol.dimension)) -> dimension.assumed_size
			then call print_message (468, stack (base), stack (base + i + 1));
		end;
	     end;

	else do;
	     if s -> symbol.general = 0
	     then call find_arg_desc (s);
	     if s -> symbol.general = 0
	     then do;				/* couldn't find arg_desc node, probably an external procedure */

		/* first time, set up arg_desc structure */


		adesc, s -> symbol.general = create_node (arg_desc_node, size (arg_desc));
		a = addr (rands (adesc));
		a -> arg_desc.n_args = num_args;

		do i = 1 to num_args;
		     p = addr (rands (stack (base + i + 1)));
		     a -> arg_desc.data_type (i) = p -> node.data_type;
		     if p -> node.node_type = symbol_node
		     then if p -> symbol.dimensioned
			then do;
			     a -> arg_desc.must_be.array (i) = "1"b;
			     if p -> symbol.ext_attributes.VLA
			     then a -> arg_desc.must_be.VLA (i) = "1"b;
			     end;
			else a -> arg_desc.must_be.scalar (i) = "1"b;
		     else if p -> node.node_type ^= array_ref_node
		     then a -> arg_desc.must_be.scalar (i) = "1"b;
		     end;
		end;

	     else do;

		/* not the first time, compare args with arg_desc structure */

		a = addr (rands (s -> symbol.general));

		if num_args ^= a -> arg_desc.n_args
		then do;
		     call print_message (400, stack (base));
		     if num_args > a -> arg_desc.n_args
		     then num_args = a -> arg_desc.n_args;
		     end;

		do i = 1 to num_args;
		     p = addr (rands (stack (base + i + 1)));

		     /* When a program calls an internal subroutine with arguments
		        that are declared as different data types in the included
		        routine, it will raise an error except in the case of
		        passing a character constant. */

		     if (p -> node.node_type ^= char_constant_node)
		     then do;
			if (p -> node.data_type ^= a -> arg_desc.data_type (i))
			     &
			     ^(p -> node.node_type = temporary_node
			     & addr (rands (a -> arg_desc.arg (i).symbol)) -> symbol.external)
			then call bad_arg;

			else if p -> node.node_type = symbol_node
			then do;
			     if p -> symbol.dimensioned
			     then do;
				if a -> arg_desc.must_be.scalar (i)
				then call bad_arg;
				else if p -> symbol.ext_attributes.VLA
				then if ^a -> arg_desc.must_be.VLA (i)
				     then call bad_arg;
				end;
			     else if a -> arg_desc.must_be.array (i)
			     then call bad_arg;
			     end;
			else if p -> node.node_type ^= array_ref_node
			then if a -> arg_desc.must_be.array (i)
			     then call bad_arg;
			end;
		     end;
		end;
	     end;


bad_arg:
     procedure ();

	call print_message (401, stack (base + i + 1), stack (base));

     end bad_arg;

	/* This procedure finds an arg_desc node that corresponds to an entry node.
	   It looks up the entry node that corresponds to the actual declaration of
	   a subprogram (if one exists), and looks in its symbol.general field to
	   find its arg_desc node. It returns the location of the arg_desc node by
	   setting the referencing entry node's general field.  It also makes sure
	   that the arg_desc node contains the data_type associated with each
	   parameter. */
find_arg_desc:
     proc (sp);
dcl  (e, i, ii) fixed bin;
dcl  (sp, ap, ep, symp) ptr;

	/* find the entry node with the same name */
	e = shared_globals.first_entry_name;
	do while (addr (rands (e)) -> symbol.name ^= sp -> symbol.name & e ^= shared_globals.last_entry_name);
	     e = addr (rands (e)) -> symbol.next_symbol;
	     end;
	ep = addr (rands (e));

	if ep -> symbol.name ^= sp -> symbol.name
	then return;				/* couldn't find it */
	if ep -> symbol.general = 0
	then return;				/* no arg_desc node */

	sp -> symbol.general = ep -> symbol.general;

	/* make sure that the data_type fields are set.  If there are any * arguments
	   (indicated by there being no symbol node accociated with the argument), then
	   remove all of these args and place one * arg at the end of the list.  Set
	   its data_type to 1. */

	ap = addr (rands (ep -> symbol.general));
	ii = 1;
	do i = 1 to ap -> arg_desc.n_args;
	     if ap -> arg_desc.arg (i).symbol ^= 0
	     then do;
		ap -> arg_desc.arg (ii) = ap -> arg_desc.arg (i);
		if ap -> arg_desc.arg (ii).data_type = 0
		then do;
		     symp = addr (rands (ap -> arg_desc.arg (ii).symbol));
		     ap -> arg_desc.arg (ii).data_type = symp -> symbol.data_type;
		     if symp -> node.node_type = symbol_node
		     then if symp -> symbol.dimensioned
			then do;
			     ap -> arg_desc.arg (ii).must_be.array = "1"b;
			     if symp -> symbol.ext_attributes.VLA
			     then ap -> arg_desc.must_be.VLA (ii) = "1"b;
			     end;
			else ap -> arg_desc.arg (ii).must_be.scalar = "1"b;
		     else if symp -> node.node_type ^= array_ref_node
		     then ap -> arg_desc.arg (ii).must_be.scalar = "1"b;
		     end;
		ii = ii + 1;
		end;
	     end;
	if ii ^= i
	then do;

	     /* at least one asterisk arg was removed */

	     ap -> arg_desc.n_args = ii;
	     unspec (ap -> arg_desc.arg (ii)) = "0"b;
	     ap -> arg_desc.arg (ii).data_type = 1;
	     end;
     end find_arg_desc;

     end check_arg_list;

replace_inputs:
     procedure (old_input, new_input);

dcl  old_input fixed binary (18);			/* Existing temp */
dcl  new_input fixed binary (18);			/* Replacement */

dcl  (new, i) fixed binary (18);
dcl  input pointer;

	new = new_input;

	i = addr (rands (old_input)) -> temporary.start_input_to;
	if i = 0
	then return;

	do input = addr (polish (i)) repeat (input -> input_to.next) while (input ^= null ());
	     if input -> input_to.which > 0		/* Operand number */
	     then input -> input_to.operator -> operator.operand (input -> input_to.which) = new;
	     else if input -> input_to.which = 0	/* Output temp */
	     then input -> input_to.operator -> operator.output = new;
	     end;

     end replace_inputs;

/**** REGISTER USAGE ANALYSIS -- End of flow_unit, End of loop processing. ****/

reset_scan:
     procedure (cur_statement, statement_ptr, iquad, fu, cur_lp);

	/* Resets scanners at end of flow_unit.  May do end_of_loop processing. */

dcl  cur_statement fixed binary (18),			/* Current statement */
     statement_ptr pointer,				/* addr(quad(cur_statement)) */
     iquad fixed binary (18),				/* Next operator to be scanned */
     fu pointer,					/* flow_unit being processed */
     cur_lp pointer;				/* Loop being processed */

dcl  (next_lp, last_fu, next_stm) pointer;


	if fu -> flow_unit.next_in_loop ^= fu -> flow_unit.next
	then do;

	     /* We are either about to pass over flow_units from other
	        loops, or have processed the last flow_unit of this loop. */

	     if fu -> flow_unit.falls_through
	     then do;
		next_lp = fu -> flow_unit.next -> flow_unit.loop;

		if cur_lp -> loop.depth < next_lp -> loop.depth
		then call flush_state;
		else do;
		     next_stm = addr (quad (fu -> flow_unit.next -> flow_unit.first_statement));
		     if ^next_stm -> opt_statement.referenced_backwards
			& ^next_stm -> opt_statement.referenced_by_assign
		     then call save_state (get_label (next_stm));
		     call discard_state;
		     end;
		end;
	     end;

	if fu -> flow_unit.next_in_loop ^= null
	then do;

	     /* We have another flow_unit in this loop,
	        so initialize for the next flow_unit. */

	     last_fu = fu;
	     fu = fu -> flow_unit.next_in_loop;

	     if last_fu ^= fu -> flow_unit.back
	     then do;

		/* We have passed over flow_units from other loops. */

		if ^fu -> flow_unit.back -> flow_unit.falls_through
		then call discard_state;
		else if ^state_discarded
		then if next_lp ^= fu -> flow_unit.back -> flow_unit.loop
		     then call discard_state;
		end;
	     end;

	else do;

	     /* We've finished this loop. */

	     call allocate_registers;

	     string (cur_lp -> loop.father -> loop.erases) =
		string (cur_lp -> loop.father -> loop.erases) | string (cur_lp -> loop.erases);
	     string (cur_lp -> loop.father -> loop.avoid_pr) =
		string (cur_lp -> loop.father -> loop.avoid_pr) | string (cur_lp -> loop.avoid_pr);

	     call reset_global_data;

	     do i_loop = i_loop + 1 to n_loops - 1 while (loop_vector (i_loop) -> loop.members = null);
		end;

	     if i_loop >= n_loops
	     then do;
		iquad = cs -> subprogram.last_quad;
		return;
		end;

	     cur_lp = loop_vector (i_loop);
	     fu = cur_lp -> loop.members;
	     call discard_state;
	     end;

	cur_statement = fu -> flow_unit.first_statement;
	statement_ptr = addr (quad (cur_statement));
	iquad = statement_ptr -> opt_statement.first_operator;

     end reset_scan;

get_label:
     procedure (st) returns (fixed binary (18));

	/* Returns label attached to a statement.  Creates, if not found. */

dcl  st pointer;

dcl  lbl fixed binary (18);

	lbl = st -> opt_statement.label;

	if lbl = 0
	then do;
	     lbl, st -> opt_statement.label = create_rel_constant (cs);
	     addr (rands (lbl)) -> label.statement = fixed (rel (st), 18);
	     end;

	return (lbl);

     end get_label;

reset_global_data:
     procedure ();

	/* Resets info in ptr_data and index_data */

dcl  p pointer;

	ptr_data.local, ptr_data.max_local, ptr_data.locked, ptr_data.max_locked = 0;

	do while (ptr_data.n_global > 0);
	     p = ptr_data.item (ptr_data.n_global);
	     p -> pointer.count = 0;
	     ptr_data.n_global = ptr_data.n_global - 1;
	     end;

	index_data.local, index_data.max_local, index_data.locked, index_data.max_locked = 0;

	do while (index_data.n_global > 0);
	     p = index_data.item (index_data.n_global);
	     p -> node.loop_ref_count = 0;
	     index_data.n_global = index_data.n_global - 1;
	     end;

     end reset_global_data;

/**** GLOBAL REGISTER ALLOCATION ****/

allocate_registers:
     procedure ();

dcl  p pointer;
dcl  (i, n_allocated) fixed binary;

	/* Sort the global register items. */

	call sort_globals (ptr_data.item_st, ptr_data.n_global, BASE);
	call sort_globals (index_data.item_st, index_data.n_global, INDEX);

	/* Initialize the regs_used fields. */

	cur_lp -> loop.xregs_used =
	     max (index_data.max_local, index_data.max_locked, fixed (index_data.n_global > avail_xregs, 1));
	cur_lp -> loop.pregs_used =
	     max (ptr_data.max_local, ptr_data.max_locked, fixed (ptr_data.n_global > avail_pregs, 1));

	/* Process the globals in descending order. */

	do i = 1 to ptr_data.n_global while (cur_lp -> loop.pregs_used < avail_pregs);
	     p = ptr_data.item (i);
	     if ok_to_allocate (p, cur_lp, BASE)
	     then do;
		call allocate (p, cur_lp, BASE);
		cur_lp -> loop.pregs_used = cur_lp -> loop.pregs_used + 1;
		end;
	     end;

	n_allocated = 0;

	do i = 1 to index_data.n_global while (cur_lp -> loop.xregs_used < avail_xregs);
	     p = index_data.item (i);
	     if ok_to_allocate (p, cur_lp, INDEX)
	     then do;
		call allocate (p, cur_lp, INDEX);
		cur_lp -> loop.xregs_used = cur_lp -> loop.xregs_used + 1;
		n_allocated = n_allocated + 1;
		end;
	     end;

	if n_allocated = avail_xregs
	then cur_lp -> loop.all_xrs_globally_assigned = "1"b;

	return;

sort_globals:
     procedure (item_st, n_items, p_reg_type);

	/* Sorts global items in descending order by count of uses in the loop. */

dcl  1 item_st like ptr_data.item_st aligned;
dcl  n_items fixed binary;
dcl  (reg_type, p_reg_type) fixed binary;		/* INDEX, BASE */

dcl  (d, i, j, k) fixed binary;
dcl  (p1, p2, p) pointer;

	reg_type = p_reg_type;

	d = n_items;

	do while (d > 1);
	     d = 2 * divide (d, 4, 17, 0) + 1;

	     do i = 1 to n_items - d;
		k = i + d;
		p2 = item (k);
up:
		j = k - d;
		p1 = item (j);

		if less_than (p1, p2, reg_type)
		then do;
		     p = item (j);
		     item (j) = item (k);
		     item (k) = p;

		     if j > d
		     then do;
			k = j;
			go to up;
			end;
		     end;
		end;
	     end;

	return;

less_than:
     procedure (p1, p2, reg_type) returns (bit (1) aligned);

dcl  (p1, p2) pointer;
dcl  reg_type fixed binary;				/* INDEX, BASE */

	if reg_type = INDEX
	then return (p1 -> node.loop_ref_count < p2 -> node.loop_ref_count);
	else return (p1 -> pointer.count < p2 -> pointer.count);

     end less_than;

     end sort_globals;

ok_to_allocate:
     procedure (pt, p_adam, p_reg_type) returns (bit (1) aligned);

	/* Determines if it is ok to allocate a global item across inner loops. */

dcl  (p, pt) pointer,				/* -> global item */
     (adam, p_adam) pointer,				/* -> loop */
     (reg_type, p_reg_type) fixed binary;		/* INDEX, BASE */

dcl  lp pointer;

	adam = p_adam;

	if adam -> loop.son = null
	then return ("1"b);

	p = pt;
	reg_type = p_reg_type;

	/* Simulate a recursive walk across the loop nest. */

	lp = adam -> loop.son;

	do while ("1"b);
	     if reg_type = INDEX
	     then if ^ok ((lp -> loop.xregs_used), avail_xregs, (lp -> loop.global_xr_items))
		then return ("0"b);
		else ;
	     else if ^ok ((lp -> loop.pregs_used), avail_pregs, (lp -> loop.global_pr_items))
	     then return ("0"b);

	     if lp -> loop.son ^= null
	     then lp = lp -> loop.son;

	     else do;
		do while (lp -> loop.brother = null);
		     lp = lp -> loop.father;
		     if lp = adam
		     then return ("1"b);
		     end;

		lp = lp -> loop.brother;
		end;
	     end;

	stop;

ok:
     procedure (regs_used, avail_regs, item_chain) returns (bit (1) aligned);

dcl  regs_used fixed binary (4),
     avail_regs fixed binary (4),
     item_chain pointer;

dcl  c pointer;
dcl  found bit (1) aligned;

	if regs_used >= avail_regs
	then do;
	     found = "0"b;
	     do c = item_chain repeat c -> chain.next while (^found & c ^= null);
		if p = c -> chain.value
		then found = "1"b;
		end;

	     if ^found
	     then return ("0"b);
	     end;

	return ("1"b);

     end ok;

     end ok_to_allocate;

allocate:
     procedure (pt, p_adam, p_reg_type);

	/* Allocate a global item across a loop next. */

dcl  (p, pt) pointer,				/* -> global item */
     (adam, p_adam) pointer,				/* -> loop */
     (reg_type, p_reg_type) fixed binary;		/* INDEX, BASE */

dcl  (opnd, new_opnd) fixed binary (18);

dcl  (bt, c, list_head, lp) pointer;
dcl  (op, op_code) fixed binary (18);
dcl  n fixed binary;

	p = pt;
	adam = p_adam;
	reg_type = p_reg_type;
	bt = adam -> loop.back_target;
	opnd = fixed (rel (p), 18);

	/* First, allocate in adam. */

	c = create_chain ();
	c -> chain.value = p;

	if reg_type = INDEX
	then do;
	     n = 2;
	     c -> chain.next = adam -> loop.global_xr_items;
	     adam -> loop.global_xr_items = c;
	     op_code = load_xreg_op;
	     call check_comparisons_and_increments (opnd, adam);
	     call propagate_and_eliminate_assignment (opnd, adam, new_opnd);
	     end;

	else do;
	     n = 1;
	     c -> chain.next = adam -> loop.global_pr_items;
	     adam -> loop.global_pr_items = c;
	     op_code = load_preg_op;
	     end;

	op, bt -> flow_unit.insert_operator = insert_operator_after (op_code, n, (bt -> flow_unit.insert_operator));
	call connect_expression (opnd, op, 1);

	if n = 2
	then call connect_expression (new_opnd, op, 2);

	/* Now, allocate in inner loops. */

	if adam -> loop.son ^= null
	then do;
	     lp = adam -> loop.son;

	     do while ("1"b);
		if reg_type = INDEX
		then do;
		     list_head = lp -> loop.global_xr_items;
		     call alloc_inner (list_head, lp -> loop.xregs_used, n);
		     lp -> loop.global_xr_items = list_head;
		     if n = avail_xregs
		     then lp -> loop.all_xrs_globally_assigned = "1"b;
		     end;
		else do;
		     list_head = lp -> loop.global_pr_items;
		     call alloc_inner (list_head, lp -> loop.pregs_used, n);
		     lp -> loop.global_pr_items = list_head;
		     end;

		if lp -> loop.son ^= null
		then lp = lp -> loop.son;

		else do;
		     do while (lp -> loop.brother = null);
			lp = lp -> loop.father;
			if lp = adam
			then return;
			end;

		     lp = lp -> loop.brother;
		     end;
		end;
	     end;

	return;

alloc_inner:
     procedure (list_head, regs_used, n_allocated);

dcl  list_head pointer,
     regs_used fixed binary (4),
     n_allocated fixed binary;			/* (output) */

dcl  c pointer;

	n_allocated = 1;

	do c = list_head repeat c -> chain.next while (c ^= null);
	     if c -> chain.value = p
	     then return;
	     n_allocated = n_allocated + 1;
	     end;

	regs_used = regs_used + 1;
	c = create_chain ();
	c -> chain.value = p;
	c -> chain.next = list_head;
	list_head = c;

     end alloc_inner;

     end allocate;

check_comparisons_and_increments:
     procedure (p_opnd, p_cur_lp);

	/* If opnd is an induction variable, we check to see if it is compared
	   against a non_constant.  If it is, that non_constant must be left
	   shifted 18 for the comparison. */

dcl  (opnd, p_opnd) fixed binary (18),			/* Induction variable? */
     (cur_lp, p_cur_lp) pointer;			/* -> current loop */

dcl  (bt, c, non_const_p, lp, o, outp, p, lsc, lsp, t, stp) pointer;
dcl  (i_non_const, non_constant, ls_op) fixed binary (18);
dcl  i fixed binary;
dcl  found bit (1) aligned;


	cur_lp = p_cur_lp;
	opnd = p_opnd;
	p = addr (rands (opnd));

	if p -> node.node_type = symbol_node
	then if p -> symbol.coordinate > 0
	     then if substr (cur_lp -> loop.induction_var -> bits, p -> symbol.coordinate, 1)
		then do c = cur_lp -> loop.eligible_ind_var_op_var repeat c -> chain.next while (c ^= null);
			o = c -> chain.value;

			found = "0"b;

			if o -> operator.op_code = storage_add_op | o -> operator.op_code = neg_storage_add_op
			then if o -> operator.output = opnd
			     then do;
				found = "1"b;
				i_non_const = 1;
				end;
			     else ;

			else do;
			     do i = 1 to 2 while (o -> operator.operand (i) ^= opnd);
				end;

			     if i <= 2
			     then do;
				found = "1"b;
				i_non_const = 3 - i;
				end;
			     end;

			if found
			then do;

			     /* Found such a comparison, now find the outermost loop in
			        which the non_constant is invariant. */

			     non_constant = o -> operator.operand (i_non_const);

			     do lp = cur_lp repeat lp -> loop.father
				while (lp -> loop.father -> loop.back_target ^= null
				& is_invariant_in (non_constant, (lp -> loop.father)));
				end;

			     bt = lp -> loop.back_target;

			     /* Now find out if there is already a left shift of the
			        non_constant to be commoned. */

			     found = "0"b;
			     lsc = lp -> loop.left_shift_chain;
			     do while (^found & lsc ^= null);
				if lsc -> chain.value -> operator.operand (1) = non_constant
				then found = "1"b;
				else lsc = lsc -> chain.next;
				end;

			     if ^found
			     then do;

				/* We must create a left_shift of the non_constant . */

				ls_op, bt -> flow_unit.insert_operator =
				     insert_operator_after (mult_op, 2, (bt -> flow_unit.insert_operator));
				lsp = addr (quad (ls_op));

				call connect_expression (non_constant, ls_op, 1);
				lsp -> operator.operand (2) = create_integer_constant (262144);
				lsp -> operator.output = create_integer_temporary (ls_op);

				/* Stick in loop_end list. */

				call put_in_loop_end (addr (rands (lsp -> operator.output)), lp);

				if ^bt -> flow_unit.falls_through
				then do;

				     /* The back target ends with a jump_op.  The
				        target of the jump is the first statement
				        in the loop entry unit.  Add the left shift
				        to the operator list of that statement, to
				        ensure that the shifted value is stored
				        before the loop is entered. */

				     stp = addr (quad (lp -> loop.entry_unit -> flow_unit.first_statement));

				     t = get_opt_space (size (primary));
				     t -> primary.last = null ();
				     t -> primary.next = stp -> opt_statement.operator_list;
				     stp -> opt_statement.operator_list = t;

				     if t -> primary.next ^= null ()
				     then t -> primary.next -> primary.last = t;
				     else stp -> opt_statement.has_operator_list = "1"b;

				     t -> primary.expression = lsp;
				     t -> primary.flow_unit = bt;
				     end;

				/* Stick in left_shift chain. */

				lsc = create_chain ();
				lsc -> chain.value = lsp;
				lsc -> chain.next = lp -> loop.left_shift_chain;
				lp -> loop.left_shift_chain = lsc;
				end;

			     else lsp = lsc -> chain.value;

			     /* Now replace the non_constant. */

			     non_const_p = addr (rands (non_constant));
			     if non_const_p -> node.node_type = temporary_node
			     then do;
				call disconnect_temporary (non_const_p, o);

				/* make up for the fact that we already have scanned
				   non_const_p, but won't during CG */

				non_const_p -> temporary.ref_count_copy =
				     non_const_p -> temporary.ref_count_copy + 1;
				end;

			     call connect_expression ((lsp -> operator.output), fixed (rel (o), 18), i_non_const);

			     /* since we won't scan operator.output in this loop,
			        decrement its ref_count, accordingly */

			     outp = addr (rands (lsp -> operator.output));
			     outp -> temporary.ref_count_copy = outp -> temporary.ref_count_copy - 1;
			     end;
			end;

     end check_comparisons_and_increments;

propagate_and_eliminate_assignment:
     procedure (p_opnd, p_lp, new_opnd);

	/* If opnd is assigned a constant or symbol value in lp's back target,
	   we attempt to remove the assignment and return the value in new_opnd
	   for loading into an xreg. */

dcl  (p_opnd, opnd) fixed binary (18),			/* operand to be loaded into an xreg */
     (p_lp, lp) pointer,				/* -> loop node */
     new_opnd fixed binary (18);			/* operand to actually be loaded */

dcl  (bt, inp, o, p) pointer;
dcl  (c, first_stm, i, op) fixed binary (18);
dcl  in_common bit (1) aligned;

	lp = p_lp;
	bt = lp -> loop.back_target;
	opnd = p_opnd;
	new_opnd = opnd;
	p = addr (rands (opnd));

	if p -> node.node_type = symbol_node
	then do;
	     c = p -> symbol.coordinate;

	     if ^substr (lp -> loop.busy_on_exit -> bits, c, 1) & substr (lp -> loop.induction_var -> bits, c, 1)
		& substr (bt -> flow_unit.set -> bits, c, 1)
	     then do;
		in_common = p -> symbol.in_common;

		/* loop backwards through operators looking for uses and sets */

		first_stm = bt -> flow_unit.first_statement;

		do op = bt -> flow_unit.insert_operator repeat o -> operator.back while (op ^= first_stm);
		     o = addr (quad (op));

		     /* special handling for namelist and common */

		     if o -> operator.op_code = read_namelist_op | o -> operator.op_code = write_namelist_op
		     then if in_namelist (o, opnd)
			then return;
			else ;
		     else if in_common
		     then if o -> operator.op_code = func_ref_op | o -> operator.op_code = call_op
			then return;

		     /* look for uses */

		     do i = 1 to o -> operator.number;
			if o -> operator.operand (i) = opnd
			then return;
			end;

		     /* look for set */

		     if o -> operator.output = opnd
		     then do;
			if o -> operator.op_code = assign_op
			then do;
			     inp = addr (rands (o -> operator.operand (1)));
			     if inp -> node.node_type = constant_node
			     then call eliminate ();
			     else if inp -> node.node_type = symbol_node
			     then do;

				/* If the input symbol might be set later in the flow unit,
				   this assignment cannot be eliminated because the
				   RHS may not be the correct value when the loop
				   is entered. */

				if inp -> symbol.aliasable
				then return;	/* Punt */

				if substr (bt -> flow_unit.set -> bits, inp -> symbol.coordinate, 1)
				then return;

				call eliminate ();
				end;
			     end;
			return;
			end;
		     end;
		end;
	     end;

eliminate:
     procedure ();

	/* This procedure does the actual elimination of assignments for
	   propagate_and_eliminate_assignment. */

	if op = bt -> flow_unit.insert_operator
	then bt -> flow_unit.insert_operator = o -> operator.back;

	new_opnd = o -> operator.operand (1);

	call unthread (o);

	if ^substr (bt -> flow_unit.set_multiple -> bits, c, 1)
	then substr (bt -> flow_unit.set -> bits, c, 1) = "0"b;

     end eliminate;

     end propagate_and_eliminate_assignment;

     end allocate_registers;

insert_operator_after:
     procedure (op_code, number, last_operator) returns (fixed binary (18));

dcl  op_code fixed binary (18),
     number fixed binary,
     last_operator fixed binary (18);

dcl  (o, next_o, last_o) pointer;
dcl  op fixed binary (18);

	/* Allocate the space. */

	n_operands = number;
	op = get_quad_space (size (operator));
	o = addr (quad (op));

	/* Initialize the space. */

	o -> operator.op_code = op_code;
	o -> operator.number = n_operands;
	o -> operator.assigns_constant_to_symbol, o -> operator.freed = "0"b;
	o -> operator.primary = null;

	/* Insert the operator. */

	last_o = addr (quad (last_operator));
	next_o = addr (quad (last_o -> operator.next));
	o -> operator.next = last_o -> operator.next;
	o -> operator.back = last_operator;
	last_o -> operator.next = op;
	next_o -> operator.back = op;

	return (op);

     end insert_operator_after;

create_integer_temporary:
     procedure (op) returns (fixed binary (18));

dcl  op fixed binary (18);				/* Operator producing the temp */

dcl  t pointer;
dcl  temp fixed binary (18);

	temp = get_temp_node ();
	t = addr (rands (temp));

	t -> temporary.data_type = int_mode;
	t -> temporary.operand_type = temp_type;
	t -> temporary.size = 1;
	t -> temporary.output_by = op;
	t -> temporary.not_in_storage = "1"b;

	return (temp);

     end create_integer_temporary;

is_invariant_in:
     procedure (opnd, lp) reducible returns (bit (1) aligned);

dcl  opnd fixed binary (18),				/* Operand which might be invariant */
     lp pointer;					/* -> loop in which invariance is tested */

dcl  (o, p) pointer;

	p = addr (rands (opnd));

	if p -> node.node_type = symbol_node
	then if p -> symbol.coordinate > 0
	     then return (^substr (lp -> loop.set -> bits, p -> symbol.coordinate, 1));
	     else ;

	else if p -> node.node_type = temporary_node
	then if lp -> loop.computed ^= null
	     then do;
		o = addr (quad (p -> temporary.output_by));
		if o -> operator.coordinate > 0
		then return (^substr (lp -> loop.computed -> obits, o -> operator.coordinate, 1));
		end;
	     else ;

	else if p -> node.node_type = constant_node
	then return ("1"b);

	return ("0"b);

     end is_invariant_in;

process_loop_end_lists:
     procedure ();

	/* Turns the loop_end lists of the various loops into operators and operands. */

dcl  (i, j) fixed binary;
dcl  (op, last_operator, next_statement) fixed binary (18);
dcl  (c, fu, last_c, o) pointer;

	do i = 1 to n_loops - 1;
	     fu = loop_vector (i) -> loop.last_unit;
	     if fu -> flow_unit.n_in_loop_end > 0
	     then do;
		next_statement = fixed (addr (quad (fu -> flow_unit.last_statement)) -> opt_statement.next, 18);
		last_operator = addr (quad (next_statement)) -> opt_statement.prev_operator;
		op = insert_operator_after (loop_end_op, (fu -> flow_unit.n_in_loop_end), last_operator);
		o = addr (quad (op));

		j = 0;
		do c = fu -> flow_unit.loop_end_chain repeat c -> lchain.next while (c ^= null);
		     j = j + 1;
		     last_c = c;
		     o -> operator.operand (j) = c -> lchain.value;
		     end;

		last_c -> lchain.next = free (size (lchain));
		free (size (lchain)) = fu -> flow_unit.loop_end_chain;
		fu -> flow_unit.loop_end_chain = null;
		fu -> flow_unit.n_in_loop_end = 0;
		end;
	     end;

     end process_loop_end_lists;

%include fort_opt_utilities;

/**** FLD BUILTIN CODE ****/
signal_error:
     procedure ();

	/* Aborts from an FLD builtin error */

	imac = fixed (rel (addr (fort_opt_macros_$abort_list)), 18);
	go to loop;

     end signal_error;

one_word_dt:
     procedure (opnd) returns (bit (1));

	/*  Returns true if "opnd" has a data type that takes up exactly one word
	   of aligned storage. */

dcl  opnd fixed bin (18);
dcl  p pointer;

	p = addr (rands (opnd));
	if (p -> node.data_type = int_mode) | (p -> node.data_type = real_mode) | (p -> node.data_type = typeless_mode)
	then return ("1"b);
	else if (p -> node.data_type = char_mode)
	then if (p -> node.node_type = symbol_node)
	     then return (p -> symbol.char_size = 3 & ^p -> symbol.aliasable);
	     else if (p -> node.node_type = char_constant_node)
	     then return (p -> char_constant.length = 4);
	     else return ("0"b);
	else return ("0"b);
     end one_word_dt;

generate_mask:
     procedure (start, len) returns (fixed bin (18));

	/* Creates an integer constant mask */

dcl  (start, len) fixed bin (18);
dcl  mask fixed bin (35);

	mask = 0;
	substr (unspec (mask), start + 1, len) = "111111111111111111111111111111111111"b;

	return (create_integer_constant (mask));
     end generate_mask;

rhs_fld:
     procedure;

	/* emits the code for the case of the fld intrinsic on the right hand
	   side of an assignement statement.  The code is emitted manually as the macros are
	   are not general enough to allow computed bit masks.  */

dcl  shift fixed bin;
dcl  (arg1, arg2, arg3, start, len) fixed bin (18);
dcl  (found_error, arg1_is_const, arg2_is_const) bit (1) init ("0"b);

	arg1 = stack (get_operand (5));
	if addr (rands (arg1)) -> node.data_type ^= int_mode
	then do;
	     call print_message (359, arg1);
	     found_error = "1"b;
	     end;
	arg2 = stack (get_operand (6));
	if addr (rands (arg2)) -> node.data_type ^= int_mode
	then do;
	     call print_message (359, arg2);
	     found_error = "1"b;
	     end;
	arg3 = stack (get_operand (7));
	if ^one_word_dt (arg3)
	then do;
	     call print_message (360, arg3);
	     found_error = "1"b;
	     end;
	if found_error
	then call signal_error;

	if addr (rands (arg2)) -> node.node_type = constant_node
	then do;
	     arg2_is_const = "1"b;
	     len = addr (addr (rands (arg2)) -> constant.value) -> based_integer;
	     if len < 1 | len > 36
	     then call print_message (364);
	     if len = 0
	     then do;
		call load (create_integer_constant (0), in_tq);
		return;
		end;
	     end;
	if addr (rands (arg1)) -> node.node_type = constant_node
	then do;
	     arg1_is_const = "1"b;
	     start = addr (addr (rands (arg1)) -> constant.value) -> based_integer;
	     if start < 0 | start > 35
	     then call print_message (363);
	     end;

	if arg1_is_const & arg2_is_const
	then do;
	     start = min (max (start, 0), 35);
	     len = min (max (len, 0), 36 - start);
	     shift = 36 - (start + len);

	     call load (arg3, in_tq);

	     if start = 0
	     then do;
		if len = 36
		then return;
		call emit_single (qrl, shift - bias);
		end;

	     else if shift = 0
	     then call emit_single (anq, generate_mask (start, len));

	     else do;
		call emit_single (qls, start - bias);
		call emit_single (qrl, (36 - len) - bias);
		end;
	     call reset_eaq (Q);
	     return;
	     end;
	else do;
	     call load (arg3, in_tq);

	     if arg1_is_const
	     then do;
		if start ^= 0
		then call emit_single (qls, start - bias);
		call emit_single (lca, arg2);
		call emit_with_tag (qrl, 36, AL_mod);
		call reset_eaq (A);
		end;
	     else if arg2_is_const
	     then do;
		call load (arg1, in_ia);
		call emit_with_tag (qls, 0, AL_mod);
		call emit_single (qrl, (36 - len) - bias);
		end;
	     else do;
		call load (arg1, in_ia);
		call emit_with_tag (qls, 0, AL_mod);
		call emit_single (lca, arg2);
		call emit_with_tag (qrl, 36, AL_mod);
		call reset_eaq (A);
		end;
	     call reset_eaq (Q);
	     return;
	     end;
	return;
     end rhs_fld;

lhs_fld:
     procedure;

	/*  emits the code for the case of the fld intrinsic on the left hand side
	   of an assignment statement.  The code is emitted manually as the macros
	   are not general enough to allow certain optimizations (such as bit
	   masks. */

dcl  shift fixed bin;
dcl  RHS fixed bin (35);
dcl  (arg1, arg2, arg3, arg4, start, len) fixed bin (18);
dcl  (found_error, arg1_is_const, arg2_is_const) bit (1) init ("0"b);
dcl  copy builtin;

	arg1 = stack (get_operand (1));
	if addr (rands (arg1)) -> node.data_type ^= int_mode
	then do;
	     call print_message (359, arg1);
	     found_error = "1"b;
	     end;
	arg2 = stack (get_operand (2));
	if addr (rands (arg2)) -> node.data_type ^= int_mode
	then do;
	     call print_message (359, arg2);
	     found_error = "1"b;
	     end;
	arg3 = stack (get_operand (3));
	if ^one_word_dt (arg3)
	then do;
	     call print_message (360, arg3);
	     found_error = "1"b;
	     end;
	arg4 = stack (get_operand (4));
	if ^one_word_dt (arg4)
	then do;
	     call print_message (361);
	     found_error = "1"b;
	     end;
	if found_error
	then call signal_error;

	if addr (rands (arg2)) -> node.node_type = constant_node
	then do;
	     arg2_is_const = "1"b;
	     len = addr (addr (rands (arg2)) -> constant.value) -> based_integer;
	     if len < 1 | len > 36
	     then call print_message (364);
	     if len = 0
	     then return;
	     end;
	if addr (rands (arg1)) -> node.node_type = constant_node
	then do;
	     arg1_is_const = "1"b;
	     start = addr (addr (rands (arg1)) -> constant.value) -> based_integer;
	     if start < 0 | start > 35
	     then call print_message (363);
	     end;

	if arg1_is_const & arg2_is_const
	then do;
	     start = min (max (start, 0), 35);
	     len = min (max (len, 0), 36 - start);

	     if start = 0 & len = 36
	     then do;
		call load (arg4, in_tq);
		call store (arg3, in_tq, 0);
		return;
		end;

	     if addr (rands (arg4)) -> node.node_type = constant_node
	     then do;
		unspec (RHS) =
		     copy ("0"b, start) || substr (addr (rands (arg4)) -> constant.value, 36 - len + 1, len);
		call load (create_integer_constant (RHS), in_tq);
		end;
	     else do;
		call load (arg4, in_tq);
		shift = 36 - start - len;
		if shift > 0
		then call emit_single (qls, shift - bias);
		end;

	     /* increment the count as it is automatically decremented by emit_single */
	     call drop_count (arg3, -1);
	     call emit_single (erq, arg3);
	     call emit_single (anq, generate_mask (start, len));
	     call emit_single (ersq, arg3);
	     call reset_eaq (Q);
	     end;

	else if arg1_is_const
	then do;
	     call use_eaq (0, EAQ, 0);
	     call reserve_regs (("1"b));

	     call emit_single (lxl0, arg2);

	     /* increment the count as it is automatically decremented by emit_single */
	     call drop_count (arg3, -1);
	     call emit_single (load_inst (in_ia), arg3);
	     call emit_with_tag (alr, start, X0_mod);
	     call emit_single (era, arg4);
	     call emit_with_tag (load_inst (in_iq), 0, DL_mod);
	     call emit_with_tag (lrs, 0, X0_mod);
	     if start ^= 0
	     then call emit_single (qrl, start - bias);
	     call emit_single (ersq, arg3);
	     end;

	else if arg2_is_const
	then do;
	     call use_eaq (0, EAQ, 0);
	     call reserve_regs (("1"b));

	     call emit_single (lxl0, arg1);

	     /* increment the count as it is automatically decremented by emit_single */
	     call drop_count (arg3, -1);
	     call emit_single (load_inst (in_ia), arg3);
	     call emit_with_tag (alr, len, X0_mod);
	     call emit_single (era, arg4);
	     call emit_with_tag (load_inst (in_iq), 0, DL_mod);
	     call emit_single (lrs, len - bias);
	     call emit_with_tag (qrl, 0, X0_mod);
	     call emit_single (ersq, arg3);
	     end;

	else do;
	     call use_eaq (0, EAQ, 0);
	     call reserve_regs (("11"b));

	     call emit_single (lxl0, arg1);
	     call emit_single (lxl1, arg2);

	     /* increment the count as it is automatically decremented by emit_single */
	     call drop_count (arg3, -1);
	     call emit_single (load_inst (in_ia), arg3);
	     call emit_with_tag (alr, 0, X0_mod);
	     call emit_with_tag (alr, 0, X1_mod);
	     call emit_single (era, arg4);
	     call emit_with_tag (load_inst (in_iq), 0, DL_mod);
	     call emit_with_tag (lrs, 0, X1_mod);
	     call emit_with_tag (qrl, 0, X0_mod);
	     call emit_single (ersq, arg3);
	     end;
	return;
     end lhs_fld;

start_subprogram:
     procedure ();

	/* Initializes global variables for a subprogram.  Most references
	   are nonlocal. */

dcl  i fixed binary;
dcl  (last, temp) fixed binary (18);

	cur_lp, fu, lp_msp = null;

	cs = addr (rands (cur_subprogram));
	call get_subr_options (cs);

	loop_vector_p = cs -> subprogram.loop_vector_p;
	n_loops = cs -> subprogram.n_loops;
	max_sym = cs -> subprogram.max_sym;
	max_operators = cs -> subprogram.max_operators;

	if analyzing
	then do;
	     do i_loop = 1 to n_loops - 1 while (loop_vector (i_loop) -> loop.members = null);
		end;

	     if i_loop >= n_loops
	     then iquad = cs -> subprogram.last_quad;

	     else do;
		iquad = loop_vector (i_loop) -> loop.members -> flow_unit.first_statement;

		/* refresh flow_unit.insert_operator for all back targets */

		do i = 1 to n_loops - 1;
		     if loop_vector (i) -> loop.members ^= null
		     then call derive_insert_for_bt ((loop_vector (i) -> loop.back_target));
		     end;
		end;
	     end;

	else iquad = cs -> subprogram.first_quad;

	if cs -> subprogram.subprogram_type ^= main_program
	then do;
	     last_auto_loc = last_auto_loc + mod (last_auto_loc, 2);
	     cs -> subprogram.entry_info = last_auto_loc;
	     call set_address_offset (addr (rands (builtins (8))), last_auto_loc, entry_info_size, word_units);
	     last_auto_loc = last_auto_loc + entry_info_size;

	     if last_auto_loc > max_stack_size
	     then call print_message (414,
		     "making subroutine entry for " || addr (rands (cs -> subprogram.symbol)) -> symbol.name
		     || " has exceeded the stack frame", max_stack_size - bias);
	     end;

	do i = 1 to 3;
	     if free_temps (i) ^= 0
	     then do;
		do temp = free_temps (i) repeat addr (rands (temp)) -> temporary.next while (temp ^= 0);
		     last = temp;
		     end;

		addr (rands (last)) -> temporary.next = next_free_temp;
		next_free_temp = free_temps (i);
		free_temps (i) = 0;
		end;
	     end;
     end start_subprogram;

reset_subprogram:
     procedure ();

	/* This resets the address, not_in_storage, and value_in fields of all
	   temps produced in all loops, and it resets statement nodes
	   throughout the program. */

dcl  (lp, fu, stm, o, outp) pointer;
dcl  (next_unit_statement, next_statement, op) fixed binary (18);
dcl  i fixed binary;

	call discard_state;
	state_discarded = "0"b;			/* To make merge_state CHEAP! */

	do i = 1 to n_loops;
	     lp = loop_vector (i);

	     do fu = lp -> loop.members repeat fu -> flow_unit.next_in_loop while (fu ^= null);
		if fu -> flow_unit.next ^= null
		then next_unit_statement = fu -> flow_unit.next -> flow_unit.first_statement;
		else next_unit_statement = 0;

		if fu -> flow_unit.first_statement ^= 0
		then do cur_statement = fu -> flow_unit.first_statement repeat next_statement
			while (cur_statement ^= next_unit_statement);
			stm = addr (quad (cur_statement));
			next_statement = fixed (stm -> opt_statement.next, 18);

			if stm -> opt_statement.machine_state ^= 0
			then call free_machine_state (stm);

			do op = stm -> opt_statement.first_operator repeat o -> operator.next
			     while (op ^= next_statement);
			     o = addr (quad (op));
			     if o -> operator.output > 0
			     then do;
				outp = addr (rands (o -> operator.output));
				if outp -> node.node_type = temporary_node
				then do;
				     unspec (outp -> temporary.address) = "0"b;
				     outp -> temporary.not_in_storage = "1"b;
				     outp -> temporary.ref_count_copy = 0;
				     end;
				end;
			     end;
			end;
		end;
	     end;

	state_discarded = "1"b;

	return;

free_machine_state:
     procedure (stm);

dcl  stm pointer;

	call merge_state (current_ms, addr (rands (stm -> opt_statement.machine_state)) -> machine_state, "1"b);
	stm -> opt_statement.machine_state = 0;

     end free_machine_state;

     end reset_subprogram;

     end interpreter;

get_char_size:
     procedure (pt) returns (fixed binary (18));

	/* Procedure to return the size of a character string.
	   The size is returned as a count (if it is constant)
	   or as an operand index. */

dcl  (p, pt) pointer;				/* Pointer to character node */

	p = pt;

	if p -> node.data_type ^= char_mode
	then call print_message (412, fixed (rel (p), 18));

	if p -> node.node_type = char_constant_node
	then return (p -> char_constant.length - bias);

	if p -> node.node_type = symbol_node
	then do;
	     if p -> symbol.v_length ^= 0
	     then return (p -> symbol.v_length);
	     else return (p -> symbol.char_size + 1 - bias);
	     end;

	if p -> node.node_type = array_ref_node
	then do;
	     if p -> array_ref.variable_length
	     then return (p -> array_ref.length);
	     else return (p -> array_ref.length - bias);
	     end;

	if p -> node.node_type = temporary_node
	then do;
	     if p -> temporary.variable_length
	     then return (p -> temporary.length);
	     else return (p -> temporary.length - bias);
	     end;

	call print_message (412, fixed (rel (p), 18));

     end get_char_size;

make_symbol_descriptor:
     procedure (var) returns (fixed binary (18));

	/* Builds a descriptor for the symbol var.  If var is a parameter
	   of star or expression extents, the appropriate fields of the
	   descriptor are filled in later by get_param_array_size or
	   get_param_char_size. */

dcl  var fixed binary (18);				/* symbol that needs a descriptor */

dcl  (p, d, cs) pointer;
dcl  (i, cm, desc, dt, const, ndims, char_star_ndims, csize) fixed binary (18);
dcl  v_length bit (1) aligned;

dcl  1 descriptor aligned,
       2 type_word aligned,
         3 bit_type unaligned,
	 4 flag bit (1) unaligned,
	 4 type bit (6) unaligned,
	 4 packed bit (1) unaligned,
         3 number_dims fixed binary (3) unaligned,
         3 size fixed binary (23) unaligned,
       2 array_info (7) aligned,
         3 l_bound fixed binary (18),
         3 h_bound fixed binary (18),
         3 multiplier fixed binary (18);

dcl  desc_image char (chars_per_word * (1 + char_star_ndims + 3 * ndims)) unaligned based (addr (descriptor));

dcl  (length, size) builtin;

	p = addr (rands (var));
	unspec (descriptor) = "0"b;
	v_length = "0"b;
	ndims, char_star_ndims = 0;

	/* If the symbol already has a descriptor, return it */

	if p -> symbol.hash_chain ^= 0
	then return (p -> symbol.hash_chain);

	/* Initialize the descriptor's type word */

	if p -> symbol.operand_type >= bif
	then unspec (descriptor.type_word) = unspec (descriptor_type_word (fptype, 7));
	else do;
	     dt = p -> symbol.data_type;
	     unspec (descriptor.type_word) = unspec (descriptor_type_word (fptype, dt));
	     if dt = char_mode
	     then do;
		if p -> symbol.units = char_units
		then descriptor.packed = "1"b;
		csize = get_char_size (p);
		if csize < 0
		then descriptor.size = csize + bias;
		else do;
		     v_length = "1"b;
		     unspec (descriptor.size) = "77777777"b3;
		     end;
		end;
	     end;

	/* If symbol is dimensioned, add the dimension info */

	/* If we would have to concoct runtime character*(*) length for a
	   funtime symbol table, reserve space for the character multipliers. */

	if p -> symbol.dimensioned
	then do;
	     d = addr (rands (p -> symbol.dimension));
	     ndims = d -> dimension.number_of_dims;
	     descriptor.number_dims = ndims;

	     if v_length & shared_globals.user_options.table
	     then char_star_ndims = ndims;		/* count char*(*) multiplier extras */

	     if descriptor.packed
	     then cm = get_size_in_bits ((p -> symbol.element_size), (p -> symbol.units));
	     else cm = get_size_in_words ((p -> symbol.element_size), (p -> symbol.units));

	     do i = 1 to ndims;

		if ^v_length
		then descriptor.multiplier (i) = cm;

		if string (d -> dimension.v_bound (i)) = "00"b
		then do;
		     descriptor.l_bound (i) = d -> dimension.lower_bound (i);
		     descriptor.h_bound (i) = d -> dimension.upper_bound (i);
		     if ^v_length
		     then cm = cm * d -> dimension.size (i);
		     end;
		else do;
		     v_length = "1"b;

		     /* if no specific bounds are seen, fill in '*' bounds in the static descriptor.
		        This requires variable descriptor math to over-write the bounds in auto
		        when called. */

		     if ^d -> dimension.v_bound (i).lower
		     then descriptor.l_bound (i) = d -> dimension.lower_bound (i);
		     else unspec (descriptor.l_bound (i)) = "400000000000"b3;
						/* '*' bound */

		     if ^d -> dimension.v_bound (i).upper
		     then descriptor.h_bound (i) = d -> dimension.upper_bound (i);
		     else if (i = ndims) & d -> dimension.assumed_size
		     then unspec (descriptor.h_bound (i)) = "377777777777"b3;
		     else unspec (descriptor.h_bound (i)) = "400000000000"b3;
						/* '*' bound */
		     end;
		end;
	     end;

	/* Create a constant node for the descriptor */

	if ndims = 0
	then const = create_constant (int_mode, unspec (descriptor.type_word));
	else const = create_char_constant (desc_image);

	/* If the descriptor must be filled in at runtime, allocate a
	   symbol node for it. */

	if v_length
	then do;
	     desc = create_node (symbol_node, size (symbol));
	     d = addr (rands (desc));
	     d -> symbol.data_type = char_mode;
	     d -> symbol.by_compiler = "1"b;
	     d -> symbol.character = "1"b;
	     d -> symbol.allocate = "1"b;
	     d -> symbol.automatic = "1"b;
	     d -> symbol.char_size = length (desc_image) - 1;
	     d -> symbol.element_size = 1 + char_star_ndims + 3 * ndims;
	     d -> symbol.general = const;

	     /* Thread in the new symbol, so its storage is allocated */

	     cs = addr (rands (cur_subprogram));
	     addr (rands (cs -> subprogram.last_symbol)) -> node.next = desc;
	     cs -> subprogram.last_symbol = desc;
	     end;
	else desc = const;

	/* Remember that we made this descriptor */

	p -> symbol.hash_chain = desc;

	/* Return the descriptor node */

	return (desc);

     end make_symbol_descriptor;

make_entry_descriptor:
     procedure (var) returns (fixed binary (18));

dcl  var fixed binary (18);				/* Symbol that needs a descriptor */

dcl  (p, d) pointer;
dcl  (i, cm, dt, const, ndims, char_star_ndims, csize) fixed binary (18);
dcl  v_length bit (1) aligned;

dcl  1 descriptor aligned,
       2 type_word aligned,
         3 bit_type unaligned,
	 4 flag bit (1) unaligned,
	 4 type bit (6) unaligned,
	 4 packed bit (1) unaligned,
         3 number_dims fixed binary (3) unaligned,
         3 size fixed binary (23) unaligned,
       2 array_info (7) aligned,
         3 l_bound fixed binary (18),
         3 h_bound fixed binary (18),
         3 multiplier fixed binary (18);

dcl  desc_image character (chars_per_word * (1 + char_star_ndims + 3 * ndims)) unaligned based (addr (descriptor));


	p = addr (rands (var));
	unspec (descriptor) = "0"b;
	v_length = "0"b;
	ndims, char_star_ndims = 0;

	/* If the symbol already has a descriptor, return it. */

	if p -> symbol.hash_chain ^= 0
	then do;
	     d = addr (rands (p -> symbol.hash_chain));

	     /* return only constant nodes */
	     if d -> node.node_type = symbol_node
	     then d = addr (rands (d -> symbol.general));

	     /* make sure the constant is allocated */
	     d -> node.allocate = "1"b;
	     return (fixed (rel (d), 18));
	     end;

	/* Initialize the descriptor's type word */

	if p -> symbol.operand_type >= bif
	then unspec (descriptor.type_word) = unspec (descriptor_type_word (fptype, 7));
	else do;
	     dt = p -> symbol.data_type;
	     unspec (descriptor.type_word) = unspec (descriptor_type_word (fptype, dt));
	     if dt = char_mode
	     then do;
		if p -> symbol.units = char_units
		then descriptor.packed = "1"b;
		csize = get_char_size (p);
		if csize < 0
		then descriptor.size = csize + bias;
		else do;
		     v_length = "1"b;
		     unspec (descriptor.size) = "77777777"b3;
		     end;
		end;
	     end;

	/* If symbol is dimensioned, add the dimension info */
	/* If we would have to concoct runtime character*(*) lengths for a
	   runtime symbol table, reserve space for the character multipliers. */

	if p -> symbol.dimensioned
	then do;
	     d = addr (rands (p -> symbol.dimension));
	     ndims = d -> dimension.number_of_dims;
	     descriptor.number_dims = ndims;

	     if v_length & shared_globals.user_options.table
	     then char_star_ndims = ndims;		/* count char*(*) multiplier extras */

	     if descriptor.packed
	     then cm = get_size_in_bits ((p -> symbol.element_size), (p -> symbol.units));
	     else cm = get_size_in_words ((p -> symbol.element_size), (p -> symbol.units));

	     do i = 1 to ndims;

		if ^v_length
		then descriptor.multiplier (i) = cm;

		if string (d -> dimension.v_bound (i)) = "00"b
		then do;
		     descriptor.l_bound (i) = d -> dimension.lower_bound (i);
		     descriptor.h_bound (i) = d -> dimension.upper_bound (i);
		     if ^v_length
		     then cm = cm * d -> dimension.size (i);
		     end;
		else do;
		     v_length = "1"b;

		     /* if no specific bounds are seen, fill in '*' bounds in the static descriptor.
		        This requires variable descriptor math to over-write the bounds in auto
		        when called. */

		     if ^d -> dimension.v_bound (i).lower
		     then descriptor.l_bound (i) = d -> dimension.lower_bound (i);
		     else unspec (descriptor.l_bound (i)) = "400000000000"b3;
						/* '*' bound */

		     if ^d -> dimension.v_bound (i).upper
		     then descriptor.h_bound (i) = d -> dimension.upper_bound (i);
		     else if (i = ndims) & d -> dimension.assumed_size
		     then unspec (descriptor.h_bound (i)) = "377777777777"b3;
		     else unspec (descriptor.h_bound (i)) = "400000000000"b3;
						/* '*' bound */
		     end;
		end;
	     end;

	/* Create a constant node for the descriptor */

	if ndims = 0
	then const = create_constant (int_mode, unspec (descriptor.type_word));
	else const = create_char_constant (desc_image);

	/* Remember that we made this descriptor */

	p -> symbol.hash_chain = const;

	/* Make sure the constant is allocated. */

	addr (rands (const)) -> node.allocate = "1"b;

	/* Return the descriptor node */

	return (const);

     end make_entry_descriptor;

/**** DATA INITIALIZATION ****/

initialize_static:
     procedure ();

dcl  (cur_subr, hdr) fixed binary (18);
dcl  (csp, h, s) pointer;

dcl  base ptr;
dcl  full_pointer ptr based (base);
dcl  packed_pointer ptr unaligned based (base);


	do cur_subr = first_subprogram repeat csp -> subprogram.next_subprogram while (cur_subr > 0);
	     csp = addr (rands (cur_subr));

	     /* Do static Large Arrays - full null pointer. */

	     do hdr = csp -> subprogram.storage_info.first (14) repeat h -> node.next while (hdr > 0);
		h = addr (rands (hdr));
		base = addrel (link_base, h -> header.location);
		full_pointer = null ();
		end;

	     /* Do static Very Large Arrays - packed null pointer. */

	     do hdr = csp -> subprogram.storage_info.first (16) repeat h -> node.next while (hdr > 0);
		h = addr (rands (hdr));
		s = addr (rands (h -> header.VLA_base_addressor));
		if ^s -> symbol.large_address
		then base = addrel (link_base, s -> symbol.address.offset);
		else base = addrel (link_base, s -> symbol.address.offset + s -> symbol.location);
		packed_pointer = null ();
		end;

	     /* Do Very Large Common - packed null pointer. */

	     do hdr = csp -> subprogram.storage_info.first (17) repeat h -> node.next while (hdr > 0);
		h = addr (rands (hdr));
		s = addr (rands (h -> header.VLA_base_addressor));
		if ^s -> symbol.large_address
		then base = addrel (link_base, s -> symbol.address.offset);
		else base = addrel (link_base, s -> symbol.address.offset + s -> symbol.location);
		packed_pointer = null ();
		end;
	     end;


	/* Initialize normal static. */
	do cur_subr = first_subprogram repeat csp -> subprogram.next_subprogram while (cur_subr > 0);
	     csp = addr (rands (cur_subr));
	     call initialize (link_base, 5);
	     end;

	/* initialize long_profile_header */

	if generate_profile & generate_long_profile
	then do;
	     base = addrel (link_base, profile_start);
	     unspec (base -> long_profile_header) = "0"b;
	     end;
	return;


initialize_auto:
     entry;

	auto_template = text_pos;

	do cur_subr = first_subprogram repeat csp -> subprogram.next_subprogram while (cur_subr > 0);
	     csp = addr (rands (cur_subr));
	     call initialize (addrel (object_base, text_pos - first_auto_var_loc), 1);
	     end;

	text_pos = text_pos + (csp -> subprogram.next_loc (2) - first_auto_var_loc);

	return;

initialize:
     procedure (pt, start);

dcl  pt pointer,					/* base of section to place initialized vars */
     start fixed binary (18);				/* first bucket to initialize */

dcl  (base, h, s) pointer;
dcl  (sym, hdr, i) fixed binary (18);

	base = pt;

	do i = start to start + 1;
	     do hdr = csp -> subprogram.storage_info.first (i) repeat h -> node.next while (hdr > 0);
		h = addr (rands (hdr));
		if h -> node.node_type = header_node
		then do sym = h -> header.first_element repeat s -> symbol.next_member while (sym > 0);
			s = addr (rands (sym));
			if s -> symbol.initialed
			then call initialize_symbol (s, base);
			end;
		else call initialize_symbol (h, base);
		end;
	     end;

     end initialize;

     end initialize_static;

list_initialize:
     procedure (pt, hdr, words);

dcl  pt pointer,					/* Base of section to place initialized vars */
						/* left at last point of init */
     hdr fixed binary (18),				/* header to init from */
     words fixed bin (18);				/* words used for init info + original value */

dcl  (h, s) pointer;
dcl  sym fixed binary (18);
dcl  start_offset fixed bin (18);
dcl  end_offset fixed bin (35);

	h = addr (rands (hdr));
	if ^h -> header.initialed
	then return;				/* No work to do */
	end_offset = 0;
	start_offset = fixed (rel (pt), 18);

	do sym = h -> header.first_element repeat s -> symbol.next_member while (sym > 0);
	     s = addr (rands (sym));

	     if s -> symbol.initialed
	     then call list_initialize_symbol (s, pt, end_offset);
	     end;
	pt -> create_init_entry.length = 0;		/* END */
	pt = addrel (pt, 1);

	/* calculate words taken for initialization list data */

	words = words + fixed (rel (pt), 18) - start_offset;
	return;
     end list_initialize;

initialize_symbol:
     procedure (sym_pt, init_pt);

dcl  (sym_pt, init_pt) pointer;

dcl  (s, address) pointer;
dcl  (index, case, csize, limit, off) fixed binary (18);

dcl  1 initial aligned auto,
       2 next fixed binary (18),
       2 limit fixed binary (18),
       2 value fixed binary (18);

dcl  1 initial_in_polish aligned based,
       2 next fixed binary (18) aligned,
       2 limit fixed binary (18) aligned,
       2 value fixed binary (18) aligned;

dcl  single_target (10000) bit (36) aligned based (address);

dcl  double_target (10000) bit (72) aligned based (address);

dcl  char_target (10000) char (csize) aligned based (address);

dcl  char77_target (10000) char (csize) unaligned based (address);

dcl  char_overlay (0:3) char (1) unaligned based;

	s = sym_pt;
	address = init_pt;
	index = 1;

	/* Develop a full pointer to the initial template for the symbol */

	off = s -> symbol.address.offset;
	if s -> symbol.large_address
	then off = off + s -> symbol.location;
	address = addrel (address, off);

	if s -> symbol.units = char_units
	then do;
	     off = s -> symbol.address.char_num;
	     address = addr (address -> char_overlay (off));
	     end;

	if s -> symbol.character
	then if s -> symbol.units = char_units
	     then do;
		csize = s -> symbol.char_size + 1;
		case = 4;
		end;
	     else do;
		csize = s -> symbol.char_size + 1;
		case = 3;
		end;
	else case = data_type_size (s -> symbol.data_type);

	if ^s -> symbol.dimensioned
	then do;
	     initial.value = addr (polish (s -> symbol.initial)) -> initial_in_polish.value;
	     if initial.value ^= gap_value
	     then call assign_value;
	     return;
	     end;

	initial.next = s -> symbol.initial;
	limit = 0;

	do while (initial.next > 0);

	     /* can't use aggregate assignment because of bug 1466 */

	     initial.value = addr (polish (initial.next)) -> initial_in_polish.value;
	     initial.limit = addr (polish (initial.next)) -> initial_in_polish.limit;
	     initial.next = addr (polish (initial.next)) -> initial_in_polish.next;
	     limit = limit + initial.limit;

	     do while (index <= limit);
		if initial.value ^= gap_value
		then call assign_value;
		index = index + 1;
		end;

	     end;

assign_value:
     procedure ();

	go to action (case);

action (1):
	single_target (index) = addr (rands (initial.value)) -> constant.value;
	return;

action (2):
	double_target (index) = addr (rands (initial.value)) -> constant.value;
	return;

action (3):
	char_target (index) = addr (rands (initial.value)) -> char_constant.value;
	return;

action (4):
	char77_target (index) = addr (rands (initial.value)) -> char_constant.value;
	return;

     end assign_value;

     end initialize_symbol;

list_initialize_symbol:
     procedure (sym_pt, init_pt, end_offset);

dcl  (
     sym_pt,					/* pointer to symbol */
     init_pt
     ) pointer;					/* pointer to template storage */

dcl  end_offset fixed bin (35);			/* offset end of last stored */

	/* end_offset will be the last offset value assigned, and used as both input
	   and output.  The difference between the end_offset input and the first
	   offset calculated will be a null filler.  end_offset output will be the
	   end of the area initialized to this point. */

dcl  boffset fixed bin (35);
dcl  s pointer;
dcl  (index, case, bsize, csize) fixed binary (18);
dcl  off fixed bin (35);

dcl  1 initial aligned automatic,
       2 next fixed binary (35),
       2 limit fixed binary (35),
       2 value fixed binary (35);

dcl  1 initial_in_polish aligned based,
       2 next fixed binary (35) aligned,
       2 limit fixed binary (35) aligned,
       2 value fixed binary (35) aligned;

dcl  single_target (10000) bit (36) aligned based;

dcl  double_target (10000) bit (72) aligned based;

dcl  char_target (10000) character (csize) aligned based;

dcl  char77_target (10000) character (csize) unaligned based;


	s = sym_pt;
	index = 1;

	/* Develop an offset to the start of the variable area to be initialized */

	if s -> symbol.VLA
	then off = s -> symbol.location;
	else do;
	     off = s -> symbol.address.offset;
	     if s -> symbol.large_address
	     then off = off + s -> symbol.location;
	     end;

	boffset = off * 36;

	if s -> symbol.units = char_units
	then boffset = boffset + 9 * s -> symbol.address.char_num;

	if s -> symbol.character
	then if s -> symbol.units = char_units
	     then do;
		csize = s -> symbol.char_size + 1;
		case = 4;
		end;
	     else do;
		csize = s -> symbol.char_size + 1;
		case = 3;
		end;
	else case = data_type_size (s -> symbol.data_type);

	if ^s -> symbol.dimensioned
	then do;
	     initial.value = addr (polish (s -> symbol.initial)) -> initial_in_polish.value;
	     call list_assign_value (1);
	     return;
	     end;

	initial.next = s -> symbol.initial;

	do while (initial.next > 0);

	     /* can't use aggregate assignment because of bug 1466 */

	     initial.value = addr (polish (initial.next)) -> initial_in_polish.value;
	     initial.limit = addr (polish (initial.next)) -> initial_in_polish.limit;
	     initial.next = addr (polish (initial.next)) -> initial_in_polish.next;
	     call list_assign_value (initial.limit);
	     index = index + initial.limit;

	     end;
	return;

list_assign_value:
     procedure (repeat);

dcl  repeat fixed bin (35);

	if initial.value = gap_value			/* skip */
	then return;

	go to size_it (case);

size_it (1):					/* single precision */
	bsize = 36;
	off = (divide (boffset + bsize - 1, bsize, 35) + (index - 1)) * bsize;
	goto list_assign_create;

size_it (2):					/* double precision */
	bsize = 72;
	off = (divide (boffset + bsize - 1, bsize, 35) + (index - 1)) * bsize;
	goto list_assign_create;

size_it (3):					/* ansi66 character aligned target */
	bsize = divide (csize + 3, 4, 35) * 36;		/* round up to word */
	off = divide (boffset + 35, 36, 35) * 36 + (index - 1) * bsize;
	goto list_assign_create;

size_it (4):					/* ansi77 character unaligned */
	bsize = csize * 9;
	off = boffset + (index - 1) * bsize;
	goto list_assign_create;


	/* create the initialization entry at the specified pointer. */

list_assign_create:
	if end_offset ^= off			/* see if we formed a gap */
	then do;					/* filler */
	     init_pt -> create_init_entry.repeat = 0;	/* skip */
	     init_pt -> create_init_entry.length = off - end_offset;
	     init_pt = addrel (init_pt, 2);
	     end;
	init_pt -> create_init_entry.length = bsize;
	init_pt -> create_init_entry.repeat = repeat;
	go to action (case);

action (1):
	addr (init_pt -> create_init_entry.datum) -> single_target (1) = addr (rands (initial.value)) -> constant.value;
	goto list_assign_finish;

action (2):
	addr (init_pt -> create_init_entry.datum) -> double_target (1) = addr (rands (initial.value)) -> constant.value;
	goto list_assign_finish;

action (3):
	addr (init_pt -> create_init_entry.datum) -> char_target (1) =
	     addr (rands (initial.value)) -> char_constant.value;
	goto list_assign_finish;

action (4):
	addr (init_pt -> create_init_entry.datum) -> char77_target (1) =
	     addr (rands (initial.value)) -> char_constant.value;
	goto list_assign_finish;

list_assign_finish:
	init_pt = addrel (init_pt, currentsize (init_pt -> create_init_entry));
	end_offset = off + bsize * repeat;
	return;

     end list_assign_value;

     end list_initialize_symbol;

/**** LINKAGE SECTION GENERATION ****/

init_linkage:
     procedure ();

	/* This procedure is called to initialize the linkage generator.
	   It builds the linkage_header and generates the class 3
	   segname definition  and the definition for "symbol_table". */

dcl  1 def_header based aligned,
       2 forward bit (18) unaligned,
       2 backward bit (18) unaligned,
       2 skip bit (18) unaligned,
       2 flags bit (18) unaligned;


	/* initialize linkage header */

	link_base -> virgin_linkage_header.def_offset = bit (defrel, 18);
	link_base -> virgin_linkage_header.link_begin = bit (begin_links, 18);
	link_base -> virgin_linkage_header.linkage_section_lng = bit (link_pos, 18);
	link_base -> virgin_linkage_header.static_length =
	     bit (fixed (begin_links - size (virgin_linkage_header), 18), 18);

	link_reloc_base -> reloc (1) = rc_t;

	/* generate definition header.  the word of zeros terminating
	   the definition chain will be at location 2 */

	def_base -> def_header.flags = "11"b;		/* new,ignore */
	def_reloc_base -> reloc (0) = rc_dp;
	zero_def = "000000000000000010"b;
	last_def = (18)"0"b;
	def_pos = 3;

	/* generate definition for segname, class 3 */

	call generate_definition (segname, 3, zero_def);

	/* generate definition for "symbol_table" */

	call generate_definition ("symbol_table", 2, "0"b);

	addrel (def_base, seg_def) -> segname_def.defblock = last_def;

	return;

     end init_linkage;

gen_linkage:
     procedure ();

	/* Generate the links for common and external references */

dcl  i fixed binary (18);
dcl  position fixed binary (15);
dcl  s pointer;

	do i = begin_external_list to end_external_list - 1 by 3;
	     s = ext_ref (i);
	     if s -> node.allocated
	     then if s -> node.node_type = symbol_node
		then if s -> symbol.initial = 0
		     then do;
			position = s -> symbol.address.offset;
			if s -> symbol.large_address
			then position = position + s -> symbol.location;
			call compile_link (s -> symbol.name, "0"b, 0, position);
			end;
		     else ;
		else do;

		     /* the following code is affected by PL/I bug 1599 */
		     /* This bug is fixed by release 23 of PL/I */

		     if index (s -> header.block_name, "$") = 0
		     then call compile_link (s -> header.block_name, initialize_common (s, (polish (i + 1))), 1,
			     (s -> header.location));
		     else if ^s -> header.initialed
		     then call compile_link (s -> header.block_name, "0"b, 1, (s -> header.location));
		     else call print_message (429, s -> header.block_name);
		     end;
	     end;

	return;

     end gen_linkage;

compile_link:
     procedure (string, grow, type, link_pos);

dcl  string char (*) aligned,
     grow bit (18) aligned,
     type fixed binary (18),
     link_pos fixed binary (15);

dcl  (seg_name, ent_name, block_type) bit (18) aligned;

dcl  (def_ptr, link_ptr, def_reloc_ptr, link_reloc_ptr) pointer;
dcl  head_address fixed binary (35) based aligned;

dcl  k fixed binary (18);

dcl  dollar_name char (32) aligned;

dcl  length builtin;

	if length (string) = 0
	then do;

	     /* <*symbol>|0 link */

	     block_type = "000001"b3;
	     seg_name = "000002"b3;
	     ent_name = "000000"b3;
	     end;

	else do;

	     /* ordinary link */

	     if grow
	     then block_type = "000005"b3;
	     else block_type = "000004"b3;

	     k = index (string, "$");

	     if k ^= 0
	     then do;				/* name of the form a$b */

		dollar_name = substr (string, 1, k - 1);/* get segment part of dollar name */
		seg_name = name_assign (dollar_name);

		/* different link required if common block name ends with $; it is illegal for */
		/* external reference names to end with $. */

		if k = length (string)		/* name ends with $ */
		then do;
		     ent_name = zero_def;		/* there is no entry name */
		     block_type = "000003"b3;		/* valid only for common block links */
		     end;
		else do;				/* reference of the form a$b; get entry name */
		     dollar_name = substr (string, k + 1);
		     ent_name = name_assign (dollar_name);
		     end;
		end;

	     else do;				/* no $ in name */

		ent_name = name_assign (string);

		if type = 0
		then seg_name = ent_name;
		else seg_name = "000005"b3;
		end;
	     end;

	def_ptr = addrel (def_base, def_pos);
	def_reloc_ptr = addrel (def_reloc_base, def_pos);
	link_ptr = addrel (link_base, link_pos);
	link_reloc_ptr = addrel (link_reloc_base, link_pos);

	def_ptr -> type_pair.type = block_type;
	def_ptr -> type_pair.trap_ptr = grow;
	if grow
	then def_reloc_ptr -> reloc (0) = rc_a_dp;

	def_ptr -> type_pair.seg_ptr = seg_name;
	def_ptr -> type_pair.ext_ptr = ent_name;
	if type = 0
	then def_reloc_ptr -> reloc (1) = rc_a_dp;
	else def_reloc_ptr -> reloc (1) = rc_dp_dp;

	addrel (def_ptr, 2) -> exp_word.type_ptr = bit (def_pos, 18);
	def_reloc_ptr -> reloc (2) = rc_dp;

	link_ptr -> head_address = -link_pos * binary (262144, 19);
	link_ptr -> link.ft2 = FT2_mod;		/* 46 octal */
	link_reloc_ptr -> reloc (0) = rc_nlb;

	link_ptr -> link.exp_ptr = bit (fixed (def_pos + 2, 18), 18);
	link_reloc_ptr -> reloc (1) = rc_dp;

	def_pos = def_pos + 3;

	return;

     end compile_link;

name_assign:
     procedure (name) returns (bit (18) aligned);

dcl  name char (*) aligned;
dcl  vname char (32) varying;

dcl  1 acc aligned based,
       2 count bit (9) unaligned,
       2 string char (n) unaligned;

dcl  n fixed binary (9);
dcl  (i, old_pos) fixed binary (18);
dcl  p pointer;

dcl  1 st aligned based (polish_base),
       2 acc_ptrs (0:next_free_polish - 1) pointer unaligned;

dcl  length builtin;

	/* trim the blanks from name */

	vname = substr (name, 1, length (name) - verify (reverse (name), " ") + 1);

	/* see if this acc string has already been used */

	do i = begin_forward_refs to hbound (acc_ptrs, 1);
	     p = acc_ptrs (i);
	     n = fixed (p -> acc.count, 9);
	     if length (vname) = n
	     then if vname = p -> acc.string
		then do;
		     old_pos = fixed (rel (p), 18) - defrel;
		     return (bit (old_pos, 18));
		     end;
	     end;

	/* build a new acc string */

	n = length (vname);
	p = addrel (def_base, def_pos);

	if next_free_polish < polish_max_len
	then do;
	     next_free_polish = next_free_polish + 1;
	     acc_ptrs (next_free_polish - 1) = p;
	     end;

	p -> acc.count = bit (n, 9);
	p -> acc.string = vname;

	old_pos = def_pos;
	def_pos = def_pos + divide (n + chars_per_word, chars_per_word, 17, 0);

	return (bit (old_pos, 18));

     end name_assign;

initialize_common:
     procedure (pt, len) returns (bit (18) aligned);

dcl  (h, s, pt, grow_pt, init_pt) pointer;
dcl  (len, init_val, sym) fixed binary (18);
dcl  (
     m,						/* length of LIST_TEMPLATE_INIT */
     n						/* length of TEMPLATE_INIT */
     ) fixed bin (18);
dcl  grow_info bit (18) aligned;
dcl  use_pool bit (1) aligned;

dcl  max_template_init_size fixed bin (18) static options (constant) init (256);

%include system_link_init_info;



	h = pt;
	n = len;

	if h -> header.alignment.character
	then n = divide (n + chars_per_word - 1, chars_per_word, 18, 0);

	if h -> header.initialed & n <= max_template_init_size
	then if fixed (rel (addrel (def_base, def_pos + n + mod (def_pos, 2)))) > max_linkage_size
	     then do;				/* CANNOT INIT ON PAIN OF DEATH */
		call print_message (469, h -> header.block_name, max_linkage_size - bias);
		h -> header.initialed = "0"b;		/* PULL OUT THE RUG */
		end;


	if h -> header.initialed
	then def_pos = def_pos + mod (def_pos, 2);

	grow_info = bit (def_pos, 18);
	grow_pt = addrel (def_base, grow_info);
	init_pt = addrel (grow_pt, 2);

	init_val = NO_INIT;

	if h -> header.initialed
	then if n > max_template_init_size
	     then do;
		m = 0;				/* presume no template generated */
		init_val = LIST_TEMPLATE_INIT;
		call list_initialize (addrel (init_pt, 1), fixed (rel (h), 18), m);
		grow_pt -> list_init_info.list_size = m;
		end;
	     else do;
		init_val = TEMPLATE_INIT;
		do sym = h -> header.first_element repeat s -> symbol.next_member while (sym > 0);
		     s = addr (rands (sym));
		     if s -> symbol.initial ^= 0
		     then call initialize_symbol (s, init_pt);
		     end;
		end;

	use_pool = init_val = NO_INIT & n <= hbound (def_pool, 1);
	if use_pool
	then if def_pool (n) ^= 0
	     then return (bit (def_pool (n), 18));

	grow_pt -> init_info.size = n;
	grow_pt -> init_info.type = init_val;

	if use_pool
	then def_pool (n) = def_pos;

	def_pos = def_pos + 2;
	if init_val = TEMPLATE_INIT
	then def_pos = def_pos + n;
	else if init_val = LIST_TEMPLATE_INIT
	then def_pos = def_pos + m + 1;
	return (grow_info);

     end initialize_common;

/**** DEFINITION SECTION ****/

generate_definition:
     procedure (name, class, value);

dcl  name char (*) aligned,				/* symbol  for definition */
     class fixed binary (3),				/* class of definition */
     value bit (18) aligned;				/* value of definition */

dcl  (def_ptr, def_reloc_ptr) pointer;
dcl  (b18, pos) bit (18) aligned;

dcl  rel_code (0:3) aligned bit (18) internal static options (constant) initial ("000000000000010000"b,
						/* text */
	"000000000000010010"b,			/* link 18 */
	"000000000000010110"b,			/* symbol */
	"000000000000010101"b);			/* definition */


	b18 = name_assign (name);

	pos = bit (def_pos, 18);
	def_ptr = addrel (def_base, pos);
	def_reloc_ptr = addrel (def_reloc_base, pos);

	if last_def
	then def_ptr -> definition.backward = last_def;
	else def_ptr -> definition.backward = zero_def;

	addrel (def_base, last_def) -> definition.forward = pos;

	def_ptr -> definition.forward = zero_def;

	def_ptr -> definition.new = "1"b;
	def_ptr -> definition.symbol = b18;
	def_ptr -> definition.value = value;

	def_ptr -> definition.class = bit (class, 3);

	if class = 3
	then seg_def = pos;
	else do;
	     def_ptr -> definition.segname = seg_def;
	     def_ptr -> definition.entry = class = 0;
	     end;

	def_reloc_ptr -> reloc (0) = rc_dp_dp;
	def_reloc_ptr -> reloc (2) = rc_dp_dp;
	def_reloc_ptr -> reloc (1) = rel_code (class);

	last_def = pos;
	def_pos = def_pos + 3;

     end generate_definition;

gen_entry_defs:
     procedure ();

	/* Generates entry definitions and finishes up entry sequences */

dcl  desc fixed bin (18);
dcl  (s, def_ptr) pointer;
dcl  (sym, stack_size) fixed binary (18);
dcl  ent_pos fixed binary (18);


	stack_size = divide (last_auto_loc + 15, 16, 17, 0) * 16;

	do sym = first_entry_name repeat s -> symbol.next_symbol while (sym > 0);
	     s = addr (rands (sym));
	     ent_pos = s -> label.location;		/* a slight kludge */

	     /* fill in stack_size (must be multiple of 16) */

	     text_halfs (ent_pos).left = stack_size;

	     /* generate entry definition */

	     call generate_definition (s -> symbol.name, 0, bit (ent_pos, 18));

	     reloc_halfs (ent_pos - 1).left = rc_dp;

	     unspec (text_halfs (ent_pos - 1).left) = last_def;
	     def_ptr = addrel (def_base, last_def);

	     if assembly_list
	     then a_name (ent_pos - 1) = -1;		/* tell listing generator this is not an inst */

	     def_ptr -> definition.retain = "1"b;

	     /* process entry definitions */

	     parm_desc_ptrsp = addr (text_halfs (text_halfs (ent_pos - 2).left));
	     do i = 1 to parm_desc_ptrs.n_args;
		desc = parm_desc_ptrs.descriptor_relp (i);
		parm_desc_ptrs.descriptor_relp (i) = addr (rands (desc)) -> label.location;
		end;
	     end;

     end gen_entry_defs;

     end code_generator;

     end fort_optimizing_cg;
