/****^  ******************************************************
        *                                                    *
        * Copyright, (C) Honeywell Limited, 1983             *
        *                                                    *
        * Copyright (c) 1972 by Massachusetts Institute of   *
        * Technology and Honeywell Information Systems, Inc. *
        *                                                    *
        ****************************************************** */



/****^  HISTORY COMMENTS:
  1) change(86-07-14,BWong), approve(86-07-14,MCR7382), audit(86-07-17,Ginter),
     install(86-07-28,MR12.0-1105):
     Fix fortran bugs 477 and 494.
  2) change(86-10-17,Ginter), approve(86-10-17,MCR7556), audit(86-10-22,Huen),
     install(86-11-13,MR12.0-1216):
     Fixed fortran bugs 496 and 502.
                                                   END HISTORY COMMENTS */


/* format: style3,^delnl,linecom */
ext_listing_generator:
     procedure (shared_vp, parse_vp, cg_vp);

/* Created:	7 September 1976, David Levin

   Modified:
	04 Sep 86, AG - 496: Changed display_text$display_create to display
		more information about pointers in create_entry
		structures.  Display_create now displays the number of
		pointers, the linkage/stack section offset of each pointer,
		the absolute offset from the base of the storage section
		of the pointer target and the name of the symbol the
		pointer is for.
	27 Feb 86, BW - 494: Fix display_text so it doesn't misinterpret
		data text for instruction text.
	29 July 85, HH - 477: Fix code for naming references into
		'pl1_operators_' so that unnamed offsets in the range
		of special offsets won't produce garbage comments.
	20 July 83, TO - MSCR: Create internal binoct using ioa_$rsnnl, to
		comply with MSCR acceptance.
	17 Jun 83, HH - 383: Use '#' to represent expression extent array
		bounds.
	10 May 83, RG - 174: To use csi.dirname as pathname when csi.segname is ""
	18 Mar 83, HH - Use new include file 'op_mnemonic_dcl_' to declare
		'op_mnemonic_$op_mnemonic_'.
	 3 December 1982, TO - Make length print out take into account
	     the type of units. i.e. words, bits, chars, half_words.
	16 November 1982, TO - Make display_text$display_init to output
	     formatted create_init_entry.
	 8 November 1982, TO - Move operator name processing to cover all.
	 5 October 1982, TO - Add bit offset print to symbol location.
	28 September 1982, TO - extend symbol location field for VLA.
	23 September 1982, TO - Add first parts of LA/VLA output additions.
	 2 September 1982, TO - Add "epp" check to "t" check in printing 
	     special pl1_operator_'s names in display_text.
	19 May 1982, TO - Add "symbol_name" routine to create names for 
	     code_generator generated symbols.  Add length_symbol_name to
	     return length of a symbol name.
	19 May 1982, TO - to fix potential oob in printing external refs, if
	     a bug in code generator puts unreferenced compiler generated
	     symbols there.
	5 August 1981, CRD - Fix bug 333.
	6 May 1981, CRD - Include names in headers for main programs and
	     block data subprograms.
	13 March 1981, CRD - Print * for upper bound of assumed size array.
	18 February 1981, CRD - Change print_symbols to print lower bounds
	     of arrays.
	31 July 1979, CRD - Fix bug 228, in which the listing generator blew
	     up trying to print the name of a non-existant pl1 operator.
	15 February 1978, dsl - Fix previous bug fix. Print all user symbols.
	31 January 1978, David Levin - Change to support new optimizer; fix
	     minor bugs, i.e, fault because there are no cref nodes for a
	     compiler variable.
	30 August 1977, David Levin - remove source seg limit of 64K; prevent
	     fault if -table used; print size of stack frame used by program.
	     NOTE -- value of bias changed from 65536 to 131072.
	25 March 1977, David Levin - line up cont lines; fix headers; new
	     incl files; move unreferenced common block members to unused
	     part of listing.
	9 Dec 1976, David Levin - bugs fixes; line up continuation lines; fix
	     headers; ref fort_version_info$version_name.

   END Modifications */

dcl	(shared_vp, parse_vp, cg_vp)
			pointer;

dcl	(shared_ptr, parse_ptr, cg_ptr)
			pointer;
dcl	polish_base	ptr;
dcl	operand_base	ptr;
dcl	object_base	ptr;
dcl	cref_base		ptr;
dcl	source_line_base	ptr;
dcl	listing_base	ptr;
dcl	quad_base		ptr;

dcl	1 shared_structure	aligned based (shared_ptr),
%include fort_shared_vars;

dcl	1 parse_structure	aligned based (parse_ptr),
%include fort_parse_vars;

dcl	1 cg_structure	aligned based (cg_ptr),
%include fort_cg_vars;

%include fort_options;
%include fort_system_constants;
%include fort_nodes;
%include fort_listing_nodes;
%include fort_opt_nodes;
%include compiler_source_info;
%include fortran_storage;
%include object_map;

	shared_ptr = shared_vp;
	parse_ptr = parse_vp;
	cg_ptr = cg_vp;

	polish_base = shared_structure.polish_base;
	operand_base = shared_structure.operand_base;
	object_base = shared_structure.object_base;
	cref_base = shared_structure.cref_base;
	source_line_base = shared_structure.source_line_base;
	listing_base = shared_structure.listing_base;
	if shared_structure.options.optimize
	then quad_base = shared_structure.quadruple_base;

	call listing_generator;
	return;

listing_generator:
     procedure;

dcl	FF		char (1) int static options (constant) init ("");
dcl	TB		char (1) int static options (constant) init ("	");
dcl	NL		char (1) int static options (constant) init ("
");
dcl	abs		builtin;
dcl	addr		builtin;
dcl	addrel		builtin;
dcl	binary		builtin;
dcl	bits_per_char	fixed bin (18) int static options (constant) init (9);
dcl	blk_sym		fixed bin (18);
dcl	cg_called		bit (1) aligned;
dcl	cleanup		condition;
dcl	code		fixed bin (35);
dcl	com_err_$suppress_name
			entry options (variable);
dcl	cp		ptr;
dcl	cur_subp		ptr;
dcl	current		fixed bin (18);
dcl	date_line		char (24);
dcl	date_time_	entry (fixed bin (71), char (*));
dcl	debuggin_		bit (1) aligned;
dcl	divide		builtin;
dcl	file_no		fixed bin (8);
dcl	file_no_picture	picture "(3)zb";
dcl	first		fixed bin (18);
dcl	first_char	fixed bin (21);
dcl	first_file	fixed bin (8);
dcl	first_line	fixed bin (18);
dcl	first_loc		fixed bin (18);
dcl	first_stmnt	ptr;
dcl	in_list		bit (1) aligned;
dcl	ioa_$ioa_switch	entry options (variable);
dcl	iocb		ptr;
dcl	iox_$attach_ioname	entry (char (*), ptr, char (*), fixed bin (35));
dcl	iox_$close	entry (ptr, fixed bin (35));
dcl	iox_$detach_iocb	entry (ptr, fixed bin (35));
dcl	iox_$open		entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
dcl	iox_$put_chars	entry (ptr, ptr, fixed bin (21), fixed bin (35));
dcl	last		fixed bin (18);
dcl	last_char		fixed bin (21);
dcl	last_line		fixed bin (18);
dcl	last_loc		fixed bin (18);
dcl	last_symbol	fixed bin (18);
dcl	length		builtin;
dcl	line_len		fixed bin (18);
dcl	line_no		fixed bin (17);
dcl	line_no_picture	picture "(4)z9b";
dcl	line_ptr		pointer;
dcl	loc		fixed bin (18);
dcl	looping		bit (1);
dcl	ltrim		builtin;
dcl	m		fixed bin;
dcl	map_file_no_picture picture "(3)z-";
dcl	max_line		fixed bin (18) int static options (constant) init (131);
dcl	max_number	fixed bin (18);
dcl	more_than_one	bit (1) aligned;
dcl	moved_text	bit (1) aligned;
dcl	n		fixed bin (18);
dcl	n_com		fixed bin (18);
dcl	n_ep		fixed bin (18);
dcl	n_hdr		fixed bin (18);
dcl	n_ref		fixed bin (18);
dcl	next_entry_name	fixed bin (18);
dcl	null		builtin;
dcl	numb		char (12) varying;
dcl	number_of_operands	fixed bin (18);
dcl	number_referenced	fixed bin (18);
dcl	object		(0:261119) bit (36) aligned based (object_base);
dcl	object_map_ptr	ptr;
dcl	octal_string	char (12) aligned;
dcl	old_id		bit (27) aligned;
dcl	old_moved		bit (1) aligned;
dcl	optimizing	bit (1) aligned;
dcl	output		char (4096) varying;
dcl	output_max	fixed bin (18) int static options (constant) init (4096);
dcl	output_ptr	pointer;
dcl	p		pointer;
dcl	polish		(0:261119) fixed bin (18) based (polish_base);
dcl	ptr		builtin;
dcl	quad		(0:261119) fixed bin (18) based (quad_base);
dcl	rands		(0:261119) fixed bin (18) based (operand_base);
dcl	rel_base		ptr;
dcl	rtrim		builtin;
dcl	source_node_ptr	ptr;
dcl	source_ptr	ptr;
dcl	source_seg	char (1044479) aligned based (source_ptr);
dcl	sp		ptr;
dcl	1 stmnt		like statement aligned;
dcl	string		builtin;
dcl	subp_type		fixed bin (18);
dcl	subprogram_header	char (276) varying;
dcl	subprogram_name	char (256) varying;
dcl	subprogram_type	(0:3) char (18) int static options (constant)
						/* 5 tabs, some SP, then type */
			init ("					Main Program ",
			"					  Block Data ",
			"					  Subroutine ",
			"					    Function ");
dcl	substr		builtin;
dcl	sym_info		(0:261119) fixed bin (18) based (sym_info_base);
dcl	sym_info_base	ptr;
dcl	text_length	fixed bin (17);
dcl	three_digits	picture "zz9";
dcl	title_lines	(3) char (12) int static options (constant)
			init ("Compiled by:", "Compiled on:", "    Options:");
dcl	text_pos		fixed bin (18);
dcl	unspec		builtin;
dcl	verify		builtin;
dcl	work_base		ptr;
dcl	work_string	char (12) varying;

dcl	1 symbols		(max_number) aligned structure based (work_base),
	  2 str_p		ptr unal,
	  2 offset	fixed bin (18) unal unsigned,
	  2 length	fixed bin (18) unal unsigned;

dcl	1 swap_temp	like symbols aligned;

dcl	1 text_overlay	aligned structure based (source_ptr),
	  2 pad		char (first_char) unaligned,
	  2 text		char (text_length) unaligned;

dcl	1 stack_length_overlay
			aligned based,		/* structure to obtain length of program stack frame */
	  2 stack_len	fixed bin (18) unaligned unsigned,
	  2 pad		bit (18) unaligned;

dcl	1 source_info_line	aligned,
	  2 line_id	char (9) unaligned,
	  2 sp1		char (2) unaligned,
	  2 file_id	char (3) unaligned,
	  2 sp2		char (4) unaligned,
	  2 dtm		char (16) unaligned,
	  2 sp3		char (2) unaligned,
	  2 pathname	char (168) unaligned;

dcl	full_line		char (132) unaligned;

dcl	sym_name		char (09) unaligned defined full_line position (01);
dcl	sym_type		char (20) unaligned defined full_line position (12);
dcl	sym_loc		char (08) unaligned defined full_line position (32);
dcl	sym_char		char (04) unaligned defined full_line position (40);
dcl	sym_class		char (09) unaligned defined full_line position (45);
dcl	begin_class	fixed bin (18) int static options (constant) init (44);
dcl	begin_refs	fixed bin (18) int static options (constant) init (54);

dcl	lbl_name		char (10) unaligned defined full_line position (09);
dcl	lbl_loc		char (06) unaligned defined full_line position (01);
dcl	lbl_type		char (41) unaligned defined full_line position (21);
dcl	lbl_line		char (75) unaligned defined full_line position (36);
dcl	begin_line	fixed bin (18) int static options (constant) init (35);

dcl	ep_name		char (14) unaligned defined full_line position (01);
dcl	ep_loc		char (06) unaligned defined full_line position (21);
dcl	begin_ep_attr	fixed bin (18) int static options (constant) init (30);

/* set global variables */

	source_ptr = source_info_ptr -> compiler_source_info.input_pointer;
						/* source seg base */
	debuggin_ = string (shared_structure.options.system_debugging) ^= "0"b;
						/* local copy of debugging switches */
	max_number = divide (sys_info$max_seg_size - number_of_crefs, 2, 17, 0);
						/* maximum number of operands */
	work_base = addr (cross_reference (number_of_crefs + 1));
						/* base of operand array */
	subprogram_header = NL;			/* initial value of the header */
	line_len = 0;				/* line is initially empty */
	line_ptr = addr (full_line);			/* pointer for value of the line */
	next_entry_name = first_entry_name;		/* first entry name is first valid name */
	n_hdr = 0;				/* to count number of header nodes */
	more_than_one = first_subprogram ^= last_subprogram;

/* if code generator called, must pick up some info pointers */

	if next_free_object ^= 0
	then do;
		object_map_ptr = addrel (object_base, addrel (object_base, next_free_object - 1) -> map_ptr);
		text_pos = binary (object_map_ptr -> object_map.text_length, 18);
						/* text length */

		rel_base = relocation_base;		/* base of relocation info */
		sym_info_base = addr (source_list (number_of_lines + 2));
						/* base of symbol ref info */

		cg_called = "1"b;
	     end;
	else cg_called = "0"b;

	optimizing = shared_structure.options.optimize;
	moved_text = "0"b;

	iocb = null;				/* acts as a flag for the cleanup handler */
	output = "";				/* the buffer is empty */
	output_ptr = addrel (addr (output), 1);		/* pointer to the actual value of "output" */

	on condition (cleanup)
	     call close_file;			/* ensure the file is closed */

/* open the listing segment using iox_ */

	call iox_$attach_ioname ("fort_listing_", iocb, "vfile_ " || objectname || ".list", code);
	if code ^= 0
	then goto print_and_abort;

	call iox_$open (iocb, 2, "0"b, code);		/* open for stream_output */
	if code ^= 0
	then goto print_and_abort;

/* Print compiler header information */

	call date_time_ (date_time_compiled, date_line);

/* If segname is null then dirname contains the absolute pathname of the source */
	if source_info_ptr -> compiler_source_info.segname = ""
	then call ioa_$ioa_switch (iocb, "^-COMPILATION^xLISTING^xOF^x^a^x(^a)",
		source_info_ptr -> compiler_source_info.given_ename, source_info_ptr -> compiler_source_info.dirname);
	else call ioa_$ioa_switch (iocb, "^-COMPILATION^xLISTING^xOF^x^a^x(^a>^a)",
		source_info_ptr -> compiler_source_info.given_ename, source_info_ptr -> compiler_source_info.dirname,
		source_info_ptr -> compiler_source_info.segname);
						/* source pathname */

	call ioa_$ioa_switch (iocb, "^3(^/^-^a^x^a^)", title_lines (1),
	     fort_version_info$version_name || fort_version_info$version_number,
						/* compiler version */
	     title_lines (2),
	     date_line,				/* date time compiled */
	     title_lines (3), options_string);
						/* user options */

/* if errors occured before the first subprogram node was created, move those errors to first subprogram */

	cur_listing = listing_base;
	if listing_info.first_error ^= 0
	then do;
		p = addr (listing_seg (listing_info.next));

/* chain lists together */

		addr (listing_seg (listing_info.last_error)) -> error_text.next = p -> listing_info.first_error;
		p -> listing_info.first_error = listing_info.first_error;

		listing_info.first_error = 0;
		listing_info.last_error = 0;
	     end;

/* sort the cross reference nodes */

	call sort_words;


/* LISTING LOOP starts here */

	do cur_listing = addr (listing_seg (listing_base -> listing_info.next))
	     repeat addr (listing_seg (listing_info.next)) while (cur_listing ^= listing_base);

/* get pointer to current subprogram node */

	     cur_subprogram = listing_info.subprogram;
	     cur_subp = addr (rands (cur_subprogram));
	     subp_type = cur_subp -> subprogram.subprogram_type;

/* build a header for this program unit */

	     subprogram_header = substr (subprogram_header, 1, 1);
						/* throw away previous header info */
	     subprogram_header = subprogram_header || subprogram_type (subp_type);
						/* add new info */

	     subprogram_name = addr (rands (cur_subp -> subprogram.symbol)) -> symbol.name;

	     if subp_type = subroutine | subp_type = function
	     then subprogram_header = subprogram_header || subprogram_name;
	     else if subp_type = main_program
	     then if subprogram_name ^= default_main_entry_point_name
		then subprogram_header = subprogram_header || subprogram_name;
		else ;
	     else if subp_type = block_data
	     then if subprogram_name ^= unnamed_block_data_subprg_name
		then subprogram_header = subprogram_header || subprogram_name;

	     subprogram_header = subprogram_header || NL;
	     subprogram_header = subprogram_header || NL;

	     if length (output) + length (subprogram_header) > output_max
	     then call print$buffer;
	     output = output || subprogram_header;

	     substr (subprogram_header, 1, 1) = FF;	/* in the future, header will begin a page */


/* SOURCE LISTING */

	     if optimizing
	     then first_stmnt = addr (quad (cur_subp -> subprogram.first_quad));
	     else first_stmnt = addr (polish (cur_subp -> subprogram.first_polish));

	     if get_stmnt_ptr (first_stmnt) -> statement.file > shared_structure.incl_count
	     then do;
		     call print_message (500);	/* cannot get pointer to source */
		end;

	     else do;
		     first_line = listing_info.first_line;
		     first_char = source_list (first_line).line_start;
		     first_file = source_list (first_line).file_number;

		     if listing_info.next = 0		/* the last subprogram in the compilation */
		     then last_line = number_of_lines;	/* end of segment, get everything that remains */
		     else last_line = addr (listing_seg (listing_info.next)) -> listing_info.first_line - 1;
						/* use beginning of next program unit */
		     last = source_list (last_line).line_start + source_list (last_line).line_length;

		     if shared_structure.options.has_line_numbers & (shared_structure.incl_data.incl_count = 0)
		     then do;
			     text_length = last - first_char;

/* write the text directly from the source segment */

			     if length (output) > 0
			     then call print$buffer;
			     call iox_$put_chars (iocb, addr (text), length (text), code);
			     if code ^= 0
			     then goto print_and_abort;
			     output = "";		/* buffer has been printed */
			end;

/* user did not supply line numbers so we will */

		     else do n = first_line to last_line;
			     file_no = source_list (n).file_number;
			     source_ptr = shared_structure.file_list (file_no).incl_ptr;
			     first_char = source_list (n).line_start;
			     text_length = source_list (n).line_length;
			     line_no = source_list (n).line_number_in_file;

			     if length (output) + text_length + 11 > output_max
			     then call print$buffer;

			     file_no_picture = file_no;
			     output = output || file_no_picture;

			     if ^shared_structure.has_line_numbers
			     then do;
				     line_no_picture = line_no;
				     output = output || line_no_picture;
				end;

			     output = output || text;
			end;

/* if last char is not a newline, add one */

		     if substr (source_seg, last, 1) ^= NL
		     then do;
			     if length (output) = output_max
			     then call print$buffer;
			     output = output || NL;
			end;
		end;				/* code to print the source */


/* REFERENCED SYMBOLS */

	     if length (output) + length (subprogram_header) + 111 > output_max
	     then call print$buffer;

	     output = output || subprogram_header;

/* current length of this string is 111 characters */

	     output =
		output
		||
		"	NAMES USED IN THIS PROGRAM UNIT

NAME       TYPE OF NAME        LOC          STORAGE   ATTRIBUTES AND REFERENCES

"
		;

	     number_of_operands = 0;
	     number_referenced = 0;
	     last_symbol = 0;

/* get entry point symbols for this subprogram */

	     do while (next_entry_name ^= 0 & addr (rands (next_entry_name)) -> symbol.parent = cur_subprogram);
		call store_item (next_entry_name);
		next_entry_name = addr (rands (next_entry_name)) -> symbol.next_symbol;
						/* get next name */
	     end;

/* get the rest of the names */

	     if cg_called
	     then do;
		     do n = 1 to 11;		/* loop thru the symbol buckets */
			call walk_bucket (n);
		     end;
		     do n = 13 to 17;		/* loop thru LA/VLA buckets */
			call walk_bucket (n);
		     end;

		     number_referenced = number_of_operands;
						/* separate the two types */

		     call walk_bucket (12);		/* get unreferenced symbols */
		end;

	     else do;
		     do current = cur_subp -> subprogram.first_symbol
			repeat addr (rands (current)) -> symbol.next_symbol while (current ^= 0);
			call store_item (current);
		     end;

		     do current = cur_subp -> subprogram.common_chain
			repeat addr (rands (current)) -> header.next_header while (current ^= 0);
			call store_item (current);
		     end;

		     do current = cur_subp -> subprogram.LA_chain
			repeat addr (rands (current)) -> header.next_header while (current ^= 0);
			call store_item (current);
		     end;

		     do current = cur_subp -> subprogram.VLA_chain
			repeat addr (rands (current)) -> header.next_header while (current ^= 0);
			call store_item (current);
		     end;

		     number_referenced = number_of_operands;
		end;

	     last_symbol = number_of_operands;

/* move all unreferenced but allocated symbols to unused list */

	     do n = number_referenced to 1 by -1;

		sp = addr (rands (symbols (n).offset)); /* get pointer to list item */

		if sp -> node.node_type = symbol_node & ^sp -> symbol.referenced
		then do;				/* unused symbol */
			if n ^= number_referenced
			then do;			/* swap into the other list */
				swap_temp = symbols (n);
				symbols (n) = symbols (number_referenced);
				symbols (number_referenced) = swap_temp;
			     end;

			number_referenced = number_referenced - 1;
		     end;
	     end;

/* get all labels */

	     do current = cur_subp -> subprogram.first_label repeat addr (rands (current)) -> label.next_label
		while (current ^= 0);
		call store_item (current);
	     end;

/* link up cref node with appropriate operand nodes */

	     last = 0;				/* current node offset */

	     do current = listing_info.first_cref to listing_info.last_cref;
						/* crefs for the subr */

		if cross_reference (current).symbol ^= last
						/* cref for another operand node */
		then do;
			if last ^= 0
			then cross_reference (first).symbol = current - 1;
			first = current;		/* first cref for this item */
			last = cross_reference (current).symbol;
			sp = addr (rands (last));

			if sp -> node.node_type = symbol_node | sp -> node.node_type = label_node
			then sp -> node.hash_chain = current;

			else if sp -> node.node_type = header_node
			then sp -> header.last_element = current;

			else call print_message (502, last);
		     end;
	     end;

	     if last ^= 0
	     then cross_reference (first).symbol = listing_info.last_cref;

/* output referenced names and attributes */

	     call sort_symbols (1, number_referenced);
	     call print_symbols (1, number_referenced, "ref");


/* UNUSED SYMBOLS */

	     if last_symbol - number_referenced > 0
	     then do;
		     if length (output) + 30 > output_max
		     then call print$buffer;

		     output = output || "
NAMES DECLARED BUT NOT USED

";

		     call sort_symbols (number_referenced + 1, last_symbol);
		     call print_symbols (number_referenced + 1, last_symbol, "declared");
		end;


/* LABELS */

	     if number_of_operands - last_symbol > 0
	     then do;
		     if length (output) + 63 > output_max
		     then call print$buffer;

		     output = output || "
LOC          LABEL  TYPE           LINE           REFERENCES

";

		     call sort_symbols (last_symbol + 1, number_of_operands);
		     call print_symbols (last_symbol + 1, number_of_operands, "ref");
		end;


/* STATEMENT MAP */

	     if cg_called
	     then do;
		     if length (output) + 227 > output_max
		     then call print$buffer;		/* length (header) + 7*16 + 1 */

		     output =
			output
			||
			"
       LINE   LOC        LINE   LOC        LINE   LOC        LINE   LOC        LINE   LOC        LINE   LOC

"
			;

		     old_id = (27)"1"b;		/* print one entry per unique source_id */
		     line_len = 0;			/* line is empty */
		     in_list = "1"b;
		     do sp = first_stmnt repeat p while (in_list);

			sp = get_stmnt_ptr (sp);

			if sp -> statement.next = "0"b
			then in_list = "0"b;
			else p = ptr (first_stmnt, sp -> statement.next);

			if sp -> statement.put_in_map & ^moved_text
			then if unspec (sp -> statement.source_id) ^= old_id
			     then do;
				     old_id = unspec (sp -> statement.source_id);

				     if line_len = 108
						/* six per line; 6*18 = 108 */
				     then do;
					     output = output || NL;
					     line_len = 0;
					     if length (output) + 109 > output_max
					     then call print$buffer;
					end;

				     line_no_picture = binary (sp -> statement.line, 14);
				     map_file_no_picture = -sp -> statement.file;
				     work_string =
					substr ("           ", 1, 8 - length (ltrim (line_no_picture)));
				     work_string = work_string || map_file_no_picture;
				     work_string = work_string || ltrim (line_no_picture);

				     output = output || work_string;

				     call binoct (unspec (sp -> statement.location), octal_string);
				     output = output || substr (octal_string, 1, 6);

				     line_len = line_len + 18;
				end;
		     end;

		     if line_len > 0
		     then output = output || NL;
		end;


/* ERROR MESSAGES */

	     do current = listing_info.first_error repeat p -> error_text.next while (current ^= 0);
		p = addr (listing_seg (current));

		if length (output) + length (p -> error_text.string) > output_max
		then call print$buffer;

		output = output || p -> error_text.string;
	     end;


/* OBJECT LISTING */

	     if shared_structure.options.list & cg_called /* must be requested and available */
	     then do;
		     if length (output) + 16 > output_max
		     then call print$buffer;

		     output = output || "


OBJECT CODE

";

/* print any words left over from the last subprogram */

		     p = get_stmnt_ptr (first_stmnt);
		     first_loc = binary (p -> statement.location, 18);

		     old_id = (27)"1"b;		/* print one header per unique source_id */
		     old_moved = "0"b;
		     in_list = "1"b;
		     do sp = first_stmnt repeat p while (in_list);

			sp = get_stmnt_ptr (sp);

			if sp -> statement.next = "0"b
			then do;
				in_list = "0"b;
				last_loc = -1;
			     end;
			else do;
				p = ptr (first_stmnt, sp -> statement.next);
				if optimizing
				then last_loc = binary (p -> opt_statement.location, 18) - 1;
				else last_loc = binary (p -> statement.location, 18) - 1;
			     end;

			if sp -> statement.put_in_map & (^moved_text | last_loc >= first_loc)
			then do;

/* print statement header if it's unique */

				if unspec (sp -> statement.source_id) ^= old_id | (old_moved ^= moved_text)
				then do;
					old_id = unspec (sp -> statement.source_id);
					old_moved = moved_text;

					if length (output) + max_line > output_max
					then call print$buffer;

					output =
					     output
					     || "						 ";

					if moved_text
					then output = output || "EXTRACTED FROM STATEMENT ";
					else output = output || "STATEMENT ";
					output = output || print_number (binary (sp -> statement.statement, 5));

					output = output || " ON LINE ";
					output = output || print_number (binary (sp -> statement.line, 14));

					if sp -> statement.file ^= 0
					then do;
						output = output || " IN FILE ";
						output =
						     output || print_number (binary (sp -> statement.file));
					     end;

					output = output || NL;

/* print source line */

					if sp -> statement.length ^= "000000000"b
					then do;
						first_char = sp -> statement.start;
						last_char =
						     first_char + binary (sp -> statement.length, 9) - 1;
						text_length = last_char - first_char;

						if length (output) + text_length + 2 > output_max
						then call print$buffer;
						source_ptr =
						     shared_structure.file_list (sp -> statement.file)
						     .incl_ptr;
						output = output || text;
						if substr (source_seg, last_char, 1) ^= NL
						then output = output || NL;
						output = output || NL;
					     end;
				     end;

/* print object code */

				if last_loc >= first_loc
				then do;
					call display_text (first_loc, last_loc);
					first_loc = last_loc + 1;
				     end;
			     end;
		     end;				/* loop through statements */
		end;				/* do block to print object code */

	end;					/* LISTING LOOP */

/* print constants */

	if shared_structure.options.list & cg_called
	then do;
		in_list = "0"b;			/* header has not been printed */

		do current = first_dw_constant repeat sp -> constant.next_constant while (current ^= 0);
		     sp = addr (rands (current));

		     if sp -> constant.allocated
		     then do;
			     call print_header;

			     if length (output) = output_max
			     then call print$buffer;
			     output = output || NL;
			     call display_text$display_abs ((sp -> constant.location), sp -> constant.location + 1);
			end;
		end;

		do current = first_word_constant repeat sp -> constant.next_constant while (current ^= 0);
		     sp = addr (rands (current));

		     if sp -> constant.allocated
		     then do;
			     call print_header;

			     if length (output) = output_max
			     then call print$buffer;
			     output = output || NL;
			     call display_text$display_abs ((sp -> constant.location), (sp -> constant.location));
			end;
		end;

		do current = first_char_constant repeat sp -> char_constant.next_constant while (current ^= 0);
		     sp = addr (rands (current));

		     if sp -> constant.allocated
		     then do;
			     call print_header;

			     if length (output) = output_max
			     then call print$buffer;
			     output = output || NL;
			     call display_text$display_ascii ((sp -> char_constant.location),
				length (sp -> char_constant.value));
			end;
		end;

		do current = first_block_constant repeat sp -> char_constant.next_constant while (current ^= 0);
		     sp = addr (rands (current));

		     if sp -> constant.allocated
		     then do;
			     call print_header;

			     if length (output) = output_max
			     then call print$buffer;
			     output = output || NL;

			     first_loc = sp -> char_constant.location;
			     last_loc =
				first_loc
				+ divide (length (sp -> char_constant.value) - 1, chars_per_word, 17, 0);
			     call display_text$display_abs (first_loc, last_loc);
			end;
		end;

/* output Creation List */

		looping = "1"b;
		if Area_create_first ^= -1
		then do;
			if length (output) + 23 > output_max
			then call print$buffer;
			output = output || "
STORAGE CREATION LIST

";

			do current = Area_create_first repeat cp -> create_entry.next while (looping);
			     cp = ptr (object_base, current);
			     first_loc = current;
			     last_loc = current + currentsize (cp -> create_entry) - 1;
			     call display_text$display_create (first_loc, last_loc, cp);

			     if cp -> create_entry.init
			     then call display_text$display_init (addrel (cp, currentsize (cp -> create_entry)));

			     if length (output) + 1 > output_max
			     then call print$buffer;
			     output = output || "
";
			     if cp -> create_entry.next = 0
			     then looping = "0"b;
			end;
		     end;

/* output Initialization List */

		if Area_init_first ^= -1
		then do;
			if length (output) + 30 > output_max
			then call print$buffer;
			output = output || "
STORAGE INITIALIZATION LIST

";

			current = Area_init_first;

			cp = ptr (object_base, current);
			call display_text$display_init (cp);
		     end;
	     end;

/* flush the buffer */

	if length (output) > 0
	then call print$buffer;

/* print summary for segment */

	if cg_called
	then do;
		call ioa_$ioa_switch (iocb,
						/* stream ptr */
		     "^|^a^2/^a^/
^-Object^-Text^-Link^-Symbol^-Defs^-Static
Start^10x0^7x0^10o^12o^8o^12o
Length^10o^8o^10o^12o^8o^12o^/"
		     , "OBJECT SEGMENT SUMMARY",	/* first header */
		     "STORAGE REQUIREMENTS FOR THIS PROGRAM",
						/* second header */
		     binary (object_map_ptr -> linkage_offset, 18),
						/* linkage start */
		     binary (object_map_ptr -> symbol_offset, 18),
						/* symbol start */
		     binary (object_map_ptr -> definition_offset, 18),
						/* def start */
		     binary (object_map_ptr -> static_offset, 18),
						/* static start */
		     next_free_object,
						/* object length */
		     text_pos,			/* text length */
		     binary (object_map_ptr -> linkage_length, 18),
						/* linkage length */
		     binary (object_map_ptr -> symbol_length, 18),
						/* symbol length */
		     binary (object_map_ptr -> definition_length, 18),
						/* def length */
		     binary (object_map_ptr -> static_length, 18));
						/* static length */
		output = "";			/* buffer has been printed */


/* print length of the program stack frame */

		call ioa_$ioa_switch (iocb, "Stack frame is ^d (decimal) words.^/",
		     addr (object (addr (rands (first_entry_name)) -> label.location)) -> stack_len);

/* summary of external references, entry point references, and common block references */

		n_ep = 0;				/* counts entry points */

/* entry points */

		do n = first_entry_name repeat sp -> symbol.next_symbol while (n ^= 0);
		     sp = addr (rands (n));

		     n_ep = n_ep + 1;
		     symbols (n_ep).offset = n;
		     symbols (n_ep).length = length (sp -> symbol.name);
		     symbols (n_ep).str_p = addr (sp -> symbol.name);
		end;

/* common blocks and outgoing references */

		n_com = n_ep;			/* common list immediately follows ep list */
		n_ref = n_ep + n_hdr;		/* ext ref list immediately follows common */

		do current = first_subprogram repeat addr (rands (current)) -> subprogram.next_subprogram
		     while (current ^= 0);

		     do m = 9, 17;
			do n = addr (rands (current)) -> subprogram.storage_info.first (m)
			     repeat addr (rands (n)) -> node.next while (n ^= 0);

			     if addr (rands (n)) -> node.node_type = symbol_node
			     then do;
				     n_ref = n_ref + 1;
				     symbols (n_ref).offset = n;
				     symbols (n_ref).length = length_symbol_name (addr (rands (n)));
				     symbols (n_ref).str_p = addr (addr (rands (n)) -> symbol.name);
				     addr (rands (n)) -> symbol.parent = current;
						/* save parent block */
				end;
			     else do;
				     n_com = n_com + 1;
				     symbols (n_com).offset = n;
				     symbols (n_com).length = length (addr (rands (n)) -> header.block_name);
				     symbols (n_com).str_p = addr (addr (rands (n)) -> header.block_name);
				end;
			end;
		     end;
		end;

/* sort the three groups */

		call sort_symbols (1, n_ep);
		call sort_offset (1, n_ep);

		call sort_symbols (n_ep + 1, n_com);
		call sort_offset (n_ep + 1, n_com);

		n = n_ep + n_hdr + 1;
		call sort_symbols (n, n_ref);
		call sort_offset (n, n_ref);

/* print entry point symbols and any ext refs resolved by them */

		if length (output) + 43 > output_max
		then call print$buffer;
		output = output || "
ENTRY POINT         LOC       ATTRIBUTES

";
		first = n;

		do current = 1 to n_ep;
		     sp = addr (rands (symbols (current).offset));

		     full_line = "";
		     line_len = begin_ep_attr - 1;

		     if length_symbol_name (sp) > length (ep_name)
		     then call print$long_name (begin_ep_attr, 0, (symbol_name (sp)));
		     else ep_name = symbol_name (sp);

		     loc = sp -> symbol.address.offset;
		     call binoct (unspec (loc), octal_string);
		     ep_loc = substr (octal_string, 7, 6);

		     blk_sym = addr (rands (sp -> symbol.parent)) -> subprogram.symbol;

		     if blk_sym ^= symbols (current).offset & more_than_one
		     then do;
			     substr (full_line, line_len + 2, 2) = "in";
			     line_len = line_len + 4;

			     if length_symbol_name (addr (rands (blk_sym))) > max_line - line_len
			     then call print$long_name (begin_ep_attr, line_len,
				     (symbol_name (addr (rands (blk_sym)))));
			     else do;
				     loc = length_symbol_name (addr (rands (blk_sym)));
				     substr (full_line, line_len + 1, loc) = symbol_name (addr (rands (blk_sym)));
				     line_len = line_len + loc;
				end;
			end;

		     numb = print_line_number ((sp -> symbol.hash_chain));
		     if line_len + length (numb) + 9 > max_line
		     then call print$line (begin_ep_attr);
		     substr (full_line, line_len + 2, 7) = "on line";
		     substr (full_line, line_len + 10, length (numb)) = numb;
		     line_len = line_len + length (numb) + 9;

		     do while (first <= n_ref
			& symbol_name (sp) > symbol_name (addr (rands (symbols (first).offset))));
			first = first + 1;
		     end;

		     do while (first <= n_ref
			& symbol_name (sp) = symbol_name (addr (rands (symbols (first).offset))));
			if addr (rands (symbols (first).offset)) -> symbol.initial = symbols (current).offset
			then do;
				loc = symbols (first).offset;
				symbols (first).offset = 0;

				blk_sym = addr (rands (addr (rands (loc)) -> symbol.parent)) -> subprogram.symbol;
				last = length_symbol_name (addr (rands (blk_sym)));

				if line_len + 9 + last > max_line
				then call print$line (begin_ep_attr);
				substr (full_line, line_len + 2, 6) = "ref in";
				substr (full_line, line_len + 9, last) = addr (rands (blk_sym)) -> symbol.name;
				line_len = line_len + 9 + last;

				loc = addr (rands (loc)) -> symbol.hash_chain;
				if loc > 0	/* protect unreferenced */
				then do;
					last = cross_reference (loc).symbol;
					call print_crefs (loc, last, begin_ep_attr, "");
				     end;
			     end;

			first = first + 1;
		     end;

		     call print$line (begin_ep_attr);
		end;

/* print external references */

		do first = n_ep + n_hdr + 1 to n_ref while (symbols (first).offset = 0);
		end;

		if first <= n_ref
		then do;
			if length (output) + 43 > output_max
			then call print$buffer;
			output = output || "
EXTERNAL REFERENCE  LOC       ATTRIBUTES

";
			last_loc = -1;

			do current = first to n_ref;
			     if symbols (current).offset > 0
			     then do;
				     sp = addr (rands (symbols (current).offset));

				     full_line = "";
				     line_len = begin_ep_attr - 1;

				     loc = sp -> symbol.address.offset;

				     if loc ^= last_loc
				     then do;
					     last_loc = loc;

					     if length_symbol_name (sp) > length (ep_name)
					     then call print$long_name (begin_ep_attr, 0, (symbol_name (sp)));
					     else ep_name = symbol_name (sp);

					     call binoct (unspec (loc), octal_string);
					     ep_loc = substr (octal_string, 7, 6);
					end;

				     if more_than_one
				     then do;
					     substr (full_line, line_len + 2, 2) = "in";
					     line_len = line_len + 4;

					     blk_sym = addr (rands (sp -> symbol.parent)) -> subprogram.symbol;
					     if length_symbol_name (addr (rands (blk_sym)))
						> max_line - line_len
					     then call print$long_name (begin_ep_attr, line_len,
						     (symbol_name (addr (rands (blk_sym)))));
					     else do;
						     loc = length_symbol_name (addr (rands (blk_sym)));
						     substr (full_line, line_len + 1, loc) =
							symbol_name (addr (rands (blk_sym)));
						     line_len = line_len + loc;
						end;
					end;

				     loc = sp -> symbol.hash_chain;

				     if loc > 0	/* protect if unreffed */
				     then do;
					     last = cross_reference (loc).symbol;
					     call print_crefs (loc, last, begin_ep_attr, "ref");
					end;

				     call print$line (begin_ep_attr);
				end;
			end;
		     end;
		else do;
			if length (output) + 24 > output_max
			then call print$buffer;
			output = output || "
NO EXTERNAL REFERENCES
";
		     end;

		if n_com = n_ep
		then do;
			if length (output) + 18 > output_max
			then call print$buffer;
			output = output || "
NO COMMON BLOCKS
";
		     end;
		else do;
			if length (output) + 50 > output_max
			then call print$buffer;
			output = output || "
COMMON BLOCK        LOC      LENGTH  REFERENCES

";
			n = -1;			/* location of last block */

			do current = n_ep + 1 to n_com;
			     sp = addr (rands (symbols (current).offset));

			     full_line = "";
			     line_len = begin_ep_attr - 1;
			     loc = sp -> header.location;

			     if loc ^= n
			     then do;
				     if length (sp -> header.block_name) > length (ep_name)
				     then call print$long_name (begin_ep_attr, 0, (sp -> header.block_name));
				     else ep_name = sp -> header.block_name;

				     call binoct (unspec (loc), octal_string);
				     ep_loc = substr (octal_string, 7, 6);

				     n = loc;
				end;

			     numb = print_number ((sp -> header.length));
			     if sp -> header.units = bit_units
			     then numb = numb || "B";
			     else if sp -> header.units = char_units
			     then numb = numb || "C";
			     else if sp -> header.units = halfword_units
			     then numb = numb || "H";

			     substr (full_line, begin_ep_attr + 6 - length (numb), length (numb)) = numb;
			     line_len = begin_ep_attr + 6;

			     loc = sp -> header.last_element;
			     last = cross_reference (loc).symbol;
			     call print_crefs (loc, last, begin_ep_attr + 6, "declared");

			     call print$line (begin_ep_attr);
			end;
		     end;
	     end;

	if length (output) + 87 > output_max
	then call print$buffer;

	output = output || FF;
	output = output || "	SOURCE FILES USED IN THIS COMPILATION

LINE      NUMBER   DATE MODIFIED    PATHNAME

";

	do m = 0 to shared_structure.incl_count;
	     string (source_info_line) = "";
	     source_node_ptr = addr (rands (shared_structure.file_list (m).source_node_offset));

	     if m > 0
	     then do;

		     line_no_picture = source_list (source_node_ptr -> source.line_number).line_number_in_file;
		     map_file_no_picture = -source_list (source_node_ptr -> source.line_number).file_number;
		     source_info_line.line_id = ltrim (map_file_no_picture) || ltrim (line_no_picture);

		end;

	     three_digits = m;			/* known to take three digits at most */
	     source_info_line.file_id = three_digits;

	     call date_time_ ((source_node_ptr -> source.dtm), source_info_line.dtm);
	     source_info_line.pathname = source_node_ptr -> source.pathname;

	     if length (output) + length (rtrim (string (source_info_line))) + 1 > output_max
	     then call print$buffer;

	     output = output || rtrim (string (source_info_line));
	     output = output || NL;

	end;

	call close_file;
	return;


print_and_abort:
	call com_err_$suppress_name (code, "fort_listing_generator");
	call close_file;
	return;

close_file:
     procedure;

	if length (output) > 0
	then call iox_$put_chars (iocb, output_ptr, length (output), code);

	if iocb ^= null
	then call iox_$close (iocb, code);

	if iocb ^= null
	then call iox_$detach_iocb (iocb, code);
     end close_file;



get_stmnt_ptr:
     proc (a_ptr) returns (ptr);

dcl	a_ptr		ptr;
dcl	st_ptr		ptr;

	if optimizing
	then do;
		st_ptr = a_ptr;

		stmnt.next = st_ptr -> opt_statement.next;
		stmnt.location = st_ptr -> opt_statement.location;
		unspec (stmnt.source_id) = unspec (st_ptr -> opt_statement.source_id);
		stmnt.length = st_ptr -> opt_statement.length;
		substr (string (stmnt.bits), 1, 2) = substr (string (st_ptr -> opt_statement.bits), 1, 2);
		stmnt.start = st_ptr -> opt_statement.start;

		moved_text = st_ptr -> opt_statement.moved;

		return (addr (stmnt));
	     end;
	else return (a_ptr);
     end get_stmnt_ptr;



sort_offset:
     procedure (sr, fi);

dcl	(sr, fi)		fixed bin (18);
dcl	(i, fir)		fixed bin (18);
dcl	old_str		char (symbols (fir).length) aligned based (symbols (fir).str_p);
dcl	new_str		char (symbols (i).length) aligned based (symbols (i).str_p);

	fir = sr;
	do i = sr + 1 to fi;
	     if old_str ^= new_str
	     then do;
		     call simple_sort (i - 1);
		     fir = i;
		end;
	end;

	call simple_sort (fi);
	return;


simple_sort:
     procedure (last_slot);

dcl	last_slot		fixed bin (18);
dcl	(j, k)		fixed bin (18);

	do j = fir to last_slot - 1;
	     do k = j + 1 to last_slot;
		if symbols (j).offset > symbols (k).offset
		then do;
			swap_temp = symbols (j);
			symbols (j) = symbols (k);
			symbols (k) = swap_temp;
		     end;
	     end;
	end;
     end simple_sort;
     end sort_offset;



print_header:
     procedure;					/* to print header for constants */

	if in_list
	then return;				/* header already printed */
	in_list = "1"b;

	if length (output) + 11 > output_max
	then call print$buffer;

	if more_than_one
	then output = output || FF;
	else output = output || NL;

	output = output || "CONSTANTS
";
     end print_header;

print$buffer:
     procedure;

dcl	leading_columns	fixed bin (18);
dcl	resumption_column	fixed bin (18);
dcl	long_name		char (256) varying;

	call printer;
	return;


print$line:
     entry (resumption_column);

	if length (output) + line_len >= output_max
	then call printer;
	output = output || substr (full_line, 1, line_len);
	output = output || NL;
	full_line = "";
	line_len = resumption_column - 1;
	return;


print$long_name:
     entry (resumption_column, leading_columns, long_name);

	if length (output) + leading_columns + length (long_name) >= output_max
	then call printer;
	if leading_columns > 0
	then output = output || substr (full_line, 1, leading_columns);
	output = output || long_name;
	output = output || NL;
	full_line = "";
	line_len = resumption_column - 1;
	return;


printer:
     procedure;

	call iox_$put_chars (iocb, output_ptr, length (output), code);
	if code ^= 0
	then goto print_and_abort;
	output = "";
     end printer;
     end print$buffer;

print_number:
     procedure (value) returns (char (12) varying);

dcl	number		picture "(11)-9";
dcl	value		fixed bin (18);


	number = value;

	return (substr (number, verify (number, " ")));
     end print_number;

print_line_number:
     procedure (source_info_index) returns (char (12) varying);

dcl	source_info_index	fixed bin (18);
dcl	cref_file		fixed bin (18);
dcl	cref_line		fixed bin (18);
dcl	return_string	char (12) varying initial ("");

	if cross_reference (source_info_index).line_no = 0
	then return ("");

	cref_line = source_list (abs (cross_reference (source_info_index).line_no)).line_number_in_file;

	if cref_line > 0
	then do;
		cref_file = source_list (abs (cross_reference (source_info_index).line_no)).file_number;

		if cref_file > 0
		then return_string = print_number (cref_file) || "-";

		return_string = return_string || print_number (cref_line);
	     end;

	return (return_string);
     end print_line_number;

walk_bucket:
     procedure (bucket_number);

dcl	bucket_number	fixed bin (18);
dcl	i		fixed bin (18);
dcl	n		fixed bin (18);

	n = bucket_number;

	do current = cur_subp -> subprogram.storage_info.first (n) repeat sp -> node.next while (current ^= 0);

	     sp = addr (rands (current));

	     if sp -> node.node_type = symbol_node
	     then call store_item (current);

	     else if sp -> node.node_type = header_node
	     then do;
		     if sp -> header.in_common
		     then call store_item (current);

		     do i = sp -> header.first_element repeat addr (rands (i)) -> symbol.next_member while (i ^= 0);
			call store_item (i);
		     end;
		end;

	     else call print_message (502, current);
	end;
     end walk_bucket;

store_item:
     procedure (node_offset);

dcl	node_offset	fixed bin (18);
dcl	x		fixed bin (18);
dcl	xp		ptr;

	if number_of_operands >= max_number
	then do;
		call print_message (501);		/* too many symbols */

		if last_symbol = 0			/* still doing symbols */
		then do;
			call sort_symbols (1, number_of_operands);
			call print_symbols (1, number_of_operands, "ref");

			number_of_operands = 0;
			number_referenced = 0;
		     end;

		else do;				/* have both symbols and labels */
			call sort_symbols (1, last_symbol);
						/* sort and print all symbols */
			call print_symbols (1, number_referenced, "ref");

			do n = 1 to number_of_operands - last_symbol;
						/* remove all symbols from the list */
			     symbols (n) = symbols (n + last_symbol);
			end;

			number_of_operands = number_of_operands - last_symbol;
			number_referenced = 0;
			last_symbol = 0;
		     end;
	     end;

	x = node_offset;
	xp = addr (rands (x));

	if xp -> node.node_type = symbol_node
	then do;
		if compiler_generated (xp)
		then return;

		number_of_operands = number_of_operands + 1;
		symbols (number_of_operands).offset = x;
		symbols (number_of_operands).length = length_symbol_name (xp);
		symbols (number_of_operands).str_p = addr (xp -> symbol.name);

		xp -> symbol.hash_chain = 0;		/* prevents bad cref output */
	     end;

	else if xp -> node.node_type = label_node
	then do;
		if xp -> label.name <= 0 & ^debuggin_
		then return;			/* eliminate compiler labels */

		number_of_operands = number_of_operands + 1;
		symbols (number_of_operands).offset = x;
		symbols (number_of_operands).length = 2;
		symbols (number_of_operands).str_p = addr (xp -> label.name);

		xp -> label.hash_chain = 0;		/* prevent bad cref output */
	     end;

	else if xp -> node.node_type = header_node
	then do;
		n_hdr = n_hdr + 1;			/* count all headers */
		number_of_operands = number_of_operands + 1;
		symbols (number_of_operands).offset = x;
		symbols (number_of_operands).length = xp -> header.name_length;
		symbols (number_of_operands).str_p = addr (xp -> header.block_name);

		xp -> header.last_element = 0;	/* prevent bad cref output */
	     end;

	else call print_message (502, x);
     end store_item;



compiler_generated:
     proc (sp) returns (bit (1) aligned);

dcl	sp		ptr;

	if debuggin_
	then return ("0"b);				/* Print all symbols when debugging. */
	if length (sp -> symbol.name) = 0
	then return ("1"b);				/* A cg symbol. */
	if substr (sp -> symbol.name, 1, 4) = "ftn."
	then return ("1"b);				/* A parse symbol. */
	if sp -> symbol.by_compiler
	then if sp -> symbol.name = unnamed_block_data_subprg_name
	     then return ("1"b);
	return ("0"b);
     end compiler_generated;

sort_words:
     procedure;

dcl	depth		fixed bin (18);
dcl	divide		builtin;
dcl	first		fixed bin (18);
dcl	high		fixed bin (18);
dcl	last		fixed bin (18);
dcl	low		fixed bin (18);
dcl	median		fixed bin (18);
dcl	swap_temp		bit (36) aligned;
dcl	t		bit (36) aligned;

dcl	1 stack		(0:20) aligned,
	  2 first		fixed bin (18),
	  2 last		fixed bin (18);



	last = number_of_crefs;
	if last <= 1
	then return;

	depth = 0;
	first = 1;
	go to L4;


L1:
	median = divide (first + last, 2, 17, 0);
	t = unspec (cross_reference (median));
	low = first;
	high = last;

	if unspec (cross_reference (first)) > t
	then do;
		unspec (cross_reference (median)) = unspec (cross_reference (first));
		unspec (cross_reference (first)) = t;
		t = unspec (cross_reference (median));
	     end;

	if unspec (cross_reference (last)) < t
	then do;
		unspec (cross_reference (median)) = unspec (cross_reference (last));
		unspec (cross_reference (last)) = t;
		t = unspec (cross_reference (median));

		if unspec (cross_reference (first)) > t
		then do;
			unspec (cross_reference (median)) = unspec (cross_reference (first));
			unspec (cross_reference (first)) = t;
			t = unspec (cross_reference (median));
		     end;

	     end;

L2:
	do high = high - 1 by -1 while (unspec (cross_reference (high)) > t);
	end;

	do low = low + 1 by 1 while (unspec (cross_reference (low)) < t);
	end;

	if low <= high
	then do;
		swap_temp = unspec (cross_reference (high));
		unspec (cross_reference (high)) = unspec (cross_reference (low));
		unspec (cross_reference (low)) = swap_temp;
		go to L2;
	     end;

	if (high - first) > (last - low)
	then do;
		stack.first (depth) = first;
		stack.last (depth) = high;
		first = low;
	     end;

	else do;
		stack.first (depth) = low;
		stack.last (depth) = last;
		last = high;
	     end;

	depth = depth + 1;

L4:
	if (last - first) > 10
	then go to L1;

	if first = 1
	then if first < last
	     then go to L1;

	do first = first + 1 to last;
	     t = unspec (cross_reference (first));
	     do low = first - 1 by -1 while (unspec (cross_reference (low)) > t);
		unspec (cross_reference (low + 1)) = unspec (cross_reference (low));
	     end;
	     unspec (cross_reference (low + 1)) = t;
	end;


	depth = depth - 1;

	if depth >= 0
	then do;
		first = stack.first (depth);
		last = stack.last (depth);
		go to L4;
	     end;
     end sort_words;

sort_symbols:
     procedure (a_initial, a_final);

dcl	a_final		fixed bin (18);
dcl	a_initial		fixed bin (18);
dcl	depth		fixed bin (18);
dcl	first		fixed bin (18);
dcl	first_string	char (symbols (first).length) unaligned based (symbols (first).str_p);
dcl	high		fixed bin (18);
dcl	high_string	char (symbols (high).length) unaligned based (symbols (high).str_p);
dcl	initial		fixed bin (18);
dcl	last		fixed bin (18);
dcl	last_string	char (symbols (last).length) unaligned based (symbols (last).str_p);
dcl	low		fixed bin (18);
dcl	low_string	char (symbols (low).length) unaligned based (symbols (low).str_p);
dcl	median		fixed bin (18);

dcl	1 t		like symbols aligned;
dcl	t_string		char (t.length) unaligned based (t.str_p);

dcl	1 stack		(0:20) aligned,
	  2 first		fixed bin (18),
	  2 last		fixed bin (18);



	first, initial = a_initial;
	last = a_final;
	if last - first <= 0
	then return;

	depth = 0;
	go to L4;


L1:
	median = divide (first + last, 2, 17, 0);
	t = symbols (median);
	low = first;
	high = last;

	if first_string > t_string
	then do;
		symbols (median) = symbols (first);
		symbols (first) = t;
		t = symbols (median);
	     end;

	if last_string < t_string
	then do;
		symbols (median) = symbols (last);
		symbols (last) = t;
		t = symbols (median);

		if first_string > t_string
		then do;
			symbols (median) = symbols (first);
			symbols (first) = t;
			t = symbols (median);
		     end;

	     end;

L2:
	do high = high - 1 by -1 while (high_string > t_string);
	end;

	do low = low + 1 by 1 while (low_string < t_string);
	end;

	if low <= high
	then do;
		swap_temp = symbols (high);
		symbols (high) = symbols (low);
		symbols (low) = swap_temp;
		go to L2;
	     end;

	if (high - first) > (last - low)
	then do;
		stack.first (depth) = first;
		stack.last (depth) = high;
		first = low;
	     end;

	else do;
		stack.first (depth) = low;
		stack.last (depth) = last;
		last = high;
	     end;

	depth = depth + 1;

L4:
	if (last - first) > 10
	then go to L1;

	if first = initial
	then if first < last
	     then go to L1;

	do first = first + 1 to last;
	     t = symbols (first);
	     do low = first - 1 by -1 while (low_string > t_string);
		symbols (low + 1) = symbols (low);
	     end;
	     symbols (low + 1) = t;
	end;


	depth = depth - 1;

	if depth >= 0
	then do;
		first = stack.first (depth);
		last = stack.last (depth);
		go to L4;
	     end;
     end sort_symbols;

binoct:
     procedure (number, string);

dcl	number		bit (36) aligned;
dcl	string		char (12) aligned;

dcl	ioa_$rsnnl	entry options (variable);

	call ioa_$rsnnl ("^w", string, 12, number);
     end binoct;

print_symbols:
     procedure (initial, final, head);

dcl	a		fixed bin (18);
dcl	dp		ptr;
dcl	final		fixed bin (18);
dcl	hdr		char (8) varying;
dcl	head		char (8) varying;
dcl	i		fixed bin (18);
dcl	initial		fixed bin (18);
dcl	iptr		ptr;
dcl	item		fixed bin (18);
dcl	n		fixed bin (18);
dcl	z		fixed bin (18);

	do item = initial to final;
	     iptr = addr (rands (symbols (item).offset));

	     hdr = head;				/* use header supplied by user (may be changed) */

	     full_line = "";
	     line_len = begin_refs - 1;

/* print symbol table entry */

	     if iptr -> node.node_type = symbol_node	/* SYMBOL NODE */
	     then do;
		     a = iptr -> symbol.hash_chain;	/* first cross reference entry */
		     if a > 0			/* i.e., there are cref nodes */
		     then z = cross_reference (a).symbol;
						/* last entry */
		     else z = -1;			/* must be < a */

		     if length_symbol_name (iptr) > length (sym_name)
		     then call print$long_name (begin_refs, 0, symbol_name (iptr));
		     else sym_name = symbol_name (iptr);

/* special attributes */

		     if iptr -> symbol.entry_point
		     then do;
			     sym_type = "entry point";
			     hdr = "on line";
			end;

		     else if iptr -> symbol.builtin
		     then sym_type = "builtin";

		     else if iptr -> symbol.external
		     then do;
			     if iptr -> symbol.initial = 0
			     then sym_type = "external";
			     else sym_type = "internal";

			     if iptr -> symbol.function
			     then substr (sym_type, 10, 8) = "function";
			     else if iptr -> symbol.subroutine
			     then substr (sym_type, 10, 10) = "subroutine";
			end;

		     else if iptr -> symbol.stmnt_func
		     then sym_type = "statement function";

		     else if iptr -> symbol.namelist
		     then sym_type = "namelist";

		     else if iptr -> symbol.named_constant
		     then sym_type = "named constant";

		     else if iptr -> symbol.dummy_arg
		     then sym_type = "st func parameter";

/* storage class */

		     if iptr -> symbol.LA & iptr -> symbol.parent ^= 0
		     then do;
			     call print_offset;

			     dp = addr (rands (iptr -> symbol.parent));

			     loc = dp -> header.location;
			     call binoct (unspec (loc), octal_string);
			     if iptr -> symbol.automatic
			     then call print$long_name (begin_refs, begin_class,
				     "la$auto$" || ltrim (substr (octal_string, 7, 6), "0"));
			     else call print$long_name (begin_refs, begin_class,
				     "la$static$" || ltrim (substr (octal_string, 7, 6), "0"));
			end;
		     else if iptr -> symbol.VLA & iptr -> symbol.parent ^= 0
		     then do;
			     call print_offset;

			     dp = addr (rands (iptr -> symbol.parent));

			     if iptr -> symbol.automatic
			     then call print$long_name (begin_refs, begin_class,
				     "vla$auto$" || addr (rands (dp -> header.first_element)) -> symbol.name);
			     else if iptr -> symbol.static
			     then call print$long_name (begin_refs, begin_class,
				     "vla$static$" || addr (rands (dp -> header.first_element)) -> symbol.name);
			     else do;
				     if dp -> header.block_name = blank_common_name
				     then call print$long_name (begin_refs, begin_class, "vla$common$_");
				     else call print$long_name (begin_refs, begin_class,
					     "vla$common$" || dp -> header.block_name);
				end;
			end;

		     else if iptr -> symbol.in_common
		     then do;
			     call print_offset;

			     dp = addr (rands (iptr -> symbol.parent));
			     n = length (dp -> header.block_name);

			     if dp -> header.block_name = blank_common_name
			     then sym_class = "//";
			     else if n > length (sym_class) - 2
						/* symbol overflows the field */
			     then call print$long_name (begin_refs, begin_class,
				     "/" || dp -> header.block_name || "/");
			     else do;
				     substr (sym_class, 1, 1) = "/";
				     substr (sym_class, 2, n) = dp -> header.block_name;
				     substr (sym_class, n + 2, 1) = "/";
				end;
			end;

		     else if iptr -> symbol.parameter
		     then if iptr -> symbol.VLA
			then sym_class = "vla$parm";
			else sym_class = "parameter";

		     else if iptr -> symbol.automatic
		     then do;
			     call print_offset;
			     sym_class = "automatic";
			end;

		     else if iptr -> symbol.static
		     then do;
			     call print_offset;
			     sym_class = "static";
			end;

		     else if iptr -> symbol.constant
		     then do;
			     if iptr -> symbol.address.offset > 0
			     then call print_offset;
			     sym_class = "constant";
			end;

/* mode */

		     if iptr -> symbol.parameter
		     then if iptr -> symbol.stack_indirect
			then do;
				if line_len + 18 > max_line
				then call print$line (begin_refs);
				substr (full_line, line_len + 2, 17) = "several positions";
				line_len = line_len + 18;
			     end;
			else do;
				if iptr -> symbol.referenced
				then numb = print_number (divide (iptr -> symbol.location, 2, 17, 0));
				else numb = print_number ((iptr -> symbol.location));

				if line_len + length (numb) + 10 > max_line
				then call print$line (begin_refs);
				substr (full_line, line_len + 2, 8) = "position";
				substr (full_line, line_len + 11, length (numb)) = numb;
				line_len = line_len + length (numb) + 10;
			     end;

		     if iptr -> symbol.external
		     then do;

			     if iptr -> symbol.initial ^= 0 & iptr -> symbol.initial < symbols (item).offset
			     then do;
				     numb =
					print_line_number
					((addr (rands (iptr -> symbol.initial)) -> symbol.hash_chain));

				     if line_len + 9 + length (numb) > max_line
				     then call print$line (begin_refs);
				     substr (full_line, line_len + 2, 7) = "on line";
				     substr (full_line, line_len + 10, length (numb)) = numb;
				     line_len = line_len + 9 + length (numb);
				end;

			     if iptr -> symbol.needs_descriptors
			     then do;
				     if line_len + 17 > max_line
				     then call print$line (begin_refs);
				     substr (full_line, line_len + 2, 16) = "with descriptors";
				     line_len = line_len + 17;
				end;
			end;

		     if iptr -> symbol.integer
		     then do;
			     if line_len + 8 > max_line
			     then call print$line (begin_refs);
			     substr (full_line, line_len + 2, 7) = "integer";
			     line_len = line_len + 8;
			end;

		     else if iptr -> symbol.real
		     then do;
			     if line_len + 5 > max_line
			     then call print$line (begin_refs);
			     substr (full_line, line_len + 2, 4) = "real";
			     line_len = line_len + 5;
			end;

		     else if iptr -> symbol.double_precision
		     then do;
			     if line_len + 17 > max_line
			     then call print$line (begin_refs);
			     substr (full_line, line_len + 2, 16) = "double precision";
			     line_len = line_len + 17;
			end;

		     else if iptr -> symbol.complex
		     then do;
			     if line_len + 8 > max_line
			     then call print$line (begin_refs);
			     substr (full_line, line_len + 2, 7) = "complex";
			     line_len = line_len + 8;
			end;

		     else if iptr -> symbol.logical
		     then do;
			     if line_len + 8 > max_line
			     then call print$line (begin_refs);
			     substr (full_line, line_len + 2, 7) = "logical";
			     line_len = line_len + 8;
			end;

		     else if iptr -> symbol.character
		     then do;
			     if iptr -> symbol.star_extents
			     then numb = "*";
			     else numb = print_number (iptr -> symbol.char_size + 1);

			     if line_len + length (numb) + 12 > max_line
			     then call print$line (begin_refs);
			     substr (full_line, line_len + 2, 10) = "character(";
			     substr (full_line, line_len + 12, length (numb) + 1) = numb || ")";
			     line_len = line_len + length (numb) + 12;
			end;

		     if iptr -> symbol.dimensioned
		     then do;
			     if line_len + 9 > max_line
			     then call print$line (begin_refs);
			     substr (full_line, line_len + 2, 6) = "array(";
			     line_len = line_len + 7;

			     dp = addr (rands (iptr -> symbol.dimension));
			     do n = 1 to dp -> dimension.number_of_dims;

				call print_dim_bound (dp -> dimension.lower_bound (n),
				     (dp -> dimension.v_bound (n).lower));

				substr (full_line, line_len + 1, 1) = ":";
				line_len = line_len + 1;

				if (n = dp -> dimension.number_of_dims)
				     & dp -> dimension.assumed_size
				then do;
					if line_len + 2 > max_line
					then call print$line (begin_refs);
					substr (full_line, line_len + 1, 1) = "*";
					line_len = line_len + 1;
				     end;
				else call print_dim_bound (dp -> dimension.upper_bound (n),
					(dp -> dimension.v_bound (n).upper));

				if n = dp -> dimension.number_of_dims
				then substr (full_line, line_len + 1, 1) = ")";
				else substr (full_line, line_len + 1, 1) = ",";
				line_len = line_len + 1;
			     end;
			end;

		     if iptr -> symbol.equivalenced & ^iptr -> symbol.in_common
		     then do;
			     if line_len + 13 > max_line
			     then call print$line (begin_refs);
			     substr (full_line, line_len + 2, 12) = "equivalenced";
			     line_len = line_len + 13;
			end;

		     if iptr -> symbol.initialed
		     then do;
			     if line_len + 12 > max_line
			     then call print$line (begin_refs);
			     substr (full_line, line_len + 2, 11) = "initialized";
			     line_len = line_len + 12;
			end;

		     if iptr -> symbol.by_compiler & debuggin_
		     then do;
			     if line_len + 12 > max_line
			     then call print$line (begin_refs);
			     substr (full_line, line_len + 2, 11) = "by compiler";
			     line_len = line_len + 12;
			end;

		     call print_crefs (a, z, begin_refs, hdr);
		end;


	     else if iptr -> node.node_type = label_node	/* LABEL NODE */
	     then do;
		     call binoct (unspec (iptr -> label.address), octal_string);
		     if substr (octal_string, 1, 6) ^= "000000"
		     then lbl_loc = substr (octal_string, 1, 6);

		     if iptr -> label.name <= 99999
		     then do;
			     line_no_picture = iptr -> label.name;
			     lbl_name = line_no_picture;
			end;
		     else substr (lbl_name, 5, 6) = ">99999";

		     if string (iptr -> label.usage) = "11"b
		     then lbl_type = "unusable";
		     else if iptr -> label.format
		     then lbl_type = "format";
		     else lbl_type = "executable";

		     a = iptr -> label.hash_chain;	/* first cross reference entry */
		     if a > 0			/* i.e., there are cref nodes */
		     then z = cross_reference (a).symbol;
						/* last entry */
		     else z = -1;			/* must be < a */

		     if iptr -> label.set
		     then do;
			     line_len = begin_line - 1;

			     if a > 0
			     then do while (a <= z & cross_reference (z).line_no < 0);
				     numb = print_line_number (z);
				     if line_len + length (numb) + 1 > max_line
				     then call print$line (begin_refs);
				     substr (full_line, line_len + 2, length (numb)) = numb;
				     line_len = line_len + length (numb) + 1;
				     z = z - 1;
				end;

			     if line_len < begin_refs - 1
			     then line_len = begin_refs - 1;
			end;
		     else lbl_line = "undefined";

		     if iptr -> label.referenced_executable & ^iptr -> label.format
		     then do;
			     if line_len + 17 > max_line
			     then call print$line (begin_refs);
			     substr (full_line, line_len + 2, 16) = "used in transfer";
			     line_len = line_len + 17;
			end;

		     if iptr -> label.name <= 0
		     then do;
			     if line_len + 12 > max_line
			     then call print$line (begin_refs);
			     substr (full_line, line_len + 2, 11) = "by compiler";
			     line_len = line_len + 12;
			end;

		     call print_crefs (a, z, begin_refs, hdr);
		end;

	     else do;				/* HEADER NODE */
		     if length (iptr -> header.block_name) > length (sym_name)
		     then call print$long_name (begin_refs, 0, (iptr -> header.block_name));
		     else sym_name = iptr -> header.block_name;

		     sym_type = "common block name";

		     numb = print_number ((iptr -> header.length));

		     if numb = "1"
		     then i = 6;
		     else i = 7;

		     if line_len + length (numb) + i > max_line
		     then call print$line (begin_refs);

		     substr (full_line, line_len + 2, length (numb)) = numb;
		     if iptr -> header.units = word_units
		     then substr (full_line, line_len + length (numb) + 3, i - 2) = substr ("words", 1, i - 2);
		     else if iptr -> header.units = bit_units
		     then substr (full_line, line_len + length (numb) + 3, i - 2) = substr (" bits", 1, i - 2);
		     else if iptr -> header.units = char_units
		     then substr (full_line, line_len + length (numb) + 3, i - 2) = substr ("chars", 1, i - 2);
		     else if iptr -> header.units = halfword_units
		     then do;
			     i = i + 5;		/* space for "half_" */
			     substr (full_line, line_len + length (numb) + 3, i - 2) =
				substr ("half_words", 1, i - 2);
			end;

		     line_len = line_len + length (numb) + i;

		     a = iptr -> header.last_element;
		     if a > 0			/* i.e., there are cref nodes */
		     then z = cross_reference (a).symbol;
						/* last entry */
		     else z = -1;			/* must be < a */

		     call print_crefs (a, z, begin_refs, hdr);
		end;

	     call print$line (begin_refs);
	end;
	return;


print_offset:
     procedure;

	if iptr -> symbol.VLA
	then call binoct (unspec (iptr -> symbol.offset), octal_string);
	else do;
		loc = iptr -> symbol.address.offset;
		if iptr -> symbol.large_address
		then loc = loc + iptr -> symbol.location;
		call binoct (unspec (loc), octal_string);
	     end;

	sym_loc = substr (octal_string, 5, 8);

/* print bit offset if it applies */

	loc = iptr -> symbol.address.char_num * 9;
	if loc = 0
	then sym_char = "";
	else sym_char = "(" || print_number ((loc)) || ")";

     end print_offset;


print_dim_bound:
     procedure (bound, variable);

dcl	bound		fixed bin (24);		/* Bound value or operand offset */
dcl	Symbol_for_expression
			char (1) static options (constant) init ("#");

dcl	variable		bit (1) aligned;		/* On if bound is operand offset */

dcl	bp		pointer;			/* Pointer to bound variable */
dcl	name_length	fixed bin (18);		/* Length of variable name */
dcl	name_ptr		ptr;			/* Address of variable name. */

dcl	name		char (name_length) based (name_ptr);


	if variable
	then do;

		if bound = 0
		then do;

/* Bound should be variable, but has not been set */

			if line_len + 10 > max_line
			then call print$line (begin_refs);
			substr (full_line, line_len + 1, 9) = "undefined";
			line_len = line_len + 9;
		     end;

		else do;

/* Bound is variable; print a suitable name. */

			bp = addr (rands (bound));
			if bp -> symbol.by_compiler
			then if polish (bp -> symbol.initial - 1) = 1
			     then do;		/* Bound is value of a variable. */
				     bp = addr (rands (polish (bp -> symbol.initial)));
				     name_ptr = addr (bp -> symbol.name);
				     name_length = length (bp -> symbol.name);
				end;
			     else do;		/* Bound is value of an expression. */
				     name_ptr = addr (Symbol_for_expression);
				     name_length = length (Symbol_for_expression);
				end;
			else do;			/* Bound is a variable. */
				name_ptr = addr (bp -> symbol.name);
				name_length = length (bp -> symbol.name);
			     end;
			if line_len + name_length + 1 > max_line
			then if name_length > max_line - begin_refs
			     then do;
				     call print$long_name (begin_refs, line_len, (name));
				     name_length = 0;
				end;
			     else call print$line (begin_refs);

			if name_length > 0
			then substr (full_line, line_len + 1, name_length) = name;
			line_len = line_len + name_length;
		     end;
	     end;

	else do;

/* The bound is constant */

		numb = print_number ((bound));
		if line_len + length (numb) + 1 > max_line
		then call print$line (begin_refs);
		substr (full_line, line_len + 1, length (numb)) = numb;
		line_len = line_len + length (numb);
	     end;

     end print_dim_bound;
     end print_symbols;

print_crefs:
     procedure (first_cr, last_cr, begin_col, cref_hdr);

dcl	begin_col		fixed bin (18);
dcl	cref_hdr		char (8) varying;
dcl	cref_index	fixed bin (18);
dcl	first_cr		fixed bin (18);
dcl	last_cr		fixed bin (18);

	if last_cr < first_cr
	then return;

	if cross_reference (first_cr).line_no > 0 & length (cref_hdr) > 0
	then do;
		if line_len + length (cref_hdr) + 2 > max_line
		then call print$line (begin_col);
		substr (full_line, line_len + 2, length (cref_hdr)) = cref_hdr;
		line_len = line_len + length (cref_hdr) + 2;
	     end;

	do cref_index = first_cr to last_cr;

	     if cross_reference (cref_index).line_no > 0
	     then do;
		     numb = print_line_number (cref_index);
		     if line_len + length (numb) + 1 > max_line
		     then call print$line (begin_col);
		     substr (full_line, line_len + 1, length (numb)) = numb;
		     line_len = line_len + length (numb) + 1;
		end;
	end;
     end print_crefs;

length_symbol_name:
     proc (sp) returns (fixed bin (18));

dcl	sp		ptr;

/* routine to return length of symbol.  If symbol is compiler generated, and
   has a zero length name, then a 9 character name would be generated. */


	if sp -> symbol.name_length = 0 & sp -> symbol.by_compiler
	then return (9);
	else return (sp -> symbol.name_length);
     end length_symbol_name;


symbol_name:
     proc (sp) returns (char (*));


/* routine to return name of symbol.  If symbol is compiler generated, and
   has a zero length name, generate the name of cg.oooooo, where the oooooo
   is the octal address of the symbol node. */

dcl	sp		ptr;


	if sp -> symbol.name_length > 0
	then return (sp -> symbol.name);


	if sp -> symbol.by_compiler
	then do;
		call binoct (unspec (rel (sp)), octal_string);

		return ("cg." || substr (octal_string, 1, 6));
	     end;
	else return ("");
     end symbol_name;

/* program to display output text produced by pl/1 or fortran

   Initial Version: 17 October, 1968
	Modified: 01 October 1979 by PES to list char*(*) variables as char*(*).
	Modified: 12 September 1979 by CRD to fix bug 239 (-16384).
	Modified: 06 December 1978 by PES for %options and %global
	Modified: 25 October 1978 by PES for larger common and arrays.
	Modified: 19 August 1972 by BLW
	Modified:	20 February 1973 by RAB for multiple base-regs
	Modified:	3 July 1973 by RAB for EIS
	Modified: 30 September 1976 by DSL for new fortran compiler
	Modified: 12 May 1977 by DSL for new operator name convention
*/

display_text:
     proc (first_word, last_word);

dcl	first_word	fixed bin (18);
dcl	last_word		fixed bin (18);

dcl	(i, j, k, m, mop, save_k, irand, nrands, ndesc)
			fixed bin (18),
	(fract_offset, offset, size, scale)
			fixed bin (18),
	(ignore_ic_mod, double, eis, eis_desc, need_comma, ext_base, itag, has_ic, decimal)
			bit (1) aligned,
	htht		char (2) int static options (constant) aligned init ("		"),
						/* two tabs */
	pt		ptr,
	c		char (1),
	op_code		char (5),
	tag		char (3),
	line		char (256),
	pl1_operators_$operator_table
			fixed bin ext;

dcl	(fixed, length, min, ptr, rel)
			builtin;

dcl	pl1_operator_names_$pl1_operator_names_
			ext static;

%include op_mnemonic_dcl_;

dcl	1 name_pair	aligned based,
	  2 rel_ptr	unaligned bit (18),		/* ptr to ascii string */
	  2 size		unaligned bit (18);		/* size of string */

dcl	based_string	aligned char (size) based;

dcl	digit		(0:9) char (1) aligned int static options (constant)
			init ("0", "1", "2", "3", "4", "5", "6", "7", "8", "9");

dcl	relocation	(-1:11) char (1) aligned int static options (constant)
			init ("a", "t", "1", "2", "3", "l", "d", "s", "7", "8", "i", "r", "e");

dcl	base		(0:7) char (4) aligned int static options (constant)
			init ("pr0|", "pr1|", "pr2|", "pr3|", "pr4|", "pr5|", "pr6|", "pr7|");

dcl	modifier		(0:63) char (3) aligned int static options (constant)
			init ("n", "au", "qu", "du", "ic", "al", "ql", "dl", "0", "1", "2", "3", "4", "5", "6", "7",
			"*", "au*", "qu*", "...", "ic*", "al*", "ql*", "...", "0*", "1*", "2*", "3*", "4*", "5*",
			"6*",
			"7*", (8) (1)"...", (8) (1)"...", "*n", "*au", "*qu", "...", "*ic", "*al", "*ql", "...",
			"*0",
			"*1", "*2", "*3", "*4", "*5", "*6", "*7");

dcl	1 instruction	(0:261119) based (object_base) aligned,
	  2 base		unaligned bit (3),
	  2 offset	unaligned bit (15),
	  2 op_code	unaligned bit (10),
	  2 unused	unaligned bit (1),
	  2 ext_base	unaligned bit (1),
	  2 tag		unaligned bit (6);

dcl	1 half		(0:261119) based (object_base) aligned,
	  2 left		unaligned bit (18),
	  2 right		unaligned bit (18);

dcl	1 rel_tab		(0:261119) based (rel_base) aligned,
	  2 dummy_l	unaligned bit (14),
	  2 left		unaligned bit (4),
	  2 dummy_r	unaligned bit (14),
	  2 right		unaligned bit (4);

dcl	1 mod_factor	aligned,
	  2 ext_base	bit (1) unal,
	  2 length_in_reg	bit (1) unal,
	  2 indirect_descriptor
			bit (1) unal,
	  2 tag		bit (4) unal;

dcl	mf		(3) fixed bin (6) int static options (constant) init (30, 12, 3);
						/* location of modification factor fields in EIS inst */

dcl	(ebase, len_reg, ic)
			(3) bit (1) aligned;
dcl	desc_word		char (8) varying;

dcl	desc_op		(0:3) char (8) varying int static options (constant)
			init ("desc9a", "descb", "desc9fl", "desc9ls");

dcl	eis_modifier	(0:15) char (3) aligned int static options (constant)
			init ("n", "au", "qu", "du", "ic", "al", "ql", "...", "x0", "x1", "x2", "x3", "x4", "x5",
			"x6",
			"x7");

dcl	bool_word		(0:15) char (6) aligned int static options (constant) varying
			init ("clear", "and", "andnot", "move", "", "", "xor", "or", "", "", "", "", "invert", "",
			"nand", "set");

dcl	1 descriptor	based aligned,		/* EIS descriptor */
	  2 address	bit (18) unal,
	  2 char		bit (2) unal,
	  2 bit		bit (4) unal,
	  2 length	bit (12) unal;

dcl	char		builtin;


%include operator_names;

/* begin display text */

	op_names_pt = addr (pl1_operator_names_$pl1_operator_names_);

	eis = "0"b;
	irand = 0;

	do i = first_word to last_word;

	     tag = "   ";
	     call binoct (unspec (i), octal_string);
	     substr (line, 1, 6) = substr (octal_string, 7, 6);
	     substr (line, 7, 2) = "  ";

	     call insert_relocation;

	     call binoct (object (i), octal_string);

	     if sym_info (i) < 0			/* negative value is used as flag to indicate */
	     then goto not_ins;			/* that word is definitely not an instruction */

	     if instruction (i).unused
	     then goto not_ins;

	     if ^eis
	     then do;
		     mop = fixed (instruction (i).op_code, 10);
		     op_code = op_mnemonic_$op_mnemonic_ (mop).name;
		end;
	     else do;
		     mop = 0;
		end;

	     if op_code = ".... "
	     then do;
not_ins:
		     substr (line, 13, 3) = "   ";
		     substr (line, 16, 12) = octal_string;
		     k = 28;
		     goto prt;
		end;

	     if op_mnemonic_$op_mnemonic_ (mop).num_words > 1
	     then do;

/* EIS */

		     call init_eis;

		     substr (line, 13, 4) = substr (octal_string, 1, 3);
		     substr (line, 17, 4) = substr (octal_string, 4, 3);
		     substr (line, 21, 4) = substr (octal_string, 7, 3);
		     substr (line, 25, 3) = substr (octal_string, 10, 3);

		     substr (line, 28, 1) = TB;
		     substr (line, 29, 5) = op_code;
		     substr (line, 34, 1) = TB;

		     k = 35;

		     do j = 1 to ndesc;
			string (mod_factor) = substr (object (i), mf (j), 7);
			ebase (j) = mod_factor.ext_base;
			len_reg (j) = mod_factor.length_in_reg;

			substr (line, k, 1) = "(";
			k = k + 1;
			need_comma = "0"b;

			if ebase (j)
			then do;
				substr (line, k, 2) = "pr";
				k = k + 2;
				need_comma = "1"b;
			     end;

			if len_reg (j)
			then do;
				if need_comma
				then do;
					substr (line, k, 1) = ",";
					k = k + 1;
				     end;
				substr (line, k, 2) = "rl";
				k = k + 2;
				need_comma = "1"b;
			     end;

			if mod_factor.tag
			then do;
				if need_comma
				then do;
					substr (line, k, 1) = ",";
					k = k + 1;
				     end;
				ic (j) = mod_factor.tag = "0100"b;
						/* IC */
				substr (line, k, 2) = eis_modifier (fixed (mod_factor.tag, 4));
				k = k + 2;
			     end;
			else ic (j) = "0"b;

			substr (line, k, 2) = "),";
			k = k + 2;
		     end;


		     if substr (object (i), 10, 1)
		     then do;
			     substr (line, k, 12) = "enablefault,";
			     k = k + 12;
			end;

		     if desc_word = "desc9a"
		     then if ndesc < 3
			then do;
				if substr (op_code, 1, 2) ^= "sc"
				then substr (line, k, 5) = "fill(";
				else substr (line, k, 5) = "mask(";
				k = k + 5;
				substr (line, k, 3) = substr (octal_string, 1, 3);
				k = k + 3;
				substr (line, k, 1) = ")";
				k = k + 1;
			     end;
			else k = k - 1;
		     else if desc_word = "descb"
		     then do;
			     substr (line, k, 5) = "fill(";
			     k = k + 5;
			     substr (line, k, 1) = digit (fixed (substr (object (i), 1, 1), 1));
			     k = k + 1;
			     substr (line, k, 1) = ")";
			     k = k + 1;
			     if op_code ^= "cmpb "
			     then do;
				     substr (line, k, 6) = ",bool(";
				     k = k + 6;
				     j = fixed (substr (object (i), 6, 4), 4);
				     m = length (bool_word (j));
				     if m > 0
				     then do;
					     substr (line, k, m) = bool_word (j);
					     k = k + m;
					end;
				     else do;
					     substr (line, k, 1) = digit (fixed (substr (object (i), 6, 1), 1));
					     substr (line, k + 1, 1) =
						digit (fixed (substr (object (i), 7, 3), 3));
					     k = k + 2;
					end;
				     substr (line, k, 1) = ")";
				     k = k + 1;
				end;
			end;
		     else if substr (object (i), 11, 1)
		     then do;
			     substr (line, k, 5) = "round";
			     k = k + 5;
			end;
		     else k = k - 1;

		     irand = 0;
		     go to prt;
		end;

	     double, ignore_ic_mod = "0"b;

	     eis_desc = eis & desc_word ^= "arg";
	     if eis_desc
	     then do;
		     substr (line, 13, 2) = "  ";
		     substr (line, 15, 6) = substr (octal_string, 2, 5);
		     substr (line, 21, 3) = substr (octal_string, 7, 2);
		     substr (line, 24, 4) = substr (octal_string, 9, 4);

		     substr (line, 28, 1) = TB;

		     if decimal
		     then desc_word = desc_op (2 + fixed (addr (object (i)) -> descriptor.bit, 4));
		     if irand > 1
		     then if op_code = "dtb  " | op_code = "mvne "
			then desc_word = desc_op (0);
			else ;
		     else if op_code = "btd  "
		     then desc_word = desc_op (0);

		     substr (line, 29, length (desc_word)) = desc_word;
		     k = length (desc_word) + 29;

		     ext_base = ebase (irand);
		     itag = len_reg (irand);
		     if itag
		     then tag = eis_modifier (fixed (substr (addr (object (i)) -> descriptor.length, 9, 4), 4));
		     has_ic = ic (irand);
		     go to chk_ext;
		end;

	     if op_code = "rpd  "
	     then goto set;
	     if op_code = "rpt  "
	     then goto set;

	     if op_mnemonic_$op_mnemonic_ (mop).num_desc ^= 0
	     then do;
		     call binoct ((instruction (i).tag), octal_string);
		     tag = substr (octal_string, 1, 2);
		     ignore_ic_mod = "1"b;
		     goto set;
		end;

	     if instruction (i).tag ^= "0"b
	     then do;
		     tag = modifier (fixed (instruction (i).tag, 6));
		     if tag = "..."
		     then goto not_ins;
		end;

set:
	     substr (line, 13, 2) = "  ";
	     substr (line, 15, 6) = substr (octal_string, 2, 5);
	     substr (line, 21, 5) = substr (octal_string, 7, 4);
	     substr (line, 26, 2) = substr (octal_string, 11, 2);

	     substr (line, 28, 1) = TB;
	     k = 29;

	     substr (line, k, 5) = op_code;

	     c = substr (line, k + 3, 1);

	     double = substr (op_code, 1, 2) = "df" | substr (op_code, 3, 2) = "aq" | substr (op_code, 4, 2) = "aq";

	     ext_base = instruction (i).ext_base;
	     itag = instruction (i).tag ^= "000000"b;
	     has_ic = instruction (i).tag = "000100"b;	/* IC */

	     k = 34;
chk_ext:
chk_ext1:
	     substr (line, k, 1) = TB;
	     k = k + 1;

	     save_k = k;

	     if ^eis
	     then if instruction (i).unused
		then do;

/* have rpd | rpt instruction */

			tag = digit (fixed (instruction (i).tag, 6));
			offset = fixed (substr (half (i).left, 1, 8), 8);
			ignore_ic_mod = "1"b;
			goto sk;
		     end;

	     if ext_base
	     then do;
		     substr (line, k, 4) = base (fixed (instruction (i).base, 3));
		     offset = fixed (instruction (i).offset, 15);
		     if offset >= 16384
		     then offset = offset - 32768;
		     k = k + 4;
		     j = 13;
		end;
	     else do;
		     offset = fixed (half (i).left, 18);

		     if offset >= 131072
		     then do;
			     if tag = "du "
			     then goto sk;
			     if tag = "dl "
			     then goto sk;
			     offset = offset - 262144;/* 2's comp */
			end;

sk:
		     j = 14;
		end;

	     substr (line, j, 1) = octal_string;

	     call bin2dec (offset);

	     if eis_desc
	     then do;
		     if desc_word = "descb"
		     then fract_offset =
			     fixed (addr (object (i)) -> descriptor.char, 2) * bits_per_char
			     + fixed (addr (object (i)) -> descriptor.bit, 4);
		     else fract_offset = fixed (addr (object (i)) -> descriptor.char, 2);
		     if fract_offset ^= 0
		     then do;
			     substr (line, k, 1) = "(";
			     k = k + 1;
			     call bin2dec (fract_offset);
			     substr (line, k, 1) = ")";
			     k = k + 1;
			end;
		end;

	     if itag
	     then do;
		     substr (line, k, 1) = ",";
		     substr (line, k + 1, 3) = tag;

		     k = k + 2;
		     if substr (line, k, 1) ^= " "
		     then k = k + 1;
		     if substr (line, k, 1) ^= " "
		     then k = k + 1;
		end;
	     else if eis_desc
	     then do;
		     substr (line, k, 1) = ",";
		     k = k + 1;
		     if desc_word = "desc9ls"
		     then do;
			     call bin2dec (fixed (substr (addr (object (i)) -> descriptor.length, 7, 6), 6));
			     substr (line, k, 1) = ",";
			     k = k + 1;
			     scale = fixed (substr (addr (object (i)) -> descriptor.length, 1, 6), 6);
			     if scale >= 32
			     then scale = scale - 64;
			     call bin2dec (scale);
			end;
		     else call bin2dec (fixed (addr (object (i)) -> descriptor.length, 12));
		end;

	     if ignore_ic_mod
	     then goto chk_base;

	     if has_ic
	     then do;
		     substr (line, k, 2) = htht;
		     k = k + 2;

		     pt = addr (object (i + offset - irand));
		     call binoct (rel (pt), octal_string);
		     substr (line, k, 6) = substr (octal_string, 1, 6);

		     k = k + 6;

		     if substr (op_code, 1, 1) = "t"
		     then goto prt;
		     if fixed (rel (pt), 18) > text_pos
		     then goto prt;

		     substr (line, k, 1) = " ";
		     k = k + 1;

equal:
		     substr (line, k, 2) = "= ";
		     call binoct (pt -> object (0), octal_string);
		     substr (line, k + 2, 12) = octal_string;
		     k = k + 14;

		     if double
		     then do;
			     substr (line, k, 1) = " ";
			     call binoct (pt -> object (1), octal_string);
			     substr (line, k + 1, 12) = octal_string;
			     k = k + 13;
			end;

		     goto prt;
		end;

chk_base:
	     if ^ext_base
	     then goto prt;

	     if instruction (i).base ^= "000"b
	     then do;
		     if sym_info (i) <= 0
		     then goto prt;

		     pt = addr (rands (sym_info (i)));

		     j = 2 - divide (k - save_k, 10, 17, 0);
		     substr (line, k, j) = htht;
		     k = k + j;

		     if pt -> node.node_type = symbol_node
		     then if compiler_generated (pt)
			then ;
			else do;
				j = length (pt -> symbol.name);
				substr (line, k, j) = pt -> symbol.name;
				k = k + j;
				goto prt;
			     end;

		     else if pt -> node.node_type = label_node
		     then if pt -> label.name <= 0 & ^debuggin_
			then ;
			else do;
				numb = print_number ((pt -> label.name));

				substr (line, k, 16) = "statement label ";
				substr (line, k + 16, length (numb)) = numb;
				k = k + 16 + length (numb);
				goto prt;
			     end;

		     else if pt -> node.node_type = header_node
		     then if ^pt -> header.in_common
			then ;
			else do;
				j = length (pt -> header.block_name);
				substr (line, k, j) = pt -> header.block_name;
				k = k + j;
				goto prt;
			     end;

		     else if pt -> node.node_type = array_ref_node & pt -> array_ref.parent > 0
		     then do;
			     pt = addr (rands (pt -> array_ref.parent));
			     j = length (pt -> symbol.name);
			     substr (line, k, j) = pt -> symbol.name;
			     k = k + j;
			     goto prt;
			end;

		     k = k - j;			/* remove the tabs */
		     goto prt;
		end;

	     if op_code = "xec  "
	     then do;
		     pt = addrel (addr (pl1_operators_$operator_table), offset);
		     mop = fixed (pt -> instruction (0).op_code, 10);
		     if op_mnemonic_$op_mnemonic_ (mop).num_words > 1
		     then do;

/* we are executing an EIS instruction in pl1_operators_ */

			     call init_eis;

			     do j = 1 to ndesc;
				ebase (j) = "1"b;
				len_reg (j) = ^decimal;
				ic (j) = "0"b;
			     end;

			     irand = 0;
			end;
		end;

	     if itag
	     then goto prt;

/* get appropriate operator name */

	     if offset >= operator_names.first & offset <= operator_names.last
	     then do;
		     pt = addr (operator_names.names (offset));
		     goto str_info;
		end;

	     else if offset >= operator_names.first_special & offset <= operator_names.last_special
	     then do;
		     do j = 1 to operator_names.number_special;

			if operator_names.special (j).offset = offset
			then do;
				pt = addr (operator_names.special (j).namep);
				goto str_info;
			     end;
		     end;
		end;

	     if substr (op_code, 1, 1) ^= "t" & substr (op_code, 1, 3) ^= "epp"
	     then do;
		     if offset >= operator_names.first
		     then goto prt;
		     pt = addrel (addr (pl1_operators_$operator_table), offset);
		     substr (line, k, 2) = htht;
		     k = k + 2;
		     goto equal;
		end;

	     else go to prt;			/* Not found */

str_info:
	     size = fixed (pt -> name_pair.size, 18);
	     pt = ptr (pt, pt -> name_pair.rel_ptr);

	     substr (line, k, 2) = htht;
	     k = k + 2;

	     substr (line, k, size) = pt -> based_string;
	     k = size + k;

prt:
	     if length (output) + k > output_max
	     then call print$buffer;
	     output = output || substr (line, 1, k - 1);
	     output = output || NL;

	     if eis
	     then do;
		     irand = irand + 1;
		     if irand > nrands
		     then do;
			     eis = "0"b;
			     irand = 0;
			end;
		     else if irand > ndesc
		     then op_code, desc_word = "arg";
		end;

	end;					/* loop thruough words */

	return;

display_text$display_abs:
     entry (first_word, last_word);

	do i = first_word to last_word;

	     call binoct (unspec (i), octal_string);
	     substr (line, 1, 6) = substr (octal_string, 7, 6);

	     substr (line, 7, 2) = "  ";
	     call insert_relocation;
	     substr (line, 13, 3) = "   ";

	     call binoct (object (i), octal_string);
	     substr (line, 16, 12) = octal_string;

	     if length (output) + 28 > output_max
	     then call print$buffer;
	     output = output || substr (line, 1, 27);
	     output = output || NL;
	end;

	return;

display_text$display_create:
     entry (first_word, last_word, cp);

dcl	extra_line	char (256) var;
dcl	cp		ptr;
dcl	cur_offset	fixed bin (35);		/* offset of current ptr from lp or sp */
dcl	s		ptr;			/* ptr to symbol */

	do i = first_word to last_word;

	     call binoct (unspec (i), octal_string);
	     substr (line, 1, 6) = substr (octal_string, 7, 6);

	     substr (line, 7, 2) = "  ";
	     call insert_relocation;
	     substr (line, 13, 3) = "   ";

	     call binoct (object (i), octal_string);
	     substr (line, 16, 12) = octal_string;
	     extra_line = "";

	     if i = first_word
	     then do;
		     extra_line = "    location ";
		     if cp -> create_entry.flags.auto
		     then extra_line = extra_line || "sp|";
		     else extra_line = extra_line || "lp|";
		     extra_line = extra_line || ltrim (substr (line, 16, 6), "0");
						/* pick out location */
		     if cp -> create_entry.auto
		     then extra_line = extra_line || " automatic";
		     else if cp -> create_entry.static
		     then extra_line = extra_line || " static";
		     else if cp -> create_entry.common
		     then extra_line = extra_line || " common";


		     if cp -> create_entry.LA
		     then extra_line = extra_line || " Large Array";
		     else if cp -> create_entry.VLA
		     then do;
			     if cp -> create_entry.K256
			     then extra_line = extra_line || " Very Large Array (256K)";
			     else extra_line = extra_line || " Very Large Array (255K)";
			end;

		     if cp -> create_entry.init
		     then extra_line = extra_line || " Initialized";
		end;

	     else if i = first_word + 1
	     then extra_line = extra_line || "    length " || ltrim (char (cp -> create_entry.length));

	     else if i = first_word + 2
	     then do;
		     extra_line = extra_line || "    next " || substr (line, 16, 6);
		     if cp -> create_entry.name_length > 0
		     then extra_line = extra_line || "  /" ||
			     cp -> create_entry.block_name || "/";
		end;
	     else if i = first_word + 3
	     then do;
		     if cp -> create_entry.common
		     then do;
			     extra_line = extra_line || "    linkage rel ";
			     extra_line = extra_line || substr (line, 16, 6);
			end;
		     if cp -> create_entry.pointer_count > 0
		     then do;
			     extra_line = extra_line || " ";
			     extra_line = extra_line || ltrim (char (cp -> create_entry.pointer_count));
			     extra_line = extra_line || " pointer";
			     if cp -> create_entry.pointer_count > 1
			     then
				extra_line = extra_line || "s";
			end;
		end;

/* the last create_entry.pointer_count entries are pointers */
	     else if (last_word - i) < cp -> create_entry.pointer_count
	     then do;
		     extra_line = extra_line || "    ";

/* output "lp|offset" or "sp|offset" as appropriate */
		     if cp -> create_entry.flags.auto
		     then
			extra_line = extra_line || "sp|";
		     else extra_line = extra_line || "lp|";
		     cur_offset = cp -> create_entry.location + cp -> create_entry.pointer_count + i - last_word;
		     call binoct (unspec (cur_offset), octal_string);
		     extra_line = extra_line || ltrim (octal_string, "0");

/* output " -> name|offset where name is the name of the storage block and
   offset is the octal offset from the beginning of the storage block */
		     extra_line = extra_line || " -> /";
		     if cp -> create_entry.name_length > 0
		     then do;
			     extra_line = extra_line ||
				cp -> create_entry.block_name || "/|";
			end;
		     else do;
			     extra_line = extra_line || "base/|";
			end;
		     extra_line = extra_line ||
			ltrim (substr (line, 20, 8), "0");

		     extra_line = extra_line || "	";

/* output the symbol name this pointer points to */
		     if sym_info (i) > 0
		     then do;
			     s = addr (rands (sym_info (i)));
			     extra_line = extra_line || "    " || s -> symbol.name;
			end;

		end;

	     if length (output) + 28 + length (extra_line) > output_max
	     then call print$buffer;
	     output = output || substr (line, 1, 27);
	     output = output || extra_line;
	     output = output || NL;
	end;

	return;


display_text$display_init:
     entry (cp);

dcl	init_p		ptr;
dcl	(first_init_word, last_init_word)
			fixed bin (18);

	init_p = cp;
	do while (init_p ^= null);
	     first_init_word = fixed (rel (init_p), 18);

/* If we are a filler then repeat = 0, if we are the end then length = 0 */

	     if init_p -> create_init_entry.repeat = 0
	     then last_init_word = first_init_word + 1;
	     else last_init_word = first_init_word + currentsize (init_p -> create_init_entry) - 1;

	     if init_p -> create_init_entry.length = 0
	     then last_init_word = first_init_word;

	     if length (output) + 1 > output_max
	     then call print$buffer;
	     output = output || NL;

	     do i = first_init_word to last_init_word;
		call binoct (unspec (i), octal_string);
		substr (line, 1, 6) = substr (octal_string, 7, 6);

		substr (line, 7, 2) = "  ";
		call insert_relocation;
		substr (line, 13, 3) = "   ";

		call binoct (object (i), octal_string);
		substr (line, 16, 12) = octal_string;
		extra_line = "";

		if i = first_init_word + 1
		then if init_p -> create_init_entry.repeat = 0
		     then extra_line = "  Fill Zero";
		     else extra_line = "  repeat " || ltrim (print_number ((init_p -> create_init_entry.repeat)));

		else if i = first_init_word
		then if init_p -> create_init_entry.length = 0
		     then extra_line = "  End of Init";
		     else extra_line =
			     "  Data length (bits) " || ltrim (print_number ((init_p -> create_init_entry.length)));

		if length (output) + 28 + length (extra_line) > output_max
		then call print$buffer;
		output = output || substr (line, 1, 27);
		output = output || extra_line;
		output = output || NL;
	     end;
	     if init_p -> create_init_entry.length = 0
	     then init_p = null ();
	     else init_p = addrel (init_p, last_init_word - first_init_word + 1);
	end;
	return;

display_text$display_ascii:
     entry (first_word, n_chars);

dcl	n_chars		fixed bin (18);		/* size of string to be displayed */

dcl	nc		fixed bin (18),
	char_off		fixed bin (18),
	char_string	char (4) aligned based (addr (object (i)));

	i = first_word;
	nc = n_chars;


	do char_off = 1 by 4 to nc;

	     call binoct (unspec (i), octal_string);
	     substr (line, 1, 6) = substr (octal_string, 7, 6);
	     substr (line, 7, 2) = "  ";
	     substr (line, 9, 4) = "aa  ";

	     call binoct (object (i), octal_string);
	     k = 13;
	     do j = 1 by 3 to 12;
		substr (line, k, 4) = substr (octal_string, j, 3);
		k = k + 4;
	     end;

	     substr (line, 28, 1) = TB;

	     k = min (4, nc - char_off + 1);
	     do j = 1 to k;
		c = substr (char_string, j, 1);
		if unspec (c) < "000100000"b | unspec (c) > "001111110"b
		then substr (line, j + 28, 1) = " ";
		else substr (line, j + 28, 1) = c;
	     end;

	     if length (output) + k + 29 > output_max
	     then call print$buffer;
	     output = output || substr (line, 1, k + 28);
	     output = output || NL;

	     i = i + 1;
	end;
	return;

insert_relocation:
     proc;

/* inserts relocation characters in line */

	if rel_base = null
	then do;
		substr (line, 9, 4) = "aa  ";
		return;
	     end;

	if rel_tab (i).dummy_l
	then k = fixed (rel_tab (i).left, 4);
	else k = -1;

	substr (line, 9, 1) = relocation (k);

	if rel_tab (i).dummy_r
	then k = fixed (rel_tab (i).right, 4);
	else k = -1;

	substr (line, 10, 3) = relocation (k);

     end insert_relocation;


bin2dec:
     proc (number);

dcl	(m, number)	fixed bin (18);

	numb = print_number ((number));
	m = length (numb);
	substr (line, k, m) = numb;
	k = k + m;

     end bin2dec;


init_eis:
     proc;

	eis = "1"b;
	nrands = op_mnemonic_$op_mnemonic_ (mop).num_words - 1;
	ndesc = op_mnemonic_$op_mnemonic_ (mop).num_desc;
	decimal = op_mnemonic_$op_mnemonic_ (mop).dtype = 2;
	desc_word = desc_op (op_mnemonic_$op_mnemonic_ (mop).dtype);

     end init_eis;
     end display_text;
     end listing_generator;
     end ext_listing_generator;
