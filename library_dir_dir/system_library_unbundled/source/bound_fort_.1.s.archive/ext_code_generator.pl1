/****^  *********************************************************
        *                                                       *
        * Copyright, (C) BULL HN Information Systems Inc., 1990 *
        *                                                       *
        * Copyright, (C) Honeywell Limited, 1983                *
        *                                                       *
        * Copyright (c) 1972 by Massachusetts Institute of      *
        * Technology and Honeywell Information Systems, Inc.    *
        *                                                       *
        ********************************************************* */



/****^  HISTORY COMMENTS:
  1) change(86-07-14,BWong), approve(86-07-14,MCR7286), audit(86-07-17,Ginter),
     install(86-07-28,MR12.0-1105):
     Fix fortran bugs 430, 449, 455, 463, and 492.
  2) change(86-07-14,BWong), approve(86-07-14,MCR7382), audit(86-07-17,Ginter),
     install(86-07-28,MR12.0-1105):
     Fix fortran bugs 411, 425, 473, and 476.
  3) change(86-10-17,Ginter), approve(86-10-17,MCR7556), audit(86-10-22,Huen),
     install(86-11-13,MR12.0-1216):
     Fixed fortran bugs 496 and 502.
  4) change(88-01-07,Huen), approve(88-01-07,MCR7825), audit(88-01-13,RWaters),
     install(88-01-19,MR12.2-1014):
     Fix fortran bug 504.
  5) change(90-04-27,Huen), approve(90-04-27,MCR8155), audit(90-05-16,Gray),
     install(90-05-30,MR12.4-1011):
     ft_508 : Generate correct code for index intrinsic on a substring of a
     static character variable.
  6) change(91-06-27,Huen), approve(91-06-27,MCR8245), audit(91-11-25,Vu),
     install(91-12-11,MR12.5-1004):
     Fix fortran bug 513 to generate correct code for VLA reference if one of
     the dimensions is greater than the maximum number that fits in a 18 bit
     halfword (262143).
                                                   END HISTORY COMMENTS */


/* format: style4,delnl,insnl,^ifthendo,indnoniterend,inditerdo,indend,^indproc,indcom,declareind5 */
ext_code_generator:
     procedure (p1, p2);

dcl  (p1, p2, shared_struc_ptr, cg_struc_ptr) pointer;
dcl  (object_base, operand_base, polish_base, relocation_base) pointer;
dcl  (object_max_len, operand_max_len, polish_max_len) fixed binary (19);

%include fort_nodes;

%include fort_listing_nodes;

%include fort_system_constants;

dcl  1 shared_globals structure aligned based (shared_struc_ptr),
%include fort_shared_vars;

%include fort_options;

dcl  1 cg_globals structure aligned based (cg_struc_ptr),
%include fort_cg_vars;

dcl  1 symtab_parameters structure aligned,
%include fort_symtab_parms;
%include long_profile;

dcl  fort_make_symbol_section entry (ptr, ptr, ptr, fixed bin (18), fixed bin (18));


	shared_struc_ptr = p1;
	cg_struc_ptr = p2;
	object_max_len = shared_globals.object_max_len;
	operand_max_len = shared_globals.operand_max_len;
	polish_max_len = shared_globals.polish_max_len;


	object_base = shared_globals.object_base;
	operand_base = shared_globals.operand_base;
	polish_base = shared_globals.polish_base;
	relocation_base = shared_globals.relocation_base;


	call code_generator;

%include fort_utilities;

code_generator:
     procedure ();

/****^ Written: 1 February 1976 by Richard A. Barnes

Modified: 31 Mar 90, SH - 508: Avoid inserting an instruction in the middle of
	the scm arg sequence for Index intrinsic when pr 4 is valid.
          Also remove "restore_prs", "lock_base", "lock_index".
Modified: 13 Dec 87, SH - 504: Change the relocation factor for the VLA common
          block members from "internal_static_15" to "absolute".
Modified: 16 Oct 86, AG - 502a:  Change make_symbol_descriptor so it always
	generates correctly formatted char (*) descriptors.  Change
	make_entry_descriptor so it never "adjusts" incorrectly formatted
	char (*) descriptors.  Change get_param_char_size so that it always
	expects correctly formatted char (*) descriptors.
Modified: 22 Sep 86, AG - 502:  Set descriptor size field to "1"b only for
	character *(*) variables in make_entry_descriptor.
Modified: 22 Sep 86, AG - 496a:  Oops -- forgot that array symbols can
	be accessed directly in "call" statements.  Explicitly check
	for symbol.dimensioned when restoring symbol.address.offset.
Modified: 04 Sep 86, AG - 496:  For non-array symbols in very large common,
	use symbol.addr_hold instead of symbol.address.offset to hold the
	offset in the linkage section of the pointer to the symbol.  Too
	much code counts on symbol.address.offset holding the offset from
	the pointer of the symbol (always 0).  Also made create_storage_entry
	save info in a_name about symbols used in create_entry structures.
Modified: 08 Jul 86, AG - 449.a: Use "anq/stq" instructions rather than "orsq"
	to update length field in character* (*) dummy arg descriptors.
Modified: 19 Feb 86, BW & AG - 473.a: Flag error if passing VLA type arguments
	to non-VLA type arguments in the same compilation unit.
Modified: 11 Dec 85, SH - 425: Passing hollerith (i.e. character) constant
	data types as arguments to other data types will no longer
	produce error 401 (inconsistent argument types).
Modified: 07 Nov 85, SH & MM - 476:  Reduce severity of a compile time
	subscript error (422) from severity 3 to a warning.
Modified: 29 Oct 85, BW - 411: Make sure common block units are the same when
	comparing maximum lengths.
Modified: 08 Aug 85, BW - 430: Prevent emission of deallocation code for auto-
	matic LA's and VLA's when they don't exist in the compilation unit.
Modified: 02 Aug 85, BW - 463: Remove code for action (56) since the macros
          no longer require this action after the bug fix.
Modified: 21 May 85, BW - 455: Ensure auto ptrs to parameters are allocated
          on even word boundaries.
Modified: 24 Apr 85, MM - 449: Create the routine 'make_entry_descriptor' as
	'make_symbol_descriptor' can't be used by the code that makes
	entrys.
Modified: 22 Jan 85, MM - 447: Fix base_man_load_any_pr to set the bit
	address_in_base for VLA elements and allow the base_regs
	structure to retain the knowledge that it points to a VLA element.
Modified: 19 Oct 84, MM - 443: Fix list_init_ array initialization.
Modified: 22 Aug 84, HH - 439: 'make_symbol_descriptor' sets lower bound to
	-2**35 if lower bound is constant but upper bound is not.
Modified: 22 Jun 84, MM - Install typeless functions support.
Modified: 09 Apr 84, MM - 417: character elements are incorrectly assumed to
	be word aligned in ansi77 mode if lower bound of array is 0.
Modified: 04 Apr 84, HH - 416: 'add' and 'sub' need to support -ve constants.
Modified: 28 Mar 84, MM - Install HFP support.
Modified: 13 Mar 84, HH - 415: Incorrect relocation information generated for
		entry point declarations.
Modified: 26 Jan 84, TO: 414 - Fix bug in char(*) sizing introduced by entry
	definition code.  We need to emit an extra constant word for char(*)
	descriptors, rather than mangle the real word that ORQ will refer to.
Modified:	19 Sep 83, RG & MM - 242/370: To look up entry-defined arg_desc if one exists.
Modified: 27 Jul 83, HH - 371: 'mult' needs to support -ve constants.
Modified:	17 June 83, HH - 383: Simplify input to 'check_parameters'.
Modified:  8 June 83, TO: 382 - Fix size of entry_info (builtin(8)) to
	correspond to reality (it is 7 words long).
	Update documentation of builtin (8).
Modified:  8 June 83, TO: 381 - Fix register reservation mask for shorten_stack
	renamed from reserve_pr1_mask (which reserved pr0 instead) to
	shorten_stack_mask which reserves pr1, x1.
Modified:	14 April 83, RG: 377 - Fix bug in flush_ref which used aliasable
	instead of in_equiv_stmnt.
Modified: 14 April 83, TO - fix 'make_create_entry' to correctly address
	'create_entry.next' when setting 't' relocation.
Modified:  5 April 83, TO - fix 'check_parameters' to ensure parameter is
	a symbol and not a return constant.
Modified:  5 April 83, TO - fix list_template_init of common bugs.
Modified:  5 April 83, TO - fix 'allocate', 'free' bug in VLA common
	cleanup, have cleanup done by common cleanup routine.  Chain headers
	were being free'd twice, and cleanup during processing was
	inconsistent.
Modified: 31 March 1983, TO: 374 - Fix bug in large_address array_ref in
	finish_subscript, make_substring in which the constant offset of the
	array_ref backs up before the 16K bound, leaving array_ref base wrong
	and large_address flag off preventing re-calc of base in 
	m_a_check_large_address.
Modified: 31 Jan 83, TO & HH: Install LA/VLA support.
Modified: 10 January  1982, TO - Add 'emit_entry_def (simple (56)) operation
	from macros to create an entry definition entry.  Added code to
	gen_entry_defs to copy text position of definition to table.  Added
	code to 'check_parameters' (simple (15)) to fill in descriptors.
Modified:  3 January  1982, TO - Add 'force_even' operation from macros to
	emit 'nop' to align to an even word boundary to permit DO-loop
	optimization.
Modified: 31 December 1982, TO: 367 - Cause allocation of named constants if
	we want a symbol_table.
Modified: 17 December 1982, TO - Add '-long_profile' support.
Modified: 17 Nov 82, HH - 361:  Incorrect code was generated for an ASSIGN
	to a format which the parser had made into a named constant if
	there was no reference to the format before the ASSIGN, because
	the code supporting the 'get_format_var' macro did not call
	'use_input' to replace named constants by their value.  Rather
	than have 'get_format_var' use 'use_input', we have opted for
	the more general fix of moving the code for 'get_format_var'
	into 'use_input'.  'use_input' was renamed to 'effective_operand'
	because of its enhanced function.
Modified: 30 Sep 1982, TO - 364: Fix 'finish_subscript' bug - first loop did
	a 'mult' even if we did not have 'vsum', this took an uninitialized
	value.  Also put a constant creation into 'load_vsum' if called 
	without a vsum created.
Modified: 05 August 1982, HH - Fix bug 357:  Pad char constants with spaces
	rather than NULs.
Modified: 23 July 1982, TO - fix named constant bug in emit_c_a_var where refs
	to the text section are not seen and fixed up.
Modified: 20 May 1982, TO - Fix bug in check_arg_list where 'n' rather than
	'num_args' is set to 'a -> arg_desc.n_args ' in limiting the scan
	of the arg_desc list.  This would permit a scan longer than the list.
Modified: 18 May 1982, TO - Fix descriptor bug where char*(*) multiplier is
	only calculated for last dimension, leaving an unprobable, and at
	times (dims>2) unrunnable binary.
Modified: 17 May 1982, TO - Fix probe bug where char*(*) multiplier calculated
	for descriptor in bits is used for probe runtime_symbol in chars.
	This causes an extended descriptor to be allocated in the stack and
	the intermediate character multiplier to be stored in the extended
	area to be picked up by runtime_symbol.bound(n).multiplier.
Modified: 13 May 1982, TO - Fix substr of named_constant, with fix to substr,
	and emit_eis, have emit_eis do correct text reference.
Modified:  9 May 1982, TO - Fix (if unless)_negative to know about other than
	integer.
Modified:  7 May 1982, TO - Fix use of EAQ register and use_ind.
	previously use_ind used and reset A, but didn't consider those things
	in EAQ, which subsiquently got lost and not stored.
Modified:  3 May 1982, TO - Allocate char_star_function return_value.
Modified:  3 May 1982, TO - Add action (74) (if unless)_char_star_function.
Modified:  3 May 1982, TO - Add action (75) (if unless)_check_multiply.
Modified: 28 April 1982, TO - fix navytest3 bug.  Cause flush_ref to remove
	ALL equivalenced refs in this chain.
Modified: 19 April 1982, TO - Implement NAMED CONSTANTS.
Modified: 14 April 1982, TO - Implement extended information for stack and
	linkage overflow message (error 414).
Modified: 12 April 1982, TO - fix bug 344, stack indirect through ITP in
	set_itp_addr.
Modified: 4 September 1981, CRD - Change reset_regs to call flush_xr.
Modified: 27 July 1981, CRD - Implement get_format_var macro.
Modified: 2 June 1981, CRD - Implement push_sf_arg_count macro.
Modified: 21 May 1981, CRD - Reorganize subscript range checking.
Modified: 12 May 1981, CRD - Add equiv_op, not_equiv_op.
Modified: 23 April 1981, CRD - Fix bug 319.
Modified: 20 April 1981, CRD - Fix bug 316.
Modified: 19 March 1981, CRD - Fix bug 311.
Modified: 13 March 1981, CRD - Implement assumed size arrays.
Modified: 27 February 1981, CRD - Implement array lower bounds ^= 1.
Modified: 8 January 1981, CRD - Fix bug 303.
Modified: 9 December 1980, CRD - Changed upper bound of
	operator_table array to 102 for block_if, else_if, and
	else operators.
Modified: 20 November 1980, CRD - Fix bug in which star extent arrays
	did not have their virtual_origin and array_size symbols
	set properly unless the first dimension was variable.
	Also fixed bug in which an attempt to use an ITP argument
	list was made when passing descriptors.
Modified: 10 October 1980, CRD - Fixed bug in use_eaq which caused
	temporaries to be stored into the wrong address when more
	than one item was in the register.
Modified: 6 October 1980, CRD - Changes mandated by audit. Also
	move symbol names of instructions in the single_inst table
	to the include file fort_single_inst_names.incl.pl1.
Modified: 26 September 1980, CRD - Add pointer register 1 to the pool
	of registers available for addressing, etc.
Modified: 24 September 1980, CRD - Change desc_ptr_in_base to be a
	simple macro (desc_ptr_in_pr3), and add arg_ptr_in_pr1.
Modified: 1 September 1980, CRD - Use array_ref.has_address instead
	of ext_base, to correspond with optimizing CG.
Modified: 15 August 1980, CRD - Fix large address bug in
	continue_cat.
Modified: 13 August 1980, CRD - Fix error handling in make_substring.
Modified: 12 August 1980, CRD - Fix bug in (if unless)_ansi77.
Modified: 16 July 1980, CRD - Add (if unless)_variable_arglist macro.
Modified: 15 July 1980, CRD - Changes for generating descriptors 
	on calls - copy needs_descriptors bit from entry_point
	symbol to external symbol in assign_storage, and add
	set_needs_descriptors macro.
Modified: 27 June 1980, CRD - Fix bug in push_length macro - it was
	not bumping the ref count of temporaries.
Modified: 23 June 1980, CRD - Add (if unless)_ansi77.
Modified: 15 May 1980, CRD - Fix bug in make_substring: if variable
	length temporary already existed, increment its ref count;
	and make sure the variable length of an array_ref is never
	another array_ref.
Modified: 8 April 1980, CRD - Add code to recycle temporary nodes
	from one subprogram to another; centralize subprogram
	initialization in start_subprogram.
Modified: 4 April 1980, CRD - Fix bug intorduced by new EAQ mgt.
	Changed load to call use_ind in all cases except when
	loading into the indicators.
Modified: 7 March 1980, CRD - Implement concatenation.  Changes
	node.multi_position to node.stack_indirect.
Modified: 7 February 1980, CRD - Add char1_to_int, int_to_char1
	macros, fix text_ref to work with char constants, and
	change the return macro to convert counts to integers.
Modified: 5 February 1980, CRD - Add (if unless)_aligned macro, and
	change text_ref to handle direct EIS operands.
Modified: 29 January 1980, CRD - Add support for substrings.
Modified: 24 January 1980, CRD - Add support for Fortran entries
	which require descriptors.
Modified: 17 January 1980, CRD - split make_descriptor into two
	routines: make_descriptor and make_symbol_descriptor.
Modified: 17 December 1979, CRD - completion of changes for
	variable length character strings.
Modified: 12 December 1979, CRD - phase 1 of changes to allow
	variable length character strings (make_descriptor).
Modified: 11 December 1979, CRD - change subscripting code to agree
	with new large address scheme, and fix it to load large
	offsets correctly.
Modified: 7 December 1979, CRD - change over to large address scheme
	used in the optimizing side (pointer registers instead of 
	index registers).
Modified: 6 December 1979, CRD - invent emit_temp_store to avoid
	recursion in eaq_man_load_a_or_q.
Modified: 6 November 1979, CRD - change eaq register management and
	addressing to handle large character offsets.
Modified: 24 September 1979, CRD - added code to finish_subscript to
	handle 77 char mode (character offsets, large offsets).
Modified: 20 September 1979, CRD - added code in base_man_load_pr
	to load addresses of unaligned character strings.
Modified: 19 September 1979, CRD - change register reservation to
	use the logic planned for the register optimizer.
Modified: 12 September 1979, CRD - change large address scheme to
	use full 32K addressing capability of 15 bit offset.
Modified: 31 August 1979, CRD - make changes to storage allocator
	for ANSI 77 character mode.
Modified: 28 August 1979, CRD - fix bug 233 (%options round and
	%options truncate in the same compilation don't work).
Modified: 24 August 1979, CRD - fix bug 232, in which descriptors
	are copied onto the stack incorrectly due to the data_type
	field of symbols created by the CG not being set.
Modified: 23 August 1979, CRD - move code to build runtime symbol
	table to separate external procedure, fort_make_symbol_table.
Modified: 25 July 1979, CRD - rearrange opcodes of some more simple
	macro instructions.
Modified: 24 July 1979, CRD - fix bug 229, in which the parent chain
	in the runtime symbol table was being built incorrectly.
Modified: 23 July 1979, CRD - to compress opcodes for certain pairs
	of if/unless macro instructions.
Modified: 23 July 1979, CRD - to rearrange opcodes for macros which
	take no arguments or operands to occupy the left half of
	the instruction word.
Modified: 16 July 1979, CRD - to fix bug 225 to make subscripts in the Q work
	properly.
Modified:	17 January 1979, RAB - to speed up reg management by using
	machine_state.value_in_xr
Modified: 6 December 1978, PES - for %options and %global
Modified:	4 December 1978, RAB - for option to initialize auto storage to zero
Modified: 30 November 1978, PES - Key rounding off of fortran_options.
Modified:	18 November 1978, RAB - Centralize control of rounding
	by use of eaq.rounded.
Modified:  25 October 1978, PES - Changes for large common and arrays.
Modified:	11 October 1978, RAB - Fix bug 184 in which bad code is
	produced if an increment causes an address to cross
	a 16K boundary.  Also checks were put in for invalid fields.
Modified: 12 Sept 1978, PES - Move PS from static to automatic storage, to fix
	bug 182 in which fortran_io_ fails in the event of a segment loop,
	e.g. a subr in segment <a> calls a subr in segment <b>, which in
	turn calls another subr in segment <a>.
Modified: 06 Sept 1978, PES -Fix bug in which a register may not be reloaded
	before being used as an index, even if the value has been changed in
	storage.
Modified: 27 July 1978, PES - Fix bug in setting of symbol.simple for
	parameters.
Modified: 23 June 1978, DSL - Add emit_c_a_const so that all procs remain quick
	procs; set symbol.element_size for descriptors (formerly done by
	storage allocator).
Modified: 19 June 1978, DSL - Changes dictated by audit.
Modified: 12 June 1978, DSL - Modify for loop optimizer. This includes the
	renaming of node.subs_in_q to node.dont_update. All nodes were
	changed. Also, removed all code in storage allocator that assigns a
	data type or a storage class.
Modified: 23 May 1978, DSL - Prepare for loop optimizing code generator; add
	load_for_test to fix bug 159 in which indicator state is not set
	correctly. Mark some code as purely version I optimizer, i.e.,
	obsolete. Change action 105 from "also_in_reg" to "compare".
Modified: 18 April 1978, DSL - to fix bug 149 in which incorrect code is
	generated for arrays with large addresses.  Also fixed bug 142 in
	which save_xr protect_indicators destroys the machine state.
Modified: 4 January 1978, DSL - Allocate double word character constants on
	double word boundaries.
Modified: 20 December 1977, DSL - Clean up previous fix; add new macros,
	load_for_test, set_in_storage, pad_char_const_to_word,
	pad_char_const_to_dw, dt_jump1; fix store macro to allow no_round
	option.
Modified: 4 November 1977, DSL - Use maximum length when allocating common
	blocks.
Modified:	31 October 1977, RAB - Fix bug 129 where large virtual origins get
	bad code.  Also, implement DL modification for negative constants.
Modified:	6 October 1977, DSL - Fix bug in subscripting code for the following:
	array i(3,3),j(3); i(j(l), l) = m(l)
Modified: 30 August 1977, DSL - coordinated change with listing generator to
	mark entry "data" words; base_man_load_pr_value fails to set reloc
	info and symbol info; multiply macro does not check for product >
	bias. Fix "load" to set proper ref count for complex vars.
	NOTE -- in this compilation the value of bias changed from 65536 to
	131072.
Modified: 21 July 1977, DSL - fix bug in itp list reloc info.
Modified: 14 July 1977 by DSL - 1) add new builtin, ps_area_ptr, for open and
	close; 2) add new macro load_pr_value, to load a pr with the contents
	of a location; 3) give relocation info for automatic storage template
	(bug fix).
Modified: 5 July 1977 by DSL - 1) fort_system_constants.incl.pl1 change;
	2) print message for multiple initialization of a single common
	block. 3)  Change if_ind and unless_ind to always work even if the
	eaq appears empty, fixing 108. THIS CONFLICTS WITH PUBLISHED
	DOCUMENTATION !!!
Modified: 26 May 1977 by DSL to always generate ERROR operand if an error
	occurs in a function frame; THIS CHANGE EXACTLY CONFLICTS WITH THE
	ORIGINAL DOCUMENTATION OF THE MACRO LANGUAGE. Refer to code for
	action 66 (error) for complete details.
Modified:	3 May 1977 by RAB for store macro
Modified: 28 April 1977 by DSL - for new fort_system_constants.incl.pl1
Modified: 28 March 1977 by DSL for new stmnt label handling; interface with new
	node formats; recompile because of PL/I bug 1599 (in compile_link for
	A$B common names).
Modified: Feb 1977 by GDC for the optimizer
Modified: 31 Jan 1977 by DSL to allow type-3 links for common block names of
	the form a$.
Modified: 9 Dec 1976 by DSL to reference fort_version_info$version_name
Modified: 7 Dec 1976 by RAB to fix bugs in make_symbol_table
Modified:	22 Nov 1976 by RAB to add -profile
Modified:	November 1976 by David Levin to add make_symbol_table
Modified:	19 Oct 1976 by RAB for ok_lists and runtime symbol table hooks
Modified:	14 Oct 1976 by RAB for relocation bits
Modified:	7 Oct 1976 by RAB for optional descriptors
Modified:	30 Sept 1976 by RAB for object listings and local object, operand,
	and polish bases
Modified:	5 July 1976 by RAB for addrs >= 16K

END Modifications */

dcl  cleanup_body_address fixed bin (18) unsigned;
dcl  alloc_auto_cleanup bit (1) aligned;

dcl  (c, lib_pt, p) ptr;

dcl  (n, text_pos, link_pos, def_pos, sym_pos, begin_links, linkrel, defrel, symrel, lib_pos, last_pos, profile_start,
     profile_pos) fixed bin (18);

dcl  (begin_external_list, end_external_list) fixed bin (18);

dcl  begin_forward_refs fixed bin (18);

dcl  (first_namelist, last_namelist) fixed bin (18);
dcl  (first_header, last_header) ptr init (null ());	/* header chain */

dcl  (link_base, def_base, lib_list_ptr, a_base, parm_desc_ptrsp) ptr;
dcl  (link_reloc_base, def_reloc_base, lib_reloc_ptr) ptr;

dcl  (generate_long_profile, generate_profile, generate_symtab, assembly_list, do_rounding, init_auto_to_zero)
	bit (1) aligned;

dcl  builtins (0:11) fixed bin (18);			/* format: off */
/* builtins are:
   0:  zero	     integer zero constant
   1:  one	     integer one constant
   2:  ps		     symbol for fortran I/O arglist
   3:  auto_template     Initialization template for auto storage
   4:  auto_overlay	     array reference overlay of automatic storage
   5:  null_ptr	     initialized to a null pointer value
   6:  null	     value of 0 as a null
   7:  two	     integer two constant
   8:  entry_info	     place to store quick proc info
	word 0 - Return address pointer (ITS).
	word 2 - Argument pointer (ITS).
	word 4 - Descriptor pointer (ITS).
	word 6 - Permanent Stack extension value (18-bit offset, 1 word).
   9:  star_symbol	     <*symbol>|0
  10:  ps_area_ptr	     symbol for ps.buffer_p
  11:  desc_overlay	     symbol for accessing a descriptor
*/
/* format: on */

dcl  image (amt) fixed bin (18) aligned based;
dcl  char_image char (4 * amt) aligned based;
dcl  (zero_def, last_def, seg_def) bit (18) aligned;
dcl  def_pool (20) fixed bin (18);

dcl  (amt, con, i, j, lib) fixed bin (18);

dcl  rands (0:operand_max_len - 1) fixed bin (18) aligned based (operand_base);

dcl  polish (0:polish_max_len - 1) fixed bin (18) aligned based (polish_base);

dcl  a_name (0:261119 - 2 * (number_of_lines + 1)) fixed bin (18) aligned based (a_base);

dcl  1 external_list based (polish_base) aligned,
       2 ext_ref (0:polish_max_len - 1) ptr unal;

dcl  last_auto_loc fixed bin (18);
dcl  linkage_pad fixed bin (18);			/* linkage pad of LA and VLA pointers */
dcl  first_auto_var_loc fixed bin (18);
dcl  free_temps (3) fixed bin (18);
dcl  auto_template fixed bin (18);

dcl  1 text_halfs (0:262143) aligned based (object_base),
       2 left fixed bin (17) unal,
       2 right fixed bin (17) unal;

dcl  1 reloc_halfs (0:262143) aligned based (relocation_base),
       2 left bit (18) unal,
       2 right bit (18) unal;

dcl  reloc (0:3) bit (36) aligned based;

dcl  1 forward_refs (0:next_free_polish - 1) based (polish_base) aligned,
       2 instruction fixed bin (17) unal,
       2 operand fixed bin (18) unsigned unal;

dcl  vsegname char (32) varying defined (objectname);

dcl  1 saved_lib_list aligned based (lib_list_ptr),
       2 nlibs fixed bin (18),
       2 names (n refer (nlibs)),
         3 offset bit (18) unal,
         3 lng fixed bin (17) unal;

dcl  1 saved_lib_reloc_list aligned based (lib_reloc_ptr),
       2 mlibs fixed bin (18),
       2 names (n),
         3 reloc bit (18) unal,
         3 pad bit (18) unal;

dcl  1 parm_desc_ptrs aligned based (parm_desc_ptrsp),
       2 n_args fixed bin (18) unaligned unsigned,
       2 descriptor_relp (0 refer (parm_desc_ptrs.n_args)) fixed bin (18) unsigned unaligned;


dcl  segname char (32) aligned;

dcl  bases (0:7) bit (3) aligned internal static options (constant)
	initial ("0"b3, "4"b3, "1"b3, "2"b3, "3"b3, "5"b3, "7"b3, "6"b3);

dcl  (
     ap defined (bases (0)),
     ab defined (bases (2)),
     bp defined (bases (3)),
     bb defined (bases (4)),
     lp defined (bases (1)),
     lb defined (bases (5)),
     sp defined (bases (7)),
     sb defined (bases (6))
     ) bit (3) aligned;

dcl  which_base (0:7) fixed binary (3) internal static options (constant) initial (0, 2, 3, 4, 1, 5, 7, 6);

dcl  (
     DU_mod initial ("03"b3),
     DL_mod initial ("07"b3),
     AL_mod initial ("05"b3),
     AU_mod initial ("01"b3),
     QL_mod initial ("06"b3),
     QU_mod initial ("02"b3),
     X0_mod initial ("10"b3),
     X1_mod initial ("11"b3),
     RI_mod initial ("20"b3),
     ITP_mod initial ("41"b3),
     FT2_mod initial ("46"b3)
     ) bit (6) aligned internal static options (constant);

dcl  01 descriptor_type_word (0:1, 7) aligned,
       02 flag bit (1) unaligned init ((14) ("1"b)),
       02 type fixed bin (6) unsigned unaligned
	  init (ft_integer_dtype, ft_real_dtype, ft_double_dtype, ft_complex_dtype, ft_logical_dtype, ft_char_dtype,
	  ft_external_dtype, ft_integer_dtype, ft_hex_real_dtype, ft_hex_double_dtype, ft_hex_complex_dtype,
	  ft_logical_dtype, ft_char_dtype, ft_external_dtype),
       02 packed bit (1) unaligned init ((14) ("0"b)),
       02 number_dims fixed bin (3) unaligned init ((14) 0),
       02 size fixed bin (23) unaligned init ((2) (35, 27, 63, 27, 1, 0, 0));
dcl  fptype fixed bin (1) init (bin (shared_globals.hfp, 1));

dcl  ext_base_on bit (36) aligned internal static options (constant) initial ("000000000100"b3);

dcl  max_address_offset fixed bin (14) static options (constant) init (16383);
dcl  max_stack_size fixed bin (18) int static init (62000) options (constant);
dcl  max_linkage_size fixed binary (18) internal static options (constant) initial (131071);

dcl  (abs, addr, addrel, bin, binary, bit, byte, char, cleanup, copy,
     currentsize, divide, fixed, hbound, index, ltrim, max, min, mod, null,
     ptr, rank, rel, reverse, size, string, substr, unspec, verify) builtin;

%include linkdcl;
%include object_map;
%include relbts;
%include reloc_lower;
%include its;
%include profile_entry;
%include fortran_storage;
%include std_descriptor_types;

	/* initialize */

	cur_statement = -1;				/* no active statement node */
	allocate_symbol_name = 0;			/* no names for symbols created by code generator */
	unspec (def_pool) = "0"b;
	text_pos, link_pos, def_pos, sym_pos, lib_pos, profile_start = 0;
	first_namelist, last_namelist = 0;
	free_temps (1), free_temps (2), free_temps (3) = 0;
	segname = vsegname;

	assembly_list = shared_globals.options.list;
	if assembly_list
	then a_base = addr (source_list (number_of_lines + 2));
	else a_base = null;

	/* allocate all constants passed as arg */

	call alloc_constants (first_dw_constant, 2);
	call alloc_constants (first_word_constant, 1);
	call alloc_char_constants (first_char_constant);

	/* allocate storage */

	begin_external_list = next_free_polish;

	call assign_storage;

	/*  set up for interpreting */

	end_external_list, begin_forward_refs = next_free_polish;

	/* interpret */

	call interpreter;

	last_pos = text_pos;

	/* allocate all constants  that need storage */

	text_pos = text_pos + mod (text_pos, 2);

	call alloc_char_constants (first_block_constant);
	call alloc_constants (first_dw_constant, 2);
	call alloc_constants (first_word_constant, 1);
	call alloc_char_constants (first_char_constant);

	/*  resolve all forward references */

	do i = begin_forward_refs to hbound (forward_refs, 1);
	     j = forward_refs (i).instruction;
	     text_halfs (j).left = text_halfs (j).left + addr (rands (forward_refs (i).operand)) -> label.location;
	     end;

	/* free up space so name_assign can use */

	next_free_polish = begin_forward_refs;

	/* allocate library structure */

	if first_lib_name ^= 0
	then do;
	     lib_pos = text_pos;
	     lib_list_ptr = addrel (object_base, lib_pos);
	     lib_reloc_ptr = addrel (relocation_base, lib_pos);
	     n = num_of_lib_names;
	     saved_lib_list.nlibs = n;
	     text_pos = text_pos + size (saved_lib_list);

	     i = 1;
	     do lib = first_lib_name repeat lib_pt -> library.next_library_node while (lib > 0);
		lib_pt = addr (rands (lib));
		c = addr (rands (lib_pt -> library.character_operand));
		saved_lib_list.offset (i) = unspec (c -> char_constant.location);
		saved_lib_list.lng (i) = c -> char_constant.length;
		saved_lib_reloc_list.reloc (i) = rc_t;
		i = i + 1;
		end;
	     end;

	/* initialize static */

	linkrel = divide (text_pos + 1, 2, 17, 0) * 2;
	link_base = addrel (object_base, linkrel);
	link_reloc_base = addrel (relocation_base, linkrel);

	call initialize_static;

	/* generate links */

	defrel = link_pos + linkrel;
	def_base = addrel (object_base, defrel);
	def_reloc_base = addrel (relocation_base, defrel);

	call init_linkage;
	call gen_linkage;

	/* generate entry definitions */

	call gen_entry_defs;

	/* generate library definition */

	if lib_pos ^= 0
	then call generate_definition ("library_list_", 0, bit (lib_pos, 18));

	/* free up space for make symbol_table that is no longer used */

	next_free_polish = begin_forward_refs;

	/* generate symbol section */

	symrel = divide (defrel + def_pos + 1, 2, 17, 0) * 2;

	symtab_parameters.link_base_ptr = link_base;
	symtab_parameters.link_reloc_base_ptr = link_reloc_base;
	symtab_parameters.def_reloc_base_ptr = def_reloc_base;
	symtab_parameters.current_text_offset = text_pos;
	symtab_parameters.current_def_offset = def_pos;
	symtab_parameters.current_link_offset = link_pos;
	symtab_parameters.final_text_offset = last_pos;
	symtab_parameters.profile_offset = profile_start;
	symtab_parameters.star_symbol_link = builtins (9);
	symtab_parameters.first_namelist_symbol = first_namelist;

	call fort_make_symbol_section (shared_struc_ptr, cg_struc_ptr, addr (symtab_parameters), symrel, sym_pos);


	/* finish up the object segment by filling in the
	   standard object map */

	n = divide (symrel + sym_pos + 1, 2, 17, 0) * 2;
	p = addrel (object_base, n);

	p -> object_map.decl_vers = object_map_version_2;
	p -> object_map.identifier = "obj_map";
	p -> object_map.text_length = bit (text_pos, 18);
	p -> object_map.definition_offset = bit (defrel, 18);
	p -> object_map.definition_length = bit (def_pos, 18);
	p -> object_map.linkage_offset = bit (linkrel, 18);
	p -> object_map.linkage_length = bit (link_pos, 18);
	p -> object_map.static_offset = bit (fixed (linkrel + size (virgin_linkage_header), 18), 18);
	p -> object_map.static_length = bit (fixed (begin_links - size (virgin_linkage_header), 18), 18);
	p -> object_map.symbol_offset = bit (symrel, 18);
	p -> object_map.symbol_length = bit (sym_pos, 18);

	p -> object_map.format.separate_static = "0"b;

	p -> object_map.format.relocatable = shared_globals.options.relocatable;

	p -> object_map.format.procedure, p -> object_map.format.standard = "1"b;

	addrel (p, size (p -> object_map)) -> map_ptr = bit (n, 18);

	/* set next_free_object  and  return */

	next_free_object = n + size (p -> object_map) + 1;
	return;

get_subr_options:
     procedure (cs);

	/* Sets various global flags to correspond to the options in
	   effect for the given program unit. */

dcl  cs pointer;					/* Pointer to subprogram node */

	do_rounding = cs -> subprogram.options.do_rounding;
	generate_profile = cs -> subprogram.options.profile;
	generate_long_profile = cs -> subprogram.options.long_profile;
	generate_symtab = cs -> subprogram.options.table | shared_globals.options.namelist_used;
	init_auto_to_zero = cs -> subprogram.options.auto_zero;

	return;

     end get_subr_options;

/**** CONSTANT ALLOCATION ****/

alloc_constants:
     procedure (start, amt);

	/* Allocates constants in the text section */

dcl  start fixed binary (18);
dcl  (amt, n) fixed binary;

	n = amt;

	do con = start repeat c -> constant.next_constant while (con > 0);
	     c = addr (rands (con));
	     if ^c -> constant.allocated
	     then if c -> constant.allocate | c -> constant.passed_as_arg
		then do;
		     c -> constant.location = text_pos;
		     addrel (object_base, text_pos) -> image = addr (c -> constant.value) -> image;
		     text_pos = text_pos + n;
		     c -> constant.allocated = "1"b;
		     end;
	     end;

     end alloc_constants;

alloc_char_constants:
     procedure (start);

	/* Allocates character constants in the text section */

dcl  start fixed binary (18);
dcl  relocate_itp bit (1) aligned;

	relocate_itp = start = first_block_constant;

	do con = start repeat c -> char_constant.next_constant while (con > 0);
	     c = addr (rands (con));
	     if ^c -> char_constant.allocated
	     then if c -> char_constant.allocate | c -> char_constant.passed_as_arg
		then do;
		     if c -> char_constant.length = chars_per_dw
						/* a double word constant */
		     then text_pos = text_pos + mod (text_pos, 2);
						/* get even address */

		     amt = divide (c -> char_constant.length + chars_per_word - 1, chars_per_word, 17, 0);
		     c -> char_constant.location = text_pos;
		     addrel (object_base, text_pos) -> char_image = c -> char_constant.value;
		     if relocate_itp
		     then call relocate_itp_list;
		     text_pos = text_pos + amt;
		     c -> char_constant.allocated = "1"b;
		     end;
	     end;

     end alloc_char_constants;

relocate_itp_list:
     procedure ();

	/* Generates relocation bits for an itp argument list */

dcl  q pointer;
dcl  rscan fixed binary (18);

	do rscan = text_pos + 2 to text_pos + amt - 1 by 2;
	     q = addrel (object_base, rscan);

	     if q -> itp.itp_mod = ITP_mod		/* ITP word */
	     then if q -> itp.pr_no = lp
		then reloc_halfs (rscan + 1).left = rc_is18;
		else ;
	     else if q -> itp.itp_mod = "00"b3		/* ordinary indirect word */
	     then reloc_halfs (rscan).left = rc_t;
	     end;

     end relocate_itp_list;

assign_address_offset:
     procedure (p, inc, size, units);

	/* This procedure sets node.address.offset and node.location
	   from node.location and the offset increment inc. */

dcl  p pointer;					/* Node pointer */
dcl  inc fixed binary (18);				/* Offset increment */
dcl  size fixed binary (18);				/* Size of datum */
dcl  units fixed binary (3);				/* Units of size */

	call set_address_offset ((p), (p -> node.location + inc), (size), (units));

     end assign_address_offset;

set_address_offset:
     procedure (p, off, size, units);

	/* Sets p -> node.address.offset and p -> node.location to
	   the correct values for the offset off. */

dcl  p pointer;
dcl  (off, loc, offset) fixed binary (18);
dcl  size fixed binary (18);
dcl  units fixed binary (3);

	offset = off;

	if abs (offset) + get_size_in_words ((size), (units)) - 1 >= 16384
	then do;
	     loc = offset;
	     p -> node.large_address = "1"b;
	     p -> node.is_addressable = "0"b;
	     offset = mod (offset + 16384, 32768) - 16384;
	     p -> node.location = loc - offset;
	     end;

	p -> node.address.offset = offset;

     end set_address_offset;

get_size_in_words:
     procedure (size, units) returns (fixed binary (18));

	/* Converts a size in the specified units to word units */

dcl  size fixed binary (18);
dcl  (units, u) fixed binary (3);

dcl  factor (0:3) fixed binary (18) internal static options (constant) initial (1, 36, 4, 2);

	u = mod (units, 4);

	if u = word_units
	then return (size);				/* For speed */

	return (divide (size + factor (u) - 1, factor (u), 18, 0));

     end get_size_in_words;

get_size_in_bits:
     procedure (size, units) returns (fixed binary (18));

	/* Converts a size in the specified units to bits */

dcl  size fixed binary (18);
dcl  (units, u) fixed binary (3);

dcl  factor (0:3) fixed binary (18) internal static options (constant) initial (36, 1, 9, 18);

	u = mod (units, 4);
	return (size * factor (u));

     end get_size_in_bits;

assign_storage:
     procedure ();

	/* STORAGE ALLOCATOR

	   subprogram.storage_info is organized into 17 buckets to aid in
	   storage allocation.   The buckets are assigned as follows:

	   1	auto	double	init
	   2	auto	single	init
	   3	auto	double
	   4	auto	single
	   5	static	double	init
	   6	static	single	init
	   7	static	double
	   8	static	single
	   9	common & external constants
	   10	parameters
	   11	others
	   12	not allocated
	   13	Large Array Automatic
	   14	Large Array Static
	   15	Very Large Array Automatic
	   16	Very Large Array Static
	   17	Very Large Array Common
	*/

dcl  (cs, h, os, clp, psp, psap, s, ssp) pointer;
dcl  (hdr, sym, i, vsize, other_sym) fixed binary (18);
dcl  loc fixed binary (18);
dcl  not_found bit (1) aligned;
dcl  alloc_ps bit (1) aligned;

%include relocation_bits;

	/* 78.06.12 The parse now sets the following fields formerly set by the storage allocator.
	   Note that these fields are only set for those variables that need them:

	   symbol.data_type
	   symbol.element_size
	   symbol.auto		} One of these is set but only if the symbol
	   symbol.static		} is a variable without a storage class
	*/

	last_auto_loc = first_auto_loc;

	/* link_pos is the current offset of linkage entries from the end of static
	   for the duration of external assignement.  Then it transforms to be the
	   current address in the linkage section of relocation of static.
	   linkage_pad is the space which is occupied by the
	   LA and VLA base pointers for static variables.  linkage_pad delineates a
	   section which is within static, but which is not filled with normal variables. */

	linkage_pad = 0;

	Area_create_first, Area_init_first = -1;	/* flag off */

	alloc_ps, alloc_auto_cleanup = "0"b;

	/* setup for cleanup of VLA common processing lists */

	on cleanup call cleanup_VLA_common;

	/* allocate entry points */

	do sym = first_entry_name repeat s -> symbol.next_symbol while (sym > 0);
	     s = addr (rands (sym));

	     s -> symbol.operand_type = entry_type;
	     s -> symbol.hash_chain = 0;
	     s -> symbol.is_addressable = "1"b;
	     s -> symbol.reloc = rc_t;

	     /* associate a quick entry point with a subprogram entry pt */

	     if s -> symbol.name ^= main_entry_point_name
	     then s -> symbol.initial = create_rel_constant ();
	     end;

	/* do allocation for each subprogram */

	do cur_subprogram = first_subprogram repeat cs -> subprogram.next_subprogram while (cur_subprogram > 0);
	     cs = addr (rands (cur_subprogram));
	     call get_subr_options (cs);

	     /* see if ps needed */

	     alloc_ps = alloc_ps | cs -> subprogram.need_PS;

	     /* allocate labels */

	     do sym = cs -> subprogram.first_label repeat s -> label.next_label while (sym > 0);
		s = addr (rands (sym));
		s -> label.is_addressable = "1"b;
		s -> label.reloc = rc_t;
		end;

	     /* initialize storage info */

	     unspec (cs -> subprogram.storage_info) = "0"b;

	     /* Allocate vars in LA chain */

	     hdr = cs -> subprogram.LA_chain;
	     do while (hdr > 0);
		h = addr (rands (hdr));
		if h -> header.allocate
		then do;
		     h -> header.needs_pointer = "1"b;
		     unspec (h -> header.address) = ext_base_on;
		     h -> header.allocated = "1"b;

		     call alloc_members;

		     h -> header.reloc = RI_mod;

		     /* Allocate the unpacked pointer storage in either static or automatic */

		     if h -> header.static
		     then do;
			i = 14;			/* LA static */
			if mod (linkage_pad + size (virgin_linkage_header), 2) ^= 0
			then linkage_pad = linkage_pad + 1;
			h -> header.location = linkage_pad + size (virgin_linkage_header);
			h -> header.base = lp;
			linkage_pad = linkage_pad + 2;/* assign double word */
			end;
		     else do;
			i = 13;			/* LA auto */
			if mod (last_auto_loc, 2) ^= 0
			then last_auto_loc = last_auto_loc + 1;
						/* even word aligned */

			h -> header.location = last_auto_loc;
			h -> header.base = sp;
			last_auto_loc = last_auto_loc + 2;
			end;


		     call create_storage_entry (h);

		     /* relocate members of Large Arrays */

		     do sym = h -> header.first_element repeat s -> symbol.next_member while (sym > 0);
			s = addr (rands (sym));
			call assign_address_offset (s, 0, (s -> symbol.element_size), (s -> symbol.units));
			end;

		     if h -> header.initialed
		     then call list_initialize (addrel (object_base, text_pos), hdr, text_pos);

		     /* thread the block on the LA lists */

		     if cs -> subprogram.storage_info.last (i) = 0
		     then cs -> subprogram.storage_info.first (i) = hdr;
		     else addr (rands (cs -> subprogram.storage_info.last (i))) -> header.next_header = hdr;
		     cs -> subprogram.storage_info.last (i) = hdr;

		     end;

		/* on to the next header */

		hdr = h -> header.next_header;
		h -> header.next_header = 0;
		end;

	     /* Allocate vars in VLA chain */
               /* 87.12.13  The relocation factor for VLA common block members is 
                  absolute (rc_a); whereas the relocation factor for VLA common block
                  is internal_static_15 (rc_is15).                                   */

	     hdr = cs -> subprogram.VLA_chain;
	     do while (hdr > 0);
		h = addr (rands (hdr));
		if h -> header.allocate
		then do;
		     h -> header.allocated = "1"b;
		     h -> header.needs_pointer = "1"b;
		     unspec (h -> header.address) = ext_base_on;
		     h -> header.reloc = rc_a;

		     if h -> header.automatic
		     then h -> header.address.base = sp;
		     else h -> header.address.base = lp;

		     call alloc_members;

		     /*  Allocate the base addressor.  */

		     if ^h -> header.automatic then h -> header.reloc = rc_is15;
		     s = addr (rands (h -> header.VLA_base_addressor));
		     s -> symbol.is_addressable = "1"b;
		     s -> symbol.allocated = "1"b;
		     s -> symbol.address = h -> header.address;
		     s -> symbol.reloc = h -> header.reloc;

		     if h -> header.in_common
		     then do;
			i = 17;			/* VLA common */
			call note_VLA_common (h);
			end;
		     else do;

			/* Allocate the addressor storage in either static or automatic */

			if h -> header.static
			then do;
			     i = 16;		/* VLA static */
			     h -> header.location, h -> header.address.offset =
				linkage_pad + size (virgin_linkage_header);
			     linkage_pad = linkage_pad + 1;
						/* space for base addressor */
			     end;
			else do;
			     i = 15;		/* VLA auto */

			     h -> header.location, h -> header.address.offset = last_auto_loc;
			     last_auto_loc = last_auto_loc + 1;
						/* space for base addressor */
			     end;
			call set_address_offset (s, (h -> header.location), 1, word_units);
			call create_storage_entry (h);
			if h -> header.initialed
			then call list_initialize (addrel (object_base, text_pos), hdr, text_pos);
			end;

		     /* thread the block on the VLA lists */

		     if cs -> subprogram.storage_info.last (i) = 0
		     then cs -> subprogram.storage_info.first (i) = hdr;
		     else addr (rands (cs -> subprogram.storage_info.last (i))) -> header.next_header = hdr;
		     cs -> subprogram.storage_info.last (i) = hdr;

		     end;

		/* on to the next header */

		hdr = h -> header.next_header;
		h -> header.next_header = 0;
		end;

	     /* Allocate vars in common chain */

	     hdr = cs -> subprogram.common_chain;
	     do while (hdr > 0);
		h = addr (rands (hdr));
		if h -> header.allocate
		then do;
		     h -> header.needs_pointer = "1"b;
		     unspec (h -> header.address) = ext_base_on;
		     h -> header.allocated = "1"b;

		     call alloc_members;

		     h -> header.location = alloc_external (h);

		     /* thread the block on the linkage list */

		     if cs -> subprogram.storage_info.last (9) = 0
		     then cs -> subprogram.storage_info.first (9) = hdr;
		     else addr (rands (cs -> subprogram.storage_info.last (9))) -> header.next_header = hdr;
		     cs -> subprogram.storage_info.last (9) = hdr;

		     end;

		/* on to the next header */

		hdr = h -> header.next_header;
		h -> header.next_header = 0;
		end;

	     /* Allocate other equivalence blocks */

	     hdr = cs -> subprogram.equiv_chain;
	     do while (hdr > 0);
		h = addr (rands (hdr));
		if h -> header.allocate
		then do;

		     /* get subclass of equivalence group */

		     if h -> header.even
		     then i = 1;
		     else i = 2;
		     if ^h -> header.initialed
		     then i = i + 2;
		     if h -> header.static
		     then i = i + 4;

		     /* allocate */

		     if h -> header.odd
		     then if mod (cs -> subprogram.next_loc (i), 2) = 0
			then cs -> subprogram.next_loc (i) = cs -> subprogram.next_loc (i) + 1;

		     loc = cs -> subprogram.next_loc (i);
		     cs -> subprogram.next_loc (i) = cs -> subprogram.next_loc (i) + h -> header.length;
		     if mod (i, 2) ^= 0
		     then cs -> subprogram.next_loc (i) = cs -> subprogram.next_loc (i) + mod (h -> header.length, 2);


		     unspec (h -> header.address) = ext_base_on;
		     h -> header.location = loc;
		     if h -> header.static
		     then do;
			h -> header.base = lp;
			h -> header.reloc = rc_is15;
			end;
		     else h -> header.base = sp;
		     h -> header.is_addressable = "1"b;
		     h -> header.allocated = "1"b;

		     /* allocate elements of equiv chain */

		     call alloc_members;
		     end;

		else i = 12;

		/* thread the header in */

		if cs -> subprogram.storage_info.last (i) = 0
		then cs -> subprogram.storage_info.first (i) = hdr;
		else addr (rands (cs -> subprogram.storage_info.last (i))) -> header.next_header = hdr;
		cs -> subprogram.storage_info.last (i) = hdr;

		hdr = h -> header.next_header;
		h -> header.next_header = 0;
		end;

	     /* Allocate non-equivalenced symbols */

	     sym = cs -> subprogram.first_symbol;
	     do while (sym > 0);
		s = addr (rands (sym));
		if ^s -> symbol.allocated
		then do;
		     if s -> symbol.parameter
		     then s -> symbol.hash_chain = 0;	/* Required by 'make_symbol_descriptor'. */

		     /* Fix up request for 'PARAMETER' variables fully probe-able by allocating if
		        we want a symbol table. */

		     if s -> symbol.named_constant & cs -> subprogram.options.table
		     then do;
			s -> symbol.allocate = "1"b;
			addr (rands (s -> symbol.initial)) -> node.allocate = "1"b;
			end;

		     if s -> symbol.allocate
		     then do;
			unspec (s -> symbol.address) = "0"b;

			s -> symbol.hash_chain = 0;

			if s -> symbol.stmnt_func
			then do;
			     s -> symbol.operand_type = statement_function;
			     i = 11;
			     end;
			else if s -> symbol.builtin
			then do;
			     s -> symbol.operand_type = bif;
			     i = 11;
			     end;
			else if s -> symbol.named_constant
			then i = 11;
			else if s -> symbol.namelist
			then do;
			     s -> label.location = text_pos;
			     s -> symbol.is_addressable = "1"b;
			     s -> symbol.reloc = rc_t;

			     vsize = divide (polish (s -> symbol.initial) + 4, 2, 17, 0);
			     text_pos = text_pos + vsize;

			     if last_namelist = 0
			     then first_namelist = sym;
			     else addr (rands (last_namelist)) -> symbol.next_member = sym;
			     last_namelist = sym;

			     i = 11;
			     end;
			else if s -> symbol.parameter | s -> symbol.stack_indirect
			then do;
			     i = 10;
			     if s -> symbol.external
			     then s -> symbol.operand_type = external;
			     else s -> symbol.operand_type = variable_type;

			     if s -> symbol.VLA
			     then do;

				/*  Allocate the base addressor of the VLA.  */
				other_sym = addr (rands (s -> symbol.dimension)) -> dimension.VLA_base_addressor;
				os = addr (rands (other_sym));
				os -> symbol.is_addressable = "1"b;
				os -> symbol.allocated = "1"b;
				unspec (os -> symbol.address) = ext_base_on;
				os -> symbol.address.base = sp;
				os -> symbol.address.offset = last_auto_loc;
				if ^VLA_is_256K
				then last_auto_loc = last_auto_loc + 1;

				/*  Allocate the packed ptr to the VLA.  */
				if last_auto_loc > max_address_offset
				then call print_message (414, "The location of a VLA parameter base pointer",
					max_address_offset - bias);
				s -> symbol.needs_pointer = "1"b;
				s -> symbol.address.base = sp;
				s -> symbol.address.offset = last_auto_loc;
				last_auto_loc = last_auto_loc + 1;
				s -> symbol.location = s -> symbol.location * 2;
				end;

			     else if s -> symbol.stack_indirect
			     then do;

				/* multiple positions -- we need an auto
				   ptr to point at the parameter */

				if mod (last_auto_loc, 2) ^= 0
				then last_auto_loc = last_auto_loc + 1;
						/* even word aligned */
				s -> symbol.location = last_auto_loc;
				last_auto_loc = last_auto_loc + 2;
				if last_auto_loc > max_stack_size
				then call print_message (414,
					"in making multiple position parameter temporary the stack frame",
					max_stack_size - bias);
				end;

			     else			/*  the actual ptr location is twice the parameter number */
				s -> symbol.location = s -> symbol.location * 2;

			     /* set up address field */

			     s -> symbol.ext_base = "1"b;

			     if s -> symbol.dimensioned
			     then do;
				s -> symbol.needs_pointer = "1"b;
				vsize = get_array_size (s);
				end;
			     else if s -> symbol.data_type = cmpx_mode
			     then s -> symbol.needs_pointer = "1"b;
			     else if s -> symbol.data_type = char_mode
			     then do;
				s -> symbol.needs_pointer = "1"b;
				if s -> symbol.variable_extents | s -> symbol.star_extents
				then if s -> symbol.needs_descriptors | s -> symbol.passed_as_arg
					| s -> symbol.put_in_symtab | shared_globals.options.table
				     then vsize = make_symbol_descriptor (fixed (rel (s), 18));
				end;
			     else do;
				if ^s -> symbol.VLA
				then do;
				     s -> symbol.address.offset = s -> symbol.location;
				     s -> symbol.tag = RI_mod;
						/* RI */
				     end;
				else s -> symbol.tag = rc_a;
						/* stack */
				if s -> symbol.stack_indirect
				then do;
				     s -> symbol.address.base = sp;
				     s -> symbol.is_addressable = "1"b;
				     end;
				end;
			     end;
			else if s -> symbol.external
			then do;

			     /* function or subroutine reference */

			     s -> symbol.operand_type = external;

			     /* check if name is on subprogram in this compilation */

			     not_found = "1"b;
			     other_sym = first_entry_name;
			     do while (other_sym > 0 & not_found);
				os = addr (rands (other_sym));
				if s -> symbol.name = os -> symbol.name
				then not_found = "0"b;
				else other_sym = os -> symbol.next_symbol;
				end;

			     if not_found
			     then do;
				s -> symbol.ext_base = "1"b;
				s -> symbol.base = lp;
				s -> symbol.location = alloc_external (s);
				s -> symbol.tag = RI_mod;
						/* RI */
				s -> symbol.reloc = rc_lp15;
				s -> symbol.is_addressable = "1"b;
				end;

			     else do;
				s -> symbol.is_addressable = "0"b;
				s -> symbol.reloc = rc_t;
				s -> symbol.initial = other_sym;
				s -> symbol.needs_descriptors = os -> symbol.needs_descriptors;
				end;

			     i = 9;
			     end;
			else do;

			     /* data type and storage class (must be auto or static) assigned by the parse */

			     s -> symbol.operand_type = variable_type;

			     if s -> symbol.dimensioned
			     then vsize = get_array_size (s);
			     else vsize = get_size_in_words ((s -> symbol.element_size), (s -> symbol.units));

			     /* get subclass */

			     if data_type_size (s -> symbol.data_type) = 2
			     then i = 1;
			     else i = 2;
			     if ^s -> symbol.initialed
			     then i = i + 2;
			     if s -> symbol.static
			     then i = i + 4;

			     /* allocate */

			     loc = cs -> subprogram.next_loc (i);
			     cs -> subprogram.next_loc (i) = cs -> subprogram.next_loc (i) + vsize;

			     /* set up addressing */

			     if s -> symbol.static
			     then do;
				s -> symbol.base = lp;
				s -> symbol.reloc = rc_is15;
				end;
			     else s -> symbol.base = sp;
			     s -> symbol.location = loc;
			     s -> symbol.ext_base = "1"b;

			     s -> symbol.is_addressable = "1"b;
			     end;

			/* set allocated bit */

			s -> symbol.allocated = "1"b;
			end;

		     else i = 12;

		     /* thread symbol into new list */

		     if cs -> subprogram.storage_info.last (i) = 0
		     then cs -> subprogram.storage_info.first (i) = sym;
		     else addr (rands (cs -> subprogram.storage_info.last (i))) -> symbol.next_symbol = sym;
		     cs -> subprogram.storage_info.last (i) = sym;
		     end;

		sym = s -> symbol.next_symbol;
		s -> symbol.next_symbol = 0;
		end;

	     end;

	/* Allocate <*symbol>|0 link, if necessary */

	if generate_symtab
	then do;

	     /* compile_link depends on symbol.name_length being 0 */

	     builtins (9) = create_node (symbol_node, size (symbol));
	     ssp = addr (rands (builtins (9)));
	     ssp -> symbol.operand_type = dummy;
	     ssp -> symbol.by_compiler = "1"b;
	     ssp -> symbol.external, ssp -> symbol.allocate, ssp -> symbol.allocated, ssp -> symbol.is_addressable,
		ssp -> symbol.ext_base = "1"b;
	     ssp -> symbol.base = lp;
	     ssp -> symbol.tag = RI_mod;		/* RI */
	     ssp -> symbol.reloc = rc_lp15;
	     ssp -> symbol.location = alloc_external (ssp);
	     end;
	else builtins (9) = 0;

	/* If a ps is needed, allocate it first to prevent problems with 16K boundary.
	   ps must be in automatic storage because namelist, err=, and end= require current stack
	   ptr to be in ps at all times, even after return from a->b->a segment flow.  */

	if alloc_ps
	then do;
	     builtins (2) = create_node (symbol_node, size (symbol));
	     psp = addr (rands (builtins (2)));
	     psp -> symbol.operand_type = dummy;
	     psp -> symbol.by_compiler = "1"b;
	     psp -> symbol.automatic, psp -> symbol.allocate, psp -> symbol.allocated, psp -> symbol.is_addressable,
		psp -> symbol.ext_base = "1"b;
	     psp -> symbol.base = sp;
	     psp -> symbol.reloc = rc_a;
	     last_auto_loc = divide (last_auto_loc + 1, 2, 17, 0) * 2;
						/* EVEN WORD NEEDED */
	     call assign_address_offset (psp, last_auto_loc, 48, word_units);
	     last_auto_loc = last_auto_loc + 48;
	     if last_auto_loc > max_stack_size
	     then call print_message (414, "in making parameter storage for IO the stack frame", max_stack_size - bias);

	     /*	Build a symbol that overlays the PS at the field buffer_p (offset 20b3). This symbol
	        is used to load the value of this pointer by the object segment. */

	     builtins (10) = create_node (symbol_node, size (symbol));
	     psap = addr (rands (builtins (10)));
	     psap -> symbol = psp -> symbol;		/* use PS symbol as template to create this one */
	     psap -> symbol.address.offset = psap -> symbol.address.offset + 16;
						/* = 20b3 */
	     end;

	else builtins (2), builtins (10) = 0;

	/* If a cleanup body is needed, allocate it.  */

	if alloc_auto_cleanup
	then do;
	     cleanup_body_address = create_node (symbol_node, size (symbol));
	     clp = addr (rands (cleanup_body_address));
	     clp -> symbol.operand_type = dummy;
	     clp -> symbol.by_compiler = "1"b;
	     clp -> symbol.automatic, clp -> symbol.allocate, clp -> symbol.allocated, clp -> symbol.is_addressable,
		clp -> symbol.ext_base = "1"b;
	     clp -> symbol.base = sp;
	     clp -> symbol.reloc = rc_a;
	     last_auto_loc = divide (last_auto_loc + 1, 2, 17, 0) * 2;
						/* EVEN WORD NEEDED */
	     call assign_address_offset (clp, last_auto_loc, 8, word_units);
	     cleanup_body_address = last_auto_loc;
	     last_auto_loc = last_auto_loc + 8;
	     if last_auto_loc > max_stack_size
	     then call print_message (414, "in making cleanup body the stack frame", max_stack_size - bias);
	     end;
	else cleanup_body_address = 0;

	/* Allocate space for all VLA COMMON */

	call allocate_VLA_common;

	/* All subprograms done, relocate auto & static items */

	link_pos = divide (size (virgin_linkage_header) + linkage_pad + 1, 2, 18, 0) * 2;
	first_auto_var_loc = last_auto_loc;

	/* now relocate all other static and auto items */

	call relocate (1, last_auto_loc, max_stack_size, "stack frame");
	call relocate (5, link_pos, max_linkage_size, "linkage section");

	/* allocate profile space, if -profile */

	if generate_profile
	then do;
	     profile_start, profile_pos = link_pos;
	     if generate_long_profile
	     then do;
		profile_pos = size (long_profile_header);
		link_pos = link_pos + size (long_profile_header) + size (long_profile_entry) * (profile_size + 1);
		end;
	     else link_pos = link_pos + size (profile_entry) * (profile_size + 1);

	     link_pos = link_pos + mod (link_pos, 2);
	     if link_pos > max_linkage_size
	     then call print_message (414, "when allocating PROFILE information the linkage section",
		     char (max_linkage_size));
	     end;

	/* Finally, relocate common + external refs */

	begin_links = link_pos;

	do cur_subprogram = first_subprogram repeat cs -> subprogram.next_subprogram while (cur_subprogram > 0);
	     cs = addr (rands (cur_subprogram));
	     call get_subr_options (cs);

	     /* relocate external refs for VLA common */

	     do hdr = cs -> subprogram.storage_info.first (17) repeat h -> node.next while (hdr > 0);
		h = addr (rands (hdr));
		h -> node.location = h -> node.location + link_pos;
		end;

	     /* relocate common and external */
	     do hdr = cs -> subprogram.storage_info.first (9) repeat h -> node.next while (hdr > 0);
		h = addr (rands (hdr));

		if h -> node.node_type = header_node
		then do;
		     h -> node.location = h -> node.location + link_pos;
		     do sym = h -> header.first_element repeat s -> symbol.next_member while (sym > 0);
			s = addr (rands (sym));
			call assign_address_offset (s, 0, (s -> symbol.element_size), (s -> symbol.units));
			end;
		     end;

		else do;
		     if h -> symbol.initial = 0
		     then call assign_address_offset (h, link_pos, 2, word_units);
		     else h -> symbol.allocated = "0"b;
		     end;
		end;


	     end;


	/* Relocate the link pointer in the 'create_entry' for common. */

	call VLA_reloc_common_link;


	if generate_symtab
	then call assign_address_offset (ssp, link_pos, 2, word_units);

	link_pos = link_pos + (next_free_polish - begin_external_list) - ((next_free_polish - begin_external_list) / 3);
						/* i.e., two words per link */
	if link_pos > max_linkage_size
	then call print_message (414,
		"after allocating SYMTAB space for " || addr (rands (cs -> subprogram.symbol)) -> symbol.name
		|| " the linkage section", char (max_linkage_size));

	return;

alloc_external:
     procedure (pt) returns (fixed binary (18));

	/* Searches the external_list to see if a common block or
	   external reference has already been allocated before
	   allocating a new link to it.

	   The current implementation for the external list consists of
	   three items per external variable. The first item is a pointer
	   to a symbol node (for external entry points) or a pointer to
	   a header node (for common blocks). The second item is only
	   used for common blocks and specifies the (maximum) length for
	   the common block.  The third item is also only used for common
	   block and indicates the units (words or characters of the
	   maximum length. */

dcl  (p, pt) pointer;
dcl  loc fixed binary (18);
dcl  i fixed binary (18);
dcl  ceil builtin;
dcl  header_length fixed binary (24);

	p = pt;

	if p -> node.node_type = symbol_node
	then do i = begin_external_list to next_free_polish - 1 by 3;
		if ext_ref (i) -> node.node_type = symbol_node
		then if p -> symbol.name = ext_ref (i) -> symbol.name
		     then return (ext_ref (i) -> symbol.location);
		end;

	else do i = begin_external_list to next_free_polish - 1 by 3;
		if ext_ref (i) -> node.node_type = header_node
		then if p -> header.block_name = ext_ref (i) -> header.block_name
		     then do;
			loc = ext_ref (i) -> header.location;

			if p -> header.block_name = blank_common_name
			then do;
			     if p -> header.units = polish (i + 2)
			     then header_length = p -> header.length;
			     else if polish (i + 2) = word_units
			     then header_length = ceil (p -> header.length / 4);
			     else header_length = p -> header.length * 4;
						/* change to character units */
			     if header_length > polish (i + 1)
						/* current max length */
			     then polish (i + 1) = header_length;
						/* update max length for unlabelled common */
			     end;
			else do;
			     if p -> header.units = polish (i + 2)
			     then header_length = p -> header.length;
			     else if polish (i + 2) = word_units
			     then header_length = ceil (p -> header.length / 4);
			     else header_length = p -> header.length * 4;
						/* change to character units */
			     if header_length > polish (i + 1)
						/* current max length for block */
			     then do;
				polish (i + 1) = header_length;
						/* update length for common block */
				if polish (i + 2) = word_units
				then call print_message (426, fixed (rel (p), 18), ltrim (char (header_length)),
					"words");
				else call print_message (426, fixed (rel (p), 18), ltrim (char (header_length)),
					"characters");
				end;
			     else if header_length < polish (i + 1)
						/* check for different length */
			     then call print_message (434, fixed (rel (p), 18));

			     if p -> header.initialed
			     then if ext_ref (i) -> header.initialed
				then call print_message (432, fixed (rel (p), 18));
				else ext_ref (i) = p;
			     end;

			return (loc);
			end;
		end;

	/* allocate new entry in external list */

	if next_free_polish + 2 < polish_max_len
	then do;
	     ext_ref (next_free_polish) = p;

	     if p -> node.node_type = header_node	/* for common blocks, save block length */
	     then do;
		polish (next_free_polish + 1) = p -> header.length;
		polish (next_free_polish + 2) = p -> header.units;
		end;
	     next_free_polish = next_free_polish + 3;

	     loc = link_pos;
	     link_pos = link_pos + 2;
	     if link_pos > max_linkage_size
	     then call print_message (414, "linkage section", char (max_linkage_size));

	     return (loc);
	     end;

	else call print_message (407, "polish region", char (polish_max_len));

     end alloc_external;

alloc_members:
     procedure ();

	/* Allocates members of common blocks and equivalence groups. */

	do sym = h -> header.first_element repeat s -> symbol.next_member while (sym > 0);
	     s = addr (rands (sym));
	     substr (string (s -> symbol.storage_class), 1, 3) = string (h -> header.storage_class);
	     unspec (s -> symbol.address) = unspec (h -> header.address);
	     s -> symbol.reloc = h -> header.reloc;
	     if s -> symbol.units = char_units
	     then do;
		s -> symbol.location = h -> header.location + divide (s -> symbol.offset, chars_per_word, 18, 0);
		s -> symbol.address.char_num = mod (s -> symbol.offset, chars_per_word);
		end;
	     else s -> symbol.location = h -> header.location + s -> symbol.offset;
	     s -> symbol.operand_type = variable_type;
	     string (s -> symbol.addressing_bits) = string (h -> header.addressing_bits);
	     s -> symbol.hash_chain = 0;
	     if s -> symbol.dimensioned
	     then vsize = get_array_size (s);
	     end;

     end alloc_members;

create_storage_entry:
     proc (h);

	/* Purpose:  Create a creation list entry in the text section, and link it to
	   the last such entry.  Information required is taken from the chain
	   header supplied. */


dcl  h ptr;					/* Incoming header pointer */

dcl  cur_pos fixed bin (18) unsigned;			/* current position in text section */
dcl  listp ptr;
dcl  i fixed bin;


dcl  (currentsize, length) builtin;

	call make_create_entry (h);

	if h -> header.VLA				/* setup pointers */
	then do sym = h -> header.first_element repeat s -> symbol.next_member while (sym > 0);
		s = addr (rands (sym));
		if s -> symbol.offset = 0 & VLA_is_256K
		then call set_address_offset (s, (h -> header.location), 1, word_units);
		else do;
		     listp -> create_entry.pointer_count = listp -> create_entry.pointer_count + 1;
		     call set_address_offset (s, h -> header.location + listp -> create_entry.pointer_count, 1,
			word_units);
		     listp -> create_entry.pointer_offsets (listp -> create_entry.pointer_count).offset =
			s -> symbol.offset;
		     if h -> header.static
		     then linkage_pad = linkage_pad + 1;
		     else last_auto_loc = last_auto_loc + 1;

		     /* save the symbol name for the listing */
		     if assembly_list
		     then do;
			cur_pos =
			     fixed (
			     rel (
			     addr (listp -> create_entry.pointer_offsets (listp -> create_entry.pointer_count))));
			a_name (cur_pos) = fixed (rel (s));
			end;
		     end;
		end;

	/* increment past all information */

	text_pos = text_pos + currentsize (listp -> create_entry);
	return;

note_VLA_common:
     entry (h);


	/* Take note of common blocks in VLA common, and combine them into single
	   composite representations for each common of every definition of that
	   common.  This means determining the maximum length, the number of unique
	   offsets into the common (to build pointer information), and any init
	   information. */

dcl  chain_head ptr;				/* head of current chain */
dcl  hdr ptr;					/* current entry node */
dcl  looping bit (1);				/* scanning chain */
dcl  s ptr;					/* current symbol */
dcl  sym fixed bin (18);				/* current symbol node */
dcl  this_chain ptr;				/* last header of current chain */


	/* entry for headers and symbols. */

dcl  1 entry based (hdr),
       2 next ptr,					/* next entry in header list */
       2 chain ptr,					/* next entry in chain */
       2 node ptr,					/* pointer node in rands */
       2 header bit (1) unaligned,			/* node is a header */
       2 offset fixed bin (35) unsigned unaligned;	/* symbol offset */

	if first_header = null ()			/* no list */
	then goto create_header;

	/* find header chain. */

	do hdr = first_header repeat entry.next while (hdr ^= null ());
	     if entry.node -> header.block_name = h -> header.block_name
	     then goto add_header;			/* in right chain */
	     end /* do hdr */;

	/* at this point we don't have the right chain, but we do have a list */

	if hdr = null ()
	then do;

create_header:
	     call make_entry;
	     if first_header = null ()		/* chain to list */
	     then first_header = hdr;
	     else last_header -> entry.next = hdr;
	     last_header = hdr;
	     end;
	else do;					/* cannot enter through the do, it is just for blocking */

	     /* form maximum length */

add_header:
	     chain_head = hdr;
	     if h -> header.length ^= entry.node -> header.length
	     then do;

		/* form maximum common block lengths */

		if h -> header.block_name ^= blank_common_name
		then if h -> header.length > entry.node -> header.length
		     then call print_message (426, fixed (rel (h), 18), ltrim (char (h -> header.length)));
		     else call print_message (434, fixed (rel (h), 18));

		if h -> header.length > entry.node -> header.length
		then h -> header.length = entry.node -> header.length;
		end;


	     /* find end of headers in chain list. */

	     do hdr = chain_head repeat entry.chain while (entry.chain -> entry.header = "1"b);
		end;				/* leave hdr pointing at last header of chain */

	     /* Link new entry into chain as last header in header portion of chain */

	     this_chain = hdr;
	     call make_entry;
	     entry.chain = this_chain -> entry.chain;
	     this_chain -> entry.chain = hdr;
	     end;


	/* Add list of symbols to chain.  Last header of chain is at 'hdr' */
	/* This leaves a list sorted by symbol offset. */

add_symbols:
	chain_head = hdr;
	do sym = h -> header.first_element repeat s -> symbol.next_member while (sym > 0);
	     s = addr (rands (sym));

	     /* add total if chain is empty of symbols. */

	     this_chain = chain_head;
	     if this_chain -> entry.chain ^= null ()
	     then do;
		looping = "1"b;
		do while (looping);
		     this_chain = this_chain -> entry.chain;
		     if this_chain -> entry.chain = null ()
		     then looping = "0"b;
		     else if this_chain -> entry.chain -> entry.offset > s -> symbol.offset
		     then looping = "0"b;
		     end;
		end;

	     /* hdr points at add_point to chain */

	     call make_entry;
	     entry.offset = s -> symbol.offset;
	     entry.chain = this_chain -> entry.chain;
	     entry.node = s;
	     entry.header = "0"b;
	     this_chain -> entry.chain = hdr;
	     end /* do sym */;
	return;

	/*	   Assign Storage to VLA common. */
allocate_VLA_common:
     entry;

	/* Assign storage address and storage creation information.  This is done
	   by scanning the finalized lists and copying the maximum length through all
	   headers for the multiple uses of that common, then creating a storage
	   creation entry for the common, and then assigning a pointer location
	   to each unique offset, and copying that pointer location into the symbols
	   mapped into that unique offset.  At the same point a storage creation
	   pointer is created and assigned that offset.  Initialization information
	   is picked up in a separate pass through the symbols. */

dcl  common_length fixed bin (35);			/* common_length of the common block */
dcl  current_offset fixed bin (35);			/* current symbol offset processing */
dcl  location fixed bin (18);				/* location of packed pointers */

	/* scan commons */

	do chain_head = first_header repeat chain_head while (chain_head ^= null ());

	     /* pick up the maximum length and propagate it through the multiple copies of headers */

	     common_length = chain_head -> entry.node -> header.length;

	     /* 'header.location' is the normal location in which the
	        external link would be found and will be later relocated
	        and external reference made. */

	     /* At this point header.location is the pointer to the first PP. */

	     /* NOTE - you will see the strange construction 'copy ("0"b, 18 - length (x)) || x'
	        in setting 'reloc_halfs' in this code.  This is because of the use to two
	        different definitions for 'rc_t' and 'rc_lp18', one for 6-bits and the
	        other for 18-bits.  Why they have the same name I do not know, but I do know
	        that the binder is very unhappy to receive a 6-bit relocation value left
	        adjusted in an 18-bit field, hence the padding.  If some turkey changes the
	        definition in the future, and I get the 18-bitter, it will still work. */

	     location, chain_head -> entry.node -> header.location = linkage_pad + size (virgin_linkage_header);
	     linkage_pad = linkage_pad + 1;		/*  space for base addressor  */
	     call make_create_entry (chain_head -> entry.node);
	     chain_head -> entry.node -> header.location, listp -> create_entry.common_link =
		alloc_external (chain_head -> entry.node);
	     reloc_halfs (text_pos + 3).left = copy ("0"b, 18 - length (rc_lp18)) || rc_lp18;
	     call set_address_offset (addr (rands (chain_head -> entry.node -> header.VLA_base_addressor)), (location),
		1, word_units);

	     do hdr = chain_head -> entry.chain repeat entry.chain while (entry.header = "1"b);
		entry.node -> header.length = common_length;
		entry.node -> header.location = alloc_external (entry.node);
		call set_address_offset (addr (rands (entry.node -> header.VLA_base_addressor)), (location), 1,
		     word_units);
		end;

	     if VLA_is_256K
	     then current_offset = 0;			/*  Base addressor is a packed ptr to offset 0.  */
	     else current_offset = -1;		/*  Base addressor is logical address of offset 0.  */
	     i = 0;				/* current pointer */
	     do hdr = hdr repeat entry.chain while (hdr ^= null ());
		s = entry.node;
		if s -> symbol.offset ^= current_offset
		then i = i + 1;			/* count unique pointer */
		call set_address_offset (s, location + i, 1, word_units);

		/* Save a copy of the offset information */
		s -> symbol.addr_hold = substr (unspec (s -> symbol.address), 1, 18);

		/* create a pointer for all but possibly the first unique entry */

		if s -> symbol.offset ^= current_offset
		then do;
		     current_offset = s -> symbol.offset;
		     listp -> create_entry.pointer_count = i;
		     listp -> create_entry.pointer_offsets (i).offset = s -> symbol.offset;
		     linkage_pad = linkage_pad + 1;

		     /* save the symbol name for the listing */
		     if assembly_list
		     then do;
			cur_pos = fixed (rel (addr (listp -> create_entry.pointer_offsets (i))));
			a_name (cur_pos) = fixed (rel (s));
			end;
		     end /* do */;
		end /* do hdr */;

	     text_pos = text_pos + currentsize (listp -> create_entry);

	     chain_head = chain_head -> entry.next;
	     end /* do chain_head */;

	call cleanup_VLA_common;			/* Use common cleanup */
	return;

	/* Entry to relocate the link relative offset left in the create_entry for
	   common VLA, to become a true linkage section offset. */

VLA_reloc_common_link:
     entry;


	looping = "1"b;				/* loop through list */

	location = Area_create_first;
	if Area_create_first ^= -1
	then do while (looping = "1"b);
		listp = addrel (object_base, location);
		if listp -> create_entry.common
		then listp -> create_entry.common_link = listp -> create_entry.common_link + link_pos;
		location = listp -> create_entry.next;
		if location = 0
		then looping = "0"b;
		end;
	return;



cleanup_VLA_common:
     entry;

	/* Cleanup vla common allocation lists when cleanup encountered. */

	if first_header = null ()
	then return;

	do first_header = first_header repeat first_header while (first_header ^= null ());
	     chain_head = first_header;
	     first_header = first_header -> entry.next;
	     do this_chain = chain_head repeat this_chain while (this_chain ^= null ());
		hdr = this_chain;
		this_chain = entry.chain;
		free entry;
		end /* do this_chain */;
	     end /* do first_header */;

	return /* cleanup_VLA_common */;


	/* create an entry for a header/symbol */
make_entry:
     proc;

	allocate entry;
	entry.node = h;
	entry.chain, entry.next = null ();
	entry.offset = 0;
	entry.header = "1"b;
	return;
     end make_entry;				/*						   Make the basic creation list entry. */
make_create_entry:
     proc (h);

dcl  h ptr;
dcl  i fixed bin (18);				/* index in text */
dcl  last_listp ptr;				/* -> last create_entry */

	listp = addrel (object_base, text_pos);

	/* Set location of base pointer in section and set relocation of pointer */

	listp -> create_entry.location = h -> header.location;
	if h -> header.static | h -> header.in_common
	then reloc_halfs (text_pos).left = copy ("0"b, 18 - length (rc_is15)) || rc_is15;
	else if h -> header.automatic
	then reloc_halfs (text_pos).left = copy ("0"b, 18 - length (rc_a)) || rc_a;

	listp -> create_entry.auto = h -> header.automatic;
	listp -> create_entry.static = h -> header.static;
	listp -> create_entry.common = h -> header.in_common;
	listp -> create_entry.LA = h -> header.LA;
	listp -> create_entry.VLA = h -> header.VLA;
	listp -> create_entry.K256 = VLA_is_256K;
	listp -> create_entry.init = h -> header.initialed;
	listp -> create_entry.length = h -> header.length;
	listp -> create_entry.next = 0;
	listp -> create_entry.name_length = h -> header.name_length;
	if listp -> create_entry.name_length ^= 0
	then listp -> create_entry.block_name = h -> header.block_name;

	listp -> create_entry.pointer_count = 0;

	if h -> header.automatic
	then alloc_auto_cleanup = "1"b;		/* cleanup automatic LA's and VLA's */

	if Area_create_first < 0			/* flagged empty */
	then Area_create_first = text_pos;
	else do;

	     /* Link previous entry to this one and set relocation too. */

	     last_listp = addrel (object_base, Area_create_last);
	     last_listp -> create_entry.next = text_pos;
	     i = fixed (rel (addr (last_listp -> create_entry.next)), 18, 0) - fixed (rel (object_base), 18, 0);
	     reloc_halfs (i).left = copy ("0"b, 18 - length (rc_t)) || rc_t;
	     end;
	Area_create_last = text_pos;

     end make_create_entry;
     end create_storage_entry;

relocate:
     procedure (which, locn, limit, section_name);

	/* Relocates items in each bucket. */

dcl  which fixed binary (18),
     locn fixed binary (18),
     limit fixed binary (18),				/* limit of section */
     section_name char (*);				/* name of section */

dcl  (i, loc, start) fixed binary (18);

	loc = locn;

	do start = which to which + 2 by 2;
	     do cur_subprogram = first_subprogram repeat cs -> subprogram.next_subprogram while (cur_subprogram > 0);
		cs = addr (rands (cur_subprogram));
		call get_subr_options (cs);

		do i = start to start + 1;
		     cs -> subprogram.next_loc (i) = cs -> subprogram.next_loc (i) + loc;

		     do hdr = cs -> subprogram.storage_info.first (i) repeat h -> node.next while (hdr > 0);
			h = addr (rands (hdr));

			if h -> node.node_type = header_node
			then do;
			     call assign_address_offset (h, loc, 1, word_units);
			     do sym = h -> header.first_element repeat s -> symbol.next_member while (sym > 0);
				s = addr (rands (sym));
				call relocate_error (s);
				call assign_address_offset (s, loc, (s -> symbol.element_size),
				     (s -> symbol.units));
				end;
			     end;

			else do;
			     call relocate_error (h);
			     call assign_address_offset (h, loc, (h -> symbol.element_size), (h -> symbol.units));
			     end;
			end;

		     loc = cs -> subprogram.next_loc (i);
		     end;

		loc = loc + mod (loc, 2);
		end;
	     end;

	locn = loc;

	/* Test if variable will fit within region. */

relocate_error:
     proc (s);

dcl  s ptr;					/* pointer to node */
dcl  next_loc fixed bin (18);

	if s -> node.next ^= 0
	then next_loc = addr (rands (s -> node.next)) -> node.location;
	else next_loc = cs -> subprogram.next_loc (i) - loc;

	if loc + next_loc > limit
	then call print_message (414,
		"with relocation of " || s -> symbol.name || " in "
		|| addr (rands (cs -> subprogram.symbol)) -> symbol.name || " the " || section_name,
		ltrim (char (limit)));
     end relocate_error;
     end relocate;

get_array_size:
     procedure (pt) returns (fixed binary (18));

	/* Calculates the size of an array, and computes its virtual
	   origin if constant. */

dcl  (pt, s, d) pointer;
dcl  (cm, i, n, v) fixed binary (18);

	n = 0;
	s = pt;
	d = addr (rands (s -> symbol.dimension));

	if ^s -> symbol.variable_extents & ^s -> symbol.star_extents
	then do;
	     d -> dimension.array_size = d -> dimension.element_count * s -> symbol.element_size;
	     d -> dimension.has_array_size = "1"b;
	     n = get_size_in_words ((d -> dimension.array_size), (s -> symbol.units));

	     /* calculate virtual origin */

	     v = 0;
	     cm = s -> symbol.element_size;
	     do i = 1 to d -> dimension.number_of_dims;
		v = v + cm * d -> dimension.lower_bound (i);
		cm = cm * d -> dimension.size (i);
		end;

	     d -> dimension.virtual_origin = v;
	     d -> dimension.has_virtual_origin = "1"b;
	     end;

	else do;

	     /* Make a descriptor for the array */

	     if s -> symbol.needs_descriptors | s -> symbol.put_in_symtab | shared_globals.options.table
	     then i = make_symbol_descriptor (fixed (rel (s), 18));

	     /* Allocate symbols for dimension.size (*) */

	     if ^d -> dimension.has_dim_sizes
	     then do;
		do i = 1 to d -> dimension.number_of_dims - binary (d -> dimension.assumed_size, 1);
		     if string (d -> dimension.v_bound (i)) = "00"b
		     then d -> dimension.size (i) =
			     d -> dimension.upper_bound (i) - d -> dimension.lower_bound (i) + 1;
		     else if ^d -> dimension.v_bound (i).lower & d -> dimension.lower_bound (i) = 1
		     then d -> dimension.size (i) = d -> dimension.upper_bound (i);
		     else d -> dimension.size (i) = create_automatic_integer (cs);
		     end;
		d -> dimension.has_dim_sizes = "1"b;
		end;
	     end;

	return (n);

     end get_array_size;

     end assign_storage;

create_automatic_integer:
     procedure (cs) returns (fixed binary (18));

	/* Creates an automatic integer variable. */

dcl  cs pointer;					/* Subprogram node pointer */

dcl  s pointer;					/* Symbol pointer */
dcl  sym fixed binary (18);				/* Symbol offset */

	sym = create_node (symbol_node, size (symbol));
	s = addr (rands (sym));
	s -> symbol.data_type = int_mode;
	s -> symbol.by_compiler, s -> symbol.integer, s -> symbol.allocate, s -> symbol.automatic = "1"b;
	s -> symbol.element_size = 1;
	s -> symbol.units = word_units;

	addr (rands (cs -> subprogram.last_symbol)) -> node.next = sym;
	cs -> subprogram.last_symbol = sym;

	return (sym);

     end create_automatic_integer;

/**** CREATE_REL_CONSTANT ****/

create_rel_constant:
     procedure () returns (fixed binary (18));

	/* Creates a rel_constant */

dcl  var fixed binary (18);
dcl  p pointer;

%include relocation_bits;

	var = create_node (label_node, size (label));
	p = addr (rands (var));

	p -> label.operand_type = rel_constant;
	p -> label.reloc = rc_t;
	p -> label.referenced, p -> label.referenced_executable, p -> label.is_addressable = "1"b;

	return (var);

     end create_rel_constant;

interpreter:
     procedure ();

	/* Written by R. A. Barnes 1 January 1976 */

dcl  base fixed bin (18);				/* subscript of arg1 */
dcl  top fixed bin (18);				/* subscript of op1 */

dcl  cur_frame ptr;					/* ptr to current procedure frame */
dcl  mac_base ptr;					/* ptr to base of macro segment */

dcl  cs ptr;					/* ptr to current subprogram node */

dcl  imac fixed bin (18);				/* index into fort_cg_macros_ */
dcl  ipol fixed bin (18);				/* index into polish */

dcl  left fixed bin (18);				/* left half of macro instructiin */
dcl  mopnd fixed bin (18);				/* operand index in macro instruction */
dcl  mop fixed bin (18);

dcl  next_free_array_ref fixed bin (18);
dcl  desc_temp_chain fixed bin (18) unsigned;

dcl  op_code fixed bin (18);

dcl  (i, k, n, op1, op2, next_base, relation, scan_proc, skip, temp, zarg, desc, eaq_name, regno, sym) fixed bin (18);
dcl  (cdt, dt, dt1, dt2) fixed bin (4);
dcl  char1 character (1);

dcl  (p, s) ptr;
dcl  (b1, b2, err_flag, build_profile_after_label) bit (1) aligned;
dcl  bit3 bit (3) aligned;

dcl  from_base_man bit (1) aligned;			/* "1"b if base_man_load_pr is active */


dcl  stack (300) fixed bin (18);

dcl  (
     fort_cg_macros_$first_scan,
     fort_cg_macros_$abort_list,
     fort_cg_macros_$error_macro
     ) bit (36) aligned external static;

dcl  1 fort_cg_macros_$interpreter_macros (4) aligned ext static,
       2 entry fixed bin (17) unal,
       2 pad fixed bin (17) unal;

dcl  1 fort_cg_macros_$operator_table (109) aligned ext static,
       2 entry fixed bin (17) unal,
       2 pad fixed bin (17) unal;

dcl  1 fort_instruction_info_$fort_instruction_info_ (0:1023) aligned ext static,
       2 pad1 bit (18) unal,
       2 directable bit (1) unal,
       2 pad2 bit (17) unal;

dcl  ERROR fixed bin (18) int static options (constant) init (-1);
						/* ERROR operand */

dcl  mask_left bit (36) aligned int static options (constant) init ("000000777777"b3);

dcl  (
     first_base initial (2),
     last_base initial (6),
     escape_index initial (1),
     first_index initial (2),
     last_index initial (7),
     arg_ptr initial (26),
     descriptor_ptr initial (34)
     ) fixed binary (18) internal static options (constant);

dcl  1 fort_cg_macros_$single_inst (158) aligned ext static like machine_instruction;

%include fort_single_inst_names;

dcl  dt_from_reg (18) fixed bin (4) int static options (constant)
	init (1, 5, 4, 2, 3, 2, 2, 1, 7, 0, 5, 5, 5, 5, 5, 5, 5, 5);

dcl  eaq_name_to_reg (18) fixed bin internal static options (constant)
	initial (2, 1, 3, 3, 3, 3, 2, 1, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4);

dcl  (
     A initial (1),
     Q initial (2),
     EAQ initial (3),
     IND initial (4)
     ) fixed bin (18) internal static options (constant);

dcl  (
     in_q init (1),					/* integer value in the Q */
     in_a init (2),					/* logical value in the A */
     in_aq init (3),				/* complex value in the AQ */
     in_eaq init (4),				/* real value in the EAQ */
     in_deaq init (5),				/* dp value in the EAQ */
     in_ieaq init (6),				/* imag value in EAQ */
     in_iq init (7),				/* second word of doubleword in Q */
     in_ia init (8),				/* integer value in A */
     in_tq init (9),				/* typeless value in the Q */
     in_ind init (10),				/* wildcard for logical value in IND */
     tze init (11),					/* .eq. */
     tnz init (12),					/* .ne. */
     tmi init (13),					/* .lt. */
     tpl init (14),					/* .ge. */
     tmoz init (15),				/* .le. */
     tpnz init (16),				/* .gt. */
     tnc init (17),					/* j_l_s */
     trc init (18)					/* j_ge_s */
     ) fixed bin (18) int static options (constant);

dcl  (						/* op_base equ 361 */
     allocate_char_string initial (361 + 0),
     reallocate_char_string initial (361 + 29),
     alloc_auto_adj initial (361 + 72),
     shorten_stack initial (361 + 163),
     long_profile initial (361 + 426),
     shorten_stack_protect_ind initial (361 + 451),
     VLA_words_per_seg initial (361 - 476)		/* SPECIAL conversion */
     ) fixed binary (14) internal static options (constant);

dcl  shorten_stack_mask bit (14) aligned internal static options (constant) initial ("01000000010000"b);
						/* Reserve pr1,x1 */
dcl  zero_for_dt (0:7) fixed bin (18);

dcl  function fixed bin (18) int static init (13) options (constant);

dcl  (
     check_subscript init (1),
     subscript_mpy init (2),
     move_eis init (3),
     check_stringrange init (4)
     ) fixed bin (18) int static options (constant);

dcl  entry_info_size fixed bin (18) int static init (7) options (constant);

dcl  descriptor_mask_addr bit (36) aligned internal static options (constant) initial ("000250000100"b3);
						/* pr0|168 = 000077777777 */

dcl  (result, source) bit (72) aligned;

dcl  based_integer fixed bin (35) based;

dcl  1 inst_address aligned like symbol.address;

dcl  1 saved_cat_address aligned like node.address automatic;

dcl  char_temp char (8);

dcl  int_image fixed bin (35) based;
dcl  real_image float bin (27) based;
dcl  dp_image float bin (63) based;
dcl  cmpx_image complex float bin (27) based;
dcl  bit_image bit (72) aligned based;

dcl  ind_word bit (36) aligned based;

dcl  1 machine_state aligned,
       2 eaq (4),					/* A, Q, EAQ, IND */
         3 name fixed bin (18),
         3 number fixed bin (18),
         3 variable (4) fixed bin (18),
         3 reserved bit (1) aligned,
       2 rounded bit (1) aligned,
       2 indicators_valid fixed bin (18),
       2 value_in_xr bit (1) aligned,
       2 index_regs (0:7),
         3 bits structure unaligned,
	 4 global bit (1),				/* Not used */
	 4 reserved bit (1),
	 4 mbz bit (34),
         3 type fixed bin (18),
         3 variable fixed bin (18),
         3 used fixed bin (18),
         3 offset fixed bin (18),
       2 address_in_base bit (1) aligned,
       2 base_regs (0:7),
         3 bits structure unaligned,
	 4 global bit (1),				/* Not used */
	 4 reserved bit (1),
	 4 mbz bit (34),
         3 type fixed bin (18),
         3 variable fixed bin (18),
         3 used fixed bin (18),
         3 offset fixed bin (18),
       2 stack_extended bit (1) aligned,
       2 last_dynamic_temp fixed bin (18);

dcl  1 proc_frame based (cur_frame) aligned,
       2 node_type fixed bin (4) unal,
       2 flags structure unaligned,
         3 func bit (1),
         3 scan_interpreter_frame,
	 4 interpreter_called bit (1) unal,
	 4 scan_called bit (1) unal,
         3 pad bit (28) unal,
       2 prev ptr unal,
       2 next ptr unal,
       2 return fixed bin (18),
       2 base fixed bin (18),
       2 error_label fixed bin (18),
       2 interpreter_return label local,
       2 nshort fixed bin (18),
       2 short (3) fixed bin (18);

dcl  1 hast based (addr (macro_instruction (imac))),
       2 instruction_word bit (36) aligned,
       2 half_array (18) fixed bin (17) unaligned;

dcl  1 macro_instruction (0:262143) based (mac_base) aligned,
       2 left fixed bin (17) unal,			/* left half - label or integer */
       2 operand fixed bin (3) unal,
       2 eaq_name fixed bin (5) unal,
       2 inhibit bit (1) unal,
       2 op_code bit (7) unal;

dcl  1 machine_instruction (0:262143) based (mac_base) aligned,
       2 operand fixed bin (3) unal,
       2 increment fixed bin (13) unal,
       2 op_code bit (10) unal,
       2 inhibit bit (1) unal,
       2 ext_base_and_tag unal,
         3 ext_base bit (1) unal,
         3 tag bit (6) unal;

dcl  1 macro_dt_inst (0:262143) based (mac_base) aligned,
       2 number fixed bin (17) unal,
       2 data_type fixed bin (9) unal,
       2 inhibit bit (1) unal,
       2 op_code bit (7) unal;

dcl  1 macro_bits_inst (0:262143) based (mac_base) aligned,
       2 left fixed bin (17) unal,
       2 bits bit (10) unal,
       2 inhibit bit (1) unal,
       2 op_code bit (7) unal;

dcl  1 macro_if_inst (0:262143) based (mac_base) aligned,
       2 left fixed bin (17) unal,
       2 operand fixed bin (3) unal,
       2 relation bit (3) unal,
       2 with fixed bin (2) unal,
       2 inhibit bit (1) unal,
       2 op_code bit (7) unal;

dcl  1 macro_regs_inst (0:262143) based (mac_base) aligned,
       2 regs bit (18) unal,
       2 pad bit (10) unal,
       2 inhibit bit (1) unal,
       2 op_code bit (7) unal;

dcl  1 macro_cond_inst (0:262143) based (mac_base) aligned,
       2 left bit (18) unal,
       2 operand bit (4) unal,
       2 pad bit (5) unal,
       2 if_test bit (1) unal,
       2 inhibit bit (1) unal,
       2 op_code bit (7) unal;

dcl  1 instruction (0:262143) aligned based (object_base),
       2 base bit (3) unal,
       2 offset fixed bin (14) unal,
       2 op bit (10) unal,
       2 inhibit bit (1) unal,
       2 ext_base_and_tag unal,
         3 ext_base bit (1) unal,
         3 tag bit (6) unal;

dcl  text_word (0:262143) bit (36) aligned based (object_base);

dcl  1 reloc (0:262143) aligned based (relocation_base),
       2 skip1 bit (12) unal,
       2 left_rel bit (6) unal,
       2 skip2 bit (12) unal,
       2 right_rel bit (6) unal;

dcl  1 half based aligned,
       2 left fixed bin (17) unal,
       2 right fixed bin (17) unal;

dcl  1 arg_list auto aligned,
       2 header aligned,
         3 arg_count fixed bin (17) unal,
         3 code bit (18) unal,
         3 desc_count fixed bin (17) unal,
         3 pad bit (18) unal,
       2 itp_list (254) like itp aligned;		/* Big enough for 127 args
						   and descriptors */

dcl  1 entry_descriptor aligned,
       2 type_bits bit (12) unaligned,
       2 char_size bit (24) unaligned;

dcl  (length, mod) builtin;

%include relocation_bits;

	/* initialize cur_subprogram and friend */

	cur_subprogram = first_subprogram;
	cs = addr (rands (cur_subprogram));
	call get_subr_options (cs);

	/* initialize constant builtins */

	builtins (0) = create_integer_constant (0);
	builtins (1) = create_integer_constant (1);
	builtins (5) = create_constant (dp_mode, unspec (null));
	builtins (6) = 0;
	builtins (7) = create_integer_constant (2);

	/* initialize array of zero constants */

	zero_for_dt (0) = ERROR;			/* for invalid register states */
	zero_for_dt (1) = builtins (0);		/* integer */
	addr (result) -> real_image = 0.0;
	zero_for_dt (2) = create_constant (real_mode, result);
						/* real */
	addr (result) -> dp_image = 0.0;
	zero_for_dt (3) = create_constant (dp_mode, result);
						/* double precision */
	addr (result) -> cmpx_image = 0.0;
	zero_for_dt (4) = create_constant (cmpx_mode, result);
						/* complex */
	result = "0"b;
	zero_for_dt (5) = create_constant (logical_mode, result);
						/* logical */
	zero_for_dt (6) = ERROR;			/* character */
	zero_for_dt (7) = builtins (0);		/* typeless */

	/* initialize automatic vars for this program */

	call initialize_auto;

	/* initialize builtins for auto template and overlay */

	char_constant_length = 0;			/* do not allocate the value field */
	builtins (3) = create_node (char_constant_node, size (char_constant));
	p = addr (rands (builtins (3)));
	p -> char_constant.operand_type = constant_type;
	p -> char_constant.data_type = char_mode;
	p -> char_constant.is_addressable, p -> char_constant.allocated = "1"b;
	p -> char_constant.location = auto_template;
	p -> char_constant.reloc = rc_t;
	p -> char_constant.length =
	     chars_per_word * (addr (rands (last_subprogram)) -> subprogram.next_loc (2) - first_auto_var_loc);
	p -> char_constant.no_value_stored = "1"b;	/* value is already in the text */

	builtins (4) = create_node (array_ref_node, size (array_ref));
	p = addr (rands (builtins (4)));
	p -> array_ref.operand_type = array_ref_type;
	p -> array_ref.data_type = char_mode;
	p -> array_ref.is_addressable, p -> array_ref.allocated, p -> array_ref.ext_base = "1"b;
	p -> array_ref.base = sp;
	p -> array_ref.address.offset = first_auto_var_loc;
	if init_auto_to_zero
	then p -> array_ref.length = chars_per_word * (last_auto_loc - first_auto_var_loc);
	else p -> array_ref.length = addr (rands (builtins (3))) -> char_constant.length;
	p -> array_ref.ref_count = 131071;		/* prevent deletion */

	builtins (8) = create_node (symbol_node, size (symbol));
	p = addr (rands (builtins (8)));
	p -> symbol.operand_type = dummy;
	p -> symbol.by_compiler = "1"b;
	p -> symbol.allocated, p -> symbol.is_addressable, p -> symbol.ext_base = "1"b;
	p -> symbol.base = sp;

	builtins (11) = create_node (symbol_node, size (symbol));
	p = addr (rands (builtins (11)));
	p -> symbol.operand_type = variable_type;
	p -> symbol.data_type = int_mode;
	p -> symbol.by_compiler = "1"b;
	p -> symbol.needs_pointer = "1"b;
	p -> symbol.descriptor = "1"b;
	p -> symbol.address.ext_base = "1"b;

	/* perform other initializations */

	next_free_array_ref = 0;
	desc_temp_chain = 0;
	build_profile_after_label, unspec (machine_state) = "0"b;
	from_base_man = "0"b;

	/* initialize scanners */

	mac_base = ptr (addr (fort_cg_macros_$first_scan), 0);
	imac = fixed (rel (addr (fort_cg_macros_$first_scan)), 18) - 1;

	/* get first procedure frame and initialize operand stack */

	cur_frame = null;

	cur_frame = create_proc_frame ();

	base, top = 0;

	/* Set things up for the first program unit */

	call start_subprogram ();

	/* MAIN LOOP! */

	do while ("1"b);

	     imac = imac + 1;

	     /* look at next instruction */

loop:
	     if ^macro_instruction (imac).inhibit
	     then do;

		/* have machine instruction */

		call emit_inst;
		go to step;
		end;

	     /* have macro instruction */

	     mopnd = macro_instruction (imac).operand;
	     left = macro_instruction (imac).left;
	     mop = fixed (macro_instruction (imac).op_code, 7);

	     go to action (mop);

action (1):					/* copy */
	     op1 = stack (get_operand (mopnd));
	     call copy (op1);
	     go to step;

action (2):					/* swap */
	     op1 = get_operand (mopnd);

	     k = stack (top);
	     stack (top) = stack (op1);
	     stack (op1) = k;

	     go to step;

action (3):					/* pop */
	     op1 = get_operand (mopnd);
	     call pop (op1);
	     go to step;

action (4):					/* push_temp */
	     dt = macro_dt_inst (imac).data_type;

	     if dt ^= 0
	     then call push (assign_temp (dt));

	     else do;

		/* have block of words */

		if left < 0
		then do;

		     /* have count */

		     left = stack (top) + bias;
		     top = top - 1;
		     end;
		call push (assign_block (left));
		end;

	     go to step;

action (5):					/* push_variable  */
	     call push_variable ((macro_dt_inst (imac).data_type));
	     go to step;

action (6):					/* dispatch for simple macro instructions */
	     go to simple (left);

simple (1):					/* push_label */
simple (2):					/* push_rel_constant */
	     call push (create_rel_constant ());
	     go to step;

action (8):					/* push_constant */
	     dt = macro_dt_inst (imac).data_type;

	     if dt ^= 0
	     then do;
		call push (create_constant (dt, addr (machine_instruction (imac + 1)) -> bit_image));
		imac = imac + data_type_size (dt);
		end;

	     else do;
		if left < 0
		then do;
		     left = stack (top) + bias;
		     top = top - 1;
		     end;
		call print_message (427, "push_constant_block");
		end;

	     go to step;

action (9):					/* convert_constant */
	     source = addr (rands (stack (top))) -> constant.value;
	     cdt = addr (rands (stack (top))) -> constant.data_type;
	     dt = macro_dt_inst (imac).data_type;
	     result = conv_round (dt, cdt) ((source), 0);

	     stack (top) = create_constant (dt, result);
	     go to step;

action (54):					/* push_count */
	     call push (left - bias);
	     go to step;

action (10):					/* push_count_indexed */
	     op1 = get_operand (mopnd);
	     i = stack (op1) + bias;

	     if i <= 0 | i > left
	     then call print_message (402, "push_count_indexed");

	     call push (half_array (i) - bias);

	     imac = imac + divide (left + 1, 2, 17, 0);
	     go to step;

action (11):					/* push_builtin */
	     call push ((builtins (left)));
	     go to step;

action (14):					/* call */
action (70):
	     if mop = 14
	     then call setup_call (left, imac, 0, 0);
	     else do;
		imac = imac + 1;
		call setup_call (left, imac, (macro_instruction (imac).left), 0);
		end;

	     imac = left;
	     go to step;

action (15):					/* return */
	     if left = 0
	     then do;

		/* should be a proc invocation */

		if proc_frame.func
		then call print_message (403);

		call pop (base);
		end;

	     else do;

		/* should be a func invocation */

		if ^proc_frame.func
		then call print_message (404);

		i = macro_instruction (imac).eaq_name;
		if i = 0
		then do;

		     /* return operand name */

		     op1 = get_operand (mopnd);

		     k = stack (op1);
		     stack (op1) = stack (base);
		     if k < 0
		     then stack (base) = create_integer_constant (k + bias);
		     else stack (base) = k;

		     call pop (base + 1);
		     end;

		else do;

		     /* return eaq_name */

		     call pop (base);

		     dt = dt_from_reg (i);
		     temp = assign_temp (dt);
		     call push (temp);

		     call in_reg (temp, i);
		     end;
		end;

	     p = cur_frame;

	     call pop_frame;

	     /* now, actually return */

	     imac = p -> proc_frame.return;

	     if p -> proc_frame.interpreter_called
	     then do;
		err_flag = "0"b;
		go to p -> proc_frame.interpreter_return;
		end;

	     go to step;

action (16):					/* jump */
	     imac = left;
	     go to loop;

action (17):					/* scan */
rescan:
	     do while (polish (ipol) < 0 | polish (ipol) > last_assigned_op);

		/* have a count or operand */

		call push (effective_operand (polish (ipol)));
		ipol = ipol + 1;
		end;

	     /* we have an operator */

	     op_code = polish (ipol);
	     ipol = ipol + 1;

	     scan_proc = fort_cg_macros_$operator_table (op_code).entry;

	     next_base = get_nextbase (scan_proc);

	     do i = next_base repeat i + 1 while (i <= top & stack (i) ^= ERROR);
		end;

	     if i <= top
	     then do;
		call pop (next_base);

		if fixed (macro_instruction (scan_proc).op_code, 7) = function
		then call push (ERROR);

		i = macro_instruction (scan_proc).left;
		if i = 0
		then go to rescan;

		call setup_call (i, imac - 1, left, 0);
		imac = i;
		end;

	     else do;
		call setup_call (scan_proc, imac - 1, left, next_base);
		imac = scan_proc;
		end;

	     proc_frame.scan_called = "1"b;
	     go to step;

action (18):					/* exit */
	     if proc_frame.func
	     then call print_message (405);
	     else if ^proc_frame.scan_called
	     then call print_message (406);

	     call pop (base);

	     imac = proc_frame.return + left;

	     call pop_frame;
	     go to step;

action (19):					/* s_call */
	     proc_frame.nshort = proc_frame.nshort + 1;
	     if proc_frame.nshort > hbound (proc_frame.short, 1)
	     then call print_message (407, "s_call stack", hbound (proc_frame.short, 1) - bias);
	     else proc_frame.short (proc_frame.nshort) = imac;
	     imac = left;
	     go to loop;

simple (3):					/* s_return */
	     if proc_frame.nshort < 0
	     then call print_message (408);
	     else do;
		imac = proc_frame.short (proc_frame.nshort);
		proc_frame.nshort = proc_frame.nshort - 1;
		end;

	     go to step;

action (21):					/* if_dt */
	     b2 = "1"b;
	     go to dt_join;

action (22):					/* unless_dt */
	     b2 = "0"b;

dt_join:
	     i = addr (rands (stack (top))) -> symbol.data_type;

	     if i <= 0 | i > length (macro_bits_inst (imac).bits)
	     then call print_message (445, stack (top), "data_type");
	     else b1 = substr (macro_bits_inst (imac).bits, i, 1);

	     go to if_join;

action (23):					/* if_optype */
	     b2 = "1"b;
	     go to optype_join;

action (24):					/* unless_optype */
	     b2 = "0"b;

optype_join:
	     if stack (top) > 0			/* item can be operand or count */
	     then do;
		i = addr (rands (stack (top))) -> symbol.operand_type;
						/* an operand */

		if i <= 0 | i > length (macro_bits_inst (imac).bits)
		then do;
		     call print_message (445, stack (top), "operand_type");
		     stop;
		     end;
		end;

	     else i = count_type;			/* a count */

	     b1 = substr (macro_bits_inst (imac).bits, i, 1);

	     go to if_join;

action (25):					/* (if unless)_array */
	     b2 = macro_cond_inst (imac).if_test;
	     p = addr (rands (stack (top)));
	     if p -> node.node_type = symbol_node
	     then b1 = p -> symbol.dimensioned;
	     else b1 = "0"b;
	     go to if_join;

action (26):					/* (if unless)_aligned */
	     b2 = macro_cond_inst (imac).if_test;
	     p = addr (rands (stack (get_operand (mopnd))));

	     if p -> node.units = char_units
	     then do;
		if p -> node.node_type = symbol_node
		then if p -> symbol.parameter
		     then b1 = "0"b;
		     else b1 = (p -> symbol.address.char_num = 0);

		else if p -> node.node_type = array_ref_node
		then if addr (rands (p -> array_ref.parent)) -> symbol.parameter
		     then b1 = "0"b;
		     else b1 = (p -> array_ref.address.char_num = 0 & ^cs -> subprogram.options.ansi_77);

		else b1 = (p -> node.address.char_num = 0);
		end;
	     else b1 = "1"b;

	     go to if_join;

action (27):					/* if_eaq */
	     b2 = "1"b;
	     go to eaq_join;

action (28):					/* unless_eaq */
	     b2 = "0"b;

eaq_join:
	     op1 = stack (get_operand (mopnd));

	     if addr (rands (op1)) -> node.value_in.eaq
	     then do;
		eaq_name = get_eaq_name (op1);
		if macro_instruction (imac).eaq_name = in_ind
		then b1 = (eaq_name > in_ind);
		else b1 = (eaq_name = macro_instruction (imac).eaq_name);
		end;
	     else b1 = "0"b;			/* op1 not in any eaq register */
	     go to if_join;

action (29):					/* dt_jump */
	     dt1 = addr (rands (stack (top))) -> symbol.data_type;
	     dt2 = addr (rands (stack (top - 1))) -> symbol.data_type;

	     if dt1 <= 0
	     then call print_message (445, stack (top), "data_type");

	     else if dt2 <= 0
	     then call print_message (445, stack (top - 1), "data_type");

	     else if dt1 = typeless_mode
	     then i = 19;

	     else if dt1 > cmpx_mode
	     then i = 17;

	     else if dt2 = typeless_mode
	     then i = 20;

	     else if dt2 > cmpx_mode
	     then i = 18;

	     else i = 4 * (dt1 - 1) + dt2;

	     imac = half_array (i);
	     go to loop;

action (124):					/* dt_jump1 */
	     dt = addr (rands (stack (get_operand (mopnd)))) -> symbol.data_type;

	     if dt <= 0 | dt > last_assigned_mode
	     then do;
		call print_message (445, stack (get_operand (mopnd)), "data_type");
		stop;
		end;

	     imac = half_array (dt);
	     goto loop;

action (30):					/* ind_jump */
	     if machine_state.eaq (IND).name < tze
	     then call print_message (409);
	     else imac = half_array (machine_state.eaq (IND).name - tze + 1);

	     go to loop;

action (72):					/* if_ind */
	     b2 = "1"b;
	     go to ind_join;

action (73):					/* unless_ind */
	     b2 = "0"b;

ind_join:
	     if machine_state.eaq (IND).name >= in_ind & machine_state.eaq (IND).number > 0
	     then call print_message (410);

	     eaq_name = macro_instruction (imac).eaq_name;
	     regno = eaq_name_to_reg (eaq_name);
	     b1 = (machine_state.indicators_valid = regno);
	     go to if_join;

action (81):					/* (if unless)_parameter */
	     b2 = macro_cond_inst (imac).if_test;
	     op1 = get_operand (mopnd);
	     b1 = addr (rands (stack (op1))) -> symbol.parameter;
	     go to if_join;

action (85):					/* (if unless)_negative */
	     b2 = macro_cond_inst (imac).if_test;
	     op1 = get_operand (mopnd);
	     b1 = check_negative (stack (op1));
	     go to if_join;

action (87):					/* (if unless)_local */
	     b2 = macro_cond_inst (imac).if_test;
	     op1 = stack (get_operand (mopnd));
	     b1 = addr (rands (op1)) -> symbol.external & addr (rands (op1)) -> symbol.initial > 0;
	     go to if_join;

action (89):					/* (if unless)_main */
	     b2 = macro_cond_inst (imac).if_test;
	     b1 = cs -> subprogram.subprogram_type = main_program;
	     go to if_join;

action (95):					/* (if unless)_needs_descriptors */
	     b2 = macro_cond_inst (imac).if_test;
	     op1 = stack (get_operand (mopnd));
	     b1 = addr (rands (op1)) -> symbol.needs_descriptors;
	     go to if_join;

action (99):					/* (if unless)_namelist_used */
	     b2 = macro_cond_inst (imac).if_test;
	     b1 = cs -> subprogram.namelist_used;
	     go to if_join;

action (31):					/* if */
	     b2 = "1"b;
	     go to unless_join;

action (32):					/* unless */
	     b2 = "0"b;

unless_join:
	     op1 = get_operand (mopnd);
	     op1 = stack (op1) + bias;

	     op2 = macro_if_inst (imac).with;
	     if op2 = 3
	     then op2 = stack (top) + bias;

	     relation = fixed (macro_if_inst (imac).relation, 3);
	     go to comp (relation);

comp (0):
	     b1 = op1 < op2;
	     go to if_join;

comp (1):
	     b1 = op1 > op2;
	     go to if_join;

comp (2):
	     b1 = op1 = op2;
	     go to if_join;

comp (3):
	     b1 = op1 ^= op2;
	     go to if_join;

comp (4):
	     b1 = op1 <= op2;
	     go to if_join;

comp (5):
	     b1 = op1 >= op2;

if_join:
	     if b1 = b2
	     then do;
		imac = left;
		go to loop;
		end;

	     go to step;

action (33):					/* jump_indexed */
	     op1 = get_operand (mopnd);
	     i = stack (op1) + bias;

	     if i <= 0 | i > left
	     then call print_message (402, "jump_indexed");
	     else imac = half_array (i);

	     go to loop;

action (34):					/* emit */
	     do imac = imac + 1 to imac + left;
		text_word (text_pos) = unspec (machine_instruction (imac));
		text_pos = text_pos + 1;
		end;
	     go to loop;

action (78):					/* assign_entry */
	     op1 = get_operand (mopnd);
	     call reset_regs;
	     goto label_join;

action (35):					/* label */
	     op1 = get_operand (mopnd);

	     if addr (rands (stack (op1))) -> label.referenced_executable
						/* reset only if label is used */
	     then call reset_regs;
	     goto label_join;

action (36):					/* relcon */
	     op1 = get_operand (mopnd);

label_join:
	     call alloc_label (op1, text_pos);

	     if addr (rands (stack (op1))) -> label.restore_prs
						/* is this label the target of a non-local goto */
	     then call emit_zero (getlp);		/* yes, restore frozen register (pr4) */

	     if build_profile_after_label
	     then do;
		call build_profile_entry;
		build_profile_after_label = "0"b;
		end;
	     go to step;

action (37):					/* set_rel_constant */
	     op1 = get_operand (mopnd);
	     call alloc_label (op1, stack (top) + bias);
	     top = top - 1;
	     go to step;

action (38):					/* add_to_address */
	     if left = 0
	     then do;
		instruction (text_pos - 1).offset = instruction (text_pos - 1).offset + stack (top) + bias;
		top = top - 1;
		end;

	     else do;
		op1 = get_operand (mopnd);
		p = addr (rands (stack (op1)));

		if p -> label.operand_type ^= rel_constant
		then call print_message (411, stack (op1));

		i = p -> label.location + stack (top - 1) + bias;
		instruction (i).offset = instruction (i).offset + stack (top) + bias;

		top = top - 2;
		end;

	     go to step;

action (39):					/* insert_bits */
	     call print_message (424, "insert_bits");
	     go to step;

action (40):					/* reserve_regs */
	     call reserve_regs ((macro_regs_inst (imac).regs));
	     go to step;

action (41):					/* load_pr */
	     op1 = stack (get_operand (mopnd));

	     if assembly_list & addr (rands (op1)) -> node.node_type = symbol_node
	     then a_name (text_pos) = op1;

	     call base_man_load_pr (op1, left);
	     go to step;

action (112):					/* load_pr_value */
	     op1 = stack (get_operand (mopnd));

	     if assembly_list & addr (rands (op1)) -> node.node_type = symbol_node
	     then a_name (text_pos) = op1;

	     call base_man_load_pr_value (op1, left);
	     go to step;

simple (49):					/* desc_ptr_in_pr3 */
	     machine_state.base_regs (which_base (3)).type = 9;
	     machine_state.base_regs (which_base (3)).used = text_pos;
	     machine_state.base_regs (which_base (3)).variable = 0;
	     machine_state.base_regs (which_base (3)).offset = 0;
	     go to step;

simple (50):					/* arg_ptr_in_pr1 */
	     machine_state.base_regs (which_base (1)).type = 5;
	     machine_state.base_regs (which_base (1)).used = text_pos;
	     machine_state.base_regs (which_base (1)).variable = 0;
	     machine_state.base_regs (which_base (1)).offset = 0;
	     go to step;

simple (4):					/* free_regs */
	     call free_regs;
	     go to step;

simple (5):					/* reset_regs */
	     call reset_regs;
	     go to step;

action (44):					/* make_addressable */
action (71):
	     op1 = get_operand (mopnd);
	     call m_a (addr (rands (stack (op1))));

	     if mop = 71
	     then do;
		op2 = get_operand ((machine_instruction (imac).operand));
		call m_a (addr (rands (stack (op2))));
		end;

	     go to step;

action (45):					/* use_eaq */
	     call use_eaq (0);
	     go to step;

action (46):					/* load */
	     op1 = stack (get_operand (mopnd));

	     if op1 < 0				/* a count */
	     then op1 = create_integer_constant (op1 + bias);

	     call load (op1, (macro_instruction (imac).eaq_name));
	     go to step;

simple (22):					/* safe_load */
	     call print_message (424, "safe_load");
	     go to step;

action (47):					/* load_top */
	     eaq_name = macro_instruction (imac).eaq_name;/* Copy in case imac is changed */
	     temp = 0;				/* swap flag */

	     /* If loading into the A, get temps in IND out first */

	     if eaq_name = in_a
	     then if machine_state.eaq (IND).number > 0
		then if addr (rands (stack (top))) -> node.value_in.eaq
		     then if addr (rands (stack (top - 1))) -> node.value_in.eaq
			then call use_ind ();

	     /* If both operands are in the eaq, check the eaq names
	        and swap if the top operand is the wrong name but the
	        lower one is the right name. */

	     if addr (rands (stack (top))) -> node.value_in.eaq
	     then if addr (rands (stack (top - 1))) -> node.value_in.eaq
		then if get_eaq_name (stack (top)) ^= eaq_name
		     then if get_eaq_name (stack (top - 1)) = eaq_name
			then temp = 1;

	     /* If the top operand is not in the eaq, and the lower one is
	        or if the top operand is a constant, swap the operands. */

	     if ^addr (rands (stack (top))) -> node.value_in.eaq
	     then if addr (rands (stack (top - 1))) -> node.value_in.eaq
		     | addr (rands (stack (top))) -> node.node_type = constant_node
		     | addr (rands (stack (top))) -> node.node_type = char_constant_node
		then temp = 1;

	     if temp > 0
	     then do;
		k = stack (top - 1);
		stack (top - 1) = stack (top);
		stack (top) = k;

		/* If operands are swapped and a label is given, transfer to that label. */

		if left > 0
		then imac = left - 1;
		end;

	     call load ((stack (top)), eaq_name);

	     go to step;

action (113):					/* load_for_test */
	     op1 = stack (get_operand (mopnd));
	     op2 = macro_instruction (imac).eaq_name;
	     regno = eaq_name_to_reg (op2);

	     call load (op1, op2);

	     /* if indicators are invalid, set them with a compare */

	     if machine_state.indicators_valid ^= regno
	     then do;
		call emit_single ((compare_inst (op2)), (zero_for_dt (dt_from_reg (op2))));
		machine_state.indicators_valid = regno;
		end;

	     goto step;

action (111):					/* store */
	     op1 = stack (get_operand (mopnd));
	     call store (op1, (macro_instruction (imac).eaq_name), left);
	     go to step;

action (48):					/* in_reg */
	     op1 = stack (get_operand (mopnd));
	     call in_reg (op1, (macro_instruction (imac).eaq_name));
	     go to step;

action (105):					/* compare */
	     op1 = stack (get_operand (mopnd));
	     if op1 < 0				/* a count */
	     then op1 = create_integer_constant (op1 + bias);
	     b1 = (op1 = zero_for_dt (addr (rands (op1)) -> node.data_type));
	     eaq_name = macro_instruction (imac).eaq_name;
	     regno = eaq_name_to_reg (eaq_name);

	     if machine_state.indicators_valid ^= regno | ^b1
	     then do;

		if do_rounding & ^machine_state.rounded
		then if (eaq_name = in_eaq) | (eaq_name = in_deaq)
		     then if (eaq_name = machine_state.eaq (regno).name) | (eaq_name ^= in_deaq)
			     | (machine_state.eaq (regno).name = 0)
			then do;
			     if machine_state.eaq (regno).name ^= 0
			     then i = round_inst (machine_state.eaq (regno).name);
			     else i = round_inst (eaq_name);
			     call emit_zero (i);
			     machine_state.rounded = "1"b;
			     end;

		call emit_single ((compare_inst (eaq_name)), op1);

		if b1
		then machine_state.indicators_valid = regno;
		else machine_state.indicators_valid = 0;

		end;

	     go to step;

simple (6):					/* reset_eaq */
	     call reset_eaq (EAQ);
	     call reset_eaq (IND);
	     go to step;

simple (7):					/* use_ind */
	     call use_ind;
	     go to step;

action (20):					/* set_inds_valid */
	     eaq_name = macro_instruction (imac).eaq_name;
	     machine_state.indicators_valid = eaq_name_to_reg (eaq_name);
	     go to step;

action (51):					/* increment */
	     op1 = get_operand (mopnd);
	     stack (op1) = stack (op1) + left;
	     go to step;

action (52):					/* decrement */
	     op1 = get_operand (mopnd);
	     stack (op1) = stack (op1) - left;
	     go to step;

action (53):					/* multiply */
	     op1 = get_operand (mopnd);

	     k = (stack (op1) + bias) * left;		/* form product */
	     if k >= bias
	     then call print_message (433, stack (op1), left - bias);
						/* product is too large to be count */
	     else stack (op1) = k - bias;		/* product ok */
	     go to step;

simple (28):					/* skip_data */
	     ipol = ipol + polish (ipol) + 1;
	     go to step;

action (50):					/* push_sf_arg_count */
action (55):					/* push_bif_index */
	     op1 = get_operand (mopnd);
	     i = addr (rands (stack (op1))) -> symbol.char_size - bias;
	     call push (i);
	     go to step;

simple (8):					/* start_subscript */
	     call start_subscript;
	     go to step;

simple (9):					/* next_subscript */
	     call next_subscript;
	     go to step;

simple (10):					/* finish_subscript */
	     call finish_subscript;
	     go to step;

simple (11):					/* subscript_error */
	     call signal_error;
	     go to step;

simple (21):					/* optimized_subscript */
	     call print_message (424, "optimized_subscript");
	     goto step;

simple (39):					/* make_substring */
	     call make_substring ();
	     go to step;

simple (12):					/* s_func_finish */
	     free_temps (1), free_temps (2), free_temps (3) = 0;
	     go to step;

action (61):					/* s_func_label */
	     op1 = get_operand (mopnd);
	     addr (rands (stack (op1))) -> symbol.initial = stack (top);
	     go to step;

action (62):					/* push_s_func_label */
	     op1 = get_operand (mopnd);
	     call push ((addr (rands (stack (op1))) -> symbol.initial));
	     go to step;

action (63):					/* push_s_func_var */
	     op1 = stack (get_operand (mopnd));

	     do i = 1 to stack (top) + bias;
		p = addr (rands (op1));
		if p -> symbol.next_member = 0
		then do;
		     imac = left;
		     go to loop;
		     end;

		op1 = p -> symbol.next_member;
		end;

	     call push (op1);

	     go to step;

action (64):					/* push_array_size */
	     op1 = get_operand (mopnd);
	     p = addr (rands (stack (op1)));
	     p = addr (rands (p -> symbol.dimension));

	     if p -> dimension.variable_array_size
	     then op1 = p -> dimension.array_size;
	     else op1 = create_integer_constant ((p -> dimension.array_size));

	     call push (op1);
	     go to step;

action (65):					/* print */
	     call setup_message_structure;
	     call print_message_op;
	     go to step;

	     /* NOTE - This code was modified on 26 May 1977 by DSL to conflict with the documented
	        actions for this macro.

	        In the case of the frame called by scan being a "FUNC" frame, the error
	        macro now pushes an ERROR operand whether or not the error_label for
	        the scan was "continue".
	     */
action (66):					/* error */
	     if left ^= 0
	     then do;
		call setup_message_structure;
		call print_message_op;
		end;

	     do while (proc_frame.error_label = 0);
		cur_frame = proc_frame.prev;
		end;

	     call pop (proc_frame.base);

	     p = cur_frame;

	     call pop_frame;

	     if p -> proc_frame.scan_called
	     then if p -> proc_frame.func
		then call push (ERROR);

	     if ^p -> proc_frame.interpreter_called
	     then do;
		imac = p -> proc_frame.error_label;
		go to loop;
		end;

	     else do;
		err_flag = "1"b;
		imac = p -> proc_frame.return;
		go to p -> proc_frame.interpreter_return;
		end;

action (68):					/* push_length */
	     op1 = get_char_size (addr (rands (stack (get_operand (mopnd)))));
	     if op1 > 0				/* Not a count */
	     then do;
		p = addr (rands (op1));
		if p -> node.node_type = temporary_node
		then p -> temporary.ref_count = p -> temporary.ref_count + 1;
		end;

	     call push (op1);
	     go to step;

action (7):					/* emit_eis */
	     call emit_eis;
	     go to step;

simple (13):					/* end_unit */
	     if top ^= 0 | base > 1
	     then call print_message (425);

	     cur_subprogram = cs -> subprogram.next_subprogram;
	     if cur_subprogram = 0
	     then return;

	     call start_subprogram ();

	     go to step;

action (76):					/* make_io_desc */
	     result = macro_regs_inst (imac).regs | bit (fixed (stack (top) + bias, 36), 36);
	     stack (top) = create_constant (int_mode, result);
	     go to step;

action (77):					/* (if unless)_one_word_dt */
	     b2 = macro_cond_inst (imac).if_test;
	     b1 = one_word_dt (stack (get_operand (mopnd)));
	     goto if_join;

simple (14):					/* stat */
	     cur_statement = ipol - 1;
	     addr (polish (cur_statement)) -> statement.location = bit (text_pos, 18);
	     ipol = ipol + (size (statement) - 1);

	     if generate_profile
	     then if addr (polish (cur_statement)) -> statement.put_in_profile
		then if polish (ipol + 1) = label_op
		     then build_profile_after_label = "1"b;
		     else call build_profile_entry;
	     go to step;

simple (15):					/* check_parameters */
	     /*** Expects:

		count of parameters
		param1
		param2
		.
		.
		.
		paramn ***/
	     zarg = base;
	     n = stack (zarg) + bias;

	     /* Perform entry descriptor processing to fill in arguments. */
	     /* We will put the node offset to the descriptor into the text section.
	        gen_entry_defs will later fill in the true text offset from the allocated
	        nodes. */
	     /* NOTE. We depend upon parm_desc_ptrsp being left set to the descriptor
	        block.  This is a relatively safe assumption however. */

	     do i = 1 to n;
		parm_desc_ptrs.descriptor_relp (i) = make_entry_descriptor ((stack (zarg + i)));

		k = fixed (rel (addr (parm_desc_ptrs.descriptor_relp (i))));
		if mod (i, 2) = 0
		then reloc (k).left_rel = rc_t;
		else reloc (k).right_rel = rc_t;
		end;

	     /* Next store pointers to multi-position parameters, and VLA
	        parameters. */

	     do i = 1 to n;
		p = addr (rands (stack (zarg + i)));

		if assembly_list & p -> node.node_type = symbol_node
		then a_name (text_pos) = stack (zarg + i);

		if p -> node.node_type = symbol_node
		then if p -> symbol.VLA
		     then do;

			/* Store pointers to Very Large Array parameters in the
			   VLA pointer blocks.  */

			bit3 = base_man_load_any_pr (2, 2 * i, 0);
			sym = addr (rands (p -> symbol.dimension)) -> dimension.VLA_base_addressor;
			s = addr (rands (sym));
			if VLA_is_256K
			then call emit_c_a_var ((store_packed_base (which_base (fixed (bit3, 3)))), s);
			else do;			/* 255K addressing */
			     if assembly_list
			     then a_name (text_pos) = fixed (rel (p));
			     unspec (inst_address) = "0"b;
			     inst_address.base = bit3;
			     inst_address.ext_base = "1"b;
			     call emit_c_a ((epaq), unspec (inst_address));
			     call emit_single ((qrl), 18 - bias);
			     call emit_c_a_var ((stq), s);
			     call emit_single ((lrl), 54 - bias);
			     inst_address.base = "000"b;
			     inst_address.offset = VLA_words_per_seg;
			     call emit_c_a ((mpy), unspec (inst_address));
			     call emit_c_a_var ((asq), s);
			     if assembly_list
			     then a_name (text_pos) = fixed (rel (p));
			     call emit_c_a ((store_packed_base (which_base (fixed (bit3, 3)))),
				c_a ((p -> symbol.address.offset), 6));
			     end;
			end;

		     else if p -> symbol.stack_indirect
		     then do;
			bit3 = base_man_load_any_pr (2, 2 * i, 0);
			if assembly_list & p -> node.node_type = symbol_node
			then a_name (text_pos) = stack (zarg + i);
			call emit_c_a ((store_base (which_base (fixed (bit3, 3)))), c_a ((p -> symbol.location), 6))
			     ;
			end;
		end;

	     /* Next store length of star extent character strings */

	     do i = 1 to n;
		p = addr (rands (stack (zarg + i)));
		if p -> node.node_type = symbol_node
		then if p -> symbol.v_length ^= 0
		     then do;
			if assembly_list & p -> node.node_type = symbol_node
			then a_name (text_pos) = stack (zarg + i);
			call get_param_char_size (p, i);
			end;
		end;

	     /* Finally compute bounds, etc. of variable extent arrays */

	     do i = 1 to n;
		p = addr (rands (stack (zarg + i)));
		if p -> node.node_type = symbol_node
		then if p -> symbol.dimensioned
		     then if p -> symbol.variable_extents | p -> symbol.star_extents
			then if p -> symbol.allocate
			     then do;
				if assembly_list & p -> node.node_type = symbol_node
				then a_name (text_pos) = stack (zarg + i);
				call get_param_array_size (p);
				end;
		end;

	     /* Last but not least emit code for star extent function allocation. */

	     if cs -> subprogram.star_extent_function
	     then do;
		p = addr (rands (cs -> subprogram.first_symbol));

		/* THIS DEPENDS UPON return_value BEING THE FIRST DEFINED SYMBOL IN THE FUNCTION. */

		call emit_single ((load_inst (in_q)), (p -> symbol.v_length));
		call emit_single ((adfx1), 3 - bias);	/* adq 3 */
		call emit_single ((qrs), 2 - bias);	/* qrs 2 */
		call flush_base (which_base (2));
		call emit_operator_call ((alloc_auto_adj));
		call emit_c_a ((store_base (which_base (2))), c_a ((p -> symbol.location), 6));

		/* If the return_value_param has a descriptor, copy to our descriptor. */

		if addr (rands (stack (zarg + n))) -> symbol.hash_chain ^= 0 & p -> symbol.hash_chain ^= 0
		then do;
		     call emit_single ((load_inst (in_q)), (addr (rands (stack (zarg + n))) -> symbol.hash_chain));
		     call emit_single ((store_inst (in_q)), (p -> symbol.hash_chain));
		     end;
		call reset_eaq (Q);
		end;

	     go to step;

action (80):					/* push_char_temp */
	     if left < 0
	     then do;

		/* have count */

		left = stack (top) + bias;
		top = top - 1;
		end;

	     call push (assign_char_temp (left));
	     go to step;

simple (16):					/* check_arg_list */
	     call check_arg_list;
	     go to step;

simple (17):					/* store_arg_addrs */
	     /*** Expects:

		external reference
		number of arguments
		arg1
		arg2
		.
		.
		.
		argn
		arglist temp ***/
	     zarg = base + 1;
	     n = stack (zarg) + bias;
	     temp = stack (zarg + n + 1);

	     do i = 1 to n;
		call base_man_load_pr ((stack (zarg + i)), 3);

		if assembly_list & addr (rands (stack (zarg + i))) -> node.node_type = symbol_node
		then a_name (text_pos) = stack (zarg + i);

		call emit_single_with_inc (store_base (3), temp, 2 * i);
		end;

	     go to step;

action (91):					/* (if unless)_constant_addrs */
	     b2 = macro_cond_inst (imac).if_test;
	     zarg = base + 1;
	     n = stack (zarg) + bias;
	     b1 = n <= hbound (itp_list, 1);

	     /* If descriptors must be supplied with this call, we cannot use
	        an ITP argument list.  This is because the constant nodes for
	        the argument list and the descriptors will not be allocated
	        until later, and we must know the addresses now. */

	     /* If we have a VLA parameter then we MUST make a correct
	        pointer to it, since we cannot indirect through the stack
	        or the linkage section through a packed pointer. */

	     if addr (rands (stack (base))) -> symbol.needs_descriptors
	     then b1 = "0"b;

	     do i = 1 to n while (b1);
		p = addr (rands (stack (zarg + i)));

		if assembly_list & p -> node.node_type = symbol_node
		then a_name (text_pos) = stack (zarg + i);

		if p -> node.node_type = symbol_node & p -> symbol.VLA
		then b1 = "0"b;			/* VLA is non-constant */

		if ^p -> node.is_addressable | ^p -> node.allocated
		     | p -> node.ext_base & ^(p -> node.base = sp | p -> node.base = lp)
		then b1 = "0"b;
		end;

	     go to if_join;

action (93):					/* get_quick_label */
	     op1 = get_operand (mopnd);
	     k = stack (op1);
	     if addr (rands (k)) -> symbol.external
	     then k = addr (rands (k)) -> symbol.initial;
	     stack (op1) = addr (rands (k)) -> symbol.initial;
	     go to step;

simple (18):					/* gen_itp_list */
	     unspec (arg_list.header) = "0"b;
	     zarg = base + 1;
	     n = stack (zarg) + bias;
	     arg_list.arg_count = 2 * n;

	     do i = 1 to n;
		p = addr (rands (stack (zarg + i)));
		call set_itp_addr (p, i);
		end;

	     stack (top) = create_constant_block (addr (arg_list), 2 * n + 2);
	     go to step;

simple (19):					/* make_descriptors */
	     if addr (rands (stack (base))) -> symbol.needs_descriptors
	     then do;
		zarg = base + 1;
		n = stack (zarg) + bias;
		temp = stack (zarg + n + 1);

		skip = 2 * n;
		if addr (rands (stack (base))) -> symbol.parameter
		then skip = skip + 2;

		do i = 1 to n;
		     desc = make_descriptor ((stack (zarg + i)));

		     if assembly_list & addr (rands (stack (zarg + i))) -> node.node_type = symbol_node
		     then a_name (text_pos) = stack (zarg + i);

		     call base_man_load_pr (desc, 3);
		     call emit_single_with_inc (store_base (3), temp, skip + 2 * i);
		     end;

		end;

	     go to step;

simple (42):					/* free_descriptors */
	     do while (desc_temp_chain ^= 0);
		p = addr (rands (desc_temp_chain));
		desc_temp_chain = p -> temporary.next;
		call free_temp (p);
		end;

	     go to step;

simple (20):					/* set_runtime_block_loc */
	     addr (rands (stack (base))) -> symbol.hash_chain = text_pos;
	     go to step;

action (104):					/* check_ref_count */
	     call print_message (424, "check_ref_count");
	     goto step;

action (110):					/* save_state */
	     call print_message (424, "save_state");


action (108):					/* round */
	     if do_rounding & ^machine_state.rounded
	     then do;
		eaq_name = macro_instruction (imac).eaq_name;
		call emit_zero ((round_inst (eaq_name)));
		machine_state.rounded = "1"b;
		machine_state.indicators_valid = eaq_name_to_reg (eaq_name);
		end;

	     goto step;

action (109):					/* flush_ref */
	     op1 = stack (get_operand (mopnd));
	     call flush_ref (op1);

	     goto step;

action (114):					/* set_in_storage */
	     op1 = stack (get_operand (mopnd));
	     addr (rands (op1)) -> node.not_in_storage = "0"b;
	     goto step;

action (125):					/* pad_char_const_to_word */
	     op1 = get_operand (mopnd);

	     if addr (rands (stack (op1))) -> char_constant.length = chars_per_word
	     then goto step;

	     else if addr (rands (stack (op1))) -> char_constant.length > chars_per_word
	     then call print_message (443, chars_per_word - bias, (stack (op1)));

	     substr (char_temp, 1, chars_per_word) = addr (rands (stack (op1))) -> char_constant.value;
	     stack (op1) = create_char_constant (substr (char_temp, 1, chars_per_word));
	     goto step;

action (126):					/* pad_char_const_to_dw */
	     op1 = get_operand (mopnd);

	     if addr (rands (stack (op1))) -> char_constant.length = chars_per_dw
	     then goto step;

	     else if addr (rands (stack (op1))) -> char_constant.length > chars_per_dw
	     then call print_message (443, chars_per_dw - bias, (stack (op1)));

	     substr (char_temp, 1, chars_per_dw) = addr (rands (stack (op1))) -> char_constant.value;
	     stack (op1) = create_char_constant (substr (char_temp, 1, chars_per_dw));
	     goto step;

simple (44):					/* int_to_char1 */
	     p = addr (rands (stack (top)));
	     if p -> node.node_type = constant_node & p -> node.data_type = int_mode
	     then do;
		char1 = byte (addr (p -> constant.value) -> int_image);
		call push (create_char_constant (char1));
		end;
	     else call print_message (462);

	     go to step;

simple (45):					/* char1_to_int */
	     p = addr (rands (stack (top)));
	     if p -> node.node_type = char_constant_node
	     then do;
		temp = rank (substr (p -> char_constant.value, 1, 1));
		call push (create_integer_constant ((temp)));
		end;
	     else call print_message (463);

	     go to step;

action (57):					/* start_cat */
	     call start_cat (b1);
	     if b1
	     then do;				/* Skip first mlr */
		imac = left;
		go to loop;
		end;
	     else go to step;

simple (46):					/* continue_cat */
	     call continue_cat ();
	     go to step;

simple (47):					/* finish_cat */
	     call finish_cat ();
	     go to step;

action (58):					/* shorten_stack */
	     if machine_state.stack_extended
	     then do;

		/* Reserve pr1 and call the correct operator */

		call reserve_regs (shorten_stack_mask);

		if left > 0			/* protect indicators? */
		then call emit_operator_call (shorten_stack_protect_ind);
		else do;
		     call use_ind ();
		     call emit_operator_call (shorten_stack);
		     end;

		machine_state.stack_extended = "0"b;
		machine_state.last_dynamic_temp = 0;

		call free_regs ();
		end;

	     go to step;

action (60):					/* (if unless)_ansi77 */
	     b2 = macro_cond_inst (imac).if_test;
	     b1 = cs -> subprogram.options.ansi_77;
	     go to if_join;

simple (48):					/* set_needs_descriptors */
	     addr (rands (stack (base))) -> symbol.needs_descriptors = "1"b;
	     go to step;

action (69):					/* (if unless)_variable_arglist */
	     b2 = macro_cond_inst (imac).if_test;
	     op1 = stack (get_operand (mopnd));
	     b1 = addr (rands (op1)) -> symbol.variable_arglist;
	     go to if_join;

action (74):					/* (if unless)_char_star_function */
	     b2 = macro_cond_inst (imac).if_test;
	     b1 = cs -> subprogram.star_extent_function;
	     go to if_join;

action (75):					/* (if unless)_check_multiply */
	     b2 = macro_cond_inst (imac).if_test;
	     b1 = cs -> subprogram.options.check_multiply;
	     go to if_join;

action (79):					/* (if unless)_storage_created */
	     b2 = macro_cond_inst (imac).if_test;
	     if Area_create_first >= 0
	     then b1 = "1"b;
	     else b1 = "0"b;
	     go to if_join;

action (88):					/* (if unless)_VLA */
	     b2 = macro_cond_inst (imac).if_test;
	     op1 = stack (get_operand (mopnd));

	     /* Only VLA if it is a symbol, which is VLA. */

	     if addr (rands (op1)) -> node.node_type = symbol_node
	     then b1 = addr (rands (op1)) -> symbol.VLA;
	     else b1 = "0"b;
	     go to if_join;

action (90):					/* (if unless)_cleanup */
	     b2 = macro_cond_inst (imac).if_test;
	     b1 = alloc_auto_cleanup;
	     go to if_join;

simple (52):					/* emit_cleanup_args */
	     text_halfs (text_pos).left = cleanup_body_address;
	     if assembly_list
	     then a_name (text_pos) = -1;		/* tell listing generator this is not an inst */
	     text_pos = text_pos + 1;
	     go to step;


simple (53):					/* emit_storage_args */
	     if Area_create_first < 0			/* See if storage */
	     then do;
		text_halfs (text_pos).left = fixed ("777777"b3, 18);
		reloc (text_pos).left_rel = rc_a;	/* leave absolute */
		end;
	     else do;
		text_halfs (text_pos).left = Area_create_first;
		reloc (text_pos).left_rel = rc_t;	/* relocate in text */
		end;

	     if Area_init_first < 0			/* See if initialization */
	     then do;
		text_halfs (text_pos).right = fixed ("777777"b3, 18);
		reloc (text_pos).right_rel = rc_a;	/* leave absolute */
		end;
	     else do;
		text_halfs (text_pos).right = Area_init_first;
		reloc (text_pos).right_rel = rc_t;	/* relocate in text */
		end;

	     if assembly_list
	     then a_name (text_pos) = -1;		/* list in octal */

	     text_pos = text_pos + 1;
	     goto step;


simple (54):					/* emit_profile_entry */
	     if ^(generate_profile & generate_long_profile)
	     then goto step;

	     call emit_profile_dummy;
	     call emit_profile_dummy;

	     call emit_profile_control;
	     call emit_profile_control;

	     call emit_profile_dummy;

	     goto step;

simple (57):					/* rhs_fld */
	     call rhs_fld;
	     goto step;

simple (58):					/* lhs_fld */
	     call lhs_fld;
	     goto step;

emit_profile_dummy:
     proc;

	/* emit a long_profile reference to long_profile_header.dummy */

	call emit_operator_call (long_profile);
	text_halfs (text_pos).left = profile_start;
	reloc (text_pos).left_rel = rc_is18;

	/* emit relative offset from long_profile_header to dummy entry */

	text_halfs (text_pos).right = 5;		/* dummy offset */
	reloc (text_pos).right_rel = rc_a;
	text_pos = text_pos + 1;
	return;
     end emit_profile_dummy;


emit_profile_control:
     proc;

	/* emit a long_profile reference to long_profile_header.control */

	call emit_operator_call (long_profile);
	text_halfs (text_pos).left = profile_start;
	reloc (text_pos).left_rel = rc_is18;

	/* emit relative offset from long_profile_header to control entry */

	text_halfs (text_pos).right = 9;		/* control offset */
	reloc (text_pos).right_rel = rc_a;
	text_pos = text_pos + 1;
	return;
     end emit_profile_control;

simple (55):					/* force_even */
	     if mod (text_pos, 2) ^= 0
	     then call emit_zero (nop);
	     goto step;

simple (56):					/* emit_entry_defs */
	     /*** Expects:

		entry label
		count of parameters ***/
	     /*** Make pointer to descriptor area we will build later.

		We will allocate space to put the node offset to the
		descriptor in the text section. This will later be filled
		by 'check_parameters' to hold the index of the constant
		node, then gen_entry_defs will later fill in the true text
		offset from the allocated nodes.

		This code is split into the three sections, this,
		check_parameters, and gen_entry_defs, since at this point
		we need to reserve space, but have not yet seen the quads
		or polish defining the parameters. At check parameters we
		put in the node offset to the descriptor, since it may not
		have been allocated, and forward refs only relocate the
		left half of an instruction. Finally at gen_entry_defs time
		we convert the node index to a text offset because all text
		allocations have been made at that time. ***/
	     zarg = base + 2;
	     n = stack (base + 1) + bias;

	     parm_desc_ptrsp = addr (text_word (text_pos));
	     parm_desc_ptrs.n_args = n;
	     k = text_pos;

	     /* Skip allocated area, and setup descr_relp_offset */

	     text_pos = text_pos + divide (n, 2, 18) + 1;
	     text_halfs (text_pos).left = k;
	     text_halfs (text_pos).right = 0;

	     reloc (text_pos).left_rel = rc_t;
	     reloc (text_pos).right_rel = rc_a;
	     text_pos = text_pos + 1;
	     go to step;

action (92):					/* (if unless)_hfp */
	     b2 = macro_cond_inst (imac).if_test;
	     b1 = cs -> subprogram.options.hfp;
	     goto if_join;

	     /* These macro opcodes are unused, or (if named) are used only by the
	        optimizing code generaor. */

simple (23):					/* discard_state */
simple (24):					/* push_output */
simple (25):					/* bump_args */
simple (26):					/* drop_args */
simple (27):					/* push_operand_count */
simple (29):					/* set_rounded */
simple (30):					/* load_xreg */
simple (31):					/* load_preg */
simple (32):					/* drop_all_counts */
simple (33):					/* ind_to_a */
simple (34):					/* assign_index */
simple (35):					/* compare_index */
simple (36):					/* test_index */
simple (37):					/* increment_index */
simple (38):					/* decrement_index */
simple (40):					/* refresh_regs_if_next_is_jump */
simple (41):					/* note_eligible_ind_var_use */
simple (43):					/* force_ql */
simple (51):
	     call print_message (436, left - bias);
	     go to step;

action (42):					/* use_a */
action (43):					/* use_q */
action (49):					/* refresh_regs */
action (59):					/* set_next_operand */
action (82):					/* (if unless)_global */
action (83):					/* (if unless)_induction_var */
action (84):					/* (if unless)_fb17 */
action (86):					/* (if unless)_global_ind_var */
action (94):
action (96):
action (97):
action (98):
action (100):
action (101):					/* if_next_statement */
action (102):					/* unless_next_statement */
action (103):
action (106):
action (107):
action (115):					/* bump */
action (116):					/* drop */
action (117):
action (118):					/* (if unless)_zero */
action (119):
action (120):
action (121):					/* push_ref_count */
action (122):
action (123):
action (127):					/* power_of_two */
	     call print_message (436, mop - bias);
	     go to step;

	     /* THESE SHOULD NOT EXECUTE */
action (0):					/* undefined */
action (12):					/* proc */
action (13):					/* func */
action (56):					/* (if unless)_saving_stack_extent */
action (67):					/* used by rest_of_error */
	     call print_message (413);

step:
	     end;

/**** STACK FRAME MANIPULATION ****/

push:
     procedure (i);

	/* Pushes an item onto the operand stack */

dcl  i fixed binary (18);

	top = top + 1;

	if top > hbound (stack, 1)
	then do;
	     call print_message (407, "operand stack", hbound (stack, 1) - bias);
	     return;
	     end;

	stack (top) = i;

     end push;

copy:
     procedure (opnd);

	/* Copies an operand onto the top of the stack */

dcl  (opnd, op) fixed binary (18);

	op = effective_operand (opnd);

	call push (op);

	if op > 0
	then do;
	     p = addr (rands (op));
	     if p -> node.node_type = array_ref_node | p -> node.node_type = temporary_node
	     then p -> temporary.ref_count = p -> temporary.ref_count + 1;
	     end;

     end copy;

pop:
     procedure (pthru);

	/* Pops the stack through thru -- top becomes thru - 1 */

dcl  (pthru, thru) fixed binary (18);			/* pop through thru */

dcl  n fixed binary (18);

	thru = pthru;

	do while (top >= thru);
	     if stack (top) > 0
	     then do;
		p = addr (rands (stack (top)));
		if p -> node.node_type = temporary_node
		then do;
		     n, p -> temporary.ref_count = p -> temporary.ref_count - 1;
		     if n <= 0
		     then call free_temp (p);
		     end;
		else if p -> node.node_type = array_ref_node
		then do;
		     n, p -> array_ref.ref_count = p -> array_ref.ref_count - 1;
		     if n <= 0
		     then call free_array_ref (p);
		     end;
		end;

	     top = top - 1;
	     end;

     end pop;

pop_frame:
     procedure ();

	/* Pops a procedure frame */

	cur_frame = cur_frame -> proc_frame.prev;
	base = cur_frame -> proc_frame.base;

     end pop_frame;

get_operand:
     procedure (opnd) returns (fixed binary (18));

	/* Takes an operand number as specified in a macro and returns
	   the corresponding operand stack subscript. */

dcl  opnd fixed binary (18);				/* Operand number specified in macro */

dcl  i fixed binary (18);

	if opnd < 0
	then return (top + opnd + 1);			/* opn */
	else if opnd > 0
	then return (base + opnd - 1);		/* argn */
	else do;

	     /* opv */

	     i = stack (top) + bias;
	     top = top - 1;
	     return (top - i + 1);
	     end;

     end get_operand;

interpreter_proc:
     procedure (mac_num, ret_lab);

	/* Calls an interpreter macro procedure.  ret_lab must
	   be set to the label of the stmt immediately following
	   the call to interpreter_proc.

	   Note that this scheme is really an attempt to escape the
	   necessity for recursion in invoking interpreter macro
	   procedures.  To be truly safe, this should have recursively
	   invoked the entire interpreter.  For this scheme to work,
	   all procedures between the caller and the interpreter MUST
	   be quick, and none of them (including the caller) must be
	   invoked during the processing of the interpreter macro
	   procedure.  This is necessary to ensure that no local
	   variables are destroyed.  Obviously a procedure is safe if
	   its last statement results in a call to interpreter_proc;
	   the interesting cases arise when some other statement in
	   a procedure directly or indirectly invokes interpreter_proc.

	   Of course, this is illegal PL/I. */

dcl  mac_num fixed binary (18),			/* Macro number of interpreter procedure */
     ret_lab label local;				/* Label to return to */

dcl  macro_proc fixed binary (18);

	macro_proc = fort_cg_macros_$interpreter_macros (mac_num).entry;

	call setup_call (macro_proc, imac, imac, 0);

	proc_frame.interpreter_called = "1"b;
	proc_frame.interpreter_return = ret_lab;

	imac = macro_proc;
	go to step;

     end interpreter_proc;

setup_call:
     procedure (macro_proc, return, error_exit, nb);

	/* Pushes a new procedure frame and sets it up for a call */

dcl  macro_proc fixed binary (18),			/* Procedure being called */
     return fixed binary (18),			/* Location from which the call is being made */
     error_exit fixed binary (18),			/* Location to jump to if errors occur */
     nb fixed binary (18);				/* Presupplied next_base if ^= 0 */

dcl  (mac_proc, next_base) fixed binary (18);

	mac_proc = macro_proc;

	if nb = 0
	then next_base = get_nextbase (mac_proc);
	else next_base = nb;

	/* get next procedure frame */

	if cur_frame -> proc_frame.next ^= null
	then cur_frame = cur_frame -> proc_frame.next;
	else cur_frame = create_proc_frame ();

	/* initialize next procedure frame */

	string (proc_frame.flags) = "0"b;

	if fixed (macro_instruction (mac_proc).op_code, 7) = function
	then proc_frame.func = "1"b;

	proc_frame.return = return;
	proc_frame.error_label = error_exit;
	base, proc_frame.base = next_base;
	proc_frame.nshort = 0;

     end setup_call;

create_proc_frame:
     procedure () returns (pointer);

	/* Allocates a procedure frame in the operand region */

dcl  p pointer;

	if mod (next_free_operand, 2) ^= 0
	then do;
	     rands (next_free_operand) = 0;		/* for debugging */
	     next_free_operand = next_free_operand + 1;
	     end;


	p = addr (rands (next_free_operand));
	next_free_operand = next_free_operand + size (proc_frame);

	if next_free_operand >= operand_max_len
	then do;
	     call print_message (407, "operand region", char (operand_max_len));
						/* FATAL */
	     return (null);				/* should never be executed */
	     end;

	if cur_frame ^= null
	then cur_frame -> proc_frame.next = p;

	unspec (p -> proc_frame) = "0"b;
	p -> proc_frame.prev = cur_frame;
	p -> proc_frame.next = null;
	return (p);

     end create_proc_frame;

get_nextbase:
     procedure (macro_proc) returns (fixed binary (18));

	/* Calculates base of new stack frame */

dcl  macro_proc fixed binary (18);			/* Proc being called */

dcl  nargs fixed binary (18);

	nargs = macro_dt_inst (macro_proc).data_type;
	if nargs < 0
	then nargs = stack (top) + bias + 1;
	return (top - nargs + 1);

     end get_nextbase;

/**** TEMPORARY MANAGEMENT ****/

assign_temp:
     procedure (data_type) returns (fixed binary (18));

	/* Assigns a temporary of a specific data type */

dcl  data_type fixed binary (4);

dcl  (clength, dt, size, temp) fixed binary (18);

	dt = data_type;
	size = data_type_size (dt);
	go to join;


assign_char_temp:
     entry (char_length) returns (fixed binary (18));

	/* Assigns a character temporary */

dcl  char_length fixed binary (18);

	dt = char_mode;
	clength = char_length;
	size = divide (clength + chars_per_word - 1, chars_per_word, 17, 0);
	go to join;


assign_block:
     entry (block_size) returns (fixed binary (18));

	/* Assigns a doubleword aligned block */

dcl  block_size fixed binary (18);

	size = block_size;
	size = size + mod (size, 2);
	dt = 0;

join:
	temp = get_temp (size);
	addr (rands (temp)) -> temporary.data_type = dt;
	addr (rands (temp)) -> temporary.ref_count = 1;
	addr (rands (temp)) -> temporary.units = word_units;

	if dt = char_mode
	then do;
	     addr (rands (temp)) -> temporary.length = clength;
	     if cs -> subprogram.options.ansi_77
	     then addr (rands (temp)) -> temporary.units = char_units;
	     end;

	return (temp);

get_temp:
     procedure (amount) returns (fixed binary (18));

	/* Finds a free temporary of the desired size */

dcl  (amt, amount, i, prev, temp) fixed binary (18);

	amt = amount;

	if amt <= 2
	then do;
	     i = amt;
	     temp = free_temps (i);

	     if temp ^= 0
	     then do;
		free_temps (i) = addr (rands (temp)) -> temporary.next;
		return (temp);
		end;
	     end;

	else do;
	     i = 3;
	     prev = 0;
	     temp = free_temps (3);

	     do while (temp ^= 0);

		if addr (rands (temp)) -> temporary.size >= amt
		then do;
		     if prev = 0
		     then free_temps (3) = addr (rands (temp)) -> temporary.next;
		     else addr (rands (prev)) -> temporary.next = addr (rands (temp)) -> temporary.next;
		     return (temp);
		     end;

		prev = temp;
		temp = addr (rands (temp)) -> temporary.next;
		end;
	     end;

	if i > 1
	then if mod (last_auto_loc, 2) ^= 0
	     then do;

		/* force doubleword alignment */

		temp = create_temp (1);
		addr (rands (temp)) -> temporary.next = free_temps (1);
		free_temps (1) = temp;
		end;

	return (create_temp (amt));

     end get_temp;

     end assign_temp;

get_temp_node:
     procedure () returns (fixed binary (18));

	/* Gets a temp node off the free chain, or allocates a new one. */

dcl  size builtin;
dcl  temp fixed binary (18);

	if next_free_temp = 0
	then temp = create_node (temporary_node, size (temporary));
	else do;
	     temp = next_free_temp;
	     next_free_temp = addr (rands (temp)) -> temporary.next;
	     unspec (addr (rands (temp)) -> temporary) = "0"b;
	     addr (rands (temp)) -> temporary.node_type = temporary_node;
	     end;

	return (temp);

     end get_temp_node;

create_temp:
     procedure (amount) returns (fixed binary (18));

	/* Creates a new temporary, possibly reusing a discarded
	   temporary node. */

dcl  node_size fixed binary;
dcl  (amount, op_type, temp) fixed binary (18);
dcl  amt fixed binary (18);
dcl  loc fixed binary (18);
dcl  node_type fixed binary (4);
dcl  p pointer;
dcl  size builtin;

	node_type = temporary_node;
	node_size = size (temporary);
	op_type = temp_type;
	go to join;

create_var:
     entry (amount) returns (fixed binary (18));

	/* Creates an automatic variable of the desired size */

	node_type = symbol_node;
	node_size = size (symbol);
	op_type = variable_type;

join:
	amt = amount;
	loc = last_auto_loc;

	if loc + amt > max_stack_size
	then call print_message (414, "in making a temporary the stack frame", max_stack_size - bias);
	else last_auto_loc = loc + amt;

	if node_type = symbol_node
	then temp = create_node (node_type, node_size);
	else temp = get_temp_node ();

	p = addr (rands (temp));

	p -> temporary.operand_type = op_type;
	string (p -> temporary.addressing_bits), string (p -> temporary.bits) = "0"b;

	p -> temporary.is_addressable, p -> temporary.allocate, p -> temporary.allocated = "1"b;

	unspec (p -> temporary.address) = ext_base_on;
	p -> temporary.base = sp;

	if node_type = temporary_node
	then do;
	     p -> temporary.size = amt;
	     p -> temporary.not_in_storage = "1"b;
	     end;

	p -> temporary.next = 0;

	p -> temporary.units = word_units;

	call set_address_offset (p, loc, amt, word_units);

	return (temp);

     end create_temp;

free_temp:
     procedure (temp_ptr);

	/* Procedure to free a temporary.  If the temporary has
	   variable length, the reference count of the associated
	   length temporary is decremented, and that temporary is
	   freed if necessary. */

dcl  temp_ptr pointer;				/* Pointer to temp node */

dcl  (tp, ltp) pointer;				/* To temp, length temp */
dcl  count fixed binary (18);				/* Reference count */

	tp = temp_ptr;

	if tp -> temporary.variable_length
	then do;

	     /* Must deal with associated length temporary */

	     ltp = addr (rands (tp -> temporary.length));
	     if ltp -> node.node_type = temporary_node
	     then do;
		count, ltp -> temporary.ref_count = ltp -> temporary.ref_count - 1;
		if count <= 0
		then call free_one_temp (ltp);
		tp -> temporary.length = 0;
		tp -> temporary.variable_length = "0"b;
		end;
	     end;

	call free_one_temp (tp);

     end free_temp;

free_one_temp:
     procedure (temp_ptr);

	/* This procedure flushes a temporary from the machine state
	   and threads it onto the appropriate free list. */

dcl  temp_ptr pointer;				/* Pointer to temp node */

dcl  tp pointer;					/* To temp node */
dcl  (temp, prev_temp, this_temp) fixed binary (18);
dcl  temp_size fixed binary (18);

	tp = temp_ptr;
	temp = fixed (rel (tp), 18);

	/* Check for reference count error */

	if tp -> temporary.ref_count < 0
	then do;
	     call print_message (415, temp);
	     return;
	     end;

	tp -> temporary.not_in_storage = "1"b;
	temp_size = tp -> temporary.size;

	call flush_ref (temp);
	call flush_addr (temp);

	/* Restore address of dynamic temporary */

	if tp -> temporary.stack_indirect
	then do;
	     unspec (tp -> temporary.address) = tp -> temporary.addr_hold;
	     tp -> temporary.address.ext_base = "1"b;
	     tp -> temporary.needs_pointer = "0"b;
	     tp -> temporary.is_addressable = ^tp -> temporary.large_address;
	     tp -> temporary.stack_indirect = "0"b;
	     end;

	/* One and two word temps have their own free lists */

	if temp_size < 3
	then do;
	     call thread_temp (temp, temp_size, 0);
	     return;
	     end;

	/* Larger temps go on the third free list, sorted by size */

	prev_temp = 0;
	this_temp = free_temps (3);
	do while (this_temp ^= 0);

	     if temp_size <= addr (rands (this_temp)) -> temporary.size
	     then do;
		call thread_temp (temp, 3, prev_temp);
		return;
		end;

	     prev_temp = this_temp;
	     this_temp = addr (rands (this_temp)) -> temporary.next;

	     end;

	/* Temp is larger than any on the free list. */

	call thread_temp (temp, 3, prev_temp);

     end free_one_temp;

thread_temp:
     procedure (temp, chain, prev);

	/* Threads temp onto the free list specified by chain after
	   the temp prev. */

dcl  (temp, chain, prev) fixed binary (18);

	if prev = 0
	then do;

	     /* Put temp at beginning of free list */

	     addr (rands (temp)) -> temporary.next = free_temps (chain);
	     free_temps (chain) = temp;
	     end;

	else do;
	     addr (rands (temp)) -> temporary.next = addr (rands (prev)) -> temporary.next;
	     addr (rands (prev)) -> temporary.next = temp;
	     end;

     end thread_temp;

push_variable:
     procedure (dt);

	/* Pushes an automatic variable of data_type dt onto the stack */

dcl  dt fixed binary (18);

dcl  (var, amt, temp) fixed binary (18);

	amt = data_type_size (dt);

	if amt > 1
	then if mod (last_auto_loc, 2) ^= 0
	     then do;

		/* force doubleword alignement for the variable */

		temp = create_temp (1);
		call free_temp (addr (rands (temp)));
		end;

	var = create_var (amt);

	addr (rands (var)) -> symbol.data_type = dt;

	call push (var);

     end push_variable;

/**** DYNAMIC TEMPORARY MANAGEMENT ****/

assign_dynamic_temp:
     procedure () returns (fixed binary (18));

	/* This procedure allocates and initializes a dynamic
	   character temporary, but emits no code.  Dynamic temps
	   are implemented as two word temporaries which hold a
	   pointer to the actual stack extension. */

dcl  t fixed binary (18);				/* Two word temp */
dcl  p pointer;					/* Pointer to it */

	t = assign_block (2);
	p = addr (rands (t));

	p -> temporary.data_type = char_mode;
	p -> temporary.stack_indirect = "1"b;
	p -> temporary.needs_pointer = "1"b;
	p -> temporary.is_addressable = "0"b;

	p -> temporary.addr_hold = substr (unspec (p -> temporary.address), 1, 18);
	p -> temporary.reloc_hold = p -> temporary.reloc;

	unspec (p -> temporary.address) = ext_base_on;
	p -> temporary.reloc = rc_a;

	return (t);

     end assign_dynamic_temp;

allocate_dynamic_temp:
     procedure (temp, tv_offset);

	/* Emits code to extend the stack for a dynamic temporary.
	   The parameter tv_offset should be set to either
	   allocate_char_string or reallocate_char_string. */

dcl  temp fixed binary (18);				/* Temporary node */
dcl  tv_offset fixed binary (14);			/* Operator offset */

dcl  p pointer;

	p = addr (rands (temp));

	call load ((p -> temporary.length), in_q);
	call use_eaq (0);
	call flush_base (which_base (2));
	call emit_operator_call ((tv_offset));

	machine_state.stack_extended = "1"b;
	machine_state.address_in_base = "1"b;
	p -> temporary.address_in_base = "1"b;
	p -> temporary.address.base = bases (which_base (2));

	machine_state.last_dynamic_temp = temp;

	machine_state.base_regs (which_base (2)).variable = temp;
	machine_state.base_regs (which_base (2)).type = 1;
	machine_state.base_regs (which_base (2)).used = text_pos;
	machine_state.base_regs (which_base (2)).offset = 0;

     end allocate_dynamic_temp;

/**** EMISSION OF OBJECT CODE ****/

emit_inst:
     procedure ();

	/* Emits an instruction of object code */

dcl  (inc, rand) fixed binary (18);

	if string (machine_instruction (imac).ext_base_and_tag) ^= "0"b
	then text_word (text_pos) = unspec (machine_instruction (imac));

	else do;

	     /* have an operand */

	     inc = machine_instruction (imac).increment;
	     rand = get_operand ((machine_instruction (imac).operand));

	     call put_word ((machine_instruction (imac)), (stack (rand)), inc);
	     end;

	text_pos = text_pos + 1;

     end emit_inst;

emit_single:
     procedure (mac_num, rand);

	/* Emits an instruction from a table of single instructions */

dcl  mac_num fixed binary (18),			/* Single instruction number */
     rand fixed binary (18);				/* Operand for the inst */
dcl  inc fixed binary (18);

	inc = fort_cg_macros_$single_inst (mac_num).increment;

	call put_word ((fort_cg_macros_$single_inst (mac_num)), (rand), inc);

	text_pos = text_pos + 1;
	return;


emit_single_with_inc:
     entry (mac_num, rand, incr);

	/* Emits a single instruction with a specified address increment */

dcl  incr fixed binary (18);

	inc = incr;


	call put_word ((fort_cg_macros_$single_inst (mac_num)), (rand), inc);

	text_pos = text_pos + 1;

     end emit_single;

emit_with_tag:
     procedure (mac_num, address, tag);

	/* Emits an instruction with a constant address and a tag field */

dcl  mac_num fixed binary (18),
     address fixed binary (18),
     tag bit (6) aligned;

dcl  1 inst like machine_instruction aligned;

	text_word (text_pos) = unspec (fort_cg_macros_$single_inst (mac_num)) & mask_left;
	instruction (text_pos).tag = tag;
	text_halfs (text_pos).left = address;
	text_pos = text_pos + 1;
	return;
     end emit_with_tag;

emit_zero:
     procedure (mac_num);

	/* Emits an instruction without operands */

dcl  mac_num fixed binary (18);

	text_word (text_pos) = unspec (fort_cg_macros_$single_inst (mac_num));
	text_pos = text_pos + 1;

     end emit_zero;

emit_c_a:
     procedure (mac_num, address);

	/* Emits an instruction given an address probably supplied by c_a */

dcl  mac_num fixed binary (18);			/* Single instruction number */
dcl  address bit (36) aligned;

	text_word (text_pos) = (unspec (fort_cg_macros_$single_inst (mac_num)) & mask_left) | address;

	if fort_cg_macros_$single_inst (mac_num).increment ^= 0
	then if instruction (text_pos).ext_base
	     then instruction (text_pos).offset =
		     instruction (text_pos).offset + fort_cg_macros_$single_inst (mac_num).increment;
	     else text_halfs (text_pos).left =
		     text_halfs (text_pos).left + fort_cg_macros_$single_inst (mac_num).increment;

	text_pos = text_pos + 1;

     end emit_c_a;

emit_c_a_var:
     procedure (mac_num, var_ptr);

	/* Emits an instruction given an address probably supplied by
	   c_a and outputs reloc and listing info */

dcl  mac_num fixed binary (18);			/* Single instruction number */
dcl  var_ptr pointer;				/* Pointer to node for operand */
dcl  p pointer;					/* Pointer to array_ref_parent */
dcl  text_offset fixed bin;				/* offset of instruction in text section */

	reloc (text_pos).left_rel = var_ptr -> node.reloc;

	if assembly_list
	then if var_ptr -> node.node_type = array_ref_node
	     then a_name (text_pos) = var_ptr -> array_ref.parent;
	     else a_name (text_pos) = binary (rel (var_ptr), 18, 0);

	call emit_c_a ((mac_num), unspec (var_ptr -> node.address));

	/* catch possible references to the text section  - phx13550 */

	p = var_ptr;
	if var_ptr -> node.node_type = array_ref_node
	then p = addr (rands (var_ptr -> array_ref.parent));

	if substr (unspec (p -> node.address), 30, 7) = "0000000"b
	then do;
	     text_pos = text_pos - 1;			/* Backup since emit_c_a inc text_pos */
	     text_offset = instruction.offset (text_pos);
	     instruction.offset (text_pos) = 0;		/* clear out offset (14 bit) */
	     call text_ref (p, (fort_cg_macros_$single_inst (mac_num).increment) + text_offset,
		fixed (fort_cg_macros_$single_inst (mac_num).op_code, 10), 0);
	     text_pos = text_pos + 1;			/* fixup */
	     end;
     end emit_c_a_var;

emit_temp_store:
     procedure (mac_no, temp);

	/* Emits code to store a temporary.  Calls emit_c_a rather
	   than emit_single to avoid recursion. */

dcl  (mac_no, mac) fixed binary (18);
dcl  temp fixed binary (18);
dcl  p pointer;

	mac = mac_no;
	p = addr (rands (temp));

	if ^p -> temporary.is_addressable
	then call m_a_except_xreg (p);

	call emit_c_a (mac, unspec (p -> temporary.address));

	p -> temporary.not_in_storage = "0"b;

     end emit_temp_store;

emit_operator_call:
     procedure (tv_offset);

	/* Emits an instruction of the form tsx0 pr0|tv_offset. */

dcl  tv_offset fixed binary (14);
dcl  1 inst aligned like instruction;

	unspec (inst) = ext_base_on;
	inst.offset = tv_offset;
	inst.op = "1110000000"b;			/* 700 (0) - tsx0 */

	text_word (text_pos) = unspec (inst);
	text_pos = text_pos + 1;

     end emit_operator_call;

put_word:
     procedure (inst, rand, inc);

	/* Uses inst as a template to put out an instruction with
	   rand as an operand and inc as the increment */

dcl  1 inst like machine_instruction parameter aligned,
     rand fixed binary (18),
     inc fixed binary (18);

dcl  p pointer;

dcl  mop fixed binary (18);

	if rand < 0
	then do;

	     /* have a count, make it the address */

	     text_word (text_pos) = unspec (inst) & mask_left;

	     /* use direct modifier if possible */

	     mop = fixed (inst.op_code, 10);
	     if directable (mop)
	     then instruction (text_pos).tag = DL_mod;	/* dl */

	     text_halfs (text_pos).left = rand + bias + inc;
	     return;
	     end;

	p = addr (rands (effective_operand (rand)));

	if ^p -> node.is_addressable
	then do;
	     if inc ^= 0 & p -> node.address.ext_base
	     then call increment_address (p, (inc));
	     call m_a (p);
	     end;

	text_word (text_pos) = (unspec (inst) & mask_left) | unspec (p -> node.address);

	reloc (text_pos).left_rel = p -> node.reloc;

	if assembly_list
	then if p -> node.node_type = array_ref_node
	     then a_name (text_pos) = p -> array_ref.parent;
	     else a_name (text_pos) = rand;

	if substr (unspec (p -> node.address), 30, 7) = "0000000"b
	then call text_ref (p, (inc), fixed (inst.op_code, 10), 0);
	else if inc ^= 0
	then if instruction (text_pos).ext_base
	     then if ^p -> node.is_addressable
		then call increment_address (p, -inc);
		else instruction (text_pos).offset = instruction (text_pos).offset + inc;
	     else text_halfs (text_pos).left = text_halfs (text_pos).left + inc;

     end put_word;

text_ref:
     procedure (pt, inc, mop, desc_no);

	/* Handles reference to the text section */

dcl  pt pointer;					/* Points to addressed node */
dcl  inc fixed binary (18);				/* Address increment */
dcl  mop fixed binary (18);				/* Instruction opcode */
dcl  desc_no fixed binary (18);			/* EIS descriptor number, or 0 */

dcl  temp fixed binary (18);
dcl  (p, q) pointer;
dcl  use_dl bit (1) aligned;
dcl  value bit (36) aligned;

dcl  (
     ldq init ("236"b3),
     lcq init ("336"b3),
     adq init ("076"b3),
     sbq init ("176"b3)
     ) bit (10) aligned internal static options (constant);

dcl  mf (0:2) fixed binary (6) internal static options (constant) initial (31, 31, 13);
						/* Location of MF within instruction */


	p = pt;

	q = null ();
	if p -> node.node_type = constant_node
	then q = addr (p -> constant.value);
	else if p -> node.node_type = char_constant_node
	then do;
	     value = unspec (p -> char_constant.value);
	     q = addr (value);
	     end;

	if q ^= null ()
	then if inc = 0
	     then if directable (mop)
		then do;

		     /* Attempt to use DL modification for any constant,
		        unless it is an operand of an EIS instruction. */

		     if (q -> half.left = 0) & (desc_no = 0)
		     then do;
			text_halfs (text_pos).left = q -> half.right;
			instruction (text_pos).tag = DL_mod;
						/* dl */
			reloc (text_pos).left_rel = rc_a;
			return;
			end;

		     /* Attempt to use DU modification for any constant,
		        unless it is the first operand of an EIS instruction. */

		     if (q -> half.right = 0) & (desc_no ^= 1)
		     then do;
			text_halfs (text_pos).left = q -> half.left;
			substr (text_word (text_pos - desc_no), mf (desc_no), 6) = DU_mod;
			reloc (text_pos).left_rel = rc_a;
			return;
			end;

		     if q -> int_image < 0
		     then do;

			/* Attempt to optimize negative constants */

			temp = -q -> int_image;
			q = addr (temp);

			if q -> half.left = 0
			then do;
			     use_dl = "1"b;

			     if instruction (text_pos).op = ldq
			     then instruction (text_pos).op = lcq;

			     else if instruction (text_pos).op = adq
			     then instruction (text_pos).op = sbq;

			     else if instruction (text_pos).op = sbq
			     then instruction (text_pos).op = adq;

			     else if instruction (text_pos).op = lcq
			     then instruction (text_pos).op = ldq;

			     else use_dl = "0"b;

			     if use_dl
			     then do;
				text_halfs (text_pos).left = q -> half.right;
				instruction (text_pos).tag = DL_mod;
				reloc (text_pos).left_rel = rc_a;
				return;
				end;
			     end;
			end;
		     end;

	p -> node.allocate = "1"b;

	if ^p -> node.allocated
	then do;
	     text_halfs (text_pos).left = inc;

	     /* add this forward reference to a list of forward refs */

	     if next_free_polish >= polish_max_len
	     then call print_message (407, "polish region", char (polish_max_len));

	     if p -> node.operand_type = external
	     then p = addr (rands (p -> symbol.initial));

	     next_free_polish = next_free_polish + 1;

	     forward_refs (next_free_polish - 1).operand = fixed (rel (p), 18);
	     forward_refs (next_free_polish - 1).instruction = text_pos;
	     end;

	else if inc ^= 0
	then text_halfs (text_pos).left = text_halfs (text_pos).left + inc;

	/* try to use a direct modifier with a rel_constant */

	if p -> node.operand_type = rel_constant
	then if directable (mop)
	     then instruction (text_pos).tag = DL_mod;	/* dl */

     end text_ref;

emit_eis:
     procedure ();

	/* Emits a single EIS instruction, presently assumed to
	   be 1 instruction word + 2 descriptor words.  Only
	   desc9a is allowed for now.  An example follows:

	   emit_eis

	   mlr	(pr),(pr),fill(040)
	   desc9a	op1
	   desc9a	arg2+3

	   If the length field is omitted, which is the usual
	   case, the interpreter supplies it.  The interpreter
	   supplies the Modification Fields.  If the equal_lengths
	   keyword is given, the length of the second operand is
	   taken to be identical to the length of the first. */

dcl  arg (2) pointer;
dcl  op (2) fixed binary (18);
dcl  len (2) fixed binary (18);
dcl  lreg (2) bit (6) aligned;
dcl  inc (2) fixed binary (18);
dcl  p ptr;					/* pointer to descriptor addressed node */
dcl  text_offset fixed bin (18);			/* used for text reference */

dcl  1 descriptor (0:262143) based (object_base) aligned,
       2 word_address bit (18) unaligned,
       2 char bit (2) unaligned,
       2 bit bit (4) unaligned,
       2 length bit (12) unaligned;

dcl  mf (3) fixed binary (6) internal static options (constant) initial (30, 12, 3);

dcl  (i, inst_pos) fixed binary (18);

dcl  bit builtin;

	imac = imac + 1;				/* point at the instruction */

	/* pick up the operands and address increments */

	do i = 1 to 2;
	     op (i) = stack (get_operand ((machine_instruction (imac + i).operand)));
	     arg (i) = addr (rands (op (i)));
	     inc (i) = machine_instruction (imac + i).increment;
	     lreg (i) = "00"b3;
	     end;

	/* Make operands addressable, reserving registers as needed */

	call make_both_addressable (arg, inc);

	/* Get lengths of operands, reserving registers as needed */

	call get_eis_length (1);			/* Get length of 1st opnd */

	if left > 0				/* Equal lengths? */
	then if mac_base -> descriptor (imac + 2).length = "000"b3
	     then do;

		/* Copy length info from 1st opnd to 2nd */

		len (2) = len (1);
		lreg (2) = lreg (1);
		end;

	     else call print_message (466);

	else call get_eis_length (2);			/* Get length for opnd 2 */

	/* Move in the instruction word */

	inst_pos = text_pos;
	text_word (text_pos) = unspec (machine_instruction (imac));

	/* fill in the descriptors and modification fields */

	do i = 1 to 2;
	     imac = imac + 1;
	     text_pos = text_pos + 1;

	     substr (text_word (inst_pos), mf (i), 7) = substr (unspec (arg (i) -> node.address), 30, 7);

	     if lreg (i)
	     then substr (text_word (inst_pos), mf (i) + 1, 1) = "1"b;

	     /* Fill in address of descriptor, including char and bit offsets */

	     substr (unspec (descriptor (text_pos)), 1, 24) = substr (unspec (arg (i) -> node.address), 1, 20);

	     if lreg (i)
	     then descriptor (text_pos).length = (6)"0"b || lreg (i);
	     else descriptor (text_pos).length = bit (fixed (len (i), 12), 12);

	     reloc (text_pos).left_rel = arg (i) -> node.reloc;

	     if assembly_list
	     then if arg (i) -> node.node_type = array_ref_node
		then a_name (text_pos) = arg (i) -> array_ref.parent;
		else a_name (text_pos) = op (i);

	     /* See if text reference, if so may need forward reference. */

	     text_offset = inc (i);
	     p = arg (i);
	     if p -> node.node_type = array_ref_node
	     then do;
		p = addr (rands (p -> array_ref.parent));
		text_offset = text_offset + arg (i) -> node.offset;
		end;
	     if substr (unspec (p -> node.address), 30, 7) = "0000000"b
	     then call text_ref (p, text_offset, fixed (machine_instruction (imac - i).op_code, 10), i);

	     else if inc (i) ^= 0
	     then if arg (i) -> node.ext_base
		then if ^arg (i) -> node.is_addressable
		     then call increment_address (arg (i), -inc (i));
		     else instruction (text_pos).offset = instruction (text_pos).offset + inc (i);
		else text_halfs (text_pos).left = text_halfs (text_pos).left + inc (i);
	     end;

	text_pos = text_pos + 1;

	/* Free regs used by addresses and lengths of EIS operands */

	call free_regs ();

	return;

get_eis_length:
     procedure (opno);

	/* Internal procedure of emit_eis.  Computes the length of the
	   specified operand of the EIS instruction, setting len and
	   lreg. */

dcl  (opno, i) fixed binary;				/* Operand number */
dcl  csize fixed binary (18);				/* Character size of opnd */

	i = opno;

	if mac_base -> descriptor (imac + i).length = "000"b3
	then do;

	     /* Length not given, figure it out */

	     csize = get_char_size ((arg (i)));
	     if csize < 0				/* Constant length */
	     then len (i) = csize + bias;
	     else do;
		if addr (rands (csize)) -> node.value_in.eaq
		then lreg (i) = eaq_man_load_a_or_q (addr (rands (csize)));
		else lreg (i) = xr_man_load_any_xr (addr (rands (csize)));
		len (i) = 0;
		end;
	     end;

	else len (i) = fixed (mac_base -> descriptor (imac + i).length, 12);

	/* If constant length will not fit in 12 bits, put it in an index register */

	if len (i) > 4095
	then lreg (i) = xr_man_load_const (len (i));

	/* Reserve register used for length */

	call lock_tag_register ((lreg (i)));

     end get_eis_length;

     end emit_eis;

/**** ADDRESSING SECTION ****/

m_a:
     procedure (pt);

	/* make_addressable */

dcl  (p, pt, s, v) pointer;

	p = pt;

	if p -> node.is_addressable
	then return;

	if p -> node.address_in_base
	then do;
	     p -> node.address.base = base_man_load_any_pr (1, fixed (rel (p), 17), 0);
	     return;
	     end;

	if p -> node.node_type = array_ref_node
	then do;
	     s = addr (rands (p -> array_ref.parent));
	     if ^p -> array_ref.has_address
	     then do;
		call print_message (446, fixed (rel (p), 18));
		stop;
		end;

	     if p -> array_ref.variable_offset
	     then do;
		v = addr (rands (p -> array_ref.v_offset));
		if v -> node.value_in.eaq | v -> node.dont_update
						/* really node.subs_in_q */
		     | p -> array_ref.large_offset
		then do;

		     /* Process array-ref of VLA.  'v' is the total Packed Pointer.  If it is in
		        the Q or A register then we leave it and will later use epp,easp, else if
		        it is in storage then we can use an lprp. */

		     if ^s -> symbol.VLA
		     then do;
			p -> array_ref.address.tag = eaq_man_load_a_or_q (v);
			v -> node.dont_update = "0"b; /* really node.subs_in_q */
			end;

		     end;
		else p -> array_ref.address.tag = xr_man_load_any_xr (v);
		end;

	     end;

	call m_a_except_xreg (p);

	if p -> node.data_type = char_mode & p -> node.units ^= char_units
	then do;
	     if ^from_base_man
	     then if p -> node.address.tag
		then do;
		     p -> node.addr_hold = substr (unspec (p -> node.address), 1, 18);
		     p -> node.reloc_hold = p -> node.reloc;
		     p -> node.address.base = base_man_load_any_pr (1, fixed (rel (p), 17), 0);
		     p -> node.address.offset = 0;
		     p -> node.address.tag = "0"b;
		     p -> node.reloc = rc_a;
		     end;
	     end;


     end m_a;

m_a_except_xreg:
     procedure (pt);

	/* make_addressable, but don't call xr_man and don't do special
	   aligned character addressing. */

dcl  (p, pt) pointer;				/* Node to make addressable */
dcl  p1 pointer;					/* Node to get adressing info from */
dcl  (i, offset) fixed binary (18);

	p = pt;

	if p -> node.node_type = array_ref_node
	then p1 = addr (rands (p -> array_ref.parent));
	else p1 = p;

	if p1 -> node.needs_pointer
	then do;

	     /* prevent a multi-position VLA parameter from missing VLA processing. */

	     if p1 -> node.stack_indirect & ^(p1 -> node.node_type = symbol_node & p1 -> symbol.VLA)
	     then do;
		i = 4;
		if p1 -> node.node_type = temporary_node
		then do;
		     offset = fixed (substr (p1 -> temporary.addr_hold, 4, 15), 15);
		     if offset >= 16384
		     then offset = offset - 32768;
		     if p1 -> temporary.large_address
		     then offset = offset + p1 -> temporary.location;
		     p -> temporary.address.base = base_man_load_any_pr (i, offset, 0);
		     return;
		     end;
		end;

	     /* Must be a symbol node */

	     else if p1 -> symbol.VLA
	     then do;
		p -> node.address.base = base_man_load_any_pr (1, fixed (rel (p), 17, 0), 0);
		return;
		end;				/* we are pointer at our pointer */
	     else if p1 -> symbol.LA
	     then do;
		if p1 -> symbol.static
		then i = 11;			/* static indirect */
		else i = 4;			/* stack */
		p1 = addr (rands (p1 -> symbol.parent));
		end;
	     else if p1 -> symbol.in_common
	     then do;
		i = 3;
		p1 = addr (rands (p1 -> symbol.parent));
		end;
	     else if p1 -> symbol.parameter
	     then i = 2;
	     else if p1 -> symbol.descriptor
	     then i = 10;
	     else do;
		call print_message (417, fixed (rel (p), 18));
		return;
		end;

	     if ^p -> symbol.large_address
	     then p -> symbol.address.base = base_man_load_any_pr (i, (p1 -> node.location), 0);
	     else p -> symbol.address.base = base_man_load_any_pr (i, (p1 -> node.location), (p -> symbol.location));
	     end;

	else if p1 -> node.node_type = symbol_node
	then do;
	     if p1 -> symbol.external & p1 -> symbol.initial ^= 0
	     then do;

		/* have an  external subr or func reference
		   that is really local */

		p1 = addr (rands (p1 -> symbol.initial));

		if p1 -> symbol.allocated
		then do;
		     unspec (p -> symbol.address) = unspec (p1 -> symbol.address);
		     p -> symbol.allocated, p -> symbol.is_addressable = "1"b;
		     end;
		end;

	     else if p1 -> symbol.parameter
	     then p -> node.address.base = base_man_load_arg_ptr ();

	     else call m_a_check_large_address (p, p1);
	     end;

	else call m_a_check_large_address (p, p1);

     end m_a_except_xreg;

m_a_check_large_address:
     procedure (pt, pt1);

	/* Handles large addresses */

dcl  (pt, p, pt1, p1) pointer;
dcl  usual_base bit (3) aligned;
dcl  i fixed binary (18);

	p = pt;
	p1 = pt1;

	if p -> node.large_address
	then do;

	     /* have abs(address) >= 16K */

	     usual_base = sp;
	     if p1 -> node.node_type = symbol_node
	     then if p1 -> symbol.static | p1 -> symbol.external
		then usual_base = lp;

	     i = p -> node.location;

	     if i ^= 0
	     then p -> node.address.base = base_man_load_large_base (i, usual_base);
	     else p -> node.address.base = usual_base;

	     end;

     end m_a_check_large_address;

increment_address:
     procedure (p, inc);

	/* Applies increment to address of node */

dcl  p pointer,
     inc fixed binary (18);

dcl  (loc, offset) fixed binary (18);

	if ^p -> node.large_address
	then p -> node.address.offset = p -> node.address.offset + inc;

	else do;
	     loc, offset = p -> node.address.offset + p -> node.location + inc;
	     offset = mod (offset + 16384, 32768) - 16384;
	     p -> node.location = loc - offset;
	     p -> node.address.offset = offset;
	     end;

     end increment_address;

c_a:
     procedure (c, code) returns (bit (36) aligned);

	/* Fabricates a constant address to be used with emit_c_a */

dcl  (c, n, code) fixed binary (18);

dcl  1 inst_address aligned like symbol.address;

	n = c;
	unspec (inst_address) = "0"b;
	go to sw (code);

sw (1):						/* n,ql */
	inst_address.tag = QL_mod;
	go to exit;

sw (5):						/* location n in the linkage section */
	inst_address.base = lp;
	go to set_ext_base;

sw (6):						/* location n in the stack */
	inst_address.base = sp;
	go to set_ext_base;

sw (3):						/* location n indirect in linkage section */
sw (11):						/* location n indirect in static section */
	inst_address.base = lp;
	go to indirect;

sw (4):						/* location n indirect in stack */
	inst_address.base = sp;

indirect:
	inst_address.tag = inst_address.tag | "010000"b;

set_ext_base:
	inst_address.ext_base = "1"b;

	if n >= 16384
	then do;
	     n = mod (n + 16384, 32768) - 16384;
	     inst_address.base = base_man_load_large_base (c - n, (inst_address.base));
	     end;

exit:
	inst_address.offset = n;
	return (unspec (inst_address));

     end c_a;

c_a_18:
     procedure (n, code) returns (bit (36) aligned);

	/* Fabricates a constant address with 18 bit offset field
	   for use with emit_c_a. */

dcl  n fixed binary (18);				/* Offset */
dcl  code fixed binary (18);				/* 1 = DU */

dcl  1 inst_address aligned,
       2 offset fixed binary (17) unaligned,
       2 op_code bit (10) unaligned,
       2 inhibit bit (1) unaligned,
       2 ext_base bit (1) unaligned,
       2 tag bit (6) unaligned;

	unspec (inst_address) = "0"b;

	inst_address.offset = n;

	if code = 1
	then inst_address.tag = DU_mod;

	return (unspec (inst_address));

     end c_a_18;

make_both_addressable:
     procedure (arg, inc);

	/* Makes two operands simultaneously addressable by reserving
	   registers as it goes. */

dcl  arg (2) pointer;
dcl  inc (2) fixed binary (18);
dcl  (i, reg) fixed binary (3);
dcl  p pointer;

	do i = 1 to 2;

	     p = arg (i);

	     if ^p -> node.is_addressable
	     then do;

		if inc (i) ^= 0 & p -> node.address.ext_base
		then call increment_address (p, inc (i));

		call m_a (p);

		/* Reserve any XRs or EAQ registers used */

		call lock_tag_register ((p -> node.address.tag));

		/* Reserve any base registers used */

		if p -> node.address.ext_base
		then do;
		     reg = which_base (fixed (p -> node.address.base, 3));
		     machine_state.base_regs (reg).reserved = "1"b;	/* lock for use in addressing */
		     end;

		end;

	     end;

     end make_both_addressable;

/**** GET_FREE_REG ****/

get_free_reg:
     procedure (regs, first, last, k) returns (fixed binary (3));

	/* Implements register searching algorithm */

dcl  1 regs (0:7) aligned like base_regs,
     (first, last) fixed binary (18),			/* Limits of search */
     k fixed binary (3);				/* Register already found to be empty */

dcl  (i, j) fixed binary (3);
dcl  lused fixed binary (18);

	if k > 0
	then if ^regs (k).reserved
	     then return (k);

	j = -1;
	lused = 131071;

	do i = first to last;

	     if ^regs (i).reserved
	     then do;
		if regs (i).type = 0
		then return (i);
		if regs (i).used < lused
		then do;
		     lused = regs (i).used;
		     j = i;
		     end;
		end;

	     end;

	if j < 0
	then call print_message (418);
	else return (j);

     end get_free_reg;

/**** POINTER REGISTER MANAGEMENT ****/

	/* The contents of the pointer registers are determined by the
	   value of the type field as follows:
	   (v = variable field)

	   -1		UNKNOWN
	   0		EMPTY
	   1		address of operand specified by v
	   2		ptr to loc v in arg list
	   3		ptr thru link with offset v
	   4		ptr at at stack offset v
	   5		arg list ptr
	   6		linkage ptr
	   7		value of operand specified by v
	   8		stack ptr
	   9		ptr to arg desc list
	   10		ptr to loc v in desc list
	   11		ptr thru static with offset v
	*/

base_man_load_any_pr:
     procedure (code, num, offset) returns (bit (3) aligned);

dcl  (n, code) fixed binary (18),			/* Type of operation */
     (v, num) fixed binary (18),			/* Location of ptr to be loaded */
     (off, offset) fixed binary (18);			/* Offset to be added to pointer */

dcl  VLA bit (1);					/* True if VLA */
dcl  s ptr;

dcl  (i, j, k) fixed bin (3);
dcl  address bit (36) aligned;
dcl  diff fixed bin (18);

	n = code;
	v = num;
	diff, off = offset;

	j, k = 0;

	do i = first_base to last_base;
	     if base_regs (i).type = 0
	     then k = i;
	     else if base_regs (i).type = n
	     then if base_regs (i).variable = v
		then if base_regs (i).offset = off
		     then do;
			base_regs (i).used = text_pos;
			return (bases (i));
			end;
		     else j = i;
	     end;

	if j > 0
	then do;

	     /* Right storage area, but wrong offset */

	     diff = off - base_regs (j).offset;
	     address = c_a (0, 6);
	     substr (address, 1, 3) = bases (j);
	     i = get_free_reg (base_regs, first_base, last_base, k);
	     call flush_base (i);
	     call emit_c_a ((load_base (i)), address);
	     end;

	else if n = 1
	then do;
	     s = addr (rands (v));
	     if s -> node.node_type = symbol_node
	     then VLA = s -> symbol.VLA;
	     else if s -> node.node_type = array_ref_node
	     then VLA = addr (rands (s -> array_ref.parent)) -> symbol.VLA;
	     else VLA = "0"b;
	     s -> node.address_in_base = "1"b;
	     machine_state.address_in_base = "1"b;
	     i = get_free_reg (base_regs, first_base, last_base, k);
	     call flush_base (i);

	     /* A very large reference can be of two types:
	        1. array-reference.  in this case the vsum of the reference is in memory
	        and is the total addressor needed by lprp.
	        2. normal-reference. in this case the address in the symbol node is
	        sufficient to address directly a base to the variable for
	        lprp.
	     */

	     if VLA
	     then call base_man_load_VLA (v, i);
	     else call emit_c_a_var ((load_base (i)), addr (rands (v)));
	     end;

	else if n = 2 | n = 10
	then do;
	     address = c_a (v, 4);
	     if n = 2
	     then substr (address, 1, 3) = base_man_load_arg_ptr ();
	     else substr (address, 1, 3) = base_man_load_desc_ptr ();

	     i = get_free_reg (base_regs, first_base, last_base, 0);
	     call flush_base (i);
	     call emit_c_a ((load_base (i)), address);
	     end;

	else do;

	     address = c_a (v, n);

	     if v >= 16384
	     then k = 0;				/* base_regs state was changed */

	     i = get_free_reg (base_regs, first_base, last_base, k);
	     call flush_base (i);

	     if n = 3				/* linkage indirect */
	     then reloc (text_pos).left_rel = rc_lp15;
	     else if n = 11				/* static indirect */
	     then reloc (text_pos).left_rel = rc_is15;

	     call emit_c_a ((load_base (i)), address);

	     end;

	if diff ^= 0
	then call emit_c_a ((add_base (i)), c_a_18 (diff, 1));

	base_regs (i).type = n;
	base_regs (i).variable = v;
	base_regs (i).offset = off;
	base_regs (i).used = text_pos;

	return (bases (i));

     end base_man_load_any_pr;

base_man_load_VLA:
     proc (op, i);

dcl  op fixed bin (18);
dcl  (loc_p, s, p, v) ptr;
dcl  i fixed bin (3);
dcl  address bit (36) aligned;
dcl  1 inst_address like symbol.address based (addr (address));
dcl  location fixed bin (18);				/* address of operand */

	/* Do addressing in the following situations.

	   1. Simple reference.  Use the 256K pointer directly at the symbol.
	   2. Array reference.   Use the 255K pointer if 'VLA_is_255K', else use
	   the packed pointer.  The 255K pointer is either in the A or Q or
	   stored at 'v_offset'.  Set the listing to indicate the symbol. */

	/* p is the pointer to the operand supplied.
	   s is the pointer to the symbol involved.
	   v is the pointer to the node whose address will be loaded. */

	p = addr (rands (op));
	if p -> node.node_type = array_ref_node
	then do;
	     s = addr (rands (p -> array_ref.parent));	/* symbol */
	     v = addr (rands (p -> array_ref.v_offset));	/* addressor */
	     end;
	else v, s = p;				/* symbol and addressor */

	reloc (text_pos).left_rel = v -> node.reloc;

	/* Use array name in listing. */

	if assembly_list
	then a_name (text_pos) = binary (rel (s), 18, 0);

	/* if we are dealing with the symbol direct, then use its addressing info, else
	   use the addressing info of the v_offset temp, which is in the stack */

	if v ^= s					/* not symbol */
	then loc_p = v;				/* array_ref */
	else loc_p = s;				/* symbol */

	/* if this is a non-dimensioned VLA symbol, use it's saved
	   offset information. */
	if v = s & ^s -> symbol.dimensioned
	then substr (unspec (s -> symbol.address), 1, 18) = s -> symbol.addr_hold;

	if loc_p -> symbol.large_address
	then location = loc_p -> node.address.offset + loc_p -> node.location;
	else location = loc_p -> node.address.offset;

	if v ^= s
	then address = c_a (location, 6);		/* array_ref */
	else if loc_p -> symbol.in_common | loc_p -> symbol.static
	then address = c_a (location, 5);		/* static/common */
	else address = c_a (location, 6);		/* auto */

	/* If the subscript calculated is aready in the A or the Q then we can do
	   work directly.  Else we load the packed base. */

	if s ^= v & v -> node.value_in.eaq
	then do;
	     address = "0"b;
	     if get_eaq_name ((p -> array_ref.v_offset)) = in_q
	     then do;				/* use Q addressing */
		inst_address.tag = QL_mod;		/* load segment with text ring */
		call emit_c_a ((load_base (i)), address);
		inst_address.tag = QU_mod;		/* load word number */
		call emit_c_a ((load_segment_num (i)), address);
		end;
	     else do;				/* use A addressing */
		inst_address.tag = AL_mod;		/* load segment with text ring */
		call emit_c_a ((load_base (i)), address);
		inst_address.tag = AU_mod;		/* load word */
		call emit_c_a ((load_segment_num (i)), address);
		end;
	     end;
	else do;
	     call emit_c_a ((load_packed_base (i)), address);

	     /* for symbols (not array_refs), zero the offset in the
	        symbol, since all references through the pointer just
	        created must be prN|0 references. */
	     if v = s & ^s -> symbol.dimensioned
	     then s -> symbol.address.offset = 0;
	     end;
     end base_man_load_VLA;

flush_base:
     procedure (i);

	/* Empties a pointer register prior to reuse */

dcl  i fixed binary (3);				/* Base reg to flush */
dcl  p pointer;

	if machine_state.base_regs (i).type = 1
	then do;
	     p = addr (rands (machine_state.base_regs (i).variable));
	     p -> node.address_in_base = "0"b;

	     if p -> node.stack_indirect
	     then if p -> node.node_type = temporary_node
		then if p -> temporary.not_in_storage
		     then do;

			/* Store pointer to dynamic temp */

			call base_man_store_temp (p, (i));
			return;
			end;

	     /* Restore address of aligned character string */

	     substr (unspec (p -> node.address), 1, 18) = p -> node.addr_hold;
	     p -> node.reloc = p -> node.reloc_hold;

	     end;

     end flush_base;

base_man_load_pr:
     procedure (opnd, which);

	/* Loads the address of an operand into the
	   specified register and reserves the register */

dcl  opnd fixed binary (18),				/* Index of operand */
     which fixed binary (18);				/* Register to use */

dcl  i fixed binary (3);
dcl  op fixed binary (18);
dcl  p pointer;
dcl  1 inst_address aligned like node.address;
dcl  tag_hold bit (6) aligned;
dcl  char_num_hold fixed bin (2) aligned;
dcl  VLA bit (1);

	from_base_man = "1"b;

	i = which;
	op = opnd;
	p = addr (rands (op));

	/* force addressability so we can look at the address */

	if p -> node.node_type = symbol_node
	then VLA = p -> symbol.VLA;
	else if p -> node.node_type = array_ref_node
	then VLA = addr (rands (p -> array_ref.parent)) -> symbol.VLA;
	else VLA = "0"b;

	if ^p -> node.is_addressable & ^VLA		/* VLA is always addressable */
	then call m_a (p);

	if p -> node.units = char_units
	then do;

	     /* Tag specifies a character offset in a register.  Save
	        the tag, so epp does not use it, and deal with it
	        manually below. Do the same for char_num. */

	     tag_hold = p -> node.address.tag;
	     p -> node.address.tag = "00"b3;
	     char_num_hold = p -> node.address.char_num;
	     p -> node.address.char_num = 0;
	     end;

	call flush_base (i);

	/* A very large reference can be of two types:
	   1. array-reference.  in this case the vsum of the reference is in memory
	   and is the total addressor needed by lprp.
	   2. normal-reference. in this case the address in the symbol node is
	   sufficient to address directly a base to the variable for
	   lprp.
	*/
	/* If we are dealing in char_units, then we want to avoid
	   calling m_a and setting the node.address.tag.  Therefore,
	   we use emit_c_a_var instead of emit_single. */

	if p -> node.address.base ^= bases (i) | ^p -> node.address.ext_base | p -> node.address.offset ^= 0
	     | p -> node.address.tag ^= "00"b3
	then if p -> node.units = char_units		/* characters cannot be VLA's so no code here. */
	     then call emit_c_a_var ((load_base (i)), p);
	     else if VLA
	     then call base_man_load_VLA (op, i);
	     else call emit_single ((load_base (i)), op);

	if p -> node.units = char_units
	then do;

	     /* Handle character offsets */

	     unspec (inst_address) = ext_base_on;	/* Initialize address for a9bd instructions */
	     inst_address.base = bases (i);

	     if char_num_hold ^= 0
	     then if tag_hold & "001000"b
		then do;

		     /* Have constant offset + offset in XR */

		     inst_address.tag = xr_man_add_const (binary (substr (tag_hold, 4, 3), 3), (char_num_hold));
		     call emit_c_a (a9bd, unspec (inst_address));
		     end;

		else if tag_hold ^= "00"b3
		then do;

		     /* Have constant offset + offset not in XR */

		     inst_address.tag = xr_man_load_const ((char_num_hold));
		     call emit_c_a (a9bd, unspec (inst_address));
		     inst_address.tag = tag_hold;
		     call emit_c_a (a9bd, unspec (inst_address));
		     end;

		else do;

		     /* Constant offset only */

		     inst_address.tag = xr_man_load_const ((char_num_hold));
		     call emit_c_a (a9bd, unspec (inst_address));
		     end;

	     else if tag_hold ^= "00"b3
	     then do;

		/* Variable offset only */

		inst_address.tag = tag_hold;
		call emit_c_a (a9bd, unspec (inst_address));
		end;

	     p -> node.address.tag = tag_hold;		/* Restore original tag */
	     p -> node.address.char_num = char_num_hold;	/* and char_num */

	     end;

	machine_state.base_regs (i).reserved = "1"b;	/* Lock for use in addressing */
	machine_state.base_regs (i).type = -1;		/* Unknown value */
	machine_state.base_regs (i).variable = op;	/* debugging */
	machine_state.base_regs (i).offset = 0;
	machine_state.base_regs (i).used = text_pos;

	from_base_man = "0"b;

     end base_man_load_pr;

base_man_load_pr_value:
     procedure (opnd, which);

	/* Loads the value of an operand into the specified register */

dcl  opnd fixed binary (18),				/* Index of operand */
     which fixed binary (18);				/* Register to use */

dcl  i fixed binary (3);
dcl  op fixed binary (18);
dcl  p pointer;

	op = opnd;
	p = addr (rands (op));
	i = which;

	/* load value if it is not loaded already */

	if machine_state.base_regs (i).type ^= 7 | machine_state.base_regs (i).variable ^= op
	     | machine_state.base_regs (i).offset ^= 0
	then do;

	     /* Force addressability so we can look at the address */

	     if ^p -> node.is_addressable
	     then call m_a (p);

	     call flush_base (i);

	     if substr (p -> node.address.tag, 1, 2)	/* inst addr already has a modifier */
	     then call print_message (416, op);		/* illegal address field */

	     substr (p -> node.address.tag, 1, 2) = "01"b;/* RI */

	     call emit_c_a_var ((load_base (i)), p);

	     substr (p -> node.address.tag, 1, 2) = "00"b;/* Restore tag */

	     base_regs (i).type = 7;			/* value of op in pr */
	     base_regs (i).variable = op;		/* debugging */
	     base_regs (i).offset = 0;
	     end;

	base_regs (i).used = text_pos;

     end base_man_load_pr_value;

base_man_load_large_base:
     procedure (offset, base) returns (bit (3) aligned);

	/* Loads pointer register with contents(base) + offset.
	   This routine is used to deal with address offsets >= 16K. */

dcl  (off, offset) fixed binary (18);
dcl  base bit (3) aligned;				/* MUST be sp or lp */

dcl  (i, k) fixed binary (3);
dcl  code fixed binary (18);
dcl  1 inst_address aligned like symbol.address;

	off = offset;

	if base = lp
	then code = 6;
	else code = 8;

	k = 0;

	do i = first_base to last_base;
	     if base_regs (i).type = 0
	     then k = i;
	     else if base_regs (i).type = code & base_regs (i).offset = off
	     then do;
		base_regs (i).used = text_pos;
		return (bases (i));
		end;

	     end;

	i = get_free_reg (base_regs, first_base, last_base, k);

	call flush_base (i);

	unspec (inst_address) = ext_base_on;
	inst_address.base = base;

	call emit_c_a ((load_base (i)), unspec (inst_address));
	call emit_c_a ((add_base (i)), c_a_18 (off, 1));

	base_regs (i).type = code;
	base_regs (i).variable = 0;
	base_regs (i).offset = off;
	base_regs (i).used = text_pos;

	return (bases (i));

     end base_man_load_large_base;

base_man_load_large_base_no_flush:
     procedure (offset, base, which) returns (bit (3) aligned);

	/* Analogous to base_man_load_large_base, except that the
	   register to load is specified and flush_base is not called,
	   to avoid recursion. */

dcl  offset fixed binary (18);
dcl  base bit (3) aligned;
dcl  which fixed binary (3);

dcl  1 inst_address like node.address;

	unspec (inst_address) = ext_base_on;
	inst_address.base = base;

	call emit_c_a ((load_base (which)), unspec (inst_address));
	call emit_c_a ((add_base (which)), c_a_18 ((offset), 1));

	if base = sp
	then base_regs (which).type = 8;
	else base_regs (which).type = 6;
	base_regs (which).variable = 0;
	base_regs (which).offset = offset;
	base_regs (which).used = text_pos;

	return (bases (which));

     end base_man_load_large_base_no_flush;

base_man_load_arg_ptr:
     procedure () returns (bit (3) aligned);

	/* Loads a pointer register with a pointer to the argument list. */

dcl  (i, k) fixed binary (3);
dcl  n fixed binary (18);

	k = 0;

	do i = first_base to last_base;
	     if machine_state.base_regs (i).type = 0
	     then k = i;
	     else if machine_state.base_regs (i).type = 5
	     then do;
		machine_state.base_regs (i).used = text_pos;
		return (bases (i));
		end;
	     end;

	i = get_free_reg (machine_state.base_regs, first_base, last_base, k);
	call flush_base (i);

	if cs -> subprogram.subprogram_type = main_program
	then n = arg_ptr;
	else n = cs -> subprogram.entry_info + 2;

	call emit_c_a ((load_base (i)), c_a (n, 4));

	machine_state.base_regs (i).type = 5;
	machine_state.base_regs (i).variable = 0;
	machine_state.base_regs (i).used = text_pos;
	machine_state.base_regs (i).offset = 0;

	return (bases (i));

     end base_man_load_arg_ptr;

base_man_load_desc_ptr:
     procedure () returns (bit (3) aligned);

	/* Loads any pointer register with a pointer to the argument
	   descriptor list. */

dcl  (i, k) fixed binary (3);
dcl  n fixed binary (18);

	k = 0;

	do i = first_base to last_base;
	     if base_regs (i).type = 0
	     then k = i;
	     else if base_regs (i).type = 9
	     then do;
		base_regs (i).used = text_pos;
		return (bases (i));
		end;
	     end;

	i = get_free_reg (base_regs, first_base, last_base, k);
	call flush_base (i);

	if cs -> subprogram.subprogram_type = main_program
	then n = descriptor_ptr;
	else n = cs -> subprogram.entry_info + 4;

	call emit_c_a ((load_base (i)), c_a (n, 4));

	base_regs (i).type = 9;
	base_regs (i).variable = 0;
	base_regs (i).used = text_pos;
	base_regs (i).offset = 0;

	return (bases (i));

     end base_man_load_desc_ptr;

base_man_store_temp:
     procedure (temp_ptr, which);

	/* Emits code to store a pointer temporary.  Note that since
	   this routine is called from flush_base, we must be careful
	   to not use any pointer registers which may require flushing
	   to avoid recursion. */

dcl  (temp_ptr, tp) pointer;
dcl  (which, temp_reg) fixed binary (3);

dcl  1 inst_address like node.address;
dcl  (free_reg, large_base_reg, i) fixed binary (3);
dcl  was_reserved bit (1) aligned;

	tp = temp_ptr;
	temp_reg = which;

	unspec (inst_address) = tp -> temporary.addr_hold;
	inst_address.ext_base = "1"b;

	tp -> temporary.not_in_storage = "0"b;

	/* If the temp is simply addressable, just store it */

	if ^tp -> temporary.large_address
	then do;
	     call emit_c_a ((store_base (temp_reg)), unspec (inst_address));
	     return;
	     end;

	/* See if there is a pointer register which already points to
	   the correct region for the large address. */

	free_reg, large_base_reg = 0;
	do i = first_base to last_base while (large_base_reg = 0);
	     if base_regs (i).type = 0
	     then free_reg = i;
	     else if base_regs (i).type = 8 & base_regs (i).offset = tp -> temporary.location
	     then large_base_reg = i;
	     end;

	/* If there is such a pointer register, use it */

	if large_base_reg > 0
	then do;
	     base_regs (large_base_reg).used = text_pos;
	     inst_address.base = bases (large_base_reg);
	     call emit_c_a ((store_base (temp_reg)), unspec (inst_address));
	     return;
	     end;

	/* Try to get an empty register, or any register which does
	   not require flushing.  Avoid the register we are trying to
	   store by pretending it is reserved for the moment. */

	was_reserved = base_regs (temp_reg).reserved;
	base_regs (temp_reg).reserved = "1"b;
	i = get_free_reg (base_regs, first_base, last_base, free_reg);
	base_regs (temp_reg).reserved = was_reserved;

	if base_regs (i).type ^= 1
	then do;
	     inst_address.base = base_man_load_large_base_no_flush ((tp -> temporary.location), sp, i);
	     call emit_c_a ((store_base (temp_reg)), unspec (inst_address));
	     return;
	     end;

	/* Try to use pr4 as a last resort. */

	i = which_base (4);

	if base_regs (i).reserved
	then call print_message (467);		/* Sigh */

	inst_address.base = base_man_load_large_base_no_flush ((tp -> temporary.location), sp, i);
	call emit_c_a ((store_base (temp_reg)), unspec (inst_address));

	call emit_zero (getlp);			/* Restore pr4 */

     end base_man_store_temp;

/**** INDEX REGISTER MANAGEMENT ****/

	/* The contents of the index registers are determined by the
	   value of the type field as follows:
	   (v = variable field)

	   -1		UNKNOWN
	   0		EMPTY
	   1		value v
	   2		constant value c
	*/

xr_man_load_any_xr:
     procedure (pt) returns (bit (6) aligned);

	/* Loads an operand into any index register */

dcl  pt pointer;					/* Points at value to be loaded */

dcl  p pointer;
dcl  v fixed binary (18);
dcl  i fixed binary (3);

	p = pt;
	v = fixed (rel (p), 18);

	if p -> node.value_in.x
	then do;
	     do i = first_index to last_index;
		if index_regs (i).type = 1
		then if index_regs (i).variable = v
		     then do;
			machine_state.index_regs (i).used = text_pos;
			return ("001"b || bit (i, 3));
			end;
		end;
	     call print_message (430, v);
	     return ("00"b3);
	     end;

	i = get_free_reg (index_regs, first_index, last_index, 0);

	call flush_xr (i);

	call use_ind;

	if p -> node.value_in.eaq
	then call emit_c_a (eax0 + i, c_a (0, 1));

	else do;
	     if p -> node.not_in_storage
	     then call print_message (419, v);

	     if ^p -> node.is_addressable
	     then call m_a_except_xreg (p);

	     call emit_c_a_var (lxl0 + i, p);
	     end;

	index_regs (i).type = 1;
	index_regs (i).variable = v;
	p -> node.value_in.x = "1"b;
	index_regs (i).used = text_pos;
	machine_state.value_in_xr = "1"b;

	return ("001"b || bit (i, 3));

     end xr_man_load_any_xr;

flush_xr:
     procedure (which);

	/* Empties an index register prior to reuse */

dcl  which fixed binary (3);				/* Index reg to flush */

dcl  i fixed bin (18);
dcl  p ptr;

	if index_regs (which).type ^= 1
	then return;

	i = which;

	p = addr (rands (index_regs (i).variable));
	p -> node.value_in.x = "0"b;

	/* the value has not been previously stored, so do so */

	if p -> node.not_in_storage
	then do;
	     call emit_temp_store (sxl0 + i, index_regs (i).variable);
	     end;

     end flush_xr;

xr_man_load_const:
     procedure (csize) returns (bit (6) aligned);

	/* Loads a constant into any index register */

dcl  csize fixed binary (18);				/* Constant to be loaded */

dcl  (i, k) fixed binary (3);
dcl  c fixed binary (18);

	c = csize;

	if const_in_xr (c, first_index, k)
	then do;
	     index_regs (k).used = text_pos;
	     return ("001"b || bit (binary (k, 3), 3));
	     end;

	i = get_free_reg (index_regs, first_index, last_index, k);

	call flush_xr (i);

	call use_ind;

	call emit_c_a (eax0 + i, c_a_18 (c, 0));

	index_regs (i).type = 2;
	index_regs (i).variable = c;
	index_regs (i).used = text_pos;

	return ("001"b || bit (i, 3));

     end xr_man_load_const;

const_in_xr:
     procedure (value, first_xr, xr_num) returns (bit (1) aligned);

	/* Procedure to find xr containing a particular constant value
	   or find an empty xr. */

dcl  value fixed binary (18);				/* Constant value required in xr */
dcl  first_xr fixed binary (18);			/* First xr to be checked */
dcl  xr_num fixed binary (3);				/* Xr containing value or a free xr */
dcl  c fixed binary (18);
dcl  i fixed binary (3);

	xr_num = 0;				/* initialize - no xr found */
	c = value;

	do i = first_xr to last_index;
	     if index_regs (i).type = 0
	     then xr_num = i;
	     else if index_regs (i).type = 2
	     then if index_regs (i).variable = c
		then do;
		     xr_num = i;
		     return ("1"b);
		     end;
	     end;

	return ("0"b);

     end const_in_xr;

xr_man_add_const:
     procedure (which, csize) returns (bit (6) aligned);

	/* Add a constant to the value in an index register */

dcl  which fixed binary (3);
dcl  csize fixed binary (18);

dcl  c fixed binary (18);
dcl  (i, j) fixed binary (3);
dcl  address bit (36) aligned;


	i = which;
	c = csize;
	address = (36)"0"b;
	substr (address, 1, 18) = bit (c, 18);		/* Set offset portion */
	substr (address, 31, 6) = bit (fixed (i + 8, 6), 6);
						/* Set tag portion */

	j = get_free_reg (machine_state.index_regs, first_index, last_index, 0);

	call flush_xr (j);
	call use_ind ();
	call emit_c_a (eax0 + j, address);		/* Emit eax_m const,n */

	/* Although the index register we just loaded is not really empty,
	   we will say it is because xr_man does not have the notion
	   of a variable plus a constant in a register.  This will only work
	   if the next instruction emitted uses the index register and
	   does not call for some other index register to be loaded. */

	machine_state.index_regs (j).type = 0;		/* Empty */
	machine_state.index_regs (j).variable = 0;
	machine_state.index_regs (j).used = text_pos;

	return (bit (fixed (j + 8, 6), 6));		/* Return XR modifier */

     end xr_man_add_const;

/**** GENERAL REGISTER MANAGEMENT ****/

reserve_regs:
     procedure (what);

	/* Reserves index and base registers */

dcl  (what, reserve) bit (14) aligned;			/* Mask specifying which regs to reserve */
dcl  i fixed binary (18);
dcl  j fixed binary (3);
dcl  length builtin;

	reserve = what;

	do i = 1 to length (reserve);
	     if substr (reserve, i, 1)
	     then if i <= 8
		then do;
		     j = i - 1;
		     call flush_xr (j);
		     machine_state.index_regs (j).reserved = "1"b;
		     machine_state.index_regs (j).type = -1;
						/* Unknown value */
		     end;
		else do;
		     j = i - 8;
		     call flush_base (j);
		     machine_state.base_regs (j).reserved = "1"b;
		     machine_state.base_regs (j).type = -1;
						/* Unknown value */
		     machine_state.base_regs (j).variable = 0;
						/* debugging */
		     machine_state.base_regs (j).offset = 0;
		     end;
	     end;

     end reserve_regs;

free_regs:
     procedure ();

	/* Frees all reserved registers (index, base, and eaq)
	   reloading pr4 if necessary */

dcl  i fixed binary (18);

	machine_state.eaq (*).reserved = "0"b;

	do i = escape_index to last_index;
	     if machine_state.index_regs (i).reserved
	     then do;
		machine_state.index_regs (i).reserved = "0"b;
		if machine_state.index_regs (i).type < 0/* Unknown? */
		then machine_state.index_regs (i).type = 0;
		end;
	     end;

	do i = first_base to last_base;		/* Normal bases */
	     if machine_state.base_regs (i).reserved
	     then do;
		machine_state.base_regs (i).reserved = "0"b;
		if machine_state.base_regs (i).type < 0 /* Unknown? */
		then machine_state.base_regs (i).type = 0;
		end;
	     end;

	/* Bug 508: Reload pr4 with linkage ptr value only if necessary */

	i = which_base (4);
	if machine_state.base_regs (i).reserved & machine_state.base_regs (i).type ^= 6
	then do;
	     call emit_zero (getlp);                            /* Emit code to restore pr4 */
	     machine_state.base_regs (i).type = 6; /* linkage ptr */
	     end;

	machine_state.base_regs (i).reserved = "0"b;

     end free_regs;

reset_regs:
     procedure ();

	/* Resets all regs to their initial state */

dcl  i fixed binary (3);

	if machine_state.address_in_base
	then do i = first_base to last_base;
		call flush_base (i);
		end;

	call reset_eaq (IND);			/* Reset indicators */
	call reset_eaq (EAQ);			/* Reset A, Q, EAQ */

	if machine_state.value_in_xr
	then do i = first_index to last_index;
		if index_regs (i).type = 1
		then if index_regs (i).variable ^= 0
		     then call flush_xr (i);
		end;

	unspec (machine_state) = "0"b;

	machine_state.base_regs (which_base (4)).type = 6;/* linkage_ptr */

     end reset_regs;

flush_ref:
     procedure (index);

	/* Flush complex reference.  This is an aliased reference.  Here we find the
	   paren header node and scan through the equivalenced list to find another
	   node which has "value_in.eaq" set.  Cause that node to be flushed too. */

dcl  (index, i) fixed binary (18);
dcl  p ptr;

	call flush_simple_ref (index);		/* Flush primary */
	p = addr (rands (index));
	if p -> node.node_type = symbol_node
	then if (p -> symbol.in_equiv_stmnt) & (p -> symbol.parent ^= 0)
	     then do;
		p = addr (rands (p -> symbol.parent));	/* point to list */
		do i = p -> header.first_element repeat p -> symbol.next_member while (i ^= 0);
		     p = addr (rands (i));
		     if p -> symbol.value_in.eaq
		     then call flush_simple_ref (i);
		     end;
		end;



flush_simple_ref:
     procedure (temp_index);

	/* Removes an item from the machine state */

dcl  (temp, temp_index) fixed binary (18);
dcl  p pointer;
dcl  (i, r) fixed binary (18);

	temp = temp_index;

	p = addr (rands (temp));

	if p -> node.value_in.eaq
	then do;
	     do r = 1 to hbound (machine_state.eaq, 1);	/* A, Q, EAQ, IND */
		do i = 1 by 1 while (i <= machine_state.eaq (r).number);
		     if machine_state.eaq (r).variable (i) = temp
		     then do;
			do i = i + 1 by 1 while (i <= machine_state.eaq (r).number);
			     machine_state.eaq (r).variable (i - 1) = machine_state.eaq (r).variable (i);
			     end;

			machine_state.eaq (r).number = machine_state.eaq (r).number - 1;
			if machine_state.eaq (r).number = 0
			then machine_state.eaq (r).name = 0;

			end;
		     end;
		end;
	     end;

	if p -> node.value_in.x
	then do i = first_index repeat i + 1 while (i <= last_index);
		if index_regs (i).type > 0
		then if index_regs (i).variable = temp
		     then index_regs (i).type = 0;
		end;

	string (p -> node.value_in) = "0"b;

     end flush_simple_ref;
     end flush_ref;

flush_addr:
     procedure (temp_index);

	/* Removes the address of an item from the machine state */

dcl  (temp, temp_index) fixed binary (18);
dcl  p pointer;
dcl  i fixed binary (18);

	temp = temp_index;
	p = addr (rands (temp));

	if p -> node.address_in_base
	then do;
	     do i = first_base repeat i + 1 while (i <= last_base);
		if base_regs (i).type = 1
		then if base_regs (i).variable = temp
		     then base_regs (i).type = 0;
		end;
	     p -> node.address_in_base = "0"b;
	     end;

     end flush_addr;

lock_tag_register:
     procedure (tag);

	/* Reserves the register specified by the address tag */

dcl  (tag, t) bit (6) aligned;

	t = tag;

	/* if XR modification, lock index reg for use in addressing */
	if substr (t, 3, 1)			
	then machine_state.index_regs (fixed (t, 6) - 8).reserved = "1"b;
	else if t = QL_mod
	then call lock_eaq (Q);
	else if t = AL_mod
	then call lock_eaq (A);

     end lock_tag_register;

/**** EAQ MANAGEMENT ****/

eaq_man_load_a_or_q:
     procedure (pt) returns (bit (6) aligned);

	/* Loads an integer value into the A or Q. */

dcl  (pt, p) pointer;
dcl  v fixed binary (18);
dcl  name fixed binary (18);

	p = pt;
	v = fixed (rel (p), 18);

	/* Take care of subscripts in the Q */

	if p -> node.dont_update			/* really node.subs_in_q */
	then return (QL_mod);

	/* If the operand is already in the A or Q, no need to load it */

	if p -> node.value_in.eaq
	then do;
	     name = get_eaq_name (v);
	     if name = in_q
	     then return (QL_mod);
	     else if name = in_ia
	     then return (AL_mod);
	     end;

	/* Must load the operand.  If one of the A or Q is reserved, we must
	   load the other one.  If neither is reserved, we favor the Q. */

	if machine_state.eaq (A).reserved & machine_state.eaq (Q).reserved
	then call print_message (449);		/* Oops */

	if machine_state.eaq (A).reserved
	then name = in_q;
	else if machine_state.eaq (Q).reserved
	then name = in_ia;
	else if machine_state.eaq (Q).number > 0 & machine_state.eaq (A).number = 0 & machine_state.eaq (IND).number = 0
	then name = in_ia;
	else name = in_q;

	call use_eaq (v);

	if ^p -> node.is_addressable
	then call m_a_except_xreg (p);

	call emit_c_a_var (load_inst (name), p);

	machine_state.indicators_valid = eaq_name_to_reg (name);

	call in_reg (v, name);

	if name = in_q
	then return (QL_mod);
	else return (AL_mod);

     end eaq_man_load_a_or_q;

get_eaq_name:
     procedure (opnd) returns (fixed binary (18));

	/* Search the eaq state for opnd and return its eaq name */

dcl  (op, opnd) fixed binary (18);
dcl  (r, v) fixed binary (18);

	op = opnd;

	if ^addr (rands (op)) -> node.value_in.eaq
	then return (0);				/* Don't even look */

	do r = 1 to hbound (machine_state.eaq, 1);

	     do v = 1 to machine_state.eaq (r).number;

		if machine_state.eaq (r).variable (v) = op
		then return (machine_state.eaq (r).name);

		end;

	     end;

	/* If we get here, the node has value_in.eaq on but the operand
	   is not in the eaq. */

	call print_message (450);
	return (0);

     end get_eaq_name;

in_reg:
     procedure (v, name);

	/* Puts an operand in an eaq register */

dcl  (var, v) fixed binary (18),
     name fixed binary (18),
     regno fixed binary (18);

	var = v;
	regno = eaq_name_to_reg (name);

	call reset (regno);

	machine_state.rounded = "0"b;

	machine_state.eaq (regno).number = 1;
	machine_state.eaq (regno).variable (1) = var;
	machine_state.eaq (regno).name = name;

	if machine_state.eaq (regno).name = in_ind
	then do;
	     call print_message (420, var);
	     return;
	     end;

	addr (rands (var)) -> node.value_in.eaq = "1"b;

	if regno = IND
	then machine_state.indicators_valid = 0;
	else machine_state.indicators_valid = regno;

     end in_reg;

also_in_reg:
     procedure (v, name);

	/* Appends an operand to the eaq register state */

dcl  (var, v) fixed binary (18),
     (i, regno) fixed binary (18),
     name fixed binary (18),
     p pointer;

	regno = eaq_name_to_reg (name);
	var = v;

	addr (rands (var)) -> node.value_in.eaq = "1"b;

	if machine_state.eaq (regno).number < hbound (machine_state.eaq.variable, 2)
	then do;
	     machine_state.eaq (regno).number = machine_state.eaq (regno).number + 1;
	     machine_state.eaq (regno).variable (machine_state.eaq (regno).number) = var;
	     return;
	     end;
	else do i = 1 to hbound (machine_state.eaq.variable, 2);

		p = addr (rands (machine_state.eaq (regno).variable (i)));

		if p -> node.node_type ^= temporary_node
		then do;
		     machine_state.eaq (regno).variable (i) = var;
		     p -> node.dont_update,		/* really node.subs_in_q */
			p -> node.value_in.eaq = "0"b;
		     return;
		     end;
		end;

	call print_message (448);

     end also_in_reg;

use_eaq:
     procedure (array_name);

	/* Empties the eaq, saving temporaries in storage and indexes
	   of array references in index registers */

dcl  array_name fixed binary (18);
dcl  p pointer;
dcl  own_sub pointer;
dcl  bit6 bit (6) aligned;
dcl  mac fixed binary (18);
dcl  (r, i) fixed binary (18);

	own_sub = null ();

	if array_name > 0
	then if addr (rands (array_name)) -> node.node_type = array_ref_node
	     then if addr (rands (array_name)) -> array_ref.ref_count = 1
		then if addr (rands (array_name)) -> array_ref.variable_offset
		     then if addr (rands (array_name)) -> array_ref.data_type ^= cmpx_mode
			then if addr (rands (addr (rands (array_name)) -> array_ref.v_offset)) -> node.value_in.eaq
			     then own_sub = addr (rands (addr (rands (array_name)) -> array_ref.v_offset));

	if machine_state.eaq (IND).number > 0
	then call use_ind ();

	do r = 1 to hbound (machine_state.eaq, 1) - 1;	/* A, Q, EAQ */

	     do i = 1 to machine_state.eaq (r).number;

		p = addr (rands (machine_state.eaq (r).variable (i)));
		if p -> node.node_type = temporary_node
		then do;
		     if p -> temporary.dont_update	/* really temporary.subs_in_q */
		     then if p = own_sub & p -> temporary.ref_count = 1 & r = Q
			then ;
			else do;
			     bit6 = xr_man_load_any_xr (p);
			     p -> temporary.dont_update = "0"b;
						/* really temporary.subs_in_q */
			     end;

		     else if p -> temporary.not_in_storage & ^p -> temporary.value_in.x
		     then do;
			if ^do_rounding | machine_state.rounded
			then mac = store_no_round_inst (machine_state.eaq (r).name);
			else mac = store_inst (machine_state.eaq (r).name);
			call emit_temp_store (mac, (machine_state.eaq (r).variable (i)));
			end;
		     end;

		if p -> node.node_type = symbol_node & p ^= own_sub
		then p -> symbol.dont_update = "0"b;	/* really symbol.subs_in_q */

		p -> node.value_in.eaq = "0"b;
		end;

	     machine_state.eaq (r).name = 0;		/* mark register empty */
	     machine_state.eaq (r).number = 0;

	     end;

	machine_state.rounded = "0"b;

     end use_eaq;

use_ind:
     procedure ();

	/* Empties the indicators, saving logical values in the
	   A register if necessary */
	/* NOTE if anything in EAQ then it too has to go. */

dcl  var fixed binary (18);

	if machine_state.eaq (IND).number > 0
	then if addr (rands (machine_state.eaq (IND).variable (1))) -> node.not_in_storage
	     then do;
		call save_logical_temps ();
		call emit_zero ((ind_to_a (machine_state.eaq (IND).name - in_ind)));

		/* Update machine state */

		var = machine_state.eaq (IND).variable (1);
		call reset_eaq (IND);
		machine_state.eaq (A).number = 1;
		machine_state.eaq (A).name = in_a;
		machine_state.eaq (A).variable (1) = var;
		addr (rands (var)) -> node.value_in.eaq = "1"b;
		end;

	machine_state.indicators_valid = 0;

save_logical_temps:
     procedure ();

	/* This procedure is analogous to use_eaq, but is used to save
	   temps in the A and EAQ registers only.  It is called by use_ind to
	   avoid recursion with use_eaq. */

dcl  (mac, i) fixed binary (18);
dcl  bit6 bit (6) aligned;
dcl  p ptr;

	do i = 1 by 1 while (i <= machine_state.eaq (A).number);

	     if addr (rands (machine_state.eaq (A).variable (i))) -> node.not_in_storage
	     then call emit_temp_store (sta, (machine_state.eaq (A).variable (i)));
	     end;

	/* The following code is more or less taken from use_eaq. */

	do i = 1 to machine_state.eaq (EAQ).number;
	     p = addr (rands (machine_state.eaq (EAQ).variable (i)));
	     if p -> node.node_type = temporary_node
	     then do;
		if p -> temporary.dont_update		/* really temporary.subs_in_q */
		then do;
		     bit6 = xr_man_load_any_xr (p);
		     p -> temporary.dont_update = "0"b; /* really temporary.subs_in_q */
		     end;

		else if p -> temporary.not_in_storage & ^p -> temporary.value_in.x
		then do;
		     if ^do_rounding | machine_state.rounded
		     then mac = store_no_round_inst (machine_state.eaq (EAQ).name);
		     else mac = store_inst (machine_state.eaq (EAQ).name);
		     call emit_temp_store (mac, (machine_state.eaq (EAQ).variable (i)));
		     end;
		end;

	     if p -> node.node_type = symbol_node
	     then p -> symbol.dont_update = "0"b;	/* really symbol.subs_in_q */

	     p -> node.value_in.eaq = "0"b;
	     end;

	call reset_eaq (A);

     end save_logical_temps;
     end use_ind;

load:
     procedure (vp, name);

dcl  vp fixed binary (18),				/* Operand to be loaded */
     name fixed binary (18);				/* Eaq_name to be loaded */
dcl  (var, eaq_name, regno, i) fixed binary (18);

	eaq_name = name;

	if eaq_name <= 0 | eaq_name > in_ind
	then do;
	     call print_message (421, vp);
	     return;
	     end;

	var = vp;

	/* If we are trying to load some register other than the
	   indicators, and there are logical values in the indicators,
	   we must get the indicators into the A now, before the load
	   takes place.  This is a kludge, and a holdover from the old
	   EAQ management scheme. */

	if eaq_name ^= in_ind & machine_state.eaq (IND).number > 0
	then call use_ind ();

	if addr (rands (var)) -> node.value_in.eaq
	then do;

	     /* Search the machine state; the operand may already be
	        in the desired register. */

	     do regno = 1 to hbound (machine_state.eaq, 1);
						/* A, Q, EAQ, IND */

		do i = 1 by 1 while (i <= machine_state.eaq (regno).number);
		     if var = machine_state.eaq (regno).variable (i)
		     then do;

			if eaq_name = in_tq | eaq_name = in_q
			then if machine_state.eaq (regno).name = in_tq | machine_state.eaq (regno).name = in_q
			     then machine_state.eaq (regno).name = eaq_name;

			if eaq_name = machine_state.eaq (regno).name
			then return;

			if eaq_name = in_ind
			then do;
			     if regno = IND
			     then return;

			     if machine_state.eaq (regno).name = in_a
			     then if machine_state.indicators_valid = A
				then do;
				     call flush_ref (var);
				     call in_reg (var, tnz);
				     return;
				     end;
			     end;

			else if eaq_name = in_a & regno = IND
			     & addr (rands (var)) -> node.node_type = temporary_node
			then do;
			     call use_ind ();
			     machine_state.indicators_valid = A;
			     return;
			     end;

			end;

		     end;

		end;

	     end;

	call use_eaq (var);

	call emit_single ((load_inst (eaq_name)), var);

	if eaq_name = in_ind
	then eaq_name = tnz;

	call in_reg (var, eaq_name);

	machine_state.rounded = "1"b;

     end load;

check_negative:
     procedure (opnd) returns (bit (1) aligned);

	/* return true if operand is "negative" for its data type */

dcl  opnd fixed bin (18);
dcl  (p, val_ptr) ptr;
dcl  based_integer fixed bin (35) aligned based;
dcl  based_real float bin (27) aligned based;
dcl  1 based_double aligned based,
       2 based_dp float bin (63) unaligned;

	if opnd < 0				/* a count */
	then return (opnd < -bias);

	p = addr (rands (opnd));
	if p -> node.data_type < 1 | p -> node.data_type > 4
	then return ("0"b);				/* cannot be neg if not numeric */
	val_ptr = addr (p -> constant.value);
	goto return_neg (p -> node.data_type);

return_neg (1):					/* INTEGER */
	return (val_ptr -> based_integer < 0);

return_neg (2):					/* REAL */
return_neg (4):					/* COMPLEX */
	return (val_ptr -> based_real < 0.0);

return_neg (3):					/* DOUBLE PRECISION */
	return (val_ptr -> based_dp < 0.0);

     end check_negative;

reset_eaq:
     procedure (reg_number);

	/* Resets the specified eaq register to the empty state */

dcl  reg_number fixed binary (18);

	if reg_number ^= IND
	then call reset (EAQ);			/* Only IND does not affect EAQ */

	if reg_number = EAQ
	then do;					/* EAQ affects both A and Q */
	     call reset (A);
	     call reset (Q);
	     end;
	else call reset (reg_number);

	machine_state.rounded = "0"b;

	return;

     end reset_eaq;

reset:
     procedure (r);

	/* Resets a single eaq register */

dcl  (i, r, regno) fixed binary (18);
dcl  p pointer;

	regno = r;

	do i = 1 by 1 while (i <= machine_state.eaq (regno).number);
	     p = addr (rands (machine_state.eaq (regno).variable (i)));
	     p -> node.dont_update,			/* really node.subs_in_q */
		p -> node.value_in.eaq = "0"b;
	     end;

	machine_state.eaq (regno).name = 0;
	machine_state.eaq (regno).number = 0;

     end reset;

store:
     procedure (vp, name, update_flag);

dcl  vp fixed binary (18);				/* Operand to be stored */
dcl  name fixed binary (18);				/* Eaq_name from which storing takes place */
dcl  update_flag fixed binary (18);			/* =0 if store should update ms */

dcl  (var, eaq_name, inst_number, reg) fixed binary (18);
dcl  v pointer;

	eaq_name = name;
	var = vp;
	v = addr (rands (var));

	if do_rounding & ^machine_state.rounded
	then inst_number = store_inst (eaq_name);
	else inst_number = store_no_round_inst (eaq_name);

	call emit_single (inst_number, var);

	if eaq_name = in_q
	then if string (v -> node.value_in)
	     then call flush_ref (var);

	if update_flag = 0
	then do;
	     v -> node.not_in_storage = "0"b;
	     reg = eaq_name_to_reg (eaq_name);
	     if eaq_name = machine_state.eaq (reg).name
	     then call also_in_reg (var, eaq_name);
	     else call in_reg (var, eaq_name);
	     end;

     end store;

lock_eaq:
     procedure (reg);

	/* Locks an EAQ register for use in addressing */

dcl  reg fixed binary (18);

	machine_state.eaq (reg).reserved = "1"b;
     end lock_eaq;

/**** REL CONSTANTS ****/

alloc_label:
     procedure (stack_sub, value);

dcl  stack_sub fixed binary (18),			/* Subscript of operand in stack */
     value fixed binary (18);				/* Value to be assigned to operand */

dcl  p pointer;

	p = addr (rands (stack (stack_sub)));

	p -> label.location = value;
	p -> label.allocated = "1"b;

     end alloc_label;

/**** BUILD PROFILE ENTRY ****/

build_profile_entry:
     procedure ();

	/* modified to produce both long and short profile. */

	if generate_long_profile
	then do;					/* long_profile */
	     call emit_operator_call (long_profile);

	     /* emit internal static relative offset to long_profile_header */

	     text_halfs (text_pos).left = profile_start;
	     reloc (text_pos).left_rel = rc_is18;

	     /* emit relative offset from long_profile_header to entry */

	     text_halfs (text_pos).right = profile_pos;
	     reloc (text_pos).right_rel = rc_a;
	     text_pos = text_pos + 1;
	     profile_pos = profile_pos + size (long_profile_entry);
	     end;
	else do;					/* short profile */
	     call use_ind;				/* aos sets indicators */
	     call emit_c_a (aos, c_a (profile_pos + 1, 5));
	     reloc (text_pos - 1).left_rel = rc_is15;

	     profile_pos = profile_pos + size (profile_entry);
	     end;

     end build_profile_entry;

setup_message_structure:
     procedure ();

	/* Sets up message_structure for print & error macros */

dcl  i fixed binary (18);

	message_structure.message_number = left;
	message_structure.number_of_operands = macro_dt_inst (imac).data_type;

	do i = 1 to message_structure.number_of_operands;
	     imac = imac + 1;

	     left = macro_instruction (imac).left;
	     if left = 0
	     then do;

		/* have an operand as argument */

		message_structure.is_string (i) = "0"b;
		message_structure.operand_index (i) = stack (get_operand ((macro_instruction (imac).operand)));
		end;

	     else do;

		/* have a string as argument */

		message_structure.is_string (i) = "1"b;
		message_structure.string_length (i) = macro_dt_inst (imac).data_type;
		message_structure.string_ptr (i) = addrel (mac_base, macro_instruction (imac).left);
		end;
	     end;

     end setup_message_structure;

create_integer_constant:
     procedure (value) returns (fixed binary (18));

dcl  value fixed binary (35) aligned;
dcl  bvalue bit (72) aligned;

	bvalue = unspec (value);
	return (create_constant (int_mode, bvalue));

     end create_integer_constant;

/**** SUBSCRIPTING CODE ****/

next_subscript:
     procedure ();

	/* Generates code to check the range of the subscript
	   at the top of the stack.  The following stack format
	   is expected:

	   array variable
	   number of subscripts
	   sub1
	   sub2
	   .
	   .
	   .
	   subn
	*/

dcl  (d, p, s) pointer;
dcl  (isub, csub, bound) fixed binary (18);

	s = addr (rands (stack (base)));
	d = addr (rands (s -> symbol.dimension));
	p = addr (rands (stack (top)));
	isub = top - base - 1;

	/* Do compile time range checking if the subscript is constant */

	if p -> node.operand_type = constant_type
	then do;
	     unspec (csub) = p -> constant.value;

	     if ^d -> dimension.v_bound (isub).lower
	     then if csub < d -> dimension.lower_bound (isub)
		then call print_message (422, stack (top), stack (base));
						/* Warning if lower bound exceeded */

	     if ^d -> dimension.v_bound (isub).upper
	     then if csub > d -> dimension.upper_bound (isub)
		then if s -> symbol.parameter
		     then do;

			/* Warning if upper bound is exceeded and array is a parameter */

			call print_message (431, stack (top), stack (base));
			end;
		     else do;

			/* Severity 3 error if upper bound is exceeded and array is not a parameter */

			call print_message (422, stack (top), stack (base));
			call signal_error ();
			return;
			end;

	     end;

	/* Emit code to check subscript range (if necessary) */

	if cs -> subprogram.options.subscriptrange
	then if (isub < d -> dimension.number_of_dims | ^d -> dimension.assumed_size)
	     then if (p -> node.operand_type ^= constant_type | string (d -> dimension.v_bound (isub)) ^= "00"b)
		then do;

		     if d -> dimension.v_bound (isub).lower
		     then bound = d -> dimension.lower_bound (isub);
		     else bound = create_integer_constant ((d -> dimension.lower_bound (isub)));
		     call copy (bound);

		     if d -> dimension.v_bound (isub).upper
		     then bound = d -> dimension.upper_bound (isub);
		     else bound = create_integer_constant ((d -> dimension.upper_bound (isub)));
		     call copy (bound);

		     call interpreter_proc (check_subscript, r1);
r1:
		     end;

     end next_subscript;

finish_subscript:
     procedure ();

	/* Puts out code to compute offset of subscripted reference
	   and creates an array ref.  A similar stack format
	   to that expected by next_subscript is expected */

dcl  (a, d, p, s) pointer;
dcl  csum fixed bin (24);
dcl  (vsum, i, a_ref, zsub, cvalue) fixed binary (18);
dcl  (first_time, have_vsum, code_emitted, char_77_mode, big_offset) bit (1) aligned;


	s = addr (rands (stack (base)));
	d = addr (rands (s -> symbol.dimension));

	first_time = "1"b;
	code_emitted, have_vsum, big_offset = "0"b;
	char_77_mode = (s -> symbol.units = char_units);
	csum = 0;
	zsub = base + 1;

	do i = d -> dimension.number_of_dims to 1 by -1;
	     if ^first_time
	     then do;

		/* multiply by dimension.size (i) */

		if string (d -> dimension.v_bound (i)) = "00"b
		then do;
		     csum = csum * d -> dimension.size (i);
		     if have_vsum
		     then call mult (d -> dimension.size (i) - bias);
		     end;

		else do;
		     if csum ^= 0
		     then do;
			if have_vsum
			then call add_csum;
			else do;
			     have_vsum = "1"b;
			     vsum = create_integer_constant ((csum));
			     end;

			csum = 0;
			end;

		     if have_vsum			/* PREVIOUSLY FORGOTTEN */
		     then call mult ((d -> dimension.size (i)));
		     end;
		end;

	     first_time = "0"b;

	     /* add ith subscript */

	     p = addr (rands (stack (zsub + i)));

	     if p -> node.operand_type = constant_type
	     then do;
		unspec (cvalue) = p -> constant.value;
		csum = csum + cvalue;
		end;
	     else do;
		if have_vsum
		then call add ((stack (zsub + i)));
		else do;
		     have_vsum = "1"b;
		     vsum = stack (zsub + i);
		     end;
		end;
	     end;

	/* multiply by element size */

	if s -> symbol.v_length ^= 0
	then do;
	     if csum ^= 0
	     then do;
		if have_vsum
		then call add_csum;
		else do;
		     have_vsum = "1"b;
		     vsum = create_integer_constant ((csum));
		     end;
		csum = 0;
		end;
	     if have_vsum
	     then call mult ((s -> symbol.v_length));
	     else do;
		vsum = s -> symbol.v_length;
		have_vsum = "1"b;
		end;
	     end;
	else if s -> symbol.element_size ^= 1
	then do;
	     csum = csum * s -> symbol.element_size;
	     if have_vsum
	     then call mult (s -> symbol.element_size - bias);
	     end;

	/* subtract the virtual origin */

	if ^d -> dimension.variable_virtual_origin
	then csum = csum - d -> dimension.virtual_origin;
	else do;

	     /* we must have_vsum since one of  the checked
	        bounds must be a variable */

	     call sub ((d -> dimension.virtual_origin));
	     end;

	/* If we are addressing in units of characters, the variable
	   offset may not fit in an index register (big_offset = "1"b).
	   For vsum to be placed in an index register, we must have
	   0 <= vsum <= 262143.  Since we know 0 <= csum + vsum <=
	   array_size - 1, we can derive these two conditions for the
	   use of index registers:
	   csum <= 0  AND  array_size - csum <= 262144
	   If either of these conditions is not met, vsum cannot be kept
	   in an index register. */

	if char_77_mode
	then if have_vsum
	     then if s -> symbol.variable_extents | s -> symbol.star_extents | csum > 0
		     | d -> dimension.array_size - csum > 262144
		then big_offset = "1"b;

	/* if symbol has large address, add into csum */

	if s -> symbol.large_address & ^s -> symbol.VLA
	then if char_77_mode
	     then csum = csum + (s -> symbol.location * chars_per_word);
	     else csum = csum + s -> symbol.location;

	/* create and initialize an array_ref node */

	a_ref = create_array_ref ((stack (base)));
	a = addr (rands (a_ref));
	a -> array_ref.large_offset = big_offset;

	/* Include address of parent in csum */

	if char_77_mode
	then do;
	     csum = csum + a -> array_ref.address.char_num;
	     a -> array_ref.address.char_num = mod (csum, chars_per_word);
	     if (csum < 0) & (a -> array_ref.address.char_num ^= 0)
	     then csum = divide (csum, chars_per_word, 18, 0) - 1;
	     else csum = divide (csum, chars_per_word, 18, 0);
	     end;

	if s -> symbol.VLA
	then do;

	     /* add the packed pointer to the subscript, and add the offset from the pointer
	        to the start of the array. */

	     a -> array_ref.large_offset, big_offset = "1"b;
	     csum = csum + s -> symbol.offset;		/* Add offset in block */

	     /* If code emitted, then subscript is in Q already.  So add a possible constant
	        offset, then add the packed pointer to the storage section and leave in Q. */

	     if code_emitted
	     then do;
		call add_csum;			/* add offset */
		call add_pointer (stack (base));	/* add pointer */
		end;

	     /* no code emitted - may have to load vsum then add offset and pointer. */

	     else if have_vsum			/* vsum exists */
	     then do;
		call add_csum;			/* add offset */
		call add_pointer (stack (base));	/* add pointer */
		end;

	     /* load constant and add pointer. */

	     else do;
		call load_vsum;			/* forces constant gen and load */
		call add_pointer (stack (base));
		end;
	     csum = 0;

	     if ^VLA_is_256K			/* Convert logical address to packed ptr. */
	     then do;
		unspec (inst_address) = ""b;
		inst_address.offset = VLA_words_per_seg;
		inst_address.ext_base = "1"b;
		call emit_c_a ((div), unspec (inst_address));
						/* seg to Q, word to A */
		call emit_single (als, 18 - bias);	/* word to high A */
		call emit_single (llr, 18 - bias);	/* full packed pointer in Q */
		end;

	     have_vsum = "1"b;
	     end;
	else csum = csum + a -> array_ref.address.offset;

	if have_vsum
	then call finalize_vsum ();
	else a -> array_ref.is_addressable = ^a -> array_ref.needs_pointer;

	call set_address_offset (a, (csum), (s -> symbol.element_size), (s -> symbol.units));

	/* If the symbol node had large_addressing then the base in the array_ref
	   node will be incorrect if the array ref is a ^large_address.  Therefore
	   or large_address flags to cause base re-evaluation if required. */

	a -> array_ref.large_address = a -> array_ref.large_address | s -> symbol.large_address;

	a -> array_ref.has_address = "1"b;


	/* push the final result on top of the stack */

	call push (a_ref);

	return;

add_csum:
     proc ();

	/* add csum, either through creating a constant, or through simple instruction. */
	if ^code_emitted				/* load vsum if needed */
	then call load_vsum;

	if csum = 0
	then return;

	if csum > max_fixed_bin_18 | csum < 0
	then call add (create_integer_constant ((csum)));
	else call add (csum - bias);
	return;
     end add_csum;


add_pointer:
     proc (op);

dcl  op fixed bin (18);

dcl  d ptr;
dcl  s ptr;
dcl  v ptr;

	if ^code_emitted
	then call load_vsum;

	s = addr (rands (op));
	d = addr (rands (s -> symbol.dimension));
	v = addr (rands (d -> dimension.VLA_base_addressor));
	call emit_c_a_var (adfx1, v);
	call reset_eaq (Q);				/* Value has been modified */

     end add_pointer;

make_substring:
     entry ();

	/* Emits code to compute the length and offset of a substring
	   reference.  The following stack format is expected:

	   substring parent (symbol or array_ref)
	   index of first character in substring
	   index of last character in substring

	   An array_ref node representing the substring reference is
	   filled in and pushed on the operand stack. */

dcl  (p1, p2, v) pointer;
dcl  (v_length, indx1_constant, indx2_constant) bit (1) aligned;
dcl  (substr_size, csize) fixed binary (18);
dcl  xr fixed binary (3);
dcl  (indx1_value, indx2_value) fixed binary (35);

	/* Get pointers to operands */

	p = addr (rands (stack (base)));
	p1 = addr (rands (stack (base + 1)));
	p2 = addr (rands (stack (base + 2)));

	if p1 -> node.operand_type = constant_type
	then do;
	     indx1_constant = "1"b;
	     indx1_value = addr (p1 -> constant.value) -> int_image;
	     end;
	else indx1_constant = "0"b;

	if p2 -> node.operand_type = constant_type
	then do;
	     indx2_constant = "1"b;
	     indx2_value = addr (p2 -> constant.value) -> int_image;
	     end;
	else indx2_constant = "0"b;

	/* Get address information from parent */

	if p -> node.node_type = array_ref_node
	then do;
	     have_vsum = p -> array_ref.variable_offset;
	     vsum = p -> array_ref.v_offset;
	     big_offset = p -> array_ref.large_offset;
	     s = addr (rands (p -> array_ref.parent));
	     v = addr (rands (vsum));

	     /* If temporary.dont_update was set for vsum, then it will
	        not have been stored.  We must either store it from the
	        index register which now holds it, or prevent it from
	        getting into an index register if it is still in the Q.
	        Note that storing from the index register only works
	        because EIS instruction offsets in index registers must
	        be positive. */

	     if v -> node.node_type = temporary_node
	     then if v -> temporary.not_in_storage
		then if v -> temporary.value_in.x
		     then do;
			do xr = first_index to last_index while (index_regs (xr).variable ^= vsum);
			     end;
			call emit_temp_store (stz, vsum);
			call emit_temp_store (sxl0 + xr, vsum);
			end;
		     else v -> temporary.dont_update = "0"b;
	     end;
	else do;
	     have_vsum = "0"b;
	     vsum = 0;
	     big_offset = "0"b;
	     s = p;
	     end;

	/* Do stringrange checking */

	csize = get_char_size (p);

	if cs -> subprogram.options.stringrange
	then if ^indx1_constant | ^indx2_constant
	     then do;
		call push (csize);
		call copy ((stack (base + 1)));
		call copy ((stack (base + 2)));
		call interpreter_proc (check_stringrange, r4);
r4:
		end;

	/* Check constant indices */

	if indx1_constant
	then if indx1_value <= 0 | (csize < 0 & indx1_value > csize + bias)
	     then do;
		call print_message (457, stack (base + 1), stack (base));
		go to substring_error;
		end;

	if indx2_constant
	then if indx2_value <= 0 | (csize < 0 & indx2_value > csize + bias)
	     then do;
		call print_message (457, stack (base + 2), stack (base));
		go to substring_error;
		end;

	/* Compute the length of the substring */

	if indx1_constant
	then if indx2_constant
	     then do;

		/* Both indices are constant */

		v_length = "0"b;
		substr_size = indx2_value - indx1_value + 1;
		if substr_size <= 0
		then do;
		     call print_message (460, stack (base));
		     go to substring_error;
		     end;
		end;

	     else do;

		/* Only the first index is constant */

		v_length = "1"b;
		if indx1_value = 1 & addr (rands (stack (base + 2))) -> node.node_type ^= array_ref_node
		then do;
		     code_emitted = "0"b;
		     substr_size = stack (base + 2);
		     if addr (rands (substr_size)) -> node.node_type = temporary_node
		     then addr (rands (substr_size)) -> temporary.ref_count =
			     addr (rands (substr_size)) -> temporary.ref_count + 1;

		     end;
		else do;
		     code_emitted = "1"b;
		     call load ((stack (base + 2)), in_q);
		     if indx1_value ^= 1
		     then call sub (indx1_value - 1 - bias);
		     end;
		end;

	else if indx2_constant
	then do;

	     /* Only the second index is constant */

	     v_length, code_emitted = "1"b;
	     call load (indx2_value + 1 - bias, in_q);
	     call sub ((stack (base + 1)));
	     end;

	else do;

	     /* Neither index is constant */

	     v_length, code_emitted = "1"b;
	     call load ((stack (base + 2)), in_q);
	     call sub ((stack (base + 1)));
	     call add (1 - bias);
	     end;

	/* If code was emitted to compute the length, assign a temp */

	if v_length & code_emitted
	then do;
	     substr_size = assign_temp (int_mode);
	     call in_reg (substr_size, in_q);
	     end;

	/* Now compute the offset of the substring reference */

	code_emitted = "0"b;

	csum = p -> node.address.char_num + (chars_per_word * p -> node.address.offset);

	/* Figure first character index into the offset */

	if indx1_constant
	then csum = csum + indx1_value - 1;
	else do;
	     if have_vsum
	     then call add ((stack (base + 1)));
	     else do;
		have_vsum = "1"b;
		vsum = stack (base + 1);
		end;
	     csum = csum - 1;
	     end;

	/* If parent has a large address, add in the base location */

	if p -> node.large_address
	then csum = csum + (chars_per_word * p -> node.location);

	/* Make sure the variable offset fits in an index register.
	   This is only an issue if we take a substring of an array
	   element (since the maximum offset into a scalar is
	   max_char_length - 1), there is a variable offset, and the
	   substring offset is not purely constant. */

	if p -> node.node_type = array_ref_node
	then if ^s -> symbol.variable_extents & ^s -> symbol.star_extents
	     then if have_vsum
		then if ^indx1_constant
		     then do;

			/* Derive the total constant offset due to the combined
			   substring and subscript operations. */

			cvalue = s -> symbol.address.offset;
			if s -> symbol.large_address
			then cvalue = cvalue + s -> symbol.location;
			cvalue = chars_per_word * cvalue + s -> symbol.address.char_num;
			cvalue = csum - cvalue;

			big_offset =
			     (cvalue > 0)
			     | (addr (rands (s -> symbol.dimension)) -> dimension.array_size - cvalue > 262144);
			end;

	/* Create and initialize an array_ref node */

	a_ref = create_array_ref (fixed (rel (s), 18));
	a = addr (rands (a_ref));

	a -> array_ref.variable_length = v_length;
	a -> array_ref.length = substr_size;
	a -> array_ref.large_offset = big_offset;

	/* Convert constant offset back to words */

	a -> array_ref.address.char_num = mod (csum, chars_per_word);
	if (csum < 0) & (a -> array_ref.address.char_num ^= 0)
	then csum = divide (csum, chars_per_word, 18, 0) - 1;
	else csum = divide (csum, chars_per_word, 18, 0);

	if have_vsum
	then call finalize_vsum ();
	else a -> array_ref.is_addressable = ^a -> array_ref.needs_pointer;

	if s -> node.node_type = symbol_node
	then do;

	     /* If the symbol node had large_addressing then the base in the array_ref
	        node will be incorrect if the array ref is a ^large_address.  Therefore
	        or large_address flags to cause base re-evaluation if required. */

	     call set_address_offset (a, (csum), (s -> symbol.element_size), (s -> symbol.units));
	     a -> array_ref.large_address = a -> array_ref.large_address | s -> symbol.large_address;
	     end;
	else do;
	     a -> node.offset = csum;
	     if s -> node.node_type = char_constant_node
	     then a -> node.units = char_units;		/* prevent m_a making a pointer */
	     end;

	a -> array_ref.has_address = "1"b;

	call push (a_ref);

	return;


substring_error:
	imac = fixed (rel (addr (fort_cg_macros_$error_macro)), 18);
	go to loop;

get_param_array_size:
     entry (sym);

	/* Figures out the size of parameter arrays of star or
	   expression extents.  Emits code to compute the array_size
	   and virtual_origin, and initializes the array descriptor. */

dcl  sym pointer;

dcl  (virtual_origin, array_size, c_virtual_origin, c_multiplier, ndims, c_mult_offset, desc) fixed binary (18);
dcl  v_multiplier bit (1) aligned;

	s = sym;

	if ^s -> symbol.variable_extents & ^s -> symbol.star_extents
	then return;

	desc = s -> symbol.hash_chain;

	/* If there is a descriptor template node, but it has not been
	   assigned storage, then it is only needed to build the entry
	   point definitions and we can ignore it. */

	if desc ^= 0
	then if ^addr (rands (desc)) -> symbol.allocated
	     then desc = 0;

	d = addr (rands (s -> symbol.dimension));

	ndims = d -> dimension.number_of_dims;

	/* Allocate array_size */

	if ^d -> dimension.has_array_size
	then do;
	     array_size, d -> dimension.array_size = create_var (1);
	     addr (rands (array_size)) -> symbol.data_type = int_mode;
	     d -> dimension.has_array_size = "1"b;
	     d -> dimension.variable_array_size = "1"b;
	     end;
	else array_size = d -> dimension.array_size;

	/* Copy descriptor template to automatic storage, but only
	   if get_param_char_size has not done so already. */

	if desc ^= 0 & s -> symbol.v_length = 0
	then call copy_array_desc_template (s);

	/* The rest of the code concerns itself with computing
	   the array_size and virtual origin, and with initializing
	   the bound information in the descriptor. */

	/* For some 1 dimensional arrays, we can emit a more efficient
	   code sequence than is possible in the general case. */

	if ndims = 1 & desc = 0 & s -> symbol.v_length = 0 & ^d -> dimension.v_bound (1).lower
	then do;
	     d -> dimension.virtual_origin = s -> symbol.element_size * d -> dimension.lower_bound (1);
	     d -> dimension.has_virtual_origin = "1"b;
	     d -> dimension.variable_virtual_origin = "0"b;

	     code_emitted = "1"b;
	     call compute_dimension_size (1);

	     if ^d -> dimension.assumed_size
	     then do;
		call load ((d -> dimension.size (1)), in_q);
		call mult (s -> symbol.element_size - bias);
		call store (array_size, in_q, 0);
		end;
	     return;
	     end;

	/* The more general code sequence must be used. */

	code_emitted = "0"b;
	virtual_origin = 0;
	c_virtual_origin = 0;

	if s -> symbol.v_length = 0
	then do;
	     c_multiplier = s -> symbol.element_size;
	     v_multiplier = "0"b;
	     end;
	else do;
	     c_multiplier = 1;
	     v_multiplier = "1"b;
	     end;

	if s -> symbol.units = char_units & desc ^= 0 & v_multiplier & shared_globals.user_options.table
	then c_mult_offset = ndims * 3;		/* possible variable dims */
	else c_mult_offset = 0;			/* constant dims */

	do i = 1 to ndims;

	     /* This section of code accumulates the virtual origin
	        and array size as long as the dimension bounds remain
	        constant.  When a variable bound is encountered, code
	        is emitted to initialize the virtual origin and array
	        size to the accumulated partial result. */

	     /* If we start with a variable multiplier (i.e. symbol.v_length
	        ^= 0 then ALL MULTIPLIERS MUST BE CALCULATED, not just the
	        LAST one. */

	     if ^code_emitted
	     then do;
		if string (d -> dimension.v_bound (i)) = "00"b & i < ndims & ^v_multiplier
		then do;
		     c_virtual_origin = c_virtual_origin + c_multiplier * d -> dimension.lower_bound (i);
		     c_multiplier = c_multiplier * d -> dimension.size (i);
		     end;
		else do;
		     code_emitted = "1"b;
		     if i = ndims & ^v_multiplier & ^d -> dimension.v_bound (i).lower
		     then do;

			/* The virtual origin is constant. */

			d -> dimension.virtual_origin =
			     c_virtual_origin + c_multiplier * d -> dimension.lower_bound (i);
			d -> dimension.has_virtual_origin = "1"b;
			d -> dimension.variable_virtual_origin = "0"b;
			end;
		     else do;

			/* The virtual origin is variable. */

			if ^d -> dimension.has_virtual_origin
			then do;
			     virtual_origin, d -> dimension.virtual_origin = create_var (1);
			     addr (rands (virtual_origin)) -> symbol.data_type = int_mode;
			     d -> dimension.has_virtual_origin = "1"b;
			     d -> dimension.variable_virtual_origin = "1"b;
			     end;
			else virtual_origin = d -> dimension.virtual_origin;

			/* Initialize the virtual origin. */

			if c_virtual_origin = 0
			then call emit_single (stz, virtual_origin);
			else do;
			     if v_multiplier
			     then do;
				call load ((s -> symbol.v_length), in_q);
				call mult (c_virtual_origin - bias);
				end;
			     else call load (create_integer_constant ((c_virtual_origin)), in_q);
			     call store (virtual_origin, in_q, 0);
			     end;
			end;

		     /* Initialize the array size. */

		     if v_multiplier
		     then do;
			call load ((s -> symbol.v_length), in_q);
			call mult (c_multiplier - bias);
			end;
		     else call load (create_integer_constant ((c_multiplier)), in_q);

		     /* The array size is left in the Q register. */

		     call in_reg (array_size, in_q);
		     end;
		end;

	     /* The following block of code is executed once a variable
	        array bound has been encountered. */

	     if code_emitted
	     then do;

		/* Store the multiplier for this dimension in the
		   descriptor if appropriate. */
		/* If we will generate a runtime symbol entry and we have
		   star_extents in a character string then save the byte
		   length in the runtime multiplier and the bit length will
		   be concocted later and stored in the true descriptor. */

		if desc ^= 0 & v_multiplier
		then if c_mult_offset ^= 0
		     then call emit_single_with_inc (store_inst (in_q), desc, c_mult_offset + i);
		     else call emit_single_with_inc (store_inst (in_q), desc, 3 * i);

		/* Store the array size if necessary.  If the lower
		   bound is known to be 1, we do not need to store the
		   array size because (1) multiplying it by 1 to compute
		   the virtual origin doesn't change it and (2) the Q
		   is left intact by compute_dimension_size in this
		   particular case. */

		if d -> dimension.v_bound (i).lower | d -> dimension.lower_bound (i) ^= 1
		then call store (array_size, in_q, 1);

		/* Update the virtual origin. */

		if virtual_origin ^= 0
		then do;
		     if d -> dimension.v_bound (i).lower
		     then call mult ((d -> dimension.lower_bound (i)));
		     else if d -> dimension.lower_bound (i) ^= 1
		     then call mult (d -> dimension.lower_bound (i) - bias);

		     call emit_single (asq, virtual_origin);
		     end;

		/* Compute the size of this dimension, and store
		   the bounds in the array's descriptor. */

		call compute_dimension_size (i);

		/* Update the array size to include the size of this
		   dimension.  One of two code sequences is chosen
		   depending on what is in the Q register.  This need
		   not be done if this is the last dimension of an
		   assumed size array. */

		if (i < ndims) | ^d -> dimension.assumed_size
		then do;
		     if get_eaq_name (array_size) = in_q
		     then do;

			/* Multiply by dimension size. */

			call load (array_size, in_q);
			if string (d -> dimension.v_bound (i)) = "00"b
			then call mult (d -> dimension.size (i) - bias);
			else call mult ((d -> dimension.size (i)));
			end;
		     else do;

			/* Multiply by array size. */

			if string (d -> dimension.v_bound (i)) = "00"b
			then call load (create_integer_constant ((d -> dimension.size (i))), in_q);
			else call load ((d -> dimension.size (i)), in_q);
			call mult (array_size);
			end;

		     /* The updated array_size is left in the Q. */

		     call in_reg (array_size, in_q);
		     end;

		/* If bounds are variable, so is multiplier. */

		v_multiplier = v_multiplier | (string (d -> dimension.v_bound (i)) ^= "00"b);
		end;

	     end;

	/* Store the array size. */

	if ^d -> dimension.assumed_size
	then call store (array_size, in_q, 1);

	/* If the array is in character units and there is a descriptor,
	   the multipliers must be converted from characters to bits. */

	if s -> symbol.units = char_units & desc ^= 0
	then do;
	     if s -> symbol.v_length ^= 0
	     then i = 1;
	     else i = 2;

	     do i = i to ndims;
		if c_mult_offset ^= 0
		then call emit_single_with_inc (load_inst (in_q), desc, c_mult_offset + i);
		else call emit_single_with_inc (load_inst (in_q), desc, 3 * i);
		call emit_single (mpy, bits_per_char - bias);
		call emit_single_with_inc (store_inst (in_q), desc, 3 * i);
		end;

	     call reset_eaq (Q);
	     end;

	return;

compute_dimension_size:
     procedure (dim_no);

	/* Emits code to compute the number of elements in a given
	   dimension.  Also stores variable array bounds in the array
	   descriptor. */

dcl  dim_no fixed binary (18);
dcl  i fixed binary (3);

	i = dim_no;

	/* If this is the last dimension of an assumed size array,
	   the dimension size must not be calculated.  Simply copy
	   the lower bound to the descriptor if necessary. */

	if (i = ndims) & d -> dimension.assumed_size
	then do;
	     if (desc ^= 0) & d -> dimension.v_bound (i).lower
	     then do;
		call emit_single (load_inst (in_a), (d -> dimension.lower_bound (i)));
		call emit_single_with_inc (store_inst (in_a), desc, 3 * i - 2);
		end;
	     return;
	     end;

	/* The dimension size must be computed. */

	if string (d -> dimension.v_bound (i)) = "01"b
	then do;
	     if d -> dimension.lower_bound (i) = 1
	     then do;

		/* Lower bound is the constant 1.  The dimension size
		   is already correct.  If the upper bound needs to be
		   copied to the descriptor, we use the A register, as
		   the main loop in get_param_array_size depends on
		   the Q register remaining intact. */

		if desc ^= 0
		then do;
		     call emit_single (load_inst (in_a), (d -> dimension.upper_bound (i)));
		     call emit_single_with_inc (store_inst (in_a), desc, 3 * i - 1);
		     end;
		end;
	     else do;

		/* Lower bound is some constant other than 1. */

		call load ((d -> dimension.upper_bound (i)), in_q);
		if desc ^= 0
		then call emit_single_with_inc (store_inst (in_q), desc, 3 * i - 1);
		call sub (d -> dimension.lower_bound (i) - 1 - bias);
		call store ((d -> dimension.size (i)), in_q, 0);
		end;
	     end;

	else if string (d -> dimension.v_bound (i)) = "10"b
	then do;
	     if desc ^= 0
	     then do;
		call emit_single (load_inst (in_a), (d -> dimension.lower_bound (i)));
		call emit_single_with_inc (store_inst (in_a), desc, 3 * i - 2);
		end;
	     call load (create_integer_constant (1 + d -> dimension.upper_bound (i)), in_q);
	     call sub ((d -> dimension.lower_bound (i)));
	     call store ((d -> dimension.size (i)), in_q, 0);
	     end;

	else if string (d -> dimension.v_bound (i)) = "11"b
	then do;
	     if desc ^= 0
	     then do;
		call emit_single (load_inst (in_a), (d -> dimension.lower_bound (i)));
		call emit_single_with_inc (store_inst (in_a), desc, 3 * i - 2);
		end;
	     call load ((d -> dimension.upper_bound (i)), in_q);
	     if desc ^= 0
	     then call emit_single_with_inc (store_inst (in_q), desc, 3 * i - 1);
	     call sub ((d -> dimension.lower_bound (i)));
	     call add (1 - bias);
	     call store ((d -> dimension.size (i)), in_q, 0);
	     end;

     end compute_dimension_size;

finalize_vsum:
     procedure ();

	/* Ensures that the variable offset is addressable or
	   in a register.  Called by finish_subscript and
	   make_substring. Uses the following variables globally:
	   code_emitted, vsum, a, big_offset */

dcl  v pointer;
dcl  i fixed binary (18);

	if code_emitted
	then do;
	     vsum = assign_temp (int_mode);
	     v = addr (rands (vsum));
	     call in_reg (vsum, in_q);
	     end;
	else do;
	     v = addr (rands (vsum));
	     if v -> node.node_type = temporary_node
	     then v -> temporary.ref_count = v -> temporary.ref_count + 1;
	     end;

	a -> array_ref.variable_offset = "1"b;
	a -> array_ref.v_offset = vsum;

	/* If the single subscript is an array reference,
	   get it into a register by temporarily pretending
	   it is the associated temp.  (explicitly call m_a
	   to prevent recursion.) */

	if v -> node.node_type = array_ref_node
	then do;
	     if big_offset
	     then do;
		i = get_eaq_name (vsum);
		if i ^= in_ia & i ^= in_q
		then call m_a (v);
		a -> array_ref.address.tag = eaq_man_load_a_or_q (v);
		if a -> array_ref.address.tag = QL_mod
		then i = in_q;
		else i = in_ia;
		vsum = assign_temp (int_mode);
		a -> array_ref.v_offset = vsum;
		call flush_ref (fixed (rel (v), 18));
		call in_reg (vsum, i);
		end;

	     else do;
		if ^v -> node.value_in.x
		then call m_a (v);
		a -> array_ref.address.tag = xr_man_load_any_xr (v);
		i = fixed (a -> array_ref.address.tag, 18) - 8;
		vsum = assign_temp (int_mode);
		a -> array_ref.v_offset, index_regs (i).variable = vsum;
		addr (rands (vsum)) -> temporary.value_in.x = "1"b;
		v -> node.value_in.x = "0"b;
		end;
	     end;

	else if ^big_offset
	then if get_eaq_name (vsum) = in_q
	     then v -> node.dont_update = "1"b;		/* really node.subs_in_q */

     end finalize_vsum;

	/* Miscellaneous code emission procedures use by finish_subscript, make_substring, and get_param_array_size */

add:
     procedure (op);

	/* Emits code to add op to the variable sum in the Q */

dcl  (mac, op) fixed binary (18);

	mac = adfx1;
	go to join;


sub:
     entry (op);

	/* Emits code to subtract op from the variable sum in the Q */

	mac = sbfx1;

join:
	if ^code_emitted
	then call load_vsum;

	if op + bias < 0
	then call emit_single (mac, create_integer_constant (op + bias));
	else call emit_single (mac, op);

	call reset_eaq (Q);				/* Value has been modified */

     end add;

load_vsum:
     procedure ();

	/* Emits code to load the variable sum into the Q */

	if ^have_vsum
	then do;
	     have_vsum = "1"b;
	     vsum = create_integer_constant ((csum));
	     csum = 0;
	     end;

	call load (vsum, in_q);
	call use_eaq (0);
	code_emitted = "1"b;

     end load_vsum;

mult:
     procedure (op);

	/* Emits code to multiply the variable sum by op */

dcl  op fixed binary (18);

	if ^code_emitted
	then call load_vsum;

	/* Bug 513: Use an indirect addressing code for referencing, when (op  + bias)
	   is greater than 262143 which is the largest 18 bit value */

	if (op + bias < 0) | (op + bias > 262143)
	then call copy (create_integer_constant (op + bias));
	else call copy (op);
	call interpreter_proc (subscript_mpy, r2);
r2:
	call reset_eaq (Q);				/* Value has been modified */

     end mult;

     end finish_subscript;

start_subscript:
     procedure ();

	/* Checks number of subscripts */

dcl  (s, d) pointer;

	s = addr (rands (stack (base)));
	d = addr (rands (s -> symbol.dimension));

	if d -> dimension.number_of_dims ^= stack (base + 1) + bias
	then do;
	     call print_message (423, stack (base));
	     call signal_error;
	     end;

     end start_subscript;

signal_error:
     procedure ();

	/* Aborts from a subscript or FLD builtin error */

	imac = fixed (rel (addr (fort_cg_macros_$abort_list)), 18);
	go to loop;

     end signal_error;

/**** ARRAY REF MANAGEMENT ****/

create_array_ref:
     procedure (sym) returns (fixed binary (18));

	/* Creates an array_ref node with sym as its parent */

dcl  (a_ref, sym, csize) fixed binary (18);
dcl  (a, s) pointer;

	if next_free_array_ref = 0
	then do;
	     a_ref = create_node (array_ref_node, size (array_ref));
	     a = addr (rands (a_ref));
	     end;
	else do;
	     a_ref = next_free_array_ref;
	     a = addr (rands (a_ref));
	     next_free_array_ref = a -> array_ref.next;
	     unspec (a -> array_ref) = "0"b;
	     a -> array_ref.node_type = array_ref_node;
	     end;


	a -> array_ref.parent = sym;
	s = addr (rands (sym));
	a -> array_ref.operand_type = array_ref_type;
	a -> array_ref.data_type = s -> symbol.data_type;
	a -> array_ref.units = s -> symbol.units;
	if s -> symbol.data_type = char_mode
	then do;
	     csize = get_char_size (s);
	     if csize > 0
	     then do;
		a -> array_ref.variable_length = "1"b;
		a -> array_ref.length = csize;
		end;
	     else a -> array_ref.length = csize + bias;
	     end;
	a -> array_ref.needs_pointer = s -> symbol.needs_pointer;
	unspec (a -> array_ref.address) = unspec (s -> symbol.address);
	a -> array_ref.reloc = s -> symbol.reloc;
	a -> array_ref.ref_count = 1;

	return (a_ref);

     end create_array_ref;

free_array_ref:
     procedure (pt);

	/* Frees an array_ref.  The variable length and offset
	   temporaries are also freed if necessary. */

dcl  (pt, p, t) pointer;
dcl  (a_ref, n) fixed binary (18);

	p = pt;
	a_ref = fixed (rel (p), 18);

	if p -> array_ref.ref_count < 0
	then do;
	     call print_message (415, a_ref);
	     return;
	     end;

	if p -> array_ref.v_offset ^= 0
	then do;
	     t = addr (rands (p -> array_ref.v_offset));
	     if t -> node.node_type = temporary_node
	     then do;
		n, t -> temporary.ref_count = t -> temporary.ref_count - 1;
		if n <= 0
		then call free_temp (t);
		end;
	     end;

	if p -> array_ref.variable_length
	then do;
	     t = addr (rands (p -> array_ref.length));
	     if t -> node.node_type = temporary_node
	     then do;
		n, t -> temporary.ref_count = t -> temporary.ref_count - 1;
		if n <= 0
		then call free_temp (t);
		end;
	     end;

	call flush_ref (a_ref);
	call flush_addr (a_ref);

	p -> array_ref.next = next_free_array_ref;
	next_free_array_ref = a_ref;

     end free_array_ref;

/**** CONCATENATION CODE ****/

start_cat:
     procedure (reallocated);

	/* Expects the stack to contain only the two concatenation operands.
	   Computes the length of the result (emitting code if necessary),
	   and allocates the temporary for the result (which is pushed on
	   the stack.)  The parameter reallocated is turned on in the case
	   where the first operand of the concatenation is the most recently
	   allocated dynamic temporary.  (In this case the result temporary
	   is merely an extension of the first operand). */

dcl  reallocated bit (1) aligned;			/* (Output) */

dcl  op (2) fixed binary (18);			/* The two operands */
dcl  csize (2) fixed binary (18);			/* Actual lengths of operands */
dcl  result fixed binary (18);			/* Result temporary (pushed on operand stack) */
dcl  asize (2) fixed binary (18);			/* Number of characters allocated to operand */
dcl  tv_offset fixed binary (14);			/* Operator offset */
dcl  i fixed binary;				/* Loop variable */

	/* Get current and allocated lengths of operands */

	do i = 1 to 2;
	     op (i) = stack (base + i - 1);
	     call get_cat_lengths (op (i), csize (i), asize (i));
	     end;

	/* If neither operand was of star extent, allocate a normal character
	   temporary and compute its length */

	if (asize (1) > 0) & (asize (2) > 0)
	then do;
	     result = assign_char_temp (asize (1) + asize (2));
	     call compute_cat_result_length (result, csize);
	     call push (result);
	     reallocated = "0"b;
	     return;
	     end;

	/* At least one of the operands was of star extent */

	reallocated = (op (1) = machine_state.last_dynamic_temp);

	if reallocated
	then tv_offset = reallocate_char_string;
	else tv_offset = allocate_char_string;

	result = assign_dynamic_temp ();
	call compute_cat_result_length (result, csize);
	call allocate_dynamic_temp (result, tv_offset);
	call push (result);

     end start_cat;

continue_cat:
     procedure ();

	/* Adds the length of the first concatenation operand into the
	   address of the result.  Expects the stack to be as start_cat
	   left it (opnd1, opnd2, result). */

dcl  (p, p1) pointer;				/* To result, opnd1 */
dcl  csize fixed binary (18);				/* Length of opnd1 */
dcl  off fixed binary (18);				/* Total char offset */
dcl  lreg bit (6) aligned;				/* Register length tag */

	p = addr (rands (stack (top)));
	p1 = addr (rands (stack (base)));

	/* Save the address of the result temporary in the global variable
	   saved_cat_address.  It will be restored when the concatenation
	   is finished by finish_cat. */

	saved_cat_address = p -> temporary.address;

	csize = get_char_size (p1);
	if csize < 0
	then do;

	     /* Length of opnd1 is constant.  Try adding length to the
	        address of the result, avoiding large address.  Note that
	        opnd1 cannot be a dynamic temp in this case. */

	     off = (p -> temporary.address.offset * chars_per_word) + (csize + bias);
	     if off < 16384 * chars_per_word
	     then do;
		p -> temporary.address.char_num = mod (off, chars_per_word);
		if (off < 0) & (p -> temporary.address.char_num ^= 0)
		then p -> temporary.address.offset = divide (off, chars_per_word, 18, 0) - 1;
		else p -> temporary.address.offset = divide (off, chars_per_word, 18, 0);
		return;
		end;

	     lreg = xr_man_load_const (csize + bias);
	     end;

	else if get_eaq_name (csize) > 0
	then lreg = eaq_man_load_a_or_q (addr (rands (csize)));
	else lreg = xr_man_load_any_xr (addr (rands (csize)));

	call lock_tag_register (lreg);

	p -> temporary.address.tag = p -> temporary.address.tag | lreg;

     end continue_cat;

finish_cat:
     procedure ();

	/* Restores the original address of the result temporary.  The same
	   stack format as continue_cat is expected. */

	addr (rands (stack (top))) -> temporary.address = saved_cat_address;

	call free_regs ();

     end finish_cat;

get_cat_lengths:
     procedure (opnd, actual_length, alloc_length);

	/* Gets the actual length and the allocated length for one operand.
	   The actual length is either a count or an operand offset as
	   returned by get_char_size.  The allocated length is a positive
	   integer (the length in characters), or zero if the operand is
	   of star extent. */

dcl  opnd fixed binary (18);				/* Operand offset */
dcl  actual_length fixed binary (18);			/* (Output) Real char length */
dcl  alloc_length fixed binary (18);			/* (Output) Length for allocation */

dcl  p pointer;					/* To operand */
dcl  csize fixed binary (18);				/* Character length */
dcl  psize fixed binary (18);				/* Parent's length */

	p = addr (rands (opnd));

	csize = get_char_size (p);
	if csize < 0
	then do;

	     /* Constant length */

	     actual_length = csize;
	     alloc_length = csize + bias;
	     return;
	     end;

	/* If the operand is not of constant length, but is a substring or
	   array reference whose parent is of constant length, return the
	   parent's length as the length for allocation. */

	if p -> node.node_type = array_ref_node
	then do;
	     psize = get_char_size (addr (rands (p -> array_ref.parent)));
	     if psize < 0
	     then do;
		actual_length = csize;
		alloc_length = psize + bias;
		return;
		end;
	     end;

	/* If the operand is a variable length temporary that is not of
	   star extent, use the allocated length of the temporary as the
	   length for allocation. */

	else if p -> node.node_type = temporary_node
	then if ^p -> temporary.stack_indirect
	     then do;
		actual_length = csize;
		alloc_length = p -> temporary.size * chars_per_word;
		return;
		end;

	/* The operand must be of star extent. */

	actual_length = csize;
	alloc_length = 0;

     end get_cat_lengths;

compute_cat_result_length:
     procedure (result, op_length);

	/* Computes the length of concatenation result, emitting code if
	   necessary, and updates the result temporary appropriately. */

dcl  result fixed binary (18);			/* Result temp */
dcl  op_length (2) fixed binary (18);			/* Operand lengths */

dcl  p pointer;					/* To result temp */
dcl  temp fixed binary (18);				/* Length temp */
dcl  op1 fixed binary (18);				/* Length of first opnd */

	p = addr (rands (result));

	if (op_length (1) < 0) & (op_length (2) < 0)
	then do;

	     /* Both operands are of constant length */

	     p -> temporary.length = (op_length (1) + bias) + (op_length (2) + bias);
	     p -> temporary.variable_length = "0"b;
	     return;
	     end;

	/* At least one of the operand lengths is non-constant.  Emit code
	   to compute the length of the result. */

	if op_length (1) < 0
	then op1 = create_integer_constant (op_length (1) + bias);
	else op1 = op_length (1);

	call load (op1, in_q);
	call use_eaq (0);
	call emit_single (adfx1, (op_length (2)));

	temp, p -> temporary.length = assign_temp (int_mode);
	call in_reg (temp, in_q);

	p -> temporary.variable_length = "1"b;

     end compute_cat_result_length;

/**** DESCRIPTOR RELATED CODE ****/

get_param_char_size:
     procedure (sym, arg_no);

	/* This procedure generates code to extract the length of a
	   star extent character string from the argument list
	   descriptor and store it in the symbol.v_length variable
	   allocated by the parse.  Also, if the character string is
	   passed as an argument and requires a descriptor of its own,
	   code is generated to initialize the automatic descriptor
	   from the template in the text section and to fill in the
	   length field. */

dcl  (s, sym) pointer;
dcl  arg_no fixed binary (18);

dcl  desc fixed binary (18);
dcl  mask fixed binary (18);				/* mask off high bits of Q register */

	s = sym;
	desc = s -> symbol.hash_chain;

	/* If there is a descriptor template node, but it has not been
	   assigned storage, then it is only needed to build the entry
	   point definitions and we can ignore it. */

	if desc ^= 0
	then if ^addr (rands (desc)) -> symbol.allocated
	     then desc = 0;

	/* Initialize the automatic descriptor if array */

	if desc ^= 0 & s -> symbol.dimensioned
	then call copy_array_desc_template (s);

	/* Extract length from descriptor and store it in symbol.v_length */

	addr (rands (builtins (11))) -> symbol.location = 2 * arg_no - 2;
	call emit_single ((load_inst (in_q)), (builtins (11)));
	call emit_c_a (anq, descriptor_mask_addr);
	call emit_single ((store_inst (in_q)), (s -> symbol.v_length));

	/* Put length into automatic descriptor */

	if desc ^= 0
	then do;
	     mask = create_constant (int_mode, "777700000000"b3);
	     if s -> symbol.dimensioned
	     then do;
		call emit_single (orq, mask);
		call emit_single (anq, desc);
		call emit_single (stq, desc);
		end;

	     else do;

		/* Get type bits while we're at it */
		call emit_single (orq, mask);
		call emit_single (anq, (addr (rands (desc)) -> symbol.general));
		call emit_single ((store_inst (in_q)), desc);
		end;
	     end;

	call reset_eaq (Q);

	return;

     end get_param_char_size;

copy_array_desc_template:
     procedure (sym);

	/* Generates code to copy the descriptor template for an array
	   from the text into automatic storage. */

dcl  (s, sym) pointer;
dcl  desc fixed binary (18);

	s = sym;
	desc = s -> symbol.hash_chain;

	call push ((addr (rands (desc)) -> symbol.general));
	call push (desc);
	call interpreter_proc (move_eis, r3);
r3:
	return;

     end copy_array_desc_template;

make_descriptor:
     procedure (var) returns (fixed binary (18));

	/* Builds a descriptor for var, which must be either a temporary,
	   an array reference, or a symbol of constant extent (variable-
	   and star-extent symbols have been dealt with at storage
	   allocation time.)  If the temporary or array_ref is a character
	   string of star extent, code is emitted to fill in the length
	   field of the descriptor. */

dcl  var fixed binary (18);				/* Argument that needs a descriptor */
dcl  p pointer;
dcl  (desc, const, dt, csize) fixed binary (18);
dcl  v_length bit (1) aligned;

dcl  1 descriptor aligned,				/* Scalars only */
       2 type_word aligned,
         3 bit_type unaligned,
	 4 flag bit (1) unaligned,
	 4 type bit (6) unaligned,
	 4 packed bit (1) unaligned,
         3 number_dims fixed binary (3) unaligned,
         3 size fixed binary (23) unaligned;

	p = addr (rands (var));
	unspec (descriptor) = "0"b;
	v_length = "0"b;

	/* Handle symbols */

	if p -> node.node_type = symbol_node
	then if p -> symbol.hash_chain ^= 0
	     then return (p -> symbol.hash_chain);
	     else return (make_symbol_descriptor ((var)));

	/* Initialize the descriptor's type word */

	if p -> node.operand_type >= bif
	then unspec (descriptor.type_word) = unspec (descriptor_type_word (fptype, 7));
	else do;
	     dt = p -> node.data_type;
	     unspec (descriptor.type_word) = unspec (descriptor_type_word (fptype, dt));
	     if dt = char_mode
	     then do;
		if p -> node.units = char_units
		then descriptor.packed = "1"b;
		csize = get_char_size (p);
		if csize < 0
		then descriptor.size = csize + bias;
		else v_length = "1"b;
		end;
	     end;

	/* Create a constant node for the descriptor */

	const = create_constant (int_mode, unspec (descriptor.type_word));

	/* If the descriptor must be filled in at runtime, allocate a
	   temporary for it, and emit code to initialize it. */

	if v_length
	then do;
	     desc = assign_temp (int_mode);
	     call load (get_char_size (p), in_q);
	     call emit_c_a (anq, descriptor_mask_addr);
	     call emit_single (orq, const);
	     call emit_single (store_inst (in_q), desc);
	     call reset_eaq (Q);

	     /* Chain this descriptor so that it can be freed after
	        the call has been compiled */

	     addr (rands (desc)) -> temporary.next = desc_temp_chain;
	     desc_temp_chain = desc;
	     end;
	else desc = const;

	return (desc);

     end make_descriptor;

set_itp_addr:
     procedure (pt, pos);

	/* Sets one element of an ITP list to contain the
	   address of the operand pointed to by pt. */

dcl  (pt, p) pointer;
dcl  (pos, i) fixed binary (18);

	p = pt;
	i = pos;

	string (itp_list (i)) = "0"b;

	if p -> node.ext_base
	then do;
	     itp_list (i).pr_no = p -> node.base;
	     itp_list (i).itp_mod = ITP_mod;
	     itp_list (i).offset = bit (fixed (p -> node.address.offset, 18), 18);
	     itp_list (i).bit_offset = bit (fixed (p -> node.address.char_num * bits_per_char, 6), 6);

	     /* Bug 344 - If is indirect entry manufactured by the compiler to stack then we
	        need to indirect through ITP. */

	     if p -> node.stack_indirect & ^(p -> node.node_type = symbol_node & p -> symbol.VLA)
	     then itp_list (i).mod = RI_mod;		/* RI (*n) */
	     end;
	else addr (itp_list (i)) -> ind_word = unspec (p -> node.address);

     end set_itp_addr;

check_arg_list:
     procedure ();

	/* Checks argument lists for consistency, using subprogram
	   definition if possible otherwise using the first invoction
	   of each subprogram as a model for checking.  If the call is
	   to an external (descriptors) procedure, consistency is not
	   checked, but assumed size arrays as arguments are diagnosed.
	   The stack looks like:

	   external reference
	   count
	   arg1
	   arg2
	   .
	   .
	   .
	   argn
	*/

dcl  (adesc, i) fixed binary (18);
dcl  (a, p, s) pointer;

	num_args = stack (base + 1) + bias;
	s = addr (rands (stack (base)));

	if s -> symbol.variable_arglist
	then do;

	     /* Must diagnose assumed size arrays as arguments */

	     do i = 1 to num_args;
		p = addr (rands (stack (base + i + 1)));
		if p -> node.node_type = symbol_node
		then if p -> symbol.dimensioned
		     then if addr (rands (p -> symbol.dimension)) -> dimension.assumed_size
			then call print_message (468, stack (base), stack (base + i + 1));
		end;
	     end;

	else do;
	     if s -> symbol.general = 0
	     then call find_arg_desc (s);
	     if s -> symbol.general = 0
	     then do;				/* couldn't find arg_desc node, probably an external procedure */

		/* first time, set up arg_desc structure */


		adesc, s -> symbol.general = create_node (arg_desc_node, size (arg_desc));
		a = addr (rands (adesc));
		a -> arg_desc.n_args = num_args;

		do i = 1 to num_args;
		     p = addr (rands (stack (base + i + 1)));
		     a -> arg_desc.data_type (i) = p -> node.data_type;
		     if p -> node.node_type = symbol_node
		     then if p -> symbol.dimensioned
			then do;
			     a -> arg_desc.must_be.array (i) = "1"b;
			     if p -> symbol.ext_attributes.VLA
			     then a -> arg_desc.must_be.VLA (i) = "1"b;
			     end;
			else a -> arg_desc.must_be.scalar (i) = "1"b;
		     else if p -> node.node_type ^= array_ref_node
		     then a -> arg_desc.must_be.scalar (i) = "1"b;
		     end;
		end;

	     else do;

		/* not the first time, compare args with arg_desc structure */

		a = addr (rands (s -> symbol.general));

		if num_args ^= a -> arg_desc.n_args
		then do;
		     call print_message (400, stack (base));
		     if num_args > a -> arg_desc.n_args
		     then num_args = a -> arg_desc.n_args;
		     end;

		do i = 1 to num_args;
		     p = addr (rands (stack (base + i + 1)));

		     /* When a program calls an internal subroutine with arguments
		        that are declared as different data types in the included
		        routine, it will raise an error except in the case of
		        passing a character constant. */

		     if (p -> node.node_type ^= char_constant_node)
		     then do;
			if (p -> node.data_type ^= a -> arg_desc.data_type (i))
			     &
			     ^(p -> node.node_type = temporary_node
			     & addr (rands (a -> arg_desc.arg (i).symbol)) -> symbol.external)
			then call bad_arg;

			else if p -> node.node_type = symbol_node
			then do;
			     if p -> symbol.dimensioned
			     then do;
				if a -> arg_desc.must_be.scalar (i)
				then call bad_arg;
				else if p -> symbol.ext_attributes.VLA
				then if ^a -> arg_desc.must_be.VLA (i)
				     then call bad_arg;
				end;
			     else if a -> arg_desc.must_be.array (i)
			     then call bad_arg;
			     end;
			else if p -> node.node_type ^= array_ref_node
			then if a -> arg_desc.must_be.array (i)
			     then call bad_arg;
			end;
		     end;
		end;
	     end;


bad_arg:
     procedure ();

	call print_message (401, stack (base + i + 1), stack (base));

     end bad_arg;

	/* This procedure finds an arg_desc node that corresponds to an entry node.
	   It looks up the entry node that corresponds to the actual declaration of
	   a subprogram (if one exists), and looks in its symbol.general field to
	   find its arg_desc node. It returns the location of the arg_desc node by
	   setting the referencing entry node's general field.  It also makes sure
	   that the arg_desc node contains the data_type associated with each
	   parameter. */
find_arg_desc:
     proc (sp);
dcl  (e, i, ii) fixed bin;
dcl  (sp, ap, ep, symp) ptr;

	/* find the entry node with the same name */
	e = shared_globals.first_entry_name;
	do while (addr (rands (e)) -> symbol.name ^= sp -> symbol.name & e ^= shared_globals.last_entry_name);
	     e = addr (rands (e)) -> symbol.next_symbol;
	     end;
	ep = addr (rands (e));

	if ep -> symbol.name ^= sp -> symbol.name
	then return;				/* couldn't find it */
	if ep -> symbol.general = 0
	then return;				/* no arg_desc node */

	sp -> symbol.general = ep -> symbol.general;

	/* make sure that the data_type fields are set.  If there are any * arguments
	   (indicated by there being no symbol node accociated with the argument), then
	   remove all of these args and place one * arg at the end of the list.  Set
	   its data_type to 1. */

	ap = addr (rands (ep -> symbol.general));
	ii = 1;
	do i = 1 to ap -> arg_desc.n_args;
	     if ap -> arg_desc.arg (i).symbol ^= 0
	     then do;
		ap -> arg_desc.arg (ii) = ap -> arg_desc.arg (i);
		if ap -> arg_desc.arg (ii).data_type = 0
		then do;
		     symp = addr (rands (ap -> arg_desc.arg (ii).symbol));
		     ap -> arg_desc.arg (ii).data_type = symp -> symbol.data_type;
		     if symp -> node.node_type = symbol_node
		     then if symp -> symbol.dimensioned
			then do;
			     ap -> arg_desc.arg (ii).must_be.array = "1"b;
			     if symp -> symbol.ext_attributes.VLA
			     then ap -> arg_desc.must_be.VLA (ii) = "1"b;
			     end;
			else ap -> arg_desc.arg (ii).must_be.scalar = "1"b;
		     else if symp -> node.node_type ^= array_ref_node
		     then ap -> arg_desc.arg (ii).must_be.scalar = "1"b;
		     end;
		ii = ii + 1;
		end;
	     end;
	if ii ^= i
	then do;

	     /* at least one asterisk arg was removed */

	     ap -> arg_desc.n_args = ii;
	     unspec (ap -> arg_desc.arg (ii)) = "0"b;
	     ap -> arg_desc.arg (ii).data_type = 1;
	     end;
     end find_arg_desc;

     end check_arg_list;

/**** FLD BUILTIN CODE ****/
one_word_dt:
     procedure (opnd) returns (bit (1));

	/*  Returns true if "opnd" has a data type that takes up exactly one word
	   of aligned storage. */

dcl  opnd fixed bin (18);
dcl  p pointer;

	p = addr (rands (opnd));
	if (p -> node.data_type = int_mode) | (p -> node.data_type = real_mode) | (p -> node.data_type = typeless_mode)
	then return ("1"b);
	else if (p -> node.data_type = char_mode)
	then if (p -> node.node_type = symbol_node)
	     then return (p -> symbol.char_size = 3 & ^p -> symbol.aliasable);
	     else if (p -> node.node_type = char_constant_node)
	     then return (p -> char_constant.length = 4);
	     else return ("0"b);
	else return ("0"b);
     end one_word_dt;

generate_mask:
     procedure (start, len) returns (fixed bin (18));

	/* Creates an integer constant mask */

dcl  (start, len) fixed bin (18);
dcl  mask fixed bin (35);


	mask = 0;
	substr (unspec (mask), start + 1, len) = "111111111111111111111111111111111111"b;

	return (create_integer_constant (mask));
     end generate_mask;

rhs_fld:
     procedure;

	/* emits the code for the case of the fld intrinsic on the right hand
	   side of an assignement statement.  The code is emitted manually as the macros are
	   are not general enough to allow computed bit masks.  */

dcl  shift fixed bin;
dcl  (arg1, arg2, arg3, start, len) fixed bin (18);
dcl  (found_error, arg1_is_const, arg2_is_const) bit (1) init ("0"b);

	arg1 = stack (get_operand (5));
	if addr (rands (arg1)) -> node.data_type ^= int_mode
	then do;
	     call print_message (359, arg1);
	     found_error = "1"b;
	     end;
	arg2 = stack (get_operand (6));
	if addr (rands (arg2)) -> node.data_type ^= int_mode
	then do;
	     call print_message (359, arg2);
	     found_error = "1"b;
	     end;
	arg3 = stack (get_operand (7));
	if ^one_word_dt (arg3)
	then do;
	     call print_message (360, arg3);
	     found_error = "1"b;
	     end;
	if found_error
	then call signal_error;

	if addr (rands (arg2)) -> node.node_type = constant_node
	then do;
	     arg2_is_const = "1"b;
	     len = addr (addr (rands (arg2)) -> constant.value) -> based_integer;
	     if len < 1 | len > 36
	     then call print_message (364);
	     if len = 0
	     then do;
		call load (create_integer_constant (0), in_tq);
		return;
		end;
	     end;
	if addr (rands (arg1)) -> node.node_type = constant_node
	then do;
	     arg1_is_const = "1"b;
	     start = addr (addr (rands (arg1)) -> constant.value) -> based_integer;
	     if start < 0 | start > 35
	     then call print_message (363);
	     end;

	if arg1_is_const & arg2_is_const
	then do;
	     start = min (max (start, 0), 35);
	     len = min (max (len, 0), 36 - start);
	     shift = 36 - (start + len);

	     call load (arg3, in_tq);

	     if start = 0
	     then do;
		if len = 36
		then return;
		call emit_single (qrl, shift - bias);
		end;

	     else if shift = 0
	     then call emit_single (anq, generate_mask (start, len));

	     else do;
		call emit_single (qls, start - bias);
		call emit_single (qrl, (36 - len) - bias);
		end;
	     call reset_eaq (Q);
	     return;
	     end;
	else do;
	     call load (arg3, in_tq);

	     if arg1_is_const
	     then do;
		if start ^= 0
		then call emit_single (qls, start - bias);
		call emit_single (lca, arg2);
		call emit_with_tag (qrl, 36, AL_mod);
		call reset_eaq (A);
		end;
	     else if arg2_is_const
	     then do;
		call load (arg1, in_ia);
		call emit_with_tag (qls, 0, AL_mod);
		call emit_single (qrl, (36 - len) - bias);
		end;
	     else do;
		call load (arg1, in_ia);
		call emit_with_tag (qls, 0, AL_mod);
		call emit_single (lca, arg2);
		call emit_with_tag (qrl, 36, AL_mod);
		call reset_eaq (A);
		end;
	     call reset_eaq (Q);
	     return;
	     end;
	return;
     end rhs_fld;

lhs_fld:
     procedure;

	/*  emits the code for the case of the fld intrinsic on the left hand side
	   of an assignment statement.  The code is emitted manually as the macros
	   are not general enough to allow certain optimizations (such as bit
	   masks. */

dcl  shift fixed bin;
dcl  RHS fixed bin (35);
dcl  (arg1, arg2, arg3, arg4, start, len) fixed bin (18);
dcl  (found_error, arg1_is_const, arg2_is_const) bit (1) init ("0"b);
dcl  copy builtin;

	arg1 = stack (get_operand (1));
	if addr (rands (arg1)) -> node.data_type ^= int_mode
	then do;
	     call print_message (359, arg1);
	     found_error = "1"b;
	     end;
	arg2 = stack (get_operand (2));
	if addr (rands (arg2)) -> node.data_type ^= int_mode
	then do;
	     call print_message (359, arg2);
	     found_error = "1"b;
	     end;
	arg3 = stack (get_operand (3));
	if ^one_word_dt (arg3)
	then do;
	     call print_message (360, arg3);
	     found_error = "1"b;
	     end;
	arg4 = stack (get_operand (4));
	if ^one_word_dt (arg4)
	then do;
	     call print_message (361);
	     found_error = "1"b;
	     end;
	if found_error
	then call signal_error;

	if addr (rands (arg2)) -> node.node_type = constant_node
	then do;
	     arg2_is_const = "1"b;
	     len = addr (addr (rands (arg2)) -> constant.value) -> based_integer;
	     if len < 1 | len > 36
	     then call print_message (364);
	     if len = 0
	     then return;
	     end;
	if addr (rands (arg1)) -> node.node_type = constant_node
	then do;
	     arg1_is_const = "1"b;
	     start = addr (addr (rands (arg1)) -> constant.value) -> based_integer;
	     if start < 0 | start > 35
	     then call print_message (363);
	     end;

	if arg1_is_const & arg2_is_const
	then do;
	     start = min (max (start, 0), 35);
	     len = min (max (len, 0), 36 - start);

	     if start = 0 & len = 36
	     then do;
		call load (arg4, in_tq);
		call store (arg3, in_tq, 0);
		return;
		end;

	     if addr (rands (arg4)) -> node.node_type = constant_node
	     then do;
		unspec (RHS) =
		     copy ("0"b, start) || substr (addr (rands (arg4)) -> constant.value, 36 - len + 1, len);
		call load (create_integer_constant (RHS), in_tq);
		end;
	     else do;
		call load (arg4, in_tq);
		shift = 36 - start - len;
		if shift > 0
		then call emit_single (qls, shift - bias);
		end;
	     call emit_single (erq, arg3);
	     call emit_single (anq, generate_mask (start, len));
	     call emit_single (ersq, arg3);
	     call reset_eaq (Q);
	     end;

	else if arg1_is_const
	then do;
	     call use_eaq (0);
	     call reserve_regs (("1"b));

	     call emit_single (lxl0, arg2);
	     call emit_single (load_inst (in_ia), arg3);
	     call emit_with_tag (alr, start, X0_mod);
	     call emit_single (era, arg4);
	     call emit_with_tag (load_inst (in_iq), 0, DL_mod);
	     call emit_with_tag (lrs, 0, X0_mod);
	     if start ^= 0
	     then call emit_single (qrl, start - bias);
	     call emit_single (ersq, arg3);
	     end;

	else if arg2_is_const
	then do;
	     call use_eaq (0);
	     call reserve_regs (("1"b));

	     call emit_single (lxl0, arg1);
	     call emit_single (load_inst (in_ia), arg3);
	     call emit_with_tag (alr, len, X0_mod);
	     call emit_single (era, arg4);
	     call emit_with_tag (load_inst (in_iq), 0, DL_mod);
	     call emit_single (lrs, len - bias);
	     call emit_with_tag (qrl, 0, X0_mod);
	     call emit_single (ersq, arg3);
	     end;

	else do;
	     call use_eaq (0);
	     call reserve_regs (("11"b));

	     call emit_single (lxl0, arg1);
	     call emit_single (lxl1, arg2);
	     call emit_single (load_inst (in_ia), arg3);
	     call emit_with_tag (alr, 0, X0_mod);
	     call emit_with_tag (alr, 0, X1_mod);
	     call emit_single (era, arg4);
	     call emit_with_tag (load_inst (in_iq), 0, DL_mod);
	     call emit_with_tag (lrs, 0, X1_mod);
	     call emit_with_tag (qrl, 0, X0_mod);
	     call emit_single (ersq, arg3);
	     end;
	return;
     end lhs_fld;

start_subprogram:
     procedure ();

	/* Initializes global variables for a subprogram. */

dcl  i fixed binary;
dcl  (last, temp) fixed binary (18);

	cs = addr (rands (cur_subprogram));
	call get_subr_options (cs);

	if cs -> subprogram.subprogram_type ^= main_program
	then do;
	     last_auto_loc = last_auto_loc + mod (last_auto_loc, 2);
	     cs -> subprogram.entry_info = last_auto_loc;
	     call set_address_offset (addr (rands (builtins (8))), last_auto_loc, entry_info_size, word_units);
	     last_auto_loc = last_auto_loc + entry_info_size;
	     if last_auto_loc > max_stack_size
	     then call print_message (414,
		     "making subroutine entry for " || addr (rands (cs -> subprogram.symbol)) -> symbol.name
		     || " has exceeded the stack frame", max_stack_size - bias);
	     end;

	ipol = cs -> subprogram.first_polish;

	do i = 1 to hbound (free_temps, 1);
	     if free_temps (i) ^= 0
	     then do;
		do temp = free_temps (i) repeat (addr (rands (temp)) -> temporary.next) while (temp ^= 0);
		     last = temp;
		     end;
		addr (rands (last)) -> temporary.next = next_free_temp;
		next_free_temp = free_temps (i);
		free_temps (i) = 0;
		end;
	     end;

     end start_subprogram;


     end interpreter;

get_char_size:
     procedure (pt) returns (fixed binary (18));

	/* Procedure to return the size of a character string.
	   The size is returned as a count (if it is constant)
	   or as an operand index. */

dcl  (p, pt) pointer;				/* Pointer to character node */

	p = pt;

	if p -> node.data_type ^= char_mode
	then call print_message (412, fixed (rel (p), 18));

	if p -> node.node_type = char_constant_node
	then return (p -> char_constant.length - bias);

	if p -> node.node_type = symbol_node
	then do;
	     if p -> symbol.v_length ^= 0
	     then return (p -> symbol.v_length);
	     else return (p -> symbol.char_size + 1 - bias);
	     end;

	if p -> node.node_type = array_ref_node
	then do;
	     if p -> array_ref.variable_length
	     then return (p -> array_ref.length);
	     else return (p -> array_ref.length - bias);
	     end;

	if p -> node.node_type = temporary_node
	then do;
	     if p -> temporary.variable_length
	     then return (p -> temporary.length);
	     else return (p -> temporary.length - bias);
	     end;

	call print_message (412, fixed (rel (p), 18));

     end get_char_size;

make_symbol_descriptor:
     procedure (var) returns (fixed binary (18));

	/* Builds a descriptor for the symbol var.  If var is a parameter
	   of star or expression extents, the appropriate fields of the
	   descriptor are filled in later by get_param_array_size or
	   get_param_char_size. */

dcl  var fixed binary (18);				/* Symbol that needs a descriptor */

dcl  (p, d, cs) pointer;
dcl  (i, cm, desc, dt, const, ndims, char_star_ndims, csize) fixed binary (18);
dcl  v_length bit (1) aligned;

dcl  1 descriptor aligned,
       2 type_word aligned,
         3 bit_type unaligned,
	 4 flag bit (1) unaligned,
	 4 type bit (6) unaligned,
	 4 packed bit (1) unaligned,
         3 number_dims fixed binary (3) unaligned,
         3 size fixed binary (23) unaligned,
       2 array_info (7) aligned,
         3 l_bound fixed binary (18),
         3 h_bound fixed binary (18),
         3 multiplier fixed binary (18);

dcl  desc_image character (chars_per_word * (1 + char_star_ndims + 3 * ndims)) unaligned based (addr (descriptor));

dcl  (length, size) builtin;

	p = addr (rands (var));
	unspec (descriptor) = "0"b;
	v_length = "0"b;
	ndims, char_star_ndims = 0;

	/* If the symbol already has a descriptor, return it */

	if p -> symbol.hash_chain ^= 0
	then return (p -> symbol.hash_chain);

	/* Initialize the descriptor's type word */

	if p -> symbol.operand_type >= bif
	then unspec (descriptor.type_word) = unspec (descriptor_type_word (fptype, 7));
	else do;
	     dt = p -> symbol.data_type;
	     unspec (descriptor.type_word) = unspec (descriptor_type_word (fptype, dt));
	     if dt = char_mode
	     then do;
		if p -> symbol.units = char_units
		then descriptor.packed = "1"b;
		csize = get_char_size (p);
		if csize < 0
		then descriptor.size = csize + bias;
		else do;
		     v_length = "1"b;
		     unspec (descriptor.size) = "77777777"b3;
		     end;
		end;
	     end;

	/* If symbol is dimensioned, add the dimension info */
	/* If we would have to concoct runtime character*(*) lengths for a
	   runtime symbol table, reserve space for the character multipliers. */

	if p -> symbol.dimensioned
	then do;
	     d = addr (rands (p -> symbol.dimension));
	     ndims = d -> dimension.number_of_dims;
	     descriptor.number_dims = ndims;

	     if v_length & shared_globals.user_options.table
	     then char_star_ndims = ndims;		/* count char*(*) multiplier extras */

	     if descriptor.packed
	     then cm = get_size_in_bits ((p -> symbol.element_size), (p -> symbol.units));
	     else cm = get_size_in_words ((p -> symbol.element_size), (p -> symbol.units));

	     do i = 1 to ndims;

		if ^v_length
		then descriptor.multiplier (i) = cm;

		if string (d -> dimension.v_bound (i)) = "00"b
		then do;
		     descriptor.l_bound (i) = d -> dimension.lower_bound (i);
		     descriptor.h_bound (i) = d -> dimension.upper_bound (i);
		     if ^v_length
		     then cm = cm * d -> dimension.size (i);
		     end;
		else do;
		     v_length = "1"b;

		     /* if no specific bounds are seen, fill in '*' bounds in the static descriptor.
		        This requires variable descriptor math to over-write the bounds in auto
		        when called. */

		     if ^d -> dimension.v_bound (i).lower
		     then descriptor.l_bound (i) = d -> dimension.lower_bound (i);
		     else unspec (descriptor.l_bound (i)) = "400000000000"b3;
						/* '*' bound */

		     if ^d -> dimension.v_bound (i).upper
		     then descriptor.h_bound (i) = d -> dimension.upper_bound (i);
		     else if (i = ndims) & d -> dimension.assumed_size
		     then unspec (descriptor.h_bound (i)) = "377777777777"b3;
		     else unspec (descriptor.h_bound (i)) = "400000000000"b3;
						/* '*' bound */
		     end;
		end;
	     end;

	/* Create a constant node for the descriptor */

	if ndims = 0
	then const = create_constant (int_mode, unspec (descriptor.type_word));
	else const = create_char_constant (desc_image);

	/* If the descriptor must be filled in at runtime, allocate a
	   symbol node for it. */

	if v_length
	then do;
	     desc = create_node (symbol_node, size (symbol));
	     d = addr (rands (desc));
	     d -> symbol.data_type = char_mode;
	     d -> symbol.by_compiler = "1"b;
	     d -> symbol.character = "1"b;
	     d -> symbol.allocate = "1"b;
	     d -> symbol.automatic = "1"b;
	     d -> symbol.char_size = length (desc_image) - 1;
	     d -> symbol.element_size = 1 + char_star_ndims + 3 * ndims;
	     d -> symbol.general = const;

	     /* Thread in the new symbol, so its storage is allocated */

	     cs = addr (rands (cur_subprogram));
	     addr (rands (cs -> subprogram.last_symbol)) -> node.next = desc;
	     cs -> subprogram.last_symbol = desc;
	     end;
	else desc = const;

	/* Remember that we made this descriptor */

	p -> symbol.hash_chain = desc;

	/* Return the descriptor node */

	return (desc);

     end make_symbol_descriptor;

make_entry_descriptor:
     procedure (var) returns (fixed binary (18));

dcl  var fixed binary (18);				/* Symbol that needs a descriptor */

dcl  (p, d) pointer;
dcl  (i, cm, dt, const, ndims, char_star_ndims, csize) fixed binary (18);
dcl  v_length bit (1) aligned;

dcl  1 descriptor aligned,
       2 type_word aligned,
         3 bit_type unaligned,
	 4 flag bit (1) unaligned,
	 4 type bit (6) unaligned,
	 4 packed bit (1) unaligned,
         3 number_dims fixed binary (3) unaligned,
         3 size fixed binary (23) unaligned,
       2 array_info (7) aligned,
         3 l_bound fixed binary (18),
         3 h_bound fixed binary (18),
         3 multiplier fixed binary (18);

dcl  desc_image character (chars_per_word * (1 + char_star_ndims + 3 * ndims)) unaligned based (addr (descriptor));



	p = addr (rands (var));
	unspec (descriptor) = "0"b;
	v_length = "0"b;
	ndims, char_star_ndims = 0;

	/* If the symbol already has a descriptor, return it. */
	if p -> symbol.hash_chain ^= 0
	then do;
	     d = addr (rands (p -> symbol.hash_chain));

	     /* return only constant nodes */
	     if d -> node.node_type = symbol_node
	     then d = addr (rands (d -> symbol.general));

	     /* make sure the constant is allocated */
	     d -> node.allocate = "1"b;
	     return (fixed (rel (d), 18));
	     end;

	/* Initialize the descriptor's type word */

	if p -> symbol.operand_type >= bif
	then unspec (descriptor.type_word) = unspec (descriptor_type_word (fptype, 7));
	else do;
	     dt = p -> symbol.data_type;
	     unspec (descriptor.type_word) = unspec (descriptor_type_word (fptype, dt));
	     if dt = char_mode
	     then do;
		if p -> symbol.units = char_units
		then descriptor.packed = "1"b;
		csize = get_char_size (p);
		if csize < 0
		then descriptor.size = csize + bias;
		else do;
		     v_length = "1"b;
		     unspec (descriptor.size) = "77777777"b3;
		     end;
		end;
	     end;

	/* If symbol is dimensioned, add the dimension info */
	/* If we would have to concoct runtime character*(*) lengths for a
	   runtime symbol table, reserve space for the character multipliers. */

	if p -> symbol.dimensioned
	then do;
	     d = addr (rands (p -> symbol.dimension));
	     ndims = d -> dimension.number_of_dims;
	     descriptor.number_dims = ndims;

	     if v_length & shared_globals.user_options.table
	     then char_star_ndims = ndims;		/* count char*(*) multiplier extras */

	     if descriptor.packed
	     then cm = get_size_in_bits ((p -> symbol.element_size), (p -> symbol.units));
	     else cm = get_size_in_words ((p -> symbol.element_size), (p -> symbol.units));

	     do i = 1 to ndims;

		if ^v_length
		then descriptor.multiplier (i) = cm;

		if string (d -> dimension.v_bound (i)) = "00"b
		then do;
		     descriptor.l_bound (i) = d -> dimension.lower_bound (i);
		     descriptor.h_bound (i) = d -> dimension.upper_bound (i);
		     if ^v_length
		     then cm = cm * d -> dimension.size (i);
		     end;
		else do;
		     v_length = "1"b;

		     /* if no specific bounds are seen, fill in '*' bounds in the static descriptor.
		        This requires variable descriptor math to over-write the bounds in auto
		        when called. */

		     if ^d -> dimension.v_bound (i).lower
		     then descriptor.l_bound (i) = d -> dimension.lower_bound (i);
		     else unspec (descriptor.l_bound (i)) = "400000000000"b3;
						/* '*' bound */

		     if ^d -> dimension.v_bound (i).upper
		     then descriptor.h_bound (i) = d -> dimension.upper_bound (i);
		     else if (i = ndims) & d -> dimension.assumed_size
		     then unspec (descriptor.h_bound (i)) = "377777777777"b3;
		     else unspec (descriptor.h_bound (i)) = "400000000000"b3;
						/* '*' bound */
		     end;
		end;
	     end;

	/* Create a constant node for the descriptor */

	if ndims = 0
	then const = create_constant (int_mode, unspec (descriptor.type_word));
	else const = create_char_constant (desc_image);

	/* Remember that we made this descriptor */

	p -> symbol.hash_chain = const;

	/* Make sure the constant is allocated. */

	addr (rands (const)) -> node.allocate = "1"b;

	/* Return the descriptor node */

	return (const);

     end make_entry_descriptor;

/**** DATA INITIALIZATION ****/

initialize_static:
     procedure ();

dcl  (cur_subr, hdr) fixed binary (18);
dcl  (csp, h, s) pointer;

dcl  base ptr;
dcl  full_pointer ptr based (base);
dcl  packed_pointer ptr unaligned based (base);


	do cur_subr = first_subprogram repeat csp -> subprogram.next_subprogram while (cur_subr > 0);
	     csp = addr (rands (cur_subr));

	     /* Do static Large Arrays - full null pointer. */

	     do hdr = csp -> subprogram.storage_info.first (14) repeat h -> node.next while (hdr > 0);
		h = addr (rands (hdr));
		base = addrel (link_base, h -> header.location);
		full_pointer = null ();
		end;

	     /* Do static Very Large Arrays - packed null pointer. */

	     do hdr = csp -> subprogram.storage_info.first (16) repeat h -> node.next while (hdr > 0);
		h = addr (rands (hdr));
		s = addr (rands (h -> header.VLA_base_addressor));
		if ^s -> symbol.large_address
		then base = addrel (link_base, s -> symbol.address.offset);
		else base = addrel (link_base, s -> symbol.address.offset + s -> symbol.location);
		packed_pointer = null ();
		end;

	     /* Do Very Large Common - packed null pointer. */

	     do hdr = csp -> subprogram.storage_info.first (17) repeat h -> node.next while (hdr > 0);
		h = addr (rands (hdr));
		s = addr (rands (h -> header.VLA_base_addressor));
		if ^s -> symbol.large_address
		then base = addrel (link_base, s -> symbol.address.offset);
		else base = addrel (link_base, s -> symbol.address.offset + s -> symbol.location);
		packed_pointer = null ();
		end;
	     end;


	/* Initialize normal static. */

	do cur_subr = first_subprogram repeat csp -> subprogram.next_subprogram while (cur_subr > 0);
	     csp = addr (rands (cur_subr));
	     call initialize (link_base, 5);
	     end;

	/* initialize long_profile_header */

	if generate_profile & generate_long_profile
	then do;
	     base = addrel (link_base, profile_start);
	     unspec (base -> long_profile_header) = "0"b;
	     end;
	return;


initialize_auto:
     entry ();

	auto_template = text_pos;

	do cur_subr = first_subprogram repeat csp -> subprogram.next_subprogram while (cur_subr > 0);
	     csp = addr (rands (cur_subr));
	     call initialize (addrel (object_base, text_pos - first_auto_var_loc), 1);
	     end;

	text_pos = text_pos + (csp -> subprogram.next_loc (2) - first_auto_var_loc);

	return;

initialize:
     procedure (pt, start);

dcl  pt pointer,					/* Base of section to place initialized vars */
     start fixed binary (18);				/* First bucket to initialize */

dcl  (base, h, s) pointer;
dcl  (sym, hdr, i) fixed binary (18);

	base = pt;

	do i = start to start + 1;
	     do hdr = csp -> subprogram.storage_info.first (i) repeat h -> node.next while (hdr > 0);
		h = addr (rands (hdr));
		if h -> node.node_type = header_node
		then do sym = h -> header.first_element repeat s -> symbol.next_member while (sym > 0);
			s = addr (rands (sym));
			if s -> symbol.initialed
			then call initialize_symbol (s, base);
			end;
		else call initialize_symbol (h, base);
		end;
	     end;

     end initialize;

     end initialize_static;

list_initialize:
     procedure (pt, hdr, words);

dcl  pt pointer,					/* Base of section to place initialized vars */
						/* left at last point of init */
     hdr fixed binary (18),				/* header to init from */
     words fixed bin (18);				/* words used for init info + original value */

dcl  (h, s) pointer;
dcl  sym fixed binary (18);
dcl  start_offset fixed bin (18);
dcl  end_offset fixed bin (35);

	h = addr (rands (hdr));
	if ^h -> header.initialed
	then return;				/* No work to do */
	end_offset = 0;
	start_offset = fixed (rel (pt), 18);

	do sym = h -> header.first_element repeat s -> symbol.next_member while (sym > 0);
	     s = addr (rands (sym));

	     if s -> symbol.initialed
	     then call list_initialize_symbol (s, pt, end_offset);
	     end;
	pt -> create_init_entry.length = 0;		/* END */
	pt = addrel (pt, 1);

	/* calculate words taken for initialization list data */

	words = words + fixed (rel (pt), 18) - start_offset;
	return;
     end list_initialize;

initialize_symbol:
     procedure (sym_pt, init_pt);

dcl  (sym_pt, init_pt) pointer;

dcl  (s, address) pointer;
dcl  (index, case, csize, limit, off) fixed binary (18);

dcl  1 initial aligned automatic,
       2 next fixed binary (18),
       2 limit fixed binary (18),
       2 value fixed binary (18);

dcl  1 initial_in_polish aligned based,
       2 next fixed binary (17) aligned,
       2 limit fixed binary (17) aligned,
       2 value fixed binary (17) aligned;

dcl  single_target (10000) bit (36) aligned based (address);

dcl  double_target (10000) bit (72) aligned based (address);

dcl  char_target (10000) character (csize) aligned based (address);

dcl  char77_target (10000) character (csize) unaligned based (address);

dcl  char_overlay (0:3) character (1) unaligned based;

	s = sym_pt;
	address = init_pt;
	index = 1;

	/* Develop a full pointer to the initial template for the symbol */

	off = s -> symbol.address.offset;
	if s -> symbol.large_address
	then off = off + s -> symbol.location;

	address = addrel (address, off);

	if s -> symbol.units = char_units
	then do;
	     off = s -> symbol.address.char_num;
	     address = addr (address -> char_overlay (off));
	     end;

	if s -> symbol.character
	then if s -> symbol.units = char_units
	     then do;
		csize = s -> symbol.char_size + 1;
		case = 4;
		end;
	     else do;
		csize = s -> symbol.char_size + 1;
		case = 3;
		end;
	else case = data_type_size (s -> symbol.data_type);

	if ^s -> symbol.dimensioned
	then do;
	     initial.value = addr (polish (s -> symbol.initial)) -> initial_in_polish.value;
	     if initial.value ^= gap_value
	     then call assign_value;
	     return;
	     end;

	initial.next = s -> symbol.initial;
	limit = 0;

	do while (initial.next > 0);

	     /* can't use aggregate assignment because of bug 1466 */

	     initial.value = addr (polish (initial.next)) -> initial_in_polish.value;
	     initial.limit = addr (polish (initial.next)) -> initial_in_polish.limit;
	     initial.next = addr (polish (initial.next)) -> initial_in_polish.next;
	     limit = limit + initial.limit;

	     do while (index <= limit);
		if initial.value ^= gap_value
		then call assign_value;
		index = index + 1;
		end;

	     end;

assign_value:
     procedure ();

	go to action (case);

action (1):
	single_target (index) = addr (rands (initial.value)) -> constant.value;
	return;

action (2):
	double_target (index) = addr (rands (initial.value)) -> constant.value;
	return;

action (3):
	char_target (index) = addr (rands (initial.value)) -> char_constant.value;
	return;

action (4):
	char77_target (index) = addr (rands (initial.value)) -> char_constant.value;
	return;

     end assign_value;

     end initialize_symbol;

list_initialize_symbol:
     procedure (sym_pt, init_pt, end_offset);

dcl  (
     sym_pt,					/* pointer to symbol */
     init_pt
     ) pointer;					/* pointer to template storage */

dcl  end_offset fixed bin (35);			/* offset end of last stored */

	/* end_offset will be the last offset value assigned, and used as both input
	   and output.  The difference between the end_offset input and the first
	   offset calculated will be a null filler.  end_offset output will be the
	   end of the area initialized to this point. */

dcl  boffset fixed bin (35);
dcl  s pointer;
dcl  (index, case, bsize, csize) fixed binary (18);
dcl  off fixed bin (35);

dcl  1 initial aligned automatic,
       2 next fixed binary (35),
       2 limit fixed binary (35),
       2 value fixed binary (35);

dcl  1 initial_in_polish aligned based,
       2 next fixed binary (35) aligned,
       2 limit fixed binary (35) aligned,
       2 value fixed binary (35) aligned;

dcl  single_target (10000) bit (36) aligned based;

dcl  double_target (10000) bit (72) aligned based;

dcl  char_target (10000) character (csize) aligned based;

dcl  char77_target (10000) character (csize) unaligned based;


	s = sym_pt;
	index = 1;

	/* Develop an offset to the start of the variable area to be initialized */

	if s -> symbol.VLA
	then off = s -> symbol.location;
	else do;
	     off = s -> symbol.address.offset;
	     if s -> symbol.large_address
	     then off = off + s -> symbol.location;
	     end;

	boffset = off * 36;

	if s -> symbol.units = char_units
	then boffset = boffset + 9 * s -> symbol.address.char_num;

	if s -> symbol.character
	then if s -> symbol.units = char_units
	     then do;
		csize = s -> symbol.char_size + 1;
		case = 4;
		end;
	     else do;
		csize = s -> symbol.char_size + 1;
		case = 3;
		end;
	else case = data_type_size (s -> symbol.data_type);

	if ^s -> symbol.dimensioned
	then do;
	     initial.value = addr (polish (s -> symbol.initial)) -> initial_in_polish.value;
	     call list_assign_value (1);
	     return;
	     end;

	initial.next = s -> symbol.initial;

	do while (initial.next > 0);

	     /* can't use aggregate assignment because of bug 1466 */

	     initial.value = addr (polish (initial.next)) -> initial_in_polish.value;
	     initial.limit = addr (polish (initial.next)) -> initial_in_polish.limit;
	     initial.next = addr (polish (initial.next)) -> initial_in_polish.next;
	     call list_assign_value (initial.limit);
	     index = index + initial.limit;

	     end;
	return;

list_assign_value:
     procedure (repeat);

dcl  repeat fixed bin (35);

	if initial.value = gap_value			/* skip */
	then return;

	go to size_it (case);

size_it (1):					/* single precision */
	bsize = 36;
	off = (divide (boffset + bsize - 1, bsize, 35) + (index - 1)) * bsize;
	goto list_assign_create;

size_it (2):					/* double precision */
	bsize = 72;
	off = (divide (boffset + bsize - 1, bsize, 35) + (index - 1)) * bsize;
	goto list_assign_create;

size_it (3):					/* ansi66 character aligned target */
	bsize = divide (csize + 3, 4, 35) * 36;		/* round up to word */
	off = divide (boffset + 35, 36, 35) * 36 + (index - 1) * bsize;
	goto list_assign_create;

size_it (4):					/* ansi77 character unaligned */
	bsize = csize * 9;
	off = boffset + (index - 1) * bsize;
	goto list_assign_create;


	/* create the initialization entry at the specified pointer. */

list_assign_create:
	if end_offset ^= off			/* see if we formed a gap */
	then do;					/* filler */
	     init_pt -> create_init_entry.repeat = 0;	/* skip */
	     init_pt -> create_init_entry.length = off - end_offset;
	     init_pt = addrel (init_pt, 2);
	     end;
	init_pt -> create_init_entry.length = bsize;
	init_pt -> create_init_entry.repeat = repeat;
	go to action (case);

action (1):
	addr (init_pt -> create_init_entry.datum) -> single_target (1) = addr (rands (initial.value)) -> constant.value;
	goto list_assign_finish;

action (2):
	addr (init_pt -> create_init_entry.datum) -> double_target (1) = addr (rands (initial.value)) -> constant.value;
	goto list_assign_finish;

action (3):
	addr (init_pt -> create_init_entry.datum) -> char_target (1) =
	     addr (rands (initial.value)) -> char_constant.value;
	goto list_assign_finish;

action (4):
	addr (init_pt -> create_init_entry.datum) -> char77_target (1) =
	     addr (rands (initial.value)) -> char_constant.value;
	goto list_assign_finish;

list_assign_finish:
	init_pt = addrel (init_pt, currentsize (init_pt -> create_init_entry));
	end_offset = off + bsize * repeat;
	return;

     end list_assign_value;

     end list_initialize_symbol;

/**** LINKAGE SECTION GENERATION ****/

init_linkage:
     procedure ();

	/* This procedure is called to initialize the linkage generator.
	   It builds the linkage_header and generates the class 3
	   segname definition  and the definition for "symbol_table". */

dcl  1 def_header based aligned,
       2 forward bit (18) unaligned,
       2 backward bit (18) unaligned,
       2 skip bit (18) unaligned,
       2 flags bit (18) unaligned;

%include segname_def;

	/* initialize linkage header */

	link_base -> virgin_linkage_header.def_offset = bit (defrel, 18);
	link_base -> virgin_linkage_header.link_begin = bit (begin_links, 18);
	link_base -> virgin_linkage_header.linkage_section_lng = bit (link_pos, 18);
	link_base -> virgin_linkage_header.static_length =
	     bit (fixed (begin_links - size (virgin_linkage_header), 18), 18);

	link_reloc_base -> reloc (1) = rc_t;

	/* generate definition header.  the word of zeros terminating
	   the definition chain will be at location 2 */

	def_base -> def_header.flags = "11"b;		/* new,ignore */
	def_reloc_base -> reloc (0) = rc_dp;
	zero_def = "000000000000000010"b;
	last_def = (18)"0"b;
	def_pos = 3;

	/* generate definition for segname, class 3 */

	call generate_definition (segname, 3, zero_def);

	/* generate definition for "symbol_table" */

	call generate_definition ("symbol_table", 2, "0"b);

	addrel (def_base, seg_def) -> segname_def.defblock = last_def;

	return;

     end init_linkage;

gen_linkage:
     procedure ();

	/* Generate the links for common and external references */

dcl  i fixed binary (18);
dcl  position fixed binary (15);
dcl  s pointer;

	do i = begin_external_list to end_external_list - 1 by 3;
	     s = ext_ref (i);
	     if s -> node.allocated
	     then if s -> node.node_type = symbol_node
		then if s -> symbol.initial = 0
		     then do;
			position = s -> symbol.address.offset;
			if s -> symbol.large_address
			then position = position + s -> symbol.location;
			call compile_link (s -> symbol.name, "0"b, 0, position);
			end;
		     else ;
		else do;

		     /* the following code is affected by PL/I bug 1599 */
		     /* This bug is fixed by release 23 of PL/I */

		     if index (s -> header.block_name, "$") = 0
		     then call compile_link (s -> header.block_name, initialize_common (s, (polish (i + 1))), 1,
			     (s -> header.location));
		     else if ^s -> header.initialed
		     then call compile_link (s -> header.block_name, "0"b, 1, (s -> header.location));
		     else call print_message (429, s -> header.block_name);
		     end;
	     end;

	return;

     end gen_linkage;

compile_link:
     procedure (string, grow, type, link_pos);

dcl  string character (*) aligned,
     grow bit (18) aligned,
     type fixed binary (18),
     link_pos fixed binary (15);

dcl  (seg_name, ent_name, block_type) bit (18) aligned;

dcl  (def_ptr, link_ptr, def_reloc_ptr, link_reloc_ptr) pointer;
dcl  head_address fixed binary (35) based aligned;

dcl  k fixed binary (18);

dcl  dollar_name character (32) aligned;

dcl  length builtin;

	if length (string) = 0
	then do;

	     /* <*symbol>|0 link */

	     block_type = "000001"b3;
	     seg_name = "000002"b3;
	     ent_name = "000000"b3;
	     end;

	else do;

	     /* ordinary link */

	     if grow
	     then block_type = "000005"b3;
	     else block_type = "000004"b3;

	     k = index (string, "$");

	     if k ^= 0
	     then do;				/* name of the form a$b */

		dollar_name = substr (string, 1, k - 1);/* get segment part of dollar name */
		seg_name = name_assign (dollar_name);

		/* different link required if common block name ends with $; it is illegal for */
		/* external reference names to end with $. */

		if k = length (string)		/* name ends with $ */
		then do;
		     ent_name = zero_def;		/* there is no entry name */
		     block_type = "000003"b3;		/* valid only for common block links */
		     end;
		else do;				/* reference of the form a$b; get entry name */
		     dollar_name = substr (string, k + 1);
		     ent_name = name_assign (dollar_name);
		     end;
		end;

	     else do;				/* no $ in name */

		ent_name = name_assign (string);

		if type = 0
		then seg_name = ent_name;
		else seg_name = "000005"b3;
		end;
	     end;

	def_ptr = addrel (def_base, def_pos);
	def_reloc_ptr = addrel (def_reloc_base, def_pos);

	link_ptr = addrel (link_base, link_pos);
	link_reloc_ptr = addrel (link_reloc_base, link_pos);

	def_ptr -> type_pair.type = block_type;

	def_ptr -> type_pair.trap_ptr = grow;
	if grow
	then def_reloc_ptr -> reloc (0) = rc_a_dp;

	def_ptr -> type_pair.seg_ptr = seg_name;
	def_ptr -> type_pair.ext_ptr = ent_name;
	if type = 0
	then def_reloc_ptr -> reloc (1) = rc_a_dp;
	else def_reloc_ptr -> reloc (1) = rc_dp_dp;

	addrel (def_ptr, 2) -> exp_word.type_ptr = bit (def_pos, 18);
	def_reloc_ptr -> reloc (2) = rc_dp;

	link_ptr -> head_address = -link_pos * binary (262144, 19);
	link_ptr -> link.ft2 = FT2_mod;		/* 46 octal */
	link_reloc_ptr -> reloc (0) = rc_nlb;

	link_ptr -> link.exp_ptr = bit (fixed (def_pos + 2, 18), 18);
	link_reloc_ptr -> reloc (1) = rc_dp;

	def_pos = def_pos + 3;

	return;

     end compile_link;

name_assign:
     procedure (name) returns (bit (18) aligned);

dcl  name character (*) aligned;
dcl  vname character (32) varying;

dcl  1 acc aligned based,
       2 count bit (9) unaligned,
       2 string character (n) unaligned;

dcl  n fixed binary (9);
dcl  (i, old_pos) fixed binary (18);
dcl  p pointer;

dcl  1 st aligned based (polish_base),
       2 acc_ptrs (0:next_free_polish - 1) pointer unaligned;

dcl  length builtin;

	/* trim the blanks from name */

	vname = substr (name, 1, length (name) - verify (reverse (name), " ") + 1);

	/* see if this acc string has already been used */

	do i = begin_forward_refs to hbound (acc_ptrs, 1);
	     p = acc_ptrs (i);
	     n = fixed (p -> acc.count, 9);
	     if length (vname) = n
	     then if vname = p -> acc.string
		then do;
		     old_pos = fixed (rel (p), 18) - defrel;
		     return (bit (old_pos, 18));
		     end;
	     end;

	/* build a new acc string */

	n = length (vname);
	p = addrel (def_base, def_pos);

	if next_free_polish < polish_max_len
	then do;
	     next_free_polish = next_free_polish + 1;
	     acc_ptrs (next_free_polish - 1) = p;
	     end;

	p -> acc.count = bit (n, 9);
	p -> acc.string = vname;

	old_pos = def_pos;
	def_pos = def_pos + divide (n + chars_per_word, chars_per_word, 17, 0);

	return (bit (old_pos, 18));

     end name_assign;

initialize_common:
     procedure (pt, len) returns (bit (18) aligned);

dcl  (h, s, pt, grow_pt, init_pt) pointer;
dcl  (len, init_val, sym) fixed binary (18);
dcl  (
     m,						/* length of LIST_TEMPLATE_INIT */
     n						/* length of TEMPLATE_INIT */
     ) fixed bin (18);
dcl  grow_info bit (18) aligned;
dcl  use_pool bit (1) aligned;

dcl  max_template_init_size fixed bin (18) static options (constant) init (256);

%include system_link_init_info;



	h = pt;
	n = len;

	if h -> header.alignment.character
	then n = divide (n + chars_per_word - 1, chars_per_word, 18, 0);

	if h -> header.initialed & n <= max_template_init_size
	then if fixed (rel (addrel (def_base, def_pos + n + mod (def_pos, 2)))) > max_linkage_size
	     then do;				/* CANNOT INIT ON PAIN OF DEATH */
		call print_message (469, h -> header.block_name, max_linkage_size - bias);
		h -> header.initialed = "0"b;		/* PULL OUT THE RUG */
		end;


	if h -> header.initialed
	then def_pos = def_pos + mod (def_pos, 2);

	grow_info = bit (def_pos, 18);
	grow_pt = addrel (def_base, grow_info);
	init_pt = addrel (grow_pt, 2);

	init_val = NO_INIT;

	if h -> header.initialed
	then if n > max_template_init_size
	     then do;
		m = 0;				/* presume no template generated */
		init_val = LIST_TEMPLATE_INIT;
		call list_initialize (addrel (init_pt, 1), fixed (rel (h), 18), m);
		grow_pt -> list_init_info.list_size = m;
		end;
	     else do;
		init_val = TEMPLATE_INIT;
		do sym = h -> header.first_element repeat s -> symbol.next_member while (sym > 0);
		     s = addr (rands (sym));
		     if s -> symbol.initial ^= 0
		     then call initialize_symbol (s, init_pt);
		     end;
		end;

	use_pool = init_val = NO_INIT & n <= hbound (def_pool, 1);
	if use_pool
	then if def_pool (n) ^= 0
	     then return (bit (def_pool (n), 18));

	grow_pt -> init_info.size = n;
	grow_pt -> init_info.type = init_val;

	if use_pool
	then def_pool (n) = def_pos;

	def_pos = def_pos + 2;
	if init_val = TEMPLATE_INIT
	then def_pos = def_pos + n;
	else if init_val = LIST_TEMPLATE_INIT
	then def_pos = def_pos + m + 1;
	return (grow_info);

     end initialize_common;

/**** DEFINITION SECTION ****/

generate_definition:
     procedure (name, class, value);

dcl  name character (*) aligned,			/* Symbol for definition */
     class fixed binary (3),				/* Class of definition */
     value bit (18) aligned;				/* Value of definition */

dcl  (def_ptr, def_reloc_ptr) pointer;
dcl  (b18, pos) bit (18) aligned;

dcl  rel_code (0:3) aligned bit (18) internal static options (constant) initial ("000000000000010000"b,
						/* Text */
	"000000000000010010"b,			/* Link 18 */
	"000000000000010110"b,			/* Symbol */
	"000000000000010101"b);			/* Definition */

%include definition;

	b18 = name_assign (name);

	pos = bit (def_pos, 18);
	def_ptr = addrel (def_base, pos);
	def_reloc_ptr = addrel (def_reloc_base, pos);

	if last_def
	then def_ptr -> definition.backward = last_def;
	else def_ptr -> definition.backward = zero_def;

	addrel (def_base, last_def) -> definition.forward = pos;

	def_ptr -> definition.forward = zero_def;

	def_ptr -> definition.new = "1"b;
	def_ptr -> definition.symbol = b18;
	def_ptr -> definition.value = value;

	def_ptr -> definition.class = bit (class, 3);

	if class = 3
	then seg_def = pos;
	else do;
	     def_ptr -> definition.segname = seg_def;
	     def_ptr -> definition.entry = class = 0;
	     end;

	def_reloc_ptr -> reloc (0) = rc_dp_dp;
	def_reloc_ptr -> reloc (2) = rc_dp_dp;
	def_reloc_ptr -> reloc (1) = rel_code (class);

	last_def = pos;
	def_pos = def_pos + 3;

     end generate_definition;

gen_entry_defs:
     procedure ();

	/* Generates entry definitions and finishes up entry sequences */

dcl  desc fixed bin (18);
dcl  (s, def_ptr) pointer;
dcl  (sym, stack_size) fixed binary (18);
dcl  text_pos fixed binary (18);

%include definition;

	stack_size = divide (last_auto_loc + 15, 16, 17, 0) * 16;

	do sym = first_entry_name repeat s -> symbol.next_symbol while (sym > 0);
	     s = addr (rands (sym));
	     text_pos = s -> label.location;		/* a slight kludge */

	     /* fill in stack_size (must be multiple of 16) */

	     text_halfs (text_pos).left = stack_size;

	     /* generate entry definition */

	     call generate_definition (s -> symbol.name, 0, bit (text_pos, 18));

	     reloc_halfs (text_pos - 1).left = rc_dp;

	     unspec (text_halfs (text_pos - 1).left) = last_def;
	     def_ptr = addrel (def_base, last_def);

	     if assembly_list
	     then a_name (text_pos - 1) = -1;		/* tell listing generator this is not an inst */

	     def_ptr -> definition.retain = "1"b;

	     /* process entry definitions */

	     parm_desc_ptrsp = addr (text_halfs (text_halfs (text_pos - 2).left));
	     do i = 1 to parm_desc_ptrs.n_args;
		desc = parm_desc_ptrs.descriptor_relp (i);
		parm_desc_ptrs.descriptor_relp (i) = addr (rands (desc)) -> label.location;
		end;
	     end;
     end gen_entry_defs;

effective_operand:
     proc (opnd) returns (fixed bin (18));

	/*  Function to replace an operand by its effective value.  */

dcl  opnd fixed bin (18);				/* incoming operand */

dcl  op fixed bin (18);				/* outgoing operand */
dcl  p ptr;					/* pointer to symbol */

	op = opnd;
	if op > 0
	then do;
	     p = addr (rands (op));
	     if p -> node.node_type = label_node
	     then if p -> label.format
		then do;
		     op = p -> label.format_var;
		     p = addr (rands (op));
		     end;
	     if p -> node.node_type = symbol_node
	     then if p -> symbol.named_constant
		then op = p -> symbol.initial;
	     end;
	return (op);
     end effective_operand;
     end code_generator;

     end ext_code_generator;
