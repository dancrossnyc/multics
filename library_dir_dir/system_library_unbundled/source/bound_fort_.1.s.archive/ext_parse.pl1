/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1987 *
        *                                                         *
        * Copyright, (C) Honeywell Limited, 1983                  *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(86-07-14,BWong), approve(86-07-14,MCR7286), audit(86-07-17,Ginter),
     install(86-07-28,MR12.0-1105):
     Fix fortran bugs 457, 458, 461, and 463.
  2) change(86-07-14,BWong), approve(86-07-14,MCR7382), audit(86-07-17,Ginter),
     install(86-07-28,MR12.0-1105):
     Fix fortran bugs 122, 389, 396, 428, 470, 473, 481, and 482.
  3) change(86-07-14,BWong), approve(86-07-14,MCR7442), audit(86-07-17,Ginter),
     install(86-07-28,MR12.0-1105):
     Fix fortran bugs 410, 497, and 498.
  4) change(87-04-15,Huen), approve(87-04-15,MCR7651), audit(87-04-15,RWaters),
     install(87-05-08,MR12.1-1031):
     Fix fortran bugs 479 and 431.
  5) change(87-06-23,RWaters), approve(87-06-23,MCR7703), audit(87-07-10,Huen),
     install(87-08-06,MR12.1-1069):
     Implemented SCP 6315: Added a fortran runtime error-handler argument.
  6) change(88-02-29,Huen), approve(88-02-29,MCR7846), audit(88-03-07,RWaters),
     install(88-03-15,MR12.2-1036):
     Fix bug 506: Do not always assign bp -> header.units to char_units
     whenever the first element of  the common block is of character type.
  7) change(88-04-28,RWaters), approve(88-04-28,MCR7875), audit(88-07-13,Huen),
     install(88-11-10,MR12.2-1209):
     Implement SCP 6339:  Allow  character variables to be up to 128K-1
     (131071) character long.
  8) change(89-06-14,RWaters), approve(89-06-14,MCR8115),
     audit(89-07-21,Blackmore), install(89-07-31,MR12.3-1065):
     Fix bug 511; error in format statements > 512 chars long.
  9) change(91-11-06,Huen), approve(91-11-06,MCR8246), audit(91-11-25,Vu),
     install(91-12-11,MR12.5-1004):
     Fix Fortran compiler (ft_514) to be able to consistently diagnose errors
     when the VLA size is greater than the maximum value.  The maximum value is
     (2**24 - 1) words long.
                                                   END HISTORY COMMENTS */


/* format: style3,^indattr,linecom,ifthendo,ifthen,^indnoniterdo,^elsestmt,dclind9 */
ext_parse:
     procedure (p, q);

/* Created:	June 1976, David Levin

   Modified:
          15 May 87, RW SCP 6315 added the -debug_io argument, set
                    io_bits.debug according to subr_options.debug_io;
          23 Feb 87, SH & RW - 431: Allow substrings in equivalence
                    statements in ansi77 mode.
          02 Jan 87, SH - 479: Whenever a left parenthesis prior to
                    an input list item in a set context, display 
                    additional information "A redundant parenthesis
                    was encountered." after the error message 95.
          21 Mar 86, NS - 498: Put in check for invalid unit numbers.
          18 Mar 86, NS - 497: Check for the typeless function fld.
          08 Mar 86, SH - 410: Allow builtin functions to be declared 
                    in external statements in ansi66 mode. Update the
                    bif_table.external table and delete the intrinsic
                    include file.
	28 Feb 86, BW - 428.a: Make minor declaration changes:
		o default_char_size only needs to be increased from
		  fixed bin (9) to fixed bin (10)
		o token can be left as bit (9) aligned
		o token_list structure is padded to make it word aligned
		o temp_str only needs to be increased from char (256)
		  to char (512).
	27 Feb 86, BW - 461.a: Fix error introduced with the character
		equivalencing.  Block lengths were calculated larger then
		they should be causing unnecessarily large text sections.
	19 Feb 86, BW & AG - 473.a: Fix allowing individual storage classes 
		(automatic, static, parameter, or common) to be addressed
		as VLA's or LA's.  Move code to set maximum array sizes
		from fort_defaults_$check_global_args to the new routine
		set_max_array_size so the values are set properly.
          12 Dec 85, NS, MM, & BW - 482: Change the default in precision of 
                    an unsupported REAL type from single to double precision.
          12 Dec 85, NS, MM, & BW - 481: Warn user of a change in the 
		precision of a real variable from that in which it was
     		declared.
          11 Dec 85, NS - 389: Warn user of a complex type declaration of
                    precision other than single precision.
          05 Dec 85, RW - 396: Stop compiler from changing automatics into
		named constants if they are in equivalence statements.
          29 Nov 85, RW - 428: Allow strings up to 512 (up from 256)
          25 Nov 85, RW - 122: Changed max number of items in a format 
                    statement to 1023 (up from 510)
	09 Oct 85, BW - 473: Allow individual storage classes (automatic,
		static, parameter, or common) to be addressed as
		VLA's or LA's.
	26 Sept 85, BW - 470: Use only the significant digits of real and
		double precision constants when converting from
		character to floating point representation.
	02 Aug 85, BW - 463: Removed code to set must_save_stack_extent.
		The saving will no longer be done because of fortran_io_
		problems.
	16 Jul 85, MM & BW - 461: Allow character variables and
		non-character variables to be equivalenced in ansi77.
          12 Jun 85, BW - 458: Suppress generation of error messages for
                    compiler generated symbols.
          12 Jun 85, BW - 457: Correct cross referencing of format statements
                    which are declared before they are referenced.
	22 Mar 85, MM - 433: Correct the polish for the bypass label that
		is emitted around entry statements.  The label itself must
		fall on the end of the last entry statement - not on the
		following statement.
          12 Aug 84, BW - 435: Generate correct polish for entry points
                    followed by non-executable statements only.
          03 Aug 84, BW - 434: Allow option names of up to 32 characters.
	22 Jun 84, MM - Install typeless functions support.
	25 Apr 84, HH - 424: Argument type & shape specification disallowed
		after 1st executable statement.
	13 Apr 84, MM - 419: Generate correct polish for routines that do
		not contain executable statements.  
	12 Apr 84, BW - 418: Correct lexer error which occurred when a
		Hollerith string was followed by a labelled statement.
	28 Mar 84, MM - Install HFP support.
	05 Dec 83, HH - 412: Prevent possible endless loop when checking
		for branches into do-loops in '77 mode.
	16 Sep 83, RG & MM - 242/370: Pass ptr (symbol.general) to arg_desc in entry node.
	14 Aug 83, HH - 387: Allow substrings as targets in DATA statements.
	14 Aug 83, HH - 386: Generalize expressions in DATA statements to
		comply with the '77 Standard.
	12 Jul 83, MM - 379: Give more consistancy to compilation options.
	 4 Jul 83, RG - 385: To allow conversions to integer in DATA statements
	19 Jun 83, HH - 145: Disallowing branching into do-loops in '77 mode.
	17 Jun 83, HH - 383: Make adjustable arrays conform to the Standard
		in '77 mode.
	10 May 83, MM - 375: Allow common variables to be initilized to 0.
	10 May 83, RG - 174: Allow include files to be archive components.
	10 Feb 83, HH - Install LA/VLA support.
	21 Oct 82, TO - 360: Add default 'UNIT=' to INQUIRE.
	21 Oct 82, TO - 362: Add parsing for 'CHARACTER*(*) FUNCTION f ('.
	14 May 82, TO  - Modify extraneous text error for parenthesis test.
	 5 May 82, TO  - Save stack extent if char_star_function is only one.
	22 Mar 82, TO  - Fix navy test bug 1, label with code on continuation lines only.
	22 Mar 82, TO  - Fix navy test bug 2, lack of comma in assigned goto.
	18 Mar 82, TO  - Fix bug 296 - implied IO do loop gets errors on left_parn of expression.
	17 Mar 82, TO  - Fix bug 326 - assign lex doesn't know about logical if with substr assign target.
     	16 Mar 82, TO  - Fix bug 269 - incorrect line number reporting.
	12 Mar 82, TO  - Fix bug 320 - failure to detect duplicate entries.
	17 Dec 81, MEP - Fix bug in doubly subscripted implied do in data statement.
	15 Dec 81, MEP - Fix bugs in label_const parsing (*<int>) and filed length in mode statements.
	14 Dec 81, MEP - Fix unreported bug in parsing of * as unit number.
	4 Dec 81, MEP - Fix bug 257 allow proper equivalencing of ansi66 and ansi77 arrays
	19 Nov 81, MEP - Fix bug 246 too many constants for variable list in data statment
	17 Nov 81, MEP - Fix bug 327 not allow chars and non-chars in fortran 77 equiv groups
	17 Nov 81, MEP - Fix bug 328 on external (descriptors) character functions in ansi_77.
	16 Nov 81, MEP - Fix bug 323 on lacking s permission of include file's directory.
	13 Nov 81, MEP - Fix unreported bug in typed functions
	22 Oct 81, MEP - Added code for INQUIRE statement.  Changed parse_open_field to have parameter
		for expression_type.
	1 Oct 1981, MEP - Fortran 77 internal files
	5 August 1981, MEP - Fixed bug 324, incorrect tally of stack high-water mark
	16 July 1981, MEP - Completion of ASSIGN with format labels
	14 July 1981, MEP - Full ansi77 format specifiers
	30 June 1981, MEP - Allow format statements to be objects of ASSIGN TO
	June 1981, MEP - Finished alteration to REWIND, etc.  Began changes for new 
		READ/WRITE specifications.
	1 June 81, MEP - Alterations to parse_parameter_list, and argument list of statement functions to
		allow functions with no arguments.
	20 May 81, MEP - Alterations in the lex to allow blank lines to be comments in ansi77
	12 May 81, MEP - Added code for INTRINSIC statement.
     	11 May 81, MEP - Added code for .EQV., .NEQV., and SAVE /common-block-name/
	4 May 81, MEP - Added code for new features in rewind, backspace, and  endfile statements.
	3 May 81, MEP - Minor changes per CRD's audit for array and data changes.
	29 Apr 81, MEP - Program statement and named block data subprogs.
	11 Mar 81, MEP - Began the enhancements for ansi77 array declarators
	22 Feb 81, MEP - Fixed bug 307 (blank common not recognized unless first in common statement and bug 305
		(parse fails when identifier continued onto next line and next char is not letter or digit).
	26 January 1981, CRD - Improve interaction of elseif statement with
		profile and breakpoints.
	 5 January 1980, MEP - Added code to handle illegally referenced labels
	31 December 1980, MEP - Added a field in statement_attributes for warnings on labelled statements 
	29 December 1980, MEP - Cleaned up the error handling for improperly nested do's and block if's.
	15 December 1980, MEP - Added code that manipulates the do_blockif_stack, formerly the do_stack for nested do loops
		and the code for the parsing of block if's.
	19 November 1980, CRD - Fix bug in which array_size was computed for
		star extent arrays instead of leaving it to later phases.
	24 October 1980, CRD - Added new intrinsics for Fortran 77.
	8 October 1980, CRD - Fixed bug 283.  Lex was not properly handling
		hollerith constants which need to be blank padded but are
		not continued.
	29 September 1980, CRD - Fixed bug 281.  Changed the lex not to make
		substr_left_parn tokens; and invented the subroutine
		get_next_token$paren_operator which differentiates between
		left_parn and substr_left_parn by scanning the token list.
		parse_expression calls this new subroutine, as it is the 
		only place which needs to differentiate.
	17 September 1980, CRD - Fixed bug 277: %include lex was not
		stripping white space properly.  Also fixed bug 268:
		fold keyword not allowed in %options or %global.
	31 July 80, MEP - Added code to allow evaluation of fortran 77
		parameter statements
	29 July 80, CRD - Fix bug in declaration processing of entry_points.
	16 July 80, MEP - Set symbol.variable_arglist in external statement.
	10 June 80, MEP - Added code to set must_save_stack_extent iff more
		than one subprogram and char star-extent variables seen.
	5 June 80, MEP - Changed parse to properly set needs_descriptors bit
		for all entry points.  This is done if any of the formal parameters
		is star_extents or the function itself is.
	16 May 80, MEP - Added code to set io_bits.ansi_77 so that character array i/o
		is handled correctly in both modes.
	09 May 1980, MEP - Fixed two bugs in character mode.  The first
		bug was that the use of two substered variables in an expression was mishandled.
		The second was that a reference to an unsubscripted substered variable failed to
		correctly set the variable bit in symbol.attribute.
	01 May 1980, MEP - Removed the builtins until such time as the required
		alterations to the back end are implemented.  Also fixed a bug in which subscripted
		substered references are correctly handled.
	04 Apr 1980, MEP - Add the new builtins sinh, cosh, dcosh, dtanh,
		dsinh.  Also fix bug to make tan externable.
	04 Apr 1980, PES - Fix uninitialized subroutine_options bug.
	18 Dec 1979, PES - Change parse to emit (read write)_namelist_op rather than namelist_op
		when optimizing, to fix bug 249, in which the optimizer appears to ignore the 
		fact that a namelist read sets the values in the namelist.  Eliminate all
		references to the obsolete bit symbol.need_word_count.
	06 Dec 1979, PES - Multiplied all positive precedences in parse_expression by 10, to ease
		addition of new operators.  Since only relative values are  supposed to matter, this
		should have no visible effect.
	27 Nov 1979, PES - Fix bug 248, in which symbol.in_equiv_stmnt is not set for a
		variable which is in both a common block and an equivalence statement.
	26 Sep 1979, PES - major butchery for new CHARACTER mode.  Make comma in assigned goto
		statement optional.
	02 Sep 1979, PES - Fix bug 206, in which certain unfortunate placements of delimiters in
		card-image format statements could cause spurious error 134 messages.
	02 Sep 1979, PES - Allow multiple namelist declarations to refer to same namelist, if
		they are consecutive statements; fix unreported bug in multiple segment
		handling; minor cleanups; allow optional comma in COMMON statements declaring
		multiple commons; change to allow blank lines before %options and %global
		statements; slightly limit the free form check for unintended comment lines;
		fix an unreported namelist bug in which if the first ref to a namelist was in a
		write any following refs in a read would not cause the namelist members to be
		marked set; fixed an unreported namelist bug in which namelist names were
		always listed in the "not referenced" list, with proper cross-reference info;
		changed namelist so that a namelist reference is also cross-referenced as a
		reference to each member; and fixed bug 208, in which variables on the lhs of
		the first assignment statement might be multiply cross-referenced.
	18 Jul 1979, PES - fix bug 211 in which fortran incorrectly evaluates a**b**c as
		(a**b)**c, rather than as a**(b**c).  Also adds diagnosis of possible
		unintended comments in free format input.  Also correct an error in handling of
		encode/decode statements when the string is an entire character array,
		introduced by the fix to 222/223.
	13 Jul 1979, CRD - initialize io_bits.fold to implement fortran_io_ suggested improvement
		078 (case insensitive namelist input with -fold or -card).
	12 Jul 1979, PES - changes to fix bug 222 and implement suggested improvment 223, both
		having to do with encode/decode problems; and to fix various unreported bugs in
		encode/decode.  Also, allow the optional comma after the statement number in a
		do statement, as permitted by the 77 ANSI Standard.
	05 Jul 1979, PES - fixes bug 219 in which an uninitialized variable in the parse may
		cause the listing generator to fault.
	03 Jul 1979, PES - fix uninited variable which caused misc faults.
	12 Jun 1979, PES - major butchery for new PARAMETER statement.
	07 Jun 1979, PES - fixes bug 210 in which the parse will generate a spurious error 125
		message (data type of entry does not match data type of function) if the data
		type of a function entry does not match the default data type of the primary
		function name.
	14 Mar 1979, PES - serious modifications towards include file handling.
	28 Feb 1979, PES - fixes bug 202 in which a missing ; on an %options or %global statement
		will cause the parse to fault.
	8 Jan 1979, RAB - fixes bug 200 in which equivalence alignment is wrong if the second
		item in a pair belongs to a header that is further to the left than the first
		item and difference is odd.
	13 Dec 1978, PES -fixes bug in which named constants are not marked as referenced, and
		bug in which fort_converter does not properly handle string_op.
	12 Dec 1978, PES - fixes bug 189 in which the compiler does not diagnose statements of
		the form "x+y = exp".  If optimizing, such a statement causes a fault; if not
		optimizing, useless code is produced.
	06 Dec 1978, RAB - fixes 193 in which missing comma in implied do causes fault.
	06 Dec 1978, PES - Implement %options and %global--change implementation of octal
		constants to match old_fortran.
	25 Oct 1978, PES - Changes for larger common and arrays.
	25 Sep 1978, PES - Change to fix bug 188, in which block data fails if data statements
		for a common block contain only equivalenced variables and do not contain any
		variables actually appearing in the common statement.
	06 Sep 1978, PES - Change so variables read by namelist directed read are marked as set.
	31 Aug 1978, PES - Change to the constants used by convert_real to check real number
		magnitudes before conversion.  Both original values were too small, meaning:
		(1) That certain very large real constants would not be accepted, even though
		they were proper values; and (2) that certain very small magnitude real
		constants could cause the compiler to take an underflow fault , instead of
		being diagnosed as errors.
	19 July 1978, PES - Fix to relaxed statment ordering, to again permit variables to be
		declared in common after they have been declared equivalenced.  This feature
		was broken by the last change.
	20 June 1978, DSL - Fixes to declaration processing.  Bug fixed in which a variable can
		have two storage classes because default storage class was applied before(!)
		equivalence processing; improved processing of invalid equiv groups; set
		symbol.equivalenced when equiv st is parsed, rather than when dcl processor is
		run.  See comments concerning this parse design change under equiv st parser
		#13.
	12 June 1978, DSL - Have "declaration_processor" set storage class as well as data type
		for all variables, and data type for all ext funcs.  Declare alternate return
		symbol as a variable (bug fix).
	25 May 1978, DSL - Fix bug 157 correctly so compiler will not fault if label > 999999.
		Move create_node to include file.  Insure that statement.put_in_profile and
		statement.put_in_map are always set correctly.
	18 May 1978, DSL - Final fix to bug 144 in which dcl for based_double assumed double word
		alignment for all dp values; fix bug in which text of first statement appears
		as text for main entry point entry sequence; fix bug 158 in which data type for
		float bif is erroneously d.p.; fix bug 157 in which parse faults trying to
		print error message for label > 131071.
	2 May 1978, dsl - minor code changes for v2 opt; also clean up a_complex_constant.
	26 April 1978, DSL - Fix introduced bug in which label parsing was broken.  Other small
		fixes.
	18 April 1978, DSL - Set symbol.set for a format if it is ref'd in a read st and
		contains_hollerith; fix bug 151 in which parse neglects to set symbol.ref'd
		(etc.) for parameter bounds.
	7 April 1978, DSL - Move complex constant processing from lexical analyzer to expression
		parser; fix introduced bug in optimizer in which parse does not force data type
		of a symbol before deciding how much temp space it needs; change card-image lex
		to supply blanks for lines less than 72 chars in length.
	28 March 1978, DSL - Finish relaxed statement ordering; allow another form of function
		statement; fix bug 144 in which conversion from dp to real fails because dcl of
		based_double is wrong.

******************  Converted to version 2 optimizer.  ******************

	28 February 1978, DSL - Change logic to allow statements to appear in any order.  The
		only surviving restrictions are: a) declaratives must precede first reference;
		b) all statement func.  defs.  must precede all other executables.
	2 February 1978, DSL - Mark return statement code generated by an end line as being
		executable.
	1 February 1978, DSL - Fix post-parse declaration processor to set all symbol.data_type
		and symbol.element_size.
	29 December 1977, DSL - Fix bug 124 so that -3435...  (-2**35) is accepted in a data
		specification; fix bug 126 so that cg will not fault on an unreferenced
		st.func.  def.; fix bug 137 so that max number of consts is 500, not 200.
		Also, some changes were made in preparation for relaxing all stmnt order
		requirements.  Also, fixed unreported bug in which char func with different
		lengths declared at each entry point would not be diagnosed, although compiler
		does not handle this case correctly.  Also, modified data spec parse to allow
		char consts and octal consts for all data type.  Data spec parse no longer
		limits the number of error msgs it prints.  print_message is made responsible.
	30 August 1977, D Levin - print message if subr or func ref has too many args;
		NOTE - value of bias changed from 65536 to 131072.
	18 July 1977, David Levin - fix bugs in open and close.
	30 June 1977, David Levin - 1) new fort_system_constants.incl.pl1; 2) open and close
		statements; 3) move block data code from fort_ to here.
	26 May 1977, David Levin - data parser printed random stuff instead of octal constant in
		error msg.
	2 May 1977, David Levin - for new fort_system_constants.incl.pl1 and changes for implied
		do loop optimization and bug fix for stop/pause.
	22 April 1977, David Levin - convert long real const (>8) to dp; warn user if char var
		init'ed with const too long; fix bug in warning msg.
	14 April 1977 David Levin - small optimizer fix; add 6 new builtin functions.
	25 March 1977 David Levin - fix for char const as fmt; set label.referenced_executable.
	24 February 1977 Gabriel Chang - to emit a zero operand for not, and negate operators and
		emit no_ops for complicated subscripts for optimization.
	10 February 1977 David Levin - fix bug in equiv stmnt; improve lex for real constants.
	24 January 1977 David Levin - minor tuning; prepare for the addition of optimizer changes.
	19 January 1977 David Levin - bug fix for data stmnt parser.
	14 September 1976 David Levin - listing addition bug fixes, some error msg clean up.
	9 September, 1976 David Levin - bug fixes for listing additions.
*/

dcl      p pointer;
dcl      q pointer;
dcl      parse_ptr pointer;
dcl      shared_ptr pointer;
dcl      polish_string (0:polish_max_len - 1) fixed bin (19) aligned based (polish_base);
dcl      polish_base ptr;
dcl      operand_base ptr;
dcl      object_base ptr;
dcl      cref_base ptr;
dcl      source_line_base ptr;
dcl      listing_base ptr;
dcl      polish_max_len fixed bin (19);
dcl      object_max_len fixed bin (19);
dcl      1 max_array_size,
	 2 auto fixed bin (24),
	 2 char fixed bin (24),
	 2 common fixed bin (24),
	 2 parm fixed bin (24),
	 2 static fixed bin (24);

dcl      1 segment_options aligned like fortran_options;
dcl      1 subr_options aligned like fortran_options;
dcl      1 segment_declared aligned like fortran_declared;
dcl      1 subr_declared aligned like fortran_declared;

dcl      1 parse_structure aligned based (parse_ptr),
%include fort_parse_vars;

dcl      1 shared_structure aligned based (shared_ptr),
%include fort_shared_vars;
%include fort_options;
%include fort_system_constants;
%include fort_nodes;
%include fort_listing_nodes;
%include std_descriptor_types;

	parse_ptr = q;
	shared_ptr = p;

	polish_base = shared_structure.polish_base;
	operand_base = shared_structure.operand_base;
	object_base = shared_structure.object_base;

	if shared_structure.options.map then do;
	     cref_base = shared_structure.cref_base;
	     source_line_base = shared_structure.source_line_base;
	     listing_base = shared_structure.listing_base;
	end;

	polish_max_len = shared_structure.polish_max_len;
	object_max_len = shared_structure.object_max_len;
	max_array_size.char = sys_info$max_seg_size;
	call set_max_array_size;
	call parse_source (source_info_ptr);
	return;

set_max_array_size:
     procedure;

	if shared_structure.options.VLA_auto then
	     max_array_size.auto = max_fixed_bin_24;
	else
	     max_array_size.auto = sys_info$max_seg_size;
	if shared_structure.options.VLA_parm then
	     max_array_size.parm = max_fixed_bin_24;
	else
	     max_array_size.parm = sys_info$max_seg_size;
	if shared_structure.options.VLA_static then
	     max_array_size.static = max_fixed_bin_24;
	else
	     max_array_size.static = sys_info$max_seg_size;
	if shared_structure.options.VLC then
	     max_array_size.common = max_fixed_bin_24;
	else
	     max_array_size.common = sys_info$max_seg_size;
	return;
     end;

%include fort_utilities;

parse_source:
     procedure (src_info_ptr);

/*	Program Specifications (parse_source)

     Inputs

     Output

     Description - This routine parses one or more source segment and produces
	the intermediate representation. Before each subprogram is parsed,
	all local work areas are reinitialized. This includes the operand table (or symbol table),
	the segment containing the intermediate representation of each statement, etc.

	Each symbol table is independent except there is a single thread which runs through
	all symbols in all segments compiled. There are similar threads for constants and labels.

	Each subprogram compiled produces a block of independent intermediate text. This text is
	preceded by a header which indicates subprogram name and type, and some switches. One switch
	indicates whether or not the intermediate text should be skipped or compiled. This switch
	will be used primarily to prevent the compilation of more than one subprogram with the
	same name.

*/

dcl      COLON_BEFORE_ASSIGN bit (1) aligned;
dcl      BEGIN_DO_LOOP fixed bin (18) static options (constant) init (-1);
declare	CURRENT_VALUE fixed binary (18) internal static options (constant) initial (1);
dcl      DECLARED bit (5) aligned int static options (constant) init ("0"b);
dcl      DIGIT char (10) aligned int static options (constant) init ("0123456789");
declare	END_DO_LOOP fixed binary (18) internal static options (constant) initial (-2);
declare	END_DO_LOOP_SIZE fixed binary (18) internal static options (constant) initial (1);
dcl      END_DO_RANGE bit (1) aligned;
dcl      FALSE bit (1) aligned int static options (constant) init ("0"b);
dcl      GOTO_REF bit (5) aligned int static options (constant) init ("10101"b);
dcl      GOTO_TARGET bit (5) aligned int static options (constant) init ("11101"b);
dcl      INIT bit (5) aligned int static options (constant) init ("00001"b);
declare	INITIAL_EXPRESSION fixed binary (18) internal static options (constant) initial (2);
dcl      NO_NAME char (8) unaligned int static options (constant) init ("");
dcl      NOT_SET bit (1) int static options (constant) init ("0"b);
dcl      NULL_STRING char (0) int static options (constant) init ("");
dcl      ONE fixed bin (18) int static options (constant) init (1);
dcl      OS (0:operand_max_len - 1) bit (36) aligned based (operand_base);
dcl      PASSED bit (5) aligned int static options (constant) init ("10110"b);
dcl      REF bit (5) aligned int static options (constant) init ("10100"b);
dcl      SECOND_EQUALS bit (1) aligned;
dcl      SET bit (5) aligned int static options (constant) init ("11100"b);
dcl      SET_ATTR bit (1) int static options (constant) init ("1"b);
dcl      SI fixed bin (18);
dcl      SKIP fixed bin (18) static options (constant) init (0);
dcl      SUBSCRIPTED_VAR fixed bin (18) static options (constant) init (-4);
dcl      SUBSCRIPTED_SUBSTR fixed bin (18) static options (constant) init (-5);
dcl      SUBSTR fixed bin (18) static options (constant) init (-3);
declare	SYMBOL_INDEX fixed binary (18) internal static options (constant) initial (1);
dcl      TRUE bit (1) aligned int static options (constant) init ("1"b);
dcl      ZERO bit (1) aligned int static options (constant) init ("0"b);
dcl      max_char_var_length fixed bin (21) internal static options (constant) init (131071);

dcl      abs builtin;
dcl      addr builtin;
dcl      after_subprogram fixed bin (18) int static options (constant) init (11);
dcl      all_attributes bit (47) aligned int static options (constant)
	    init ("11111111111111111111111111111111111111111111111"b);
dcl      allow_star_after bit (1) aligned;
dcl      alphabetic char (52) aligned int static options (constant)
	    init ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
dcl      alternate_return_index fixed bin (18);
dcl      any_label bit (2) aligned int static options (constant) init ("00"b);
dcl      arg_type bit (36) aligned;
dcl      asf_attribute bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000000000010000000000000"b);
dcl      asf_conflicts bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000111111111111111110000"b);
dcl      asf_definition fixed bin (18) int static options (constant) init (28);
dcl      assign_ entry (ptr, fixed bin, fixed bin (35), ptr, fixed bin, fixed bin (35));
dcl      assignment_statement fixed bin (18) int static options (constant) init (60);
dcl      assignment_statement_index fixed bin (18);
declare	asterisk_seen bit (1) aligned;
dcl      attr_table (0:6) bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000000000000000000000000"b,
	    "00000000000000000000100000000000000000000000000"b, "00000000000000000000010000000000000000000000000"b,
	    "00000000000000000000001000000000000000000000000"b, "00000000000000000000000100000000000000000000000"b,
	    "00000000000000000000000010000000000000000000000"b, "00000000000000000000000001000000000000000000000"b);
dcl      attributes bit (47) aligned;
dcl      auto_attribute bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000000000000010000001000"b);
dcl      b72_one bit (72) aligned int static options (constant)
	    init ("100000000000000000000000000000000000000000000000000000000000000000000000"b);
dcl      b72_zero bit (72) aligned int static options (constant)
	    init ("000000000000000000000000000000000000000000000000000000000000000000000000"b);
dcl      bad_type fixed bin (18);
dcl      based_bit_72 bit (72) aligned based;
dcl      based_char char (8) aligned based;
dcl      based_integer fixed bin (35) based;
dcl      based_real (2) float bin (27) based aligned;
dcl      based_words (512) bit (36) aligned based;
dcl      before builtin;
dcl      begin_char fixed bin (18);
dcl      bif_conflicts bit (47) aligned int static options (constant)
	    init ("11111111111111111111000011111110011111111111000"b);
dcl      binary builtin;
dcl      bit builtin;
dcl      bit_mask (4) bit (36) aligned int static options (constant)
	    init ("111111111000000000000000000000000000"b, "111111111111111111000000000000000000"b,
	    "111111111111111111111111111000000000"b, "111111111111111111111111111111111111"b);
dcl      bit_value bit (9) aligned;
dcl      bypass_first_pending_entry bit (1);
dcl      card_image bit (1) aligned;
dcl      char builtin;
dcl      char_index fixed bin (20);
dcl      char_siz fixed bin (18);
dcl      char_temp char (1320) aligned;			/* Refer to procedure "create_format" before changing. */
dcl      char_type fixed bin (18);
dcl      char_value char (1) aligned based (addr (bit_value));
dcl      code fixed bin (35);
dcl      common_name char (256) varying;
dcl      common_storage bit (3) aligned int static options (constant) init ("001"b);
dcl      const_index fixed bin (18);
dcl      const_count fixed bin (18);
dcl      constant_type (6) bit (9) aligned int static options (constant)
	    init ("001100110"b, "001100111"b, "001101000"b, "001101001"b, "001000010"b, "001000001"b);
dcl      continuation_line fixed bin (18) int static options (constant) init (2);
dcl      copy builtin;
dcl      count fixed bin (18);
dcl      cp_count fixed bin (18);
dcl      cp_label_count fixed bin (18);
dcl      cur_paren fixed bin (18);
dcl      cur_segment fixed bin (18);
dcl      cur_stmnt_ptr pointer;
dcl      current_character char (1) aligned;
dcl      current_parameter fixed bin (18);
dcl      current_token fixed bin (18);
dcl      decimal builtin;
dcl      decode_statement fixed bin (18) int static options (constant) init (44);
dcl      default_char_size fixed bin (10);
dcl      default_table (52) bit (47) aligned;
declare	default_unit_specifier fixed binary (18);
dcl      defined fixed bin (18);
dcl      dim_attr bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000000000000100000001000"b);
dcl      dim_conflicts bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000111111111100000110000"b);
dcl      dim builtin;
dcl      digits fixed bin (18) int static options (constant) init (3);
dcl      divide builtin;
dcl      do_index fixed bin (18);
dcl      do_info (8) fixed bin (18);
dcl      do_level fixed bin (18);
dcl      do_statement fixed bin (18) int static options (constant) init (61);
dcl      dp pointer;
dcl      (E_start, E_finish) fixed bin;
dcl      E_token fixed bin;
dcl      elseif_statement fixed bin (18) int static options (constant) init (30);
dcl      else_statement fixed bin (18) int static options (constant) init (31);
dcl      end_char fixed bin (18);
dcl      end_line fixed bin (18) int static options (constant) init (64);
dcl      end_of_line fixed bin (18);
dcl      end_possible bit (1) aligned;
dcl      entry_point_conflicts bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000111111111111111111000"b);
dcl      entry_value bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000000001000000000000000"b);
dcl      entry_value_conflicts bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000110010011111110111000"b);
declare	equivalence_statement fixed bin (18) int static options (constant) init (14);
dcl      equiv_conflicts bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000111111111000001110000"b);
dcl      error bit (1);
dcl      error_code fixed bin (35);
dcl      executable_label bit (2) aligned int static options (constant) init ("01"b);
dcl      ext_attributes bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000000001000000000000000"b);
dcl      ext_conflicts bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000111111111111110111000"b);
dcl      fast_lookup char (24) unaligned defined (full_name);
dcl      fields_specified bit (72) aligned;
dcl      file_number fixed bin (8) init (0);
dcl      file_number_pic picture "zzz-";
dcl      file_stack_depth fixed bin (17);
dcl      first_mode_keyword fixed bin (18) int static options (constant) init (15);
dcl      first_time bit (1) aligned;
dcl      first_token fixed bin (18);
dcl      first_word fixed bin (18);
dcl      fixed builtin;
dcl      fold_option bit (1) aligned;
dcl      force_symtab_entry fixed bin (2) int static options (constant) init (2);
dcl      format_label bit (2) aligned int static options (constant) init ("10"b);
dcl      format_label_attributes bit (47) aligned int static options (constant)
	    init ("00000000000000000000000001000000000001000001000"b);
dcl      fort_defaults_$global ext entry (ptr, fixed bin, ptr, entry);
dcl      fort_defaults_$check_global_args ext entry (ptr, ptr, entry);
dcl      fort_defaults_$init_shared_vars external entry (ptr);
dcl      fort_defaults_$option ext entry (ptr, fixed bin, ptr, ptr, ptr, bit (1) aligned, bit (1) aligned, entry);
dcl      fort_defaults_$set ext entry (ptr, ptr);

declare	fort_eval_parm ext entry (ptr, char (*), fixed bin (35));
dcl      free_chain fixed bin (18);
dcl      from_data_parser bit (1) aligned;
dcl      full_name char (256) unaligned;
dcl      func_conflicts bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000110110111111110111000"b);
dcl      func_ref_attribute bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000001001000000000000000"b);
dcl      function_attribute bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000001010000000000100000"b);
declare	function_statement fixed binary (18) internal static options (constant) initial (4);
dcl      general_format_parse_ entry (char (1320) aligned, char (4096) aligned, bit (1) aligned, fixed bin (35));
dcl      hash_table (0:210) fixed bin (18);
dcl      have_auto_option bit (1) aligned;
dcl      have_auto_stmnt bit (1) aligned;
dcl      have_save_stmnt bit (1) aligned;
dcl      have_static_option bit (1) aligned;
dcl      have_subscript bit (1);
dcl      hbound builtin;
dcl      i fixed bin (18);
dcl      ignore_bits bit (36) aligned;
dcl      ignore_octal_value bit (72) aligned;
dcl      ignore_symtab_entry fixed bin (2) int static options (constant) init (0);
dcl      ignore_value fixed bin (18);
dcl      impossible_align bit (2) aligned int static options (constant) init ("11"b);
dcl      impossible_class (0:7) bit (1) aligned int static options (constant) init ((3) (1)"0"b, "1"b, "0"b, (3) (1)"1"b);
dcl      in_list bit (1) aligned;
dcl      in_stmnt bit (1) aligned;
dcl      index builtin;
dcl      indx fixed bin (18);
declare	indx_type fixed binary (18);
dcl      initial_line fixed bin (18) int static options (constant) init (1);
dcl      inx fixed binary;
declare	io_control_type fixed binary (4);
dcl      jnx fixed binary;
dcl      keyword_index fixed bin (18);
dcl      label_args bit (1) aligned;
dcl      label_hash_table (0:210) fixed bin (18);
dcl      label_ptr fixed bin (18);
dcl      last_cur_statement fixed bin (18);
dcl      last_do fixed bin (18);
dcl      last_element fixed bin (18);
dcl      last_mode_keyword fixed bin (18) int static options (constant) init (20);
dcl      last_namelist fixed bin (18);
dcl      last_namelist_word_offset fixed bin (18);
dcl      last_paren_parsed fixed bin (18);
dcl      last_source_line fixed bin (18);
dcl      last_statement fixed bin (18);
dcl      last_statement_type fixed bin (18);
dcl      last_token fixed bin (18);
dcl      lbound builtin;
dcl      length builtin;
dcl      letters fixed bin (18) int static options (constant) init (1);
dcl      line_number fixed bin (18);
dcl      line_number_pic picture "zzzzz9";
dcl      line_numbered_text bit (1) aligned;
dcl      locate_symtab_entry fixed bin (2) int static options (constant) init (1);
dcl      logical_if_statement bit (1) aligned;
dcl      local_attributes bit (47) aligned;
dcl      ltrim builtin;
dcl      main_attr bit (47) aligned int static options (constant) init ("000000000000000000010000000000100000"b);
dcl      max builtin;
dcl      max_arglist fixed bin (18) int static options (constant) init (63);
dcl      max_stack fixed bin (18);
dcl      member_attr bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000000000000000110001000"b);
dcl      member_conflicts bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000111111111011101110000"b);
dcl      min builtin;
dcl      mod builtin;
dcl      mode_defined bit (52) aligned;
dcl      mode_type fixed bin (4);
dcl      must_have_label bit (1) aligned;
dcl      named_constant_ptr pointer;
dcl      named_constant_ptr_valid bit (1) aligned;
dcl      named_const_attr bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000000000000000000010000"b);
dcl      named_const_conflicts bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000111111111111111111101"b);
dcl      namelist_attr bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000000000001000000000000"b);
dcl      need_comma bit (1) aligned;
declare	need_ref bit (1) aligned;
dcl      new fixed bin (18);
dcl      next_line_index fixed bin (20);
dcl      next_statement_label fixed bin (18);
dcl      next_token bit (9) aligned;
dcl      no_attributes bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000000000000000000000000"b);
dcl      no_more_source fixed bin (18) int static options (constant) init (0);
declare	not_found bit (1) aligned;
dcl      null builtin;
dcl      number_of_dims fixed bin;
dcl      number_of_subs fixed bin;
dcl      old fixed bin (18);
dcl      op_code fixed bin;
dcl      1 other_segment_info aligned like compiler_source_info;
dcl      out_of_sequence fixed bin (18) int static options (constant) init (63);
dcl      p fixed bin (18);
dcl      param_attr bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000000000000000001000000"b);
dcl      param_conflicts bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000111110111011110110000"b);
dcl      param_ptr pointer;
dcl      param_variable_attrs bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000000000000000001001000"b);
dcl      parameter_statement fixed bin (18) int static options (constant) init (24);
dcl      paren_array (660) fixed bin (18);
dcl      paren_count fixed bin (18);
dcl      01 pending_entry (50) aligned,
	 02 entry_symbol fixed bin (18),
	 02 entry_stmnt bit (36 * size (statement));
dcl      pending_entry_cnt fixed bin;
dcl      produce_listing bit (1) aligned;
dcl      put_in_map bit (9) aligned int static options (constant) init ("100000000"b);
dcl      put_in_profile bit (9) aligned int static options (constant) init ("110000000"b);
dcl      reset_stack (max_stack) bit (36) aligned based (object_base);
dcl      return_value fixed bin (18);
dcl      return_value_param fixed bin (18);
dcl      round builtin;
dcl      rtrim builtin;
dcl      save_attributes bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000000000000001000001000"b);
dcl      save_conflicts bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000111111111011111110000"b);
dcl      save_current_token fixed bin (18);
dcl      saved_number_of_crefs fixed bin (18);
dcl      scalar_conflicts bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000111111111100000110000"b);
dcl      search builtin;
dcl      seg_ptr pointer;
dcl      seg_chain_end_ptr pointer;
dcl      sign bit (9) aligned;			/* Refer to proc "convert_integer_constant" before using. */
dcl      size builtin;
dcl      source_info pointer;
dcl      source_len fixed bin (21);
dcl      source_ptr pointer;
dcl      src_info_ptr pointer;
dcl      stack (0:sys_info$max_seg_size - 1) fixed bin (18) based (object_base);
dcl      stack_base fixed bin (18);
dcl      stack_index fixed bin (18);
dcl      start_of_expression fixed bin (18);
dcl      start_of_node fixed bin (18);
dcl      statement_info bit (36 * size (statement)) aligned;
dcl      statement_label fixed bin (18);
dcl      statement_length fixed bin (18);
dcl      statement_offset fixed bin (20);
dcl      statement_type fixed bin (18);
dcl      string builtin;
dcl      st_copy char (1320) aligned;
dcl      st_lbl_type bit (2) aligned;
dcl      sub_ptr pointer;
dcl      subprogram_attributes bit (47) aligned;
dcl      subprogram_conflicts bit (47) aligned;
dcl      subprogram_op fixed bin;
dcl      subprogram_symbol fixed bin (18);
dcl      subroutine_attributes bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000000110000000000100000"b);
dcl      subroutine_conflicts bit (47) aligned int static options (constant)
	    init ("11111111111111111111111111111010111111110111000"b);
dcl      subroutine_reference bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000000101000000000000000"b);
dcl      subs_list (0:7) fixed bin (18);
dcl      subscript fixed bin (24);
dcl      substr builtin;
dcl      symbol_index fixed bin (18);
dcl      symbol_length fixed bin (18);
dcl      symp pointer;
dcl      temp pointer;
dcl      token bit (9) aligned;
dcl      token_length fixed bin (18);
dcl      token_offset fixed bin (18);
dcl      translate builtin;
dcl      type_conflicts bit (47) aligned int static options (constant)
	    init ("11111111111111111111111111110100011000000110000"b);
dcl      type_of_line fixed bin (18);
dcl      unknown_statement fixed bin (18) int static options (constant) init (62);
dcl      unspec builtin;
dcl      v_length_attributes bit (47) aligned int static options (constant)
	    init ("00000000000000000000100000000000000010000001000"b);
dcl      value_0 fixed bin (18);
dcl      value_1 fixed bin (18);
dcl      value_7 fixed bin (18);
dcl      variable_attributes bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000000000000000000001000"b);
dcl      variable_conflicts bit (47) aligned int static options (constant)
	    init ("00000000000000000000000000111111111000000110000"b);
dcl      verify builtin;
dcl      word_offset fixed bin (18);
dcl      work bit (72) aligned;

dcl      1 do_blockif_stack (50) aligned,
	 2 label_ptr fixed binary (18),
	 2 clauses fixed binary (18),
	 2 count_op fixed binary (18),
	 2 line_number fixed binary (18),
	 2 do_loop bit (1) aligned,
	 2 else_seen bit (1) aligned;

dcl      1 word_align aligned based,
	 2 based_double float bin (63) unaligned;

dcl      1 token_list (1000) aligned,
	 2 type bit (9) unaligned,
	 2 pad bit (9) unaligned,
	 2 offset fixed bin (18) unaligned unsigned,
	 2 length fixed bin (10) aligned;

dcl      1 constant_array (500) aligned,
	 2 prec fixed bin (8) unaligned,
	 2 scale fixed bin (8) unaligned,
	 2 exponent fixed bin (8) unaligned,
	 2 length fixed bin (8) unaligned;

dcl      1 file_stack (0:32) aligned,
	 2 fs_seg_ptr ptr,				/* ptr to source_node for segment. */
	 2 fs_source_ptr ptr,			/* ptr to base of source segment. */
	 2 fs_end_of_line fixed bin (21),		/* offset of end of current line in source seg. */
	 2 fs_source_length fixed bin (21),		/* length in chars of source segment. */
	 2 fs_line_number fixed bin (18),		/* line number in source segment. */
	 2 fs_file_number fixed bin (8);		/* file number of source segment. */

dcl      1 token_structure aligned based (addr (st_copy)),
	 2 pad char (token_offset) unaligned,
	 2 token_string char (token_length) unaligned;

dcl      1 format_structure aligned based (addr (st_copy)),
	 2 pad char (6) unaligned,
	 2 format_string char (statement_length - 6) unaligned;

dcl      1 paren_info (100) aligned structure,
	 2 chain fixed bin (18),
	 2 position fixed bin (18),
	 2 begin_index fixed bin (18),
	 2 implied_loop bit (1);

%include fort_parameter;

declare	1 parameter_info aligned like parameter;

dcl      1 io_bits unaligned structure,
%include fortran_job_bits;
	dummy fixed bin (18);

%include format_tables;

/* format: off */
dcl	1 statement_attributes
			(64) aligned structure internal static options (constant),
	  2 statement_label_type
			bit (2) unaligned		/* Stmnt label is: executable, format, non-executable */
init (
			(28) (1)"11"b,		/* 1-28 */
			"01"b,			/* 29 */
			(3) (1)"01"b,		/* 30-32 */
			(4) (1)"01"b,		/* 33-36 */
			"10"b, "11"b,		/* 37&38 */
			(7) (1)"01"b,		/* 39-45 */
			"11"b,			/* 46 */
			(17) (1)"01"b,		/* 47-63 */
			"11"b),			/* 64 */
	  2 ok_second_statement
			bit (1) unaligned /* On if legal second stmnt for logical if stmnt. */ 
init (
			(28) (1)"0"b,		/* 1-28 */
			"1"b,			/* 29 */
			(3) (1)"0"b,		/* 30-32 */
			(4) (1)"1"b,		/* 33-36 */
			"0"b, "0"b,		/* 37&38 */
			(7) (1)"1"b,		/* 39-45 */
			"0"b,			/* 46 */
			(14) (1)"1"b,		/* 47-60 */
			"0"b, "1"b, "1"b, "0"b),	/* 61-64 */
	  2 need_label	bit (1) unaligned /* On if FOLLOWING stmnt must have a label. */ 
init (
			(28) (1)"0"b,		/* 1-28 */
			"1"b,			/* 29 */
			(3) (1)"0"b,		/* 30-32 */
			"1"b,			/* 33 */
			(5) (1)"0"b,		/* 34-38 */
			"1"b,			/* 39 */
			(7) (1)"0"b,		/* 40-46 */
			"1"b,			/* 47 */
			(5) (1)"0"b,		/* 48-52 */
			"1"b,			/* 53 */
			(11) (1)"0"b),		/* 54-64 */
	  2 cant_be_reached bit (1) unaligned		/* On if THIS statement is not reached by block if */
init (
			(29) (1)"1"b,		/* 1-29 */
			(3) (1)"0"b,		/* 30-32 */
			(32) (1)"1"b),		/* 33-64 */

	  2 cant_ref_label	bit (1) unaligned		/* ON if label on  this statment cant be referenced */
init (
			(29) (1)"0"b,		/* 1 -29 */
			(2) (1)"1"b,		/* 30-31 */
			(33) (1)"0"b),		/* 32-64 */
	  2 reserved	bit (12) unaligned init ((64) (1)""b),
						/* Unused. */
	  2 first_keyword	fixed bin (18) unaligned unsigned
						/* Beginning of program section for this stmnt. */
init (
			(11) 11,			/* 1-11 */
			(50) 12,			/* 12-61 */
			(3) 0);			/* 62-64 */

/* format: on */
/* Keyword character strings. */

dcl      keyword_table (64) char (28) varying internal static options (constant)
	    init ("program", "blockdata", "subroutine", "function", "integerfunction", "realfunction",
	    "doubleprecisionfunction", "complexfunction", "logicalfunction", "characterfunction", "implicit",
	    "dimension", "common", "equivalence", "integer", "real", "doubleprecision", "complex", "logical",
	    "character", "external", "intrinsic", "namelist", "parameter", "library", "save", "automatic",
	    "statement func. definition", "if", "elseif", "else", "endif", "goto", "call", "continue", "write",
	    "format", "data", "return", "rewind", "endfile", "read", "encode", "decode", "print", "entry", "stop",
	    "pause", "assign", "punch", "input", "backspace", "chain", "closefile", "margin", "openfile", "open",
	    "close", "inquire", "assignment", "do", "UNKNOWN", "SEQUENCE ERROR", "end");

/*	Statement			Key Label      Ok   Need 1st
	Type			Len Type      2nd  Label Key
	
	 1 Program		 7  Un   .    No   No    11
	 2 Block Data		 9  Un   .    No   No    11
	 3 Subroutine		10  Un   .    No   No    11
	 4 Function		 8  Un   .    No   No    11	= function_statement
	 5 Integer Function		15  Un   .    No   No    11
	 6 Real Function		12  Un   .    No   No    11
	 7 Double Precision Function	23  Un   .    No   No    11
	 8 Complex Function		15  Un   .    No   No    11
	 9 Logical Function		15  Un   .    No   No    11
	10 Character Function	17  Un   .    No   No    11
	11 Implicit		 8  Un   .    No   No    11	= after_subprogram
	12 Dimension		 9  Un   .    No   No    12
	13 Common			 6  Un   .    No   No    12
	14 Equivalence		11  Un   .    No   No    12   = equivalence_statement
	15 Integer		 7  Un   .    No   No    12	= first_mode_keyword
	16 Real			 4  Un   .    No   No    12
	17 Double Precision		15  Un   .    No   No    12
	18 Complex		 7  Un   .    No   No    12
	19 Logical		 7  Un   .    No   No    12
	20 Character		 9  Un   .    No   No    12	= last_mode_keyword
	21 External		 8  Un   .    No   No    12
	22 Intrinsic		 9  Un   .    No   No    12
	23 Namelist		 8  Un   .    No   No    12
	24 Parameter		 9  Un   .    No   No    12	= parameter_statement
	25 Library		 7  Un   .    No   No    12
	26 Save			 4  Un   .    No   No    12
	27 Automatic		 9  Un   .    No   No    12
	28 Statement Function Def	 0  Un   .    No   No    12	= asf_definition
	29 If (Arithmetic)		 2  Ex   .    Yes  Yes   12
	30 Elseif			 6  Un   .    No   No    12	= elseif_statement
	31 Else			 4  Un   .    No   No    12	= else_statement
	32 Endif			 5  Un   .    No   No    12
	33 Goto			 4  Ex   .    Yes  Yes   12
	34 Call			 4  Ex   .    Yes  No    12
	35 Continue		 8  Ex   .    Yes  No    12
	36 Write			 5  Ex   .    Yes  No    12
	37 Format			 6  Fmt  .    No   No    12
	38 Data			 4  Un   .    No   No    12
	39 Return			 6  Ex   .    Yes  Yes   12
	40 Rewind			 6  Ex   .    Yes  No    12
	41 Endfile		 7  Ex   .    Yes  No    12
	42 Read			 4  Ex   .    Yes  No    12
	43 Encode			 6  Ex   .    Yes  No    12
	44 Decode			 6  Ex   .    Yes  No    12	= decode_statement
	45 Print			 5  Ex   .    Yes  No    12
	46 Entry			 5  Un   .    No   No    12
	47 Stop			 4  Ex   .    Yes  Yes   12
	48 Pause			 5  Ex   .    Yes  No    12
	49 Assign To		 6  Ex   .    Yes  No    12
	50 Punch			 5  Ex   .    Yes  No    12
	51 Input			 5  Ex   .    Yes  No    12
	52 Backspace		 9  Ex   .    Yes  No    12
	53 Chain			 5  Ex   .    Yes  Yes   12
	54 Closefile		 9  Ex   .    Yes  No    12
	55 Margin			 6  Ex   .    Yes  No    12
	56 Openfile		 8  Ex   .    Yes  No    12
	57 Open			 4  Ex   .    Yes  No    12
	58 Close			 5  Ex   .    Yes  No    12
	59 Inquire		 7  Ex   .    Yes  No    12
	60 Assignment		 0  Ex   .    Yes  No    12	= assignment_statement
	61 Do			 2  Ex   .    No   No    12	= do_statement
	62 Unknown		 0  Ex   .    Yes  No     0	= unknown_statement
	63 Out of Sequence		 0  Ex   .    Yes  No     0	= out_of_sequence
	64 End			 0  Un   .    No   No     0	= end_line
*/


dcl      1 expression aligned based structure,
	 2 storage_info like symbol.storage_info unaligned,
						/* currently 5 bits */
	 2 allow_array_name bit (1) unaligned,
	 2 reset_arg_bit bit (1) unaligned,
	 2 needs_descriptors bit (1) unaligned,
	 2 not_scalar_ref unaligned structure,
	   3 subscripted_ref bit (1) unaligned,
	   3 array_name bit (1) unaligned,
	   3 not_simple_ref bit (1) unaligned,
	   3 substring_ref bit (1) unaligned,
	 2 not_constant bit (1) unaligned,
	 2 no_assumed_size_array bit (1) unaligned;

/* format: off */
/*		L E G E N D
		IN = set by caller to parse_expression
		OUT = set by parse_expression

			       allocate (IN)
			       |set (IN)
			       | referenced (IN)
			       | |passed_as_arg (IN - OUT)
			       | | initialed (IN)
			       | | |allow_array_name (IN)
			       | | | reset_arg_bit (IN)
			       | | | |needs_descriptors (IN) 
			       | | | | subscripted_ref (OUT)
			       | | | | |array_name (OUT)
			       | | | | | not_simple_ref (OUT)
			       | | | | | |substring_ref (OUT)
			       | | | | | | not_constant (OUT)
			       | | | | | | |no_assumed_size_array (IN)
			       ||||||||||||||	
			       ||||||||||||||
          Constant Names	       ||||||||||||||
			       vvvvvvvvvvvvvv */
declare	(
	any_expression	init ("101000000000000000000000000000000000"b),
	set_reference	init ("111000000000000000000000000000000000"b),
	input_element	init ("111001000000010000000000000000000000"b),
	output_element	init ("101001000000010000000000000000000000"b),
	string_target	init ("111001000000010000000000000000000000"b),
	string_source	init ("101001000000010000000000000000000000"b),
	arg_list_expr	init ("101101100000000000000000000000000000"b),
	darg_list_expr	init ("101101110000000000000000000000000000"b),
	simple_reference	init ("101000000000000000000000000000000000"b),
	format_reference	init ("101001000000010000000000000000000000"b),
	set_no_symbol_bits	init ("000000000000000000000000000000000000"b)
	)		bit (36) aligned int static options (constant);

/* format: on */

dcl      out bit (36) aligned;			/* for return value */

%include compiler_source_info;
%include fortran_io_consts;

/* THE PARSE PHASE BEGINS HERE. */

/* Initialize constants used by the entire phase. */

	addr (work) -> based_integer = 0;
	value_0 = create_constant (int_mode, work);
	default_unit_specifier = value_0;
	addr (work) -> based_integer = 1;
	value_1 = create_constant (int_mode, work);
	value_7 = 0;

	cur_segment = 0;				/* Used to chain the source nodes. */
	first_segment = 0;				/* Head of source node chain. */
	number_of_source_segments = 0;
	number_of_lines = 0;			/* count total number of lines parsed */
	last_source_line = 0;			/* insures comments print with following program unit */
	profile_size = 0;				/* counts number of profile entries required */
	unnamed_block_data_subprogram = 0;		/* keep track of whether or not one was compiled */
	from_data_parser = FALSE;			/* Used by get_next_token to suppress error msgs. */

	free_chain = 0;				/* Free initial "nodes". */
	max_stack = 0;				/* Number of words used in stack. */
	file_stack_depth = 0;			/* Current include file nesting depth. */
	shared_structure.incl_count = -1;		/* Count of include files used in this compilation. */

	subprogram_op = main_op;
	subprogram_attributes = main_attr;
	subprogram_conflicts = all_attributes;

	sign = ZERO;				/* Refer to procedure "convert_integer_constant" for explanation. */

	options.namelist_used = FALSE;
	line_numbered_text = shared_structure.options.has_line_numbers;
	produce_listing = string (shared_structure.options.listing) ^= ZERO;
	parameter_info.shared_pointer = shared_ptr;

/* the following makes a template for the statement node */

	unspec (statement_info) = ZERO;
	addr (statement_info) -> statement.op_code = stat_op;
	addr (statement_info) -> statement.next = (18)"0"b;
	addr (statement_info) -> statement.location = (18)"1"b;
	addr (statement_info) -> statement.statement = "00001"b;

/* SEGMENT LOOP. THIS LOOP IS EXECUTED ONCE FOR EACH SOURCE SEGMENT. */

	source_info = src_info_ptr;			/* Copy input argument. */
	source_ptr = source_info -> compiler_source_info.input_pointer;
						/* Points to source segment. */

	shared_structure.source_file_number, shared_structure.source_line_number = 0;
	do while (source_ptr ^= null);

	     source_len = source_info -> compiler_source_info.input_lng;

/* Build source node and save segment info. */

	     shared_structure.incl_count = shared_structure.incl_count + 1;

	     addr (statement_info) -> statement.file = shared_structure.incl_count;

	     number_of_source_segments = number_of_source_segments + 1;

	     if source_info -> compiler_source_info.segname = "" then
		i = 63 - divide (length (source_info -> compiler_source_info.dirname), chars_per_word, 17, 0);
	     i = 63
		-
		divide (length (source_info -> compiler_source_info.dirname)
		+ length (source_info -> compiler_source_info.segname), chars_per_word, 17, 0);

	     indx = create_node (source_node, size (source) - i);
						/* Pathname cannot be made longer. */

	     shared_structure.source_node_offset (incl_count) = indx;
	     shared_structure.incl_len (incl_count) = source_len;
	     shared_structure.incl_ptr (incl_count) = source_ptr;

	     if cur_segment = 0 then
		first_segment = indx;
	     else
		seg_ptr -> source.next = indx;

	     cur_segment = indx;
	     seg_chain_end_ptr, seg_ptr = addr (OS (cur_segment));

	     seg_ptr -> source.pathname = source_info -> compiler_source_info.dirname;
	     if source_info -> compiler_source_info.segname ^= "" then do;
		seg_ptr -> source.pathname = seg_ptr -> source.pathname || ">";
		seg_ptr -> source.pathname =
		     seg_ptr -> source.pathname || source_info -> compiler_source_info.segname;
	     end;

	     seg_ptr -> source.uid = source_info -> compiler_source_info.unique_id;
	     seg_ptr -> source.dtm = source_info -> compiler_source_info.date_time_modified;

/* Initialize the lex and get the first significant character in the segment. */

	     call statement_lex$initialize;		/* Sets "type_of_line", subr_options, segment_options */

	     if type_of_line = no_more_source		/* Abort if segment contains no statements. */
	     then do;
		call print_message (1);		/* segment contains no source code */
	     end;

/* SUBPROGRAM LOOP. EXECUTED ONCE FOR EACH SUBPROGRAM. */

	     do while (type_of_line ^= no_more_source);

/* INITIALIZATION REQUIRED FOR EACH SUBPROGRAM. */

/* Build a subprogram header for the subprogram's attributes. */

		cur_subprogram = create_node (subprogram_node, size (subprogram));
		sub_ptr = addr (OS (cur_subprogram));

		if last_subprogram ^= 0		/* Chain this header in with the others. */
		then do;
		     sub_ptr -> previous_subprogram = last_subprogram;
		     addr (OS (last_subprogram)) -> next_subprogram = cur_subprogram;
		end;
		else
		     first_subprogram = cur_subprogram;
		last_subprogram = cur_subprogram;

		if seg_ptr -> source.initial_subprogram = 0
						/* Set field as needed. */
		     then
		     seg_ptr -> source.initial_subprogram = cur_subprogram;

		sub_ptr -> first_polish = next_free_polish;
		sub_ptr -> subprogram.options = subr_options;
		last_statement = -1;		/* No previous statement. */
		subprogram_op = 0;			/* Not a function or subroutine yet. */
		alternate_return_index = 0;		/* argument to implement alternate return */


/* If a listing is to be produced, build the listing_info node */

		if produce_listing then do;
		     listing_info.next = next_free_listing;
						/* build forward chain */

		     cur_listing = addr (listing_seg (next_free_listing));
						/* point to new node */
		     unspec (listing_info) = ZERO;	/* initialize the node */
		     next_free_listing = next_free_listing + size (listing_info);

		     listing_info.subprogram = cur_subprogram;

		     listing_info.first_cref = number_of_crefs + 1;
		     listing_info.first_line = last_source_line + 1;
		end;


/* Initialize symbol and label hash tables, and zero count of compiler generated symbols. */

		unspec (hash_table) = ZERO;
		unspec (label_hash_table) = ZERO;
		cp_count = 0;			/* Count of compiler generated names. */
		cp_label_count = 0;			/* Count of compiler labels. */

		have_auto_stmnt = FALSE;		/* information about storage class statements */
		have_save_stmnt = FALSE;

/* Set up the default mode tables. The letters i thru n are integer. All others are real. */

		do i = 1 to 8;			/* The letters a thru h in each case. */
		     default_table (i) = attr_table (real_mode);
		     default_table (i + 26) = attr_table (real_mode);
		end;
		do i = 9 to 14;			/* The letters i thru n in each case. */
		     default_table (i) = attr_table (int_mode);
		     default_table (i + 26) = attr_table (int_mode);
		end;
		do i = 15 to 26;			/* The letters o thru z in each case. */
		     default_table (i) = attr_table (real_mode);
		     default_table (i + 26) = attr_table (real_mode);
		end;

		mode_defined = ZERO;		/* Nothing defined by the user. */

/* Initialize the parse of a subprogram. */

		must_have_label = FALSE;		/* Label not required for first executable statement. */
		assignment_statement_index = asf_definition;
						/* First apparent asgn stmnt might be st.func.def. */
		bypass_first_pending_entry = FALSE;	/* No need to bypass main entry. */
		pending_entry_cnt = 0;		/* No entries pending. */
		keyword_index = 1;			/* First statement may be anything. */
		do_index = 0;			/* Reset do loop stack. */
		stack_index = lbound (stack, 1);	/* Stack is initially empty. */

		stack_base = stack_index;		/* lex first statement separately because of special case below. */

		call statement_lex (statement_type);	/* Lex the first statement of a subprogram. */

/* Function statements of the form "mode*k function" look like mode statements
		   to the statement recognizer. Decide if initial mode st is really a func st. */

		allow_star_after = TRUE;		/* Allow either form of function statement. */

		if statement_type >= first_mode_keyword & statement_type <= last_mode_keyword
						/* a mode st */
		     then
		     if token_list (first_token).type = asterisk & first_token + 2 <= last_token then do;
			if token_list (first_token + 2).type = ident then
			     if substr (st_copy, token_list (first_token + 2).offset + 1, 8) = "function" then do;

/* Set stmnt type = function_statement + mode. Delete "function" chars. */

				statement_type = function_statement + (statement_type - first_mode_keyword + 1);
				call split_token (8, first_token + 2, TRUE);
				allow_star_after = FALSE;
						/* "*k" field must precede func name. */
			     end;
			     else
				;
			else			/* process potential character *(*) function */
			     if token_list (first_token + 1).type = left_parn
			     & token_list (first_token + 2).type = asterisk
			     & token_list (first_token + 3).type = right_parn
			     & token_list (first_token + 4).type = ident & first_token + 4 <= last_token then
			     if substr (st_copy, token_list (first_token + 4).offset + 1, 8) = "function" then do;

/* re-build the list as if we read 'CHARACTER FUNCTION f*(*) */
/* list looked like: (referenced to first_token)                                        */
/* token  -2    -1    0     1     2     3     4              */
/*      ----- -----   *     (     *     )   FUNCTIONvar      */
/* and moves to be:      (FUNCTION is deleted)               */
/* token  -2    -1    0     1     2     3     4              */
/*      ----- -----  var    *     (     *     )              */

/* Set stmnt type = function_statement + mode. Delete "function" chars. */

				statement_type = function_statement + (statement_type - first_mode_keyword + 1);

				call split_token (8, first_token + 4, TRUE);

				token_list (first_token + 0) = token_list (first_token + 4);
				token_list (first_token + 4) = token_list (first_token + 3);
				token_list (first_token + 3) = token_list (first_token + 2);
				token_list (first_token + 2) = token_list (first_token + 1);
				token_list (first_token + 1) = token_list (first_token + 3);
			     end;
		     end;

/* The first statement of a program unit specifies the type of subprogram. An end line at this point is
	   legal.  If the first statement is not a subroutine, function, or block data statement,
             then this is a main program and a "main statement" must be manufactured. */

		if statement_type >= after_subprogram then do;
		     main_entry_point_name = default_main_entry_point_name;
		     call build_main_program (build_symbol ((main_entry_point_name), main_attr, SET));
		end;

/* STATEMENT LOOP. EXECUTED ONCE FOR EACH STATEMENT OF A SUBPROGRAM, EXCEPT THE END LINE. */
/* Note - a subprogram consisting of only an end_line is diagnosed above. */

		do while (statement_type ^= end_line);

/* This removes some statement types from look up at appropriate time. */

		     if first_keyword (statement_type) > keyword_index then
			keyword_index = first_keyword (statement_type);
						/* "Shorten" the keyword list. */

/* Initialize for statement label processing. */

		     END_DO_RANGE = FALSE;		/* This stmnt is not the terminal stmnt of a do loop. */
		     st_lbl_type = statement_label_type (statement_type);

/* If this is the first executable statement, inhibit future recognition of s.f. defs.
			Also, if any s.f. defs. have been parsed, emit a label to prevent the
			execution of the s.f. defs. by erroneous means. */

		     if st_lbl_type = executable_label then
			if assignment_statement_index ^= assignment_statement then
			     call finish_sf_defs;

/* If the next statement is executable and there are any entries pending,
   process them now. */

		     if st_lbl_type = executable_label & pending_entry_cnt > 0 then
			call process_pending_entries;

/* Process statement label. "statement_label" is set by statement_lex; to zero if no label or value of label.
   All statement labels are entered in the label table. Only executable labels are checked when looking for
   the end of a do loop. Only executable stmnts are checked for missing labels. i.e. - the first executable
   statement after an unconditional transfer of control. */

		     if statement_label ^= 0 then do;
			statement_label = enter_label (st_lbl_type, statement_label, SET);
			addr (OS (statement_label)) -> label.not_referencable =
			     statement_attributes.cant_ref_label (statement_type);

			if produce_listing		/* mark cref node as a defining ref */
			then do;
			     if ^(addr (OS (statement_label)) -> label.referenced) then
				cross_reference (number_of_crefs - 1).line_no =
				     -cross_reference (number_of_crefs - 1).line_no;
			     else
				cross_reference (number_of_crefs).line_no =
				     -cross_reference (number_of_crefs).line_no;
			end;

			if st_lbl_type = executable_label then do;
			     END_DO_RANGE = "0"b;

/* check if this terminates any do loops 
   if so insure proper nesting of do loops and block if's and pop stack to terinating level */

			     do inx = do_index to 1 by -1 while (^END_DO_RANGE);
				if do_blockif_stack (inx).do_loop then
				     END_DO_RANGE = statement_label = do_blockif_stack (inx).label_ptr;
				if END_DO_RANGE then
				     do jnx = do_index to inx + 1 by -1;
					if do_blockif_stack (jnx).do_loop then
					     call print_message (183, do_blockif_stack (jnx).label_ptr);
					else
					     call print_message (184,
						ltrim (char (do_blockif_stack (jnx).line_number)));
				     end;
			     end;

			     if END_DO_RANGE then
				do_index = inx + 1;
			     must_have_label = need_label (statement_type);
						/* Reset need for label on following stmnt. */

			     call emit_operand (statement_label);
						/* Emit label operand and label operator. */
			     call emit_operator (label_op);
			end;
		     end;
		     else if st_lbl_type = executable_label then do;
						/* Executable stmnt without label */
			if must_have_label & statement_attributes.cant_be_reached (statement_type) then
			     call print_message (5);	/* statement cannot be referenced */
			must_have_label = need_label (statement_type);
		     end;

/* Reset global variables modified by the stmnt parsers. */

		     logical_if_statement = FALSE;	/* Statement is not a logical if statement. */
		     stack_base = stack_index;	/* Stack can only grow by resetting stack_base. */
		     current_token = first_token - 1;	/* First token of stmnt is next not current. */
		     go to parser (statement_type);	/* Actually case(statement_type) */

/* Input conditions true for all statement parsers:
	1. values of token, token_offset, and token_length are invalid at entry; parsers must get first token by
	   incrementing current_token; (i.e. - get_next_token(TRUE, ...))
	2. value of "statement_type" is valid when parser is entered;
	3. value of "statement_label" is valid when parser is entered (pointer to label operand for statement label);

   Output requirements for each statement parser:
	1. parser must position after last token processed to allow test for extraneous text;
*/

/* End of case(statement_type) */


missing_identifier:
		     call print_message (10, err_string ());
		     go to statement_parse_abort;

missing_right_paren:
		     call print_message (11, err_string ());
		     go to statement_parse_abort;

missing_slash:
		     call print_message (13, err_string ());
		     go to statement_parse_abort;

missing_left_paren:
		     call print_message (22, err_string ());
		     go to statement_parse_abort;

missing_comma:
		     call print_message (26, err_string ());
		     go to statement_parse_abort;

missing_equals_sign:
		     call print_message (49, err_string ());
		     go to statement_parse_abort;

missing_label:
		     call print_message (23, err_string ());
		     go to statement_parse_abort;

missing_keyword:
		     call print_message (40, err_string ());
		     go to statement_parse_abort;
invalid_keyword:
		     call print_message (66, err_string (), keyword_table (statement_type));
		     go to statement_parse_abort;

invalid_substring:
		     call print_message (195);
		     go to statement_parse_abort;

parse_done:					/* Check for extraneous text in statement. */
		     if current_token <= last_token then
			if token = right_parn	/* be more explicit if parenthesis */
			     then
			     call print_message (90);
			else
			     call print_message (6, keyword_table (statement_type));
						/* extra text */

statement_parse_abort:				/* If stmnt was a logical if, an exit operator must be emitted. */
		     if logical_if_statement then do;
			call emit_operator (exit_op);
		     end;

/* If current stmnt terminates a do loop, emit exit operators for each loop which is terminated, 
   but not if there is a block if seperating them */

		     if END_DO_RANGE then
			do do_index = do_index to 1 by -1
			     while (do_blockif_stack (do_index).do_loop
			     & statement_label = do_blockif_stack (do_index).label_ptr);
			     call emit_operator (exit_op);
			end;

/* Lex the next statement in the subprogram. Reexecute the loop if it is not an end_line. */

		     stack_index = stack_base;	/* Insure validity of what is on the stack. */
		     last_statement_type = statement_type;
		     call statement_lex (statement_type);
		end;				/* END OF STATEMENT LOOP. */

/* The following code is executed after a subprogram is completely parsed. */

		cur_statement = -1;			/* Suppress line number in error msgs. */

/* Check for main program, subroutine, function, or entry point without executable code. */

		if sub_ptr -> subprogram_type ^= block_data
		     & (assignment_statement_index ^= assignment_statement | pending_entry_cnt > 0) then
		     call process_pending_entries;

/* Terminate all unended do loops and block ifs for the code generator. */

		do i = do_index to 1 by -1;
		     if do_blockif_stack (i).do_loop then do;
			call emit_operator (exit_op);
			call print_message (8, do_blockif_stack (i).label_ptr);
		     end;
		     else do;
			call emit_operator (item_op);
			call emit_operator (eol_op);
			call print_message (178, ltrim (char (do_blockif_stack (i).line_number)));
		     end;
		end;

/* Generate a return stmnt if control would pass thru to end_line. Then generate an endunit operator. */

		if ^must_have_label & sub_ptr -> subprogram_type ^= block_data then do;
		     profile_size = profile_size + 1;
		     string (cur_stmnt_ptr -> statement.bits) = put_in_profile;

		     call emit_return_op;
		     call emit_statement_op (addr (statement_info));
						/* NOT in profile or map */
		end;

		call emit_operator (endunit_op);

/* Indicate default storage class to storage allocator. */

		if ^have_auto_stmnt & ^have_save_stmnt then do;
		     if have_auto_option | have_static_option then
			sub_ptr -> default_is.static = have_static_option;
		     else
			sub_ptr -> default_is.static = shared_structure.options.user_options.static_storage;
		end;

		sub_ptr -> default_is.auto = ^sub_ptr -> default_is.static;

/* Save offset of last emitted halfword. */

		sub_ptr -> last_polish = next_free_polish - 1;


		call declaration_processor;


/* For listings, finish up the listing_info node */

		if produce_listing then do;
		     listing_info.last_cref = number_of_crefs;
		     last_source_line = number_of_lines;/* insures comments following endline are printed */
		end;

/* Get first significant character of next subprogram, if such exists. */

		call statement_lex$get_next_subprogram; /* Sets "type_of_line". */
	     end;					/* END OF SUBPROGRAM LOOP. */

/* The following code is executed after all subprograms in the current source segment have been parsed. */

	     source_info = addr (other_segment_info);	/* use separate area for second thru nth segments */

	     call get_next_source_seg (source_info);	/* Returns new source info ptr or null. */

	     if source_info = null then
		source_ptr = null;
	     else
		source_ptr = source_info -> compiler_source_info.input_pointer;
	end;					/* END OF SEGMENT LOOP. */

/* if there is an entry name chain, insure it is separate from the symbol table */

	if last_entry_name ^= 0 then
	     addr (OS (last_entry_name)) -> symbol.next_symbol = 0;
	call check_entry_duplication;			/* Ensure no dups */

/* Zero the object segment. */

	unspec (reset_stack) = ZERO;
	return;

/* BEGIN  ext_parse section - PARSE - split 82-03-29  T. Oke */
/* Modification History:

83-02-10 HH - Install LA/VLA support.
82-06-28 TO.  Change INQUIRE keyword "filename=" to "file=" to conform to
	standard.
82-05-03 TO. Implement star_extent functions.
82-05-03 TO. Start on multiply_check option catching.
82-04-19 TO, Fix bug 287 in declaration_processor - create named_constant if
	static or automatic variable fit limits.  Stolen from optimizer.
82-04-05 TO, Fix bug 306 in get_equiv_var, by correctly throwing back a header
	node if equivalence cannot be made.
	*/

/* BEGIN case(statement_type) */

/* Case		Program

Syntax:	<program_name>

Polish:	<program_name> <count_op> <main_op> <eol_op>

Notes:	If present, must be the first statement in the source segment.
*/

parser (1):
	string (cur_stmnt_ptr -> statement.bits) = put_in_map;

	call get_next_token (force_symtab_entry, subprogram_symbol);
	if token ^= ident then
	     go to missing_identifier;

	call build_main_program (subprogram_symbol);
	current_token = current_token + 1;
	go to parse_done;

/* Case		Block Data

Syntax:	[ <block_data_subprog_name> ] 

Polish:	<non_executable> <block_data>

Notes:
	sub_ptr		points to subprogram header node in polish
	subprogram_op, etc	unchanged
	common_name used to hold the name (or "unnamed name) of sub_prog
	it is also used in the parsing of common statements.
*/
parser (2):
	call emit_operator (block_data_op);

	call get_next_token (ignore_symtab_entry, ignore_value);

	if token = EOS_token then do;
	     if unnamed_block_data_subprogram ^= 0 then
		call print_message (15);		/* duplicate unnamed block data subprograms */
	     unnamed_block_data_subprogram = cur_subprogram;
	     common_name = unnamed_block_data_subprg_name;
	end;
	else if token = ident then do;
	     common_name = token_string;
	     current_token = current_token + 1;
	end;
	else
	     goto missing_identifier;

	sub_ptr -> subprogram_type = block_data;
	SI, sub_ptr -> subprogram.symbol = build_symbol (common_name, no_attributes, SET);

/* if named block data, then indicate it's a user defined name.  build symbol assumes compiler generated names */

	if common_name ^= unnamed_block_data_subprg_name then
	     addr (OS (SI)) -> symbol.by_compiler = FALSE;

	go to parse_done;


/* Case		Subroutine

Syntax:	<subroutine_name> [ ( [ <parameter_list> ] ) ] <eos>

Polish:	<subroutine_name> <parameter_count> <subr>  [ <parameter> <item> ] <eol>

Notes:
	subprogram_attributes	same as a subroutine
	subprogram_conflicts	any and all attributes
	subprogram_op	subroutine opr
*/
parser (3):
	string (cur_stmnt_ptr -> statement.bits) = put_in_map;

	call get_next_token (force_symtab_entry, subprogram_symbol);
	if token ^= ident then
	     go to missing_identifier;

/* set fields in subprogram node */

	sub_ptr -> subprogram_type = subroutine;
	sub_ptr -> subprogram.symbol = subprogram_symbol;

/* set global variables for parameter list parse and entry statement parse */

	subprogram_op = subr_op;			/* This symbol and its entries are subroutines. */
	subprogram_attributes = subroutine_attributes;
	subprogram_conflicts = all_attributes;
	return_value_param = 0;			/* used if label args are in parameter list */

	call parse_parameter_list (subprogram_symbol);	/* emits all polish for stmnt and parses param list */
	go to parse_done;


/* Case		Function

Syntax:	[ <mode_keyword> [ <*> <K> ] ] <function_name> ( [ <parameter_list> ] ) <eos>

Polish:	<function_name> <func_count> <func> <parameter> <item> ... <return_value> <item> <eol>

Notes:
	<func_count> includes return value parameter
*/
parser (4):
parser (5):
parser (6):
parser (7):
parser (8):
parser (9):
parser (10):
	string (cur_stmnt_ptr -> statement.bits) = put_in_map;
	attributes = attr_table (statement_type - function_statement);

/* if mode keyword is provided, set function data type */

	if statement_type = function_statement then
	     allow_star_after = FALSE;		/* mode not specified, so "*k" is invalid */
	else if ^allow_star_after			/* i.e., "*k" must appear before name */
	     then
	     call get_mode_size (statement_type - function_statement, (default_char_size), attributes, asterisk_seen);

/* get name of function */

	call get_next_token (force_symtab_entry, return_value);
	if token ^= ident then
	     go to missing_identifier;

/* if alternate form is possible, check for "*k" */

	if allow_star_after then
	     call get_mode_size (statement_type - function_statement, (default_char_size), attributes, asterisk_seen);

/* function return value will be in hash table. Set accumulated attributes. */

	attributes = attributes | auto_attribute;	/* force auto storage for return value */
	if declare_symbol (return_value, attributes, all_attributes, DECLARED) then
	     ;					/* Error is impossible */

/* function name is not in hash table */

	subprogram_symbol = build_symbol (substr (full_name, 1, symbol_length), no_attributes, SET);
	addr (OS (subprogram_symbol)) -> symbol.by_compiler = FALSE;
						/* treat as user symbol */

/* function return value parameter */
/* do a little work on this to handle character*(*) functions. */

/* if the attributes of the symbol indexed by "return_value" have star_extents
   then set them here too, and set the return_value as being stack_indirect. */

	return_value_param = build_symbol ((NO_NAME), param_variable_attrs, SET);
	if addr (OS (return_value)) -> symbol.star_extents then do;
	     sub_ptr -> subprogram.star_extent_function = "1"b;
	     addr (OS (return_value)) -> symbol.stack_indirect = "1"b;
	     addr (OS (return_value_param)) -> symbol.star_extents = "1"b;
	     addr (OS (subprogram_symbol)) -> symbol.star_extents = "1"b;
	end;

/* set fields in subprogram node */

	sub_ptr -> subprogram_type = function;
	sub_ptr -> subprogram.symbol = subprogram_symbol;

/* set global variables for parameter list and entry statement parsers */

	subprogram_op = func_op;
	subprogram_attributes = function_attribute;
	subprogram_conflicts = entry_point_conflicts;

	call parse_parameter_list (subprogram_symbol);	/* emits all polish for stmnt and parses param list */

	go to parse_done;


/* Case		Implicit

Syntax:

Polish:

Notes:
*/
parser (11):					/* Parse each mode range separately. */
	in_stmnt = TRUE;
	do while (in_stmnt);

/* Get mode type and build attribute bit string. */

	     call get_next_token (ignore_symtab_entry, ignore_value);
	     if token ^= ident then
		go to missing_keyword;

	     if length (fast_lookup) - symbol_length > 0	/* pad with blanks when necessary */
		then
		substr (fast_lookup, symbol_length + 1, length (fast_lookup) - symbol_length) = NULL_STRING;

	     do i = first_mode_keyword to last_mode_keyword while (keyword_table (i) ^= fast_lookup);
	     end;

	     if i > last_mode_keyword then
		go to invalid_keyword;

	     attributes = attr_table (i - first_mode_keyword + 1);
	     call get_mode_size (i - first_mode_keyword + 1, (default_char_size), attributes, asterisk_seen);

/* Parse letter range(s). */

	     call get_next_token$operator;		/* Get left parenthesis. */
	     if token ^= left_parn then
		go to missing_left_paren;

	     in_list = TRUE;
	     do while (in_list);

/* get the first, or only letter in the range */

		call get_next_token (ignore_symtab_entry, ignore_value);
		if token ^= ident | symbol_length ^= 1 then do;
		     call print_message (45, err_string ());
		     go to statement_parse_abort;
		end;

		begin_char, end_char = index (alphabetic, substr (full_name, 1, 1));

/* there is a second letter if the first is followed by a hyphen */

		call get_next_token$operator;		/* get comma, right paren, or hyphen (minus) */
		if token = minus then do;
		     call get_next_token (ignore_symtab_entry, ignore_value);
		     if token ^= ident | symbol_length ^= 1 then do;
			call print_message (45, err_string ());
			go to statement_parse_abort;
		     end;

		     end_char = index (alphabetic, substr (full_name, 1, 1));

/* insure the range specified is valid */

		     if end_char < begin_char then do;
			call print_message (46);	/* chars wrong order */
			go to statement_parse_abort;
		     end;

		     if divide (begin_char - 1, 26, 17, 0) ^= divide (end_char - 1, 26, 17, 0) then do;
			call print_message (47);
			go to statement_parse_abort;
		     end;

		     call get_next_token$operator;	/* get comma or right paren */
		end;

/* regardless of how we got the range, see if it's been used before */

		if substr (mode_defined, begin_char, end_char - begin_char + 1) ^= ZERO then
		     call print_message (129);

		substr (mode_defined, begin_char, end_char - begin_char + 1) = (26)"1"b;

/* set range to desired type */

		do i = begin_char to end_char;
		     default_table (i) = attributes;
		end;
		if token ^= comma then
		     in_list = FALSE;
	     end;
	     if token ^= right_parn then
		go to missing_right_paren;

	     call get_next_token$operator;		/* get comma or eos */
	     if token ^= comma then
		in_stmnt = FALSE;
	end;
	go to parse_done;


/* Case		Dimension

Syntax:

Polish:

Notes:
*/
parser (12):
	in_list = TRUE;
	do while (in_list);
	     call get_next_token (force_symtab_entry, SI);
	     if token ^= ident then
		go to missing_identifier;

	     if addr (OS (SI)) -> symbol.referenced	/* Symbol has already been used */
		then
		call print_message (140, SI, (keyword_table (statement_type)));

	     call get_next_token$operator;		/* get left paren */
	     if token ^= left_parn then
		go to missing_left_paren;

	     call get_bounds (SI);
	     if token ^= comma then
		in_list = FALSE;
	end;
	go to parse_done;


/* Case		Common

Syntax:	[ / [ <name> ] / ] <list> [ / [ <name> ] / <list> ] ...

Polish:	<non_executable>

Notes:
	common_name	8 (?)-character name of common block, also used in block_data statement parse
	in_stmnt		on while parsing a common block list; off if current list not followed by another list
	SI		passes output from get_next_token to other subroutines
	indx		word offset of current common block header node
	in_list		on while conditions for loop still hold
*/
parser (13):
	call get_next_token (force_symtab_entry, SI);	/* Get slash or first member of list. */

	in_stmnt = TRUE;				/* Indicates more text left to parse. */
	do while (in_stmnt);			/* Loop for each common list. */

/* Get common block name. */

	     if token = slash			/* Name is given explicitly. */
	     then do;
		call get_next_token (ignore_symtab_entry, ignore_value);
						/* Get slash or block name. */

		if token ^= ident then
		     go to missing_identifier;
		common_name = substr (full_name, 1, symbol_length);
						/* save block name */

		call get_next_token$operator;		/* Get slash. */

		if token ^= slash then
		     go to missing_slash;

		call get_next_token (force_symtab_entry, SI);
						/* Get first member of list. */
	     end;
	     else if token = concat			/* Two slashes in a row */
	     then do;
		common_name = blank_common_name;
		call get_next_token (force_symtab_entry, SI);
	     end;
	     else
		common_name = blank_common_name;	/* initial common name is omitted */

/* Find header node if already defined or create a new one. */

	     indx = sub_ptr -> common_chain;		/* Get head of list. */
	     if indx = 0 then do;

/* create a header node for this common block and thread into chain */

		indx = build_common_block (common_name);
		sub_ptr -> common_chain = indx;
	     end;

	     else do;				/* List is not empty. */
		in_list = TRUE;
		do while (in_list);			/* Search the list. */
		     if addr (OS (indx)) -> header.block_name = common_name then
			in_list = FALSE;		/* Found old block. */
		     else if addr (OS (indx)) -> header.next_header = 0 then do;
						/* End of list and not found. Create a new header node. */
			in_list = FALSE;		/* Indicate end of search. */

			addr (OS (indx)) -> header.next_header = build_common_block (common_name);
			indx = addr (OS (indx)) -> header.next_header;
		     end;

		     else
			indx = addr (OS (indx)) -> header.next_header;
		end;
	     end;


/* If needed, generate cross reference nodes */

	     if produce_listing then
		call generate_cross_ref (indx);


/* Parse common block list. */

	     in_list = TRUE;
	     do while (in_list);
		if token ^= ident then
		     go to missing_identifier;

		if addr (OS (SI)) -> symbol.referenced	/* Symbol has already been used */
		     then
		     call print_message (140, SI, (keyword_table (statement_type)));

		if declare_symbol (SI, member_attr, member_conflicts, DECLARED) then do;

/* Thread new member into common block list. */

		     if addr (OS (indx)) -> header.last_element = 0 then
			addr (OS (indx)) -> header.first_element = SI;
		     else
			addr (OS (addr (OS (indx)) -> header.last_element)) -> symbol.next_member = SI;
		     addr (OS (indx)) -> header.last_element = SI;

		     addr (OS (SI)) -> symbol.parent = indx;

/* insure it is initialized only in a block data subprogram */

		     if addr (OS (SI)) -> symbol.initialed then
			if sub_ptr -> subprogram_type = block_data then
			     string (addr (OS (indx)) -> header.storage_info) =
				string (addr (OS (indx)) -> header.storage_info)
				| string (addr (OS (SI)) -> symbol.storage_info);
			else
			     call print_message (80, SI);
		end;

		else
		     call print_message (20, SI, indx); /* Cannot be in this common block. */

/* Process member bound, next member, or end of list. */

		call get_next_token$operator;		/* Get left paren, comma, or slash. */
		if token = left_parn then
		     call get_bounds (SI);

		if token = comma then do;
		     call get_next_token (force_symtab_entry, SI);
						/* Get next member of list. */
		     if token = slash | token = concat then
			in_list = FALSE;
		end;
		else
		     in_list = FALSE;
	     end;
	     if token ^= slash & token ^= concat then
		in_stmnt = FALSE;
	end;
	go to parse_done;


/* Case		Equivalence

Syntax:

Polish:

Notes:
	78.06.20 - Parse has been changed so that symbol.equivalenced DOES NOT imply that symbol.parent
		is valid. symbol.equivalenced may be TRUE while symbol.parent equals zero.

	Automatic storage is equivalence conflict.
*/
parser (14):
	in_stmnt = TRUE;
	do while (in_stmnt);
	     call get_next_token$operator;		/* get left paren */
	     if token ^= left_parn then
		go to missing_left_paren;

	     if token_list (current_token + 2).type = right_parn then do;
		call print_message (28);		/* at least two required in group */
		go to statement_parse_abort;
	     end;

	     call stack_operand ((cur_statement));	/* For error messages. */

	     in_list = TRUE;
	     do while (in_list);
		call get_next_token (force_symtab_entry, SI);
		if token ^= ident then
		     go to missing_identifier;

		E_token = SI;
		if addr (OS (SI)) -> symbol.referenced	/* Symbol has already been used */
		     then
		     call print_message (140, SI, (keyword_table (statement_type)));
		else
		     addr (OS (SI)) -> symbol.in_equiv_stmnt, addr (OS (SI)) -> symbol.equivalenced,
						/* mark as equiv'd */
			addr (OS (SI)) -> symbol.variable = TRUE;
						/* must remain a variable */

		call stack_operand (SI);

		call get_next_token$paren_operator;	/* get comma, left paren, substring left paren, or right paren */

		if token = left_parn | token = substr_left_parn then do;

		     if token = left_parn		/* Parse subscripts */
			then
			call stack_operand (get_constant_offset (SI, FALSE));
						/* inhibit variable subscripts */

		     if token = substr_left_parn	/* Parse substring */
		     then do;
			if ^subr_options.ansi_77 then do;
			     call print_message (154);
			     goto statement_parse_abort;
			end;
			call stack_operand (0);

			call get_next_token (ignore_symtab_entry, SI);
			if token = dec_int then do;
			     E_start = binary (addr (st_copy) -> token_structure.token_string, 17);

/* Check the constant start is in range */
			     if (E_start < 1) then
				call print_message (155, SI, "Start has a length < 1.");
			     else if (E_start > addr (OS (E_token)) -> symbol.char_size + 1) then
				call print_message (155, SI, "Start > length.");
			     else
				call stack_operand (E_start - 1);

			     call get_next_token$operator;
			     if token = colon then do;

				call get_next_token (ignore_symtab_entry, SI);
				if token = dec_int then do;
				     E_finish = binary (addr (st_copy) -> token_structure.token_string);

/* Check if the constant finish is in range */
				     if (E_finish < E_start) then
					call print_message (155, SI, "Finish < start.");
				     if (E_finish > addr (OS (E_token)) -> symbol.char_size + 1) then
					call print_message (155, SI, "Finish > length.");
				     call get_next_token$operator;
				end;
				else if token ^= right_parn then
				     go to invalid_substring;
			     end;
			     else
				go to invalid_substring;
			     call get_next_token$operator;
			end;
			else if token = colon then do;
			     E_start = 1;
			     call stack_operand (E_start - 1);
			     call get_next_token (ignore_symtab_entry, SI);
			     if token = dec_int then do;
				E_finish = binary (addr (st_copy) -> token_structure.token_string);
						/* Check if the constant finish is in range */
				if (E_finish < 1) then
				     call print_message (155, SI, "Finish < 1.");
				if (E_finish > addr (OS (E_token)) -> symbol.char_size + 1) then
				     call print_message (155, SI, "Finish > length.");
				call get_next_token$operator;
			     end;
			     else if token ^= right_parn then
				go to invalid_substring;
			     call get_next_token$operator;
			end;
			else
			     go to invalid_substring;
		     end;
		     else
			call stack_operand (0);
		end;
		else do;
		     call stack_operand (0);
		     call stack_operand (0);
		end;

		if token ^= comma then
		     in_list = FALSE;
	     end;

	     if token ^= right_parn then
		go to missing_right_paren;

	     call stack_operator (-1);		/* End of equivalence group. */
	     stack_base = stack_index;		/* Prevent the info from being lost. */

	     call get_next_token$operator;		/* get comma or eos */
	     if token ^= comma then
		in_stmnt = FALSE;
	end;
	go to parse_done;


/* Case		Character, Complex, Double Precision, Integer, Logical, Real

Syntax:	[ * k ] <name> [ * k ] [ ( d1 , ... dn ) ] ... [ / <constants> / ] ...

Polish:	<non_executable> [ <increment_polish_op> <halfword> <junk> ]
     where
	<halfword> is the number of halfwords in <junk>
	<junk> is the code representing the data specifications.

Notes:
	mode_type		mode, or data type, specified by this statement
	in_stmnt		on if data specifications are encountered; otherwise off
	char_siz		used only for char stmnt; global char size to be used
	attributes	attributes to be aplied to the variable being declared
	SI		passes output from get_next_token to other subroutines
*/
parser (15):
parser (16):
parser (17):
parser (18):
parser (19):
parser (20):
	mode_type = statement_type - first_mode_keyword + 1;
						/* Convert stmnt type to mode. */
	first_word = 0;				/* No "nodes" generated by data specs. */
	char_siz = default_char_size;			/* Only used if mode is character. */
	attributes = attr_table (mode_type);
	call get_mode_size (mode_type, char_siz, attributes, asterisk_seen);
						/* Get the global mode for this statement. */

	in_list = TRUE;
	do while (in_list);				/* Loop thru variable list. */
	     call get_next_token (force_symtab_entry, SI);/* Get variable name. */
	     if token ^= ident then
		go to missing_identifier;

	     if addr (OS (SI)) -> symbol.referenced	/* Symbol has already been used */
		then
		call print_message (140, SI, (keyword_table (statement_type)));

	     local_attributes = attributes;
	     call get_mode_size ((mode_type), (char_siz), local_attributes, asterisk_seen);
						/* Get local attributes, but save global ones. */

	     call stack_operand (SI);			/* Stack it in case of data specifications. */

	     call get_next_token$operator;		/* Get left paren, slash, comma, or eos. */

	     if token = left_parn then do;
		call get_bounds (SI);		/* Declaring bounds in mode stmnt. */
		if ^asterisk_seen & mode_type = char_mode then do;
		     current_token = current_token - 1;
		     call get_mode_size ((mode_type), (char_siz), local_attributes, asterisk_seen);
		     call get_next_token$operator;
		end;
	     end /* left_parn */;
	     if ^declare_symbol (SI, local_attributes, type_conflicts, DECLARED) then
		call print_message (30, keyword_table (statement_type), SI);

	     if token = slash then
		call parse_data;			/* Data spec in mode stmnt. */

	     if token ^= comma then
		in_list = FALSE;			/* If no comma, list is done. */
	end;

/* If data specs generated "nodes" in polish, must indicate how many halfwords are used. */
	if first_word ^= 0 then
	     polish_string (first_word) = next_free_polish - first_word - 1;

	go to parse_done;


/* Case		External

Syntax:

Polish:

Notes:
*/
parser (21):
	in_list = TRUE;
	do while (in_list);
	     call get_next_token (force_symtab_entry, SI);
	     if token ^= ident then
		go to missing_identifier;

	     if addr (OS (SI)) -> symbol.referenced	/* Symbol has already been used */
		then
		call print_message (140, SI, (keyword_table (statement_type)));

/* In ansi66 mode, builtin functions may be declared in external statements */

	     if ^(sub_ptr -> subprogram.options.ansi_77) & (builtin_lookup (SI, NOT_SET)) then do;
		if ^declare_symbol (SI, no_attributes, bif_conflicts, DECLARED) then
		     call print_message (30, keyword_table (statement_type), SI);
		if (builtin_lookup (SI, SET_ATTR)) then do;
		     call get_next_token$operator;
		     in_list = (token = comma);
		end;
	     end;
	     else do;
		if ^declare_symbol (SI, ext_attributes, ext_conflicts, DECLARED) then
		     call print_message (30, keyword_table (statement_type), SI);

		call get_next_token$operator;		/* get comma, left paren, or eos */

/* the name may optionally be followed by "(descriptors)" */

		if token = left_parn then do;
		     call get_next_token (ignore_symtab_entry, ignore_value);
						/* get "descriptors" */
		     if token ^= ident | substr (full_name, 1, symbol_length) ^= "descriptors" then do;
			call print_message (044, "descriptors", err_string ());
			go to statement_parse_abort;
		     end;

		     call get_next_token$operator;	/* get right paren */
		     if token ^= right_parn then
			go to missing_right_paren;

		     addr (OS (SI)) -> symbol.needs_descriptors = TRUE;
		     addr (OS (SI)) -> symbol.variable_arglist = TRUE;
		     call get_next_token$operator;	/* get comma or eos */
		end;

		if token ^= comma then
		     in_list = FALSE;
	     end;
	end;
	go to parse_done;

/* Case		Intrinsic

Syntax:	<fun> [,<fun>] where <fun> in a builtin function name

Polish:	None

Notes:	Check to see name is not referenced and no declaration conflicts.

*/
parser (22):
	in_list = TRUE;
	do while (in_list);
	     call get_next_token (force_symtab_entry, SI);
	     if token ^= ident then
		goto missing_identifier;

	     if addr (OS (SI)) -> symbol.referenced	/* symbol previously used */
		then
		call print_message (140, SI, (keyword_table (statement_type)));

	     if ^declare_symbol (SI, no_attributes, bif_conflicts, DECLARED) then
		call print_message (30, keyword_table (statement_type), SI);

	     if ^builtin_lookup (SI, SET_ATTR)		/* name is not recognized as a builtin */
		then
		call print_message (93, SI);

	     call get_next_token$operator;		/* get comma or EOS */
	     in_list = (token = comma);
	end /* in_list loop */;
	goto parse_done;

/* Case		Namelist

Syntax:

Polish:

Notes:
	Not Audited.
*/
parser (23):
	call get_next_token$operator;			/* get slash */
	if token ^= slash then
	     go to missing_slash;

	in_stmnt = TRUE;
	do while (in_stmnt);
	     call get_next_token (force_symtab_entry, SI);
	     if token ^= ident then
		go to missing_identifier;

	     if ^declare_symbol (SI, namelist_attr, all_attributes, DECLARED) then do;
		if last_statement_type = statement_type & last_namelist = SI then do;
		     word_offset = last_namelist_word_offset;
		     next_free_polish = cur_statement;
		     cur_statement = last_cur_statement;
		end;
		else
		     call print_message (30, keyword_table (statement_type), SI);
	     end;
	     else do;
		call emit_operator (increment_polish_op);
		call emit_count (word_offset);
		polish_string (word_offset) = 0;	/* count will always be correct */
		addr (OS (SI)) -> symbol.initial = word_offset;
	     end;

	     last_namelist = SI;
	     last_namelist_word_offset = word_offset;

	     call get_next_token$operator;		/* get slash */
	     if token ^= slash then
		go to missing_slash;

	     in_list = TRUE;
	     do while (in_list);
		call get_next_token (force_symtab_entry, SI);
		if token ^= ident then
		     go to missing_identifier;

		if ^declare_symbol (SI, variable_attributes, variable_conflicts, REF) then
		     call print_message (10, SI);

		call emit_operand (SI);		/* list is saved in the polish */
		polish_string (word_offset) = polish_string (word_offset) + 1;
						/* keep count accurate */

		call get_next_token$operator;		/* get comma, slash, or eos */
		if token ^= comma then
		     in_list = FALSE;
	     end;
	     if token ^= slash then
		in_stmnt = FALSE;
	end;
	go to parse_done;


/* Case		Parameter

Syntax:

Polish:

Notes:
	Not Audited.
*/
parser (24):
	call get_next_token (force_symtab_entry, SI);
	in_list = TRUE;

/* To de-implement the old style PARAMETER statement, delete the block of
   code at old_parameter_stmt, and replace the following statement with:

	if token ^= left_parn then go to missing_left_paren;

*/

	if token ^= left_parn then
	     go to old_parameter_statement;

/* New style parameter statement.  Using parse_expression, while round-about
   insures consistency of expression interpretation with what would be done
   at run-time.
*/

	parameter_info.start_of_polish = next_free_polish;

	do while (in_list);
	     call get_next_token (force_symtab_entry, SI);
	     if token ^= ident then
		go to missing_identifier;

	     if ^declare_symbol (SI, named_const_attr, named_const_conflicts, DECLARED) then do;
		call print_message (30, "named constant", SI);
		SI = 0;				/* indicates an error. */
	     end;
	     current_parameter = SI;

	     call get_next_token$operator;		/* get equals  */
	     if token ^= assign then
		go to missing_equals_sign;

	     call get_next_token (force_symtab_entry, SI);

	     call parse_expression (any_expression, SI, ignore_bits);

	     if current_parameter > 0 then do;
		call assign_data_type (current_parameter);

		param_ptr = addr (OS (current_parameter));
		parameter_info.stack_index = stack_index;
		parameter_info.max_stack = max_stack;
		parameter_info.desired_data_type = index (string (param_ptr -> symbol.mode), "1"b);
		parameter_info.end_of_polish = next_free_polish - 1;
		parameter_info.rounding = subr_options.do_rounding;

		call fort_eval_parm (addr (parameter_info), (param_ptr -> symbol.name), error_code);
		max_stack = parameter_info.max_stack;

		if error_code = 0 then do;

/* non-star-extent character parameters require different treatment, since the string must be padded or truncated
   or padded with blanks to make it of the declared length */

		     if param_ptr -> symbol.mode.character then do;

/* for star extent stuff, set the length to the length of the calculated string, otherwise pad on the right
   with blanks or truncated to set to declared length */

			if param_ptr -> symbol.star_extents then do;
			     param_ptr -> symbol.initial = parameter_info.result_location;
			     param_ptr -> symbol.star_extents = "0"b;
			     param_ptr -> symbol.mode_bits.char_size =
				addr (OS (parameter_info.result_location)) -> char_constant.length - 1;
			end;
			else do;
			     param_ptr -> symbol.initial =
				create_char_constant (
				substr (addr (OS (parameter_info.result_location)) -> char_constant.value
				|| copy (" ", max_char_length), 1, param_ptr -> symbol.mode_bits.char_size + 1));
			end;
		     end /* character parameters */;

		     else do;
			param_ptr -> symbol.initial = parameter_info.result_location;
		     end /* non_character params */;

		end /* error_code = 0 */;

		else do;
		     param_ptr -> symbol.initial = 0;
		end /* non_zero error_codes */;


	     end;

	     next_free_polish = parameter_info.start_of_polish;

	     if token ^= comma then
		in_list = FALSE;
	end;

	if token ^= right_parn then
	     go to missing_right_paren;
	current_token = current_token + 1;		/* Skip over the right paren. */

	go to parse_done;

old_parameter_statement:
	first_time = TRUE;

	do while (in_list);
	     if ^first_time then
		call get_next_token (force_symtab_entry, SI);
	     first_time = FALSE;

	     if token ^= ident then
		go to missing_identifier;

	     if ^declare_symbol (SI, named_const_attr, all_attributes, DECLARED) then do;
		call print_message (30, "named constant", SI);
		SI = 0;				/* indicates an error */
	     end;

	     call get_next_token$operator;		/* get equals */
	     if token ^= assign then
		go to missing_equals_sign;

	     call get_next_token (ignore_symtab_entry, const_index);
						/* get constant or sign */

	     call parse_a_constant (FALSE, const_index, ignore_octal_value);
						/* FALSE= octal is invalid */

	     if SI > 0 then
		addr (OS (SI)) -> symbol.initial = const_index;
						/* store it only if valid */

	     call get_next_token$operator;		/* get comma or eos */
	     if token ^= comma then
		in_list = FALSE;
	end;
	go to parse_done;


/* Case		Library

Syntax:

Polish:

Notes:
*/
parser (25):
	call get_next_token (ignore_symtab_entry, const_index);

	if token ^= char_string then do;
	     call print_message (53, err_string ());	/* missing char ref */
	     go to statement_parse_abort;
	end;

	if options.compile_only			/* If compiling, call our own routine. */
	     then
	     call add_to_lib_list (addr (OS (const_index)) -> char_constant.value, code);
	else
	     call add_to_lib_list_run (addr (OS (const_index)) -> char_constant.value, code);

	if code ^= 0 then
	     call print_message (54);			/* illegal pathname */
	current_token = current_token + 1;
	go to parse_done;


/* Case		Save

Syntax: <eos> | <save-element> [,<save-element>]
	where save-element is an array-name, a variable-name, or /common-block-name/

Polish: None

Notes: This statement serves to set the save attributes for a symbol.
*/
parser (26):					/* Save statements and automatic statements cannot co-exist in a program unit. */
	if have_auto_stmnt then do;
	     call print_message (38);
	     go to statement_parse_abort;
	end;

/* If there is no list, this is a global save statement. */

	if current_token >= last_token then do;
	     if have_save_stmnt then
		call print_message (33);		/* global save must be only save stmnt */
	     else
		sub_ptr -> default_is.static = TRUE;

	     have_save_stmnt = TRUE;

	     current_token = current_token + 1;
	     go to parse_done;
	end;

/* Particular save statement may not follow global one. */

	if sub_ptr -> default_is.static then
	     call print_message (33);			/* global save statement already encountered */
	else
	     sub_ptr -> default_is.auto = TRUE;

	have_save_stmnt = TRUE;

/* Parse list of variable names. */

	in_list = TRUE;
	do while (in_list);
	     call get_next_token (force_symtab_entry, SI);

/* if this is a common-block-name, add a header if not there already. header.first_element will be zero */

	     if token = slash then do;
		call get_next_token (ignore_symtab_entry, ignore_value);
		if token ^= ident then
		     goto missing_identifier;
		common_name = substr (full_name, 1, symbol_length);
		not_found = TRUE;
		indx = sub_ptr -> common_chain;

		do while (indx ^= 0 & not_found);
		     if substr (addr (OS (indx)) -> header.block_name, 1, symbol_length) = common_name then
			not_found = FALSE;
		     else
			indx = addr (OS (indx)) -> header.next_header;
		end /* search loop for common-block-name */;

/* if not found, then add the header to the end of the chain of headers (or to the start if this is the first header). */

		if not_found then do;
		     SI = build_common_block (common_name);
		     if sub_ptr -> common_chain = 0 then
			sub_ptr -> common_chain = SI;
		     else
			addr (OS (indx)) -> header.next_header = SI;
		end;
		call get_next_token$operator;
		if token ^= slash then
		     goto missing_slash;
	     end;
	     else if token ^= ident then
		go to missing_identifier;

	     else do;
		if addr (OS (SI)) -> symbol.referenced	/* Symbol has already been used */
		     then
		     call print_message (140, SI, (keyword_table (statement_type)));

		if ^declare_symbol (SI, save_attributes, save_conflicts, DECLARED) then
		     call print_message (30, keyword_table (statement_type), SI);
	     end;
	     call get_next_token$operator;		/* get comma or eos */
	     if token ^= comma then
		in_list = FALSE;
	end;
	go to parse_done;


/* Case		Automatic

Syntax:

Polish:	non_executable {increment_polish_op}

Notes:
	Not audited.
*/
parser (27):					/* save and automatic statements cannot co-exist in a single program unit */
	if have_save_stmnt then do;
	     call print_message (38);
	     go to statement_parse_abort;
	end;

	have_auto_stmnt = TRUE;
	sub_ptr -> default_is.static = TRUE;


	in_list = TRUE;
	do while (in_list);				/* Loop thru variable list. */
	     call get_next_token (force_symtab_entry, SI);/* Get variable name. */
	     if token ^= ident then
		go to missing_identifier;

	     if addr (OS (SI)) -> symbol.referenced	/* Symbol has already been used */
		then
		call print_message (140, SI, (keyword_table (statement_type)));

	     if ^declare_symbol (SI, auto_attribute, save_conflicts, DECLARED) then
		call print_message (30, keyword_table (statement_type), SI);

	     call stack_operand (SI);			/* Stack it in case of data specifications. */

	     call get_next_token$operator;		/* Get left paren or comma. */

	     if token = left_parn then
		call get_bounds (SI);		/* Declaring bounds in automatic stmnt. */

	     if token ^= comma then
		in_list = FALSE;			/* If no comma, list is done. */
	end;

	go to parse_done;


/* Case		Statement Function Definition

Syntax:

Polish:

Notes:
	label_ptr		set in parse loop to point to stmnt's label node
	SI		st func name
	indx		arg as provided by user
	new		arg used by compiler
	old		previous member of hash chain for indx
*/
parser (28):
	saved_number_of_crefs = number_of_crefs;

	call get_next_token (force_symtab_entry, SI);
	if token ^= ident then
	     go to missing_identifier;

	if token_list (current_token + 1).type = left_parn & ^COLON_BEFORE_ASSIGN then
	     if declare_symbol (SI, asf_attribute, asf_conflicts, DECLARED) then do;

		profile_size = profile_size + 1;	/* profile entry required by this statement */
		string (cur_stmnt_ptr -> statement.bits) = put_in_profile;

		current_token = current_token + 1;

/* The statement function definition (sfd) will now be placed in the polish string
		   using the expression parser. The fields, symbol.initial and symbol.dimension,
		   are used to store the offset of the first word of the sfd and the offset of
		   the first word after the sfd. If the sf is not referenced, these values are
		   used to "remove" the sfd from the polish string. */

		addr (OS (SI)) -> symbol.initial = next_free_polish;
						/* offset of first word. */

		call emit_operand (SI);
		call emit_operator (sf_def_op);
		last_element = 0;
		count = 0;

/* if the next token is a right_paren, then an empty arg list, no need to scan */
		in_list = (token_list (current_token + 1).type ^= right_parn);
		if ^in_list then
		     call get_next_token$operator;

		do while (in_list);
		     call get_next_token (locate_symtab_entry, indx);
		     if token ^= ident then
			go to missing_identifier;

		     count = count + 1;

		     if indx = 0 then
			call find_symbol_index (symbol_length, new, force_symtab_entry, old);
		     else do;
			call find_symbol_index (symbol_length, indx, force_symtab_entry, old);
			new = build_symbol (substr (full_name, 1, symbol_length),
			     unspec (addr (OS (indx)) -> symbol.mode_bits), DECLARED);
			addr (OS (new)) -> symbol.hash_chain = indx;

			if old > hbound (hash_table, 1) then
			     addr (OS (old)) -> symbol.hash_chain = new;
			else
			     hash_table (old) = new;
		     end;

		     if ^declare_symbol (new, auto_attribute, variable_conflicts, DECLARED) then
			call print_message (30, keyword_table (statement_type), new);
						/* conflicting attr. */

		     addr (OS (new)) -> symbol.parent = old;
		     addr (OS (new)) -> symbol.general = last_element;

		     addr (OS (new)) -> symbol.by_compiler = TRUE;
						/* flag as special symbol */
		     addr (OS (new)) -> symbol.dummy_arg = TRUE;
						/* flag as stmnt func param */

		     if last_element = 0 then
			addr (OS (SI)) -> symbol.next_member = new;
		     else
			addr (OS (last_element)) -> symbol.next_member = new;
		     last_element = new;

		     call get_next_token$operator;	/* get comma or right paren */
		     if token ^= comma then
			in_list = FALSE;
		end;
		if token ^= right_parn then
		     go to missing_right_paren;

		call get_next_token$operator;		/* get equals */
		if token ^= assign then
		     go to missing_equals_sign;

		call get_next_token (force_symtab_entry, indx);
		call parse_expression (any_expression, indx, ignore_bits);

		do i = last_element repeat addr (OS (i)) -> symbol.general while (i ^= 0);
		     if ^addr (OS (i)) -> symbol.referenced
						/* Check for unused parameter. */
		     then do;
			addr (OS (i)) -> symbol.allocate = TRUE;
			call print_message (68, i, SI);
		     end;

		     old = addr (OS (i)) -> symbol.parent;

		     if old > hbound (hash_table, 1) then
			addr (OS (old)) -> symbol.hash_chain = addr (OS (i)) -> symbol.hash_chain;
		     else
			hash_table (old) = addr (OS (i)) -> symbol.hash_chain;

		     addr (OS (i)) -> symbol.parent = SI;
		end;

		call emit_operator (exit_op);

		addr (OS (SI)) -> symbol.dimension = next_free_polish;
						/* offset of 1st word after sfd */

		if count > 511 then do;
		     call print_message (55, 511 - bias);
						/* implementation restriction */
		     count = 511;
		end;

		addr (OS (SI)) -> symbol.char_size = count;

		go to parse_done;
	     end;

/* Control passes this point only if the statement cannot be an asf def. Stmnt becomes an assignment. */

	call finish_sf_defs;			/* End of sf defs. Emit by-pass label. */

/* Process all pending entries now. */
	if pending_entry_cnt > 0 then
	     call process_pending_entries;

	current_token = first_token - 1;
	number_of_crefs = saved_number_of_crefs;

	if statement_label ^= 0 then do;
	     string (addr (OS (statement_label)) -> label.usage) = executable_label;
	     call emit_operand (statement_label);
	     call emit_operator (label_op);
	end;

	statement_type = assignment_statement;
	keyword_index = first_keyword (assignment_statement);

/* assignment statement parse code must follow. */


/* Case		Assignment

Syntax:

Polish:

Notes:
*/
parser (60):
	profile_size = profile_size + 1;		/* profile entry required by this statement */
	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;

	call get_next_token (force_symtab_entry, SI);

/* test for the assignment being to the typeless function "fld".  This is the
only builtin function that can appear on the left hand side of an equal sign */

	if (addr (OS (SI)) -> symbol.name = "fld" & ^addr (OS (SI)) -> symbol.dimensioned
	     & token_list (current_token + 1).type = left_parn & ^addr (OS (SI)) -> symbol.mode.character) then do;
	     call get_next_token (force_symtab_entry, SI);/* swallow left paren */
	     call get_next_token (force_symtab_entry, SI);
	     do i = 1 to 2;
		call parse_expression (any_expression, SI, ignore_bits);
		if token ^= comma then
		     go to missing_comma;
		call get_next_token (force_symtab_entry, SI);
	     end;
	     call parse_expression (set_reference, SI, ignore_bits);
	     if token ^= right_parn then
		go to missing_right_paren;
	     call get_next_token (force_symtab_entry, SI);
	     if token ^= assign then
		go to missing_equals_sign;
	     call get_next_token (force_symtab_entry, SI);
	     call parse_expression (any_expression, SI, ignore_bits);
	     call emit_operator (lhs_fld_op);
	     go to parse_done;
	end;
	call parse_expression (set_reference, SI, ignore_bits);
	if token ^= assign then
	     go to missing_equals_sign;

	call get_next_token (force_symtab_entry, SI);
	call parse_expression (any_expression, SI, ignore_bits);
	call emit_operator (assign_op);
	go to parse_done;

/* Case		Elseif

Syntax:	elseif <left_parn> <expression> <right_parn> then

Polish: 	<item_op> <polish for expression> <else_if_op>

Notes:	Must check for proper nesting, but in most ways this is much like
the parsing of block if's, so we parse it the same way.  A new statement is
created for the logical expression and else_if_op for the benefit of profiling
and setting breakpoints.

*/

parser (30):					/* this stmnt NOT in profile or map */
	call emit_operator (item_op);			/* elseif's terminate previous block ifs */
	call emit_statement_op (cur_stmnt_ptr);		/* make new statement for if part */
						/* fall through to if parser */

/* Case		If

Syntax:	if <left_parn> <expression> <right_parn> <logical, block or arithmetic if>
	<logical if> ::= <some legit second statment>
	<arithmetic if>::= <a sequence of labels for jumps>
	<block if>::= then

Polish:

Notes:
*/

parser (29):
	profile_size = profile_size + 1;		/* profile entry required by this statement */
	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;

/* Parse if statement expression. */

	call get_next_token$operator;			/* Get left paren. */
	if token ^= left_parn then
	     go to missing_left_paren;

	call get_next_token (force_symtab_entry, SI);	/* Get first token of expression. */
	call parse_expression (any_expression, SI, ignore_bits);
	if token ^= right_parn then
	     go to missing_right_paren;

	call get_next_token (ignore_symtab_entry, ignore_value);
						/* Get integer, comma, or statement keyword. */

/* Arithmetic-if statement if integer or comma, and not an ELSEIF. */

	if statement_type ^= elseif_statement & (token = dec_int | token = comma) then do;
	     if END_DO_RANGE & ^logical_if_statement then
		call print_message (16, keyword_table (statement_type));
						/* cannot terminate do loop */

/* Parse three target labels. */

	     do i = 1 to 3;
		if token = dec_int			/* label is given */
		then do;
		     call emit_operand (enter_label (executable_label, (addr (work) -> based_integer), GOTO_REF));
		     call get_next_token$operator;	/* get comma or eos */
		end;

		else if token = comma | token = EOS_token
						/* label is omitted */
		then do;
		     must_have_label = FALSE;
		     call emit_count (ignore_value);
		end;

		else
		     go to missing_label;		/* syntax error */

/* Commas must appear between the labels, even if the labels are omitted. */

		if i < 3 then do;
		     if token ^= comma then
			go to missing_comma;

		     call get_next_token$label (ignore_symtab_entry, ignore_value);
		end;
	     end;
	     call emit_operator (jump_arithmetic_op);
	     go to parse_done;
	end;

/* Parse logical-if, block-if, and else-if statements. */

	if logical_if_statement then
	     call print_message (42, "logical if");	/* illegal second statement */

/* distinguish between logical if's and (block if's and else if's) */

	logical_if_statement =
	     statement_type ^= elseif_statement & (SECOND_EQUALS | substr (full_name, 1, token_length) ^= "then");
	must_have_label = FALSE;

	if logical_if_statement then do;
	     if SECOND_EQUALS then
		statement_type = assignment_statement;
	     else
		call statement_lex$recognize_statement (statement_type);
						/* Get second stmnt type. */

	     call emit_operator (jump_logical_op);

	     if ^ok_second_statement (statement_type) then
		call print_message (42, keyword_table (statement_type));
						/* illegal second statement */

/* Now process the second statement. In order to make the profile option work usefully, a second
	   stat_op will be generated in the polish. This allows separated counts for the if statement and
	   its then clause. */

	     call emit_statement_op (cur_stmnt_ptr);

	     profile_size = profile_size + 1;		/* profile entry required by this statement */
	     string (cur_stmnt_ptr -> statement.bits) = put_in_profile;

	     current_token = current_token - 1;		/* Backup lex for all parsers. */
	     go to parser (statement_type);
	end /* logical_if_statement */;

	else do;					/*  else if and block if */
	     if END_DO_RANGE then
		call print_message (16, keyword_table (statement_type));

	     if substr (full_name, 1, token_length) ^= "then"
						/* required keyword */
		then
		call print_message (179, "then", keyword_table (statement_type));

	     else if statement_type = elseif_statement then do;
		current_token = current_token + 1;

/* elseif must be nested in blockif's not do loops, peel off erroneous do's */

		do do_index = do_index to 1 by -1 while (do_blockif_stack (do_index).do_loop);
		     call print_message (182, do_blockif_stack (do_index).label_ptr, keyword_table (statement_type));
		end;

		if do_index = 0			/* insure that elseif follows a if at same level */
		     then
		     call print_message (180, keyword_table (statement_type));

		else if do_blockif_stack (do_index).else_seen
						/* cant follow else on same level */
		     then
		     call print_message (181, keyword_table (statement_type));

		else do;
		     call emit_operator (else_if_op);
		     do_blockif_stack (do_index).clauses = do_blockif_stack (do_index).clauses + 1;
		end;
	     end;
	     else do;
		if do_index = hbound (do_blockif_stack, 1)
						/* stack oflo */
		     then
		     call print_message (27, hbound (do_blockif_stack, 1) - bias);
		else do;				/* block if */
		     current_token = current_token + 1;
		     call emit_count (word_offset);
		     call emit_operator (block_if_op);

/* pop up the do_blockif_stack and set values */

		     do_index = do_index + 1;
		     do_blockif_stack (do_index).do_loop = "0"b;
		     do_blockif_stack (do_index).clauses = 1;
		     do_blockif_stack (do_index).line_number = line_number - 1;
		     do_blockif_stack (do_index).count_op = word_offset;
		     do_blockif_stack (do_index).else_seen = "0"b;
		end;
	     end;
	end /* block_if and else if */;
	goto parse_done;

/* Case		Else

Syntax:	else

Polish:	<item op> <else op>

Notes: 	An else clause if valid iff it exists within a block_if  and is nested properly
	within the do_blockif_stack, nor can it be the object of a GOTO .
*/
/* Case		Endif

Syntax: endif

Polish: <item_op> <eol_op>

Notes:  In addition to checking for the nesting of the block_if's and the do loops, the endif
        must also properly set the count in the count_op emitted by the block_if
*/

parser (31):
parser (32):
	profile_size = profile_size + 1;		/* profile entry required by these statements */
	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;
	current_token = current_token + 1;

	if END_DO_RANGE then
	     call print_message (16, keyword_table (statement_type));

	do do_index = do_index to 1 by -1 while (do_blockif_stack (do_index).do_loop);
	     call print_message (182, do_blockif_stack (do_index).label_ptr, keyword_table (statement_type));
	end;

	if do_index = 0				/* nesting check */
	     then
	     call print_message (180, keyword_table (statement_type));

	else if statement_type = else_statement then do;
	     if do_blockif_stack (do_index).else_seen	/* cant have > 1 else at same level */
		then
		call print_message (181, keyword_table (statement_type));
	     else do;
		call emit_operator (item_op);
		call emit_operator (else_op);
		do_blockif_stack (do_index).clauses = do_blockif_stack (do_index).clauses + 1;
		do_blockif_stack (do_index).else_seen = "1"b;
	     end;
	end;

	else do;					/* endif statement */
	     call emit_operator (item_op);
	     call emit_operator (eol_op);

/* having come to the end of the blockif, set count operator reserved by the block if and pop stack */

	     polish_string (do_blockif_stack (do_index).count_op) = do_blockif_stack (do_index).clauses - bias;
	     do_index = do_index - 1;
	end;

	goto parse_done;

/* Case		Goto

Syntax:

Polish:
*/
parser (33):
	profile_size = profile_size + 1;		/* profile entry required by this statement */
	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;

	if END_DO_RANGE & ^logical_if_statement then
	     call print_message (16, keyword_table (statement_type));
						/* cannot terminate do loop */

/* First token of statement determines type of goto. */

	call get_next_token$label (force_symtab_entry, SI);
						/* Get label, name, or left paren. */

	if token = dec_int				/* UNCONDITIONAL GOTO */
	then do;
	     call emit_operand (enter_label (executable_label, (addr (work) -> based_integer), GOTO_REF));
	     call emit_operator (jump_op);
	     current_token = current_token + 1;
	end;

	else if token = ident			/* ASSIGNED GOTO */
	then do;
	     if token_list (current_token + 1).type ^= left_parn then do;
		call parse_expression (simple_reference, SI, out);

		if addr (out) -> expression.not_simple_ref
						/* must check result ourselves */
		     then
		     call print_message (143, SI);
	     end;
	     else do;				/* Let parse expression do its trick */
		token_list (current_token + 1).type = comma;
						/* Tell a white lie */
		call parse_expression (simple_reference, SI, out);
		if addr (out) -> expression.not_simple_ref then
		     call print_message (143, SI);
		token, token_list (current_token).type = left_parn;
	     end;

	     call emit_operator (jump_assigned_op);

	     if token = comma then do;
		call get_next_token$operator;		/* get left paren */
		if token ^= left_parn then
		     go to missing_left_paren;
	     end;

	     if token = left_parn then do;
		call scan_label_list (FALSE);		/* Returns pointing to right paren. */
		current_token = current_token + 1;
	     end;
	end;

	else if token = left_parn			/* COMPUTED GOTO */
	then do;
	     call scan_label_list (TRUE);		/* Returns pointing to right paren. */
	     call get_next_token (force_symtab_entry, SI);
	     if token = comma then
		call get_next_token (force_symtab_entry, SI);
	     call parse_expression (any_expression, SI, ignore_bits);
	     call emit_operator (exit_op);
	     must_have_label = FALSE;			/* label not required after computed goto */
	end;

	else do;					/* syntax error */
	     call print_message (41, err_string ());	/* missing  int, ident, or left paren */
	     go to statement_parse_abort;
	end;
	go to parse_done;


/* Case		Call

Syntax:	<subroutine name> [ ( [ <subroutine arg list> ] ) ]

Polish:	<subroutine name> <arg count> <call_op> [ <arg_list> ] <eol_op>

Notes:
	SI	passes output from get_next_token to parse_expr
*/
parser (34):
	profile_size = profile_size + 1;		/* profile entry required by this statement */
	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;

	call get_next_token (force_symtab_entry, SI);	/* Get subroutine name. */
	if token ^= ident then
	     go to missing_identifier;

	if ^declare_symbol (SI, subroutine_reference, subroutine_conflicts, REF) then
	     call print_message (21, SI);

/* if the arg list contains label constants, must initialize alt ret value */

	if label_args then do;
	     if alternate_return_index = 0		/* first ref so create it */
		then
		alternate_return_index = build_symbol ((NO_NAME), auto_attribute | attr_table (int_mode), PASSED);

	     call emit_operand (alternate_return_index);
	     call emit_operand (value_0);
	     call emit_operator (assign_op);
	end;

/* emit polish for a call statement */

	call emit_operand (SI);
	call emit_count (word_offset);
	call emit_operator (call_op);

/* parse the argument list */

	call get_next_token$operator;			/* Get left paren or eos. */

	if token = left_parn then do;
	     count = 0;

	     if addr (OS (SI)) -> symbol.needs_descriptors then
		arg_type = darg_list_expr;
	     else
		arg_type = arg_list_expr;

	     in_list = (token_list (current_token + 1).type ^= right_parn);
	     if ^in_list then
		call get_next_token$operator;

	     do while (in_list);
		call get_next_token (force_symtab_entry, indx);
						/* Get next argument. expression or label const */

		if token = label_const then do;
		     call stack_operand (indx);
		     call get_next_token$operator;	/* get comma or right paren */
		end;
		else do;
		     call parse_expression (arg_type, indx, ignore_bits);
		     call emit_operator (item_op);
		     count = count + 1;
		end;

		if token ^= comma then
		     in_list = FALSE;
	     end;

	     if token ^= right_parn then
		go to missing_right_paren;
	     current_token = current_token + 1;		/* skip over paren */

/* if there are label args, include alt ret value in arg list */

	     if label_args then do;
		call emit_operand (alternate_return_index);
		call emit_operator (item_op);
		count = count + 1;
	     end;

/* check number of arguments and update count word */

	     if count > max_arglist then
		call print_message (138, max_arglist - bias, SI);

	     polish_string (word_offset) = count - bias;
	end;

	call emit_operator (eol_op);			/* terminate call arg list */

/* alternate return is implemented as computed goto */

	if stack_index - stack_base > 0 then do;
	     call emit_halfword ((stack_index - stack_base) - bias);
						/* count of labels */
	     call emit_operator (jump_computed_op);

	     do i = stack_base to stack_index - 1;	/* copy the labels into the polish */
		call emit_operand (stack (i));
		call emit_operator (item_op);
	     end;
	     call emit_operator (eol_op);		/* end of the list */

	     call emit_operand (alternate_return_index);	/* computed goto expression */
	     call emit_operator (exit_op);		/* end of expression */
	end;
	go to parse_done;


/* Case		Continue

Syntax:

Polish:

Notes:
*/
parser (35):
	profile_size = profile_size + 1;		/* profile entry required by this statement */
	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;

	current_token = current_token + 1;
	go to parse_done;


/* Case		Write

Syntax:

Polish:

Notes:
*/
parser (36):
	profile_size = profile_size + 1;		/* profile entry required by this statement */
	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;

	call parse_io (FALSE);
	go to parse_done;


/* Case		Format

Syntax:

Polish:

Notes:
*/
parser (37):
	if statement_label = 0 then
	     call print_message (37);			/* format statement without label */

	call create_format (format_string, statement_label);
	current_token = last_token + 1;
	go to parse_done;


/* Case		Data

Syntax:

Polish:

Notes:
	The stack is built up with a series of "nodes", which are then interpreted by parse_data as it works its way 
	through the list of data elements.  The first word of each node determines what type of node it is.  A node may
	be any of the following:

	(1) a scalar variable node, which corresponds to the appearance of a scalar variable in the target list.
	It consists of a single word containing the index of the symbol node of the variable.

	(2) an array name node, which corresponds to the appearance of an array name in the target list.  It
	consists of a single word containing the index of the symbol node of the array.

	(3) a BEGIN_DO_LOOP node, which corresponds to the start of an implied do-loop in the target list.  It
	consists of 8 or more words.  The first word contains BEGIN_DO_LOOP, the code for this type of node.  The
	second word contains the index of the symbol node for the index variable of the loop.  The remaining words
	contain the Polish for the initial, final and increment expressions of the loop.  The first word of each
	expression is not part of the Polish, but rather the count of the number of following words which are the
	Polish.  The Polish is slightly nonstandard in that a variable (which must be an index of a containing
	implied loop) is represented by a negative value whose absolute value is the index in the stack of the
	symbol node index of the BEGIN_DO_LOOP node for the implied loop having the variable as its index. (Note
	that 'parse_data' will keep the current value of the loop index in that same location.)

	(4) an END_DO_LOOP node, which corresponds to the end of an implied do-loop in the target list.  It
	consists of a single word containing END_DO_LOOP, the code for this type of node.

	(5) a SUBSTRING node, which corresponds to a substring of a variable in the target list.  It consists
	of 6 or more words.  The first contains SUBSTR, the code for this type of node.  The second contains
	the index of the symbol node for the variable.  The remaining words contain the Polish (in the same
	format as the expressions in a BEGIN_DO_LOOP node) for the start and finish positions of the substring.

	(6) a SUBSCRIPTED_VAR node, which corresponds to a subscripted variable in the target list.  It
	consists of 6 or more words.  The first contains SUBSCRIPTED_VAR, the code for this type of node.
	The second contains the index of the symbol node for the variable.  The remaining words contain the
	Polish for the subscript expressions, in the same format as the expressions in a BEGIN_DO_LOOP node.

	(7) a SUBSCRIPTED_SUBSTR node, which corresponds to a substring of a subscripted variable in the target
	list.  It consists of 10 or more words.  The first contains SUBSCRIPTED_SUBSTR, the code for this type
	of node.  The second contains the index of the symbol node for the variable.  The remaining words contain
	the Polish for the subscript expressions, followed by the Polish for the start and finish positions of the
	substring.

	(8) a SKIP node, which corresponds to a substring, subscripted variable or subscripted substring
	in the target list in which an error was detected.  It consists of a single word containing SKIP,
	the code for this type of node.

	Note that the codes for node types (3) through (8) above are less than or equal to zero so that they can be
	distinguished from node types (1) and (2), which are always positive.
*/
parser (38):
	first_word = 0;				/* No "nodes" generated by data specs. */
	last_paren_parsed = 0;			/* indicates no pre-scan has occurred */

/* Parse each set of variables and constants separately. */

	in_stmnt = TRUE;
	do while (in_stmnt);

	     do_level = 0;				/* no implied do loops encountered */
	     last_do = 0;				/* ditto */

/* Parse variables, subscripted references, and implied do loops. */

	     in_list = TRUE;
	     do while (in_list);

/* Parse left paren or variable. */

		call get_next_token (force_symtab_entry, SI);

/* left paren must delimit an implied do loop */

		if token = left_parn then
		     if is_implied_loop () then do;
			save_current_token = current_token;
						/* remember current token position */
			current_token = paren_info (cur_paren).begin_index;
						/* move up to loop code */

			call stack_operator (BEGIN_DO_LOOP);
						/* stack begin loop operator */
			if do_level = hbound (do_info, 1) then do;
			     call print_message (89, hbound (do_info, 1) - bias);
						/* do loop nesting is too deep */
			     go to statement_parse_abort;
			end;
			else
			     do_info (do_level + 1) = stack_index;
						/* stack pointer to do loop info */

/* process new do loop index variable */

			call get_next_token (force_symtab_entry, indx);
			if token ^= ident then
			     go to missing_identifier;

			do i = 1 to do_level;	/* check for reused index variable */
			     if stack (do_info (i)) = indx then do;
				call print_message (18, indx);
						/* reused loop index */
				go to statement_parse_abort;
			     end;
			end;

			call stack_operand (indx);	/* stack loop index variable */

/* index must be scalar integer variable */

			if addr (OS (indx)) -> symbol.dimensioned then
			     call print_message (141, indx);
			else if (unspec (addr (OS (indx)) -> symbol.attributes) & scalar_conflicts) ^= ZERO then
			     call print_message (141, indx);
			else do;
			     call assign_data_type (indx);
			     if ^addr (OS (indx)) -> symbol.integer then
				call print_message (141, indx);
			end;

			call get_next_token$operator;

/* get equals */
			if token ^= assign then
			     go to missing_equals_sign;

/* Get and stack the initial, final and increment expressions. */
			start_of_expression = stack_index;
			call get_data_statement_expression;
			if stack (start_of_expression) = 0 then
			     goto statement_parse_abort;
			if token ^= comma then
			     go to missing_comma;
			start_of_expression = stack_index;
			call get_data_statement_expression;
			if stack (start_of_expression) = 0 then
			     goto statement_parse_abort;
			if token = comma then do;
			     start_of_expression = stack_index;
			     call get_data_statement_expression;
			     if stack (start_of_expression) = 0 then
				goto statement_parse_abort;
			end;
			else do;			/* Assume increment of 1. */
			     call stack_operand (1);
			     call stack_operand (value_1);
			end;

			if token ^= right_parn then
			     go to missing_right_paren;

			paren_info (cur_paren).position = current_token;
						/* remember end of loop code */
			current_token = save_current_token;
						/* restore scan to proper position */

			last_do = cur_paren;
			do_level = do_level + 1;	/* put this implied loop on stack */
		     end /* is implied do_loop */;

		     else do /* not implied do_loop */;
			call print_message (34);	/* syntax error in do loop */
			go to statement_parse_abort;
		     end;

		else do /* not a left_parn */;
		     if token ^= ident then
			go to missing_identifier;

		     call get_next_token$paren_operator;/* Get left paren, comma, or slash. */

/* Stack variable, substring, subscripted variable, or subscripted substring reference. */

		     symp = addr (OS (SI));
		     if token = left_parn | token = substr_left_parn then do;
						/* substr, subscripted variable or subscripted substring */
			error = FALSE;
			start_of_node = stack_index;
			if token = substr_left_parn then do;
			     call stack_operand (SUBSTR);
			     call stack_operand (SI);
			end;
			else do;
			     call stack_operand (SUBSCRIPTED_VAR);
			     call stack_operand (SI);
			     dp = null;
			     number_of_dims, number_of_subs = 0;
			     if ^symp -> symbol.dimensioned then do;
				call print_message (76, SI);
				error = TRUE;
			     end;
			     else if symp -> symbol.variable_extents then do;
				call print_message (77, SI);
				error = TRUE;
			     end;
			     else do;
				dp = addr (OS (symp -> symbol.dimension));
				number_of_dims = dp -> dimension.number_of_dims;
			     end;

			     have_subscript = TRUE;
			     do while (have_subscript);
				number_of_subs = number_of_subs + 1;
				start_of_expression = stack_index;
				call get_data_statement_expression;
				if stack (start_of_expression) = 0 then
				     error = TRUE;
				else if number_of_subs <= number_of_dims & stack (start_of_expression) = 1
				     & stack (start_of_expression + 1) > last_assigned_op then do;
						/* Verify constant subscript is in range. */
				     subscript =
					addr (addr (OS (stack (start_of_expression + 1))) -> constant.value)
					-> based_integer;
				     if subscript < dp -> dimension.lower_bound (number_of_subs) then do;
					call print_message (78, subscript - bias, "lower", SI);
					error = TRUE;
				     end;
				     else if subscript > dp -> dimension.upper_bound (number_of_subs) then do;
					call print_message (78, subscript - bias, "upper", SI);
					error = TRUE;
				     end;
				end;
				if token ^= comma then
				     have_subscript = FALSE;
			     end;
			     if token ^= right_parn then
				goto missing_right_paren;
			     if number_of_subs ^= number_of_dims & number_of_dims ^= 0 then do;
				call print_message (79, SI, "the wrong number of");
				error = TRUE;
			     end;
			     call get_next_token$paren_operator;
						/* Next token must be an operator. */
			end;
			if token = substr_left_parn then do;
						/* Parse substring start and finish. */
			     if stack (start_of_node) = SUBSCRIPTED_VAR then
				stack (start_of_node) = SUBSCRIPTED_SUBSTR;
			     if ^subr_options.ansi_77 then do;
				call print_message (154);
				error = TRUE;
			     end;
			     if symp -> symbol.character then
				char_siz = symp -> symbol.char_size + 1;
			     else do;
				char_siz = 0;
				call print_message (159, SI);
				error = TRUE;
			     end;

			     inx = 1;
			     if token_list (current_token + 1).type = colon then do;
				call stack_operand (1);
				call stack_operand (value_1);
			     end;
			     else do;
				start_of_expression = stack_index;
				call get_data_statement_expression;
				if token ^= colon then do;
				     call print_message (102, err_string ());
				     goto statement_parse_abort;
				end;
				if stack (start_of_expression) = 0 then
				     error = TRUE;
				else if stack (start_of_expression) = 1
				     & stack (start_of_expression + 1) > last_assigned_op then do;
						/* Check that constant index is in range. */
				     inx = addr (addr (OS (stack (start_of_expression + 1))) -> constant.value)
					-> based_integer;
				     if inx < 1 then do;
					call print_message (155, SI, "start < 1");
					error = TRUE;
				     end;
				     else if inx > char_siz & char_siz ^= 0 then do;
					call print_message (155, SI, "start > length");
					error = TRUE;
				     end;
				end;
			     end;
			     if token_list (current_token + 1).type = right_parn then do;
				call stack_operand (1);
				addr (work) -> based_integer = char_siz;
				call stack_operand (create_constant (int_mode, work));
			     end;
			     else do;
				start_of_expression = stack_index;
				call get_data_statement_expression;
				if token ^= right_parn then
				     goto missing_right_paren;
				if stack (start_of_expression) = 0 then
				     error = TRUE;
				else if stack (start_of_expression) = 1
				     & stack (start_of_expression + 1) > last_assigned_op then do;
						/* Check that constant finish is in range. */
				     jnx = addr (addr (OS (stack (start_of_expression + 1))) -> constant.value)
					-> based_integer;

				     if jnx < inx then do;
					call print_message (155, SI, "finish < start");
					error = TRUE;
				     end;
				     else if jnx > char_siz & char_siz ^= 0 then do;
					call print_message (155, SI, "finish > length");
					error = TRUE;
				     end;
				end;
			     end;
			     call get_next_token$operator;
						/* Next token must be an operator. */
			end;
			if error then do;
			     stack (start_of_node) = SKIP;
			     stack_index = start_of_node + 1;
			end;
		     end;
		     else do /* ident with no parn */;
			call stack_operand (SI);
		     end;

/* comma, end of loop, or end of list must follow reference */

		     need_comma = TRUE;
		     do while (need_comma & in_list);

			if token ^= comma then
			     in_list = FALSE;
			else if last_do > 0 & current_token = paren_info (last_do).begin_index then do;
			     current_token = paren_info (last_do).position;
						/* skip over loop code */
			     last_do = paren_info (last_do).chain;
						/* step up to containing loop */
			     do_level = do_level - 1;

			     call stack_operand (END_DO_LOOP);
						/* end of implied loop */

			     call get_next_token$operator;
						/* get comma or slash */
			end;
			else
			     need_comma = FALSE;
		     end /* need_comma & in_list */;
		end /* not left paren */;
	     end /* loop to parse all list elements */;

	     if token ^= slash then
		go to missing_slash;

/* Parse constant list. */

	     call parse_data;

	     if token ^= comma then
		in_stmnt = FALSE;
	end /* do while (in_stmnt) */;

/* If data specs generated "nodes" in polish, must indicate how many halfwords are used. */

	if first_word ^= 0 then
	     polish_string (first_word) = next_free_polish - first_word - 1;
	go to parse_done;


/* Case		Return

Syntax:

Polish:

Notes:
*/
parser (39):
	profile_size = profile_size + 1;		/* profile entry required by this statement */
	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;

	if END_DO_RANGE & ^logical_if_statement		/* ends a loop only as part of logical if */
	     then
	     call print_message (16, keyword_table (statement_type));
						/* cannot terminate do loop */

	if sub_ptr -> subprogram_type = main_program then
	     call print_message (17, keyword_table (statement_type));
						/* return stmnt illegal in main */

/* if subroutine and text follows keyword, assume alternate return statement */

	call get_next_token (force_symtab_entry, SI);

	if subprogram_op = subr_op & token ^= EOS_token then do;
	     if return_value_param = 0		/* first ref so create it */
		then
		return_value_param = build_symbol ((NO_NAME), param_variable_attrs | attr_table (int_mode), REF);

	     call emit_operand (return_value_param);
	     call parse_expression (any_expression, SI, ignore_bits);
	     call emit_operator (assign_op);
	end;

	call emit_return_op;
	go to parse_done;


/* Case		Backspace, Rewind, Endfile

Syntax:	<expression> <eos> | (<specifier>...) <eos>
	<specifier> ::= [unit] = u | iostat = ios | err = s
Polish:	<expression> <op_code> [<polish for err> <error_label_op>]
		[<polish for iostat> <iostat_op>]

Notes:
	need_PS	indicates presence of an I/O statement
	SI	passes output from get_next_token to parse_expr
	at most one iostat or err and exactly 1 unit specifier
*/
parser (40):					/* rewind */
	op_code = rewind_op;
	io_control_type = rewind_opr;
	goto rewind_endfile_backspace;

parser (41):					/* endfile */
	op_code = endfile_op;
	io_control_type = endfile_opr;
	goto rewind_endfile_backspace;

parser (52):					/* backspace */
	op_code = backspace_op;
	io_control_type = backspace_opr;
	goto rewind_endfile_backspace;

rewind_endfile_backspace:
	profile_size = profile_size + 1;		/* profile entry required by this statement */
	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;

/* Initialize and then begin the parse */

	fields_specified = ZERO;
	string (io_bits) = ZERO;
	io_bits.control_type = bit (binary (io_control_type, 4, 0), 4);
	io_bits.fold = subr_options.fold;
	io_bits.ansi_77 = subr_options.ansi_77;
	io_bits.hfp = subr_options.hfp;
	io_bits.debug_io = subr_options.debug_io;
	count = 0;

	call get_next_token (force_symtab_entry, SI);	/* Get first token of the expr. */
	if token = left_parn			/* Keyword driven */
	then do;
	     in_list = TRUE;
	     do while (in_list);
		call get_next_token (ignore_symtab_entry, ignore_value);

/* if next token is an equals sign, then this may be a true keyword driven value, 
   otherwise it's the expression defining UNIT or some sort of syntactic error */
		count = count + 1;
		if token_list (current_token + 1).type = assign then do;
		     if token ^= ident then
			goto missing_keyword;
		     else if substr (full_name, 1, symbol_length) = "err" then
			call parse_error_label;
		     else if substr (full_name, 1, symbol_length) = "iostat" then
			call parse_iostat_var;
		     else if substr (full_name, 1, symbol_length) = "unit" then
			call parse_unit_specifier (FALSE, FALSE);
						/* asterisk forbidden */
		     else
			goto invalid_keyword;
		end;
		else do;

/* no keyword, UNIT = assumed (if first element in list ) */

		     if count = 1 then
			call parse_unit_specifier$no_keyword (FALSE, FALSE);
		     else
			goto missing_identifier;
		end /* no keyword */;
		in_list = (token = comma);
	     end /* looping over list */;

	     if token ^= right_parn then
		goto missing_right_paren;
	     if ^substr (fields_specified, units_field, 1) then
		call print_message (31, keyword_table (statement_type), "unit");
	     current_token = current_token + 1;
	end /* then clause */;

	else
	     call parse_expression (any_expression, SI, ignore_bits);
	call emit_operand (create_constant (int_mode, string (io_bits)));
	call emit_operator ((op_code));
	sub_ptr -> need_PS = TRUE;
	go to parse_done;


/* Case		Read

Syntax:

Polish:

Notes:
*/
parser (42):
	profile_size = profile_size + 1;		/* profile entry required by this statement */
	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;

	if token_list (current_token + 1).type = left_parn then
	     call parse_io (TRUE);
	else
	     call parse_implied_io (TRUE, value_0, TRUE);
	go to parse_done;


/* Case		Decode, Encode - get and put string

Syntax:

Polish:

Notes:
*/
parser (43):
parser (44):
	profile_size = profile_size + 1;		/* profile entry required by this statement */
	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;

	call get_next_token$operator;			/* Get left paren. */
	if token ^= left_parn then
	     go to missing_left_paren;

/* Set up control string. */

	string (io_bits) = FALSE;
	io_bits.read = statement_type = decode_statement;
	io_bits.fold = subr_options.fold;
	io_bits.ansi_77 = subr_options.ansi_77;
	io_bits.hfp = subr_options.hfp;
	io_bits.debug_io = subr_options.debug_io;

	fields_specified = ZERO;
	sub_ptr -> need_PS = TRUE;			/* Indicate presence of an I/O statement. */

/* Parse the string reference. */

	call get_next_token (force_symtab_entry, SI);
	if token ^= ident then
	     go to missing_identifier;

/*  get_internal_file builds the polish for stmnt.  parameter indicates it is being called from encode/decode */

	call set_data_fields (SI);
	call get_internal_file (TRUE);

/* Process format and err=l fields. */

	if token ^= comma then
	     go to missing_comma;

	call parse_io_options;			/* io_bits.format may change. */
	if io_bits.format = unformatted		/* string io may not be unformatted */
	     then
	     call print_message (31, keyword_table (statement_type), "format");
	call parse_io_list;
	go to parse_done;


/* Case		Print

Syntax:

Polish:

Notes:
*/
parser (45):
	profile_size = profile_size + 1;		/* profile entry required by this statement */
	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;

	call parse_implied_io (FALSE, value_0, TRUE);
	go to parse_done;


/* Case		Entry

Syntax:

Polish:

Notes:
	Not Audited -- not for first release.
*/
parser (46):
	string (cur_stmnt_ptr -> statement.bits) = put_in_map;

/* tell code generator there are multiple entry points */

	sub_ptr -> subprogram.multiple_entry = TRUE;

	if sub_ptr -> subprogram_type = main_program then
	     call print_message (35, keyword_table (statement_type));
						/* entry invalid in main program */

	call get_next_token (force_symtab_entry, SI);
	if token ^= ident then
	     go to missing_identifier;

/* if entry in function, data type must agree with main entry point */

	if subprogram_op = func_op then do;
	     call assign_data_type (return_value);	/* make sure main e.p. has data type, too */
	     call assign_data_type (SI);

	     if (unspec (addr (OS (SI)) -> symbol.mode_bits) ^= unspec (addr (OS (return_value)) -> symbol.mode_bits))
		then
		call print_message (125, SI, subprogram_symbol);
	end;

	call parse_parameter_list (SI);		/* parses param list */

	if pending_entry_cnt = 1 then
	     bypass_first_pending_entry = ^must_have_label;
	must_have_label = FALSE;			/* statement following entry stmt never needs label */

	go to parse_done;


/* Case		Pause, Stop

Syntax:

Polish:

Notes:
*/
parser (47):					/* Stop Statement */
	op_code = stop_op;
	go to stop_pause_common;

parser (48):					/* Pause Statement */
	op_code = pause_op;

stop_pause_common:
	profile_size = profile_size + 1;		/* profile entry required by this statement */
	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;

	if END_DO_RANGE & ^logical_if_statement then
	     call print_message (16, keyword_table (statement_type));
						/* cannot terminate do loop */

	call get_next_token (locate_symtab_entry, indx);

	if token = char_string then do;
	     current_token = current_token + 1;
	end;
	else if token = dec_int then do;
	     indx = create_char_constant (token_string);
	     current_token = current_token + 1;
	end;
	else do;
	     indx = create_char_constant (NULL_STRING);
	end;
	call emit_operand (indx);
	call emit_operator ((op_code));
	go to parse_done;


/* Case		Assign To

Syntax:

Polish:

Notes:
*/
parser (49):
	profile_size = profile_size + 1;		/* profile entry required by this statement */
	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;

	call get_next_token$label (ignore_symtab_entry, ignore_value);
	if token ^= dec_int then
	     go to missing_label;

	call emit_operand (enter_label (any_label, (addr (work) -> based_integer), GOTO_REF));
	call get_next_token (ignore_symtab_entry, ignore_value);
	if token ^= ident then do;
	     call print_message (44, "to", err_string ());/* missing keyword */
	     go to statement_parse_abort;
	end;

	if substr (fast_lookup, 1, 2) ^= "to" then do;
	     call print_message (44, "to", err_string ());/* missing keyword */
	     go to statement_parse_abort;
	end;

	call split_token (2, current_token, TRUE);
	current_token = current_token - 1;		/* Get the token again. */
	call get_next_token (force_symtab_entry, SI);

	call parse_expression (set_reference, SI, ignore_bits);
	call emit_operator (assign_label_op);
	go to parse_done;


/* Case	 	Punch

Syntax:

Polish:

Notes:
*/
parser (50):
	profile_size = profile_size + 1;		/* profile entry required by this statement */
	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;

	if is_fast then
	     go to parser (unknown_statement);

	if value_7 = 0 then do;
	     addr (work) -> based_integer = 7;
	     value_7 = create_constant (int_mode, work);
	end;

	call parse_implied_io (FALSE, value_7, FALSE);
	go to parse_done;


/* Case		Input

Syntax:

Polish:

Notes:
*/
parser (51):
	profile_size = profile_size + 1;		/* profile entry required by this statement */
	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;

	call parse_implied_io (TRUE, value_0, TRUE);
	go to parse_done;


/* Case		Chain */
parser (53):
	profile_size = profile_size + 1;		/* profile entry required by this statement */
	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;

	call get_next_token (force_symtab_entry, SI);

	call parse_expression (any_expression, SI, ignore_bits);

	if token = comma then do;
	     in_stmnt = TRUE;
	     call get_next_token (ignore_symtab_entry, ignore_value);
	     if token ^= ident then
		go to missing_keyword;

	end;
	else
	     in_stmnt = FALSE;

	if in_stmnt & substr (fast_lookup, 1, 6) = "system" then do;
	     call split_token (6, current_token, TRUE);
	     current_token = current_token - 1;		/* Get the token again. */
	     call get_next_token (force_symtab_entry, SI);

	     call parse_expression (any_expression, SI, ignore_bits);

	     if token = comma then do;
		in_stmnt = TRUE;
		call get_next_token (ignore_symtab_entry, ignore_value);
		if token ^= ident then do;
		     call print_message (44, "with", err_string ());
						/* missing keyword */
		     go to statement_parse_abort;
		end;

	     end;
	     else
		in_stmnt = FALSE;
	end;
	else
	     call emit_operand (create_char_constant ("fortran"));

	call emit_count (word_offset);
	call emit_operator (chain_op);

	if in_stmnt then
	     if substr (fast_lookup, 1, 4) = "with" then do;
		call split_token (4, current_token, TRUE);
		current_token = current_token - 1;
		count = 0;
		in_list = TRUE;
		do while (in_list);
		     call get_next_token (force_symtab_entry, SI);
		     call parse_expression (any_expression, SI, ignore_bits);
		     count = count + 1;
		     if token ^= comma then
			in_list = FALSE;

		     call emit_operator (item_op);
		end;
		polish_string (word_offset) = count - bias;
	     end;
	     else
		current_token = current_token - 1;

	call emit_operator (eol_op);
	go to parse_done;


/* Case		Closefile

Syntax:	<expression> <eos>

Polish:	<expression> <closefile_op>

Notes:
	need_PS	indicates presence of an I/O statement
	SI	passes output from get_next_token to parse_expr
*/
parser (54):
	profile_size = profile_size + 1;		/* profile entry required by this statement */
	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;

	call get_next_token (force_symtab_entry, SI);	/* Get first token of the expr. */
	call parse_expression (any_expression, SI, ignore_bits);
	call emit_operator (closefile_op);
	sub_ptr -> need_PS = TRUE;
	go to parse_done;


/* Case		Margin

Syntax:

Polish:

Notes:
*/
parser (55):
	profile_size = profile_size + 1;		/* profile entry required by this statement */
	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;

	call get_next_token (force_symtab_entry, SI);
	call parse_expression (any_expression, SI, ignore_bits);
	if token ^= comma then
	     go to missing_comma;

	call get_next_token (force_symtab_entry, SI);
	call parse_expression (any_expression, SI, ignore_bits);
	call emit_operator (margin_op);
	sub_ptr -> need_PS = TRUE;
	go to parse_done;


/* Case		Openfile

Syntax:

Polish:

Notes:
*/
parser (56):
	profile_size = profile_size + 1;		/* profile entry required by this statement */
	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;

	call get_next_token (force_symtab_entry, SI);
	sub_ptr -> need_PS = TRUE;
	call parse_expression (any_expression, SI, ignore_bits);
	if token ^= comma then
	     go to missing_comma;

	call get_next_token (force_symtab_entry, SI);

	call parse_expression (any_expression, SI, ignore_bits);

	if token = comma then do;
	     call get_next_token (force_symtab_entry, SI);

	     call parse_expression (any_expression, SI, ignore_bits);

	end;
	else
	     call emit_operand (create_char_constant ("terminal"));
	call emit_operator (openfile_op);
	go to parse_done;


/* Case		Open

Syntax:	open ( <option list> )

		where option list is any of these in any order:
		(exactly one unit specifier is required)
	err=, status=, iostat=, attach=, switch=, form=, access=, mode=, prompt=, defer=, carriage=,
	file=, binary=, recl=, [unit =].

Polish:
	file_#  job_bits  fields_specified  #_of_fields  open  field_expre  field_#  item  ...  eol
	 <saved>  opnd	opnd		count	op	expre	count  op		op

Notes:
	THE CORRESPONDENCE BETWEEN FIELD AND NUMBER IS NOT ALTERABLE WITHOUT CHANGING:
		the parse (ext_parse), the macros (fort_cg_macros_), and bound_pl1_operators_.
	     Also, the include file fortran_open_data.incl.(pl1 alm).
*/
parser (57):
	profile_size = profile_size + 1;		/* profile entry required by this statement */
	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;

	sub_ptr -> subprogram.need_PS = TRUE;

/* Initialize */

	string (io_bits) = ZERO;			/* Control word to define type of operation. */
	io_bits.control_type = bit (binary (open_opr, 4, 0), 4);
	io_bits.fold = subr_options.fold;
	io_bits.ansi_77 = subr_options.ansi_77;
	io_bits.hfp = subr_options.hfp;
	io_bits.debug_io = subr_options.debug_io;

	fields_specified = ZERO;			/* Bit string to specify which fields have already appeared. */

	count = 0;				/* counts the number of fields present */

/* Begin the parse */

	call get_next_token$operator;			/* get left paren */
	if token ^= left_parn then
	     go to missing_left_paren;

/* Allocate polish for 0) unit_specifier built by code gen, 1) job_bits, 2) fields_specified, 3) a count */

	word_offset = next_free_polish;		/* remember where */
	call increment_polish (4);
	call emit_operator (open_op);

	in_list = TRUE;
	count = 0;
	do while (in_list);
	     count = count + 1;
	     call get_next_token (ignore_symtab_entry, ignore_value);
						/* get the keyword */
	     if token_list (current_token + 1).type ^= assign then do;
						/* non-keyword, must be implied unit if first */
		if count = 1 then
		     call parse_unit_specifier$no_keyword (FALSE, TRUE);
		else
		     goto missing_identifier;
	     end;
	     else do;

		if token ^= ident then
		     go to missing_keyword;

		if substr (full_name, 1, symbol_length) = "err" then
		     call parse_error_label;

		else if substr (full_name, 1, symbol_length) = "iostat" then
		     call parse_iostat_var;

		else if substr (full_name, 1, symbol_length) = "status" then
		     call parse_open_field (status_field, any_expression);

		else if substr (full_name, 1, symbol_length) = "ioswitch" then
		     call parse_open_field (io_switch_field, any_expression);

		else if substr (full_name, 1, symbol_length) = "attach" then
		     call parse_open_field (attach_desc_field, any_expression);

		else if substr (full_name, 1, symbol_length) = "file" then
		     call parse_open_field (filename_field, any_expression);

		else if substr (full_name, 1, symbol_length) = "mode" then
		     call parse_open_field (mode_field, any_expression);

		else if substr (full_name, 1, symbol_length) = "access" then
		     call parse_open_field (access_field, any_expression);

		else if substr (full_name, 1, symbol_length) = "form" then
		     call parse_open_field (form_field, any_expression);

		else if substr (full_name, 1, symbol_length) = "recl" then
		     call parse_open_field (recl_field, any_expression);

		else if substr (full_name, 1, symbol_length) = "binarystream" then
		     call parse_open_field (binarystream_field, any_expression);

		else if substr (full_name, 1, symbol_length) = "prompt" then
		     call parse_open_field (prompt_field, any_expression);

		else if substr (full_name, 1, symbol_length) = "carriage" then
		     call parse_open_field (carriage_field, any_expression);

		else if substr (full_name, 1, symbol_length) = "defer" then
		     call parse_open_field (defer_field, any_expression);

		else if substr (full_name, 1, symbol_length) = "blank" then
		     call parse_open_field (blank_field, any_expression);

		else if substr (full_name, 1, symbol_length) = "unit" then
		     call parse_unit_specifier (FALSE, TRUE);

		else
		     go to invalid_keyword;
	     end /* keyword driven */;
	     in_list = (token = comma);
	end;					/* loop through option fields */

	if token ^= right_parn then
	     go to missing_right_paren;
	if ^substr (fields_specified, units_field, 1) then
	     call print_message (31, keyword_table (statement_type), "unit");
	current_token = current_token + 1;		/* skip over right paren */

	call emit_operator (eol_op);

/* copy values into polish slots reserved earlier */

	polish_string (word_offset) = -bias;
	polish_string (word_offset + 1) = create_constant (int_mode, string (io_bits));
	polish_string (word_offset + 2) = create_constant (int_mode, fields_specified);
	polish_string (word_offset + 3) = -bias;	/* count of zero. Index for field-specified bit string. */
	go to parse_done;

/* Case		Close

Syntax:	close ( <option list> )

		where option list is any of these in any order:
		(exactly one unit specifier required, keyword optional)
	err=, status=, iostat=, [unit = ],

Polish:
	file_#  job_bits  fields_specified  #_of_fields  close field_expre  field_#  item  ...  eol
	 <save>  opnd	opnd		count	op	expre	count  op		op

Notes:
	THE CORRESPONDENCE BETWEEN FIELD AND NUMBER IS NOT ALTERABLE WITHOUT CHANGING:
		the parse (ext_parse), the macros (fort_cg_macros_), and bound_pl1_operators_.
	     Also, the include file fortran_open_data.incl.(pl1 alm).
*/
parser (58):
	profile_size = profile_size + 1;		/* profile entry required by this statement */
	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;

	sub_ptr -> subprogram.need_PS = TRUE;

/* Initialize */

	string (io_bits) = ZERO;			/* Control word to define type of operation. */
	io_bits.control_type = bit (binary (close_opr, 4, 0), 4);
	io_bits.fold = subr_options.fold;
	io_bits.ansi_77 = subr_options.ansi_77;
	io_bits.hfp = subr_options.hfp;
	io_bits.debug_io = subr_options.debug_io;

	fields_specified = ZERO;			/* Bit string to specify which fields have already appeared. */

	count = 0;				/* counts the number of fields present */

/* Begin the parse */

	call get_next_token$operator;			/* get left paren */
	if token ^= left_parn then
	     go to missing_left_paren;

/* Allocate polish for 0) unit id built by code gen, 1) job_bits, 2) fields_specified, 3) a count */

	word_offset = next_free_polish;		/* remember where */
	call increment_polish (4);
	call emit_operator (close_op);

	in_list = TRUE;
	do while (in_list);
	     count = count + 1;
	     call get_next_token (ignore_symtab_entry, ignore_value);
						/* get the keyword */
	     if token_list (current_token + 1).type ^= assign then do;
						/* non-keyword, must be implied unit if first */
		if count = 1 then
		     call parse_unit_specifier$no_keyword (FALSE, TRUE);
		else
		     goto missing_identifier;
	     end;
	     else do;
		if token ^= ident then
		     go to missing_keyword;

		if substr (full_name, 1, symbol_length) = "err" then
		     call parse_error_label;

		else if substr (full_name, 1, symbol_length) = "iostat" then
		     call parse_iostat_var;

		else if substr (full_name, 1, symbol_length) = "status" then
		     call parse_open_field (status_field, any_expression);

		else if substr (full_name, 1, symbol_length) = "unit" then
		     call parse_unit_specifier (FALSE, TRUE);

		else
		     go to invalid_keyword;
	     end /* keyword driven */;
	     in_list = (token = comma);
	end;					/* loop through option fields */

	if token ^= right_parn then
	     go to missing_right_paren;
	if ^substr (fields_specified, units_field, 1) then
	     call print_message (31, keyword_table (statement_type), "unit");
	current_token = current_token + 1;		/* skip over right paren */

	call emit_operator (eol_op);

/* copy values into polish slots reserved earlier */

	polish_string (word_offset) = -bias;
	polish_string (word_offset + 1) = create_constant (int_mode, string (io_bits));
	polish_string (word_offset + 2) = create_constant (int_mode, fields_specified);
	polish_string (word_offset + 3) = -bias;	/* count of zero. Index for field-specified bit string. */
	go to parse_done;


/* Case		Inquire

Syntax:	inquire ( <option list> )

		where option list is any of these in any order:
		(exactly one of unit or file is required)
	err=, iostat=, file=, form=, blank=, access=, exist=, opened=, number=, named=,
	sequential=, formatted=, recl=, unit =, unformatted=, nextrec=, direct=.

Polish:
	job_bits  fields_specified  #_of_fields  inquire  field_expre  field_#  item  ...  eol

Notes: This is much like the method in which the open statement is implemented, except that 
       here everything is returned by fortran_io_ except unit/file
*/
parser (59):
	profile_size = profile_size + 1;		/* profile entry required by this statement */
	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;

	sub_ptr -> subprogram.need_PS = TRUE;

/* Initialize */

	string (io_bits) = ZERO;			/* Control word to define type of operation. */
	io_bits.control_type = bit (binary (inquire_opr, 4, 0), 4);
	io_bits.fold = subr_options.fold;
	io_bits.ansi_77 = subr_options.ansi_77;
	io_bits.hfp = subr_options.hfp;
	io_bits.debug_io = subr_options.debug_io;

	fields_specified = ZERO;			/* Bit string to specify which fields have already appeared. */

/* Begin the parse */

	call get_next_token$operator;			/* get left paren */
	if token ^= left_parn then
	     go to missing_left_paren;

/* Allocate polish for 0) job_bits, 1) fields_specified, 2) a count */

	word_offset = next_free_polish;		/* remember where */
	call increment_polish (3);
	call emit_operator (inquire_op);

	in_list = TRUE;
	count = 0;
	do while (in_list);
	     count = count + 1;
	     call get_next_token (ignore_symtab_entry, ignore_value);
						/* get the keyword */
	     if token_list (current_token + 1).type = assign then do;

		if token ^= ident then
		     go to missing_keyword;

		if substr (full_name, 1, symbol_length) = "err" then
		     call parse_error_label;

		else if substr (full_name, 1, symbol_length) = "iostat" then
		     call parse_iostat_var;

		else if substr (full_name, 1, symbol_length) = "file" then
		     call parse_open_field (filename_field, any_expression);

		else if substr (full_name, 1, symbol_length) = "unit" then
		     call parse_unit_specifier (FALSE, TRUE);

		else if substr (full_name, 1, symbol_length) = "access" then
		     call parse_open_field (access_field, set_reference);

		else if substr (full_name, 1, symbol_length) = "form" then
		     call parse_open_field (form_field, set_reference);

		else if substr (full_name, 1, symbol_length) = "recl" then
		     call parse_open_field (recl_field, set_reference);

		else if substr (full_name, 1, symbol_length) = "blank" then
		     call parse_open_field (blank_field, set_reference);

		else if substr (full_name, 1, symbol_length) = "exist" then
		     call parse_open_field (exist_field, set_reference);

		else if substr (full_name, 1, symbol_length) = "opened" then
		     call parse_open_field (opened_field, set_reference);

		else if substr (full_name, 1, symbol_length) = "number" then
		     call parse_open_field (number_field, set_reference);

		else if substr (full_name, 1, symbol_length) = "named" then
		     call parse_open_field (named_field, set_reference);

		else if substr (full_name, 1, symbol_length) = "name" then
		     call parse_open_field (name_field, set_reference);

		else if substr (full_name, 1, symbol_length) = "sequential" then
		     call parse_open_field (sequential_field, set_reference);

		else if substr (full_name, 1, symbol_length) = "formatted" then
		     call parse_open_field (formatted_field, set_reference);

		else if substr (full_name, 1, symbol_length) = "unformatted" then
		     call parse_open_field (unformatted_field, set_reference);

		else if substr (full_name, 1, symbol_length) = "nextrec" then
		     call parse_open_field (nextrec_field, set_reference);

		else if substr (full_name, 1, symbol_length) = "direct" then
		     call parse_open_field (direct_field, set_reference);

		else
		     go to invalid_keyword;
	     end /* keyword driven */;
	     else do;				/* presume 'UNIT=' */
		if count = 1 then
		     call parse_unit_specifier$no_keyword (FALSE, TRUE);
		else
		     goto missing_identifier;
	     end;

	     in_list = (token = comma);
	end;					/* loop through option fields */

	if token ^= right_parn then
	     go to missing_right_paren;

	if ^substr (fields_specified, units_field, 1) & ^substr (fields_specified, filename_field, 1) then
	     call print_message (31, keyword_table (statement_type), "unit or a file");
	if substr (fields_specified, units_field, 1) & substr (fields_specified, filename_field, 1) then
	     call print_message (187, keyword_table (statement_type), "file and unit");

	current_token = current_token + 1;		/* skip over right paren */

	call emit_operator (eol_op);

/* copy values into polish slots reserved earlier */

	polish_string (word_offset) = create_constant (int_mode, string (io_bits));
	polish_string (word_offset + 1) = create_constant (int_mode, fields_specified);
	polish_string (word_offset + 2) = -bias;	/* count of zero. Index for field-specified bit string. */
	go to parse_done;

/* Case		Do

Syntax:

Polish:

Notes:
*/
parser (61):
	profile_size = profile_size + 1;		/* profile entry required by this statement */
	string (cur_stmnt_ptr -> statement.bits) = put_in_profile;

	if END_DO_RANGE then
	     call print_message (16, keyword_table (statement_type));
						/* cannot terminate do loop */

	call get_next_token$label (ignore_symtab_entry, ignore_value);
	if token ^= dec_int then
	     go to missing_label;

	label_ptr = enter_label (executable_label, (addr (work) -> based_integer), REF);
	call get_next_token (force_symtab_entry, SI);

	if token = comma then
	     call get_next_token (force_symtab_entry, SI);

	call parse_expression (set_reference, SI, ignore_bits);
	if token ^= assign then
	     go to missing_equals_sign;

	call get_next_token (force_symtab_entry, SI);
	call parse_expression (any_expression, SI, ignore_bits);
	if token ^= comma then
	     go to missing_comma;

	call get_next_token (force_symtab_entry, SI);
	call parse_expression (any_expression, SI, ignore_bits);
	if token = comma then do;
	     call get_next_token (force_symtab_entry, SI);
	     call parse_expression (any_expression, SI, ignore_bits);
	end;
	else
	     call emit_operand (value_1);
	call emit_operator (do_op);

	if do_index = hbound (do_blockif_stack, 1) then
	     call print_message (27, hbound (do_blockif_stack, 1) - bias);
						/* too many do loop nestings */
	else do;
	     do_index = do_index + 1;
	     do_blockif_stack (do_index).do_loop = "1"b;
	     do_blockif_stack (do_index).label_ptr = label_ptr;
	end;
	go to parse_done;


/* Case		Unknown */
parser (62):
	call get_next_token (ignore_symtab_entry, ignore_value);
						/* get first token of statement */

	if token = ident then
	     call print_message (32, token_string);	/* unknown keyword */
	else
	     call print_message (92, token_string);	/* doesnt start with identifier */

	go to statement_parse_abort;


/* Case		Out of Sequence */
parser (63):
	call print_message (56, keyword_table (bad_type));/* statement is out of sequence */
	go to statement_parse_abort;

declaration_processor:
     procedure;

/*	Program Specifications (declaration_processor)

     Inputs

     Output

     Description - Process common blocks and equvalence groups.
*/

dcl      LA_hdri fixed bin (18);
dcl      LA_hdrp ptr;
dcl      VLA_hdri fixed bin (18);
dcl      VLA_hdrp ptr;
dcl      added pointer;
dcl      added_group bit (1);
dcl      added_header_length fixed binary (24);
dcl      adesc fixed binary (18);
dcl      all_character_offsets_in_group bit (1);
dcl      ap pointer;
dcl      array_max_size fixed bin (24);
dcl      block_length fixed bin (25);
dcl      block_max_size fixed bin (24);
dcl      bp pointer;
dcl      (chars_in_block, chars_in_group, character_offset) bit (1);
dcl      common_hdri fixed bin (18);
dcl      common_hdrp ptr;
dcl      difference fixed bin (24);
dcl      displacement fixed bin (24);
dcl      equiv_error bit (1) aligned;
dcl      equiv_hdri fixed bin (18);
dcl      equiv_hdrp ptr;
dcl      group_align bit (2) aligned;
dcl      group_class bit (4) aligned;
dcl      group_length fixed bin (24);
dcl      i fixed bin (18);
dcl      ii fixed bin;
dcl      indx fixed bin (18);
dcl      indx_ptr pointer;
dcl      j fixed bin (18);
dcl      k fixed bin (24);
dcl      max_length_this_pass fixed bin (18);
dcl      new fixed bin (18);
dcl      old fixed bin (18);
dcl      original pointer;
dcl      prev_LA_hdrp ptr;
dcl      prev_common_hdrp ptr;
dcl      prev_equiv_hdrp ptr;
dcl      real_statement fixed bin (18);
dcl      sp pointer;
dcl      sp_header_length fixed binary (24);
dcl      symbol_even bit (1);
dcl      symbol_length fixed bin (24);
dcl      symbol_storage bit (5) unaligned defined (addr (OS (indx)) -> symbol.storage_info);
dcl      symbol_storage_class bit (3);
dcl      symi fixed bin (18);
dcl      tp pointer;
dcl      vbai fixed bin (18);
dcl      vbap ptr;
dcl      vba_name char (256) varying;

dcl      01 initial_in_polish aligned based,		/* Used to transform to named constant */
	 02 next fixed binary (17) aligned,
	 02 limit fixed binary (17) aligned,
	 02 value fixed binary (17) aligned;


	real_statement = cur_statement;		/* cur_statement is changed for error messages. */
	cur_statement = -1;				/* There is no current statement. */

/* force data type for function return value */

	if subprogram_op = func_op then do;

/* Insure that the function return value was set. */

	     if ^addr (OS (return_value)) -> symbol.set & ^addr (OS (return_value)) -> symbol.passed_as_arg then
		call print_message (9, return_value);	/* return value is not set */

	     call set_data_fields (return_value);	/* must have data type */

	     unspec (addr (OS (return_value_param)) -> symbol.mode_bits) =
		unspec (addr (OS (return_value)) -> symbol.mode_bits);
	     addr (OS (return_value_param)) -> symbol.data_type = addr (OS (return_value)) -> symbol.data_type;
	     addr (OS (return_value_param)) -> symbol.element_size = addr (OS (return_value)) -> symbol.element_size;
	end;

/*  *  *  *  *  *  LABEL PROCESSOR  *  *  *  *  *  */

/*	Check all labels for illegal reference. For format labels, if they
	contain hollerith fields and are referenced by a read statement, set symbol.set. */

	do SI = sub_ptr -> subprogram.first_label repeat symp -> label.next_label while (SI ^= 0);
	     symp = addr (OS (SI));

	     if symp -> label.referenced & ^symp -> label.set then
		call print_message (12, SI);

	     if symp -> label.referenced_executable & symp -> label.not_referencable then
		call print_message (185, SI);

	     if string (symp -> label.usage) = format_label then do;
		sp = addr (OS (symp -> label.format_var));

		if sp -> symbol.set			/* used in a read st, check for hollerith */
		then do;
		     addr (work) -> based_char /* copy because char_const.value is not word aligned */ =
			addr (addr (OS (polish_string (sp -> symbol.initial + 2))) -> char_constant.value)
			-> based_char;
		     if ^addr (work) -> runtime_format.contains_hollerith then
			sp -> symbol.set = FALSE;
		end;
	     end;
	end;


/*  *  *  *  *  *  SYMBOL TABLE PROCESSOR  *  *  *  *  *  */

/* The symbol table chain must be destroyed and replaced by two chains, -- a chain for entry point
   symbols and a chain for everything else. Also, while walking the original symbol table chain,
   the following actions are performed:

     o	symbol.general is zeroed; the cg assumes this as its initial value.

     o	symbols with the external attribute that are not builtins and without a storage class
	are assigned to constant storage.

     o	arrays with variable extents must be parameters; the bounds must all be scalar
	integer parameters.

     o	functions, statement functions, and variables are assigned a data type,
	if they don't already have one; symbol.data_type, symbol.element_size,
	(also dimension.element_count, dimension.array_size) are set if
	symbol.data_type is zero. */

	SI = sub_ptr -> subprogram.first_symbol;	/* get head of original symbol table chain */

	sub_ptr -> subprogram.first_symbol = 0;		/* general symbol chain is initially empty */
	sub_ptr -> subprogram.last_symbol = 0;

	do while (SI ^= 0);

/* get pointer to current node */

	     symp = addr (OS (SI));

	     new = symp -> symbol.next_symbol;		/* next member of the original chain */
	     symp -> symbol.next_symbol = 0;		/* destroy original chain */

/* Process each symbol. */

/* entry point symbols are added to the entry point chain */

	     if symp -> symbol.entry_point then do;

/* All function entry points must have a data type. */

		if subprogram_op = func_op then do;
		     unspec (addr (OS (SI)) -> symbol.mode_bits) =
			unspec (addr (OS (return_value)) -> symbol.mode_bits);
		     addr (OS (SI)) -> symbol.data_type = addr (OS (return_value)) -> symbol.data_type;
		     addr (OS (SI)) -> symbol.element_size = addr (OS (return_value)) -> symbol.element_size;
		end;

/* an entry_point needs descriptors iff any of its parameters is declared to
   be of star_extent.  The index of the symbol nodes for these parameters is
   put into an arg_desc node by parse_parameter_list for each entry point, but 
   as the symbols need not have been declared yet, star_extent_edness must be  
   checked on a per-subprogram basis.   */

		adesc = symp -> symbol.general;
		if adesc ^= 0 then do;
		     ap = addr (OS (adesc));
		     num_args = ap -> arg_desc.n_args;
		     if symp -> symbol.function then
			symp -> symbol.needs_descriptors = symp -> symbol.star_extents;
		     do i = 1 to num_args while (^symp -> symbol.needs_descriptors);
			if ap -> arg_desc.symbol (i) > 0
						/* if parameter was a symbol, not a *  */
			     then
			     symp -> symbol.needs_descriptors =
				addr (OS (ap -> arg_desc.symbol (i))) -> symbol.star_extents;
		     end;

		end;

		if first_entry_name = 0 then
		     first_entry_name = SI;
		else
		     addr (OS (last_entry_name)) -> symbol.next_symbol = SI;

		last_entry_name = SI;
	     end;

/* all others are added to symbol table chain */

	     else do;


/* DATA TYPE and STORAGE CLASS ALLOCATION. The parse sets the data type for
   all external functions, statement functions, and variables. It also assigns
   a storage class to all variables that do not have one. */

		if symp -> symbol.function | symp -> symbol.stmnt_func then
		     call set_data_fields (SI);	/* Assign a data type and set related fields. */

		else if symp -> symbol.variable | symp -> symbol.parameter then do;
		     call set_data_fields (SI);	/* Assign a data type and set related fields. */

/* Insure that all non-equivalenced variables have a storage class. */

		     if ^symp -> symbol.equivalenced	/* this symbol is not in common nor equivalenced */
			then
			if string (symp -> symbol.storage_class) = ZERO then do;
			     string (symp -> symbol.storage_class) = string (sub_ptr -> subprogram.default_is);
			     if symp -> symbol.dimensioned & ^symp -> symbol.variable_extents
				& ^symp -> symbol.star_extents then do;
				if symp -> symbol.automatic then
				     array_max_size = max_array_size.auto;
				else if symp -> symbol.static then
				     array_max_size = max_array_size.static;

				if (addr (OS (symp -> symbol.dimension)) -> dimension.array_size)
				     > array_max_size * units_per_word (symp -> symbol.units) then
				     call print_message (136, "size", SI,
					ltrim (char (array_max_size)) || " words");
			     end;
			end;

/* Print warning if variable is used but not set. Parameters, members of
   common and equiv groups, initialed vars, compiler generated symbols,
   and s.f. dummy args are excluded. */

		     if symp -> symbol.referenced then
			if ^symp -> symbol.set & ^symp -> symbol.passed_as_arg then
			     if ^symp -> symbol.parameter & ^symp -> symbol.equivalenced
				& ^symp -> symbol.dummy_arg & ^symp -> symbol.by_compiler
						/* make sure it wasn't compiler generated */
				then
				if symp -> symbol.initial = 0
						/* do this way to catch init to zero */
				     then
				     call print_message (043, SI);

/* If static variable is init'd to zero, is referenced, is not set or passed
   as arg, mark as init'd so that optimizer can make it a constant. */

		     if symp -> symbol.static then
			if ^symp -> symbol.set & ^symp -> symbol.passed_as_arg then
			     if ^symp -> symbol.initialed & symp -> symbol.initial ^= 0 then
				symp -> symbol.initialed = TRUE;

/* Convert a symbol into a named constant if possible. */

		     if (symp -> symbol.static | symp -> symbol.automatic) & symp -> symbol.initial ^= 0
			& ^symp -> symbol.set & ^symp -> symbol.passed_as_arg & ^symp -> symbol.aliasable
			& ^symp -> symbol.dimensioned & ^symp -> symbol.equivalenced then do;
						/* CONVERT FROM OPTMIZER */
			symp -> symbol.automatic, symp -> symbol.static = "0"b;
			symp -> symbol.named_constant = "1"b;
			symp -> symbol.initial =
			     addr (polish_string (symp -> symbol.initial)) -> initial_in_polish.value;
		     end;
		end;

/* default storage class for external references is constant and use word units
   for external (descriptors) character functions in ansi77 */

		if symp -> symbol.external then do;
		     if ^symp -> symbol.parameter & ^symp -> symbol.builtin then
			symp -> symbol.constant = TRUE;
		     if symp -> symbol.function then
			if symp -> symbol.mode.character then
			     if subr_options.ansi_77 then do;
				symp -> symbol.units = word_units;
				symp -> symbol.element_size =
				     divide (symp -> symbol.char_size + chars_per_word, chars_per_word, 17, 0);
			     end;
		end;

/* process variable bounds */

		else if symp -> symbol.variable_extents then do;
		     if ^symp -> symbol.parameter then
			call print_message (14, SI);

		     dp = addr (OS (symp -> symbol.dimension));

/* As we check the validity of the bounds, we will force their allocation. */

		     do i = 1 to dp -> dimension.number_of_dims;
			if dp -> dimension.v_bound.lower (i) then
			     call validate_array_bound (dp -> dimension.dim.lower_bound (i));

/* warning - dont attempt to validate the last upper bound for assumed size arrays */

			if dp -> dimension.v_bound.upper (i) then
			     if ^(i = dp -> dimension.number_of_dims & dp -> dimension.assumed_size) then
				call validate_array_bound (dp -> dimension.dim.upper_bound (i));
		     end;
		end;

/* Statement function definitions are masked if the statement function
   is not referenced. The borrowed fields symbol.initial and symbol.dimension
   are always zeroed. */

		else if symp -> symbol.stmnt_func then do;
		     if ^symp -> symbol.allocate then do;

/* The definition is removed from the polish string by overwriting it
   with an increment_polish_op. The def. is guaranteed to be at least
   three (3) words in length. */

			word_offset = symp -> symbol.initial;
			polish_string (word_offset) = increment_polish_op;
			polish_string (word_offset + 1) = symp -> symbol.dimension - word_offset - 2;

/* All of the s.f. parameters should not be allocated. */

			do indx = symp -> symbol.next_member repeat addr (OS (indx)) -> symbol.next_member
			     while (indx ^= 0);
			     symbol_storage = ZERO;
			end;
		     end;

		     symp -> symbol.initial = 0;
		     symp -> symbol.dimension = 0;
		end;

/* Check to make sure *-length declaration has not been used improperly;
   if used validly, create a symbol to hold length info. */

		if symp -> symbol.star_extents then
		     if ^(sub_ptr -> subprogram_type = function & SI = return_value) then
			if ^symp -> symbol.function & ^symp -> symbol.parameter then do;
			     call print_message (147, SI, default_char_size - bias);
			     symp -> symbol.star_extents = "0"b;
			     symp -> symbol.char_size = default_char_size - 1;
			end;
			else do;
			     if symp -> symbol.v_length = 0 then do;
				symp -> symbol.v_length = build_symbol ((NO_NAME), v_length_attributes, SET);
				addr (OS (symp -> symbol.v_length)) -> symbol.data_type = int_mode;
				addr (OS (symp -> symbol.v_length)) -> symbol.element_size = 1;

				if sub_ptr -> subprogram.star_extent_function & SI = return_value_param
						/* Update return_value symbol with our star extent for length. */
				then do;
				     addr (OS (return_value)) -> symbol.v_length = symp -> symbol.v_length;
				     addr (OS (subprogram_symbol)) -> symbol.v_length = symp -> symbol.v_length;
				     if addr (OS (return_value)) -> symbol.needs_descriptors then
					symp -> symbol.needs_descriptors = "1"b;
				end;
			     end;
			end;

/* Now, add the symbol to the general symbol table chain. */

		if sub_ptr -> subprogram.last_symbol = 0 then
		     sub_ptr -> subprogram.first_symbol = SI;
		else
		     addr (OS (sub_ptr -> subprogram.last_symbol)) -> symbol.next_symbol = SI;

		sub_ptr -> subprogram.last_symbol = SI;
	     end;

/* ensure that this field is zero for the code generator */

	     symp -> symbol.general = 0;

/* exception entrypoints, general point to argument descriptor */
	     if symp -> symbol.attributes.misc_attributes.entry_point then
		symp -> symbol.general = adesc;

/* step to next member of the original chain */

	     SI = new;
	end;


/*  *  *  *  *  *  COMMON BLOCK PROCESSOR  *  *  *  *  *  */

/* Walk common block chain calculating offsets and lengths. */

	do i = sub_ptr -> common_chain repeat bp -> header.next_header while (i ^= 0);
	     bp = addr (OS (i));
	     block_length = 0;			/* accumulates the block length */
	     if sub_ptr -> subprogram.options.ansi_77	/* If any var is char, all must be */
		then
		if addr (OS (bp -> header.first_element)) -> symbol.data_type = char_mode then do;
		     bp -> header.alignment.character = TRUE;
		     bp -> header.units = char_units;
		end;

/* Should the header node be associated with no elements, it has appeared only in a SAVE statement and not a COMMON statement */

	     if bp -> header.first_element = 0 then
		call print_message (186, i);

	     do j = bp -> header.first_element repeat sp -> symbol.next_member while (j ^= 0);
		sp = addr (OS (j));

		if (unspec (addr (OS (j)) -> symbol.attributes) & variable_conflicts) = ZERO then do;
						/* Enforce the ANSI77 character vars in common restriction (all or none) */

		     if sub_ptr -> subprogram.options.ansi_77 then
			if bp -> header.alignment.character then
			     if sp -> symbol.data_type ^= char_mode then
				call print_message (156, i);
			     else
				;
			else if sp -> symbol.data_type = char_mode then
			     call print_message (156, i);

/* Set member offset and update total block length. */

		     if sp -> symbol.double_precision | sp -> symbol.complex then
			if mod (block_length, 2) ^= 0 then do;
			     call print_message (57, i, j);
						/* Adding word to common for alignment */
			     block_length = block_length + 1;
			end;

		     sp -> symbol.offset = block_length;/* Set offset. */

		     if sp -> symbol.dimensioned then
			if sp -> symbol.variable_extents then do;
			     call print_message (58, j);
						/* cannot have variable extents in common */
			     k = 0;
			end;
			else
			     k = addr (OS (sp -> symbol.dimension)) -> dimension.array_size;
		     else
			k = sp -> symbol.element_size;

		     block_length = block_length + k;	/* Update length. */
		end;

		else
		     call print_message (20, j, i);	/* symbol cannot be in common */

/* copy block length into header */

		if block_length > max_fixed_bin_24 then
		     call print_message (136, "length", i, ltrim (char (max_fixed_bin_24)) || " words");
		else
		     bp -> header.length = block_length;
	     end;
	end;


/*  *  *  *  *  *  EQUIVALENCE GROUP PROCESSOR  *  *  *  *  *  */

/* Loop thru all equivalence groups. */

	i = lbound (stack, 1);
	do while (i < stack_index);

/* Get the beginning of a group. */

	     cur_statement = stack (i);
	     i = i + 1;

	     if subr_options.ansi_77 then do;
		all_character_offsets_in_group = TRUE;
		ii = i;
		do while (stack (ii) ^= -1 & all_character_offsets_in_group);
		     all_character_offsets_in_group = addr (OS (stack (ii))) -> symbol.mode.character;
		     ii = ii + 3;
		end;
	     end;
	     else
		all_character_offsets_in_group = FALSE;

	     equiv_error = TRUE;
	     do while (equiv_error & stack (i) ^= -1);
		displacement = get_equiv_var (old, bp, character_offset);
	     end;

/* Allow ansi77 characters to be equivalenced to other data types. */

	     displacement = verify_offset_type_kludge (displacement, character_offset);
						/* Loop thru remaining group members. */

	     do while (stack (i) ^= -1);

/* Get next member and difference between its offset and the group offset. */

		equiv_error = TRUE;
		do while (equiv_error & stack (i) ^= -1);
		     difference = get_equiv_var (new, sp, character_offset);
		end;

		if equiv_error then
		     go to equivalence_member_abort;

/* Allow ansi77 characters to be equivalenced to other data types. */

		difference = displacement - verify_offset_type_kludge (difference, character_offset);

/* Calculate new storage class for group. */

		group_class = string (bp -> header.storage_class) | string (sp -> header.storage_class);
		if impossible_class (binary (substr (group_class, 1, 3), 3, 0)) then do;
		     call print_message (59, indx);	/* conflicting storage classes */
		     go to equivalence_member_abort;
		end;

/* Process offset and alignment. */

		if old = new then
		     if difference ^= 0		/* If group is equivalenced to itself. */
		     then do;
			call print_message (60, indx);/* conflicting offset */
			go to equivalence_member_abort;
		     end;
		     else
			;
		else do;				/* Two different groups. */

/* OPTIMIZATION. If either group is in common, insure it is pointed to by "old".
   Both groups cannot be in common. */

		     if sp -> header.in_common then do;
			displacement = displacement - difference;
			difference = -difference;
			j = old;
			old = new;
			new = j;
			tp = bp;
			bp = sp;
			sp = tp;
		     end;

/* Handle special constraints raised by common. a) the origin of common may not
   be changed; b) two common blocks may not be equivalenced. */

		     if bp -> header.in_common then
			if difference < 0 then do;
			     call print_message (61, old);
						/* attempt to change address of common block */
			     go to equivalence_member_abort;
			end;
			else if sp -> header.in_common then do;
			     call print_message (62, indx, old);
						/* equivalencing two common blocks */
			     go to equivalence_member_abort;
			end;

/* If "difference" is non-zero, offsets in one group must be increased by abs(difference). */

		     if difference ^= 0 then do;
			if difference < 0 then do;	/* Old group is fiddled. This redefines its origin. */
			     difference = -difference;
			     added = bp;
			     original = sp;
			     displacement = displacement + difference;
						/* Fiddling is permanent. */
			end;
			else do;			/* New group is fiddled. */
			     added = sp;
			     original = bp;
			end;

/* Change all offsets in appropriate group. */

			do j = added -> header.first_element repeat tp -> symbol.next_member while (j ^= 0);
			     tp = addr (OS (j));
			     block_length = tp -> symbol.offset + difference;
			     if block_length <= max_fixed_bin_24 then do;
				if character_offset & tp -> symbol.mode.character
				     & ^all_character_offsets_in_group then
				     tp -> symbol.offset = block_length * 4;
				else
				     tp -> symbol.offset = block_length;
			     end;
			end;

/* Update length to include origin shift. */

			if bp -> header.units ^= added -> header.units then
			     if bp -> header.units = char_units then
				added_header_length = (added -> header.length + difference) * 4;
			     else
				added_header_length = (added -> header.length + difference) / 4;
			else
			     added_header_length = added -> header.length + difference;
			block_length = max (bp -> header.length, added_header_length);
			if block_length > max_fixed_bin_24 then
			     call print_message (136, "length", old, ltrim (char (max_fixed_bin_24)));
			else
			     bp -> header.length = block_length;
		     end;

		     else do;
			added = sp;
			original = bp;
		     end;

/* Calculate required group alignment: even word, odd word, or any word. */


		     group_align = string (added -> header.alignment);
		     if mod (difference, 2) ^= 0 & group_align ^= ZERO then
			group_align = ^group_align;
		     group_align = group_align | string (original -> header.alignment);
		     if group_align = impossible_align then do;
			call print_message (63, indx);/* conflicting alignment */
			go to equivalence_member_abort;
		     end;

/* Update member's storage class if it has changed. */

		     if substr (group_class, 1, 3) ^= string (bp -> header.storage_class) then
			do j = bp -> header.first_element repeat tp -> symbol.next_member while (j ^= 0);
			     tp = addr (OS (j));
			     string (tp -> symbol.storage_class) =
				string (tp -> symbol.storage_class) | group_class;
			end;

/* Update length if new group is longer than the old. */

		     if bp -> header.units ^= sp -> header.units then
			if bp -> header.units = char_units then
			     sp_header_length = 4 * sp -> header.length;
			else
			     sp_header_length = sp -> header.length / 4;
		     else
			sp_header_length = sp -> header.length;
		     bp -> header.length = max (bp -> header.length, sp_header_length);
						/* cannot overflow */

/* Thread the two group chains into one big one. */

		     addr (OS (bp -> header.last_element)) -> symbol.next_member = sp -> header.first_element;
		     bp -> header.last_element = sp -> header.last_element;

/* Change symbol.parent and storage class for all members of added group. */

		     do j = sp -> header.first_element repeat tp -> symbol.next_member while (j ^= 0);
			tp = addr (OS (j));
			tp -> symbol.parent = old;
			string (tp -> symbol.storage_class) = string (tp -> symbol.storage_class) | group_class;
		     end;

/* allocation information of both groups must be combined */

		     string (bp -> header.storage_info) =
			string (bp -> header.storage_info) | string (sp -> header.storage_info);

/* Added group can be eliminated from general equivalence chain. */

		     if sub_ptr -> equiv_chain = new then
			sub_ptr -> equiv_chain = sp -> header.next_header;
		     else do;
			do j = sub_ptr -> equiv_chain repeat addr (OS (j)) -> header.next_header
			     while (addr (OS (j)) -> header.next_header ^= new);
			end;
			addr (OS (j)) -> header.next_header = sp -> header.next_header;
		     end;

/* Added group header can be released if it is at the end of our area. */

		     allocate_symbol_name = sp -> header.name_length;
		     if new + size (header) = next_free_operand then
			next_free_operand = new;

/* Update group storage class and required alignment. */

		     string (bp -> header.alignment) = group_align;
		     string (bp -> header.storage_class) = group_class;
		end;

equivalence_member_abort:
	     end;					/* element loop. */
	     i = i + 1;

	     if all_character_offsets_in_group then
		bp -> header.alignment.character = TRUE;

	end;					/* equiv group. */

	stack_index = lbound (stack, 1);
	stack_base = lbound (stack, 1);

	cur_statement = real_statement;


/*  *  *  *  *  *   COMMON BLOCK & EQUIVALENCE GROUP POST-PROCESSOR  *  *  *  *  *  */

/*  Check the length of each common block.  Permanent common blocks may not  */
/*  exceed a segment in size.  Normal common blocks that contain character   */
/*  variables may not exceed 'max_array_size.char' in size.  Normal common   */
/*  blocks which do not contain character variables are limited in size to   */
/*  'max_array_size.common'.                                                 */

	do common_hdri = sub_ptr -> subprogram.common_chain repeat common_hdrp -> header.next_header
	     while (common_hdri ^= 0);
	     common_hdrp = addr (OS (common_hdri));
	     if index (common_hdrp -> header.block_name, "$") > 0 then
		block_max_size = sys_info$max_seg_size;
	     else do;
		chars_in_block = FALSE;
		do symi = common_hdrp -> header.first_element repeat symp -> symbol.next_member
		     while (symi ^= 0 & ^chars_in_block);
		     symp = addr (OS (symi));
		     if symp -> symbol.character then
			chars_in_block = TRUE;
		end;
		if chars_in_block then
		     block_max_size = max_array_size.char;
		else
		     block_max_size = max_array_size.common;
	     end;
	     if common_hdrp -> header.length > block_max_size * units_per_word (common_hdrp -> header.units) then
		call print_message (136, "size", common_hdri, ltrim (char (block_max_size)) || " words");
	end;

/*  Check the size of each equivalence group and insure it has been assigned */
/*  a storage class.  Equivalence groups which contain character variables   */
/*  may not exceed 'max_array_size.char' in size, while those that do not    */
/*  contain character variables are limited by 'max_array_size.auto',        */
/*  'max_array_size.common', or 'max_array_size.static'.                     */

	do equiv_hdri = sub_ptr -> subprogram.equiv_chain repeat equiv_hdrp -> header.next_header
	     while (equiv_hdri ^= 0);
	     equiv_hdrp = addr (OS (equiv_hdri));
	     if string (equiv_hdrp -> header.storage_class) = ZERO then
		string (equiv_hdrp -> header.storage_class) = string (sub_ptr -> subprogram.default_is);
	     chars_in_group = FALSE;
	     do symi = equiv_hdrp -> header.first_element repeat symp -> symbol.next_member
		while (symi ^= 0 & ^chars_in_group);
		symp = addr (OS (symi));
		if symp -> symbol.character then
		     chars_in_group = TRUE;
	     end;

	     if chars_in_group then
		block_max_size = max_array_size.char;
	     else if equiv_hdrp -> header.in_common then
		block_max_size = max_array_size.common;
	     else if equiv_hdrp -> header.automatic then
		block_max_size = max_array_size.auto;
	     else
		block_max_size = max_array_size.static; /* if equiv_hdrp -> header.static */

	     if equiv_hdrp -> header.length > block_max_size * units_per_word (equiv_hdrp -> header.units) then
		call print_message (136, "size of the equivalence group",
		     bin (equiv_hdrp -> header.first_element, 18), ltrim (char (block_max_size)) || " words");
	end;

/*  *  *  *  *  *  VERY LARGE ARRAY PROCESSOR  *  *  *  *  *  */

/*  Begin VLA processing.  */

/*  Move common blocks that exceed a segment in size from the common block   */
/*  chain to the VLA chain.                                                  */
	if subr_options.VLC | subr_options.VLA_auto | subr_options.VLA_static | subr_options.VLA_parm then do;

	     if subr_options.VLC then do;
		prev_common_hdrp = null;
		common_hdri = sub_ptr -> subprogram.common_chain;
		do while (common_hdri ^= 0);
		     common_hdrp = addr (OS (common_hdri));
		     block_length =
			divide (common_hdrp -> header.length + units_per_word (common_hdrp -> header.units) - 1,
			units_per_word (common_hdrp -> header.units), 24);
		     if block_length > sys_info$max_seg_size then do;
						/*  Move block to VLA chain.  */
			if prev_common_hdrp = null then
			     sub_ptr -> subprogram.common_chain = common_hdrp -> header.next_header;
			else
			     prev_common_hdrp -> header.next_header = common_hdrp -> header.next_header;
			common_hdrp -> header.next_header = sub_ptr -> subprogram.VLA_chain;
			sub_ptr -> subprogram.VLA_chain = common_hdri;
			common_hdrp -> header.VLA = TRUE;
			do symi = common_hdrp -> header.first_element repeat symp -> symbol.next_member
			     while (symi ^= 0);
			     symp = addr (OS (symi));
			     symp -> symbol.VLA = TRUE;
			end;
		     end;
		     else
			prev_common_hdrp = common_hdrp;
						/*  Leave block on common chain.  */
		     if prev_common_hdrp = null then
			common_hdri = sub_ptr -> subprogram.common_chain;
		     else
			common_hdri = prev_common_hdrp -> header.next_header;
		end;
	     end;

/*  Move equivalence groups that exceed a segment in size from the           */
/*  equivalence chain to the VLA chain.                                      */
	     if subr_options.VLC | subr_options.VLA_auto | subr_options.VLA_static then do;
		prev_equiv_hdrp = null;
		equiv_hdri = sub_ptr -> subprogram.equiv_chain;
		do while (equiv_hdri ^= 0);
		     equiv_hdrp = addr (OS (equiv_hdri));
		     if ((subr_options.VLC & equiv_hdrp -> header.in_common)
			| (subr_options.VLA_auto & equiv_hdrp -> header.automatic)
			| (subr_options.VLA_static & equiv_hdrp -> header.static)) then do;
			block_length =
			     divide (equiv_hdrp -> header.length + units_per_word (equiv_hdrp -> header.units) - 1,
			     units_per_word (equiv_hdrp -> header.units), 24);
			if block_length > sys_info$max_seg_size then do;
						/*  Move group to VLA chain.  */
			     if prev_equiv_hdrp = null then
				sub_ptr -> subprogram.equiv_chain = equiv_hdrp -> header.next_header;
			     else
				prev_equiv_hdrp -> header.next_header = equiv_hdrp -> header.next_header;
			     equiv_hdrp -> header.next_header = sub_ptr -> subprogram.VLA_chain;
			     sub_ptr -> subprogram.VLA_chain = equiv_hdri;
			     equiv_hdrp -> header.VLA = TRUE;
			     do symi = equiv_hdrp -> header.first_element repeat symp -> symbol.next_member
				while (symi ^= 0);
				symp = addr (OS (symi));
				symp -> symbol.VLA = TRUE;
			     end;
			end;
			else
			     prev_equiv_hdrp = equiv_hdrp;
						/*  Leave group on equiv chain.  */
		     end;
		     else
			prev_equiv_hdrp = equiv_hdrp; /*  Leave group on equiv chain.  */
		     if prev_equiv_hdrp = null then
			equiv_hdri = sub_ptr -> subprogram.equiv_chain;
		     else
			equiv_hdri = prev_equiv_hdrp -> header.next_header;
		end;
	     end;

/*  Set the VLA flag and allocate a base addressor for each dimensioned,     */
/*  noncharacter parameter.  Add to the VLA chain all dimensioned, nonchar,  */
/*  parentless (i.e. not equivalenced nor common) variables whose size       */
/*  exceeds that of a segment.                                               */

	     if subr_options.VLA_auto | subr_options.VLA_static | subr_options.VLA_parm then do;
		symi = sub_ptr -> subprogram.first_symbol;
		do while (symi ^= 0);
		     symp = addr (OS (symi));
		     if symp -> symbol.dimensioned & ^symp -> symbol.character then
			if subr_options.VLA_parm & symp -> symbol.parameter then do;
			     symp -> symbol.VLA = TRUE;
			     vba_name = symp -> symbol.name;
			     vbai = build_symbol (vba_name, variable_attributes | attr_table (int_mode), SET);
			     vbap = addr (OS (vbai));
			     vbap -> symbol.data_type = int_mode;
			     vbap -> symbol.automatic = TRUE;
			     vbap -> symbol.element_size = 1;
			     addr (OS (symp -> symbol.dimension)) -> dimension.VLA_base_addressor = vbai;
			end;
			else if ((subr_options.VLA_auto & symp -> symbol.automatic)
			     | (subr_options.VLA_static & symp -> symbol.static)) then do;
			     if divide (addr (OS (symp -> symbol.dimension)) -> dimension.array_size
				+ units_per_word (symp -> symbol.units) - 1,
				units_per_word (symp -> symbol.units), 24) > sys_info$max_seg_size
				& symp -> symbol.parent = 0 then do;
						/*  Add symbol to VLA chain.  */
				allocate_symbol_name = 0;
				VLA_hdri = create_node (header_node, size (header));
				VLA_hdrp = addr (OS (VLA_hdri));
				VLA_hdrp -> header.next_header = sub_ptr -> subprogram.VLA_chain;
				sub_ptr -> subprogram.VLA_chain = VLA_hdri;
				string (VLA_hdrp -> header.storage_info) = string (symp -> symbol.storage_info);
				if symp -> symbol.double_precision | symp -> symbol.complex then
				     VLA_hdrp -> header.even = TRUE;
				else if symp -> symbol.character & subr_options.ansi_77 then
				     VLA_hdrp -> header.character = TRUE;
				string (VLA_hdrp -> header.storage_class) =
				     substr (string (symp -> symbol.storage_class), 1, 3);
				VLA_hdrp -> header.units = symp -> symbol.units;
				VLA_hdrp -> header.VLA = TRUE;
				VLA_hdrp -> header.length =
				     addr (OS (symp -> symbol.dimension)) -> dimension.array_size;
				VLA_hdrp -> header.first_element, VLA_hdrp -> header.last_element = symi;
				symp -> symbol.VLA = TRUE;
				symp -> symbol.parent = VLA_hdri;
			     end;
			end;
		     symi = symp -> symbol.next_symbol;
		end;
	     end;

/*  For each VLA group, create an integer variable to hold the base address  */
/*  of the group.  If the group has a name, that name is also given to the   */
/*  integer variable; otherwise, the name of the first variable in the group */
/*  which has an offset of zero is given to the integer variable.            */

	     do VLA_hdri = sub_ptr -> subprogram.VLA_chain repeat VLA_hdrp -> header.next_header while (VLA_hdri ^= 0);
		VLA_hdrp = addr (OS (VLA_hdri));
		if VLA_hdrp -> header.block_name = "" then
		     vba_name = NO_NAME;
		else
		     vba_name = VLA_hdrp -> header.block_name;
		do symi = VLA_hdrp -> header.first_element repeat symp -> symbol.next_member
		     while (vba_name = NO_NAME & symi ^= 0);
		     symp = addr (OS (symi));
		     if symp -> symbol.offset = 0 then
			vba_name = symp -> symbol.name;
		end;
		vbai = build_symbol (vba_name, variable_attributes | attr_table (int_mode), SET);
		vbap = addr (OS (vbai));
		vbap -> symbol.data_type = int_mode;
		if VLA_hdrp -> header.automatic then
		     vbap -> symbol.automatic = TRUE;
		else
		     vbap -> symbol.static = TRUE;
		vbap -> symbol.element_size = 1;
		VLA_hdrp -> header.VLA_base_addressor = vbai;
		do symi = VLA_hdrp -> header.first_element repeat symp -> symbol.next_member while (symi ^= 0);
		     symp = addr (OS (symi));
		     if symp -> symbol.dimensioned then
			addr (OS (symp -> symbol.dimension)) -> dimension.VLA_base_addressor = vbai;
		end;
	     end;

	end;					/*  End VLA processing.  */

/*  *  *  *  *  *  LARGE ARRAY PROCESSOR  *  *  *  *  *  */

	if subr_options.LA_auto | subr_options.LA_static then do;
						/*  Begin LA processing.  */

/*  We must add all the array variables that are not parameters, nor VLA's   */
/*  nor in common to the Large Array chain.  We must also add long scalar    */
/*  character variables (i.e. longer than 'max_char_length') which are       */
/*  not parameters nor in common.  Each member of the Large Array chain looks*/
/*  like an equivalence group whose total storage does not exceed a segment. */
/*  Array variables are assigned to the Large Array chain in such a way that */
/*  a variable that does not exceed 16K in size will be totally contained in */
/*  the first 16K of the group in which it is entered.  (This allows us to   */
/*  generate more efficient code, since extra instructions are generated to  */
/*  access data outside the first 16K of a storage area.)                    */
/*                                                                           */
/*  There are two sources of arrays for the Large Array chain: parentless,   */
/*  dimensioned nonparameter symbols and the equivalence chain.  We pass     */
/*  through each of these sources twice.  The first time we pick out all     */
/*  arrays less than or equal to 16K in size.  The second time we pick up    */
/*  the rest.                                                                */

	     do max_length_this_pass = 16384, sys_info$max_seg_size;

/*  Run through the symbol table looking for parentless, nonparameter arrays */
/*  and long, parentless, nonparameter character scalars.  Add those whose   */
/*  size does not exceed 'max_length_this_pass' to a group in the LA chain,  */
/*  creating a new group if necessary.                                       */

		do symi = sub_ptr -> subprogram.first_symbol repeat symp -> symbol.next_symbol while (symi ^= 0);
		     symp = addr (OS (symi));
		     if ^symp -> symbol.parameter & symp -> symbol.parent = 0
			& (symp -> symbol.dimensioned
			| (symp -> symbol.character & symp -> symbol.char_size >= max_char_length)) then do;
			if ((subr_options.LA_auto & symp -> symbol.automatic)
			     | (subr_options.LA_static & symp -> symbol.static)) then do;
			     if symp -> symbol.dimensioned then
				symbol_length =
				     divide (addr (OS (symp -> symbol.dimension)) -> dimension.array_size
				     + units_per_word (symp -> symbol.units) - 1,
				     units_per_word (symp -> symbol.units), 18);
			     else
				symbol_length =
				     divide (symp -> symbol.char_size + chars_per_word - 1, chars_per_word, 18);
			     if symbol_length <= max_length_this_pass then do;
						/*  Add symbol to an LA group.  */
				symbol_even = symp -> symbol.double_precision | symp -> symbol.complex;
				symbol_storage_class = substr (string (symp -> symbol.storage_class), 1, 3);
				if symbol_storage_class = ""b then
				     symbol_storage_class = string (sub_ptr -> subprogram.default_is);
				prev_LA_hdrp = null;
				do LA_hdri = sub_ptr -> subprogram.LA_chain
				     repeat LA_hdrp -> header.next_header
				     while (symp -> symbol.parent = 0 & LA_hdri ^= 0);
				     LA_hdrp = addr (OS (LA_hdri));
				     block_length = LA_hdrp -> header.length;
				     if symbol_even then
					block_length = block_length + mod (block_length, 2);
				     if string (LA_hdrp -> header.storage_class) = symbol_storage_class
					& block_length + symbol_length <= max_length_this_pass then do;
						/*  Add symbol to end of this LA group.  */
					addr (OS (LA_hdrp -> header.last_element)) -> symbol.next_member = symi;
					string (LA_hdrp -> header.storage_info) =
					     string (LA_hdrp -> storage_info)
					     | string (symp -> symbol.storage_info);
					LA_hdrp -> header.last_element = symi;
					LA_hdrp -> header.length = block_length + symbol_length;
					symp -> symbol.LA = TRUE;
					symp -> symbol.parent = LA_hdri;
					symp -> symbol.offset =
					     units_per_word (symp -> symbol.units) * block_length;
				     end;
				     prev_LA_hdrp = LA_hdrp;
				end;
				if symp -> symbol.parent = 0 then do;
						/*  Create a new group for this array.  */
				     allocate_symbol_name = 0;
				     LA_hdri = create_node (header_node, size (header));
				     if prev_LA_hdrp = null then
					sub_ptr -> subprogram.LA_chain = LA_hdri;
				     else
					prev_LA_hdrp -> header.next_header = LA_hdri;
				     LA_hdrp = addr (OS (LA_hdri));
				     string (LA_hdrp -> header.storage_info) =
					string (symp -> symbol.storage_info);
				     LA_hdrp -> header.even = TRUE;
				     string (LA_hdrp -> header.storage_class) = symbol_storage_class;
				     LA_hdrp -> header.LA = TRUE;
				     LA_hdrp -> header.length = symbol_length;
				     LA_hdrp -> header.first_element, LA_hdrp -> header.last_element = symi;
				     symp -> symbol.LA = TRUE;
				     symp -> symbol.parent = LA_hdri;
				end;
			     end;
			end;
		     end;
		end;

/*  Run through the equivalence chain looking for groups whose size is more  */
/*  than that required for one element of the dominant type in the group but */
/*  not exceeding 'max_length_this_pass' and move them to a group in the LA  */
/*  chain, creating a new group if necessary.                                */

		prev_equiv_hdrp = null;
		equiv_hdri = sub_ptr -> subprogram.equiv_chain;
		do while (equiv_hdri ^= 0);
		     equiv_hdrp = addr (OS (equiv_hdri));
		     if ((subr_options.LA_auto & equiv_hdrp -> header.automatic)
			| (subr_options.LA_static & equiv_hdrp -> header.static)) then do;
			group_length =
			     divide (equiv_hdrp -> header.length + units_per_word (equiv_hdrp -> header.units) - 1,
			     units_per_word (equiv_hdrp -> header.units), 18);
			if group_length > bin (equiv_hdrp -> header.even) + 1 & group_length <= max_length_this_pass
			then do;			/*  Move this equivalence group to the LA chain.  */
			     if prev_equiv_hdrp = null then
				sub_ptr -> subprogram.equiv_chain = equiv_hdrp -> header.next_header;
			     else
				prev_equiv_hdrp -> header.next_header = equiv_hdrp -> header.next_header;
			     prev_LA_hdrp = null;
			     added_group = FALSE;
			     do LA_hdri = sub_ptr -> subprogram.LA_chain repeat LA_hdrp -> header.next_header
				while (^added_group & LA_hdri ^= 0);
				LA_hdrp = addr (OS (LA_hdri));
				block_length = LA_hdrp -> header.length;
				if equiv_hdrp -> header.even then
				     block_length = block_length + mod (block_length, 2);
				if string (LA_hdrp -> header.storage_class)
				     = string (equiv_hdrp -> header.storage_class)
				     & block_length + group_length <= max_length_this_pass then do;
						/*  Move equiv group to end of this LA group.  */
				     addr (OS (LA_hdrp -> header.last_element)) -> symbol.next_member =
					equiv_hdrp -> header.first_element;
				     string (LA_hdrp -> header.storage_info) =
					string (LA_hdrp -> storage_info)
					| string (equiv_hdrp -> header.storage_info);
				     LA_hdrp -> header.last_element = equiv_hdrp -> header.last_element;
				     LA_hdrp -> header.length = block_length + group_length;
				     do symi = equiv_hdrp -> header.first_element
					repeat symp -> symbol.next_member while (symi ^= 0);
					symp = addr (OS (symi));
					symp -> symbol.LA = TRUE;
					symp -> symbol.parent = LA_hdri;
					symp -> symbol.offset =
					     symp -> symbol.offset
					     + units_per_word (symp -> symbol.units) * block_length;
				     end;
				     allocate_symbol_name = equiv_hdrp -> header.name_length;
				     if equiv_hdri + size (header) = next_free_operand then
					next_free_operand = equiv_hdri;
						/*  Storage can be reused.  */
				     added_group = TRUE;
				end;
				prev_LA_hdrp = LA_hdrp;
			     end;
			     if ^added_group then do; /*  Create a new LA group from the equiv group.  */
				if prev_LA_hdrp = null then
				     sub_ptr -> subprogram.LA_chain = equiv_hdri;
				else
				     prev_LA_hdrp -> header.next_header = equiv_hdri;
				equiv_hdrp -> header.next_header = 0;
				equiv_hdrp -> header.LA = TRUE;
				equiv_hdrp -> header.units = word_units;
				equiv_hdrp -> header.length = group_length;
				do symi = equiv_hdrp -> header.first_element
				     repeat symp -> symbol.next_member while (symi ^= 0);
				     symp = addr (OS (symi));
				     symp -> symbol.LA = TRUE;
				end;
			     end;
			end;
			else
			     prev_equiv_hdrp = equiv_hdrp;
						/*  Leave group on equiv chain.  */
		     end;
		     else
			prev_equiv_hdrp = equiv_hdrp; /*  Leave group on equiv chain.  */
		     if prev_equiv_hdrp = null then
			equiv_hdri = sub_ptr -> subprogram.equiv_chain;
		     else
			equiv_hdri = prev_equiv_hdrp -> header.next_header;
		end;
	     end;
	end /*  End of LA processing.  */;

	return;


get_equiv_var:
     procedure (hdr, hdr_ptr, char_offset) returns (fixed bin (24));

dcl      hdr fixed bin (18);
dcl      hdr_ptr pointer;
dcl      char_offset bit (1);
dcl      offset fixed bin (24);
dcl      length fixed bin (24);

	indx = stack (i);
	indx_ptr = addr (OS (indx));
	i = i + 1;

/* set character_offset to see if ansi77 equiv group rules hold, tested later
   in the routine 'verify_offset_type_kludge' */

	char_offset = indx_ptr -> symbol.mode.character & subr_options.ansi_77;

	if (unspec (addr (OS (indx)) -> symbol.attributes) & equiv_conflicts) | addr (OS (indx)) -> symbol.by_compiler
	then do;
	     call print_message (64, indx);		/* cannot be equivalenced */
	     i = i + 1;
	     return (0);
	end;

	offset = stack (i) * indx_ptr -> symbol.element_size + stack (i + 1);
	i = i + 2;

	if offset > max_fixed_bin_24 then do;
	     call print_message (136, "length", indx, ltrim (char (max_fixed_bin_24)));
						/* implementation restriction */
	     return (0);
	end;

	if indx_ptr -> symbol.equivalenced & indx_ptr -> symbol.parent > 0 then do;
	     hdr = indx_ptr -> symbol.parent;
	     hdr_ptr = addr (OS (hdr));

	     offset = offset + indx_ptr -> symbol.offset;
	     if char_offset then
		hdr_ptr -> header.units = char_units;
	end;
	else do;
	     if indx_ptr -> symbol.dimensioned then do;
		length = addr (OS (indx_ptr -> symbol.dimension)) -> dimension.array_size;
		if length = 0 then do;
		     call print_message (65, indx);	/* cannot be equivalenced */
		     return (0);
		end;
	     end;
	     else
		length = indx_ptr -> symbol.element_size;

	     allocate_symbol_name = 0;		/* no name for equivalence group */
	     hdr = create_node (header_node, size (header));
	     hdr_ptr = addr (OS (hdr));

	     string (hdr_ptr -> header.storage_class) = substr (string (indx_ptr -> symbol.storage_class), 1, 3);
	     string (hdr_ptr -> header.storage_info) = string (indx_ptr -> symbol.storage_info);
	     hdr_ptr -> header.next_header = sub_ptr -> equiv_chain;
	     sub_ptr -> equiv_chain = hdr;
	     hdr_ptr -> header.first_element, hdr_ptr -> header.last_element = indx;
	     hdr_ptr -> header.length = length;
	     if char_offset then
		hdr_ptr -> header.units = char_units;

	     if indx_ptr -> symbol.double_precision | indx_ptr -> symbol.complex then
		hdr_ptr -> header.even = TRUE;

	     indx_ptr -> symbol.parent = hdr;
	     indx_ptr -> symbol.equivalenced = TRUE;
	end;

	equiv_error = FALSE;

	return (offset);
     end get_equiv_var;

verify_offset_type_kludge:
     proc (offset, char_type_offset) returns (fixed bin (24));

/* This routine allows ansi77 character variables to be equivalenced to other
   data types.  This is strickly AGAINST the standard.  We allow it for people
   who wish to use strange and dangerous programming practices.

   The code just checks to see if the offset is of type character and then
   whether the offset is actually supposed to be in words.  If so, it is
   converted.  */

dcl      char_type_offset bit (1);
dcl      offset fixed bin (24);
dcl      new_offset fixed bin (24);

	new_offset = offset;

	if char_type_offset then
	     if ^all_character_offsets_in_group then do;
		if stack (i + 2) > 0 then
		     return (new_offset);

		if mod (new_offset, 4) ^= 0 then do;
		     call print_message (63, indx);
		     goto equivalence_member_abort;
		end;
		new_offset = new_offset / 4;
	     end;
	return (new_offset);
     end verify_offset_type_kludge;

validate_array_bound:
     proc (bnd_sym_idx);

/* Check that a variable array bound is a common or parameter, scalar, integer
   variable, or the result of an arithmetic expression of such variables. */

dcl      bnd_sym_idx fixed bin (24);			/* Index of the symbol containing the bound. */

dcl      bnd_sym_ptr ptr,
         expression_size fixed bin,
         expression_start fixed bin (18),
         opnd_idx fixed bin (24),
         polish_idx fixed bin (18);

	bnd_sym_ptr = addr (OS (bnd_sym_idx));
	if ^bnd_sym_ptr -> symbol.by_compiler then
	     call validate (bnd_sym_idx);
	else if bnd_sym_ptr -> symbol.initial ^= 0 then do;
	     expression_start = bnd_sym_ptr -> symbol.initial;
	     expression_size = polish_string (expression_start - 1);
	     do polish_idx = expression_start to expression_start + expression_size - 1;
		opnd_idx = polish_string (polish_idx);
		if opnd_idx > last_assigned_op then
		     if addr (OS (opnd_idx)) -> node.node_type = symbol_node then
			call validate (opnd_idx);
	     end;
	end;
	return;


validate:
     procedure (ndx);

declare	ndx fixed binary (24);			/* INPUT: index of array bound symbol */
declare	symbol_storage bit (5) unaligned defined (sym_ptr -> symbol.storage_info);
declare	sym_ptr pointer;
declare	header_storage bit (5) unaligned defined (addr (OS (sym_ptr -> symbol.parent)) -> header.storage_info);

	sym_ptr = addr (OS (ndx));
	call set_data_fields ((ndx));

	if ^(sym_ptr -> symbol.parameter | sym_ptr -> symbol.in_common) | ^sym_ptr -> symbol.integer
	     | sym_ptr -> symbol.dimensioned then
	     call print_message (19, ndx, SI);
	else
	     symbol_storage = symbol_storage | REF;

/* if variable is in common, set common block header to indicate it is REF */

	if sym_ptr -> symbol.in_common & sym_ptr -> symbol.parent ^= 0 then
	     header_storage = header_storage | REF;

     end validate;
     end validate_array_bound;

     end declaration_processor;

/* BEGIN ext_parse section -SUPPORT  - split 82-03-29  T. Oke */

/* Modification History - 82-04-05 */

/* Modification:
	10 Feb 83, HH - Install LA/VLA support.
	08 Feb 83, HH - 366/369: Fix bug where 'parse_data' fails to force
	     initial value of a character variable to be at least as long
	     as the character variable.
	13 Dec 82, TO - 365: Fix bug in 'parse_expression', where substr
	     processing of (x:) uses 'indx' left from 'x' expression parse,
	     rather than the index of the string symbol which is currently
	     in the stack.
	21 May 82,  TO  - Have needs_descriptors of args set if character
	     and in ansi77 mode.
	19 May 82,  TO  - Have needs_descriptors set if star_extent char 
	     array, as well as variable_extents array in parse_expression.
	 6 May 82,  TO  - Fix bug of reference to entry point in assigning
	     result of  function, link entry assignment to 'return_value'.
	 4 May 82,  TO  - Add needs_descriptors check in parse_expression,
	     to manage setting descriptor requirement for local auto
	     stack allocated variable of character*(*) function.
	 5 Apr 82,  TO  - Check number of args in parse_parameter_list.
	*/

set_data_fields:
     procedure (a_sym);

dcl      a_sym fixed bin (18);
dcl      sym fixed bin (18);
dcl      array_max_size fixed bin (24);
dcl      dt fixed bin (18);
dcl      sp pointer;
dcl      te fixed bin (24);
dcl      wc fixed bin (18);

	sym = a_sym;

	call assign_data_type (sym);

	sp = addr (OS (sym));
	if sp -> symbol.data_type ^= 0 then
	     return;

	dt, sp -> symbol.data_type = index (string (sp -> symbol.mode), TRUE);

	if dt ^= char_mode then
	     wc, sp -> symbol.element_size = data_type_size (dt);
	else if subr_options.ansi_77 then do;
	     wc, sp -> symbol.element_size = sp -> symbol.char_size + 1;
	     sp -> symbol.units = char_units;
	end;
	else
	     wc, sp -> symbol.element_size = divide (sp -> symbol.char_size + chars_per_word, chars_per_word, 17, 0);

	if sp -> symbol.dimensioned & ^sp -> symbol.variable_extents & ^sp -> symbol.star_extents then do;
	     te = addr (OS (sp -> symbol.dimension)) -> dimension.element_count * wc;

	     if dt = char_mode then
		array_max_size = max_array_size.char;
	     else if sp -> symbol.automatic then
		array_max_size = max_array_size.auto;
	     else if sp -> symbol.in_common then
		array_max_size = max_array_size.common;
	     else if sp -> symbol.parameter then
		array_max_size = max_array_size.parm;
	     else if sp -> symbol.static then
		array_max_size = max_array_size.static;
	     else
		array_max_size =
		     max (max_array_size.auto, max_array_size.common, max_array_size.parm, max_array_size.static);

	     if te > array_max_size * units_per_word (sp -> symbol.units) then
		call print_message (136, "size", sym, ltrim (char (array_max_size)) || " words");
	     else
		addr (OS (sp -> symbol.dimension)) -> dimension.array_size = te;
	end;

	return;
     end set_data_fields;

assign_data_type:
     procedure (sym_index);

dcl      sp pointer;
dcl      sym_index fixed bin (18);

	sp = addr (OS (sym_index));
	if string (sp -> symbol.mode) ^= ZERO then
	     return;

	unspec (sp -> symbol.attributes) =
	     unspec (sp -> symbol.attributes) | default_table (index (alphabetic, substr (sp -> symbol.name, 1, 1)));
     end assign_data_type;

build_main_program:
     procedure (subpr_symb);

/* given the index of the symbol for this main program, set the subprogram node */

declare	subpr_symb fixed binary (18);			/* INPUT: index of symbol for main prog */

/* main program must be first */
	if cur_subprogram ^= first_subprogram then
	     call print_message (3);

/* set symbol for the entry point, link entry point to block, treat as user symbol */
	subprogram_symbol = subpr_symb;
	subprogram_conflicts = all_attributes;
	subprogram_attributes = main_attr;
	unspec (addr (OS (subprogram_symbol)) -> symbol.attributes) = main_attr;
	unspec (addr (OS (subprogram_symbol)) -> symbol.storage_info) = SET;
	addr (OS (subprogram_symbol)) -> symbol.parent = cur_subprogram;
	addr (OS (subprogram_symbol)) -> symbol.by_compiler = FALSE;

/* fill in type of subprogram and point to its symbol */

	sub_ptr -> subprogram_type = main_program;
	sub_ptr -> subprogram.symbol = subprogram_symbol;

/* Start the list of pending entries. */

	pending_entry_cnt = 1;
	pending_entry (1).entry_symbol = subprogram_symbol;
	if statement_type < after_subprogram then
	     pending_entry (1).entry_stmnt = unspec (cur_stmnt_ptr -> statement);
	else do;					/* There is no 'program' statement; fake a 'statement' node. */
	     pending_entry (1).entry_stmnt = ""b;
	     addr (pending_entry (1).entry_stmnt) -> statement.op_code = stat_op;
	     addr (pending_entry (1).entry_stmnt) -> statement.location = (18)"1"b;
	     addr (pending_entry (1).entry_stmnt) -> statement.statement = "00001"b;
	     addr (pending_entry (1).entry_stmnt) -> statement.put_in_map = TRUE;
	end;

	subprogram_op = main_op;
	return_value_param = 0;

	return;
     end build_main_program;

build_common_block:
     procedure (common_blk_name) returns (fixed binary (18));

/* build a header node and initialize it for a common-block */

declare	common_blk_name char (256) varying;		/* INPUT - name of common block */
declare	indxx fixed binary (18);			/* Return value */
declare	header_ptr pointer;

	allocate_symbol_name = length (common_blk_name);
	indxx = create_node (header_node, size (header));
	header_ptr = addr (OS (indxx));

	string (header_ptr -> header.storage_class) = common_storage;
	header_ptr -> header.even = TRUE;		/* MUST be on double-word boundary */
	header_ptr -> header.name_length = allocate_symbol_name;
	substr (header_ptr -> header.block_name, 1, allocate_symbol_name) = common_blk_name;

	return (indxx);
     end build_common_block;

process_pending_entries:
     proc;

/* For each pending entry, emit a 'main', 'func' or 'subr' operator, as
   appropriate.  If the entry has parameters, emit assignments to initialize
   any associated compiler generated array bound variables, then emit a
   'process_param_list' operator. */

dcl      Asterisk fixed bin static options (constant) init (0);

dcl      arg_desc_cnt fixed bin,
         arg_desc_idx fixed bin,
         arg_desc_ptr ptr,
         arg_symbol_ptr ptr,
         bound_is_expression bit (1),
         bound_symbol_ptr ptr,
         bypass_label fixed bin (18),
         dim_cnt fixed bin,
         dim_idx fixed bin,
         dimension_ptr ptr,
         entry_symbol fixed bin (18),
         entry_symbol_ptr ptr,
         expression_size fixed bin,
         expression_start fixed bin (18),
         i fixed bin,
         idx_of_count fixed bin (18),
         last_upper_bound fixed bin,
         param_count fixed bin,
         pending_entry_idx fixed bin,
         polish_idx fixed bin,
         stmnt_ptr ptr;

	if cur_statement + size (statement) < next_free_polish then
	     call emit_statement_op (cur_stmnt_ptr);	/* Insure last Polish item is a stat-op. */
	bypass_label = 0;
	do pending_entry_idx = 1 to pending_entry_cnt;
	     entry_symbol = pending_entry (pending_entry_idx).entry_symbol;

/* If there is more than one pending entry, the second and subsequent ones
   must be bypassed (i.e. preceded by a branch to the statement following
   the last pending entry) so that control can not "fall" into the entry
   sequence code from the preceding entry.  The 'bypass_first_pending_entry'
   flag tells us if we have to bypass the first entry. */

	     if bypass_label = 0 & (pending_entry_idx > 1 | bypass_first_pending_entry) then do;
						/* This is the 1st entry to bypass; create the bypass label. */
		cp_label_count = cp_label_count - 1;	/* Generate a unique label number. */
		bypass_label = create_label (cp_label_count, executable_label, GOTO_TARGET);
	     end;
	     if bypass_label ^= 0 then do;		/* Emit a jump to the bypass label. */
		call emit_operand (bypass_label);
		call emit_operator (jump_op);
		stmnt_ptr = cur_stmnt_ptr;
		call emit_statement_op (cur_stmnt_ptr);
		unspec (stmnt_ptr -> statement) = pending_entry (pending_entry_idx).entry_stmnt;
		stmnt_ptr -> statement.next = bit (cur_statement, 18);
	     end;

/* Emit a 'main_op', 'subr_op' or 'func_op', as required for this entry. */

	     call emit_operand (entry_symbol);
	     call emit_count (idx_of_count);
	     call emit_operator ((subprogram_op));

/* Determine the number of parameters for this entry.  The parameters are
   the "nonasterisk" arguments plus any return value.  Also, if the entry
   has any expression extent array parameters, emit assignments to
   initialize the compiler generated bound variables to the expressions. */

	     if return_value_param = 0 then
		param_count = 0;
	     else
		param_count = 1;

	     entry_symbol_ptr = addr (OS (entry_symbol));
	     if entry_symbol_ptr -> symbol.general = 0 then
		arg_desc_cnt = 0;
	     else do;
		arg_desc_ptr = addr (OS (entry_symbol_ptr -> symbol.general));
		arg_desc_cnt = arg_desc_ptr -> arg_desc.n_args;
	     end;

	     do arg_desc_idx = 1 to arg_desc_cnt;
		if arg_desc_ptr -> arg_desc.symbol (arg_desc_idx) ^= Asterisk then do;
		     param_count = param_count + 1;
		     arg_symbol_ptr = addr (OS (arg_desc_ptr -> arg_desc.symbol (arg_desc_idx)));

		     if arg_symbol_ptr -> symbol.variable_extents then do;
						/* Check if any of the variable extents are expressions. */
			dimension_ptr = addr (OS (arg_symbol_ptr -> symbol.dimension));
			dim_cnt = dimension_ptr -> dimension.number_of_dims;

			if dimension_ptr -> dimension.assumed_size then
			     last_upper_bound = dim_cnt - 1;
			else
			     last_upper_bound = dim_cnt;

			do dim_idx = 1 to dim_cnt;
			     do i = 1 to 2;		/* Check lower and upper bound of 'dim_idx'th dimension. */
				if i = 1 then
				     if dimension_ptr -> dimension.v_bound (dim_idx).lower then do;
					bound_symbol_ptr =
					     addr (OS (dimension_ptr -> dimension.lower_bound (dim_idx)));
					bound_is_expression = bound_symbol_ptr -> symbol.by_compiler;
				     end;
				     else
					bound_is_expression = FALSE;
				else if dimension_ptr -> dimension.v_bound (dim_idx).upper
				     & dim_idx <= last_upper_bound then do;
				     bound_symbol_ptr =
					addr (OS (dimension_ptr -> dimension.upper_bound (dim_idx)));
				     bound_is_expression = bound_symbol_ptr -> symbol.by_compiler;
				end;
				else
				     bound_is_expression = FALSE;

				if bound_is_expression then do;
						/* Emit assignment of bound expression to bound variable. */
				     expression_start = bound_symbol_ptr -> symbol.initial;
				     expression_size = polish_string (expression_start - 1);

				     if next_free_polish + expression_size + 2 >= polish_max_len then
					call print_message (67, "polish string", char (polish_max_len));
				     else do;
					call emit_operand (fixed (rel (bound_symbol_ptr)));
					do polish_idx = expression_start
					     to expression_start + expression_size - 1;
					     polish_string (next_free_polish) = polish_string (polish_idx);
					     next_free_polish = next_free_polish + 1;
					end;
					call emit_operator (assign_op);
				     end;
				end;
			     end;
			end;
		     end;
		end;
	     end;

/* If there are any parameters, emit the 'process_param_list' operator. */

	     if param_count > 0 then do;
		polish_string (idx_of_count) = param_count - bias;
						/* Store param_count in entry op. */
		call emit_operand (param_count - bias);
		call emit_operator (process_param_list_op);
		do arg_desc_idx = 1 to arg_desc_cnt;
		     if arg_desc_ptr -> arg_desc.symbol (arg_desc_idx) ^= Asterisk then do;
			call emit_operand ((arg_desc_ptr -> arg_desc.symbol (arg_desc_idx)));
			call emit_operator (item_op);
		     end;
		end;
		if return_value_param ^= 0 then do;
		     call emit_operand (return_value_param);
		     call emit_operator (item_op);
		end;
		call emit_operator (eol_op);
	     end;

/* Emit a new stat-op for the next statement, then change the preceding one
   to reflect the entry we just processed. */

	     stmnt_ptr = cur_stmnt_ptr;
	     call emit_statement_op (cur_stmnt_ptr);
	     unspec (stmnt_ptr -> statement) = pending_entry (pending_entry_idx).entry_stmnt;
	     stmnt_ptr -> statement.next = bit (cur_statement, 18);
	end;

/* If we bypassed any entries, emit the bypass label. */

	if bypass_label ^= 0 then do;
	     call emit_operand (bypass_label);
	     call emit_operator (label_op);
	     stmnt_ptr = cur_stmnt_ptr;
	     call emit_statement_op (cur_stmnt_ptr);
	     unspec (stmnt_ptr -> statement) = pending_entry (pending_entry_cnt).entry_stmnt;
	     stmnt_ptr -> statement.next = bit (cur_statement, 18);
	end;

	pending_entry_cnt = 0;
     end process_pending_entries;

emit_operator:
emit_operand:
emit_halfword:
     procedure (op_name_or_opnd_or_data);		/*	Program Specifications (emit_operator)

     Inputs

     Output

     Description (emit_operator)
*/

dcl      count fixed bin (18);
dcl      op_name_or_opnd_or_data fixed bin (18);
dcl      st_info_p ptr;
dcl      stmnt_info_ptr ptr;
dcl      wrd_off fixed bin (18);

	if next_free_polish >= polish_max_len then
	     call print_message (67, "polish string", char (polish_max_len));
						/* polish string too long */
	else do;
	     polish_string (next_free_polish) = op_name_or_opnd_or_data;
	     next_free_polish = next_free_polish + 1;
	end;
	return;

emit_count:
     entry (wrd_off);
	if next_free_polish >= polish_max_len then
	     call print_message (67, "polish string", char (polish_max_len));
						/* polish string too long */
	else do;
	     polish_string (next_free_polish) = -bias;
	     wrd_off = next_free_polish;
	     next_free_polish = next_free_polish + 1;
	end;
	return;

emit_statement_op:
     entry (st_info_p);
	stmnt_info_ptr = st_info_p;			/* Copy value in case input arg is cur_stmnt_ptr. */

	last_cur_statement = cur_statement;

	if next_free_polish + size (statement) >= polish_max_len then
	     call print_message (67, "polish string", char (polish_max_len));
	else do;
	     cur_statement = next_free_polish;
	     cur_stmnt_ptr = addr (polish_string (cur_statement));
	     cur_stmnt_ptr -> statement = stmnt_info_ptr -> statement;

	     next_free_polish = next_free_polish + size (statement);

	     if last_statement ^< 0 then
		addr (polish_string (last_statement)) -> statement.next = bit (cur_statement, 18);

	     last_statement = cur_statement;
	end;
	return;

increment_polish:
     entry (count);
	if next_free_polish + count >= polish_max_len then
	     call print_message (67, "polish string", char (polish_max_len));
	else do;
	     if count = 1 then
		polish_string (next_free_polish) = no_op;
	     else do;
		polish_string (next_free_polish) = increment_polish_op;
		polish_string (next_free_polish + 1) = count - 2;
	     end;
	     next_free_polish = next_free_polish + count;
	end;
	return;
     end emit_operator;

emit_return_op:
     procedure;
	if subprogram_op = func_op then do;
	     call emit_operand (return_value_param);
	     call emit_operand (return_value);
	     call emit_operator (assign_op);
	end;
	call emit_operator (return_op);
     end emit_return_op;

finish_sf_defs:
     proc;
	if sub_ptr -> subprogram_type = block_data then
	     call print_message (4);			/* executable statement in block data */

	assignment_statement_index = assignment_statement;
     end finish_sf_defs;

generate_cross_ref:
     procedure (item);

dcl      item fixed bin (18);


	if number_of_crefs = max_fixed_bin_18 then
	     call print_message (67, "cross reference region", char (max_fixed_bin_18));

	number_of_crefs = number_of_crefs + 1;
	cross_reference (number_of_crefs).symbol = item;

	if cur_statement < 0 | addr (polish_string (cur_statement)) -> statement.line = ZERO then
	     cross_reference (number_of_crefs).line_no = 0;
	else
	     cross_reference (number_of_crefs).line_no = cur_statement_list;
     end generate_cross_ref;

declare_symbol:
     procedure (indx, attributes, conflicts, storage_type) returns (bit (1) aligned);

/*	Program Specifications (declare_symbol)

     Inputs

     Output

     Description (declare_symbol)
*/

dcl      attributes bit (47) aligned;
dcl      conflicts bit (47) aligned;
dcl      header_storage bit (5) unaligned defined (addr (OS (indx_ptr -> symbol.parent)) -> header.storage_info);
dcl      indx fixed bin (18);
dcl      indx_ptr pointer;
dcl      storage_type bit (5) aligned;
dcl      symbol_storage bit (5) unaligned defined (indx_ptr -> symbol.storage_info);

	indx_ptr = addr (OS (indx));

	if (unspec (indx_ptr -> symbol.attributes) & conflicts) ^= ZERO then
	     return (FALSE);

	unspec (indx_ptr -> symbol.attributes) = unspec (indx_ptr -> symbol.attributes) | attributes;

	if storage_type ^= DECLARED then do;
	     symbol_storage = symbol_storage | storage_type;
	     if indx_ptr -> symbol.equivalenced then
		if indx_ptr -> symbol.parent > 0	/* update header only if it exists */
		     then
		     header_storage = header_storage | storage_type;
	end;

	return (TRUE);
     end declare_symbol;

enter_label:
     procedure (a_type, a_value, a_usage) returns (fixed bin (18));

/*	Program Specifications (enter_label)

     Inputs

     Output

     Description (enter_label)
	The fact that legal values for label_type are "01"b, "10"b, "11"b is used in
	selecting error messages.

	In '66 mode, branching into a do-loop is legal.  It is not legal in
	'77 mode and we diagnose a fatal error if we detect it.  We detect
	a branch into a do-loop as follows:  For each executable label, we
	keep track (in its 'label' node) of whether it is branched to or
	ends a do loop, and the statement number of the loop end of the
	do-loop that immediately contains the first executable reference
	to the label.  If we are asked to define an executable label that
	is branched to but which does not end a loop, we check that the
	loop which contained the first branch to the label is the same
	as or contained in the current loop.  If we are asked to reference
	a label in a DO statement, we check that the label has not yet
	been branched to.  If we are asked to reference a label that has
	already been defined, we check that it does not end a loop and
	that the loop containing the referencing statement is the same
	as or contained in the loop which contained the statement which
	defined the label.
*/

dcl      a_type bit (2) aligned;
dcl      a_usage bit (5) aligned;
dcl      a_value fixed bin (18);
dcl      actual_type bit (2) aligned;
dcl      current_loop_end fixed bin (18);
dcl      in_list bit (1) aligned;
dcl      indx fixed bin (18);
dcl      label_storage bit (5) aligned;
dcl      label_type bit (2) aligned;
dcl      label_value fixed bin (18);
dcl      last_item fixed bin (18);
dcl      loop_end fixed bin (18);
dcl      lp pointer;

	label_type = a_type;
	label_value = a_value;
	label_storage = a_usage;

	current_loop_end = 0;
	do indx = do_index to 1 by -1 while (current_loop_end = 0);
	     if do_blockif_stack (indx).do_loop then
		current_loop_end = do_blockif_stack (indx).label_ptr;
	end;

	if label_value <= 0 | label_value > 99999 then do;
	     call print_message (69, char (decimal (label_value, 12)));
						/* label is illegal */
	     label_value = min (max_fixed_bin_18, abs (label_value));
	end;

	last_item = mod (label_value, dim (label_hash_table, 1));
	indx = label_hash_table (last_item);

	in_list = TRUE;

	if indx > 0 then
	     do while (in_list);
		lp = addr (OS (indx));
		if lp -> label.name = label_value then
		     in_list = FALSE;
		else do;
		     last_item = indx;
		     indx = lp -> label.hash_chain;
		     if indx = 0 then
			in_list = FALSE;
		end;
	     end;

	if indx = 0 then do;
	     indx = create_label (label_value, (label_type), (label_storage));
	     lp = addr (OS (indx));

	     if last_item <= hbound (label_hash_table, 1) then
		label_hash_table (last_item) = indx;
	     else
		addr (OS (last_item)) -> label.hash_chain = indx;

	     if produce_listing then
		call generate_cross_ref (indx);

	     if label_type = format_label then do;
		if label_storage = SET then
		     label_storage = INIT;

		indx = build_symbol ((NO_NAME), format_label_attributes, (label_storage));
		lp -> label.format_var = indx;
	     end;

	     if label_type = executable_label & subr_options.ansi_77 then do;
		if substr (label_storage, 1, 3) = REF then
		     if statement_type = do_statement then
			lp -> label.ends_do_loop = TRUE;
		     else
			lp -> label.branched_to = TRUE;
		lp -> label.loop_end = current_loop_end;
	     end;
	     return (indx);
	end;

	if produce_listing then
	     call generate_cross_ref (indx);

	actual_type = string (lp -> label.usage);

/* if label previous entered with no usage info, e.g. in an ASSIGN, and we now can determine its usage, update the info 
   on the other hand, if this is an assign and previous was not, make this label type be consistent with previous */

	if actual_type = any_label & label_type ^= any_label then do;
	     actual_type = label_type;
	     string (lp -> label.usage) = label_type;
	end;
	else if label_type = any_label & actual_type ^= any_label then
	     label_type = actual_type;

	if substr (label_storage, 1, 3) = SET then
	     if lp -> label.set then
		call print_message (70, indx);	/* label is multiply declared */
	     else if actual_type ^= label_type then
		call print_message (70 + binary (label_type, 2, 0));
						/* usage conflicts with stmnt type */
	     else if label_type = executable_label & subr_options.ansi_77 then
		if lp -> label.branched_to & ^lp -> label.ends_do_loop then do;
		     if current_loop_end ^= 0 then do;
			do loop_end = lp -> label.loop_end repeat addr (OS (loop_end)) -> label.loop_end
			     while (loop_end ^= current_loop_end & loop_end ^= 0);
			end;
			if loop_end ^= current_loop_end then
			     call print_message (190, indx, current_loop_end);
		     end;
		     lp -> label.loop_end = current_loop_end;
		end;

	if substr (label_storage, 1, 3) = REF then
	     if label_type ^= actual_type then
		call print_message (73 + binary (label_type, 2, 0), indx);
						/* ref conflicts with previous */
	     else if label_type = executable_label & subr_options.ansi_77 then
		if lp -> label.set then do;		/* Label is already defined. */
		     if statement_type = do_statement then
			call print_message (70, indx);
		     else if lp -> label.ends_do_loop then
			call print_message (190, indx, indx);
		     else do;
			if lp -> label.loop_end ^= 0 then do;
			     do loop_end = current_loop_end repeat addr (OS (loop_end)) -> label.loop_end
				while (loop_end ^= lp -> label.loop_end & loop_end ^= 0);
			     end;
			     if loop_end ^= lp -> label.loop_end then
				call print_message (190, indx, fixed (lp -> label.loop_end, 18));
			end;
		     end;

		end;
		else do;				/* Label is not yet defined. */
		     if statement_type = do_statement then do;
			if lp -> label.branched_to then
			     call print_message (190, indx, indx);
			if ^lp -> label.ends_do_loop then do;
			     lp -> label.ends_do_loop = TRUE;
			     lp -> label.loop_end = current_loop_end;
			end;
		     end;
		     else if ^lp -> label.branched_to then do;
			lp -> label.branched_to = TRUE;
			if ^lp -> label.ends_do_loop then
			     lp -> label.loop_end = current_loop_end;
		     end;
		end;
	string (lp -> label.storage_info) = string (lp -> label.storage_info) | label_storage;

	if actual_type = format_label then do;
	     indx = lp -> label.format_var;
	     if indx = 0				/* no previous use in format context */
	     then do;
		indx = build_symbol ((NO_NAME), format_label_attributes, (label_storage));
		lp -> label.format_var = indx;
	     end;
	     if label_storage = SET then
		label_storage = INIT;
	     string (addr (OS (indx)) -> symbol.storage_info) =
		string (addr (OS (indx)) -> symbol.storage_info) | label_storage;
	end;

	return (indx);
     end enter_label;

create_label:
     procedure (label_name, label_usage, label_allocate_bits) returns (fixed bin (18));

dcl      label_allocate_bits bit (5) aligned;
dcl      label_name fixed bin (18);
dcl      label_usage bit (2) aligned;
dcl      new_label fixed bin (18);

	new_label = create_node (label_node, size (label));

	addr (OS (new_label)) -> label.operand_type = rel_constant;
	addr (OS (new_label)) -> label.name = label_name;
	string (addr (OS (new_label)) -> label.usage) = label_usage;
	string (addr (OS (new_label)) -> label.storage_info) = label_allocate_bits;

	if sub_ptr -> last_label = 0 then
	     sub_ptr -> first_label = new_label;
	else
	     addr (OS (sub_ptr -> last_label)) -> label.next_label = new_label;
	sub_ptr -> last_label = new_label;
	return (new_label);
     end create_label;

get_constant_offset:
     procedure (sym, allow_variable_subscripts) returns (fixed bin (18));

/*	Program Specifications (get_constant_offset)

     Inputs

     Output

     Description - calculates a constant offset, in elements, from constant subscript expressions
*/

dcl      allow_variable_subscripts bit (1) aligned;
declare	ansi66_equivalence_statement bit (1) aligned;
dcl      count fixed bin (18);
declare	dim_size fixed binary (18);
dcl      dp pointer;
declare	error_code fixed binary (35);
dcl      in_list bit (1) aligned;
declare	lower fixed binary (18);
dcl      multiplier fixed bin (18);
dcl      no_dims fixed bin (18);
dcl      off fixed bin (18);
dcl      sym fixed bin (18);
dcl      sp pointer;
dcl      subs fixed bin (18);
dcl      upper fixed bin (18);
declare	value fixed binary (24);
declare	variable_sub bit (1);

	sp = addr (OS (sym));

	off = 0;					/* calculated offset */
	multiplier = 1;				/* Multiplier for current subscript */
	count = 0;				/* number of subscripts */
	ansi66_equivalence_statement = (statement_type = equivalence_statement) & ^subr_options.ansi_77;

/* symbol must be dimensioned without variable bounds */

	if ^sp -> symbol.dimensioned then do;
	     call print_message (76, sym);		/* symbol must have dimension attribute */
	     no_dims = 0;
	     multiplier = 0;			/* final offset should be zero */
	end;
	else do;
	     dp = addr (OS (sp -> symbol.dimension));

	     if sp -> symbol.variable_extents then do;
		call print_message (77, sym);
		no_dims = 0;
		multiplier = 0;			/* final offset should be zero */
	     end;
	     else
		no_dims = dp -> dimension.number_of_dims;
	end;

	in_list = TRUE;
	do while (in_list);
	     count = count + 1;

	     call get_next_token (force_symtab_entry, subs);

/* pick up lower and upper bounds; used for bound checking and to build the multiplier */

	     if count <= no_dims then
		call get_bounds_and_size;
	     else
		upper, multiplier, lower = 0;		/* final offset will not include these subscripts */

/* subscript can be integer or an identifier is allowed */

	     const_index = subs;			/* save for err msg */
	     call get_integer_constant (subs, (allow_variable_subscripts), value, variable_sub, error_code);
	     if error_code ^= 0 then do;		/* illegal expression in constant or variable */
		call print_message (24, "the invalid expression");
		goto statement_parse_abort;
	     end;

	     else if ^variable_sub then do;		/* check that constant subscript within bounds */

		if value < lower then do;
		     if count <= no_dims & ^ansi66_equivalence_statement then do;
			call print_message (78, const_index, "lower", sym);
			value, off, multiplier = 0;
		     end;
		end;

		if value > upper then do;
		     if count <= no_dims & ^ansi66_equivalence_statement then do;
			call print_message (78, const_index, "upper", sym);
						/* subscript exceeds upper bound */
			value, off, multiplier = 0;	/* final offset will be zero */
		     end;
		end;

		off = off + (value - lower) * multiplier;
						/* accumulate constant offset */
	     end;
	     else do;				/* subscript can be a variable in some contexts */

		subs_list (0) = no_dims;		/* inexpensive way to tell caller there are subscripts */
		if count <= no_dims then
		     subs_list (count) = const_index;
	     end;

	     multiplier = multiplier * dim_size;	/* multiplier gets bigger */


	     if token ^= comma then
		in_list = FALSE;
	end;

	if token ^= right_parn then
	     go to missing_right_paren;
	call get_next_token$paren_operator;		/* next token must be an operator or a substr_left_parn */

	if no_dims ^= 0				/* check subscript count for valid refs */
	then do;
	     if ansi66_equivalence_statement then do;
		if count ^= 1 & count ^= no_dims then
		     call print_message (79, sym, "the wrong number of");
		else
		     do count = count + 1 to no_dims;
			call get_bounds_and_size;
			multiplier = multiplier * dim_size;
		     end;
		if multiplier < off then
		     call print_message (422, off + 1 - bias, sym);
	     end;
	     else if count ^= no_dims then
		call print_message (79, sym, "the wrong number of");
	end;
	return (off);

get_bounds_and_size:
     procedure;
	upper = dp -> dimension.dim.upper_bound (count);
	lower = dp -> dimension.dim.lower_bound (count);
	dim_size = dp -> dimension.dim.size (count);
     end get_bounds_and_size;

     end get_constant_offset;

get_char_length:
     procedure (action, sym_index) returns (fixed bin (18));

dcl      action fixed bin (2);
dcl      sym_index fixed bin (18);
dcl      symp pointer;

	symp = addr (OS (sym_index));
	if ^symp -> symbol.star_extents then do;
	     addr (work) -> based_integer = symp -> symbol.char_size + 1;
	     return (create_constant (int_mode, work));
	end;
	else if symp -> symbol.v_length ^= 0 then
	     return (symp -> symbol.v_length);
	else if action = force_symtab_entry then do;
	     symp -> symbol.v_length = build_symbol ((NO_NAME), v_length_attributes, SET);
	     addr (OS (symp -> symbol.v_length)) -> symbol.data_type = int_mode;
	     addr (OS (symp -> symbol.v_length)) -> symbol.element_size = 1;
	     return (symp -> symbol.v_length);
	end;
	else
	     return (0);
     end;

get_data_statement_expression:
     proc;

/* Parse an expression.  Check that its operands are all integer constants
   or implied do-loop indices.  Check that its operators are only '+', '-',
   '*', '/' and '**'.  If the expression is valid, stack its size and Polish;
   otherwise, stack 0 (i.e. a zero-length expression) to indicate it was
   invalid.  To save time later on during expression interpretation, we
   replace the node address of each implied do-loop index by the negative
   of the index of the stack element which will hold the current value of
   the loop index during interpretation. */

dcl      INVALID_CONSTANT fixed bin static options (constant) init (1),
         INVALID_OPERATOR fixed bin static options (constant) init (2),
         INVALID_SYMBOL fixed bin static options (constant) init (3);

dcl      do_idx fixed bin,
         indx fixed bin (18),
         op fixed bin (18),
         opnd_ptr ptr,
         polish_idx fixed bin (18),
         start_of_polish fixed bin (18),
         status fixed bin (35);

	start_of_polish = next_free_polish;
	call get_next_token (force_symtab_entry, indx);
	call parse_expression (set_no_symbol_bits, indx, out);
	status = 0;
	do polish_idx = start_of_polish to next_free_polish - 1 while (status = 0);
	     op = polish_string (polish_idx);
	     if op > last_assigned_op then do;
		opnd_ptr = addr (OS (op));
		if opnd_ptr -> node.node_type = constant_node then do;
		     if opnd_ptr -> constant.data_type ^= int_mode then
			status = INVALID_CONSTANT;
		end;
		else if opnd_ptr -> node.node_type = symbol_node then do;
		     do do_idx = 1 to do_level while (op ^= stack (do_info (do_idx)));
		     end;
		     if do_idx <= do_level then
			polish_string (polish_idx) = -do_info (do_idx);
		     else
			status = INVALID_SYMBOL;
		end;
		else
		     status = INVALID_CONSTANT;
	     end;
	     else if op < add_op | op > negate_op then
		status = INVALID_OPERATOR;
	end;
	if status = 0 then
	     if next_free_polish > start_of_polish + 1 & ^addr (out) -> expression.not_constant then do;
						/* Replace constant expression by its value. */
		parameter_info.desired_data_type = int_mode;
		parameter_info.rounding = subr_options.do_rounding;
		parameter_info.start_of_polish = start_of_polish;
		parameter_info.end_of_polish = next_free_polish;
		parameter_info.stack_index = stack_index;
		parameter_info.max_stack = max_stack;
		call fort_eval_parm (addr (parameter_info), "an integer constant expression", status);
		max_stack = parameter_info.max_stack;
		if status = 0 then do;
		     polish_string (start_of_polish) = parameter_info.result_location;
		     next_free_polish = start_of_polish + 1;
		end;
	     end;
	if status ^= 0 then do;
	     if status = INVALID_CONSTANT then
		call print_message (24, op);
	     else if status = INVALID_OPERATOR then
		call print_message (175, "an integer expression");
	     else if status = INVALID_SYMBOL then
		call print_message (135, op);
	     next_free_polish = start_of_polish;
	end;
	call stack_operand (next_free_polish - start_of_polish);
	do polish_idx = start_of_polish to next_free_polish - 1;
	     op = polish_string (polish_idx);
	     if op < 1 | op > last_assigned_op then
		call stack_operand (op);
	     else
		call stack_operator (op);
	end;
	next_free_polish = start_of_polish;
     end get_data_statement_expression;

parse_parameter_list:
     procedure (entry_point_name);			/* Not Audited. */

/*	Program Specifications (parse_parameter_list)

     Inputs

     Output

     Description - parses parameter list for subroutine, function, and entry statements.
*/
dcl      adesc fixed binary (18);
dcl      alternate_return bit (1) aligned;
dcl      ap pointer;
dcl      entry_point_name fixed bin (18);
dcl      ep_name fixed bin (18);
dcl      saved_stack_index fixed binary (18);

	ep_name = entry_point_name;

	if declare_symbol (ep_name, subprogram_attributes, subprogram_conflicts, SET) then
	     addr (OS (ep_name)) -> symbol.parent = cur_subprogram;
						/* link entry point to block */
	else
	     call print_message (127, ep_name);

/* parse parameter list */

	call get_next_token$operator;			/* get left paren or eos */

	count = 0;
	num_args = 0;
	saved_stack_index = stack_index;
	alternate_return = FALSE;			/* param list does not contain alt ret param */

	if token = left_parn then do;
	     in_list = (token_list (current_token + 1).type ^= right_parn);

/* an empty parameter list is just a left and right paren and needs no further analysis */

	     if in_list then
		sub_ptr -> subprogram.has_parameters = TRUE;
	     else
		call get_next_token$operator;

	     do while (in_list);			/* loop thru parameters */

		call get_next_token (force_symtab_entry, indx);

/* parameter must be name or * */

		if token = ident then do;
		     count = count + 1;

		     if ^declare_symbol (indx, param_attr, param_conflicts, DECLARED) then
			call print_message (30, "parameter", indx);
		     else
			call check_param_position (indx);
						/* check for different position */

		     call stack_operand (indx);	/* save indx for arg_desc  */
		end;

		else if token = asterisk & subprogram_op = subr_op then do;
		     alternate_return = TRUE;
		     call stack_operand (0);		/* tell we're  not a symbol   */
		end;

		else
		     go to missing_identifier;

		num_args = num_args + 1;
		call get_next_token$operator;		/* get comma or right paren */
		if token ^= comma then
		     in_list = FALSE;

	     end;

	     if token ^= right_parn then
		go to missing_right_paren;

	     current_token = current_token + 1;		/* skip over right paren */
	end;

/* entry and subroutine statements don't require the parens for a null list, but all function statements do */

	else if statement_type >= function_statement & statement_type < after_subprogram then
	     goto missing_left_paren;

/* for functions, the return value must be added to the parameter list */

	if subprogram_op = func_op then do;
	     count = count + 1;

	     call check_param_position (return_value_param);
						/* check for different position */

	end;

/* for subroutines with label value parameters, alt ret value must be added to param list */

	else if alternate_return then do;
	     count = count + 1;

	     if return_value_param = 0		/* first ref so create it */
		then
		return_value_param = build_symbol ((NO_NAME), param_variable_attrs | attr_table (int_mode), REF);

	     call check_param_position (return_value_param);
						/* otherwise check for different position */

	end;

/* create  an arg_desc node for the parameter-list and fill it in with the
   info placed in the stack - then reset the stack_index */

	adesc = create_node (arg_desc_node, size (arg_desc));
	ap = addr (OS (adesc));
	ap -> arg_desc.n_args = num_args;

	do i = 1 to num_args;
	     ap -> arg_desc.symbol (i) = stack (saved_stack_index + i - 1);
	end;


/* Check if too many parameters.  Warn if so. */

	if num_args > max_arglist then
	     call print_message (189, max_arglist - bias);

	addr (OS (ep_name)) -> symbol.general = adesc;
	stack_index = saved_stack_index;

/* Add this entry to the list of pending entries. */

	if pending_entry_cnt < hbound (pending_entry, 1) then do;
	     pending_entry_cnt = pending_entry_cnt + 1;
	     pending_entry (pending_entry_cnt).entry_symbol = ep_name;
	     pending_entry (pending_entry_cnt).entry_stmnt = unspec (cur_stmnt_ptr -> statement);
	end;
	else
	     call print_message (67, "pending_entry", char (hbound (pending_entry, 1)));

	return;

check_param_position:
     procedure (formal_parameter);

dcl      formal_parameter fixed bin (18);

	if addr (OS (formal_parameter)) -> symbol.location ^= 0 then
	     if addr (OS (formal_parameter)) -> symbol.location ^= count then
		if addr (OS (formal_parameter)) -> symbol.general ^= ep_name then
		     addr (OS (formal_parameter)) -> symbol.stack_indirect = TRUE;
		else
		     call print_message (39, formal_parameter);

	addr (OS (formal_parameter)) -> symbol.location = count;
	addr (OS (formal_parameter)) -> symbol.general = ep_name;
     end check_param_position;
     end parse_parameter_list;

parse_data:
     procedure;					/* Not Audited. */

/*	Program Specifications (parse_data)

     Inputs

     Output

     Description (parse_data)

Parses the constant list and generates "initial value nodes" to represent the required initiation.
These are not true nodes because they are allocated in the polish string. Each node requires three
halfwords that are used as follows:

	+0	pointer to next node (Also used to chain free "nodes")
	+1	repetition count for this value
	+2	pointer to operand table node for constant or has the value "gap_value"


     Initial values for arrays (and variables) are stored in a chained list
in the order of the array elements. This method prevents multiple initial values
for a given element and allows the storage allocator to make a single pass to
generate initial value templates.

     The initial attribute is assigned to the symbol only if a non-zero value
is given as an initial value.


     This parser is driven by information stored by either a data statement parser or a mode
statement parser. The information stored includes implied do loop control information as well as
variables, array element names, or array vectors. See the description under the data statement
parse for a complete description of how the information is encoded.
*/

dcl      c_count fixed bin (18);
dcl      c_dt fixed bin (4);
dcl      char_count fixed bin (18);
dcl      char_len fixed bin (18);
dcl      char_var_length fixed bin (10);
dcl      char_var_value char (char_var_length) based (addr (char_temp));
dcl      cv_ptr pointer;
dcl      conv_error fixed bin (35);
dcl      const fixed bin (18);
dcl      current_spec fixed bin (18);
declare	current_value fixed binary (18);
dcl      data_error bit (1) aligned;
declare	dim_size fixed bin (18);
dcl      dp pointer;
dcl      el_ct fixed bin (18);
dcl      final_expression_idx fixed bin (18);
declare	final_value fixed binary (18);
dcl      have_constant_subscripts bit (1) aligned;
dcl      i fixed bin (18);
dcl      in_list bit (1) aligned;
dcl      increment_expression_idx fixed bin (18);
declare	increment_value fixed binary (18);
dcl      indx fixed bin (18);
dcl      initial_expression_idx fixed bin (18);
dcl      interval fixed bin (18);
dcl      interval_ptr fixed bin (18);
dcl      j fixed bin (18);
dcl      last fixed bin (18);
declare	loop_info fixed binary (18);
declare	lower fixed bin (18);
dcl      multiplier fixed bin (18);
dcl      non_zero_value bit (5) aligned;
dcl      octal_value bit (72) aligned;
dcl      off fixed bin (18);
dcl      partial_offset fixed bin (18);
dcl      substr_finish fixed bin (10);
dcl      substr_length fixed bin (10);
dcl      substr_start fixed bin (10);
dcl      t_ct fixed bin (18);
dcl      target fixed bin (18);
dcl      upper fixed bin (18);
dcl      v_dt fixed bin (4);
dcl      v_count fixed bin (18);


	from_data_parser = TRUE;			/* To suppress msgs in get_next_token */
	c_count = 0;				/* number of constants parsed and as yet unused */
	token = comma;				/* token is actually a slash; this for loop */
	do_level = 0;				/* no do loops encountered. */

/* loop thru information stored on the stack */

	current_spec = stack_base;			/* beginning of the list */
	do while (current_spec < stack_index);

/* pick up all do loops that start with this variable */

	     do while (stack (current_spec) = BEGIN_DO_LOOP);
		if do_level = hbound (do_info, 1) then do;
		     call print_message (89, hbound (do_info, 1) - bias);
						/* too deeply nested */
		     go to statement_parse_abort;
		end;

		do_level = do_level + 1;
		do_info (do_level) = current_spec;	/* remember where loop starts */
		initial_expression_idx = current_spec + INITIAL_EXPRESSION;
		stack (current_spec + CURRENT_VALUE) = value (initial_expression_idx);

/* skip over do loop parameters */
		final_expression_idx = initial_expression_idx + stack (initial_expression_idx) + 1;
		increment_expression_idx = final_expression_idx + stack (final_expression_idx) + 1;
		current_spec = increment_expression_idx + stack (increment_expression_idx) + 1;
	     end /* current_spec = BEGIN_DO_LOOP */;

/* get the next item from the list, either subscripted or not */

	     target = stack (current_spec);

	     if target > 0				/* array name or scalar variable */
	     then do;
		indx = target;
		current_spec = current_spec + 1;
		if addr (OS (indx)) -> symbol.dimensioned then do;
		     v_count = addr (OS (addr (OS (indx)) -> symbol.dimension)) -> dimension.element_count;
		     if v_count = 0 then
			call print_message (77, indx);/* symbol must have constant extents */
		end;
		else
		     v_count = 1;
		off = 0;
		have_constant_subscripts = FALSE;
	     end /* array_name or scalar var */;

	     else if target = SUBSTR | target = SUBSCRIPTED_VAR | target = SUBSCRIPTED_SUBSTR then do;
		indx = stack (current_spec + SYMBOL_INDEX);
		off = 0;
		v_count = 1;
		current_spec = current_spec + 2;
		if target = SUBSTR then
		     have_constant_subscripts = FALSE;
		else do;
		     have_constant_subscripts = TRUE;	/* Assume all subscripts are constant. */

		     dp = addr (OS (addr (OS (indx)) -> symbol.dimension));
						/* dimension node for symbol */
		     multiplier = 1;		/* used to calculate offset */

		     do i = 1 to dp -> dimension.number_of_dims;

/* find and process subscripts */
			upper = dp -> dimension.dim.upper_bound (i);
			lower = dp -> dimension.dim.lower_bound (i);
			dim_size = dp -> dimension.dim.size (i);

			if stack (current_spec) ^= 1 | stack (current_spec + 1) < 0 then
			     have_constant_subscripts = FALSE;
						/* At least one subscript is not constant. */
			j = value (current_spec);
			if j > upper then do;
			     call print_message (78, j - bias, "upper", indx);
						/* value exceeds upper bound */
			     j = upper;
			end;
			else if j < lower then do;
			     call print_message (78, j - bias, "lower", indx);
			     j = lower;
			end;

			off = off + (j - lower) * multiplier;
						/* add subscript to offset */
			multiplier = multiplier * dim_size;
			current_spec = current_spec + stack (current_spec) + 1;
						/* skip over this subscript */
		     end;
		end;

		if target = SUBSTR | target = SUBSCRIPTED_SUBSTR then do;
						/* Extract start and finish positions. */
		     char_var_length = addr (OS (indx)) -> symbol.char_size + 1;
		     substr_start = value (current_spec);
		     current_spec = current_spec + stack (current_spec) + 1;
		     if substr_start < 1 then do;
			call print_message (155, indx, "start < 1");
			substr_start = 1;
		     end;
		     else if substr_start > char_var_length then do;
			call print_message (155, indx, "start > length");
			substr_start = char_var_length;
		     end;
		     substr_finish = value (current_spec);
		     current_spec = current_spec + stack (current_spec) + 1;
		     if substr_finish < substr_start then do;
			call print_message (155, indx, "finish < start");
			substr_finish = substr_start;
		     end;
		     else if substr_finish > char_var_length then do;
			call print_message (155, indx, "finish > length");
			substr_finish = char_var_length;
		     end;
		     substr_length = substr_finish - substr_start + 1;
		end;
	     end;

	     else do;				/* It had better be SKIP. */
		have_constant_subscripts = FALSE;
		indx = 0;
		off = 0;
		v_count = 1;
		current_spec = current_spec + 1;
	     end;

/* insure variable can acquire the initial attribute */

	     if indx = 0 then do;
		v_dt = 0;
		data_error = TRUE;
	     end;
	     else if ^declare_symbol (indx, variable_attributes, equiv_conflicts, DECLARED) then do;
		call print_message (126, indx);
		v_dt = 0;
		data_error = TRUE;
	     end;
	     else do;
		call set_data_fields (indx);
		v_dt = addr (OS (indx)) -> symbol.data_type;
						/* copy data type */
		data_error = FALSE;
	     end;

/* Common is initialed in block data only. Allocate bit is set only if in block data. */

	     if indx = 0 then
		non_zero_value = DECLARED;
	     else if addr (OS (indx)) -> symbol.in_common then
		if sub_ptr -> subprogram_type = block_data then
		     if addr (OS (addr (OS (indx)) -> symbol.parent)) -> header.block_name = blank_common_name
		     then do;
			call print_message (128, indx);
						/* a member of blank common */
			data_error = TRUE;
			non_zero_value = DECLARED;
		     end;
		     else
			non_zero_value = REF;	/* member of common in block data */
		else do;
		     call print_message (80, indx);	/* cannot initial common block */
		     data_error = TRUE;
		     non_zero_value = DECLARED;
		end;
	     else if sub_ptr -> subprogram_type = block_data then
		if addr (OS (indx)) -> symbol.equivalenced then
		     non_zero_value = REF;
		else
		     non_zero_value = DECLARED;
	     else
		non_zero_value = DECLARED;

/* If the offset > 0, then the correct element position must be found. */

	     partial_offset = off;			/* copy offset */
	     last = -indx;				/* indicates that there is no previous interval */
	     interval = 0;				/* number of elements in interval being redefined */
	     current_value = gap_value;		/* indicates there is no current value */

	     in_list = TRUE;
	     if indx = 0 then
		interval_ptr = 0;
	     else
		interval_ptr = addr (OS (indx)) -> symbol.initial;
	     do while (in_list & interval_ptr ^= 0);

		interval = polish_string (interval_ptr + 1);
						/* number of elements */

		if partial_offset < interval		/* initialization will redefine an existing interval */
		then do;
		     in_list = FALSE;
		     interval = interval - partial_offset;
						/* number of elements preceding new value */

/* interval being redefined must be empty and its length >= number of new values */

		     current_value = polish_string (interval_ptr + 2);
		     if current_value ^= gap_value then
			if target = SUBSTR | target = SUBSCRIPTED_SUBSTR then do;
			     if unspec (
				substr (addr (OS (current_value)) -> char_constant.value, substr_start,
				substr_length)) ^= ""b then do;
				call print_message (81, indx);
				data_error = TRUE;
			     end;
			end;
			else do;
			     call print_message (81, indx);
						/* redefining an element */
			     data_error = TRUE;
			end;

		     if polish_string (interval_ptr) ^= 0 & v_count > interval
						/* check length, if required */
		     then do;
			call print_message (81, indx);/* redefining an element */
			data_error = TRUE;
		     end;
		end;

/* not on this interval, get the next one */

		else do;
		     partial_offset = partial_offset - interval;
						/* reduce offset by width of this interval */
		     interval = 0;			/* no current interval */
		     last = interval_ptr;		/* remember this interval */
		     interval_ptr = polish_string (interval_ptr);
						/* get next interval or end of list */
		end;
	     end;

/* if the new element is in the middle of an interval, filler is required for preceding elements */

	     if partial_offset > 0 then
		call store_value (partial_offset, (current_value));

/* loop thru all the elements being initialized for this reference */

	     do while (v_count > 0);

/* if there are no left over constants, parse another one */

		if c_count = 0 then do;
		     if token ^= comma then
			if token ^= slash then
			     go to missing_comma;
			else do;
			     call print_message (82); /* fewer constants than variables */
			     call get_next_token (ignore_symtab_entry, ignore_value);
			     stack_index = stack_base;
			     return;
			end;

		     call get_next_token (locate_symtab_entry, const);

		     c_count = 1;
		     if token = dec_int then
			if token_list (current_token + 1).type = asterisk then do;
			     c_count = addr (work) -> based_integer;
			     if c_count <= 0 then do;
				call print_message (24, const);
						/* count must be positive */
				c_count = 1;
			     end;

			     current_token = current_token + 1;
						/* skip over the asterisk */
			     call get_next_token (locate_symtab_entry, const);
			end;

		     call parse_a_constant (TRUE, const, octal_value);
						/* TRUE= allow octal */

		     if const = 0 then
			c_dt = 0;			/* octal constants have no data type */
		     else do;
			c_dt = addr (OS (const)) -> constant.data_type;
			if c_dt ^= char_mode then
			     cv_ptr = addr (addr (OS (const)) -> constant.value);
		     end;

		     call get_next_token$operator;	/* get comma or slash */
		end;				/* loop to parse a constant and replication factor */

		el_ct = min (v_count, c_count);	/* only use what is available */

/* Now store the initial value, converting to target data type if required. */

		if v_dt > 0			/* zero if variable cannot take an initial value */
		then do;

		     if v_dt > char_mode then
			go to conversion_error;	/* weird mode for variable */

		     if c_dt > char_mode then
			go to conversion_error;	/* weird mode for constant */

		     go to convert_initial (v_dt * (char_mode + 1) - char_mode + c_dt);

convert_initial (42):				/* character = character */
		     char_var_length = addr (OS (indx)) -> symbol.char_size + 1;
		     if target = SUBSTR | target = SUBSCRIPTED_SUBSTR then do;
			if current_value = gap_value then
			     unspec (char_var_value) = ""b;
			else
			     char_var_value = addr (OS (current_value)) -> char_constant.value;
			if addr (OS (const)) -> char_constant.length > substr_length then do;
			     call print_message (139, indx, substr_length - bias);
			     substr (char_var_value, substr_start, substr_length) =
				substr (addr (OS (const)) -> char_constant.value, 1, substr_length);
			end;
			else
			     substr (char_var_value, substr_start, substr_length) =
				addr (OS (const)) -> char_constant.value;
			call store_value (el_ct, create_char_constant (char_var_value));
		     end;
		     else if addr (OS (const)) -> char_constant.length < char_var_length then do;
						/*  Too short: Create constant of required size.  */
			char_var_value = addr (OS (const)) -> char_constant.value;
			call store_value (el_ct, create_char_constant (char_var_value));
		     end;
		     else do;			/*  Long enough:  Use as much as needed.  */
			if addr (OS (const)) -> char_constant.length > char_var_length then
			     call print_message (139, indx, char_var_length - bias);
			call store_value (el_ct, (const));
		     end;
		     goto reduce_counts;

convert_initial (2):				/* integer = integer */
convert_initial (10):				/* real = real */
convert_initial (18):				/* double precision = double precision */
convert_initial (26):				/* complex = complex */
convert_initial (34):				/* logical = logical */
		     call store_value (el_ct, (const)); /* store without conversion */
		     go to reduce_counts;


convert_initial (6):				/* integer = logical */
convert_initial (13):				/* real = logical */
convert_initial (20):				/* double precision = logical */
convert_initial (27):				/* complex = logical */
convert_initial (29):				/* logical = octal constant */
convert_initial (30):				/* logical = integer */
convert_initial (31):				/* logical = real */
convert_initial (32):				/* logical = double precision */
convert_initial (33):				/* logical = complex */
convert_initial (36):				/* character = octal constant */
convert_initial (37):				/* character = integer */
convert_initial (38):				/* character = real */
convert_initial (39):				/* character = double precision */
convert_initial (40):				/* character = complex */
convert_initial (41):				/* character = logical */
conversion_error:
		     call print_message (83, const, indx);
		     call store_value (el_ct, gap_value);
						/* prevents reinitialization of these elements */
		     go to reduce_counts;


convert_initial (14):				/* real by character */
convert_initial (21):				/* double precision by character */
convert_initial (28):				/* complex by character */
convert_initial (35):				/* logical by character */
convert_initial (7):				/* integer = character */
						/* An entire array may be set using a single constant if the first element is specified. */
		     char_len = chars_per_word * data_type_size (v_dt);
						/* characters per element */
		     char_count = addr (OS (const)) -> char_constant.length;

		     if off = 0 & have_constant_subscripts & el_ct = 1 & do_level = 0 then do;
			t_ct = divide (char_count + char_len - 1, char_len, 17, 0);

			if t_ct > addr (OS (addr (OS (indx)) -> symbol.dimension)) -> dimension.element_count
			     & ^data_error then do;
			     t_ct = addr (OS (addr (OS (indx)) -> symbol.dimension)) -> dimension.element_count;
			     call print_message (139, indx, t_ct * char_len - bias);
			end;

			if interval_ptr ^= 0 & polish_string (interval_ptr) ^= 0 & t_ct > interval then do;
						/* Attempt to reinitialize an element. */
			     call print_message (81, indx);
			     t_ct = interval;
			end;

			do j = 1 to (t_ct - 1) * char_len by char_len;
						/* Store all but last value. */
			     substr (addr (work) -> based_char, 1, char_len) =
				substr (addr (OS (const)) -> char_constant.value, j, char_len);
			     call store_value (1, create_constant (v_dt, work));
			end;

			char_count = char_count - j + 1;
						/* number of chars remaining */
		     end;
		     else
			j = 1;

		     if char_count > char_len then
			call print_message (139, indx, char_len - bias);
						/* more chars than will fit */

		     substr (addr (work) -> based_char, 1, char_len) /* common code assigns last (or only) word. */ =
			substr (addr (OS (const)) -> char_constant.value, j, char_count);
		     go to converted;

convert_initial (1):				/* integer = octal constant */
convert_initial (8):				/* real = octal constant */
		     addr (work) -> based_bit_72 = substr (octal_value, 37, 36);
		     go to converted;

convert_initial (3):				/* integer = real */
convert_initial (5):				/* integer = complex */
		     conv_error = 0;
		     unspec (addr (work) -> based_integer) =
			conv_round (int_mode, real_mode) ((unspec (cv_ptr -> based_real (1))), conv_error);
		     if conv_error < 0		/* number is too large to be an integer */
			then
			call print_message (119, const);
		     goto converted;

convert_initial (4):				/* integer = double_precision */
		     conv_error = 0;
		     unspec (addr (work) -> based_integer) =
			conv_round (int_mode, dp_mode) ((unspec (cv_ptr -> based_double)), conv_error);
		     if conv_error < 0		/* number is too large to be an integer */
			then
			call print_message (119, const);
		     goto converted;

convert_initial (15):				/* double precision = octal constant */
convert_initial (22):				/* complex = octal constant */
		     addr (work) -> based_bit_72 = octal_value;
		     go to converted;

convert_initial (23):				/* complex = integer */
		     addr (work) -> based_real (2) = 0.0;
						/* 0 is the same in hex */

convert_initial (9):				/* real = integer */
		     unspec (addr (work) -> based_real (1)) =
			conv_round (real_mode, int_mode) ((unspec (cv_ptr -> based_integer)), 0);
		     go to converted;

convert_initial (25):				/* complex = double precision */
		     addr (work) -> based_real (2) = 0.0;
						/* 0 is the same in hex */

convert_initial (11):				/* real = double precision */
		     unspec (addr (work) -> based_real (1)) =
			conv_round (real_mode, dp_mode) ((unspec (cv_ptr -> based_double)), 0);
		     go to converted;

convert_initial (24):				/* complex = real */
		     addr (work) -> based_real (2) = 0.0;
						/* 0 is the same in hex */

convert_initial (12):				/* real = complex */
convert_initial (17):				/* double precision = real */
convert_initial (19):				/* double precision = complex */
		     addr (work) -> based_real (1) = cv_ptr -> based_real (1);
		     go to converted;

convert_initial (16):				/* double precision = integer */
		     unspec (addr (work) -> based_double) =
			conv_round (dp_mode, int_mode) ((unspec (cv_ptr -> based_integer)), 0);

converted:
		     call store_value (el_ct, create_constant (v_dt, work));
		end /* loop: v_dt > 0 */;

reduce_counts:
		v_count = v_count - el_ct;
		c_count = c_count - el_ct;
		interval = interval - el_ct;
	     end /* loop: v_count>0 */;

/* Initialization is done. If interval existed, attempt to combine it with last created node or eliminate it. */

	     if interval_ptr ^= 0 & ^data_error		/* Initialization redefined an existing interval. */
		then
		if interval <= 0 then do;		/* Interval was completely redefined. Remove it from chain. */
		     if last <= 0 then
			addr (OS (-last)) -> symbol.initial = polish_string (interval_ptr);
		     else
			polish_string (last) = polish_string (interval_ptr);

		     polish_string (interval_ptr) = free_chain;
						/* Free the "node". */
		     free_chain = interval_ptr;
		end;
		else if last > 0 then
		     if polish_string (last + 2) = polish_string (interval_ptr + 2) then do;
						/* Remaining part of interval can be combined. */
			polish_string (last + 1) = polish_string (last + 1) + interval;

			polish_string (interval_ptr) = free_chain;
						/* Free the "node". */
			free_chain = interval_ptr;
		     end;
		     else
			polish_string (interval_ptr + 1) = interval;
						/* Shorten the interval. */
		else
		     polish_string (interval_ptr + 1) = interval;
						/* Shorten the interval. */

/* Set attributes for symbol (and header) only if there are non zero values in initial chain. */

	     if (non_zero_value & INIT) = INIT & ^data_error then do;
		string (addr (OS (indx)) -> symbol.storage_info) =
		     string (addr (OS (indx)) -> symbol.storage_info) | non_zero_value;

		if addr (OS (indx)) -> symbol.equivalenced then
		     if addr (OS (indx)) -> symbol.parent > 0
						/* update header only if it exists */
			then
			string (addr (OS (addr (OS (indx)) -> symbol.parent)) -> header.storage_info) =
			     string (addr (OS (addr (OS (indx)) -> symbol.parent)) -> header.storage_info)
			     | non_zero_value;
	     end;

/* process all do loops terminating after this variable */

	     do while (stack (current_spec) = END_DO_LOOP);
		loop_info = do_info (do_level);	/* pointer to loop info */
		initial_expression_idx = loop_info + INITIAL_EXPRESSION;
		final_expression_idx = initial_expression_idx + stack (initial_expression_idx) + 1;
		increment_expression_idx = final_expression_idx + stack (final_expression_idx) + 1;

/* increment loop variable */
		increment_value = value (increment_expression_idx);
		current_value, stack (loop_info + CURRENT_VALUE) =
		     stack (loop_info + CURRENT_VALUE) + increment_value;

/* test if loop is complete */
		final_value = value (final_expression_idx);
		if (increment_value > 0 & current_value > final_value)
		     | (increment_value < 0 & current_value < final_value) then do;
						/* loop is completed, go forward */
		     current_spec = current_spec + END_DO_LOOP_SIZE;
		     do_level = do_level - 1;		/* one fewer containing loops */
		end;
		else
		     current_spec = increment_expression_idx + stack (increment_expression_idx) + 1;
						/* re-execute the range of the loop */
	     end /* loops terminating after this var */;
	end /* main driving loop: current_spec < stack_index */;

/* All variables have been processed. The constant list should also be expended; c_count >0 => excess in repeated value */

	if token ^= slash | c_count > 0 then do;
	     call print_message (84);			/* missing slash */
	     go to statement_parse_abort;
	end;

	call get_next_token (ignore_symtab_entry, ignore_value);
	stack_index = stack_base;
	from_data_parser = FALSE;
	return;


store_value:
     procedure (count, value);

dcl      count fixed bin (18);
dcl      value fixed bin;

	if data_error then
	     return;

	if value ^= gap_value then
	     non_zero_value = non_zero_value | INIT;

/* This value is combined with previous node if possible, otherwise, a new node is created. */

	if last > 0 then
	     if polish_string (last + 2) = value then do;
		polish_string (last + 1) = polish_string (last + 1) + count;
		return;
	     end;

/* A "node" is needed. Allocate it and return. */

	last = create_initial_node (last, interval_ptr, count, (value));
     end store_value;


value:
     proc (expression_idx) returns (fixed bin (18));

/* Return the value of an expression in the stack whose operands are integer
   constants or implied do-loop variables, and whose operators are '+', '-',
   '*', '/', and '**'.  The expression consists of a "size" word (indicating
   how many of the following words are in the expression) and the Polish for
   the expression.  A negative value in the Polish indicates an implied
   do-loop variable and its absolute value is the index of the stack location
   containing the current value of that variable. */

dcl      expression_idx fixed bin (18);

dcl      error condition,
         fixedoverflow condition,
         zerodivide condition;

dcl      exp_idx fixed bin (18),
         op fixed bin (18),
         orig_stack_index fixed bin (18);

	if stack (expression_idx) = 0 then
	     return (0);				/* Assume zero for value of null expression. */

	orig_stack_index = stack_index;
	on error goto error_detected;
	on fixedoverflow goto fixedoverflow_detected;
	on zerodivide goto zerodivide_detected;

	do exp_idx = expression_idx + 1 to expression_idx + stack (expression_idx);
	     op = stack (exp_idx);
	     if op < 0 then
		call stack_operand (stack (-op));
	     else if op > last_assigned_op then
		call stack_operand ((addr (addr (OS (op)) -> constant.value) -> based_integer));
	     else if op >= add_op & op <= negate_op then do;
		if op < negate_op then do;
		     if stack_index < orig_stack_index + 2 then
			goto invalid_expression;
		     stack_index = stack_index - 1;
		end;
		else if stack_index < orig_stack_index + 1 then
		     goto invalid_expression;
		unspec (stack (stack_index - 1)) =
		     binop_trunc (int_mode, int_mode)
		     (op - add_op + 1, (unspec (stack (stack_index - 1))), (unspec (stack (stack_index))), 0);
	     end;
	     else
		goto invalid_expression;
	end;

	if stack_index ^= orig_stack_index + 1 then
	     goto invalid_expression;
	stack_index = orig_stack_index;
	return (stack (stack_index));

error_detected:
	call print_message (174, "error", "an integer expression");
	goto statement_parse_abort;

fixedoverflow_detected:
	call print_message (174, "fixedoverflow", "an integer expression");
	goto statement_parse_abort;

invalid_expression:
	call print_message (525, "in an integer expression");
	goto statement_parse_abort;

zerodivide_detected:
	call print_message (174, "zerodivide", "an integer expression");
	goto statement_parse_abort;

     end value;
     end parse_data;

parse_a_constant:
     procedure (allow_octal_constant, constant_offset, octal_value);

/* This procedure parses one constant, preceded optionally by a sign. It returns a
	   pointer to the constant node for the constant parsed. */

dcl      allow_octal_constant bit (1) aligned;
dcl      const_offset fixed bin (18);
dcl      constant_offset fixed bin (18);
dcl      (i, j) fixed bin;
dcl      octal_digits char (8) aligned int static options (constant) init ("01234567");
dcl      octal_value bit (72) aligned;
dcl      octal_work bit (72) aligned;
dcl      temp_sign bit (9) aligned;

	const_offset = constant_offset;

	if token = plus | token = minus then do;
	     sign = token;
	     call get_next_token (locate_symtab_entry, const_offset);
	end;

/* If constant is a complex constant, call expression parser to parse it. */

	if token = left_parn then do;
	     temp_sign = sign;			/* Copy sign in case components also have signs */
	     sign = ZERO;				/* See procedure "convert_integer_constant" for explanation. */

	     if ^is_complex_constant (const_offset) then
		go to invalid_constant;

	     sign = temp_sign;			/* Restore sign for entire constant */
	end;

	else if (token & is_constant) = ZERO then
	     if token = ident & substr (fast_lookup, 1, 1) = "o" & allow_octal_constant then do;

		octal_work = "0"b;

/* convert the string of digits */

		do i = 1 to min (symbol_length - 1, 24);
		     j = index (octal_digits, substr (full_name, symbol_length - i + 1, 1)) - 1;

		     if j < 0			/* non_octal digit */
			then
			call print_message (130, substr (full_name, symbol_length - i + 1, 1));

		     else if j > 0 then
			substr (octal_work, 73 - 3 * i, 3) = bit (fixed (j, 3), 3);
		end;

		octal_value = octal_work;
		const_offset = 0;
	     end;

	     else do;
invalid_constant:
		call print_message (50, err_string ()); /* missing constant */
		const_offset = value_0;
	     end;

/* If sign is supplied, negate an arithmetic constant. */

	if sign ^= ZERO then do;
	     if const_offset = 0			/* sign invalid for octal constant */
		then
		call print_message (51);

	     else if (token & is_arith_constant) = ZERO then
		call print_message (51);		/* not arithmetic */

	     else if sign = minus then
		const_offset = negate_constant (const_offset);

	     sign = ZERO;				/* See procedure "convert_integer_constant" for explanation. */
	end;

	constant_offset = const_offset;
     end parse_a_constant;

create_initial_node:
     procedure (last_node, next_node, rep_count, value_ptr) returns (fixed bin (18));

dcl      last_node fixed bin (18);
dcl      next_node fixed bin (18);
dcl      new_node fixed bin (18);
dcl      rep_count fixed bin (18);
dcl      value_ptr fixed bin (18);

/* Reuse a free "node" or allocate a new one. */

	if free_chain ^= 0 then do;			/* Reuse an old "node". */
	     new_node = free_chain;			/* Remove node from free chain. */
	     free_chain = polish_string (new_node);

	     polish_string (new_node) = next_node;	/* Store values. */
	     polish_string (new_node + 1) = rep_count;
	     polish_string (new_node + 2) = value_ptr;
	end;
	else do;					/* Create a new "node". */
	     if first_word = 0			/* First "node" for this statement. */
	     then do;
		call emit_operator (increment_polish_op);
		call emit_count (first_word);
	     end;

	     new_node = next_free_polish;		/* Build a "node". */
	     call emit_halfword (next_node);
	     call emit_halfword (rep_count);
	     call emit_halfword (value_ptr);
	end;

	if last_node <= 0 then
	     addr (OS (-last_node)) -> symbol.initial = new_node;
	else
	     polish_string (last_node) = new_node;
	return (new_node);
     end create_initial_node;

create_format:
     procedure (fmt_str, sym_index);			/* Not Audited. */

/*	Program Specifications (create_format)

     Inputs

     Output

     Description (create_format)

     Notes - The variable "char_temp", declared in a containing procedure, must be an acceptable
	input argument in the call to general_format_parse_, below.
*/

dcl      fmt_length fixed bin (18);
dcl      fmt_ptr pointer;
dcl      fmt_str char (*);
dcl      fmt_word (512) char (4) unaligned based (addr (new_format));
dcl      format_string char (fmt_length) based (addr (new_format));
dcl      i fixed bin (18);
dcl      j fixed bin (18);
dcl      k fixed bin (18);
dcl      new_format char (4096) aligned;
dcl      sym_index fixed bin (18);

dcl      1 encoded_format like runtime_format aligned based (addr (new_format));

	if length (fmt_str) > length (char_temp) then do;
	     call print_message (85, length (char_temp) - bias);
						/* too many characters in format */
	     return;
	end;

	char_temp = fmt_str;

	call general_format_parse_ (char_temp, new_format, (subr_options.ansi_77), code);
	if code ^= 0 then do;
	     call print_message (86, addr (new_format) -> error_message);
						/* syntax error in format */
	     return;
	end;

/* The length, in characters, of the output string is returned in "fmt_len". It is always even.
	   The halfword immediately following the output string contains the number of characters parsed.
	   The number of characters parsed must equal the length of the input to this procedure. */

	fmt_length = encoded_format.fmt_len;		/* character length of encoded string */

/* compare length of input string with the number of characters parsed. */

	if length (fmt_str) ^= addr (new_format) -> old_format.fmt (divide (fmt_length, 2, 17, 0) - 1) then
	     call print_message (134);		/* garbage at end */

/* If the specification contains hollerith or character-string fields, the appropriate strings must
	   be copied into the representation of the format spec. */

	if encoded_format.contains_hollerith & encoded_format.version ^= fmt_parse_ver1 then do;

	     i = 1;
	     do k = addr (new_format) -> old_format.fmt (i) repeat addr (new_format) -> old_format.fmt (i)
		while (k ^= end_of_format);

		if k = hollerith_field | k = quoted_string then do;
		     j = addr (new_format) -> old_format.fmt (i + 1);
						/* length of the string */

		     if fmt_length + j > length (new_format)
						/* too big */
		     then do;
			call print_message (85, length (new_format) - bias);
			return;
		     end;

		     substr (new_format, fmt_length + 1, j) =
			substr (char_temp, addr (new_format) -> old_format.fmt (i + 2), j);
		     addr (new_format) -> old_format.fmt (i + 2) = fmt_length + 1;
						/* copy string and update offset field */

		     fmt_length = fmt_length + j;	/* update total length */
		end;

		i = i + increment_table (k);		/* point to next specification */
	     end;

	     addr (new_format) -> old_format.fmt_len = fmt_length;
						/* update length field to include strings */
	end;

/* now build the appropriate constant */

	first_word = 0;				/* No "nodes" allocated by this statement. */

	k = -sym_index;
	fmt_ptr = addr (OS (-k));
	fmt_ptr -> symbol.initialed = TRUE;

	if fmt_length > max_char_length		/* 512 */
	then do;
	     fmt_ptr -> symbol.dimensioned = TRUE;
	     fmt_ptr -> symbol.char_size = chars_per_word - 1;

	     i = divide (fmt_length + chars_per_word - 1, chars_per_word, 17, 0);
	     num_dims = 1;
	     j = create_node (dimension_node, size (dimension));
	     addr (OS (j)) -> dimension.number_of_dims = 1;
	     addr (OS (j)) -> dimension.dim.lower_bound (1) = 1;
	     addr (OS (j)) -> dimension.dim.upper_bound (1) = i;
	     addr (OS (j)) -> dimension.dim.size (1) = i;
	     addr (OS (j)) -> dimension.has_dim_sizes = TRUE;
	     addr (OS (j)) -> dimension.v_bound (1) = ""b;
	     addr (OS (j)) -> dimension.element_count = i;
	     fmt_ptr -> symbol.dimension = j;

	     if fmt_length - i * chars_per_word ^= 0	/* insure there is no garbage */
		then
		addr (new_format) -> based_words (i) =
		     addr (new_format) -> based_words (i)
		     & bit_mask ((fmt_length - i * chars_per_word) + chars_per_word);

	     do j = 1 to i;
		k = create_initial_node (k, 0, 1, create_char_constant (fmt_word (j)));
	     end;
	end;
	else do;
	     fmt_ptr -> symbol.char_size = fmt_length - 1;
	     ignore_value = create_initial_node (k, 0, 1, create_char_constant (format_string));
	end;

/* If data specs generated "nodes" in polish, must indicate how many halfwords are used. */
	if first_word ^= 0 then
	     polish_string (first_word) = next_free_polish - first_word - 1;
     end create_format;

find_symbol_index:
     procedure (a_len, a_index, create_sw, a_last);

/*	Program Specifications (find_symbol_index)

     Inputs

     Output

     Description (find_symbol_index)
*/

dcl      a_index fixed bin (18);
dcl      a_last fixed bin (18);
dcl      a_len fixed bin (18);
dcl      bool builtin;
dcl      create_sw fixed bin (2);
dcl      fast_bits bit (36) aligned;
dcl      in_list bit (1) aligned;
dcl      last_item fixed bin (18);
dcl      n fixed bin (18);
dcl      returned_index fixed bin (18);

	allocate_symbol_name = a_len;

/* Calculate hash bucket value. */

	if allocate_symbol_name = 1 then
	     last_item = binary (unspec (substr (full_name, 1, 1)), 9, 0);
	else do;

/* calculate number of words and mod(length, chars_per_word) */

	     last_item = divide (allocate_symbol_name - 1, chars_per_word, 17, 0) + 1;
	     n = allocate_symbol_name - (last_item - 1) * chars_per_word;

/* mask last word of the symbol name (bit_mask(4) is all ones) */

	     addr (full_name) -> based_words (last_item) = addr (full_name) -> based_words (last_item) & bit_mask (n);

/* form hash index by exclusive or'ing all the words of the symbol name */

	     fast_bits = addr (full_name) -> based_words (1);

	     if last_item >= 2 then
		do n = 2 to last_item;
		     fast_bits = bool (fast_bits, addr (full_name) -> based_words (n), "0110"b);
		end;

	     last_item = mod (binary (fast_bits, 35), dim (hash_table, 1));
	end;

	returned_index = hash_table (last_item);
	in_list = TRUE;

/* search through the symbol table */

	if returned_index > 0 then
	     do while (in_list);
		if addr (OS (returned_index)) -> symbol.name = substr (full_name, 1, allocate_symbol_name) then do;
		     in_list = FALSE;
		     if produce_listing then
			call generate_cross_ref (returned_index);
		end;
		else do;
		     last_item = returned_index;
		     returned_index = addr (OS (returned_index)) -> symbol.hash_chain;
		     if returned_index = 0 then
			in_list = FALSE;
		end;
	     end;

	if returned_index = 0 then
	     if create_sw = force_symtab_entry then do;
		returned_index = create_node (symbol_node, size (symbol));

		addr (OS (returned_index)) -> symbol.name_length = allocate_symbol_name;
		substr (addr (OS (returned_index)) -> symbol.name, 1, allocate_symbol_name) =
		     substr (full_name, 1, allocate_symbol_name);

		if sub_ptr -> last_symbol = 0 then
		     sub_ptr -> first_symbol = returned_index;
		else
		     addr (OS (sub_ptr -> last_symbol)) -> symbol.next_symbol = returned_index;
		sub_ptr -> last_symbol = returned_index;

		if last_item <= hbound (hash_table, 1) then
		     hash_table (last_item) = returned_index;
		else
		     addr (OS (last_item)) -> symbol.hash_chain = returned_index;

		if produce_listing then
		     call generate_cross_ref (returned_index);
	     end;

	a_index = returned_index;
	a_last = last_item;
     end find_symbol_index;

get_mode_size:
     procedure (mode, a_size, attributes, asterisk_seen);

/*	Program Specifications (get_mode_size)

     Inputs

     Output

     Description (get_mode_size)
	this procedure is called with the current token being the token before the asterisk, when it exists.
*/

dcl      a_size fixed bin (18);
declare	asterisk_seen bit (1) aligned;
dcl      1 attr like symbol.attributes based (addr (attributes));
dcl      attributes bit (47) aligned;
dcl      mode fixed bin (4);
dcl      size fixed bin (9);
dcl      star_extents bit (1) aligned;

	star_extents, asterisk_seen = FALSE;

	if token_list (current_token + 1).type = asterisk then do;
	     asterisk_seen = TRUE;
	     current_token = current_token + 1;
	     call get_next_token (locate_symtab_entry, const_index);

	     if token = dec_int then do;
		size = addr (work) -> based_integer;
		if mode = cmpx_mode then do;		/*   if not single precision then error  */
		     if size ^= 8 then
			call print_message (365, ltrim (char (size, 7)));
		end;
	     end;
	     else if token ^= left_parn then do;
		call print_message (24, err_string ());
		go to statement_parse_abort;
	     end;

	     else do;
		call get_next_token (force_symtab_entry, symbol_index);

		if token = asterisk then
		     if mode = char_mode then
			if subr_options.ansi_77 then do;
			     star_extents = "1"b;
			     call get_next_token$operator;
			end;
			else do;
			     call print_message (158);
			     go to statement_parse_abort;
			end;
		     else do;
			call print_message (24, err_string ());
			go to statement_parse_abort;
		     end;

		else do;
		     parameter_info.start_of_polish = next_free_polish;
		     call parse_expression (any_expression, symbol_index, ignore_bits);

		     parameter_info.max_stack = max_stack;
		     parameter_info.stack_index = stack_index;
		     parameter_info.desired_data_type = int_mode;
		     parameter_info.end_of_polish = next_free_polish - 1;
		     parameter_info.rounding = subr_options.do_rounding;

		     call fort_eval_parm (addr (parameter_info), "a length field expression", error_code);
		     max_stack = parameter_info.max_stack;
		     next_free_polish = parameter_info.start_of_polish;

		     if error_code = 0 then do;
			const_index = parameter_info.result_location;
			size = addr (addr (OS (const_index)) -> constant.value) -> based_integer;
		     end;
		     else if mode = char_mode then
			size = default_char_size;
		end;

		if token ^= right_parn then
		     go to missing_right_paren;
	     end;

	     if mode = char_mode then
		if star_extents then
		     attr.star_extents = "1"b;
		else do;
		     attr.star_extents = "0"b;
		     if size <= 0 then do;
			call print_message (24, const_index);
			size = default_char_size;
		     end;
		     else if size > max_char_var_length /*131071*/
		     then do;
			call print_message (87, addr (OS (SI)) -> symbol.name,
			     max_char_var_length /*131071*/ - bias);
			size = default_char_size;
		     end;
		end;
	     else if (mode = real_mode | mode = dp_mode) then do;
		if size <= 4 then do;
		     if size ^= 4 then
			call print_message (366, "single", ltrim (char (size, 7)));
		     mode = real_mode;
		end;
		else do;
		     if size ^= 8 then
			call print_message (366, "double", ltrim (char (size, 7)));
		     mode = dp_mode;
		end;
	     end;

	end;
	else
	     size = a_size;

	if mode = char_mode then
	     if attr.star_extents then do;
		attr.char_size = 0;
		a_size = 0;
	     end;
	     else do;
		attr.char_size = size - 1;
		a_size = size;
	     end;
	else
	     attributes = attr_table (mode);

     end get_mode_size;

parse_implied_io:
     procedure (rd_sw, unit, allow_asterisk);

/*	Program Specifications (parse_implied_io)

     Inputs

     Output

     Description (parse_implied_io)
*/

dcl      indx fixed bin (18);
dcl      rd_sw bit (1) aligned;
declare	allow_asterisk bit (1) aligned;

dcl      unit fixed bin (18);

	string (io_bits) = FALSE;
	fields_specified = ZERO;
	io_bits.read = rd_sw;
	io_bits.fold = subr_options.fold;
	io_bits.ansi_77 = subr_options.ansi_77;
	io_bits.hfp = subr_options.hfp;
	io_bits.debug_io = subr_options.debug_io;

	sub_ptr -> need_PS = TRUE;

	call emit_operand (unit);

	call get_next_token$label (force_symtab_entry, indx);
	if token ^= comma & token ^= EOS_token then do;
	     call get_format (indx, allow_asterisk);
	end;

	if token = comma then do;
	     if current_token >= last_token then do;
		current_token = current_token + 1;
		go to missing_identifier;
	     end;
	end;
	else if token ^= EOS_token then
	     go to missing_comma;

	call parse_io_list;
     end parse_implied_io;

parse_io:
     procedure (rd_sw);

/*	Program Specifications (parse_io)

     Inputs

     Output

     Description (parse_io)
*/

dcl      indx fixed bin (18);
dcl      rd_sw bit (1) aligned;
declare	no_keyword fixed binary;
declare	fmt fixed binary (18);

	string (io_bits) = FALSE;
	fields_specified = ZERO;
	io_bits.read = rd_sw;
	io_bits.fold = subr_options.fold;
	io_bits.ansi_77 = subr_options.ansi_77;
	io_bits.hfp = subr_options.hfp;
	io_bits.debug_io = subr_options.debug_io;

	sub_ptr -> need_PS = TRUE;

	call get_next_token$operator;			/* get left paren */
	if token ^= left_parn then
	     go to missing_left_paren;

	count = 0;
	no_keyword = 0;
	in_list = TRUE;
	do while (in_list);
	     count = count + 1;
	     call get_next_token (ignore_symtab_entry, ignore_value);
	     if token_list (current_token + 1).type = assign then do;
						/* keyword driven list element */
		if token ^= ident then
		     go to missing_keyword;
		else if substr (full_name, 1, symbol_length) = "err" then
		     call parse_error_label;
		else if substr (full_name, 1, symbol_length) = "end" then
		     call parse_end_label;
		else if substr (full_name, 1, symbol_length) = "unit" then
		     call parse_unit_specifier (TRUE, FALSE);
		else if substr (full_name, 1, symbol_length) = "iostat" then
		     call parse_iostat_var;
		else if substr (full_name, 1, symbol_length) = "fmt" then do;
		     call get_next_token$operator;	/* skip over the "=" */
		     call get_next_token$label (force_symtab_entry, fmt);
		     call get_format (fmt, TRUE);
		end;
		else if substr (full_name, 1, symbol_length) = "rec" then do;
		     call get_next_token$operator;
		     call get_next_token (force_symtab_entry, indx);
		     call parse_record_number (indx);
		end;
		else
		     goto invalid_keyword;
	     end;
	     else do;

/* if no keyword, then assume UNIT = if first in list, FMT = if second in list
and first was also unit, but with no keyword, otherwise an error */

		no_keyword = no_keyword + 1;
		if count = 1 then do;
		     call parse_unit_specifier$no_keyword (TRUE, FALSE);
		     if token = apostrophe then do;
			call get_next_token (force_symtab_entry, indx);
			call parse_record_number (indx);
		     end;
		end;
		else if count = 2 then do;
		     if no_keyword = 2 then
			if token = comma | token = right_parn then do;
						/* old list directed input */
			     io_bits.format = list_directed;
			     substr (fields_specified, fmt_field, 1) = TRUE;
			end /* null list element */;
			else do;
			     current_token = current_token - 1;
			     call get_next_token$label (force_symtab_entry, fmt);
			     call get_format (fmt, TRUE);
			end /* usual parse of format */;
		     else do;

/* if this is not keyword driven, is the second list item, the first item should have been keyword driven */
			go to missing_keyword;
		     end;
		end /* count = 2 */;
		else
		     goto missing_keyword;		/* count > 2 */
	     end /* no keyword */;

	     in_list = (token = comma);
	end /* while loop */;

/* error checking */

	if ^substr (fields_specified, units_field, 1) then
	     call print_message (31, keyword_table (statement_type), "unit");

	if substr (fields_specified, rec_field, 1) & io_bits.end_label then
	     call print_message (187, keyword_table (statement_type), "rec and end");

	if io_bits.end_label & ^io_bits.read then
	     call print_message (187, keyword_table (statement_type), "end");

	if io_bits.read & io_bits.end_label & io_bits.mode ^= sequential_access then
	     call print_message (187, keyword_table (statement_type), "sequential access and end");

	if ^substr (fields_specified, fmt_field, 1) then
	     io_bits.format = unformatted;

	if io_bits.mode = internal_file then do;
	     if io_bits.format = unformatted then
		call print_message (31, "internal file" || keyword_table (statement_type), "format");
	     else if io_bits.format = list_directed then
		call print_message (187, keyword_table (statement_type), "internal file and list directed");
	end;
	if token ^= right_parn then
	     go to missing_right_paren;

	call parse_io_list;
     end parse_io;

parse_io_options:
     procedure;

/*	Program Specifications (parse_io_options)

     Inputs

     Output

     Description (parse_io_options)
	Comment the sneakiness loudly.
*/
dcl      fmt fixed bin (18);

	if token ^= comma then
	     io_bits.format = unformatted;
	else do;
	     next_token = token_list (current_token + 1).type;
	     if next_token = comma then
		call get_next_token$operator;		/* get that comma */
	     else if token_list (current_token + 2).type = assign & current_token + 2 <= last_token then
		io_bits.format = unformatted;
	     else if next_token = right_parn then
		call get_next_token$operator;		/* get that right paren */
	     else do;
		call get_next_token$label (force_symtab_entry, fmt);
		call get_format (fmt, FALSE);
	     end;
	     do while (token = comma);
		call get_next_token (ignore_symtab_entry, ignore_value);
		if token ^= ident then
		     go to missing_keyword;

		if substr (fast_lookup, 1, symbol_length) = "err" then
		     call parse_error_label;

		else if io_bits.read & io_bits.mode = sequential_access
		     & substr (fast_lookup, 1, symbol_length) = "end" then
		     call parse_end_label;

		else
		     go to invalid_keyword;

	     end /* exception loop */;
	end /* token = comma */;

	if token ^= right_parn then
	     go to missing_right_paren;
     end parse_io_options;

parse_error_label:
     procedure;

dcl      exit_lbl fixed bin (18);
dcl      op_name fixed bin;

	if io_bits.error_label then
	     call print_message (48, "err");
	io_bits.error_label = TRUE;

	op_name = error_label_op;
	go to parse_error_common;

parse_end_label:
     entry;
	if io_bits.end_label then
	     call print_message (48, "end");
	io_bits.end_label = TRUE;

	op_name = end_label_op;

parse_error_common:
	call get_next_token$operator;			/* get equals */
	if token ^= assign then
	     go to missing_equals_sign;

	call get_next_token$label (ignore_symtab_entry, ignore_value);
	if token ^= dec_int then
	     go to missing_label;

	exit_lbl = enter_label (executable_label, (addr (work) -> based_integer), GOTO_REF);
	addr (OS (exit_lbl)) -> label.restore_prs = TRUE;

	call emit_operand (exit_lbl);
	call emit_operator ((op_name));
	call get_next_token (ignore_symtab_entry, ignore_value);
     end parse_error_label;

parse_iostat_var:
     procedure;

dcl      first_sym fixed bin (18);

	if io_bits.iostat_var then
	     call print_message (48, "iostat");
	io_bits.iostat_var = TRUE;

	call get_next_token$operator;			/* get equals */
	if token ^= assign then
	     go to missing_equals_sign;

	call get_next_token (force_symtab_entry, first_sym);
	call parse_expression (set_reference, first_sym, ignore_bits);

	call emit_operator (iostat_op);
     end parse_iostat_var;

parse_unit_specifier:
     procedure (allow_asterisk, build_list_item);

/* the unit specifier is either an asterisk, identifying the default unit specifier, or an integer expression > 0.
   If allow_asterisk is false (e.g. for backspace, endfile, etc.) then must be of the usual variety.
   Unlike parse_iostat_var and parse_end_label, this subroutine does not emit any polish for a "unit" operator.
   This is done as part of the polish by the caller in an appropriate place.
*/
declare	allow_asterisk bit (1) aligned;		/* INPUT */
declare	build_list_item bit (1) aligned;		/* INPUT */

	call get_next_token$operator;
	if token ^= assign then
	     goto missing_equals_sign;
	goto unit_parse_common;

parse_unit_specifier$no_keyword:
     entry (allow_asterisk, build_list_item);

	current_token = current_token - 1;		/* back it up, we assumed it was a keyword */

unit_parse_common:
	if substr (fields_specified, units_field, 1) then
	     call print_message (48, "unit specifier or unit");
	substr (fields_specified, units_field, 1) = TRUE;

	call get_next_token (force_symtab_entry, SI);

/* Check for invalid unit numbers. */

	if (token = dec_int | token = minus) then do;
	     if (token = minus) then do;
		call get_next_token (force_symtab_entry, SI);
		call print_message (194, "-" || (ltrim (char (addr (work) -> based_integer))));
	     end;
	     else if (addr (work) -> based_integer > 99) then
		call print_message (194, ltrim (char (addr (work) -> based_integer)));
	end;

	if token = asterisk then do;
	     if allow_asterisk then do;
		call emit_operand (default_unit_specifier);
		call get_next_token$operator;
	     end;
	     else
		call print_message (149, keyword_table (statement_type));
	end;
	else if token = ident then do;
	     call set_data_fields (SI);
	     if addr (OS (SI)) -> symbol.character then
		call get_internal_file (FALSE);
	     else
		goto not_internal_file;
	end;
	else do;
not_internal_file:
	     call parse_expression (any_expression, SI, ignore_bits);
	end;

/* if building list item, put out the polish - open and close statements */

	if build_list_item then do;
	     call emit_halfword (units_field - bias);
	     call emit_operator (item_op);
	end;
	return;
     end parse_unit_specifier;

parse_record_number:
     procedure (indx);

declare	indx fixed binary (18);			/* INPUT: 1st symbol in expression for record number */

	if substr (fields_specified, rec_field, 1) then
	     call print_message (48, "record specifier or rec");
	if io_bits.mode = internal_file then
	     call print_message (187, keyword_table (statement_type), "internal file and direct access");
	substr (fields_specified, rec_field, 1) = TRUE;

	call parse_expression (any_expression, indx, ignore_bits);
	io_bits.mode = direct_access;
	call emit_operator (record_number_op);
     end parse_record_number;

get_internal_file:
     procedure (from_encode_decode);

declare	from_encode_decode bit (1) aligned;		/* INPUT: T if from encode/decode, F if from read/write */
declare	symp pointer;				/* ptr to symbol node */

	symp = addr (OS (SI));
	call emit_operand (value_0);			/* Dummy file number. */
	if io_bits.read then
	     call parse_expression (string_source, SI, out);
	else
	     call parse_expression (string_target, SI, out);

/* this must be a variable, array name, array element, or substring of those */

	if addr (out) -> expression.not_simple_ref then
	     call print_message (29, keyword_table (statement_type));

/* Emit proper operator, check for errors, and emit polish for string length (encode_decode only) */

	if from_encode_decode then do;
	     if ^sub_ptr -> subprogram.options.optimize then
		call emit_operator (string_op);
	     else if io_bits.read then
		call emit_operator (decode_string_op);
	     else
		call emit_operator (encode_string_op);

	     if io_bits.mode = direct_access then
		call print_message (187, keyword_table (statement_type), "direct access");
	     else
		io_bits.mode = string_io;

/* We must emit the polish for the length of the string 
   for encode/decode, we permit character scalars and non-logical arrays and array elements 
*/

	     if symp -> symbol.character then do;
		addr (work) -> based_integer = symp -> symbol.char_size + 1;
		call emit_operand (create_constant (int_mode, work));
	     end;
	     else do;
		addr (work) -> based_integer = chars_per_word * symp -> symbol.element_size;
		if symp -> symbol.dimensioned & addr (out) -> expression.array_name then do;
		     dp = addr (OS (symp -> symbol.dimension));
		     p = 0;

		     if symp -> symbol.variable_extents then do;
			if dp -> dimension.assumed_size then do;
			     call print_message (166, keyword_table (statement_type));
			     goto statement_parse_abort;
			end;
			do i = 1 to dp -> dimension.number_of_dims;
			     if string (dp -> dimension.v_bound (i)) = ""b
						/* both bounds constant just multiply constant part by size */
				then
				addr (work) -> based_integer =
				     addr (work) -> based_integer * dp -> dimension.dim.size (i);
			     else if string (dp -> dimension.v_bound (i)) = "11"b
						/* both bounds variable, size = upper - lower + 1 */
			     then do;
				call emit_operand ((dp -> dimension.dim.upper_bound (i)));
				call emit_operand ((dp -> dimension.dim.lower_bound (i)));
				call emit_operator (sub_op);
				call emit_operand (value_1);
				call emit_operator (add_op);
				p = p + 1;
			     end;
			     else if dp -> dimension.v_bound.lower (i)
						/* only lower bound is variable.  size = constant (upper_bound +1) - lower_bound */
			     then do;
				call emit_operand (
				     create_constant (int_mode, bit (dp -> dimension.dim.upper_bound (i) + 1, 72))
				     );
				call emit_operand ((dp -> dimension.dim.lower_bound (i)));
				call emit_operator (sub_op);
				p = p + 1;
			     end;
			     else do;

/* only upper bound is variable.  size = upper - constant (lower -1) */
				call emit_operand ((dp -> dimension.dim.upper_bound (i)));
				call emit_operand (
				     create_constant (int_mode, bit (dp -> dimension.dim.lower_bound (i) - 1, 72))
				     );
				call emit_operator (sub_op);
				p = p + 1;
			     end;

			     if i = dp -> dimension.number_of_dims then do;
				call emit_operand (create_constant (int_mode, work));
				p = p + 1;
			     end;

			     if p > 1 then
				call emit_operator (mult_op);
			end /* do loop number of dimesnions */;
		     end /* variable extents */;
		     else do;
			addr (work) -> based_integer = addr (work) -> based_integer * dp -> dimension.element_count;
			call emit_operand (create_constant (int_mode, work));
		     end;
		end /* dimension and array_name */;
		else
		     call emit_operand (create_constant (int_mode, work));
	     end /* not character */;

	     call emit_operator (string_length_op);
	end /* from_encode_decode */;

/* for internal_files from read/write, the code generator deals with length */

	else do;
	     if io_bits.read then
		call emit_operator (read_internal_file_op);
	     else
		call emit_operator (write_internal_file_op);
	     if io_bits.mode = direct_access then
		call print_message (187, keyword_table (statement_type), "direct access and internal file");
	     else
		io_bits.mode = internal_file;
	end /* read-write internal files */;

     end get_internal_file;

get_format:
     procedure (fmt, allow_asterisk);

/*	Program Specifications (get_format)

     Inputs

     Output

     Description (get_format)
*/

dcl      fmt fixed bin (18);
declare	allow_asterisk bit (1) aligned;

dcl      label_ptr fixed bin (18);
dcl      label_storage bit (5) aligned;
dcl      nl_ind fixed bin (18);
dcl      nl_off fixed bin (18);
declare	saved_polish fixed binary (18);

	if io_bits.read then
	     label_storage = SET;
	else
	     label_storage = REF;

	if substr (fields_specified, fmt_field, 1) then
	     call print_message (48, "format specifier or format label");
	substr (fields_specified, fmt_field, 1) = TRUE;

	if token = dec_int				/* FORMAT STATEMENT LABEL */
	then do;
	     label_ptr = enter_label (format_label, (addr (work) -> based_integer), REF);
	     call emit_operand (label_ptr);

	     call process_format_symbol (/* label_ptr */);

	     call get_next_token$operator;		/* get comma or right paren */
	end;

	else if token = ident then do;
	     label_ptr = fmt;

	     if addr (OS (label_ptr)) -> symbol.namelist	/* NAMELIST REFERENCE */
	     then do;

/* mark the group as used and force members into symbol table; add crossref entries for the namelist variables.  */

		addr (OS (label_ptr)) -> symbol.allocate = TRUE;
		nl_off = addr (OS (label_ptr)) -> symbol.initial;
						/* offset into polish */

		do nl_ind = nl_off + 1 to nl_off + polish_string (nl_off);
						/* loop thru members */
		     addr (OS (polish_string (nl_ind))) -> symbol.put_in_symtab = TRUE;
						/* force into symtab */
		     if produce_listing then
			call generate_cross_ref ((polish_string (nl_ind)));

		     if io_bits.read then
			addr (OS (polish_string (nl_ind))) -> symbol.set = TRUE;
						/* if read, mark as set */
		end;				/* loop thru members */

/* emit polish */

		call emit_operand (label_ptr);
		if ^sub_ptr -> subprogram.options.optimize then
		     call emit_operator (namelist_op);
		else if io_bits.read then
		     call emit_operator (read_namelist_op);
		else
		     call emit_operator (write_namelist_op);

		addr (OS (label_ptr)) -> symbol.bits.referenced = TRUE;

		io_bits.format = namelist;		/* set type of I/O */

		options.namelist_used = TRUE;		/* tell code generator namelist occurred */
		sub_ptr -> subprogram.namelist_used = TRUE;
						/* ditto */

		call get_next_token$operator;		/* get comma or right paren */
	     end;					/* do block for namelist */

	     else do;				/* VARIABLE REFERENCE */
		call parse_expression (format_reference, (label_ptr), out);

		call process_format_symbol (/* label_ptr */);

		if ^addr (OS (label_ptr)) -> symbol.attributes.mode_bits.mode.character
		     & addr (out) -> expression.not_simple_ref then
		     call print_message (143, label_ptr);
	     end;					/* do block for var ref */
	end;					/* do block for identifier */

	else if token = char_string			/* CHARACTER STRING REFERENCE */
	then do;

/* optimization: if the expression is a single char_string, at compile time we can create its format variable, much as if
   it were a dec_int, saving the work of the code generator */

	     saved_polish = next_free_polish;
	     label_ptr = fmt;
	     call parse_expression (format_reference, label_ptr, out);
	     if next_free_polish > saved_polish + 1 then
		call process_format_symbol (/* label_ptr */);
	     else do;
		next_free_polish = saved_polish;
		label_ptr = build_symbol ((NO_NAME), format_label_attributes, label_storage);
		call create_format (addr (OS (fmt)) -> char_constant.value, label_ptr);
		call emit_operand (label_ptr);
		call process_format_symbol (/* label_ptr */);
	     end;
	end;

	else if allow_asterisk & token = asterisk then do;
	     io_bits.format = list_directed;		/* set format */
	     call get_next_token$operator;		/* comma or right parn */
	end;

	else do;
	     call print_message (88, err_string ());	/* syntax error */
	     go to statement_parse_abort;
	end;


process_format_symbol:
     proc;

/* Procedure to handle any weird stuff for format symbols. */

	call emit_operator (format_op);
	io_bits.format = formatted;

	if io_bits.read then
	     addr (OS (label_ptr)) -> symbol.set = TRUE;
     end process_format_symbol;
     end get_format;

is_implied_loop:
     procedure /* ( paren_info, paren_count, cur_paren, last_paren_parsed ) */ returns (bit (1) aligned);

/*	Program Specifications


     Inputs

	No explicit arguments.
	This routine assumes the current token is a left paren. It prescans the
	remaining tokens of the statement to determine if this paren begins an implied loop.


     Output

	No explicit arguments.
	Implicit arguments:
	     paren_info - a structure, see notes below
	     paren_count - number of implied do loops encountered. If there were none, this field
		is set to one, and the first vector of the array appears to be a set of parens.
	     cur_paren - index into paren_info for current left paren
	     last_paren_parsed - set to last right paren scanned.


     Description (is_implied_loop)

Notes:
	The structure paren_info contains the following subfields:

	implied_loop - initially false; set to true if an equal sign encountered within this set of parens.

	position - token index of left paren; e.i. - value of current_token for left paren.

	chain - multi-purpose chain; while scanning, it is chain to containing paren for this set; as loops are
	     encountered, a left to right chain is made of the do loops.

	begin_index - token index of last comma encountered before the equal sign; this is updated every time
	     a comma is encountered until an equal sign is encountered.
*/

dcl      j fixed bin (18);
dcl      last_do fixed bin (18);
dcl      previous fixed bin (18);
dcl      token bit (9) aligned;


/* if the current paren is enclosed in another set of parens, scanning is already done */

	if current_token < last_paren_parsed then do;

	     if paren_count = 0 then
		return (FALSE);			/* all scanned parens are not loops */

/* must find info for current paren or there is a logic error */

	     do cur_paren = cur_paren + 1 to paren_count;
		if paren_info (cur_paren).position = current_token then
		     return (paren_info (cur_paren).implied_loop);
	     end;

	     call print_message (34);			/* apparent syntax error or logic error */
	     go to statement_parse_abort;
	end;

/* this paren (and contained parens) has not been prescanned; do it now */

	last_do = 0;				/* left to right chain of nested loops */

	paren_count = 1;				/* current token is first left paren */
	cur_paren = 1;				/* current paren info is in first array slot */

	paren_info (1).implied_loop = FALSE;		/* not yet determined to be an implied loop */
	paren_info (1).chain = 0;			/* no containing paren set exists */
	paren_info (1).position = current_token;	/* first paren is at current token position */
	paren_info (1).begin_index = 0;		/* no comma found yet */

/* loop until matching right paren is found or end of statement */

	do j = 1 to last_token - current_token;

	     token = token_list (current_token + j).type;

/* process left parenthesis */

	     if token = left_parn then
		if paren_count >= hbound (paren_info, 1) then do;
		     call print_message (89, hbound (paren_info, 1) - bias);
						/* imp res - too many nested parens */
		     go to statement_parse_abort;
		end;
		else do;
		     paren_count = paren_count + 1;	/* stack a new set of parens */
		     paren_info (paren_count).implied_loop = FALSE;
		     paren_info (paren_count).chain = cur_paren;
						/* chain to previous left paren */
		     paren_info (paren_count).position = current_token + j;
						/* token index for left paren */
		     paren_info (paren_count).begin_index = 0;
						/* no comma found yet */

		     cur_paren = paren_count;		/* becomes current set of parens */
		end;

/* process right parenthesis */

	     else if token = right_parn then do;
		if cur_paren = 0 then do;
		     call print_message (90);		/* mismatched parens - more right parens than left */
		     go to statement_parse_abort;
		end;

		previous = paren_info (cur_paren).chain;/* save index of previous left paren */

		if paren_info (cur_paren).implied_loop then do;
		     if last_do > 0 then
			paren_info (last_do).chain = cur_paren;
						/* forward chain of do loops */
		     last_do = cur_paren;
		end;

		cur_paren = previous;		/* step to containing set of parens */

/* if we closed first paren set, return */

		if cur_paren = 0 then do;
		     if last_do > 0 then
			paren_info (last_do).chain = 0;
						/* last element of chain */

		     cur_paren = 1;			/* paren of interest is first one */
		     last_paren_parsed = current_token + j;
						/*remember how far the stmnt has been scanned */

		     if paren_count = 0 then
			return (FALSE);		/* all parens encountered are not loops */
		     return (paren_info (1).implied_loop);
		end;
	     end;

/* check for comma and assign tokens only if assign token not yet encountered */

	     else if ^paren_info (cur_paren).implied_loop then
		if token = comma then
		     paren_info (cur_paren).begin_index = current_token + j;
						/* remember last comma */

		else if token = assign then
		     if paren_info (cur_paren).begin_index ^= 0
						/* make sure comma has been encountered */
			then
			paren_info (cur_paren).implied_loop = TRUE;
		     else do;
			call print_message (91);	/* syntax error in implied loop */
			go to statement_parse_abort;
		     end;
	end;

/* loop exits here only if parens are not matched */

	call print_message (90);			/* mismatched parens - too few right parens */
	go to statement_parse_abort;
     end is_implied_loop;

parse_io_list:
     procedure;

/*	Program Specifications (parse_io_list)

     Inputs

     Output

     Description (parse_io_list)
*/

dcl      element_type bit (36) aligned;
dcl      in_list bit (1) aligned;
dcl      io_ele fixed bin (18);
dcl      last_do fixed bin (18);
dcl      need_comma bit (1) aligned;
dcl      need_element bit (1) aligned;

	if current_token < last_token then
	     io_bits.list = TRUE;
	else
	     current_token = current_token + 1;		/* current token has been parsed */

	call emit_operand (create_constant (int_mode, string (io_bits)));

	if io_bits.read then do;			/* a read statement */
	     call emit_operator (read_op);
	     element_type = input_element;
	end;
	else do;					/* a write statement */
	     call emit_operator (write_op);
	     element_type = output_element;
	end;

/* process I/O list or return */

	if io_bits.list then do;
	     if io_bits.format = namelist then
		call print_message (145, keyword_table (statement_type));
						/* list is illegal */
	end;
	else do;
	     if io_bits.mode = string_io then
		call print_message (146, keyword_table (statement_type));
						/* list is required */
	     return;
	end;

	last_paren_parsed = 0;			/* indicates no prescan has occurred */
	last_do = 0;

	in_list = TRUE;
	do while (in_list);
	     call get_next_token (force_symtab_entry, io_ele);
	     if token = left_parn then
		if is_implied_loop ()		/* Modifies paren_info, paren_count, cur_paren, last_paren_parsed */
		then do;
		     save_current_token = current_token;
		     current_token = paren_info (cur_paren).begin_index;
						/* move up to do_loop specs */
		     call get_next_token (force_symtab_entry, io_ele);

		     call parse_expression (set_reference, io_ele, out);

		     if addr (out) -> expression.subscripted_ref then
			call print_message (25, io_ele);

		     call get_next_token (force_symtab_entry, io_ele);
		     call parse_expression (any_expression, io_ele, ignore_bits);
		     if token ^= comma then
			go to missing_comma;

		     call get_next_token (force_symtab_entry, io_ele);
		     call parse_expression (any_expression, io_ele, ignore_bits);
		     if token = comma then do;
			call get_next_token (force_symtab_entry, io_ele);
			call parse_expression (any_expression, io_ele, ignore_bits);
		     end;
		     else
			call emit_operand (value_1);
		     if token ^= right_parn then
			go to missing_right_paren;

		     call emit_operator (do_op);
		     paren_info (cur_paren).position = current_token;
		     current_token = save_current_token;
		     need_element = FALSE;
		     last_do = cur_paren;
		end;
		else
		     need_element = TRUE;		/* paren is part of expression */
	     else
		need_element = TRUE;		/* obviously not an implied do loop */

	     if need_element then do;
		call parse_expression (element_type, io_ele, out);

		if addr (out) -> expression.array_name then
		     call emit_operator (xmit_array_op);
		else
		     call emit_operator (xmit_scalar_op);

		need_comma = TRUE;
		do while (need_comma & in_list);
		     if token ^= comma then
			in_list = FALSE;
		     else if last_do > 0 & current_token = paren_info (last_do).begin_index then do;
			current_token = paren_info (last_do).position;
			last_do = paren_info (last_do).chain;
			call emit_operator (exit_op);
			call get_next_token$operator; /* get comma or eos */
		     end;
		     else
			need_comma = FALSE;
		end /* item_op loop */;
	     end /* parse list element */;
	end /* list loop */;

	if last_do ^= 0 then
	     call print_message (91);			/* syntax error in implied loop */

	call emit_operator (terminate_op);
     end parse_io_list;

parse_open_field:
     procedure (field_no, expression_type);

dcl      field_no fixed bin;
declare	expression_type bit (36) aligned;
dcl      field_number fixed bin (18);
dcl      first_sym fixed bin (18);

/* parse the fields in open and possibly other i/o statments.  The field numbers of fields_specified are listed in the
   include file fortran_io_consts.  Changes must be made consistently with EP, FIO, pl1_ops, and the code generators. 
*/

	field_number = field_no;

	if substr (fields_specified, field_number, 1) = TRUE then
	     call print_message (48, substr (full_name, 1, symbol_length));

	substr (fields_specified, field_number, 1) = TRUE;

	call get_next_token$operator;
	if token ^= assign then
	     go to missing_equals_sign;

	call get_next_token (force_symtab_entry, first_sym);
	call parse_expression (expression_type, first_sym, ignore_bits);

	call emit_halfword (field_number - bias);
	call emit_operator (item_op);

	count = count + 1;
     end parse_open_field;

scan_label_list:
     procedure (build_list);

/*	Program Specifications (scan_label_list)

     Inputs

     Output

     Description (scan_label_list)
*/

dcl      count fixed bin (18);
dcl      word_offset fixed bin (18);
dcl      build_list bit (1) aligned;
dcl      in_list bit (1) aligned;
dcl      label_ptr fixed bin (18);
dcl      list_bits bit (5) aligned;

	if build_list				/* list of lbls will be emitted in polish */
	then do;
	     list_bits = GOTO_REF;			/* computed goto IS goto_ref */

	     call emit_count (word_offset);
	     count = 0;
	     call emit_operator (jump_computed_op);
	end;
	else
	     list_bits = DECLARED;			/* assigned goto is NOT goto_ref */

	in_list = TRUE;
	do while (in_list);
	     call get_next_token$label (ignore_symtab_entry, ignore_value);
	     if token ^= dec_int then
		go to missing_label;

	     label_ptr = enter_label (executable_label, (addr (work) -> based_integer), list_bits);

	     call get_next_token$operator;		/* get comma or right paren */
	     count = count + 1;
	     if token ^= comma then
		in_list = FALSE;

	     if list_bits ^= DECLARED then do;
		call emit_operand (label_ptr);
		call emit_operator (item_op);

		if ^in_list then do;
		     call emit_operator (eol_op);
		     polish_string (word_offset) = count - bias;
		end;
	     end;
	end;
	if token ^= right_parn then
	     go to missing_right_paren;

     end scan_label_list;

get_bounds:
     procedure (symb);

/*	Program Specifications (get_bounds)

     Inputs

     Output

     Description (get_bounds)

NB - An entire dimension node may not be allocated. Only enough words are allocated
for the actual number of dimensions.

	explain use of positive and negative
*/

declare	assumed_size_index fixed bin (18);
dcl      bound_error bit (1) aligned;
dcl      count fixed bin (18);
dcl      dim_node fixed bin (18);
declare	dim_size fixed bin (24);
dcl      dp pointer;
dcl      ele_cnt fixed bin (48);
declare	error_code fixed binary (35);
dcl      indx fixed bin (18);
dcl      in_list bit (1) aligned;
declare	size builtin;
dcl      symb fixed bin (18);
dcl      sp pointer;
dcl      var_bounds bit (1) aligned;

declare	1 bounds (7) aligned like dimension.dim;
declare	1 v_bounds (7) aligned like dimension.v_bound;

	count = 0;
	ele_cnt = 1;
	var_bounds = FALSE;
	assumed_size_index = 0;
	bounds = 0;
	v_bounds = ""b;

	bound_error = ^declare_symbol (symb, dim_attr, dim_conflicts, DECLARED);

	if bound_error then
	     call print_message (30, "dimension", symb);	/* redundant declaration */

	in_list = TRUE;
	do while (in_list);
	     count = count + 1;
	     if count = hbound (bounds, 1) then
		in_list = FALSE;

/* get the next declarator, check for errors.  Assume it  is upper bound, can change later if required */

	     call get_next_token (force_symtab_entry, indx);

	     if token = asterisk then
		call check_assumed_size;
	     else do;
		call get_one_bound (indx, bounds (count).upper_bound, v_bounds (count).upper, error_code);

		if error_code ^= 0 then do;
		     call print_message (169, symb);
		     bound_error = TRUE;
		end;
		else if ^v_bounds (count).upper then
		     call check_size;

	     end /* not asterisk */;

	     if token = colon then do;		/* this dimension has user defined lower bound */
		if assumed_size_index = count		/* asterisk in lower bound */
		     then
		     call print_message (167, symb);

		bounds (count).lower_bound = bounds (count).upper_bound;
		bounds (count).upper_bound = 0;
		v_bounds (count).lower = v_bounds (count).upper;
		v_bounds (count).upper = FALSE;

/* get the upper bound information and do error checking */

		call get_next_token (force_symtab_entry, indx);

		if token = asterisk then
		     call check_assumed_size;
		else do;
		     call get_one_bound (indx, bounds (count).upper_bound, v_bounds (count).upper, error_code);
		     if error_code ^= 0 then do;
			call print_message (169, symb);
			bound_error = TRUE;
		     end;
		     else if ^v_bounds (count).upper then
			call check_size;

		end /* not asterisk in upper bound */;
	     end /* token = colon */;
	     else do;

/* if no colon, the bounds we see are the upper bounds - set the lower to 1 */

		bounds (count).lower_bound = 1;
		v_bounds (count).lower = FALSE;
	     end;

/* if both bounds are not variable or assumed-size, then compute size, otherwise set var_bounds */

	     if string (v_bounds (count)) = ""b then do;
		dim_size = bounds (count).upper_bound - bounds (count).lower_bound + 1;
		if dim_size < 1			/* lower bnd > upper bnd */
		then do;
		     call print_message (168, symb);
		     bound_error = TRUE;
		     dim_size = 1;
		end;
		ele_cnt = ele_cnt * dim_size;
		bounds (count).size = dim_size;
		if ele_cnt > max_fixed_bin_24		/* prevent overflow */
		     then
		     ele_cnt = max_fixed_bin_24 + 1;
	     end;
	     else
		var_bounds = TRUE;

/* see if any other bounds */

	     if token ^= comma then
		in_list = FALSE;
	end /* do while (in_list) */;

	if token ^= right_parn then
	     go to missing_right_paren;

	call get_next_token (ignore_symtab_entry, ignore_value);

	if assumed_size_index ^= 0 then
	     if assumed_size_index ^= count		/* assumed size in non-final  dimension */
	     then do;
		call print_message (167, symb);
		bound_error = TRUE;
	     end;
	     else
		var_bounds = TRUE;

	if bound_error then
	     return;

	num_dims = count;
	dim_node = create_node (dimension_node, size (dimension));
	dp = addr (OS (dim_node));
	dp -> dimension.number_of_dims = count;
	dp -> dimension.assumed_size = (assumed_size_index ^= 0);

	sp = addr (OS (symb));
	sp -> symbol.dimension = dim_node;
	sp -> symbol.variable_extents = var_bounds;

	do i = 1 to num_dims;
	     dp -> dimension.dim (i) = bounds (i);
	     dp -> dimension.v_bound (i) = v_bounds (i);
	end;

	if ^var_bounds				/* store the element count if constant and in range */
	     then
	     if ele_cnt <= max_fixed_bin_24 then
		dp -> dimension.element_count = ele_cnt;
	     else
		call print_message (136, "length", symb, ltrim (char (max_fixed_bin_24)));
						/* array is too long */
	return;

check_assumed_size:
     procedure;
	if assumed_size_index ^= 0			/* second assumed size in this array */
	then do;
	     call print_message (167, symb);
	     bound_error = TRUE;
	end;
	else do;
	     assumed_size_index = count;
	     v_bounds (count).upper = TRUE;
	     call get_next_token$operator;
	end;
	return;
     end check_assumed_size;

check_size:
     procedure;

	if abs (bounds (count).upper_bound) > max_fixed_bin_24 then do;
	     call print_message (136, "magnitude of an array bound", symb, ltrim (char (max_fixed_bin_24)));
	     if bounds (count).upper_bound > 0 then
		bounds (count).upper_bound = max_fixed_bin_24;
	     else
		bounds (count).upper_bound = -max_fixed_bin_24;
	end;
     end check_size;

get_one_bound:
     procedure (indx, bound, bound_is_variable, err_code);

/* Parse one bound of an array declaration and, if the syntax of the bound
   is correct (i.e. is an arithmetic expression of integer constants and
   scalar variables), return either the value of the bound (if constant) or
   the index of a symbol for the value of the bound.  If the bound is not
   a constant or a constant expression, an anonymous automatic integer
   variable is created to hold the value of the bound, unless the bound
   is a scalar variable and we are in '66 mode, in which case we just use
   the variable.  If we create a variable to hold the bound, the index of
   the Polish to initialize it is stored in the 'initial' field of its
   symbol node.  This Polish is preceded by an 'increment_polish' operator
   to "hide" it from the code generator.  The 'process_pending_entries'
   routine is responsible for generating the assignment to initialize a
   compiler generated array bound variable at the appropriate point in
   the entry sequence. */

dcl      indx fixed bin (18),				/* INPUT: index of initial symbol in expression */
         bound fixed bin (24),			/* OUTPUT: if bound is constant then its value else indx of its symbol */
         bound_is_variable bit (1),			/* OUTPUT: "1"b if bound is not constant */
         err_code fixed binary (35);			/* OUTPUT: error code */

dcl      Invalid_operand fixed bin (35) static options (constant) init (1),
         Invalid_operator fixed bin (35) static options (constant) init (2);

dcl      idx_of_expression fixed bin (18),
         idx_of_increment_polish_op fixed bin (18),
         opnd_ptr ptr,
         polish_idx fixed bin (18);


	idx_of_increment_polish_op = next_free_polish;
	call increment_polish (2);
	idx_of_expression = next_free_polish;
	call parse_expression (set_no_symbol_bits, indx, out);

	err_code = 0;
	do polish_idx = idx_of_expression to next_free_polish - 1 while (err_code = 0);
	     if polish_string (polish_idx) > last_assigned_op then do;
						/* Found an operand; check if it is valid. */
		opnd_ptr = addr (OS (polish_string (polish_idx)));
		if opnd_ptr -> node.data_type ^= 0 then
		     if opnd_ptr -> node.data_type ^= int_mode then
			err_code = Invalid_operand;
	     end;
	     else if polish_string (polish_idx) < add_op | polish_string (polish_idx) > negate_op then
		err_code = Invalid_operator;
	end;

	bound = 0;
	bound_is_variable = addr (out) -> expression.not_constant;
	if err_code ^= 0 then
	     next_free_polish = idx_of_increment_polish_op;
	else if bound_is_variable then
	     if next_free_polish > idx_of_expression + 1 | subr_options.ansi_77 then do;
						/* Generate an anonymous variable to receive the bound. */
		bound = build_symbol ((NO_NAME), v_length_attributes, SET);
		addr (OS (bound)) -> symbol.initial = idx_of_expression;
		polish_string (idx_of_increment_polish_op + 1) = next_free_polish - idx_of_expression;
	     end;
	     else do;				/* Use the scalar variable as the bound. */
		bound = indx;
		next_free_polish = idx_of_increment_polish_op;
	     end;
	else if next_free_polish > idx_of_expression + 1
	     | addr (OS (polish_string (idx_of_expression))) -> constant.data_type ^= int_mode then do;
						/* Reduce the expression to an integer value. */
	     parameter_info.desired_data_type = int_mode;
	     parameter_info.max_stack = max_stack;
	     parameter_info.stack_index = stack_index;
	     parameter_info.start_of_polish = idx_of_expression;
	     parameter_info.end_of_polish = next_free_polish - 1;
	     parameter_info.rounding = subr_options.do_rounding;

	     call fort_eval_parm (addr (parameter_info), "an integer constant expression", err_code);
	     max_stack = parameter_info.max_stack;

	     if err_code = 0 then
		unspec (bound) = addr (OS (parameter_info.result_location)) -> constant.value;
	     next_free_polish = idx_of_increment_polish_op;
	end;
	else do;					/* Use the integer value as the bound. */
	     unspec (bound) = addr (OS (polish_string (idx_of_expression))) -> constant.value;
	     next_free_polish = idx_of_increment_polish_op;
	end;

     end get_one_bound;
     end get_bounds;

get_integer_constant:
     procedure (indx, allow_variables, value, variable_found, err_code);
declare	indx fixed bin (18);			/* INPUT: index of initial symbol in expression */
declare	allow_variables bit (1);			/* INPUT: "1"b iff scalar integer expressions permitted */
declare	value fixed bin (24);			/* OUTPUT: value or (symbol index, if variable_found set) */
declare	variable_found bit (1);			/* OUTPUT: "1"b if non-constant found and allowed */
declare	err_code fixed binary (35);			/* OUTPUT: error code */

declare	sp pointer;
declare	ILLEGAL_EXPRESSION_FOUND fixed binary (35) internal static options (constant) initial (1);


/* parses the next expression in the input stream, usually searching for integer constants or constant expressions which
   it converts to constants via fort_eval_parm.  Optionally allows scalars integer variables as well, 
   and if permitted and found, it sets variable_found TRUE.   
*/
	variable_found = FALSE;
	err_code = 0;

	parameter_info.start_of_polish = next_free_polish;

	call parse_expression (set_no_symbol_bits, indx, out);

/* result can be either constant expression or simple scalar variable.
   if it is not a simple_ref
   then if not constant, it is a  error
        else it's a constant expression
	 if only one operand and it is an integer constant
	 then simply get its value.
	 else it is a constant expression of more than term
	      call fort_eval_parm to get its value.
   else its a simple ref
        cant be a substr or subscripted ref
        must be a simple variable.
*/

	if addr (out) -> expression.not_simple_ref then do;
	     if addr (out) -> expression.not_constant then
		err_code = ILLEGAL_EXPRESSION_FOUND;

	     else do;				/* constant expression */
		sp = addr (OS (polish_string (parameter_info.start_of_polish)));

/* if bound is a single integer constant simply gets its value */

		if next_free_polish = parameter_info.start_of_polish + 1 & sp -> constant.data_type = int_mode then
		     unspec (value) = sp -> constant.value;
		else do;
		     parameter_info.desired_data_type = int_mode;
		     parameter_info.max_stack = max_stack;
		     parameter_info.stack_index = stack_index;
		     parameter_info.end_of_polish = next_free_polish - 1;
		     parameter_info.rounding = subr_options.do_rounding;

		     call fort_eval_parm (addr (parameter_info), "an integer constant expression", err_code);
		     max_stack = parameter_info.max_stack;

		     if err_code = 0 then
			unspec (value) = addr (OS (parameter_info.result_location)) -> constant.value;
		end /* complex constant expression */;
	     end /* constant expression */;
	end /* not simple reference */;
	else do;					/* simple reference */
	     if addr (out) -> expression.substring_ref | addr (out) -> expression.subscripted_ref
						/* must be scalar ref */
		then
		err_code = ILLEGAL_EXPRESSION_FOUND;
	     else do;
		variable_found = TRUE;
		if allow_variables then
		     value = indx;
		else
		     err_code = ILLEGAL_EXPRESSION_FOUND;
	     end;
	end;
	next_free_polish = parameter_info.start_of_polish;

     end get_integer_constant;

stack_operand:
stack_operator:
     procedure (op_code_or_operand);

dcl      op_code_or_operand fixed bin (18);

	if stack_index > hbound (stack, 1) then
	     call print_message (67, "stack", hbound (stack, 1) - bias);
						/* stack overflow */
	stack (stack_index) = op_code_or_operand;
	stack_index = stack_index + 1;
	max_stack = max (stack_index, max_stack);
     end stack_operator;

build_symbol:
     procedure (name, attributes, storage_bits) returns (fixed bin (18));

dcl      name char (256) varying;
dcl      attributes bit (47) aligned;
dcl      storage_bits bit (5) aligned;
dcl      sym_indx fixed bin (18);
dcl      sym_ptr pointer;
dcl      count_pic picture "9999";

	allocate_symbol_name = length (name);
	sym_indx = create_node (symbol_node, size (symbol));
	sym_ptr = addr (OS (sym_indx));

	if sub_ptr -> last_symbol = 0 then
	     sub_ptr -> first_symbol = sym_indx;
	else
	     addr (OS (sub_ptr -> last_symbol)) -> symbol.next_symbol = sym_indx;
	sub_ptr -> last_symbol = sym_indx;

	unspec (sym_ptr -> symbol.attributes) = attributes;
	string (sym_ptr -> symbol.storage_info) = storage_bits;
	sym_ptr -> symbol.by_compiler = TRUE;		/* indicate declared by compiler */

	sym_ptr -> symbol.name_length = allocate_symbol_name;

	if substr (name, 1, length (NO_NAME)) = NO_NAME then do;
	     substr (sym_ptr -> symbol.name, 1, 4) = "ftn.";
	     cp_count = cp_count + 1;
	     count_pic = cp_count;
	     substr (sym_ptr -> symbol.name, 5, 4) = count_pic;
	end;
	else
	     substr (sym_ptr -> symbol.name, 1, allocate_symbol_name) = name;

	if produce_listing then
	     call generate_cross_ref (sym_indx);

	return (sym_indx);
     end build_symbol;

/* 08 Mar 86, SH - 410: The bif_table.external has been updated. This table
                        defines the validity of builtins for use as external
                        entry references.*/
builtin_lookup:
     procedure (indx, set_attributes) returns (bit (1) aligned);

dcl      bif_dt fixed bin (18);
dcl      bif_name char (8) aligned;
dcl      bif_ptr pointer;
dcl      i fixed bin (18);
dcl      indx fixed bin (18);
dcl      lower fixed bin (18);
dcl      not_found bit (1) aligned;
dcl      set_attributes bit (1);
dcl      upper fixed bin (18);

/* format: off */

dcl	1 bif_table	(95) aligned int static options (constant),
	  2 name		char (8) aligned init (
			"abs     ", "acos    ", "aimag   ", "aint    ", "alog    ", "alog10  ", "amax0   ", "amax1   ",
			"amin0   ", "amin1   ", "amod    ", "and     ", "anint   ", "asin    ", "atan    ", "atan2   ",
			"bool    ", "cabs    ", "ccos    ", "cexp    ", "char    ", "clog    ", "cmplx   ", "compl   ",
			"conjg   ", "cos     ", "cosh    ", "csin    ", "csqrt   ", "dabs    ", "dacos   ", "dasin   ",
			"datan   ", "datan2  ", "dble    ", "dcos    ", "dcosh   ", "ddim    ", "dexp    ", "dim     ",
			"dint    ", "dlog    ", "dlog10  ", "dmax1   ", "dmin1   ", "dmod    ", "dnint   ", "dprod   ",
			"dsign   ", "dsin    ", "dsinh   ", "dsqrt   ", "dtan    ", "dtanh   ", "exp     ", "fld     ",
			"float   ", "iabs    ", "ichar   ", "idim    ", "idint   ", "idnint  ", "ifix    ", "ilr     ",
			"ils     ", "index   ", "int     ", "irl     ", "irs     ", "isign   ", "len     ", "lge     ",
			"lgt     ", "lle     ", "llt     ", "log     ", "log10   ", "max     ", "max0    ", "max1    ",
			"min     ", "min0    ", "min1    ", "mod     ", "nint    ", "or      ", "real    ", "sign    ",
			"sin     ", "sinh    ", "sngl    ", "sqrt    ", "tan     ", "tanh    ", "xor     "),
	  2 external	bit (1) unaligned init (
			"1"b, "1"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b,
			"0"b, "0"b, "1"b, "0"b, "1"b, "1"b, "1"b, "1"b,
			"0"b, "1"b, "1"b, "1"b, "0"b, "1"b, "0"b, "0"b,
			"1"b, "1"b, "1"b, "1"b, "1"b, "1"b, "1"b, "1"b,
			"1"b, "1"b, "0"b, "1"b, "1"b, "1"b, "1"b, "1"b,
			"1"b, "1"b, "1"b, "0"b, "0"b, "1"b, "1"b, "1"b,
			"1"b, "1"b, "1"b, "1"b, "1"b, "1"b, "1"b, "0"b,
			"0"b, "1"b, "0"b, "1"b, "0"b, "1"b, "0"b, "1"b,
			"1"b, "1"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b,
			"0"b, "0"b, "0"b, "1"b, "1"b, "0"b, "0"b, "0"b,
			"0"b, "0"b, "0"b, "1"b, "1"b, "0"b, "0"b, "1"b,
			"1"b, "1"b, "0"b, "1"b, "1"b, "1"b, "0"b),
	  2 pad		bit (3) unaligned init ((95) (3)"0"b),
	  2 data_type	fixed bin (4) unaligned init (
			0, 0, 2, 0, 0, 0, 2, 2,
			2, 2, 2, 7, 0, 0, 0, 0,
			7, 2, 4, 4, 6, 4, 4, 7,
			4, 0, 0, 4, 4, 3, 3, 3,
			3, 3, 3, 3, 3, 3, 3, 2,
			3, 3, 3, 3, 3, 3, 3, 3,
			3, 3, 3, 3, 3, 3, 0, 7,
			2, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 5,
			5, 5, 5, 0, 0, 0, 1, 1,
			0, 1, 1, 0, 0, 7, 2, 2,
			0, 0, 2, 0, 0, 0, 7),
	  2 index		fixed bin (8) unaligned init (
			001, 063, 055, 049, 005, 008, 024, 025,
			030, 031, 036, 084, 079, 061, 010, 012,
			085, 004, 016, 022, 065, 007, 057, 086,
			058, 014, 073, 043, 046, 003, 064, 062,
			011, 013,	056, 015, 075, 019, 021, 017,
			078, 006,	009, 028, 034, 037, 080, 083,
			040, 042,	076, 045, 060, 077, 020, 087,
			051, 002, 066, 018, 050, 082, 052, 088,
			089, 067, 048, 090, 091, 039, 068, 069,
			070, 071, 072, 005, 008, 023, 026, 027,
			029, 032, 033, 035, 081, 092, 054, 038,
			041, 074, 053, 044, 059, 047, 093);

/* format: revert */

	bif_ptr = addr (OS (indx));

	if bif_ptr -> symbol.builtin then
	     return (TRUE);
	else if bif_ptr -> symbol.external then
	     return (FALSE);

	if (unspec (bif_ptr -> symbol.attributes) & bif_conflicts) ^= ZERO then
	     return (FALSE);

	if bif_ptr -> symbol.name_length > length (bif_name) then
	     return (FALSE);
	bif_name = bif_ptr -> symbol.name;
	i = 1;
	lower = 1;
	upper = hbound (bif_table, 1);

	not_found = TRUE;
	do while (not_found);
	     if bif_name = bif_table (i).name then
		not_found = FALSE;
	     else do;
		if bif_name < bif_table (i).name then do;
		     upper = i;
		     i = i - divide (upper - lower + 1, 2, 17, 0);
		end;
		else do;
		     lower = i;
		     i = i + divide (upper - lower + 1, 2, 17, 0);
		end;
		if i = lower then
		     return (FALSE);
	     end;
	end;

	bif_dt = bif_table (i).data_type;

	if bif_dt ^= 0 then
	     if unspec (bif_ptr -> symbol.mode_bits) ^= ZERO then
		if (unspec (bif_ptr -> symbol.attributes) & attr_table (bif_dt)) = ZERO then
		     return (FALSE);		/* Data types differ. */

	if bif_ptr -> symbol.referenced then do;
	     call print_message (93, indx);		/* cannot become a bif */
	     return (FALSE);
	end;

/* symbol.char_size holds the number of the builtin */

	if (set_attributes) then do;
	     bif_ptr -> symbol.char_size = bif_table (i).index;
	     bif_ptr -> symbol.builtin = TRUE;
	     bif_ptr -> symbol.external = bif_table (i).external;
	     if unspec (bif_ptr -> symbol.mode_bits) = ZERO then
		unspec (bif_ptr -> symbol.attributes) = unspec (bif_ptr -> symbol.attributes) | attr_table (bif_dt);
	end;

	return (TRUE);
     end builtin_lookup;

parse_expression:
     procedure (control_bits, save_index, return_bits);	/* Not audited. */

/*	Program Specifications (parse_expr)

     Inputs

     Output

     Description (parse_expr)


		 left right
	operator	 prec  prec  type  op_code

	0. BOE	   0    -1   -	  0
	1. +	  60    60   both	  2
	2. -	  60    60   both	  3
	3. *	  70    70   infix	  4
	4. /	  70    70   infix	  5
	5. **	  90   100   infix	  6
	6. not	  30    30   prefix	  16
	7. and	  20    20   infix	  15
	8. or	  10    10   infix	  14
	9. eq	  40    40   infix	  10
	10. ne	  40    40   infix	  11
	11. lt	  40    40   infix	  8
	12. gt	  40    40   infix	  13
	13. le	  40    40   infix	  9
	14. ge	  40    40   infix	  12
	15. =	  -1     0   -	  0
	16. ,	  -1     0   -	  0
	17. (	   0    -1   prefix	  0
	18. )	  -1     0   -	  0
	19. '	  -1     0   -	  0
	20. :	  -1     0   -        0
	21. //	  50    50   infix    96
	22. substr  -1     0   -        0
	 left_parn
	23. eqv	   0     0   infix    103
	24. neqv	   0     0   infix	  104
	25.	   0     0   not used
	26.	   0     0   not used
	27.	   0     0   not used
	28.	   0     0   not used
	29.	   0     0   not used
	30.	   0     0   not used
	31.	   0     0   not used
	32.	   0     0   not used
	33.	   0     0   not used
	34. negate  80    -1   prefix	   7
*/

dcl      BOE fixed bin (18) int static options (constant) init (0);
dcl      concat_op fixed bin (18) int static options (constant) init (23);
dcl      control_bits bit (36) aligned;
dcl      count fixed bin (18);
dcl      expr bit (36) aligned;
dcl      expon_op fixed bin (18) int static options (constant) init (5);
dcl      have_operand bit (1) aligned;
dcl      header_storage bit (5) unaligned defined (addr (OS (sp -> symbol.parent)) -> header.storage_info);
dcl      in_expr bit (1) aligned;
dcl      indx fixed bin (18);
dcl      is_infix bit (2) aligned int static options (constant) init ("10"b);
dcl      is_prefix bit (2) aligned int static options (constant) init ("01"b);
dcl      left_parenthesis fixed bin (18) int static options (constant) init (10001b);
dcl      may_need_descriptors bit (1);			/* true if may need descriptors */
dcl      negate_token fixed bin (18) int static options (constant) init (34);
dcl      new_state bit (36) aligned;
dcl      not_token fixed bin (18) int static options (constant) init (00110b);
dcl      opc fixed bin;
dcl      pop_stack bit (1) aligned;
dcl      return_bits bit (36) aligned;
dcl      save_index fixed bin (18);
declare	set_storage bit (1) aligned;
dcl      sp pointer;
dcl      subs_or_arg_list fixed bin (18) int static options (constant) init (32);
dcl      substr_paren fixed bin (18) int static options (constant) init (33);
dcl      symbol_storage bit (5) unaligned defined (sp -> symbol.storage_info);
dcl      token_prec fixed bin (18);
dcl      top fixed bin (18);
dcl      tkn fixed bin (18);
dcl      word_offset fixed bin (18);


/* Precedence table initializations */

dcl      lprec (0:34) fixed bin (18) int static options (constant)
	    init (0, 60, 60, 70, 70, 90, 30, 20, 10, (6) 40, (2) - 1, 0, (3) - 1, 50, -1, (2) 5, (9) 0, 80);
dcl      rprec (0:34) fixed bin (18) int static options (constant)
	    init (-1, 60, 60, 70, 70, 100, 30, 20, 10, (6) 40, (2) 0, -1, (3) 0, 50, 0, (2) 5, (7) 0, (3) - 1);
dcl      op_code (0:34) fixed bin (18) int static options (constant)
	    init (0, 2, 3, 4, 5, 6, 16, 15, 14, 10, 11, 8, 13, 9, 12, (6) 0, 96, 0, 103, 104, (9) 0, 7);
dcl      t_type (0:34) bit (2) aligned int static options (constant)
	    init ("0"b, (2) (2)"1"b, (3) (1)"10"b, "01"b, (8) (1)"10"b, (2) (2)"0"b, "01"b, (3) (2)"0"b, "10"b, "00"b,
	    (2) (1)"10"b, (9) (2)"0"b, "01"b);

/* Expression parsing begins here. */

	top = BOE;				/* Prime the top of stack. */
	word_offset = 0;				/* Current symbol does not have a list. */
	count = 0;				/* Therefore list has zero items. */

	expr = control_bits;			/* Copy initial state from input arg. */
	symbol_index = save_index;			/* Copy initial symbol ptr from input arg. */
	set_storage = control_bits ^= set_no_symbol_bits; /* Flag indicates handling of symbol node */

/* EXPRESSION LOOP. Exited when expression is completely parsed. */

	have_operand = FALSE;
	in_expr = TRUE;
	do while (in_expr);

/* OPERAND LOOP. Exited after one opnd, and any prefix operators and left parens, have been parsed. */

	     do while (^have_operand);

/* Stack any prefix operators and left parens which precede the operand. */

		do while (token & is_operator);

/*	Recognition of complex tokens was moved from the lexical analyzer to the
			expression parser on 78.04.07, by David Levin. */

		     if token = left_parn then
			if is_complex_constant (symbol_index) then
			     go to have_constant;

		     tkn = binary (substr (token, 5, 5), 5, 0);

		     if (t_type (tkn) & is_prefix) = ZERO then do;
			call print_message (94, err_string ());
			go to statement_parse_abort;
		     end;

		     if addr (expr) -> expression.set	/* expr in set reference */
			then
			if token = left_parn then
			     call print_message (95, "A redundant parenthesis was encountered. ");
			else
			     call print_message (95);
		     else
			;
		     addr (expr) -> expression.not_simple_ref = TRUE;

		     if token ^= plus		/* No need to stack prefix plus. */
		     then do;
			call stack_operator (top);	/* Stack the old one. */
			if token = minus then
			     top = negate_token;	/* Prefix minus is negate. */

			else if token = not then
			     top = not_token;

			else
			     top = tkn;		/* The rest are what they seem. */
		     end;

		     call get_next_token (force_symtab_entry, symbol_index);
						/* Get token after prefix. */
		end;

/* Prefix operators and left parens are parsed. Now there must be an operand. */

		if token & is_constant		/* All constants. */
		then do;
have_constant:
		     if addr (expr) -> expression.set then
			call print_message (95);	/* constant in set reference */

		     if named_constant_ptr_valid then do;
			sp = named_constant_ptr;
			symbol_storage = symbol_storage | string (addr (expr) -> expression.storage_info);
		     end;
		     call emit_operand (symbol_index);	/* Put constant into polish string. */

		     call get_next_token$operator;	/* Get binary opr or end of expr. */
		     tkn = binary (substr (token, 5, 5), 5, 0);

		     call determine_complexity;	/*  sets not_simple_ref, passed_as_arg, and have_operand */
		     addr (expr) -> expression.not_simple_ref = TRUE;
						/* constant is never simple ref */

		     if addr (expr) -> expression.passed_as_arg
						/* constant is passed as arg */
			then
			addr (OS (symbol_index)) -> constant.passed_as_arg = TRUE;
		end;

		else if token = ident		/* Otherwise, it could be an identifier. */
		then do;
		     addr (expr) -> expression.not_constant = TRUE;
		     indx = symbol_index;		/* freeze index to the symbol. */
		     sp = addr (OS (indx));		/* Pointer to the symbol node. */

		     if addr (expr) -> expression.needs_descriptors = "1"b
			| (sp -> node.node_type = symbol_node & sp -> symbol.mode.character = "1"b
			& addr (expr) -> expression.passed_as_arg = "1"b) then
			may_need_descriptors = "1"b;
		     else
			may_need_descriptors = "0"b;

		     call get_next_token$paren_operator;/* Get left paren, bin opr, or end of expr. */

		     if token = left_parn | token = substr_left_parn
						/* Subscripted ref or some kind of func ref. */
		     then do;

/* Determine the semantics of this reference. */

			if token = substr_left_parn then do;
						/* better be substring */
			     if sp -> symbol.dimensioned & ^addr (expr) -> expression.subscripted_ref then
				call print_message (155, indx,
				     "Substring may only be applied to simple variables or array elements");
						/* can't substr an array */

			     if (unspec (sp -> symbol.attributes) & scalar_conflicts) = ZERO
						/* simple ref */
				then
				if set_storage then
				     sp -> symbol.variable = TRUE;
						/* Symbol must remain a variable */

			     new_state = any_expression;
			     opc = substr_op;
			end;

			else if sp -> symbol.dimensioned then do;
						/* Subscripted reference. */
			     addr (expr) -> expression.subscripted_ref = TRUE;
			     new_state = any_expression;
			     opc = subscript_op;
			end;

/* if not dimensioned, Then some sort of func ref */

			else if sp -> symbol.external & sp -> symbol.function then do;
						/* External function reference. */
			     addr (expr) -> expression.not_simple_ref = TRUE;

			     if addr (expr) -> expression.set then
				call print_message (96, indx);

			     if sp -> symbol.needs_descriptors then
				new_state = darg_list_expr;
			     else
				new_state = arg_list_expr;

			     opc = func_ref_op;
			end;

			else if sp -> symbol.stmnt_func then do;
						/* st func reference. */
			     addr (expr) -> expression.not_simple_ref = TRUE;

			     if addr (expr) -> expression.set then
				call print_message (96, indx);

			     new_state = any_expression;
			     opc = sf_op;
			end;

			else if builtin_lookup (indx, SET_ATTR) then do;
						/* builtin func reference. */
			     addr (expr) -> expression.not_simple_ref = TRUE;
						/* fld is the only bif that can be used in a set reference */

			     if addr (expr) -> expression.set & addr (OS (indx)) -> symbol.name ^= "fld" then
				call print_message (96, indx);

			     new_state = any_expression;
			     opc = builtin_op;
			end;

			else do;			/* Anything else must become an external func ref. */
			     if (unspec (sp -> symbol.attributes) & func_conflicts) = ZERO then do;
				if set_storage then
				     unspec (sp -> symbol.attributes) =
					unspec (sp -> symbol.attributes) | func_ref_attribute;
			     end;
			     else
				call print_message (97, indx);
						/* cannot be ext func */

			     addr (expr) -> expression.not_simple_ref = TRUE;

			     if addr (expr) -> expression.set then
				call print_message (96, indx);

			     if sp -> symbol.needs_descriptors then
				new_state = darg_list_expr;
			     else
				new_state = arg_list_expr;

			     opc = func_ref_op;
			end;

/* Stack the current expression state. State will be restored after correct right paren encountered. */

			call emit_operand (indx);
substring_of_array_ref:
			call stack_operator (top);	/* Stack previous operator. */
			call stack_operator ((addr (expr) -> based_integer));
						/* Stack state */
			call stack_operator (count);
			if opc = substr_op then do;
			     call stack_operator (indx);
			     top = substr_paren;
			     if ^subr_options.ansi_77 then
				call print_message (154);
			end;
			else do;
			     top = subs_or_arg_list;
			     call stack_operator (word_offset);
			end;

			expr = new_state;

/* Emit correct polish. */
			if opc ^= substr_op then do;
			     call emit_count (word_offset);
			     call emit_operator ((opc));
			end;
			count = 0;		/* Local copy of item count. */

			call get_next_token (force_symtab_entry, symbol_index);
						/* Get beginning of first item or right paren. */

			if token = right_parn	/* func ref with no args. */
			then do;
			     call process_eol;
			     call get_next_token$operator;
						/* get binary opr or end of expr */
			end;

			else if token = colon	/* substring, no start given */
			then do;
			     count = count + 1;

			     call get_next_token (force_symtab_entry, symbol_index);

			     if token = right_parn	/* (:)--just ignore it */
			     then do;
				have_operand = TRUE;
				call process_end_of_substr;
				call get_next_token$operator;
			     end;

			     else
				call emit_operand (value_1);
						/* otherwise, beginning is implicitly 1 */
			end;

		     end;				/* SUBSCRIPTED REF or FUNCTION REF */

		     else do;

/* ident without left_parn */
			tkn = binary (substr (token, 5, 5), 5, 0);
						/* gives context */
			call determine_complexity;	/*  sets not_simple_ref, passed_as_arg, and have_operand */

			if set_storage then do;

/* determine the semantics */
			     if sp -> symbol.function & sp -> symbol.entry_point then do;
						/* LINK  ENTRY TO return_value */
				indx = return_value;
				sp = addr (OS (indx));
			     end;

			     if (unspec (sp -> symbol.attributes) & scalar_conflicts) = ZERO
						/* simple ref */
			     then do;
				sp -> symbol.variable = TRUE;

/* If star extent automatic, then it will not get picked up by declaration
   processor, entry argument processing to set the needs descriptors.  Therefore
   we must set it when we know the reference. */

				if sp -> symbol.star_extents & may_need_descriptors then
				     sp -> symbol.needs_descriptors = "1"b;
			     end;			/* Symbol must remain a variable */

			     else if sp -> symbol.dimensioned
						/* array name ref */
			     then do;
				if may_need_descriptors
				     & (sp -> symbol.variable_extents | sp -> symbol.star_extents) then
				     sp -> symbol.needs_descriptors = TRUE;

				addr (expr) -> expression.array_name = TRUE;

				if ^addr (expr) -> expression.allow_array_name
				     | addr (expr) -> expression.not_simple_ref then
				     call print_message (98, indx);
						/* array name is illegal */
				if addr (expr) -> expression.no_assumed_size_array then
				     if addr (OS (sp -> symbol.dimension)) -> dimension.assumed_size then
					call print_message (166, keyword_table (statement_type));
			     end;

			     else if sp -> symbol.external | sp -> symbol.builtin
						/* entry value in arg list */
			     then do;
				if ^addr (expr) -> expression.passed_as_arg then
				     call print_message (99, indx);
						/* illegal use of entry value */
				if ^sp -> symbol.external then
				     call print_message (461, indx);
						/* Not a passable intrinsic */
				addr (expr) -> expression.not_simple_ref = TRUE;

				if (unspec (sp -> symbol.attributes) & entry_value_conflicts) = ZERO then
				     unspec (sp -> symbol.attributes) =
					unspec (sp -> symbol.attributes) | entry_value;
				else
				     call print_message (99, indx);
			     end;

			     else
				call print_message (100, indx);
						/* ref is in wrong context */

			     call set_storage_bits;

			end /* set_storage */;
			call emit_operand (indx);
		     end;
		end /* ident */;
		else do;
		     call print_message (94, err_string ());
		     go to statement_parse_abort;	/* missing operand */
		end;
	     end /* looking for operand */;

/* Now parse one binary operator or the end of the expression. Then check precedence. */

	     if (token & is_operator) = ZERO		/* Token must be an operator. */
	     then do;
		call print_message (101, err_string ());
		go to statement_parse_abort;		/* missing operator */
	     end;

	     if t_type (tkn) = is_prefix		/* Must be infix operator. */
	     then do;
		call print_message (101, err_string ());
		go to statement_parse_abort;		/* missing operator */
	     end;

	     if addr (expr) -> expression.set then
		if (t_type (tkn) & is_infix) ^= ZERO then
		     call print_message (95);		/* expr in set reference */

	     have_operand = FALSE;			/* Must have operand if not end of expression. */

/* Unstack operators as long as the current token has lower or equal precedence. */

	     token_prec = rprec (tkn);		/* right precedence for the token */

	     pop_stack = lprec (top) >= token_prec;
	     do while (pop_stack);

/* If stack contains executable ops, start emitting them. */

		if op_code (top) ^= 0		/* All executable operators. */
		then do;
		     call emit_operator ((op_code (top)));
		     stack_index = stack_index - 1;	/* Get the previous operator from stack. */
		     top = stack (stack_index);
		     pop_stack = lprec (top) >= token_prec;
		end;

/* Otherwise, end of expr, end of subs or arg list, end of parenthesized expr, or error. */

		else do;
		     pop_stack = FALSE;		/* No iteration possible. */
		     if top = BOE			/* If we're here, we're done. */
			then
			in_expr = FALSE;

		     else if top = left_parenthesis & token = right_parn
						/* Eliminate pair of parens. */
		     then do;
			stack_index = stack_index - 1;/* Get the previous operator from stack. */
			top = stack (stack_index);
			tkn = binary (substr (token_list (current_token + 1).type, 5, 5), 5, 0);
			have_operand = TRUE;
		     end;

		     else if top = subs_or_arg_list & (token = right_parn | token = comma) then do;
			count = count + 1;

			call emit_operator (item_op);

			if token = right_parn then do;
			     call process_eol;
			     if token_list (current_token + 1).type = left_parn then do;
				call get_next_token$paren_operator;
				if token ^= substr_left_parn then do;
				     call print_message (101, err_string ());
				     go to statement_parse_abort;
				end;
				have_operand = FALSE;
				opc = substr_op;
				addr (expr) -> expression.substring_ref = TRUE;
				new_state = any_expression;
				if sp -> symbol.attributes.mode.character then
				     go to substring_of_array_ref;
				else do;
				     call print_message (102, err_string ());
				     go to statement_parse_abort;
				end;
			     end;
			end;			/* End of list. */

			else do;			/* Get next expression. */
			     unspec (addr (expr) -> expression.not_scalar_ref) = ZERO;

			     if addr (expr) -> expression.reset_arg_bit then
				addr (expr) -> expression.passed_as_arg = TRUE;
			end;
		     end;

		     else if top = substr_paren & token = colon then do;
			count = count + 1;
			if count ^= 1 then do;
			     call print_message (102, err_string ());
			     go to statement_parse_abort;
			end;

			unspec (addr (expr) -> expression.not_scalar_ref) = ZERO;

			if token_list (current_token + 1).type = right_parn then do;
			     call get_next_token$operator;

/* recover index of string symbol from stacked expression */

			     indx = stack (stack_index - 1);
			     call emit_operand (get_char_length (force_symtab_entry, (indx)));
			     call process_end_of_substr;
			end;
		     end;

		     else if top = substr_paren & token = right_parn then do;
			if count ^= 1 then do;
			     call print_message (102, err_string ());
			     goto statement_parse_abort;
			end;
			call process_end_of_substr;
		     end;

		     else do;
			call print_message (102, err_string ());
						/* comma out of place */
			go to statement_parse_abort;
		     end;
		end;
	     end /* unstack loop */;

/* Stack the current operator if it is not the end of the expression. */

	     if token_prec > 0 then do;
		if top = expon_op & tkn = expon_op then
		     call print_message (144);
		call stack_operator (top);		/* Stack previous operator. */
		top = tkn;
		addr (expr) -> expression.not_simple_ref = TRUE;
	     end;

/* The test for concat in non-ansi77 subr moved to the code generator or
   converter ...  */
/* if tkn = concat_op & ^subr_options.ansi_77
	     then call print_message (153);     */


	     if in_expr then
		call get_next_token (force_symtab_entry, symbol_index);
	end /* expression loop */;

	return_bits = expr;				/* return final expression status */
	return;


determine_complexity:
     procedure;					/* check for binary operators and sets have_operand */
						/* also sets expr.not_simple_ref and expr.passed_as_arg */
	have_operand = TRUE;			/* binary opr or end of expr must follow */

	if t_type (tkn) & is_infix then
	     addr (expr) -> expression.not_simple_ref = TRUE;
						/* Is ref part of expr? */

	if addr (expr) -> expression.not_simple_ref then
	     addr (expr) -> expression.passed_as_arg = FALSE;
						/* argument only if not expr. */
     end determine_complexity;


process_eol:
     procedure;

	unspec (expr) = unspec (stack (stack_index - 3)); /* Restore expression status bits. */

	indx = polish_string (word_offset - 1);		/* Restore pointer to owner of this list. */
	sp = addr (OS (indx));			/* ditto. */

	call emit_operator (eol_op);

	if count > 0 then do;
	     if count > max_arglist - 1		/* must leave room for return value */
		then
		call print_message (138, max_arglist - 1 - bias, indx);

	     polish_string (word_offset) = count - bias;	/* Store list count in polish. */
	end;

	tkn = binary (substr (token_list (current_token + 1).type, 5, 5), 5, 0);
						/* gives context */
	call determine_complexity;			/*  sets not_simple_ref, passed_as_arg, and have_operand */

	if set_storage then
	     call set_storage_bits;

	word_offset = stack (stack_index - 1);		/* Restore list info for containing list. */
	count = stack (stack_index - 2);
	stack_index = stack_index - 4;		/* Remove this list from the stack and get prev opr. */
	top = stack (stack_index);
     end process_eol;
process_end_of_substr:
     procedure;

	unspec (expr) = unspec (stack (stack_index - 3));

	if ^have_operand then do;
	     have_operand = TRUE;
	     call emit_operator (substr_op);
	     addr (expr) -> expression.substring_ref = TRUE;
	end;

	top = stack (stack_index - 4);
	count = stack (stack_index - 2);
	indx = stack (stack_index - 1);
	sp = addr (OS (indx));
	if set_storage then
	     call set_storage_bits;
	stack_index = stack_index - 4;

	tkn = binary (substr (token_list (current_token + 1).type, 5, 5), 5, 0);

	return;
     end process_end_of_substr;
set_storage_bits:
     procedure;

	symbol_storage = symbol_storage | string (addr (expr) -> expression.storage_info);
	if sp -> symbol.equivalenced then
	     if sp -> symbol.parent > 0 then
		header_storage = header_storage | string (addr (expr) -> expression.storage_info);

	return;
     end set_storage_bits;
     end parse_expression;

is_complex_constant:
     procedure (complex_constant_offset) returns (bit (1) aligned);

dcl      complex_constant_offset fixed bin (18);
dcl      cx fixed bin (18);
dcl      following_token (2) bit (9) aligned int static options (constant) init ("220"b3, "222"b3);
						/* comma & right_parn */
dcl      i fixed bin (18);
dcl      indx fixed bin (18);
dcl      symb fixed bin (18);
dcl      var_len fixed bin (18);

dcl      1 complex_info (2) aligned,
	 2 sign_char bit (9),
	 2 value fixed bin (18);

dcl      1 two_words aligned,
	 2 words (2) bit (36) aligned;

	indx = current_token;

/* First, see if this is a complex const; while we check, we'll save what info we get. */

	do i = 1 to 2;

	     if token_list (indx + 1).type = plus | token_list (indx + 1).type = minus then do;
		complex_info (i).sign_char = token_list (indx + 1).type;
		indx = indx + 1;
	     end;
	     else
		complex_info (i).sign_char = ZERO;

	     if token_list (indx + 2).type ^= following_token (i) then
		return (FALSE);

	     if token_list (indx + 1).type = real_const | token_list (indx + 1).type = dec_int then
		complex_info (i).value = indx + 1;
	     else do;
		if token_list (indx + 1).type ^= ident then
		     return (FALSE);

		var_len = token_list (indx + 1).length + 1;

		substr (full_name, 1, var_len) = substr (st_copy, token_list (indx + 1).offset + 1, var_len);

		call find_symbol_index (var_len, symb, locate_symtab_entry, ignore_value);
		if symb = 0 then
		     return (FALSE);
		if ^addr (OS (symb)) -> symbol.named_constant then
		     return (FALSE);

		symb = addr (OS (symb)) -> symbol.initial;
		if addr (OS (symb)) -> constant.data_type ^= real_mode then
		     return (FALSE);
		complex_info (i).value = -symb;
	     end;

	     indx = indx + 2;
	end;					/* loop to check each part of a complex const */

/* Now, convert both parts to binary. */

	do i = 1 to 2;

	     sign = complex_info (i).sign_char;
	     cx = complex_info (i).value;

	     if cx > 0				/* then this is a token node */
		then
		if token_list (cx).type = real_const then do;
		     token_offset = token_list (cx).offset;
						/* get token info for conversion */
		     cx = token_list (cx).length + 1;
		     token_length = constant_array (cx).length + 1;

		     work = convert_real_constant (cx);
		     unspec (addr (two_words) -> based_real (i)) =
			conv_round (real_mode, dp_mode) ((unspec (addr (work) -> based_double)), 0);
		end;

		else do;				/* otherwise an integer */
		     work = convert_integer_constant ((token_list (cx).offset), token_list (cx).length + 1);
		     unspec (addr (two_words) -> based_real (i)) =
			conv_round (real_mode, int_mode) ((unspec (addr (work) -> based_integer)), 0);
		end;

	     else
		words (i) = addr (OS (-cx)) -> constant.value;
						/* this is named constant, get const value */

	     if sign = minus then
		unspec (addr (two_words) -> based_real (i)) =
		     negate_round (real_mode) (6, (unspec (addr (two_words) -> based_real (i))), "0"b, 0);
	end;

	sign = ZERO;				/* See procedure convert_integer_constant */

/* Next, modify token list info. */

	current_token = indx;

	if current_token >= last_token then
	     token_length, token_list (current_token).length = statement_length - token_offset - 1;
	else
	     token_length, token_list (current_token).length = token_list (current_token + 1).offset - token_offset - 1;

	token, token_list (current_token).type = complex_const;

	token_list (current_token).offset = token_offset;

/* Finally, create a complex constant. */

	work = string (two_words);			/* Many parsers expect the value to be here. */
	complex_constant_offset = create_constant (cmpx_mode, work);
	return (TRUE);
     end is_complex_constant;

/* BEGIN ext_parse section - LEX - split 82-03-29  T. Oke */

/* Modification History:

   Modified 10 Feb 83, HH - Install LA/VLA support.
   Modified  21 June  1982, TO - Change global and option names to:
	"ckmpy", "nckmpy", change optional "nsubrg", "nstrg".
   Modified   4 April 1982, TO - Change global and option names to:
	"ck_mpy" and "no_ck_mpy", add optional "no_subrg", "no_strg".
   Modified:  7 May 1982, TO - Make %global options print in header and binary.
   Modified:  3 May 1982, TO - change error_table_$no_entry to error_table_$noentry.
   Modified:  3 May 1982, TO - Add "-check_multiply" and "-no_check_multiply".
   Modified: 28 April 1982, TO - Fix phx12940, X FORMAT not followed by comma.
   Modified: 15 April 1982, TO - Fix bug300 to permit lex to see an apostrophe
	even if not preceeded by an operator, if in a FORMAT statement.
   */

statement_lex:
     procedure (a_stmnt_type);

/*	Program Specifications (statement_lex)

     Inputs

     Output

     Description (statement_lex)
*/

dcl      ASSIGN bit (1) aligned;
dcl      EOS bit (1) aligned;
dcl      FORTRAN_ONLY bit (2) aligned int static options (constant) init ("00"b);
dcl      GLOBAL_OK bit (2) aligned int static options (constant) init ("11"b);
dcl      LOWER char (26) aligned int static options (constant) init ("abcdefghijklmnopqrstuvwxyz");
dcl      NL char (1) aligned init ("
") int static options (constant);
dcl      OPTIONS_OK bit (2) aligned int static options (constant) init ("01"b);
dcl      UPPER char (26) aligned int static options (constant) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
dcl      WHITE char (2) aligned int static options (constant) init ("	 ");
						/* tab & space */
dcl      a_stmnt_type fixed bin (18);
dcl      alphanumeric char (64) aligned int static options (constant)
	    init ("$0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz");
dcl      apostrophe_char char (1) aligned int static options (constant) init ("'");
dcl      begin_text fixed bin (20);
dcl      blank_cont_count fixed bin (18);
dcl      cname char (32);
declare	command character (7) internal static options (constant) initial ("fortran");
dcl      count fixed bin (18);
dcl      dname char (256);
dcl      dtm fixed bin (71);
dcl      ename char (256);
dcl      end_text fixed bin (20);
dcl      end_zero fixed bin (18);
dcl      exp fixed bin (18);
dcl      extra_blanks fixed bin (18);
dcl      i fixed bin (18);
dcl      last_token_type bit (9) aligned;
dcl      lexing_a_token bit (1) aligned;
dcl      operator_follows bit (1) aligned;
dcl      paren_level fixed bin (18);
declare	penultimate_token_type bit (9) aligned;
dcl      percent_line_flag bit (2) aligned;
dcl      precision fixed bin (18);
dcl      quote char (1) aligned int static options (constant) init ("""");
dcl      stmnt_type fixed bin (18);
dcl      t_scale fixed bin (18);
dcl      token_table (0:127) fixed bin (18) int static options (constant)
						/* 000 - 037 */
	    init ((9) 0, -1, (22) 0,			/* 040 - 047 */
	    -1, 0, 13, 0, 15, (2) 0, 12,		/* 050 - 057 */
	    8, 9, 14, 4, 10, 5, 2, 11,		/* 060 - 100 */
	    (10) 3, 17, 16, 0, 7, (3) 0,		/* 101 - 177 */
	    (26) 1, (3) 0, 6, (2) 0, (26) 1, (5) 0);
dcl      token_type bit (9) aligned;
dcl      translate_string bit (1) aligned;
dcl      uid bit (36) aligned;

dcl      1 line_structure aligned based (source_ptr),
	 2 pad char (char_index) unaligned,
	 2 rest_of_line char (end_of_line - char_index) unaligned;

dcl      1 text_structure aligned based (source_ptr),
	 2 pad char (char_index) unaligned,
	 2 rest_of_text char (source_len - char_index) unaligned;

dcl      find_include_file_$initiate_count entry (char (*), ptr, char (*), fixed bin (24), ptr, fixed bin (35));
dcl      hcs_$terminate_noname entry (ptr, fixed bin (35));
dcl      translator_info_$component_get_source_info
	    entry (ptr, char (*), char (*), char (*), fixed bin (71), bit (36) aligned, fixed bin (35));
declare	com_err_ entry () options (variable);
declare	error_table_$noentry external static fixed binary (35);
declare	error_table_$no_s_permission fixed bin (35) ext static;

/* beginning of statement lexical analysis */

lex_aborted:
	if cur_statement + size (statement) = next_free_polish then
	     cur_stmnt_ptr -> statement = addr (statement_info) -> statement;
	else
	     call emit_statement_op (addr (statement_info));

	first_token = 2;				/* index of first token; leave room to split it */
	last_token = 1;				/* index of last token; it is always correct */

/* loop until a non-null statement is encountered */

	do while (last_token < first_token);

	     statement_length = 0;			/* Length of statement text copy. */
	     COLON_BEFORE_ASSIGN = FALSE;
	     ASSIGN = FALSE;			/* No assign token encountered. */
	     SECOND_EQUALS = FALSE;			/* Second statement of logical if is assignment. */
	     label_args = FALSE;			/* indicate presence of label args; used by call stmnt parse */
	     paren_level = 0;			/* Paren level. */
	     end_zero = 0;				/* Used to recognize logical if statements. */
	     const_count = 0;			/* Count of real and dp constants. */
	     last_token_type, penultimate_token_type = no_token;
	     stmnt_type = 0;			/* Statement type of statement lexed. */
	     EOS = FALSE;				/* have not yet reached end of this statement */

	     if line_number >= 16384			/* limitation imposed by stmnt map */
	     then do;
		cur_stmnt_ptr -> statement.line = ZERO; /* line has no line number */
		addr (statement_info) -> statement.line = ZERO;
						/* nor do future ones */

		if type_of_line ^= no_more_source then
		     call print_message (103, char (decimal (line_number, 12)));
	     end;
	     else do;
		addr (statement_info) -> statement.line = bit (fixed (line_number, 14), 14);
		cur_stmnt_ptr -> statement.line = bit (fixed (line_number, 14), 14);
	     end;

	     cur_statement_list = number_of_lines;

	     begin_text, end_text = statement_offset;	/* used to calculate sttmnt length */
	     cur_stmnt_ptr -> statement.start = statement_offset;

	     if type_of_line = no_more_source then do;
		call print_message (104);		/* missing end_line */
		statement_label = 0;
		a_stmnt_type = end_line;
		return;
	     end;

/* pick up statement label */

	     statement_label = next_statement_label;
	     if statement_label ^= 0 then do;
		end_possible = FALSE;
		next_statement_label = 0;
	     end;

/* loop to lex a statement; terminates when the next statement is encountered */

	     do while (^EOS);

		token_length = 0;
		token_offset = statement_length;

		translate_string = FALSE;		/* just copy, don't translate */

		go to lexer (char_type);		/* CASE ( token type ) */

/* Return here after lexing one token. If the token is simple, i.e.- an operator, only
		   the token type is stored. If it is complicated, its length and offset are also stored. */

store_token_length:					/* a complicated token */
		token_list (last_token + 1).offset = token_offset;
						/* last_token will never exceed the array bound */

		if token_length > 512 then do;
		     token_list (last_token + 1).length = 512;
		     call print_message (124, 512 - bias);
						/* token string too long */
		end;
		else
		     token_list (last_token + 1).length = token_length - 1;


have_token:					/* a simple token */
		last_token = last_token + 1;

		if last_token >= hbound (token_list, 1) then do;
		     call print_message (123, hbound (token_list, 1) - 1 - bias);
						/* token table overflow */
		     go to abort_lex;
		end;

		token_list (last_token).type = token_type;
		penultimate_token_type = last_token_type;
		last_token_type = token_type;

lex_next_token:					/* if token lex fails */
	     end;					/* lex of a single statement */

	     if last_token < first_token then do;
		call print_message (105);		/* null statement */
	     end;
	end;					/* loop to lex a non-null statement */

	if end_text - begin_text < 512 then
	     cur_stmnt_ptr -> statement.length = bit (binary (end_text - begin_text, 9), 9);
	else
	     cur_stmnt_ptr -> statement.length = "111111111"b;
						/* maximum length possible */

	current_token = 2;

	token_list (last_token + 1).type = EOS_token;	/* indicates the end to the parsers */

	if stmnt_type ^= 0				/* Statement type is already known. */
	then do;
	     if stmnt_type ^= asf_definition & stmnt_type ^= assignment_statement then
		call split_token ((length (keyword_table (stmnt_type))), current_token, FALSE);

	     a_stmnt_type = stmnt_type;
	     return;
	end;

statement_lex$recognize_statement:
     entry (a_stmnt_type);

/* Lookup first token in table to determine statement type. */

	if token_list (current_token).type ^= ident then do;
	     a_stmnt_type = unknown_statement;
	     return;
	end;

	fast_lookup = substr (st_copy, token_list (current_token).offset + 1, token_list (current_token).length + 1);

/* Order of look up is based on whether we are out of "declarative section". */

	if assignment_statement_index ^= assignment_statement then do;
						/* Most likely a declarative. */
	     do stmnt_type = keyword_index to asf_definition - 1
		while (substr (fast_lookup, 1, length (keyword_table (stmnt_type))) ^= keyword_table (stmnt_type));
	     end;

	     if stmnt_type >= asf_definition then
		do stmnt_type = asf_definition + 1 to assignment_statement - 1
		     while (substr (fast_lookup, 1, length (keyword_table (stmnt_type)))
		     ^= keyword_table (stmnt_type));
		end;
	end;

	else do;					/* Most likely executable. */
	     do stmnt_type = asf_definition + 1 to assignment_statement - 1
		while (substr (fast_lookup, 1, length (keyword_table (stmnt_type))) ^= keyword_table (stmnt_type));
	     end;

	     if stmnt_type >= assignment_statement then do;
		do stmnt_type = keyword_index to asf_definition - 1
		     while (substr (fast_lookup, 1, length (keyword_table (stmnt_type)))
		     ^= keyword_table (stmnt_type));
		end;
		if stmnt_type >= asf_definition then
		     stmnt_type = assignment_statement;
	     end;
	end;

/* If not found, see if it unknown or just out of sequence. */

	if stmnt_type >= assignment_statement then do;
	     do stmnt_type = 1 to keyword_index - 1
		while (substr (fast_lookup, 1, length (keyword_table (stmnt_type))) ^= keyword_table (stmnt_type));
	     end;
	     if stmnt_type >= keyword_index then
		stmnt_type = unknown_statement;
	     else do;
		bad_type = stmnt_type;
		stmnt_type = out_of_sequence;
	     end;
	end;

/* If it is legitimate, remove the keyword from the token. If stmnt_type = asf_definition
	   & stmnt_type = assignement_statement split_token will incorrectly remove valid characters. */

	else
	     call split_token ((length (keyword_table (stmnt_type))), current_token, FALSE);

	a_stmnt_type = stmnt_type;
	return;

statement_lex$initialize:
     entry;

	percent_line_flag = GLOBAL_OK;
	extra_blanks, blank_cont_count, source_line_number, line_number = 0;
	next_line_index, end_of_line = -1;

statement_lex$get_next_subprogram:
     entry;

	percent_line_flag = percent_line_flag | OPTIONS_OK;
	have_auto_option, have_static_option = "0"b;
	cur_statement = -1;
	next_statement_label = 0;

/* loop until the first initial line or end of text */

	EOS = FALSE;

	do while (^EOS);
	     call get_line_image (percent_line_flag);	/* Sets "type_of_line" & "EOS", processes %global, %options */

	     if type_of_line = continuation_line & ^EOS	/* continuation precedes initial line, error */
		then
		call print_message (112);
	end;

	call get_new_character;			/* get information about first character */
	return;

abort_lex:					/* if lex of a statement must be aborted */
	EOS = FALSE;
	do while (^EOS);
	     call get_line_image (FORTRAN_ONLY);
	end;

	call get_new_character;			/* reset global variables */

	go to lex_aborted;

/* Case	White space -- only possible if first significant char of a statement is on a continuation line */
lexer (-1):
	if statement_label ^= 0 then
	     next_statement_label = -1;		/* prevent multiple labels */
	call skip_characters (0);
	if next_statement_label < 0 then
	     next_statement_label = 0;
	go to lex_next_token;

/* Case	non-ASCII, characters not in character set. */
lexer (0):
	if binary (bit_value, 9, 0) <= 32 | binary (bit_value, 9, 0) >= hbound (token_table, 1) then
	     call print_message (106, "whose bit value is " || char (bit_value));
	else
	     call print_message (106, char_value);
	call skip_characters (ONE);
	go to lex_next_token;

/* Case A-Z a-z */
lexer (1):
	token_type = ident;
	translate_string = fold_option;		/* translate name if specified by user */

	lexing_a_token = TRUE;
	do while (lexing_a_token);
	     i = verify (rest_of_line, alphanumeric) - 1;
	     if i = 0 then
		lexing_a_token = FALSE;
	     else do;
		if i < 0 then
		     i = length (rest_of_line);
		call skip_characters (i);
		if EOS then
		     lexing_a_token = FALSE;
		else if char_type ^= digits & char_type ^= letters & current_character ^= "_"
		     & current_character ^= "$" then
		     lexing_a_token = FALSE;
	     end;
	end;

	go to store_token_length;

/* Case . decimal point */
lexer (2):
	call skip_characters (ONE);

	if EOS then do;
	     call print_message (107, ".");		/* illegal "." */
	     go to lex_next_token;
	end;

	if char_type = digits then do;
	     call get_digits (precision);
	     token_type = real_const;
	     t_scale = precision;
	     operator_follows = FALSE;
	     call parse_exponent;
	end;
	else do;
	     translate_string = fold_option;
	     call build_fortran_operator;
	end;
	go to store_token_length;

/* Case 0-9 digits */
lexer (3):
	token_type = dec_int;
	call get_digits (precision);
	t_scale = 0;
	operator_follows = FALSE;

/* for ansi77, a few changes here.  If the last token_type was an asterisk, there are several possibilities.
   If we're wihtin parens, and the next_to_last token is either a comma, or a left paren,
   then this should be a label constant (e.g. *8 ,like Multics $8) in a call statment.
   We can also detect an initial field length (e.g. character*30), but not an internal one,
   e.g. character *3 foo, bar *33.  The *33 can't be distinguished from an arithemetic expression at this point.
*/

	if EOS then
	     go to store_token_length;
	if last_token_type = asterisk then do;
	     if paren_level = 0 & last_token - first_token = 1 then
		go to store_token_length;		/* a initial length field */
	     else if paren_level > 0 & (penultimate_token_type = comma | penultimate_token_type = left_parn) then do;

/* The previous asterisk actually began an alternate return arg in a call.  We must back up the token list,
   and incorporate the "*" into this token.  This requires changing the token_type, and the length and offset.
*/

		token_offset = token_offset - 1;
		token_length = token_length + 1;
		label_args = TRUE;
		token_type = label_const;
		last_token = last_token - 1;
		goto store_token_length;
	     end /* label arg */;
	end /* last was asterisk */;

/* A little diddling added to handle x format within formats, but not
   followed by an operator, such as ) or ,. PHX12940.  Here detect the
   presence of a 6 character token as first on a line, followed by a
   left_parn, the best we can do other than actually setting a FORMAT flag. */

	if current_character = "x" | current_character = "X" then
	     if paren_level >= 1 & last_token > 2 & token_list (2).length = 5 & token_list (3).type = left_parn then do;
						/* must be FORMAT nX */
		call skip_characters (ONE);
		go to store_token_length;
	     end;

/* an integer followed by an h is usually a hollerith constant */

	if current_character = "h" | current_character = "H" then do;
	     unspec (count) = convert_integer_constant (token_offset, token_length);

	     token_length = -1;
	     token_offset = statement_length + 1;
	     token_type = char_string;

	     if count = 0				/* "call skip_characters" even if error. */
	     then do;
		call print_message (108);
		call skip_characters (ONE);		/* Skip "h". */
		go to store_token_length;
	     end;

	     count = count + 1;			/* Include the "h" in the count. */
	     do while (count > 0);
		i = min (count, length (rest_of_line));
		count = count - i;
		if count > 0 then do;
		     call get_continuation_line (count);/* Sets: type_of_line, EOS and its argument */

		     if EOS			/* string is terminated by the end of the statement */
		     then do;
			if count > 0		/* statement terminated before we got enough chars */
			     then
			     call print_message (109);
			if token_length = 0 then
			     call print_message (108);
			call skip_characters (0);
			go to store_token_length;
		     end;

		     i = count;			/* set i to number of remaining chars in const */
		end;
	     end;

	     call skip_characters (i);		/* copy end of string and find next significant char */
	     go to store_token_length;
	end;

/* now see if the number contains a decimal point */

	if current_character = "." then do;
	     call skip_characters (ONE);
	     token_type = real_const;
	     if ^EOS then do;
		if char_type = digits		/* Digits after the decimal point? */
		then do;				/* Yes. */
		     call get_digits (t_scale);
		     precision = precision + t_scale;
		end;
		else do;
		     translate_string = fold_option;	/* in case integer is followed by rel op */
		     operator_follows = TRUE;		/* could be integer followed by rel op */
		end;
	     end;
	end;

/* finally, see if there is an exponent field */

	call parse_exponent;

	if operator_follows				/* set by parse_exponent if rel op follows int */
	then do;

/*	A decimal point encountered is actually part of a relational operator. We will store the
		integer (which is the only possible token to precede it) and then process the rel op. */

	     last_token = last_token + 1;

	     if last_token >= hbound (token_list, 1) then do;
		call print_message (123, hbound (token_list, 1) - 1 - bias);
						/* token table overflow */
		go to abort_lex;
	     end;

	     token_list (last_token).type = dec_int;
	     token_list (last_token).offset = token_offset;

	     if precision > 512 then do;
		token_list (last_token).length = 511;
		call print_message (124, 512 - bias);	/* token string too long */
	     end;
	     else
		token_list (last_token).length = precision - 1;

/* now update length and offset to exclude the integer */

	     token_offset = token_offset + precision;
	     token_length = token_length - precision;
	     call build_fortran_operator;
	end;
	go to store_token_length;

/* Case + */
lexer (4):
	token_type = plus;
	call skip_characters (ONE);
	go to have_token;

/* Case - */
lexer (5):
	token_type = minus;
	call skip_characters (ONE);
	go to have_token;

/* Case ^ */
lexer (6):
	token_type = expon;
	call skip_characters (ONE);
	go to have_token;

/* Case = */
lexer (7):
	token_type = assign;
	if paren_level = 0 & ^ASSIGN then do;
	     ASSIGN = TRUE;				/* These tests made only once per statement. */
	     if substr (st_copy, 1, 3) = "if("		/* See if "if" stmnt */
		& ((end_zero = 1 & last_token_type = ident)
						/* if() x = */
		| (end_zero = 2 & last_token_type = right_parn))
						/* if () x() = */
		| (end_zero = 3 & last_token_type = right_parn & COLON_BEFORE_ASSIGN)
						/* if () x () (n:m) = */
		then
		SECOND_EQUALS = TRUE;		/* Probably log if stmnt whose second is assignmnt. */
	     else if keyword_index > parameter_statement	/* obviously not parameter. */
		then
		stmnt_type = assignment_statement_index;
	     else if substr (st_copy, 1, 9) = "parameter" & statement_length > 9 then
		stmnt_type = parameter_statement;
	     else
		stmnt_type = assignment_statement_index;
	end;

	call skip_characters (ONE);
	go to have_token;

/* Case ( */
lexer (8):
	token_type = left_parn;
	paren_level = paren_level + 1;
	call skip_characters (ONE);
	paren_array (paren_level) = last_token + 1;
	go to have_token;

/* Case ) */
lexer (9):
	token_type = right_parn;
	call skip_characters (ONE);

	paren_level = paren_level - 1;
	if paren_level = 0 then
	     end_zero = end_zero + 1;
	go to have_token;

/* Case , */
lexer (10):
	token_type = comma;
	if ASSIGN & paren_level = 0 & substr (st_copy, 1, 2) = "do" then
	     stmnt_type = do_statement;

	call skip_characters (ONE);
	go to have_token;

/* Case / */
lexer (11):
	token_type = slash;
	call skip_characters (ONE);
	if EOS then
	     go to have_token;
	if current_character ^= "/" then
	     go to have_token;
	token_type = concat;
	call skip_characters (ONE);
	go to have_token;

/* Case ' apostrophe */
/* A little diddling added to handle ' strings within formats, but not
   preceeded by an operator, such as ( or ,.  bug 300.  Here detect the
   presence of a 6 character token as first on a line, followed by a
   left_parn, the best we can do other than actually setting a FORMAT flag. */

lexer (12):
	token_type = apostrophe;

	if paren_level = 1 & (last_token_type = right_parn | (last_token_type & is_operand) ^= ZERO)
	     & ^(last_token > 2 & token_list (2).length = 5 & token_list (3).type = left_parn) then do;
						/* apostrophe operator */
	     call skip_characters (ONE);
	     go to have_token;
	end;
	else do;					/* char str constant */
	     call build_string (apostrophe_char);
	     go to store_token_length;
	end;

/* Case " quote */
lexer (13):
	call build_string (quote);
	go to store_token_length;

/* Case * */
lexer (14):
	token_type = asterisk;
	call skip_characters (ONE);
	if EOS then
	     go to have_token;
	if current_character ^= "*" then
	     go to have_token;
	token_type = expon;
	call skip_characters (ONE);
	go to have_token;

/* Case $ */
lexer (15):
	token_type = label_const;
	call skip_characters (ONE);

	if ^EOS & char_type = digits then
	     call get_digits (ignore_value);

	label_args = TRUE;
	go to store_token_length;

/* Case ; */
lexer (16):
	if card_image then
	     go to lexer (0);

	statement_offset, end_text = char_index + 1;	/* unless there is a newline, next stmnt starts here */

/* add one to the statement count for this line. it is reset if a new line is read */

	addr (statement_info) -> statement.statement =
	     bit (binary (binary (addr (statement_info) -> statement.statement, 5, 0) + 1, 5, 0), 5);

	end_possible = FALSE;			/* end line cannot contain a semi-colon */
	call skip_characters (ONE);			/* skip over the semi-colon */
	statement_length = statement_length - 1;	/* to keep format parse happy */

	EOS = TRUE;				/* semi-colon is the end of a statement */
	go to lex_next_token;			/* semi-colon is not stored in token table */

/* Case : */
lexer (17):
	token_type = colon;
	call skip_characters (ONE);
	if ^ASSIGN then
	     COLON_BEFORE_ASSIGN = TRUE;
	go to have_token;

get_continuation_line:
     procedure (a_count);

/*	Program Specifications (get_continuation_line)

     Inputs

     Output

     Description (get_continuation_line)

     NOTE - This procedure modifies:
	char_index
	st_copy
	statement_length
	token_length
	end_possible
*/

dcl      a_count fixed bin (18);
dcl      blank_count fixed bin (18);
dcl      const_max_len fixed bin (18);
dcl      i fixed bin (18);
dcl      len fixed bin (18);
dcl      more_on_this_line bit (1) aligned;


/* This entry point is used to get the next line if no blank suppression is desired. It also appends
	   blanks characters implied by card-image format that were removed as trailing white space.
	   Currently, it is only used if a character-string constant is continued onto a following line. */


	const_max_len = a_count;
	blank_count = min (const_max_len, extra_blanks);	/* number of blanks present and needed on this line */
	blank_cont_count = 0;			/* number of intervening completely blank cont. lines */
	end_possible = FALSE;			/* an endline cannot contain character-string constants */

/* copy character-string constant value into temp buffer */

	len = length (rest_of_line);			/* number of characters from this line */
	if len > 0 then
	     call concatenate_text;			/* must be something to concatenate */

	if blank_count > 0				/* add blanks for original line */
	then do;
	     const_max_len = const_max_len - blank_count;
	     call concatenate_blanks;
	end;

	call get_line_image (FORTRAN_ONLY);		/* Sets: type_of_line,EOS,blank_cont_count,extra_blanks */

	if blank_cont_count > 0			/* If we have skipped over some completely blank
	then if const_max_len > 0			/* continuation lines, add to constant if needed. */
	then do;
	     blank_count = min (const_max_len, blank_cont_count * 66);
	     const_max_len = const_max_len - blank_count;
	     call concatenate_blanks;
	end;

	a_count = const_max_len;
	return;


skip_characters:
     entry (a_count);

/* this entry point is called to skip zero or more characters and then find the next non-white character.
	   It also recognizes end lines as it is the only procedure with sufficient knowledge to make
	   the distinctions necessary */

/* copy characters into temp buffer */

	len = min (a_count, length (rest_of_line));	/* number of characters to cancatenate and skip */
	if len > 0 then
	     call concatenate_text;			/* must be something to concatenate */

/* loop until a non-blank character or the end of the text */

	more_on_this_line = length (rest_of_line) > 0;	/* something left on this line */
	current_character = substr (rest_of_line, 1, 1);

	do while (TRUE);

/* except for first line, always get a new line image */

	     if ^more_on_this_line			/* only on if first line had remaining chars */
	     then do;
		if end_possible then
		     if statement_length = 3 then
			if translate (substr (st_copy, 1, 3), LOWER, UPPER) = "end" then do;
			     EOS = TRUE;
			     stmnt_type = end_line;
			     return;
			end;

		call get_line_image (FORTRAN_ONLY);	/* Sets "type_of_line" & "EOS" */
		if type_of_line = no_more_source then
		     return;
	     end;

	     else
		more_on_this_line = FALSE;		/* only used once per line image, if at all */

	     call get_new_character;			/* determine character type */

	     if EOS | char_type > 0 then
		return;				/* return if it is a Fortran character */

	     i = verify (rest_of_line, WHITE) - 1;	/* is it white space? */

	     if i >= 0				/* at least one non-blank left on this line */
	     then do;				/* skip it */
		if i > 0				/* actually was white space; get new character */
		then do;
		     char_index = char_index + i;	/* skip the white space */
		     current_character = substr (rest_of_line, 1, 1);
						/* new cur char needed */
		end;

		if current_character ^= "!" | card_image/* found a non-blank character, return it */
		then do;
		     if i > 0 then
			call get_new_character;	/* determine character type */
		     return;
		end;
	     end;					/* skipping white space */
	end;

/* should never exit this loop here */


/* Procedure to append extra blank characters implied by a short card-image record. */

concatenate_blanks:
     procedure;

	if statement_length + blank_count > length (st_copy) then do;
	     call print_message (111, length (st_copy) - bias);
						/* text buffer overflow */
	     go to abort_lex;
	end;

	else do;
	     substr (st_copy, statement_length + 1, blank_count) = " ";
	     statement_length = statement_length + blank_count;
	     token_length = token_length + blank_count;
	end;
     end concatenate_blanks;


concatenate_text:
     procedure;

	if statement_length + len > length (st_copy) then do;
	     call print_message (111, length (st_copy) - bias);
						/* text buffer overflow */
	     go to abort_lex;
	end;

	else do;
	     if translate_string			/* user specified folding and token requires it */
	     then do;
		substr (st_copy, statement_length + 1, len) = translate (substr (rest_of_line, 1, len), LOWER, UPPER);
		statement_length = statement_length + len;
						/* included here to keep "shorten_stack" call out of main line */
	     end;
	     else do;
		substr (st_copy, statement_length + 1, len) = substr (rest_of_line, 1, len);
		statement_length = statement_length + len;
	     end;
	     char_index = char_index + len;
	     token_length = token_length + len;
	end;
     end concatenate_text;
     end get_continuation_line;

get_line_image:
     procedure (options_flag);

/*	Program Specifications (get_line_image)

     Inputs
	options_flag indicates what sorts of lines are acceptable:
	     "00"b -- only standard FORTRAN program lines (FORTRAN_ONLY)
	     "01"b -- FORTRAN lines of %options lines (OPTIONS_OK)
	     "11"b -- FORTRAN, %options, %global ok (GLOBAL_OK)

     Output
	options_flag is continuously updated to reflect the fact that %globals must precede %options,
	and that both must precede FORTRAN source statements, including comments.  By the time
	get_line_image returns, options_flag will be set to "00"b (FORTRAN_ONLY)

     Description

     this procedure isolates line images; it should be the only procedure to know about the actual
format of the source text

THERE ARE TWO LEXERS -- CARD IMAGE and FREE FORM

		The following block of code should be the only block of code to differentiate
		lines. For each type of source input three types of lines are defined:

			1. Initial lines
			2. Continuation lines
			3. Comment lines

		In the ansi77 standard, blank lines are treated differently  than they are in
		the 66 standard.  In ansi77 mode, they are comments, whereas in 66 mode they are initial lines.

		Each lex shall define these three line types. Comment lines are useful to the reader of the
		source code and not to the parsers or token lexers.


	CARD IMAGE LEX

		1. A comment line is any line whose first character is either a c, C, or *. This is the first
		      type of line to be checked for.
		2. An initial line is any line whose sixth character is neither a blank nor a zero.
		      Lines with fewer than six characters are initial lines.
		3. If neither of the above are satisfied, the line is a continuation line.

	FREE FORM LEX

		If the source text is required to have line numbers, they are processed and then
		stripped from the line.

		1. A comment line is either: a) a line whose first character is a c or C, or
		   b) a line whose first non blank character is * or !.
		2. A continuation line is a line whose first non blank character is &.
		3. An initial line is any other line. A line containing no text is an initial line.


THERE IS ADDITIONALLY A PSEUDO-LEXER

	which precedes the above, to recognize and process %options and %global statements, if they are
	allowed.  This processing has to be done at this point, since it is the first place at which
	the information necessary to process the statements is readily accessible, and the information
	is needed in this subprogram since it may affect which of the two lexers are to be used.

     NOTE - This procedure modifies:
	char_index
	next_line_index
	EOS
	type_of_line
	subr_options
	segment_options
*/

dcl      ERROR bit (1) aligned int static options (constant) init ("0"b);
dcl      LEGAL_NON_WHITE_SPACE char (66) aligned int static options (constant)
	    init ("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890()=_");
dcl      RETURN bit (1) aligned int static options (constant) init ("1"b);
dcl      WHITE_AND_DIGITS char (12) aligned int static options (constant) init ("	 0123456789");
						/* ht sp digits */
dcl      depthx fixed bin (17);
dcl      file_string_index fixed bin (17);
dcl      file_string_length fixed bin (17);
dcl      i fixed bin (18);
dcl      include_file_bit_count fixed bin (24);
dcl      include_file_name char (256) varying;
dcl      include_file_ptr pointer;
dcl      just_white_space fixed bin (18) int static options (constant) init (-1);
dcl      line_no fixed dec (6);
dcl      options_flag bit (2) aligned;
dcl      percent_index fixed bin (18);

dcl      last_label_line fixed bin (18) static;		/* source line of last label */

dcl      1 line_no_overlay aligned structure based (addr (line_no)),
	 2 pad char (1) unaligned,
	 2 ln_digits char (6) unaligned;

/* NOTE. use_source_info is ONLY ON IN get_line_image.  This is the peculiarity*/
/* of error message reporting.				         */

	shared_structure.use_source_info = "1"b;
	end_text = next_line_index + 1;		/* stmnt len will not include following comment lines */

	if options_flag then do;
	     if options_flag = GLOBAL_OK then do;
		segment_options = shared_structure.options.user_options;
		unspec (segment_declared) = "0"b;
	     end;
	     else
		subr_options = segment_options;
	     unspec (subr_declared) = "0"b;
	end;

/* loop until a significant character is found */

	type_of_line = just_white_space;
	do while (type_of_line = just_white_space);

/* get the next line image or the end of text */

NEED_NEW_LINE:					/* escape for case where options lexer eats the line. */
	     statement_offset, char_index = next_line_index + 1;

	     if char_index >= source_len		/* no more text */
	     then do;
		call test_orphan_label;
		if file_stack_depth = 0 then do;
		     EOS = TRUE;
		     type_of_line = no_more_source;
		end;

		else do;
		     file_stack_depth = file_stack_depth - 1;
		     seg_ptr = file_stack (file_stack_depth).fs_seg_ptr;
		     source_ptr = file_stack (file_stack_depth).fs_source_ptr;
		     next_line_index = file_stack (file_stack_depth).fs_end_of_line;
		     source_len = file_stack (file_stack_depth).fs_source_length;
		     source_line_number, line_number = file_stack (file_stack_depth).fs_line_number;
		     source_file_number, file_number = file_stack (file_stack_depth).fs_file_number;
		     addr (statement_info) -> statement.file = file_number;
		     go to NEED_NEW_LINE;
		end;

		goto exit_get_line_image;
	     end;

	     number_of_lines = number_of_lines + 1;	/* count lines */

/* now find the end of this line */

	     next_line_index = index (rest_of_text, NL) + char_index - 1;
	     if next_line_index < char_index then
		next_line_index = source_len;
	     end_of_line = next_line_index;		/* line ends with the beginning of the next one */

	     if produce_listing then do;
		source_list (number_of_lines).file_number = file_number;
		source_list (number_of_lines).line_start = statement_offset;
		source_list (number_of_lines).line_length = next_line_index - statement_offset + 1;
		source_list (number_of_lines).line_number_in_file = line_number + 1;
	     end;

/* %(OPTIONS GLOBAL INCLUDE) PSEUDO-LEX */

	     percent_index = verify (rest_of_line, WHITE_AND_DIGITS);

	     if percent_index > 0 then
		if substr (rest_of_line, percent_index, 1) = "%" then
		     call test_orphan_label;
	     if percent_index > 0 then
		if substr (rest_of_line, percent_index, 1) = "%" then
		     if translate (substr (rest_of_line, percent_index, 8), LOWER, UPPER) = "%include" then do;

			source_line_number, line_number = line_number + 1;
			char_index = char_index + percent_index + 7;

			if length (rest_of_line) <= 0 then do;
			     call print_message (160);
			     go to NEED_NEW_LINE;
			end;

			file_string_index = verify (rest_of_line, WHITE);
			char_index = char_index + file_string_index - 1;
			if length (rest_of_line) <= 0 then do;
			     call print_message (160);
			     go to NEED_NEW_LINE;
			end;

			file_string_length = search (rest_of_line, WHITE) - 1;

			if file_string_length <= 0 then
			     file_string_length = length (rest_of_line);
			if file_string_length >= 244 then do;
			     call print_message (161, substr (rest_of_line, 1, file_string_length));
			     go to NEED_NEW_LINE;
			end;

			include_file_name = substr (rest_of_line, 1, file_string_length) || ".incl.fortran";

			call find_include_file_$initiate_count (command, source_ptr, (include_file_name),
			     include_file_bit_count, include_file_ptr, code);
			if include_file_ptr = null	/* file not found */
			then do;
			     call print_message (162, include_file_name);
			     if code ^= 0 & code ^= error_table_$noentry then
				call com_err_ (code, command, "^a", include_file_name);
			     go to NEED_NEW_LINE;
			end;


			if shared_structure.incl_count > 255 then do;
			     call hcs_$terminate_noname (include_file_ptr, code);
			     call print_message (163, include_file_name);
			     go to NEED_NEW_LINE;
			end;

			if file_stack_depth > hbound (file_stack, 1) then do;
			     call hcs_$terminate_noname (include_file_ptr, code);
			     call print_message (164, include_file_name);
			     go to NEED_NEW_LINE;
			end;

			file_stack (file_stack_depth).fs_seg_ptr = seg_ptr;
			file_stack (file_stack_depth).fs_source_ptr = source_ptr;
			file_stack (file_stack_depth).fs_end_of_line = end_of_line;
			file_stack (file_stack_depth).fs_source_length = source_len;
			file_stack (file_stack_depth).fs_line_number = line_number;
			file_stack (file_stack_depth).fs_file_number =
			     binary (addr (statement_info) -> statement.file, 8, 0);

			do depthx = lbound (file_stack, 1) to file_stack_depth;
			     if file_stack (depthx).fs_source_ptr = include_file_ptr then do;
				call hcs_$terminate_noname (include_file_ptr, code);
				call print_message (165, include_file_name);
				go to NEED_NEW_LINE;
			     end;
			end;

			file_stack_depth = file_stack_depth + 1;
			shared_structure.incl_count = shared_structure.incl_count + 1;

			call translator_info_$component_get_source_info (include_file_ptr, dname, ename, cname, dtm,
			     uid, code);
			if code ^= 0 then do;
			     if code = error_table_$no_s_permission then
				call print_message (188, include_file_name);
			     else
				call com_err_ (code, command, "^a", include_file_name);
			     cname = "";
			     if substr (include_file_name, 1, 1) ^= ">" then do;
				dname = "UNKNOWN DIRECTORY NAME";
				ename = include_file_name;
			     end;
			     else do;
				ename = reverse (before (reverse (include_file_name), ">"));
				dname = before (include_file_name || " ", ">" || rtrim (ename) || " ");
			     end;
			     uid = ""b;
			     dtm = 0;
			end;

			number_of_source_segments = number_of_source_segments + 1;
			i = 63 - divide (length (ename) + length (dname), chars_per_word, 17, 0);

			indx = create_node (source_node, size (source) - i);
			seg_chain_end_ptr -> source.next = indx;
			cur_segment = indx;
			seg_chain_end_ptr, seg_ptr = addr (OS (cur_segment));

			if cname = "" then
			     seg_ptr -> source.pathname = rtrim (dname) || ">" || rtrim (ename);
			else
			     seg_ptr -> source.pathname =
				rtrim (dname) || ">" || before (ename, ".archive") || "::" || rtrim (cname);
			seg_ptr -> source.uid = uid;
			seg_ptr -> source.dtm = dtm;
			seg_ptr -> source.line_number = number_of_lines;

			source_ptr = include_file_ptr;
			char_index = 0;
			source_len = divide (include_file_bit_count + 8, 9, 21, 0);
			source_line_number, line_number = 0;
			source_file_number, file_number = shared_structure.incl_count;
			addr (statement_info) -> statement.file = file_number;
			next_line_index = -1;

			shared_structure.source_node_offset (shared_structure.incl_count) = cur_segment;
			shared_structure.incl_len (shared_structure.incl_count) = source_len;
			shared_structure.incl_ptr (shared_structure.incl_count) = source_ptr;

			go to NEED_NEW_LINE;
		     end;

		     else if options_flag then
			if translate (substr (rest_of_line, percent_index, 7), LOWER, UPPER) = "%global" then do;
			     source_line_number, line_number = line_number + 1;
			     if options_flag = GLOBAL_OK then
				call lex_global;
			     else
				call print_message (193);
			     go to NEED_NEW_LINE;
			end;

			else if translate (substr (rest_of_line, percent_index, 8), LOWER, UPPER) = "%options"
			then do;
			     if options_flag = GLOBAL_OK then do;
				options_flag = OPTIONS_OK;
				call fort_defaults_$check_global_args (addr (segment_declared),
				     addr (shared_structure.declared_options), print_message);
						/* check for any conflicts between arguments and %globals */
				unspec (segment_declared) =
				     unspec (segment_declared) | unspec (shared_structure.declared_options);
				call fort_defaults_$set (addr (segment_declared), addr (segment_options));
				shared_structure.options.user_options = segment_options;
				call set_max_array_size;
				subr_options = segment_options;
				shared_structure.declared_options = segment_declared;
				call fort_defaults_$init_shared_vars (addr (shared_structure));
			     end;
			     source_line_number, line_number = line_number + 1;
			     call lex_options;
			     go to NEED_NEW_LINE;
			end;

	     if options_flag ^= FORTRAN_ONLY then do;
		if options_flag = GLOBAL_OK then do;
		     call fort_defaults_$check_global_args (addr (segment_declared),
			addr (shared_structure.declared_options), print_message);
						/* check for any conflicts between arguments and %globals */
		     unspec (segment_declared) =
			unspec (segment_declared) | unspec (shared_structure.declared_options);
		     call fort_defaults_$set (addr (segment_declared), addr (segment_options));
		     shared_structure.options.user_options = segment_options;
		     call set_max_array_size;
		     subr_options = segment_options;
		     shared_structure.declared_options = segment_declared;
		     call fort_defaults_$init_shared_vars (addr (shared_structure));
		end;
		card_image = subr_options.card;
		fold_option = subr_options.fold;
		if subr_options.ansi_77 then
		     default_char_size = 1;
		else
		     default_char_size = 8;
	     end;

/* CARD IMAGE LEX */

	     if card_image then do;
		source_line_number, line_number = line_number + 1;
						/* use sequence number as the line number */

		if length (rest_of_line) <= 0 then
		     EOS = ^subr_options.ansi_77;
		else do;
		     if length (rest_of_line) > 72	/* only use 72 columns per card */
		     then do;
			if length (rest_of_line) > 80 /* warn user of a long card image */
			     then
			     call print_message (132);

			end_of_line = char_index + 72;
		     end;

		     if substr (rest_of_line, 1, 1) ^= "c" & substr (rest_of_line, 1, 1) ^= "C"
			& substr (rest_of_line, 1, 1) ^= "*" then
			if length (rest_of_line) < 6	/* column 6 is blank, an initial line */
			then do;
			     EOS = ^subr_options.ansi_77;
			     if rest_of_line ^= ""	/* Initial line */
				then
				EOS = TRUE;
			     call lex_label_field (length (rest_of_line), ERROR);
			end;
			else if substr (rest_of_line, 6, 1) ^= " " & substr (rest_of_line, 6, 1) ^= "0" then
			     if length (rest_of_line) > 6
						/* a non blank continuation line */
			     then do;
				char_index = char_index + 6;
				extra_blanks = max (0, 66 - length (rest_of_line));
				end_possible = FALSE;
						/* cont line cannot be end line */
				type_of_line = continuation_line;
			     end;

/* blank continuation line -- treat as comment line */

			     else
				blank_cont_count = blank_cont_count + 1;

			else do;			/* possibly an initial line */
			     EOS = (substr (rest_of_line, 6, 1) = "0" | ^subr_options.ansi_77);
			     if rest_of_line ^= " "	/* Determine if comment */
				then
				EOS = TRUE;
			     call lex_label_field (5, ERROR);
			     char_index = char_index + 1;
						/* skip continuation field */

/* find first non blank char on this line or get another line */

			     if length (rest_of_line) > 0 then do;
				i = verify (rest_of_line, WHITE) - 1;
				if i >= 0		/* non blank found */
				then do;
				     EOS = TRUE;
				     extra_blanks = max (0, 66 - length (rest_of_line));
				     char_index = char_index + i;
				     end_possible = TRUE;
						/* init line can be end line */
				     type_of_line = initial_line;
				end;
			     end;
			end;
		end;				/* non blank lines */
	     end;					/* CARD IMAGE LEX */


/* FREE FORM LEX */

	     else do;

		if line_numbered_text		/* for line numbered text, lex a line number */
		then do;
		     i = verify (rest_of_line, DIGIT) - 1;
						/* count digits in line number */
		     if i < 0 then
			i = length (rest_of_line);	/* entire line is digits (or length(line) = 0) */

		     if i = 0 then
			call print_message (113, rest_of_line);
						/* missing line number */

		     else do;			/* process line number field */
			if i - length (ln_digits) > 0 /* limit length of line number */
			then do;
			     call print_message (114, substr (rest_of_line, 1, i));
						/* line number too long */
			     char_index = char_index + (i - length (ln_digits));
						/* skip excess digits */
			     i = length (ln_digits);
			end;

			line_no = 0;		/* convert line number to binary */
			substr (ln_digits, length (ln_digits) - i + 1, i) = substr (rest_of_line, 1, i);

			char_index = char_index + i;	/* skip line number field */

			if line_no <= line_number	/* sequence check the line number */
			     then
			     call print_message (115, ln_digits, char (decimal (line_number, 12)));
						/* out of sequence */

			source_line_number, line_number = line_no;
						/* set current line number */
		     end;				/* processing existing line number */
		end;				/* lex for line numbers */

		else
		     source_line_number, line_number = line_number + 1;
						/* no line numbers, use sequence number */

		if length (rest_of_line) <= 0 then
		     EOS = ^subr_options.ansi_77;
		else if substr (rest_of_line, 1, 1) ^= "c" & substr (rest_of_line, 1, 1) ^= "C" then do;

		     i = verify (rest_of_line, WHITE) - 1;
		     if i < 0 then
			EOS = ^subr_options.ansi_77;
		     else do;			/* a line with text */
			char_index = char_index + i;
			current_character = substr (rest_of_line, 1, 1);

			if current_character ^= "*" & current_character ^= "!" then
			     if current_character = "&" then do;
						/* continuation line */
				char_index = char_index + 1;
						/* skip "&" */
				if length (rest_of_line) > 0 then do;
				     end_possible = FALSE;
						/* cont line cannot be end line */
				     type_of_line = continuation_line;
				end;
			     end;
			     else do;		/* initial line */
				call test_orphan_label;
				call get_new_character;
						/* Sets "char_type" */

				if char_type = digits
						/* lex label field if it exists */
				     then
				     call lex_label_field (length (rest_of_line), RETURN);

				if length (rest_of_line) > 0 then do;
				     end_possible = TRUE;
						/* init line can be end line */
				     type_of_line = initial_line;
				end;
				EOS = TRUE;
			     end;			/* initial line */
		     end;				/* non blank line */
		end;				/* non comment line */

		else do;				/* Quick cheap check to catch some unintended comments */
		     if index (LEGAL_NON_WHITE_SPACE, substr (rest_of_line, 2, 1)) ^= 0 then do;
			line_number_pic = line_number;
			file_number_pic = -file_number;
			call print_message (148, file_number_pic, line_number_pic);
		     end;
		end;
	     end;					/* FREE FORM LEX */

	end;					/* loop to get significant character */

	if options_flag ^= FORTRAN_ONLY then
	     options_flag = FORTRAN_ONLY;

	addr (statement_info) -> statement.statement = "00001"b;
						/* reset statement count for line */

	current_character = substr (rest_of_line, 1, 1);	/* return character just found */
exit_get_line_image:
	shared_structure.use_source_info = "0"b;	/* TURN OFF SOURCE LINE NUMBERS */
	return;

lex_global:
     procedure;

dcl      option char (32);

	char_index = char_index + percent_index + 7;

	call get_next_option (option);

	do while (option ^= "");

	     call fort_defaults_$global (addr (option), length (option), addr (segment_declared), print_message);

	     call get_next_option (option);

	end;

	return;
     end lex_global;

lex_options:
     procedure;

dcl      option char (32);

	char_index = char_index + percent_index + 8;

	call get_next_option (option);

	do while (option ^= "");

	     call fort_defaults_$option (addr (option), length (option), addr (subr_options), addr (subr_declared),
		addr (segment_options), have_auto_option, have_static_option, print_message);

	     call get_next_option (option);

	end;

	return;
     end lex_options;

get_next_option:
     procedure (option);

dcl      i fixed bin (18);
dcl      option char (32);
dcl      OPTION_DELIMS char (4) static int options (constant) init ("	 ,;");
						/* tab, space, comma, semi */
dcl      OPTION_SKIP char (3) static int options (constant) init ("	 ,");
						/* tab, space, comma */

	i = verify (rest_of_line, OPTION_SKIP) - 1;
	if i < 0 then do;
	     option = "";
	     char_index = char_index + length (rest_of_line);
	     return;
	end;

	else do;
	     char_index = char_index + i;

	     if substr (rest_of_line, 1, 1) = ";" then do;
		option = "";
		char_index = char_index + length (rest_of_line);
		return;
	     end;

	     i = search (rest_of_line, OPTION_DELIMS) - 1;
	     if i < 0 then
		i = length (rest_of_line);

	     if i = 0 then
		option = "";

	     else do;
		if substr (rest_of_line, i, 1) = ";" then
		     i = i - 1;
		option = translate (substr (rest_of_line, 1, min (i, 32)), LOWER, UPPER);
		char_index = char_index + i;
	     end;

	end;

	return;
     end get_next_option;


lex_label_field:
     procedure (width, action_on_non_numeric);

dcl      action_on_non_numeric bit (1) aligned;
dcl      digit fixed bin (18);
dcl      loop_index fixed bin (18);
dcl      numeric bit (1) aligned;
dcl      width fixed bin (18);

	call test_orphan_label;			/* ensure no label outstanding */
	numeric = FALSE;				/* no digits encountered */

	do loop_index = 1 to width;
	     digit = binary (unspec (substr (rest_of_line, 1, 1)), 9, 0);
	     if digit > hbound (token_table, 1) then
		char_type = 0;
	     else
		char_type = token_table (digit);

	     if char_type = digits then do;
		next_statement_label = next_statement_label * 10 + digit - 000110000b;
		numeric = TRUE;
	     end;

	     else if char_type ^= just_white_space then do;
		if action_on_non_numeric = ERROR then do;
		     call print_message (133);
		     char_index = char_index + (width - loop_index + 1);
		end;

		if numeric & next_statement_label = 0 then
		     call print_message (69, "0");
		return;
	     end;

	     char_index = char_index + 1;
	end;

	if numeric then
	     if next_statement_label = 0 then
		call print_message (69, "0");
	     else
		last_label_line = source_line_number;
     end lex_label_field;

test_orphan_label:
     proc;

/* Declare error if there is an orphan statement label */

/* see if there is a left over statement label */
/* code moved from "get_line_image to prevent navy bug #1 */

	if next_statement_label ^= 0 then do;
	     source_line_number = last_label_line;
	     call print_message (131);		/* label without text */
	     source_line_number = line_number;
	     next_statement_label = 0;
	end;
     end test_orphan_label;
     end get_line_image;


get_new_character:
     procedure;

	char_value = current_character;		/* do not want current_character to have an alias */
	if binary (bit_value, 9, 0) > hbound (token_table, 1)
						/* non ASCII character */
	     then
	     char_type = 0;
	else
	     char_type = token_table (binary (bit_value, 9, 0));
     end get_new_character;

get_digits:
     procedure (digit_count);

/*	Program Specifications (get_digits)

     Inputs

     Output

     Description (get_digits)

     NOTE - This procedure modifies:
	EOS
	text_bit
*/

dcl      i fixed bin (18);
dcl      d_count fixed bin (18);
dcl      digit_count fixed bin (18);

	d_count = 0;

	lexing_a_token = TRUE;
	do while (lexing_a_token);
	     i = verify (rest_of_line, DIGIT) - 1;
	     if i = 0 then
		lexing_a_token = FALSE;
	     else do;
		if i < 0 then
		     i = length (rest_of_line);
		call skip_characters (i);
		d_count = d_count + i;
		if EOS then
		     lexing_a_token = FALSE;
		else if char_type ^= digits then
		     lexing_a_token = FALSE;
	     end;
	end;

	digit_count = d_count;
     end get_digits;

build_fortran_operator:
     procedure;

/*	Program Specifications (build_fortran_operator)

     Inputs

     Output

     Description (build_fortran_operator)
*/

dcl      i fixed bin (18);
dcl      sp_op_name (13) char (8) aligned int static options (constant)
	    init (".not.", ".and.", ".or.", ".eq.", ".ne.", ".lt.", ".gt.", ".le.", ".ge.", ".false.", ".true.",
	    ".eqv.", ".neqv.");
dcl      sp_op_type (13) bit (9) aligned int static options (constant)
	    init ("010000110"b, "010000111"b, "010001000"b, "010001001"b, "010001010"b, "010001011"b, "010001100"b,
	    "010001101"b, "010001110"b, "001000010"b, "001000011"b, "010010111"b, "010011000"b);

	lexing_a_token = TRUE;
	do while (lexing_a_token);
	     i = verify (rest_of_line, alphabetic) - 1;
	     if i = 0 then
		lexing_a_token = FALSE;
	     else do;
		if i < 0 then
		     i = length (rest_of_line);
		call skip_characters (i);
		if EOS then
		     lexing_a_token = FALSE;
		else if char_type ^= letters then
		     lexing_a_token = FALSE;
	     end;
	end;

	if EOS then do;
	     call print_message (116);		/* missing "." */
	     go to lex_next_token;
	end;

	if current_character ^= "." then do;
	     call print_message (116);		/* missing "." */
	     go to lex_next_token;
	end;

	call skip_characters (ONE);

	if token_length > length (sp_op_name (1)) then do;
	     call print_message (117, token_string);	/* unknown operator */
	     go to lex_next_token;
	end;

	substr (fast_lookup, 1, length (sp_op_name (1))) = token_string;

	do i = 1 to hbound (sp_op_name, 1) while (substr (fast_lookup, 1, length (sp_op_name (1))) ^= sp_op_name (i));
	end;

	if i > hbound (sp_op_name, 1) then do;
	     call print_message (117, token_string);	/* unknown operator */
	     go to lex_next_token;
	end;

	token_type = sp_op_type (i);
     end build_fortran_operator;

parse_exponent:
     procedure;

/*	Program Specifications (parse_exponent)

     Inputs

     Output

     Description (parse_exponent)
*/

	exp = 0;
	if EOS then do;
	     if token_type ^= dec_int then
		call store_real_constant;
	     return;
	end;
	if current_character = "d" | current_character = "D" then
	     token_type = double_const;
	else if current_character = "e" | current_character = "E" then
	     token_type = real_const;
	else if token_type = dec_int then
	     return;
	else do;
	     if t_scale > 0 | char_type ^= letters then
		call store_real_constant;
	     return;
	end;
	call skip_characters (ONE);

	if EOS then do;
	     call missing_exponent;
	     return;
	end;

	exp = token_length;

	if current_character = "+" then do;
	     operator_follows = FALSE;
	     translate_string = FALSE;		/* translation is no longer necessary */

	     call skip_characters (ONE);
	     exp = exp + 1;
	end;
	else if current_character = "-" then do;
	     operator_follows = FALSE;
	     translate_string = FALSE;		/* translation is no longer necessary */

	     call skip_characters (ONE);
	     exp = -token_length;
	end;

	if EOS then do;
	     call missing_exponent;
	     return;
	end;

	if char_type = digits then do;
	     call get_digits (ignore_value);
	     call store_real_constant;
	end;
	else if ^operator_follows then
	     call missing_exponent;

	return;


store_real_constant:
     procedure;

	operator_follows = FALSE;
	translate_string = FALSE;			/* translation is no longer necessary */

	const_count = const_count + 1;
	if const_count > hbound (constant_array, 1)	/* check for constant table overflow */
	then do;
	     if const_count = hbound (constant_array, 1) + 1
						/* only print message once */
		then
		call print_message (110, hbound (constant_array, 1) - bias);
	     go to lex_next_token;
	end;

	constant_array (const_count).prec = precision;
	constant_array (const_count).scale = t_scale;
	constant_array (const_count).exponent = exp;
	constant_array (const_count).length = token_length - 1;
	token_length = const_count;
     end store_real_constant;


missing_exponent:
     procedure;

	call print_message (118);
	exp = 0;
	call store_real_constant;
     end missing_exponent;
     end parse_exponent;

build_string:
     procedure (delimiter);

/*	Program Specifications (build_string)

     Inputs

     Output

     Description (build_string)
	Modified 01/28/77 to allow embedded delimiters in char strings.
*/

dcl      embedded bit (1) aligned;
dcl      delimiter char (1) aligned;
dcl      len fixed bin (18);
dcl      len_pic picture "zz9";
dcl      off fixed bin (18);
dcl      temp_str char (512);

	token_offset = statement_length + 1;
	token_length = -1;
	token_type = char_string;

	off = 1;					/* skip over initial delimiter */
	embedded = FALSE;				/* no embedded delimiters found */

	do while (TRUE);

	     len = index (substr (rest_of_line, off + 1), delimiter) + off;

	     if len = off				/* delimiter not found, add rest of line */
	     then do;
		call get_continuation_line ((max_fixed_bin_18));
						/* get next line */

		if EOS				/* oops, no more lines for us */
		then do;
		     call print_message (109);
		     call get_new_character;		/* prime the lex */
		     go to return_string;
		end;

		off = 0;				/* begin with first character */
	     end;

	     else do;				/* see if encountered delimiter terminates the string */
		if len = length (rest_of_line) then do; /* following char is on next line */

		     if extra_blanks > 0 then
			go to final_delimiter;	/* last char followed by blank, must be delim */

		     call get_continuation_line (0);	/* no blanks follow, so get next line */

		     if blank_cont_count > 0		/* line of blanks follow, so must be delim */
		     then do;
			len = 0;			/* Characters have already been skipped */
			go to final_delimiter;
		     end;

		     if EOS then do;
			token_length = token_length - 1;
						/* length does not include the delimiters */
			call get_new_character;	/* prime the lex */
			go to return_string;
		     end;

		     off, len = 0;			/* want the first char on the line */
		end;

		if substr (rest_of_line, len + 1, 1) ^= delimiter then do;
						/* the final delimiter, done */
final_delimiter:
		     call skip_characters (len);

		     token_length = token_length - 1;	/* length does not include the delimiters */
		     go to return_string;
		end;

		embedded = TRUE;			/* an embedded delimiter; remove one from the const */
		call skip_characters (len);		/* next char is obviously non-blank */

		token_length = token_length - 1;	/* remove first delimiter of the pair from */
		statement_length = statement_length - 1;/* from the constant's value */

		off = 1;				/* continue processing with second delimiter */
	     end;
	end;

/* loop cannot exit here */

return_string:
	if token_length = 0 then
	     call print_message (108);		/* string length is zero */
	else if embedded				/* for format statements, strings with embedded */
	     then
	     if substr (st_copy, 1, 6) = "format"	/* delimiters must be converted to hollerith consts */
	     then do;
		if token_length > 512		/* string is too long */
		then do;
		     call print_message (124, 512 - bias);
						/* token length too long */
		     token_length = 512;
		end;

		substr (temp_str, 1, token_length) = token_string;
						/* save str value */

		statement_length = token_offset - 1;	/* remove original string from buffer */

		len_pic = token_length;		/* build length field for hollerith const */
		off = verify (len_pic, WHITE);	/* first significant char */
		len = length (len_pic) - off + 1;	/* number of digits */

		if statement_length + len + 1 + token_length > length (st_copy)
						/* will it fit? */
		then do;
		     call print_message (111, length (st_copy) - bias);
						/* text buffer overflow */
		     go to abort_lex;
		end;

		substr (st_copy, statement_length + 1, len) = substr (len_pic, off, len);
		statement_length = statement_length + len + 1;
		substr (st_copy, statement_length, 1) = "h";

		token_offset = statement_length;	/* new offset */

		token_string = substr (temp_str, 1, token_length);
						/* move value back */
		statement_length = statement_length + token_length;
	     end;
     end build_string;
     end statement_lex;

convert_integer_constant:
     procedure (off, len) returns (bit (72) aligned);

/*	Program Specifications (convert_integer_constant)

     Inputs
	Arguments
	     off - Offset into the character string "st_copy" at which the character representation
		 of the value to be converted is stored.
	     len - Length of the string to be converted.

	Implicit Arguments
	     sign - (Declared in the procedure parse_source.) This variable is used to simulate
		a condition handler for fixedoverflow in order to allow the conversion of the
		value -34359738368.  If "sign" has the value "minus", the conversion succeeds;
		otherwise the conversion fails. If "sign" is used to create a negative value,
		the procedure sets the value of "sign" to "ZERO" to prevent another negation.

     Output
	A 36-bit binary representation of the constant stored left justified in a 72-bit field.
	The remaining bits are undefined.
*/

dcl      based_dec char (12) aligned based (addr (dec_value));
dcl      dec_value fixed decimal (11);
dcl      i fixed bin (18);
dcl      int_bits bit (72) aligned;
dcl      j fixed bin (18);
dcl      max_value fixed decimal (11) int static options (constant) init (34359738368);
dcl      len fixed bin (18);
dcl      off fixed bin (18);

	j = off + verify (substr (st_copy, off + 1, len), "0") - 1;
	if j < off then
	     return (b72_zero);
	i = len - (j - off);

	if i >= length (based_dec) then do;
	     call print_message (119, substr (st_copy, off + 1, len));
						/* fixed overflow */
	     return (b72_zero);
	end;

	dec_value = 0;
	substr (based_dec, length (based_dec) - i + 1, i) = substr (st_copy, j + 1, i);

	if dec_value >= max_value			/* i.e., fixedoverflow will occur. */
	     then
	     if (dec_value = max_value) & (sign = minus) then do;
		sign = ZERO;
		return (b72_one);
	     end;
	     else do;
		call print_message (119, substr (st_copy, off + 1, len));
						/* fixed overflow */
		return (b72_zero);
	     end;

	addr (int_bits) -> based_integer = dec_value;
	return (int_bits);
     end convert_integer_constant;

negate_constant:
     procedure (in_const) returns (fixed bin (18));

dcl      in_const fixed bin (18);

	go to negate_code (addr (OS (in_const)) -> constant.data_type);

negate_code (1):					/* integer */
	if addr (work) -> based_integer = -34359738368 then do;
	     call print_message (137, in_const);
	     return (in_const);
	end;
	else do;
	     addr (work) -> based_integer = -addr (work) -> based_integer;
	     return (create_constant (int_mode, work));
	end;

negate_code (2):					/* real */
	unspec (addr (work) -> based_real (1)) =
	     negate_round (real_mode) (6, (unspec (addr (work) -> based_real (1))), "0"b, 0);
	return (create_constant (real_mode, work));

negate_code (3):					/* double precision */
	unspec (addr (work) -> based_double) =
	     negate_round (dp_mode) (6, (unspec (addr (work) -> based_double)), "0"b, 0);
	return (create_constant (dp_mode, work));

negate_code (4):					/* complex */
	unspec (addr (work) -> based_real (1)) =
	     negate_round (real_mode) (6, (unspec (addr (work) -> based_real (1))), "0"b, 0);
	unspec (addr (work) -> based_real (2)) =
	     negate_round (real_mode) (6, (unspec (addr (work) -> based_real (2))), "0"b, 0);
	return (create_constant (cmpx_mode, work));
     end negate_constant;

convert_real_constant:
     procedure (offset) returns (bit (72) aligned);

dcl      dec_exp fixed dec (3);
dcl      mantissa fixed dec (30) based (addr (ext_float_dec));
dcl      exp fixed bin (18);
dcl      indx fixed bin (18);
dcl      l_significant_digits fixed bin (18);
dcl      ldigits fixed bin (18);
dcl      ldigits_parm fixed bin (18);
dcl      lsd_parm fixed bin (18);
dcl      offset fixed bin (18);
dcl      r_significant_digits fixed bin (18);
dcl      rdigits fixed bin (18);
dcl      rdigits_parm fixed bin (18);
dcl      rsd_parm fixed bin (18);
dcl      real_bits bit (72) aligned;

dcl      1 ext_float_dec aligned,
	 2 sign char (1) unaligned,
	 2 digits char (30) unaligned,
	 2 expnt fixed bin (8) unaligned;

	rdigits = constant_array (offset).scale;
	ldigits = constant_array (offset).prec - rdigits;

	if ldigits > 0 then
	     l_significant_digits = length (ltrim (substr (token_string, 1, ldigits), "0"));
	else
	     l_significant_digits = 0;
	if rdigits > 0 then
	     r_significant_digits = length (rtrim (substr (token_string, ldigits + 2, rdigits), "0"));
	else
	     r_significant_digits = 0;		/* trim off the extraneous zeros */
	goto convert_constant;

convert_real_constant_from_real:
     entry (offset, rdigits_parm, ldigits_parm, rsd_parm, lsd_parm) returns (bit (72) aligned);

	rdigits = rdigits_parm;
	ldigits = ldigits_parm;
	r_significant_digits = rsd_parm;
	l_significant_digits = lsd_parm;

convert_constant:
	exp = constant_array (offset).exponent;
	mantissa = 0;
	if l_significant_digits + r_significant_digits > length (digits) then do;
	     call print_message (120, length (digits) - bias, token_string);
						/* constant too long */
	     return (b72_one);
	end;

	if l_significant_digits > 0 & ldigits > 0 then
	     substr (digits, 1, l_significant_digits) = ltrim (substr (token_string, 1, ldigits), "0");
	if r_significant_digits > 0 & rdigits > 0 then
	     substr (digits, l_significant_digits + 1, r_significant_digits) =
		rtrim (substr (token_string, ldigits + 2, rdigits), "0");

	if exp ^= 0 then do;
	     dec_exp = 0;
	     if exp < 0 then do;
		exp = -exp;
		substr (addr (dec_exp) -> based_char, 1, 1) = "-";
	     end;

	     indx = token_length - exp;
	     if indx > 3 then do;
		call print_message (121, token_string); /* exponent too large */
		return (b72_one);
	     end;

	     substr (addr (dec_exp) -> based_char, 5 - indx, indx) = substr (token_string, exp + 1, indx);
	     exp = dec_exp;
	end;

	exp = exp + l_significant_digits - length (digits);

	if mantissa = 0 then
	     return (b72_one);

	if exp > 255 then
	     call print_message (121, token_string);
	else if exp < -256 then
	     call print_message (122, token_string);
	else do;
	     expnt = exp;

/*THE NEXT FLOAT DEC CONSTANTS YOU SEE ARE THE LARGEST AND SMALLEST CONVERTIBLE FLOATING POINT DECIMAL MANTISSA'S */
	     if shared_structure.user_options.hfp then do;
		if (mantissa > 837987995621412318632521721850 & expnt = 123) | (expnt > 123) then
		     call print_message (121, token_string);
		else if (mantissa < 745834073120020674248233039307 & expnt = -184) | (expnt < -184) then
		     call print_message (122, token_string);
		else do;
		     call assign_ (addr (real_bits), 2 * ft_hex_double_dtype, 63, addr (ext_float_dec),
			2 * real_flt_dec_extended_dtype, 30);
		     return (real_bits);
		end;
	     end;
	     else do;
		if (mantissa > 170141183460469231713240559642 & expnt = 9) | (expnt > 9) then
		     call print_message (121, token_string);
		else if (mantissa < 146936793852785938496092067153 & expnt = -68) | (expnt < -68) then
		     call print_message (122, token_string);
		else do;
		     call assign_ (addr (real_bits), 2 * ft_double_dtype, 63, addr (ext_float_dec),
			2 * real_flt_dec_extended_dtype, 30);
		     return (real_bits);
		end;
	     end;
	end;
	return (b72_one);
     end convert_real_constant;

get_next_token:
     procedure (action, sym_index);

/*	Program Specifications (get_next_token)

     Inputs

     Output

     Description (get_next_token)
	current_token
	token
	token_offset
	token_length
*/

dcl      action fixed bin (2);
dcl      l_significant_digits fixed bin (18);
dcl      ldigits fixed bin (18);
dcl      paren_level fixed bin (18);
dcl      r_significant_digits fixed bin (18);
dcl      rdigits fixed bin (18);
dcl      sym_index fixed bin (18);
dcl      symtab_action fixed bin (2);
dcl      temp fixed bin (18);

	current_token = current_token + 1;

	named_constant_ptr_valid = FALSE;
	token = token_list (current_token).type;

	if token = ident then do;
	     token_offset = token_list (current_token).offset;
	     token_length = token_list (current_token).length + 1;
	     symbol_length = token_length;
	     substr (full_name, 1, symbol_length) = token_string;

	     symtab_action = action;
	     if symtab_action = ignore_symtab_entry then
		return;

	     call find_symbol_index (symbol_length, temp, symtab_action, ignore_value);

	     if temp ^= 0 then
		if addr (OS (temp)) -> symbol.named_constant then do;
		     named_constant_ptr = addr (OS (temp));
		     named_constant_ptr_valid = TRUE;
		     temp = addr (OS (temp)) -> symbol.initial;
		     token = constant_type (addr (OS (temp)) -> constant.data_type);

		     if token ^= char_string then
			work = addr (OS (temp)) -> constant.value;
		end;
	     sym_index = temp;
	end;

	else if token & is_constant then do;
	     token_offset = token_list (current_token).offset;
	     token_length = token_list (current_token).length + 1;

	     go to convert (binary (substr (token, 5, 5), 5, 0));
						/* actually case of token_type */
	end;
	return;


get_next_token$operator:
     entry;

	current_token = current_token + 1;
	token = token_list (current_token).type;
	return;


get_next_token$paren_operator:
     entry;

	current_token = current_token + 1;
	token = token_list (current_token).type;
	if token = left_parn then do;
	     paren_level = 1;
	     do temp = current_token + 1 to last_token while (paren_level > 0);
		if token_list (temp).type = left_parn then
		     paren_level = paren_level + 1;
		else if token_list (temp).type = right_parn then
		     paren_level = paren_level - 1;
		else if paren_level = 1 & token_list (temp).type = colon then do;
		     token = substr_left_parn;
		     return;
		end;
	     end;					/* token search loop */
	end;					/* left parenthesis case */
	return;


get_next_token$label:
     entry (action, sym_index);

	current_token = current_token + 1;
	token = token_list (current_token).type;

	if token = dec_int then do;
	     token_offset = token_list (current_token).offset;
	     token_length = token_list (current_token).length + 1;

	     work = convert_integer_constant (token_offset, token_length);
	     return;
	end;

	else if token & is_operator then
	     return;

	else if token = ident then do;
	     token_offset = token_list (current_token).offset;
	     token_length = token_list (current_token).length + 1;
	     symbol_length = token_length;
	     substr (full_name, 1, symbol_length) = token_string;

	     call find_symbol_index (symbol_length, temp, force_symtab_entry, ignore_value);

	     if addr (OS (temp)) -> symbol.named_constant /* named const cannot be label value */
		then
		call print_message (142, substr (full_name, 1, symbol_length));

	     sym_index = temp;
	     return;
	end;

	else if token = char_string then do;
	     token_offset = token_list (current_token).offset;
	     token_length = token_list (current_token).length + 1;
	     sym_index = create_char_constant (token_string);
	     return;
	end;

	go to missing_label;


/* Case		Character String */
convert (1):
	sym_index = create_char_constant (token_string);
	return;

/* Case		False */
convert (2):
	token = logical_const;
	work = FALSE;
	sym_index = create_constant (logical_mode, work);
	return;

/* Case		True */
convert (3):
	token = logical_const;
	work = TRUE;
	sym_index = create_constant (logical_mode, work);
	return;

/* Case		Label */
convert (4):
	if token_length > 1 then
	     work = convert_integer_constant (token_offset + 1, token_length - 1);
	else
	     addr (work) -> based_integer = 0;

	sym_index = enter_label (executable_label, (addr (work) -> based_integer), GOTO_REF);
	return;

/* Case		Octal */
convert (5):
	call print_message (229);			/* constant type not implemented */
	return;

/* Case		Integer */
convert (6):
	work = convert_integer_constant (token_offset, token_length);
	sym_index = create_constant (int_mode, work);
	return;

/* Case		Real */
convert (7):
	temp = token_length;
	token_length = constant_array (temp).length + 1;

	rdigits = constant_array (temp).scale;
	ldigits = constant_array (temp).prec - rdigits;
	if ldigits > 0 then
	     l_significant_digits = length (ltrim (substr (token_string, 1, ldigits), "0"));
	else
	     l_significant_digits = 0;
	if rdigits > 0 then
	     r_significant_digits = length (rtrim (substr (token_string, ldigits + 2, rdigits), "0"));
	else
	     r_significant_digits = 0;		/* trim off the extraneous zeros */
	if l_significant_digits + r_significant_digits > max_prec_single
						/* too many digits for single precision (after trimming extraneous zeros) */
	then do;					/* so, convert to double precision, with warning */
	     if ^from_data_parser then
		call print_message (36, token_string, max_prec_single - bias);
	     token = double_const;
	     go to convert_to_dp;
	end;

	work = convert_real_constant_from_real (temp, rdigits, ldigits, r_significant_digits, l_significant_digits);
	unspec (addr (work) -> based_real (1)) =
	     conv_round (real_mode, dp_mode) ((unspec (addr (work) -> based_double)), 0);
	sym_index = create_constant (real_mode, work);
	return;

/* Case		Double Precision */
convert (8):
	temp = token_length;
	token_length = constant_array (temp).length + 1;

convert_to_dp:
	work = convert_real_constant (temp);
	sym_index = create_constant (dp_mode, work);
	return;

/* Case		Complex */
convert (9):
	call print_message (229);			/* complex constant cannot be handled by get_next_token */
	return;

     end get_next_token;

split_token:
     procedure (length, indx, must_be_one);

/*	Program Specifications (split_token)

     Inputs

     Output

     Description (split_token)

     NOTE - This procedure modifies:
	token_list
	first_token
*/

dcl      j fixed bin (18);
dcl      indx fixed bin (18);
dcl      len fixed bin (18);
dcl      length fixed bin (18);
dcl      must_be_one bit (1) aligned;
dcl      off fixed bin (18);

dcl      1 split_structure aligned based (addr (st_copy)),
	 2 pad char (off) unaligned,
	 2 tkn char (len) unaligned;

	off, token_list (indx).offset = token_list (indx).offset + length;
	token_list (indx).length = token_list (indx).length - length;
	len = token_list (indx).length + 1;

	if len > 0 then do;
	     j = verify (tkn, DIGIT) - 1;
	     if j ^= 0 then
		if j < 0 then do;
		     j = len;
		     len = 0;
		end;
		else do;
		     if must_be_one then
			call print_message (52, tkn); /* extraneous characters */
		     if indx = first_token then
			first_token = first_token - 1;
		     token_list (indx).offset = token_list (indx).offset + j;
		     token_list (indx).length = token_list (indx).length - j;
		end;

	     if len - j > 0 then
		if verify (substr (tkn, j + 1, 1), alphabetic) ^= 0 then do;
		     call print_message (52, substr (tkn, j + 1));
		     if j > 0 then
			indx = indx - 1;		/* extraneous characters */
		end;
		else if j > 0 then
		     indx = indx - 1;
	     if j > 0 then do;
		token_list (indx).type = dec_int;
		token_list (indx).offset = off;
		token_list (indx).length = j - 1;
	     end;
	end;
	else do;
	     token_list (indx).type = no_token;
	     if indx = first_token then
		first_token = first_token + 1;
	     indx = indx + 1;
	end;
     end split_token;

err_string:
     procedure () returns (char (512) varying);		/* makes a printable string from the current token */

dcl      TKN bit (9) aligned;				/* to keep token a padded ref */
dcl      op_chars (22) char (4) aligned int static options (constant)
	    init ("+", "-", "*", "/", "**", "not", "and", "or", "eq", "ne", "lt", "gt", "le", "ge", "=", ",", "(", ")",
	    "'", ":", "//", "(");

	if current_token > last_token then
	     return ("the end of this statement");

	TKN = token_list (current_token).type;
	token_offset = token_list (current_token).offset;
	token_length = token_list (current_token).length + 1;

	if TKN = ident then
	     return ("the name " || token_string);

	else if TKN = octal_const then
	     return ("the octal constant " || token_string);

	else if TKN & is_constant then do;
	     if TKN = real_const | TKN = double_const then
		token_length = constant_array (token_length).length + 1;

	     return ("the constant " || token_string);
	end;

	else if TKN & is_operator then
	     return ("the operator " || op_chars (binary (substr (TKN, 5, 5), 5, 0)));

	else
	     return ("the token " || char (TKN) || " (compiler error)");
     end err_string;

/*Check to ensure no duplicate entries. */

check_entry_duplication:
     proc;

/* Routine to scan through list of entry points built by                     */
/* "declaration_processor" (first_entry_name, last_entry_name).  The method  */
/* used is a simple decreasing length scan and is not in the least elegant.  */
/* If a duplication is encountered error 428 is signaled.		       */

dcl      1 master like symbol based (addr (OS (master_index)));
dcl      1 slave like symbol based (addr (OS (slave_index)));
dcl      master_index fixed bin (18);
dcl      slave_index fixed bin (18);

	master_index = first_entry_name;
	do while (master_index ^= 0);			/* scan through list */
	     slave_index = master.next_symbol;
	     do while (slave_index ^= 0);		/* checking dups */
		if slave.name = master.name then
		     call print_message (428, slave.name);
		slave_index = slave.next_symbol;
	     end;
	     master_index = master.next_symbol;
	end;
     end check_entry_duplication;

     end parse_source;
     end ext_parse;

