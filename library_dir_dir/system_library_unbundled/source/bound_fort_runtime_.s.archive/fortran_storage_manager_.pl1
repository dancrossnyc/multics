/****^  ******************************************
        *                                        *
        * Copyright, (C) Honeywell Limited, 1983 *
        *                                        *
        ****************************************** */



/****^  HISTORY COMMENTS:
  1) change(86-08-20,DGHowe), approve(86-08-20,MCR7391),
     audit(86-08-01,Schroth), install(86-11-20,MR12.0-1222):
     removed unrequired declarations.
                                                   END HISTORY COMMENTS */


/* format: style3,^delnl,linecom */
fortran_storage_manager_:
fsm_:
     proc options (support);

/*  Author:  H. Hoover,  University of Calgary,  82-08-12.                   */
/*                                                                           */
/*  Modified:                                                                */
/*     84-10-10 by MM - 442:  Set 256K switch once per process.  Do not set  */
/*        it prior to creating a segment.			       */
/*     83-07-10 by TO:  Set 256K switch prior to creating a 256K segment     */
/*     83-06-16 by TO:  Use condition_info_header, have options (support).   */
/*     83-02-15 by TO:  Create get_vla_segnos entry to return information to */
/*	run_ as to the segment numbers created for storage.	       */
/*     83-01-19 by TO:  Allow storage directory per-ring.                    */
/*     83-01-19 by TO:  Set maximum length of segments from                  */
/*        pl1_operators_$VLA_words_per_seg_ for general runtime use.         */
/*     83-01-19 by TO:  Set safety switch for fsm_dir, fsm_info and fsm_segs.*/
/*     82-10-14 by HH:  Allow storage to be allocated from anywhere in the   */
/*        storage heirarchy (rather than just the process directory) and     */
/*        allow multiple processes to share the same pool of free segments.  */

/*  Function:  to allocate, free and list storage in connection with large   */
/*     and very large 'fortran' arrays.                                      */

/*  Error processing:                                                        */
/*                                                                           */
/*  The entry points in this procedure do not return a status code if an     */
/*  error occurs.  Instead, the condition 'fortran_storage_manager_error' is */
/*  signalled with a description of what the error is.  If the user chooses  */
/*  to restart, we assume he has done something to fix the problem and we    */
/*  retry the operation that detected the error.  If the problem is not      */
/*  fixed, we again signal the condition 'fortran_storage_manager_error'.    */
/*  This continues ad nauseum until either the user fixes the problem or     */
/*  gives up and releases.					       */

dcl	get_lock_id_	entry returns (bit (36) aligned);

dcl	False		bit (1) static options (constant) init ("0"b),
	True		bit (1) static options (constant) init ("1"b),
	fsm_dir_name_master char (8) static options (constant) init ("fsm_dir_"),
	fsm_info_name	char (13) static options (constant) init ("fsm_info.fsm_");
     

dcl	01 fsm_info	aligned based (fsm_info_ptr),
	  02 lock		bit (36),			/*  Lock word.  */
	  02 seg_cnt	fixed bin,		/*  Total number of allocated and free segments.  */
	  02 seg		(fsm_info.seg_cnt),
	    03 owning_process
			bit (36),			/*  Lock ID for owning process.  ""b => Free.  */
	    03 owner	ptr unal,			/*  Pointer to owner of this segment.  */
	    03 first_seg_in_group
			fixed bin,		/*  Index of first seg in this group.  */
	    03 next_seg_in_group
			fixed bin,		/*  Index of next seg in this group.  */
	    03 seg_num	fixed bin;		/*  Number under which segment is initiated.  */

dcl	fsm_dir_path	char (168) static init (""),
	fsm_info_path	char (168) static init (""),
	fsm_info_ptr	ptr static init (null),
	fsm_info_ptr_valid	bit (1) static init ("0"b);

dcl	me		ptr init (codeptr (fsm_)),
	my_process	bit (36) aligned init (get_lock_id_ ());


	return;					/*  Just ignore calls to the main entry point.  */

alloc:
     entry (num_segs_desired, owner, first_seg_ptr);

/*  Function:  to allocate a specified number of segments with consecutive   */
/*     segment numbers.  The segments are created as needed.                 */

/*  Arguments:                                                               */
/*                                                                           */
/*  num_segs_desired  (Input)                                                */
/*     is the number of segments to be allocated.                            */
/*                                                                           */
/*  owner  (Input)                                                           */
/*     is the address of a location which is considered to own the segments  */
/*     to be allocated.  It is used to identify the segments which are to be */
/*     deallocated by a call to the 'free' routine.                          */
/*                                                                           */
/*  first_seg_ptr  (Output)                                                  */
/*     is the address of the base of the first segment allocated.  (The      */
/*     addresses of the other segments are obtained by incrementing the      */
/*     segment number portion of the address of the first segment.)  The     */
/*     value 'null' is returned if 'num_segs_desired' is less than 1 or if   */
/*     'owner' is 'null' or the 'fortran_storage_manager_' entry point.      */

/*  Error handling:                                                          */
/*                                                                           */
/* If an error occurs during allocation, the 'fortran_storage_manager_error' */
/*   condition is signalled.  If the user does not handle the condition, the */
/*   system  will  display a diagnostic describing the error that caused the */
/*   condition  to  be  signalled  and  establish  a new command level.  The */
/*   'start'  command will cause the code that failed to be retried.  If the */
/*  problem which caused the failure has been fixed, allocation will proceed */
/*   as  though  the  error  had  never  occurred;  otherwise, the condition */
/*  'fortran_storage_manager_error' will be signalled again.	       */
/*                                                                           */
/*  There is one error that can occur which the user need only restart the   */
/*  allocation in order to correct:  'The segment number is in use.'  This   */
/*  should only occur if the user suspends the allocation process with a     */
/*  'quit' signal, does something that requires a new segment to be made     */
/*  known, then restarts the allocation.  If the new segment is made known   */
/*  under a segment number that was to be used for one of the segments being */
/*  allocated, the above error occurs.  Restarting after such an error will  */
/*  cause a new set of sequential segment numbers to be chosen.              */

dcl	num_segs_desired	fixed bin,
	owner		ptr,
	first_seg_ptr	ptr;

dcl	hcs_$initiate	entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35)),
	hcs_$terminate_file entry (char (*), char (*), fixed bin (1), fixed bin (35)),
	pathname_		entry (char (*), char (*)) returns (char (168));

/* builtins */

dcl       (addr, addrel, baseno, baseptr, before, bin, char, codeptr,
	fixed, hbound, index, lbound, length, ltrim, ptr, rel, rtrim,
	size, substr, sum, unspec, verify, null)		builtin;

dcl	cleanup		condition;

dcl	first_seg_in_group	fixed bin,
	first_seg_num	fixed bin,
	prev_seg_in_group	fixed bin,
	seg_idx		fixed bin,
	seg_num		fixed bin,
	status		fixed bin (35),
	try_again		bit (1);


/*  Verify that the input arguments are valid.  */

	first_seg_ptr = null;
	if num_segs_desired <= 0 | owner = null | owner = me
	then return;

	on cleanup call release_fsm_info;
	call appropriate_fsm_info;

/*  Allocate the requested segments, specifying this object segment as the   */
/*  owner, so that if we have to do a clean up, we will know which segments  */
/*  we must deallocate.                                                      */

	try_again = True;
	do while (try_again);
	     try_again = False;
	     call pick_first_seg_num (num_segs_desired, first_seg_num);
	     do seg_num = first_seg_num to first_seg_num + num_segs_desired - 1 while (^try_again);
		call pick_seg (seg_idx);
		if seg_num = first_seg_num
		then first_seg_in_group = seg_idx;
		else fsm_info.seg (prev_seg_in_group).next_seg_in_group = seg_idx;
		fsm_info.seg (seg_idx).owning_process = my_process;
		fsm_info.seg (seg_idx).owner = me;
		fsm_info.seg (seg_idx).first_seg_in_group = first_seg_in_group;
		fsm_info.seg (seg_idx).next_seg_in_group = 0;
		fsm_info.seg (seg_idx).seg_num = seg_num;
		call hcs_$initiate (fsm_dir_path, seg_name (seg_idx), "", 1, 0, baseptr (seg_num), status);
		if status ^= 0
		then do;
			call signal_fsm_error (status,
			     "(Trying to initiate " || pathname_ (fsm_dir_path, seg_name (seg_idx))
			     || " as segment "
			     || octal_representation (seg_num) || ")");
			do seg_idx = first_seg_in_group repeat fsm_info.seg (seg_idx).next_seg_in_group
			     while (seg_idx ^= 0);
			     call hcs_$terminate_file (fsm_dir_path, seg_name (seg_idx), 0, status);
			end;
			try_again = True;
		     end;
		prev_seg_in_group = seg_idx;
	     end;
	end;

/*  Transfer ownership of the allocated segments to the caller.  */

	do seg_idx = 1 to fsm_info.seg_cnt;
	     if fsm_info.seg (seg_idx).owning_process = my_process & fsm_info.seg (seg_idx).owner = me
	     then fsm_info.seg (seg_idx).owner = owner;
	end;
	first_seg_ptr = baseptr (first_seg_num);
	call release_fsm_info;
	return;

free:
     entry (owner);

/*  Function:  to free all segments previously allocated to a specified      */
/*     owner.                                                                */

/*  Arguments:                                                               */
/*                                                                            */
/*  owner  (Input)                                                           */
/*     is the address of the location that was specified (at allocation) to  */
/*     be the owner of the segments that are now desired to be deallocated.  */
/*     If there are no allocated segments with the specified owner, the      */
/*     routine just returns, without comment.                                */

dcl	hcs_$truncate_file	entry (char (*), char (*), fixed bin (19), fixed bin (35));

	on cleanup call release_fsm_info;
	call appropriate_fsm_info;

	do seg_idx = 1 to fsm_info.seg_cnt;
	     if fsm_info.seg (seg_idx).owning_process = my_process & fsm_info.seg (seg_idx).owner = owner
	     then do;
		     call hcs_$terminate_file (fsm_dir_path, seg_name (seg_idx), 0, status);
		     call hcs_$truncate_file (fsm_dir_path, seg_name (seg_idx), 0, status);
		     unspec (fsm_info.seg (seg_idx)) = ""b;
		end;
	end;
	call release_fsm_info;
	return;

get_owner:
     entry (seg_ptr, owner);

/*  Function:  to return the owner of a specified managed segment.  If the   */
/*     specified segment is free or is not one of those managed by 'fsm_',   */
/*     'null' is returned.                                                   */

/*  Arguments:                                                               */
/*                                                                           */
/*  seg_ptr  (Input)                                                         */
/*     is a pointer to any location in the segment whose owner is desired.   */

dcl	seg_ptr		ptr;

	on cleanup call release_fsm_info;
	call appropriate_fsm_info;
	do seg_idx = 1 to fsm_info.seg_cnt
	     while (fsm_info.seg (seg_idx).owning_process ^= my_process
	     | fsm_info.seg (seg_idx).seg_num ^= bin (baseno (seg_ptr)));
	end;
	if seg_idx <= fsm_info.seg_cnt
	then owner = fsm_info.seg (seg_idx).owner;
	else owner = null;
	call release_fsm_info;
	return;

get_vla_segnos:
     entry (segment_map_bits);

/*  Function:  to return a bit array with bits set for each segment created  */
/*     by fortran_storage_manager_ in this process.		       */

/*  Arguments:                                                               */
/*                                                                           */
/*  segment_map_bits (Input/Output)                                          */
/*     is an array (*) of bits which is passed in.  This routine will set    */
/*     bits corresponding to the segment numbers of external storage segments*/

dcl	segment_map_bits	(*) bit (1);

	on cleanup call release_fsm_info;
	call appropriate_fsm_info;

/*   Scan the groups of segments allocated to this process.                  */

	do seg_idx = 1 to fsm_info.seg_cnt;
	     if fsm_info.owning_process (seg_idx) = my_process
	     then segment_map_bits (seg_idx) = "1"b;
	end;
	call release_fsm_info;
	return;

list_fortran_storage:
lfs:
     entry;

/*  Function:  to list (on the 'user_output' switch) the segments which are  */
/*     currently allocated to this process.                                  */

dcl	ioa_		entry options (variable);

dcl	group_cnt		fixed bin;


	on cleanup call release_fsm_info;
	call appropriate_fsm_info;

/*  Count the number of groups of segments that are allocated to this        */
/*  process.                                                                 */

	group_cnt = 0;
	do seg_idx = 1 to fsm_info.seg_cnt;
	     if fsm_info.owning_process (seg_idx) = my_process & fsm_info.first_seg_in_group (seg_idx) = seg_idx
	     then group_cnt = group_cnt + 1;
	end;

/*  If there are any segments allocated to this process, list them by owner  */
/*  and group.                                                               */

	if group_cnt = 0
	then call ioa_ ("No segments in ^a allocated to this process.", fsm_dir_path);
	else do;
		call ioa_ ("Segments in ^a allocated to this process:", fsm_dir_path);
		call list_groups (group_cnt, my_process);
	     end;
	call release_fsm_info;
	return;

appropriate_fsm_info:
     proc;

/*  Function:  to find and lock for this process 'fsm_info'.  'fsm_info' and */
/*     its containing directory will be created if necessary.                */

/*  Global arguments:                                                        */
/*                                                                           */
/*  fsm_dir_name_master  (Input)                                             */
/*     is the name of the directory where the segment on which 'fsm_info' is */
/*     based resides. (Ring number will be added later to create the dir.)   */
/*                                                                           */
/*  fsm_dir_path  (Output)                                                   */
/*     is the absolute pathname of the directory where the segment on which  */
/*     'fsm_info' is based resides.                                          */
/*                                                                           */
/*  fsm_info_name  (Input)                                                   */
/*     is the name of the segment on which 'fsm_info' is based.              */
/*                                                                           */
/*  fsm_info_ptr  (Output)                                                   */
/*     is the address of the base of the segment on which 'fsm_info' is      */
/*     based.                                                                */

dcl	error_table_$bad_segment
			fixed bin (35) ext,
	error_table_$invalid_lock_reset
			fixed bin (35) ext,
	error_table_$moderr fixed bin (35) ext,
	error_table_$noentry
			fixed bin (35) ext,
	error_table_$notadir
			fixed bin (35) ext,
	error_table_$nomatch
			fixed bin (35) ext;

dcl	cu_$level_get	entry returns (fixed bin (3)),
	get_group_id_$tag_star
			entry returns (char (32)),
	get_system_free_area_
			entry returns (ptr),
	hcs_$add_acl_entries
			entry (char (*), char (*), ptr, fixed bin, fixed bin (35)),
	hcs_$append_branchx
			entry (char (*), char (*), fixed bin (5), (3) fixed bin (6), char (*), fixed bin (1),
			fixed bin (1),
			fixed bin (24), fixed bin (35)),
	hcs_$make_seg	entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35)),
	hcs_$set_safety_sw	entry (char (*), char (*), bit (1), fixed bin (35)),
	hcs_$set_256K_switch
			entry (bit (2) aligned, bit (2) aligned, fixed bin (35)),
	hcs_$star_	entry (char (*), char (*), fixed bin (2), ptr, fixed bin, ptr, ptr, fixed bin (35)),
	hcs_$status_minf	entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24), fixed bin (35)),
	pl1_operators_$VLA_words_per_seg_
			fixed bin (19) external,
	set_lock_$lock	entry (bit (36) aligned, fixed bin, fixed bin (35)),
	sys_info$max_seg_size
			fixed bin (35) ext;

dcl	cleanup		condition;

dcl	Chase_links	fixed bin (1) static options (constant) init (1),
	Max_wait_time	fixed bin static options (constant) init (120);

dcl	01 acl		aligned,
	  02 access_name	char (32),
	  02 modes	bit (36),
	  02 xmodes	bit (36),
	  02 status	fixed bin (35);

dcl	bit_count		fixed bin (24),
	fsm_dir_dir_path	char (168),
	fsm_dir_name	char (32),
	i		fixed bin,
	max_seg_idx	fixed bin,
	primary_name	char (32),
	seg_cnt		fixed bin,
	seg_idx		fixed bin,
	status		fixed bin (35),
	system_free_area_ptr
			ptr init (null),
	type		fixed bin (2);


dcl	system_free_area	area based (system_free_area_ptr);

dcl	get_ring_		entry () returns (fixed bin (3));


/*  If  the  flag 'fsm_info_ptr_valid' is false, we must find 'fsm_info' and */
/*   store the address of its base in 'fsm_info_ptr'.  If 'fsm_info' doesn't */
/*  exist, we must create it (and possibly its containing directory).  If we */
/*   are  unable  to  do this, we signal the 'fortran_storage_manager_error' */
/*   condition  with a description of the problem.  If the user restarts us, */
/*   we  assume  he  has  done  something to correct the problem, and we try */
/*  again.						       */

	if ^fsm_info_ptr_valid
	then do;
		if pl1_operators_$VLA_words_per_seg_ > sys_info$max_seg_size
		then do;
			call hcs_$set_256K_switch ("11"b, (""b), status);
			if status ^= 0
			then call signal_fsm_error (status, "Cannot set 256K switch");
		     end;
		fsm_info_ptr = null;
		fsm_dir_name = fsm_dir_name_master || ltrim (char (get_ring_ ()));
		do while (fsm_info_ptr = null);
		     call get_fsm_dir_dir_path (fsm_dir_dir_path);
		     fsm_dir_path = pathname_ (fsm_dir_dir_path, fsm_dir_name);
		     fsm_info_path = pathname_ (fsm_dir_path, fsm_info_name);
		     call hcs_$status_minf (fsm_dir_dir_path, fsm_dir_name, Chase_links, type, bit_count, status);
		     if status = 0
		     then if type = star_DIRECTORY & bit_count = 0
			then do;			/*  Find 'fsm_info', creating it if necessary.  */
				call hcs_$make_seg (fsm_dir_path, fsm_info_name, "", RW_ACCESS_BIN, fsm_info_ptr,
				     status);
				if status = error_table_$moderr
				then do;		/*  Segment exists, but we don't have access. */
					acl.access_name = get_group_id_$tag_star ();
					acl.modes = RW_ACCESS;
					acl.xmodes = ""b;
					call hcs_$add_acl_entries (fsm_dir_path, fsm_info_name, addr (acl), 1,
					     status);
					if status = 0
					then call hcs_$initiate (fsm_dir_path, fsm_info_name, "", 0, 0,
						fsm_info_ptr, status);
				     end;
				if fsm_info_ptr = null
				then call signal_fsm_error (status, fsm_info_path);
			     end;
			else call signal_fsm_error (error_table_$notadir, fsm_dir_path);
		     else if status = error_table_$noentry
		     then do;			/*  Create 'fsm_dir' and 'fsm_info'.  */
			     call hcs_$append_branchx (fsm_dir_dir_path, fsm_dir_name, SMA_ACCESS_BIN,
				cu_$level_get (),
				get_group_id_$tag_star (), 1, 0, 0, status);
			     if status = 0
			     then do;		/*  Create 'fsm_info'.  */
				     call hcs_$set_safety_sw (fsm_dir_dir_path, fsm_dir_name, "1"b, status);
				     call hcs_$make_seg (fsm_dir_path, fsm_info_name, "", RW_ACCESS_BIN,
					fsm_info_ptr, status);
				     if fsm_info_ptr = null
				     then call signal_fsm_error (status, fsm_info_path);
				     call hcs_$set_safety_sw (fsm_dir_dir_path, fsm_info_name, "1"b, status);
				end;
			     else call signal_fsm_error (status, fsm_dir_path);
			end;
		     else call signal_fsm_error (status, fsm_dir_path);
		end;
	     end;

/*  We  now have a pointer to 'fsm_info'.  However, we cannot use 'fsm_info' */
/*  until we lock it so that we are safe from some other process altering it */
/*   while  we use it.  If some other process is currently using it, we must */
/*   wait  for that process to unlock it.  If that process doesn't unlock it */
/*   in  a  reasonable  time,  we signal the 'fortran_storage_manager_error' */
/*   condition, indicating that this has occurred.  If the user restarts us, */
/*  we try again.						       */

	status = 1;
	do while (status ^= 0);
	     call set_lock_$lock (fsm_info.lock, Max_wait_time, status);
	     if status = error_table_$invalid_lock_reset
	     then status = 0;
	     else if status ^= 0
	     then call signal_fsm_error (status, fsm_info_path);
	end;

/*  We now have 'fsm_info' all to ourselves.  However, it may not be valid.  */
/*  It is fairly expensive to check for validity, so we only do it the first */
/*  time we access 'fsm_info'.  This is reasonable, since serious problems   */
/*  with the information in 'fsm_info' are rare and will be diagnosed later  */
/*  anyway.                                                                  */
/*                                                                           */
/*  There are two ways in which 'fsm_info' could be invalid.  First, it may  */
/*  not be consistent in that it knows about more or fewer managed segments  */
/*  than actually exist in the directory.  Second, it may be out of date in  */
/*  that it has some segments allocated to processes that no longer exist.   */
/*                                                                           */
/*  It  is  easy  to  tell if 'fsm_info' is inconsistent: We need only count */
/*   number  of  managed segments (i.e.  segments whose first component is a */
/*   positive  integer  and  whose  second component is 'fsm_') and find the */
/*   managed  segment whose first component is numerically largest.  We have */
/*   consistency if and only if both these numbers equal 'fsm_info.seg_cnt'. */
/*   If  'fsm_info'  is  inconsistent,  the  'fortran_storage_manager_error' */
/*   condition  is  signalled  with  a description of the problem.  The user */
/*  probably cannot do anything about this, but if he chooses to restart, we */
/*  repeat the validity test.					       */
/*                                                                           */
/*  If 'fsm_info' is found to be consistent, we examine all allocated        */
/*  segments and free any found to be allocated to nonexistent processes.    */

	do while (^fsm_info_ptr_valid);
	     system_free_area_ptr = get_system_free_area_ ();
	     star_entry_ptr, star_names_ptr = null;
	     on cleanup
		begin;				/*  Free anything that was allocated.  */
		     if star_names_ptr ^= null
		     then free star_names in (system_free_area);
		     if star_entry_ptr ^= null
		     then free star_entries in (system_free_area);
		end;
	     call hcs_$star_ (fsm_dir_path, "*.fsm_", star_BRANCHES_ONLY, system_free_area_ptr, star_entry_count,
		star_entry_ptr, star_names_ptr, status);
	     if status ^= 0 & status ^= error_table_$nomatch
	     then call signal_fsm_error (status, fsm_info_path);
	     else do;				/*  Check validity of 'fsm_info_'.  */
		     seg_cnt, max_seg_idx = 0;
		     do i = 1 to star_entry_count;
			primary_name = star_names (star_entries (i).nindex);
			if verify (before (primary_name, "."), "0123456789") = 0
			     & substr (primary_name, 1, 1) ^= "0"
			then do;			/*  This is a managed segment.  */
				seg_cnt = seg_cnt + 1;
				seg_idx = bin (before (primary_name, "."));
				if seg_idx > max_seg_idx
				then max_seg_idx = seg_idx;
			     end;
		     end;
		     if star_names_ptr ^= null
		     then free star_names in (system_free_area);
		     if star_entry_ptr ^= null
		     then free star_entries in (system_free_area);
		     if max_seg_idx ^= seg_cnt | seg_cnt ^= fsm_info.seg_cnt
		     then call signal_fsm_error (error_table_$bad_segment, fsm_info_path);
		     else do;			/*  'fsm_info' is consistent.  */
			     do seg_idx = 1 to fsm_info.seg_cnt;
				if fsm_info.seg (seg_idx).owning_process ^= ""b
				then do;
					call set_lock_$lock ((fsm_info.seg (seg_idx).owning_process), 0, status)
					     ;
					if status = error_table_$invalid_lock_reset
					then do;	/*  The owner is dead.  */
						call hcs_$truncate_file (fsm_dir_path, seg_name (seg_idx), 0,
						     status);
						unspec (fsm_info.seg (seg_idx)) = ""b;
					     end;
				     end;
			     end;
			     fsm_info_ptr_valid = True;
			end;
		end;
	end;
	return;


%include star_structures;
     end appropriate_fsm_info;

description_of_location:
     proc (location) returns (char (256) varying) recursive;

/*  Function:  to return a meaningful description of the location addressed  */
/*     by a pointer variable.  If the segment number of the location is not  */
/*     valid, the description is just the ASCII representation of a pointer  */
/*     and a comment indicating the segment number is invalid.  Otherwise,   */
/*     the segment number portion is replaced by the pathname of the segment */
/*     and the offset potion is dropped if it is zero, or replaced by the    */
/*     entry name if the location is an entry point.  If the location is in  */
/*     an active stack frame or an external variable, the description will   */
/*     include a comment indicating that.                                    */

/*  Arguments:                                                               */
/*                                                                           */
/*  location  (Input)                                                        */
/*     contains the address of the location whose description is desired.    */

dcl	location		ptr;

dcl	get_entry_name_	entry (ptr, char (*), fixed bin (18), char (8) aligned, fixed bin (35)),
	get_pdir_		entry returns (char (168)),
	hcs_$fs_get_path_name
			entry (ptr, char (*), fixed bin, char (*), fixed bin (35));

dcl	null		builtin,
	stackbaseptr	builtin,
	stackframeptr	builtin;

dcl	False		bit (1) static options (constant) init ("0"b),
	True		bit (1) static options (constant) init ("1"b);

dcl	bit_offset	char (4) varying,
	checking_external_variables
			bit (1),
	description	char (256) varying,
	dir_name		char (168),
	dir_name_len	fixed bin,
	entry_name	char (32),
	hash_table_idx	fixed bin,
	language		char (8) aligned,
	seg_name		char (32),
	seg_num		fixed bin (18),
	status		fixed bin (35),
	vnp		ptr,
	vthp		ptr,
	word_offset	char (8) varying;


	if location = null
	then return ("null");

/*  Create character representations of the word and bit offsets.  */

	if substr (unspec (location), 58, 6) = ""b	/*  Unfortunately, there is no builtin to get the bit offset.  */
	then bit_offset = "";
	else do;
		bit_offset = "(";
		bit_offset = bit_offset || ltrim (char (fixed (substr (unspec (location), 58, 6))));
		bit_offset = bit_offset || ")";
	     end;
	if rel (location) = ""b & bit_offset = ""
	then word_offset = "";
	else do;
		word_offset = "|";
		word_offset = word_offset || octal_representation (fixed (rel (location)));
	     end;

/*  Generate a meaningful description of the location, if possible.  */

	call hcs_$fs_get_path_name (location, dir_name, dir_name_len, seg_name, status);
	if status ^= 0
	then do;					/*  Can't do much as the segment number is invalid.  */
		description = octal_representation (fixed (baseno (location)));
		description = description || word_offset;
		description = description || bit_offset;
		description = description || " (Segment number invalid)";
	     end;
	else do;					/*  We can at least give a pathname instead of a segment number.  */
		if dir_name = ">"
		then description = "";
		else if dir_name = get_pdir_ ()
		then description = "[pd]";
		else description = substr (dir_name, 1, dir_name_len);
		description = description || ">";
		description = description || rtrim (seg_name);
		call get_entry_name_ (location, entry_name, seg_num, language, status);
		if status = 0
		then do;				/*  Give the entry name instead of a word and bit offset.  */
			description = description || "$";
			description = description || rtrim (entry_name);
		     end;
		else do;				/*  Give the word and bit offset, if nonzero.  */
			description = description || word_offset;
			description = description || bit_offset;
		     end;
		if ptr (location, 0) = stackbaseptr
		then do;				/*  See if it's in an active stack frame.  */
			sp = stackframeptr;
			do while (rel (sp) > rel (location) & stack_frame.prev_sp ^= null);
			     sp = stack_frame.prev_sp;
			end;
			if rel (sp) <= rel (location) & rel (stack_frame.next_sp) > rel (location)
			then do;			/*  Indicate who owns the stack frame.  */
				description = description || " (stack_frame";
				if location ^= sp
				then do;
					description = description || "|";
					description =
					     description
					     ||
					     octal_representation (fixed (rel (location)) - fixed (rel (sp)));
					description = description || bit_offset;
				     end;
				description = description || " of ";
				description = description || description_of_location (stack_frame.entry_ptr);
				description = description || ")";
			     end;
		     end;
		else if index (seg_name, ".area.linker") > 0
		then do;				/*  See if the location is in an external variable.  */
			sb = stackbaseptr;
			vthp = stack_header.sys_link_info_ptr;
			if vthp ^= null
			then do;
				checking_external_variables = True;
				do hash_table_idx = lbound (vthp -> variable_table_header.hash_table, 1)
				     to hbound (vthp -> variable_table_header.hash_table, 1)
				     while (checking_external_variables);
				     do vnp = vthp -> variable_table_header.hash_table (hash_table_idx)
					repeat vnp -> variable_node.forward_thread
					while (vnp ^= null & checking_external_variables);
					if baseno (vnp -> variable_node.vbl_ptr) = baseno (location)
					then if rel (vnp -> variable_node.vbl_ptr) <= rel (location)
						&
						rel (
						addrel (vnp -> variable_node.vbl_ptr,
						vnp -> variable_node.vbl_size))
						> rel (location)
					     then do;
						/*  Indicate the name of the external variable.  */
						     checking_external_variables = False;
						     description = description || " (External Variable ";
						     description = description || vnp -> variable_node.name;
						     if vnp -> variable_node.vbl_ptr ^= location
						     then do;
							     description = description || "|";
							     description =
								description
								||
								octal_representation (
								fixed (rel (location))
								-
								fixed (rel (vnp -> variable_node.vbl_ptr))
								);
							     description = description || bit_offset;
							end;
						     description = description || ")";
						end;
				     end;
				end;
			     end;
		     end;
	     end;
	return (description);


%include stack_frame;
%include stack_header;
%include system_link_names;
     end description_of_location;

get_fsm_dir_dir_path:
     proc (fsm_dir_dir_path);

/*  Function:  to return the pathname of the directory which will contain    */
/*     the directory of segments managed by 'fsm_'.  This pathname is        */
/*     obtained from the variable 'fsm_dir_dir_path' in the user's per-      */
/*     process value segment or default permanent value segment (with the    */
/*     value in the perprocess value segment taking precedent if it is       */
/*     defined differently in the two value segments).  If neither of these  */
/*     value segments define the variable, or if the value is "", then the   */
/*     pathname of the process directory is returned.  If the defined value  */
/*     is not an absolute pathname (i.e. does not start with ">"), the       */
/*     condition 'fortran_storage_manager_error' is signalled with a         */
/*     description of the problem. If this occurs, the user should fixed the */
/*     value segment and restart.  				       */

/*  Arguments:                                                               */
/*                                                                           */
/*  fsm_dir_dir_path  (Output)                                               */
/*     is the absolute pathname of the directory which will contain the      */
/*     directory of segments managed by 'fsm_'.                              */

dcl	fsm_dir_dir_path	char (*);

dcl	error_table_$not_abs_path
			fixed bin (35) ext;

dcl	get_pdir_		entry returns (char (168)),
	value_$get	entry (ptr, bit (36) aligned, char (*), char (*), fixed bin (35));

dcl	status		fixed bin (35);


	fsm_dir_dir_path = "";
	do while (fsm_dir_dir_path = "");
	     call value_$get (null, "11"b, "fsm_dir_dir_path", fsm_dir_dir_path, status);
	     if fsm_dir_dir_path = ""
	     then fsm_dir_dir_path = get_pdir_ ();
	     else if substr (fsm_dir_dir_path, 1, 1) ^= ">"
	     then do;
		     call signal_fsm_error (error_table_$not_abs_path,
			"Value segment specifies 'fsm_dir_dir_path' = " || fsm_dir_dir_path);
		     fsm_dir_dir_path = "";
		end;
	end;
     end get_fsm_dir_dir_path;

list_groups:
     proc (max_group_cnt, desired_process);

/*  Function: to list (on the 'user_output' switch) the groups of segments   */
/*     which are allocated to a specified process.  The groups are listed by */
/*     owner.                                                                */

/*  Arguments:                                                               */
/*                                                                           */
/*  max_group_cnt  (Input)                                                   */
/*     is the maximum number of groups to be listed.  If there are more      */
/*     groups than this, the excess are ignored without comment.             */
/*                                                                           */
/*  desired_process  (Input)                                                 */
/*     is the ID of the process whose groups are to be listed.               */
/*                                                                           */

dcl	max_group_cnt	fixed bin,
	desired_process	bit (36) aligned;

dcl	get_line_length_$stream
			entry (char (*), fixed bin (35)) returns (fixed bin),
	ioa_$nnl		entry options (variable);

dcl	01 expected_group	aligned like group;

dcl	01 group		(max_group_cnt) aligned,
	  02 owner	ptr unaligned,
	  02 first_seg_in_group
			fixed bin;

dcl	expected_group_idx	fixed bin,
	group_cnt		fixed bin,
	group_idx		fixed bin,
	line_len		fixed bin,
	max_line_len	fixed bin,
	name		char (32) varying,
	prev_group_owner	ptr unaligned,
	seg_idx		fixed bin,
	status		fixed bin (35),
	trial_group_idx	fixed bin;

/*  Store in 'group' the owner and number of the first segment of each group */
/*  allocated to this process.                                               */

	group_cnt = 0;
	do seg_idx = 1 to fsm_info.seg_cnt while (group_cnt < max_group_cnt);
	     if fsm_info.seg (seg_idx).owning_process = desired_process
		& fsm_info.seg (seg_idx).first_seg_in_group = seg_idx
	     then do;
		     group_cnt = group_cnt + 1;
		     group (group_cnt).owner = fsm_info.owner (seg_idx);
		     group (group_cnt).first_seg_in_group = fsm_info.first_seg_in_group (seg_idx);
		end;
	end;

/*  Sort groups into ascending order of owner and number of first segment in */
/*  the group.                                                               */

	do group_idx = 1 to group_cnt - 1;
	     expected_group = group (group_idx);
	     expected_group_idx = group_idx;
	     do trial_group_idx = group_idx + 1 to group_cnt;
		if unspec (group (trial_group_idx)) < unspec (expected_group)
		then do;
			expected_group = group (trial_group_idx);
			expected_group_idx = trial_group_idx;
		     end;
	     end;
	     if group_idx ^= expected_group_idx
	     then do;
		     group (expected_group_idx) = group (group_idx);
		     group (group_idx) = expected_group;
		end;
	end;

/*  List the groups.  */

	max_line_len = get_line_length_$stream ("user_output", status);
	unspec (prev_group_owner) = ""b;		/*  Start with an impossible owner.  */
	do group_idx = 1 to group_cnt;
	     if group (group_idx).owner ^= prev_group_owner
	     then do;				/*  Describe new owner.  */
		     prev_group_owner = group (group_idx).owner;
		     call ioa_$nnl ("^/^a owns:^/", description_of_location ((prev_group_owner)));
		end;
	     call ioa_$nnl ("^4x");
	     line_len = 4;
	     do seg_idx = group (group_idx).first_seg_in_group repeat fsm_info.next_seg_in_group (seg_idx)
		while (seg_idx ^= 0);
		name = rtrim (seg_name (seg_idx));
		if line_len + 1 + length (name) <= max_line_len
		then do;
			line_len = line_len + 1 + length (name);
			call ioa_$nnl (" ^a", name);
		     end;
		else do;
			line_len = 10 + length (name);
			call ioa_$nnl ("^/^-^a", name);
		     end;
	     end;
	     call ioa_$nnl ("^/");
	end;

     end list_groups;

octal_representation:
     proc (value) returns (char (12) varying);

/*  Function:  to return the octal representation of an integer value.       */

/*  Arguments:                                                               */
/*                                                                           */
/*  value  (Input)                                                           */
/*     is the integer value whose octal representation is desired.           */

dcl	value		fixed bin;

dcl	cv_bin_$oct	entry (fixed bin, char (12) aligned);

dcl	string		char (12) aligned;

	call cv_bin_$oct (value, string);
	return (ltrim (string));
     end octal_representation;

pick_first_seg_num:
     proc (num_segs_desired, first_seg_num);

/*  Function:  to find a set of a specified size of free, consecutive        */
/*     segment numbers and return the first segment number of the set.       */

/*  Arguments:                                                               */
/*                                                                           */
/*  num_segs_desired  (Input)                                                */
/*     is the number of consecutive segment numbers needed.                  */
/*                                                                           */
/*  first_seg_num  (Output)                                                  */
/*     is the first segment number of the chosen set of consecutive segment  */
/*     numbers.                                                              */

dcl	num_segs_desired	fixed bin,
	first_seg_num	fixed bin;

dcl	hcs_$high_low_seg_count
			entry (fixed bin, fixed bin);

dcl	best_hole_size	fixed bin,
	best_hole_start	fixed bin,
	cur_hole_size	fixed bin,
	found_highest_seg_num_in_use
			bit (1),
	high_seg_num	fixed bin,
	high_seg_num_minus_low_seg_num
			fixed bin,
	low_seg_num	fixed bin,
	seg_num		fixed bin;

/*  Find the lowest segment number allowed to be used and the highest that   */
/*  is currently in use.                                                     */

	call hcs_$high_low_seg_count (high_seg_num_minus_low_seg_num, low_seg_num);
	high_seg_num = high_seg_num_minus_low_seg_num + low_seg_num;
	low_seg_num = low_seg_num + 8;		/*  First 8 reserved for stacks.  */
	found_highest_seg_num_in_use = False;
	do while (^found_highest_seg_num_in_use);
	     if seg_num_free (high_seg_num)
	     then high_seg_num = high_seg_num - 1;
	     else found_highest_seg_num_in_use = True;
	end;

/*  Search from the lowest segment number allowed to be used to the highest  */
/*  in use for the smallest set of consecutive segment numbers that is at    */
/*  least as big as needed.                                                  */

	best_hole_size, cur_hole_size = 0;
	do seg_num = low_seg_num to high_seg_num while (best_hole_size ^= num_segs_desired);
	     if seg_num_free (seg_num)
	     then cur_hole_size = cur_hole_size + 1;
	     else do;
		     if cur_hole_size >= num_segs_desired
		     then if best_hole_size = 0 | best_hole_size > cur_hole_size
			then do;			/*  Latest hole is best fit so far.  */
				best_hole_size = cur_hole_size;
				best_hole_start = seg_num - best_hole_size;
			     end;
		     cur_hole_size = 0;
		end;
	end;

/*  If we found a hole large enough, choose the first segment number in it   */
/*  as the start of the desired set; otherwise, start the set immediately    */
/*  following the highest segment number currently in use.                   */

	if best_hole_size < num_segs_desired
	then first_seg_num = high_seg_num + 1;
	else first_seg_num = best_hole_start;
     end pick_first_seg_num;

pick_seg:
     proc (seg_idx);

/*  Function:  to choose a free segment to be allocated.  If there are none, */
/*     one is created.                                                       */

/*  Arguments:                                                               */
/*                                                                           */
/*  seg_idx  (Output)                                                        */
/*     is the index of the element in 'fsm_info.seg' which corresponds to    */
/*     the segment which has been chosen.                                    */

dcl	seg_idx		fixed bin;

dcl	get_group_id_	entry returns (char (32)),
	hcs_$append_branch	entry (char (*), char (*), fixed bin (5), fixed bin (35)),
	hcs_$replace_acl	entry (char (*), char (*), ptr, fixed bin, bit (1), fixed bin (35)),
	hcs_$set_max_length entry (char (*), char (*), fixed bin (19), fixed bin (35)),
	hcs_$set_safety_sw	entry (char (*), char (*), bit (1), fixed bin (35)),

	pl1_operators_$VLA_words_per_seg_
			fixed bin (19) external;

dcl	01 acl		aligned,
	  02 access_name	char (32),
	  02 modes	bit (36),
	  02 xmodes	bit (36),
	  02 status	fixed bin (35);

dcl	status		fixed bin (35);

	do seg_idx = 1 to fsm_info.seg_cnt while (fsm_info.seg (seg_idx).owning_process ^= ""b);
	end;
	if seg_idx <= fsm_info.seg_cnt
	then do;					/*  Reuse free segment.  */
		acl.access_name = get_group_id_ ();
		acl.modes = RW_ACCESS;
		acl.xmodes = ""b;
		status = 1;
		do while (status ^= 0);
		     call hcs_$replace_acl (fsm_dir_path, seg_name (seg_idx), addr (acl), 1, "0"b, status);
		     if status ^= 0
		     then call signal_fsm_error (status, pathname_ (fsm_dir_path, seg_name (seg_idx)));
		end;
	     end;
	else do while (seg_idx > fsm_info.seg_cnt);	/*  Create a segment.  */
		call hcs_$append_branch (fsm_dir_path, seg_name (seg_idx), RW_ACCESS_BIN, status);
		if status = 0
		then do;
			fsm_info.seg_cnt = seg_idx;
			fsm_info.seg (seg_idx).owner = null;
			call hcs_$set_max_length (fsm_dir_path, seg_name (seg_idx),
			     pl1_operators_$VLA_words_per_seg_, status);
			if status ^= 0
			then call signal_fsm_error (status, pathname_ (fsm_dir_path, seg_name (seg_idx)));

			call hcs_$set_safety_sw (fsm_dir_path, seg_name (seg_idx), "1"b, status);
		     end;
		else call signal_fsm_error (status, pathname_ (fsm_dir_path, seg_name (seg_idx)));
	     end;
     end pick_seg;

release_fsm_info:
     proc;

/*  Function:  to free any segments that have been allocated to 'fsm_', then */
/*     to unlock 'fsm_info' so it can be used by other processes.            */

dcl	hcs_$terminate_file entry (char (*), char (*), fixed bin (1), fixed bin (35)),
	set_lock_$unlock	entry (bit (36) aligned, fixed bin (35));

dcl	seg_idx		fixed bin,
	status		fixed bin (35);


/*  This routine may be called in response to a 'cleanup' condition before   */
/*  'fsm_info' has been locked for this process, or possibly even found.     */
/*  Thus, we must be careful to check for these possibilities.               */

	if fsm_info_ptr ^= null
	then if fsm_info.lock = my_process
	     then do;				/*  'fsm_info' is locked for this process.  */
		     do seg_idx = 1 to fsm_info.seg_cnt;
			if fsm_info.seg (seg_idx).owning_process = my_process & fsm_info.seg (seg_idx).owner = me
			then do;
				call hcs_$terminate_file (fsm_dir_path, seg_name (seg_idx), 0, status);
				unspec (fsm_info.seg (seg_idx)) = ""b;
			     end;
		     end;
		     status = 1;
		     do while (status ^= 0);
			call set_lock_$unlock (fsm_info.lock, status);
			if status ^= 0
			then call signal_fsm_error (status, "Trying to unlock 'fsm_info'.");
		     end;
		end;
     end release_fsm_info;

seg_name:
     proc (seg_idx) returns (char (32));

/*  Function:  to return the name of the segment associated with a specified */
/*     element of 'fsm_info.seg'.  The name is 'N.fsm_', where 'N' is the    */
/*     decimal representation of the index of the specified element.         */

/*  Arguments:                                                               */
/*                                                                           */
/*  seg_idx  (Input)                                                         */
/*     is the index of the element of 'fsm_info.seg' with which the segment  */
/*     is associated.                                                        */

dcl	seg_idx		fixed bin;

	return (ltrim (char (seg_idx)) || ".fsm_");
     end seg_name;

seg_num_free:
     proc (seg_num) returns (bit (1));

/*  Function:  to indicate whether a given segment number is currently in    */
/*     use.  (Since there is no system function to do this, we fake it by    */
/*     asking for the unique-id of the segment corresponding to the segment  */
/*     number.  If the return code is 'error_table_$invalidsegno', then the  */
/*     segment number is free.)                                              */

/*  Arguments:                                                               */
/*                                                                           */
/*  seg_num  (Input)                                                         */
/*     is the segment number to be tested.                                   */

dcl	seg_num		fixed bin;

dcl	error_table_$invalidsegno
			fixed bin (35) ext;

dcl	hcs_$get_uid_seg	entry (ptr, bit (36) aligned, fixed bin (35));

dcl	status		fixed bin (35),
	uid		bit (36) aligned;

	call hcs_$get_uid_seg (baseptr (seg_num), uid, status);
	if status = error_table_$invalidsegno
	then return (True);
	else return (False);
     end seg_num_free;

signal_fsm_error:
     proc (status, details);

/*  Function:  to signal the restartable condition                          */
/*          'fortran_storage_manager_error'.              		      */

/*  Arguments:                                                               */
/*                                                                           */
/*  status  (Input)                                                          */
/*     is a standard system status code describing why the condition is      */
/*     being signalled.                                                      */
/*                                                                           */
/*  details  (Input)                                                         */
/*     is supplementary information regarding why the condition is being     */
/*     signalled.                                                            */

dcl	status		fixed bin (35),
	details		char (*);

dcl	signal_		entry options (variable);

%include condition_info_header;

dcl	01 condition_info	aligned like condition_info_header;

	condition_info.length = size (condition_info);
	condition_info.version = 1;
	unspec (condition_info.action_flags) = ""b;
	condition_info.info_string = rtrim (details);
	condition_info.status_code = status;
	call signal_ ("fortran_storage_manager_error", null, addr (condition_info));
     end signal_fsm_error;

%include access_mode_values;
     end fortran_storage_manager_;
