/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1978 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/* format: style4,^inddcls,insnl,delnl */

e_pl1_:
     procedure;
	return;

/****^  HISTORY COMMENTS:
  1) change(84-07-31,Margolin), approve(), audit(), install():
     Pre-hcom comments:
     BSG 3/4/78
     Modified: 12/3/79 by BSG for process preservation across hangup.
     Modified: 7 May 1981 Soley for e_pl1_$check_object
     Modified: 22 June 1981 RMSoley to make get_real_terminal_type
     check for the video system.
     Modified:  2 July 1981 RMSoley to make get_char entries use the
     video system if present.
     Modified 6 July 1981 bim for correct video usage
     Modified: 9 July 1981 RMSoley to check for -login_channel in finding
     proper I/O switch.
     Modified: 23 July 1981 RMSoley to use emacs_data_ static
     Modified: August 1981 RMSoley to move static to invocation structure,
     get rid of push_pop_table_swap, calls to e_find_invocation_
     Modified: November 1981 RMSoley & BIMargulies to add get_emacs_data_ptr,
     enlarge workstring, add retry bit to window_system calls.
     Modified: 30 June 1982 B Margolin to convert hcs_$echo_negotiate_get_chars
     calls to use the new hcs_$tty_read_echoed entrypoint, and
     to process error_table_$echnego_awaiting_stop_sync instead of
     error_table_$line_status_pending.
     Modified: 1 September 1982 B. Margolin to send send_buffered_output order
     to video system in dump_obuf
     Modified: 15 September 1982 B. Margolin to call window_$sync instead of
     sending send_buffered_output order.
     Modified: 5 January 1983 B. Margolin to remove all references to the
     NCP (!!!!), as we recently switched to TCP, which use STY terminals
     Modified 31 July 1984 - K. P. Fleming - to add new messaging primitives,
     in preparation for a complete emacs-console-messages rewrite to
     support new message_facility_.
  2) change(85-01-16,Margolin), approve(), audit(), install():
     Pre-hcom comments:
     Modified 28 August 1984 - K. P. Fleming - to cover for a 'bug' in the new
     message facility. we have to be able to set the wakeup and holding states
     indepedently, and the message facility doesn't allow this yet. so, we just
     use a structure overlay and set them in there.
     Modified 22 September 1984 - B. Margolin - to fix up KPF's work, and to
     make check_for_window_status entrypoint call e_find_invocation_.
     Modified 9 October 1984 - B. Margolin - to change current_message_info
     references to last_message_info.
     Modified 2 November 1984 - B. Margolin - to translate control chars in
     messages to spaces.
     Modified 30 November 1984 - B. Margolin - to not use Iint parameter in
     the wrong entrypoint, and change some vars declared bin to fixed bin.
     Modified 16 January 1985 - B. Margolin - for compatibility with the
     change to message_facility_, changed references to last_message_info.last_message_index
     to =.last_message_id (in mf_$set_seen_switch call) and =.last_message_number
     (in ioa_$rsnnl call, which it should have been in the first place).
  3) change(86-07-08,Coren), approve(86-07-08,MCR7300),
     audit(86-07-08,Beattie), install(86-07-08,MR12.0-1089):
     Changed to use v1_echo_neg_data for compatibility.
  4) change(86-07-16,Margolin), approve(86-07-16,MCR7452),
     audit(86-07-29,Coren), install(86-11-03,MR12.0-1205):
     Changed e_pl1_$init to automatically turn on the video system if a non-MCS
     terminal is being used.
  5) change(86-11-11,LJAdams), approve(86-11-11,MCR7485),
     audit(86-12-16,Margolin), install(87-01-06,MR12.0-1255):
     Modified to support MOWSE.
  6) change(87-03-13,LJAdams), approve(87-03-13,MCR7642),
     audit(87-04-24,Gilcrease), install(87-05-14,MR12.1-1030):
     Added external variable video_data_$terminal_iocb to be able to determine
     if video has been invoked by another subsytem other than emacs.
  7) change(87-12-21,Schroth), approve(88-02-29,MCR7851),
     audit(88-06-06,RBarstad), install(88-08-01,MR12.2-1071):
     Added support for 8-bit extended ASCII I/O.
     Added set_extended_ascii and get_output_conv_table entry points,
     and grew breaktables to 256.
                                                   END HISTORY COMMENTS */

/* Those editor functions best done in PL/I, but not concerned with
   getting into or out of the editor environment.
   This includes the ring 0 TTY dim and NCP interface (removed 1/5/82!), the
   TELNET and SUPDUP-OUTPUT negotiators, the message-receiving primitives,
   etcetera. */

/* Builtin */
dcl  (byte, collate9, fixed, length, null, translate) builtin;

/* CONSTANTS for TELNET negotiations. */

dcl  (
     IAC init (255),
     WILL init (251),
     WONT init (252),
     DO init (253),
     DONT init (254),
     ECHO init (1),
     SB init (250),					/**     SE init (240), **/
     SUPDUP_OUTPUT init (22)
     ) fixed bin (8) static options (constant);

/* Static Variables */
dcl  1 bl aligned static,
       2 c fixed bin init (1),
       2 pad bit (36) aligned,
       2 event fixed bin (71);
dcl  charsgot_meter fixed bin internal static;
dcl  charsout_meter fixed bin (21) internal static;
dcl  dbosw bit (1) static init ("0"b);
dcl  1 editing_chars_v1 aligned internal static,
       2 version fixed bin init (1),
       2 escape_char character (1) aligned,
       2 erase_char character (1) aligned,
       2 kill_char character (1) aligned;
dcl  1 editing_chars_v2 aligned internal static,
       2 version fixed bin init (2),
       2 special_chars aligned,
         3 erase_char character (1) unaligned,
         3 kill_char character (1) unaligned;
dcl  ignore_lf_sw bit (1) init ("0"b) static;
dcl  locecho_meter fixed bin internal static;
dcl  my_pid bit (36) aligned static;
dcl  r0echo_meter fixed bin internal static;
dcl  sdostate bit (1) internal static initial ("0"b);
dcl  1 supdup_info aligned internal static,
       2 aobjct fixed bin (17) unaligned,
       2 pad fixed bin (17) unaligned,
       2 tctyp fixed bin (35),
       2 ttyopt bit (36),
       2 tcmxv fixed bin (35),
       2 tcmxh fixed bin (35),
       2 ttyrol fixed bin (35),
       2 smarts bit (36),
       2 ispeed fixed bin (35),
       2 ospeed fixed bin (35);
dcl  tracing_Rtyo bit (1) aligned internal static initial ("0"b);
dcl  Rtyo_trace_iocb_ptr pointer internal static initial (null ());
dcl  network_type fixed bin (4) unsigned static;

/* System Entries */
dcl  com_err_ entry options (variable);
dcl  condition_ entry (char (*), entry);
dcl  cu_$arg_count entry (fixed bin);
dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
dcl  cu_$cp entry (ptr, fixed bin (21), fixed bin (35));
dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
dcl  get_line_length_$switch entry (ptr, fixed bin (35)) returns (fixed bin);
dcl  get_process_id_ entry returns (bit (36) aligned);
dcl  get_system_free_area_ entry () returns (ptr);
dcl  hcs_$tty_read entry (fixed bin, ptr, fixed bin (21), fixed bin (21), fixed bin (21), fixed bin, fixed bin (35));
dcl  hcs_$tty_state entry (fixed bin, fixed bin, fixed bin (35));
dcl  hcs_$tty_write entry (fixed bin, ptr, fixed bin, fixed bin, fixed bin, fixed bin, fixed bin (35));
dcl  hcs_$wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
dcl  ioa_$ioa_switch entry options (variable);
dcl  ipc_$block entry (ptr, ptr, fixed bin (35));
dcl  mode_string_$get_mode entry (char (*), char (*), ptr, fixed bin (35));
dcl  object_info_$brief entry (ptr, fixed bin (24), ptr, fixed bin (35));
dcl  signal_ entry () options (variable);
dcl  sub_err_ entry () options (variable);
dcl  video_utils_$network_login_channel entry (ptr, fixed bin (4) unsigned, fixed bin (35));
dcl  video_utils_$turn_on_login_channel entry (fixed bin (35), char (*));

/* External static */
dcl  error_table_$bad_arg fixed bin (35) external static;
dcl  error_table_$echnego_awaiting_stop_sync fixed bin (35) external static;
dcl  error_table_$no_table fixed bin (35) external static;

dcl  video_data_$terminal_iocb pointer external;

/* Automatic */
dcl  1 bit_bucket aligned automatic like object_info;
dcl  break_nonvar character (1);
dcl  ch char (1) aligned;
dcl  code fixed bin (35);
dcl  code_to_check fixed bin (35);
dcl  1 delay_table aligned like delay_struc;
dcl  error_message char (128);
dcl  expdl fixed bin;
dcl  fch fixed bin (9);
dcl  gruft (10) fixed bin (71);
dcl  ignore_control bit (1) aligned;
dcl  intp pointer;
dcl  msgp pointer;
dcl  1 my_mode_value aligned like mode_value;
dcl  nargs fixed bin;
dcl  newbit bit (1);
dcl  ngo_entry bit (1);
dcl  nread fixed bin (21);
dcl  ochl fixed bin (21);
dcl  ochp pointer;
dcl  retry bit (1) aligned;
dcl  save_tty_in_emacs_p bit (1) aligned;
dcl  screenlinelen fixed bin;
dcl  sdbct fixed bin;
dcl  sddata (0:35) bit (6) unaligned;
dcl  sls_al fixed bin (21);
dcl  sls_ap pointer;
dcl  sls_t_ospeed fixed bin;
dcl  system_free_ptr pointer;
dcl  tempc fixed bin (9);
dcl  tty_mode_string character (512);
dcl  vaccum character (200) varying;
dcl  way fixed bin;
dcl  went_opblockedp bit (1);
dcl  S fixed bin;

/* Based */
dcl  based_area area based (system_free_ptr);
dcl  1 based_message_struc aligned based (msgp),
       2 msglen initial (length (P_msgtext)) fixed bin (21),
       2 sender character (64) initial (P_sender),
       2 time character (32) unal initial (P_msgtime),
       2 next pointer initial (null ()),
       2 msg character (length (P_msgtext) refer (based_message_struc.msglen)) init (P_msgtext) unal;
dcl  big_bit_string bit (256) based (addr (emacs_data.breaktable));
dcl  bytes (10000) bit (8) unal based (emacs_data.ibufptr);
dcl  chars (6000) bit (9) unal based (addr (bytes));
dcl  1 charsadded based (P_charsadded_symobj),
       2 (tinfo, ct) fixed bin (35);
dcl  1 echd like echo_neg_data aligned;
dcl  1 get_channel_info aligned,
       2 version fixed bin,
       2 devx fixed bin,
       2 channel_name char (32);
dcl  ibuf (10000) bit (8) unal based (emacs_data.ibufptr);
dcl  1 interrupt based (intp),
       2 number fixed bin,
       2 msg fixed bin,
       2 chain pointer;
dcl  obuf char (4096) unal based (emacs_data.obufptr);
dcl  och character (ochl) based (ochp);
dcl  1 rsblock aligned like tty_read_status_info;
dcl  sls_arg character (sls_al) based (sls_ap);
dcl  1 tinfo like terminal_info aligned;
dcl  workstring character (262144) varying based (P_workstringobj);

/* Parameters */
dcl  a_mxh fixed bin (35) parameter;
dcl  a_mxv fixed bin (35) parameter;
dcl  (a_r1, a_r2, a_r3, a_r4) fixed bin (35) parameter;
dcl  a_terminal_type character (*) varying parameter;
dcl  a_ttyopt bit (36) aligned;
dcl  a_terminal_type1 character (*) parameter;
dcl  in_ptr pointer parameter;
dcl  out_ptr pointer parameter;
dcl  pch character (*) parameter;
dcl  (P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8) fixed bin (32) parameter;
dcl  P_backspace_delay fixed bin parameter;
dcl  P_bc fixed bin (24) parameter;
dcl  P_bchx fixed bin parameter;
dcl  P_charsadded_symobj pointer parameter;
dcl  P_cline character (*) parameter;
dcl  1 P_cv_trans like cv_trans aligned parameter;
dcl  P_dbosw fixed bin (1) parameter;
dcl  P_erase_char character (1) parameter;
dcl  P_escape_char character (1) parameter;
dcl  P_horz_nl_delay float bin parameter;
dcl  P_intercode fixed bin parameter;
dcl  P_interrupt_msg fixed bin parameter;
dcl  P_interruptno fixed bin parameter;
dcl  P_intno_char character (*) parameter;
dcl  P_iocb_name character (*) parameter;
dcl  P_kill_char character (1) parameter;
dcl  P_line_speed fixed bin parameter;
dcl  P_linel fixed bin parameter;
dcl  P_msgno character (*) parameter;
dcl  P_msgtext character (*) parameter;
dcl  P_msgtime character (*) parameter;
dcl  P_pointer pointer parameter;
dcl  P_retmsg character (*) varying parameter;
dcl  P_retsender character (*) varying parameter;
dcl  P_rettime character (*) varying parameter;
dcl  P_screenlinelen fixed bin parameter;
dcl  P_sender character (*) parameter;
dcl  P_sw fixed bin (1) parameter;
dcl  P_tab_const_delay fixed bin parameter;
dcl  P_tab_var_delay float bin parameter;
dcl  P_tabs_avl bit (1) aligned parameter;
dcl  P_vert_nl_delay fixed bin parameter;
dcl  P_video fixed bin (1) parameter;
dcl  P_way fixed bin parameter;
dcl  P_workstringobj pointer parameter;

/* Include Files */
%include emacs_data;
%include iocb;
%include iox_dcls;
%include line_types;
%include mcs_echo_neg;
%include mode_string_info;
%include net_event_message;
%include object_info;
%include terminal_info;
%include tty_convert;
%include tty_read_status_info;
%include window_control_info;
%include window_dcls;
%include mail_format;
%include send_mail_info;
%include message_info;
%include msg_array;
%include msg_wakeup_flags;
%include last_message_info;

/* This entry reads a character, blocking if necessary */

get_char:
     entry returns (fixed bin);

	emacs_data_ptr = e_find_invocation_ ();

/* Use video system if we can. */
	if emacs_data.flags.using_video
	then begin;
dcl  break char (1) varying;

	     retry = "1"b;
	     do while (retry);

		call window_$get_one_unechoed_char (emacs_data.input_iocb, break, "1"b, code);
		call check_window_code ("get_one_unechoed_char", code, retry);
	     end;
	     break_nonvar = break;
	     return (rank (break_nonvar));
	end;

	ngo_entry = "0"b;
	expdl, screenlinelen = 0;			/* Need this to avoid fault in getc */
	call getc;
get_char_returns:
	if emacs_data.interrupts.array (0) > 0 then do;
	     if emacs_data.flags.using_r0_echnego then do;
a1r:
		call hcs_$tty_read (emacs_data.ttyx, null (), 0, 0, 0, 0, code);
		if code ^= 0
		then call revalidate_tty (a1r);
	     end;
	     if emacs_data.cgot > 0
	     then emacs_data.ctook = emacs_data.ctook - 1;/* Must be a real ch that woulda been returned. */

/* This kludge turns off ring zero echoing before emacs plays tricks on the
   display. Echoed_in_buffer had better be zero. Christ almighty, what hair. */

/* In truth, this should not be necessary for get_char entry,
   because nobody could have called regular get_char unless echo get_char
   broke echo, but this sure can't hurt, and is needed for echo call. */

	     return (-1);
	end;
	return (fixed (unspec (ch), 9));

/* This entry "prints" a character */

tyo:
     entry (fch);

	emacs_data_ptr = e_find_invocation_ ();

	unspec (ch) = bit (fixed (fch, 9), 9);
	ochp = addr (ch);
	ochl = 1;
	call output_och;
	return;

/* This entry "prints" a string */

princ:
     entry (pch);

	emacs_data_ptr = e_find_invocation_ ();

	ochp = addr (pch);
	ochl = length (pch);
	call output_och;
	return;

output_och:
     proc;

dcl  och_string character (ochl) based (ochp);

	if tracing_Rtyo then do;			/* send it to the trace iocb, as well */
	     call iox_$put_chars (Rtyo_trace_iocb_ptr, ochp, ochl, (0));
	end;

	charsout_meter = charsout_meter + ochl;
	if (ochl + emacs_data.chars_in_obuf > length (obuf))
	then call dump_obuf;
	if (ochl > length (obuf)) | dbosw then do;
	     retry = "1"b;
	     if emacs_data.flags.using_video
	     then do while (retry);
		call window_$overwrite_text (emacs_data.output_iocb, och_string, code);
		call check_window_code ("overwrite_text", code, retry);
	     end;
	     else call iox_$put_chars (emacs_data.output_iocb, ochp, ochl, code);
	end;
	else do;
	     substr (obuf, emacs_data.chars_in_obuf + 1, ochl) = och;
	     emacs_data.chars_in_obuf = emacs_data.chars_in_obuf + ochl;
	end;
	return;

     end output_och;

/* Return emacs data pointer-- 19 November 1981 RMSoley */
get_emacs_data_ptr:
     entry () returns (pointer);

	emacs_data_ptr = e_find_invocation_ ();
	return (emacs_data_ptr);


/*	Modified for DCTL Rtyo and Rprinc output tracing, 06/25/79 WOS */

set_io_trace_iocb:
     entry (P_iocb_name);

	emacs_data_ptr = e_find_invocation_ ();

	call cu_$arg_count (nargs);
	if nargs ^= 1 then do;
	     call com_err_ (0, "e_pl1_$set_io_trace_iocb", "^/Usage:^-e_pl1_$set_io_trace_iocb iocb_name");
	     return;
	end;

	if P_iocb_name = "-off" | P_iocb_name = "off" then do;
						/* shut it off */
	     tracing_Rtyo = "0"b;
	     return;
	end;

	tracing_Rtyo = "0"b;			/* turn it off until we're sure we won */

	call iox_$look_iocb (P_iocb_name, Rtyo_trace_iocb_ptr, code);
	if code ^= 0 then do;
cant_use_trace_iocb:
	     call com_err_ (code, "e_pl1_$set_io_trace_iocb", "Can't use I/O switch ""^a"".", P_iocb_name);
	     return;
	end;

	if Rtyo_trace_iocb_ptr -> iocb.open_descrip_ptr = null ()
	then goto cant_use_trace_iocb;

	tracing_Rtyo = "1"b;			/* assume we won */
	return;					/* all done with set_io_trace_iocb */

/* Lisp/PL1 echo negotiator - BSG 10/28/78 */
/* Ring 0 wired echo BSG 1/21/79 */

echo_negotiate_get_char:
     entry (P_workstringobj, P_charsadded_symobj, P_screenlinelen) returns (fixed bin);

	emacs_data_ptr = e_find_invocation_ ();

	if emacs_data.flags.using_video
	then begin;
dcl  buffer char (256);
dcl  break char (1) varying;
dcl  broke character (1);				/* Fix up break table if it needs it. */
	     if emacs_data.flags.update_breaktable
	     then begin;
dcl  1 bti aligned like break_table_info;
		bti.version = break_table_info_version;
		string (bti.breaks) = string (emacs_data.breaktable);
		call iox_$control (emacs_data.input_iocb, "set_break_table", addr (bti), code);
		if code ^= 0
		then call signal_io_error (code, "Could not set video break table.");
		emacs_data.flags.update_breaktable = "0"b;
	     end;

	     nread = 0;
	     retry = "1"b;
	     if P_screenlinelen <= 0
	     then do while (retry);

		call window_$get_one_unechoed_char (emacs_data.input_iocb, break, "1"b /* BLOCK */, code);
		call check_window_code ("get_one_unechoed", code, retry);
	     end;

	     else do while (retry);
		call window_$get_echoed_chars (emacs_data.input_iocb, (P_screenlinelen), buffer, nread, break, code);
		call check_window_code ("get_echoed_chars", code, retry);
	     end;

	     charsadded.ct = nread;
	     if nread ^= 0 then do;
		workstring = substr (workstring, 1, length (workstring) - 1);
		workstring = workstring || substr (buffer, 1, nread) || byte (10 /* NL */);
	     end;
	     broke = break;
	     if length (break) > 0
	     then return (rank (broke));
	     else return (-1);
	end;

	ngo_entry = "1"b;				/* Call right hcs_ */
	ochp = addr (ch);				/* Out what we in */
	ochl = 1;
	charsadded.ct = 0;				/* In case lisp didn't */
	expdl = 0;
	screenlinelen = P_screenlinelen;
	vaccum = "";				/* for cleanup */
enegot_loop:
	call getc;
	if emacs_data.cgot = 0
	then go to enegot_closeout;
	if fixed (unspec (ch), 9) > 127
	then if ^emacs_data.flags.extended_ascii
	     then go to enegot_closeout;		/* Meta frobs and IACs break */
	if emacs_data.breaktable (fixed (unspec (ch), 9))
	then go to enegot_closeout;
	if expdl ^< screenlinelen
	then go to enegot_closeout;
	expdl = expdl + 1;				/* Watch for end */
	vaccum = vaccum || ch;
	locecho_meter = locecho_meter + 1;
	if emacs_data.flags.using_r0_echnego then do;
	     if emacs_data.echoed <= 0
	     then call output_och;
	     else emacs_data.echoed = emacs_data.echoed - 1;
	end;
	else call output_och;
	go to enegot_loop;
enegot_closeout:
	charsadded.ct = length (vaccum);
	vaccum = vaccum || byte (10 /* NL */);
	workstring = substr (workstring, 1, length (workstring) - 1);
	workstring = workstring || vaccum;
	if emacs_data.chars_in_obuf > 0
	then call dump_obuf;
	go to get_char_returns;			/* Check echo break */

set_break_char:
     entry (P_bchx, P_way);

	emacs_data_ptr = e_find_invocation_ ();

	if P_bchx < 32 | P_bchx = 127
	then way = 1;
	else way = P_way;				/* control chars never print right */
	newbit = (way ^= 0);
	if emacs_data.breaktable (P_bchx) ^= newbit then do;
	     emacs_data.breaktable (P_bchx) = newbit;
	     emacs_data.flags.update_breaktable = "1"b;
	end;
	return;

set_break_sequence:
     entry (P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8);

	emacs_data_ptr = e_find_invocation_ ();

/* This entry sets the break table en masse, i.e., for the entire
   collating sequence.  P_(1 2 3 4) are fb32's filled from the lisp side
   to simulate a bit(128) bit string.  RMSoley 28 June 1981 */
/* Added P_5...P_8 for 8 bit ASCII breaktables. 84-11-23 EDSchroth */

	big_bit_string =
	     bit (P_1, 32) || bit (P_2, 32) || bit (P_3, 32) || bit (P_4, 32) || bit (P_5, 32) || bit (P_6, 32)
	     || bit (P_7, 32) || bit (P_8, 32);
	emacs_data.flags.update_breaktable = "1"b;
	return;

r0_echnego_on:
     entry;
	emacs_data_ptr = e_find_invocation_ ();
	emacs_data.flags.using_r0_echnego = "1"b;
	return;
r0_echnego_off:
     entry;
	emacs_data_ptr = e_find_invocation_ ();
	emacs_data.flags.using_r0_echnego = "0"b;
	return;

return_echo_meters:
     entry (a_r1, a_r2, a_r3, a_r4);

	emacs_data_ptr = e_find_invocation_ ();

	a_r1 = charsgot_meter;
	a_r2 = r0echo_meter;
	a_r3 = locecho_meter;
	a_r4 = charsout_meter;

	return;

/* This entry gets the speed of the user's terminal */

get_line_speed:
     entry returns (fixed bin);

	emacs_data_ptr = e_find_invocation_ ();

	if emacs_data.ospeed > 0
	then return (emacs_data.ospeed);
	terminal_info_ptr = addr (tinfo);
	terminal_info.version = terminal_info_version;

	call iox_$control (emacs_data.input_iocb, "terminal_info", addr (terminal_info), code);
	if code ^= 0
	then return (30);
	else return (divide (terminal_info.baud_rate, 10, 17, 0));

/* This entry allows rawmode net users to assert their true line speed */

set_line_speed:
     entry;

	emacs_data_ptr = e_find_invocation_ ();

	call cu_$arg_ptr (1, sls_ap, sls_al, code);
	if code ^= 0 then do;
sls_usage:
	     call com_err_ (code, "emacs$set_line_speed", "Usage: emacs$set_line_speed <baud> | -reset");
	     return;
	end;
	if sls_arg = "-rs" | sls_arg = "-reset" then do;
	     emacs_data.ospeed = 0;
	     return;
	end;
	sls_t_ospeed = cv_dec_check_ (sls_arg, code);
	if code ^= 0 | sls_t_ospeed ^> 0 then do;
	     code = error_table_$bad_arg;
	     go to sls_usage;
	end;
	emacs_data.ospeed = divide (sls_t_ospeed, 10, 17, 0);
	return;

set_line_speed_:
     entry (P_line_speed);

	emacs_data_ptr = e_find_invocation_ ();

	emacs_data.ospeed = P_line_speed;
	return;

/* This entry returns various information about the terminal */

get_mcs_tty_info:
     entry (P_tabs_avl, P_horz_nl_delay, P_vert_nl_delay, P_tab_var_delay, P_tab_const_delay, P_backspace_delay, P_linel);

	emacs_data_ptr = e_find_invocation_ ();

	P_linel = emacs_data.linel;

	my_mode_value.version = mode_value_version_3;
	call mode_string_$get_mode ((emacs_data.tty_modes), "tabs", addr (my_mode_value), code);
	if code ^= 0
	then P_tabs_avl = "0"b;
	else P_tabs_avl = my_mode_value.boolean_value;

	delay_table.version = 1;
	call iox_$control (emacs_data.input_iocb, "get_delay", addr (delay_table), code);
	if code ^= 0 then do;
	     unspec (delay_table) = "0"b;		/* Dont know can't hurt */
	     delay_table.horz_nl = 0.1;
	     delay_table.vert_nl = 5;
	     delay_table.var_tab = 0.250;
	end;
	else do;
	     P_horz_nl_delay = delay_table.horz_nl;
	     P_vert_nl_delay = delay_table.vert_nl;
	     P_tab_var_delay = delay_table.var_tab;
	     P_tab_const_delay = delay_table.const_tab;
	     P_backspace_delay = delay_table.backspace;
	end;
	return;


/* Dump whatever is in the output buffer. */

dump_obuf:
     proc;

dcl  (charsout, charsout_this_time) fixed bin;

dcl  video_obuf char (emacs_data.chars_in_obuf) unaligned based (emacs_data.obufptr);

	went_opblockedp = "0"b;
	if emacs_data.chars_in_obuf <= 0		/* nothing in our buffer */
	then do;
	     retry = "1"b;
	     /*** Dump what's in the video system buffer ***/
	     if emacs_data.flags.using_video
	     then do while (retry);
		call window_$sync (emacs_data.output_iocb, code);
		call check_window_code ("sync", code, retry);
	     end;
	     return;
	end;
	/*** dump our buffer now ***/
	if emacs_data.flags.using_video then do;
	     retry = "1"b;
	     do while (retry);
		call window_$overwrite_text (emacs_data.output_iocb, video_obuf, code);
		call check_window_code ("overwrite_text", code, retry);
	     end;
	     retry = "1"b;
	     do while (retry);
		call window_$sync (emacs_data.output_iocb, code);
		call check_window_code ("sync", code, retry);
	     end;
	end;
	else do;
	     charsout = 0;
	     do while (emacs_data.chars_in_obuf > charsout);
a2r:
		call hcs_$tty_write (emacs_data.ttyx, addr (obuf), charsout, emacs_data.chars_in_obuf - charsout,
		     charsout_this_time, S, code);
		if code ^= 0
		then call revalidate_tty (a2r);
		if S ^= 5 | code ^= 0
		then call signal_io_error (code, "hcs_ tty write failed, or reconnect failed.");

		charsout = charsout + charsout_this_time;
		if emacs_data.chars_in_obuf > charsout then do;
		     call ipc_$block (addr (bl), addr (gruft), code);
		     if code ^= 0
		     then call signal_io_error (code, "Block failed on tty write.");
		     went_opblockedp = "1"b;
		end;
	     end;
	end;

	emacs_data.chars_in_obuf = 0;
     end;


/* Get one unread character, actually reading if necessary. */

getc:
     proc ();					/* Fill ch */

dcl  lleft fixed bin,
     echnego_sync_flag bit (1);


	lleft = screenlinelen - expdl;
rt:
	if emacs_data.ctook >= emacs_data.cgot then do;
	     if emacs_data.chars_in_obuf > 0
	     then call dump_obuf;			/* Must dump FIRST, or echnego race loses. */
rread:
	     emacs_data.ctook, emacs_data.echoed = 0;
	     echnego_sync_flag = "0"b;		/* Start out in synch */
	     if emacs_data.flags.using_r0_echnego & ngo_entry then do;
		if emacs_data.flags.update_breaktable then do;
		     unspec (echd) = ""b;
		     echd.version = echo_neg_data_version_2;
		     string (echd.break) = string (emacs_data.breaktable);
		     call iox_$control (emacs_data.input_iocb, "set_echo_break_table", addr (echd), code);
		     if code ^= 0
		     then call signal_io_error (code, "Could not set echo break table.");

		     emacs_data.flags.update_breaktable = "0"b;
		end;
		if emacs_data.interrupts.array (0) > 0
		then lleft = 0;
		call hcs_$tty_read_echoed (emacs_data.ttyx, addr (chars), 0, dimension (chars, 1), emacs_data.cgot,
		     emacs_data.echoed, lleft, S, code);
		if emacs_data.echoed > emacs_data.cgot
		then emacs_data.echoed = emacs_data.cgot;
		r0echo_meter = r0echo_meter + emacs_data.echoed;
		if code ^= 0
		then if code = error_table_$echnego_awaiting_stop_sync then do;
						/* Echo stop waitout */
			code = 0;
			echnego_sync_flag = "1"b;
		     end;
	     end;
	     else call hcs_$tty_read (emacs_data.ttyx, addr (chars), 0, dimension (chars, 1), emacs_data.cgot, S, code);

	     if code ^= 0 then do;
		if emacs_data.flags.using_r0_echnego then do;
		     emacs_data.flags.update_breaktable = "1"b;
						/* maybe switched tties? */
		     if ngo_entry & code = error_table_$no_table
		     then go to rread;		/* Switched tties at night */
		end;
		call revalidate_tty (rread);
	     end;
	     if code ^= 0
	     then call signal_io_error (code, "hcs_ tty read failed.");
	     if emacs_data.cgot = 0 then do;
		if emacs_data.interrupts.array (0) > 0 & ^echnego_sync_flag
		then return;			/* Wait more for echnego_sync_flag */
		call ipc_$block (addr (bl), addr (gruft), code);
		if code ^= 0
		then call signal_io_error (code, "Block failed for tty read.");
		go to rread;
	     end;
	     charsgot_meter = charsgot_meter + emacs_data.cgot;
	end;
	emacs_data.ctook = emacs_data.ctook + 1;
	unspec (ch) = chars (emacs_data.ctook);

	if ignore_lf_sw & (unspec (ch) = "012"b3)
	then go to rt;				/* lf kloodgerie */

	return;
     end getc;


/* This entry dumps the output buffer */

dump_output_buffer:
     entry ();

	emacs_data_ptr = e_find_invocation_ ();
	call dump_obuf;
	return;


/* This entry does a resetwrite on the terminal */

resetwrite:
     entry;
	emacs_data_ptr = e_find_invocation_ ();
	if emacs_data.output_iocb = null
	then emacs_data.output_iocb = iox_$user_output;
	call iox_$control (emacs_data.output_iocb, "resetwrite", null, (0));
	return;


/* This entry returns if any input is available */

real_have_chars:
     entry returns (fixed bin);

	emacs_data_ptr = e_find_invocation_ ();
	if emacs_data.flags.using_video then do;
	     call iox_$control (emacs_data.input_iocb, "read_status", addr (rsblock), code);
	     if code ^= 0 | ^rsblock.input_pending
	     then return (0);
	     else return (1);
	end;

	if emacs_data.ctook < emacs_data.cgot - fixed (ignore_lf_sw, 1) - fixed (emacs_data.flags.got_cr, 1)
	then return (1);
	else return (0);


/* This entry executes a Multics command line trapping all errors */


cline_executor:
     entry (P_cline);

	emacs_data_ptr = e_find_invocation_ ();
	ignore_control = "0"b;
	call condition_ ("any_other", cline_any_other_handler);
	call cu_$cp (addr (P_cline), length (P_cline), (0));

cline_returns:
	return;

cline_any_other_handler:
     proc (mcp, cname, cop, inp, cont);

dcl  (mcp, cop, inp) ptr;
dcl  cname char (*);
dcl  cont bit (1) aligned;
	if ignore_control then do;			/* Oh my, recursing */
	     cont = "1"b;
	     return;
	end;
	if cname = "quit" | cname = "alrm" | cname = "program_interrupt" | cname = "command_error" | cname = "cput"
	     | cname = "command_question" | cname = "finish" | cname = "trm_" | cname = "sus_" then do;
	     cont = "1"b;
	     return;
	end;
	ignore_control = "1"b;			/* Let recurse thru */
	emacs_data.cgot = 0;
	save_tty_in_emacs_p = emacs_data.flags.in_emacs;
	emacs_data.flags.in_emacs = "0"b;
	call set_multics_tty_modes;
	call ioa_$ioa_switch (iox_$user_io,
	     "^/emacs: ^a raised while executing Multics command.^/Use the ^[emacs^;program_interrupt (pi)^] command to return to emacs.",
	     cname, emacs_data.in_task);
	if save_tty_in_emacs_p
	then begin options (non_quick);		/* Probably file-outputting, will never see fault msg unless we output it. */
dcl  condition_interpreter_ entry (ptr, ptr, fixed bin, fixed bin, ptr, char (*), ptr, ptr);
dcl  xarea area (500);
dcl  msg char (mlen) based (mptr),
     mlen fixed bin,
     mptr ptr;

	     call condition_interpreter_ (addr (xarea), mptr, mlen, 1, mcp, rtrim (cname), cop, inp);
	     if msg = ""
	     then return;				/* quiet_restart and friends */
	     call ioa_$ioa_switch (iox_$user_io, "^a", msg);
	end;
	call signal_ (cname, mcp, inp);
	if save_tty_in_emacs_p
	then call set_emacs_tty_modes;
	emacs_data.flags.in_emacs = save_tty_in_emacs_p;
	ignore_control = "0"b;
	return;
     end cline_any_other_handler;


/* This entry sets flag indicating whether buffering happens */

set_dbo_sw:
     entry (P_dbosw);

	emacs_data_ptr = e_find_invocation_ ();
	dbosw = bit (fixed (P_dbosw, 1), 1);
	return;


/* This entry intializes the PL/1 stuff */

init:
set_single:
     entry;

	emacs_data_ptr = e_find_invocation_ ();

	my_pid = get_process_id_ ();
	emacs_data.interrupts.array (*) = 0;
	emacs_data.flags.in_emacs = "0"b;
	if ^emacs_data.flags.debugging | (emacs_data.output_iocb = null ()) then do;

	     if emacs_data.output_iocb = null () then do; /* Check to see if the video system is on. */

		emacs_data.flags.using_video = "0"b;
		system_free_ptr = get_system_free_area_ ();
		allocate window_position_info in (based_area) set (window_position_info_ptr);
		window_position_info.version = window_position_info_version;

		call iox_$control (iox_$user_io, "get_window_info", window_position_info_ptr, code);
		free window_position_info_ptr -> window_position_info;
		if code = 0 then do;
		     emacs_data.output_iocb = iox_$user_io;
		     emacs_data.flags.using_video = "1"b;
		end;
	     end;


	     if emacs_data.output_iocb = null () then do;
		call video_utils_$network_login_channel (emacs_data.output_iocb, network_type, code);
		if code ^= 0
		then call signal_io_error (code, error_message);
	     end;

						/** See if we need to automatically invoke video **/
	     if ^emacs_data.flags.using_video
	     then if network_type ^= MCS_NETWORK_TYPE & video_data_$terminal_iocb = null then do;
		     call video_utils_$turn_on_login_channel (code, error_message);
		     if code ^= 0
		     then call signal_io_error (code, error_message);
		     emacs_data.flags.using_video = "1"b;
		     emacs_data.flags.turned_on_video = "1"b;
		end;

	     emacs_data.input_iocb = emacs_data.output_iocb;
	end;

/* Determine if iocb we got is a video iocb. */
	if ^emacs_data.flags.using_video & ^emacs_data.flags.debugging then do;
	     system_free_ptr = get_system_free_area_ ();
	     allocate window_position_info in (based_area) set (window_position_info_ptr);
	     window_position_info.version = window_position_info_version;
	     call iox_$control (emacs_data.output_iocb, "get_window_info", window_position_info_ptr, code);
	     free window_position_info_ptr -> window_position_info;
	     emacs_data.flags.using_video = (code = 0);
	end;

	call iox_$modes (emacs_data.input_iocb, "", tty_mode_string, (0));
	if emacs_data.tty_modes = ""
	then emacs_data.tty_modes = tty_mode_string;
	emacs_data.linel = get_line_length_$switch (emacs_data.output_iocb, code);
	if code ^= 0
	then emacs_data.linel = 79;
	call get_tty_channel_info;
	emacs_data.chars_in_obuf, emacs_data.ctook, emacs_data.cgot, emacs_data.echoed = 0;
	locecho_meter, charsgot_meter, charsout_meter, r0echo_meter = 0;
	call iox_$control (emacs_data.input_iocb, "get_event_channel", addr (bl.event), code);
	if code ^= 0 then do;
	     code = 0;
	     call iox_$control (emacs_data.input_iocb, "read_status", addr (rsblock), code);
	     if code = 0
	     then bl.event = rsblock.event_channel;
	end;
	if emacs_data.obufptr = null
	then allocate obuf;
	if emacs_data.ibufptr = null
	then allocate ibuf;
	return;

/* TTY channel attach/reattach hackery 12/3/79 BSG */

get_tty_channel_info:
     proc ();

dcl  gtc_code fixed bin (35);
dcl  1 ttyt aligned based,
       2 pad (14) fixed bin,
       2 tttyx fixed bin (35);

	unspec (get_channel_info) = "0"b;
	get_channel_info.version = 1;
	call iox_$control (emacs_data.output_iocb, "get_channel_info", addr (get_channel_info), gtc_code);
	if gtc_code = 0
	then emacs_data.ttyx = get_channel_info.devx;
	else emacs_data.ttyx = emacs_data.output_iocb -> iocb.attach_data_ptr -> ttyt.tttyx;
	emacs_data.flags.update_breaktable = "1"b;
     end get_tty_channel_info;

revalidate_tty:
     proc (a_label);

dcl  a_label label,
     l_code fixed bin (35);

/* This procedure is called when hcs_$tty_* returns an error.  If the
   current tty devx isn't even valid, as hcs_$tty_state indicates, we
   may have been hung up.  If this IS the case, reattach as below. If
   not, we have a real error, and let it thru. */

	call hcs_$tty_state (emacs_data.ttyx, (0), l_code);
	if l_code = 0
	then return;				/* Some other problem */

/* At this point, we have definitely hung up the line. Force the
   ring 4 TTY dim to call ring 0, and clean up his own act, figuring
   out the new devx, and waiting, if necessary,  for reattachment. */

	call iox_$control (emacs_data.input_iocb, "read_status", addr (rsblock), l_code);

	if l_code ^= 0
	then return;				/* Probly old dim */

/* The ring 4 TTY dim now knows the real devx.  Try to figure it out.
   It must be at LEAST the 8.0 TTY DIM if l_code is 0. */

	call get_tty_channel_info;

/* If we are in this situation, either get_tty_channel_info did its
   thing or we punt. */

	if get_channel_info.devx = 0
	then return;
	go to a_label;				/* Return to retry */
     end;

/* This entry is for debugging */

set_display_iocbs:
     entry (in_ptr, out_ptr);

	emacs_data_ptr = e_find_invocation_ ();

	emacs_data.input_iocb = in_ptr;
	emacs_data.output_iocb = out_ptr;
	emacs_data.flags.debugging = "1"b;
	return;

/* This entry is also for debugging, for setting emacs_data.flags.using_video. */

set_video_system:
     entry (P_video);

	emacs_data_ptr = e_find_invocation_ ();

	emacs_data.flags.using_video = bit (fixed (P_video, 1), 1);
	emacs_data.flags.debugging = "1"b;
	return;

/* This entry sets the flag controlling whether LF is ever returned */

set_ignore_lf:
     entry (P_sw);

	emacs_data_ptr = e_find_invocation_ ();
	ignore_lf_sw = bit (fixed (P_sw, 1), 1);
	return;


/* This entry sets the extended ASCII character I/O flag allowing/disallowing
   8 bit input/output. */

set_extended_ascii:
     entry (P_sw);

	emacs_data_ptr = e_find_invocation_ ();
	emacs_data.flags.extended_ascii = bit (fixed (P_sw, 1), 1);
	return;

/* This entry sets the terminal modes for EMACS */

set_emacs_tty_modes:
     entry ();

	emacs_data_ptr = e_find_invocation_ ();

	if ^emacs_data.flags.using_video then do;
	     call iox_$modes (emacs_data.input_iocb, "init,force,^prefixnl,rawi,rawo,ctl_char,fulldpx,breakall", (""),
		(0));				/* 1/5/83 to move breakall in (it had its own call!) */
						/* 1/31/81 try again */
						/* 11/8/79 to use init mode */
	     if emacs_data.flags.extended_ascii
	     then call iox_$modes (emacs_data.input_iocb, "force,8bit,no_outp", "", (0));
	     call iox_$control (emacs_data.input_iocb, "printer_off", null (), (0));
	end;
	emacs_data.flags.in_emacs = "1"b;
	return;


fix_modes_and_exit:
	call multics_tty_modes_setter;
	if code ^= 0
	then call signal_io_error (code, "Setting Multics tty modes.");
	return;

/* This entry resets the modes for Multics use */

set_multics_tty_modes:
     entry ();
	emacs_data_ptr = e_find_invocation_ ();

	call multics_tty_modes_setter;
	return;

multics_tty_modes_setter:
     procedure;

	if emacs_data.input_iocb ^= null () then do;
	     tty_mode_string = emacs_data.tty_modes;
	     call iox_$modes (emacs_data.input_iocb, tty_mode_string, "", (0));
	     call iox_$control (emacs_data.input_iocb, "printer_on", null (), (0));
	end;
	emacs_data.flags.in_emacs = "0"b;
     end multics_tty_modes_setter;

signal_io_error:
     procedure (reason, explanation);
declare  reason fixed bin (35);
declare  explanation character (*);

	call sub_err_ (reason, emacs_data.myname, "s", null (), (0),
	     "Emacs encountered an error. ^a. ^/Give the following command:^/file_output emacs_trace_;trace_stack;revert_output^/and save the results for programming staff.",
	     explanation);

     end signal_io_error;

/* This internal procedure negotiates via TELNET */

negotiate:
     procedure (option, have_it_or_not);

dcl  have_it_or_not bit (1) aligned,
     option fixed bin (8);

	call dump_obuf;
	call ncp_send (IAC);
	if have_it_or_not
	then call ncp_send (WILL);
	else call ncp_send (WONT);
	call ncp_send (option);
ne_ret:
	call dump_obuf;
	return;

ncp_send:
	proc (byte8);

dcl  byte8 fixed bin (8);


	     emacs_data.chars_in_obuf = emacs_data.chars_in_obuf + 1;
	     substr (obuf, emacs_data.chars_in_obuf, 1) = byte (byte8);
	     return;
	end ncp_send;
     end negotiate;


/* Hacks for those rare people who like messages */

/* 05/25/78 */

message_acceptor:
     entry (P_intno_char, P_msgno, P_sender, P_msgtime, P_msgtext);

	emacs_data_ptr = e_find_invocation_ ();

	if ^emacs_data.flags.in_emacs then do;
	     call ioa_$ioa_switch (iox_$user_io, "From ^a ^a:^/^a", P_sender, P_msgtime, P_msgtext);
	end;
	call set_emacs_interrupt (binary (P_intno_char, 17, 0), 0, (0));
	allocate based_message_struc set (msgp);
	if emacs_data.first_msgp = null
	then emacs_data.first_msgp = msgp;
	else emacs_data.last_msgp -> based_message_struc.next = msgp;
	emacs_data.last_msgp = msgp;
	return;

retrieve_message:
     entry (P_retsender, P_rettime, P_retmsg);

	emacs_data_ptr = e_find_invocation_ ();

	if emacs_data.last_msgp = null
	then P_retsender, P_rettime, P_retmsg = "";
	else do;
	     msgp = emacs_data.first_msgp;
	     P_retsender = rtrim (based_message_struc.sender);
	     P_rettime = rtrim (based_message_struc.time);
	     P_retmsg = rtrim (based_message_struc.msg);
	     emacs_data.first_msgp = based_message_struc.next;
	     if emacs_data.first_msgp = null
	     then emacs_data.last_msgp = null;
	     free based_message_struc;
	end;
	return;
/**** This code added 31 July 1984 - K. P. Fleming */


dcl  (PDmsgfmbx, PIint) ptr init (null ());
dcl  (P_msgfmbx_ptr, P_PIint) ptr parameter;
dcl  P_code fixed bin (35) parameter;
dcl  Iint fixed bin (17) parameter;
dcl  int_index fixed bin (17);
dcl  message_facility_$get_last_message_info entry (ptr, ptr, fixed bin (35));
dcl  1 local_last_message_info aligned like last_message_info;
dcl  date_time fixed bin (71);
dcl  date_time_ entry (fixed bin (71), char (*));
dcl  msg_date_time char (24);
dcl  message_sender char (120);
dcl  ioa_$rsnnl entry () options (variable);
dcl  (int_index_char, Imsg_char) char (8);
dcl  message_facility_$set_seen_switch entry (ptr, bit (72) aligned, bit (*), fixed bin (35));
dcl  message_facility_$get_msgf_mbx_ptr entry (char (*), char (*), ptr, fixed bin (35));
dcl  message_facility_$set_wakeup_state entry (ptr, bit (*), fixed bin (35));
dcl  message_facility_$get_wakeup_state entry (ptr, bit (*), fixed bin (35));
dcl  message_facility_$set_wakeup_handler entry (ptr, entry, ptr, fixed bin (35));
dcl  message_facility_$send_message entry (char (*), char (*), char (*), ptr, fixed bin (35));
dcl  NLSPHT char (3) aligned int static options (constant) init ("
 	");
dcl  mbx_path char (*) parm;
dcl  expand_pathname_$add_suffix entry (char (*), char (*), char (*), char (*), fixed bin (35));
dcl  mbx_dname char (168);
dcl  mbx_ename char (32);
dcl  Swakeup_state bit (5);
dcl  1 Dmail aligned like send_mail_info;
dcl  message char (*) parm;
dcl  user_info_$whoami entry (char (*));
dcl  person_id char (32);
dcl  (person, project) char (*) parameter;
dcl  message_facility_$default_wakeup_handler entry (ptr, ptr);
dcl  user_info_$homedir entry (char (*));
dcl  message_handler entry (ptr, ptr) variable;
dcl  1 Dstates_overlay defined (Swakeup_state) like wakeup_flags;
dcl  (binary, bit, dimension, divide, empty, hbound, rank, rtrim, string, wordno, addr, before, setwordno, substr, unspec)
	builtin;

set_message_handler:
     entry (mbx_path, Iint, P_code);

	P_code = 0;
/**** Note: the next line of code contains a "kludge" that saves us a little
      bit of time and storage. The message_facility_ wants an info_ptr that it
      can pass to the wakeup handler for "static" information. The only thing
      we need to save in this manner is the Emacs interrupt number for this
      mbx. Thus, instead of allocating an array in emacs_data for the
      interrupt numbers to be stored "statically", we just pass a fake pointer
      to the message_facility_ that contains the interrupt number as its word
      offset, and the rest of it is just null().

      -Kevin
*/
	PIint = setwordno (null (), Iint);
	message_handler = message_wakeup_handler;
	call expand_pathname_$add_suffix (mbx_path, "mbx", mbx_dname, mbx_ename, P_code);
	if P_code ^= 0
	then return;
SET_THE_HANDLER:
	call message_facility_$get_msgf_mbx_ptr (mbx_dname, mbx_ename, PDmsgfmbx, P_code);
	if P_code ^= 0
	then return;
	call message_facility_$get_wakeup_state (PDmsgfmbx, Swakeup_state, P_code);
	if P_code ^= 0
	then return;
	Dstates_overlay.wakeup_state = ACCEPT_MESSAGES;	/* here's our where cover for the message facility */
	call message_facility_$set_wakeup_state (PDmsgfmbx, Swakeup_state, P_code);
	if P_code ^= 0
	then return;
	call message_facility_$set_wakeup_handler (PDmsgfmbx, message_handler, PIint, P_code);
	return;

restore_message_handler:
     entry (P_code);				/* arg is only to get parm var allocated */
	P_code = 0;
	PIint = null ();
	message_handler = message_facility_$default_wakeup_handler;
	call user_info_$homedir (mbx_dname);
	call user_info_$whoami (mbx_ename);
	mbx_ename = rtrim (mbx_ename) || ".mbx";
	go to SET_THE_HANDLER;

send_message:
     entry (person, project, message, P_code);
	P_code = 0;
	mbx_dname = ">udd>" || rtrim (project) || ">" || person;
	mbx_ename = rtrim (person) || ".mbx";
	Dmail.version = send_mail_info_version_2;
	call user_info_$whoami (person_id);
	Dmail.sent_from = person_id;
	string (Dmail.switches) = ""b;
	Dmail.wakeup, Dmail.always_add = "1"b;
	call message_facility_$send_message (mbx_dname, mbx_ename, message, addr (Dmail), P_code);
	return;

message_wakeup_handler:
     entry (P_msgfmbx_ptr, P_PIint);
	int_index = wordno (P_PIint);
	code = 0;
	last_message_info_ptr = addr (local_last_message_info);
	last_message_info.version = LAST_MESSAGE_INFO_VERSION_1;
	call message_facility_$get_last_message_info (P_msgfmbx_ptr, last_message_info_ptr, code);
	if code ^= 0				/* Should probably sub_err_ or something, but I'm */
	then return;				/* not sure what. */
	message_info_ptr = last_message_info.last_message_ptr;
	mail_format_ptr = message_info.message_ptr;
	date_time = fixed (substr (last_message_info.last_message_id, 19, 54), 71);
	call date_time_ (date_time, msg_date_time);
	if mail_format.sent_from = before (message_info.sender, ".") | mail_format.sent_from = ""
	     | unspec (mail_format.sent_from) = ""b
	then message_sender = substr (message_info.sender, 1, length (rtrim (message_info.sender)) - 2);
	else message_sender =
		substr (message_info.sender, 1, length (rtrim (message_info.sender)) - 2) || " ("
		|| rtrim (mail_format.sent_from) || ")";
	call ioa_$rsnnl ("^d", int_index_char, (0), int_index);
	call ioa_$rsnnl ("^d", Imsg_char, (0), last_message_info.last_message_number);
	call message_facility_$set_seen_switch (P_msgfmbx_ptr, last_message_info.last_message_id, DELETE_UNHELD, (0));
	call message_acceptor (int_index_char, Imsg_char, message_sender, msg_date_time,
	     translate (rtrim (mail_format.text, NLSPHT), "", substr (collate9 (), 1, 32) || substr (collate9 (), 128)))
	     ;
	return;					/* End of new code */

/*

   Interrupt mechanism for Multics EMACS

   Made useful for recursive emaces November 1978

*/

get_emacs_interrupt_array:
     entry returns (ptr);

	emacs_data_ptr = e_find_invocation_ ();

	return (addr (emacs_data.interrupts.array));

free_emacs_interrupt_array:
     entry;

	return;

assign_channel:
     entry (P_interruptno) returns (fixed binary);

	return (P_interruptno);

/*	primitives to set and receive emacs interrupts */

set_emacs_interrupt:
     entry (P_interruptno, P_interrupt_msg, P_intercode);

	emacs_data_ptr = e_find_invocation_ ();

	if emacs_data.flags.using_r0_echnego & ^emacs_data.flags.using_video then do;
a3r:
	     call hcs_$tty_read_echoed (emacs_data.ttyx, null (), 0, 0, (0), (0), 0, (0), code);
	     if code ^= 0
	     then call revalidate_tty (a3r);
	end;

	call hcs_$wakeup (my_pid, bl.event, 0, (0));
	P_intercode = 0;

	emacs_data.interrupts.array (0) = 1;

	allocate interrupt;
	interrupt.number = P_interruptno;
	interrupt.msg = P_interrupt_msg;
	interrupt.chain = null ();

	if emacs_data.interrupts.head = null ()
	then emacs_data.interrupts.head, emacs_data.interrupts.tail = intp;
	else do;
	     emacs_data.interrupts.tail -> interrupt.chain = intp;
	     emacs_data.interrupts.tail = intp;
	end;

	return;

get_emacs_interrupt:
     entry (P_interruptno, P_interrupt_msg);

	emacs_data_ptr = e_find_invocation_ ();

	if emacs_data.interrupts.head = null () then do;
	     P_interruptno = -1;
	     return;
	end;
	intp = emacs_data.interrupts.head;
	emacs_data.interrupts.head = interrupt.chain;
	if emacs_data.interrupts.head = null ()
	then emacs_data.interrupts.tail = null ();
	P_interruptno = interrupt.number;
	P_interrupt_msg = interrupt.msg;
	free interrupt;
	return;

set_message_cleanup:
     entry;

	emacs_data_ptr = e_find_invocation_ ();

	emacs_data.messages_were_sent_here = "1"b;
	return;

dump_out_console_messages:
     entry;

	emacs_data_ptr = e_find_invocation_ ();

	call free_emacs_interrupt_array;
	if ^emacs_data.messages_were_sent_here
	then return;
	call restore_message_handler ((0));
	do while (emacs_data.first_msgp ^= null);
	     msgp = emacs_data.first_msgp;
	     call ioa_$ioa_switch (iox_$user_io, "From ^a ^a:^/^a", based_message_struc.sender,
		based_message_struc.time, based_message_struc.msg);
	     emacs_data.first_msgp = based_message_struc.next;
	     if emacs_data.first_msgp = null
	     then emacs_data.last_msgp = null;
	     free based_message_struc;
	end;
	return;


/* Interfaces to determine/remember terminal type and line type.
   GMP, 8/27/78 */

get_terminal_type:
     entry (a_terminal_type);				/* get static terminl type */

	emacs_data_ptr = e_find_invocation_ ();

	a_terminal_type = rtrim (emacs_data.terminal_type);

	return;

set_terminal_type:
     entry (a_terminal_type1);

	emacs_data_ptr = e_find_invocation_ ();

	emacs_data.terminal_type = a_terminal_type1;

	return;

get_real_terminal_type:
     entry (a_terminal_type);

	emacs_data_ptr = e_find_invocation_ ();

	if emacs_data.input_iocb = null ()
	then emacs_data.input_iocb = iox_$user_input;

	if emacs_data.flags.using_video then do;
	     a_terminal_type = "video_system";
	     return;
	end;

/* Not video system; find out what kind of terminal. */

	tinfo.version = terminal_info_version;

	call iox_$control (emacs_data.input_iocb, "terminal_info", addr (tinfo), code);

	if code = 0
	then a_terminal_type = rtrim (tinfo.term_type);
	else a_terminal_type = "ASCII";		/* default value */

	return;

get_iocb:
     entry () returns (pointer);

	emacs_data_ptr = e_find_invocation_ ();

	return (emacs_data.input_iocb);


get_editing_chars:
     entry (P_escape_char, P_erase_char, P_kill_char);

	emacs_data_ptr = e_find_invocation_ ();

	call iox_$control (emacs_data.input_iocb, "get_editing_chars", addr (editing_chars_v1), code);
	if code ^= 0 then do;
	     call iox_$control (emacs_data.input_iocb, "get_editing_chars", addr (editing_chars_v2), code);
	     if code = 0 then do;
		P_escape_char = "\";
		P_erase_char = editing_chars_v2.erase_char;
		P_kill_char = editing_chars_v2.kill_char;
		return;
	     end;
	end;
	if code = 0 then do;
	     P_escape_char = editing_chars_v1.escape_char;
	     P_erase_char = editing_chars_v1.erase_char;
	     P_kill_char = editing_chars_v1.kill_char;
	     return;
	end;
	P_escape_char = "\";
	P_erase_char = "#";
	P_kill_char = "@";
	return;

get_network_flag:
     entry () returns (fixed binary);			/* return 1 if a Network connection */

	return (0);				/* No more network */

/* Moby SUPDUP-OUTPUT negotiator (as per RFC 749) BSG 10/1/78 */


will_supdup_output:
     entry returns (fixed bin (1));

	emacs_data_ptr = e_find_invocation_ ();

	if sdostate
	then return (1);				/* OK as is */
						/* Must try to negotiate it */
	call negotiate (SUPDUP_OUTPUT, "1"b);		/* Send the cmd */
	do while ("1"b);				/* Let's play TELNET! */
	     do while (get_char () ^= IAC);
	     end;
	     tempc = get_char ();
	     if tempc = DO then do;
		tempc = get_char ();
		if tempc = SUPDUP_OUTPUT
		then ;
		if tempc = ECHO
		then ;
	     end;
	     if tempc = DONT then do;
		tempc = get_char ();
		if tempc = SUPDUP_OUTPUT
		then return (0);
		if tempc = ECHO
		then ;
	     end;
	     if tempc = WILL | tempc = WONT then do;
		tempc = get_char ();
	     end;
	     if tempc = SB then do;
		tempc = get_char ();
		if tempc = SUPDUP_OUTPUT then do;
		     tempc = get_char ();
		     if tempc ^= 1
		     then go to run_out_sb;
		     string (sddata) = "0"b;
		     do sdbct = 0 to (hbound (sddata, 1));
			tempc = get_char ();
			if tempc = IAC
			then go to sdd_gotten;
			sddata (sdbct) = bit (fixed (tempc, 6), 6);
		     end;
		     do while (get_char () ^= IAC);
		     end;
sdd_gotten:
		     tempc = get_char ();
		     unspec (supdup_info) = string (sddata);
		     sdostate = "1"b;
		     return (1);
		end;
run_out_sb:
		do while (get_char () ^= IAC);
		end;
		tempc = get_char ();
	     end;

	end;

return_supdup_info:
     entry (a_ttyopt, a_mxh, a_mxv);

	emacs_data_ptr = e_find_invocation_ ();

	a_ttyopt = supdup_info.ttyopt;
	a_mxh = supdup_info.tcmxh;
	a_mxv = supdup_info.tcmxv;
	return;

object_check:
     entry (P_bc, P_pointer) returns (fixed bin);

	call object_info_$brief (P_pointer, P_bc, addr (bit_bucket), code);
	if code = 0
	then return (1);
	return (0);

check_window_code:
     procedure (excuse, code, retry);

declare  excuse character (*);
declare  code fixed bin (35);
declare  retry bit (1) aligned;

declare  video_et_$window_status_pending fixed bin (35) ext static;
declare  1 wsi aligned like window_status_info;

	if code = video_et_$window_status_pending then do;
	     wsi.version = window_status_version;
	     call iox_$control (emacs_data.input_iocb, "get_window_status", addr (wsi), code);
	     if code ^= 0
	     then call signal_io_error (code, "Error from get_window_status");
	     retry = "1"b;
	     code = 0;
	     return;
	end;

	if code = 0 then do;
	     retry = "0"b;
	     return;
	end;

	call signal_io_error (code, "Error from window_$" || excuse);
	return;
     end check_window_code;

check_for_window_status:
     entry (code_to_check);

	emacs_data_ptr = e_find_invocation_ ();
	call check_window_code ("<<video system ctl>>", code_to_check, (""b));

	return;

/* This entry returns the terminal's output conversion table for use in determining
   the self-insert characters. */

get_output_conv_table:
     entry (P_cv_trans);

	emacs_data_ptr = e_find_invocation_ ();

	begin options (non_quick);
dcl  chnum fixed bin;
dcl  1 cts aligned like cv_trans_struc;
dcl  CV_TRANS_VERSION_2 fixed bin int static options (constant) init (2);
						/* tty_convert.incl.pl1 declares only CV_TRANS_VERSION */
	     cts.version = CV_TRANS_VERSION_2;
	     cts.default = 0;
	     call iox_$control (emacs_data.input_iocb, "get_output_conversion", addr (cts), code);
	     if code = 0
	     then P_cv_trans = cts.cv_trans;
	     else do;				/* fix up table */
		do chnum = 32 to 126;		/* printing */
		     P_cv_trans.value (chnum) = OUTPUT_CONVERT_ORDINARY;
		end;
		do chnum = 0 to 31, 127 to 255;	/* octal escape */
		     P_cv_trans.value (chnum) = OUTPUT_CONVERT_OCTAL;
		end;
	     end;
	end;
	return;

     end e_pl1_;
