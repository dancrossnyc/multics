/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_gns.pl1 Reformatted code to new Cobol standard.
                                                   END HISTORY COMMENTS */


/* Modified on 11/31/81 by FCH, [5.1-1], reset lerr to prevent loop, phx12017(BUG521) */
/* Modified on 05/19/81 by FCH, [4.4-3], $ and _ allowed in symbols in some cases */
/* Modified on 04/09/81 by FCH, [4.4-2], fix bugs in leveling for validation-81, BUG477 */
/* Modified on 12/05/80 by FCH, [4.4-1], report_writer added */
/* Modified on 04/18/80 by FCH, [4.2-8], zero length non-num lit, "" ,detected(BUG439) */
/* Modified on 04/09/80 by FCH, [4.2-7], fix problems in flagging */
/* Modified on 10/8/79 by MHD, [4.2-6], assigning 9999 to COLUMN for DEBUG statements */
/* Modified on 05/15/79 by FCH, [4.0-5], debug statement */
/* Modified on 04/17/79 by FCH, [4.0-4], " or ' delim alphanum lits */
/* Modified on 04/11/79 by FCH, [4.0-3], ignore term . if skipping copy statement */
/* Modified on 04/05/79 by FCH, [4.0-2], gcos alphalit continuation implemented */
/* Modified on 03/22/79 by FCH, [4.0-1], prepare duplicated data name table */
/* Modified on 03/28/78 by FCH, [3.0-4], lev diag 34 issued as extension */
/* Modified on 01/02/78 by FCH, [3.0-3], program-id containing _ detected */
/* Modified on 11/16/77 by FCH, [3.0-2], leveling diag 44 emitted */
/* Modified on 09/08/77 by FCH, [3.0-1], emit level for leveling diags 1,2, and 4 fixed */
/* Modified since Version 4.0 */





/* format: style3 */
cobol_gns:
     proc;

/* ========================================================================== */
/*                                                                            */
/* Procedure gns is the primary module of the lex complex. it is responsible  */
/* for the original classification and issolation of all items from the users */
/* source cards.	   						  */
/*                                                                            */
/* ========================================================================== */

/*   general overlay for any token    */
dcl	1 token		based (cobol_current),
	  2 fwd_link	pointer,
	  2 back_link	pointer,
	  2 rep_link	pointer,
	  2 l_info	bit (8),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin;		/*   reserved_word    */
dcl	1 reserved_word	based (cobol_current),
	  2 fwd_link	pointer,
	  2 back_link	pointer,
	  2 rep_link	pointer,
	  2 l_info	bit (8),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,		/* = 1 */
	  2 key		fixed bin,
	  2 class		bit (26),
	  2 jump_index	fixed bin,		/*[4.4-1]*/
	  2 length	fixed bin,		/*[4.4-1]*/
	  2 name		char (30);		/*   numeric_lit    */
dcl	1 numeric_lit	based (cobol_current),
	  2 fwd_link	pointer,
	  2 back_link	pointer,
	  2 rep_link	pointer,
	  2 l_info	bit (8),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,		/* = 2 */
	  2 info		bit (8),
	  2 sign		char (1),
	  2 exp_sign	char (1),
	  2 exp_places	fixed bin,
	  2 places_left	fixed bin,
	  2 places_right	fixed bin,
	  2 places	fixed bin,
	  2 literal	char (30);

/*   alphanum_lit    */
dcl	1 alphanum_lit	based (cobol_current),
	  2 fwd_link	pointer,
	  2 back_link	pointer,
	  2 rep_link	pointer,
	  2 l_info	bit (8),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,		/* = 3 */
	  2 info		bit (8),
	  2 length	fixed bin,
	  2 string	char (200);

/*   picture    */
dcl	1 picture		based (cobol_current),
	  2 fwd_link	pointer,
	  2 back_link	pointer,
	  2 rep_link	pointer,
	  2 l_info	bit (8),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,		/* = 4 */
	  2 length	fixed bin,
	  2 string	char (30);

/*   user_word    */
dcl	1 user_word	based (cobol_current),
	  2 fwd_link	pointer,
	  2 back_link	pointer,
	  2 rep_link	pointer,
	  2 l_info	bit (8),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,		/* = 8 */
	  2 info		bit (8),
	  2 length	fixed bin,
	  2 word		char (30);

dcl	1 debug		based (cobol_current),
	  2 fwd_link	pointer,
	  2 back_link	pointer,
	  2 rep_link	pointer,
	  2 l_info	bit (8),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 debug_index	fixed bin,
	  2 on_off	bit (1);

dcl	cobol_lexerr$lexerr3
			entry (fixed bin, bit (1), fixed bin, char (50)) external;
dcl	cobol_gns		entry external;
dcl	cobol_merge	entry ext;
dcl	cobol_insert_token	entry (fixed bin, fixed bin) external;
dcl	cobol_delete_tokens entry (pointer, pointer) external;
declare	cobol_c_list	entry (ptr);
dcl	mask		bit (8);
dcl	(wl, wll, places_left, exp_places, i, save_pcol, rwk)
			fixed bin;
dcl	rwc		bit (26);
dcl	wb		char (256) static;
dcl	(num_sign, exp_sign, per)
			char (1);
dcl	(exp_sw, integer_sw, found_comma)
			bit (1);
dcl	period_sw		bit (1) static init ("0"b);
dcl	dlmck1_sw		bit (1);
dcl	(rep_factor, save_nr_char, slen)
			fixed bin static,
	(c1, hc, hc1)	char (1);
dcl	(hc_ptr, hc1_ptr)	ptr;
dcl	quot_ch		char (1);
declare	np_char		bit (1);
dcl	1 hcs		based,
	  2 lp		bit (5),
	  2 rp		bit (4);
dcl	1 hcs1		based,
	  2 lp		bit (4),
	  2 rp		bit (5);
dcl	1 hcs2		based (hc_ptr),
	  2 fill		bit (3),
	  2 hc_ck		bit (1),
	  2 ehc_ck	bit (1),
	  2 fill2		bit (4);			/*[4.4-2]*/
						/* declare CONT bit(1); */
dcl	(lerr, per_sw)	bit (1) static;
dcl	save_sw		bit (1) static init ("0"b);
dcl	xplus_op		fixed bin static init (182);
dcl	xequal_op		fixed bin static init (102);
dcl	xminus_op		fixed bin static init (183);
dcl	xtimes_op		fixed bin static init (184);
dcl	xdivide_op	fixed bin static init (185);
dcl	xexponent		fixed bin static init (186);
dcl	xleft_paren	fixed bin static init (187);
dcl	xright_paren	fixed bin static init (188);
dcl	xperiod		fixed bin static init (189);
dcl	xgreater_than	fixed bin static init (113);
dcl	xless_than	fixed bin static init (123);
dcl	(addr, fixed, index, null, substr, translate, unspec, mod)
			builtin;

/*[4.4-2]*/
/* CONT = "0"b; */


start:
	dlmck1_sw = "1"b;

	do while (substr (cobol_cards.name, cobol_cards.nr_char, 1) = " ");

	     cobol_cards.nr_char = cobol_cards.nr_char + 1;

	end;

	if substr (cobol_cards.name, cobol_cards.nr_char, 1) = cobol_new_line_character
	then do;					/* get next card and scanoff spaces */
		call cobol_merge;
		go to start;
	     end;

	if cobol_scanoff_sw
	then do;
		per_sw = "0"b;
scanoff:
		do while (substr (cobol_cards.name, cobol_cards.nr_char, 1) = cobol_new_line_character);

		     call cobol_merge;

		     do while (substr (cobol_cards.name, cobol_cards.nr_char, 1) = " ");

			cobol_cards.nr_char = cobol_cards.nr_char + 1;

		     end;

		end;

		if cobol_cards.nr_char < 12
		then return;

		if substr (cobol_cards.name, cobol_cards.nr_char, 1) = "."
		then do;

			if per_sw = "0"b
			then do;
				per_sw = "1"b;

				call cobol_insert_token (1, 0);
						/*[4.0-1]*/
				prev_tok_type = 0;

				reserved_word.line = cobol_save_cln;
				reserved_word.column = cobol_save_col;
				reserved_word.key = xperiod;
				reserved_word.class = "0001"b;
			     end;

			cobol_cards.nr_char = cobol_cards.nr_char + 1;
			goto scanoff;
		     end;

		cobol_cards.nr_char = cobol_cards.nr_char + 1;
		goto scanoff;
	     end;

ck_stack_end:
	if token.fwd_link ^= null ()
	then do;

		cobol_current = token.fwd_link;

		if (token.type = 6) | (token.type = 5)
		then goto ck_stack_end;
		return;
	     end;

	cobol_save_cln = cobol_c_l_n;
	cobol_save_col = cobol_cards.nr_char;
	wl = 1;

/*[4.2-6]*/
	if substr (cobol_cards.name, 1, 6) = "~~~~~~"	/*[4.2-6]*/
	then TOK_COLUMN = 9999;			/*[4.2-6]*/
	else TOK_COLUMN = cobol_save_col;

	if cobol_pic_switch
	then goto pic_proc;				/* switch on first character first */

/*[4.4-1]*/
	new_ch = substr (cobol_cards.name, cobol_cards.nr_char, 1);

/*[4.4-1]*/
	goto l (x (fixed (unspec (new_ch), 15)));

/*[4.4-1]*/
declare	new_ch		char (1);			/* leveling diagnostics */

lev_diag:
     proc (lin, col, num);

declare	(lin, col, num)	fixed bin;

declare	1 diag_item,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 run		fixed bin,
	  2 number	fixed bin,
	  2 info		bit (32);

	diag_item.size = 28;
	diag_item.type = 5;
	diag_item.run = 9;
	diag_item.info = "0"b;

	diag_item.line = lin;
	diag_item.column = col;
	diag_item.number = num;

	call cobol_c_list (addr (diag_item));

     end;


/* COMMON OPERATOR CODE */

ops1:
	cobol_cards.nr_char = cobol_cards.nr_char + 1;
ops1a:
	if substr (cobol_cards.name, cobol_cards.nr_char, 1) = cobol_new_line_character
	then call cobol_merge;

	call cobol_insert_token (1, 0);

/*[4.0-1]*/
	prev_tok_type = 0;

	reserved_word.key = rwk;
	reserved_word.class = rwc;
	reserved_word.line = cobol_save_cln;		/*[4.2-6]*/
	reserved_word.column = TOK_COLUMN;

/*[4.4-1]*/
	if report_exists				/*[4.4-1]*/
	then do;					/*[4.4-1]*/
		reserved_word.length = 1;		/*[4.4-1]*/
		substr (reserved_word.name, 1, 1) = new_ch;
						/*[4.4-1]*/
		reserved_word.size = reserved_word.size + 5;
						/*[4.4-1]*/
	     end;

/*[4.4-2]*/
/*
	if fixed_common.comp_level < "3" & CONT
	then	do;	call lev_diag	(	reserved_word.line,
						reserved_word.column,
							1
					);

			CONT = "0"b;
		end;
*/
/*[4.4-2]*/

	return;

/* end of first character selection portion */


/* ALPHANUMERIC-- USER WORD */


l (1):						/* user words: a -> z */
alpha:
	mask = "10000000"b;
	wll = 30;
	call swm;

	if lerr
	then do;
w_l_err:
		call cobol_lexerr$lexerr3 (2, "1"b, 2, "30");
						/*[5.1-1]*/
		lerr = "0"b;
		return;
	     end;

	if substr (cobol_cards.name, cobol_cards.nr_char, 1) = cobol_new_line_character
	then do;
		call cobol_merge;

		if cobol_continuation = "1"b
		then do;
			cobol_continuation = "0"b;

/*[4.4-2]*/
/* CONT = "1"b; */

			goto alpha;
		     end;
		goto uw_dlm_ok;
	     end;

	c1 = substr (wb, wl, 1);
	mask = mem_tab (fixed (unspec (c1), 35));

	if mask & "00001000"b
	then if c1 ^= """"
	     then do;

		     if c1 = "."
		     then period_sw = "1"b;
		     else period_sw = "0"b;

		     go to uw_dlm_ok;
		end;

	     else do;
		     call ill_dlm;
		     goto uw_dlm_ok;
		end;

	if cobol_head_words (3) & ^cobol_head_words (4)
	then do;

		if dlmck1_sw
		then dlmck1_sw = "0"b;

		cobol_cards.nr_char = cobol_cards.nr_char + 1;
		wl = wl + 1;
		goto alpha;
	     end;

	if cobol_progid_sw & c1 = "_"			/*[3.0-3]*/
	then do;
		cobol_cards.nr_char = cobol_cards.nr_char + 1;
		wl = wl + 1;
		substr (wb, wl, 1) = /*[3.0-3]*/ substr (cobol_cards.name, cobol_cards.nr_char, 1);

		if substr (wb, wl, 1) = "."		/*[3.0-3]*/
		then do;
			period_sw = "1"b;
			go to uw_dlm_ok;
		     end;				/*[3.0-3]*/
		else go to alpha;			/*[3.0-3]*/
	     end;
	call ill_char;
	return;

uw_dlm_ok:
	wl = wl - 1;

	if substr (wb, wl, 1) = "-"			/* illegal termination of item */
	then do;
		call ill_char;
		return;
	     end;

/*[4.4-1]*/
	if ^processing_report
	then if cobol_lu_sw
	     then substr (wb, 1, wl) = translate (substr (wb, 1, wl), lower_case_alphabet);

	call cobol_insert_token (8, wl);

/*[4.0-1]*/
	if fixed_common.comp_level < "3"		/*[4.0-1]*/
	then /*[4.0-1]*/
	     if prev_tok_type = 1			/*[4.0-1]*/
	     then do;
		     ch36 = substr (wb, 1, wl) || "~";

/*[4.0-1]*/
		     if ch36 ^= "filler~"		/*[4.0-1]*/
		     then /*[4.0-1]*/
			if index (tok_string, "~" || ch36) <= 0
						/*[4.0-1]*/
			then tok_string = tok_string || ch36;
						/*[4.0-1]*/
			else call cobol_ddsyntax$enter_tok_string (ch36);
						/*[4.0-1]*/
		end;

/*[4.0-1]*/
	prev_tok_type = 0;

	user_word.line = cobol_save_cln;		/*[4.2-6]*/
	user_word.column = TOK_COLUMN;
	user_word.length = wl;
	substr (user_word.word, 1, wl) = substr (wb, 1, wl);

/*[4.4-2]*/
/*
	if fixed_common.comp_level < "3" & CONT
	then	do;	call lev_diag	(	user_word.line,
						user_word.column,
						1
					);

			CONT = "0"b;
		end;
*/
/*[4.4-2]*/

	if fixed_common.comp_level < "3" & index ("0123456789", substr (user_word.word, 1, 1)) ^= 0
						/*[3.0-1]*/
	then call lev_diag (user_word.line, user_word.column, 4);

	if fixed_common.comp_level < "5" /* [3.0-4] */ & /* [3.0-4] */ cobol_progid_sw /* [3.0-4] */
	     & /* [3.0-4] */ index (substr (wb, 1, wl), "_") ^= 0
						/* [3.0-4] */
	then call lev_diag (user_word.line,		/*[3.0-3]*/
		user_word.column,			/*[3.0-3]*/
		34 /*[3.0-3]*/);			/*[3.0-3]*/

	if ^dlmck1_sw
	then call cobol_lexerr$lexerr3 (1, "0"b, 0, " ");

	return;


/* NUMERIC LITERIAL (FLOATING POINT) */


l (2):						/* numeric literals: 0 -> 9 */
digit:
	if cobol_head_words (5) & (cobol_cards.nr_char < 12)
	then goto alpha;				/* label--treat as a word */

	num_sign = " ";
d1a:
	integer_sw = "0"b;
	exp_sign = " ";
	exp_sw = "0"b;
	places_left = 0;
	exp_places = 0;
	per = " ";
	found_comma = "0"b;

d1:						/* return label for continuation of part 1 of digits */
						/* following size limit is 30 because of numeric procedure names */
	mask = "01000000"b;
	wll = 30;
	call swm;

	if lerr
	then do;
nl_l_err:
		call cobol_lexerr$lexerr3 (2, "1"b, 2, "30");
						/*[5.1-1]*/
		lerr = "0"b;
		return;
	     end;

	c1 = substr (cobol_cards.name, cobol_cards.nr_char, 1);

	if c1 = cobol_new_line_character
	then do;
		call cobol_merge;

		if cobol_continuation = "1"b
		then do;
			cobol_continuation = "0"b;

/*[4.4-2]*/
/* CONT = "1"b; */

			goto d1;
		     end;

		integer_sw = "1"b;
		places_left = wl - 1;
		goto nl_dlm_ok;
	     end;

	if mem_tab (fixed (unspec (c1), 35)) & "10000000"b
	then goto alpha;

	integer_sw = "1"b;
	places_left = wl - 1;			/* set count field */

	if c1 = cobol_comma_character			/*[4.2-7]*/
	then do;
		found_comma = "1"b;			/*[4.2-7]*/
		cobol_save_cln = cobol_c_l_n;		/*[4.2-7]*/
		cobol_save_col = cobol_cards.nr_char;	/*[4.2-7]*/
	     end;
	else if c1 ^= cobol_decimal_point_character
	then do;
build_nlt:
		c1 = substr (cobol_cards.name, cobol_cards.nr_char, 1);
		mask = mem_tab (fixed (unspec (c1), 35));

		if (mask & "00000001"b) | (c1 = ")")
		then goto nl_dlm_ok;

		if (c1 ^= """") & (c1 ^= "(")
		then do;
			call ill_char;
			return;
		     end;

/*call ill_dlm;*/

nl_dlm_ok:
		wl = wl - 1;

		call cobol_insert_token (2, wl);

		numeric_lit.line = cobol_save_cln;	/*[4.2-6]*/
		numeric_lit.column = TOK_COLUMN;
		numeric_lit.places = wl;
		substr (numeric_lit.info, 1, 1) = integer_sw;
		substr (numeric_lit.info, 2, 1) = exp_sw;
		numeric_lit.sign = num_sign;
		numeric_lit.exp_sign = exp_sign;
		numeric_lit.places_left = places_left;
		numeric_lit.exp_places = exp_places;
		numeric_lit.places_right = wl - places_left - exp_places;
		substr (numeric_lit.literal, 1, wl) = substr (wb, 1, wl);

/*[4.0-1]*/
		if fixed_common.comp_level < "3"
		then do;

/*[4.0-1]*/
			prev_tok_type = 0;

/*[4.0-1]*/
			if cobol_head_words (4) & ^(cobol_head_words (5))
						/*[4.0-1]*/
			then if numeric_lit.sign = " " & numeric_lit.places_right = 0
						/*[4.0-1]*/
			     then do;
				     int_val = fixed (substr (numeric_lit.literal, 1, wl));

/*[4.0-1]*/
				     if int_val >= 2 & int_val <= 49
						/*[4.0-1]*/
				     then prev_tok_type = 1;
						/*[4.0-1]*/
				end;

/*[4.0-1]*/
		     end;

/*[4.4-2]*/
/*
			if fixed_common.comp_level < "3" & CONT
			then	do;	call lev_diag	(	numeric_lit.line,
								numeric_lit.column,
								1
							);

					CONT = "0"b;
				end;
*/
/*[4.4-2]*/

		if per = "."
		then do;				/* Generate reserved word token "." (EOS). */

/*[4.0-3]*/
			token.l_info = linfo;
gen_per:
			cobol_save_col = save_pcol;
			rwk = xperiod;
			rwc = "0001"b;
			goto ops1a;
		     end;
		return;

	     end;

	save_pcol = cobol_cards.nr_char;
	per = substr (cobol_cards.name, save_pcol, 1);	/* save delimiter */
	cobol_cards.nr_char = cobol_cards.nr_char + 1;
	c1 = substr (cobol_cards.name, cobol_cards.nr_char, 1);

/*[4.0-3]*/
	if per = "."
	then linfo = token.l_info;

	if c1 = cobol_new_line_character
	then do;
		call cobol_merge;

		if cobol_continuation = "1"b
		then do;
			cobol_continuation = "0"b;

/*[4.4-2]*/
/* CONT = "1"b; */

			if mem_tab (fixed (unspec (substr (cobol_cards.name, cobol_cards.nr_char, 1)), 35))
			     & "01000000"b
			then if found_comma
			     then do;
				     call ill_char;
				     return;
				end;
			     else go to d2;

			call cobol_lexerr$lexerr3 (9, "1"b, 0, " ");

			return;

		     end;
		goto nl_dlm_ok;
	     end;

	if mem_tab (fixed (unspec (c1), 35)) & "01000000"b
	then if found_comma
	     then do;
		     call ill_char;
		     return;
		end;
	     else go to d2;


/*[4.2-7]*/
	if found_comma				/*[4.2-7]*/
	then if fixed_common.comp_level < "3"		/*[4.2-7]*/
	     then call lev_diag (cobol_save_cln, cobol_save_col, 2);
						/* ;, as sepatator */

	goto build_nlt;

/* right part of a number */

d2:
	integer_sw = "0"b;
	per = " ";
	mask = "01000000"b;
	wll = 18;
	call swm;

	if lerr
	then goto nl_l_err;

	c1 = substr (cobol_cards.name, cobol_cards.nr_char, 1);

	if c1 = cobol_new_line_character
	then do;
		call cobol_merge;

		if cobol_continuation = "1"b
		then do;
			cobol_continuation = "0"b;

/*[4.4-2]*/
/* CONT = "1"b; */

			goto d2;
		     end;
		goto nl_dlm_ok;
	     end;

/*	if c1 ^= "e" & c1 ^= "E" then  */
	goto build_nlt;

/* STRING PROCESSING */

s3:						/* continuation loop label */
	slen =
	     index (substr (cobol_cards.name, cobol_cards.nr_char, cobol_cards.column - cobol_cards.nr_char + 1), """");

	if slen = 0
	then slen = cobol_cards.column - cobol_cards.nr_char;
	else slen = slen - 1;

	if slen + wl - 1 > 200
	then do;
al_l_err:
		call cobol_lexerr$lexerr3 (4, "1"b, 3, "200");
		return;
	     end;

	if slen ^= 0
	then do;

		substr (wb, wl, slen) = substr (cobol_cards.name, cobol_cards.nr_char, slen);
		cobol_cards.nr_char = cobol_cards.nr_char + slen;
						/* terminating " or new_line  */
		wl = wl + slen;			/* cobol_current true size + 1 */

	     end;

	if substr (cobol_cards.name, cobol_cards.nr_char, 1) = cobol_new_line_character
	then do;
		i = cobol_cards.tblanks;

		call cobol_merge;

		if cobol_continuation = "1"b
		then do;
			cobol_continuation = "0"b;

/*[4.4-2]*/
/* CONT = "1"b; */

			if i ^= 0
			then do;
				substr (wb, wl, i) = " ";
				wl = wl + i;
			     end;



			if substr (cobol_cards.name, cobol_cards.nr_char, 1) ^= quot_ch
			then do;
				call cobol_lexerr$lexerr3 (5, "1"b, 0, " ");
				call scan_off;
				return;
			     end;

			cobol_cards.nr_char = cobol_cards.nr_char + 1;
			goto s3;			/* normal continuation */

		     end;

		goto alit_err;
	     end;

	if substr (cobol_cards.name, cobol_cards.nr_char, 1) = quot_ch
	then goto ck_quote;

alit_err:						/* illegal termination of literal string */
	call cobol_lexerr$lexerr3 (3, "1"b, 0, " ");
	call scan_off;
	return;

ck_quote:
	if substr (cobol_cards.name, cobol_cards.nr_char + 1, 1) = quot_ch
	then do;
		substr (wb, wl, 1) = quot_ch;		/* double quote */
		wl = wl + 1;
		cobol_cards.nr_char = cobol_cards.nr_char + 2;
		goto s3;
	     end;

	if substr (cobol_cards.name, cobol_cards.nr_char + 1, 1) = cobol_new_line_character
						/* single quote */
	then do;
		call cobol_merge;

		if cobol_continuation = "1"b
		then do;
			cobol_continuation = "0"b;

/*[4.4-2]*/
/* CONT = "1"b; */

			if substr (cobol_cards.name, cobol_cards.nr_char, 1) ^= quot_ch
			then do;
				call cobol_lexerr$lexerr3 (5, "1"b, 0, " ");
				call scan_off;
				return;
			     end;

/*[4.0-2]*/
/* continued double quote */

/*[4.0-2]*/
			if substr (fixed_common.compile_mode, 1, 1)
						/*[4.0-2]*/
			then do;			/* gcos */

/*[4.0-2]*/
				posit = cobol_cards.nr_char + 1;
						/*[4.0-2]*/
				ch = substr (cobol_cards.name, posit, 1);

ct:						/*[4.0-2]*/
				if ch = quot_ch	/*[4.0-2]*/
				then do;
					posit = posit + 1;
						/*[4.0-2]*/
					ch = substr (cobol_cards.name, posit, 1);

/*[4.0-2]*/
					go to ct; /*[4.0-2]*/
				     end;

/*[4.0-2]*/
				posit = posit - cobol_cards.nr_char;

/*[4.0-2]*/
				if ch = "
"
				then posit = posit - 1;

/*[4.0-2]*/
				if mod (posit, 2) = 1
						/*[4.0-2]*/
				then go to l (3);

/*[4.0-2]*/
			     end;

			goto ck_quote;
		     end;
		goto al_dlm_ok;
	     end;

	hc_ptr = addr (hc);
	hc1_ptr = addr (hc1);
	cobol_cards.nr_char = cobol_cards.nr_char + 1;
	hc = substr (cobol_cards.name, cobol_cards.nr_char, 1);
	hc = hexl_tab (fixed (unspec (hc), 35));

	if hcs2.hc_ck = "0"b
	then goto end_alit;

	np_char = "1"b;

	goto next_hex1;

next_hex:
	cobol_cards.nr_char = cobol_cards.nr_char + 1;
	hc = substr (cobol_cards.name, cobol_cards.nr_char, 1);

	if hc = quot_ch
	then do;
		cobol_cards.nr_char = cobol_cards.nr_char + 1;
		goto s3;
	     end;

	hc = hexl_tab (fixed (unspec (hc), 35));

	if hcs2.hc_ck = "0"b
	then do;

		if substr (cobol_cards.name, cobol_cards.nr_char, 1) = cobol_new_line_character
		then do;
			call cobol_merge;

			if cobol_continuation = "1"b
			then do;
				cobol_continuation = "0"b;

/*[4.4-2]*/
/* CONT = "1"b; */

				if substr (cobol_cards.name, cobol_cards.nr_char, 1) = quot_ch
				then goto next_hex;

			     end;
		     end;
hex_err:
		call cobol_lexerr$lexerr3 (25, "1"b, 0, " ");

		return;

	     end;

next_hex1:
	hc1_ptr -> hcs.lp = hc_ptr -> hcs1.rp;

hex_c:
	cobol_cards.nr_char = cobol_cards.nr_char + 1;
	hc = substr (cobol_cards.name, cobol_cards.nr_char, 1);

	if hc = quot_ch
	then goto hex_err;


	hc = hexl_tab (fixed (unspec (hc), 35));

	if hcs2.hc_ck = "0"b
	then do;

		if substr (cobol_cards.name, cobol_cards.nr_char, 1) = cobol_new_line_character
		then do;
			call cobol_merge;

			if cobol_continuation = "1"b
			then do;
				cobol_continuation = "0"b;

/*[4.4-2]*/
/* CONT = "1"b; */

				if substr (cobol_cards.name, cobol_cards.nr_char, 1) = c1
				then goto hex_c;

			     end;
		     end;

		goto hex_err;

	     end;

	hc1_ptr -> hcs.rp = hc_ptr -> hcs.rp;
	substr (wb, wl, 1) = hc1;
	wl = wl + 1;

	goto next_hex;

end_alit:						/*[4.2-8]*/
	if wl = 1 | wl > 211
	then do;					/* literal too long */
		call cobol_lexerr$lexerr3 (4, "1"b, 3, "200");
		return;
	     end;

	c1 = substr (cobol_cards.name, cobol_cards.nr_char, 1);
	mask = mem_tab (fixed (unspec (c1), 35));

	if (mask & "00000001"b) | (c1 = ")")
	then goto al_dlm_ok;

	call ill_dlm;
al_dlm_ok:
	wl = wl - 1;

	if np_char & fixed_common.comp_level < "5"
	then call lev_diag (cobol_save_cln, cobol_save_col, 134);

	call cobol_insert_token (3, wl);

/*[4.0-1]*/
	prev_tok_type = 0;

	alphanum_lit.line = cobol_save_cln;		/*[4.2-6]*/
	alphanum_lit.column = TOK_COLUMN;
	alphanum_lit.length = wl;
	substr (alphanum_lit.string, 1, wl) = substr (wb, 1, wl);
						/*[4.4-2]*/
	alpha_lit_bit = "0"b;

	return;

/* BIT STRING LITERIALS */

l (3):						/* alpha-numeric literals and bit strings: " */
						/*[4.0-4]*/
	quot_ch = """";				/*[4.4-2]*/
	alpha_lit_bit = "1"b;

l3:						/* bit string */
						/* alphanumeric literal */
	np_char = "0"b;
	cobol_cards.nr_char = cobol_cards.nr_char + 1;
	goto s3;

l (4):						/*[4.0-4]*/
	if substr (fixed_common.compile_mode, 2, 1)	/*[4.0-4]*/
	then do;
		quot_ch = "'";			/*[4.0-4]*/
		go to l3;				/*[4.0-4]*/
	     end;

/*[4.0-4]*/
	go to l (10);				/* COMMA OR SEMI-COLOMN CHARACTERS */

l (5):						/* comma and semi colon */
	cobol_cards.nr_char = cobol_cards.nr_char + 1;

	if ^mem_tab (fixed (unspec (substr (cobol_cards.name, cobol_cards.nr_char, 1)), 35)) & "00000010"b
	then call ill_dlm;

	if fixed_common.comp_level < "3"		/*[3.0-1]*/
	then call lev_diag (cobol_save_cln, cobol_save_col, 2);

	goto start;

/* SIGN--ARITHEMATIC OPERATORS */

l (6):
	;					/*  + operator */
l (18):						/* - operator */
	if cobol_cards.nr_char > 12
	then if substr (cobol_cards.name, cobol_cards.nr_char - 1, 1) = ")"
	     then call ill_dlm1;

	c1 = substr (cobol_cards.name, cobol_cards.nr_char, 1);
	cobol_cards.nr_char = cobol_cards.nr_char + 1;

	if substr (cobol_cards.name, cobol_cards.nr_char, 1) = cobol_new_line_character
	then do;
		call cobol_merge;

		if cobol_continuation = "1"b
		then do;
			cobol_continuation = "0"b;

/*[4.4-2]*/
/* CONT = "1"b; */

		     end;
		else goto sign1;

	     end;

	if mem_tab (fixed (unspec (substr (cobol_cards.name, cobol_cards.nr_char, 1)), 35)) & "01000000"b
	then goto sign2;				/* it is a sign character */

	if substr (cobol_cards.name, cobol_cards.nr_char, 1) = cobol_decimal_point_character
	then go to sign2;

	if ^mem_tab (fixed (unspec (substr (cobol_cards.name, cobol_cards.nr_char, 1)), 35)) & "00000010"b
	then call ill_dlm2;

	cobol_cards.nr_char = cobol_cards.nr_char - 1;

sign1:
	if c1 = "+"
	then do;
		rwk = xplus_op;
		rwc = "01"b;
	     end;
	else do;
		rwk = xminus_op;
		rwc = "01"b;
	     end;

	go to ops1;

/*   ARITHMETIC OPERATOR */

sign2:						/* must be a sign if here else an error */
	num_sign = c1;
	goto d1a;



/* ASTERISK PROCESSOR */

l (7):						/* multiply and exponent operators */
	if cobol_cards.nr_char > 12
	then if substr (cobol_cards.name, cobol_cards.nr_char - 1, 1) = ")"
	     then call ill_dlm1;

	c1 = substr (cobol_cards.name, cobol_cards.nr_char + 1, 1);

	if mem_tab (fixed (unspec (c1), 35)) & "00000010"b
	then do;					/* valid delimiter found */
put_ast:
		rwk = xtimes_op;
		rwc = "01"b;
		goto ops1;
	     end;					/* multiply operator */

	if c1 = "*"
	then do;					/* exponent operator */

		c1 = substr (cobol_cards.name, cobol_cards.nr_char + 2, 1);
		rwk = xexponent;
		rwc = "01"b;

		if ^mem_tab (fixed (unspec (c1), 35)) & "00000010"b
		then call ill_dlm2;

		cobol_cards.nr_char = cobol_cards.nr_char + 1;
		go to ops1;

	     end;					/* legal part */

	call ill_dlm2;				/* must be illegal if here */

	goto put_ast;
l (8):						/* unused */
	call ill_char;
	return;


l (9):						/* slash "/" */
	if cobol_cards.nr_char > 12
	then if substr (cobol_cards.name, cobol_cards.nr_char - 1, 1) = ")"
	     then call ill_dlm1;

	if ^mem_tab (fixed (unspec (substr (cobol_cards.name, cobol_cards.nr_char + 1, 1)), 35)) & "00000010"b
	then call ill_dlm2;

	rwk = xdivide_op;
	rwc = "01"b;

	goto ops1;

/* BAD CHARACTER IN USERS INPUT SOURCE */

l (10):						/* 000->011 013->037 ! # $  : ? @ A->Z [ \ ] ^ _ ` { | } ~ PAD */
	call ill_char;
	return;

ill_char:
     proc;

	call cobol_lexerr$lexerr3 (1, "1"b, 0, " ");
	call scan_off;
     end;

/* SPECIAL OPERATORS--BLANKS NOT REQUIRED>> */

l (11):						/* (  character. */
	rwk = xleft_paren;
	rwc = "0"b;
	goto ops1;

l (12):						/* blank and end of line characters */
	goto start;

l (13):						/* ) character. */
	rwk = xright_paren;
	rwc = "0"b;
	goto ops1;

/* NORMAL OPERATORS */

l (14):						/* "." */
	c1 = substr (cobol_cards.name, cobol_cards.nr_char, 1);

	if ^period_sw				/* if not used as user word delimiter */
	then do;

		if c1 = cobol_decimal_point_character
		then if mem_tab (fixed (unspec (substr (cobol_cards.name, cobol_cards.nr_char + 1, 1)), 35))
			& "01000000"b
		     then go to digit;

	     end;
	else period_sw = "0"b;

	if ^mem_tab (fixed (unspec (substr (cobol_cards.name, cobol_cards.nr_char + 1, 1)), 35)) & "00000010"b
	then do;
		call ill_dlm;

		if fixed_common.comp_level < "5"
		then do;
			call lev_diag (reserved_word.line, reserved_word.column, 145);
		     end;
	     end;

	rwk = xperiod;
	rwc = "0001"b;
	goto ops1;

l (15):						/* "=" and "==" (psuedo-text delimiter) operators */
	c1 = substr (cobol_cards.name, cobol_cards.nr_char + 1, 1);

	if c1 = "="
	then do;
		rwk = 256;			/* == */
		rwc = "0"b;
		cobol_cards.nr_char = cobol_cards.nr_char + 1;
		go to ops1;
	     end;

	if mem_tab (fixed (unspec (c1), 35)) & "00000010"b
	then do;
put_eq:
		rwk = xequal_op;
		rwc = "0000110"b;
		goto ops1;
	     end;

	call ill_dlm;

	goto put_eq;

l (16):						/* "<" */
	if ^mem_tab (fixed (unspec (substr (cobol_cards.name, cobol_cards.nr_char + 1, 1)), 35)) & "00000010"b
	then call ill_dlm;

	rwk = xless_than;
	rwc = "0000110"b;
	goto ops1;

l (17):						/* ">" */
	if ^mem_tab (fixed (unspec (substr (cobol_cards.name, cobol_cards.nr_char + 1, 1)), 35)) & "00000010"b
	then call ill_dlm;

	rwk = xgreater_than;
	rwc = "0000110"b;
	goto ops1;

/* PROCESS PICTURE CHARACTER STRINGS */

pic_proc:						/* picture string processor */
dcl	(cont_flag, cont_flag1)
			bit (1),
	a		char (1),
	(h_index, st_pos)	fixed bin;

	if substr (cobol_cards.name, cobol_cards.nr_char, 1) = "I"
	     | substr (cobol_cards.name, cobol_cards.nr_char, 1) = "i"
	then goto alpha;				/* handle the case of is */

p_p:						/* external entry--cobol_continuation point */
	per = " ";
	mask = "00100000"b;
	wll = 31;
	call swm;

/* (31 to allow for a terminating "." in the scan) */
	if lerr
	then goto w_l_err;

	save_pcol = cobol_cards.nr_char - 1;
	per = substr (cobol_cards.name, save_pcol, 1);




	if substr (cobol_cards.name, cobol_cards.nr_char, 1) = cobol_new_line_character
	then do;
		call cobol_merge;

		if cobol_continuation = "1"b
		then do;
			cobol_continuation = "0"b;

/*[4.4-2]*/
/* CONT = "1"b; */

			goto p_p;
		     end;

		if mem_tab (fixed (unspec (per), 35)) & "00000001"b
		then wl = wl - 2;
		else wl = wl - 1;

		goto p_p2;
	     end;

	if mem_tab (fixed (unspec (substr (wb, wl, 1)), 35)) & "00000001"b
	then do;					/* must back up one character position */
		wl = wl - 1;

		if mem_tab (fixed (unspec (substr (wb, wl, 1)), 35)) & "00000100"b
		then do;				/* delimiter in the string now */
			wl = wl - 1;
p_p2:
			if wl > 30
			then do;			/* too long */
				call cobol_lexerr$lexerr3 (2, "1"b, 2, "30");
				call scan_off;
				return;
			     end;

			if cobol_lu_sw
			then substr (wb, 1, wl) = translate (substr (wb, 1, wl), upper_case_alphabet);

			call cobol_insert_token (4, wl);

/*[4.0-1]*/
			prev_tok_type = 0;

			picture.line = cobol_save_cln;/*[4.2-6]*/
			picture.column = TOK_COLUMN;
			picture.length = wl;

/*[4.4-2]*/
/*
		if fixed_common.comp_level < "3" & CONT
		then	do;	call lev_diag	(	picture.line,
							picture.column,
							1
						);

				CONT = "0"b;
			end;
*/
/*[4.4-2]*/

			if wl > 2
			then do;
				st_pos = 2;
				cont_flag = "1"b;
			     end;
			else cont_flag = "0"b;

			do while (cont_flag);

			     h_index = index (substr (wb, st_pos, wl - st_pos + 1), "-");

			     if h_index = 0
			     then cont_flag = "0"b;
			     else do;

				     st_pos = st_pos + h_index;

				     if st_pos > wl - 1
				     then cont_flag = "0"b;
				     else do;

					     a = substr (wb, st_pos - 2, 1);

					     if a ^= "B" & a ^= "-" & a ^= "/" & a ^= "." & a ^= ","
						& a ^= "0" & a ^= "$"
					     then do;

						     substr (wb, st_pos - 1, 1) = "h";
						     cont_flag1 = "1"b;
						     cont_flag = "0"b;

						     do while (cont_flag1);

							h_index =
							     index (substr (wb, st_pos, wl - st_pos), "-");

							if h_index = 0
							then cont_flag1 = "0"b;
							else do;

								st_pos = st_pos + h_index;

								if st_pos > wl - 1
								then cont_flag1 = "0"b;
								substr (wb, st_pos - 1, 1) = "h";

							     end;
						     end;

						end;
					end;

				end;
			end;

			substr (picture.string, 1, wl) = substr (wb, 1, wl);

			if per = "."
			then goto gen_per;

/*[4.2-7]*/
			if per = ","		/*[4.2-7]*/
			then if fixed_common.comp_level < "3"
						/*[4.2-7]*/
			     then call lev_diag (cobol_c_l_n, save_pcol, 2);
						/* ,; as separator */

			return;
		     end;

		goto p_p2;

	     end;

	call ill_dlm;				/* something fishy here */

/* INTERNAL DEBUG ELEMENT */


	call ill_char;
	return;

initialize:
     entry;

/*[4.4-2]*/
	period_sw, save_sw, alpha_lit_bit = "0"b;

/*[4.0-5]*/
	return;

/*[4.4-2]*/
dcl	alpha_lit_bit	bit (1) static internal;

alpha_lit:
     entry returns (bit (1));

/*[4.4-2]*/
	return (alpha_lit_bit);

set_table:
     entry;

/*[4.4-3]*/
	if substr (fixed_common.compile_mode, 4, 1)	/*[4.4-3]*/
	then do;
		mem_tab (36) = "10100000"b;		/* $ */
						/*[4.4-3]*/
		mem_tab (95) = "10100000"b;		/* _ */

/*[4.4-3]*/
		x (36) = 1;			/* $ */
						/*[4.4-3]*/
		x (95) = 1;			/* _ */
						/*[4.4-3]*/
	     end;					/*[4.4-3]*/
	else do;
		mem_tab (36) = "00100000"b;		/*[4.4-3]*/
		mem_tab (95) = "00100000"b;

/*[4.4-3]*/
		x (36) = 10;			/*[4.4-3]*/
		x (95) = 10;			/*[4.4-3]*/
	     end;

	return;

swm:
     proc;


/* ========================================================================== */
/*                                                                            */
/* this procedure is used to scan a string of characters while they all       */
/* belong to the same set of characters. its paramaters are::                 */
/*       mask--membership to be scanned for.                                   */
/*       ons--output string from the scan.                                    */
/*       onp--output position(updated) from the scan.                         */
/*                                                                            */
/* ========================================================================== */

	slen = cobol_cards.nr_char;
swm_loop:
	if mem_tab (fixed (unspec (substr (cobol_cards.name, slen, 1)), 35)) & mask
	then do;
		slen = slen + 1;
		go to swm_loop;
	     end;

	slen = slen - cobol_cards.nr_char;


	if slen = 0
	then return;

	if slen + wl - 1 > wll
	then do;
		cobol_cards.nr_char = cobol_cards.nr_char + slen;
		lerr = "1"b;
		return;
	     end;
	else lerr = "0"b;

	substr (wb, wl, slen + 1) = substr (cobol_cards.name, cobol_cards.nr_char, slen + 1);
	cobol_cards.nr_char = cobol_cards.nr_char + slen;
	wl = wl + slen;
     end swm;

scan_off:
     proc;
scan_off1:
	if ^mem_tab (fixed (unspec (substr (cobol_cards.name, cobol_cards.nr_char, 1)), 35)) & "00001000"b
	then do;
		cobol_cards.nr_char = cobol_cards.nr_char + 1;
		goto scan_off1;
	     end;

	if substr (cobol_cards.name, cobol_cards.nr_char, 1) = cobol_new_line_character
	then do;
		call cobol_merge;

		if cobol_continuation = "1"b
		then do;
			cobol_continuation = "0"b;	/*[4.4-2]*/
						/* CONT = "1"b; */
			goto scan_off1;
		     end;
	     end;
     end scan_off;

ill_dlm:
     proc;
	call cobol_lexerr$lexerr3 (6, "0"b, 0, " ");
     end ill_dlm;

ill_dlm1:
     proc;
	call cobol_lexerr$lexerr3 (30, "0"b, 0, " ");

	if fixed_common.comp_level < "5"		/*[3.0-2]*/
	then call lev_diag (reserved_word.line,		/*[3.0-2]*/
		reserved_word.column,		/*[3.0-2]*/
		44 /*[3.0-2]*/);			/*[3.0-2]*/


     end ill_dlm1;

ill_dlm2:
     proc;
	call cobol_lexerr$lexerr3 (31, "0"b, 0, " ");

	if fixed_common.comp_level < "5"		/*[3.0-2]*/
	then call lev_diag (reserved_word.line,		/*[3.0-2]*/
		reserved_word.column,		/*[3.0-2]*/
		44 /*[3.0-2]*/);			/*[3.0-2]*/


     end ill_dlm2;

/*[4.0-1]*/
init_tok_string:
     entry;

/*[4.0-1]*/
	prev_tok_type = 0;				/*[4.0-1]*/
	tok_string = "~";

/*[4.0-1]*/
	call cobol_ddsyntax$init_tok_string;

/*[4.0-1]*/
	return;

/*[4.0-1]*/
dcl	cobol_ddsyntax$init_tok_string
			entry;			/*[4.0-1]*/
dcl	cobol_ddsyntax$enter_tok_string
			entry (char (36) varying);

/*[4.0-1]*/
dcl	prev_tok_type	fixed bin static internal;	/*[4.0-1]*/
dcl	tok_string	char (1024) varying static internal;

/*[4.0-1]*/
dcl	ch36		char (36) varying,
	int_val		fixed bin;

/*[4.0-2]*/
dcl	posit		fixed bin,
	ch		char (1),
	linfo		bit (8);


dcl	lower_case_alphabet char (128) static options (constant) init (" 	
 !""#$%&'()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[\]^_`abcdefghijklmnopqrstuvwxyz{|}~");
dcl	upper_case_alphabet char (128) static options (constant) init (" 	
 !""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~");


/* +46 [] ->{}
/* process EXPONENT expression %/
/*
/*	exp_sw = "1"b;
/*	cobol_cards.nr_char = cobol_cards.nr_char + 1;		/* skip the e %/
/*	if substr(cobol_cards.name, cobol_cards.nr_char, 1) = cobol_new_line_character then
/*	do;
/*		call cobol_merge;
/*		if cobol_continuation = "1"b then
/*		do;
/*		cobol_continuation = "0"b;
/*		goto d3;
/*		end;
/*	end;
/*
/*d3:	
/*
/*	c1 = substr(cobol_cards.name,cobol_cards.nr_char,1);
/*	if mem_tab(unspec(c1)) & "01000000"b  then
/*	goto d4;
/*	if (c1 = "+") | (c1 = "-") then
/*	do;
/*		exp_sign = c1;
/*		cobol_cards.nr_char = cobol_cards.nr_char + 1;
/*		goto d4;
/*	end;
/*
/* not an exponent expression %/
/*
/*	cobol_cards.nr_char = cobol_cards.nr_char - 1;		/* back up one character %/
/*	goto build_nlt;
/*
/* accumulate exponent value now %/
/*
/*d4:	
/*
/*	mask = "01000000"b;
/*	wll = 18;
/*	call swm;
/*	if lerr then goto nl_l_err;
/*	if substr(cobol_cards.name, cobol_cards.nr_char, 1) = cobol_new_line_character then
/*	do;
/*		call cobol_merge;
/*		if cobol_continuation = "1"b then
/*		do;
/*		cobol_continuation = "0"b;
/*		goto d4;
/*		end;
/*	end;
/*	goto build_nlt;
/*   -46 []->{} */


/* +68 []->{}
/*	bitstr_sw = "0"b;
/*  	goto b_s1a;
/*b_s1:						/* continuation loop label %/
/*	if substr(cobol_cards.name, cobol_cards.nr_char, 1) ^= """" then
/*	do;
/*{%/		call cobol_lexerr$lexerr3(5,"1"b,0," "); /*}%/
/*		call scan_off;
/*		return;
/*	end;
/*b_s1a:	
/*	cobol_cards.nr_char = cobol_cards.nr_char + 1;
/*	mask = "00010000"b;
/*	wll = /*{{{ 64 }}}%/ /*{%/ 200 /*}%/;
/*	call swm;
/*	if lerr then goto al_l_err;
/*	if substr(cobol_cards.name, cobol_cards.nr_char, 1) = cobol_new_line_character then
/*	do;
/*		call cobol_merge;
/*		if cobol_continuation = "1"b then
/*		do;
/*		cobol_continuation = "0"b;
/*		goto b_s1;
/*		end;
/*	end;
/*	if substr(cobol_cards.name,cobol_cards.nr_char,1) = """" then
/*	do;					/* tail delimiter %/
/*		if substr(cobol_cards.name, cobol_cards.nr_char + 1, 1) = """" then goto proc_quote;
/*		cobol_cards.nr_char = cobol_cards.nr_char + 1;
/*
/*b_s2:	    					/* final delimiter processing %/
/*
/*	if substr(cobol_cards.name, cobol_cards.nr_char, 1) = cobol_new_line_character then
/*	do;
/*		call cobol_merge;
/*		if cobol_continuation = "1"b then
/*		do;
/*		cobol_continuation = "0"b;
/*		goto b_s2;
/*		end;
/*	end;
/*		hc = substr(cobol_cards.name, cobol_cards.nr_char, 1);
/*		hc = hexl_tab(unspec(hc));
/*		if unspec(hc) ^= "0"b then goto next_hex2;
/*		if substr(cobol_cards.name,cobol_cards.nr_char,1) = "b" | substr(cobol_cards.name, cobol_cards.nr_char, 1) = "B" then
/*		do;
/*		bitstr_sw = "1"b;
/*		cobol_cards.nr_char = cobol_cards.nr_char + 1;
/*		end;
/*
/*		goto build_alt;
/*	end;
/*	if substr(cobol_cards.name,cobol_cards.nr_char,1)^="(" then
/*	goto s3;					/* only item allowed %/
/*	goto s3;					/* *** This bypasses the repitition code *** %/
/*	cobol_cards.nr_char = cobol_cards.nr_char + 1;
/*	rep_factor = 0;
/*
/*b_s4:	
/*
/*	do while (mem_tab(unspec(substr(cobol_cards.name,cobol_cards.nr_char,1))) & "01000000"b );
/*		rep_factor = rep_factor * 10 + unspec(substr(cobol_cards.name,cobol_cards.nr_char,1)) -
/*		 /*{{{ 240 }}}%/ /*{%/ 48 /*}%/;
/*		cobol_cards.nr_char = cobol_cards.nr_char + 1;
/*	end;					/* digit accumulation loop %/
/*	if substr(cobol_cards.name, cobol_cards.nr_char, 1) = cobol_new_line_character then
/*	do;
/*		call cobol_merge;
/*		if cobol_continuation = "1"b then
/*		do;
/*		cobol_continuation = "0"b;
/*		goto b_s4;
/*		end;
/*	end;
/*	do rep_factor = rep_factor-1 by -1 to 1;
/*		substr(wb,wl,1) = 
/*		substr(wb,wl-1,1); /* duplicate te character %/
/*		wl = wl + 1;
/*	end;					/* expansion part %/
/*
/*b_s3:	
/*
/*	if substr(cobol_cards.name, cobol_cards.nr_char, 1) = cobol_new_line_character then
/*	do;
/*		call cobol_merge;
/*		if cobol_continuation = "1"b then
/*		do;
/*		cobol_continuation = "0"b;
/*		goto b_s3;
/*		end;
/*	end;
/*	if substr(cobol_cards.name,cobol_cards.nr_char,1)^=")"	/* improper delimiter %/
/*	then	do;	call ill_char;
/*			return;
/*		end;
/*	goto b_s1a;
/*   -68 []->{} */

/* +67 []->{} *->%
/*
/*	cobol_cards.nr_char = cobol_cards.nr_char + 1;		/* skip the starting character %/
/*
/*d_c1:	
/*
/*	call cobol_insert_token(8);
/*	user_word.length = 1;
/*	call swm("10000000"b,addr(user_word.word),user_word.length, 3);
/*	if lerr then	do;	call ill_char;
/*				return;
/*			end;
/*
/* we should now have either "on" or "off" %/
/*
/*dcl (p,q) pointer static,
/*    (i, j) fixed bin static,
/*	xp bit (1) static;
/*	p = cobol_current;				/* save the location within the stack %/
/*	if substr(user_word.word,1,2) = "ON" then
/*	xp = "1"b;
/*	else
/*	if substr(user_word.word,1,3) = "OFF" then
/*	xp = "0"b;
/*	else	do;	call ill_char
/*			return;
/*		end;
/*	call cobol_gns;					/* get the next symbol %/
/*	if reserved_word.type = 1 then
/*	if reserved_word.key = xleft_paren then goto l2;
/*	else;
/*	else call lexerr(14, "0"b, 1, "(");		/* missing ( %/
/*
/*l2:	
/*
/*	call cobol_gns;					/* get the first digit value %/
/*	if reserved_word.type ^= 1 then goto l2;
/*	if reserved_word.key ^= xright_paren then goto l2;
/*	q = cobol_current;				/* save the top end of the string %/
/*	cobol_current = p;				/* reset token stack %/
/*	do while (cobol_current ^= q);
/*		if numeric_lit.type = 2 then
/*		do;					/* valid item maybe %/
/*
/* NOTICE==HANDLE CASE OF OUR OWN DEBUG ITEMS FIRST>> %/
/*
/*		i = 0;
/*		do j = 1 to numeric_lit.places;
/*			if mem_tab(unspec(substr(numeric_lit.literal,j,1))) & "01000000"b then
/*			i = i * 10 + unspec(substr(numeric_lit.literal,j,1)) - 48;
/*		end;
/* 		if i <= 25 then
/* 		bug(i) = xp; 
/*		else 
/*		do;				/* not ours %/
/*
/* set type and value into element %/
/*			debug.type = 24;
/*			debug.size =   21;		/* mark exact element size %/
/*			debug.on_off = xp;
/*			debug.debug_index = i;
/*		end;
/*		end;					/* element completed %/
/*		cobol_current = numeric_lit.fwd_link;		/* advance token index %/
/*	end;
/*	cobol_current = q;
/*	call cobol_delete_tokens(p,q);
/*	call cobol_gns;					/* make the actual token active %/
/* 	if (bug(1)) then call trace ("EXIT GNS--debug section"); 
/*	return;
/*  -67 []->{} *->% */

/*  This variable is used to contain the column number to assign to COLUMN */
/* in the token header.  It is either the actual source */
/* column number or 0 (for all columns inserted for debug */

/*[4.2-6]*/
declare	TOK_COLUMN	fixed bin;
%include cobol_ext_lex;
%include cobol_hexl_tab;
%include cobol_gns_tab;
%include cobol_fixed_common;
%include cobol_ext_;

     end cobol_gns;
