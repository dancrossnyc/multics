/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_generate_report.pl1 Reformatted code to new Cobol standard.
                                                   END HISTORY COMMENTS */


/* Modified on 10/25/82 by FCH, [5.1-5], test for missing PIC clause, phx13531 */
/* Modified on 10/22/82 by FCH, [5.1-4], control footing groups not exec, phx13755 */
/* Modified on 02/10/82 by FCH, [5.1-3], no period after WRITE state, phx12454(BUG526) */
/* Modified on 12/22/81 by FCH, [5.1-2], LINE-COUNTER and PAGE-COUNTER must be qualif, phx12120(BUG522) */
/* Modified on 12/21/81 by FCH, [5.1-1], set bit count for rw incl files, phx11819(BUG517) */
/* Modified on 08/31/81 by FCH, [5.0-1], dont enter RW source into the listing, BUG498 */
/* Modified on 06/29/81 by FCH, [4.4-1], dont emit go to dep if only one group, BUG479(TR09695) */
/* Modified since Version 4.4 */






/* format: style3 */
cobol_generate_report:
     proc (rep_list_loc, f_l, tbit);

declare	rep_list_loc	ptr,
	f_l		fixed bin,
	tbit		bit (1);
declare	(g_i_count, control_count, group_number, line_number, field_number)
			fixed bin;
declare	gch		char (32) varying;




declare	cobol_io_$cobol_msf_start
			entry (ptr, ptr);
declare	cobol_swf_get	entry (ptr, bit (32), ptr, fixed bin);
declare	ioa_		entry options (variable);
declare	ioa_$rsnnl	entry options (variable);



declare	(addr, substr, null, size, length, addrel, abs)
			builtin;


/* initialization */
	current_report_loc = rep_list_loc;
	alf_lit_ptr = addr (ALF);
	rwfp = cobol_m1fp;
	ddloc, pdloc = 1;
	first_line = f_l;
	trace_bit = tbit;
	b_incr = 0;
	buffer_size = 132;

	call line_init;
	call gen_S;				/* process the reports */

	do while (current_report_loc ^= null ());


/*[5.1-2]*/
	     if report.page.count ^= 0
	     then call gen_report;

	     current_report_loc = report.rep_next;

	end;

	rwdd = "1"b;
	call rep_term;

/*[5.1-1]*/
	call hcs_$set_bc_seg (cobol_rwdd, 9 * (ddloc - 1), CODE);

/*[5.1-1]*/
	if CODE ^= 0
	then go to err;

/*[5.1-1]*/
	call hcs_$set_bc_seg (cobol_rwpd, 9 * (pdloc - 1), CODE);

/*[5.1-1]*/
	if CODE ^= 0
	then go to err;

	return;

err:						/*[5.1-1]*/
	return;

/*[5.1-1]*/
declare	hcs_$set_bc_seg	entry (ptr, fixed bin (24), fixed bin (35));
						/*[5.1-1]*/
declare	CODE		fixed bin (35);

declare	code		char (32) varying;

gen_report:
     proc;

declare	i		fixed bin;		/* process a report */

	call gen_report_init;

	rwdd = "1"b;


	call rep_descr;				/* report description */

	rwdd = "0"b;


	call emit_rep_pn ("R", 1);			/* report_name section. */
	call test_control_tables;

	call gen_scb;				/* SCB. */

	if report.cf ^= null ()
	then call gen_reset_sums;			/* RESET-SUM. */

	call gen_init;				/*  INIT. */
	call gen_term;				/* TERM. */

	if efg
	then call gen_first_gen;

	call emit_p_br;				/* P-BR. */
	call emit_pincr;				/* P-INCR. */
	call emit_b_abs;				/* B-ABS. */
	call emit_w_bl;				/* W-BL. */

	if control_count ^= 0
	then do;

		call emit_comment ("CONTROL TO PREVIOUS", 32);
		call control_function (1, "C-TO-P", "P");
						/* gen_c_to_p */

		call emit_comment ("CONTROL TO SHADOW", 32);
		call control_function (2, "C-TO-S", "S");
						/* gen_c_to_s */

		call emit_comment ("PREVIOUS TO CONTROL", 32);
		call control_function (3, "P-TO-C", "P");
						/* gen_s_to_c */

		call emit_comment ("SHADOW TO CONTROL", 32);
		call control_function (4, "S-TO-C", "S");
						/* gen_s_to_c */

	     end;

	if report.ch ^= null ()
	then do;
		ch_table_ptr = report.ch;		/* exists(CH group) */

		call emit_comment ("CH GROUPS", 32);

		call emit_exit_para ("CH-EXIT");	/* CH-EXIT. exit. */

		call emit_comment ("EXECUTE CH GROUPS", 32);
		call gen_c_h;

		gch = "CH";

		if ch_table.ch_loc (0) ^= null ()
		then do;
			call emit_comment ("CH FINAL GROUP", 32);
			call ch_group (0);
		     end;

		do i = 1 by 1 to ch_table.ch_size;

		     call emit_comment ("CH GROUP", 32);

		     call ch_group (i);		/* CH-i. i = 0(1)... */

		end;
	     end;

	if report.de ^= null ()
	then do;
		de_table_ptr = report.de;		/* exists(DE group) */

		call emit_comment ("DE GROUPS", 32);

		call emit_exit_para ("DE-EXIT");	/* DE-EXIT. exit. */

		gch = "DE";

		if de_table.det_subtot_all.count ^= 0
		then call emit_stall_para;		/* subtot for all groups */


		if de_table.det_size ^= 0
		then do i = 1 by 1 to de_table.det_size;

			call emit_comment ("DE GROUP", 32);

			call de_group (i);		/* DE-i. i = 1(1)... */

		     end;
		else call de_group (0);

	     end;

	if report.cf ^= null ()
	then do;
		cf_table_ptr = report.cf;		/* exists(CF group) */

		call emit_comment ("CF GROUPS", 32);

		call emit_exit_para ("CF-EXIT");	/* CH-EXIT. exit. */

		call emit_comment ("EXECUTE CF GROUPS", 32);
		call gen_c_f;

		gch = "CF";

		if cf_table.cf_loc (0) ^= null ()
		then do;
			call emit_comment ("CF FINAL GROUP", 32);
			call cf_group (0);
		     end;

		do i = 1 by 1 to cf_table.cf_size;

		     call emit_comment ("CF GROUP", 32);

		     call cf_group (i);		/* CF-i. i = 0(1)... */

		end;
	     end;

	if report.rh ^= null ()
	then do;
		rt_ptr = report.rh;			/* exists(RH group) */

		call emit_comment ("RH GROUP", 32);

		call emit_group_name ("R-H", 10000);	/* RH. */
		call use_proc ("R-H-EXIT");

		gch = "R-H";

		call emit_lines (10000);		/* emit lines in group */
		call emit_exit_para ("R-H-EXIT");	/* RH-EXIT. exit. */
	     end;

	if report.rf ^= null ()
	then do;
		rt_ptr = report.rf;			/* exists(RF group) */

		call emit_comment ("RF GROUP", 32);

		call emit_group_name ("R-F", 10000);	/* RF. */
		call use_proc ("R-F-EXIT");

		gch = "R-F";

		call emit_lines (10000);		/* emit lines in group */
		call emit_exit_para ("R-F-EXIT");	/* RF-EXIT. exit. */
	     end;

	if report.ph ^= null ()
	then do;
		rt_ptr = report.ph;			/* exists(PH group) */

		call emit_comment ("PH GROUP", 32);

		call emit_group_name ("P-H", 10000);	/* PH. */
		call use_proc ("P-H-EXIT");

		gch = "P-H";

		call emit_lines (10000);		/* emit lines in group */
		call emit_exit_para ("P-H-EXIT");	/* PH-EXIT. exit. */
	     end;

	if report.pf ^= null ()
	then do;
		rt_ptr = report.pf;			/* exists(PF group) */

		call emit_comment ("PF GROUP", 32);

		call emit_group_name ("P-F", 10000);	/* PF. */
		call use_proc ("P-F-EXIT");

		gch = "P-F";

		call emit_lines (10000);
		call emit_exit_para ("P-F-EXIT");	/* PF-EXIT. exit. */
	     end;



     end;

rep_term:
     proc;
	call skip_to_a;				/* A margin */
	call append_var_string ("procedure");		/* procedure */
	call emit_line;
     end;

go_to_dep:
     proc (string, j);

declare	string		char (32) varying,
	j		fixed bin;

declare	i		fixed bin;

	call skip_to_b;				/* B margin */
	call append_sep_var_string ("go");		/* go */
	call append_sep_var_string ("to");		/* to */

	do i = 1 by 1 to j;

	     call qual_int_by_rep_proc (string, i);

	end;

	call append_sep_var_string ("depending");	/* depending */
	call append_sep_var_string ("on");		/* on */
	call qual_by_rep ("C-L");
	call append_period;				/* . */

     end;

control_function:
     proc (type, string_1, string_2);

declare	type		fixed bin,
	(string_1, string_2)
			char (32) varying;

declare	i		fixed bin;

/*
				function		type	string_1	string_2

				gen_c_to_p	1	C-TO-P-	P-
				gen_c_to_s	2	C-TO-S-	S-
				gen_p_to_c	3	P-TO-C-	P-
				gen_s_to_c	4	S-TO-C-	S-
*/

	if qual_name_seq_ptr = null ()
	then return;

	call emit_pn (string_1);			/* string_1. */
						/*[4.4-1]*/
	if cf_table.cf_size > 1
	then call go_to_dep (string_1, cf_table.cf_size);

	do i = 1 by 1 to cf_table.cf_size;

/*[4.4-1]*/
	     if cf_table.cf_size > 1
	     then call emit_ind_pn (string_1, i);	/* string_1-i. */

	     call skip_to_b;			/* B margin */
	     call append_sep_var_string ("move");	/* move */

	     go to CF1 (type);

CF1 (1):						/* gen_c_to_p */
CF1 (2):						/* gen_c_to_s */
	     call append_control_name (i);		/* control_name */

	     go to CF1_0;

CF1 (3):						/* gen_p_to_c */
CF1 (4):						/* gen_s_to_c */
	     call control_item (string_2, i);		/* control_data_item */

	     go to CF1_0;

CF1_0:
	     call append_sep_var_string ("to");		/* to */

	     go to CF2 (type);

CF2 (1):						/* gen_c_to_p */
CF2 (2):						/* gen_c_to_s */
	     call control_item (string_2, i);

	     go to CF2_0;

CF2 (3):						/* gen_p_to_c */
CF2 (4):						/* gen_c_to_s */
	     call append_control_name (i);		/* control_name */

	     go to CF2_0;

CF2_0:
	     call append_period;			/* . */

	end;

	call emit_exit_para (string_1 || "-EXIT");	/* string_1-EXIT. exit. */

     end;

gen_S:
     proc;

	rwdd = "0"b;

	call emit_section ("SSSS");			/* SSSS section. */
	call emit_pn ("S");				/* S. */
	call SENT ("stop run");			/*     stop run. */
	call emit_section ("SSS");			/* SSS section. */
	call emit_pn ("S");				/* S. */
	call SENT ("move 1 to SS");			/* move 1 to SS. */

	rwdd = "1"b;

	call descr_line (1, "XXXXX");			/* 01 XXXXX. */
	call descr_line_int (2, "SS", "0");		/* 02 SS comp-6 value 0. */
	call descr_line_int (2, "S-PI", "0");		/* 02 S-PI comp-6 value 0 */

     end;





emit_exit_para:
     proc (string);

declare	string		char (32) varying;

	call skip_to_a;				/* A margin */
	call append_sep_var_string (string);		/* string */
	call append_var_string (".");			/* . */

	call skip_to_b;				/* B margin */
	call append_sep_var_string ("exit");		/* exit */
	call append_period;				/* . */

     end;

control_item:
     proc (string, i);

declare	string		char (32) varying,
	i		fixed bin;

	call qual_by_int (string, i);			/* string-i */

	call append_sep_var_string ("of");		/* of */
	call append_sep_token (report.rep_name_ptr);	/* report_name */

     end;

dl:
     proc (lev_num, name);

declare	lev_num		fixed bin,
	name		char (32) varying;

	call append_level_number (lev_num);		/* level number */
	call append_var_string (name);		/* name */
	call append_sep_var_string ("comp-6");		/* comp-6 */

     end;

emit_pn:
     proc (name);

declare	name		char (32) varying;

	call skip_to_a;				/* A margin */
	call append_sep_var_string (name);		/* name */
	call append_period;				/* . */

     end;

def_val_clauses:
     proc;					/* define value clauses for the	*/
						/* page parameters in a report	*/
						/* description			*/

/* PAGE clause */

	go to P (report.page.type);

P (0):						/* PAGE not defined */
	call descr_line_int (2, "P-G", "0");		/* 02 PAGE value 0 */
	call descr_line_int (2, "H-D", "0");		/* 02 HEADING value 0 */
	call descr_line_int (2, "F-D", "0");		/* 02 FIRST-DETAIL value 0 */
	call descr_line_int (2, "L-D", "0");		/* 02 LAST-DETAIL value 0 */
	call descr_line_int (2, "F-T", "0");		/* 02 FOOTING value 0 */

	return;

P (1):						/* PAGE integer */
P (2):						/* PAGE expression */
	call pg_vcl ("P-G", addr (report.page));	/* 02 PAGE value integer */

	go to P0;

P0:						/* HEADING clause */
	go to H (report.heading.type);

H (0):						/* HEADING not defined */
	call descr_line_int (2, "H-D", "1");		/* 02 HEADING value 1 */

	go to H0;

H (1):						/* HEADING integer */
H (2):						/* HEADING expression */
	call pg_vcl ("H-D", addr (report.heading));	/* 02 HEADING value integer */

	go to H0;

H0:						/* FIRST-DETAIL */
	go to FD (report.first_detail.type);

FD (0):						/* FIRST-DETAIL not defined */
	go to HH (report.heading.type);

HH (0):						/* HEADING not defined */
	call descr_line_int (2, "F-D", "1");		/* 02 FIRST-DETAIL value 1 */

	go to HH0;

HH (1):						/* HEADING integer */
HH (2):						/* HEADING expression */
	call pg_vcl ("F-D", addr (report.heading));	/* 02 FIRST-DETAIL value integer */

	go to HH0;

HH0:
	go to FD0;

FD (1):						/* FIRST-DETAIL integer */
FD (2):						/* FIRST-DETAIL expression */
	call pg_vcl ("F-D", addr (report.first_detail));	/* 02 FIRST-DETAIL value integer */

	go to FD0;

FD0:						/* LAST-DETAIL */
	go to LD (report.last_detail.type);

LD (0):						/* LAST-DETAIL not defined */
	go to F (report.footing.type);

F (0):						/* FOOTING not defined */
	call pg_vcl ("L-D", addr (report.page));	/* 02 LAST-DETAIL value integer */
	call pg_vcl ("F-T", addr (report.footing));	/* 02 FOOTING value integer */

	go to F0;

F (1):						/* FOOTING integer */
F (2):						/* FOOTING expression */
	call pg_vcl ("L-D", addr (report.footing));	/* 02 LAST-DETAIL value integer */
	call pg_vcl ("F-T", addr (report.footing));	/* 02 FOOTING value integer */

	go to F0;

F0:
	go to LD0;

LD (1):						/* LAST-DETAIL integer */
LD (2):						/* LAST-DETAIL expression */
	call pg_vcl ("L-D", addr (report.last_detail));	/* 02 LAST-DETAIL value integer */

	go to FF (report.footing.type);

FF (0):						/* FOOTING not defined */
	call pg_vcl ("F-T", addr (report.last_detail));	/* 02 FOOTING value integer */

	go to FF0;

FF (1):						/* FOOTING integer */
FF (2):						/* FOOTING expression */
	call pg_vcl ("F-T", addr (report.footing));	/* 02 FOOTING value integer */

	go to FF0;

FF0:
	go to LD0;

LD0:
     end;

pg_vcl:
     proc (name, int_loc);

declare	name		char (32) varying,
	int_loc		ptr;



	integer_spec_ptr = int_loc;

	call append_level_number (2);			/* 02 */
	call append_var_string (name);		/* name */
	call append_sep_var_string ("comp-6");		/* comp-6 */
	call append_sep_var_string ("value");		/* value */
	call append_sep_integer (integer_spec.count);	/* integer */
	call append_period;				/* . */

     end;

descr_line:
     proc (lev_num, name);

declare	lev_num		fixed bin,
	name		char (32) varying;

	call dl (lev_num, name);			/* lev_num name comp-6 */
	call append_period;				/* . */

     end;

descr_line_int:
     proc (lev_num, name, value);

declare	lev_num		fixed bin,
	name		char (32) varying,
	value		char (32) varying;

	call dl (lev_num, name);			/* lev_num name comp-6 */
	call append_sep_var_string ("value");		/* value */
	call append_sep_var_string (value);		/* integer */
	call append_period;				/* . */

     end;

gen_scb:
     proc;

declare	i		fixed bin;

	qual_name_seq_ptr = report.controls.loc;

	if qual_name_seq_ptr ^= null ()
	then do;

		call emit_comment ("SET CONTROL BREAK", 32);
		call emit_pn ("SCB");		/* SCB. */

		do i = 1 by 1 to qual_name_seq.qns_size;

		     qual_name_ptr = qual_name_seq.qns_loc (i);

		     call skip_to_b;		/* B margin */

		     if i ^= 1
		     then call append_sep_var_string ("else");
						/* else */
		     call append_sep_var_string ("if"); /* if */
		     call qual_int_by_rep ("P", i);	/* P-i of report-name */
		     call append_sep_var_string ("not");/* not */
		     call append_sep_var_string ("equal");
						/* equal */
		     call append_qual_name (qual_name_ptr);
						/* control */
		     call emit_line;

		     b_incr = 7;

		     call emit_compute_lhs ("C-L", 0);	/* compute CLEVEL of report_name = */
		     call append_sep_integer (i);	/* i */
		     call emit_line;

		     b_incr = 0;
		end;
		call de_word ("else");		/* else */

		b_incr = 7;

		call emit_compute_lhs ("C-L", 0);	/* compute CLEVEL of report_name = */
		call append_sep_var_string ("0");	/* 0 */
		call append_period;			/* . */

		b_incr = 0;

		if g_i_count ^= 0
		then do;

			call emit_rel_int_test ("C-L", "not equal", 0);
						/* if CLEVEL not = 0 */

			b_incr = 3;

			call emit_move_cv_sent ("all zeros", "GR-I");

			b_incr = 0;

		     end;
	     end;

     end;

qual_by_rep:
     proc (name);

declare	name		char (32) varying;

	call append_sep_var_string (name);		/* name */
	call append_sep_var_string ("of");		/* of */
	call append_sep_token (report.rep_name_ptr);	/* report name */

     end;

qual_by_int:
     proc (name, i);

declare	name		char (32) varying,
	i		fixed bin;

	call append_sep_var_string (name);		/* name */
	call append_var_string ("-");			/* - */
	call append_integer (i);			/* i */

     end;

qual_int_by_rep:
     proc (name, i);

declare	name		char (32) varying,
	i		fixed bin;

	call qual_by_int (name, i);			/* name-i */
	call append_sep_var_string ("of");		/* of */
	call append_sep_token (report.rep_name_ptr);	/* report_name */

     end;

emit_ind_pn:
     proc (name, i);

declare	name		char (32) varying,
	i		fixed bin;


	call skip_to_a;				/* A margin */

	if i < 10000
	then call qual_by_int (name, i);
	else call append_var_string (name);		/* name[-i] */

	call append_period;				/* . */
     end;

emit_group_name:
     proc (name, lev);

declare	name		char (32) varying,
	lev		fixed bin;

	call emit_ind_pn (name, lev);

	if root.rt_name_ptr ^= null ()
	then call emit_gp_pn (1);
     end;

emit_gp_pn:
     proc (i);

declare	i		fixed bin;

	call skip_to_a;				/* A margin */
	call append_var_string ("G");			/* G */

	if i ^= 0
	then call append_token (root.rt_name_ptr);	/* token */
	else call append_token (report.rep_name_ptr);

	call append_period;				/* . */
     end;

rep_descr:
     proc;

declare	i		fixed bin;

	call emit_comment ("REPORT DESCRIPTION", 32);
	call append_level_number (1);			/* 01 */
	call append_token (report.rep_name_ptr);	/* report name */
	call append_period;				/* . */

	call def_val_clauses;			/* define val clauses, page params */

	call descr_line (2, "C-L");
	call descr_line (2, "GEN-CTR");
	call descr_line (2, "line-counter");
	call descr_line (2, "page-counter");
	call descr_line (2, "LN-C");
	call descr_line (2, "B-C");
	call descr_line (2, "SNGI");
	call descr_line (2, "S-P");

	call descr_pic_line (2, "RN", "pic x value ""0""");

	g_i_count = report.g_i_count;

	if g_i_count ^= 0
	then do;

		call emit_comment ("GROUP INDICATE CLAUSES", 32);



		call append_level_number (2);		/* 02 */
		call append_var_string ("GR-I pic x("); /* GR-I pic x(*/
		call append_integer (g_i_count);	/* report count */
		call append_var_string (")");		/* ) */
		call append_period;			/* . */

		call append_level_number (2);		/* 02 */
		call append_var_string ("G-I redefines GR-I");
						/* G-I redefines GROUP-INDICATE */
		call append_period;			/* . */

		do i = 1 by 1 to g_i_count;

		     call append_level_number (3);	/* 03 */
		     call append_var_string ("G-I-");	/* G-I- */
		     call append_integer (i);		/* i */
		     call append_sep_var_string ("pic x");
						/* pic x */
		     call append_period;		/* . */

		end;

	     end;

	if report.cf ^= null ()
	then call def_sum_counters;



	if control_count ^= 0
	then do;
		call emit_comment ("PREVIOUS AND SHADOW VALUES", 32);
		call control_struct ("P-V", "P-");
		call control_struct ("S-H", "S-");
	     end;

	call def_line_buffer;
     end;

control_struct:
     proc (string_1, string_2);

declare	(string_1, string_2)
			char (32) varying;
declare	i		fixed bin;

	call append_level_number (2);			/* 02 */
	call append_var_string (string_1);		/* name */
	call append_period;				/* . */

	do i = 1 by 1 to control_count;

	     call append_level_number (3);		/* 03 */
	     call append_var_string (string_2);		/* name */
	     call append_integer (i);			/* i */
	     call append_sep_var_string ("renames");	/* renames */
	     call append_control_name (i);		/* control name */
	     call append_period;			/* . */

	end;

     end;

append_control_name:
     proc (control_num);

declare	control_num	fixed bin;

	qual_name_ptr = control_name_table.cnt_loc (control_num);

	call append_qual_name (qual_name_ptr);

     end;

def_sum_counters:
     proc;					/* define the sum counters associated	*/
						/* with the CF groups in a report	*/
declare	i		fixed bin;

	call emit_comment ("SUM COUNTERS", 32);

	do i = 0 by 1 to cf_table.cf_size;

	     if cf_table.cf_sum_chain (i) ^= null ()
	     then do;				/* CF group defines sum counters */

		     tn_ptr = cf_table.cf_loc (i);	/* loc of CF node */

		     do while (tn_ptr ^= null ());

			call append_level_number (term_node.tn_level + 1);
						/* level number */

			if term_node.tn_name_ptr = null ()
			then call append_var_string ("filler");
			else call append_token (term_node.tn_name_ptr);

/* name */

			if term_node.tn_type = 2	/* root, non-term */
			then if term_node.data_type = 3
						/* sum counter */
			     then call sum_descr;
			     else call append_sep_var_string ("pic x");

			call append_period;		/* . */

			tn_ptr = term_node.tn_next;

		     end;

		end;
	end;

     end;

declare	buffer_size	fixed bin;




def_line_buffer:
     proc;					/* define the line buffer for a report */

declare	p		ptr;
declare	gn		fixed bin;

	call emit_comment ("BLANK LINE BUFFER", 32);
	call emit_lev_item (2, "filler comp-6", "");
	call emit_blank_lines_data;			/* 02 BLANK-LINES ... */
	call emit_end_page_rec;

	call emit_comment ("LINE BUFFER", 32);
	call buffer_name_def ("REP-LINE");		/* 02 REP-LINE-i */
	call emit_lev_item (3, "S-Z comp-6", "");	/* 03 SIZE comp-6 */

	call emit_lev_item (3, "C-D pic xx", """" || code || """");
						/* 03 CODE pic xx value "cc". */
	call emit_lev_item (3, "T-Y pic xx", """: """);	/* 03 TYPE pic xx value """: """. */
	call append_level_number (3);			/* 03 */
	call append_var_string ("B-F");		/* BUFFER */
	call append_pic_x (buffer_size);		/* pic x(buffer_size) */
	call append_period;				/* . */

	line_rd = "1"b;

	if report.rh ^= null ()
	then do;
		gch = "R-H";
		call line_redef (report.rh, 10000);
	     end;
	if report.rf ^= null ()
	then do;
		gch = "R-F";
		call line_redef (report.rf, 10000);
	     end;
	if report.ph ^= null ()
	then do;
		gch = "P-H";
		call line_redef (report.ph, 10000);
	     end;
	if report.pf ^= null ()
	then do;
		gch = "P-F";
		call line_redef (report.pf, 10000);
	     end;

	gch = "DE";

	de_table_ptr = report.de;

	if report.de ^= null ()			/* de groups */
	then do gn = 1 by 1 to de_table.det_size;

		call line_redef (de_table.det_loc (gn), gn);

	     end;

	gch = "CH";

	ch_table_ptr = report.ch;

	if report.ch ^= null ()			/* cf_groups */
	then do gn = 0 by 1 to ch_table.ch_size;

		call line_redef (ch_table.ch_loc (gn), gn);

	     end;

	gch = "CF";

	cf_table_ptr = report.cf;

	if report.cf ^= null ()
	then do gn = 0 by 1 to cf_table.cf_size;

		p = cf_table.cf_loc (gn);
		if p ^= null ()
		then call line_redef (p, gn);

	     end;


	call emit_write_line;
     end;



emit_lev_tok_item:
     proc (lev, p);

declare	lev		fixed bin,
	p		ptr;


	call append_level_number (lev);		/* lev */
	call append_token (p);			/* token */
	call append_period;				/* . */
     end;



emit_lev_item:
     proc (lev, def, val);

declare	lev		fixed bin,
	(def, val)	char (32) varying;

	call append_level_number (lev);		/* level number */
	call append_sep_var_string (def);		/* definition of field */

	if val ^= ""
	then call append_value (val);			/* value val */

	call append_period;				/* . */
     end;

append_value:
     proc (val);

declare	val		char (32) varying;

	call append_sep_var_string ("value");		/* value */
	call append_sep_var_string (val);		/* val */
     end;


declare	line_rd		bit (1);



line_redef:
     proc (node_ptr, gn);				/* emit redef of line buffer */
declare	node_ptr		ptr,
	(gn, fill_size)	fixed bin;
declare	(ltn, first, last, size, field_size, left_fill_size, lev)
			fixed bin;

	if node_ptr = null ()
	then return;


	if line_rd
	then do;
		call emit_comment ("REDEFINITIONS, LINE BUFFER", 32);
		line_rd = "0"b;
	     end;


	call emit_comment (gch || " GROUP", 32);

	rt_ptr = node_ptr;
	LINE_table_ptr = root.line_table_ptr;
	FIELD_table_ptr = root.field_table_ptr;

	do line_number = 1 by 1 to LINE_table.LT_size;

	     call append_level_number (2);		/* 02 */
	     call line_redef_name (gn, line_number);	/* line name */
	     call append_sep_var_string ("redefines");
	     call qual_by_int ("REP-LINE", report.rep_num);
	     call append_period;			/* . */

	     call emit_write_fields ("S-Z");




	     first = LINE_table.LT_first_field (line_number);
	     size = LINE_table.LT_field_count (line_number);
	     last = first + size - 1;
	     field_number = 1;

	     do ltn = first by 1 to last;



		tn_ptr = FIELD_table.FT_loc (ltn);
		field_size = FIELD_table.FT_field_size (ltn);
		left_fill_size = FIELD_table.FT_left_fill_size (ltn);


		if term_node.tn_name_ptr = null () | term_node.data_type = 3
		then lev = 3;
		else do;
			call emit_lev_tok_item (3, term_node.tn_name_ptr);
			lev = 4;
		     end;

		if left_fill_size ^= 0
		then call fill (lev, "filler", left_fill_size);
						/* lev filler pic x(ii) */


		call append_level_number (lev);	/* lev */
		call field_name ("F-", field_number);	/* f-i */

		tn_ptr = FIELD_table.FT_loc (ltn);

		call emit_picture;

		if term_node.sign ^= 0
		then call sign_clause;
		if term_node.blank_zero & ^term_node.non_num
		then call blank_zero;
		if term_node.just_right & term_node.non_num
		then call just_right;
		if term_node.usage_disp
		then call usage;

		call append_period;			/* . */

		field_number = field_number + 1;

	     end;


	     fill_size = LINE_table.LT_line_size (line_number);

	     if fill_size < buffer_size
	     then call fill (3, "filler", buffer_size - fill_size);



	end;

     end;

blank_zero:
     proc;

	call append_sep_var_string ("blank");
	call append_sep_var_string ("when");
	call append_sep_var_string ("zero");
     end;

usage:
     proc;

	call append_sep_var_string ("usage");
	call append_sep_var_string ("display");
     end;

just_right:
     proc;

	call append_sep_var_string ("justified");
	call append_sep_var_string ("right");
     end;
emit_picture:
     proc;					/*[5.1-5]*/
	if term_node.picture = null ()		/*[5.1-5]*/
	then call append_sep_var_string ("pic x");	/*[5.1-5]*/
	else do;
		call append_sep_var_string ("pic");	/* pic */
						/*[5.1-5]*/
		call append_sep_token (term_node.picture);
						/* picture */
						/*[5.1-5]*/
	     end;
     end;
fill:
     proc (lev, name, size);

declare	(lev, size)	fixed bin,
	name		char (32) varying;

	call append_level_number (lev);		/* level number */
	call append_sep_var_string (name);		/* name */
	call append_pic_x (size);			/* pic x (size) */


	call append_period;				/* . */
     end;

emit_blank_lines_data:
     proc;

	call buffer_name_def ("BLANK-LINES");		/* 02 BLANK-LINES-i */
	call bld ("4", "r ");
	call emit_lev_item (3, "BL-C comp-6", "");	/* 03 BLANK-COUNT comp-6. */

     end;

append_pic_x:
     proc (size);

declare	size		fixed bin;

	call append_sep_var_string ("pic x(");		/* pic x( */
	call append_integer (size);			/* size */
	call append_var_string (")");			/* ) */
     end;

sign_clause:
     proc;					/* sign clause */
declare	type		fixed bin;

	type = term_node.sign;

	if type = 0
	then return;				/* missing */

	call append_sep_var_string ("sign");		/* sign */


	if type = 1 | type = 3
	then call append_sep_var_string ("leading");	/* leading */
	else call append_sep_var_string ("trailing");	/* trailing */

	if type = 1 | type = 2
	then return;

	call append_sep_var_string ("separate");	/* separate */

     end;

line_redef_name:
     proc (group_num, line_num);

declare	(group_num, line_num)
			fixed bin;		/* G-i-L-j */
	call append_sep_var_string (gch);		/* gch */

	if group_num < 10000
	then do;
		call append_var_string ("-");		/* - */
		call append_integer (group_num);	/* group_num */
	     end;

	call append_var_string ("-L-");		/* -L- */

	call append_integer (line_num);

     end;
emit_pfex:
     proc (string, i);

declare	string		char (32) varying,
	i		fixed bin;

	call emit_ind_perf (string, i);
	call append_sep_var_string ("thru");
	call qual_int_by_rep_proc (string || "-EXIT", 10000);
	call append_period;
     end;

field_name:
     proc (st, field_num);				/* F-j */
declare	st		char (32) varying,
	field_num		fixed bin;

	call skip_to_b;				/* B margin */
	call append_var_string (st);			/* st */
	call append_integer (field_num);		/* j */

     end;

qual_field_name:
     proc (group_num, line_num, field_num);		/* F-i of G-j-L-k of report_name */
declare	(group_num, line_num, field_num)
			fixed bin;

	call field_name ("F-", field_num);		/* F-i */
	call append_sep_var_string ("of");		/* of */
	call line_redef_name (group_num, line_num);	/* G-j-L-k */
	call append_sep_var_string ("of");		/* of */
	call append_sep_token (report.rep_name_ptr);	/* report_name */

     end;

gen_init:
     proc;					/* INIT of report_name		*/
						/* initialization for a report	*/
	call emit_comment ("INITIATE REPORT", 32);
	call emit_rep_pn ("I", 0);			/* Ireport_name. */
	call emit_reset_state ("B-C", "0");		/* compute BODY-COUNT = 0 */
	call emit_reset_sent ("GEN-CTR", "0");		/* compute GEN-CTR = 0. */


	if report.ng_exists
	then call emit_reset_sent ("SNGI", "0");	/* compute SNGI = 0. */
	if report.controls.loc ^= null ()
	then call emit_reset_sent ("C-L", "1");		/* compute CLEVEL = 1. */


	call emit_reset_sent ("line-counter", "0");	/* compute line-counter = 0. */

	call emit_reset_sent ("page-counter", "1");	/* compute page-counter = 1. */

	if g_i_count ^= 0
	then call emit_move_cv_sent ("all zeros", "GR-I");/* move all zeros to GROUP-INDICATE. */

	if report.cf ^= null ()
	then call emit_perf_sent ("RESET-SUMS");	/* perform RESET-SUMS. */


     end;

gen_term:
     proc;

declare	(abs, rel, line, type, page)
			fixed bin;

	call emit_comment ("TERMINATE REPORT", 32);
	call emit_rep_pn ("T", 0);			/* Treport-name. */

	if report.controls.loc ^= null ()		/* compute CLEVEL of report_name = 0 */
	then do;
		call emit_reset_sent ("C-L", "0");
		call cb_save;
	     end;

	if report.cf ^= null ()
	then do;					/* exists(CF group) */


		call emit_perf_exit_sent ("C-F");	/* perform C-F of report_name. */


		if report.cf -> cf_table.cf_loc (0) ^= null ()
		then call emit_pfex ("CF", 0);	/* perform CF-0 of report_name. */
	     end;
	if report.controls.loc ^= null ()
	then call cb_restore;

	page = report.page.count;

	if report.pf ^= null ()
	then do;					/* exists(PF group */
		rt_ptr = report.pf;

		type = root.next_group.type;

		call emit_bl_abs (root.group_desc.line);/* (i1) root.group_desc.lines PF(abs) */
		call emit_perf_exit_sent ("P-F");	/* perform PF of report_name. */


		go to PFNG (type);

PFNG (0):						/* NG clause (missing) */
		if report.rf ^= null ()
		then do;
			rt_ptr = report.rf;		/* exists(RF group) */
			type = root.group_desc.type;
			line = root.group_desc.line;

			go to rf0 (type);
rf0 (0):
			go to rf00;
rf0 (1):						/* RF(abs) */
			call emit_ABS (line - 1);	/* (i1-1) lines */
			call append_period;
			go to rf00;
rf0 (2):						/* RF(rel) */
			call emit_bl_rel (line);	/* (j1-1) lines */
			if line > 0
			then call append_period;
			go to rf00;
rf0 (3):						/* RF(page) */
			call emit_ABS (page + line);	/* (P + i1) lines */
			call append_period;
			go to rf00;

rf00:
			call emit_perf_exit_sent ("R-F");
						/* perform RF of report_name. */
		     end;

		go to PFNG0;

PFNG (1):						/* NG(abs) */
		abs = root.next_group.value;		/* NG(i1) */

		if report.rf ^= null ()
		then do;
			rt_ptr = report.rf;		/* exists(RF group) */
			type = root.group_desc.type;
			line = root.group_desc.line;

			go to rf1 (type);
rf1 (0):
			go to rf10;
rf1 (1):						/* RF(abs) */
			call emit_ABS (line - 1);	/* (i1-1) lines */
			go to rf10;

rf1 (2):						/* RF(rel) */
			call emit_bl_rel (abs + line);/* (abs + j1) lines */
			go to rf10;

rf1 (3):						/* RF(page) */
			call emit_ABS (page + line);	/* (P + i1) lines */
			go to rf10;

rf10:
			call append_period;

			call emit_perf_exit_sent ("R-F");
						/* perform RF of report_name. */

		     end;

		else call emit_ABS (root.group_desc.line - 1);
						/* (i1-1) lines RF group missing */

		go to PFNG0;

PFNG (2):						/* NG(rel) */
		rel = root.next_group.value;		/* NG(j1) */

		if report.rf ^= null ()
		then do;
			rt_ptr = report.rf;		/* exists(RF group) */
			type = root.group_desc.type;
			line = root.group_desc.line;

			go to rf2 (type);
rf2 (0):
			go to rf20;
rf2 (1):						/* RF(abs) */
			call emit_ABS (line - 1);	/* (i1 - 1) lines */
			go to rf20;

rf2 (2):						/* RF(rel) */
			call emit_bl_rel (rel + line);/* (rel + j1) lines */
			go to rf20;

rf2 (3):						/* RF(page) */
			call emit_ABS (page + line);	/* (page + i1) lines */
			go to rf20;

rf20:
			call append_period;

			call emit_perf_exit_sent ("R-F");
						/* perform RF or report_name. */

		     end;

		go to PFNG0;

PFNG0:
	     end;					/* ^exists(PF group)) */
	else if report.rf ^= null ()
	then do;
		rt_ptr = report.rf;			/* exists(RF group) */
		type = root.group_desc.type;
		line = root.group_desc.line;

		go to rf3 (type);
rf3 (0):
		go to rf30;
rf3 (1):						/* RF(abs) */
		call emit_ABS (line - 1);		/* (i1 - 1) lines */
		go to rf30;

rf3 (2):						/* RF(rel) */
		call emit_bl_rel (line);		/* (j1) lines */
		go to rf30;

rf3 (3):						/* RF(page) */
		call emit_ABS (page + line);		/* (P + i1) lines */
		go to rf30;

rf30:
		call append_period;

		call emit_perf_exit_sent ("R-F");	/* perform RF of report_name. */

	     end;

	call emit_ABS (page + 1);
	call append_period;				/* fill page with blank lines */

/*[5.0-1]*/
	call emit_write_sent ("END-PAGE");		/* write from END-PAGE-i */

     end;




gen_reset_sums:
     proc;					/* RESET-SUMS of report_name	*/

declare	i		fixed bin;

	call emit_comment ("RESET ALL SUM COUNTERS", 32);
	call emit_pn ("RESET-SUMS");			/* RESET-SUMS. */

	do i = 0 by 1 to cf_table.cf_size;

	     sum_ptr = cf_table.cf_sum_chain (i);

	     do while (sum_ptr ^= null ());

		call skip_to_b;			/* B margin */
		call append_var_string ("compute");	/* compute */
		call append_qual_name (sum.sum_qn_ptr); /* sum counter */
		call append_sep_var_string ("= 0");	/* = 0 */
		call append_period;			/* . */

		sum_ptr = sum.sum_next;

	     end;

	end;

     end;



emit_p_br:
     proc;

	call emit_comment ("PAGE BREAK", 32);
	call emit_pn ("P-BR");

	if report.pf ^= null ()
	then do;					/* exists(PF group) */
		rt_ptr = report.pf;			/* (i1 - LC) lines */
		call emit_bl_abs (root.group_desc.line);

		call emit_perf_exit_sent ("P-F");	/* perform PF of report_name. */
	     end;

	call emit_bl_abs (report.page.count + 1);	/* blank lines to eop */
	call emit_perf_sent ("P-INCR");		/* perform P-INCR. */

	if report.ph ^= null ()
	then do;					/* exists(PH group) */
		rt_ptr = report.ph;

		if root.group_desc.type = 1		/* PH(abs) */
		then call emit_bl_abs (root.group_desc.line);

/* ((P + i1 - 1) - LC) lines */

		else call emit_bl_abs (report.heading.count + root.group_desc.line - 1);

/* ((P+H +j1 - 1) - LC) lines */

		call emit_perf_exit_sent ("P-H");	/* perform PH of report_name. */
	     end;





	call emit_reset_sent ("B-C", "0");		/*compute BODY-COUNT = 0 */
     end;

emit_pincr:
     proc;

	call emit_comment ("PAGE-COUNTER INCREMENT", 32);

	call emit_pn ("P-INCR");			/* P-INCR. */
	call emit_reset_sent ("line-counter", "0");	/* compute line-counter = 0. */
	call emit_if_test ("S-PI", "equal", "0");	/* if S-PI equal 0 */
	call emit_incr_sent ("page-counter", 1);	/* page-counter = page-counter + 1. */

	if g_i_count ^= 0
	then call emit_move_cv_sent ("all zeros", "GR-I");/* move all zeros to GROUP-INDICATE. */

/*[5.0-1]*/
	call emit_write_sent ("END-PAGE");		/* write from END-PAGE-i */


     end;




emit_bl_abs:
     proc (line);

declare	line		fixed bin;

	call emit_comment ("EMIT BLANK LINES, ABS", 32);

	if line <= report.page.count + 1
	then do;
		call emit_move_int_state (line, "LN-C");/* move line to LINE-COUNT-i */
		call emit_line;
		call emit_perf_state ("B-ABS");	/* perform B-ABS */
	     end;
	else do;
		call emit_comp_end ("line-counter", line - 1 - report.page.count);

/* compute line-counter = line - 1 - report.page.count */

		call emit_line;
	     end;
     end;

emit_ng_abs:
     proc (line);

declare	line		fixed bin;

	call emit_pb_blank_lines (line, line);

     end;

emit_bl_rel:
     proc (line_count);

declare	line_count	fixed bin;
	if line_count = 0
	then return;

	call emit_comment ("EMIT BLANK LINES, REL", 32);

	call EMIT_REL (line_count - 1, line_count);

     end;

EMIT_REL:
     proc (line1, line2);

declare	(line1, line2)	fixed bin;


	if line1 > 0
	then do;

		call emit_compute_lhs ("BL-C", 0);	/* compute BLANK-COUNT of report_name = */
		call append_sep_integer (line1);	/* line1 */
		call append_sep_var_string ("end-compute");
		call emit_line;



/*[5.1-3]*/
		call emit_write_state ("BLANK-LINES");	/* write BLANK-LINES of report_name */


	     end;


	if line2 > 0
	then call emit_incr_state ("line-counter", line2);
     end;

emit_bl_abs_var:
     proc (string);

declare	string		char (32) varying;

	call emit_comment ("EMIT BLANK LINES, ABS VAR", 32);

	call emit_compute_lhs ("count of BLANK-LINES", 1);/* compute count of BLANK-LINES of report_name = */
	call qual_by_rep (string);			/* string of report_name */
	call append_sep_var_string ("-");		/* - */
	call qual_by_rep ("line-counter");		/* line-counter of report_name */
	call append_sep_var_string ("end-compute");
	call emit_line;



	call emit_incr_var_state ("line-counter", string);/* increment line-counter */
						/*[5.0-1]*/
	call emit_write_sent ("BLANK-LINES");
     end;

emit_WR:
     proc (rec_area);

declare	rec_area		char (32) varying;

	call skip_to_b;				/* B margin */
	call append_var_string ("write");		/* write */
	call append_sep_token (report.file_name);	/* file-name */
	call append_sep_var_string ("from");		/* from */
	call qual_by_int (rec_area, report.rep_num);	/* rec-i */
	call append_sep_var_string ("end-write");	/* end-write */

     end;

emit_incr_sent:
     proc (name, i);

declare	name		char (32) varying,
	i		fixed bin;

	call emit_incr (name, i);
	call append_period;
     end;

emit_incr_state:
     proc (name, i);

declare	name		char (32) varying,
	i		fixed bin;

	call emit_incr (name, i);

	call append_sep_var_string ("end-compute");
	call emit_line;
     end;

emit_incr:
     proc (name, i);

declare	name		char (32) varying,
	i		fixed bin;

	call emit_compute_lhs (name, 1);		/* compute name of report name = */
	call qual_by_rep (name);			/* name of report name */


	if i > 0
	then do;
		call append_sep_var_string ("+");
		call append_sep_integer (i);
	     end;
	else do;
		call append_sep_var_string ("-");
		call append_sep_integer (-i);
	     end;
     end;

emit_incr_var:
     proc (name, incr);

declare	(name, incr)	char (32) varying;

	call skip_to_b;				/* B margin */
	call emit_compute_lhs (name, 1);		/* compute name of report_name = */
	call qual_by_rep (name);			/* name of report_name */
	call append_sep_var_string ("+");		/* + */
	call qual_by_rep (incr);			/* incr of report_name */
     end;

emit_incr_var_state:
     proc (name, incr);

declare	(name, incr)	char (32) varying;

	call emit_incr_var (name, incr);
	call emit_line;
     end;

emit_reset_sent:
     proc (name, value);

declare	(name, value)	char (32) varying;

	call emit_reset (name, value);
	call append_period;
     end;

emit_reset_state:
     proc (name, value);

declare	(name, value)	char (32) varying;

	call emit_reset (name, value);
	call emit_line;
     end;

emit_reset_int_state:
     proc (name, i);

declare	name		char (32) varying,
	i		fixed bin;

	call emit_reset_int (name, i);
	call emit_line;
     end;

emit_reset_int:
     proc (name, i);

declare	name		char (32) varying,
	i		fixed bin;

	call emit_compute_lhs (name, 0);		/* compute name of report_name = */
	call append_sep_integer (i);			/* i */
     end;

emit_reset:
     proc (name, value);

declare	(name, value)	char (32) varying;

	call emit_compute_lhs (name, 0);		/* compute name of report name = */
	call append_sep_var_string (value);		/* value */
     end;

emit_move_cv:
     proc (from, to);

declare	(from, to)	char (32) varying;

	call skip_to_b;				/* B margin */
	call append_var_string ("move");		/* move */
	call append_sep_var_string (from);		/* from */
	call append_sep_var_string ("to");		/* to */
	call qual_by_rep (to);			/* to of report_name */
     end;

emit_move_cv_sent:
     proc (from, to);

declare	(from, to)	char (32) varying;

	call emit_move_cv (from, to);
	call append_period;
     end;

emit_use_proc:
     proc (p);

declare	p		ptr;

	call skip_to_b;				/* B margin */
	call append_sep_var_string ("perform");		/* perform */
	call append_sep_token (p);			/* use_procedure */

     end;

emit_use_proc_sent:
     proc (p);

declare	p		ptr;

	call emit_use_proc (p);
	call append_period;
     end;

use_proc:
     proc (string);

declare	string		char (32) varying;

declare	p		ptr,
	sep		bit (1);

	p = root.use_proc.use_proc_name_ptr;

	if p = null ()
	then return;

	sep = root.use_proc.suppress;

	if sep
	then call SENT ("move 0 to SS");		/* move 0 to SS. */

	call emit_use_proc_sent (p);			/* perform use_procedure. */

	if sep
	then do;

		call LINE ("if SS equal 1");		/* if SS equal 1 */
		call emit_go_to_sent (string);	/* go to string of report_name. */

	     end;

     end;

ch_group:
     proc (i);

declare	i		fixed bin;

	rt_ptr = ch_table.ch_loc (i);
	if rt_ptr = null ()
	then return;

	b_incr = 6;

	call emit_group_name ("CH", i);		/* CH-i. */
	call use_proc ("CH-EXIT");
	call body_group ("CH", i);			/* emit body group */
	call emit_go_to_sent ("CH-EXIT");		/* go to CH-EXIT of report_name. */
     end;

de_group:
     proc (i);

declare	i		fixed bin;


	if i = 1
	then if de_table.det_size = 1
	     then call emit_rn_proc;

	rt_ptr = de_table.det_loc (i);
	gch = "DE";

	call emit_gp_pn (i);			/* Rgroup_name. */
	call emit_pfex ("DE", i);			/* perform DE-i thru DE-EXIT. */
	call emit_ind_pn ("DE", i);			/* DE-i. */

	b_incr = 0;

	if efg
	then call emit_rel_con_test ("GEN-CTR", "equal", "0");
						/* if GEN-CTR of report_name equal 0 */

	b_incr = 3;

	if efg
	then call emit_perf_state ("FG");		/* perform FG of report_name */

	b_incr = 0;


	if report.controls.loc ^= null ()
	then do;
		call de_word ("else");		/* else */

		b_incr = 3;

		call emit_perf_state ("SCB");		/* perform SCB of report_name */

		call emit_rel_con_test ("C-L", "not equal", "0");
						/* if CLEVEL of report_name not equal 0 */

		b_incr = 6;

		call cb_save;


		if report.cf ^= null ()
		then call emit_perf_exit_state ("C-F"); /* perform C-F of report_name */

		call cb_restore;


		if report.ch ^= null ()
		then call emit_perf_exit_state ("C-H"); /* perform C-H of report_name */

		b_incr = 3;

		call de_word ("end-if");		/* end-if */

		b_incr = 0;


	     end;


	if efg
	then call end_sent ("end-if");		/* end-if. */


	if de_table.det_subtot_all.count ^= 0
	then call emit_perf_sent ("SUB-TOT");		/* perform SUB-TOT of report_name. */


	if i ^= 0
	then do;



		if de_table.det_subtot.count (i) ^= 0
		then call emit_sc ("SUBTOTALLING, CURRENT GROUP", de_table.det_subtot.first (i));
						/* perform SUB-TOT-i of report_name. */

		call use_proc ("DE-EXIT");

		if de_table.det_size = 1
		then call emit_rn_test;

		call body_group ("DE", i);		/* emit body group */

	     end;

	call emit_go_to_sent ("DE-EXIT");		/* go to DE-EXIT of report_name. */

     end;


emit_rn_test:
     proc;

	call emit_rel_con_test ("RN", "equal", """1""");	/* if RN equal "1" */
	call emit_move_con_state ("""0""", "RN");	/* move "0" to RN */
	call emit_go_to_sent ("DE-EXIT");		/* go to DE-EXIT */

     end;

emit_rn_proc:
     proc;

	call emit_gp_pn (0);			/* Greport_name. */
	call emit_move_con_state ("""1""", "RN");	/* move "1" to RN */
	call emit_pfex ("DE", 1);			/* perform DE-1 */

     end;

cf_group:
     proc (i);

declare	i		fixed bin;

	rt_ptr = cf_table.cf_loc (i);

	if rt_ptr = null ()
	then return;
	b_incr = 6;

	call emit_group_name ("CF", i);		/* CF-i. */

	if cf_table.cf_crossfoot.count (i) ^= 0
	then call emit_sc ("CROSSFOOTING", cf_table.cf_crossfoot.first (i));


	if cf_table.cf_rollfwd.count (i) ^= 0
	then call emit_sc ("ROLLING FORWARD", cf_table.cf_rollfwd.first (i));


	call use_proc ("CF-EXIT");
	call body_group ("CF", i);			/* emit body group */
	call emit_go_to_sent ("CF-EXIT");		/* go to CF-EXIT of report_name. */


	if cf_table.cf_reset.count (i) ^= 0
	then call emit_reset_para (i);
     end;



declare	(ld, ft)		fixed bin;

body_group:
     proc (string, i);

declare	string		char (32) varying,
	i		fixed bin;
declare	(type, line, size, sz)
			fixed bin;
declare	st		char (32) varying;




	type = root.group_desc.type;
	line = root.group_desc.line;
	size = root.group_desc.size;
	st = string || "-1";
	ld = report.last_detail.count;

	ft = report.footing.count;

	b_incr = 0;

	go to BGT (type);


BGT (0):
	go to BGT0;
BGT (1):						/* Body Group (abs) */
	if report.ng_exists				/* group contains a NEXT GROUP clause */
	then call emit_ind_pn (st, i);		/* string-1-i. */

	call emit_rel_int_test ("line-counter", "not less", line);
						/* if line-counter not < i1 */
	b_incr = 3;

	call emit_perf_state ("P-BR");		/* perform P-BR */

	if report.ng_exists				/* group contains a NEXT GROUP clause */
	then do;
		call emit_rel_con_test ("SNGI", "not equal", "0");

/* if SNGI not = 0 */
		call emit_bl_abs_var ("SNGI");	/* SNGI lines */
		call emit_reset_state ("SNGI", "0");	/* compute SNGI = 0 */

		call emit_ind_go_to_state (st, i);	/* go to string-1-i of report_name */

		call emit_line;
		b_incr = 3;

		call de_word ("end-if");		/* end-if */
	     end;

	b_incr = 0;

	call de_word ("end-if");			/* end-if */
	call emit_bl_abs (line);			/* (i1) lines */

	go to BGT0;

BGT (2):						/* Body Group (rel) */
	call emit_ind_pn (st, i);			/* string-1-i. */
	call emit_rel_con_test ("B-C", "equal", "0");	/* if BODY-COUNT = 0 */
	call emit_ind_go_to_sent (string || "-3", i);	/* go to string-3-i. */

	call pb_test (ld - line - size + 1);		/* test for page break */

	b_incr = 3;

	call emit_perf_state ("P-BR");		/* perform P-BR */
	call emit_reset_state ("B-C", "0");		/* compute BODY-COUNT = 0 */

	call emit_ind_go_to_state (st, i);		/* go to string-1-i of report_name */
	call emit_line;

	b_incr = 0;

	call de_word ("else");			/* else */

	b_incr = 3;

	call emit_bl_rel (line);			/* (j1) lines */
	call de_word ("end-if");			/* end-if */

	b_incr = 0;

	call emit_ind_go_to_sent (string || "-2", i);	/* go to string-2-i. */
	call emit_ind_pn (string || "-3", i);		/* string-3-i. */


	if report.ng_exists				/* group contains a NEXT GROUP clause */
	then do;

		b_incr = 3;

		call emit_rel_con_test ("SNGI", "not equal", "0");
						/* if SNGI not = 0 */

		call emit_bl_abs_var ("SNGI");	/* SNGI lines */

		b_incr = 6;


		call emit_reset_state ("SNGI", "0");	/* compute SNGI = 0 */

		call emit_rel_int_test ("line-counter", "greater", ld - size);
						/* if line-counter > LD - <size> */

		b_incr = 9;

		call emit_perf_state ("P-BR");	/* perform P-BR */

		b_incr = 6;

		call de_word ("end-if");		/* end-if */

		b_incr = 3;

		call de_word ("end-if");		/* end-if */

		b_incr = 0;
	     end;


	call emit_pb_blank_lines (report.first_detail.count - 1, report.first_detail.count);
	call append_period;


	call emit_ind_pn (string || "-2", i);		/* string-2-i. */
	go to BGT0;

BGT (3):						/* Body Group (page) */
	call emit_ind_pn (st, i);			/* string-1-i. */

	call emit_rel_con_test ("B-C", "greater", "0");	/* if BODY-COUNT > 0 */

	b_incr = 3;

	call emit_perf_state ("P-BR");		/* perform P-BR */
	call emit_reset_state ("B-C", "0");		/* compute BODY-COUNT = 0 */

	call emit_ind_go_to_state (st, i);		/* go to string-1-i */
	call emit_line;

	b_incr = 0;

	call de_word ("else");			/* else */

	if report.ng_exists				/* group contains a NEXT GROUP clause */
	then do;
		b_incr = 3;

		call emit_rel_con_test ("SNGI", "greater", "0");
						/* if SNGI > 0 */

		call emit_bl_abs_var ("SNGI");	/* SNGI lines */

		b_incr = 6;

		call emit_reset_state ("SNGI", "0");	/* compute SNGI = 0 */

		b_incr = 3;

		call de_word ("end-if");		/* end-if */

		b_incr = 0;

	     end;

	b_incr = 3;

	call emit_rel_int_test ("line-counter", "not less", line);
						/* if line-counter not < i1 */

	b_incr = 6;

	call emit_perf_state ("P-BR");		/* perform P-BR */

	b_incr = 3;

	call de_word ("end-if");			/* end-if */

	call emit_bl_abs (line - 1);			/* (i1 - 1) lines */

	b_incr = 0;

	call de_word ("end-if");			/* end-if */
	go to BGT0;

BGT0:
	call emit_lines (i);			/* emit lines in group */

	call emit_reset_sent ("B-C", "1");		/* BODY-COUNT = 1 */

	type = root.next_group.type;
	line = root.next_group.value;

	if type = 0
	then return;
	if type = 3 & line = 1
	then return;



	if root.group_type = 5			/* CF group */
	then do;
		call emit_rel_int_test ("C-L", "equal", i);
		b_incr = b_incr + 3;

	     end;					/* if CLEVEL of report_name equal i */

	go to BNG (type);


BNG (1):						/* NEXT GROUP (page) */
	call emit_bl_abs (ft - 1);			/* F - 1 lines */
	go to BNG0;

BNG (2):
	call emit_rel_int_test ("line-counter", "less", line);
	b_incr = b_incr + 3;			/* if line-counter < i1 */

	call emit_bl_abs (line - 1);
	b_incr = b_incr - 3;			/* (i1 - 1) lines */

	call de_word ("else");
	b_incr = b_incr + 3;			/* else */

	call emit_bl_abs (ft);			/* F lines */
	call emit_reset_int_state ("SNGI", line);
	b_incr = b_incr - 3;			/* compute SNGI = i1 */

	call de_word ("end-if");
	b_incr = b_incr - 3;			/* end-if */

	go to BNG0;

BNG (3):						/* NEXT GROUP (rel) */
	call emit_rel_int_test ("line-counter", "less", ft - line);
						/* if line-counter < F - j1 */

	b_incr = b_incr + 3;

	call emit_ng_rel (line);
	b_incr = b_incr - 3;			/* j1 lines */

	call de_word ("else");
	b_incr = b_incr + 3;			/* else */

	call emit_ng_abs (ft);
	b_incr = b_incr - 3;			/* F lines */

	call de_word ("end-if");
	b_incr = b_incr - 3;			/* end-if */

	go to BNG0;

BNG0:
	if root.group_type = 5			/* CF group */
	then call de_word ("end-if");			/* end-if */

	b_incr = 0;

	call append_period;				/* . */

     end;





emit_lines:
     proc (i);

declare	i		fixed bin;

declare	(line_num, prev_line_num, line_count, line_size)
			fixed bin;


declare	(first, last, size, ltn, data_type)
			fixed bin;
declare	nd_loc		ptr;



	group_number = root.group_number;

	LINE_table_ptr = root.line_table_ptr;

	FIELD_table_ptr = root.field_table_ptr;



	do line_number = 1 by 1 to LINE_table.LT_size;

	     line_num = LINE_table.LT_line_num (line_number);
	     line_size = LINE_table.LT_line_size (line_number);

	     if line_number = 1
	     then do;
		     if line_num < 0
		     then prev_line_num = -line_num;
		     else prev_line_num = line_num;
		end;
	     else do;
		     if line_num < 0
		     then do;
			     line_num = -line_num;	/* absolute */
			     call emit_abs (line_num - prev_line_num - 1, line_num);
			     prev_line_num = line_num;
			end;
		     else do;
			     call emit_rel (line_num - 1);
						/* relative */
			     prev_line_num = prev_line_num + line_num;
			end;
		end;

	     call emit_move_cv_sent ("spaces", "B-F");	/* move spaces to BUFFER */

	     call emit_comment ("LINE", 32);
	     field_number = 1;


	     first = LINE_table.LT_first_field (line_number);
	     size = LINE_table.LT_field_count (line_number);
	     last = first + size - 1;

	     do ltn = first by 1 to last;

		call emit_comment ("FIELD", 32);

		tn_ptr = FIELD_table.FT_loc (ltn);
		data_type = term_node.data_type;
		nd_loc = term_node.nd_loc;

		if term_node.group_ind
		then do;
			call emit_irel_con_test ("G-I", term_node.g_i_count, "equal", """0""");
						/* if G-I-i equal "0" */

			b_incr = 3;

			call emit_move_cvi_state ("""1""", "G-I", term_node.g_i_count);
						/* move "1" to G-I-i */

		     end;

		call skip_to_b;			/* B margin */
		call append_var_string ("move");	/* move */

		go to EL (data_type);
EL (0):						/* missing */
						/*[5.1-5]*/
		call append_sep_var_string ("spaces");
		go to EL0;

EL (1):						/* SOURCE */
		call emit_identifier (nd_loc);
		go to EL0;

EL (2):						/* VALUE */
		call append_list (nd_loc);
		go to EL0;

EL (3):						/* SUM */
		call emit_sum_counter_name;
		go to EL0;

EL0:
		call append_sep_var_string ("to");	/* to */
		call qual_field_name (i, line_number, field_number);

		if term_node.group_ind
		then do;
			call emit_line;
			call end_sent ("end-if");
			b_incr = 0;
		     end;

		else call append_period;		/* . */

		field_number = field_number + 1;

	     end;

	     call emit_line_size_init (line_size);	/*[5.0-1]*/
	     call emit_write_sent ("WRITE-LINE");	/* write fn from WRITE-LINE. */



	     b_incr = 0;



	end;

	line_number = line_number + 1;
     end;

emit_identifier:
     proc (p);

declare	p		ptr;

	ident_ptr = p;

	call append_qual_name (ident.id_name_loc);

	ident_ptr = p;

	if ident.subscripts.count ^= 0
	then call append_list (addr (ident.subscripts));

     end;

emit_sum_counter_name:
     proc;

declare	(p, q)		ptr;

	call append_sep_token (term_node.tn_name_ptr);

	p = term_node.tn_up;

	do while (p ^= null ());

	     q = p -> term_node.tn_name_ptr;

	     if q ^= null ()
	     then do;
		     call append_sep_var_string ("of");
		     call append_sep_token (q);
		end;

	     p = p -> term_node.tn_up;

	end;
     end;

gen_first_gen:
     proc;

declare	(i, line, type, heading, value)
			fixed bin;

	call emit_comment ("FIRST GENERATE STATEMENT", 32);
	call emit_pn ("FG");			/* FG. */

	if report.rh ^= null ()
	then do;
		rt_ptr = report.rh;			/* exists(RH group) */

		line = root.group_desc.line;
		type = root.group_desc.type;
		heading = report.heading.count;

		if type = 1
		then call emit_bl_abs (line);		/* (i1) lines RH(abs) */
		else call emit_bl_rel (heading + line - 1);
						/* (H+j1-1) lines RH(rel) */

		call emit_perf_exit_sent ("R-H");	/* perform RH of report_name. */

		type = root.next_group.type;
		value = root.next_group.value;

		go to RHNG (type);			/* NEXT GROUP clause */

RHNG (0):						/* NG clause (missing) */
		go to RHNG0;

RHNG (1):						/* NG clause (NEXT PAGE) */
		call emit_ABS (report.page.count);	/* (P) lines */
		call emit_reset_sent ("line-counter", "0");
						/* compute line-counter of report_name = 0. */
		call emit_reset_sent ("page-counter", "2");
						/* compute page-counter of report_name = 2. */

		go to RHNG0;

RHNG (2):						/* NG clause (integer) */
		call emit_ABS (value);		/* (i1) lines */
		go to RHNG0;

RHNG (3):						/* NG clause (PLUS integer) */
		call emit_bl_rel (value);		/* (j1) lines */
		go to RHNG0;

RHNG0:
		if report.ph ^= null ()
		then call gen_ph (0);		/* exists RH */

	     end;

	else if report.ph ^= null ()
	then call gen_ph (report.heading.count - 1);	/* exists PH */

	if report.controls.loc ^= null ()
	then do;
		call emit_reset_sent ("C-L", "1");	/* compute CLEVEL of report_name = 1. */

		call emit_perf_exit_sent ("C-TO-P");	/* perform C-TO-P of report_name */
	     end;


	if report.ch ^= null ()
	then do;					/* exists(CH groups) */

		ch_table_ptr = report.ch;



		if ch_table.ch_loc (0) ^= null ()
		then call emit_pfex ("CH", 0);	/* perform CH-0 of report_name. */


		call emit_perf_exit_sent ("C-H");	/* perform C-H of report_name. */

	     end;

	call emit_reset_sent ("GEN-CTR", "1");		/* compute GEN-CTR of report_name = 1. */
     end;

emit_go_to_sent:
     proc (string);

declare	string		char (32) varying;

	call emit_go_to (string);			/* go to string of report_name */
	call append_period;				/* . */
     end;

emit_go_to:
     proc (string);

declare	string		char (32) varying;

	call skip_to_b;				/* B margin */
	call append_sep_var_string ("go to");		/* go to */
	call qual_by_rep_proc (string);		/* string of R-report_name */
     end;

emit_ind_go_to_state:
     proc (string, i);

declare	string		char (32) varying,
	i		fixed bin;

	call emit_ind_go_to (string, i);

     end;

emit_ind_go_to_sent:
     proc (string, i);

declare	string		char (32) varying,
	i		fixed bin;

	call emit_ind_go_to_state (string, i);
	call append_period;
     end;

emit_ind_go_to:
     proc (string, i);

declare	string		char (32) varying,
	i		fixed bin;

	call skip_to_b;				/* B margin */
	call append_var_string ("go to");		/*go to */
	call qual_int_by_rep_proc (string, i);		/* string-i of R-report_name */
     end;

emit_ind_perf:
     proc (string, i);

declare	string		char (32) varying,
	i		fixed bin;

	call skip_to_b;				/* B margin */
	call append_var_string ("perform");		/* perform */
	call qual_int_by_rep_proc (string, i);		/* string-i of R-report_name */

     end;

emit_rep_sec_name:
     proc (ch);

declare	ch		char (32) varying;

	call append_sep_var_string (ch);		/* R- */
	call append_token (report.rep_name_ptr);	/* report_name */
     end;

end_sent:
     proc (string);

declare	string		char (32) varying;

	call skip_to_b;				/* B margin */
	call append_var_string (string);		/* string */
	call append_period;				/* . */

     end;

qual_int_by_rep_proc:
     proc (string, i);

declare	string		char (32) varying,
	i		fixed bin;

	if i < 10000
	then call qual_by_int (string, i);		/* string-i */
	else call append_sep_var_string (string);	/* string */

	call append_sep_var_string ("of");		/* of */
	call emit_rep_sec_name ("R");			/* Rreport_name */
     end;

de_word:
     proc (string);

declare	string		char (32) varying;

	call skip_to_b;				/* B margin */
	call append_var_string (string);		/* string */
	call emit_line;

     end;

emit_compute_lhs:
     proc (name, mode);

declare	name		char (32) varying,
	mode		fixed bin;

	call skip_to_b;				/* B margin */
	call append_var_string ("compute");		/* compute */
	call qual_by_rep (name);			/* name of report_name */
	call append_sep_var_string ("=");		/* = */

	if mode = 0
	then return;

	call emit_line;

	call skip_to_col (15 + b_incr);

     end;


emit_rel_con_test:
     proc (var, rel, con);

declare	(var, rel, con)	char (32) varying;

	call if_var_rel (var, rel);			/* if var rel */
	call append_sep_var_string (con);		/* con */
	call emit_line;
     end;

emit_rel_int_test:
     proc (var, rel, i);

declare	(var, rel)	char (32) varying,
	i		fixed bin;

	call if_var_rel (var, rel);			/* if var rel */
	call append_sep_integer (i);			/* i */
	call emit_line;
     end;

if_var_rel:
     proc (var, rel);

declare	(var, rel)	char (32) varying;

	call skip_to_b;				/* B margin */
	call append_var_string ("if");		/* if */
	call qual_by_rep (var);			/* var of report_name */
	call append_sep_var_string (rel);		/* rel */
     end;

if_int_var_rel:
     proc (var, i, rel);

declare	(var, rel)	char (32) varying,
	i		fixed bin;

	call skip_to_b;				/* B margin */
	call append_var_string ("if");		/* if */
	call qual_int_by_rep (var, i);		/* var-i of report_name */
	call append_sep_var_string (rel);		/* rel */
     end;

emit_irel_con_test:
     proc (var, i, rel, con);

declare	(var, rel, con)	char (32) varying,
	i		fixed bin;

	call if_int_var_rel (var, i, rel);
	call append_sep_var_string (con);
	call emit_line;
     end;

emit_move_cvi:
     proc (con, var, i);

declare	(con, var)	char (32) varying,
	i		fixed bin;

	call skip_to_b;				/* B margin */
	call emit_move_con (con);			/* move con to */
	call qual_int_by_rep (var, i);		/* var-i of report_name */
     end;

emit_move_cvi_state:
     proc (con, var, i);

declare	(con, var)	char (32) varying,
	i		fixed bin;

	call emit_move_cvi (con, var, i);
	call emit_line;
     end;

emit_move_con:
     proc (con);

declare	con		char (32) varying;

	call skip_to_b;				/* B margin */
	call append_var_string ("move");		/* move */
	call append_sep_var_string (con);		/* con */
	call append_sep_var_string ("to");		/* to */

     end;

emit_move_con_state:
     proc (con, var);

declare	(con, var)	char (32) varying;

	call emit_move_con (con);
	call qual_by_rep (var);
	call emit_line;
     end;

emit_thru:
     proc (name, suff);

declare	(name, suff)	char (32) varying;

	call append_sep_var_string ("thru");
	call qual_by_rep_proc (name || suff);
     end;

emit_perf_sent:
     proc (name);

declare	name		char (32) varying;

	call emit_perf (name);
	call append_period;				/* . */
     end;

emit_perf_exit_sent:
     proc (name);

declare	name		char (32) varying;

	call emit_perf_exit_state (name);
	call append_period;
     end;




emit_perf_state:
     proc (name);

declare	name		char (32) varying;

	call emit_perf (name);
	call emit_line;

     end;
emit_perf_exit_state:
     proc (name);

declare	name		char (32) varying;

	call emit_perf (name);
	call emit_thru (name, "-EXIT");
	call emit_line;
     end;

emit_perf:
     proc (name);

declare	name		char (32) varying;

	call skip_to_b;				/* B margin */
	call append_sep_var_string ("perform");		/* perform */
	call qual_by_rep_proc (name);			/* name of R-report_name */
     end;

emit_ind_perf_sent:
     proc (string, i);

declare	string		char (32) varying,
	i		fixed bin;

	call emit_ind_perf (string, i);
	call append_period;
     end;

gen_c_h:
     proc;

declare	i		fixed bin;

	call emit_pn ("C-H");			/* C-H. */
						/*[4.4-1]*/
	if ch_table.ch_size > 1
	then call go_to_dep ("C-H", ch_table.ch_size);	/* go to depending */

	do i = 1 by 1 to ch_table.ch_size;

/*[4.4-1]*/
	     if ch_table.ch_size > 1
	     then call emit_ind_pn ("C-H", i);		/* C-H-i. */
	     call skip_to_b;			/* B margin */

	     if ch_table.ch_loc (i) ^= null ()
	     then do;

		     call emit_ind_perf_exit_state ("CH", i);
						/* perform CHi of report_name */
		     call append_period;		/* . */

		end;
	end;

	call emit_exit_para ("C-H-EXIT");		/* C-H-EXIT. exit. */

     end;

gen_c_f:
     proc;

declare	(i, j)		fixed bin;

	call emit_pn ("C-F");			/* C-F. */

	if report.g_i_count ^= 0
	then call emit_move_cv_sent ("all zeros", "GR-I");

	j = cf_table.cf_size;

/*[5.1-4]*/
	if j > 0
	then do i = cf_table.cf_size by -1 to 1;


		if cf_table.cf_loc (i) ^= null ()
		then do;
			call emit_ind_perf_exit_state ("CF", i);
						/* perform CF-i of report_name */

			call append_period;
		     end;

		if cf_table.cf_reset.count (i) ^= 0
		then call emit_ind_perf_sent ("RESET", i);


		if i ^= 1
		then do;

			call skip_to_b;		/* B margin */
			call append_var_string ("if");/* if */
			call qual_by_rep ("C-L");	/* CLEVEL of report_name */
			call append_sep_var_string ("equal");
						/* EQUAL */
			call append_sep_integer (i);	/* i */
			call emit_go_to ("C-F-EXIT"); /* go to C-F-EXIT of report_name */
			call append_period;		/* . */

		     end;
	     end;

	call emit_exit_para ("C-F-EXIT");		/* C-F-EXIT. exit. */

     end;

emit_comment:
     proc (string, pos);

declare	string		char (32) varying,
	pos		fixed bin;

	call skip_to_a;
	substr (line.chars, 7, 1) = "*";
	call skip_to_col (pos);
	call append_var_string (string);
	call emit_line;
     end;

emit_ind_perf_exit_state:
     proc (string, i);

declare	string		char (32) varying,
	i		fixed bin;

	call emit_ind_perf (string, i);
	call emit_thru (string, "-EXIT");
     end;

emit_stall_para:
     proc;


/* subtotalling which occurs for	*/
/* every de group			*/


	call emit_pn ("SUB-TOT");			/* SUB-TOT. */

	call emit_sc ("SUBTOTALLING- ALL GROUPS", de_table.det_subtot_all.first);

     end;

emit_reset_para:
     proc (i);

declare	i		fixed bin;


	reset_chain_entry_ptr = cf_table.cf_reset.first (i);

	call emit_ind_pn ("RESET", i);		/* RESET-i. */

	do while (reset_chain_entry_ptr ^= null ());

	     call skip_to_b;			/* B margin */
	     call append_sep_var_string ("compute");	/* compute */
	     call append_qual_name (reset_chain_entry.loc);
						/* sum counter */
	     call append_sep_var_string ("= 0");	/* = 0 */
	     call append_period;			/* . */

	     reset_chain_entry_ptr = reset_chain_entry.next;

	end;

     end;

emit_sc:
     proc (comm, p);

declare	comm		char (32) varying,
	p		ptr;


	call emit_comment (comm, 32);

	b_incr = 0;
	chain_entry_ptr = p;

	do while (chain_entry_ptr ^= null ());

	     call skip_to_b;			/* B margin */
	     call append_sep_var_string ("add");	/* add */
	     call emit_identifier (chain_entry.ce_loc);	/* addend */
	     call append_sep_var_string ("to");		/* to */
	     call append_qual_name (chain_entry.ce_sum_loc);
						/* sum counter */
	     call append_period;


	     chain_entry_ptr = chain_entry.ce_next;

	end;

     end;

emit_rep_pn:
     proc (ch, type);

declare	ch		char (32) varying,
	type		fixed bin;

	call skip_to_a;

	call emit_rep_sec_name (ch);

	if type ^= 0
	then call append_sep_var_string ("section");

	call append_period;

     end;

qual_by_rep_proc:
     proc (string);

declare	string		char (32) varying;

	call append_sep_var_string (string);		/* string */

	call append_sep_var_string ("of");		/* of */

	call emit_rep_sec_name ("R");			/* Rreport_name */


     end;

declare	1 line,
	  2 next_loc	fixed bin,		/* next location */
	  2 bl_loc	fixed bin,		/* location of last space */
	  2 chars		char (256);

declare	first_line	fixed bin,
	trace_bit		bit (1);

append_var_string:
     proc (string);

/* append a char varying string to	*/
/* the current line			*/

declare	string		char (32) varying;
declare	sz		fixed bin;

	sz = length (string);

	substr (line.chars, line.next_loc, sz) = string;
	line.next_loc = line.next_loc + sz;

     end;

append_refer_string:
     proc (refer_ptr);

/* append a string of characters to the	*/
/* current line. The location of the	*/
/* self defined string is an input	*/
/* parameter			*/

declare	refer_ptr		ptr;
declare	sz		fixed bin;

declare	1 refer_string	based (refer_ptr),
	  2 size		fixed bin,
	  2 string	char (0 refer (refer_string.size));

	sz = refer_string.size;

	substr (line.chars, line.next_loc, sz) = refer_string.string;
	line.next_loc = line.next_loc + sz;

     end;

append_integer:
     proc (bin_int);

/* append a decimal integer to the	*/
/* current string. The location of a	*/
/* binary integer is an input paramater	*/

declare	bin_int		fixed bin;
declare	dec_int		char (4),
	dec_size		fixed bin;


	if bin_int <= 0
	then do;
		dec_int = "0";
		dec_size = 1;
	     end;
	else do;

		call ioa_$rsnnl ("^d", dec_int, dec_size, bin_int);

	     end;

	substr (line.chars, line.next_loc, dec_size) = dec_int;
	line.next_loc = line.next_loc + dec_size;

     end;

append_sep_var_string:
     proc (string);

/* This operation appends a space and	*/
/* then executes the operation	*/
/* append_var_string		*/

declare	string		char (32) varying;

	call append_space;

	call append_var_string (string);

     end;

append_sep_refer_string:
     proc (refer_ptr);

/* This operation appends a space and	*/
/* then executes the operation	*/
/* append_refer_string		*/

declare	refer_ptr		ptr;

	call append_space;

	call append_refer_string (refer_ptr);

     end;

append_sep_integer:
     proc (bin_int);

/* This operation appends a space and	*/
/* then executes the operation	*/
/* append_integer			*/

declare	bin_int		fixed bin;

	call append_space;

	call append_integer (bin_int);

     end;




declare	b_incr		fixed bin;


skip_to_b:
     proc;

/* This operation adds spaces to the	*/
/* current line and insures that the	*/
/* next item placed in the line is in	*/
/* the B field			*/

declare	loc		fixed bin;


	loc = 12 + b_incr;

	if line.next_loc >= loc
	then do;
		if substr (line.chars, line.next_loc - 1, 1) = " "
		then line.bl_loc = line.next_loc - 1;
		else do;
			substr (line.chars, line.next_loc, 1) = " ";
			line.bl_loc = line.next_loc;
			line.next_loc = line.next_loc + 1;
		     end;
	     end;
	else do;
		substr (line.chars, line.next_loc, loc - line.next_loc) = " ";
		line.bl_loc = loc - 1;
		line.next_loc = loc;
	     end;

     end;



skip_to_a:
     proc;

	substr (line.chars, 1, 7) = " ";
	line.bl_loc = 7;
	line.next_loc = 8;
     end;

skip_to_col:
     proc (pos);

declare	pos		fixed bin;

	if pos <= line.next_loc
	then return;

	substr (line.chars, line.next_loc, pos - line.next_loc) = " ";
	line.next_loc = pos;
     end;

append_space:
     proc;

/* append a space to the current line	*/
/* emit a line if required		*/

	if substr (line.chars, line.next_loc - 1, 1) = " "
	then return;

	if line.next_loc < 72
	then call es;
	else if line.next_loc < 74
	then call emit_line;
	else do;
		call emit_line;
		call es;
	     end;

     end;

es:
     proc;

	substr (line.chars, line.next_loc, 1) = " ";
	line.bl_loc = line.next_loc;
	line.next_loc = line.next_loc + 1;

     end;

append_period:
     proc;

/* append a period separator to the	*/
/* current line, emit one or two lines	*/
/* as required			*/

	if line.next_loc < 73
	then do;
		call ep;
		call emit_line;
		call seta;
	     end;
	else do;
		call emit_line;
		call ep;
		call emit_line;
		call seta;
	     end;

     end;

ep:
     proc;

	substr (line.chars, line.next_loc, 1) = ".";
	line.next_loc = line.next_loc + 1;

     end;

seta:
     proc;

	line.bl_loc = 7;
	line.next_loc = 8;

     end;

declare	rwfp		ptr;

append_list:
     proc (list_ptr);

declare	list_ptr		ptr,
	st		bit (32),
	(i, rec_size)	fixed;

	list_def_ptr = list_ptr;

	call cobol_io_$cobol_msf_start (rwfp, addrel (list_def.first, -1));

	do i = 1 by 1 to list_def.count;

	     call cobol_swf_get (rwfp, st, addr_record, rec_size);

	     if substr (st, 17, 16) ^= "0"b
	     then return;

	     call append_sep_token (addr_record);

	end;
     end;




append_token:
     proc (token_ptr);

declare	token_ptr		ptr;

	call get_ref_ptr (token_ptr);

	call append_refer_string (refer_ptr);

     end;
declare	refer_ptr		ptr;




get_ref_ptr:
     proc (token_ptr);

declare	token_ptr		ptr;
declare	type		fixed bin;

	type = token_ptr -> reserved_word.type;

	if type > 8
	then return;

	go to TOK (type);

TOK (0):
TOK (5):
TOK (6):
	return;
TOK (1):
	refer_ptr = addr (token_ptr -> reserved_word.length);
	go to TOK1;

TOK (2):
	refer_ptr = addr (token_ptr -> numeric_lit.places);
	go to TOK1;

TOK (3):
	call quoter (token_ptr);
	go to TOK1;

TOK (4):
	refer_ptr = addr (token_ptr -> picture.length);
	go to TOK1;

TOK (7):
	refer_ptr = addr (token_ptr -> proc_def.name_size);
	go to TOK1;

TOK (8):
	refer_ptr = addr (token_ptr -> user_word.length);
	go to TOK1;

TOK1:
     end;



append_sep_token:
     proc (token_ptr);

declare	token_ptr		ptr;

	call get_ref_ptr (token_ptr);

	call append_sep_refer_string (refer_ptr);

     end;

append_level_number:
     proc (lev_num);				/* append a level number in the A margin	*/
						/* and then emit blanks			*/

declare	lev_num		fixed bin;
declare	sz		fixed bin;

	call skip_to_a;

	if lev_num < 10
	then call append_var_string ("0");		/* 0 */

	call append_integer (lev_num);		/* level number */

	sz = lev_num + lev_num;
	substr (line.chars, line.next_loc, sz) = " ";	/* blanks */

	line.next_loc = line.next_loc + sz;
	line.bl_loc = line.next_loc - 1;

     end;

append_qual_name:
     proc (qn_ptr);					/* append a qualified name, loc of	*/
						/* the qual name is in qual_name_ptr	*/

declare	qn_ptr		ptr;
declare	(i, ct)		fixed bin;

/*[5.1-2]*/
	ct = qn_ptr -> qual_name.qn_size;

/*[5.1-2]*/
	if ct = 1					/*[5.1-2]*/
	then call unqual_name (qn_ptr -> qual_name.qn_loc (1));
						/*[5.1-2]*/
	else do i = 1 by 1 to ct;

		if i ^= 1
		then call append_sep_var_string ("of"); /* of */
		call append_sep_token (qn_ptr -> qual_name.qn_loc (i));
						/* data-name */
	     end;
     end;

emit_line:
     proc;

/* the current line is emitted. If it	*/
/* exceeds 72 characters in length	*/
/* then the last item on the line is	*/
/* saved and placed in the B field of	*/
/* the next line			*/

declare	sz		fixed bin;

	if line.next_loc > 8			/* non empty line */
	then if line.next_loc <= 73			/* short line */
	     then do;
		     call EMIT (line.next_loc);

		     call clear_line;



		end;
	     else do;
		     call EMIT (line.bl_loc);		/* long line */

		     substr (line.chars, 1, 11) = " ";

		     sz = line.next_loc - line.bl_loc - 1;

/* line overflow */

		     substr (line.chars, 12, sz) = substr (line.chars, line.bl_loc + 1);

		     line.bl_loc = 11;
		     line.next_loc = 12 + sz;
		     call EMIT (line.next_loc);
		     call clear_line;
		end;
     end;



declare	rwdd		bit (1),
	(ddloc, pdloc)	fixed bin;

declare	chars		char (1024) based;



EMIT:
     proc (loc);

declare	loc		fixed bin;

/*[5.0-1]*/
	substr (line.chars, 1, 6) = "::::::";		/* dont put into the listing */

	if rwdd
	then do;
		substr (cobol_rwdd -> chars, ddloc, loc) = substr (line.chars, 1, loc - 1) || "
";
		ddloc = ddloc + loc;
	     end;
	else do;
		substr (cobol_rwpd -> chars, pdloc, loc) = substr (line.chars, 1, loc - 1) || "
";
		pdloc = pdloc + loc;
	     end;

     end;

line_init:
     proc;

	line.next_loc = 1;
	line.bl_loc = 1;
	line.chars = " ";
     end;



declare	1 ALF,
	  2 lit_size	fixed bin,
	  2 string	char (136);

declare	1 alf_lit		based (alf_lit_ptr),
	  2 lit_size	fixed bin,
	  2 string	char (136 refer (alf_lit.lit_size));

declare	alf_lit_ptr	ptr;

quoter:
     proc (token_ptr);

declare	token_ptr		ptr;

	ALF.lit_size = token_ptr -> alphanum_lit.lit_size + 2;
	substr (ALF.string, 1, ALF.lit_size) = """" || token_ptr -> alphanum_lit.string || """";

	refer_ptr = alf_lit_ptr;

     end;

emit_write_line:
     proc;

	call emit_comment ("WRITE-LINE", 32);
	call append_level_number (2);
	call qual_by_int ("WRITE-LINE", report.rep_num);
	call append_sep_var_string ("redefines");
	call qual_by_int ("REP-LINE", report.rep_num);
	call append_period;

	call emit_write_fields ("LINE-SIZE");


	call append_level_number (3);
	call append_sep_var_string ("B occurs 1 to 132 times");
	call emit_line;
	call skip_to_b;
	call append_sep_var_string ("depending on");

	call qual_by_rep ("LINE-SIZE");
	call append_sep_var_string ("pic x");
	call append_period;

     end;

emit_write_fields:
     proc (name);

declare	name		char (32) varying;

	call emit_lev_item (3, name || " comp-6", "");
	call emit_lev_item (3, "C-D pic xx", "");
	call emit_lev_item (3, "T-Y pic xx", "");

     end;

declare	efg		bit (1);


gen_report_init:
     proc;

	ch_table_ptr = report.ch;
	cf_table_ptr = report.cf;
	de_table_ptr = report.de;

	code = report.code;

	if code = ""
	then code = "  ";				/* default for report code */

	if ch_table_ptr ^= null ()
	then control_count = cf_table.cf_size;
	else control_count = 0;

	control_name_table_loc = report.controls.loc;




	if report.ph ^= null () | report.rh ^= null () | report.controls.loc ^= null ()
	then efg = "1"b;				/* emit  FG. */
	else efg = "0"b;


     end;




emit_line_size_init:
     proc (size);

declare	size		fixed bin;

	call skip_to_b;				/* B margin */
	call append_var_string ("compute");		/* compute */

	call qual_by_rep ("LINE-SIZE");
	call append_sep_var_string ("=");		/* = */
	call append_sep_integer (size);		/* size */
	call append_period;				/* . */

     end;




buffer_name_def:
     proc (name);

declare	name		char (32) varying;

	call append_level_number (2);			/* 02 */
	call qual_by_int (name, report.rep_num);	/* name-i */
	call append_period;				/* .*/

     end;




emit_pb_blank_lines:
     proc (line1, line2);

declare	(line1, line2)	fixed bin;

	call emit_rel_int_test ("line-counter", "not less", line2);
						/* if line-counter > line */
	call sbc (report.page.count + line1);		/* incr BLANK-COUNT */
	call emit_line;
	call de_word ("else");			/* else */
	call sbc (line1);				/* set BLANK-COUNT */
	call de_word ("end-if");			/* end-if */
	call emit_rel_con_test ("BL-C", "greater", "0");	/* if BLANK-COUNT > 0 */
	call emit_write_state ("BLANK-LINES");		/* write from BLANK-LINES */
	call de_word ("end-if");			/* end-if */
	call emit_comp_end ("line-counter", line2);	/* compute line-counter = line end-compute */


     end;

sbc:
     proc (size);

declare	size		fixed bin;

	call emit_comp ("BL-C", size);		/* compute BLANK-COUNT = size */


	if size = 0
	then return;

	call append_sep_var_string ("-");		/* - */
	call qual_by_rep ("line-counter");		/* line-counter */

     end;




descr_pic_line:
     proc (lev, name, desc);

declare	lev		fixed bin,
	(name, desc)	char (32) varying;

	call append_level_number (lev);		/* lev */
	call append_sep_var_string (name);
	call append_sep_var_string (desc);
	call append_period;				/* . */
     end;



LINE:
     proc (line);

declare	line		char (32) varying;

	call skip_to_b;				/* B margin */
	call append_var_string (line);		/* line */
	call emit_line;
     end;

emit_section:
     proc (name);

declare	name		char (32) varying;

	call skip_to_a;				/* A margin */
	call append_var_string (name);		/* name */
	call append_sep_var_string ("section");		/* section */
	call append_period;				/* . */
     end;




SENT:
     proc (sent);

declare	sent		char (32) varying;

	call skip_to_b;				/* B margin */
	call append_var_string (sent);		/* sent */
	call append_period;				/* . */
     end;


test_control_tables:
     proc;					/* do CH and CF tables contain entries */

	if report.ch ^= null ()
	then call tct (report.ch);
	if report.cf ^= null ()
	then call tct (report.cf);

     end;


tct:
     proc (p);

declare	p		ptr,
	i		fixed bin;

	do i = 1 by 1 to p -> ch_table.ch_size;

	     if p -> ch_table.ch_loc (i) ^= null ()
	     then return;

	end;

	p = null ();

     end;


sum_descr:
     proc;

	call append_sep_var_string ("pic s9(9)v9(9)");
	call append_sep_var_string ("sign leading separate");


     end;

cb_save:
     proc;

	call emit_perf_exit_state ("C-TO-S");		/* perform C-TO-S of report_name */
	call emit_perf_exit_state ("P-TO-C");		/* perform P-TO-C of report_name */

     end;

cb_restore:
     proc;

	call emit_perf_exit_state ("S-TO-C");		/* perform S-TO-C of report_name */
	call emit_perf_exit_state ("C-TO-P");		/* perform C-TO-P of report_name */

     end;



emit_comp:
     proc (var, size);

declare	var		char (32) varying,
	size		fixed bin;

	call emit_compute_lhs (var, 1);		/* compute var = */
	call append_sep_integer (size);		/* size */

     end;


emit_comp_end:
     proc (var, size);

declare	var		char (32) varying,
	size		fixed bin;

	if size > report.page.count
	then size = size - report.page.count;

	call emit_comp (var, size);			/* compute var = size */
	call append_sep_var_string ("end-compute");	/* end-compute */

     end;


emit_comp_write:
     proc (count);

declare	count		fixed bin;

	call emit_comp_end ("BL-C", count);		/* compute BLANK-COUNT = count end-compute */
	call emit_line;

	call emit_write_state ("BLANK-LINES");		/* write from BLANK-LINES */

     end;


emit_rel:
     proc (count);

declare	count		fixed bin;

	if count > 0
	then call emit_comp_write (count);


	call emit_incr_state ("line-counter", count + 1); /* compute line-counter = line-counter + count + 1 */

     end;


emit_abs:
     proc (count, line);

declare	(count, line)	fixed bin;

	if count ^= 0
	then call emit_comp_write (count);



	call emit_comp_end ("line-counter", line);	/* compute line-counter = line end-compute */

     end;


clear_line:
     proc;

	substr (line.chars, 1, 11) = " ";
	line.bl_loc = 11;
	line.next_loc = 12;

     end;


gen_ph:
     proc (incr);

declare	(incr, line, type)	fixed bin;

	rt_ptr = report.ph;				/* PH group */
	line = root.group_desc.line;
	type = root.group_desc.type;

	if type = 1
	then call emit_ABS (line);			/* absolute */
	else call emit_bl_rel (line + incr);		/* relative */

	call emit_perf_exit_sent ("P-H");		/* perform P-H of report_name */

     end;


pb_test:
     proc (line);

declare	line		fixed bin;

	if line < report.page.count
	then call emit_rel_int_test ("line-counter", "greater", line);
						/* if line-counter greater line */
	else call emit_rel_int_test ("line-counter", "equal", 0);
						/* if line-counter = 0 */

     end;


emit_ng_rel:
     proc (line);

declare	line		fixed bin;

	if line <= 1
	then return;

	call EMIT_REL (line - 1, line - 1);

     end;

emit_b_abs:
     proc;

	call emit_comment ("EMIT BLANK LINES", 32);
	call emit_pn ("B-ABS");			/* B-ABS. */

	call emit_rel_var_test ("line-counter", "not less", "LN-C");
						/* IF line-counter >= LINE-COUNT */

	b_incr = b_incr + 3;

	call emit_compute_lhs ("BL-C", 1);		/* compute BLANK-COUNT = */
	call append_integer (report.page.count);	/* page */
	call op_var ("-", "line-counter");		/* - line-counter */
	call emit_line;
	call emit_perf_state ("W-BL");		/* perform W-BL */
	call emit_perf_state ("P-INCR");		/* perform P-INCR */
	call emit_compute_lhs ("BL-C", 1);		/* compute BLANK-COUNT = */
	call qual_by_rep ("LN-C");			/* LINE-COUNT */
	call op_con ("-", "1");			/* - 1 */
	call emit_line;

	call emit_perf_state ("W-BL");		/* perform W-BL */

	b_incr = b_incr - 3;

	call de_word ("else");			/* else */

	b_incr = b_incr + 3;

	call emit_compute_lhs ("BL-C", 1);		/* compute BLANK-COUNT = */
	call qual_by_rep ("LN-C");			/* LINE-COUNT */
	call op_con ("-", "1");			/* - 1 */
	call op_var ("-", "line-counter");		/* - line-counter */
	call emit_line;

	call emit_perf_state ("W-BL");		/* perform W-BL */

	b_incr = b_incr - 3;

	call de_word ("end-if");			/* end-if */
	call append_period;				/* . */

	call emit_compute_lhs ("line-counter", 0);	/* compute line-counter = */
	call qual_by_rep ("LN-C");			/* LINE-COUNT */
	call append_period;				/* . */

     end;

emit_rel_var_test:
     proc (var, rel, con);

declare	(var, rel, con)	char (32) varying;

	call if_var_rel (var, rel);			/* if var rel */
	call qual_by_rep (con);			/* con */
	call emit_line;
     end;

op_con:
     proc (op, con);

declare	(op, con)		char (32) varying;

	call append_sep_var_string (op);
	call append_sep_var_string (con);
     end;

op_var:
     proc (op, var);

declare	(op, var)		char (32) varying;

	call append_sep_var_string (op);
	call qual_by_rep (var);
     end;

emit_w_bl:
     proc;

	call emit_comment ("WRITE BLANK LINES", 32);
	call emit_pn ("W-BL");			/* W-BL. */
	call emit_wr_bl;
     end;

emit_wr_bl:
     proc;

	call emit_rel_con_test ("BL-C", "greater", "0");	/* if BLANK-COUNT > 0 */
	call emit_write_state ("BLANK-LINES");		/* write from BLANK-LINES */
						/*[5.0-1]*/
	call de_word ("end-if.");			/* end-if. */

     end;

emit_end_page_rec:
     proc;

	call buffer_name_def ("END-PAGE");		/* 02 END-PAGE-i. */
	call bld ("0", "n ");
     end;

bld:
     proc (val, type);

declare	(val, type)	char (32) varying;

	call emit_lev_item (3, "S-Z comp-6", val);	/* 03 SIZE comp-6 value val */
	call emit_lev_item (3, "C-D pic xx", """" || code || """");
						/* 03 CODE pic xx value "cc". */
	call emit_lev_item (3, "T-Y pic xx", """" || type || """");
						/* 03 TYPE pic xx value "type" */
     end;

emit_move_int_state:
     proc (line, var);

declare	line		fixed bin,
	var		char (32) varying;

	call skip_to_b;				/* B margin */
	call append_var_string ("move");		/* move */
	call append_sep_integer (line);		/* line */
	call append_sep_var_string ("to");		/* to */
	call qual_by_rep (var);			/* var */
     end;

emit_ABS:
     proc (line);

declare	line		fixed bin;

	call STATE ("compute S-PI = 1");		/* compute S-PI = 1 */
	call emit_bl_abs (line);
	call STATE ("compute S-PI = 0");		/* compute S-PI = 0 */
     end;

emit_if_test:
     proc (var, op, con);

declare	(var, op, con)	char (32) varying;

	call skip_to_b;				/* B margin */
	call append_var_string ("if");
	call append_sep_var_string (var);
	call append_sep_var_string (op);
	call append_sep_var_string (con);		/* if var op con */
	call emit_line;

	call skip_to_b;				/* B margin */
     end;

STATE:
     proc (state);

declare	state		char (32) varying;

	call skip_to_b;				/* B margin */
	call append_var_string (state);
	call emit_line;
     end;

emit_write_state:
     proc (rec_area);

/*[5.0-1]*/
dcl	rec_area		char (32) varying;

/*[5.0-1]*/
	call emit_WR (rec_area);			/*[5.0-1]*/
	call emit_line;
     end;

emit_write_sent:
     proc (rec_area);

/*[5.0-1]*/
dcl	rec_area		char (32) varying;

/*[5.0-1]*/
	call emit_WR (rec_area);			/*[5.0-1]*/
	call append_period;				/*[5.0-1]*/
	call emit_line;
     end;

unqual_name:
     proc (qn_ptr);

/* LINE-COUNTER and PAGE-COUNTER	*/
/* must be qualif by report-name	*/

dcl	qn_ptr		ptr,
	char12		char (12);

/*[5.1-2]*/
	call append_sep_token (qn_ptr);

/*[5.1-2]*/
	if qn_ptr -> user_word.length = 12		/*[5.1-2]*/
	then do;
		char12 = substr (qn_ptr -> user_word.word, 1, 12);

/*[5.1-2]*/
		if char12 = "line-counter" | char12 = "page-counter"
						/*[5.1-2]*/
		then do;

/*[5.1-2]*/
			call append_sep_var_string ("of");
						/*[5.1-2]*/
			call append_sep_token (report.rep_name_ptr);

/*[5.1-2]*/
		     end;

/*[5.1-2]*/
	     end;

     end;



/* control name table */

declare	1 control_name_table
			based (control_name_table_loc),
	  2 cnt_size	fixed bin,
	  2 cnt_loc	(0 refer (control_name_table.cnt_size)) ptr;

declare	control_name_table_loc
			ptr;

declare	1 reserved_word	based,
%include cobol_TYPE1;

declare	1 numeric_lit	based,
%include cobol_TYPE2;

declare	1 alphanum_lit	based,
%include cobol_TYPE3;

declare	1 proc_def	based (addr_record),
%include cobol_TYPE7;

declare	addr_record	ptr;

%include cobol_report_writer;
%include cobol_ext_;
%include cobol_fixed_common;

     end;
