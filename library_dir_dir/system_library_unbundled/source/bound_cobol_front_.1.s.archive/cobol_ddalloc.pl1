/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_ddalloc.pl1 Reformatted code to new Cobol standard.
                                                   END HISTORY COMMENTS */


/* Modified on 09/28/83 by FCH, [5.2...], trace added */
/* Modified on 12/30/81 by FCH, [5.1-2], [4.2-2] is removed, phx11821(BUG520) */
/* Modified on 10/13/81 by FCH, [5.1-1], major rewrite of redefines, BUG516, BUG513(phx11673) */
/* Modified on 04/03/80 by FCH, [4.2-3], -rck does not work with odo, BUG430(TR4533) */
/* Modified on 09/24/79 by FCH, [4.2-2], constant sect becomes working-storage sect */
/* Modified on 08/23/79 by FCH, [4.2-1] just_right = "0"b during initialization */
/* Modified on 12/28/78 by FCH, [3.0-2], fix  son_cnt */
/* Modified on 05/12/78 by FCH, [3.0-1], fix incorrect unequal size diag */
/* Modified since Version 3.0 */









/* format: style3 */
cobol_ddalloc:
     proc;/***.....if Trace_Bit="1"b then call ioa_("^a^a",substr(Trace_Line,1,Trace_Lev),"COBOL_DDALLOC:");/**/

/*[5.1-1]*/
	addr (stk (0)) -> bit32400 = "0"b;

	stk.redef_ptr (1) = null ();
	redef_object_offset = 1;
	ddseg.next_offset = 8;

	fixed_common.number_of_dd_segs = 1;
	fixed_common.size_seg = record_segment;
	fixed_common.size_offset = 0;

/*[5.1-1]*/
	hisi_slack = substr (fixed_common.compile_mode, 5, 1);

	if fixed_common.sra_clauses > 0
	then do i = 1 to fixed_common.sra_clauses;

		same_rec_area_info.clause_no (i) = i;
		same_rec_area_info.seg_num (i) = 0;
		same_rec_area_info.cra_size (i) = 0;

	     end;

	current_fno = 0;
	file_key = "00000";
	procdef.section_name = fixed_common.pd_section;
	reswd.jump_index = 0;
	numlit.line, numlit.column = 0;
	numlit.type = 2;
	nonnumlit.line, nonnumlit.column = 0;
	nonnumlit.type = 3;

	if fixed_common.odo_info ^= "00000"
	then do;					/* size routines must be generated */

		procname_sw = 1;

		call cobol_swf_put (cobol_ext_$cobol_m2fp, st, addr (type25), type25.size);
						/* write type25 for pdstax */

		if procdef.section_name
		then do;

			procdef.section_num = fixed_common.spec_tag_counter + 1;
			procdef.proc_num = fixed_common.spec_tag_counter + 1;

			call cobol_swf_put (cobol_ext_$cobol_m2fp, st, addr (procdef), procdef.size);

			reswd.key = reswd_SECTION;
			reswd.class = "000000000000000000110000000"b;

			call put_rw_token;		/* write out SECTION key */

			reswd.key = reschar_PERIOD;
			reswd.class = "000100000000000000000000000"b;

			call put_rw_token;		/* write out period key */

			fixed_common.spec_tag_counter = procdef.proc_num;
			procdef.section_name = "0"b;

		     end;

	     end;
	else procname_sw = 0;

	do i = 1 to fixed_common.file_count;

	     call cobol_read_ft_ (i, ft_ptr);

	     if ^file_table.sort_file
	     then do;

		     if ^file_table.external
		     then do;

			     temp = index (file_table.ifn, " ") - 1;

			     if temp < 0
			     then temp = 16;

			     file_table.id =
				substr (file_table.ifn, 1, temp) || "." || unique_chars_ (unique_bits_ ());

			end;
		     else file_table.id = file_table.ifn;

		     call cobol_make_fsb_link_ (ft_ptr);

		end;
	end;

/* FIRST PASS */

	eof = 0;
	first_name_key = fixed_common.first_dd_item;

	if first_name_key = "00000"
	then eof = -1;
	else call cobol_ntio$dget (dn_ptr, first_name_key);

	do while (eof = 0);

	     if data_name.type = 12 | data_name.type = 16
	     then do;

		     current_fno = dn_ptr -> fd_token.file_no;

		     if current_fno = 0
		     then ft_ptr = null ();		/* a fatal error was encountered */
		     else call cobol_read_ft_ (current_fno, ft_ptr);


		     call GET;

		end;

	     else if data_name.type = 9
	     then do;

		     if data_name.level ^= 66
		     then do;

			     if data_name.file_num ^= current_fno
			     then current_fno = 0;

			     call set_size;

			     if current_fno > 0
			     then do;		/* processing a record description */

				     temp_size = stk.nt_ptr (1) -> data_name.item_length;

				     if file_table.same_rec_clause ^= 0
				     then do;

					     if temp_size
						> same_rec_area_info.cra_size (file_table.same_rec_clause)
					     then same_rec_area_info.cra_size (file_table.same_rec_clause) =
						     temp_size;

					end;

				     if file_table.max_cra_size ^= 0
				     then if temp_size ^= file_table.max_cra_size
					then file_table.unequal_recs = "1"b;

				     if stk.nt_ptr (1) -> data_name.variable_length
				     then file_table.unequal_recs = "1"b;

				     if temp_size > file_table.max_cra_size
				     then file_table.max_cra_size = temp_size;

				end;

			end;
		     else call GET;

		end;
	     else call GET;

	end;

/* SECOND PASS */

	if eof = 1
	then do;

		eof = 0;
		index_cnt = 0;

		call cobol_ntio$dget (dn_ptr, first_name_key);
		call cobol_ntio$sget (dn_ptr, eof);
		;				/* discard SYSTEM-STATUS */
		call cobol_ntio$sget (dn_ptr, eof);
		;				/* discard TALLY */

	     end;





	do while (eof = 0);

	     if data_name.type = 9
	     then do;

		     if data_name.level ^= 66
		     then do;			/* replacement will patch renames items */

			     if data_name.level = 01 | data_name.level = 77
			     then do;

				     odo_proc_num = 0;
				     occurs_level = 0;

				     if ^data_name.exp_redefining
				     then do;

					     if data_name.o_of_rdf
					     then temp_size = data_name.max_red_size;
					     else temp_size = data_name.item_length;

					     if data_name.working_storage
					     then do;

						     cobol_$ws_charcnt = cobol_$ws_charcnt + temp_size;

						     if cobol_$ws_wdoff = 0
						     then cobol_$ws_wdoff =
							     divide (ddseg.next_offset, 4, 35, 0);

						end;

					     else if data_name.linkage_section
					     then do;

						     cobol_$ls_charcnt = cobol_$ls_charcnt + temp_size;
						     fixed_common.number_of_ls_pointers =
							fixed_common.number_of_ls_pointers + 1;

						end;


/*[5.1-2]*/
					     else if data_name.constant_section
						/*[5.1-2]*/
					     then cobol_$cons_charcnt = cobol_$cons_charcnt + temp_size;


					end;
				end;
			     else call test_occurs;

			     if data_name.variable_length
			     then call variable_size;



/*[5.1-2]*/
			     if data_name.constant_section
						/*[5.1-2]*/
			     then do;

/*[5.1-2]*/
				     call cobol_IVAL (dn_ptr);

/*[5.1-2]*/
				     data_name.seg_num = 3000;
						/*[5.1-2]*/
				     curr_wd_off = con_wd_off;
						/*[5.1-2]*/
				     curr_char_off = (curr_wd_off * 4) - data_name.offset;
						/*[5.1-2]*/
				     curr_char_pos = mod (curr_char_off, 4);

/*[5.1-2]*/
				     if curr_char_pos > 0
						/*[5.1-2]*/
				     then do;

/*[5.1-2]*/
					     if curr_char_pos = 1
					     then curr_char_pos = 3;
						/*[5.1-2]*/
					     else if curr_char_pos = 3
					     then curr_char_pos = 1;

/*[5.1-2]*/
					     curr_wd_off = divide (curr_char_off, 4, 17, 0) + 1;
						/*[5.1-2]*/
					     curr_char_off = curr_wd_off * 4;
						/*[5.1-2]*/
					end;

/*[5.1-2]*/
				     data_name.offset = curr_char_off + curr_char_pos;
						/*[5.1-2]*/
				end;		/*[5.1-2]*/
						/*[5.1-2]*/
			     else if ^data_name.linkage_section
			     then do;		/* allocate in cobol ^data.	*/

				     if data_name.level = 01 | data_name.level = 77
				     then do;

					     if data_name.file_num ^> 0
					     then do;
						/* record area for file already allocated */

						     if data_name.exp_redefining
						     then record_offset = redef_object_offset;
						     else do;

							     if data_name.communication_section
							     then do;

								     redef_object_offset, record_offset =
									cd_offsets (data_name.file_num);

								end;
							     else do;

								     if data_name.o_of_rdf
								     then temp_len =
									     data_name.max_red_size;
								     else temp_len =
									     data_name.item_length;

								     if data_name.double_word
								     then temp_mod = 8;
								     else if data_name.word
								     then temp_mod = 4;
								     else if data_name.half_word
								     then temp_mod = 2;
								     else temp_mod = 1;

								     temp_slack =
									mod (ddseg.next_offset,
									temp_mod);

								     if temp_slack > 0
								     then record_offset =
									     ddseg.next_offset
									     + temp_mod - temp_slack;
								     else record_offset =
									     ddseg.next_offset;

								     ddseg.next_offset =
									record_offset + temp_len;

								     if data_name.o_of_rdf
								     then redef_object_offset =
									     record_offset;

								end;

							end;

						end;

					     else if ft_ptr ^= null ()
					     then record_offset = file_table.cra_offset;

					end;

				     data_name.seg_num = record_segment;
				     data_name.offset = data_name.offset + record_offset;

				     if data_name.initial_ptr ^= 0
				     then do;

					     cobol_$value_cnt = cobol_$value_cnt + 1;

					     call mc_initval_seg2;

					end;
				end;
			end;




		     if index_cnt > 0
		     then do;

			     temp_slack = mod (ddseg.next_offset, 8);

			     if temp_slack > 0
			     then ddseg.next_offset = ddseg.next_offset + 8 - temp_slack;

			     do i = 1 to index_cnt;

				ind_ptr = index_ptr (i);
				index_name.seg_num = record_segment;
				index_name.offset = ddseg.next_offset;
				index_name.struc_length = occurs_info.struclength (occurs_level);
				ddseg.next_offset = ddseg.next_offset + 8;
				cobol_$ws_charcnt = cobol_$ws_charcnt + 8;

			     end;

			     index_cnt = 0;

			end;
		end;
	     else if data_name.type = 10
	     then do;				/* index-name token */

		     index_cnt = index_cnt + 1;
		     index_ptr (index_cnt) = dn_ptr;	/* defer allocation until following type 9 is processed */

		end;

	     else if data_name.type = 13
	     then do;				/* cd token */

		     cdtoken_ptr = dn_ptr;
		     temp_slack = mod (ddseg.next_offset, 16);
						/* double word align */

		     if temp_slack > 0
		     then record_offset, ddseg.next_offset = ddseg.next_offset + 16 - temp_slack;
		     else record_offset = ddseg.next_offset;

		     if cdtoken.options.input
		     then do;

			     dn_ptr = addr (icdhdr_type9);
			     ddseg.next_offset = ddseg.next_offset + 60;
			     temp = 87;

			end;
		     else do;

			     dn_ptr = addr (ocdhdr_type9);
			     ddseg.next_offset = ddseg.next_offset + 20;
			     ocdhdr_type9.binary_max_station_count = cdtoken.mdest;

			     call bin_to_dec (cdtoken.mdest, temp_char5, temp);

			     ocdhdr_type9.max_station_count = "0000";
			     substr (ocdhdr_type9.max_station_count, 5 - temp, temp) = temp_char5;
			     temp = 10 + 13 * cdtoken.mdest;

			end;

		     data_name.offset = record_offset;

		     call mc_initval_seg2;

		     if cobol_$coms_wdoff = 0
		     then cobol_$coms_wdoff = divide (record_offset, 4, 35, 0);

		     record_offset = ddseg.next_offset; /* offset of data i.e. following header */
		     cdtoken.cd_seg = record_segment;
		     cd_offsets (cdtoken.cd_num), cdtoken.cd_off = record_offset;

		     if cdtoken.options.initial
		     then do;

			     fixed_common.init_cd_seg = record_segment;
			     fixed_common.init_cd_offset = record_offset;

			end;

		     ddseg.next_offset = ddseg.next_offset + temp;
		     cobol_$coms_charcnt = cobol_$coms_charcnt + temp;
		     cobol_$cd_cnt = cobol_$cd_cnt + 1;

		end;

	     else if data_name.type = 12 | data_name.type = 16
	     then do;				/* file-name */

		     name_ptr = dn_ptr;

		     if fd_token.file_no > 0
		     then do;

			     call cobol_read_ft_ (fd_token.file_no, ft_ptr);

			     file_table.locate_mode = "0"b;
			     temp_slack = mod (ddseg.next_offset, 8);

			     if temp_slack > 0
			     then record_offset = ddseg.next_offset + 8 - temp_slack;
			     else record_offset = ddseg.next_offset;

			     if file_table.same_rec_clause ^= 0
			     then do;

				     i = file_table.same_rec_clause;

				     if same_rec_area_info.seg_num (i) = 0
				     then do;	/* hasn't been allocated yet */

					     same_rec_area_info.seg_num (i) = record_segment;
					     same_rec_area_info.offset (i) = record_offset;
					     ddseg.next_offset =
						record_offset + same_rec_area_info.cra_size (i);
					     cobol_$fs_charcnt =
						cobol_$fs_charcnt + same_rec_area_info.cra_size (i);

					end;

				     file_table.cra_seg = same_rec_area_info.seg_num (i);
				     file_table.cra_offset = same_rec_area_info.offset (i);

				end;
			     else do;

				     file_table.cra_seg = record_segment;
				     file_table.cra_offset = record_offset;
				     ddseg.next_offset = record_offset + file_table.max_cra_size;
				     cobol_$fs_charcnt = cobol_$fs_charcnt + file_table.max_cra_size;

				end;

			     if cobol_$fs_wdoff = 0
			     then cobol_$fs_wdoff = divide (file_table.cra_offset, 4, 35, 0);
			end;

		     call set_file_table;

		end;



	     call cobol_ntio$sget (dn_ptr, eof);
	     ;

	end;

	if procname_sw > 0
	then do;					/* output END COBOL. minpral */

		reswd.key = reswd_END;
		reswd.class = "000100010000100000010000000"b;

		call put_rw_token;

		reswd.key = reswd_COBOL;
		reswd.class = "000010000000000000010000000"b;

		call put_rw_token;

		reswd.key = reschar_PERIOD;
		reswd.class = "000100000000000000000000000"b;

		call put_rw_token;

	     end;

	con_wd_off = con_wd_off + 1;
	cobol_$cobol_data_wd_off = cobol_$cobol_data_wd_off + divide (ddseg.next_offset, 4, 35, 0) + 1;

	if cobol_$coms_wdoff = 0
	then cobol_$coms_wdoff = divide (ddseg.next_offset, 4, 35, 0);
	if cobol_$ws_wdoff = 0
	then cobol_$ws_wdoff = cobol_$coms_wdoff;
	if cobol_$fs_wdoff = 0
	then cobol_$fs_wdoff = cobol_$ws_wdoff;


	call cobol_vdwf_sput (cobol_ext_$cobol_cmfp, st, addr (ddseg), ddseg_size, fixed_common.seg_info);

	return;



set_file_table:
     proc;

	if (file_table.variable_recs | file_table.spanned_recs)
	     | (^file_table.fixed_recs & (file_table.unequal_recs | file_table.rec_do))
	then do;

		file_table.record_format = file_table.record_format + 100;
		file_table.variable = "1"b;

		if file_table.rec_max > 0
		then if file_table.rec_min = 0
		     then call issue_file_diag (warn_MIN_RECSIZE_MISSING);

	     end;

	if file_table.rec_max > 0
	then do;					/* RECORD CONTAINS specified */

		if ^file_table.rec_do
		then if file_table.rec_max ^= file_table.max_cra_size
		     then do;

			     call issue_file_diag (warn_RECSIZE_INCONSISTENT);

			     if file_table.rec_max > file_table.max_cra_size
			     then do;

				     call issue_file_diag (obs_CRASIZE_ADJUSTED);

				     file_table.max_cra_size = file_table.rec_max;

				end;
			     else do;

				     call issue_file_diag (obs_RECSIZE_ADJUSTED);

				     file_table.rec_max = file_table.max_cra_size;

				end;
			end;
	     end;

	if file_table.device = 5
	then do;					/* TAPE */

		if file_table.max_cra_size < 18
		then do;

			call issue_file_diag (warn_RECSIZE_TOO_SMALL);
			call issue_file_diag (obs_RECSIZE_ADJUSTED);

			file_table.max_cra_size = 18;

		     end;
		else do;

			if file_table.variable_recs
			then do;
				if file_table.max_cra_size > 8188
				then do;

					call issue_file_diag (warn_VLR_RECSIZE_EXCEEDED);
					call issue_file_diag (obs_RECSIZE_ADJUSTED);

					file_table.max_cra_size = 8188;

				     end;
			     end;
			else if file_table.spanned_recs
			then do;

				if file_table.max_cra_size > 1044480
				then do;

					call issue_file_diag (warn_SPANNED_RECSIZE_EXCEEDED);
					call issue_file_diag (obs_RECSIZE_ADJUSTED);

					file_table.max_cra_size = 1044480;

				     end;
			     end;
			else if file_table.max_cra_size > 8192
			then do;			/* FLR assumed */

				call issue_file_diag (warn_FLR_RECSIZE_EXCEEDED);
				call issue_file_diag (obs_RECSIZE_ADJUSTED);

				file_table.max_cra_size = 8192;

			     end;
		     end;

		if file_table.block_desc = 1
		then if file_table.block_max < 18
		     then do;

			     call issue_file_diag (warn_BLKSIZE_TOO_SMALL);
			     call issue_file_diag (obs_BLKSIZE_ADJUSTED);

			     file_table.block_max = 18;

			end;

		if file_table.block_desc = 1
		then do;				/* block size given in characters */

			if file_table.block_max < file_table.max_cra_size
			then if ^file_table.spanned_recs
			     then do;

				     call issue_file_diag (warn_BLKSIZE_LESS_THAN_RECSIZE);
				     call issue_file_diag (obs_BLKSIZE_ADJUSTED);

				     file_table.block_max = file_table.max_cra_size;

				end;
			     else ;
			else if file_table.fixed_recs
			then do;

				if mod (file_table.block_max, file_table.max_cra_size) ^= 0
				then do;

					call issue_file_diag (warn_BLKSIZE_NOT_MULT_OF_RECSIZE);
					call issue_file_diag (obs_BLKSIZE_ADJUSTED);

					file_table.block_max =
					     divide (file_table.block_max, file_table.max_cra_size, 35, 0)
					     * file_table.max_cra_size;

				     end;

			     end;
		     end;
	     end;
	else do;					/* not TAPE */

		if file_table.block_desc > 0
		then call issue_file_diag (obs_BLOCKING_IGNORED);

	     end;

	if (file_table.block_desc = 2 & file_table.block_max > 1)
	     | (file_table.block_desc = 1 & file_table.block_max > file_table.max_cra_size)
	then do;

		file_table.record_format = file_table.record_format + 1;
		file_table.blocked = "1"b;

	     end;

	file_table.record_format = file_table.record_format + 1;

	if file_table.device = 2 | file_table.device = 3
	then do;

		if file_table.max_cra_size > 80
		then call issue_fd_diag (warn_REC_EXCEEDS_DEVICE_LIMIT);

	     end;

	else if file_table.device = 1
	then do;					/* PRINTER */

		if file_table.max_cra_size > 132
		then call issue_fd_diag (warn_REC_EXCEEDS_DEVICE_LIMIT);

	     end;

     end set_file_table;



put_rw_token:
     proc;

	call cobol_swf_put (cobol_ext_$cobol_m2fp, st, addr (reswd), reswd.size);

     end put_rw_token;



set_size:
     proc;

dcl	rec_off		fixed bin;
dcl	next_rec_off	fixed bin;
dcl	cur_lev		fixed bin;
dcl	occ_lev		fixed bin;
dcl	sign_lev		fixed bin;
dcl	(n, fill)		fixed bin;

dcl	code_set_sw	bit (1);
dcl	sync_bits		bit (5) unal based;
dcl	(comp7_sync, comp8_sync)
			bit (1);

dcl	(N, R)		ptr;

	comp7_sync, comp8_sync = "0"b;
	rec_off, next_rec_off, occ_lev, n = 0;


	code_set_sw = "0"b;

	if current_fno > 0
	then code_set_sw = file_table.code_set_clause;

	cur_lev = 1;
	sign_lev = 0;
	stk.son_cnt (0) = 0;
	stk.level (0) = 0;
	stk.offset (1) = 0;

/*[5.1-1]*/
	addr (stk_occurs (0)) -> bit100 = "0"b;


	do while (cur_lev > 0);

	     /***.....if Trace_Bit="1"b/**/
	     /***.....then do;/**/
	     /***.....   call ioa_("^a(^d)",substr(Trace_Line,1,Trace_Lev),cur_lev);/**/
	     /***.....   Trace_Lev=Trace_Lev+3;/**/
	     /***.....     end;/**/
/* PUSH */

	     do while (cur_lev > stk.level (n));


		n = n + 1;
		/***.....   if Trace_Bit="1"b then call ioa_("^a(^d)^p",substr(Trace_Line,1,Trace_Lev),n,N);/**/

		stk.son_cnt (n), stk.init_slack (n) = 0;
		stk.son_cnt (n - 1) = stk.son_cnt (n - 1) + 1;
		stk.nt_ptr (n) = dn_ptr;
		addr (data_name.bitt) -> sync_bits = ""b;
		stk.level (n) = data_name.level;

		if data_name.non_elementary
		then if n = 1
		     then do;

			     data_name.double_word = "1"b;
			     stk.bound (1) = 16;

			end;
		     else do;			/* non-elementary with level greater than 01 */

			     data_name.byte = "1"b;
			     stk.bound (n) = 2;

			end;

		else do;				/* elementary */

			if code_set_sw
			then if ^data_name.display | (data_name.item_signed & ^data_name.sign_separate)
			     then call issue_diag (warn_CODE_SET_VIOLATION, dn_ptr);

			if data_name.numeric & data_name.item_signed
			then if n > sign_lev
			     then sign_lev = n;

			stk.size (n) = data_name.item_length * 2;

			if data_name.display | data_name.comp | data_name.ascii_packed_dec
			then do;

				data_name.byte = "1"b;
				stk.bound (n) = 2;

			     end;
			else if data_name.ascii_packed_dec_h
			then do;

				data_name.ascii_packed_dec = "1"b;

				if data_name.sync | comp8_sync
				then do;		/* either this or last one */

					data_name.byte = "1"b;
					stk.bound (n) = 2;

				     end;
				else do;

					data_name.bitt = "1"b;
					stk.bound (n) = 1;

				     end;

				stk.size (n) = data_name.places_left + data_name.places_right;

				if data_name.item_signed
				then do;

					stk.size (n) = stk.size (n) + 1;
					data_name.sign_type = "100"b;
						/* leading separate */

				     end;
			     end;

			else if data_name.bin_18
			then do;

				if data_name.sync
				then do;

					data_name.word = "1"b;
					stk.bound (n) = 8;
					comp7_sync = "1"b;
						/* indicate offset adj needed */
					stk.size (n) = 8;
						/* allocate full word */

				     end;
				else do;

					data_name.half_word = "1"b;
					stk.bound (n) = 4;

				     end;
			     end;
			else if data_name.usage_index
			then do;

				data_name.double_word = "1"b;
				stk.bound (n) = 16;

			     end;
			else do;			/* bin_36 or anything else	*/

				data_name.word = "1"b;
				stk.bound (n) = 8;

			     end;

			if n = 1
			then do;

				addr (data_name.bitt) -> sync_bits = ""b;
						/* undo any previous determination */
				data_name.double_word = "1"b;
						/* in case of redefinition or argument usage */
				stk.bound (n) = 16;

			     end;
		     end;

		if ^data_name.non_elementary & (data_name.level = 01 | data_name.level = 77)
		then do;

			cur_lev = 0;
			call GET;

		     end;
		else do;




			stk.max_bound (n) = stk.bound (n);

			if data_name.exp_redefining
			then do;

/*[3.0-2]*/
				stk.son_cnt (n - 1) = stk.son_cnt (n - 1) - 1;
				rec_off = stk.redef_offset (n);

			     end;

/*[5.1-1]*/
			else stk.redef_offset (n) = rec_off;








			temp_mod = mod (rec_off, stk.bound (n));

			if temp_mod > 0
			then do;

/*[5.1-1]*/
				stk.init_slack (n) = stk.bound (n) - temp_mod;
						/*[5.1-1]*/
				rec_off = rec_off + stk.init_slack (n);

				if data_name.sync
				then temp = obs_EXPLICIT_SYNC;
				else if comp8_sync
				then temp = obs_PREVIOUS_SYNC;
				else do;

					if data_name.non_elementary
					then temp = obs_IMPLICIT_SYNC_FOR_GROUP;
					else if data_name.display
					then temp = obs_IMPLICIT_SYNC_FOR_DISPLAY;
					else temp = obs_IMPLICIT_SYNC;

				     end;

				call issue_diag (temp, dn_ptr);

			     end;

/*[5.1-1]*/
			if hisi_slack		/*[5.1-1]*/
			then do;
				if data_name.elementary
						/*[5.1-1]*/
				then do;
					stk.offset (n) = rec_off;
						/*[5.1-1]*/
					data_name.offset = divide (rec_off, 2, 35, 0);
						/*[5.1-1]*/
					m = n - 1;

/*[5.1-1]*/
					if m > 0
					then call inherit_offset;
						/*[5.1-1]*/
				     end;

/*[5.1-1]*/
			     end;			/*[5.1-1]*/
			else do;

				stk.offset (n) = rec_off;
				data_name.offset = divide (rec_off, 2, 35, 0);

/*[5.1-1]*/
			     end;

			if mod (rec_off, 2) = 1
			then data_name.bit_offset = "0101"b;
			else data_name.bit_offset = "0000"b;




			stk_occurs (n) = "0"b;	/* set only for explicit occurs */

			if data_name.occurs_ptr ^= 0
			then do;

				stk.occ_ptr (n), occurs_ptr = addr (nt_array (data_name.occurs_ptr));

				if occurs.dimensions > occ_lev
				then do;

					occ_lev = occ_lev + 1;
					stk_occurs (n) = "1"b;

					if occurs.level.max (occurs.dimensions) > 0
					then stk.max_occ (n) = occurs.level.max (occurs.dimensions);
					else stk.max_occ (n) = occurs.level.min (occurs.dimensions);

				     end;
			     end;

			if data_name.ascii_packed_dec_h & data_name.sync
			then comp8_sync = "1"b;	/* indicate NEXT item must be byte aligned */
			else comp8_sync = "0"b;

			found = "0"b;

			do while (cur_lev > 0 & ^found);

			     call GET;

			     if eof ^= 0
			     then cur_lev = 0;
			     else if data_name.type = 12 | data_name.type = 16
			     then cur_lev = 0;
			     else if data_name.type = 9
			     then do;

				     if data_name.level = 01 | data_name.level = 66 | data_name.level = 77
				     then cur_lev = 0;
				     else do;

					     found = "1"b;
					     cur_lev = data_name.level;

					end;

				end;
			end;

		     end;

		if comp7_sync
		then do;

			stk.nt_ptr (n) -> data_name.offset = stk.nt_ptr (n) -> data_name.offset + 2;
			comp7_sync = "0"b;

		     end;
	     end;

	     /***.....if Trace_Bit="1"b then Trace_Lev=Trace_Lev-3;/**/

	     do while (cur_lev <= stk.level (n) & n > 0);
		N = stk.nt_ptr (n);
		/***.....if Trace_Bit="1"b/**/
		/***..... then do;/**/
		/***.....   call ioa_("^a^a^x^d",substr(Trace_Line,1,Trace_Lev),"LEVEL:",cur_lev);/**/
		/***.....   call ioa_("^a(^d)^p",substr(Trace_Line,1,Trace_Lev),n,N);/**/
		/***.....      end;/**/

		if N -> data_name.non_elementary
		then do;

			temp_size = rec_off - stk.offset (n);
			temp_size = temp_size + mod (temp_size, 2);

			N -> data_name.item_length = divide (temp_size, 2, 35, 0);


			if n < sign_lev
			then N -> data_name.item_signed = "1"b;

/* contains signed data */

			N -> data_name.son_cnt = substr (unspec (stk.son_cnt (n)), 21, 16);

		     end;

		else temp_size = stk.size (n);

		if stk_occurs (n)
		then do;



			temp_mod = mod (temp_size, stk.max_bound (n));

			if temp_mod > 0
			then do;

/*[5.1-1]*/
				fill = stk.max_bound (n) - temp_mod;
				temp_size = temp_size + fill;

				call issue_diag (obs_IMPLICIT_SYNC_IN_ARRAY, stk.nt_ptr (n));

			     end;			/*[5.1-1]*/
			else fill = 0;

			occurs_ptr = stk.occ_ptr (n);
			occurs.level.struc_length (occurs.dimensions) = temp_size;

			rec_off = rec_off + temp_size * (stk.max_occ (n) - 1);

			if ^N -> data_name.non_elementary
			then rec_off = rec_off + temp_size;
						/* add size of one more element */
						/*[5.1-1]*/
			else rec_off = rec_off + mod (rec_off, 2) + fill;


/*[3.0-1]*/
			temp_size = temp_size * stk.max_occ (n);

/*[5.1-1]*/
			if hisi_slack		/*[5.1-1]*/
			then N -> data_name.item_length = N -> data_name.item_length + divide (fill, 2, 31, 0);
						/*[5.1-1]*/
			else rec_off = rec_off - fill;

			occ_lev = occ_lev - 1;

		     end;
		else if ^N -> data_name.non_elementary
		then rec_off = rec_off + temp_size;
		else rec_off = rec_off + mod (rec_off, 2);

/* integral number of bytes in all groups */


		stk.max_bound (n - 1) = max (stk.max_bound (n - 1), stk.max_bound (n));

		if N -> data_name.exp_redefining
		then do;

			R = stk.redef_ptr (n);	/*[5.1-1]*/
			temp_size = temp_size + stk.init_slack (n);




			if R ^= null ()		/* possible only if error in source */
			then if n = 1		/* level 01 */
			     then if temp_size > stk.redef_size (n)
				then if R -> data_name.file_num = 0
				     then do;

					     call issue_diag (obs_GREATER_SIZE_REDEFINES, N);

					     R -> data_name.max_red_size =
						max (R -> data_name.max_red_size, N -> data_name.item_length);

					end;

				     else ;	/* size greater,but in a file - OK */

				else ;		/* size unequal,but not greater - OK */

			     else do;		/* not a level 01 - an error in any case */

				     if rec_off ^= stk.next_rec_off (n)
				     then call issue_diag (warn_UNEQUAL_SIZE_REDEFINES, stk.nt_ptr (n));

				     if rec_off > stk.next_rec_off (n)
				     then call issue_diag (obs_ALLOC_ADJUSTED, stk.redef_ptr (n));

				     rec_off, stk.next_rec_off (n) = max (rec_off, stk.next_rec_off (n));




				end;



		     end;

/*[5.1-1]*/
		else do;
			stk.next_rec_off (n) = rec_off;

			stk.redef_size (n) = temp_size;
			N -> data_name.max_red_size = N -> data_name.item_length;

			if stk_occurs (n)
			then stk.redef_ptr (n) = null ();
			else stk.redef_ptr (n) = N;

/*[5.1-1]*/
		     end;

		n = n - 1;
		/***.....if Trace_Bit="1"b/**/
		/***.....  then do;/**/
		/***.....   if N->data_name.bit_offset=""b then Off="BYTE OFFSET:"; else Off="DIGIT OFFSET:";/**/
		/***.....   call ioa_$nnl("^a^a^x^a^x^a^x^d^x",substr(Trace_Line,1,Trace_Lev)/**/
		/***.....                       ,"NAME:",substr(N->data_name.name,1,N->data_name.name_size)/**/
		/***.....                         ,Off,N->data_name.offset);/**/
		/***.....   call ioa_("^a^x^d","SIZE:",N->data_name.item_length);/**/
		/***.....       end;/**/
	     end;

	end;

     end set_size;

/*[5.1-1]*/



inherit_offset:
     proc;

declare	(off, stk_off)	fixed bin,
	p		ptr;
declare	OFF		fixed bin based (p);

	off = data_name.offset;
	stk_off = 2 * off;

	do while ("1"b);

	     p = addr (stk.nt_ptr (m) -> data_name.offset);

	     if OFF < 0
	     then do;
		     OFF = off;
		     stk.offset (m) = stk_off;
		end;
	     else return;

	     m = m - 1;

	     if m = 0
	     then return;

	end;

     end;

GET:
     proc;

	call cobol_ntio$sget (dn_ptr, eof);

	if hisi_slack & eof = 0
	then if data_name.type = 9 & data_name.non_elementary
	     then do;
		     data_name.offset = -1;
		     data_name.item_length = 0;
		end;

     end;

/*[5.1-1]*/



test_occurs:
     proc;

/* test_occurs maintains the occurs_info table and checks the current data item to see if it is
subscripted.  if it is,the OCCURS extension for the item is updated.  if the item has an
explicit OCCURS clause(rather than simply being subordinate to an OCCURring item),a
compute-subscript-word is allocated for the clause; and a new entry is added to the occurs_info
table so that items subordinate to the new OCCURS clause can be properly patched */

start_test_occurs:
	if occurs_level = 0
	then go to test_item;			/* go if no entries in occurs_info table */

	if data_name.level > occurs_info.level (occurs_level)
	then go to test_item;

/* all current entries
		in occurs_info table must still apply to current item if this condition is met */

	occurs_level = occurs_level - 1;

	go to start_test_occurs;

test_item:
	if data_name.subscripted = "0"b
	then return;

/* set occurs_ptr to point to OCCURS extension for current item */

	occurs_ptr = addr (nt_array (data_name.occurs_ptr));

/* go to update_occ_ext if this item does not have an explicit OCCURS clause */

	if occurs.dimensions ^> occurs_level
	then go to update_occ_ext;

/* add new entry in occurs_info table for this item's OCCURS clause */

	occurs_level = occurs_level + 1;
	occurs_info.level (occurs_level) = data_name.level;
	occurs_info.struclength (occurs_level) = occurs.level.struc_length (occurs.dimensions);

/* occurs.level.struc_length of minor /* occurs.level filled by set_size,if set_size
			 is executed for this record.  Otherwise the value is left from ddsyntax */

	if data_name.occurs_do = "0"b
	then go to update_occ_ext;

	call odo_item;				/* generate size routine for this item */

	if data_name.linkage_section = "1"b
	then go to link_odo;

	odo_rec_ptr -> odo_rec.seg_no = record_segment;
	odo_rec_ptr -> odo_rec.offset_l = data_name.offset + record_offset;

	odo_rec_ptr -> odo_rec.offset_r =
	     odo_rec_ptr -> odo_rec.offset_l
	     + divide (occurs.level.struc_length (occurs.dimensions), 2, 35, 0)
	     * (occurs.level.max (occurs.dimensions) - 1) + data_name.item_length - 1;

	go to replace_odo_rec;

link_odo:
	odo_rec_ptr -> odo_rec.seg_no = fixed_common.number_of_ls_pointers + 20000;

/* add 20000 to identify link sec item */

	odo_rec_ptr -> odo_rec.offset_l = data_name.offset;
	odo_rec_ptr -> odo_rec.offset_r =
	     data_name.offset
	     + divide (occurs.level.struc_length (occurs.dimensions), 2, 35, 0)
	     * (occurs.level.max (occurs.dimensions) - 1) + data_name.item_length - 1;

replace_odo_rec:
	call cobol_vdwf_dput (cobol_ext_$cobol_cmfp, st, odo_rec_ptr, odo_recsize, odo_key);


update_occ_ext:
	do i = 1 to occurs.dimensions;
	     occurs.level.struc_length (i) = occurs_info.struclength (i);
	end;

/*	
call cobol_vdwf_dput(cobol_ext_$cobol_name_fileno,st,dn_ptr,name_recsize,name_key);  */

     end test_occurs;




variable_size:
     proc;

/* variable_size is 
called when a variable-length item is encountered during the second pass

(allocation pass) over the name table.  If the item has variable length because it contains an
OCCURS  DEPENDING ON item,the procedure number of the appropriate size routine is filled into
the size_rtn field in the name table entry for the variable-length item.  If the item has
variable length because it has a PICTURE  DEPENDING ON clause,its size routine is created
in the minpral-2 file.  The size routine generated for a PICTURE  DEPENDING ON item consists
of a paragraph header followed by the statement IF DO-item < 1 OR DO-item > max-item-size
DISPLAY "out-of-range depending on item" ELSE SUBTRACT DO-item FROM max-item-size GIVINGresult-field */

/*	if ^data_name.pic_has_l then do;	*/

	if odo_proc_num = 0
	then do;

		fixed_common.spec_tag_counter = fixed_common.spec_tag_counter + 1;
		odo_proc_num = fixed_common.spec_tag_counter;
		odo_do_rec = data_name.do_rec;	/* save key in common of odo_rec entry for this item */

	     end;

	data_name.size_rtn = odo_proc_num;		/* set with procno of size rtn to be generated */

/**/
/*	end;
/*	else do;					/* picture has L */
/*		
call gen_true_path(0);			/* generate first half of IF statement */

/*		reswd.key = reswd_SUBTRACT;
/*		reswd.class = "100100000000000000110000000"b;
/*		
call put_rw_token;

/*
/*		
call issue_name;

/*
/*		reswd.key = reswd_FROM;
/*		reswd.class = "000000000000000000110000000"b;
/*		
call put_rw_token;

/* 
/*		
call bin_to_dec(data_name.item_length,sizertn_numlit.literal,sizertn_numlit.places);

/*		sizertn_numlit.size = numlit_size + sizertn_numlit.places;
/*		sizertn_numlit.places_left = sizertn_numlit.places;
/*		
call cobol_swf_put(cobol_ext_$cobol_m2fp,st,addr(numlit),numlit.size);

/* 
/*		reswd.key = reswd_GIVING;
/*		reswd.class = "000000000000000000010000000"b;
/*		
call put_rw_token;

/* 
/*		
call cobol_swf_put(cobol_ext_$cobol_m2fp,st,addr(sizedn),sizedn.size);

/*
/*		reswd.key = reschar_PERIOD;
/*		reswd.class = "000100000000000000000000000"b;
/*		
call put_rw_token;

/*	end;
/**/
	return;

     end variable_size;




odo_item:
     proc;

/* odo_item generates the size routine needed for an OCCURS  DEPENDING ON item.  The size routine
	generated for an OCCURS  DEPENDING ON item consists of a paragraph header followed by the
	statement IF DO-item < minimum-number-of-occurrences OR DO-item > maximum-number-of-occurrences
	DISPLAY "out-of-range depending on item" ELSE COMPUTE result-field EQUALS structure-length *
				(maximum-number-of-occurrences - DO-item). */

	call gen_true_path (1);


	reswd.key = reswd_COMPUTE;
	reswd.class = "100100100000000000110000000"b;

	call put_rw_token;



	call cobol_swf_put (cobol_ext_$cobol_m2fp, st, addr (sizedn), sizedn.size);


	reswd.key = reswd_EQUALS;			/*[4.2-3]*/
	reswd.class = "000001100000000000011000000"b;

	call put_rw_token;


	call bin_to_dec (divide (occurs.level.struc_length (occurs.dimensions), 2, 24, 0), sizertn_numlit.literal,
	     sizertn_numlit.places);
	sizertn_numlit.size = numlit_size + sizertn_numlit.places;
	sizertn_numlit.places_left = sizertn_numlit.places;

	call cobol_swf_put (cobol_ext_$cobol_m2fp, st, addr (sizertn_numlit), sizertn_numlit.size);


	reswd.key = reschar_STAR;
	reswd.class = "010000000000000000000000000"b;

	call put_rw_token;


	reswd.key = reschar_LPARENS;
	reswd.class = "000000000000000000000000000"b;

	call put_rw_token;



	call bin_to_dec (occurs.level.max (occurs.dimensions), sizertn_numlit.literal, sizertn_numlit.places);

	sizertn_numlit.size = numlit_size + sizertn_numlit.places;
	sizertn_numlit.places_left = sizertn_numlit.places;

	call cobol_swf_put (cobol_ext_$cobol_m2fp, st, addr (sizertn_numlit), sizertn_numlit.size);


	reswd.key = reschar_MINUS;
	reswd.class = "010000000000000000000000000"b;

	call put_rw_token;



	call issue_name;				/* write out name of DEPENDING ON item */


	reswd.key = reschar_RPARENS;
	reswd.class = "000000000000000000000000000"b;

	call put_rw_token;


	reswd.key = reschar_PERIOD;
	reswd.class = "000100000000000000000000000"b;

	call put_rw_token;


	return;

     end odo_item;



gen_true_path:
     proc (calling_param);



/* gen_true_path generates the first part of the size routine produced for a variable-length item,
	consisting of the true path of the appropriate IF statement(see pic_l_item and odo_item). */


dcl	calling_param	fixed bin;


start_gen_true_path:				/**/
						/*	if 
calling_param = 0 then odo_key = data_name.do_rec;  /* picture has L */
						/*	else  */
	odo_key = odo_do_rec;			/* record contains depending on */

	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, st, odo_rec_ptr, odo_recsize, odo_key);


	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, st, depend_ptr, common_recsize, odo_rec_ptr -> odo_rec.descr);


/**/
/*	if 
	calling_param = 0 then do;

/*		fixed_common.spec_tag_counter = fixed_common.spec_tag_counter + 1;
/*		data_name.size_rtn = fixed_common.spec_tag_counter;
/*		
	call cobol_vdwf_dput(cobol_ext_$cobol_name_fileno,st,dn_ptr,name_recsize,name_key);

/*		procdef.proc_num = fixed_common.spec_tag_counter;
/*	end;
/*	else */

	procdef.proc_num = odo_proc_num;

	call cobol_swf_put (cobol_ext_$cobol_m2fp, st, addr (procdef), procdef.size);
						/* write paragraph name */

/*[4.2-3]*/
	reswd.key = reschar_PERIOD;
	reswd.class = "0001"b;			/*[4.2-3]*/

	call put_rw_token;

/* add paragraph name to list of performed procedures */
	perform_ptr = addr (work_area);
	perform_entry.proc_number = procdef.proc_num;
	perform_entry.code = 0;
	perform_entry.next = "00000";
	perform_entry.next1 = "00000";
	perform_entry.priority = 0;
	perform_entry.address = 0;

	call cobol_vdwf_sput (cobol_ext_$cobol_cmfp, st, perform_ptr, perform_size, common_key);

	if fixed_common.size_perform_info = "00000"
	then fixed_common.size_perform_info = common_key;
	else do;

		call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, st, work_ptr, common_recsize, last_perform_key);

		work_ptr -> perform_entry.next = common_key;

		call cobol_vdwf_dput (cobol_ext_$cobol_cmfp, st, work_ptr, common_recsize, last_perform_key);

	     end;

	last_perform_key = common_key;

	if fixed_common.options.oc
	then do;					/* generate code to check result */

		reswd.key = reswd_MOVE;
		reswd.class = "100100100000000000110000000"b;

		call put_rw_token;


		reswd.key = reswd_ZERO;
		reswd.class = "001000000000000000010000000"b;
		reswd.jump_index = 1;

		call put_rw_token;

		reswd.jump_index = 0;

		reswd.key = reswd_TO;
		reswd.class = "000000000000000000010000000"b;

		call put_rw_token;



		call cobol_swf_put (cobol_ext_$cobol_m2fp, st, addr (sizedn), sizedn.size);


		reswd.key = reswd_IF;
		reswd.class = "100100000000000000010000000"b;

		call put_rw_token;



		call issue_name;


		reswd.key = reschar_LT;		/*[4.2-3]*/
		reswd.class = "000011000000000000000000000"b;

		call put_rw_token;


/**/
/*		if 
calling_param = 0 then do;

/*		sizertn_numlit.size = numlit_size + 1;
/*		sizertn_numlit.places_left = 1;
/*		sizertn_numlit.places = 1;
/*		sizertn_numlit.literal = "1";
/*		end;
/*		else do;
/**/

		call bin_to_dec (occurs.level.min (occurs.dimensions), sizertn_numlit.literal, sizertn_numlit.places);

		sizertn_numlit.size = numlit_size + sizertn_numlit.places;
		sizertn_numlit.places_left = sizertn_numlit.places;
						/*		end;  */


		call cobol_swf_put (cobol_ext_$cobol_m2fp, st, addr (sizertn_numlit), sizertn_numlit.size);


		reswd.key = reswd_OR;
		reswd.class = "000000000000000000010000000"b;

		call put_rw_token;



		call issue_name;


		reswd.key = reschar_GT;		/*[4.2-3]*/
		reswd.class = "000011000000000000000000000"b;

		call put_rw_token;



		call bin_to_dec (occurs.level.max (occurs.dimensions), sizertn_numlit.literal, sizertn_numlit.places);

		sizertn_numlit.size = numlit_size + sizertn_numlit.places;
		sizertn_numlit.places_left = sizertn_numlit.places;

		call cobol_swf_put (cobol_ext_$cobol_m2fp, st, addr (sizertn_numlit), sizertn_numlit.size);


		reswd.key = reswd_STOP;
		reswd.class = "100100100000000000110000000"b;

		call put_rw_token;



		call cobol_swf_put (cobol_ext_$cobol_m2fp, st, addr (errormes_lit), errormes_lit.size);


		reswd.key = reswd_ELSE;
		reswd.class = "000000000000000000010000000"b;

		call put_rw_token;

	     end;
     end gen_true_path;



issue_name:
     proc;

/* issue_name is 
called during generation of a size routine for a variable-length item.  issue_name

writes the name of the DEPENDING ON item,including any specified qualifiers,out to the minpral-2 file. */

	usrwd.size = usrwd_size + depend_ptr -> obj_rec.size;
	usrwd.length = depend_ptr -> obj_rec.size;
	usrwd.word = substr (depend_ptr -> obj_rec.name, 1, depend_ptr -> obj_rec.size);

	call cobol_swf_put (cobol_ext_$cobol_m2fp, st, addr (usrwd), usrwd.size);



	if depend_ptr -> obj_rec.qual = "00000"
	then return;


	call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, st, qual_ptr, common_recsize, depend_ptr -> obj_rec.qual);


	reswd.key = reswd_OF;
	reswd.class = "000000000000000000010000000"b;

	do while ("1"b);


	     call put_rw_token;			/* write out OF key */


	     usrwd.size = usrwd_size + qual_ptr -> qual_rec.size;
	     usrwd.length = qual_ptr -> qual_rec.size;
	     usrwd.word = substr (qual_ptr -> qual_rec.name, 1, qual_ptr -> qual_rec.size);


	     call cobol_swf_put (cobol_ext_$cobol_m2fp, st, addr (usrwd), usrwd.size);


/* write out qualifier */

	     if qual_ptr -> qual_rec.next = "00000"
	     then return;


	     call cobol_vdwf_dget (cobol_ext_$cobol_cmfp, st, qual_ptr, common_recsize, qual_ptr -> qual_rec.next);


	end;

     end issue_name;




/* bin_to_dec converts the value in a 15-bit fixed binary field to its decimal equivalent. */

b_to_d:
     entry (btd_i, btd_o, btd_s);

dcl	btd_i		fixed bin;
dcl	btd_o		char (5);
dcl	btd_s		fixed bin;


	call bin_to_dec (btd_i, btd_o, btd_s);

	return;



bin_to_dec:
     proc (bd_input, bd_output, bd_size);

dcl	bd_input		fixed bin;
dcl	bd_output		char (5);
dcl	bd_size		fixed bin;
dcl	bd_work1		fixed bin;
dcl	bd_work2		fixed bin;
dcl	result		char (4) based (addr (bd_work2));
dcl	bd_work3		char (5);
dcl	loc		fixed bin;

	loc = 6;

	if bd_input = 0
	then do;

		bd_size = 1;
		bd_output = "0";
		return;

	     end;

	bd_work1 = bd_input;

	do while (bd_work1 > 0);

	     bd_work2 = mod (bd_work1, 10) + 48;
	     loc = loc - 1;
	     substr (bd_work3, loc, 1) = substr (result, 4, 1);
	     bd_work1 = divide (bd_work1, 10, 15, 0);
	end;

	bd_size = 6 - loc;
	bd_output = substr (bd_work3, loc);

     end bin_to_dec;




issue_fd_diag:
     proc (diag_no);

dcl	diag_no		fixed bin;

	diag.line = dn_ptr -> fd_token.def_line;
	diag.column = 8;
	diag.number = diag_no;

	call cobol_c_list (addr (diag));		/* issue diagnostic */

     end issue_fd_diag;

issue_file_diag:
     proc (diag_no);

dcl	diag_no		fixed bin;

	diag.line = dn_ptr -> fd_token.line;
	diag.column = dn_ptr -> fd_token.column;
	diag.number = diag_no;

	call cobol_c_list (addr (diag));

     end issue_file_diag;

issue_diag:
     proc (diag_no, dn_ptr);

dcl	diag_no		fixed bin;
dcl	dn_ptr		ptr;

	diag.line = dn_ptr -> data_name.line;
	diag.column = dn_ptr -> data_name.column;
	diag.number = diag_no;

	call cobol_c_list (addr (diag));

     end issue_diag;



mc_initval_seg2:
     proc;

/* This procedure will generate tokens to a separate minpral file
				for initial value non-constant items during a MCOBOL run.
			*/

dcl	keyindex		(7) fixed bin;

	keyindex (1) = reswd_ZERO;
	keyindex (2) = reswd_SPACE;
	keyindex (3) = 999;				/* upper-bound */
	keyindex (4) = 999;				/* lower-bound */
	keyindex (5) = reswd_HIGH_VALUE;
	keyindex (6) = reswd_LOW_VALUE;
	keyindex (7) = reswd_QUOTE;

	valueptr = addr (dn (data_name.initial_ptr));
	cobol_$data_init_flag = cobol_$data_init_flag + 1;/* current count of Cobol data items to be initialized */
	reswd.key = reswd_MOVE;
	reswd.class = "100100100000000000110000000"b;



	call cobol_swf_put (cobol_$initval_file_ptr, st, addr (reswd), reswd.size);
						/*write key */


	if data_name.value_numeric
	then do;					/* numeric literal */

		numlit.size = numlit_size + numinit.length;
						/* type 2 numeric value */
		numlit.places = numinit.length;
		numlit.places_left = numinit.ltdp;
		substr (numlit.literal, 1, numinit.length) = substr (numinit.literal, 1, numinit.length);
		numlit.info = string (numinit.info);
		numlit.sign = numinit.sign;
		numlit.exp_sign = numinit.expsign;
		numlit.exp_places = numinit.explaces;
		numlit.places_right = numinit.rtdp;


		call cobol_swf_put (cobol_$initval_file_ptr, st, addr (numlit), numlit.size);


	     end;

	else if alphainit.info.figconindex ^= "0000000"b
	then do;					/* figurative constant */

		reswd.key = keyindex (fixed (alphainit.info.figconindex, 18));
		reswd.class = "101000000000000000000000000"b;
		reswd.jump_index = 1;


		call cobol_swf_put (cobol_$initval_file_ptr, st, addr (reswd), reswd.size);


		reswd.jump_index = 0;

	     end;
	else do;					/* nonnumeric literal */

		nonnumlit.size = nonnumlit_size + alphainit.length;
		nonnumlit.length = alphainit.length;

		substr (nonnumlit.string, 1, alphainit.length) = substr (alphainit.string, 1, alphainit.length);

		if alphainit.allit = "1"b
		then nonnumlit.info = "01000000"b;
		else nonnumlit.info = "00000000"b;


		call cobol_swf_put (cobol_$initval_file_ptr, st, addr (nonnumlit), nonnumlit.size);


	     end;

/*[4.2-1]*/
	sv_bit = data_name.just_right;
	data_name.just_right = "0"b;

	if data_name.numeric ^= "1"b
	then do;

		valhd_ptr = addr (data_name.numeric);
		valhd = substr (valhd_ptr -> valhd_based, 1, 6);
		substr (valhd_ptr -> valhd_based, 1, 6) = "001000"b;
		valhdbit = data_name.variable_length;
		data_name.variable_length = "0"b;


		call cobol_swf_put (cobol_$initval_file_ptr, st, dn_ptr, data_name.size);


		data_name.variable_length = valhdbit;
		substr (valhd_ptr -> valhd_based, 1, 6) = valhd;

	     end;
	else call cobol_swf_put (cobol_$initval_file_ptr, st, dn_ptr, data_name.size);


/*[4.2-1]*/
	data_name.just_right = sv_bit;

	do ieos = 1 to 10;				/* initialize EOS token to zeros */
						/*MCO*/

	     eos_token (ieos) = 0;

dcl	ieos		fixed bin (24);

	end;

	eos_ptr = addr (eos_token);
	end_stmt.type = 19;
	end_stmt.verb = 18;
	end_stmt.e = 1;
	end_stmt.size = 38;


	call cobol_swf_put (cobol_$initval_file_ptr, st, eos_ptr, end_stmt.size);
						/* type19 EOS */


dcl	eos_token		(10) fixed bin (24);

     end mc_initval_seg2;

	/***.....	dcl Trace_Bit bit(1) static external;/**/
	/***.....	dcl Trace_Lev fixed bin static external;/**/
	/***.....	dcl Trace_Line char(60) static external;/**/
	/***.....	dcl ioa_ entry options(variable); /**/
	/***.....   dcl ioa_$nnl entry options(variable);/**/
	/***.....   dcl Off char(13);/**/

/*[4.2-1]*/
declare	sv_bit		bit (1);


dcl	temp_char5	char (5);
dcl	temp_size		fixed bin;
dcl	procname_sw	fixed bin;
dcl	temp		fixed bin;
dcl	eof		fixed bin;
dcl	temp_len		fixed bin (24);
dcl	temp_mod		fixed bin;
dcl	redef_object_offset fixed bin;
dcl	(curr_char_off, curr_wd_off, curr_char_pos)
			fixed bin;

dcl	cd_offsets	(-256:0) fixed bin;		/* 0 is invalid */

dcl	dn_ptr		ptr;			/* name table pointer */
dcl	com2_ptr		ptr;
dcl	valueptr		ptr;
dcl	valhd_ptr		ptr;
dcl	valhdbit		bit (1);
dcl	valhd		bit (6);
dcl	valhd_based	bit (6) based;
dcl	dn		(500) char (1) based (dn_ptr);
dcl	index_name_ptr	ptr;

dcl	ft_ptr		ptr;			/* pointer to current file table record in common */
dcl	save_red_nptr	ptr;
dcl	odo_rec_ptr	ptr;			/* pointer to odo_rec item */
dcl	depend_ptr	ptr;			/* pointer to obj_rec item */
dcl	qual_ptr		ptr;			/* pointer to qual_rec items in common */

dcl	1 rw_area,
	  2 dummy		(5) fixed bin,
	  2 verb		bit (27),
	  2 dummy1	fixed bin;

dcl	last_perform_key	char (5);
dcl	work_ptr		ptr;
dcl	name_ptr		ptr;
dcl	nt_buf		char (1000) based (dn_ptr);
dcl	nt_array		(1000) char (1) based (dn_ptr);
dcl	index_cnt		fixed bin;
dcl	index_ptr		(200) ptr;

dcl	1 same_rec_area_info
			(cobol_ext_$cobol_com_ptr -> fixed_common.sra_clauses),
	  2 clause_no	fixed bin,
	  2 cra_size	fixed bin (24),
	  2 seg_num	fixed bin,
	  2 offset	fixed bin (24);

dcl	1 occurs_info	(3),
	  2 level		fixed bin,
	  2 cswd_seg	fixed bin,
	  2 cswd_offset	fixed bin (24),
	  2 struclength	fixed bin;		/* character string work fields */
dcl	work_area		char (100);
dcl	index_area	char (120);
dcl	odo_key		char (5);
dcl	odo_do_rec	char (5);
dcl	common_recsize	fixed bin;
dcl	common_key	char (5);
dcl	name_recsize	fixed bin;
dcl	first_name_key	char (5) aligned;
dcl	file_key		char (5);
dcl	report_key	char (5);
dcl	group_key		char (5);
dcl	rec_offset	fixed bin (24);
dcl	record_offset	fixed bin (24);
dcl	temp_slack	fixed bin;
dcl	i		fixed bin;
dcl	occurs_level	fixed bin;
dcl	odo_proc_num	fixed bin;
dcl	odo_recsize	fixed bin;
dcl	ft_size		fixed bin;
dcl	current_fno	fixed bin;
dcl	st		bit (32);
dcl	(found, first_pop)	bit (1);

/*[5.1-1]*/
dcl	hisi_slack	bit (1),
	m		fixed bin;

/*[5.1-1]*/
dcl	bit32400		bit (32400) based,
	bit648		bit (648) based;		/*[5.1-1]*/
dcl	bit100		bit (100) based;

dcl	1 stk		(0:49),
	  2 nt_ptr	ptr,
	  2 redef_ptr	ptr,
	  2 occ_ptr	ptr,
	  2 level		fixed bin,
	  2 size		fixed bin,
	  2 offset	fixed bin,
	  2 bound		fixed bin,
	  2 max_bound	fixed bin,
	  2 max_occ	fixed bin,
	  2 redef_size	fixed bin,
	  2 son_cnt	fixed bin,		/*[5.1-1]*/
	  2 init_slack	fixed bin,		/*[5.1-1]*/
	  2 redef_offset	fixed bin,		/*[5.1-1]*/
	  2 next_rec_off	fixed bin;

/*[5.1-1]*/
dcl	1 STK		(0:49),
	  2 stk_occurs	bit (1),
	  2 redef_sw	bit (1);

dcl	1 procdef		static,
	  2 size		fixed bin init (53),
	  2 line		fixed bin init (0),
	  2 column	fixed bin init (0),
	  2 type		fixed bin init (7),
	  2 string_ptr	ptr init (null ()),
	  2 prev_rec	ptr init (null ()),
	  2 filler1	bit (4) init (""b),
	  2 section_name	bit (1),
	  2 filler2	bit (4) init (""b),
	  2 priority	char (2) init ("  "),
	  2 filler3	bit (9) init (""b),
	  2 section_num	fixed bin init (0),
	  2 proc_num	fixed bin,
	  2 def_line	fixed bin init (0),
	  2 name_size	fixed bin init (1),
	  2 name		char (1) init ("$");

dcl	1 reswd		static,
	  2 size		fixed bin init (28),
	  2 line		fixed bin init (0),
	  2 column	fixed bin init (0),
	  2 type		fixed bin init (1),
	  2 key		fixed bin,
	  2 class		bit (27),
	  2 jump_index	fixed bin;

dcl	1 diag		static,
	  2 size		fixed bin init (32),
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin init (5),
	  2 run		fixed bin init (2),
	  2 number	fixed bin,
	  2 info		bit (8) init (""b),
	  2 image_size	fixed bin init (0);

dcl	1 usrwd		static,
	  2 size		fixed bin,
	  2 line		fixed bin init (0),
	  2 column	fixed bin init (0),
	  2 type		fixed init (8),
	  2 info		bit (8) init (""b),
	  2 length	fixed bin,
	  2 word		char (30);

dcl	1 sizertn_numlit	static,
	  2 size		fixed bin,
	  2 line		fixed bin init (0),
	  2 column	fixed bin init (0),
	  2 type		fixed bin init (2),
	  2 info		bit (8) init ("10000000"b),
	  2 sign		char (1) init (" "),
	  2 exp_sign	char (1) init (" "),
	  2 exp_places	fixed bin init (0),
	  2 places_left	fixed bin,
	  2 places_right	fixed bin init (0),
	  2 places	fixed bin,
	  2 literal	char (5);

dcl	1 icdhdr_type9	static,
	  2 header	(4) fixed bin init (184, 0, 0, 9),
	  2 repl_ptr	(2) ptr init ((2) null ()),
	  2 fill1		bit (108) init (""b),
	  2 file_key_info,
	    3 fb1		(3) fixed bin init (0, 0, 0),
	    3 size	fixed bin init (60),
	    3 fb2		(2) fixed bin init (0, 0),
	    3 flags1	bit (36) init ("010000100100000000010000000100000000"b),
	    3 flags2	bit (36) init (""b),
	    3 seg		fixed bin init (2),
	    3 off		fixed bin,
	  2 init_ptr	fixed bin init (117),
	  2 edit_ptr	fixed bin init (0),
	  2 occurs_ptr	fixed bin init (0),
	  2 do_rec	char (5) init ("00000"),
	  2 fill2		bit (27) unal init (""b),
	  2 max_red_size	fixed bin init (0),
	  2 name_size	fixed bin init (4),
	  2 name		char (4) init ("IHDR"),
	  2 ext		bit (36) init ("01"b),
	  2 value_len	fixed bin init (60),
	  2 value,
	    3 qp		bit (72) init ("000111111111111111000000000000100011000000000000000001"b),
	    3 flags	bit (36) init ("11"b),
	    3 last_full_q_name
			char (48) init ("");

dcl	1 ocdhdr_type9	static,
	  2 header	(4) fixed bin init (144, 0, 0, 9),
	  2 repl_ptr	(2) ptr init ((2) null ()),
	  2 fill1		bit (108) init (""b),
	  2 file_key_info,
	    3 fb1		(3) fixed bin init (0, 0, 0),
	    3 size	fixed bin init (20),
	    3 fb2		(2) fixed bin init (0, 0),
	    3 flags1	bit (36) init ("010000100100000000010000000100000000"b),
	    3 flags2	bit (36) init (""b),
	    3 seg		fixed bin init (2),
	    3 off		fixed bin,
	  2 init_ptr	fixed bin init (117),
	  2 edit_ptr	fixed bin init (0),
	  2 occurs_ptr	fixed bin init (0),
	  2 do_rec	char (5) init ("00000"),
	  2 fill2		bit (27) unal init (""b),
	  2 max_red_size	fixed bin init (0),
	  2 name_size	fixed bin init (4),
	  2 name		char (4) init ("OHDR"),
	  2 ext		bit (36) init ("01"b),
	  2 value_len	fixed bin init (60),
	  2 value,
	    3 last_station_info_ptr
			bit (72) init ("000111111111111111000000000000100011000000000000000001"b),
	    3 flags	bit (36) init ("01"b),
	    3 binary_max_station_count
			fixed bin,
	    3 max_station_count
			char (4);

dcl	1 numlit		auto,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 info		bit (8),
	  2 sign		char (1),
	  2 exp_sign	char (1),
	  2 exp_places	fixed bin,
	  2 places_left	fixed bin,
	  2 places_right	fixed bin,
	  2 places	fixed bin,
	  2 literal	char (30);

dcl	1 nonnumlit	auto,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 info		bit (8),
	  2 length	fixed bin,
	  2 string	char (256);


dcl	1 ddseg		static,
	  2 next		char (5) init ("00000"),
	  2 seg_no	fixed bin init (2),
	  2 next_offset	fixed bin (24),
	  2 duplicate_next_loc
			fixed bin (24) init (0),
	  2 read_only	bit (1) init ("0"b);	/*~*/
dcl	record_segment	fixed bin static options (constant) init (2);
dcl	perform_size	fixed bin static options (constant) init (28);
dcl	usrwd_size	fixed bin static options (constant) init (24);
dcl	numlit_size	fixed bin static options (constant) init (36);
dcl	nonnumlit_size	fixed bin static options (constant) init (24);
dcl	ddseg_size	fixed bin static options (constant) init (21);

dcl	1 type25		static options (constant),
	  2 size		fixed bin init (53),
	  2 line		fixed bin init (0),
	  2 column	fixed bin init (0),
	  2 type		fixed bin init (25),
	  2 string_ptr	ptr init (null ()),
	  2 prev_rec	ptr init (null ()),
	  2 filler	bit (36) init (""b),
	  2 section_num	fixed bin init (0),
	  2 proc_num	fixed bin init (0),
	  2 def_line	fixed bin init (0),
	  2 name_size	fixed bin init (1),
	  2 name		char (1) init ("$");

dcl	1 errormes_lit	static options (constant),
	  2 size		fixed bin init (76),
	  2 line		fixed bin init (0),
	  2 column	fixed bin init (0),
	  2 type		fixed bin init (3),
	  2 info		bit (8) init (""b),
	  2 length	fixed bin init (52),
	  2 string	char (52) init ("Value of DEPENDING ON item is outside defined range.");

dcl	1 sizedn		static options (constant),
	  2 size		fixed bin init (113),
	  2 line		fixed bin init (0),
	  2 column	fixed bin init (0),
	  2 type		fixed bin init (9),
	  2 repl_ptr	(2) ptr init ((2) null ()),
	  2 fill1		bit (108) init (""b),
	  2 file_key_info,
	    3 fb1		(3) fixed bin init (0, 0, 0),
	    3 size	fixed bin init (4),
	    3 places_left	fixed bin init (11),
	    3 places_right	fixed bin init (0),
	    3 flags1	bit (36) init ("010000100100001001"b),
						/* ws,77,elem,bin36,num */
	    3 flags2	bit (36) init (""b),
	    3 seg		fixed bin init (2),
	    3 off		fixed bin init (0),
	  2 fill2		(6) fixed bin init (0, 0, 0, 0, 0, 0),
	  2 name_size	fixed bin init (1),
	  2 name		char (1) init ("$");

dcl	cobol_make_fsb_link_
			entry (ptr);
dcl	cobol_read_ft_	entry (fixed bin, ptr);
dcl	unique_bits_	entry returns (bit (70));
dcl	unique_chars_	entry (bit (*)) returns (char (15));
dcl	cobol_IVAL	entry (ptr);
dcl	cobol_vdwf_dput	entry (ptr, bit (32), ptr, fixed bin, char (5)) ext;
dcl	cobol_vdwf_dget	entry (ptr, bit (32), ptr, fixed bin, char (5)) ext;
dcl	cobol_swf_put	entry (ptr, bit (32), ptr, fixed bin) ext;
dcl	cobol_vdwf_sput	entry (ptr, bit (32), ptr, fixed bin, char (5)) ext;
dcl	cobol_ntio$sget	entry (ptr, fixed bin);
dcl	cobol_ntio$dget	entry (ptr, char (5) aligned);
dcl	cobol_c_list	entry (ptr);

dcl	(addr, addrel, divide, fixed, index, mod, null, string, substr, unspec, max)
			builtin;



/***************************************/
%include cobol_perform_entry;
%include cobol_obj_rec;
%include cobol_qual_rec;
%include cobol_odo_rec;
%include cobol_occurs_ext;
%include cobol_ext_num;
%include cobol_ext_nonnum;
%include cobol_ext_;
%include cobol_;
%include cobol_fixed_common;
%include cobol_file_table;
%include cobol_type9;
%include cobol_type10;
%include cobol_type12;
%include cobol_type13;
%include cobol_type19;
%include cobol_type20;
%include cobol_ddal_diag_values;
%include cobol_reswd_values;
%include cobol_size_values;
     end;
