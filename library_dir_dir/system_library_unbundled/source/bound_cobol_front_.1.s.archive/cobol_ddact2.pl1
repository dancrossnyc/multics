/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_ddact2.pl1 Reformatted code to new Cobol standard.
                                                   END HISTORY COMMENTS */


/* Modified on 11/24/81 by FCH, [5.1-1], RECORD CONTAINS may not contain ZERO, BUG520(phx11821) */
/* Modified on 07/22/81 by FCH, [4.4-1], set fixed_common.cd, BUG468 */
/* Modified on 08/11/79 by FCH, [4.0-1], debug statement added */
/* Modified on 04/14/78 by FCH, [3.0-2], fig con in level 88 item */
/* Modified on 04/12/78 by FCH, [3.0-1], include file change */
/* Modified since version 3.0 */


/* format: style3 */
cobol_ddact2:
     proc (an);

	sv_ptr_auto = cobol_sv_ptr;
	go to actlbl (an);

/* store condition names */

actlbl (150):					/*action(63):*/
	conditioname.name_size = user_word.word_size;
	substr (conditioname.name, 1, conditioname.name_size) = substr (user_word.word, 1, user_word.word_size);
	conditioname.size = conditioname.size + conditioname.name_size;

	conditioname.size = conditioname.size + mod (-conditioname.size, 4);

	save_ptr = ptr1;
	ptr1 = addr (w2_ptr -> any_item (conditioname.size + 1));
	conditioname.numlits = 0;
	save_ptr1 = null_func;			/*for compare_values*/
	go to retrn;				/* store numeric value for 88 entry */

actlbl (151):					/*action(64):*/
	conditioname.numlits = conditioname.numlits + 1;
	call store_nv;

store_nv:
     proc;

	numinit.initype.numeric = "1"b;
	if numeric_lit.rtdp = 0
	then numinit.info.integer = "1"b;
	numinit.info.floating = numeric_lit.info.floating;
	numinit.info.filler = numeric_lit.info.filler;
	numinit.expsign = numeric_lit.exp_sign;
	numinit.explaces = numeric_lit.exp_places;
	numinit.sign = numeric_lit.sign;
	numinit.ltdp = numeric_lit.ltdp;
	numinit.rtdp = numeric_lit.rtdp;
	numinit.length = numeric_lit.length;
	niv = nl;
	numinit.literal = numeric_lit.literal;
     end store_nv;


	conditioname.size = conditioname.size + niv_constant + niv;

	conditioname.size = conditioname.size + mod (-conditioname.size, 4);

	if save_ptr1 ^= null_func
	then do;
		numinit.initype.thru2 = "1"b;		/*numinit.initype fits alpha,figcon also*/
		tf = cobol_compare_values (save_ptr1, ptr1, data_name.item_length, ptr_to_char_tbl);

		if tf > 0
		then call diag;

		save_ptr1 = null_func;
	     end;
	go to retrn;				/* store non_numeric value for 88 entry */

actlbl (152):					/*action(65):*/
	conditioname.numlits = conditioname.numlits + 1;
	call store_av;


store_av:
     proc;
	alphainit.initype.non_numeric = "1"b;
	alphainit.info.bit_string = alphanum_lit.info.bit_string;
	alphainit.length = alphanum_lit.length;
	aiv = al;
	alphainit.string = alphanum_lit.string;
     end store_av;


	conditioname.size = conditioname.size + aiv_constant + aiv;

	conditioname.size = conditioname.size + mod (-conditioname.size, 4);

	if save_ptr1 ^= null_func
	then do;
		numinit.initype.thru2 = "1"b;		/*numinit.initype fits alpha,figcon also*/
		tf = cobol_compare_values (save_ptr1, ptr1, data_name.item_length, ptr_to_char_tbl);

		if tf > 0
		then call diag;

		save_ptr1 = null_func;
	     end;
	go to retrn;				/* store fig_con value for 88 entry */

actlbl (153):					/*action(66):*/
	conditioname.numlits = conditioname.numlits + 1;
	call store_fcv;


store_fcv:
     proc;
	alphainit.initype.fig_con = "1"b;
	alphainit.info.fig_con_index = substr (unspec (rw.jump_index), 30, 7);

	alphainit.length = 0;
     end store_fcv;



/* [3.0-2] */
/*[]*/
	if alphainit.info.fig_con_index = "0000001"b	/*fig zero*/
						/*[]*/
	then do;
		if vector_map.numeric		/*[]*/
		then do;
			conditioname.size = conditioname.size + niv_constant + 1;
						/*[]*/
			numinit.initype.numeric = "1"b;
						/*[]*/
			numinit.length = 1;		/*[]*/
		     end;				/*[]*/
		else do;
			conditioname.size = conditioname.size + aiv_constant + 1;
						/*[]*/
			alphainit.initype.non_numeric = "1"b;
						/*[]*/
			alphainit.length = 1;	/*[]*/
		     end;				/*[]*/
						/*[]*/
	     end;					/* [3.0-2] */
						/*PIC_VAL_COMP wmay replace fig con extension by numeric*/
	else conditioname.size = conditioname.size + aiv_constant;

	conditioname.size = conditioname.size + mod (-conditioname.size, 4);

	if save_ptr1 ^= null_func
	then do;
		numinit.initype.thru2 = "1"b;		/*numinit.initype fits alpha,figcon also*/
		tf = cobol_compare_values (save_ptr1, ptr1, data_name.item_length, ptr_to_char_tbl);

		if tf > 0
		then call diag;

		save_ptr1 = null_func;
	     end;

	go to retrn;				/* set ptr and first of thru value for 88 entry */

actlbl (154):					/*action(67):*/
	numinit.initype.thru1 = "1"b;
	save_ptr1 = ptr1;
	ptr1 = addr (w2_ptr -> any_item (conditioname.size + 1));
	go to retrn;				/* set pre for condition valuee in 88 entry */

actlbl (155):					/*action(68):*/
	ptr1 = addr (w2_ptr -> any_item (conditioname.size + 1));
	go to retrn;				/*object of ODO is TALLY*/

actlbl (156):					/*action(69):*/
						/*not implemented*/
	go to retrn;				/* write 88 entry type = 11 */

actlbl (157):					/*action(70):*/
	if bnw ^= 0
	then do;

/*non - level - 88 item to be written before first level - 88 item is written*/

		rnt_size = data_name.size;

		call cobol_vdwf_sput (cobol_ntfp, fstatus, dn_ptr, rnt_size, w_key);

		bnw = 0;

		if data_name.level = 1
		then if data_name.exp_redefining
		     then rdf_01_sav = w_key;
		     else save_01 = w_key;
		save_wkey = w_key;

	     end;

	rnt_size = conditioname.size;

	call cobol_vdwf_sput (cobol_ntfp, fstatus, w2_ptr, rnt_size, w_key);

	ptr1 = save_ptr;
	save_switch_88 = "1"b;
	no_of_88s = no_of_88s + 1;
	go to retrn;				/* store subject of renames */

actlbl (158):					/*action(71):*/
	rnm_obj12 = 0;
	com2_ptr = addr (cobol_wkbuf2_tbl.wkbuf2);
	ptr4 = addr (cobol_wkbuf2_tbl);
	ptr4 -> cntbuf2 = 0;
	rename_rec.lineno_66 = user_word.line;

	if save_line_for66 = 0
	then do;
		if h = 0
		then do;
			if rdf_01_sav ^= null_key
			then rnt_key = rdf_01_sav;
			else do;
				if save_01 = null_key
				then do;

					rnt_size = data_name.size;
					call cobol_vdwf_sput (cobol_ntfp, fstatus, dn_ptr, rnt_size, w_key);
					bnw = 0;

					if data_name.exp_redefining
					then rdf_01_sav = w_key;
					else do;
						save_01 = w_key;
						rdf_01_sav = null_key;
					     end;

					save_wkey = w_key;
				     end;
				rnt_key = save_01;
			     end;
		     end;

		else rnt_key = cobol_htbl.nt_rec (1);


		call cobol_vdwf_dget (cobol_ntfp, fstatus, rnt_ptr, rnt_size, rnt_key);

		rnt_ptr -> data_name.rnm_01 = "1"b;
		save_01_for66 = rnt_key;
		save_line_for66 = rnt_ptr -> data_name.line;

		call cobol_vdwf_dput (cobol_ntfp, fstatus, rnt_ptr, rnt_size, rnt_key);

	     end;

	rename_rec.rec_no_66 = save_01_for66;
	rename_rec.lineno_01 = save_line_for66;
	rename_rec.size = user_word.word_size;

	substr (rename_rec.name, 1, rename_rec.size) = substr (user_word.word, 1, user_word.word_size);

	rename_rec.next = null_key;
	rename_rec.obj1 = null_key;
	rename_rec.obj2 = null_key;
	go to retrn;				/* store object1 of rename */

actlbl (159):					/*action(72):*/
	if rnm_obj12 = 0
	then do;
		cm_ptr = com2_ptr;
		cm_size = rename_rec_constant + rename_rec.size;

		call cobol_vdwf_sput (cobol_cmfp, fstatus, cm_ptr, cm_size, cm_key);

		if prior_rename_rec = null_key
		then fixed_common.rename_info = cm_key;
		else do;
			rcm_key = prior_rename_rec;

			call cobol_vdwf_dget (cobol_cmfp, fstatus, cm_ptr, cm_size, rcm_key);

			com2_ptr = cm_ptr;
			rename_rec.next = cm_key;

			call cobol_vdwf_dput (cobol_cmfp, fstatus, cm_ptr, cm_size, rcm_key);

		     end;

		prior_rename_rec = cm_key;
	     end;

	prior_qual_rec = null_key;
	rnm_obj12 = rnm_obj12 + 1;
	com2_ptr = addr (cobol_wkbuf2_tbl.wkbuf2);
	ptr4 = addr (cobol_wkbuf2_tbl);
	ptr4 -> cntbuf2 = 0;
	obj_rec.qual = null_key;
	obj_rec.size = user_word.word_size;

	substr (obj_rec.name, 1, obj_rec.size) = substr (user_word.word, 1, user_word.word_size);

	obj_rec.line = user_word.line;
	obj_rec.column = user_word.column;
	cm_ptr = com2_ptr;
	cm_size = obj_rec_constant + obj_rec.size;

	call cobol_vdwf_sput (cobol_cmfp, fstatus, cm_ptr, cm_size, cm_key);

/* store object 1 into rename_rec*/
	prior_obj_rec = cm_key;
	rcm_key = prior_rename_rec;

	call cobol_vdwf_dget (cobol_cmfp, fstatus, cm_ptr, cm_size, rcm_key);

	com2_ptr = cm_ptr;

	if rnm_obj12 = 1
	then rename_rec.obj1 = cm_key;
	else rename_rec.obj2 = cm_key;

	call cobol_vdwf_dput (cobol_cmfp, fstatus, cm_ptr, cm_size, rcm_key);
	go to retrn;				/* store qualifier for rename adn occ object */

actlbl (160):					/*action(73):*/
	call qualifier;


qualifier:
     proc;
	com2_ptr = addr (cobol_wkbuf2_tbl.wkbuf2);
	ptr4 = addr (cobol_wkbuf2_tbl);
	ptr4 -> cntbuf2 = 0;
	qual_rec.line = user_word.line;
	qual_rec.column = user_word.column;
	qual_rec.size = user_word.word_size;

	substr (qual_rec.name, 1, qual_rec.size) = substr (user_word.word, 1, user_word.word_size);

	qual_rec.next = null_key;
	cm_ptr = com2_ptr;
	cm_size = qual_rec_constant + qual_rec.size;

	call cobol_vdwf_sput (cobol_cmfp, fstatus, cm_ptr, cm_size, cm_key);

     end qualifier;


	if prior_qual_rec ^= null_key
	then go to s_qual;

	rcm_key = prior_obj_rec;

	call cobol_vdwf_dget (cobol_cmfp, fstatus, cm_ptr, cm_size, rcm_key);

	com2_ptr = cm_ptr;
	obj_rec.qual = cm_key;
	prior_qual_rec = cm_key;

	call cobol_vdwf_dput (cobol_cmfp, fstatus, cm_ptr, cm_size, rcm_key);

	go to retrn;

s_qual:
	call store_qualifier;
	go to retrn;


store_qualifier:
     proc;
	rcm_key = prior_qual_rec;
	call cobol_vdwf_dget (cobol_cmfp, fstatus, cm_ptr, cm_size, rcm_key);
	com2_ptr = cm_ptr;
	qual_rec.next = cm_key;
	prior_qual_rec = cm_key;

	call cobol_vdwf_dput (cobol_cmfp, fstatus, cm_ptr, cm_size, rcm_key);

     end store_qualifier;




actlbl (161):					/*action(74):*/
	next_level = 1;
	go to retrn;

/* redefines processing */

actlbl (162):					/*action(75):*/
	if user_word.word = "FILLER"
	then do;
		tf = 180;
		call diag;
		go to retrn;
	     end;

	vector_map.s_of_rdf = "1"b;
	vector_map.exp_redefining = "1"b;

	if save_level = 77
	then do;
		rdf_level = 1;

		if data_name.level ^= 77
		then call enter_incorrect (32);

		else if ^data_name.exp_redefining
		then do;
			if user_word.word ^= data_name.name
			then call enter_correct_err (220);

			else do;

/*names match ... level 77*/

				data_name.o_of_rdf = "1"b;
				call enter_correct;
			     end;
		     end;

		else do;

/*dataname is s_of_rdf and levels match at 77*/

			if user_word.word ^= rdf_tbl (1)
			then call TF (220);		/*names match*/
			else call end75;
		     end;

		go to retrn;

	     end;

	rdf_level = next_level;

	if next_level = data_name.level
	then do;

		offset_ct = save_offsets (next_level);

		if ^data_name.exp_redefining
		then do;
			if user_word.word = data_name.name
			then do;

				if fixed_common.comp_level < "3"
				then do;
					if data_name.s_of_rdf
					then do;
						tf = 47;
						call diag_level;
					     end;

					if data_name.occurs_ptr ^= 0
					then do;
						tf = 48;
						call diag_level;
					     end;
				     end;
				data_name.o_of_rdf = "1"b;
				call enter_correct;
			     end;

/*levels match but not names*/

			else call enter_correct_err (220);
		     end;

		else do;

			if rdf_tbl (rdf_level) = user_word.word
			then call end75;
			else call TF (220);

		     end;
	     end;

	else if next_level > data_name.level
	then call enter_incorrect (32);

	else do;					/*next_level less than data_name.level*/

		offset_ct = save_offsets (next_level);

/*at this moment, cobol_htbl has been popped to last item with level
	less than next_level; however, the
	old items are still in there. If h indexes parent level item
	of next_level item, then h + 1 indexes either an item of level
	equal to next_level or greater than it. If equal, the cobol_htbl item
	represents object of redefines, or last redefinition of object
	at that level; if greater, the redefinition is
	in error.*/

		fh = h + 1;

		if cobol_htbl.level (fh) ^= next_level	/*level is greater than next_level*/
		then call enter_incorrect (32);

/*levels match*/

		else if ^cobol_htbl.exp_redefining (fh)
		then do;
			rnt_key = cobol_htbl.nt_rec (fh);

			call cobol_vdwf_dget (cobol_ntfp, fstatus, rnt_ptr, rnt_size, rnt_key);

			save_ptr = dn_ptr;
			dn_ptr = rnt_ptr;

			if user_word.word = data_name.name
			then do;
				data_name.o_of_rdf = "1"b;
				rdf_tbl (next_level) = data_name.name;


				if data_name.exp_occurs
				then do;
					tf = 54;
					call diag;
				     end;

				if data_name.do_rec ^= null_key
				then do;
					tf = 55;
					call diag;
				     end;

				call cobol_vdwf_dput (cobol_ntfp, fstatus, rnt_ptr, rnt_size, rnt_key);

				dn_ptr = save_ptr;

				call end75;
			     end;

/*names don't match*/

			else do;
				dn_ptr = save_ptr;
				call enter_correct_err (220);
			     end;

		     end;				/*cobol_htbl.exp_redefining(fh) is set*/

		else if user_word.word = rdf_tbl (next_level)
		then call end75;
		else call TF (220);

	     end;
	go to retrn;

enter_incorrect:
     proc (num);

declare	num		fixed bin;

	rdf_tbl (next_level) = user_word.word;

	call TF (num);

     end;

enter_correct_err:
     proc (num);

declare	num		fixed bin;

	tf = num;
	call diag;

	call enter_correct;

     end;

enter_correct:
     proc;

	rdf_tbl (next_level) = data_name.name;

	if data_name.exp_occurs
	then do;
		tf = 54;
		call diag;
	     end;

	if data_name.do_rec ^= null_key
	then do;
		tf = 55;
		call diag;
	     end;

	call end75;

     end;

TF:
     proc (num);

declare	num		fixed bin;

	tf = num;
	call diag;

	call end75;

     end;

end75:
     proc;

	if bnw ^= 0
	then do;

/*write completed (previous) dataname token*/

		rnt_ptr = dn_ptr;
		nt_size = data_name.size;

		call cobol_vdwf_sput (cobol_ntfp, fstatus, rnt_ptr, nt_size, w_key);

		if data_name.non_elementary
		then cobol_htbl.nt_rec (h) = w_key;

		if data_name.level = 1
		then do;
			if data_name.exp_redefining
			then rdf_01_sav = w_key;

			else do;
				save_01 = w_key;
				rdf_01_sav = null_key;
			     end;
		     end;
	     end;

	else do;

/* item was written already -  - but o_of_rdf description bit has been updated since*/

		if data_name.o_of_rdf
		then do;

			call cobol_vdwf_dget (cobol_ntfp, fstatus, rnt_ptr, rnt_size, save_wkey);
			call cobol_vdwf_dput (cobol_ntfp, fstatus, dn_ptr, rnt_size, save_wkey);

		     end;

	     end;

	ptr4 = addr (cobol_wkbuf1_tbl);
	ptr4 -> cntbuf = 0;

	data_name.type = 9;
	data_name.size = dn_constant;
	data_name.line = save_line;
	data_name.def_line = save_line;
	data_name.column = save_column;
	data_name.level = save_level;
	data_name.do_rec = null_key;

	if file_number ^= 0
	then data_name.file_num = file_number;
	else data_name.file_num = cdno;

	data_name.name_size = dnl;

	data_name.name = substr (save_dname, 1, data_name.name_size);

	data_name.size = dn_constant + dnl;

	data_name.size = data_name.size + mod (-data_name.size, 4);

	ptr1 = addr (dn_ptr -> any_item (data_name.size + 1));

	bnw = 1;					/*buf needs write*/

     end;

diag:
     proc;
	rn = 3;
	go to diag_start;
diag_level:
     entry;
	rn = 9;
diag_start:
	message_ptr = addr (message_area);
	message.size = 32;
	message.line = record.line;
	message.column = record.column;
	message.type = 5;
	message.run3 = rn;
	message.info.para = "0"b;
	message.info.rep = "0"b;
	message.info.fillerx = "000000"b;
	message.length = 0;
	message.number = tf;

	call cobol_c_list (message_ptr);

     end;



actlbl (163):					/*action(76):*/
	data_name.size = data_name.size + max_poss_extensions;
						/*maximum possible size*/
						/* save 66 entry record no in rename_rec */

	if prior_rename_rec ^= null_key
	then do;
		rcm_key = prior_rename_rec;

		call cobol_vdwf_dget (cobol_cmfp, fstatus, cm_ptr, cm_size, rcm_key);

		com2_ptr = cm_ptr;
	     end;
	go to retrn;

/* set file section indicators */

actlbl (166):					/*action(79):*/
	substr (section_ind, 1, 1) = "1"b;
	substr (vector_part, 1, 6) = "100000"b;
	ll01 = "0"b;
	ll77 = "0"b;
	file_number = 0;
	name_string_index = 1;
	nsa_index = 0;
	go to retrn;				/* end of file section processing */

actlbl (167):					/*action(80):*/
	file_number = 0;

/* check data record names and label record names are defined */

	if nsa_index ^= 0
	then do nsa_work_index = 1 to nsa_index by 1;

		if ^nsa_cancelled (nsa_work_index)
		then do;

			if nsa_lbl_rec (nsa_work_index)
			then tf = 192;
			else tf = 193;

			call diag;
		     end;

	     end;

/* scan and report undefined files */
	go to retrn;				/* initialize current fd token entry */

actlbl (168):					/*action(81):*/
	if fixed_common.comp_level < "5"
	then if record.column < 8 | record.column > 11
	     then do;
		     tf = 133;
		     call diag_level;
		end;

	ll01 = "0"b;
	fd_clauses = "000000000000000000000000000000000000"b;
	ptr4 = addr (cobol_wkbuf2_tbl);
	ptr4 -> cntbuf2 = 0;
	fd_token.def_line = record.line;
	fd_token.line = record.line;
	fd_token.column = record.column;
	fd_token.size = fd_constant;

	if rw.key = 219
	then fd_token.type = 12;
	if rw.key = 243
	then fd_token.type = 16;
	if rw.key = 242
	then fd_token.type = 15;

	nsa_index_last_fd = nsa_index + 1;
	save_block_desc = 0;
	save_block_min = 0;
	save_block_max = 0;
	save_record_min = 0;
	save_record_max = 0;
	go to retrn;				/*code - set bcd - 1400*/

actlbl (173):					/*action(86):*/
						/*label records c120*/
	if file_number ^= 0
	then file_table.label_format = 2;
	go to retrn;

actlbl (174):					/*action(87):*/
						/*label records c80*/
	if file_number ^= 0
	then file_table.label_format = 3;
	go to retrn;

actlbl (175):					/*action(88):*/
						/*label records e80*/
	if file_number ^= 0
	then file_table.label_format = 4;
	go to retrn;

actlbl (176):					/*action(89):*/
						/*code - set ascii*/
	go to retrn;				/* get file number from file table in common */

actlbl (181):					/*action(94):*/
	fd_token.file_no = file_table.file_no;
	file_number = fd_token.file_no;

	if fd_token.type = 16
	then file_table.sort_file = "1"b;
	else file_table.sort_file = "0"b;

	file_table.rec_do_info = null_key;
	go to retrn;				/*end of Communication Section*/

actlbl (177):					/*action(90):*/
	cdno = 0;
	go to retrn;				/*level 1 in Communication Section*/

actlbl (178):					/*action(91):*/
	data_name.file_num = cdno;
	data_name.s_of_rdf = "1"b;
	data_name.exp_redefining = "1"b;
	go to retrn;

/* store file name */

actlbl (182):					/*action(95):*/
						/*[4.0-1]*/
	call cobol_ddsyntax$init_file_tab;

	fd_token.name_size = user_word.word_size;
	substr (fd_token.name, 1, fd_token.name_size) = substr (user_word.word, 1, user_word.word_size);
	fd_token.size = fd_token.size + fd_token.name_size;

	fd_token.size = fd_token.size + mod (-fd_token.size, 4);

	ptr2 = addr (w2_ptr -> any_item (fd_token.size + 1));
	go to retrn;				/*record contains depending on dataname*/

actlbl (183):					/*action(96):*/
	if file_number ^= 0
	then do;
		file_table.rec_do = "1"b;

		if file_table.fixed_recs
		then do;
			tf = 189;
			call diag;
		     end;
	     end;

	if bnw ^= 0
	then do;
		rnt_size = data_name.size;

		call cobol_vdwf_sput (cobol_ntfp, fstatus, dn_ptr, rnt_size, w_key);

		bnw = 0;
	     end;

	fkey_ptr = addr (cobol_wkbuf1_tbl.wkbuf1);
	file_key.next = null_key;
	file_key.next_alt = null_key;
	file_key.qual = null_key;
	addr (file_key.info) -> BIT8 = "0"b;		/* [3.0-1] */
	file_key.file_no = file_number;
	file_key.key_type = 6;
	file_key.line = user_word.line;
	file_key.column = user_word.column;
	file_key.temp_seg = 0;
	file_key.temp_offset = 0;
	file_key.name_size = user_word.word_size;

	substr (file_key.name, 1, file_key.name_size) = substr (user_word.word, 1, user_word.word_size);

	cm_size = fkey_constant + file_key.name_size;

	call cobol_vdwf_sput (cobol_cmfp, fstatus, fkey_ptr, cm_size, cm_key);

	if file_number ^= 0
	then if file_table.rec_do_info = null_key
	     then file_table.rec_do_info = cm_key;

	if fixed_common.file_keys = null_key
	then fixed_common.file_keys = cm_key;
	else do;
		rcm_key = fixed_common.last_file_key;

		call cobol_vdwf_dget (cobol_cmfp, fstatus, fkey_ptr, cm_size, rcm_key);

		file_key.next = cm_key;

		call cobol_vdwf_dput (cobol_cmfp, fstatus, fkey_ptr, cm_size, rcm_key);
	     end;
	fixed_common.last_file_key = cm_key;
	go to retrn;				/* end of fd processing */

actlbl (186):					/*action(99):*/
						/* store block record linage info into file table in common */
	if fd_token.file_no ^= 0
	then do;

		file_table.block_desc = save_block_desc;
		file_table.block_min = save_block_min;
		file_table.block_max = save_block_max;
		file_table.rec_min = save_record_min;
		file_table.rec_max = save_record_max;	/* generate LINAGE - COUNTER */
		if fd_ind.linage_is
		then do;
			cm_size = linage_rec_constant + 40 * linage_rec.name_count;

			call cobol_vdwf_sput (cobol_cmfp, fstatus, linage_ptr, cm_size, cm_key);

			file_table.linage_info = cm_key;
			file_table.linage = "1"b;

			if bnw ^= 0
			then do;
				rnt_size = data_name.size;

				call cobol_vdwf_sput (cobol_ntfp, fstatus, dn_ptr, rnt_size, w_key);

			     end;

			ptr4 = addr (cobol_wkbuf1_tbl);
			ptr4 -> cntbuf = 0;
			data_name.size = dn_constant + 14;
			data_name.line = fd_token.line;
			data_name.column = fd_token.column;
			data_name.type = 9;
			data_name.level = 1;
			data_name.item_length = 5;	/* 5 is arbitrarily chosen */
			data_name.places_left = 5;
			data_name.places_right = 0;
			data_name.initial_ptr = 0;
			data_name.edit_ptr = 0;
			data_name.occurs_ptr = 0;
			data_name.file_num = file_number;
			data_name.offset = 0;
			data_name.name_size = 14;
			substr (data_name.name, 1, data_name.name_size) = "LINAGE-COUNTER";
			ptr8 = addr (data_name.file_section);

			ptr8 -> bit72 = "100000010100000001000000000100000000000000000000000000000000000000100000"b;

			bnw = 1;

		     end;				/*first write fd token*/
		rnt_size = fd_token.size;

		call cobol_vdwf_sput (cobol_ntfp, fstatus, w2_ptr, rnt_size, w_key);

		save_fd = w_key;
	     end;

	if fd_ind.report_is = "1"b & fd_ind.data_record = "1"b
	then do;
		tf = 66;
		call diag;
	     end;

	if fd_ind.report_is = "1"b & fd_ind.linage_is = "1"b
	then do;
		tf = 87;
		call diag;
	     end;

	go to retrn;				/* store file no into data record entry */
						/* check user label names and data record names if specified */

actlbl (187):					/*action(100):*/
	call cobol_vdwf_dget (cobol_ntfp, fstatus, save_w2, rnt_size, save_fd);

	data_name.file_num = save_w2 -> fd_token.file_no; /* set fno */
						/* check user label names */
	if fd_ind.label_type.user_spec ^= "1"b
	then go to na100;				/* check data record names */
na100:
	if nsa_index < nsa_index_last_fd
	then go to err100_191;

	do nsa_work_index = nsa_index_last_fd to nsa_index by 1;

	     if nsa_name_length (nsa_work_index) = dnl
	     then do;

		     if substr (name_string, nsa_name_index (nsa_work_index), dnl) = save_dname
		     then do;
			     nsa_cancelled (nsa_work_index) = "1"b;
			     data_name.label_record = nsa_lbl_rec (nsa_work_index);
			     go to endg100;
			end;

		end;
	end;
endg100:
	if nsa_work_index > nsa_index
	then do;
err100_191:					/*tf = 191;
			call diag;*/
	     end;
nna100:						/* store data record names */
	go to retrn;				/* set linage defaults for fd_token */

actlbl (188):					/*action(101):*/
	if fd_ind.linage_type.top = "0"b
	then do;
		linage_rec.top = 0;
		linage_rec.top_int = 0;
		linage_rec.top_name = null_key;
	     end;
	if fd_ind.linage_type.bottom = "0"b
	then do;
		linage_rec.bottom = 0;
		linage_rec.bottom_int = 0;
		linage_rec.bottom_name = null_key;
	     end;

	if fd_ind.linage_type.footing = "0"b
	then do;
		linage_rec.footing = 0;
		linage_rec.footing_int = 0;
		linage_rec.footing_name = null_key;
	     end;

	go to retrn;

/* Store linage footing info */

actlbl (189):					/*action(102):*/
	fd_ind.linage_type.footing = "1"b;
	linage_rec.footing = linage_rec.name_count + 1;
	linage_name_rec.desc = 2;

	call write_linage_name_rec;

	linage_rec.footing_name = cm_key;
	go to retrn;				/* Store integer for linage footing */

actlbl (190):					/*action(103):*/
	fd_ind.linage_type.footing = "1"b;
	linage_rec.footing = 5;			/*[5.1-1]*/
	if record.type = 2
	then linage_rec.footing_int = fixed (numeric_lit.literal);
	else linage_rec.footing_int = 0;
	go to retrn;

/* set fd recording mode indicator */

actlbl (191):					/*action(104):*/
	fd_ind.recording_mode = "1"b;
	go to retrn;				/* set fd recording mode index */

actlbl (192):					/*action(105):*/
						/* not done */
	go to retrn;				/* set block contain indicator */

actlbl (193):					/*action(106):*/
	fd_ind.block_contain = "1"b;
	go to retrn;				/* set record contain indicator */

actlbl (194):					/*action(107):*/
	fd_ind.record_contain = "1"b;
	go to retrn;				/* set label record indicator */

actlbl (195):					/*action(108):*/
	fd_ind.label_record = "1"b;
	go to retrn;				/* set value of indicator */

actlbl (196):					/*action(109):*/
	fd_ind.value_of = "1"b;
	go to retrn;				/* set data record indicator */

actlbl (197):					/*action(110):*/
	fd_ind.data_record = "1"b;
	go to retrn;				/* set report is indicator */

actlbl (198):					/*action(111):*/
	fd_ind.report_is = "1"b;
	go to retrn;

/* set linage is indicator */

actlbl (199):					/*action(112):*/
	if bnw ^= 0
	then do;
		rnt_size = data_name.size;

		call cobol_vdwf_sput (cobol_ntfp, fstatus, dn_ptr, rnt_size, w_key);

		bnw = 0;
	     end;

	fd_ind.linage_is = "1"b;
	com2_ptr = addr (cobol_wkbuf1_tbl.wkbuf1);	/*ads linage_name_recs*/

	linage_ptr = addr (com2_ptr -> any_item (101));	/*ads linage rec -  -  - must be word aligned on 6180*/
	linage_rec.body = 0;
	linage_rec.top = 0;
	linage_rec.bottom = 0;
	linage_rec.footing = 0;
	linage_rec.name_count = 0;

	save_block_min = 0;
	save_block_max = 0;
	save_record_min = 0;
	save_record_max = 0;
	go to retrn;

/* set min_size for block */

actlbl (201):					/*action(114):*/
						/*[5.1-1]*/
	if record.type = 2
	then save_block_max = fixed (numeric_lit.literal);
	else save_block_max = 0;
	save_block_min = 0;
	go to retrn;				/* set record bit for block */

actlbl (202):					/*action(115):*/
	save_block_desc = 2;
	go to retrn;				/* set character bit for block */

actlbl (203):					/*action(116):*/
	save_block_desc = 1;
	go to retrn;

/* set max size for block */

actlbl (204):					/*action(117):*/
	save_block_min = save_block_max;		/*[5.1-1]*/
	if record.type = 2
	then save_block_max = fixed (numeric_lit.literal);
	else save_block_max = 0;

	if save_block_min >= save_block_max
	then do;
		tf = 211;
		call diag;
	     end;
	go to retrn;				/* Store data name for linage bottom */

actlbl (205):					/*action(118):*/
	fd_ind.linage_type.bottom = "1"b;
	linage_rec.bottom = linage_rec.name_count + 1;
	linage_name_rec.desc = 4;

	call write_linage_name_rec;

	linage_rec.bottom_name = cm_key;
	go to retrn;				/* Store integer for linage bottom */

actlbl (206):					/*action(119):*/
	fd_ind.linage_type.bottom = "1"b;
	linage_rec.bottom = 5;			/*[5.1-1]*/
	if record.type = 2
	then linage_rec.bottom_int = fixed (numeric_lit.literal);
	else linage_rec.bottom_int = 0;
	go to retrn;

/* store min size for record contain */

actlbl (207):					/*action(120):*/
						/*[5.1-1]*/
	if record.type = 2
	then save_record_max = fixed (numeric_lit.literal);
	else save_record_max = 0;

	if save_record_max > 262143
	then do;
		tf = 212;
		call diag;
	     end;

	save_record_min = 0;
	go to retrn;

/* Set linage top data name */

actlbl (208):					/*action(121):*/
	fd_ind.linage_type.top = "1"b;
	linage_rec.top = linage_rec.name_count + 1;
	linage_name_rec.desc = 3;

	call write_linage_name_rec;

	linage_rec.top_name = cm_key;
	go to retrn;

/* store max size for record contain */

actlbl (209):					/*action(122):*/
	save_record_min = save_record_max;		/*[5.1-1]*/
	if record.type = 2
	then save_record_max = fixed (numeric_lit.literal);
	else save_record_max = 0;

	if save_record_max > 262143
	then do;
		tf = 212;
		call diag;
	     end;
	go to retrn;				/* set label record omitted */

actlbl (210):					/*action(123):*/
	fd_ind.label_type.omitted = "1"b;

	if file_number ^= 0
	then file_table.label_format = 5;
	go to retrn;				/* set label record standard */

actlbl (211):					/*action(124):*/
	fd_ind.label_type.standard = "1"b;

	if file_number ^= 0
	then file_table.label_format = 1;
	go to retrn;				/* set label record user spec */

actlbl (212):					/*action(125):*/
	nsa_index = nsa_index + 1;
	nsa_name_index (nsa_index) = name_string_index;
	nsa_name_length (nsa_index) = user_word.word_size;
	nsa_lbl_rec (nsa_index) = "1"b;
	nsa_cancelled (nsa_index) = "0"b;

	substr (name_string, name_string_index, user_word.word_size) = substr (user_word.word, 1, user_word.word_size);

	name_string_index = name_string_index + user_word.word_size;
	go to retrn;

actlbl (213):					/* action(126) */
						/* value of label field is literal */
	if label_field_num ^= 0
	then go to LFL (label_field_num);

	go to retrn;

LFL (1):						/* file - id */
	call enter_key (113);

	if file_table.file_id_info ^= "00000"
	then do;
		tf = 208;
		call diag;
	     end;
	else file_table.file_id_info = common_key;

	go to retrn;

LFL (2):						/* retention */
	call enter_key (114);

	if file_table.retention_info ^= "00000"
	then do;
		tf = 208;
		call diag;
	     end;
	else file_table.retention_info = common_key;

	go to retrn;

LFL (3):						/* catalogue-name */
	if file_table.catalogued ^= 0
	then do;
		tf = 221;
		call diag;
	     end;

	else do;
		file_table.catalogued = 2;
		file_table.cat_nm = alphanum_lit.string;
	     end;

	if file_table.cat_id_info ^= "00000"
	then do;
		tf = 208;
		call diag;
	     end;
	else file_table.cat_id_info = common_key;

	go to retrn;

actlbl (214):					/* action(127) */
						/* value of label field is data name */
	if label_field_num ^= 0
	then go to LFD (label_field_num);

	go to retrn;

LFD (1):						/* file - id */
	call enter_key (13);

	if file_table.file_id_info ^= "00000"
	then do;
		tf = 208;
		call diag;
	     end;
	else file_table.file_id_info = common_key;

	go to retrn;

LFD (2):						/* retention */
	call enter_key (14);

	if file_table.retention_info ^= "00000"
	then do;
		tf = 208;
		call diag;
	     end;
	else file_table.retention_info = common_key;

	go to retrn;

LFD (3):						/* catalogue-name */
	if file_table.catalogued ^= 0
	then do;
		tf = 221;
		call diag;
	     end;

	else do;
		file_table.catalogued = 3;
		call enter_key (7);
	     end;

	if file_table.cat_id_info ^= "00000"
	then do;
		tf = 208;
		call diag;
	     end;
	else file_table.cat_id_info = common_key;

	go to retrn;

actlbl (215):					/* action(128) */
						/* name qualifier */
	if label_field_num ^= 0
	then call enter_qual;

	go to retrn;



/* enter key into var common */

enter_key:
     proc (type);

declare	(type, siz, lit_size)
			fixed bin;

	file_key.next = "00000";
	file_key.next_alt = "00000";
	file_key.qual = "00000";

	addr (file_key.info) -> BIT8 = "0"b;		/* [3.0-1] */

	file_key.file_no = file_table.file_no;

	file_key.line = user_word.line;
	file_key.column = user_word.column;

	file_key.temp_seg = 0;
	file_key.temp_offset = 0;

	file_key.desc = " ";

	file_key.key_type = type;

	qual_sw = "0"b;

	if user_word.type = 8			/* user word */
	then do;
		file_key.name_size = user_word.word_size;
		file_key.name = user_word.word;
	     end;

	else if alphanum_lit.type = 3			/* alphanumeric lit */
	then do;
		file_key.name_size = alphanum_lit.length;
		file_key.name = alphanum_lit.string;
	     end;

	else if numeric_lit.type = 2			/* numeric lit */
	then do;
		file_key.name_size = numeric_lit.length;
		file_key.name = numeric_lit.literal;
	     end;

	else if rw.type = 1				/* figurative const */
	then do;
		if label_field_num ^= 0
		then do;

			go to LFF (label_field_num);

LFF (1):						/* file - id */
			if all_ind = 0
			then file_key.name_size = 1;
			else file_key.name_size = 17;

			call form_lit;

			go to LFF1;

LFF (2):						/* retention */
			if all_ind = 0
			then file_key.name_size = 1;
			else file_key.name_size = 3;

			call form_lit;

			go to LFF1;

LFF (3):						/* catalogue-name */
			if all_ind = 0
			then file_key.name_size = 1;
			else file_key.name_size = 17;

			call form_lit;

			go to LFF1;

LFF1:
		     end;

	     end;

	siz = size (file_key) * 4 + file_key.name_size;

	call cobol_vdwf_sput (cobol_com_fileno, com_status, fkey_ptr, siz, common_key);

	if fixed_common.file_keys = "00000"
	then fixed_common.file_keys = common_key;

	else do;
		call cobol_vdwf_dget (cobol_com_fileno, com_status, work_ptr, siz, fixed_common.last_file_key);

		work_ptr -> file_key.next = common_key;

		call cobol_vdwf_dput (cobol_com_fileno, com_status, work_ptr, siz, fixed_common.last_file_key);

	     end;

	fixed_common.last_file_key = common_key;

     end;

form_lit:
     proc;					/* form lit from fig const */

declare	lit_char		char (1),
	p		ptr;
declare	lit_bit		bit (9) based;
declare	lit_bit_string	(256) char (1) based (p);

	lit_char = " ";

	if rw.key = 192
	then lit_char = " ";			/* is_word("SPACE") */
	else if rw.key = 180
	then lit_char = "0";			/* is_word("ZERO") */
	else if rw.key = 235
	then lit_char = """";			/* is_word("QUOTE") */
	else if rw.key = 229			/* is_word("LOW-VALUE") */
	then addr (lit_char) -> lit_bit = "0"b;
	else if rw.key = 221			/* is_word("HIGH-VALUE") */
	then addr (lit_char) -> lit_bit = "001111111"b;

	p = addr (file_key.name);

	do i = 1 by 1 to file_key.name_size;

	     lit_bit_string (i) = lit_char;

	end;

     end;

enter_qual:
     proc;					/* enter qualifier into var common */

declare	size		fixed bin;

declare	1 qual_rec	based (qual_ptr),
	  2 next		char (5),
	  2 size		fixed bin,
	  2 name		char (0 refer (qual_rec.size));

	size = user_word.word_size + key_qual_size;

	qual_rec.next = "00000";
	qual_rec.size = user_word.word_size;
	qual_rec.name = user_word.word;

	call cobol_vdwf_sput (cobol_com_fileno, com_status, qual_ptr, size, common_key);

	if qual_sw = "0"b
	then do;
		call cobol_vdwf_dget (cobol_com_fileno, com_status, work_ptr, size, fixed_common.last_file_key);

		work_ptr -> file_key.qual = common_key;

		call cobol_vdwf_dput (cobol_com_fileno, com_status, work_ptr, size, fixed_common.last_file_key);

	     end;

	else do;
		call cobol_vdwf_dget (cobol_com_fileno, com_status, work_ptr, size, prev_qual_key);
	     end;

	prev_qual_key = common_key;
	qual_sw = "1"b;

     end;


/* store data record name */

actlbl (216):					/*action(129):*/
	if file_number ^= 0
	then file_table.data_count = file_table.data_count + 1;

	nsa_index = nsa_index + 1;
	nsa_name_index (nsa_index) = name_string_index;
	nsa_name_length (nsa_index) = user_word.word_size;
	nsa_lbl_rec (nsa_index) = "0"b;
	nsa_cancelled (nsa_index) = "0"b;

	substr (name_string, name_string_index, user_word.word_size) = substr (user_word.word, 1, user_word.word_size);

	name_string_index = name_string_index + user_word.word_size;
	go to retrn;

/* store report name */

actlbl (217):					/*action(130):*/
	if file_number ^= 0
	then file_table.report_count = file_table.report_count + 1;
						/* write report_rec */
	if bnw ^= 0
	then do;
		rnt_size = data_name.size;

		call cobol_vdwf_sput (cobol_ntfp, fstatus, dn_ptr, rnt_size, w_key);

		bnw = 0;
	     end;

	com2_ptr = addr (cobol_wkbuf1_tbl.wkbuf1);
	ptr4 = addr (cobol_wkbuf1_tbl);
	ptr4 -> cntbuf = 0;
	report_rec.next = null_key;
	report_rec.line = user_word.line;
	report_rec.column = user_word.column;
	report_rec.fileno = fd_token.file_no;
	report_rec.size = user_word.word_size;

	substr (report_rec.name, 1, report_rec.size) = substr (user_word.word, 1, user_word.word_size);

	cm_ptr = com2_ptr;
	cm_size = report_rec_constant + report_rec.size;

	call cobol_vdwf_sput (cobol_cmfp, fstatus, cm_ptr, cm_size, cm_key);

	if prior_report_rec ^= null_key
	then go to s_report_next;

	fixed_common.report_names = cm_key;
	prior_report_rec = cm_key;
	go to retrn;

s_report_next:
	rcm_key = prior_report_rec;

	call cobol_vdwf_dget (cobol_cmfp, fstatus, cm_ptr, cm_size, rcm_key);

	if substr (fstatus, 17, 16) ^= "0000000000000000"b
	then go to retrn;

	com2_ptr = cm_ptr;
	report_rec.next = cm_key;

	call cobol_vdwf_dput (cobol_cmfp, fstatus, cm_ptr, cm_size, rcm_key);

	prior_report_rec = cm_key;
	go to retrn;				/* store body data name for linage */

actlbl (218):					/*action(131):*/
	fd_ind.linage_type.body = "1"b;
	linage_rec.body = linage_rec.name_count + 1;
	linage_name_rec.desc = 1;

	call write_linage_name_rec;

	linage_rec.body_name = cm_key;
	go to retrn;				/* store body integer for linage */

actlbl (219):					/*action(132):*/
	fd_ind.linage_type.body = "1"b;
	linage_rec.body = 5;			/*[5.1-1]*/
	if record.type = 2
	then linage_rec.body_int = fixed (numeric_lit.literal);
	else linage_rec.body_int = 0;
	go to retrn;				/* Store integer for linage top */

actlbl (220):					/*action(133):*/
	fd_ind.linage_type.top = "1"b;
	linage_rec.top = 5;				/*[5.1-1]*/
	if record.type = 2
	then linage_rec.top_int = fixed (numeric_lit.literal);
	else linage_rec.top_int = 0;
	go to retrn;


write_linage_name_rec:
     proc;					/*store linage data name into common*/
	linage_name_rec.next = null_key;
	linage_name_rec.line = user_word.line;
	linage_name_rec.column = user_word.column;
	linage_name_rec.fileno = fd_token.file_no;
	linage_name_rec.size = user_word.word_size;

	substr (linage_name_rec.name, 1, linage_name_rec.size) = substr (user_word.word, 1, user_word.word_size);

	cm_ptr = com2_ptr;
	cm_size = linage_name_rec_constant + linage_name_rec.size;

	call cobol_vdwf_sput (cobol_cmfp, fstatus, cm_ptr, cm_size, cm_key);

	linage_rec.name_count = linage_rec.name_count + 1;

	if prior_linage_name_rec ^= null_key
	then go to linage_next;

	fixed_common.linage_info = cm_key;
	prior_linage_name_rec = cm_key;

	return;

linage_next:
	rcm_key = prior_linage_name_rec;

	call cobol_vdwf_dget (cobol_cmfp, fstatus, cm_ptr, cm_size, rcm_key);

	if substr (fstatus, 17, 16) ^= "0000000000000000"b
	then return;

	cm_ptr -> linage_name_rec.next = cm_key;

	prior_linage_name_rec = cm_key;
     end write_linage_name_rec;

actlbl (221):					/*action(134):*/
/**** not done *****/
	go to retrn;

/* all_lit */

actlbl (222):					/*action(135):*/
	alphainit.initype.all_lit = "1"b;

	go to retrn;

/* set ptr1 after occrus clause */

actlbl (223):					/*action(137):*/
	ptr1 = addr (dn_ptr -> any_item (data_name.size + 1));

	go to retrn;				/* set level indicator to 0 */

actlbl (224):					/*action(138):*/
	ll01 = "0"b;
	ll77 = "0"b;
	go to retrn;

/* add key structure length to size */

actlbl (225):					/*action(139):*/
						/*           data_name.size = data_name.size + ks_constant + ks_cnt_constant*keys.keycount;*/
	go to retrn;
/***** communication section action routines *****/
						/* cms section init */

actlbl (226):					/*action(140):*/
	substr (section_ind, 5, 1) = "1"b;
	substr (vector_part, 1, 6) = "000010"b;
	cd_initial = "0"b;
	ll01 = "1"b;
	cdno = 0;
	go to retrn;				/* cd entry init */

actlbl (227):					/*action(141):*/
	if fixed_common.comp_level < "5"
	then if record.column < 8 | record.column > 11
	     then do;
		     tf = 133;
		     call diag_level;
		end;

	if ll01 = "0"b
	then do;
		tf = 101;
		call diag;
	     end;

	ll01 = "0"b;
	ptr4 = addr (cobol_wkbuf2_tbl);
	ptr4 -> cntbuf2 = 0;
	cdtoken.def_line = record.line;		/*	cdtoken.level = 0; */
	cdtoken.column = record.column;
	cdtoken.size = cd_constant;
	cdtoken.type = 13;
	cdno = cdno - 1;

	do i = 1 to 11;
	     cd_size (i) = 0;
	end;

	cd_clauses = "0"b;
	save_cdo = 0;
	go to retrn;				/* store cd name */

actlbl (228):					/*action(142):*/
						/*[4.4-1]*/
	fixed_common.cd = "1"b;
	cdtoken.name_size = user_word.word_size;

	substr (cdtoken.name, 1, cdtoken.name_size) = substr (user_word.word, 1, user_word.word_size);

	cdtoken.size = cdtoken.size + cdtoken.name_size;

	cdtoken.size = cdtoken.size + mod (-cdtoken.size, 4);

	go to retrn;				/* set cd output option indicator and write cd entry */

actlbl (229):					/*action(143):*/
	cdtoken.options.output = "1"b;
	cd_clauses = "0"b;

	call write_cd;
	call cdinit;

	data_name.level = 1;
	data_name.item_length = 16;

	ptr8 = addr (data_name.file_section);

	ptr8 -> bit72 = "000010010100000000010000000100000000000000000001000000000000000000000100"b;
	data_name.size = dn_constant;

	data_name.size = data_name.size + mod (-data_name.size, 4);

	data_name.initial_ptr = data_name.size + 1;
	ptr1 = addr (dn_ptr -> any_item (data_name.initial_ptr));
	alphainit.initype.non_numeric = "1"b;
	alphainit.length = data_name.item_length;
	ptr11 = addr (output_cd_prefix_initval);
	alphainit.string = output_cd_string;
	data_name.size = data_name.size + aiv_constant + alphainit.length;

/*	call cobol_vdwf_sput(cobol_ntfp,fstatus,dn_ptr,data_name.size,w_key); */

	data_name.initial_ptr = 0;
	index_ct = 0;
	go to retrn;



write_cd:
     proc;					/* write cd entry */
	rnt_size = cdtoken.size;
	cdtoken.cd_num = cdno;
	cdtoken.mdest = 1;

	call cobol_vdwf_sput (cobol_ntfp, fstatus, w2_ptr, rnt_size, w_key);

	save_fd = w_key;
	return;
     end write_cd;


/* set cd input bit and write cd entry */

actlbl (230):					/*action(144):*/
	cdtoken.options.input = "1"b;
	cd_clauses = "0"b;
	substr (cd_clauses, 12, 1) = "1"b;		/*stands for input cd*/

	call write_cd;
	call cdinit;

	data_name.level = 1;
	data_name.item_length = 16;

	ptr8 = addr (data_name.file_section);

	ptr8 -> bit72 = "000010010100000000010000000100000000000000000001000000000000000000000100"b;
	data_name.size = dn_constant;

	data_name.size = data_name.size + mod (-data_name.size, 4);

	data_name.initial_ptr = data_name.size + 1;
	ptr1 = addr (dn_ptr -> any_item (data_name.initial_ptr));
	alphainit.initype.non_numeric = "1"b;
	alphainit.length = data_name.item_length;
	ptr11 = addr (input_cd_prefix_initval);
	alphainit.string = input_cd_string;
	data_name.size = data_name.size + aiv_constant + alphainit.length;

/*	call cobol_vdwf_sput(cobol_ntfp,fstatus,dn_ptr,data_name.size,w_key); */

	data_name.initial_ptr = 0;
	go to retrn;

/* set cd initial bit */

actlbl (231):					/*action(145):*/
	cdtoken.options.initial = "1"b;
	cd_initial = "1"b;
	go to retrn;				/* set cd data name index to 1 */

actlbl (232):					/*action(146):*/
	cd_index = 0;
	go to retrn;				/* store data name for cd */

actlbl (233):					/*action(147):*/
	if cd_index > 11
	then go to na147;

	cd_index = cd_index + 1;
	go to act150;

na147:
	tf = 102;
	call diag;
	go to retrn;				/* store filler name for cd entry */

actlbl (234):					/*action(148):*/
	cd_index = cd_index + 1;

	if cd_index <= 11
	then do;
		cd_size (cd_index) = 6;
		substr (cd_name (cd_index), 1, 6) = "FILLER";
		go to retrn;
	     end;

	tf = 102;
	call diag;
	go to retrn;				/* generate cd input record based on options */

actlbl (235):					/*action(149):*/
	ll01 = "1"b;

	do i = 1 to 11;

	     if substr (cd_clauses, i, 1) ^= "0"b
	     then go to enda149;

	     cd_size (i) = 6;
	     substr (cd_name (i), 1, 6) = "FILLER";
enda149:
	end;

g149:						/*generate cd data name 0*/
	data_name.name_size = 6;

	substr (data_name.name, 1, data_name.name_size) = "FILLER";

	data_name.offset = 0;
	data_name.level = 1;
	data_name.item_length = 87;
	data_name.places_right = 0;
	ptr8 = addr (data_name.file_section);

	ptr8 -> bit72 = "0000100110100000000100000001000000000000000000000000000000000000"b;
	data_name.size = dn_constant + data_name.name_size;

	call write_dn;

	temp_bin1 = 0;

	call cdinit;				/*generate cd data names 1 - 4 */
	data_name.level = 2;
	data_name.item_length = 12;
	data_name.places_left = 12;

	ptr8 -> bit72 = "0000100001000000000100000001000000000000000000000000000000000000"b;

	do i = 1 to 4;
	     data_name.name_size = cd_size (i);

	     substr (data_name.name, 1, data_name.name_size) = substr (cd_name (i), 1, data_name.name_size);

	     data_name.size = dn_constant + data_name.name_size;

	     data_name.size = data_name.size + mod (-data_name.size, 4);

	     data_name.initial_ptr = data_name.size + 1;
	     ptr1 = addr (dn_ptr -> any_item (data_name.initial_ptr));

	     alphainit.initype.non_numeric = "1"b;
	     alphainit.length = 12;
	     alphainit.string = "            ";

	     data_name.size = data_name.size + aiv_constant + 12;
	     data_name.offset = temp_bin1;
	     temp_bin1 = temp_bin1 + 12;

	     call write_dn;
	end;

	data_name.initial_ptr = 0;			/* generate cd data name 5 */
	i = 5;
	data_name.item_length = 6;

	ptr8 -> bit72 = "0000100001000000010000000001000000000000000000000000100000000000"b;

	call gen_dn;				/* generate cd data name 6 */
	i = 6;
	data_name.item_length = 8;

	call gen_dn;				/* generate cd data name 7 */
	i = 7;
	data_name.item_length = 12;

	ptr8 -> bit72 = "0000100001000000000100000001000000000000000000000000000000000000"b;

	call gen_dn;				/* generae cd data name 8 */
	i = 8;
	data_name.item_length = 4;
	ptr8 -> bit72 = "0000100001000000010000000001000000000000000000000000100000000000"b;

	call gen_dn;				/* generate cd data name 9 */
	i = 9;
	data_name.item_length = 1;

	ptr8 -> bit72 = "0000100001000000000100000001000000000000000000000000000000000000"b;

	call gen_dn;				/* generate cd data name 10 */
	i = 10;
	data_name.item_length = 2;

	call gen_dn;				/* generate cd data name 11 */
	i = 11;
	data_name.item_length = 6;

	ptr8 -> bit72 = "0000100001000000010000000001000000000000000000000000100000000000"b;

	call gen_dn;
	go to retrn;

cdinit:
     proc;
	ptr4 = addr (cobol_wkbuf1_tbl);
	ptr4 -> cntbuf = 0;
	data_name.type = 9;
	data_name.def_line = cdtoken.def_line;
	data_name.column = cdtoken.column;
	data_name.file_num = cdno;
     end cdinit;



gen_dn:
     proc;
	data_name.name_size = cd_size (i);
	data_name.size = data_name.name_size + dn_constant;

	substr (data_name.name, 1, data_name.name_size) = substr (cd_name (i), 1, data_name.name_size);

	data_name.places_right = 0;

	data_name.places_left = data_name.item_length;


	data_name.offset = temp_bin1;
	temp_bin1 = temp_bin1 + data_name.item_length;

	call write_dn;

     end gen_dn;



write_dn:
     proc;
	rnt_size = data_name.size;

	call cobol_vdwf_sput (cobol_ntfp, fstatus, dn_ptr, rnt_size, w_key);

     end write_dn;


/* cd index 1 */

actlbl (236):					/*action(150):*/
	cd_index = 1;
act150:
	substr (cd_clauses, cd_index, 1) = "1"b;

	call cd_dn;
	go to retrn;				/* cd index = 2 */

actlbl (237):					/*action(151):*/
	cd_index = 2;
	go to act150;				/* cd index = 3 */

actlbl (238):					/*action(152):*/
	cd_index = 3;
	go to act150;				/* cd index = 4 */

actlbl (239):					/*action(153):*/
	cd_index = 4;
	go to act150;				/* cd index = 5 */

actlbl (240):					/*action(154):*/
	cd_index = 5;
	go to act150;				/* cd index = 6 */

actlbl (241):					/*action(155):*/
	cd_index = 6;
	go to act150;				/* cd index = 7 */

actlbl (242):					/*action(156):*/
	cd_index = 7;
	go to act150;				/* cd index = 8 */

actlbl (243):					/*action(157):*/
	cd_index = 8;
	go to act150;				/* cd index = 9 */

actlbl (244):					/*action(158):*/
	cd_index = 9;
	go to act150;				/* cd index = 10 */

actlbl (245):					/*action(159):*/
	cd_index = 10;
	go to act150;				/* cd index = 11 */

actlbl (246):					/*action(160):*/
	cd_index = 11;
	go to act150;


cd_dn:
     proc;
	if rw.type = 1				/*FILLER*/
	then do;
		cd_size (cd_index) = 6;
		substr (cd_name (cd_index), 1, 6) = "FILLER";
	     end;
	else do;
		cd_size (cd_index) = user_word.word_size;

		substr (cd_name (cd_index), 1, cd_size (cd_index)) = substr (user_word.word, 1, user_word.word_size);

	     end;

	return;
     end cd_dn;


/* generate cd output data names and indexed names */

actlbl (247):					/*action(161):*/
	ll01 = "1"b;

	do i = 1 to 5;
	     if substr (cd_clauses, i, 1) ^= "0"b
	     then go to enda161;

	     cd_size (i) = 6;
	     substr (cd_name (i), 1, 6) = "FILLER";
enda161:
	end;

	if save_cdo = 0
	then save_cdo = 1;				/* generate cd output data name 0 */
	data_name.name_size = 6;

	substr (data_name.name, 1, data_name.name_size) = "FILLER";

	data_name.offset = 0;
	data_name.level = 1;
	data_name.item_length = (10 + (13 * save_cdo));
	data_name.places_right = 0;
	ptr8 = addr (data_name.file_section);

	ptr8 -> bit72 = "0000100110100000000100000001000000000000000000000000000000000000"b;
	data_name.size = dn_constant + data_name.name_size;

	call write_dn;
	call cdinit;				/* generate cd output data name 1 2 */
	data_name.level = 2;
	temp_bin1 = 0;
	data_name.item_length = 4;

	ptr8 -> bit72 = "0000100001000000010000000001000000000000000000000000100000000000"b;

	do i = 1 to 2;
	     call gen_dn;
	end;

/* generate data name 3 for cd output */
	data_name.item_length = 2;
	data_name.places_left = 2;
	ptr8 -> bit72 = "0000100001000000000100000001000000000000000000000000000000000000"b;

	call gen_dn;

	if save_cdo > 1
	then ;
	else go to gend4;

	ptr8 -> bit72 = "000010001000000000010000000000000000000001000000000000000000000001"b;
	data_name.name_size = 6;

	substr (data_name.name, 1, data_name.name_size) = "FILLER";

	data_name.item_length = 13;
	data_name.places_left = 0;
	data_name.size = dn_constant + data_name.name_size;

	data_name.size = data_name.size + mod (-data_name.size, 4);

	ptr1 = addr (dn_ptr -> any_item (data_name.size + 1));
	data_name.occurs_ptr = data_name.size + 1;
	occurs.keyed = 0;
	occurs.key_number = 0;
	odim = 1;

	occurs.dimensions = 1;
	occurs.level.max (1) = save_cdo;
	occurs.level.struclength (1) = 13;
	occurs.level.cswd (1) = 0;

	if index_ct = 0
	then occurs.level.indexedno (odim) = 0;
	else do;
		counter2 = counter2 + 1;
		occurs.level.indexedno (odim) = counter2;
		data_name.indexed_by = "1"b;
	     end;
size161:
	data_name.size = data_name.size + occ_constant + occ_dim_constant;

	if index_ct <= 0
	then go to wcddn3;

/* write index name for occurs cd */
	ptr4 = addr (cobol_wkbuf2_tbl);
	ptr4 -> cntbuf2 = 0;

	indexname.type = 10;
	indexname.level = 99;
	indexname.index_no = counter2;
	indexname.min = occurs.level.min (1);
	indexname.max = occurs.level.max (1);

	do i = 6 to 5 + index_ct;
	     indexname.name_size = cd_size (i);


	     substr (indexname.name, 1, indexname.name_size) = substr (cd_name (i), 1, cd_size (i));

	     indexname.size = in_constant + indexname.name_size;
	     rnt_size = indexname.size;

	     call cobol_vdwf_sput (cobol_ntfp, fstatus, w2_ptr, rnt_size, w_key);

	end;

wcddn3:
	rnt_size = data_name.size;

	call cobol_vdwf_sput (cobol_ntfp, fstatus, dn_ptr, rnt_size, w_key);

/* generate data name 4 for cd output */
gend4:						/* save occurs extension in buffer2 */
	if save_cdo > 1
	then substr (cobol_wkbuf2_tbl.wkbuf2, 1, occ_constant + occ_dim_constant) =
		substr (cobol_wkbuf1_tbl.wkbuf1, data_name.occurs_ptr, occ_constant + occ_dim_constant);

	do i = 4 to 5;
	     data_name.name_size = cd_size (i);
	     data_name.size = dn_constant + data_name.name_size;

	     data_name.size = data_name.size + mod (-data_name.size, 4);

	     data_name.offset = temp_bin1;
	     substr (data_name.name, 1, data_name.name_size) = cd_name (i);

	     if i = 4
	     then do;
		     data_name.item_length = 1;
		     data_name.places_left = 1;
		end;
	     else do;
		     data_name.item_length = 12;
		     data_name.places_left = 12;
		end;

	     if save_cdo > 1
	     then do;

		     ptr8 -> bit72 = "0000100001000000000100000001000000000000010000000000000000000000"b;

/* inherit occurs extension */
		     data_name.occurs_ptr = data_name.size + 1;

		     substr (cobol_wkbuf1_tbl.wkbuf1, data_name.occurs_ptr, occ_constant + occ_dim_constant) =
			substr (cobol_wkbuf2_tbl.wkbuf2, 1, occ_constant + occ_dim_constant);

		     data_name.size = data_name.size + occ_constant + occ_dim_constant;
		     data_name.level = 3;

		end;
	     else ptr8 -> bit72 = "0000100001000000000100000001000000000000000000000000000000000000"b;

	     temp_bin1 = temp_bin1 + data_name.item_length;
	     rnt_size = data_name.size;

	     call cobol_vdwf_sput (cobol_ntfp, fstatus, dn_ptr, rnt_size, w_key);

	end;

	data_name.level = 2;

	if save_cdo > 1
	then do;
		save_wkey = w_key;
		w_key = save_fd;

		call cobol_vdwf_dget (cobol_ntfp, fstatus, cd_ptr, rnt_size, w_key);

		cd_ptr -> cdtoken.mdest = save_cdo;

		call cobol_vdwf_dput (cobol_ntfp, fstatus, cd_ptr, rnt_size, w_key);

		w_key = save_wkey;
	     end;

	go to retrn;				/* save integer for destination table */

actlbl (248):					/*action(162):*/
						/*[5.1-1]*/
	if record.type = 2
	then save_cdo = fixed (numeric_lit.literal);
	else save_cdo = 0;

	if fixed_common.comp_level < "3"
	then if save_cdo > 1
	     then do;
		     tf = 164;
		     call diag_level;
		end;
	go to retrn;

/* initialize cd output index names */

actlbl (249):					/*action(163):*/
	go to retrn;				/* generate index names for cd output */

actlbl (250):					/*action(164):*/
	index_ct = index_ct + 1;

	if 5 + index_ct <= 11
	then go to na164;

	tf = 95;
	call diag;
	go to retrn;

na164:
	cd_index = 5 + index_ct;

	call cd_dn;

	go to retrn;				/* save index names in 6 - 11 cd name array */

/* create occ_key item for odo key */

actlbl (251):					/*action(165):*/
	vector_map.subject_of_keyis = "1"b;
	prior_skey_rec = null_key;
	com2_ptr = addr (cobol_wkbuf2_tbl.wkbuf2);
	ptr4 = addr (cobol_wkbuf2_tbl);
	ptr4 -> cntbuf2 = 0;
	occ_key.next = null_key;
	occ_key.rec_no = save_01;
	occ_key.lineno = record.line;			/* write occ_key item into common */
	cm_ptr = com2_ptr;
	cm_size = occ_key_constant;

	call cobol_vdwf_sput (cobol_cmfp, fstatus, cm_ptr, cm_size, cm_key);

	if prior_occ_key ^= null_key
	then go to occ_key_next;

	fixed_common.search_keys = cm_key;
	prior_occ_key = cm_key;
	go to retrn;

occ_key_next:
	rcm_key = prior_occ_key;

	call cobol_vdwf_dget (cobol_cmfp, fstatus, cm_ptr, cm_size, rcm_key);

	com2_ptr = cm_ptr;
	occ_key.next = cm_key;

	call cobol_vdwf_dput (cobol_cmfp, fstatus, cm_ptr, cm_size, rcm_key);

	prior_occ_key = cm_key;
	go to retrn;

/* store qualifier for occ_key item */

actlbl (252):					/*action(166):*/
	call qualifier;

	if prior_qual_rec ^= null_key
	then go to skey_qual;

	rcm_key = prior_skey_rec;

	call cobol_vdwf_dget (cobol_cmfp, fstatus, cm_ptr, cm_size, rcm_key);

	skey_ptr = cm_ptr;
	skey_rec.qual = cm_key;

	call cobol_vdwf_dput (cobol_cmfp, fstatus, cm_ptr, cm_size, rcm_key);

	prior_qual_rec = cm_key;
	go to retrn;

skey_qual:
	call store_qualifier;
	go to retrn;

actlbl (253):					/* action(78) */
	fixed_common.init_cd = "1"b;

	go to retrn;

/*action(92):*/
	;

/*action(93):*/
	;

/*action(97):*/
	;

/*action(98):*/


retrn:
	return;

/*[4.0-1]*/
declare	cobol_ddsyntax$init_file_tab
			entry;

dcl	rn		fixed bin;
dcl	an		fixed bin;
dcl	max_poss_extensions fixed bin internal static init (314);
dcl	tf		fixed bin;
dcl	fstatus		bit (32);			/*io return code*/
dcl	null_func		ptr init (null ()) internal static;
dcl	null_key		char (5) internal static init ("00000");
dcl	ptr11		ptr;
declare	BIT8		bit (8) based;		/* [3.0-1] */
dcl	input_cd_string	char (16) based (ptr11);

dcl	output_cd_string	char (16) based (ptr11);

declare	cd_ptr		ptr;

dcl	1 input_cd_prefix_initval
			static,
	  2 cdtype	bit (1) init ("1"b),
	  2 usertype	bit (1) init ("1"b),
	  2 convert	bit (1) init ("1"b),
	  2 textln	fixed bin init (0),
	  2 mcount	fixed bin init (0),
	  2 seqno		fixed bin init (0);

dcl	1 output_cd_prefix_initval
			static,
	  2 cdtype	bit (1) init ("0"b),
	  2 usertype	bit (1) init ("1"b),
	  2 convert	bit (1) init ("1"b),
	  2 textln	fixed bin init (0),
	  2 dcount	fixed bin init (1),
	  2 seqno		fixed bin init (0);

declare	(addr, size, mod, substr, unspec, fixed)
			builtin;


%include cobol_ext_;

%include cobol_ext_ddsyn;
dcl	sv_ptr_auto	ptr;
%include cobol_special_dcls;
%include cobol_spec_constants;
dcl	1 shared_var	based (sv_ptr_auto),
%include cobol_shared_var;
%include cobol_non_static;
%include cobol_type9;
%include cobol_occurs;
%include cobol_fd_token;
declare	1 cdtoken		based (cdtoken_ptr),
%include cobol_TYPE13;
%include cobol_qual_rec;
%include cobol_obj_rec;
%include cobol_occ_key_rec;
%include cobol_report_rec;
%include cobol_rename_rec;
%include cobol_skey_rec;
%include cobol_file_key;
%include cobol_linage_rec;
%include cobol_linage_name_rec;
%include cobol_fixed_common;
%include cobol_file_table;
     end cobol_ddact2;
