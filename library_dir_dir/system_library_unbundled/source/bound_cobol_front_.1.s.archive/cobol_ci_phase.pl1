/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_ci_phase.pl1 Reformatted code to new Cobol standard.
                                                   END HISTORY COMMENTS */


/* Modified on 05/06/81 by FCH, [4.4-2], cobol_ciphase_data.incl.pl1 changed, BUG482(TR9781) */
/* Modified on 05/15/79 by FCH, [4.0-1], table size decreased */
/* Modified on 05/26/78 by FCH, [3.0-1], table size increased */
/* Modified since Version 3.0 */

/*{*/

/* format: style3 */
cobol_ci_phase:
     proc;

/*	This procedure scans rmin2 looking for initialize statements and statements
	containing the corresponding option. These statements are expanded and written
	into corrout							*/

/*}*/
/*[4.0-2]*/
dcl	size		builtin;			/*[4.0-2]*/
dcl	cobol$alloc	entry (fixed bin (35)) returns (ptr) ext;
						/*[4.0-2]*/
						/*[4.0-2]*/
	dir_ptr = cobol$alloc (size (dir_struct));

	infp = cobol_rmin2fp;
	outfp = cobol_x3fp;
	table1_2_size = 22000;			/*[4.0-1]*/
	on = "1"b;
	off = "0"b;
	eof = "0"b;
	dir_ptr1 = addr (dir1);
	dir_ptr2 = addr (dir2);
	initlz_tbl_ptr = addr (table1);
	input_ptr = null ();
	output_ptr = null ();
	gen_item_allocated = "0"b;
	initlz_items_allocated = "0"b;
	new_seg_bit = "0"b;
	poss_prior_err = "1"b;
	without_on_bit = "0"b;			/*  syntax  ON SIZE ERROR  witout  ON  */
	fixed_common.phase_name = "CORRES";
	err_num = 0;
	substr (err_image, 1, 1) = "*";

find_bos:
	if err_num ^= 0
	then do;
		go to err (err_num);

err (1):
		poss_prior_err = "0"b;
		go to err_end;

err (2):
		err_image = "identifier*";
		go to err_end;

err (3):
		err_image = "(*";
		go to err_end;

err (4):
		poss_prior_err = "0"b;
		go to err_end;

err (5):
		go to err_end;

err (6):
		go to err_end;

err (7):
		go to err_end;

err (8):
		go to err_end;

err (9):
		go to err_end;

err (10):
		err_image = "illegal level number*";
		poss_prior_err = "0"b;
		go to err_end;

err (11):
		go to err_end;

err (12):
		go to err_end;

err (13):
		poss_prior_err = "0"b;
		go to err_end;

err (14):
		go to err_end;

err (15):
		call err_pro;
		return;

err (16):
		poss_prior_err = "0"b;
		go to err_end;

err (17):
		poss_prior_err = "0"b;
		go to err_end;

err (18):
		poss_prior_err = "0"b;
		go to err_end;

err (19):
		poss_prior_err = "0"b;
		go to err_end;

err (20):
		poss_prior_err = "0"b;
		go to err_end;

err (21):
		poss_prior_err = "0"b;
		go to err_end;

err (22):
		err_image = "occurs depending on*";
		poss_prior_err = "0"b;
		go to err_end;

err (23):
		go to err_end;

err (24):
		go to err_end;

err (25):
		poss_prior_err = "0"b;
		go to err_end;

err (26):
		poss_prior_err = "0"b;
		go to err_end;

err (27):
		poss_prior_err = "0"b;
		go to err_end;

err (28):
		poss_prior_err = "0"b;
		go to err_end;

err (29):
		err_image = "numeric literal or identifier*";
		err_num = 2;
		poss_prior_err = "0"b;
		go to err_end;

err (30):
		err_image = "proper index name*";
		err_num = 2;
		poss_prior_err = "0"b;
		go to err_end;

err (31):
		err_image = """+"",""-"", numeric literal or indexname*";
		err_num = 2;
		go to err_end;

err (32):
		err_image = "numeric_literal*";
		err_num = 2;
		go to err_end;

err (33):
		err_image = "proper subscript*";
		err_num = 2;
		go to err_end;

err (34):
		err_image = "identifier, literal or proper figurative constant*";
		err_num = 2;
		go to err_end;

err (35):
		err_image = "from*";
		err_num = 3;
		go to err_end;

err (36):
		err_image = "to*";
		err_num = 3;
		go to err_end;

err (37):
		err_image = ")*";
		err_num = 3;
		go to err_end;

err (38):
		err_image = "data or by*";
		err_num = 3;
		go to err_end;

err (39):
		err_image = "by*";
		err_num = 3;
		go to err_end;

err (40):
		err_image = "usage is index*";
		err_num = 22;
		poss_prior_err = "0"b;
		go to err_end;
err (41):
		err_image = "usage is index*";
		err_num = 10;
		poss_prior_err = "0"b;
		go to err_end;
err (42):
		poss_prior_err = "0"b;
		err_num = 29;
		go to err_end;
err (43):
		poss_prior_err = "0"b;
		err_num = 30;
		go to err_end;
err_end:
		recov = "1"b;
		call err_pro;

		if eof
		then return;

		err_num = 0;

	     end;

	else do;

		curr_dim = 1;
		fixbin15 = 0;

		fixbin_diff = "0"b;			/** initialize for statement **/
		lk_ahd_index = 0;
		ose_exists = "0"b;
		recovering = "0"b;
		begin_i = 1;
		top_token_stack = 1;
		sending_op = "1"b;
		code = 1;
		next_free_column = 8;

		call corr_in;			/*read until beginning of a statment is recognized --
			    corr_in looks for add, subtract, or move verb */

		if eof
		then return;

		if initlz_swt
		then call initialize_statement;
		else do;

			call add_token;

			gen_ptr (1) = token_stack_ptr;
			end_i = 2;		/*skip 1 to store sending operand */
			code = 0;

			call corr_in;


			if eof
			then return;

			if reserved_word.type = 1 & reserved_word.key = 524
						/* corresponding */
			then do;
				if fixed_common.comp_level ^= "5" & fixed_common.comp_level < "3"
				then do;
					message.number = 19;
					message.line = reserved_word.line;
					message.column = reserved_word.column;
					message.size = 32;
					message.run = 9;

					call cobol_c_list (addr (message));

					message.run = 8;
				     end;
				recursive_bit = "0"b;
				call corres_option (0);
			     end;

			else do;

				output_ptr = token_stack_ptr;

				call cobol_swf_put (outfp, fst, output_ptr, output_ptr -> reserved_word.size);


				call remove_token;

				output_ptr = input_ptr;

				call cobol_swf_put (outfp, fst, output_ptr, output_ptr -> reserved_word.size);


				call corr_in;

				if eof
				then return;

			     end;

		     end;

	     end;

	go to find_bos;



corres_option:
     proc (mode);

declare	mode		fixed bin;

more:
	if mode = 0
	then do;

		nu_line = reserved_word.line;		/* add for numerot.line in output */
		first_pair = "1"b;

		call corr_in;

		if eof
		then do;
			err_num = 15;
			return;
		     end;

	     end;

	if data_name.type ^= 9			/* user word */
	then do;

		err_num = 2;
		return;
	     end;

	if data_name.elementary
	then do;
		err_num = 16;			/*MUST BE GROUP NAME*/
		return;
	     end;

	if data_name.level > 49 & data_name.level ^= 66	/* illegal level number */
	then do;
		err_num = 10;
		return;
	     end;

	if data_name.usage_index			/*USAGE IS INDEX*/
	then do;
		err_num = 41;
		return;
	     end;

	if data_name.subscripted			/*OCCURS*/
	then do;
		ptr1 = addr (any_item (data_name.occurs_ptr));
		orig_dimen = ptr1 -> occurs.dimensions;
	     end;
	else orig_dimen = 0;

	if sending_op
	then do;
		curr_tbl_ptr = addr (table1);		/* sending operand */
		curr_dir_ptr = addr (dir1);
		dir_num = 0;
	     end;
	else do;
		curr_tbl_ptr = addr (table2);		/* receiving operand */
		curr_dir_ptr = addr (dir2);
		dir_num = 1;
	     end;

	main_item_ptr = input_ptr;

	curr_dir_index = 0;
	curr_tbl_index = 1;
	curr_stk_index = 1;

	rdf_illegal = ^data_name.s_of_rdf;

get_next_group_member:
	call corr_in;

	if eof
	then do;
		err_num = 15;
		return;
	     end;

	if data_name.type = 9
	then /* user word */
	     do;

		if data_name.filler_item | (rdf_illegal & data_name.s_of_rdf)
		     | (^move_swt & data_name.elementary & ^data_name.numeric) | data_name.usage_index
		then go to get_next_group_member;

		if data_name.subscripted
		then do;
			ptr1 = addr (any_item (data_name.occurs_ptr));

			if ptr1 -> occurs.dimensions > orig_dimen
			then go to get_next_group_member;
		     end;

		if curr_dir_index = 512		/*[4.0-2]*/
		then do;
			err_num = 21;
			return;
		     end;

		curr_dir_index = curr_dir_index + 1;

		tbl_item_ptr = addr (curr_table (curr_tbl_index));
		substr (tbl_item_ptr -> record, 1, recsize) = substr (input_ptr -> record, 1, recsize);
		curr_dir.tbl (curr_dir_index) = curr_tbl_index;
		curr_dir.dir (curr_dir_index) = 0;
		curr_level = data_name.level;

/*[4.0-2]*/
		if curr_tbl_index + recsize + mod (-recsize, 4) > 100000
						/*  */
		then do;
			err_num = 19;
			return;
		     end;

		curr_tbl_index = curr_tbl_index + recsize + mod (-recsize, 4);

		if curr_dir_index = 1
		then do;
			stack.level (1) = curr_level;
			stack.stk_to_dir (1) = 1;

		     end;

		else if curr_level > stack.level (curr_stk_index)
		then do;

			if curr_stk_index = 10
			then do;
				err_num = 20;
				return;
			     end;
			curr_stk_index = curr_stk_index + 1;
			stack.stk_to_dir (curr_stk_index) = curr_dir_index;
			stack.level (curr_stk_index) = curr_level;

		     end;

		else do;
			call set_links;

			if err_num ^= 0
			then return;

		     end;


		go to get_next_group_member;

	     end;



	if curr_stk_index > 1
	then do;
		curr_level = stack.level (1);
		curr_dir_index = curr_dir_index + 1;

		curr_dir.tbl (curr_dir_index) = 0;
		curr_dir.dir (curr_dir_index) = 0;

		call set_links;

		if err_num ^= 0
		then return;


		if dir_num = 0
		then curr_dir.dir (stack_loc) = 0;

	     end;

	if orig_dimen > 0
	then do;					/* subscripting required */

		call res_test (187, 3);
		if err_num ^= 0
		then return;

		call begin_subscripts;

		if err_num ^= 0
		then return;

		call corr_in;

		if eof
		then do;
			err_num = 15;
			return;
		     end;

	     end;
	if reserved_word.type ^= 26
	then do;
		err_num = 11;
		return;
	     end;

	if ^sending_op
	then do;
		call check_for_further;

		if err_num ^= 0
		then return;

		if check_res = 0
		then return;

		go to get_next_group_member;

	     end;

	end_dir1_index = curr_dir_index;

	call corr_in;

	if eof
	then do;
		err_num = 15;
		return;
	     end;

	if subtract_swt
	then do;
		call res_test (111, 35);
		if err_num ^= 0
		then return;
	     end;

	else do;
		call res_test (170, 36);
		if err_num ^= 0
		then return;
	     end;



	call add_token;

	end_i = end_i + 1;
	gen_ptr (end_i) = token_stack_ptr;
	end_i = end_i + 1;
	recv_i = end_i;
	sending_op = "0"b;
	mode = 0;

	go to more;

     end;

res_test:
     proc (resnum, errnum);

declare	(resnum, errnum)	fixed bin;

	if reserved_word.type ^= 1
	then do;
		err_num = errnum;
		return;
	     end;

	if reserved_word.key ^= resnum
	then do;
		err_num = errnum;
		return;
	     end;

	err_num = 0;
     end;

set_links:
     proc;

	do while (curr_level < stack.level (curr_stk_index));

	     curr_dir.dir (stack.stk_to_dir (curr_stk_index)) = stack.stk_to_dir (curr_stk_index - 1);
	     curr_stk_index = curr_stk_index - 1;

	end;

	if curr_level = stack.level (curr_stk_index)
	then do;
		stack_loc = stack.stk_to_dir (curr_stk_index);
		curr_dir.dir (stack_loc) = curr_dir_index;
		stack.stk_to_dir (curr_stk_index) = curr_dir_index;
		stack.level (curr_stk_index) = curr_level;
	     end;
	else do;
		err_num = 13;
		err_image = "sending*";
		return;
	     end;
     end;

begin_subscripts:
     proc;

	indexname_subscr_sw = "0"b;
	dataname_subscr_sw = "0"b;

	call add_token;				/*leftparen*/

	if ^initlz_swt
	then do;
		end_i = end_i + 1;
		gen_ptr (end_i) = token_stack_ptr;
	     end;
	else subscr_directory.tokn_ptr (subscr_dir_index) = token_stack_ptr;

	call corr_in;

	if eof
	then do;
		err_num = 15;
		return;
	     end;

	subscr_cnt = 0;

pick_up_subscr:
	if numeric_lit.type = 2
	then do;

		if numeric_lit.sign = "-"
		then do;
			err_num = 17;
			return;
		     end;

		subscr_cnt = subscr_cnt + 1;

add_subscript:
		call add_token;

		if ^initlz_swt
		then do;
			end_i = end_i + 1;
			gen_ptr (end_i) = token_stack_ptr;
		     end;

		call corr_in;

		if eof
		then do;
			err_num = 15;
			return;
		     end;

test_subscr_cnt:
		if reserved_word.type = 1 & reserved_word.key = 188
		then rparen = "1"b;
		else rparen = "0"b;

		if subscr_cnt = ptr1 -> occurs.dimensions
		then do;

test_rparen:
			if rparen
			then do;

				call add_token;

				if ^initlz_swt
				then do;
					end_i = end_i + 1;
					gen_ptr (end_i) = token_stack_ptr;
				     end;
				else do;

					call corr_in;

					if eof
					then err_num = 15;
				     end;
				return;
			     end;

			err_num = 37;
			return;
		     end;

		else do;
			if rparen
			then do;
				err_num = 42;
				return;
			     end;
			go to pick_up_subscr;
		     end;

	     end;




	if data_name.type = 9
	then do;

		if indexname_subscr_sw
		then do;
			err_num = 4;
			return;
		     end;
		else dataname_subscr_sw = "1"b;
	     end;

	else if index_name.type = 10
	then do;

		if ^(main_item_ptr -> data_name.indexed_by)
						/*INDEXING NOT ALLOWED*/
		then do;
			err_num = 2;
			return;
		     end;				/*test is this the right index name for this dimension*/

		if ptr1 -> occurs.level.indexedno (subscr_cnt + 1) ^= index_name.index_no
		then do;
			err_num = 28;
			return;
		     end;

		if dataname_subscr_sw
		then do;
			err_num = 4;
			return;
		     end;

		indexname_subscr_sw = "1"b;

		if initlz_swt
		then subscr_directory.index_ct (subscr_dir_index) = subscr_directory.index_ct (subscr_dir_index) + 1;

	     end;

	else do;
		err_num = 33;
		return;
	     end;

	subscr_cnt = subscr_cnt + 1;

	call add_token;

	if ^initlz_swt
	then do;
		token_stack_ptr -> index_name.searched = "0"b;
		token_stack_ptr -> index_name.duplicate = "0"b;
		end_i = end_i + 1;
		gen_ptr (end_i) = token_stack_ptr;
	     end;

/*	if ^initlz_swt then if ^sending_op then

		do while(reserved_word.type ^= 26);
		
			call corr_in;
	
			if eof then	do;	err_num = 15;
						return;
					end;
		
		end;	*/

	call corr_in;

	if eof
	then do;
		err_num = 15;
		return;
	     end;

	if dataname_subscr_sw
	then go to test_subscr_cnt;

	if reserved_word.type ^= 1
	then do;

		if subscr_cnt = ptr1 -> occurs.dimensions
		then do;
			err_num = 37;
			return;
		     end;
		go to pick_up_subscr;
	     end;

	if reserved_word.key ^= 182 /*+*/ & reserved_word.key ^= 183
						/*-*/
	then do;

		if subscr_cnt = ptr1 -> occurs.dimensions
		then do;
			if reserved_word.key = 188
			then rparen = "1"b;
			else rparen = "0"b;
			go to test_rparen;
		     end;

		err_num = 30;
		return;
	     end;

	if ^initlz_swt
	then do;

		call add_token;

		end_i = end_i + 1;
		gen_ptr (end_i) = token_stack_ptr;
	     end;

	call corr_in;

	if eof
	then do;
		err_num = 15;
		return;
	     end;

	if numeric_lit.type ^= 2
	then do;
		err_num = 32;
		return;
	     end;

	if input_ptr -> numeric_lit.sign ^= " "
	then do;
		err_num = 18;
		return;
	     end;
	go to add_subscript;

     end;

check_for_further:
     proc;

	check_res = 0;

/* look for rounded, on size error */

	if move_swt
	then do;
		call commence_search;
		return;
	     end;

	call corr_in;

	if eof
	then do;
		call commence_search;
		return;
	     end;

	if data_name.type = 9
	then do;
		recursive_bit = "1"b;
		check_res = 1;
		return;
	     end;					/*  on  ADD  or  SUBTRACT  */

	if reserved_word.type ^= 1
	then do;
		call commence_search;
		return;
	     end;


	if reserved_word.key = 156
	then do;					/*rounded*/

		call add_token;

		end_i = end_i + 1;
		gen_ptr (end_i) = token_stack_ptr;

		call corr_in;

		if eof
		then do;
			call commence_search;
			return;
		     end;

		if reserved_word.type ^= 1
		then do;
			call commence_search;
			return;
		     end;

	     end;

	if reserved_word.key ^= 134
	then do;					/*on*/
		without_on_bit = "1"b;
		xst = 1;
	     end;

	else do;

		call add_token;

		lk_ahd_index = 1;
		lk_ahd_ptr (1) = token_stack_ptr;

		call corr_in;

		if eof
		then do;
			call commence_search;
			return;
		     end;

		xst = 2;

		if reserved_word.type ^= 1
		then do;
			call commence_search;
			return;
		     end;

	     end;

	if reserved_word.key ^= 161
	then do;					/*size*/

		without_on_bit = "0"b;

		call commence_search;
		return;

	     end;

	call add_token;

	lk_ahd_index = xst;
	lk_ahd_ptr (xst) = token_stack_ptr;

	call corr_in;

	if eof | reserved_word.type ^= 1
	then do;
		call commence_search;
		return;
	     end;


	if reserved_word.key ^= 3
	then do;
		call commence_search;
		return;
	     end;


	if without_on_bit
	then without_on_bit = "0"b;
	else call remove_token;


	call remove_token;

	lk_ahd_index = 0;

	call corr_in;

	if eof
	then do;
		err_num = 15;
		return;
	     end;

	ose_exists = "1"b;				/* APPEND gen_item TO NAME TABLE FILE */

	if ^gen_item_allocated & ^initlz_items_allocated
	then do;
		fixbin24 = gen_item_t1.size;

		call allocate_item (fixbin24, 0, 0, off, off, off, on, off, off, alloc_seg, alloc_offset);

		gen_item_t1.seg_num = alloc_seg;
		gen_item_t1.offset = alloc_offset;
		gen_item_allocated = "1"b;
	     end;

	if initlz_items_allocated
	then do;
		gen_item_t1.length = 1;
		gen_item_t1.places_left = 1;
	     end;

	call commence_search;

     end;



commence_search:
     proc;

	if end_dir1_index = 0 | curr_dir_index = 0
	then do;
		call error1;
		call emit;
		return;
	     end;

	loc1 = 1;
	loc2 = 1;
	null_match = "1"b;

after_initialization:
	tbl_item_ptr1 = addr (table1 (dir1.tbl (loc1)));

	name1 = blank_name;

	substr (name1, 1, tbl_item_ptr1 -> data_name.name_size) =
	     substr (tbl_item_ptr1 -> data_name.name, 1, tbl_item_ptr1 -> data_name.name_size);

	trial = 0;

set_name2:
	tbl_item_ptr2 = addr (table2 (dir2.tbl (loc2)));

	name2 = blank_name;

	substr (name2, 1, tbl_item_ptr2 -> data_name.name_size) =
	     substr (tbl_item_ptr2 -> data_name.name, 1, tbl_item_ptr2 -> data_name.name_size);

	if name1 = name2
	then do;

		if (tbl_item_ptr1 -> data_name.elementary & tbl_item_ptr2 -> data_name.elementary)
		     | ((tbl_item_ptr1 -> data_name.elementary | tbl_item_ptr2 -> data_name.elementary)
		     & move_swt = "1"b)
		then do;

			if first_pair
			then do;
				fixbin15 = tbl_item_ptr1 -> data_name.column;
				cv_string = bin_to_char (fixbin15, cvindex);
				cvbd_1 = substr (cv_string, 7, 4);
				dcl_col (loc1) = substr (cvbd_1, 2, 3);
				fixbin15 = tbl_item_ptr1 -> data_name.line;
				cv_string = bin_to_char (fixbin15, cvindex);
				cvbd_1 = substr (cv_string, 7, 4);
				dcl_line (loc1) = cvbd_1;
			     end;

			gen_ptr (2) = tbl_item_ptr1;
			gen_ptr (recv_i) = tbl_item_ptr2;
						/*... CORROUTPUT ALGORITHM...*/

/* GENERATE MINPRAL TOKEN STREAM */

			if ose_exists
			then do;

				if null_match
				then do;		/*first time through */

/*GENERATE STREAM: move zero to generated field*/

					end_i = end_i + 1;
					begin_i = end_i;
					ose_gen_begin_i = begin_i;
					gen_ptr (end_i) = addr (res_wd_move);
					end_i = end_i + 1;
					gen_ptr (end_i) = addr (num_lit_zero);
					end_i = end_i + 1;
					gen_ptr (end_i) = addr (res_wd_to);
					end_i = end_i + 1;
					gen_ptr (end_i) = addr (gen_item_t1);

					call stream_gen;

				     end;

				end_i = ose_gen_begin_i - 1;
				begin_i = 1;

			     end;

/* GENERATE SOURCE LINE IMAGE */
			set_new_col = "1"b;

			call stream_gen;

			if ose_exists
			then do;			/*GENERATE STREAM: on size error move 1 to generated_field*/

				if null_match
				then do;		/*set up gen_ptrs*/
					begin_i = end_i + 1;
					ose_gen_begin_i = begin_i;
					end_i = begin_i;

					gen_ptr (end_i) = addr (res_wd_on);
					end_i = end_i + 1;
					gen_ptr (end_i) = addr (res_wd_size);
					end_i = end_i + 1;
					gen_ptr (end_i) = addr (res_wd_error);
					end_i = end_i + 1;
					gen_ptr (end_i) = addr (res_wd_move);
					end_i = end_i + 1;
					gen_ptr (end_i) = addr (num_lit_one);
					end_i = end_i + 1;
					gen_ptr (end_i) = addr (res_wd_to);
					end_i = end_i + 1;
					gen_ptr (end_i) = addr (gen_item_t1);
					end_i = end_i + 1;
					gen_ptr (end_i) = addr (res_wd_dot);
				     end;
				else do;
					begin_i = ose_gen_begin_i;
					end_i = begin_i + 7;
				     end;

				call stream_gen;

				end_i = begin_i - 1;
			     end;

			null_match = "0"b;

			if ^recursive_bit
			then do;

				if tbl_item_ptr1 -> data_name.searched
				then do;
					err_num = 13;
					err_image = "sending*";
					return;

				     end;
				else tbl_item_ptr1 -> data_name.searched = "1"b;

				if tbl_item_ptr2 -> data_name.searched
				then do;
					err_num = 13;
					err_image = "receiving*";
					return;

				     end;
				else tbl_item_ptr2 -> data_name.searched = "1"b;

			     end;

			trial = 1;

			go to find_new_match;

		     end;

		if tbl_item_ptr1 -> data_name.elementary | tbl_item_ptr2 -> data_name.elementary
		then go to find_new_match;

/* if here, then neither was elementary */
		loc1 = loc1 + 1;
		loc2 = loc2 + 1;

		go to after_initialization;

	     end;					/* end of matching names */

find_new_match:
	link2 = dir2.dir (loc2);

	if link2 > loc2
	then do;
		loc2 = link2;

		if dir2.tbl (loc2) ^= 0
		then go to set_name2;
		else link2 = dir2.dir (loc2);
	     end;

	if trial = 0
	then do;
		trial = 1;
		loc2 = link2 + 1;
		go to set_name2;
	     end;

	link1 = dir1.dir (loc1);
	ln = link1 - loc1;
declare	ln		fixed bin (24);

	if ln > 0
	then do;
		loc1 = link1;
		loc2 = link2 + 1;
		go to after_initialization;
	     end;
	else do while (link1 < loc1);

		if link1 ^= 0
		then do;
			loc1 = link1;
			link1 = dir1.dir (loc1);
		     end;

		if link1 = 0
		then do;

			if null_match
			then call error1;

			call emit;

			return;

		     end;
	     end;

	loc1 = link1;

	do while (link2 < loc2);

	     loc2 = link2;
	     link2 = dir2.dir (loc2);

	end;

	loc2 = link2;

	go to after_initialization;

     end;


error1:
     proc;

	err_num = 1;
	poss_prior_err = "0"b;
	recov = "0"b;

	call err_pro;

     end;

emit:
     proc;

	if move_swt
	then do;

		call corr_in;

		if eof
		then return;

		if data_name.type = 9
		then do;
			null_match = "1"b;
			first_pair = "0"b;

			do n = 1 to end_dir1_index;
			     tbl_item_ptr1 = addr (table1 (dir1.tbl (n)));
			     tbl_item_ptr1 -> data_name.searched = "0"b;
			end;

			end_i = recv_i;
			call corres_option (1);
		     end;

	     end;

	else do;

		if ose_exists & ^null_match = "1"b
		then do;

/*GENERATE STREAM: if gen_item = 1 then*/

			begin_i = 1;
			end_i = 4;

			gen_ptr (1) = addr (res_wd_if);
			gen_ptr (2) = addr (gen_item_t1);
			res_wd_greater.key = 102;
			gen_ptr (3) = addr (res_wd_greater);
			gen_ptr (4) = addr (num_lit_one);

			call stream_gen;

		     end;

	     end;
     end;



initialize_statement:
     proc;

	err_num = 0;

	nu_line = reserved_word.line;
	n_array = 1;
	gen_label_def.def_line = nu_line;
	gen_label_ref.def_line = nu_line;
	gen_label_def.name = "NONAME0000";
	gen_label_ref.name = "NONAME0000";
	gen_label_def.section_num = section_number;
	gen_label_ref.section_num = section_number;
	second_time = "0"b;
	array_init_bit = "0"b;
	relecture = "0"b;
	sending_op = "0"b;
	end_initlz_tbl_index = 1;
	subscr_dir_index = 0;
	code = 0;

	call corr_in;

	if eof
	then do;
		err_num = 15;
		return;
	     end;

	if data_name.type ^= 9
	then do;
		err_num = 2;
		return;
	     end;

check_main_initlz_traits:
	if data_name.usage_index
	then do;					/* USAGE IS INDEX */
		err_num = 40;
		return;
	     end;

	if data_name.subscripted
	then do;					/* OCCURS */
		main_item_subscripted = "1"b;

		if data_name.occurs_do
		then do;				/* OCCURS DEPENDING ON  */
			err_num = 22;
			return;
		     end;

/* add item to subscript directory */

		if subscr_dir_index = 100
		then do;
			err_num = 28;
			return;
		     end;

		subscr_dir_index = subscr_dir_index + 1;
		subscr_directory.index_ct (subscr_dir_index) = 0;
		subscr_directory.tokn_ptr (subscr_dir_index) = null ();
		subscr_directory.sufx_ptr (subscr_dir_index) = null ();
	     end;

	else main_item_subscripted = "0"b;

/*add item to initlz_item_tbl*/

	main_item_ptr = addr (initlz_item_tbl (end_initlz_tbl_index));
	recsize2 = recsize + mod (-recsize, 4);

	if end_initlz_tbl_index + recsize2 >= table1_2_size
	then do;
		err_num = 27;
		return;
	     end;

	main_item_index = end_initlz_tbl_index;
	end_initlz_tbl_index = end_initlz_tbl_index + recsize2;
	substr (main_item_ptr -> record, 1, recsize) = substr (input_ptr -> record, 1, recsize);

	if main_item_subscripted
	then do;
		req_sub = main_item_ptr -> occurs.dimensions;
		ptr1 = addr (main_item_ptr -> any_item (main_item_ptr -> data_name.occurs_ptr));
		subscr_directory.sufx_ptr (subscr_dir_index) = ptr1;
	     end;
	else req_sub = 0;

	if data_name.elementary
	then do;
		main_item_ptr -> data_name.searched = "1"b;

		call corr_in;

		if eof
		then do;
			err_num = 15;
			return;
		     end;
		if reserved_word.type = 1
		then go to sub_ref;

		if reserved_word.type ^= 26
		then do;

			if data_name.type = 9
			then do;

				if data_name.subscripted
				then n_array = n_array + 1;
				go to get1;

			     end;

			err_num = 23;
			return;
		     end;
		go to got_end_initlz_opnd;

	     end;

	main_item_ptr -> data_name.searched = "0"b;

get_nxt_initlz_member:
	call corr_in;

	if eof
	then do;
		err_num = 15;
		return;
	     end;

	if data_name.type ^= 9
	then do;
		if reserved_word.type = 1
		then go to sub_ref;

		if reserved_word.type ^= 26
		then go to get_nxt_initlz_member;
		else go to got_end_initlz_opnd;
	     end;

get1:
	if data_name.occurs_do
	then do;					/*OCCURS DEPENDING ON*/

		if main_item_subscripted
		then subscr_dir_index = subscr_dir_index - 1;

		end_initlz_tbl_index = main_item_index;
		go to get_nxt_initlz_member;


	     end;

	if ^data_name.usage_index & ^data_name.filler_item & ^data_name.s_of_rdf
	then do;

		ptr2 = addr (initlz_item_tbl (end_initlz_tbl_index));
		recsize2 = recsize + mod (-recsize, 4);
		end_initlz_tbl_index = end_initlz_tbl_index + recsize2;

		if end_initlz_tbl_index >= table1_2_size
		then do;
			err_num = 27;
			return;
		     end;

		substr (ptr2 -> record, 1, recsize) = substr (input_ptr -> record, 1, recsize);

	     end;

	go to get_nxt_initlz_member;

sub_ref:
	if reserved_word.key ^= 187			/* ( */
	then do;
		err_num = 28;
		return;
	     end;

sub_ref_1:
	call begin_subscripts;

	if err_num ^= 0
	then return;

got_end_initlz_opnd:
	ptr2 = addr (initlz_item_tbl (end_initlz_tbl_index));
	recsize2 = recsize + mod (-recsize, 4);
	end_initlz_tbl_index = end_initlz_tbl_index + recsize2;

	if end_initlz_tbl_index >= table1_2_size
	then do;
		err_num = 27;
		return;
	     end;					/* type 26 token delimits group */

	substr (ptr2 -> record, 1, recsize) = substr (input_ptr -> record, 1, recsize);

	call corr_in;

	if eof
	then do;
		err_num = 15;
		return;
	     end;

	if data_name.type = 9
	then do;
		n_array = n_array + 1;
		array_init_bit = "1"b;
		go to check_main_initlz_traits;
	     end;

second_half_initlz:					/* assumes token already retrieved */
						/* this type_26 token, immediately following the last group terminator token
   which was also a type_26 token, signals the end of the table */
						/* if no items were entered in table, it contains only this type_26 token
   signalling an empty table */
	ptr2 = addr (initlz_item_tbl (end_initlz_tbl_index));
	recsize2 = type_26_token.size;
	ptr1 = addr (type_26_token);
	recsize2 = recsize2 + mod (-recsize2, 4);
	end_initlz_tbl_index = end_initlz_tbl_index + recsize2;

	if end_initlz_tbl_index >= table1_2_size
	then do;
		err_num = 27;
		return;
	     end;

	substr (ptr2 -> record2, 1, recsize2) = substr (ptr1 -> record2, 1, recsize2);
	ptr2 = addr (initlz_item_tbl (1));

	call corr_in;

	if eof
	then do;
		err_num = 15;
		return;
	     end;

	if reserved_word.type ^= 1 | reserved_word.key ^= 152
						/*REPLACING*/
	then do;
		defaults = "1"b;

/* want not to retrieve another token for bos */

		subscr_dir_index = 0;
		go to gen_initlz_code;
	     end;

	defaults = "0"b;
	sending_op = "1"b;

	call corr_in;

	if eof
	then do;
		err_num = 15;
		return;
	     end;

	if reserved_word.type ^= 1
	then do;
		err_num = 23;
		return;
	     end;

	if reserved_word.key = 131			/*NUMERIC*/
	then category = 18;

	else if reserved_word.key = 132		/*NUMERIC-EDITED*/
	then category = 19;

	else if reserved_word.key = 75		/*ALPHANUMERIC*/
	then category = 20;

	else if reserved_word.key = 76		/*ALPHANUMERIC-EDITED*/
	then category = 21;

	else if reserved_word.key = 74		/*ALPHABETIC*/
	then category = 22;

	else do;
		err_num = 23;
		return;
	     end;


	call corr_in;

	if eof
	then do;
		err_num = 15;
		return;
	     end;

	if reserved_word.type ^= 1
	then do;
		err_num = 38;
		return;
	     end;

	if reserved_word.key = 196
	then do;					/*DATA*/

		call corr_in;

		if eof
		then do;
			err_num = 15;
			return;
		     end;

		if reserved_word.type ^= 1
		then do;
			err_num = 39;
			return;
		     end;
	     end;

	if reserved_word.key ^= 82			/*BY*/
	then do;
		err_num = 39;
		return;
	     end;

	call corr_in;

	if eof
	then do;
		err_num = 15;
		return;
	     end;

	if reserved_word.type = 1
	then do;

		if reserved_word.key = 73
		then do;				/* lit. preceded by ALL key word */

			call corr_in;

			if eof
			then do;
				err_num = 15;
				return;
			     end;

			if reserved_word.type = 3
			then do;
				input_ptr -> alphanum_lit.all_lit = "1"b;
				go to tst_alph_cat;
			     end;
		     end;
	     end;

	if numeric_lit.type = 2
	then do;

tst_num_cat:
		if category ^= 18 & category ^= 19
		then do;
			err_num = 26;
			return;
		     end;
store_send_op:
		call add_token;

		send_op_ptr = token_stack_ptr;

		call corr_in;

		if eof
		then do;
			err_num = 15;
			return;
		     end;

		if reserved_word.key = 189
		then do;
			call corr_in;
			if eof
			then do;
				err_num = 15;
				return;
			     end;
		     end;

		subscr_dir_index = 0;

		go to gen_initlz_code;

	     end;

	if reserved_word.type = 3
	then do;					/*alphanumeric literal*/

tst_alph_cat:
		if category = 18 | category = 19
		then do;
			err_num = 26;
			return;
		     end;
		go to store_send_op;
	     end;

	if data_name.type = 9
	then do;
		descr_ptr = addr (data_name.file_section);

		if ^(description (category))
		then do;
			err_num = 26;
			return;
		     end;

		if ^(data_name.subscripted)		/*occurs*/
		then go to store_send_op;

		subscr_dir_index = subscr_dir_index + 1;

/*not used, but prevents overlaying of prev area by subscript processing*/

		call add_token;

		send_op_ptr = token_stack_ptr;

		call corr_in;

		if eof
		then do;
			err_num = 15;
			return;
		     end;

		if reserved_word.type = 1
		then if reserved_word.key = 187	/* ( */
		     then go to sub_ref_1;

		     else do;
			     err_num = 3;
			     return;
			end;
	     end;

	if reserved_word.type = 1
	then do;

		if reserved_word.key = 180		/*zeroes*/
		then go to tst_num_cat;
		if reserved_word.key = 192		/*spaces*/
		then go to tst_alph_cat;
	     end;

	err_num = 34;

	return;

gen_initlz_code:
	if subscr_cnt ^= req_sub
	then do;
		err_num = 43;
		return;
	     end;

	array_init_bit = "0"b;

more_code:
	if ptr2 -> reserved_word.type = 26
	then return;				/*  was  end_of_initlz_tbl_fnd  */

	null_match = "1"b;

	if ptr2 -> data_name.subscripted
	then do;					/* OCCURS */
		subscr_dir_index = subscr_dir_index + 1;
		main_item_subscripted = "1"b;
	     end;
	else main_item_subscripted = "0"b;

test_item_elementary:
	if (ptr2 -> data_name.elementary)
	then do;

		if defaults
		then do;

			if match_cat ()
			then call gen_assign;

		     end;
		else do;
			descr_ptr = addr (ptr2 -> data_name.file_section);
			if description (category)
			then call gen_assign;
			else n_array = n_array - 1;
		     end;


	     end;

	n = ptr2 -> reserved_word.size;
	n = n + mod (-n, 4);
	ptr2 = addr (ptr2 -> any_item (n + 1));

	if ptr2 -> reserved_word.type = 26
	then do;					/* group terminator */

		if null_match
		then do;
			err_num = 25;
			poss_prior_err = "0"b;

			call err_pro;

		     end;

		n = ptr2 -> reserved_word.size;
		n = n + mod (-n, 4);
		ptr2 = addr (ptr2 -> any_item (n + 1));

		go to more_code;

	     end;

	go to test_item_elementary;

     end;



setup_gen_lit:
     proc;

declare	fixbin15		fixed bin;		/* fills in fields in generated numeric literal tokens for perform control values */

	gen_num_lit_mindim.size = 36;
	fixbin15 = ptr1 -> occurs.level.max (curr_dim);
	cv_string = bin_to_char (fixbin15, cvindex);
	gen_num_lit_mindim.places = 10 - cvindex;

	substr (gen_num_lit_mindim.literal, 1, gen_num_lit_mindim.places) =
	     substr (cv_string, cvindex + 1, gen_num_lit_mindim.places);

	gen_num_lit_mindim.size = gen_num_lit_mindim.size + gen_num_lit_mindim.places;
	gen_num_lit_mindim.places_left = gen_num_lit_mindim.places;

     end;








dcl	1 message		internal static,
	  2 size		fixed bin init (0),
	  2 line		fixed bin init (0),
	  2 column	fixed bin init (0),
	  2 type		fixed bin init (5),
	  2 run		fixed bin init (8),
	  2 number	fixed bin init (0),
	  2 infobits,
	    3 info1	bit (1) init ("0"b),
	    3 info2	bit (1) init ("0"b),
	    3 info3	bit (6) init ("0"b),
	  2 length	fixed bin init (0),
	  2 image		char (200);



err_pro:
     proc;
	if poss_prior_err & ^eof
	then do;

		if reserved_word.type = 5		/*message from earlier phase caused error*/
		then call cobol_swf_put (outfp, fst, input_ptr, reserved_word.size);

	     end;

	message.number = err_num;
	message.length = index (err_image, "*");

	if message.length > 0
	then message.length = message.length - 1;

	output_ptr = addr (message);

	if message.length = 0
	then do;
		message.info1 = "0"b;
	     end;
	else do;
		substr (message.image, 1, message.length) = substr (err_image, 1, message.length);
		substr (err_image, 1, 1) = "*";
		message.info1 = "1"b;
	     end;

	message.infobits.info2 = "0"b;
	message.line = reserved_word.line;
	message.column = reserved_word.column;
	message.size = 32 + message.length;

	call cobol_swf_put (outfp, fst, output_ptr, message.size);

	poss_prior_err = "1"b;

	if ^recov
	then return;

	if reserved_word.terminator /*period or verb*/ | reserved_word.end_cobol = "1"b
						/*special generated end-cobol token*/
	then do;
		recov = "0"b;
		return;
	     end;

	message.number = 7;				/* syntax checking discontinued message */
	message.size = 28;
	message.info1 = "0"b;
	message.infobits.info2 = "1"b;
	recovering = "1"b;

	call cobol_swf_put (outfp, fst, output_ptr, output_ptr -> reserved_word.size);

	code = 2;

	call corr_in;

	recovering = "0"b;

	if eof
	then return;

	if reserved_word.key = 98 & reserved_word.terminator & reserved_word.end_cobol
	then do;					/* special end_cobol token */

		call cobol_swf_put (outfp, fst, input_ptr, recsize);

		eof = "1"b;
		recov = "0"b;
		return;

	     end;

	message.number = 8;				/*syntax checking resumed message */
	message.line = reserved_word.line;
	message.column = reserved_word.column;

	call cobol_swf_put (outfp, fst, output_ptr, output_ptr -> reserved_word.size);

	recov = "0"b;
     end;



corr_in:
     proc;


dcl	first_time_in_get_1 bit (1);



dcl	1 message		based (input_ptr),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 run		fixed bin,
	  2 number	fixed bin,
	  2 infobits,
	    3 info1	bit (1),
	    3 info2	bit (1),
	    3 info3	bit (6);


dcl	1 debug_token	based (input_ptr),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 index		fixed bin,
	  2 switch	bit (1);



	first_time_in_get_1 = "1"b;

	go to get (code);

get (0):						/*any token except type 6 */
						/*or type 5 with info(2) off */
	call cobol_swf_get (infp, fst, input_ptr, recsize);


	if substr (fst, 17, 16) = "0000000000100111"b
	then do;
		eof = "1"b;
		recovering = "0"b;
		return;
	     end;

	if message.type = 5
	then do;

		if code = 0
		then do;

			if message.infobits.info2
			then return;
			go to get (0);
		     end;

		else go to write_tok;
	     end;

	if debug_token.type = 24
	then go to write_tok;

	if data_name.type = 9
	then do;
		inf_ptr = addr (data_name.searched);
		inf = "0"b;
	     end;

	return;

get (1):						/* add, subtract, or move */
	if first_time_in_get_1
	then do;

		if lk_ahd_index > 0
		then do n = 1 to lk_ahd_index;
			output_ptr = lk_ahd_ptr (n);
			recsize = output_ptr -> reserved_word.size;

			call cobol_swf_put (outfp, fst, output_ptr, recsize);

		     end;

		add_swt = "0"b;
		subtract_swt = "0"b;
		move_swt = "0"b;
		initlz_swt = "0"b;
		first_time_in_get_1 = "0"b;
		if input_ptr ^= null ()
		then go to test_token_get1;

		call cobol_swf_get (infp, fst, input_ptr, recsize);

		if substr (fst, 17, 16) = "0000000000100111"b
		then do;
			eof = "1"b;
			return;
		     end;

		if reserved_word.type = 1 & reserved_word.key = 189
						/* . */
		then do;
			call cobol_swf_get (infp, fst, input_ptr, recsize);
			if substr (fst, 17, 16) = "0000000000100111"b
			then do;
				eof = "1"b;
				return;
			     end;
		     end;
	     end;
	else call cobol_swf_get (infp, fst, input_ptr, recsize);

	if substr (fst, 17, 16) = "0000000000100111"b
	then do;
		eof = "1"b;
		return;
	     end;

test_token_get1:
	if proc_def.type = 7
	then do;
		section_number = proc_def.section_num;
	     end;

	if debug_token.type = 24
	then go to write_tok;

	if reserved_word.type = 1
	then do;

		if reserved_word.key = 2
		then do;
			add_swt = "1"b;
			return;
		     end;

		if reserved_word.key = 11
		then do;
			subtract_swt = "1"b;
			return;
		     end;

		if reserved_word.key = 18
		then do;
			move_swt = "1"b;
			return;
		     end;

		if reserved_word.key = 13
		then do;
			initlz_swt = "1"b;
			return;
		     end;
	     end;

	go to passover;

get (2):						/* statement terminator */
	call cobol_swf_get (infp, fst, input_ptr, recsize);

	if substr (fst, 17, 16) = "0000000000100111"b
	then eof = "1"b;

	if eof
	then return;

	if reserved_word.type = 1
	then if reserved_word.terminator
	     then return;

passover:
	if message.type = 5
	then if code = 0
	     then do;

		     if message.infobits.info2
		     then return;
		     go to get (0);
		end;

	if ^recovering
	then go to write_tok;

	if message.type = 5
	then go to write_tok;

	if debug_token.type = 24
	then go to write_tok;
	go to get (code);

write_tok:
	if data_name.type ^= 26
	then call cobol_swf_put (outfp, fst, input_ptr, recsize);

	go to get (code);

     end;



add_token:
     proc;

	/*** adds token to token_stack -- for later output order ***/

	token_stack_ptr = addr (token_stack (top_token_stack));
	substr (token_stack_ptr -> record, 1, recsize) = substr (input_ptr -> record, 1, recsize);
	n = token_stack_ptr -> reserved_word.size;
	top_token_stack = top_token_stack + n + mod (-n, 4);
     end;



remove_token:
     proc;

	/***pops token stack -- when token added prematurely ***/


	recsize2 = token_stack_ptr -> reserved_word.size;
	recsize2 = recsize2 + mod (-recsize2, 4);
	top_token_stack = top_token_stack - recsize2;
     end;



stream_gen:
     proc;

	/***generates stream of minpral tokens from gen_ptr(begin_i) to gen_ptr(end_i) ***/

	do i = begin_i to end_i;

	     output_ptr = gen_ptr (i);

	     if output_ptr -> reserved_word.line = 0
	     then output_ptr -> reserved_word.line = nu_line;

	     call cobol_swf_put (outfp, fst, output_ptr, output_ptr -> reserved_word.size);

	     output_ptr -> reserved_word.line = 0;
	end;

     end;





bin_to_char:
     proc (value_sent, cv_index) returns (char (10));



dcl	dec_digits	char (10) internal static init ("0123456789");
dcl	bin_val		fixed bin;
dcl	value_sent	fixed bin;
dcl	cv_index		fixed bin;
dcl	cv_string		char (10);
dcl	remainder		fixed bin;



	bin_val = value_sent;
	cv_string = (10)" ";
	cv_index = 10;


	if bin_val = 0
	then do;
		substr (cv_string, 10, 1) = "0";
		cv_index = 9;
	     end;
	else do while (bin_val > 0);
		remainder = mod (bin_val, 10);
		substr (cv_string, cv_index, 1) = substr (dec_digits, remainder + 1, 1);
		bin_val = divide (bin_val, 10, 15, 0);
		cv_index = cv_index - 1;
	     end;

	return (cv_string);

     end;





gen_assign:
     proc;


	/***   sets up gen_ptr stack values for an INITIALIZE pair   ***/

dcl	sub_level		fixed bin;
dcl	ind_level		fixed bin;
dcl	perform_bit	bit (1);




	null_match = "0"b;
	perform_bit = "0"b;
	fixbin_diff = "0"b;

	if ptr2 -> data_name.subscripted
	then do;					/* this item is array */
		ptr1 = addr (ptr2 -> any_item (ptr2 -> data_name.occurs_ptr));

		if main_item_subscripted
		then do;
			ptr4 = subscr_directory.sufx_ptr (subscr_dir_index);

			if ptr4 -> occurs.dimensions < ptr1 -> occurs.dimensions
			then do;

/* this item has more dimensions than main item */

				sub_level = ptr4 -> occurs.dimensions + 1;
				go to perform_reqd;
			     end;

			if array_init_bit
			then do;
				sub_level = 1;

			     end;
		     end;

/* array within non-array */

		else do;
			sub_level = 1;
			go to perform_reqd;
		     end;
	     end;

/* no additional dimensions in this item over main item's */

	gen_ptr (1) = addr (res_wd_move);

	if defaults
	then do;

		if category < 20
		then gen_ptr (2) = addr (res_wd_zeroes);
		else gen_ptr (2) = addr (res_wd_spaces);
	     end;

	else gen_ptr (2) = send_op_ptr;

	gen_ptr (3) = addr (res_wd_to);
	gen_ptr (4) = ptr2;
	end_i = 4;

	if main_item_subscripted
	then do;
		gen_ptr (5) = addr (res_wd_lparen);
		ptr3 = subscr_directory.tokn_ptr (subscr_dir_index);

stk_subscr_tokns:
		end_i = end_i + 1;
		gen_ptr (end_i) = ptr3;


		if ptr3 -> reserved_word.type = 1
		then if ptr3 -> reserved_word.key = 188
		     then /* ) */
			do;
			     call stream_gen;
			     n_array = n_array - 1;
			     array_init_bit = "1"b;
			     return;
			end;

		n = ptr3 -> reserved_word.size;
		n = n + mod (-n, 4);
		ptr3 = addr (ptr3 -> any_item (n + 1));

		go to stk_subscr_tokns;

	     end;

	call stream_gen;
	second_time = "0"b;
	array_init_bit = "0"b;
	n_array = n_array - 1;
	return;

perform_reqd:
	perform_bit = "1"b;

	if fixbin15 ^= 0
	then if (fixbin15 - 1) ^= ptr1 -> occurs.level.min (curr_dim)
	     then do;
		     second_time = "0"b;
		     fixbin_diff = "1"b;
		end;

	if second_time
	then do;
		i = 1;
		go to several_time;
	     end;

	if ^initlz_items_allocated
	then do;

		save_the_key = "1"b;

		if gen_item_allocated
		then go to allocate_t2;

		fixbin24 = gen_item_t1.size;

		call allocate_item (fixbin24, 0, 0, off, off, off, on, off, off, alloc_seg, alloc_offset);

		gen_item_t1.seg_num = alloc_seg;
		gen_item_t1.offset = alloc_offset;

allocate_t2:					/*  allocation du deuxieme article  */
		fixbin24 = gen_item_t2.size;

		call allocate_item (fixbin24, 0, 0, off, off, off, on, off, off, alloc_seg, alloc_offset);

		gen_item_t2.seg_num = alloc_seg;
		gen_item_t2.offset = alloc_offset;
		fixbin24 = gen_item_t3.size;

		call allocate_item (fixbin24, 0, 0, off, off, off, on, off, off, alloc_seg, alloc_offset);

		gen_item_t3.seg_num = alloc_seg;
		gen_item_t3.offset = alloc_offset;
		initlz_items_allocated = "1"b;
	     end;

	else save_the_key = "0"b;

/* either main item had no dimensions or main item had 1 or 2 dimensions;
		   in either case, this item has more dimensions than main item */

	fixed_common.spec_tag_counter = fixed_common.spec_tag_counter + 1;
	gen_label_ref.proc_num = fixed_common.spec_tag_counter;
	gen_label_def.proc_num = fixed_common.spec_tag_counter;

	gen_ptr (1) = addr (gen_label_def);

	call write_gen_label (gen_ptr (1));		/*   added  to  give  a  name  to  label  */

	if main_item_subscripted
	then do;

		ptr3 = subscr_directory.tokn_ptr (subscr_dir_index);

		if subscr_directory.index_ct (subscr_dir_index) > 0
		then do;

/* main item's subscript string includes indices */
						/** generate code to SET index value(s) to non-index variables for loop **/

			ind_level = 1;

set_main_indices:
			if ptr3 -> index_name.type = 10
			then do;

				if ^(ptr3 -> index_name.searched)
				then do;
					gen_ptr (2) = addr (gen_item_t1);
					ptr3 -> index_name.searched = "1"b;
				     end;
				else do;
					gen_ptr (2) = addr (gen_item_t2);
					ptr3 -> index_name.duplicate = "1"b;
				     end;

				gen_ptr (1) = addr (res_wd_set);
				gen_ptr (3) = addr (res_wd_to);
				gen_ptr (4) = ptr3;
				end_i = 4;

				call stream_gen;

				n = ptr3 -> reserved_word.size;
				n = n + mod (-n, 4);
				ptr3 = addr (ptr3 -> any_item (n + 1));

				if ptr3 -> reserved_word.type = 1
				then do;

					if ptr3 -> reserved_word.key = 182
					then /* + */
					     do;
						gen_ptr (1) = addr (res_wd_add);

gen_rest:
						gen_ptr (4) = gen_ptr (2);
						n = ptr3 -> reserved_word.size;
						n = n + mod (-n, 4);
						gen_ptr (2) = addr (ptr3 -> any_item (n + 1));

						call stream_gen;

						ptr3 -> reserved_word.type = 0;
						gen_ptr (2) -> reserved_word.type = 0;
						n = gen_ptr (2) -> reserved_word.size;
						n = n + mod (-n, 4);
						ptr3 = addr (gen_ptr (2) -> any_item (n + 1));
					     end;

					else if ptr3 -> reserved_word.key = 183
					then /* - */
					     do;
						gen_ptr (1) = addr (res_wd_subtract);
						gen_ptr (3) = addr (res_wd_from);
						go to gen_rest;
					     end;
				     end;
			     end;

			else do;
				n = ptr3 -> reserved_word.size;
				n = n + mod (-n, 4);
				ptr3 = addr (ptr3 -> any_item (n + 1));
				go to set_main_indices;
			     end;

			if ind_level ^= subscr_directory.index_ct (subscr_dir_index)
			then do;
				ind_level = ind_level + 1;
				go to set_main_indices;
			     end;

		     end;
	     end;

						/** generate PERFORM **/

	if fixbin_diff
	then do;
		gen_label_def.proc_num = gen_label_def.proc_num - 1;
		gen_ptr (1) = addr (res_wd_dot);
		gen_ptr (2) = addr (gen_label_def);

		call write_gen_label (gen_ptr (2));

		gen_ptr (3) = addr (res_wd_dot);
		end_i = 3;

		call stream_gen;

		fixbin_diff = "0"b;
	     end;

	gen_ptr (1) = addr (res_wd_perform);
	gen_ptr (2) = addr (gen_label_ref);

	call write_gen_label (gen_ptr (2));

	gen_ptr (3) = addr (res_wd_varying);
	end_i = 3;
	res_wd_greater.key = 113;

	if sub_level = 3
	then go to level3_gen;

	if sub_level = 2
	then go to level2_gen;

	curr_dim = 1;

	call setup_gen_lit;

	gen_item_t1.length = gen_num_lit_mindim.places;
	gen_item_t1.places_left = gen_num_lit_mindim.places;

	gen_ptr (4) = addr (gen_item_t1);
	gen_ptr (5) = addr (res_wd_from);
	gen_ptr (6) = addr (num_lit_one);
	gen_ptr (7) = addr (res_wd_by);
	gen_ptr (8) = addr (num_lit_one);
	gen_ptr (9) = addr (res_wd_until);
	gen_ptr (10) = addr (gen_item_t1);
	gen_ptr (11) = addr (res_wd_greater);
	gen_ptr (12) = addr (gen_num_lit_mindim);
	end_i = 12;

	call stream_gen;

	if ptr1 -> occurs.dimensions = 1
	then go to gen_move_label;

	gen_ptr (1) = addr (res_wd_after);
	end_i = 1;

level2_gen:
	curr_dim = 2;

	call setup_gen_lit;

	end_i = end_i + 1;
	gen_item_t2.length = gen_num_lit_mindim.places;
	gen_item_t2.places_left = gen_num_lit_mindim.places;

	gen_ptr (end_i) = addr (gen_item_t2);
	end_i = end_i + 1;
	gen_ptr (end_i) = addr (res_wd_from);
	end_i = end_i + 1;
	gen_ptr (end_i) = addr (num_lit_one);
	end_i = end_i + 1;
	gen_ptr (end_i) = addr (res_wd_by);
	end_i = end_i + 1;
	gen_ptr (end_i) = addr (num_lit_one);
	end_i = end_i + 1;
	gen_ptr (end_i) = addr (res_wd_until);
	end_i = end_i + 1;
	gen_ptr (end_i) = addr (gen_item_t2);
	end_i = end_i + 1;
	gen_ptr (end_i) = addr (res_wd_greater);
	end_i = end_i + 1;
	gen_ptr (end_i) = addr (gen_num_lit_mindim);

	call stream_gen;

	if ptr1 -> occurs.dimensions = 2
	then go to gen_move_label;

	gen_ptr (1) = addr (res_wd_after);
	end_i = 1;

level3_gen:
	curr_dim = 3;

	call setup_gen_lit;

	end_i = end_i + 1;
	gen_item_t3.length = gen_num_lit_mindim.places;
	gen_item_t3.places_left = gen_num_lit_mindim.places;

	gen_ptr (end_i) = addr (gen_item_t3);
	end_i = end_i + 1;
	gen_ptr (end_i) = addr (res_wd_from);
	end_i = end_i + 1;
	gen_ptr (end_i) = addr (num_lit_one);
	end_i = end_i + 1;
	gen_ptr (end_i) = addr (res_wd_by);
	end_i = end_i + 1;
	gen_ptr (end_i) = addr (num_lit_one);
	end_i = end_i + 1;
	gen_ptr (end_i) = addr (res_wd_until);
	end_i = end_i + 1;
	gen_ptr (end_i) = addr (gen_item_t3);
	end_i = end_i + 1;
	gen_ptr (end_i) = addr (res_wd_greater);
	end_i = end_i + 1;
	gen_ptr (end_i) = addr (gen_num_lit_mindim);

	call stream_gen;

gen_move_label:
	fixed_common.spec_tag_counter = fixed_common.spec_tag_counter + 1;
	gen_label_ref.proc_num = fixed_common.spec_tag_counter;
	gen_label_def.proc_num = fixed_common.spec_tag_counter;
	gen_ptr (1) = addr (res_wd_go);
	gen_ptr (2) = addr (res_wd_to);
	gen_ptr (3) = addr (gen_label_ref);

	call write_gen_label (gen_ptr (3));

	gen_ptr (4) = addr (res_wd_dot);
	gen_label_def.proc_num = gen_label_def.proc_num - 1;

	gen_ptr (5) = addr (gen_label_def);

	call write_gen_label (gen_ptr (5));

	gen_ptr (6) = addr (res_wd_dot);
	gen_ptr (7) = addr (res_wd_move);

	i = 8;

	if defaults
	then do;
		if category < 20
		then gen_ptr (i) = addr (res_wd_zeroes);
		else gen_ptr (i) = addr (res_wd_spaces);
	     end;

	else do;

		gen_ptr (i) = send_op_ptr;

		if send_op_ptr -> data_name.type = 9
		then do;

			if send_op_ptr -> data_name.subscripted
						/*OCCURS*/
			then do;
nxt_send_op_subscr:
				n = gen_ptr (i) -> data_name.size;
				n = n + mod (-n, 4);
				i = i + 1;
				gen_ptr (i) = addr (gen_ptr (i - 1) -> any_item (n + 1));

				if gen_ptr (i) -> reserved_word.type = 1
				then do;
					if gen_ptr (i) -> reserved_word.key = 188
					then go to end_send_op_gen;
				     end;
				go to nxt_send_op_subscr;
			     end;
end_send_op_gen:
		     end;

	     end;

	i = i + 1;
	gen_ptr (i) = addr (res_wd_to);
	i = i + 1;

several_time:
	gen_ptr (i) = ptr2;
	end_i = i;

	call stream_gen;

/*	if array_init_bit
	then	do;
		          array_init_bit = "0"b;
		          go to gen_lpar;
	          end;	*/

	if main_item_subscripted
	then do;

/* give subscripts from subscript area */

		ptr3 = subscr_directory.tokn_ptr (subscr_dir_index);
		end_i = 0;

test_subscr_type:
		if ptr3 -> reserved_word.type = 0
		then go to get_nxt_subscript;		/*
		/* this was from index +_ literal for main item -- replaced by SET and ADD or SUBTRACT */

		if ptr3 -> index_name.type = 10
		then do;
			end_i = end_i + 1;

			if ptr3 -> index_name.searched
			then gen_ptr (end_i) = addr (gen_item_t1);
			else gen_ptr (end_i) = addr (gen_item_t2);

			ptr3 -> index_name.searched = "0"b;
			ptr3 -> index_name.duplicate = "0"b;
		     end;
		else do;
			if ptr3 -> reserved_word.type = 1
			then if ptr3 -> reserved_word.key = 188
			     then go to test_extra_subscr;
			end_i = end_i + 1;
			gen_ptr (end_i) = ptr3;
		     end;

get_nxt_subscript:
		n = ptr3 -> reserved_word.size;
		n = n + mod (-n, 4);
		ptr3 = addr (ptr3 -> any_item (n + 1));

		go to test_subscr_type;

	     end;

test_extra_subscr:					/* there is always at least one */
	if ^main_item_subscripted
	then do;
gen_lpar:
		end_i = 1;
		gen_ptr (1) = addr (res_wd_lparen);
	     end;

	if sub_level = 3
	then go to gen_level3;

	if sub_level = 2
	then go to gen_level2;

	end_i = end_i + 1;
	gen_ptr (end_i) = addr (gen_item_t1);

	if ptr1 -> occurs.dimensions = 1
	then go to gen_rparen;

gen_level2:
	end_i = end_i + 1;
	gen_ptr (end_i) = addr (gen_item_t2);

	if ptr1 -> occurs.dimensions = 2
	then go to gen_rparen;

gen_level3:
	end_i = end_i + 1;
	gen_ptr (end_i) = addr (gen_item_t3);

gen_rparen:
	end_i = end_i + 1;
	gen_ptr (end_i) = addr (res_wd_rparen);

	end_i = end_i + 1;
	gen_ptr (end_i) = addr (res_wd_dot);

	call stream_gen;

	call genlabel;

	if n_array > 1
	then do;

		second_time = "0"b;
		n_array = n_array - 1;
		array_init_bit = "1"b;

	     end;

	return;



genlabel:
     proc;

	if perform_bit
	then do;
		perform_bit = "0"b;
		gen_label_def.proc_num = gen_label_def.proc_num + 1;
		gen_ptr (1) = addr (gen_label_def);

		call write_gen_label (gen_ptr (1));

		gen_ptr (2) = addr (res_wd_dot);
		end_i = 2;

		call stream_gen;

	     end;

     end;

     end;

write_gen_label:
     proc (label_ptr);

dcl	label_ptr		ptr;

dcl	1 general_label	based (label_ptr),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 string_ptr	ptr,
	  2 prev_rec	ptr,
	  2 info		bit (8),
	  2 priority	char (2),			/* 1 multics char(1), */
	  2 repl_bit	bit (8),
	  2 section_num	fixed bin,
	  2 proc_num	fixed bin,
	  2 def_line	fixed bin,
	  2 length	fixed bin,
	  2 name		char (10);
dcl	string_ctr	char (10);
dcl	scale		fixed bin;



	string_ctr = bin_to_char (label_ptr -> general_label.proc_num, scale);
	substr (general_label.name, scale + 1, 10 - scale) = substr (string_ctr, scale + 1, 10 - scale);

     end;



match_cat:
     proc returns (bit (1));

	do category = 18 to 22 by 1;
	     descr_ptr = addr (ptr2 -> data_name.file_section);
	     if description (category)
	     then return ("1"b);
	end;

	return ("0"b);

     end;



/*    merge  allocate_item  in  internal   */

allocate_item:
     proc (al_size, al_elem_offset, al_occ_offset, al_read_only, al_bitt, al_byte, al_half_word, al_word, al_double_word,
	al_rec_seg, al_rec_off);

/* pointers */
/*  suppress cobol_com_ptr declared in begining cobol_ci_phase  
	dcl cobol_com_ptr ptr ext;    */
/* pointer to fixed common, set by driver */
dcl	ft_ptr		ptr;			/* pointer to current file table record in common */
dcl	seg_ptr		ptr;			/* pointer to segment-information entry in common */
dcl	prev_seg_ptr	ptr;			/* previous value of seg_ptr saved here by allocate_item */
						/*  cobol_cmfp  external  pointer  must  be  declared  in  cobol_ci_phase
	dcl cobol_cmfp ptr ext;
	                                                                        */
						/*   cobol_vdwf_dput  and  dget  are  declared  in  cobol_ci_phase      
	dcl cobol_vdwf_dget ext entry(ptr,bit(32),ptr,fixed bin,char(5));
	dcl cobol_vdwf_dput ext entry(ptr,bit(32),ptr,fixed bin,char(5));
	                                                                     */
						/* description of data division segment information table in common */
dcl	1 dd_segment	based (seg_ptr),
	  2 next		char (5),			/* record number in common of next segment information record */
	  2 seg_no	fixed bin (7),
	  2 next_avail_loc	fixed bin (24),
	  2 duplicate_next_loc
			fixed bin (24),
	  2 read_only	bit (1);			/* character string work fields */
dcl	work_area		char (25),
	seg_size		fixed bin;		/* fixed binary work fields */
dcl	common_recsize	fixed bin;		/* size of record just read from common file */
dcl	common_key	char (5);			/* record number of common record just read or to be read */
dcl	elem_offset_limit	fixed bin (24);
dcl	occ_offset_limit	fixed bin (24);
dcl	second_occ_limit	fixed bin (24);		/* 2**15 + 2**12 - 1 */
dcl	next_loc_used	fixed bin (24);		/* work area used by allocate_item */
dcl	work31		fixed bin (24);
dcl	double_word_slack	fixed bin (7);
dcl	word_slack	fixed bin (7);
dcl	half_word_slack	fixed bin (7);		/* bit strings */

dcl	common_eof	bit (1);			/* set on if end-of-file encountered on read of common file */
dcl	al_size		fixed bin (24);		/* size of item to be allocated */
dcl	al_elem_offset	fixed bin (24);		/* largest offset of any contained elementary item not in a table */
dcl	al_occ_offset	fixed bin (24);		/* largest offset of any contained table item */
dcl	al_rec_seg	fixed bin;		/* segment number assigned to item */
dcl	al_rec_off	fixed bin (24);		/* offset assigned to item */
dcl	al_read_only	bit (1);			/* read only requirement of the item */
dcl	al_bitt		bit (1);			/* boundary requirement of the item */
dcl	al_byte		bit (1);
dcl	al_half_word	bit (1);
dcl	al_word		bit (1);
dcl	al_double_word	bit (1);



	seg_size = 21;
	elem_offset_limit = 262144;
	occ_offset_limit = 262144;
	second_occ_limit = 262144;

	if new_seg_bit = off
	then do;					/* have any segments been started yet? */

		if fixed_common.seg_info = "00000" | al_size ^< fixed_common.dd_seg_size
		then go to new_segment_needed;
	     end;

	common_key = fixed_common.seg_info;

	call cobol_vdwf_dget (cobol_cmfp, status, seg_ptr, common_recsize, fixed_common.seg_info);

/* can the item be allocated in this segment? */

check_this_segment:
	if dd_segment.read_only ^= al_read_only
	then go to check_next_segment;

	next_loc_used = dd_segment.next_avail_loc;

	if al_bitt
	then go to boundary_ok;

	if al_byte
	then go to boundary_ok;

	if al_half_word
	then go to incr_to_half_word;

	if al_word
	then go to incr_to_word;			/* double-word boundary required for this item */
	double_word_slack = mod (next_loc_used, 8);

	if double_word_slack ^= 0
	then next_loc_used = next_loc_used + 8 - double_word_slack;

	go to boundary_ok;				/* word boundary required for this item */

incr_to_word:
	word_slack = mod (next_loc_used, 4);

	if word_slack ^= 0
	then next_loc_used = next_loc_used + 4 - word_slack;

	go to boundary_ok;				/* half-word boundary required for this item */

incr_to_half_word:
	half_word_slack = mod (next_loc_used, 2);
	next_loc_used = next_loc_used + half_word_slack;

boundary_ok:
	work31 = next_loc_used + al_size - 1;

	if work31 > fixed_common.dd_seg_size
	then go to check_next_segment;

	if al_elem_offset ^< elem_offset_limit
	then go to first_occ_check;

	work31 = next_loc_used + al_elem_offset - 1;

	if work31 ^< elem_offset_limit
	then go to check_next_segment;

first_occ_check:
	work31 = next_loc_used + al_occ_offset - 1;

	if al_occ_offset > (occ_offset_limit - 1)
	then go to second_occ_check;

	if work31 ^< occ_offset_limit
	then go to check_next_segment;

	go to this_seg_ok;

second_occ_check:
	if work31 ^< second_occ_limit
	then go to check_next_segment;		/* yes, item can be allocated in this segment */

this_seg_ok:
	al_rec_seg = dd_segment.seg_no;
	al_rec_off = next_loc_used;
	dd_segment.next_avail_loc = next_loc_used + al_size;
	dd_segment.duplicate_next_loc = dd_segment.next_avail_loc;

	call cobol_vdwf_dput (cobol_cmfp, status, seg_ptr, common_recsize, common_key);

	return;

check_next_segment:
	if new_seg_bit
	then go to this_seg_ok;

	common_key = dd_segment.next;

	call cobol_vdwf_dget (cobol_cmfp, status, seg_ptr, common_recsize, dd_segment.next);

	if dd_segment.next ^= "00000"
	then go to check_this_segment;		/* build new segment entry in work area, then write it out to common */

new_segment_needed:
	seg_ptr = addr (work_area);
	dd_segment.next = "00000";

	if ^new_seg_bit
	then fixed_common.number_of_dd_segs = fixed_common.number_of_dd_segs + 2;

	new_seg_bit = "1"b;
	dd_segment.seg_no = fixed_common.number_of_dd_segs;
						/* start with segment number 2 */
	dd_segment.next_avail_loc = 0;
	dd_segment.duplicate_next_loc = 0;
	dd_segment.read_only = al_read_only;

	call cobol_vdwf_dput (cobol_cmfp, status, seg_ptr, seg_size, common_key);


/* save old value of seg_ptr to fill next field if another segment is created */

	if fixed_common.seg_info ^= "00000"
	then fixed_common.seg_info = common_key;

	next_loc_used = 0;

	go to this_seg_ok;

     end;

declare	(mod, divide, substr, index, addr)
			builtin;

declare	cobol_c_list	entry (ptr);

declare	(descr_ptr, inf_ptr)
			ptr;
declare	description	(64) bit (1) based (descr_ptr);
declare	inf		bit (8) based (inf_ptr);
declare	1 indicators,
	  2 rdf_illegal	bit (1),
	  2 rparen	bit (1);
declare	(trial, req_sub)	fixed bin (24);
declare	(dir_num, stack_loc)
			fixed bin (24);
declare	(link1, link2)	fixed bin (24);

declare	(section_number, check_res)
			fixed bin;

%include cobol_ext_;
%include cobol_io_info;
declare	1 reserved_word	based (input_ptr),
%include cobol_TYPE1;

declare	1 numeric_lit	based (input_ptr),
%include cobol_TYPE2;

declare	1 data_name	based (input_ptr),
%include cobol_TYPE9;

%include cobol_occurs;

declare	1 index_name	based (input_ptr),
%include cobol_TYPE10;

declare	1 proc_def	based (input_ptr),
%include cobol_TYPE7;

declare	1 alphanum_lit	based (input_ptr),
%include cobol_TYPE3;

%include cobol_ciphase_data;

%include cobol_fixed_common;
%include cobol_common_data;
     end cobol_ci_phase;
