/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_ddsyntax.pl1 Reformatted code to new Cobol standard.
                                                   END HISTORY COMMENTS */


/* Modified on 10/17/83 by FCH, [5.2-2], check for type 10 token, phx16140(BUG562) */
/* Modified on 07/07/83 by FCH, [5.2-1], lev 88 item causes abort if RW used, BUG552(phx15491) */
/* Modified on 10/29/82 by FCH, [5.1-3], diag 3-35 put on prev token, BUG542(phx13372) */
/* Modified on 10/29/82 by FCH, [5.1-2], places_left set for group items, BUG531(phx12991) */
/* Modified on 11/24/81 by FCH, [5.1-1], RECORD CONTAINS clause may not contain ZERO, BUG5.1(phx11821) */
/* Modified on 09/10/81 by FCH, [5.0-1], occ dep item followed by lev 66 item blows compiler, BUG502(phx11383) */
/* Modified on 07/10/81 by FCH, [4.4-3], debug cards not processed unless use for debugging used (phx10378, BUG493) */
/* Modified on 04/13/81 by FCH, [4.4-2], fix bugs in leveling for validation-81, BUG477 */
/* Modified on 12/03/80 by FCH, [4.4-1], report writer added */
/* Modified on 09/03/80 by FCH, [4.3-2], single digit level numbers detected */
/* Modified on 04/15/80 by FCH, [4.2-5], emit diag cursor on proper line */
/* Modified on 03/05/80 by FCH, [4.2-4], Fix BUG426 (TR3226) pic bbx(nn) failed when nn >= 31 */
/* Modified on 01/03/80 by MHD, [4.2-3], issue leveling diag when filler defines condition name */
/* Modified on 12/28/79 by MHD, [4.2-2], don't diag debug tokens (column=9999) when checking margin A */
/* Modified on 11/20/79 by MHD, [4.2-1], check(74): also check for end of file for minpral */
/* Modified on 10/08/79 by MHD, [4.0-5], check(74): check for COLUMN = 9999 (eat all DEBUG inserted statements) */
/* Modified on 08/28/79 by FCH, [4.0-4], LEV_DIAG defined */
/* Modified on 08/11/79 by FCH, [4.0-3], debug statement added */
/* Modified on 03/27/79 by FCH, [4.0-2], leveling diags on fd clause */
/* Modified on 03/22/79 by FCH, [4.0-1], check for duplicate data names */
/* Modified since version 4.0 */






/* format: style3 */
cobol_ddsyntax:
     proc;

	call cobol_initstatic;			/*sets sv_ptr*/
	sv_ptr_auto = cobol_sv_ptr;			/*optimization of hpl code*/
	stack_index = 0;

	file_ptr = addr (file_key_area (1));

/*[4.4-1]*/
	first_rec = "1"b;				/*[4.4-1]*/
	first_key, like_key = "00000";


	qual_ptr = file_ptr;
	qual_rec.size = 0;
	key_qual_size = size (qual_rec) * 4;

	fkey_ptr = file_ptr;
	file_key.name_size = 0;
	file_key_size = size (file_key) * 4;


	prev_qual_key = "00000";

/*[4.0-3]*/
	FILE_REC_TAB.file_ind = "1"b;
	FILE_REC_TAB.file_count = 0;

/*[4.0-2]*/
	lev_message_ptr = addr (lev_message);

/*[4.0-2]*/
	lev_message.size = 28;			/*[4.0-2]*/
	lev_message.type = 5;			/*[4.0-2]*/
	lev_message.run = 9;

	mod_num = 0;

	tf = 0;
	all_ind = 0;

	se = 0;
	cslno = 0;
	pre_end_sw = "0"b;
	comp_end_sw = "0"b;

	alf_key_ptr = addr (alf_key);

	filstring_init = "ffffffffffffffffffffffffffffff";

	character_tbl (1) = "0";
	character_tbl (2) = " ";
	unspec (character_tbl (3)) = "000000000"b;
	unspec (character_tbl (4)) = "111111111"b;
	unspec (character_tbl (5)) = "000000000"b;
	unspec (character_tbl (6)) = "111111111"b;
	character_tbl (7) = """";

	ptr_to_char_tbl = addr (character_tbl);
	call cobol_ddst (syntab_ptr);			/*don't care about second argument to cobol_ddst*/
prelude:
	dn_ptr = addr (cobol_wkbuf1_tbl.wkbuf1);
	w2_ptr = addr (cobol_wkbuf2_tbl.wkbuf2);
	cdtoken_ptr = w2_ptr;

	begin;
dcl	(comma, period, dollar, store)
			char (1);			/* picproc insert */
	     if fixed_common.dec_comma
	     then do;
		     comma = ",";
		     period = ".";
		     bit9 = unspec (comma);
		     i = fixed (bit9, 35);
		     bit9 = unspec (period);
		     j = fixed (bit9, 35);
		     store = transltble (i);
		     transltble (i) = transltble (j);
		     transltble (j) = store;
		end;
	end;

	fixed_common.phase_name = "ddsynt";

start:
	current_line = 1;
	trace_ptr = addr (interp);

	tbit = fixed_common.syntax_trace;

	if tbit
	then call cobol_syntax_trace_$initialize_phase (trace_ptr, 2);



	call scan;

	go to loop;

fail:
	if tbit
	then do;
		interp.rec_ptr = min_ptr;
		call cobol_syntax_trace_$trace (trace_ptr, tm2);
	     end;

	current_line = current_line + 1;

loop:
	interp.rec_ptr = min_ptr;
new_inst:
	syntax_line_ptr = addr (syntax_table (current_line));
	TF = 0;

	go to test (syntax_line.t_type);

test (0):
	if record.type ^= 1
	then go to fail;
	if rw.key ^= syntax_line.t_field
	then go to fail;

success:
	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm1);

ucon:
	if syntax_line.o_bit ^= " "
	then do;
		if syntax_line.o_bit > fixed_common.comp_level
		then call lev_diag (syntax_line.a_num);
		go to actretrn;
	     end;

	act_num = syntax_line.a_num;

success_1:
	if act_num < 50
	then go to actlbl (act_num);

	if act_num < 150
	then call cobol_ddact1 (act_num);
	else call cobol_ddact2 (act_num);

actretrn:
actlbl (0):
actlbl (1):
	current_line = syntax_line.s_exit;

action_0:						/* action(0): */
						/*[4.2-5]*/
	if TF ^= 0
	then call diag (TF, record.line, record.column);
	if pre_end_sw
	then go to pre_end;

	if comp_end_sw
	then go to comp_end;

	if syntax_line.s_bit = "s"
	then call scan;

	go to loop;

test (1):
	go to check (syntax_line.t_field);

test (2):						/* unconditional branch */
	TF = syntax_line.t_field;
	act_num = syntax_line.a_num;

	if syntax_line.o_bit ^= " "
	then do;
		if syntax_line.o_bit > fixed_common.comp_level
		then do;
			mod_num = syntax_line.a_num;
			call lev_diag (TF);
		     end;

		TF = 0;
		act_num = 0;
	     end;

	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm1);

	go to success_1;

test (3):						/* syntax routine test */
	stack_index = stack_index + 1;

	if stack_index > 30
	then go to comp_end;

	if tbit
	then do;
		interp.rec_ptr = min_ptr;
		call cobol_syntax_trace_$trace (trace_ptr, tm3);
	     end;

	stack (stack_index) = current_line;
	current_line = syntax_line.t_field;

	go to loop;

actlbl (2):					/* exit true */
						/* action(1): */
	current_line = stack (stack_index);

	if tbit
	then do;
		interp.rec_ptr = min_ptr;
		call cobol_syntax_trace_$trace (trace_ptr, tm4);
	     end;

	if syntax_line.s_bit = "s"
	then call scan;

	syntax_line_ptr = addr (syntax_table (current_line));
	stack_index = stack_index - 1;

	go to ucon;

actlbl (3):					/* exit false */
						/* action(2); */
	current_line = stack (stack_index);

	if tbit
	then do;
		interp.rec_ptr = min_ptr;
		call cobol_syntax_trace_$trace (trace_ptr, tm5);
	     end;

	stack_index = stack_index - 1;
	go to fail;

actlbl (4):					/* jump index */
						/* action(4): */
	if min_eof
	then go to pre_end;

	current_line = rw.jump_index + syntax_line.s_exit;

	go to action_0;


declare	cobol_syntax_trace_$trace
			entry (ptr, fixed bin);
declare	cobol_syntax_trace_$initialize_phase
			entry (ptr, fixed bin);

declare	(syntax_line_ptr, trace_ptr)
			ptr;
declare	tbit		bit (1);
declare	act		fixed bin;

declare	tm1		fixed bin init (1),
	tm2		fixed bin init (2),
	tm3		fixed bin init (3),
	tm4		fixed bin init (4),
	tm5		fixed bin init (5);

declare	1 interp,
	  2 current_line	fixed bin,
	  2 phase		fixed bin,
	  2 rec_ptr	ptr,
	  2 syntab_ptr	ptr,
	  2 directory_ptr	ptr,
	  2 source_ptr	ptr;

declare	1 syntax_line	based (syntax_line_ptr),
	  2 s_bit		char (1),
	  2 o_bit		char (1),
	  2 t_type	fixed bin,
	  2 t_field	fixed bin,
	  2 s_exit	fixed bin,
	  2 a_num		fixed bin;

declare	1 syntax_table	(0:10000) based (syntab_ptr),
	  2 b1		fixed bin,
	  2 b2		fixed bin,
	  2 b3		fixed bin,
	  2 b4		fixed bin,
	  2 b5		fixed bin;


actlbl (5):					/*action(77)*/
						/* first entry in ref table */
						/*[4.4-1]*/
	ref_table_size = 1;

/*[4.4-1]*/
	ref.length (1) = user_word.word_size;		/*[4.4-1]*/
	ref.name (1) = substr (user_word.word, 1, user_word.word_size);
						/*[4.4-1]*/
	ref.size (1) = user_word.word_size;

	go to actretrn;

/*level number*/
actlbl (6):					/*action(8):*/
						/*[5.1-1]*/
	if record.type = 2
	then save_level = fixed (numeric_lit.literal);
	else save_level = 1;
	substr (vector_part, 7) = "0"b;

	goto actretrn;

/* store_data_name */
actlbl (7):					/*action(12):*/
	dnl = ul;
	save_dname = "                              ";
	substr (save_dname, 1, dnl) = substr (user_word.word, 1, dnl);
lbl12:
	save_line = record.line;
	save_column = record.column;
	goto actretrn;

/*filler*/
actlbl (8):					/*action(14):*/
						/*[4.2-3]*/
	saved_line = record.line;			/*[4.2-3]*/
	saved_column = record.column;			/*[4.2-3]*/
	filler_flag = "1"b;

	dnl = 6;
	save_dname = "FILLER                        ";
	vector_map.filler_item = "1"b;
	goto lbl12;


/* semantic_consistency_analysis */

actlbl (9):					/*action(17):*/
	if vector_map.elementary
	then do;
		if (substr (vector_part, 9, 32) & non_display_bits_mask) = "0"b
		then vector_map.display = "1"b;
		else if (substr (vector_part, 9, 32) & numeric_usage_bits_mask) ^= "0"b
		then vector_map.numeric = "1"b;
	     end;

/*test for unsigned packed decimal on Level 64*/

	if vector_map.bwz = "1"b & vector_map.numeric = "1"b
	then do;

		vector_map.numeric_edited = "1"b;
		vector_map.numeric = "0"b;

	     end;

	if vector_map.pic_has_s & vector_map.numeric & vector_map.display & vector_map.sign_type = "000"b
	then do;
		vector_map.sign_type = fixed_common.default_sign_type;

		if vector_map.sign_type = "100"b | vector_map.sign_type = "011"b
		then vector_map.sign_separate = "1"b;
	     end;

	if vector_map.fig_zero = "1"b
	then if vector_map.numeric = "1"b
	     then vector_map.value_numeric = "1"b;
	     else vector_map.value_non_numeric = "1"b;

	if vector_map.code_set
	then do;

		if ^vector_map.display & vector_map.elementary
		then do;
			if vector_map.code_set_class1
			then tf = 199;		/*fatal*/
			else tf = 200;		/*nonfatal*/

			call diag (tf, record.line, record.column);
			goto l17;
		     end;

		if vector_map.numeric
		then do;

			if vector_map.pic_has_s & ^vector_map.sign_separate
						/* implies not display */
			then do;
				if vector_map.code_set_class1
				then tf = 188;	/*fatal*/
				else tf = 198;	/*nonfatal*/
						/*[4.2-5]*/
				call diag (tf, record.line, record.column);
			     end;
		     end;

	     end;
l17:
	if vector_map.inherit_value | vector_map.non_elementary
	then vector_map.elem_no_value = "0"b;
	else vector_map.elem_no_value = "1"b;

/* Move Vector_map bits into data_name.description bits. */

	addr (data_name.file_section) -> bit72 = vectord.descr;

	if data_name.non_elementary
	then do;
		cobol_htbl.minivector (h) = vectord.minivector;
	     end;

	do i = 1 to 83;

	     if vectora (i)
	     then do;

		     vectemp = vector_part & (m1 (i) || m2 (i));

		     if vectemp
		     then do;

/* store diag info for cobol_c_list */

			     message_ptr = addr (message_area);
			     message.length = 16;
			     message.size = msg_constant + 16;

			     message.line = s_lin;
			     message.column = s_col;

			     message.type = 5;
			     message.run3 = 3;
			     message.info.para = "1"b;
			     message.info.rep = "0"b;
			     message.info.fillerx = "000000"b;
			     message.number = 9;
			     ptr4 = addr (message.image);

			     mi_overlay_bit9 = substr (unspec (i), 28, 9);

			     mi_overlay_part = vectemp;

			     call cobol_c_list (message_ptr);

			end;
		end;
	end;

/* This bit may not be set until after the contradiction analysis has been completed, to avoid spurious diags: */

	if data_name.non_elementary
	then data_name.alphanum = "1"b;

	if vector_map.elementary
	then if data_name.initial_ptr ^= 0
	     then do;
		     ptr1 = addr (dn_ptr -> any_item (data_name.initial_ptr));
		     tf = cobol_pic_val_comp (dn_ptr, ptr1);

/*[4.2-5]*/
		     if tf > 0
		     then call diag (tf, dn_ptr -> record.line, dn_ptr -> record.column);

		     tf = 0;			/**in case set to -1 by cobol_pic_val_comp*/

		end;

	if save_switch_88
	then do;

		save_switch_88 = "0"b;

		if no_of_88s = 0
		then goto l17aaa;

/* If data_name is non-elementary we still want to update description bits in
		   the type 9 token. Consistency checking of condition-name values will be
		   performed in action(21), hierarchy analysis, after this non-elementary
		   item has been completed. */

		if data_name.non_elementary
		then go to l17aaa;

		rnt_key = save_wkey;		/* set in action 70 */

		if save_wkey = null_key
		then go to l17aaa;

		call cobol_vdwf_dget (cobol_ntfp, fstatus, rnt_ptr, rnt_size, rnt_key);
l17a:
		if no_of_88s = 0
		then goto l17aaa;

		no_of_88s = no_of_88s - 1;

		call cobol_vdwf_sget (cobol_ntfp, fstatus, rnt_ptr, rnt_size, rnt_key);

		if substr (fstatus, 17, 16) ^= "0000000000000000"b
		then go to l17aaa;

		temp_bin1 = cn_constant + rnt_ptr -> conditioname.name_size;

		temp_bin1 = temp_bin1 + mod (-temp_bin1, 4);

		temp_bin2 = rnt_ptr -> conditioname.numlits;

		if temp_bin2 < 1
		then goto l17a;

/*will be 0 if value was not syntactically valid*/
l17aa:
		ptr1 = addr (rnt_ptr -> any_item (temp_bin1 + 1));
		tf = cobol_pic_val_comp (dn_ptr, ptr1);

/*[4.2-5]*/
		if tf > 0
		then call diag (tf, dn_ptr -> record.line, dn_ptr -> record.column);

		if tf < 0
		then do;
			call cobol_vdwf_dput (cobol_ntfp, fstatus, rnt_ptr, rnt_size, rnt_key);
			tf = 0;
		     end;

		if ptr1 -> numinit.initype.numeric
		then temp_bin1 = temp_bin1 + niv_constant + ptr1 -> numinit.length;

		else do;
			if ptr1 -> alphainit.initype.fig_con
			then do;
				if ptr1 -> alphainit.info.fig_con_index = "0000001"b
				then temp_bin1 = temp_bin1 + niv_constant + 1;
				else temp_bin1 = temp_bin1 + aiv_constant;
			     end;
			else temp_bin1 = temp_bin1 + aiv_constant + ptr1 -> alphainit.length;
		     end;

		temp_bin1 = temp_bin1 + mod (-temp_bin1, 4);

		if temp_bin2 = 1
		then goto l17a;

		temp_bin2 = temp_bin2 - 1;
		goto l17aa;

l17aaa:
		call cobol_vdwf_dput (cobol_ntfp, fstatus, dn_ptr, data_name.size, save_wkey);

/*update description bits in type9 token*/
		no_of_88s = 0;
		save_wkey = null_key;

	     end;

/*[4.4-1]*/
	s_lin = record.line;
	s_col = record.column;
	goto actretrn;


/*write item not followed by subject of redefines*/
actlbl (10):					/*action(18):*/
						/*write completed(previous)dataname token*/
	if bnw ^= 0
	then do;
		rnt_ptr = dn_ptr;
		nt_size = data_name.size;

		call cobol_vdwf_sput (cobol_ntfp, fstatus, rnt_ptr, nt_size, w_key);

/*[4.0-3]*/
		if FILE_REC_TAB.file_ind		/*[4.0-3]*/
		then do;
			FILE_REC_TAB.file_key (FILE_REC_TAB.file_count) = w_key;
						/*[4.0-3]*/
			FILE_REC_TAB.file_ind = "0"b; /*[4.0-3]*/
		     end;

		if data_name.level = 1
		then do;


			if data_name.exp_redefining
			then rdf_01_sav = w_key;

			else do;
				save_01 = w_key;
				rdf_01_sav = null_key;
			     end;

		     end;

		if data_name.non_elementary
		then cobol_htbl.nt_rec (h) = w_key;

/*[4.4-1]*/
		if first_rec			/*[4.4-1]*/
		then do;
			first_rec = "0"b;		/*[4.4-1]*/
			first_key = w_key;		/*[4.4-1]*/
		     end;

	     end;

	ptr4 = addr (cobol_wkbuf1_tbl);

	ptr4 -> cntbuf = 0;


	data_name.type = 9;
	data_name.line = save_line;
	data_name.def_line = save_line;
	data_name.column = save_column;
	data_name.level = save_level;
	data_name.do_rec = null_key;

	if file_number ^= 0
	then data_name.file_num = file_number;
	else data_name.file_num = cdno;

	data_name.name_size = dnl;
	substr (data_name.name, 1, dnl) = substr (save_dname, 1, dnl);
	data_name.size = dn_constant + dnl;



/*[4.0-3]*/
	if fixed_common.debug			/*[4.0-3]*/
	then data_name.size = data_name.size + 32 - data_name.name_size;

	data_name.size = data_name.size + mod (-data_name.size, 4);

	ptr1 = addr (dn_ptr -> any_item (data_name.size + 1));

	if data_name.level = 1
	then do;

		ptr4 = addr (cobol_htbl);

		ptr4 -> chtbl = 0;

	     end;



	bnw = 1;					/*buf needs write*/

	goto actretrn;


/*level 01*/
actlbl (11):					/*action(20):*/
	vector_map.level_01 = "1"b;

/*[4.4-1]*/
	like_clause = "0"b;

	ixix = 0;
	ll01 = "1"b;

	if vector_map.file_section
	then if file_number ^= 0
	     then do;
		     cm_key = fixed_common.filedescr_offsets (file_number);

		     call cobol_vdwf_dget (cobol_cmfp, fstatus, cm_ptr, cm_size, cm_key);

		     ft_ptr = cm_ptr;
		     vector_map.code_set = file_table.code_set_clause;

		     if file_table.code_set = 3	/*jis*/
		     then vector_map.code_set_class1 = "1"b;
		end;

	offset_ct = 0;
	h = 0;
	odim = 0;
	save_line_for66 = 0;

	goto actretrn;


/* hierarchy analysis */
actlbl (12):					/*action(21):*/
	data_name.offset = offset_ct;

	if ^vector_map.exp_redefining
	then save_offsets (data_name.level) = offset_ct;

	if data_name.occurs_ptr ^= 0
	then if ^data_name.key_a & ^data_name.key_d
	     then occurs.keyed = 0;

	if data_name.level < next_level
	then goto groupa21;

/*current item elementary,some undetermined number of group items may be finished*/

	vector_map.elementary = "1"b;

	if vector_map.occurs_do & next_level ^= 1
	then call DIAG (31);

	if h ^= 0 & ^vector_map.assoc_with_signed_num_display
	then do;
		vector_map.sign_type = "0"b;
		vector_map.sign_separate = "0"b;
	     end;

	if ^vector_map.picture_clause & (substr (vector_part, 9, 32) & pic_suff_bits_mask) = "0"b
	then vector_map.no_picture = "1"b;

	call data_length;

	if ^vector_map.occurs_clause
	then temp_bin1 = data_name.item_length;
	else temp_bin1 = data_name.item_length * save_occno;

	offset_ct = offset_ct + temp_bin1;		/*add current item length to ancestors in cobol_htbl*/

	if vector_map.exp_redefining | h = 0
	then goto no_add;

	fh = h;
elem1:
	cobol_htbl.item_length (fh) = cobol_htbl.item_length (fh) + temp_bin1;

	if cobol_htbl.occurs_clause (fh)
	then temp_bin1 = temp_bin1 * cobol_htbl.occno (fh);

	if cobol_htbl.exp_redefining (fh) | fh = 1
	then goto no_add;

	fh = fh - 1;
	goto elem1;

no_add:
	if data_name.occurs_ptr ^= 0 & vector_map.occurs_clause
	then do;

		ptr1 = addr (dn_ptr -> any_item (data_name.occurs_ptr));
		odim = occurs.dimensions;
		occurs.level.struclength (odim) = data_name.item_length;

		if ^vector_map.key_a & ^vector_map.key_d
		then occurs.keyed = 0;

		if vector_map.indexed_by
		then do;

			if ixix ^= 0
			then do;

				j = occurs.level.indexedno (odim);
				k = data_name.offset;

				if ix_ino (ixix) = j
				then do;
elema21ix2:
					rnt_key = ix_key (ixix);
					save_w2 = w2_ptr;

					call cobol_vdwf_dget (cobol_ntfp, fstatus, rnt_ptr, rnt_size, rnt_key);

					w2_ptr = rnt_ptr;
					indexname.struc_length = data_name.item_length;
					indexname.offset = data_name.offset;

					call cobol_vdwf_dput (cobol_ntfp, fstatus, rnt_ptr, rnt_size, rnt_key);

					w2_ptr = save_w2;
					ixix = ixix - 1;

					if ixix = 0
					then goto elema21end;

					if ix_ino (ixix) = j
					then goto elema21ix2;
					else go to elema21end;

				     end;
			     end;

		     end;


	     end;

elema21end:
	if data_name.level = next_level
	then goto actretrn;

lbl21a:
	if cobol_htbl.level (h) < next_level
	then goto actretrn;

	save_ptr = dn_ptr;
	rnt_key = cobol_htbl.nt_rec (h);

	call cobol_vdwf_dget (cobol_ntfp, fstatus, rnt_ptr, rnt_size, rnt_key);

	dn_ptr = rnt_ptr;				/*[5.1-2]*/
	data_name.item_length, data_name.places_left = cobol_htbl.item_length (h);

	if cobol_htbl.do_rec_valid (h) & ^data_name.occurs_do
	then do;

		data_name.variable_length = "1"b;
		data_name.do_rec = cobol_htbl.do_rec (h);

	     end;

	if data_name.occurs_do
	then if next_level ^= 1
	     then call DIAG (31);

	if data_name.initial_ptr ^= 0
	then do;

		ptr1 = addr (dn_ptr -> any_item (data_name.initial_ptr));
		tf = cobol_pic_val_comp (dn_ptr, ptr1);

/*[4.2-5]*/
		if tf > 0
		then call diag (tf, dn_ptr -> record.line, dn_ptr -> record.column);

		tf = 0;				/*in case set to -1*/

	     end;

	if data_name.sign_clause_occurred & ^substr (cobol_htbl.minivector (h), 12, 1)
	then call DIAG (190);

	if ^data_name.exp_occurs | data_name.occurs_ptr = 0
	then do;
		call cobol_vdwf_dput (cobol_ntfp, fstatus, rnt_ptr, rnt_size, rnt_key);
		goto end21;

	     end;

	ptr1 = addr (dn_ptr -> any_item (data_name.occurs_ptr));
	odim = occurs.dimensions;
	occurs.level.struclength (odim) = cobol_htbl.item_length (h);
	offset_ct = save_offsets (data_name.level) + data_name.item_length * cobol_htbl.occno (h);

	if ^data_name.key_a & ^data_name.key_d
	then occurs.keyed = 0;

	call cobol_vdwf_dput (cobol_ntfp, fstatus, rnt_ptr, rnt_size, rnt_key);

	if ^data_name.indexed_by | ixix = 0
	then go to end21;

/*pop indexname stack*/

	j = occurs.level.indexedno (odim);
	k = data_name.offset;			/*will otherwise be lost when io operation done*/

	if ix_ino (ixix) = j
	then do;
ix2:
		rnt_key = ix_key (ixix);
		save_w2 = w2_ptr;

		call cobol_vdwf_dget (cobol_ntfp, fstatus, rnt_ptr, rnt_size, rnt_key);

		w2_ptr = rnt_ptr;
		indexname.struc_length = cobol_htbl.item_length (h);
		indexname.offset = k;

		call cobol_vdwf_dput (cobol_ntfp, fstatus, rnt_ptr, rnt_size, rnt_key);

		w2_ptr = save_w2;
		ixix = ixix - 1;

		if ixix = 0
		then goto end21;

		if ix_ino (ixix) = j
		then goto ix2;
		else go to end21;
	     end;

end21:
	if cobol_htbl.switch_88 (h)
	then do;

		rnt_key = cobol_htbl.nt_rec (h);

		if rnt_key = null_key
		then goto l21aaa;

		call cobol_vdwf_dget (cobol_ntfp, fstatus, rnt_ptr, rnt_size, rnt_key);
l21a:
		call cobol_vdwf_sget (cobol_ntfp, fstatus, rnt_ptr, rnt_size, rnt_key);

		if substr (fstatus, 17, 16) ^= "0"b | rnt_ptr -> record.type ^= 11
		then go to l21aaa;

		temp_bin1 = cn_constant + rnt_ptr -> conditioname.name_size;

		temp_bin1 = temp_bin1 + mod (-temp_bin1, 4);

		temp_bin2 = rnt_ptr -> conditioname.numlits;

		if temp_bin2 < 1
		then goto l21a;
l21aa:
		ptr1 = addr (rnt_ptr -> any_item (temp_bin1 + 1));
		tf = cobol_pic_val_comp (dn_ptr, ptr1);

/*[4.2-5]*/
		if tf > 0
		then call diag (tf, dn_ptr -> record.line, dn_ptr -> record.column);

		if tf < 0
		then do;
			tf = 0;
			call cobol_vdwf_dput (cobol_ntfp, fstatus, rnt_ptr, rnt_size, rnt_key);
		     end;

		if ptr1 -> numinit.initype.numeric
		then temp_bin1 = temp_bin1 + niv_constant + ptr1 -> numinit.length;

		else do;
			if ptr1 -> alphainit.initype.fig_con
			then do;
				if ptr1 -> alphainit.info.fig_con_index = "0000001"b
				then temp_bin1 = temp_bin1 + niv_constant + 1;
				else temp_bin1 = temp_bin1 + aiv_constant;
			     end;
			else temp_bin1 = temp_bin1 + aiv_constant + ptr1 -> alphainit.length;
		     end;

		temp_bin1 = temp_bin1 + mod (-temp_bin1, 4);

		if temp_bin2 = 1
		then goto l21a;

		temp_bin2 = temp_bin2 - 1;
		goto l21aa;

	     end;

l21aaa:
	dn_ptr = save_ptr;				/*pop hierarchy stack*/
	h = h - 1;

	if h = 0
	then goto actretrn;

	goto lbl21a;

groupa21:						/*level number of finished item less than new level number*/
	vector_map.non_elementary = "1"b;

/*push hierarchy stack*/
	h = h + 1;
	ptr4 = addr (cobol_htbl (h));

	ptr4 -> chtbl_item = 0;

	cobol_htbl.level (h) = data_name.level;		/*	cobol_htbl.offset(h)=data_name.offset;*/
	cobol_htbl.occno (h) = save_occno;
	cobol_htbl.do_rec (h) = data_name.do_rec;

	if bnw ^= 0
	then cobol_htbl.nt_rec (h) = null_key;
	else cobol_htbl.nt_rec (h) = save_wkey;

	cobol_htbl.occurs_clause (h) = vector_map.occurs_clause;
	cobol_htbl.odo_switch (h) = vector_map.occurs_do;

	if data_name.occurs_ptr ^= 0
	then cobol_htbl.occurs_ext (h) = "1"b;

	cobol_htbl.switch_88 (h) = save_switch_88;	/* save_switch_88 will be reset in action 17 */
	cobol_htbl.exp_redefining (h) = vector_map.exp_redefining;
	cobol_htbl.minivector (h) = vectord.minivector;
	goto actretrn;



data_length:
     proc;

	bit32_1 = substr (vector_part, 9, 32) & non_display_bits_mask;

	if vector_map.item_signed & vector_map.numeric
	then do;

		if vector_map.sign_separate
		     | ((vector_map.ascii_packed_dec_b | vector_map.ascii_packed_dec_h) & vector_map.pic_has_s)
		then goto incr_lnth;
		else if bit32_1 = "0"b		/* display data */
		then if vector_map.sign_type = "000"b
		     then if fixed_common.default_sign_type = "011"b | fixed_common.default_sign_type = "100"b
			then go to incr_lnth;

		goto no_incr;

incr_lnth:
		data_name.item_length = data_name.item_length + 1;

	     end;
no_incr:
	if bit32_1 = thirty_two_zeros
	then return;				/* display data */

	if vector_map.bin_16
	then do;
		data_name.item_length = 2;
		data_name.places_right = 0;
		data_name.places_left = 5;
		goto dl_end;
	     end;

	if vector_map.bin_18
	then do;
		data_name.item_length = 2;
		data_name.places_right = 0;
		data_name.places_left = 6;
		go to dl_end;
	     end;

	if vector_map.bin_32
	then do;
		data_name.item_length = 4;
		data_name.places_right = 0;
		data_name.places_left = 10;
		go to dl_end;
	     end;

	if vector_map.bin_36
	then do;
		data_name.item_length = 4;
		data_name.places_right = 0;
		data_name.places_left = 11;
		go to dl_end;
	     end;

/*test packed decimal*/

	if vector_map.ebcdic_packed_dec | vector_map.ascii_packed_dec_h | vector_map.ascii_packed_dec_b
	then do;
		data_name.item_length = divide (data_name.item_length + 1, 2, 15, 0);
		goto dl_end;
	     end;

	if vector_map.usage_index = "1"b
	then data_name.item_length = 6;
dl_end:
	vector_map.pic_integer = "1"b;

     end;



actlbl (13):					/*action(22):*/
	vector_map.picture_clause = "1"b;
	goto actretrn;


/* picture_analysis */

actlbl (14):					/*action(23):*/
						/* The following variables may be as well declared within the host procedure */
dcl	pic_image		char (128),		/*translated picture string*/
	spec_char		char (1),
	t		fixed bin,		/*indexes current PICTURE character in image string*/
						/* i indexes last character picked up in image,
					may be PICTURE character or right parenthesis
					of repetition factor*/
	p		fixed bin,		/*work*/
	r		fixed bin,
	n		fixed bin,		/*work*/
	m		fixed bin,		/*work*/
	arrpntr		fixed bin,		/*binary value from character position in image--
				used as index into tables and label array piclabel*/
	piccounter1	fixed bin,		/*number of consecutive identical characters, including those
				indicated by a parenthesized integer*/
	piccounter2	fixed bin,		/*number of consecutive receiving characters between two fixed insertions*/
	inscnter		fixed bin,		/*number of fixed inserts in entire picture string*/
	fltswitch1	bit (1),			/*set when pic contains floating insert(s)*/
	fltswitch2	bit (1),			/*set when t indexes to the left of the right boundary of the
				string to be suppressed for floating insertion and for
				zero suppression*/
	fltswitch3	bit (1),
	auxvector1	bit (32),			/*work*/
	auxvector2	bit (32),			/*constant zeroes*/
	propvector	bit (32),			/*properties of current item according to picture string*/
	fltchar		char (1),			/*current floating insertion character*/
	editlim		fixed bin,		/*maximum edit string size*/
	auxbit		bit (1),
	mask4x		bit (32),
	picptr		pointer,			/*addresses edit extension*/
	filstring		char (30);		/*contains receiving characters for moving into edit string*/

declare	pic_ch		char (1),
	nsi		bit (1);
declare	ch		char (1),
	pic_string_ptr	ptr;

declare	pic_array		(128) char (1) based (pic_string_ptr);

/* inftble is property matrix */
/* prectble is precedence array */

	filstring = filstring_init;
	editlim = 256;
	propvector = thirty_two_zeros;
	auxvector2 = thirty_two_zeros;
	piccounter2 = 0;
	inscnter = 0;
	fltswitch1 = "0"b;
	fltswitch2 = "0"b;
	fltswitch3 = "0"b;
	pic_string_ptr = addr (picture.string);
	picptr = ptr1;
	j = 1;

	if picture.length > 30
	then go to aerr;

	pic_image = picture.string;

/* after the length was checked the picture string is translated below */

	i = 0;
	nsi = "0"b;


	do while (i < picture.length);

	     i = i + 1;
	     pic_ch = substr (pic_image, i, 1);

	     if pic_ch ^= fixed_common.currency & index (ch_str, pic_ch) ^= 0
	     then nsi = "1"b;

	     bit9 = unspec (substr (pic_image, i, 1));
	     m = fixed (bit9, 35);
	     substr (pic_image, i, 1) = transltble (m);

	end;

	if nsi
	then do;
		call DIAG (215);

/*[4.0-4]*/
		if fixed_common.comp_level < "5"
		then call LEV_DIAG (28);

	     end;

	substr (pic_image, i + 1, 1) = stopper;

	i = 0;

mainloop:
	i = i + 1;

	bit9 = unspec (substr (pic_image, i, 1));
	arrpntr = fixed (bit9, 15);

	if arrpntr > 32
	then go to err2;

	piccounter1 = 1;
	t = i;

/*check property matrix for repeatable character*/
	if substr (inftble (arrpntr), 1, 1) ^= "1"b
	then go to pic4;
pic1:
	i = i + 1;

	if substr (pic_image, i, 1) = "("
	then go to anext;

	if i <= picture.length
	then do;
		if substr (picture.string, i, 1) = substr (picture.string, i - 1, 1)
		then do;
			piccounter1 = piccounter1 + 1;
			go to pic1;
		     end;
	     end;

	i = i - 1;
	go to pic3;

anext:						/*pick up repetition factor*/
	i = i + 1;

	if substr (unspec (substr (pic_image, i, 1)), 6, 4) ^= "1111"b
	then go to err3;

	k = i;
next1:
	i = i + 1;

	if substr (unspec (substr (pic_image, i, 1)), 6, 4) = "1111"b
	then go to next1;

	if substr (pic_image, i, 1) ^= ")"
	then go to err3;

	piccounter1 = piccounter1 - 1 + fixed (substr (picture.string, k, i - k));

pic3:						/*set for +,-,$,*.P,Z */
	if substr (inftble (arrpntr), 2, 1) ^= "1"b
	then go to pic4;

/*analysis for legal insertion and to determine whether fixed or floating*/

	if substr (inftble (arrpntr), 3, 1) = "1"b
	then go to pic3a;

	if arrpntr ^= 12
	then do;
		if fltswitch3 = "0"b
		then do;
			fltswitch3 = "1"b;
			fltswitch2 = "1"b;
			editor.start_supress = data_name.item_length + 1;
		     end;
		go to pic6;
	     end;

	vector_map.pic_has_p = "1"b;

	if data_name.item_length ^= inscnter
	then do;
		data_name.places_left = data_name.places_left + piccounter1;
		data_name.places_right = data_name.places_right - piccounter1;
		go to pic4;
	     end;

	data_name.places_right = data_name.places_right + piccounter1;
	data_name.places_left = data_name.places_left - piccounter1;
	substr (propvector, 2, 1) = "1"b;
pic5:
	arrpntr = arrpntr + 1;
	go to pic4;

pic3a:
	if fltswitch1
	then if substr (picture.string, t, 1) = fltchar
	     then go to pic8;
	     else go to pic5;

	if piccounter1 > 1
	then go to pic7;

	if data_name.item_length ^= inscnter
	then go to pic5;

	k = i;
pic3b:
	k = k + 1;

	if k > picture.length
	then go to pic6;

	bit9 = unspec (substr (pic_image, k, 1));
	n = fixed (bit9, 15);

	if arrpntr = n
	then go to pic7;

	if n > 31
	then do;
pic3b1:
		k = k + 1;
		if k > picture.length
		then go to pic6;
		if substr (picture.string, k, 1) = ")"
		then go to pic3b;
		else go to pic3b1;
	     end;

	if substr (inftble (n), 4, 1)
	then go to pic3b;
pic6:
	if substr (propvector, 4, 1) | substr (propvector, 2, 1)
	then go to pic5;
	go to pic4;

pic7:
	fltswitch1 = "1"b;
	fltswitch2 = "1"b;
	fltchar = substr (picture.string, t, 1);
	editor.start_supress = data_name.item_length + 1;
pic8:
	arrpntr = arrpntr + 2;
	go to pic6;

pic4:						/* test precedence */
	auxvector1 = propvector & prectble (arrpntr);

/* if auxvector is zeroes, string is valid so far */
	if auxvector1 ^= auxvector2
	then go to err1;

/* set property vector bit for current PICTURE character */
	substr (propvector, arrpntr, 1) = "1"b;

/* test for PICTURE character contributing to total length of data item */
	if substr (inftble (arrpntr), 5, 1) = "0"b
	then go to pic9;

	data_name.item_length = data_name.item_length + piccounter1;

/* test for PICTURE character contributing to receiving field size in item */
	if substr (inftble (arrpntr), 6, 1) = "0"b
	then go to pic4a;

/* increment consecutive receiving characters field size counter */

	piccounter2 = piccounter2 + piccounter1;

/* test for V or . has already occurred in string */

	if substr (propvector, 4, 1) | substr (propvector, 2, 1)
	then do;
		data_name.places_right = data_name.places_right + piccounter1;
		go to pic9;
	     end;

	data_name.places_left = data_name.places_left + piccounter1;
	go to pic9;

pic4a:						/* characters not contributing to receiving field size but contributing to total item length */
	inscnter = inscnter + piccounter1;

	if data_name.item_length > editlim
	then go to err4;

/* test the number of receiving characters accumulated since last insertion and plop into ecm */

	if piccounter2 = 0
	then go to pic4b;

/*[4.2-4]*/
	call fill_edit;

	j = j + piccounter2;
	piccounter2 = 0;

pic4b:						/* 1 or more consecutive insertion characters get put into ecm */
	do p = 1 to piccounter1;

	     if arrpntr = 4				/*period(functionally)*/
	     then do;
		     if fixed_common.obj_dec_comma
		     then substr (editor.ecm, j + p - 1, 1) = ",";
		     else substr (editor.ecm, j + p - 1, 1) = ".";
		end;

	     else if arrpntr = 3			/*comma (functionally)*/
	     then do;
		     if fixed_common.obj_dec_comma
		     then substr (editor.ecm, j + p - 1, 1) = ".";
		     else substr (editor.ecm, j + p - 1, 1) = ",";
		end;

	     else do;
		     ch = pic_array (t);

		     if ch = "B"
		     then ch = " ";
		     else if ch = "h"
		     then ch = "-";

		     substr (editor.ecm, j + p - 1, 1) = ch;

		end;
	end;

	j = j + piccounter1;
pic9:
	go to piclabel (arrpntr);

piclabel (1):					/* B */
piclabel (3):					/* , */
piclabel (15):					/* 0 */
	if fltswitch2
	then editor.max_supress = editor.max_supress + piccounter1;
	go to mainloop;

piclabel (2):					/* V */
piclabel (4):					/* . */
piclabel (31):					/* 9 */
	fltswitch2 = "0"b;
	go to mainloop;

piclabel (5):					/* C */
	if substr (picture.string, i + 1, 1) = "R"
	then do;
		i = i + 1;
		data_name.item_length = data_name.item_length + 1;
		substr (editor.ecm, j, 1) = "R";
		inscnter = inscnter + 1;
		editor.fixed_insert = 5;		/* blank when >=0 */
		vector_map.item_signed = "1"b;
		go to mainloop;
	     end;

	go to err3;

piclabel (6):					/* D */
	if substr (picture.string, i + 1, 1) = "B"
	then do;
		i = i + 1;
		data_name.item_length = data_name.item_length + 1;
		substr (editor.ecm, j, 1) = "B";
		inscnter = inscnter + 1;
		editor.fixed_insert = 5;		/* blank when >=0 */
		vector_map.item_signed = "1"b;
		go to mainloop;
	     end;

	go to err3;

piclabel (7):					/* E */
						/*		call ioa_("E not implemented yet");*/
	go to mainloop;

piclabel (8):					/* Z to left of decimal point */
	editor.max_supress = editor.max_supress + piccounter1;
	go to mainloop;

piclabel (10):					/*asterisk to left of decimal point */
	editor.max_supress = editor.max_supress + piccounter1;
	vector_map.pic_has_ast = "1"b;
	go to mainloop;

piclabel (18):					/* floating left + */
	editor.max_supress = editor.max_supress + piccounter1;
	editor.float_insert = 2;
	vector_map.item_signed = "1"b;
	go to mainloop;

piclabel (22):					/* floating left - */
	editor.max_supress = editor.max_supress + piccounter1;
	editor.float_insert = 3;
	vector_map.item_signed = "1"b;
	go to mainloop;

piclabel (26):					/* floating left $ */
	editor.max_supress = editor.max_supress + piccounter1;
	editor.float_insert = 1;
	go to mainloop;

piclabel (9):					/* Z to right of decimal point */
	vector_map.pic_has_ast = "0"b;
	vector_map.bwz = "1"b;
	goto extra_label;

piclabel (27):					/* floating right $ */
	vector_map.pic_has_ast = "0"b;
	vector_map.bwz = "1"b;
	go to mainloop;

piclabel (19):					/* floating right + */
piclabel (23):					/* floating right - */
	vector_map.pic_has_ast = "0"b;
	vector_map.bwz = "1"b;
	vector_map.item_signed = "1"b;
	go to mainloop;

piclabel (11):					/* asterisk to right of decimal point */
	vector_map.ast_when_zero = "1"b;

extra_label:
	if substr (propvector, 13, 1)
	then editor.start_supress = 0;
	go to mainloop;

piclabel (14):					/* L */
	vector_map.pic_has_l = "1"b;
	vector_map.variable_length = "1"b;
	go to mainloop;

piclabel (16):					/* fixed left + */
	substr (editor.ecm, j - 1, 1) = "-";
	editor.fixed_insert = 4;
	vector_map.item_signed = "1"b;
	go to mainloop;

piclabel (17):					/* fixed right + */
	substr (editor.ecm, j - 1, 1) = "-";
	editor.fixed_insert = 2;
	vector_map.item_signed = "1"b;
	go to mainloop;

piclabel (20):					/* fixed left - */
	editor.fixed_insert = 3;
	vector_map.item_signed = "1"b;
	go to mainloop;

piclabel (21):					/* fixed right - */
	editor.fixed_insert = 1;
	vector_map.item_signed = "1"b;
	go to mainloop;

piclabel (28):					/* S */
	vector_map.pic_has_s = "1"b;
	vector_map.item_signed = "1"b;
	go to mainloop;

piclabel (24):					/* fixed left $ */
	substr (editor.ecm, j - 1, 1) = fixed_common.object_sign;
	goto mainloop;

piclabel (12):					/* P to left of decimal point */
piclabel (13):					/* P to right of decimal point */
piclabel (25):					/* fixed right $ */
piclabel (29):					/* X */
piclabel (30):					/* A */
	go to mainloop;

piclabel (32):					/* stopper character generated at end of PICTURE string by cobol_ddsyntax */
	if inscnter = 0
	then do;
		auxbit = fltswitch1 | fltswitch3;

		if ^auxbit
		then do;
			mask4x = propvector & mask1x;

			if mask4x = mask2x
			then do;

				if substr (propvector, 2, 1) = "0"b
				then vector_map.pic_integer = "1"b;

				vector_map.numeric = "1"b;

				if ^vector_map.item_signed
				then vector_map.pic_unsigned = "1"b;
				go to speclabel;
			     end;

			if mask4x = mask3x
			then vector_map.alphabetic = "1"b;
			else vector_map.alphanum = "1"b;

			go to speclabel;

		     end;
	     end;

	if piccounter2 = 0
	then go to int1;

/*[4.2-4]*/
	call fill_edit;

int1:
	editor.length = data_name.item_length;
	data_name.edit_ptr = data_name.size + 1;
	data_name.size = data_name.size + data_name.item_length + ed_constant;

	data_name.size = data_name.size + mod (-data_name.size, 4);

	r = data_name.size + 1;
	picptr = addr (dn_ptr -> any_item (r));

	if data_name.item_length = inscnter
	then go to err5;

	if substr (propvector, 29, 2) = "00"b
	then do;
		vector_map.numeric_edited = "1"b;

		if fltswitch1
		then do;
			if ^substr (propvector, 13, 1)
			then do;
				data_name.places_left = data_name.places_left - 1;
				substr (editor.ecm, editor.start_supress, 1) = fltchar;
			     end;

			n = editor.max_supress + editor.start_supress;

			if n - 1 = data_name.item_length
			then vector_map.bwz = "1"b;

			if substr (propvector, 13, 1)
			then do;

				data_name.places_right = data_name.places_right - 1;

				if fltchar = "+"
				then do;
					fltchar = "-";
					editor.fixed_insert = 2;
				     end;

				else if fltchar = "-"
				then editor.fixed_insert = 3;
				else fltchar = fixed_common.object_sign;

				substr (editor.ecm, editor.start_supress, 1) = fltchar;
				editor.start_supress = 0;
				editor.max_supress = 0;

			     end;

			if n = data_name.item_length
			then if substr (propvector, 4, 1)
			     then vector_map.bwz = "1"b;
						/*[3.0-1]*/
		     end;

		go to speclabel;

	     end;

	auxbit = substr (propvector, 30, 1) & substr (propvector, 15, 1);

	if substr (propvector, 29, 1) | auxbit
	then vector_map.alphanum_edited = "1"b;
	else vector_map.alphabetic_edited = "1"b;

speclabel:
	ptr1 = picptr;

	goto actretrn;

aerr:
	tf = 130;

err:						/*[4.2-5]*/
	call diag (tf, record.line, record.column);

	goto actretrn;

err2:
	if (arrpntr = 127 | arrpntr = 40 | arrpntr = 41)
	then go to err1;

	tf = 132;
	go to err;

err1:
	tf = 134;
	go to err;

err3:
	if arrpntr < 32
	then go to err1;
	go to err2;

err4:
	tf = 136;
	go to err;

err5:
	tf = 137;
	go to err;

/*[4.2-4]*/
fill_edit:
     proc;					/**/
	save_j = j;				/**/
	if piccounter2 <= 30			/**/
	then substr (editor.ecm, j, piccounter2) = substr (filstring, 1, piccounter2);
						/**/
						/**/
	else do;					/**/
		fixbin15 = 30;			/**/
		temp_bin1 = piccounter2;		/**/
						/**/
		do while ("1"b);			/**/
						/**/
		     substr (editor.ecm, j, fixbin15) = substr (filstring, 1, fixbin15);
						/**/
		     temp_bin1 = temp_bin1 - fixbin15;	/**/
		     j = j + fixbin15;		/**/
						/**/
		     if temp_bin1 = 0
		     then do;
			     j = save_j;
			     return;
			end;			/**/
						/**/
		     if temp_bin1 < 30
		     then fixbin15 = temp_bin1;
		     else fixbin15 = 30;		/**/
		end;
	     end;
     end;						/*[4.2-4]*/


actlbl (15):					/*action(136):*/
						/* inherit parent properties */
	if vector_map.value_clause = "0"b
	then vector_map.elem_no_value = "1"b;

	odim = 0;

	if h = 0
	then goto actretrn;

	fh = h;
	temp_bin1 = data_name.size + 1;

	if cobol_htbl.occurs_ext (fh) & ^vector_map.occurs_clause
	then do;

/*inherit parent's occurs extension ... if vector_map.occurs_clause was set,then
	item inherited parent's extension at time that its own occurs clause was
	parsed ... if parent had one*/

		rnt_key = cobol_htbl.nt_rec (fh);

		call cobol_vdwf_dget (cobol_ntfp, fstatus, rnt_ptr, rnt_size, rnt_key);

		if rnt_ptr -> data_name.occurs_ptr = 0
		then go to postveca136;

		save_ptr = dn_ptr;
		dn_ptr = rnt_ptr;
		pdn_occ_ptr = addr (dn_ptr -> any_item (data_name.occurs_ptr));
		odim = pdn_occ_ptr -> occurs.dimensions;
		ptr1 = addr (save_ptr -> any_item (temp_bin1));
		fixbin7_1 = occ_constant + occ_dim_constant * odim;
		substr (ptr1 -> anystring, 1, fixbin7_1) = substr (pdn_occ_ptr -> anystring, 1, fixbin7_1);
		ptr1 -> occurs.keyed = 0;
lbl136:
		dn_ptr = save_ptr;
	     end;

	if odim ^= 0
	then do;

		data_name.occurs_ptr = data_name.size + 1;
		data_name.size = data_name.size + fixbin7_1;
		data_name.size = data_name.size + mod (-data_name.size, 4);

	     end;

	rnt_key = cobol_htbl.nt_rec (fh);

	call cobol_vdwf_dget (cobol_ntfp, fstatus, rnt_ptr, rnt_size, rnt_key);

postveca136:
	vector_map.assoc_with_signed_num_display =
	     (substr (vector_part, 9, 32) & non_display_bits_mask) = "0"b & vector_map.numeric & vector_map.pic_has_s;

	ptr6 = addr (vectemp);

	vectempd.descr = addr (rnt_ptr -> data_name.file_section) -> bit72 & mask_descr;
	vectempd.minivector = cobol_htbl.minivector (fh) & mask_minivector;
	vectempd.filler = "0"b;

	vector_part = vectemp | vector_part;

	cobol_htbl.minivector (fh) = cobol_htbl.minivector (fh) | (vectord.minivector & mask_minivector_reverse);

	do fh = fh - 1 to 1 by -1;
	     cobol_htbl.minivector (fh) =
		(cobol_htbl.minivector (fh + 1) & mask_minivector_reverse) | cobol_htbl.minivector (fh);
	end;

	goto actretrn;

actlbl (16):					/* action(82) */
	current_line = current_line + org + 1;

	go to new_inst;

actlbl (17):					/* action(83) */
	if int_val = 0
	then if fixed_common.comp_level < "5"		/*[4.0-4]*/
	     then call LEV_DIAG (129);

	go to actretrn;

actlbl (18):					/*action(168)*/
						/*[3.0-2]*/
						/*[4.0-4]*/
	if fixed_common.comp_level < "5"
	then call LEV_DIAG (169);

	go to actretrn;

actlbl (19):					/*action(169)*/
						/* add entry in ref table */
						/*[4.4-1]*/
	ref_table_size = ref_table_size + 1;

/*[4.4-1]*/
	ref.length (ref_table_size) = user_word.word_size;/*[4.4-1]*/
	ref.name (ref_table_size) = substr (user_word.word, 1, user_word.word_size);
						/*[4.4-1]*/
	ref.size (ref_table_size) = 24 + user_word.word_size;

	go to actretrn;

actlbl (20):					/*action(170)*/
						/* process like attribute */
						/*[4.4-1]*/
	if like_key = null_key			/*[4.4-1]*/
	then do;
		hash_table_ptr = addr (hash_table (1)); /* first use, initialize */
						/*[4.4-1]*/
		ref_table_ptr = addr (ref_table (1));	/*[4.4-1]*/
		diag_ptr = addr (diag_token);

/*[4.4-1]*/
		diag_token.size = 28;		/*[4.4-1]*/
		diag_token.run = 6;

/*[4.4-1]*/
		do i = 1 by 1 to 512;

/*[4.4-1]*/
		     hash_table (i) = null ();

/*[4.4-1]*/
		end;

/*[4.4-1]*/
		do i = 1 by 1 to 50;

/*[4.4-1]*/
		     ref_table (i) = addr (ref (i));

/*[4.4-1]*/
		end;

/*[4.4-1]*/
		prev_rec_ptr = null ();		/*[4.4-1]*/
		rec_key = first_key;		/* get first record in name table */
						/*[4.4-1]*/
		call cobol_vdwf_dget (cobol_ext_$cobol_name_fileno_ptr,
						/*[4.4-1]*/
		     status,			/*[4.4-1]*/
		     rec_ptr,			/*[4.4-1]*/
		     rec_size,			/*[4.4-1]*/
		     first_key /*[4.4-1]*/);

/*[4.4-1]*/
		call form_chains;

/*[4.4-1]*/
	     end;

/*[4.4-1]*/
	else do;
		call cobol_vdwf_dget (cobol_ext_$cobol_name_fileno_ptr,
						/*[4.4-1]*/
		     status,			/*[4.4-1]*/
		     rec_ptr,			/*[4.4-1]*/
		     rec_size,			/*[4.4-1]*/
		     like_key /*[4.4-1]*/);

/*[4.4-1]*/
		prev_rec_ptr = rec_ptr;

/*[4.4-1]*/
	     end;

/* process entries added since	*/
/* the last like attribute		*/

/*[4.4-1]*/
	status = "0"b;

/*[4.4-1]*/
	do while (status = "0"b);

/*[4.4-1]*/
	     call cobol_vdwf_sget (cobol_ext_$cobol_name_fileno_ptr,
						/*[4.4-1]*/
		status,				/*[4.4-1]*/
		rec_ptr,				/*[4.4-1]*/
		rec_size,				/*[4.4-1]*/
		rec_key /*[4.4-1]*/);

/*[5.2-1]*/
	     if status = "0"b			/*[4.4-1]*/
	     then do;
		     call form_chains;

/*[4.4-1]*/
		     prev_rec_ptr = rec_ptr;

/*[4.4-1]*/
		end;

/*[4.4-1]*/
	     else last_rec_ptr = addrel (rec_ptr, divide (rec_size + 11, 8, 17, 0) * 2);

/*[4.4-1]*/
	end;

/*[4.4-1]*/
	like_key = rec_key;

/*[4.4-1]*/
	diag_no = 0;


/*[4.4-1]*/
	call cobol_usrwd (ref_table_ptr,		/*[4.4-1]*/
	     ref_table_size,			/*[4.4-1]*/
	     hash_table_ptr,			/*[4.4-1]*/
	     0,					/*[4.4-1]*/
	     last_rec_ptr,				/*[4.4-1]*/
	     "0"b,				/*[4.4-1]*/
	     was_found,				/*[4.4-1]*/
	     not_found,				/*[4.4-1]*/
	     diag_no,				/*[4.4-1]*/
	     rename_object_ptr);


/*[4.4-1]*/
	if was_found
	then do;
		call get_rename_desc;
		go to actretrn;
	     end;


/*[4.4-1]*/
	if not_found				/*[4.4-1]*/
	then do;
		if diag_no = 0
		then diag_token.num = 2;
		else diag_token.num = diag_no;

/*[4.4-1]*/
		call cobol_c_list (diag_ptr);


/*[4.4-1]*/
	     end;


	go to actretrn;


get_rename_desc:
     proc;

/*[4.4-1]*/
	data_name.item_length = rename_object_ptr -> data_name.item_length;
						/*[4.4-1]*/
	data_name.places_left = rename_object_ptr -> data_name.places_left;
						/*[4.4-1]*/
	data_name.places_right = rename_object_ptr -> data_name.places_right;

/*[4.4-1]*/
	vector_map.elementary, vector_map.picture_clause, vector_map.alphanum = "1"b;

     end;

form_chains:
     proc;

/*[4.4-1]*/
declare	(string_size, hashno)
			fixed bin;		/*[4.4-1]*/
declare	string_ptr	ptr;

/*[4.4-1]*/
declare	string		char (30) based (string_ptr);

/*[5.2-1]*/
	if rec_ptr -> data_name.type = 9		/*[5.2-1]*/
	then do;
		string_size = rec_ptr -> data_name.name_size;
						/*[5.2-1]*/
		string_ptr = addr (rec_ptr -> data_name.name);
						/*[5.2-1]*/
	     end;					/*[5.2-1]*/
	else if rec_ptr -> procname.type = 7		/*[5.2-1]*/
	then do;
		string_size = rec_ptr -> procname.length;
						/*[5.2-1]*/
		string_ptr = addr (rec_ptr -> procname.name);
						/*[5.2-1]*/
	     end;					/*[5.2-1]*/
	else if rec_ptr -> conditioname.type = 11	/*[5.2-1]*/
	then do;
		string_size = rec_ptr -> conditioname.name_size;
						/*[5.2-1]*/
		string_ptr = addr (rec_ptr -> conditioname.name);
						/*[5.2-1]*/
	     end;					/*[5.2-1]*/
	else if rec_ptr -> fd.type = 12 | rec_ptr -> fd.type = 16
						/*[5.2-1]*/
	then do;
		string_size = rec_ptr -> fd.name_size;	/*[5.2-1]*/
		string_ptr = addr (rec_ptr -> fd.name); /*[5.2-1]*/
	     end;					/*[5.2-2]*/
	else if rec_ptr -> indexname.type = 10		/*[5.2-2]*/
	then do;
		string_size = rec_ptr -> indexname.name_size;
						/*[5.2-2]*/
		string_ptr = addr (rec_ptr -> indexname.name);
						/*[5.2-2]*/
	     end;					/*[5.2-2]*/
	else return;

/*[4.4-1]*/
	hashno = 0;

/*[4.4-1]*/
	do i = 1 by 1 to string_size;

/*[4.4-1]*/
	     hashno = hashno + fixed (unspec (substr (string, i, 1)));

/*[4.4-1]*/
	end;

/*[4.4-1]*/
	hashno = mod (hashno, 512) + 1;

/*[4.4-1]*/
	procname.string_ptr = hash_table (hashno);	/*[4.4-1]*/
	hash_table (hashno) = rec_ptr;

/*[4.4-1]*/
	procname.string_ptr = prev_rec_ptr;		/*[4.4-1]*/
	prev_rec_ptr = rec_ptr;

     end;

actlbl (21):					/* action(84) */
						/* issue diag attached to prev token */
						/*[5.1-3]*/
	call diag (TF, save_last_line, save_last_column); /*[5.1-3]*/
	TF = 0;

	go to actretrn;


/***** check routines *****/

/* section_header */

check (1):
	if min_eof
	then do;
		next_level = 1;
		go to success;
	     end;

	else if (record.type = 1 & rw.class.section_header = "1"b)
	then do;
		call a_test;
		next_level = 1;
		go to success;
	     end;

	go to fail;

/* fs_precedence */

check (2):
	if substr (section_ind, 2, 7) = "0"b
	then goto success;
	go to fail;

/* wss_indicator */

check (3):
	if substr (section_ind, 2, 1) = "0"b
	then goto success;
	go to fail;

/* cns_precedence */

check (4):
	if substr (section_ind, 4, 5) = "0"b
	then goto success;
	go to fail;

/* cns_indicator */

check (5):
	if substr (section_ind, 3, 1) = "0"b
	then goto success;
	else goto fail;

/* lks_precedence */

check (6):
	if substr (section_ind, 5, 4) = "0"b
	then goto success;
	go to fail;

/* lks_indicator */

check (7):
	if substr (section_ind, 4, 1) = "0"b
	then goto success;
	go to fail;

/* integer */

int:
check (8):					/*[5.1-1]*/
	if record.type = 1				/*[5.1-1]*/
	then if rw.key = 180			/*[5.1-1]*/
	     then do;
		     int_val, temp_bin1 = 0;		/*[5.1-1]*/
		     go to success;			/*[5.1-1]*/
		end;				/*[5.1-1]*/
	     else go to fail;			/*[5.1-1]*/
	else if record.type ^= 2 | numeric_lit.rtdp ^= 0
	then go to fail;

	if numeric_lit.length > 18
	then call DIAG (218);

	int_val, temp_bin1 = fixed (numeric_lit.literal);

	go to success;

/* integer_77 */

lev77:
check (9):
	call level_number (77);

	next_level = 1;

	goto success;

/* integer_01 */

lev01:
check (10):
	call level_number (1);

/*[4.3-2]*/
	if numeric_lit.length = 1
	then if fixed_common.comp_level < "3"
	     then call LEV_DIAG (218);

	s_lin = record.line;
	s_col = record.column;

	next_level = 1;

	goto success;

/* user_word */

type8:
check (11):
	if record.type = 8
	then do;					/* if fixed_common.comp_level < "5"
			then	if record.column < 12
				then	call LEV_DIAG(142);	*/
						/*[4.4-2]*/

/*[4.2-3]*/
		filler_flag = "0"b;

		go to success;
	     end;
	go to fail;

/* dd_clause_header */

check (12):
	if record.type ^= 1
	then go to fail;

	if rw.class.dd_clause = "1"b
	then goto success;
	go to fail;


/* code set clause */

check (13):
codeset:
	if user_word.type ^= 8
	then go to fail;

	if fixed_common.alphabet_offset ^= 0
	then do;
		alf_offset = fixed_common.alphabet_offset;

		do while (alf_offset ^= 0);

		     call cobol_vdwf_dget (cobol_ntfp, alf_status, alf_ptr, alf_size, alf_key);

		     if user_word.word = alf_ptr -> alphabet_name.name
		     then do;
			     file_table.code_set_clause = "1"b;
			     file_table.code_set = alf_ptr -> alphabet_name.iw_key;

			     go to success;

			end;

		     alf_offset = addr (alf_ptr -> alphabet_name.prev_rec) -> fb;

		end;

	     end;

	alf_offset = cobol_imp_word$alphabet_name (min_ptr);

	if alf_offset = 0
	then go to fail;

	call DIAG (204);

	file_table.code_set_clause = "1"b;
	file_table.code_set = alf_offset + 10;

	go to success;


/* integer_88 */

lev88:
check (14):
	call level_number (88);

	go to success;

/* integer_66 */

lev66:
check (15):
	call level_number (66);

	next_level = 1;

	goto success;

/* linage footing body integer */

check (16):
	if linage_rec.footing = 5 & linage_rec.body = 5 & linage_rec.footing_int > linage_rec.body_int
	then go to fail;

	go to success;


/* integer_02_49 */

lev0249:
check (17):
	call level_number (0);

	if int_val >= 2 & int_val <= 49
	then do;
		if res
		then call DIAG (216);
		next_level = temp_bin1;

		if fixed_common.comp_level < "3" & int_val > 10
						/*[4.0-4]*/
		then call LEV_DIAG (141);

/*[4.3-2]*/
		if numeric_lit.length = 1
		then if fixed_common.comp_level < "3"
		     then call LEV_DIAG (218);

		go to success;
	     end;

	go to fail;

level_number:
     proc (level);

declare	level		fixed bin;

	if record.type ^= 2
	then go to fail;

/*[5.1-1]*/
	if record.type = 2
	then int_val, temp_bin1 = fixed (numeric_lit.literal);
	else int_val, temp_bin1 = 0;

	if numeric_lit.sign ^= " " | numeric_lit.rtdp ^= 0 | numeric_lit.ltdp + numeric_lit.rtdp > 2
	then res = "1"b;
	else res = "0"b;

	if level = 0 | level = 66 | level = 88
	then return;

	if int_val ^= level
	then go to fail;

/*[4.2-2]*/
	if record.column = 9999
	then return;

	if res
	then call DIAG (216);

	call a_test;

     end;

a_test:
     proc;

	if record.column < 8 | record.column > 11
	then do;
		call DIAG (219);

/*[4.2-2]*/
		if fixed_common.comp_level < "5"
		then call lev_diag (133);

	     end;

     end;

/* picture_clause */

check (18):
	if vector_map.picture_clause = "0"b
	then goto success;
	go to fail;

/* picture_char_string */

check (19):
	if record.type = 4
	then goto success;
	go to fail;

/* usage_clause */

check (20):
	if vector_map.usage_clause = "0"b
	then goto success;
	go to fail;

/* father_son usage */

check (21):
	if h = 0
	then goto success;

	rnt_key = cobol_htbl.nt_rec (h);

	call cobol_vdwf_dget (cobol_ntfp, fstatus, rnt_ptr, rnt_size, rnt_key);



/*mask out all bits but USAGE ones*/

	bit32_1 = substr (addr (rnt_ptr -> data_name.file_section) -> bit72, 9, 32) & usage_bits_mask;

	if bit32_1 = "0"b
	then goto success;

	bit32_2 = substr (vector_part, 9, 32) & usage_bits_mask;

	if bit32_2 = bit32_1
	then goto success;

	goto fail;

/* value_indicator */

check (22):
	if vector_map.value_clause = "0"b
	then goto success;
	go to fail;

/*numeric_literal */

check (23):
	if record.type = 2
	then goto success;
	go to fail;

/* alphanumeric_literal */

check (24):
	if record.type = 3
	then goto success;
	go to fail;

/* rw_figurative_constant */

figcon:
check (25):
	if fixed_common.comp_level < "3"
	then do;
		if record.type = 1 & rw.class.fig_con
		then do;
			if rw.class.end_dec		/*[4.0-4]*/
			then call LEV_DIAG (154);
			go to success;
		     end;
	     end;
	else do;
		if record.type = 1 & rw.class.fig_con
		then go to success;
	     end;
	go to fail;

/* father_no_value */

check (26):
	if h = 0
	then goto success;

	rnt_key = cobol_htbl.nt_rec (h);

	call cobol_vdwf_dget (cobol_ntfp, fstatus, rnt_ptr, rnt_size, rnt_key);

	if substr (addr (rnt_ptr -> data_name.file_section) -> bit72, 47, 2) = "0"b
	then go to success;

	goto fail;

/* sign_clause */

check (27):
	if sign_clause = "0"b
	then goto success;
	go to fail;

/* father_sign_clause */

check (28):
	if h = 0
	then goto success;

	rnt_key = cobol_htbl.nt_rec (h);

	call cobol_vdwf_dget (cobol_ntfp, fstatus, rnt_ptr, rnt_size, rnt_key);

	if rnt_ptr -> data_name.sign_type
	then go to fail;
	go to success;

/* father_son_sign_type */


check (29):
	if h = 0
	then goto success;

	sign_type_temp = data_name.sign_type;
	rnt_key = cobol_htbl.nt_rec (h);

	call cobol_vdwf_dget (cobol_ntfp, fstatus, rnt_ptr, rnt_size, rnt_key);

	if rnt_ptr -> data_name.sign_type
	then go to fail;
	else if rnt_ptr -> data_name.sign_type = sign_type_temp
	then go to success;
	goto fail;

/*sync*/

check (30):
	if vector_map.sync_right = "0"b
	then goto success;
	go to fail;

/* father_88 */

check (31):
	if h = 0
	then goto success;

	do fh = h to 1 by -1;
	     if cobol_htbl.switch_88 (fh)
	     then goto fail;
	end;
	goto success;

/* just_indicator */


check (32):
	if vector_map.just_right = "0"b & vector_map.just_left = "0"b
	then goto success;
	go to fail;

/* bwz_clause */

check (33):
	if vector_map.bwz = "0"b
	then goto success;
	go to fail;

/* occurs_clause */

check (34):
	if h = 0 | vector_map.occurs_clause
	then go to fail;
	goto success;

/* occurs_dimension */

check (35):
	if occurs.dimensions < 3
	then goto success;
	go to fail;

check (36):
labnam:						/* value of clause */
	label_field_num = cobol_imp_word$label_name (min_ptr);

	if label_field_num ^= 0
	then go to success;

	go to fail;

/* occurence_number */

check (37):
	if occurs.level.max (odim) ^= 0
	then goto success;
	go to fail;

/* occurs_minimax */

check (38):
	if occurs.level.max (odim) > occurs.level.min (odim)
	then goto success;
	go to fail;

/* father_subscripted */

check (39):
	if h = 0
	then goto success;

	rnt_key = cobol_htbl.nt_rec (h);

	call cobol_vdwf_dget (cobol_ntfp, fstatus, rnt_ptr, rnt_size, rnt_key);

	if ^rnt_ptr -> data_name.subscripted
	then goto success;

	goto fail;

/* linage footing redundancy */

check (40):
	if fd_ind.linage_type.footing = "1"b
	then goto fail;
	go to success;

/* linage bottom redundancy */

check (41):
	if fd_ind.linage_type.bottom = "0"b
	then goto success;
	go to fail;

/* indexed_by */

check (42):
	if vector_map.indexed_by = "0"b
	then goto success;
	go to fail;

/* father_indexed_by */

check (43):
	if h = 0
	then goto success;

	rnt_key = cobol_htbl.nt_rec (h);

	call cobol_vdwf_dget (cobol_ntfp, fstatus, rnt_ptr, rnt_size, rnt_key);

	if ^rnt_ptr -> data_name.subscripted | rnt_ptr -> data_name.indexed_by
	then goto success;

	goto fail;

/*test for Level 64 COBOL running*/

check (44):
	goto success;

/* thru_value */

check (45):
	goto success;

/* father_usage_index */

check (46):
	if h = 0
	then goto success;

	rnt_key = cobol_htbl.nt_rec (h);

	call cobol_vdwf_dget (cobol_ntfp, fstatus, rnt_ptr, rnt_size, rnt_key);

	if ^rnt_ptr -> data_name.usage_index
	then goto success;

	goto fail;

/* fs_cms_rdf_01 */

check (47):
	if data_name.level ^= 1
	then go to success;
	if vector_map.file_section = "1"b | vector_map.communication_section = "1"b
	then goto fail;
	goto success;



check (48):
labval:						/* examine label field literal */
	if label_field_num ^= 0
	then go to LV (label_field_num);

	if numeric_lit.type = 2 | alphanum_lit.type = 3 | (rw.type = 1 & rw.class.fig_con)
	then go to success;

	go to fail;

LV (1):						/* file-id */
	if numeric_lit.type = 2			/* numeric lit */
	then go to fail;

	else if alphanum_lit.type = 3			/* alphanumeric lit */
	then do;
		if alphanum_lit.length > 17
		then tf = 194;
		go to success;
	     end;

	else if rw.type = 1 & rw.class.fig_con		/* figurative const */
	then go to success;

	go to fail;

LV (2):						/* retention */
	if numeric_lit.type = 2			/* numeric lit */
	then do;
		if ^(numeric_lit.integer & numeric_lit.sign = " " & numeric_lit.length <= 3)
		then tf = 212;

		go to success;

	     end;

	else if alphanum_lit.type = 3			/* alphanumeric literal */
	then go to fail;

	else if rw.type = 1 & rw.class.fig_con		/* figurative const */
	then do;
		if ^(rw.key = 180)			/* is_word("ZERO") */
		then tf = 213;
		go to success;

	     end;

	go to fail;

LV (3):						/* catalogue-name */
	if alphanum_lit.type = 3
	then do;
		if alphanum_lit.length > 168
		then do;
			tf = 222;
			alphanum_lit.length = 168;
		     end;

		go to success;

	     end;

	go to fail;

/* linage top redundancy */

check (49):
	if fd_ind.linage_type.top = "0"b
	then goto success;
	go to fail;

check (50):
all:						/* test for all fig const */
	if rw.type = 1 & rw.key = 73			/* is_word("ALL") */
	then do;
		all_ind = 1;

/*[4.0-4]*/
		if fixed_common.comp_level < "3"
		then call LEV_DIAG (144);

		go to success;
	     end;

	all_ind = 0;

	go to fail;

/* level = 01 or 77, but dont push level stack */

check (51):
lev0177:
	if record.type ^= 2
	then go to fail;

/*[5.1-1]*/
	if record.type = 2
	then int_val, temp_bin1 = fixed (numeric_lit.literal);
	else int_val, temp_bin1 = 0;

	if int_val = 1 | int_val = 77
	then do;
		next_level = 1;
		go to success;
	     end;

	go to fail;

lrc:
check (52):
	if FD_indic = "0"b
	then go to success;
	else if file_table.label_format ^= 0
	then go to success;

	go to fail;

/*[4.0-1]*/
dup_type8:
check (53):					/*[4.0-1]*/
	if record.type = 8				/*[4.0-1]*/
	then do;
		if fixed_common.comp_level < "3"	/*[4.0-1]*/
		then if index (tok_string, "~" || user_word.word || "~") > 0
						/*[4.0-4]*/
		     then call LEV_DIAG (182);

/*[4.0-1]*/
		go to success;			/*[4.0-1]*/
	     end;

/*[4.0-1]*/
	go to fail;

/* fs_indicator */

check (54):
	if substr (section_ind, 1, 1) = "0"b
	then goto success;
	go to fail;

/* fs_level_indicator */

check (55):
fsind:
	if record.type = 1 & rw.class.fs_ind = "1"b
	then do;
		call a_test;
		next_level = 1;

		if rw.key = 219			/* fd */
		then FD_indic = "1"b;
		else FD_indic = "0"b;
		go to success;
	     end;

	go to fail;

/* file_name_match */

check (56):
	i = 0;

next_file:
	i = i + 1;

	if i > fixed_common.file_count
	then goto fundefined;

/* get file record number in common file */

	cm_key = fixed_common.filedescr_offsets (i);

	call cobol_vdwf_dget (cobol_cmfp, fstatus, cm_ptr, cm_size, cm_key);

	ft_ptr = cm_ptr;

	if file_table.name_size = fd_token.name_size
	then if substr (file_table.name, 1, file_table.name_size) = substr (fd_token.name, 1, fd_token.name_size)
	     then do;
		     org = file_table.organization;

/*[4.0-2]*/
		     call init_src;

		     go to success;
		end;

	if i = 20
	then goto next_file_chain;

	goto next_file;

next_file_chain:
	if file_table.next = null_key
	then goto fundefined;

	cm_key = file_table.next;

	call cobol_vdwf_dget (cobol_cmfp, fstatus, cm_ptr, cm_size, cm_key);

	ft_ptr = cm_ptr;

	if file_table.name_size = fd_token.name_size
	then if substr (file_table.name, 1, file_table.name_size) = substr (fd_token.name, 1, fd_token.name_size)
	     then do;
		     org = file_table.organization;

/*[4.0-2]*/
		     call init_src;

		     go to success;
		end;

	goto next_file_chain;

fundefined:
	fd_token.file_no = 0;
	org = 0;
	goto fail;

check (57):
	if record.type = 1 & rw.class.fs_ind
	then do;
		next_level = 1;
		go to success;
	     end;

	go to fail;

/* file_01 */

check (58):
	if ll01 = "1"b | fd_ind.report_is = "1"b
	then goto success;
	go to fail;

/* fd_record_contain */

check (59):
	if fd_ind.record_contain = "0"b
	then goto success;
	go to fail;

/* fd_data_record */

check (60):
	if fd_ind.data_record = "0"b
	then goto success;
	go to fail;

/* fd_clause_header */

check (61):					/*[4.0-2]*/
	if record.type ^= 1
	then go to fail;				/*[4.0-2]*/
	if ^rw.class.fd_clause
	then go to fail;

/*[4.0-2]*/
	if rw.key = 219
	then ii = 1;				/* fd */
						/*[4.0-2]*/
	else if rw.key = 237
	then ii = 2;				/* recording */
						/*[4.0-2]*/
	else if rw.key = 205
	then ii = 3;				/* block */
						/*[4.0-2]*/
	else if rw.key = 148
	then ii = 4;				/* record */
						/*[4.0-2]*/
	else if rw.key = 121
	then ii = 5;				/* label */
						/*[4.0-2]*/
	else if rw.key = 258
	then ii = 6;				/* value */
						/*[4.0-2]*/
	else if rw.key = 196
	then ii = 7;				/*data */
						/*[4.0-2]*/
	else if rw.key = 240
	then ii = 8;				/* reports */
						/*[4.0-2]*/
	else if rw.key = 563
	then ii = 9;				/* linage */
						/*[4.0-2]*/
	else if rw.key = 306
	then ii = 10;				/* code-set */
						/*[4.0-2]*/
	else go to fail;

/*[4.0-2]*/
	source_pos.line (ii) = rw.line;		/*[4.0-2]*/
	source_pos.column (ii) = rw.column;

	go to success;

/*[4.0-2]*/
init_src:
     proc;

/*[4.0-2]*/
	do ii = 1 by 1 to 10;

/*[4.0-2]*/
	     source_pos.line (ii) = 0;

/*[4.0-2]*/
	end;

/*[4.0-2]*/
	source_pos.line (1) = rw.line;		/*[4.0-2]*/
	source_pos.column (1) = rw.column;

     end;

check (62):
sechdr:
	if min_eof | (record.type = 1 & rw.class.section_header = "1"b)
	then do;
		next_level = 1;
		go to success;
	     end;

	go to fail;

check (63):
lev66s:						/*[5.0-1]*/
	call test_level_number (66);
	next_level = 1;
	go to success;

check (64):
lev88s:
	call test_level_number (88);

/*[4.2-3]*/
	if filler_flag = "1"b
	then if fixed_common.comp_level < "3"
	     then call LEV_DIAG_SAVED (176);
	go to success;

test_level_number:
     proc (num);

declare	num		fixed bin;

	call level_number (num);

	if int_val ^= num
	then go to fail;

     end;

/* fd_recording_mode */

check (65):
	if fd_ind.recording_mode = "0"b
	then goto success;
	go to fail;

/* fd_block_contain */

check (66):
	if fd_ind.block_contain = "0"b & fd_token.type = 12
	then goto success;
	go to fail;

/* fd_record_contain */

check (67):
	if fd_ind.record_contain = "0"b
	then goto success;
	go to fail;

/* fd_label_record */


check (68):
	if fd_ind.label_record = "0"b & fd_token.type = 12
	then goto success;
	go to fail;

/* fd_value_of */

check (69):
	if fd_ind.value_of = "0"b & fd_token.type = 12
	then goto success;
	go to fail;

/* fd_data_record */

check (70):
	if fd_ind.data_record = "0"b
	then goto success;
	go to fail;

/* fd_report_is */

check (71):
	if fd_ind.report_is = "0"b & fd_token.type = 12	/*[4.4-1]*/
	then do;
		file_table.organization, file_table.device = 1;
		go to success;
	     end;
	go to fail;				/* fd_linage_is */

check (72):
	if fd_ind.linage_is = "0"b & fd_token.type = 12
	then goto success;
	go to fail;

/*[4.0-2]*/
per_ck:
check (73):					/*[4.0-2]*/
	if rw.type ^= 1
	then go to fail;				/*[4.0-2]*/
	if rw.key ^= 189
	then go to fail;				/* "." */

/*[4.0-2]*/
	do ii = 1 by 1 to 10;

/*[4.0-2]*/
	     if source_pos.line (ii) ^= 0		/*[4.0-2]*/
	     then do;
		     lev_message.line = source_pos.line (ii);
						/*[4.0-2]*/
		     lev_message.column = source_pos.column (ii);

/*[4.0-2]*/
		     go to FT (ii);

FT (1):
		     num = 36;
		     call LEV1;
		     go to FT1;			/* fd */
FT (2):
		     num = 192;
		     mod_num = 25;
		     LEV = "5";
		     go to FT1;			/* recording mode */
FT (3):
		     num = 37;
		     call LEV1;
		     go to FT1;			/* block contains */
FT (4):
		     num = 193;
		     call LEV1;
		     go to FT1;			/* record contains */
FT (5):
		     num = 38;
		     call LEV1;
		     go to FT1;			/* label records */
FT (6):
		     num = 189;
		     call LEV1;
		     go to FT1;			/* value of */
FT (7):
		     num = 190;
		     call LEV1;
		     go to FT1;			/* data records */
FT (8):
		     num = 122;
		     mod_num = 25;
		     LEV = "5";
		     go to FT1;			/* reports are */
FT (9):
		     num = 191;
		     call LEV2;
		     go to FT1;			/* linage */
FT (10):
		     num = 168;
		     go to FT1;			/* code-set */

/*[4.0-2]*/
FT1:						/*[4.0-2]*/
		     if LEV > fixed_common.comp_level	/*[4.0-2]*/
		     then do;
			     lev_message.module = mod_num;
						/*[4.0-2]*/
			     lev_message.number = num;

/*[4.0-2]*/
			     call cobol_c_list (lev_message_ptr);

/*[4.0-2]*/
			     mod_num = 0;		/*[4.0-2]*/
			end;

/*[4.0-2]*/
		end;

/*[4.0-2]*/
	end;

	go to success;

LEV1:
     proc;

/*[4.0-2]*/
	mod_num = lev1_mod (org);			/*[4.0-2]*/
	LEV = lev1_org (org);

     end;

LEV2:
     proc;

/*[4.0-2]*/
	mod_num = lev2_mod (org);			/*[4.0-2]*/
	LEV = lev2_org (org);

     end;

check (74):					/* skip debug item decls if not needed */
						/*[4.4-3]*/
	if fixed_common.use_debug | fixed_common.debug
	then go to success;



/*[4.2-1]*/
/*[4.0-5] */
	do while (record.column = 9999 & ^min_eof);

/*[4.0-3]*/
	     call scan;				/*[4.0-3]*/
	end;

/*[4.0-3]*/
	go to success;



/* father_son_value_usage */

check (75):
	if h = 0
	then goto success;

	rnt_key = cobol_htbl.nt_rec (h);

	call cobol_vdwf_dget (cobol_ntfp, fstatus, rnt_ptr, rnt_size, rnt_key);

	if substr (addr (rnt_ptr -> data_name.file_section) -> bit72, 47, 2) = "0"b
	then go to success;

	if vector_map.display
	then goto success;

	goto fail;

/* usage_display */

check (76):
	if vector_map.display = "1"b
	then goto success;
	go to fail;

check (77):					/* skip terminator for debug item decl */
						/*[4.0-3]*/
	if record.type = 3 /*[4.0-3]*/ & /*[4.0-3]*/ alphanum_lit.length = 6 /*[4.0-3]*/
	     & /*[4.0-3]*/ substr (alphanum_lit.string, 1, alphanum_lit.length) = "~~~~~~"
						/*[4.0-3]*/
	then go to success;				/*[4.0-3]*/
	else go to fail;

check (78):
renames:
	go to fail;
















check (79):
test_like:
	if like_clause
	then go to fail;
	else go to success;

/****** communication section check routines *****/

check (80):
	if substr (section_ind, 6, 3) = "000"b
	then goto success;
	go to fail;

/* uniqueness of cms */

check (81):
	if substr (section_ind, 5, 1) = "1"b
	then goto fail;
	go to success;

/* uniqueness of INTIAL for cd */

check (82):
	if cd_initial = "0"b
	then goto success;
	go to fail;

/* cd input clause header */

check (83):
	if rw.type = 1 & rw.class.cd_input = "1"b
	then goto success;
	go to fail;

/* cd input record length=87 output record length=23 */

check (84):
	if save_cdo = 0
	then cd_out_size = 23;
	else cd_out_size = 10 + 13 * save_cdo;

	if data_name.level ^= 1 & data_name.level ^= 77
	then if (substr (cd_clauses, 12, 1) & cobol_htbl.item_length (1) <= 87)
		| (^substr (cd_clauses, 12, 1) & cobol_htbl.item_length (1) <= cd_out_size)
	     then goto success;
	     else go to fail;

	else if (substr (cd_clauses, 12, 1) & data_name.item_length <= 87)
	     | (^substr (cd_clauses, 12, 1) & data_name.item_length <= cd_out_size)
	then goto success;
	else go to fail;

/* uniqueness of symbolic que clause */

check (85):
	if substr (cd_clauses, 1, 1) = "0"b
	then goto success;
	go to fail;

/* uniqueness of message count */

check (86):
	if substr (cd_clauses, 11, 1) = "0"b
	then goto success;
	go to fail;

/* uniqueness of sub-queue-1 */

check (87):
	if substr (cd_clauses, 2, 1) = "0"b
	then goto success;
	go to fail;

/* uniqueness of sub-queue-2 */

check (88):
	if substr (cd_clauses, 3, 1) = "0"b
	then goto success;
	go to fail;

/* uniqueness of sub-queue-3 */
check (89):
	if substr (cd_clauses, 4, 1) = "0"b
	then goto success;
	go to fail;

/* uniqueness of symbolic source clause */

check (90):
	if substr (cd_clauses, 7, 1) = "0"b
	then goto success;
	go to fail;

/* uniqueness of message date or symbolic destination clause */

check (91):
	if substr (cd_clauses, 5, 1) = "0"b
	then goto success;
	go to fail;

/* uniqueness of message times */

check (92):
	if substr (cd_clauses, 6, 1) = "0"b
	then goto success;
	go to fail;

/* uniqueness of text length */

check (93):
	if substr (cd_clauses, 8, 1) = "0"b
	then goto success;
	go to fail;

/* uniqueness of end key clause */

check (94):
	if substr (cd_clauses, 9, 1) = "0"b
	then goto success;
	go to fail;

/* uniqueness of status key clause */

check (95):
	if substr (cd_clauses, 10, 1) = "0"b
	then goto success;
	go to fail;

/* cd output clause header */

check (96):
	if rw.type = 1 & rw.class.cd_output = "1"b
	then goto success;
	go to fail;

check (97):
	;
check (98):
	;
check (99):
	;

check (100):					/*       call ioa_("compiler error run3: routine ^d is unused ",tf);*/
	goto fail;


/*[5.1-3]*/
dcl	(RL, RC)		fixed bin;
scan:
     proc;

scan_next:					/*[5.1-3]*/
	save_last_line = RL;			/*[5.1-3]*/
	save_last_column = RC;

	call cobol_swf_get (cobol_m1fp, fstatus, min_ptr, min_size_r);

	if substr (fstatus, 17, 16) ^= "0"b
	then do;

		if substr (fstatus, 17, 16) = "0000000000100111"b
		then do;
			min_eof = "1"b;
			goto outscan;
		     end;

		pre_end_sw = "1"b;

		goto outscan;

	     end;

/*[5.1-3]*/
	RL = record.line;				/*[5.1-3]*/
	RC = record.column;

	if record.type = 5
	then call cobol_c_list (min_ptr);

	if record.type = 7 | record.type = 24 | (record.type = 5 & record.info.rep = "0"b)
	then goto scan_next;

	if record.type = 2
	then nl = numeric_lit.length;
	if record.type = 3
	then al = alphanum_lit.length;
	if record.type = 8
	then ul = user_word.word_size;

	if min_ptr = null ()
	then do;

outscan:
		min_ptr = addr (name_string);		/*for fake token*/

/*[5.1-3]*/
		rw.line = RL;			/*[5.1-3]*/
		rw.column = RC;
		rw.type = 1;
		rw.key = 142;			/*PROCEDURE*/
		rw.class.filler4 = "00"b;
		rw.class.fig_con = "0"b;
		rw.class.filler5 = "0"b;
		rw.class.section_header = "1"b;
		rw.class.fs_ind = "0"b;
		rw.class.fd_clause = "0"b;
		rw.class.dd_clause = "0"b;
		rw.class.cd_input = "0"b;
		rw.class.cd_output = "0"b;
		rw.class.cset_name = "0"b;
		rw.class.filler6 = "00000000000"b;
		rw.jump_index = 30;			/* 5*6 */

	     end;

     end scan;


DIAG:
     proc (num);

declare	(num, tf_save)	fixed bin;

	tf_save = tf;
	tf = num;

/*[4.2-5]*/
	call diag (tf, record.line, record.column);

	tf = tf_save;

     end;

diag:
     proc (diag_num, line, column);

/*[4.2-5]*/
declare	(diag_num, line, column)
			fixed bin;

	message_ptr = addr (message_area);

	ptr4 = addr (message_area);
	ptr4 -> cma = 0;

	message.size = msg_constant;			/*[4.2-5]*/
	message.line = line;			/*[4.2-5]*/
	message.column = column;
	message.type = 5;
	message.run3 = 3;
	message.info.para = "0"b;
	message.info.rep = "0"b;
	message.info.fillerx = "000000"b;
	message.length = 0;
	message.number = diag_num;

	call cobol_c_list (message_ptr);

	diag_num = 0;
     end diag;

lev_diag:
     proc (diag_num);

declare	diag_num		fixed bin;

	lev_message.line = record.line;
	lev_message.column = record.column;
	lev_message.number = diag_num;
	lev_message.module = mod_num;

/*[4.0-2]*/
	call cobol_c_list (lev_message_ptr);

	mod_num = 0;

     end;

LEV_DIAG:
     proc (diag_num);

/*[4.0-4]*/
declare	diag_num		fixed bin;

/*[4.0-4]*/
	mod_num = 0;

/*[4.0-4]*/
	call lev_diag (diag_num);

     end;

/*[4.2-3]*/
LEV_DIAG_SAVED:
     proc (diag_num);

/* Prints diagnostic at the line and column saved in saved_line
   ans saved_column					*/

dcl	diag_num		fixed bin;

	lev_message.line = saved_line;
	lev_message.column = saved_column;
	lev_message.number = diag_num;
	lev_message.module = 0;

	call cobol_c_list (lev_message_ptr);

     end LEV_DIAG_SAVED;

pre_end:
comp_end:
	call cobol_ddact1 (98);			/*action(62)*/
	return;

/*[4.0-1]*/
init_tok_string:
     entry;

/*[4.0-1]*/
	tok_string = "~";				/*[4.0-1]*/
	return;

/*[4.0-1]*/
enter_tok_string:
     entry (ch36);

/*[4.0-1]*/
	if index (tok_string, "~" || ch36) <= 0		/*[4.0-1]*/
	then tok_string = tok_string || ch36;

/*[4.0-1]*/
	return;

/*[4.0-1]*/
dcl	ch36		char (36) varying;		/*[4.0-1]*/
dcl	tok_string	char (1024) varying static internal;

/*[4.0-2]*/
dcl	1 lev_message	static internal,		/*[4.0-2]*/
	  2 size		fixed bin,		/*[4.0-2]*/
	  2 line		fixed bin,		/*[4.0-2]*/
	  2 column	fixed bin,		/*[4.0-2]*/
	  2 type		fixed bin,		/*[4.0-2]*/
	  2 run		fixed bin,		/*[4.0-2]*/
	  2 number	fixed bin,		/*[4.0-2]*/
	  2 module	fixed bin;

/*[4.0-2]*/
dcl	lev_message_ptr	ptr static internal;

/*[4.0-2]*/
dcl	1 source_pos	(10),			/*[4.0-2]*/
	  2 line		fixed bin,		/*[4.0-2]*/
	  2 column	fixed bin;

/*[4.0-2]*/
dcl	(ii, num)		fixed bin,
	LEV		char (1);

/*[4.0-2]*/
dcl	lev1_org		(5) char (1) init ("0", "2", "4", "0", "0");
						/*[4.0-2]*/
dcl	lev2_org		(5) char (1) init ("3", "3", "4", "0", "5");

/*[4.0-2]*/
dcl	lev1_mod		(5) fixed bin init (15, 17, 19, 0, 25);
						/*[4.0-2]*/
dcl	lev2_mod		(5) fixed bin init (16, 18, 20, 0, 26);

get_file_key:
     entry (fnumber) returns (char (5));

/*[4.0-3]*/
declare	fnumber		fixed bin;

/*[4.0-3]*/
	return (FILE_REC_TAB.file_key (fnumber));

init_file_tab:
     entry;

/*[4.0-3]*/
	FILE_REC_TAB.file_ind = "1"b;			/*[4.0-3]*/
	FILE_REC_TAB.file_count = FILE_REC_TAB.file_count + 1;
						/*[4.0-3]*/
	FILE_REC_TAB.file_key (FILE_REC_TAB.file_count) = "";

/*[4.0-3]*/
	return;

/*[4.0-3]*/
declare	1 FILE_REC_TAB	static int,		/*[4.0-3]*/
	  2 file_count	fixed bin,		/*[4.0-3]*/
	  2 file_ind	bit (1),			/*[4,0-3]*/
	  2 file_key	(128) char (5);

/*[4.2-3]*/
declare	saved_line	fixed bin,
	saved_column	fixed bin,
	filler_flag	bit (1);

declare	cobol_imp_word$alphabet_name
			entry (ptr) returns (fixed bin);
declare	cobol_imp_word$label_name
			entry (ptr) returns (fixed bin);
declare	alf_ptr		ptr;
declare	key		fixed bin,
	int_val		fixed bin (71);
declare	(mod_num, act_num, org, TF, save_j)
			fixed bin;

declare	1 alf,
	  2 alf_size	fixed bin,
	  2 alf_key	char (5),
	  2 alf_key_ptr	ptr,
	  2 alf_status	bit (32);

declare	alf_offset	fixed bin based (alf_key_ptr);
declare	fb		fixed bin based;

declare	test_v		fixed bin;		/*store test field*/
declare	se		fixed bin;
declare	cslno		fixed bin;
declare	stack		(30) fixed bin;
declare	stack_index	fixed bin;
declare	slptr		ptr;
declare	fstatus		bit (32);			/*io return code*/
declare	bit9		bit (9);
declare	syntab_ptr	ptr;
declare	cd_out_size	fixed bin;

declare	1 indicators,
	  2 FD_indic	bit (1),
	  2 res		bit (1);

declare	1 dd_static	static internal,
	  2 save_last_line	fixed bin,
	  2 save_last_column
			fixed bin,
	  2 s_lin		fixed bin,
	  2 s_col		fixed bin;



declare	null_key		char (5) internal static init ("00000");
declare	thirty_two_zeros	bit (32) internal static init ("00000000000000000000000000000000"b);
declare	filstring_init	char (30) internal static;
declare	cobol_initstatic	entry ext;		/*initialize variables*/
declare	cobol_ddst	entry (ptr) ext;		/*initialize syntax table*/
declare	cobol_ddact1	entry (fixed bin);
declare	cobol_ddact2	entry (fixed bin);

declare	1 qual_rec	based (qual_ptr),
	  2 next		char (5),
	  2 size		fixed bin,
	  2 name		char (0 refer (qual_rec.size));

%include cobol_file_key;
declare	1 alphabet_name	based (min_ptr),
%include cobol_TYPE40;
%include cobol_ext_;

%include cobol_ext_ddsyn;
%include cobol_special_dcls;
%include cobol_spec_constants;
dcl	sv_ptr_auto	ptr;
dcl	1 shared_var	based (sv_ptr_auto),
%include cobol_shared_var;

/*[4.4-1]*/
declare	data_name_bits	bit (5000) based;

/*[4.4-1]*/
declare	hash_table	(512) ptr;

/*[4.4-1]*/
declare	ref_table		(50) ptr;

/*[4.4-1]*/
declare	1 ref		(50),			/*[4.4-1]*/
	  2 size		fixed bin,		/*[4.4-1]*/
	  2 line		fixed bin,		/*[4.4-1]*/
	  2 column	fixed bin,		/*[4.4-1]*/
	  2 type		fixed bin,		/*[4.4-1]*/
	  2 info_bit	bit (8),			/*[4.4-1]*/
	  2 length	fixed bin,		/*[4.4-1]*/
	  2 name		char (30);

/*[4.4-1]*/
declare	1 diag_token,				/*[4.4-1]*/
	  2 size		fixed bin,		/*[4.4-1]*/
	  2 line		fixed bin,		/*[4.4-1]*/
	  2 column	fixed bin,		/*[4.4-1]*/
	  2 type		fixed bin,		/*[4.4-1]*/
	  2 run		fixed bin,		/*[4.4-1]*/
	  2 num		fixed bin,		/*[4.4-1]*/
	  2 info		bit (36);

/*[4.4-1]*/
declare	(hash_table_ptr, ref_table_ptr, diag_ptr)
			ptr;			/*[4.4-1]*/
declare	(like_key, rec_key, first_key)
			char (5);

/*[4.4-1]*/
declare	(prev_rec_ptr, rec_ptr, last_rec_ptr)
			ptr;			/*[4.4-1]*/
declare	rec_size		fixed bin;		/*[4.4-1]*/
declare	(was_found, not_found, like_clause, first_rec)
			bit (1);			/*[4.4-1]*/
declare	rename_object_ptr	ptr;			/*[4.4-1]*/
declare	rename_object_size	fixed bin;		/*[4.4-1]*/
declare	(diag_no, ref_table_size)
			fixed bin (15);

/*[4.4-1]*/
declare	cobol_usrwd	entry (ptr, fixed bin (15), ptr, fixed bin (15), ptr, bit (1), bit (1), bit (1),
			fixed bin (15), ptr);

/*[4.4-1]*/
declare	status		bit (32);

dcl	bit32_1		bit (32);			/*work field for USAGE analysis*/
dcl	bit32_2		bit (32);			/*ditto*/
dcl	usage_bits_mask	bit (32) init ("00000110000000000001111111100000"b) internal static;
						/*masks out non-USAGE bits from a P7-byte-aligned substring of description bits vector*/
dcl	non_display_bits_mask
			bit (32) init ("00000110000000000000111111100000"b) internal static;
						/*usage anything but display*/
dcl	pic_suff_bits_mask	bit (32) init ("00000110000000000000000011100000"b) internal static;
						/*masks out all but picture-sufficient usage bits*/
dcl	numeric_usage_bits_mask
			bit (32) internal static init ("00000110000000000000011111000000"b);
						/*masks out all but numeric usage bits*/
dcl	based_char_string	char (11) based;		/*overlays vectemp bit structure*/
dcl	alph		char (1);			/*work field for consistency analysis*/
dcl	log_mask		(8) bit (8) internal static
			init ("10000000"b, "01000000"b, "00100000"b, "00010000"b, "00001000"b, "00000100"b,
			"00000010"b, "00000001"b);
dcl	1 matrix1		internal static,
	  2 m1		(88) bit (64)
			init ("0111111000000000000000000000000000000000000000000000000000000000"b,
			"0011110000000000000000000000000000000000000000000000000000000000"b,
			"0001110000010000000000000000000000100000000000000000000000000000"b,
			"0000110000000000000000000000000000000000000000000000000000000000"b,
			"0000010000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000110100000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000001000000000000000000000000011111000000100000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000100000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000010000000000011111111111001000000010000000000000000"b,
			"0000000000000000000000000011111111111001000000010000000000000000"b,
			"0000000000000000001010101000011011111001000000000000000000000000"b,
			"0000000000000000001010101000011011111001000000000000000000000000"b,
			"0000000000000000001111100000000000000000000000010000000000000000"b,
			"0000000000000000000111100000111111000000000000100000000000000000"b,
			"0000000000000000000011111000111111000001000000100000000000000000"b,
			"0000000000000000000001100000111111000001000000100000000000000000"b,
			"0000000000000000000000111000111111000001000000100000000000000000"b,
			"0000000000000000000000011000111111011001000000100000000000000000"b,
			"0000000000000000000000000000000000011000000000000000000000000000"b,
			"0000000000000000000000000000000000011001000000100000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000011000000000000000000000000000000"b,
			"0000000000000000000000000000111111100000000000000000000000000000"b,
			"0000000000000000000000000000011111100000000000000000000000000000"b,
			"0000000000000000000000000000001111111001000000010000000000000000"b,
			"0000000000000000000000000000000111111001000000010000000000000000"b,
			"0000000000000000000000000000000011111001000000010000000000000000"b,
			"0000000000000000000000000000000001111001000000010000000000000000"b,
			"0000000000000000000000000000000000111001000000010000000000000000"b,
			"0000000000000000000000000000000000011111000000000000000000000000"b,
			"0000000000000000000000000000000000001001000000100000000000000000"b,
			"0000000000000000000000000000000000000001100000100000000000000000"b,
			"0000000000000000000000000000000000000010000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000100000100000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000010000000000000000"b,
			"0000000000000000000000000000000000000000000000001000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b);
dcl	1 matrix2		internal static,
	  2 m2		(88) bit (64)
			init ("0000000000001000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000001000000000000000000000000000000000000000000000000"b,
			"0000000000001000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0100000000000010000000000000000000000000000000000000000000000000"b,
			"0100000000000000000000000000000000000000000000000000000000000000"b,
			"0000000001000000000000000000000000000000000000000000000000000000"b,
			"0000000000000010000000000000000000000000000000000000000000000000"b,
			"0000000000000010000000000000000000000000000000000000000000000000"b,
			"0000000000001000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000001000000000000000000000000000000000000000000000000000000"b,
			"0000000001000000000000000000000000000000000000000000000000000000"b,
			"0000000000001000000000000000000000000000000000000000000000000000"b,
			"0000000000001000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000100000000000000000000000000000000000000000000000000000"b,
			"0000000000100000000000000000000000000000000000000000000000000000"b,
			"0000000000100000000000000000000000000000000000000000000000000000"b,
			"0000000000100000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000100000000000000000000000000000000000000000000000000000"b,
			"0000000010000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000010000000000000000000000000000000000000000000000000"b,
			"0000000000000010000000000000000000000000000000000000000000000000"b,
			"0000000000000010000000000000000000000000000000000000000000000000"b,
			"0000000001000000000000000000000000000000000000000000000000000000"b,
			"0000000001000000000000000000000000000000000000000000000000000000"b,
			"0000000001101000000000000000000000000000000000000000000000000000"b,
			"0000000000100000000000000000000000000000000000000000000000000000"b,
			"0000000000100000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000100000000000000000000000000000000000000000000000000000"b,
			"0100000000001000000000000000000000000000000000000000000000000000"b,
			"0000000000001000000000000000000000000000000000000000000000000000"b,
			"0000000000001000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000100000000000000000000000000000000000000000000000000000"b,
			"0000000010000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000001000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000100000000000000000000000000000000000000000000000000000"b,
			"0000000000000010000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000001000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b,
			"0000000000000000000000000000000000000000000000000000000000000000"b);
dcl	1 mi_overlay	based (ptr4),
	  2 mi_overlay_bit9 bit (9),
	  2 mi_overlay_part bit (128);

declare	(addr, divide, fixed, mod, null, substr, unspec, size)
			builtin;

%include cobol_non_static;
%include cobol_type9;
%include cobol_occurs;
%include cobol_fd_token;
declare	1 cdtoken		based (cdtoken_ptr),
%include cobol_TYPE13;
declare	1 fd		based,
%include cobol_TYPE12;
%include cobol_linage_rec;
%include cobol_skey_rec;
%include cobol_fixed_common;
%include cobol_file_table;
declare	1 procname	based (rec_ptr),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 string_ptr	ptr,
	  2 prev_rec	ptr,
	  2 info		bit (8),
	  2 priority	char (2),
	  2 repl_bits	bit (8),
	  2 section_num	fixed bin,
	  2 proc_num	fixed bin,
	  2 def_line	fixed bin,
	  2 length	fixed bin,
	  2 name		char (30);
     end cobol_ddsyntax;
