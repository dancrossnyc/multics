/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8082),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8082 cobol_db_phase.pl1 Fix wild array subscript.
                                                   END HISTORY COMMENTS */


/* Modified on 02/11/85 by FCH, [5.3-1], conditional statements revised, BUG561 */
/* Modified on 12/30/81 by FCH, [5.1-1], eof not properly detected if debugging mode, phx11819(BUG517)*/
/* Modified on 09/17/81 by FCH, debug proc not exec on ACCEPT MESSAGE COUNT, BUG505 */
/* Modified on 07/10/81 by FCH, [4.4-4], debug cards not processed unless use for debugging used (phx10378, BUG493) */
/* Modified on 02/20/81 by FCH, [4.4-3], fix debugging for communication statements, BUG465 */
/* Modified on 12/10/80 by FCH, [4.4-2], cobol_db_phase$initialize called by cobol_lex instead of cobol_res_words */
/* Modified on 10/20/80 by FCH, [4.4-1], automatic items changed to static int options(const) */
/* Modified on 06/13/80 by FCH, [4.3-1], debug-sub-i described with sign */
/* Modified on 05/08/80 by FCH, [4.2-1], END-PERFORM not written after PERFORM pn1 THRU pn2 */
/* Modified on 09/21/79 by FCH, [4.0-1], Fix DEBUG-LINE on pn (DB101) */
/* Created for Version 4.0 by FCH on 03/20/79 */






/* format: style3 */
cobol_db_phase:
     proc;

start:						/* the following are init changed to assign */
	gotodep = "0"b;
	preospn_bit = "0"b;
	nestifcnt = 0;
	cssub = 0;
	mod_num = 0;

	emrec = "0"b;
	copy_tab.size = 0;
	copy_mode = "0"b;
	impswitch = 0;
	decswitch = 0;
	nest_lev = 0;
	N_L = "1"b;
	secswitch = 0;

	i1 = 0;
	syntax_line_ptr = addr (sline);
	sline.s_exit = 59;				/* 59*5+5 */

	call cobol_db (pointer_to_internal, dumfix);	/* initialize diag item */

	dg_ptr = addr (diag_item);
	diag_item.size = 28;
	diag_item.type = 5;
	diag_item.run = 10;
	TOK_ptr, ft_ptr, occptr = null ();

/*[4.0-1]*/
	ln_not_emitted = "1"b;			/*[4.0-1]*/
	nines_ptr = null ();
	lev_dg_ptr = addr (lev_diag_item);
	lev_diag_item.size = 28;
	lev_diag_item.type = 5;
	lev_diag_item.run = 9;

	diag_item.info = "00000000"b;
	DIAG_NUM = 0;
	trace_ptr = addr (interp);
	tbit = fixed_common.syntax_trace;
	pn_count = 0;

	debug_table.cd.first_ptr, debug_table.cd.last_ptr = null ();
	debug_table.file.first_ptr, debug_table.file.last_ptr = null ();
	debug_table.proc.first_ptr, debug_table.proc.last_ptr = null ();
	debug_table.data.first_ptr, debug_table.data.last_ptr = null ();

	debug_table.cd.size = 0;
	debug_table.file.size = 0;
	debug_table.proc.size = 0;
	debug_table.data.size = 0;

	debug_table.cd.max = 5;
	debug_table.file.max = 20;
	debug_table.proc.max = 50;
	debug_table.data.max = 50;

	string (debug_table.data.all_refs) = "0"b;

	data_size = size (data_entry);
	proc_size = size (proc_entry);
	file_size = size (file_entry);
	cd_size = size (cd_entry);

	call st_init;
	all_procs = "0"b;
	TOK_TAB.size = 0;

	if tbit
	then call cobol_syntax_trace_$initialize_phase (trace_ptr, 4);

	call SCAN;

	current_line = syntax_line.s_exit;

	go to new_inst;

get_rec:
     entry (crp, REC_NUM);

/* called by cobol_get_rec which	*/
/* is called by cobol_res_words after	*/
/* PROCEDURE DIVISION		*/


	crp = addr (DD (REC_NUM));

/*[5.1-1]*/
	if REC_NUM = 17
	then REC_NUM = 0;

	return;

declare	crp		ptr,
	REC_NUM		fixed bin;

/*[4.4-1]*/
declare	DD		(16) char (73) static int options (constant)
			init ("~~~~~~ 01   debug-item.                                                 
", "~~~~~~ 02      debug-line      picture is x(6).                         
", "~~~~~~ 02      filler          picture is x value space.                
", "~~~~~~ 02      debug-name      picture is x(30).                        
", "~~~~~~ 02      filler          picture is x value space.                
", "~~~~~~ 02      debug-subs.
", "~~~~~~ 03      debug-sub-1     pic is s9999
", "~~~~~~                   sign is leading separate character.
", "~~~~~~ 03      filler          picture is x value space.                
", "~~~~~~ 03      debug-sub-2     pic is s9999
", "~~~~~~                   sign is leading separate character.
", "~~~~~~ 03      filler          picture is x value space.                
", "~~~~~~ 03      debug-sub-3     pic is s9999
", "~~~~~~                   sign is leading separate character.
", "~~~~~~ 03      filler          picture is x value space.                
", "~~~~~~ 02      debug-contents  picture is x(2048). ""~~~~~~""
");

get_perf:
     entry (crp, REC_NUM);

/* called by cobol_get_rec which	*/
/* is called by cobol_res_words after	*/
/* END DECLARATIVES			*/

/*[4.4-1]*/
declare	perf_line		char (72) static int;

declare	proc_count	fixed bin static int;

/*[5.1-1]*/
	if proc_def_size = 0 | proc_count >= proc_def_size + 1
	then do;
		REC_NUM = 0;
		return;
	     end;

	proc_count = proc_count + 1;

	if proc_count <= proc_def_size
	then do;

		perf_line = "~~~~~~     perform " || proc_def_table (proc_count) -> proc_def.name || ".
";

/*[4.4-1]*/
		crp = perf_line_ptr;

	     end;

	else crp = addr (TKN (17));

	return;


get_tok:
     entry (crp, REC_NUM);

/* called by cobol_get_rec which	*/
/* is called by cobol_res_words after	*/
/* WORKING STORAGE			*/

	crp = addr (TKN (REC_NUM));

/*[5.1-1]*/
	if REC_NUM = 18
	then REC_NUM = 0;


	return;

/*[4.4-1]*/
dcl	TKN		(17) char (73) static int options (constant)
			init ("~~~~~~      debug-line debug-name debug-contents                        
", "~~~~~~      debug-sub-1 debug-sub-2 debug-sub-3                         
", "~~~~~~      ""LLLLLL"" ""NNNNNNNNNNNNNNNNNNNNNNNNNNNNNN""                   
", "~~~~~~      move to ""~"" ""~"" = space perform
", "~~~~~~      ""START PROGRAM"" ""SORT INPUT"" ""SORT OUTPUT"" ""MERGE OUTPUT""   
", "~~~~~~      ""PERFORM LOOP"" ""USE PROCEDURE"" ""FALL THROUGH""               
", "~~~~~~      set compute up by end-perform times until not )
", "~~~~~~      thru add end-if
", "~~~~~~      on size error at end invalid key eop overflow
", "~~~~~~      with data exception no end-add end-call 
", "~~~~~~      end-compute end-delete
", "~~~~~~      end-divide end-evaluate end-if end-multiply end-perform
", "~~~~~~      end-read end-receive end-return end-rewrite
", "~~~~~~      end-search end-start
", "~~~~~~      end-string end-subtract end-unstring end-write
", "~~~~~~      ( if DEBUG-ON . debug-subs ""999999""
", "~~~~~~      ""~~~""
");

proc_def_ptr:
     entry (proc_def_ptr);				/* used by cobol_res_words, use for debugging */
declare	proc_def_table	(64) ptr static internal;
declare	proc_def_size	fixed bin static internal;

declare	proc_def_ptr	ptr;

	proc_def_size = proc_def_size + 1;
	proc_def_table (proc_def_size) = addrel (proc_def_ptr, 1);

	return;

initialize:
     entry;

/*[4.4-1]*/
declare	perf_line_ptr	ptr static int;		/* called by cobol_lex */
	proc_def_size, proc_count = 0;		/*[4.4-2]*/
						/*	fixed_common.debug = "1"b;*/
						/*[4.4-1]*/
	perf_line_ptr = addr (perf_line);

	return;

/*					*/
/*	 syntax interpreter			*/
/*					*/

fail:						/*failure */
	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm2);

next_inst:
	current_line = current_line + 1;

new_inst:						/* new instruction */
	syntax_line_ptr = addr (syntax_table (current_line));

	go to test (syntax_line.t_type);

test (0):						/* reserved word test */
	if reserved_word.type ^= 1
	then go to fail;

	if reserved_word.key ^= syntax_line.t_field
	then go to fail;

success:						/* success */
	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm1);

ucon:
	if syntax_line.o_bit ^= " "
	then do;
		if syntax_line.o_bit > fixed_common.comp_level
		then call lev_diag (syntax_line.a_num);
		go to ret;
	     end;

	go to action (syntax_line.a_num);

test (1):						/* check routine test */
	go to check (syntax_line.t_field);

test (2):						/* unconditional branch */
	DIAG_NUM = syntax_line.t_field;
	act_num = syntax_line.a_num;

	if syntax_line.o_bit ^= " "
	then do;
		if syntax_line.o_bit > fixed_common.comp_level
		then do;
			mod_num = syntax_line.a_num;
			call lev_diag (DIAG_NUM);
		     end;

		DIAG_NUM = 0;
		act_num = 0;
	     end;

	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm1);

	go to action (act_num);

test (3):
	i1 = i1 + 1;
	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm3);

	if i1 > 75
	then go to comp_error;

	intrp_stack (i1) = current_line;
	current_line = syntax_line.t_field;

	go to new_inst;

ret:
action (0):
	if DIAG_NUM ^= 0
	then call diag (DIAG_NUM);

	if syntax_line.s_bit = "s"
	then call SCAN;

	current_line = syntax_line.s_exit;

	go to new_inst;

action (1):					/* exit true */
	current_line = intrp_stack (i1);

	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm4);

	syntax_line_ptr = addr (syntax_table (current_line));
	i1 = i1 - 1;

	go to ucon;

action (2):					/* exit false */
	current_line = intrp_stack (i1);

	if tbit
	then call cobol_syntax_trace_$trace (trace_ptr, tm5);

	i1 = i1 - 1;

	go to next_inst;

comp_error:
	diag_item.number = 183;
	diag_item.column = header.column;
	diag_item.line = header.line;

	call cobol_c_list (dg_ptr);

	return;

st_init:
     proc;

	bad_token = "0"b;
	inhibit_db = "0"b;
	statement.cd.size, statement.file.size, statement.proc.size, statement.data.size = 0;


     end;

emit_nl:
     proc;

	N_L = "0"b;
	call emit;
	N_L = "1"b;

     end;

EMIT:
     proc;

declare	i		fixed bin,
	AR		ptr;

	if TOK_TAB.size ^= 0
	then do i = 1 by 1 to TOK_TAB.size;

		AR = TOK_TAB.ptr (i);
		last_line = header.line;
		last_col = header.column;

		RP = AR;
		call PUT_REC;

	     end;

     end;

PUT_REC:
     proc;

/* make entry in output stream	*/
/* enter copy stack if required	*/
	if copy_mode
	then do;
		copy_tab.size = copy_tab.size + 1;

		call cobol_db_put (cobol_x3fp, st, RP, RP -> header.size, RP1);

		copy_tab.ptr (copy_tab.size) = addrel (RP1, 1);
	     end;
	else call cobol_db_put (cobol_x3fp, st, RP, RP -> header.size, RP1);
     end;

emit_copy:
     proc (loc);

declare	loc		fixed bin;
declare	p		ptr,
	i		fixed bin;

/* process entry in copy stack */

	if loc > copy_tab.size
	then return;

	do i = loc by 1 to copy_tab.size;

	     p = copy_tab.ptr (i);

	     call cobol_db_put (cobol_x3fp, st, p, p -> header.size, RP1);

	     p = addrel (RP1, 1);

	     p -> header.line = 0;
	     p -> header.column = 0;

	end;

	copy_tab.size = loc - 1;

     end;

SCAN:
     proc;

	do while ("1"b);

	     TOK_TAB.size = TOK_TAB.size + 1;

	     call cobol_swf_get (cobol_rmin2fp, st, addr_record, tln);

	     if substr (st, 17, 16) ^= "0"b
	     then return;

	     TOK_TAB.ptr (TOK_TAB.size) = addr_record;

	     if header.type ^= 5 & header.type ^= 6
	     then return;

	     bad_token = "1"b;

	end;

     end;

diag:
     proc (diag_num);

declare	diag_num		fixed bin;

	diag_item.number = diag_num;
	diag_item.column = header.column;
	diag_item.line = header.line;
	call cobol_c_list (dg_ptr);
     end diag;

lev_diag:
     proc (diag_num);

declare	diag_num		fixed bin;

	lev_diag_item.line = header.line;
	lev_diag_item.column = header.column;
	lev_diag_item.number = diag_num;
	lev_diag_item.module = mod_num;

	call cobol_c_list (lev_dg_ptr);

	mod_num = 0;

     end;

/* is item an 01 or 77 item in linkage section */



check (2):
lident:
	if (header.type = 9) & ((data_name.level = 01) | (data_name.level = 77)) & data_name.linkage_section
	then go to success;
	go to fail;				/* is it a section header */
check (4):
sechdr:
	if (header.type = 7) & (proc_def.section_name = "1"b)
	then go to success;
	go to fail;				/* is it a non sort file name */



check (5):
filenm:
	if header.type = 12
	then go to success;
	else go to fail;

check (6):
res_test:
	if db_res = 1
	then inhibit_db = "0"b;
	else inhibit_db = "1"b;

	current_line = current_line + res;
	go to new_inst;				/* is it a report section  group item */
check (7):
rident:
	if header.type = 21
	then go to success;
	go to fail;				/* is it a procedure definition */
check (8):
paranm:
prdef:
	if (header.type = 7 & proc_def.section_name = "0"b)
	then go to success;
	go to fail;				/* is it a verb */



check (9):
verb:
	if ((header.type = 1) & (reserved_word.verb = "1"b))
	then go to success;
	go to fail;				/* is section number legitimate */


check (10):
prnum:
	if header.type = 2 & numeric_lit.integral = "1"b & numeric_lit.sign = " " & numeric_lit.seg_range = "1"b
	then go to success;
	go to fail;

check (11):
not_opt:
	if ST.parity (nest_lev) = 1
	then go to success;
	else go to fail;


check (12):
numlit:
	if header.type = 2
	then go to success;
	go to fail;				/* is it a procedure name reference */


check (14):
prnm:
	if header.type = 18
	then go to success;
	go to fail;				/* is it a non numeric literal */
check (15):
nonumlit:
	if header.type = 3
	then go to success;
	go to fail;				/* is it an 01 or 77 item within file working-storage communication or link section */


check (16):
useid:
	if header.type = 2 | header.type = 3
	then go to success;

	if header.type = 9
	then do;
		if ((data_name.level = 1 | data_name.level = 77)
		     & (data_name.file_section | data_name.working_storage | data_name.communication_section
		     | data_name.linkage_section | data_name.constant_section))
		then go to success;
	     end;

	go to fail;

/* is it a non sort file name */


check (17):
nsfilnm:
	if header.type = 12
	then go to success;
	else go to fail;				/* is it an input cd name */

/*[5.0-1]*/
dcl	cd_pres		bit (1);
check (18):
incdnm:
	if (addr_record -> cdtoken.type = 13 & addr_record -> cdtoken.options.input)
						/*[5.0-1]*/
	then do;
		cd_pres = "1"b;
		go to success;
	     end;					/*[5.0-1]*/
	else do;
		cd_pres = "0"b;
		go to fail;
	     end;					/* is it an output cd name */


check (19):
outcdnm:
	if (addr_record -> cdtoken.type = 13 & addr_record -> cdtoken.output)
	then go to success;
	go to fail;

/* is it a literal */



check (21):
lit:
	if header.type = 2 | header.type = 3
	then go to success;
	go to fail;				/* is item a figurative constant except all */
check (22):
figconall:
	if header.type = 1 & reserved_word.figcon
	then go to success;

	go to fail;

check (25):
rpid:						/*	if report_name.type = 20 | (group_name.type = 21 & group_name.group_type = 4) then go to success;
go to fail;	*/
						/* is it a declarative section name reference */
check (26):
descnm:
	if header.type = 18 & proc_def.section_name & proc_def.declarative_proc
	then go to success;
	go to fail;				/* is it an rd report name */
check (27):
repnm:
	if header.type = 20
	then go to success;
	go to fail;				/*is file not sequentila access
	not file table already in core from check 38 */

check (29):
notseqac:
	if access > 1
	then go to success;
	go to fail;

/* is it a non sort mass storage file */
check (31):
msfilnm:						/*  according to ron ham we do not check for ms file regardless of codasyl rules */
	if header.type = 12
	then go to success;
	go to fail;

/* is it an index name */
check (33):
xnm:
	if header.type = 10
	then do;
		min_index = max (min_index, index_name.min);
		max_index = min (max_index, index_name.max);
		go to success;
	     end;
	go to fail;

/* is item a declarative section name reference */
/* and is it a random processing section */



check (35):
descnmra:
	if header.type = 18 & proc_def.section_name
	then go to success;
	go to fail;				/* is it an sa area name */
check (36):
saanm:
	if header.type = 15
	then go to success;
	go to fail;				/* is it an  01 data name under sa */
check (37):
said:
	if header.type = 9 & data_name.level_01 & data_name.exp_redefining
	then go to success;
	go to fail;

/* is it end cobol statement */
check (39):
endcob:
	if header.type = 1 & reserved_word.end_cobol = "1"b
	then go to success;
	go to fail;				/* is verb an imperative verb */
check (41):
impvrb:
	if header.type = 1 & reserved_word.imper_verb = "1"b
	then go to success;
	go to fail;

/* is this item a record within the associated sort file */
check (46):
recnm:
	if header.type ^= 9
	then go to fail;

	go to success;

/* is this file the same as associated file in the sort statement */
check (49):
asfil:
	if header.type ^= 16
	then go to fail;


	go to success;

/* is item not subscripted and not indexed */
/* but still has the occurs and indexed by clauses */
check (50):
srchid:
	if header.type = 9 & data_name.subscripted & data_name.indexed_by
	then go to success;
	else go to fail;				/* is item an integer type or is it usage is index */
check (51):
usornm:
	if header.type = 9 & (data_name.pic_integer | data_name.usage_index)
	then go to success;
	else go to fail;				/* does item have the key is clause */
check (52):
keylbl:
	if data_name.key_a | data_name.key_d
	then go to success;
	else go to fail;

/* is it a one character integer without an operational sign */



check (54):
onechnosn:
	if data_name.item_length = 1 & data_name.pic_integer & ^data_name.item_signed
	then go to success;
	go to fail;

/* is it a mnemonic name */
check (56):
mnenm:
	if header.type = 17
	then go to success;
	go to fail;

/* does the file have an associated format 1 use procedure */

/* is it  an index data item or
			is it  an elementary integer item */
check (58):
xint:
	if header.type = 9 & data_name.elementary & data_name.usage_index = "1"b
	then go to success;

	if header.type = 9 & data_name.elementary = "1"b & data_name.pic_integer = "1"b
	then go to success;
	go to fail;				/* is it a positive integer literal  */



check (59):
posint:
	if header.type = 2 & numeric_lit.integral = "1"b & numeric_lit.sign ^= "-"
	then go to success;
	go to fail;				/* is it a sortt file */



check (60):
srtfil:
	if header.type = 16
	then go to success;
	go to fail;				/* is itt a data_name within the saved file */


check (61):
dninfl:
	if header.type = 9
	then go to success;
	go to fail;				/* does item have usage is display clause */

check (62):
usisds:
	if data_name.non_elementary | (data_name.elementary & data_name.display)
	then go to success;
	go to fail;				/* is item fixed length with usage is display clause */
check (63):
flusisds:
	if data_name.display & ^data_name.variable_length
	then go to success;
	go to fail;				/* is item an elementary data item with usage is display clause
			and with no edit symbols */
check (64):
elneds:
	if data_name.elementary & data_name.display & ^data_name.numeric_edited & ^data_name.alphanum_edited
	     & ^data_name.alphabetic_edited
	then go to success;
	go to fail;				/* is itt an elementary numeric integer data item */
check (65):
elnuindi:
	if data_name.elementary & data_name.numeric & data_name.pic_integer
	then go to success;
	go to fail;				/* is it an elementary numeric item */



check (66):
elnuit:
	if header.type = 9 & data_name.elementary & data_name.numeric
	then go to success;
	go to fail;				/* is it a file name */



check (67):
file:
	if header.type = 12 | header.type = 16
	then go to success;
	go to fail;				/* is it an alphanumeric data item */
check (68):
andait:
	if data_name.alphanum | data_name.alphanum_edited
	then go to success;
	go to fail;				/* is item a non_sort record name */



check (70):
nsrecnm:
	if header.type = 9
	then go to success;
	else go to fail;				/* does saved item have linage clause */
						/* not to be executed until common is all set */
check (71):
linage:
	if file_table.linage
	then go to success;

	go to fail;

check (72):
in_line:
	if IN_LINE = 0
	then go to success;
	else go to fail;

/* is item an unsubscripted data name excluding index data names */



check (73):
undana:
	if header.type = 9 & ^data_name.subscripted & ^data_name.usage_index
	then go to success;
	go to fail;

/* is item a subscripted data name excluding  index data names */

check (74):
sudana:
	if header.type = 9 & data_name.subscripted & ^data_name.usage_index
	then go to success;
	go to fail;

/* is subcnt less than level of occurs in the saved ident */
check (75):
ieqlvl:
	if subcnt <= 3
	then go to success;
	go to fail;				/* is the saved ident indexed at this level */
check (76):
indexed:
	if indexedno (subcnt) ^= 0
	then do;
		sub_loc = sub_loc + 1;
		go to success;
	     end;
	go to fail;				/* is index no of curent item = to
			index no of saved item */
check (77):
indeqind:
	if index_name.index_no = indexedno (subcnt)
	then go to success;
	go to fail;				/* is item a positive integer whose value is greater than zero */
check (78):
pigz:
	call pigz_sub;

	if pigz_res = 0
	then go to success;
	else go to fail;

pigz_sub:
     proc;

	pigz_res = 0;
	litcnt = 1;

	if header.type = 2 & numeric_lit.integral & numeric_lit.sign ^= "-"
	then do while ("1"b);

		if substr (numeric_lit.literal, litcnt, 1) ^= "0"
		then return;

		if litcnt = numeric_lit.places
		then do;
			pigz_res = 1;
			return;
		     end;

		litcnt = litcnt + 1;

	     end;

	pigz_res = 1;

     end;

/* is item an unsigned integer */
check (79):
unsint:
	if header.type = 2 & numeric_lit.integral & numeric_lit.sign = " "
	then go to success;
	go to fail;				/* is item an arithemetic operator */
check (80):
arop:
	if header.type = 1 & reserved_word.arith_op
	then go to success;
	go to fail;

check (81):
examlitid:
	if header.type = 9 | header.type = 1 | header.type = 3
	then go to success;
	else go to fail;				/* is item a single character non numeric literal or a fig con */
						/* is item elementary or redefined */

check (82):
elemred:
	if data_name.elementary | data_name.s_of_rdf | data_name.o_of_rdf
	then go to success;
	go to fail;


/* does program contain sections */
check (84):
secsw:
	if secswitch = 1
	then go to success;
	go to fail;				/* does imperative switch = 0 */



check (85):
impsw:
	if impswitch = 0
	then go to success;
	go to fail;				/* is it a cdname */
check (87):
cdname:
	if header.type = 13
	then go to success;
	go to fail;				/* is it a data name not in report section */
check (88):
dana:
	if header.type = 9 & data_name.report_section = "0"b
	then go to success;
	go to fail;


check (90):
deswon:
	if decswitch > 1 & decswitch < 5
	then go to success;
	go to fail;


/* is it an unsubscripted elementary data name */

check (92):
unelnudn:
	if header.type = 9 & data_name.subscripted = "0"b & data_name.elementary = "1"b & ^data_name.constant_section
	     & data_name.numeric = "1"b
	then go to success;
	go to fail;				/* is it a statement termiator */
check (93):
sterm:
	if header.type = 1 & reserved_word.terminator = "1"b
	then go to success;

	if header.type = 7
	then go to success;
	go to fail;				/* is it a group item or does it have usage is display */



check (94):
usagid:
	if header.type = 9 & (data_name.non_elementary | data_name.display)
	then go to success;
	go to fail;

/*  is item an elementary item with usage is display clause */
check (95):
eldis:
	if header.type = 9 & data_name.display & data_name.elementary
	then go to success;
	go to fail;				/* is it end declaratives */


check (115):
enddec:
	if header.type = 1 & reserved_word.key = 98 & reserved_word.end_dec = "1"b
	then do;
		decswitch = 5;
		go to success;
	     end;
	go to fail;				/* is item alterable */

check (116):
edalit:
	if header.type = 9 & data_name.constant_section = "0"b
	then go to success;
	go to fail;				/* is it an alterable elementary numeric item */
check (117):
alelnuitm:
	if header.type = 9 & data_name.constant_section = "0"b & data_name.elementary = "1"b & data_name.numeric = "1"b
	then go to success;
	go to fail;				/* is it an integer */
check (118):
elnuint:
	if header.type = 2 & numeric_lit.integral
	then go to success;
	go to fail;				/*  is it an elementary numeric data name and an integer */
check (119):
elnudnint:
	if header.type = 9 & data_name.elementary & data_name.pic_integer
	then go to success;
	go to fail;				/* is it an edited or non edited alterable
			elementary numeric item */
check (120):
edalelnue:
	if header.type = 9 & ^data_name.constant_section & data_name.elementary
	     & (data_name.numeric | data_name.numeric_edited)
	then go to success;
	go to fail;				/* is item alphabetic or alphanumeric */
check (122):
alphoral:
	if data_name.alphanum | data_name.alphabetic
	then go to success;
	go to fail;				/* is item an arithmetic operator or right paren */
check (123):
aroprp:
	if header.type = 1 & reserved_word.arith_op
	then go to success;

	if header.type = 1 & reserved_word.key = 188
	then go to success;
	go to fail;				/* is item a relation operator */

check (124):
relop:
	if header.type = 1 & reserved_word.rel_op
	then go to success;

	go to fail;				/* is token res word positive or negative or zero */
check (125):
pnz:
	if header.type = 1
	then if reserved_word.key = 141 | reserved_word.key = 127 | reserved_word.key = 180
	     then go to success;
	go to fail;				/* is subject not = 0 --- do we have a subject present */
check (126):
is_sub_opt:
	if subj_req
	then go to fail;
	else go to success;


/* is item a status switch condition name */
check (134):
sscondnm:
	if mnemonic_name.type = 17 & mnemonic_name.class.switch_condition
	then go to success;

	go to fail;


check (137):
lptopstk:
	if cssub >= 0
	then go to success;
	else go to fail;

/* is item an unsubscripted index data name */

check (138):
unxdnm:
	if header.type = 9 & ^data_name.subscripted & data_name.usage_index
	then go to success;
	go to fail;

check (141):
nestedif:
	if nestifcnt = 0
	then go to success;
	else go to fail;

/* is item alphanumeric */

check (147):
nonumdn:
	if header.type = 9 & data_name.alphanum
	then go to success;
	go to fail;

/* is item elementary alphabetic,alphanumeric or numeric edited or a group item */



check (149):
elaanne:
	if header.type = 9
	     & ((data_name.elementary & (data_name.numeric_edited | data_name.alphanum | data_name.alphabetic))
	     | data_name.non_elementary)
	then go to success;
	go to fail;

/* is item a subscribted idndex data name */



check (150):
suxdnm:
	if header.type = 9 & data_name.subscripted & data_name.usage_index
	then go to success;
	go to fail;

/* is this MNEMONIC NAME an input device */

check (153):
indev:
	if mnemonic_name.iw_key = 3 | mnemonic_name.iw_key = 1
	then go to success;
	go to fail;

/* is MNEMONIC NAME input device */

check (154):
outdev:
	if mnemonic_name.iw_key = 3 | mnemonic_name.iw_key = 2
	then go to success;
	go to fail;

check (158):
adrisadr:
	if header.type = 9
	then go to success;
	else go to fail;

/* is ADDRESS same as FILE KEY in COMMON */
/* FILE TABLE already in core */
/* processing START verb */

check (159):
ssnm:
	if mnemonic_name.type = 17 & mnemonic_name.class.switch_name
	then go to success;

	go to fail;

check (160):					/* enter, routine name */
is_rout:
	if lang_num = 1
	then go to fail;

	if header.type = 8
	then go to success;

	go to fail;

check (161):
edick:
	if data_name.alphanum | data_name.alphabetic
	     | (data_name.numeric & data_name.places_left ^< 0 & data_name.places_right ^< 0)
	then go to success;
	go to fail;

check (162):
cktp25:
	if header.type = 25
	then go to success;
	go to fail;

check (166):
cklit:
	if header.type = 3 & alphanum_lit.lit_size < 31
	then go to success;
	go to fail;

/* check for a nonzero numeric literal */
check (169):
nznumlit:
	if header.type = 2
	then do;
		litcnt = 1;

		do while ("1"b);

		     if substr (numeric_lit.literal, litcnt, 1) ^= "0"
		     then go to success;

		     if litcnt = numeric_lit.places
		     then go to fail;

		     litcnt = litcnt + 1;

		end;
	     end;

	go to fail;

/* check integer bit in saved identifier */
check (170):
ckintbit:
	if numeric_lit.integral
	then go to success;
	go to fail;

/* is an lit < 32 chars for CALL */

check (180):
cklit1:
	if alphanum_lit.lit_size < 32
	then go to success;
	go to fail;

/* are we executing multics cobol compiler */

check (181):
mcobol:
	if compiler_id = 3
	then go to success;
	go to fail;

/* is an lit < 66 chars for CALL */

check (182):
cklit2:
	if alphanum_lit.lit_size < 66
	then go to success;
	go to fail;

/* is item unsubscripted data name excluding index data names, and,
		is it elementary, numeric ,integer data item. */
check (186):
udneli:
	if header.type = 9 & ^data_name.subscripted & ^data_name.usage_index & data_name.elementary
	     & data_name.numeric & data_name.pic_integer
	then do;
		sub_loc = sub_loc + 1;
		go to success;
	     end;
	go to fail;

check (188):
altst:
	if header.type = 9 & data_name.elementary
	then go to success;
	else go to fail;

check (189):
edaltst:
	if header.type = 9 & data_name.elementary & (data_name.numeric | data_name.numeric_edited)
	then go to success;
	else go to fail;

check (193):
resword:
	if reserved_word.type = 1
	then go to success;
	else go to fail;

check (194):
type9:
	if header.type = 9
	then go to success;
	else go to fail;

check (195):
alphnm:						/* check for alphabet name token */
	if alphabet_name.type ^= 40
	then go to fail;

	go to success;

check (196):
on_off:						/* test for ON or OFF */
	if reserved_word.type ^= 1
	then go to fail;

	key = reserved_word.key;

	if key ^= 134 & key ^= 574
	then go to fail;

	go to success;

acc_dev:
check (197):					/* test for accept device */
	if mnemonic_name.type = 17 & mnemonic_name.class.accept_device
	then go to success;

	go to fail;

disp_dev:
check (198):					/* test for display device */
	if mnemonic_name.type = 17 & mnemonic_name.class.display_device
	then go to success;

	go to fail;

prt_con:
check (199):					/* test for printer control */
	if mnemonic_name.type = 17 & mnemonic_name.class.printer_control
	then go to success;

	go to fail;

check (200):					/* enter, language name */
is_lang:
	lang_num = cobol_imp_word$lang_name (addr_record);

	if lang_num = 0
	then go to fail;

	go to success;

check (201):
amarg:
	if header.column < 12
	then go to success;
	go to fail;

check (202):
set_xint:
	if header.type = 9 & data_name.elementary
	then go to success;

	go to fail;

check (203):
set_pigz:
	call pigz_sub;

	if pigz_res = 0
	then go to success;

	go to fail;

check (206):
is_user_word:
	if data_name.type = 9
	then go to success;

	go to fail;

check (208):
nlit:
	if header.type = 2
	then go to success;

	go to fail;

check (209):
pigz_by:
	litcnt = 1;

	if header.type = 2 & numeric_lit.integral
	then do while ("1"b);

		if substr (numeric_lit.literal, litcnt, 1) ^= "0"
		then go to success;

		if litcnt = numeric_lit.places
		then go to fail;

		litcnt = litcnt + 1;

	     end;

	go to fail;

/***********************************************:*****************************/
/*****		PLACE NEW CHECKS BEFORE THIS COMMENT		********/
/*****************************************************************************/



action (12):
	call set_st_type (103);
	statement.line = proc_def.line;		/* section header */

	call enter_st_table;

	pn_count = pn_count + 1;
	go to ret;

action (13):
	if reserved_word.key = 2
	then end_word = 1;				/* add */
	else if reserved_word.key = 11
	then end_word = 17;				/* subtract */
	else if reserved_word.key = 40
	then end_word = 3;				/* compute */
	else if reserved_word.key = 10
	then end_word = 8;				/* multiply */
	else if reserved_word.key = 9
	then end_word = 5;				/* divide */

NL:
	nest_lev = nest_lev + 1;
	ST.end_word (nest_lev) = end_word;
	ST.parity (nest_lev) = 0;
	not_emitted = "0"b;

	go to ret;



action (14):
	call set_st_type (104);
	statement.line = proc_def.line;		/* paragraph header */

	call enter_st_table;

	pn_count = pn_count + 1;
	go to ret;

action (15):
	nestifcnt = nestifcnt + 1;
	call set_until_ptr;
	go to action (28);

action (16):
	call set_st_type (reserved_word.key);

	current_line = reserved_word.key;
	statement.line = reserved_word.line;
	go to new_inst;

action (17):
	decswitch = 3;
	section_ptr -> proc_def.type = 18;
	go to ret;

action (18):
	call set_st_type (106);			/* . */
	go to ret;

action (19):
	call set_st_type (107);			/* P.goto. */
	go to ret;

action (20):
	statement.type = 108;			/* go to depending */
	go to ret;

action (21):
	call set_st_type (109);			/* P.exit. */
	go to ret;

action (22):
	call set_st_type (110);			/* stop statement */
	go to ret;

action (23):
	call set_st_type (111);			/* end declaratives*/
	decswitch = 5;
	pn_count = 0;
	go to ret;

action (24):
	call set_st_type (112);			/* end cobol */
	go to ret;

action (25):
	call scan_to_end;				/* type 25 token */
	go to ret;

action (26):
	call set_st_type (114);			/* use statement */
	db_res = 1;
	go to ret;

action (27):
	call set_st_type (115);			/* on size error */
	go to ret;

action (28):
	if reserved_word.key = 47
	then end_word = 7;				/*if */
	else if reserved_word.key = 5
	then end_word = 2;				/* call */
	else if reserved_word.key = 34
	then end_word = 16;				/* string */
	else if reserved_word.key = 37
	then end_word = 18;				/* unstring */
	else if reserved_word.key = 25
	then end_word = 12;				/* return */

	go to NL;


action (29):
	from_pres = "0"b;

	if reserved_word.key = 21
	then end_word = 10;				/* read */
	else if reserved_word.key = 38
	then end_word = 19;				/* write */
	else if reserved_word.key = 27
	then end_word = 13;				/* rewrite */
	else if reserved_word.key = 56
	then end_word = 15;				/* start */
	else if reserved_word.key = 22
	then end_word = 4;				/* delete */

	go to NL;



action (30):
	call set_st_type (116);			/* next statement */
	go to ret;

action (31):
	if reserved_word.key = 20			/* perform */
	then do;
		per_desc.pn1, per_desc.pn2 = 0;
		end_word = 9;
	     end;
	else if reserved_word.key = 26		/* search */
	then do;
		end_word = 14;
		call set_until_ptr;
	     end;
	else if reserved_word.key = 23
	then end_word = 11;				/* receive */
	else if reserved_word.key = 500
	then end_word = 6;				/* evaluate */

	go to NL;


action (32):
	call set_st_type (117);			/* else */
	go to ret;

action (33):
	alphanum_lit.all_lit = "1"b;
	go to ret;

action (34):
	call set_st_type (100);
	decswitch = 1;				/* procedure division */
	go to ret;

action (35):
	item_tab.ptr (1) = TOK_TAB.ptr (1);
	TOK_TAB.size = 0;
	res, i = 2;

	do while (res = 2);

	     call cobol_swf_get (cobol_rmin2fp, st, item_tab.ptr (i), tln);

	     addr_record = item_tab.ptr (i);

	     if alphanum_lit.type = 3 & alphanum_lit.string = "~~~"
	     then res = 0;
	     else i = i + 1;

	end;

	item_tab.size = i;

	call define_macros;
	go to ret;

action (36):
	nest_lev = 0;
	go to ret;

action (37):
	call set_st_type (118);			/* invalid key */
	impswitch = 0;
	go to ret;

action (38):
	call set_st_type (119);			/* at end */
	go to ret;

action (39):
	impswitch = 1;
	go to ret;

action (40):
	impswitch = 0;
	go to ret;

action (41):
	nestifcnt = 0;
	nest_lev = 0;
	impswitch = 0;
	go to ret;

action (42):
	impswitch = 0;
	go to ret;

action (43):
	nest_lev = 0;
	go to ret;

action (44):
	call set_st_type (120);			/* at eop */
	go to ret;

action (45):
	subcnt = 0;
	go to ret;

action (46):
	subcnt = subcnt + 1;
	if QQ = null ()
	then go to ret;
	statement_data_entry.dimen = statement_data_entry.dimen + 1;
	go to a46 (subcnt);

a46 (1):
	statement_data_entry.sub_1.TOK = TOK_TAB.size;
	statement_data_entry.sub_1.TOK_size = 1;
	go to ret;

a46 (2):
	statement_data_entry.sub_2.TOK = TOK_TAB.size;
	statement_data_entry.sub_2.TOK_size = 1;
	go to ret;

a46 (3):
	statement_data_entry.sub_3.TOK = TOK_TAB.size;
	statement_data_entry.sub_3.TOK_size = 1;
	go to ret;

action (47):
	impswitch = 0;
	cssub = 0;
	go to ret;

action (48):
	nestifcnt = nestifcnt - 1;
	go to ret;

action (49):
	nestifcnt = nestifcnt - 1;
	go to ret;

action (50):
	nestifcnt = nestifcnt - 1;
	call set_st_type (117);
	go to ret;

action (51):					/* cd-name,data-name,file-name,proc-name */
	ALL_REFS = "0"b;
	call enter_db_table;
	go to ret;

action (52):					/* all refs, data-name */
	ALL_REFS = "1"b;
	call enter_db_table;
	go to ret;

action (53):					/* all procs */
	if debug_table.proc.size ^= 0
	then call diag (6);
	else if all_procs
	then call diag (7);
	else do;
		all_procs, DB = "1"b;
		debug_table.proc.size = 1;
		debug_table.proc.entry.proc_ptr (1) = section_ptr;
	     end;
	go to ret;

action (54):
	ALL_REFS = "0"b;
	go to ret;

action (55):
	decswitch = 4;
	go to ret;

action (56):
	call set_st_type (0);			/*	call ioa_("^d ^d",header.line,header.column); dcl ioa_ entry options(variable);*/
	go to ret;

action (57):
	if EN ^= 0
	then statement.data.entry.TOK (EN) = -statement.data.entry.TOK (EN);
	go to ret;

action (58):					/* go to PN */
	call set_st_type (14);
	go to ret;

action (59):					/* ident, sending field */
	send_bit = "1"b;
	BEG_ID = TOK_TAB.size;
	if QQ ^= null ()
	then statement_data_entry.TOK_size = 1;

	call enter_st_table;
	go to ret;

action (60):					/* ident, receiving field */
	send_bit = "0"b;
	BEG_ID = TOK_TAB.size;
	if QQ ^= null ()
	then statement_data_entry.TOK_size = 1;

	call enter_st_table;
	go to ret;

action (61):
	statement.line = reserved_word.line;
	go to ret;

action (62):
	section_ptr = addr_record;
	go to ret;

action (63):
	cssub = cssub + 1;
	subj_req = "1"b;
	go to ret;

action (64):
	per_desc.format = 1;
	cssub = cssub - 1;
	go to ret;

action (65):
	subcnt = subcnt + 1;
	if QQ = null ()
	then go to ret;
	statement_data_entry.dimen = statement_data_entry.dimen + 1;
	go to a65 (subcnt);

a65 (1):
	statement_data_entry.sub_1.TOK_size = 3;
	go to ret;

a65 (2):
	statement_data_entry.sub_2.TOK_size = 3;
	go to ret;

a65 (3):
	statement_data_entry.sub_3.TOK_size = 3;
	go to ret;
action (66):
	IN_LINE = 1;
	dim = 0;
	per_desc.pn1 = 0;
	go to ret;

action (67):
	IN_LINE = 0;
	dim = 0;
	per_desc.pn1 = TOK_TAB.size;

	call enter_st_table;
	go to ret;

action (68):
	per_desc.format = 1;
	go to ret;

action (69):
	per_desc.format = 2;
	per_desc.count.tok_no = TOK_TAB.size;
	go to ret;

action (70):
	per_desc.format = 3;
	per_desc.until.tok_no = TOK_TAB.size + 1;
	call set_until_ptr;
	go to ret;

action (71):
	per_desc.format = 4;
	per_desc.dim = 1;
	call set_per_cond_ptr;
	go to ret;

action (72):
	subj_req = "0"b;
	go to ret;

action (73):
	subj_req = "1"b;
	cssub = cssub - 1;
	go to ret;
action (74):					/*[5.3-1]*/
	nest_lev = nest_lev - 1;
	go to ret;
action (82):
	cssub = 0;
	subj_req = "1"b;
	go to ret;
action (83):
	per_desc.loop.cond.size (per_desc.dim) = TOK_TAB.size - per_desc.loop.cond.tok_no (per_desc.dim);
	go to ret;

action (84):
	per_desc.pn2 = TOK_TAB.size;
	go to ret;

action (85):
	per_desc.until.size = TOK_TAB.size - per_desc.until.tok_no + 1;
	go to ret;

action (86):
eos:
	if bad_token | inhibit_db | decswitch < 3
	then call emit_nl;
	else do;
		call db_emit;

		if e_res = 1
		then if stne
		     then call emit_db_code;
	     end;

	call st_init;
	go to ret;

action (87):
endjob:
	return;

action (88):
	db_res = 2;
	go to ret;

action (89):
	per_desc.dim = per_desc.dim + 1;
	call set_per_cond_ptr;
	go to ret;

action (90):
	per_desc.loop.var.tok_no (per_desc.dim) = TOK_TAB.size;
	per_desc.loop.var.size (per_desc.dim) = 1;
	go to ret;

action (91):
	per_desc.loop.from.tok_no (per_desc.dim) = TOK_TAB.size;
	per_desc.loop.from.size (per_desc.dim) = 1;
	go to ret;

action (92):
	per_desc.loop.by.tok_no (per_desc.dim) = TOK_TAB.size;
	per_desc.loop.by.size (per_desc.dim) = 1;
	go to ret;

action (93):
	per_desc.loop.cond.tok_no (per_desc.dim) = TOK_TAB.size + 1;
	go to ret;

action (94):					/* send-receive status */
	TOK_NUM = -TOK_NUM;
	go to ret;

action (95):					/* dispatch on end word */
	end_word = ST.end_word (nest_lev);

	if end_word < 0
	then end_word = -end_word;

	if end_word = 0 | end_word > 19
	then end_word = 1;
	else end_word = end_word + 1;

	current_line = current_line + end_word;
	go to new_inst;

action (96):
	ST.parity (nest_lev) = 0;
	call emit_not_option (1);			/* on size error */
	go to ret;

action (97):
	ST.parity (nest_lev) = 1;
	call emit;				/* set to NOT */
	call st_init;
	go to ret;

action (98):
	ST.parity (nest_lev) = 0;
	call emit_not_option (5);			/* on overflow */
	go to ret;

action (99):
	ST.parity (nest_lev) = 0;
	call emit_not_option (2);			/* at end */
	go to ret;

action (100):
	ST.parity (nest_lev) = 0;
	call emit_not_option (3);			/* invalid key */
	go to ret;

action (101):					/*[4.4-3]*/
	opt_word_num = 44;				/* with */
	ST.parity (nest_lev) = 0;
	call emit_not_option (8);			/* no data */
	go to ret;
action (102):
	ST.parity (nest_lev) = 0;
	call emit_not_option (4);			/* at eop */
	go to ret;
action (103):
	if not_emitted
	then call reset_TOK_TAB;
	else do;
		call emit_nl;
		call st_init;
	     end;
	go to ret;
action (104):
	call emit;
	call st_init;
	go to ret;

action (105):
	if not_emitted
	then call PUT (item_tab.ptr (47 + ST.end_word (nest_lev)));
	go to ret;

action (106):
	call set_st_type (101);
	decswitch = 2;
	go to ret;

action (107):
	decswitch = 5;
	pn_count = 0;
	go to ret;

action (108):
	if all_procs
	then res = 1;
	else call enter_st_table;

	if res = 1
	then do;
		alt_ct = alt_ct + 1;
		alt_tab.pn1 (alt_ct) = TOK_TAB.size;
	     end;
	go to ret;

action (109):
	sm_desc.ip_TOK, sm_desc.op_TOK = 0;		/* initialize for sort-merge */
	go to ret;

action (110):
	sm_desc.op_TOK = TOK_TAB.size;		/* pn for output procedure */
	go to action (60);

action (111):
	sm_desc.ip_TOK = TOK_TAB.size;		/* pn for input procedure */
	go to action (60);

action (112):
	alt_ct = 0;
	go to ret;

action (113):
	alt_tab.pn2 (alt_ct) = TOK_TAB.size;
	go to ret;

action (114):
	if QQ ^= null ()
	then statement_data_entry.TOK_size = TOK_TAB.size - BEG_ID + 1;
	go to ret;
action (115):
	send_bit = "0"b;
	call enter_st_table;			/* call type12_token; */
						/* form type 12 token, enter_st_table */
	go to ret;

action (116):
	from_pres = "1"b;
	FR.TOK = TOK_TAB.size + 1;
	go to ret;

action (117):
	FR.TOK_size = TOK_TAB.size - FR.TOK + 1;
	go to ret;

action (118):
	per_desc.loop.var.size (per_desc.dim) = TOK_TAB.size - per_desc.loop.var.tok_no (per_desc.dim) + 1;
	go to ret;

action (119):
	per_desc.loop.from.size (per_desc.dim) = TOK_TAB.size - per_desc.loop.from.tok_no (per_desc.dim) + 1;
	go to ret;

action (120):
	per_desc.loop.by.size (per_desc.dim) = TOK_TAB.size - per_desc.loop.by.tok_no (per_desc.dim) + 1;
	go to ret;

action (121):
	per_desc.count.size = TOK_TAB.size - per_desc.count.tok_no + 1;
	go to ret;

action (122):
	call enter_st_table;
	go to ret;

action (123):
	if ST_NO = 0
	then go to ret;

	if new_entry | cond_desc.tok_count = 0
	then ;
	else do i = 1 by 1 to cond_desc.tok_count;

		if cond_desc.tok (i) = ST_NO
		then go to ret;

	     end;

	cond_desc.tok_count = cond_desc.tok_count + 1;
	cond_desc.tok (cond_desc.tok_count) = ST_NO;
	go to ret;

action (124):
	ST_NO = 0;
	go to ret;

define_macros:
     proc;

	M1.size = 4;
	M1.type (1) = 1;				/* MOVE */
	M1.ptr (1) = item_tab.ptr (9);
	M1.type (2) = 2;				/* AN_LIT(statement.line) */
	M1.ptr (2) = addr (statement.line);
	M1.type (3) = 1;				/* TO */
	M1.ptr (3) = item_tab.ptr (10);
	M1.type (4) = 1;				/* DEBUG-LINE */
	M1.ptr (4) = item_tab.ptr (1);

	M2.size = 4;
	M2.type (1) = 1;				/* MOVE */
	M2.ptr (1) = item_tab.ptr (9);
	M2.type (2) = 3;				/* NAME(token) */
	M2.ptr (2) = null ();
	M2.type (3) = 1;				/* TO */
	M2.ptr (3) = item_tab.ptr (10);
	M2.type (4) = 1;				/* DEBUG-NAME */
	M2.ptr (4) = item_tab.ptr (2);

	M3.size = 4;
	M3.type (1) = 1;				/* MOVE */
	M3.ptr (1) = item_tab.ptr (9);
	M3.type (2) = 1;				/* SPACES */
	M3.ptr (2) = item_tab.ptr (14);
	M3.type (3) = 1;				/* TO */
	M3.ptr (3) = item_tab.ptr (10);
	M3.type (4) = 1;				/* DEBUG-CONTENTS */
	M3.ptr (4) = item_tab.ptr (3);

	M4.size = 4;
	M4.type (1) = 1;				/* MOVE */
	M4.ptr (1) = item_tab.ptr (9);
	M4.type (2) = 1;				/* token */
	M4.ptr (2) = null ();
	M4.type (3) = 1;				/* TO */
	M4.ptr (3) = item_tab.ptr (10);
	M4.type (4) = 1;				/* DEBUG-CONTENTS */
	M4.ptr (4) = item_tab.ptr (3);

	M5.size = 10;
	M5.type (1) = 1;				/* IF */
	M5.ptr (1) = item_tab.ptr (68);

	do i = 0 by 1 to 5;				/* SWITCH-9 */

	     M5.type (2 + i) = 1;
	     M5.ptr (2 + i) = item_tab.ptr (69 + i);

	end;

	M5.type (8) = 1;				/* PERFORM */
	M5.ptr (8) = item_tab.ptr (15);
	M5.type (9) = 1;				/* PN */
	M5.ptr (9) = null ();
	M5.type (10) = 1;				/* END-IF */
	M5.ptr (10) = item_tab.ptr (34);

	M6.size = 4;
	M6.type (1) = 1;				/* MOVE */
	M6.ptr (1) = item_tab.ptr (9);
	M6.type (2) = 3;				/* NAME(token) */
	M6.ptr (2) = null ();
	M6.type (3) = 1;				/* TO */
	M6.ptr (3) = item_tab.ptr (10);
	M6.type (4) = 1;				/* DEBUG-CONTENTS */
	M6.ptr (4) = item_tab.ptr (3);

     end;

/*		item_tab.ptr

	1	type 9	DEBUG-LINE
	2	type 9	DEBUG-NAME
	3	type 9	DEBUG-CONTENTS
	4	type 9	DEBUG-SUB-1
	5	type 9	DEBUG-SUB-2
	6	type 9	DEBUG-SUB-3
	7	type 3	"(6)L"
	8	type 3	"(30)N"
	9	type 1	MOVE
	10	type 1	TO
	11	type 3	"~"
	12	type3	"~"
	13	type 1	=
	14	type 1	SPACE
	15	type 1	PERFORM
	16	type 3	"START PROGRAM"
	17	type 3	"SORT INPUT"
	18	type 3	"SORT OUTPUT"
	19	type 3	"MERGE OUTPUT"
	20	type 3	"PERFORM LOOP"
	21	type 3	"USE PROCEDURE"
	22	type 3	"FALL THROUGH"
	23	type 1	SET
	24	type 1	COMPUTE
	25	type 1	UP
	26	type 1	BY
	27	type 1	END-PERFORM
	28	type 1	TIMES
	29	type 1	UNTIL
	30	type 1	NOT
	31	type 1	)
	32	type 1	THRU
	33	type 1	ADD
	34	type1	END-IF
	35	type1	ON
	36	type1	SIZE
	37	type1	ERROR
	38	type1	AT
	39	type1	END
	40	type1	INVALID
	41	type1	KEY
	42	type1	EOP
	43	type1	OVERFLOW
	44	type1	WITH
	45	type1	DATA
	46	type1	EXCEPTION
	47	type1	NO
	48	type1	END-ADD
	49	type1	END-CALL
	50	type1	END-COMPUTE
	51	type1	END-DELETE
	52	type1	END-DIVIDE
	53	type1	END-EVALUATE
	54	type1	END-IF
	55	type1	END-MULTIPLY
	56	type1	END-PERFORM
	57	type1	END-READ
	58	type1	END-RECEIVE
	59	type1	END-RETURN
	60	type1	END-REWRITE
	61	type1	END-SEARCH
	62	type1	END-START
	63	type1	END-STRING
	64	type1	END-SUBTRACT
	65	type1	END-UNSTRING
	66	type1	END-WRITE
	67	type 1	(
	68	type 1	if
	69	type1	(	DEBUG-ON OF SWITCH-9
	70	type9	DEBUG-ON	|
	71	type1	NOT	|
	72	type1	EQUALS	|
	73	type3	LOW-VALUE	|
	74	type1	)	|
	75	type1	.
	76	type9	DEBUG-SUBS
	77	type3	"999999"
	128	type 3	"~~~"
*/
declare	1 M1,					/* MOVE AN-LIT(statement-line) TO DEBUG-LINE*/
	  2 size		fixed bin,
	  2 def		(4),
	    3 type	fixed bin,
	    3 num		fixed bin,
	    3 ptr		ptr;

declare	1 M2,					/* MOVE NAME(token) TO DEBUG-NAME */
	  2 size		fixed bin,
	  2 def		(4),
	    3 type	fixed bin,
	    3 num		fixed bin,
	    3 ptr		ptr;

declare	1 M3,					/* MOVE SPACES TO DEBUG-CONTENTS */
	  2 size		fixed bin,
	  2 def		(4),
	    3 type	fixed bin,
	    3 num		fixed bin,
	    3 ptr		ptr;

declare	1 M4,					/* MOVE token TO DEBUG-CONTENTS */
	  2 size		fixed bin,
	  2 def		(4),
	    3 type	fixed bin,
	    3 num		fixed bin,
	    3 ptr		ptr;

declare	1 M5,					/* IF DEBUG-ON PERFORM debug-section END-IF */
	  2 size		fixed bin,
	  2 def		(10),
	    3 type	fixed bin,
	    3 num		fixed bin,
	    3 ptr		ptr;

declare	1 M6,					/* MOVE NAME(token) TO DEBUG-CONTENTS */
	  2 size		fixed bin,
	  2 def		(4),
	    3 type	fixed bin,
	    3 num		fixed bin,
	    3 ptr		ptr;

set_st_type:
     proc (type);

declare	type		fixed bin;

	statement.type = type;
	stne = "0"b;

     end;

emit_proc_name:
     proc;					/* used by VERB(103): section header, VERB(104): para header */

/*	First Non-Declarative Procedure

		MOVE "START-PROGRAM TO DEBUG-CONTENTS.

			LL: PN section.
			LL: PN.

		MOVE "PN" TO DEBUG-NAME
		IF DEBUG-ON THEN PERFORM.

	Subsequent Non-Declarative Procedures

		MOVE "FALL-THROUGH" TO DEBUG-CONTENTS.

			LL: PN section.
			LL: PN.

		MOVE "PN" TO DEBUG-NAME
		IF DEBUG-ON THEN PERFORM.

	Use Procedure (Not For debugging)

			LL: PN section.
			    USE ...

		MOVE "USE PROCEDURE" TO DEBUG-CONTENTS
		MOVE "PN" TO DEBUG-NAME
		IF DEBUG-ON THEN PERFORM.

*/
declare	en		fixed bin,
	ep		ptr;

	M2.ptr (2) = TOK_TAB.ptr (1);

	go to EPN (decswitch);

EPN (0):						/* 0: initial value */
EPN (1):						/* 1: procedure division */
EPN (3):						/* 3: use(debugging) */
	call emit_nl;

	if ^stne
	then return;

	go to EPN2;

EPN (2):						/* 2: declaratives */
EPN (4):						/* 4: use(not debugging) */
	call emit_nl;

	if ^stne & ^all_procs
	then return;
EPN2:
	M4.ptr (2) = item_tab.ptr (21);		/* USE PROCEDURE */

	call emit_macro (addr (M4));			/* MOVE xx TO DEBUG-CONTENTS */


	go to EPN1;

EPN (5):						/* 5: end declaratives */
	if ^stne & ^all_procs
	then do;
		call emit_nl;
		return;
	     end;

/*[4.0-1]*/
	if ln_not_emitted				/*[4.0-1]*/
	then do;
		call PUT (item_tab.ptr (9));		/* MOVE */
						/*[4.0-1]*/
		call PUT (item_tab.ptr (77));		/* "999999" */

/*[4.0-1]*/
		nines_ptr = addrel (RP1, 1);

/*[4.0-1]*/
		call PUT (item_tab.ptr (10));		/* TO */
						/*[4.0-1]*/
		call PUT (item_tab.ptr (1));		/* DEBUG-LINE */

/*[4.0-1]*/
		ln_not_emitted = "0"b;

/*[4.0-1]*/
	     end;

	if pn_count = 1
	then M4.ptr (2) = item_tab.ptr (16);		/* START PROGRAM */
	else M4.ptr (2) = item_tab.ptr (22);		/* FALL THROUGH */

	call emit_macro (addr (M4));			/* MOVE xx TO DEBUG-CONTENTS */
	call PUT (item_tab.ptr (75));			/* . */
	call emit_nl;				/* emit statement */

	go to EPN1;

EPN1:
	call emit_macro (addr (M2));			/* MOVE "PN" TO DEBUG-NAME */



	if all_procs
	then ep = debug_table.proc.entry.proc_ptr (1);	/* use on all procs specified */
	else do;
		en = statement.proc.entry.num (1);
		ep = debug_table.proc.entry.proc_ptr (en);
	     end;

	call emit_perform (ep);

	call PUT (item_tab.ptr (75));			/* . */
     end;

set_debug_line:
     proc;

/*[4.0-1]*/
	call emit_macro (addr (M1));			/* MOVE AN_LIT(line) TO DEBUG-LINE */

/*[4.0-1]*/
	if nines_ptr ^= null ()			/*[4.0-1]*/
	then do;
		substr (nines_ptr -> alphanum_lit.string, 1, 6) = LN1;

/*[4.0-1]*/
		nines_ptr = null ();		/*[4.0-1]*/
	     end;

/*[4.0-1]*/
	ln_not_emitted = "0"b;

     end;


emit_alter:
     proc;					/* alter statement */

declare	(i, num, TOK)	fixed bin,
	(pn1, pn2, proc_ptr)
			ptr;


/*[4.0-1]*/
	call set_debug_line;			/* MOVE AN-LIT(line) TO DEBUG-LINE */
	if alt_ct > 0
	then do i = 1 by 1 to alt_ct;

		pn1 = TOK_TAB.ptr (alt_tab.pn1 (i));
		pn2 = TOK_TAB.ptr (alt_tab.pn2 (i));

		if all_procs
		then proc_ptr = debug_table.proc.entry.proc_ptr (1);
						/* use for all procs specified */
		else do;
			num = statement.proc.entry.num (i);
			proc_ptr = debug_table.proc.entry.proc_ptr (num);
		     end;

		M2.ptr (2) = pn1;
		call emit_macro (addr (M2));		/* MOVE NAME(token) TO DEBUG-NAME */

		M6.ptr (2) = pn2;
		call emit_macro (addr (M6));		/* MOVE NAME(token) TO DEBUG-CONTENTS */

		call emit_perform (proc_ptr);		/* IF SWITCH-8 THEN PERFORM ...*/

	     end;

	call emit_nl;

     end;

emit_data:
     proc (p, q);

declare	(p, q, dn_ptr)	ptr,
	TOKNO		fixed bin;

declare	1 state_dn	based (p),
	  2 num		fixed bin,		/* debug table entry */
	  2 TOK		fixed bin;		/* token table entry */

declare	1 data_dn		based (q),
	  2 TOK_size	fixed bin,
	  2 dimen		fixed bin,
	  2 sub_1,
	    3 TOK		fixed bin,
	    3 TOK_size	fixed bin,
	  2 sub_2,
	    3 TOK		fixed bin,
	    3 TOK_size	fixed bin,
	  2 sub_3,
	    3 TOK		fixed bin,
	    3 TOK_size	fixed bin,
	  2 sub_ptr	ptr;

declare	1 dntok,
	  2 TOK		fixed bin,
	  2 TOK_size	fixed bin;

declare	1 entry_dn	based (dn_ptr),
	  2 seg_num	fixed bin,
	  2 offset	fixed bin,
	  2 level		fixed bin,
	  2 name_size	fixed bin,
	  2 name		char (32),
	  2 proc_ptr	ptr;

	if ^emrec
	then if state_dn.TOK < 0 & debug_table.data.all_refs (state_dn.num) = "0"b
	     then return;

	if state_dn.TOK < 0
	then TOKNO = -state_dn.TOK;
	else TOKNO = state_dn.TOK;

	M2.ptr (2) = TOK_TAB.ptr (TOKNO);
	call emit_macro (addr (M2));			/* MOVE NAME(token TO DEBUG-NAME */

	if data_dn.dimen > 0
	then do;
		call set_subs;
		call emit_subs (q);
	     end;

	dntok.TOK = TOKNO;
	dntok.TOK_size = data_dn.TOK_size;
	dn_ptr = addr (debug_table.data.entry (state_dn.num));

	call PUT (item_tab.ptr (9));			/* MOVE */
	call emit_range (addr (dntok));		/* identifier */
	call PUT (item_tab.ptr (10));			/* TO */
	call PUT (item_tab.ptr (3));			/* DEBUG-CONTENTS */

	call emit_perform (entry_dn.proc_ptr);
     end;

emit_subs:
     proc (p);

declare	p		ptr;

declare	1 data		based (p),
	  2 TOK_size	fixed bin,
	  2 dimen		fixed bin,
	  2 sub_1,
	    3 TOK		fixed bin,
	    3 TOK_size	fixed bin,
	  2 sub_2,
	    3 TOK		fixed bin,
	    3 TOK_size	fixed bin,
	  2 sub_3,
	    3 TOK		fixed bin,
	    3 TOK_size	fixed bin,
	  2 sub_ptr	ptr;

	if data.dimen > 3
	then return;

	go to DM (data.dimen);

DM (1):
	call emit_sub (item_tab.ptr (4), addr (data.sub_1));
	go to DM1;

DM (2):
	call emit_sub (item_tab.ptr (4), addr (data.sub_1));
	call emit_sub (item_tab.ptr (5), addr (data.sub_2));
	go to DM1;

DN (3):
	call emit_sub (item_tab.ptr (4), addr (data.sub_1));
	call emit_sub (item_tab.ptr (5), addr (data.sub_2));
	call emit_sub (item_tab.ptr (6), addr (data.sub_3));
	go to DM1;

DM1:
     end;

emit_sub:
     proc (item_tab_ptr, sub_ptr);

declare	(item_tab_ptr, sub_ptr, PP)
			ptr;

declare	1 sub		based (sub_ptr),
	  2 TOK		fixed bin,
	  2 TOK_size	fixed bin;

	PP = TOK_TAB.ptr (sub.TOK);

	if PP -> header.type = 10
	then do;
		if TOK_size > 4
		then return;

		call PUT (item_tab.ptr (23));		/* SET */
		call PUT (item_tab_ptr);		/* DEBUG-SUB-i */
		call PUT (item_tab.ptr (10));		/* TO */
		call PUT (TOK_TAB.ptr (TOK));		/* index-name */

		if TOK_size = 3
		then do;
			call PUT (item_tab.ptr (24)); /* COMPUTE */
			call PUT (item_tab_ptr);	/* DEBUG-SUB-i */
			call PUT (item_tab.ptr (13)); /* = */
			call PUT (item_tab_ptr);	/* DEBUG-SUB-i */
			call PUT (TOK_TAB.ptr (TOK)); /* +- */
			call PUT (TOK_TAB.ptr (TOK + 1));
						/* integer */
		     end;
	     end;
	else do;
		call PUT (item_tab.ptr (24));		/* COMPUTE */
		call PUT (item_tab_ptr);		/* DEBUG-SUB-i */
		call PUT (item_tab.ptr (13));		/* = */
		call emit_range (sub_ptr);
	     end;
     end;

emit_range:
     proc (p);

declare	p		ptr,
	i		fixed bin;

declare	1 sub		based (p),
	  2 TOK		fixed bin,
	  2 TOK_size	fixed bin;

	do i = sub.TOK by 1 to sub.TOK + sub.TOK_size - 1;

	     call PUT (TOK_TAB.ptr (i));

	end;
     end;

PUT:
     proc (p);

declare	p		ptr;

	p -> header.line = last_line;
	p -> header.column = last_col;

	RP = p;
	call PUT_REC;

     end;

emit_macro:
     proc (p);

declare	(p, rptr)		ptr,
	LN		char (6),
	ch		char (1),
	NAME		char (30),
	(i, j)		fixed bin;

declare	1 def		based (p),
	  2 size		fixed bin,
	  2 def		(128),
	    3 type	fixed bin,
	    3 num		fixed bin,
	    3 ptr		ptr;

/*	type = 1	token(ptr)
					type = 2	debug-line value(ptr)
					type = 3	token name value(ptr)
				*/

declare	line_num		fixed bin based (def.def.ptr (i));

declare	ch30		char (30) based;

	do i = 1 by 1 to def.size;

	     go to EM (def.def.type (i));

EM (1):						/* token */
	     rptr = def.def.ptr (i);
	     go to EM1;

EM (2):						/* DEBUG-LINE value */
	     LN = " ";
	     call ioa_$rsnnl ("^d", LN, 6, line_num);

	     j = 6;
	     LN1 = " ";
	     ch = substr (LN, j, 1);

	     do while (ch = " " & j > 0);

		j = j - 1;
		ch = substr (LN, j, 1);

	     end;

	     if j > 0
	     then substr (LN1, 7 - j, j) = substr (LN, 1, j);

	     rptr = item_tab.ptr (7);
	     rptr -> alphanum_lit.lit_size = 6;
	     rptr -> alphanum_lit.string = LN1;
	     go to EM1;

EM (3):						/* DEBUG-NAME value */
	     PP, rptr = def.def.ptr (i);

	     call set_type;

	     go to TTP (DB_TYPE);

TTP (1):						/* proc-name */
	     NAME = rptr -> proc_def.name;
	     go to TTP1;

TTP (2):						/* data-name */
	     NAME = rptr -> data_name.name;
	     go to TTP1;

TTP (3):						/* file-name */
	     NAME = rptr -> fd_token.name;
	     go to TTP1;

TTP (4):						/* cd-name */
	     NAME = rptr -> cdtoken.name;
	     go to TTP1;

TTP1:
	     rptr = item_tab.ptr (8);

	     NAME = translate (NAME, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", "abcdefghijklmnopqrstuvwxyz");

	     substr (rptr -> alphanum_lit.string, 1, 30) = NAME;
						/* form alphanumeric literal */
	     go to EM1;

EM1:
	     rptr -> header.line = last_line;
	     rptr -> header.column = last_col;

	     RP = rptr;
	     call PUT_REC;

	end;
     end;

emit_file:
     proc (p);

declare	(p, fn_ptr)	ptr;

/* execute debug section for file-name 
					   DEBUG-NAME = file-name
					   DEBUG-CONTENTS = entire record(READ), SPACES(^READ)
					*/

declare	1 state_fn	based (p),
	  2 num		fixed bin,		/* debug table entry */
	  2 TOK		fixed bin;		/* TOK_TAB entry */

declare	1 entry_fn	based (fn_ptr),
	  2 file_no	fixed bin,
	  2 proc_ptr	ptr;

	fn_ptr = addr (debug_table.file.entry (state_fn.num));

	call emit_debug_name (TOK_TAB.ptr (state_fn.TOK));/* MOVE NAME(token) TO DEBUG-NAME */

	if statement.type = 21
	then do;
		call emit_rec_name (fn_ptr);		/* READ statement */
	     end;
	else do;
		call emit_macro (addr (M3));
	     end;





	call emit_perform (entry_fn.proc_ptr);

     end;

emit_perform:
     proc (p);					/* IF SWITCH-9 PERFORM debug-section END-IF */
declare	p		ptr;

	M5.ptr (9) = p;

	call emit_macro (addr (M5));

     end;

emit_cd:
     proc (p);

declare	(p, cd_ptr, cd_name_ptr)
			ptr;			/* execute debug section for cd-name
						   DEBUG-NAME = cd-name
						   DEBUG-CONTENTS = area for cd-name
						*/

declare	1 state_cd	based (p),
	  2 num		fixed bin,		/* debug table entry */
	  2 TOK		fixed bin;		/* TOK_TAB entry */

declare	1 entry_cd	based (cd_ptr),
	  2 cd_num	fixed bin,
	  2 proc_ptr	ptr;

	cd_ptr = addr (debug_table.cd.entry (state_cd.num));

/*[4.4-3]*/
	cd_name_ptr = TOK_TAB.ptr (state_cd.TOK);	/*[4.4-3]*/
	call emit_debug_name (cd_name_ptr);		/*[4.4-3]*/
	call emit_debug_contents (cd_name_ptr);

	call emit_perform (entry_cd.proc_ptr);

     end;

emit_db_code:
     proc;

/* execute the debug sections specified
						   in the statement table
						*/

declare	i		fixed bin;

	if statement.cd.size ^= 0			/* cd-names */
	then do i = 1 by 1 to statement.cd.size;

		call emit_cd (addr (statement.cd.entry (i)));

	     end;

	if statement.file.size ^= 0			/* file-names */
	then do i = 1 by 1 to statement.file.size;

		call emit_file (addr (statement.file.entry (i)));

	     end;

	if statement.data.size ^= 0			/* data-names */
	then do i = 1 by 1 to statement.data.size;

		call emit_data (addr (statement.data.entry (i)), addr (statement.data.data (i)));

	     end;
     end;

emit_debug_name:
     proc (p);					/* MOVE NAME(token) TO DEBUG-LINE */
declare	p		ptr;

	M2.ptr (2) = p;

	call emit_macro (addr (M2));
     end;

emit_debug_contents:
     proc (p);

declare	p		ptr;

	M4.ptr (2) = p;

	call emit_macro (addr (M4));
     end;

open_db:
     proc (tab_ptr);				/* initialize for debug table search	*/
						/* TAB based(tab_ptr)		*/
						/* (first_ptr,last_ptr,size,max)	*/
dcl	tab_ptr		ptr;

	TAB_PTR = tab_ptr;
	ENT_NUM = 0;
	NEXT_PTR = null ();
	ENT_PTR = null ();
	eof = "0"b;
	main_tab = "1"b;

     end;

extend_db:
     proc (ent_size);

declare	ent_size		fixed bin,
	new_ptr		ptr;

	ENT_NUM = ENT_NUM + 1;

	if ENT_NUM <= TAB.max
	then return;

	new_ptr = cobol$alloc (ent_size + 2);

	if ENT_NUM = TAB.max + 1
	then do;
		TAB.first_ptr = new_ptr;
		main_tab = "0"b;
	     end;
	else TAB.last_ptr -> ENTRY.next = new_ptr;

	TAB.last_ptr, ENT_PTR = new_ptr;
	new_ptr -> ENTRY.next = null ();
     end;

get_next_db:
     proc;					/* find next entry in a sub-table */
	ENT_NUM = ENT_NUM + 1;

	if ENT_NUM > TAB.size
	then do;
		eof = "1"b;			/* end of table */
		return;
	     end;

	if ENT_NUM <= TAB.max
	then do;
		main_tab = "1"b;			/* entry in main table */
		return;
	     end;

	if ENT_NUM = TAB.max + 1
	then do;
		main_tab = "0"b;

		if TAB.first_ptr = null ()		/* first entry in extended table */
		then do;
			eof = "1"b;		/* end of table */
			return;
		     end;
		ENT_PTR = TAB.first_ptr;
	     end;
	else do;
		if ENTRY.next = null ()		/* subseq entry in extended table */
		then do;
			eof = "1"b;		/* end of table */
			return;
		     end;
		ENT_PTR = ENTRY.next;
	     end;
     end;

search_data:
     proc;					/* search debug table for data-name */
	call open_db (addr (debug_table.data));

	do while ("1"b);

	     call get_next_db;

	     if eof
	     then do;
		     if MODE ^= 0
		     then call extend_db (data_size);

		     if main_tab
		     then ENT_PTR = addr (TAB_PTR -> data_array (ENT_NUM));
		     return;
		end;

	     if main_tab
	     then ENT_PTR = addr (TAB_PTR -> data_array (ENT_NUM));
	     else ENT_PTR = addr (ENTRY.data);

	     call dn_comp;
	     if res = 1
	     then return;
	end;
     end;

search_proc:
     proc;					/* search debug table for proc-name */
	call open_db (addr (debug_table.proc));

	do while ("1"b);

	     call get_next_db;

	     if eof
	     then do;
		     if MODE ^= 0
		     then call extend_db (proc_size);

		     if main_tab
		     then ENT_PTR = addr (TAB_PTR -> proc_array (ENT_NUM));
		     return;
		end;

	     if main_tab
	     then ENT_PTR = addr (TAB_PTR -> proc_array (ENT_NUM));
	     else ENT_PTR = addr (ENTRY.data);

	     call pn_comp;
	     if res = 1
	     then return;
	end;
     end;

search_file:
     proc;					/* search debug table for file-name */
	call open_db (addr (debug_table.file));

	do while ("1"b);

	     call get_next_db;

	     if eof
	     then do;
		     if MODE ^= 0
		     then call extend_db (file_size);

		     if main_tab
		     then ENT_PTR = addr (TAB_PTR -> file_array (ENT_NUM));
		     return;
		end;

	     if main_tab
	     then ENT_PTR = addr (TAB_PTR -> file_array (ENT_NUM));
	     else ENT_PTR = addr (ENTRY.data);

	     call fn_comp;
	     if res = 1
	     then return;
	end;
     end;

search_cd:
     proc;					/* search debug table for cd-name */
	call open_db (addr (debug_table.cd));

	do while ("1"b);

	     call get_next_db;

	     if eof
	     then do;
		     if MODE ^= 0
		     then call extend_db (cd_size);

		     if main_tab
		     then ENT_PTR = addr (TAB_PTR -> cd_array (ENT_NUM));

		     return;
		end;

	     if main_tab
	     then ENT_PTR = addr (TAB_PTR -> cd_array (ENT_NUM));
	     else ENT_PTR = addr (ENTRY.data);

	     call cd_comp;
	     if res = 1
	     then return;
	end;
     end;

emit_go_to:
     proc;

	call emit_macro (addr (M3));			/* MOVE SPACES TO DEBUG-CONTENTS */

	call emit;
	call st_init;

     end;

emit_go_to_dep:
     proc;

/*[4.0-1]*/
	call set_debug_line;

	if stne
	then call emit_db_code;

	if statement.proc.size ^= 0
	then call emit_macro (addr (M3));

	call emit_nl;
     end;

emit_string:
     proc;					/* string statement */
	call emit;
	call st_init;
     end;

emit_unstring:
     proc;					/* unstring statement */
	call emit;
	call st_init;
     end;

SM_emit:
     proc (iw_ptr, TOK_NUM);

declare	iw_ptr		ptr,
	TOK_NUM		fixed bin;

	M4.ptr (2) = iw_ptr;			/* literal */
	M2.ptr (2) = TOK_TAB.ptr (TOK_NUM);		/* PN */

	call emit_macro (addr (M4));			/* MOVE LL TO DEBUG-CONTENTS */

	call emit_macro (addr (M2));			/* MOVE "PN" TO DEBUG-NAME */

/*[4.0-1]*/
	call set_debug_line;			/* MOVE LINE TO DEBUG-LINE */

     end;

emit_sort_merge:
     proc (type);					/* sort/merge statements */

declare	type		fixed bin;		/* 0: sort, 1: merge */
declare	sub_ptr		ptr;

declare	1 sub,
	  2 TOK		fixed bin,
	  2 TOK_size	fixed bin;

	sub_ptr = addr (sub);


	if sm_desc.ip_TOK ^= 0
	then do;
		sub.TOK = 1;
		sub.TOK_size = sm_desc.ip_TOK - 1;
		call emit_range (sub_ptr);

		call SM_emit (item_tab.ptr (17), sm_desc.ip_TOK);
						/* SORT INPUT */

		if sm_desc.op_TOK ^= 0
		then do;
			sub.TOK = sm_desc.ip_TOK;
			sub.TOK_size = sm_desc.op_TOK - sm_desc.ip_TOK;
			call emit_range (sub_ptr);

			call SM_emit (item_tab.ptr (18), sm_desc.op_TOK);
						/* SORT OUTPUT */

			sub.TOK = sm_desc.op_TOK;
			sub.TOK_size = TOK_TAB.size - sm_desc.op_TOK;
			call ER (sub_ptr);
		     end;
		else do;
			sub.TOK = sm_desc.ip_TOK;
			sub.TOK_size = TOK_TAB.size - sm_desc.ip_TOK;
			call ER (sub_ptr);
		     end;
	     end;
	else do;
		if sm_desc.op_TOK ^= 0
		then do;
			sub.TOK = 1;
			sub.TOK_size = sm_desc.op_TOK - 1;
			call emit_range (sub_ptr);

			if type = 0
			then call SM_emit (item_tab.ptr (18), sm_desc.op_TOK);
						/* SORT OUTPUT */
			else call SM_emit (item_tab.ptr (19), sm_desc.op_TOK);
						/* MERGE OUTPUT */

			sub.TOK = sm_desc.op_TOK;
			sub.TOK_size = TOK_TAB.size - sm_desc.op_TOK;
			call ER (sub_ptr);
		     end;
		else do;
			call emit;
			call st_init;
		     end;
	     end;
     end;

ER:
     proc (sub_ptr);

declare	sub_ptr		ptr;

	call emit_range (sub_ptr);

	TOK_TAB.ptr (1) = TOK_TAB.ptr (TOK_TAB.size);
	TOK_TAB.size = 1;

     end;

emit_if:
     proc;					/* if statement */
	call emit;
	call st_init;
     end;

emit_move:
     proc;					/* move statement */
	call emit;
	if stne
	then call emit_db_code;
	call st_init;
     end;

emit_perform_state:
     proc;

declare	i		fixed bin;

	if per_desc.pn1 = 0
	then do;
		call emit;			/* in-line perform */
		call st_init;
		return;
	     end;

	if ^stne
	then do;
		call emit;
		call st_init;
		return;
	     end;

/*[4.0-1]*/
	call set_debug_line;			/* MOVE LINE-NUMBER TO DEBUG-LINE */

	if per_desc.format ^= 4
	then call PUT (item_tab.ptr (15));		/* PERFORM */

	emrec = "1"b;

	go to PERF (per_desc.format);

PERF (1):
	go to PRF;

PERF (2):
	call emit_range (addr (per_desc.count));

	call PUT (item_tab.ptr (28));			/* TIMES */

	call get_st_num (per_desc.count.tok_no);

	if st_no ^= 0
	then call ED (st_no);

	go to PRF;
PERF (3):
	call PUT (item_tab.ptr (29));			/* UNTIL */
	call emit_range (addr (per_desc.until));

	per_desc.until.copy_loc = copy_tab.size + 1;
	copy_mode = "1"b;

	call emit_db_cond (addr (per_desc.until));	/* debug(condition) */

	copy_mode = "0"b;

	call perf_common;

/*[4.0-1]*/
	call set_debug_line;			/* MOVE LINE-NUMBER TO DEBUG-LINE */

	call PUT (item_tab.ptr (27));			/* END-PERFORM */

/*[4.0-1]*/
	call set_debug_line;			/* MOVE LINE-NUMBER TO DEBUG-LINE */

	call emit_copy (per_desc.until.copy_loc);	/* debug(condition) */

	go to PRF2;

PRF:
	call perf_common;
	call PUT (item_tab.ptr (27));			/* END-PERFORM */
PRF2:
	call reset_TOK_TAB;

	emrec = "0"b;
	return;

PERF (4):
	do i = 1 by 1 to per_desc.dim;

	     call perf_set (i);

/* debug(V(i),R(i)) */

	end;

	do i = 1 by 1 to per_desc.dim;

	     call perf_until (i);			/* debug(cond(i)) */

	end;

	call perf_common;

/*[4.0-1]*/
	call set_debug_line;			/* MOVE LINE-NUMBER TO DEBUG-LINE */

	call perf_incr (per_desc.dim);

/* debug(V,I) */

	call PUT (item_tab.ptr (27));			/* END-PERFORM */

	call emit_copy (per_desc.loop.cond.copy_loc (per_desc.dim));
						/* debug(cond) */

	if per_desc.dim = 1
	then go to PRF2;

	do i = per_desc.dim - 1 by -1 to 1;

	     call perf_set (i + 1);

/* debug(V,R) */

	     call perf_incr (i);

/* debug(V,I) */

	     call PUT (item_tab.ptr (27));		/* END-PERFORM */

	     call emit_copy (per_desc.loop.cond.copy_loc (i));
						/* debug(cond(i)) */

	end;

	go to PRF2;
     end;

perf_common:
     proc;

declare	(pn1, pn2)	fixed bin;		/* MOVE pn1 TO DEBUG-NAME */
	st_no = 0;

	if per_desc.pn1 ^= 0 & statement.proc.size ^= 0
	then call get_st_proc_num (per_desc.pn1);

	if st_no ^= 0
	then do;

		call emit_debug_name (TOK_TAB.ptr (per_desc.pn1));

/* MOVE "PERFORM-LOOP" TO DEBUG-CONTENTS */

		call emit_debug_contents (item_tab.ptr (20));

/* MOVE line-number TO DEBUG-LINE */

	     end;

/* PERFORM pn1 THRU pn2 */
	pn1 = per_desc.pn1;
	pn2 = per_desc.pn2;

	call PUT (item_tab.ptr (15));			/* PERFORM */
	call PUT (TOK_TAB.ptr (pn1));			/* PN */
	call PUT (item_tab.ptr (32));			/* THRU  */

	if pn2 ^= 0
	then call PUT (TOK_TAB.ptr (pn2));
	else call PUT (TOK_TAB.ptr (pn1));



/*[4.0-1]*/
	call set_debug_line;			/* MOVE LINE-NUMBER TO DEBUG-LINE */

     end;

perf_until:
     proc (i);

declare	i		fixed bin;

	call PUT (item_tab.ptr (15));			/* PERFORM */
	call PUT (item_tab.ptr (29));			/* UNTIL */

	call PUT (item_tab.ptr (67));			/* ( */
	call emit_range (addr (per_desc.cond (i)));	/* condition */
	call PUT (item_tab.ptr (31));			/* ) */

	per_desc.loop.cond.copy_loc (i) = copy_tab.size + 1;
	copy_mode = "1"b;

	call emit_db_cond (addr (per_desc.loop.cond (i)));/* debug(condition) */

	copy_mode = "0"b;

     end;

perf_set:
     proc (i);

declare	i		fixed bin,
	(v, f)		fixed bin,
	(vp, rp)		ptr;

	vp = addr (per_desc.loop.var (i));
	rp = addr (per_desc.loop.from (i));

	if TOK_TAB.ptr (per_desc.loop.var.tok_no (i)) -> header.type = 10
	then do;
		call PUT (item_tab.ptr (23));		/* SET, V = index name */
		call emit_range (vp);		/* V */
		call PUT (item_tab.ptr (10));		/* TO */
		call emit_range (rp);		/* R */
	     end;

	else if TOK_TAB.ptr (per_desc.loop.from.tok_no (i)) -> header.type = 10
	then do;
		call PUT (item_tab.ptr (23));		/* SET, V = identifier */
		call emit_range (vp);		/* V */
		call PUT (item_tab.ptr (10));		/* TO */
		call emit_range (rp);		/* R */
	     end;
	else do;
		call PUT (item_tab.ptr (9));		/* MOVE, R = inentifier */
		call emit_range (rp);		/* R */
		call PUT (item_tab.ptr (10));		/* TO */
		call emit_range (vp);		/* V */
	     end;

	call db_perf (rp, vp);

/*	SET(V R)	V = identifier	R = identifier	MOVE R TO V
				R = index-name	SET V TO R
				R = literal	MOVE R TO V
		V = index-name			SET V TO R
*/

     end;

perf_incr:
     proc (i);

declare	i		fixed bin,
	(v, r)		fixed bin,
	(vp, rp)		ptr;

/*	V = identifier	R = identifier	ADD R TO V
			R = index-name
			R = literal

	V = index-name	R = identifier	SET V UP BY R
			R = index-name
			R = literal
*/

	vp = addr (per_desc.loop.var (i));
	rp = addr (per_desc.loop.by (i));

	if TOK_TAB.ptr (per_desc.loop.var.tok_no (i)) -> header.type = 10
	then do;
		call PUT (item_tab.ptr (23));		/* SET */
		call emit_range (vp);		/* V */
		call PUT (item_tab.ptr (25));		/* UP */
		call PUT (item_tab.ptr (26));		/* BY */
		call emit_range (rp);		/* R */
	     end;
	else do;
		call PUT (item_tab.ptr (33));		/* ADD */
		call emit_range (rp);		/* R */
		call PUT (item_tab.ptr (10));		/* TO */
		call emit_range (vp);		/* V */
	     end;

	call db_perf (rp, vp);
     end;

/*	Perform Statement Expansion

	Format 1:

		XX PERFORM pn1 THRU pn2

		LINE = "XX"
		PERFORM
			NAME = "pn1"
			CONTENTS = "PERFORM=LOOP"
			PERFORM pn1 THRU pn2
			LINE = "XX"
		END-PERFORM

	Format 2:

		XX PERFORM pn1 THRU pn2 count TIMES

		LINE = "XX"
		PERFORM count TIMES
			NAME = "pn1"
			CONTENTS = "PERFORM-LOOP"
			PERFORM pn1 THRU pn2
			LINE = "XX"
		END-PERFORM

	Format 3:

		XX PERFORM pn1 THRU pn2 UNTIL condition

		LINE = "XX"
		PERFORM UNTIL condition
			debug(condition)
			NAME = "pn1"
			CONTENTS = "PERFORM-LOOP"
			PERFORM pn1 THRU pn2
			LINE = "XX"
		END-PERFORM
		LINE = "XX"
		debug(condition)

	Format 4:

	XX PERFORM pn1 THRU pn2
		VARYING V1 FROM R1 BY I1 UNTIL C1
		AFTER   V2 FROM R2 BY I2 UNTIL C2
		AFTER   V3 FROM R3 BY I3 UNTIL C3

	LINE = "XX"
	SET(V1 R1) debug(V1 R1)
	SET(V2 R2) debug(V2 R2)
	SET(V3 R3) debug(V3 R3)

	PERFORM UNTIL ( C1 )
		debug( C1 )
		PERFORM UNTIL  ( C2 )
			debug( C2)
			PERFORM UNTIL  ( C3 )
				debug( C3 )
				NAME = "pn1"
				CONTENTS = "PERFORM-LOOP"
				PERFORM pn1 THRU pn2
				LINE = "XX"
				INCR(V3 I3) debug(V3 I3)
			END-PERFORM
			debug(C3)
			SET(V3 R3) debug(V3 R3)
			INCR(V2 I2) debug(V2 I2)
		END-PERFORM
		debug(C2)
		SET(V2 R2) debug(V2 R2)
		INCR(V1 I1) debug(V1 I1)
	END-PERFORM
	debug(C1)
*/

reset_TOK_TAB:
     proc;

	TOK_TAB.ptr (1) = TOK_TAB.ptr (TOK_TAB.size);
	TOK_TAB.size = 1;

     end;

emit:
     proc;					/* emit all but last token */
declare	TOK_SIZE		fixed bin;

	TOK_SIZE = TOK_TAB.size;
	TOK_TAB.size = TOK_TAB.size - 1;

/*[4.0-1]*/
	if N_L & DB & decswitch > 3
	then call set_debug_line;
	call EMIT;				/* last token now first token */
	TOK_TAB.ptr (1) = TOK_TAB.ptr (TOK_SIZE);
	TOK_TAB.size = 1;

     end;						/*[4.4-3]*/
declare	opt_word_num	fixed bin;
emit_not_option:
     proc (not_option);

declare	not_option	fixed bin;




	call db_emit;				/* emit statement */

	if ^stne
	then return;

/*[4.4-3]*/
	if statement.type ^= 23
	then call PUT (item_tab.ptr (30));		/* emit NOT unless RECEIVE state */

	call emit_option (not_option);		/* emit option clause */

emit_option:
     proc (not_option);

declare	not_option	fixed bin;

	go to ENO (not_option);

ENO (1):						/* ON SIZE ERROR */
	call PUT (item_tab.ptr (35));
	call PUT (item_tab.ptr (36));
	call PUT (item_tab.ptr (37));
	go to ENO1;

ENO (2):						/* AT END */
	call PUT (item_tab.ptr (38));
	call PUT (item_tab.ptr (39));
	go to ENO1;

ENO (3):						/* INVALID KEY */
	call PUT (item_tab.ptr (40));
	call PUT (item_tab.ptr (41));
	go to ENO1;

ENO (4):						/* AT EOP */
	call PUT (item_tab.ptr (38));
	call PUT (item_tab.ptr (42));
	go to ENO1;

ENO (5):						/* ON OVERFLOW */
	call PUT (item_tab.ptr (35));
	call PUT (item_tab.ptr (43));
	go to ENO1;

ENO (6):						/* WITH DATA */
	call PUT (item_tab.ptr (44));
	call PUT (item_tab.ptr (45));
	go to ENO1;

ENO (7):						/* ON EXCEPTION */
	call PUT (item_tab.ptr (35));
	call PUT (item_tab.ptr (46));
	go to ENO1;

ENO (8):						/* NO/WITH DATA */
	call PUT (item_tab.ptr (opt_word_num));
	call PUT (item_tab.ptr (45));			/*4.4-3]*/
	opt_word_num = 47;				/* no */
	go to ENO1;
ENO1:
     end;

	call emit_db_code;

	call emit_option (not_option);

	if statement.type ^= 21 & statement.type ^= 23
	then call emit_db_code;

	call st_init;

	not_emitted = "1"b;
     end;

db_emit:
     proc;

	go to VERB (statement.type);

VERB (0):						/*[4.4-4]*/
	call emit;				/*[4.4-4]*/
	e_res = 2;
	return;

VERB (1):						/* accept */
	call emit;				/*[5.0-1]*/
	if cd_pres
	then e_res = 1;
	else e_res = 2;
	return;
VERB (2):						/* add */
	call emit;
	e_res = 1;
	return;
VERB (3):						/* illegal */
	call emit_nl;
	e_res = 2;
	return;
VERB (4):						/* alter */
	call emit_alter;
	e_res = 2;
	return;
VERB (5):						/* call */
	call emit;
	e_res = 1;
	return;
VERB (6):						/* illegal */
	call emit_nl;
	e_res = 2;
	return;
VERB (7):						/* cancel */
	call emit;
	e_res = 1;
	return;
VERB (8):						/* close */
	call emit;
	e_res = 1;
	return;
VERB (9):						/* divide */
	call emit;
	e_res = 1;
	return;
VERB (10):					/* multiply */
	call emit;
	e_res = 1;
	return;
VERB (11):					/* subtract */
	call emit;
	e_res = 1;
	return;
VERB (12):					/* exit */
	call emit_nl;
	e_res = 2;
	return;
VERB (13):					/* illegal */
	call emit_nl;
	e_res = 2;
	return;
VERB (14):					/* go */
	call emit_go_to;
	e_res = 2;
	return;
VERB (15):					/* merge */
	call emit_sort_merge (1);
	;
	e_res = 2;
	return;
VERB (16):					/* initiate */
	call emit;
	e_res = 1;
	return;
VERB (17):					/* inspect */
	call emit;
	e_res = 1;
	return;
VERB (18):					/* move */
	call emit_move;
	e_res = 2;
	return;
VERB (19):					/* open */
	call emit;
	e_res = 1;
	return;
VERB (20):					/* perform */
	call emit_perform_state;
	e_res = 2;
	return;
VERB (21):					/* read */
	call emit;
	e_res = 1;
	return;
VERB (22):					/* delete */
	call emit;
	e_res = 1;
	return;
VERB (23):					/* receive */
	call emit;
	e_res = 1;
	return;
VERB (24):					/* release */
	call emit;
	e_res = 1;
	return;
VERB (25):					/* return */
	call emit;
	e_res = 1;
	return;
VERB (26):					/* search */
	call emit;
	e_res = 1;
	return;
VERB (27):					/* rewrite */
	call emit_wr_rew;
	e_res = 1;
	return;
VERB (28):					/* illegal */
	call emit_nl;
	e_res = 1;
	return;
VERB (29):					/* illegal */
	call emit_nl;
	e_res = 1;
	return;
VERB (30):					/* send */
	call emit;
	e_res = 1;
	return;
VERB (31):					/* set */
	call emit;
	e_res = 1;
	return;
VERB (32):					/* illegal */
	call emit_nl;
	e_res = 2;
	return;
VERB (33):					/* stop */
	call emit;
	e_res = 2;
	return;
VERB (34):					/* string */
	call emit_string;
	e_res = 2;
	return;
VERB (35):					/* suspend */
	call emit;
	e_res = 1;
	return;
VERB (36):					/* terminate */
	call emit;
	e_res = 1;
	return;
VERB (37):					/* unstring */
	call emit_unstring;
	e_res = 2;
	return;
VERB (38):					/* write */
	call emit_wr_rew;
	e_res = 1;
	return;
VERB (39):					/* illegal */
	call emit_nl;
	e_res = 2;
	return;
VERB (40):					/* compute */
	call emit;
	e_res = 1;
	return;
VERB (41):					/* disable */
	call emit;
	e_res = 1;
	return;
VERB (42):					/* display */
	call emit;
	e_res = 1;
	return;
VERB (43):					/* enable */
	call emit;
	e_res = 1;
	return;
VERB (44):					/* enter */
	call emit;
	e_res = 2;
	return;
VERB (45):					/* generate */
	call emit;
	e_res = 1;
	return;
VERB (46):					/* hold */
	call emit;
	e_res = 2;
	return;
VERB (47):					/* if */
	call emit_if;
	return;
VERB (48):					/* process */
	call emit;
	e_res = 2;
	return;
VERB (49):					/* sort */
	call emit_sort_merge (0);
	e_res = 2;
	return;
VERB (50):					/* examine */
	call emit;
	e_res = 1;
	return;
VERB (51):					/* transform */
	call emit;
	e_res = 1;
	return;
VERB (56):					/* start */
	call emit;
	e_res = 1;
	return;
VERB (57):					/* suppress */
	call emit;
	e_res = 1;
	return;
VERB (58):					/* purge */
	call emit;
	e_res = 1;
	return;
VERB (100):					/* procedure division */
	call emit_nl;
	e_res = 2;
	return;
VERB (101):					/* declaratives */
	call emit_nl;
	e_res = 2;
	return;
VERB (103):					/* section header */
	call emit_proc_name;
	e_res = 2;
	return;
VERB (104):					/* paragraph header */
	call emit_proc_name;
	e_res = 2;
	return;
VERB (106):					/* . */
	call emit_nl;
	e_res = 2;
	return;
VERB (107):					/* P.go to. */
	call emit_go_to;
	e_res = 2;
	return;
VERB (108):					/* go to depending */
	call emit_go_to_dep;
	e_res = 2;
	return;
VERB (109):					/* P.exit [program] */
	call emit_nl;
	e_res = 2;
	return;
VERB (110):					/* stop statement */
	call emit_nl;
	e_res = 1;
	return;
VERB (111):					/* end declaratives */
	call emit_nl;

	if ^DB & ^all_procs
	then return;

	res = 1;

	if proc_def_size > 0
	then do while (res = 1);

		call cobol_swf_get (cobol_rmin2fp, st, addr_record, tln);

		if alphanum_lit.type = 3 & alphanum_lit.string = "~~~"
		then res = 0;

	     end;

	call st_init;
	TOK_TAB.size = 0;
	call SCAN;
	return;
VERB (112):					/* end_cobol */
	call emit_nl;
	e_res = 2;
	return;
VERB (113):					/* type 25 token */
	call emit_nl;
	e_res = 2;
	return;
VERB (114):					/* use statement */
	call emit_nl;
	e_res = 2;
	return;
VERB (115):					/* on size error */
	call emit_nl;
	e_res = 2;
	return;
VERB (116):					/* next */
	call emit_nl;
	e_res = 2;
	return;
VERB (117):					/* else */
	call emit_nl;
	e_res = 2;
	return;
VERB (118):					/* invalid key */
	call emit_nl;
	e_res = 2;
	return;
VERB (119):					/* at end */
	call emit_nl;
	e_res = 2;
	return;
VERB (120):					/* at eop */
	call emit_nl;
	e_res = 2;
	return;

     end;

enter_db_table:
     proc;

	PP = addr_record;
	call set_type;

	if DB_TYPE = 1 & all_procs			/* test for all procs */
	then do;
		call diag (1);
		return;
	     end;

	MODE = 0;
	call search_debug_table;

	if eof
	then DB = "1"b;

	go to EDT (DB_TYPE);			/* make new entry in debug table */

EDT (1):						/* proc-name */
	if eof
	then do;
		proc_entry.section_name = PP -> proc_def.section_name;
		proc_entry.section_num = PP -> proc_def.section_num;
		proc_entry.proc_num = PP -> proc_def.proc_num;
		proc_entry.proc_ptr = section_ptr;
	     end;
	else call diag (2);

	go to EDT1;

EDT (2):						/* identifier */
	if eof
	then do;
		data_entry.proc_ptr = section_ptr;
		data_entry.seg_num = PP -> data_name.seg_num;
		data_entry.offset = PP -> data_name.offset;
		data_entry.level = PP -> data_name.level;
		data_entry.name_size = PP -> data_name.name_size;
		data_entry.name = PP -> data_name.name;

		if ALL_REFS
		then debug_table.data.all_refs (debug_table.data.size + 1) = "1"b;

	     end;
	else call diag (3);

	go to EDT1;

EDT (3):						/* file-name */
	if eof
	then do;
		file_entry.proc_ptr = section_ptr;
		file_entry.file_no = PP -> fd_token.file_no;
	     end;
	else call diag (4);

	go to EDT1;

EDT (4):						/* cd-name */
	if eof
	then do;
		cd_entry.proc_ptr = section_ptr;
		cd_entry.cd_num = PP -> cdtoken.cd_num;
	     end;
	else call diag (5);

	go to EDT1;

EDT1:
	TAB_PTR -> CD.size = TAB_PTR -> CD.size + 1;	/* incr size of debug sub-table */

     end;

search_st_table:
     proc;					/* search and enter statement table */
	go to SST (DB_TYPE);

SST (1):						/* proc-name */
	tab_max = 50;
	tab_ptr = addr (statement.proc);
	call ent_tab;
	go to SS;

SST (2):						/* identifier */
	tab_max = 50;
	tab_ptr = addr (statement.data);
	call ent_tab;

	if send_bit
	then do;
		if new_entry
		then statement.data.entry.TOK (EN) = -statement.data.entry.TOK (EN);
	     end;
	else do;
		if statement.data.entry.TOK (EN) < 0
		then statement.data.entry.TOK (EN) = -statement.data.entry.TOK (EN);
	     end;

	QQ = addr (statement.data.data (EN));
	statement_data_entry.dimen = 0;
	statement_data_entry.TOK_size = 1;
	ST_NO = EN;

	go to SS;

SST (3):						/* file-name */
	tab_max = 20;
	tab_ptr = addr (statement.file);
	call ent_tab;
	go to SS;

SST (4):						/* cd-name */
	tab_max = 5;
	tab_ptr = addr (statement.cd);
	call ent_tab;

	go to SS;

SS:
     end;

ent_tab:
     proc;

	tab_size = TB.size;
	new_entry = "1"b;

	if tab_size = 0
	then do;
		EN, TB.size = 1;
		stne = "1"b;
		TB.num (1) = ENT_NUM;
		TB.TOK (1) = TOK_TAB.size;

		return;
	     end;

	do EN = 1 by 1 to tab_size;

	     if TB.num (EN) = ENT_NUM
	     then do;
		     new_entry = "0"b;
		     return;
		end;

	end;

	if tab_size = tab_max
	then do;
		EN = 0;				/* not found */
		new_entry = "0"b;

		return;
	     end;

	EN, tab_size = tab_size + 1;
	TB.size = tab_size;
	TB.num (tab_size) = ENT_NUM;
	TB.TOK (tab_size) = TOK_TAB.size;

     end;

enter_st_table:
     proc;					/* If token is in the debug table	*/
						/* then search and enter the		*/
						/* statement table			*/
	QQ = null ();
	ST_NO = 0;

	if decswitch < 3
	then do;
		res = 0;
		return;
	     end;

	PP = addr_record;
	MODE = 0;
	EN = 0;

	call set_type;
	call search_debug_table;

	if res = 0
	then return;				/* send_bit = 1(sending) 0(receiving) */
	call search_st_table;

	res = 1;

     end;

search_debug_table:
     proc;					/* see if token mentioned in a use */
						/* for debugging section */

	ENT_NUM = 0;
	ENT_PTR = null ();

	if DB_TYPE = 0
	then return;

	go to SCH (DB_TYPE);

SCH (1):						/* proc-name */
	if all_procs
	then res = 0;				/* use on all procs specified */
	else call search_proc;

	go to SC;

SCH (2):						/* identifier */
	call search_data;
	go to SC;

SCH (3):						/* file-name */
	call search_file;
	go to SC;

SCH (4):						/* cd-name */
	call search_cd;
	go to SC;

SC:
     end;

dn_comp:
     proc;					/* compare identifiers */


	res = 0;

	if PP -> data_name.seg_num = data_entry.seg_num & PP -> data_name.offset = data_entry.offset
	     & PP -> data_name.level = data_entry.level & PP -> data_name.name_size = data_entry.name_size
	     & PP -> data_name.name = substr (data_entry.name, 1, data_name.name_size)
	then res = 1;
     end;

pn_comp:
     proc;					/* compare proc names */
	res = 0;

	if PP -> proc_def.section_name
	then do;
		if ^proc_entry.section_name
		then return;			/* section name */

		if PP -> proc_def.section_num = proc_entry.proc_num
		then res = 1;
	     end;
	else do;
		if proc_entry.section_name
		then return;			/* paragraph name */

		if PP -> proc_def.proc_num = proc_entry.proc_num
		then res = 1;
	     end;
     end;

fn_comp:
     proc;					/* compare file-names */
	res = 0;

	if PP -> fd_token.file_no = file_entry.file_no
	then res = 1;
     end;

cd_comp:
     proc;					/* compare cd-names */
	res = 0;

	if PP -> cdtoken.cd_num = cd_entry.cd_num
	then res = 1;
     end;

set_type:
     proc;					/* token type -> DB_TYPE */
declare	TYPE		fixed bin;

	TYPE = PP -> header.type;
	DB_TYPE, res = 0;

	if TYPE <= 18
	then go to TYP (TYPE);

	return;


TYP (7):						/* proc-name */
TYP (18):
	DB_TYPE = 1;
	go to TP;

TYP (9):						/* identifier */
	DB_TYPE = 2;
	go to TP;

TYP (12):						/* file-name */
TYP (16):
	DB_TYPE = 3;
	go to TP;

TYP (13):						/* cd-name */
	DB_TYPE = 4;
	go to TP;

TYP (1):
TYP (2):
TYP (3):
TYP (4):
TYP (5):
TYP (6):
TYP (10):
TYP (11):
TYP (14):
TYP (15):
TYP (17):
TP:
     end;

scan_to_end:
     proc;					/* read and copy all tokens after the	*/
						/* type 25 token			*/
	call emit;
	call st_init;

	do while ("1"b);

	     call cobol_swf_get (cobol_rmin2fp, st, addr_record, tln);
						/* read record */

	     if substr (st, 17, 16) ^= "0"b
	     then return;				/* eof */

	     call cobol_swf_put (cobol_x3fp, st, addr_record, header.size);
						/* write record */

	end;
     end;

emit_rec_name:
     proc (f_ptr);

declare	f_ptr		ptr,
	ch5		char (5);

declare	FN		fixed bin based (f_ptr);

	ch5 = cobol_ddsyntax$get_file_key (FN);

	if ch5 ^= ""
	then do;
		call cobol_read_rand_ (2, ch5, M4.ptr (2));

		call emit_macro (addr (M4));		/* MOVE RECORD NAME TO DEBUG-CONTENTS */
	     end;

	else call emit_macro (addr (M3));		/* MOVE SPACES TO DEBUG-CONTENTS */

     end;

emit_wr_rew:
     proc;

/*	WRITE record-name FROM identifier ...
				becomes
			MOVE identifier TO record-name
			DEBUG(identifier,record-name)
			WRITE record-name ...
		*/

declare	i		fixed bin,
	fn_save		fixed bin;

	if from_pres
	then do;
		call PUT (item_tab.ptr (9));		/* MOVE */
		call emit_range (addr (FR));		/* identifier */
		call PUT (item_tab.ptr (10));		/* TO */
		call PUT (TOK_TAB.ptr (2));		/* record-name */
						/*[4.0-1]*/
		call set_debug_line;		/* MOVE AN-LIT(statement.line) TO DEBUG-LINE */
		fn_save = statement.file.size;
		statement.file.size = 0;

		call emit_db_code;

		statement.file.size = fn_save;
		statement.data.size = 0;

		do i = FR.TOK + FR.TOK_size by 1 to TOK_TAB.size;

		     TOK_TAB.ptr (i - FR.TOK_size - 1) = TOK_TAB.ptr (i);

		end;

		TOK_TAB.size = TOK_TAB.size - FR.TOK_size - 1;

		call emit_nl;

	     end;

	else call emit;

     end;

db_perf:
     proc (sp, rp);					/*emit debug code during perform statement */

declare	(rp, sp)		ptr;
declare	(sp_no, rp_no)	fixed bin;
declare	TN		fixed bin,
	p		ptr;

declare	1 ident		based,
	  2 tok_no	fixed bin,
	  2 size		fixed bin;

	sp_no, rp_no = 0;				/* entry numbers in statement table */

	TN = sp -> ident.tok_no;
	p = TOK_TAB.ptr (TN);

	if p -> header.type = 9 | p -> header.type = 10
	then do;
		call get_st_num (TN);		/* entry num in statement table */
		sp_no = st_no;
	     end;

	TN = rp -> ident.tok_no;
	p = TOK_TAB.ptr (TN);

	if p -> header.type = 9 | p -> header.type = 10
	then do;
		call get_st_num (TN);		/* entry num in statement table */
		rp_no = st_no;
	     end;

	if sp_no ^= 0
	then do;
		call ED (sp_no);			/* emit code */

		if rp_no = 0 | rp_no = sp_no
		then return;

		call ED (rp_no);			/* emit code */

	     end;
	else if rp_no ^= 0
	then call ED (rp_no);

     end;

get_st_num:
     proc (tn);

declare	(tn, data_tok_num, i)
			fixed bin;

	st_no = 0;

	if statement.data.size ^= 0
	then do i = 1 by 1 to statement.data.size;

		data_tok_num = statement.data.entry.TOK (i);

		if data_tok_num < 0
		then data_tok_num = -data_tok_num;

		if tn = data_tok_num
		then do;
			st_no = i;
			return;
		     end;
	     end;
     end;

ED:
     proc (tn);

declare	tn		fixed bin;

	call emit_data (addr (statement.data.entry (tn)), addr (statement.data.data (tn)));
     end;

get_st_proc_num:
     proc (tn);

/* get entry num in statement table for proc name */

declare	(tn, i)		fixed bin;

	do i = 1 by 1 to statement.proc.size;

	     if statement.proc.entry.TOK (i) = tn
	     then do;
		     st_no = i;
		     return;
		end;
	end;
     end;

set_per_cond_ptr:
     proc;

	per_cond_ptr = addr (per_desc.loop.cond (per_desc.dim));
	per_desc.loop.cond.tok_count (per_desc.dim) = 0;

     end;

set_until_ptr:
     proc;

	per_cond_ptr = addr (per_desc.until);
	per_desc.until.tok_count = 0;

     end;

emit_db_cond:
     proc (p);

declare	p		ptr;

declare	1 cond_desc	based (p),
	  2 tok_no	fixed bin,
	  2 size		fixed bin,
	  2 copy_loc	fixed bin,
	  2 tok_count	fixed bin,
	  2 tok		(128) fixed bin;

	if cond_desc.tok_count > 0
	then do i = 1 by 1 to cond_desc.tok_count;

		call ED (cond_desc.tok (i));

	     end;
     end;

set_subs:
     proc;

	call PUT (item_tab.ptr (9));			/* MOVE */
	call PUT (item_tab.ptr (14));			/* SPACE */
	call PUT (item_tab.ptr (10));			/* TO */
	call PUT (item_tab.ptr (76));			/* DEBUG-SUBS */

     end;

declare	ST_NO		fixed bin,
	per_cond_ptr	ptr;

declare	st_no		fixed bin;		/* entry num in statement table */

declare	1 FR,
	  2 TOK		fixed bin,
	  2 TOK_size	fixed bin;

declare	e_res		fixed bin;

declare	save_addr_record	ptr;

declare	1 TOK_TAB,
	  2 size		fixed bin,
	  2 ptr		(1024) ptr;

declare	proc_ptr		ptr,
	proc_num		fixed bin;

declare	(tab_max, tab_size) fixed bin;

declare	1 TB		based (tab_ptr),
	  2 size		fixed bin,
	  2 entry		(tab_max),
	    3 num		fixed bin,
	    3 TOK		fixed bin;


declare	1 ST		(256),
	  2 parity	fixed bin,		/* 0 no NOT, 1 NOT */
	  2 end_word	fixed bin;

/*	end_word =	1	end-add
		2	end-call
		3	end-compute
		4	end-delete
		5	end-divide
		6	end-evaluate
		7	end-if
		8	end-multiply
		9	end-perform
		10	end-read
		11	end-receive
		12	end-return
		13	end-rewrite
		14	end-search
		15	end-start
		16	end-string
		17	end-subtract
		18	end-unstring
		19	end-write
*/

declare	(cd_size, end_word, nest_lev, PROC_NUM, pn_count)
			fixed bin;
declare	(tab_ptr, section_ptr)
			ptr;

declare	MODE		fixed bin,
	res		fixed bin;
declare	(data_size, proc_size, file_size, cd, i, last_line, last_col)
			fixed bin;
declare	DB_TYPE		fixed bin,
	PP		ptr,
	EN		fixed bin;
declare	(IN_LINE, dim, BEG_ID)
			fixed bin;

declare	TOK_ptr		ptr;
declare	TOK_NUM		fixed bin based (TOK_ptr);

declare	1 sm_desc,
	  2 ip_TOK	fixed bin,		/* input procedure */
	  2 op_TOK	fixed bin;		/* output procedure */

declare	1 item_tab,
	  2 size		fixed bin,
	  2 ptr		(128) ptr;

declare	1 statement_entry	based (QQ),
	  2 num		fixed bin,
	  2 TOK		fixed bin;

declare	1 statement_data_entry
			based (QQ),
	  2 TOK_size	fixed bin,
	  2 dimen		fixed bin,
	  2 sub_1,
	    3 TOK		fixed bin,
	    3 TOK_size	fixed bin,
	  2 sub_2,
	    3 TOK		fixed bin,
	    3 TOK_size	fixed bin,
	  2 sub_3,
	    3 TOK		fixed bin,
	    3 TOK_size	fixed bin,
	  2 sub_ptr	ptr;

declare	1 table		based (tab_ptr),
	  2 size		fixed bin,
	  2 num		(50) fixed bin;

declare	1 cd_entry	based (ENT_PTR),
	  2 cd_num	fixed bin,
	  2 proc_ptr	ptr;

declare	1 file_entry	based (ENT_PTR),
	  2 file_no	fixed bin,
	  2 proc_ptr	ptr;

declare	1 proc_entry	based (ENT_PTR),
	  2 section_name	bit (1),
	  2 section_num	fixed bin,
	  2 proc_num	fixed bin,
	  2 proc_ptr	ptr;

declare	1 data_entry	based (ENT_PTR),
	  2 seg_num	fixed bin,
	  2 offset	fixed bin,
	  2 level		fixed bin,
	  2 name_size	fixed bin,
	  2 name		char (32),
	  2 proc_ptr	ptr;

/* num: entry number in debug_table	*/
/* TOK: entry number in TOK_TAB	*/
declare	1 statement,
	  2 type		fixed bin,
	  2 line		fixed bin,
	  2 cd,					/* cd-names */
	    3 size	fixed bin,
	    3 entry	(5),
	      4 num	fixed bin,
	      4 TOK	fixed bin,
	  2 file,					/* file-names */
	    3 size	fixed bin,
	    3 entry	(20),
	      4 num	fixed bin,
	      4 TOK	fixed bin,
	  2 proc,					/* proc-names */
	    3 size	fixed bin,
	    3 entry	(50),
	      4 num	fixed bin,
	      4 TOK	fixed bin,
	  2 data,					/* identifiers */
	    3 size	fixed bin,
	    3 entry	(50),
	      4 num	fixed bin,
	      4 TOK	fixed bin,		/* neg if sending field */
	    3 data	(50),
	      4 TOK_size	fixed bin,
	      4 dimen	fixed bin,
	      4 sub_1,
	        5 TOK	fixed bin,
	        5 TOK_size	fixed bin,
	      4 sub_2,
	        5 TOK	fixed bin,
	        5 TOK_size	fixed bin,
	      4 sub_3,
	        5 TOK	fixed bin,
	        5 TOK_size	fixed bin,
	      4 sub_ptr	ptr;

dcl	1 debug_table,
	  2 cd,
	    3 first_ptr	ptr,
	    3 last_ptr	ptr,
	    3 size	fixed bin,
	    3 max		fixed bin,
	    3 entry	(5),			/* cd_names */
	      4 cd_num	fixed bin,
	      4 proc_ptr	ptr,
	  2 file,
	    3 first_ptr	ptr,
	    3 last_ptr	ptr,
	    3 size	fixed bin,
	    3 max		fixed bin,
	    3 entry	(20),			/* file names */
	      4 file_no	fixed bin,
	      4 proc_ptr	ptr,
	  2 proc,
	    3 first_ptr	ptr,
	    3 last_ptr	ptr,
	    3 size	fixed bin,
	    3 max		fixed bin,
	    3 entry	(50),			/* proc names */
	      4 section_name
			bit (1),
	      4 section_num fixed bin,
	      4 proc_num	fixed bin,
	      4 proc_ptr	ptr,
	  2 data,
	    3 first_ptr	ptr,
	    3 last_ptr	ptr,
	    3 size	fixed bin,
	    3 max		fixed bin,
	    3 entry	(50),			/* data names */
	      4 seg_num	fixed bin,		/* neg if all refs */
	      4 offset	fixed bin,
	      4 level	fixed bin,
	      4 name_size	fixed bin,
	      4 name	char (32),
	      4 proc_ptr	ptr,
	    3 all_refs	(256) bit (1);

declare	1 alt_tab		(128),			/* alter statement table */
	  2 pn1		fixed bin,
	  2 pn2		fixed bin;

dcl	(TAB_PTR, NEXT_PTR, ENT_PTR, QQ)
			ptr;
dcl	alt_ct		fixed bin;
dcl	ENT_NUM		fixed bin;

declare	1 CD		based,
	  2 first_ptr	ptr,
	  2 last_ptr	ptr,
	  2 size		fixed bin,
	  2 max		fixed bin,
	  2 cd_array	(5),
	    3 cd_num	fixed bin,
	    3 proc_ptr	ptr;

declare	1 FILE		based,
	  2 first_ptr	ptr,
	  2 last_ptr	ptr,
	  2 size		fixed bin,
	  2 max		fixed bin,
	  2 file_array	(20),
	    3 file_no	fixed bin,
	    3 proc_ptr	ptr;

declare	1 PROC		based,
	  2 first_ptr	ptr,
	  2 last_ptr	ptr,
	  2 size		fixed bin,
	  2 max		fixed bin,
	  2 proc_array	(50),
	    3 section_name	bit (1),
	    3 section_num	fixed bin,
	    3 proc_num	fixed bin,
	    3 proc_ptr	ptr;

declare	1 DATA		based,
	  2 first_ptr	ptr,
	  2 last_ptr	ptr,
	  2 size		fixed bin,
	  2 max		fixed bin,
	  2 data_array	(50),
	    3 seg_num	fixed bin,
	    3 offset	fixed bin,
	    3 level	fixed bin,
	    3 name_size	fixed bin,
	    3 name	char (32),
	    3 proc_ptr	ptr;

declare	1 ENTRY		based (ENT_PTR),
	  2 next		ptr,
	  2 data		fixed bin;

declare	1 TAB		based (TAB_PTR),
	  2 first_ptr	ptr,
	  2 last_ptr	ptr,
	  2 size		fixed bin,
	  2 max		fixed bin;

declare	(key, min_index, max_index)
			fixed bin;


declare	(file_org, seg_num, mod_num, act_num)
			fixed bin;
declare	last_seg_num	fixed bin init (1000);
declare	pigz_res		fixed bin;

declare	DIAG_NUM		fixed bin;
declare	tm1		fixed bin (24) init (1),
	tm2		fixed bin (24) init (2),
	tm3		fixed bin (24) init (3),
	tm4		fixed bin (24) init (4),
	tm5		fixed bin (24) init (5);

dcl	vfile_key		fixed bin;
dcl	kc		fixed bin;

declare	1 cond_desc	based (per_cond_ptr),
	  2 tok_no	fixed bin,
	  2 size		fixed bin,
	  2 copy_loc	fixed bin,
	  2 tok_count	fixed bin,
	  2 tok		(128) fixed bin;

declare	(RP, RP1)		ptr;

declare	1 copy_tab,
	  2 size		fixed bin,
	  2 ptr		(256) ptr;

declare	1 per_desc,				/* perform statement description */
	  2 format	fixed bin,		/* 1,2 ,3,4 */
	  2 pn1		fixed bin,		/* proc-name, 0 if in-line, TN */
	  2 pn2		fixed bin,		/* proc-name, 0 if in-line, TN */
	  2 dim		fixed bin,		/* dimension */
	  2 loop		(3),			/* format 4 */
	    3 var,				/* loop variable */
	      4 tok_no	fixed bin,
	      4 size	fixed bin,
	    3 from,				/*from variable */
	      4 tok_no	fixed bin,
	      4 size	fixed bin,
	    3 by,					/* by variable */
	      4 tok_no	fixed bin,
	      4 size	fixed bin,
	    3 cond,				/* condition */
	      4 tok_no	fixed bin,		/* first token, TN */
	      4 size	fixed bin,		/* token count */
	      4 copy_loc	fixed bin,		/* copy stack loc */
	      4 tok_count	fixed bin,
	      4 tok	(128) fixed bin,
	  2 count,				/* count control, format 2 */
	    3 tok_no	fixed bin,
	    3 size	fixed bin,
	  2 until,				/* condition, format 3 */
	    3 tok_no	fixed bin,		/* first token, TN */
	    3 size	fixed bin,		/* token count */
	    3 copy_loc	fixed bin,		/* copy stack loc */
	    3 tok_count	fixed bin,
	    3 tok		(128) fixed bin;



declare	lev_save		fixed bin (24);
declare	subs		(3) fixed bin;
declare	sub_loc		fixed bin;		/*[4.0-1]*/
declare	LN1		char (6),
	nines_ptr		ptr;


declare	1 indicators,
	  2 tbit		bit (1),
	  2 res		bit (1),
	  2 SAE		bit (1),
	  2 send_bit	bit (1),			/* 0 receiving, 1 sending */
	  2 from_pres	bit (1),			/* FROM clause present */
	  2 not_emitted	bit (1),			/* 0 no NOT generated, 1 NOT generated */
	  2 UB_ind	bit (1) init ("0"b),
	  2 subj_req	bit (1),
	  2 db_use_state	bit (1),
	  2 emrec		bit (1),
	  2 copy_mode	bit (1),			/*[4.0-1]*/
	  2 ln_not_emitted	bit (1),
	  2 inhibit_db	bit (1),
	  2 new_entry	bit (1),
	  2 N_L		bit (1),
	  2 db_use_bit	bit (1),
	  2 bad_token	bit (1),
	  2 eof		bit (1),			/* item not in table */
	  2 main_tab	bit (1),			/* entry to made in main table */
	  2 stne		bit (1),			/* statement table is not empty */
	  2 ref_bit	bit (1),
	  2 ALL_REFS	bit (1),			/* all refs phrase used */
	  2 DB		bit (1),			/* debug table is not empty */
	  2 all_procs	bit (1);			/* use for db on all procs used */


dcl	(cssub, db_res, lang_num)
			fixed bin;

dcl	st		bit (32);
dcl	tln		fixed bin;

/* common area */
declare	(a_ptr, w_ptr, sub_ptr)
			ptr;
declare	file_number	fixed bin;


dcl	ft_ptr		ptr;


dcl	gotodep		bit (1) static;		/*  for go to depending verb found in an if statement */

dcl	preospn_bit	bit (1) static;		/* used by EXIT verb */
dcl	(dg_ptr, lev_dg_ptr)
			ptr;			/* pointer to diag item passed to print routine*/
						/*  type 5 structure used to construct diagnostics issued by pdsyntax */
dcl	1 diag_item,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 run		fixed bin,
	  2 number	fixed bin,
	  2 info		bit (8),
	  2 multics	char (3);

declare	1 lev_diag_item,
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin,
	  2 run		fixed bin,
	  2 number	fixed bin,
	  2 module	fixed bin;



dcl	srchfm2bit	bit (1) static;		/* format 2 of search verb */
dcl	srchbit		bit (1) static;		/* when set we are processing a search verb */
dcl	nestifcnt		fixed bin static;		/* counter for nested if statements */
dcl	common_recsize	fixed bin;		/* size of record just read from common file */

dcl	tempkey		fixed bin;		/* used to hold res word key */
dcl	litcnt		fixed bin;		/* used for size of numeric literal */
						/* used to save the subscript count */
dcl	(subcnt, dimensions)
			fixed bin;
dcl	impswitch		fixed bin static;		/* used for imp verbs */
dcl	decswitch		fixed bin static;		/* if prog has sectons */
dcl	secswitch		fixed bin static;		/* used for sections */
						/* used for debugging sections */



dcl	x		bit (8) based;		/* length of one line in syntax table */

declare	1 interp,
	  2 current_line	fixed bin (24),
	  2 phase		fixed bin (24),
	  2 addr_record	ptr,
	  2 pointer_to_internal
			ptr,
	  2 directory_ptr	ptr,
	  2 source_ptr	ptr;

/* the following dcls are used in conjunction with the syntax table subroutines */
/* the current nested limit is 75 */
declare	intrp_stack	(75) fixed bin (24),	/* used for syntax subroutine */
	i1		fixed bin static;		/* syntax table */
dcl	p		ptr;
declare	trace_ptr		ptr;
dcl	dumfix		fixed bin;

declare	1 syntax_table	(0:10000) based (pointer_to_internal),
	  2 b1		fixed bin,
	  2 b2		fixed bin,
	  2 b3		fixed bin,
	  2 b4		fixed bin,
	  2 b5		fixed bin;

declare	1 syntax_line	based (syntax_line_ptr),
	  2 s_bit		char (1),
	  2 o_bit		char (1),
	  2 t_type	fixed bin,
	  2 t_field	fixed bin,
	  2 s_exit	fixed bin,
	  2 a_num		fixed bin;

declare	syntax_line_ptr	ptr;

declare	1 sline,
	  2 s_bit		char (1),
	  2 o_bit		char (1),
	  2 t_type	fixed bin,
	  2 t_field	fixed bin,
	  2 s_exit	fixed bin,
	  2 a_num		fixed bin;

declare	1 header		based (addr_record),
	  2 size		fixed bin,
	  2 line		fixed bin,
	  2 column	fixed bin,
	  2 type		fixed bin;


dcl	occptr		ptr;


dcl	seqvarptr		ptr;
dcl	varrecaddr	char (5);

dcl	cobol$alloc	entry (fixed bin) returns (ptr);
dcl	(addr, size, fixed, null, substr, unspec, min, max, addrel, translate, string)
			builtin;
dcl	cobol_syntax_trace_$trace
			entry (ptr, fixed bin (24));
dcl	cobol_syntax_trace_$initialize_phase
			entry (ptr, fixed bin (24));
dcl	cobol_imp_word$lang_name
			entry (ptr) returns (fixed bin);
dcl	cobol_swf_get	entry (ptr, bit (32), ptr, fixed bin) ext;
dcl	cobol_read_rand_	entry (fixed bin, char (5), ptr);
dcl	cobol_read_ft	entry (fixed bin, ptr);
dcl	cobol_vdwf_dget	entry (ptr, bit (32), ptr, fixed bin, char (5)) ext;
dcl	ioa_$rsnnl	entry options (variable);
dcl	cobol_swf_put	entry (ptr, bit (32), ptr, fixed bin) ext;
dcl	cobol_db_put	entry (ptr, bit (32), ptr, fixed bin, ptr);
dcl	cobol_vdwf_sput	entry (ptr, bit (32), ptr, fixed bin, char (5)) ext;
dcl	cobol_vdwf_dput	entry (ptr, bit (32), ptr, fixed bin, char (5)) ext;
dcl	cobol_ddsyntax$get_file_key
			entry (fixed bin) returns (char (5));
dcl	cobol_c_list	entry (ptr) ext;		/*  called to print sources and diags */
dcl	cobol_db		entry (ptr, fixed bin) ext;
%include cobol_ext_;

%include cobol_fixed_common;


/* the layout of a file table */


%include cobol_file_table;
%include cobol_diag_file;
%include cobol_;

declare	1 alphabet_name	based (addr_record),
%include cobol_TYPE40;


dcl	1 reserved_word	based (addr_record),
%include cobol_TYPE1;

dcl	1 numeric_lit	based (addr_record),
%include cobol_TYPE2;

dcl	1 alphanum_lit	based (addr_record),
%include cobol_TYPE3;

dcl	1 proc_def	based (addr_record),
%include cobol_TYPE7;

dcl	1 data_name	based (addr_record),
%include cobol_TYPE9;

dcl	1 occurs		based (occptr),
%include cobol_OCCURS;

dcl	1 index_name	based (addr_record),
%include cobol_TYPE10;

dcl	1 fd_token	based (addr_record),
%include cobol_TYPE12;


%include cobol_type13;
dcl	1 mnemonic_name	based (addr_record),
%include cobol_TYPE17;
dcl	01 dumprocname	static,
%include cobol_TYPE18;
/* type18 procedure name stored here for go to depending */
dcl	01 store_label_1	static internal,
%include cobol_TYPE18;
/* store type 18 for go dependig */
dcl	01 store_label_2	static internal,
%include cobol_TYPE18;
%include cobol_file_desc_1;
     end cobol_db_phase;
