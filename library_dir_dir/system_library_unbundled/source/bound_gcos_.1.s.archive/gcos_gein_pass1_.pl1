/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   *********************************************************** */
gcos_gein_pass1_: proc;

/*
   This procedure reads thru the input segment, and any $ SELECTed files,
   performing the following functions:

   1) optional canonicalization of ascii segments (conversion of tabs and
   backspaces to the right number of blanks);

   2) copying of $ SELECTed files into the job stream;

   3) scanning for $ EXECUTE and $ 355SIM cards, for later PSW bit 5 setting.

   It writes the job stream file in standard gcos format. This file contains
   no $ SELECT cards; they are discarded when the $ SELECTed files are
   copied into the job stream.

   For each $ control card, the ascii image, as well as the bcd image, is
   written on the job stream file (with a media code of "0110"b), the
   ascii image preceeding the bcd image.

   The $ control cards are written on the execution report at this time.

   Author: T. CASEY APRIL 1973
   Change: T. CASEY NOVEMBER 1973, FEBRUARY 1974, APRIL 1974, JUNE 1974, AUGUST 1974
   Change: R.H. MORRISON OCTOBER 1974
   Change: D. KAYDEN DECEMBER 1974, MARCH 1975
   Change: R.H. MORRISON SEPTEMBER 19, 1975
   Change: M. R. Jordan, August 1977
   Change: Mel Wilson  March 1979 for gtss media codes.
   Change: Dave Ward	06/21/81 Reorganized. Corrected bug tabulation & alter files.
   Change: Ron Barstad  83-08-02  Start numbering jcl with 1 instead of 2!
                                  Fix card count message to look like GCOS
*/
	write_buffer_ptr = addr (write_buffer);
/*	status_ptr = addr (status); */


	ascii_work_area (*) = (4)"040"b3;
	ascii_ptr = addr (ascii_work_area);
	ascii_card_ptr = addrel (ascii_ptr, 1);
	ascii_len = 20;
	ascii_record.rcw = ascii_rcw;
	substr (ascii_report_card, 85, 1) = ascii_newline;

	write_buffer_ptr = addr (write_buffer);
	output_word_ptr = addrel (write_buffer_ptr, 1);
	remaining_output_words = 319;
	write_buffer_ptr -> bcw.bsn = "000001"b3 ;
	write_buffer_ptr -> bcw.length = (18)"0"b;

	save_data.last_execute_act_no,		/* initialize activity numbers */
	     act_no = 0;
	gcos_ext_stat_$userid = "";

/* stack the main input segment for reading */
	stack_level = 0;
	select_path = gcos_ext_stat_$input_segment_path;
	select_path_len = length (gcos_ext_stat_$input_segment_path);

	if gcos_ext_stat_$save_data.gcos then		/* input is gcos file */
	     ascii_sw, canon_sw = "0"b;
	else do;					/* input is ascii segment */
	     if gcos_ext_stat_$save_data.no_canonicalize
	     then canon_sw = "0"b;
	     else canon_sw = "1"b;
	     ascii_sw = "1"b;
	end;

	on condition (cleanup) call pass1_cleanup;	/* before we start allocating things */

	call stack_selected_file;
						/* inputs to stack_selected_file include: select_path,
						   select_path_len, ascii_sw, canon_sw */

/* attach gcos_job_stream_file for writing */
	js_io_sw = "1"b;				/* in case of io error, print path of job stream file */

	js_path = gcos_ext_stat_$save_dir || ">" || gcos_ext_stat_$job_id || ".job_deck";
	call ios_$attach ("gcos_job_stream_", "file_", js_path, "w", status);
	if code ^= 0 then do;
	     err_msg = "from ios_$attach ^a w";
	     goto file_error;
	end;

	call ios_$setsize ("gcos_job_stream_", 36, status);
	if code ^= 0 then do;
setsize_err:   err_msg = "from ios_$setsize ^a";
	     goto file_error;
	end;

	call ios_$seek ("gcos_job_stream_", "last", "first", 0, status); /* truncate, in case it exists */
	if code ^= 0 then do;
	     err_msg = "from ios_$seek ^a";
	     goto file_error;
	end;

	js_io_sw = "0"b;				/* in case of io error, print pathname of current input file */
%page;
/*     Main loop. Read input as long as any remains. */
	do while (stack_level > 0);			/* (stack level becomes zero at eof on main input seg) */

	     dollar_sw, eof_sw, select_card = "0"b;

	     call read_current_file;
						/* outputs of read_current_file include:
						   gcos_ptr,gcos_len,bcd_card_ptr,
						   ascii_ptr,ascii_len,ascii_card_ptr,
						   dollar_sw,eof_sw, card_type */

	     if eof_sw then				/* if end of file, go back to reading the previous file,
						   if there is one */

		call unstack_current_file;

/*   if eof occurred, fall thru to end of read_loop   */
	     else					/* not eof */
process_card:  do;

		card_count = card_count + 1;		/* count cards */
		if stack_level > 1 then selected_card_count = selected_card_count + 1;

		if dollar_sw then do;		/* if this is a dollar card */

		     if card_type = "endcop" then
			if endfc = "" | substr (ascii_card, 16, 2) = endfc then copy_sw = "0"b;


		     if substr (ascii_card, 8, 8) = "selectd" then goto process_select_card; /* even if copy_sw is on */
		     if copy_sw | card_type = "alter" then do;
			dollar_sw = "0"b;		/* pretend its not a dollar card */
			goto end_process_dollar_card;
		     end;

		     if card_type = "data" then do;	/* check for copy option */
			i = index (substr (ascii_card, 18), ",copy");

/* NOTE: Above code does not provide for ",copy"
   as comment on a data card.
*/
			if i ^= 0 then do;
			     copy_sw = "1"b;
			     i = index (substr (ascii_card, 18), ",endfc");
			     if i ^= 0 then endfc = substr (ascii_card, 16, 2);
			     else endfc = "";
			end;
		     end;

		     if card_type = "select" then do;	/* special handling of select cards */
process_select_card:
			select_card = "1"b;
			call interpret_select_card;
						/* outputs from interpret_select_card include:
						   select_path,select_path_len,ascii_sw,canon_sw */

/* stack the selected file for reading */
			call stack_selected_file;
		     end;
		     else do;			/* Process non-select card. */
			if card_type = "userid" then do; /* special handling of  $ USERID cards */
			     gcos_ext_stat_$save_data.userid = "1"b; /* remember it, so prmfiles will be allowed */
			     in_password = "0"b;

			     if gcos_ptr ^= addr (bcd_work_area) then do; /* can't modify the input file */
				overlay_ptr = addr (bcd_work_area); /* get ptr to our work area */
				overlay_ptr -> bcd_card_overlay = gcos_ptr -> bcd_card_overlay;
						/* copy card into it */
				gcos_ptr = overlay_ptr; /* make it our working copy */
				bcd_card_ptr = addrel (gcos_ptr, 1);
			     end;

			     do i = 16 to 72	/* scan card */
				     while (substr (ascii_card, i, 1) ^= " "); /* to end of operand field */
				if in_password then /* wiping out password */
				     substr (ascii_card, i, 1) = "#";
				else
				if substr (ascii_card, i, 1) = "$" then /* or looking for start of password */
				     in_password = "1"b;
			     end;

			     goto job_stream_write;	/* go write it on job stream and execution report */
			end;

			do i = 1 to gcos_control_tables_$totallen /* look up card in table */
				while (card_type ^= substr (gcos_control_tables_$cardtable (i), 1, 6));
			end;
			if i <= gcos_control_tables_$totallen then /* if not implemented, complain */
			     if i > gcos_control_tables_$tablelen then do;
				unimp_sw = "1"b;	/* remember it */
				if ^gcos_ext_stat_$save_data.brief then do; /* print warning unless told to be quiet */
				     err_msg = "unimplemented control card read from ^a:^/" || ascii_card;
				     call com_err_ (0, "gcos", err_msg, current_file.pathname);
				end;
			     end;

/* see if it is an activity card */
			if i >= gcos_control_tables_$exc_offset then
						/* if it's not before the first activity card in the table */
			     if i < gcos_control_tables_$nonact then do; /* and it's not after the last one */
						/* then it must be an activity card */

				act_no = act_no + 1; /* count activity cards */
						/* and complain if too many   */
				if act_no > gcos_ext_stat_$max_activities then
				     call gcos_error_ (
				     gcos_et_$too_many_activs
				     , "Maximum number of activities allowed is ^d."
				     , gcos_ext_stat_$max_activities
				     );

/* locate info table entry for this activity */
				act_ptr = addr (gcos_control_tables_$activity_table); /* start of table */
				act_ptr = addrel (act_ptr, (i-gcos_control_tables_$exc_offset)*3);

/* pick up nondollar canonicalization index for this activity */
				nondollar_canon_index = act_table_entry.canon_index;

/* if execute card, remember to turn on PSW bit 5 for all preceeding activities */

				if card_type = "execut" | card_type = "355sim" then
				     save_data.last_execute_act_no = act_no;

			     end;

			if card_type = "msg1" then	/* print msg1 card in pass1 */
			     call ioa_ ("^a", substr (ascii_card, 8, 73));

job_stream_write:		call write_job_stream (ascii_ptr, ascii_len+1);
		     end;

print_before_etc:					/* come here to print card before reading $ ETC following */


/* TO KEEP $ SELECT CARDS OFF THE EXECUTION REPORT, MOVE THE ABOVE END STATEMEMNT
   DOWN PAST THE CODE THAT WRITES ON THE EXECUTION REPORT */

/* The following logic puts a $ in column 2 of any dollar cards that were
   in $ SELECTed files. For the case of selected bcd files, we must make a
   copy of the bcd image before inserting the $, since otherwise we would
   be attempting to write into the input file itself, and we probably do
   not have write permission on it. */

		     overlay_ptr = gcos_ptr;		/* point to image to be written on execution report */
		     if stack_level > 1 then do;	/* if card is from a select file */
						/* it needs a double dollar sign */
			if gcos_ptr ^= addr (bcd_work_area) then do; /* bcd file. can't write into it */
			     overlay_ptr = addr (bcd_work_area); /* get pointer to our work area */
			     overlay_ptr -> bcd_card_overlay = gcos_ptr -> bcd_card_overlay; /* move card into it */
			     gcos_ptr = overlay_ptr;	/* make it the working copy */
			     bcd_card_ptr = addrel (gcos_ptr, 1);
			end;

			bcd_card.column (2) = bcd_dollar; /* put $ in column 2 */
			substr (ascii_card, 2, 1) = "$"; /* put it in ASCII copy, also */
		     end;

		     if i >= gcos_control_tables_$exc_offset & i < gcos_control_tables_$nonact then act_flag = "a";
		     else act_flag = " ";
		     gcos_ext_stat_$card_num = mod (card_count, 10000);
		     call ioa_$rs ("^a ^1a^a", rtn_string, rtn_string_len, gcos_ext_stat_$card_num, act_flag, substr (ascii_card_record_overlay, 5));
		     if ^gcos_ext_stat_$save_data.debug then ioa_string = translate (ioa_string, UPPER_CASE, LOWER_CASE);
		     call gcos_write_$ascii_ptr (gcos_ext_stat_$er, ioa_string, "11111100"b);

		     if stack_level > 1 then do;	/* if from a select file */
			bcd_card.column (2) = bcd_blank; /* wipe out the extra dollar sign */
			substr (ascii_card, 2, 1) = " "; /* in both copies */
		     end;


/*	END OF WRITE EXECUTION REPORT CODING. MOVE THAT END STATEMENT HERE */

		     if dbs_dollar then		/* FOR DEBUGGING */
			call ioa_ (ascii_card);

end_process_dollar_card: ;
		end;


/*   for all cards (dollar or not) except $ SELECT cards, write the bcd (or binary) image on the job stream file */

		if ^select_card then
		     call write_job_stream (gcos_ptr, gcos_len + 1);

		if dbs_nondollar then		/*      FOR DEBUGGING     */
		     if ^dollar_sw			/* if this was a nondollar card */
		     then call ioa_ (ascii_card);	/* print it */
						/* NOTE that read_current_file checks the dbs_nondollar, and
						   gives us the ascii image of nondollar cards, if we need them */

		if etc_next_sw then goto etc_label;	/* return to read $ ETC card, if one is expected */
						/* NOTE: for etc after select cards, the select_card
						   switch stays on, and the etc card does not get
						   written on the job stream file */


	     end;
	end;
%page;
/*  fall thru when we hit eof on main input segment */
/* see if job ended in $ ENDJOB card */

	if card_type ^= "endjob" then
	     do;					/* generate endjob card if needed */

	     ascii_card = "$      endjob                *** GENERATED BY GCOS ***";

	     gcos_ptr = addr (bcd_work_area);		/* set up to get bcd image of it */
	     bcd_card_ptr = addrel (gcos_ptr, 1);
	     gcos_len = 14;


	     call get_bcd;				/* entry point in read_current_file,
						   just after reading ascii line */

	     goto process_card;			/* in main loop, just after call to read_current_file */

	end;

/* print card count on execution report */


	call ioa_$rsnnl ("^2xTotal card count this job = ^6d", err_path, i, card_count);
						/* length of returned string must be multiple of 4 */
	err_num = i + 1;				/* err_num = index of first vacant char in string */
						/* it must be the first character in a word */

	if selected_card_count > 0 then do;
	     overlay_ptr = addr (addr (err_path) -> char_addrel (i)); /* get ptr to first vacant character */
						/* ptr may not have a char offset -
						   ioa_$rsnnl wants an aligned string */
	     call ioa_$rsnnl ("  (including ^d from selected files)",
		bcd_card_overlay,			/* convenient based char string, for return arg */
		i, selected_card_count);
	     err_num = err_num + i;			/* err_num = index of first vacant char in extended line */
	end;

	unspec (substr (err_path, err_num, 4)) = (4)"012"b3; /* append 4 newlines */
						/* (skip 3 lines after message) */

	err_num = err_num + 3;			/* now, err_num is the exact length of the message */

	call gcos_write_$ptr (gcos_ext_stat_$er, substr (err_path, 1, err_num), "11111100"b);


	if unimp_sw then
	     if ^gcos_ext_stat_$save_data.continue then do;
		if gcos_ext_stat_$save_data.debug then do;
		     query_info.yes_or_no_sw = "1"b;
		     call command_query_ (addr (query_info), answer, "gcos",
			"unimplemented control cards have been found; do you wish to continue?");
		     if answer = "yes" then goto unimp_continue;
		end;
		call gcos_error_ (0, "unimplemented control cards have been used in this job");
	     end;

unimp_continue: ;

/* detach job stream file, see if it grew to a msf, and "open" it for reading
   in the appropriate way */

/*	WRITE EOF RECORD ON IT FIRST */

	call write_job_stream (addr (eof_rcw), 1);

	js_io_sw = "1"b;				/* in case of io error, print pathname of job stream file */

	call ios_$detach ("gcos_job_stream_", "", "", status);
	if code ^= 0 then do;
detach_err:    err_msg = "from ios_$detach ^a";

/* ALL-PURPOSE ERROR MESSAGE PRINTER */

file_error:    if restartsw then do;
		a_code = code;
		return;
	     end;
	     if js_io_sw then err_path = js_path;
	     else err_path = current_file.pathname;
	     call gcos_error_ (code, err_msg, err_path, err_num); /* job will be aborted, and not return */
	end;

restart_join:
	dirname = gcos_ext_stat_$save_dir;
	ename = gcos_ext_stat_$job_id || ".job_deck";
	call hcs_$status_minf (dirname, ename, chase, type, bit_count, code);

	if code ^= 0 then do;
status_minf_err: err_msg = "from hcs_$status_minf ^a";
	     goto file_error;
	end;

	if type = 2				/* if it grew to a msf */
	|dbs_msf_test then do;			/* or we just want to test the msf logic */
	     call ios_$attach ("gcos_job_stream_", "file_", js_path, "r", status);
	     if code ^= 0 then do;
attach_r_err:	err_msg = "from ios_$attach ^a r";
		goto file_error;
	     end;

	     call ios_$setsize ("gcos_job_stream_", 36, status);
	     if code ^= 0 then goto setsize_err;


	     save_data.job_deck = null;		/* tell rest of gcos it's not a segment */
	end;
	else
	if type = 1 then do;			/* or if it's a segment */
						/* initiate it, for faster reading than if it were a msf */

	     call hcs_$initiate_count (dirname, ename, "", bit_count, 0, save_data.job_deck, code);

	     if save_data.job_deck = null then do;
initiate_err:	err_msg = "from hcs_$initiate_count ^a";
		goto file_error;
	     end;

	     save_data.jd_size = divide (bit_count, 36, 24, 0); /* size in words!!! */


	end;
	else do;					/* bad type code */
type_error:    code = 0;
	     err_num = type;
	     err_msg = "bad type code from hcs_$status_minf for ^a: ^d";
	     goto file_error;
	end;
	call gcos_read_card_$read_init (restartsw);
	return;

job_stream_restart: entry (a_code);

	write_buffer_ptr = addr (write_buffer);
/*	status_ptr = addr (status); */
	restartsw = "1"b;
	a_code = 0;
	js_path = gcos_ext_stat_$save_dir || ">" || gcos_ext_stat_$job_id || ".job_deck";
	go to restart_join;

/*  END OF MAIN PROCEDURE. DEBUGGING ENTRIES AND INTERNAL PROCEDURES FOLLOW     */
%page;
%include gcos_canonicalizer;
%page;
interpret_select_card: proc;

dcl  ca                       char (1) aligned;
dcl  path_type                fixed bin(24) init (0);
dcl  prmfl_path               char (250) varying init ("")	/* file string is 233 chars max - use 250 to be safe */;

pick_up_pathname:					/* come here to scan etc cards, too */
	     etc_next_sw = "0"b;			/* off unless we find that path is not complete on this card */

	     i = index (substr (ascii_card, 16, 57), " "); /* find end of pathname */
	     if i = 0 then
		i = 58;				/* it gets decremented below */
	     if i = 1 then do;
		code = 0;
		err_msg = "no file given on select card from ^a:^/" || ascii_card;
		goto file_error;
	     end;

	     i = i - 1;				/* get rid of trailing blank */

/* check for possible continuation onto etc card */

	     ca = substr (ascii_card, i+15, 1);		/* pick up last nonblank character */

	     if ca = ">" then do;
		etc_next_sw = "1"b;
		path_type = 1;			/* must be Multics pathname */
	     end;

	     else
	     if ca = "/" then do;
		etc_next_sw = "1"b;
		path_type = 2;			/* must be GCOS file string */
	     end;

	     prmfl_path = prmfl_path || substr (ascii_card, 16, i); /* pick up path from this card */

/* if path is continued, finish processing this card, and then go get the etc card */

	     if etc_next_sw then do;
		etc_label = select_etc;		/* remember where to return */
		goto print_before_etc;		/* go print on execution report */
select_etc:					/* return here */
		dollar_sw = "0"b;
		call read_current_file;		/* read etc card */
		if dollar_sw then			/* it better be an etc card ... */
		     if card_type = "etc" then goto pick_up_pathname; /* go get rest of path */

/* error if we fall thru - it was not an etc card */
		code = 0;
		err_msg = "expected etc card missing following:^/$      select  " || prmfl_path;
		goto file_error;
	     end;

/* now we have the whole thing - do we know its type (pathname or file string) */

	     if path_type = 0 then do;		/* we don't, so figure it out */
		j = index (prmfl_path, "/");		/* a file string must have at least one "/" */
		if j = 0 then			/* if it doesn't */
		     path_type = 1;			/* it has to be a Multics pathname */
		else do;				/* it has a "/" - could still be a pathname */
		     j = index (prmfl_path, ">");	/* does it have a ">" */
		     if j = 0 then			/* if it doesn't */
			path_type = 2;		/* assume a GCOS file string */
		     else				/* but if it does, Multics is going to interpret it as a
						   separator, even if someone made up a GCOS file string
						   containing a ">" in one of its catalog names or the file
						   name, so we could not process it as a file string anyway */
		     path_type = 1;
		end;
	     end;

	     if path_type = 2 then
		call gcos_interpret_file_string_ (prmfl_path, select_path, select_path_len, ascii_card);
	     else do;
		select_path = prmfl_path;
		select_path_len = length (prmfl_path);
	     end;

/* note that value of i (length of path field on this card) has been preserved */
/* look for -ascii and -nocan in comments field */

	     i = i + 17;				/* move i to first char of comment field */

	     j = index (substr (ascii_card, i), "-ascii"); /* search whole card image after pathname */
						/* i.e. allow -ascii and -no to run past col 72 */
	     if j ^= 0 then ascii_sw = "1"b;
	     else ascii_sw = "0"b;

	     if ascii_sw then do;
		j = index (substr (ascii_card, i), "-no"); /* too many ways to spell "no canonicalize..." */
		if j = 0 then canon_sw = "1"b;
		else canon_sw = "0"b;
	     end;

	     return;
	end interpret_select_card;
%page;
pass1_cleanup: proc;				/* cleanup handler */

	     do i = stack_level to 1 by -1;
		current_pointer = stacked_pointers (i);
		if i <= hbound (stacked_pointers, 1) then /* avoid freeing nonexistent stuff */
		     if current_pointer ^= null then do;
			if current_file.msf then
			     call ios_$detach (current_file.stream, "", "", status);
						/* ignore errors */
			else
			if current_file.init_ptr ^= null then
			     call hcs_$terminate_noname (current_file.init_ptr, code);

/* be sure the pointer points into free area */
			if baseno (current_pointer) = baseno (gcos_ext_stat_$system_free_pointer) then
			     free current_file in (system_free_area);
		     end;
	     end;
	     call ios_$detach ("gcos_job_stream_", "", "", status);
	end pass1_cleanup;
%page;

read_current_file: proc;

						/* come here to read next line,
						   if this one is null (i.e., just a newline) */
	     if current_file.eof then			/* if no more blocks in file */
		if current_file.eob then do;		/* and no more lines in this block */
		     eof_sw = "1"b;			/* tell caller */
		     return;			/* and return */
		end;

	     if current_file.ascii then do;		/* Read an ascii file. */
		if current_file.msf then do;		/* Read an ascii msf. */

/* Ascii file not blocked. Read 1 line into buffer. Element size is 9 bits (one
   ascii character). Delimiter is ascii newline character). Read up to 1280
   characters only because the buffer holds that many. There must be a newline
   long before that, if it is a legal line */

		     call ios_$read (current_file.stream, buffer_ptr, 0, 1280, chars_read, status);

		     if code ^= 0 then do;
read_err:			err_msg = "from ios_$read ^a";
show_where:		err_msg = err_msg || " (after card ^d of job)";
			err_num = card_count;
			goto file_error;
		     end;

		     current_file.eof = substr (unspec (status), 46, 1); /* pick up eof switch from ios */
		end;
		else do;				/* Read an ascii segment: current file is segment */
						/* simulate ios_$read by moving buffer pointer ahead
						   to next line, and setting chars_read to length of it */

		     buffer_ptr = current_file.read_ptr; /* read_ptr was saved last time thru here */
		     chars_read = index (current_segment, ascii_newline); /* current_segment is based on read_ptr, so
						   it includes only lines we haven't read yet */
		     if chars_read = 0		/* if no newline found */
		     |chars_read >1280		/* or if it was a long way off */
		     then chars_read = 1280;		/* ios_$read would have returned 1280 chars */

		     if chars_read > current_file.remaining_len /* but if there are not 1280 chars left */
		     then chars_read = current_file.remaining_len; /* ios_$read would have returned what was left */

		     current_file.remaining_len = current_file.remaining_len - chars_read;
						/* decrement remaining length */

		     if current_file.remaining_len = 0 then current_file.eof = "1"b;
						/* if none left, give eof on NEXT call */

		     current_file.read_ptr = addr (buffer_ptr -> char_addrel (chars_read+1));
						/* do addrel in terms of characters */
						/* to get pointer to next line, for use in next call */

		end;

		if chars_read = 0 then do;
		     code = 0;
		     err_msg = "zero chars read from ^a";
		     goto show_where;
		end;

		if chars_read = 1280 then
		     if substr (char_buffer, 1280, 1) ^= ascii_newline then do;
			code = 0;
			err_msg = "no newline for 1280 characters in ^a";
			goto show_where;
		     end;

		if current_file.needs_canonicalization then
		     call canonicalizer (buffer_ptr, chars_read, ascii_card_ptr, 80);
		else do;
						/* check for long lines, wipe out newline,
						   copy line to output card buffer */
		     if chars_read <= 81 then chars_read = chars_read - 1; /* wipe out newline */
		     else do;			/* line is too long */
			if gcos_ext_stat_$save_data.truncate then /* if user said -truncate */
			     chars_read = 80;	/* just ignore the extras */
			else do;			/* other wise complain */
			     code = 0;
			     err_num = chars_read;
			     err_msg = "line from ^a is too long (^d characters)^/" || char_buffer;
			     if ^gcos_ext_stat_$save_data.continue then /* this is a nonfatal error */
				goto file_error;
			     if ^gcos_ext_stat_$save_data.brief then /* complain unless told to be quiet */
				call ioa_ (err_msg, current_file.pathname, err_num);
			end;
		     end;
		     ascii_card = char_buffer;	/* this statement SHOULD blank out the tail end of ascii_card */
		end;

/* get bcd image of card */

get_bcd:		entry;				/* place to enter if creating an endjob card */

		call gcos_cv_ascii_gebcd_check_ (ascii_card_ptr, 84, bcd_card_ptr, i);
		if i ^= 0 then do;
		     code = 0;
		     err_num = i;
		     err_msg = "line from ^a contains an illegal character in col. ^d^/" || char_buffer;
		     go to file_error;
		end;

		gcos_record.rcw = bcd_rcw;		/* put standard rcw in front of bcd card */
		if substr (ascii_card, 1, 2) = "$" then do;
		     dollar_sw = "1"b;		/* tell caller about dollar card */
		     card_type = substr (ascii_card, 8, 6); /* and give him its type */
		end;
	     end;

/* IF WE READ AN ASCII FILE, CONTROL SKIPS OVER THE read_gcos_file BLOCK FOLLOWING, AND RETURNS */
	     else do;				/* current file is in gcos format */
		if current_file.eob then do;		/* do we need another block?  */
		     if current_file.msf then do;
			call ios_$read (current_file.stream, buffer_ptr, 0, 320, words_read, status);
			if code ^= 0 then goto read_err;
			current_file.eof = substr (unspec (status), 46, 1); /* pick up eof switch from ios_$read */

			if ^current_file.eof then	/* in the unlikely event that the eof switch is NOT on */
			     if words_read < 320 then do; /* when we get a short block */
				code = 0;		/* complain about it */
				err_num = words_read;
				err_msg = "block from ^a contained only ^d words";
				goto file_error;
			     end;
		     end;
		     else do;			/* current file is a segment */
						/* simulate ios_$read by moving pointer */

			buffer_ptr = current_file.read_ptr;
			words_read = min (320, current_file.remaining_len);

			current_file.remaining_len = current_file.remaining_len - words_read;

			if current_file.remaining_len = 0 then current_file.eof = "1"b;
						/* remember to return eof NEXT get block call */

			current_file.read_ptr = addrel (current_file.read_ptr, words_read);
						/* get pointer to next block, for use in next call */
		     end;

/* now get first record in block */

		     current_file.remaining_block_len = fixed (buffer_ptr -> bcw.length);

		     if current_file.remaining_block_len > 319 /* if block length too long (probably garbage) */
		     | current_file.remaining_block_len < 1 /* or too short (probably all zeros) */
		     then do;			/* then complain */
			code = 0;
			err_num = current_file.remaining_block_len;
			err_msg = "illegal block length in bcw from ^a: ^d words";
			goto file_error;
		     end;

		     gcos_ptr, current_file.record_ptr = addrel (buffer_ptr, 1);
		     current_file.eob = "0"b;		/* don't get another block 'til this one used up */
		end;
		else				/* just get next record in current block */
		gcos_ptr, current_file.record_ptr =
		     addrel (current_file.record_ptr, fixed (current_file.record_ptr -> rcw.length) + 1);
						/* move pointer past LAST record, to THIS one;
						   +1 because rcw.length does not include the rcw itself */

/*   COMMON CODE FOR NEW BLOCK OR JUST NEXT RECORD */
		if gcos_ptr -> rcw.eof = bcd_eof then do; /* if this is an eof record */
		     eof_sw = "1"b;			/* return EOF THIS call */
		     current_file.eob, current_file.eof = "1"b; /* in case anyone looks */
		     return;
		end;
		bcd_card_ptr = addrel (gcos_ptr, 1);	/* get pointer to data words in record */

		gcos_len = fixed (gcos_ptr -> rcw.length); /* get length of THIS record */

		current_file.remaining_block_len = current_file.remaining_block_len - gcos_len -1;
						/* -1 since gcos_len does not include the rcw */

		if current_file.remaining_block_len < 0 then do; /* should never happen. program bug if it does */
		     call gcos_error_ (0, "pass1-get next record: block len < 0");
		end;

		if current_file.remaining_block_len = 0 then current_file.eob = "1"b;
						/* remember to get block NEXT call */

		if gcos_ptr -> rcw.media_code = "0010"b
		| gcos_ptr -> rcw.media_code = "0011"b
		| gcos_ptr -> rcw.media_code = "0111"b
		& gcos_ext_stat_$save_data.gtssflag then do;

		     if bcd_card.column (1) = bcd_dollar then /* is it a dollar card ?   */
			if bcd_card.column (2) = bcd_blank then dollar_sw = "1"b;

		     if gcos_len > 14 then do;
			call ioa_ ("gcos_gein_pass1_ bcd card > 14 words; using first 14");
			gcos_len = 14;
		     end;

		     if dollar_sw			/* if this is a dollar card */
		     |dbs_nondollar then do;		/* or we are tracing nondollar cards */
			ascii_card = "";		/* blank out card; gcos_cv_gebcd_ascii_ does not blank it */
			call gcos_cv_gebcd_ascii_ (bcd_card_ptr, min (80, gcos_len*6), ascii_card_ptr);
		     end;

		     if dollar_sw then		/* return type of dollar card */
			card_type = substr (ascii_card, 8, 6);
		end;

		else
		if gcos_ptr -> rcw.media_code = "0001"b then do; /* if binary card */
		     if dbs_nondollar then ascii_card = "..... binary card .....";
						/* give them something to print in trace */
		end;
		else do;				/* media code not bcd or binary */
		     code = 0;
		     err_num = fixed (gcos_ptr -> rcw.media_code); /* show the code */
		     err_msg = "bad media code in record from ^a: ^d";
		     goto file_error;
		end;
	     end;
	     return;
	end read_current_file;
%page;
stack_selected_file: proc;

	     stack_level = stack_level + 1;		/* increment stack level */

	     if stack_level > hbound (stacked_pointers, 1) then do;
		code = 0;
		err_num = stack_level;
		err_msg = "too many nested $ SELECT cards; ^a contains the ^dth";
		goto file_error;
	     end;

	     allocate current_file
		in (system_free_area)
		set (stacked_pointers (stack_level));
	     current_pointer = stacked_pointers (stack_level);
	     current_file.init_ptr = null;
	     current_file.pathname = select_path;
	     current_file.ascii = ascii_sw;
	     current_file.needs_canonicalization = canon_sw;
	     current_file.eof = "0"b;
	     current_file.eob = "1"b;			/* to get a new block on first call to read */

	     if ascii_sw then do;
		gcos_ptr = addr (bcd_work_area);
		bcd_card_ptr = addrel (gcos_ptr, 1);
		gcos_len = 14;
	     end;
						/* gcos file initialization done below:
						   different for seg and msf */
	     call expand_path_ (addr (select_path), select_path_len, addr (dirname), addr (ename), code);
	     if code ^= 0 then do;
		err_msg = "from expand_path_ ^a";
		goto file_error;
	     end;

	     current_file.pathname = rtrim (dirname)||">"||rtrim (ename);
	     call hcs_$status_minf (dirname, ename, chase, type, bit_count, code);
	     if code ^= 0 then goto status_minf_err;

	     if type = 2				/* if it it is a directory (msf, we hope) */
	     | dbs_msf_test then do;			/* or if we want to test msf logic with a small job */

		if bit_count = 0 then do;		/* zero bit count => directory, not msf */
		     code = 0;
		     err_msg = "attempt to $ SELECT a directory: ^a";
		     goto file_error;
		end;

		current_file.msf = "1"b;
		current_file.stream = "select";
						/* convert stack level to characters, and append to "select" */
		i = stack_level;
		if i > 9 then i = divide (i, 10, 24, 0);
		substr (current_file.stream, 7, 1) = substr ("123456789", i, 1);
		if stack_level > 9 then
		     substr (current_file.stream, 8, 1) = substr ("0123456789", 1+mod (stack_level, 10), 1);
						/* this is better than a call to arith_to_char_ ??? */

		call ios_$attach (current_file.stream, "file_", current_file.pathname, "r", status);

		if code ^= 0 then goto attach_r_err;

		buffer_ptr = addr (current_file.buffer);

		if ^ascii_sw then do;
						/* initializations needed for gcos format msf */
		     call ios_$setsize (current_file.stream, 36, status); /* set element size to 36 (one word)
						   and delimiter to "none" (by changing element size without
						   defining a new delimiter */
		     if code ^= 0 then goto setsize_err;
		end;

/* for an ascii file, the file dim defaults are used:
   -	element size = 9 (one ascii character)
   -	delimiter is ascii newline character. */

	     end;
	     else
	     if type = 1 then do;			/* or if it's a segment */

		current_file.msf = "0"b;
		call hcs_$initiate_count (dirname, ename, "", bit_count, 0, current_file.init_ptr, code);
		if current_file.init_ptr = null then goto initiate_err;

		if bit_count = 0 then do;

		     code = 0;
		     err_msg = "zero length file $ SELECTed: ^a";
		     goto file_error;
		end;

		if ascii_sw then do;		/* initializations needed for ascii segments */
		     current_file.init_len = divide (bit_count, 9, 24, 0); /* length in characters */
		end;
		else do;				/* initializations for gcos format segment */
		     current_file.init_len = divide (bit_count, 36, 24, 0); /* length in words */
		end;

/* for both ascii and gcos segments:     */

		current_file.read_ptr = current_file.init_ptr; /* next block = first block */
		current_file.remaining_len = current_file.init_len;
	     end;
	     else goto type_error;			/* if bad type code from hcs_$status_minf */
	     return;
	end stack_selected_file;
%page;
unstack_current_file: proc;

	     if current_file.msf then do;
		call ios_$detach (current_file.stream, "", "", status);
		if code ^= 0 then goto detach_err;
	     end;
	     else do;
		call hcs_$terminate_noname (current_file.init_ptr, code);
		if code ^= 0 then do;
		     err_msg = "from hcs_$terminate_noname ^a";
		     goto file_error;
		end;
	     end;
	     free current_file in (system_free_area);
	     stacked_pointers (stack_level) = null;	/* the free nulled current_pointer only */
	     stack_level = stack_level -1;

	     if stack_level > 0 then do;		/* if there's a file to resume reading */
						/* then set up for reading it, where we left off */
		current_pointer = stacked_pointers (stack_level); /* get pointer to info for it */

		if current_file.ascii then do;	/* re-do some initializations that were not preserved */
		     gcos_ptr = addr (bcd_work_area);
		     bcd_card_ptr = addrel (gcos_ptr, 1);
		     gcos_len = 14;
		end;
		if current_file.msf then buffer_ptr = addr (current_file.buffer);
	     end;
	     return;
	end unstack_current_file;
%page;
write_job_stream: proc (word_ptr, word_count);

dcl  word_count               fixed bin(24);
dcl  word_ptr                 ptr;
	     if word_count > 319 then do;		/* if record bigger than block, complain */
		code = 0;
		err_num = word_count;		/* tell them how big it is */
		err_msg = "record to be written on ^a is too long: ^d words";
		js_io_sw = "1"b;			/* print job stream file in error message */
		goto file_error;
	     end;

	     if word_count > remaining_output_words then do; /* if no room in block for this record */
write_block:					/* write the block */
		call ios_$write ("gcos_job_stream_", write_buffer_ptr, 0, 320, words_written, status);
		if code ^= 0 then do;		/* if any problem, complain */
		     err_msg = "from ios_$write ^a";
		     js_io_sw = "1"b;
		     goto file_error;
		end;

		if words_written ^= 320 then do;	/* if whole block not written, complain */
		     code = 0;
		     err_num = words_written;
		     err_msg = "wrong number of words written on ^a: ^d";
		     js_io_sw = "1"b;
		     goto file_error;
		end;

/* set block to empty */
		remaining_output_words = 319;
		output_word_ptr = addrel (write_buffer_ptr, 1);
		write_buffer_ptr -> bcw.bsn = bit (fixed (fixed (write_buffer_ptr -> bcw.bsn)+1, 18));
						/* bsn = bsn + 1 */
		write_buffer_ptr -> bcw.length = (18)"0"b; /* length = 0 */

	     end;

	     if last_block then return;		/* if we just wrote out the last block, return */

/* append record to block   */
	     write_buffer_ptr -> bcw.length = bit (fixed (fixed (write_buffer_ptr -> bcw.length) + word_count, 18));
						/* length = length + word_count */
	     output_word_ptr -> words = word_ptr -> words; /* move record to write buffer */
	     output_word_ptr = addrel (output_word_ptr, word_count); /* advance pointer in buffer */
	     remaining_output_words = remaining_output_words - word_count;

	     if word_count = 1 then do;		/* one word record can only be an eof record */
		last_block = "1"b;			/* remember to quit after writing */
		goto write_block;			/* and go write the block out */
	     end;
	     return;

dcl  last_block               bit (1) aligned init ("0"b)	/* used only when writing out final block */;
dcl  words                    (word_count) bit (36) based;
	end write_job_stream;
%page;
/*   Variables for gcos_gein_pass1_:		 */
/*   IDENTIFIER		ATTRIBUTES	 */
dcl  act_ptr                  ptr;
dcl  ascii_card               char (80) aligned based (ascii_card_ptr)   /* overlay for one line from an ascii file (segment or msf)  */;
dcl  ascii_card_ptr           ptr	/* init(addrel(ascii_ptr,1)) */;
dcl  ascii_card_record_overlay char (84) aligned based (ascii_ptr)	/* char overlay for ascii record, for gcos_write_$record */;
dcl  ascii_len                fixed bin(24);
dcl  ascii_ptr                ptr	/* init(addr(ascii_work_area)) */;
dcl  ascii_report_card        char (85) aligned based (ascii_card_ptr)	/* to write on execution report. char 85 is nl */;
dcl  ascii_work_area          (23) bit (36) aligned;
dcl  a_code                   fixed bin(35)	/* used by restart entry */;
dcl  bcd_card_overlay         char (60) aligned based (overlay_ptr)	/* to send 15 word gcos record to gcos_write */;
dcl  bcd_card_ptr             ptr	/* always = addrel(gcos_ptr,1) */;
dcl  bcd_work_area            (15) bit (36) aligned;
dcl  buffer_ptr               ptr;
dcl  chars_read               fixed bin(21);
dcl  char_addrel              (1280) char (1) based	/* to do addrel in terms of characters */;
dcl  char_buffer              char (chars_read) based (buffer_ptr);
dcl  command_query_           ext entry options (variable);
dcl  com_err_                 ext entry options (variable);
dcl  current_pointer          ptr init (null) /* pointer to info structure for file currently being read, (equal to stacked_pointers(stack_level) */;
dcl  current_segment          char (current_file.remaining_len) based (current_file.read_ptr);
dcl  err_msg                  char (200) varying;
dcl  err_num                  fixed bin(24);
dcl  err_path                 char (200);
dcl  expand_path_             ext entry (ptr, fixed bin(24), ptr, ptr, fixed bin(35));
dcl  gcos_cv_ascii_gebcd_check_ ext entry (ptr, fixed bin(24), ptr, fixed bin(24));
dcl  gcos_cv_gebcd_ascii_     ext entry (ptr, fixed bin(24), ptr);
dcl  gcos_error_              ext entry options (variable);
dcl  gcos_et_$cc_bad_field    fixed bin(35) ext;
dcl  gcos_et_$too_many_activs fixed bin(35) ext;
dcl  gcos_interpret_file_string_ entry (char (*) varying, char (*), fixed bin(24), char (80) aligned);
dcl  gcos_len                 fixed bin(24);
dcl  gcos_ptr                 ptr	/* NOT always = addr(bcd_work_area) - just sometimes */;
dcl  gcos_read_card_$read_init ext entry (bit (1) aligned);
dcl  gcos_write_$ascii_ptr    entry (ptr, char (*) aligned, bit (8));
dcl  gcos_write_$ptr          ext entry (ptr, char (*) aligned, bit (8));
dcl  gcos_write_$record_ptr   ext entry (ptr, char (*) aligned, bit (8));
dcl  hcs_$initiate_count      ext entry (char (*), char (*), char (*), fixed bin(24), fixed bin(24), ptr, fixed bin(35));
dcl  hcs_$status_minf         ext entry (char (*), char (*), fixed bin(1), fixed bin(2), fixed bin(24), fixed bin(35));
dcl  hcs_$terminate_noname    ext entry (ptr, fixed bin(35));
dcl  ioa_                     ext entry options (variable);
dcl  ioa_$rs                  ext entry options (variable);
dcl  ioa_$rsnnl               ext entry options (variable);
dcl  output_word_ptr          ptr;
dcl  overlay_ptr              ptr;
dcl  remaining_output_words   fixed bin(24);
dcl  rtrim                    builtin;
dcl  SP                       char(1)static int options(constant)init(" ");
dcl  stacked_pointers         (11) ptr init ((11)null)	/* pointers to info structure for the open files */;
dcl  stack_level              fixed bin(24)	/* number of input files currently "open"  */;
dcl  system_free_area         area based (gcos_ext_stat_$system_free_pointer)	/* area to allocate things in   */;
dcl  unspec                   builtin;
dcl  words_read               fixed bin(21);
dcl  words_written            fixed bin(21);
dcl  write_buffer             (320) bit (36) aligned;
dcl  write_buffer_ptr         ptr ;

dcl  act_flag                 char (1);
dcl  act_no                   fixed bin(24);
dcl  addr                     builtin;
dcl  addrel                   builtin;
dcl  answer                   char (4) varying;
dcl  ascii_backspace          char (1) int static init ("");
dcl  ascii_rcw                bit (36) aligned int static init ("000024000600"b3);
dcl  baseno                   builtin;
dcl  bcd_blank                bit (6) unaligned int static init ("20"b3);
dcl  bcd_dollar               bit (6) unaligned int static init ("53"b3);
dcl  bcd_eof                  bit (6) unaligned int static init ("17"b3);
dcl  bcd_newline_record       bit (72) aligned int static init ("0000010003747701"b3);
dcl  bcd_newline_record_overlay char (8) aligned based (addr (bcd_newline_record));
dcl  bcd_number_sign          bit (6) unaligned int static init ("13"b3);
dcl  bcd_rcw                  bit (36) aligned int static init ("000016000200"b3);
dcl  bit                      builtin;
dcl  bit_count                fixed bin(24);
dcl  card_count               fixed bin(24)init(0);
dcl  card_type                char (6);
dcl  chase                    fixed bin(1) init (1);
dcl  cleanup                  condition;
dcl  dirname                  char (168);
dcl  divide                   builtin;
dcl  ename                    char (32);
dcl  endfc                    char (2)	/* for endfc option of $ data card */;
dcl  eof_rcw                  bit (36) aligned int static init ("000000170000"b3);
dcl  etc_label                label local	/* place to return to after printing card before etc */;
dcl  fixed                    builtin;
dcl  hbound                   builtin;
dcl  i                        fixed bin(24);
dcl  index                    builtin;
dcl  ioa_string               char (rtn_string_len) aligned based (addr (rtn_string));
dcl  j                        fixed bin(24);
dcl  js_path                  char (168);
dcl  length                   builtin;
dcl  LOWER_CASE               char (26) static internal options (constant) init ("abcdefghijklmnopqrstuvwxyz");
dcl  max                      builtin;
dcl  min                      builtin;
dcl  mod                      builtin;
dcl  nondollar_canon_index    fixed bin(24) /* says which tabs to use for nondollar cards, in the current activity */;
dcl  null                     builtin;
dcl  rtn_string               char (256) aligned;
dcl  rtn_string_len           fixed bin(24);
dcl  selected_card_count      fixed bin(24)init(0);
dcl  select_path              char (168);
dcl  select_path_len          fixed bin(24);
dcl  substr                   builtin;
dcl  TAB                      char (1) int static init ("	");
dcl  translate                builtin;
dcl  type                     fixed bin(2);
dcl  UPPER_CASE               char (26) static internal options (constant) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
dcl  VALID_FMS_CHARS          char (38) static internal options (constant) init (".-0123456789abcdefghijklmnopqrstuvwxyz");

dcl  ascii_newline            char (1) int static init ("
");

dcl (						/* switches */
     ascii_sw,					/* on if file to be stacked is ascii */
     canon_sw,					/* on if file being stacked needs canonicalization */
     dollar_sw,					/* on if card read is a dollar card */
     eof_sw,					/* on if attempt to read card got end of file */
     select_card,					/* on if this is a select card */
     unimp_sw,					/* on if any unimplemented card is found in the job */
     copy_sw,					/* on if in a $ DATA ,,COPY deck */
     etc_next_sw,					/* on if next card is expected to be etc */
     js_io_sw,					/* on if doing io on job stream file (selects error message) */
     in_password,					/* on while blanking out password on $ USERID card */
     restartsw					/* on if restart entry called */
     ) bit (1) aligned init ("0"b);

dcl 1 current_file aligned based (current_pointer) /* info structure for open input files
						   new copy allocated each time a $ SELECT card is read,
						   and freed when eof occurs on the $ SELECTed file */

,2 stream		char (8)unal
,2 init_ptr	ptr aligned
,2 init_len	fixed bin(24) aligned
,2 read_ptr	ptr aligned
,2 record_ptr	ptr aligned
,2 remaining_len	fixed bin(35) aligned
,2 remaining_block_len	fixed bin(24) aligned
,2 ascii 		bit (1) aligned
,2 msf 		bit (1) aligned
,2 needs_canonicalization bit (1) aligned
,2 eob 		bit (1) aligned
,2 eof 		bit (1) aligned
,2 pathname	char (200) unal
,2 buffer 	(320) bit 	(36) aligned
;

dcl 1 ascii_record aligned based (ascii_ptr),
    2 rcw bit (36) aligned,
    2 data_words (ascii_len) bit (36) aligned;

dcl 1 bcd_card aligned based (bcd_card_ptr),
    2 column (80) bit (6) unaligned;

dcl 1 gcos_record aligned based (gcos_ptr),
    2 rcw bit 	(36) aligned,
    2 data_words (gcos_len) bit (36) aligned;

dcl 1 bcw aligned based,				/* block control word overlay */
    2 bsn bit (18) unaligned,
    2 length bit (18) unaligned;

dcl 1 rcw aligned based,				/* record control word overlay */
    2 length bit (18) unaligned,
    2 eof bit (6) unaligned,
    2 zeroes bit (2) unaligned,
    2 media_code bit (4) unaligned,
    2 report_code bit (6) unaligned;

dcl 1 act_table_entry based (act_ptr),
    2 fill1 fixed bin(24),
    2 fill2 char (4),
    2 canon_index fixed bin(24);

dcl 1 tabstops	aligned based (addr (gcos_control_tables_$tabstops)),
    2 count	fixed bin(24) aligned,
    2 tab		(0:tabstops.count-1),
      3 stop	(10) fixed bin(24) aligned;
%page;
%include gcos_control_tables_;
%page;
%include query_info;
%page;
%include gcos_ext_stat_;
%page;
%include gcos_dbs_names;
%page;
%include gcos_dcl_ios_;
     end gcos_gein_pass1_;
