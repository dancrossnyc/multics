/* ******************************************************
   *                                                    *
   *                                                    *
   * Copyright (c) 1972 by Massachusetts Institute of   *
   * Technology and Honeywell Information Systems, Inc. *
   *                                                    *
   *                                                    *
   ****************************************************** */

apl_file_system_:
	procedure (operators_argument);

/* Procedure to manage APL component files.
   Written 2/79 by William M. York.
   Modified 790212 by WMY to add entrypoints for untying and unlocking all tied files,
	and to check for code = 0 before calling file_error.
   Modified 790213 by WMY to implement qFLIB.
   Modified 790225 by WMY to make qFLIB free up allocated storage.
   Modified 790225 by WMY to fix bug 397 (value_stack_ptr gets assigned from
	an uninitialized variable).
   Modified 800814 by WMY fix bug 470 (attemtping to open or create a file when
	quota is exhausted leaves the switch attached).
   Modified 820120 by WMY to fix a problem for Renault in which qFHOLD
	returns a not_a_valid_iocb or no_iocb error code.
*/

/* Automatic storage */

dcl share bit (1) aligned;			/* open file for sharing */
dcl create_if_not_found bit(1) aligned;		/* create new files? */
dcl untie_error bit(1) aligned;
dcl flim_not_fsize bit(1) aligned;		/* for common code */
dcl fsetacl_not_faddacl bit(1) aligned;		/* for common code */
dcl switched_one bit(1) aligned;		/* for sorting */

dcl (left_vb, right_vb) ptr;			/* ptrs to arg beads */
dcl (left, right) ptr;			/* ptrs to arg values */
dcl result_vb ptr unaligned;			/* to APL bead */
dcl bead_size fixed bin(21);			/* size of APL value */
dcl size_read fixed bin(21);			/* size of record read */
dcl data_ptr ptr;				/* ptr to data elements */

dcl tie_num fixed;				/* current tie num */
dcl iocb_ptr ptr;				/* current file ptr */
dcl tied_array_idx fixed bin;			/* where to put info */
dcl data_elements fixed bin;			/* number of values in right arg */
dcl component_number fixed bin;
dcl component_key picture "99999999999";	/* for conversion to string */
dcl start_component fixed bin;		/* first component done */
dcl end_component fixed bin;			/* last one done */
dcl drop_number fixed bin;			/* number of components to drop */

dcl file_pathname char(168);			/* file name stuff */
dcl (file_dname, new_dname) char(168);
dcl (file_ename, new_ename) char(32);

dcl user_name char(22);			/* for keeping record of */
dcl user_project char(9);			/*  who wrote what */

dcl (count, idx) fixed bin;			/* random counters */
dcl increment fixed bin;			/* do loop step */
dcl temp_string char(20) varying;		/* scratch string */
dcl info_ptr ptr;				/* for vfile_status_ */

dcl lock_info bit(2) aligned;			/* for set_file_lock */
dcl lock bit(2) init ("10"b);			/* lock file, inhibit writes only */
dcl unlock bit(2) init ("00"b);		/* unlock file */
dcl current_file_locked bit(1) init ("0"b);	/* indicator of locking */

dcl system_area area (261120) based (area_ptr);	/* for acl structure */
dcl area_ptr pointer;			/* for acl hacking */

dcl acl_ptr pointer;
dcl acl_count fixed bin;
dcl mode_string char(4);			/* ACL modes; "rew", etc */
dcl fcb_ptr pointer;			/* for msf_manager_ */

dcl (code, code2) fixed bin(35);		/* status code */

dcl 1 index_info based (info_ptr) like indx_info;

dcl 1 segment_acl (acl_count) aligned based (acl_ptr),
      2 access_name char(32),
      2 modes bit(36),
      2 zero_pad bit(36),
      2 status_code fixed bin(35);

dcl 1 delete_acl (acl_count) aligned based (acl_ptr),
      2 access_name char(32),
      2 status_code fixed bin(35);


dcl uid bit(36);				/* segment unique id */

/* These arrays must be the same dimension as tied_files */

dcl file_uids (100) bit(36);			/* for locking order */
dcl array_idxs (100) fixed bin;		/* for keeping array idxs */

/* Header information at the beginning of each file. */

dcl 1 file_header,				/* info at head of file */
      2 version fixed bin,
      2 first_component fixed bin,
      2 last_component fixed bin;

dcl file_header_version fixed bin init (1);
dcl file_header_size fixed bin (21);
dcl file_header_key char(256) varying init ("APL_file_header");

/* Header information for each component. */

dcl 1 component_header,
      2 size fixed bin,
      2 user_id char(32),
      2 user_number fixed bin,
      2 time fixed bin(71);

dcl component_header_size fixed bin(21);

/* Internal static */

dcl 1 apl_file_system_static static,
      2 number_of_files_tied fixed bin init (0),
      2 first_file_open bit(1) aligned init ("1"b),
      2 group_id char(32),

      2 tied_files (100),
        3 iocb_ptr pointer init ((100) null()),
        3 tie_number fixed bin,
        3 file_name char(168),
        3 shared bit(1),
        3 locked bit(1),
        3 read_only bit(1),
        3 first_component fixed,
        3 last_component fixed;

/* External static */

dcl apl_static_$apl_output ptr static external;

/* Entries */

dcl vfile_status_ entry (char(*), char(*), ptr, fixed bin(35));
dcl hcs_$star_ entry (char (*), char (*), fixed bin (2), ptr, fixed bin, ptr, ptr, fixed bin (35));
dcl hcs_$status_minf entry (char(*),  char(*), fixed bin(1), fixed bin(2), fixed bin(24), fixed bin(35));
dcl hcs_$status_long entry (char(*), char(*), fixed bin(1), ptr, ptr, fixed bin(35));
dcl hcs_$chname_file entry (char(*), char(*), char(*), char(*), fixed bin(35));
dcl msf_manager_$open entry (char(*), char(*), ptr, fixed bin(35));
dcl msf_manager_$acl_list entry (ptr, ptr, ptr, ptr, fixed bin, fixed bin(35));
dcl msf_manager_$acl_replace entry (ptr, ptr, fixed bin, bit(1), fixed bin(35));
dcl msf_manager_$acl_add entry (ptr, ptr, fixed bin, fixed bin(35));
dcl msf_manager_$acl_delete entry (ptr, ptr, fixed bin, fixed bin(35));
dcl msf_manager_$close entry (ptr);
dcl apl_translate_pathname_$file_system_pathname entry (char(*), char(*), char(*), ptr, fixed bin(35));
dcl expand_pathname_ entry (char(*), char(*), char(*), fixed bin(35));
dcl delete_$path entry (char(*), char(*), bit(6), char(*), fixed bin(35));
dcl unique_chars_ entry (bit(*)) returns (char(15));
dcl user_info_$whoami entry (char(*), char(*), char(*));
dcl cv_userid_ entry (char(*)) returns (char(32));
dcl get_system_free_area_ entry returns (ptr);
dcl ioa_$ioa_switch entry options (variable);

/* I/O manipulation routines */

dcl iox_$attach_name entry (char(*), ptr, char(*), ptr, fixed bin(35));
dcl iox_$open entry (ptr, fixed bin, bit(1) aligned, fixed bin(35));
dcl iox_$close entry (ptr, fixed bin(35));
dcl iox_$detach_iocb entry (ptr, fixed bin(35));
dcl iox_$seek_key entry (ptr, char(256) varying, fixed bin(21), fixed bin(35));
dcl iox_$read_record entry (ptr, ptr, fixed bin(21), fixed bin(21), fixed bin (35));
dcl iox_$write_record entry (ptr, ptr, fixed bin(21), fixed bin(35));
dcl iox_$rewrite_record entry (ptr, ptr, fixed bin(21), fixed bin(35));
dcl iox_$delete_record entry (ptr, fixed bin(35));
dcl iox_$control entry (ptr, char(*), ptr, fixed bin(35));

/* Builtins */

dcl (null, addr, addrel, rtrim, substr, index, length, size,
	hbound, lbound, dimension, clock, abs, binary, codeptr,
	currentsize, divide, fixed, floor, ltrim, rel, string,
	sum, verify)
    builtin;

/* Error codes */

dcl (error_table_$noentry,
     error_table_$nomatch,
     error_table_$file_busy,
     error_table_$lock_not_locked,
     error_table_$locked_by_this_process,
     error_table_$moderr,
     error_table_$no_info,
     error_table_$no_operation,
     error_table_$no_record)
    fixed bin(35) external;

dcl (apl_error_table_$domain,
     apl_error_table_$not_within_int_fuzz,
     apl_error_table_$rank,
     apl_error_table_$length,
     apl_error_table_$file_already_tied,
     apl_error_table_$file_already_exists,
     apl_error_table_$no_write_permission,
     apl_error_table_$no_access_to_file,
     apl_error_table_$tie_num_in_use,
     apl_error_table_$no_such_file,
     apl_error_table_$bad_tie_num,
     apl_error_table_$bad_file_name,
     apl_error_table_$bad_fname_match,
     apl_error_table_$bad_component_num,
     apl_error_table_$not_enough_components,
     apl_error_table_$bad_apl_file,
     apl_error_table_$old_file_header,
     apl_error_table_$bad_access_matrix,
     apl_error_table_$bad_access_modes,
     apl_error_table_$too_many_files)
    fixed bin(35) external;

/* Include files */

%include vfs_info;
%include branch_status;
%include star_structures;
%include iox_modes;
%include apl_number_data;
%include apl_ws_info;
%include apl_bead_format;
%include apl_value_bead;
%include apl_operators_argument;

/* All calls to file system functions are made through the main
   procedure, apl_file_system_.  The following transfer vector picks
   the appropriate entry and starts it off. */

	/* Pop argument(s) off stack */

	if operators_argument.operands(2).on_stack
	     then ws_info.value_stack_ptr = operators_argument.operands(2).value;
	     else if operators_argument.operands(1).on_stack
		then ws_info.value_stack_ptr = operators_argument.operands(1).value;

	goto file_operation(operators_argument.op1);

niladic_functions:
	entry (operators_argument);

	goto file_operation(operators_argument.op1);

/* The three entries following all deal with file opening.  They merely
   set some state bits, then call open_file which does all the real work. */

file_operation(75):				/* qFCREATE */

	share = "0"b;			/* exclusive open */
	create_if_not_found = "1"b;		/* create a new file */
	goto decode_args;

file_operation(92):				/* qFTIE */
	share = "0"b;
	create_if_not_found = "0"b;
	goto decode_args;

file_operation(91):				/* qFSTIE */
	share = "1"b;
	create_if_not_found = "0"b;
	goto decode_args;

decode_args:
	call decode_file_id;
	call decode_right_arg (1, 1);

	/* If the maximum number of files are already tied, complain. */

	if number_of_files_tied >= dimension (tied_files, 1)
	     then call file_error (apl_error_table_$too_many_files);

	call open_file (share, create_if_not_found);

	operators_argument.result = null();

error_return:	/* All errors return through here. */
	return;


/* FUNTIE unties (i.e. closes and detaches) all APL files given in its
   right argument, updating the file header information if necessary. */

file_operation(121):			/* qFUNTIE */

	call decode_right_arg (0, -1);		/* allow infinite number */

	/* Check each tie number for validity and untie them. */

	call check_integers (right_vb, code);
	if code ^= 0
	     then call file_error (code);

	untie_error = "0"b;
	do count = 0 to (right_vb -> value_bead.total_data_elements - 1);

	     tie_num = integerize (right -> numeric_datum (count));

	     tied_array_idx = get_tie_index (tie_num, code);

	     if code = 0
		then call untie_file (tied_array_idx, code);

		/* If that number is not tied, go to next.  Any other error
		   is fatal. */

		else if code = apl_error_table_$bad_tie_num
		     then untie_error = "1"b;
		     else call file_error (code);

	end;  /* do for all tie nums */

	if untie_error
	     then call file_error (apl_error_table_$bad_tie_num);

	operators_argument.result = null;
	return;

/* FERASE unties and deletes a file. */

file_operation(78):				/* qFERASE */

	call decode_file_id;
	call decode_right_arg (1, 1);

	/* Find the array index of the specified file. */

	tied_array_idx = get_tie_index (tie_num, code);
	if code ^= 0
	     then call file_error (code);

	/* Get the full pathnames of both the specified file and
	   the file tied to the specified tie number. */

	call expand_pathname_ (file_pathname, new_dname, new_ename, code);
	if code ^= 0
	     then call file_error (code);

	call expand_pathname_ (tied_files(tied_array_idx).file_name, file_dname, file_ename, code);
	if code ^= 0
	     then call file_error (code);

	/* Get unique ids of the file specified by name and the file
	   tied to the specified number. */

	call hcs_$status_long (new_dname, new_ename, 1, addr (branch_status), null (), code);	
	if code ^= 0
	     then call file_error (code);

	uid = branch_status.unique_id;

	call hcs_$status_long (file_dname, file_ename, 1, addr (branch_status), null (), code);
	if code ^= 0
	     then call file_error (code);

	if branch_status.unique_id ^= uid
	     then call file_error (apl_error_table_$bad_fname_match);

	call untie_file (tied_array_idx, code);

	call delete_$path (file_dname, file_ename, "000100"b, "apl", code);
	if code ^= 0
	     then call file_error (code);

	operators_argument.result = null();
	return; /* from ferase */


/* FRENAME changes the filename of a tied APL file. */

file_operation(87):				/* qFRENAME */

	call decode_file_id;
	call decode_right_arg (1, 1);

	tied_array_idx = get_tie_index (tie_num, code);
	if code ^= 0
	     then call file_error (code);

	/* Get the full pathnames of both the given filename and the
	   filename of the file tied to the given number. */

	call expand_pathname_ (tied_files(tied_array_idx).file_name, file_dname, file_ename, code);
	if code ^= 0
	     then call file_error (code);

	call expand_pathname_ (file_pathname, new_dname, new_ename, code);
	if code ^= 0
	     then call file_error (code);

	/* If the names are not the same, rename the file (hcs_$chname_file
	   complains if the names are identical). */

	if new_ename ^= file_ename
	     then do;
		call hcs_$chname_file (file_dname, file_ename, file_ename, new_ename, code);
		if code ^= 0
		     then call file_error (code);

		tied_files(tied_array_idx).file_name = file_pathname;
	     end;

	operators_argument.result = null ();
	return; /* from frename */

/* FAPPEND writes the given APL value to the logical end of the APL file. */

file_operation(74):				/* qFAPPEND */

	call decode_right_arg (1, 1);

	left_vb = operators_argument(1).value;

	tied_array_idx = get_tie_index (tie_num, code);
	if code ^= 0
	     then call file_error (code);

	iocb_ptr = tied_files(tied_array_idx).iocb_ptr;

	/* if file is sharable, read header from file */

	if tied_files(tied_array_idx).shared
	     then do;
	          file_header_size = size (file_header) * 4;

	          call iox_$seek_key (iocb_ptr, file_header_key, size_read, code);
		if code ^= 0
		     then call file_error (code);

		/* Prevent interference from other users of the shared
		   file */

		call lock_file (tied_array_idx, lock);

		call iox_$read_record (iocb_ptr, addr (file_header), file_header_size, size_read, code);
		if code ^= 0
		     then call file_error (code);

		component_number = file_header.last_component + 1;
	     end;
	     else component_number = tied_files(tied_array_idx).last_component + 1;

	component_key = component_number;		/* convert to string */

	call iox_$seek_key (iocb_ptr, (component_key), size_read, code);

	/* Component must not already be there. */

	if code ^= error_table_$no_record
	     then call file_error (apl_error_table_$bad_apl_file);

	if operators_argument(1).on_stack
	     then bead_size = compute_length (left_vb);
	     else bead_size = binary (left_vb -> value_bead.size) * 4;

	/* Write the bead out wholesale.  The one pointer in it
	   (value_bead.data_pointer) will br reconstructed by FREAD */

	call iox_$write_record (iocb_ptr, left_vb, bead_size, code);
	if code ^= 0
	     then call file_error (code);

	/* Update component header */

	/* Get info to write to component header... */

	component_header.user_id = group_id;
	component_header.user_number = ws_info.user_number;
	component_header.time = clock ();
	component_header.size = bead_size;

	component_header_size =  size (component_header) * 4;

	/* ...and write it out */

	call iox_$seek_key (iocb_ptr, component_key || "info", size_read, code);

	if code = error_table_$no_record
	     then call iox_$write_record (iocb_ptr, addr (component_header), component_header_size, code);
	     else call iox_$rewrite_record (iocb_ptr, addr (component_header), component_header_size, code);

	if code ^= 0
	     then call file_error (code);

	/* Update file header information, either in the file or in the array */

	if tied_files(tied_array_idx).shared
	     then do;
	          file_header_size = size (file_header) * 4;
	          file_header.version = file_header_version;
	          file_header.last_component = component_number;
		if file_header.first_component = 0
		     then file_header.first_component = component_number;

		call iox_$seek_key (iocb_ptr, file_header_key, size_read, code);
		if code ^= 0
		     then call file_error (code);

		call iox_$rewrite_record (iocb_ptr, addr (file_header), file_header_size, code);
		if code ^= 0
		     then call file_error (code);

		/* Unlock the file. */

		call lock_file (tied_array_idx, unlock);

	     end;
	     else do;
		tied_files(tied_array_idx).last_component = component_number;
		if tied_files(tied_array_idx).first_component = 0
		     then tied_files(tied_array_idx).first_component = component_number;
	     end;

	operators_argument.result = null();

	return; /* from fappend */


/* FREPLACE replaces the value of a given APL file component with a
   new value. */

file_operation(88):				/* qFREPLACE */

	/* Get tie number and component number. */

	call decode_right_arg (2, 2);

	tied_array_idx = get_tie_index (tie_num, code);
	if code ^= 0
	     then call file_error (code);

	/* Check range of component number if possible. */

	if ^(tied_files(tied_array_idx).shared)
	     then if (component_number < tied_files(tied_array_idx).first_component) |
		(component_number > tied_files(tied_array_idx).last_component)
		then call file_error (apl_error_table_$bad_component_num);

	/* Get pointer to APL value. */

	left_vb = operators_argument(1).value;

	iocb_ptr = tied_files(tied_array_idx).iocb_ptr;

	component_key = component_number;

	/* Seek component with given number. If it does not exist, the
	   component number is out of range. */

	call iox_$seek_key (iocb_ptr, (component_key), size_read, code);
	if code = error_table_$no_record
	     then call file_error (apl_error_table_$bad_component_num);
	     else if code ^= 0
		then call file_error (code);

	/* Compute total size of the bead. */

	if operators_argument(1).on_stack
	     then bead_size = compute_length (left_vb);
	     else bead_size = binary (left_vb -> value_bead.size) * 4;

	/* Write the new value. */

	if tied_files(tied_array_idx).shared
	     then call lock_file (tied_array_idx, lock);

	call iox_$rewrite_record (iocb_ptr, left_vb, bead_size, code);
	if code ^= 0
	     then call file_error (code);

	/* Update the component header. */

	/* Get info to write to component header... */

	component_header.user_id = group_id;
	component_header.user_number = ws_info.user_number;
	component_header.time = clock ();
	component_header.size = bead_size;

	component_header_size =  size (component_header) * 4;

	/* ...and write it out */

	call iox_$seek_key (iocb_ptr, component_key || "info", size_read, code);
	if code ^= 0
	     then call file_error (code);

	call iox_$rewrite_record (iocb_ptr, addr (component_header), component_header_size, code);
	if code ^= 0
	     then call file_error (code);

	/* As we are replacing a component the total number of components
	   remains the same, and we don't have to update the file header. */

	if tied_files(tied_array_idx).shared
	     then call lock_file (tied_array_idx, unlock);

	operators_argument.result = null();

	return; /* from freplace */


/* FDROP deletes components from either end of an APL file. */

file_operation(77):				/* qFDROP */

	call decode_right_arg (2, 2);

	tied_array_idx = get_tie_index (tie_num, code);
	if code ^= 0
	     then call file_error (code);

	iocb_ptr = tied_files(tied_array_idx).iocb_ptr;

	/* If file is opened for sharing, we must read header info from
	   file header. */

	if tied_files(tied_array_idx).shared
	     then do;
		call iox_$seek_key (iocb_ptr, file_header_key, size_read, code);
		if code ^= 0
		     then call file_error (code);
   
		file_header_size = size (file_header) * 4;

		call lock_file (tied_array_idx, lock);

		call iox_$read_record (iocb_ptr, addr (file_header), file_header_size, size_read, code);
		if code ^= 0
		     then call file_error (code);

		start_component = file_header.first_component;
		end_component = file_header.last_component;
	     end;
	     else do;
		start_component = tied_files(tied_array_idx).first_component;
		end_component = tied_files(tied_array_idx).last_component;
	     end;

	/* Check to see that there are as many components to drop as
	   specified. */

	if drop_number > (end_component - start_component + 1)
	     then call file_error (apl_error_table_$not_enough_components);

	/* If drop_number is positve, drop components from the low numbered
	   end of the file.  Update static file information now so that even
	   if something goes wrong, the file will look like the components
	   were dropped. */

	if drop_number > 0
	     then do;
		end_component = (start_component + drop_number - 1);
		increment = 1;
		tied_files(tied_array_idx).first_component = end_component + 1;
	     end;
	     else do;
		start_component = end_component;	/* start from high end */
		end_component = (start_component + drop_number + 1);
		increment = -1;
		tied_files(tied_array_idx).last_component = end_component - 1;
	     end;

	/* Check to see if any components remain.  If not, reset the
	   static information to the same state as for an empty file.  It
	   is not certain that this is done in the APL*PLUS file system,
	   but it seems reasonable.  */

	if tied_files(tied_array_idx).first_component > tied_files(tied_array_idx).last_component
	     then do;
		tied_files(tied_array_idx).first_component = 0;
		tied_files(tied_array_idx).last_component = 0;
	     end;

	/* Update the shared file information.  If this is done here,
	   the components will appear to be gone even if something goes
	   wrong below. */

	if tied_files(tied_array_idx).shared
	     then do;
		file_header.first_component = tied_files(tied_array_idx).first_component;
		file_header.last_component = tied_files(tied_array_idx).last_component;

		call iox_$seek_key (iocb_ptr, file_header_key, size_read, code);
		if code ^= 0
		     then call file_error (code);

		call iox_$rewrite_record (iocb_ptr, addr (file_header), file_header_size, code);
		if code ^= 0
		     then call file_error (code);

		call lock_file (tied_array_idx, unlock);
	     end;

	/* Do the real work. */

	do component_number = start_component to end_component by increment;

	     component_key = component_number;

	     call iox_$seek_key (iocb_ptr, (component_key), size_read, code);
	     if code ^= 0
		then call file_error (code);

	     call iox_$delete_record (iocb_ptr, code);
	     if code ^= 0
		then call file_error (code);
	end;

	operators_argument.result = null();
	return; /* from fdrop */

/* FREAD reads an APL value from an APL file and returns it. */

file_operation(86):				/* qFREAD */

	/* Get tie number and component number */

	call decode_right_arg (2, 2);

	tied_array_idx = get_tie_index (tie_num, code);
	if code ^= 0
	     then call file_error (code);

	/* Check component number for proper range of values if info is available */

	if ^(tied_files(tied_array_idx).shared)
	     then if (component_number > tied_files(tied_array_idx).last_component) |
	          (component_number < tied_files(tied_array_idx).first_component)
	          then call file_error (apl_error_table_$bad_component_num);

	iocb_ptr = tied_files(tied_array_idx).iocb_ptr;

	component_key = component_number;

	/* Find file component with designated key.  If none exists,
	   component number must have been out of range. */

	call iox_$seek_key (iocb_ptr, (component_key), size_read, code);
	if code = error_table_$no_record
	     then call file_error (apl_error_table_$bad_component_num);
	     else if code ^= 0
		then call file_error (code);

	bead_size = divide ((size_read + 3), 4, 21, 0);	/* convert bytes to words */

	/* Get storage to hold value bead... */

	result_vb = apl_push_stack_ ((bead_size));

	/* ...and read file component into it. */

	call iox_$read_record (iocb_ptr, (result_vb), size_read, size_read, code);
	if code ^= 0
	     then call file_error (code);

	/* Find pointer to actual data.  It starts after the last element
	   of value_bead.rho.  */

	data_ptr = addrel (addr (result_vb -> value_bead.rho (result_vb -> value_bead.rhorho)), 1);

	/* If data is numeric, it is guarenteed to be even word aligned.
	   Adjust the pointer accordingly. */

	if result_vb -> value_bead.numeric_value
	     then if substr (rel (data_ptr), 18, 1)	/* even or odd word? */
	          then data_ptr = addrel (data_ptr, 1);

	/* Assign value into bead header... */

	result_vb -> value_bead.data_pointer = data_ptr;

	/* ...and return value bead. */

	operators_argument.result = result_vb;

	return; /* from fread */

/* FRDCI returns information about a given component in an APL file. */

file_operation(85):				/* qFRDCI */

	call decode_right_arg (2, 2);

	tied_array_idx = get_tie_index (tie_num, code);
	if code ^= 0
	     then call file_error (code);

	/* Check component number for proper range of values if info is available */

	if ^tied_files(tied_array_idx).shared
	     then if (component_number > tied_files(tied_array_idx).last_component) |
	          (component_number < tied_files(tied_array_idx).first_component)
	          then call file_error (apl_error_table_$bad_component_num);

	iocb_ptr = tied_files(tied_array_idx).iocb_ptr;

	component_key = component_number;

	/* Find file component with designated key.  If none exists,
	   component number must have been out of range. */

	call iox_$seek_key (iocb_ptr, component_key || "info", size_read, code);
	if code = error_table_$no_record
	     then call file_error (apl_error_table_$bad_component_num);
	     else if code ^= 0
		then call file_error (code);

	component_header_size = size (component_header) * 4;
	call iox_$read_record (iocb_ptr, addr (component_header), component_header_size, size_read, code);
	if code ^= 0
	     then call file_error (code);

	/* Set global infomation on bead size, to be used to calculate
	   how much storage to ask for. */

	data_elements = 3;
	number_of_dimensions = 1;
	bead_size = size (value_bead) + size (numeric_datum) + 1;

	/* Get storage for bead. */

	result_vb = apl_push_stack_ ((bead_size));

	/* Fix up bead. */

	string (result_vb -> value_bead.type) = integral_value_type;     /* from incl file */
	result_vb -> value_bead.total_data_elements = data_elements;
	result_vb -> value_bead.rhorho = number_of_dimensions;
	result_vb -> value_bead.rho(1) = data_elements;

	result = addrel (result_vb, size (value_bead));

	/* even word align data */

	if substr (rel (result), 18, 1)
	     then result = addrel (result, 1);

	result_vb -> value_bead.data_pointer = result;

	result -> numeric_datum(0) = component_header.size;
	result -> numeric_datum(1) = component_header.user_number;
	result -> numeric_datum(2) = component_header.time;

	operators_argument.result = result_vb;
	return; /* from frdci */


/* FNUMS returns the tie numbers of all tied files. */

file_operation(84):				/* qFNUMS */

	/* We don't need to call decode_right_arg as this is a niladic
	   function, and is guaranteed to have no args (by APL) */

	/* Set global data used to compute length of bead. */

	data_elements = number_of_files_tied;
	number_of_dimensions = 1;

	bead_size = size (value_bead) + size (numeric_datum) + 1;

	result_vb = apl_push_stack_ ((bead_size));

	string (result_vb -> value_bead.type) = integral_value_type;
	result_vb -> value_bead.total_data_elements = data_elements;
	result_vb -> value_bead.rhorho = number_of_dimensions;
	result_vb -> value_bead.rho(1) = data_elements;

	/* Find pointer to data. */

	result = addrel (result_vb, size (value_bead));

	/* Even word align the data pointer. */

	if substr (rel (result), 18, 1)
	     then result = addrel (result, 1);

	result_vb -> value_bead.data_pointer = result;

	/* Fill in result bead with tie numbers of tied files. */

	idx = 0;
	do count = lbound (tied_files, 1) to hbound (tied_files, 1);
	     if tied_files(count).iocb_ptr ^= null ()
		then do;
		     result -> numeric_datum(idx) = tied_files(count).tie_number;
		     idx = idx + 1;
		end;
	end;

	operators_argument.result = result_vb;
	return;  /* from fnums */

/* FNAMES returns the names of the currently tied files in a character
   matrix. */

file_operation(83):				/* qFNAMES */

	/* We don't need to call decode_right_arg because we are
	   guaranteed to have no arguments. */

	/* Set global data used for bead size computation. */

	data_elements = number_of_files_tied * 168;	/* max length of one pathname */
	number_of_dimensions = 2;

	bead_size = size (value_bead) + size (character_data_structure);

	result_vb = apl_push_stack_ ((bead_size));	/* allocate storage */

	string (result_vb -> value_bead.type) = character_value_type;
	result_vb -> value_bead.total_data_elements = data_elements;
	result_vb -> value_bead.rhorho = number_of_dimensions;
	result_vb -> value_bead.rho(1) = number_of_files_tied;
	result_vb -> value_bead.rho(2) = 168;

	/* Find pointer to data in bead */

	result = addrel (result_vb, size (value_bead));

	result_vb -> value_bead.data_pointer = result;

	/* Fill in result bead with file pathnames. */

	idx = 0;
	do count = lbound (tied_files, 1) to hbound (tied_files, 1);
	     if tied_files(count).iocb_ptr ^= null ()
		then do;
		     substr (result -> character_string_overlay, (idx * 168 + 1), 168) =
			tied_files(count).file_name;
		     idx = idx + 1;
		end;
	end;

	operators_argument.result = result_vb;
	return; /* from fnames */

/* FLIB returns a character matrix of all of the files on the working dir */

file_operation(80):				/* qFLIB */

	right_vb = operators_argument.operands(2).value;

	data_elements = right_vb -> value_bead.total_data_elements;

	file_pathname = right_vb -> value_bead.data_pointer -> character_string_overlay;

	/* Ask apl_translate_pathname_ for a directory (signified by passing
	   it a null string ename). */

	call apl_translate_pathname_$file_system_pathname (file_pathname, file_dname, (""), null (), code);
	if code ^= 0
	     then call file_error (code);

	file_ename = "**.cf.apl";

	area_ptr = get_system_free_area_ ();

	call hcs_$star_ (file_dname, file_ename, 3, area_ptr, star_entry_count, star_entry_ptr, star_names_ptr, code);

	if code = 0
	     then data_elements = star_entry_count * 32;
	     else if code = error_table_$nomatch
		then data_elements = 0;
		else call file_error (code);

	number_of_dimensions = 2;

	bead_size = size (value_bead) + size (character_data_structure);

	result_vb = apl_push_stack_ ((bead_size));

	string (result_vb -> value_bead.type) = character_value_type;
	result_vb -> value_bead.total_data_elements = data_elements;
	result_vb -> value_bead.rhorho = number_of_dimensions;
	result_vb -> value_bead.rho(1) = star_entry_count;
	result_vb -> value_bead.rho(2) = 32;

	/* Find pointer to data in bead */

	result = addrel (result_vb, size (value_bead));

	result_vb -> value_bead.data_pointer = result;

	do count = 1 to star_entry_count;	/* star_entry_count will be 0 for no matches. */

	     substr (result -> character_string_overlay, (count - 1) * 32 + 1, 32) = star_names(star_entries(count).nindex);
	end;

	/* If no matches were found, ptr's are null */

	if star_names_ptr ^= null()
	     then free star_names in (system_area);
	if star_entry_ptr ^= null()
	     then free star_entries in (system_area);

	operators_argument.result = result_vb;
	return; /* from flib */

/* FLISTACL returns a character matrix of the Access Control List for
   the msf containing the APL file. */

file_operation(82):				/* qFLISTACL */

	call decode_right_arg (1, 1);

	tied_array_idx = get_tie_index (tie_num, code);
	if code ^= 0
	     then call file_error (code);

	iocb_ptr = tied_files(tied_array_idx).iocb_ptr;

	/* Get pointer to area in which to write data. */

	area_ptr = get_system_free_area_ ();

	/* Get ACL */

	call expand_pathname_ (tied_files(tied_array_idx).file_name, file_dname, file_ename, code);
	if code ^= 0
	     then call file_error (code);

	call msf_manager_$open (file_dname, file_ename, fcb_ptr, code);
	if code ^= 0
	     then call file_error (code);

	call msf_manager_$acl_list (fcb_ptr, area_ptr, acl_ptr, null(), acl_count, code);
	if code ^= 0
	     then call file_error (code);

	call msf_manager_$close (fcb_ptr);

	/* Set global data used to compute bead length. */

	data_elements = 36 * acl_count;
	number_of_dimensions = 2;

	bead_size = size (value_bead) + size (character_data_structure);

	result_vb = apl_push_stack_ ((bead_size));

	string (result_vb -> value_bead.type) = character_value_type;
	result_vb -> value_bead.total_data_elements = data_elements;
	result_vb -> value_bead.rhorho = number_of_dimensions;
	result_vb -> value_bead.rho(1) = acl_count;
	result_vb -> value_bead.rho(2) = 36;

	/* Find pointer to data in bead */

	result = addrel (result_vb, size (value_bead));

	result_vb -> value_bead.data_pointer = result;

	do count = 1 to acl_count;

	     substr (result -> character_string_overlay, (((count - 1) * 36) + 5), 32) = segment_acl(count).access_name;

	     if substr (segment_acl(count).modes, 1, 1)
		then substr (mode_string, 1, 1) = "r";
		else substr (mode_string, 1, 1) = " ";

	     if substr (segment_acl(count).modes, 2, 1)
		then substr (mode_string, 2, 1) = "e";
		else substr (mode_string, 2, 1) = " ";

	     if substr (segment_acl(count).modes, 3, 1)
		then substr (mode_string, 3, 2) = "w ";
		else substr (mode_string, 3, 2) = "  ";

	     substr (result -> character_string_overlay, (((count - 1) * 36) + 1), 4) = mode_string;

	end;

	free segment_acl in (system_area);

	operators_argument.result = result_vb;
	return; /* from flistacl */

/* FSETACL sets the Access Control List for an APL file. */

file_operation(89):				/* qFSETACL */

	fsetacl_not_faddacl = "1"b;
	goto common_acl_hacker;

/* FADDACL adds acl entries to the APL file acl. */

file_operation(73):				/* qFADDACL */

	fsetacl_not_faddacl = "0"b;
	goto common_acl_hacker;

common_acl_hacker:

	call decode_right_arg (1, 1);

	tied_array_idx = get_tie_index (tie_num, code);
	if code ^= 0
	     then call file_error (code);

	/* Decode the left argument */

	left_vb = operators_argument.operands(1).value;

	/* Validate the character matrix */

	if ^left_vb -> general_bead.value
	     then call file_error (apl_error_table_$domain);

	if ^left_vb -> value_bead.character_value	/* Must be characters */
	     then call file_error (apl_error_table_$domain);

	/* Check for correct dimensionality.  Must be vector or 2-dimensional
	   array. */

	if (left_vb -> value_bead.rhorho > 2 |
	     left_vb -> value_bead.rhorho < 1)
	     then call file_error (apl_error_table_$rank);

	/* If value is a matrix, it must be n by 36 */

 	if left_vb -> value_bead.rhorho = 2
	     then if left_vb -> value_bead.rho(left_vb -> value_bead.rhorho) ^= 36
		then call file_error (apl_error_table_$length);
		else;

	/* If it is a vector, it must have at least 5 elements ("rew *") */

	     else if left_vb -> value_bead.total_data_elements < 5
		then call file_error (apl_error_table_$length);

	left = left_vb -> value_bead.data_pointer;

	/* Get space to put acl structure in. */

	area_ptr = get_system_free_area_ ();

	if left_vb -> value_bead.rhorho = 1
	     then acl_count = 1;
	     else acl_count = left_vb -> value_bead.rho(1);

	allocate segment_acl in (system_area);

	data_elements = left_vb -> value_bead.total_data_elements;

	/* Fill in acl structure. */

	code = 0;
	do count = 1 to acl_count;

	     if substr (left -> character_string_overlay, 4, 1) ^= " "   /* space */
		then do;
		     code = apl_error_table_$bad_access_matrix;
		     goto bad_matrix_syntax_exit;
		end;

	     /* The following statement is designed to allow the user to
	        not bother to pad to 36 characters if his entry is a
	        vector.  Basically it uses rho(rhorho) of the value, which
	        is rho(1) for a vector and rho(2) for a matrix, to compute
	        the length of the current row of the value.  The rho(2) of
	        the matrix will always be 36 (see code above), the rho(1)
	        of the vector will be the actual length of the vector.
	        The substring of the line from the 5th char for
	        length_of_line - 4 chars is the user id.  cv_userid_
	        converts this into the canonical form. */

	     segment_acl(count).access_name = cv_userid_ (ltrim (substr (left -> character_string_overlay,
		((count - 1) * 36) + 5,
		left_vb -> value_bead.rho(left_vb -> value_bead.rhorho) - 4)));

	     mode_string = substr (left -> character_string_overlay, ((count - 1) * 36) + 1, 3);

	     if verify (mode_string, "rew ") ^= 0
		then do;
		     code = apl_error_table_$bad_access_modes;
		     goto bad_matrix_syntax_exit;
		end;

	     substr (segment_acl(count).modes, 1, 1) = (index (mode_string, "r") > 0);
	     substr (segment_acl(count).modes, 2, 1) = (index (mode_string, "e") > 0);
	     substr (segment_acl(count).modes, 3, 1) = (index (mode_string, "w") > 0);

	end;

	/* Get the APL file pathname, then do the actual ACL rearranging. */

	call expand_pathname_ (tied_files(tied_array_idx).file_name, file_dname, file_ename,code);
	if code ^= 0
	     then call file_error (code);

	call msf_manager_$open (file_dname, file_ename, fcb_ptr, code);
	if code ^= 0
	     then call file_error (code);

	if fsetacl_not_faddacl
	     then call msf_manager_$acl_replace (fcb_ptr, acl_ptr, acl_count, "0"b, code);
	     else call msf_manager_$acl_add (fcb_ptr, acl_ptr, acl_count, code);

	call msf_manager_$close (fcb_ptr);

bad_matrix_syntax_exit:
	if code ^= 0
	     then call file_error (code);

	free segment_acl in (system_area);

	operators_argument.result = null();
	return; /* from fsetacl or faddacl */

/* FDELETEACL removes the specified access names from the ACL list for an
   APL file. */

file_operation(76):				/* qFDELETEACL */

	call decode_right_arg (1, 1);

	tied_array_idx = get_tie_index (tie_num, code);
	if code ^= 0
	     then call file_error (code);

	/* Decode the left argument */

	left_vb = operators_argument.operands(1).value;

	/* Validate the character matrix */

	if ^left_vb -> general_bead.value
	     then call file_error (apl_error_table_$domain);

	if ^left_vb -> value_bead.character_value	/* Must be characters */
	     then call file_error (apl_error_table_$domain);

	/* Check for correct dimensionality.  Must be vector or 2-dimensional
	   array. */

	if (left_vb -> value_bead.rhorho > 2 |
	     left_vb -> value_bead.rhorho < 1)
	     then call file_error (apl_error_table_$rank);

	/* Character matrix must be n by 32 */

	if left_vb -> value_bead.rhorho = 2
	     then if left_vb -> value_bead.rho(left_vb -> value_bead.rhorho) ^= 32
		then call file_error (apl_error_table_$length);
		else;

	/* If it is a vector, it must have at least 1 element. */

	     else if left_vb -> value_bead.total_data_elements < 1
		then call file_error (apl_error_table_$length);

	left = left_vb -> value_bead.data_pointer;

	/* Get space to put acl structure in. */

	area_ptr = get_system_free_area_ ();

	if left_vb -> value_bead.rhorho = 1
	     then acl_count = 1;
	     else acl_count = left_vb -> value_bead.rho(1);

	allocate delete_acl in (system_area);

	/* Fill in acl structure. */

	do count = 1 to acl_count;

	     /* For an explanation of the following statement, see the
	        similar code in fsetacl. */

	     delete_acl(count).access_name = cv_userid_ (substr (left -> character_string_overlay,
		((count - 1) * 32) + 1,
		left_vb -> value_bead.rho(left_vb -> value_bead.rhorho)));

	end;

	/* Get the APL file pathname, then do the actual ACL rearranging. */

	call expand_pathname_ (tied_files(tied_array_idx).file_name, file_dname, file_ename, code);
	if code ^= 0
	     then call file_error (code);

	call msf_manager_$open (file_dname, file_ename, fcb_ptr, code);
	if code ^= 0
	     then call file_error (code);

	call msf_manager_$acl_delete (fcb_ptr, acl_ptr, acl_count, code);
	if code ^= 0
	     then call file_error (code);

	call msf_manager_$close (fcb_ptr);

	free delete_acl in (system_area);

	operators_argument.result = null();
	return; /* from fdeleteacl */

/* FLIM returns the number of the first component and 1 greater than the
   number of the last component. */

file_operation(81):				/* qFLIM */

	flim_not_fsize = "1"b;
	goto flim_fsize_common;

/* FSIZE returns the same information as FLIM, plus the storage used and
   storage reservation of the file */

file_operation(90):				/* qFSIZE */

	flim_not_fsize = "0"b;
	goto flim_fsize_common;

flim_fsize_common:

	call decode_right_arg (1, 1);

	tied_array_idx = get_tie_index (tie_num, code);
	if code ^= 0
	     then call file_error (code);

	iocb_ptr = tied_files(tied_array_idx).iocb_ptr;

	/* Set global data used to compute bead length. */

	if flim_not_fsize then do;
	     data_elements = 2;
	     number_of_dimensions = 1;
	end;
	else do;
	     data_elements = 4;
	     number_of_dimensions = 1;
	end;

	bead_size = size (value_bead) + size (numeric_datum) + 1;

	result_vb = apl_push_stack_ ((bead_size));

	string (result_vb -> value_bead.type) = integral_value_type;
	result_vb -> value_bead.total_data_elements = data_elements;
	result_vb -> value_bead.rhorho = number_of_dimensions;
	result_vb -> value_bead.rho(1) = data_elements;

	/* Find pointer to data. */

	result = addrel (result_vb, size (value_bead));

	/* Even word align the data pointer. */

	if substr (rel (result), 18, 1)
	     then result = addrel (result, 1);

	result_vb -> value_bead.data_pointer = result;
	/* Fill in the result bead with the first and last component
	   numbers of the file. */

	if tied_files(tied_array_idx).shared
	     then do;
		call iox_$seek_key (iocb_ptr, file_header_key, size_read, code);
		if code ^= 0
		     then call file_error (code);

		file_header_size = size (file_header) * 4;

		call iox_$read_record (iocb_ptr, addr (file_header), file_header_size, size_read, code);
		if code ^= 0
		     then call file_error (code);

		result -> numeric_datum(0) = file_header.first_component;
		result -> numeric_datum(1) = file_header.last_component + 1;
	     end;
	     else do;
		result -> numeric_datum(0) = tied_files(tied_array_idx).first_component;
		result -> numeric_datum(1) = tied_files(tied_array_idx).last_component + 1;
	     end;

	/* Fill in storage used and storage reservation. */

	if ^flim_not_fsize
	     then do;
		call expand_pathname_ (tied_files(tied_array_idx).file_name, file_dname, file_ename, code);
		if code ^= 0
		     then call file_error (code);

		area_ptr = get_system_free_area_ ();

		allocate index_info in (system_area);

		index_info.info_version = 1;

		call vfile_status_ (file_dname, file_ename, info_ptr, code);
		if code ^= 0
		     then call file_error (code);

		result -> numeric_datum(2) = index_info.record_bytes;
		result -> numeric_datum(3) = TheBiggestNumberWeveGot;

		free index_info in (system_area);
	     end;

	operators_argument.result = result_vb;

	return; /* from flim */

/* FHOLD locks all of the files specified by the user in the right argument
   after unlocking all of the files the user currently has locked. */

file_operation(79):				/* qFHOLD */

	/* Allow as many tie nums as the maximum tieable. */

	call decode_right_arg (0, hbound (tied_files, 1));

	call check_integers (right_vb, code);
	if code ^= 0
	     then call file_error (code);

	/* Unlock all currently locked files. */

	do count = lbound (tied_files, 1) to hbound (tied_files, 1);

	     if tied_files(count).iocb_ptr ^= null ()
		then call lock_file (count, unlock);
	end;

	/* Check to see that all specified files are tied, and get
	   their UID's to determine locking order. */

	do count = 0 to (right_vb -> value_bead.total_data_elements - 1);

	     tie_num = integerize (right -> numeric_datum (count));

	     tied_array_idx = get_tie_index (tie_num, code);
	     if code ^= 0
		then call file_error (code);

	     call expand_pathname_ (tied_files(tied_array_idx).file_name, file_dname, file_ename, code);
	     if code ^= 0
		then call file_error (code);

	     call hcs_$status_long (file_dname, file_ename, 1, addr (branch_status), null (), code);
	     if code ^= 0
		then call file_error (code);

	     file_uids(count + 1) = branch_status.unique_id;
	     array_idxs(count + 1) = tied_array_idx;
	end;

	/* Sort the files by unique id. This ensures that every process
	   using shared files will lock them in the same order, thus
	   preventing deadlocks. */

	do count = (right_vb -> value_bead.total_data_elements - 1) to 1 by -1;

	     switched_one = "0"b;

	     do idx = 1 to count;

		/* If the current entry is greater than the next, switch
		   them, and switch the corresponding array indecies. */

		if file_uids(idx) > file_uids(idx + 1)
		     then do;
			uid = file_uids(idx);
			file_uids(idx) = file_uids(idx + 1);
			file_uids(idx + 1) = uid;

			tied_array_idx = array_idxs(idx);
			array_idxs(idx) = array_idxs(idx + 1);
			array_idxs(idx + 1) = tied_array_idx;

			switched_one = "1"b; /* note that switching was done */
		     end;
	     end;

	     /* If no entries were exchanged this pass, everything is in
	        order. */

	     if ^switched_one
		then goto exit_early;
	end;

exit_early:

	/* Do the actual file locking.  If somebody else has one of the
	   files locked,  we will sleep until we can lock it (see
	   attachment and opening modes in open_file).  All the preceding
	   UID hair is to ensure that no deadly embraces can occur
	   (everybody locks them in the same order).  */

	do count = 1 to (right_vb -> value_bead.total_data_elements);

	     call lock_file (array_idxs(count), lock);
	end;

	operators_argument.result = null();
	return; /* from fhold */

/* open_file is the routine that does all the real work of attaching and
   opening files.  */

open_file:
	procedure (share, create_if_not_found);

dcl (share, create_if_not_found) bit(1) aligned parameter;

dcl attach_desc char(256) varying;		/* attach description */

dcl record_quota_overflow condition;
dcl any_other condition;

dcl apl_error_table_$rqo_on_file fixed bin(35) external;


	/* Take advantage of the fact that this code MUST be executed
	   before any other file system functions can run. */

	if first_file_open
	     then do;
		call user_info_$whoami (user_name, user_project, (""));
		group_id = rtrim (user_name) || "." || user_project;
		first_file_open = "0"b;
	     end;

	/* See if the specified tie number is already tied to a file,
	   and if so, complain. */

	tied_array_idx = get_tie_index (tie_num, code);
	if code = 0
	     then call file_error (apl_error_table_$tie_num_in_use);

	/* Find a free array slot. */

	tied_array_idx = get_free_index (tie_num, code);
	if code ^= 0
	     then call file_error (code);

	/* Build the attach description based on previously gathered information. */

	attach_desc = "vfile_ " || file_pathname;
      
	/* Check to see if file already exists when creating. */

	if create_if_not_found
	     then do;
	          call hcs_$status_minf (file_dname, file_ename, 1, (0), (0), code);
		if code = 0			/* status_minf found the file */
		     then call file_error (apl_error_table_$file_already_exists);
		if code ^= error_table_$noentry	/* if it was not there, it's OK */
		     then call file_error (code);
	     end;

	     /* Otherwise, make sure it will not be created. */

	     else attach_desc = attach_desc || " -old";	     

	/* If the file is to be opened in shared mode, set the wait time
	   for a locked file to -1, forever.  This means that any attempt
	   to operate on a file locked by another APL user will wait until
	   the other user unlocks the file, then proceed. */

	if share
	     then attach_desc = attach_desc || " -share -1";
	     else attach_desc = attach_desc || " -exclusive";

	/* File information is kept in an internal static array, indexed by
	   tie number.  The "shared" bit is the definitive test for
	   determining whether or not file header information may be kept
	   in the static storage or must be written to the file header.  */

	tied_files(tied_array_idx).shared = share;

	/* set up any_other handler to catch vfile_ complaints when
	   quota is exhausted.  It sometimes gets null pointer faults */

	on any_other
	     begin;

		call iox_$close (iocb_ptr, code);
		call iox_$detach_iocb (iocb_ptr, code);

		call file_error (apl_error_table_$rqo_on_file);
	     end;

	/* Attach the APL file. */

	call iox_$attach_name (unique_chars_ (""b), iocb_ptr,
	     (attach_desc), codeptr(apl_file_system_), code);
	if code ^= 0
	     then call file_error (code);

	/* All APL value files are indexed files, and are opened in the
	   same way */

	call iox_$open (iocb_ptr, Keyed_sequential_update, "0"b, code);

	if code = error_table_$moderr
	     then do;
		call iox_$detach_iocb (iocb_ptr, code);

		/* Since the open failed due to insufficient access,
		   we are going to try to open for read only.  This code
		   first takes out the attach description information
		   pertaining to sharable openings, then tries again. */

		if share
		     then temp_string = "-share -1";
		     else temp_string = "-exclusive";

		idx = index (attach_desc, temp_string); /* if idx = 0 we are in trouble */
		attach_desc = substr (attach_desc, 1, idx - 1) ||
		     substr (attach_desc, idx + length (temp_string));

		call iox_$attach_name (unique_chars_ (""b), iocb_ptr,
		     (attach_desc), codeptr(apl_file_system_), code);
		if code ^= 0
		     then call file_error (code);

		call iox_$open (iocb_ptr, Keyed_sequential_input, "0"b, code);
		if code ^= 0
		     then call iox_$detach_iocb (iocb_ptr, code2);

		if code = error_table_$moderr
		     then call file_error (apl_error_table_$no_access_to_file);

		/* Remember that this is a  read only file. */

		tied_files(tied_array_idx).read_only = "1"b;
	     end;
	     else tied_files(tied_array_idx).read_only = "0"b;

	if code ^= 0
	     then call iox_$detach_iocb (iocb_ptr, code2);

	if code ^= 0
	     then call file_error (code);

	/* Find the file header record.  If it isn't there, assume
	   this is the first write to this file and continue. */

	call iox_$seek_key (iocb_ptr, file_header_key, size_read, code);

	/* If there is no such record, this is a new file. Use write_record
	   to write header info... */

	if code = error_table_$no_record
	     then do;
	          file_header_size = size (file_header) * 4;
	          file_header.version = file_header_version;
	          file_header.first_component = 0;
		file_header.last_component = 0;

	          call iox_$write_record (iocb_ptr, addr (file_header), file_header_size, code);

		if code ^= 0
		     then call file_error (code);

		if ^share
		     then do;
			tied_files(tied_array_idx).first_component = 0;
			tied_files(tied_array_idx).last_component = 0;
		     end;
	     end;

	/* ...otherwise read the existing header info */

	     else do;
		if code ^= 0
		     then call file_error (code);

	          file_header_size = size (file_header) * 4;

		call iox_$read_record (iocb_ptr, addr (file_header),
		     file_header_size, size_read, code);
		if code ^= 0
		     then call file_error (code);

		if file_header.version ^= file_header_version
		     then call file_error (apl_error_table_$old_file_header);

		/* If file is exclusively tied, header info may be kept
	             in static storage */

		if ^share
		     then do;
		          tied_files(tied_array_idx).first_component =
			     file_header.first_component;
		          tied_files(tied_array_idx).last_component =
			     file_header.last_component;
		     end;
	     end;

	revert any_other;

	/* Set up static data array entry for this file. */

	tied_files(tied_array_idx).iocb_ptr = iocb_ptr;
	tied_files(tied_array_idx).tie_number = tie_num;
	tied_files(tied_array_idx).file_name = file_pathname;
	tied_files(tied_array_idx).locked = "0"b;
	number_of_files_tied = number_of_files_tied + 1;

	return;
     end; /* open_file */


/* untie_all_files is intended to be called by APL to untie all of the
   user's files.  This is done when he quits APL. */

untie_all_files:
	entry;

dcl found_one bit(1);

	found_one = "0"b;

	do count = lbound (tied_files, 1) to hbound (tied_files, 1);

	     if tied_files(count).iocb_ptr ^= null()
		then do;
		     call untie_file (count, code);
		     found_one = "1"b;
		end;
	end;

	if found_one
	     then call ioa_$ioa_switch (apl_static_$apl_output, "files untied - some files automatically untied");
	return;

/* untie_file closes and detaches a file given its tied_files array index,
   updating the tied file database if necessary.  If the specified array
   index does not refer to a file, untie_file returns. */

untie_file:
	procedure (tied_array_idx, code);

dcl tied_array_idx fixed bin parameter;
dcl code fixed bin(35) parameter;

dcl iocb_ptr pointer;

	code = 0;

	if tied_files(tied_array_idx).iocb_ptr = null()
	     then return;

	iocb_ptr = tied_files(tied_array_idx).iocb_ptr;

	/* If the file is exclusively tied, update the header
	   in the file. */

	if (^tied_files(tied_array_idx).shared &
	     ^tied_files(tied_array_idx).read_only)
	     then do;
	          file_header_size = size (file_header) * 4;
		file_header.version = file_header_version;
		file_header.first_component =
		     tied_files(tied_array_idx).first_component;
		file_header.last_component =
		     tied_files(tied_array_idx).last_component;

		call iox_$seek_key (iocb_ptr, file_header_key, size_read, code);
		if code ^= 0
		     then return;

		call iox_$rewrite_record (iocb_ptr, addr (file_header),
		     file_header_size, code);
		if code ^= 0
		     then return;

	     end;  /* if not shared */

	     tied_files(tied_array_idx).iocb_ptr = null();
	     number_of_files_tied = number_of_files_tied - 1;

	     call iox_$close (iocb_ptr, code);
	     call iox_$detach_iocb (iocb_ptr, code);

	end; /* untie_file */


/* decode_file_id parses a filename of an APL file.  It also sets the global
   variables "left_vb" (a pointer to the left value bead), "left" (a pointer
   to the data in the left vb), "file_dname", "file_ename", and
   "file_pathname". */

decode_file_id:
          procedure;

/* automatic */

dcl file_id char (168);
dcl (libx, strx) fixed bin;


/* program */

	left_vb = operators_argument.operands (1).value;

	if ^left_vb -> general_bead.value
	     then call file_error (apl_error_table_$domain);

	if ^left_vb -> value_bead.character_value
	     then call file_error (apl_error_table_$domain);

	if (left_vb -> value_bead.total_data_elements = 0)
	     then call file_error (apl_error_table_$length);

	if (left_vb -> value_bead.rhorho > 1) & (left_vb -> value_bead.total_data_elements ^= 1)
	     then call file_error (apl_error_table_$rank);

	/* data_elements is a global variable used in based dcls
	   (see declarations of character_datum and
	   character_string_overlay for a better understanding of
	   this code).  Set here for length computations.  */

	data_elements = left_vb -> value_bead.total_data_elements;

	left = left_vb -> value_bead.data_pointer;

	/* Strip leading spaces. */

	do strx = lbound (left -> character_datum, 1) to hbound (left -> character_datum, 1)
	     while (left -> character_datum (strx) = " ");
	end;

	/* If strx is off the end of the array, no non-white characters
	   were found.  Report an error. */
	   
	if strx > hbound (left -> character_datum, 1)
	     then call file_error (apl_error_table_$bad_file_name);

	libx = strx;				/* index of first non-blank */

	/* Does file-id include a library number? */

	if index ("0123456789", left -> character_datum (strx)) ^= 0
	     then do;
	          do strx = strx + 1 to hbound (left -> character_datum, 1)
		     while (left -> character_datum (strx) >= "0" &
		     left -> character_datum (strx) <= "9");
		end;

		/* Skip blanks */

		do strx = strx to hbound (left -> character_datum, 1)
		     while (left -> character_datum (strx) = " ");
		end;

		/* If strx is off the end of the array, no file name was
		   found after the library number. */

		if strx > hbound (left -> character_datum, 1)
		     then call file_error (apl_error_table_$bad_file_name);
	     end;

	/* Scan file name */

	do strx = strx to hbound (left -> character_datum, 1)
	     while (left -> character_datum (strx) ^= " ");
	end;

	/* Skip trailing blanks. */

	do idx = strx to hbound (left -> character_datum, 1)
	     while (left -> character_datum (idx) = " ");
	end;

	/* If idx is not one greater than the length of the string,
	   there is cruft after the file name (possibly a "storage
	   reservation", a number accepted by other APL file systems,
	   but meaningless in Multics APL. */

	if idx <= hbound (left -> character_datum, 1)
	     then call file_error (apl_error_table_$bad_file_name);

	/* strx is now one greater than the last char in the file name.
	   Note that the apparent off-by-one error in using libx + 1
	   instead of libx is due to the fact the the array character_datum
	   is dimensioned to be 0:data_elements-1 (zero-origin) while the
	   string character_string_overlay is char (data_elements),
	   (one-origin). */

	file_id = substr (left -> character_string_overlay, libx + 1, strx - libx);
	call apl_translate_pathname_$file_system_pathname (file_id, file_dname, file_ename, null, code);

	file_pathname = rtrim (file_dname) || ">" || file_ename;
	return;

     end; /* decode_file_id */

/* decode_right_arg checks to make sure the right number of
   elements were supplied in the right hand vector.  The global
   variables "tie_num", "component_number", and "drop_number"
   are set to the 1st, 2nd and 2nd elements of the argument vector.
   The global variables "right_vb" (a pointer to the right value
   bead) and "right" (pointer to the actual data in the right
   vb) are also set.  */

decode_right_arg: procedure (min_arg_len, max_arg_len);

/* parameters */

dcl (min_arg_len, max_arg_len) fixed bin parameter;

/* program */

	right_vb = operators_argument.operands(2).value;

	if ^right_vb -> general_bead.value		/* must be a value bead */
	     then call file_error (apl_error_table_$domain);

	if ^right_vb -> value_bead.numeric_value	/* must be numeric */
	     then call file_error (apl_error_table_$domain);

	/* Set global variable used for based objects reference below */

	data_elements = right_vb -> value_bead.total_data_elements;

	/* If we have more than 1 dimension, there better be only one
	   element in the matrix. */

	if (right_vb -> value_bead.rhorho > 1) & (data_elements ^= 1)
	     then call file_error (apl_error_table_$rank);

	/* Check range for length.  -1 signifies no limit on values */

	if (data_elements < min_arg_len) |
	     ((max_arg_len ^= -1) & (data_elements > max_arg_len))
	     then call file_error (apl_error_table_$length);

	right = right_vb -> value_bead.data_pointer;

	/* If we don't have "real" integers, check for fuzz tolerance. */

	if right_vb -> value_bead.integral_value
	     then do;
		tie_num = fixed (right -> numeric_datum (0));
		if data_elements > 1
		     then do;
			component_number = fixed (right -> numeric_datum (1));
			drop_number = fixed (right -> numeric_datum(1));
		     end;
	     end;
	     else do;
		tie_num = integerize (right -> numeric_datum(0));
		if data_elements > 1
		     then do;
			component_number = integerize (right -> numeric_datum(1));
			drop_number = integerize (right -> numeric_datum(1));
		     end;
	     end;

	return;
     end; /* decode_right_arg */

/* integerize converts a floating number to a fixed one if it is within
   integer fuzz of an integer.  If not, an error is reported. */

integerize:
	procedure (number) returns (fixed bin);

dcl number float aligned parameter;

	/* Check for tolerance outside of integer fuzz range. */

	if abs (floor (number + 0.5) - number) < ws_info.integer_fuzz
	     then return (fixed (floor (number + 0.5)));
	     else call file_error (apl_error_table_$not_within_int_fuzz);

     end; /* integerp */

/* check_integers makes sure that all of the numbers in a numeric value_bead
   are within integer fuzz of an integer.  If they are not, a status code
   is returned.  It is the caller's responsibility to act upon the error. */

check_integers:
	procedure (bead_ptr, code);

dcl bead_ptr ptr parameter;
dcl code fixed bin(35);

dcl count fixed bin;
dcl data_ptr ptr;
dcl data_elements fixed bin;

	code = 0;

	data_ptr = bead_ptr -> value_bead.data_pointer;
	data_elements = bead_ptr -> value_bead.total_data_elements;

	do count = 0 to hbound (data_ptr -> numeric_datum, 1);
	     if abs (floor (data_ptr -> numeric_datum(count) + 0.5) -
		data_ptr -> numeric_datum(count)) >= integer_fuzz
		then do;
		     code = apl_error_table_$not_within_int_fuzz;
		     return;
		end;
	end;
     end; /* check_integers */

/* unlock_all_files unlocks all of the currently locked files.  It is
   used by APL each time "desk calcualtor" level is reached. */

unlock_all_files:
     entry;

     do count = lbound (tied_files, 1) to hbound (tied_files, 1);

	if tied_files(count).iocb_ptr ^= null()
	     then call lock_file (count, unlock);
     end;
     return;

/* lock_file locks or unlocks a file given its tied_files array index,
   updating the static information. */

lock_file:
	procedure (tied_array_idx, mode);

dcl tied_array_idx fixed bin parameter;
dcl mode bit(2) parameter;

	if tied_files(tied_array_idx).iocb_ptr = null()
	     then return;

	/* Indicate that some locking action has occurred in this
	   call to the file system.  This allows file_error to win.
	   First mode bit is "1"b for lock, "0"b for unlock.  */

	current_file_locked = substr (mode, 1, 1);

	/* If state is already right, punt. */

	if tied_files(tied_array_idx).locked = current_file_locked
	     then return;

	/* Set info to reflect given locking state. */

	tied_files(tied_array_idx).locked = current_file_locked;

	lock_info = mode;

	call iox_$control (tied_files(tied_array_idx).iocb_ptr, "set_file_lock", addr (lock_info), code);

	if (code ^= 0) & (code ^= error_table_$lock_not_locked) & (code ^= error_table_$locked_by_this_process)
	     then call file_error (code);

	return;
     end; /* lock_file */


/* file_error takes care of reporting all errors pertaining to the file system.
   Some standard error codes are converted wholesale to file system errors. */

file_error:
          procedure (status_code);

dcl status_code fixed bin(35) parameter;

	if status_code = 0		/* nothing to report */
	     then return;

	operators_argument.error_code = status_code;

	/* file_busy means somebody already has the file exclusively tied. */

	if status_code = error_table_$file_busy
	     then operators_argument.error_code = apl_error_table_$file_already_tied;

	/* These codes just get APL flavoring. */

	if status_code = error_table_$noentry
	     then operators_argument.error_code = apl_error_table_$no_such_file;

	if status_code = error_table_$moderr
	     then operators_argument.error_code = apl_error_table_$no_write_permission;

	if status_code = error_table_$no_info
	     then operators_argument.error_code = apl_error_table_$no_access_to_file;

	if status_code = error_table_$no_operation
	     then operators_argument.error_code = apl_error_table_$no_write_permission;

	if current_file_locked
	     then call lock_file (tied_array_idx, unlock);

	goto error_return;

     end; /* file_error */

/* get_tie_index and get_free_index manage the array containing information
   about tied files. */

get_tie_index:
          procedure (tie_num, code) returns (fixed bin);

dcl tie_num fixed bin parameter;
dcl code fixed bin(35) parameter;

dcl count fixed bin;

	/* get_tie_index finds the array index of an already tied file.
	   If the given tie number is not tied to a file, an error is
	   reported. */

	code = 0;

	/* Find the array slot holding the info on the specified tie
	   num.  Checking for non-null iocb_ptr is the definitive test
	   of whether or not a slot contains info about a currently
	   tied file.  Tie numbers between 1 and 20 (inclusive) are
	   optimized on the grounds that users use them most often.  */

	if (tie_num < 21) & (tie_num > 0)
	     & (tied_files(tie_num).iocb_ptr ^= null())    /* test for tiedness */
	     then return (tie_num);
	     else do count = 21 to hbound (tied_files, 1);
		if (tied_files(count).tie_number = tie_num)  /* find matching tie num */
		          & (tied_files(count).iocb_ptr ^= null())     /* and check for tiedness */
		     then return (count);
	     end;
	code = apl_error_table_$bad_tie_num;
	return (-1);

     end; /* get_tie_index */


get_free_index:
          procedure (tie_num, code) returns (fixed bin);

dcl tie_num fixed bin parameter;
dcl code fixed bin(35) parameter;

dcl count fixed bin;

	/* get_free_index finds a free array entry to use for a newly
	   tied file. */

	code = 0;

	/* Find the array slot not currently holding info about a
	   file.  Checking for non-null iocb_ptr is the definitive test
	   of whether or not a slot is in use.  Tie numbers between 1
	   and 20 (inclusive) are optimized on the grounds that users
	   use them most often.  */

	if (tie_num < 21) & (tie_num > 0)
	     then if tied_files(tie_num).iocb_ptr = null()
	          then return (tie_num);
	          else do;
		     code = apl_error_table_$tie_num_in_use;
		     return (-1);
		end;
	     else do count = 21 to hbound (tied_files, 1);
		if tied_files(count).iocb_ptr = null()
		     then return (count);
	     end;
	code = apl_error_table_$too_many_files;
	return (-1);

     end; /* get_free_index */
		

/* compute_length calculates the size of an APL value bead. */

compute_length:
	procedure (value_bead_ptr) returns (fixed bin (21));

/* parameter */

declare	value_bead_ptr ptr parameter;

/* automatic */

declare	data_size fixed bin (19),
	temp_vb ptr;

/* program */

	temp_vb = value_bead_ptr;

	/* set global information used to compute length */

	data_elements = temp_vb -> value_bead.total_data_elements;

	if temp_vb -> value_bead.numeric_value
	     then data_size = size (numeric_datum) + 1;
	     else data_size = size (character_string_overlay);

	return (4 * (currentsize (temp_vb -> value_bead) + data_size));

     end /* compute_length */;


/* apl_push_stack_ is a utility program to allocate space on the APL stack. */

%include apl_push_stack_fcn;

end; /* apl_file_system */
