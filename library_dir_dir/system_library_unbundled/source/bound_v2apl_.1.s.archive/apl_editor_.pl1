/* ******************************************************
   *                                                    *
   *                                                    *
   * Copyright (c) 1972 by Massachusetts Institute of   *
   * Technology and Honeywell Information Systems, Inc. *
   *                                                    *
   *                                                    *
   ****************************************************** */

/* New version of the APL editor, written by William M. York, Summer 1979. */

/* Modified 791207 by wmy to fix bug 426 ([Nq0] editing doesn't work) and
   the following unreported bugs:
   1) Hitting QUIT while in line-editing mode can leave you in
      read_back_output mode.
   2) Attempting to edit a pendent function reports the error properly, but
      leaves you in the editor in an inconsistant state.
   3) When the header is deleted [q] mis-numbers the lines.
   4) [d0] will delete the header of a suspended function.
   5) Function is renumbered after lex reports errors, but line number
      prompt is left as the old (sometimes no longer existing) line number.
   Modified 791217 by PG to fix bug whereby [Nq0] was rejected in a suspended function.
   Modified 800131 by PG to fix 442 (editor permitted user to add labels to a suspended fcn),
	and 435 (editor would not permit system variables in the header of a new fcn).
   Modified 800827 by WMY to add extensions to editor for context searching
	and substitution.
   Modified 810615 by WMY to add context_global_print and fix bugs
*/

apl_editor_:
	procedure (header_line, header_line_pos, code);

dcl	header_line char(*) parameter;
dcl	header_line_pos fixed bin(21) parameter;
dcl	code fixed bin(35) parameter;

/* Automatic */

dcl	input_buffer char(256);
dcl	input_line_length fixed bin(21);
dcl	character_pos fixed bin;
dcl	character char(1);
dcl	current_line_number fixed decimal (10, 5);
dcl	line_pos fixed bin;
dcl	(got_line, quit_force) bit(1) init ("0"b);
dcl	saved_search_string char(128) varying init("");

/* Internal Static */

dcl	whitespace_NL_string char(3) internal static options (constant) init (" 	
");	/* SPACE, TAB, NL */

/* Based */

dcl	input_line char(input_line_length) based (addr (input_buffer));

/* External */

dcl	(apl_error_table_$bad_function_header,
	apl_error_table_$extra_text)
	external fixed bin(35);

dcl	(cleanup, apl_quit_) condition;

/* Entries */

dcl	apl_create_save_frame_ entry ();
dcl	apl_segment_manager_$get entry () returns (pointer);
dcl	apl_command_$from_editor entry (char(*), fixed bin(21), fixed bin(35));

dcl	(length, substr, verify) builtin;

/* Include Files */

%include apl_number_data;
%include apl_characters;

%include apl_function_info;


/* Program */

	code = 0;

	function_info.first_unused_char_in_buffer = 1;
	function_info.locked_function = "0"b;
	function_info.suspended_function = "0"b;
	function_info.saved_stop_vector = null ();
	function_info.saved_trace_vector = null ();
	function_info.number_of_lines = 0;

	function_info.edit_buffer_ptr = apl_segment_manager_$get ();

	call apl_create_save_frame_;

	on cleanup
	     call apl_editor_cleanup (function_info);

	character_pos = header_line_pos + 1;
	call open_function (header_line, character_pos, function_info);

	input_line_length = length (header_line) - character_pos + 1;
	input_line = substr (header_line, character_pos);
	character_pos = 1;

	current_line_number = function_info.line_info(function_info.number_of_lines).line_number + 1;

	/* All setup is done, we are ready to go */

	on apl_quit_
	     goto internal_error_restart;

	do while ("1"b);

	     got_line = "0"b;
	     do while (^got_line);

		if character_pos > length (input_line)
		     then do;

/*  This is the place where the error routine goes after reporting errors */

internal_error_restart:
			call prompt (current_line_number, function_info);
			call read_line (input_buffer, input_line_length);
			character_pos = 1;
		     end;

		got_line = "1"b;

		line_pos = verify (substr (input_line, character_pos), whitespace_NL_string);
		if line_pos > 0
		     then character_pos = character_pos + line_pos - 1;
		     else do;
			character_pos = length (input_line) + 1;
			got_line = "0"b;
		     end;
	     end;  /* do while (^got_line) */

	     /* Could be del line, bracket line, APL command line, or
		new line of function. */

	     character = substr (input_line, character_pos, 1);

	     if character = QDel | character = QDelTilde
		then do;

		     if quit_force
			then call apl_editor_cleanup (function_info);

		     if character = QDelTilde
			then function_info.locked_function = "1"b;
			else function_info.locked_function = "0"b;

		     character_pos = character_pos + 1;
		     if character_pos < length (input_line)
			then call error (apl_error_table_$extra_text, input_line, character_pos);

		     call close_function (function_info, current_line_number, code);
		     if code = 0
			then call apl_editor_cleanup (function_info);
			else if code ^= apl_error_table_$bad_function_header
			     then do;
				quit_force = "1"b;
				call error (0, "", 0);
			     end;
		end;
		else do;

		     quit_force = "0"b;

		     if character = QLeftBracket
			then call process_bracket_contents (input_buffer, input_line_length, character_pos, current_line_number, function_info);

			else if character = QRightParen
			     then do;
				call apl_command_$from_editor (input_line, (character_pos), code);
				character_pos = length (input_line) + 1;
			     end;
			     else if character = QPeriod
				then call context_editor (input_buffer, input_line_length, character_pos, current_line_number, function_info, saved_search_string);

				else do;

				     call process_new_function_line (input_line, character_pos, current_line_number, function_info);

				     current_line_number = increment_line_number (current_line_number);
				end;
		end; /* else do */
	end;  /* do forever */

apl_editor_return_point:
	return;

open_function:
	procedure (header_line, character_pos, function_info);

dcl	header_line char(*) parameter;
dcl	character_pos fixed bin parameter;
%include	apl_function_info;

/* Automatic */

dcl	(header_start, header_length) fixed bin;
dcl	complicated_header bit(1);
dcl	last_frame_was_suspended bit(1);
dcl	function_bead_ptr pointer;
dcl	lexed_function_bead_ptr pointer;
dcl	parse_frame_ptr pointer;

/* External */

dcl	(apl_error_table_$complicated_header_line,
	apl_error_table_$non_function_edited,
	apl_error_table_$locked_function_edited,
	apl_error_table_$external_function_edited,
	apl_error_table_$pendent_function_edited) fixed bin(35) external;

/* Entries */

dcl	apl_get_symbol_ entry (char(*), pointer unaligned, fixed bin);

/* Include Files */

%include apl_ws_info;
%include apl_bead_format;
%include apl_operator_bead;
%include apl_symbol_bead;
%include apl_function_bead;
%include apl_lexed_function_bead;
%include apl_parse_frame;

/* Program */

	call parse_header_line (header_line, character_pos, header_start, header_length, complicated_header, function_info);
	     
	/* Lookup function name */

	call apl_get_symbol_ ((function_info.name), function_info.symbol_ptr, (0));

	/* If we just created the symbol_bead, hang on to it, otherwise
	   decrement it. */

	if function_info.symbol_ptr -> symbol_bead.reference_count > 1
	     then call decrement_reference_count (function_info.symbol_ptr);

	function_bead_ptr = function_info.symbol_ptr -> symbol_bead.meaning_pointer;

	if function_bead_ptr ^= null()
	     then do;

		if complicated_header
		     then call report_error (apl_error_table_$complicated_header_line, header_line, header_start);

		if ^(function_bead_ptr -> function_bead.function)
		     then do;
			call report_error (apl_error_table_$non_function_edited, header_line, header_start);
			call apl_editor_cleanup (function_info);
		     end;

		if function_bead_ptr -> function_bead.class = 1
		     then do;
			call report_error (apl_error_table_$locked_function_edited, header_line, header_start);
			call apl_editor_cleanup (function_info);
		     end;
		     else if function_bead_ptr -> function_bead.class ^= 0
			then do;
			     call report_error (apl_error_table_$external_function_edited, header_line, header_start);
			     call apl_editor_cleanup (function_info);
			end;

		lexed_function_bead_ptr = function_bead_ptr -> function_bead.lexed_function_bead_pointer;

		if lexed_function_bead_ptr ^= null ()
		     then do parse_frame_ptr = ws_info.current_parse_frame_ptr
			repeat (parse_frame_ptr -> parse_frame.last_parse_frame_ptr)
			while (parse_frame_ptr ^= null());

			if parse_frame.parse_frame_type = suspended_frame_type
			     then last_frame_was_suspended = "1"b;
			     else do;

				if parse_frame.parse_frame_type = function_frame_type
				     then if parse_frame.lexed_function_bead_ptr = lexed_function_bead_ptr
					then if ^last_frame_was_suspended
					     then do;

					     /* Not allowed to edit pendent functions, punt */
						call report_error (apl_error_table_$pendent_function_edited, header_line, header_start);
						call apl_editor_cleanup (function_info);
					     end;
					     else function_info.suspended_function = "1"b;
				last_frame_was_suspended = "0"b;
			     end;  /* else do */
		     end;  /* do parse_frame_ptr */

		call assign_line_numbers (function_info);

	     end;  /* if function_bead_ptr ^= null () */

	     else do;
		call make_new_function (function_info, substr (header_line, header_start, header_length));

		call assign_line_numbers (function_info);
	     end;
	return;

end; /* open_function */

close_function:
	procedure (function_info, current_line_number, code);

%include	apl_function_info;
dcl	current_line_number fixed decimal(10, 5) parameter;
dcl	code fixed bin(35) parameter;

/* Automatic */

dcl	character_pos fixed bin;
dcl	line_count fixed bin;
dcl	reported_si_damage bit (1) aligned;
dcl	scratch_space_ptr pointer;
dcl	function_bead_ptr pointer unaligned;
dcl	lexed_function_bead_ptr pointer unaligned;
dcl	function_name char(32) varying;
dcl	parse_frame_ptr pointer;
dcl	data_elements fixed bin;
dcl	last_frame_was_suspended bit(1);
dcl	bad_header bit(1);
dcl	lex_errors_occurred bit(1) aligned;

/* Static */

dcl	unlocked_message char(28) static options (constant) init ("function has been unlocked.
");

/* Based */

dcl	edit_buffer char(4 * sys_info$max_seg_size) based (function_info.edit_buffer_ptr);

/* External */

dcl	sys_info$max_seg_size external fixed bin;
dcl	apl_static_$apl_output external pointer;
dcl	apl_error_table_$bad_function_header external fixed bin(35);
dcl	apl_error_table_$edited_pendent_fcn external fixed bin (35);

dcl	(size, substr, string, null, lbound, addrel, divide) builtin;

/* Entries */

dcl	apl_allocate_words_ entry (fixed bin(24), pointer unaligned);
dcl	apl_function_lex_ entry (char(*) aligned, ptr unaligned, bit(1) aligned, fixed bin(24), ptr);
dcl	apl_get_symbol_ entry (char(*), pointer unaligned, fixed bin);
dcl	iox_$put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35));

/* Include Files */

%include apl_ws_info;
%include apl_bead_format;
%include apl_operator_bead;
%include apl_symbol_bead;
%include apl_function_bead;
%include apl_lexed_function_bead;
%include apl_parse_frame;

/* Program */

	code = 0;

	data_elements = 0;
	do line_count = lbound (function_info.line_info, 1) to function_info.number_of_lines;
	     data_elements = data_elements + function_info.line_info(line_count).line_length;
	end;

	call apl_allocate_words_ (size (function_bead), function_bead_ptr);

	string (function_bead_ptr -> function_bead.type) = function_type;
	function_bead_ptr -> function_bead.text_length = data_elements;

	character_pos = 1;
	do line_count = lbound (function_info.line_info, 1) to function_info.number_of_lines;

	     substr (function_bead_ptr -> function_bead.text, character_pos, function_info.line_info(line_count).line_length) =
		substr (edit_buffer, function_info.line_info(line_count).line_start, function_info.line_info(line_count).line_length);

	     character_pos = character_pos + function_info.line_info(line_count).line_length;
	end;

	scratch_space_ptr = addrel (function_info.edit_buffer_ptr, divide (function_info.first_unused_char_in_buffer + 3, 4, 17, 0));

	call apl_function_lex_ (function_bead_ptr -> function_bead.text, lexed_function_bead_ptr, lex_errors_occurred, 0, scratch_space_ptr);

	function_bead_ptr -> function_bead.lexed_function_bead_pointer = lexed_function_bead_ptr;

	if lex_errors_occurred
	     then do;

		code = -1;

		if function_info.locked_function
		     then do;

			function_bead_ptr -> function_bead.class = 0;
			function_info.locked_function = "0"b;

			call iox_$put_chars (apl_static_$apl_output, addr (unlocked_message), length (unlocked_message),
			     code);
		     end;

		/* Find out if header is valid, and if so hack the meaning
		   pointer to save the function definition. */

		call parse_function_name_and_args (substr (edit_buffer, function_info.line_info(1).line_start,
		     function_info.line_info(1).line_length), 1, (0), function_name, (""), (""), (""), ("0"b), ("0"b),
		     bad_header);

		if bad_header
		     then do;
			code = apl_error_table_$bad_function_header;
			return;
		     end;

		call apl_get_symbol_ ((function_name), symbol_ptr, (0));

		function_info.symbol_ptr = symbol_ptr;	/* remember symbol ptr */
	     end;  /* if lex_errors_occurred */

	     else symbol_ptr = lexed_function_bead_ptr -> lexed_function_bead.name;

	call decrement_reference_count (symbol_ptr -> symbol_bead.meaning_pointer);
	symbol_ptr -> symbol_bead.meaning_pointer = function_bead_ptr;
	function_bead_ptr -> function_bead.reference_count = 1;

	/* Renumber all the lines if there were errors */

	if lex_errors_occurred
	     then do;
		call assign_line_numbers (function_info);
		current_line_number = function_info.line_info(function_info.number_of_lines).line_number + 1;
	     end;

	last_frame_was_suspended = "0"b;
	reported_si_damage = "0"b;

	/* See if the function we have just finished editing successfully is on the SI.
	   We check now, as well as at the beginning, because the user could have renamed
	   the function while editing it. */

	if ^lex_errors_occurred
	then do parse_frame_ptr = ws_info.current_parse_frame_ptr repeat (parse_frame.last_parse_frame_ptr)
		while (parse_frame_ptr ^= null ());

		if parse_frame.parse_frame_type = suspended_frame_type
		then last_frame_was_suspended = "1"b;
		else do;

		     code = 0;

		     if parse_frame.parse_frame_type = function_frame_type
		     then if parse_frame.lexed_function_bead_ptr -> lexed_function_bead.name = symbol_ptr
			then if last_frame_was_suspended
			     then do;

/* We have found a suspended instance of this function.  See if
   they match.  We have prevented some kinds of errors by
   refusing to let the user edit the header, but by renaming the
   function, or by adding/deleting/reordering labels, he could
   still screw us.  */

				code = check_function_compatibility (parse_frame.lexed_function_bead_ptr,
				     lexed_function_bead_ptr);

				if code = 0
				then do;
					call decrement_reference_count (parse_frame.function_bead_ptr);
					call decrement_reference_count (parse_frame.lexed_function_bead_ptr);

					parse_frame.function_bead_ptr = function_bead_ptr;
					function_bead_ptr -> general_bead.reference_count =
					     function_bead_ptr -> general_bead.reference_count + 1;

					parse_frame.lexed_function_bead_ptr = lexed_function_bead_ptr;

					lexed_function_bead_ptr -> general_bead.reference_count =
					     lexed_function_bead_ptr -> general_bead.reference_count + 1;
				     end;
				end;
			     else code = apl_error_table_$edited_pendent_fcn;

		     if code ^= 0
		     then do;
			     if ^reported_si_damage
			     then call report_error (code, "", 0);

			     reported_si_damage = "1"b;
			end;

		     last_frame_was_suspended = "0"b;
		     end;
	     end;

	if function_info.locked_function
	     then do;

		function_bead_ptr -> function_bead.class = 1;
		function_bead_ptr -> function_bead.stop_control_pointer = null ();
		function_bead_ptr -> function_bead.trace_control_pointer = null ();
	     end;
	     else do;

		function_bead_ptr -> function_bead.class = 0;
		function_bead_ptr -> function_bead.stop_control_pointer = function_info.saved_stop_vector;
		if function_info.saved_stop_vector ^= null ()
		     then function_info.saved_stop_vector -> general_bead.reference_count =
			function_info.saved_stop_vector -> general_bead.reference_count + 1;

		function_bead_ptr -> function_bead.trace_control_pointer = function_info.saved_trace_vector;
		if function_info.saved_trace_vector ^= null ()
		     then function_info.saved_trace_vector -> general_bead.reference_count =
			function_info.saved_trace_vector -> general_bead.reference_count + 1;
	     end;

	return;

check_function_compatibility:
     procedure (P_old_lfbp, P_new_lfbp) returns (fixed bin (35));

/* parameters */

declare	(P_old_lfbp, P_new_lfbp) ptr unal parameter;

/* automatic */

declare	indx fixed bin (17),
	new_labels_ptr ptr,
	new_lfbp ptr,
	old_labels_ptr ptr,
	old_lfbp ptr;

/* external static */

declare	(apl_error_table_$labels_differ,
	apl_error_table_$locals_differ,
	apl_error_table_$n_labels_differ,
	apl_error_table_$n_locals_differ) fixed bin (35) external static;

/* program */

	old_lfbp = P_old_lfbp;
	new_lfbp = P_new_lfbp;

	if (old_lfbp -> lexed_function_bead.number_of_labels =
	     new_lfbp -> lexed_function_bead.number_of_labels)
	then if (old_lfbp -> lexed_function_bead.number_of_localized_symbols =
		new_lfbp -> lexed_function_bead.number_of_localized_symbols)
	     then do;

/* We know they have the same number of locals, see if the names match */

		     do indx = 1 to old_lfbp -> lexed_function_bead.number_of_localized_symbols -
			old_lfbp -> lexed_function_bead.number_of_labels;

			if old_lfbp -> lexed_function_bead.localized_symbols (indx) ^=
			     new_lfbp -> lexed_function_bead.localized_symbols (indx)
			then return (apl_error_table_$locals_differ);
		     end;

/* We know they have the same number of labels. See if they are the same names,
   in the same order. */

		     old_labels_ptr = old_lfbp -> lexed_function_bead.label_values_ptr;
		     new_labels_ptr = new_lfbp -> lexed_function_bead.label_values_ptr;

		     do indx = 1 to old_lfbp -> lexed_function_bead.number_of_labels;
			if old_labels_ptr -> lexed_function_label_values (indx) ^=
			     new_labels_ptr -> lexed_function_label_values (indx)
			then return (apl_error_table_$labels_differ);
		     end;

		     return (0);
		end;
	     else return (apl_error_table_$n_locals_differ);

	return (apl_error_table_$n_labels_differ);

     end check_function_compatibility;

     end close_function;

process_bracket_contents:
	procedure (input_buffer, input_line_length, character_pos, current_line_number, function_info);

dcl	input_buffer char(*) parameter;
dcl	input_line_length fixed bin(21);
dcl	character_pos fixed bin parameter;
dcl	current_line_number fixed decimal(10, 5) parameter;
%include	apl_function_info;

/* Automatic */

dcl	(state, last_state) fixed bin;

dcl	count fixed bin;
dcl	(token_type, token_start) fixed bin;
dcl	gotten_number fixed decimal (10,5);
dcl	(left_number, right_number) fixed decimal (10,5);

/* Based */

dcl	input_line char(input_line_length) based (addr (input_buffer));

/* External */

dcl	(apl_error_table_$empty_editor_brackets,
	apl_error_table_$missing_quad_or_rb,
	apl_error_table_$missing_number_or_rb,
	apl_error_table_$missing_rb,
	apl_error_table_$missing_number,
	apl_error_table_$bad_token_in_brackets,
	apl_error_table_$suspended_header,
	apl_error_table_$extra_text)
	fixed bin(35) external;

/* Internal Static */

/* States:  LB = Left Bracket, N = Number, Quad and Delta are themselves */

dcl      (LB		init (0),
	LB_N		init (1),
	LB_N_Quad		init (2),
	LB_N_Quad_N	init (3),
	LB_Quad		init (4),
	LB_Quad_N		init (5),
	LB_Delta		init (6),
	LB_Delta_N	init (7),
	Done		init (8),
	Empty_Brackets	init (9),
	Not_Quad_or_RB	init (10),
	Not_N_or_RB	init (11),
	Not_RB		init (12),
	Not_N		init (13))
         fixed bin internal static options (constant);

dcl	first_time_in_process bit (1) aligned initial ("1"b) internal static;
dcl	state_table(0:7, 4) fixed bin internal static;

dcl      (Number_Token	init (1),
	Quad_Token	init (2),
	Delta_Token	init (3),
	RB_Token		init (4),
	Bad_Token		init (5))
         fixed bin internal static options (constant);

/* Program */

	if first_time_in_process
	then do;
		state_table(LB, Number_Token) = LB_N;
		state_table(LB, Quad_Token) = LB_Quad;
		state_table(LB, Delta_Token) = LB_Delta;
		state_table(LB, RB_Token) = Empty_Brackets;

		state_table(LB_N, Number_Token) = Not_Quad_or_RB;
		state_table(LB_N, Quad_Token) = LB_N_Quad;
		state_table(LB_N, Delta_Token) = Not_Quad_or_RB;
		state_table(LB_N, RB_Token) = Done;

		state_table(LB_N_Quad, Number_Token) = LB_N_Quad_N;
		state_table(LB_N_Quad, Quad_Token) = Not_N_or_RB;
		state_table(LB_N_Quad, Delta_Token) = Not_N_or_RB;
		state_table(LB_N_Quad, RB_Token) = Done;

		state_table(LB_N_Quad_N, Number_Token) = Not_RB;
		state_table(LB_N_Quad_N, Quad_Token) = Not_RB;
		state_table(LB_N_Quad_N, Delta_Token) = Not_RB;
		state_table(LB_N_Quad_N, RB_Token) = Done;

		state_table(LB_Quad, Number_Token) = LB_Quad_N;
		state_table(LB_Quad, Quad_Token) = Not_N_or_RB;
		state_table(LB_Quad, Delta_Token) = Not_N_or_RB;
		state_table(LB_Quad, RB_Token) = Done;

		state_table(LB_Quad_N, Number_Token) = Not_RB;
		state_table(LB_Quad_N, Quad_Token) = Not_RB;
		state_table(LB_Quad_N, Delta_Token) = Not_RB;
		state_table(LB_Quad_N, RB_Token) = Done;

		state_table(LB_Delta, Number_Token) = LB_Delta_N;
		state_table(LB_Delta, Quad_Token) = Not_N;
		state_table(LB_Delta, Delta_Token) = Not_N;
		state_table(LB_Delta, RB_Token) = Not_N;

		state_table(LB_Delta_N, Number_Token) = Not_RB;
		state_table(LB_Delta_N, Quad_Token) = Not_RB;
		state_table(LB_Delta_N, Delta_Token) = Not_RB;
		state_table(LB_Delta_N, RB_Token) = Done;

		first_time_in_process = "0"b;
	     end;

	state = LB;
	character_pos = character_pos + 1;	/* flush the LB */

process_another:

	last_state = state;

	call get_next_bracket_token (input_line, character_pos, token_type, token_start, gotten_number);

	if token_type = Bad_Token
	     then call error (apl_error_table_$bad_token_in_brackets, input_line, token_start);

	state = state_table (last_state, token_type);

	go to new_state(state);

new_state(1):	/* LB_N */

	/* If function is suspended, user is not allowed to edit header.
	   Check for left number = 0, and barf. If in any future changes,
	   a left number of 0 does not refer to line 0, this code will have
	   to be changed. */

	if gotten_number = 0
	     then if function_info.suspended_function
		then call error (apl_error_table_$suspended_header, input_line, token_start);

	left_number = gotten_number;
	go to process_another;

new_state(7):	/* LB_Delta_N */

	/* Check for attempt to delete header of suspended function */

	if gotten_number = 0
	     then if function_info.suspended_function
		then call error (apl_error_table_$suspended_header, input_line, token_start);

new_state(3):	/* LB_N_Quad_N */
new_state(5):	/* LB_Quad_N */

	right_number = gotten_number;
	go to process_another;

new_state(2):	/* LB_N_Quad */
new_state(4):	/* LB_Quad */
new_state(6):	/* LB_Delta */

	go to process_another;

new_state(8):	/* Done */

	go to perform_action(last_state);

new_state(9):	/* Empty_Brackets */

	call error (apl_error_table_$empty_editor_brackets, input_line, token_start);

new_state(10):	/* Not_Quad_or_RB */

	call error (apl_error_table_$missing_quad_or_rb, input_line, token_start);

new_state(11):	/* Not_N_or_RB */

	call error (apl_error_table_$missing_number_or_rb, input_line, token_start);

new_state(12):	/* Not_RB */

	call error (apl_error_table_$missing_rb, input_line, token_start);

new_state(13):	/* Not_N */

	call error (apl_error_table_$missing_number, input_line, token_start);


/* This is where the actual actions begin. The entire line has been parsed
   so that we know exactly what to do. */

perform_action(1):		/* LB_N */

	current_line_number = left_number;
	return;

perform_action(2):		/* LB_N_Quad */

	call print_function_lines (left_number, 1, function_info);
	current_line_number = left_number;
	return;

perform_action(3):		/* LB_N_Quad_N */

	if character_pos < length (input_line)
	     then call error (apl_error_table_$extra_text, input_line, character_pos);

	call edit_one_line (input_buffer, input_line_length, character_pos, left_number, right_number, current_line_number, function_info);
	return;

perform_action(4):		/* LB_Quad */

	call print_function_lines (0, 2, function_info);
	return;

perform_action(5):		/* LB_Quad_N */

	call print_function_lines (right_number, 2, function_info);
	return;

perform_action(7):		/* LB_Delta_N */

	do count = lbound (function_info.line_info, 1) to function_info.number_of_lines
	     while (function_info.line_info(count).line_number < right_number);
	end;

	if count ^> function_info.number_of_lines
	     then if function_info.line_info(count).line_number = right_number
		then do;

		     do count = count to function_info.number_of_lines - 1;

			function_info.line_info(count) = function_info.line_info(count + 1);
		     end;

		     function_info.number_of_lines = function_info.number_of_lines - 1;
		end;

	current_line_number = right_number;
	return;

get_next_bracket_token:
	procedure (input_line, character_pos, token_type, token_start, gotten_number);
	
dcl	input_line char(*) parameter;
dcl	character_pos fixed bin parameter;
dcl	token_type fixed bin parameter;
dcl	token_start fixed bin parameter;
dcl	gotten_number fixed decimal (10,5) parameter;

/* Automatic */

dcl	character char(1);
dcl	number_length fixed bin;
dcl	whitespace char(2) init (" 	");		/* space, tab */

dcl	conversion condition;

	character_pos = character_pos + verify (substr (input_line, character_pos), whitespace) - 1;

	token_start = character_pos;

	character = substr (input_line, character_pos, 1);

	if index ("0123456789.", character) ^= 0
	     then do;

		number_length = verify (substr (input_line, character_pos), "0123456789.") - 1;

		on conversion
		     goto got_bad_token;

		gotten_number = fixed (substr (input_line, character_pos, number_length), 10, 5);
		revert conversion;

		character_pos = character_pos + number_length;

		token_type = Number_Token;
	     end;

	     else do;
		if character = QQuad
		     then token_type = Quad_Token;

		     else if character = QDelta
			then token_type = Delta_Token;

			else if character = QRightBracket
			     then token_type = RB_Token;

			else do;
got_bad_token:
			     token_type = Bad_Token;
			     return;
			end;

		character_pos = character_pos + 1;
	     end;

end;  /* get_next_bracket_token */

end; /* process_bracket_contents */

context_editor:
	procedure (input_buffer, input_line_length, character_pos, current_line_number, function_info, saved_search_string);

dcl	input_buffer char(*) parameter;
dcl	input_line_length fixed bin(21);
dcl	character_pos fixed bin parameter;
dcl	current_line_number fixed decimal(10, 5) parameter;
%include	apl_function_info;
dcl	saved_search_string char(128) varying parameter;

/* Automatic */

dcl	char char(1);

/* Based */

dcl	input_line char(input_line_length) based (addr (input_buffer));

/* External */

dcl	apl_error_table_$bad_context_request external fixed bin(35);
dcl	apl_static_$apl_output external ptr;

/* Entries */

dcl	ioa_$ioa_switch entry() options(variable);

/* Include */

%include	apl_characters;


	character_pos = character_pos + 1;

	/* Line has at least a NL in it, so this substr won't fail */

	char = substr (input_line, character_pos, 1);

	if char = QSlash
	     then call context_search (input_line, character_pos, current_line_number, function_info, saved_search_string, "0"b);

	     else if char = QLessThan			/* reverse search */
		then do;
		     character_pos = character_pos + 1;
		     char = substr (input_line, character_pos, 1);

		     if char = QSlash
			then call context_search (input_line, character_pos, current_line_number, function_info, saved_search_string, "1"b);
			else call error (apl_error_table_$bad_context_request, input_line, character_pos);
		end;

		else if char = QLetterS
		     then call context_substitute (input_line, character_pos, current_line_number, function_info, saved_search_string);

		     else if char = QLetterG
			then call context_global_print (input_line, character_pos, function_info, saved_search_string);
			else call error (apl_error_table_$bad_context_request, input_line, character_pos);

	if character_pos < length (input_line)
	     then do;
		call ioa_$ioa_switch (apl_static_$apl_output, "extra text follows context request");
		call error (0, "", 0);
	     end;

	return;

context_search:
	procedure (input_line, character_pos, current_line_number, function_info, saved_search_string, reverse_search);

dcl	input_line char(*) parameter;
dcl	character_pos fixed bin parameter;
dcl	current_line_number fixed decimal(10, 5) parameter;
%include	apl_function_info;
dcl	saved_search_string char(128) varying parameter;
dcl	reverse_search bit(1) parameter;

/* Automatic */

dcl	search_string_start fixed bin;
dcl	search_string char (128) varying;
dcl	starting_line_idx fixed bin;
dcl	increment fixed bin;
dcl	end_of_first_half fixed bin;
dcl	start_of_second_half fixed bin;
dcl	idx fixed bin;
dcl	line_idx fixed bin;

/* External */

dcl	apl_static_$apl_output external ptr;
dcl	apl_error_table_$missing_slash external fixed bin(35);
dcl	sys_info$max_seg_size external fixed bin;

/* Based */

dcl	edit_buffer char(sys_info$max_seg_size * 4) based (function_info.edit_buffer_ptr);

/* Entries */

dcl	ioa_$ioa_switch entry options (variable);

/* Program */

	character_pos = character_pos + 1;		/* skip "/" */
	search_string_start = character_pos;

	/* Move forward to next "/" */

	idx = index (substr (input_line, character_pos), QSlash);

	if idx = 0
	     then do;
		character_pos = input_line_length + 1;
		call error (apl_error_table_$missing_slash, input_line, character_pos);
	     end;

	character_pos = character_pos + idx - 1;

	search_string = substr (input_line, search_string_start, character_pos - search_string_start);	/* drop trailing "/" */

	/* Hack empty search string to use previous */

	if search_string = ""
	     then search_string = saved_search_string;
	     else saved_search_string = search_string;

	character_pos = character_pos + 1;		/* move over slash */

	/* Get index into function line array of current line */

	call get_line_info_idx (current_line_number, starting_line_idx, function_info, code);

	/* If code is not zero, the current_line does not exist.  If we are
	   past the end of the lines array, start at the beginning. */

	if code ^= 0
	     then if starting_line_idx > function_info.number_of_lines
		then starting_line_idx = lbound (function_info.line_info, 1);


	/* Loop through lines looking for match starting at the line
	     after (or before) and wrapping around at the bottom (or top)
	     of the function.  Set up the proper loop variables. */

	if reverse_search
	     then do;
		increment = -1;
		end_of_first_half = 1;		/* back to line 1 */
		start_of_second_half = function_info.number_of_lines;
	     end;
	     else do;
		increment = 1;
		end_of_first_half = function_info.number_of_lines;
		start_of_second_half = 1;		/* start again at top */
	     end;

	do line_idx = starting_line_idx + increment to end_of_first_half by increment,
	     start_of_second_half to starting_line_idx by increment;

	     /* Does current line match? */

	     idx = index (substr (edit_buffer, function_info.line_info(line_idx).line_start, function_info.line_info(line_idx).line_length), search_string);

	     if idx ^= 0
		then do;

		     current_line_number = function_info.line_info(line_idx).line_number;
		     call print_function_lines (current_line_number, 1, function_info);

		     return;
		end;
	end;

	call ioa_$ioa_switch (apl_static_$apl_output, "search fails");
	call error (0, "", 0);

  end;  /* context_search */

context_substitute:
	procedure (input_line, character_pos, current_line_number, function_info, saved_search_string);

dcl	input_line char(*) parameter;
dcl	character_pos fixed bin parameter;
dcl	current_line_number fixed decimal(10, 5) parameter;
%include	apl_function_info;
dcl	saved_search_string char(128) varying parameter;

/* Automatic */

dcl	string_start fixed bin;
dcl	(string1, string2) char(128) varying;
dcl	idx fixed bin;
dcl	verify_substitute bit(1) init ("0"b);
dcl	show_substitute bit(1) init ("0"b);
dcl	line_idx fixed bin;
dcl	(old_start, old_length) fixed bin;
dcl	first_free_char fixed bin;
dcl	old_tail_length fixed bin;
dcl	answer_buffer char(5);
dcl	answer_length fixed bin(21);
dcl	prompt_string char(14) varying;

/* Based */

dcl	edit_buffer char(4 * sys_info$max_seg_size) based (function_info.edit_buffer_ptr);

/* External */

dcl	apl_error_table_$missing_slash external fixed bin(35);
dcl	apl_error_table_$bad_substitute external fixed bin(35);
dcl	apl_static_$apl_output external ptr;
dcl	sys_info$max_seg_size fixed bin(35) ext static;

/* Entries */

dcl	ioa_$ioa_switch entry() options(variable);

/* Program */

	character_pos = character_pos + 1;		/* skip "s" */

	if substr (input_line, character_pos, 1) ^= QSlash
	     then call error (apl_error_table_$bad_substitute, input_line, character_pos);

	character_pos = character_pos + 1;		/* skip slash */

	string_start = character_pos;

	/* find first terminating slash */

	idx = index (substr (input_line, character_pos), QSlash);

	if idx = 0
	     then do;
		character_pos = input_line_length + 1;
		call error (apl_error_table_$missing_slash, input_line, character_pos);
	     end;

	character_pos = character_pos + idx - 1;

	string1 = substr (input_line, string_start, character_pos - string_start);

	/* If string1 is empty use previous string */

	if string1 = ""
	     then string1 = saved_search_string;
	     else saved_search_string = string1;

	character_pos = character_pos + 1;		/* skip past slash */

	string_start = character_pos;

	idx = index (substr (input_line, character_pos), QSlash);

	if idx = 0
	     then do;
		character_pos = input_line_length + 1;
		call error (apl_error_table_$missing_slash, input_line, character_pos);
	     end;

	character_pos = character_pos + idx - 1;

	string2 = substr (input_line, string_start, character_pos - string_start);

	character_pos = character_pos + 1;		/* skip over "/" */

	/* Check for verification request */

	if length (input_line) >= character_pos
	     then do;

		char = substr (input_line, character_pos, 1);

		if char = QQuestion
		     then verify_substitute = "1"b;

		if char = QLetterP
		     then show_substitute = "1"b;

		character_pos = character_pos + 1;

	     end;

	/* look up line info index */

	call get_line_info_idx (current_line_number, line_idx, function_info, code);

	if code ^= 0
	     then do;
		call ioa_$ioa_switch (apl_static_$apl_output, "substitute fails - line is empty");
		call error (0, "", 0);
	     end;

	old_start = function_info.line_info(line_idx).line_start;
	old_length = function_info.line_info(line_idx).line_length;

	idx = index (substr (edit_buffer, old_start, old_length), string1);

	if idx = 0				/* no string1 */
	     then do;
		call ioa_$ioa_switch (apl_static_$apl_output, "substitute fails - no match in line");
		call error (0, "", 0);
	     end;

	/* Build new line in edit_buffer.  This should really be done
	   by some managing routine. */

	first_free_char = function_info.first_unused_char_in_buffer;

	/* first add part of line before string1 */

	substr (edit_buffer, first_free_char, idx - 1) = substr (edit_buffer, old_start, idx - 1);

	first_free_char = first_free_char + idx - 1;

	/* now splice in string2 */

	substr (edit_buffer, first_free_char, length (string2)) = string2;

	first_free_char = first_free_char + length (string2);

	/* now add end of old line */

	old_tail_length = old_length - (idx + length (string1)) + 1;

	substr (edit_buffer, first_free_char, old_tail_length) = substr (edit_buffer, old_start + (idx + length (string1)) - 1, old_tail_length);

	first_free_char = first_free_char + old_tail_length;

	if verify_substitute
	     then do;

		prompt_string = line_number_to_string (function_info.line_info(line_idx).line_number);

		call ioa_$ioa_switch (apl_static_$apl_output, "^va^a", length (prompt_string), prompt_string, substr (edit_buffer, function_info.first_unused_char_in_buffer, first_free_char - function_info.first_unused_char_in_buffer));

ask_if_substitute_is_ok:
		call ioa_$ioa_switch (apl_static_$apl_output, "ok? ");

		call read_line (answer_buffer, answer_length);
		answer_length = answer_length - 1;	/* drop NL */

		if substr (answer_buffer, 1, answer_length) = "no"
		     then return;
		     else if substr (answer_buffer, 1, answer_length) ^= "yes"
			then do;
			     call ioa_$ioa_switch (apl_static_$apl_output, "please answer yes or no");
			     goto ask_if_substitute_is_ok;
			end;
	     end;

	/* At this point we know that the substitution has passed
	   verification (if any) and should actually be done. This is
	   accomplished by changing the function_info entry for the line
	   to point at the newly constructed line. */

	function_info.line_info(line_idx).line_start = function_info.first_unused_char_in_buffer;
	function_info.line_info(line_idx).line_length = first_free_char - function_info.first_unused_char_in_buffer;
	function_info.first_unused_char_in_buffer = first_free_char;

	if show_substitute
	     then call print_function_lines (function_info.line_info(line_idx).line_number, 1, function_info);

	return;

  end;  /* context_substitute */

context_global_print:
	procedure (input_line, character_pos, function_info, saved_search_string);

dcl	input_line char(*) parameter;
dcl	character_pos fixed bin parameter;
%include	apl_function_info;
dcl	saved_search_string char(128) varying parameter;

dcl	string_start fixed bin;
dcl	idx fixed bin;
dcl	string char(128) varying;
dcl	first_idx fixed bin;
dcl	line_idx fixed bin;
dcl	line_start fixed bin;
dcl	line_length fixed bin;

dcl	edit_buffer char(4 * sys_info$max_seg_size) based (function_info.edit_buffer_ptr);

dcl	apl_error_table_$bad_global_print external fixed bin(35);
dcl	apl_error_table_$missing_slash external fixed bin(35);
dcl	sys_info$max_seg_size external fixed bin(35);


	character_pos = character_pos + 1;		/* skip "g" */

	if substr (input_line, character_pos, 1) ^= QSlash
	     then call error (apl_error_table_$bad_global_print, input_line, character_pos);

	character_pos = character_pos + 1;		/* skip slash */

	string_start = character_pos;

	/* find first terminating slash */

	idx = index (substr (input_line, character_pos), QSlash);

	if idx = 0
	     then do;
		character_pos = input_line_length + 1;
		call error (apl_error_table_$missing_slash, input_line, character_pos);
	     end;

	character_pos = character_pos + idx - 1;

	string = substr (input_line, string_start, character_pos - string_start);

	/* If string is empty use previous string */

	if string = ""
	     then string = saved_search_string;
	     else saved_search_string = string;

	character_pos = character_pos + 1;		/* skip past slash */

	first_idx = lbound (function_info.line_info, 1);

	do line_idx = first_idx to function_info.number_of_lines;

	     line_start = function_info.line_info(line_idx).line_start;
	     line_length = function_info.line_info(line_idx).line_length;

	     idx = index (substr (edit_buffer, line_start, line_length), string);

	     if idx ^= 0
		then call print_function_lines (function_info.line_info(line_idx).line_number, 1, function_info);
	end;

	return;

end; /* context_global_print */

end;  /* context_editor */

process_new_function_line:
	procedure (initial_input_line, character_pos, current_line_number, function_info);

dcl	initial_input_line char(*) parameter;
dcl	character_pos fixed bin parameter;
dcl	current_line_number fixed decimal(10, 5) parameter;
%include	apl_function_info;

/* Automatic */

dcl	input_buffer char(256);
dcl	input_line_length fixed bin(21);
dcl	(line_pos, del_pos) fixed bin;
dcl	(in_quotes, was_in_quotes, got_line, replacing_old_line) bit(1);
dcl	(count, line_info_idx) fixed bin;

/* Based */

dcl	input_line char(input_line_length) based (addr (input_buffer));
dcl	edit_buffer char(sys_info$max_seg_size * 4) based (function_info.edit_buffer_ptr);

/* External */

dcl	sys_info$max_seg_size external fixed bin;
dcl	apl_error_table_$mismatched_editor_quotes external fixed bin(35);

dcl	(length, substr, ltrim) builtin;

/* Program */

	call get_line_info_idx (current_line_number, line_info_idx, function_info, code);

	if code = 0
	     then replacing_old_line = "1"b;
	     else do;
		replacing_old_line = "0"b;

		/* There is no existing line for current_line_number, but
		   line_info_idx points to where it should be. If that
		   place is in the middle of existing lines, lines have to
		   be moved to make room */

		if line_info_idx <= function_info.number_of_lines
		     then do count = function_info.number_of_lines to line_info_idx by -1;
			function_info.line_info(count + 1) = function_info.line_info(count);
		     end;

		/* no else clause, line_info_idx is after the last existing
		   line, so we can just add the line (note that all of this
		   code assumes that we never get more lines than the
		   line_info array is long. this should be fixed.) */

	     end;  /* else do */

	input_buffer = substr (initial_input_line, character_pos);
	input_line_length = length (substr (initial_input_line, character_pos));

	in_quotes = "0"b;
	was_in_quotes = "0"b;
	got_line = "0"b;

	do while (^got_line);

	     del_pos = 0;
	     do line_pos = 1 to length (input_line) - 1;

		character = substr (input_line, line_pos, 1);

		if character = QApostrophe
		     then in_quotes = ^in_quotes;

		if character = QDel | character = QDelTilde
		     then del_pos = line_pos;
	     end;

	     if ^was_in_quotes
		then function_info.line_info(line_info_idx).line_start = function_info.first_unused_char_in_buffer;

	     if del_pos ^= 0
		then do;

		     if in_quotes
			then call error (apl_error_table_$mismatched_editor_quotes, input_line, line_pos);

		     substr (edit_buffer, function_info.first_unused_char_in_buffer, del_pos) =
			substr (input_line, 1, del_pos - 1) || QNewLine;

		     function_info.first_unused_char_in_buffer = function_info.first_unused_char_in_buffer + del_pos;

		     got_line = "1"b;

		     character_pos = character_pos + del_pos - 1;
		end;
		else do;

		     if in_quotes
			then was_in_quotes = "1"b;
			else do;
			     got_line = "1"b;
			     character_pos = length (initial_input_line) + 1;
			end;

		     substr (edit_buffer, function_info.first_unused_char_in_buffer, length (input_line)) = ltrim (input_line);

		     function_info.first_unused_char_in_buffer = function_info.first_unused_char_in_buffer + length (ltrim (input_line));

		     if ^got_line
			then call read_line (input_buffer, input_line_length);
		end;
	end;

	function_info.line_info(line_info_idx).line_number = current_line_number;
	function_info.line_info(line_info_idx).line_length = function_info.first_unused_char_in_buffer -
	     function_info.line_info(line_info_idx).line_start;

	if ^replacing_old_line
	     then function_info.number_of_lines = function_info.number_of_lines + 1;

	return;
end; /* process_new_function_line */

parse_header_line:
	procedure (line_to_parse, character_pos, header_start, header_length, complicated_header, function_info);

dcl	line_to_parse char(*) parameter;		/* contains header line and maybe other stuff */ 
dcl	character_pos fixed bin parameter;		/* where we are in line */
dcl	(header_start, header_length) fixed bin parameter;/* return info about actual header line */
dcl	complicated_header bit(1) parameter;		/* return: true if args or return var found */
%include	apl_function_info;

/* Automatic */

dcl	(token_start, token_length) fixed bin;
dcl	(done, last_token_was_semicolon, ran_out_of_tokens, bad_header) bit(1);
dcl	code2 fixed bin(35);

/* Based */

dcl	character_array_kludge(length (line_to_parse)) char(1) based (addr (line_to_parse));
dcl	token char(token_length) based (addr (character_array_kludge(token_start)));

/* Program */

	header_start = character_pos;

	call parse_function_name_and_args (line_to_parse, character_pos, header_start, function_info.name, function_info.args(0), function_info.args(1), function_info.args(2), complicated_header, ran_out_of_tokens, bad_header);

	if bad_header
	     then call apl_editor_cleanup (function_info);

	header_length = character_pos - header_start;

	if ran_out_of_tokens
	     then return;

	/* Now process local variables */

	done = "0"b;
	do while (^done);

	     call get_header_token (line_to_parse, character_pos, token_start, token_length, code2);   /* "token" depends on vals of token_(start length) */

	     if code2 ^= 0
		then done = "1"b;

		else if token = QLamp
		     then do;
			character_pos = length (line_to_parse) + 1;
			done = "1"b;
		     end;

		     else if token = QSemiColon
			then last_token_was_semicolon = "1"b;

			else do;  /* could be var or non-header stuff */

			     if ^last_token_was_semicolon
				then do;
				     character_pos = token_start;
				     done = "1"b;
				end;

				else do;  /* we did see semi, this could be var name */

				     call validate_identifier (token, code2);

				     if code2 ^= 0
					then do;
					     character_pos = token_start;	/* back up over token */
					     done = "1"b;
					end;

				end;

			     last_token_was_semicolon = "0"b;

			end;  /* else do */
	end;  /* do while (^done)... */

	header_length = character_pos - header_start;
	return;


end;  /* parse_header_line */

parse_function_name_and_args:
	procedure (line_to_parse, character_pos, header_start, function_name, right_arg, left_arg, return_arg, complicated_header, ran_out_of_tokens, bad_header);

dcl	line_to_parse char(*) parameter;
dcl	character_pos fixed bin parameter;
dcl	header_start fixed bin parameter;
dcl	(function_name, right_arg, left_arg, return_arg) char(*) varying parameter;
dcl	(complicated_header, ran_out_of_tokens, bad_header) bit(1) parameter;

/* Automatic */

dcl	(id_number, phony_number_of_ids, last_identifier) fixed bin;
dcl	(found_left_arrow, done) bit(1);
dcl	old_character_pos fixed bin;
dcl	(token_start, token_length) fixed bin;
dcl	code fixed bin(35);

dcl	1 identifiers(4),
	  2 name char(256) varying init ((4)(1)""),
	  2 position fixed bin;

/* Based */

dcl	character_array_kludge(length (line_to_parse)) char(1) based (addr (line_to_parse));
dcl	token char(token_length) based (addr (character_array_kludge(token_start)));

/* External */

dcl	(apl_error_table_$misplaced_left_arrow,
	apl_error_table_$missing_function_name)
	external fixed bin(35);

/* Program */

	function_name, right_arg, left_arg, return_arg = "";
	complicated_header, ran_out_of_tokens, bad_header = "0"b;

	done, found_left_arrow = "0"b;
	do id_number = 1 to 4 while (^ran_out_of_tokens & ^done);

	     old_character_pos = character_pos;

	     call get_header_token (line_to_parse, character_pos, token_start, token_length, code);
	     if code ^= 0			/* no more tokens */
		then ran_out_of_tokens = "1"b;
		else if token = QLamp
		     then do;
			character_pos = length (line_to_parse) + 1;
			ran_out_of_tokens = "1"b;
		     end;
		     else do;
			if token = QLeftArrow
			     then do;

			     /* Found a left arrow. First token must have
				been the return var. */

				if id_number ^= 2
				     then do;
					call report_error (apl_error_table_$misplaced_left_arrow, line_to_parse, token_start);
					bad_header = "1"b;
					return;
				     end;

				call get_header_token (line_to_parse, character_pos, token_start, token_length, code);
				if code ^= 0
				     then do;
					call report_error (apl_error_table_$missing_function_name, line_to_parse, character_pos);
					bad_header = "1"b;
					return;
				     end;
				
				found_left_arrow = "1"b;

			     end; /* if token = QLeftArrow */

			call validate_identifier (token, code);
			if code = 0
			     then do;
				identifiers(id_number).name = token;
				identifiers(id_number).position = token_start;
			     end;
			     else do;
				character_pos = old_character_pos;
				done = "1"b;
			     end;

		     end;  /* else do; if token = QLeftArrow... */

	end;  /* do id_number... */

	if identifiers(1).name = ""
	     then do;
		call report_error (apl_error_table_$missing_function_name, line_to_parse, token_start);
		bad_header = "1"b;
		return;
	     end;

	header_start = identifiers(1).position;

	if ran_out_of_tokens | done
	     then last_identifier = id_number - 2;
	     else last_identifier = id_number - 1;

	if found_left_arrow
	     then do;

		/* First identifier was the return var. */

		return_arg = identifiers(1).name;
		complicated_header = "1"b;
		phony_number_of_ids = last_identifier - 1;  /* subtract one for the return var */
	     end;
	     else phony_number_of_ids = last_identifier;

	/* Step through and figure out which identifiers are which header
	   components. */

	if phony_number_of_ids = 3	/* left_arg function_name right_arg */
	     then do;

		function_name = identifiers(last_identifier - 1).name;
		right_arg = identifiers(last_identifier).name;
		left_arg = identifiers(last_identifier - 2).name;
		complicated_header = "1"b;
	     end;
	     else if phony_number_of_ids = 2	/* function_name right_arg */
		then do;

		     function_name = identifiers(last_identifier - 1).name;
		     right_arg = identifiers(last_identifier).name;
		     complicated_header = "1"b;
		end;
		else if phony_number_of_ids = 1	/* function_name */
		     then function_name = identifiers(last_identifier).name;

	return;
end; /* parse_function_name_and_args */

get_header_token:
	procedure (line_to_parse, character_pos, token_start, token_length, code);

dcl	line_to_parse char(*) parameter;
dcl	character_pos fixed bin parameter;
dcl	(token_start, token_length) fixed bin parameter;
dcl	code fixed bin(35);

/* Automatic */

dcl	new_pos fixed bin;

/* Static */

dcl	whitespace_string char(2) static options (constant) init (" 	");	/* SPACE, TAB */
dcl	good_chars_in_identifier char(76) static options (constant) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_");	/* Last ones are QZero_ thru QNine_, QDelta, QQuad, QDelta_ and _ */

/* Program */

	code = 0;

	if character_pos > length (line_to_parse)
	     then do;
		code = -1;
		return;
	     end;
	     else if substr (line_to_parse, character_pos, 1) = QNewLine
		then do;
		     character_pos = character_pos + 1;
		     code = -1;
		     return;
		end;

	new_pos = verify (substr (line_to_parse, character_pos), whitespace_string);

	if new_pos = 0			/* nothing but whitespace */
	     then do;
		character_pos = character_pos + length (line_to_parse) + 1;
		code = -1;
		return;
	     end;
	     else character_pos = character_pos + new_pos - 1;

	token_start = character_pos;

	if index (good_chars_in_identifier, substr (line_to_parse, character_pos, 1)) ^= 0
	     then do;

		/* first char looks like identifier. find whole thing */

		new_pos = verify (substr (line_to_parse, character_pos), good_chars_in_identifier);

		if new_pos = 0		/* identifier last thing on line */
		     then character_pos = length (line_to_parse) + 1;
		     else character_pos = character_pos + new_pos - 1;
	     end;
	     else character_pos = character_pos + 1; /* all other tokens are 1 char */

	token_length = character_pos - token_start;
	return;
end;  /* get_header_token */


validate_identifier:
	procedure (token, code);

dcl	token char(*) parameter;
dcl	code fixed bin(35) parameter;

/* Static */

dcl	good_chars_in_identifier char(76) static options (constant) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_");	/* Last ones are QZero_ thru QNine_, QDelta, QQuad, QDelta_ and _ */

/* Program */

	code = 0;

	if verify (token, good_chars_in_identifier) ^= 0
	     then code = -1;

	     return;
end;  /* validate_identifier */

make_new_function:
	procedure (function_info, header_line);

%include	apl_function_info;
dcl	header_line char(*) parameter;

/* Automatic */

dcl	data_elements fixed bin;
dcl	function_bead_ptr pointer unaligned;

/* Entries */

dcl	apl_allocate_words_ entry (fixed bin(24), pointer unaligned);

dcl	(length, null, size, string, substr) builtin;

/* Include Files */

%include apl_bead_format;
%include apl_operator_bead;
%include apl_function_bead;
%include apl_symbol_bead;

/* Program */


	data_elements = length (header_line);

	if substr (header_line, data_elements, 1) ^= QNewLine
	     then data_elements = data_elements + 1;

	call apl_allocate_words_ (size (function_bead), function_bead_ptr);

	string (function_bead_ptr -> function_bead.type) = function_type;

	function_bead_ptr -> function_bead.lexed_function_bead_pointer = null ();
	function_bead_ptr -> function_bead.class = 0;
	function_bead_ptr -> function_bead.stop_control_pointer = null ();
	function_bead_ptr -> function_bead.trace_control_pointer = null ();

	function_bead_ptr -> function_bead.text_length = data_elements;

	/* If we reserved room for NL, add one now */

	if data_elements > length (header_line)
	     then function_bead_ptr -> function_bead.text = header_line || QNewLine;
	     else function_bead_ptr -> function_bead.text = header_line;

	function_info.symbol_ptr -> symbol_bead.meaning_pointer = function_bead_ptr;
	return;

end;  /* make_new_function */

assign_line_numbers:
	procedure (function_info);

%include	apl_function_info;

/* Automatic */

dcl	function_bead_ptr pointer;
dcl	in_quotes bit(1);
dcl	(real_line_start, line_start) fixed bin;
dcl	(real_line_length, line_length) fixed bin;
dcl	line_pos fixed bin;
dcl	line_counter fixed bin;

/* Based */

dcl	edit_buffer char(4 * sys_info$max_seg_size) based (function_info.edit_buffer_ptr);

/* External */

dcl	sys_info$max_seg_size external fixed bin;

dcl	(apl_error_table_$mismatched_editor_quotes,
	apl_error_table_$not_end_with_newline)
	external fixed bin(35);

/* Include files */

%include apl_bead_format;
%include apl_symbol_bead;
%include apl_function_bead;

/* Program */

	function_bead_ptr = function_info.symbol_ptr -> symbol_bead.meaning_pointer;
	in_quotes = "0"b;
	real_line_start, line_start = 1;
	real_line_length = 0;
	function_info.first_unused_char_in_buffer = 1;

	do line_counter = 1 by 1 while (real_line_start <= (function_bead_ptr -> function_bead.text_length));

	     line_length = index (substr (function_bead_ptr -> function_bead.text, line_start), QNewLine);
	     if line_length = 0
		then do;
		     call report_error (apl_error_table_$not_end_with_newline, substr (function_bead_ptr -> function_bead.text, line_start), function_bead_ptr -> function_bead.text_length - line_start + 2);
		     call apl_editor_cleanup (function_info);
		end;

	     do line_pos = line_start to (line_start + line_length - 1); /* skip NL */

		if substr (function_bead_ptr -> function_bead.text, line_pos, 1) = QApostrophe
		     then in_quotes = ^in_quotes;
		     else if ^in_quotes
			then if substr (function_bead_ptr -> function_bead.text, line_pos, 1) = QLamp
			     then line_pos = line_start + line_length;  /* stop loop */
	     end;

	     real_line_length = real_line_length + line_length;

	     if in_quotes
		then do;
		     line_start = line_start + line_length;
		     line_counter = line_counter - 1;
		end;
		else do;

		     substr (edit_buffer, function_info.first_unused_char_in_buffer, real_line_length) =
			substr (function_bead_ptr -> function_bead.text, real_line_start, real_line_length);

		     function_info.line_info(line_counter).line_number = line_counter - 1;
		     function_info.line_info(line_counter).line_start = first_unused_char_in_buffer;
		     function_info.line_info(line_counter).line_length = real_line_length;

		     function_info.first_unused_char_in_buffer = function_info.first_unused_char_in_buffer + real_line_length;
		     line_start,
		     real_line_start = real_line_start + real_line_length;
		     real_line_length = 0;
		end;
	end;  /* do line_counter ... */

	if in_quotes
	     then call error (apl_error_table_$mismatched_editor_quotes, substr (function_bead_ptr -> function_bead.text, line_start), length (substr (function_bead_ptr -> function_bead.text, line_start)) + 1);

	function_info.number_of_lines = line_counter - 1;

	return;
end; /* assign_line_numbers */

print_function_lines:
	procedure (first_line_number, print_type, function_info);

dcl	first_line_number fixed decimal(10, 5) parameter;
dcl	print_type fixed bin parameter;	/* 1 = one line, 2 = specified line to end */
%include	apl_function_info;

/* Automatic */

dcl	(first_array_idx, last_array_idx) fixed bin;
dcl	count fixed bin;
dcl	output_line char(256) varying;
dcl	code fixed bin(35);

/* Based */

dcl	edit_buffer char(4 * sys_info$max_seg_size) based (function_info.edit_buffer_ptr);

/* External */

dcl	apl_static_$apl_output external ptr;
dcl	sys_info$max_seg_size external fixed bin;

dcl	(length, substr, rtrim) builtin;

/* Entries */

dcl	iox_$put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35));

/* Program */

	do first_array_idx = lbound (function_info.line_info, 1) to function_info.number_of_lines
	     while (function_info.line_info(first_array_idx).line_number < first_line_number);
	end;

	if first_array_idx > function_info.number_of_lines
	     then return;

	if print_type = 1
	     then if function_info.line_info(first_array_idx).line_number ^= first_line_number
		then return;
		else last_array_idx = first_array_idx;

	if print_type = 2
	     then last_array_idx = function_info.number_of_lines;

	if first_line_number = 0 & print_type ^= 1
	     then do;

		output_line = "     ";	/* SP SP SP SP QDel SP */

		/* Make sure that there is a line 0 */

		if function_info.line_info(first_array_idx).line_number = 0
		     then do;
			output_line = output_line || substr (edit_buffer, function_info.line_info(1).line_start, function_info.line_info(1).line_length);
			first_array_idx = first_array_idx + 1;
		     end;
		     else output_line = output_line || QNewLine;

		call iox_$put_chars (apl_static_$apl_output, addrel (addr (output_line), 1), length (output_line), code);
	     end;

	do count = first_array_idx to last_array_idx;

	     if line_has_label (substr (edit_buffer, function_info.line_info(count).line_start, function_info.line_info(count).line_length))
		then output_line = line_number_to_string_with_label (function_info.line_info(count).line_number);
		else output_line = line_number_to_string (function_info.line_info(count).line_number);

	     output_line = output_line || substr (edit_buffer, function_info.line_info(count).line_start, function_info.line_info(count).line_length);

	     call iox_$put_chars (apl_static_$apl_output, addrel (addr (output_line), 1), length (output_line), code);
	end;

	if print_type ^= 1
	     then do;

		output_line = "     
";
		call iox_$put_chars (apl_static_$apl_output, addrel (addr (output_line), 1), length (output_line), code);
	     end;
	return;
end;  /* print_function_lines */

edit_one_line:
	procedure (editor_input_buffer, editor_input_buffer_length, character_pos, left_number, right_number, current_line_number, function_info);

dcl	editor_input_buffer char(*) parameter;
dcl	editor_input_buffer_length fixed bin(21);
dcl	character_pos fixed bin parameter;
dcl	(left_number, right_number) fixed decimal(10, 5) parameter;
dcl	current_line_number fixed decimal (10, 5) parameter;
%include	apl_function_info;

/* Automatic */

dcl	(count, idx) fixed bin;
dcl	(original_line, input_line, output_line) char (256);
dcl	(original_line_length, input_line_length, output_line_length) fixed bin(21);
dcl	line_info_idx fixed bin;
dcl	prompt_string char(14) varying;
dcl	integer_part fixed decimal (5);
dcl	first_insertion fixed bin;
dcl	amount_to_insert fixed bin;
dcl	character char(1);
dcl	old_mode char(32);
dcl	code fixed bin(35);

/* Static */

dcl	NL char(1) static options (constant) init ("
");
dcl	insertion_chars char(36) static options (constant) init ("0123456789abcdefghijklmnopqrstuvwxyz");
dcl	insertion_table(0:36) fixed bin static options (constant) init (-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 105, 110, 115, 120, 125, 130);

/* Based */

dcl	edit_buffer char(4 * sys_info$max_seg_size) based (function_info.edit_buffer_ptr);

/* External */

dcl	sys_info$max_seg_size external fixed bin;
dcl	apl_static_$apl_output external ptr;
dcl	(apl_error_table_$line_too_long_to_edit)
	external fixed bin(35);

/* Entries */

dcl	iox_$put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35));
dcl	continue_to_signal_ entry (fixed bin(35));

dcl	(substr, addr, copy, index, trunc, length) builtin;

/* Include Files */

%include apl_ws_info;

/* Program */

	current_line_number = left_number;

	call get_line_info_idx (left_number, line_info_idx, function_info, code);

	if code ^= 0			/* no such line */
	     then return;

	prompt_string = line_number_to_string (current_line_number);

	original_line = prompt_string;
	original_line_length = length (prompt_string);

	count = function_info.line_info(line_info_idx).line_length;

	substr (original_line, original_line_length + 1, count) = substr (edit_buffer, function_info.line_info(line_info_idx).line_start, count);
	original_line_length = original_line_length + count;

	/* If there are any newlines other than the trailing one, barf */

	idx = index (substr (original_line, 1, original_line_length - 1), NL);
	if idx ^= 0
	     then call error (apl_error_table_$line_too_long_to_edit, substr (original_line, 1, idx), idx);

	integer_part = trunc (right_number);

	if integer_part ^= right_number		/* right is not integer */
	     then return;				/* should probably error out */

	if integer_part ^= 0			/* 0 is special case, skip all this code */
	     then do;

	     call iox_$put_chars (apl_static_$apl_output, addr (original_line), original_line_length, code);

	     output_line = "";
	     call iox_$put_chars (apl_static_$apl_output, addr (output_line), integer_part - 1, code);

	     call read_line (input_line, input_line_length);
	     substr (input_line, input_line_length) = "";	/* flush NL, add spaces */

	     output_line_length = 0;
	     original_line_length = original_line_length - 1;	/* flush NL */
	     first_insertion = 0;
	     do count = 1 to original_line_length;

		character = substr (input_line, count, 1);
		if character ^= QSlash
		     then do;
			amount_to_insert = insertion_table (index (insertion_chars, character));	/* lookup insertion value for char */

			if amount_to_insert > 0
			     then do;
				if first_insertion < 1
				     then first_insertion = output_line_length + 1;
				output_line_length = output_line_length + amount_to_insert; /* insert the spaces */
			     end;

			substr (output_line, output_line_length + 1, 1) = substr (original_line, count, 1);
			output_line_length = output_line_length + 1;

			if output_line_length > ws_info.width
			     then call error (apl_error_table_$line_too_long_to_edit, substr (output_line, 1, ws_info.width - 2), ws_info.width - 1);
		     end;  /* if character ^= QSlash */

		/* There is no else clause, as slash is supposed to delete
		   a char. If we do nothing, the char will not get copied */
	     end;  /* do count ... */
	     
	     if first_insertion < 1
		then first_insertion = output_line_length + 1;

	     if first_insertion < output_line_length
		then do;
		     substr (output_line, output_line_length + 1, output_line_length - first_insertion + 1) =
			copy (QBackSpace, output_line_length - first_insertion + 1);
		     output_line_length = output_line_length + (output_line_length - first_insertion + 1);
		end;

	end;  /* if integer_part ^= 0 */

	else do;
	     output_line = original_line;
	     output_line_length = original_line_length - 1;
	end;

	old_mode = "";

	on apl_quit_
	     begin;
		call reset_read_back_output_mode (old_mode);
		call continue_to_signal_ (code);
	     end;

	call set_read_back_output_mode (old_mode);

	call iox_$put_chars (apl_static_$apl_output, addr (output_line), output_line_length, code);

	call read_line (input_line, input_line_length);

	call reset_read_back_output_mode (old_mode);

	revert apl_quit_;

	editor_input_buffer = substr (input_line, 1, input_line_length);
	editor_input_buffer_length = input_line_length;
	character_pos = 1;

	return;		/* let main command loop deal with it */

end;  /* edit_one_line */

increment_line_number:
	procedure (line_number) returns (fixed decimal(10, 5));

dcl	line_number fixed decimal(10, 5) parameter;

/* Automatic */

dcl	incremented_line_number fixed decimal(10, 5);
dcl	line_number_pic picture "99999v.99999";
dcl	power fixed bin;

dcl	(length, rtrim, after, fixed) builtin;

/* Program */

	line_number_pic = current_line_number;
	power = length (rtrim (after (line_number_pic, "."), "0"));
	incremented_line_number = fixed (line_number + 10 ** (-power), 10, 5);
	return (incremented_line_number);

end;  /* increment_line_number */

line_number_to_string:
	procedure (line_number) returns (char(14) varying);

dcl	line_number fixed decimal(10, 5) parameter;

/* Automatic */

dcl	line_number_pic picture "zzzz9v.99999";
dcl	return_string char(14) varying;
dcl	number_of_spaces fixed bin;

dcl	(length, ltrim, rtrim, copy) builtin;

/* Program */

	number_of_spaces = 6;
	goto lnts_join;

line_number_to_string_with_label:
	entry (line_number) returns (char(14) varying);

	number_of_spaces = 5;

lnts_join:
	line_number_pic = line_number;

	return_string = "[";
	return_string = return_string || ltrim (line_number_pic);
	return_string = rtrim (rtrim (return_string, "0"), ".");
	if length (return_string) = 1
	     then return_string = return_string || "0";
	return_string = return_string || "] ";

	if length (return_string) < number_of_spaces
	     then return_string = return_string || copy (" ", number_of_spaces - length (return_string));

	return (return_string);
end;  /* line_number_to_string */

line_has_label:
	procedure (line) returns (bit(1));

dcl	line char(*) parameter;

dcl	current_pos fixed bin;
dcl	(token_start, token_length) fixed bin;

	current_pos = 1;

	call get_header_token (line, current_pos, token_start, token_length, code);
	if code ^= 0
	     then return ("0"b);

	if substr (line, token_start + token_length, 1) = QColon
	     then return ("1"b);
	     else return ("0"b);

end;  /* line_has_label */

prompt:
	procedure (current_line_number, function_info);

dcl	current_line_number fixed decimal(10, 5) parameter;
%include	apl_function_info;

/* Automatic */

dcl	line_number_pic picture "99999v.99999";
dcl	prompt_string char(14) varying;

/* External */

dcl	apl_static_$apl_output ptr external;

/* Entries */

dcl	iox_$put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35));

dcl	(length, addr, addrel, rtrim) builtin;

/* Program */

	prompt_string = line_number_to_string (current_line_number);

	call iox_$put_chars (apl_static_$apl_output, addrel (addr (prompt_string), 1), length (prompt_string), code);

	return;
end;  /* prompt */

read_line:
	procedure (input_buffer, input_line_length);

dcl	input_buffer char(*) parameter;
dcl	input_line_length fixed bin(21) parameter;

/* Automatic */

dcl	got_line bit(1);
dcl	have_reattached_user_input bit(1);
dcl	code fixed bin(35);

/* External */

dcl	(error_table_$short_record, error_table_$end_of_info) fixed bin(35) external;
dcl	apl_error_table_$cant_read_input fixed bin(35) external;
dcl	apl_static_$apl_input pointer external;

/* Entries */

dcl	iox_$get_line entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
dcl	apl_system_error_ entry (fixed bin(35));

/* Program */

	have_reattached_user_input = "0"b;
	got_line = "0"b;

	do while (^got_line);

	     call iox_$get_line (apl_static_$apl_input, addr (input_buffer), length (input_buffer), input_line_length, code);
	     if code = 0
		then got_line = "1"b;
		else if code = error_table_$short_record
		     then do;
			input_line_length = input_line_length + 1;
			substr (input_buffer, input_line_length, 1) = QNewLine;
			got_line = "1"b;
		     end;
		     else if code = error_table_$end_of_info
			then do;
			     if have_reattached_user_input
				then call apl_system_error_ (apl_error_table_$cant_read_input);

			     call reattach_user_input;
			     have_reattached_user_input = "1"b;
			end;
			else call apl_system_error_ (apl_error_table_$cant_read_input);
	end;
	return;

/* Small procedure to attach user_input back to user_i/o. Handles case where
   user_input is presently attached via syn_, and case where user_input is
   attached via regular IO module. */

reattach_user_input:
     procedure;

dcl	code fixed bin(35);

/* External */

dcl	iox_$user_input pointer external;
dcl	error_table_$not_closed fixed bin(35) external;

/* Entries */

dcl	iox_$detach_iocb entry (ptr, fixed bin (35));
dcl	iox_$close entry (ptr, fixed bin (35));
dcl	iox_$attach_ptr entry (ptr, char(*), ptr, fixed bin (35));

/* Program */

	call iox_$detach_iocb (iox_$user_input, code);
	if code = error_table_$not_closed
	     then do;				/* means was vfile_ or something */
		call iox_$close (iox_$user_input, code);
		call iox_$detach_iocb (iox_$user_input, code);
	     end;
	call iox_$attach_ptr (iox_$user_input, "syn_ user_i/o", null (), code);

     end; /* reattach_user_input */
end;  /* read_line */

set_read_back_output_mode:
	procedure (old_mode);

dcl	old_mode char(*) parameter;

/* Automatic */

dcl	code fixed bin(35);

/* External */

dcl	apl_static_$apl_input external ptr;

/* Entries */

dcl	ipc_$mask_ev_calls entry (fixed bin(35));
dcl	ipc_$unmask_ev_calls entry (fixed bin(35));
dcl	iox_$control entry (ptr, char(*), ptr, fixed bin (35));

/* Program */

	call ipc_$mask_ev_calls (code);

	call iox_$control (apl_static_$apl_input, "read_back_output", addr (old_mode), code);
	if code ^= 0
	     then call error (code, "", 0);

	return;

reset_read_back_output_mode:
	entry (old_mode);

	/* Check to see if there is anythingg to reset */
	if old_mode = ""
	     then return;

	call iox_$control (apl_static_$apl_input, old_mode, (null ()), code);

	call ipc_$unmask_ev_calls (code);

	old_mode = "";

	return;
end;  /* set_read_back_output_mode */

decrement_reference_count:
	procedure (bead_ptr);

dcl	bead_ptr pointer unaligned parameter;

/* Entries */

dcl	apl_free_bead_ entry (pointer unaligned);

/* Include Files */

%include apl_bead_format;

/* Program */

	if bead_ptr = null()
	     then return;

	bead_ptr -> general_bead.reference_count = bead_ptr -> general_bead.reference_count - 1;

	if bead_ptr -> general_bead.reference_count < 1
	     then do;

		call apl_free_bead_ (bead_ptr);
		bead_ptr = null();
	     end;
	return;
end;  /* decrement_reference_count */

get_line_info_idx:
	procedure (line_number, line_info_idx, function_info, code);

dcl	line_number fixed decimal(10, 5) parameter;
dcl	line_info_idx fixed bin parameter;
%include	apl_function_info;
dcl	code fixed bin(35) parameter;

/* Program */

	code = 0;

	do line_info_idx = 1 to function_info.number_of_lines
	     while (function_info.line_info(line_info_idx).line_number < line_number);
	end;

	if line_info_idx > function_info.number_of_lines
	     then do;
		code = -1;
		return;
	     end;

	if function_info.line_info(line_info_idx).line_number ^= line_number
	     then code = -1;

	return;
end;  /* get_line_info_idx */

error:
          procedure (code, source, position);

dcl       code fixed bin(35) parameter;
dcl	source char(*) parameter;
dcl	position fixed bin parameter;

/* Automatic */

dcl	fatal bit(1);

/* Entries */

dcl	apl_error_ entry (fixed bin(35), bit(36) aligned, fixed bin, char(*), ptr unaligned, fixed bin);

/* Program */

	fatal = "1"b;
	go to error_join;

report_error:
	entry (code, source, position);

	fatal = "0"b;

error_join:
	if code ^= 0
	     then call apl_error_ (code, "0"b, position, source, null (), 0);

	if fatal
	     then goto internal_error_restart;
	     else return;

end;  /* error, report_error */

apl_editor_cleanup:
	procedure (function_info);

%include	apl_function_info;

/* Entries */

dcl	apl_segment_manager_$free entry (ptr);
dcl	apl_destroy_save_frame_update_ entry ();

/* Program */

	call apl_segment_manager_$free (function_info.edit_buffer_ptr);

	call apl_destroy_save_frame_update_;

	goto apl_editor_return_point;

end; /* apl_editor_cleanup */

end; /* apl_editor_ */
