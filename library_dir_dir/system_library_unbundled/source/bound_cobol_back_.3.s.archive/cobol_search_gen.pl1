/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(89-04-23,Zimmerman), approve(89-04-23,MCR8060),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8060 cobol_search_gen.pl1 Added Trace statements.
  2) change(89-04-23,Zimmerman), approve(89-04-23,MCR8082),
     audit(89-05-05,RWaters), install(89-05-24,MR12.3-1048):
     MCR8082 cobol_search_gen.pl1 Fix wild array subscript.
                                                   END HISTORY COMMENTS */


/* Modified on 02/11/85 by FCH, [5.3-2], BUG561, search_flag=0 in fmt4_eos */
/* Modified on 10/19/84 by FCH, [5.3-1], BUG563(phx18381), new cobol_addr_tokens.incl.pl1 */
/* Modified on 09/11/81 by FCH, [5.0-1], set search_flag to 1 in fmt3_eos not fmt1_eos, BUG503(phx11385) */
/* Modified on 09/08/77 by Bob Chang to fix the bug for not setting numeric_lit.places_left. */
/* Modified on 7/18/76 by Bob Chang to handle  the varying length data. */








/* format: style3 */
cobol_search_gen:
     proc (in_token_ptr, search_flag);

/*
This procedure generates code for the Cobol Search statment.  */
/*  Because of the way the PD syntax phase parses the
SEARCH statement, cobol_search_gen will be called more than
once to generate code for a single SEARCH statement.  See
details below in the documentation for the separate internal
procedures used to implement the code generation.  */

/*
The current implemenattion generates code only for format 1
SEARCH statements.  If called to generate code for format 2
SEARCH statements, a diagnostic is issued, and unpredictable
code is generated.
*/

/*  DECLARATION OF THE PARAMETERS  */

/*  dcl in_token_ptr ptr;  */
/*  THIS PARAMETER IS DECLARED BELOW IN AN INCLUDE FILE  */
dcl	search_flag	fixed bin;

/*  DECLARATION OF EXTERNAL ENTRIES  */

dcl	cobol_register$load ext entry (ptr);
dcl	ioa_$ioa_stream	ext entry options (variable);
dcl	cobol_compare_gen	ext entry (ptr);
dcl	cobol_emit	ext entry (ptr, ptr, fixed bin);
dcl	cobol_make_tagref	ext entry (fixed bin, fixed bin, ptr);
dcl	cobol_define_tag	ext entry (fixed bin);
dcl	cobol_set_gen	ext entry (ptr);
dcl	cobol_add_gen	ext entry (ptr, fixed bin);
dcl	cobol_read_rand	entry (fixed bin, char (5), ptr);
dcl	cobol_make_type9$copy
			ext entry (ptr, ptr);
dcl	cobol_addr	ext entry (ptr, ptr, ptr);
dcl	cobol_process_error ext entry (fixed bin, fixed bin, fixed bin);
dcl	cobol_alloc$stack	ext entry (fixed bin, fixed bin, fixed bin);



/*}*/


/*************************************************/
/*	START OF EXECUTION			*/
/*	cobol_search_gen			*/
/**************************************************/

/*  Save the in_token_ptr.  */
	save_in_token_ptr = in_token_ptr;

	if in_token.token_ptr (in_token.n) -> end_stmt.a = "000"b
	then call format1_search;
	else call format2_search;			/*  Restore the in_token_ptr to its original value.  */
	in_token_ptr = save_in_token_ptr;







/*  DECLARATIONS OF INTERNAL STATIC VARIABLES  */

dcl	1 set_eos_token	int static,
	  2 size		fixed bin (15) init (38),
	  2 line		fixed bin (15) init (0),
	  2 column	fixed bin (15) init (0),
	  2 type		fixed bin (15) init (19),	/*  EOS  */
	  2 verb		fixed bin (15) init (31),	/*  SET  */
	  2 e		fixed bin (15),
	  2 h		fixed bin (15),
	  2 i		fixed bin (15),
	  2 j		fixed bin (15),
	  2 a		bit (3) init ("000"b),	/*  SET FOR EITHER FMT 1 OR FMT 2  */
	  2 b		bit (1) init ("0"b);	/*  SET FOR FMT 1 OR FMT 2   */


dcl	1 numeric_lit_1	int static,
	  2 size		fixed bin (15) init (36),
	  2 line		fixed bin (15) init (0),
	  2 column	fixed bin (15) init (0),
	  2 type		fixed bin (15) init (2),	/*  NUMERIC LITERAL  */
	  2 integral	bit (1) init ("1"b),
	  2 floating	bit (1) init ("0"b),
	  2 filler1	bit (5) init ("00000"b),
	  2 subscript	bit (1) init ("0"b),
	  2 sign		char (1) init (" "),
	  2 exp_sign	char (1) init (" "),
	  2 exp_places	fixed bin (15) init (0),
	  2 places_left	fixed bin (15) init (1),
	  2 places_right	fixed bin (15) init (0),
	  2 places	fixed bin (15) init (1),
	  2 literal	char (1) init ("1");



dcl	1 add_eos_token	int static,
	  2 size		fixed bin (15) init (38),
	  2 line		fixed bin (15) init (0),
	  2 column	fixed bin (15) init (0),
	  2 type		fixed bin (15) init (19),	/*  EOS  */
	  2 verb		fixed bin (15) init (2),	/*  ADD  */
	  2 e		fixed bin (15) init (1),	/*  left operands  */
	  2 h		fixed bin (15) init (1),	/*  right operands  */
	  2 i		fixed bin (15) init (0),
	  2 j		fixed bin (15) init (0),
	  2 a		bit (3) init ("000"b),	/*  FORMAT 1  */
	  2 b		bit (1) init ("0"b);	/*  NO OSE CLAUSE PRESENT  */


dcl	1 compare_eos_token int static,
	  2 size		fixed bin (15) init (38),
	  2 line		fixed bin (15) init (0),
	  2 column	fixed bin (15) init (0),
	  2 type		fixed bin (15) init (19),	/*  EOS  */
	  2 verb		fixed bin (15) init (13),	/*  BRANCH  */
	  2 e		fixed bin (15) init (0),	/*  SET TO GREATER OR EQUAL  */
	  2 h		fixed bin (15) init (0),
	  2 i		bit (36) init ("010"b);	/*  TRANSFER IF CONDITION NOT TRUE  */


dcl	1 work_numeric_lit	int static,
	  2 size		fixed bin (15) init (36),
	  2 line		fixed bin (15) init (0),
	  2 column	fixed bin (15) init (0),
	  2 type		fixed bin (15) init (2),	/*  NUMERIC LITERAL  */
	  2 integral	bit (1) init ("1"b),
	  2 floating	bit (1) init ("0"b),
	  2 filler1	bit (5) init ("00000"b),
	  2 subscript	bit (1) init ("0"b),
	  2 sign		char (1) init (" "),
	  2 exp_sign	char (1) init (" "),
	  2 exp_places	fixed bin (15) init (0),
	  2 places_left	fixed bin (15) init (0),
	  2 places_right	fixed bin (15) init (0),
	  2 places	fixed bin (15) init (0),
	  2 literal	char (20);

/*  Declaration of an unconditional transfer instruction  */

dcl	tra_inst		bit (36) int static init ("000000000000000000111001000000000000"b);


dcl	mlr_op		bit (10) int static init ("0010000011"b /*010(1)*/);
dcl	ldq_op		bit (10) int static init ("0100111100"b /*236(0)*/);
dcl	stq_op		bit (10) int static init ("1111011100"b /*756(0)*/);
dcl	lda_op		bit (10) int static init ("0100111010"b /*235(0)*/);
dcl	div_op		bit (10) int static init ("1010001100"b /*506(0)*/);
dcl	asa_op		bit (10) int static init ("0001011010"b /*055(0)*/);
dcl	aos_op		bit (10) int static init ("0001011000"b /* 054(0)*/);
dcl	sta_op		bit (10) int static init ("1111011010"b /*755(0)*/);

dcl	do_ptr		ptr,
	com2_ptr		ptr;
dcl	next_compare_tag	fixed bin static;
dcl	next_stmt_tag	fixed bin int static;
dcl	compare_code_tag	fixed bin int static;
dcl	increment_code_tag	fixed bin int static;
dcl	next_when_tag	fixed bin int static;
dcl	check_index_tag	fixed bin int static;
dcl	at_end_tag	fixed bin int static;

dcl	save_in_token_ptr	ptr;

dcl	work_in_token	(1:20) ptr;

/*  Structure used to communicate with the register handling routines.  */

dcl	1 register_struc,
	  2 what_reg	fixed bin,
	  2 reg_no	bit (4),
	  2 lock		fixed bin,
	  2 already_there	fixed bin,
	  2 contains	fixed bin;

dcl	dn_ptr		ptr;
format1_search:
     proc;

/*  Declaration of an entry array  */

dcl	eos_proc		(1:4) entry init (fmt1_eos, fmt2_eos, fmt3_eos, fmt4_eos);


/*  DECLARATIONS OF INTERNAL VARIABLES  */

dcl	index_token_ptr	ptr;
dcl	varying_token_ptr	ptr;

dcl	add_next_stmt_tag	fixed bin;
dcl	work_string	char (20);
dcl	varying_done	bit (1);
dcl	ix		fixed bin;
dcl	iy		fixed bin;
dcl	offset_inst_word	bit (36);
dcl	occurrence_inst_word
			bit (36);
dcl	element_length_inst_word
			bit (36);

/**************************************************/
/*	START OF EXECUTION			*/
/*	INTERNAL PROCEDURE			*/
/*		format1_search		*/
/**************************************************/



	call eos_proc (in_token.token_ptr (in_token.n) -> end_stmt.e);


fmt1_eos:
     proc;

/*  Reserve a tag to be defined at the next Cobol statement (the statement
		following this SEARCH stetement)  */

	next_stmt_tag = cobol_$next_tag;

/*  Reserve a tag to be defined at the first instruction of the code generated to
		compare the index name value with the maximum size of the table.  */

	compare_code_tag = next_stmt_tag + 1;

/*  Reserve a tag to be defined at the next WHEN clause in the SEARCH statement.  */

	next_when_tag = next_stmt_tag + 2;

/*  Reserve a tag to be defined at the first instruction generated to increment the index name.  */

	next_compare_tag = cobol_$next_tag + 4;
	at_end_tag = cobol_$next_tag + 5;

	increment_code_tag = next_stmt_tag + 3;

/*  Update the next tag variable in the external data segment.  */

	cobol_$next_tag = cobol_$next_tag + 6;

	eos_ptr = in_token.token_ptr (in_token.n);

	dn_ptr = in_token.token_ptr (2);
	if data_name.occurs_do
	then do;
		call cobol_read_rand (1, data_name.do_rec, com2_ptr);
		call cobol_read_rand (3, odo_rec.descr, dn_ptr);
		do_ptr = dn_ptr;
	     end;
	else do_ptr = null ();
	if end_stmt.c = "1"b			/*  VARYING clause present.  */
	then if (in_token.token_ptr (in_token.n - 1) -> data_name.type = rtc_dataname
		& in_token.token_ptr (in_token.n - 1) -> data_name.usage_index)
	     then /*  VARYING variabble is an index data item.  */
		/*  Generate code to extract data from the index data item to be used
			in incrementing the index data item during the execution of the SEARCH.  */
		call get_index_item_data (in_token.token_ptr (in_token.n - 1), offset_inst_word, occurrence_inst_word,
		     element_length_inst_word);

/*  Generate an unconditional transfer to the compare_code_tag.  */

	call cobol_emit (addr (tra_inst), null (), 1);

/*  Make a tag reference to compare_code_tag at the instruction just emitted.  */

	call cobol_make_tagref (compare_code_tag, cobol_$text_wd_off - 1, null ());

/*  Define the increment_code_tag at the next instruction location.  */
	call cobol_define_tag (increment_code_tag);

/*  Determine what index name should be used to search the table.  */


	if end_stmt.c = "0"b
	then do;					/*  No VARYING clause present.  */

		index_token_ptr = in_token.token_ptr (in_token.n - 1);
		dn_ptr = in_token.token_ptr (in_token.n - 2);
		occurs_ptr = addrel (dn_ptr, divide (data_name.occurs_ptr, 4, 35, 0));
		varying_token_ptr = null ();

	     end;					/*  No VARYING clause present.  */

	else do;					/*  VARYING present, determine whether the index name appearing in the
		VARYING clause should be used to search the table.  */

		dn_ptr = in_token.token_ptr (in_token.n - 3);

/*  Build a pointer to the occurs extension of the table being searched.  */
		occurs_ptr = addrel (dn_ptr, divide (data_name.occurs_ptr, 4, 35, 0));

		if in_token.token_ptr (in_token.n - 1) -> data_name.type = rtc_indexname
		then do;				/*  VARYING variable is an index name.  */

/*  Check to see if the index name in the VARYING clause appears in
			the INDEXED BY clause of the table being searched.  This index name
			appears in the INDEXED BY clause of the table if the index_no value in the
			index name token is equal to the index_no value in the occurs extension
			of the table.  */

			if occurs.level.index_no (occurs.dimensions)
			     = in_token.token_ptr (in_token.n - 1) -> index_name.index_no
			then do;			/*  It does appear in the INDEXED BY clause of the table.  */

/*  Use the index name in the VARYING clause for the SEARCH.  */
				index_token_ptr = in_token.token_ptr (in_token.n - 1);
				varying_token_ptr = null ();
						/*  no varying identifier to worry about.  */

			     end;			/*  It does appear in the INDEXED BY clause of the table.  */

			else do;			/*  Index name not associated with the table via INDEXED BY clause.  */

/*  The first index name token appears on cobol_pdout_ immediately
				following the data name token for the table.  */
				index_token_ptr = in_token.token_ptr (in_token.n - 2);

/*  The INDEX name in the varying clause is also incremented during
				the search.  */
				varying_token_ptr = in_token.token_ptr (in_token.n - 1);

			     end;			/*  The Index name not associated with the table via
					INDEXED BY clause.  */

		     end;				/*  VARYING variable is an index name.  */

		else do;				/*  VARYING VARIABLE is not an index name.  */

/*  Index used to search the table is the first index appearing in the
			INDEXED BY clause.  */
			index_token_ptr = in_token.token_ptr (in_token.n - 2);
			varying_token_ptr = in_token.token_ptr (in_token.n - 1);

		     end;				/*  VARYING variable is not an index name.  */

	     end;					/*  VARYING present, determine whether the index name appearing in the VARYING
		clause should be used to search the table.  */


/*  AT THIS POINT IN PROCESSING:

		1.  dn_ptr points to the data name token (type 9) for the
		table to be searched.
		2.  index_token_ptr points to the index name token (type 10) for the
		index to be used in the search.
		3.  varying_token_ptr points to the token appearing in the VARYING
		clause, to be incremented along with the index name used in the
		search.  If there was no VARYING clause, or if the variable
		referenced in the VARYING clause was the index name now being used
		in the search, then this pointer is null.

*/



/*  Generate code to increment the index name, and the variable referenced
		in the VARYING clause.  */


	varying_done = "0"b;
	in_token_ptr = addr (work_in_token (1));

	in_token.token_ptr (1) = save_in_token_ptr -> in_token.token_ptr (1);
	in_token.token_ptr (2) = index_token_ptr;



	if varying_token_ptr ^= null ()
	then do;					/*  VARYING variable is present.  */

		if varying_token_ptr -> data_name.type = rtc_indexname
		then do;				/*  VARYING variable is an index name.  */

/*  We will call the SET generator once to increment both index names.  */

			varying_done = "1"b;
			in_token.token_ptr (3) = varying_token_ptr;
			in_token.token_ptr (4) = addr (numeric_lit_1);
						/*  Numeric literal 1 is increment.  */
			in_token.token_ptr (5) = addr (set_eos_token);
			in_token.n = 5;
			in_token.token_ptr (5) -> end_stmt.e = 2;
						/*  Two operands to be SET.  */
			set_eos_token.a = "001"b;	/*  Format 2 set stmt.  */
			set_eos_token.b = "0"b;	/*  UP  */

		     end;				/*  VARYING variable is an index name.  */

		else if (varying_token_ptr -> data_name.type = rtc_dataname
		     & varying_token_ptr -> data_name.usage_index = "1"b)
		then do;				/*  VARYING variable is an index data item.  */

			call increment_index_data_item (varying_token_ptr, offset_inst_word, occurrence_inst_word,
			     element_length_inst_word);

		     end;				/*  VARYING variable is an index data item.  */

	     end;					/*  VARYING variable is present.  */

	if ^varying_done
	then do;					/*  VARYING not present, or if present, varying variable is not index name */

		in_token.token_ptr (3) = addr (numeric_lit_1);
						/*  Increment is literal 1.  */
		in_token.token_ptr (4) = addr (set_eos_token);
		in_token.n = 4;
		in_token.token_ptr (4) -> end_stmt.e = 1;
						/*  One operand to be set.  */
		set_eos_token.a = "001"b;		/*  Format 2 SET stmt.  */
		set_eos_token.b = "0"b;		/*  UP  */

	     end;					/*  VARYING not present, or if present, varying variable is not an index name.  */

/*  Call the SET generator to increment the index.  */

/*  Modify the maximum value field in the index name token so the SET generator will allow it to
		be set to one greater than the maximum size defined in the occurs clause.  */

	index_token_ptr -> index_name.max = index_token_ptr -> index_name.max + 1;

/*  Increment the same field in the varying token if it is also an index name.  */

	if varying_token_ptr ^= null ()
	then if varying_token_ptr -> data_name.type = rtc_indexname
	     then varying_token_ptr -> index_name.max =
		     varying_token_ptr -> index_name.max + index_token_ptr -> index_name.max - 1;

/*  Call the SET generator.  */
	call cobol_set_gen (in_token_ptr);


	if varying_token_ptr ^= null ()
	then if (varying_token_ptr -> data_name.type = rtc_dataname & varying_token_ptr -> data_name.usage_index = "0"b)
	     then do;				/*  VARYING present, and the varying variable is a dataname, but not usage index.  */

/*  Generate code to add one to the variable referenced in the VARYING clause.  */

		     in_token_ptr = addr (work_in_token (1));
		     in_token.token_ptr (1) = null ();
		     in_token.token_ptr (2) = addr (numeric_lit_1);
		     in_token.token_ptr (3) = varying_token_ptr;
		     in_token.token_ptr (4) = addr (add_eos_token);
		     in_token.n = 4;

		     call cobol_add_gen (in_token_ptr, add_next_stmt_tag);

		end;				/*  VARYING present, and the varying variable is a dataname, but not usage index.  */

/*  Define the compare_code_tag at the next instruction.  */

	call cobol_define_tag (compare_code_tag);

/*  Generate code to compare the index name being used to search the table, to its maximum size.  */

/*  Convert the maximum size of the table being searched (in fixed binary representation) to a
	character string.  */

	call bin_to_char (index_token_ptr -> index_name.max - 1,
						/*  Remember that we incremented "max"
		by 1 before calling the set generator.  */
	     work_numeric_lit.literal, work_numeric_lit.places);
	work_numeric_lit.places_left = work_numeric_lit.places;

	in_token.n = 3;
	in_token.token_ptr (3) = addr (compare_eos_token);
	in_token.token_ptr (1) = index_token_ptr;
	compare_eos_token.e = 113;			/*  GREATER  */
	compare_eos_token.i = "010"b;			/*  Transfer if not greater.  */

/*  Generate code to do the comparison.  */
	if do_ptr ^= null ()
	then do;
		in_token.token_ptr (2) = do_ptr;
		compare_eos_token.h = next_compare_tag;
		call cobol_compare_gen (in_token_ptr);
		call cobol_emit (addr (tra_inst), null (), 1);
		if end_stmt.b = "0"b
		then call cobol_make_tagref (next_stmt_tag, cobol_$text_wd_off - 1, null ());
		else call cobol_make_tagref (at_end_tag, cobol_$text_wd_off - 1, null ());
	     end;
	call cobol_define_tag (next_compare_tag);
	in_token.token_ptr (2) = addr (work_numeric_lit);
	compare_eos_token.h = next_when_tag;
	call cobol_compare_gen (in_token_ptr);		/*  Check to see if an AT END clause was not present, and generate a transfer to the next
		Cobol statement.  */

	if end_stmt.b ^= "1"b
	then do;					/*  AT END clause not present.  */
						/*  Emit a transfer to the next Cobol statement.  */
						/*  Make a tag reference at the instruction just emitted.  */
						/*  Define the next when tag at the next instruction to be generated.  */

/*[5.3-2]*/
		call TG (next_stmt_tag, next_when_tag);

	     end;					/*  AT END clause not present.  */

	call cobol_define_tag (at_end_tag);		/*  Set the output parameter to non_zero.  */
						/*[5.0-1]*/
						/* 	search_flag = 1; */

     end fmt1_eos;


fmt2_eos:
     proc;


	if in_token.token_ptr (in_token.n) -> end_stmt.b = "1"b
	then do;					/*  This EOS is the last EOS for the sEARCH statement.  */

/*  Generate code to transfer to  increment code tag.  */

		call cobol_emit (addr (tra_inst), null (), 1);
		call cobol_make_tagref (increment_code_tag, cobol_$text_wd_off - 1, null ());

/*  Define the next_stmt_tag.  */

/*[5.3-2]*/
		call TG (increment_code_tag, next_stmt_tag);

/*  Set the output parameter search_flag to zero.  */

		search_flag = 0;

	     end;					/*  This EOS is the last EOS for the SEaRCH statement.  */

	else do;					/*  This EOs is not the last EOS for the sEaRCH statement.  */

/*  Generate a transfer to the next Cobol statement.  */
/*  Make a reference to the next Cobol statement at the instruction just emitted.  */
/*  Define the next_when_tag.  */

/*[5.3-2]*/
		call TG (next_stmt_tag, next_when_tag);

	     end;					/*  This EOS is not the last EOS for the sEaRCH statement.  */


     end fmt2_eos;

TG:
     proc (T1, T2);

/*[5.3-2]*/
dcl	(T1, T2)		fixed bin;

/*[5.3-2]*/
	call cobol_emit (addr (tra_inst), null (), 1);	/*[5.3-2]*/
	call cobol_make_tagref (T1, cobol_$text_wd_off - 1, null ());
						/*[5.3-2]*/
	call cobol_define_tag (T2);

     end;

fmt3_eos:
     proc;

/*[5.0-1]*/
	search_flag = 1;

	return;

     end fmt3_eos;


fmt4_eos:
     proc;

/*  Save the internal tag defined in the internal tag token (type 30) as the next_when_tag.  */
	next_when_tag = in_token.token_ptr (in_token.n - 1) -> int_tag.proc_num;
						/*[5.3-2]*/
	search_flag = 0;
     end fmt4_eos;

     end format1_search;


/*************************************************/
/*	INTERNAL PROCEDURE			*/
/*	get_index_item_data		*/
/**************************************************/

get_index_item_data:
     proc (index_data_item_ptr, work_offset_inst, work_occurrence_inst, element_length_inst);

/*
This internal proceduure generates code to get the following information
for an index data item that is to be incremented during
the execution of a SEARCH statement:
	1. occurrence number
	2. byte offset of the item referenced by
	"occurrence number".
	3. element length of the item referenced by the index
	data item.  (this length is calculated by dividing
	"byte offset" by "occurrence number".)

An index data item in Multics cobol consists of six bytes of
data.  the first four bytes contain the byte offset, and the last
two bytes contain the occurrence number.  However, within each
byte, only the least significant 8 bits contain meaningful
data.  Therefore, to do any computation or incrementing of The
data in an index data item, it is necessary to squeeze out the
junk bits, and store the resulting data into temporary storage.
This procedure does That silly bit squeezing.
*/

/*  DECLARATION OF THE PARAMETERS  */

dcl	index_data_item_ptr ptr;
dcl	work_offset_inst	bit (36);
dcl	work_occurrence_inst
			bit (36);
dcl	element_length_inst bit (36);

/*  DESCRIPTION OF THE PARAMETERS  */

/*
PARAMETER		DESCRIPTION

index_data_item_ptr	Pointer to the index data item token
		(type 9) from which data is to be
		extracted by this procedure.  (input)
work_offset_inst	a word in which the basic, non-eis
		address of the word in wich the fixed
		binary offset value is stored by this
		procedure. (output)
work_occurrence_inst a word in which the basic, non-eis
		address of the word in which the fixed binary
		occurrence number is stored by this
		procedure.  (output)
element_length_inst	a word in which the basic, non-eis address
		of the word in which the fixed binary
		element length is stored by this procedure.
		(output)

*/


/*  DECLARATIONS OF INTERNAL STATIC VARIABLES  */

dcl	1 get_occurrence_no_code
			int static,
	  2 i1		bit (36) init ("000000000000000000010011101000000011"b),
						/*  lda 0,du */
	  2 i2		bit (36) init ("000000000000001010111011111000000000"b),
						/* lls 10  */
	  2 i3		bit (36) init ("000000000000000001111011001000000000"b),
						/* ars 1  */
	  2 i4		bit (36) init ("000000000000011100111011011000000000"b),
						/*  lrs 28  */
	  2 i5		bit (36) init ("000000000000000000110000001000000000"b);
						/*  tnz 0  */

dcl	1 get_offset_code	int static,
	  2 i1		bit (36) init ("000000000000001000111011011000000000"b),
						/*  lrs 8  */
	  2 i2		bit (36) init ("000000000000000001111011001000000000"b),
						/*  ars 1  */
	  2 i3		bit (36) init ("000000000000001000111011011000000000"b),
						/*  lrs 8  */
	  2 i4		bit (36) init ("000000000000000001111011001000000000"b),
						/*  ars 1  */
	  2 i5		bit (36) init ("000000000000001000111011011000000000"b),
						/*  lrs 8  */
	  2 i6		bit (36) init ("000000000000000001111011001000000000"b),
						/*  ars 1  */
	  2 i7		bit (36) init ("000000000000001100111011011000000000"b);
						/*  lrs 12  */

dcl	search_occurrence_error
			fixed bin int static init (46);


/*  DECLARATION OF INTERNAL VARIABLES  */

dcl	work_offset1	fixed bin;
dcl	work_offset2	fixed bin;
dcl	work_offset3	fixed bin;

dcl	work_ptr		ptr;

dcl	work_offset_inst_ptr
			ptr;
dcl	work_occurrence_inst_ptr
			ptr;
dcl	element_length_inst_ptr
			ptr;

dcl	buff1		(1:10) ptr;
dcl	buff2		(1:10) ptr;
dcl	buff3		(1:10) ptr;
dcl	occurrence_ok_tag	fixed bin;

	input_ptr = addr (buff1 (1));
	inst_ptr = addr (buff2 (1));
	reloc_ptr = addr (buff3 (1));

/*  allocate 3 words (12 bytes) on an even word boundary in the stack.  these
three words ar to be used to hold:
	1. first word-byte offset of the index data item.
	2. second occurrence number from the index data item
	3. element length of the array item described by the index data item.

*/

	call cobol_alloc$stack (12, 2, work_offset1);

/*  Convert the word offset returned by cobol_alloc$stack to a byte offset.  */
	work_offset1 = work_offset1 * 4;

/*  calculate the  byte offset of the word for the occurrence number from the index data item.  */
	work_offset2 = work_offset1 + 4;

/*  calculate the byte offset for the  word to contain the element length.  */
	work_offset3 = work_offset1 + 8;

/*  Make a copy of the input index data item token.  */
	work_ptr = null ();				/*  Utility provides buffer for the token.  */
	call cobol_make_type9$copy (work_ptr, index_data_item_ptr);

/*  Modify the token so that it describes the temporary space just allocated in the stack.  */
	work_ptr -> data_name.seg_num = 1000;		/*  stack  */
	work_ptr -> data_name.offset = work_offset1;
	work_ptr -> data_name.subscripted = "0"b;

/*  generate code to move the index data item ( 6 bytes long)  to the stack space.  */

	input_struc.type = 5;			/*  EIS, 2 operands input, instruction and 2 descriptors returned.  */
	input_struc.operand_no = 2;
	input_struc.lock = 0;
	input_struc.operand.token_ptr (1) = index_data_item_ptr;
	input_struc.operand.send_receive (1) = 0;	/*  sending  */
	input_struc.operand.size_sw (1) = 0;

	input_struc.operand.token_ptr (2) = work_ptr;
	input_struc.operand.send_receive (2) = 1;	/*  receiving  */
	input_struc.operand.size_sw = 0;

/*  call the addressability utility  */
	call cobol_addr (input_ptr, inst_ptr, reloc_ptr);

/*  set the MLR opcode into the instruction returned.  */
	inst_struc.inst.fill1_op = mlr_op;

/*  emit the instruction and 2 descriptors.  */
	call cobol_emit (inst_ptr, reloc_ptr, 3);

/*  get the basic addresses (6180 non-eis addresses of the offset, occurrence number, and element
	length words.  */

	work_offset_inst_ptr = addr (work_offset_inst);
	work_occurrence_inst_ptr = addr (work_occurrence_inst);
	element_length_inst_ptr = addr (element_length_inst);

	input_struc_basic.type = 1;			/*  basic, non-eis  */
	input_struc_basic.operand_no = 0;
	input_struc_basic.segno = 1000;

/*  get basic address of the offset word  */
	input_struc_basic.char_offset = work_offset1;
	call cobol_addr (input_ptr, work_offset_inst_ptr, reloc_ptr);

/*  get the basic address of the occurrence number wordl  */
	input_struc_basic.char_offset = work_offset2;
	call cobol_addr (input_ptr, work_occurrence_inst_ptr, reloc_ptr);

/*  get basic address of the element length word.  */
	input_struc_basic.char_offset = work_offset3;
	call cobol_addr (input_ptr, element_length_inst_ptr, reloc_ptr);

/*  get the a and q registera  */

	register_struc.what_reg = 3;			/*  A and Q  */
	register_struc.lock = 0;			/*  no change to locks.  */
	register_struc.contains = 0;			/*  Contents of A and Q will not be meaningful ofr register
		optimization, because the code to be generated shifts the contents of the registers.  */

	call cobol_register$load (addr (register_struc));

/*  build instruction to load the Q register with the occurrence number.  */
	work_occurrence_inst_ptr -> inst_struc_basic.fill1_op = ldq_op;

/*  Emit the ldq instruction  */
	call cobol_emit (work_occurrence_inst_ptr, null (), 1);

/*  at this point we have generated code to load the occurrence number into the Q register.  */

/*  emit a stream of code to convert the occurrence number into a fixed bin (35) value
	in the Q register  */

/*  The code stream emitted is:
		lda 0,dl
		lls 10
		ars 1
		lrs 28
		tnz
	*/

	call cobol_emit (addr (get_occurrence_no_code), null (), 5);

/*  Reserve a tag to which to transfer if the occurrence number is OK (non-zero)  */
	occurrence_ok_tag = cobol_$next_tag;
	cobol_$next_tag = cobol_$next_tag + 1;		/*  Make a reference to the tag just reserved at the tnz instruction just emitted.  */

	call cobol_make_tagref (occurrence_ok_tag, cobol_$text_wd_off - 1, null ());

/*  Generate code to signal an error, if the occurrence number is zero.  */

	call cobol_process_error (search_occurrence_error, fixed (index_data_item_ptr -> data_name.line, 17), 0);

/*  Define the occurrence_ok_tag.  */
	call cobol_define_tag (occurrence_ok_tag);

/*  Generate code to store the occurrence number, back into the temporary in the stack.  */
	work_occurrence_inst_ptr -> inst_struc_basic.fill1_op = stq_op;

/*  Emit the instruction.  */
	call cobol_emit (work_occurrence_inst_ptr, null (), 1);

/*  Now  generate code to load the offset into the A-Q register and squeeze out the junk bits.  */
	work_offset_inst_ptr -> inst_struc_basic.fill1_op = lda_op;
	call cobol_emit (work_offset_inst_ptr, null (), 1);

/*  Emit a stream of code to squeeze out the junk bits.  */
/*  The stream of code is:
		lrs 8
		ars 1
		lrs 8
		ars 1
		lrs 8
		ars 1
		lrs 12  RESULT WINDS UP IN Q
	*/

	call cobol_emit (addr (get_offset_code), null (), 7);

/*  Generate code to store the Q into the owrk offset word.  */
	work_offset_inst_ptr -> inst_struc_basic.fill1_op = stq_op;
	call cobol_emit (work_offset_inst_ptr, null (), 1);

/*  Now generate code to calculate the element length of the item described by the index data item,
	and store the element length in the stack for use later when the index data item is incremented.  */

/*  Note at this point in the generated code, the offset is contained in the Q register,
	the occurrence number is sorted in the stack.  The element length is calculated by dividing
	the  offset by the occurrence number.  */

	work_occurrence_inst_ptr -> inst_struc_basic.fill1_op = div_op;
	call cobol_emit (work_occurrence_inst_ptr, null (), 1);

/*  Store the quotient (in the Q ) into the stack space allocated to hold the element length  */
	element_length_inst_ptr -> inst_struc_basic.fill1_op = stq_op;
	call cobol_emit (element_length_inst_ptr, null (), 1);

     end get_index_item_data;


/**************************************************/
/*	INTERNAL PROCEDURE			*/
/*	increment_index_data_item		*/
/**************************************************/

increment_index_data_item:
     proc (index_data_item_ptr, work_offset_inst, work_occurrence_inst, element_length_inst);

/*
This procedure generates code to increment an index data item
that is referenced in the VARYING clause of a format 1 SEARCH
statement.  When this procedure is entered, code has been generated
to convert the contents of the index data item into the format of
an index data name in the stack.  (i.e. two consecutinve words of
storage; the first word contains the byte offset, the second
word contains the occurrence number.)
The value to be used to increment the byte offset is also
contained in a temporary in the stack.  This procedure generates
code that
	1. increments the value of the temporary index name
	representation.
	2. converts this index name representation to the
	index data item representation.
	3. moves the index data item representation into the
	index data item referenced in the VARYING clause.

*/

/*  DECLARATION OF THE PARAMETERS  */

dcl	index_data_item_ptr ptr;
dcl	work_offset_inst	bit (36);
dcl	work_occurrence_inst
			bit (36);
dcl	element_length_inst bit (36);

/*  DESCRIPTION OF THE PARAMETERS  */

/*
PARAMETER		DESCRIPTION

index_data_item_ptr	Pointer to the index data item token (type9)
		that is be be incremented because it appears
		in the VARYING clause of a SEARCH statement.
work_offset_inst	A word that contains the basic, non-eis
		address of the word containing the byte
		offset in the index data name format.
		(input)
work_occurrence_inst A word that contains the basic,non-eis
		address of the word containing the occurrence
		number in index data name format. (input)
element_length_inst	A word that contains the basic, non-eis
		address of the word containing the
		element length of the item represented
		by the index data item that appears in
		the VARYING clause.  (input)

*/

/*  DECLARATION OF INTERNAL STATIC VARIABLES  */

dcl	1 get_offset_code	int static,
	  2 i1		bit (36) init ("000000000000001100111011111000000000"b),
						/*  lrs 12  */
	  2 i2		bit (36) init ("000000000000000001111011101000000000"b),
						/*  als 1  */
	  2 i3		bit (36) init ("000000000000001000111011111000000000"b),
						/*  lls 8  */
	  2 i4		bit (36) init ("000000000000000001111011101000000000"b),
						/*  als 1  */
	  2 i5		bit (36) init ("000000000000001000111011111000000000"b),
	  2 i6		bit (36) init ("000000000000000001111011101000000000"b),
						/*  als 1  */
	  2 i7		bit (36) init ("000000000000001000111011111000000000"b);
						/*  lls 8  */


dcl	1 get_occurrence_code
			int static,
	  2 i1		bit (36) init ("000000000000011100111011111000000000"b),
						/*  lls 28  */
	  2 i2		bit (36) init ("000000000000000001111011101000000000"b),
						/*  als 1  */
	  2 i3		bit (36) init ("000000000000011010111011111000000000"b);
						/*  lls 26  */


/*  DECLARATION OF INTERNAL VARIABLES  */

dcl	work_offset_inst_ptr
			ptr;
dcl	work_occurrence_inst_ptr
			ptr;
dcl	element_length_inst_ptr
			ptr;

dcl	temp_ptr		ptr;

dcl	work_offset1	fixed bin;
dcl	work_offset2	fixed bin;
dcl	buff1		(1:10) ptr;
dcl	buff2		(1:10) ptr;
dcl	buff3		(1:10) ptr;

dcl	temp_offset_inst_ptr
			ptr;
dcl	temp_occurrence_inst_ptr
			ptr;
dcl	temp_offset_inst	bit (36);
dcl	temp_occurrence_inst
			bit (36);

/**************************************************/
/*	START OF EXECUTION			*/
/*	INTERNAL PROCEDURE			*/
/*	increment_index_data_item		*/
/**************************************************/

	work_offset_inst_ptr = addr (work_offset_inst);
	work_occurrence_inst_ptr = addr (work_occurrence_inst);
	element_length_inst_ptr = addr (element_length_inst);

	input_ptr = addr (buff1 (1));
	inst_ptr = addr (buff2 (1));
	reloc_ptr = addr (buff3 (1));

/*  Generate code to increment the work occurrence number by one.  */
	work_occurrence_inst_ptr -> inst_struc_basic.fill1_op = aos_op;
	call cobol_emit (work_occurrence_inst_ptr, null (), 1);

/*  Get the A and Q registers  */
	register_struc.what_reg = 3;			/*  A AND Q  */
	register_struc.lock = 0;
	register_struc.contains = 0;

	call cobol_register$load (addr (register_struc));

/*  Load the element length into the A register.  */
	element_length_inst_ptr -> inst_struc_basic.fill1_op = lda_op;
	call cobol_emit (element_length_inst_ptr, null (), 1);

/*  Add the contents of the A register to the byte offset in temporary storage.  */
	work_offset_inst_ptr -> inst_struc_basic.fill1_op = asa_op;
	call cobol_emit (work_offset_inst_ptr, null (), 1);

/*  At this point, code has been generated to increment the occurrence number by one,
	and the byte offset by the stored element length.  */

/*  Allocate 6 bytes on an even word boundary on the stack to receive the index data item
	format information.  */
	call cobol_alloc$stack (6, 2, work_offset1);


/*  Convert the word offset to a byte offset.  */
	work_offset1 = work_offset1 * 4;

/*  Calculate the byte offset of the occurrence number bytes of the temporary index data item.  */
	work_offset2 = work_offset1 + 4;

/*  Get the basic, non-eis address of the byte offset and occurrence number bytes.  */
	temp_offset_inst_ptr = addr (temp_offset_inst);
	temp_occurrence_inst_ptr = addr (temp_occurrence_inst);

	input_struc_basic.type = 1;			/*  basic, non-eis  */
	input_struc_basic.operand_no = 0;
	input_struc_basic.segno = 1000;		/*  stack  */

	input_struc_basic.char_offset = work_offset1;
	call cobol_addr (input_ptr, temp_offset_inst_ptr, reloc_ptr);

	input_struc_basic.char_offset = work_offset2;
	call cobol_addr (input_ptr, temp_occurrence_inst_ptr, reloc_ptr);

/*  Generate an instruction to load the stored offset into the Q.  */
	work_offset_inst_ptr -> inst_struc_basic.fill1_op = ldq_op;
	call cobol_emit (work_offset_inst_ptr, null (), 1);

/*  Emit a stream of code to expand the offset and insert the junk bits.
	The expanded result winds up in the A register.  */
/*  The emitted code stream is:
		lls 12
		als 1
		lls 8
		als 1
		lls 8
		als 1
		lls 8
	*/

	call cobol_emit (addr (get_offset_code), null (), 7);

/*  Emit code to store the A register into the temporary storage set aside for the offset
		part of the index data item.  */
	temp_offset_inst_ptr -> inst_struc_basic.fill1_op = sta_op;
	call cobol_emit (temp_offset_inst_ptr, null (), 1);

/*  Emit code to load the Q register with the occurrence number from the temporary.  */
	work_occurrence_inst_ptr -> inst_struc_basic.fill1_op = ldq_op;
	call cobol_emit (work_occurrence_inst_ptr, null (), 1);

/*  Emit a stream of code to expand the occurrence number and insert the junk bits.
	The expanded result winds up in the 2 leftmost bytes of the a register.  */
/*  The emitted stream is:
		lls 28
		als 1
		lls 26
	*/

/*  Emit the stream of code.  */
	call cobol_emit (addr (get_occurrence_code), null (), 3);

/*  Emit code to store the A register into the temporary storage for the occurrence number
	part of the index data item.  */
	temp_occurrence_inst_ptr -> inst_struc_basic.fill1_op = sta_op;
	call cobol_emit (temp_occurrence_inst_ptr, null (), 1);

/*  At this point, we have generated code to expand the offset and occurrence number and
	store these values in index data item format in the six bytes of storage in the stack.  */

/*  Now we must generate code to move the temporary index stat item from the stack
	into the index data item being incremented during the execution of the SEARCH.  */

/*  Make a copy of the input index data item token.  */

	temp_ptr = null ();
	call cobol_make_type9$copy (temp_ptr, index_data_item_ptr);

/*  Modify the copy so that it describes the six byte temporary in the stack.  */
	temp_ptr -> data_name.seg_num = 1000;		/*  stack  */
	temp_ptr -> data_name.offset = work_offset1;
	temp_ptr -> data_name.subscripted = "0"b;

/*  Build the input structure to the addressability utility.  */
	input_struc.type = 5;			/*  EIS, 2 operands input; instruction and 2 descriptors returned.  */
	input_struc.operand_no = 2;
	input_struc.lock = 0;

	input_struc.operand.token_ptr (1) = temp_ptr;
	input_struc.operand.send_receive (1) = 0;	/*  Sending  */
	input_struc.operand.size_sw (1) = 0;

	input_struc.operand.token_ptr (2) = index_data_item_ptr;
	input_struc.operand.send_receive (2) = 1;	/*  Receiving  */
	input_struc.operand.size_sw (2) = 0;

	call cobol_addr (input_ptr, inst_ptr, reloc_ptr);

/*  Set the mlr opcode into the instruction  */
	inst_struc.inst.fill1_op = mlr_op;

/*  Emit the instruction to move the temp index data item image to the index data item
		being incremented.  */
	call cobol_emit (inst_ptr, reloc_ptr, 3);

     end increment_index_data_item;

format2_search:
     proc;



/*  DECLARATION OF AN ENTRY ARRAY.  */

dcl	fmt2_eos_proc	(1:3) entry init (fmt2_eos1, fmt2_eos2, fmt2_eos3);

/**************************************************/
/*	START OF EXECUTION			*/
/*	INTERNAL PROCEDURE			*/
/*	format2_search			*/
/**************************************************/

	call fmt2_eos_proc (in_token.token_ptr (in_token.n) -> end_stmt.e);


fmt2_eos1:
     proc;

/*  Reserve a tag to be defined at the first instruction generated to test whether
	the index name is within limits.  */

	check_index_tag = cobol_$next_tag;

/*  Reserve a tag to be defined at the first instruction generated for the WHEN clause.  */

	next_when_tag = check_index_tag + 1;

/*  Reserve a tag to be defined at the first instruction of the next cobol statement.
	(The statement following this SEARCH statement. )  */

	next_stmt_tag = check_index_tag + 2;

	next_compare_tag = cobol_$next_tag + 3;

/*  Update the next tag counter in MCOBOL external data segment.  */

	cobol_$next_tag = cobol_$next_tag + 4;

	dn_ptr = in_token.token_ptr (2);
	if data_name.occurs_do
	then do;
		call cobol_read_rand (1, data_name.do_rec, com2_ptr);
		call cobol_read_rand (3, odo_rec.descr, dn_ptr);
		do_ptr = dn_ptr;
	     end;
	else do_ptr = null ();

/*  Generate code to initialize the index name being used in the search.  */

/*  Set up the in_token structure for a call to the SET generator.  */

	in_token_ptr = addr (work_in_token (1));
	in_token.token_ptr (1) = save_in_token_ptr -> in_token.token_ptr (1);
						/*  Reserved word SEARCH  */
	in_token.token_ptr (2) = save_in_token_ptr -> in_token.token_ptr (3);
						/*  Index name token.  */
	in_token.token_ptr (3) = addr (numeric_lit_1);
	in_token.token_ptr (4) = addr (set_eos_token);
	in_token.n = 4;
	set_eos_token.a = "000"b;			/*  Format 1 set.  */
	set_eos_token.e = 1;			/*  One operand to be set.  */

/*  Call the SET generator.  */
	call cobol_set_gen (in_token_ptr);


/*  Generate code to determine whether the index is at its maximum value.  */

	eos_ptr = save_in_token_ptr -> in_token.token_ptr (save_in_token_ptr -> in_token.n);

/*  Build an in_token structure for calling cobol_compare_gen.  */

	in_token.token_ptr (1) = null ();		/*  in_token.token_ptr(2) points to the index name already.  (It was set above when
	the in_token structure was built for the call to cobol_set_gen.  */

	in_token.token_ptr (3) = addr (work_numeric_lit);
	in_token.token_ptr (4) = addr (compare_eos_token);
	in_token.n = 4;

/*  Convert the maximum value that can be contained in the index name to a character string literal.  */


	work_numeric_lit.places_left = work_numeric_lit.places;

	compare_eos_token.e = 102;			/*  COMPARE EQUAL  */
	compare_eos_token.i = "000"b;			/*  Transfer if equal to the tag in end_stmt.h.  */

	if end_stmt.b = "1"b
	then do;					/*  AT END CLAUSE present.  */
						/*  Reserve a tag to be defined at the first instruction generated
		for the AT END clause.  */

		at_end_tag = cobol_$next_tag;
		cobol_$next_tag = cobol_$next_tag + 1;
		compare_eos_token.h = at_end_tag;	/*  Transfer to the at_end_tag when the index equals
			its maximum value.  */

	     end;					/*  AT END CLAUSE present.  */

	else compare_eos_token.h = next_stmt_tag;	/*  Transfer to the next Cobol statement when the
			index equals its maximum value.  */

	if do_ptr ^= null ()
	then do;
		in_token.token_ptr (3) = do_ptr;
		call bin_to_char (fixed (in_token.token_ptr (2) -> index_name.max, 17), work_numeric_lit.literal,
		     work_numeric_lit.places);
		work_numeric_lit.places_left = work_numeric_lit.places;
		compare_eos_token.e = 113;		/* greater compare */
		call cobol_compare_gen (in_token_ptr);
		compare_eos_token.e = 102;
	     end;

/*  Generate an instruction to transfer to the next_when_tag.  */

	call cobol_emit (addr (tra_inst), null (), 1);

/*  Make a tag reference at the instruction just emitted.  */
	call cobol_make_tagref (next_when_tag, cobol_$text_wd_off - 1, null ());

/*  Define the check_index_tag at the next instruction to be generated.  */
	call cobol_define_tag (check_index_tag);

	call bin_to_char (fixed (in_token.token_ptr (2) -> index_name.max, 17), work_numeric_lit.literal,
	     work_numeric_lit.places);
	work_numeric_lit.places_left = work_numeric_lit.places;

	if do_ptr ^= null ()
	then do;
		call cobol_compare_gen (in_token_ptr);
		in_token.token_ptr (3) = addr (work_numeric_lit);
	     end;
	call cobol_compare_gen (in_token_ptr);

/*  Generate code to increment the index by 1.  */

	in_token.token_ptr (1) = save_in_token_ptr -> in_token.token_ptr (1);
						/*  in_token.token_ptr(2) still points to the index name token.  */
	in_token.token_ptr (3) = addr (numeric_lit_1);
	in_token.token_ptr (4) = addr (set_eos_token);

	set_eos_token.a = "001"b;			/*  FOR AT 2 SET  */
	set_eos_token.b = "0"b;			/*  UP  */

	call cobol_set_gen (in_token_ptr);

/*  Check to see if AT END clause was present.  If present, generate a transfer to the WHEN clause.  */

	if end_stmt.b = "1"b
	then do;					/*  AT END CLAUSE present.  */

/*  Generate a transfer.  */
		call cobol_emit (addr (tra_inst), null (), 1);

/*  Make a reference to the next_when_tag at the instruction just emitted.  */
		call cobol_make_tagref (next_when_tag, cobol_$text_wd_off - 1, null ());

/*  Define the at_end_tag at the next instruction location.  */
		call cobol_define_tag (at_end_tag);


	     end;					/*  AT END CLAUSE present.  */

	else /*  Define the next_when tag at the next instruction location.  */
	     call cobol_define_tag (next_when_tag);

     end fmt2_eos1;


fmt2_eos2:
     proc;


	if in_token.token_ptr (in_token.n) -> end_stmt.b = "1"b
	then /*  This is the lase EOS2 in the SEARCH statement.  */ /*  Define the next_stmt_tag.  */
	     call cobol_define_tag (next_stmt_tag);

	else do;					/*  This is not the last EOS2 in the SEARCH statement.  */
						/*  Generate code to transfer to the next_stmt_tag.  */
		call cobol_emit (addr (tra_inst), null (), 1);

/*  Make a tagref at the instruction just emitted.  */
		call cobol_make_tagref (next_stmt_tag, cobol_$text_wd_off - 1, null ());

/*  Define the next_when_tag at the next instruction location.  */

		call cobol_define_tag (next_when_tag);

	     end;					/*  This is not the last EOS2 in the SEARCH statement.  */

     end fmt2_eos2;


fmt2_eos3:
     proc;

dcl	ix		fixed bin;
dcl	iy		fixed bin;		/*  Build an in_token structure for calling cobol_compare_gen.  */
	in_token_ptr = addr (work_in_token);
	in_token.n = 3;
	in_token.token_ptr (3) = addr (compare_eos_token);
	compare_eos_token.h = check_index_tag;
	compare_eos_token.i = "010"b;			/*  Transfer if not equal to check_index_tag.  */

	ix = 1;
	iy = 1;					/*  Generate code to compare two operands and transfer to check_index_tag if not equal.  */

/*  Process each pair of operands in the input token structure.  */

	do while (save_in_token_ptr -> in_token.token_ptr (iy) -> end_stmt.type ^= rtc_eos);

/*  Get a pointer to the first operand of the comparison.  */
	     in_token.token_ptr (1) = save_in_token_ptr -> in_token.token_ptr (ix);

/*  Get a pointer to the second operand of the comparison.  Note that the token for
			the reserved word EQUAL is in in_token.token_ptr(ix+ 1)  */

	     in_token.token_ptr (2) = save_in_token_ptr -> in_token.token_ptr (ix + 2);

	     call cobol_compare_gen (in_token_ptr);

/*  Increment the index to reference the pointer following the 2nd operand.  */
	     ix = ix + 4;
	     iy = ix - 1;

	end;

     end fmt2_eos3;
     end format2_search;

bin_to_char:
     proc (bin_value, ret_string, ret_length);

dcl	bin_value		fixed bin;
dcl	ret_string	char (*);
dcl	ret_length	fixed bin (15);

dcl	digit		fixed bin;
dcl	work_string	char (20);
dcl	work_value	fixed bin;
dcl	iy		fixed bin;

dcl	char_value	(0:9) char (1) int static init ("0", "1", "2", "3", "4", "5", "6", "7", "8", "9");

	if bin_value = 0
	then do;					/*  INput value is zero.  */
		ret_length = 1;
		substr (ret_string, 1, 1) = char_value (0);
	     end;					/*  Input value is zero.  */

	else do;					/*  Input value non-zero.  */

		work_value = bin_value;
		iy = 0;

		do while (work_value ^= 0);
		     iy = iy + 1;
		     digit = mod (work_value, 10);
		     work_value = work_value / 10;
		     substr (work_string, 21 - iy, 1) = char_value (digit);
		end;
		substr (ret_string, 1, iy) = substr (work_string, 21 - iy, iy);
		ret_length = iy;
	     end;


     end bin_to_char;

/**************************************************/
/*	INCLUDE FILES USED BY THIS PROCEDURE	*/
/**************************************************/


/*****	Declaration for builtin function	*****/

dcl	(substr, mod, binary, fixed, addr, addrel, rel, length, string, unspec, null, index)
			builtin;

/*****	End of declaration for builtin function	*****/

%include cobol_type19;


%include cobol_type30;


%include cobol_type10;


%include cobol_type9;


%include cobol_in_token;

%include cobol_record_types;


%include cobol_;


%include cobol_occurs_ext;


%include cobol_addr_tokens;
%include cobol_odo_rec;



/**************************************************/
/*	END OF EXTERNAL PROCEDURE		*/
/*	cobol_search_gen			*/
/**************************************************/

     end cobol_search_gen;
