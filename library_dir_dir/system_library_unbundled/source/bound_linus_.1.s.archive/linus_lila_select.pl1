/* ***********************************************************
   *                                                         *
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
   *                                                         *
   *                                                         *
   *********************************************************** */

/* ******************************************************
   *                                                    *
   *                                                    *
   * Copyright (c) 1972 by Massachusetts Institute of   *
   * Technology and Honeywell Information Systems, Inc. *
   *                                                    *
   *                                                    *
   ****************************************************** */

linus_lila_select:
     proc (lcb_ptr, lsh_ptr, inner, td_ptr, code);

/* DESCRIPTION:

   This  procedure  processes the select clause of a LILA block.  If this is an
   inner  LILA  block, the second leaf of a predicate term is created.  If this
   is an outer block, a list of selected items is created in the lila stack for
   the block.



   HISTORY:

   77-07-01 J. A. Weeldreyer: Initially written.

   78-03-01  J.   A.   Weeldreyer:  Modified to detect invalid tokens in select
   clause.

   78-04-01  J.   A.   Weeldreyer:  Modified  to  give  better  diagnostics for
   constant expresions or scalar functions.

   78-06-01 J. A. Weeldreyer: Modified to disallow update of temp tables.

   78-08-01 J. A. Weeldreyer: Modified to conform to new token data.

   79-02-01  J.   C.   C.   Jagernauth:  Modified to access version 4 resultant
   information.

   80-01-08  Rickie  E.   Brinegar:  modified  to  pass  linus_lila_alloc_lit a
   descriptor  pointer  rather than an assign_ descriptor type and to eliminate
   the assign_ length parameter.

   80-04-13   Rickie   E.    Brinegar:   to   use   a   work  area  defined  on
   lcb.lila_area_ptr instead of getting system free area.

   80-06-23 Jim Gray: to capture select * with >1 table in from clause.

   80-09-15 Rickie E.  Brinegar: Modified to not call dsl_$get_rstl_info but to
   use the linus_rel_array instead.

   81-02-03   Rickie  E.   Brinegar:  Added  the  temp  table  names.   Changed
   add_sel_tuple to use the temp tuple names instead of temp table indices with
   the  char  builtin used on them.  Added the rel builtin to the declarations.
   Removed the unused entry points dsl(_ v1_)$get_(rslt temp)_info.

   81-06-19  Rickie  E.   Brinegar: Removed the use of lcb.new_version and the
   copying  of  descriptors  returned  by  dsl_$get_(temp  rslt)_info into the
   rslt_info structure as the routine that returns the rslt_info structure has
   been modified to fill in the descriptors in the rslt_info_structure.
   
   81-07-15 Rickie E. Brinegar: Removed useless cleanup condition handler.

   82-11-28 Dave Schimke: Added code to the internal proc add_sel_item to also
   save the table name for each column in select_info.user_item.table_name.
   This is for use in the default column names generated by linus_table.

   83-07-14 Dave Schimke: Changed select_info.user_item.table_name (added 
   above) to contain the name of the tuple variable used in the selection 
   expression rather than the actual database table name. This was requested 
   by users during the report_writer controlled release.

   83-08-18 Al Dupuis: Fixed a bug caused by the above change (83-07-14) in
   the add_sel_tuple procedure. Rather than take it from 
   ls_block.range_items.tup_var (i), it only takes it from there when mvar
   is set to something like "V00001". The variable mvar contains the correct
   tuple variable in all other cases.
*/

%include linus_lcb;
%page;
%include linus_ef_data;
%page;
%include linus_ls_header;
%page;
%include linus_ls_set;
%page;
%include linus_ls_block;
%page;
%include linus_mrds_block;
%page;
%include linus_rel_array;
%page;
%include linus_select_info;
%page;
%include linus_temp_tab_names;
%page;
%include linus_token_data;
%page;
%include mrds_rslt_info;
%page;
%include mdbm_att_desc;

	dcl     (
	        code,				/* Output: status code */
	        icode,				/* internal status code */
	        bit_len_sink,			/* repository for unused bit length */
	        temp_cur_pos
	        )			 fixed bin (35);	/* temp curr. pos. for look ahead */
	dcl     (
	        inner,				/* Input: on if inner LILA block */
	        lb_flag,				/* on if left bracket OK */
	        sel_flag,				/* on if "select" OK */
	        end_flag,				/* on if select list end OK */
	        un_dup_flag,			/* on if unique or dup OK */
	        item_flag,				/* on if select item OK */
	        done
	        )			 bit (1);		/* completion indicator */

	dcl     work_area		 area (sys_info$max_seg_size) based (lcb.lila_area_ptr);
	dcl     token		 char (token_data.length) based (token_data.t_ptr);

	dcl     1 tok_data		 aligned like token_data;

	dcl     1 expr_data		 aligned like ef_data;

	dcl     MRDS		 fixed bin int static options (constant) init (1);
	dcl     SEL_EXPR		 fixed bin int static options (constant) init (2);

	dcl     (
	        linus_data_$max_pred_stack_size,
	        linus_data_$max_range_items,
	        linus_data_$max_expr_items,
	        linus_data_$max_set_stack_size,
	        linus_error_$bad_inner_select,
	        linus_error_$cant_alloc_lit,
	        linus_error_$const_expr_fn,
	        linus_error_$expr_not_alld,
	        linus_error_$incomplete_select,
	        linus_error_$no_table,
	        linus_error_$select_list_ovfl,
	        linus_error_$select_syntax,
	        linus_error_$too_many_tables,
	        linus_error_$union_compat,
	        mrds_data_$max_select_items,
	        mrds_data_$max_temp_rels,
	        mrds_data_$max_token_size,
	        sys_info$max_seg_size
	        )			 fixed bin (35) ext;

	dcl     (addr, before, fixed, length, rel, null, substr) builtin;

	dcl     linus_assign_data	 entry (bit (36) aligned, fixed bin, fixed bin (35));
	dcl     linus_lila_alloc_lit	 entry (ptr, ptr, ptr, fixed bin (35));
	dcl     linus_lila_build_expr_tab entry (ptr, ptr, ptr, ptr, fixed bin (35));
	dcl     linus_lila_build_expr_str
				 entry (ptr, ptr, ptr, ptr, char (*), fixed bin (35));
	dcl     linus_lila_error	 entry (ptr, ptr, fixed bin (35), char (*));
	dcl     linus_lila_get_token	 entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
	dcl     linus_lila_term$stack_term entry (ptr, ptr);

	ttn_ptr = lcb.ttn_ptr;
	linus_rel_array_ptr = lcb.rel_array_ptr;
	mblk_ptr, rdesc_ptr, rslt_ptr = null;		/* initiallize */
	lsb_ptr = ls_header.cur_ptr;
	lss_ptr = ls_block.back_ptr;
	si_ptr = ls_set.si_ptr;

	if token_data.key = NULL then do;		/* if no token passed in */
		call
		     linus_lila_get_token (lcb_ptr, lsh_ptr, ls_header.cur_pos, td_ptr,
		     icode);
		if icode ^= 0 then
		     call linus_lila_error (lcb_ptr, lsh_ptr, icode, token);
	     end;					/* getting first token */

	lb_flag,					/* initialize state flags */
	     sel_flag = "1"b;			/* can have { or select */
	end_flag, un_dup_flag, item_flag = "0"b;

	done = "0"b;

	do while (^done);

	     go to token_proc (token_data.key);		/* go process the current token */

token_proc (0):					/* null */
token_proc (1):					/* ) */
token_proc (3):					/* linus variable */
token_proc (4):					/* constant */
token_proc (5):					/* set function */
token_proc (9):					/* / */
token_proc (10):					/* + */
token_proc (11):					/* - */
token_proc (12):					/* table name */
token_proc (13):					/* row_table_pair */
token_proc (14):					/* union */
token_proc (15):					/* inter */
token_proc (16):					/* differ */
token_proc (19):					/* } */
token_proc (21):					/* ^ */
token_proc (22):					/* & */
token_proc (23):					/* | */
token_proc (24):					/* = */
token_proc (25):					/* ^= */
token_proc (26):					/* > */
token_proc (27):					/* >= */
token_proc (28):					/* < */
token_proc (29):					/* <= */
token_proc (30):					/* from */
token_proc (31):					/* where */
token_proc (34):					/* , */
	     if ^end_flag then /* if end not allowed */
		call
		     linus_lila_error (lcb_ptr, lsh_ptr,
		     linus_error_$incomplete_select, token);
	     if token_data.key ^= FROM then
		call
		     linus_lila_error (lcb_ptr, lsh_ptr, linus_error_$select_syntax,
		     token);
	     done = "1"b;				/* to get out of loop */
	     go to next;

token_proc (2):					/* column specification */
	     if ^item_flag then /* if select item not allowed */
		call
		     linus_lila_error (lcb_ptr, lsh_ptr, linus_error_$select_syntax,
		     token);

	     temp_cur_pos = ls_header.cur_pos;		/* save real pos. */
	     call linus_lila_get_token (lcb_ptr, lsh_ptr, temp_cur_pos,
						/* look at next token */
		addr (tok_data), icode);
	     if icode = 0 then /* if success. */
		if tok_data.key >= STAR & tok_data.key <= MINUS then
		     /* if arith oper. */
		     call process_expr;		/* is expr. process it */
		else call process_col_spec;		/* is just col. spec. */
	     else call process_col_spec;

	     un_dup_flag = "0"b;			/* wont accept unique/dup anymore */
	     end_flag = "1"b;			/* allow termination */
	     go to next;				/* end column specification */

token_proc (6):					/* scalar function */
token_proc (7):					/* ( */
	     if ^item_flag then /* if select item not allowed */
		call
		     linus_lila_error (lcb_ptr, lsh_ptr, linus_error_$select_syntax,
		     token);

	     call process_expr;			/* this is an expr, process it */

	     end_flag = "1"b;			/* reset state flags */
	     un_dup_flag = "0"b;

	     go to next;				/* end expr. */

token_proc (8):					/* * */
	     if ^item_flag then /* if select item not allowed */
		call
		     linus_lila_error (lcb_ptr, lsh_ptr, linus_error_$select_syntax,
		     token);
	     if inner then /* total tuple not allowed in inner block */
		call
		     linus_lila_error (lcb_ptr, lsh_ptr,
		     linus_error_$bad_inner_select, token);
	     if ls_block.nritems < 1 then /* if no range items */
		call
		     linus_lila_error (lcb_ptr, lsh_ptr, linus_error_$no_table,
		     token);
	     if ls_block.nritems > 1 then
		call
		     linus_lila_error (lcb_ptr, lsh_ptr,
		     linus_error_$too_many_tables, token);

	     select_info.se_flags.val_mod = "0"b;	/* cant mod. entire tuple */

	     call
		add_sel_tuple ((ls_block.range_items.tup_var (ls_block.dflt_ritem)))
		;				/* add tuple to sel. list */
	     end_flag = "1"b;			/* set state flags */
	     un_dup_flag = "0"b;
	     token_data.key = NULL;			/* force new token */
	     go to next;				/* end * */

token_proc (17):					/* row descriptor */
	     if ^item_flag then /* if select item not allowed */
		call
		     linus_lila_error (lcb_ptr, lsh_ptr, linus_error_$select_syntax,
		     token);
	     if inner then /* total tuple not alowed in inner block */
		call
		     linus_lila_error (lcb_ptr, lsh_ptr,
		     linus_error_$bad_inner_select, token);

	     select_info.se_flags.val_mod = "0"b;	/* cant mod. total tuple */

	     call add_sel_tuple (token);		/* add tuple to sel. list */

	     token_data.key = NULL;			/* force new token */
	     end_flag = "1"b;			/* set state flags */
	     un_dup_flag = "0"b;

	     go to next;				/* end row descr. */

token_proc (18):					/* { */
	     if ^lb_flag then /* if { not expected */
		call
		     linus_lila_error (lcb_ptr, lsh_ptr, linus_error_$select_syntax,
		     token);
	     token_data.key = NULL;			/* force new token */
	     lb_flag = "0"b;			/* dont want another one */
	     go to next;				/* end { */

token_proc (20):					/* select */
	     if ^sel_flag then /* if select not expected */
		call
		     linus_lila_error (lcb_ptr, lsh_ptr, linus_error_$select_syntax,
		     token);
	     token_data.key = NULL;			/* force new token */
	     lb_flag,				/* reset state flags */
		sel_flag = "0"b;
	     un_dup_flag, item_flag = "1"b;
	     go to next;				/* end select */

token_proc (32):					/* dup */
	     if ^un_dup_flag then /* if dup not expected */
		call
		     linus_lila_error (lcb_ptr, lsh_ptr, linus_error_$select_syntax,
		     token);
	     ls_set.dup_flag = "1"b;			/* remember */
	     un_dup_flag = "0"b;
	     token_data.key = NULL;
	     go to next;				/* end dup */

token_proc (33):					/* unique */
	     if ^un_dup_flag then /* if unique not expected */
		call
		     linus_lila_error (lcb_ptr, lsh_ptr, linus_error_$select_syntax,
		     token);
	     ls_set.unique_flag = "1"b;		/* remember */
	     un_dup_flag = "0"b;
	     token_data.key = NULL;
	     go to next;

next:
	     if token_data.key = NULL then do;		/* if need new token */
		     call
			linus_lila_get_token (lcb_ptr, lsh_ptr, ls_header.cur_pos,
			td_ptr, icode);
		     if icode ^= 0 then
			call linus_lila_error (lcb_ptr, lsh_ptr, icode, token);
		end;

	end;					/* main processing loop */

	code = 0;
exit:
	return;

process_expr:
     proc;

/* Procedure to handle expressions */

	dcl     var		 char (32);
	dcl     i			 fixed bin;

	if inner then do;				/* if inner block */
		var = "";
		call
		     linus_lila_build_expr_str (lcb_ptr, lsh_ptr, td_ptr, mblk_ptr, var,
		     icode);			/* build expr string, */
		if icode ^= 0 then
		     call linus_lila_error (lcb_ptr, lsh_ptr, icode, "");
		if var = "" then
		     call
			linus_lila_error (lcb_ptr, lsh_ptr, linus_error_$const_expr_fn,
			"");
		ls_block.leaf_ptr (2) = mblk_ptr;	/* put in second leaf */
		mblk_ptr = null;
		call linus_lila_term$stack_term (lcb_ptr, lsh_ptr); /* make into term */
		item_flag = "0"b;			/* inner blocks have only one item */
	     end;					/* if inner block */

	else do;					/* is outer LILA block */
		if ^ls_set.first_block then /* expr. not allowed for set opers. */
		     call
			linus_lila_error (lcb_ptr, lsh_ptr, linus_error_$expr_not_alld,
			token);
		ls_set.inv_setop = "1"b;
		select_info.se_flags.val_dtt,		/* exprs valid only for retrieve */
		     select_info.se_flags.val_mod, select_info.se_flags.val_del = "0"b;
		expr_data.nmrds_items = 0;
		expr_data.var_name = " ";

		call
		     linus_lila_build_expr_tab (lcb_ptr, lsh_ptr, td_ptr,
		     addr (expr_data), icode);	/* build table  for expr */
		if icode ^= 0 then
		     call linus_lila_error (lcb_ptr, lsh_ptr, icode, "");

		do i = 1 to expr_data.nmrds_items;	/* process the required mrds items */
		     if select_info.n_mrds_items >= select_info.nmi_alloc then
			/* if overflow */
			call
			     linus_lila_error (lcb_ptr, lsh_ptr,
			     linus_error_$select_list_ovfl, "");
		     select_info.n_mrds_items = select_info.n_mrds_items + 1;
		     select_info.mrds_item.bit_len (select_info.n_mrds_items) =
			expr_data.mrds_items.bit_length (i);
		     select_info.mrds_item.desc (select_info.n_mrds_items) =
			expr_data.mrds_items.desc (i);
		     select_info.mrds_item.arg_ptr (select_info.n_mrds_items) =
			expr_data.mrds_items.assn_ptr (i);
		     select_info.mrds_item.assn_type (select_info.n_mrds_items) =
			expr_data.mrds_items.assn_type (i);
		     select_info.mrds_item.assn_len (select_info.n_mrds_items) =
			expr_data.mrds_items.assn_len (i);
		end;				/* mrds items loop */
		if select_info.n_user_items >= select_info.nui_alloc then
		     /* if user item ovfl */
		     call
			linus_lila_error (lcb_ptr, lsh_ptr,
			linus_error_$select_list_ovfl, "");
		select_info.n_user_items = select_info.n_user_items + 1;
		do i = 1 to ls_block.nritems
		     while (expr_data.var_name ^= ls_block.range_items.mrds_var (i));
		end;
		select_info.user_item.name (select_info.n_user_items),
		select_info.user_item.table_name (select_info.n_user_items)
		     = ls_block.range_items.tup_var (i);	/* fill in user item info */

		select_info.user_item.item_type (select_info.n_user_items) = SEL_EXPR;
		select_info.user_item.rslt_desc (select_info.n_user_items) =
		     expr_data.desc;
		select_info.user_item.rslt_bit_len (select_info.n_user_items) =
		     expr_data.bit_length;
		select_info.user_item.rslt_assn_ptr (select_info.n_user_items) =
		     expr_data.assn_ptr;
		select_info.user_item.rslt_assn_type (select_info.n_user_items) =
		     expr_data.assn_type;
		select_info.user_item.rslt_assn_len (select_info.n_user_items) =
		     expr_data.assn_len;
		select_info.user_item.item_ptr (select_info.n_user_items) =
		     expr_data.ef_ptr;
	     end;					/* if outer block */

     end process_expr;

process_col_spec:
     proc;

/* Procedure to process a column spec. */

	dcl     (i, j)		 fixed bin;

	dcl     rel_name		 char (32) init ("");

	if inner then do;				/* if inner block, merely place in second term leaf */
		nval_args_init = 0;			/* set up mrds block */
		ms_len_init = token_data.length + length (token_data.mvar) + 1;
		allocate mrds_block in (work_area);
		mrds_block.fwd_ptr = null;
		mrds_block.mrds_string = token_data.mvar || "." || token;
		ls_block.leaf_ptr (2) = mblk_ptr;	/* put in second leaf */
		mblk_ptr = null;
		if token_data.must_free then
		     token_data.t_ptr = null;
		call linus_lila_term$stack_term (lcb_ptr, lsh_ptr); /* add term to term stack */
		item_flag = "0"b;			/* no more items for inner select */
	     end;					/* if inner block */

	else do;					/* is outer block */
		if ls_block.nselects >= mrds_data_$max_select_items then
		     /* check overflow */
		     call
			linus_lila_error (lcb_ptr, lsh_ptr,
			linus_error_$select_list_ovfl, token);
		do i = 1 to ls_block.nritems
		     while (ls_block.range_items.mrds_var (i) ^= token_data.mvar);
		end;				/* search for range item */
		if ls_block.range_items.rel_name (i) = ".V." then do;
						/* if temp rel. */
			select_info.se_flags.val_del, /* cant update temp tables */
			     select_info.se_flags.val_mod = "0"b;
			rel_name = temp_tab_names (ls_block.range_items.rel_index (i));
		     end;
		else rel_name = ls_block.range_items.rel_name (i);
		if ls_set.first_block
		     then select_info.user_item.table_name (select_info.n_user_items + 1) 
		   = ls_block.range_items.tup_var (i);	

		do j = 1 to linus_rel_array.num_of_rels
		     while (linus_rel_array.rels.rel_name (j) ^= rel_name);
		end;
		rslt_ptr = linus_rel_array.rels.rslt_info_ptr (j);
		do i = 1 to rslt_info.num_attr
		     while (rslt_info.attr.attr_name (i) ^= token);
		end;				/* search for particular attr. */

		call add_sel_item (token_data.mvar, i); /* add item to select list */
		rslt_ptr = null;
	     end;					/* if outer block */

	token_data.key = NULL;			/* force new token */

     end process_col_spec;

add_sel_tuple:
     proc (tup_var);

/* Procedure to add each attribute of a relation designated by tup_var to the
   select list */

	dcl     (i, j)		 fixed bin;
	dcl     rel_name		 char (32) init ("");
	dcl     tup_var		 char (*);
	dcl     mvar		 char (32) var;

	do i = ls_block.nritems by -1 to 1
	     while (ls_block.range_items.tup_var (i) ^= tup_var);
	end;					/* search for range item */
	mvar = ls_block.range_items.mrds_var (i);
	if ls_block.range_items.rel_name (i) = ".V." then do; /* if temp rel */
		select_info.se_flags.val_del,		/* cant update temp tables */
		     select_info.se_flags.val_mod = "0"b;
		rel_name = temp_tab_names (ls_block.range_items.rel_index (i));
	     end;
	else rel_name = ls_block.range_items.rel_name (i);

	do j = 1 to linus_rel_array.num_of_rels
	     while (linus_rel_array.rels.rel_name (j) ^= rel_name);
	end;
	rslt_ptr = linus_rel_array.rels.rslt_info_ptr (j);
	if rslt_info.num_attr + ls_block.nselects > mrds_data_$max_select_items
	then /* if overflow */
	     call
		linus_lila_error (lcb_ptr, lsh_ptr, linus_error_$select_list_ovfl,
		token);
	do i = 1 to rslt_info.num_attr;		/* add each attr. to select list */
	     call add_sel_item (mvar, i);
	     if ls_set.first_block
	     then if length (mvar) > 2
	          then if substr (mvar, 1, 3) = "V00"
		     then select_info.user_item.table_name (select_info.n_user_items) = rel_name;
	               else select_info.user_item.table_name (select_info.n_user_items) = mvar;
		else select_info.user_item.table_name (select_info.n_user_items) = mvar;
	     else;
	     end;

     end add_sel_tuple;

add_sel_item:
     proc (mvar, attr_ind);

/* Procedure to add a select list item given the attr index into rslt_info,
   and the tuple variable name */

	dcl     (attr_ind, assn_type)  fixed bin;
	dcl     assn_len		 fixed bin (35);
	dcl     assn_ptr		 ptr init (null);
	dcl     mvar		 char (32) var;

	ls_block.nselects = ls_block.nselects + 1;
	ls_block.sel_items (ls_block.nselects) = /* add to select list */
	     mvar || "." || before (rslt_info.attr.attr_name (attr_ind), " ");

	if ^ls_set.first_block then /* if not first block, check compat. */
	     if ls_set.domain_info.name (ls_block.nselects)
		^= rslt_info.attr.domain_name (attr_ind) then
		call
		     linus_lila_error (lcb_ptr, lsh_ptr,
		     linus_error_$union_compat, token);
	     else ;				/* if is OK do nothing */
	else do;					/* is first block, add domain info */
		call
		     linus_assign_data (rslt_info.attr.descriptor (attr_ind), assn_type,
		     assn_len);
		call
		     linus_lila_alloc_lit (lcb_ptr,
		     addr (rslt_info.attr.descriptor (attr_ind)), assn_ptr, bit_len_sink)
		     ;
		if assn_ptr = null then /* couldnt alloc. */
		     call
			linus_lila_error (lcb_ptr, lsh_ptr,
			linus_error_$cant_alloc_lit, token);
		ls_set.nselects = ls_set.nselects + 1;
		ls_set.domain_info.name (ls_set.nselects) =
		     rslt_info.attr.domain_name (attr_ind);
		ls_set.domain_info.bit_length (ls_set.nselects) =
		     rslt_info.attr.attr_length (attr_ind);
		ls_set.domain_info.desc (ls_set.nselects) =
		     rslt_info.attr.descriptor (attr_ind);
		ls_set.domain_info.assn_ptr (ls_set.nselects) = assn_ptr;
		ls_set.domain_info.assn_type (ls_set.nselects) = assn_type;
		ls_set.domain_info.assn_len (ls_set.nselects) = assn_len;
		if select_info.n_mrds_items >= select_info.nmi_alloc
		     /* if could overflow */
		     | select_info.n_user_items >= select_info.nui_alloc then
		     call
			linus_lila_error (lcb_ptr, lsh_ptr,
			linus_error_$select_list_ovfl, "");
		select_info.n_mrds_items = select_info.n_mrds_items + 1;
		select_info.n_user_items = select_info.n_user_items + 1;
						/* fill in select info item data */
		select_info.mrds_item.arg_ptr (select_info.n_mrds_items) = assn_ptr;
		select_info.mrds_item.bit_len (select_info.n_mrds_items) =
		     rslt_info.attr.attr_length (attr_ind);
		select_info.mrds_item.desc (select_info.n_mrds_items) =
		     rslt_info.attr.descriptor (attr_ind);
		select_info.mrds_item.assn_type (select_info.n_mrds_items) = assn_type;
		select_info.mrds_item.assn_len (select_info.n_mrds_items) = assn_len;
		select_info.user_item.name (select_info.n_user_items) =
		     before (rslt_info.attr.attr_name (attr_ind), " ");

		select_info.user_item.item_type (select_info.n_user_items) = MRDS;
		select_info.user_item.item_ptr (select_info.n_user_items) =
		     addr (select_info.mrds_item (select_info.n_mrds_items));
	     end;					/* if first block */

     end add_sel_item;

     end linus_lila_select;
