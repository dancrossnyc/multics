/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1990   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        *********************************************************** */


linus_table:
   proc;

/*
     This module retrieves the data from the database and loads
     it into the "table" for processing by the display request.
     The module also keeps information about the current table
     in the table_info structure.
 
     Known Bugs:
 
     Other Problems:
 
     History:

     Written - March 1983 - Dave Schimke


   83-08-30  Bert Moberg:  Added call to linus_translate_query$auto if no current
   select expression is available

   83-09-09  Al Dupuis: Added translate_query entrypoint. Took the call to
   linus_translate_query$auto from the info entrypoint and added it to the
   new entrypoint.

   83-09-19 Al Dupuis: Added get_row entrypoint. This is a simple entrypoint
   for requests like write, who need to just have one row retrieved and then
   dispose of it when they call back for another row.

   83-09-27 Al Dupuis: Added info_for_store entrypoint. This entrypoint
   allocates and fills in the table_info structure for the table named
   by the caller.

   83-09-27 Al Dupuis: Added store_row entrypoint. This entrypoint
   stores a single row into the table named by the caller.

   84-08-07 John Hergert: Fixed bug in load_table_info that was causing
   the value table_info.columns.column_length to be loaded with
   seemingly random values when evaluating mrds items.
*/

/****^  HISTORY COMMENTS:
  1) change(88-05-09,Dupuis), approve(88-07-13,MCR7905), audit(88-07-14,Blair),
     install(88-07-26,MR12.2-1068):
     Added an extra check to the code that determined if column names should be
     qualified. It was forgetting to check for the case when there were
     different row designators used on one table.
  2) change(90-04-30,Leskiw), approve(90-10-05,MCR8202),
     audit(90-10-11,Bubric), install(90-10-14,MR12.4-1039):
     Changed calls to assign_round_ from assign_ so that data is rounded.
                                                   END HISTORY COMMENTS */


%page;
/* format: style3,ind3 */
/* parameters */
      dcl     caller_area_ptr_parm   ptr parm;
      dcl	    code_parm	       fixed bin (35) parm;	/* These parameters are      */
      dcl	    keep_from_row_parm     fixed bin (35) parm;	/* described at each         */
      dcl	    lcb_ptr_parm	       ptr parm;		/* entry where they are used */
      dcl	    permanent_table_parm
			       bit (1) aligned parm;
      dcl	    row_count_specified_parm
			       fixed bin (35) parm;
      dcl	    row_count_actual_parm
			       fixed bin (35) parm;
      dcl     row_value_ptr_parm     ptr unaligned parm;
      dcl	    sort_info_ptr_parm     ptr parm;
      dcl	    table_info_ptr_parm    ptr parm;
      dcl     table_name_parm	       char (30) parm;
      dcl	    temp_directory_parm    char (168) var parm;

%skip(3);
      lcb_ptr = lcb_ptr_parm;
      call ssu_$abort_line (lcb.subsystem_control_info_ptr, 0,
         "This is not a valid entrypoint.");
%page;

async_retrieval:
   entry (lcb_ptr_parm,				/* input: linus control block */
      code_parm);					/* output: status code */


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/*								        */
/* This entry point is called by the linus requests that do			        */
/* retrievals from the database: linus_assign_values.pl1,			        */
/* linus_create_list.pl1, linus_eval_set_func.pl1, linus_modify.pl1,		        */
/* linus_print.pl1, linus_report.pl1, and linus_write.pl1.			        */
/* The entry point sets the retrieval indentifier so incremental		        */
/* retrievals can determine that their "-another" selection is		        */
/* no longer valid.							        */
/*								        */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

      code_parm = 0;
      lcb_ptr = lcb_ptr_parm;

      if lcb.table_control_info_ptr = null () then
	 return;

      call initialize;

      if table_ip = null () then
	 return;

      table_info.retrieval_identifier, table_control_info.retrieval_id =
         table_control_info.retrieval_id + 1;

      return;					/* end async_retrieval */

%page;
db_on:
   entry;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/*								        */
/* This entrypoint turns on a switch which causes the value of		        */
/* the current selection expression to be displayed at the terminal.	                  */
/*								        */
/*    Usage:							        */
/*    linus_table$db_on						        */
/*								        */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


      debug_switch = "1"b;
      return;

%page;
db_off:
   entry;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/*								        */
/* This entrypoint turns off the switch which causes the value of		        */
/* the current selection expression to be displayed at the terminal.		        */
/*								        */
/*    Usage:							        */
/*    linus_table$db_off						        */
/*								        */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


      debug_switch = "0"b;
      return;

%page;
delete_table:
   entry (lcb_ptr_parm,				/* input: linus control block */
      code_parm);					/* output: status code */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/*								        */
/* This entry point deletes the current table. It is called from		        */
/* linus_display to conserve space when the table is known to be		        */
/* invalid and we will need to rebuild it.				        */
/*								        */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


      lcb_ptr = lcb_ptr_parm;
      code_parm = 0;

      call initialize;
      call cleanup_table;

      code_parm = icode;
      return;					/* end linus_table_$delete_table */

%page;
get_row: entry (

	lcb_ptr_parm,	/* input: ptr to linus control block */
	row_value_ptr_parm, /* output: packed ptr to the row */
	code_parm		/* output: success or failure */
	    );

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* This entry point gets a single row from the data base and loads it into the table.	*/
	/* The parm row_value_ptr_parm describes where the row has been placed, and can be used	*/
	/* with the row_value character string to do substr's to access the individual columns.	*/
	/* The table_info, table_control_info, and row_ptrs variables below are set to 1 so that	*/
	/* the newly retrieved row is always placed in the second slot in the table.		*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

         
	lcb_ptr = lcb_ptr_parm;
	row_value_ptr_parm = null;
	code_parm = 0;
%skip(1);
	call initialize;
	if select_info.set_fn
	then do;
	     code_parm = mrds_error_$tuple_not_found;
	     return;
	end;
	call prepare_to_load_rows;
	call retrieve_another;
	if icode ^= 0
	then do;
	     code_parm = icode;
	     return;
	end;
	table_control_info.current_seg_row_count = 1;
	table_info.row_count = 1;
	call load_one_row;
	row_value_ptr_parm = row_value_p;
	row_ptrs.number_of_ptrs_this_seg = 1;
%skip(1);
	return;
%page;
info:
   entry (lcb_ptr_parm,				/* input: pointer to linus control_block */
      table_info_ptr_parm,				/* output: pointer to the table_info structure */
      code_parm);					/* output: status code */


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/*								        */
/* This entrypoint is called by the linus_options subroutine to		        */
/* return information on the current state of the display table.		        */
/*								        */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


      table_info_ptr_parm = null ();
      code_parm, icode = 0;
      lcb_ptr = lcb_ptr_parm;

      call initialize;

      if lcb.si_ptr = null then
	 icode = linus_error_$no_lila_expr_processed;
      else
         do;
	  si_ptr = lcb.si_ptr;
	  call load_table_info;
	  table_info_ptr_parm = table_control_info.table_info_ptr;
         end;

      code_parm = icode;
      return;					/* end linus_table$info */
%page;
info_for_store: entry (

	lcb_ptr_parm,	  /* input: ptr to linus control block */
	table_name_parm,	  /* input: name of relation */
          caller_area_ptr_parm, /* input: ptr to caller specified area */
	table_info_ptr_parm,  /* output: points to table_info structure */
	code_parm		  /* output: success or failure */
		 );
%skip(1);

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* This entrypoint is called to provide a table_info structure for a named table. The	*/
	/* structure store_args is also allocated and filled in for future calls to dsl_$store.	*/
	/* The caller is responsible for freeing both of these structures when finished with	*/
	/* them.									*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
%skip(1);
	lcb_ptr = lcb_ptr_parm;
	work_area_p = caller_area_ptr_parm;
%skip(1);
	call load_table_info_for_store (table_name_parm, table_info_ptr_parm, code_parm);
%skip(1);
	return;
%page;
new_table:
   entry (lcb_ptr_parm,				/* input: pointer to linus control block */
      temp_directory_parm,				/* input: workspace for the table */
      permanent_table_parm,				/* input: "1"b = permanent */
      code_parm /* output: status code */);

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/*								        */
/* This entrypoint is called by the display request to initialize		        */
/* the display table. It takes care of:                                                 */
/*     1) initializing the table info                                                   */
/*     2) creating the table     				                  */
/*     3) retrieving the first row from the database			        */
/*     4) loading the first row into the table				        */
/*								        */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

      lcb_ptr = lcb_ptr_parm;
      code_parm, icode = 0;

      call initialize;

      table_control_info.temp_directory = temp_directory_parm;
      table_control_info.flags.permanent = permanent_table_parm;

      if lcb.si_ptr = null then call linus_translate_query$auto (sci_ptr, lcb_ptr); /* try translating it */
      if lcb.si_ptr = null then
         do;
	  icode = linus_error_$no_lila_expr_processed;
	  goto NEW_TABLE_EXIT;
         end;

      si_ptr = lcb.si_ptr;				/* select_info */
      sci_ptr = lcb.subsystem_control_info_ptr;		/* ssu_ */

      if ^select_info.se_flags.val_ret then
         do;
	  icode = linus_error_$ret_not_valid;
	  goto NEW_TABLE_EXIT;
         end;

      if table_control_info.msf_seg_count ^= 0 then do;
	  call cleanup_table;
	  if icode ^= 0 then
	       goto NEW_TABLE_EXIT;
	  call initialize;
         end;

      call load_table_info;
      if icode ^= 0 then
	 goto NEW_TABLE_EXIT;

      table_control_info.incremental_retrieval_arg_ptr = null ();
      table_info.row_count = 0;
      table_control_info.flags.sorted = "0"b;

      if select_info.prior_sf_ptr ^= null then
	 call linus_eval_set_func (lcb_ptr, select_info.prior_sf_ptr, icode);
						/* evaluate prior set functions */
      if icode ^= 0 & icode ^= mrds_error_$tuple_not_found then
         do;
	  icode = icode;
	  goto NEW_TABLE_EXIT;
         end;

      if select_info.set_fn				/* set function to be applied */ then
	 call linus_eval_set_func (lcb_ptr, select_info.user_item.item_ptr (1),
	    icode);
      else call retrieve_new;				/* or retrieve */

      if icode = 0 then
         do;
	  call create_table;

	  allocate char_output_string in (work_area) set (char_string_ptr);
	  table_control_info.char_output_string_ptr = char_string_ptr;
	  call prepare_to_load_rows;
	  call load_one_row;
         end;

NEW_TABLE_EXIT:
      code_parm = icode;
      return;					/* end linus_table$new_table */

%page;
load_rows:
   entry (lcb_ptr_parm,				/* input: pointer to linus control_block */
      row_count_specified_parm,			/* input: number of rows to load into the display table. */
      row_count_actual_parm,				/* output: actual number of rows loaded into the display table. */
      keep_from_row_parm,				/* input: (disposable table) discard only rows prior to this row number */
      code_parm);					/* output: status code */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/*								        */
/* This entrypoint loads N rows into the display table making N		        */
/* retrieves from the database. It is called by the linus_display		        */
/* subroutine.							        */
/*								        */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


      lcb_ptr = lcb_ptr_parm;
      code_parm, icode, row_count_actual_parm = 0;
      row_count_specified = row_count_specified_parm;
      keep_from_row = keep_from_row_parm;

      call initialize;

      if select_info.set_fn then
         do;					/* can only apply set function once */
	  icode = mrds_error_$tuple_not_found;
	  goto LOAD_ROWS_EXIT;
         end;

      call prepare_to_load_rows;

      do row_index = 1 to row_count_specified while (icode = 0);
         call retrieve_another;
         if icode = 0 then
	  do;
	     call load_one_row;
	     row_count_actual_parm = row_count_actual_parm + 1;
	  end;
      end;

LOAD_ROWS_EXIT:
      code_parm = icode;
      return;					/* end linus_table$load_rows */

%page;
load_table:
   entry (lcb_ptr_parm,				/* input: pointer to linus control_block */
      code_parm);					/* output: status code */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/*								        */
/* This entrypoint loads rows into the display table until no more		        */
/* rows are available from the database. It is called by the linus_display	        */
/* subroutine.							        */
/*								        */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


      lcb_ptr = lcb_ptr_parm;
      code_parm, icode = 0;

      call initialize;

      if select_info.set_fn then
	 goto LOAD_TABLE_EXIT;			/* can only apply set function once */

      call prepare_to_load_rows;

      do while (icode = 0);
         call retrieve_another;
         if icode = 0 then
	    call load_one_row;
      end;

LOAD_TABLE_EXIT:
      if icode ^= mrds_error_$tuple_not_found then
	 code_parm = icode;
      return;					/* end linus_table$load_table */

%page;
sort:
   entry (lcb_ptr_parm,				/* input: pointer to linus control_block */
      sort_info_ptr_parm,				/* input: how to sort the table */
      code_parm);					/* output: status code */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/*								        */
/* This entrypoint is called by the display request to sort the current                 */
/* table. It sorts the table by:                                                        */
/* 1) loading the ss_info structure to describe the sort.                               */
/* 2) allocating and loading the sort_input structure to describe the current table.    */
/* 3) allocating the sort output structure for sort_seg_$linus_table.                   */
/* 4) calling sort_seg_$linus_table.                                                    */
/* 5) transforming the sort_output into the row_segs_info structure.                    */
/* 6) freeing the sort_input and sort_output structures.                                */
/*								        */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

      lcb_ptr = lcb_ptr_parm;
      sort_info_ptr = sort_info_ptr_parm;
      ss_info_ptr, sort_desc_array_ptr, sort_input_ptr, sort_output_ptr = null;
      code_parm = 0;

      call initialize;

      if table_control_info.component_ptrs_ptr = null () then
         do;
	  icode = error_table_$no_table;
	  goto SORT_EXIT;
         end;

      ss_field_count = sort_info.number_of_columns_to_sort;
      allocate ss_info in (info_area) set (ss_info_ptr);
      allocate sort_desc_array in (info_area);

      ss_info.header.version = SS_info_version_1;
      ss_info.header.block_size = 1;
      ss_info.header.duplicate_mode = SS_duplicates;
      ss_info.header.mbz1 = 0;
      ss_info.header.delim.type = SS_length;
      ss_info.header.delim.number = table_info.row_value_length;

      do item_index = 1 to ss_field_count;
         ss_info.field.from.type (item_index) = SS_index;
         ss_info.field.from.number (item_index) =
	  table_info.columns
	  .column_index (sort_info.columns.number (item_index));
         ss_info.field.to.type (item_index) = SS_length;
         ss_info.field.to.number (item_index) =
	  table_info.columns
	  .column_length (sort_info.columns.number (item_index));

         ss_info.field.modes.descending (item_index) =
	  sort_info.columns.modes.descending (item_index);
         ss_info.field.modes.non_case_sensitive (item_index) =
	  sort_info.columns.modes.non_case_sensitive (item_index);
         desc_ptr = addr (table_info.columns.column_data_type (sort_info.columns.number (item_index)));
         sort_desc_array (item_index) = desc_ptr;
         ss_info.field.modes.numeric (item_index)
	  = mdbm_util_$number_data_class (desc_ptr);
      end;

      allocate sort_input in (info_area) set (sort_input_ptr);
      sort_input.sorted = table_control_info.flags.sorted;
      do item_index = 1 to row_segs_info.number_of_seg_ptrs;
         sort_input.segment_ptr (item_index) =
	  row_segs_info.seg_ptr (item_index);
      end;
      do item_index = 1 to table_control_info.msf_seg_count;
         sort_input.component_ptr (item_index) =
	  component_ptr (item_index);
      end;
      allocate sort_output in (info_area) set (sort_output_ptr);
      do item_index = 1 to sort_output.number_of_segs;
         call linus_temp_seg_mgr$get_segment (lcb_ptr, my_name,
	  table_control_info.temp_directory, temp_ptr, icode);
         if icode ^= 0 then
	  call ssu_$abort_line (icode, "While getting a new row_ptr_seg.");
         sort_output.seg_ptr (item_index) = temp_ptr;
      end;
      call sort_seg_$linus_table (lcb_ptr, my_name, ss_info_ptr,
         linus_temp_seg_mgr$get_segment, linus_temp_seg_mgr$release_segment,
         table_control_info.temp_directory, sort_input_ptr,
         sort_desc_array, sort_output_ptr, icode);
      if icode = 0 then
         do;
	  table_control_info.flags.sorted = "1"b;	/* mark this table sorted */

	  do item_index = 1 to row_segs_info.number_of_seg_ptrs;
	     call linus_temp_seg_mgr$release_segment (lcb_ptr, my_name,
	        (row_segs_info.seg_ptr (item_index)), icode);
	  end;
	  row_segs_info.number_of_seg_ptrs = sort_output.number_of_segs; /* transform output into row_segs_info */
	  do item_index = 1 to sort_output.number_of_segs;
	     row_segs_info.seg_ptr (item_index) =
	        sort_output.seg_ptr (item_index);
	  end;
         end;
      else do item_index = 1 to sort_output.number_of_segs; /* must clean up */
	  call linus_temp_seg_mgr$release_segment (lcb_ptr, my_name,
	     (sort_output.seg_ptr (item_index)), icode);
         end;

SORT_EXIT:
      if ss_info_ptr ^= null then free ss_info;
      if sort_desc_array_ptr ^= null then free sort_desc_array;
      if sort_input_ptr ^= null then free sort_input;
      if sort_output_ptr ^= null then free sort_output;

      code_parm = icode;
      return;					/* end linus_table$sort */

%page;
store_row: entry (

	lcb_ptr_parm,	 /* input: ptr to the linus control block */
	table_info_ptr_parm, /* input: ptr to the table_info structure */
	row_value_ptr_parm,  /* input: ptr to the row value */
	code_parm		 /* output: success or failure */
	      );
%skip(1);
	lcb_ptr = lcb_ptr_parm;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* This entrypoint is called to store a row. The table_info structure used by this	*/
	/* entrypoint should have been generated earlier by the info_for_store entrypoint.	*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	
	call store_the_row (table_info_ptr_parm, row_value_ptr_parm, code_parm);
%skip(1);
	return;
%page;
terminate:
   entry (lcb_ptr_parm,				/* input: pointer to linus control_block */
      code_parm);					/* output: status code */


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/*								        */
/* This entry is called by the linus terminate procedure			        */
/* when a "quit" request or the linus cleanup handler			        */
/* is executed. It cleans up all table work areas.            		        */
/*								        */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


      lcb_ptr = lcb_ptr_parm;
      code_parm = 0;

      if lcb.table_control_info_ptr = null then return;

      table_control_ip = lcb.table_control_info_ptr;
      table_ip = table_control_info.table_info_ptr;
      component_ptrs_p = table_control_info.component_ptrs_ptr;

      if table_ip ^= null then
	 row_segs_ip = table_info.row_segs_info_ptr;
      else row_segs_ip = null;


      call cleanup_table;

      if table_control_info.info_area_ptr ^= null () then
         do;
	  info_area_p = table_control_info.info_area_ptr;
	  call release_area_ (info_area_p);
	  call linus_temp_seg_mgr$release_segment (lcb_ptr, "linus_table$info",
	     table_control_info.info_area_ptr, icode);
         end;

      lcb.table_control_info_ptr = null ();
      code_parm = icode;
      return;					/* end linus_table$terminate */

%page;
translate_query:
   entry (lcb_ptr_parm,				/* input: pointer to linus control_block */
      table_info_ptr_parm,				/* output: pointer to the table_info structure */
      code_parm);					/* output: status code */


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/*								        */
/* This entrypoint is called by the linus display request to		        */
/* return information on the current state of the display   		        */
/* table and to translate the current query.				        */
/*								        */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


      table_info_ptr_parm = null ();
      code_parm, icode = 0;
      lcb_ptr = lcb_ptr_parm;

      call initialize;

      if lcb.si_ptr = null then call linus_translate_query$auto (sci_ptr, lcb_ptr); /* try translating it */
      if lcb.si_ptr = null then
	 icode = linus_error_$no_lila_expr_processed;
      else
         do;
	  si_ptr = lcb.si_ptr;
	  call load_table_info;
	  table_info_ptr_parm = table_control_info.table_info_ptr;
         end;

      code_parm = icode;
      return;					/* end linus_table$translate_query */

%page;
/* internal procedures */

append_row:
   proc;

/* Do we need another msf component for another row of data? */
/* If this component is full or this is the first call...    */
      if (table_control_info.current_seg_row_count >=
         table_control_info.max_number_of_rows_per_seg) |
         (table_control_info.msf_seg_count = 0)
      then call get_next_component;

/* Now do we have room for another pointer in the current ptr seg? */

      if table_info.row_segs_info_ptr = null then
	 call load_row_info;			/* create row info */
      else row_segs_ip = table_info.row_segs_info_ptr;

      if row_segs_info.number_of_seg_ptrs = 0 then
	 call get_ptr_seg (row_ptrs_p);
      else row_ptrs_p =
	    row_segs_info.seg_ptr (row_segs_info.number_of_seg_ptrs);

      if row_ptrs.number_of_ptrs_this_seg
         = row_segs_info.max_number_of_ptrs_per_seg then
	 call get_ptr_seg (row_ptrs_p);		/* need another seg for ptrs!! */

      row_value_p =
         addr (component_value (table_control_info.current_seg_row_count + 1));
      row_ptrs.number_of_ptrs_this_seg = row_ptrs.number_of_ptrs_this_seg + 1;
      row_ptrs.row_value_ptr (row_ptrs.number_of_ptrs_this_seg) = row_value_p;

   end append_row;

%page;
calc_len:
   proc (descriptor_parm, length_parm);

/* Calculate the length of a print field given a descriptor */

      dcl	    descriptor_parm	       bit (36) parm;
      dcl	    fixed_bin_11_ovrly     fixed bin (11) unal based;
      dcl	    length_parm	       fixed bin (21) parm;

      desc_ptr = addr (descriptor_parm);		/* Point to descriptor */
      prec_len = fixed (descriptor.size.precision);
      if mdbm_util_$binary_data_class (desc_ptr) then
	 length_parm = divide(prec_len, 3, 21) + 5;		/* binary */
      else if mdbm_util_$number_data_class (desc_ptr) then
	 length_parm = prec_len + 3;			/* decimal */
      else if mdbm_util_$string_data_class (desc_ptr) then
	 length_parm =
	    fixed (descriptor.size.scale || descriptor.size.precision);
      else length_parm = 20;
      if mdbm_util_$number_data_class (desc_ptr) then
         do;
	  if mdbm_util_$fixed_data_class (desc_ptr) then
	     do;					/* fixed */
	        scale_len =
		 addr (descriptor.size.scale) -> fixed_bin_11_ovrly;
						/* get signed scale */
	        if (scale_len < 0) | (scale_len > 0 & prec_len < scale_len)
	        then length_parm =
		      length_parm + ceil (log10 (abs (scale_len)));
						/* largest scale will be f-128 to f+127 */
	     end;
	  else length_parm = length_parm + 5;		/* float */
         end;
      if mdbm_util_$complex_data_class (desc_ptr) then
	 length_parm = length_parm * 2;
   end calc_len;

%page;
create_table:
   proc;

      table_control_info.table_msf = unique_chars_ ("0"b) || ".LINUS.table";

      if table_control_info.temp_directory = "" then
	 table_control_info.temp_directory = get_pdir_ ();

      call msf_manager_$open (table_control_info.temp_directory,
         table_control_info.table_msf, table_control_info.fcb_ptr, icode);

      if icode = error_table_$noentry then
	 icode = 0;
      if icode ^= 0 then
	 call ssu_$abort_line (sci_ptr, icode, "^/While opening ^a>^a",
	    table_control_info.temp_directory, table_control_info.table_msf);

      table_control_info.current_seg_row_count = 0;
      if table_control_info.component_ptrs_ptr = null then
         do;					/* need to create the structure */
	  table_control_info.max_number_of_components = ROW_SEG_INCREASE;
	  allocate component_ptr in (work_area) set (component_ptrs_p);
	  table_control_info.component_ptrs_ptr = component_ptrs_p;
         end;
   end create_table;

%page;
cleanup_table:
   proc;

      icode = 0;
      table_control_info.current_component_ptr = null;
      table_control_info.current_seg_row_count = 0;

      if table_control_info.fcb_ptr ^= null then
         do;
            call msf_manager_$close (table_control_info.fcb_ptr);
	  component_ptr (*) = null;
	  table_control_info.component_ptrs_ptr = null;

	  call delete_$path (table_control_info.temp_directory, table_control_info.table_msf, DELETE_SEG_SW, my_name, icode);
	  if icode ^= 0 then
	       call ssu_$print_message (icode, "While deleting table msf");

	  table_control_info.msf_seg_count = 0;
         end;
      if row_segs_ip ^= null then
         do;					/* clean_up row segs info */
	  if row_segs_info.number_of_seg_ptrs ^= 0 then
	     do item_index = 1 to row_segs_info.number_of_seg_ptrs;
	        if row_segs_info.seg_ptr (item_index) ^= null then
		   call linus_temp_seg_mgr$release_segment (lcb_ptr, my_name,
		      (row_segs_info.seg_ptr (item_index)), icode);
	        if icode ^= 0 then
		   call ssu_$print_message (icode, "While deleting table row seg ptr ^d.", item_index);
	     end;
	  table_control_info.row_info_ptr, table_info.row_segs_info_ptr,
	     row_segs_ip = null;
         end;

      if table_control_info.work_area_ptr ^= null () then
         do;
	  work_area_p = table_control_info.work_area_ptr;
	  call release_area_ (work_area_p);
	  call linus_temp_seg_mgr$release_segment (lcb_ptr, my_name,
	     table_control_info.work_area_ptr, icode);
	  if icode ^= 0 then
	       call ssu_$print_message (icode, "While releasing table work area.");
         end;

   end cleanup_table;

%page;
get_next_component:
   proc;
      if table_control_info.msf_seg_count + 1 >
         table_control_info.max_number_of_components then do; /* need to expand the structure */
	  table_control_info.max_number_of_components =
	     ROW_SEG_INCREASE + table_control_info.msf_seg_count;
	  allocate new_component_ptr in (work_area) set (new_component_ptrs_p);
	  new_component_ptrs_p -> component_ptr = component_ptr;
	  table_control_info.component_ptrs_ptr,
	     component_ptrs_p = new_component_ptrs_p;
         end;

      call msf_manager_$get_ptr (table_control_info.fcb_ptr,
         table_control_info.msf_seg_count, CREATE,
         table_control_info.current_component_ptr, bit_count, icode);
						/* actually getting the (seg_count - 1)th component (1st seg is 0) */

      if icode ^= 0 then
	 call ssu_$abort_line (sci_ptr, icode,
	    "^/While creating ^[a component of ^]^a>^a", (table_control_info.msf_seg_count > 0),
	    table_control_info.temp_directory, table_control_info.table_msf);

      table_control_info.msf_seg_count =
         table_control_info.msf_seg_count + 1;
      component_ptr (table_control_info.msf_seg_count) =
         table_control_info.current_component_ptr;
      table_control_info.current_seg_row_count = 0;

   end get_next_component;

%page;
get_ptr_seg:
   proc (seg_ptr_parm);
      dcl	    seg_ptr_parm	       ptr parm;

      call linus_temp_seg_mgr$get_segment (lcb_ptr, my_name,
         table_control_info.temp_directory, seg_ptr_parm, icode);
      if icode ^= 0 then
	 call ssu_$abort_line (icode, "While getting a new row_ptr_seg.");

      if row_segs_info.number_of_seg_ptrs = row_segs_info.max_number_of_seg_ptrs
      then call load_row_info;			/* need to grow structure */

      row_segs_info.number_of_seg_ptrs = row_segs_info.number_of_seg_ptrs + 1;
      row_segs_info.seg_ptr (row_segs_info.number_of_seg_ptrs) = seg_ptr_parm;
      seg_ptr_parm -> row_ptrs.number_of_ptrs_this_seg = 0;
   end get_ptr_seg;

%page;
initialize:
   proc;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/*								        */
/* Make sure everything is ready. Set automatic pointers and		        */
/* initialize common structures.					        */
/*								        */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


      sci_ptr = lcb.subsystem_control_info_ptr;
      if lcb.table_control_info_ptr = null () then
         do;					/* init control structure */
	  allocate table_control_info in (lcb.static_area)
	     set (table_control_ip);

	  lcb.table_control_info_ptr = table_control_ip;
         end;
      else table_control_ip = lcb.table_control_info_ptr;

      work_area_p = table_control_info.work_area_ptr;
      if work_area_p = null () then
         do;
	  call linus_temp_seg_mgr$get_segment (lcb_ptr, my_name,
	     table_control_info.temp_directory, work_area_p, icode);
	  if icode ^= 0 then
	       call ssu_$abort_line (sci_ptr, icode,
		"While getting table work area temp seg.");
	  call mdbm_util_$mu_define_area (work_area_p, (sys_info$max_seg_size),
	     "work_area", EXTENSIBLE, NO_FREEING, NO_ZERO_ON_ALLOC,
	     NO_ZERO_ON_FREE, icode);
	  if icode ^= 0 then
	       call ssu_$abort_line (sci_ptr, icode,
		"While getting table work area.");
	  table_control_info.work_area_ptr = work_area_p;
         end;

      info_area_p = table_control_info.info_area_ptr;
      if info_area_p = null () then
         do;
	  call linus_temp_seg_mgr$get_segment (lcb_ptr, "linus_table$info",
	     table_control_info.temp_directory, info_area_p, icode);
	  if icode ^= 0 then
	       call ssu_$abort_line (sci_ptr, icode,
		"While getting table info area temp seg.");
	  call mdbm_util_$mu_define_area (info_area_p, (sys_info$max_seg_size),
	     "table.info", EXTENSIBLE, FREEING, NO_ZERO_ON_ALLOC,
	     NO_ZERO_ON_FREE, icode);
	  if icode ^= 0 then
	       call ssu_$abort_line (sci_ptr, icode,
		"While getting table info area.");
	  table_control_info.info_area_ptr = info_area_p;
         end;

      table_ip = table_control_info.table_info_ptr;
      if table_ip ^= null then
	 row_segs_ip = table_info.row_segs_info_ptr;
      else row_segs_ip = null;
      component_ptrs_p = table_control_info.component_ptrs_ptr;

      si_ptr = lcb.si_ptr;				/* select_info ptr */
   end initialize;

%page;
load_one_row:
   proc;

      call append_row;				/* adjust row_ptr */

      do item_index = 1 to table_info.column_count;
         char_output_string = "";
         if ^select_info.set_fn & select_info.user_item.item_type (item_index) = MRDS then
	  do;
	     user_item_ptr = select_info.user_item.item_ptr (item_index);
						/* init user item structure */

	     call assign_round_ (char_string_ptr, target_type,
	        (table_info.columns.column_length (item_index)),
	        user_item.arg_ptr, user_item.assn_type, user_item.assn_len);
	  end;

         else
	  do;					/* Evaluate expression */
	     if select_info.user_item.item_type (item_index) = EXPR then
	        do;
		 call linus_eval_expr (lcb_ptr,
		    select_info.user_item.item_ptr (item_index), si_ptr,
		    caller, item_index, icode);
		 if icode ^= 0 then
		      return;
	        end;

	     if mdbm_util_$number_data_class (
	        addr (select_info.user_item.rslt_desc (item_index))) then
	        do;				/* this is really an expr
						   -- not char or string scalar function */
		 if mdbm_util_$complex_data_class (
		    addr (select_info.user_item.rslt_desc (item_index)))
		 then call assign_round_ (expr_results_ptr, cmpx_float_dec_type,
		         float_dec_len,
		         select_info.user_item.rslt_assn_ptr (item_index),
		         select_info.user_item.rslt_assn_type (item_index),
		         select_info.user_item.rslt_assn_len (item_index));

		 else call assign_round_ (expr_results_ptr, float_dec_type,
		         float_dec_len,
		         select_info.user_item.rslt_assn_ptr (item_index),
		         select_info.user_item.rslt_assn_type (item_index),
		         select_info.user_item.rslt_assn_len (item_index));

		 call ioa_$rsnnl (IOARS_STRING, char_output_string, (0),
		    expr_results);			/* convert to a character string */
	        end;
	     else /* output result of non-arithmetic scalar function */
		call assign_round_ (char_string_ptr, target_type,
		   (table_info.columns.column_length (item_index)),
		   select_info.user_item.rslt_assn_ptr (item_index),
		   select_info.user_item.rslt_assn_type (item_index),
		   select_info.user_item.rslt_assn_len (item_index));

	  end;
         substr (row_value, table_info.columns (item_index).column_index,
	  table_info.columns (item_index).column_length) = char_output_string;
      end;
      table_info.row_count = table_info.row_count + 1;
      table_control_info.current_seg_row_count =
         table_control_info.current_seg_row_count + 1;

   end load_one_row;

%page;
load_row_info:
   proc;
      if table_info.row_segs_info_ptr = null then
         do;					/* need to create the row info structure */
	  rsi_init_max_number_of_seg_ptrs = ROW_SEG_INCREASE;
	  allocate row_segs_info in (work_area) set (row_segs_ip);
	  table_info.row_segs_info_ptr = row_segs_ip;
	  row_segs_info.max_number_of_ptrs_per_seg =
	     sys_info$max_seg_size - 1;
	  row_segs_info.number_of_seg_ptrs = 0;
         end;

      else
         do;					/* need to expand the row info structure */
	  rsi_init_max_number_of_seg_ptrs,
	     row_segs_info.max_number_of_seg_ptrs =
	     ROW_SEG_INCREASE + row_segs_info.number_of_seg_ptrs;
	  allocate new_row_segs_info in (work_area) set (new_row_segs_ip);
	  new_row_segs_ip -> row_segs_info = row_segs_info;
	  row_segs_ip, table_info.row_segs_info_ptr = new_row_segs_ip;
         end;
      table_control_info.row_info_ptr = row_segs_ip;	/* save for synchronization over table_info reinitialization */
   end load_row_info;

%page;
load_table_info:
   proc;

/* Is the old table information still valid? */

      if table_control_info.table_info_ptr ^= null () then
	 if table_control_info.selection_expression_identifier
	    = lcb.selection_expression_identifier then
	      return;

/* No, we need to calculate and load table_info. */
/* Get a new table_info structure. */

      if table_control_info.table_info_ptr ^= null then
	 free table_info;
      ti_init_column_count = select_info.n_user_items;
      allocate table_info in (info_area) set (table_ip);
      table_control_info.table_info_ptr = table_ip;	/* save the ptr */

/* initialization */

      expression_count = 0;
      linus_rel_array_ptr = lcb.rel_array_ptr;

/* init table_info */

      table_info.retrieval_identifier, table_control_info.retrieval_id =
         table_control_info.retrieval_id + 1;
      table_info.row_segs_info_ptr = table_control_info.row_info_ptr;

      table_info.maximum_column_value_length = 1;
      table_info.maximum_column_name_length = 0;
      table_info.columns.column_name = "";
      table_info.store_args_ptr = null;

/* Try to set unique names for each MRDS item */
/* If more than 1 table (relation) is selected, include the table name. */

      if linus_rel_array.num_of_rels > 1 | select_uses_different_row_designators () then
         do row_index = 1 to table_info.column_count;
	  if (select_info.user_item.item_type (row_index) = MRDS) then
	       table_info.columns.column_name (row_index) =
		rtrim (select_info.user_item.table_name (row_index))
		|| "." || select_info.user_item.name (row_index);
         end;

/* Fill in the rest of the column specific data. */

      do item_index = 1 to table_info.column_count;	/* column data */
         if ^select_info.set_fn & select_info.user_item.item_type (item_index) = MRDS then
	  do;					/* MRDS item */

	     if (table_info.columns.column_name (item_index) = "") then
		table_info.columns.column_name (item_index) =
		   select_info.user_item.name (item_index);

	     user_item_ptr = select_info.user_item.item_ptr (item_index);
	     call calc_len ((user_item.desc),
	        table_info.columns.column_length (item_index));

	     table_info.columns.column_data_type (item_index) =
	        user_item.desc;
	  end;

         else
	  do;					/* Expression or Function */
	     expression_count = expression_count + 1;
	     table_info.columns.column_name (item_index) =
	        "e" || ltrim (char (expression_count));

	     if mdbm_util_$number_data_class (
	     addr (select_info.user_item.rslt_desc (item_index)))
	     then do;
		table_info.columns.column_length (item_index) =
		     DEFAULT_EXPR_SIZE;
		table_info.columns.column_data_type (item_index) =
		     FIXED_DEC_14_3_DESC;
	     end;
	     else do;
		table_info.columns.column_length (item_index) =
		     select_info.user_item.rslt_assn_len (item_index);
		table_info.columns.column_data_type (item_index) =
		     select_info.user_item.rslt_desc (item_index);
	     end;
	  end;

         table_info.maximum_column_value_length =
	  max (table_info.maximum_column_value_length,
	  table_info.columns.column_length (item_index));
         table_info.maximum_column_name_length =
	  max (table_info.maximum_column_name_length,
	  length (table_info.columns.column_name (item_index)));
         if item_index ^= 1 then
	    table_info.columns (item_index).column_index =
	       table_info.columns (item_index - 1).column_length
	       + table_info.columns (item_index - 1).column_index;
         else table_info.columns (1).column_index = 1;

      end;					/* column data */

/* If duplicates from the same table exist, add numeric suffixes. */

      do row_index = 1 to table_info.column_count;
         do item_index = row_index + 1 to table_info.column_count;
	  duplicate_count = 1;
	  if (table_info.columns.column_name (row_index)
	     = table_info.columns.column_name (item_index)) then
	     do loop_index = 1 to table_info.column_count;
	        if (select_info.user_item.name (row_index)
		 = select_info.user_item.name (loop_index))
		 & (select_info.user_item.table_name (row_index)
		 = select_info.user_item.table_name (loop_index)) then
		 do;
		    table_info.columns.column_name (loop_index) =
		       rtrim (table_info.columns.column_name (loop_index))
		       || "." || ltrim (char (duplicate_count));
		    duplicate_count = duplicate_count + 1;
		 end;
	     end;
         end;
      end;
      table_info.row_value_length = sum (table_info.columns.column_length (*));
      table_control_info.max_number_of_rows_per_seg =
         divide ((sys_info$max_seg_size * 4), table_info.row_value_length, 10);
      table_control_info.selection_expression_identifier =
         lcb.selection_expression_identifier;
   end load_table_info;
%page;
load_table_info_for_store: proc (

	ltifs_table_name_parm,     /* input: name of table for info */
	ltifs_table_info_ptr_parm, /* output: points to table_info structure */
	ltifs_code_parm	       /* output: success or failure */
			  );
%skip(1);
dcl ltifs_code_parm fixed bin (35) parm;
dcl ltifs_current_index fixed bin (21);
dcl ltifs_found_the_relation bit (1) aligned;
dcl ltifs_loop fixed bin;
dcl ltifs_relation_index fixed bin (35);
dcl ltifs_table_name char (30);
dcl ltifs_table_name_parm char (30) parm;
dcl ltifs_table_info_ptr_parm ptr parm;
%skip(1);
	ltifs_table_name = ltifs_table_name_parm;
	ltifs_table_info_ptr_parm = null;
	ltifs_code_parm = 0;
%skip(1);
	if lcb.db_index = 0
	then do;
	     ltifs_code_parm = linus_error_$no_db;
	     return;
	end;
%skip(1);
	if lcb.timing_mode
	then initial_vclock = vclock;
%skip(1);
	call dsl_$get_rslt_info (lcb.db_index, ltifs_table_name,
	     work_area_p, rslt_ptr, ltifs_code_parm);
	if ltifs_code_parm ^= 0
	then do;
	     ltifs_found_the_relation = "0"b;
	     if lcb.ttn_ptr ^= null
	     then do;
		ttn_ptr = lcb.ttn_ptr;
		do ltifs_loop = 1 to mrds_data_$max_temp_rels
		     while (^ltifs_found_the_relation);
		     if ltifs_table_name = temp_tab_names (ltifs_loop)
		     then do;
			ltifs_found_the_relation = "1"b;
			ltifs_relation_index = ltifs_loop;
		     end;
		end;
	     end;
	     if ltifs_found_the_relation
	     then call dsl_$get_temp_info (lcb.db_index, ltifs_relation_index,
		work_area_p, rslt_ptr, ltifs_code_parm);
	     else;
	end;
%skip(1);
	if lcb.timing_mode
	then lcb.mrds_time = lcb.mrds_time + vclock - initial_vclock;
	if ltifs_code_parm ^= 0
	then return;
%skip(1);
	ti_init_column_count = rslt_info.num_attr;
	allocate table_info in (work_area) set (table_ip);
	table_info.retrieval_identifier = 0;
	table_info.row_count = 0;
	table_info.row_segs_info_ptr = null;
	table_info.store_args_ptr = null;
%skip(1);
	table_info.maximum_column_name_length = 0;
	table_info.maximum_column_value_length = 0;
	table_info.row_value_length = 0;
	ltifs_current_index = 1;
%skip(1);
	do ltifs_loop = 1 to ti_init_column_count;
	     table_info.columns.column_name (ltifs_loop)
		= rtrim (rslt_info.attr (ltifs_loop).attr_name);
	     table_info.maximum_column_name_length
		= max (length (table_info.columns.column_name (ltifs_loop)),
		table_info.maximum_column_name_length);
	     table_info.columns.column_data_type (ltifs_loop)
		= rslt_info.attr (ltifs_loop).descriptor;
	     call calc_len ((table_info.columns.column_data_type (ltifs_loop)),
		table_info.columns.column_length (ltifs_loop));
	     table_info.maximum_column_value_length
		= max (table_info.columns.column_length (ltifs_loop),
		table_info.maximum_column_value_length);
	     table_info.row_value_length = table_info.row_value_length
		+ table_info.columns.column_length (ltifs_loop);
	     table_info.columns.column_index (ltifs_loop) = ltifs_current_index;
	     ltifs_current_index = ltifs_current_index
		+ table_info.columns.column_length (ltifs_loop);
	end;
	free rslt_info;
%skip(1);
	/* Add extra args and descriptors for db index, relation name, and error code. */
%skip(1);
	arg_list_arg_count = table_info.column_count + 3;
	init_number_of_descriptors = arg_list_arg_count;
%skip(1);
	allocate store_args in (work_area) set (store_ap);
	store_args.table_name = ltifs_table_name;
	store_args.header.pad1 = "0"b;
	store_args.header.call_type = Interseg_call_type;
	store_args.header.desc_count = store_args.header.arg_count;
	store_args.header.pad2 = "0"b;
%skip(1);
	/* Init descriptors and set db index, table name, and code. */
%skip(1);
	unspec (store_args.argument_list_descriptors) = "0"b;
	store_args.argument_list_descriptors (*).flag = "1"b;
	store_args.argument_list_descriptors (1).type = real_fix_bin_1_dtype;
	store_args.argument_list_descriptors (1).size = 35;
	store_args.argument_list_descriptors (2).type = char_dtype;
	store_args.argument_list_descriptors (2).size = length (store_args.table_name);
	store_args.argument_list_descriptors (arg_list_arg_count).type = real_fix_bin_1_dtype;
	store_args.argument_list_descriptors (arg_list_arg_count).size = 35;
%skip(1);
	/* Fill in arg and desc ptrs for db index, table name, and code. */
%skip(1);
	store_args.arg_ptrs (1) = addr (lcb.db_index);
	store_args.desc_ptrs (1) = addr (store_args.argument_list_descriptors (1));
	store_args.arg_ptrs (2) = addr (store_args.table_name);
	store_args.desc_ptrs (2) = addr (store_args.argument_list_descriptors (2));
	store_args.arg_ptrs (arg_list_arg_count) = addr (store_args.error_code);
	store_args.desc_ptrs (arg_list_arg_count) = addr (store_args.argument_list_descriptors (arg_list_arg_count));
%skip(1);
	/* Fill in desc ptrs for column values after setting them.
             arg ptrs are filled in when store takes place. */
%skip(1);
	do ltifs_loop = 3 to table_info.column_count + 2;
	     store_args.arg_ptrs (ltifs_loop) = null;
	     store_args.argument_list_descriptors (ltifs_loop).type = char_dtype;
	     store_args.argument_list_descriptors (ltifs_loop).size
		= table_info.columns.column_length (ltifs_loop - 2);
	     store_args.desc_ptrs (ltifs_loop)
		= addr (store_args.argument_list_descriptors (ltifs_loop));
	end;
%skip(1);
	table_info.store_args_ptr = store_ap;
	ltifs_table_info_ptr_parm = table_ip;
%skip(1);
	return;
%skip(1);
     end load_table_info_for_store;
%page;
prepare_to_load_rows:
   proc;
      caller = 1;					/* for linus_eval_expr */
      cmpx_float_dec_type = 24;
      arg_descriptor_ptr = addr (FLOAT_DEC_59_DESC);
      float_dec_len = arg_descriptor.size;
      float_dec_type = 2 * arg_descriptor.type;
      expr_results_ptr = addr (expr_results);

      if ^select_info.set_fn then
         do;					/* extra setup for "-another" */
	  retrieval_arg_list_ptr = table_control_info.incremental_retrieval_arg_ptr;
	  retrieve_code_ptr = retrieval_arg_list.arg_ptrs (retrieval_arg_list.arg_count);
         end;
      char_string_ptr = table_control_info.char_output_string_ptr;

   end prepare_to_load_rows;

%page;
retrieve_another:
   proc;
      if lcb.timing_mode then
	 initial_mrds_vclock = vclock;

      call cu_$generate_call (dsl_$retrieve, retrieval_arg_list_ptr);	/* Retrieve "-another" */
      icode = retrieve_code;

      if lcb.timing_mode then
	 lcb.mrds_time = lcb.mrds_time + vclock - initial_mrds_vclock;
   end retrieve_another;

%page;
retrieve_new:
   proc;

/* This procedure does the first retrieval from the currently
   open  database and sets up for subsequent retrievals using
   the "-another" selection expression.  */



/* assure that the arg_list is new */

      n_chars_init = 1;
      allocate char_desc in (work_area);
      arg_list_arg_count = select_info.n_mrds_items + 3 + select_info.nsevals;
						/* Offset for descriptors */
      allocate retrieval_arg_list in (work_area) set (retrieval_arg_list_ptr);			/* System standard argument list */
      retrieval_arg_list.header.pad1 = "0"b;
      retrieval_arg_list.header.call_type = Interseg_call_type;
      retrieval_arg_list.header.desc_count = retrieval_arg_list.arg_count;
      retrieval_arg_list.header.pad2 = "0"b;
      allocate retrieve_code in (work_area) set (retrieve_code_ptr);
						/* Code returned by generated call to dsl_$retrieve */
      retrieval_arg_list.arg_ptrs (arg_list_arg_count) = retrieve_code_ptr;
      retrieval_arg_list.desc_ptrs (arg_list_arg_count) = addr (char_desc.fb_desc);

						/* DB index */
      retrieval_arg_list.arg_ptrs (1) = addr (lcb.db_index);
      retrieval_arg_list.desc_ptrs (1) = addr (char_desc.fb_desc);

				/* selection expression */
      char_desc.arr.var (1) = addr (select_info.se_len) -> arg_len_bits.len;
      retrieval_arg_list.arg_ptrs (2) = select_info.se_ptr;
      retrieval_arg_list.desc_ptrs (2) = addr (char_desc.arr (1));

/* Fill in rest of standard arg_list */

/* First the selection expression values for substitution. */
      if select_info.nsevals ^= 0 then
         do item_index = 1 to select_info.nsevals;
	  retrieval_arg_list.arg_ptrs (item_index + 2) =
	     select_info.se_vals.arg_ptr (item_index);
	  retrieval_arg_list.desc_ptrs (item_index + 2) =
	     select_info.se_vals.desc_ptr (item_index);
         end;

/* Then the retrieved attribute values. */
      item_index = 1;
      do loop_index = 3 + select_info.nsevals
         to 2 + select_info.n_mrds_items + select_info.nsevals;
						/* Use pointers and descriptors from select_info structure */
         retrieval_arg_list.arg_ptrs (loop_index) =
	  select_info.mrds_item.arg_ptr (item_index);
         retrieval_arg_list.desc_ptrs (loop_index) =
	  addr (select_info.mrds_item.desc (item_index));
         if mdbm_util_$varying_data_class (
	  addr (select_info.mrds_item.desc (item_index))) then
	  do;
	     temp_ptr = select_info.mrds_item.arg_ptr (item_index);
	     retrieval_arg_list.arg_ptrs (loop_index) = addrel (temp_ptr, 1);
	  end;
         item_index = item_index + 1;
      end;

      if debug_switch then
         do;
	  call ioa_ ("Selection expression:");
	  call mdb_display_data_value$ptr (select_info.se_ptr,
	     addr (char_desc.arr (1)));
         end;					/* if debug_switch */

      if lcb.timing_mode then
	 initial_vclock = vclock;

      call cu_$generate_call (dsl_$retrieve, retrieval_arg_list_ptr);	/* Call retrieve */
      icode = retrieve_code;

      if lcb.timing_mode then
	 lcb.mrds_time = lcb.mrds_time + vclock - initial_vclock;

/* Insure that we are now set up for -another processing */

      retrieval_arg_list.arg_ptrs (2) = addr (ANOTHER);
      char_desc.arr (1).var = ANOTHER_LEN;

      table_control_info.incremental_retrieval_arg_ptr = retrieval_arg_list_ptr;
      table_control_info.incremental_retrieval_char_ptr = char_ptr;
      return;
   end retrieve_new;
%page;
select_uses_different_row_designators: proc () returns (bit (1) aligned);

dcl sudrd_loop fixed bin;

      do sudrd_loop = 2 to select_info.n_user_items;
	 if select_info.user_item.table_name (1) ^= select_info.user_item.table_name (sudrd_loop)
	 then return ("1"b);
      end;

      return ("0"b);

 end select_uses_different_row_designators;
%page;
store_the_row: proc (

	str_table_info_ptr_parm, /* input: ptr to the table_info structure */
	str_row_value_ptr_parm,  /* input: ptr to the row value */
	str_code_parm	     /* output: success or failure */
		);
%skip(1);
dcl str_code_parm fixed bin (35) parm;
dcl str_descriptor_ptr ptr;
dcl str_current_column_number fixed bin;
dcl str_loop fixed bin;
dcl str_row_value char (table_info.row_value_length) based (str_row_value_ptr);
dcl str_row_value_as_an_array (table_info.row_value_length) char (1) based (str_row_value_ptr);
dcl str_row_value_ptr ptr;
dcl str_row_value_ptr_parm ptr unaligned parm;
dcl str_table_info_ptr_parm ptr parm;
%skip(1);
	table_ip = str_table_info_ptr_parm;
	str_row_value_ptr = str_row_value_ptr_parm;
	str_code_parm = 0;
	store_ap = table_info.store_args_ptr;
%skip(1);
	do str_loop = 3 to table_info.column_count + 2;
	     str_current_column_number = str_loop - 2;
	     store_args.arg_ptrs (str_loop) = addr (str_row_value_as_an_array
		(table_info.columns (str_current_column_number).column_index));
	     str_descriptor_ptr = addr (table_info.columns.column_data_type (str_current_column_number));
	     if str_descriptor_ptr -> arg_descriptor.type = bit_dtype
	     then substr (str_row_value, 
		table_info.columns.column_index (str_current_column_number),
		table_info.columns.column_length (str_current_column_number))
		= translate (substr (str_row_value, 
		table_info.columns.column_index (str_current_column_number),
		table_info.columns.column_length (str_current_column_number)), CHARACTER_ZERO, BLANK);
	     else if str_descriptor_ptr -> arg_descriptor.type = varying_bit_dtype
		| str_descriptor_ptr -> arg_descriptor.type = varying_char_dtype
		then store_args.argument_list_descriptors (str_loop).size
		     = length (rtrim (substr (str_row_value,
		     table_info.columns.column_index (str_current_column_number),
		     table_info.columns.column_length (str_current_column_number))));
		else;
	end;
%skip(1);
	call cu_$generate_call (dsl_$store, addr (store_args.header));
	str_code_parm = store_args.error_code;
%skip(1);
	return;
%skip(1);
     end store_the_row;
%skip(1);

%include access_mode_values;
%page;
%include arg_descriptor;
%page;
%include arg_list;
%page;
%include linus_arg_list;
%page;
%include linus_char_argl;
%page;
%include linus_lcb;
%page;
%include linus_rel_array;
%page;
%include linus_select_info;
%page;
%include linus_sort_info;
%page;
%include linus_table_control;
%page;
%include linus_table_info;
%page;
%include linus_temp_tab_names;
%page;
%include mdbm_descriptor;
%page;
%include mrds_rslt_info;
%page;
%include sort_seg_info;
%page;
%include std_descriptor_types;


/* Based */

      dcl	    1 arg_len_bits	       based,
	      2 pad	       bit (12) unal,
	      2 len	       bit (24);		/* Length of argument to be passed in arg_list */
      dcl	    char_output_string     char (table_info.maximum_column_value_length)
			       based (char_string_ptr) varying;
      dcl	    component_ptr	       (table_control_info.max_number_of_components) ptr based (component_ptrs_p);
      dcl	    new_component_ptr      (table_control_info.max_number_of_components) ptr based (new_component_ptrs_p);
      dcl	    component_value	       (table_control_info.max_number_of_rows_per_seg)
			       char (table_info.row_value_length)
			       based (table_control_info.current_component_ptr);
      dcl	    sort_desc_array	       (sort_info.number_of_columns_to_sort) ptr based (sort_desc_array_ptr);
      dcl	    info_area	       area (sys_info$max_seg_size) based (info_area_p);
      dcl	    1 new_row_segs_info    like row_segs_info based (new_row_segs_ip);
      dcl	    retrieve_code	       fixed bin (35) based (retrieve_code_ptr);

      dcl 1 retrieval_arg_list aligned based (retrieval_arg_list_ptr),
            2 header like arg_list.header,
            2 arg_ptrs (arg_list_arg_count refer (retrieval_arg_list.header.arg_count)) ptr,
	  2 desc_ptrs (arg_list_arg_count refer (retrieval_arg_list.header.arg_count)) ptr;
      dcl retrieval_arg_list_ptr ptr;

      dcl	    1 sort_input	       aligned based (sort_input_ptr),
	      2 number_of_ptr_segments
			       fixed bin,
	      2 number_of_components
			       fixed bin,
	      2 sorted	       bit (1),
	      2 segment_ptr	       (row_segs_info
			       .number_of_seg_ptrs
			       refer (sort_input.number_of_ptr_segments))
			       ptr unal init (null),
	      2 component_ptr      (table_control_info
			       .msf_seg_count
			       refer (sort_input.number_of_components)) ptr
			       unal init (null);

      dcl	    1 sort_output	       based (sort_output_ptr),
	      2 number_of_segs     fixed bin,
	      2 seg_ptr	       (row_segs_info
			       .number_of_seg_ptrs
			       refer (sort_output.number_of_segs)) ptr unal
			       init (null);

      dcl	    1 user_item	       aligned based (user_item_ptr), /* valid when mrds item = user item */
	      2 arg_ptr	       ptr,
	      2 bit_len	       fixed bin (35),
	      2 desc	       bit (36),
	      2 assn_type	       fixed bin,
	      2 assn_len	       fixed bin (35);
      dcl	    work_area	       area (sys_info$max_seg_size) based (work_area_p);

/* Automatic */

      dcl	    arg_list_arg_count     fixed bin (17) unsigned unaligned;
      dcl	    bit_count	       fixed bin (24);
      dcl	    caller	       fixed bin;
      dcl	    char_string_ptr	       ptr;
      dcl	    component_ptrs_p       ptr init (null);
      dcl	    cmpx_float_dec_type    fixed bin;
      dcl	    duplicate_count	       fixed bin;
      dcl	    expr_results	       float dec (59);
      dcl	    expr_results_ptr       ptr;
      dcl	    expression_count       fixed bin;
      dcl	    float_dec_len	       fixed bin (35);
      dcl	    float_dec_type	       fixed bin;
      dcl	    icode		       fixed bin (35);
      dcl	    info_area_p	       ptr init (null);
      dcl	    initial_mrds_vclock    float bin (63);
      dcl	    initial_vclock	       float bin (63);
      dcl	    item_index	       fixed bin;
      dcl	    keep_from_row	       fixed bin (35);
      dcl	    loop_index	       fixed bin;
      dcl	    my_name	       char (11) init ("linus_table");
      dcl	    new_component_ptrs_p
			       ptr init (null);
      dcl	    new_row_segs_ip	       ptr init (null);
      dcl	    prec_len	       fixed bin;
      dcl	    retrieve_code_ptr      ptr;
      dcl	    row_count_specified    fixed bin;
      dcl	    row_index	       fixed bin;
      dcl	    scale_len	       fixed bin (11);
      dcl	    sci_ptr	       ptr;		/* for ssu_ */
      dcl	    sort_desc_array_ptr    ptr;
      dcl	    sort_input_ptr	       ptr;
      dcl	    sort_output_ptr	       ptr;
      dcl	    target_type	       fixed bin init (44);	/* char * 2 */
      dcl	    temp_ptr	       ptr init (null);
      dcl	    user_item_ptr	       ptr init (null);
      dcl	    work_area_p	       ptr init (null);

/* Builtins */

      dcl	    abs		       builtin;
      dcl	    addr		       builtin;
      dcl	    addrel	       builtin;
      dcl	    ceil		       builtin;
      dcl	    char		       builtin;
      dcl	    divide	       builtin;
      dcl	    fixed		       builtin;
      dcl	    length	       builtin;
      dcl	    log10		       builtin;
      dcl	    ltrim		       builtin;
      dcl	    max		       builtin;
      dcl	    null		       builtin;
      dcl	    rel		       builtin;
      dcl	    rtrim		       builtin;
      dcl	    substr	       builtin;
      dcl	    sum		       builtin;
      dcl     translate	       builtin;
      dcl     unspec	       builtin;
      dcl	    vclock	       builtin;

/* Conditions */

/* Static */

      dcl	    debug_switch	       bit (1) int static init ("0"b);
						/* Constants */

      dcl	    ANOTHER	       char (8) int static options (constant)
			       init ("-another");
      dcl	    ANOTHER_LEN	       bit (24) init ("000000000000000000001000"b)
			       int static options (constant);
      dcl	    BLANK		       char (1) internal static options (constant) init (" ");
      dcl	    CHARACTER_ZERO	       char (1) internal static options (constant) init ("0");
      dcl	    CREATE	       bit (1) int static options (constant) init ("1"b);
      dcl	    DEFAULT_EXPR_SIZE      fixed bin (5) int static options (constant)
			       init (17);
      dcl	    DELETE_SEG_SW	       bit (6) int static options (constant)
			       init ("100100"b);
      dcl	    EXPR		       fixed bin (2) int static options (constant)
			       init (2);
      dcl	    EXTENSIBLE	       bit (1) aligned int static options (constant)
			       init ("1"b);
      dcl	    FIXED_DEC_14_3_DESC    bit (36) int static options (constant)
			       init ("110101110000000000000011000000001110"b);
      dcl	    FLOAT_DEC_59_DESC      bit (36) int static options (constant)
			       init ("100101000000000000000000000000111011"b);
      dcl	    FREEING	       bit (1) aligned int static options (constant)
			       init ("0"b);
      dcl	    IOARS_STRING	       char (8) int static options (constant) init ("^.3f");
      dcl	    MRDS		       fixed bin (2) int static options (constant)
			       init (1);
      dcl	    NO_FREEING	       bit (1) aligned int static options (constant)
			       init ("1"b);
      dcl	    NO_ZERO_ON_ALLOC       bit (1) aligned int static options (constant)
			       init ("0"b);
      dcl	    NO_ZERO_ON_FREE	       bit (1) aligned int static options (constant)
			       init ("0"b);
      dcl	    ROW_SEG_INCREASE       fixed bin int static options (constant) init (10);

/* External */

      dcl	    error_table_$noentry
			       fixed bin (35) ext;
      dcl	    error_table_$no_table
			       fixed bin (35) ext;
      dcl	    linus_error_$no_lila_expr_processed
			       fixed bin (35) ext;
      dcl	    linus_error_$ret_not_valid
			       fixed bin (35) ext;
      dcl	    linus_error_$no_db     fixed bin(35) ext static;
      dcl     mrds_data_$max_temp_rels
			       fixed bin (35) ext static;
      dcl	    mrds_error_$tuple_not_found
			       fixed bin (35) ext;
      dcl	    sys_info$max_seg_size
			       fixed bin (35) ext;

/* Entries */

      dcl	    assign_round_	       entry (ptr, fixed bin, fixed bin (35), ptr,
			       fixed bin, fixed bin (35));
      dcl	    cu_$generate_call      entry (entry, ptr);
      dcl     dsl_$get_rslt_info     entry (fixed bin(35), char(*), ptr, ptr, fixed bin(35));
      dcl     dsl_$get_temp_info     entry (fixed bin(35), fixed bin(35), ptr, ptr, fixed bin(35));
      dcl	    dsl_$retrieve	       entry options (variable);
      dcl     dsl_$store	       entry() options(variable);
      dcl	    get_pdir_	       entry () returns (char (168));
      dcl	    delete_$path	       entry (char (*), char (*), bit (6), char (*), fixed bin (35));
      dcl	    ioa_		       entry options (variable);
      dcl	    ioa_$rsnnl	       entry options (variable);
      dcl	    linus_eval_expr	       entry (ptr, ptr, ptr, fixed bin, fixed bin,
			       fixed bin (35));
      dcl	    linus_eval_set_func    entry (ptr, ptr, fixed bin (35));
      dcl	    linus_temp_seg_mgr$get_segment
			       entry (ptr, char (*), char (*), ptr,
			       fixed bin (35));
      dcl	    linus_temp_seg_mgr$release_segment
			       entry (ptr, char (*), ptr, fixed bin (35));
      dcl     linus_translate_query$auto  entry (ptr, ptr);
      dcl	    mdbm_util_$binary_data_class
			       entry (ptr) returns (bit (1) aligned);
      dcl	    mdbm_util_$complex_data_class
			       entry (ptr) returns (bit (1) aligned);
      dcl	    mdbm_util_$fixed_data_class
			       entry (ptr) returns (bit (1) aligned);
      dcl	    mdbm_util_$number_data_class
			       entry (ptr) returns (bit (1) aligned);
      dcl	    mdbm_util_$string_data_class
			       entry (ptr) returns (bit (1) aligned);
      dcl	    mdbm_util_$varying_data_class
			       entry (ptr) returns (bit (1) aligned);
      dcl	    mdb_display_data_value$ptr
			       entry (ptr, ptr);
      dcl	    mdbm_util_$mu_define_area
			       entry (ptr, fixed bin (18), char (11),
			       bit (1) aligned, bit (1) aligned, bit (1) aligned,
			       bit (1) aligned, fixed bin (35));
      dcl	    msf_manager_$close     entry (ptr);
      dcl	    msf_manager_$get_ptr
			       entry (ptr, fixed bin, bit (1), ptr,
			       fixed bin (24), fixed bin (35));
      dcl	    msf_manager_$open      entry (char (*), char (*), ptr, fixed bin (35));
      dcl	    release_area_	       entry (ptr);
      dcl	    sort_seg_$linus_table
			       entry (ptr, char (*), ptr, entry, entry, char (*),
			       ptr, (*) ptr, ptr, fixed bin (35));
      dcl	    ssu_$abort_line	       entry options (variable);
      dcl	    ssu_$print_message     entry () options (variable);
      dcl	    unique_chars_	       entry (bit (*)) returns (char (15));

   end linus_table;
