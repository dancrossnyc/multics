/* **************************************************************
   *                                                            *
   * Copyright, (C) Massachusetts Institute of Technology, 1973 *
   *                                                            *
   ************************************************************** */
lisp_array_fcns_:	procedure;

/* This procedure implements all of the lisp sorting functions.
   The algorithm used is a slightly modified version of the
   algorithm "heapsort", as described in Knuth, Vol. III.

   In addition, several array utility functions are implemented
   here, as they use common code to handle array properties.
   In addition, various array manipulation functions are
   provided.

   Coded D. Reed, July 10, 1973.

   Modified 74.05.14 by DAM to:
	[1] move the sorting package to the end.
	[2] add the rest of the array manipulation functions (formerly in lisp_defsubr_)
	    i.e. *array, array, arraydims, *rearray, bltarray.
	[3] implement the "new array" scheme.

     NOTE:  this code frequently relies on the knowledge that fixnums and
	  flonums are stored in an equivalent format, and that flonum assignment
	  may be performed using a fixnum overlay.  This is to eliminate extra
	  unnecessary special cases.
   Modified 74.12.06 by DAM for changes in definition of listarray and fillarray
    and for external arrays, which are 1-dimensional fixnum arrays stored in external segments.
  */

dcl (stack,
    tstack,
     ustack ) ptr,
    lisp_property_fns_$get entry,
    lisp_error_ entry,
    lisp_alloc_$cons entry,
    lisp_alloc_$ncons entry,
    lisp_static_man_$allocate entry(pointer, fixed bin(18)),
    lisp_alloc_ entry(fixed bin(18), pointer),
    lisp_$eval entry,
    lisp_list_utils_$subst entry,
    lisp_property_fns_$putprop entry,
    lisp_$snapcaller entry, 		/* special entry to evaluator */

    (lisp_static_vars_$alphalessp_atom,
     lisp_static_vars_$readtable,
     lisp_static_vars_$external,
     lisp_static_vars_$fixnum,
     lisp_static_vars_$flonum) fixed bin(71) external,

    L fixed bin,			/* Knuth's losing 1 char variable names */
    R fixed bin,
    arraydim fixed bin,

    1 snapcall_args based aligned,
      2 fn_offset fixed bin,
      2 arg_length fixed bin,

    1 error_args based aligned,
      2 code fixed bin,
      2 name fixed bin,

    myname fixed bin,
    temp_item fixed bin(71),
    special_action_flag bit(1),
    (addr, addrel, divide, unspec, null, substr, mod, min, ptr, size) builtin;

dcl type_field bit(36) aligned,	/* type field to fill in in number sort */
    entry_id fixed bin;		/* code for type of sort to do:

	0		S-expression sort
	1		S-expression sortcar
	2		S-expression alphasort
	3		S-expression alphasortcar
	-1		Number sort
 */

dcl ndims fixed bin,
    nargs fixed bin,
    star_rearray bit(1),
    other_array_type fixed bin,
    other_array_ptr pointer,
    other_array_size fixed bin(18),
    external_array bit(1),		/* flag on if creating an external array */
    array_type fixed bin,
    array_ptr pointer,
    array_size fixed bin(18),
    i fixed bin(18);

dcl 1 packed_pointer_aligned aligned based,
    2 packed_pointer unaligned pointer;


dcl (fix1, fix2) fixed bin(35),
    (float1, float2) float bin(27);

	/* Error Codes */

dcl (lisp_error_table_$bad_argument,
     lisp_error_table_$wrong_external_array_ndims,
     lisp_error_table_$argument_must_be_array,
     lisp_error_table_$not_same_type,
     lisp_error_table_$special_array_type,
     lisp_error_table_$too_few_args,
     lisp_error_table_$too_many_args,
     lisp_error_table_$array_too_big,
     lisp_error_table_$store_not_allowed,
     lisp_error_table_$not_an_array,
    lisp_error_table_$not_alpha_array,
     lisp_error_table_$dead_array_reference) fixed bin external;
dcl  bad_argument fixed bin defined lisp_error_table_$bad_argument,
     wrong_external_array_ndims fixed bin defined lisp_error_table_$wrong_external_array_ndims,
     argument_must_be_array fixed bin defined lisp_error_table_$argument_must_be_array,
     not_same_type fixed bin defined lisp_error_table_$not_same_type,
     special_array_type fixed bin defined lisp_error_table_$special_array_type,
     too_few_args fixed bin defined lisp_error_table_$too_few_args,
     too_many_args fixed bin defined lisp_error_table_$too_many_args,
     array_too_big fixed bin defined lisp_error_table_$array_too_big,
     store_not_allowed fixed bin defined lisp_error_table_$store_not_allowed,
     not_an_array fixed bin defined lisp_error_table_$not_an_array,
    not_alpha_array fixed bin defined lisp_error_table_$not_alpha_array,
     dead_array_reference fixed bin defined lisp_error_table_$dead_array_reference;

	/* information used in constructing arrays */

dcl fault_tag_3_number_2 bit(72) static init("000000000000000010000000000000100111000000000000000000000000000000000000"b);

dcl words_per_item (0:5) fixed bin static init(2,2,1,1,1,2);

dcl 1 array_load_sequence(0:5) static aligned,		/* instructions to load  from array */
      2 inst(3) bit(36) initial(
		(2)("101000000000000000010011111001000110"b,
		    "010000000000000000111001000001000000"b, ""b),	/* S-expr, Un-gc:  ldaq lb|0,ql  tra bp|0 */
		"000100000000100111010011101000000111"b,
		"101000000000000000010011110001000110"b,
		"010000000000000000111001000001000000"b,	/* fixnum - lda 040047,dl  ldq lb|0,ql  tra bp|0 */
		"000010000000100111010011101000000111"b,
		"101000000000000000010011110001000110"b,
		"010000000000000000111001000001000000"b,	/* flonum - lda 020047,dl  ldq lb|0,ql  tra bp|0 */
		"000100000000100111010011101000000111"b,
		"101000000000000000010011110001000110"b,
		"010000000000000000111001000001000000"b,	/* readtable - lda 040047,dl  ldq lb|0,ql  tra bp|0 */
		"101000000000000000010011111001000110"b,
		"010000000000000000111001000001000000"b,
		""b);					/* obarray - ldaq lb|0,ql  tra bp|0 */

dcl fixed_data (0:array_size-1) fixed bin(35) aligned based,
    float_data (0:array_size-1) float bin(27) aligned based,
    array_element (0:array_size-1) fixed bin(71) aligned based,
    bounds (ndims) fixed bin(18) aligned based(ustack);	/* vector of bounds in unmkd pdl */




%include lisp_array_fmt;
%include lisp_stack_seg;
%include lisp_nums;
%include lisp_readtable;
%include lisp_common_vars;
%include lisp_cons_fmt;
%include lisp_name_codes;
%include lisp_stack_fmt;
%include lisp_ptr_fmt;
%include lisp_atom_fmt;
%include lisp_string_fmt;


star_array:  entry;		/* LISP *array function, create an array */

	myname = fn_star_array;
	call lsubr_initialization;
	star_rearray = "0"b;
	call make_array;			/* call common code for array and *array */
	go to exit;

make_array: procedure;

	special_action_flag = "0"b;
	external_array = "0"b;
	unspec(ptr(ustack, 0) -> stack_seg.array_info_for_store) = fault_tag_3_number_2;

	ndims = divide(nargs, -2, 17, 0)-2;	/* number of dimensions in array */

	/* identify type of array to be created */

	if stack -> temp(2) = nil then array_type = Un_gc_array;
	else if stack -> temp(2) = t_atom then array_type = S_expr_array;
	else if stack -> temp(2) = lisp_static_vars_$fixnum then array_type = Fixnum_array;
	else if stack -> temp(2) = lisp_static_vars_$flonum then array_type = Flonum_array;
	else if stack -> temp(2) = lisp_static_vars_$obarray then array_type = Obarray_array;
	else if stack -> temp(2) = lisp_static_vars_$readtable then array_type = Readtable_array;
	else if stack -> temp(2) = lisp_static_vars_$external then do;
		external_array = "1"b;
		array_type = Fixnum_array;	/* looks much like a fixnum array */
		ndims = ndims - 1;		/* First "dimension" is packed ptr */
		if ndims ^= 1 then call reject_argument(1, wrong_external_array_ndims);
		end;
	else call reject_argument(2, bad_argument);

	/* first argument may be nil (generate array pointer),
	   an array pointer (to be reused), or an atomic symbol (apply to array property) */

	if stack -> temp(1) = nil
	then if ^ star_rearray then call make_array_pointer;
	     else call reject_argument(1, bad_argument);
	else if stack -> temp_type36(1) & Atsym36 then do;
		call get_array_prop;
		if tstack -> temp(1) = nil then do;	/* put on array property */
		   if star_rearray then call reject_argument(1, argument_must_be_array);
		   tstack -> temp(1) = stack -> temp(1);	/* symbol */
		   call make_array_pointer;
		   stack_ptr = addr(tstack -> temp(4));
		   tstack -> temp(2) = stack -> temp(1);	/* array ptr */
		   tstack -> temp(3) = lisp_static_vars_$array_atom;	/* 'array */
		   call lisp_property_fns_$putprop;
		   end;
		else stack -> temp(1) = tstack -> temp(1);	/* prior array property  */
		end;

	if stack -> temp_type36(1) & Array36
	then if ^ star_rearray
	     then call kill_array;
	     else;			/* don't kill the array if *rearray */
	else call reject_argument(1, bad_argument);

	/* special checks for *rearray - type must match and not be special */

	if star_rearray then do;
	   if array_type ^= stack -> temp_ptr(1) -> array_info.type
	   then call reject_argument(2, not_same_type);
	   if array_type >= Readtable_array then call reject_argument(1, special_array_type);
	   other_array_size = 1;		/* compute old size */
	   other_array_ptr = stack -> temp_ptr(1) -> array_info.array_data_ptr;
	   do i = 1 to stack -> temp_ptr(1) -> array_info.ndims;
	      other_array_size = other_array_size * other_array_ptr ->
				array_data.dope_vector(i - stack -> temp_ptr(1) -> array_info.ndims).bounds;
	      end;
	   end;

	/* at this point, stack -> temp(1) is an array pointer
	   to an array info block, dead unless *rearray.  Now fill in the info block */

	if array_type >= Readtable_array then ndims = 1;	/* args treated differently in these cases */
	stack -> temp_ptr(1) -> array_info.ndims = ndims;
	stack -> temp_ptr(1) -> array_info.minus_2_times_ndims = -2*ndims;
	stack -> temp_ptr(1) -> array_info.gc_mark = ""b;

	stack -> temp_ptr(1) -> array_info.array_load_sequence =
		array_load_sequence(array_type).inst(*);

	if ^ external_array then do;		/* following code omitted for ext arrays */

	/* create copy of bounds vector in unmkd pdl, do error checking,
	   and compute number of elements in the array (array_size) */

	if ndims <= 0 then call reject_argument(1, too_few_args);
	else if ndims > 510 then call reject_argument(1, too_many_args);
	unmkd_ptr = addrel(ustack, ndims+mod(ndims,2));	/* room for bounds vector, even word alignment */
	if array_type < Readtable_array then do;		/* bounds come from arguments */
	     array_size = 1;
	     do i = 1 to ndims;
	        if stack -> temp_type36(i+2) & Fixed36
	        then do;
		   bounds(i) = addr(stack -> temp(i+2)) -> fixedb;
		   if bounds(i) < 0 then call reject_argument(i+2, bad_argument);
		   else array_size = array_size * bounds(i);
		   end;
	        else call reject_argument(i+2, bad_argument);
	        end;
	     end;
	else if array_type = Readtable_array then do;	/* Readtable */
	     array_size, bounds(1) = 290;
	     end;
	else do;					/* Obarray */
	     array_size, bounds(1) = 639;
	     end;

	/* create data area */

	i = words_per_item(array_type)*array_size + 2*ndims;
	if i > 50000 then call reject_argument(1, array_too_big);	/* decide it is too big */
	call lisp_alloc_(i, array_ptr);
	array_ptr = addrel(array_ptr, 2*ndims);	/* -> after dope vector, before data */

	other_array_ptr = stack -> temp_ptr(1) -> array_info.array_data_ptr;		/* may have gc'ed */

	/* initialize dope vector */

	do i = 1 to ndims;
	   array_ptr -> array_data.dope_vector(i-ndims).bounds = bounds(i);
	   end;

	array_ptr -> array_data.dope_vector(ZERO).multiplier = words_per_item(array_type);
	do i = ndims-1 by -1 to 1;
	   array_ptr -> array_data.dope_vector(i-ndims).multiplier = bounds(i+1);
	   end;

	/* initialize the data area */

	if ^ star_rearray then other_array_size = 0;	/* if nothing to copy */
	if array_type < Fixnum_array 		/* init to nil */
	then do;
	     do i = 0 by 1 to min(array_size, other_array_size)-1;
	        array_ptr -> array_element(i) = other_array_ptr -> array_element(i);
	        end;
	     do i = i by 1 while (i < array_size);
	        array_ptr -> array_element(i) = nil;
	        end;
	     end;

	else if array_type = Fixnum_array
	then do;
	     do i = 0 by 1 to min(array_size, other_array_size)-1;
	        array_ptr -> fixed_data(i) = other_array_ptr -> fixed_data(i);
	        end;
	     do i = i by 1 while (i < array_size);
	        array_ptr -> fixed_data(i) = 0;
	        end;
	     end;

	else if array_type = Flonum_array
	then do;
	     do i = 0 by 1 to min(array_size, other_array_size)-1;
	        array_ptr -> float_data(i) = other_array_ptr -> float_data(i);
	        end;
	     do i = i by 1 while (i < array_size);
	        array_ptr -> float_data(i) = 0.0;
	        end;
	     end;

	else if array_type = Obarray_array then do;
	     if nargs > -6 then stack -> temp(3) = t_atom;	/* default 3rd arg is t */
	     if stack -> temp(3) = nil		/* leave completely empty */
	     then do i = 0 to 638;
		array_ptr -> array_data.data(i) = nil;
		end;
	     else do;			/* copy some existing obarray */
		if stack -> temp(3) = t_atom then stack -> temp(3) = addr(lisp_static_vars_$obarray)->based_ptr -> atom.value;
		call get_array_prop_3;
		if tstack -> temp_type36(1) & Array36 then;
		else do;
		     call reject_argument(3, argument_must_be_array);
		     end;
		if tstack -> temp_ptr(1) -> array_info.type ^= Obarray_array
		then call reject_argument(3, not_same_type);

		array_ptr -> array_element(*) = tstack -> temp_ptr(1) -> array_info.array_data_ptr -> array_element(*);
		special_action_flag = "1"b;	/* remember to copy the buckets */
		end;
	     end;

	else if array_type = Readtable_array then do;
	     if nargs > -6 then stack -> temp(3) = nil;	/* default 3rd arg is nil */
	     if stack -> temp(3) = nil then stack -> temp(3) = addr(lisp_static_vars_$readtable)->based_ptr -> atom.value;
	     if stack -> temp(3) = t_atom		/* copy initial readtable */
	     then call initialize_a_readtable;
	     else do;				/* copy other readtable */
		call get_array_prop_3;
		if tstack -> temp_type36(1) & Array36 then;
		else do;
		     call reject_argument(3, argument_must_be_array);
		     end;
		if tstack -> temp_ptr(1) -> array_info.type ^= Readtable_array
		then call reject_argument(3, not_same_type);
		other_array_ptr = tstack -> temp_ptr(1) -> array_info.array_data_ptr;
		call copy_a_readtable;
		end;
	     end;

	end;		/* end of if ^ external_array */
	else do;		/* external array - pick up arguments & create array */

		if stack -> temp_type36(3) & Fixed36 then do;	/* pick up ptr */
			array_ptr = addr(addr(stack -> temp(3))->fixedb)->packed_pointer;
			end;
		else call reject_argument(3, bad_argument);
		stack -> temp_ptr(1) -> array_info.minus_2_times_ndims = 0;	/* ext array flag */
		if stack -> temp_type36(4) & Fixed36 then do;	/* pick up bound */
			array_size = addr(stack -> temp(4))->fixedb;
			end;
		else call reject_argument(4, bad_argument);
		stack -> temp_ptr(1) -> array_info.array_load_sequence(1) =
			unspec(array_size);		/* set up for bounds check (ecch) */
		end;

	/* array initialization completed.  make the array accessible */

	stack -> temp_ptr(1) -> array_info.array_data_ptr = array_ptr;
	stack -> temp_ptr(1) -> array_info.type = array_type;
	if array_type ^= Readtable_array
	then stack -> temp_ptr(1) -> array_info.call_array_operator = call_array_operator;
	else stack -> temp_ptr(1) -> array_info.call_array_operator = call_dead_array_operator;	/* readtable - can't subscript*/

	/* perform any deferred consing. This is done down here because
	   all the various array pointers have to get set up before
	   we can allow a garbage collection.  Yes, it's kludgey */

	if special_action_flag
	then if array_type = Readtable_array		/* copy more_macros list */
	     then call finish_copying_readtable;
	else if array_type = Obarray_array then do;	/* copy the buckets */
		call finish_copying_obarray;
		end;

	/* the return value from array or *array is in stack -> temp(1),
	   so these functions will always return the array pointer */

end make_array;

/* routines to initialize and copy readtables */

initialize_a_readtable:  proc;		/* array_ptr -> array_data block to init */

dcl lisp_static_vars_$quote_macro fixed bin(71) external,
   lisp_static_vars_$semicolon_macro fixed bin(71) external,
    lisp_static_vars_$vertical_bar_macro fixed bin(71) external,
    1 lisp_reader_alm_$initial_readtable aligned external,
      2 std_syntax(0:131) bit(18) aligned,
      2 std_translation(0:131) fixed bin;

	array_ptr -> read_table.macro_table(1) = lisp_static_vars_$quote_macro;
	array_ptr -> read_table.macro_table(2) = lisp_static_vars_$semicolon_macro;
	array_ptr -> read_table.macro_table(3) = lisp_static_vars_$vertical_bar_macro;
	do i = 4 to num_macs;
	   array_ptr -> read_table.macro_table(i) = nil;
	   end;
	array_ptr -> read_table.more_macros = nil;

	array_ptr -> read_table.syntax = std_syntax;
	array_ptr -> read_table.translation = std_translation;

	array_ptr -> read_table.status_terpri = "0"b;
	array_ptr -> read_table.status_underline = "1"b;
	array_ptr -> read_table.status_ttyread = "1"b;
	array_ptr -> read_table.abbreviate_on_files = "0"b;
	array_ptr -> read_table.abbreviate_on_flat = "1"b;
	unspec(array_ptr -> read_table.words_not_used_yet) = ""b;
end initialize_a_readtable;

copy_a_readtable:  proc;			/* array_ptr -> new, other_array_ptr -> old */

	array_ptr -> read_table = other_array_ptr -> read_table;	/* copy whole thing */
	special_action_flag = "1"b;		/* remember to copy more_macros list (KLUDGE) */

end copy_a_readtable;

finish_copying_readtable:  proc;		/* called to copy the more_macros list */

	tstack = stack_ptr;
	stack_ptr = addr(tstack -> temp(4));
	tstack -> temp(1), tstack -> temp(2) = nil;
	tstack -> temp(3) = array_ptr -> read_table.more_macros;
	call lisp_list_utils_$subst;
	stack -> temp_ptr(1) -> array_info.array_data_ptr -> read_table.more_macros = tstack -> temp(1);
end finish_copying_readtable;

finish_copying_obarray:  proc;		/* copy the buckets so can remob from old array
					   without affecting the new one */

	tstack = stack_ptr;
	do i = 0 to 638;
	   stack_ptr = addr(tstack -> temp(4));
	   tstack -> temp(1), tstack -> temp(2) = nil;
	   tstack -> temp(3) = stack -> temp_ptr(1) -> array_info.array_data_ptr -> array_data.data(i);
	   call lisp_list_utils_$subst;
	   stack -> temp_ptr(1) -> array_info.array_data_ptr -> array_data.data(i) = tstack -> temp(1);
	   end;
end finish_copying_obarray;

array:  entry;		/* the LISP array function */

	stack = addrel(stack_ptr, -2);
	do nargs = 0 repeat (nargs+1) while(stack -> temp_type(1) = Cons);
	   stack_ptr = addr(stack -> temp(nargs+3));
	   stack -> temp(nargs+2) = stack -> temp_ptr(1) -> cons.car;
	   stack -> temp(1) = stack -> temp_ptr(1) -> cons.cdr;
	   if nargs > 1 then call lisp_$eval;		/* eval all but first two args */
	   end;

	nargs = -2*nargs;			/* lsubr compatibility */

	ustack = unmkd_ptr;
	myname = fn_array;
	star_rearray = "0"b;
	stack -> temp(1) = stack -> temp(2);	/* copy the first argument so it can be returned */
	stack = addr(stack -> temp(2));	/* -> arguments */
	call make_array;			/* call subroutine to do like *array */
	stack = addrel(stack, -2);		/* adjust for extra stack cell */
	if stack -> temp(1) = nil		/* return first argument, or array ptr if it was nil */
	then stack -> temp(1) = stack -> temp(2);
	go to exit;

star_rearray:  entry;			/* LISP *rearray function */

	myname = fn_star_rearray;
	star_rearray = "1"b;
	call lsubr_initialization;
	if nargs >= -2 then do;		/* kill existing array */
	   if stack -> temp_type36(1) & Array36 then call kill_array;
	   else do;
	        call get_array_prop;
	        stack -> temp(1) = tstack -> temp(1);
	        if stack -> temp_type36(1) & Array36 then call kill_array;
	        end;
	   if stack -> temp_type36(1) & Array36	/* actually killed it */
	   then stack -> temp(1) = t_atom;	/* return result like remprop */
	   else stack -> temp(1) = nil;
	   go to exit;
	   end;

	/* *rearray with more than one argument - reformat the array */

	call make_array;			/* do all work in common code */
	go to exit;


/* useful routines used by the above */

reject_argument:  proc(num, err);

dcl num fixed bin,			/* number of stack cell containing bad argument */
    err fixed bin;		/* error code to use */

dcl unm pointer,
    tstack pointer;

dcl 1 args_to_lisp_error_on_unmarked_pdl aligned based,
    2 errcode (2) fixed bin(35);

	tstack = stack_ptr;
	stack_ptr = addr(tstack -> temp(2));
	tstack -> temp(1) = stack -> temp(num);

	unm = unmkd_ptr;
	unmkd_ptr = addrel(unm, 2);
	unm -> errcode(1) = err;
	unm -> errcode(2) = myname;
	call lisp_error_;
	stack -> temp(num) = tstack -> temp(1);	/* in case correctable error */
	stack_ptr = tstack;
end;


kill_array:  proc;		/* kill array pointed at by stack -> temp(1) */

	stack -> temp_ptr(1) -> array_info.type = Dead_array;
	stack -> temp_ptr(1) -> array_info.call_array_operator = call_dead_array_operator;
	stack -> temp_ptr(1) -> array_info.array_data_ptr = null;
end;

make_array_pointer:  proc;	/* set stack -> temp(1) to an array pointer + initialize array_info */

	call lisp_static_man_$allocate(array_ptr, size(array_info));
	unspec(stack -> temp(1)) = unspec(array_ptr) | Array36 | Subr36;	/* turn on type bit */
	call kill_array;		/* do some initialization */
end;


lsubr_initialization:  proc;

	stack = addrel(stack_ptr, -2);
	nargs = stack -> fixedb;		/* -2* # of args */
	stack = addrel(stack, nargs);
	ustack = unmkd_ptr;
end lsubr_initialization;


get_array_prop_3:  procedure;
	stack = addr(stack -> temp(3));
	call get_array_prop;
	stack = addrel(stack, -4);
end get_array_prop_3;

get_array_prop:  procedure;

	tstack = stack_ptr;
	stack_ptr = addr(tstack -> temp(2));
	tstack -> temp(1) = stack -> temp(1);
	if tstack -> temp_type36(1) & Array36 then return;	/* already an array pointer */
	stack_ptr = addr(tstack -> temp(3));
	tstack -> temp(2) = lisp_static_vars_$array_atom;
	call lisp_property_fns_$get;
end get_array_prop;

/* various array operations, converting from arrays to lists, and initting arrays */


fillarray:	entry;		/* fills an array from a list, replicating the last element as necessary */

	myname = fn_fillarray;
	stack = addrel(stack_ptr, -4);

	if stack -> temp_type(2) ^= Cons	/* allow (fillarray to-array from-array) */
	then do;				/* by interchanging args & using bltarray */
	     temp_item = stack -> temp(2);
	     stack -> temp(2) = stack -> temp(1);
	     stack -> temp(1) = temp_item;
	     go to fillarray_bltarray_join;
	     end;

	call get_array_property;

	if array_type >= Readtable_array
	then call reject_argument(1, store_not_allowed);

	L = 0;
	stack_ptr = addr(stack -> temp(4));
	do while(stack -> temp(2) ^= nil);	/* until the end of the list argument */
	     stack -> temp(3) = stack -> temp_ptr(2) -> cons.car;
	     if array_type < Fixnum_array		/* S-expression array */
	     then array_ptr -> array_element(L) = stack -> temp(3);

	     else if array_type = Fixnum_array		/* Fixnum array */
	     then if addr(stack -> temp(3))-> fixnum_fmt.type_info = fixnum_type
		then array_ptr -> fixed_data(L) = addr(stack -> temp(3))-> fixedb;
		else call reject_argument(3, store_not_allowed);
	     else					/* Flonum array */
		if addr(stack -> temp(3))-> flonum_fmt.type_info = flonum_type
		then array_ptr -> float_data(L) = addr(stack -> temp(3))-> floatb;
		else call reject_argument(3, store_not_allowed);
	     stack -> temp(2) = stack -> temp_ptr(2) -> cons.cdr;
	     L = L + 1;
	     if L = array_size then go to done;
	     end;

	if L = 0 then go to done;

	/* replicate last element */

	if array_type < Fixnum_array then do;		/* replicate S-expression */
	   stack -> temp(2) = array_ptr -> array_element(L-1);
	   do L = L repeat (L+1) while (L < array_size);
	      array_ptr -> array_element(L) = stack -> temp(2);
	      end;
	   end;

	else if array_type = Fixnum_array then do;		/* replicate a fixnum */
	     fix1 = array_ptr -> fixed_data(L-1);
	     do L = L repeat (L+1) while (L < array_size);
		array_ptr -> fixed_data(L) = fix1;
		end;
	     end;

	else if array_type = Flonum_array then do;		/* replicate a flonum */
	     float1 = array_ptr -> float_data(L-1);
	     do L = L repeat (L+1) while (L < array_size);
		array_ptr -> float_data(L) = float1;
		end;
	     end;

done:	stack_ptr = addr(stack -> temp(2));
	return;



listarray:	entry;		/* convert an array to a list */

	myname = fn_listarray;
	call lsubr_initialization;		/* extended to lsubr 74.12.06 */

	call get_array_property;
	if nargs < -2 then array_size = min(array_size, 		/* argument - limit # elems returned */
			addr(stack -> temp(2)) -> fixedb);
	if array_type = Readtable_array then call reject_argument(1, special_array_type);

	stack -> temp(1) = stack -> temp(3);		/* save the array-pointer */
	stack = addr(stack -> temp(2));
	stack_ptr = addr(stack -> temp(3));
	stack -> temp(1) = nil;
	do L = array_size - 1 to 0 by -1;	/* start with last array element */

	     stack -> temp(2) = stack -> temp(1);
	     if array_type < Fixnum_array
	     then stack -> temp(1) = array_ptr -> array_element(L);

	     else if array_type = Fixnum_array then do;
		stack -> fixnum_fmt.type_info = fixnum_type;
		stack -> fixedb = array_ptr -> fixed_data(L);
		end;

	     else if array_type = Flonum_array then do;
		stack -> flonum_fmt.type_info = flonum_type;
		stack -> floatb = array_ptr -> float_data(L);
		end;
	     else do;			/* Obarray */
		stack -> temp(1) = array_ptr -> array_element(L);
		end;	/* ncons SCO buckets??? */
	     call lisp_alloc_$cons;
	     array_ptr = stack -> temp_ptr(ZERO) -> array_info.array_data_ptr;	/* in case GC */
	     stack_ptr = addr(stack -> temp(3));	/* readjust stack */
	     end;
	stack = addrel(stack, -2);			/* recover hidden cell */
	stack -> temp(1) = stack -> temp(2);	/* move result down */
	go to done;

bltarray:  entry;

	myname = fn_bltarray;
	stack = addrel(stack_ptr, -4);
fillarray_bltarray_join:			/* bltarray is obsolete except fillarray uses it */
	call get_array_property;		/* process 1st arg */
	other_array_type = array_type;
	other_array_size = array_size;

	stack = addr(stack -> temp(2));	/* process 2nd arg */
	call get_array_property;
	other_array_ptr = stack -> temp_ptr(2) -> array_info.array_data_ptr;	/* have to do this because of GC */

	if array_type ^= other_array_type
	then if array_type >= Fixnum_array | other_array_type >= Fixnum_array
	then do;		/* types have to match, except can mix S-expr and un-gc */
	     stack_ptr = addr(stack -> temp(3));
	     call lisp_alloc_$ncons;
	     call lisp_alloc_$cons;
	     stack = stack_ptr;
	     call reject_argument(0, not_same_type);
	     end;

	/* checking is completed, now copy the data */

	stack = addrel(stack, -2);			/* -> args */
	stack -> temp(1) = stack -> temp(4);		/* array object to be written into.
						   This is also return value */
	array_size = min(array_size, other_array_size);	/* how many elements to copy over */
	if array_type = Readtable_array then do;
	   call copy_a_readtable;
	   call finish_copying_readtable;
	   end;
	else if array_type = Obarray_array then do;
	   array_ptr -> array_element(*) = other_array_ptr -> array_element(*);
	   call finish_copying_obarray;		/* make top-level copies of buckets */
	   end;
	else if array_type >= Fixnum_array	/* copy number array */
	     then array_ptr -> fixed_data(*) = other_array_ptr -> fixed_data(*);
	else array_ptr -> array_element(*) =	/* copy S-expr or un_gc array */
		other_array_ptr -> array_element(*);
	go to done;

arraydims:  entry;	/* arraydims subr, return list of array type and dimensions */

	myname = fn_arraydims;
	stack = addrel(stack_ptr, -2);
	call get_array_property;
	ndims = stack -> temp_ptr(3) -> array_info.ndims;
	call lisp_alloc_(4*(ndims+1), stack -> temp_ptr(1));		/* create return list in one fell swoop.
								   this is array won't move later */
	array_ptr = stack -> temp_ptr(3) -> array_info.array_data_ptr;	/* -> dope vector */

	/* get type of array */

	if array_type = S_expr_array then stack -> temp_ptr(1) -> temp(1) = t_atom;
	else if array_type = Un_gc_array then stack -> temp_ptr(1) -> temp(1) = nil;
	else if array_type = Fixnum_array then stack -> temp_ptr(1) -> temp(1) = lisp_static_vars_$fixnum;
	else if array_type = Flonum_array then stack -> temp_ptr(1) -> temp(1) = lisp_static_vars_$flonum;
	else if array_type = Readtable_array then stack -> temp_ptr(1) -> temp(1) = lisp_static_vars_$readtable;
	else if array_type = Obarray_array then stack -> temp_ptr(1) -> temp(1) = lisp_static_vars_$obarray;

	/* copy dimensions and link up the list */

	if stack -> temp_ptr(3) -> array_info.minus_2_times_ndims ^= 0	/* normal array */
	then do i = 1 by 1 while(i <= ndims);
	   addr(stack -> temp_ptr(1) -> temp(2*i+1))-> fixnum_fmt.type_info = fixnum_type;
	   addr(stack -> temp_ptr(1) -> temp(2*i+1))-> fixedb = array_ptr -> array_data.dope_vector(i-ndims).bounds;
	   stack -> temp_ptr(1) -> temp_ptr(2*i) = addr(stack -> temp_ptr(1) -> temp(2*i+1));
	   end;
	else do;			/* external array */
	   stack -> temp_ptr(1) -> temp_ptr(2) = addr(stack -> temp_ptr(1) -> temp(3));
	   addr(stack -> temp_ptr(1) -> temp(3)) -> fixnum_fmt.type_info = fixnum_type;
	   unspec(addr(stack -> temp_ptr(1) -> temp(3)) -> fixedb) = array_ptr -> array_info.array_load_sequence(1);
	   end;
	stack -> temp_ptr(1) -> temp(2*ndims+2) = nil;		/* end the list */
	stack_ptr = addr(stack -> temp(2));
	return;

mapatoms:	entry;

	myname = fn_mapatoms;
	call lsubr_initialization;
	if nargs = -2 then stack -> temp(2) = addr(lisp_static_vars_$obarray) -> based_ptr -> atom.value;
	stack_ptr = addr(stack-> temp(5));
	unmkd_ptr = addrel(ustack,2);
	ustack-> snapcall_args.fn_offset = -8;
	ustack -> snapcall_args.arg_length = -2;

	do while((stack->temp_type36(2)&Array36) = "0"b);
bad_mapa:
		call reject_argument(2,not_an_array);
	end;

	if stack->temp_ptr(2)->array_info.type ^= Obarray_array then go to bad_mapa;

	do i = 0 to 510;
		stack->temp(3) = stack->temp_ptr(2)->array_info.array_data_ptr -> array_element(i);
		do while(stack->temp(3) ^= nil);
			stack->temp(4) = stack->temp_ptr(3)-> cons.car;
			stack->temp(3) = stack->temp_ptr(3)->cons.cdr;
			call lisp_$snapcaller;
		end;
	end;

	do i = 511 to 638;
		stack->temp(4) = stack->temp_ptr(2)-> array_info.array_data_ptr-> array_element(i);
		if stack->temp(4) ^= nil then call lisp_$snapcaller;
	end;

	stack->temp(1) = t_atom;
	stack_ptr = addr(stack->temp(2));
	unmkd_ptr = ustack;
	return;

sort:	entry;			/* major sort entrypoint, taking two lisp args, first is array, second is < predicate */

	myname = fn_sort;
	entry_id = 0;

join_sort:
	stack = addrel(stack_ptr, -4);
	ustack = unmkd_ptr;

	if stack -> temp(2) = lisp_static_vars_$alphalessp_atom
	then go to alphasort;				/* special alphbetic sorting feature for speed */

	if stack -> temp(1) = nil then go to exit;
	if stack -> temp_type(1)
	then do;
		call get_array_property;
		if array_type < Fixnum_array then;	/* regular old S-expression sort */
		else if array_type = Fixnum_array
		     then if entry_id = 0 then do;
			entry_id = -1;
			type_field = fixnum_type;
			end;
		     else go to cant_sortcar_number_array;
		else if array_type = Flonum_array
		     then if entry_id = 0 then do;
			entry_id = -1;
			type_field = flonum_type;
			end;
		     else go to cant_sortcar_number_array;
		else go to cant_sort_special_array;
		call heapsort;
	     end;
	else call merge_sort;


exit:	stack_ptr = addr(stack -> temp(2));
	unmkd_ptr = ustack;

	return;


/* Error exits */

cant_sort_special_array:
cant_sortcar_number_array:
cant_alphasort_number_array:
	call reject_argument(1, special_array_type);

sortcar:	entry;

	myname = fn_sortcar;
	entry_id = 1;

	go to join_sort;

alphasort: entry_id = entry_id + 2;		/* indicate special comparison technique */

alpha_retry:
	if stack -> temp(1) = nil then go to exit;
	if stack -> temp_type(1)
		then do;
		call get_array_property;			/* get the array property, which we must verify as
							   an aplhabetic array */
		if array_type >= Fixnum_array then go to cant_alphasort_number_array;
	
		do L = array_size-1 by -1 to 0;			/* check the whole array */
		  if entry_id = 2 then
		     if addr(array_ptr -> array_element(L)) -> lisp_ptr_type & (Atsym36|String36) then;
		     else do;
	
alpha_loss:		     stack_ptr = addr(stack -> temp(2));
			     unmkd_ptr =addrel(ustack,2);
			     ustack -> error_args.code = not_alpha_array;
	
			     ustack -> error_args.name = myname;
	
			     call lisp_error_;
			     go to alpha_retry;
			end;
		  else if addr(array_ptr -> array_element(L)) -> based_ptr -> lisp_ptr_type & (Atsym36|String36) then;
		       else go to alpha_loss;
	
		end;
	
		call heapsort;
	     end;

	else do;

		stack_ptr = addr(stack -> temp(3));	/* set up args for cons */
		stack -> temp(2) = stack -> temp(1);

		do while(stack -> temp(2) ^= nil);
		  if entry_id = 2 then
		     if stack -> temp_ptr(2) -> lisp_ptr_type & (Atsym36|String36) then;
		     else go to alpha_loss;
		  else if stack -> temp_ptr(2) -> cons_ptrs.car -> lisp_ptr_type & (Atsym36|String36) then;
		     else go to alpha_loss;
		     stack -> temp(2) = stack -> temp_ptr(2) -> cons.cdr;
		end;

		call merge_sort;
	     end;

	go to exit;

heapsort:	proc;			/* algorithm to implent Knuth's heapsort */

	if array_size <= 1 then go to exit;

	stack_ptr = addr(stack->temp(5));		/* set up for siftup */
	unmkd_ptr = addrel(ustack,2);
	ustack->snapcall_args.fn_offset = -10;		/* offset of function from top of  stack */
	ustack->snapcall_args.arg_length = -4;		/* -2 * nargs */

	R = array_size - 1;

/* Now we enter into Knuth's algorithm proper */

	do L = divide(array_size,2,17,0)-1 to 0 by -1;

	     if entry_id >= 0
	     then stack -> temp(4) = array_ptr -> array_element(L);		/* set K */
	     else do;
		addr(stack -> temp(4)) -> fixnum_fmt.type_info = type_field;
		addr(stack -> temp(4)) -> fixedb = array_ptr -> fixed_data(L);
		end;
	     call siftup;

	end;

	L = 0;					/* make sure */

	if entry_id < 0
	then do;
	     addr(stack -> temp(4)) -> fixnum_fmt.type_info = type_field;
	     addr(stack -> temp(4)) -> fixedb = array_ptr -> fixed_data(R);
	     array_ptr -> fixed_data(R) = array_ptr -> fixed_data(0);
	     end;
	else do;
	     stack -> temp(4) = array_ptr -> array_element(R);		/* set K */
	     array_ptr -> array_element(R) = array_ptr -> array_element(0);	/* move next element to final pos */
	     end;
	do R = R-1 to 1 by -1;

	     call siftup;
	     if entry_id >= 0 then do;
		stack -> temp(4) = array_ptr -> array_element(R);	/* set K */
		array_ptr -> array_element(R) = array_ptr -> array_element(0);	/* move next element to final pos */
		end;
	     else do;
		addr(stack -> temp(4)) -> fixnum_fmt.type_info = type_field;
		addr(stack -> temp(4)) -> fixedb = array_ptr -> fixed_data(R);
		array_ptr -> fixed_data(R) = array_ptr -> fixed_data(0);
		end;

	end;
	if entry_id >= 0
	then array_ptr -> array_element(0) = stack -> temp(4);
	else array_ptr -> fixed_data(0) = addr(stack -> temp(4)) -> fixedb;



	end heapsort;

siftup:	proc;		/* the algorithm for ordering the binary tree correctly */

dcl (I, J) fixed bin;	/* more Knuth variables */


	do I = L repeat(J);

	     J = 2*I+1;

	     if J > R
	     then do;
pop_out:		if entry_id >= 0
		then array_ptr -> array_element(I) = stack -> temp(4);	/* move K into proper place */
		else array_ptr -> fixed_data(I) = addr(stack -> temp(4)) -> fixedb;
		return;
		end;

	     if J < R 		/* I.E. there are two sons to node I in the heap, rather than 1. */
	     then do;
		stack_ptr = addr(stack->temp(7));		/* compare elements j and j+1 */
		if entry_id >= 0 then do;
		     stack -> temp(5) = array_ptr ->array_element(J);
		     stack -> temp(6) = array_ptr -> array_element(J+1);
		     end;
		else do;
		     addr(stack -> temp(5)) -> fixnum_fmt.type_info,
		      addr(stack -> temp(6)) -> fixnum_fmt.type_info = type_field;
		     addr(stack -> temp(5)) -> fixedb = array_ptr -> fixed_data(J);
		     addr(stack -> temp(6)) -> fixedb = array_ptr -> fixed_data(J+1);
		     end;
		call compare;		/* call the comparison function */
		if stack -> temp(5) ^= nil then J = J+1;	/* use the greater valued node */
		end;

	     stack_ptr = addr(stack -> temp(7));
	     stack -> temp(5) = stack -> temp(4);		/* first arg to comparator is K */
	     if entry_id >= 0
	     then stack -> temp(6) = array_ptr -> array_element(J);	/* second is the larger son of node I */
	     else do;
		addr(stack -> temp(6)) -> fixnum_fmt.type_info = type_field;
		addr(stack -> temp(6)) -> fixedb = array_ptr -> fixed_data(J);
		end;
	     call compare;			/* call function */

	     if stack -> temp(5) = nil then go to pop_out;	/* if K larger or equal, we are done */

	     if entry_id >= 0
	     then array_ptr -> array_element(I) = array_ptr -> array_element(J);
	     else array_ptr -> fixed_data(I) = array_ptr -> fixed_data(J);

	end;

end siftup;

compare:	procedure;			/* internal procedure for determining the ordering of two elements */

dcl j fixed bin,
    string_ptr(0:1) ptr;


	go to comparison(entry_id);		/* branck on which type of sort */

comparison(1):				/* sortcar */
comparison(3):				/* sortcar (alphalessp) */
	stack -> temp(5) = stack -> temp_ptr(5) -> cons.car;
	stack -> temp(6) = stack -> temp_ptr(6) -> cons.car;
	go to comparison(entry_id-1);

comparison(-1):				/* number sort */
comparison(0):				/* sort */
	call lisp_$snapcaller;		/* call evaluator to apply the function,
					   cleverly remembering the subr property for successive
					   calls if possible! */
	if array_ptr ^= null		/* if array sort recompute ptr */
	then array_ptr = stack -> temp_ptr(3) -> array_info.array_data_ptr;	/* in case gc in predicate */
	return;

comparison(2):				/* alphasort */

	do j = 0 to 1;			/* get two string pointers */
	     if stack -> temp_type36(5+j) & String36
	     then string_ptr(j) = stack -> temp_ptr(5+j);
	     else string_ptr(j) = addr(stack -> temp_ptr(5+j) -> atom.pnamel);
	end;

	/* now compare the strings */

	if string_ptr(0) -> lisp_string.string_length >= string_ptr(1) -> lisp_string.string_length
	then do;

		j = string_ptr(1) -> lisp_string.string_length;	/* min of the lengths */
		if substr(string_ptr(0) -> lisp_string.string,1, j)
		   < substr(string_ptr(1) -> lisp_string.string,1,j)
		then stack -> temp(5) = t_atom;
		else stack -> temp(5) = nil;

	     end;

	else do;

		j = string_ptr(0) -> lisp_string.string_length;	/* min of the lengths */
		if substr(string_ptr(0) -> lisp_string.string,1,j)
		    <= substr(string_ptr(1) -> lisp_string.string,1,j)
		then stack -> temp(5) = t_atom;
		else stack -> temp(5) = nil;

	     end;

   end compare;


get_array_property: procedure;		/* common code to get array property */

/* the following variables are set by this routine from the array in stack -> temp(1):
	array_ptr		-> data area of array
	array_size	number of elements in array
	array_type	type of array
   stack -> temp(2) is undisturbed
   stack -> temp(3) is left with the array-pointer (-> array_info)
 */

	stack_ptr = addr(stack -> temp(5));
retry:
	stack -> temp(3) = stack -> temp(1);		/* get array property of first arg */
	if stack -> temp_type36(3) & Array36 then;	/* already got array pointer */
	else do;					/* get array pointer from array property */
	     stack -> temp(4) = lisp_static_vars_$array_atom;
	     call lisp_property_fns_$get;
	     if stack -> temp_type36(3) & Array36 then;
	     else do;
		call reject_argument(1, not_an_array);	/* signal correctable error */
		go to retry;
		end;
	     end;

	array_type = stack -> temp_ptr(3) -> array_info.type;
	if array_type = Dead_array
	then call reject_argument(1, dead_array_reference);

	array_ptr = stack -> temp_ptr(3) -> array_info.array_data_ptr;
	array_size = 1;
	if stack -> temp_ptr(3) -> array_info.minus_2_times_ndims ^= 0	/* normal array */
	then do i = - stack -> temp_ptr(3) -> array_info.ndims
	     repeat (i+1)
	     while (i < 0);
	   array_size = array_size * array_ptr -> array_data.dope_vector(i+1).bounds;
	   end;
	else unspec(array_size) = stack -> temp_ptr(3) ->
			array_info.array_load_sequence(1);	/* external array */

end get_array_property;

merge:	proc;		/* procedure to merge two lists */

	if stack -> temp(1) = nil
	then do;
		stack -> temp(1) = stack -> temp(2);
		return;
	     end;

	if stack -> temp(2) = nil then return;

	stack_ptr = addr(stack -> temp(7));		/* for space we need */
	stack -> temp(5) = stack -> temp_ptr(1) -> cons.car;
	stack -> temp(6) = stack -> temp_ptr(2) -> cons.car;
	call compare;					/* compare heads of lists */
	if stack -> temp(5) = nil
	then do;						/* if first list >= second */
		stack -> temp(3) = stack -> temp(1);
		stack -> temp(1) = stack -> temp(2);
	     end;

	else do;
		stack -> temp(3) = stack -> temp(2);
		stack -> temp(2) = stack -> temp(1);
	     end;

	stack -> temp(4) = stack -> temp(2);			/* temp 4 points to cell to rplacd */
	stack -> temp(2) = stack -> temp_ptr(2) -> cons.cdr;	/* temp 2 contains list we are merging into */

							/* temp 3 contains list we are merging from */
	do while(stack -> temp(2) ^= nil);

	     stack_ptr = addr(stack->temp(7));
	     stack -> temp(5) = stack -> temp_ptr(2) -> cons.car;
	     stack -> temp(6) = stack -> temp_ptr(3) -> cons.car;
	     call compare;
	     if stack -> temp(5) = nil			/* if list we are merging into is >=
							   than list merging from, exchange */
	     then do;
		     stack -> temp_ptr(4) -> cons.cdr = stack -> temp(3);
		     stack -> temp(3) = stack -> temp(2);
		     stack -> temp(2) = stack -> temp_ptr(4) -> cons.cdr;
		end;

	     stack -> temp(4) = stack -> temp(2);		/* move down list */
	     stack -> temp(2) = stack -> temp_ptr(4) -> cons.cdr;

	end;

	stack -> temp_ptr(4) -> cons.cdr = stack -> temp(3);	/* put remainder of list on end */

end merge;


merge_sort:proc;						/* procedure to merge sort a list in place */

dcl retv(0:99) fixed bin,				/* return stack, of essentially infinite length */
    sourcep ptr,
    depth fixed bin,
    list_size fixed bin;					/* log of length of current lists */

	array_ptr = null;					/* see compare */
	stack_ptr = addr(stack -> temp(4));
	sourcep = stack;

	unmkd_ptr = addrel(ustack,2);
	ustack -> snapcall_args.fn_offset = -14;
	ustack -> snapcall_args.arg_length = -4;

	stack -> temp(3) = nil;				/* initial result */
	depth = 0;					/* initial recursion depth */
	retv(0) = 0;					/* set return for call to pfx */
	list_size = -1;
	stack = stack_ptr;
	go to pfx;

pfxret(0):	stack = addrel(stack,-2);				/* get back to result, and merge in */
	stack_ptr = addr(stack -> temp(3));
	call merge;

	if sourcep -> temp(1) = nil
	then do;
		sourcep -> temp(1) = stack -> temp(1);
		stack = sourcep;
		goto exit;
	     end;

	stack = addr(stack -> temp(2));			/* move up again */
	list_size = list_size + 1;
	go to pfx;

pfx:							/* routine to obtain sorted prefix of source list */
	stack_ptr = addr(stack -> temp(2));
	stack -> temp(1) = sourcep -> temp(1);		/* get source list */
	if stack -> temp(1) = nil				/* if none left, */
	then goto pfxret(retv(depth));
	if list_size <= 0
	then do;
		sourcep -> temp(1) = sourcep -> temp_ptr(1) -> cons.cdr;
		stack -> temp_ptr(1) -> cons.cdr = nil;		/* get list of length 1 */
		go to pfxret(retv(depth));
	     end;

	/* otherwise, call pfx recursiviely twice, and merge the two shorter lists */

	list_size = list_size - 1;
	depth = depth + 1;
	retv(depth) = 1;			/* set return address */
	go to pfx;

pfxret(1):retv(depth) = 2;			/* set for next call */
	stack = addr(stack -> temp(2));
	ustack -> snapcall_args.fn_offset = ustack -> snapcall_args.fn_offset - 2;
	go to pfx;

pfxret(2):stack = addrel(stack,-2);
	depth = depth - 1;
	list_size = list_size + 1;
	call merge;
	ustack -> snapcall_args.fn_offset = ustack -> snapcall_args.fn_offset + 2;
	go to pfxret(retv(depth));		/* return */

end merge_sort;
end lisp_array_fcns_;
