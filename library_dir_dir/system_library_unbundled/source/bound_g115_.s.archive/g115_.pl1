/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */


g115_: proc;

	return;					/* not a legal entry */


/* Rewritten by D. Vinograd, 11/77, to make the G115 an iox based module for MR 6.1 */
/* Modified by J. Nicholls 7/78 to change full_cc to rr_cnt to use reocrd counting instead of character counting */
/* Modified by D. Vinograd, 10/78, for compatibility with MCS 3.3 and above */
/* Modified by J. C. Whitmore, 11/78, to make all attach options consistent with the remote_xxx_ dims */
/* Modified by J. C. Whitmore, 3/79, to correct size and initialization of delay variable */
/* Modified by J. C. Whitmore, 8/79, grossley changed to accept binary output mode and multiple channels per process */




/*	Parameters	*/

dcl  a_code fixed bin (35) parameter;
dcl (a_new_mode, a_old_mode) char (*) parameter;
dcl  a_nelem fixed bin (21) parameter;
dcl  a_nelemt fixed bin (21) parameter;
dcl  a_devx fixed bin parameter;
dcl  a_ddp ptr parameter;
dcl  a_adp ptr parameter;
dcl  a_bufp ptr parameter;
dcl  a_iocbp ptr parameter;
dcl  a_option (*) char (*) var parameter;
dcl  a_comerr_sw bit (1) parameter;
dcl  a_open_mode fixed bin parameter;
dcl  a_order char (*) parameter;
dcl  a_infop ptr parameter;

/*	Automatic		*/

dcl  attach_description char (256) var;
dcl  bufp ptr;
dcl  chn fixed bin (71);
dcl  code fixed bin (35);
dcl  comerr_sw bit (1) init ("0"b);
dcl  comm char (32);
dcl  delay fixed bin (35);
dcl  device char (32);
dcl  device_type fixed bin;
dcl  dial_msg_chan char (32);				/* Variables for dial manager */
dcl  dial_msg_module char (32);
dcl  dial_msg_ndialed fixed bin;
dcl  dummy_arg char (32);
dcl  i fixed bin;
dcl  ignore fixed bin (35);
dcl  infop ptr;
dcl  iocbp ptr;
dcl  level fixed bin;
dcl  mask bit (36);
dcl  max_length fixed bin;
dcl  open_mode fixed bin;
dcl  order char (32);
dcl  state fixed bin;
dcl  temp_ptr ptr;
dcl  terminal_type char (32);
dcl  tty char (32);

/*	Internal Static	*/

dcl  attach_areap ptr int static init (null);		/* pointer to attach_area */
dcl  first_device_data_p ptr int static init (null);	/* head of chain of device data structures */
dcl  last_device_data_p ptr int static init (null);	/* tail of this chain */
dcl  static_comerr_sw bit (1) int static init ("0"b);	/* to force error messages during debug */

/*	Based variables	*/

dcl  attach_area area (262144) based (attach_areap);	/* space for device_data and attach data structures */
dcl  info_string char (32) based (infop);		/* for the control entry */

/*	External Entries	*/

dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
dcl  timer_manager_$sleep entry (fixed bin (71), bit (2));
dcl  get_process_id_ entry () returns (bit (36));
dcl  get_ttt_info_ entry (ptr, fixed bin (35));
dcl  hcs_$tty_abort entry (fixed bin, fixed bin, fixed bin, fixed bin (35));
dcl  ipc_$delete_ev_chn entry (fixed bin (71), fixed bin (35));
dcl  ipc_$decl_ev_wait_chn entry (fixed bin (71), fixed bin (35));
dcl  ipc_$decl_ev_call_chn entry (fixed bin (71), entry, ptr, fixed bin, fixed bin (35));
dcl  ipc_$block entry (ptr, ptr, fixed bin (35));
dcl  hcs_$tty_attach entry (char (*), fixed bin (71), fixed bin, fixed bin, fixed bin (35));
dcl  ioa_ entry options (variable);
dcl  iox_$control entry (ptr, char (*), ptr, fixed bin (35));
dcl  hcs_$tty_detach entry (fixed bin, fixed bin, fixed bin, fixed bin (35));
dcl  g115_io_$read_status entry (ptr, ptr, fixed bin (35));
dcl  g115_io_$write entry (ptr, ptr, fixed bin (35));
dcl  hcs_$tty_order entry (fixed bin, char (*), ptr, fixed bin, fixed bin (35));
dcl  ipc_$create_ev_chn entry (fixed bin (71), fixed bin (35));
dcl  convert_ipc_code_ entry (fixed bin (35));
dcl  dial_manager_$privileged_attach entry (ptr, fixed bin (35));
dcl  dial_manager_$release_channel entry (ptr, fixed bin (35));
dcl  dial_manager_$dial_out entry (ptr, fixed bin (35));
dcl  convert_dial_message_ entry (bit (72) aligned, char (*), char (*), fixed bin, 1 like dial_msg_flags aligned,
     fixed bin (35));
dcl  com_err_ entry options (variable);
dcl  get_temp_segment_ entry (char (*), ptr, fixed bin (35));
dcl  release_temp_segment_ entry (char (*), ptr, fixed bin (35));
dcl  continue_to_signal_ entry (fixed bin (35));
dcl  iox_$err_no_operation entry;
dcl  hcs_$set_ips_mask entry (bit (36), bit (36));
dcl  iox_$propagate entry (ptr);
dcl  hcs_$reset_ips_mask entry (bit (36), bit (36));
dcl  g115_protocol_$write entry (ptr, ptr, ptr, fixed bin (21), fixed bin (35));
dcl  g115_protocol_$read entry (ptr, ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));

/*	Builtins and Conditions	*/

dcl (null, addr, hbound, length, rtrim, ltrim, unspec, empty) builtin;

dcl  cleanup condition;
dcl  any_other condition;

/*	Error Table Entries		*/

dcl  error_table_$bad_conversion fixed bin (35) ext;
dcl  error_table_$noarg fixed bin (35) ext;
dcl  error_table_$line_status_pending ext fixed bin (35);
dcl  error_table_$action_not_performed ext fixed bin (35);
dcl  error_table_$ionmat ext fixed bin (35);
dcl  error_table_$wrong_no_of_args ext fixed bin (35);
dcl  error_table_$badopt ext fixed bin (35);
dcl  error_table_$bad_mode ext fixed bin (35);
dcl  error_table_$multiple_io_attachment ext fixed bin (35);
dcl  error_table_$invalid_read ext fixed bin (35);
dcl  error_table_$invalid_write ext fixed bin (35);
dcl  error_table_$not_attached fixed bin (35) ext;
dcl  error_table_$not_detached fixed bin (35) ext;
dcl  error_table_$not_open fixed bin (35) ext;
dcl  error_table_$not_closed fixed bin (35) ext;
dcl  error_table_$no_operation fixed bin (35) ext;
dcl  error_table_$io_no_permission fixed bin (35) ext;
dcl  error_table_$resource_attached fixed bin (35) ext;

/* 	Constants		 */

dcl  devices (4) char (32) static options (constant) init ("reader", "printer", "teleprinter", "punch");

/* Line Control and Status Values */

dcl  set_g115_remote_mode fixed bin int static init (3) options (constant);
dcl  test_for_fnp_output fixed bin int static init (5) options (constant);
dcl  reset_g115_remote_mode fixed bin int static static init (6) options (constant);
dcl  fnp_output_pending fixed bin int static init (8) options (constant);

/*	Structures	*/

dcl 1 line_status aligned,				/* for the Ring 0 line_status order */
   (2 value,
    2 mbz1,
    2 mbz2,
    2 mbz3) fixed bin unal;

dcl 1 hangup_proc aligned based (infop),		/* Data for hangup_proc order */
    2 entry_var entry variable,
    2 data_ptr ptr,
    2 prior fixed bin;

dcl 1 info_structure aligned based (infop),		/* for the read_status control order */
    2 ev_chan fixed bin (71),
    2 input_available bit (1);

dcl 1 modes aligned,				/* for the Ring 0 tty modes order */
    2 len fixed bin,
    2 str char (256);

dcl 1 event_info aligned,				/* data returned by ipc_$block */
    2 channel_id fixed bin (71),			/* event channel which signalled this wakeup */
    2 message fixed bin (71),				/* 72 bit event message from sender */
    2 sender bit (36),				/* process id of sending process */
    2 origin,
      3 dev_signal bit (18) unal,
      3 ring bit (18) unal,
    2 channel_index fixed bin (17);			/* index of channel_id in the wait list we blocked on */

dcl 1 dial_msg_flags aligned,				/* data returned from convert_dial_message_ */
    2 dialed_up bit (1) unal,
    2 hung_up bit (1) unal,
    2 control bit (1) unal,
    2 pad bit (33) unal;

dcl 1 dma aligned,					/* data for dial_manager_ to attach, dial_out or allow dials */
    2 version fixed bin,				/* this is the version 1 structure */
    2 dial_qual char (22),				/* phone number for dial_out, qualifier for allow dials */
    2 dial_mgr_ev_chan fixed bin (71),			/* IPC chan for Ans. Serv. to notify us on */
    2 device_name char (32);				/* name of the tty channel we want to have assigned */

dcl 1 dial_wait_list aligned,				/* IPC wait list for blocking after calling dial_manager_ */
    2 nchan fixed bin init (1),			/* number of channels in this list: always 1 */
    2 dummy_word fixed bin,				/* so the next will be on even word */
    2 dial_mgr_ev_chan fixed bin (71);


%include iocb;

%include iox_modes;

%include io_call_info;

%include g115_attach_data;

%include g115_device_data;

%include g115_message;

%include G115;

%include remote_ttt_info;

g115_attach: entry (a_iocbp, a_option, a_comerr_sw, a_code);

	comerr_sw = static_comerr_sw | a_comerr_sw;	/* print error messages if either switch is on */

	adp, device_data_p = null;			/* no attach data or device data structures defined yet */
	terminal_type, tty, comm, device = "";
	delay, code, a_code = 0;
	iocbp = a_iocbp;				/* copy the input iocb pointer */

	if iocbp -> iocb.attach_descrip_ptr ^= null then do; /* already used? */
	     code = error_table_$not_detached;
	     call abort_attach ("Already attached", "");
	end;

	if hbound (a_option, 1) < 1 then do;
	     code = error_table_$wrong_no_of_args;
	     call abort_attach ("No attach description", "");
	end;

	if attach_areap = null then do;		/* make an area for attach data structures */
	     call get_temp_segment_ ("g115_attach", attach_areap, code);
	     if code ^= 0 then call abort_attach ("Unable to create temp segment", "");
	     attach_area = empty;			/* initialize the area */
	end;

	on cleanup call clean_up_handler;

	dma.dial_qual = "";				/* prepare for call to dial manager */
	attach_description = "g115_";			/* start building att desc which we will tell iox_ about */
	do i = 1 to hbound (a_option, 1);
	     attach_description = attach_description || " " || a_option (i);
	     if a_option (i) = "-device" then device = get_option_arg (i);
	     else if a_option (i) = "-tty" then tty = get_option_arg (i);
	     else if a_option (i) = "-comm" then comm = get_option_arg (i);
	     else if a_option (i) = "-auto_call" then dma.dial_qual = get_option_arg (i);
	     else if a_option (i) = "-ascii" then;	/* ignore ascii/ebcdic specification */
	     else if a_option (i) = "-physical_line_length" | a_option (i) = "-pll" then dummy_arg = get_option_arg (i);
						/* ignore -pll N but no error */
	     else if a_option (i) = "-terminal_type" | a_option (i) = "-ttp" then terminal_type = get_option_arg (i);
	     else if a_option (i) = "-delay" then do;
		delay = cv_dec_check_ ((get_option_arg (i)), code);
		if code ^= 0 | delay < 0 then do;
		     code = error_table_$bad_conversion;
		     call abort_attach ("Invalid delay value", (a_option (i)));
		end;
	     end;
	     else do;
		code = error_table_$badopt;
		call abort_attach ("Invalid attach description option", (a_option (i)));
	     end;
	end;

	if comm ^= "rci" then do;
	     code = error_table_$badopt;		/* indicate bad, but not which one???? */
	     call abort_attach ("Invalid or missing -comm option", (comm));
	end;

	if tty = "" then do;
	     code = error_table_$badopt;
	     call abort_attach ("No ""-tty"" option given", "");
	end;

	do i = 1 to hbound (devices, 1) while (device ^= devices (i));
	end;
	if i > hbound (devices, 1) then do;
	     code = error_table_$badopt;
	     call abort_attach ("Invalid device specified", (device));
	end;
	else device_type = i;

	do temp_ptr = first_device_data_p repeat (temp_ptr -> g115_device_data.fwd_ptr)
		while (temp_ptr ^= null & device_data_p = null);
	     if temp_ptr -> g115_device_data.tty_name = tty then /* channel already defined ? */
		device_data_p = temp_ptr;		/* then grab the ptr and exit loop */
	end;

	if device_data_p = null then do;		/* first init for this device */
	     call ipc_$create_ev_chn (dial_wait_list.dial_mgr_ev_chan, code);
	     if code ^= 0 then call abort_attach ("Unable to create dial event channel", "");

	     dma.version = 1;			/* Setup dial manager request structure */
	     dma.dial_mgr_ev_chan = dial_wait_list.dial_mgr_ev_chan;
	     dma.device_name = tty;			/* say which tty channel we want */

	     if dma.dial_qual = ""			/* normal attach or auto_call (dial_out) */
	     then call dial_manager_$privileged_attach (addr (dma), code);
	     else call dial_manager_$dial_out (addr (dma), code);
	     if code = error_table_$action_not_performed | code = error_table_$resource_attached
		then go to maybe_mine_already;
	     if code ^= 0 then call abort_attach ("From dial_manager_ attaching ^a", (tty));

dial_wait:     call ipc_$block (addr (dial_wait_list), addr (event_info), code);
						/* wait for Answering Service to give us the device */
	     if code ^= 0 then do;
		call convert_ipc_code_ (code);
		call abort_attach ("From ipc_$block waiting for ^a attachment.", (tty));
	     end;

/*	Call convert_dial_message_ so it can update it's table of attached channels */

	     call convert_dial_message_ (unspec (event_info.message), dial_msg_chan, dial_msg_module,
		dial_msg_ndialed, dial_msg_flags, code);
	     if code ^= 0 then call abort_attach ("From dial_manager_ attaching ^a", (tty));

	     if ^dial_msg_flags.dialed_up then do;	/* OOPS - we got a wakeup for some other event - PUNT */
		call com_err_ (0, "g115_", "Dial message received: ^[HANGUP^;CONTROL^] on channel: ^a",
		     dial_msg_flags.hung_up, dial_msg_chan);
		go to dial_wait;			/* wait for our channel */
	     end;

maybe_mine_already:

	     call create_device_data (device_data_p);	/* allocate structure and link it */

	     call init_g115_device_data (device_data_p, code); /* then initialize it for this tty device */

	     if code ^= 0 then call abort_attach ("Unable to initialize device data", "");

	     g115_device_data.tty_name = tty;		/* save name for future attaches */
	     g115_device_data.dial_mgr_ev_chan = dial_wait_list.dial_mgr_ev_chan;
	     g115_device_data.delay = delay;		/* use the value from attach options */

/*	set up IPC wait list to use for input/output blocking:  two channels, tty and timeout */

	     call ipc_$create_ev_chn (g115_device_data.tty_ev_channel, code); /* create ring 0 tty event channel */
	     if code ^= 0 then call abort_attach ("Unable to create tty event channel", "");;

	     call ipc_$create_ev_chn (g115_device_data.timeout_ev_channel, code);
	     if code ^= 0 then call abort_attach ("Unable to create timeout event channel", "");;

	     g115_device_data.nchan = 2;

	     call hcs_$tty_attach (tty, g115_device_data.tty_ev_channel, g115_device_data.devx, state, code);
	     if state ^= 5 then code = error_table_$io_no_permission;
	     if code ^= 0 then call abort_attach ("Unable to attach communications channel.", "");

	     modes.str = "rawo,rawi,^hndlquit";
	     modes.len = length (modes.str);		/* set the max size for return info */

	     call hcs_$tty_order (g115_device_data.devx, "modes", addr (modes), state, code);
	     if state ^= 5 then code = error_table_$io_no_permission;
	     if code ^= 0 then call abort_attach ("Unable to set initial modes", "");

	     max_length = G115.max_msg_len + 10;	/* tell ring 0 the largest msg we will see */

	     call hcs_$tty_order (g115_device_data.devx, "set_input_message_size", addr (max_length), state, code);
	     if state ^= 5 then code = error_table_$io_no_permission;
	     if code ^= 0 then call abort_attach ("Unable to set input message size", "");
	end;

	allocate g115_attach_data in (attach_area) set (adp); /* get a place for the attach data structure */

	unspec (g115_attach_data) = "0"b;		/* initialize the attach data structure */
	g115_attach_data.device_type = device_type;	/* record the device type code (fixed bin) */
	g115_attach_data.device = device;		/* set device name in here (char) */
	g115_attach_data.attach_description = attach_description;
	g115_attach_data.device_ptr = device_data_p;	/* point it back to the device block */

/*	 define the media code for this attachment */

	if device_type = teleprinter then g115_attach_data.media_code = G115.teleprinter_mc;
	else if device_type = printer then g115_attach_data.media_code = G115.printer_mc;
	else if device_type = punch then g115_attach_data.media_code = G115.punch_bcd_mc; /* default data type */
	else g115_attach_data.media_code = "";		/* others are input devices */

/*	set default ttt data  */

	g115_attach_data.terminal_type = terminal_type;
	g115_attach_data.kill_char = "@";
	g115_attach_data.erase_char = "#";
	g115_attach_data.ttt_bits = "1"b;
	g115_attach_data.ttt_ptrs = null;

	if g115_attach_data.device_type = reader then g115_attach_data.canonicalize_input = "0"b;

	if g115_attach_data.terminal_type ^= "" then do;
	     call get_ttt_info_ (addr (g115_attach_data.ttt_info), code);
	     if code ^= 0 then call abort_attach ("Unknown terminal type specified", "");
	end;

	mask = "0"b;

	on any_other call any_other_handler;

	call hcs_$set_ips_mask ("0"b, mask);

	iocbp -> iocb.attach_descrip_ptr = addr (g115_attach_data.attach_description);
	iocbp -> iocb.attach_data_ptr = adp;
	iocbp -> iocb.open = g115_open;
	iocbp -> iocb.detach_iocb = g115_detach;
	iocbp -> iocb.control = iox_$err_no_operation;
	iocbp -> iocb.position = iox_$err_no_operation;
	iocbp -> iocb.modes = iox_$err_no_operation;
	iocbp -> iocb.put_chars = iox_$err_no_operation;
	iocbp -> iocb.get_chars = iox_$err_no_operation;
	iocbp -> iocb.get_line = iox_$err_no_operation;
	iocbp -> iocb.read_record = iox_$err_no_operation;
	iocbp -> iocb.write_record = iox_$err_no_operation;

	g115_device_data.attach_count = g115_device_data.attach_count + 1; /* count up attaches */

	call iox_$propagate (iocbp);

	revert cleanup;

	call hcs_$reset_ips_mask (mask, mask);

	revert any_other;

	code = 0;

attach_return:

	a_code = code;				/* pass back any error codes */

	return;

g115_open: entry (a_iocbp, a_open_mode, a_comerr_sw, a_code);

	a_code, code = 0;				/* be sure to initialize */
	iocbp = a_iocbp -> iocb.actual_iocb_ptr;
	adp = iocbp -> iocb.attach_data_ptr;
	device_data_p = g115_attach_data.device_ptr;

	if adp = null | device_data_p = null then do;
	     a_code = error_table_$not_attached;
	     return;
	end;

	if g115_device_data.hangup_signalled then do;	/* Illegal if we sent a hangup to the device */
	     a_code = error_table_$io_no_permission;
	     return;
	end;

	open_mode = a_open_mode;

	if ^((open_mode = Stream_input) | (open_mode = Stream_output) | (open_mode = Stream_input_output)) then do;
	     a_code = error_table_$bad_mode;
	     return;
	end;

	g115_attach_data.open_description = rtrim (iox_modes (open_mode));

	mask = "0"b;

	on any_other call any_other_handler;

	call hcs_$set_ips_mask ("0"b, mask);

	if ((open_mode = Stream_input) | (open_mode = Stream_input_output)) then do;
	     iocbp -> iocb.get_chars = g115_get_chars;
	     iocbp -> iocb.get_line = g115_get_chars;
	end;
	if ((open_mode = Stream_output) | (open_mode = Stream_input_output)) then do;
	     iocbp -> iocb.put_chars = g115_put_chars;
	end;
	iocbp -> iocb.read_record = iox_$err_no_operation;
	iocbp -> iocb.write_record = iox_$err_no_operation;
	iocbp -> iocb.control = g115_control;
	iocbp -> iocb.modes = g115_modes;
	iocbp -> iocb.close = g115_close;
	iocbp -> iocb.open_descrip_ptr = addr (g115_attach_data.open_description);

	call iox_$propagate (iocbp);

	call hcs_$reset_ips_mask (mask, mask);

	revert any_other;

	return;

g115_close: entry (a_iocbp, a_code);

	a_code, code = 0;				/* be sure to initialize */
	iocbp = a_iocbp -> iocb.actual_iocb_ptr;
	adp = iocbp -> iocb.attach_data_ptr;
	device_data_p = g115_attach_data.device_ptr;

	if adp = null | device_data_p = null then do;
	     a_code = error_table_$not_attached;
	     return;
	end;

	if iocbp -> iocb.open_descrip_ptr = null then do;
	     a_code = error_table_$not_open;
	     return;
	end;

	mask = "0"b;

	on any_other call any_other_handler;

	call hcs_$set_ips_mask ("0"b, mask);

	iocbp -> iocb.open_descrip_ptr = null;
	iocbp -> iocb.open = g115_open;
	iocbp -> iocb.detach_iocb = g115_detach;
	iocbp -> iocb.control = iox_$err_no_operation;
	iocbp -> iocb.position = iox_$err_no_operation;
	iocbp -> iocb.modes = iox_$err_no_operation;
	iocbp -> iocb.put_chars = iox_$err_no_operation;
	iocbp -> iocb.get_chars = iox_$err_no_operation;
	iocbp -> iocb.get_line = iox_$err_no_operation;
	iocbp -> iocb.read_record = iox_$err_no_operation;
	iocbp -> iocb.write_record = iox_$err_no_operation;

	call iox_$propagate (iocbp);

	call hcs_$reset_ips_mask (mask, mask);

	return;

g115_get_chars: entry (a_iocbp, a_bufp, a_nelem, a_nelemt, a_code);

/* This is an entry to get the next record from an input message block.
   The data is written into a_bufp -> buffer without any G115 media codes or record separators.
   The calling procedure must add on a trailing NL char if desired.
*/

	a_code, code = 0;				/* be sure to initialize */
	iocbp = a_iocbp -> iocb.actual_iocb_ptr;
	adp = iocbp -> iocb.attach_data_ptr;
	device_data_p = g115_attach_data.device_ptr;

	if adp = null | device_data_p = null then do;
	     a_code = error_table_$not_attached;
	     return;
	end;

	if g115_device_data.hangup_signalled then do;	/* Illegal if we sent a hangup to the device */
	     a_code = error_table_$io_no_permission;
	     return;
	end;

	if g115_attach_data.device_type = printer |	/* not a readable device */
	g115_attach_data.device_type = punch then do;
	     a_code = error_table_$invalid_read;
	     return;
	end;

	call g115_protocol_$read (adp, device_data_p, a_bufp, a_nelem, a_nelemt, a_code); /* pass on read */

	return;

g115_put_chars: entry (a_iocbp, a_bufp, a_nelem, a_code);

/* This is an entry to write a record which may be a partial or complete G115 message block.
   The record format is a string of ASCII characters without any media code or record separator
   characters.  If the attachment is for the printer device, the last character of the input
   record is a slew control character.
*/

	a_code, code = 0;				/* be sure to initialize */
	iocbp = a_iocbp -> iocb.actual_iocb_ptr;
	adp = iocbp -> iocb.attach_data_ptr;
	device_data_p = g115_attach_data.device_ptr;

	if adp = null | device_data_p = null then do;
	     a_code = error_table_$not_attached;
	     return;
	end;

	if g115_device_data.hangup_signalled then do;	/* Illegal if we sent a hangup to the device */
	     a_code = error_table_$io_no_permission;
	     return;
	end;

	if g115_attach_data.device_type = reader then do;
	     a_code = error_table_$invalid_write;
	     return;
	end;


	call g115_protocol_$write (adp, device_data_p, a_bufp, a_nelem, a_code);

	return;

g115_modes: entry (a_iocbp, a_new_mode, a_old_mode, a_code);

	a_code, code = 0;				/* be sure to initialize */
	iocbp = a_iocbp -> iocb.actual_iocb_ptr;
	adp = iocbp -> iocb.attach_data_ptr;
	device_data_p = g115_attach_data.device_ptr;

	if adp = null | device_data_p = null then do;
	     a_code = error_table_$not_attached;
	     return;
	end;

	if g115_device_data.hangup_signalled then do;	/* Illegal if we sent a hangup to the device */
	     a_code = error_table_$io_no_permission;
	     return;
	end;

	a_old_mode = "";				/* initialize return string */

	if a_new_mode = "non_edited" then g115_attach_data.edited = "0"b;
	else if a_new_mode = "default" then g115_attach_data.edited = "1"b;
	else do;
	     modes.str = a_new_mode;
	     modes.len = length (modes.str);		/* set the max size for return info */
M_1:
	     call hcs_$tty_order (g115_device_data.devx, "modes", addr (modes), state, code);
	     if state ^= 5 then code = error_table_$io_no_permission;
	     if line_status_pending (code) then go to M_1;
	     a_old_mode = modes.str;			/* copy back the old value */
	end;

	a_code = code;

	return;

g115_control: entry (a_iocbp, a_order, a_infop, a_code);

	a_code, code = 0;				/* be sure to initialize */
	iocbp = a_iocbp -> iocb.actual_iocb_ptr;
	adp = iocbp -> iocb.attach_data_ptr;
	device_data_p = g115_attach_data.device_ptr;

	if adp = null | device_data_p = null then do;
	     a_code = error_table_$not_attached;
	     return;
	end;

	if g115_device_data.hangup_signalled then do;	/* Illegal if we sent a hangup to the device */
	     a_code = error_table_$io_no_permission;
	     return;
	end;

	order = a_order;				/* get the order name */
	infop = a_infop;				/* and the data pointer */

	if order = "io_call" then do;			/* check this first so we can redefine the order */

	     if infop = null then do;
bad_call:		a_code = error_table_$no_operation;	/* say we didn't do it */
		return;
	     end;

	     order = infop -> io_call_info.order_name;	/* get the new order name */
	     infop = null;				/* make this cheap, only a few orders accepted */
	end;

	if order = "hangup" then do;
	     dma.version = 1;			/* make structure for call to dial_manager_ */
	     dma.dial_mgr_ev_chan = g115_device_data.dial_mgr_ev_chan;
	     dma.device_name = g115_device_data.tty_name;
	     dma.dial_qual = "";

	     call ipc_$decl_ev_wait_chn (g115_device_data.dial_mgr_ev_chan, code);
						/* in case a hangup_proc order was given */
	     call dial_manager_$release_channel (addr (dma), code);
	     if code ^= 0 then
		call hcs_$tty_order (g115_device_data.devx, order, infop, state, (0)); /* pass it on */

	     g115_device_data.hangup_signalled = "1"b;	/* this will end all but close and detach */
	     code = 0;				/* say it was good, since they MUST close and detach */
	end;
	else if order = "select_device" then do;	/* order to set device type for next write */
	     if infop = null then go to bad_call;	/* this order requires this pointer */
	     if info_string = "teleprinter" then do;
		g115_attach_data.media_code = G115.teleprinter_mc;
	     end;
	     else if info_string = "punch" then do;

/*		g115_attach_data.media_code = G115.punch_bcd_mc; */
	     end;
	     else if info_string = "printer" then do;
		g115_attach_data.media_code = G115.printer_mc;
	     end;
	     else if info_string = "reader" then do;
		g115_attach_data.media_code = G115.bcd_input_mc; /* character only */
	     end;
	     else do;				/* not a legal value, tell the caller */
		code = error_table_$action_not_performed;
	     end;
	end;
	else if order = "runout" then do;
	     msgp = g115_device_data.outp (g115_device_data.level + 1); /* buffer we would write into */
	     if msgp = null then return;		/* in case it was not allocated yet */
	     if g115_message.text_char_count = 0 then return; /* make it fast if nothing to runout */

	     if ^g115_message.being_changed then	/* only write consistent messages */
		call g115_io_$write (device_data_p, msgp, code);

	     g115_message.text_char_count = 0;		/* mark this as written */
	     g115_message.fmt_code = ""b;
	     g115_message.being_changed = "0"b;

	     call timer_manager_$sleep ((g115_device_data.delay), "10"b);
	end;
	else if order = "hangup_proc" then do;
	     if infop = null then go to bad_call;	/* this order requires this pointer */
	     call ipc_$decl_ev_call_chn (g115_device_data.dial_mgr_ev_chan, hangup_proc.entry_var, hangup_proc.data_ptr,
		hangup_proc.prior, code);
	     if code ^= 0 then call convert_ipc_code_ (code);
	end;
	else if order = "reset" then do;
	     if g115_attach_data.device_type = punch then
		g115_attach_data.media_code = G115.punch_bcd_mc;
	end;
	else if order = "binary_punch" then do;
	     if g115_attach_data.device_type ^= punch then go to bad_call;
	     g115_attach_data.media_code = G115.punch_bin_mc; /* all future records will be binary coded */
	end;
	else if order = "read_status" then do;		/* order to get read status */
	     if infop = null then go to bad_call;	/* this order requires this pointer */
	     info_structure.ev_chan = g115_device_data.tty_ev_channel; /* return ev chn on which read will return */
	     info_structure.input_available = "0"b;	/* none yet */
	     msgp = g115_device_data.first_bp;		/* set auto reference ptr */
follow_chain:  if g115_message.rec_count > 0 then do;	/* input is ready */
		info_structure.input_available = "1"b;	/* go to it daemons */
		return;
	     end;
	     if g115_message.next_bp ^= null then do;	/* if a chain exists, check it out */
		msgp = g115_message.next_bp;
		go to follow_chain;
	     end;

	     call g115_io_$read_status (device_data_p, infop, code); /* check for any ring-0 data */
	end;
	else if order = "end_write_mode" then do;
	     call iox_$control (iocbp, "runout", null, code);
	     if code ^= 0 then return;
	     line_status.value = fnp_output_pending;
	     do while (line_status.value = fnp_output_pending);
C_1:		line_status.value = test_for_fnp_output;
		call hcs_$tty_order (g115_device_data.devx, "line_control", addr (line_status), state, code);
		if state ^= 5 then code = error_table_$io_no_permission;
		if line_status_pending (code) then go to C_1;
		call timer_manager_$sleep (1, "11"b);	/* give fnp a chance to digest line_control */
		call hcs_$tty_order (g115_device_data.devx, "line_status", addr (line_status), state, code);
		if state ^= 5 then code = error_table_$io_no_permission;
		if line_status_pending (code) then go to C_1;
		if line_status.value = fnp_output_pending then
		     call timer_manager_$sleep (10, "11"b);
	     end;
	end;
	else if order = "resetread" then do;
	     msgp = g115_device_data.first_bp;
	     bufp = g115_message.next_bp;		/* find next input buffer in chain */
	     unspec (g115_message) = "0"b;		/* clear out everything */
	     g115_message.next_bp = null;		/* mark as chain end */
	     g115_device_data.last_bp = msgp;		/*    "    "	*/
	     do while (bufp ^= null);
		msgp = bufp;
		bufp = g115_message.next_bp;		/* walk the chain */
		free msgp -> g115_message in (buffer_area); /* Poof, it's gone */
	     end;
C_2:	     call hcs_$tty_abort (g115_device_data.devx, 1, state, code);
	     if state ^= 5 then code = error_table_$io_no_permission;
	     if line_status_pending (code) then go to C_2;
	end;
	else if order = "resetwrite" then do;
	     msgp = g115_device_data.outp (g115_device_data.level);
	     g115_message.text_char_count = 0;
	     g115_message.fmt_code = "0"b;
C_3:	     call hcs_$tty_abort (g115_device_data.devx, 2, state, code);
	     if state ^= 5 then code = error_table_$io_no_permission;
	     if line_status_pending (code) then go to C_3;
	end;
	else if order = "set_remote_mode" then do;	/* order to tell control tables to act as L6 */
C_4:	     line_status.value = set_g115_remote_mode;	/* set the proper value */
	     call hcs_$tty_order (g115_device_data.devx, "line_control", addr (line_status), state, code);
	     if state ^= 5 then code = error_table_$io_no_permission;
	     if line_status_pending (code) then go to C_4;
	end;
	else if order = "reset_remote_mode" then do;	/* order to tell control tables to act as host */
C_5:	     line_status.value = reset_g115_remote_mode;
	     call hcs_$tty_order (g115_device_data.devx, "line_control", addr (line_status), state, code);
	     if state ^= 5 then code = error_table_$io_no_permission;
	     if line_status_pending (code) then go to C_5;
	end;
	else do;
C_6:	     call hcs_$tty_order (g115_device_data.devx, order, infop, state, code); /* pass it on */
	     if state ^= 5 then code = error_table_$io_no_permission;
	     if line_status_pending (code) then go to C_6;
	end;

	a_code = code;

	return;

g115_detach: entry (a_iocbp, a_code);			/* entry to detach device */

	a_code, code = 0;				/* be sure to initialize */
	iocbp = a_iocbp -> iocb.actual_iocb_ptr;
	adp = iocbp -> iocb.attach_data_ptr;
	device_data_p = g115_attach_data.device_ptr;

	if adp = null | device_data_p = null then do;
	     a_code = error_table_$not_attached;
	     return;
	end;

	if iocbp -> iocb.open_descrip_ptr ^= null then do;
	     a_code = error_table_$not_closed;
	     return;
	end;

	mask = "0"b;

	on any_other call any_other_handler;

	call hcs_$set_ips_mask ("0"b, mask);

	iocbp -> iocb.attach_descrip_ptr = null;

	call iox_$propagate (iocbp);

	g115_device_data.attach_count = g115_device_data.attach_count - 1; /* count down for detach */

	call cleanup_and_detach (a_code);

	call hcs_$reset_ips_mask (mask, mask);

	return;

as_init:	entry (a_devx, a_ddp, a_adp, a_code);

	if attach_areap = null then do;
	     call get_temp_segment_ ("g115_attach", attach_areap, a_code);
	     if a_code ^= 0 then return;
	     attach_area = empty;
	end;

	call create_device_data (device_data_p);	/* make a new block for AS */

	call init_g115_device_data (device_data_p, a_code);
	if a_code ^= 0 then return;

	g115_device_data.tty_name = "as_tty";		/* make up a dummy name for now */
	g115_device_data.devx = a_devx;
	g115_device_data.dial_mgr_ev_chan = 0;
	g115_device_data.tty_ev_channel = 0;
	g115_device_data.timeout_ev_channel = 0;
	g115_device_data.as_priv_no_block = "1"b;	/* this is the answering service! */

	allocate g115_attach_data in (attach_area) set (adp);

	g115_attach_data.media_code = G115.teleprinter_mc; /* answering service is only a teleprinter */
	g115_attach_data.device = "teleprinter";
	g115_attach_data.device_type = teleprinter;
	g115_attach_data.attach_description = "AS_direct_attach";
	g115_attach_data.open_description = "stream_input_output";
	g115_attach_data.device_ptr = device_data_p;
	g115_attach_data.terminal_type = "";
	g115_attach_data.kill_char = "@";
	g115_attach_data.erase_char = "#";
	g115_attach_data.ttt_bits = "1"b;
	g115_attach_data.ttt_ptrs = null;

	a_ddp = device_data_p;
	a_adp = adp;

	return;



as_detach: entry (a_devx, a_ddp, a_adp, a_code);

	adp = a_adp;
	device_data_p = a_ddp;

	free adp -> g115_attach_data in (attach_area);

	call release_temp_segment_ ("g115_io_buffer", g115_device_data.buffer_areap, a_code);

	call delete_device_data (device_data_p);	/* remove from the chain */

	return;

flip_comerr_sw: entry;

	static_comerr_sw = ^static_comerr_sw;		/* change the bit */

	call ioa_ ("g115_: Static com_err_ switch is ^[on^;off^]", static_comerr_sw);

	return;


cleanup_and_detach: proc (ec);

dcl  ec fixed bin (35);
dcl  ignore fixed bin (35);

	     if adp ^= null then
		free adp -> g115_attach_data in (attach_area);

	     if device_data_p ^= null then		/* check on deleting the device data */
		if g115_device_data.attach_count < 1 then do; /* no more streams attached, free block */
		     if ^g115_device_data.hangup_signalled then do; /* hang up the line if caller didn't */
			dma.version = 1;		/* make structure for call to dial_manager_ */
			dma.dial_mgr_ev_chan = g115_device_data.dial_mgr_ev_chan;
			dma.device_name = g115_device_data.tty_name;
			dma.dial_qual = "";

			call ipc_$decl_ev_wait_chn (g115_device_data.dial_mgr_ev_chan, ignore);
						/* in case a hangup_proc order was given */
			call dial_manager_$release_channel (addr (dma), ignore);
			if code ^= 0 then
			     call hcs_$tty_order (g115_device_data.devx, order, infop, state, ignore); /* pass it on */
		     end;
		     do chn = g115_device_data.tty_ev_channel, g115_device_data.timeout_ev_channel,
			     g115_device_data.dial_mgr_ev_chan;
			call ipc_$delete_ev_chn (chn, ignore);
		     end;

		     call hcs_$tty_detach (g115_device_data.devx, 0, state, ec);

		     call release_temp_segment_ ("g115_io_buffer", g115_device_data.buffer_areap, ignore);

		     call delete_device_data (device_data_p); /* remove from the chain */

		end;

	end cleanup_and_detach;



get_option_arg: proc (idx) returns (char (*) var);

/* this proc is used to do multiple tests and assignments within  a one line then clause of an if statement */

dcl  idx fixed bin;

	     idx = idx + 1;				/* bump the current option index, to find the option arg */
	     if idx > hbound (a_option, 1) then do;	/* still in range? */
		code = error_table_$noarg;		/* tell process it left out an arg */
		call abort_attach ("No argument after ", (a_option (i - 1)));
	     end;

	     attach_description = attach_description || " " || a_option (idx); /* include the arg in attach description */

	     return (a_option (idx));

	end get_option_arg;

abort_attach: proc (control_string, arg_value);		/* this proc handles attach errors */

dcl (control_string, arg_value) char (*) aligned;
dcl  saved_code fixed bin (35);

	     if comerr_sw then call com_err_ (code, "g115_", control_string, arg_value);

	     saved_code = code;			/* keep a copy */

	     call cleanup_and_detach (code);
	     if saved_code ^= 0 then code = saved_code;	/* use former reason if any */

	     go to attach_return;			/* non local transfer to finish off the abort */

	end abort_attach;



any_other_handler: proc;

/* this is the any_other handler to protect us while masked against IPS signals */

	     if mask then call hcs_$reset_ips_mask (mask, mask);
	     mask = ""b;

	     call continue_to_signal_ (code);

	     return;

	end any_other_handler;




clean_up_handler: proc;

/* this is the cleanup condition handler for errors during the attach entry */

	     call cleanup_and_detach (ignore);

	     return;

	end clean_up_handler;

init_g115_device_data: proc (ddp, ec);

dcl  ddp ptr;
dcl  ec fixed bin (35);
dcl  msgp ptr;
dcl  bp ptr;

	     ddp -> g115_device_data.tty_name = "";	/* let the main proc define this */
	     ddp -> g115_device_data.fmt_code.control = G115.special_nc;
	     ddp -> g115_device_data.fmt_code.data = G115.info_s_c; /* data will be compressed and split */
	     ddp -> g115_device_data.write_split, ddp -> g115_device_data.write_compress = "1"b; /* for easy test */
	     ddp -> g115_device_data.delay = 50000;	/* default to 50 msec for AS */
	     ddp -> g115_device_data.level = 0;		/* the write invocation level */
	     ddp -> g115_device_data.outp (*) = null;
	     ddp -> g115_device_data.process_id = get_process_id_ (); /* record our process id for wakeups */

/* make an area for allocation of input/output buffers */

	     call get_temp_segment_ ("g115_io_buffer", ddp -> g115_device_data.buffer_areap, ec);
	     if ec ^= 0 then return;

	     bp = ddp -> g115_device_data.buffer_areap;	/* get short pointer name */
	     bp -> buffer_area = empty;		/* initialize the area */

	     allocate g115_message in (bp -> buffer_area) set (ddp -> g115_device_data.template_ptr); /* OUTPUT buffer */

	     msgp = ddp -> g115_device_data.template_ptr; /* for easy structure reference */

/*		set up the template output buffer for speed later */

	     unspec (msgp -> g115_message) = "0"b;	/* set everything to zero */
	     msgp -> g115_message.next_bp = null;	/* output buffers are not chained */
	     msgp -> g115_message.soh = G115.soh_char;
	     msgp -> g115_message.addr_code = G115.addr_code_char;
	     msgp -> g115_message.op_code.use = "1"b;
	     msgp -> g115_message.id_code = G115.id_code_char;
	     msgp -> g115_message.stx = G115.stx_char;
	     msgp -> g115_message.etx = G115.etx_char;

	     allocate g115_message in (bp -> buffer_area) set (ddp -> g115_device_data.first_bp); /* INPUT buffer */

	     msgp, ddp -> g115_device_data.last_bp = ddp -> g115_device_data.first_bp; /* set the chain */
	     unspec (msgp -> g115_message) = "0"b;	/* make it clean */
	     msgp -> g115_message.next_bp = null;

	     return;

	end init_g115_device_data;

create_device_data: proc (ddp);

/* this proc allocates a copy of g115_device_data and threads it into the list */

dcl  ddp ptr;

	     allocate g115_device_data in (attach_area) set (ddp);

	     unspec (ddp -> g115_device_data) = "0"b;	/* set everything to zero */

	     ddp -> g115_device_data.back_ptr = last_device_data_p; /* point back to previous tail */
	     ddp -> g115_device_data.fwd_ptr = null;	/* this is the new tail of the chain */
	     if last_device_data_p ^= null		/* if tail already exists */
	     then last_device_data_p -> g115_device_data.fwd_ptr = ddp; /* link it to this block */
	     else first_device_data_p = ddp;		/* otherwise start the chain */
	     last_device_data_p = ddp;		/* record the new tail */

	     return;

delete_device_data: entry (ddp);

/* this entry removes a link in the chain and frees the data block */

	     if ddp -> g115_device_data.back_ptr = null then /* was this the head of the chain? */
		first_device_data_p = ddp -> g115_device_data.fwd_ptr; /* make the next one the head */
	     else ddp -> g115_device_data.back_ptr -> g115_device_data.fwd_ptr = ddp -> g115_device_data.fwd_ptr;
						/* move our fwd ptr to previous block */

	     if ddp -> g115_device_data.fwd_ptr = null then /* was this the tail of the chain */
		last_device_data_p = ddp -> g115_device_data.back_ptr; /* make previous the new tail */
	     else ddp -> g115_device_data.fwd_ptr -> g115_device_data.back_ptr = ddp -> g115_device_data.back_ptr;
						/* move our back ptr to next block */

	     free ddp -> g115_device_data in (attach_area);

	     ddp = null;				/* just to be sure */

	     return;

	end create_device_data;

line_status_pending: proc (ec) returns (bit (1));

dcl  ec fixed bin (35);

/* this proc returns true if there was a line status code and we cleared the line, ready for a retry */

	     if ec = 0 then return ("0"b);		/* avoid a loop for normal case */

	     do while (ec = error_table_$line_status_pending);
		call hcs_$tty_order (g115_device_data.devx, "line_status", addr (line_status), state, ec);
		if state ^= 5 then ec = error_table_$io_no_permission;
	     end;

	     if ec = 0 then return ("1"b);		/* OK to retry */

	     return ("0"b);				/* Do not retry */

	end line_status_pending;




     end g115_;
