/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   *********************************************************** */
gcos_mme_inos_: proc (mcpp, increment);

/*
   *  This procedure processes the I/O MME, GEINOS. The GEINOS calling sequence(s) are:
   *  Also contains code to process the GEENDC MME.
   *
   *			MME GEINOS
   *			OPERATION WORD
   *			IDENTIFICATION WORD
   *			RETURN WORD
   *
   *			or.....
   *
   *			MME GEINOS
   *			OPERATION WORD 1
   *			IDENTIFICATION WORD 1
   *			OPERATION WORD 2
   *			IDENTIFICATION WORD 2
   *			RETURN WORD
   *
   *			where:
   *
   *		OPERATION WORD FORMAT =
   *
   *			BITS	USE
   *			0-5	Device Command [cc] (See values below)
   *			6-17	Zeros
   *			18-22	IOC Command [ii]
   *			23	Zero
   *			24-29	Control
   *			30-35	Count [nn]
   *
   *		Operation word (GMAP oct implementation):
   *			8	16
   *			oct	cc0000ii00nn
   *
   *		IDENTIFICATION WORD FORMAT =
   *
   *			BITS	USE
   *			00-17	File Control Block Pointer
   *			18-35	Dcw List Pointer
   *
   *		RETURN WORD FORMAT =
   *
   *			BITS	USE
   *			0-17	Status Return Pointer
   *			18-35	Courtesy Call Address
   *
   *		DCW FORMAT
   *
   *			BITS	USE
   *			0-17	Data Address
   *			18-20	Zero
   *			   21	Character tally flag.
   *			22-23	Action Code (See values below)
   *			24-35	Count (value of zero indicates count of 4096)
   *
   *		DCW ACTION CODES
   *
   *			CODE	MEANING
   *			00	(IOTD) Transfer and Disconnect (this is last DCW in list)
   *			01	(IOTP) Transfer and Continue (with next DCW in list)
   *			10	(TDCW) Skip to New DCW List (whose address is in Data Address)
   *			11	(IONTP) Skip Data Transfer (skip words and continue with next DCW in list)
   *
   *		OPERATION WORD DEVICE COMMANDS [cc]
   *
   *			CODE	MEANING
   *
   *			00	Request Status
   *
   *			03	Read Typewriter
   *			04	Read Tape Decimal
   *			05	Read Tape Binary
   *
   *			13	Write (then Read) Typewriter
   *			14	Write Tape Decimal
   *				(and Write Filemark Decimal, when IOC command = "00100"b)
   *			15	Write Tape Binary
   *				(and Write Filemark, when IOC command = "00100"b)
   *
   *			25	Read
   *
   *			30	Write Printer Edited
   *			31	Write
   *
   *			34	Seek
   *
   *			40	Reset Status
   *
   *			41	Set 6250 Density
   *			42	Set 800 Density
   *			43	Set 556 Density
   *			44	Forward Space Record
   *			45	Forward Space to Filemark
   *			46	Backspace Record
   *			47	Backspace to Filemark
   *
   *			54	Erase
   *			55	Write EOF
   *
   *			60	Set High Density
   *			61	Set Low Density
   *			64	Set 200 Density
   *			65	Set 1600 Density
   *
   *			70	Rewind
   *			72	Rewind and Unload
   *
   *
*/
%page;
/*
   Author: DICK SNYDER OCTOBER 7, 1970
   Change: T. CASEY, OCTOBER 1973, DECEMBER 1973, AUGUST 1974
   Change: D. KAYDEN, MARCH 1974, APRIL 1974, JULY 1974, DECEMBER 1974, MARCH 1975
   Change: R.H. MORRISON  FEB 2, 1976
   Change: M. R. Jordan, September 1976
   Change: A. N. Kepner, March 1978 to allow courtesy call i/o  within cc routines
   Change: Dave Ward	05/20/81 multirecord read/write disk, various bugs.
   Change: Dave Ward	09/02/81 Removed use of cmd_word variable.
   Change: Dave Ward	09/02/81 provided tape density 6250.
   Change: Dave Ward	09/16/81 removed use of init (except for constant).
   Change: Scott C. Akers	12/23/81 Fix bugs which arise when dealing with
			         discontiguous DCWs and stuff.

   Change: Ron Barstad        01/27/83 Rewrite tape status checking. The
                                       old version was checking tally residues
                                        and IOM Central statuses, mistaking
                                       them for handler status.

   Change: Ron Barstad  83-07-01  Fix bug in writting multi-records to a non-randon file
   Change: Ron Barstad  83-08-03  Fix courtesy call queue to work like GCOS
*/
%page;
dcl  increment                fixed bin (24)parm;		/* number of words MME processor
						   must skip over */
dcl  mcpp                     ptr parm			/* pointer to machine conditions. */;
	mcp = mcpp;
	increment = 3;				/* init parameter skip number */
	gseg = gcos_ext_stat_$gcos_slave_area_seg;	/* pointer to slave program */
	storlimit = gcos_ext_stat_$storage_limit;	/* slave core boundary */
	trace_or_stopsw = dbs_mme_inos_trace | dbs_mme_inos_stop;

	scup = addr (mc.scu);			/* get ptr to scu data */
	i = instruction_counter + 2;			/* get offset of first id word */
	idptr = addrel (gseg, i);			/* build pointer to id word */

	if id_word.filep >= storlimit then		/* file control block ptr */
	     call gcos_mme_bort_$system (
	     gcos_et_$invalid_file_ptr
	     , "File code pointer in GEINOS sequence is outside slave limits."
	     );

	workp = addrel (gseg, id_word.filep);		/* get pointer to fcb */
	substr (fc, 1, 1) = xlate (fixed (substr (file_code_word.fcode, 1, 6))); /* translate file code */
	substr (fc, 2, 1) = xlate (fixed (substr (file_code_word.fcode, 7, 6))); /* to ascii */

	if fc = "  " 				/* a blank file code is illegal */
	then call gcos_mme_bort_$system (gcos_et_$fc_not_defined,
				   "Blank file code is illegal.");

	call init_routine;				/* Initialize variables. */

/* Now we see if we have a legal file code. The variable "j" gets set. */

	if fc = "*t" | fc = "t/" | fc = "/t"		/* See if it's the operator's console. */
	then fc = "t*";

	if ^match_fc ()				/* If we didn't find a match,
						   we bail out. */

	then call gcos_mme_bort_$system (gcos_et_$fc_not_defined,
				        """^a""", fc);

	if fct.sysout (j) then			/* abort if sysout file */
	     call gcos_mme_bort_$system (
	     gcos_et_$fc_not_defined
	     , "File code ""^a"" is assigned to SYSOUT."
	     , fc
	     );

	fibptr = fct.fibptr (j);			/* copy pointer to fib */

	call process_request;			/* Go do the dirty work. */
%page;
com_proc (01): ;

/* disk or drum seek */
	seeksw = "1"b;				/* Indicate seek has been performed. */
	if fib.type = random_file then do;		/* (no seek necessary for sequential file) */
	     if dcw_offset >= storlimit then		/* dcw addr OOB? */
		call gcos_mme_bort_$system (
		gcos_et_$invalid_dcw_ptr
		, "DCW is outside slave limits."
		);

	     dcwptr = addrel (gseg, dcw_offset);	/* get address of dcw */
	     if dcw.data_addr >= storlimit		/* data address OOB? */
	     | dcw.count ^= 1 then			/* count not 1 ? */
		call gcos_mme_bort_$system (
		gcos_et_$bad_seek_dcw
		, "DCW address field is outside slave limits or DCW word count is not 1."
		);

	     i = addrel (gseg, dcw.data_addr) -> seek_address; /* grab seek address */
	     fib.current = i*64;			/* multiply by block size */
	     if trace_or_stopsw then call ioa_ ("seek ^w", i);
	end;

bump:	;

	increment = increment + 2;			/* prepare for following command */
	idptr = addrel (idptr, 2);			/* get ptr to new id word */
	call process_request;			/* Do the next command. */
%page;
com_proc (02): ;

/* read disk continuous */

	if fib.read = "0"b then do;			/* Reads are not allowed on this file. */
	     if fib.null then do;			/* If this a null file */
		substr (slave_status, 3, 4) = "1111"b;	/* return eof status. */
		goto return_stat;
	     end;
	     call gcos_mme_bort_$system (
		gcos_et_$impermissible_perm_read
		, "No read permission on file ""^a""."
		, fc
		);
	end;

	if fib.order = write_file then do;		/* If last i/o request was a write, then */
	     fib.order = read_file;			/* we must bring ios_'s seek pointers together */
	     goto seek;
	end;

	if fib.type = random_file then do;		/* Seek only if file is random. */
seek:	     ;
	     if seeksw = "0"b then			/* read or write must be preceded by a seek */
		call gcos_mme_bort_$system (
		gcos_et_$bad_io_cmnd_file
		, "Disk ^[read^;write^] without a seek on file ""^a""."
		, fib.order = read_file
		, fc
		);
	     call do_seek;
	end;
	if fib.type ^= random_file then		/* Linked file. */
	call check_multirecord_request (mr);
	goto loop;

com_proc (03): ;

/* write disk continuous */

	if fib.write = "0"b then do;			/* write not allowed ? */
	     if fib.null then goto return_stat;		/* is this a null file ? */
	     call gcos_mme_bort_$system (
		gcos_et_$impermissible_perm_write
		, "No write access to file ""^a""."
		, fc
		);
	end;

	if fib.order = read_file then do;		/* if last i/o request was a read, then */
	     fib.order = write_file;			/* we must bring ios_'s seek pointers together */
	     goto seek;
	end;
	if fib.type = random_file then goto seek;
	call check_multirecord_request (mr);

/* transfer to loop. */
%page;
/* Read and write processing. */

loop:	;

/* Call a subroutine which examines the dcw list and returns the
   number of contiguous words to transmit (count), the address to
   transmit from/to (where), and an indicator saying whether
   there are more dcws to be processed (continue).
*/
	call get_dcw;

	if fib.type = linked_file then do;		/* Linked file on disk. */
	     if fib.order = read_file then		/* sequential file read */
		if fib.current >= fib.last then do;	/* check for end of valid data */
		     substr (slave_status, 3, 4) = "1111"b; /* set eof status */
		     wc_residue = count;
		     da_residue = where;
		     goto return_stat;
		end;

	     if mr = "0"b then			/* Not a multirecord request. */
		if (count + total_count) > 320 then do; /* About to exceed 1 block. */
		     wc_residue = count + total_count - 320;
		     continue = "0"b;
		     count = max (0, 320 - total_count); /* Adjust count to finish to 1 block. */
		end;
	end;

	fib.current = fib.current + count;		/* Calculate next position in the file. */

	if fib.current > fib.size then goto disk_eof;	/* will i/o go over eof ? */

/* If get_dcw returns a where value of -1, this means that a skip
   DCW (IONTP) has been encountered. In this case, the proper
   pointer will be advanced by the value in count, an the next
   DCW is obtained.
*/

	if where = -1 then do;			/* => Skip DCW (IONTP). */
	     if fib.type = linked_file then
		if fib.order = write_file then do;	/* Fill block with zeroes. */
		     if count < 1 then nelemt = 0;
		     else
		     call ios_$write (
			fib.stream
			, addr (z320)
			, 0			/* offset to 1st word of z320. */
			, count			/* Number words to write. */
			, nelemt			/* (output) number of words written. */
			, status
			);
		     goto complete;
		end;
	     if count > 0 then
		call do_seek;
	end;
	else do;					/* Data movement DCW (IOTP or IOTD). */

issue:	     ;

	     if fib.order = write_file then
		call ios_$write (
		fib.stream
		, gseg
		, where
		, count
		, nelemt
		, status
		);
	     else
	     call ios_$read (
		fib.stream
		, gseg
		, where
		, count
		, nelemt
		, status
		);

complete:	     ;

	     total_count = total_count + nelemt;	/* Update count total. */
	     if fib.tape then goto tape_stat;
	     if code ^= 0 then do;
fail_loop:	;
		call gcos_mme_bort_$system (
		     code
		     , "Fatal ^[read^;write^] error on ^[random^;linked^]  file ""^a""."
		     , fib.order = read_file
		     , fib.type = random_file
		     , fc
		     );
	     end;
	     if fib.order = write_file then fib.last = max (fib.last, fib.current); /* update last pointer */
	     da_residue = where + count;
	end;
	if continue then goto loop;

/* Complete the i/o operation. */
	if fib.type = linked_file then		/* Final positioning. */
	     if mr = "0"b then			/* Not multirecord request. */
		if total_count < 320 then do;
		     fib.current = fib.current + (320 - total_count);
		     if fib.order = write_file then do; /* Fill block with zeroes. */
			call ios_$write (
			     fib.stream
			     , addr (z320)
			     , 0			/* 1st word of z320. */
			     , 320-total_count	/* Number words to write. */
			     , nelemt		/* (output) number of words written. */
			     , status
			     );
			if code ^= 0 then goto fail_loop;
			if fib.order = write_file then fib.last = max (fib.last, fib.current); /* update last pointer */
		     end;
		     else				/* => linked file read. Position to block. */
		     call do_seek;
		end;
	goto return_stat;
%page;
com_proc (04): ;

/* rewind disk/drum */

	if fib.print then goto return_stat;		/* temporary fix until sysout is working */
	if fib.null then goto return_stat;		/* is this a null file ? */

	fib.current = 0;				/* reset position */

	goto disk_posit;
%page;
com_proc (05): ;

/* backspace disk/drum */

	bksp_sw = "1"b;				/* remember backspace */


bksp_share: ;

	if fib.type = random_file then		/* abort if random */
	     call gcos_mme_bort_$system (
	     gcos_et_$bad_io_cmnd_file
	     , "Attempt to backspace/forward space random file ""^a""."
	     , fc
	     );
	if fib.null then goto return_stat;		/* is this a null file ? */

	j = op_word.count;
	if j = 0 then j = 64;			/* zero count means 64 */
	j = 320*j;
	if bksp_sw then j = -j;

	fib.current = fib.current + j;
	if fib.current < 0 then fib.current = 0;	/* allow for backspace too far */
	if fib.current > fib.size then do;		/* check for end of file */


disk_eof:	     ;

	     if fib.type = random_file then		/* end of file on a random file */
		call gcos_mme_bort_$system (
		gcos_et_$access_beyond_file
		, "Positioning to ^i on random file ""^a"" exceeds size ^i."
		, fib.current
		, fc
		, fib.size
		);
	     substr (slave_status, 3, 4) = "1111"b;	/* Is this the proper status ? */

	     rec_ct_residue = divide (fib.current - fib.size, 320, 17, 0);
	     substr (slave_status, 31, 6) = substr (unspec (rec_ct_residue), 31, 6);

	     fib.current = fib.size;

	end;


disk_posit: ;

	call do_seek;

	goto return_stat;				/* process status */
%page;
com_proc (06): ;

/* forward space disc/drum */

	bksp_sw = "0"b;				/* remember forward space */

	goto bksp_share;				/* now go share backspace code */
%page;
com_proc (07): ;

/* reset status for disk/drum */

	goto return_stat;
%page;
com_proc (08): ;

/* request status for disk/drum */

	goto return_stat;
%page;
com_proc (09): ;					/* read tape binary */

	error_retry = "0"b;
	total_read = 0;				/* Haven't read anything first time through. */
	fib.order = read_file;			/* indicate read to be done */
	if   fib.mode ^= "00"b
	then do;
	     fib.mode = "00"b;
	     order = "binary";
	     call ios_$order (fib.stream, order, null, status);
	     end;

	more_dcws = "1"b;
	do   while (more_dcws);
	     call next_dcw_ptr (output_ptr, transfer_count, more_dcws);
	     call ios_$read (fib.stream, output_ptr, 0, transfer_count, nelemt, status);

	     total_read = total_read + nelemt;
	     da_residue = dcw.data_addr + nelemt;
	     wc_residue = transfer_count - nelemt;

	     end;
	goto tape_status;
%page;
com_proc (10): ;					/* write tape binary */

	fib.order = write_file;			/* indicate write to be done */

	if fib.mode = "00"b then goto mode_set;		/* mode already binary? */
	fib.mode = "00"b;				/* set mode to binary */
	order = "binary";				/* set up to change mode */

mode_order: ;
	call ios_$order (fib.stream, order, null, status); /* change tape mode */

mode_set:	;
	call get_dcw;				/* get dcw */
	error_retry = "0"b;				/* not doing error recovery */
	if where >= 0 then
	     if continue = "0"b then goto issue;	/* avoid  overhead of extra buffering if possible */

	sc_ga = "1"b;				/* remember for possible error recovery */
	if fib.buffer = null then
	     fib.buffer = addr (tapebuffer);

	if fib.order = read_file then do;

sc_read:	     ;
	     call ios_$read (fib.stream, fib.buffer, 0, 1632, nelemt, status);
	     call adjust_buffer (fib.buffer);

	     call scatter_input (fib.buffer);		/* send any data to slave, even if tape error */
	end;
	else do;					/* Write tape. */
	     posit = 0;				/* init fib.buffer position */

ga_loop:	     ;
	     if where >= 0				/* skip dcw ? */
	     then do;
		ibuffptr = addrel (fib.buffer, posit);	/* pointer to intermediate fib.buffer */
		sbuffptr = addrel (gseg, where);	/* pointer to slave fib.buffer */
		internal_buffer = slave_buffer;	/* move data */
		posit = posit + count;		/* adjust intermediate fib.buffer position */
		end;
	     if continue				/* more to do ? */
	     then do;
		call get_dcw;
		goto ga_loop;
		end;

	     da_residue = where + count;		/* data address residue */
	     wc_residue = 0;			/* word count residue */

	     call ios_$write (fib.stream, fib.buffer, 0, posit, nelemt, status); /* write gathered output */
	end;
	goto tape_status;				/* done - now process status */

%page;
com_proc (11): ;

/* read tape nine */

	fib.order = read_file;			/* indicate read to be done */


asa9_common: ;

	if fib.mode = "10"b then goto mode_set;		/* already in asa9 mode? */

	fib.mode = "10"b;				/* set mode to decimal */
	order = "nine";				/* prepare to make order call */

	goto mode_order;
%page;
com_proc (12): ;

/* write tape nine */

	fib.order = write_file;			/* indicate write to be done */

	goto asa9_common;
%page;
com_proc (13): ;

/* rewind */

	order = "rewind";
	goto order_call;
%page;
com_proc (14): ;

/* write eof */

	order = "eof";
	goto order_call;
%page;
com_proc (15): ;

/* forward space file */

	order = "forward_file";
	goto order_call;
%page;
com_proc (16): ;

/* backspace file */

	order = "backspace_file";
	goto order_call;
%page;
com_proc (17): ;

/* forward space record */

	order = "forward_record";
	goto order_loop;
%page;
com_proc (18): ;

/* backspace record */

	order = "back";


order_loop: ;

	i = op_word.count;				/* pick up skip count */
	if i = 0 then i = 64;			/* count of 0 means 64 */

	do j = 1 to i;				/* loop to skip */
	     call ios_$order (fib.stream, order, null, status); /* issue a skip order */
	     if code ^= 0 then do;			/* stop if any problems */
		rec_ct_residue = i-j;		/* compute count of no of skips left */
		goto tape_status;
	     end;
	end;

	goto tape_status;				/* process status */
%page;
com_proc (19): ;

/* write file mark binary */

	goto com_proc (14);
%page;
com_proc (20): ;

/* write file mark decimal */

	goto com_proc (14);
%page;
com_proc (21): ;

/* erase */

	order = "erase";
	goto order_call;
%page;
com_proc (22): ;

/* rewind and unload */

	order = "unload";
	goto order_call;
%page;
com_proc (23): ;

/* set high density */

	order = "high";
	density_history = "01"b ;
	goto tape_high_low;
%page;
com_proc (24): ;

/* set low density */

	order = "low";
	density_history = "00"b ;


tape_high_low: ;

	if fib.density = "0000"b then goto set_density;	/* means "as is" */
	if fib.density = "1111"b then do;		/* use system default densities */
	     if order = "high" then order = default_high;
	     else order = default_low;
	     goto set_density;
	end;

	if fib.density = "0010"b then goto com_proc (26);
	if fib.density = "0100"b then goto com_proc (27);
	if fib.density = "1001"b then goto com_proc (28);
	if fib.density = "1100"b then goto com_proc (41);
%page;
com_proc (25): ;

/* set 200 density */

	order = "d200";
	density_history = "10"b ;
	goto set_density;
%page;
com_proc (26): ;

/* set 556 density */

	order = "d556";
	density_history = "00"b ;
	goto set_density;
%page;
com_proc (27): ;

/* set 800 density */

	order = "d800";
	density_history = "01"b ;
	goto set_density;
%page;
com_proc (28): ;

/* set 1600 density */

	order = "d1600";
	density_history = "11"b ;

set_density: ;

	call ios_$order (fib.stream, order, null, status);
	if code = 0 then fib.dens_hist = density_history; /* change history bits only if order was successful */
	goto tape_status;
%page;
com_proc (41): ;

/* set 6250 density */

	order = "d6250";
	density_history = "00"b ;
	goto set_density;
%page;
com_proc (29): ;

/* reset status */

	order = "reset_status";
	override = 1;


order_call: ;

	call ios_$order (fib.stream, order, null, status);

	goto tape_status;
%page;
com_proc (30): ;

/* request status */

	call ios_$order (fib.stream, "request_status", addr (slave_status), status);
	override = 1;

	goto tape_status;
%page;
com_proc (31): ;

/* read tape bcd */

	fib.order = read_file;			/* indicate read to be done */


bcd_common: ;

	if fib.mode = "01"b then goto mode_set;		/* already in bcd mode? */

	fib.mode = "01"b;				/* set mode to bcd */
	order = "bcd";				/* prepare to make order call */

	goto mode_order;
%page;
com_proc (32): ;

/* write tape bcd */

	fib.order = write_file;			/* indicate write to be done */

	goto bcd_common;
%page;
com_proc (33): ;

/* write printer edited */

	n = 1;


write_prt: ;

	do i = 1 to n;


get_prt_dcw:   ;

	     call get_dcw;
	     if where < 0 then goto get_prt_dcw;	/* skip dcw ? */
	     if count > 27 then do;
		if count = 4096 then goto print_skip;
		count = 27;
	     end;
	     j = count*4;				/* compute length of char */
						/* string overlay		 */
	     call gcos_write_$bcd_ptr (fibptr, addrel (gseg, where) -> record,
		"11111100"b);			/* put on file */


print_skip:    ;

	     if continue then goto get_prt_dcw;

	end;

	goto return_stat;				/* return good status */
%page;
com_proc (34): ;

/* write printer edited continuous */

	n = op_word.count;				/* get record count */
	if n = 0 then n = 64;
	goto write_prt;
%page;
com_proc (35): ;

/* reset status */

	goto return_stat;
%page;
com_proc (36): ;

/* request status */

	goto return_stat;
%page;
com_proc (37): ;

/* write console */

	ascii_index = 0;				/* init line index for possible multi-dcw list */


type_loop: ;					/* come here for all dcws after the first */

	call get_dcw;				/* analyze dcw */

	if where = -1 then goto type_loop;		/* if this dcw said skip data, do it */

	workp = addrel (gseg, where);			/*  get pointer to string to write */

	do i = 1 to count*6;

	     if bcd_string (i) = "77"b3 then do;	/* escape */
		i = i+1;
		if bcd_string (i) = "77"b3 then do;	/* escape */
		     i = i+1;
		     if bcd_string (i) = "77"b3 then char = "!";
		     else
		     if bcd_string (i) = "17"b3 then char = "?";
		     else
		     if bcd_string (i) = "20"b3 then do;
			substr (ascii_string, ascii_index, 3) = "/b";
			ascii_index = ascii_index + 3;
			goto skip_fill;
		     end;
		     else do;
			substr (slave_status, 3, 10) = "0011010000"b; /* incorrect format */
			goto type_it;		/*  send the good part */
		     end;
		     goto end_loop;
		end;

		j = fixed (bcd_string (i));		/* get carriage control char */
		if j < 32 then unspec (char) = "012"b3; /* put newline in string */
		else unspec (char) = "011"b3;		/* put tab in string */
		goto end_loop;
	     end;

	     if bcd_string (i) = "17"b3 then goto skip_fill; /* if not fill char */
	     char = xlate (fixed (bcd_string (i)));	/* put ascii equivalent in string */


end_loop:	     ;

	     ascii_index = ascii_index+1;		/* increment ascii output string index */
	     substr (ascii_string, ascii_index, 1) = char; /* stuff char into string */


skip_fill:     ;

	     if ascii_index > 129 then goto type_it;	/* check for too much output */

	end;

	if continue then goto type_loop;		/* if more dcws, go process them */


type_it:	;

	if ascii_index > 0 then			/* type line and test for write-then-read */
	     call ios_$write_ptr (addr (ascii_string), 0, ascii_index); /* print output */

	if op_word.count = 2 then goto bump;		/* test for write then read */
	goto return_stat;				/* go return status */
%page;
com_proc (38): ;

/* read console */

	call get_dcw;				/* analyze dcw */

	call ios_$read_ptr (addr (ascii_string), 132, i); /* read a line from tty */
	i = i - 1;				/* strip off NL */
	if i > 0 then				/* check for null response */
	     call gcos_cv_ascii_gebcd_ (addr (ascii_string), i, addr (mybuf), i); /* convert to bcd */
						/* don't attempt to convert null string */
	nelemt = divide (i+5, 6, 17, 0);		/* compute word and character residues */
	cc_residue = mod (i, 6);
	call scatter_input (addr (mybuf));
	goto return_stat;
%page;
com_proc (39): ;

/* reset status */

	goto return_stat;
%page;
com_proc (40): ;

/* request status */

	goto return_stat;
%page;
tape_stat: ;

	if fib.order = read_file then call adjust_buffer (addrel (gseg, where)); /* adjust fib.buffer on input */

	wc_residue = count - nelemt;
	da_residue = where + nelemt;


tape_status:	;



	if   ^substr (unspec (status), 1, 1)		/* Are we expected to interpret
						/* a Multics error code? */
	then do;
	     if   code = 0
	     then go to return_stat;			/* everything ok */
	     else call gcos_mme_bort_$system (code, "fc=""^a""", fc);
	     end;

	substr (slave_status, 1, 12) =   "10"b
				 ||substr (unspec (status), 27, 10);  /* copy major/minor status */
	substr (slave_status, 31, 6) = substr (unspec (rec_ct_residue), 31, 6); /* copy any residue from skip op */

	if trace_or_stopsw then call ioa_ ("status:^-^w", slave_status);

	major_status = substr (unspec (status), 27, 4);	/* Get major and minor status */
	minor_status = substr (unspec (status), 31, 6);
	
	if   major_status = "0000"b			/* Device Ready */
	   | major_status = "0100"b			/* EOF */
	then goto return_stat;

	if   major_status = "1001"b			/* Device busy */
	   & minor_status = "000000"b			/* Command Accepted */
	then goto return_stat;
	

	if ^error_retry then			/* if not already attempting error recovery, */
	     fib.error_retry = fib.error_retry + 1;	/* then count tape errors */

	call make_stat_ptr;				/* we need pointer to status words */
	if override = 0 then
	     if substr (sw1, 1, 33) = (33)"1"b then	/* error recovery override requested */
		override = - (addr (sw1) -> fb35);	/* remember type */

	if   override = 1				/* normal status override */
	   | override = 5				/* override all except mpc statuses */
	then  go to return_tape_stat;

	if   major_status = "0001"b			/* Device Busy */
	   | major_status = "0010"b			/* Device Attention */
	then goto epabort;

	if   major_status = "0101"b			/* Command Reject */
	then do;
	     if   (minor_status & "001000"b) = "001000"b	/* Tape on Load Point */
	     then goto return_tape_stat;
	     else goto epabort;			/* Other cmd rejects are illegal */
	     end;

	if   major_status ^= "0011"b
	then go to epabort;				/* If not Data Alert, abort */

	if   (minor_status & "000011"b) = "000011"b	/* Bit During Erase */
	then goto epabort;

	if   override = 3
	then goto return_tape_stat;			/* override case 2 */

	if   (minor_status & "000010"b) = "000010"b	/* Blank Tape on Read */
	   | (minor_status & "100000"b) = "100000"b	/* End of Tape */

	then goto return_tape_stat;

	if   (minor_status & "000001"b) = "000001"b	/* Transfer Timing Alert */
	   | (minor_status & "000100"b) = "000100"b	/* Transmission Parity Alert */

	then goto epabort;

/* 	We must have a parity error of some type */


	if override = 2 then go to return_tape_stat;	/* override parity errors */

	if ^error_retry then retry_count = 11;
	error_retry = "1"b;				/* set switch to indicate we are processing error */
	retry_count = retry_count-1;			/* decrement retry attempt count */
	if retry_count = 0 then go to epabort;		/* abort if we still have */
						/* parity error after 10 retries */

	slave_status = "400000000000"b3;		/* reinitialize status for retry */

	if override ^= 4 then			/* check for bypass noise check */
	     if fib.order = read_file then
		if nelemt < 4 then
		     if nelemt > 0 then		/* noise record */
			if sc_ga then goto sc_read;
			else goto issue;

	call ios_$order (fib.stream, "back", null, status); /* backspace tape */

	if fib.order = write_file then
	     if retry_count ^= 10 then		/* on a write, retry same spot once */
		call ios_$order (fib.stream, "erase", null, status); /* then erase bad spot on tape */

	if sc_ga = "0"b then goto issue;
	else
	if fib.order = write_file
	then do;					/* write gathered output */
	     call ios_$write (fib.stream, fib.buffer, 0, posit, nelemt, status);
	     goto tape_status;			/* done - now process status */
	     end;

	else goto sc_read;


epabort:	;

	call gcos_mme_bort_$system (
	     gcos_et_$irrecoverable_io_err
	     , "Fatal tape I/O error on file ""^a"".  Status = ^w."
	     , fc
	     , slave_status
	     );
%page;
return_stat: ;

	call make_stat_ptr;


return_tape_stat: ;

	sw1 = slave_status;				/* move status into slave */
	sw2 = "0"b;

	substr (sw2, 1, 18) = substr (unspec (da_residue), 19, 18); /* and data address residues */
	if cc_residue ^= 0 then			/* check for character residue */
	     substr (sw2, 19, 3) = substr (unspec (cc_residue), 34, 3); /* we have some */
	substr (sw2, 22, 1) = (fib.order = read_file);	/* Last order was a read. */
	substr (sw2, 23, 2) = type_dcw;		/* Type of last DCW. */
	substr (sw2, 25, 12) = substr (unspec (wc_residue), 25, 12); /* return word count */
	if trace_or_stopsw then call ioa_ ("status ^w ^w", sw1, sw2);

	fib.iocount = fib.iocount + 1;		/* count I/O requests completed */

	if return_word.courtesy_call = 0 then return;	/* done if no courtesy call */

	if gcos_ext_stat_$save_data.cc then do;		/* Already in courtesy call */

/* Check courtesy call queue for overflow */
	     new_next_avail =
		mod (courtesy_call.next_avail, hbound (courtesy_call.queue, 1))+1;
	     if courtesy_call.next_out = new_next_avail then
		call gcos_mme_bort_$system (
		gcos_et_$bad_mme_in_cc
		, "Maximum of ^i simultaneous outstanding courtesy calls has been exceeded."
		, hbound (courtesy_call.queue, 1)-1
		);

/* Add cc address to queue */
	     courtesy_call.queue (courtesy_call.next_avail) =
		return_word.courtesy_call;
	     courtesy_call.next_avail = new_next_avail;
	end;
	else do;					/* Not in courtesy call yet. */
	     gcos_ext_stat_$save_data.cc = "1"b;	/* indicate that courtesy call in progress */


/* Save machine conditions and increment value for return to the caller of	 */
/* MME GEINOS when the MME GEENDC is executed. Put courtesy call address		 */
/* in increment to cause control to go to courtesy call routine.		 */

	     gcos_ext_stat_$increment_hold = increment;	/* save increment */
	     courtesy_call.hold = courtesy_call_conditions.save_space; /* save MME GEINOS conditions */
	     i = return_word.courtesy_call;		/* get courtesy call address */
	     j = instruction_counter;			/* get loc of MME GEINOS */
	     increment = i-j-1;			/* compute increment value to cause control to go to cc rtn */
	end;

	return;					/* go */
%page;
mme_endc:	entry (mcpp, increment);

/* MME GEENDC. Processing consists of restoring
   The machine conditions that existed at the time of the MME GEINOS
*/

	if gcos_ext_stat_$save_data.cc = "0"b then
	     call gcos_mme_bort_$system (
	     gcos_et_$geendc_not_in_cc
	     , "A MME GEENDC has been executed outside of a courtesy call."
	     );

	mcp = mcpp;

	if courtesy_call.next_out = courtesy_call.next_avail then do; /* cc queue empty */
	     gcos_ext_stat_$save_data.cc = "0"b;	/* unset courtesy call in progress flag */

	     increment = gcos_ext_stat_$increment_hold;	/* set old increment */

/* Restoration of slave program registers at time of courtesy call  */
	     mc_save_ptr = addr (courtesy_call.hold);
	     mcp -> mc_save_data.pr_regs = mc_save_data.pr_regs;
	     mcp -> mc_save_data.s_regs = mc_save_data.s_regs;
	     mcp -> mc_save_data.ici_regs = mc_save_data.ici_regs;
	     mcp -> mc_save_data.pl_regs = mc_save_data.pl_regs;
	end;
	else do;					/* cc routine still waiting. */

/* remove cc address from queue */
	     scup = addr (mc.scu);			/* get ptr to scu data */
	     increment =				/* Set increment to return to courtesy code return. */
		courtesy_call.queue (courtesy_call.next_out)
		- instruction_counter
		-1
		;
	     courtesy_call.next_out =
		mod (courtesy_call.next_out, hbound (courtesy_call.queue, 1))+1;

	end;

	return;
%page;
inos_trace_filecode: entry (arg_string);

/* Set file code values to trace. */
dcl  arg_string               char(*)parm;

	do k = 1 by 1;
	     if next_arg (k, argp, arglen) then return;
	     dbs_filecode = "1"b;
	     if (arg = "-pr") | (arg = "-print") then do; /* Display which files being traced. */
		if trace_index < 1 then call ioa_ ("No files being traced.");
		else
		do i = 1 to trace_index;
		     call ioa_ ("^3i. ^a", i, trace_array (i));
		end;
	     end;
	     else do;
		if trace_index >= hbound (trace_array, 1) then
		     call ioa_ ("ONLY ^i ALLOWED, ^a not entered.", hbound (trace_array, 1), arg);
		else do;
		     trace_index = trace_index + 1;	/* set table size */
		     trace_array (trace_index) =	/* Record file code (lower case) to trace. */
			translate (
			arg
			, "abcdefghijklmnopqrstuvwxyz"
			, "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
			);
		end;
	     end;
	end;
	return;
%page;
adjust_buffer: proc (bp);

/* for a fib.buffer just read from tape,
   determine if Multics has given us
   one word too much
*/
dcl  bp                       ptr parm;

	     if nelemt >= 4 then
		if bcw.blk_size = (nelemt - 2) then
		     if addrel (bp, nelemt - 1) -> word = "0"b then
			nelemt = nelemt - 1;
	     return;

dcl  word                     aligned bit(36) based;

dcl 1 bcw		aligned based (bp),
      2 bsn	fixed bin (18)unsigned unal,
      2 blk_size	fixed bin (18)unsigned unal;
	end adjust_buffer;
%page;
check_multirecord_request: proc (m);

/* Set "m" to "1"b if the MME GEINOS operation word
   specifies a multirecord request, and verify that the sum of the
   DCW list count of words to move and/or skip is consistent with
   the operation word block count.
   Set "m" to "0"b if the operation is not multirecord.
*/
dcl  m                        bit(1)parm;
	     if op_word.ioc_com ^= multirecord_com then do;
		m = "0"b;
		return;
	     end;

	     t = 0;				/* Total of DCW's words. */
	     d = dcw_offset;
get_ptr:	     ;

	     if d >= storlimit then			/* dcw ptr legal ? */
		call gcos_mme_bort_$system (
		gcos_et_$invalid_dcw_ptr
		, "DCW (at ^6.3b oct) is outside slave limits (^6.3b)."
		, addr (d) -> r18
		, addr (storlimit) -> r18
		);

	     dcwptr = addrel (gseg, d);		/* get ptr to dcw list */

	     if dcw.action = TDCW then do;		/* Transfer DCW. */
		d = dcw.data_addr;			/* get new address */
		goto get_ptr;			/* continue */
	     end;

	     if dcw.count = 0 then t = t+4096;
	     else t = t+dcw.count;
	     d = d + 1;				/* bump to next dcw */
	     if dcw.action ^= IOTD then goto get_ptr;	/* iontp or iotp - check next dcw */

	     nb = op_word.count;
	     if nb = 0 then nb = 64;			/* (gcos convention). */
	     if t ^= (320*nb) then
		call gcos_mme_bort_$system (
		gcos_et_$bad_multirec
		, "Multirecord ^[read^;write^] on file ""^a""."
		||"^/Requesting ^i blocks (^i words) but ^i specified in"
		||" MME GEINOS command (at memory ^6.3b)."
		, fib.order = read_file
		, fc
		, nb
		, count
		, op_word.count
		, scu.ilc
		);

	     m = "1"b;
	     return;

dcl  d                        fixed bin (24);
dcl  nb                       fixed bin (24);
dcl  t                        fixed bin (24);
	end check_multirecord_request;
%page;
debug_proc: proc ();

/* Display filecode debugging. */
	     if trace_index = 0 then goto trace;

	     do i = 1 to trace_index;
		if trace_array (i) = fc then goto trace;
	     end;
	     return;

trace:	     ;
	     if dbs_mme_inos_trace then do;
		call ioa_ (
		     "^a order ^w ^a (at ^6.3b)"
		     , fc
		     , op_word
		     , type_op (op_word.dev_com)
		     , rel (opptr)
		     );
	     end;

	     if dbs_mme_inos_stop then do;
		call ioa_ ("CALLING db:");
		call db;
	     end;
	     return;

	end debug_proc;
%page;
do_seek:	proc;					/* position file at fib.current */

	     if fib.current > fib.last then do;
		call ios_$seek (fib.stream, "last", "first", fib.current, status);
		if code ^= 0 then
		     call gcos_mme_bort_$system (
		     code
		     , "I/O error seek extending file ""^a"" to position ^i."
		     , fc
		     , fib.current
		     );
	     end;

	     if fib.order = write_file then seek_pointer = "write"; /* seek the write pointer */
	     else seek_pointer = "read";		/* seek the read pointer */

	     call ios_$seek (fib.stream, seek_pointer, "first", fib.current, status); /* do seek */
	     if code ^= 0 then
		call gcos_mme_bort_$system (
		code
		, "I/O error seeking to ^i on file ""^a""."
		, fib.current
		, fc
		);

	     return;
	end do_seek;
%page;
get_cmd_tbl_entry: proc;
	if fib.tape				/* tape? */
	then do;
	     fib.command_count = index.printer - index.tape;   /* get command table length */
	     fib.command_index = index.tape;		/* get command table address */
	     end;

	else if fib.print				/* printer? */
	     then do;
		fib.command_count = index.typewriter - index.printer;  /* get command table length */
		fib.command_index = index.printer;	/* get command table address */
		end;

	     else if fib.console			/* typewriter? */
		then do;
		     fib.command_count = index.next - index.typewriter;	/* get command table length */
		     fib.command_index = index.typewriter;   /* get command table address */
		     end;

/* If none of the above, the device type is disk (or punch simulated as a disk). */
		else do;
		     fib.command_count = index.tape - index.disk; /* get command table length */
		     fib.command_index = index.disk;	/* get command table address */
		     end;

	return;

end get_cmd_tbl_entry;
%page;
get_dcw: proc;

/* Return "count" with total number of contiguous words specified
   by DCW's, "where" to the memory location, and "continue" to
   "1"b if there are more DCW's to be processed. The format of
   the DCW, and the meanings of the action codes, are described
   in the comments at the beginning of the external procedure,
   gcos_mme_inos_.
*/
	     count = 0;
	     successive_tdcws = 0;

get_ptr:	     ;
	     if dcw_offset >= storlimit then		/* dcw ptr legal ? */
		call gcos_mme_bort_$system (
		gcos_et_$invalid_dcw_ptr
		, "DCW (at ^6.3b oct) is outside slave limits (^6.3b)."
		, addr (dcw_offset) -> r18
		, addr (storlimit) -> r18
		);

	     dcwptr = addrel (gseg, dcw_offset);		/* get ptr to dcw list */
	     if trace_or_stopsw then
		call ioa_ (
		"dcw (^[IOTD^;IOTP^;TDCW^;IONTP^]) ^w"
		, fixed (dcw.action, 2)+1
		, dcw
		);

	     if dcw.action = TDCW then do;		/* Transfer DCW. */
		successive_tdcws = successive_tdcws+1;
		if successive_tdcws>1 then
		     call gcos_mme_bort_$system (	/* 2 successive TDCW's. */
		     gcos_et_$two_tdcws
		     , "File ""^a"""
		     , fc
		     );
		dcw_offset = dcw.data_addr;		/* get new address */
		goto get_ptr;			/* continue */
	     end;
	     successive_tdcws = 0;			/* Reset count. */

	     if dcw.action = IONTP then do;		/* Skip and continue. */
		continue = "1"b;			/* indicate more to do */
		if count ^= 0 then return;		/* Exit perform previous DCW's, return to "get_dcw" for skip. */
		if dcw.count = 0 then count = 4096;	/* grab skip count */
		else count = dcw.count;		/* (count of 0 = 4096) */
		type_dcw = IONTP;
		dcw_offset = dcw_offset + 1;		/* bump over dcw */
		where = -1;			/* indicate medium skip to caller */
		return;				/* Exit to process skip. */
	     end;

/* => IOTD or IOTP form of DCW. */
	     if dcw.count = 0 then holdcount = 4096;	/* count of 0 = 4096 */
	     else holdcount = dcw.count;

	     if count = 0 then			/* first dcw processed this call ? */
		where = dcw.data_addr;		/* yes...get transfer start location */
	     else
	     if (where + count) ^= dcw.data_addr then do; /* new dcw contiguous ? */
		continue = "1"b;			/* indicate more dcws to process */
		return;				/* exit */
	     end;
	     count = count + holdcount;		/* bump total transfer count */
	     dcw_offset = dcw_offset + 1;			/* bump to next dcw */
	     type_dcw = IOTP;
	     if dcw.action = IOTP then goto get_ptr;	/* iotp - check next dcw */
	     type_dcw = IOTD;
	     continue = "0"b;			/* iotd dcw */
	     return;

dcl  holdcount                fixed bin (24);
dcl  successive_tdcws         fixed bin (24);
	end get_dcw;
%page;
init_routine: proc;

	seeksw,
	sc_ga,
	mr,
	type_dcw = "0"b;

	unspec (status) = "0"b;

	slave_status = "400000000000"b3;

	cc_residue,
	da_residue,
	nelemt,
	override,
	total_count,
	wc_residue = 0;

	argp,
	dcwptr,
	ibuffptr,
	mc_save_ptr,
	opptr,
	sbuffptr,
	sptr,
	swptr = null ();
	i = 0;

	return;

end init_routine;
%page;
make_stat_ptr: proc;				/* obtain pointer to status
						   words and check return_word
						   address fields */
	if return_word.status_return >= storlimit then /* legal status return */
	     call gcos_mme_bort_$system (
	     gcos_et_$bad_status_ret_ptr
	     , "Status return address in I/O sequence is outside slave limits."
	     );

	if return_word.courtesy_call >= storlimit then /* legal courtesy call */
	     call gcos_mme_bort_$system (
	     gcos_et_$bad_cc_ptr
	     , "Courtesy call address in I/O sequence is outside slave limits."
	     );

	if return_word.status_return = 0		/* program doesn't want status */
	then do;
	     swptr = addr (scratch_status);		/* so fake a return area */
	     scratch_status = "0"b;
	     end;
	else swptr = addrel (gseg, return_word.status_return); /* get address of status words */
	return;

end make_stat_ptr;
%page;
match_fc: proc () returns (bit (1));			/* Find a file code in the FC table. */

	do   j = 1 to hbound (save_data.fibs, 1);	/* Search file code table for match */
	     if fct.filecode (j) = fc			/* Set MATCH flag if match. */
	     then return ("1"b);
	     end;

	return ("0"b);

end match_fc;
%page;
next_dcw_ptr: proc (data_ptr, how_many, continuation);

/*

   Check  the  DCW  list and return the buffer pointer, transfer count,
   and a flag indicating whether this was the last DCW in the list.

   If the DCW is a transfer DCW (TDCW), then we go to the next list and
   start looking there, returning only when we find an I/O DCW.

   We  also  check  the  buffer  pointer for legality.  If it is out of
   range, we don't return to the caller, but instead bail  out  through
   the MME GEBORT escape-hatch.  Ditto for 2 successive TDCWs.

*/

dcl  data_ptr	pointer		parm;
dcl  how_many	fixed bin (21)	parm;
dcl  continuation	bit (1)		parm;

	successive_tdcws = 0;

	if   dcw_offset >= storlimit
	then call gcos_mme_bort_$system (gcos_et_$invalid_dcw_ptr,
				   "DCW (at ^6.3b oct) is outside slave limits (^6.3b).",
				   addr (dcw_offset) -> r18,
				   addr (storlimit) -> r18);

	dcwptr = addrel (gseg, dcw_offset);
	if   trace_or_stopsw
	then call ioa_ ("dcw (^[IOTD^;IOTP^;TDCW^;IONTP^]) ^w",
		      fixed (dcw.action, 2) + 1,
		      dcw);
	
	if   dcw.action = TDCW
	then do;
	     dcw_offset = dcw.data_addr;
	     dcwptr = addrel (gseg, dcw_offset);
	     if   dcw.action = TDCW
	     then call gcos_mme_bort_$system (gcos_et_$two_tdcws,
				        "While accessing file code ""^a""",
				        fc);
	     end;

	if   dcw.data_addr = 0			/* Gotta provide an address SOMEHOW! */
	   | dcw.action = IONTP
	then data_ptr = addr (tapebuffer);		/* If nothing else, round-file it. */
	else data_ptr = addrel (gseg, data_addr);

	if   dcw.count = 0
	then how_many = 4096;			/* Can't just do nuthin'. */
	else how_many = dcw.count;

	if how_many > gcos_ext_stat_$tape_buffer_size
	then call gcos_mme_bort_$system (gcos_et_$request_too_big,
				   "gcos_mme_inos_",
				   "^/Request was ^i, buffer size is ^i words (decimal).",
				   how_many,
				   gcos_ext_stat_$tape_buffer_size);

	continuation = (dcw.action ^= IOTD);		/* Gotta tell him there's more. */

	dcw_offset = dcw_offset + 1;			/* Bump over this one. */

	return;

end next_dcw_ptr;
%page;
process_request: proc;				/* Process the GEINOS command. */

	opptr = addrel (idptr, -1);			/* build pointer to operation word */
	sptr = addrel (idptr, 1);			/* build pointer to return word */
	dcw_offset = id_word.dcwp;			/* get dcw list pointer */
	if trace_or_stopsw then call debug_proc ();

	if fib.command_index = 0			/* Get pointer to proper command table entry. */
	then call get_cmd_tbl_entry;

/* Look up command in the command table specified in fib.command.
   Table length is specified by fib.command_count. */

	do i = fib.command_index to fib.command_index + fib.command_count;
	     if   substr (io (i).command, 1, 6) = op_word.dev_com	/* are device and */
	        & substr (io (i).command, 19, 5) = op_word.ioc_com	/* IOC command valid? */
	     then goto com_proc (io (i).process);	/* go to processing rtn */
	end;					/* no...continue */

	call gcos_mme_bort_$system (gcos_et_$bad_io_cmnd_file,
			        "This MME GEINOS command is not supported:"
			        ||"^/file code=""^a"", command=^w (^a), memory offset=^6.3b",
			        fc,
			        unspec (op_word),
			        type_op (op_word.dev_com),
			        scu.ilc);

end process_request;
%page;
scatter_input: proc (bp);

/* move data from fib.buffer pointed to by bp
   to (possibly) multiple buffers in
   slave program, according to dcw list
*/
dcl  bp                       ptr parm;

	     posit, wc_residue = 0;
sc_loop:	     ;
	     if nelemt < count then do;
		wc_residue = wc_residue + count - nelemt;
		if nelemt = 0 then goto sc_res;
		count = nelemt;
	     end;
	     if where = -1 then goto sc_skip;		/* no-transfer and proceed */
	     ibuffptr = addrel (bp, posit);		/* move from our fib.buffer */
	     sbuffptr = addrel (gseg, where);		/* into slave fib.buffer */
	     slave_buffer = internal_buffer;
sc_skip:	     ;
	     nelemt = nelemt - count;
	     posit = posit + count;
	     da_residue = where + count;
sc_res:	     ;
	     if continue = "0"b then return;
	     call get_dcw;
	     goto sc_loop;

	end scatter_input;
%page;
type_op:	proc (op)returns (char (*));

/* Return string specifying type of mme inos operation word. */
dcl  op                       bit(6)unal parm;
	     do i = 1 to hbound (device_cmd, 1);
		if op = device_cmd (i) then return (rtrim (name_cmd (i)));
	     end;
	     return ("UNKNOWN DEVICE COMMAND");

dcl  i                        fixed bin (24);
dcl 1 operation_word_values	(27)static int options(constant)
,2 device_cmd		bit(6)init(
	"00"b3 /* Request Status */
,	"03"b3 /* Read Typewriter */
,	"04"b3 /* Read Tape Decimal */
,	"05"b3 /* Read Tape Binary */
,	"13"b3 /* Write (then Read) Typewriter */
,	"14"b3 /* Write Tape Decimal */
,	"15"b3 /* Write Tape Binary */
,	"25"b3 /* Read */
,	"30"b3 /* Write Printer Edited */
,	"31"b3 /* Write */
,	"34"b3 /* Seek */
,	"40"b3 /* Reset Status */
,	"41"b3 /* Set 6250 Density */
,	"42"b3 /* Set 800 Density */
,	"43"b3 /* Set 556 Density */
,	"44"b3 /* Forward Space Record */
,	"45"b3 /* Forward Space to Filemark */
,	"46"b3 /* Backspace Record */
,	"47"b3 /* Backspace to Filemark */
,	"54"b3 /* Erase */
,	"55"b3 /* Write EOF */
,	"60"b3 /* Set High Density */
,	"61"b3 /* Set Low Density */
,	"64"b3 /* Set 200 Density */
,	"65"b3 /* Set 1600 Density */
,	"70"b3 /* Rewind */
,	"72"b3 /* Rewind and Unload */
			)
,2 name_cmd		char(28)init(
	/* 00"b3*/ "Request Status"
,	/* 03"b3*/ "Read Typewriter"
,	/* 04"b3*/ "Read Tape Decimal"
,	/* 05"b3*/ "Read Tape Binary"
,	/* 13"b3*/ "Write (then Read) Typewriter"
,	/* 14"b3*/ "Write Tape Decimal"
,	/* 15"b3*/ "Write Tape Binary"
,	/* 25"b3*/ "Read"
,	/* 30"b3*/ "Write Printer Edited"
,	/* 31"b3*/ "Write"
,	/* 34"b3*/ "Seek"
,	/* 40"b3*/ "Reset Status"
,	/* 41"b3*/ "Set 6250 Density"
,	/* 42"b3*/ "Set 800 Density"
,	/* 43"b3*/ "Set 556 Density"
,	/* 44"b3*/ "Forward Space Record"
,	/* 45"b3*/ "Forward Space to Filemark"
,	/* 46"b3*/ "Backspace Record"
,	/* 47"b3*/ "Backspace to Filemark"
,	/* 54"b3*/ "Erase"
,	/* 55"b3*/ "Write EOF"
,	/* 60"b3*/ "Set High Density"
,	/* 61"b3*/ "Set Low Density"
,	/* 64"b3*/ "Set 200 Density"
,	/* 65"b3*/ "Set 1600 Density"
,	/* 70"b3*/ "Rewind"
,	/* 72"b3*/ "Rewind and Unload"
	);
	end type_op;
%page;
%include gcos_next_arg;
%page;
/*   Variables for gcos_mme_inos_:		 */
/*   IDENTIFIER		ATTRIBUTES	 */
dcl  addr                     builtin;
dcl  addrel                   builtin;
dcl  arg                      char(arglen) based (argp);
dcl  arglen                   fixed bin (24);
dcl  argp                     ptr;
dcl  ascii_index              fixed bin (21);
dcl  ascii_string             char(132);
dcl  bcd_string               (count*6) bit(6) unal based (workp);
dcl  bksp_sw                  bit(1);
dcl  cc_residue               fixed bin (24);
dcl  char                     char aligned;
dcl  continue                 bit(1)	/* parameter from get_dcw */;
dcl  count                    fixed bin (21);
dcl  da_residue               fixed bin (24);
dcl  db                       ext entry;
dcl  dcwptr                   ptr;
dcl  dcw_offset		fixed bin (24)		/* slave offset of current dcw */;
dcl  default_high             char(5) int static options (constant) init ("d1600")	/* system default high density */;
dcl  default_low              char(4) int static options (constant) init ("d556")	/* system default low density */;
dcl  density_history          bit(2) aligned;
dcl  divide                   builtin;
dcl  error_retry              bit(1) aligned		/* 1 = processing parity error */;
dcl  fb35                     fixed bin (35) based;
dcl  fc                       char(2)	/* file code from file control block */;
dcl  fixed                    builtin;
dcl  gcos_cv_ascii_gebcd_     ext entry (ptr, fixed bin (21), ptr, fixed bin (21));
dcl  gcos_et_$access_beyond_file fixed bin (35) ext;
dcl  gcos_et_$bad_cc_ptr      fixed bin (35) ext;
dcl  gcos_et_$bad_io_cmnd_file fixed bin (35) ext;
dcl  gcos_et_$bad_mme_in_cc   fixed bin (35) ext;
dcl  gcos_et_$bad_multirec    fixed bin (35) ext static;
dcl  gcos_et_$bad_seek_dcw    fixed bin (35) ext;
dcl  gcos_et_$bad_status_ret_ptr fixed bin (35) ext;
dcl  gcos_et_$fc_not_defined  fixed bin (35) ext;
dcl  gcos_et_$geendc_not_in_cc fixed bin (35) ext;
dcl  gcos_et_$impermissible_perm_read fixed bin (35) ext;
dcl  gcos_et_$impermissible_perm_write fixed bin (35) ext;
dcl  gcos_et_$invalid_dcw_ptr fixed bin (35) ext;
dcl  gcos_et_$invalid_file_ptr fixed bin (35) ext;
dcl  gcos_et_$irrecoverable_io_err fixed bin (35) ext;
dcl  gcos_et_$need_multirec   fixed bin (35) ext static;
dcl  gcos_et_$request_too_big fixed bin (35) ext static;
dcl  gcos_et_$two_tdcws       fixed bin (35) ext static;
dcl  gcos_mme_bort_$system    ext entry options (variable);
dcl  gcos_write_$bcd_ptr      ext entry (ptr, char(*), bit(8));
dcl  gseg                     ptr;
dcl  hbound                   builtin;
dcl  i                        fixed bin (21);
dcl  ibuffptr                 ptr;
dcl  idptr                    ptr;
dcl  instruction_counter      fixed bin (18)unsigned unal based(addr(scu.ilc));
dcl  internal_buffer          (count) fixed bin (35) based (ibuffptr);
dcl  ioa_                     ext entry options (variable);
dcl  j                        fixed bin (24);
dcl  k                        fixed bin (24);
dcl  major_status		bit (4) aligned;
dcl  max                      builtin;
dcl  mc_save_ptr              ptr;
dcl  minor_status		bit (6) aligned;
dcl  mod                      builtin;
dcl  more_dcws		bit (1);
dcl  mr                       bit(1)	/* "1"b => multirecord request. */;
dcl  multirecord_com          bit(5)static int options(constant)init("00011"b);
dcl  mybuf                    (160) bit(6) unal;
dcl  n                        fixed bin (24);
dcl  nelemt                   fixed bin (21);
dcl  new_next_avail           fixed bin (24);
dcl  null                     builtin;
dcl  opptr                    ptr;
dcl  order                    char(20)	/* holds order type */;
dcl  output_ptr		pointer;
dcl  override                 fixed bin (24);
dcl  posit                    fixed bin (21);
dcl  record                   char(j) based	/* overlay for bcd record */;
dcl  rec_ct_residue           fixed bin (24)/* holds no of unskipped records */;
dcl  rel                      builtin;
dcl  retry_count              fixed bin (24)/* number of attempts left in which */;
dcl  sbuffptr                 ptr;
dcl  scratch_status           bit(72) aligned	/* temp */;
dcl  sc_ga                    bit(1);
dcl  seeksw                   bit(1)	/* sw controlling disk or drum seeks */;
dcl  seek_address             fixed bin (24)based	/* user seek address for disk or drum */;
dcl  seek_pointer             char(5)	/* holds name of pointer to seek */;
dcl  slave_buffer             (count) fixed bin (35) based (sbuffptr);
dcl  slave_status             bit(36) aligned;
dcl  sptr                     ptr;
dcl  storlimit                fixed bin (19)	/* slave core boundary */;
dcl  substr                   builtin;
dcl  successive_tdcws	fixed bin;
dcl  swptr                    ptr;
dcl  tapebuffer               (4096) bit(36) aligned;
dcl  total_count              fixed bin (24);
dcl  total_read		fixed bin (36);
dcl  trace_array              (20) char(4) int static;
dcl  trace_index              fixed bin (24) static int init(0);
dcl  trace_or_stopsw          bit(1) static int init ("0"b);
dcl  transfer_count		fixed bin (21);
dcl  translate                builtin;
dcl  type_dcw                 bit(2);
dcl  unspec                   builtin;
dcl  wc_residue               fixed bin (24);
dcl  where                    fixed bin (21);
dcl  workp                    ptr;
dcl  z320                     (320)bit(36)static int options(constant)init((320)(36)"0"b);
dcl 1 courtesy_call_conditions  like save_machine_conditions based (mcp);

dcl (
    IOTD		init("00"b)
,   IOTP		init("01"b)
,   TDCW		init("10"b)
,   IONTP		init("11"b)
		) bit(2)static internal options(constant);

dcl 1 w		aligned based
,     2 l18	bit(18)unal
,     2 r18	bit(18)unal
;
%page;
dcl 1 op_word aligned based (opptr),		/* model of operation word */
      2 dev_com	bit(6) unal,		/* device command */
      2 zero1	bit(12) unal,		/* zeros */
      2 ioc_com	bit(5) unal,		/* ioc command */
      2 zero2	bit(1) unal,		/* zero */
      2 control	bit(6) unal,		/* control */
      2 count	fixed bin (6)unsigned unal	/* count */;

dcl 1 id_word aligned based (idptr),		/* model of identification word */
      2 filep	fixed bin (18)unsigned unal,	/* file control block pointer */
      2 dcwp	fixed bin (18)unsigned unal	/* dcw list pointer */;

dcl 1 file_code_word aligned based (workp),	/* model of file code word */
      2 fill	bit(24) unal,
      2 fcode	bit(12) unal		/* file code in bcd */;

dcl 1 return_word aligned based (sptr),		/* model of status return word */
      2 status_return	fixed bin (18)unsigned unal,	/* pointer to return words */
      2 courtesy_call	fixed bin (18)unsigned unal	/* pointer to courtesy call rtn */;

dcl 1 stat_words aligned based (swptr),		/* model of status words */
      2 sw1	bit(36) aligned,		/* word 1 */
      2 sw2	bit(36) aligned		/* word 2 */;

dcl 1 dcw aligned based (dcwptr),		/* dcw model */
      2 data_addr	fixed bin (18)unsigned unal,	/* data address */
      2 zero	bit(3) unal,		/* fill */
      2 chr_tally	bit(1) unal,		/* character tally indicator. */
      2 action	bit(2) unal,		/* action */
      2 count	fixed bin (12)unsigned unal	/* word count for transfer */;

dcl 1 mc_save_data based (mc_save_ptr),
   (2 pr_regs (16),
    2 s_regs (8),
    2 scu_0_3 (4),
    2 ici_regs,
    2 scu_5_7 (3),
    2 software_data (8),
    2 pl_regs (8)) fixed bin (35);
%page;
/* 	I/O Simulation Tables					 */


/* 	Command Tables:						 */
/* 								 */
/* 	The command tables contain the possible legal commands for each device	 */
/* 	type. Each command table entry contains the command and the command	 */
/* 	processor address.						 */


/* Table of indices into io_commands list to
   separate MME GEINOS command word sublists
   for various devices.
*/
dcl 1 index	static int options(constant),
      2 (
	disk		init(01),
	tape		init(11),
	printer		init(36),
	typewriter	init(40),
	next		init(44)
		) fixed bin (24);

dcl 1 io (43) internal static options (constant),
	     2 command bit (36) init (

/*   Disk commands:  */
  /*  1 */ "340000000002"b3	/* 34 - seek disk address */
, /*  2 */ "250000002400"b3	/* 25 - read disk continuous */
, /*  3 */ "250000060000"b3	/* 25 - multirecord disk read. */
, /*  4 */ "310000002400"b3	/* 31 - write disk continuous */
, /*  5 */ "310000060000"b3	/* 31 - multirecord disk write. */
, /*  6 */ "700000020001"b3	/* 70 - rewind */
, /*  7 */ "460000020001"b3	/* 46 - backspace record(s) */
, /*  8 */ "440000020001"b3	/* 44 - forward space record(s) */
, /*  9 */ "400000020001"b3	/* 40 - reset status */
, /* 10 */ "000000020001"b3	/* 00 - request status */

/*   Tape commands:  */
, /* 11 */ "050000000000"b3	/* 05 - read tape binary */
, /* 12 */ "150000000000"b3	/* 15 - write tape binary */
, /* 13 */ "030000000000"b3	/* 03 - read tape nine */
, /* 14 */ "130000000000"b3	/* 13 - write tape nine */
, /* 15 */ "700000020001"b3	/* 70 - rewind */
, /* 16 */ "550000020001"b3	/* 55 - write eof */
, /* 17 */ "450000020001"b3	/* 45 - forward space to file mark */
, /* 18 */ "470000020001"b3	/* 47 - backspace to file mark */
, /* 19 */ "440000020001"b3	/* 44 - forward space one record */
, /* 20 */ "460000020001"b3	/* 46 - backspace one record */
, /* 21 */ "150000100000"b3	/* 15 - write file mark */
, /* 22 */ "140000100000"b3	/* 14 - write file mark decimal */
, /* 23 */ "540000020001"b3	/* 54 - erase */
, /* 24 */ "720000020001"b3	/* 72 - rewind and unload */
, /* 25 */ "600000020001"b3	/* 60 - set high density */
, /* 26 */ "610000020001"b3	/* 61 - set low density */
, /* 27 */ "640000020001"b3	/* 64 - set 200 density */
, /* 28 */ "430000020001"b3	/* 43 - set 556 density */
, /* 29 */ "420000020001"b3	/* 42 - set 800 density */
, /* 30 */ "650000020001"b3	/* 65 - set 1600 density */
, /* 31 */ "410000020001"b3	/* 41 - set 6520 density */
, /* 32 */ "400000020001"b3	/* 40 - reset status */
, /* 33 */ "000000020001"b3	/* 00 - request status */
, /* 34 */ "040000000000"b3	/* 04 - read tape bcd */
, /* 35 */ "140000000000"b3	/* 14 - write tape bcd */

/*   Printer commands:  */
, /* 36 */ "300000000000"b3	/* 30 - write printer edited */
, /* 37 */ "300000060001"b3	/* 30 - write printer edited continuous */
, /* 38 */ "400000020001"b3	/* 40 - reset status */
, /* 39 */ "000000020001"b3	/* 00 - request status */

/*   Typewriter commands: */
, /* 40 */ "130000000000"b3	/* 13 - write or write then read */
, /* 41 */ "030000000000"b3	/* 03 - read */
, /* 42 */ "400000020001"b3	/* 40 - reset status */
, /* 43 */ "000000020001"b3	/* 00 - request status */
	     ),

/* Corresponding indices to labeled array location
   to processing routine.
*/
	     2 process fixed bin (24)init (

/*   Disk commands:  */
   1	/* 34 - seek disk address */
,  2	/* 25 - read disk continuous */
,  2	/* 25 - multirecord disk read */
,  3	/* 31 - write disk continuous */
,  3	/* 31 - multirecord disk write. */
,  4	/* 70 - rewind */
,  5	/* 46 - backspace record(s) */
,  6	/* 44 - forward space record(s) */
,  7	/* 40 - reset status */
,  8	/* 00 - request status */

/*   Tape commands:  */
,  9	/* 05 - read tape binary */
, 10	/* 15 - write tape binary */
, 11	/* 03 - read tape nine */
, 12	/* 13 - write tape nine */
, 13	/* 70 - rewind */
, 14	/* 55 - write eof */
, 15	/* 45 - forward space to file mark */
, 16	/* 47 - backspace to file mark */
, 17	/* 44 - forward space one record */
, 18	/* 46 - backspace one record */
, 19	/* 15 - write file mark */
, 20	/* 14 - write file mark decimal */
, 21	/* 54 - erase */
, 22	/* 72 - rewind and unload */
, 23	/* 60 - set high density */
, 24	/* 61 - set low density */
, 25	/* 64 - set 200 density */
, 26	/* 43 - set 556 density */
, 27	/* 42 - set 800 density */
, 28	/* 65 - set 1600 density */
, 41	/* 41 - set 6520 density */
, 29	/* 40 - reset status */
, 30	/* 00 - request status */
, 31	/* 04 - read tape bcd */
, 32	/* 14 - write tape bcd */

/*   Printer commands:  */
, 33	/* 30 - write printer edited */
, 34	/* 30 - write printer edited continuous */
, 35	/* 40 - reset status */
, 36	/* 00 - request status */

/*   Typewriter commands: */
, 37	/* 13 - write or write then read */
, 38	/* 03 - read */
, 39	/* 40 - reset status */
, 40	/* 00 - request status */
	     );
%page;
%include gcos_dcl_ios_;
%page;
%include gcos_xlate_bcd_ascii_;
%page;
%include gcos_ext_stat_;
%page;
%include gcos_dbs_names;
     end gcos_mme_inos_;
