" ***********************************************************
" *                                                         *
" * Copyright, (C) Honeywell Information Systems Inc., 1982 *
" *                                                         *
" ***********************************************************
"  *************************************************************                
"  *                                                           *                
"  *                                                           *                
"  * copyright (c) 1974 by honeywell information systems, inc. *                
"  *                                                           *                
"  *                                                           *                
"  *************************************************************                
"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"								"
"	gcos_mme_snp1_						"
"								"
"	This procedure is a conversion of the GCOS SR1/G SSA module .MSNP1	"
"	from gmap to alm pure procedure.				"
"								"
"	There are three entry points to this procedure:			"
"								"
"	1.  gcos_mme_snp1_:-  This entry processes a slave program MME	"
"	GESNAP. It requires no arguments.				"
"								"
"	2.  binpt:- This entry is used to snap the slave prefix of	"
"	aborting programs.  It requires three arguments:			"
"	     arg1 is a full word containing the absolute location to print	"
"	     in its upper, and the number of words to print in its lower.	"
"	     arg2 is a full word containing the absolute location to snap	"
"	     in its upper, and the number of words to snap in its lower.	"
"	     arg3 is a full word containing bias to apply to address 	"
"	     for snap in its upper, and 3 bcd characters to print with the	"
"	     first line of output in its lower (m  ,s  ,   ).		"

"								"
"	3.  bord:-  This entry is used to snap registers and memory of 	"
"	aborting programs.  It requires two arguments:			"
"	     arg1 is a full word containing the ic&ir to print.		"
"	     arg2 is a full word which has the same format as the MME 	"
"	     GESNAP parameter.					"
"								"
"	Written by R.H. Morrison	December, 1974			"
"								"
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
" " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
"
	name	gcos_mme_snp1_
	entry	gcos_mme_snp1_,bord,binpt
	include	mc
"
"
gcos_mme_snp1_:
	push
	spriap	sp|0	save ap
	ldq	0,dl	change transfer to ep1
	stq	mod
	lda	0,dl	set a & q registers
	ldq	0,dl
	tra	xinit1  


"      ttl     cd600j3.265	 gecos sr1/g		  740704snp1
"      cpr     g,1968,1969,1970                                                 
"      cpr     h,1971,1972                                                      
"      .entry  snp1,xend,,(gesnip,binpt,bord),ssa                        
"      ttls                    g e s n a p                               
bp:    null                                                                     
       stx1    prea                                                         
bp05:  null                                                              
       eax3    0,qu            save location of first word to            
"                              be dumped.                                
       eaq     0,ql            store # words to dump in                  
       stq     wdcnt      word count.                               
       cana    -1,dl           are there any words to be moved?          
       tze     bp20            nope                                             
       eax1    0,au            put location of data to be moved in x1.   
       ldx2    lp|bufad1       x2 = 1st location in output buffer
       ana     -1,dl           isolate # of words to move                
bp10:  ldq     pr3|0,1         start move.                               
       stq     lp|0,2                                                       
       adlx1   1,du            bump move indices.                        
       adlx2   1,du                                                      
       sbla    1,dl            decrement # words to move.                
       tnz     bp10       continue moving.                          
bp20:  stx3    mo10a       store location of next word to dump.      
       tsx1    comp       go find first equal line.                 
       tra     bp30       no equal lines.                           
       tra     comp20     lines not equal, continue search.         
       ldx4    comp20a     first equal line-loc. in comp 20.         
       sblx4   mo10a       calculate # words to move.                
       sta     wdcnt      restore wdcnt to new value.               
       tsx1    output     go output the words.                      
       ldx0    =o542020,du     set up to print * with next line.         
       sxl0    mo30a                                                 
       tsx1    comp       now we skip all equal lines.              
       tra     bp50       less than 17 words left to print.         
       tra     2,ic            unequal lines found.                      
       tra     comp20     equal lines found, keep going             
       sta     wdcnt      restore word count.                       
       ldx3    comp20a     pick up loc. of unequal line.             
       tra     bp20                                                 
bp30:  ldx4    wdcnt      pick up # of words to print.              
       tsx1    output     output last of line.                      
pre:   ldx1    prea                                                            
       tnz     0,1             came from eis register dump routine              
flush: tsx1    write      flush the buffer                                 
xit:   null                                                                     
	return		return to calling procedure
bp50:  eax3    8,3             bump loc. of line by 8 to get past        
"                              equal line.                               
       eax4    -8,au           # words left to x4.                       
       stx3    mo10a       store loc. of last line(s) to print.      
       tra     bp30+1                                               
"                              this routine determines                   
"                              how many words to be printed              
"                              will fit in the current                   
"                              buffer and calls the                      
"                              move routine to put them                  
"                              in the buffer. whenever the               
"                              buffer is found to be full,               
"                              the write routine is called               
"                              to empty the buffer.                      
"                              upon entry                                
"                              x2-next available loc. in lp|bufr.           
"                              x4-number of words to move.               
output:stx1    op20a       save x1 for return.                       
       eax0    bufnd            see if all words to be moved		   
       stx2    op05a            fit in buffer. allow for 2                
       sblx0   op05a           extra words. last loc in buffer-          
"                              first available loc to store in.          
       tmi     op50       nothing fits.                             
       stx0    op15a                                                      
op10:  cmpx4   op15a           will all words fit?                       
       trc     op30       no- see if any fit                               
       eaa     0,4             # words to au.                            
       tsx1    move       go setup sysout record.                   
op20:  ldx1    op20a
       tra     0,1
op30:  cmpx0   9,du            will at least 8 words fit?                
       tnc     op50       no-go flush buffer.                       
       eax0    -1,0            set number of words to move               
       anx0    =o777770,du     to a multiple of 8.                       
       stx0    op40a       save so as to reduce total words.         
       eaa     0,0                                                       
       tsx1    move       set up sysout record.                     
op40:  sblx4   op40a           reduce total words to move by             
       ldx0    =o202020,du       # words just moved.                       
       stx3    mo10a       initialize move rout. with start of       
"                              next line.                                
       sxl0    mo30a       set print character to blank.             
op50:  tsx1    write      go flush the buffer.                      
       tra     output+1                                             
"                              this routine sets up the sysout           
"                              (gefrc) record control words              
"                              for n lines of "binary"                   
"                              print words. it then moves                
"                              the prescribed words to the               
"                              buffer.                                   
"                              upon entry                                
"                              x2-next available loc in bufr.            
"                              au-# words to move                        
"                              mo10a-initialize with loc of               
"                                 first word to move                     
"                              mo20a-initialize with bias to              
"                                 apply to printed location.             
"                              mo30a-initialized with character           
"                                 to print with first loc.               
"                                 e.i. m,s,* or blank.                   
move:  eaq     1,au            construct first gefrc control             
       orq     =o70374,dl      word.                                     
       stq     lp|0,2                                                       
mo10:  ldx3    mo10a           set x3 to first word to move              
"                              set up second sysout control              
"                              word. location, print character           
mo20:  eaq     0,3             apply bias to location
       adlq    mo20a
mo30:  orq     mo30a       or in print character                            
       stq     lp|1,2                                                       
       eax2    2,2             set x2 to "move to" location.             
mo40:  arl     8              shift # word to move into position        
       eax0    256+512,al      and "or" in a and b bits for repeat       
          cana      -1,dl     test for partial 256 word block
          tnz       mo50      move it
mo60:     sbla      1,du      decrement number of full blocks
          tmi       0,1       exit
	odd
mo50:  rpdx    0,1             move last of words
       ldq     pr3|0,3                                                   
       stq     lp|0,2                                                        
       tra     mo60                                                        
"                              this routine compares one line            
"                              (8 words to print in memory dump)         
"                              with the next line and                    
"                              exits 1 when the lines are                
"                              not equal. when the lines are             
"                              equal it exits 2. if there                
"                              are only 2 lines (16 words) or            
"                              less to be processed this                 
"                              routine exits 0. when at                  
"                              least one comparison takes place,         
"                              comp20a contains the first loc.            
"                              of the second line of the                 
"                              current pair.                             
"                              upon entry:                               
"                              wdcnt contains # word still to            
"                                 be processed.                          
"                              x3 contains location for first line.      
comp:  lda     wdcnt      pick up number of words to process.       
comp10:cmpa    17,du           is there less than 17 words.              
       tnc     0,1             yes, exit 0.                              
       eax4    8,3             location of next line to x4.              
       eaa     -8,au           reduce count by 8.                        
       stx4    comp20a     save it for use later.                    
	odd
       rpd     8,1,tnz         compare lines for equality                
       ldq     pr3|0,3                                                        
       cmpq    pr3|0,4                                                        
       tnz     1,1             lines are not equal, exit 1.              
       tra     2,1             lines are equal, exit 2.                  
comp20:ldx3    comp20a           location of next line to x3.              
       tra     comp10                                               
"                                                                        
"                              write output routine                      
"                              this routine calls sysout                 
"                              entry point 1 for sysout on               
"                              p* or entry point 5 for                   
"                              writing to the execution report.          
"                              upon entry                                
"                                 x1 - used for return.                  
"                                 x2 - contains next avail loc in bufr.  
"                                 x4-contains a count that must be saved 
"                              upon exit                                 
"                                 x2-must contain next avail loc in lp|bufr 
"                                 x4-must be preserved throughout.       
write: stx1    writxa          convert to print line format and write
       ldx0    lp|bufad   dev # words for dcw                              
       stx0    wr10a           write routine
       sblx2   wr10a           dev words
       sxl2    lp|bufr-1                                               
       eaa     -1,2            now generate block control word.          
       ora     =o060000,dl    this is for output to execution report
       sta     lp|bufr
"                              develope address portion of dcw.          
       sblx0   lp|.crlal,6
       stx0    lp|bufr-1
       stx4    wr20a
       tsx1    gwrite          convert to print line format
       lxl1    bsn             set block serial number
       stx1    lp|pbufr
       aos     bsn
	lda   	desc2i	descriptor word for block
	arl	18	shift out size
	eaq	1,4	new size
	qls	2	times 4 for ascii pseudo char. count
	lls	18	shift back to a reg.
	sta	desc2	put in argument list
	call	<gcos_write_>|[block_ptr](arglst)
       ldx4    wr20a
writx: ldx1    writxa          restore x1
       ldx2    lp|bufad1
       tra     0,1                                                       
ckore: null                                                                     
       ldaq    lp|.stemp,5        get ic+i and dump parameter                          
       canq    =o400000,dl     do we want registers only                        
       tze     snpc       no-user wants core also                          
       tra     flush      go write registers and exit                      
snpc:  null                                                                     
       anq     =o777777077777 mask out panel/slew info                     
       ldx3    =o622020,du         dump label                                   
       lcx1    lp|.crlal,6
       ldx0    lp|.crlal,6
snps:  null                                                                     
       lda     lp|.salim,5        get slave memory limits                          
       ana     =o776,du        isolate # of words                               
       als     9                                                                
       sbla    1,dl                                                             
"*******                                                                        
" au is last avail mem location, al is all ones. this will override             
" any word count in the lower half of lp|.stemp+1 which is used in a               
" comparison very shortly.                                                      
       stx0    snpmsa      to absolutize starting address                   
       stx1    mo20a       relativize dump locations                        
       sxl3    mo30a       dump label                                       
       canq    -1,dl           is word count zero                               
       tnz     2,ic                                                             
       orq     -1,dl           yes-set count to max                             
       stq     lp|.stemp+1,5      save dump parameter                              
       cmpa    lp|.stemp+1,5      compare 1st address with last avail              
       trc     3,ic            ok                                               
       eax0    0                                                                
       stx0    lp|.stemp+1,5                                                       
       anq     -1,dl           isolate word count                               
       stq     lp|.stemp+2,5      save it                                          
       ldq     lp|.stemp+1,5      now we calculate last word                       
       qrl     18              to be dumped in lower half                       
       asq     lp|.stemp+2,5      of lp|.stemp+2                                      
       arl     18              last avail mem loc to al                         
       sbla    lp|.stemp+2,5      is last word to be dumped greater                
       tpl     3,ic            no-parameter ok                                  
       asa     lp|.stemp+1,5      clip word count in parameter                     
       aos     lp|.stemp+1,5      so as to fit in avail memory                     
       ldq     lp|.stemp+1,5      pick up parameter                                
snpms: adlq    snpmsa            absolutize                                       
       eaa     0                                                                
       tra     bp05                                                        
ckeis: null                                                                     
       ldq     lp|.creis          are there eis registers to be snapped            
       orsq    mo20a      yes - set print location to zero                       
       lcx1    mo20a                                                       
       stx1    mo20a      set print loc to zero                            
       orq     24,dl           # words in reg storage                           
       eax1    rcw                                                         
	odd
       rpd     7,1                                                              
       lda     0,1                                                              
       sta     lp|0,2                                                              
       lda     0,du                                                             
       epp3    lp|0
       tsx1    bp                                                          
       epp3    <gcos_ext_stat_>|[gcos_slave_area_seg],*
       lda     rcw                                                         
       era     7,du            set word count to one                            
       sta     lp|0,2                                                              
       lda     =o770300,du     slew code                                        
       sta     lp|1,2             store slew info in output buffer                 
       adlx2   2,du                                                             
       eax1    0                                                                
       stx1    prea                                                        
       tra     ckore                                                       
rcw:   vfd     18/6,o18/374                                                     
       bci     /*pointer registers & eis info*!2/
snp:   null                    ep1                                              
       lda     lp|.sstke       get ic&i of mme
       adla    1,du                                                             
       ana     =o777777777577  set indicator to slave
       sta     lp|icir                                                        
snp1:  null                                                                     
       lda     lp|icir                                                        
       sta     lp|.sstke
       ldq     lp|.crlal,6
       adlq    lp|icir         address of mme added to qu
       ldq     pr3|0,qu        pick up mme parameter
       staq    lp|.stemp,5                                                         
       ana     =o77,dl         isolate bits used by gecos                       
       ersa    lp|icir       turn them off for printing ir                    
       eax1    .sreg        absolute register pointer
snp7:  stx1    span4a      store register pointer                           
panel: null                                                                     
	lda	lp|.salim+1 	base address register
	sta	lp|icir+1 	store it  
       ldx1    =o770100,du                                                      
"***       q still contains dump parameter                                     
       canq    =o100000,dl     do we slew t-o-p                                 
       tnz     2,ic            yes                                              
       stx1    snp5a       no-slew one line                                 
       ldx2    lp|bufad1  pointer to output buffer
       lda     =o374,dl        device and media code
       stx2    span6a          save record header
       sta     lp|0,2
       adlx2   1,du            bump to first word
       lda     snp5a           slew code
       tsx1    span5+1
snp5:  vfd     o18/772000,18/0                                                  
"***       q still contains dump parameter                                     
       canq    =o200000,dl     do we dump registers                             
       tnz     ckore      no                                               
snpx:  lxl1    mod        is  this  ep3                              
       cmpx1   2,du
       tnz     snp4            no - don't dump even/odd pair
       tsx1    span                                                  
ein:   vfd     18/icir-.sreg+2,o12/2531,1/0,5/31
oin:   vfd     18/icir-.sreg+3,o12/4631,1/0,5/31
shift: oct     011717171717                                                     
       eax1    icr                                                         
       tra     span5                                                       
snp4:  tsx1    span                                                        
icr:   vfd     18/icir-.sreg,o12/3123,1/0,5/30
irr:   vfd     18/icir-.sreg,o12/3151,1/1,5/30
bar:   vfd     18/icir-.sreg+1,o12/2221,1/0,5/30
       vfd     18/6,o12/2551,1/0,5/12      er                                     
       vfd     18/4,o12/2151,1/0,5/31      ar                                     
       vfd     18/5,o12/5051,1/0,5/31      qr                                     
       vfd     18/7,o12/6351,1/0,5/7       tr                                     
       oct     770100000000                                                     
       tsx1    span                                                        
       vfd     18/0,o12/6700,1/0,5/30      x0                                     
       vfd     18/0,o12/6701,1/1,5/30      x1                                     
       vfd     18/1,o12/6702,1/0,5/30      x2                                     
       vfd     18/1,o12/6703,1/1,5/30      x3                                     
       vfd     18/2,o12/6704,1/0,5/30      x4                                     
       vfd     18/2,o12/6705,1/1,5/30      x5                                     
       vfd     18/3,o12/6706,1/0,5/30      x6                                     
       vfd     18/3,o12/6707,1/1,5/30      x7                                     
       oct     770300000000                                                     
       tra     ckeis                                                       
"                                                                        
"              panel dump                                                
"                                                                        
span:  lda     =o374,dl        put out device and media code.            
       stx2    span6a      save record header                        
       sta     lp|0,2                                                       
       adlx2   1,du            bump to first word                        
span5: lda     0,1             pick up parameter                         
       eax4    0,al            test if slew code only.                   
       tze     span1      yes, exit                                 
       cmpx4   =o171717,du                                                      
       tze     1,1                                                              
span4: eaq     0,au            no, pick up register contents
       adlq    span4a
       ldq     lp|0,qu
       ana     =o777700,dl     isolate bcd name                          
       cmpa    =o255100,dl      is this register er?                       
       tnz     2,ic           no-                                        
       qrl     1              yes-align it octally.                      
       ora     =o202017000020    format                                   
       sta     lp|0,2             store register name                       
       adlx2   1,du            bump storage                              
       canx4   1,du            test if bits 0-17                         
       tze     2,ic            are to be converted                       
       tsx3    scon2      yes, convert, store                       
       canx4   =o40,du         test if only 18-35 are convert            
       tze     2,ic            no                                        
       qls     18              yes fetch to high end                     
       anx4    =o36,du         isolate shift for counting                
       lda     =o011717171717     rest of characters and fill              
       arl     0,4             shift character control                   
       tsx3    scon3      convert rest of register                  
       adlx1   1,du            bump to next parameter                    
       tra     span5      back for next one                         
 span1:sta     lp|0,2             end of line, close record                 
       sblx2   span6a      record header                             
span6: ldx4    span6a          store record length to buffer
       stx2    lp|0,4
       adlx2   1,du            increment to point at next                
       adlx2   span6a                                                
       tra     1,1                                                       
"
scon2: lda     1,dl            convert register 36 bits                  
scon3: als     3               convert 36 or less                        
       lls     3                                                         
       tnc     -2,ic           keep going till 1 bit goes thru sign      
       sta     lp|0,2             store converted register                  
       adlx2   1,du                                                      
       tra     0,3             exit                                      
"*******************************************************************************
"*******************************************************************************
"***       ep 1: process mme gesnap                                            
"                calling sequence:                                              
"                  mme gesnap                                                   
"                  vfd 18/a,2/p,1/s,15/n                                        
"                  where a = starting location of snapshot                      
"                        p = panel indicator                                    
"                          00= dump panel, eis registers, and memory            
"                          01= no registers-memory only                         
"                          10= panel and eis registers only                     
"                        s = slew control                                       
"                          0= slew 1 line before snap                           
"                          1= slew t-o-p before snap                            
"                        n = number of words to be snapped                      
"                          0= all the prg's allocated memory starting           
"                             at location ' a ' will be snapped                 
"***                                                                           
gesnip:null                                                                     
       tra     xinit1      go initialize                                    
"***:       ep 2: used to snap the ssa/slave prefix of aborting programs        
"                au = absolute loc of lines to print                            
"                al = # of words to print                                       
"                qu = absolute loc to snap                                      
"                ql = # words to snap                                           
"                x1 = bias to apply to address for snap                         
"                x2 = 3 bcd characters to print with first                      
"                     line of output(m  ,s  , or   )                            
"***:                                                                           
binpt: null                                                                     
	push
	spriap	sp|0	save ap
	ldq	1,dl		change xfer to ep2
	stq	mod
	lda	ap|2,*		get arguments
	ldq	ap|4,*
          ldx1      ap|6,*
          lxl2      ap|6,*
       tra     xinit1      go initialize                                    
"                                                                               
"                                                                               
"***:       ep 3: used to snap registers and memory of aborting programs        
"                ar = ic+i to print                                             
"                qr = dump parameter-same as mme parameter                      
"                x1 = absolute pointer to register storage                      
"***:                                                                           
bord:  null                                                                     
	push
	spriap	sp|0	save ap
	ldq	2,dl		change xfer tp ep3
	stq	mod
	lda	ap|2,*	get arguments
	ldq	ap|4,*
	eax1	.sreg
xinit1:null
       ldx5    0,du		 lower address of slave program (simulated)
       ldx6    0,du		 program number (simulated)
       ldx7    0,du		 processor number (simulated)
       staq    lp|.stemp+8
       sreg    lp|savreg
pinit: null		initialize procedure
"
"	zero temporary storage
"
	stz	workt
	eaa	arglst		first temporary location
	sta	workt
	eaa 	workt		last temporary location
	sbla	workt		length of temporary storage area
	arl	8
	ldx2	0,du
	eax0	0,al
	rptx	0,1
	stz	arglst,2
"
"	construct argument list for call to gcos_write_
"
	lda    	=o000004000004	arg. count and code
	ldq	=o000004,du	descriptor count
	staq	sp|arglst
	epp2	<gcos_ext_stat_>|[prt]	fib pointer
	spri2	sp|arglst+2	 
	epp2	lp|pbufr		record pointer
	spri2	sp|arglst+4	 
	epp2	desc1		descriptor 1
	spri2	sp|arglst+6	 
	epp2	desc2		descriptor 2
	spri2	sp|arglst+8	 
	epp3	<gcos_ext_stat_>|[gcos_slave_area_seg],*	set pointer
          tra       mfalt
desc1:	oct	464000000000
desc2i:	oct   	524000002400
mfalt:    null
"			store bar & set .salim
	sbar	lp|.salim+1	save base address register setting
	ldx5	0,du	zero lower to be sure
	sxl5	lp|.salim+1
	lda	lp|.salim+1
          sta       lp|.salim
	arl	9
	eax5	lp|.salim,*au
	sxl5	lp|.salim
"			get ic & i
	epp2	<gcos_ext_stat_>|[mc]
	ldq	pr2|mc.scu.ilc_word
	adlq	1,dl	mark registers stored
	stq	lp|.sstke		save
"			get machine registers
	ldx2	0,du
	ldx3	0,du
	odd
	rpd	8,1
	ldq	pr2|mc.regs,2
	stq	lp|.sreg,3
"	get pointer registers
	ldx2	0,du
          ldx3      0,du
          odd
          rpd       16,1
          ldq       pr2|mc.prs,2
          stq       lp|eisbf,3
"	get eis info
          ldx2      0,du
          ldx3      16,du
          odd
          rpd       8,1
          ldq       pr2|mc.eis_info,2
          stq       lp|eisbf,3
"	get even and odd instructions
	ldq	pr2|scu.even_inst_word
	stq	lp|icir+2
	ldq	pr2|scu.odd_inst_word
	stq	lp|icir+3
"
xsnp1:	ldq	=o202020,dl
	stq	mo30a
	ldq	snp5
	stq	snp5a
       tra     syot
bp06:  null                                                                     
       sblx1   lp|savreg+5   create print bias                                
       stx1    mo20a       to be applied to print address                   
       sxl2    mo30a       save m/s label                                   
       tra     bp05                                                        
syot:  null                                                                     
       eaa     bufr
       sta     lp|bufad
       adla    1,du
       sta     lp|bufad1
       eaa     pbfnd
       sta     lp|endbuf
       eaa     bufr
       sta     lp|bufr-1
       eaa     eisbf
       sta     lp|.creis
xinix: null                                                                     
       lreg    lp|savreg
xfer:  lxl4    mod
       tra     *+1,4
       tra     snp        ep # 1                                           
       tra     bp06       ep # 2                                           
nopr:  nop     0,du                                                             
bord1: null                    ep # 3                                           
       staq    lp|.stemp,5        save ic+i:dump parameter                         
       sta     lp|icir       ic+i for printing                                
       stx1    span4a     save absolute register pointer                   
       eax1    0,au            instruction at ic is the odd                     
       cana    =o200,dl        is it master or slave                            
       tnz     contd      master                                     
       adlx1   lp|.crlal,6        slave absolutize it                        
       stx1    sizea                                                  
       lda     lp|.salim,5                                                   
       ana     =o776,du        program bound                              
       als     9                                                          
       sbla    1,du            last legal address                         
       adla    lp|.crlal,6        absolutize  it                             
size:  cmpa    sizea           is snap legal                              
       tnc     panel      no, dump panel only                        
contd: null
       lca     =o201,dl                                                   
       ansa    lp|.stemp,5        turn  off  master  mode  bit               
       tra     panel                                                       
"
"	This routine converts the dump record format to print line format
"	and moves therecords to the print buffer (pbufr).
"	This routine is a modification of the write and dump routines
"	of the GCOS SR1/G program GEOT.
"
gwrite:	null
	stx1	wtrsk	save return location
	eax2	bufr	set x2 for block control word
	eax4	pbufr	set x4 for expansion & print buffer
	stx4	talls	initialize output buffer (pbufr) tally
	eax0	bufr	set end of buffer limit
	adlx0	lp|0,2	number of words from record control word
	stx0	nwdpr
writb:	null
	lxl1	lp|0,2	x1 = lower of l.r. cont-wd
	cmpx1	=o060000,du
	tze	cdump	control for dump
	cmpx1	=o070374,du
	tze	dump	dump record
writr:	anx1	=o007700,du
	cmpx1	=o000300,du
	tze	writh	if m/c = 3, accept record
	tra	writc	ignore other m/c's
writh:	null
q.ar:	null
	lda	=o000777,du	mask out all but last nine bits of word
	ora	=o007777,dl	count, media code, and report from
	ansa	lp|0,2	GFRC control word
	ldx0	lp|0,2
	eaa	1,0	move logical record to print buffer
	als	10
	eax0	768,au
	eax3	0,2
	ldx4	talls
	odd
	rpdx	0,1
	lda	lp|0,3	from bufr
	sta	lp|0,4	to pbufr
	stx4	talls
writc:	adlx2	lp|0,2	advance x2 to last word of record
writq:	adlx2	1,du	advance x2 to next l.r.
	sxl2	nwdpr	save l.r. pointer in case of continue
	cmpx2	nwdpr
	trc	writd	skip if we finished buffer
	tra	writb	repeat if more
writd:	null
	eax0	pbufr	develop block length
	stx0	workt
	eax4	-1,4
	sblx4	workt
	sxl4	lp|pbufr	set length in block control word
	ldx1	wtrsk	return address
	ldx5	0,du
	ldx7	0,du
	tra	0,1	return to caller
cdump:	stz	lp|0,2	skip to first logical record
	stz	lp|0,4	zero output block control word
	adlx4	1,du	bump tally
	stx4	talls
	tra	writc
dump:	null
	ldx0	talls
	adlx0	20,du
	cmpx0	lp|endbuf
	trc	writd
dump4: null
dump0:	eax5	0,2	x5 = beginning of logical record
	ldq	lp|1,2	beginning address/line i.d.
	lda	lp|1,5	save address for next line
	ana	-1,du
	ora	=o202020,dl
	sta	lp|1,5
	lda	=o777777,du
	asa	lp|0,5	now only binary data wd count
	adlx2	2,du	first binary data word
dump1:	lda	21,du
	ora	=o374,dl	build control word for 21 word line
	sta	lp|0,4
	stx4	lrcw	save location of rcw
	adlx4	1,du
	ldx0	5,du	convert and store line address
	lda	0,du
	als	3
	lls	3
	sblx0	1,du
	tpl	*-3
	sta	lp|0,4
	adlx4	1,du
	orq	=o202020,dl	trailing blanks after line i.d.
	stq	lp|0,4	store line i.d. and 3 blanks
	adlx4	1,du
	ldx0	5,du	set shift count-1
	ldx1	lp|0,5	set x1 for words/line
	tze	dump2	none if length = 0
	cmpx1	8,du
	tnc	dump3	= exact if <= 8
	ldx1	8,du	= 8 if more in record
dump3:	ldx7	11,du
	ldq	lp|0,2
	als	3
	lls	3
	sblx0	1,du
	tpl	*+4
	ldx0	5,du
	sta	lp|0,4	store expanded word
	adlx4	1,du
	sblx7	1,du
	tpl	dump3+2
	adlx2	1,du
	sblx1	1,du
	tze	dump2	exit
	tmi	dump2	exit
	ldq	=o202000,du	add two trailing blanks after each expanded
	lls	6		data word
	sblx0	1,du
	lls	6
	sblx0	1,du
	tpl	dump3
	ldx0	5,du
	sta	lp|0,4
	adlx4	1,du
	tra	dump3
dump2:	null
	ldq	=o770101010101
	lls	6
	sblx0	1,du
	tpl	*-2
	sta	lp|0,4	store slew characters
	adlx4	1,du
	stx4	talls
dumpa:	null
	ldx1	lp|0,5	no. of binary words in l.r.
	sblx1	8,du
	tze	dump7	end of l.r.
	tmi	dump6	last line was partial
	stx1	lp|0,5
	ldq	lp|1,5
	adlq	8,du
	stq	lp|1,5
dumpb:	null
	eax0	0,4	next address in expansion buffer
	adlx0	20,du
	cmpx0	lp|endbuf
	tnc	dump1
	tra	writd	quick fix
dump6:	eax0	-1,4	correction to rcw for partial record
	sblx0	lrcw
	ldx7	lrcw
	stx0	lp|0,7	record length to rcw
dump7:	eax0	0,4
	adlx0	20,du
	cmpx0	lp|endbuf	has buffer been filled
	tnc	writq+1	no
	sxl2	nwdpr
	cmpx2	nwdpr	has 120 wd buffer been exhausted
	trc	writd	yes - write it out
	tra	writd	quick fix
txtnd:    null
"
"	Temporary
"
	tempd	arglst(5)
	temp	desc2
	temp	prea
	temp	op05a
	temp	op15a
	temp	op20a
	temp	op40a
	temp	mo10a
	temp	mo20a
	temp	mo30a
	temp	comp20a
	temp	wdcnt
	temp	wr10a
	temp	wr20a
	temp	writxa
	temp	snpmsa
	temp	snp5a
	temp	span4a
	temp	span6a
	temp	sizea
	temp	wtrsk
	temp	nwdpr
	temp	talls
	temp	lrcw
	temp	bsn
	temp	workt
	temp	mod
	use	intstat
	join	/link/intstat
icir:	bss	,4		ic+ir,bar,eibf,oibf
bufad:	bss	,1
bufad1:	bss	,1
endbuf:	bss 	,1
	odd
	bss	,1
bufr:	bss	,120
bufnd:    null
pbufr:	bss	,320
pbfnd:	null
eisbf:	bss	,24
	eight
savrgu:	bss	,8
savreg:	bss	,8
"
"	GCOS data base
"
	eight
	segdef	ssa
ssa:	null
	bss	.sstke,8
	eight
	bss	.sreg,8
	bss	.salim,2
	even
	bss	.stemp,10
.crlal:   dec       0
.creis:   bss      ,1
          even
.crmsz:   zero      0,500
 xend: null                                                              
       end
