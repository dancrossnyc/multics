/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(86-04-03,Spitzer), approve(86-04-03,MCR7311),
     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
     remove unused dcls. remove PL/1 IO statement.
                                                   END HISTORY COMMENTS */


/* -alm
   -ssl
   -ct
   -term
   -sem mrds_rst_semantics
   -mla 10
   -table mrds_rst_parse_table
   -recover <nil> <semicolon>
   -mark <identifier>
   -order
   <left_parenthesis>
   <right_parenthesis>
   <comma>
   <semicolon>
   <colon>
   <hyphen>
   <asterisk>
   <plus>
   <path_name>
   <entry_name>
   <positive_integer>
   <identifier>
   <domain>
   <attribute>
   <relation>
   <index>
   <real>
   <complex>
   <fixed>
   <float>
   <binary>
   <decimal>
   <precision>
   <char>
   <bit>
   <varying>
   <nonvarying>
   <aligned>
   <unaligned>
   <check_proc>
   <encode_proc>
   <decode_proc>
   <decode_dcl>
   <nil>
   -parse */



/* IMPORTANT!!! - - - HOW TO UPDATE THIS SOURCE **************************************************************

   This  semantic routine interface, the parser, and the scanner
   were  all  developed with the aide of the automated "lrk" parser
   generator tool.  (see >udd>LIS>Wardd>MTB_lrk.runout for complete
   details)  The  following steps (say in an exec_com) must be done
   when the total parser or any part is to be modified, in order to
   insure proper operation.

   1)  make  changes to the grammar and/or pl1 code representing
   semantics  in  the  "lrk  source"  mrds_rst_parse.lrk via a text
   editor.   This  source  looks like this listing, except that the
   BNF  rules, and lrk options are not enclosed as comments, and it
   is  not indented.  DO NOT MODIFY mrds_rst_semantics.pl1 as those
   changes  would  be  lost  when  lrk is invoked, and would not be
   reflected in any tables generated.

   2) invoke the lrk program to generate

   a) the semantic routine source as pl1 code in
   mrds_rst_semantics.pl1
   from the bnf, control arguments, and pl1 code in the lrk source in
   mrds_rst_parse.lrk

   b) parsing tables for the table driven parsing algorithm(an lrk bottom up parser)
   (the source is in mrds_rst_parse.pl1)
   from an "lrk source" of backus-naur form grammer (this is in
   mrds_rst_parse.lrk) via the command line:

   >udd>LIS>Wardd>lrk  mrds_rst_parse

   the control arguments in the source direct lrk output as follows:
   "-table mrds_rst_parse_table" will build and initialize the basic lrk
   parsing table for the parsing algorithm
   "-sem mrds_rst_semantics" directs semantic output to the appropriate pl1 segment
   the "-order", and "-recover" control arguments affect error handling during parsing

   3) generate the keyword sorted list for the scanner using the
   kwsl   tool.   this  builds  an  include  file  that  is  a  pl1
   declaration  for  keyword  encodings.   the  source  of  keyword
   synonyms  is  in mrds_rst_keywords.syn and is in the development
   library  source  directory  the  tool is invoked via the command
   line:
   >udd>LIS>Wardd>kwsl mrds_rst_parse mrds_rst_keywords mrds_rst_keywords
   where arguments 1 to 3 are the lrk source, kwsl
   source, and include file name

   4) generate the error recovery skip table from the lrk tables
   by the following command line :
   udd>LIS>Wardd>msd mrds_rst_parse mrds_rst_skip_table
   where the first argument is the lrk source, the
   other the include file name

   5)  generate  the error message terminal symbols file via the
   command line:
   ted -abort >udd>LIS>Wardd>lrk|hal_dcl mrds_rst_parse mrds_rst_terminals
   where the first argument is the lrk source, the
   last the include file name

   6)  build  the ascii to decimal transliteration include file,
   input  is  is  mrds_rst_translate.mad  which may be found in the
   development library source directory.

   7)  add  include  file  comment  heading/trailing banners via
   command lines:
   ted -abort >udd>LIS>Wardd>Wardd|incl_cmt mrds_rst_parse_table
   ted -abort >udd>LIS>Wardd>Wardd|incl_cmt mrds_rst_skip_table

   8)  indent and compile the three affected parts of the parser
   on:
   mrds_rst_semantics.pl1
   mrds_rst_parse.pl1
   mrds_rst_scanner.pl1

   the   modification  to  the  parser  is  now  complete.   THE
   FOLLOWING EXEC COM DOES THE ABOVE TASKS:

   &     indent the lrk source
   &
   ted -abort >udd>LIS>Wardd>lrk|ind mrds_rst_parse.lrk
   &
   &     generate the lrk tables from  mrds_rst_parse.lrk  source  bnf
   &     with  control  arguments  inside  that  source  output is the
   &     mrds_rst_parse  object  table  for  the  parser  the   source
   &     mrds_rst_semantics.pl1,  and  the  intermediate  lrk  results
   &     mrds_rst_parse.result and several  mrds_rst_parse.lrk.*  segs
   &     with a listing of mrds_rst_parseg.list
   &
   >udd>LIS>Wardd>lrk mrds_rst_parse
   &
   &     generate the  keyword  sorted  list  include  file  from  the
   &     mrds_rst_keywords.syn    source    and    the    lrk   output
   &     mrds_rst_parse.result     the     output     produced      is
   &     mrds_rst_keywords.incl.pl1
   &
   >udd>LIS>Wardd>kwsl mrds_rst_parse mrds_rst_keywords mrds_rst_keywords
   &
   &     generate  the  error  skip  table  include  the   source   is
   &     mrds_rst_parse.result, output is mrds_rst_skip_table.incl.pl1
   &
   >udd>LIS>Wardd>msd mrds_rst_parse mrds_rst_skip_table
   &
   &     generate the terminal symbols  include  file  the  source  is
   &     mrds_rst_parse.result, output is mrds_rst_terminals.incl.pl1
   &
   ted -abort >udd>LIS>Wardd>lrk|hal_dcl mrds_rst_parse mrds_rst_terminals
   &
   &     build the ascii to decimal transliteration include file input
   &     is          mrds_rst_translate.mad,         output         is
   &     mrds_rst_translate.incl.pl1
   &
   ted -abort >udd>LIS>Wardd>Wardd|mad mrds_rst_translate.mad
   &
   &     put include file headers/trailer comments in  this  adds  the
   &     BEGIN INCLUDE FILE.... and END INCLUDE FILE comments
   &
   ted -abort >udd>LIS>Wardd>Wardd|incl_cmt mrds_rst_parse_table
   ted -abort >udd>LIS>Wardd>Wardd|incl_cmt mrds_rst_skip_table
   &
   &     compile parser, scanner, and semantics PL1 routines
   &
   pl1  mrds_rst_semantics
   pl1  mrds_rst_parse
   pl1  mrds_rst_scanner
   &
   &     get rid of lrk generated segments no longer needed they  were
   &     used as intermediate results by lrk and it's tools
   &
   dl mrds_rst_parse.lrk.TL
   dl mrds_rst_parse.lrk.THL
   dl mrds_rst_parse.lrk.TC
   dl mrds_rst_parse.lrk.DPDA
   dl mrds_rst_parse.result

   ***************************************************************************** */

/* ******************************************************
   *                                                    *
   *                                                    *
   * Copyright (c) 1972 by Massachusetts Institute of   *
   * Technology and Honeywell Information Systems, Inc. *
   *                                                    *
   *                                                    *
   ****************************************************** */

/* HISTORY:

   originally written by jim gray - - july 1978

   Modified by Jim Gray  -  -  Jan.  1980,  to  add  packed  decimal
   capability.

   80-12-12 Jim Gray : added -mark <identifier> control to LRK input
   file  in  order  to be able to un-reserve keywords for CMDB. Also
   changed <cmdb_statement> and <domain_stmt> rules to avoid <empty>
   case  so  that could run with 6.2 LRK (previously used 5.5). This
   means that a domain keyword must always be  present,  even  if  a
   define does not add new domains.


   81-06-04 Jim Gray : removed unused rules and code, this  included
   blocked  file  and foreign key statements, the -check option, and
   the  restructuring  directives.  Also  re-did  scanner  -  parser
   constants according to the new -order statment.

   81-10-15 Davids: added rules to allow declarations of the form:
   .   varying char (64)
   .   nonvarying char (64)
   .   varying bit (64)
   .   nonvarying bit (64)
   Also modified  the  example  ec  and  explantion  before  it  and
   justified all the text.
*/

mrds_rst_semantics: procedure (rule, alternate, stkp, ls_top); goto SKIP_ENTRIES;

mrds_rst_semantics$rule_set: entry (); rule_sw = ^rule_sw; goto return_label;

/* DESCRIPTION:
   semantics routines for mrds restructuring
   it is called by the lrk parser whenever a rule is found to aply
   giving the rule number, alternate number, the stack pointer,
   and the current top of the lexical stack
   a goto the appropiate semantic action is given based on the rule number,
   and the semantic action routine implements the "meaning" of the parse
   tree which the lrk parser has determined that the syntax represents.
   after the action, it returns to the parser.

   entry mrds_rst_semantics$init should be called first to initialize

   an alternate entry mrds_rst_semantics$rule_set - allows debug output of rule numbers processed to
   be switched on or off on succeeding calls, it has no parameters
*/

/* PARAMETERS:
   rule - - (input) the rule number of the bnf at which the lrk parser
   has found the syntax to conform to, before the reduction takes place.

   alternate - - (input) the alternative of this rule which is being used

   stkp - - (input) the lexical stack pointer

   ls_top - - (input) current top of the lexical stack

   rsc_ptr - - (input) for the init entry only, a pointer to the restructure control segment
*/

/* initialization entry */

mrds_rst_semantics$init: entry (rsc_ptr);

	static_rsc_ptr = rsc_ptr;
	rsc.skip_scanner_conversion = OFF;

	call mrds_rst_rsc_alloc (static_rsc_ptr, DIRECTIVE, directive_ptr);
	rsc_ptr -> rsc.directive_ptr = directive_ptr;
	directive.type = 0;				/* no directive seen yet */
	directive.undefine.active = OFF;
	directive.undefine.seen = OFF;
	directive.define.active = OFF;
	directive.define.seen = OFF;
	directive.redefine.active = OFF;
	directive.redefine.seen = OFF;

	call mrds_rst_rsc_alloc (static_rsc_ptr, STMT, stmt_ptr);
	rsc_ptr -> rsc.stmt_ptr = stmt_ptr;
	do i = 1 by 1 to hbound (stmt_ptr -> stmt, 1);
	     stmt (i).domain.active = OFF;
	     stmt (i).domain.number = 0;
	     stmt (i).attribute.active = OFF;
	     stmt (i).attribute.number = 0;
	     stmt (i).relation.active = OFF;
	     stmt (i).relation.number = 0;
	     stmt (i).file.active = OFF;
	     stmt (i).file.number = 0;
	     stmt (i).foreign_key.active = OFF;
	     stmt (i).foreign_key.number = 0;
	     stmt (i).index.active = OFF;
	     stmt (i).index.number = 0;
	end;

	max_string_size = mrds_data_$max_string_size;
	max_fixed_bin_17 = fixed (binary (copy ("1", 17) || "b"));
	max_fixed_bin_71 = fixed (binary (copy ("1", 71) || "b"));

	db_model_path = rtrim (rsc_ptr -> rsc.temp_dir) || ">db_model"; /* path name for the db_model must be saved */

	call mrds_rst_rsc_alloc (static_rsc_ptr, TOKEN, name_ptr); /* space for token from stack */
	call mrds_rst_rsc_alloc (static_rsc_ptr, TOKEN, temp_source_ptr); /* space for string to be multiplied */

	goto return_label;

/* *******************************************************************

   normal entry for semantics case structure

   ****************************************************************** */



SKIP_ENTRIES: ;



/* set local versions of parameters */

	lex_stack_ptr = stkp;
	stack_top = ls_top;

/* output the rule about to be executed, if debug switch is on */

	if ^rule_sw then ;
	else call ioa_ ("rule ^d", rule);

/* go do the case that this semantic rule number specifies */

	goto rule_label (rule);

/* **************************************************************************

   definitions for statements within the directives

   ************************************************************************** */



/* <source> ::= <domain_stmt><attribute_stmt><relation_stmt><index_stmt>  ! */

rule_label (0001):

/* define and redefine directives are made up of any combination of the six statement keywords
   followed by the specifications for the items to be newly created
   or to be given a new definition */

	goto return_label;

/* <empty> ::=  ! */

rule_label (0002):

/* null statement */

	goto return_label;


/* <domain_keyword> ::= <domain><colon>  ! */

rule_label (0003):

/* start of domain delete/define/redefine, set it active */

	if directive.type = 0 then do;		/* no other directive seen */

/* cmdb source,  set up cmdb seen and active, check that this is a genuine cmdb command */

		directive.type = CMDB;
		directive.cmdb.seen = ON;
		directive.cmdb.active = ON;
	     end;
	stmt (directive.type).domain.active = ON;
	goto return_label;

/* <attribute_keyword> ::= <attribute><colon>  ! */

rule_label (0004):

/* start of attribute delete/define/redefine, set it active */

	stmt (directive.type).attribute.active = ON;
	goto return_label;

/* <relation_keyword> ::= <relation><colon>  ! */

rule_label (0005):

/* start of relation delete/define/redefine, set it active */

	stmt (directive.type).relation.active = ON;
	goto return_label;



/* <index_keyword> ::= <index><colon>  ! */

rule_label (0006):

/* start of index delete/define/redefine, set it active */

	stmt (directive.type).index.active = ON;
	goto return_label;

/* ************************************************************

   all the following rules apply to define and redefine statement lists only

   ***************************************************************** */


/* <domain_stmt> ::= <domain_keyword><semicolon> |  <domain_keyword><domain_list><semicolon> ! */

rule_label (0007):

/* domain processing complete, set it inactive, after defining default attributes for new domains */

	call mrds_rst_attribute_cleanup (static_rsc_ptr);
	stmt (directive.type).domain.active = OFF;
	goto return_label;


/* <domain_list> ::= <domain_spec>  ! */

rule_label (0008):
	goto return_label;


/* <domain_list> ::= <domain_list><comma><domain_spec>  ! */

rule_label (0009):
	goto return_label;


/* <domain_spec> ::= <domain_name><declaration><check_list>  ! */

rule_label (0010):

/* call the semantic handler for domains */

	call mrds_rst_domain_handler (static_rsc_ptr, domain_list_ptr);
	stmt (directive.type).domain.number = stmt (directive.type).domain.number + 1;
	goto return_label;




/* <domain_name> ::= <identifier>  ! */

rule_label (0011):

/* set up domain structure and get the domain name */

	call mrds_rst_rsc_alloc (static_rsc_ptr, DOMAIN, domain_list_ptr);
	call domain_initialize ();
	call set_declaration_defaults (domain_list_ptr -> domain.descriptor);
	goto return_label;


/* <declaration> ::= <number_declare>  ! */

rule_label (0012):

/* build descriptor for number,  set packing, precision, scale, and type */

	if aligned then
	     descr_ptr -> descriptor.packed = OFF;
	else descr_ptr -> descriptor.packed = ON;

	call set_precision_and_scale ();
	call set_number_type ();
	goto return_label;


/* <declaration> ::= <character_declare>  ! */

rule_label (0013):

/* build descriptor for character string,  set type, packed, and size */

	call set_string_size_and_packing ();
	if nonvarying then
	     descr_ptr -> descriptor.type = 21;
	else descr_ptr -> descriptor.type = 22;
	goto return_label;


/* <declaration> ::= <bit_declare>  ! */

rule_label (0014):

/* build descriptor for bit string, set type, packed, and size */

	call set_string_size_and_packing ();
	if nonvarying then
	     descr_ptr -> descriptor.type = 19;
	else descr_ptr -> descriptor.type = 20;
	goto return_label;

domain_initialize: procedure ();

/* initialize the domain structure */

	domain_list_ptr -> domain.name = get_name (stack_top, 32);
	domain_list_ptr -> domain.descriptor = OFF;
	domain_list_ptr -> domain.varying_avg_length = 0;
	domain_list_ptr -> domain.options = OFF;
	domain_list_ptr -> domain.pad = OFF;
	domain_list_ptr -> domain.check.flag = OFF;
	domain_list_ptr -> domain.check.pad = OFF;
	domain_list_ptr -> domain.check.stack_ptr = null ();
	domain_list_ptr -> domain.check.stack_size = 0;
	domain_list_ptr -> domain.check_proc.flag = OFF;
	domain_list_ptr -> domain.check_proc.pad = OFF;
	domain_list_ptr -> domain.check_proc.path = BLANK;
	domain_list_ptr -> domain.check_proc.entry = BLANK;
	domain_list_ptr -> domain.encode_proc.flag = OFF;
	domain_list_ptr -> domain.encode_proc.pad = OFF;
	domain_list_ptr -> domain.encode_proc.path = BLANK;
	domain_list_ptr -> domain.encode_proc.entry = BLANK;
	domain_list_ptr -> domain.decode_proc.flag = OFF;
	domain_list_ptr -> domain.decode_proc.pad = OFF;
	domain_list_ptr -> domain.decode_proc.path = BLANK;
	domain_list_ptr -> domain.decode_proc.entry = BLANK;
	domain_list_ptr -> domain.decode_dcl.flag = OFF;
	domain_list_ptr -> domain.decode_dcl.pad = OFF;
	domain_list_ptr -> domain.decode_dcl.descriptor = OFF;
	domain_list_ptr -> domain.line_num = get_line_number (stack_top);


/* set up duplicate check_list option flags */

	decode_dcl_seen = OFF;
	decode_proc_seen = OFF;
	encode_proc_seen = OFF;
	check_seen = OFF;
	multiplier = 1;
	string_average_length = 0;
	avg_length_seen = OFF;
	decode_dcl_mesg = "";


     end;

set_declaration_defaults: procedure (current_descriptor);


/* set up defaults */

	decimal = OFF;
	float = OFF;
	real = ON;
	aligned = ON;
	nonvarying = ON;
	string_length = 1;
	scale_factor = 0;

/* set up overlays and descriptor constants */

	descr_ptr = addr (current_descriptor);

	descr_ptr -> descriptor.version = ON;
	descr_ptr -> descriptor.number_dims = OFF;	/* dimension = 0 */
	num_dims = 0;

/* set up duplication and declaration flags */

	size_seen = OFF;
	type_seen = OFF;
	representation_seen = OFF;
	base_seen = OFF;
	precision_seen = OFF;
	alignment_seen = OFF;
	fixed_varying_seen = OFF;
	scale_seen = OFF;


	declare current_descriptor	 bit (36) aligned;	/* current descriptor to point to for this declaration */

     end;

set_number_type: procedure ();

/* set data type for number based on float/short/decimal/real attributes */
/* packed decimal data types 43-46, depend on the aligned attribute as well */


	if ^decimal then
	     if real then
		if ^float then
		     if short then
			descr_ptr -> descriptor.type = 1;
		     else descr_ptr -> descriptor.type = 2;
		else if short then
		     descr_ptr -> descriptor.type = 3;
		else descr_ptr -> descriptor.type = 4;
	     else if ^float then
		if short then
		     descr_ptr -> descriptor.type = 5;
		else descr_ptr -> descriptor.type = 6;
	     else if short then
		descr_ptr -> descriptor.type = 7;
	     else descr_ptr -> descriptor.type = 8;
	else if real then
	     if ^float then do;
		     if aligned then
			descr_ptr -> descriptor.type = 9;
		     else descr_ptr -> descriptor.type = 43;
		end;
	     else do;
		     if aligned then
			descr_ptr -> descriptor.type = 10;
		     else descr_ptr -> descriptor.type = 44;
		end;
	else if ^float then do;
		if aligned then
		     descr_ptr -> descriptor.type = 11;
		else descr_ptr -> descriptor.type = 45;
	     end;
	else do;
		if aligned then
		     descr_ptr -> descriptor.type = 12;
		else descr_ptr -> descriptor.type = 46;
	     end;

     end;

/* *************************************************************

   number precision and scale attribute processing

   ************************************************************ */


set_precision_and_scale: procedure ();

/* set default precision or check user values against limits */

	if ^precision_seen then

/* no precision given, set defaults */

	     if ^float then
		if ^decimal then
		     saved_precision = 17;
		else saved_precision = 7;
	     else if ^decimal then
		saved_precision = 27;
	     else saved_precision = 10;

/* check user's precision */

	else if ^decimal then
	     if ^float then
		if saved_precision >= 1 & saved_precision <= 71 then ;
		else do;
			call ioa_$rs ("^a ^a^a^a^a ^d ^a", message, message_length,
			     "The", decode_dcl_mesg, "declaration of domain """, domain_list_ptr -> domain.name,
			     """ on line", domain_list_ptr -> domain.line_num,
			     "has precision <1 or >71 for fixed binary number, using ""71"" instead.");
			call mrds_rst_error (static_rsc_ptr, 2 /* severity */,
			     mrds_error_$rst_bad_declaration, (message));
			saved_precision = 71;
		     end;
	     else if saved_precision >= 1 & saved_precision <= 63 then ;
	     else do;
		     call ioa_$rs ("^a ^a^a^a^a ^d ^a", message, message_length,
			"The", decode_dcl_mesg, "declaration of domain """, domain_list_ptr -> domain.name,
			""" on line", domain_list_ptr -> domain.line_num,
			"has precision <1 or >63 for float binary number, using ""63"" instead.");
		     call mrds_rst_error (static_rsc_ptr, 2 /* severity */, mrds_error_$rst_bad_declaration, (message));
		     saved_precision = 63;
		end;
	else if saved_precision >= 1 & saved_precision <= 59 then ;
	else do;
		call ioa_$rs ("^a ^a^a^a^a ^d ^a", message, message_length,
		     "The", decode_dcl_mesg, "declaration of domain """, domain_list_ptr -> domain.name,
		     """ on line", domain_list_ptr -> domain.line_num,
		     "has precision <1 or >59 for a decimal number, using ""59"" instead.");
		call mrds_rst_error (static_rsc_ptr, 2 /* severity */, mrds_error_$rst_bad_declaration, (message));
		saved_precision = 59;
	     end;

	descr_ptr -> arith_size.precision = saved_precision;





/* set precision type as short or long */

	if decimal then ;
	else if ^float then
	     if saved_precision <= 35 then
		short = ON;
	     else short = OFF;
	else if saved_precision <= 27 then
	     short = ON;
	else short = OFF;

/* check on the scale factor */

	if ^(float & scale_seen) then ;
	else do;
		call ioa_$rs ("^a ^a^a^a^a ^d ^a", message, message_length,
		     "The", decode_dcl_mesg, "declaration of domain """, domain_list_ptr -> domain.name,
		     """ on line", domain_list_ptr -> domain.line_num,
		     "is declared float, it can not have scale specified,  --- the scale is ignored!!");
		call mrds_rst_error (static_rsc_ptr, 2 /* severity */, mrds_error_$rst_bad_declaration, (message));
		scale_factor = 0;
	     end;

	if scale_factor >= -128 & scale_factor <= 127 then ;
	else do;
		if scale_factor < 0 then
		     scale_factor = -128;
		else scale_factor = +127;
		call ioa_$rs ("^a ^a^a^a^a ^d ^a^d^a", message, message_length,
		     "The", decode_dcl_mesg, "declaration of domain """, domain_list_ptr -> domain.name,
		     """ on line", domain_list_ptr -> domain.line_num,
		     "has a scale factor <-128 or >127, using """, scale_factor, """ instead.");
		call mrds_rst_error (static_rsc_ptr, 2 /* severity */, mrds_error_$rst_bad_declaration, (message));
	     end;

	descr_ptr -> arith_size.scale = scale_factor;

     end;

set_string_size_and_packing: procedure ();

/* check alignment and varying attributes to determine packing,
   and set size from the string length */

	if nonvarying then
	     if alignment_seen then ;
	     else aligned = OFF;
	else if aligned then ;
	else do;
		aligned = ON;
		call ioa_$rs ("^a ^a^a^a^a ^d ^a", message, message_length,
		     "The", decode_dcl_mesg, "declaration of domain """, domain_list_ptr -> domain.name,
		     """ on line", domain_list_ptr -> domain.line_num,
		     "is being corrected, since varying strings must be ""aligned"".");
		call mrds_rst_error (static_rsc_ptr, 1 /* severity */, mrds_error_$rst_bad_declaration, (message));
	     end;


	if aligned then
	     descr_ptr -> descriptor.packed = OFF;
	else descr_ptr -> descriptor.packed = ON;

	descr_ptr -> string_size.length = string_length;

/* for normal declarations(not decode_dcl), and varying strings, remember the average length */

	if decode_dcl_mesg ^= "" then ;
	else if ^nonvarying then
	     domain_list_ptr -> domain.varying_avg_length = string_average_length;
	else if ^avg_length_seen then ;
	else do;
		call ioa_$rs ("^a^a ^a^a^a^a ^d^a", message, message_length,
		     "The average length attribute is not allowed with nonvarying strings",
		     ", it is being ignored in the", decode_dcl_mesg, "declaration for domain """,
		     domain_list_ptr -> domain.name,
		     """ on line", domain_list_ptr -> domain.line_num, ".");
		call mrds_rst_error (static_rsc_ptr, 1 /* severity */, mrds_error_$rst_inconsis_option, (message));
	     end;

     end;

/* *********************************************

   attributes in number declarations can be in any order
   duplicates and contradictory attributes are checked for

   ***************************************** */

/* <number_declare> ::= <number_spec_list>  ! */

rule_label (0015):
	goto return_label;


/* <number_spec_list> ::= <number_spec>  ! */

rule_label (0016):
	goto return_label;


/* <number_spec_list> ::= <number_spec_list><number_spec>  ! */

rule_label (0017):
	goto return_label;


/* <number_spec> ::= <real>  ! */

rule_label (0018):

/* set real attribute */

	if duplicate ("real or complex", addr (type_seen)) then ;
	else real = ON;
	goto return_label;


/* <number_spec> ::= <complex> ! */

rule_label (0019):

/* set complex attribute */

	if duplicate ("real or complex", addr (type_seen)) then ;
	else real = OFF;
	goto return_label;


/* <number_spec> ::= <fixed>  ! */

rule_label (0020):

/* set fixed attribute */

	if duplicate ("float or fixed", addr (representation_seen)) then ;
	else float = OFF;
	goto return_label;


/* <number_spec> ::= <float>  ! */

rule_label (0021):

/* set float attribute */

	if duplicate ("float or fixed", addr (representation_seen)) then ;
	else float = ON;
	goto return_label;


/* <number_spec> ::= <binary>  ! */

rule_label (0022):

/* set binary attribute */

	if duplicate ("binary or decimal", addr (base_seen)) then ;
	else decimal = OFF;
	goto return_label;


/* <number_spec> ::= <decimal>  ! */

rule_label (0023):

/* set decimal attribute */

	if duplicate ("binary or decimal", addr (base_seen)) then ;
	else decimal = ON;
	goto return_label;


/* <number_spec> ::= <precision><precision_stmt>  ! */


rule_label (0024):
	goto return_label;


/* <number_spec> ::= <precision_stmt>  ! */

rule_label (0025):
	goto return_label;

/* <sign> ::= <plus>  ! */

rule_label (0026):

/* set positive sign */

	sign_flag = OFF;
	goto return_label;


/* <sign> ::= <hyphen>  ! */

rule_label (0027):

/* set negative sign */

	sign_flag = ON;
	goto return_label;


/* <sign> ::= <empty>  ! */

rule_label (0028):

/* set sign positive */

	sign_flag = OFF;
	goto return_label;

/* <precision_stmt> ::= <left_parenthesis> <positive_integer> <comma><sign> <positive_integer> <right_parenthesis>  ! */

rule_label (0029):

/* set precision attribute with scale factor (negative) */

	if duplicate ("precision", addr (precision_seen)) then ;
	else do;
		saved_precision = get_fixed_value (stack_top - 4, max_fixed_bin_71);
		if sign_flag then
		     scale_factor = -get_fixed_value (stack_top - 1, max_fixed_bin_71);
		else scale_factor = get_fixed_value (stack_top - 1, max_fixed_bin_71);
		scale_seen = ON;
	     end;
	goto return_label;


/* <precision_stmt> ::= <left_parenthesis> <positive_integer> <right_parenthesis>  ! */

rule_label (0030):

/* set precision attribute */

	if duplicate ("precision", addr (precision_seen)) then ;
	else saved_precision = get_fixed_value (stack_top - 1, max_fixed_bin_71);
	goto return_label;


/* <number_spec> ::= <alignment>  ! */

rule_label (0031):
	goto return_label;


/* <alignment> ::= <aligned>  ! */

rule_label (0032):

/* set aligned attribute */

	if duplicate ("aligned or unaligned", addr (alignment_seen)) then ;
	else aligned = ON;
	goto return_label;


/* <alignment> ::= <unaligned>  ! */

rule_label (0033):

/* set unaligned attribute */

	if duplicate ("aligned or unaligned", addr (alignment_seen)) then ;
	else aligned = OFF;
	goto return_label;

/* *******************************************************

   make sure that attributes are not repeated in a declaraion

   ************************************************************* */


duplicate: procedure (attribute, flag_ptr) returns (bit (1));

/* check to see if this attribute has already been used in this declaration */

	if ^flag_ptr -> flag_overlay then do;

/* attribute not yet seen, flag it as seen, return no duplication */

		flag_ptr -> flag_overlay = ON;
		duplication = OFF;
	     end;

	else do;

/* attribute duplicate, issue error, return duplication */

		duplication = ON;
		call ioa_$rs ("^a^a^a ^a^a^a^a ^d^a", message, message_length,
		     "The attribute """, attribute, """ appears more than once in the",
		     decode_dcl_mesg, "declaration of domain """,
		     domain_list_ptr -> domain.name,
		     """ on line", domain_list_ptr -> domain.line_num,
		     ", the first occurence will be used.");
		call mrds_rst_error (static_rsc_ptr, 2 /* severity */, mrds_error_$rst_bad_declaration, (message));
	     end;

	return (duplication);

	declare duplication		 bit (1);		/* ON => this is a previously seen attribute */
	declare flag_ptr		 ptr;		/* pointer to attribute flag */
	declare flag_overlay	 bit (1) based;	/* overlay structure for flag */
	declare attribute		 char (*);	/* attribute name being checked */

     end;

/* ***********************************************************************

   bit and character string declarations can have the attributes in any order
   but duplicates will be flagged as errors and ignored
   as with number precision and scale, string size is checked for a legal range

   **************************************************************************** */


/* <bit_declare> ::= <bit><string_type>  ! */

rule_label (0034):
	goto return_label;

/* <bit_declare> ::= <varying><bit><string_type> ! */

rule_label (0035):
	if duplicate ("varying or nonvarying", addr (fixed_varying_seen)) then ;
	else nonvarying = OFF;
	goto return_label;

/* <bit_declare> ::= <nonvarying><bit><string_type> ! */

rule_label (0036):
	if duplicate ("varying or nonvarying", addr (fixed_varying_seen)) then ;
	else nonvarying = ON;
	goto return_label;

/* <string_type> ::= <string_attr_list>  ! */

rule_label (0037):
	goto return_label;


/* <string_type> ::= <empty>  ! */

rule_label (0038):
	goto return_label;


/* <string_attr_list> ::= <string_attr>  ! */

rule_label (0039):
	goto return_label;


/* <string_attr_list> ::= <string_attr_list><string_attr>  ! */

rule_label (0040):
	goto return_label;


/* <string_attr> ::= <left_parenthesis><positive_integer><right_parenthesis>   ! */

rule_label (0041):

/* set string length attribute(and default average length for normal declarations) */

	if duplicate ("string size", addr (size_seen)) then ;
	else do;
		temp_number = get_fixed_value (stack_top - 1, max_fixed_bin_71);
		call string_size_check (temp_number);
		string_length = temp_number;
		avg_length_seen = OFF;
		if decode_dcl_mesg ^= "" then ;
		else string_average_length = string_length;
	     end;
	goto return_label;


/* <string_attr> ::= <alignment>  ! */

rule_label (0042):
	goto return_label;


/* <string_attr> ::= <varying>  ! */

rule_label (0043):

/* set varying attribute */

	if duplicate ("varying or nonvarying", addr (fixed_varying_seen)) then ;
	else nonvarying = OFF;
	goto return_label;


/* <string_attr> ::= <nonvarying> ! */

rule_label (0044):

/* set nonvarying attribute */

	if duplicate ("varying or nonvarying", addr (fixed_varying_seen)) then ;
	else nonvarying = ON;
	goto return_label;

/* <character_declare> ::= <char><string_type>  ! */

rule_label (0045):
	goto return_label;

/* <character_declare> ::= <varying><char><string_type> ! */

rule_label (0046):
	if duplicate ("varying or nonvarying", addr (fixed_varying_seen)) then ;
	else nonvarying = OFF;
	goto return_label;

/* <character_declare> ::= <nonvarying><char><string_type> ! */

rule_label (0047):
	if duplicate ("varying or nonvarying", addr (fixed_varying_seen)) then ;
	else nonvarying = ON;
	goto return_label;

string_size_check: procedure (number);

/* make sure number for string length is less than maximum allowable */

	if number <= max_string_size then ;
	else do;

		call ioa_$rs ("^a^d^a ^d^a ^a^a^a^a ^d^a", message, message_length,
		     "String size """, number, """ exceeds the maximum allowable length of",
		     max_string_size, ", using the maximum instead in the",
		     decode_dcl_mesg, "declaration of domain """,
		     domain_list_ptr -> domain.name,
		     """ on line", domain_list_ptr -> domain.line_num, ".");
		call mrds_rst_error (static_rsc_ptr, 2 /* severity */, mrds_error_$rst_bad_declaration, (message));
		number = max_string_size;
	     end;



/* fixup unwanted zero values */

	if number ^= 0 then ;
	else do;
		number = 1;
		call ioa_$rs ("^a ^a^a^a^a ^d^a", message, message_length,
		     "Illegal zero value is being replaced by ""1"" in size attribute of",
		     decode_dcl_mesg, "declaration for domain """,
		     domain_list_ptr -> domain.name,
		     """ on line", domain_list_ptr -> domain.line_num, ".");
		call mrds_rst_error (static_rsc_ptr, 2 /* severity */, mrds_error_$rst_bad_declaration, (message));
	     end;

	declare number		 fixed binary (71); /* number under test as string length */

     end;

/* *****************************************************************

   the check, check_proc, encode_proc, decode_proc options may be in any order
   however, check and check_proc are mutually exclusive options

   ***************************************************************** */

/* <check_list> ::= <proc_list>  ! */

rule_label (0048):

/* set options present */

	domain_list_ptr -> domain.options = ON;
	goto return_label;

/* <check_list> ::= <empty>  ! */

rule_label (0049):

/* set no options present */

	domain_list_ptr -> domain.options = OFF;
	goto return_label;

/* <proc_list> ::= <proc_list><proc_item>  ! */

rule_label (0050):
	goto return_label;

/* <proc_list> ::= <proc_item>  ! */

rule_label (0051):
	goto return_label;

/* <proc_item> ::= <check_proc_option>  ! */

rule_label (0052):
	goto return_label;

/* <proc_item> ::= <encode_proc_option>  ! */

rule_label (0053):
	goto return_label;

/* <proc_item> ::= <decode_proc_option>  ! */

rule_label (0054):
	goto return_label;

/* <proc_item> ::= <decode_declaration>  ! */

rule_label (0055):
	goto return_label;

/* *****************************

   decode declaration option

   ****************************** */


/* <decode_declaration> ::= <decode_dcl_keyword><declaration>  ! */

rule_label (0056):

/* decode declaration finished, restore normal declaration pointers */

	descr_ptr = saved_descr_ptr;
	decode_dcl_mesg = "";

/* if a duplicate caused the descriptor to be saved, restore it */

	if ^descriptor_saved then ;
	else domain_list_ptr -> domain.decode_dcl.descriptor = saved_decode_descriptor;
	goto return_label;

/* <decode_dcl_keyword> ::= <hyphen><decode_dcl>  ! */

rule_label (0057):

/* set up for handling a decode declaration, save normal declaration pointers */

	saved_descr_ptr = descr_ptr;
	call set_declaration_defaults (domain_list_ptr -> domain.decode_dcl.descriptor);

/* only set this option on if this is not a duplicate
   else remember the first declaration seen(via the descriptor) */

	if duplicate ("decode_dcl", addr (decode_dcl_seen)) then do;
		descriptor_saved = ON;
		saved_decode_descriptor = domain_list_ptr -> domain.decode_dcl.descriptor;
	     end;
	else do;
		domain_list_ptr -> domain.decode_dcl.flag = ON;
		descriptor_saved = OFF;
	     end;

/* set up error messages for decode declarations */

	decode_dcl_mesg = "decode_";
	goto return_label;

/* ************************************************

   gather pathnames and entry names for procedure options

   ************************************************** */


/* <check_proc_option> ::= <hyphen><check_proc><path_name><entry_name>  ! */

rule_label (0058):

/* set up check procedure path and entry names */

	temp_index = stack_top - 1;
	call get_check_path_entry ();
	goto return_label;


/* <check_proc_option> ::= <hyphen><check_proc><path_name>  ! */

rule_label (0059):

/* set up check procedure pathname and missing entry name */

	temp_index = stack_top;
	call get_check_path_entry ();
	goto return_label;


/* <encode_proc_option> ::= <hyphen><encode_proc><path_name><entry_name>  ! */

rule_label (0060):

/* set up encode procedure path and entry names */

	temp_index = stack_top - 1;
	call get_encode_path_entry ();
	goto return_label;


/* <encode_proc_option> ::= <hyphen><encode_proc><path_name>  ! */

rule_label (0061):

/* set up encode pathname and missing entryname */

	temp_index = stack_top;
	call get_encode_path_entry ();
	goto return_label;


/* <decode_proc_option> ::= <hyphen><decode_proc><path_name><entry_name>  ! */

rule_label (0062):

/* set up decode procedure path and entry names */

	temp_index = stack_top - 1;
	call get_decode_path_entry ();
	goto return_label;



/* <decode_proc_option> ::= <hyphen><decode_proc><path_name>  ! */

rule_label (0063):

/* set up decode procedure pathname and missing entryname */

	temp_index = stack_top;
	call get_decode_path_entry ();
	goto return_label;

get_check_path_entry: procedure ();

/* get pathname from the stack and entry name if there,
   else get entry name from path name.  Set this option on */

	if duplicate ("check_proc", addr (check_seen)) then ;
	else do;
		domain_list_ptr -> domain.check_proc.flag = ON;
		domain_list_ptr -> domain.check_proc.path = get_name (temp_index, 168);
		if temp_index = stack_top then
		     domain_list_ptr -> domain.check_proc.entry = get_entry (domain_list_ptr -> domain.check_proc.path);
		else domain_list_ptr -> domain.check_proc.entry = get_name (stack_top, 32);
	     end;

     end;

get_encode_path_entry: procedure ();

/* get pathname from the stack and entry name if there,
   else get entry name from path name.  Set this option on */

	if duplicate ("encode_proc", addr (encode_proc_seen)) then ;
	else do;
		domain_list_ptr -> domain.encode_proc.flag = ON;
		domain_list_ptr -> domain.encode_proc.path = get_name (temp_index, 168);
		if temp_index = stack_top then
		     domain_list_ptr -> domain.encode_proc.entry =
			get_entry (domain_list_ptr -> domain.encode_proc.path);
		else domain_list_ptr -> domain.encode_proc.entry = get_name (stack_top, 32);
	     end;

     end;

get_decode_path_entry: procedure ();

/* get pathname from the stack and entry name if there, else
   get entry name from path name.  Set this option on */

	if duplicate ("decode_proc", addr (decode_proc_seen)) then ;
	else do;
		domain_list_ptr -> domain.decode_proc.flag = ON;
		domain_list_ptr -> domain.decode_proc.path = get_name (temp_index, 168);
		if temp_index = stack_top then
		     domain_list_ptr -> domain.decode_proc.entry =
			get_entry (domain_list_ptr -> domain.decode_proc.path);
		else domain_list_ptr -> domain.decode_proc.entry = get_name (stack_top, 32);
	     end;

     end;

get_entry: procedure (pathname) returns (char (32));

/* extract the entry name from the pathname */

	if lex_stack_ptr -> lex_stack (stack_top).token_num ^= 0 & search (reverse (pathname), ">") ^= 0 then

/* absolute pathname, extract the rightmost component */

	     entry_portion = substr (pathname, length (pathname) - search (reverse (pathname), ">") + 2);

/* either dummy "<error_symbol>" or relative pathname, use path as entry name */

	else entry_portion = pathname;

/* make sure the entry name is not too big */

	entry_portion = rtrim (entry_portion);
	if length (entry_portion) <= 32 then ;
	else do;
		call ioa_$rs ("^a^a^a ^d^a", message, message_length,
		     "The entry name portion exceeds 32 characters in pathname """, pathname,
		     """ on line", domain_list_ptr -> domain.line_num,
		     ", it is being truncated to that length!!");
		call mrds_rst_error (static_rsc_ptr, 2 /* severity */, mrds_error_$rst_name_too_long, (message));
	     end;

	entryname = entry_portion;
	return (entryname);

	declare pathname		 char (*) aligned;	/* absolute or relative pathname */
	declare entryname		 char (32);	/* final extracted entry name */
	declare entry_portion	 char (168) varying;/* intermediate entry portion */

     end;

/* *************************************************

   attribute specification processing

   ********************************************** */

/* <attribute_stmt> ::= <attribute_keyword><attribute_domain_list> <semicolon>  ! */

rule_label (0064):

/* attribute declaration processing complete, set it inactive */

	stmt (directive.type).attribute.active = OFF;
	goto return_label;

/* <attribute_stmt> ::= <empty> | <attribute_keyword><semicolon>  ! */

rule_label (0065):
	goto return_label;

/* <attribute_domain_list> ::= <attribute_domain>  ! */

rule_label (0066):

/* count the last attribute specification */

	stmt (directive.type).attribute.number = stmt (directive.type).attribute.number + 1;
	goto return_label;

/* <attribute_domain_list> ::= <attribute_domain_list><comma><attribute_domain>  ! */

rule_label (0067):
	goto return_label;

/* <attribute_domain> ::= <identifier><identifier>  ! */

rule_label (0068):

/* get the attribute domain pair, and call the semantic routine for this declaration */

	call mrds_rst_rsc_alloc (static_rsc_ptr, ATTRIBUTE_DOMAIN, attribute_list_ptr);
	attribute_list_ptr -> attribute_domain.attr = get_name (stack_top - 1, 32);
	attribute_list_ptr -> attribute_domain.dom = get_name (stack_top, 32);
	attribute_list_ptr -> attribute_domain.line_num = get_line_number (stack_top - 1);
	attribute_list_ptr -> attribute_domain.default = OFF; /* defined in source */
	attribute_list_ptr -> attribute_domain.unused = OFF;

	call mrds_rst_attribute_handler (static_rsc_ptr, attribute_list_ptr);
	stmt (directive.type).attribute.number = stmt (directive.type).attribute.number + 1;
	goto return_label;

/* ***************************************************

   relation specification processing

   *********************************************** */


/* <relation_stmt> ::= <relation_keyword><relation_spec_list> <semicolon>  ! */

rule_label (0069):

/* relation processing complete, set it inactive */

	call mrds_rst_file_cleanup (static_rsc_ptr);
	stmt (directive.type).relation.active = OFF;
	goto return_label;


/* <relation_stmt> ::= <empty> | <relation_keyword><semicolon>  ! */

rule_label (0070):

/* no relation statement, set it inactive */

	stmt (directive.type).relation.active = OFF;
	goto return_label;


/* <relation_spec_list> ::= <relation_spec>  ! */

rule_label (0071):
	goto return_label;


/* <relation_spec_list> ::= <relation_spec_list><comma><relation_spec>  ! */

rule_label (0072):
	goto return_label;


/* <relation_spec> ::= <relation_name> <left_parenthesis> <relation_attr_list> <right_parenthesis>  ! */

rule_label (0073):

/* relation list built, call the semantic routine for relation declarations */

	if key_order ^= 0 then ;
	else call fixup_key_attribute ();
	call mrds_rst_relation_handler (static_rsc_ptr, relation_list_ptr);
	stmt (directive.type).relation.number = stmt (directive.type).relation.number + 1;
	goto return_label;


/* <relation_name> ::= <identifier>  ! */

rule_label (0074):

/* start relation list, get name from stack */

	call get_relation_name ();
	goto return_label;


/* <relation_attr_list> ::= <attr_spec>  ! */

rule_label (0075):
	goto return_label;


/* <relation_attr_list> ::=  <relation_attr_list><attr_spec>  ! */

rule_label (0076):
	goto return_label;


/* <attr_spec> ::= <identifier>  ! */

rule_label (0077):

/* get non key attribute for this relation list */

	temp_index = stack_top;
	key_attribute = OFF;
	call get_relation_attribute ();
	goto return_label;


/* <attr_spec> ::= <identifier> <asterisk>  ! */

rule_label (0078):

/* get key attribute for this relation list */

	temp_index = stack_top - 1;
	key_attribute = ON;
	call get_relation_attribute ();
	goto return_label;


fixup_key_attribute: procedure ();

/* assume the first attrubte defined is the key when none given */

	attribute_ptr = relation_list_ptr -> relation.a_ptr;
	attribute_ptr -> attribute.pr_key = ON;
	attribute_ptr -> attribute.key_order = 1;

	call ioa_$rs ("^a^a^a ^d ^a^a^a", message, message_length,
	     "Relation """, relation_list_ptr -> relation.name,
	     """ on line", relation_list_ptr -> relation.line_num,
	     "does not specify any key attributes, assuming """,
	     attribute_ptr -> attribute.name, """ is a key attribute.");
	call mrds_rst_error (static_rsc_ptr, 2 /* severity */, mrds_error_$rst_no_key_attr, (message));

     end;

get_relation_name: procedure ();

/* get relation name from stack and build list header */

	call mrds_rst_rsc_alloc (static_rsc_ptr, RELATION, relation_list_ptr);
	relation_list_ptr -> relation.a_ptr = null ();
	relation_list_ptr -> relation.name = get_name (stack_top, 30);
	relation_list_ptr -> relation.max_tup = 0;
	relation_list_ptr -> relation.num_items = 0;
	relation_list_ptr -> relation.line_num = get_line_number (stack_top);
	relation_list_ptr -> relation.unused = OFF;
	key_order = 0;
	definition_order = 0;
	saved_attr_ptr = relation_list_ptr;

     end;

get_relation_attribute: procedure ();

/* get attribute name from stack and add it to the relation's list */

	if list_duplicate (ATTRIBUTES, relation_list_ptr -> relation.a_ptr, temp_index, 32) then ;
	else do;
		call mrds_rst_rsc_alloc (static_rsc_ptr, ATTRIBUTE, attribute_ptr);
		attribute.next = null ();
		saved_attr_ptr -> attribute.next = attribute_ptr;
		attribute.name = get_name (temp_index, 32);
		attribute.pr_key = key_attribute;
		attribute.pad = OFF;
		definition_order = definition_order + 1;
		attribute.defn_order = definition_order;
		if ^key_attribute then
		     attribute.key_order = 0;
		else do;
			key_order = key_order + 1;
			attribute.key_order = key_order;
		     end;
		attribute.line_num = get_line_number (temp_index);
		relation_list_ptr -> relation.num_items = relation_list_ptr -> relation.num_items + 1;
		saved_attr_ptr = attribute_ptr;
	     end;

     end;

/* ******************************************************

   index specification processing

   ****************************************************** */


/* <index_stmt> ::= <index_keyword><index_list> <semicolon> ! */

rule_label (0079):

/* index processing complete, set it inactive */

	stmt (directive.type).index.active = OFF;
	goto return_label;


/* <index_stmt> ::= <empty> | <index_keyword><semicolon>  ! */

rule_label (0080):

/* set index statement inactive */

	stmt (directive.type).index.active = OFF;
	goto return_label;


/* <index_list> ::= <index_spec>  ! */

rule_label (0081):
	goto return_label;


/* <index_list> ::= <index_list><comma><index_spec>  ! */

rule_label (0082):
	goto return_label;


/* <index_spec> ::= <index_relation_name> <left_parenthesis> <index_attr_list> <right_parenthesis>  ! */

rule_label (0083):

/* index definition list complete, go process the definition */

	call mrds_rst_index_handler (static_rsc_ptr, index_list_ptr);
	stmt (directive.type).index.number = stmt (directive.type).index.number + 1;
	goto return_label;


/* <index_relation_name> ::= <identifier>  ! */

rule_label (0084):

/* start a index definition list with the relation name */

	call get_index_relation ();
	goto return_label;


/* <index_attr_list> ::= <identifier>  ! */

rule_label (0085):

/* add the last attribute to this index definition list */

	call get_index_attribute ();
	goto return_label;


/* <index_attr_list> ::= <index_attr_list><identifier>  ! */

rule_label (0086):

/* add the next attribute to this index definition list */

	call get_index_attribute ();
	goto return_label;




/* case statement common exit */
return_label:

	return;

get_index_relation: procedure ();

/* get the relation name and build list head for this index statment */

	call mrds_rst_rsc_alloc (static_rsc_ptr, INDEX, index_list_ptr);
	index_list_ptr -> rel_index.i_ptr = null ();
	index_list_ptr -> rel_index.rel_name = get_name (stack_top, 32);
	index_list_ptr -> rel_index.num_items = 0;
	index_list_ptr -> rel_index.unused = OFF;
	index_list_ptr -> rel_index.line_num = get_line_number (stack_top);
	saved_attr_ptr = index_list_ptr;

     end;

get_index_attribute: procedure ();

/* add attribute name to the list for this index */

	if list_duplicate (ATTRIBUTES, index_list_ptr -> rel_index.i_ptr, stack_top, 32) then ;
	else do;
		call mrds_rst_rsc_alloc (static_rsc_ptr, ITEM, item_ptr);
		item.name = get_name (stack_top, 32);
		item.next = null ();
		item.unused = OFF;
		item.line_num = get_line_number (stack_top);
		saved_attr_ptr -> item.next = item_ptr;
		index_list_ptr -> rel_index.num_items = index_list_ptr -> rel_index.num_items + 1;
		saved_attr_ptr = item_ptr;
	     end;


     end;

list_duplicate: procedure (list_type, list_ptr, stack_pos, size) returns (bit (1));

/* check that the given attribute/relation name appears only once in the
   given list. (i.e. attributes in a relation, relations in a file) */

	name_duplicate = OFF;
	name = get_name (stack_pos, size);

/* set up list start depending on list type and status */

	if list_type ^= CHILD then
	     item_ptr = list_ptr;
	else if list_ptr = null () then
	     item_ptr = null ();
	else do;
		children_ptr = list_ptr;
		item_ptr = children_ptr -> children.child_ptr;
	     end;

/* run through linked list of names, checking for duplicates, until list end */

	do while (item_ptr ^= null ());
	     if item_ptr -> item.name ^= name then /* not duplicate, set next list element for list type */
		if list_type ^= CHILD then
		     item_ptr = item_ptr -> item.next;
		else do;
			children_ptr = children_ptr -> children.next;
			if children_ptr = null () then
			     item_ptr = null ();
			else item_ptr = children_ptr -> children.child_ptr;
		     end;

	     else do;				/* duplicate found, issue error, quit search */
		     name_duplicate = ON;
		     item_ptr = null ();
		     if list_type = CHILD then
			duplicate_type = "child relation in a foreign key";
		     else if list_type = FILE_REL then
			duplicate_type = "relation in a file";
		     else duplicate_type = "attribute in a relation";
		     call ioa_$rs ("^a^a^a ^d ^a ^a^a", message, message_length,
			"The name """, name, """ given on line", get_line_number (stack_pos),
			"is a duplicate", duplicate_type, ", --- it will be ignored!!");
		     call mrds_rst_error (static_rsc_ptr, 2 /* severity */, mrds_error_$rst_name_duplicate, (message));
		end;
	end;

	return (name_duplicate);

	declare stack_pos		 fixed binary;	/* stack index for this item */
	declare size		 fixed binary;	/* allowable length of name */
	declare duplicate_type	 char (36) varying; /* error list message */
	declare list_ptr		 ptr;		/* overlay list pointer */
	declare name		 char (32);	/* name that is to be checked for duplicate */
	declare list_type		 fixed bin;	/* 8 => child relation, 9 => file relation, 10 => attribute */
	declare name_duplicate	 bit (1);		/* ON => name already in list */

     end;

get_name: procedure (stack_pos, name_size) returns (char (*));

/*  return the identifier from the given stack position,
   checking that it does not exceed the given size.
   Note that "<error_symbol>" is used when a missing identifier
   has been detected and a dummy inserted for it. */

	length = lex_stack_ptr -> lex_stack (stack_pos).symlen;
	name = substr (lex_stack_ptr -> lex_stack (stack_pos).symptr -> source, 1, length);
	token_pos = lex_stack_ptr -> lex_stack (stack_pos).token_num;

/* check on the token size */

	if length <= name_size then ;
	else do;
		length = name_size;
		lex_stack_ptr -> lex_stack (stack_pos).symlen = name_size;
		call ioa_$rs ("^a^a^a ^d ^a ^d ^a", message, message_length,
		     "The string """, name, """ in line", get_line_number (stack_pos),
		     "is longer than", name_size, "characters, it is being truncated at that length.");
		call mrds_rst_error (static_rsc_ptr, 2 /* severity */, mrds_error_$rst_name_too_long, (message));
	     end;

/* if this is the dummy symbol(token_pos = 0), issue a warning, the first time */

	if token_pos ^= 0 then ;
	else do;
		lex_stack_ptr -> lex_stack (stack_pos).token_num = -1;
		call ioa_$rs ("^a^a^a ^d^a", message, message_length,
		     "The string """, name, """ is being used for a missing token in line",
		     get_line_number (stack_pos), ".");
		call mrds_rst_error (static_rsc_ptr, 1 /* severity */, mrds_error_$rst_bad_semantics, (message));
	     end;

	name_overlay_ptr = addrel (addr (name), 1);	/* point to data portion of varying string */

	return (name_overlay);


	declare length		 fixed binary (24); /* length of token */
	declare name		 char (mrds_data_$max_string_size) varying based (name_ptr); /* token character string */
	declare name_overlay	 char (length) based (name_overlay_ptr); /* exact length token to return */
	declare name_overlay_ptr	 ptr;		/* points to data portion */
	declare token_pos		 fixed binary (24); /* position of token in line */
	declare stack_pos		 fixed binary;	/* index into stack for this identifier */
	declare name_size		 fixed binary;	/* maximum legal size for this token */

     end;

get_fixed_value: procedure (stack_pos, max_value) returns (fixed bin (71));

/* get a fixed binary value from the stack at the given position */

	if lex_stack_ptr -> lex_stack (stack_pos).token_num ^= 0 then
	     value = lex_stack_ptr -> lex_stack (stack_pos).val;

	else do;

/* token_num = 0 means dummy "<error_symbol>" on stack for missing number,
   use a fixup value and issue error message */

		value = 1;
		lex_stack_ptr -> lex_stack (stack_pos).val = 1;
		call ioa_$rs ("^a^d^a ^d^a", message, message_length,
		     "The value """, value, """ is being used for a missing number in line",
		     get_line_number (stack_pos), ".");
		call mrds_rst_error (static_rsc_ptr, 1 /* severity */, mrds_error_$rst_bad_semantics, (message));
	     end;

/* check that the number is within the range of the option */

	if value <= max_value then ;
	else do;
		call ioa_$rs ("^a^d^a ^d ^a^d^a", message, message_length,
		     "The value """, value, """ in line", get_line_number (stack_pos),
		     "exceeds the maximum allowable for this option, using """, max_value, """ instead.");
		call mrds_rst_error (static_rsc_ptr, 2 /* severity */, mrds_error_$rst_option_limit, (message));
		value = max_value;
		lex_stack_ptr -> lex_stack (stack_pos).val = max_value;
	     end;

	return (value);

	declare value		 fixed binary (71); /* value of number to be returned */
	declare stack_pos		 fixed binary;	/* index into stack for this number */
	declare max_value		 fixed binary (71); /* largest allowed value */

     end;

get_line_number: procedure (stack_pos) returns (fixed binary (24));

/* routine to obtain line number from parse stack */

	line_number = lex_stack_ptr -> lex_stack (stack_pos).line;

	return (line_number);


	declare line_number		 fixed binary (24); /* value to be returned */
	declare stack_pos		 fixed binary;	/* index into stack for this item */

     end;

	declare rule_sw		 bit (1) static init ("0"b); /* switch for debug output of rule numbers */
	declare saved_attr_ptr	 ptr internal static; /* last attr pointer */
	declare saved_decode_descriptor bit (36) aligned internal static; /* first given decode_dcl descriptor */
	declare descriptor_saved	 bit (1) internal static; /* on => the first decode descriptor was saved */
	declare (fixed, addr, search, binary) builtin; /* functions known to pl1 */
	declare stkp		 ptr;		/* lexical stack pointer parameter */
	declare ls_top		 fixed binary (24); /* parameter for top of stack */
	declare sign_flag		 bit (1) internal static; /* on => negative value needed */
	declare mrds_error_$rst_no_key_attr fixed binary (35) external; /* no attr given as key in relation */
	declare mrds_error_$rst_option_limit fixed binary (35) external; /* number too large for receiving field */
	declare mrds_error_$rst_name_duplicate fixed binary (35) external; /* dup name in rel/attr or file/rel list */
	declare mrds_error_$rst_bad_declaration fixed binary (35) external; /* error in domain declaration */
	declare mrds_error_$rst_inconsis_option fixed binary (35) external; /* contradictory option */
	declare mrds_error_$rst_name_too_long fixed binary (35) external; /* oversize name error */
	declare mrds_error_$rst_bad_semantics fixed binary (35) external; /* meaning of source may be lost */
	declare EQUAL		 fixed bin internal static options (constant) init (1); /* = op code */
	declare NOT_EQUAL		 fixed bin internal static options (constant) init (2); /* ^= op code */
	declare GREATER		 fixed bin internal static options (constant) init (3); /* > op code */
	declare LESS		 fixed bin internal static options (constant) init (4); /* < op code */
	declare GREATER_EQUAL	 fixed bin internal static options (constant) init (5); /* >= op code */
	declare LESS_EQUAL		 fixed bin internal static options (constant) init (6); /* <= op code */
	declare AND		 fixed binary internal static options (constant) init (10); /* & op code */
	declare OR		 fixed binary internal static options (constant) init (20); /* | op code */
	declare NOT		 fixed binary internal static options (constant) init (30); /* ^ op code */
	declare MINUS		 fixed binary internal static options (constant) init (40); /* - unary operator code */
	declare DOMAIN_VARIABLE	 fixed binary internal static options (constant) init (50); /* domain id code */
	declare ELEMENT		 fixed bin internal static options (constant) init (60); /* code for constant */
	declare OFF		 bit (1) internal static options (constant) init ("0"b); /* flag reset value */
	declare ON		 bit (1) internal static options (constant) init ("1"b); /* flag set value */
	declare BLOCKED		 fixed binary internal static options (constant) init (2); /* code for blocked file type */
	declare UNBLOCKED		 fixed binary internal static options (constant) init (1); /* code for unblocked file type */
	declare BLANK		 char (1) internal static options (constant) init (" "); /* blank fill constant */
	declare max_string_size	 fixed binary (35) internal static; /* descriptor string size limit */
	declare descr_ptr		 ptr internal static; /* pointer to current descriptor */
	declare saved_descr_ptr	 ptr internal static; /* normal desc pointer temp storage */
	dcl     decode_dcl_mesg	 char (8) var internal static; /* "" => normal, else decode_dcl declare message */
	declare mrds_rst_rsc_alloc	 entry (ptr, fixed bin, ptr); /* working area allocation routine */
	declare db_model_path	 char (168) internal static; /* saved db_model pathname */
	declare ioa_$rs		 entry options (variable); /* string building routine */
	declare mrds_rst_domain_handler entry (ptr, ptr); /* domain declaration semantic routine */
	declare mrds_rst_attribute_handler entry (ptr, ptr); /* attribute declaration semantic routine */
	declare mrds_rst_relation_handler entry (ptr, ptr); /* relation declaration semantic routine */
	declare mrds_rst_index_handler entry (ptr, ptr);	/* index declaration semantic routine */
	declare mrds_rst_file_cleanup	 entry (ptr);	/* undeclared file semantic routine */
	declare mrds_rst_attribute_cleanup entry (ptr);	/* domain default attribute routine */
	declare stack_top		 fixed binary;	/* current top of lexical stack */
	declare message		 char (512) varying;/* error message of specifics */
	declare message_length	 fixed binary (21); /* length of error message */
	declare mrds_rst_error	 entry (ptr, fixed binary, fixed binary (35), char (*)); /* error handling routine */

/* note: changing the declaration of multiplier, requires changing the
   code for the <quantity> rule (the any_to_any parameters) */
	declare multiplier		 fixed bin (24) internal static aligned; /* string multiplier */
	declare source		 char (sys_info$max_seg_size) based; /* string overlay for getting tokens */
	declare sys_info$max_seg_size	 fixed binary (35) external; /* system maximum segment size */
	declare rule		 fixed binary (24); /* current rule number returned by parser */
	declare alternate		 fixed binary (24); /* current allternate of rule number */
	declare max_fixed_bin_17	 fixed binary (71) internal static; /* largest 17 bit value */
	declare max_fixed_bin_71	 fixed binary (71) internal static; /* largest 71 bit value */
	declare static_rsc_ptr	 ptr internal static; /* pointer to restructure control segment */
	declare index_list_ptr	 ptr internal static; /* pointer to list of index information */
	declare relation_list_ptr	 ptr internal static; /* pointer to list of relation information */
	declare attribute_list_ptr	 ptr internal static; /* pointer to list of attribute information */
	declare domain_list_ptr	 ptr internal static; /* pointer to list of domain information */
	declare definition_order	 fixed bin internal static; /* order of attribute definition */
	declare key_order		 fixed bin internal static; /* order of key attribute definition */
	declare string_length	 fixed bin (24) internal static; /* size of bit or char string declaration */
	declare string_average_length	 fixed bin (24) internal static; /* average varying string size */
	declare temp_number		 fixed binary (71); /* storage for number checks */
	declare i			 fixed binary;	/* index for initialization loop */
	declare saved_precision	 fixed bin (71) internal static; /* remembered number precision */
	declare scale_factor	 fixed bin (71) internal static; /* remembered number scale value declaration */
	declare avg_length_seen	 bit (1) internal static; /* ON => varying average size declared */
	declare size_seen		 bit (1) internal static; /* on => string size was declared */
	declare decode_proc_seen	 bit (1) internal static; /* on => decode_proc option was declared */
	declare encode_proc_seen	 bit (1) internal static; /* on => encode_proc option was declared */
	declare check_seen		 bit (1) internal static; /* on => check or check_proc option declared */
	declare type_seen		 bit (1) internal static; /* on => a type was declared */
	declare representation_seen	 bit (1) internal static; /* on => representation was declared */
	declare base_seen		 bit (1) internal static; /* on => base was declared */
	declare precision_seen	 bit (1) internal static; /* on => precision was declared */
	declare alignment_seen	 bit (1) internal static; /* on => alignment was declared */
	declare fixed_varying_seen	 bit (1) internal static; /* on =>  fixed or varying was declared */
	declare scale_seen		 bit (1) internal static; /* on => scale was declared */
	declare decode_dcl_seen	 bit (1) internal static; /* on => decode declaration seen */
	declare MULTIPLIER		 fixed bin internal static options (constant) init (1); /* any to any of multiplier */
	declare A_CONSTANT		 fixed bin internal static options (constant) init (2); /* any to any of constant */
	declare NUMBER		 fixed bin internal static options (constant) init (3); /* number constant to convert */
	declare BIT_STRING		 fixed bin internal static options (constant) init (4); /* bit_string to convert */
	declare CHAR_STRING		 fixed bin internal static options (constant) init (5); /* char_string to convert */
	declare RMDB		 fixed bin internal static options (constant) init (5); /* rmdb fixup */
	declare CHILD		 fixed bin internal static options (constant) init (8); /* child rel dup check */
	declare FILE_REL		 fixed bin internal static options (constant) init (9); /* file rel dup check */
	declare ATTRIBUTES		 fixed bin internal static options (constant) init (10); /* attr dup check */
	declare decimal		 bit (1) internal static; /* on => decimal declared */
	declare real		 bit (1) internal static; /* on => real declared */
	declare (addrel, hbound, copy, length) builtin;
	declare (null, reverse, rtrim, substr) builtin;
	declare float		 bit (1) internal static; /* on => float declared */
	declare aligned		 bit (1) internal static; /* on => aligned was declared */
	declare nonvarying		 bit (1) internal static; /* on => nonvarying was declared */
	declare temp_index		 fixed binary;	/* storage for stack position of a token */
	declare key_attribute	 bit (1);		/* on => attribute is part of primary key */
	declare short		 bit (1) internal static; /* on => short precision */
	declare 1 arith_size	 unal based,	/* overlay for scale and precision fields of descriptor */
		2 unused		 bit (12),
		2 scale		 fixed bin (11),
		2 precision	 fixed binary (11); /* equivalent to bit(12) */
	declare 1 string_size	 unal based,	/* overlay for size field in descriptor */
		2 unused		 bit (12),
		2 length		 fixed binary (23); /* equivalent to bit(24) */
	declare name_ptr		 ptr int static;	/* pointer to token space when needed from stack */
	declare temp_source_ptr	 ptr int static;	/* pointer to temp token space when to be multiplied */
	declare ioa_		 entry() options(variable);



%include mrds_rst_parse_stack;
%include mrds_rst_semantics;
%include mdbm_descriptor;
%include mrds_rst_rsc;
%include mrds_rst_parse_info;
%include mdbm_db_model;
%include mrds_rst_struct_types;


     end;
