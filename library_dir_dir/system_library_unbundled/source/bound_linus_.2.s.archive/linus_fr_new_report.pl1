/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   *********************************************************** */
/* format: off */
%skip(1);
/*

     This module is called by the linus display request to set
     up the environment for a new report. Description and usage follows.

     Description:

     This module calls linus_options to get the values of the formatting
     options. It then uses the set of defined options to allocate all of
     the structures needed by linus_fr_build_page. The number of structures,
     their extents, etc. are all dictated by the definition of the format
     options. These structures which result from the translation provide
     a complete execution environment for linus_fr_build_page.

     Usage:

     Both parameters are passed to this program by it's caller, linus_display.
     It is called every time a new report is desired.
 
     Known Bugs:
 
     Other Problems:

     History:

     Written - Al Dupuis - August 1983

*/
%page;
linus_fr_new_report: proc (

	lcb_ptr_parm,	/* input: points to the linus control block */
	code_parm		/* output: success or failure */
		      );
%skip(3);
dcl code_parm fixed bin (35) parm;
dcl lcb_ptr_parm ptr parm;
%skip(3);
/*
     Mainline Processing Overview.

     (1) Perform initialization.

     (2) Go through the process of getting format options from linus_options
         and allocating/filling in the execution structures based on what the
         options are defined as.  The order is roughly setting up the input
         columns, the output columns, the page information, the subtotals and
         subcounts, the totals and counts, the report info, the
         headers/footers info, and the status info.  Everything specific to
         one of these areas sometimes can't all be done in the specific
         subroutine because there are some things that are order dependent.

*/
%skip(1);
	lcb_ptr = lcb_ptr_parm;
	code_parm = 0;
	call housekeeping;
	call setup_input_column_info;
	call setup_output_column_info;
	call setup_page_info;
	call setup_subtotals_info;
	call setup_subcounts_info;
	call setup_totals_info;
	call setup_counts_info;
	call setup_report_info;
	call setup_header_info;
	call setup_status_info;
%skip(1);
	report_control_info.format_report_info_ptr = format_report_ip;
%skip(1);
	return;
%page;
get_option_value: proc (

	gov_option_name_parm,	/* input: name of option */
	gov_option_identifier_parm,	/* input: column identifier */
	gov_option_value_parm	/* output: option value */
		   );
%skip(1);
dcl gov_code fixed bin (35);
dcl gov_option_identifier_parm char (*) varying parm;
dcl gov_option_name_parm char (*) varying parm;
dcl gov_option_value_parm char (*) varying parm;
%skip(3);
          call linus_options$get (lcb_ptr, gov_option_name_parm, 
	     gov_option_identifier_parm, normalized_option_name, 
	     gov_option_value_parm, gov_code);
%skip(1);
	if gov_code ^= 0
	then call ssu_$abort_line (sci_ptr, gov_code);
%skip(1);
          return;
%skip(1);
     end get_option_value;
%page;
housekeeping: proc;
%skip(3);
/*
     Make sure the table information is up to date. Set the pointers to
     our needed temp segments and areas. Allocate/initialize the
     format_report_info structure.
*/
%skip(1);
          sci_ptr = lcb.subsystem_control_info_ptr;
%skip(1);
	call linus_table$info (lcb_ptr, table_ip, code);
	if code ^= 0
	then call ssu_$abort_line (sci_ptr, code);
	number_of_defined_columns = table_info.column_count;
	maximum_segment_size = sys_info$max_seg_size * 4;
%skip(1);
          report_cip = lcb.report_control_info_ptr;
	work_area_ptr = report_control_info.report_work_area_ptr;
	temp_seg_ptr = report_control_info.report_temp_seg_ptr;
	editing_strings_tsp 
	     = report_control_info.editing_strings_temp_seg_ptr;
	editing_strings_next_byte = 1;
	headers_tsp = report_control_info.headers_temp_seg_ptr;
	headers_next_byte = 1;
%skip(1);
	allocate format_report_info in (work_area) set (format_report_ip);
	unspec (format_report_info) = OFF;
	format_report_info.table_info_ptr = table_ip;
%skip(1);
          code = 0;
%skip(1);
          return;
%skip(1);
     end housekeeping;
%page;
map_column_list: proc (

	mcl_type_of_map_parm,	/* input: two different types of map */
	mcl_option_value_parm,	/* input: the list of columns */
	mcl_no_of_columns_found_parm	/* output: how many were in the list */
		  );
%skip(1);
dcl mcl_character_string_length fixed bin;
dcl mcl_column_number fixed bin;
dcl mcl_column_position fixed bin;
dcl mcl_current_position fixed bin;
dcl mcl_next_blank fixed bin;
dcl mcl_no_of_columns_found fixed bin;
dcl mcl_no_of_columns_found_parm fixed bin parm;
dcl mcl_option_value_parm char (*) varying parm;
dcl mcl_still_processing_columns bit (1) aligned;
dcl mcl_type_of_map_parm bit (1) aligned parm;
%skip(3);
/*
     Parse the column list and fill in the column_map structure based on what
     we find.  Set the output parm to reflect how many columns we've found.
     The column map has been normalized by linus_options to change all column
     numbers to names, place a single blank between each, and trim all leading
     and trailing whitespace.  We supply two types of maps.  The parameter
     mcl_type_of_map_parm when set to OUTPUT_MAP results in us preserving the
     order in which we find them.  If it is set to INPUT_MAP the order of the
     selection expression is preserved.  For example, if the user selected a,
     b, c, d, e, f, g, h and the list contained "e c" the map would look like:

	OUTPUT_MAP 1 2 3 4 5 6 7 8
	           1 1 0 0 0 0 0 0 PRESENT
                     5 3 0 0 0 0 0 0 POSITION

	 INPUT_MAP 1 2 3 4 5 6 7 8
	           0 0 1 0 1 0 0 0 PRESENT
                     0 0 3 0 5 0 0 0 POSITION
*/
%skip(1);
          unspec (column_map) = OFF;
	mcl_option_value_parm = mcl_option_value_parm || BLANK;
	mcl_current_position = 1;
	mcl_character_string_length = length (mcl_option_value_parm);
	mcl_column_position = 1;
	mcl_no_of_columns_found = 0;
	mcl_still_processing_columns = ON;
%page;
	do while (mcl_still_processing_columns);
	     mcl_next_blank = index (substr (mcl_option_value_parm, mcl_current_position), BLANK);
	     mcl_column_number = lookup_column_number ();
	     if mcl_type_of_map_parm = OUTPUT_MAP
	     then do;
		column_map.present (mcl_column_position) = ON;
		column_map.position (mcl_column_position) = mcl_column_number;
		mcl_column_position = mcl_column_position + 1;
	     end;
	     else do;
		column_map.present (mcl_column_number) = ON;
		column_map.position (mcl_column_number) = mcl_column_number;
	     end;
	     mcl_current_position = mcl_current_position + mcl_next_blank;
	     mcl_no_of_columns_found = mcl_no_of_columns_found + 1;
	     if mcl_current_position > mcl_character_string_length
	     then mcl_still_processing_columns = OFF;
	end;
%skip(1);
	mcl_no_of_columns_found_parm = mcl_no_of_columns_found;
%skip(1);
          return;
%page;
lookup_column_number: proc () returns (fixed bin);
%skip(1);
dcl lcn_loop fixed bin;
%skip(1);
          lcn_column_name = substr (mcl_option_value_parm, 
	     mcl_current_position, mcl_next_blank - 1);
%skip(1);
	do lcn_loop = 1 to number_of_defined_columns;
	     if lcn_column_name = table_info.columns.column_name (lcn_loop)
	     then return (lcn_loop);
	end;
%skip(1);
          call ssu_$abort_line (sci_ptr, linus_error_$bad_option_value,
	     "^/Invalid column list ""^a"".", mcl_option_value_parm);
%skip(1);
	return (0);
%skip(1);
     end lookup_column_number;
%skip(1);
     end map_column_list;
%page;
set_grouping_info: proc (

	sgi_option_name_parm,	     /* input: name of group option */
	sgi_grouping_is_defined_flag_parm, /* output: on if group is defined */
	sgi_group_info_ptr_parm	     /* output: ptr to group_info structure if above is on */
		    );
%skip(1);
dcl 1 sgi_group_info like group_info based (sgi_group_info_ptr);
dcl sgi_group_info_ptr ptr;
dcl sgi_group_info_ptr_parm ptr parm;
dcl sgi_grouping_is_defined_flag_parm bit (1) parm;
dcl sgi_loop fixed bin;
dcl sgi_option_name_parm char (*) varying parm;
%skip(3);
/*

     Get the option value associated with the named option.  Set the flag to
     reflect whether or not it's defined.  Allocate/fill in the group_info
     structure if it's defined.

*/
%skip(1);
	sgi_group_info_ptr_parm = null ();
	call get_option_value (sgi_option_name_parm, "", option_value);
	if option_value = ""
	then do;
	     sgi_grouping_is_defined_flag_parm = OFF;
	     return;
	end;
%skip(1);
	sgi_grouping_is_defined_flag_parm = ON;
	call map_column_list (OUTPUT_MAP, option_value, gi_init_number_of_columns_to_group);
	allocate sgi_group_info in (work_area) set (sgi_group_info_ptr);
%skip(1);
	do sgi_loop = 1 to gi_init_number_of_columns_to_group;
	     sgi_group_info.column_number (sgi_loop) = column_map.position (sgi_loop);
	end;
	sgi_group_info_ptr_parm = sgi_group_info_ptr;
%skip(1);
	return;
%skip(1);
     end set_grouping_info;
%page;
set_ioa_string_for_total_or_subtotal: proc (

	sisfs_descriptor_ptr_parm,	/* input: ptr to the descriptor */
	sisfs_ioa_string_parm	/* output: the proper ioa_ string to edit it through */
			    );
%skip(1);
dcl sisfs_char_10 char (10) based;
dcl sisfs_descriptor_ptr_parm ptr parm;
dcl sisfs_ioa_string_parm char (*) varying parm;
dcl sisfs_scale fixed bin;
%skip(3);
/*
     If the scale is greater than zero then set the ioa_ string to reflect
     the number of digits (i.e. fixed dec (5,2) would be "^.2f"). If scale
     is zero then set the ioa_ string to "^f" for float numbers and "^d" for
     all others.
*/
%skip(1);
	desc_ptr = sisfs_descriptor_ptr_parm;
	sisfs_scale = fixed (descriptor.size.scale, 17, 0);
	if sisfs_scale > 0
	then sisfs_ioa_string_parm = "^." || ltrim (convert (sisfs_char_10, sisfs_scale)) || "f";
	else if descriptor.type = 3 | descriptor.type = 4 | descriptor.type = 7
	     | descriptor.type = 8 | descriptor.type = 10 | descriptor.type = 12
	     | descriptor.type = 42 | descriptor.type = 44 | descriptor.type = 46
	     then sisfs_ioa_string_parm = "^f";
	     else sisfs_ioa_string_parm = "^d";
%skip(1);
	return;
%skip(1);
     end set_ioa_string_for_total_or_subtotal;
%page;
setup_counts_info: proc;
%skip(3);
/*
     Get the value for the count option and get the subroutine to figure out
     if it's defined and allocate/initialize the structure if it is. Set it's
     pointer in format_report_info.
*/
%skip(1);
	call get_option_value (OPTIONS.GENERAL_COLUMN.NAME
	     (INDEX_FOR_COUNT), "", option_value);
	call setup_totals_or_counts_info (ROW_COUNT, option_value,
	     format_report_info.flags.count_is_defined, count_ip);
	if format_report_info.flags.count_is_defined
	then format_report_info.count_info_ptr = count_ip;
	else format_report_info.count_info_ptr = null ();
%skip(1);
	return;
%skip(1);
     end setup_counts_info;
%page;
setup_header_info: proc;
%skip(1);
dcl shi_additional_indent fixed bin;
dcl shi_alignment_modes (3) fixed bin;
dcl shi_delimiter char (1);
dcl shi_inner_loop fixed bin;
dcl shi_loop fixed bin;
dcl shi_current_header_part fixed bin;
dcl shi_current_inner_position fixed bin;
dcl shi_current_position fixed bin;
dcl shi_header_info_ptr ptr;
dcl shi_header_length fixed bin;
dcl shi_header_part_length fixed bin;
dcl shi_n_parts_width (3) fixed bin;
dcl shi_next_newline_position fixed bin;
dcl shi_number_of_lines_found fixed bin;
dcl shi_number_of_parts_found fixed bin;
dcl shi_second_delimiter_position fixed bin;
dcl shi_starting_position fixed bin;
dcl shi_still_counting bit (1) aligned;
dcl shi_still_parsing bit (1) aligned;
%skip(3);
/*
     Get the header portion delimiter. Init maximum number of portions to three
     and set the widths for 1, 2, and 3 part headers. Make left, center
     and right portions alignment accordingly. Get the subroutine to figure out
     which headers/footers are defined and allocate/fill in the structures.
     Group headers and footers need grouping info set for them. The parsed
     versions of the character strings the headers/footers were set to are 
     placed contiguosly in a temp segment, and the rest of the temp seg is used
     during the evaluation of each (in linus_fr_build_page).
*/
%skip(1);
	call get_option_value (OPTIONS.GENERAL_REPORT.NAME (
	     INDEX_FOR_DELIMITER), "", option_value);
	if option_value ^= ""
	then format_report_info.header_part_delimiter = substr (option_value, 1, 1);
	else format_report_info.header_part_delimiter = BLANK;
	shi_delimiter = format_report_info.header_part_delimiter;
	hi_init_maximum_number_of_parts = 3;
	shi_n_parts_width (1) = page_info.width - 1;
	shi_n_parts_width (2) = divide (shi_n_parts_width (1), 2, 17);
	shi_n_parts_width (3) = divide (shi_n_parts_width (1), 3, 17);
	shi_alignment_modes (1) = LEFT_ALIGNMENT;
	shi_alignment_modes (2) = CENTER_ALIGNMENT;
	shi_alignment_modes (3) = RIGHT_ALIGNMENT;
%page;
	call define_header (OPTIONS.GENERAL_REPORT.NAME (INDEX_FOR_PAGE_HEADER_VALUE),
	     format_report_info.flags.page_header_is_defined, 
	     format_report_info.page_header_info_ptr);
%skip(1);
	call define_header (OPTIONS.GENERAL_REPORT.NAME (INDEX_FOR_PAGE_FOOTER_VALUE),
	     format_report_info.flags.page_footer_is_defined,
	     format_report_info.page_footer_info_ptr);
%skip(1);
	call define_header (OPTIONS.GENERAL_COLUMN.NAME (INDEX_FOR_ROW_HEADER_VALUE),
	     format_report_info.flags.row_header_is_defined,
	     format_report_info.row_header_info_ptr);
%skip(1);
	call define_header (OPTIONS.GENERAL_COLUMN.NAME (INDEX_FOR_ROW_FOOTER_VALUE),
	     format_report_info.flags.row_footer_is_defined,
	     format_report_info.row_footer_info_ptr);
%skip(1);
	call define_header (OPTIONS.GENERAL_COLUMN.NAME (INDEX_FOR_GROUP_HEADER_VALUE),
	     format_report_info.flags.group_header_is_defined,
	     format_report_info.group_header_info_ptr);
%skip(1);
	call define_header (OPTIONS.GENERAL_COLUMN.NAME (INDEX_FOR_GROUP_FOOTER_VALUE),
	     format_report_info.flags.group_footer_is_defined,
	     format_report_info.group_footer_info_ptr);
%skip(1);
	call set_grouping_info (OPTIONS.GENERAL_COLUMN.NAME (INDEX_FOR_GROUP_HEADER_TRIGGER),
	     format_report_info.flags.group_header_trigger_is_defined,
	     format_report_info.group_header_trigger_info_ptr);
%skip(1);
	call set_grouping_info (OPTIONS.GENERAL_COLUMN.NAME (INDEX_FOR_GROUP_FOOTER_TRIGGER),
	     format_report_info.flags.group_footer_trigger_is_defined,
	     format_report_info.group_footer_trigger_info_ptr);
%skip(1);
	format_report_info.headers_next_available_byte = headers_next_byte;
%skip(1);
	return;
%page;
define_header: proc (

	dh_header_option_name_parm,	  /* input: name of header/footer option */
	dh_header_is_defined_flag_parm, /* output: on if header is defined */
	dh_header_info_ptr_parm	  /* output: points to header_info structure */
		);
%skip(1);
dcl dh_header_option_name_parm char (*) varying parm;
dcl dh_header_is_defined_flag_parm bit (1) parm;
dcl dh_header_info_ptr_parm ptr parm;
%skip(3);
/*
     Parse the header and set pointer and bit to reflect it's definition.
*/
%skip(1);
	dh_header_info_ptr_parm = null ();
	call get_option_value (dh_header_option_name_parm, "", option_value);
	if option_value = ""
	then do;
	     dh_header_is_defined_flag_parm = OFF;
	     return;
	end;
%skip(1);
	call parse_header (option_value, shi_header_info_ptr);
	dh_header_is_defined_flag_parm = ON;
	dh_header_info_ptr_parm = shi_header_info_ptr;
%skip(1);
	return;
%skip(1);
     end define_header;
%page;
parse_header: proc (

	ph_header_value_parm,    /* input: the header to be parsed */
	ph_header_info_ptr_parm  /* output: ptr to the header info structure */
	         );
%skip(1);
dcl ph_header_info_ptr_parm ptr parm;
dcl ph_header_line_length fixed bin;
dcl ph_header_value_parm char (*) varying parm;
%skip(3);
/*
     Make sure header ends in new line. Allocate header_info structure based on
     how many lines it is. Cleanup header and place it in temp seg. For each
     part within each line fill in the structure and redistribute page space.
     Set the starting position on the page and alignment for each part.
*/
%skip(1);
	ph_header_info_ptr_parm = null ();
	if substr (ph_header_value_parm, length (ph_header_value_parm), 1) ^= NL
	then ph_header_value_parm = ph_header_value_parm || NL;
	call allocate_header_info_structure;
%skip(1);
	shi_current_position = 1;
%skip(1);
	do shi_loop = 1 to shi_number_of_lines_found;
	     call cleanup_and_save_header_line;
	     shi_current_header_part = 1;
	     shi_number_of_parts_found = 0;
	     shi_current_inner_position = 1;
	     shi_still_parsing = ON;
	     do while (shi_still_parsing);
		call set_header_part_info;
	     end;
	     call correct_header_part_anomaly;
	     do shi_inner_loop = 1 to hi_init_maximum_number_of_parts;
		call set_header_part_additional_info;
	     end;
	     headers_next_byte = headers_next_byte + ph_header_line_length;
	end;
%skip(1);
	ph_header_info_ptr_parm = header_ip;
%skip(1);
	return;		
%page;
allocate_header_info_structure: proc;
%skip(3);
/*
     Allocate structure based on number of lines it is made up of.
*/
%skip(1);
	shi_number_of_lines_found = 0;
	shi_current_position = 1;
	shi_header_length = length (ph_header_value_parm);
	shi_still_counting = ON;
%skip(1);
	do while (shi_still_counting);
	     shi_next_newline_position = index (substr (ph_header_value_parm,
		shi_current_position), NL);
	     shi_number_of_lines_found = shi_number_of_lines_found + 1;
	     shi_current_position = shi_current_position + shi_next_newline_position;
	     if shi_current_position > shi_header_length
	     then shi_still_counting = OFF;
	end;
%skip(1);
	hi_init_number_of_lines = shi_number_of_lines_found;
	allocate header_info in (work_area) set (header_ip);
	unspec (header_info.lines) = OFF;
%skip(1);
	return;
%skip(1);
     end allocate_header_info_structure;
%page;
cleanup_and_save_header_line: proc;
%skip(3);
/*
     Left, right, and center portion delimiters are optional. Place any
     missing ones. Save the cleaned up header line.
*/
%skip(1);
	shi_next_newline_position = index (substr (ph_header_value_parm,
	     shi_current_position), NL);
	ph_header_line = substr (ph_header_value_parm,
	     shi_current_position, shi_next_newline_position - 1);
	shi_current_position = shi_current_position + shi_next_newline_position;
%skip(1);
	if length (ph_header_line) = 0
	then ph_header_line = shi_delimiter || shi_delimiter;
	if substr (ph_header_line, 1, 1) ^= shi_delimiter
	then ph_header_line = shi_delimiter || ph_header_line;
	if substr (ph_header_line, length (ph_header_line), 1) ^= shi_delimiter
	then ph_header_line = ph_header_line || shi_delimiter;
%skip(1);
	ph_header_line_length = length (ph_header_line);
	substr (headers_temp_seg, headers_next_byte, ph_header_line_length) = ph_header_line;
%skip(1);
	return;
%skip(1);
     end cleanup_and_save_header_line;
%page;
correct_header_part_anomaly: proc;
%skip(1);
dcl chpa_loop fixed bin;
%skip(1);
/*
     Parts of a header/footer which are zero length have their space
     assigned to the parts whose length is greater than zero. This creates
     an environment where all space on the page is available for use. For
     example, if only the center part of a header has a length greater than
     zero, the text is centered on the page but it has 100% of the page width
     available to use. There are two cases where this action is not desired,
     and this subroutine takes care of these two special cases (listed in the
     table below as the two special cases).

		NORMAL RE-DISTIBUTION ACTION

1.	!!text!!		100%-centered
2.	!text!text!text!	33%-left aligned, 33%-centered, 33%-right aligned
3.	!text!!text!	50%-left aligned, 50%-right aligned
4.	!text!!!		100%-left aligned
5.	!!!text!		100%-right aligned

		SPECIAL CASE - NO RE-DISTRIBUTION ACTION

6.	!text!text!!	33%-left aligned, 33%-centered, 33%-UNUSED
7.	!!text!text!	33%-UNUSED, 33%-centered, 33%-right aligned

	 Special case, #7 above, followed immediately by #6.
*/
%skip(1);
	if (header_info.lines (shi_loop).parts (1).flags.present
	& header_info.lines (shi_loop).parts (1).length = 0)
	& (header_info.lines (shi_loop).parts (2).flags.present
	& header_info.lines (shi_loop).parts (2).length > 0)
	& (header_info.lines (shi_loop).parts (3).flags.present
	& header_info.lines (shi_loop).parts (3).length > 0)
	then return;
	else if (header_info.lines (shi_loop).parts (3).flags.present
	     & header_info.lines (shi_loop).parts (3).length = 0)
	     & (header_info.lines (shi_loop).parts (1).flags.present
	     & header_info.lines (shi_loop).parts (1).length > 0)
	     & (header_info.lines (shi_loop).parts (2).flags.present
	     & header_info.lines (shi_loop).parts (2).length > 0)
	     then return;
	     else;
%skip(1);
	do chpa_loop = 1 to hi_init_maximum_number_of_parts;
	     if header_info.lines (shi_loop).parts (chpa_loop).flags.present
	     then if header_info.lines (shi_loop).parts (chpa_loop).length = 0
		then do;
		     header_info.lines (shi_loop).parts (chpa_loop).flags.present = OFF;
		     shi_number_of_parts_found = shi_number_of_parts_found - 1;
		end;
	          else;
	     else;
	end;
%skip(1);
	return;
%skip(1);
     end correct_header_part_anomaly;
%page;
set_header_part_additional_info: proc;
%skip(3);
/*
     For each part that's present set it's width, starting position on the
     page, and alignment.
*/
%skip(1);
	if header_info.lines (shi_loop).parts (shi_inner_loop).flags.present
	then do;
	     header_info.lines (shi_loop).parts (shi_inner_loop).width
		= shi_n_parts_width (shi_number_of_parts_found);
	     if shi_number_of_parts_found = 1
	     then shi_starting_position = 1;
	     else if shi_number_of_parts_found = 2
		then if shi_inner_loop = 1
		     then shi_starting_position = 1;
	               else shi_starting_position = shi_n_parts_width (2)
			+ mod (shi_n_parts_width (1), 2) + 1;
		else if shi_inner_loop = 1
		     then shi_starting_position = 1;
		     else if shi_inner_loop = 2
			then do;
			     shi_starting_position = shi_n_parts_width (3) + 1;
			     shi_additional_indent = mod (shi_n_parts_width (1), 3);
			     if shi_additional_indent = 2
			     then shi_additional_indent = 1;
			     shi_starting_position = shi_starting_position + shi_additional_indent;
			end;
		          else shi_starting_position = shi_n_parts_width (1) - shi_n_parts_width (3) + 1;
	     header_info.lines (shi_loop).parts (shi_inner_loop).starting_position = shi_starting_position;
	     header_info.lines (shi_loop).parts (shi_inner_loop).alignment
		= shi_alignment_modes (shi_inner_loop);
	end;
%skip(1);
	return;
%skip(1);
     end set_header_part_additional_info;
%page;
set_header_part_info: proc;
%skip(3);
/*
     Find the portion and it's length. Mark it present and whether it
     contains active requests. Set the index and length to it. Check to make
     sure the maximum number of header parts isn't exceeded.
*/
%skip(1);
	shi_second_delimiter_position = index (substr (ph_header_line,
	     shi_current_inner_position + 1), shi_delimiter);
	shi_header_part_length = shi_second_delimiter_position - 1;
	shi_number_of_parts_found = shi_number_of_parts_found + 1;
	header_info.lines (shi_loop).parts (shi_current_header_part).flags.present = ON;
%skip(1);
	if shi_header_part_length ^= 0
	then if search (substr (ph_header_line, 
	     shi_current_inner_position + 1, shi_header_part_length), LEFT_OR_RIGHT_BRACKET) ^= 0
	     then header_info.lines (shi_loop).parts (shi_current_header_part).flags.active = ON;
	     else;
	else;
%skip(1);
	header_info.lines (shi_loop).parts (shi_current_header_part).index
	     = headers_next_byte + shi_current_inner_position;
	header_info.lines (shi_loop).parts (shi_current_header_part).length = shi_header_part_length;
%skip(1);
	shi_current_inner_position = shi_current_inner_position + shi_second_delimiter_position;
	if shi_current_inner_position >= ph_header_line_length
	then shi_still_parsing = OFF;
	else shi_current_header_part = shi_current_header_part + 1;
	if shi_current_header_part > hi_init_maximum_number_of_parts
	then call ssu_$abort_line (sci_ptr, linus_error_$bad_report_setup,
	     "^/A header or footer was found which contained more than ^d parts."
	     || "^/The line in error was ^/^a", hi_init_maximum_number_of_parts, ph_header_line);
%skip(1);
	return;
%skip(1);
     end set_header_part_info;
%skip(1);	
     end parse_header;
%skip(1);
     end setup_header_info;
%page;
setup_input_column_info: proc;
%skip(1);
dcl sici_hit bit (1) aligned;
dcl sici_inner_loop fixed bin;
dcl sici_loop fixed bin;
%skip(3);
/*
     Allocate and init the input_columns_info and input_columns_order structures.
*/
%skip(1);
	initialize_number_of_columns = number_of_defined_columns;
	allocate input_columns_info in (work_area) set (input_columns_ip);
	unspec (input_columns_info.columns) = OFF;
	format_report_info.input_columns_info_ptr = input_columns_ip;
	allocate input_columns_order in (work_area) set (input_columns_op);
	format_report_info.input_columns_order_ptr = input_columns_op;
%skip(1);
/*
     Set the width, alignment, folding, prefix character, editing, title, 
     and data type for each column. Stash the editing string and the title
     in the editing strings temp segment.
*/
%skip(1);
	do sici_loop = 1 to number_of_defined_columns;
	     option_identifier = ltrim (convert (option_identifier, sici_loop));
	     input_columns_info.columns (sici_loop).input_column = sici_loop;
%skip(1);
	     call get_option_value (OPTIONS.SPECIFIC_COLUMN.NAME
		(INDEX_FOR_WIDTH), option_identifier, option_value);
	     input_columns_info.columns (sici_loop).width = convert (sici_loop, option_value);
%skip(1);
	     call get_option_value (OPTIONS.SPECIFIC_COLUMN.NAME
		(INDEX_FOR_ALIGNMENT), option_identifier, option_value);
	     call set_alignment_and_decimal_position (sici_loop, option_value);
%skip(1);
	     call get_option_value (OPTIONS.SPECIFIC_COLUMN.NAME
		(INDEX_FOR_FOLDING), option_identifier, option_value);
	     if option_value = "fill"
	     then input_columns_info.columns (sici_loop).folding_is_fill = ON;
	     else input_columns_info.columns (sici_loop).folding_is_fill = OFF;
	     input_columns_info.columns (sici_loop).prefix_character = "";
%skip(1);
	     call get_option_value (OPTIONS.SPECIFIC_COLUMN.NAME
		(INDEX_FOR_EDITING), option_identifier, option_value);
	     if option_value = ""
	     then input_columns_info.columns (sici_loop).editing = OFF;
	     else do;
		format_report_info.flags.editing_is_defined = ON;
		input_columns_info.columns (sici_loop).editing = ON;
		input_columns_info.columns (sici_loop).editing_string_length = length (option_value);
		input_columns_info.columns (sici_loop).editing_string_ptr
		     = addr (editing_strings_temp_seg_as_an_array (editing_strings_next_byte));
		substr (editing_strings_temp_seg, editing_strings_next_byte, 
		     input_columns_info.columns (sici_loop).editing_string_length) = option_value;
		editing_strings_next_byte = editing_strings_next_byte
		     + input_columns_info.columns (sici_loop).editing_string_length;
	     end;
%skip(1);
	     call get_option_value (OPTIONS.SPECIFIC_COLUMN.NAME
		(INDEX_FOR_TITLE), option_identifier, option_value);
	     if option_value = ""
	     then option_value = BLANK;
	     input_columns_info.columns (sici_loop).editing_string_result_length = length (option_value);
	     input_columns_info.columns (sici_loop).editing_string_result_ptr
		= addr (editing_strings_temp_seg_as_an_array (editing_strings_next_byte));
	     substr (editing_strings_temp_seg, editing_strings_next_byte, 
		input_columns_info.columns (sici_loop).editing_string_result_length) = option_value;
	     editing_strings_next_byte = editing_strings_next_byte
		+ input_columns_info.columns (sici_loop).editing_string_result_length;
%skip(1);
	     call set_linus_data_type (sici_loop);
	end;
%skip(1);
/*
     Set the next available byte in the editing strings temp seg. Allocate
     the column map structure. Map the column order list and set the
     input_columns_info and input_columns_order structures to reflect the 
     order. Set the grouping info.
*/
%skip(1);
	format_report_info.editing_strings_next_available_byte = editing_strings_next_byte;
	column_map_number_of_columns = number_of_defined_columns;
	allocate column_map in (work_area) set (column_mp);
%skip(1);
	call get_option_value (OPTIONS.GENERAL_COLUMN.NAME
	     (INDEX_FOR_COLUMN_ORDER), "", option_value);
	call map_column_list (OUTPUT_MAP, option_value, no_of_columns_found);
	do sici_loop = 1 to number_of_defined_columns;
	     input_columns_info.columns (sici_loop).order = column_map.position (sici_loop);
	     input_columns_info.columns (sici_loop).input_column = sici_loop;
	     input_columns_order (sici_loop) = column_map.position (sici_loop);
	end;
%skip(1);
	call set_grouping_info (OPTIONS.GENERAL_COLUMN.NAME (INDEX_FOR_GROUP),
	     format_report_info.flags.group_is_defined, format_report_info.group_info_ptr);
	if format_report_info.flags.group_is_defined
	then group_ip = format_report_info.group_info_ptr;
	else group_ip = null ();
%page;
/*
     Allocate/set the page_break_info structure. Any column requested as a
     page break candidate who is a member of the "group" columns has any
     columns more major in the group set also.
*/
%skip(1);
	call get_option_value (OPTIONS.GENERAL_COLUMN.NAME
	     (INDEX_FOR_PAGE_BREAK), "", option_value);
	if option_value = ""
	then do;
	     format_report_info.flags.page_break_is_defined = OFF;
	     format_report_info.page_break_info_ptr = null ();
	end;
	else do;
	     format_report_info.flags.page_break_is_defined = ON;
	     call map_column_list (INPUT_MAP, option_value, no_of_columns_found);
	     pbi_init_number_of_columns = input_columns_info.number_of_columns;
	     allocate page_break_info in (work_area) set (page_break_ip);
	     page_break_info.columns (*) = OFF;
	     format_report_info.page_break_info_ptr = page_break_ip;
	     do sici_loop = 1 to input_columns_info.number_of_columns;
		if column_map.present (sici_loop)
		then page_break_info.columns (sici_loop) = ON;
	     end;
	     if format_report_info.flags.group_is_defined
	     then do;
		do sici_loop = 1 to input_columns_info.number_of_columns;
		     sici_hit = OFF;
		     do sici_inner_loop = group_info.number_of_columns_to_group to 1 by -1;
			if group_info.column_number (sici_inner_loop) = sici_loop
			& page_break_info.columns (group_info.column_number (sici_inner_loop))
			then sici_hit = ON;
			if sici_hit
			then page_break_info.columns (group_info.column_number (sici_inner_loop)) = ON;
		     end;
		end;
	     end;
	end;
%page;
/*
     Allocate/set the outline_info structure. The columns named who are a
     member of the "group" of columns are treated separately from the columns
     who are not a member of the group.
*/
%skip(1);
	call get_option_value (OPTIONS.GENERAL_COLUMN.NAME
	     (INDEX_FOR_OUTLINE), "", option_value);
	if option_value = ""
	then do;
	     format_report_info.flags.outline_is_defined = OFF;
	     format_report_info.outline_info_ptr = null ();
	end;
	else do;
	     format_report_info.flags.outline_is_defined = ON;
	     call map_column_list (INPUT_MAP, option_value, no_of_columns_found);
	     if format_report_info.flags.group_is_defined
	     then oi_init_maximum_number_of_grouping_columns = group_info.number_of_columns_to_group;
	     else oi_init_maximum_number_of_grouping_columns = 0;
	     oi_init_maximum_number_of_single_columns = input_columns_info.number_of_columns;
	     allocate outline_info in (work_area) set (outline_ip);
	     format_report_info.outline_info_ptr = outline_ip;
	     outline_info.number_of_grouping_columns = 0;
	     if format_report_info.flags.group_is_defined
	     then do sici_loop = 1 to input_columns_info.number_of_columns;
		do sici_inner_loop = group_info.number_of_columns_to_group to 1 by -1;
		     if group_info.column_number (sici_inner_loop) = sici_loop
		     & column_map.present (group_info.column_number (sici_inner_loop))
		     then do;
			outline_info.number_of_grouping_columns
			     = outline_info.number_of_grouping_columns + 1;
			outline_info.grouping_columns (outline_info.number_of_grouping_columns)
			     = group_info.column_number (sici_inner_loop);
			column_map.present (group_info.column_number (sici_inner_loop)) = OFF;
		     end;
		end;
	     end;
	     outline_info.number_of_single_columns = 0;
	     if outline_info.number_of_grouping_columns ^= no_of_columns_found
	     then do sici_loop = 1 to input_columns_info.number_of_columns;
		if column_map.present (sici_loop)
		then do;
		     outline_info.number_of_single_columns = outline_info.number_of_single_columns + 1;
		     outline_info.single_columns (outline_info.number_of_single_columns) = sici_loop;
		end;
	     end;
	end;
%skip(1);
          return;
%skip(1);
     end setup_input_column_info;
%page;
setup_output_column_info: proc;
%skip(1);
dcl soci_inner_loop fixed bin;
dcl soci_loop fixed bin;
%skip(3);
/*
     Find out which columns are excluded from the page.
*/
%skip(1);
	call get_option_value (OPTIONS.GENERAL_COLUMN.NAME
	     (INDEX_FOR_EXCLUDE), "", option_value);
	if option_value ^= ""
	then do;
	     format_report_info.flags.exclude_is_defined = ON;
	     call map_column_list (INPUT_MAP, option_value, no_of_columns_found);
	     initialize_number_of_columns = number_of_defined_columns - no_of_columns_found;
	end;
	else do;
	     initialize_number_of_columns = number_of_defined_columns;
	     unspec (column_map) = OFF;
	end;
%skip(1);
/*
     If all columns are excluded fill them in as all present for the case
     where it is a report consisting of totals/subtotals only.
*/
%skip(1);
	if initialize_number_of_columns = 0
	then do;
	     format_report_info.flags.row_value_is_defined = OFF;
	     initialize_number_of_columns = number_of_defined_columns;
	     unspec (column_map) = OFF;
	end;
	else format_report_info.flags.row_value_is_defined = ON;
	allocate output_columns_info in (work_area) set (output_columns_ip);
	format_report_info.output_columns_info_ptr = output_columns_ip;
%page;
/*
     Allocate/set the output_columns_order array. Assign input_columns_info
     for each column that isn't excluded into output_columns_info, and make
     each output_columns_info reflect it's input_columns_info (i.e. if the
     user re-ordered and excluded columns, the output_columns_info structure
     will reflect it.)     
*/
%skip(1);
	output_columns_order_number_of_columns = output_columns_info.number_of_columns;
	allocate output_columns_order in (work_area) set (output_columns_op);
	soci_inner_loop = 1;
%skip(1);
	do soci_loop = 1 to number_of_defined_columns;
	     if ^column_map.present (input_columns_info.columns (soci_loop).order)
	     then do;
		output_columns_order (soci_inner_loop) = input_columns_info.columns (soci_loop).order;
		soci_inner_loop = soci_inner_loop + 1;
	     end;
	end;
%skip(1);
	do soci_loop = 1 to output_columns_info.number_of_columns;
	     output_columns_info.columns (soci_loop)
		= input_columns_info.columns (output_columns_order (soci_loop));
	     input_columns_info.columns (output_columns_order (soci_loop)).output_column = soci_loop;
	end;
%skip(1);
	return;
%skip(1);
     end setup_output_column_info;
%page;
setup_page_info: proc;
%skip(1);
dcl spi_current_detail_line fixed bin;
dcl spi_current_position fixed bin;
dcl spi_exceeds_max_seg_size bit (1) aligned;
dcl spi_last_column_on_detail_line bit (1) aligned;
dcl spi_loop fixed bin;
dcl spi_separator_width fixed bin;
%skip(3);
/*
     Get the page length and width. A page length of zero means the report is
     unpaginated. If page length is zero then set the internal page length
     to a healthy buffer size. Unpaginated reports are buffered into chunks
     that are mostly treated just like a page, because it would be foolish
     to try to do the whole report in one chunk when there may be several
     million rows in the table. Allocate formatted_page_info structure.
*/
%skip(1);
	call get_option_value (OPTIONS.GENERAL_REPORT.NAME
	     (INDEX_FOR_PAGE_WIDTH), "", option_value);
	format_report_info.page_width = convert (spi_loop, option_value);
	if format_report_info.page_width = 0
	then format_report_info.flags.unlimited_page_width = ON;
	else format_report_info.flags.unlimited_page_width = OFF;
	call get_option_value (OPTIONS.GENERAL_REPORT.NAME
	     (INDEX_FOR_PAGE_LENGTH), "", option_value);
	format_report_info.page_length = convert (spi_loop, option_value);
	if format_report_info.page_length = 0
	then do;
	     report_control_info.flags.report_is_paginated = OFF;
	     format_report_info.flags.unlimited_page_length = ON;
	     format_report_info.page_length = convert (format_report_info.page_length,
		OPTIONS.GENERAL_REPORT.VALUE (INDEX_FOR_PAGE_LENGTH)) * SAFETY_FACTOR;
	end;
	else do;
	     report_control_info.flags.report_is_paginated = ON;
	     format_report_info.flags.unlimited_page_length = OFF;
	end;
	fpi_init_maximum_number_of_detail_blocks = format_report_info.page_length;
	allocate formatted_page_info in (work_area) set (formatted_page_ip);
	format_report_info.formatted_page_info_ptr = formatted_page_ip;
%skip(1);
/*
     Get the definition of the title line. If page width is zero then calculate
     exactly what's needed; if it isn't zero then reduce the width of any
     column who exceeds page width to page width.
*/
%skip(1);
	call get_option_value (OPTIONS.GENERAL_REPORT.NAME
	     (INDEX_FOR_TITLE_LINE), "", option_value);
	if option_value = "on"
	then format_report_info.flags.title_block_is_defined = ON;
	else format_report_info.flags.title_block_is_defined = OFF;
%skip(1);
	if format_report_info.page_width = 0
	then do;
	     spi_current_position = 1;
	     do spi_loop = 1 to output_columns_info.number_of_columns;
		spi_current_position = spi_current_position
		     + output_columns_info.columns (spi_loop).width;
		if spi_loop ^= output_columns_info.number_of_columns
		then do;
		     option_identifier = ltrim (convert (option_identifier, 
			output_columns_info.columns (spi_loop).input_column));
		     call get_option_value (OPTIONS.SPECIFIC_COLUMN.NAME
			(INDEX_FOR_SEPARATOR), option_identifier, option_value);
		     spi_current_position = spi_current_position + length (option_value);
		end;
		else;
	     end;
	     format_report_info.page_width = spi_current_position - 1;
	end;
	else do spi_loop = 1 to output_columns_info.number_of_columns;
	     if output_columns_info.columns (spi_loop).width > format_report_info.page_width
	     then output_columns_info.columns (spi_loop).width = format_report_info.page_width;
	end;
%skip(1);
/*
     Add one to page width to accomodate the newline. If report isn't paginated
     then check to make sure that our chosen page length * page width doesn't
     exceed the maximum segment size. If it does reduce accordingly.
*/
%skip(1);
	format_report_info.page_width = format_report_info.page_width + 1;
	if format_report_info.flags.unlimited_page_length
	then do;
	     spi_exceeds_max_seg_size = ON;
	     do while (spi_exceeds_max_seg_size);
		if format_report_info.page_width * (format_report_info.page_length - 6) ^> maximum_segment_size
		then spi_exceeds_max_seg_size = OFF;
		else do;
		     if format_report_info.page_length < 8
		     then call ssu_$abort_line (sci_ptr, linus_error_$bad_report_setup,
			"The page width of ^d causes a single page to exceed the maximum segment size.",
			format_report_info.page_width);

		     format_report_info.page_length = divide (format_report_info.page_length, 2, 17);
		     if format_report_info.page_length < 7
		     then format_report_info.page_length = 7;
		     else;
		end;
	     end;
	end;
%page;
/*
     Allocate/set page_info structure. Make sure a single page doesn't exceed
     a segment for paginated reports. Allocate a second copy of the structure
     so linus_fr_build_page can adjust the length, width, and total_characters
     after formatting each page and then restore the original structure before
     beginning the next page. Allocate page_overstrike_info structure.
*/
%skip(1);
	allocate page_info in (work_area) set (page_ip);
	page_info.width = format_report_info.page_width;
	page_info.length = format_report_info.page_length - 6;
	page_info.total_characters = page_info.width * page_info.length;
	if format_report_info.flags.unlimited_page_length
	then if page_info.total_characters > maximum_segment_size
	     then call ssu_$abort_line (sci_ptr, linus_error_$bad_report_setup,
	          "^/The page width of ^d and the page length of ^d cause a single page to exceed the maximum segment size.",
	          format_report_info.page_width, format_report_info.page_length);
	     else;
	else;
	page_info.page_info_size = size (page_info);
	page_info.page_ptr = report_control_info.report_temp_seg_ptr;
	page_info.formatted_page_info_ptr = format_report_info.formatted_page_info_ptr;
	format_report_info.page_info_ptr = page_ip;
	allocate page_info in (work_area) set (page_ip);
	page_info = format_report_info.page_info_ptr -> page_info;
	format_report_info.copy_of_page_info_ptr = page_ip;
	allocate page_overstrike_info in (work_area) set (page_overstrike_ip);
	format_report_info.overstrike_info_ptr = page_overstrike_ip;
%skip(1);
/*
     Allocate the generic_template (for headers and the like). Base template
     at the beginning of the temp seg and assign it initially the value of
     the generic template.
*/
%skip(1);
	generic_template_length = page_info.width;
	allocate generic_template in (work_area) set (generic_tp);
	generic_template = BLANK;
	substr (generic_template, generic_template_length, 1) = NL;
	format_report_info.generic_template_ptr = generic_tp;
	template_length = generic_template_length;
	template_ptr = temp_seg_ptr;
	template = generic_template;
%page;
/*
     Walk through the output columns. Set the number of detail lines a row
     value will take and do folding of columns which won't fit down to the
     next detail line(s). Create a template for each individual detail line
     and stash it away in the temp seg. Set the starting position on the page
     for each output column, and fill it's separator into the template. The
     last column of each detail line doesn't have a separator.
*/
%skip(1);
	spi_current_detail_line = 1;
	spi_current_position = 1;
%skip(1);
	do spi_loop = 1 to output_columns_info.number_of_columns;
	     option_identifier = ltrim (convert (option_identifier, 
		output_columns_info.columns (spi_loop).input_column));
	     if spi_loop = output_columns_info.number_of_columns
	     then spi_last_column_on_detail_line = ON;
	     else spi_last_column_on_detail_line = OFF;
%skip(1);
	     output_columns_info.columns (spi_loop).starting_position = spi_current_position;
	     output_columns_info.columns (spi_loop).output_line = spi_current_detail_line;
	     spi_current_position = spi_current_position + output_columns_info.columns (spi_loop).width;
%skip(1);
	     call get_option_value (OPTIONS.SPECIFIC_COLUMN.NAME
		(INDEX_FOR_SEPARATOR), option_identifier, option_value);
	     spi_separator_width = length (option_value);
	     if spi_current_position + spi_separator_width > page_info.width
	     then spi_last_column_on_detail_line = ON;
%skip(1);
	     if ^spi_last_column_on_detail_line
	     then if spi_current_position + spi_separator_width
		+ output_columns_info.columns (spi_loop + 1).width > page_info.width
		then spi_last_column_on_detail_line = ON;
%skip(1);
	     if ^spi_last_column_on_detail_line
	     then do;
		substr (template, spi_current_position, spi_separator_width) = option_value;
		spi_current_position = spi_current_position + spi_separator_width;
	     end;
	     else if spi_loop ^= output_columns_info.number_of_columns
		then do;
		     template_ptr = addrel (template_ptr, size (template));
		     template = generic_template;
		     spi_current_detail_line = spi_current_detail_line + 1;
		     spi_current_position = 1;
		end;
		else;
	end;
%page;
/*
     Initialize the number of templates, and allocate/set the 
     row_value_template_info structure. Allocate the template_map
     structure (used to determine which lines on a page have already
     had a template laid down).
*/
%skip(1);
	ti_init_number_of_templates = spi_current_detail_line;
	ti_init_template_width = template_length;
	allocate row_value_template_info in (work_area) set (row_value_template_ip);
	format_report_info.row_value_template_info_ptr = row_value_template_ip;
	template_map_number_of_bits = page_info.length;
	allocate template_map in (work_area) set (template_mp);
	format_report_info.template_map_ptr = template_mp;
	template_ptr = temp_seg_ptr;
	do spi_loop = 1 to spi_current_detail_line;
	     row_value_template_info.templates (spi_loop) = template;
	     template_ptr = addrel (template_ptr, size (template));
	end;
%skip(1);
/*
     If the title line is on then allocate/set the title_block_columns_info
     structure. Null the pointer to the title_block_info structure so that
     linus_fr_build_page will know it is the first time formatting the titles
     (it only formats the title block on page 1 and then places the resulting
     lines on the page for every one after page 1.)
*/
%skip(1);
	if format_report_info.flags.title_block_is_defined
	then do;
	     initialize_number_of_columns = output_columns_info.number_of_columns;
	     allocate title_block_columns_info in (work_area) set (title_block_columns_ip);
	     title_block_columns_info = output_columns_info;
	     format_report_info.title_block_columns_info_ptr = title_block_columns_ip;
	     do spi_loop = 1 to initialize_number_of_columns;
		column_ip = addr (title_block_columns_info.columns (spi_loop));
		column_info.flags.outline = OFF;
		column_info.flags.editing = ON;
		column_info.alignment = CENTER_ALIGNMENT;
	     end;
	     format_report_info.title_block_info_ptr = null ();
	end;
%skip(1);
	return;
%skip(1);
     end setup_page_info;
%page;
setup_report_info: proc;
%skip(3);
/*
     Set the truncation indicator. Allocate/set the format_document_options
     structure.
*/
%skip(1);
	call get_option_value (OPTIONS.GENERAL_REPORT.NAME
	     (INDEX_FOR_TRUNCATION), "", option_value);
	format_report_info.truncation_indicator = option_value;
%skip(1);
	allocate format_document_options in (work_area) set (format_document_options_ptr);
	unspec (format_document_options) = OFF;
	format_document_options.version_number = format_document_version_2;
	format_document_options.switches.galley_sw = ON;
	format_document_options.switches.break_word_sw = ON;
	format_document_options.switches.max_line_length_sw = ON;
	format_document_options.switches.sub_err_sw = ON;
	call get_option_value (OPTIONS.GENERAL_REPORT.NAME
	     (INDEX_FOR_FORMAT_DOCUMENT_CONTROLS), "", option_value);
	if option_value = "off"
	then do;
	     format_document_options.switches.literal_sw = ON;
	     format_document_options.switches.dont_compress_sw = ON;
	end;
	call get_option_value (OPTIONS.GENERAL_REPORT.NAME
	     (INDEX_FOR_HYPHENATION), "", option_value);
	if option_value = "on"
	then format_document_options.switches.hyphenation_sw = ON;
	format_document_options.syllable_size = DEFAULT_SYLLABLE_SIZE;
	format_report_info.format_document_op = format_document_options_ptr;
%skip(1);
/*
     If it's a permanent report then setup the file which will contain a
     copy of each formatted page.
*/
%skip(1);
	if report_control_info.flags.permanent_report
	then do;
	     switch_name = unique_chars_ ("0"b) || ".linus_report";
	     format_report_info.report_entry_name = unique_chars_ ("0"b);
	     format_report_info.report_directory_name = report_control_info.temp_dir_name;
	     call iox_$attach_name (switch_name, iocb_ptr,
		"vfile_ " || rtrim (format_report_info.report_directory_name)
		|| ">" || rtrim (format_report_info.report_entry_name), 
		null (), code);
	     if code ^= 0
	     then call ssu_$abort_line (sci_ptr, code,
		"While trying to attach file ^a in dir ^a.",
		rtrim (format_report_info.report_directory_name),
		rtrim (format_report_info.report_entry_name));
	     call iox_$open (iocb_ptr, Direct_update, "0"b, code);
	     if code ^= 0
	     then call ssu_$abort_line (sci_ptr, code,
		"While trying to open file ^a in dir ^a.",
		rtrim (format_report_info.report_directory_name),
		rtrim (format_report_info.report_entry_name));
	     format_report_info.report_iocb_ptr = iocb_ptr;
	end;
%skip(1);
	return;
%skip(1);
     end setup_report_info;
%page;
setup_status_info: proc;
%skip(3);
/*
     Allocate/set the status structure. This is the execution control structure
     that linus_fr_build_page lives and breathes by.
*/
%skip(1);
	allocate status in (work_area) set (status_pointer);
	unspec (status) = OFF;
%skip(1);
	status.number_of_lines_needed_for_detail_block = 0;
	if ^format_report_info.flags.row_header_is_defined
	then status.number_of_lines_needed_for_row_header = 0;
	else do;
	     header_ip = format_report_info.row_header_info_ptr;
	     status.number_of_lines_needed_for_row_header = header_info.number_of_lines;
	     status.number_of_lines_needed_for_detail_block = status.number_of_lines_needed_for_detail_block
		+ status.number_of_lines_needed_for_row_header;
	end;
	if format_report_info.flags.row_value_is_defined
	then do;
	     status.number_of_lines_needed_for_row_value = row_value_template_info.number_of_templates;
	     status.number_of_lines_needed_for_detail_block = status.number_of_lines_needed_for_detail_block
		+ status.number_of_lines_needed_for_row_value;
	end;
	if ^format_report_info.flags.row_footer_is_defined
	then status.number_of_lines_needed_for_row_footer = 0;
	else do;
	     header_ip = format_report_info.row_footer_info_ptr;
	     status.number_of_lines_needed_for_row_footer = header_info.number_of_lines;
	     status.number_of_lines_needed_for_detail_block = status.number_of_lines_needed_for_detail_block
		+ status.number_of_lines_needed_for_row_footer;
	end;
%skip(1);
	if ^format_report_info.flags.page_footer_is_defined
	then status.number_of_lines_needed_for_page_footer = 0;
	else do;
	     header_ip = format_report_info.page_footer_info_ptr;
	     status.number_of_lines_needed_for_page_footer = header_info.number_of_lines;
	end;
%skip(1);
	if ^format_report_info.flags.group_header_is_defined
	then status.number_of_lines_needed_for_group_header = 0;
	else do;
	     header_ip = format_report_info.group_header_info_ptr;
	     status.number_of_lines_needed_for_group_header = header_info.number_of_lines;
	end;
%page;
	if ^format_report_info.flags.group_footer_is_defined
	then status.number_of_lines_needed_for_group_footer = 0;
	else do;
	     header_ip = format_report_info.group_footer_info_ptr;
	     status.number_of_lines_needed_for_group_footer = header_info.number_of_lines;
	end;
%skip(1);
	status.current_row_ptr = null ();
	status.previous_row_ptr = null ();
	status.next_row_ptr = null ();
	status.last_row_number = 0;
	status.last_page_number = 0;
	status.current_pass_number = 1;
	status.flags.last_pass = ON;
%skip(1);
	format_report_info.status_ptr = status_pointer;
%skip(1);
	return;
%skip(1);
     end setup_status_info;
%page;
setup_subcounts_info: proc;
%skip(3);
/*
     Allocate/set the subcount_info, subcount_generation_info, and
     subcount_columns_info structures if the subcount option is defined.
*/
%skip(1);
	call get_option_value (OPTIONS.GENERAL_COLUMN.NAME
	     (INDEX_FOR_SUBCOUNT), "", option_value);
	call setup_subtotals_or_subcounts_info (ROW_SUBCOUNT, option_value,
	     format_report_info.flags.subcount_is_defined, subcount_ip);
	if format_report_info.flags.subcount_is_defined
	then do;
	     format_report_info.subcount_info_ptr = subcount_ip;
	     subcount_generation_ip = subcount_info.subtotal_generation_info_ptr;
	     subcount_columns_ip = subcount_info.columns_info_ptr;
	end;
	else format_report_info.subcount_info_ptr = null ();
%skip(1);
	return;
%skip(1);
     end setup_subcounts_info;
%page;
setup_subtotals_info: proc;
%skip(3);
/*
     Allocate/set the subtotal_info, subtotal_generation_info, and
     subtotal_columns_info structures if the subtotal option is defined.
*/
%skip(1);
	call get_option_value (OPTIONS.GENERAL_COLUMN.NAME
	     (INDEX_FOR_SUBTOTAL), "", option_value);
	call setup_subtotals_or_subcounts_info (ROW_SUBTOTAL, option_value,
	     format_report_info.flags.subtotal_is_defined, subtotal_ip);
	if format_report_info.flags.subtotal_is_defined
	then do;
	     format_report_info.subtotal_info_ptr = subtotal_ip;
	     subtotal_generation_ip = subtotal_info.subtotal_generation_info_ptr;
	     subtotal_columns_ip = subtotal_info.columns_info_ptr;
	end;
	else format_report_info.subtotal_info_ptr = null ();
%skip(1);
	return;
%skip(1);
     end setup_subtotals_info;
%page;
setup_subtotals_or_subcounts_info: proc (

	ssosi_subtotal_flag_parm,	/* input: on for subtotals, off for subcounts */
	ssosi_option_value_parm,	/* input: the value for the option */
	ssosi_defined_flag_parm,	/* output: on if it is defined */
	ssosi_subtotal_info_ptr_parm	/* output: points to subtotal_info structure */
				);
%skip(1);
dcl ssosi_comma_position fixed bin;
dcl ssosi_current_position fixed bin;
dcl ssosi_current_inner_position fixed bin;
dcl ssosi_defined_flag_parm bit (1) parm;
dcl ssosi_inner_loop fixed bin;
dcl ssosi_loop fixed bin;
dcl ssosi_next_blank fixed bin;
dcl ssosi_option_value_parm char (*) varying parm;
dcl ssosi_still_counting_subtotals bit (1) aligned;
dcl ssosi_subtotal_flag_parm bit (1) aligned parm;
dcl 1 ssosi_subtotal_columns_info like subtotal_columns_info based (ssosi_subtotal_columns_info_ptr);
dcl ssosi_subtotal_columns_info_ptr ptr;
dcl 1 ssosi_subtotal_generation_info like subtotal_generation_info based (ssosi_subtotal_generation_info_ptr);
dcl ssosi_subtotal_generation_info_ptr ptr;
dcl 1 ssosi_subtotal_info like subtotal_info based (ssosi_subtotal_info_ptr_parm);
dcl ssosi_subtotal_info_ptr_parm ptr parm;
dcl ssosi_subtotal_list_length fixed bin;
%skip(3);
/*
     This subroutine works for subcounts and subtotals. See if it's defined.
*/
%skip(1);
	if ssosi_option_value_parm = ""
	then do;
	     ssosi_defined_flag_parm = OFF;
	     ssosi_subtotal_info_ptr_parm = null ();
	     return;
	end;
%skip(1);
/*
     Great! First let's remove the subtotals/subcounts whose parents are
     excluded from the page and see if we still have any defined.
*/
%skip(1);
	ssosi_defined_flag_parm = ON;
	si_init_number_of_columns_to_subtotal = 0;
	ssosi_still_counting_subtotals = ON;
	ssosi_current_position = 1;
	ssosi_option_value_parm = ssosi_option_value_parm || BLANK;
	call remove_orphan_subtotals;
	if ssosi_option_value_parm = BLANK
	then do;
	     ssosi_defined_flag_parm = OFF;
	     ssosi_subtotal_info_ptr_parm = null ();
	     return;
	end;
	ssosi_subtotal_list_length = length (ssosi_option_value_parm);
%skip(1);
/*
     We have some defined. Let's see how many.
*/
%skip(1);
	do while (ssosi_still_counting_subtotals);
	     ssosi_next_blank = index (substr (ssosi_option_value_parm, ssosi_current_position), BLANK);
	     if ssosi_next_blank ^= 0
	     then si_init_number_of_columns_to_subtotal = si_init_number_of_columns_to_subtotal + 1;
	     else ssosi_still_counting_subtotals = OFF;
	     if ssosi_still_counting_subtotals
	     then ssosi_current_position = ssosi_current_position + ssosi_next_blank;
	     if ssosi_current_position > ssosi_subtotal_list_length
	     then ssosi_still_counting_subtotals = OFF;
	end;
%skip(1);
/*
     Allocate/set the subtotal_info structure.
*/
%skip(1);
	allocate ssosi_subtotal_info in (work_area) set (ssosi_subtotal_info_ptr_parm);
	ssosi_subtotal_info.current_level = 0;
	unspec (ssosi_subtotal_info.columns) = OFF;
	ssosi_subtotal_info.columns (*).subtotal = 0;
%page;
/*
     Allocate the subtotal_generation_info structure. This is a circular
     list used to place the value of each subtotal after it's been generated.
     During formatting when the removal of rows is necessary, the subtotals
     are restored back to their old values from this circular list.
*/
%skip(1);
	sgi_init_number_of_subtotals = si_init_number_of_columns_to_subtotal;
	sgi_init_number_of_generations = divide (page_info.length, 2, 17) + 1;
	allocate ssosi_subtotal_generation_info in (work_area)
	     set (ssosi_subtotal_generation_info_ptr);
	ssosi_subtotal_info.subtotal_generation_info_ptr = ssosi_subtotal_generation_info_ptr;
	ssosi_subtotal_generation_info.current_generation_block = -1;
%skip(1);
/*
     Allocate/set the subtotal_map structure so we can figure out how
     many levels of them we have (several subtotals defined on the same
     column, who are generated when different column's values change.) For
     the subtotal_info structure set the input column and level for each
     column. Set the highest_level in the same structure. For subtotals
     there is a requirement that they must be numbers; this isn't true
     for subcounts. Set the ioa_ string to edit them through. If the "watch"
     column is a member of the group of columns then mark it. Set the
     reset flag accordingly.
*/
%skip(1);
	subtotal_map_init_number_of_columns = input_columns_info.number_of_columns;
	allocate subtotal_map in (work_area) set (subtotal_map_ptr);
	unspec (subtotal_map.columns) = OFF;
	ssosi_current_position = 1;
	ssosi_subtotal_info.highest_level = 0;
%skip(1);
	do ssosi_loop = 1 to si_init_number_of_columns_to_subtotal;
	     ssosi_current_inner_position = 1;
	     ssosi_next_blank = index (substr (ssosi_option_value_parm, ssosi_current_position), BLANK);
	     ssosi_option_value = substr (ssosi_option_value_parm, 
		ssosi_current_position, ssosi_next_blank - 1);
	     ssosi_comma_position = index (ssosi_option_value, COMMA);
	     ssosi_column_name = substr (ssosi_option_value, 1, ssosi_comma_position - 1);
	     ssosi_subtotal_info.columns (ssosi_loop).input_column = get_column_number ();
	     subtotal_map.columns (ssosi_subtotal_info.columns (ssosi_loop).input_column).present = ON;
	     subtotal_map.columns (ssosi_subtotal_info.columns (ssosi_loop).input_column).number
		= subtotal_map.columns (ssosi_subtotal_info.columns (ssosi_loop).input_column).number + 1;
	     ssosi_subtotal_info.columns (ssosi_loop).level
		= subtotal_map.columns (ssosi_subtotal_info.columns (ssosi_loop).input_column).number;
	     if ssosi_subtotal_info.columns (ssosi_loop).level > ssosi_subtotal_info.highest_level
	     then ssosi_subtotal_info.highest_level = ssosi_subtotal_info.columns (ssosi_loop).level;
	     if ssosi_subtotal_flag_parm
	     then do;
		if input_columns_info.columns (ssosi_subtotal_info.columns
		.input_column (ssosi_loop)).linus_data_type = NUMERIC_DATA_TYPE
		| input_columns_info.columns (ssosi_subtotal_info.columns
		.input_column (ssosi_loop)).linus_data_type = DECIMAL_DATA_TYPE
		then;
	          else call ssu_$abort_line (sci_ptr, linus_error_$bad_report_setup,
		     "^/A subtotal was specified for the ^a column and it is not numeric.",
		     table_info.columns.column_name (ssosi_subtotal_info.columns.input_column (ssosi_loop)));
		call set_ioa_string_for_total_or_subtotal (
		     addr (table_info.columns (ssosi_subtotal_info.columns.input_column (ssosi_loop)).column_data_type),
		     ssosi_subtotal_info.columns.ioa_string (ssosi_loop));
	     end;
	     else ssosi_subtotal_info.columns.ioa_string (ssosi_loop) = "^d";
	     ssosi_current_inner_position = ssosi_current_inner_position + ssosi_comma_position;
	     ssosi_comma_position = index (substr (ssosi_option_value, ssosi_current_inner_position), COMMA);
	     ssosi_column_name = substr (ssosi_option_value,
		ssosi_current_inner_position, ssosi_comma_position - 1);
	     ssosi_subtotal_info.columns (ssosi_loop).watch_column = get_column_number ();
	     if format_report_info.flags.group_is_defined
	     then do ssosi_inner_loop = 1 to group_info.number_of_columns_to_group;
		if group_info.column_number (ssosi_inner_loop)
		= ssosi_subtotal_info.columns (ssosi_loop).watch_column
		then ssosi_subtotal_info.columns (ssosi_loop).flags.group_column = ON;
	     end;
	     ssosi_subtotal_info.columns (ssosi_loop).flags.reset
		= (substr (ssosi_option_value, ssosi_current_inner_position + ssosi_comma_position) = RESET);
	     ssosi_current_position = ssosi_current_position + ssosi_next_blank;
	end;
%skip(1);
/*
     Allocate/set the subtotal_columns_info structure. Assign the values of
     the output_columns to them, and set the prefix of all to blank. Walk
     through the subtotal_columns_info structure setting the prefix of each
     one that is really a subtotal/subcount to "-", and set the alignment in
     the case of subcounts to right.
*/
%skip(1);
	initialize_number_of_columns = output_columns_info.number_of_columns;
	allocate ssosi_subtotal_columns_info in (work_area) set (ssosi_subtotal_columns_info_ptr);
	ssosi_subtotal_info.columns_info_ptr = ssosi_subtotal_columns_info_ptr;
	ssosi_subtotal_columns_info = output_columns_info;
	ssosi_subtotal_columns_info.columns (*).prefix_character = BLANK;
%skip(1);
	do ssosi_loop = 1 to ssosi_subtotal_info.number_of_columns_to_subtotal;
	     ssosi_subtotal_columns_info.columns (input_columns_info.columns
		(ssosi_subtotal_info.columns (ssosi_loop).input_column).output_column).prefix_character = "-";
	     if ^ssosi_subtotal_flag_parm
	     then ssosi_subtotal_columns_info.columns (input_columns_info.columns
		(ssosi_subtotal_info.columns (ssosi_loop).input_column).output_column).alignment = RIGHT_ALIGNMENT;
	end;
%skip(1);
	return;
%page;
get_column_number: proc () returns (fixed bin);
%skip(1);
dcl gcn_loop fixed bin;
%skip(3);
/*
     Get the column number for the supplied column name. These names have been
     verified in linus_options, so any name that isn't found indicates the
     parsing code in this module messed up somewhere.
*/
%skip(1);
	do gcn_loop = 1 to number_of_defined_columns;
	     if ssosi_column_name = table_info.columns.column_name (gcn_loop)
	     then return (gcn_loop);
	end;
%skip(1);
	if ssosi_subtotal_flag_parm
	then call ssu_$abort_line (sci_ptr, linus_error_$bad_report_setup,
	     "The column name ""^a"" in the subtotal list ""^a"" isn't valid.",
	     ssosi_column_name, ssosi_option_value_parm);
	else call ssu_$abort_line (sci_ptr, linus_error_$bad_report_setup,
	     "The column name ""^a"" in the subcount list ""^a"" isn't valid.",
	     ssosi_column_name, ssosi_option_value_parm);
%skip(1);
	return (0);
%skip(1);
     end get_column_number;
%page;
remove_orphan_subtotals: proc;
%skip(1);
dcl ros_column_number fixed bin;
dcl ros_current_position fixed bin;
dcl ros_next_blank fixed bin;
dcl ros_next_comma fixed bin;
dcl ros_still_eliminating_orphans bit (1) aligned;
dcl ros_subtotal_list_length fixed bin;
%skip(3);
/*
     Walk through the list eliminating any subtotals whose parents have been
     excluded from the page.
*/
%skip(1);
	ssosi_option_value = "";
	ros_subtotal_list_length = length (ssosi_option_value_parm);
	ros_current_position = 1;
	ros_still_eliminating_orphans = ON;
%skip(1);
	do while (ros_still_eliminating_orphans);
	     ros_next_blank = index (substr (ssosi_option_value_parm, 
		ros_current_position), BLANK);
	     ros_next_comma = index (substr (ssosi_option_value_parm,
		ros_current_position), COMMA);
	     ssosi_column_name = substr (ssosi_option_value_parm, 
		ros_current_position, ros_next_comma - 1);
	     ros_column_number = get_column_number ();
	     if input_columns_info.columns (ros_column_number).output_column ^= 0
	     then ssosi_option_value = ssosi_option_value
		|| substr (ssosi_option_value_parm, ros_current_position, ros_next_blank);
	     ros_current_position = ros_current_position + ros_next_blank;
	     if ros_current_position > ros_subtotal_list_length
	     then ros_still_eliminating_orphans = OFF;
	end;
%skip(1);
	ssosi_option_value_parm = ssosi_option_value;
%skip(1);
	return;
%skip(1);
     end remove_orphan_subtotals;
%skip(1);
     end setup_subtotals_or_subcounts_info;
%page;
setup_totals_info: proc;
%skip(3);
/*
     Get the subroutine to figure out if we have any defined.
*/
%skip(1);
	call get_option_value (OPTIONS.GENERAL_COLUMN.NAME
	     (INDEX_FOR_TOTAL), "", option_value);
	call setup_totals_or_counts_info (ROW_TOTAL, option_value,
	     format_report_info.flags.total_is_defined, total_ip);
	if format_report_info.flags.total_is_defined
	then format_report_info.total_info_ptr = total_ip;
	else format_report_info.total_info_ptr = null ();
%skip(1);
	return;
%skip(1);
     end setup_totals_info;
%page;
setup_totals_or_counts_info: proc (

	stoci_total_flag_parm,    /* input: on for totals, off for counts */
	stoci_option_value_parm,  /* input: the value for the option */
	stoci_defined_flag_parm,  /* output: on if it's defined */
	stoci_total_info_ptr_parm /* output: points to total_info structure */
	);
%skip(1);
dcl stoci_defined_flag_parm bit (1) parm;
dcl stoci_inner_loop fixed bin;
dcl stoci_loop fixed bin;
dcl stoci_option_value_parm char (*) varying parm;
dcl 1 stoci_total_columns_info like total_columns_info based (stoci_total_columns_info_ptr);
dcl stoci_total_columns_info_ptr ptr;
dcl stoci_total_flag_parm bit (1) aligned parm;
dcl 1 stoci_total_info like total_info based (stoci_total_info_ptr_parm);
dcl stoci_total_info_ptr_parm ptr parm;
%skip(3);
/*
     See if we have any defined.
*/
%skip(1);
	if stoci_option_value_parm = ""
	then do;
	     stoci_defined_flag_parm = OFF;
	     stoci_total_info_ptr_parm = null ();
	     return;
	end;
%skip(1);
/*
     Yes we do. Get a map and remove any totals whose parents are excluded
     from the page. Adjust our count accordingly.
*/
%skip(1);
	stoci_defined_flag_parm = ON;
	call map_column_list (INPUT_MAP, stoci_option_value_parm, 
	     ti_init_number_of_columns_to_total);
	do stoci_loop = 1 to number_of_defined_columns;
	     if column_map.present (stoci_loop)
	     then if input_columns_info.columns (stoci_loop).output_column = 0
		then do;
		     column_map.present (stoci_loop) = OFF;
		     ti_init_number_of_columns_to_total = ti_init_number_of_columns_to_total - 1;
		end;
		else;
	     else;
	end;
%skip(1);
/*
     There may not be any defined at this point.
*/
%skip(1);
	if ti_init_number_of_columns_to_total ^> 0
	then do;
	     stoci_defined_flag_parm = OFF;
	     stoci_total_info_ptr_parm = null ();
	     return;
	end;
%skip(1);
/*
     Looks like we still have some left. Allocate the total_info structure 
     and zero all totals.
*/
%skip(1);
	allocate stoci_total_info in (work_area) set (stoci_total_info_ptr_parm);
	stoci_total_info.columns.total (*) = 0;
	stoci_inner_loop = 1;
%skip(1);
/*
     Walk through the column map setting the input column and ioa_ string.
     There is a requirement that totals be defined on columns that are
     numbers; no such requirement for counts.
*/
%skip(1);
	do stoci_loop = 1 to output_columns_info.number_of_columns;
	     if column_map.present (output_columns_info.columns (stoci_loop).input_column)
	     then do;
		stoci_total_info.columns.input_column (stoci_inner_loop)
		     = output_columns_info.columns (stoci_loop).input_column;
		if stoci_total_flag_parm
		then do;
		     if input_columns_info.columns (stoci_total_info.columns.input_column (stoci_inner_loop))
		     .linus_data_type = NUMERIC_DATA_TYPE
		     | input_columns_info.columns (stoci_total_info.columns.input_column (stoci_inner_loop))
		     .linus_data_type = DECIMAL_DATA_TYPE
		     then;
		     else call ssu_$abort_line (sci_ptr, linus_error_$bad_report_setup,
			"^/A total was specified for the ^a column and it is not numeric.",
			table_info.columns.column_name (stoci_total_info.columns.input_column (stoci_inner_loop)));
		     call set_ioa_string_for_total_or_subtotal (
			addr (table_info.columns (stoci_total_info.columns.input_column (stoci_inner_loop)).column_data_type),
			stoci_total_info.columns.ioa_string (stoci_inner_loop));
		end;
		else stoci_total_info.columns.ioa_string (stoci_inner_loop) = "^d";
		stoci_inner_loop = stoci_inner_loop + 1;
	     end;
	end;
%page;
/*
     Allocate the total_columns_info structure. Assign the output_columns_info
     to total_columns_info. Set outlining on for all and right alignment if we
     are playing with counts rather than totals.
*/
%skip(1);
	initialize_number_of_columns = output_columns_info.number_of_columns;
	allocate stoci_total_columns_info in (work_area) set (stoci_total_columns_info_ptr);
	stoci_total_info.columns_info_ptr = stoci_total_columns_info_ptr;
	stoci_total_columns_info = output_columns_info;
	stoci_total_columns_info.columns (*).flags.outline = ON;
	if ^stoci_total_flag_parm
	then stoci_total_columns_info.columns (*).alignment = RIGHT_ALIGNMENT;
%skip(1);
	return;
%skip(1);
     end setup_totals_or_counts_info;
%page;
set_alignment_and_decimal_position: proc (

	saadp_column_number_parm, /* input: number of column */
	saadp_option_value_parm   /* input: value of option for column */
				 );
%skip(1);
dcl saadp_claimed_digits char (7) varying;
dcl saadp_column_number_parm parm;
dcl saadp_option_value_parm char (*) varying parm;
%skip(3);
/*
     Set the alignment and in the case of decimal, the position within the
     display width where the decimal alignment should take place.
*/
%skip(1);
	if saadp_option_value_parm = "center"
	then input_columns_info.columns (saadp_column_number_parm).alignment 
	     = CENTER_ALIGNMENT;
	else if saadp_option_value_parm = "left"
	     then input_columns_info.columns (saadp_column_number_parm)
	          .alignment = LEFT_ALIGNMENT;
	     else if saadp_option_value_parm = "right"
		then input_columns_info.columns (saadp_column_number_parm)
		     .alignment = RIGHT_ALIGNMENT;
	          else if saadp_option_value_parm = "both"
		     then input_columns_info.columns (saadp_column_number_parm)
		          .alignment = BOTH_ALIGNMENT;
		     else do;
			input_columns_info.columns (saadp_column_number_parm)
			     .alignment = DECIMAL_ALIGNMENT;
			saadp_claimed_digits = after (saadp_option_value_parm, BLANK);
			if verify (saadp_claimed_digits, DIGITS) ^= 0
			then call ssu_$abort_line (sci_ptr, linus_error_$bad_report_setup,
			     "^/The decimal alignment position could not be converted to an integer. ""^a""",
			     saadp_option_value_parm);
			input_columns_info.columns (saadp_column_number_parm).decimal_position
			     = convert (saadp_column_number_parm, saadp_claimed_digits);
			if input_columns_info.columns (saadp_column_number_parm).decimal_position
			> input_columns_info.columns (saadp_column_number_parm).width
			then call ssu_$abort_line (sci_ptr, linus_error_$bad_report_setup,
			     "^/The decimal alignment position ^d is larger than the column width ^d for column number ^d.",
			     input_columns_info.columns (saadp_column_number_parm).decimal_position,
			     input_columns_info.columns (saadp_column_number_parm).width,
			     saadp_column_number_parm);
		     end;
%skip(1);
	return;
%skip(1);
     end set_alignment_and_decimal_position;
%page;
set_linus_data_type: proc (sldt_column_number_parm);
%skip(1);
dcl sldt_column_number_parm fixed bin parm;
dcl sldt_column_type fixed bin (6) unsigned unaligned;
%skip(3);
/*
     Simplify all of the possibilities into numeric, decimal, bit or character.
*/
%skip(1);
	desc_ptr = addr (table_info.columns.column_data_type (sldt_column_number_parm));
	sldt_column_type = descriptor.type;
%skip(1);
	if (sldt_column_type >= 1 & sldt_column_type <= 8)
	| (sldt_column_type = 33 | sldt_column_type = 34)
	then input_columns_info.columns (sldt_column_number_parm)
	     .linus_data_type = NUMERIC_DATA_TYPE;
	else if (sldt_column_type >= 9 & sldt_column_type <= 12)
	     | (sldt_column_type = 29 | sldt_column_type = 30)
	     | (sldt_column_type = 35 | sldt_column_type = 36)
	     | (sldt_column_type >= 38 & sldt_column_type <= 46)
	     then input_columns_info.columns (sldt_column_number_parm)
	          .linus_data_type = DECIMAL_DATA_TYPE;
	     else if (sldt_column_type = 19 | sldt_column_type = 20)
		then input_columns_info.columns (sldt_column_number_parm)
		     .linus_data_type = BIT_DATA_TYPE;
	          else if (sldt_column_type = 21 | sldt_column_type = 22)
		     then input_columns_info.columns (sldt_column_number_parm)
		          .linus_data_type = CHAR_DATA_TYPE;
		     else call ssu_$abort_line (sci_ptr, linus_error_$bad_report_setup,
			"^/The table information described an unsupported data type.^/The data type was ^d.", 
			sldt_column_type);
%skip(1);
	return;
%skip(1);
     end set_linus_data_type;
%page;
dcl BLANK char (1) static int options (constant) init (" ");
dcl COMMA char (1) static int options (constant) init (",");
dcl DEFAULT_SYLLABLE_SIZE fixed bin static int options (constant) init (2);
dcl DIGITS char (10) static int options (constant) init ("0123456789");
dcl INPUT_MAP bit (1) aligned static int options (constant) init ("1"b);
dcl LEFT_OR_RIGHT_BRACKET char (2) internal static options (constant) init ("[]");
dcl NL char (1) internal static options (constant) init ("
");
dcl OFF bit (1) aligned internal static options (constant) init ("0"b);
dcl ON bit (1) aligned internal static options (constant) init ("1"b);
dcl OUTPUT_MAP bit (1) aligned static int options (constant) init ("0"b);
dcl RESET char (5) static int options (constant) init ("reset");
dcl ROW_COUNT bit (1) aligned static int options (constant) init ("0"b);
dcl ROW_SUBCOUNT bit (1) aligned static int options (constant) init ("0"b);
dcl ROW_SUBTOTAL bit (1) aligned static int options (constant) init ("1"b);
dcl ROW_TOTAL bit (1) aligned static int options (constant) init ("1"b);
dcl SAFETY_FACTOR fixed bin int static options (constant) init (4);
%page;
dcl addr builtin;
dcl addrel builtin;
dcl after builtin;
%skip(1);
dcl code fixed bin (35);
dcl convert builtin;
%skip(1);
dcl divide builtin;
%skip(1);
dcl fixed builtin;
%skip(1);
dcl iocb_ptr ptr;
dcl index builtin;
dcl iox_$attach_name entry (char(*), ptr, char(*), ptr, fixed bin(35));
dcl iox_$open entry (ptr, fixed bin, bit(1) aligned, fixed bin(35));
%skip(1);
dcl lcn_column_name char (MAXIMUM_OPTION_IDENTIFIER_LENGTH) varying;
dcl length builtin;
dcl linus_error_$bad_option_value fixed bin(35) ext static;
dcl linus_error_$bad_report_setup fixed bin(35) ext static;
dcl linus_options$get entry (ptr, char(*) var, char(*) var, char(*) var, char(*) var, fixed bin(35));
dcl linus_table$info entry (ptr, ptr, fixed bin(35));
dcl ltrim builtin;
%skip(1);
dcl mod builtin;
%skip(1);
dcl no_of_columns_found fixed bin;
dcl normalized_option_name char (97) varying;
dcl null builtin;
dcl number_of_defined_columns fixed bin;
%skip(1);
dcl option_identifier char (MAXIMUM_OPTION_IDENTIFIER_LENGTH) varying;
dcl option_value char (MAXIMUM_OPTION_VALUE_LENGTH) varying;
dcl output_columns_order (output_columns_order_number_of_columns) fixed bin based (output_columns_op);
dcl output_columns_order_number_of_columns fixed bin;
dcl output_columns_op ptr;
%skip(1);
dcl ph_header_line char (MAXIMUM_OPTION_VALUE_LENGTH) varying;
%skip(1);
dcl rel builtin;
dcl rtrim builtin;
%skip(1);
dcl sci_ptr ptr;
dcl search builtin;
dcl size builtin;
dcl ssosi_column_name char (MAXIMUM_OPTION_IDENTIFIER_LENGTH) varying;
dcl ssosi_option_value char (MAXIMUM_OPTION_VALUE_LENGTH) varying;
dcl ssu_$abort_line entry() options(variable);
dcl 1 subtotal_map aligned based (subtotal_map_ptr),
      2 number_of_columns fixed bin,
      2 columns (subtotal_map_init_number_of_columns refer (subtotal_map.number_of_columns)),
        3 present bit (1),
        3 number fixed bin;
dcl substr builtin;
dcl subtotal_map_init_number_of_columns fixed bin;
dcl subtotal_map_ptr ptr;
dcl switch_name char (32);
dcl sys_info$max_seg_size fixed bin(35) ext static;
%skip(1);
dcl temp_seg_ptr ptr;
%skip(1);
dcl unique_chars_ entry (bit(*)) returns(char(15));
dcl unspec builtin;
%skip(1);
dcl verify builtin;
%skip(1);
dcl work_area area (sys_info$max_seg_size) based (work_area_ptr);
dcl work_area_ptr ptr;
%page;
%include arg_descriptor;
%page;
%include arg_list;
%page;
%include format_document_options;
%page;
%include iox_modes;
%page;
%include linus_lcb;
%page;
%include linus_format_options;
%page;
%include linus_names_and_values;
%page;
%include linus_options_extents;
%page;
%include linus_page_info;
%page;
%include linus_report_info;
%page;
%include linus_report_structures;
%page;
%include linus_table_control;
%page;
%include linus_table_info;
%page;
%include mdbm_descriptor;
%skip(3);
     end linus_fr_new_report;

