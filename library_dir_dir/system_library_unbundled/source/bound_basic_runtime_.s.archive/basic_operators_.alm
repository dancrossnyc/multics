" ***********************************************************
" *                                                         *
" * Copyright, (C) Honeywell Information Systems Inc., 1982 *
" *                                                         *
" * Copyright (c) 1972 by Massachusetts Institute of        *
" * Technology and Honeywell Information Systems, Inc.      *
" *                                                         *
" ***********************************************************

"
"	Operators segment for Multics BASIC
"	Inital Version:	Spring 1973 by BLW
"	Modified:		18 March 1974 by BLW to fix bug 017
"	Modified:		28 March 1974 by BLW to fix bugs 018 & 021
"	Modified:		19 July 1974 by BLW to fix bugs 034, 034, 035, & 041
"	Modified:		5 August 1974 by BLW to preserve EAQ around string assignment
"	Modified:		16 August 1974 by BLW to fix bug 046
"	Modified:		27 August 1974 by BLW to fix bug 047
"	Modified:		9 July by J.M. Broughton for debuggers to find op return loc
"	Modified:		30 April 1976 by MBW  to add macros for extended precision and fix bugs 060, 062
"	Modified:		8 December 1976 by MBW to correct references to string segment
"	Modified:		24 January 1977 by MBW to fix bugs 063 and 065
"	Modified:		26 January 1977 by MBW to pass char strings as char (*) to non-basic progs
"	Modified:		14 July 1977 by MBW to convert to alm and fix bug 075 (ep list assign)
"	Modified:		23 September 1977 by MBW to fix bugs 078 and 079
"	Modified:		25 May 1978 by MBW to fix bug 081
"	Modified:		24 November 1980 by MBW to fix bugs 087 and 091
"	Modified:		1 April 1980 by MBW to reference strings thru pr5 and call functions with pr3
"	Modified:		15 July 1981 by MBW to fix bug 098 (using temp3 to store return loc)
"	Modified:		11 September 1981 by MBW to fix bug 102 (string data relocation)
"	Modified:		15 May 1984 by DWL to document use of sst$ for mid$
"	Modified:		22 May 1984 by DWL to add left$
"	Modified:		23 May 1984 by DWL to add right$
"
	tempd	print_using_ptr
"
	tempd	abort_label(2),conversion_label(2),size_label(2),on_units(6)
	tempd	program_header,text_base_ptr,string_segment
	tempd	fcb_pt
	tempd	arglist1(2),runtime_arglist(2)
	tempd	cpu_start,determinant
	temp	fcb(17),file_number,number,pdl,program_header_offset
	temp	numeric_data_pos,string_data_pos,random
	temp	math_block,last_frame,next_frame,number_read,pu_pos,pu_length
	temp	definitions,fn_temp1,fn_temp2,entryname,flags,string_value
	tempd	temp1,temp2,temp3
"
"	temp3 doubles as the return pt to the actual program when a call is
"	performed, its location must be the same as for ep basic for use by debuggers
"
	bool	program_header_equ,102	should be equal to program_header
	equ	args,128
	equ	math_block_size,32	size of storage block for math routines
"
	include	stack_header
	include	stack_frame
"
	link	sp_sqr,<square_root_>|[square_root_]
	link	sp_cos,<sine_>|[cosine_radians_]
	link	sp_sin,<sine_>|[sine_radians_]
	link	sp_tan,<tangent_>|[tangent_radians_]
	link	sp_cot,<tangent_>|[cotangent_radians_]
	link	sp_atn,<arc_tangent_>|[arc_tangent_radians_]
	link	sp_exp,<exponential_>|[exponential_]
	link	sp_log,<logarithm_>|[log_base_e_]
	link	sp_pwr,<power_>|[single_power_single_]
	link	sp_clg,<logarithm_>|[log_base_10_]
	link	ep_sqr,<double_square_root_>|[double_square_root_]
	link	ep_cos,<double_sine_>|[double_cosine_radians_]
	link	ep_sin,<double_sine_>|[double_sine_radians_]
	link	ep_tan,<tangent_>|[double_tangent_radians_]
	link	ep_cot,<tangent_>|[double_cotangent_radians_]
	link	ep_atn,<double_arc_tangent_>|[double_arc_tangent_radians_]
	link	ep_exp,<double_exponential_>|[double_exponential_]
	link	ep_log,<double_logarithm_>|[double_log_base_e_]
	link	ep_pwr,<power_>|[double_power_double_]
	link	ep_clg,<double_logarithm_>|[double_log_base_10_]
"
"	definition of basic program header
"
	equ	bph.version,0
	equ	bph.numeric_storage,1
	equ	bph.string_storage,2
	equ	bph.numeric_data,3
	equ	bph.string_data,4
	equ	bph.incoming_args,5
	equ	bph.outgoing_args,6
	equ	bph.numeric_scalars,7
	equ	bph.string_scalars,8
	equ	bph.numeric_arrays,9
	equ	bph.string_arrays,10
	equ	bph.functions,11
	equ	bph.statement_map,12
	equ	bph.precision_ind,13
	equ	bph.definitions,13
"
"	definition of basic array dope
"
	equ	array_dope.data,0
	equ	array_dope.original_bounds,2
	equ	array_dope.current_bounds,4
"
"	definitiion of basic array symbols
"
	equ	array_symbol.name,0
	equ	array_symbol.location,0
	equ	array_symbol.offset,1
	equ	array_symbol.bounds,2
	equ	array_symbol_size,3
	bool	array_symbol_param,400000
"
"	definition of definition block
"
	equ	def_head.forward,0		0-17
	equ	def_head.backward,0		18-35
"
	equ	def.forward,0		0-17
	equ	def.backward,0		18-35
	equ	def.value,1		0-17
	equ	def.flags,1		18-32
	equ	def.class,1		33-35
	equ	def.symbol,2		0-17
	equ	def.segname,2		18-35
"
	bool	def_flag.new,400000		dl
	bool	def_flag.ignore,200000	dl
	bool	def_flag.entry,100000	dl
	bool	def_flag.retain,040000	dl
	bool	def_flag.descriptors,020000	dl
"
"	definition of on-unit body
"
	equ	on_name,0
	equ	on_body,2
	equ	on_size,4
	equ	on_next,5
"
	bool	blank,40
"
	equ	pdl_size,256
	equ	fn_size,256
	equ	fn_extend_size,64
"
	bool	n_scalar_type,414000
	bool	n_list_type,414100
	bool	n_table_type,414200
	bool	char_type,524000
	bool	vs_char_type,530000
"
	bool	erase_packed_bit,775777
	bool	ignore_handler,020000
	bool	use_handler,757777
"
	bool	dim_1,000100
	bool	dim_2,000200
"
	equ	descriptor.type,0
	equ	descriptor.lower_1,1
	equ	descriptor.upper_1,2
	equ	descriptor.multiplier_1,3
	equ	descriptor.lower_2,4
	equ	descriptor.upper_2,5
	equ	descriptor.multiplier_2,6
"
	bool	eax7,627000
"
"
"	macros for code which is different for single and double precision
"
	macro	transfer_vector
&1operator_table:
	zero	0			0
	tra	&1string_assign		1
	tra	string_concatenate		2
	tra	string_compare		3
	tra	len_fun			4
	tra	pos_fun			5
	tra	chr_fun			6
	tra	clk_fun			7
	tra	dat_fun			8
	tra	usr_fun			9
	tra	str_fun			10
	tra	seg_fun			11
	tra	sst_fun			12, also used by mid$
	tra	&1max_fun			13
	tra	&1min_fun			14
	tra	change_from_string		15
	tra	change_to_string		16
	tra	argcnt			17
	tra	argval			18
	zero	0
	tra	stop_op			20
	tra	on_op			21
	tra	gosub_op			22
	tra	on_gosub_op		23
	tra	sub_call_op		24
	tra	std_sub_call_op		25
	tra	return_op			26
	tra	sub_exit_op		27
	tra	&1fun_call_op		28
	tra	&1global_fun_call_op	29
	tra	&1fun_return_op		30
	tra	&1list_sub_op		31
	tra	&1table_sub_op		32
	tra	&1inv_table_sub_op		33
	tra	error_in_statement		34
	tra	missing_line		35
	tra	unclosed_for		36
	zero	0			37
	tra	undefined_function		38
	tra	subend_op			39
	tra	use_tty			40
	tra	setup_fcb			41
	tra	scratch			42
	tra	margin			43
	tra	reset_data		44
	tra	numeric_write		45
	tra	string_write		46
	tra	&1numeric_read		47
	tra	string_read		48
	tra	numeric_print		49
	tra	string_print		50
	tra	print_new_line		51
	tra	tab_for_comma		52
	tra	tab_fun			53
	tra	spc_fun			54
	tra	check_eof			55
	tra	&1numeric_input		56
	tra	string_input		57
	tra	linput			58
	tra	end_input			59
	tra	lof_fun			60
	tra	loc_fun			61
	tra	mar_fun			62
	tra	&1numeric_data_read		63
	tra	string_data_read		64
	tra	per_fun			65
	tra	typ_fun			66
	tra	use_fcb			67
	tra	print_using_start		68
	tra	print_using_end		69
	tra	&1print_using_numeric	70
	tra	print_using_string		71
	tra	hps_fun			72
	tra	lin_fun			73
	tra	tst_fun			74
	tra	num_fun			75
	tra	file_fun			76
	tra	end_print			77
	tra	reset_ascii		78
	tra	reset_random		79
	tra	abs_fun			80
	tra	int_fun			81
	tra	&1mod_fun			82
	tra	randomize			83
	tra	rnd_fun			84
	tra	sgn_fun			85
	tra	tim_fun			86
	tra	&1val_fun			87
	tra	&1sqr_fun			88
	tra	&1cos_fun			89
	tra	&1sin_fun			90
	tra	&1cot_fun			91
	tra	&1tan_fun			92
	tra	&1atn_fun			93
	tra	&1exp_fun			94
	tra	&1log_fun			95
	tra	&1clg_fun			96
	tra	&1pwr_fun			97
	tra	&1pwri_fun		98
	zero	0
	tra	det_fun			100
	tra	&1con_fun			101
	tra	&1idn_fun			102
	tra	inv_fun			103
	tra	&1trn_fun			104
	tra	&1zer_fun			105
	tra	nul_fun			106
	tra	list_redim_op		107
	tra	table_redim_op		108
	tra	inv_table_redim_op		109
	tra	mat_numeric_input		110
	tra	mat_string_input		111
	tra	mat_numeric_print		112
	tra	mat_string_print		113
	tra	mat_numeric_read		114
	tra	mat_string_read		115
	tra	mat_numeric_write		116
	tra	mat_string_write		117
	tra	mat_linput_op		118
	tra	mat_numeric_data_read	119
	tra	mat_string_data_read	120
	tra	mat_print_using_numeric	121
	tra	mat_print_using_string	122
	tra	&1mat_assign_numeric	123
	tra	&1mat_add			124
	tra	&1mat_sub			125
	tra	&1mat_scalar_mult		126
	tra	&1dot_product		127
	tra	mat_assign_string		128
	tra	mat_mult_vm		129
	tra	mat_mult_mv		130
	tra	mat_mult_mm		131
	tra	setdigits_op		132
	tra	ep_sqr_fun		133
	tra	ep_cos_fun		134
	tra	ep_sin_fun		135
	tra	ep_cot_fun		136
	tra	ep_tan_fun		137
	tra	ep_atn_fun		138
	tra	ep_exp_fun		139
	tra	ep_log_fun		140
	tra	ep_clg_fun		141
	tra	ep_pwr_fun		142
	tra	ep_pwri_fun		143
	tra	ep_mod_fun		144
	tra	&1new_fun_call_op		145
	tra	&1new_global_fun_call_op	146
	tra	&1new_fun_return_op		147
	tra	new_string_data_read	148
	tra	left_fun			149
	tra	right_fun			150
	&end
	macro	string_assign
"	string assignment, entered with pointer to lhs in bb and pointer to rhs in ab
"
&1string_assign:
	&2	temp1		save EAQ
	ldq	10,dl
"
&1ss1:	tsx0	invoke_runtime
&1ss2:	&3	temp1
	tra	text_base_ptr,*7
	&end
	macro	max
"
"	operator to return max(arg1,arg2,...,argn)
"	entered with
"		ldq	n,dl
"		tsx7	ap|max_fun
"		fld	arg1
"		fld	arg2
"		...
"		fld	argn
"
&1max_fun:
	epp2	text_base_ptr,*7	get ptr to arg list
	eax0	0,ql		save number of args
	eax1	0,ql		save return point
	xec	pr2|-1,0		get last arg
&1max1:	sbx0	1,du		count down
	tze	pr2|0,1		return with result in eaq
	&2	temp1
	xec	pr2|-1,0		get next arg
	&3	temp1
	tpl	2,ic
	&4	temp1
	tra	&1max1
	&end
	macro	min
"
"	operator to return min(arg1,arg,...,argn)
"	entered with same calling sequence as max
"
&1min_fun:
	epp2	text_base_ptr,*7
	eax0	0,ql
	eax1	0,ql
	xec	pr2|-1,0
&1min1:	sbx0	1,du
	tze	pr2|0,1
	&2	temp1
	xec	pr2|-1,0
	&3	temp1
	tmi	2,ic
	&4	temp1
	tra	&1min1
"
	&end
"
	macro	fun_call_op
"
"	operator to call a user defined function, entered with
"		epplb	entry
"		tsx7	fun_call_op
"		vfd	36/fun_call_word
"		fld	arg1		numeric
"		eppab	arg2		string
"	entry point is
"	entry:	vfd	36/fun_call_word
"		vfd	36/fun_local_word
"		[first executable instruction]
"
&1fun_call_op:
	stx4	fn_temp1		use current display as next fn display
	sprplp	fn_temp2		use current value as next value of program header pt
"
"	at this point:
"		lp -> current program header
"		fn_temp1 = new function display value
"		fn_temp2 = packed ptr to new program header
"
&1fun_call:
	sprplp	temp1
	ldq	temp1
	stq	pdl,id		put current program header pt on pdl
	ttn	pdl_full
	eppbp	text_base_ptr,*7	get ptr to fun call word
	ldq	lb|0		get expected call word
	cmpq	bp|0		check with actual
	tnz	fn_call_error	error if not the same
	lda	0,dl		get number of args
	lls	5
	sta	temp1		save
	eppap	bp|1,al		get ptr to return loc
	sprpap	temp2
	ldq	temp2
	stq	pdl,id		put on pdl
	ttn	pdl_full
	stx4	pdl,id		put fn display on pdl
	ttn	pdl_full
	stx6	pdl,id		put current frame offset on pdl
	ttn	pdl_full
	stz	pdl,id		put in fence of 0
	ttn	pdl_full
	ldq	lb|1		get local word
	lda	0,dl		get number of locals
	lls	5
	sta	temp2		save
	ada	temp1		get number args + locals
	ada	2,dl		add 1 for return arg + 1 to make even
	ana	=o777776,dl	make multiple of 2
	lls	&4
	ldx7	next_frame	get next frame offset
	ada	next_frame	update next frame offset
	sta	next_frame
	cmpa	last_frame	have we exceeded available space
	tmoz	&1fc1
	eppap	sb|stack_header.stack_end_ptr,*	get ptr to end of stack
	eppap	ap|fn_extend_size	extend stack
	spriap	sb|stack_header.stack_end_ptr
	spriap	sp|stack_frame.next_sp
	eaa	fn_extend_size
	asa	last_frame
&1fc1:	eax1	&2		init arg copy loop
	eax2	1
	eppap	sp|0,7		get ptr to next frame
	stz	ap|0		init return value
	lxl0	temp1		get number of args
	tze	&1fc5		skip if zero
	ldq	lb|0		get call word
	lls	5		shift to position
&1fc2:	qls	1		check next arg
	stq	temp3
	tmi	&1fc4		minus means string arg
	xec	bp|0,2		load the arg value
	&3	ap|0,1		and save in frame
&1fc3:	adx1	&2,du		account for position
	adx2	1,du
	sbx0	1,du		count down
	tze	&1fc5		and skip if no more args
	ldq	temp3		do next arg
	tra	&1fc2
&1fc4:	xec	bp|0,2		string arg, get ptr
	epp3	ap|0,1		get ptr to target
	stz	3|0		clear string temp (important!)
	ldq	10,dl		get action code
	epplp	sp|stack_frame.lp_ptr,*
	call	<basic_runtime_>|[basic_runtime_](runtime_arglist)
	epplp	program_header,*
	tra	&1fc3		go do next arg
	ife	&1,sp_
sp_fc5:	lxl0	temp2		get number of locals
	ifend
	ife	&1,ep_
ep_fc5:	ldq	temp2		get number of locals
	qls	1		double for number of words
	eax0	0,ql
	ifend
	tze	&1fc7		skip if no locals
&1fc6:	stz	ap|0,1		zero local
	sbx0	1,du
	tze	&1fc7
	adx1	1,du
	tra	&1fc6
&1fc7:	eppap	&1operator_table	restore ptr to operators
	ldx4	fn_temp1		get new fn display
	eax6	0,7		get new fn offset
	lprplp	fn_temp2		get new program header pt
	sprilp	program_header
	spbplp	text_base_ptr	set text base ptr also
	eax7	lp|0		set program header offset
	stx7	program_header_offset
	tra	lb|2		and enter function
	&end
"
	macro	global_fun_call_op
"
"	operator to call global function
"		epplb	entry_info
"		tsx7	global_fun_call_op
"		vfd	36/fun_call_word
"		fld	arg1		numeric
"		eppab	arg2		string
"	entry info is
"		word 0	packed ptr to entry pt
"		word 1	packed ptr to stack frame of parent
"
&1global_fun_call_op:
	eaa	sp|0		get rel(parent stack) - rel(our stack)
	neg	0
	sta	fn_temp1
	lxl0	lb|1
	asx0	fn_temp1		save as new display value
	lprpbp	lb|1		get ptr to parent stack frame of fun
	eppbp	bp|program_header_equ,*	load ptr to program header
	sprpbp	fn_temp2		save packed ptr to program header
	lprplb	lb|0		get ptr to entry pt
	tra	&1fun_call		join common code
	&end
"
	macro	fun_return_op
"
"	operator to return from function, entered with
"		epplb	entry
"		tsx7	fun_return_op
"
&1fun_return_op:
	ldq	pdl,di		pop pdl
	ttn	fn_return_error
	tnz	&1fun_return_op	skip gosub return
	eppap	sp|0,6		get ptr to this frame
	eax1	&2		init arg, local loop
	ldq	lb|0		get call word
	lda	0,dl		extract number of args
	lls	5
	eax0	0,al
	tze	&1fr3		skip if no args
&1fr1:	qls	1		check next arg
	tpl	&1fr2		plus means numeric
	stq	temp2
	eppab	ap|0,1		get ptr to string word
	ldq	28,dl
	epplp	sp|stack_frame.lp_ptr,*
	call	<basic_runtime_>|[basic_runtime_](runtime_arglist)
	epplp	program_header,*
	ldq	temp2
&1fr2:	adx1	&2,du
	sbx0	1,du		check next arg
	tnz	&1fr1
&1fr3:	ldq	lb|1		get local word
	lda	0,dl
	lls	5		get number of locals
	eax0	0,al
	tze	&1fr6		skip if none
&1fr4:	qls	1
	tpl	&1fr5
	stq	temp2
	eppab	ap|0,1		get ptr to string word
	ldq	28,dl
	epplp	sp|stack_frame.lp_ptr,*
	call	<basic_runtime_>|[basic_runtime_](runtime_arglist)
	epplp	program_header,*
	ldq	temp2
&1fr5:	sbx0	1,du
	tze	&1fr6
	adx1	&2,du
	tra	&1fr4
&1fr6:	stx6	next_frame	reset end of stack
	ldx6	pdl,di		pop function stack
	ldx4	pdl,di		restore display from pdl
	ldq	lb|0		check mode of return value
	qls	5
	tmi	&1fr7		minus is string
	&3	ap|0		load numeric value
	tra	&1fr8		and return
&1fr7:	eppab	string_value	set string ptr
	szn	ab|0		is string_value word zero
	tze	&1fr7a		yes, don't have to deallocate it
	ldq	28,dl		no, deallocate it
	epplp	sp|stack_frame.lp_ptr,*
	call	<basic_runtime_>|[basic_runtime_](runtime_arglist)
&1fr7a:	ldq	ap|0		get function value
	stq	ab|0		set string value
	fld	=0.0,du		get 0 numeric value
&1fr8:	eppap	&1operator_table	restore ptr to operators
	lprpbp	pdl,di		get return pt from pdl
	lprplp	pdl,di		get program header pt from pdl
	sprilp	program_header	restore stack frame
	spbplp	text_base_ptr
	eax7	lp|0		set program header offset
	stx7	program_header_offset
	fcmp	=0.0,du		set indicators
	tra	bp|0		return to caller
	&end
"
	macro	new_fun_call_op
"
"	operator to call a user defined function, entered with
"		epp3	entry
"		tsx7	fun_call_op
"		vfd	36/fun_call_word
"		fld	arg1		numeric
"		eppab	arg2		string
"	entry point is
"	entry:	vfd	36/fun_call_word
"		vfd	36/fun_local_word
"		[first executable instruction]
"
&1new_fun_call_op:
	stx4	fn_temp1		use current display as next fn display
	sprplp	fn_temp2		use current value as next value of program header pt
"
"	at this point:
"		lp -> current program header
"		fn_temp1 = new function display value
"		fn_temp2 = packed ptr to new program header
"
&1new_fun_call:
	sprplp	temp1
	ldq	temp1
	stq	pdl,id		put current program header pt on pdl
	ttn	pdl_full
	eppbp	text_base_ptr,*7	get ptr to fun call word
	ldq	pr3|0		get expected call word
	cmpq	bp|0		check with actual
	tnz	fn_call_error	error if not the same
	lda	0,dl		get number of args
	lls	5
	sta	temp1		save
	eppap	bp|1,al		get ptr to return loc
	sprpap	temp2
	ldq	temp2
	stq	pdl,id		put on pdl
	ttn	pdl_full
	stx4	pdl,id		put fn display on pdl
	ttn	pdl_full
	stx6	pdl,id		put current frame offset on pdl
	ttn	pdl_full
	stz	pdl,id		put in fence of 0
	ttn	pdl_full
	ldq	pr3|1		get local word
	lda	0,dl		get number of locals
	lls	5
	sta	temp2		save
	ada	temp1		get number args + locals
	ada	2,dl		add 1 for return arg + 1 to make even
	ana	=o777776,dl	make multiple of 2
	lls	&4
	ldx7	next_frame	get next frame offset
	ada	next_frame	update next frame offset
	sta	next_frame
	cmpa	last_frame	have we exceeded available space
	tmoz	&1nfc1
	eppap	sb|stack_header.stack_end_ptr,*	get ptr to end of stack
	eppap	ap|fn_extend_size	extend stack
	spriap	sb|stack_header.stack_end_ptr
	spriap	sp|stack_frame.next_sp
	eaa	fn_extend_size
	asa	last_frame
&1nfc1:	spri3	temp3		save, may need pr3 for string handling
	eax1	&2		init arg copy loop
	eax2	1
	eppap	sp|0,7		get ptr to next frame
	stz	ap|0		init return value
	lxl0	temp1		get number of args
	tze	&1nfc5		skip if zero
	ldq	pr3|0		get call word
	lls	5		shift to position
&1nfc2:	qls	1		check next arg
	stq	temp2+1
	tmi	&1nfc4		minus means string arg
	xec	bp|0,2		load the arg value
	&3	ap|0,1		and save in frame
&1nfc3:	adx1	&2,du		account for position
	adx2	1,du
	sbx0	1,du		count down
	tze	&1nfc5		and skip if no more args
	ldq	temp2+1		do next arg
	tra	&1nfc2
&1nfc4:	xec	bp|0,2		string arg, get ptr
	epp3	ap|0,1		get ptr to target
	stz	pr3|0		clear string temp (important!)
	ldq	10,dl		get action code
	epplp	sp|stack_frame.lp_ptr,*
	call	<basic_runtime_>|[basic_runtime_](runtime_arglist)
	epplp	program_header,*
	tra	&1nfc3		go do next arg
	ife	&1,sp_
sp_nfc5:	lxl0	temp2		get number of locals
	ifend
	ife	&1,ep_
ep_nfc5:	ldq	temp2		get number of locals
	qls	1		double for number of words
	eax0	0,ql
	ifend
	tze	&1nfc7		skip if no locals
&1nfc6:	stz	ap|0,1		zero local
	sbx0	1,du
	tze	&1nfc7
	adx1	1,du
	tra	&1nfc6
&1nfc7:	eppap	&1operator_table	restore ptr to operators
	ldx4	fn_temp1		get new fn display
	eax6	0,7		get new fn offset
	lprplp	fn_temp2		get new program header pt
	sprilp	program_header
	spbplp	text_base_ptr	set text base ptr also
	eax7	lp|0		set program header offset
	stx7	program_header_offset
	epp3	temp3,*		restore ptr to entry
	tra	pr3|2		and enter function
	&end
"
	macro	new_global_fun_call_op
"
"	operator to call global function
"		epp3	entry_info
"		tsx7	global_fun_call_op
"		vfd	36/fun_call_word
"		fld	arg1		numeric
"		eppab	arg2		string
"	entry info is
"		word 0	packed ptr to entry pt
"		word 1	packed ptr to stack frame of parent
"
&1new_global_fun_call_op:
	eaa	sp|0		get rel(parent stack) - rel(our stack)
	neg	0
	sta	fn_temp1
	lxl0	pr3|1
	asx0	fn_temp1		save as new display value
	lprpbp	pr3|1		get ptr to parent stack frame of fun
	eppbp	bp|program_header_equ,*	load ptr to program header
	sprpbp	fn_temp2		save packed ptr to program header
	lprp3	pr3|0		get ptr to entry pt
	tra	&1new_fun_call		join common code
	&end
"
	macro	new_fun_return_op
"
"	operator to return from function, entered with
"		epp3	entry
"		tsx7	fun_return_op
"
&1new_fun_return_op:
	ldq	pdl,di		pop pdl
	ttn	fn_return_error
	tnz	&1new_fun_return_op	skip gosub return
	eppap	sp|0,6		get ptr to this frame
	eax1	&2		init arg, local loop
	ldq	pr3|0		get call word
	lda	0,dl		extract number of args
	lls	5
	eax0	0,al
	tze	&1nfr3		skip if no args
&1nfr1:	qls	1		check next arg
	tpl	&1nfr2		plus means numeric
	stq	temp2
	eppab	ap|0,1		get ptr to string word
	ldq	28,dl
	epplp	sp|stack_frame.lp_ptr,*
	call	<basic_runtime_>|[basic_runtime_](runtime_arglist)
	epplp	program_header,*
	ldq	temp2
&1nfr2:	adx1	&2,du
	sbx0	1,du		check next arg
	tnz	&1nfr1
&1nfr3:	ldq	pr3|1		get local word
	lda	0,dl
	lls	5		get number of locals
	eax0	0,al
	tze	&1nfr6		skip if none
&1nfr4:	qls	1
	tpl	&1nfr5
	stq	temp2
	eppab	ap|0,1		get ptr to string word
	ldq	28,dl
	epplp	sp|stack_frame.lp_ptr,*
	call	<basic_runtime_>|[basic_runtime_](runtime_arglist)
	epplp	program_header,*
	ldq	temp2
&1nfr5:	sbx0	1,du
	tze	&1nfr6
	adx1	&2,du
	tra	&1nfr4
&1nfr6:	stx6	next_frame	reset end of stack
	ldx6	pdl,di		pop function stack
	ldx4	pdl,di		restore display from pdl
	ldq	pr3|0		check mode of return value
	qls	5
	tmi	&1nfr7		minus is string
	&3	ap|0		load numeric value
	tra	&1nfr8		and return
&1nfr7:	eppab	string_value	set string ptr
	szn	ab|0		is string_value word zero
	tze	&1nfr7a		yes, don't have to deallocate it
	ldq	28,dl		no, deallocate it
	epplp	sp|stack_frame.lp_ptr,*
	call	<basic_runtime_>|[basic_runtime_](runtime_arglist)
&1nfr7a:	ldq	ap|0		get function value
	stq	ab|0		set string value
	fld	=0.0,du		get 0 numeric value
&1nfr8:	eppap	&1operator_table	restore ptr to operators
	lprpbp	pdl,di		get return pt from pdl
	lprplp	pdl,di		get program header pt from pdl
	sprilp	program_header	restore stack frame
	spbplp	text_base_ptr
	eax7	lp|0		set program header offset
	stx7	program_header_offset
	fcmp	=0.0,du		set indicators
	tra	bp|0		return to caller
	&end
"
	macro	list_sub_op
"
"	validate list subscript, for x(i)
"		fld	i
"		eppbp	x_dope
"		tsx7	list_sub_op
"
&1list_sub_op:
	ufa	=71b25,du		convert to integer in ql
	cmpq	bp|array_dope.current_bounds
	trc	subscript_error
	ife	&1,ep_
	qls 	1
	ifend
	eppbp	bp|array_dope.data,*ql	get ptr to element
	tra	text_base_ptr,*7	and return
	&end
"
	macro	table_sub_op
"
"	validate table subscript, for x(i,j)
"		fld	i
"		eppbp	x_dope
"		tsx7	table_sub_op
"		fld	j
"
&1table_sub_op:
	ufa	=71b25,du		convert to integer in qu
	cmpq	bp|array_dope.current_bounds
	trc	subscript_error
	mpy	bp|array_dope.current_bounds+1
	stq	temp1
	xec	text_base_ptr,*7
	ufa	=71b25,du
	cmpq	bp|array_dope.current_bounds+1
	trc	subscript_error
	adlq	temp1
	ife	&1,ep_
	qls	1
	ifend
	eppbp	bp|array_dope.data,*ql
	adx7	1,du
	tra	text_base_ptr,*7
&end
"
	macro	inv_table_sub_op
"
"	validate table subscript, for x(i,j)
"		fld	j
"		eppbp	x_dope
"		tsx7	inv_table_sub_op
"		fld	i
"
&1inv_table_sub_op:
	ufa	=71b25,du
	cmpq	bp|array_dope.current_bounds+1
	trc	subscript_error
	stq	temp1
	xec	text_base_ptr,*7
	ufa	=71b25,du
	cmpq	bp|array_dope.current_bounds
	trc	subscript_error
	mpy	bp|array_dope.current_bounds+1
	adlq	temp1
	ife	&1,ep_
	qls	1
	ifend
	eppbp	bp|array_dope.data,*ql
	adx7	1,du
	tra	text_base_ptr,*7
	&end
"
	macro	numeric_read
"
"	operator to read numeric value, return value in EAQ
"
&1numeric_read:
	ldq	35,dl		reading random file
&1nr1:	tsx0	invoke_runtime
	&2	temp1
	tra	text_base_ptr,*7
	&end
"
	macro	numeric_data_read
"
&1numeric_data_read:
	lxl0	numeric_data_pos
	cmpx0	numeric_data_pos
	trc	out_of_data
	&2	text_base_ptr,*0
	adx0	&3,du
	sxl0	numeric_data_pos
	tra	text_base_ptr,*7
	&end
"
	macro	numeric_input
"
"	input numeric value, result left in EAQ
"
&1numeric_input:
	ldq	14,dl
	tsx0	invoke_runtime
	&2	temp1
	tra	text_base_ptr,*7
	&end
"
	macro	print_using_numeric
"
&1print_using_numeric:
	&2	temp1
	ldq	57,dl
	tra	call_runtime
	&end
"
	macro	mod_fun
"
"	mod
"		fld	a
"		tsx7	mod_fun
"		fld	b
"
&1mod_fun:
	&2	temp1		save a
	xec	text_base_ptr,*7	get b
	tze	&1mf1		return a if b = 0
	&2	temp2
	&3	temp1		a/b
	ufa	=71b25,du
	fad	=71b25,du		int(a/b)
	&4	temp2		int(a/b)*b
	fneg	0		-int(a/b)*b
&1mf1:	adx7	1,du
	&5	temp1		a-int(a/b)*b
	tra	text_base_ptr,*7
	&end
"
	macro	val_fun
"
"	val(a$)
"
&1val_fun:
	ldq	27,dl
	tra	&1nr1
	&end
"
	macro	math_functions
"
"	math functions
"		fld	x
"		tsx7	math_function
"
&1sqr_fun:
	eax0	&1sqr
"
&1fun2:	lprp2	math_block	get ptr to storage block for math routines
	epp3	text_base_ptr,*7	store return location
	spri3	temp3		in case we get error
	epplp	sp|stack_frame.lp_ptr,*
	stx4	sp|stack_frame.regs+2	save in case used by function
	sxl7	sp|stack_frame.regs+3	save for error handler
	fad	=0.0,du			set indicators
	tsp3	lp|0,0*
	ldx4	sp|stack_frame.regs+2	restore x4 for user function
	lxl7	sp|stack_frame.regs+3	in case of error
	epp0	&1operator_table	in case there was a math error
	epplp	program_header,*
	fad	=0.0,du			set indicators
	tra	text_base_ptr,*7
"
&1cos_fun:
	eax0	&1cos
	tra	&1fun2
"
&1sin_fun:
	eax0	&1sin
	tra	&1fun2
"
&1cot_fun:
	eax0	&1cot
	tra	&1fun2
"
&1tan_fun:
	eax0	&1tan
	tra	&1fun2
"
&1atn_fun:
	eax0	&1atn
	tra	&1fun2
"
&1exp_fun:
	eax0	&1exp
	tra	&1fun2
"
&1log_fun:
	eax0	&1log
	tra	&1fun2
"
&1clg_fun:
	eax0	&1clg
	tra	&1fun2
"
	&end
"
	macro	power_functions
"
"	operator to evaluate a ** b, entered with
"		fld	a
"		tsx0	pwr_fun
"		fld	b
"
&1pwr_fun:
	&2	temp1		save a
	xec	text_base_ptr,*7	get b
	&2	temp2		and save it
&1fun3:	eax0	&1pwr
"
	&3	temp1
	epp1	temp2
	adx7	1,du
	tra	&1fun2
"
"	operator to evaluate a ** b, entered with
"		fld	b
"		tsx0	pwri_fun
"		fld	a
"
&1pwri_fun:
	&2	temp2		save b
	xec	text_base_ptr,*7	get a
	&2	temp1		and save it
	tra	&1fun3		join pwr code
"
	&end
"
	macro	zer_con_funs
"
"	operators to do
"		mat A = zer
"		mat A = con
"	entered with pr2 pointing at dope for A.
"
&1zer_fun:
	&2	&3		get value
	tra	&1con_fun+1
"
&1con_fun:
	&2	&4		get value
"
	lxl1	2|array_dope.current_bounds
	sbx1	1,du		get row bound
	tmoz	array_error
	lxl2	2|array_dope.current_bounds+1
	tmi	&1con_list
	sbx2	1,du		get col bound
	tmoz	array_error
	epp2	2|array_dope.data,*
	ife	&1,sp_
	eax3	2,2
	ifend
	ife	&1,ep_
	eaq	2,2
	qls	1
	eax3	0,qu
	xec	0,0
	ifend
	stx2	temp3		save col bound
&1ct1:	ldx2	temp3		col = col bound
&1ct2:	&5	2|0,3		set A(row,col)
	adx3	&6,du
	sbx2	1,du		col = col - 1
	tpnz	&1ct2
	adx3	&6,du		skip over col 0
	sbx1	1,du		row = row - 1
	tpnz	&1ct1
	tra	text_base_ptr,*7
"
&1con_list:
	epp2	2|array_dope.data,*
	ife	&1,ep_
	eaq	0,1
	qls	1
	eax1	0,qu
	xec	0,0
	ifend
	&5	2|0,1		set all but 0 element
	sbx1	&6,du
	tpnz	-2,ic
	tra	text_base_ptr,*7
"
	ife	&1,ep_
load0:	fld	=0.0,du
load1:	fld	=1.0,du
	ifend
"
	&end
"
	macro	idn_fun
"
"	operator to do
"		mat A = idn
"	entered with pr2 -> dope for A
"
&1idn_fun:
	ldq	2|array_dope.current_bounds
	cmpq	2|array_dope.current_bounds+1
	tnz	array_error	matrix must be square
	eax1	-1,ql
	tmoz	array_error
	eax2	0,1
	epp2	2|array_dope.data,*
	ife	&1,sp_
	eax3	2,2
	ifend
	ife	&1,ep_
	eaq	2,2
	qls	1
	eax3	0,qu
	ifend
	stx2	temp3
&1id1:	ldx2	temp3
	stx1	temp2
&1id2:	&2	=0.0d0		assume 0 element
	cmpx2	temp2		is row = col
	tnz	2,ic
	&2	=1.0d0		yes, get 1
	&3	2|0,3
	adx3	&4,du
	sbx2	1,du
	tpnz	&1id2
	adx3	&4,du
	sbx1	1,du
	tpnz	&1id1
	tra	text_base_ptr,*7
"
	&end
"
	macro	mat_assign_numeric
"
"	operator to do mat A = B
"	entered with pr2 -> dope for A and pr1 -> dope for B
"
&1mat_assign_numeric:
	eax0	&1nop
	ldaq	1|array_dope.current_bounds
	cmpq	0,dl
	tmi	&1list_assign
&1table_assign:
	mpy	1|array_dope.current_bounds
	stq	temp3
	ldq	2|array_dope.original_bounds
	mpy	2|array_dope.original_bounds+1
	cmpq	temp3
	tmi	redim_error
	ldaq	1|array_dope.current_bounds
	eax1	-1,al
	tmoz	array_error
	eax2	-1,ql
	tmoz	array_error
	staq	2|array_dope.current_bounds
	epp2	2|array_dope.data,*
	epp1	1|array_dope.data,*
	ife	&1,sp_
	eax3	2,2
	ifend
	ife	&1,ep_
	eaq	2,2
	qls	1
	eax3	0,qu
	ifend
	stx2	temp3
&1ta1:	ldx2	temp3
&1ta2:	&2	1|0,3
	xec	0,0
	&3	2|0,3
	adx3	&4,du
	sbx2	1,du
	tpnz	&1ta2
	adx3	&4,du
	sbx1	1,du
	tpnz	&1ta1
	tra	text_base_ptr,*7
"
&1list_assign:
	cmpa	2|array_dope.original_bounds
	tpnz	redim_error
	sta	2|array_dope.current_bounds
	ife	&1,ep_
	als	1
	ifend
	eax3	-&4,al
	tmoz	array_error
	epp1	1|array_dope.data,*
	epp2	2|array_dope.data,*
	&2	1|0,3
	xec	0,0
	&3	2|0,3
	sbx3	&4,du
	tpnz	-4,ic
	tra	text_base_ptr,*7
"
	&end
"
"
	macro	mat_add_sub
"
"	operator to do
"		mat A = B + C
"		mat A = B - C
"	entered with pr2 -> dope for A, pr1 -> dope for B,
"	pr3 -> dope for C
"
&1mat_add:
	eax0	&1fad
	tra	&1mat_sub+1
"
&1mat_sub:
	eax0	&1fsb
"
	ldaq	1|array_dope.current_bounds
	cmpq	0,dl
	tmi	&1list_sub
	cmpaq	3|array_dope.current_bounds
	tnz	array_error
	epp3	3|array_dope.data,*
	tra	&1table_assign
"
&1list_sub:
	cmpa	3|array_dope.current_bounds
	tnz	array_error
	epp3	3|array_dope.data,*
	tra	&1list_assign
"
	&end
"
	macro	mat_scalar_mult
"
"	operator to do
"		mat A = (expression)*B
"	entered with expression in EAQ, pr2 -> dope for A and
"	pr1 -> dope for B
"
&1mat_scalar_mult:
	&2	temp1
	eax0	&1fmp
	tra	&1mat_assign_numeric+1
"
&1nop:	nop	0,du
&1fad:	fad	3|0,3
&1fsb:	fsb	3|0,3
&1fmp:	fmp	temp1
"
	&end
"
	macro	dot_product
"
"	operator to form
"		mat dot_product = A * B
"	entered with pr1 -> dope for A and pr3 -> dope for B
"	returns with value in EAQ
"
&1dot_product:
	lda	1|array_dope.current_bounds
	cmpa	3|array_dope.current_bounds
	tnz	array_error
	ada	-&2,dl
	eax1	0,al		store bounds for indexing
	tmoz	array_error
	epp1	1|array_dope.data,*
	epp3	3|array_dope.data,*
	fld	=0.0,du
&1dot:	dfst	temp1
	&3	1|0,1
	&4	3|0,1
	dfad	temp1
	sbx1	&2,du
	tpnz	&1dot
	&5	=0.0,du		set indicators
	tra	text_base_ptr,*7
"
	&end
"
	macro	trn_fun
"
"	operator to do
"		mat A = trn(B)
"
&1trn_fun:
	ldq	1|array_dope.current_bounds+1
	tmi	&1mat_assign_numeric
	mpy	1|array_dope.current_bounds
	stq	temp3
	ldq	2|array_dope.original_bounds
	mpy	2|array_dope.original_bounds+1
	cmpq	temp3
	tmi	redim_error
	lda	1|array_dope.current_bounds+1
	ldq	1|array_dope.current_bounds
	staq	2|array_dope.current_bounds
	ldq	2,dl
	tra	call_matrix
"
	&end
"
"
"	Run-time transfer vector for Multics BASIC
"	Following locations cannot be changed since they are directly referenced
"	from compiled programs
"
	transfer_vector	sp_
	transfer_vector	ep_
"
"	End of section which cannot be modified
"
"	string operations and functions
"
	string_assign	sp_,fst,fld
"
"	concatenate, entered with pointer to left side in ab and pointer to right side in bb
"
string_concatenate:
	ldq	12,dl
	tra	call_runtime
"
"	string comparison, entered with pointer to lhs in ab and pointer to rhs in bb
"
string_compare:
	lda	ab|0		is lhs constant?
	cana	=o777777,du
	tze	sc1		yes, skip
	epbpab	string_segment,*	get ptr to beg of string segment
	eppab	ab|0,au		variable, get ptr to varying string
	eppab	ab|1
	lda	ab|0		and pickup variable length
sc1:	ldq	bb|0		is rhs constant?
	canq	=o777777,du
	tze	sc2		yes, skip
	epbpbb	string_segment,*	get ptr to beg of string segment
	eppbb	bb|0,qu		variable, get ptr to varying string
	eppbb	bb|1
	ldq	bb|0		and pickup variable length
sc2:	cmpc	(pr,rl),(pr,rl),fill(blank)
	desc9a	bb|1,ql
	desc9a	ab|1,al
	tze	text_base_ptr,*7	return if =
	trc	3,ic		convert carry indicator into negative indicator
	ldq	1,dl		turn off negative indicator
	tra	text_base_ptr,*7
	lcq	1,dl		set negative indicator
	tra	text_base_ptr,*7
"
"	return length of string pointed at by ab
"
len_fun:
	lda	ab|0		get string word
	tze	len1		zero means null string
	cana	=o777777,du	is this constant
	tze	len1		yes, length already in a
	epbpab	string_segment,*	no, get ptr to string block
	eppab	ab|0,au
	lda	ab|1		and pick up length from that
len1:	lde	=35b25,du		float length
	ldq	0,dl
	fad	=0.0,du
	tra	text_base_ptr,*7	and return
"
"	pos(a$,b$,n), a$ in ab, b$ in bb, n in EAQ
"
pos_fun:	fst	temp1
	ldq	17,dl
pos1:	tsx0	invoke_runtime
pos2:	fld	temp1
	tra	text_base_ptr,*7
"
"	chr$(x)
"
chr_fun:	fst	temp1
	ldq	18,dl
	tra	call_runtime
"
"	clk$
"
clk_fun:	ldq	19,dl
	tra	call_runtime
"
"	dat$
"
dat_fun:	ldq	20,dl
	tra	call_runtime
"
"	usr$
"
usr_fun:	ldq	21,dl
	tra	call_runtime
"
"	str$(x)
"
str_fun:	dfst	temp1
	ldq	22,dl
	tra	call_runtime
"
"	left$(a$,i), a$ in ab, i in EAQ
"
left_fun:	fst	temp1
	ldq	134,dl
	tra 	call_runtime
"
"	right$(a$,i), a$ in ab, i in EAQ
"
right_fun:
	fst	temp1
	ldq	135,dl
	tra	call_runtime
"
"	seg$(a$,i,j), a$ in ab, i in EAQ, j at text_base_ptr,7*
"
seg_fun:	fst	temp1
	xec	text_base_ptr,*7
	fst	temp2
	ldq	23,dl
	adx7	1,du
	tra	call_runtime
"
"	sst(a$,i,n) and mid$(a$,i,n)
"
sst_fun:
mid_fun:	fst	temp1
	xec	text_base_ptr,*7
	fst	temp2
	ldq	24,dl
	adx7	1,du
	tra	call_runtime
"
	max	sp_,fst,fcmp,fld
"
	min	sp_,fst,fcmp,fld
"
"	operators to change from string to numeric array, and vice versa
"	entered with pr1 -> string, pr2 -> array, element size in eaq
"
change_from_string:
	fst	temp1
	ldq	43,dl
	tra	call_runtime
"
change_to_string:
	fst	temp1
	ldq	44,dl
	tra	call_runtime
"
"	function to return number of Multics arguments of current subprogram
"
argcnt:	lda	sp|stack_frame.arg_ptr,*	get 2*n_args in au
	ars	18+1
	tra	len1		go float result and return
"
"	arg$(x) returns string for argument number x or "" if specified
"	argument doesn't exist
"
argval:	ufa	=35b25,du		fix arg number
	tmoz	return_null_string	return null if invalid number
	als	1
	eax1	0,al		save 2*arg number
	epp2	sp|stack_frame.arg_ptr,*	get arglist ptr
	cmpx1	2|0		check arg desired
	tpnz	return_null_string	return null if arg number too bit
	lda	2|1		are there any descriptors
	tze	return_null_string	nope
	epp1	2|0,au		get ptr to descriptors
	lxl0	2|0		is there extra ptr in middle of arg list
	canx0	8,du
	tze	2,ic
	epp1	1|2		yes, skip over extra ptr
	lda	1|0,1*		get descriptor
	ana	=o7777,dl		extract size
	cmpa	=4096,dl		use max of 4095 chars
	tmi	2,ic
	lda	=4095,dl
	epp2	2|0,1*		get ptr to string
	ldq	65,dl
	tra	call_runtime	go setup string value
"
return_null_string:
	epp1	=0
	tra	text_base_ptr,*7
"
"	control operations
"
subend_op:
stop_op:
	ldq	1,dl		get stop code
	tsx0	invoke_runtime
"
	even
	sprisp	sb|stack_header.stack_end_ptr
	eppsp	sp|stack_frame.prev_sp,*
	epbpsb	sp|0
	eppap	sp|stack_frame.operator_ptr,*
	rtcd	sp|stack_frame.return_ptr
"
"	operator to do on statement, entered with
"		fld	number
"		tsx7	on_op
"		dec	number_of_transfers+1
"		tra	l1-*,ic
"		tra	l2-*,ic
"		...
"
on_op:
	ufa	=35b25,du		fix number in al
	tmoz	on_error
	eppbp	text_base_ptr,*7
	cmpa	bp|0		make sure transfer is valid
	tmoz	bp|0,al
"
on_error:	ldq	101,dl		go print error and abort run
	tra	error1
"
"	operator to do gosub statement
"		eppbp	location
"		tsx7	gosub_op
"
gosub_op:
	stx7	pdl,id		save return address
	ttn	pdl_full
	tra	bp|0		and then transfer to routine
"
pdl_full:
	ldq	130,dl
	tra	error1
"
"	operator to do on with gosub
"		fld	number
"		tsx7	on_gosub_op
"		dec	number_of_transfers+1
"		tra	l1-*,ic
"		tra	l2-*,ic
"		...
"
on_gosub_op:
	ufa	=35b25,du		fix number in al
	tmoz	on_error
	eppab	text_base_ptr,*7
	cmpa	ab|0
	tpnz	on_error		make sure number in range
	eppbp	ab|0,al		get ptr to transfer
	adwpbp	bp|0		remove ic modification
	lda	ab|0		get number of transfers
	eax7	ab|0,al		compute return point
	tra	gosub_op		and join gosub code
"
"	subprogram call operator
"		epp1	subprogram_name
"		tsx7	call_op
"		vfd	18/2*n_args,54/0
"		itb	arg1
"		itb	arg2
"		...
"		itb	argn
"	where byte1 of word1 of itb gives arg type
"
sub_call_op:
std_sub_call_op:
	lda	1|0		is string constant
	cana	=o777777,du
	tze	sco1		yes, skip
	epbp1	string_segment,*	get ptr to beg of string segment
	epp1	1|0,au		get ptr to string value
	epp1	1|1
	lda	1|0		get string length
sco1:	spri1	print_using_ptr	save ptr to name of entry
"
"	pr1 points at name of entry to be called, length of name in al
"	search definitions chain of this segment first
"
	lprp2	definitions	get ptr to definitions
	ldx2	2|def_head.forward	get offset of first def
check_def:
	ldq	2|def.flags,2
	canq	def_flag.entry,dl	skip if not entry def
	tze	next_def
	ldx3	2|def.symbol,2	get ptr to acc for symbol
	epp3	2|0,3
	ldq	3|0		extract acc size
	qrs	27
	cmpc	(pr,rl),(pr,rl),fill(blank)	check names
	desc9a	1|1,al
	desc9a	3|0(1),ql
	tnz	next_def
"
"	found the definition, make sure class = 0
"
	ldq	2|def.class,2
	anq	7,dl
	tnz	next_def
	ldq	2|def.value,2	get ptr to entry
	epp2	text_base_ptr,*qu
	tra	have_entry
"
"	go on to next definition
"
next_def:	ldx2	2|def.forward,2
	szn	2|0,2		is this trailer of 0
	tnz	check_def		no, keep looking
"
"	call runtime to find entry
"
	epplp	sp|stack_frame.lp_ptr,*
	call	<basic_find_proc_>|[basic_find_proc_](runtime_arglist)
	epplp	program_header,*
	cmpq	0,dl
	tnz	subprogram_not_found
"
"	ptr to entry is in pr2, special handling needed if not BASIC
"	check number of arguments supplied against number wanted
"
have_entry:
	epp0	text_base_ptr,*7	get ptr to arglist
	eax1	ignore_handler
	orsx1	flags		calling prog not interested in conditions
	lxl0	2|0		get opcode from entry word
	cmpx0	eax7,du		is this eax7
	tnz	not_basic		no, can't possibly be basic
	lda	2|-1		get word containing descriptor in upper
	cana	=o400000,dl	is this basic entry
	tze	not_basic
	lda	2|3		basic, get ptr to program header of new entry
	epp1	2|-1,al
	lxl0	1|bph.incoming_args	get 2*n_args wanted
	cmpx0	0|0		compare with number supplied
	tnz	wrong_number_of_args
	ldx0	1|bph.incoming_args	get ptr to arg type array
	epp1	1|0,0
"
"	extend our stack frame to include all of frame of called sub
"
	segdef	call_op_begin	denotes section of code where x7 nonvalid
call_op_begin:
	ldx7	2|0		get stack size
	eax3	pdl_size+math_block_size+fn_size,7	ead space for pdl and fn frames
	epp3	sb|stack_header.stack_end_ptr,*
	epp4	3|0,3
	spri4	sb|stack_header.stack_end_ptr
	spri4	sp|stack_frame.next_sp
	spri4	pr3|stack_frame.next_sp	set now so we can reuse pr4
"
"	pr3 points at where new frame will be, sp still points at old frame
"	now copy args into new frame and check type of each arg as we do it
"	Note: pr5, x4 and x6 may be referenced by arg ITB(s)
"
	eax0	0
	eax1	0
arg_copy:
	cmpx0	0|0		are we done
	tpl	arg_copy_done	yes
	epp4	0|2,0		get ptr to arg ITB pair
	cmpc	(pr),(pr,x1)	check arg type
	desc9a	pr4|0(1),1
	desc9a	pr1|0,1
	tnz	wrong_arg_type	error if mismatch
	epp4	pr4|0,*		arg ok, get ptr to arg
	spri4	3|args,0		store ptr in new frame
	adx0	2,du		update for next arg
	adx1	1,du
	tra	arg_copy		and repeat until done
arg_copy_done:
	epp4	0|2,0		get ptr to return location
	spri4	temp3		save for use when we return
	epp4	sp|0		save ptr to current stack frame
	epp2	2|3		fake "tsp2" for subsequent entry code
	sprisp	3|stack_frame.prev_sp	set up new frame
	spri3	sp|stack_frame.next_sp
	segdef	new_frame		denotes section where in new stack
new_frame:
	eppsp	3|0		stack frame now belongs to called sub
	stz	flags		clear flags
	spri0	sp|stack_frame.arg_ptr
	stz	temp1
	stx0	temp1		save 2*n_args in upper
	eaq	-args,7		compute number of words to zero
	sbq	temp1		adjusting for ptr words
	tze	sub_go		skip if nothing to zero
	epp1	sp|args,0
	qls	2
	mlr	(),(pr,rl),fill(0)
	vfd	36/0
	desc9a	1|0,qu
"
sub_go:	sreg	sp|stack_frame.regs
	stcd	pr4|stack_frame.return_ptr	set real return ptr in old frame
	tra	init_stack	join standard entry sequence
	segdef	call_op_end
call_op_end:
"
"	control returns here after subprogram finishes, return to real caller
"
sub_done:	epp4	program_header,*
	ldx3	pr4|bph.string_storage
	epp5	sp|0,3			load to start of string vars
	ldx5	pr4|bph.precision_ind
	xec	load_op_tbl_ptr,5
	lreg	sp|stack_frame.regs
	eax1	use_handler		turn off ignore flag
	ansx1	flags		so we will handle conditions again
	tra	temp3,*
"
"
"	this procedure being called is not written in basic, we'll have to
"	generate a standard Multics argument list.  extend stack by enough
"	to hold an arg pointer and a desc pointer for each argument.
"
not_basic:
	lda	0|0		get number of args * 2
	tze	no_args		easy if no args
	epp3	sb|stack_header.stack_end_ptr,*
	epp1	3|2,au		get ptr to where descriptor ptrs will go
	als	1
	ada	2+15,du		form 4*n_args+2 and make multiple of 16
	ana	=o7777760,du
	sta	fn_temp1		save size of extension in upper
	asa	sb|stack_header.stack_end_ptr+1  extend stack
	asa	sp|stack_frame.next_sp+1
"
"	at this point:
"		pr0 -> arg list in basic program
"		pr1 -> where descriptors should go
"		pr2 -> entry point of procedure being called
"		pr3 -> where argument list should go
"		pr5 -> where string variables are stored
"
	spri2	temp3		save so can use pr2 as a temp
	eax0	0		init arg copy loop
	eax1	0		amount of free space is 0
	ldx5	4|bph.precision_ind
"
ac_loop:	cmpx0	0|0		have all args been copied?
	tpl	ac_done		yes, skip
	ldq	0|2,0		extract arg type code
	qrl	18
	anq	=o77,dl
	epp2	0|2,0*		get ptr to basic arg
	tra	*-1,ql		dispatch to handle arg type
	tra	n_scalar
	tra	s_scalar
	tra	n_list
	tra	s_list
	tra	n_table
	tra	s_table
	tra	n_fun
	tra	s_fun
	tra	file
"
"	arg is numeric scalar, pass ptr directly to arg and use
"	constant float bin(27) descriptor
"
n_scalar:	spri2	3|2,0		save arg ptr
	epp2	float_bin_desc,5
	spri2	1|0,0		save desc ptr
	adx0	2,du		go do next arg
	tra	ac_loop
"
"	arg is string scalar, treat as char(*) where * is
"	current length
"
s_scalar:	ldq	66,dl		go call runtime to make string value unique
	sprp4	fn_temp2	
	epp4	sp|stack_frame.lp_ptr,*
	call	<basic_runtime_>|[basic_runtime_](runtime_arglist)
	lprp4	fn_temp2	
	lda	pr2|0		get string word
	epbp2	string_segment,*	get ptr to beg of string segment
	epp2	pr2|0,au		get ptr to string block
	epp2	pr2|2		get ptr to chars
	spri2	pr3|2,0		save arg ptr
	cmpx1	1,du		is there one word in free block
	tpl	2,ic		yes, skip
	tsx2	extend_by_16	no, extend stack by 16
	ldq	pr2|-1		get string length
	orq	char_type,du	make descriptor
	stq	4|0		save descriptor in free space
	spri4	1|0,0		store ptr to descriptor
	epp4	4|1		update free space ptr
	sbx1	1,du		and free space count
	adx0	2,du		go do next arg
	tra	ac_loop
"
"	arg is numeric list, treat as (*) float bin
"
n_list:	cmpx1	4,du		are there 4 words free
	tpl	2,ic
	tsx2	extend_by_16	no, extend stack by 16
	ldq	float_bin_desc,5
	orq	dim_1,du		insert dim flag in descriptor
	stq	4|descriptor.type
	stz	4|descriptor.lower_1	lb1 = 0
	ldq	pr2|array_dope.current_bounds
	sbq	1,dl
	stq	4|descriptor.upper_1	ub1 = our upper bound
	xec	s1b,5
	stq	4|descriptor.multiplier_1	m1 = 1
	spri4	1|0,0		save ptr to descriptor
	epp4	4|4		adjust free space
	sbx1	4,du
n_list_1:	epp2	pr2|array_dope.data,*	get ptr to data
	spri2	3|2,0		save arg ptr
	adx0	2,du		update for next arg
	tra	ac_loop
s1b:	ldq	1,dl
	ldq	2,dl
"
"	arg is numeric table, treat as(*,*) float bin
"
n_table:	cmpx1	7,du		are there 7 words free
	tpl	2,ic
	tsx2	extend_by_16	no, extend stack by 16
	ldq	float_bin_desc
	orq	dim_2,du		insert dim flag in descriptor
	stq	4|descriptor.type
	stz	4|descriptor.lower_1	lb1 = 0
	ldq	pr2|array_dope.current_bounds+1
	qls	0,5
	stq	4|descriptor.multiplier_2	m2 = ub1 + 1
	qrs	0,5
	sbq	1,dl
	stq	4|descriptor.upper_1	ub1 = our 2nd upper
	xec	s1b,5
	stq	4|descriptor.multiplier_1	m1 = 1
	stz	4|descriptor.lower_2	lb2 = 0
	ldq	pr2|array_dope.current_bounds
	sbq	1,dl
	stq	4|descriptor.upper_2	ub2 = our 1st upper
	spri4	1|0,0		save ptr to descriptor
	epp4	4|7		update free space
	sbx1	7,du
	tra	n_list_1
"
"	extend stack by 16 words
"
extend_by_16:
	epp4	sb|stack_header.stack_end_ptr,*  get ptr to end of stack
	eax1	16		extend stack by 16 words
	asx1	sb|stack_header.stack_end_ptr+1
	asx1	sp|stack_frame.next_sp+1
	asx1	fn_temp1		remember additional exension
	tra	0,2		return
"
"	a string list or table is invalid
"
s_list:
s_table:	ldq	153,dl
	tra	error2
"
"	a string or numeric function is invalid
"
n_fun:
s_fun:	ldq	154,dl
	tra	error2
"
"	a file is invalid
"
file:	ldq	155,dl
	tra	error2
"
"	all args have been copied, finish up new arg list and make call
"
ac_done:	lda	0|0		get 2*n_args
	eaq	0,au		indicate descriptors present
	ora	4,dl		insert pl1 code
	staq	3|0		set head of new arg list
	epp2	pr3|0		get ptr to new arg list in temp
	epp3	pr0|2,0		get ptr to return point
	epp0	pr2|0		copy ptr to new arg list
	epp2	temp3,*		restore pr2 for actual call
non_basic_go:
	spri3	temp3
	sreg	sp|stack_frame.regs
	stcd	sp|stack_frame.return_ptr
	callsp	2|0		jump to proc
"
"	return from called proc
"
	lcx0	fn_temp1		get - extension size
	asx0	sb|stack_header.stack_end_ptr+1  remove stack extension
	asx0	sp|stack_frame.next_sp+1
	tra	sub_done
"
"	call has no args
"
no_args:	epp3	pr0|2		get ptr to real return pt
	stz	fn_temp1		stack not extended
	tra	non_basic_go	use same arg ptr
"
float_bin_desc:
	oct	414000000033
	oct	420000000077
"
wrong_number_of_args:
	ldq	150,dl
	tra	error2
"
wrong_arg_type:
	ldq	151,dl
"
error2:	stq	number
	epp1	print_using_ptr,*	get ptr to name of subprogram
	ldq	2,dl
	tsx0	invoke_runtime
	tra	stop_op
"
subprogram_not_found:
	ldq	152,dl
	tra	error2
"
"	operator to do gosub return
"
return_op:
	ldq	pdl,di		pop pdl
	tnz	text_base_ptr,*qu	it is return point if non-zero
"
	ldq	102,dl		error, return without gosub
	tra	error1		go print error and abort run
"
sub_exit_op:
	tra	not_yet
"
	new_fun_call_op	sp_,1,fst,18
"
fn_call_error:
	ldq	128,dl
	tra	error1
"
"
	new_global_fun_call_op	sp_
"
	new_fun_return_op	sp_,1,fld
"
fn_return_error:
	ldq	129,dl
	tra	error1
"
	list_sub_op	sp_
"
	table_sub_op	sp_
"
	inv_table_sub_op	sp_
"
subscript_error:
	ldq	100,dl
"
error1:	stq	number
	ldq	2,dl
	tsx0	invoke_runtime
	tra	stop_op
"
error_in_statement:
	ldq	111,dl
	tra	error1
"
missing_line:
	ldq	112,dl
	tra	error1
"
unclosed_for:
	ldq	113,dl
	tra	error1
"
undefined_function:
	ldq	127,dl
	tra	error1
"
"	I/O operations
"
use_tty:
	ldx5	=0,du
	sxl5	file_number
	lprpbp	fcb		set fcb_pt
	spribp	fcb_pt
	tra	text_base_ptr,*7
"
"	operator to set up fcb, entered with file number in eaq
"
setup_fcb:
	ufa	=35b25,du		fix file number
	tmi	invalid_file_number
	cmpa	16,dl		complain if bad
	tpnz	invalid_file_number
	eax5	0,al
	sxl5	file_number
	ldq	fcb,al
	cmpq	=o007777000001
	tze	invalid_file_number	error if null
	lprpbp	fcb,al
	spribp	fcb_pt		set fcb_pt
	tra	text_base_ptr,*7		and return
"
"	operator to store ptr to parameter fcb.  entered with fcb ptr
"	in pr2 and file number in eaq
"
use_fcb:
	ufa	=35b25,du
	sprpbp	fcb,al
	tra	text_base_ptr,*7
"
invalid_file_number:
	ldq	135,dl
	tra	error1
"
"	operator to scratch file
"
scratch:
	ldq	31,dl
	tra	call_runtime
"
"	operator to set file margin, entered with margin in eaq
"
margin:
	fst	temp1
	ldq	30,dl
	tra	call_runtime
"
"	reset reading of data
"
reset_data:
	eppab	program_header,*
	tsx0	init_data
	tra	text_base_ptr,*7
"
"	operator to write numeric value in eaq into random file
"
numeric_write:
	dfst	temp1
	ldq	34,dl
	tra	call_runtime
"
"	operator to write string value specified by ab into random file
"
string_write:
	ldq	36,dl
	tra	call_runtime
"
	numeric_read	sp_,fld
"
	numeric_data_read	sp_,fld,1
"
out_of_data:
	ldq	103,dl		go print error and abort trun
	tra	error1
"
"	operator to read string value, return string ptr in ab
"
string_read:
	ldq	37,dl		reading random file
	tra	call_runtime
"
new_string_data_read:
	lxl0	string_data_pos
	cmpx0	string_data_pos
	trc	out_of_data
	ldq	text_base_ptr,*0
	adx0	1,du
	sxl0	string_data_pos
	eppab	program_header,*ql
	tra	text_base_ptr,*7
"
"	print numeric value in eaq
"
numeric_print:
	dfst	temp1
	ldq	3,dl
"
call_runtime:
	epplp	sp|stack_frame.lp_ptr,*
	call	<basic_runtime_>|[basic_runtime_](runtime_arglist)
	epplp	program_header,*
	tra	text_base_ptr,*7
"
string_print:
	ldq	4,dl
	tra	call_runtime
"
"	finish current line
"
print_new_line:
	ldq	7,dl
	tra	call_runtime
"
"	move to next column which is multiple of 15
"
tab_for_comma:
	ldq	5,dl
	tra	call_runtime
"
"	tab to column whose value is in eaq
"
tab_fun:
	fst	temp1
	ldq	8,dl
	tra	call_runtime
"
"	space by number of columns given in eaq
"
spc_fun:
	fst	temp1
	ldq	9,dl
	tra	call_runtime
"
	numeric_input	sp_,fld
"
"	input string value, pointer to result left in ab
"
string_input:
	ldq	15,dl
	tra	call_runtime
"
linput:
	ldq	13,dl
	tra	call_runtime
"
"	terminate current input statement
"
end_input:
	ldq	16,dl
	tra	call_runtime
"
lof_fun:
	fst	temp1
	ldq	38,dl
	tra	pos1
"
loc_fun:
	fst	temp1
	ldq	39,dl
	tra	pos1
"
mar_fun:
	fst	temp1
	ldq	40,dl
	tra	pos1
"
check_eof:
	fst	temp1
	ldq	41,dl
	tra	pos1
"
per_fun:
	fst	temp1
	ldq	64,dl
	tra	pos1
"
typ_fun:
	fst	temp1
	ldq	42,dl
	tra	pos1
"
print_using_start:
	ldq	56,dl
	tra	call_runtime
"
print_using_end:
	ldq	59,dl
	tra	call_runtime
"
	print_using_numeric	sp_,fst
"
print_using_string:
	ldq	58,dl
	tra	call_runtime
"
"	hps
"
hps_fun:
	fst	temp1
	ldq	25,dl
	tra	pos1
"
lin_fun:
	tra	not_yet
"
"	tst(a$)
"
tst_fun:
	ldq	26,dl
	tra	pos1
"
num_fun:
	lda	number_read
	tra	len1
"
"	operator to "open" file, entered with file name specified by pr(1)
"	and file number in eaq
"
file_fun:
	fst	temp1
	ldq	29,dl
	tra	call_runtime
"
reset_ascii:
	ldq	32,dl
	tra	call_runtime
"
reset_random:
	lxl5	file_number	file 0 means internal data
	tze	reset_data
	fst	temp1
	ldq	33,dl
	tra	call_runtime
"
end_print:
	ldq	6,dl
	tra	call_runtime
"
"	Numeric functions
"
"	absolute value
"		fld	x
"		tsx7	abs_fun
"
abs_fun:
	fad	=0.0,du		make sure indicators are set right
	tpl	text_base_ptr,*7
	fneg	0
	tra	text_base_ptr,*7
"
"	integer part
"		fld	x
"		tsx7	int_fun
"
int_fun:
	fst	temp1		save for range check
	ufa	=71b25,du		get integer in AQ
	fad	=71b25,du		float again
	tnz	text_base_ptr,*7	if non-zero, all done
	fld	temp1		must check arg for range -.5 to 0
	tmi	3,ic		if arg negative, answer is -1.0
	fld	=0.0,du		answer is really 0.0
	tra	text_base_ptr,*7	return
	fld	=-1.0,du
	tra	text_base_ptr,*7	return
"
	mod_fun	sp_,fst,fdi,fmp,fad
"
randomize:
	epplp	sp|stack_frame.lp_ptr,*
	call	<clock_>|[clock_](arglist1)
	epplp	program_header,*
	ldq	temp1+1		use low-order clock value
	stq	random
	tra	text_base_ptr,*7	and return
"
"	operator to return pseudo-random number in eaq
"
rnd_fun:
	ldq	random		get last random number
	mpy	random_multiplier
	adl	random_addend
	cmpq	0,dl
	tpl	2,ic		make sure it is positive
	erq	=o400000,du
	stq	random		save for next time
	lda	0,dl		treat as binary fraction
	lde	=36b25,du
	fad	=0.0,du		float it
	tra	text_base_ptr,*7	and return
"
"	signum
"		fld	x
"		tsx7	sgn_fun
"
sgn_fun:
	tze	text_base_ptr,*7
	tmi	3,ic
	fld	=1.0,du
	tra	text_base_ptr,*7
	fld	=-1.0,du
	tra	text_base_ptr,*7
"
tim_fun:
	epplp	sp|stack_frame.lp_ptr,*
	call	<virtual_cpu_time_>|[virtual_cpu_time_](arglist1)
	epplp	program_header,*
	ldaq	temp1
	sbaq	cpu_start
	lde	=71b25,du
	fad	=0.0,du
	fdv	=1.0e6
	tra	text_base_ptr,*7
"
	val_fun	sp_
"
	math_functions	sp_
"
	power_functions	sp_,fst,fld
"
"	matrix functions
"
det_fun:
	szn	determinant	make sure inv was called
	tze	array_error
	dfld	determinant
	tra	text_base_ptr,*7
"
array_error:
	ldq	139,dl
	tra	error1
"
	zer_con_funs	sp_,fld,(=0.0,du),(=1.0,du),fst,1
"
	idn_fun	sp_,fld,fst,1
"
	mat_assign_numeric	sp_,fld,fst,1
"
"	operator to do
"		mat a$ = b$
"
mat_assign_string:
	ldaq	1|array_dope.current_bounds
	cmpq	0,dl
	tmi	string_list_assign
	mpy	1|array_dope.current_bounds+1
	stq	temp3
	ldq	2|array_dope.original_bounds
	mpy	2|array_dope.original_bounds+1
	cmpq	temp3
	tmi	redim_error
	ldaq	1|array_dope.current_bounds
	staq	2|array_dope.current_bounds
mas:	ldq	63,dl
	tra	call_runtime
"
string_list_assign:
	cmpa	2|array_dope.original_bounds
	tpnz	redim_error
	sta	2|array_dope.current_bounds
	tra	mas
"
	mat_add_sub	sp_
"
	mat_scalar_mult	sp_,fst
"
	dot_product	sp_,1,fld,fmp,fcmp
"
"	operator to do
"		mat A = inv(B)
"
inv_fun:
	ldq	1|array_dope.current_bounds
	cmpq	1|array_dope.current_bounds+1
	tnz	array_error	must be sequare
	mpy	1|array_dope.current_bounds+1
	stq	temp3
	ldq	2|array_dope.original_bounds
	mpy	2|array_dope.original_bounds+1
	cmpq	temp3
	tmi	redim_error
	ldaq	1|array_dope.current_bounds
	staq	2|array_dope.current_bounds
	ldq	1,dl
"
call_matrix:
	epplp	sp|stack_frame.lp_ptr,*
	call	<basic_matrix_>|[basic_matrix_](runtime_arglist)
	epplp	program_header,*
	cmpq	0,dl
	tnz	error1
	tra	text_base_ptr,*7
"
	trn_fun	sp_
"
"	operator to do
"		mat A = B * C
"	when A and B are vectors and C is a matrix
"
mat_mult_vm:
	ldq	1|array_dope.current_bounds
	cmpq	3|array_dope.current_bounds
	tnz	array_error
	ldq	3|array_dope.current_bounds+1
	cmpq	2|array_dope.original_bounds
	tpnz	redim_error
	stq	2|array_dope.current_bounds
	ldq	3,dl
	tra	call_matrix
"
"	operator to do
"		mat A = B * C
"	when A and C are vectors and B is a matrix
"
mat_mult_mv:
	ldq	1|array_dope.current_bounds+1
	cmpq	3|array_dope.current_bounds
	tnz	array_error
	ldq	1|array_dope.current_bounds
	cmpq	2|array_dope.original_bounds
	tpnz	redim_error
	stq	2|array_dope.current_bounds
	ldq	4,dl
	tra	call_matrix
"
"	operator to do
"		mat A = B * C
"	when A, B and C are all matrices
"
mat_mult_mm:
	ldq	1|array_dope.current_bounds+1
	cmpq	3|array_dope.current_bounds
	tnz	array_error
	ldq	1|array_dope.current_bounds
	mpy	3|array_dope.current_bounds+1
	stq	temp3
	ldq	2|array_dope.original_bounds
	mpy	2|array_dope.original_bounds+1
	cmpq	temp3
	tmi	redim_error
	lda	1|array_dope.current_bounds
	ldq	3|array_dope.current_bounds+1
	staq	2|array_dope.current_bounds
	ldq	5,dl
	tra	call_matrix
"
nul_fun:
	ldq	62,dl
	tra	call_runtime
"
"	operator to redimension list
"		epp2	dope
"		fld	new_bound
"		tsx7	list_redim
"
list_redim_op:
	ufa	=35b25,du		fix bound
	tmoz	redim_error
	ada	1,dl		get number of elements
	cmpa	bp|array_dope.original_bounds
	tpnz	redim_error
	sta	bp|array_dope.current_bounds
	tra	text_base_ptr,*7
"
redim_error:
	ldq	137,dl
	tra	error1
"
"	operator to redimension table
"		epp2	dope
"		fld	new_bound1
"		tsx7	table_redim
"		fld	new_bound2
"
table_redim_op:
	ufa	=71b25,du
	tmoz	redim_error
	adq	1,dl
	stq	temp1
	xec	text_base_ptr,*7
	ufa	=71b25,du
	tmoz	redim_error
	adq	1,dl
	stq	temp2
	mpy	temp1
redim:	stq	temp3
	ldq	bp|array_dope.original_bounds
	mpy	bp|array_dope.original_bounds+1
	cmpq	temp3
	tmi	redim_error
	lda	temp1
	ldq	temp2
	staq	bp|array_dope.current_bounds
	adx7	1,du
	tra	text_base_ptr,*7
"
"	operator to redimension table inversely
"		epp2	dope
"		fld	new_bound2
"		tsx7	inv_table_redim
"		fld	new_bound1
"
inv_table_redim_op:
	ufa	=71b25,du
	tmoz	redim_error
	adq	1,dl
	stq	temp2
	xec	text_base_ptr,*7
	ufa	=71b25,du
	tmoz	redim_error
	adq	1,dl
	stq	temp1
	mpy	temp2
	tra	redim
"
"	matrix I/O operators entered with pr2 -> dope
"
mat_numeric_input:
	ldq	45,dl
	tra	mnp
"
mat_string_input:
	ldq	46,dl
	tra	mnp
"
mat_numeric_print:
	ldq	47,dl
mnp:	lda	text_base_ptr,*7	get format control | redim switch
	tsx0	invoke_runtime
	adx7	1,du
	tra	text_base_ptr,*7
"
mat_string_print:
	ldq	48,dl
	tra	mnp
"
mat_numeric_read:
	ldq	49,dl
	tra	call_runtime
"
mat_string_read:
	ldq	50,dl
	tra	call_runtime
"
mat_numeric_write:
	ldq	51,dl
	tra	call_runtime
"
mat_string_write:
	ldq	52,dl
	tra	call_runtime
"
mat_linput_op:
	ldq	55,dl
	tra	call_runtime
"
mat_numeric_data_read:
	ldq	53,dl
	tra	call_runtime
"
mat_string_data_read:
	ldq	54,dl
	tra	call_runtime
"
mat_print_using_numeric:
	ldq	60,dl
	tra	call_runtime
"
mat_print_using_string:
	ldq	61,dl
	tra	call_runtime
"
"	operator to reset default number length
"
setdigits_op:
	ufa	=35b25,du		convert to integer
	tmoz	invalid_number_length
	cmpa	19,dl
	tpnz	invalid_number_length
	eax1	0,al
	sxl1	flags
	tra	text_base_ptr,*7
"
invalid_number_length:
	ldq	166,dl
	stq	number
	ldq	2,dl
	tra	call_runtime
"
string_data_read:
	lxl0	string_data_pos
	cmpx0	string_data_pos
	trc	out_of_data
	ldq	text_base_ptr,*0
	adx0	1,du
	sxl0	string_data_pos
	eppab	text_base_ptr,*ql
	tra	text_base_ptr,*7
"
not_yet:	ldq	99,dl
	tra	error1
"
	segdef	enter_proc
enter_proc:
	lda	=o400000,du	indicate called from non-basic
	eaq	0,7		don't get extra space at end of frame
	tra	save
"
	segdef	enter_main
enter_main:
	lda	=o200000,du	indicate main program
	eaq	pdl_size+math_block_size+fn_size,7	add extra space at end of frame
"
save:	eppbb	sb|stack_header.stack_end_ptr,*
	sprisp	bb|stack_frame.prev_sp
	eppab	bb|0,qu
	spriab	bb|stack_frame.next_sp
	spriab	sb|stack_header.stack_end_ptr
	eppsp	bb|0
	spriap	sp|stack_frame.arg_ptr
	sta	flags		initialize flags
"
"	zero out user area in stack
"
	eaq	-args,7		compute number of words to zero
	tze	init_stack	skip if no variables
	qls	2		get number of chars
	mlr	(),(pr,rl),fill(0)
	vfd	36/0
	desc9a	sp|args,qu
"
"	setup entry ptr and language type code in stack frame
"
init_stack:
	eawpbp	bp|-3
	spribp	sp|stack_frame.entry_ptr
	spbpbp	text_base_ptr
	lda	5,du
	sta	sp|stack_frame.translator_id
"
"	setup ptr to basic program header 
"
	lda	bp|3
	eppab	bp|-1,al
	spriab	program_header
	eaa	ab|0		save in case program is bound
	sta	program_header_offset
"
"	initialize precision indicator
"
	ldx5	1,du
	adx5	ab|bph.precision_ind
	stx5	file_number
	sbx5	1,du		restore precision indicator
"
"	initialize digit count
"
	ldx1	6,du
	sxl1	flags
"
"	get ptr to definitions section
"
	lxl1	ab|bph.definitions
	tze	3,ic		zero means regular object
	eppap	ab|0,1		non-zero means defs relative to header
	tra	4,ic
	epaq	ab|0		have object segment, get linkage ptr
	lprplp	sb|stack_header.lot_ptr,*au
	eppap	lp|0,*		get ptr to defs from head of linkage
	sprpap	definitions	save definitions ptr
"
"	store ptr to acc string giving name of this subprogram
"
	lda	bp|-1		get def offset in au
	lda	ap|def.symbol,au	get acc offset in au
	epp4	ap|0,au		get ptr to acc
	sprp4	entryname		and save
"
"	store ptr to our linkage section
"
	epaq	*
	lprplp	sb|stack_header.lot_ptr,*au
	sprilp	sp|stack_frame.lp_ptr
"
"	set up abort label
"
	eppap	stop_op
	spriap	abort_label
	sprisp	abort_label+2
"
"	initialize conversion_label & size_label to "null"
"
	stz	conversion_label
	stz	size_label
"
"	establish default handler and cleanup procedures
"
	eaa	sp|0		get offset of this frame
	neg	0		get -offset
	eppbb	on_units		get ptr to first unit
	stz	bb|on_next	clear next ptr
	eppap	cleanup		fill in name
	spriap	bb|on_name
	ldq	7,dl		and length
	stq	bb|on_size
	eppap	<basic_runtime_>|[cleanup]	fill in body ptr
	spriap	bb|on_body
	eax2	bb|0,au		get offset of this unit relative to frame
	eppbb	bb|6		get ptr to next unit
	stz	bb|on_next	set next ptr
	stx2	bb|on_next
	eppap	unclaimed_signal	fill in name
	spriap	bb|on_name
	ldq	16,dl		and length
	stq	bb|on_size
	eppap	<basic_runtime_>|[default]	fill in body ptr
	spriap	bb|on_body
	eax2	bb|0,au		get offset of this unit relative to frame
	stz	sp|stack_frame.on_unit_rel_ptrs
	stx2	sp|stack_frame.on_unit_rel_ptrs	establish chain
	lda	=o100,dl		turn on flag that says chain exists
	orsa	sp|stack_frame.prev_sp
"
"	setup arglist for use in calling basic_runtime_ & basic_matrix_
"	and arglist for calling virtual_cpu_time_
"
	eppap	temp1
	spriap	arglist1+2
	eppap	abort_label+2
	spriap	runtime_arglist+2
	fld	1*2048,dl
	staq	arglist1
	staq	runtime_arglist
"
"	call basic_runtime_ to do any further initialization
"
	ldq	0,dl
	call	<basic_runtime_>|[basic_runtime_](runtime_arglist)
"
"	set up array dope
"
	lda	ab|bph.numeric_arrays
	tsx0	setup_arrays
	lda	ab|bph.string_arrays
	tsx0	setup_arrays
"
"	initialize random number generator
"
	lda	initial_random
	sta	random
"
"	indicate inv not called
"
	stz	determinant
"
"	init num function
"
	stz	number_read
"
"	convert arg list if we were called from non-basic program
"
	szn	flags
	tmi	call_from_non_basic
"
"	set up push down list at end of stack
"
setup_pdl:
	eppap	sp|0,7		get ptr to start of pdl
	eaa	ap|0		get offset
	ora	pdl_size*64,dl	form tally word
	sta	pdl		and save
"
"	store word of zeros so we can detect return without gosub
"
	stz	pdl,id
"
"	initialize math block and function frame area
"
	eaa	sp|0		get offset of this stack frame
	sta	temp1		and save
	eppap	ap|pdl_size	get ptr to end of pdl
	sprpap	math_block	save ptr to math block
	eppap	ap|math_block_size	skip over math block
	eaa	ap|0		get offset
	sba	temp1		relative to start of frame
	sta	next_frame
	ada	fn_size,du
	sta	last_frame
"
"	initialize numeric and string data position
"
	tsx0	init_data
"
"	all done with initialization, start user program
"
	call	<virtual_cpu_time_>|[virtual_cpu_time_](arglist1)
	ldaq	temp1
	staq	cpu_start
"
"
	epplp	program_header,*
	ldx3	pr4|bph.string_storage
	epp5	sp|0,3		load ptr to start of string variables
	ldx5	pr4|bph.precision_ind
	xec	load_op_tbl_ptr,5	get ptr to correct op table
	eax4	0		init fn display
	eax6	0		init fn frame offset
	tra	bp|4		start program
"
load_op_tbl_ptr:
	epp0	sp_operator_table
	epp0	ep_operator_table
"
call_from_non_basic:
	stz	fn_temp1		init extension count
	lxl0	1|bph.incoming_args	get number of args expected * 2
	tze	args_thru		trivial if no args expected
	epp0	sp|stack_frame.arg_ptr,*	get ptr to our arglist
	cmpx0	0|0		compare against number provided
	tnz	incorrect_number_of_args	complain if wrong number of args
	ldq	0|1		are descriptors present
	tze	no_descriptors	no, complain
	epp3	0|2,qu		get ptr to start of descriptors
	lxl0	0|0		is there an extra ptr in arglist
	canx0	8,du
	tze	2,ic
	epp3	3|2		yes, skip over extra ptr
	ldx0	1|bph.incoming_args	get ptr to arg type array
	epp1	1|0,0
	eax0	0		init list position
	eax1	0		zero free space initially
	eax3	-1		init arg count
"
"	at this point
"		pr0 -> arglist
"		pr3 -> descriptors
"	process each arg and convert to appropriate basic type
"
loop_ac:	cmpx0	0|0		are we done with args
	tpl	args_done		yes, go finish up
	adx3	1,du		update arg position
	epp5	3|0,0*		get ptr to descriptor
	ldx4	5|0		get lhs of descriptor
	mrl	(pr,x3),(pr),fill(0)	extract type code for this arg
	desc9a	1|0,1
	desc9a	fn_temp2,4
	lda	fn_temp2		get expected type
	tra	*-1,al		and dispatch on it
	tra	scalar_n
	tra	scalar_s
	tra	list_n
	tra	list_s
	tra	table_n
	tra	table_s
	tra	fun_n
	tra	fun_s
	tra	file1
"
"	all args transformed, update x7 by amount stack was extended
"	extend stack to get space for pdl, math block, and functions
"	and rejoin normal code
"
args_done:
	epp1	program_header,*	restore program header ptr
	epp2	sp|stack_frame.entry_ptr,*	restore ptr to entry point
	epp4	sp|stack_frame.lp_ptr,*	restore ptr to our linkage
"
args_thru:
	adx7	fn_temp1
	eax1	pdl_size+math_block_size+fn_size
	asx1	sb|stack_header.stack_end_ptr+1
	asx1	sp|stack_frame.next_sp+1
	tra	setup_pdl
"
"
"	expected arg is numeric scalar
"
scalar_n:
	cmpx4	n_scalar_type,du	check type from descriptor
	tnz	incorrect_arg_type
	epp5	0|2,0*		type ok, get ptr to variable
	spri5	sp|args,0		store ptr to arg
	adx0	2,du		and go do next arg
	tra	loop_ac
"
"	expected arg is string scalar
"
scalar_s:
	lda	5|0		get descriptor size
	ana	=o777777,dl
	epp2	0|2,0*		get ptr to characters
	cmpa	4096,dl		complain if length too long
	tpl	incorrect_arg_type
	cmpx1	2,du		get space for string word
	tpl	2,ic
	tsx2	extend_by_16
	sta	4|1		save descriptor size
	anx4	erase_packed_bit,du	erase packed bit in descriptor lhs
	cmpx4	char_type,du	skip if arg is non-varying
	tze	convert_string
	cmpx4	vs_char_type,du	complain if not varying
	tnz	incorrect_arg_type
"
"	arg is varying char string
"
	lda	2|-1		get current length
	eax4	1		remember varying
	stx4	4|1
"
convert_string:
	spri4	sp|args,0		args is our string word
	sbx1	2,du		account for space
	ldq	65,dl		go to run-time to make string value
	sprp1	fn_temp2		pr1 will get changed by basic_runtime_, so save it
	epp4	sp|stack_frame.lp_ptr,*
	call	<basic_runtime_>|[basic_runtime_](runtime_arglist)
	epp4	sp|args,0*		restore free ptr
	epp0	sp|stack_frame.arg_ptr,*	restore arglist ptr
	ldq	1|0		get string word
	stq	4|0		and save
	stz	1|0		prevent deallocation
	lprp1	fn_temp2
	epp4	4|2		account for space
	adx0	2,du		and go do next arg
	tra	loop_ac
"
"	arg is numeric list
"
list_n:	cmpx4	n_list_type,du	check type
	tnz	incorrect_arg_type
	ldq	5|descriptor.multiplier_1	make sure array is connected
	cmpq	1,dl
	tnz	incorrect_arg_type
	lda	5|descriptor.upper_1	fill in bounds
	sba	5|descriptor.lower_1
	ada	1,dl
	lcq	1,dl
set_dope:
	cmpx1	6,du		get dope space
	tpl	2,ic
	tsx2	extend_by_16
	staq	4|array_dope.original_bounds
	staq	4|array_dope.current_bounds
	epp2	0|2,0*		get ptr to data
	spri2	4|array_dope.data	save in dope vector
	spri4	sp|args,0		arg points to dope vector
	epp4	4|6		account for free space used
	sbx1	6,du
	adx0	2,du		go do next arg
	tra	loop_ac
"
"	arg is numeric table
"
table_n:
	cmpx4	n_table_type,du	check type
	tnz	incorrect_arg_type
	ldq	5|descriptor.multiplier_1	make sure array is connected
	cmpq	1,dl
	tnz	incorrect_arg_type
	ldq	5|descriptor.upper_1
	sbq	5|descriptor.lower_1
	adq	1,dl
	cmpq	5|descriptor.multiplier_2
	tnz	incorrect_arg_type
	lda	5|descriptor.upper_2
	sba	5|descriptor.lower_2
	ada	1,dl
	tra	set_dope
"
incorrect_number_of_args:
	ldq	160,dl
	tra	error3
"
incorrect_arg_type:
	ldq	161,dl
error3:	stq	number
	lprp1	entryname
	ldq	2,dl
	tsx0	invoke_runtime
	tra	stop_op
"
no_descriptors:
	ldq	162,dl
	tra	error3
"
list_s:
table_s:
	ldq	163,dl
	tra	error3
"
fun_n:
fun_s:
	ldq	164,dl
	tra	error3
"
file1:	ldq	165,dl
	tra	error3
"
"	int subroutine to setup array dope
"
setup_arrays:
	tze	0,0
	eppap	ab|0,au		get ptr to start of array_symbols
"
array_loop:
	lda	ap|0		get 1st word of array symbol
	tze	0,0		zero means done
	cana	array_symbol_param,dl
	tnz	next_array	skip if parameter
	epplb	sp|0,al		get ptr to array dope
	ldq	ap|array_symbol.offset
	eppbb	sp|0,ql		get ptr to actual data location
	spribb	lb|array_dope.data	set data ptr
	lda	ap|array_symbol.bounds	get bounds in upper,lower
	lrs	18		unpack
	qrs	18
	staq	lb|array_dope.current_bounds
	staq	lb|array_dope.original_bounds
next_array:
	eppap	ap|array_symbol_size	do next array symbol
	tra	array_loop
	segdef	end_entry_ops
end_entry_ops:
"
"	int subroutine to call runtime
"
invoke_runtime:
	epplp	sp|stack_frame.lp_ptr,*
	call	<basic_runtime_>|[basic_runtime_](runtime_arglist)
	epplp	program_header,*
	tra	0,0
"
"	int subroutine to initialize data reading
"
init_data:
	ldx1	ab|bph.numeric_data
	adx1	program_header_offset
	sxl1	numeric_data_pos
	lxl1	ab|bph.numeric_data
	adx1	ab|bph.numeric_data
	adx1	program_header_offset
	stx1	numeric_data_pos
"
	ldx1	ab|bph.string_data
	adx1	program_header_offset
	sxl1	string_data_pos
	lxl1	ab|bph.string_data
	adx1	ab|bph.string_data
	adx1	program_header_offset
	stx1	string_data_pos
"
	tra	0,0
"
"	constants for random number generator
"
initial_random:
	oct	201451444176
"
random_multiplier:
	dec	27182818285
"
random_addend:
	dec	31415926535
"
cleanup:	aci	"cleanup"
"
unclaimed_signal:
	aci	"unclaimed_signal"
"
" 	extended precision operators that are different from single precision operators
"
	string_assign	ep_,dfst,dfld
"
	max		ep_,dfst,dfcmp,dfld
"
	min		ep_,dfst,dfcmp,dfld
"
	new_fun_call_op	ep_,2,dfst,19
"
	new_global_fun_call_op	ep_
"
	new_fun_return_op	ep_,2,dfld
"
	list_sub_op	ep_
"
	table_sub_op	ep_
"
	inv_table_sub_op	ep_
"
	numeric_read	ep_,dfld
"
	numeric_data_read	ep_,dfld,2
"
	numeric_input	ep_,dfld
"
	print_using_numeric	ep_,dfst
"
	mod_fun		ep_,dfst,dfdi,dfmp,dfad
"
	val_fun	ep_
"
	math_functions	ep_
"
	power_functions	ep_,dfst,dfld
"
	zer_con_funs	ep_,eax0,load0,load1,dfst,2
"
	idn_fun		ep_,dfld,dfst,2
"
	mat_assign_numeric	ep_,dfld,dfst,2
"
	mat_add_sub	ep_
"
	mat_scalar_mult	ep_,dfst
"
	dot_product	ep_,2,dfld,dfmp,dfcmp
"
	trn_fun		ep_
"
	fun_call_op	sp_,1,fst,18
"
	global_fun_call_op	sp_
"
	fun_return_op	sp_,1,fld
"
	fun_call_op	ep_,2,dfst,19
"
	global_fun_call_op	ep_
"
	fun_return_op	ep_,2,dfld
"
	segdef	end_basic_operators
end_basic_operators:
	end
