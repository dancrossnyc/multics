/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1986 *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(85-02-21,Davids), approve(86-02-04,MCR7350),
     audit(86-04-24,Gilcrease), install(86-04-24,MR12.0-1048):
     Written by extracting things out of the xforum_ent_attend_mtg_menu
     and xforum_sub_attend_mtg_menus modules.
     
     85-03-25 Davids: Added calls to timer_manager_$sleep after calls
     to com_err_ so that the user will have time to read the message.
     The timer calls were not placed after some calls to com_err_ in
     copy_to_name because the screen is not cleared after those calls.
     
     85-03-26 Davids: Added the set_up_meeting entry point.
     
     85-03-28 Davids: Added code to set_up_meeting so that the old
     xforum_meeting_info structure is not zeroed if it already contains
     information about the meeting.  This will happen if the user
     leaves a meeting and then reenters it without going to another
     meeting.  The forum meeting is still opened, the seen map updated
     and other meeting statistics are still updated.  The current
     comment information is the oinly thing that is really saved.
  2) change(85-04-17,Davids), approve(86-02-04,MCR7350),
     audit(86-04-24,Gilcrease), install(86-04-24,MR12.0-1048):
     Modified the next_unread_comment entry so that it saves the
     original current comment and flags and so that it has a quit
     handler that will restore the current comment and flags and get a
     pointer to the first current comment which is returned.  This
     solves the problem of having a meeting with lots of deleted or
     expunged comments, asking for the next unread, hitting BREAk and
     being left with a current comment that has been deleted or
     expunged.  Error list entry #8.
     
     85-05-01 Davids: Modified next_unread_comment so that if the error
     code returned from xforum_trans_$read is non 0 and neither deleted
     or reaped it will find the next unread comment.  It was just
     telling the user that the next one would be found but the code to
     find it was missing so the user would be in a loop.
     
     85-05-20 Davids: Added header comments and cleaned up some dcls.
     
     85-06-20 Davids: Changed calling sequence of xforum_format_$append
     so that the bit_count parameter which is input/output comes after
     all the input parameters (i.e.  the bit (1) switch).
  3) change(87-04-13,LJAdams), approve(87-04-22,MCR7684),
     audit(87-07-30,Blair), install(87-08-06,MR12.1-1065):
     Changed to allow command_processor_ escapes.
                                                   END HISTORY COMMENTS */

xforum_attend_mtg_utilities: proc;

/*
   BEGIN DESCRIPTION

   function:
      This module contains functions that are used by both the
      xforum_ent_attend_mtg_menu and the xforum_sub_attend_mtg_menu modules.

   description of entry points:
      xforum_attend_mtg_utilities:
         input:
         output:
         It is an error to call the main entry point. The xforum_fatal_error
         condition will be signaled with an "internal programming error" error
         message.

      set_up_meeting:
         input:   ptr              pointer to meeting_list structure
                  ptr              pointer to meeting_info structure
                  fixed bin        index of meeting in meeting_list
                  bit (1) aligned  "1"b => subject oriented attending menu in use
         output:  fixed bin        meeting index used by forum, 0 => meeting not opened
                  char (256)        subject of current comment chain
                  char (256)       chairs msg. "" => no message or no need to print message
         This entry calls forum to open a forum meeting and sets up information
         that xforum needs to know about. The meeting path is obtained from the
         meeting list. The new meeting name and index are compared to the previously
         opened name and index. If they are the same it is assumed that it is the
         same meeting and the old info is reused. This old info includes the current
         set of selected comments. Both name and index are used because it was felt
         that either one by itself might not be enough, i.e. two meeting with the
         same name or a resorted meeting list so that the same index refers to
         a different meeting. If the call to forum fails it is assumed that the
         meeting list has been invalidated by someone changing the name or access
         on the meeting and a message to that effect is output to the user. The
         participation and changed flags are also turned off (and the counts
         decremented) for that meeting. Given that the meeting is opened ok. Then
         if the participant flag is off it is turned on. For a version 2 forum the
         transaction map is obtained, a pseudo transaction map is obtained for version 1
         forums by assuming that all comments prior to the last one the user has seen
         have all been seen. If the previous information is still to be used
         the current comment information must be checked to be sure that it can
         still be used. For the case of changing from entry oriented to subject oriented
         there are sets of current comments that cannot be used, i.e. ranges and sets.
         For these cases the last current comment is set to the last comment in
         the range or set. The chairman message is obtained and returned only if the
         current comment has been set to 1 which means that the user has never atteneded
         the meeting before. The current comment is also read, if the comment cannot be read
         the first comment in the meeting is read and the current comment set to that.
         If that cannot be read a programming error message is output to the user,

      copy_to_name:
         input:   ptr              pointer to the spy structure
         output:  char (32)        name of segment
                  ptr              pointer to segment
                  fixed bin (24)   bit count of segment
         This entry prompts the user for the name of a segment and returns the
         name, pointer and bit count of the segment. The user can input
         either an absolute or relative pathname. Null names are handled by
         printing an error message and the prompt again. "?" is handled by a
         call to xforum_help_$display with the parameters of "xforum_prompt" 
         and "file_name" and then reissusing the prompt. "??" is handled by
         printing an error message and the prompt. The user's response is
         recorded in the spy segment as either "name" or "pathname". Pathname
         is used if the user's response has either a > or a < in it. If the 
         segment indicated by the user cannot be initiated an error message is
         printed and the returned name, ptr and bit count values set to "",
         null and 0. A quit handler also sets the returned values to "", null,
         and 0.

      next_unread_comment:
         input:   ptr              pointer to meeting_info structure
                  fixed bin        index forum uses to ID meeting
                  fixed bin        version of forum meeting
         output:  ptr              pointer to next unread comment or null
         This entry returns a pointer to the forum_user_trans structure of the
         next unread comment, or a null if there are no more unread comments.
         It uses the next_unread element in the xforum_meeting_info structure
         to identify that comment. It then calls xforum_trans_$read to get a
         pointer to it. If the call to read fails because the comment has been
         deleted or expunged then the seen map is marked so that it shows its
         has been seen and the unread_count in xforum_meeting_info is
         decremented. In addition for version 2 meetings the seen switch for
         the comment is set. The next unread comment is then located by looping
         through the seen map - starting with the deleted/expunged comment.
         This new comment is then read and the cycle repeats itself. If some
         other error was returned by the read operation. An error message is
         output and a new unread comment is found. The cycle then repeats.

      update_status:
         input:   ptr              pointer to meeting_info structure
                  fixed bin        index of current comment, 0 implies no current comment
                  char (*)         subject of current comment, used for subject oriented menu
                  fixed bin        version of forum meeting
                  fixed bin        index forum uses to ID meeting
         output:
         This entry updates the contents of the status window, sets seen flags,
         and finds the next unread comment. If the index of the current comment is
         non-zero it will set the forum seen flag or the last_seen_idx depending
         on forum version. It will also set the xforum comment seen map to record
         that the comment has been seen and find the next unseen comment based on
         the xforum seen map. It always makes a call to forum to get the current
         status of the meeting, including the last transaction in the meeting. If
         the meeting has had comments added to it since the xforum_seen_map was
         last updated then the map is extended and the comments marked as unseen.
         The unread count is updated and if there currently were no unread
         comments next_unread is set to the first new comment. The xforum status
         line is then rebuilt using the lastest values of total, and new. The help
         line changed to show F1, F3, and F4.

      close_meeting:
         input:   ptr              pointer to meeting_info structure
                  ptr              pointer to meeting_list structure
                  fixed bin        index of meeting in the meeting list
                  fixed bin        index forum uses to ID meeting
                  ptr              pointer to the attend meeting menu
         output:
         This entry closes a meeting and destroys the associated attend meeting
         menu. The meeting is closed by calls forum_$close. After its closed
         then if the meeting was flaged as having been changed and there are
         no new comments the changed flag is turned off and the changed count
         decremented. 

      enter_trans:
         input:   ptr              pointer to meeting_info structure
                  fixed bin        index forum uses to ID meeting
                  bit (1) aligned  "1"b implies reply mode, "0"b is talk mode
                  ptr              pointer to spy structure
                  bit (1) aligned  "1"b implies subject oriented meeting attendance,
                                   "0"b implies entry order attendance
         output:
         This entry sets up and calls the lisp extension for replying to and
         creating comments. There are two modes, reply mode and talk mode.
         In reply mode the current comments are written to a specially created
         file caled xforum_view_seg in the pdir. The segment will eventually
         be read into the top window of emacs. The segment xforum_trans which
         is also created in the pdir is used to house the new comment. The
         emacs extension IS NOT FOUND BY SEARCH RULES. It is found by
         determining the current referencing dir and creating the absolute
         path to the extension by using the referencing dir and the name of the
         extension. Note that the pointers to xforum_trans, xforum_view_seg and
         the extension are stored in internal static so once the extension is
         used you cannot use a new one. When the user exits the extension the
         new comment is in the xforum_trans segment. The first 9 characters of
         segment must be "Subject: " or an error will be reported. The subject
         is extracted and placed in its own variable of 500 characters. Embeded
         new-lines are allowed by terminating the subject with an ESC
         character. forum_$enter_trans is used to enter the comment and itr
         returns the comment number so it can be reported to the user. If the
         new comment number is greater than 1 + the last known comment number
         i.e. last_trans stored in xforum_meeting_info it means that there are
         new comments. The transaction number returned is used as a new last
         and the seen map, unread_count, and next_unread index are all updated.

   description of internal procedures:
      collect_spy_data: Similar to all the other collect_spy_data procedures. See the
      xforum module. Note that this procedure is duplicated so as to save the
      expense of an external call for a commonly executed, very short program,
      whose output is used only durning development or special site exposure.

      error: Similar to all the other error procedures. It records in an internal
      static structure the details of an error and then signals the
      xforum_fatal_error condition.

   known bugs:

   notes:
      85-05-20 Davids: collect_spy_data could be placed in an include file.

   END DESCRIPTION
*/

/* PARAMETERS */

/* EXTERNAL STATIC */

	dcl     forum_error_table_$invalid_trans_idx fixed bin (35) ext static;
	dcl     forum_error_table_$trans_deleted fixed bin (35) ext static;
	dcl     forum_error_table_$trans_reaped fixed bin (35) ext static;

/* ENTRIES */

	dcl     com_err_$suppress_name entry () options (variable);
	dcl     emacs_		 entry (ptr, char (*), char (*), ptr, fixed bin (35));
	dcl     expand_pathname_	 entry (char (*), char (*), char (*), fixed bin (35));
	dcl     get_pdir_		 entry () returns (char (168));
	dcl     hcs_$fs_get_path_name	 entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
	dcl     hcs_$make_ptr	 entry (ptr, char (*), char (*), ptr, fixed bin (35));
	dcl     hcs_$set_bc_seg	 entry (ptr, fixed bin (24), fixed bin (35));
	dcl     initiate_file_	 entry (char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));
	dcl     initiate_file_$create	 entry (char (*), char (*), bit (*), ptr, bit (1) aligned, fixed bin (24), fixed bin (35));
          dcl     xforum_get_str_	 entry (char(*) var, ptr, char(*), char(*), char(*) var, fixed bin(35));
	dcl     ioa_		 entry () options (variable);
	dcl     ioa_$rsnnl		 entry () options (variable);
	dcl     menu_$destroy	 entry (ptr, fixed bin (35));
	dcl     signal_		 entry () options (variable);
	dcl     timer_manager_$sleep	 entry (fixed bin (71), bit (2));
	dcl     window_$clear_window	 entry (ptr, fixed bin (35));
	dcl     xforum_format_$append	 entry (ptr, ptr, bit (1) aligned, fixed bin (24), fixed bin (35));
	dcl     xforum_format_$write	 entry (ptr, ptr, fixed bin (35));
	dcl     xforum_get_selected_trans$first entry (ptr, ptr, fixed bin (35));
	dcl     xforum_get_selected_trans$next entry (ptr, ptr, fixed bin (35));
	dcl     xforum_help_line_$change entry (bit (8) aligned, char (*), char (*), char (*));
	dcl     xforum_help_line_$pop	 entry options (variable);
	dcl     xforum_help_line_$push entry (bit (8) aligned, char (*), char (*), char (*));
	dcl     xforum_status_$redisplay entry (fixed bin (35));
	dcl     xforum_status_$update_current entry (char (*));
	dcl     xforum_status_$update_new entry (char (*));
	dcl     xforum_status_$update_title entry (char (*));
	dcl     xforum_status_$update_total entry (char (*));
	dcl     xforum_trans_$first_trans entry (ptr, fixed bin (35));
	dcl     xforum_trans_$read	 entry (fixed bin, ptr, fixed bin (35));
	dcl     xforum_user_profile$get_remove_menu_while_editing entry () returns (bit (1));
	dcl     xforum_window_mgr$check_window_status entry options (variable);
	dcl     xforum_window_mgr$resynch_windows entry (fixed bin, bit (1));

/* CONDITIONS */

	dcl     quit		 condition;

/* INTERNAL AUTOMATIC */

	dcl     xforum_meeting_info_ptr ptr;		/* pointer to meeting_info structure */
	dcl     xforum_meeting_list_ptr ptr;		/* pointer to meeting_list structure */

		         
/* INTERNAL STATIC */

	dcl     01 xamu_xforum_error_info like xforum_error_info internal static;
						/* used to record error info to be output to the user */

/* CONSTANTS */

	dcl     (
	        xamu_QUERY_USAGE	 char (69) init ("Press  ? and RETURN:help  BREAK:Do not copy comments"),
	        xamu_ME		 char (27) init ("xforum_attend_mtg_utilities"),
	        xamu_OFF		 bit (1) aligned init ("0"b),
	        xamu_ON		 bit (1) aligned init ("1"b),
	        xamu_REPLY		 bit (1) aligned init ("1"b),
	        xamu_SUBJECT	 bit (1) aligned init ("1"b)
	        )			 internal static options (constant);

/* BUILTINS */

	dcl     (
	        addr,
	        after,
	        before,
	        divide,
	        index,
	        length,
	        null,
	        rtrim,
	        string,
	        substr,
	        unspec
	        )			 builtin;

/* BASED */


/* INCLUDE FILES */

%include access_mode_values;
%page;
%include forum_dcls;
%page;
%include forum_flags;
%page;
%include forum_user_trans;
%page;
%include xforum_error_info;
%page;
%include xforum_meeting_info;
%page;
%include xforum_meeting_list;
%page;
%include xforum_spy;
%page;
%include xforum_windows;
%page;
%include xforum_prompts;

%include xforum_answers;

%include xforum_help_infos;


	call error (0, "Internal programming error - xforum_attend_mtg_utilities$xforum_attend_mtg_utilities called.");

set_up_meeting: entry (sum_xforum_meeting_list_ptr, sum_xforum_meeting_info_ptr, sum_midx, sum_subject_oriented,
	sum_fidx, sum_subject, sum_chairman_msg);

/* PARAMETERS */

	dcl     sum_xforum_meeting_list_ptr ptr;	/* (input) pointer to meeting_list structure */
	dcl     sum_xforum_meeting_info_ptr ptr;	/* (input) pointer to meeting_info structure */
	dcl     sum_midx		 fixed bin;	/* (input) index of meeting in meeting_list */
	dcl     sum_subject_oriented	 bit (1) aligned;	/* (input) "1"b => subject oriented attending menu in use */
	dcl     sum_fidx		 fixed bin;	/* (output) meeting index used by forum, 0 => meeting not opened */
	dcl     sum_subject		 char (256);	/* (output) subject of current comment chain */
	dcl     sum_chairman_msg	 char (256);	/* (output) chairs msg. "" => no message or no need to print message */

/* INTERNAL AUTOMATIC */

	dcl     sum_code		 fixed bin (35);	/* standard error code */
	dcl     sum_i		 fixed bin;	/* loop index */
	dcl     sum_old_info_still_good bit (1) aligned;	/* "1"b implies that data in meeting_info structure still valid */
	dcl     sum_seen_map_ptr	 ptr;		/* pointer to the seen_map string */
	dcl     sum_set_array_ptr	 ptr;		/* pointer to the set_array structure */

	xforum_meeting_list_ptr = sum_xforum_meeting_list_ptr;
	xforum_meeting_info_ptr = sum_xforum_meeting_info_ptr;
	sum_fidx = 0;
	sum_subject = "";
	sum_chairman_msg = "";


	if xforum_meeting_info.lidx = sum_midx & xforum_meeting_info.name = forums (sum_midx).long_name
	then sum_old_info_still_good = "1"b;
	else sum_old_info_still_good = "0"b;

	if ^sum_old_info_still_good
	then do;
	     sum_seen_map_ptr = xforum_meeting_info.seen_map_ptr; /* zero everything */
	     sum_set_array_ptr = xforum_meeting_info.set_array_ptr; /* but the seen_map_ptr */
	     unspec (xforum_meeting_info) = "0"b;	/* and the set_array_ptr */
	     xforum_meeting_info.seen_map_ptr = sum_seen_map_ptr;
	     xforum_meeting_info.set_array_ptr = sum_set_array_ptr;
	     xforum_meeting_info.name = forums (sum_midx).long_name;
	end;

	if forums (sum_midx).forum_version = 1 then
	     call forum_$open_forum (forums (sum_midx).directory,
		rtrim (forums (sum_midx).long_name) || ".control", sum_fidx, sum_code);
	else call forum_$open_forum (forums (sum_midx).directory,
		rtrim (forums (sum_midx).long_name) || ".forum", sum_fidx, sum_code);
	if sum_code ^= 0
	then do;
	     call ioa_ ("The ^a meeting^/has been deleted or renamed since your meeting list was created.",
		xforum_meeting_list.forums (sum_midx).long_name);
	     call ioa_ ("To update your meeting list exit Executive Forum^/and reinvoke it with the -force control argument.");
	     if xforum_meeting_list.forums (sum_midx).participant
	     then do;
		xforum_meeting_list.forums (sum_midx).participant = "0"b;
		no_participant = no_participant - 1;
	     end;
	     if xforum_meeting_list.forums (sum_midx).changed
	     then do;
		xforum_meeting_list.forums (sum_midx).changed = "0"b;
		no_changed = no_changed - 1;
	     end;
	     call timer_manager_$sleep (4, "11"b);
	     goto exit_set_up_meeting;
	end;

	forums (sum_midx).been_to = xamu_ON;		/* remember where you've been */

	call forum_$forum_limits (sum_fidx, ONLY_UNDELETED,
	     xforum_meeting_info.last_seen, xforum_meeting_info.first_trans,
	     xforum_meeting_info.last_trans, xforum_meeting_info.new_trans,
	     forum_flags_word, sum_code);
	if sum_code ^= 0 then do;
	     call com_err_$suppress_name (sum_code, xamu_ME,
		"Getting forum_limits for ^a.", xforum_meeting_info.name);
	     goto exit_set_up_meeting;
	end;

	if ^forums (sum_midx).participant		/* keep tables up to date      */
	then do;
	     forums (sum_midx).participant = xamu_ON;
	     forums (sum_midx).removed = xamu_OFF;
	     no_participant = no_participant + 1;
	     if xforum_meeting_info.last_seen < xforum_meeting_info.last_trans
	     then do;
		forums (sum_midx).changed = xamu_ON;
		no_changed = no_changed + 1;
	     end;
	end;

	if forums (sum_midx).forum_version = 2
	then do;
	     call forum_$get_transaction_map_idx (sum_fidx, "", xforum_meeting_info.seen_map_ptr -> seen_map_string, sum_code);
	     if sum_code ^= 0
	     then do;
		call com_err_$suppress_name (sum_code, "", "Could not get seen transaction map.");
		return;
	     end;
	     xforum_meeting_info.next_unread = -1;
	     xforum_meeting_info.unread_count = 0;
	     do sum_i = 1 to xforum_meeting_info.last_trans;
		if ^xforum_meeting_info.seen_map_ptr -> seen_map (sum_i)
		then do;
		     xforum_meeting_info.unread_count = xforum_meeting_info.unread_count + 1;
		     if xforum_meeting_info.next_unread = -1
		     then xforum_meeting_info.next_unread = sum_i;
		end;
	     end;
	end;
	else do;
	     do sum_i = 1 to xforum_meeting_info.last_seen;
		xforum_meeting_info.seen_map_ptr -> seen_map (sum_i) = "1"b;
	     end;
	     do sum_i = xforum_meeting_info.last_seen + 1 to xforum_meeting_info.last_trans;
		xforum_meeting_info.seen_map_ptr -> seen_map (sum_i) = "0"b;
	     end;
	     xforum_meeting_info.next_unread = xforum_meeting_info.last_seen + 1;
	     xforum_meeting_info.unread_count = xforum_meeting_info.last_trans - xforum_meeting_info.last_seen;
	end;

	xforum_meeting_info.lidx = sum_midx;
						/* note which one we are	      */

	xforum_meeting_info.idx = sum_fidx;

	if sum_old_info_still_good
	then do;
	     if sum_subject_oriented & string (xforum_meeting_info.flags) ^= "0"b
	     then do;
		if xforum_meeting_info.flags.all | xforum_meeting_info.flags.new
		then xforum_meeting_info.current = xforum_meeting_info.last_seen;
		else
		     if xforum_meeting_info.flags.range
		then xforum_meeting_info.current = xforum_meeting_info.high;
		else
		     if xforum_meeting_info.flags.set
		then do;
		     sum_i = xforum_meeting_info.set_array_ptr -> set_array.number;
		     xforum_meeting_info.current = xforum_meeting_info.set_array_ptr -> set_array.index (sum_i);
		end;
		else
		     if xforum_meeting_info.flags.allref
		then xforum_meeting_info.current = xforum_meeting_info.current_ref;
		unspec (xforum_meeting_info.flags) = "0"b;
	     end;
	end;
	else xforum_meeting_info.current = xforum_meeting_info.last_seen;

	if xforum_meeting_info.current = 0
	then do;
	     xforum_meeting_info.current = 1;

	     call forum_$get_message (sum_fidx, sum_chairman_msg, sum_code);
	     if sum_code ^= 0
	     then sum_chairman_msg = "";
	end;

	if xforum_meeting_info.current ^= 0
	then do;
	     call xforum_trans_$read (xforum_meeting_info.current, forum_user_trans_ptr, sum_code);
	     if sum_code ^= 0
	     then do;
		call xforum_trans_$first_trans (forum_user_trans_ptr, sum_code);
		xforum_meeting_info.current = forum_user_trans.trans_no;
	     end;

	     if sum_code = 0
	     then do;
		if forum_user_trans.subject_length <= length(sum_subject)
		then sum_subject = forum_user_trans.subject;
		else sum_subject = substr (forum_user_trans.subject, 1, length(sum_subject));
		free forum_user_trans;
	     end;
	     else do;
		call ioa_ ("A programming error has occured.^/   The comments in this meeting cannot be read.");
		call timer_manager_$sleep (4, "11"b);
		goto exit_set_up_meeting;
	     end;
	end;

exit_set_up_meeting:
	return;

copy_to_name: entry (ctn_spy_ptr, ctn_name, ctn_seg_ptr, ctn_bc);

/* PARAMETERS */

	dcl     ctn_spy_ptr		 ptr;		/* (input) pointer to the spy structure */
	dcl     ctn_name		 char (32);	/* (output) name of segment */
	dcl     ctn_seg_ptr		 ptr;		/* (output) pointer to segment */
	dcl     ctn_bc		 fixed bin (24);	/* (output) bit count of segment */

/* INTERNAL AUTOMATIC */

	dcl     ctn_code		 fixed bin (35);	/* standard error code */
	dcl     ctn_dir_name	 char (168);	/* path of the dir containing the requested seg */
	dcl     ctn_entry_name	 char (32);	/* name of the segment */
	dcl     ctn_reply		 char (200);	/* buffer for user to enter reply */
						/* extra long because we don't know what he will type */
	dcl     ctn_unused_b1	 bit (1) aligned;	/* unused output from called entry */

          dcl      reply                 char (200) var;

/* EXTERNAL ENTRY */

          dcl      error_table_$long_record	
                                         fixed bin(35) ext static;
    

	answer_array.N = 0;				/* all answers acceptable			*/
          answer_array.max_length = length(ctn_dir_name);	/* max length of file name is 168		*/

	spy_ptr = ctn_spy_ptr;
	ctn_name = "";
	ctn_seg_ptr = null ();
	ctn_bc = 0;

	call window_$clear_window (xforum_windows.bottom.iocb, (0));

	call xforum_help_line_$push ("0"b, "", "", xamu_QUERY_USAGE);

	on quit
	     begin;
		call xforum_window_mgr$check_window_status;
		call window_$clear_window (xforum_windows.bottom.iocb, (0));
		call collect_spy_data (SPY_AT_15, "QUIT");
		ctn_name = "";
		ctn_seg_ptr = null ();
		ctn_bc = 0;
		goto exit_copy_to_name;
	     end;

	ctn_code = 1;
	do while (ctn_code ^= 0);
               ctn_code = 0;
	     call xforum_get_str_ ((FILE_PROMPT), addr(answer_array), PROMPT_HELP, "file_name", reply, ctn_code);

               if ctn_code = error_table_$long_record
	     then do;
                    call ioa_ ("File name must be less than ^i characters.^/", answer_array.max_length);
		ctn_code = 1;
		end;
	     ctn_reply = substr (reply, 1, length(reply));
						/* strip off new line char */

	     if rtrim (ctn_reply) = ""
	     then do;
		call com_err_$suppress_name (0, "", "^/A file name must be entered. To return to the menu press BREAK.^/");
		ctn_code = 1;
	     end;
	     else if ctn_reply = "??"
	     then do;
		call collect_spy_data (SPY_AT_15, "??");
		call ioa_ ("A menu of all possible file names cannot be constructed.^/");
		ctn_code = 1;
	     end;
	     else do;
		call expand_pathname_ (ctn_reply, ctn_dir_name, ctn_entry_name, ctn_code);
		if ctn_code = 0
		then ctn_name = ctn_entry_name;
		else do;
		     call collect_spy_data (SPY_AT_15, "invalid");
		     call com_err_$suppress_name (ctn_code, "", "^a is not a valid file name.", ctn_reply);
		end;
	     end;
	end;

	if (index (ctn_reply, ">") > 0) | (index (ctn_reply, "<") > 0)
	then call collect_spy_data (SPY_AT_15, "pathname");
	else call collect_spy_data (SPY_AT_15, "name");

	call initiate_file_$create (ctn_dir_name, ctn_entry_name, RW_ACCESS, ctn_seg_ptr, ctn_unused_b1, ctn_bc, ctn_code);
	if ctn_code ^= 0
	then do;
	     call com_err_$suppress_name (ctn_code, xamu_ME,
		"Could not find or create the file ^a>^a.", ctn_dir_name, ctn_entry_name);
	     call timer_manager_$sleep (3, "11"b);
	     ctn_name = "";
	     ctn_seg_ptr = null ();
	     ctn_bc = 0;
	end;

exit_copy_to_name:
	call xforum_help_line_$pop;

	return;

next_unread_comment: entry (nuc_xforum_meeting_info_ptr, nuc_fidx, nuc_version, nuc_forum_user_trans_ptr);

/* PARAMETERS */

	dcl     nuc_xforum_meeting_info_ptr ptr;	/* (input) pointer to meeting_info structure */
	dcl     nuc_fidx		 fixed bin;	/* (input) index forum uses to ID meeting */
	dcl     nuc_version		 fixed bin;	/* (input) version of forum meeting */
	dcl     nuc_forum_user_trans_ptr ptr;		/* (output) pointer to next unread comment or null */

/* INTERNAL AUTOMATIC */

	dcl     nuc_code		 fixed bin (35);	/* standard error code */
	dcl     nuc_found		 bit (1);		/* "1" imples that an unread comment was found */
	dcl     nuc_i		 fixed bin;	/* loop index */
	dcl     nuc_old_current	 fixed bin;	/* IDs the current comment before the search begins */
	dcl     nuc_old_flags	 bit (6) unaligned; /* IDs the current comment before the search begins */

	xforum_meeting_info_ptr = nuc_xforum_meeting_info_ptr;
	nuc_forum_user_trans_ptr = null ();
	nuc_found = "0"b;
	nuc_old_current = xforum_meeting_info.current;
	nuc_old_flags = string (xforum_meeting_info.flags);

	on quit
	     begin;
		xforum_meeting_info.current = nuc_old_current;
		unspec (xforum_meeting_info.flags) = nuc_old_flags;
		call xforum_get_selected_trans$first (xforum_meeting_info_ptr, forum_user_trans_ptr, nuc_code);
		if nuc_code = 0
		then nuc_forum_user_trans_ptr = forum_user_trans_ptr;
		else nuc_forum_user_trans_ptr = null ();
		goto exit_next_unread_comment;
	     end;

	do while (xforum_meeting_info.next_unread ^= -1 & ^nuc_found);
	     xforum_meeting_info.current = xforum_meeting_info.next_unread;

	     call xforum_trans_$read (xforum_meeting_info.current, forum_user_trans_ptr, nuc_code);
	     if nuc_code = forum_error_table_$trans_deleted |
		nuc_code = forum_error_table_$trans_reaped
	     then do;
		xforum_meeting_info.seen_map_ptr -> seen_map (xforum_meeting_info.current) = "1"b;
		xforum_meeting_info.unread_count = xforum_meeting_info.unread_count - 1;
		if nuc_version = 2
		then call forum_$set_seen_switch (nuc_fidx, "", xforum_meeting_info.current, xamu_ON, nuc_code);
		xforum_meeting_info.next_unread = -1;
		do nuc_i = xforum_meeting_info.current + 1 to xforum_meeting_info.last_trans while (xforum_meeting_info.next_unread = -1);
		     if ^xforum_meeting_info.seen_map_ptr -> seen_map (nuc_i)
		     then xforum_meeting_info.next_unread = nuc_i;
		end;
	     end;
	     else
		if nuc_code ^= 0
	     then do;
		call ioa_ ("Comment #^i has not yet been read but cannot be obtained,", xforum_meeting_info.current);
		call ioa_ ("will find the next unread comment.");
		call timer_manager_$sleep (3, "11"b);
		xforum_meeting_info.next_unread = -1;
		do nuc_i = xforum_meeting_info.current + 1 to xforum_meeting_info.last_trans while (xforum_meeting_info.next_unread = -1);
		     if ^xforum_meeting_info.seen_map_ptr -> seen_map (nuc_i)
		     then xforum_meeting_info.next_unread = nuc_i;
		end;
	     end;
	     else nuc_found = "1"b;			/* get out of the loop */
	end;

	if nuc_found
	then nuc_forum_user_trans_ptr = forum_user_trans_ptr;

exit_next_unread_comment:
	return;

update_status: entry (us_xforum_meeting_info_ptr, us_trans_no, us_subject, us_version, us_fidx);

/* PARAMETERS */

	dcl     us_xforum_meeting_info_ptr ptr;		/* (input) pointer to meeting_info structure */
	dcl     us_trans_no		 fixed bin;	/* (input) index of current comment, 0 implies no current comment */
	dcl     us_subject		 char (*);	/* (input) subject of current comment, used for subject oriented menu */
	dcl     us_version		 fixed bin;	/* (input) version of forum meeting */
	dcl     us_fidx		 fixed bin;	/* (input) index forum uses to ID meeting */

/* INTERNAL AUTOMATIC */

	dcl     us_code		 fixed bin (35);	/* standard error code */
	dcl     us_current_text	 char (80);	/* middle part of second line of status window for attending menu */
	dcl     us_i		 fixed bin;	/* loop index */
	dcl     us_last_trans	 fixed bin;	/* index of last comment in meeting */
	dcl     us_new_text		 char (12);	/* last part of second line of status window for attending menu */
	dcl     us_total_text	 char (11);	/* first part of second line of status window for attending menu */
	dcl     us_unused_b36	 bit (36) aligned;	/* unused output from system call */

	xforum_meeting_info_ptr = us_xforum_meeting_info_ptr;

	if us_trans_no ^= 0
	then do;
	     if us_version = 2
	     then call forum_$set_seen_switch (us_fidx, "", us_trans_no, xamu_ON, us_code);

	     if (us_version = 1) & (us_trans_no > xforum_meeting_info.last_seen)
	     then call forum_$set_last_seen_idx (us_fidx, us_trans_no, xamu_ON, us_code);

	     if ^xforum_meeting_info.seen_map_ptr -> seen_map (us_trans_no)
	     then do;
		xforum_meeting_info.seen_map_ptr -> seen_map (us_trans_no) = "1"b;
		xforum_meeting_info.unread_count = xforum_meeting_info.unread_count - 1;
		if xforum_meeting_info.next_unread = us_trans_no
		then do;
		     xforum_meeting_info.next_unread = -1;
		     do us_i = us_trans_no + 1 to xforum_meeting_info.last_trans while (xforum_meeting_info.next_unread = -1);
			if ^xforum_meeting_info.seen_map_ptr -> seen_map (us_i)
			then xforum_meeting_info.next_unread = us_i;
		     end;
		end;
	     end;
	end;

	call forum_$forum_limits (us_fidx, ONLY_UNDELETED,
	     xforum_meeting_info.last_seen,
	     xforum_meeting_info.first_trans,
	     us_last_trans,
	     xforum_meeting_info.new_trans, us_unused_b36, us_code);

	if us_last_trans > xforum_meeting_info.last_trans
	then do;
	     do us_i = xforum_meeting_info.last_trans + 1 to us_last_trans;
		xforum_meeting_info.seen_map_ptr -> seen_map (us_i) = "0"b;
		xforum_meeting_info.unread_count = xforum_meeting_info.unread_count + 1;
	     end;
	     if xforum_meeting_info.next_unread = -1
	     then xforum_meeting_info.next_unread = xforum_meeting_info.last_trans + 1;
	     xforum_meeting_info.last_trans = us_last_trans;
	end;

	call ioa_$rsnnl ("Total: ^d", us_total_text, (0), xforum_meeting_info.last_trans);

	call ioa_$rsnnl ("Unread: ^d", us_new_text, (0), xforum_meeting_info.unread_count);

	if us_subject ^= ""
	then do;
	     if index (us_subject, "Re: ") ^= 1
	     then call ioa_$rsnnl ("Current Subject: ^a", us_current_text, (0), us_subject);
	     else call ioa_$rsnnl ("Current Subject: ^a", us_current_text, (0), substr (us_subject, 5));
	end;
	else do;
	     if xforum_meeting_info.flags.set
	     then us_current_text = "Current comment(s): " || set_array.spec;
	     else call ioa_$rsnnl (
		     "Current comment(s): ^[^[all^]^[aref^]^[new^]^[^d:^d^s^]^;^s^s^s^s^s^s^d^]",
		     us_current_text, (0),
		     unspec (xforum_meeting_info.flags ^= "0"b),
		     xforum_meeting_info.flags.all,
		     xforum_meeting_info.flags.allref,
		     xforum_meeting_info.flags.new,
		     xforum_meeting_info.flags.range, xforum_meeting_info.low,
		     xforum_meeting_info.high, xforum_meeting_info.current);
	end;


	call xforum_help_line_$change ("10110000"b, "Leave Meeting", "", "");
	call xforum_status_$update_total (us_total_text);
	call xforum_status_$update_new (us_new_text);
	call xforum_status_$update_current (us_current_text);
	call xforum_status_$redisplay ((0));

	return;

close_meeting: entry (cm_xforum_meeting_info_ptr, cm_xforum_meeting_list_ptr, cm_midx, cm_fidx, cm_menu_ptr);

/* PARAMETERS */

	dcl     cm_xforum_meeting_info_ptr ptr;		/* (input) pointer to meeting_info structure */
	dcl     cm_xforum_meeting_list_ptr ptr;		/* (input) pointer to meeting_list structure */
	dcl     cm_midx		 fixed bin;	/* (index) index of meeting in the meeting list */
	dcl     cm_fidx		 fixed bin;	/* (index) index forum uses to ID meeting */
	dcl     cm_menu_ptr		 ptr;		/* (input) pointer to the attend meeting menu */






	xforum_meeting_info_ptr = cm_xforum_meeting_info_ptr;
	xforum_meeting_list_ptr = cm_xforum_meeting_list_ptr;


	call forum_$close_forum (cm_fidx, (0));

	if forums (cm_midx).changed
	then if xforum_meeting_info.new_trans = 0
	     then do;
		forums (cm_midx).changed = xamu_OFF;
		no_changed = no_changed - 1;
	     end;

	if cm_menu_ptr ^= null
	then call menu_$destroy (cm_menu_ptr, (0));

	cm_fidx = -1;
	cm_menu_ptr = null ();

	return;

enter_trans: entry (et_xforum_meeting_info_ptr, et_fidx, et_spy_ptr, et_flavour, et_attend_mtg_type);

/* PARAMETERS */

	dcl     et_xforum_meeting_info_ptr ptr;		/* (input) pointer to meeting_info structure */
	dcl     et_fidx		 fixed bin;	/* (index) index forum uses to ID meeting */
	dcl     et_flavour		 bit (1) aligned;	/* (input) "1"b impl;ies reply mode, "0"b is talk mode */
	dcl     et_spy_ptr		 ptr;		/* (input) /* (input) pointer to spy structure */
	dcl     et_attend_mtg_type	 bit (1) aligned;	/* (input) "1"b implies subject oriented meeting attendance, */
						/* "0"b implies entry order attendance */

/* INTERNAL AUTOMATIC */

	dcl     et_bc		 fixed bin (24);	/* bit count of segment containing the just entered comment */
	dcl     et_chairman_msg	 char (256);	/* chairman msg for the mtg */
	dcl     et_chars		 fixed bin (24);	/* number of chars in just entered comments */
	dcl     et_code		 fixed bin (35);	/* standard error code */
	dcl     et_emacs_flavour	 char (40);	/* tells emacs extension what to do either */
						/* talk, reply, if subject oriented includes current comment index */
	dcl     et_i		 fixed bin;	/* loop index */
	dcl     et_my_label		 label;		/* needed to determine referencing dir for emacs extension */
	dcl     et_prefix_len	 fixed bin;	/* length of text string preceeding the subject in the just entered comment */
	dcl     et_reply_no		 fixed bin;	/* index of comment being replied to */
	dcl     et_temp_line	 char (80);	/* first line of status window when editing a reply */
	dcl     et_seg		 char (et_chars) based (et_trans.trans_seg_ptr); /* just entered comment */
	dcl     et_sj		 char (500) varying;/* subject of just enetered comment */
	dcl     et_str		 char (510) varying;/* subject of just enetered comment */
						/* plus the "Subject: " string and a terminating ESC character */
	dcl     et_subj_len		 fixed bin;	/* length of the subject */
	dcl     et_trans_num	 fixed bin;	/* index of just eneterd comment */
	dcl     et_txt_len		 fixed bin;	/* length of actual comment, i.e. no subject, prefix or ESC */
	dcl     et_unusedb1		 bit (1) aligned;	/* unused output from system call */
	dcl     et_unusedfb24	 fixed bin (24);	/* unused output from system call */
	dcl     et_view_seg_bc	 fixed bin (24);	/* bit count of segment containing comment(s) being replied to */

	dcl     1 et_my_overlay	 based (addr (et_my_label)), /* used too get referencing dir for emacs extension */
		2 my_addr		 ptr,		/* segment i'm part of */
		2 my_stack	 ptr;		/* my stack frame */

	dcl     1 et_trans_seg	 based (et_trans.trans_seg_ptr), /* structure of segment containing just entered comment */
		2 prefix		 char (et_prefix_len) unal, /* the string "Subject:" */
		2 subj		 char (et_subj_len) unal, /* the text of the subject */
		2 esc_char	 char (1) unal,	/* ESC char terminates subject text */
		2 new_line	 char (1) unal,	/* new line char */
		2 txt		 char (et_txt_len) unal; /* text of comment */

/* INTERNAL STATIC */

	dcl     01 et_trans		 internal static,	/* need to get these only once per process */
		02 process_dir	 char (168),	/* process dir path */
		02 ext_dir	 char (168),	/* dir containing emacs extension */
		02 ext_seg	 char (32),	/* name of emacs extebsion */
		02 ext_ptr	 ptr,		/* pointer to emacs extension */
		02 have_trans_seg	 bit (1) unaligned init ("0"b), /* "1"b implies we have a segment to put new comments in */
		02 have_view_seg	 bit (1) unaligned init ("0"b), /* "1"b implies we have a segment to copy comment(s) being replied intgo */
		02 trans_seg_ptr	 ptr,		/* pointer to seg to put just created comment into */
		02 view_seg_ptr	 ptr;		/* pointer to put comment(s) being replied into */


/* CONSTANTS */

	dcl     et_ESC		 char (1) init ("") internal static options (constant);
						/* escape character 33 octal used to terminate subject */
          dcl     MAX_SUBJECT_LENGTH     fixed bin internal static options (constant) init (256);
	


	spy_ptr = et_spy_ptr;
	xforum_meeting_info_ptr = et_xforum_meeting_info_ptr;

	on quit
	     begin;
		call xforum_window_mgr$check_window_status;
		call window_$clear_window (xforum_windows.bottom.iocb, (0));
		call ioa_ ("Comment not entered.");
		call timer_manager_$sleep (3, "11"b);
		goto exit_enter_trans;
	     end;

	if et_flavour = xamu_REPLY
	then do;
	     call xforum_trans_$read (xforum_meeting_info.current,
		forum_user_trans_ptr, et_code);
	     if et_code ^= 0
	     then do;
		call com_err_$suppress_name (et_code, xamu_ME, "Could not read the comment you want to reply to.");
		call timer_manager_$sleep (3, "11"b);
		goto exit_enter_trans;
	     end;
	     if et_attend_mtg_type = xamu_SUBJECT
	     then call ioa_$rsnnl ("Replying on subject ^a in the ^a meeting", et_temp_line, (0),
		     forum_user_trans.subject, xforum_meeting_info.name);
	     else call ioa_$rsnnl ("Replying to comment no. ^d in the ^a meeting", et_temp_line, (0),
		     forum_user_trans.trans_no, xforum_meeting_info.name);
	     call xforum_status_$update_title (et_temp_line);
	     call xforum_status_$redisplay ((0));
	     call xforum_window_mgr$resynch_windows (-1, "1"b);
	     if et_attend_mtg_type = xamu_SUBJECT
	     then et_temp_line = "       ESCl:previous page of comments  ESCh:next page of comments";
	     else call ioa_$rsnnl ("       ESCl:previous page of comment ^d  ESCh:next page of comment ^d",
		     et_temp_line, (0), forum_user_trans.trans_no, forum_user_trans.trans_no);
	     call xforum_help_line_$change ("0"b, "", "", et_temp_line);
	     if et_attend_mtg_type = xamu_SUBJECT
	     then free forum_user_trans;
	end;
	else call xforum_help_line_$change ("0"b, "", "", "Press  RETURN:enter subject  BREAK:abort entry");

	if xforum_user_profile$get_remove_menu_while_editing () & et_flavour ^= xamu_REPLY
	then do;
	     call ioa_$rsnnl ("Entering a new comment in the ^a meeting",
		et_temp_line, (0), xforum_meeting_info.name);
	     call xforum_status_$update_title (et_temp_line);
	     call xforum_status_$redisplay ((0));
	     call xforum_window_mgr$resynch_windows (-1, "1"b);
	end;


	call window_$clear_window (xforum_windows.bottom.iocb, (0));
	call ioa_ ("Please wait for editor...");

	if et_flavour = xamu_REPLY & xforum_meeting_info.current = 0 then do;
	     call com_err_$suppress_name (0, xamu_ME, "Invalid current comment specifier for replying to.");
	     call timer_manager_$sleep (3, "11"b);
	     goto exit_enter_trans;
	end;


	if ^et_trans.have_trans_seg then do;
	     call initiate_file_$create (get_pdir_ (), "xforum.trans", RW_ACCESS,
		et_trans.trans_seg_ptr, et_unusedb1, et_unusedfb24, et_code);
	     if et_trans.trans_seg_ptr = null then do;
		call com_err_$suppress_name (et_code, xamu_ME, "Cannot get temp segment for comment.");
		call timer_manager_$sleep (3, "11"b);
		goto exit_enter_trans;
	     end;

	     et_trans.ext_seg = "xforum_emacs_ext_";
	     et_my_label = here;
here:
	     call hcs_$make_ptr (et_my_overlay.my_addr, et_trans.ext_seg, "symbol_table",
		et_trans.ext_ptr, et_code);
	     if et_code ^= 0 then do;
		call com_err_$suppress_name (et_code, xamu_ME, "Trying to load emacs extensions.");
		call timer_manager_$sleep (3, "11"b);
		goto exit_enter_trans;
	     end;

	     call hcs_$fs_get_path_name (et_trans.ext_ptr, et_trans.ext_dir, (0),
		(et_trans.ext_seg), et_code);
	     if et_code ^= 0 then do;
		call com_err_$suppress_name (et_code, xamu_ME, "Trying to load emacs extensions.");
		call timer_manager_$sleep (3, "11"b);
		goto exit_enter_trans;
	     end;

	     et_trans.have_trans_seg = xamu_ON;
	     et_trans.process_dir = get_pdir_ ();
	end;

	if et_flavour = xamu_REPLY & ^et_trans.have_view_seg then do;
	     call initiate_file_$create (get_pdir_ (), "xforum_view_seg", RW_ACCESS,
		et_trans.view_seg_ptr, et_unusedb1, et_unusedfb24, et_code);
	     if et_trans.view_seg_ptr = null then do;
		call com_err_$suppress_name (et_code, xamu_ME, "Cannot get temp segment for comment.");
		call timer_manager_$sleep (3, "11"b);
		goto exit_enter_trans;
	     end;

	     et_trans.have_view_seg = xamu_ON;
	end;

	call hcs_$set_bc_seg (et_trans.trans_seg_ptr, 0, (0));

	if et_flavour = xamu_REPLY
	then do;
	     if et_attend_mtg_type = xamu_SUBJECT
	     then do;
		call ioa_$rsnnl ("reply_by_subject                [^i]", et_emacs_flavour, (0), xforum_meeting_info.current);
		et_view_seg_bc = 0;
		xforum_meeting_info.flags.allref = "1"b;
		xforum_meeting_info.current_ref = xforum_meeting_info.current;
		call xforum_get_selected_trans$first (xforum_meeting_info_ptr, forum_user_trans_ptr, et_code);
		do while (et_code ^= forum_error_table_$invalid_trans_idx);
		     if et_code = 0
		     then do;
			call xforum_format_$append (forum_user_trans_ptr, et_trans.view_seg_ptr, "1"b, et_view_seg_bc, et_code);
			call xforum_get_selected_trans$next (xforum_meeting_info_ptr, forum_user_trans_ptr, et_code);
		     end;
		end;
		xforum_meeting_info.flags.allref = "0"b;
	     end;
	     else do;
		et_emacs_flavour = "reply";
		call xforum_format_$write (forum_user_trans_ptr,
		     et_trans.view_seg_ptr, et_code);
	     end;
	end;
	else et_emacs_flavour = "talk";

	if (et_flavour = xamu_REPLY) then do;
	     call forum_$get_message (et_fidx, et_chairman_msg, et_code);
	     if et_code = 0
	     then call ioa_ (rtrim (et_chairman_msg));
	end;

	call emacs_ (xforum_windows.bottom.iocb,
	     rtrim (et_trans.process_dir) || ">xforum.trans",
	     rtrim (et_trans.ext_dir) || ">" || rtrim (et_trans.ext_seg),
	     addr (et_emacs_flavour), et_code);
	if et_code ^= 0 then do;
	     if et_flavour = xamu_REPLY
	     then call collect_spy_data (SPY_AT_8, "QUIT");
	     else call collect_spy_data (SPY_AT_9, "QUIT");
	     call ioa_ ("Comment not entered.");
	     call timer_manager_$sleep (3, "11"b);
	     et_code = 0;
	     goto exit_enter_trans;
	end;

	call initiate_file_ (et_trans.process_dir, "xforum.trans", RW_ACCESS,
	     et_trans.trans_seg_ptr, et_bc, et_code);
						/* get bit count		      */
	if et_trans.trans_seg_ptr = null
	then do;
	     et_trans.have_trans_seg = xamu_OFF;
	     call com_err_$suppress_name (et_code, xamu_ME, "Getting bit count of comment.");
	     call timer_manager_$sleep (3, "11"b);
	     goto exit_enter_trans;
	end;

	if et_bc = 0 then do;
	     call com_err_$suppress_name (0, xamu_ME, "No data in comment.");
	     call timer_manager_$sleep (3, "11"b);
	     goto exit_enter_trans;
	end;

	et_chars = divide (et_bc, 9, 17, 0);

	et_str = before (et_seg, et_ESC);

	if substr (et_str, 1, 9) ^= "Subject: " then do;
	     call com_err_$suppress_name (0, xamu_ME, "No subject in comment.");
	     call timer_manager_$sleep (3, "11"b);
	     goto exit_enter_trans;
	end;

	et_sj = after (et_str, "Subject: ");
	et_prefix_len = 9;

	et_subj_len = length (et_sj);

          if et_subj_len > MAX_SUBJECT_LENGTH then do;
	      call com_err_$suppress_name (0, xamu_ME, "Max subject length (256 chars) exceeded.");
	      call timer_manager_$sleep (3, "11"b);
                goto exit_enter_trans;
	end;

	et_txt_len = et_chars - (et_prefix_len + et_subj_len + 2);

	if et_flavour = xamu_REPLY
	then et_reply_no = xforum_meeting_info.current;
	else et_reply_no = 0;

	call forum_$enter_trans (xforum_meeting_info.idx, et_trans_seg.txt,
	     et_reply_no, et_trans_seg.subj, xamu_OFF, et_trans_num, et_code);
	if et_code ^= 0 then do;
	     call com_err_$suppress_name (et_code, xamu_ME, "Trying to enter comment.");
	     call timer_manager_$sleep (3, "11"b);
	     goto exit_enter_trans;
	end;

	if et_trans_num > xforum_meeting_info.last_trans + 1
	then do;
	     do et_i = xforum_meeting_info.last_trans + 1 to et_trans_num - 1;
		xforum_meeting_info.seen_map_ptr -> seen_map (et_i) = "0"b;
		xforum_meeting_info.unread_count = xforum_meeting_info.unread_count + 1;
	     end;
	     if xforum_meeting_info.next_unread = -1
	     then xforum_meeting_info.next_unread = xforum_meeting_info.last_trans + 1;
	end;

	xforum_meeting_info.seen_map_ptr -> seen_map (et_trans_num) = "1"b;
	xforum_meeting_info.last_trans = et_trans_num;

	call ioa_ ("Comment ^d entered into the ^a meeting.", et_trans_num,
	     xforum_meeting_info.name);
	call timer_manager_$sleep (3, "11"b);

exit_enter_trans:
	return;

collect_spy_data: proc (csd_where, csd_response);

/* PARAMETERS */

	dcl     csd_where		 fixed bin;	/* (input) location response was collected */
	dcl     csd_response	 char (*);	/* (input) user's response */





	spy.count = spy.count + 1;
	spy.choices (count).at = csd_where;
	spy.choices (count).choice = csd_response;

	return;

     end collect_spy_data;

error: proc (e_code, e_message);

/* PARAMETERS */

	dcl     e_code		 fixed bin (35);	/* (input) error code associated with the error */
	dcl     e_message		 char (*);	/* (input) message to be output to user */





	xamu_xforum_error_info.name = xamu_ME;
	xamu_xforum_error_info.entry = "";
	xamu_xforum_error_info.doing = "";
	xamu_xforum_error_info.code = e_code;
	xamu_xforum_error_info.reason = e_message;

	call signal_ ("xforum_fatal_error", null (), addr (xamu_xforum_error_info), null ());

     end error;

     end xforum_attend_mtg_utilities;
