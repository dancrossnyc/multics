/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(86-01-09,Herbst), approve(86-03-25,MCR7367),
     audit(86-04-28,Margolin), install(86-05-22,MR12.0-1059):
     Changed to process the keywords "seen", "unseen", and "new".
  2) change(86-03-04,Herbst), approve(86-03-25,MCR7367),
     audit(86-04-28,Margolin), install(86-05-22,MR12.0-1059):
     Added keywords (first last previous next)_(seen unseen).
  3) change(86-03-05,Herbst), approve(86-03-25,MCR7367),
     audit(86-04-28,Margolin), install(86-05-22,MR12.0-1059):
     Added entry points first_request, last_request, all_request,
     current_request, seen_request, new_request, etc. Also brought
     over other requests from obsolete rdm_active_requests_.
  4) change(86-03-07,Herbst), approve(86-03-25,MCR7367),
     audit(86-04-28,Margolin), install(86-05-22,MR12.0-1059):
     Replaced emf_et_$empty_range with emf_et_$no_messages_selected.
  5) change(86-04-01,Herbst), approve(86-04-01,MCR7367),
     audit(86-04-28,Margolin), install(86-05-22,MR12.0-1059):
     Moved bulk of message spec requests to rdm_msg_requests.
  6) change(86-04-04,Herbst), approve(86-04-04,MCR7367),
     audit(86-04-28,Margolin), install(86-05-22,MR12.0-1059):
     Fixed unitialized code bug processing "new" keyword when no new messages
     and the last message is an interactive one.
  7) change(86-04-28,Herbst), approve(86-04-28,MCR7367),
     audit(86-04-28,Margolin), install(86-05-22,MR12.0-1059):
     Deleted unused declarations.
  8) change(86-08-06,Margolin), approve(86-08-06,MCR7508),
     audit(86-08-27,Blair), install(86-08-29,MR12.0-1142):
     Pass the error code up to the calling program when no messages are
     selected.  Fixes error_list #500 (TRs 20435 20438).  Also, now it
     doesn't set P_code if entered via the do_request entrypoint.
  9) change(89-04-07,Lee), approve(89-05-10,MCR8104),
     audit(89-07-18,LZimmerman), install(89-10-02,MR12.3-1079):
     phx19099, phx15783, Mail 457 - added parameter P_msg_type to
     "mark_current_message" entry so that usage of "-odl" for the current
     message can be caught - the current message should never be a deleted
     message; reformatting.
                                                   END HISTORY COMMENTS */


/* format: off */

/* read_mail Message Mark Management -- responsible for manipulating the marked and marked_as_original message chains and
   for processing message specifiers (ie: parsing a specifier and then marking those messages which it selects) */

/* Created:  31 December 1979 by W. Olin Sibert out of parse_msg_spec_, construct_msg_spec_, and rdm_msg_spec_ */
/* Modified: 1 June 1980 by G. Palter to add entries to manipulate the "reply" chain */
/* Modified: 17 December 1982 by G. Palter to fix the following errors on the mail_system error list:
      #0260, #0382, #0383: Use of binary operators (:+-&|) without a first operand are not diagnosed as invalid;
      #0300: The logical operators (&|) do not work */
/* Modified: September 1983 by G. Palter to rename to rdm_message_mark_mgr_, rename the check_msg_spec entrypoint to
      validate_message_specifier, rename the clear entrypoint to clear_marked_messages, make validate_message_specifier
      only check syntax, and convert to the new mail system interface */

/* format: on,style4,delnl,insnl,ifthenstmt,ifthen */


rdm_message_mark_mgr_:
     procedure ();

	return;					/* not an entrypoint */


/* Parameters */

dcl  (P_rdm_invocation_ptr, P_sci_ptr) pointer parameter;

dcl  P_msg_spec_ptr pointer parameter;			/* -> message_specifier to parse and (maybe) process */
dcl  P_msg_spec_lth fixed binary (21) parameter;		/* ... length of said specifier */

dcl  P_msg_type fixed binary parameter;			/* types of messages to select: all, delete, non-deleted */

dcl  P_flags bit (*) parameter;

dcl  P_keyword_number fixed binary parameter;
dcl  P_reverse_sw bit (1) aligned parameter;

dcl  P_code fixed binary (35) parameter;


/* Local copies of parameters */

dcl  msg_spec_str character (msg_spec_lth) unaligned based (msg_spec_str_ptr);
dcl  msg_spec_lth fixed binary (21);
dcl  msg_spec_str_ptr pointer;

dcl  msg_type fixed binary;
dcl  code fixed binary (35);

/* Information for requests/active requests */

dcl  request_entry_sw bit (1) aligned init ("0"b);

/* The individual tokens comprising a message specifier */

dcl  1 token aligned based (tp),
       2 type fixed binary,				/* number, keyword, all, regexp, etc. */
       2 value fixed binary (35),			/* numeric value if a number */
       2 operator fixed binary,			/* type of operation for arithmetic and logical operators */
       2 str_ptr pointer,				/* -> regular expression */
       2 str_lth fixed binary (21);			/* ... length of the regular expression */

dcl  1 token_array (32) aligned like token automatic;	/* the actual tokens */

dcl  tp pointer;
dcl  (n_tokens, max_tokens) fixed binary;


/* The internal representation of a message_specifier */

dcl  1 msg_spec aligned based (msg_spec_ptr),
       2 range_info,
         3 first fixed binary,			/* # of first message in range */
         3 last fixed binary,				/* # of last message in range */
         3 single_message bit (1) aligned,		/* ON => a single message is selected */
       2 switches,
         3 seen_only_sw bit (1) unaligned,		/* ON => processing "seen" keyword */
         3 unseen_only_sw bit (1) unaligned,		/* ON => processing "unseen" keyword */
         3 pad bit (34) unaligned,
       2 string_info,
         3 search_start fixed binary,			/* index in typed-chain of first msg to search for regexp */
         3 search_direction fixed binary,		/* direction to perform the search */
         3 all_matches bit (1) aligned,			/* ON => select all messages that match */
         3 strings (msg_spec_n_strings),		/* the regular expressions to match */
	 4 regexp_ptr pointer,			/* ... reserved */
	 4 str_ptr pointer,				/* ... -> the regular expression */
	 4 str_len fixed binary (21),			/* ... length of the regular expression */
	 4 complement bit (1) aligned,		/* ... ON => complement the sense of this regexp */
	 4 operator fixed binary;			/* ... logical operator between this and previous regexps */

dcl  msg_spec_ptr pointer;
dcl  msg_spec_n_strings fixed binary;

/* format: off */
dcl (SEARCH_FORWARD		initial (1),		/* ascending order */
     SEARCH_BACKWARD	initial (2),		/* descending order */
     DONT_SEARCH		initial (3),		/* don't */
     SEARCH_SEEN		initial (4),		/* only seen messages */
     SEARCH_UNSEEN		initial (5))		/* only unseen messages */
	fixed binary static options (constant);
/* format: on */


/* Remaining declarations */

dcl  (first_msg_number, last_msg_number, current_msg_number, prev_msg_number, next_msg_number) fixed binary;
dcl  (first_msg_idx, last_msg_idx, current_msg_idx, prev_msg_idx, next_msg_idx, message_idx) fixed binary;

dcl  (keyword_count, number_count, range_count, regexp_count) fixed binary;

dcl  (report_errors_sw, reset_marked_as_original, reverse) bit (1) aligned initial ("0"b);

dcl  NULL_STRING character (1) static options (constant) initial (" ");

dcl  REGEXP_DELIM character (1) static options (constant) initial ("/");
dcl  REGEXP_CONCEAL character (2) static options (constant) initial ("\c");

dcl  DIGITS character (10) static options (constant) initial ("0123456789");
dcl  LETTERS character (54) static options (constant) initial ("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ._");

/* format: off */
dcl (UC_ALPHA	initial ("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
     LC_ALPHA	initial ("abcdefghijklmnopqrstuvwxyz"))
	character (26) static options (constant);

dcl (emf_et_$msg_spec_bad_expr, emf_et_$msg_spec_bad_keyword, emf_et_$msg_spec_bad_number,
     emf_et_$msg_spec_bad_oper, emf_et_$msg_spec_bad_range, emf_et_$msg_spec_bad_regexp, emf_et_$msg_spec_invalid,
     emf_et_$msg_spec_missing_delim, emf_et_$msg_spec_mixed, emf_et_$msg_spec_null, emf_et_$msg_spec_too_complex,
     emf_et_$no_current_message, emf_et_$no_matching_messages, emf_et_$no_messages_selected,
     emf_et_$no_messages, emf_et_$no_next_message,
     emf_et_$no_previous_message, emf_et_$no_such_message, error_table_$nomatch)
	fixed binary (35) external;

/* format: on */

dcl  cu_$grow_stack_frame entry (fixed binary (19), pointer, fixed binary (35));
dcl  rdm_mailbox_interface_$read_message entry (pointer, fixed binary, pointer, fixed binary (35));
dcl  rdm_search_utils_$search_message_with_regexp entry (pointer, fixed binary, pointer, fixed binary (21))
	returns (bit (1) aligned);
dcl  search_file_$silent
	entry (pointer, fixed binary (21), fixed binary (21), pointer, fixed binary (21), fixed binary (21),
	fixed binary (21), fixed binary (21), fixed binary (35));
dcl  ssu_$abort_line entry () options (variable);

dcl  (addr, addrel, currentsize, fixed, hbound, index, length) builtin;
dcl  (min, null, substr, translate, unspec, verify) builtin;
%page;
/* format: off */

/* Defined token types */

dcl (FIRST_TYPE		initial  (1),		/* first token (a placeholder) */
     NUMBER_TYPE		initial  (2),		/* a number */
     KEYWORD_TYPE		initial  (3),		/* a keyword other than "all" */
     ALL_KEYWORD_TYPE	initial  (4),		/* the keyword "all" */
     REGEXP_TYPE		initial  (5),		/* a regular expression */
     RANGE_OPERATOR_TYPE	initial  (6),		/* the range delimiter (:) */
     NUMBER_OPERATOR_TYPE	initial  (7),		/* an aritmetic operator (+ -) */
     REGEXP_OPERATOR_TYPE	initial  (8),		/* a logical connector (& |) */
     COMPLEMENT_OPERATOR_TYPE initial  (9),		/* logical complement (^) */
     LAST_TYPE		initial (10))		/* last token (a placeholder) */
	fixed binary static options (constant);


/* Defined operator types */

dcl (NO_OPERATOR		initial (-1),		/* no operator */
     COLON_OPERATOR		initial  (1),		/* range delimiter */
     PLUS_OPERATOR		initial  (2),		/* addition (numeric) */
     MINUS_OPERATOR		initial  (3),		/* subtraction (numeric) */
     AND_OPERATOR		initial  (4),		/* logical and */
     OR_OPERATOR		initial  (5),		/* logical or */
     COMPLEMENT_OPERATOR	initial  (6))		/* logical complement */
	fixed binary static options (constant);

dcl  OPERATORS character (6) static options (constant) initial (":+-&|^");

dcl  OPERATOR_TYPES (6) fixed binary static options (constant) initial (
	6 /* : */,	7 /* + */,	7 /* - */,
	8 /* & */,	8 /* | */,	9 /* ^ */);


/* Syntax table: defines the valid syntax of a message_specifier by defining which tokens can appear sequentially within
   the specifier */

dcl  SYNTAX_TABLE (10, 10) fixed binary static options (constant) initial (

	 /* FIRST   NUM    KWD  "all"  REGXP	":"   "+-"   "|&"	 "^"  LAST */
/* FIRST	 */   99,  000,   000,   000,   000,	 7,     2,     2,	000,    1,
/* NUM	 */   99,   99,	6,     2,     4,   000,   000,     4,	  2,  000,
/* KEYWORD */   99,    2,    99,    99,   000,   000,   000,     4,	000,  000,
/* "all"	 */   99,    2,    99,    99,   000,	 7,     3,     3,	000,  000,
/* REGEXP  */   99,    4,	5,     5,     5,	 4,     4,   000,	  3,  000,
/* ":"	 */   99,  000,   000,     7,     4,	 7,     7,     7,	  7,    7,
/* "+-"	 */   99,  000,   000,     3,     4,	 7,     2,     4,	  4,    2,
/* "&|"	 */   99,    4,	5,     5,   000,	 7,     4,     2,	000,    2,
/* "^"	 */   99,    4,	5,     5,   000,	 7,     4,     2,	  2,    2,
/* LAST	 */   99,   99,    99,    99,    99,	99,    99,    99,	 99,   99);

dcl (VALID_STATE		initial  (0),		/* these tokens may be consecutive */
     EMPTY_MSG_SPEC_STATE	initial  (1),		/* empty message_specifier */
     BAD_EXPR_STATE		initial  (2),		/* syntax error in an expression */
     BAD_OPER_STATE		initial  (3),		/* invalid use of an operator */
     MIXED_EXPR_STATE	initial  (4),		/* mixed ranges and regular expressions */
     BAD_REGEXP_STATE	initial  (5),		/* invalid position for a regular expression */
     INVALID_SPEC_STATE	initial  (6),		/* invalid syntax */
     BAD_RANGE_STATE	initial  (7),		/* invalid syntax in a range */
     CANT_HAPPEN_STATE	initial (99))		/* can't happen, but */
	fixed binary static options (constant);
/* format: on */
%page;
/* Mark all messages specified by the supplied message_specifier */

mark_messages:
     entry (P_rdm_invocation_ptr, P_msg_spec_ptr, P_msg_spec_lth, P_msg_type, P_flags, P_code);

	rdm_invocation_ptr = P_rdm_invocation_ptr;

	msg_spec_str_ptr = P_msg_spec_ptr;
	msg_spec_lth = P_msg_spec_lth;
	msg_type = P_msg_type;

	report_errors_sw = "1"b;

	call parse_string ();

	call make_msg_spec ();

	call mark_messages ();

	P_code = 0;

	return;



/* Validates the syntax of a message_specifier */

validate_message_specifier:
     entry (P_rdm_invocation_ptr, P_msg_spec_ptr, P_msg_spec_lth, P_msg_type, P_flags, P_code);

	rdm_invocation_ptr = P_rdm_invocation_ptr;

	msg_spec_str_ptr = P_msg_spec_ptr;
	msg_spec_lth = P_msg_spec_lth;
	msg_type = P_msg_type;
	P_code = 0;

	report_errors_sw = "0"b;

	call parse_string ();

	return;
%page;
/* Clear the chain of marked messages */

clear_marked_messages:
     entry (P_rdm_invocation_ptr);

	rdm_invocation_ptr = P_rdm_invocation_ptr;

	marked_chain.n_messages = 0;			/* it's so simple with the new structure */

	return;



/* Mark the current message: used by requests which default to the current message */

mark_current_message:
     entry (P_rdm_invocation_ptr, P_msg_type);

	rdm_invocation_ptr = P_rdm_invocation_ptr;

/* phx19099 RL - check that current message is not treated as a deleted message */
	if P_msg_type = ONLY_DELETED_MESSAGES then
	     if rdm_invocation.current_message = 0 then
		call ssu_$abort_line (rdm_invocation.sci_ptr, emf_et_$no_current_message);
	     else call ssu_$abort_line (rdm_invocation.sci_ptr, (0), "Message ^d is not a deleted message.",
		     rdm_invocation.current_message);

	if rdm_invocation.current_message = 0 then	/* no current message ... */
	     if undeleted_chain.n_messages > 0 then	/* ... but there are still undeleted messages */
		call ssu_$abort_line (rdm_invocation.sci_ptr, emf_et_$no_current_message);
	     else call ssu_$abort_line (rdm_invocation.sci_ptr, 0, "There are no non-deleted messages.");

	marked_chain.n_messages = 1;			/* will be just one message in the chain */
	marked_chain.messages (1) = rdm_invocation.current_message;

	return;



/* Mark all messages: used by requests which operate on all messages by default (eg: list) */

mark_all_messages:
     entry (P_rdm_invocation_ptr, P_msg_type);

	rdm_invocation_ptr = P_rdm_invocation_ptr;

	msg_type = P_msg_type;
	if msg_type = ALL_MESSAGES then message_chain_ptr = rdm_invocation.message_chains.all;
	else if msg_type = NON_DELETED_MESSAGES then message_chain_ptr = rdm_invocation.message_chains.undeleted;
	else /*** if msg_type = ONLY_DELETED_MESSAGES then */
	     message_chain_ptr = rdm_invocation.message_chains.deleted;

	if message_chain.n_messages = 0 then		/* no messages of the given type left */
	     call ssu_$abort_line (rdm_invocation.sci_ptr, 0, "There are no^[^; non-deleted^; deleted^] messages.",
		msg_type);

	marked_chain.n_messages = message_chain.n_messages;

	do message_idx = 1 to message_chain.n_messages;	/* copy the chain to the marked chain */
	     marked_chain.messages (message_idx) = message_chain.messages (message_idx);
	end;

	return;
%page;
/* Marks each message on the current marked chain as an "original" request:  This entry is called by the "reply" and
   "forward" requests to indicate to other requests possibly invoked by send_mail or the forward sub-subsystem which
   messages are the "current" messages */

mark_original_messages:
     entry (P_rdm_invocation_ptr);

	rdm_invocation_ptr = P_rdm_invocation_ptr;

	marked_as_original_chain.n_messages = marked_chain.n_messages;

	do message_idx = 1 to marked_chain.n_messages;
	     marked_as_original_chain.messages (message_idx) = marked_chain.messages (message_idx);
	end;

	return;



/* Clears the messages marked as original messages:  This entry is called by the "reply" and "forward" requests upon
   completion to (1) clear the current marked chain (which might not be what the request had marked itself) and
   (2) recreate the marked chain as those messages explicitly marked by the earlier call to mark_original_messages above
*/

clear_original_messages:
     entry (P_rdm_invocation_ptr);

	rdm_invocation_ptr = P_rdm_invocation_ptr;

	call clear_marked_messages (rdm_invocation_ptr);
	reset_marked_as_original = "1"b;		/* throw out the old original chain */

	go to REMARK_ORIGINAL_MESSAGES;



/* Remark the messages marked as the original messages by "reply" or "forward":  This entry is called by a send_mail
   request or a forward sub-request to construct the message chain which the "reply" or "forward" request, respectively,
   was invoked to process */

remark_original_messages:
     entry (P_rdm_invocation_ptr);

	rdm_invocation_ptr = P_rdm_invocation_ptr;

	reset_marked_as_original = "0"b;		/* not yet done with this chain */


REMARK_ORIGINAL_MESSAGES:
	do message_idx = 1 to marked_as_original_chain.n_messages;
	     call add_message_to_marked_chain (marked_as_original_chain.messages (message_idx));
	end;

	if reset_marked_as_original then marked_as_original_chain.n_messages = 0;

	return;
%page;
/* Entry point called by rdm_msg_requests_ to mark messages for certain requests */

do_request:
     entry (P_sci_ptr, P_rdm_invocation_ptr, P_keyword_number, P_msg_type, P_reverse_sw);

	request_entry_sw = "1"b;
	regexp_count = 0;
	max_tokens = hbound (token_array, 1);
	n_tokens = 0;
	call get_token (FIRST_TYPE);
	if P_keyword_number = ALL_KEYWORD | P_keyword_number = SEEN_KEYWORD | P_keyword_number = UNSEEN_KEYWORD
	     | P_keyword_number = NEW_KEYWORD then
	     call get_token (ALL_KEYWORD_TYPE);
	else call get_token (KEYWORD_TYPE);
	token.str_ptr, msg_spec_str_ptr = addrel (addr (KEYWORDS (P_keyword_number, 1)), 1);
	token.str_lth, msg_spec_lth = length (KEYWORDS (P_keyword_number, 1));
	token.value = P_keyword_number;
	call get_token (LAST_TYPE);

	rdm_invocation_ptr = P_rdm_invocation_ptr;
	msg_type = P_msg_type;
	reverse = P_reverse_sw;

	call make_msg_spec ();
	call mark_messages ();
	return;
%page;
/* Parses the string which is a message_specifier into tokens and validates its syntax */

parse_string:
     procedure ();

dcl  ntp pointer;
dcl  keyword character (32) varying;
dcl  char1 character (1) aligned;
dcl  (number_value, code) fixed binary (35);
dcl  (idx, jdx, i1, i2) fixed binary (21);
dcl  (token_idx, operator_idx) fixed binary;

	max_tokens = hbound (token_array, 1);

	n_tokens = 0;				/* start out with no tokens, of course */
	call get_token (FIRST_TYPE);			/* dummy token at the beginning */

	idx = 1;					/* index of character to begin current token */

	do while (idx <= msg_spec_lth);
	     char1 = substr (msg_spec_str, idx, 1);

	     if index (OPERATORS, char1) ^= 0 then do;
		operator_idx = index (OPERATORS, char1);
		call get_token (OPERATOR_TYPES (operator_idx));
		token.operator = operator_idx;
		idx = idx + 1;
	     end;

	     else if index (DIGITS, char1) ^= 0 then do;	/* the beginning of a number */
		jdx = verify (substr (msg_spec_str, idx), DIGITS);
		if jdx = 0 then			/* j is the length of the putative number */
		     jdx = msg_spec_lth - idx + 1;
		else jdx = jdx - 1;

		if jdx > 6 then call abort_parse (emf_et_$msg_spec_bad_number);

		number_value = fixed (substr (msg_spec_str, idx, jdx));
		call get_token (NUMBER_TYPE);
		token.value = number_value;
		idx = idx + jdx;			/* move on to the next keyword */
	     end;

	     else if index (LETTERS, char1) ^= 0 then do; /* test for a keyword */
		jdx = verify (substr (msg_spec_str, idx), LETTERS);
		if jdx = 0 then			/* j is the length of the possible keyword */
		     jdx = msg_spec_lth - idx + 1;
		else jdx = jdx - 1;

		keyword = substr (msg_spec_str, idx, min (32, jdx));
						/* get a value for comparison */
		keyword = translate (keyword, LC_ALPHA, UC_ALPHA);
						/* make it case independent */
		do i1 = 1 to hbound (KEYWORDS, 1);	/* loop through the possible keywords */
		     if keyword = KEYWORDS (i1, 1) then go to GOOD_KEYWORD;
						/* it's the long form already */
		     do i2 = 2 to hbound (KEYWORDS, 2); /* loop through the possible short forrms */
			if keyword = KEYWORDS (i1, i2) then do;
						/* found one */
			     keyword = KEYWORDS (i1, 1);
						/* convert to the long form */
			     go to GOOD_KEYWORD;
			end;
		     end;
		end;				/* of keyword testing loop */

		call abort_parse (emf_et_$msg_spec_bad_keyword);

GOOD_KEYWORD:
		if keyword = "all" | keyword = "seen" | keyword = "unseen" | keyword = "new" then
		     call get_token (ALL_KEYWORD_TYPE);
		else call get_token (KEYWORD_TYPE);
		token.value = i1;			/* numeric index of keyword */
		idx = idx + jdx;			/* move past it to the next token */
	     end;

	     else if char1 = REGEXP_DELIM then do;	/* process regular expression now */
		i1 = idx + 1;			/* loop index for search for second delim */
REGEXP_LOOP:
		if i1 > msg_spec_lth then do;		/* we've run out of string! */
		     call abort_parse (emf_et_$msg_spec_missing_delim);
		end;

		jdx = index (substr (msg_spec_str, i1), REGEXP_DELIM);
						/* look for next one */
		if jdx = 0 then			/* didn't find it */
		     call abort_parse (emf_et_$msg_spec_missing_delim);

		if jdx > 3 then			/* look for a concealed delim if there's room */
		     if substr (msg_spec_str, i1 + jdx - 3, 2) = REGEXP_CONCEAL then do;
			i1 = i1 + jdx;		/* bump the index past it */
			go to REGEXP_LOOP;		/* and look again */
		     end;

		call get_token (REGEXP_TYPE);
		token.str_ptr = addr (substr (msg_spec_str, idx + 1, 1));
						/* the regexp, without the slash */
		token.str_lth = ((i1 + jdx) - idx) - 2; /* length of regexp */

		idx = idx + ((i1 + jdx) - idx);	/* skip the regexp and delims */

		call search_file_$silent (token.str_ptr, 1, token.str_lth, addr (NULL_STRING), 1, 0, (0), (0), code);
		if code = error_table_$nomatch then	/* can only get this far if the string's syntax is OK */
		     code = 0;
		if code ^= 0 then call abort_parse (code);
	     end;

	     else call abort_parse (emf_et_$msg_spec_invalid);
						/* evil character found */
	end;					/* of token generating loop */

	call get_token (LAST_TYPE);


/* Validate the syntax of the tokens comprising this message_specifier */

	regexp_count, number_count, range_count, keyword_count = 0;

	do token_idx = 1 to n_tokens - 1;
	     tp = addr (token_array (token_idx));
	     ntp = addr (token_array (token_idx + 1));

	     idx = SYNTAX_TABLE (token.type, ntp -> token.type);
						/* is this a legal pair? */
	     if idx ^= VALID_STATE then do;		/* no, it's illegal */
		if idx = EMPTY_MSG_SPEC_STATE then code = emf_et_$msg_spec_null;
		else if idx = BAD_EXPR_STATE then code = emf_et_$msg_spec_bad_expr;
		else if idx = BAD_OPER_STATE then code = emf_et_$msg_spec_bad_oper;
		else if idx = MIXED_EXPR_STATE then code = emf_et_$msg_spec_mixed;
		else if idx = BAD_REGEXP_STATE then code = emf_et_$msg_spec_bad_regexp;
		else if idx = BAD_RANGE_STATE then code = emf_et_$msg_spec_bad_range;
		else code = emf_et_$msg_spec_invalid;

		call abort_parse (code);		/* some error detected here */
	     end;

	     if token.type = NUMBER_TYPE then number_count = number_count + 1;

	     else if token.type = REGEXP_TYPE then regexp_count = regexp_count + 1;

	     else if token.type = KEYWORD_TYPE then keyword_count = keyword_count + 1;

	     else if token.type = RANGE_OPERATOR_TYPE then/* just check for range */
		range_count = range_count + 1;

	end;					/* of syntax checking loop through tokens */

	if regexp_count ^= 0 then do;
	     if number_count > 0 then			/* no numbers allowed */
		call abort_parse (emf_et_$msg_spec_mixed);
	     else if keyword_count > 1 then		/* only one keyword allowed in a regexp-type specifier */
		call abort_parse (emf_et_$msg_spec_invalid);
	end;

	if range_count > 1 then			/* only one range per specifier */
	     call abort_parse (emf_et_$msg_spec_invalid);

	return;

     end parse_string;
%page;
get_token:
     procedure (p_type);

dcl  p_type fixed binary parameter;

	if n_tokens >= max_tokens then call abort_parse (emf_et_$msg_spec_too_complex);

	n_tokens = n_tokens + 1;
	tp = addr (token_array (n_tokens));

	unspec (token) = ""b;
	token.str_ptr = null ();
	token.type = p_type;

	return;

     end get_token;
%page;
/* Constructs the msg_spec structure which defines the semantics of a message_specifier */

make_msg_spec:
     procedure () /* options (quick) */;

dcl  (low_range_found, high_range_found) bit (1) aligned;
dcl  (keyword_msg_number, low_range, high_range, code) fixed binary (35);
dcl  (token_idx, regexp_idx, prev_operator, bad_msg_number, keyword_msg_idx) fixed binary;

	if msg_type = ALL_MESSAGES then message_chain_ptr = rdm_invocation.message_chains.all;
	else if msg_type = NON_DELETED_MESSAGES then message_chain_ptr = rdm_invocation.message_chains.undeleted;
	else /*** if msg_type = ONLY_DELETED_MESSAGES then */
	     message_chain_ptr = rdm_invocation.message_chains.deleted;

	call get_message_numbers_and_indices ();	/* need pointers to the relevant messages */

	msg_spec_n_strings = regexp_count;
	call cu_$grow_stack_frame (currentsize (msg_spec), msg_spec_ptr, code);
	if code ^= 0 then call abort_parse (emf_et_$msg_spec_too_complex);

	unspec (msg_spec) = ""b;
	msg_spec.first, msg_spec.last = -1;
	msg_spec.search_start = 0;
	msg_spec.search_direction = DONT_SEARCH;

	regexp_idx = 1;				/* it will be used as a subscript when installing regexps */
	low_range_found, high_range_found = "0"b;
	prev_operator = NO_OPERATOR;

	do token_idx = 2 to n_tokens - 1;		/* loop through the real tokens */
	     tp = addr (token_array (token_idx));

	     if token.type = NUMBER_TYPE then do;	/* either a start or an end */
		low_range_found = "1"b;		/* remember we found a number */

		if ^high_range_found then		/* must be part of lower bound */
		     call apply_number_operator (prev_operator, low_range, token.value);
		else call apply_number_operator (prev_operator, high_range, token.value);

		prev_operator = NO_OPERATOR;		/* forget about operators 'till we see another one */
	     end;

	     else if token.type = RANGE_OPERATOR_TYPE then do;
		if ^high_range_found then do;		/* indicate that a range has been started */
		     prev_operator = NO_OPERATOR;
		     high_range_found = "1"b;
		end;

		else call abort_parse (emf_et_$msg_spec_bad_range);
	     end;					/* of case for range operator */

	     else if token.type = REGEXP_OPERATOR_TYPE then msg_spec.operator (regexp_idx) = token.operator;

	     else if token.type = NUMBER_OPERATOR_TYPE | token.type = COMPLEMENT_OPERATOR_TYPE then
		prev_operator = token.operator;

	     else if token.type = KEYWORD_TYPE then do;	/* process possible keywords */
		if token.value = FIRST_KEYWORD then do;
		     if first_msg_number = 0 then call no_message (emf_et_$no_messages);
		     keyword_msg_number = first_msg_number;
		     keyword_msg_idx = first_msg_idx;	/* in case we have to start a search */
		     msg_spec.search_direction = SEARCH_FORWARD;
		end;

		else if token.value = LAST_KEYWORD then do;
		     if last_msg_number = 0 then call no_message (emf_et_$no_messages);
		     keyword_msg_number = last_msg_number;
		     keyword_msg_idx = last_msg_idx;
		     msg_spec.search_direction = SEARCH_BACKWARD;
		end;

		else if token.value = CURRENT_KEYWORD then do;
		     if current_msg_number = 0 then call no_message (emf_et_$no_current_message);
		     keyword_msg_number = current_msg_number;
		     keyword_msg_idx = current_msg_idx;
		     msg_spec.search_direction = DONT_SEARCH;
		end;

		else if token.value = NEXT_KEYWORD then do;
		     if next_msg_number = 0 then call no_message (emf_et_$no_next_message);
		     keyword_msg_number = next_msg_number;
		     keyword_msg_idx = next_msg_idx;
		     msg_spec.search_direction = SEARCH_FORWARD;
		end;

		else if token.value = PREVIOUS_KEYWORD then do;
		     if prev_msg_number = 0 then call no_message (emf_et_$no_previous_message);
		     keyword_msg_number = prev_msg_number;
		     keyword_msg_idx = prev_msg_idx;
		     msg_spec.search_direction = SEARCH_BACKWARD;
		end;

		else if token.value = FIRST_SEEN_KEYWORD then
		     call search_message (first_msg_idx, SEARCH_FORWARD, SEARCH_SEEN);

		else if token.value = FIRST_UNSEEN_KEYWORD then
		     call search_message (first_msg_idx, SEARCH_FORWARD, SEARCH_UNSEEN);

		else if token.value = LAST_SEEN_KEYWORD then
		     call search_message (last_msg_idx, SEARCH_BACKWARD, SEARCH_SEEN);

		else if token.value = LAST_UNSEEN_KEYWORD then
		     call search_message (last_msg_idx, SEARCH_BACKWARD, SEARCH_UNSEEN);

		else if token.value = PREVIOUS_SEEN_KEYWORD then
		     call search_message (current_msg_idx - 1, SEARCH_BACKWARD, SEARCH_SEEN);

		else if token.value = PREVIOUS_UNSEEN_KEYWORD then
		     call search_message (current_msg_idx - 1, SEARCH_BACKWARD, SEARCH_UNSEEN);

		else if token.value = NEXT_SEEN_KEYWORD then
		     call search_message (current_msg_idx + 1, SEARCH_FORWARD, SEARCH_SEEN);

		else if token.value = NEXT_UNSEEN_KEYWORD then
		     call search_message (current_msg_idx + 1, SEARCH_FORWARD, SEARCH_UNSEEN);

		else call abort_parse (emf_et_$msg_spec_bad_keyword);
						/* shouldn't ever happen, since */
						/* we've now gotten through all the possible keywords */

		if msg_spec_n_strings > 0 then	/* this means the keyword is a "string" keyword */
		     msg_spec.search_start = keyword_msg_idx;

		else do;				/* otherwise, it's a number */
		     if ^high_range_found then do;
			call apply_number_operator (prev_operator, low_range, keyword_msg_number);
			low_range_found = "1"b;	/* so we won't make the mistake later */
			prev_operator = NO_OPERATOR;
		     end;

		     else call apply_number_operator (prev_operator, high_range, keyword_msg_number);
		end;				/* of case for a "number", as opposed to a "string" keyword */
	     end;					/* of case for keyword (other than "all") */

	     else if token.type = ALL_KEYWORD_TYPE then do;
		if (first_msg_number = 0) | (last_msg_number = 0) then call no_message (emf_et_$no_messages);

		if token.value = NEW_KEYWORD then do;
		     low_range_found = "0"b;
		     prev_msg_idx = 0;
		     do message_idx = message_chain.n_messages by -1 to 1 while (^low_range_found);
			call rdm_mailbox_interface_$read_message (rdm_invocation_ptr,
			     message_chain.messages (message_idx), message_ptr, code);
			if code ^= 0 | message.flags.seen then do;
			     low_range_found = "1"b;
			     if prev_msg_idx = 0 then
				call no_message (emf_et_$no_messages_selected);
			     else low_range = message_chain.messages (prev_msg_idx);
			end;
			prev_msg_idx = message_idx;
		     end;
		     if ^low_range_found then low_range = first_msg_number;
		end;
		else low_range = first_msg_number;
		high_range = last_msg_number;
		low_range_found, high_range_found = "1"b;

		if token.value = SEEN_KEYWORD then msg_spec.seen_only_sw = "1"b;
		else if token.value = UNSEEN_KEYWORD then msg_spec.unseen_only_sw = "1"b;
		else if msg_spec_n_strings > 0 then do; /* "all" is a special case for this */
		     msg_spec.search_start = first_msg_idx;
		     msg_spec.search_direction = SEARCH_FORWARD;
		     msg_spec.all_matches = "1"b;
		end;
	     end;					/* of case for "all" */

	     else if token.type = REGEXP_TYPE then do;
		msg_spec.str_ptr (regexp_idx) = token.str_ptr;
		msg_spec.str_len (regexp_idx) = token.str_lth;
		if prev_operator = COMPLEMENT_OPERATOR then msg_spec.complement (regexp_idx) = "1"b;
		regexp_idx = regexp_idx + 1;
		prev_operator = NO_OPERATOR;		/* compliment applies to exactly one regexp */
	     end;
	end;					/* of token processing loop */


	if (first_msg_number = 0) | (last_msg_number = 0) then call no_message (emf_et_$no_messages);
						/* there's not much that can be done */

	if ^low_range_found then do;
	     if msg_spec_n_strings = 0 then do;
		if current_msg_number = 0 then call no_message (emf_et_$no_current_message);
		high_range, low_range = current_msg_number;
	     end;

	     else do;				/* default to 'all' for strings */
		low_range = first_msg_number;
		high_range = last_msg_number;
		high_range_found = "1"b;
	     end;

	     low_range_found = "1"b;
	end;

	if ^high_range_found then do;			/* check for validity */
	     high_range = low_range;
	     msg_spec.single_message = "1"b;		/* indicate that a single message was asked for */
	end;

	if (high_range <= 0) | (low_range <= 0) | (low_range > high_range) then
	     call abort_parse (emf_et_$msg_spec_bad_range);

	bad_msg_number = -1;			/* check ranges against absolute message boundaries */
	if high_range > all_chain.messages (all_chain.n_messages) then bad_msg_number = high_range;
	if low_range < all_chain.messages (1) then bad_msg_number = low_range;
	if bad_msg_number ^= -1 then			/* this code is only reached with report_errors_sw OFF */
	     call ssu_$abort_line (rdm_invocation.sci_ptr, 0, "There is no message ^d.", bad_msg_number);


	if msg_spec.search_direction = DONT_SEARCH then do;
	     if msg_spec_n_strings > 0 then msg_spec.all_matches = "1"b;
	     msg_spec.search_direction = SEARCH_FORWARD;
	end;

	msg_spec.first = low_range;
	msg_spec.last = high_range;

	return;
%page;
/* Internal to make_msg_spec: sets the values of the current, first, last, previous, and next message numbers along with
   their indices in the type-specific message chain */

get_message_numbers_and_indices:
	procedure ();

dcl  idx fixed binary;

	     if message_chain.n_messages = 0 then	/* first and last are undefined */
		first_msg_number, first_msg_idx, last_msg_number, last_msg_idx = 0;
	     else do;				/* they're defined ... */
		first_msg_number = message_chain.messages (1);
		first_msg_idx = 1;
		last_msg_number = message_chain.messages (message_chain.n_messages);
		last_msg_idx = message_chain.n_messages;
	     end;

	     current_msg_number = rdm_invocation.current_message;
	     if current_msg_number = 0 then		/* no current message */
		current_msg_idx = 0;
	     else do;				/* check if it's in this type-specific chain */
		current_msg_idx = 0;
		do idx = 1 to message_chain.n_messages while (current_msg_idx = 0);
		     if message_chain.messages (idx) = current_msg_number then current_msg_idx = idx;
		end;
	     end;

	     if current_msg_number = 0 then		/* no current message: previous and next are undefined */
		prev_msg_number, prev_msg_idx, next_msg_number, next_msg_idx = 0;
	     else do;				/* find them in the chain ... */
		/*** ... previous is last message before the current message */
		prev_msg_number, prev_msg_idx = 0;
		do idx = message_chain.n_messages to 1 by -1 while (prev_msg_idx = 0);
		     if message_chain.messages (idx) < current_msg_number then do;
			prev_msg_number = message_chain.messages (idx);
			prev_msg_idx = idx;
		     end;
		end;
		/*** ... next is first message after the current mesage */
		next_msg_number, next_msg_idx = 0;
		do idx = 1 to message_chain.n_messages while (next_msg_idx = 0);
		     if message_chain.messages (idx) > current_msg_number then do;
			next_msg_number = message_chain.messages (idx);
			next_msg_idx = idx;
		     end;
		end;
	     end;

	     return;

	end get_message_numbers_and_indices;
%page;
/* Internal to make_msg_spec: applies a numeric operator (+ -) */

apply_number_operator:
	procedure (p_operator, p_operand_1, p_operand_2);

dcl  p_operator fixed binary parameter;
dcl  p_operand_1 fixed binary (35) parameter;
dcl  p_operand_2 fixed binary (35) parameter;

	     if p_operator = NO_OPERATOR then p_operand_1 = p_operand_2;

	     else if p_operator = MINUS_OPERATOR then p_operand_1 = p_operand_1 - p_operand_2;

	     else if p_operator = PLUS_OPERATOR then p_operand_1 = p_operand_1 + p_operand_2;

	     return;

	end apply_number_operator;
%page;
/* Internal to make_msg_spec: searches for first_seen, etc. */

search_message:
	proc (P_start_message_idx, P_search_direction, P_seen_unseen);

dcl  (P_start_message_idx, P_search_direction, P_seen_unseen, increment, message_idx) fixed bin;

	     if P_search_direction = SEARCH_FORWARD then
		increment = 1;
	     else increment = -1;

	     do message_idx = P_start_message_idx by increment
		while (message_idx >= 1 & message_idx <= message_chain.n_messages);

		call rdm_mailbox_interface_$read_message (rdm_invocation_ptr, message_chain.messages (message_idx),
		     message_ptr, code);
		if code ^= 0 then call abort_parse (emf_et_$no_such_message);
		if message.flags.seen = (P_seen_unseen = SEARCH_SEEN) then do;
		     keyword_msg_number = message_chain.messages (message_idx);
		     keyword_msg_idx = message_idx;
		     msg_spec.search_direction = DONT_SEARCH;
		     return;
		end;
	     end;
	     call no_message (emf_et_$no_such_message);

	end search_message;

     end make_msg_spec;
%page;
/* Marks the messages which are selected by the message_specifier:  Messages are only marked once even if selected by
   several message_specifiers so that they will always be processed in the order specified */

mark_messages:
     procedure ();

dcl  (continue_searching, ms_matched, this_matched) bit (1) aligned;
dcl  (first_message_idx, next_message_idx, message_idx, message_number, match_count, idx) fixed binary;

	if msg_spec.search_start > 0 then do;		/* a keyword preceded the strings */
	     search_direction = msg_spec.search_direction;
	     first_message_idx = msg_spec.search_start;
	end;
	else do;					/* otherwise, do it for "all" */
	     search_direction = SEARCH_FORWARD;
	     first_message_idx = 1;
	end;

	match_count = 0;				/* to keep track of matches */

	do message_idx = first_message_idx repeat (next_message_idx)
	     while ((message_idx > 0) & (message_idx <= message_chain.n_messages));

	     if search_direction = SEARCH_FORWARD then next_message_idx = message_idx + 1;
	     else if search_direction = SEARCH_BACKWARD then next_message_idx = message_idx - 1;
	     else next_message_idx = 0;

	     message_number = message_chain.messages (message_idx);

	     if (message_number >= msg_spec.first) & (message_number <= msg_spec.last) then do;
						/* the message number is within range ... */
		continue_searching = "1"b;
		ms_matched = "1"b;

		do idx = 1 to msg_spec_n_strings while (continue_searching);
		     this_matched =
			rdm_search_utils_$search_message_with_regexp (rdm_invocation_ptr, message_number,
			msg_spec.str_ptr (idx), msg_spec.str_len (idx));
		     if msg_spec.complement (idx) then this_matched = ^this_matched;

		     if msg_spec.operator (idx) = OR_OPERATOR then ms_matched = ms_matched | this_matched;
		     else if msg_spec.operator (idx) = AND_OPERATOR then do;
			ms_matched = ms_matched & this_matched;
			continue_searching = ms_matched;
		     end;				/* search more only if necessary */
		     else ms_matched = this_matched;	/* no operator specified, presumably */
		end;

		if msg_spec.seen_only_sw | msg_spec.unseen_only_sw then do;
		     call rdm_mailbox_interface_$read_message (rdm_invocation_ptr, message_number, message_ptr, code);
		     if code ^= 0 then call abort_parse (code);
		     if message.flags.seen ^= msg_spec.seen_only_sw then ms_matched = "0"b;
		end;

		if ms_matched then do;		/* we won */
		     match_count = match_count + 1;
		     call add_message_to_marked_chain (message_number);
		     if ^msg_spec.all_matches & (msg_spec_n_strings > 0) then next_message_idx = 0;
		end;				/* ...stop on first match unless "all" was used */
	     end;
	end;

	if match_count = 0 & ^request_entry_sw then do;	/* no match */
	     if report_errors_sw & msg_spec.single_message then
		if msg_type = ONLY_DELETED_MESSAGES then/* complain about a missing message */
		     call ssu_$abort_line (rdm_invocation.sci_ptr, 0, "Message ^d is not a deleted message.",
			msg_spec.first);
		else if msg_type = NON_DELETED_MESSAGES then
		     call ssu_$abort_line (rdm_invocation.sci_ptr, 0, "Message ^d has already been deleted.",
			msg_spec.first);
		else call ssu_$abort_line (rdm_invocation.sci_ptr, 0, "There is no message ^d.", msg_spec.first);

	     else if msg_spec.single_message then call abort_parse (emf_et_$no_such_message);

	     else if msg_spec_n_strings > 0 then call abort_parse (emf_et_$no_matching_messages);

	     else call abort_parse (emf_et_$no_messages_selected);
	end;

	return;

     end mark_messages;
%page;
/* Adds the specified message to the marked chain iff it is not already in the chain */

add_message_to_marked_chain:
     procedure (p_message_number);

dcl  p_message_number fixed binary parameter;
dcl  idx fixed binary;

	do idx = 1 to marked_chain.n_messages;
	     if marked_chain.messages (idx) = p_message_number then return;
	end;

	marked_chain.n_messages, idx = marked_chain.n_messages + 1;

	marked_chain.messages (idx) = p_message_number;

	return;

     end add_message_to_marked_chain;
%page;
/* Routine to return from message spec processing if there are no messages
   of the specified type.  If the caller is a keyword active request it will
   return the null string or 0 as appropriate. */

no_message:
     procedure (p_code);

dcl  p_code fixed bin (35) parameter;

	if ^request_entry_sw then P_code = p_code;	/* do_request has no code parameter */
	go to ERROR_RETURN_FROM_VALIDATE_MESSAGE_SPECIFIER;

     end no_message;
%page;
/* Aborts processing of the message_specifier and optionally prints an error message */

abort_parse:
     procedure (p_code);

dcl  p_code fixed bin (35) parameter;
dcl  message character (64) varying;
dcl  type_str character (32) varying;

	if report_errors_sw then do;
	     if msg_type = NON_DELETED_MESSAGES then type_str = " non-deleted";
	     else if msg_type = ONLY_DELETED_MESSAGES then type_str = " deleted";
	     else type_str = "";

	     if p_code = emf_et_$no_previous_message then message = "There is no previous^a message. ""^a""";
	     else if p_code = emf_et_$no_next_message then message = "There is no next^a message. ""^a""";
	     else if p_code = emf_et_$no_messages then message = "There are no^a messages. ""^a""";
	     else if p_code = emf_et_$no_messages_selected then message = "No^a messages selected. ""^a""";
	     else if p_code = emf_et_$no_matching_messages then message = "No matching^a messages. ""^a""";
	     else message = "";

	     if length (message) > 0 then
		call ssu_$abort_line (rdm_invocation.sci_ptr, 0, message, type_str, msg_spec_str);
	     else call ssu_$abort_line (rdm_invocation.sci_ptr, p_code, """^a""", msg_spec_str);
	end;

	else do;
	     if ^request_entry_sw then		/* do_request has no code parameter */
		P_code = p_code;			/* copy it to the main procedure error code */
	     go to ERROR_RETURN_FROM_VALIDATE_MESSAGE_SPECIFIER;
	end;

     end abort_parse;

ERROR_RETURN_FROM_VALIDATE_MESSAGE_SPECIFIER:
	return;
%page;
%include mlsys_mailbox;
%page;
%include mlsys_message;
%page;
%include rdm_invocation;
%page;
%include rdm_message_list;
%page;
%include rdm_msg_spec_keywords;
%page;
%include rdm_message_chains;

     end rdm_message_mark_mgr_;
