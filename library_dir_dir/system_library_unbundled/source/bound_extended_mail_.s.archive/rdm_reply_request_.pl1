/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(89-04-07,Lee), approve(89-05-10,MCR8104),
     audit(89-07-18,LZimmerman), install(89-10-02,MR12.3-1079):
     phx19099, phx15783, Mail 457 - added message_type parameter to call to
     rdm_message_mark_mgr_$mark_current_message to catch use of "-odl" with the
     current message.
  2) change(89-04-11,Lee), approve(89-05-10,MCR8104),
     audit(89-07-18,LZimmerman), install(89-10-02,MR12.3-1079):
     phx18564, phx17540, phx17353, Mail 446 - the new entry set_new_current_msg
     in rdm_mailbox_interface_ is now called when the current message is
     changed to guarantee that the new current message is never a deleted
     message; reformatting.
                                                   END HISTORY COMMENTS */


/* format: off */

/* The read_mail reply request */

/* Created:  March 1979 by W. Olin Sibert */
/* Modified: 25 December 1979 by W. Olin Sibert to update for new rdm_invocation, add new options, and fix bug in replying
      to a message with only a Sender: field */
/* Modified: 25 April 1980 by G. Palter to implement suggestion #084 -- Provide abbrev expansion of read_mail and
      send_mail request lines; add the "-abbrev", "-no_abbrev", and "-profile" control arguments */
/* Modified: 30 May 1980 by G. Palter to:
      (1) fix bug #0156 -- the "reply" request does not work on headerless messages;
      (2) implement suggestion #0309 -- the "reply" request should default the send_mail it creates to the same state of
	abbrev processing and the same profile as the read_mail invocation in which "reply" is executed;
      (3) implement suggestion #0263 -- the current message in read_mail should be set to the message being processed -
	thus, if an error occurs, the current message will remain on which the error occured;
      (4) implement suggestion #0184 -- when replying to a single address, the message should say "Replying to ADDRESS." -
	actually, it will include as many addresses as possible */
/* Modified: 31 May 1980 by G. Palter to:
      (1) implement suggestion #0220 -- the "-include_original" control argument to "reply" should also cause the
	inclusion of the From, Date and Subject fields;
      (2) implement suggestion #0186 -- there should be a "print_original" request in send_mail which prints the message
	being replied to when invoked by read_mail's "reply" request;
      (3) implement suggestion #0196 -- replying to an interactive message should cause the text of the message to be
	included (unless "-no_include_original" is given) */
/* Modified: 3 June 1980 by G.  Palter to implement suggestion #0286 -- add control arguments to the "reply" request to
      suppress replying to yourself ("-no_include_self").  Make this argument the default */
/* Modified: 4 June 1980 by G. Palter to implement suggestion #0287 -- if a reply is being created and the user exits
      send_mail without sending the reply, the "-delete" control argument of the "reply" request should be ignored */
/* Modified: 17 June 1980 by G. Palter to:
      (1) fix bug #0326 -- Attempting to reply to a message sent by yourself when "-no_include_self" is in effect produces
	an error message and then sets the current message to garbage, causing all sorts of subsequent bad behavior;
      (2) partially implement suggestion #0327 -- The "reply" request should issue a warning when it detects that you
	would have been a recipient to a reply if "-no_include_self" had not been used */
/* Modified: 20 June 1980 by G. Palter to:
      (1) fix bug #0328 -- the "Replying to ..." message is ungramatical.  It includes commas in the wrong places and also
	says "1 others" */
/* Modified: 24 July 1980 by G. Palter to add "-prompt" and "-no_prompt" control arguments */
/* Modified: 16 February 1982 by G. Palter for new calling sequences of ssu_$get_abbrev_info and ssu_$set_abbrev_info */
/* Modified: 19 September 1982 by G. Palter for new send_mail filling, prompting, and request loop control and to
      propogate the state of debug_mode to the created send_mail */
/* Modified: 2 November 1982 by G. Palter to:
      (1) insure that all foreign recipients have their host names validated;
      (2) fix mail_system error #0301 -- if all recipients of the reply are deleted because of errors, an extra message
	will be issued promising that the send_mail request loop will be entered;
      (3) fix mail_system error #0372 -- use of "-refill" without "-include_original" should be an error;
      (4) fix mail_system error #0330 -- the reply request doesn't count "-log" as a recipient causing improper rejection
	of reply requests if only the logbox is the recipient; and
      (5) implement mail_system suggestion #0327 -- the reply request should issue warnings when the reply would not be
	sent to the user as a result of the use of -no_include_self */
/* Modified: 7 November 1982 by G. Palter to:
      (1) fix mail_system error #0407 -- the reply request takes a null_pointer fault if one of the header fields used to
	determine the recipients of the reply (eg: From, To, cc) is empty; and
      (2) not issue the -no_include_self warning if "-nis" is given explicitly on either the read_mail command line or the
	reply request line */
/* Modified: 20 December 1982 by G. Palter to fix mail_system error #0408 -- the reply request does not recognize
      "-include_deleted", "-only_deleted", and "-only_non_deleted" */
/* Modified: October 1983 by G. Palter as part of the conversion to the new mail system interface */
/* Modified: March 1984 by G. Palter to fix the following mail system errors:
      #0421 -- the warning issued by the reply request when the "-no_include_self" default causes a copy of the reply not
         to be sent to the user is incorrect.  It mistakenly claims that the default is "-include_self"
      #0433 -- the send_mail command and all send_mail and read_mail requests which accept multiple addresses as arguments
         do not properly parse "-log -at HOST" */

/* format: on,style4,delnl,insnl,ifthenstmt,ifthen */


rdm_reply_request_:
     procedure (P_sci_ptr, P_rdm_invocation_ptr);

	return;					/* not an entrypoint */


dcl  P_sci_ptr pointer parameter;
dcl  P_rdm_invocation_ptr pointer parameter;

dcl  argument character (argument_lth) based (argument_ptr);
dcl  argument_lth fixed binary (21);
dcl  argument_ptr pointer;
dcl  (n_arguments, argument_idx) fixed binary;

dcl  msg_spec_array (msg_spec_array_size) fixed binary based (msg_spec_array_ptr);
dcl  msg_spec_array_ptr pointer;
dcl  (msg_spec_array_size, msg_spec_count) fixed binary;
dcl  msg_type fixed binary;				/* type of messages to process (all/undeleted/deleted) */

dcl  input_filename character (input_filename_lth) unaligned based (input_filename_ptr);
dcl  (input_filename_ptr, input_file_ptr) pointer;
dcl  input_filename_lth fixed binary (21);

dcl  profile_pathname character (profile_pathname_lth) unaligned based (profile_pathname_ptr);
dcl  profile_dirname character (168);
dcl  profile_ename character (32);
dcl  (profile_pathname_ptr, profile_ptr) pointer;
dcl  profile_pathname_lth fixed binary (21);
dcl  (profile_pathname_given, abbrev_ca_given, abbrev_enabled) bit (1) aligned;

dcl  recipients_lists_array (3) pointer based (addr (sdm_subsystem_info.to));

dcl  current_address_list_ptr pointer based (current_address_list_ptr_ptr);
dcl  current_address_list_ptr_ptr pointer;

dcl  sdm_invocation_ptr pointer;			/* -> description of the send_mail invocation we created */

dcl  1 local_pcao aligned like parse_ca_options;

dcl  clear_original_message_chain bit (1) aligned;	/* ON => we've marked the original messages */
dcl  saved_current_message fixed binary;		/* current message number before invokeing send_mail */

dcl  include_authors_arg fixed binary (1);		/* indicates if either -iat/-niat is on the request line */
dcl  include_authors bit (1) aligned;			/* ON => include the authors as recipients of the reply */
dcl  to_arg_specified bit (1) aligned;			/* ON => explicit primary recipients given: disable -iat */

dcl  include_recipients bit (1) aligned;		/* ON => include original recipients as reply recipients */

dcl  include_self bit (1) aligned;			/* ON => remove the user from implicit recipients */
dcl  dont_issue_nis_warning bit (1) aligned;		/* ON => don't complain if user is excluded */
dcl  warning_given_for_this_message bit (1) aligned;	/* ON => already complained for the current message */

dcl  abort bit (1) aligned;				/* ON => abort request if invalid address on request line */
dcl  found_invalid_address bit (1) aligned;		/* ... tracks invalid addresses */

dcl  delete_after_processing bit (1) aligned;		/* ON => delete original messages after the reply */

dcl  address_ptr pointer;

dcl  my_person_id character (32);
dcl  compare_both_user_addresses bit (1) aligned;		/* ON => mail table & default mailbox addresses differ */

dcl  (message_idx, message_number) fixed binary;

dcl  recipient_count fixed binary;			/* total # of recipients */

dcl  code fixed binary (35);

/* format: off */
dcl (DEFAULT_INCLUDE_AUTHORS	initial (0),		/* include authors if no explicit primary recipients */
     INCLUDE_AUTHORS	initial (1),		/* include authors regardless */
     NO_INCLUDE_AUTHORS	initial (-1))		/* never include authors */
	fixed binary (1) static options (constant);

dcl (emf_et_$send_mail_aborted, error_table_$bad_conversion, error_table_$badopt, error_table_$inconsistent,
     error_table_$noarg, error_table_$smallarg, mlsys_et_$ca_parse_failed, mlsys_et_$no_recipients)
	fixed binary (35) external;
/* format: on */

dcl  iox_$user_output pointer external;

dcl  cu_$grow_stack_frame entry (fixed binary (19), pointer, fixed binary (35));
dcl  cv_dec_check_ entry (character (*), fixed binary (35)) returns (fixed binary (35));
dcl  expand_pathname_ entry (character (*), character (*), character (*), fixed binary (35));
dcl  expand_pathname_$add_suffix entry (character (*), character (*), character (*), character (*), fixed binary (35));
dcl  get_line_length_$switch entry (pointer, fixed binary (35)) returns (fixed binary);
dcl  hcs_$fs_get_path_name entry (pointer, character (*), fixed binary, character (*), fixed binary (35));
dcl  initiate_file_ entry (character (*), character (*), bit (*), pointer, fixed binary (24), fixed binary (35));
dcl  mail_system_$add_address entry (pointer, pointer, character (8), fixed binary (35));
dcl  mail_system_$compare_addresses entry (pointer, pointer, fixed binary (35)) returns (bit (1) aligned);
dcl  mail_system_$eliminate_duplicate_addresses entry ((*) pointer, fixed binary (35));
dcl  mail_system_$free_address entry (pointer, fixed binary (35));
dcl  mail_system_$free_address_list entry (pointer, fixed binary (35));
dcl  mail_system_$merge_address_lists entry (pointer, pointer, bit (1) aligned, pointer, fixed binary (35));
dcl  mail_system_$validate_address entry (pointer, bit (1) aligned, fixed binary (35));
dcl  mlsys_utils_$parse_address_control_args entry (pointer, fixed binary, pointer, pointer, fixed binary (35));
dcl  mlsys_utils_$parse_address_list_control_args
	entry (pointer, fixed binary, pointer, character (8), pointer, pointer, fixed binary (35));
dcl  mlsys_utils_$print_validate_results entry (pointer, pointer, fixed binary (35));
dcl  mlsys_utils_$summarize_address entry (pointer, bit (1) aligned, character (*) varying, fixed binary (35));
dcl  pathname_ entry (character (*), character (*)) returns (character (168));
dcl  rdm_mailbox_interface_$delete_messages entry (pointer, bit (1) aligned);
dcl  rdm_mailbox_interface_$mark_processed_and_acknowledge entry (pointer, fixed binary);
dcl  rdm_mailbox_interface_$read_message entry (pointer, fixed binary, pointer, fixed binary (35));
dcl  rdm_mailbox_interface_$set_new_current_msg entry (ptr, fixed binary, fixed binary);
dcl  rdm_message_mark_mgr_$clear_marked_messages entry (pointer);
dcl  rdm_message_mark_mgr_$clear_original_messages entry (pointer);
dcl  rdm_message_mark_mgr_$mark_current_message entry (pointer, fixed binary);
dcl  rdm_message_mark_mgr_$mark_messages
	entry (pointer, pointer, fixed binary (21), fixed binary, bit (*), fixed binary (35));
dcl  rdm_message_mark_mgr_$mark_original_messages entry (pointer);
dcl  sdm_subsystem_$create_invocation entry (character (8), pointer, pointer, fixed binary (35));
dcl  sdm_subsystem_$destroy_invocation entry (pointer, pointer);
dcl  sdm_subsystem_$subsystem entry (pointer, pointer, fixed binary (35));
dcl  ssu_$abort_line entry () options (variable);
dcl  ssu_$arg_count entry (pointer, fixed binary);
dcl  ssu_$arg_ptr entry (pointer, fixed binary, pointer, fixed binary (21));
dcl  ssu_$get_abbrev_info entry (pointer, pointer, pointer, bit (1) aligned);
dcl  ssu_$get_subsystem_and_request_name entry (pointer) returns (character (72) varying);
dcl  ssu_$print_message entry () options (variable);
dcl  terminate_file_ entry (pointer, fixed binary (24), bit (*), fixed binary (35));
dcl  user_info_ entry (character (*));

dcl  cleanup condition;

dcl  (addr, convert, currentsize, hbound, index, length, ltrim, maxlength, min, null, substr, translate) builtin;
%page;
reply_request:
     entry (P_sci_ptr, P_rdm_invocation_ptr);

	rdm_invocation_ptr = P_rdm_invocation_ptr;
	call ssu_$arg_count (P_sci_ptr, n_arguments);

	sdm_invocation_ptr,				/* for cleanup handler */
	     sdm_subsystem_info_ptr, address_ptr, input_file_ptr, profile_ptr = null ();
	clear_original_message_chain = "0"b;

	on condition (cleanup) call cleanup_after_reply_request ();


/* Create the send_mail invocation:  This must be done before argument processing as the address lists in the
   sdm_subsystem_info structure are used directly */

	call sdm_subsystem_$create_invocation (SDM_SUBSYSTEM_INFO_VERSION_6, sdm_invocation_ptr, sdm_subsystem_info_ptr,
	     code);
	if code ^= 0 then call ssu_$abort_line (P_sci_ptr, code, "Creating a send_mail subsystem.");

	sdm_subsystem_info.rdm_invocation_ptr = rdm_invocation_ptr;

	call rdm_message_mark_mgr_$clear_marked_messages (rdm_invocation_ptr);

	msg_spec_count = 0;
	msg_type = NON_DELETED_MESSAGES;		/* default value */
	msg_spec_array_size = n_arguments;
	call cu_$grow_stack_frame (currentsize (msg_spec_array), msg_spec_array_ptr, code);
	if code ^= 0 then call ssu_$abort_line (P_sci_ptr, 0, "Too many message specifiers on the request line.");


/* Setup defaults: reading the user's profile will go here someday */

	abort = "1"b;				/* abort if any invalid addresses are on the request line */
	found_invalid_address = "0"b;			/* ... will need to know this later on */

	delete_after_processing = "0"b;		/* do not delete them after the reply is sent */

	sdm_subsystem_info.debug = rdm_invocation.debug_mode;

	sdm_subsystem_info.include_original_text = rdm_invocation.reply_options.include_original;
	sdm_subsystem_info.original_text_indentation = -1;/* indicates "-indent" not seen */

	include_authors_arg = DEFAULT_INCLUDE_AUTHORS;	/* default is dependent on use of "-to" */
	include_recipients = rdm_invocation.reply_options.include_recipients;
	to_arg_specified = "0"b;			/* haven't seen explicit primary recipients */

	if rdm_invocation.reply_options.include_self = DEFAULT_INCLUDE_SELF then
	     include_self, dont_issue_nis_warning = "0"b;
	else if rdm_invocation.reply_options.include_self = INCLUDE_SELF then
	     include_self, dont_issue_nis_warning = "1"b;
	else do;					/* explicit -no_include_self on read_mail command line */
	     include_self = "0"b;
	     dont_issue_nis_warning = "1"b;		/* ... so suppress the warnings */
	end;

	sdm_subsystem_info.fill_control = rdm_invocation.reply_options.fill_control;
	sdm_subsystem_info.fill_width = rdm_invocation.reply_options.line_length;

	abbrev_ca_given = "0"b;			/* haven't seen -ab/-nab: use read_mail abbrev state */
	profile_pathname_given = "0"b;		/* no -profile yet */

	local_pcao.version = PARSE_CA_OPTIONS_VERSION_1;
	local_pcao.logbox_creation_mode = CREATE_AND_ANNOUNCE_MAILBOX;
	local_pcao.savebox_creation_mode = QUERY_TO_CREATE_MAILBOX;
	local_pcao.abort_on_errors = "0"b;		/* can't abort in case -no_abort appears somewhere */
	local_pcao.validate_addresses = "1"b;		/* always check validity of addresses */
	local_pcao.mbz = ""b;

	argument_idx = 1;

	current_address_list_ptr_ptr = null ();		/* start out looking for msg-specs, rather than addresses */


/* Process arguments */

	do while (argument_idx <= n_arguments);

	     if current_address_list_ptr_ptr ^= null () then do;
		/*** Looking for addresses after "-from", "-to", ... */
		call mlsys_utils_$parse_address_list_control_args (P_sci_ptr, argument_idx, addr (local_pcao),
		     ADDRESS_LIST_VERSION_2, current_address_list_ptr, sdm_subsystem_info.bcc, code);
		if (code ^= 0) & (code ^= mlsys_et_$ca_parse_failed) then
		     call ssu_$abort_line (P_sci_ptr, code, "Parsing control arguments.");
		found_invalid_address = found_invalid_address | (code = mlsys_et_$ca_parse_failed);
	     end;

	     if argument_idx <= n_arguments then do;

		/*** Either still looking for message specifiers or an argument not recognized by the mail system */
		call ssu_$arg_ptr (P_sci_ptr, argument_idx, argument_ptr, argument_lth);

		if index (argument, "-") = 1 then	/* a control argument */
		     /*** reply request control arguments ... */
		     if (argument = "-include_deleted") | (argument = "-idl") then msg_type = ALL_MESSAGES;
		     else if (argument = "-only_deleted") | (argument = "-odl") then msg_type = ONLY_DELETED_MESSAGES;
		     else if (argument = "-only_non_deleted") | (argument = "-ondl") then
			msg_type = NON_DELETED_MESSAGES;

		     else if (argument = "-delete") | (argument = "-dl") then delete_after_processing = "1"b;
		     else if (argument = "-no_delete") | (argument = "-ndl") then delete_after_processing = "0"b;

		     else if (argument = "-message") | (argument = "-msg") then do;
			call get_next_argument ("A message specifier");
			call process_arg_as_spec ();
		     end;

		     else if (argument = "-include_authors") | (argument = "-include_author") | (argument = "-iat")
			then
			include_authors_arg = INCLUDE_AUTHORS;
		     else if (argument = "-no_include_authors") | (argument = "-no_include_author")
			| (argument = "-niat") then
			include_authors_arg = NO_INCLUDE_AUTHORS;

		     else if (argument = "-include_recipients") | (argument = "-irc") then include_recipients = "1"b;
		     else if (argument = "-no_include_recipients") | (argument = "-nirc") then
			include_recipients = "0"b;

		     else if (argument = "-include_self") | (argument = "-is") then
			include_self, dont_issue_nis_warning = "1"b;
		     else if (argument = "-no_include_self") | (argument = "-nis") then do;
			include_self = "0"b;
			dont_issue_nis_warning = "1"b;
		     end;

		     else if (argument = "-include_original") | (argument = "-io") then
			sdm_subsystem_info.include_original_text = "1"b;
		     else if (argument = "-no_include_original") | (argument = "-nio") then
			sdm_subsystem_info.include_original_text = "0"b;

		     else if (argument = "-refill") | (argument = "-rfi") then
			sdm_subsystem_info.fill_original_text = "1"b;
		     else if (argument = "-no_refill") | (argument = "-nrfi") then
			sdm_subsystem_info.fill_original_text = "0"b;

		     else if (argument = "-indent") | (argument = "-ind") | (argument = "-in") then do;
			call get_next_argument ("A number");
			sdm_subsystem_info.original_text_indentation = cv_dec_check_ (argument, code);
			if code ^= 0 then
			     call ssu_$abort_line (P_sci_ptr, error_table_$bad_conversion, "-indent ^a", argument);
			if (sdm_subsystem_info.original_text_indentation < 0)
			     | (sdm_subsystem_info.original_text_indentation > 30) then
			     call ssu_$abort_line (P_sci_ptr, code,
				"Indentation must be between 0 and 30; not ""^a"".", argument);
		     end;

		     /*** Standard send_mail control arguments ... */
		     else if (argument = "-terminal_input") | (argument = "-ti") then
			sdm_subsystem_info.input_type = TERMINAL_INPUT;
		     else if (argument = "-input_file") | (argument = "-if") then do;
			call get_next_argument ("A pathname");
			sdm_subsystem_info.input_type = FILE_INPUT;
			input_filename_ptr = argument_ptr;
			input_filename_lth = argument_lth;
		     end;				/* save it for later processing */

		     else if argument = "-from" then current_address_list_ptr_ptr = addr (sdm_subsystem_info.from);
		     else if (argument = "-reply_to") | (argument = "-rpt") then
			current_address_list_ptr_ptr = addr (sdm_subsystem_info.reply_to);
		     else if argument = "-to" then do;
			to_arg_specified = "1"b;	/* ... turns off the -include_authors default */
			current_address_list_ptr_ptr = addr (sdm_subsystem_info.to);
		     end;
		     else if argument = "-cc" then current_address_list_ptr_ptr = addr (sdm_subsystem_info.cc);
		     else if argument = "-bcc" then current_address_list_ptr_ptr = addr (sdm_subsystem_info.bcc);

		     else if (argument = "-log") | (argument = "-save") | (argument = "-sv") then do;
			/*** ... must recognize these arguments even before "-to", etc. */
			call mlsys_utils_$parse_address_control_args (P_sci_ptr, argument_idx, addr (local_pcao),
			     address_ptr, code);
			if (code ^= 0) & (code ^= mlsys_et_$ca_parse_failed) then
			     call ssu_$abort_line (P_sci_ptr, code, "Parsing control arguments.");
			found_invalid_address = found_invalid_address | (code = mlsys_et_$ca_parse_failed);
			if address_ptr ^= null () then do;
			     call mail_system_$add_address (sdm_subsystem_info.bcc, address_ptr,
				ADDRESS_LIST_VERSION_2, code);
			     if code ^= 0 then
				call ssu_$abort_line (P_sci_ptr, code,
				     "Adding ^[logbox^;savebox^] address to bcc field.", (argument = "-log"));
			     address_ptr = null ();
			end;
			argument_idx = argument_idx - 1;
		     end;				/* is incremented below */

		     else if (argument = "-subject") | (argument = "-sj") then do;
			call get_next_argument ("A string");
			sdm_subsystem_info.subject_given = "1"b;
			sdm_subsystem_info.subject_ptr = argument_ptr;
			sdm_subsystem_info.subject_lth = argument_lth;
		     end;
		     else if (argument = "-no_subject") | (argument = "-nsj") then do;
			sdm_subsystem_info.subject_given = "1"b;
			sdm_subsystem_info.subject_lth = 0;
		     end;

		     else if argument = "-abort" then abort = "1"b;
		     else if argument = "-no_abort" then abort = "0"b;

		     else if (argument = "-acknowledge") | (argument = "-ack") then
			sdm_subsystem_info.acknowledge = "1"b;
		     else if (argument = "-no_acknowledge") | (argument = "-nack") then
			sdm_subsystem_info.acknowledge = "0"b;

		     else if (argument = "-brief") | (argument = "-bf") then sdm_subsystem_info.brief = "1"b;
		     else if (argument = "-long") | (argument = "-lg") then sdm_subsystem_info.brief = "0"b;

		     else if (argument = "-fill") | (argument = "-fi") then sdm_subsystem_info.fill_control = FILL;
		     else if (argument = "-no_fill") | (argument = "-nfi") then
			sdm_subsystem_info.fill_control = NO_FILL;
		     else if (argument = "-line_length") | (argument = "-ll") then do;
			call get_next_argument ("A number");
			sdm_subsystem_info.fill_width = cv_dec_check_ (argument, code);
			if code ^= 0 then
			     call ssu_$abort_line (P_sci_ptr, error_table_$bad_conversion, "-line_length ""^a""",
				argument);
			if sdm_subsystem_info.fill_width < 31 then
			     call ssu_$abort_line (P_sci_ptr, 0, "Line length must be greater than 30.");
		     end;

		     else if (argument = "-notify") | (argument = "-nt") then sdm_subsystem_info.notify = "1"b;
		     else if (argument = "-no_notify") | (argument = "-nnt") then sdm_subsystem_info.notify = "0"b;

		     /*** Control arguments required by the MCR boards despite the furious objections of the author */
		     else if argument = "-auto_write" then sdm_subsystem_info.auto_write = "1"b;
		     else if argument = "-no_auto_write" then sdm_subsystem_info.auto_write = "0"b;

		     /*** Standard subsystem control arguments */
		     else if (argument = "-abbrev") | (argument = "-ab") then
			sdm_subsystem_info.abbrev, abbrev_ca_given = "1"b;
		     else if (argument = "-no_abbrev") | (argument = "-nab") then do;
			sdm_subsystem_info.abbrev = "0"b;
			abbrev_ca_given = "1"b;
		     end;
		     else if (argument = "-profile") | (argument = "-pf") then do;
			call get_next_argument ("A pathname");
			profile_pathname_given = "1"b;
			profile_pathname_ptr = argument_ptr;
			profile_pathname_lth = argument_lth;
		     end;				/* save for later processing */

		     else if (argument = "-debug") | (argument = "-db") then sdm_subsystem_info.debug = "1"b;
		     else if (argument = "-no_debug") | (argument = "-ndb") then sdm_subsystem_info.debug = "0"b;

		     else if (argument = "-prompt") | (argument = "-pmt") then do;
			call get_next_argument ("A string");
			if argument_lth = 0 then	/* same as -no_prompt */
			     sdm_subsystem_info.prompt_control.prompt_control = NO_PROMPT;
			else do;
			     sdm_subsystem_info.prompt_control.prompt_control = USE_PROMPT_STRING;
			     sdm_subsystem_info.prompt_string = argument;
			end;
		     end;
		     else if (argument = "-no_prompt") | (argument = "-npmt") then
			sdm_subsystem_info.prompt_control.prompt_control = NO_PROMPT;

		     else if (argument = "-request") | (argument = "-rq") then do;
			call get_next_argument ("A string");
			sdm_subsystem_info.initial_requests_ptr = argument_ptr;
			sdm_subsystem_info.initial_requests_lth = argument_lth;
		     end;

		     else if (argument = "-request_loop") | (argument = "-rql") then
			sdm_subsystem_info.request_loop_control = REQUEST_LOOP;
		     else if (argument = "-no_request_loop") | (argument = "-nrql") then
			sdm_subsystem_info.request_loop_control = NO_REQUEST_LOOP;

		     /*** Control arguments which are now obsolete: delete in MR11 */
		     else if (argument = "-all") | (argument = "-a") then msg_type = ALL_MESSAGES;
		     else if (argument = "-message_id") | (argument = "-mid") | (argument = "-no_message_id")
			| (argument = "-nmid") then
			;

		     else call ssu_$abort_line (P_sci_ptr, error_table_$badopt, """^a""", argument);

		else do;
		     /*** Non-control argument: a message specifier */
		     if current_address_list_ptr_ptr ^= null () then
			call ssu_$abort_line (P_sci_ptr, 0,
			     "No implicit message specifiers may follow the ""-from"", ""-reply_to"", ""-to"", ""-cc"", or ""-bcc"" control arguments"
			     );
		     call process_arg_as_spec ();
		end;

		argument_idx = argument_idx + 1;	/* skip past the argument we just processed */
	     end;
	end;

	if sdm_subsystem_info.input_type = FILE_INPUT then do;
	     /*** Verify that the specified input file exists ... */
	     call expand_pathname_ (input_filename, sdm_subsystem_info.input_file.dname,
		sdm_subsystem_info.input_file.ename, code);
	     if code ^= 0 then call ssu_$abort_line (P_sci_ptr, code, "-input_file ""^a""", input_filename);
	     call initiate_file_ (sdm_subsystem_info.input_file.dname, sdm_subsystem_info.input_file.ename, R_ACCESS,
		input_file_ptr, (0), code);
	     if code ^= 0 then
		call ssu_$abort_line (P_sci_ptr, code, "-input_file ""^a""",
		     pathname_ (sdm_subsystem_info.input_file.dname, sdm_subsystem_info.input_file.ename));
	     call terminate_file_ (input_file_ptr, 0, TERM_FILE_TERM, (0));
	end;

	if profile_pathname_given then do;
	     /*** Initiate the subsystem profile requested by the user */
	     call expand_pathname_$add_suffix (profile_pathname, "profile", profile_dirname, profile_ename, code);
	     if code ^= 0 then call ssu_$abort_line (P_sci_ptr, code, "-profile ""^a""", profile_pathname);
	     call initiate_file_ (profile_dirname, profile_ename, R_ACCESS, sdm_subsystem_info.default_profile_ptr, (0),
		code);
	     if code ^= 0 then
		call ssu_$abort_line (P_sci_ptr, code, "-profile ""^a""", pathname_ (profile_dirname, profile_ename));
	     if ^abbrev_ca_given then			/* -profile implies -abbrev unless explicit -ab/-nab given */
		sdm_subsystem_info.abbrev = "1"b;
	     abbrev_ca_given = "1"b;			/* do not copy read_mail's abbreviation processing state */
	end;


/* Establish the remaining parameters for the send_mail invocation */

	if ^abbrev_ca_given then do;
	     /*** User did not give any abbrev control arguments: use read_mail's state of abbreviation processing */
	     call ssu_$get_abbrev_info (P_sci_ptr, sdm_subsystem_info.default_profile_ptr,
		sdm_subsystem_info.profile_ptr, abbrev_enabled);
	     sdm_subsystem_info.abbrev = abbrev_enabled;	/* attributes don't match, sigh... */
	     if sdm_subsystem_info.default_profile_ptr ^= null () then
		call add_null_refname (sdm_subsystem_info.default_profile_ptr);
	     if (sdm_subsystem_info.profile_ptr ^= null ())
		& (sdm_subsystem_info.profile_ptr ^= sdm_subsystem_info.default_profile_ptr) then
		call add_null_refname (sdm_subsystem_info.profile_ptr);
	end;					/* ssu_ never terminiates same profile twice */


/* If invalid addresses were found on the request line and -abort (the default) was specified, abort the request here.
   Otherwise (-no_abort specified), force the user to enter send_mail's request loop; a warning to this effect will be
   issued later */

	if found_invalid_address then			/* there are indeed invalid addresses ... */
	     if abort then				/* ... and the user doesn't want to continue */
		call ssu_$abort_line (P_sci_ptr, 0);
	     else sdm_subsystem_info.request_loop_control = REQUEST_LOOP;
						/* ... force the user to fix the addresses */


/* Check for inconsistencies and supply appropriate defaults where needed */

	if ^sdm_subsystem_info.include_original_text & (sdm_subsystem_info.original_text_indentation >= 0) then
	     call ssu_$abort_line (P_sci_ptr, error_table_$inconsistent, """-indent"" without ""-include_original"".");

	if ^sdm_subsystem_info.include_original_text & sdm_subsystem_info.fill_original_text then
	     call ssu_$abort_line (P_sci_ptr, error_table_$inconsistent, """-refill"" without ""-include_original"".");

	if sdm_subsystem_info.original_text_indentation < 0 then
	     sdm_subsystem_info.original_text_indentation = rdm_invocation.reply_options.indentation;
						/* indent by default value if not otherwise specified */

	if include_authors_arg = DEFAULT_INCLUDE_AUTHORS then
	     if to_arg_specified then			/* ... if explicit -to given do not include the authors */
		include_authors = "0"b;
	     else include_authors = rdm_invocation.include_authors;
	else if include_authors_arg = NO_INCLUDE_AUTHORS then include_authors = "0"b;
	else /*** if include_authors_arg = INCLUDE_AUTHORS then */
	     include_authors = "1"b;

	if msg_spec_count = 0 then			/* defaults to the current message (if any) */
	     call rdm_message_mark_mgr_$mark_current_message (rdm_invocation_ptr, msg_type);
						/* phx19099 RL - use of "-odl" with the current message will be caught during marking */
	else call process_msg_specs ();		/* mark the messages the caller asked for */


/* Build the reply message */

	if ^include_self then do;			/* will have to check addresses against ourselves */
	     call user_info_ (my_person_id);		/* ... may be needed for warnings */
	     compare_both_user_addresses =
		^
		mail_system_$compare_addresses (mlsys_data_$user_default_mailbox_address,
		mlsys_data_$user_mail_table_address, (0));
	     if ^dont_issue_nis_warning then		/* ... see if user explicitly sending himself a copy */
		call check_if_explicit_self ();
	end;

	original_messages_n_original_messages = marked_chain.n_messages;

	allocate original_messages in (rdm_area) set (original_messages_ptr);
	original_messages.version = ORIGINAL_MESSAGES_VERSION_1;

	do message_idx = 1 to marked_chain.n_messages;
	     message_number = marked_chain.messages (message_idx);

	     call rdm_mailbox_interface_$read_message (rdm_invocation_ptr, message_number, message_ptr, code);
	     if code ^= 0 then
		call ssu_$abort_line (P_sci_ptr, code, "Reading message #^d from ^a.", message_number,
		     rdm_invocation.mailbox_name);

	     original_messages.messages (message_idx).message_ptr = message_ptr;
	     original_messages.messages (message_idx).message_idx = message_number;

/* phx18564 RL - set current message to message_number and guarantee that it's not deleted */
	     call rdm_mailbox_interface_$set_new_current_msg (rdm_invocation_ptr, message_number,
		rdm_invocation.current_message);	/* it's current while we're working on it */

	     call process_message ();

	     call rdm_mailbox_interface_$mark_processed_and_acknowledge (rdm_invocation_ptr, message_number);
	end;

	sdm_subsystem_info.original_messages_ptr = original_messages_ptr;

	if ^sdm_subsystem_info.subject_given then do;	/* no subject in original messages ... */
	     sdm_subsystem_info.subject_given = "1"b;	/* ... force the reply to have no subject also */
	     sdm_subsystem_info.subject_lth = 0;
	end;


/* Eliminate duplicate recipients and, if not brief, list the recipients */

	call mail_system_$eliminate_duplicate_addresses (recipients_lists_array, code);
	if code ^= 0 then call ssu_$abort_line (P_sci_ptr, code, "Eliminating duplicate recipients.");

	recipient_count = 0;			/* just count top-level addresses */
	do address_list_ptr = sdm_subsystem_info.to, sdm_subsystem_info.cc, sdm_subsystem_info.bcc;
	     if ^is_empty_list (address_list_ptr) then recipient_count = recipient_count + address_list.n_addresses;
	end;

	if recipient_count = 0 then call ssu_$abort_line (P_sci_ptr, mlsys_et_$no_recipients);

	if found_invalid_address then do;		/* force the user into the request loop */
	     sdm_subsystem_info.request_loop_control = REQUEST_LOOP;
	     call ssu_$print_message (P_sci_ptr, 0,
		"Invalid addresses were detected.  The send_mail request loop will be entered to permit corrections.")
		;
	end;

	if ^sdm_subsystem_info.brief then		/* tell user who's getting it */
	     call print_recipients_list ();


/* Invoke send_mail */

	call rdm_message_mark_mgr_$mark_original_messages (rdm_invocation_ptr);
	saved_current_message = rdm_invocation.current_message;
	clear_original_message_chain = "1"b;

	call sdm_subsystem_$subsystem (sdm_invocation_ptr, sdm_subsystem_info_ptr, code);

	clear_original_message_chain = "0"b;
	rdm_invocation.current_message = saved_current_message;
						/* in case some send_mail request changes it */
	call rdm_message_mark_mgr_$clear_original_messages (rdm_invocation_ptr);

	if code ^= 0 then
	     if code = emf_et_$send_mail_aborted then	/* message was modified/unprocessed on exit */
		if ^sdm_subsystem_info.brief & delete_after_processing then
		     call ssu_$abort_line (P_sci_ptr, 0, "Reply not sent.  Message(s) will not be deleted.");
		else call ssu_$abort_line (P_sci_ptr, 0);
	     else call ssu_$abort_line (P_sci_ptr, code, "Invoking send_mail subsystem.");

	if delete_after_processing then		/* delete messages after replying */
	     call rdm_mailbox_interface_$delete_messages (rdm_invocation_ptr, "0"b);

	call cleanup_after_reply_request ();

	return;
%page;
/* Fetches the value expected after the given control argument */

get_next_argument:
     procedure (p_argument_type);

dcl  p_argument_type character (*) parameter;

	if argument_idx = n_arguments then
	     call ssu_$abort_line (P_sci_ptr, error_table_$noarg, "^a after ""^a"".", p_argument_type, argument);

	argument_idx = argument_idx + 1;
	call ssu_$arg_ptr (P_sci_ptr, argument_idx, argument_ptr, argument_lth);

	return;

     end get_next_argument;
%page;
/* Adds the current argument to the array of message specifies for this request */

process_arg_as_spec:
     procedure ();

	if msg_spec_count >= hbound (msg_spec_array, 1) then
	     call ssu_$abort_line (P_sci_ptr, 0, "Too many message specifiers on the request line.");
						/* can't ever happen */

	msg_spec_count = msg_spec_count + 1;
	msg_spec_array (msg_spec_count) = argument_idx;

	return;

     end process_arg_as_spec;



/* Processes the message specifies to produce the chain of messages to be processed by this request */

process_msg_specs:
     procedure ();

dcl  idx fixed bin;

	do idx = 1 to msg_spec_count;
	     call ssu_$arg_ptr (P_sci_ptr, msg_spec_array (idx), argument_ptr, argument_lth);

	     call rdm_message_mark_mgr_$mark_messages (rdm_invocation_ptr, argument_ptr, argument_lth, msg_type, ""b,
		code);
	     if code ^= 0 then call ssu_$abort_line (P_sci_ptr, code);
	end;

	return;

     end process_msg_specs;
%page;
/* Cleans up after execution of the request */

cleanup_after_reply_request:
     procedure ();

	if clear_original_message_chain then do;
	     call rdm_message_mark_mgr_$clear_original_messages (rdm_invocation_ptr);
	     rdm_invocation.current_message = saved_current_message;
	end;

	if input_file_ptr ^= null () then call terminate_file_ (input_file_ptr, 0, TERM_FILE_TERM, (0));

	if profile_ptr ^= null () then call terminate_file_ (profile_ptr, 0, TERM_FILE_TERM, (0));

	if address_ptr ^= null () then call mail_system_$free_address (address_ptr, (0));

	if (sdm_invocation_ptr ^= null ()) | (sdm_subsystem_info_ptr ^= null ()) then
	     call sdm_subsystem_$destroy_invocation (sdm_invocation_ptr, sdm_subsystem_info_ptr);

	return;

     end cleanup_after_reply_request;
%page;
/* Processes a single message:  If this is the first message with a non-null subject, it's subject will be used as the
   subject for the reply (with "Re:" prefixed to the subject if needed).  The authors and recipients of the message will
   be added to the reply's recipients as requested by the user */

process_message:
     procedure ();

	if ^sdm_subsystem_info.subject_given then	/* add the first non-null subject we can find */
	     call set_reply_subject_if_ok ();

	warning_given_for_this_message = "0"b;		/* don't give -no_include_self warning twice */

	if include_authors then
	     if is_empty_list (message.reply_to) then	/* no Reply-To: use the From field which is never empty */
		call add_recipients (message.from, sdm_subsystem_info.to);
	     else call add_recipients (message.reply_to, sdm_subsystem_info.to);

	if include_recipients then do;
	     if ^is_empty_list (message.to) then call add_recipients (message.to, sdm_subsystem_info.cc);
	     if ^is_empty_list (message.cc) then call add_recipients (message.cc, sdm_subsystem_info.cc);
	     if ^is_empty_list (message.bcc) then call add_recipients (message.bcc, sdm_subsystem_info.bcc);
	end;

	return;



/* Internal to process_message:  Sets the subject of the reply to this message's subject prefixed by "Re:" if this
   message's subject is non-null */

set_reply_subject_if_ok:
	procedure ();

dcl  reply_subject character (reply_subject_lth) unaligned based (reply_subject_ptr);
dcl  reply_subject_ptr pointer;
dcl  reply_subject_lth fixed binary (21);

	     if length (message_subject) = 0 then return; /* no subject */

	     sdm_subsystem_info.subject_given = "1"b;	/* only the first non-null subject is used */

	     if translate (substr (message_subject, 1, min (3, length (message_subject))), "Re", "rE") = "Re:" then do;
		reply_subject_lth = length (message_subject);
		allocate reply_subject in (rdm_area) set (reply_subject_ptr);
		reply_subject = message_subject;
		substr (reply_subject, 1, 3) = "Re:";
	     end;
	     else do;
		reply_subject_lth = length (message_subject) + length ("Re: ");
		allocate reply_subject in (rdm_area) set (reply_subject_ptr);
		reply_subject = "Re: " || message_subject;
	     end;

	     sdm_subsystem_info.subject_ptr = reply_subject_ptr;
	     sdm_subsystem_info.subject_lth = reply_subject_lth;

	     return;

	end set_reply_subject_if_ok;
%page;
/* Internal to process_message:  Adds the addresses in the specified header field of an original message to one of the
   recipient header fields (To, cc, bcc) of the reply message: Any addresses which refer to the user issuing the reply are
   eliminated if so requested */

add_recipients:
	procedure (p_original_field, p_reply_recipient_field);

dcl  p_original_field pointer parameter;
dcl  p_reply_recipient_field pointer parameter;

dcl  address_ptr pointer;
dcl  code fixed binary (35);
dcl  address_idx fixed binary;


	     address_list_ptr = p_original_field;	/* guarenteed not empty by our caller */

	     do address_idx = 1 to address_list.n_addresses;
		address_ptr = address_list.addresses (address_idx);

		call mail_system_$validate_address (address_ptr, "0"b /* don't expand mailing lists */, code);

		if code = 0 then do;		/* address is OK ... */
		     if ^include_self then		/* ... but we must check for self-references */
			if mail_system_$compare_addresses (mlsys_data_$user_default_mailbox_address, address_ptr,
			     (0)) then do;
IGNORE_ADDRESS:					/* ... and it is our own address */
			     if ^dont_issue_nis_warning then do;
				if ^warning_given_for_this_message then
				     call ssu_$print_message (P_sci_ptr, 0,
					"Message #^d -- no reply sent to ^a due to ""-no_include_self"" default.",
					message_number, my_person_id);
				warning_given_for_this_message = "1"b;
			     end;
			     go to PROCESS_NEXT_ADDRESS;
			end;
			else if compare_both_user_addresses then
			     if mail_system_$compare_addresses (mlsys_data_$user_mail_table_address, address_ptr,
				(0)) then
				go to IGNORE_ADDRESS;
		     call mail_system_$add_address (p_reply_recipient_field, address_ptr, ADDRESS_LIST_VERSION_2,
			code);
		     if code ^= 0 then
			call ssu_$abort_line (P_sci_ptr, code,
			     "Message #^d -- processing ""^[-include_authors^;-include_recipients^]"".",
			     message_number, (addr (p_reply_recipient_field) = addr (sdm_subsystem_info.to)));
		end;

		else do;				/* invalid address ... */
		     found_invalid_address = "1"b;	/* ... force the request loop */
		     call mlsys_utils_$print_validate_results (P_sci_ptr, address_ptr, code);
		end;

PROCESS_NEXT_ADDRESS:
	     end;

	     return;

	end add_recipients;

     end process_message;
%page;
/* Checks if the user has explicitly included himself as a recipient of the reply:  If so, and -no_include_self is
   specified, the warning messages issued when excluding an implicit self reference will be suppressed */

check_if_explicit_self:
     procedure ();

	if ^is_empty_list (sdm_subsystem_info.to) then call check_single_list (sdm_subsystem_info.to);

	if ^is_empty_list (sdm_subsystem_info.cc) then call check_single_list (sdm_subsystem_info.cc);

	if ^is_empty_list (sdm_subsystem_info.bcc) then call check_single_list (sdm_subsystem_info.bcc);

RETURN_FROM_CHECK_IF_EXPLICIT_SELF:
	return;



/* Internal to check_if_explicit_self: actually performs the check */

check_single_list:
	procedure (p_address_list_ptr);

dcl  p_address_list_ptr pointer parameter;

dcl  address_ptr pointer;
dcl  address_idx fixed binary;

	     address_list_ptr = p_address_list_ptr;

	     do address_idx = 1 to address_list.n_addresses;
		address_ptr = address_list.addresses (address_idx);

		if mail_system_$compare_addresses (mlsys_data_$user_default_mailbox_address, address_ptr, (0))
		then do;
		     dont_issue_nis_warning = "1"b;	/* found an explicit match */
		     go to RETURN_FROM_CHECK_IF_EXPLICIT_SELF;
		end;

		else if compare_both_user_addresses then
		     if mail_system_$compare_addresses (mlsys_data_$user_mail_table_address, address_ptr, (0))
		     then do;
			dont_issue_nis_warning = "1"b;
			go to RETURN_FROM_CHECK_IF_EXPLICIT_SELF;
		     end;
	     end;

	     return;

	end check_single_list;

     end check_if_explicit_self;
%page;
/* Print the list of recipients of the message:  as many recipients as will fit on one line are printed with an indication
   of the total number in the list */

print_recipients_list:
     procedure ();

dcl  (recipients_list_ptr, address_ptr) pointer;
dcl  (n_recipients_left, address_idx) fixed binary;
dcl  n_recipients_left_picture picture "(8)z9";
dcl  include_comma bit (1) aligned;

dcl  recipients_list				/* the "Replying to..." message */
	character (get_line_length_$switch (iox_$user_output, (0)) - line_prefix_length ()) varying;

dcl  address_summary				/* the text for one address */
	character (get_line_length_$switch (iox_$user_output, (0)) - line_prefix_length ()) varying;


	recipients_list_ptr = null ();		/* for cleanup handler */

	on condition (cleanup)
	     begin;
	     if recipients_list_ptr ^= null () then call mail_system_$free_address_list (recipients_list_ptr, (0));
	end;

	do address_list_ptr = sdm_subsystem_info.to, sdm_subsystem_info.cc, sdm_subsystem_info.bcc;
	     if is_empty_list (address_list_ptr) then	/* nothing in this one: however, at least one isn't empty */
		code = 0;
	     else call mail_system_$merge_address_lists (recipients_list_ptr, address_list_ptr, "0"b,
		     recipients_list_ptr, code);
	     if code ^= 0 then do;
CANT_GENERATE_RECIPIENTS_LIST:
		call ssu_$print_message (P_sci_ptr, 0, "Replying to ^d total recipient^[s^].", recipient_count,
		     (recipient_count ^= 1));
		go to RETURN_FROM_PRINT_RECIPIENTS_LIST;
	     end;
	end;

	recipients_list = "Replying to ";		/* prime the output */

	n_recipients_left = recipients_list_ptr -> address_list.n_addresses - 1;
						/* at least the first address appears */

	call mlsys_utils_$summarize_address (recipients_list_ptr -> address_list.addresses (1), "0"b, address_summary,
	     code);
	if code ^= 0 then go to CANT_GENERATE_RECIPIENTS_LIST;
	if ^is_room_for_address () then go to CANT_GENERATE_RECIPIENTS_LIST;

	recipients_list = recipients_list || address_summary;
	include_comma = "0"b;

	do address_idx = 2 to recipients_list_ptr -> address_list.n_addresses;
	     address_ptr = recipients_list_ptr -> address_list.addresses (address_idx);

	     n_recipients_left = n_recipients_left - 1;	/* insures the test will be oK */
	     call mlsys_utils_$summarize_address (address_ptr, "0"b, address_summary, code);
	     if (code ^= 0) & (code ^= error_table_$smallarg) then go to CANT_GENERATE_RECIPIENTS_LIST;

	     if code = 0 then			/* got the summary */
		if is_room_for_address () then do;	/* ... and it will fit */
		     if ^include_comma & (n_recipients_left > 0) then include_comma = "1"b;
		     if include_comma then recipients_list = recipients_list || ",";
		     if n_recipients_left = 0 then
			recipients_list = recipients_list || " and ";
		     else recipients_list = recipients_list || " ";
		     recipients_list = recipients_list || address_summary;
		end;
		else do;				/* ... but it won't fit on the line */
		     n_recipients_left = n_recipients_left + 1;
		     go to FINISH_AND_PRINT_RECIPIENTS_LIST;
		end;

	     else do;				/* address summary is too long */
		n_recipients_left = n_recipients_left + 1;
		go to FINISH_AND_PRINT_RECIPIENTS_LIST;
	     end;

	     include_comma = "1"b;			/* definitely need one now */
	end;

FINISH_AND_PRINT_RECIPIENTS_LIST:
	if n_recipients_left > 0 then do;
	     if include_comma then recipients_list = recipients_list || ",";
	     recipients_list = recipients_list || " and ";
	     recipients_list = recipients_list || ltrim (convert (n_recipients_left_picture, n_recipients_left));
	     if n_recipients_left = 1 then
		recipients_list = recipients_list || " other";
	     else recipients_list = recipients_list || " others";
	end;

	recipients_list = recipients_list || ".";

	call ssu_$print_message (P_sci_ptr, 0, "^a", recipients_list);

RETURN_FROM_PRINT_RECIPIENTS_LIST:
	if recipients_list_ptr ^= null () then call mail_system_$free_address_list (recipients_list_ptr, (0));

	return;



/* Internal to print_recipients_list: determines the length of the prefix printed by ssu_$print_message */

line_prefix_length:
	procedure () returns (fixed binary);

	     return (length (ssu_$get_subsystem_and_request_name (P_sci_ptr)) + length (":  "));

	end line_prefix_length;



/* Internal to print_recipients_list: determines if this address will fit in the remainder of the line */

is_room_for_address:
	procedure () returns (bit (1) aligned);

	     if n_recipients_left > 0 then
		return ((length (recipients_list) + length (address_summary) + length (", , and NNN others."))
		     <= maxlength (recipients_list));

	     else return ((length (recipients_list) + length (address_summary) + length (", and ."))
		     <= maxlength (recipients_list));

	end is_room_for_address;

     end print_recipients_list;
%page;
/* Adds a null reference name to the supplied profile: ssu_ will terminate a null refname when the send_mail invocation is
   destroyed but read_mail will still try to reference the profile; adding an extra null refname here makes everything
   work properly */

add_null_refname:
     procedure (p_profile_ptr);

dcl  p_profile_ptr pointer parameter;
dcl  new_profile_ptr pointer;
dcl  profile_dirname character (168);
dcl  profile_ename character (32);

	call hcs_$fs_get_path_name (p_profile_ptr, profile_dirname, (0), profile_ename, code);
	if code ^= 0 then call ssu_$abort_line (P_sci_ptr, code, "Copying state of read_mail abbrev processing.");

	call initiate_file_ (profile_dirname, profile_ename, R_ACCESS, new_profile_ptr, (0), code);
	if p_profile_ptr ^= new_profile_ptr then
	     call ssu_$abort_line (P_sci_ptr, code, "Copying state of read_mail abbrev processing.");

	return;

     end add_null_refname;



/* Determines if the supplied address list is empty */

is_empty_list:
     procedure (p_address_list_ptr) returns (bit (1) aligned);

dcl  p_address_list_ptr pointer parameter;

	if p_address_list_ptr = null () then		/* nothing there at all */
	     return ("1"b);

	else return ((p_address_list_ptr -> address_list.n_addresses = 0));

     end is_empty_list;
%page;
%include rdm_invocation;
%page;
%include rdm_message_list;
%page;
%include rdm_message_chains;
%page;
%include sdm_subsystem_info;
%page;
%include send_mail_options;
%page;
%include sdm_original_messages;
%page;
%include mlsys_data;
%page;
%include mlsys_parse_ca_options;
%page;
%include mlsys_message;
%page;
%include mlsys_address_list;
%page;
%include access_mode_values;
%page;
%include terminate_file;

     end rdm_reply_request_;
