* ***********************************************************
* *                                                         *
* * Copyright, (C) Honeywell Information Systems Inc., 1982 *
* *                                                         *
* * Copyright (c) 1972 by Massachusetts Institute of        *
* * Technology and Honeywell Information Systems, Inc.      *
* *                                                         *
* ***********************************************************

	lbl     ,g115_tables           
	ttl     g115_tables      
	editp	on
	pmc	off
	pcc     off        
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *       
*       
*       
*      g115_tables, g115        
*       
*           control tables for running high-speed device obeying           
*      g115 protocol      
*       
*      split off from control_tables by robert coren 4/29/76         
*       
*       
*      tables redone by joe nicholls and art beatie may-nov 1978        
*              the same general concepts were used, but the implementatio       
*              may be different.      
*	a number of redundencies have been built in to maintain a known
*		state of things, such as reseting variable and dumpins.
*       
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *       
	rem
	rem
g115	null	
	rem
	symdef	g115	
	symdef	gstar	
	symdef	g15acu	
	rem
	symref	begin	
	symref	hungup	
	symref	error	
	symref	acutst	
	symref	cvaddr	
	symref	frebfh
	symref	setbpt
	symref	cvabs
	rem
	pmc	save,on
	comreg
	tib
	meters	
	csbits	
	tconst	
	buffer	
	cctdef	
	pmc	restore
	rem
	base	64
cct.3	null	* cct for use with grts, terminate on etx + bcc	
	rem
	vfd 9/ct.ncs,9/ct.ncs * 000 001 
	vfd 9/ct.ncs,9/ct.grt * 002 etx 
	vfd 9/ct.ncs,9/ct.ncs * 004 005 
	vfd 9/ct.ncs,9/ct.ncs * 006 007 
	vfd 9/ct.ncs,9/ct.ncs * 010 011 
	vfd 9/ct.ncs,9/ct.ncs * 012 013 
	vfd 9/ct.ncs,9/ct.ncs * 014 015 
	vfd 9/ct.ncs,9/ct.ncs * 016 017 
	vfd 9/ct.ncs,9/ct.ncs * 020 021 
	vfd 9/ct.ncs,9/ct.ncs * 022 023 
	vfd 9/ct.ncs,9/ct.ncs * 024 025 
	vfd 9/ct.ign,9/ct.grt * syn etb 
	vfd 9/ct.ncs,9/ct.ncs * 030 031 
	vfd 9/ct.ncs,9/ct.ncs * 032 033 
	vfd 9/ct.ncs,9/ct.ncs * 034 035 
	vfd 9/ct.ncs,9/ct.ncs * 036 037 
	rem
	dup	1,48	
	vfd	9/ct.ncs,9/ct.ncs	
	start	g115,,w3gesm0a1000
	ttls	tib extension array definitions
	tibex	incnt,char	input char count	
	tibex	fctype,char	function code type obtained	
	tibex	optype,char	operation type of msg	
	tibex	acknak,char	ack or nak char for msg	
	tibex	seqcde,char	seq code to use in msg	
	tibex	prevsc,char	previous seq code used	
	tibex	xmtsc,char	xmited seq code	
	tibex	modtyp,char	mode type we are in for gwrrd	
	tibex	scrchr,char	storage for special control record char	
	tibex	tibchr,char	place to stroe msg addr for comparision
	tibex	rtnlbl,word	label to return to for gotov	
	tibex	ctlop,word	control word for line status new	
	tibex	ctlop1,word	second control word for 36 bits	
	tibex	ctlop2,word	some spare in tib	
	tibex	ctlop3,word	make it even 4 words control	
	tibex	msgchk,word	value of the check we did on the output message	
	tibex	outchn,word	addr of last output buffer to check
	tibex	bsyinc,word	count for counting delay waits for 68/80
	tibex	dlytim,word	time to wait for response
	tibex	gflags,word	word of flags in tib extension
	rem
	rem
trmchr	bool	000001	flag that remote is finished inputing
xnak	bool	000002	internal to keep track of our naking
rtntry	bool	000004	tried to allocate buffer before, so give up
early	bool	000010	flag to say that we received our response before
rmtcmp	bool	001000	for multics to multics init
	ttls 	g115 - defined values				
	rem		/* defined modtyp test values */	
actinp	bool	1	active, input	
inact	bool	2	inactive	
actot1	bool	3	active, output 1	
actot2	bool	4	active, output 2	
actot3	bool	10	mixed i/o mode	
inact1	bool	7	scr ($*$dis) received	
inact2	bool	5	rfd received	
inact3	bool	6	inactive, responding to a $*$OUT record
inact4	bool	11	inactive, inprocess of terminating
inact5	bool	12	we have output the terminate message
	rem
	rem
	rem
	rem		line status definitions for ctlop	
fspr	bool	1	spare line status	
fbld	bool	2	failure to build a message	
fxmit	bool	3	failure to xmit msg n time in a row	
fsoh	bool	4	failure to find soh chr in output msg	
fetx	bool	5	failure to find ext chr at end of output msg	
fmod	bool	6	bad mode in tib we will terminate and start over	
notimp	bool	7	line control order not implemented in these table	
otpend	bool	10	yes you have output pending	
discrd	bool	11	portion of pending output was deleted before sent	
lngmsg	bool	12	the assembled message was too long >324 character	
	rem
	rem
	rem		line control definitions for ctlop	
	rem		try to keep the same values as the bisinc tables	
lctrmt	bool	3	set for remote mode
lcttwr	bool	5	see if output is pending	
lctrrt	bool	6	set for host mode (reset remote mode)
	rem
	rem
	rem
	rem
	rem		/* defined fctype test values */	
srvmes	bool	1	service message	
scrmes	bool	2	special contrl record	
infmes	bool	3	information message	
	rem
	rem
	rem
	rem		/* defined operation code test values */	
opnorq	bool	0	no request	
optdat	bool	2	transmite data
opwait	bool	4	wait tosend output	
	rem
	rem
	rem
	rem		/* defined instruction code test values */	
noinst	bool	0	no instruction	
select	bool	2	select	
termin	bool	3	terminate	
rdyfd	bool	4	ready for disconnect	
notrfd	bool	5	not ready for disconnect	
disc	bool	6	disconnect	
	rem
	rem
	rem
	rem		/* defined format codes */	
sm102	bool	102	upper case b
sm103	bool	103	upper case c
scr104	bool	104	upper case d
scr105	bool	105	upper case e
inf110	bool	110	upper case h
inf111	bool	111	upper case i
inf112	bool	112	upper case j
inf113	bool	113	upper case k
inf115	bool	115	upper case m
	rem
	rem
	rem		/* defined scan masks */	
opmask	bool	7	
ackmsk	bool	70	
	rem
	rem
	rem
	rem		/* defined output chars */	
chr027	bool	027	end of transmission block etb	
chr036	bool	036	record separator	
chr040	bool	040	ascii blank and slew top	
chr044	bool	044	ascii dollar sign	
chr052	bool	052	ascii asterisk	
chr101	bool	101	one transmit seq code	
chr100	bool	100	address/identification code	
chr103	bool	103	terminate,ack	
chr102	bool	102	transmit data op,ack	
chr061	bool	061	scr - abort code	
chr010	bool	010	nak bit in operation code	
chr104	bool	104	ready for disconnect code	
chr105	bool	105	upper case e	
chr111	bool	111	upper case i	
chr112	bool	112	upper case j
chr114	bool	114	upper case l and printer mc	
chr116	bool	116	upper case n and teleprinter mc	
chr117	bool	117	upper case o and printer mc	
chr123	bool	123	upper case s	
chr124	bool	124	upper case t	
chr125	bool	125	upper case u	
chr131	bool	131	upper case v	
	eject
	rem		gocase variable value and jump lists	
ginopt	chstr	(disc,rdyfd,select)	
ginout	adrlst	(gdis,grfd,gsel)	
	rem
	rem
redop	chstr	(disc,rdyfd,termin,notrfd,select)	
redopj	adrlst	(gdis,grfd,gterm)	
srjmp	adrlst	(gdis,grfd1,gterm1,wrecnk)
opotjm	adrlst	(gdis,grfd1,outtrm,wrecnk,gterm1)
	rem
etxcmp	chstr	(actot2,actot3)	
etxjmp	adrlst	(getmor,getmor)	
wrjmp	adrlst	(output,output)	
sohjmp	adrlst	(gterm,gterm)	
	rem
otptfc	chstr	(srvmes,scrmes)	
otptfj	adrlst	(otckop,otcksc)	
redjmp	adrlst	(redsrv,scrrcv)	
	rem
wextmd	chstr	(actinp,inact,inact1,actot1,actot2,actot3,inact3,inact4,i	
	etc	nact2,inact5)
wextjp	adrlst	(gredin,gidle,gdis,outsrv,output,output,gterm,gterm,gdis
	etc	,endtrm)
sctjmp	adrlst	(ginlop,gidle,gdis,gout,goodsc,goodsc,gterm1,endtr1,gdis,
	etc	endtr1)
	rem
fccmp	chstr	(sm102,sm103,scr104,scr105,inf110,inf111,inf112,inf113,in
	etc	f115)
fcjmp	adrlst	(fcsm,fcsm,fcscr,fcscr,fcinf,fcinf,fcinf,fcinf,fcinf)	
	rem
opck	chstr	(select,termin)	
opjmp	adrlst	(gckret,gckret)	
	rem
	pmc	save,on
scrcmp	chstr	(chr101,chr102,chr103,chr104,chr105,chr117)	
scrjmp	adrlst	(scra,scrqut,scrqut,scrd,scre,scro)	
	rem
norcmp	chstr	(inact1,inact2,inact3,inact4,inact5)
norjmp	adrlst	(gdis,gdis,gterm1,endtr1,endtr1)
	rem
trmcmp	chstr	(inact,inact5,inact4)
trmjmp	adrlst	(gidle,endtrm)
trmabt	adrlst	(gterm,endtr1,gterm1)
	rem
msgcmp	chstr	(fsoh,fetx,lngmsg,discrd)	
msgjmp	adrlst	(ftfsoh,ftfetx,flong,gwrdrd)	
	rem
otptoc	chstr	(opnorq,optdat)
otptoj	adrlst	(goodot,goodot)
	rem
outopt	chstr	(noinst,disc,rdyfd)
outopj	adrlst	(goutpt,gdis,grfd)
	rem
msglcm	chstr	(actinp,actot3,inact3,inact4,inact5)
msgljm	adrlst	(synbld,synbld,synbld,synbld,synbld)
	pmc	restore
	eject
	rem		/* canned output messages */	
tdomsg	chstr	(soh,inf110,null,chr100,chr102,chr100,stx,etx,seteom)	
tnkmsg	chstr	(soh,inf110,null,chr100,chr112,chr100,stx,etx,null,seteom
	etc	)
synmsg	chstr	(syn,syn,syn,syn)	
trmmsg	chstr	(soh,sm102,null,chr100,chr103,chr100,stx,etx,seteom)	
selmsg	chstr	(soh,sm102,null,chr100,chr102,chr100,stx,etx,seteom)	
rfdmsg	chstr	(soh,sm102,null,chr100,chr104,chr100,stx,etx,seteom)	
tdormt	chstr	(soh,sm102,null,chr100,chr100,chr100,stx,etx,seteom)
tdack	chstr	(soh,inf110,null,chr100,chr100,chr100,stx,etx,seteom)
wakmsg	chstr	(soh,inf110,null,chr100,chr104,chr100,stx,etx,seteom)
dismsg	chstr	(soh,scr104,null,chr100,chr100,chr100,stx,chr116,chr104,c	
	etc	hr111,chr123,chr036,etx,seteom)	
ndamsg	chstr	(soh,inf110,null,chr100,chr102,chr100,stx,chr116,chr116,c	
	etc	hr117,chr040,chr104,chr101,chr124,chr101,chr036,etx,seteo	
	etc	m)	
dlrout	chstr	(soh,scr104,null,chr100,chr100,chr100,stx,chr116,chr044,c
	etc	hr052,chr044,chr117,chr125,chr124,chr036,etx,seteom)
	rem
	rem
	rem
	rem		/* outscn contrl lists */	
octrl1	chstr	(rescan,search,soh,ignore,ignore,replac,xmtsc)	
octrl2	chstr	(rescan,search,soh,ignore,strlrc,search,etx,ignore,outlrc	
	etc	,ignore,replac,null)	
octrl3	chstr	(rescan,search,soh,ignore,ignore,ignore,ignore,setbit,chr	
	etc	010)	
octrl4	chstr	(rescan,search,soh,ignore,ignore,ignore,ignore,offbit,ack	
	etc	msk)	
octrl5	chstr	(rescan,search,soh,ignore,strlrc,search,chr027,ignore,out
	etc	lrc,ignore,replac,null)
octrl6	chstr	(rescan,search,soh,ignore,strlrc,search,eot,ignore,outlrc
	etc	,ignore,replac,null)
	rem
	rem
	rem
	rem		/* inscan contrl lists */	
adrscn	chstr	(rescan,search,soh,ignore,ignore,ignore,movchr,tibchr)
fcscan	chstr	(movchr,fctype)	
ictrl1	chstr	(rescan,search,stx,ignore,ignore,match,chr061)	
ictrl2	chstr	(rescan,search,soh,ignore,strlrc,search,etx,ignore,cmplrc	
	etc	,replac,null)	
ictrl4	chstr	(ignore,movchr,seqcde,ignore,ignore,movmsk,optype,opmask,	
	etc	movmsk,acknak,ackmsk)	
ictrl6	chstr	(search,stx,ignore,count,incnt,search,etx)	
ictrl7	chstr	(rescan,search,soh,ignore)	
ictrl9	chstr	(rescan,search,stx,ignore,count,incnt,search,chr027)	
icldlr	chstr	(rescan,search,stx,ignore,ignore,match,chr044,ignore,matc
	etc	h,chr052,ignore,match,chr044,ignore,movchr,scrchr,ignore)	
iclabt	chstr	(match,chr102,ignore,match,chr124)	
iclout	chstr	(match,chr125,ignore,match,chr124)	
icldis	chstr	(match,chr111,ignore,match,chr123)	
iclend	chstr	(match,chr116,ignore,match,chr104)	
	ttl	new g115 tables
	ttls 	g115 line initialization				
gstar	tstflg	tfacu,acutst	must dial phone first	
	tstflg	tflisn,glisn	see if 68/80 told us to listen	
	wait	0,0,begin	if not wait for him to tell us	
	rem
	rem
	rem
glisn	contrl	sdtr+stat	set our minimum leads needed	
	wait	0,0,gntint	wait for 115 or hangup order	
	rem		we only need to see if modem is there,	
	rem		we dont care if the phone rings or not since	
	rem		dtr is set up before we look at the line	
	status	dsr,0,gonlin	we have the terminal	
g15acu	nullop		return here after acu dials up	
gonlin	tstflg	tfdlup,setdpx	cluge to set duplex until cmf is updated	
	setflg	tffdpx	force that we are full duplex if not dialup
	contrl	srts+stat	full duplex	
	wait	0,0,gntint	wait for cd and cts	
	status	cd+cts,0,gtell	have full duplex line	
setdpx	clrflg	tffdpx	force that we are half duplex if dialup	
gtell	getext	,errtib	get tib extension	
	setcct	cct.3	get default cct	
	clrlcf	gflags,trmchr+rmtcmp	make sure we start in known state	
	setlcl	dlytim,8	set delay to assume host timing
	calsub	dmpall	and no output	
	signal	dialup	finally tell moma we are here	
	setchr	modtyp,inact	we are doing nothing yet	
	setflg	tfmrcv	only need space for one msg
	goto	gidle	go do our thing	
	rem
	rem
errtib	goto	ghangn	cant do a thing without it	
	rem		at this time the only other thing is to punt	
	rem		but we dont want to take everybody with us	
	ttls 	g115 idle loop					
gidle	tstflg	tfhang,ghang	see if 68/80 told us to hangup	
	setlcl	bsyinc,0	just incase we fell out while stalling
	tstlcf	gflags,trmchr,gottst if terminated, ok to output	
girec	setflg	tfcrcv	only looking for a select msg
	contrl	srec+rxmit	set to receive mode	
	setime	5	give 115 5 seconds to talk	
	wait	gidle,gidle,gtest wait to see what happend first	
	status	brkchr,0,gin	got something from 115	
	status	0,dsr,ghang	115 went home early	
	status	parity,0,gipar	ignor bad data here	
	status	exh,0,exhlim	we ate too much	
	rem
gottst	tstwrt	gout	got data to give out	
	goto	girec	no so go check receive now	
	rem
gipar	meter1	m.par,1
	stpchn		whooo horse	
	dumpin		and throw the garbage out	
	goto	gidle	
	ttls 	g115 input from remote routine				
gin	contrl	rrec+smark	get out of rec mode
	wait	0,0,gtest
	status	marker,0,ginset
	status	exh,0,exhlim
	status	0,dsr,ghang
	rem
ginset	calsub	gckin	see what we got	
	cmpchr	fctype,srvmes,ginput did we get a select msg	
ginbad	dumpin		no so forget it	
	goto	gidle	
ginput	gocase	optype,ginopt,ginout have something but what is it	
	goto	ginbad	nothing that we want	
	rem
gsel	dumpin		throw out select msg	
	setchr	prevsc,seqcde	save seq code we got	
	goto	rednda	go ack select or do output
	rem
	rem

	rem		return here after remote responds	
	rem		with next input	
gredin	gocase	fctype,otptfc,redjmp see what data was sent us	
	cmpchr	incnt,null,rednda if no chars dont give it to anybody	
ginlop	calasm	ckibsy	see if dia has completed last input yet	
	tstflg	tfhang,ghang	are we going home now?	
	tstlcl	msgchk,1,gbusy if msgchk is one, dia has not finished	
	tstlcl	bsyinc,0,shipit if 0 have msg to send in
	dumpin		else have not got new msg yet
	goto	rednda	and since channel was still in receive
	rem		should dump and not send in possible noise
shipit	meterm	0	record input message
	sendin		give it to 68/80	
rednda	setchr	modtyp,actinp	we are active input	
	setlcl	bsyinc,0	we are not stalling now
	clrlcf	gflags,rtntry	say first try	
	setlcl	rtnlbl,tdobld	where to come for second try	
tdobld	tstlcf	gflags,rmtcmp,rmttdo if we are remote ack with no request msg
	bldmsg	tdomsg,ftbld	build xmit data msg	
	goto	gwrrd	go output the msg	
	rem
rmttdo	cmpchr	fctype,srvmes,rmtack if srv msg use srv msg no req as ack
	bldmsg	tdack,ftbld	else us info no req as ack
	goto	gwrrd
	rem
rmtack	bldmsg	tdormt,ftbld bld no req msg
	goto	gwrrd
	rem
	rem
gbusy	tstlcl	bsyinc,0,bsysnd is this the first stall wait
	goto	stalit	if not, just go stall
bsysnd	meterm	0
	sendin		if so move pending input to safe place from dumpin
stalit	meter2	m.cnt4,1	keep track of this
	tstlcf	gflags,rmtcmp,rmtbsy if rmt we wak instead
	tstwrt	gbusyo	does mother have output?	
	tstlcl	bsyinc,12,bsyinp we waited 10 half seconds
	addlcl	bsyinc,1	incr busy counter
	setime	-500	give us a one half second to wait	
	wait	ginlop,gbusyo,gtest wait and see what to do next	
	status	0,dsr,ghang	left us cold did he?	
	status	exh,0,exhlim	dont allow data forced down our throat
	rem
gbusyo	cmpchr	modtyp,actot3,gwrrd if still outputing just go do it
	setchr	modtyp,actot3	output so say we are mixed io	
	goto	gwrrd	go output	
	rem
	rem
bsyinp	setlcl	bsyinc,1	say we are still stalling
	setchr	modtyp,actinp	aviod confussion, this is an active input
	clrlcf	gflags,rtntry	say first try
	setlcl	rtnlbl,tnklbl	where to come for second try
tnklbl	bldmsg	tnkmsg,ftbld	nak last input as a stall since a wait
	goto	gwrrd	msg is not defined to the remote
	rem
redsrv	gocase	optype,redop,redopj see what optype we have	
	dumpin		not of interest	
	goto	rednda	go try again	
	rem
rmtbsy	setlcl	bsyinc,1	we are stalling but who cares if were rmt
	clrlcf	gflags,rtntry	say first try
	setlcl	rtnlbl,waklbl	where to come for second try
waklbl	bldmsg	wakmsg,ftbld	send a wait msg
	goto	gwrrd
	ttls	output from main frame routine			 
gout	stpchn		hold on boys our turn now	
	dumpin		throw it to the dogs	
	clrlcf	gflags,rtntry	first time	
	setlcl	rtnlbl,selbld	where to come for second try	
selbld	bldmsg	selmsg,ftbld	try and get the line for us	
	setchr	modtyp,actot1	say we want the line	
	goto	gwrrd	ship it!	
	rem
	rem
	rem		come here after response to our select	
outsrv	cmpchr	fctype,srvmes,outopc if not service forget it unless multics to multics
	tstlcf	gflags,rmtcmp,cktdms if remote look for trans data msg
	goto	gout	if not, try select again
	rem
cktdms	cmpchr	fctype,infmes,outinf check for xmit data msg
	goto	gout	else try select again	
	rem
outinf	dumpin		if xmit data, input not dmped previously
	cmpchr	optype,optdat,goutpt if xmit data, ok, if not bad
	rem
outopc	gocase	optype,outopt,outopj see what type returned
	tstlcf	gflags,rmtcmp,outrmt see if we are remote
	goto	gout	try again if not
outrmt	cmpchr	optype,select,gsel if so we must give in
	goto	gout	else not what we expected
	rem
goutpt	meterm	1	count output message
	setchr	modtyp,actot2	we are outputing data	
	goto	gwrrd
	rem
	rem
	rem		return point for outputing data	
	rem		after we have the line from a select	
output	gocase	fctype,otptfc,otptfj see what function returned	
	cmpchr	incnt,null,outnch were any chars returned
	dmpout		get rid of the msg we sent
	goto	ginlop	assume that this is multics to multics
	rem
outnch	gocase	optype,otptoc,otptoj if a norequest or trans data, good
	goto	wrecnk	if not bad
	rem
	rem
otcksc	dmpout		clear our output msg first
	goto	scrrcv	go process special control record
	rem
otckop	gocase	optype,redop,opotjm if so resync logical line
	rem		if terminate we want to send quit to 68/80
	goto	wrecnk	any other service msg is considered a nak
	rem
	rem
goodot	dumpin		throw out 115 return msg	
goodsc	dmpout		dump the output msg we are thru with it	
	tstwrt	morout	more 68/80 output?	
	cmpchr	modtyp,actot3,ginlop if mixed io go back	
	setimv	dlytim	give 7 secs to	
	wait	otck68,gwrrd,gtest wait for output from 68/80	
	status	0,dsr,ghang	
	status	exh,0,exhlim	watch for runaway channel
otck68	tstwrt	gwrrd	just made it for output, one last check	
	tstlcf	gflags,rmtcmp,rmtout are we remote
	goto	gterm
rmtout	clrlcf	gflags,rtntry
	setlcl	rtnlbl,mulout
mulout	bldmsg	dlrout,ftbld	output the $*$out msg
	setchr	modtyp,inact4	equal to a terminate
	goto	gwrrd
	rem
outtrm	tstlcf	gflags,rmtcmp,gterm1 if remote term means term
	goto	scrqut	else term means quit
	ttls 	g115 routine to write and then read the response			
morout	meterm	1	meter next output message
gwrrd	calasm	ckomsg	go check the msg to output	
	gocase	msgchk,msgcmp,msgjmp see if msg was good or not	
	rem		if we fall through it was good	
	goto	synlbl	and go and the syn chars	
gwrdrd	dmpout		dump the bad first part of the msg	
synlbl	clrlcf	gflags,rtntry	first time	
	setlcl	rtnlbl,synbld	where to come for second time	
	clrflg	tfcrcv	reset for idle may have set it again
	gocase	modtyp,msglcm,msgljm if inputing get bigger buffer
	setflg	tfcrcv	else only expect a control msg
synbld	bldmsg	synmsg,ftbld	add 4 syn chars to front of msg	
	cmpchr	modtyp,actinp,ckstal see if inputing
	goto	notstl	if not skip all this garbage
ckstal	tstlcl	bsyinc,0,notstl	see if stalling
	holdot		save this for possible re-xmit
	goto	wckdpx	if so, send an erroneous msg so the level 6 will
	rem		send the msg again with a nak and we with
	rem		selectivly throw that msg away as a stall
	rem		since the host does not have a defined wait
notstl	scntr	0	init retry cntr to 0	
	clrlcf	gflags,xnak	internal, first time always acking
	cmpchr	xmtsc,chr101,seqcd2 deside on which seq cd to use	
	setchr	xmtsc,chr101	use #1	
	goto	setsqc	go set the seq code	
seqcd2	setchr	xmtsc,chr102	have 1 so set it to #2	
setsqc	outscn	octrl1,ftfsoh	place seq code	
	clrlcf	gflags,rtntry	first time	
	setlcl	rtnlbl,setlrc	where to come for second time	
setlrc	outscn	octrl2,lrcetx	set lrc character	
	holdot		save output for rexmit if neccessary	
	goto	wckdpx	do the output
lrcetx	outscn	octrl5,ftbld	no etx,try etb
	holdot		save this for xmit again latter
	goto	wckdpx	go do our thing
	rem
lrceot	outscn	octrl6,ftbld	no etb, try eot, else give up
	holdot
	rem
	rem
wckdpx	clrlcf	gflags,early	looking for new response
	tstflg	tffdpx,wfdpx	see which duplex to output with	
	contrl	srts+stat	half duplex	
	setime	1	wait for 1 sec	
	wait	ftxmit,0,gtest	for line to turn around	
	status	0,dsr,ghang	
	status	cts,0,wgotln	we got the line	
	status	exh,0,exhlim	watch for runaway channel
	rem
wgotln	dcwlst		set up the dcw list	
	cmd	sxmit+srec	go into xmit mode and possible response
	output	(outmsg)	send data out	
	cmd	sterm+rxmit	wait for msg to go out	
	wait	0,0,gtest	wait for status change	
	status	0,dsr,ghang	
	status	brkchr,0,elyrsp	fast wasn't he.
	status	exh,0,exhlim	watch for runaway channel
	status	0,cts,wrlost	lost line so try again	
	status	term,0,wgood	output terminated properly	
	rem
wgood	contrl	rrts+stat	ready ourselves for input	
	tstlcf	gflags,early,lintrn already have our response
	setimv	dlytim	wait 7 secs	
	wait	norsp,0,gtest	for a response	
	status	0,dsr,ghang	
	status	cd,0,lintrn	turned line properly	
	status	exh,0,exhlim	watch for runaway channel
	rem
	rem
wfdpx	dcwlst		bld dcw list for full dplx line	
	cmd	sxmit+srec	ready for output and input for full dpx	
	output	(outmsg)	go do it	
	cmd	sterm+rxmit	ready for response	
	wait	0,0,gtest	wait for output tp finish	
	status	0,dsr,ghang	
	status	brkchr,0,elyrsp	fast son-of-a-gun
	status	exh,0,exhlim	watch for runaway channel
	status	term,0,lintrn	output finished properly	
	rem
elyrsp	setlcf	gflags,early	note that we have our response already
	waitm		go finish what we were doing
	rem
lintrn	cmpchr	modtyp,inact4,trmchk if trminate msg, say we did it
	goto	rspwat	else just go wait for response
trmchk	setchr	modtyp,inact5 say we sent it and dont do it again
rspwat	tstlcf	gflags,early,wrecrp already have our response
	contrl	stat	see if anything interesting has happened
	setimv	dlytim	give us 7 secs	
	wait	norsp,0,gtest	wait for a response	
	status	0,dsr,ghang	
	status	brkchr,0,wrecrp	got a response
	status	parity,0,gwrpar nak bad parity	
	status	exh,0,exhlim	we ate too much go dmp it	
	rem
wrecrp	contrl	rrec+smark	get out of rec mode
	wait	0,0,gtest	wait for rec to be reset
	status	marker,0,recrst	then continue
	status	exh,0,exhlim
	status	0,dsr,ghang
	rem
recrst	calsub	gckin	see what we got	
	cmpchr	fctype,null,wrnak error in response	
	cmpchr	incnt,null,wcknak no data in response	
	cmpchr	seqcde,prevsc,wckxnk same seq code	
	goto	wsvsc	response ok save seq code	
	rem
wckxnk	tstlcf	gflags,xnak,wcknak see if we really already processed it
	dumpin		yes, (data msg with same seq code) dont need it
	setchr	incnt,null	keep things consistant
	rem
wcknak	cmpchr	acknak,nak,wrecnk got a nak	
	rem
wsvsc	setchr	prevsc,seqcde	save the seq code	
	cmpchr	fctype,srvmes,wsvmes service msg	
	cmpchr	optype,opwait,wopwt need to wait 7 secs	
wrtok	gocase	modtyp,etxcmp,wrjmp output msg sent ok	
	dmpout		we dont need it any more	
	gocase	modtyp,wextmd,wextjp exit based on mode	
	goto	badmod	
	rem
	rem
gwrpar	meter1	m.par,1
	stpchn		bad parity so throw it away	
	dumpin	
	goto	wrnak	and nak the msg	
	rem
wsvmes	gocase	modtyp,etxcmp,wrjmp if active output, let output decide what to do
	gocase	optype,redop,srjmp see if srv msg needs processing
	goto	wrtok	message received ok	
	rem
wopwt	dumpin		throw away the wait message	
	meter2	m.cnt4,1
	outscn	octrl4,ftfsoh	set ack in byte
	setimv	dlytim	set time for 7 secs	
	wait	wckdpx,0,gtest	re-xmit after 7 secs	
	status	0,dsr,ghang	
	status	exh,0,exhlim	watch for runaway channel
	rem
wrecnk	dumpin		finished with input msg	
	setchr	incnt,null	just to keep info consistant
	outscn	octrl4,ftfsoh	set ack in ic byte	
	clrlcf	gflags,xnak	internal to say we are acking
	cmpchr	modtyp,actinp,ckbyin in inputing, check some more
	goto	wrlost	keep triing until he says ok
	rem
ckbyin	tstlcl	bsyinc,0,wrlost	if not busy bad msg
	dmpout		cleanup the msg we forced out
	goto	ginlop	else things are backing up
	rem
norsp	meter2	m.cnt3,1
	gocase	modtyp,norcmp,norjmp Level 6 may or may not answer our msg
	goto	wrlost	get back to idle state
	rem
	rem
wrnak	outscn	octrl3,ftfsoh	set nak bit in ic byte	
	setlcf	gflags,xnak	internal to say we are naking
wrlost	meter2	m.cnt2,1
	acntr	1	bump retry counter	
	tcntr	10,ftxmit	too many xmition failures	
	goto	wckdpx	go try again	
	ttls 	routine to test orders from main frame			
gtest	tstflg	tfhang,ghang	told to hangup	
	tstflg	tfwabt,gpgwrt	write abort, purge output	
	tstflg	tfrabt,gpginp	read abort,purge input	
	linctl	ctlop,tstret	if no line control order just return	
	tstlcl	ctlop,lcttwr,gtstot see if output pending for him	
	tstlcl	ctlop,lctrmt,gtstrc are we to set remote mode
	tstlcl	ctlop,lctrrt,gtstrr are we ro reset remote mode
	setlcl	ctlop,notimp	else line control order not implemented	
	setlcl	ctlop1,0	set second 18 bits	
	setlcl	ctlop2,0	zero 3rd 18 bits	
	setlcl	ctlop3,0	zero 4th 18 bits	
	linsta	ctlop	go tell 68/80 we have no response	
tstret	waitm		not interested in anything else	
	rem
	rem
gntint	tstflg	tfhang,ghangn	hangup without tib ext	
	waitm		dont care	
	rem
	rem
gpgwrt	stpchn		hold on for a second	
	calsub	dmpall	purge all output	
	clrflg	tfwabt	reset this flag	
	tstflg	tfrabt,gpginp	see if read abort also is set	
	gocase	modtyp,trmcmp,trmabt if teminating dont re-xmit
	goto	gterm	send terminate msg	
	rem
	rem
gpginp	stpchn		stop everything here also	
	dumpin		purge all input	
	clrflg	tfrabt	reset this flag	
	gocase	modtyp,trmcmp,trmabt if terminating dont re-xmit
	goto	gterm	
	rem
	rem
	rem
gtstot	tstwrt	tstsot	if pending output tell 68/80, he asked us	
	setlcl	ctlop,0	say we have no data	
	goto	gtstrt	go return the info	
tstsot	setlcl	ctlop,otpend	say we have output pending	
gtstrt	setlcl	ctlop1,0	set second 18 bits	
	setlcl	ctlop2,0	zero 3rd 18 bits	
	setlcl	ctlop3,0	zero 4th 18 bits	
	linsta	ctlop	go tell 68/80 his answer	
	waitm		go back from where we came	
	rem
gtstrc	setlcf	gflags,rmtcmp+trmchr say to act as remote
	setlcl	dlytim,6	set timer as if we are remote
	waitm
	rem
gtstrr	clrlcf	gflags,rmtcmp say to act as host
	setlcl	dlytim,8	set timer as if host
	waitm
	ttls	routines to give main frame a status indication		
ftbld	tstlcf	gflags,rtntry,bldfld see if we tried this before	
	setime	1	if not wait 1 sec and try again	
	wait	bldwt,0,gtest	
	status	0,dsr,ghang	watch out	
bldwt	setlcf	gflags,rtntry	say we tried this once	
	gotov	rtnlbl	go try again	
bldfld	meter2	m.cnt8,1
	setlcl	ctlop,fbld	failure to bld message for output	
	setlcl	ctlop1,0	zero second 18 bits	
	setlcl	ctlop2,0	zero 3rd 18 bits	
	setlcl	ctlop3,0	zero 4th 18 bits	
	linsta	ctlop	give this status to host	
	goto	ghang	go hangup the line can do nothing	
	rem
ftxmit	meter2	m.cnt5,1
	setlcl	ctlop,fxmit	unable to send good output	
	setlcl	ctlop1,0	zero second 18 bits	
	setlcl	ctlop2,0	zero 3rd 18 bits	
	setlcl	ctlop3,0	zero 4th 18 bits	
	linsta	ctlop	give this status to host	
	goto	gterm1	cleanup and idle
	rem
ftfsoh	meter2	m.cnt6,1
	setlcl	ctlop,fsoh	failure to find soh on output msg	
	setlcl	ctlop1,0	zero second 18 bits	
	setlcl	ctlop2,0	zero 3rd 18 bits	
	setlcl	ctlop3,0	zero 4th 18 bits	
	linsta	ctlop	tell 68/80	
	dmpout		get rid of bad msg	
	gocase	modtyp,etxcmp,sohjmp if from 68/80 his problem	
	goto	ghang	else our problem	
	rem
ftfetx	meter2	m.cnt6,1
	gocase	modtyp,etxcmp,etxjmp if output from mother it is her problem	
	setlcl	ctlop,fetx	failure to find ext in canned output msg	
	setlcl	ctlop1,0	0 second 18	
	setlcl	ctlop2,0	zero 3rd 18 bits	
	setlcl	ctlop3,0	zero 4th 18 bits	
	linsta	ctlop	say we have a problem	
	goto	ghang	so forget this whole bussiness	
getmor	signal	sndout	ask for more data please	
	setimv	dlytim	give 68/80 7 seconds to come up with something	
	wait	nomore,morout,gtest if not, dump and terminate	
	status	0,dsr,ghang	watch out	
	status	exh,0,exhlim	watch for runaway channel
nomore	calasm	ckochn	one last chance to see if sliped in before wait
	tstlcl	outchn,0,gterm1 if 0 68/80 did not give more so dump it
	goto	gwrrd	else we got more so go try to output this
	rem
	rem
badmod	setlcl	ctlop,fmod	say we have a bad mode in tib	
	setlcl	ctlop1,0	zero second 18 bits	
	setlcl	ctlop2,0	zero 3rd 18 bits	
	setlcl	ctlop3,0	zero 4th 18 bits	
	linsta	ctlop	tell host about our confussion	
	calsub	dmpall	start with a clean slate	
	dumpin		also dump the input	
	goto	gterm	
	rem
	rem
flong	meter2	m.cnt7,1
	setlcl	ctlop,lngmsg	message was too long	
	setlcl	ctlop1,0	zero 2nd 18 bits	
	setlcl	ctlop2,0	zero 3rd 18 bits	
	setlcl	ctlop3,0	zero 4th 18 bits	
	linsta	ctlop	tell 68/80	
	dmpout		get rid of bad msg	
	gocase	modtyp,etxcmp,sohjmp if from 68/80 go terminate	
	goto	ghang	else our problem so hangup	
	ttls	routines to end a dialog				
gterm1	dmpout		if had no resp must dmp our msg
gterm	dumpin		throw away the input
	gocase	modtyp,trmcmp,trmjmp already terminated or "ing"
	setchr	modtyp,inact4	end of input or output	
	setlcf	gflags,trmchr	set the terminate flag	
	clrlcf	gflags,rtntry	say first time	
	setlcl	rtnlbl,trmbld	where to come for second try	
trmbld	bldmsg	trmmsg,ftbld	set up terminate msg	
	goto	gwrrd	go output term msg	
	rem
endtr1	dmpout		if no resp must dmp out output
endtrm	dumpin		make sure we are clean
	setchr	modtyp,inact	say we are truely inactive
	goto	gidle	go rest for a while
	rem
	rem
	rem
gdis	stpchn		received disconnect	
	dumpin		get rid of input if any	
	calsub	dmpall	get rid of all output	
	clrlcf	gflags,trmchr	lets reset things
	setchr	modtyp,inact	we are now inactive	
	goto	gidle	go rest	
	rem
	rem
	rem
grfd1	dmpout		dump out old msg we had sent
grfd	dumpin		ready for disconnect	
	clrlcf	gflags,rtntry	first time	
	setlcl	rtnlbl,rfdbld	where to come for second try	
rfdbld	bldmsg	rfdmsg,ftbld	generate rfd msg in response	
	setchr	modtyp,inact2	set this mode	
	goto	gwrrd	go put the msg out	
	ttls	processing of special control records
scrrcv	cmpchr	incnt,3,scrabt	only 3 chars returned	
	goto	scrmor	if more or less further checking
scrabt	inscan	ictrl1,passin	abort msg?	
	goto	scrqut	abort so go quit
scrmor	inscan	icldlr,passin	check for $*$ in this record	
	gocase	scrchr,scrcmp,scrjmp go check this special control record	
	goto	passin	nothing we expected so  give it to Multics	
	rem
scra	inscan	iclabt,passin	check for abort msg	
	goto	scrqut	if so go quit 68/80	
scro	inscan	iclout,passin	check for out msg	
	setlcf	gflags,trmchr	yes so set terminate flag	
	dumpin		we are through with it
	tstwrt	gterm	if output, go do it now
	setime	5	give us 5 secs to	
	wait	noout,gterm,gtest wait for output	
	rem		if no data send not data msg	
	status	0,dsr,ghang	self explanitory	
	status	exh,0,exhlim	watch for runaway channel
noout	setchr	modtyp,inact3	waiting for response from NO DATA
	clrlcf	gflags,rtntry	first time	
	setlcl	rtnlbl,bldnda	where to come to try again	
bldnda	bldmsg	ndamsg,ftbld	build no data msg	
	goto	gwrrd	go output it	
	rem
scrd	inscan	icldis,passin	check fr a disconnect msg	
	setchr	modtyp,inact1	we are in process of disconnecting	
	dumpin		get rid of old dis msg	
	clrlcf	gflags,rtntry	first try	
	setlcl	rtnlbl,disbld	where to come for second try	
disbld	bldmsg	dismsg,ftbld	bld our own dis msg to the 115	
	goto	gwrrd	go output our disconnect	
	rem
scre	inscan	iclend,passin	check for an end msg	
	goto	gterm	if so go terminate	
	rem
exhlim	meter2	m.exh,1
	stpchn		hold everything, its too much	
	rem		and start over again	
scrqut	dumpin		get rid of msg	
	signal	quit	quit to 68/80	
	calsub	dmpall	dump all the output	
	goto	gterm	go terminate this dialog	
	rem
passin	cmpchr	incnt,null,scrrtn nothing to give 68/80
	cmpchr	modtyp,actinp,scrrtn if actinp let input do the sendins
	sendin		give it to the 68/80
scrrtn	gocase	modtyp,wextmd,sctjmp go back
	goto	badmod	bad data in tib
	ttls	routine to hangup the line				
ghang	retext		release the tib extension	
ghangn contrl	rxmit+rrec+rdtr+rrts lower all the contrl lines	
	setime	5	wait 5 secs for modem to follow	
	wait	ghg,0,0	
	status	0,dsr,ghg	modem did its thing	
ghg	stpchn		make sure all is stopped	
	signal	hangup	tell momma he went home	
	calsub	dmpall	purge all output buffers	
	dumpin		purge input buffer	
	clrflg	tfhang	reset flag for next time	
	goto	hungup	back to main contrl tables	
	rem		thats all folks!	
	ttls subroutine to insure all output is dumped			
dmpall	dmpout		throw output buffer away	
	tstwrt	dmpall	still have some left	
	retsub		return to caller	
	ttls	subroutine to check for data remote sent to us			
gckin	inscan	ictrl2,gbadin	check lrc on input	
	calasm	stpbcc	go strip the bcc character from the buffer
	inscan	ictrl7,gbadin	find soh
	inscan	fcscan,gbadin	get the msg type to a tib addr	
	gocase	fctype,fccmp,fcjmp go to type of msg it is	
	goto	gbadin	not a valid function code type
	rem
fcsm	setchr	fctype,srvmes	service msg	
	goto	gckcnt	go check the rest	
fcscr	setchr	fctype,scrmes	special record msg	
	goto	gckcnt	
fcinf	setchr	fctype,infmes	information msg	
gckcnt	inscan	ictrl4,gbadin	save seq code, op type, and ack	
	cmpchr	acknak,null,setack see if we got ack in msg	
	setchr	acknak,nak	no so say nak	
	goto	gack	go get the cnt	
setack	setchr	acknak,ack	yes we got an ack	
gack	inscan	ictrl6,gcketb	count the chars we got	
	goto	gcksrv	see if srv msg needs more checks	
gcketb	inscan	ictrl9,gbadin	ck for etb if no etx	
gcksrv	cmpchr	fctype,srvmes,cksrv see if further checking required	
	retsub		no so go back	
cksrv	gocase	optype,opck,opjmp see if srvmes to be saved	
	dumpin		no so dump it	
gckret	retsub		return to caller	
	rem
gbadin	dumpin		get rid of bad msg	
	setchr	fctype,null	say we got error	
	setchr	optype,null	same here	
	setchr	acknak,nak	nak the msg	
	meter2	m.cnt1,1
	retsub		go back	
	ttls subroutine to check for completion of dia input			
*	
*	
*	subroutine to check the dia input chain to see if one exists	
*	if it does, it is assumed that we are taking data faster than	
*	we can give it to the 68/80 and we must slow down by	
*	doing something else and checking again later.	
*	
*	
ckibsy	subr	cki,(x3)
	ila	msgchk	get tib addr of place to store result	
	cax3		move that tib addr to x3	
	tsy	ckmcad-*,*	call cvaddr to get real addr	
	stx3	ckmans-*	save this addr to store status	
	stz	ckmans-*,*	init the status to 0	
	szn	t.dcp,1	set zero flag if no 68/80 input pending	
	tze	ckirtn-*	not busy so just return	
	aos	ckmans-*,*	else set it to one (fspr)	
ckirtn	return	ckibsy	
	ttls	subroutine to check for any addtional output
*
*
*	subroutine to check to see if dia_man has appended any addtional
*	output to our output chain since we last looked at it.  dia_man will
*	not notify us if he appended stuff to an already existing chain, so
*	we have to check for the appending ourselves
*
*
ckochn	subr	cko,(x3)
	ila	outchn	get tib addr of place to get buffer addr
	cax3		move this tib addr to x3
	tsy	ckmcad-*,*	convert tib addr to real addr
	stx3	ckmout-*	save addr of variable for later use
	lda	ckmout-*,*	get buffer through indirect
	tsy	a.a001-*,*	setbpt
	cax3
	lda	bf.nxt,3	get addr of the next buffer in the output chain
	sta	ckmout-*,*	if not 0 we have more output
	return	ckochn
	ttls subroutine to adjust the buffer tally to not reflect the lrc
*
*
*	subroutine to adjust the buffer tally to not reflect the lrc
*	character in the tally of the buffer with the terminate
*	character.
*
*
stpbcc	subr	stp,(x3)	strip block chaeck char
	stz	prvbuf-*
	stz	prsbuf-*
	stz	prschr-*
	lda	t.icp,1	get input chain
	tze	stprtn-*	if none, go back
stpbuf	sta	prsabs-*	save absolute address of buffer
	tsy	a.a001-*,*	setbpt
	cax3
	stx3	prsbuf-*	save virtual addr of this input buffer
	lda	bf.flg,3	get flag word into a
	ana	stpbrk-*	and to get if brk char is here or not
	tze	stpnxt-*	if zero then use other buffer
	lda	bf.tly,3	get tally word into a
	ana	tlymsk-*	and separate character count
	tze	stprtn-*	must be error, forwe have term char here it said
	iaa	-1	char #1 is in 0 position
	sta	prschr-*	save the tally to add later
	ana	stpodd-*	see if even or odd
	tze	stpevn-*	it is even
	lda	prschr-*	get tally back
	ars	1	divide by 2
	ora	stpbyt-*	looking for odd byte since odd count
	tra	stpdo-*	go do the add
stpevn	lda	prschr-*	get tally back
	ars	1	divide by 2
	ora	ckobyt-*	looking for even byte
stpdo	sta	prschr-*	save for later use
	cx3a		move buffer addr to a
	iaa	bf.dta	incr to get real data
	ora	ckobyt-*	set to byte addring
	cax3		set x3 to this char addr
	adcx3	prschr-*	set x3 to the char pointed to by tally
	lda	0,3,b.0	load a with this char
	tnz	stpnxt-*	either we were here already or lrc not checked
	ldx3	prsbuf-*	get buffer back
	lda	bf.tly,3	get tally back to a
	iaa	-1	add -1 (substract 1)
	sta	bf.tly,3	and put it back decremented
	ana	tlymsk-*	just get the count
	tnz	stpnxt-*	go look at the next buff if not zero count
	ldq	bf.nxt,3	if zero must release it
	lda	prvbuf-*	get previous buffer
	tze	stprtn-*	error
	tsy	a.a001-*,*	setbpt
	cax3
	stq	bf.nxt,3	unthread the buffer we will free
	lda	bf.flg,3	get the flags for this buffer
	ora	stplst-*	say this is the real end of msg
	ora	stpbrk-*	say this is really where the break char is
	sta	bf.flg,3	put the modified flags back
	lda	prsabs-*	get back the buffer to be freed
	tsy	a.a001-*,*	setbpt
	cax3
	lda	bf.siz,3	get size code
	ars	15	get size code as interger
	iaa	1	total # of 32 word groups
	sta	stptly-*	save num of icpl we need to subtract
	lda	t.icpl,1	get count of icp buffer lengths
	cmpa	stptly-*	just check to make sure
	tmi	stprtn-*	icpl less than number we calculated, error
	sba	stptly-*	substract out our buffer we are releasing
	sta	t.icpl,1	put back the correct tally
	lda	prsabs-*	get buffer address
	ilq	0	tell frebuf to use size code
	tsy	stpfre-*,*	go free this buffer
stpnxt	lda	prsabs-*	get the old pres buff
	sta	prvbuf-*	and store it as a previous buff
	tsy	a.a001-*,*	setbpt
	cax3
	lda	bf.nxt,3	get addr of next buffer
	tze	stprtn-*	no more so return
	tra	stpbuf-*	go try this buffer now
stprtn	return	stpbcc
	rem
stpbrk	vfd	o18/bffbrk	break char flag
stpbyt	zero	0,b.1	odd byte addring
stpodd	vfd	o18/1	looking at least significant bit (b17)
stplst	vfd	o18/bfflst	mask to set last buff in msg flag
stptly	bss	1	total num of 32 word blocks in buffer
stpfre	ind	frebfh	to free a buffer
	rem
a.a001	ind	setbpt
a.a002	ind	cvabs
a.a003	ind	.crbpe,*
	ttls	subroutine to check an output msg
*	
*	possibilities are
*		good msg transmit
*		particle msg	ask multics for more
*		particle msg(s) followed
*		   by good msg	throw away particle msgs
*		msg > 324 text chars throw away
*		invalid msg	throw away
*	
*	subroutine to check for a valid output message	
*	a status is stored in the tib extension depending on the	
*	result of our check.	
*	gocase is then used to decide what to do with the status	
*	
*	
ckomsg	subr	ckm,(x3)
	ila	msgchk	get tib addr of place to put our result	
	cax3		move that tib addr to x3	
	tsy	ckmcad-*,*	call cvaddr to get real addr	
	stx3	ckmans-*	save the addr to store our answer	
	ila	outchn	our last buffer addr
	cax3		move this tib addr to x3
	tsy	ckmcad-*,*	get real addr to that variable
	stx3	ckmout-*	place real addr in word to use later
	stz	ckmans-*,*	init answer to 0 and place it
	lda	t.ocp,1	get output chain	
	tze	ckmrtn-*	no output so just return	
	stz	ckmflg-*	init our found flag to 0
	stz	lstbuf-*	init last buffer address	
	stz	prvbuf-*	init prev last msg buffer	
	stz	ckmcnt-*	init character count of message	
ckmbuf	tsy	a.a001-*,*	setbpt
	sta	prsbuf-*	save base of present buffer	
	cax3		save this buffer addr in x3	
	lda	bf.tly,3	get number of chars in this data buffer	
	ana	tlymsk-*	tally is low 9 bits	
	iaa	1	set our buffer overflow number	
	sta	ckmmax-*	save our over flow number	
	stz	buftly-*	set number of characters we start with	
	cx3a		get base of buffer back to a
	iaa	bf.dta	get to first character in buffer	
	ora	ckobyt-*	get to the 0 byte	
	cax3		get this real addr to x3 for use
ckmget	aos	buftly-*	have scanned up another one in buffer	
	lda	buftly-*	get our buffer characters read	
	cmpa	ckmmax-*	see if we should switch to next buffer now
	tnz	ckmsbf-*	use the same buffer
	ldx3	prsbuf-*	get our present buffer
	cx3a		convert to absolute address
	tsy	a.a002-*,*	cvabs
	sta	lstbuf-*	save our present buffer for reference
	lda	bf.nxt,3	get next buffer addr	
	tnz	ckmbuf-*	if not zero we have a next buffer	
	tra	ckmmor-*	else we are at end of string	
ckmsbf	aos	ckmcnt-*	incr our character count	
	lda	ckmlen-*	load a with max msg length	
	cmpa	ckmcnt-*	see if we are too long yet	
	tmi	ckmlng-*	if so go notify	
	lda	0,3,b.0	get the character to check	
	cmpa	ckmetx-*	see if we have an etx char	
	tze	ckmsta-*	yes so msg is complete	
	cmpa	ckmetb-*	see if we have an etb which is ok	
	tze	ckmsta-*	yes so msg can be sent	
	cmpa	ckmeot-*	see if eot char
	tze	ckmsta-*	yes so it is ok
	cmpa	ckmsoh-*	see if it is an soh char	
	tnz	ckmnxt-*	no so go get the next char	
	aos	ckmflg-*	say we found another soh char	
	szn	lstbuf-*	see if first buffer we looked at
	tze	ckmnxt-*	first so dont discard it.
	stx3	prschr-*	save our present character location	
	ldq	a.a003-*,*	(.crbpe,*) hold on to pte
	szn	prvbuf-*	see if we had a previous last msg	
	tze	ckmset-*	if not, go set this one	
	ldx3	prvbuf-*	get that previous buffer	
	lda	bftlsn-*	load a with the last buf not flag	
	ansa	bf.flg,3	set the last flag to 0	
ckmset	ldx3	lstbuf-*	go get our lst buffer	
	stx3	prvbuf-*	say we set one here	
	stz	ckmcnt-*	restart our msg char cnt here	
	ila	discrd	say we have to dump	
	sta	ckmans-*,*	save this status	
	cx3a		convert buffer address to virtual
	tsy	a.a001-*,*	setbpt
	cax3		back to x3
	lda	bftmsk-*	load a with the last flag mask
	orsa	bf.flg,3	set the last flag	
	ldx3	prschr-*	go back to our present character	
	stq	a.a003-*,*	(.crbpe,*) restore pte
ckmnxt	iacx3	0,b.1	incr to the next character	
	tra	ckmget-*	go get the next character	
ckmlng	ila	lngmsg	message was too long	
	tra	ckmwan-*	see if it was a msg at all	
ckmmor	lda	prsbuf-*	get the addr of our last good buffer
	tsy	a.a002-*,*	cvabs
	sta	ckmout-*,*	save this addr in our tib
	ila	fetx	if we got here we didnt find an etx	
ckmwan	sta	ckmans-*,*	place the answer we have so far
ckmsta	szn	ckmflg-*	see if we found at least one soh char	
	tnz	ckmrtn-*	if we did skip next error msg	
	ila	fsoh	say we failed to find soh char	
	sta	ckmans-*,*	store our answer in the tib	
ckmrtn	return	ckomsg	return to the caller	
	rem
lstbuf	bss	1	last buffer we looked at	
prvbuf	bss	1	previous buffer we set last buf flag in	
prsbuf	bss	1	virtual addr of the present buffer we are in
prsabs	bss	1	absolute "   "    "     "     "     "  "   "
ckobyt	zero	0,b.0	the first byte of the word
ckmmax	bss	1	max number of chars + 1 we allowed in buff
buftly	bss	1	char we are looking at in buffer	
ckmsoh	vfd	o18/soh	soh character mask	
bftlsn	vfd	o18//bfflst	last buff zeroed mask	
bftmsk	vfd	o18/bfflst	last buff mask	
ckmans	bss	1	final addr to store our response	
ckmout	bss	1	final addr to store last output buffer in
ckmcnt	bss	1	character count of msg	
ckmetx	vfd	o18/etx	etx character	
ckmetb	vfd	o18/chr027	etb character	
ckmeot	vfd	o18/eot	eot character
ckmflg	bss	1	flag that we had found atleast one soh char	
ckmlen	dec	332	max length of msg plus header, plus etx
prschr	bss	1	our present character location in buffer	
tlymsk	vfd	o18/buftmk	mask to get tally count	
ckmcad	ind	cvaddr	external subroutine to get real tib addr	
	eject
	end	
