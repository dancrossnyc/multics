* ************************************************************
* *                                                          *
* * Copyright, (C) BULL HN Information Systems Inc., 1989    *
* *                                                          *
* * Copyright, (C) Honeywell Information Systems Inc., 1982  *
* *                                                          *
* * Copyright, (C) Honeywell Information Systems Inc., 1980. *
* *                                                          *
* ************************************************************
	lbl	,x25_tables
	ttl	x25_tables
	editp	on
	pmc	off
	detail	off
	pcc	off
****************************************************************
*
*	x25_tables (orginal called x25lap_tables)
*
*	This module is designed to use the HDLC subchannel of
*	the high-speed line adaptor to implement the Link
*	Access Procedure (LAP) of CCITT recommendation X.25.  This
*	module supports both asynchronous response mode and 
*	asynchronous balance mode (LAPB).
*
*	Coded August, 1979 by J. Stern
*	Fixed for TELENET May 1980 by C. Hornig
*	RNR problem fixed October 1980 by C. Hornig
*	Modified for parameterization December 1980 by R. Harvey
*	Rewritten by D. W. Cousins June 1981
*	Fixed bugs to pass TELNET certication and
*	 improve maintinance for future improvements.
*	Rewritten by D. W. Cousins April, 1982 for LAPB
*	Modified by D. W. Cousins  July,1982 for eom sentinal
*	Modified by D. W. Cousins Janurary, 1983 for stpchn problem on exhaust
*	Modified by D. W. Cousins Janurary, 1983 for bugs fixes
*	Modified by D. W. Cousins June 8, 1983 for output blockage during
*	  link recovery from timer expired with transmitter busy
*	Modified by D. W. Cousins Sept 9, 1983 for LAPB reset I-frame hold
*	Modified by D. W. Cousins April 1984 for speed ups in the output
*	  section to used a nrn instruction inplace of tstlcf code and
*	  set up a CMDR/FRMR check for I-frames with more data then remote
*	  can accept to cause the link to disconnect.
*	Modified by D. W. Cousins Oct 12 1984 to have the control of crash
*	  to deactivate the line in such a matter to only have an activate
*	  control order to turn it back on.
*	Modified by D. W. Cousins Oct 18, 1985 to correct a problem of RNR,
*	   RR being recieve during I-frame output in which a.r is reset
*	   such that no messages are acknowledged that should be.
*	Modified by D. W. Cousins Nov 22 1985 to abort the hangup timer in
*	   control_tables so that the activation order is not lost.
*
*
****************************************************************

* HISTORY COMMENTS:
*  1) change(86-02-03,Kissel), approve(86-02-03,MCR7297),
*     audit(86-02-03,Coren), install(86-04-10,MR12.0-1038):
*     Correct a problem of RNR or RR being received during I-frame output in
*     which a.r is reset such that no messages are acknowledged when they
*     should be.
*  2) change(86-02-03,Kissel), approve(86-02-03,MCR7324),
*     audit(86-02-03,Coren), install(86-04-10,MR12.0-1038):
*     Modified to abort the hangup timer in the control_tables so that an
*     activation order is not lost.
*  3) change(86-12-19,Cousins), approve(87-01-26,MCR7605),
*     audit(87-06-11,Brunelle), install(87-07-15,MR12.1-1041):
*     Close a hole in detecting invalid frames.  Bug caused connection to go
*     into LINK-up state when it should not.  This would not happen with
*     certified connections, expected only during certification tests.
*  4) change(87-02-04,Beattie), approve(87-04-06,MCR7657),
*     audit(87-06-11,Brunelle), install(87-07-15,MR12.1-1041):
*     The FNP erroneously sends out 2 DISC (disconnect) commands when a DM
*     (disconnected mode) response is received when the link is down.  This
*     can cause loss of synchronization with the other end.  There is also a
*     bug in handling of DMs when the connection is in the link up state.
*  5) change(89-04-30,Beattie), approve(89-05-15,MCR8108),
*     audit(89-06-15,Brunelle):
*     Input exhaust status processing incorrectly reestablishing T1 timer to
*     1 second rather than current value for T1.  Can cause extra data to be
*     sent to remote terminal.
*                                                      END HISTORY COMMENTS

	rem
x25tbs	null
	rem
	symdef	x25str
	rem
	symref	begin
	symref	hungup
	symref	adbyte
	symref	cvaddr
	symref	setbpt	/*18 to 15 bit for i/o buffers */
	rem
	pmc	save,on
	tib
	sfcm	hsla
	csbits
	buffer
	comreg
	tconst
	meters
	pmc	restore
	rem
	start	x25tbs,,c3x25m0c0000
	ttls	X25 LAP tib extension variables
	tibex	locadr,char	/* local station address */
	tibex	remadr,char	/* remote station address */
	tibex	frmadr,char	/* address from current input frame */
	tibex	pmask,char	/* P bit mask for command output */
	tibex	fmask,char	/* F bit mask for response output */
	tibex	cfield,char	/* output frame control field */
	tibex	cmdrb1,char	/* CMDR/FRMR info field, byte 1 */
	tibex	cmdrb2,char	/* CMDR/FRMR info field, byte 2 */
	tibex	cmdrb3,char	/* CMDR/FRMR info field, byte 3 */
	rem
	tibex	lkupws,word	/* which table during link up */
	tibex	lastf,word	/* last function recieve */
	tibex	stat0,word	/* line status/line control words */
	tibex	stat1,word
	tibex	stat2,word
	tibex	stat3,word
	tibex	rc,word   /* retry counter */
	tibex	v.s,word  /* next N(S) to send */
	tibex	v.r,word  /* next N(S) to receive */
	tibex	a.s,word  /* last N(R) sent */
	tibex	a.r,word  /* last N(R) received */
	tibex	xx,word	/* saved value of v.s during timer recovery */
	tibex	t1,word	/* response time-out interval (from host) */
	tibex	t3,word	/* time-out interval (from host) */
	tibex	n2,word	/* max number of retries (from host) */
	tibex	kc,word	/* number of frame before stopping HOST */
	tibex	kv,word	/* number of frame on the chain now */
	tibex	state,word	/* primary state */
	tibex	pstate,word	/* primanry up state */
	tibex	sstate,word	/* secondary up state */
	tibex	mxfrsz,word	/* max frame size (input) */
	tibex	uaoffs,word	/* buffer offset (offset to buffer) */
	tibex	bufadd,word	/* buffer pool address */
	tibex	upobuf,word	/* unprocess buffer address */
	tibex	nrv,word	/* n.r if xmit is busy */
	tibex	retlbl,word	/* label for stpchn return to */
	rem
	tibex	flgwd1,word	/* flags word link control */
laparb	bool	000001	/* on if lapb protocall */
dcedte	bool	000002	/* on if dce device */
discft	bool	000004	/* on if send disc first */
trcoff	bool	000010	/* on if trace is to be off on crash */
rprtsw	bool	000020	/* on if report needed to host */
xmitsw	bool	000040	/* on if transmitter busy */
rcvsw	bool	000100	/* on if recieving mode on */
oasw	bool	000200	/* on if output is recieve since last sndout */
t1rec	bool	000400	/* on if timer recovery is in progress */
timesw	bool	001000	/* on if timer is running */
timet3	bool	002000	/* on if t3 timmer is running */
pbit	bool	004000	/* on if poll is required */
fbit	bool	010000	/* on if finial is required */
ifrsnd	bool	020000	/* on if iframe on t.ocp (xmiting) */
psarm	bool	040000	/* on if a prior sarm is recieve */
oprusw	bool	100000	/* on if output recieve on xmit on */
ackrq	bool	200000	/* on if ack is required because of i-frame xmit */
downsw	bool	400000	/* on if link is down */
	rem
	tibex	flgwd2,word	/* flag word 2 output messages */
sndm	bool	200000	/* on send dm (lapb) */
sndisc	bool	100000	/* on send disc */
snsarm	bool	040000	/* on send sarm (lap) */
snsabm	bool	020000	/* on send sabm (lapb) */
sncmdr	bool	010000	/* on send cmdr (lap) */
snfrmr	bool	010000	/* on send frmr (lapb) */
snua	bool	004000	/* on send ua */
snrnr	bool	002000	/* on send response rnr */
snrej	bool	001000	/* on send response rej */
snifr	bool	000400	/* on send i-frame */
snrr	bool	000200	/* on send response rr */
snprnr	bool	000100	/* on send command rnr (lapb) */
snprej	bool	000040	/* on send command rej (lapb) */
snprr	bool	000020	/* on send command rr (lapb) */
*unused		400017	/* note 0-bit must be zero for nrn to work */
	rem
	tibex	flgwd3,word	/* flag word 3 misc flags */
rtyhld	bool	000001	/* on = no I-frame to be send t1rec */
hldvar	bool	000002	/* on = next ua response to DISC not ss move */
mstclr	bool	000004	/* on = must clear buffers */
mstifr	bool	000010	/* on = sent one I-frame (timer recovery)*/
*unused		777760
	ttls	X25 LAP constant symbols
*
*	miscellaneous chars
*
dceadr	bool	001	/* DCE address */
dteadr	bool	003	/* DTE address */
rr	bool	001	/* RR frame type */
rnr	bool	005	/* RNR frame tpye */
rej	bool	011	/* REJ frame type */
sarm	bool	017	/* SARM frame type */
sabm	bool	057	/* SABM frame type */
disc	bool	103	/* DISC frame type */
dm	bool	017	/* DM frame type */
ua	bool	143	/* UA frame type */
cmdr	bool	207	/* CMDR frame type */
frmr	bool	207	/* FRMR frame type */
pfon	bool	020	/* P/F bit mask */
eof	bool	400	/* end of frame bit */
*
*	link state constants
*
lkdnst	equ	1	/*link down state */
lkt3st	equ	2	/* t3 state */
lkssst	equ	3	/* sabm send state (lapb) */
lksust	equ	4	/* link setup state */
lkisup	equ	5	/* link up state */
lkprnr	equ	5	/* prinary normal state */
lkprrb	equ	6	/* primary remote busy state */
lkprt1	equ	7	/* primary t1 expire state */
lkprsr	equ	8	/* primary sarm reset state */
lkscnm	equ	9	/* secondary normal state */
lksclb	equ	10	/* secondary local busy state */
lkscrj	equ	11	/* secondary reject state */
lksccs	equ	12	/* secondary cmdr send state */
lkupfr	equ	13	/* link up frmr send (lapb) */
lkuprs	equ	14	/* link up reset started (lapb) */
*
*	miscellaneous integers
*
dialim	equ	8	/* max queued frames to DIA */
*
*	line control types
*
lctact	equ	1	/* activate link */
lctdea	equ	2	/* deactivate link */
lctdis	equ	3	/* disconnect link */
*
*	format of activate order (stat0)
*
dceflg	bool	400000	/* we are a dce */
abmflg	bool	200000	/* default to lapb */
disftf	bool	100000	/* disc first flags */
*unused	077000
ordmsk	bool	000777	/* control order type */
*
*	line status types
*
lstdwn	equ	1	/* link is down */
lstup	equ	2	/* link is up */
lstcmr	equ	3	/* CMDR of I-frame Y set*/
*
*	bldmsg control strings
*
srmmsg	chstr	(remadr,sarm,seteom)
dmmsg	chstr	(locadr,dm,seteom)
sbmmsg	chstr	(remadr,sabm,seteom)
dscmsg	chstr	(remadr,disc,seteom)
uamsg	chstr	(locadr,ua,seteom)
cmdmsg	chstr	(remadr,cfield,seteom)
rspmsg	chstr	(locadr,cfield,seteom)
frmrms	null
cmdrms	chstr	(locadr,cmdr,cmdrb1,cmdrb2,cmdrb3,seteom)
*
*	outscn control strings
*
setp	chstr	(rescan,ignore,setbit,pmask)
setf	chstr	(rescan,ignore,setbit,fmask)
setac	chstr	(rescan,replac,remadr,ignore,replac,cfield,setbit,pmask,e
	etc	ndchn,offbit,eof)
*
*	gocase control labels, compare strings, and tables constants
*
*	tables constants
*
rvbdad	equ	0	/* bad address or other type of trash */
rvdisc	equ	1	/* receive disc */
rvdm	equ	2	/* receive dm (lapb) */
rvsarm	equ	3	/* receive sarm (lap) */
rvsabm	equ	4	/* recieve sabm (lapb) */
rvua	equ	5	/* recieve ua */
rvcmdr	equ	6	/* recieve cmdr (lap) or frmr (lapb) */
rvrr	equ	7	/* recieve response rr */
rvrnr	equ	8	/* recieve response rnr */
rvrej	equ	9	/* recieve response rej */
rvbdcr	equ	10	/* recieve a bad command or response */
rvt12l	equ	11	/* t1 expired rc less then n2 */
rvt12e	equ	12	/* t1 expired rc equal to n2 */
rvbdfb	equ	13	/* recieve bad f-bit */
rvbdir	equ	14	/* recieve i-frame bad n(r) */
rvbdis	equ	15	/* recieve i-frame bad n(s) */
rvifrm	equ	16	/* recieve i-frame */
rvprr	equ	17	/* recieve command poll rr (lapb) */
rvprnr	equ	18	/* recieve command poll rnr (lapb) */
rvprej	equ	19	/* recieve command poll rej (lapb) */
*
*	down state table control array
*
downst	chstr	(rvdisc,rvdm,rvua,rvt12l,rvt12e)
*
*	t3 state table (mostly send disc go to down state used by
*	   DCE portion only)
*
t3stat	chstr	(rvdisc,rvdm,rvsarm,rvsabm,rvcmdr,rvrr,rvrnr,rvrej,rvbdcr
	etc	,rvt12l,rvt12e,rvbdfb,rvbdir,rvbdis,rvifrm,rvprr,rvprnr,r
	etc	vprej)
*
*	 sabm send state  used by LAPB only
*
ssstat	chstr	(rvdisc,rvdm,rvsabm,rvua,rvcmdr,rvt12l,rvt12e)
*
*	set up state  used by LAP only
*
sustat	chstr	(rvdisc,rvsarm,rvua,rvt12l,rvt12e)
*
*	link up state primary side sub tables
*	  prinr - primary normal state
*	  prirb - primary remote busy state
*	  prit1 - primary timer reset state
*
prinr	null
prirb	null
prit1	chstr	(rvdisc,rvdm,rvsarm,rvsabm,rvua,rvcmdr,rvrr,rvrnr,rvrej,r
	etc	vbdcr,rvt12l,rvt12e,rvbdfb,rvbdir,rvbdis,rvifrm)
*
*	link up primary substate sarm send state LAP only
*
prisr	chstr	(rvua,rvt12l,rvt12e)
*
*	link up secondary substate
*	  secnm - secondary normal
*	  seclb - secondary local busy
*	  secrj - secondary reject
*	  seccs - secondary command send LAP only
*
secnm	null
seclb	null
secrj	null
seccs	chstr	(rvdisc,rvsarm,rvsabm,rvua,rvcmdr,rvrr,rvrnr,rvrej,rvbdcr
	etc	,rvbdir,rvbdis,rvifrm,rvprr,rvprnr,rvprej)
*
*	link up frame reject state LAPB only
*
prifr	chstr	(rvdisc,rvdm,rvsarm,rvsabm,rvua,rvcmdr,rvrr,rvrnr,rvrej,r
	etc	vbdcr,rvt12l,rvt12e,rvbdfb,rvbdir,rvbdis,rvifrm,rvprr,rvp
	etc	rnr,rvprej)
*
*	link up reset send state LAPB only
*
prisrt	chstr	(rvdisc,rvdm,rvsabm,rvua,rvcmdr,rvt12l,rvt12e)
*
*	which state tables gocase is going to used?
*	  (used in linkup state only)
*
whstgc	chstr	(lkprnr,lkprrb,lkprt1,lkprsr,lkscnm,lksclb,lkscrj,lksccs,
	etc	lkupfr,lkuprs)
*
*	gocase label tables
*
*	down state transferred vectors
*
dslabl	adrlst	(dssnua,dmstt3,srtt3,disct1,dst1e)
*
*	t3 state transferred vectors
*
t3labl	adrlst	(sndua,dsdisc,susua,lpbiup,dsdisc,dsdisc,dsdisc,dsdisc,ds
	etc	disc,t3t1ln,dsdscp,dsdisc,dsdisc,dsdisc,dsdisc,dsdisc,dsd
	etc	isc,dsdisc)
*
*	ss LAPB state transferred vectors for sabm sent state
*
sslabl	adrlst	(sndua,ckdisc,sndua,lpbiup,sndsbm,t1sabm,ckdscp)
*
*	set up state transferred vectors (lap)
*
sulabl	adrlst	(dsdsua,sndua1,ckupst,sndsmp,dsdscp)
*
*	primary normal state
*	primary remote busy
*	primary t1 time out
*	  transferred vectors
*
pnrlbl	null
prblbl	null
pt1lbl	adrlst	(frsrrq,dsdisc,frsrrq,frsrrq,uaigfr,sborsm,nrrr,rbrnr,nrr
	etc	ej,frsrrq,t1stch,n2rssr,frsrrq,frsrrq,frsrrq,frsrrq)
*
*	primary sarm rest state transferred vectors
*
psrlbl	adrlst	(backnr,tisarm,tidisc)
*
*	secondary normal state transferred vectors
*
snmlbl	adrlst	(dsduab,nmdua,nmduab,frcmdr,frcmdr,frcmdr,frcmdr,frcmdr,f
	etc	rcmdr,frsrrq,rjrej,nmif,finrr,finrr,finrr)
*
*	secondary local busy state transferred vectors
*
slblbl	adrlst	(dsduab,nmsdua,nmduab,frcmdr,frcmdr,frcmdr,frcmdr,frcmdr,
	etc	frcmdr,frsrrq,sndrnr,sndrnr,finrnr,finrnr,finrnr)
*
*	secondary reject state transferred vectors 
*
srjlbl	adrlst	(dsduab,nmsdua,nmduab,frcmdr,frcmdr,frcmdr,frcmdr,frcmdr,
	etc	frcmdr,frsrrq,rej1,pnmif,finrej,finrej,finrej)
*
*	secondary command reject state transferred vectors
*
scslbl	adrlst	(dsdsua,nmsdua,sndcmd,sndcmd,sndcmd,sndcmd,sndcmd,sndcmd,
	etc	sndcmd,frsrrq,sndcmd,sndcmd,sndcmd,sndcmd,sndcmd)
*
*	lapb frame reject transferred vectors
*
lbfrtv	adrlst	(dsduab,discds,sndfr,lpbpup,sndfr,rssabm,sndfr,sndfr,sndf
	etc	r,sndfr,t1nor,rssabm,sndfr,sndfr,sndfr,sndfr,sndfr,sndfr,
	etc	sndfr)
*
*	reset sabm send state transferred vectors
*
lbrstv	adrlst	(dsduab,discds,sndua,lpbpup,sndsbm,t1sabm,discds)
*
*	which gocase table search to use transferred vectors
*
whgclb	adrlst	(lkpnr,lkprb,lkpt1,lkpsr,lksnm,lkslb,lksrj,lkscs,lkfrlb,l
	etc	krslb)
	rem
*
*	meter difinitions
*
frmxmt	equ	1	/* output messages */
frmrcv	equ	0	/* input messages */
rtyxmt	equ	m.cnt1	/* metter xmt retried */
resxmt	equ	m.cnt2	/* meter xmt reset */
rtyrcv	equ	m.cnt3	/* meter frmaes discarded */
resrcv	equ	m.cnt4	/* meter reciever reset */
mfce	equ	m.cnt5	/* meter fcs errors */
mrab	equ	m.cnt6	/* meter read aborts */
	rem
************************************************************
*
*
*	The x25 protocall has states in which only certain
*	 function can be preform, If these are violated; the
*	 state will send it to another state for that function
*	 or if function is satisfied then it will progress it
*	 to the proper state in line to link up.
*
*	The first function is the physcal connect. This
*	 is not a state for the x25, but a common state to
*	 all lines.
*
*	The following is the primary states for normal linkup flow
*
*	  LAP                    LAPB
*	down state             down state
*	t3 state               t3 state
*	setup state            sabm send state
*	linkup state           linkup state
*	 Note LAPB can go to linkup state in t3 state but
*	  LAP cann't
*
*	the following is the linkup substate
*
*	  LAP                    LAPB
*	primary normal         primary normal
*	primary remote busy    primary remote busy
*	primary t1             primary t1
*	primary sarm send
*	secondary normal       secondary normal
*	secondary local busy   secondary local busy
*	secondary reject       secondary reject
*	secondary command reject
*	                       frame reject
*	                       reset sabm send
*
************************************************************
	ttls	physical connection
	eject
************************************************************
*
*	wait for the activation order
*
************************************************************
	rem
x25str	clrflg	tfhang	/* clear last hangup flag just in case */
	config		/* set idle link state */
	rmode	fg.itf	/* don't transmit flags */
	getext	,gopunt	/* get tib extension */
	linctl	stat0,actwt	/* did we get activated? */
	goto	actts2	/* yes, process it now */
	rem
actwt	wait	0,0,actts	/* wait for activation order */
	rem
actts	tstflg	tfhang,hangr	/* start over */
	linctl	stat0,actwt	/* is it a activation order */
actts2	calasm	dcdact,(actwt)	/* decode it */
	rem
lisna	tstflg	tflisn,lisn	/* told to listen? */
	wait	0,0,lisnt	/* test for it type */
	rem
lisnt	tstflg	tfhang,hangr	/* told to hand up */
	goto	lisna	/* all other */
	rem
lisn	contrl	sdtr+srts+stat	/* full duplex set rts and dtr */
	rem
	wait	0,0,cklisn	/* wait for changes or status */
	status	cts+dsr+cd,0,ckdlup
*       	/* must have cts, dsr, and cd before we can talk */
	rem
ckdlup	setime	1	/* wait one second for line settling */
	wait	ckline,0,ckdlup
	rem
ckline	contrl	stat	/*find out if line still up */
	rem
	wait	0,0,cklisn
	status	cts+dsr+cd,0,dialed	/* it dial up */
	status	0,dsr,hang	/* dead line so drop it */
	rem
cklisn	tstflg	tfhang,hang	/* told to drop the line */
	tstflg	tflisn,golisn	/* still listening */
	goto	hang	/* none so quit */
	rem
golisn	waitm
	rem
	rem
************************************************************
*
*	the line has dial up now set up some tables 
*
************************************************************
	rem
dialed	calasm	cfgpcw	/* set configuration pcw */
	contrl	srec	/* enter recieve mode */
	setlcf	flgwd1,rcvsw	/* say we are recieving */
	rem
	config		/* set active link state */
	smode	fg.itf
	rem
	clrlcf	flgwd1,xmitsw	/* clear transmitter */
	goto	pcdown	/* start the down state function */
	rem
************************************************************
*
*	handle the deactivation of the line
*
************************************************************
	rem
deact	contrl	rrec	/* exit recieve mode */
	config		/* set idle link */
	rmode	fg.itf
	goto	hang	/* wait for activation order */
	ttls	link down state
	eject
	rem
************************************************************
*
*	link down has two phases. one is for initialization
*	 the other is for the actual down state functions
*
************************************************************
	rem
pcdown	clrlcf	flgwd1,rprtsw	/* no report is needed */
	setlcl	flgwd2,0	/* clear all messages */
	setlcl	flgwd3,0	/* clear more flags */
	clrlcf	flgwd1,xmitsw	/* xmiter not busy */
	tstlcf	flgwd1,discft,dwnst	/* down state required */
	tstlcf	flgwd1,laparb,pssute /* setup for lapb */
	goto	psuste	/* lap setup */
dwnst	setlcf	flgwd1,downsw	/* shown link is down */
	clrlcf	flgwd1,t1rec	/* no timer recovery */
	clrlcf	flgwd1,timet3	/* no t3 timer going */
	clrlcf	flgwd1,pbit	/* clear p bit */
	clrlcf	flgwd1,fbit	/* clear f bit */
	setchr	pmask,null
	setchr	fmask,null
	calsub	clrabf	/* free any messages buffers */
	rem
	tstlcf	flgwd1,rprtsw,repdns /* do we report down state */
	goto	dwnwt	/* no */
	rem
repdns	setlcl	stat0,lstdwn	/* set order to down state */
	setlcv	stat1,lastf	/* going tell HOST why we when down */
	setlcv	stat2,state
	setlcv	stat3,sstate
	tstlcf	flgwd1,trcoff,repdn1
	goto	repdn2
repdn1	setlcl	.crtsw,1
repdn2	calasm	setust
	linsta	stat0
	clrlcf	flgwd1,rprtsw	/* clear the report switch */
	goto	deact		/* not the correct place, but */
	rem			/* link crash so deactivate it */
	rem
dwnwt	setlcl	state,lkdnst	/* show we are down */
	setlcl	pstate,0	/* save a mess later */
	clrlcf	flgwd1,psarm	/* prior sarm required off */
	setlcl	rc,0	/* set retry counter to zero */
	setimv	t1	/* set timer */
	setlcf	flgwd1,timesw	/* start timer */
	setlcf	flgwd2,sndisc	/* set send disc message */
	calsub	outlst	/* output it */
	rem
dwntwt	setlcl	retlbl,dwntwt	/* return label for stpchn */
	wait	timeds,badoa,testst /* main wait for down state */
	status	0,dsr,hang	/* line drop hangup */
	status	exh,0,exhsta	/* no buffers avaible */
	status	fcserr,0,fcesta	/* fcs error */
	status	rcvabt,0,rabsta	/* read abort */
	status	rcvtrm,0,rddsin	/* read terminate check it out */
	status	term,0,outpcw	/* output terminate see if any more */
	status	xte,0,xtesta	/* punt transferred timming error */
	rem
************************************************************
*
*	driver for the down state
*
************************************************************
	rem
timeds	calsub	timeo	/* which timer is it (t3, t1 < rc, or t1 = rc */
	goto	dstest	/* go to work */
	rem
rddsin	meterm	frmrcv	/* meter input */
	calasm	valfrm	/* get function form input */
	setlcl	rc,0	/* still some life give it a chance */
	rem
dstest	gocase	lastf,downst,dslabl /* do the work */
	meter2	rtyrcv,1	/* not handle here meter it */
	dumpin		/* ignore it */
	setchr	fmask,null	/* no finial here */
	clrlcf	flgwd1,fbit
	waitm		/* go back to where came from */
	ttls	t3 state
	eject
	rem
************************************************************
*
*	t3 state DCE use only - set t3 and wait for sarm
*	 for LAP and UA for LAPB
*
************************************************************
	rem
t3tat	setlcl	retlbl,t3tat	/* return label for stpchn */
	wait	tmt3,badoa,testst /* main wait for t3 state */
	status	0,dsr,hang	/* dead line - hangup */
	status	exh,0,exhsta	/* exhaust */
	status	fcserr,0,fcesta	/* fcs error */
	status	rcvabt,0,rabsta	/* read abort */
	status	rcvtrm,0,rdnt3	/* reader terminate */
	status	term,0,outpcw	/* output terminate */
	status	xte,0,xtesta	/* punt transferred timing error */
	rem
rdnt3	meterm	frmrcv	/* meter this */
	calasm	valfrm	/* get function from input */
	goto	t3test	/* go do the work */
	rem
tmt3	calsub	timeo	/* which time */
	tstlcf	flgwd1,timet3,dsdscp /* t3 expired go down */
	rem
t3test	gocase	lastf,t3stat,t3labl /* do the work */
	meter2	rtyrcv,1	/* not handle here */
	dumpin		/* ignore it */
	setchr	fmask,null	/* no finial here */
	clrlcf	flgwd1,fbit
	waitm		/* go back were we came from */
	ttls	ss state (lapb only)
	eject
	rem
************************************************************
*
*	ss state a LAPB state for link initialization.
*	  It is waiting for a UA response to the previous 
*	 SABM command 
*
************************************************************
	rem
pssute	clrlcf	flgwd3,hldvar
	setlcf	flgwd2,snsabm	/* sabm is to be sent */
	calsub	outlst
	setlcf	flgwd1,timesw
	setimv	t1
	setlcl	rc,0
sspbst	setlcl	retlbl,sspbst	/* return label for stpchn */
	wait	tmss,badoa,testst /* main wait for ss state */
	status	0,dsr,hang	/* line drop */
	status	exh,0,exhsta	/* exhaust conditions */
	status	fcserr,0,fcesta	/* fcs error */
	status	rcvabt,0,rabsta	/* read abort */
	status	rcvtrm,0,rdnss	/* read terminate */
	status	term,0,outpcw	/* output terminate */
	status	xte,0,xtesta	/* punt transferred timing error */
	rem
tmss	calsub	timeo	/* which timer */
	goto	sstest	/* process it */
	rem
rdnss	meterm	frmrcv	/* meter the input */
	calasm	valfrm	/* what function to preform */
	rem
sstest	gocase	lastf,ssstat,sslabl /* driver to process ss state */
	dumpin		/* not process here dump it */
	meter2	rtyrcv,1	/* meter it */
	setchr	fmask,null	/* no finial here */
	clrlcf	flgwd1,fbit
	waitm		/* go back to wait */
	rem
	ttls	set up state
	eject
	rem
************************************************************
*
*	setup state a short distant to link up, only
*	 need a UA to complete it (lap)
*
************************************************************
	rem
psuste	setlcf	flgwd2,snsarm	/* send a sarm now */
	calsub	outlst
	setlcf	flgwd1,timesw
	setimv	t1
	setlcl	rc,0
sustte	setlcl	retlbl,sustte	/* return label for stpchn */
	wait	timesu,badoa,testst /* main wait */
	status	0,dsr,hang	/* drop line hangup */
	status	exh,0,exhsta	/* exhaust condition */
	status	fcserr,0,fcesta	/* fcs error */
	status	rcvabt,0,rabsta	/* read abort */
	status	rcvtrm,0,rdnsu	/* read terminate */
	status	term,0,outpcw	/* output terminate */
	status	xte,0,xtesta	/* punt transferred timing error */
	rem
rdnsu	meterm	frmrcv	/* meter input */
	calasm	valfrm	/* process ctr field */
	goto	sutest
	rem
timesu	calsub	timeo	/* which time is it */
sutest	gocase	lastf,sustat,sulabl /* process the frame */
	dumpin		/* not process here */
	meter2	rtyrcv,1	/* meter it */
	setchr	fmask,null	/* no finial here */
	clrlcf	flgwd1,fbit
	waitm		/* return back to last wait */
	ttls	link up state (information transfer state)
	eject
	rem
************************************************************
*
*	Link up stae this contains two side of the protocol
*	 the primary and the secondary. To insure the proper
*	 rountines to call a double gocase is perform. The
*	 first is to get the right tables, the second is to call the 
*	 right function.
*
************************************************************
	rem
linkup	setlcl	retlbl,linkup	/* return lable for stpchn */
	wait	timelk,writeo,testst /* main linkup wait */
	status	0,dsr,hang	/* line drop hangup */
	status	exh,0,exhsta	/* exhaust condition */
	status	fcserr,0,fcesta	/* fcs error */
	status	rcvabt,0,rabsta	/* read abort */
	status	rcvtrm,0,rdnlk	/* read terminate */
	status	term,0,outpcw	/* output terminate */
	status	xte,0,xtesta	/* punt transferred timing error */
	rem
timelk	calsub	timeo	/* which time is it */
	goto	tmlk
	rem
rdnlk	meterm	frmrcv	/* meter input */
	calasm	valfrm	/* find which function is it */
	cmpchr	frmadr,locadr,secmpr /* secondary side */
	setlcv	lkupws,pstate	/* no primary side */
	goto	tmlk
	rem
secmpr	setlcv	lkupws,sstate /* set to secondary tables */
	rem
tmlk	gocase	lkupws,whstgc,whgclb /* which table to use */
	dumpin		/* bad input */
	meter2	rtyrcv,1
	waitm
	rem
lkpnr	gocase	lastf,prinr,pnrlbl /* primary mornal */
	goto	lkpret	/* not handle function */
	rem
lkprb	gocase	lastf,prirb,prblbl /* primary remote busy */
	goto	lkpret	/* not handle function */
	rem
lkpt1	gocase	lastf,prit1,pt1lbl /* primary t1 expired */
	goto	lkpret	/* not handle functions */
	rem
lkpsr	gocase	lastf,prisr,psrlbl /* primary sarm sent (lap)*/
	goto	lkpret	/* not handle functions */
	rem
lksnm	gocase	lastf,secnm,snmlbl /* secondary normal */
	goto	lkpret	/* not handle functions */
	rem
lkslb	gocase	lastf,seclb,slblbl /* secondary local busy */
	goto	lkpret	/* not handle functions */
	rem
lksrj	gocase	lastf,secrj,srjlbl /* secondary reject */
	goto	lkpret	/* functions not handle */
	rem
lkscs	gocase	lastf,seccs,scslbl /* secondary command sent */
	goto	lkpret	/* functions not handle */
	rem
lkfrlb	gocase	lastf,prifr,lbfrtv /* frame reject (lapb) */
	goto	lkpret	/* function not handle */
	rem
lkrslb	gocase	lastf,prisrt,lbrstv /* reset sabm (lapb) */
	rem
	setchr	fmask,null
	clrlcf	flgwd1,fbit
lkpret	dumpin		/* ignore function */
	meter2	rtyrcv,1	/* meter anyway */
	waitm
	ttls driver call functional code for X.25 protocol
	eject
	rem
************************************************************
*
*	dssnua - down state, receive disc send ua
*	  if lap dce send ua plus a disc
*	  if lap dte just a ua
*	  if lapb dce just a ua
*	  if lapb dte send ua plus a disc
*
************************************************************
	rem
dssnua	setlcf	flgwd2,snua	/* set send ua flag */
	calsub	outlst	/* output it */
	dumpin		/* dump any input */
	setimv	t1	/* set timer */
	setlcf	flgwd1,timesw	/* set indicator timer is running */
	tstlcf	flgwd1,laparb,lpbtst /* test for lapb */
	rem
	tstlcf	flgwd1,dcedte,stdisc /* test for dce */
	rem
dsrtsn	waitm		/* nothing more to do */
	rem
lpbtst	tstlcf	flgwd1,dcedte,dsrtsn /* test for dce */
stdisc	setlcf	flgwd2,sndisc	/* set flag it will be sent later */
	waitm		/* that is all */
	rem
	rem
************************************************************
*
*	dmstt3 - dm recieve while in down state
*	send mode setting response (sabm) in lapb only
*	if lap - ingore it as an error
*
************************************************************
	rem
dmstt3	tstlcf	flgwd1,laparb,dmst3n /* is it lapb */
	goto	lkpret	/* no error ingore it */
dmst3n	setlcf	flgwd2,snsabm	/* send a sabm */
	clrlcf	flgwd3,hldvar	/* no ua to hold */
	goto	srtt3
	rem
	rem
************************************************************
*
*	srtt3 - start t3 timer
*	if dte then do;
*	  if lap go to su state, send a sarm, and wait for a ua
*	  if lapb go to ss state, send a sabm, and wait for a ua
*	end
*	else do;
*	  go to t3 state
*	  set t3 timer
*	  wait for approxiate command
*	end;
*
************************************************************
	rem
srtt3	tstlcf	flgwd3,hldvar,srt3i	/* do we readly want to go to t3  state */
	setime	0	/* reset timer */
	setlcl	rc,0	/* reset rc counter */
	clrlcf	flgwd1,timesw	/* reset timer running flag */
	calsub	fbitck	/* check final bit */
	dumpin		/* dump any input */
	tstlcf	flgwd1,dcedte,t3sts /* test for dce */
	rem
	setimv	t1	/* set timer to t1 */
	clrlcf	flgwd1,timet3	/* reset t3 flag */
	setlcf	flgwd1,timesw	/* set t1 flag */
	tstlcf	flgwd1,laparb,t3sbm /* dce send sabm */
	setlcf	flgwd2,snsarm	/* set send sarm for lap */
	calsub	outlst	/* output it */
	setlcl	state,lksust
	goto	sustte	/* go to set up state */
	rem
t3sbm	setlcf	flgwd2,snsabm	/* set send sabm flag for lapb */
	calsub	outlst	/* output it */
	setlcl	state,lkssst
	goto	sspbst	/* go to send sabm state */
	rem
t3sts	setimv	t3	/* set timer to t3 */
	setlcf	flgwd1,timesw	/* set timer running flag */
	setlcf	flgwd1,timet3	/* set t3 flag */
	setlcl	state,lkt3st
	calsub	outlst	/*just in case (dm sabm request) */
	goto	t3tat	/* go to t3 state */
	rem
srt3i	clrlcf	flgwd3,hldvar	/*no holding now */
	calsub	fbitck
	dumpin
	waitm
	rem
	rem
************************************************************
*
*	disct1 - t1 expired send disc - polled
*
*	dst1ep - same as above but doesn't increase rc
*
************************************************************
	rem
disct1	addlcl	rc,1	/* add one to retry counter */
dst1ep	setchr	pmask,pfon	/* set poll bit */
	setlcf	flgwd2,sndisc	/* send a disc */
	calsub	outlst	/* output it */
	setlcf	flgwd1,timesw	/* set timer running flag */
	setimv	t1	/* set timer */
	waitm
	rem
	rem
************************************************************
*
*	dst1e - t1 expired with rc = n2
*	  if dte lapb reset timer and ignore
*	  It should be HANGUP for DTE on both lap & lapb
*
************************************************************
	rem
dst1e	tstlcf	flgwd1,laparb,dst1e2 /* if lapb */
	goto	dst1ep
	rem
dst1e2	tstlcf	flgwd1,dcedte,dst1ep /* if dce */
	clrlcf	flgwd1,timesw	/* reset timer flag */
	setime	0	/* reset timer */
	setlcl	rc,0	/* clear the retry count for later */
	waitm
	rem
	rem
************************************************************
*
*	sndua - send ua and remine here
*
************************************************************
	rem
sndua1	setlcf	flgwd1,psarm
sndua	setlcf	flgwd2,snua	/* set send ua flag */
	meter2	resrcv,1	/* meter this, but it not right */
	dumpin		/* dump any input */
	calsub	fbitck	/* check f-bit */
	calsub	outlst	/* output it */
	waitm
	rem
	rem
************************************************************
*
*	dsdisc - send disc go to down state (link still down )
*
*	dsdscp - same as above but send a poll disc
*
************************************************************
	rem
ckdisc	setlcf	flgwd3,hldvar	/* DM slow UA process to SS state */
	tstlcf	flgwd1,discft,dsdisc
	clrlcf	flgwd3,hldvar	/*no down state let t1 handle it */
	dumpin
	waitm
ckdscp	tstlcf	flgwd1,discft,dsdscp
	goto	t1sbmg	/* ss state t1 expired rc=n2 */
	rem
dsdscp	setchr	pmask,pfon	/* set polled bit */
dsdisc	setlcf	flgwd1,downsw	/* set down flag */
	setlcl	flgwd2,0	/* clear out output control */
	calsub	fbitck	/* check for f-bit */
	dumpin		/* dump any input */
	goto	dwnst	/* goto down state */
	rem
	rem
************************************************************
*
*	susua - send ua and goto to setup state (lap only)
*	 since DCE are in t3, no check for dte needed
*	 if lapb - set lastf to bad command go to driver
*	 else send a sarm, send ua, reset t3, goto su state 
*
************************************************************
	rem
susua	tstlcf	flgwd1,laparb,t3bcrd /* lapb bad news */
	setlcf	flgwd1,psarm	/* sarm recieve */
	clrlcf	flgwd1,timet3	/* clear t3 timer */
	setime	0	/* clear timer */
	setlcl	rc,0	/* reset retry counter */
	dumpin		/* dump any input */
	setlcl	state,lksust	/* set state to su */
	setlcf	flgwd2,snsarm	/* one sarm needed */
	setlcf	flgwd2,snua	/* also one ua */
	calsub	outlst	/* output one of them */
	setimv	t1	/* set timer */
	setlcf	flgwd1,timesw	/* insure timer is running */
	goto	sustte	/* go to su state wait */
	rem
t3bcrd	setlcl	lastf,rvbdcr	/* bad command */
	goto	t3test	/* t3 state driver entry */
	rem
	rem
************************************************************
*
*	lpbiup - lapb initial linkup entry
*	 if state = t3state send a ua
*	 if lap entry then bad command (label t3bcrd)
*	lkupst- -linkup for lap
*	lpbpup - reset link (lapb) do not report to host
*	 status
*
************************************************************
	rem
ckupst	tstlcf	flgwd1,psarm,lkupst
	calsub	fbitck	/* check f-bit */
	dumpin		/* UA no longer needed */
	waitm
lpbiup	tstlcf	flgwd1,laparb,lkupst /* if lapb */
	goto	t3bcrd	/* no bad command */
lkupst	setlcf	flgwd1,rprtsw	/* report to host link failure */
	signal	dialup	/* the host we are up */
lpbpup	calsub	fbitck	/* check f-bit */
	dumpin		/* dump any input */
	clrlcf	flgwd1,psarm
	clrlcf	flgwd1,downsw	/* clear down indicator */
	setlcl	flgwd2,0	/* clear any output */
	tstlcl	state,lkt3st,snualk /* send a ua */
	tstlcl	pstate,lkupfr,snualk /* also send ua */
	goto	norlku	/* no ua needed */
	rem
snualk	setlcf	flgwd2,snua	/* set ua flag */
	calsub	outlst	/* output it */
	rem
norlku	clrlcf	flgwd1,timesw	/* clear timer */
	clrlcf	flgwd1,timet3	/* clear t3 flag */
	setlcl	flgwd3,0	/* reset some flags */
	setlcl	v.s,0	/* clear the state variables */
	setlcl	v.r,0
	setlcl	a.s,0
	setlcl	a.r,0
	setlcl	rc,0	/* reset retry counter */
	setlcl	uaoffs,0	/* set to top message (first
*			  unacknowledge message */
	clrlcf	flgwd1,t1rec
	setime	0	/* clear time */
	setlcl	state,lkisup	/* set statte to link up */
	setlcl	pstate,lkprnr	/* set p state to normal */
	setlcl	sstate,lkscnm	/* set s state to normal */
	setchr	pmask,null	/* reset mask bits */
	setchr	fmask,null
	setchr	cmdrb1,null	/* no cmdr/frmr info */
	calasm	scanup
	tstlcl	bufadd,0,nupwt	/* any thing to write */
	setlcf	flgwd2,snifr	/* yes */
	calsub	outlst	/* output if we can */
nupwt	calsub	sigotp	/* check for sndout requirements */
	goto	linkup	/* that is all to link up */
	rem
	rem
************************************************************
*
*	t3t1ln - t3 state t1 expired rc < n2
*	 This is currently impositiable - for their is only
*	 one timer running. Incase  it is corrected inc rc
*	 and restart the timer.
*
************************************************************
	rem
t3t1ln	addlcl	rc,1	/* inc rc counter */
	setlcf	flgwd1,timesw	/* start timer flag */
	setimv	t1	/* set timer going */
	waitm
	rem
	rem
************************************************************
*
*	sndsbm - meter bad command send a sabm and remain
*
************************************************************
	rem
sndsbm	meter2	rtyrcv,1	/* meter bad command */
	dumpin		/* no input needed */
	setlcf	flgwd2,snsabm	/* set send sabm flag */
	calsub	outlst	/* output it */
	waitm
	rem
	rem
************************************************************
*
*	t1sabm - t1 expired send a sabm and remain
*
************************************************************
	rem
t1sabm	addlcl	rc,1	/* inc retry counter */
t1sbmg	setchr	pmask,pfon
	setlcf	flgwd2,snsabm	/* set send sabm flag */
	calsub	outlst	/* output it */
	setlcf	flgwd1,timesw	/* set timer flag */
	setimv	t1	/* start timer */
	waitm
	rem
	rem
************************************************************
*
*	dsdsua - send disc, send ua, go to down state (lap)
*	 if dte send just a ua
*	 else send both disc and a ua
*
************************************************************
	rem
dsdsua	meter2	resrcv,1	/* meter reset counts */
	setlcl	flgwd2,0	/* clear any output messages */
	setchr	pmask,null	/* no poll needed */
	clrlcf	flgwd1,pbit	/* clear bit */
	setlcf	flgwd2,snua	/* set send ua flag */
	tstlcf	flgwd1,dcedte,dcdsua /*dce test */
	goto	dtdsua	/* nothing for dte */
dcdsua	setlcf	flgwd2,sndisc	/* need one disc */
dtdsua	dumpin		/* no input needed */
	calsub	outlst	/* output anything that is left */
	setlcl	rc,0	/* reset retry counter */
	setlcf	flgwd1,timesw	/* set timer flag */
	setimv	t1	/* set timer going */
	goto	dwnst	/* go to down state */
	rem
	rem
************************************************************
*
*	sndsmp - send pol sarm and remain
*	tisarm - same
*
************************************************************
	rem
tisarm	null
sndsmp	setchr	pmask,pfon	/* set pol bit */
	addlcl	rc,1	/* inc retry counter */
	setlcf	flgwd2,snsarm	/* set sarm flag */
	dumpin		/* dump any input */
	setlcf	flgwd1,timesw	/* restart the timer */
	calsub	outlst
	setimv	t1
	waitm
	rem
	rem
************************************************************
*
*	frsrrq - frame reject or sarm required
*	 if lapb send frame reject and goto fr state
*	 else send sarm go to sr state 
*
************************************************************
	rem
frsrrq	meter2	resxmt,1	/* meter link reset */
	setlcl	rc,0	/* reset retry conter */
	setlcf	flgwd1,timesw
	tstlcf	flgwd1,laparb,lpbfrc /* lapb test */
	setlcf	flgwd2,snsarm	/* sarm needed (lap) */
	setlcl	pstate,lkprsr	/* set primary to new state */
	goto	frsren	/* go to continue */
lpbfrc	setlcf	flgwd2,snfrmr	/* set send frmr */
	calasm	blfcdr	/* generate the frmr fields */
	calasm	ldnsdr	/* load the n(s) value */
	setlcl	pstate,lkupfr	/* set sub state to fr state */
	setlcl	sstate,lkupfr
frsren	dumpin	/* dump input now */
	calsub	outlst
	setimv	t1	/* restart timer */
	waitm
	rem
	rem
************************************************************
*
*	sborsm - send SABM or SARM
*	  if LAP then send SARM and go to sarm reset state.
*	  else if LAPB then send SABM and go to reset state
*
************************************************************
	rem
sborsm	tstlcl	lastf,rvcmdr,cmchkl /* check I-frame length problem
	goto	sbors1	/* no continue */
cmchkl	tstlcl	cmdrln,0,sbors1 /* length error */
	setlcf	flgwd2,sndisc /* send disc to crash the link */
	calsub	outlst	/* get the disc out
	setlcl	stat0,lstcmr /* set cmdr reject */
	linsta	stat0	/* send in the status */
	clrlcf	flgwd1,rprtsw /* clear report indicator */
	goto	deact	/* crash the link */
sbors1	meter2	resxmt,1	/* meter link reset */
	setlcl	rc,0	/* reset counter */
	setlcf	flgwd1,timesw /* needed timer */
	tstlcf	flgwd1,laparb,lpbsbb /* lap or lapb */
	setlcl	pstate,lkprsr /* set sarm reset state */
	setlcf	flgwd2,snsarm /* send sarm */
	goto	sbsmct
lpbsbb	setlcl	pstate,lkuprs /* set reset state */
	setlcl	sstate,lkuprs /* just in case */
	setlcf	flgwd2,snsabm /* send sabm */
sbsmct	dumpin
	calsub	outlst	/* send the message */
	setimv	t1	/* set timer */
	setlcf	flgwd1,timesw /* set timer flags */
	waitm
	rem
	rem
************************************************************
*
*	uaigfr - UA receive during substates normal, t1
*	 expired, and remote busy. Ignore it unless it lapb
*	 then go to frame reject
*
************************************************************
	rem
uaigfr	calsub	fbitck	/* check the f-bit */
	tstlcf	flgwd1,laparb,frsrrq /* lapb frsrrq can do it */
	dumpin		/* input not needed now */
	waitm		/* ignore it, go back to start */
	rem
	rem
************************************************************
*
*	nrrr - Recieve RR frame - go back to nornal substate
*	 set xx and n(r), ack any frame, also set fbit and
*	 timer
*
************************************************************
	rem
nrrr	tstlcl	sstate,lksccs,cshook /* cs (lap) generate aproper response*/
	calsub	fbitck	/* process f bit */
	dumpin
	tstlcl	pstate,lkprrb,rsprrb /* remote busy some special */
	setlcl	pstate,lkprnr	/* set p state to normal */
	tstlcv	a.r,n.r,gowait	/* ack any */
	calsub	ackmsg	/* ok ack them */
	goto	suakst
rsprrb	setlcl	pstate,lkprnr	/* set pstate to normal */
	calsub	ackmsg	/* ack any frames */
	setlcv	v.s,n.r	/* set v.s to normal */
	rem		/* a.r will be handle by the ACK process */
	calsub	clrrbb	/* set up next output frame */
suakst	setlcl	rc,0	/* reset retry counter */
	tstlcv	v.s,a.r,rclkrr	/* if equal reset clock */
	setlcf	flgwd1,timesw	/* no restart timer */
	setimv	t1
gowait	tstlcf	flgwd1,t1rec,rect1 /* tier recovery in process */
	tstlcf	flgwd3,rtyhld,hldrty /* more t1 recovery LAPB left over */
gownt1	calsub	outlst	/* output any thing */
	gotov	retlbl	/* that is all */
	rem
************************************************************
*
*	This should be only LAPB condition - reset
*	I-frame hold flag and restart i_frame processing
*
************************************************************
hldrty	clrlcf	flgwd3,rtyhld	/* reset i-frame hold */
	calsub	clrrbb	/* setup next output i-frame */
	goto	gownt1	/* finish up */
	rem
rect1	clrlcf	flgwd1,t1rec	/* reset recovery flag */
	clrlcf	flgwd3,rtyhld	/* reset i-frame hold */
	setlcl	rc,0	/* reset retry counter */
	calsub	clrrbb	/* setup next output frame */
************************************************************
*
*	lapb on timer recovery reset , must check for  
*	 unack frames if any the polled bit must be set
*	 again for next I-frame to be sent
*
************************************************************
	rem
	tstlcf	flgwd1,laparb,trplms /* is it lapb */
	goto	gownt1	/* no proceed */
trplms	tstlcv	xx,a.r,gownt1	/* all ack return */
	tstlcl	bufadd,0,gownt1	/* test for no output */
	setchr	pmask,pfon	/* set poll on */
	setlcf	flgwd1,pbit	/* set bit */
	setlcf	flgwd3,mstifr	/* must send one I-frame out */
	calsub	outlst	/* output poll I-frame */
	setlcf	flgwd3,rtyhld	/* no more i-frame wait for response */
	gotov	retlbl	/* go back to normal wait */
	rem
rclkrr	tstlcl	uaoffs,0,rclkra /* any unack messages? */
	punt	3	/* yes crash for there shouldn't be */
rclkra	null
	clrlcf	flgwd1,timesw	/* clear flag */
	setime	0	/* reset timer */
	goto	gowait	/* now finish it up */
	rem
	rem
************************************************************
*
*	rbrnr - go to remote busy and process rnr message 
*
************************************************************
	rem
rbrnr	tstlcl	sstate,lksccs,cshook /* lap error */
	calsub	fbitck	/* process f-bit */
	setlcl	pstate,lkprrb	/* set pstate to remote busy */
	dumpin
	calsub	ackmsg	/* ack any output messages */
	setlcl	uaoffs,0	/* sending no more, top one is next*/
	tstlcf	flgwd1,timesw,rbrn1 /* reset timer needed */
	goto	rbrnr2
rbrn1	setlcl	rc,0	/* reset retry counter */
	setlcf	flgwd1,timesw	/* reset timer */
	setimv	t1
rbrnr2	waitm
	rem
	rem
************************************************************
*
*	nrrej - normal state rej recieve
*
************************************************************
	rem
nrrej	tstlcl	sstate,lksccs,cshook
	calsub	fbitck
	setlcl	pstate,lkprnr	/*set state to normal */
	meter2	rtyxmt,1	/* meter this one */
	calsub	ackmsg	/* ack any output messages */
	calsub	rejrst	/* get reject message */
	dumpin		/* input not needed */
	tstlcv	v.s,a.r,rclkrr /* recieve last message so stop the clock */
	setlcv	v.s,n.r	/* transmit this frame next */
	goto	gowait	/*some more check common area */
	rem
	rem
************************************************************
*
*	t1stch - t1 expired retramit the earlest I-frame
*	 In lapb case start sending poll rr frames
*
************************************************************
	rem
t1stch	meter2	rtyxmt,1	/* meter this */
	clrlcf	flgwd3,rtyhld	/* tempory reset i-frame hold */
	addlcl	rc,1	/* inc the retry counter */
	setlcl	pstate,lkprt1	/* set pstate to t1 recovery */
	setlcf	flgwd1,t1rec	/* set t1 recovery flag */
	setlcv	xx,v.s	/* save current value */
	setlcv	v.s,a.r	/* set to first unack frame */
	setchr	pmask,pfon	/* set poll bit */
	setlcf	flgwd1,pbit
	setimv	t1	/* reset time for next time out */
	setlcl	uaoffs,0	/* setup first message */
	tstlcf	flgwd1,laparb,lpbt1s /* test for lapb */
	tstlcl	bufadd,0,lpanif
	setlcf	flgwd2,snifr	/* set i frame to transmit */
	setlcf	flgwd3,mstifr	/* force at least one I-frame */
t1stou	calsub	outlst	/* output it */
	setlcf	flgwd3,rtyhld	/*no I-frame to be sent */
lpanif	waitm	/* that is all */
lpbt1s	clrlcf	flgwd2,snifr	/* lapb no i-frame during recovery */
	setlcf	flgwd2,snprr	/* set poll rr message needed */
	goto	t1stou
	rem
	rem
************************************************************
*
*	n2rssr - t1 expired with rc = n2
*	 lap go to sr state and send sarm
*	 lapb go to rs state and send sabm
*
************************************************************
	rem
n2rssr	meter2	resxmt,1	/* meter this */
	setchr	pmask,null	/* no needed poll bit yet */
	clrlcf	flgwd1,pbit
	setlcl	rc,0	/* reset retry counter */
	tstlcf	flgwd1,laparb,lpbsbs
	setlcl	pstate,lkprsr	/* set pstate to sr state */
	setlcf	flgwd2,snsarm	/* set send sarm flag */
	goto	n2rrsc
lpbsbs	setlcl	pstate,lkuprs	/* set stats to reset sabm */
	setlcl	sstate,lkuprs
	setlcf	flgwd2,snsabm	/* send sabm now */
n2rrsc	dumpin
	calsub	outlst
	setlcf	flgwd1,timesw	/* reset timer */
	setimv	t1	/* restart the timer */
	waitm
	rem
	rem
************************************************************
*
*	backnr - LAP only go back to normal state reset
*	 outgoing frames and v.s, a.s values
*
************************************************************
	rem
backnr	clrlcf	flgwd1,t1rec	/* no timer recovery */
	clrlcf	flgwd3,rtyhld	/* no i-frame holding */
	dumpin		/* needed no input */
	setlcl	v.s,0	/* reset some values */
	setlcl	a.r,0
	setime	0	/* reset timer */
	setlcl	rc,0	/* reset retry counter */
	clrlcf	flgwd1,timesw	/* reset timer indicator */
	setchr	fmask,null	/* reset maskes */
	setchr	pmask,null
	setlcl	uaoffs,0	/* reset i-frame to top */
	calasm	scanup
	tstlcl	bufadd,0,bknrni	/* any i-frame to transmit */
	setlcf	flgwd2,snifr	/* some to go */
bknrni	setlcl	pstate,lkprnr	/* set pstate to normal */
	calsub	outlst	/* output frames */
	calsub	sigotp	/* tell HOST of output */
	waitm
	rem
	rem
************************************************************
*
*	tidisc - t1 expired with rc = n2 send dics and go down
*
************************************************************
	rem
tidisc	meter2	resxmt,1	/* meter this stuff */
	setlcl	rc,0	/* reset counter */
	setchr	pmask,null	/* reset mask */
	clrlcf	flgwd1,pbit
	setlcf	flgwd1,downsw	/* indicat we are down */
	setlcl	flgwd2,0	/* reset output flags */
	setlcf	flgwd2,sndisc	/* send a disc */
	calsub	fbitck
	calsub	outlst	/* output the disc */
	goto	dwnst	/* go down now */
	rem
************************************************************
*
*	dsduab - if lap then use dsdsua by goto
*	 else if lapb then send a ua and go to down state
*
************************************************************
	rem
	rem
dsduab	tstlcf	flgwd1,laparb,dsdub /* test for lapb */
	goto	dsdsua	/* lap only */
dsdub	setlcl	flgwd2,0	/* reset output flags */
	setchr	pmask,null	/* reset poll bit */
	setlcf	flgwd2,snua	/* flag a send ua */
	calsub	outlst	/* output it now */
	goto 	dwnst	/* ok go down now */
	rem
	rem
************************************************************
*
*	nmdua - send ua and clear this state.
*
*	nmsdua - go to normal   (lap only )
*
************************************************************
	rem
	rem
nmsdua	tstlcf	flgwd1,laparb,frcmdr /* lapb error */
	setlcl	sstate,lkscnm	/* reset state */
	setchr	cmdrb1,null /* clear cmdr fields */
nmdua	tstlcf	flgwd1,laparb,frcmdr /* lapb error */
	setlcl	v.r,0	/* reset recieve variables */
	setlcl	a.s,0
	tstlcl	bufadd,0,nmdua1
	setlcf	flgwd2,snifr	/* tried to write something */
nmdua1	setlcl	flgwd2,snua	/* send a ua */
	meter2	resrcv,1	/* meter the reset recieve */
	dumpin
	calsub	outlst	/* send ua out */
	waitm
	rem
	rem
************************************************************
*
*	nmduab - recieve sabm send a ua and reset link
*	 (lapb only )
*
************************************************************
	rem
nmduab	tstlcf	flgwd1,laparb,nmdubc /* test for lapb */
	goto	frcmdr	/* no it a lap */
nmdubc	setlcl	flgwd2,0	/* clear all output stuff */
	dumpin		/* no more input needed */
	goto	snualk	/* reset link via linkup code */
	rem
	rem
************************************************************
*
*	frcmdr - build reject fields and set state as follows
*	 if lap then set state to CS
*	 else if lapb then set state to FR
*
*	sndcmd - cs lap only send cmdr again
*
*	sndfr - fr lapb only send frmr again
*	   NOTE cmdr and frmr are the same command
*
************************************************************
	rem
frcmdr	calasm	blfcdr	/* build the reject frame */
	tstlcf	flgwd1,laparb,lpbfrb /* test for lapb */
	setlcl	sstate,lksccs	/* lap set state */
	goto	sndcmd	/* continue on */
lpbfrb	setlcl	sstate,lkupfr	/* set laps state */
	setlcl	pstate,lkupfr
	calasm	ldnsdr
sndfr	null		 /* lapb entry */
sndcmd	setlcf	flgwd2,sncmdr	/* set output flag */
	meter2	rtyrcv,1	/* meter this */
	dumpin	/* input not needed */
	calsub	outlst	/* output the command */
	waitm
	rem
	rem
************************************************************
*
*	rjrej - Reject - bad I-frame only one reject can be
*	 sent.
*
*	rej1 - same as reject but no rej is sent
*
************************************************************
	rem
rjrej	setlcl	sstate,lkscrj	/* set sstate to reject state */
	setlcf	flgwd2,snrej	/* set reject flag */
rej1	calsub	ackmsg	/* ack any frames */
	calsub	outlst	/* output any messages */
	meter2	rtyrcv,1	/* meter it */
	dumpin
	waitm
	rem
	rem
************************************************************
*
*	nmif - process I-frame and stay here
*
*	pnmif - process I-frame and go to normal state
*	 also check for local busy conditions
*
************************************************************
	rem
pnmif	setlcl	sstate,lkscnm	/* set sstate */
nmif	calasm	ckrnr	/* check for local busy */
	tstlcl	rnrflg,0,nmifa	/* is it */
	goto	sndrt1
nmifa	calsub	ackmsg	/* ack any frames */
	setlcv	amarg1,v.r	/* set mod8 arith */
	setlcl	amarg2,1
	calasm	admod8
	setlcv	v.r,amarg2
	calasm	setbrk	/* set break flag */
	sendin		/* send it off to the HOST */
	tstlcv	a.r,v.s,rcnmif	/* reset timer */
	goto	nmifct
rcnmif	tstlcf	flgwd1,t1rec,nmifct /* if recovery in process skip */
	tstlcl	uaoffs,0,rcnmfa	/*  some unack buffers ? */
	punt	3	/* shouldn't be any crash */
rcnmfa	null
	clrlcf	flgwd1,timesw
	setime	0
nmifct	null
	setlcf	flgwd2,snrr	/* ack this last frame */
	calsub	outlst	/* do it now */
	waitm
	rem
	rem
************************************************************
*
*	finrr - poll response recieve send a rr back
*
*	finrej - since one rej can be send send a rr back 
*	 instead
*
************************************************************
	rem
finrr	null
finrej	calsub	ackmsg	/* ack any frames */
	dumpin
	setlcf	flgwd2,snrr	/* send the rr */
	calsub	outlst
	waitm
	rem
	rem
************************************************************
*
*	sndrnr - send RNR remote busy recieve I-frame
*	 test for not busy if so process as normal
*
************************************************************
	rem
sndrnr	calasm	ckrnr	/* check for local busy */
	tstlcl	rnrflg,1,sndrt1	/* yes it is */
	setlcl	sstate,lkscnm
	goto	secmpr	/* reprocess it */
sndrt1	setlcl	sstate,lksclb	/* set local busy condition */
	meter2	rtyrcv,1	/* meter this */
	calsub	ackmsg	/* ack any frames */
	dumpin
	setlcf	flgwd2,snrnr	/* send  rnr */
	calsub	outlst
	waitm
	rem
	rem
************************************************************
*
*	finrnr - poll response recieve send an rnr back
*
************************************************************
	rem
finrnr	calsub	ackmsg	/* ack any input frames */
	dumpin
	calasm	ckrnr	/* check if busy has been clear */
	tstlcl	rnrflg,0,finrn1
	setlcf	flgwd2,snrnr /* no send rnr */
	goto	finrn2
finrn1	setlcl	sstate,lkscnm /* normal state */
	setlcf	flgwd2,snrr /*send rr */
finrn2	calsub	outlst
	waitm
	rem
	rem
************************************************************
*
*	discds - either recieve DM or t1 expired with rc = n2
*	 on both FR and RS state - send disc and go down
*
************************************************************
	rem
discds	setlcl	flgwd2,0	/* clear out flags */
	dumpin
	setlcf	flgwd2,sndisc	/* send a disc now */
	calsub	outlst
	goto	dwnst
	rem
	rem
************************************************************
*
*	rssabm - go to RS state and send a sabm
*
************************************************************
	rem
rssabm	calsub	fbitck	/* check f-bit */
	dumpin		/* dump any input */
	setlcf	flgwd1,timesw
	setimv	t1
	setlcf	flgwd2,snsabm	/* set sabm flags */
	setlcl	pstate,lkuprs	/* set states now */
	setlcl	sstate,lkuprs
	calsub	outlst	/* output sabm now */
	waitm
	rem
	rem
************************************************************
*
*	t1nor - t1 - expired rest timer and to rc and wait 
*
************************************************************
	rem
t1nor	addlcl	rc,1	/* inc rc counter */
	setlcf	flgwd1,timesw	/* set timer flag */
	setimv	t1	/* restart timer */
	waitm
	ttls	status called routines and errors handlers
	eject
	rem
************************************************************
*
*	exhsta - Got exhaust status.  This means an input tally runout
*	occurred which resets receive mode.  Therefore, we must
*	set receive mode on again.  Unfortunately, we cannot do
*	this immediately if there is a pending output dcw list.
*
*	stpchn at this point realy messup the x25_tables, therefore,
*	the code of stpchn is inserted here and is modified to
*	handle the unique problem of this tables.
*
*****************************************************************
	rem
exhsta	null
	meter2	m.exh,1	/* meter this conditions */
	goto	exhrst	/* and reset things */
	rem
xtesta	null
	meter1	m.xte,1	/* meter it */
	rem
exhrst	null
	contrl	rrec+rxmit+smark	/* reset transmit and recieve */
	setime	1	/* set a timer to insure resetting occures */
	wait	exhsta,exhwrt,testst	/* wait for reset */
	rem
************************************************************
*
*	NOTE: exhsta in time out is for insuring that the rrec and rxmit is performed.
*
*	exhwrt is to insure that no output is lost.
*
*	testst is to kill the line if a hangup is signalled.
*
************************************************************
	rem
	status	marker,0,exhret /* finish on stopping the channel */
	status	0,dsr,hang
*
exhwrt	setlcf	flgwd1,oasw	/* output arrive */
	setlcf	flgwd1,oprusw	/* say it has been recieve */
	waitm		/*go back to waiting */
*
exhrtr	setimv	t1	/ not right but timer will be restarted */
	goto	exhcnt
*
exhret	tstlcf	flgwd1,timesw,exhrtr /* timer running, set timer */
	setime	0	/* reset the timer */
exhcnt	null
	clrlcf	flgwd1,rcvsw	/* out of rcv mode */
	meter2	rtyrcv,1	/* meter also a retried to be preform */
	dumpin
	tstlcf	flgwd1,xmitsw,outpcw /* output was going process like term */
	contrl	srec	/* reset recieve mode */
	setlcf	flgwd1,rcvsw
	tstlcf	flgwd1,oprusw,writeo /* output has arrive process it */
	gotov	retlbl	/* return to previous wait */
	rem
	rem
************************************************************
*
*	FCS error on the frame
*
************************************************************
	rem
fcesta	meter2	mfce,1	/* meter it */
	goto	abtfn
	rem
	rem
************************************************************
*
*	read abort status
*
************************************************************
	rem
rabsta	meter2	mrab,1
abtfn	meter2	rtyrcv,1	/* meter everything as a retried */
	dumpin
	waitm
	rem
	rem
************************************************************
*
*	gopunt - unrecoverable error so DIE
*
************************************************************
	rem
gopunt	punt	2
	rem
	rem
************************************************************
*
*	hang - clean up tib extension and reset dtr 
*	 signals
*
*	hangr - delete the tib extension and signal hangup
*
************************************************************
	rem
hang	stpchn		/* kill the channel */
	clrlcf	flgwd1,xmitsw
	calsub	clrabf
	config
	rmode	fg.itf
	contrl	rdtr+rrts
hangr	unwind		/* in case we exited a subroutine */
	retext		/* release the extension */
	dumpin
hang2	dmpout
	tstwrt	hang2	/* loop untill all output is gone */
	clrflg	(tflisn,tfhang)
	signal	hangup
	goto	hungup
	rem
	rem
************************************************************
*
*	outpcw - output process complete check for more
*
************************************************************
	rem
outpcw	clrlcf	flgwd1,xmitsw	/* reset transmitter busy */
	tstlcf	flgwd1,ifrsnd,iprotm
	dmpout
	goto	iptmrt
outclr	calsub	clrabf	/* clear any data frames */
	goto	iptrta
iprotm	calasm	clrocp
iptmrt	tstlcf	flgwd3,mstclr,outclr
iptrta	tstlcf	flgwd1,rcvsw,sgoa /* is reciver running */
	contrl	srec	/* no restart it */
	setlcf	flgwd1,rcvsw
sgoa	tstlcf	flgwd1,ackrq,sgoa1
	goto	sgoa2
sgoa1	setlcv	n.r,nrv
	calsub	ackmsg
sgoa2	tstwrt	writa2	/* output on t.ocp process it */
	tstlcf	flgwd1,oprusw,write1
	clrlcf	flgwd1,ifrsnd	/* clear for next */
	tstlcf	flgwd1,ackrq,ackrtc
	calsub	outlst
	gotov	retlbl	/* insure right wait block */
	ttls	wait test routines and timer determination
	eject
	rem
************************************************************
*
*	timeo - time out processing set lastf to proper state
*
************************************************************
	rem
timeo	setlcl	lastf,rvbdad	/* set function to ignore value */
	setlcv	lkupws,pstate	/* set to primary state */
	tstlcf	flgwd1,timesw,cotime /* timer must be running */
retime	retsub
	rem
cotime	tstlcf	flgwd1,timet3,retime
	rem
	tstlcv	rc,n2,n2equl	/* rc = n2 */
	setlcl	lastf,rvt12l	/* no normal case */
	retsub
n2equl	setlcl	lastf,rvt12e	/* next state or down */
	retsub
	rem
	rem
************************************************************
*
*	testst - comman DIA test line status and orders
*
************************************************************
	rem
testst	tstflg	tfhang,hang	/* told to hangup */
	linctl	stat0,testwt	/* line status - no return */
	tstlcl	stat0,lctdea,deact /* told to deactivate the line */
	tstlcl	stat0,lctdis,dsdisc /* logical disconnect the line*/
*		  NOTE is status should never be used */
	rem
testwt	waitm
	rem
	rem
************************************************************
*
*	badoa - write recieve for actual linkup and linkup
*	 is not complete. Rember the write, but flush the output
*
************************************************************
	rem
badoa	setlcf	flgwd1,oasw	/* output arrived since last sndout */
	tstlcf	flgwd1,xmitsw,badoa2 /* xmit busy */
	dmpout		/* no dump output now */
badoa2	waitm
	rem
	rem
************************************************************
*
*	writeo - write output from the DIA (I-frame.
*	 This will not set up the control fiels in the I-frame
*	 nor will it set the clock and state variable, The outlst
*	 do the dirty work. Also the output is place on the
*	 unprocess chain for later processing.
*
************************************************************
	rem
writeo	setlcf	flgwd1,oasw	/* say we have output form host */
	setlcf	flgwd1,oprusw
	tstlcf	flgwd1,xmitsw,wrtrrt
	tstwrt	writa2
	clrlcf	flgwd1,oprusw
	goto	wrtret
write1	tstlcf	flgwd1,ifrsnd,writ1a
	goto	writa2
writ1a	calasm	scpbst
	clrlcf	flgwd1,ifrsnd
	goto	writa3
writa2	calasm	ocpset,(temups)
	calasm	clrocp
writa3	clrlcf	flgwd1,oprusw
	calasm	scupem
	tstlcf	flgwd1,ackrq,ackrtc
	calsub	outlst	/*tried to send it now */
wrtret	calsub	sigotp	/* signal the HOST */
wrtrrt	gotov	retlbl	/* insure right wait block */
	rem
ackrtc	clrlcf	flgwd1,ackrq
	calsub	sigotp	/* just incase ackmsg bypassed it */
	goto	suakst
	rem
	rem
************************************************************
*
*	clrabf - clear the buffer chain and reset some variables
*
************************************************************
	rem
clrabf	tstlcf	flgwd1,xmitsw,busyst
	tstwrt	clrbfn	/* anything on the output chain */
clrloo	calasm	setocp,(bufadd)
clrlo1	dmpout		/* dump the message */
clrlo2	tstwrt	clrlo1	/* anymore */
	tstlcl	upobuf,0,clrlo3
	calasm	setocp,(upobuf)
	setlcl	upobuf,0
	goto	clrlo2
clrlo3	calasm	setocp,(temclr)
	setlcl	temclr,0
	setlcl	kv,0	/* clean up a few things */
	setlcl	bufadd,0
	setlcl	uaoffs,0
	clrlcf	flgwd3,mstclr
	retsub
clrbfn	tstlcf	flgwd1,ifrsnd,clrloo /* onput frame  ignore it */
	calasm	ocpset,(temclr)
	goto	clrloo
busyst	setlcf	flgwd3,mstclr
	retsub
temclr	oct	0
	rem
	rem
****************************************************************
*
*	outlst - output a message under two different priorty
*	but first dm of lapb may be outputed.
*	if f bit send the following in order:  sarm, cmdr,
*	ua, rnr, rej, and rr. Otherwise the order is disc
*	sarm, cmdr, ua, rnr, rej, i, and rr.
*	 Lapb the sarm is sabm and cmdr is frmr. Also polled RR,
*	 RNR and REJ are send if so wanted
*
************************************************************
	rem
outlst	tstlcf	flgwd1,xmitsw,retotl /* busy return */
	tstlcf	flgwd1,fbit,flst /* f bit required */
	tstlcl	flgwd2,0,retotl	/* nothing to do return */
	calasm	getopt		/* find something to do
sddnnt	bldmsg	dmmsg,gopunt	/* create the dm message */
	outscn	setf,gopunt	/* set f bit */
	clrlcf	flgwd2,sndm	/* clear it indicator */
	goto	wret	/* write it now */
sdout	bldmsg	dscmsg,gopunt	/* build the disc message */
	outscn	setp,gopunt	/* set the p bit */
	clrlcf	flgwd2,sndisc	/* clear the flag */
	goto	wret	/* write it an d return */
ssout1	bldmsg	srmmsg,gopunt	/* build the sarm message */
	outscn	setp,gopunt	/* set the p bit */
	clrlcf	flgwd2,snsarm	/* clear the send sarm */
	goto	wret	/* write and return */
sbout1	bldmsg	sbmmsg,gopunt	/* build a sabm */
	outscn	setp,gopunt	/* set poll bit */
	clrlcf	flgwd2,snsabm
	goto	wret
scout1	bldmsg	cmdrms,gopunt	/* build the cmdr message */
	outscn	setf,gopunt	/* set the f bit */
	clrlcf	flgwd2,sncmdr	/* clear the send cmdr flag */
	goto	wret	/* write it and return */
sua1	bldmsg	uamsg,gopunt	/* build the ua message */
	outscn	setf,gopunt	/* set f bit */
	clrlcf	flgwd2,snua	/* clear the ua flag */
	goto	wret	/* write it and return */
srnr1	setchr	cfield,null	/* clear cfield */
	calsub	outseq	/* setup n.r */
	calasm	bldrsp,(rnr)	/* build the rsp message */
	bldmsg	rspmsg,gopunt	/* build the actual message */
	outscn	setf,gopunt	/* set f bit */
	clrlcf	flgwd2,snrnr	/* clear the flag */
	goto	wret
srej1	setchr	cfield,null	/* clear cfield */
	calsub	outseq	/* set up n.r */
	calasm	bldrsp,(rej)	/* build response field */
	bldmsg	rspmsg,gopunt	/* build the message */
	outscn	setf,gopunt	/* set f bit */
	clrlcf	flgwd2,snrej	/* reset the send reject flag */
	goto	wret	/* write it and return */
sif1	tstlcl	pstate,lkprrb,ifrett /* no write right now */
	tstlcl	pstate,lkprsr,ifrett
	tstlcl	pstate,lkupfr,ifrett
	tstlcl	pstate,lkuprs,ifrett
	tstlcl	sstate,lksccs,ifrett /* no need to confuse the reciver */
	tstlcf	flgwd3,mstifr,ifskov /* required to send I-frame */
	tstlcf	flgwd3,rtyhld,ifrett /* hold i-frames */
ifskov	clrlcf	flgwd3,mstifr	/* not required any more */
	calasm	gtntms	/* get next message on t.ocp */
	calasm	tstocp,(0,ifrett)
	goto	sif2
ifrett	clrlcf	flgwd2,snifr
	goto	outlst	/* continue on for other output */
sif2	setlcl	cfield,null	/* clear cfield */
	calasm	bldcfd	/* build cfield */
	outscn	setac,gopunt	/* finish control fields */
	setlcf	flgwd1,ifrsnd	/* set this for later processing */
	clrlcf	flgwd2,snrr	/* no rr needed I-frame will do */
	goto	wret	/* output it now */
srr1	setchr	cfield,null	/* clear cfield */
	calsub	outseq	/* set up n.r */
	calasm	bldrsp,(rr)	/* build the response field */
	bldmsg	rspmsg,gopunt	/* build the output message */
	outscn	setf,gopunt	/* set finial bit in message */
	clrlcf	flgwd2,snrr	/* clear the flag */
	goto	wret	/* write it and return *?
sprnr1	setchr	cfield,null	/* set c field to null for building */
	calsub	outseq	/* get n.r */
	calasm	bldrsp,(rnr)	/* gset in the command */
	bldmsg	cmdmsg,gopunt
	outscn	setp,gopunt
	clrlcf	flgwd2,snprnr
	goto	wret
sprej1	setchr	cfield,null	/* clear cfield */
	calsub	outseq	/* get n.r :/
	calasm	bldrsp,(rej)
	bldmsg	cmdmsg,gopunt	/* build the command msg */
	outscn	setp,gopunt
	clrlcf	flgwd2,snprej
	goto	wret
sprr1	setchr	cfield,null	/* clear cfiedl :/
	calsub	outseq	/* get n.r */
	calasm	bldrsp,(rr)	/* build rr control */
	bldmsg	cmdmsg,gopunt
	outscn	setp,gopunt
	clrlcf	flgwd2,snprr
	goto	wret
flst	tstlcf	flgwd2,snsarm,fsout /* send a sarm */
	goto	fbout
fsout	bldmsg	srmmsg,gopunt	/* build a sarm message */
************************************************************
*
*	a condition - the only time a sarm is send prior
*	 a final frame, This is done to achive a link up condition
*	 in most cases it wouldn't haven.
*
************************************************************
	clrlcf	flgwd2,snsarm	/* clear the sarm flag */
fsabmc	outscn	setp,gopunt	/* set p bit */
	calsub	write	/* write the message */
	goto	retotl
fbout	tstlcf	flgwd2,snsabm,fbsout
	goto	fcout
fbsout	bldmsg	sbmmsg,gopunt
	clrlcf	flgwd2,snsabm
	goto	fsabmc
fcout	tstlcf	flgwd2,sncmdr,scout1 /* send a cmdr */
	tstlcf	flgwd2,snua,sua1 /* send ua */
	tstlcf	flgwd2,snrnr,srnr1  /* sned rnr */
	tstlcf	flgwd2,snrej,srej1  /* send a reject */
	goto	srr1	/* send rr like or not */
wret	calsub	write	/* write the message */
	tstlcf	flgwd1,fbit,cfbps /* clear fbit? */
	tstlcf	flgwd1,ifrsnd,write2
	goto	retotl
write2	tstlcf	flgwd1,timesw,write3 /* timer running */
	setlcf	flgwd1,timesw
	setimv	t1	/* set timer going */
write3	setlcv	amarg1,v.s	/* add mod 8 to v.s */
	setlcl	amarg2,1
	calasm	admod8
	setlcv	v.s,amarg2
	tstlcf	flgwd1,t1rec,write4 /* in timer recovery check xx */
	retsub
write4	tstlcv	xx,amarg1,write5
	retsub
write5	setlcv	xx,amarg2	/* set xx to next */
	retsub
cfbps	clrlcf	flgwd1,fbit	/* clear sending finial bit */
	setchr	fmask,null	/* clear mask also */
retotl	retsub
	rem
	rem
************************************************************
*
*	fbitck - if f bit on then reset the fbit flags
*
************************************************************
	rem
fbitck	tstlcl	pf,0,fbitc1	/* f bit on */
	clrlcf	flgwd1,fbit	/* clear the flags */
	clrlcf	flgwd1,pbit
	setchr	fmask,null	/* clear the maskes */
	setchr	pmask,null
	setlcl	pf,0	/* reset the pf flag */
fbitc1	retsub
	rem
	rem
************************************************************
*
*	sigotp - signal sndout if kv < kc else return
*
************************************************************
	rem
sigotp	tstlcv	kv,kc,sigret /* equal stop the HOST */
	tstlcf	flgwd1,oasw,sigctn /* needed sndout */
sigret	retsub
sigctn	signal	sndout
	clrlcf	flgwd1,oasw
	retsub
	rem
	rem
************************************************************
*
*	cshook - a hook for the send cmdr state into
*	 primary for responses
*
************************************************************
	rem
cshook	tstlcf	flgwd1,dcedte,frsrrq
	goto	sndcmd
	rem
	rem
************************************************************
*
*	ackmsg - acknowledge any I-frames. Delete all
*	 messages that have been ack. Reset kv as well
*
************************************************************
	rem
ackmsg	tstlcf	flgwd1,xmitsw,ackms1
	goto	ackms3
ackms1	tstlcf	flgwd2,snifr,ackms2
	goto	ackms3
ackms2	setlcv	nrv,n.r
	setlcf	flgwd1,ackrq
	retsub
ackms3	tstlcv	a.r,n.r,akmret	/* any to ack */
	calasm	tstocp,(0,ackstr)
	calasm	ocpset,(temclr)
ackstr	calasm	setocp,(bufadd)
acklop	calasm	tstocp,(uaoffs,ackclr)
	goto	ackst1	/* no - no clear */
ackclr	setlcl	uaoffs,0	/* clear it  next will off the top */
ackst1	dmpout		/* dump one message */
	addlcl	kv,-1	/* one less off the chain */
	setlcv	amarg1,a.r	/* set up the admod8 to add one to a.r */
	setlcl	amarg2,1
	calasm	admod8
	tstlcf	flgwd1,t1rec,ackms4 /* if t1 recovery test v.s */
	goto	ackms6	/* if equal, increment it with a.r */
ackms4	tstlcv	v.s,a.r,ackms5
	goto	ackms6
ackms5	setlcv	v.s,amarg2
ackms6	setlcv	a.r,amarg2
	tstlcv	a.r,n.r,ackpro	/* finish */
	goto	acklop	/* loop again not finish */
ackpro	calasm	ocpset,(bufadd)
	calasm	setocp,(temclr)
	setlcl	temclr,0	/* clear tempory */
	tstlcf	flgwd1,oprusw,akmret /* no scanup if output recieve on bufadd */
	calasm	scanup	/* any on unprocess chain */
	calsub	sigotp	/* tell HOST if output is ok */
akmret	retsub
	rem
	rem
************************************************************
*
*	clrrbb - clear a remote busy or reject mustsetup
*	 the next output buffer (set flgwd2,snifr) */
*
************************************************************
	rem
clrrbb	tstlcl	bufadd,0,clrret /* nothing to set up */
	setlcf	flgwd2,snifr	/* set  send i-frame */
clrret	retsub
	rem
	rem
************************************************************
*
*	rejrst - reject recieve must reset uaoffs
*
************************************************************
	rem
rejrst	setlcl	uaoffs,0	/* top is the next if any */
	tstlcl	bufadd,0,rejret	/* nothing to do */
	setlcf	flgwd2,snifr	/* set send I-frame */
rejret	retsub
	rem
	rem
************************************************************
*
*	outseq - put n(r) into the send frame 
*
************************************************************
	rem
outseq	setlcv	outn.r,v.r	/* get current V(R) */
	calasm	putn.r	/* put N(R) in control field */
	setlcv	a.s,outa.s	/* remember most recent ack sent */
	retsub
	rem
	rem
*****************************************************************
*
*	Subroutine to start transmission of the current output
*	message.
*
*****************************************************************
	rem
write	holdot		/* hold the output */
	meterm	frmxmt	/* meter this */
	setlcf	flgwd1,xmitsw	/* indicate xmit busy */
	dcwlst
	cmd	sxmit+rtroe
	output	(outmsg)
	cmd	rxmit+sterm
	retsub
	rem
	ttls	multiply and divide macros
mpy	macro
	mpf	#1
	lrl	1
	endm	mpy
	rem
	rem
dvd	macro
	qls	1
	dvf	#1
	endm	dvd
	ttls	assembler utility subroutines
************************************************************
*
*	dcdact - subroutine to decode the parameters from the
*	 activate control order.
*	 Control order format:
*
*	dcl 1 order_format aligned based (addr(stat0)),
*	    2 flags,
*	      3 dce_or_dte bit (1) unal, /* on = dce */
*	      3 lap_or_lapb bit (1) unal, /* on = lapb */
*	      3 disc_first bit (1) unal, /* on = disc sent right away */
*	      3 trace_off bit (1) unal, /* on = trace off upon crash */
*	      3 pad bit (5) unal, /* padding */
*	    2 activation_order bit (9) unal init ("001"b), /* constant */
*	    2 frame_size fixed bin (17) unal, /* max frame size */
*	    2 k fixed bin (8) unal, /* max unack frames */
*	    2 N2 uns fixed bin (9) unal, /* number of retries */
*	    2 T1 uns fixed bin (9) unal, /* retry time in tents of seconds */
*	    2 T3 uns fixed bin (9) unal; /* init timer */
*
*	called with address of opblock to return to if
*	 the control order is not activate
*
************************************************************
	rem
dcdact	subr	dcd,(x3)
	stx3	t.a000-*	/*save off the parameter */
*
*	check for activate 
*
	ldx3	l.a000-*	/* =stat0 getr address */
	tsy	a.a000-*,* /* = cvaddr in x3 */
	lda	0,3	/* got order word */
	sta	t.a001-*	/* save it */
	ana	l.a001-*	/* =ordmsk mask all but order */
	cmpa	l.a002-*	/* =lctact corrent one */
	tze	dcd010-*	/* yes go on */
*
*	unwanted order, return as requested
*
	ldx3	t.a000-*	/* get address of parm block */
	ldx2	0,3	/* return is now in place */
	tra	dcdret-*	/* get out */
*
*	set flags and control address 
*
dcd010	ldx3	l.a003-*	/* =flgwd1
	tsy	a.a000-*,* /* cvaddr */
	stz	0,3	/* clear the field */
	lda	t.a001-*	/* get back stat0 */
	ilq	0
	ars	12	/* clear the order :/
	icana	=4	/* trace off on crash */
	tze	dcd015-*
	iaq	=8
dcd015	icana	=8	/* is disc on */
	tze	dcd020-*	/* no skip it */
	iaq	=4
dcd020	icana	=16	/* is lapb on */
	tze	dcd030-*	/* no */
	iaq	=1
dcd030	icana	=32	/* is dce on */
	tze	dcd040-*	/* no */
	iaq	=2	/* set up last flags */
	cqa		/* place it into a */
	orsa	0,3	/* or it in */
	lda	l.a004-*	/* =locadr */
	tsy	a.a001-*,* /* adbyte */
	nop
	ila	dceadr	/* dec address */
	sta	0,3,b.0	/*store it */
	lda	l.a005-*	/* =remadr */
	tra	dcd050-*	/* common area */
	rem
dcd040	cqa		/* set flgwd1 flags */
	orsa	0,3	/* store them */
	lda	l.a005-*	/* remadr */
	tsy	a.a001-*,*	 /* adbyte */
	nop
	ila	dceadr
	sta	0,3,b.0
	lda	l.a004-*	/*locadr */
	rem
dcd050	tsy	a.a001-*,* /* =adbyte */
	nop
	ila	dteadr
	sta	0,3,b.0	/* flags bit are done */
*
*	now do the stat1 frame size (n1)
*
	ldx3	l.a006-*	/* stat1 */
	tsy	a.a000-*,* /* =cvaddr */
	lda	0,3	/* get stat1 contents */
	iaa	7	/* round upward */
	ars	3	/* convert to bytes */
	caq		/* get it to q */
	ldx3	l.a007-*	/* =mxfrsz max frame size */
	tsy	a.a000-*,* /* cvaddr */
	stq	0,3	/* save q for max size */
*
*	now do stat2 lower (k) window size
*
	ldx3	l.a008-*	/* =stat2 */
	tsy	a.a000-*,* /* cvaddr */
	lda	0,3	/* get the contance of stat2 */
	sta	t.a002-*	/* saft temp storage */
	ldx3	l.a009-*	/* =kc unack number of frames */
	tsy	a.a000-*,* /* cvaddr :/
	lda	t.a002-*	/* retrieve stat2 */
	ars	9	/* get only k value */
	sta	0,3	/* put it in place */
*
*	upper of stat2 (n2)
*
	ldx3	l.a010-*	/* =n2*/
	tsy	a.a000-*,* /* cvaddr */
	lda	t.a002-*	/* temp storage */
	ana	l.a011-*	/* =o000777 */
	sta	0,3
*
*	stat3 lower  (t1)
*
	ldx3	l.a012-*	/* =stat3 */
	tsy	a.a000-*,* /* cvaddr */
	ldx2	0,3	/* got contants of stat3 */
	stx2	t.a003-*	/* save tempary */
	ldx3	l.a013-*	/* =t1 */
	tsy	a.a000-*,* /* cvaddr */
	cx2a		/* get back stat3*/
	arl	9	/* shift out bad bits */
	mpy	l.a014-*	/* convert tenths to negative milliseconds */
	stq	0,3	/* pu it in place */
*
*	now t3 in stat3
*
	ldx3	l.a015-*	/* =t3 */
	tsy	a.a000-*,* /* cvaddr */
	lda	t.a003-*	/* get back stat3 */
	ana	l.a011-*	/* =o000777 */
	sta	0,3	/* save t3 */
*
*	all done, set up normal return
*
	ila	0
	cax2
dcdret	return	dcdact
	rem
a.a000	ind	cvaddr
a.a001	ind	adbyte
	rem
l.a000	vfd	18/stat0
l.a001	vfd	18/ordmsk
l.a002	vfd	18/lctact
l.a003	vfd	18/flgwd1
l.a004	vfd	18/locadr
l.a005	vfd	18/remadr
l.a006	vfd	18/stat1
l.a007	vfd	18/mxfrsz
l.a008	vfd	18/stat2
l.a009	vfd	18/kc
l.a010	vfd	18/n2
l.a011	oct	000777
l.a012	vfd	18/stat3
l.a013	vfd	18/t1
l.a014	dec	-100
l.a015	vfd	18/t3
	rem
t.a000	bss	1	/* temp for parameters */
t.a001	bss	1	/* stat0 tempory */
t.a002	bss	1	/* stat2 tempory */
t.a003	bss	1	/* stat3 tempory */
	rem
********************************************************************************
*
*	cfgpcw - set configuration pcw
*
*	Turns off unwanted bits in the configuration pcw.
*
**********************************************************************************
	rem
cfgpcw	subr	cfp,(x3)
	rem
	lda	l.b000-*  (=tfkpar) get keep parity bit
	orsa	t.flg3,1  turn it on in the tib
	rem
	ldx3	t.sfcm,1  get addr of sfcm
	lda	l.b001-*  (=777704) get mask for word 1 of pcw
	ansa	sf.cfg,3  leave only wanted bits on in word 1 of pcw
	stz	sf.cfg+1,3	zero word 2 of pcw
	rem
	return	cfgpcw
l.b000	vfd	18/tfkpar
l.b001	oct	777704
	rem
	rem
************************************************************
*
*	valfrm - validate input frame - check for bad address,
*	 test for proper length, test for known commands,set
*	 calues - lastf and frmadr-, check for pand f bits
*	 for propper conditions, also test n(s) and n(r) in
*	 all messages
*
*	no arguments  (nornal usages a = controlfield q = function
*
************************************************************
	rem
valfrm	subr	vfm,(x1)
	stz	cmdrln-*		"zero length problem
	stz	a.c000-*,* /* =pf clear finial test data */
	lda	t.icp,1	/* get input buffer */
	tze	vfmree-*	/* nothing to do */
	tsy	a.c001-*,* /* =setbpt 18 - 15 bit address */
	cax2
	tsy	a.c002-*,* /* =gtbfsz get buffer data size */
	lda	a.c003-*,* /* = vfmsiz load a with size */
	icmpa	2	/* at least two bytes */
	tmi	vfmree-*	/* no not enought */
	iacx2	bf.dta	/* get data address */
	lda	0,2	/* get address fields */
	arl	9	/* clear all other fields */
	icmpa	1	/* dte pri */
	tze	vfm000-*	/* good */
	icmpa	3	/* dce pri */
	tnz	vfmree-*	/* bad address */
vfm000	sta	q.save-*	/* save foeld tempory */
	lda	l.c000-*	/* =frmadr */
	tsy	a.c004-*,* /* =adbyte */
	oct	0	/* die on this error */
	ldq	q.save-*	/* bet back address fields */
	stq	0,3,b.0	/* store it in t.elnk */
	lda	0,2	/* get control field now */
	als	9	/* get rid of address fields */
	arl	9	/* control field is only thing left */
	icana	=o1	/* is it an i-frame */
	tze	iframp-*	/* yes */
	caq		/* save it in q */
	arl	1	/* sift 1 */
	iana	7	/* mask out other bits */
	cax3		/* save in x3 */
	cqa
	tra	a.c010-*,* /* find what connamd it is */
vfm020	tra	rrp-*	/* 000 rr frame */
	tra	dsuap-*	/* 001 either disc, ua, or bad frame */
	tra	rnrp-*	/* 010 rnr frame */
	tra	cmdrp-*	/* 011 cmdr or bad frame */
	tra	rejp-*	/* 100 rej frame */
	tra	bdcrp-*	/* 101 bad command */
	tra	bdcrp-*	/* 110 bad command */
	tra	sbrdmp-*	/* 111 dm, sarm, sabm, or bad command *]/
bdcrp	ilq	rvbdcr	/* set function to bad command */
	tra	vfmret-*	/* return */
cmdrp	ilq	rvcmdr	/* cmdr processing */
	icana	=o340	/* first is it cmdr */
	tze	bdcrp-*	/* no it isn't */
	icana	=o140
	tze	2	/* it is cmdr now */
	tra	bdcrp-*
	lda	1,2	"get cmdr cmd field
	ars	9	"get field in position
	icana	=o1	"is it and I-frame
	tnz	cmdrpc-*	"no
	lda	2,2	"get cmdr flags fields
	ars	9	"get field in to position
	icana	=o4	"is Y bit set
	tze	cmdrpc-*	"no
	aos	cmdrln-*	"indicate a problem
	ldx3	l.c003-*	"=stat1
	tsy	a.c009-*,* "cvaddr
	lda	1,2	"reject byte and state var
	sta	0,3	"stat1 field
	lda	2,2	"flags and zeros
	sta	1,3	"stat2
	stz	2,3	"stat3
cmdrpc	lda	a.c003-*,* /* gtbfsz */
	icmpa	5	/* check for proprer frame size */
	tze	vfm030-*	/* good length */
	aos	a.c005-*,* /* bdlgsz */
	tra	bdcrp-*
vfm030	null
rspfck	tsy	checkr-*	/* check for response address */
	tra	vfmret-*	/* no respose */
	tsy	checkf-*	/* check f bit */
	tra	vfmret-*
	tra	vfmret-*	/* done */
uap	ilq	rvua	/* function ua */
	lda	a.c003-*,* /*gtbfsz message size */
	icmpa	2	/* only two bytes */
	tze	rspfck-*
	aos	a.c005-*,*
	tra	bdcrp-*
discp	ilq	rvdisc	/* function disc */
	lda	a.c003-*,* /* vfmsiz */
	icmpa	2	/* two bytes */
	tze	vfm040-*
	aos	a.c005-*,*
	tra	bdcrp-*
vfm040	tsy	checkc-*	/* check for command */
	tra	vfmret-*
	tsy	checkp-*	/* check p bit */
	nop
	tra	vfmret-*
sarmp	ilq	rvsarm	/* function sarm */
	lda	a.c003-*,* /* message size vfmsiz */
	icmpa	2	/* only two bytes */
	tze	vfm050-*
	aos	a.c005-*,*
	tra	bdcrp-*
vfm050	tsy	checkc-*	/* check for command */
	tra	dmp-*	/* response then it a dm on lapb */
	tsy	checkp-*	/* check p bit */
	tra	vfmret-*
	tra	vfmret-*
rrp	ilq	rvrr	/* function  rr */
	ila	rvprr	/* may be p rr */
rpros	sta	polcmd-*
	tsy	checkr-*	/* check for response */
	tra	prespc-*	/* polled command */
	tsy	checkf-*	/* f bit processing */
	tra	vfmret-*
rpcomp	tsy	a.c006-*,* /* chknr */
	tra	vfmret-*
	lda	a.c003-*,* /* vfmsiz */
	icmpa	2	/* two bytes only */
	tze	vfmret-*
	aos	a.c005-*,* /* bad length */
	tra	bdcrp-*
rnrp	ilq	rvrnr	/* rnr = function */
	ila	rvprnr
	tra	rpros-*
rejp	ilq	rvrej	/* rej = function */
	ila	rvprej
	tra	rpros-*
prespc	tsy	checkp-*	/* check for polled bit */
	tra	bdcrp-*
	ldq	polcmd-*	/* set function to poll command function */
	tra	rpcomp-*
iframp	ilq	rvifrm	/* i-frame processing */
	tsy	checkc-*
	tra	vfmret-*
	tsy	checkp-*
	nop
	tsy	a.c007-*,* /* checnr */
	tra	vfmret-*
	tsy	a.c008-*,* /* checnr */
	tra	vfmret-*
	ldq	a.c003-*,* /* vfmsiz */
	ldx3	l.c002-*	/* mxfrsz */
	tsy	a.c009-*,* /* cvaddr */
	cmpq	0,3	/* compare to max size */
	tze	vfm055-*	/* equal is allright */
	tpl	vfmbif-*
vfm055	ilq	rvifrm
	tra	vfmret-*
vfmbif	aos	a.c005-*,* /* bad info length */
	tra	bdcrp-*
dsuap	icana	=o200	/* any 1xx */
	tnz	bdcrp-*	/* yes bad command */
	icana	=o340	/*  any 000 */
	tze	bdcrp-*	/* yes it is also bad */
	icana	=o240
	tze	discp-*	/* disc command */
	icana	=o300     /* misc bit check */
	tze	bdcrp-*   /* bad command */
	tra	uap-*	/* ua command */
sbrdmp	icana	=o340
	tze	sarmp-*	/* sarm command */
	icana	=o300
	tnz	bdcrp-* /* not 001 */
	ilq	rvsabm	/* sabm function */
	lda	a.c003-*,* /* vfmsiz */
	icmpa	2	/* two bytes */
	tze	vfm070-*
	aos	a.c005-*,* /* bad message length */
	tra	bdcrp-*
vfm070	tsy	checkc-*
	tra	vfmret-*
	tsy	checkp-*
	tra	vfmret-*
	tra	vfmret-*
dmp	ilq	rvdm	/* dm recieve */
	tra	vfmret-*
vfmree	ilq	rvbdad	/* function of nothing */
vfmret	ila	0	/* set to return by clearing x2 */
	cax2
	ldx3	l.c001-*	/* lastf */
	tsy	a.c009-*,* /* cvaddr */
	stq	0,3
	return	valfrm
	rem
	rem
q.save	bss	1
polcmd	bss	1
cmdrln	bss	1
	rem
a.c000	ind	pf
a.c001	ind	setbpt
a.c002	ind	gtbfsz
a.c003	ind	vfmsiz
a.c004	ind	adbyte
a.c005	ind	bdlgsz
a.c006	ind	chknr
a.c007	ind	checnr
a.c008	ind	checns
a.c009	ind	cvaddr
a.c010	ind	vfm020,3
	rem
l.c000	vfd	18/frmadr
l.c001	vfd	18/lastf
l.c002	vfd	18/mxfrsz
l.c003	vfd	18/stat1
	rem
	rem
************************************************************
*
*	checkr - check response to address
*
************************************************************
	rem
checkr	subr	ckr,(a,q,x2,x3)
	lda	0,2	/* get control address again */
	arl	9	/* only address is needed */
	cax2
	lda	l.d001-*	/* remadr */
	tsy	a.d000-*,* /* adbyte */
	oct	0
	cmpx2	0,3,b.0	/* compare address */
	tnz	ckrree-*	/* no compare */
	aos	checkr-*
	tra	ckrret-*
ckrree	ilq	rvbdcr	/* bad command */
	stq	ckrsq-*
ckrret	return	checkr
	rem
	rem
************************************************************
*
*	checkc - check for command address
*
************************************************************
	rem
checkc	subr	chc,(a,q,x2,x3)
	lda	0,2	/* get address byte */
	arl	9	/* only address is needed */
	cax2
	lda	l.d002-*	/* locadr */
	tsy	a.d000-*,* /* adbyte */
	oct	0
	cmpx2	0,3,b.0	/* are they equal */
	tnz	ckcree-*
	aos	checkc-*
	tra	ckcret-*
ckcree	ilq	rvbdcr	/* bad command */
	stq	chcsq-*
ckcret	return	checkc
	rem
l.d001	vfd	18/remadr
l.d002	vfd	18/locadr
a.d000	ind	adbyte
	rem
	rem
************************************************************
*
*	checkf - check f bit for validate response frames
*
************************************************************
	rem
checkf	subr	chf,(a,q,x3)
	lda	0,2	/* get back controls fields */
	als	9	/* only control bit needed */
	arl	9
	sta	chfsa-*
	stz	pf-*
	ana	l.e000-*	/*fbit position */
	sta	fchtmp-*	/* save it tempory */
	lda	l.e001-*	/* pbit pmask */
	tsy	a.e000-*,* /* adbyte */
	oct	0
	lda	fchtmp-*	/* get orgin value back */
	cmpa	0,3,b.0	/* compare if f bit is on */
	tnz	chf010-*	/* not equal */
	aos	checkf-*	/* normal return */
	szn	fchtmp-*	/* is it zero */
	tze	chfret-*	/* yes it is */
	aos	pf-*
chfret	return	checkf
chf010	ilq	rvbdfb	/* it a bad command */
	stq	chfsq-*	/* save for q reg restore */
	tra	chfret-*
	rem
pf	bss	1
	rem
	rem
************************************************************
*
*	checkp - check poll bit if on set needed fbit
*
************************************************************
	rem
checkp	subr	chp,(a,q,x3)
	lda	0,2	/* get back controls fields */
	als	9	/* only control bits needed */
	arl	9
	sta	chpsa-*
	cana	l.e000-*	/* pfon */
	tze	chpret-*	/* nothing */
	aos	checkp-*	/* normal return */
	lda	l.e003-*	/* fmask */
	tsy	a.e000-*,* /* adbyte */
	oct	0
	lda	l.e000-*	/* pfon */
	orsa	0,3,b.0	/* or the bit in */
	ldx3	l.e004-*	/* flgwd1 */
	tsy	a.e001-*,* /* cvaddr */
	lda	l.e005-*	/* fbit */
	orsa	0,3
chpret	return	checkp
	rem
a.e000	ind	adbyte
a.e001	ind	cvaddr
	rem
l.e000	vfd	18/pfon
l.e001	vfd	18/pmask
*l.e002	unused
l.e003	vfd	18/fmask
l.e004	vfd	18/flgwd1
l.e005	vfd	18/fbit
	rem
fchtmp	bss	1
	rem
	rem
************************************************************
*
*	chknr - check nr for response frames, if out of
*	 range then it  is a error, else normal return
*
************************************************************
	rem
chknr	subr	chk,(a,x3)
	stz	bnr-*
	ana	l.f006-*	/* o=340 n.r mask */
	arl	5	/* shift it to proper place */
	sta	middle-*	/*let hope it is the middle */
	sta	n.r-*	/* storage for later uses */
	ldx3	l.f000-*	/* a.r */
	tsy	a.f000-*,* /* cvaddr */
	lda	0,3	/*get a.r */
	sta	low-*
	ldx3	l.f001-*	/* flgwd1 */
	tsy	a.f000-*,* /* cvaddr */
	lda	0,3
	ana	l.f002-*	/* mask all but t1rec */
	tze	chk010-*
	ldx3	l.f003-*	/* xx */
	tsy	a.f000-*,* /* cvaddr */
	tra	chk020-*
chk010	ldx3	l.f004-*	/* v.s */
	tsy	a.f000-*,* /* cvaddr */
chk020	lda	0,3
	sta	high-*
	tsy	chkrng-*
	szn	badrng-*
	tze	chk030-*
	ilq	rvbdcr	/* bad command +?
	aos	bnr-*
	tra	chkret-*
chk030	aos	chknr-*
chkret	return	chknr
	rem
n.r	bss	1
bnr	bss	1
	rem
	rem
************************************************************
*
*	checnr - check nr on i-frames
*
************************************************************
	rem
checnr	subr	chr,(a,x3)
	tsy	chknr-*	/* he'll do the work */
	tra	chr010-*
	tra	chr020-*
chr010	ilq	rvbdir	/* bad N(r) I-frame  */
	tra	chrret-*
chr020	aos	checnr-*
chrret	return	checnr
	rem
	rem
************************************************************
*
*	checns - check n.s on i-frames
*
************************************************************
	rem
checns	subr	chs,(a,x3)
	iana	=o16	/* mask all but n.s */
	arl	1	/* shift by one */
	cax2	
	ldx3	l.f005-*	/* v.r */
	tsy	a.f000-*,* /* cvaddr */
	cmpx2	0,3	/* must be equal */
	tze	chs010-*
	ilq	rvbdis	/* bad i-frame n.s */
	tra	chsret-*
chs010	aos	checns-*
chsret	return	checns
	rem
a.f000	ind	cvaddr
	rem
l.f000	vfd	18/a.r
l.f001	vfd	18/flgwd1
l.f002	vfd	18/t1rec
l.f003	vfd	18/xx
l.f004	vfd	18/v.s
l.f005	vfd	18/v.r
l.f006	oct	000340
	rem
	rem
************************************************************
*
*	chkrng - check range to check if midle is middle
*	 on mod 8 arith.
*
************************************************************
	rem
chkrng	subr	ckg
	lda	high-*	/* get upper bound */
	cmpa	low-*	/* hi < low */
	tpl	ckg010-*	/*no */
	ila	8	/* get modulus */
	asa	high-*	/* advance upper bound */
	lda	middle-*	/* get middle */
	cmpa	low-*	/* middle < low */
	tpl	ckg010-*	/* no */
	ila	8	/* get modulus */
	asa	middle-*	advance middle
	rem
ckg010	ila	1
	sta	badrng-*	assume out of range */
	lda	middle-*	/* get middl */
	cmpa	low-*	/* less than lower bound */
	tmi	ckgret-*	/* yes it is bad */
	lda	high-*	/* get upper bound */
	cmpa	middle-*	/* less than middle */
	tmi	ckgret-*	/* yes error */
	rem
	stz	badrng-*
ckgret	return	chkrng
	rem
high	bss	1
low	bss	1
middle	bss	1
badrng	bss	1
	rem
	rem
************************************************************
*
*	blfcdr - build command reject fields
*
************************************************************
	rem
blfcdr	subr	blc
	lda	t.icp,1	/* get pointer  to input message */
	tsy	a.g000-*,* /* setbpe */
	iaa	bf.dta	/* get buffer data offset */
	cax2
	ldq	0,2	get control field */
	qls	9	/* clean it up to have only control */
	qrl	9
	stq	qrsave-*	/* save it tempory */
	lda	l.g000-*	/* cmdr1 */
	tsy	a.g001-*,* /* adbyte */
	oct	0
	lda	0,3,b.0	/* get it info */
	tnz	blcret-*	/* sonething is already there */
	ldq	qrsave-*
	stq	0,3,b.0	/* put it in place */
	ldx3	l.g003-*	/* v.r */
	tsy	a.g002-*,* /* cvaddr */
	lda	0,3
	als	6	/* place in proper location */
	sta	qrsave-*
	lda	l.g001-*	/* cmdr2 */
	tsy	a.g001-*,* /* adbyte */
	oct	0
	ldq	qrsave-*
	stq	0,3,b.0
	szn	a.g003-*,* /* dblgsz */
	tze	blc010-*
	ilq	3	/*set w and x */
	lda	0,2
	icana	=01
	tze	2
	tra	blc020-*
	ilq	5	/* set w and y */
	tra	blc020-*
blc010	szn	bnr-*
	tze	blc015-*
	ilq	=o10
	tra	blc020-*
blc015	ilq	1	/* just w */
blc020	stq	qrsave-*
	lda	l.g002-*	/* cmdr3 */
	tsy	a.g001-*,* /* adbyte */
	oct	0
	ldq	qrsave-*
	stq	0,3,b.0
blcret	ila	0
	stz	bnr-*
	cax2
	return	blfcdr
	rem
a.g000	ind	setbpt
a.g001	ind	adbyte
a.g002	ind	cvaddr
a.g003	ind	bdlgsz
	rem
l.g000	vfd	18/cmdrb1
l.g001	vfd	18/cmdrb2
l.g002	vfd	18/cmdrb3
l.g003	vfd	18/v.r
l.g004	vfd	18/v.s
	rem
	rem
************************************************************
*
*	ldnsdr - load ns into frmr for lapb reject
*
************************************************************
	rem
ldnsdr	subr	ldn,(x3)
	ldx3	l.g004-*	/*v.s */
	tsy	a.g002-*,* /* cvaddr */
	lda	0,3
	als	1
	sta	qrsave-*
	lda	l.g001-*	/* cmdrb2 */
	tsy	a.g001-*,* /* adbyte */
	oct	0
	lda	0,3,b.0
	ora	qrsave-*
	sta	0,3,b.0
	ila	0
	cax2
	return	ldnsdr
qrsave	bss	1
	rem
	rem
************************************************************
*
*	ckrnr - check rnr needed
*
*	determines whether a rnr response is appropriate due to
*	either of the following conditions:
*
*	1.  the total number of free buffers is less that the
*	sum of the reserved buffer count plus twice the channel
*	buffer size.
*
*	2.  two or more frames belonging to this channel are already
*	queued for dia transfer.
*
************************************************************
	rem
ckrnr	subr	rnr,(x3)
	tsy	cntqf-*	/* count queued frames */
	lda	cqfcnt-*	/*get count */
	cmpa	l.h001-*	/* =dialim over limit */
	tpl	rnr030-*	/*yes, rnr required */
	rem
	stz	rnrflg-*
	tra	rnrret-*
	rem
rnr030	ila	1
	sta	rnrflg-*	/* indicate rnr required */
	rem
rnrret	return	ckrnr
	rem
rnrflg	bss	1
a.h000	ind	setbpt
	rem
l.h000	vfd	18/bffbrk
l.h001	vfd	18/dialim
	rem
	rem
************************************************************
*
*	cntqf - count queued frames
*
*	a subroutine to count the number of frames on the dia
*	queue. (count only the i-frames)
*
************************************************************
	rem
cntqf	subr	cqf,(x3)
	stz	cqfcnt-*	/* start count at zero */
	lda	t.dcp,1	/* get start of dia queue */
	tze	cqf030-*	/* end of queue */
cqf010	tsy	a.h000-*,* /* setbpe */
	cax3
	lda	bf.flg,3	/* look at buffer flags */
	cana	l.h000-*	/* =bffbrk */
	tze	cqf020-*
	aos	cqfcnt-*	/* yes, count another frame */
cqf020	lda	bf.nxt,3	/* follow the chain */
	tnz	cqf010-*	/* if not the end */
cqf030	return	cntqf
	rem
cqfcnt	bss	1
	rem
	rem
************************************************************
*
*	admod8 - add modulo 8
*
************************************************************
	rem
admod8	subr	am8
	lda	amarg1-*	/* get arg 1 */
	asa	amarg2-*	/* add to arg 2 */
	lda	l.i000-*	/* =o000007 get mod 8 mask */
	ansa	amarg2-*	/* convert arg 2 to mod 8 */
	rem
	return	admod8
	rem
amarg1	bss	1
amarg2	bss	1
l.i000	oct	000007
	rem
	rem
************************************************************
*
*	setbrk - set break flag in last buffer
*
************************************************************
	rem
setbrk	subr	sbk,(x3)
	lda	t.icp,1	/* get buffer address */
sbk010	tsy	a.j000-*,* /* convert address to 15 bits */
	cax3		/* place address in index reg */
	szn	bf.nxt,3	/* is next zero */
	tze	sbk020-*	/* yes location found */
	lda	bf.nxt,3	/* get ready for follow the chain */
	tra	sbk010-*	/* follow it */
sbk020	lda	l.j000-*	/* bffbrk flag */
	orsa	bf.flg,3	/* set it on */
	return	setbrk
	rem
	rem
************************************************************
*
*	gtbfsz- get buffer size. add all the buffers
*	 in the input chain and place it in vfmsiz
*
************************************************************
	rem
gtbfsz	subr	gtb,(x3)
	stz	vfmsiz-*	/* clear tally  */
	stz	bdlgsz-*	/* clear check */
	lda	t.icp,1	/* get input buffer */
gtb010	tsy	a.j000-*,* /* setbpt */
	cax3
	lda	bf.tly,3	/* get the tally */
	ana	l.j002-*	/* bfmsk tally mask */
	asa	vfmsiz-*	/* add to storage */
	szn	bf.nxt,3	/* is next zero */
	tze	gtb020-*	/* yes finish */
	lda	bf.nxt,3	/* get next buffer */
	tra	gtb010-*	/* loop again */
gtb020	lda	t.icp,1	/* get back  to orginal */
	tsy	a.j000-*,* /* setbpt */
	return	gtbfsz
	rem
a.j000	ind	setbpt
	rem
l.j000	vfd	18/bffbrk
l.j001	vfd	18/bfflst
l.j002	vfd	18/buftmk
	rem
vfmsiz	bss	1
bdlgsz	bss	1
	rem
	rem
************************************************************
*
*	addbte - add buffer to end of output chain
*
************************************************************
	rem
addbte	subr	adb,(x3)
	ldx3	l.k000-*	/* buffadd */
	tsy	a.k000-*,* /* cvaddr */
	lda	0,3	/* get buffer into regs */
	tnz	adb010-*	/* no more searching */
	lda	temups-*	/* get new buffer chain */
	sta	0,3	/* place it at the head */
	tra	adbret-*	/* that is all */
adb010	tsy	a.k001-*,* /* convert 18 to 15 setbpt */
	cax3
	lda	bf.nxt,3	/* get next buffer */
	tze	adb020-*	/* no more add it here */
	tra	adb010-*	/* loop for end */
adb020	lda	temups-*	/* get new chain */
	sta	bf.nxt,3	/* put in proper place */
adbret	return	addbte
	rem
	rem
************************************************************
*	bldrsp- build response command in cfield
*
************************************************************
	rem
bldrsp	subr	brp,(x3)
	lda	l.k001-*	/* cfield */
	tsy	a.k002-*,* /* adbyte */
	oct	0
	ldx2	brpsx3-*	/* get type of message address */
	lda	0,2	/* get response bits */
	orsa	0,3,b.0	/* or it into cfield */
	ila	0
	cax2
	return	bldrsp
	rem
a.k000	ind	cvaddr
a.k001	ind	setbpt
a.k002	ind	adbyte
	rem
l.k000	vfd	18/bufadd
l.k001	vfd	18/cfield
l.k002	vfd	18/kv
	rem
	rem
************************************************************
*
*	gtntms - get next message to send
*
************************************************************
	rem
gtntms	subr	gtn,(x3)
	ldx3	l.l000-*	/* uaoffs */
	tsy	a.l000-*,* /* cvaddr */
	cx3a
	cax2
	lda	0,3	/* get it buffer pointer address */
	tnz	gtn010-*	/* must loop down to end of message */
	ldx3	l.l001-*	/* bufadd */
	tsy	a.l000-*,* /* cvaddr */
	lda	0,3	/* get top message */
	sta	0,2	/* place it on uaoffs */
	tra	gtnret-*	/* common return */
gtn010	tsy	a.l001-*,* /* setbpt */
	cax3
	lda	bf.flg,3	/* get buffer flags */
	ana	l.l002-*	/* bfflst */
	tnz	gtn020-*	/* finish this is next */
	lda	bf.nxt,3	/* get next message chain pointer */
	tze	gtnret-*	/* finish no more don`'t set uaoffs */
	tra	gtn010-*	/* loop again */
gtn020	lda	bf.nxt,3	/* get next buffer */
	tze	gtnret-*	/* nothing there don't set uaoffs */
	sta	0,2	/* set uaoffs to head of message chain */
gtnret	sta	t.ocp,1	/*  store next in output */
	stz	t.ocur,1
	stz	t.olst,1
	ila	0
	cax2
	return	gtntms
	rem
	rem
************************************************************
*
*	bldcfd - build command field for this i-frame
*
************************************************************
	rem
bldcfd	subr	bcd,(x3)
	lda	l.l003-*	/* cfield */
	tsy	a.l002-*,* /* adbyte */
	oct	0
	stz	0,3,b.0	/* clear cfield */
	cx3a
	cax2
	ldx3	l.l004-*	/* v.s */
	tsy	a.l000-*,* /* cvaddr */
	lda	0,3	/* v.s in a +?
	als	1	/* shift v.s to proper spot */
	sta	0,2,b.0	/* store it in cfield */
	ldx3	l.l005-*	/* v.r */
	tsy	a.l000-*,* /* cvaddr */
	lda	0,3
	sta	outn.r-*
	tsy	putn.r-*
	ldx2	outa.s-*	/* also remiber last ack */
	ldx3	l.l012-*	/* a.s */
	tsy	a.l000-*,* /* cvaddr */
	stx2	0,3
	ila	0
	cax2
	return	bldcfd
	rem
	rem
************************************************************
*
*	putn.r - put n(r) in to cfield 
*
*	 a subroutine to put the current n(r) value in the control
*	field of the next output frame.
*
************************************************************
	rem
putn.r	subr	pnr,(q,x3)
	lda	outn.r-*	get n.r */
	ana	l.l006-*	/* 000007 */
	sta	outa.s-*	/* save for caller */
	als	5	/* shift into proper byte position +?
	sta	pnrtmp-*	/* save it in temp */
	lda	l.l003-*	/* cfield */
	tsy	a.l002-*,* /* adbyte */
	oct	0
	lda	0,3,b.0	/* get value of cfield */
	ora	pnrtmp-*	/* drop in n.r */
	sta	0,3,b.0	/* update cfield */
	return	putn.r	/* that is all folks */
	rem
outn.r	bss	1
outa.s	bss	1
pnrtmp	bss	1
	rem
a.l000	ind	cvaddr
a.l001	ind	setbpt
a.l002	ind	adbyte
	rem
l.l000	vfd	18/uaoffs
l.l001	vfd	18/bufadd
l.l002	vfd	18/bfflst
l.l003	vfd	18/cfield
l.l004	vfd	18/v.s
l.l005	vfd	18/v.r
l.l006	oct	000007
l.l007	vfd	18/stat2
l.l008	oct	000777
l.l009	vfd	18/lkupws
l.l010	vfd	18/stat3
l.l011	vfd	18/pstate
l.l012	vfd	18/a.s
	rem
	rem
************************************************************
*
*	setust - set up link down status of word stat2 and
*	 stat3
*
************************************************************
	rem
setust	subr	sut,(x3)
	ldx3	l.l007-*	/* stat2 */
	tsy	a.l000-*,* /* cvaddr */
	lda	l.l008-*	/* o000777 */
	ansa	0,3	/* mask out upper half */
	cx3a
	cax2
	ldx3	l.l009-*	/* lkupws */
	tsy	a.l000-*,* /* cvaddr */
	lda	0,3	/* get data */
	als	9	/* place is upper position */
	orsa	0,2	/* store it */
	ldx3	l.l010-*	/* stat3 */
	tsy	a.l000-*,* /* cvaddr */
	lda	l.l008-*	/* o000777 */
	ansa	0,3
	cx3a
	cax2
	ldx3	l.l011-*	/* pstate */
	tsy	a.l000-*,* /* cvaddr */
	lda	0,3
	als	9
	orsa	0,2
	ila	0
	cax2
	return	setust
	rem
	rem
************************************************************
*
*	scpbst - scan process chain for unprocess messages
*	 and break chain on set address in temups
*
************************************************************
	rem
scpbst	subr	scp,(x3)
	ldx3	l.n000-*	/* =bufadd
	tsy	a.n000-*,* /* cvaddr */
	lda	0,3
	sta	fbufmg-*
	stz	fbufng-*	/* head of queue check */
	tze	scpret-*
scp010	caq
	tsy	a.n001-*,* /* setbpt */
	cax3
	lda	bf.flg,3
	cana	l.n001-*	/* bfflst */
	tnz	scp020-*	/* last message flag */
	lda	bf.nxt,3
	tze	scp030-*	/* no more */
	tra	scp010-*
scp020	aos	fbufng-*
	lda	bf.nxt,3
	tze	scpret-*
	stq	fbufmg-*
	tra	scp010-*
scp030	lda	fbufmg-*
	szn	fbufng-*
	tze	scp040-*
	tsy	a.n001-*,* /* setbpe */
	cax3
	ldq	bf.nxt,3
	stz	bf.nxt,3
	stq	temups-*
	tra	scpret-*
scp040	sta	temups-*
	ldx3	l.n000-*	/* bufadd */
	tsy	a.n000-*,* /* cvaddr */
	stz	0,3
scpret	ila	0
	cax2
	return	scpbst
	rem
	rem
************************************************************
*
*	scupem - scan unprocess chain and add new buffer to it
*
************************************************************
	rem
scupem	subr	scu,(x3)
	ldq	temups-*
	tze	scu040-*
	ldx3	l.n002-*	/* upobuf */
	tsy	a.n000-*,* /* cvaddr */
	lda	0,3
	tze	scu020-*
scu010	tsy	a.n001-*,* /* setbpe */
	cax3
	lda	bf.nxt,3
	tze	scu030-*
	tra	scu010-*
scu020	stq	0,3
	tra	scu040-*
scu030	stq	bf.nxt,3
scu040	stz	temups-*
	tsy	scanup-*
	return	scupem
	rem
	rem
fbufmg	bss	1
temups	bss	1
fbufng	bss	1
	rem
a.n000	ind	cvaddr
a.n001	ind	setbpt
a.n002	ind	addbte
	rem
l.n000	vfd	18/bufadd
l.n001	vfd	18/bfflst
l.n002	vfd	18/upobuf
l.n003	vfd	18/buftmk
l.n004	vfd	18/kv
l.n005	vfd	18/kc
l.n006	vfd	18/flgwd2
l.n007	vfd	18/snifr
*l.n008
l.n009	oct	400000
l.n010	oct	000400
*l.n011
	rem
************************************************************
*
*	scanup - scan unprocess chain and place complete
*	 messages on the bufadd
*
************************************************************
	rem
scanup	subr	scn,(x3)
	ldx3	l.n004-*	/* kv */
	tsy	a.n000-*,* /* cvaddr */
	cx3a
	cax2
scn010	ldx3	l.n005-*	/* kc */
	tsy	a.n000-*,* /* cvaddr */
	lda	0,2
	cmpa	0,3
	tze	scaret-*	/* no more output */
	tsy	getups-*	/* get next on upobuf chain */
	tra	scaret-*	/* done */
	tsy	a.n002-*,* /* add it to the bufadd */
	ldx3	l.n006-*	/* flgwd2 */
	tsy	a.n000-*,* /* cvaddr */
	lda	l.n007-*	/* snifr */
	orsa	0,3
	aos	0,2
	tra	scn010-*
scaret	ila	0
	cax2
	return	scanup
	rem
	rem
************************************************************
*
*	getups - get next uprocess message and process it
*
************************************************************
	rem
getups	subr	gtp,(x2,x3)
	ldx3	l.n002-*	/* upobuf */
	tsy	a.n000-*,* /* cvaddr */
	lda	0,3
	tze	gtpret-*	/* nothing to do */
	sta	temups-*	/* store address  here for later use */
gtp010	tsy	a.n001-*,* /*setbpt */
	sta	fbufmg-*	/* temp store for address modication */
	cax3
	lda	bf.tly,3
	ana	l.n003-*	/* only tally is needed */
	iaa	1
	ars	1
	iaa	-1
	ada	fbufmg-*
	iaa	bf.dta
	cax2
	lda	0,2
	cana	l.n009-*
	tnz	gtp020-*	/* found eom */
	cana	l.n010-*
	tnz	gtp020-*
	lda	bf.nxt,3
	tze	gtpret-*	/* no more input */
	tra	gtp010-*	/* loop again */
gtp020	aos	getups-*	/* normal return */
	lda	l.n001-*	/* bfflst */
	orsa	bf.flg,3
	lda	bf.nxt,3
	stz	bf.nxt,3
	caq
	ldx3	l.n002-*	/* upobuf */
	tsy	a.n000-*,* /* cvaddr */
	stq	0,3
gtpret	return	getups
	rem
	rem
************************************************************
*
*	getotp - a very fast method to get the proper output
*	 command/response to be sent
*	 This routine use the normalize instruction to 
*	 preform this function.
*
*	parameters 
*	 flgwd2 - Place in A-reg with bit 0 off (a must)
*	 pointer (endlist) in X1 for transfer lables back
*
*	results
*	 routines will return to lable corresponding to
*	 bit set in flgwd2
*
*	warnings
*	 flgwd2 must have bit 0 off
*	 and flgwd2 must not be zero
*
************************************************************
getopt	subr	gto,(x1)	"restore x1 on return
	ldx3	l.o000-*	"=flgwd2
	tsy	a.o000-*,* "=cvaddr
	lda	0,3	"flgwd2 must be in A-reg
	ldx1	l.o001-*	"address of endlist
	nrm		"find something to output
	ldx2	0,1	"this what we will do
	return	getopt
	rem
a.o000	ind	cvaddr
l.o000	vfd	18/flgwd2
l.o001	ind	endlst
	rem
	ind	sprr1	"poll rr command
	ind	sprej1	"poll rej command
	ind	sprnr1	"poll rnr command
	ind	srr1	"rr response
	ind	sif1	"I-frame
	ind	srej1	"rej response
	ind	srnr1	"rnr response
	ind	sua1	"ua response
	ind	scout1	"cmdr/frmr command
	ind	sbout1	"sabm command
	ind	ssout1	"sarm command
	ind	sdout	"disc command
endlst	ind	sddnnt	"dm command
	rem
	rem
************************************************************
*
*	clrocp, setocp, ocpset, tstocp
*
*	subrountines to handle the t.ocp field
*
************************************************************
clrocp	subr
	stz	t.ocp,1
	stz	t.ocur,1
	stz	t.olst,1
	return	clrocp
	rem
setocp	subr
	ldx3	0,3
	tsy	a.m000-*,* /* cvaddr */
	lda	0,3
	sta	t.ocp,1
	stz	t.ocur,1
	stz	t.olst,1
	ila	0
	cax2
	return	setocp
	rem
ocpset	subr
	ldx3	0,3
	tsy	a.m000-*,* /* cvaddr */
	lda	t.ocp,1
	sta	0,3
	ila	0
	cax2
	return	ocpset
	rem
tstocp	subr	tst,(x3)
	ldx3	0,3
	tze	tst010-* /* zero no address */
	tsy	a.m000-*,* /* cvaddr */
	lda	0,3
	tra	tst020-*
tst010	cx3a
tst020	cmpa	t.ocp,1
	tze	tst040-*
	ila	0
tst030	cax2
	return	tstocp
tst040	ldx3	tstsx3-*
	lda	1,3
	tra	tst030-*
a.m000	ind	cvaddr
	end
