* ***********************************************************
* *                                                         *
* * Copyright, (C) Honeywell Information Systems Inc., 1982 *
* *                                                         *
* * Copyright (c) 1972 by Massachusetts Institute of        *
* * Technology and Honeywell Information Systems, Inc.      *
* *                                                         *
* ***********************************************************

	ttl	intp -- control table interpreter for mcs/fnp
	lbl	,interpreter
	rem
********************************************************************************
*
* modified 79 jul 29 by art beattie to use real tib address in trace calls
*   and call 'setptw' in 'itmout' routine.
* modified 81 jan 16 by robert coren to add metering op blocks
*
********************************************************************************
	rem
	rem
	pcc	on
	pmc	off
	editp	on
	symdef	intp
	symdef	itmout,itest,iwrite,istat,istbrk
	symdef	globsw
	symdef	cvaddr
	symdef	adbyte
	symdef	getcmt
	symdef	intend	end of interpreter
	symdef	-mcall
	symdef	-mcal2
	pmc	save,on
	comreg
	tib
	meters
	sfcm	hsla
	devtab
	buffer
	ttls	symbol definitions
	symref	ctrl
	symref	secdsp,setime,frelbf
	symref	denq,meterc
	symref	hdcw,ldcw
	symref	hgeti
	symref	hcfg
	symref	trace
	symref	getbuf,frebuf
	symref	getbfh,frebfh
	symref	getmem,fremem
	symref	brkhit
	symref	lctlck
	symref	setcct
	symref	puteco
	symref	setptw	set up variable cpu page table word
	symref	setbpt	set up buffer page table word
	symref	cvabs	convert virtual address to absolute
	symref	gettib
	symref	mincs,mincd,mupdat,mmsg
	rem
statop	bool	777004	status op code
waitop	bool	777003	wait op code
accin	equ	74	accept input mailbox op code
sndout	bool	105	send output mailbox op code
sparms	bool	104	send params opcode
space	bool	040	ascii space char
cr	bool	015	ascii carriage return
upshft	bool	034	ebcdic up-shift
dnshft	bool	037	ebcdic down-shift
ibmeot	bool	074	ebcdic eot
ntfwrt	bool	/tfwrit	for turning tfwrit off
ntfrpn	bool	/tfrpon	for turning tfrpon off
hslafl	bool	001000
	rem
	rem
	rem	memory trace types
	rem
mt.tst	equ	1
mt.wrt	equ	2
mt.sta	equ	3
mt.tim	equ	4
mt.blk	equ	5
	rem
	rem	tracing switches
	rem
tr.ent	bool	040
tr.blk	bool	100
	rem
ct.dev	equ	1	offset in control tables of pointer
	rem		to device table entry pointers
intp	null
	start	intp,3
	pmc	restore
	rem
globsw	oct	0	"global swtches" word
	ttls	itest entry for test-state
	rem
*	this entry called by dia_man for test-state
*
*	input:
*	     x1 - virtual tib address
	rem
itest	subr	ite,(x1,x2,x3,a,q)
	rem
	lda	t.line,1	get line number
	tsy	a.c002-*,*	(gettib) get real tib address in a
	cax2		put in x2 for trace
	rem
	trace	mt.tst,tr.ent,(x2,t.cur(1))
*
	tsy	iinchk-*,*	make sure entry is valid
	tra	ite001-*	at breakpoint, ignore call
	ldx2	3,2	get branch point for test-state
	tze	ite001-*	never mind if there isn't one
	tsy	iintrp-*,*	call interp to do work
ite001	return	itest
	ttls	iwrite entry for output
	rem
*	entry for write, called by dia_man when output is to be sent
*
*	input:
*	     x1 - virtual tib address
	rem
iwrite	subr	iwr,(x1,x2,x3,a,q)
	rem
	lda	t.line,1	get line number
	tsy	a.c002-*,*	(gettib) get real tib address in a
	cax2		put in x2 for trace
	rem
	trace	mt.wrt,tr.ent,(x2,t.cur(1))
*
	tsy	iinchk-*,*
	tra	iwr001-*	at breakpoint, ignore call
	ldx2	2,2	get branch point for write
	tze	2	if any
	tsy	iintrp-*,*
iwr001	return	iwrite
*
	ttls	istat entry to process status
*
*	entry called by hsla_man or lsla_man with standard
*	status word in a register and virtual tib address in x1.
*	checks op blocks following current wait to see if any
*	status tests succeed, and if so, calls interp to proceed.
*	if a non-status block is encountered before any of the status
*	matches, then return, doing nothing.
*
istat	subr	ist,(x1,x2,x3,a,q)
	sta	istsav-*	hang on to status word
	rem
	lda	t.line,1	get line number
	tsy	a.c002-*,*	(gettib) get real tib address in a
	cax2		put in x2 for trace
	rem
	trace	mt.sta,tr.ent,(x2,t.cur(1),istsav)
	tsy	iinchk-*,*	make sure its ok
	tra	istbak-*	at breakpoint, ignore call
ist010	null
	iacx2	4	get next op block
	lda	0,2	get type code
	cmpa	l.a001-*	check against status op code
	tze	ist020-*	okay, go ahead
	rem
	tra	istbak-*	no status blocks to check
*
ist020	null
	lda	istsav-*	get status back in a
	cana	3,2	check "off" bits
	tnz	ist010-*	if not all off, get next status
	ana	2,2	ok, get "on" bits
	cmpa	2,2	are they all on?
	tnz	ist010-*	that didn't work either
*
*		                fell through, get branch point and call        
	trace	mt.blk,tr.blk,(x2,l.a002)
	ldx2	1,2	interp
	tsy	iintrp-*,*
istbak	null
	return	istat
*
l.a001	vfd	o18/statop
l.a002	oct	4	constant for status op block type
istsav	bss	1	saved status
*
	ttls	itmout entry for processing timeouts
*
*	called by secondary dispatcher
*
*	input:
*	     x1 - real tib address
	rem
itmout	null
	rem
	cx1a		get real tib address in a
	sta	itmtib-*	save real tib address for trace
	tsy	a.c001-*,*	(setptw) virtualize it
	cax1		put virtual tib address in x1
	rem
	trace	mt.tim,tr.ent,(itmtib,t.cur(1))
	rem
	tsy	iinchk-*,*	set up
	tra	iscdsp-*,*	in breakpoint, ignore call
*
	ldx2	1,2	get timeout branch if any
	tze	2
	tsy	iintrp-*,*	and do it
	tra	iscdsp-*,*	back to secondary dispatcher
*
iscdsp	ind	secdsp	secondary dispatcher
iinchk	ind	inchek	interpreter entry validation
iintrp	ind	interp	main interpreter subroutine
	rem
itmtib	bss	1	saves real tib address
	ttls	istbrk entry for restarting from breakpoint
	rem
istbrk	subr	ibk,(x1,x2,x3)
	sta	brkopc-*	may contain the real op to execute
	tsy	iinchk-*,*	do std setup
	tra	ibk001-*	at breakpoint, good
	stz	brkopc-*	not at breakpoint, cleanup
	tra	ibkret-*	and return
	rem
ibk001	lda	l.c003-*	=^tfbkpt
	ansa	t.flg3,1	not at break anymore
	tsy	iintrp-*,*	call intpreter
ibkret	return	istbrk
	rem
brkopc	oct	0	real op to exec when starting from break
	ttls	inchek subroutine to validate and set up at entry
*
*	this subroutine makes sure everything is legal at entry to
*	interpreter, and puts address of current wait block in x2
*
inchek	subr	inc,(a)
*
	cx1a		make sure x1 is non-zero
	tnz	2
	die	1
*
	ldx2	t.cur,1	get pointer to current wait blk
	tnz	2	which had better be non-zero
	die	2
	rem
	lda	t.flg3,1	see if at break
	cana	l.c002-*	=tfbkpt
	tnz	incret-*	at break, take nonskip return
*
	lda	0,2	get op block type
	cmpa	l.c001-*	which should be "wait"
	tze	2
	die	3
	aos	inchek-*	take skip return
*
incret	return	inchek
*
a.c001	ind	setptw	set up variable cpu page table word
a.c002	ind	gettib
	rem
l.c001	vfd	o18/waitop
l.c002	vfd	o18/tfbkpt
l.c003	vfd	o18//tfbkpt
	ttls	interp subroutine processes most control blocks
*
*	interp: main subroutine of control table interpreter, called
*	tib address in x1 and pointer to first block to process in
*	x2. starts at top for every fresh op block
*
interp	subr	int,(x2,x3)
	rem
	szn	brkopc-*	op to exec from bkpt restart?
	tze	int010-*	no
	lda	brkopc-*	yes, pick it up
	stz	brkopc-*
	tra	int011-*
*
int010	null		head of main loop
	lda	0,2	get op block type
int011	lrs	9	extend high-order 9 bits
	icmpa	-1	which must be all on
	tze	2
	die	4
*		                 isolate type so as to use        
*		                 jump table        
	qrl	9	get it in low-order
	cqa		of a
	tze	int020-*	zero is not allowed
	icmpa	maxop	it can't be too big either
	tmi	2
int020	null
	die	8
*		                now we'll load type into x3 and use it        
*		                 to index jump table        
	cax3
	trace	mt.blk,tr.blk,(x2,x3)
	adcx3	int030-*	add address of head of jump table
	tra	0,3*	and go through indirect word
*
int030	zero	*	address of jump table
*		                jump table follows        
	ind	int100	(01) goto
	ind	int200	(02) iftyp
	ind	int300	(03) wait
	ind	int400	(04) status
	ind	int500	(05) dcwlst
	ind	int600	(06) setime
	ind	int700	(07) gotype
	ind	int800	(10) setflg
	ind	int900	(11) clrflg
	ind	in1000	(12) tstflg
	ind	in1100	(13) dmpout
	ind	in1200	(14) signal
	ind	in1300	(15) meter
	ind	intbak	(16) waitm just returns
	ind	in1500	(17) sendin
	ind	in1600	(20) tstwrt
	ind	in1700	(21) tstglb
	ind	in1800	(22) setype
	ind	in1900	(23) scntr
	ind	in2000	(24) acntr
	ind	in2100	(25) tcntr
	ind	in2200	(26) getext
	ind	in2300	(27) retext
	ind	in2400	(30) inscan
	ind	in2500	(31) outscn
	ind	in2600	(32) bldmsg
	ind	in2700	(33) dumpin
	ind	in2800	(34) setchr
	ind	in2900	(35) cmpchr
	ind	in3000	(36) calsub
	ind	in3100	(37) retsub
	ind	in3200	(40) holdot
	ind	in3300	(41) ifhsla
	ind	in3400	(42) config
	ind	in3500	(43) ckinpt
	ind	in3600	(44) gtinpt
	ind	in3700	(45) replay
	ind	in3800	(46) dmprpy
	ind	in3900	(47) prepnl
	ind	in4000	(50) tstrpy
	ind	in4100	(51) echo
	ind	in4200	(52) setcct
	ind	in4300	(53) dmpmsg
	ind	in4400	(54) setlcl
	ind	in4500	(55) addlcl
	ind	in4600	(56) tstlcl
	ind	in4700	(57) setlcf
	ind	in4800	(60) clrlcf
	ind	in4900	(61) tstlcf
	ind	in5000	(62) setlcv
	ind	in5100	(63) calasm
	ind	in5200	(64) bkptop
	ind	in5300	(65) linctl
	ind	in5400	(66) linsta
	ind	in5500	(67) tstlcv
	ind	in5600	(70) nullop
	ind	in5700	(71) unwind
	ind	in5800	(72) settmv
	ind	in5600	(73) retpms obsolete (ind to nullop)
	ind	in6000	(74) gotov
	ind	in6100	(75) gocase
	ind	in6200	(76) setfld
	ind	in6300	(77) addfld
	ind	in6400	(100) tstfld
	ind	in6500	(101) meter1
	ind	in6600	(102) meter2
	ind	in6700	(103) meteru
	ind	in6800	(104) meterm
	ind	in2620	(105) bldims
maxop	equ	*-int030	defines end of table
*
intbak	null		return point
	return	interp
*
*
*
*
int100	null		goto
	ldx2	1,2	get address from block
	tra	int010-*	and go around again
*
*	test terminal type
*	iftype <terminal type test value>,<ptg on equal>
*
int200	null
	lda	1,2	get terminal type test value
	cmpa	t.type,1	vs tib terminal type
	tze	int210-*	equal
	iacx2	3	go to next block
	tra	int010-*
int210	ldx2	2,2	get new block address
	tra	int010-*
*
*
int300	null		wait
	szn	incall-*	check if still in called subroutine
	tze	2
	die	13	wait block executed between call and retu
	stx2	t.cur,1	store pointer to wait block in
	tra	intbak-*	tib and return
*
*
int400	null		status is illegal except after wait
	die	5
*
*
int500	null		dcwlst, handled by subroutine
	tsy	idcwc-*,*
	tra	int010-*
*
idcwc	ind	dcwcnt
*
*
int600	null		setime
	lda	1,2	get interval
int601	tsy	istime-*,*
	iacx2	2	bump to next block
	tra	int010-*
istime	ind	setime	scheduler entry to set timer
*
*
int700	null		gotype
	ldq	t.type,1	make sure terminal type code
	tze	int710-*	is positive
	tpl	2
int710	null
	die	12
*
int720	iacx2	1	advance to branch point
	lda	0,2	get branch point
	tmi	int710-*	end of list
	iaq	-1	decrement count
	tze	int730-*	found branch point
	tra	int720-*	loop
int730	cax2		get new address
	tra	int010-*	and process it
*
*
int800	null		setflg
	lda	1,2	get word of flags to turn on
	orsa	t.flg,1	and do it
	lda	2,2	same for second word
	orsa	t.flg2,1
	iacx2	3	bump to next block
	tra	int010-*
*
*
int900	null		clrflg
	lda	1,2	get word of flags to turn off
	iera	-1	complement it
	ansa	t.flg,1	turn off specified tib flags
	lda	2,2	get  second word
	iera	-1	complement  it
	ansa	t.flg2,1	turn these off,too
	iacx2	3	on to the next
	tra	int010-*
*
*
in1000	null		tstflg
	lda	2,2	get flags to test
	ana	t.flg,1	isolate them from tib flag word
	cmpa	2,2	are they all on?
	tnz	in1010-*
	lda	3,2	get  second word to test
	ana	t.flg2,1
	cmpa	3,2	are they all on too?
	tnz	in1010-*
	ldx2	1,2	yes, get new op block address
	tra	int010-*
in1010	null
	iacx2	4	no, bump to next block
	tra	int010-*
*
*
in1100	null		dmpout
	stz	sndflg-*	initialize this
	lda	t.ocp,1	get output chain pointer
	tze	in1110-*	and if its non-zero, free chain
	sta	in1190-*	save address
	tsy	a.d005-*,*	setbpt
	cax3		get addressable pointer
	lda	bf.flg,3	get buffer flags
	cana	l.d007-*	=hold output buffers flag
	tze	in1108-*	no - normal dmpout
in1104	cana	l.d006-*	=last buffer in message flag
	tnz	in1106-*	yes - release partial chain
	lda	bf.nxt,3	get forward link
	tze	in1107-*	end of chain - treat as normal dmpout
	tsy	a.d005-*,*	setbpt
	cax3		as above
	lda	bf.flg,3	get buffer flags
	tra	in1104-*
in1106	lda	bf.nxt,3	get forward link
	stz	bf.nxt,3	unlink rest of chain
	ldx3	t.ocp,1	get output chain pointer
	sta	t.ocp,1	establish new output chain
	cx3a
	tsy	ifrel-*,*	release first message in chain
	stz	t.ocur,1	void current buffer stuff
	stz	t.olst,1
	tra	in1140-*
	rem
in1107	aos	sndflg-*	make sure about sndout
	lda	t.ocp,1	get ptr to chain
	tsy	ifrel-*,*	free chain
	stz	t.ocp,1	zero ptr
	stz	t.ocur,1
	stz	t.olst,1
	tra	in1120-*
	rem
in1108	lda	in1190-*	get absolute chain address
	tsy	ifrel-*,*
	stz	t.ocp,1
	aos	sndflg-*	we must do "send output" if t.ocp chain was freed
in1110	null
	rem		do the same for chain being
	lda	t.ocur,1	output currently
	tze	in1120-*
	tsy	ifrel-*,*
	stz	t.ocur,1
	stz	t.olst,1
	lda	t.line,1	hsla line?
	cana	l.d010-*	=hslafl
	tze	in1120-*	no
	ldx3	t.sfcm,1	yes, we'll need sfcm address
	stz	sf.noc,3	not partway through an output buffer now
	rem
in1120	null
	szn	sndflg-*	did we free t.ocp chain?
	tnz	in1125-*	yes, queue "send output"
	ila	bufthr	if we threw away more than "threshold" buffers,
	cmpa	t.ocnt,1	we'll have to ask for more output
	tpl	in1130-*
in1125	null
	ilq	sndout
	tsy	idenq-*,*	dia enqueueing routine
in1130	null
	stz	t.ocnt,1	no buffers in write chain now
	lda	l.d002-*	^tfwrit
	ansa	t.flg,1	tfwrit must be turned off
in1140	null
	iacx2	1	bump to next block
	tra	int010-*
	rem
in1190	bss	1
ifrel	ind	frelbf	free buffer chain subroutine
*
*
in1200	null		signal
	ldq	1,2	get signal type
	tsy	idenq-*,*	call dia queuing routine
	iacx2	2	bump to next block
	tra	int010-*
idenq	ind	denq	dia enqueuing routine
*
*
in1300	null		meter
	ldq	1,2	get meter type
	tsy	imetrc-*,*	and call metering utility
	iacx2	2	next block
	tra	int010-*
imetrc	ind	meterc
*
*
in1500	null		sendin
	lda	t.icp,1	get input chain pointer
	tze	in1520-*	forget it if zero
	cmpa	t.ilst,1	see if there's only 1 buffer
	tnz	in1510-*	no, send the chain
	tsy	a.d005-*,*	setbpt
	cax3
	lda	bf.tly,3	otherwise make sure tally
	ana	l.d001-*	is non-zero
	tze	in1520-*
*
in1510	null
	ilq	accin	put "accept input" opcode in q
	tsy	idenq-*,*	for dia enqueuing routine
*
in1520	null
	iacx2	1	next block
	tra	int010-*
*
*
*
in1600	null		tstwrt
	szn	t.ocp,1	is there an output chain
	tnz	in1605-*
	szn	t.ocur,1	or is there one we're working on now?
	tze	in1610-*
in1605	null
	ldx2	1,2	yes, get branch address
	tra	int010-*
in1610	null		no, go to next block
	iacx2	2
	tra	int010-*
*
*
in1700	null		tstglb
	lda	iglob-*,*	pick up global switches
	ana	1,2	isolate the one(s) we're testing
	cmpa	1,2	all on?
	tnz	in1710-*
	ldx2	2,2	yes, get new op block addr.
	tra	int010-*
in1710	iacx2	3	fail, get next block
	tra	int010-*
iglob	ind	globsw
*
*
in1800	null		setype
	lda	1,2	get new type from op block
	sta	t.type,1	set it in tib
	ldx3	a.d004-*	addr (ctrl)
	ldx3	ct.dev,3	get pointer to device tables
	adcx3	t.type,1	indexed by line type
	ldx3	-1,3	subtract 1 for 0 origin
	iacx3	dt.brk	add in offset of break table
	stx3	t.brkp,1	update break table address
	iacx2	2	next block
	tra	iin010-*,*
*
in1900	null		scntr (set counter)
	lda	1,2	get new value
	sta	t.cntr,1	store it in counter
	iacx2	2	next block
	tra	iin010-*,*
*
in2000	null		acntr (add to counter)
	lda	t.cntr,1	origional value
	ldq	1,2	increment
	tsy	a.d001-*,*	=addnov
	sta	t.cntr,1
	iacx2	2	next block
	tra	iin010-*,*
*
in2100	null		tcntr (test counter)
	lda	1,2	get test value
	cmpa	t.cntr,1	same as counter?
	tze	in2110-*
	iacx2	3	no, go to next block
	tra	iin010-*,*
in2110	null
	ldx2	2,2	yes, get new block address
	tra	iin010-*,*
	rem
	rem
	rem
a.d001	ind	addnov
a.d002	ind	getmem
a.d003	ind	fremem
a.d004	ind	ctrl
a.d005	ind	setbpt
a.d006	ind	cvabs
	rem
l.d001	vfd	18/buftmk	buffer tally mask
l.d002	vfd	18/ntfwrt
l.d003	oct	400000	extension buffer in use flag
l.d004	oct	77	sub-buffer tally mask
l.d005	oct	777	mask for right half
l.d006	vfd	18/bfflst	last buffer in message flag
l.d007	vfd	18/bffhld	hold output buffers flag
*l.d008	unused
*l.d009	unused
l.d010	vfd	18/hslafl
	rem
incall	oct	0	hold area - return point from called subr
ifrlbf	ind	frelbf	free linked chain of buffers subroutine
	rem
	rem
sndflg	bss	1	indicates whether to do "send output" on dmpout
*
*	get tib extension
*	getext < # words needed>,<ptg on failure>
*
in2200	szn	t.elnk,1	does line have extension?
	tze	2	no
	die	14	die
	ldq	1,2	number of words needed
	iaq	1	+1 for length word
	tsy	a.d002-*,*	=getmem
	tra	in2210-*	no room
	lda	1,2	length requested
	sta	0,3	save in extension
	stx3	t.elnk,1	save extension address
	iacx2	3	skip 3 words for this opblock
	tra	iin010-*,*	and go to next
in2210	ldx2	2,2	take failure return
	tra	iin010-*,*
*
*	return a tib extension
*	retext
*
in2300	ldx3	t.elnk,1	get address
	tze	in2310-*	none, do nothing
	stz	t.elnk,1	no longer has ext
	ldq	0,3	length
	iaq	1	plus control word
	tsy	a.d003-*,*	=fremem
in2310	iacx2	1
	tra	iin010-*,*
*
*	input scan
*	inscan <address of control string>,<ptg on failure>
*
in2400	ila	0	get input scan indicator
	tsy	iscnop-*,*	call scan subroutine
	tra	iin010-*,*
iscnop	ind	scanop
*
*	output scan
*	outscn <address of control string>,<ptg on failure>
*
in2500	ila	1	get output scan indicator
	tsy	iscnop-*,*	call scan subroutine
	tra	iin010-*,*
*
*
*
iin010	ind	int010
ibldut	ind	bldutl
iadbyt	ind	adbyte
*
*	build output message
*	bldmsg <address of control string>,<ptg on failure>
*
in2600	null
	tsy	ibldut-*,*	(=bldutl) build the message
	tra	in2670-*	failed
	lda	t.ocp,1	get output chain pointer
	sta	bf.nxt,3	chain it to this one
	cx3a		get our absolute address
	tsy	a.d006-*,*	cvabs
	sta	t.ocp,1	replace output chain pointer
	rem
in2605	iacx2	3	go to next block
	tra	iin010-*,*
*
*	build input message
*	bldims <address of control string>,<ptg on failure>
*
in2620	null
	tsy	ibldut-*,*	(=bldutl) build the message
	tra	in2670-*	failed
	lda	t.icp,1	get input chain pointer
	sta	bf.nxt,3	chain it to current one
	cx3a
	tsy	a.d006-*,*	cvabs
	sta	t.icp,1	place input chain pointer
	tra	in2605-*	return
*
* Here for failing bldmsg
*
in2670	ldx2	2,2	get failure block address
	tra	iin010-*,*
*
*	dump input chain
*	dumpin
*
in2700	lda	t.icp,1	get input chain ptr
	tze	in2710-*	no chain
	tsy	ifrlbf-*,*	free input chain
	stz	t.icp,1	zero chain pointer
	stz	t.ilst,1	zero pointer to last buffer
	stz	t.icpl,1
in2710	iacx2	1	go to next block
	tra	iin010-*,*
*
*	set byte value in tib extension
*	setchr <destination>,<source>
*
in2800	lda	1,2	get byte positions
	arl	9	isolate dest byte
	tsy	iadbyt-*,*	get its byte adress
	die	15	not tib extension byte
	stx3	in2850-*	save - dest address
	lda	1,2
	ana	l.d005-*	=o777 - isolate source byte
	tsy	iadbyt-*,*	get its address
	tra	in2810-*	not 46x value
	lda	0,3,b.0	get source byte
in2810	ldx3	in2850-*	get dest byte address
	sta	0,3,b.0	place in tib byte
	iacx2	2	go to next block
	tra	iin010-*,*
in2850	bss	1	destination byte address
in2860	bss	1	source byte address
*
*	compare bytes
*	cmpchr <source>,<test value>,<ptg on equal>
*
in2900	lda	1,2	get byte positions
	arl	9	isolate source byte
	tsy	iadbyt-*,*	get its byte address
	tra	in2910-*	not 46x value
	lda	0,3,b.0	get source byte
in2910	sta	in2860-*	save for compare
	lda	1,2
	ana	l.d005-*	=o777 - isolate test value
	tsy	iadbyt-*,*	get its address
	tra	in2920-*	not 46x value
	lda	0,3,b.0	get test value
in2920	cmpa	in2860-*	vs source byte
	tze	in2930-*	equal
	iacx2	3	go to next block
	tra	iin010-*,*
in2930	ldx2	2,2	get equal block address
	tra	iin010-*,*
*
*	call subroutine
*	calsub <subroutine entry point>
*
in3000	szn	incall-*	check return point
	tze	2	ok - not in use
	die	13	multiple subroutine calls
	lda	1,2	get entry point block address
	iacx2	2
	szn	t.reta,1	tib return addr used yet?
	tnz	in3001-*	yes
	stx2	t.reta,1
	tra	in3002-*
in3001	stx2	incall-*	save return point
in3002	cax2		go to subroutine
	tra	iin010-*,*
*
*	return from subroutine
*	retsub
*
in3100	szn	incall-*	check second return point
	tze	in3101-*	not in use
	ldx2	incall-*
	stz	incall-*
	tra	iin010-*,*
in3101	szn	t.reta,1	check first return point
	tnz	2
	die	13
	ldx2	t.reta,1
	stz	t.reta,1
	tra	iin010-*,*
*
*	set hold output buffer flag
*	holdot
*
in3200	lda	t.ocp,1	get output chain pointer
	tnz	in3220-*
in3210	iacx2	1	go to next block
	tra	iin010-*,*
in3220	tsy	a.g015-*,*	setbpt
	cax3
	lda	in3290-*	get hold output buffer flag
	orsa	bf.flg,3	set on in buffer
	lda	bf.flg,3
	ana	in3280-*	check for last buffer in message
	tnz	in3210-*	yes
	lda	bf.nxt,3	get forward pointer
	tze	in3210-*
	tra	in3220-*
	rem
in3280	vfd	18/bfflst	last buffer in message flag
in3290	vfd	18/bffhld	hold output buffer flag
*
*	test for hsla line
*	ifhsla
*
in3300	null		ifhsla
	lda	t.line,1	get line number to find out if hsla line
	arl	9	get hsla bit down at end
	tze	in3310-*	not hsla
	ldx2	1,2	is hsla, get branch point
	tra	iin010-*,*	go get new block
in3310	null		not hsla
	iacx2	2	go to next block
	tra	iin010-*,*
*
*	reconfigure operation for hsla's
*	config
*
in3400	null		config
	lda	t.line,1	be sure hsla
	arl	9
	tnz	2
	die	16
	iacx2	1	point at first sub-op
	tsy	icnfg-*,*	config block processed by subroutine
	tra	iin010-*,*	and continue with next op block
	rem
icnfg	ind	hcfg	subroutine to process config block
*
*	check for partial input line for channel
*	ckinpt
*
in3500	null		ckinpt
	lda	t.icp,1	is there an input chain?
	tze	in3510-*	no, check for hsla
	tsy	a.g015-*,*	setbpt
	cax3
	lda	bf.tly,3	yes, see if it's more than just cr
	ana	l.g001-*	(=buftmk) isolate tally in first buffer
	iaa	-2	is it more than 1?
	tpl	in3595-*	yes, there's a partial line
	rem		(otherwise result would have been negative)
	cx3a		no, get pointer to first character
	ada	l.g007-*	bf.dta,b.0
	cax3		in order to
	tra	in3520-*	check to see if it's carriage return
	rem
in3510	lda	t.line,1
	arl	9	is it an hsla line?
	tze	in3590-*	no, there's no input
	rem
	ldx3	a.g001-*	(=indblk) 2 word arg blk for hgeti
	tsy	a.g002-*,*	(=hgeti) call routine to check input
	lda	indblk+1-*	any chars in buffer?
	tze	in3590-*	no, at left margin
	icmpa	1	 more than one char?
	tnz	in3595-*	yes, we have partial input
	ldx3	indblk-*	no, look at character
in3520	lda	0,3,b.0	pick up the char
	iana	127	strip off parity
	sta	tmpchr-*	hang on to it
	icmpa	cr	is it carriage return?
	tze	in3590-*	yes, no partial input
	icmpa	upshft	case shift character?
	tze	in3590-*	yes, doesn't count
	icmpa	dnshft	or lower shift?
	tze	in3590-*	yes, don't count it either
	lda	t.flg2,1	check for output flow control chars
	cana	l.g008-*	tfofc
	tze	in3540-*	mode not on, skip it
	ldq	t.ofch,1	get the chars
	cana	l.g009-*	tfblak
	tnz	in3530-*	if block ack, don't check 1st char
	cqa
	arl	9	suspend character
	cmpa	tmpchr-*	got it?
	tze	in3590-*	yes, doesn't count
in3530	lls	27	isolate resume/ack char
	arl	9
	cmpa	tmpchr-*
	tze	in3590-*	it is one, don't count it
in3540	lda	t.type,1	is this a 2741?
	icmpa	3
	tnz	in3595-*	no, don't check further
	lda	tmpchr-*	get character back into a
	iana	63	mask off shift
	icmpa	ibmeot	is it an eot?
	tnz	in3595-*	no, we have partial input
	rem
in3590	ldx2	1,2	get fail addr, no partial line
	tra	a.g003-*,*	(=int010) return
	rem
in3595	iacx2	2	all well, partial input ready
	tra	a.g003-*,*	(=int010) return
*
*	routine to scoop up input and make output chain at t.rcp
*	gtinpt
*
in3600	null
	stx2	in3694-*	save x2 value
	rem
	tsy	a.g006-*,*	(=getcmt) get pointer to cmt
	rem		returned in x2
	lda	1,2,b.0	get tab from cmt
	sta	a.g007-*,*	(tabchr) save for copybf
	lda	1,2,b.1	likewise backspace
	sta	a.g008-*,*	(bschar)
	rem
	lda	t.type,1	is it a 1050 or 2741?
	icmpa	2	(1050)
	tze	in3602-*
	icmpa	3	(2741)
	tnz	in3603-*
in3602	ila	61	yes, use ebcdic pad
	tra	in3604-*
	rem
in3603	ila	0	no, use ascii pad
in3604	sta	a.g008-*,*	(delchr) save for copybf
	stz	t.rcp,1	to initialize
	rem
	lda	t.icp,1	get ptr to head of input chain
	tze	in3650-*	none, check hsla
	rem
in3610	tsy	a.g015-*,*	setbpt
	cax2
	lda	bf.tly,2	get the output buffer tally
	ana	l.g001-*	(=buftmk) mask tally
	caq		hold on to it
	stx2	in3695-*	save original buffer pointer
	cx2a		move pointer to first char
	ada	l.g007-*	bf.dta,b.0
	cax2
	cqa		get tally back
	tsy	a.g010-*,*	(copybf) copy it into replay chain
	rem
	ldx2	in3695-*	restore x2 with buffer pointer
	lda	bf.nxt,2	get fwd ptr in this buffer
	tnz	in3610-*	enter copy loop if another buffer
	stx3	in3693-*	save pointer to last buffer
	rem
in3650	lda	t.line,1	special code for hsla's
	arl	9	we are done if its an lsla
	tze	in3680-*	we are.
	rem
	ldx3	a.g001-*	(=indblk) 2 word arg blk
	tsy	a.g002-*,*	(=hgeti) get input ptrs and tally
	szn	indblk+1-*	any input at all?
	tze	in3680-*	no, done
	rem
	lda	indblk+1-*	get the tally
	rem
	ldx2	indblk-*	get ptr to input bffr
	tsy	a.g010-*,*	(copybf) copy this stuff
	tra	2	buffer address is in x3 already
	rem
in3680	ldx3	in3693-*	get ptr to last buffer in chain
	lda	a.g016-*,*	(ctpte) get target pte back
	sta	a.g017-*,*	.crbpe,*
	lda	l.g004-*	(=bffrpy) get replay flag
	orsa	bf.flg,3	set in buffer
	rem
	ldx2	in3694-*
	iacx2	1	skip this block
	tra	a.g003-*,*	(=int010)
	rem
in3693	bss	1
	rem
in3694	bss	1
in3695	bss	1
indblk	bss	2
	rem
a.g001	ind	indblk
a.g002	ind	hgeti
a.g003	ind	int010
a.g004	ind	getbfh
a.g005	ind	frelbf
a.g006	ind	getcmt
a.g007	ind	tabchr	in copybf
a.g008	ind	delchr	in copybf
a.g009	ind	bschar	in copybf
a.g010	ind	copybf	subroutine to copy input buffer into replay buffer
a.g011	ind	addnov
a.g012	ind	puteco
a.g013	ind	frebfh
a.g014	ind	setcct	hsla mans cct setter
a.g015	ind	setbpt
a.g016	ind	ctpte	in copybf
a.g017	ind	.crbpe,*
	rem
l.g001	vfd	18/buftmk
l.g002	ind	0,b.0
l.g003	oct	000777
l.g004	vfd	18/bffrpy
l.g005	vfd	18/ntfrpn
l.g006	vfd	18/bffbrk
l.g007	zero	bf.dta,b.0
l.g008	vfd	18/tfofc
l.g009	vfd	18/tfblak
	rem
tmpchr	bss	1	temporary storage for test char
*
*	op to make gtinpt chain the real output chain
*	replay
*
in3700	null		replay
	ldx3	t.rcp,1	get replay chain ptr
	szn	t.ocp,1	make sure no output ready now
	tze	2
	die	17
	rem
	stx3	t.ocp,1	set as head of chain
	stz	t.rcp,1	zero replay chain ptr
	rem
	iacx2	1	next block please
	tra	a.g003-*,*	(=int010)
*
*	dump the replay chain, if any
*	dmprpy
*
in3800	null		dmprpy
	lda	t.rcp,1	get ptr
	tze	in3810-*	none, done
	rem
	tsy	a.g005-*,*	(=frelbf)
	stz	t.rcp,1	freed
	rem
in3810	iacx2	1	next block
	lda	l.g005-*	=^tfrpon
	ansa	t.flg2,1	replay not on now
	tra	a.g003-*,*	(=int010)
*
*	op to prepare newline and delays for output now
*	prepnl
*
in3900	null
	ilq	bufsiz	allocate buffer for the nl
	tsy	a.g004-*,*	(=getbfh)
	die	18
	rem
	sta	in3994-*	save absolute address of buffer
	stx3	in3991-*	save virtual addr of buffer
	stx2	in3992-*	save x2 for awhile
	rem
	stz	in3993-*	init the tally for the buffer
	rem
	cx3a		setup x3 with char addressing too
	iaa	bf.dta	offset of data in buffer
	ora	l.g002-*	(=0,b.0) char bits
	cax3		back into x3
	rem
	tsy	a.g006-*,*	(getcmt) get cmt pointer
	lda	0,2,b.1	get the cr char from the cmt
	cmpa	l.g003-*	(=000777) no char?
	tze	in3910-*	yes, dont use it
	rem
	sta	0,3,b.0	put cr into buffer
	iacx3	0,b.1	bump ptr
	aos	in3993-*	bump tally
	rem
in3910	lda	0,2,b.0	get the nl char
	sta	0,3,b.0	put the char into the buffer
	iacx3	0,b.1	bump the ptr
	aos	in3993-*	bump the tally
	rem
	ilq	0	get the pad for ascii (null)
	rem
	lda	t.type,1	get the type of this guy
	icmpa	2	is it 1050?
	tze	in3913-*	yes
	icmpa	3	is it 2741?
	tnz	in3915-*	no
in3913	ila	-17	more delays for ebcdic types
	ilq	61	octal 75 is idle for 1050/2741
	tra	in3920-*
	rem
in3915	ila	-8	get the count of pads to send
in3920	stq	0,3,b.0	deposit for idle
	iacx3	0,b.1	bump ptr
	aos	in3993-*	count tally
	iaa	1	decrement count
	tnz	in3920-*	loop
	rem
	ldx3	in3991-*	reload ptr to buffer
	lda	in3993-*	get the correct tally
	sta	bf.tly,3	save in buffer
	rem
	lda	t.ocp,1	get head of chain
	sta	bf.nxt,3	make head ptr nxt in our buffer
	ldx3	in3994-*	get absolute address back
	stx3	t.ocp,1	make us head now
	rem
	ldx2	in3992-*	reload op block ptr
	iacx2	1	skip the block
	tra	a.g003-*,*	(=int010)
	rem
in3991	bss	1
in3992	bss	1
in3993	bss	1
in3994	bss	1
*
*	op to test replay chain ptr
*	tstrpy
*
in4000	null
	szn	t.rcp,1	any replay chain?
	tnz	in4010-*	yes
	rem
	ldx2	1,2	no, take fail addr
	tra	a.g003-*,*	(=int010)
	rem
in4010	iacx2	2	ok skip block
	tra	a.g003-*,*	(=int010)
*
*	op to insert char in echo buffer
*	echo
*
in4100	null
	ldq	1,2	get character
	tsy	a.g012-*,*	(=puteco)
	iacx2	2	next op block
	tra	a.g003-*,*	(=int010)
*
*	initialize cct to specific table
*	setcct	<addr of cct to be used>
*
h.baw	equ	8	base address word in hwcm
*
in4200	lda	t.line,1	be sure it is hsla
	arl	9
	tze	in4201-*	lsla, ignore
	lda	1,2	get arg
	tsy	a.g014-*,*	=setcct
in4201	iacx2	2	go to next op block
	tra	a.g003-*,*	(=int010)
*
*	dump input message up to break char
*	dmpmsg
*
in4300	lda	t.icp,1	get head of input chain
	tze	in4310-*	there isn't any, we're done
	sta	in4391-*	save absolute address
	tsy	a.g015-*,*	setbpt
	cax3
	lda	bf.flg,3	find out if this is end
	ana	l.g006-*	=bffbrk
	sta	in4390-*	save for later
	lda	bf.nxt,3	get forward pointer
	sta	t.icp,1	new head of chain
	lda	bf.siz,3	get buffer size
	arl	15	size-1
	iera	-1	add 1 and negate
	asa	t.icpl,1	subtract from chain length
	lda	in4391-*	get absolute address for freeing
	ilq	0
	tsy	a.g013-*,*	frebfh
	szn	in4390-*	was it last in message?
	tze	in4300-*	no, look at new head
in4310	szn	t.icp,1	is head of chain zero?
	tnz	2	no, that's cool
	stz	t.ilst,1	make sure no one thinks there's a chain
	iacx2	1	done, go to next block
	tra	a.g003-*,*	=int010
	rem
in4390	bss	1	used to hold latest value of bffbrk
in4391	bss	1	holds absolute buffer address
*
*	setlcl - set a local variable
*
in4400	ldx3	1,2	addr of variable
	tsy	cvaddr-*	get real address
	lda	2,2	new value
	sta	0,3	this is the job
	iacx2	3
	tra	a.g003-*,*	=int010
*
*	addlcl - add value to a local variable
*
in4500	ldx3	1,2	addr of variable
	tsy	cvaddr-*
	lda	0,3	starting value
	ldq	2,2	increvemt
	tsy	a.g011-*,*	(addnov) do the add
	sta	0,3	and store result
	iacx2	3
	tra	a.g003-*,*	=int010
*
*	tstlcl - test local variable and goto if equal
*
in4600	ldx3	1,2	addr of variable
	tsy	cvaddr-*
	lda	2,2	test val
	cmpa	0,3
	tze	in4601-*	do the goto
	iacx2	4
	tra	a.g003-*,*	=int010
in4601	ldx2	3,2	get branch addr
	tra	a.g003-*,*	=int010
*
*	setlcf - set flag in local variable
*
in4700	ldx3	1,2	addr of variable
	tsy	cvaddr-*
	lda	2,2	new bits to set
	orsa	0,3	set them
	iacx2	3
	tra	a.g003-*,*	=int010
*
*	clrlcf - clear flag in local variable
*
in4800	ldx3	1,2	addr of variable
	tsy	cvaddr-*
	ila	-1
	era	2,2	get invverted mask
	ansa	0,3	turn off bits
	iacx2	3
	tra	a.g003-*,*	=int010
*
*	tstlcf - test flag in local variable and goto if on
*
in4900	ldx3	1,2	addr of variable
	tsy	cvaddr-*
	lda	2,2	bits to test
	ana	0,3	test them
	cmpa	2,2	all on?
	tze	in4901-*	yes
	iacx2	4
	tra	a.g003-*,*	=int010
in4901	ldx2	3,2	get place to go
	tra	a.g003-*,*	=int010
*
*	setlcv - set local variable from another one
*
in5000	ldx3	1,2	address of target
	tsy	cvaddr-*
	stx3	in5001-*
	ldx3	2,2	address of source
	tsy	cvaddr-*
	lda	0,3	pick up data
	sta	in5001-*,*
	iacx2	3
	tra	a.g003-*,*	=int010
in5001	bss	1
*
*	subroutine to get address of local variables.
*	a positve number is a real address.
*	a negative number is a tib externion offset, and is converted
*	to a real address.
*	entered with address in x3
*
cvaddr	subr	cva
	cx3a
	icmpa	0	test for minus
	tpl	cvaret-*	normal address
	szn	t.elnk,1	be sure there is tib extension
	tnz	2
	die	14
	iera	-1	invert offset
	iaa	1
	ada	t.elnk,1	now have real address
	cax3
cvaret	return	cvaddr
*
*	calasm - call an assembler subr from control tables
*
in5100	cx2a
	iaa	3	get param list addr
	cax3		store here for call
	ada	2,2	get addr of opblock after params
	sta	in5101-*	save for return
	ldx2	2,2	load param count
	tsy	-2,3*	and call subr
	cx2a		check return value
	tnz	a.g003-*,*	subr set return addr
	ldx2	in5101-*	continue in line
	tra	a.g003-*,*	=int010
in5101	bss	1
*
*	bkptop - breakpoint ecountered
*
in5200	tsy	a.h002-*,*	=brkhit, see what to do
	tra	a.h003-*,*	=int011, dont break, a contains op
	lda	l.h002-*	=tfbkpt, set break flag
	orsa	t.flg3,1
	tra	a.h004-*,*	=int300, exit thru wait opblock
*
*	linctl - checks to see if test state call was caused
*	         by a line_control order from cs
*
in5300	tsy	a.h005-*,*	=lctlck, dia man entry to check
	tra	in5301-*	not a line control call
	stx3	in5302-*	save temporarily
	ldx3	1,2	where to store data
	tsy	cvaddr-*
	cx2a		save opblock addr
	ldx2	in5302-*	address of line_control data
	ldq	0,2	copy 4 words
	stq	0,3
	ldq	1,2
	stq	1,3
	ldq	2,2
	stq	2,3
	ldq	3,2
	stq	3,3
	iaa	3	address of next opblock
	cax2
	tra	a.g003-*,*	=int010
in5301	ldx2	2,2	take failuure addr
	tra	a.g003-*,*
in5302	bss	1
*
*	linsta - line status to send signal to cs
*
in5400	ldx3	1,2	addr of data
	tsy	cvaddr-*
	stx2	in5302-*	save opblock addr
	cx3a
	cax2
	ldq	l.h003-*	=004124, linsta code with wordcount=4
	tsy	a.h006-*,*	=denq
	ldx2	in5302-*	current opblock
	iacx2	2	advance to next
	tra	a.g003-*,*
*
*	tstlcv - compares two variables and does goto if equal
*
in5500	ldx3	1,2	addr of first
	tsy	cvaddr-*
	stx3	in5501-*	save first addr
	ldx3	2,2	addr of second
	tsy	cvaddr-*
	lda	0,3	get second value
	cmpa	in5501-*,*	compare to first
	tze	in5502-*	got a match
	iacx2	4	on to next op
	tra	a.h009-*,*	=int010
in5502	ldx2	3,2	get success addr
	tra	a.h009-*,*	=int010
in5501	bss	1
*
*	nullop - a no-operation, do nothing
*
in5600	iacx2	1
	tra	a.h009-*,*	=int010
*
*	unwind - zeores all subroutine return addresses to return
*	         highest level.
*
in5700	stz	a.h007-*,*	=incall
	stz	t.reta,1
	tra	in5600-*
*
*	settmv - set time from a variable
*
in5800	ldx3	1,2	get variable address
	tsy	cvaddr-*
	lda	0,3	pick up time
	tra	a.h008-*,*	=int601, join setime path
*
*	retpms - return parameters
*
* in5900	null		return parameters
* 	ilq	sparms	put return params opcode in q
* 	tsy	idenk-*,*	for dia enqueueing routine
* 	iacx2	1	skip this block
* 	tra	a.h009-*,*	(=int010)
idenk	ind	denq	dia enqueueing routine
*
*	gotov - go to a variable
*
in6000	ldx3	1,2	get variable address
	tsy	cvaddr-*
	ldx2	0,3	get target address
	tra	a.h009-*,*	=int010
	rem
*
*	gocase -  goto computed on case basis
*
in6100	null		goto computed on case
	stx2	gocsva-*	save opblock table IC
	lda	1,2	get varriable addr
	sta	gocval-*	save this addr in temp loc
	ana	gocmsk-*	see if tib ext is char or word
	cmpa	gocmsk-*	see if o760
	tnz	in6101-*	if not char in tib
	lda	gocval-*	word, so get addr from cvaddr
	ora	gocend-*	get this to a full o777XXX
	cax3		move this addr to x3
	tsy	cvaddr-*	go get the real address
	lda	0,3	get value of this varriable
	tra	in6102-*	have addr so go do rest
in6101	lda	gocval-*	char so go get that addr
	tsy	goctib-*,*	get real addr
	tra	in6102-*	literal, so have value
	lda	0,3,b.0	go get value from tib
in6102	sta	gocval-*	so store it
	lda	2,2	get addr compare list
	ora	gocbyt-*	set for byte addressing
	sta	gocvls-*	save addr in word
	ldx3	3,2	get addr of jmp list
	ldx2	gocvls-*	get addr of cmp list to an index
in6103	lda	gocend-*	get ond of list marker
	cmpa	0,3	check for end of string
	tze	in6107-*	if end return
	lda	0,2,b.0	get char from cmp list
	cmpa	goclsn-*	see if end of value list
	tze	in6107-*	end so return
	stx3	gocjls-*	save our jmp addr, we need x3
	ana	gocmsk-*	o760, see if char or word
	cmpa	gocmsk-*	see if word (o760)
	tnz	in6104-*	if not char, tib ext word
	lda	0,2,b.0	word so get value back to get
	ora	gocend-*	get to a full o777XXX
	cax3		move addr to x3 for cvaddr
	tsy	cvaddr-*	go get real addr
	lda	0,3	get value of varriable
	tra	in6105-*	go do it
in6104	lda	0,2,b.0	char so go get it.
	tsy	goctib-*,*	get tib ext addr if needed
	tra	in6105-*	literal so have it
	lda	0,3,b.0	get real value from tib ext
in6105	null		do rest of this entry
	ldx3	gocjls-*	load our jmp list back
	cmpa	gocval-*	compare two values
	tze	in6106-*	if equal found it
	iacx2	0,b.1	incr x2 to next character
	iacx3	1	incr our index counter
	tra	in6103-*	try next value to compare
in6106	null		found our value
	ldx2	0,3	set x2 to the jmp addr
	tra	a.h009-*,*	go return =int010
in6107	null		value not in our table
	ldx2	gocsva-*	get old opblock table IC
	iacx2	4	incr x2 to next opblock in table
	tra	a.h009-*,*	go return =int010
gocsva	bss	1	temp of old x2
gocvls	bss	1	varriable list addr
gocjls	bss	1	jump list addr
gocend	oct	777000	end of list records
gocmsk	oct	760	mask for char or word tib ext
gocval	bss	1	store value to match
goclsn	oct	000777	end of chrstr list
goctib	ind	adbyte	get character from tib
gocsvt	bss	1	save area
gocbyt	zero	0,b.0	set to byte addressing
	rem
	rem
in6200	null		setfld
	lda	2,2	get value to set
	sta	1,2*	store it (op block indirects through x1)
	iacx2	3	on to next
	tra	a.h009-*,*	int010
	rem
in6300	null		addfld
	lda	1,2*	get contents of tib field
	ldq	2,2	get increment
	tsy	a.h010-*,*	addnov
	sta	1,2*	result to tib field  (op block indirects through x1)
	iacx2	3	on to next
	tra	a.h009-*,*	int010
	rem
in6400	null		tstfld
	lda	2,2	get value to test against
	cmpa	1,2*	compare it to field
	tze	in6410-*	equal, branch
	iacx2	4	else advance to next block
	tra	a.h009-*,*	int010
in6410	ldx2	3,2	get branch address
	tra	a.h009-*,*	(int010) go to it
	rem
in6500	null		meter1 (add to single-word meter)
	lda	a.h011-*	addr (mincs)
	tra	mjoin-*
	rem
in6600	null		meter2 (add to double-word meter)
	lda	a.h012-*	addr(mincd)
	tra	mjoin-*
	rem
in6700	null		meteru (update meter & meter count)
	lda	a.h013-*	addr (mupdat)
mjoin	null		a contains address of subroutine
mcall	tra	mret-*	patched to nop by bind_fnp if metering enabled
	sta	mentry-*
	lda	t.metr,1	get pointer to metering area
	ada	1,2	plus offset of specified meter
	ldq	2,2	get increment from op block
	tsy	mentry-*,*	call subroutine
mret	iacx2	3	next op block
	tra	a.h009-*,*	int010
	rem
in6800	null		meterm (meter synchronous message)
mcal2	tra	mret2-*	***see note at mcall
	lda	t.metr,1	get pointer to metering area
	szn	1,2	input or output?
	tnz	in6810-*	output
	iaa	m.nim	input, get correct offset
	ldx3	t.icp,1	and buffer pointer
	tra	in6820-*
in6810	iaa	m.nom	get offset for output metering
	ldx3	t.ocp,1	and buffer pointer
in6820	tsy	a.h014-*,*	mmsg
mret2	iacx2	2	next op block
	tra	a.h009-*,*	int010
	rem
	rem
mentry	ind	0	set to address of appropriate metering routine
	ttls	subroutine to get address of carriage movement table
	rem
getcmt	subr	get
	rem
	ldx2	a.h001-*	(=ctrl) get addr of base of ctrl
	lda	ct.dev,2	to get ptr to device tables
	ada	t.type,1	add in the type of this guy
	iaa	-1	correct for zero offset
	cax2		get ptr to ptr to correct devtbl
	lda	0,2	now have ptr to devtbl
	iaa	dt.cmt	add in offset of cmt
	ora	l.h001-*	(=0,b.0) add in char addressing
	cax2		put into x2
	return	getcmt
	rem
l.h001	zero	0,b.0
l.h002	vfd	o18/tfbkpt
l.h003	oct	004124
l.h004	oct	004000
l.h005	oct	400000
l.h006	oct	377777
a.h001	ind	ctrl
a.h002	ind	brkhit
a.h003	ind	int011
a.h004	ind	int300
a.h005	ind	lctlck
a.h006	ind	denq
a.h007	ind	incall
a.h008	ind	int601
a.h009	ind	int010
a.h010	ind	addnov
a.h011	ind	mincs
a.h012	ind	mincd
a.h013	ind	mupdat
a.h014	ind	mmsg
	ttls	addnov - add the q to the a without causing overflow
	rem
addnov	subr	ano,(i)
	sta	anosva-*	save "a" temporarily
	lda	anosi-*	get indicators
	ora	l.h004-*	=004000, inhibit overflow
	sta	anotmp-*
	ldi	anotmp-*
	stq	anotmp-*	the addend
	lda	anosva-*
	ada	anotmp-*	why we're here
	tov	2	failed
	tra	anoret-*	add ok, return
	iaa	0
	tmi	annovp-*	answer was minus, set to +infinity
	lda	l.h005-*	=400000
	tra	anoret-*
annovp	lda	l.h006-*	=377777
anoret	return	addnov
anotmp	bss	1
anosva	bss	1
	ttls	dcwcnt subroutine counts words in dcwlst op block
*
dcwcnt	subr	dcw
*
*	calculates number of words in dcwlst op block and calls
*	appropriate subroutine to process it
*
maxdcw	equ	6
	rem
	rem
	iacx2	1	point to first subop
	stx2	t.dcwa,1	store starting address
*
dcw010	null		head of word-counting loop
	lda	0,2	get next word
	arl	9	isolate subop code
	cmpa	l.e005-*	(=o777) are all 9 bits on?
	tze	dcw080-*	yes, all through with dcwlst
	arl	6	isolate 3 high-order bits
	icmpa	1	die if less than 1
	tmi	dcw020-*
	icmpa	3	if output, handle specifically
	tze	dcw030-*
	icmpa	maxdcw	check against maximum value
	tmi	2	less is okay
dcw020	null		unrecognizable subop
	die	6
	rem		here if 1, 2, 4, or 5, just go to next word
	iacx2	1
	tra	dcw010-*
*
dcw030	null		output subop, count chars.
	cx2a		switch x2 to 9-bit byte addr.
	ora	l.e001-*	0,b.0
	cax2
dcw040	null
	iacx2	0,b.1	next character
dcw050	null
	lda	0,2,b.0	pick up char.
	cmpa	l.e002-*	=o000477
	tze	dcw070-*	end of output subop
	cmpa	l.e003-*	(=o000400) literal?
	tmi	dcw040-*	yes, get next char.
	era	l.e003-*	else turn off high-order bit
	icmpa	1	check for printer
	tze	dcw040-*	or keyboard addressing
	icmpa	2	and go to next char
	tze	dcw040-*	in either case
*
	icmpa	3	splice in output chain?
	tnz	dcw060-*
	iacx2	0,b.1	if so, next char. must be
	lda	0,2,b.0	"end  f output" or we die
	cmpa	l.e002-*	=o000477
	tze	dcw070-*
	die	7
*
dcw060	null
	icmpa	4	repeat?
	tze	2	it had better be
	die	6
	iacx2	1,b.1	bump x2 by 3 chars
	tra	dcw050-*
*
dcw070	null		end of output subop
	cx2a		restore word addressing to x2
	ana	l.e004-*	=o077777
	cax2
	iacx2	1	go to next word
	tra	dcw010-*
*
dcw080	null		end of dcwlst
	lda	l.e007-*	(o777000)
	ansa	t.dcwl,1	zero t.dcwl but preserve skip count in upper char
	cx2a		calculate dcwlst length
	sba	t.dcwa,1
	orsa	t.dcwl,1	and put it in tib
	lda	t.line,1	get high-order bit of
	arl	9	line number
	tze	dcw090-*
	tsy	ihdcw-*,*	hsla
	tra	dcwbak-*
dcw090	null
	tsy	ildcw-*,*	lsla
*
dcwbak	return	dcwcnt
*
*
ihdcw	ind	hdcw	hsla dcwlst processor
ildcw	ind	ldcw	lsla dcwlst processor
*
l.e001	zero	0,b.0	to switch to char addressing
l.e002	oct	477
l.e003	oct	400
l.e004	oct	77777
l.e005	oct	777
l.e006	oct	514	control string byte - seteom
l.e007	oct	777000
	ttls	subroutines for copying into replay chain
	rem
copybf	subr	cop,(x2)
	rem
	rem		this routine is called to copy an input buffer
	rem		into the replay chain
	rem		inputs:
	rem		    x2 contains virtual pointer to input buffer
	rem		     a contains buffer tally
	rem
	rem		outputs:
	rem		    x3 points to last buffer in replay chain
	rem		     but buffer ptw is restored to its original
	rem		     value
	rem
	iera	-1	negate the tally
	iaa	1
	sta	citly-*	save it
	lda	a.i002-*,*	.crbpe,*
	sta	cspte-*	save "source" page table entry
	ldq	0,2,b.0	get first character now (x2 will be
	rem		temporarily invalid)
	rem
	szn	t.rcp,1	have we started building the chain yet?
	tnz	cop010-*	yes
	tsy	cgetbf-*	no, get a buffer to start it with
	rem
	stz	cpos-*	column position starts at zero
	ila	10	first tab stop is 10
	sta	ctab-*
	tra	cop030-*
	rem
cop010	ldx3	clchar-*	get pointer to next place to store char
	rem
cop030	cmpq	tabchr-*	is it a tab?
	tnz	cop070-*	no
	lda	t.flg,1	yes, are we in tab echo?
	cana	l.i003-*	=tftbec
	tnz	cop050-*	yes
	tsy	cpchar-*	no, put tab in buffer
	ldq	delchr-*	now we'll put in delays for the real tab
	ila	3	three of 'em
	rem
cop040	tsy	cpchar-*	put one in replay buffer
	iaa	-1
	tnz	cop040-*	do another if not finished
	rem
	tra	cop090-*	ok, done with this char
	rem
cop050	lda	ctab-*	we're in tab echo, how many spaces?
	sba	cpos-*	this many
	ilq	space
cop060	tsy	cpchar-*	put it in
	iaa	-1	more?
	tnz	cop060-*	yes
	rem
	lda	ctab-*	update column position
	sta	cpos-*
	iaa	10
	sta	ctab-*	and next tab stop
	tra	cop090-*
	rem
cop070	tsy	cpchar-*	not a tab, store it
	lda	t.flg,1	tab echo?
	cana	l.i003-*	=tftbec
	tze	cop090-*
	lda	cpos-*	yes, update position
	cmpq	bschar-*	which way did we go?
	tnz	cop080-*
	iaa	-1	backspace
	tra	2
cop080	iaa	1	forward
	sta	cpos-*
	cmpa	ctab-*	did we reach next tab stop?
	tmi	cop090-*
	ila	10	yes, update tab stop
	asa	ctab-*
	rem
cop090	lda	cspte-*	restore source pte
	sta	a.i002-*,*	.crbpe,*
	iacx2	0,b.1	bump input pointer
	ldq	0,2,b.0	get next character
	aos	citly-*	have we done it all?
	tnz	cop030-*	no, process next char
	rem
	stx3	clchar-*	done, save character position in buffer
	ldx3	clast-*	return buffer pointer for gtinpt
	return	copybf
	eject
cpchar	subr	cpc,(a,q,x2)
	rem
	rem		this subroutine stores the character
	rem		passed in the q into the replay chain
	rem		pointed into by x3, updating x3 as appropriate
	rem
	lda	ctpte-*	use target pte
	sta	a.i002-*,*	.crbpe,*
	rem
	szn	cotly-*	is there room?
	tnz	cpc010-*	yes
	tsy	cgetbf-*	no, get a buffer
	rem		x3, cotly, and clast are also updated now
cpc010	stq	0,3,b.0
	iacx3	0,b.1
	aos	cotly-*
	ldx2	clast-*	get buffer pointer
	aos	bf.tly,2	keep tally accurate
	return	cpchar
	eject
cgetbf	subr	cge,(q,x2)
	rem
	rem		this subroutine allocates a buffer
	rem		for adding to the replay chain
	rem		address at which first char is to be stored
	rem		is returned in x3
	rem
	ilq	bufsiz
	tsy	a.i001-*,*	getbfh
	die	18	bad news if we couldn't get one
	rem
	ilq	-bufnch	initialize negative tally
	stq	cotly-*
	ldq	a.i002-*,*	(.crbpe,*) hang on to pte
	rem		(set by getbfh)
	rem
	szn	t.rcp,1	is there a chain already?
	tnz	cge010-*	yes, ok
	sta	t.rcp,1	no, this is the beginning of it
	tra	cge020-*
cge010	ldx2	ctpte-*	use old target pte
	stx2	a.i002-*,*	.crbpe,*
	sta	clast-*,*	set forward pointer in preceding buffer
	stq	a.i002-*,*	(.crbpe,*) restore latest pte
cge020	stx3	clast-*	this is last one now
	stq	ctpte-*	and this is corresponding pte
	rem
	cx3a		point to beginning of data
	ada	l.i001-*	=bf.dta,b.0
	cax3
	return	cgetbf
	rem
	rem
a.i001	ind	getbfh
a.i002	ind	.crbpe,*
	rem
l.i001	zero	bf.dta,b.0
*l.i002		unused
l.i003	vfd	18/tftbec
	rem
citly	bss	1	residual source tally (negative)
cotly	bss	1	residual target tally (negative)
cpos	bss	1	current column position
ctab	bss	1	next tab stop
clast	bss	1	pointer to last buffer in replay chain
clchar	bss	1	pointer to next place for replay character
cspte	bss	1	source page table entry
ctpte	bss	1	target page table entry
	rem
tabchr	bss	1	tab character for this terminal
delchr	bss	1	pad character
bschar	bss	1	backspace
	ttls	scanop subroutine processes both inscan and outscn block
*
scanop	subr	sca
*
	sta	isctyp-*,*	set scan type
	stx2	iscsx2-*,*	save x2 value during scan
	lda	a.a014-*,*	sccbpe
	sta	a.a012-*,*	(.crbpe,*) get previous buffer pte so that
	rem		saved value of pbufp will work
	lda	1,2	get control string address
	ora	l.u001-*	0,b.0
	sta	iscstr-*,*	save control string byte address
sca000	null		get next byte from control string
	tsy	iscnxt-*,*	via subroutine
	tra	a.a004-*,*	(sca260) end of control string
	tra	sca004-*	control byte = 5xx
	tra	sca001-*	error - literal in control string
	rem
sca004	ana	l.u002-*	=o77 - isolate scan subop
	tnz	2	zero not allowed
	die	15	error in control string
	rem
	icmpa	sca003	check for max subop
	tmi	2
	die	15	error in control string
	cax3
	adcx3	sca002-*	add address of jump table
	tra	0,3*	go to subop routine
sca002	zero	*	address of jump table
*		                        subop jump table        
	ind	sca010	match for equal
	ind	sca020	search for char
	ind	sca030	ignore
	ind	sca040	start bcc computation
	ind	sca050	find end of chain
	ind	sca060	compare bcc
	ind	sca070	compare with mask
	ind	sca080	rescan
	ind	sca090	start lrc computation
	ind	sca100	insert lrc
	ind	sca110	compare lrc
	ind	sca120	set last buffer in message flag
	ind	sca130	replace current char
	ind	sca140	compare with list
	ind	sca150	move byte
	ind	sca160	move byte with mask
	ind	sca170	count chars
	ind	sca180	search for match on either of two values
	ind	sca190	turn on bits in char
	ind	sca200	turn off bits in char
	ind	sca210	check sync termination char
	ind	sca220	move last two chars in message to tib extension
	ind	sca230	skip to next char, update block check
sca003	equ	*-sca002	defines end of jump table
	rem
sca001	die	15	error in control string
	eject
sca010	null		match for equal
	tsy	ischkc-*,*	get compare value
	die	15	error in control string
	sta	scwrk1-*	save byte for compare
	tsy	isgtch-*,*	pick up char.
	tra	a.a005-*,*	(=sca300) no char, forget it
*
	cmpa	scwrk1-*	see if it's the match char
	tnz	a.a005-*,*	(=sca300) no
	tra	sca000-*	yes
*
*
*
*
sca020	null		search for char
	tsy	ischkc-*,*	get search value
	die	15	error in control string
	sta	scwrk1-*	save for compare
	tsy	isgtch-*,*	get char, without bumping pointer
	tra	a.a005-*,*	(=sca300) if any
sca022	null
	szn	a.a009-*,*	(=scbccf) are we in process of block check
	tze	2
	ersa	a.a008-*,*	(=scbcc) yes, do it
	cmpa	scwrk1-*	check against search char.
	tze	sca000-*	got it
	szn	a.a007-*,*	(=sccntf) are we in process of char count
	tze	2	no
	tsy	a.a006-*,*	(=scount) go ahead and count this char
	tsy	iscnex-*,*	no match, bump pointer
	tra	a.a005-*,*	(=sca300) if not possible, fail
	tra	sca022-*	else, go look at char
*
*
*
sca230	null		skip char, but update block check
	szn	a.a009-*,*	(=scbccf) block check in progress ?
	tze	sca030-*	no
	tsy	isgtch-*,*	get current char
	tra	a.a005-*,*	(=sca300) end of data
	ersa	a.a008-*,*	(=scbcc) update block check
	rem
sca030	null		ignore
	tsy	iscnex-*,*	skip over next char.
	tra	sca032-*	trying to skip past end, add more room
sca031	szn	a.a007-*,*	(=sccntf) are we in process of char count
	tze	2	no
	tsy	a.a006-*,*	(=scount) go ahead and count this char
	tra	sca000-*
	rem
sca032	szn	isctyp-*,*	check scan type
	tze	a.a005-*,*	(=sca300) inscan, fail can't add
	rem
	ldx3	a.a001-*,*	(=pbufp)
	lda	bf.tly,3	get buffer tally
	ana	l.k001-*	(=buftmk) leave only tally
	icmpa	bufnch	compare to max tally
	tmi	sca033-*	ok, will fit here
	rem
	lda	bf.flg,3	get buffer flags
	ana	l.k002-*	(=bfflst) save last flag
	sta	scasva-*
	iera	-1	invert it
	ansa	bf.flg,3	make sure it's off
	rem
	cx3a		we will save its absolute address
	tsy	a.a011-*,*	cvabs
	sta	scaprv-*
	lda	bf.nxt,3
	sta	scasvn-*	save forward pointer from current last buffer
	ilq	bufsiz	get a new one
	tsy	a.i001-*,*	=getbuf
	tra	a.a005-*,*	=sca300, scan fails
	sta	scacur-*	save absolute address of new buffer
	lda	scasvn-*	forward pointer from old last pointer
	sta	bf.nxt,3	chain after current buffer
	ldq	a.a012-*,*	(.crbpe,*) hang on to pte (protect from setbpt)
	lda	scaprv-*	get previous buffer back
	tsy	a.a013-*,*	setbpt
	cax2
	lda	scacur-*
	sta	bf.nxt,2	make old last buffer point at current
	stq	a.a012-*,*	(.crbpe,*) restore pte
	rem
	lda	scasva-*	get saved a
	sta	bf.flg,3	set last flag same as before
	rem
	ila	1
	sta	a.a002-*,*	(=ptally) and set to one
	cx3a		get ptr to buffer
	iaa	bf.dta	add offset to data
	ora	l.k003-*	point to data
	sta	a.a003-*,*	(=pdatp) store
	stx3	a.a001-*,*	(=pbufp) save buffer addr too
	rem
	aos	bf.tly,3	bump tally up one
	tra	sca031-*
	rem
sca033	aos	bf.tly,3
	tsy	iscnex-*,*	now bump pointers, we made room
	die	15	die if room not found
	tra	sca031-*
	rem
l.k001	vfd	18/buftmk
l.k002	vfd	18/bfflst
l.k003	zero	0,b.0	for character addressing
a.a001	ind	pbufp
a.a002	ind	ptally
a.a003	ind	pdatp
a.a004	ind	sca260
a.a005	ind	sca300
a.a006	ind	scount
a.a007	ind	sccntf
a.a008	ind	scbcc
a.a009	ind	scbccf
a.a010	ind	scend
a.a011	ind	cvabs
a.a012	ind	.crbpe,*
a.a013	ind	setbpt
a.a014	ind	sccbpe
	rem
scaprv	bss	1
scacur	bss	1
scasvn	bss	1
scasva	bss	1
*
*
*
sca040	null		start bcc computation
sca090	null		start lrc computation
	aos	a.u003-*,*	(scbccf) turn flag on
	stz	a.u004-*,*	(scbcc) initialize block check char
	tra	sca000-*	all done
*
scwrk1	bss	1	work area
*
*
*
sca050	null		find end of chain
	tsy	a.a010-*,*	(scend)
	tra	sca300-*	wasn't any chain
	tra	sca000-*	ok, get next byte
*
*
*
sca060	null		compare bcc
sca110	null		compare lrc
	szn	a.u003-*,*	(scbccf) make sure we were doing it
	tnz	2
	die	10
*
	stz	a.u003-*,*	(scbccf) turn off flag
	tsy	a.u002-*,*	(=sgtchr) get next char
	tra	sca300-*	if any
*
	cmpa	a.u004-*,*	(scbcc) is block check correct?
	tnz	sca300-*	no
	tra	sca000-*	yes
*
*
*
sca070	null		compare with mask
	tsy	a.u001-*,*	(=schkcc) get compare value
	die	15	error in control string
	sta	scwrk2-*	save compare value
	tsy	a.u001-*,*	(=schkcc) get mask value
	die	15	error in control string
	sta	scwrk3-*	save mask value
	ansa	scwrk2-*	mask compare value
*
	tsy	a.u002-*,*	(=sgtchr) get next char
	tra	sca300-*	if we can
	ana	scwrk3-*	apply the mask
	cmpa	scwrk2-*	match?
	tnz	sca300-*	no, fail
	tra	sca000-*
*
l.u001	zero	0,b.0
l.u002	oct	77
	rem
a.u001	ind	schkcc
a.u002	ind	sgtchr
a.u003	ind	scbccf
a.u004	ind	scbcc
	rem
scwrk2	bss	1	work area
scwrk3	bss	1
scwrk4	bss	1
	rem
ipbufp	ind	pbufp
iscstr	ind	sccstr
iscnxt	ind	sccnxt
iscsx2	ind	scsvx2
isctyp	ind	scntyp
ischkc	ind	schkcc
isgtch	ind	sgtchr
iscnex	ind	scnext
*
*
*
sca080	null		rescan - initialize pointers and flags
	tsy	scinit-*	call scan init subroutine
	tra	sca000-*
*
*
*
sca100	null		insert lrc
	rem
	szn	scbccf-*	were we doing bcc?
	tnz	2	ok
	die	15	no, kill it
	rem
	stz	scbccf-*	clear flag, used bcc value
	tsy	isgtch-*,*	get addr of byte
	die	15	error in control string
	rem
	lda	scbcc-*	get bcc value
	sta	0,3,b.0	put into msg
	tra	sca000-*
*
*
*
sca120	null		set last buffer in message flag
	ldx3	a.a001-*,*	(=pbufp) get addr of current buffer
	lda	l.s008-*	(=bfflst) get last buffer in message flag
	orsa	bf.flg,3	turn it on
	tra	sca000-*
*
*
*
sca130	null		replace current char
	tsy	isgtch-*,*	get byte address of next char in chain
	tra	sca300-*	none
	tsy	ischkc-*,*	get replace value
	die	15	error in control string
	sta	0,3,b.0	replace current char
	tra	sca000-*
*
*
*
sca140	null		compare with list
	tsy	sgtchr-*	get next char in chain
	tra	sca300-*	none - failure
	sta	scwrk3-*	save for compare
sca144	tsy	a.s003-*,*	(=sccnxt) get value from control string
	tra	sca300-*	end of control string - failure
	tra	sca300-*	5xx - failure
	tsy	a.s002-*,*	(=adbyte) check for 46x
	tra	sca148-*	not 46x
	lda	0,3,b.0	get tib byte value
sca148	cmpa	scwrk3-*	match?
	tze	sca146-*	yes
	tra	sca144-*	keep looking
sca146	tsy	a.s003-*,*	(=sccnxt) just pass by values
	tra	sca260-*	end of control string
	tra	sca004-*	5xx
	tra	sca146-*
*
*
*
sca150	null		move byte
	tsy	a.s003-*,*	(=sccnxt) get 46x value
	tra	1
sca152	die	15	error - must be 46x
	tsy	a.s002-*,*	(=adbyte) get byte address
	tra	sca152-*	not 46x
	stx3	scwrk2-*	save byte address
	ila	-1
sca154	sta	scwrk3-*	prime mask area
	tsy	sgtchr-*	get next char and address
	tra	sca300-*	none
	ana	scwrk3-*	mask char
	ldx3	scwrk2-*	get byte address
	sta	0,3,b.0	place in tib
	tra	sca000-*
*
*
*
sca160	null		move byte with mask
	tsy	iscnxt-*,*	get 46x value
	tra	1
sca162	die	15	error - must be 46x
	tsy	a.s002-*,*	(=adbyte) get byte address
	tra	sca162-*	not 46x
	stx3	scwrk2-*	save byte address
	tsy	schkcc-*	get mask value
	tra	sca162-*	error - in control string
	tra	sca154-*	same as move byte
*
*
*
sca170	null		count chars
	tsy	iscnxt-*,*	get 46x value
	tra	1
sca172	die	15	error - must be 46x
	tsy	a.s002-*,*	(=adbyte) get byte address
	tra	sca172-*	not 46x
	stx3	sccnta-*	save byte address for count accumulation
	stz	0,3,b.0	zero count in tib
	aos	sccntf-*	set count flag
	tra	sca000-*
*
*
*
sca180	null		search for match on either of two values
	tsy	schkcc-*	get first search value
	die	15	error in control string
	sta	scwrk3-*	save for compare
	tsy	schkcc-*	get second search value
	die	15
	sta	scwrk4-*
	tsy	sgtchr-*	get char, w/o bumping ptr
	tra	sca300-*	fail if none
sca182	null
	szn	scbccf-*	are we in process of block check
	tze	2
	ersa	scbcc-*	yes, do it
	cmpa	scwrk3-*	check vs first value
	tze	a.s001-*,*	(sca000) got it
	cmpa	scwrk4-*	check vs second value
	tze	a.s001-*,*	(sca000) got it
	szn	sccntf-*	are we in process of char count
	tze	2
	tsy	scount-*	go ahead and count this char
	tsy	iscnex-*,*	no match, bump ptr
	tra	sca300-*	fail, no more chars
	tra	sca182-*	else, go look at char
*
*
*
sca190	null		turn on bits in char
	tsy	schkcc-*	get bit pattern
	die	15	error - in control string
	sta	scwrk2-*	save
	tsy	sgtchr-*	get next char address
	tra	sca300-*	no next char
	lda	scwrk2-*	get bit pattern
	orsa	0,3,b.0	turn on bits
	tra	a.s001-*,*	(=sca000) done
*
*
*
sca200	null		turn off bits in char
	tsy	schkcc-*	get bit pattern
	die	15	error in control string
	sta	scwrk2-*	save
	tsy	sgtchr-*	get next char address
	tra	sca300-*	no next char
	lda	scwrk2-*	get bit pattern
	orsa	0,3,b.0	turn bits on
	ersa	0,3,b.0	now really turn them off
	tra	a.s001-*,*	(=sca000)
*
*
*
sca210	tsy	schkcc-*	get char from control string
	die	15	error in control string
	sta	scwrk4-*	save for compare
	stz	sca216-*	reset flag
	rem
sca215	ldx3	a.s007-*,*	(pbufp) get ptr to head of list
	stz	sccbuf-*	zero prev buf ptr
sca211	lda	bf.flg,3	get flag bits
	cana	l.s008-*	(=bfflst) last buffer in msg?
	tnz	sca212-*	yes, use this buffer
	rem
	szn	bf.nxt,3	more in chain?
	tze	sca212-*	no, use this one
	rem
	cx3a		get absolute address
	tsy	a.s005-*,*	cvabs
	sta	sccbuf-*	save ptr to this buffer
	lda	bf.nxt,3	bump to next
	tsy	a.s004-*,*	setbpt
	cax3
	tra	sca211-*
	rem
sca212	stx3	a.s007-*,*	(pbufp) remember where we are
	cx3a		copy to a
	iaa	bf.dta	point at data
	ora	l.s002-*	with char addressing
	sta	a.s008-*,*	(pdatp) save
	rem
	lda	bf.tly,3	get tally in buffer
	ana	l.s001-*	(=buftmk) only tally
	icmpa	2	at least two chars in this buffer?
	tmi	sca214-*	no, must use prev buffer
	rem
	iaa	-2	backup to look at term char
	lrl	1	divide by two (save bit)
	asa	pdatp-*	add into ptr
	ldx3	pdatp-*	get it
	rem
	lls	1	get bit back
	icana	1	on?
	tze	sca213-*	ok as is
	rem
	iacx3	0,b.1	bump ptr to odd char
	stx3	pdatp-*	save ptr always
sca213	szn	sca216-*	check flag
	tnz	sca224-*	move 2 chars
	lda	0,3,b.0	get the supposed term char
	cmpa	scwrk4-*	is this it?
	tze	a.s001-*,*	(=sca000) yes, we got it...
	rem
	tra	sca300-*	fail
	rem
	rem	since we know bcc was in last buffer, etx must be
	rem	last char in this buffer.
	rem
sca214	lda	sccbuf-*	get ptr to next-to-last buffer
	tze	sca300-*	fail - not two chars in message
	tsy	a.s004-*,*	setbpt
	sta	sccntl-*	save virtual address of buffer
	iaa	bufsiz-1	point to last word
	ada	l.s009-*	(=0,b.1) and last char
	cax3		copy to index reg
	szn	sca216-*	check flag
	tnz	sca226-*	move 2 chars
	ldq	0,3,b.0	else get character for comparison
	ldx3	sccntl-*	get address of buffer
	lda	bf.nxt,3	get address of last buffer again
	tsy	a.s004-*,*	(setbpt) restore pte
	cmpq	scwrk4-*	now test the character
	tze	a.s001-*,*	(=sca000) success
	tra	sca300-*	failure
*
sca216	bss	1	flag for move last two chars to tib
*
*
*
sca220	null		move last two chars to tib extension
	stz	sca216-*	reset flag
	tsy	sccnxt-*	get 46x value
	tra	1	not 46x
sca222	die	15	error in control string
	tsy	adbyte-*	get byte address
	tra	sca222-*	not 46x
	stx3	scwrk3-*	save first char addr
	tsy	sccnxt-*	get second 46x value
	tra	sca222-*	not 46x
	tra	sca222-*	not 46x
	tsy	adbyte-*	get byte addr
	tra	sca222-*	not 46x
	stx3	scwrk4-*	save second char addr
	aos	sca216-*	set flag
	tra	sca215-*	do search for last chars
sca224	null		return from search
	lda	0,3,b.0	get second to last char
	iacx3	0,b.1	bump to next char
	stx3	pdatp-*	always save current ptr
	ldq	0,3,b.0	get last char
	tra	sca227-*	store into tib ext
sca226	null		return - last two chars split between buffers
	ldx2	0,3,b.0	get second to last char
	ldx3	sccntl-*	get pointer to beginning of next-to-last
	lda	bf.nxt,3	get last
	tsy	a.s004-*,*	(setbpt) restore pte
	cx2a		get character into a
	ldx3	pdatp-*	get data ptr - last buffer
	ldq	0,3,b.0	get last char
sca227	null		store two chars into tib ext
	ldx3	scwrk3-*	place to store next to last
	sta	0,3,b.0	into tib ext
	ldx3	scwrk4-*	and last char
	stq	0,3,b.0	into tib ext, too
	tra	a.s001-*,*	(=sca000)done
*
*
*
sca260	null		scan was a success
	ldx2	scsvx2-*	get scan block address
	iacx2	3	go to next block
scabak	null
	lda	a.s006-*,*	.crbpe,*
	sta	sccbpe-*	save pte in case of another scan
	return	scanop
*
*
*
sca300	null		general scan failure
	ldx2	scsvx2-*	get scan block address
	ldx2	2,2	get branch point
	tra	scabak-*
*
*
l.s001	vfd	18/buftmk	buffer tally mask
l.s002	zero	0,b.0	for char addressing
l.s003	oct	77777	for word addressing
l.s004	oct	77	mask for 5xx values
l.s005	oct	777	end of control string designator
l.s006	oct	700	5xx mask
l.s007	oct	500	test value
l.s008	vfd	18/bfflst	last buffer in message flag
l.s009	ind	0,b.1
	rem
a.s001	ind	sca000
a.s002	ind	adbyte
a.s003	ind	sccnxt
a.s004	ind	setbpt
a.s005	ind	cvabs
a.s006	ind	.crbpe,*
a.s007	ind	pbufp
a.s008	ind	pdatp
	rem
sccbpe	bss	1	safe store for pte
scbcc	bss	1	cumulative block check char
scbccf	bss	1	block check in progress flag
tmask	bss	1	place to save masked char.
scntyp	bss	1	input or output scan indicator
	rem		=0, input scan
	rem		=1, output scan
scsvx2	bss	1	save area for scan block address
sccstr	bss	1	control string byte address
sccnta	bss	1	byte address - char count accumulation
sccntf	bss	1	char count in progress flag
sccbuf	bss	1	absolute ptr to next-to-last buffer
sccntl	bss	1	virtual pointer to same
	ttls	utilities for scan
*
*	scount increments tib extension byte designated by count scan subop
*	max accumulated count = 511
*
scount	subr	sco,(a,x3)
	ldx3	sccnta-*	get accumulation byte address
	lda	0,3,b.0	get accumulation byte
	iaa	1	increment it
	ana	l.s005-*	=o777
	tze	2	overflow
	sta	0,3,b.0	place it back in tib
	return	scount
*
*	scinit subroutine initializes scan pointers
*
scinit	subr	sci
	lda	t.icp,1	get input chain pointer
	szn	scntyp-*	check scan type - input or output
	tze	sci010-*	input
	lda	t.ocp,1	get output chain pointer
sci010	null
	tsy	a.s004-*,*	setbpt
	sta	pbufp-*	save virtual address
	szn	pbufp-*
	tze	scibak-*	no chain, forget it
	stz	ptally-*	zero out scan tallies
	aos	ptally-*	pointing at char now
	iaa	bf.dta	point to data
	ora	l.s002-*	0,b.0
	sta	pdatp-*	save data pointers
scibak	null
	stz	scbccf-*	zero block check flag
	stz	sccntf-*	zero char count in progress flag
	return	scinit
*
*	sgtchr  uses pointers to find current char and return it in a
*		it does not advance the pointers        
*		output - return1 = no more chars        
*		         return2 = current char in a        
*
sgtchr	subr	sgt
	szn	pbufp-*	check buffer pointer
	tze	sgtbak-*	none exists
	rem
	ldx3	pdatp-*
	lda	0,3,b.0
	aos	sgtchr-*	did it
	rem
sgtbak	return	sgtchr
*
*	schkcc gets next byte from control string and checks for 777,5xx values
*	if byte = 46x then its tib value is returned in a
*	output - return1 = byte in a = 777 or 5xx
*		return2 = byte in a        
*
schkcc	subr	sch,(x3)
	tsy	sccnxt-*	get control string byte
	tra	schbak-*	777
	tra	schbak-*	5xx
	tsy	adbyte-*	check for 46x
	tra	sch020-*	not 46x
	lda	0,3,b.0	get byte value
sch020	aos	schkcc-*	return2
schbak	null
	return	schkcc
*
*	scnext bumps character pointers
*	returns to location after call if no more chars,
*	otherwise puts char in a and returns two locations past call
*
scnext	subr	scn,(x3)
*
	ldx3	pbufp-*	any buffer at all?
	tze	scnbak-*	no, done
	rem
	lda	bf.tly,3	get the buffer tally
	ana	l.s001-*	(=buftmk) only tally
	cmpa	ptally-*	any chars left to look at?
	tmi	2	no, over the limit now
	tnz	scn020-*	yes, process
	rem
	lda	bf.flg,3	get flag bits
	cana	l.s008-*	(=bfflst) last buffer in msg?
	tnz	scnbak-*	yes, done
	rem
	lda	bf.nxt,3	get fwd ptr
	tze	scnbak-*	none, give up
	rem
	tsy	a.s004-*,*	setbpt
	sta	pbufp-*	new buffer
	iaa	bf.dta	nake ptr to data
	ora	l.s002-*	add in char addressing
	sta	pdatp-*	save ptr
	stz	ptally-*
	cax3		copy ptr to x3
	tra	scn030-*	finish up
	rem
scn020	ldx3	pdatp-*	load ptr to char
	iacx3	0,b.1	bump it
	stx3	pdatp-*	save
scn030	aos	ptally-*	bump tally
	lda	0,3,b.0	load char
	rem
	aos	scnext-*	indicate good bump
scnbak	return	scnext
*
*	sccnxt places next byte from scan control string into a
*	output - return1 = end of control string - byte in a = 777
*		return2 = byte in a = 5xx        
*		return3 = byte in a = xxx        
*
sccnxt	subr	scc,(x2)
	ldx2	sccstr-*	get control string byte address
	lda	0,2,b.0	get control string byte
	cmpa	l.s005-*	=o777
	tze	sccbak-*	end of control string
	iacx2	0,b.1	advance to next byte
	stx2	sccstr-*	save
	caq
	ana	l.s006-*	=o700
	cmpa	l.s007-*	=o500 - scan subop designator
	tze	scc010-*
	aos	sccnxt-*	return 3
scc010	aos	sccnxt-*	return 2
	cqa		retrieve control string byte
sccbak	return	sccnxt
*
*
*	scend implements the end-of-chain subop, setting
*	the pointers to the last character in the chain
*	output - return1 = no chain
*		return2 = found it
*
scend	subr	sce
	ldx3	pbufp-*	get buffer pointer
	tze	scebak-*	fail if no chain
sce010	lda	bf.flg,3	see if this is last one
	cana	l.t006-*	bfflst
	tnz	sce020-*	yes it is
	szn	bf.nxt,3	not marked as such, is there another?
	tze	sce020-*	no, use this one
	lda	bf.nxt,3	yes, on to next
	tsy	a.s004-*,*	setbpt
	cax3
	tra	sce010-*
sce020	null
	stx3	pbufp-*	this is current one now 
	lda	bf.tly,3	get tally
	ana	l.t007-*	buftmk
	sta	ptally-*
	rem
	iaa	-1	less one for last char
	lrl	1	divide by two to get word offset
	ada	pbufp-*	make a pointer out of it
	ada	l.t008-*	bf.dta,b.0
	cax3		put into x3 for now
	lls	1	get low order bit back
	icana	1	is low order bit on?
	tze	2	nope, ok
	iacx3	0,b.1	bump by one char
	stx3	pdatp-*
	aos	scend-*	bump return pointer
scebak	return	scend
*
*
*
	even
	rem		permanent scan pointers
pbufp	bss	1	virtual address of current buffer
ptally	bss	1
pdatp	bss	1	virtual address of current character
*
*	subroutine to form an address in q of a byte in tib extension
*	input - a = char value from scan control string
*	output - return1 = char value not 46x
*		return2 = x3 contains byte address        
*
adbyte	subr	adb,(a)
	caq		save input value
	ana	l.t001-*	=o760 - check for 46x
	cmpa	l.t002-*	=o460
	tze	adb010-*	ok - form byte address
	tra	adbbak-*	input not 46x
adb010	ldx3	t.elnk,1	get tib extension address
	tnz	2	one exists
adb020	die	14
	lda	0,3	get length
	als	1	times 2 = char count
	sta	adb100-*
	cqa
	ana	l.t004-*	=o17 - isolate byte designator
	cmpa	adb100-*	vs max + 1 byte position
	tmi	2	ok - within range
	tra	adb020-*
	caq
	cx3a
	ora	l.t005-*	=0,b.1 - make into byte address
	cax3
adb030	iacx3	0,b.1	advance address - one byte
	iaq	-1	decrement byte position
	tmi	adb040-*	all done
	tra	adb030-*
adb040	null
	aos	adbyte-*	advance return point
adbbak	return	adbyte
adb100	bss	1	work area
	rem
	rem
l.t001	oct	760	mask
l.t002	oct	460	byte position designator
l.t003	oct	77	sub-buffer tally mask
l.t004	oct	17	byte position   mask
l.t005	zero	0,b.1	address advance value
l.t006	vfd	18/bfflst
l.t007	vfd	18/buftmk
l.t008	zero	bf.dta,b.0
l.t009	zero	0,b.0
l.t010	oct	514	seteom
*
* Utility to build a message
*
bldutl	subr	bld
	ilq	bufsiz
	tsy	a.m003-*,*	(=getbfh) get a bufsiz buffer
	tra	bldret-*	no buffers available
	sta	bld099-*	save absolute
	stx3	bld092-*	and virtual address
	rem
	cx3a
	ada	l.t008-*	(=bf.dta,b.0) point to data
	sta	bld096-*	save
	rem
	lda	1,2	get control string address
	ora	l.t009-*	(=0,b.0)
	sta	a.m001-*,*	(=sccstr) save for sccnxt subroutine
	rem
	ila	-bufnch	max number chars in buffer
	sta	bld098-*	save for count down
	stz	bld090-*	zero tally count
bld010	tsy	a.m002-*,*	(=sccnxt) get next byte from control string
	tra	bld040-*	end of control string
	tra	bld030-*	control byte = 5xx
	tsy	adbyte-*	literal or tib byte?
	tra	bld020-*	must be a literal, store it
	lda	0,3,b.0	get the char from the tib
bld020	ldx3	bld096-*	get ptr to data in buffer
	sta	0,3,b.0	store char in buffer
	iacx3	0,b.1	bump ptr
	stx3	bld096-*
	rem
	aos	bld090-*	bump tally
	aos	bld098-*	decrement max tally
	tze	bld050-*	control string too long
	tra	bld010-*	ok, get next byte
	rem
bld030	cmpa	l.t010-*	(=o514) - check for seteom
	tnz	bld050-*	error - not seteom
	rem
	ldx3	bld092-*	get buffer address
	lda	l.t006-*	(=bfflst) get last buffer in message flag
	orsa	bf.flg,3	set on in buffer
	tra	bld010-*
	rem
bld040	ldx3	bld092-*	get buffer address
	lda	bld090-*	get tally count
	tze	bld050-*	no chars placed in buffer
	orsa	bf.tly,3	place tally in buffer
	aos	bldutl-*	successful return
bldret	return	bldutl
	rem
bld050	lda	bld099-*	get buffer address
	ilq	0
	tsy	a.m004-*,*	(=frebfh) return buffer - error or not used
	tra	bldret-*
	rem
bld090	bss	1	tally count
bld092	bss	1	save area - virtual buffer address
bld096	bss	1	save area - data pointer
bld098	bss	1	max tally count
bld099	bss	1	absolute buffer address
	rem
a.m001	ind	sccstr
a.m002	ind	sccnxt
a.m003	ind	getbfh
a.m004	ind	frebfh
*
intend	null
	end
