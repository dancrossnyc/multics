/*  START OF:       mbuild_data_.incl.pl1                     *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

          
/****^  HISTORY COMMENTS:
  1) change(2019-08-17,GDixon), approve(2019-10-25,MCR10069),
     audit(2020-01-20,Swenson), install(2020-01-20,MR12.6g-0035):
     Major and minor data structures used by the mbuild subsystem.
  2) change(2021-02-16,GDixon), approve(2021-02-22,MCR10086),
     audit(2021-03-17,Swenson), install(2021-03-17,MR12.6g-0051):
      A) Add constants shared by several mbuild programs:
               not_stored_in_library     no_containing_archive
               no_library_operation      unknown_archive_name
                                                   END HISTORY COMMENTS */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
/*                                                                                                */
/* Data structures used by the mbuild command, and its supporting subroutines.                    */
/*                                                                                                */
/* NOTE: The Tlist_base and Tlist_data sub-structures are declared in mbuild_Tlist_dcls_.incl.pl1 */
/*                                                                                                */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* ------------------------------------------------------------------------------------------

BNF for Build Script Language (used in MCRnnnnn.mb segs):

    -  { <alt-1> | <alt-2> | <alt-3> } identifies alternatives.  Choose only one of them.
       { <alt-1> | <alt-2> | <alt-3> }... says choose one or more of the alternatives. 

    -  [....] says stuff is optional.  [....]... says choose zero or more of this item.

    -  User commenting may or may not be supported in the actual build script files.  
       Such comments would have to be parsed/stored by read operation to be preserved for
       future save operations; and mbuild would have to learn how to display them.

   ----------                                                                      ----------

<script-contents>       ::= <description-group> [<mb-script-item>]... <installable-item>... 

<description-group>     ::= <description-stmt> <install-dir-stmt> | <install-dir-stmt>
 <description-stmt>     ::= Description: <description-line>... 
 <install-dir-stmt>     ::= Installation_directory: <absolute-pathname> ;


<installable-item>      ::= {<bound-object-group>|<unbound-object-group>|
                              <info-seg-group>|<include-file-group>|<unanalyzed-seg-group>}

<bound-object-group>    ::= <bound-object-stmt> [<bindfile-stmt>] [<archive-source-group>]... 
 <archive-source-group> ::  {<source-stmt>|<archive-stmt> <source-stmt>...}

<unbound-object-group>  ::= <unbound-object-stmt> <source-stmt> [<naming-group>]...

<include-file-group>    ::= <include-file-stmt> ;

<info-seg-group>        ::= <info-seg-stmt> [<naming-group>]...

<unanalyzed-seg-group>  ::= <unanalyzed-seg-stmt> [<naming-group>]... ;


<bound-object-stmt>     ::= Bound_obj: <bound-object-name> <library> <bound-obj-operation> ;
  <library>             ::=  IN: <library-name>
  <bound-obj-operation> ::=  {ADD|UPDATE|DELETE}

<bindfile-stmt>         ::=  bindfile: <bind-file-name> [<library>] <operation> ;
  <operation>           ::=  {ADD|REPLACE|DELETE}

<archive-stmt>          ::=  source_arch:  <bound-source-archive-name> [<library>] <bound-obj-operation> ;

<source-stmt>           ::=  source:   <source-seg-name> [<library>] <operation> [<compiler-group>]
  <compiler-group>      ::=   <compiler> [<compile-option>]... ; 
  <compiler>            ::=   compiler: <compiler-name>
  <compile-option>      ::=   {<control-arg>|<control-arg> <value-word>}


<unbound-object-stmt>   ::= Unbound_obj: <object-seg-primary-name> <library> <operation> ;

<include-file-stmt>     ::= Include: <include-file-name> [<library>] <operation>;

<info-seg-stmt>         ::= Info: <info-seg-primary-name> <library> <operation> ;

<unanalyzed-seg-stmt>   ::= Seg(<seg-type>): <seg-name> <operation> ;


<naming-group>          ::= <add_name-stmt>|<delete_name-stmt>
 <add_name-stmt>        ::=  add_name: <add-seg-name>... ;
 <delete_name-stmt>     ::=  delete_name: <del-seg-name>... ;


<mb-script-item>        ::= {<mb-script-stmt>|<mb-exec_com_stmt>|<mb-io-stmt>|<mb-log-stmt>}

 <mb-script-stmt>       ::= Build_script: <mb-seg-name>.mb ;

 <mb-exec_com-stmt>     ::= Build_exec_com: <mb-seg-name>.mb.ec ;

 <mb-io-stmt>           ::= Build_io: <mb-seg-name>.mb.io ;

 <mb-log-stmt>          ::= Build_log: <mb-seg-name>.mb.il ;
 

   ----------                                                                      ----------
%page;
   ----------                                                                      ----------
Flattened Description of Build Script Language:

 The script language given as BNF above generates statements such as those shown below.  
 Items in braces are alternatives; only one is present in an actual statement.

 An archive statement is used only for a bound object having more than one source archive
 (i.e., where source archive has a .<digit> in its name; e.g. bound_pl1_.2.s.archive).

 An add_name or delete_name statement not used on a Bound_obj statement; names on a
 bound segment are specified by statements in its bindfile.

Description     : <description-line>...
Installation_directory 
                :  <absolute-pathname> ;

Build_script    : <mb-seg-name>.mb ;
Build_exec_com  : <mb-seg-name>.mb.ec ;
Build_io        : <mb-seg-name>.mb.io ;
Build_log       : <mb-seg-name>.mb.il ;

Bound_obj       : <bound-object-name>       IN : <library-name>   { ADD | UPDATE  | DELETE }  ;
    bindfile    : <bind-file-name>                                { ADD | REPLACE | DELETE }  ;
 source_arch    : <bound-source-archive-name>                     { ADD | UPDATE  | DELETE }  ;
      source    : <source-seg-name>                               { ADD | REPLACE | DELETE }  <compiler-group> ;
      
Unbound_obj     : <object-seg-name>         IN : <library-name>   { ADD | REPLACE | DELETE }  ;
      source    : <source-seg-name>                               { ADD | REPLACE | DELETE }  <compiler-group> ;

Include         : <include-file-name>       IN : <library_name>   { ADD | REPLACE | DELETE }  ;
Info            : <info-seg-primary-name>   IN : <library_name>   { ADD | REPLACE | DELETE }  ;

Seg(<seg-type>) : <seg-name>                IN : <library_name>   { ADD | REPLACE | DELETE }  ;

Either/both of these statements can follow:  Unbound_obj Info Seg
add_name        : <name>... ; 
delete_name     : <name>... ;
   ----------                                                                      ----------


Examples of Build Script Language
 
  EXAMPLE 1:
   Dir only containing pnotice_language_info_.cds and cds_args.incl.pl1 files.

    mbuild
    Installation directory: >user_dir_dir>Multics>GDixon>work>MCR001

    mbuild:  scan

    mbuild:  print

    Segments found by scan request:
      bound_pnotice_.s.archive:
        source:                pnotice_language_info_.cds        IN: tools.source  REPLACE compiler: cds;

      Include:                 cds_args.incl.pl1                 IN: lang.include  REPLACE;

    mbuild:  analyze

    mbuild:  print

     Bound_obj:                bound_pnotice_                    IN: tools  REPLACE;
         source:               pnotice_language_info_.cds         REPLACE            compiler: cds;

     Include:                  cds_args.incl.pl1                 IN: lang.include  REPLACE;

    mbuild:  quit


  EXAMPLE 2:
   Dir contains:
            Segments = 3, Lengths = 6.

            r w    2  bound_library_tools_.bind
            r w    1  library_pathname.info
                      lpn.info
            r w    3  library_pathname.pl1

    mbuild
    Installation directory: >user_dir_dir>Multics>GDixon>work>MCR002

    mbuild:  scan

    mbuild:  print

    Segments found by scan request:
      bound_library_tools_.archive:
        bindfile:              bound_library_tools_.bind         IN: tools.object  REPLACE;

      bound_library_tools_.s.archive:
        source:                library_pathname.pl1              IN: tools.source  REPLACE compiler: pl1 -ot;

      Info:                    library_pathname.info             IN: privileged.info  REPLACE;
			   add_name:
			     lpn.info;

    mbuild:  analyze

    mbuild:  print

     Bound_obj:                bound_library_tools_              IN: tools  REPLACE;
         bindfile:             bound_library_tools_.bind          REPLACE;
         source:               library_pathname.pl1               REPLACE            compiler: pl1 -ot;

     Info:                     library_pathname.info             IN: privileged.info  REPLACE;
			   add_name:
			     lpn.info;

    mbuild:  quit


  EXAMPLE 3:
   Dir contains:  

    Segments = 3, Lengths = 11.

    r w    3  asu_data.archive
    r w    4  hcs_.alm
    rew    4  new_gate_.alm


    mbuild
    Installation directory: >user_dir_dir>Multics>GDixon>work>MCR003

    mbuild:  scan

    mbuild:  print

    Segments found by scan request:
      source:                  hcs_.alm                          IN: hard.source  REPLACE compiler: alm;
      source:                  new_gate_.alm                     IN: UNKNOWN.source  ADD compiler: alm;

      Seg(data_arch):          asu_data.archive                  IN: tools.execution  REPLACE;

    mbuild:  analyze

    mbuild:  print

     Unbound_obj:              hcs_                              IN: hard  REPLACE;
         source:               hcs_.alm                           REPLACE            compiler: alm;

     Unbound_obj:              new_gate_                         IN: UNKNOWN  ADD;
         source:               new_gate_.alm                      ADD                compiler: alm;

     Seg(data_arch):           asu_data.archive                  IN: tools.execution  REPLACE;

    mbuild:  quit



  EXAMPLE 4:
   Dir is adding a new bound segment: bound_mbuild_.  

    Segments = 13, Lengths = 82.

    r w    1  bound_mbuild_.bind
    r w   54  bound_mbuild_.s.archive
    rew    2  mbuild_Tlist_.incl.pl1
    rew    1  mbuild_Tlist_dcls_.incl.pl1
    rew   14  mbuild_data_.incl.pl1
    rew    1  mbuild_display_dcls_.incl.pl1
    rew    2  mbuild_info_.incl.pl1
    rew    1  mbuild_request_parms_.incl.pl1
    rew    2  mbuild_type.info
	    mbt.info
	    mbuild_type.paradigm.info
	    mbt.paradigm.info
	    mbuild_type.pdm.info
	    mbt.pdm.info
	    mbuild_type.seg_type.info
	    mbt.seg_type.info
	    mbuild_type.seg.info
	    mbt.seg.info
    rew    1  ssu_command_dcls_.incl.pl1
    rew    1  ssu_request_dcls_.incl.pl1
    rew    1  ssu_standalone_command_.incl.pl1
    rew    1  ssu_subroutine_dcls_.incl.pl1


   Since the directory contains a bind file bound_mbuild_.bind, analyze uses its
   Order statement to determine which source files are destined for the new bound 
   object.  Analyze assumes new bound obj will be installed in sss library.
   It assumes all source fits into one source archive; therefore no archive 
   statement is needed.

    mbuild
    Installation directory: >user_dir_dir>Multics>GDixon>work>MCR004

    mbuild:  scan; analyze; print

     Bound_obj:                bound_mbuild_                     IN: UNKNOWN  ADD;
         bindfile:             bound_mbuild_.bind                 ADD;
       source_arch:            bound_mbuild_.s.archive            ADD;
         source:               mbuild.pl1                         ADD                compiler: pl1 -ot;
         source:               mbuild_Tlist_.pl1                  ADD                compiler: pl1 -ot;
         source:               mbuild_analyze_.pl1                ADD                compiler: pl1 -ot;
         source:               mbuild_data_.pl1                   ADD                compiler: pl1 -ot;
         source:               mbuild_display_.pl1                ADD                compiler: pl1 -ot;
         source:               mbuild_et_.alm                     ADD                compiler: alm;
         source:               mbuild_info_.cds                   ADD                compiler: cds;
         source:               mbuild_info_find_.pl1              ADD                compiler: pl1 -ot;
         source:               mbuild_library_.pl1                ADD                compiler: pl1 -ot;
         source:               mbuild_lpn.pl1                     ADD                compiler: pl1 -ot;
         source:               mbuild_print_.pl1                  ADD                compiler: pl1 -ot;
         source:               mbuild_request_.pl1                ADD                compiler: pl1 -ot;
         source:               mbuild_request_parms_.pl1          ADD                compiler: pl1 -ot;
         source:               mbuild_request_tables_.alm         ADD                compiler: alm;
         source:               mbuild_scan_.pl1                   ADD                compiler: pl1 -ot;
         source:               mbuild_script_.pl1                 ADD                compiler: pl1 -ot;
         source:               mbuild_script_parse_.rd            ADD                compiler: rdc -ot -trace off;
         source:               mbuild_set_.pl1                    ADD                compiler: pl1 -ot;
         source:               mbuild_type.pl1                    ADD                compiler: pl1 -ot;

     Include:                  mbuild_Tlist_.incl.pl1            IN: lang.include  ADD;
     Include:                  mbuild_Tlist_dcls_.incl.pl1       IN: lang.include  ADD;
     Include:                  mbuild_data_.incl.pl1             IN: lang.include  ADD;
     Include:                  mbuild_display_dcls_.incl.pl1     IN: lang.include  ADD;
     Include:                  mbuild_info_.incl.pl1             IN: lang.include  ADD;
     Include:                  mbuild_request_parms_.incl.pl1    IN: lang.include  ADD;
     Include:                  ssu_command_dcls_.incl.pl1        IN: lang.include  ADD;
     Include:                  ssu_request_dcls_.incl.pl1        IN: lang.include  ADD;
     Include:                  ssu_standalone_command_.incl.pl1  IN: lang.include  ADD;
     Include:                  ssu_subroutine_dcls_.incl.pl1     IN: lang.include  ADD;

     Info:                     mbuild_type.info                  IN: UNKNOWN.info  ADD;
			   add_name:
			     mbt.info
			     mbuild_type.paradigm.info
			     mbt.paradigm.info
			     mbuild_type.pdm.info
			     mbt.pdm.info
			     mbuild_type.seg_type.info
			     mbt.seg_type.info
			     mbuild_type.seg.info
			     mbt.seg.info;

    mbuild:  quit


   At this point, the admin saves the build script (shown above) and edits
   the Bound_obj library to be tools.  The library for mbuild_type.info remains
   sss.info.  (tools.info selects >doc>info and >doc>privileged, introducing an
   ambiguity in target directory, which mbuild would complain about.)  

   sss.info selects only >doc>info; whereas priv.info selects only >doc>privileged. 
   Maybe we need a better name in multics_libraries_.ld to select just >doc>info, 
   like: general.info ???
   ----------                                                                      ----------


DIAGRAMS SHOWING INTERNAL STRUCTURES BUILT BY mbuild:

 Notes on Threaded Lists:
   The structures declared below are connected in two cardinality types:
    - one-to-one:              COMPILE.sourceP  <---->  SEG(source).COMPILEp
    - one-to-many:  SEG(source_arch).inArch_Tb  <--->>  SEG(source).inArch_Td

   mbuild uses threaded lists (Tlists) to do one-to-many connections between 
   related structures.  
     - A base structure (element name ending in _Tb) anchors the head/tail 
       of a list.  
     - A data structure (element name ending in _Td) stored within each 
       list item threads between:
        - adjacent items of the list, or 
        - anchor.head and first item of list, or 
        - last item of list and anchor.tail.

   These structures are referred to in the diagrams below, and later in the actual
   structure declarations.  They are declared in mbuild_Tlist_dcls_.incl.pl1.


Structure Elements in Diagrams Below:

  Seg:       Main structure representing a real segment:
              - found by a scan request;
              - fabricated to record output of a compile 
                or bind request.

             Designated symbol in diagrams below.........      Seg(<seg_type>)
              - seg_type indicates build type, output of:
                  mbuild_type seg -comment <seg-name>

             Main thread element of a structure                          Seg(source)
             is designated by name beginning with hyphen      scan_Tb:    -scan_Td
             and ending with _Td.  This element name
             appears either above or below the Seg(...)
             symbol.  The - points to build_data.xxx_Tb
             element (head/tail of list containing item) 
             shown in left column of diagram.

             Data for other threads through the structure         Seg(source_arch)
             are indicated by other Td or Tb names                  inArch_Tb
             above/below the Seg symbol, with lines                   /
             pointing to other end of connection.  For               /
             example, a list anchored in a source archive        inArch_Td - - -  inArch_Td
             Seg(source_arch) goes thru each Seg(source)       Seg(source)      Seg(source)
             to be updated within that source archive.          -scan_Td         -scan_Td

             A one-to-one connection is designated by          Seg(source)  Seg(Unbound_obj)
             names ending in P or p above/below the Seg          COMPILEp     COMPILEp
             COMPILE or BOUNDOBJ or UNBOUNDOBJ                        \       /
             symbol.  For example, a link from                         \     /
             Seg(source) to its Compile symbol.                         sP oP
                                                                      COMPILE
  COMPILE:   A relationship symbol connecting a                        -COMPILE_Td    
             a Seg(source) with its compiled 
             Seg(Unbound_obj).  The COMPILE symbol itself 
             does not represent any real segment; just 
             this source-to-compiler-output relationship.
             

  BOUNDOBJ:  A relationship symbol connecting bound               bindfileP
             object's source and object archives,                 bound_objP   
             bindfile, and output from bind command.            BOUNDOBJ
             operation.  See Diagrams 6B and 7 below.            -BOUNDOBJ_Td
                                                                  sourceArchs_Tb
                                                                  objectArchs_Tb

UNBOUNDOBJ:  A relationship symbol identifying an               UNBOUNDOBJ
             unbound object to be installed without              -UNBOUNDOBJ_Td
             binding into a larger bound object.  Gate            sP     
             segments are a good example.  See Diagram 7.


STRUCTURES CREATED or USED by mbuild REQUESTS

Request 1: scan 

  Scans contents of an install directory containing just the source, bindfile, includes,
  info segs, and other files to be directly install.  It generates a threaded list of Seg
  structures, one for each segment found.  Segment <build-type> is not identified by the 
  scan, so segments are represented with undesignated type Seg().
 

  build_data elements   (Diagram 1)
  - - - - - - - - - -
                Seg()     Seg()       Seg()     Seg()      Seg()
     scan_Tb:    -scan_Td  -scan_Td    -scan_Td  -scan_Td   -scan_Td
                   
   - The only identifying information in each Seg structure is the primary file name.

   - Only files on the scan_Tb thread are retained if user decides to start over by issuing
     a "clean" request.

      Policy: segments in this scan_Tb list (original segs in install dir) are never deleted
              from the install dir.  
               Maybe: scan request will turn on safety switch for these segs.


Request 2:  analyze 

  Analyzes Seg() structures built by earlier scan or read requests.

  0) Checks that scan_Tb thread is non-empty.  That would mean neither scan nor read has been
     done.  Report "nothing to analyze" if list is empty.

  1) Walk down the scan_Tb thread, using Seg.name to look up build_type and paradigm for 
     each segment.  Store build_type.mbuild_type as Seg.type.

  2) Place each Seg on a separate thread devoted to its build paradigm.  For example,
     a Seg(source) would be added to the source_Tb paradigm list, in addition to remaining
     on the scan_Tb list.
      a) For bindfile paradigm, add a BOUNDOBJ structure to manage bind operations using
         the bind file.
      b) For source paradigm, add a COMPILE structure to manage compiling the source.
      c) For target_only paradigm, the target_only_Tb thread base uses a to_Td thread
         data element; this shorter name avoids clutter in the diagram.

  build_data elements   (Diagram 2A)
  - - - - - - - - - -
                                                 Seg(bindfile)
      bindfile_Tb:                                -pdm_Td
                                    bindfileP - -  BOUNDOBJp
                                  BOUNDOBJ
      BOUNDOBJ_Tb:                 -BOUNDOBJ_Td

                     Seg(source)       Seg(source)         Seg(source)        Seg(source)
        source_Tb:    -pdm_Td           -pdm_Td             -pdm_Td            -pdm_Td      
                       COMPILEp          COMPILEp            COMPILEp           COMPILEp
                         \                   \                   \                   \    
                         sP oP               sP oP               sP oP               sP oP
                       COMPILE             COMPILE             COMPILE             COMPILE
       COMPILE_Tb:      -COMPILE_Td         -COMPILE_Td         -COMPILE_Td         -COMPILE_Td            

                      Seg(include)  Seg(info)     Seg(exec_com)  Seg(<seg-type>) 
   target_only_Tb:     -pdm_Td       -pdm_Td       -pdm_Td        -pdm_Td     ...


  3) For each Seg, use mblpn (library_pathname derivative) to determine if segment
     is replacing an existing segment in Multics Libraries (target segment).  
     Get the target segment's:
      - containing directory path:    ex: >ldd>sss>source  or  >doc>info  or >ldd>include
      - containing archive (if any):  bound_xxx_.s.archive or bound_xxx_.archive

  4) Use that target segment information to set/adjust Seg.library; and to record
     Seg(source).containing_arch for a source replacing a bound segment source file.
      a) For Seg(bindfile) in bindfile_Tb list, also set BOUNDOBJ.library.
      b) For Seg(source) in source_Tb:
          i)  If Seg is replacing a component of a source archive:
              link Seg to a Seg(source_arch) structure based on target's archive name.
          ii) Otherwise, link Seg to an UNBOUNDOBJ structure.
      c) For Seg(source_arch) in source_archive_Tb, link Seg to a BOUNDOBJ structure
         based upon the source archive name.
      d) For BOUNDOBJ structure in BOUNDOBJ_Tb, set BOUNDOBJ.sourceArchsN = count
         of source archives currently in Multics Libraries for that bound segment.

  Note that members of UNBOUNDOBJ_Tb, BOUNDOBJ_Tb and COMPILE_Tb are not Seg 
  structures, and therefore those Tbase lists do not have a build paradigm name.

  build_data elements   (Diagram 2B)
  - - - - - - - - - -
                                                                          UNBOUNDOBJ
    UNBOUNDOBJ_Tb:                                                         -UNBOUNDOBJ_Td   
                                                 Seg(bindfile)              sP
      bindfile_Tb:                                -pdm_Td                    |
                                    bindfileP - -  BOUNDOBJp                 |
                                  BOUNDOBJ                                   |
      BOUNDOBJ_Tb:                 -BOUNDOBJ_Td                              |
                                    sourceArchsN                             |
                                    sourceArchs_Tb                           |
                                    /                                        |
                                archs_Td- - - - - - - - - archs_Td           |
                              Seg(source_arch)          Seg(source_arch)     |
   source_arch_Tb:             -pdm_Td                   -pdm_Td             |
                                inArch_Tb                 inArch_Tb          |
                                /                              \             |
                        inArch_Td- - - - - inArch_Td          inArch_Td     UNBOUNDOBJp
                      Seg(source)       Seg(source)         Seg(source)    Seg(source)
        source_Tb:     -pdm_Td           -pdm_Td             -pdm_Td        -pdm_Td      
                        COMPILEp          COMPILEp            COMPILEp       COMPILEp
                            \                   \                   \               \    
                            sP oP               sP oP               sP oP           sP oP
                          COMPILE             COMPILE             COMPILE         COMPILE
       COMPILE_Tb:         -COMPILE_Td         -COMPILE_Td         -COMPILE_Td     -COMPILE_Td            

                       Seg(include)  Seg(info)     Seg(exec_com)  Seg(<other>) 
   target_only_Tb:      -pdm_Td       -pdm_Td       -pdm_Td        -pdm_Td     ...


Request 3: save 

  Saves a summary of the installation in Mbuild Script Language in a Seg(mb_script) segment,
  such as MCR10056.mb.  

  FUTURE FEATURE:  If mbuild was invoked with -log, then each request is logged in a Seg(mb_log)
                   segment, such as MCR10056.mb.list.  

  0) Check for any derived segments resulting from compiles, bind, etc.  If any are found,
     warn admin to do a clean before saving; abort the save request.

  1) Add an mbuild_support_Tbase thread, with Seg(mb_script) to track the script file (prevent
     it from being removed by a clean request).  Add a Seg(mb_log) to track requested log file.

  build_data elements   (Diagram 3)
  - - - - - - - - - -
                                                                          UNBOUNDOBJ
    UNBOUNDOBJ_Tb:                                                         -UNBOUNDOBJ_Td   
                                                 Seg(bindfile)              sP
      bindfile_Tb:                                -pdm_Td                    |
                                    bindfileP - -  BOUNDOBJp                 |
                                  BOUNDOBJ                                   |
      BOUNDOBJ_Tb:                 -BOUNDOBJ_Td                              |
                                    sourceArchsN                             |
                                    sourceArchs_Tb                           |
                                    /                                        |
                                archs_Td- - - - - - - - - archs_Td           |
                              Seg(source_arch)          Seg(source_arch)     |
   source_arch_Tb:             -pdm_Td                   -pdm_Td             |
                                inArch_Tb                 inArch_Tb          |
                                /                              \             |
                        inArch_Td- - - - - inArch_Td          inArch_Td     UNBOUNDOBJp
                      Seg(source)       Seg(source)         Seg(source)    Seg(source)
        source_Tb:     -pdm_Td           -pdm_Td             -pdm_Td        -pdm_Td      
                        COMPILEp          COMPILEp            COMPILEp       COMPILEp
                            \                   \                   \               \    
                            sP oP               sP oP               sP oP           sP oP
                          COMPILE             COMPILE             COMPILE         COMPILE
       COMPILE_Tb:         -COMPILE_Td         -COMPILE_Td         -COMPILE_Td     -COMPILE_Td            

                       Seg(include)     Seg(info)     Seg(exec_com)    Seg(<other>) 
   target_only_Tb:      -pdm_Td          -pdm_Td       -pdm_Td          -pdm_Td     ...

                       Seg(mb_script)   Seg(mb_log)
mbuild_support_Tb:      -pdm_Td          -pdm_Td


  2) Create/replace the build script file <install_dir_entryname>.mb (e.g., MCR10056.mb)
     in the install directory.  Contents...

  3) Append statements to the build script, using the paradigm threads in build_data
     shown in Diagram 3.
      a) mbuild_support_Tb: append a Build_Script statement.

      b) BOUNDOBJ_Tb: Walk list; for each BOUNDOBJ item:
          - Append a Bound_obj statement.

          - If BOUNDOBJ.bindfileP is not null, append a bindfile statement.

          - If BOUNDOBJ.sourceArchsN > 1 then:
            - For each Seg(source_arch) in source_arch_Tb:
              - Append an <archive-stmt>.
              - For each Seg(source) in Seg(source_arch).inArch_Tb:
                - Append a <source-stmt> for each modified source file.
          - If BOUNDOBJ.sourceArchsN = 1 then:
            - Append a source statement for each Seg(source) in the inArch_Tb
              list for that archive (each modified source file).

      c) UNBOUNDOBJ_Tb: Walk list; for each UNBOUNDOBJ item:
          - Append an Unbound_obj statement.
          - If UNBOUNDOBJ.add_nameP is not null, append an <add_name-stmt>.
          - If UNBOUNDOBJ.delete_nameP is not null, append a <delete_name-stmt>.
          - If UNBOUNDOBJ.sP is not null, append a source statement describing the
            Seg(source).

      d) target_only_Tbase: Walk list; for each Seg(...) item:
          - If Seg(include), append an Include statement.
          - If Seg(info), append an Info statement.
            - If Seg(info).add_nameP is not null, append an <add_name-stmt>.
            - If Seg(info).delete_nameP is not null, append a <delete_name-stmt>.
          - Otherwise, append a Seg statement.
            - If Seg(...).add_nameP is not null, append an <add_name-stmt>.
            - If Seg(...).delete_nameP is not null, append a <delete_name-stmt>.


Request 4: read 

  Reads the Build Script file written by a save request.

  1) Parse the <install_dir_entryname>.mb segment.  For each statement, construct the
     equivalent structure, as described in Diagram 3: save request (above).
  2) Scan the install directory, looking for files not given in the parsed Build Script.
      - Compare the scan_Tb from parsing with a separate scan_Tb generated by a 
        private scan of the install directory.
      - Complain if other files are present.  (Admin should have done clean before the
        save request.  Or admin added files to install directory, not yet in script.
        - List files not in build script, and ask if those files should be removed
          from install directory.
          - If admin says "no", then abort the read request, preserving any existing data.

  These steps should resurrect Diagram 3 (including its implicit scan_Tb, which is not 
  shown explicitly to simplify that diagram).
            

Request 5: compile 

  1) Walks down the COMPILE_Tb thread, compiling each of the Seg(source) files.  
      - Generates a Seg(Unbound_obj) for the output segment of each compile, along with 
        a new object_Tb anchor.
      - Sets source's COMPILE to point to Seg(Unbound_obj):  COMPILE.oP ---- Seg(Unbound_obj).COMPILEp
      - If any compile also generates an intermediate source, a Seg(INTERMEDIATE) is added,
        placed on an INTERMEDIATE_Tb thread.
      - If -list control argument is included when compiling, a Seg(listing) is added,
        placed on a listing_Tb thread.  Listing files are usually side-effects of 
        compilation, but may optionally be installed in the >ldd>listings>LIBRARY directory.
     Generating Seg() structures for these side-effect files  ensures proper cleanup.

  2) If compiled Seg(Unbound_obj) is tied (via COMPILE and Seg(source) structures) to an
     UNBOUNDOBJ where: UNBOUNDOBJ.add_nameP ^= null or UNBOUNDOBJ.delete_nameP ^= null
      - For each name in UNBOUNDOBJ.add_nameP list, issue command: 
         add_name Seg(Unbound_obj).name <add-seg-name> -bf
      - For each name in UNBOUNDOBJ.delete_nameP list, issue command: 
         delete_name  <del-seg-name> -bf


  build_data Tbases   (Diagram 5)
  - - - - - - - - - 
                       Seg(source)        Seg(source)          Seg(source)           Seg(source)
        source_Tb:      -pdm_Td            -pdm_Td              -pdm_Td               -pdm_Td      
                         COMPILEp           COMPILEp             COMPILEp              COMPILEp
                            \                    \                    \                    \
                             \  Seg(Unbound_obj)  \  Seg(Unbound_obj)  \  Seg(Unbound_obj)  \  Seg(Unbound_obj)
   Unbound_obj_Tb:            \  -pdm_Td           \  -pdm_Td           \  -pdm_Td           \  -pdm_Td      
                               \  COMPILEp          \  COMPILEp          \  COMPILEp          \  COMPILEp
                                \   /                \   /                \   /                \   /
                                sP oP               sP oP                sP oP                sP oP
                              COMPILE             COMPILE              COMPILE              COMPILE
        COMPILE_Tb:            -COMPILE_Td         -COMPILE_Td          -COMPILE_Td          -COMPILE_Td            
                                lP                                       iP
                                 |                                        |
                               COMPILEp                                   |
                             Seg(listing)                                 |
        listing_Tb:           -pdm_Td                                  COMPILEp
                                                                     Seg(INTERMEDIATE)
   INTERMEDIATE_Tb:                                                   -INTERMEDIATE_Td   


Request 6: archive_prep 

  1) Walks down the BOUNDOBJ_Tb thread, getting a list of object archives for each bound segment.
     Adds a Seg(object_arch) for each object archive.
      a) Set operation = "UPDATE" for an object archive having a corresponding source archive
         attached to the BOUNDOBJ (the source archive is being modified); or to the object archive
         containing any modified bindfile.
      b) Set operation = "BIND-INPUT" for all other object archives.

  build_data elements   (Diagram 6A)
  - - - - - - - - - -

      bindfile_Tb:                      \                        -pdm_Td
                                       objectArchs_Tb          Seg(bindfile)
                                       bindfileP - - - - - - - - BOUNDOBJp
                                     BOUNDOBJ
      BOUNDOBJ_Tb:                    -BOUNDOBJ_Td   
                                       sourceArchsN
                                       sourceArchs_Tb   
                                      /
                                archs_Td- - - - - - - - - archs_Td
                              Seg(source_arch)          Seg(source_arch)
   source_arch_Tb:             -pdm_Td                   -pdm_Td   
                                inArch_Tb                 inArch_Tb   
                               /                               \
                        inArch_Td- - - - -inArch_Td           inArch_Td   
                      Seg(source)       Seg(source)         Seg(source)
        source_Tb:     -pdm_Td           -pdm_Td             -pdm_Td      
                         COMPILEp           COMPILEp              COMPILEp
                            \                    \                     \
                             \  Seg(Unbound_obj)  \  Seg(Unbound_obj)   \  Seg(Unbound_obj)
   Unbound_obj_Tb:            \  -pdm_Td           \  -pdm_Td            \  -pdm_Td      
                               \  COMPILEp          \  COMPILEp           \  COMPILEp
                                \   /                \   /                 \   /
                                sP oP                sP oP                 sP oP
                              COMPILE              COMPILE               COMPILE
       COMPILE_Tb:             -COMPILE_Td          -COMPILE_Td           -COMPILE_Td            


  2) At this point, the Seg(source_arch) have no corresponding segment in the install directory,
     unless the Seg(source_arch) is ADDing a new Seg(Bound_obj) to the library.
     Call library_fetch for each missing Seg(source_arch), to bring it into the install directory.
  3) At this point, the Seg(object_arch) are not present, and have no corresponding segment in 
     the install directory.  Call library_fetch for each Seg(object_arch).operation = "UPDATE", 
     to bring it into the install directory.
  4) Update/add/delete Seg(source) components into each Seg(source_arch) archive being modified.
     New/changed source files are not removed from the install dir as source archives are
     updated. 
      (Policy: the original scan_Tb list of segments is never deleted from the install dir.)
  5) Update/add/delete Seg(Unbound_obj) components in each Seg(object_arch) archive to be modified.
     If any Seg(bindfile) is in the install directory, update it into its Seg(object_arch).  
     Segments represented by Seg(Unbound_obj) are deleted as they are updated into their object 
     archive.  The Seg(Unbound_obj) structures are then deleted.  
     The segment represented by Seg(bindfile) remains in the install directory.

  At this point, parts of the internal representation relating to archive_prep are shown below.  

  build_data elements   (Diagram 6B)
  - - - - - - - - - -
   object_arch_Tb:        -pdm_Td                   -pdm_Td                  -pdm_Td
                         Seg(object_arch)          Seg(object_arch)         Seg(object_arch)
                                archs_Td- - - - - -  archs_Td- - - - - - - -  archs_Td
                                       \          
      bindfile_Tb:                      \                        -pdm_Td
                                        objectArchs_Tb          Seg(bindfile)
                                        bindfileP - - - - - - - - BOUNDOBJp
                                      BOUNDOBJ
      BOUNDOBJ_Tb:                     -BOUNDOBJ_Td   
                                        sourceArchsN
                                        sourceArchs_Tb   
                                       /
                                archs_Td- - - - - - - - - archs_Td
                              Seg(source_arch)          Seg(source_arch)
   source_arch_Tb:             -pdm_Td                   -pdm_Td
                                inArch_Tb                 inArch_Tb   
                               /                               \
                        inArch_Td - - - - inArch_Td           inArch_Td   
                      Seg(source)       Seg(source)         Seg(source)
        source_Tb:     -pdm_Td           -pdm_Td             -pdm_Td      
                        COMPILEp          COMPILEp            COMPILEp
                           \                   \                   \
   Unbound_obj_Tb:          \   /               \   /               \   /
                            sP oP               sP oP               sP oP
                          COMPILE             COMPILE             COMPILE
       COMPILE_Tb:         -COMPILE_Td         -COMPILE_Td         -COMPILE_Td   



  6) Binds BOUNDOBJ Seg(object_arch) to produce a Seg(Bound_obj) output segment.
  
      - Walk the BOUNDOBJ_Tb list; for each BOUNDOBJ structure:
         - Bind together all the Seg(object_arch) segments.

  build_data elements   (Diagram 6C)
  - - - - - - - - - -
   object_arch_Tb:        -pdm_Td                   -pdm_Td                  -pdm_Td
                         Seg(object_arch)          Seg(object_arch)         Seg(object_arch)
                                archs_Td- - - - - -  archs_Td- - - - - - - -  archs_Td
                                       \   
      bindfile_Tb:                      \                     -pdm_Td
                                     objectArchs_Tbase       Seg(bindfile)
                                     bindfileP - - - - - - - - BOUNDOBJp
                                   BOUNDOBJ
      BOUNDOBJ_Tb:                  -BOUNDOBJ_Tdata
                                     sourceArchsN
                                     bound_objP - - - -  - - - BOUNDOBJp
                                     sourceArchs_Tb          Seg(Bound_obj)
     Bound_obj_Tb:                                            -pdm_Td

                                UNBOUNDOBJ
    UNBOUNDOBJ_Tb:               -UNBOUNDOBJ_Td
                                  sP
                                   |
                         UNBOUNDOBJp
                       Seg(source)
        source_Tb:      -pdm_Td      
                         COMPILEp
                               \    Seg(Unbound_obj) 
   Unbound_obj_Tb:              \    -pdm_Td
                                 \    COMPILEp
                                  \   /
                                  sP oP
                                COMPILE
       COMPILE_Tb:               -COMPILE_Td


Request 8: install_ec 

  Creates an exec_com of update_seg commands for installing (add/replace/delete) segments
   from the install directory into the Multics Libraries.  

  Diagram 8 shows the structures that remain after the bind request.

  1) Create an exec_com: <install_dir_entryname>.mb.ec.  For example: MCR10056.mb.ec

  2) To this exec_com, add the following update_seg (us) lines.  Note the abbreviated form:
       us {replace|add|delete} Seg(...).name [lds pn BOUNDOBJ.library || ".x"]>== ...
     really means choose one of the following update_seg commands, based upon Seg.operation:
       us replace Seg().name [lds pn BOUNDOBJ.library || ".x"]>==            ...
       us add                [lds pn BOUNDOBJ.library || ".x"]>Seg(...).name ... 
       us delete             [lds pn BOUNDOBJ.library || ".x"]>Seg(...).name ...   
     The [lds pn ...] is replaced by result from the library_descriptor active function.

  a) update_seg initiate <install_dir_entryname>.io

  b) Walk BOUNDOBJ_Tbase; for each BOUNDOBJ structure:
      - us {replace|add|delete} Seg(source_arch).name   [lds pn BOUNDOBJ.library || ".s"]>== -ac
      - For each Seg(object_arch) not having Seg(object_arch).operation = "BIND-INPUT":
        - us {replace|add|delete} Seg(object_arch).name [lds pn BOUNDOBJ.library || ".o"]>== -ac
      - us {replace|add|delete} Seg(Bound_obj).name     [lds pn BOUNDOBJ.library || ".x"]>== 
     All names placed by bind command on Seg(Bound_obj) will be on the installed target.

  c) Walk UNBOUNDOBJ_Tb; for each UNBOUNDOBJ structure:
      - us {replace|add|delete} Seg(source).name [lds pn UNBOUNDOBJ.library || ".s"]>== ...
      - us {replace|add|delete} Seg(Unbound_obj).name [lds pn UNBOUNDOBJ.library || ".o"]>== ...
      - us {replace|add|delete} Seg(Unbound_obj).name [lds pn UNBOUNDOBJ.library || ".x"]>== ...
     All names added to Seg(Unbound_obj) during bind request will be on the installed target.

  d) Walk the target_only_Tb; for each Seg(...) structure:
      - us {replace|add|delete} Seg(...).name [lds pn Seg(...).library]>== ...
     All names found on Seg(...) in the install directory will be on the installed target.

  e) If -listings was given to install_ec request, walk the listing_Tb   ; for each Seg(listing):
      - us {replace|add|delete} Seg(listing).name [lds pn Seg(listing).library]>== ...


  build_data elements   (Diagram 8)
  - - - - - - - - - -
                                                                                 UNBOUNDOBJ
    UNBOUNDOBJ_Tb:                                                                -UNBOUNDOBJ_Td   
                                                                                   sP
   object_arch_Tb:     -pdm_Td               -pdm_Td               -pdm_Td          |
                      Seg(object_arch)      Seg(object_arch)      Seg(object_arch)  |
                             archs_Td- - - -  archs_Td- - - - - - - archs_Td        |
                                    \                                               |
      bindfile_Tb:                   \                        -pdm_Td               |
                                     objectArchs_Tb          Seg(bindfile)          |
                                     bindfileP - - - - - - - - BOUNDOBJp            |
                                   BOUNDOBJ                                         |
      BOUNDOBJ_Tb:                  -BOUNDOBJ_Td                                    |
                                     sourceArchsN                                   |
                                     bound_objP- - - - - - - - BOUNDOBJp            |
                                     sourceArchs_Tb          Seg(Bound_obj)         |
     Bound_obj_Tb:                     /                      -pdm_Td               |
                                      /                                             |
                                archs_Td- - - - - - - - - archs_Td                  |
                              Seg(source_arch)          Seg(source_arch)            |
   source_arch_Tb:             -pdm_Td                   -pdm_Td                    |
                                inArch_Tb                 inArch_Tb                 |
                               /         \                     \                    |
                        inArch_Td         inArch_Td          inArch_Td      UNBOUNDOBJp
                      Seg(source)       Seg(source)        Seg(source)    Seg(source)
        source_Tb:     -pdm_Td           -pdm_Td            -pdm_Td        -pdm_Td      
                        COMPILEp          COMPILEp           COMPILEp       COMPILEp
                            \                 \                  \              \    Seg(Unbound_obj) 
   Unbound_obj_Tb:           \                 \                  \              \    -pdm_Td   
                              \                 \                  \              \    COMPILEp
                               \   /             \   /              \   /          \    /
                               sP oP             sP oP              sP oP          sP oP
                             COMPILE           COMPILE            COMPILE        COMPILE
       COMPILE_Tb:            -COMPILE_Td       -COMPILE_Td        -COMPILE_Td    -COMPILE_Td   
                               lP                                   iP
                                |                                    |
                               COMPILEp                              |
                             Seg(listing)                            |
       listing_Tb:            -pdm_Td                              COMPILEp
                                                                 Seg(intermediate)
  INTERMEDIATE_Tb:                                                -INTERMEDIATE_Td   

                       Seg(include)    Seg(info)    Seg(exec_com)   Seg(<other>) 
   target_only_Tb:      -pdm_Td         -pdm_Td      -pdm_Td         -pdm_Td      ...

                       Seg(mb_script)  Seg(mb_log)
mbuild_support_Tb:      -pdm_Td         -pdm_Td   


Request 9: clean 

  Removes all files derived from build operations.  The files found during the original 
  scan request should remain in the install directory, along with any mbuild support files.

  1) Walk the listing_Tb, removing each Seg(listing) from the list and 
     deleting its associated file.
  2) Walk the INTERMEDIATE_Tb, removing each Seg(intermediate) from the list and 
     deleting its associated file.
  3) Walk the unbound_object_Tb, removing each Seg(Unbound_obj) from the list and 
     deleting its associated file.
  4) Walk the source_archive_Tb, KEEPING each Seg(source_arch) in the list, but 
     deleting its associated file.
  5) Walk the object_archive_Tb, removing each Seg(object_arch) from the list and 
     deleting its associated file.
  6) Walk the bound_object_Tb, removing each Seg(Bound_obj) from the list and 
     deleting its associated file.

  The result should be a data structure as shown in Diagram 3.
 * ------------------------------------------------------------------------------------------ */
%page;
/* ------------------------------------------------------------------------------------------ 
   MAJOR STRUCTURE:  build_data

   Data structure passed by the mbuild command to each of its requests and supporting subroutines.
   It provides the "mbuild database" of information gathered by a series of mbuild requests 
   that describe an installation directory and its changeset.
   ------------------------------------------------------------------------------------------ */

  dcl 1 build_data aligned,
      2 info,					/* Information:				        */
        3 version char(20) var,			/*   Version of this structure = mbuild_data_version_3    */
        3 directory char(168) unal,			/*   Build directory pathname.		        */
        3 log_directory char(168) unal,			/*   Log directory used by update_seg initiate	        */
        3 build_script_prefix char(24) var,		/*   Build script name prefix (without .mb suffix).       */
        3 scan_Tb_via_request char(4),			/*   Last request to replace contents of scan_Tb thread.  */
        3 pad char(4),
      2 progress aligned like bld_progress,		/* Build Progress Indicators (saved between requests)     */
      2 ptrs,					/* Pointers to:				        */
        3 ssu_areaP ptr,				/*   an ssu_-provided standard area.		        */
        3 areaP ptr,				/*   translator_temp_ area when seg structs live	        */
        3 sciP ptr,					/*   subsystem control structure owned by ssu_	        */
        3 script_descripP ptr,			/*   description placed at top of build script.	        */
        3 lib_namesP ptr,				/*   library paths and preferred lib.dir name	        */
      2 Special_Tb,					/* Special Threaded List Anchors		        */
        3 scan_Tb          aligned like Tlist_base,	/*                  scan_Tb -->> Seg.scan_Td              */
        3 INTERMEDIATE_Tb  aligned like Tlist_base,	/*          INTERMEDIATE_Tb -->> Seg.INTERMEDIATE_Td      */
      2 Struct_Tb,                                          /* Per-Structure Anchors:			        */
        3 (BOUNDOBJ_Tb,                                     /*              BOUNDOBJ_Tb -->> BOUNDOBJ.BOUNDOBJ_Td     */
           COMPILE_Tb,                                      /*               COMPILE_Tb -->> COMPILE.COMPILE_Td       */
           Seg_Tb,                                          /*                   Seg_Tb -->> Seg.Seg_Td               */
           UNBOUNDOBJ_Tb                                    /*            UNBOUNDOBJ_Tb -->> UNBOUNDOBJ.UNBOUNDOBJ_Td */
           )               aligned like Tlist_base,
      2 pdm_Tb,                                             /* Per-Paradigm Anchors:			        */
        3 (source_Tb,             bindfile_Tb,              /*       <paradigm_name>_Tb -->> Seg.pdm_Td               */
           source_arch_Tb,        object_arch_Tb,    
           Bound_obj_Tb,          Unbound_obj_Tb,
           target_only_Tb,        listing_Tb,
	 object_x_only_Tb,
           mbuild_support_Tb
           )               aligned like Tlist_base;

  dcl  mbuild_data_version_2 char(20) var aligned int static options(constant) init("mbuild_data_0002");
  dcl  mbuild_data_version_3 char(20) var aligned int static options(constant) init("mbuild_data_0003");

  dcl 1 bld aligned like build_data based(Abuild_dataP),	/* Declaration of build_data used by each mbuild request  */
       Abuild_dataP ptr;


/* ------------------------------------------------------------------------------------------
   STRUCTURE:  bld_progress

   Describes progress made by mbuild requests to build and install the changeset in an
   installation directory.
   ------------------------------------------------------------------------------------------ */

  dcl 1 bld_progress aligned,
      2 (describedS,                                        /* set -description request: description gathered.        */
         scannedS,                                          /* scan: request complete.                                */
         analyzedS,                                         /* analyze: request complete.                             */
         compiledS,					/* compile: request complete.			        */
         preppedS,					/* archive_prep: request complete.		        */
         install_ecS				/* install_ec: request complete.		        */
         ) bit(1) unaligned,
      2 progress_pad bit(30) unaligned;


/* ------------------------------------------------------------------------------------------
   STRUCTURE:  lib_names

   Array of node structures describing a library.directory: its preferred name, 
   absolute directory pathname, and any problem found it attaching a preferred
   name that uniquely identifies a single library.directory.

   The preferred library name and pathname are extracted from the current library
   descriptor for the current user process.
   ------------------------------------------------------------------------------------------ */

  dcl 1 lib_names aligned based(lib_namesP),		/* List of library valid name/path combinations. 	        */
      2 descriptor char(168) var,			/*  - library descriptor provided this data.	        */
      2 namesN fixed bin,				/*  - Obtained from lib_descriptor_		        */
      2 P (lib_namesN refer (lib_names.namesN)) ptr unal,	/*  - P->nodes ordered by length(path), longest first     */
      2 node (lib_namesN refer (lib_names.namesN)),
        3 library char(32) var,			/*  - Preferred library name, should exactly identify...  */
        3 path char(168) var,				/*  - Path of root directory in library.	        */
        3 problem char(52) var,			/*  - Issue with preferred name for this path.	        */
       lib_namesN fixed bin,
       lib_namesP ptr;

/* ------------------------------------------------------------------------------------------
   STRUCTURE:  script_descrip

   Text string entered using the mbuild request:  set -desc
   or read into mbuild using the mbuild request:  read -desc  or  read
   ------------------------------------------------------------------------------------------ */

  dcl 1 script_descrip aligned based (script_descripP),     /* Description of the installation, stored permanently    */
                                                            /*  only in the build script.                             */
      2 L fixed bin(21),                                    /* Note: This is a char(N) varying string, w/ adjustable  */
      2 text char (script_textL refer (script_descrip.L)),  /*       maxlength.                                       */
       script_descripP ptr,
       script_textL fixed bin(21);
          

/* ------------------------------------------------------------------------------------------
   MAJOR STRUCTURE:  Seg

   Data describing each segment found in the installation directory, or created when building
   the changeset.  

   Also, the Seg.common substructure is data that also appears in other major structures used 
   by mbuild:  BOUNDOBJ, COMPILE, and UNBOUNDOBJ
   ------------------------------------------------------------------------------------------ */

  dcl 1 Seg aligned based(SegP),
      2 common,					/* Elems in: Seg, COMPILE, BOUNDOBJ, UNBOUNDOBJ, request  */
        3 info,
	4 struct char(4) var,			/* = Seg, COMP, BND, or UBND			        */
          4 type char(16) var,			/* = [mbt seg Seg.name -type]                             */
          4 name char(32) var,			/* Entryname of this segment.                             */
          4 library char(32) var,			/* Library for this seg: sss, tools, hard, unb, include,  */
                                                            /*  or for infos: sss.info, priv.info;                    */
                                                            /*  for subsystem infos: analyze_multics.info, bce.info   */
          4 operation char(12) var,			/* = "ADD", "REPLACE", "UPDATE", or "DELETE"              */
						/*   UPDATE designates archives whose component(s)        */
						/*   will be REPLACEd.  Using REPLACE for an archive      */
						/*   means the entire archive is REPLACEd without	        */
						/*   changing its components during the build process.    */
          4 archive_name char(32) var,			/* Name of containing archive in Multics Libraries.       */
          4 compiler char(32) var,			/* Name of compiler used to compile source segment.       */
          4 compile_options char(32) var,		/* Specific compile options given in a .mb file.          */
	4 produced_by_compiler char(32) var,		/* Name of compiler which produced this derived segment.  */
	4 pad1 char(4),
        3 request_Td aligned like Tlist_data,	/*	     request.request_Tb -->> Seg.request_Td (Per Request) */
      2 Td,
        3 (Seg_Td,                                /*              build_data.Seg_Tb -->> Seg.Seg_Td   (Per Structure) */
           pdm_Td,                                /*  build_data.<paradigm-name>_Tb -->> Seg.pdm_Td    (Per Paradigm) */

           scan_Td,                               /*             build_data.scan_Tb -->> Seg.scan_Td                  */
           INTERMEDIATE_Td,                       /*     build_data.INTERMEDIATE_Tb -->> Seg.INTERMEDIATE_Td          */

           archs_Td,                              /*        BOUNDOBJ.sourceArchs_Tb -->> Seg(source_arch).archs_Td    */
                                                  /*        BOUNDOBJ.objectArchs_Tb -->> Seg(object_arch).archs_Td    */
           inArch_Td                              /*     Seg(source_arch).inArch_Tb -->> Seg(source).inArch_Td        */
           ) aligned like Tlist_data,
      2 Tb,
        3 inArch_Tb aligned like Tlist_base,      /*     Seg(source_arch).inArch_Tb -->> Seg(source).inArch_Td        */
      2 ptrs,
        3 seg_typeP ptr,                          /*           Pointer to seg_type_info structure for this seg.       */
        3 build_typeP ptr,                        /*           Pointer to bld_paradigm_info structure for this seg.   */

        3 name_addP ptr,                          /*           Pointer to nm_data: names to be added to the seg.      */
        3 name_deleteP ptr,                       /*           Pointer to nm_data: names to be deleted from the seg.  */

        3 BOUNDOBJp ptr,                          /*	          Seg.BOUNDOBJp  --> BOUNDOBJ                     */
        3 COMPILEp ptr,                           /*	           Seg.COMPILEp  --> COMPILE                      */
        3 UNBOUNDOBJp ptr,                        /*	        Seg.UNBOUNDOBJp  --> UNBOUNDOBJ                   */
        3 sArchP ptr,			/*        Seg(object_arch).sArchP  --> Seg(source_arch)	        */
       SegP ptr;

  dcl 1 sArch aligned like Seg based (sArchP),              /* Seg(source_arch) structure.                            */
       sArchP ptr;
  dcl 1 oArch aligned like Seg based (oArchP),              /* Seg(object_arch) structure.                            */
       oArchP ptr;

  dcl 1 nm_data aligned based(nm_dataP),                    /* List of names associated with seg entry.               */
      2 N fixed bin,                                        /*  Count of names in the list.                           */
      2 names (nm_dataN refer (nm_data.N)) char(32) var,    /*  Array of names.                                       */
       nm_dataP ptr,                                        /* Pointer to a names structure.                          */
       nm_dataN fixed bin;                                  /* Number of names to allocate in a new structure.        */


/* ------------------------------------------------------------------------------------------
   STRUCTURE:  request

   Minor structure that mainly holds a threaded-list anchor (Tlist_base) substructure.
   The request threaded-list holds Seg (or COMPILE or BOUNDOBJ) structures to be operated
   upon by the current mbuild request.  The list is constructured by that mbuild request,
   and lives only while that request is running.  Before the request returned, the request
   threaded list MUST BE EMPTIED; this frees the Seg.request_Td threads in member Seg
   structures so those structures can appear in request threads of some subsequent mbuild
   request.

   NOTE: Each mbuild request that builds a request thread must establish a cleanup on-unit
         to empty that threaded list if operation of the request is interrupted and/or
         aborted.
   ------------------------------------------------------------------------------------------ */

  dcl 1 request aligned based (requestP),		/* Structure to hold temporary per-request list anchor    */
      2 common,					/* Elems in: Seg, COMPILE, BOUNDOBJ, UNBOUNDOBJ, request  */
        3 info aligned like Seg.info,
        3 request_Td aligned like Tlist_data,		/*      request.request_Tb -->> Seg.request_Td  (Per Req) */
      2 Tb,					/*  - other .info fields are blank.		        */
        3 request_Tb aligned like Tlist_base,
       requestP ptr;
	

/* ------------------------------------------------------------------------------------------
   MAJOR STRUCTURE: COMPILE

   A "relationship structure" that manages the operation of compiling one Seg in the changeset.
   ------------------------------------------------------------------------------------------ */

  dcl 1 COMPILE aligned based(COMPILEp),
      2 common,					/* Elems in: Seg, COMPILE, BOUNDOBJ, UNBOUNDOBJ, request  */
        3 info aligned like Seg.info,
        3 request_Td aligned like Tlist_data,		/*      request.request_Tb -->> Seg.request_Td  (Per Req) */
      2 Td,
        3 COMPILE_Td aligned like Tlist_data,               /*   build_data.COMPILE_Tb -->> COMPILE.COMPILE_Tb        */
      2 ptrs,
        3 sourceP ptr,                                      /*         COMPILE.sourceP  --> Seg(source)               */
        3 objectP ptr,                                      /*         COMPILE.objectP  --> Seg(Unbound_obj)          */
        3 listingP ptr,                                     /*        COMPILE.listingP  --> Seg(listing)              */
        3 INTERMEDIATEp ptr,                                /*   COMPILE.INTERMEDIATEp  --> Seg(source)               */
						/*                              .produced_by_compiler^="" */
       COMPILEp ptr;


/* ------------------------------------------------------------------------------------------
   MAJOR STRUCTURE: BOUNDOBJ

   A "relationship structure" that manages the operations of assembling source, objects, and
   bindfile needed to create a single bound object (aka, bound segment).
   ------------------------------------------------------------------------------------------ */

  dcl 1 BOUNDOBJ aligned based(BOUNDOBJp),
      2 common,					/* Elems in: Seg, COMPILE, BOUNDOBJ, UNBOUNDOBJ, request  */
        3 info aligned like Seg.info,
        3 request_Td aligned like Tlist_data,		/*      request.request_Tb -->> Seg.request_Td  (Per Req) */
      2 Td,
        3 BOUNDOBJ_Td aligned like Tlist_data,              /*  build_data.BOUNDOBJ_Tb -->> BOUNDOBJ.BOUNDOBJ_Tb      */
      2 Tb,
        3 (sourceArchs_Tb,                                  /* BOUNDOBJ.sourceArchs_Tb -->> Seg(source_arch).archs_Td */
           objectArchs_Tb                                   /* BOUNDOBJ.objectArchs_Tb -->> Seg(object_arch).archs_Td */
           ) aligned like Tlist_base,
      2 ptrs,
        3 (bindfileP,                                       /*      BOUNDOBJ.bindfileP  --> Seg(bindfile)             */
           Bound_objP,                                      /*     BOUNDOBJ.bound_objP  --> Seg(Bound_obj)            */
           listingP                                         /*       BOUNDOBJ.listingP  --> Seg(listing)              */
           ) ptr,
      2 sourceArchsN fixed bin,                             /* Number of source archives for bound seg in libraries.  */
       BOUNDOBJp ptr;


/* ------------------------------------------------------------------------------------------
   MAJOR STRUCTURE: UNBOUNDOBJ

   A "relationship structure" that manages the operation of assembling source and object 
   needed to create a single unbound object (standalone program) to be installed.
   ------------------------------------------------------------------------------------------ */

  dcl 1 UNBOUNDOBJ aligned based(UNBOUNDOBJp),
      2 common,					/* Elems in: Seg, COMPILE, BOUNDOBJ, UNBOUNDOBJ, request  */
        3 info aligned like Seg.info,
        3 request_Td aligned like Tlist_data,		/*      request.request_Tb -->> Seg.request_Td  (Per Req) */
      2 Td,
        3 UNBOUNDOBJ_Td aligned like Tlist_data,            /*build_data.UNBOUNDOBJ_Tb -->> UNBOUNDOBJ.UNBOUNDOBJ_Tb  */
      2 ptrs,
        3 name_addP ptr,                                    /* Pointer to list of alternate names on the seg.         */
        3 name_deleteP ptr,                                 /* Pointer to list of names to be deleted from the seg.   */

        3 sourceP ptr,                                      /*      UNBOUNDOBJ.sourceP  --> Seg(source)               */
       UNBOUNDOBJp ptr;

  dcl (						/* Initial values for elements of Seg.info	        */
       unknown_type char(16) var,			/*  - Seg type not yet determined.		        */
       not_stored_in_library char(32) var,		/*  - Seg library not appropriate for given Seg type.     */
       unknown_library char(32) var,			/*  - Seg library not yet determined.		        */
       no_library_operation char(12) var,		/*  - Seg operation not appropriate for given Seg type.   */
       unknown_operation char(12) var,			/*  - Seg operation not yet determined.		        */
       no_containing_archive char(32) var,		/*  - Seg type not appropriate for archiving.	        */
       unknown_archive_name char(32) var		/*  - Seg type location unknown; could be archived.       */
       ) int static options(constant) init("");

/*  END OF:         mbuild_data_.incl.pl1                     *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
