/*  START OF:	info_seg_dcls_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

/****^  HISTORY COMMENTS:
  1) change(2020-07-30,GDixon), approve(2021-02-23,MCR10089),
     audit(2021-03-31,Swenson), install(2021-03-31,MR12.6g-0053):
     Initial version written for verify_info command and info_seg_ subroutine.
      A) This version includes revised block divider keywords: :[Info]: and :hcom:
      B) Add INFO_SECTION_NO_TITLE_FABRICATION constant.
  2) change(2020-11-25,GDixon), approve(2021-02-23,MCR10089),
     audit(2021-03-31,Swenson), install(2021-03-31,MR12.6g-0053):
      A) Replace all references to iBlok_divider_Internal with iBlok_divider_hcom.
                                                   END HISTORY COMMENTS */

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Common sub-structures declared within major info segment structures (defined further below).   */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

  dcl 1 iCommon aligned based(iCommonP),		/* Substructure which begins many info_seg structures.    */
      2 content,					/* Content described by the major structure.	        */
        3 ID char(4),				/*  - content identifier			        */
        3 L fixed bin(21),				/*  - content length (in characters)		        */
        3 P ptr,					/*  - content pointer			        */
      2 sib like iSib,				/*  Pointers to next/prev items in list of major 	        */
       iCommonP ptr;				/*   structures.  All structures in list have same shape  */
						/*   and ID.				        */

						/* Values for iCommon.content.ID:		        */
  dcl (iFileID init("FILE"),				/*  iFile: info_seg file data structure 	        */
       iBlokID init("BLOK"),				/*  iBlok: info_seg block-of-lines descriptor	        */
       iSectID init("SECT"),				/*  iSect: info_seg section-of-paragraphs descriptor      */
       iListID init("LIST"),				/*  iList: info_seg Argument/Control_arg/Operation desc.  */
       OListID init("OLST"),				/*  Operation_List: operation/control order list          */
       iPghID  init("PGH"),				/*  iPgh:  info_seg paragraph descriptor	        */
       iLineID init("LINE")				/*  iLine: info_seg line descriptor		        */
       ) char(4) int static options(constant);


  dcl 1 iChild aligned based(iChildP),			/* Substructure declared within a major structure below.  */
						/* It is the base of a list of child structs attached     */
						/* to the parent structure.			        */
      2 firstP ptr,					/*  - points to first child structure in list.	        */
      2 lastP ptr,					/*  - points to final child structure in list.	        */
       iChildP ptr;

  dcl 1 iSib aligned based(iSibP),			/* Thread between structures in a list.  All list members */
						/* have the same shape and ID.		        */
      2 nextP ptr,					/*  - points to next structure in list.		        */
						/*     - null if declaring structure is last in the list. */
      2 prevP ptr,					/*  - points to prior structure in list.	        */
						/*     - null if declaring structure is first in the list.*/
       iSibP ptr;


  dcl  entrynameL fixed bin int static options(constant) init(32);
						/* NOTE: iNameXXX structures below hold words from        */
						/*   info seg heading lines, block divider names, and     */
						/*   external names on the info segment.  Both heading    */
						/*   line names and block divider names can be a	        */
						/*   subroutine entrypoint name; and such names are       */
						/*   PL/I identifiers whose max length is 256 characters. */
						/*   info_seg_ limits such names to 32 chars in length    */
						/*   since no Multics subroutine uses entrypoint names    */
						/*   longer than 32 characters.		        */

  dcl 1 iName10 aligned,				/* A 10-element name array.			        */
      2 N fixed bin,				/*  - number of array elements currently in use.	        */
      2 nm (10) char(entrynameL) var;			/*  - array holding names in the list.		        */

  dcl 1 iName100 aligned based,			/* A 100-element name array			        */
      2 N fixed bin,				/*  - number of array elements currently in use.	        */
      2 nm (100) char(entrynameL) var;			/*  - array holding names in the list.		        */

  dcl 1 iName300 aligned based,			/* A 300-element name array			        */
      2 N fixed bin,				/*  - number of array elements currently in use.	        */
      2 nm (300) char(entrynameL) var;			/*  - array holding names in the list.		        */

  dcl 1 Names aligned based (NamesP),			/* Overlay for in-use portion of any name array.	        */
      2 N fixed bin,
      2 nm (0 refer (Names.N)) char(entrynameL) var,
       NamesP ptr;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
 *											        *
   Notes on the following structures:
    - List: an adjustable-sized array of items.
       - Items may be: Argument names, Control argument names, List of ... item names, etc.
       - Each item may have 1-4 name variants.
       - Each list includes a pointer to the info section which describes those items.
    - Operation_List: a kind of List whose items describe other info blocks.
       - Items may be: operations supported by a multi-operation command (io_call, history_comment, etc.).
       - Items share same List.common (or Lcom) substructure.
       - Extra elements of an Operation_List:
	- blok_name: name of the info block containing the section describing items in the Operation_List.
	- per_operation_iBlokP: array of pointers to the info block references by each operation item.
    - Lcom: overlay for the List.common substructure shared by List and Operation_List instances.
 *											        *
 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

  dcl  LENGTH_iList_item_name fixed bin init(80) int static options(constant);
  dcl 1 iList aligned based,				/* A 200-element array of Argument, Control_arg, or       */
						/* List of ... items			        */
      2 content like iCommon.content,
      2 parentSectP ptr,				/*  - points to iSect holding this data.	        */
      2 common,					/* Common parts shared by: iList, List, Operation_List    */
        3 N fixed bin,				/*  - number of array elements currently in use.	        */
        3 items (200),				/*  - array holding up to four long/short/variant names   */
          4 nmN fixed bin,				/*    for the argument, control_arg, or operation.        */
	4 nameP ptr unal,				/*     - iLineP for first line containing name of item.   */
	4 defEndP ptr unal,				/*     - iLineP for final name/definition line of item.   */
          4 nm (4) char(LENGTH_iList_item_name) var;	/*    All 4 are alternative names for the same item.      */

  dcl 1 List aligned based (ListP),			/* An N-element array of Argument, Control_arg, or        */
						/* Operation names for a command/af/request/ar blok.      */
      2 content like iCommon.content,
      2 common,					/* Common parts shared by: iList, List, Operation_List    */
        3 parentSectP ptr,				/*  - points to iSect holding this data.	        */
        3 N fixed bin,				/*  - number of array elements currently in use.	        */
        3 items (ListN refer (List.N)),			/*  - array holding up to four long/short/variant names   */
	4 nmN fixed bin,				/*    for the argument, control_arg, or operation.        */
	4 nameP ptr unal,				/*     - iLineP for first line containing name of item.   */
	4 defEndP ptr unal,				/*     - iLineP for final name/definition line of item.   */
	4 nm (4) char(80) var,			/*    All 4 are alternative selectors for the same item.  */
      (ListI, ListN) fixed bin,
       ListP ptr,
       List_item_names (ListP->List.items(ListI).nmN) char(80) var based(addr(ListP->List.items(ListI).nm(1)));

  dcl 1 Operation_List aligned based (Operation_ListP),	/* An N-element "List of operations" op names w/ pointers */
						/* to the iBlok describing each operation.	        */
      2 content like iCommon.content,
      2 blok_name char(entrynameL) var,			/*  - ShortName of multi-operation command/af/request/ar  */
      2 common,					/* Common parts shared by: iList, List, Operation_List    */
        3 parentSectP ptr,				/*  - points to multi_operations block iSect holding list */
        3 N fixed bin,				/*  - number of array elements currently in use.	        */
        3 items (Operation_ListN refer (Operation_List.N)),	/*  - array holding up to four long/short/variant names   */
	4 nmN fixed bin,				/*    for the argument, control_arg, or operation.        */
	4 nameP ptr unal,				/*     - iLineP for first line containing name of item.   */
	4 defEndP ptr unal,				/*     - iLineP for final name/definition line of item.   */
	4 nm (4) char(80) var,			/*    All 4 are alternative names for the same item.      */
      2 per_operation_iBlokP (Operation_ListN refer (Operation_List.N)) ptr,
						/*  - array holding iBlokP values for block describing    */
						/*    each operation in the items array.	        */
      (Operation_ListI, Operation_ListN) fixed bin,
       Operation_ListP ptr,
       operation_names (Operation_ListP->Operation_List.items(Operation_ListI).nmN) char(80) var 
	based( addr(Operation_ListP->Operation_List.items(Operation_ListI).nm(1)) );

  dcl 1 Lcom aligned based (LcomP),
        3 parentSectP ptr,				/*  - points to iSect holding this data.	        */
        3 N fixed bin,				/*  - number of array elements currently in use.	        */
        3 items (0 refer (Lcom.N)),			/*  - array holding up to four long/short/variant names   */
	4 nmN fixed bin,				/*    for the argument, control_arg, or operation.        */
	4 nameP ptr unal,				/*     - iLineP for first line containing name of item.   */
	4 defEndP ptr unal,				/*     - iLineP for final name/definition line of item.   */
	4 nm (4) char(80) var,			/*    All 4 are alternative names for the same item.      */
       LcomP ptr,
       LcomI fixed bin,
       Lcom_item_names (LcomP->Lcom.items(LcomI).nmN) char(80) var based(addr(LcomP->Lcom.items(LcomI).nm(1)));


%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Major structures defining components of an info segment, listed in order of smallest to        */
	/* largest aggregate of characters in the info segment.				        */
	/*									        */
	/*  - iLine	defines content of one line of an info segment.			        */
	/*  - iPgh	defines lines in one paragraph of an info segment.		        */
	/*  - iSect	defines paragraphs combined into one titled section of an info segment.       */
	/*  - iBlok	defines block divider (optional), header line, and sections in one block      */
	/* 		of an info segment.  A block describes one info topic, command/AF, subsystem  */
	/*		request, subroutine or subroutine entrypoint, etc.		        */
	/*  - iFile	defines one info segment, which may contain one or more blocks of data.       */
	/*		Each block can be located and displayed individually.		        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* --------------------------------------------------------------------------------
   DEFINITIONS for lines:
     line of an info segment:  1 or more consecutive characters within the info
			 segment ending with a NL character.

   STRUCTURE:  iLine

     Describes content of one line within an info segment, not including its ending
     NL delimiter (character separating the line from data beyond end of that line).

   Siblings:
     An iLine may be threaded below (may be a child of) a structure describing a 
     higher-level aggregate within an info segment.  Other members on this thread
     are its siblings.

     iFile: Each iLine is threaded below an iFile.lines structure describing lines 
	  of an entire info segment.  iLine structures are threaded in their
	  order of appearance of their line within that file; they are in 
	  ascending line-number order.
     iBlok: An iLine may be threaded below an iBlok.lines structure describing lines
	  within that block of the info segment.  
	   - Blank lines preceding block dividers 
	      (:Info: or :[Info]:, or :Entry:, or :hcom: or :Internal:) 
	     are only threaded to the iFile; not to any iBlok structure.
     iSect: An iLine may be threaded below an iSect.lines structure describing lines
	  contained in that section (group of paragraphs) within the block.
	   - Only 1 of the 2 blank lines preceding each paragraph is included in this
	     thread.  This is how help displays consecutive paragraphs of a section
	     when user responds: rest -section
     iPgh:  An iLine may be threaded below an iPgh.lines structure describing 
	  a group of lines preceded by two blank lines within the block.
	   - The two blank lines (separating a paragraph from its predecessor)
	     are not threaded to any iPgh structure.

   Relatives:
     sectP: points to any section of the info segment containing this line.
     pghP:  points to any paragraph containing this line.
   -------------------------------------------------------------------------------- */

  dcl 1 iLine aligned based (iLineP),			/* Structure describing one line of an info segment.      */
      2 common like iCommon.content,			/*  - ID; pointer to, and length of chars in the line.    */
      2 sibs,					/*  Line may be child of several higher-level structures. */
        3 file like iSib,				/*  - thread between adjacent lines of info seg iFile.    */
        3 blok like iSib,				/*  - thread between adjacent lines of info seg iBlok.    */
        3 sect like iSib,				/*  - thread between adjacent lines of info seg iSect.    */
        3 pgh  like iSib,				/*  - thread between adjacent lines of info seg paragraph.*/
      2 relatives,
        3 sectP ptr,				/*  - Pointer to iSect containing this line.	        */
        3 pghP ptr,					/*  - Pointer to iPgh containing this line.	        */
      2 line_in_file fixed bin,			/*  - Line's position (sequence number) within info seg.  */

      2 errors aligned,				/*  ERRORS detected while determining line content.       */
        3 (NL_missingS,				/*  - Last line of info seg did not end with NL.	        */

	 all_whitespaceS,				/*  - Line contains only whitespace chars.	        */
	 ends_whitespaceS,				/*  - Line contains non-whitespace chars, but ends with 
						/*    whitespace chars.			        */

	 overlengthS,				/*  - Line length exceeds INFO_CHARS_PER_LINE.	        */

	 backspaceS,				/*  - Line contains BS (backspace) characters.	        */
	 unprintableS				/*  - Line contains characters not in INFO_PRINTABLE.     */
	 ) bit(1) unal,
       iLineP ptr;					/* Points to "current" line's iLine structure.	        */

  dcl  Line char(iLineP->iLine.L) based(iLineP->iLine.P);	/* Character content of line described by iLineP->iLine   */
						/*  (the "current" line).  Does not include NL delimiter. */
%page;
/* --------------------------------------------------------------------------------
   DEFINITIONS for paragraphs:
     paragraph of an info segment:  1 or more consecutive lines within an info
			      segment, ending with either:
			       - two blank lines; or
			       - end of info seg block containing the paragraph.
			      The first paragraph of a block is preceded by
			      1 or 2 blank lines ending the block
			      header line(s).
   STRUCTURE:  iPgh

     Describes content of one paragraph within an info segment, not including its ending
     pair of blank lines.

   Siblings:
     An iPgh may be threaded to a structure describing a higher-level aggregate
     within an info segment.  Other members on this thread are its adjacent paragraph
     siblings.

     iBlok: A paragraph is threaded to iBlok.pghs listing paragraphs contained
	  in that block of the info segment.  
     iSect: A paragraph is threaded to iSect.pghs listing paragraphs contained
	  in that section of the info segment block.

   Relatives:
     .sectP: points to the iSect that contains this paragraph.
     .lines: a threaded list of lines in this paragraph.
   -------------------------------------------------------------------------------- */

  dcl 1 iPgh aligned based (iPghP),			/* Structure describing one paragraph (group of lines) in */
						/*  an info segment block.			        */
      2 common like iCommon.content,			/*  - ID; pointer to, and length of chars in paragraph    */
      2 sibs,					/*  Paragraph may be child of higher-level structures.    */
        3 blok like iSib,				/*  - thread between adjacent paragraphs of a block       */
        3 sect like iSib,				/*  - thread between adjacent paragraphs of a section     */
      2 relatives,
        3 sectP ptr,				/*  - points to iSect containing this paragraph.	        */
        3 lines like iChild,				/*  - list of lines in this paragraph.		        */
						/*     - follows the iLine.sibs.pghs thread.	        */
      2 line_in_file fixed bin,			/*  - paragraphs's position (starting line number) in seg */
      2 line_count fixed bin,				/*  - number of lines within this paragraph.	        */
      2 seenS bit(1) aligned,				/*  ^ paragraph has been displayed to user.	        */
						/*     (^ - set by help_ when paragraph printed.)	        */

      2 errors aligned,				/* ERRORS detected while locating paragraph content.      */
        3 (long_paragraphS,				/*  - iPgh.line_count >INFO_LINES_PER_PARAGRAPH	        */
           few_blank_lines_before_paragraphS,		/*  - pgh preceded by <INFO_BLANK_LINES_BEFORE_PARAGRAPH  */
						/*    blank or all-white lines.		        */
           many_blank_lines_before_paragraphS		/*  - pgh preceded by >INFO_BLANK_LINES_BEFORE_PARAGRAPH  */
						/*    blank or all-white lines.		        */
           ) bit(1) unal,
         3 pad_errors bit(33) unal,
       iPghP ptr;
	
  dcl  Pgh char(iPghP->iPgh.L) based(iPghP->iPgh.P);	/* Character content of iPghP->iPgh (current paragraph).  */
%page;
/* --------------------------------------------------------------------------------
   DEFINITIONS for sections: 
     section title:               Characters within first line of the section that 
			    precede a COLON (:) character.  If first line 
			    of any paragraph includes a COLON (after 1st char
			    of line), that paragraph begins a new section 
			    of the info segment.

     section of an info segment:  1 or more consecutive paragraphs within an info
			    segment, beginning with either:
			       - paragraph beginning with a non-blank section 
			         title.
			       - paragraph with no section title, but which is
			         first paragraph of the block (it immediately
			         follows block header and 1 or more blank lines 
			         ending that block header). 

   STRUCTURE:  iSect

     Describes the paragraph content of one section within an info segment.
     The first paragraph of most sections begins with a line containing a non-blank
     section title.  Only the first section of a block may have no section title.

   Siblings:
     An iSect may be threaded to a structure describing a higher-level aggregate
     within an info segment.

     iBlok: A section is threaded to iBlok.sects list, containing sections
	  in that block of the info segment.  

   Relatives:
     .blokP: points to info seg block containing this section.
     .pghs:  a threaded list of paragraphs contained in this section.
     .lines: a threaded list of lines contained in this section.
   -------------------------------------------------------------------------------- */

  dcl  Syntax_MAX_PIECES fixed bin int static options(constant) init(10);

  dcl 1 iSect aligned based (iSectP),			/* Structure describing a titled group of paragraphs.     */
      2 common like iCommon,				/*  - ID; pointer to, and length of chars in section;     */
						/*    pointers to next/prev sections within block.        */
      2 relatives,					/*  Section may be child of higher-level structures.      */
        3 blokP ptr,				/*  - points to iBlok containing this section.	        */
        3 listP ptr,				/*  - points to ListP (if any) summarizing Arguments,     */
						/*    Control_args, or Operation names defined in this    */
						/*    section.				        */
        3 help_listP ptr,				/*  ^ points to help_'s LIST (displayable form of listP)  */
						/*     (^ - defaults to null; set by help_)	        */
        3 pghs like iChild,				/*  - list of paragraphs contained in this section.       */
        3 lines like iChild,				/*  - list of lines contained in this section.	        */

      2 line_in_file fixed bin,			/*  - line number (in info seg) on which section begins.  */
      2 line_count fixed bin,				/*  - number of iLine structs in .relatives.lines list.   */
      2 type fixed bin,				/*  - one of the iSect_XXX values below.  Identifies      */
						/*    the section as one having known type and format     */
						/*    of information.			        */
      2 sequence fixed bin,				/*  - verify_info sequence in which section should appear.*/

      2 title,					/*  - section title for this section.		        */
        3 (in_file,					/*     - exactly as it appears in the block (w/o COLON)   */
	 case_adjusted,				/*     - with 1st word having initial-capital, and        */
						/*       subsequent words in lower case.	        */
	 should_be				/*     - possibly restated with preferred wording or      */
						/*       capitalization.  This length should be:	        */
	 ) char(71) var,				/*       >INFO_CHARS_PER_TITLE to allow detection of long */
						/*       titles.				        */
      2 syntax,					/*  - items found in a Syntax... section.	        */
        3 N fixed bin,				/*     - number of items found.		        */
        3 str (Syntax_MAX_PIECES) char(1000) var,		/*     - each item gives syntax for a command/request;    */
						/*       active function/request; or declare and call for */
						/*       a subroutine, or declare and return value assign */
						/*       for a function procedure.		        */

      2 errors aligned,				/* ERRORS detected which locating section contents.       */
						/*     Error comments starting with - are diagnosed by    */
						/*       info_seg_ and its info_seg_parse_ helper.        */
						/*     Error comments starting with + are diagnosed by    */
						/*       verify_info and its info_seg_verify_ helper.     */
        3 (bad_titleS,				/*  - Section title marked BAD (not preferred)	        */
	 blank_titleS,				/*  - Section title is all whitespace.		        */
	 long_titleS,				/*  - Section title length >INFO_CHARS_PER_TITLE	        */
	 unrecognized_titleS,			/*  - Section title not known to info_seg_.	        */
	 untitledS,				/*  - Section title not found in first section of block.  */
						/*     This is not an error, just an unusual circumstance */

	 syntax_title_wrong_for_kindS,		/*  - Syntax... title wrong for block kind.	        */
 	 syntax_for_subroutine_invalidS,		/*  - Syntax: missing declare/dcl or call or = (assign)   */
	 syntax_missing_left_bracketS,		/*  - Syntax as an active... missing [ in line	        */
	 syntax_missing_right_bracketS,		/*  - Syntax as an active... missing ] in line	        */
	 syntax_missing_namesS,			/*  - Syntax... has none of words in block header.        */
	 syntax_missing_short_nameS,			/*  + Syntax... does not use shortest word in block header*/
	 syntax_uses_control_argumentsS,		/*  - Syntax... uses -control_arguments		        */
	 syntax_uses_control_argumentS,		/*  - Syntax... uses -control_argument		        */

	 list_of_ops_bad_namesS,			/*  - List of ... operations: names non-unique or	names   */
						/*			have non-descending length  */
	 list_of_ops_long_nameS,			/*  - List of ... operations: length(name) > 32	        */
	 list_of_ops_nonunique_namesS,		/*  - List of ... operations: all item names not unique   */
	 list_of_ops_op_not_documentedS,		/*  - List of ... operations: some op items have no op    */
						/*			documentation block	        */
	 control_order_bad_listS,			/*  + Control order: line constructed badly.  More than   */
						/* 	           2 names, or nothing before comma.    */
	 control_order_bad_name_orderS,		/*  + Control order: name order differs from entry in     */
						/*                   "List of control operations" section.*/

						/* error checks for Subroutine Introduction:	        */
	 bad_entry_points_inS			/*  + "Entry points in" section formatted incorrectly.    */
	 ) bit(1) unal,
         3 pad_errors bit(15) unal,
         3 display_listS bit(1) unal,			/*  - verify_info displays iList to aid error msgs        */
       iSectP ptr;

  dcl  Sect char(iSectP->iSect.L) based(iSectP->iSect.P);	/* Character content of iSectP->iSect (current section)   */
						/*  as it appears in the info segment.		        */
  dcl 1 Syntax aligned based(SyntaxP),			/* Overlay for just the actual items found in the	        */
      2 N fixed bin,				/*  iSect.syntax.str array.			        */
      2 str (0 refer (Syntax.N)) char(1000) var,
       SyntaxP ptr;
						/* The following table (in info_seg_specifications_.cds)  */
						/* lists known section titles, and their preferred        */
						/* wording (used when prior wordings go out-of-style, or  */
						/* to detect common mistakes in wording).	        */
  dcl  iSect_title_MAXLENGTH_KNOWN_TITLE fixed bin int static options(constant) init(44);

  dcl 1 iSect_title aligned based (addr (info_seg_specifications_$section_titles)),
      2 titles,
        3 titleN fixed bin,
        3 array (0 refer (iSect_title.titles.titleN)),
          4 cmp fixed bin,				/* EQUALS: .title must match exact title in info seg.     */
						/* BEGINS: .title must match start of title in info seg.  */
	4 title char(iSect_title_MAXLENGTH_KNOWN_TITLE) var,
						/* Expected title string.			        */
	4 ilk fixed bin,				/* PREF:    preferred or "recommended" title according to */
						/*          info segment standards.		        */
						/* BAD:     titles used in the past, now disparaged.      */
						/*          Instead use title(sectionID), the 	        */
						/*          sectionIDth title in this array.	        */
	4 sectionID fixed bin;			/* For PREF titles, this is a named constant whose value  */
						/*          is the index of this array entry.	        */
						/* For BAD  titles, this is named constant identifying    */
						/*          the array element now preferred in place of   */
						/*          this title string.		        */
  dcl  info_seg_specifications_$section_titles fixed bin external static;

  dcl (EQUALS, PREF) fixed bin int static options(constant) init(0),
      (BEGINS, BAD ) fixed bin int static options(constant) init(1);


						/* The following table (in info_seg_specifications_.cds)  */
						/* lists known section titles expected in each kind of    */
						/* info block.				        */
  dcl  iSect_sequence_MAX_TITLES fixed bin int static options(constant) init(25);
  dcl  iSect_sequence_MAX_POSITION fixed bin int static options(constant) init(13);

  dcl 1 iSect_sequence aligned based (addr (info_seg_specifications_$section_sequence)),
      2 sequence,
        3 kindN fixed bin,				/* Number of block kinds having "known" section titles    */
        3 array (0 refer (iSect_sequence.sequence.kindN)),	/* Array of sequence info, ordered by iBlok_kind_XXX      */
	4 block_kind fixed bin,			/*  - iBlok_kind_XXX with this "preferred" sequence of    */
						/*    section titles			        */
	4 titleN fixed bin,				/*  - Number of "preferred" section titles for block kind */
	4 title_seq (iSect_sequence_MAX_TITLES),	/* Array of substructures, each holding per-title data    */
	  5 type fixed bin,				/*  - An iSect_XXX title type			        */
	  5 position fixed bin,			/*  - A sequence position in which this title appears     */
						/*    within the block.  Titles with same position form a */
						/*    position group; title may appear in any order       */
						/*    relative to other titles in that same group.        */
						/*    Rule:  1 <= position <= iSect_sequence_MAX_POSITION */
	  5 cardinality fixed bin;			/*  - An iCard_XXX value giving requirements for this     */
						/*    type of title.			        */
  dcl  info_seg_specifications_$section_sequence fixed bin external static;

  dcl 1 iTitle_seq aligned based(iTitle_seqP),		/* Overlay for the defined iSect_sequence.array           */
      2 block_kind fixed bin,				/*  array for a particular kind of info block.	        */
      2 titleN fixed bin,
      2 array (0 refer(iTitle_seq.titleN)) like iSect_sequence.title_seq,
       iTitle_seqP ptr;

						/* Values for iSect_sequence.cardinality(k, i); also      */
						/*            iTitle_seq.cardinality(i)		        */
  dcl (iCard_UNKNOWN              init(-1),		/*  UNKNOWN cardinality (this should never occur)	        */
       iCard_0_ALLOWED            init( 0),		/*  NOT_ALLOWED: title once used, now obsolete/ignored    */
       iCard_1_REQUIRED           init( 1),		/*   1 required: title needed to identify block type, etc */
       iCard_1_ALLOWED            init( 2),		/*   1 allowed : not required, but 1 can be used	        */
       iCard_0_OR_MORE            init( 3),		/*   0 or more : any number of such titles may be used    */
       iCard_1_OR_MORE	    init( 4),		/*   1 or more : at least 1 such title should be used     */
       iCard_1_IN_GROUP_REQUIRED  init( 5),		/*   1 required in group : only 1 of titles in pos group  */
						/*                         can/must be given.	        */
       iCard_1_IN_GROUP_ALLOWED   init( 6)		/*   1 allowed in group  : only 1 of titles in pos group  */
						/*                         can be given.	        */
       ) fixed bin int static options(constant);

  dcl  iCard_string (-1:6) char(21) int static options(constant) init(
        "  UNKNOWN  ",				/*  - Section title's cardinality not known.	        */
        "NOT ALLOWED",				/*  - Section title is not permitted in this kind of info */
        " 1 required",				/*  - Section title required in this kind of info block.  */
        " 1 allowed ",				/*  - Section title not required, but 1 instance allowed. */
        " 0 or more ",				/*  - Any number of such section titles may be used.      */
        " 1 or more ",				/*  - At least one instance of section title must be used */
        " 1 of ORDER required",
        " 1 of ORDER allowed "
        );
						/* Values for iSect.type element; also 		        */
						/*	for iSect_titles.sectionID(n) element; also     */
						/*        for iBlok_kind.method_or_title(n) element; and  */
						/*        for iBlok_kind.second_title(n) element.	        */
  dcl (iSect_ACCESS_REQUIRED			    init( 1),  /* Access required:		 	        */
       iSect_ARGUMENTS			    init( 2),  /* Arguments:				        */
       iSect_ARGUMENTS_FOR_IO_CALL		    init( 3),  /* Arguments for io_call:		        */
       iSect_ARGUMENTS_FOR_IOX_CONTROL		    init( 4),  /* Arguments for iox_$control:		        */
       iSect_ARGUMENTS_FOR			    init( 5),  /* Arguments for ...:			        */
       iSect_ARGUMENTS_SUBSET                         init( 6),  /* Arguments (...):			        */
       iSect_CONTROL_ARGUMENTS		    init( 7),  /* Control arguments:			        */
       iSect_CONTROL_ARGUMENTS_AS_A_COMMAND	    init( 8),  /* Control arguments as a command:		        */
       iSect_CONTROL_ARGUMENTS_AS_A_REQUEST	    init( 9),  /* Control arguments as a request:		        */
       iSect_CONTROL_ARGUMENTS_AS_AN_ACTIVE_FUNCTION  init(10),  /* Control arguments as an active function:	        */
       iSect_CONTROL_ARGUMENTS_AS_AN_ACTIVE_REQUEST   init(11),  /* Control arguments as an active request:	        */
       iSect_CONTROL_ARGUMENTS_FOR_ATTACH_DESCRIPTION init(12),  /* Control arguments for attach description:	        */
       iSect_CONTROL_ARGUMENTS_FOR_OPEN_DESCRIPTION   init(13),  /* Control arguments for open description:	        */
       iSect_CONTROL_ARGUMENTS_FOR_CLOSE_DESCRIPTION  init(14),  /* Control arguments for close description:	        */
       iSect_CONTROL_ARGUMENTS_FOR_DETACH_DESCRIPTION init(15),  /* Control arguments for detach description:	        */
       iSect_CONTROL_ARGUMENTS_FOR		    init(16),  /* Control arguments for ...:		        */
       iSect_CONTROL_ARGUMENTS_SUBSET                 init(17),  /* Control arguments (...):		        */
       iSect_CONTROL_ORDER			    init(18),  /* Control order:			        */
       iSect_ENTRY_POINTS_IN			    init(19),  /* Entry points in SUBROUTINE_NAME:	        */
						     /*    (List is generated by the help command)        */
       iSect_EXAMPLES			    init(20),  /* Examples:				        */
       iSect_FUNCTION			    init(21),  /* Function:				        */
       iSect_LIST_OF_CONTROL_OPERATIONS		    init(22),  /* List of control operations:		        */
       iSect_LIST_OF_CONTROLS			    init(23),  /* List of controls:			        */
       iSect_LIST_OF_ELEMENTS			    init(24),  /* List of elements:			        */
						     /*  [after section "Arguments for iox_$control"]     */
       iSect_LIST_OF_IO_OPERATIONS                    init(25),  /* List of i/o operations:		        */
       iSect_LIST_OF_MODE_STRINGS		    init(26),  /* List of mode strings:			        */
       iSect_LIST_OF_OPENING_MODES		    init(27),  /* List of opening modes:		        */
       iSect_LIST_OF_OPERATIONS		    init(28),  /* List of operations:			        */
       iSect_LIST_OF_REQUESTS			    init(29),  /* List of requests:			        */
       iSect_LIST_OF_ACTIVE_REQUESTS		    init(30),  /* List of active requests:		        */
       iSect_LIST_OF			    init(31),  /* List of ...:			        */
       iSect_NOTES_ON_THE_INFO_PTR		    init(32),  /* Notes on the info ptr:		        */
       iSect_NOTES				    init(33),  /* Notes:				        */
       iSect_NOTES_ON			    init(34),  /* Notes on ...:			        */
       iSect_SYNTAX				    init(35),  /* Syntax:				        */
						     /*  [first section in SUBSYSTEM REQUEST INFO]        */
       iSect_SYNTAX_AS_A_COMMAND		    init(36),  /* Syntax as a command:			        */
       iSect_SYNTAX_AS_AN_ACTIVE_FUNCTION	    init(37),  /* Syntax as an active function:		        */
       iSect_SYNTAX_AS_AN_ACTIVE_REQUEST	    init(38),  /* Syntax as an active request:		        */
       iSect_SYNTAX_OF_ATTACH_DESCRIPTION	    init(39),  /* Syntax of attach description:		        */
       iSect_SYNTAX_OF_OPEN_DESCRIPTION		    init(40),  /* Syntax of open description:		        */
       iSect_SYNTAX_OF_CLOSE_DESCRIPTION	    init(41),  /* Syntax of close description:		        */
       iSect_SYNTAX_OF_DETACH_DESCRIPTION	    init(42),  /* Syntax of detach description:		        */

       iSect_Untitled			    init(43),  /*  [used when there is no section title.]	        */
       iSect_Another_Title			    init(44)   /*  [used if title other than one of those above     */
                                                                 /*   is present.]			        */
       ) fixed bin int static options (constant);
						/* The next three dcls extend constant value range from   */
						/*  list above, but use different name/date convention    */
						/*  for the constants, to reflect their use as...	        */
						/* Values for iBlok_kind.method_or_title(n) element.      */
  dcl (iBlok_method_REFINE_EARLIER_KIND		    init(50),  /* Use 1st section title to possibly change	        */
						     /*  .kind = iBlok_kind_SUBROUTINE_INTRO to	        */
						     /*	       iBlok_kind_SUBROUTINE_BRIEF_INTRO        */
       iBlok_method_NAMES_MAY_TELL_KIND               init(51),  /* Use file/block names to possibly set iBlok.kind   */
       iBlok_method_DATE_BEFORE_1985                  init(52),  /* Use block iso_date to possibly set iBlok.kind     */
       iBlok_method_NAME_summary_topic		    init(53),  /* Look for divider name: summary.topic	        */
       iBlok_method_PATH_subsystem		    init(54)   /* Look for >subsystem> or >ss> in info seg directory*/
       ) fixed bin int static options (constant);
%page;
/* --------------------------------------------------------------------------------
   DEFINITIONS for blocks:
     block:                  Portion of an info segment completely describing:
		         a command or active function; a subroutine or its entrypoints; 
		         a subsystem request or active request; or some other
		         topic of general information; or a history comment for 
		         the info segment.

     block divider line:     Line of an info segment that begins a new block.
		         The first character of each divider line is a COLON (:).
		         The divider line consists of two parts:
		            :Info: probe: pb:  2020-02-27  probe, pb	        
			  \--divider------/  \--header-----------/
		         These parts may appear in 1 line as shown above; or
		         in 2 consecutive lines, with divider on first line and 
		         full header on second line.
		         
		         If the info segment includes only one block, the divider
		         portion of the block divider line may be omitted; only 
		         the header portion is present.
							         
     block divider starter:  One of the following strings that identify the purpose
		         of this block of the info segment:
		           :Info:     begins a block in a multi-block info segment.
		           :[Info]:   begins a block in a multi-block info segment
				  whose divider names are not names on info seg.
			 :Entry:	  begins subroutine entrypoint documentation
			 :hcom:     begins a history comment describing past 
				  updates to the info segment.
			 :Internal: obsolete history comment starter.

   STRUCTURE:  iBlok

     Describes the content of one block within an info segment.  Each info segment
     contains one or more blocks.  If a segment contains no divider starter, then the
     entire segment contents is treated as its only block (a block without the divider
     portion of the block divider line described above).

     Therefore, the first block may begin with or without an :Info: divider section
     in its block divider line.  Subsequent blocks begin with a divider line of some type.

   Siblings:
     An iBlok is threaded to a structure describing a higher-level aggregate.

     iFile: Each iBlok is threaded below an iFile.bloks structure describing blocks
	  within the entire info segment.

   Relatives:
     .fileP: points to iFile containing this block.
     .sects: a threaded list of sections contained in this block.
     .pghs:  a threaded list of paragraphs contained in this block.
     .lines: a threaded list of lines contained in this block.
   -------------------------------------------------------------------------------- */

  dcl 1 iBlok aligned based (iBlokP),			/* Structure describing one block of an info segment.     */
      2 common like iCommon,				/*  - ID; pointer to, and length of chars in block;       */
						/*    pointers to next/prev blocks within info segment.   */
      2 line_in_file fixed bin,			/*  - line number (in info seg) on which block starts.    */
      2 line_count fixed bin,				/*  - number of iLine structs in .relatives.sects list,   */
						/*     + 1 header line & 1 blank line before each section */
      2 seenS bit(1) aligned,				/*  ^ some block paragraphs have been displayed to user . */
						/*     (^ - set by help_ when paragraph printed.)	        */
      2 divider fixed bin,				/*  - records divider line starter string for block       */
						/*    (one of the iBlok_divider_XXX values below).        */
      2 names like iName10,				/*  - names in divider part of the block divider line.    */
						/*     :Info: probe: pb:  2020-02-27  probe, pb	        */
						/*            ^^^^^  ^^			        */
      2 kind fixed bin,				/*  - classification of block by nature of its contents   */
						/*    (one of the iBlok_kind_XXX values below).	        */

      2 header aligned,				/* Every iBlok begins with a header.		        */
        3 str char(100) var,				/*  - full header string as it appears in info segment.   */
						/*       <date> <rest-of-header>		        */
						/*    length(str) must be >INFO_CHARS_PER_HEADER to show  */
						/*    over-long header string.		        */
        3 reformatted,				/*  - reformatted header with:		        */
          4 iso_date char(12) unal,			/*     - <date> portion formatted in iso_date format.     */
          4 rest char(88) unal,			/*     - <rest-of-header>			        */
        3 wordN fixed bin,				/*  - count of initial words found in <rest-of-header>    */
        3 word (5) char(72) var,			/*  - comma-delimited tokens in <rest-of-header>.	        */
						/*       2020-02-27  probe, pb		        */
						/*                   ^^^^^  ^^		        */
						/*    For command/AF and request info blocks:	        */
						/*     - these words are the command/AF/request names.    */
						/*     - All of these words should be in iBlok.names      */
						/*       for such block kinds.		        */
        3 after_header_iLineP ptr unal,			/*  - points to first non-blank iLine that ended header   */
      2 relatives,					/*  Block may be child of higher-level structures.        */
        3 fileP ptr,				/*  - points to iFile containing this block.	        */
        3 multi_operation_listP ptr,			/*  - points to Operation_List describing operations      */
						/*    performed by command/AF/request/AR described in blok*/
						/*    Should be non-null if syntax.multi_operationsS,     */
						/*    syntax.is_operationS is T ("1"b); or if             */
						/*    syntax.request_summaryS or syntax.isRequestS is T.  */
        3 multi_control_listP ptr,			/*  - points to List describing controls performed by     */
						/*    I/O Module described in this blok.                  */
						/*    Should be non-null if syntax.multi_controlsS or     */
						/*    syntax.is_controlS is T.		        */
        3 sects like iChild,				/*  - list of sections contained in this block.	        */
        3 pghs  like iChild,				/*  - list of paragraphs contained in this block.	        */
        3 lines like iChild,				/*  - list of lines contained in this block.	        */

      2 syntax aligned,
        3 (is_function_procedureS,			/* SUBROUTINE ENTRYPOINT: function rather than subroutine */
						/*    requires "Arguments" section even if has no parms   */
	 is_command_requestS,			/* COMMAND or REQUEST			        */
	 is_activeFunction_activeRequestS,		/* ACTIVE FUNCTION (AF) or ACTIVE REQUEST (AR)	        */
	 has_argumentsS,				/* SUBROUTINE ENTRYPOINT, COMMAND or AF, REQUEST or AR:   */
						/*    requires 1 or more "Arguments" sections.	        */
	 has_control_argsS,				/* COMMAND or AF, REQUEST or AR: 		        */
						/*    requires 1 or more "Control arguments" sections.    */
	 has_ellipsisS,				/* SUBROUTINE ENTRYPOINT, COMMAND or AF, REQUEST or AR:   */
						/*    ... requires 1 or more "Arguments" sections.        */
           multi_operationsS,				/* COMMAND or AF, REQUEST or AR, or IO_MODULE	        */
						/*    (with associated IO_OPERATION) does several ops.    */
	 multi_controlsS,				/* IO_MODULE does several controls doc'd as :Info: blocks */
	 request_summaryS,				/* SUBSYSTEM_SUMMARY documents a list of subsystem        */
						/*    request names (the operation_names).  Look for      */
						/*    per-request blocks with header words same as        */
						/*    those operation_names.			        */
	 is_operationS,				/* COMMAND or AF, REQUEST or AR, or IO_OPERATION 	        */
						/*    documents one such op.			        */
						/*    Its header line has the format:		        */
						/*     SHORTEST_COMMAND_NAME LONG_OPERATION_NAME operation*/
						/*    Get SHORTEST_OPERATION_NAME from divider (or from   */
						/*    "List of operations" List of multi_operationsS blok)*/
						/*    and look in each Syntax line for:		        */
						/*      SHORTEST_COMMAND_NAME SHORTEST_OPERATION_NAME ... */
	 is_controlS,				/* IO_CONTROL documents one I/O control operation.        */
						/*    Its header line has the format:		        */
						/*     SHORTEST_COMMAND_NAME LONG_CONTROL_NAME control    */
						/*    Get SHORTEST_OPERATION_NAME from divider (or from   */
						/*    "List of control operations" List of	        */
						/*    multi_controlsS blok.  Look for "Control order:"    */
						/*    section giving just name(s) of control order.       */
	 is_requestS,				/* REQUEST or AR that documents one of the requests in    */
						/*    a "List of requests" section of request_summaryS    */
						/*    blok.  header words must equal operation_names.     */
           has_subsystem_pathS			/* REQUEST or AR residing in segment below substree with  */
						/*    path containing entryname: subsystem or ss	        */
	 ) bit(1) unal,
        3 syntax_pad bit(23) unal,

      2 errors aligned,				/* ERROR possibilities found while parsing for blocks.    */
						/*     Error comments starting with - are diagnosed by    */
						/*       info_seg_ and its info_seg_parse_ helper.        */
						/*     Error comments starting with + are diagnosed by    */
						/*       verify_info and its info_seg_verify_ helper.     */

        3 (few_blank_lines_before_blockS,		/*  - Blok preceded by <INFO_BLANK_LINES_BEFORE_PARAGRAPH */
						/*    blank or all-white lines.		        */
           many_blank_lines_before_blockS,		/*  - Blok preceded by >INFO_BLANK_LINES_BEFORE_PARAGRAPH */
						/*    blank or all-white lines.		        */

	 long_namesS,				/*  - Blok divider name(s) longer than 32 chars.	        */
	 bad_namesS,				/*  - Blok divider name(s) quoted incorrectly.	        */
           no_namesS,				/*  - Blok divider contains no names.		        */
	 many_namesS,				/*  - Blok divider contains too many names.	        */

	 missing_headerS,				/*  - Blok header is missing (zero-length)	        */
	 big_headerS,				/*  - Blok divider/header >INFO_LINES_PER_HEADER long.    */
	 long_headerS,				/*  - Blok header >INFO_CHARS_PER_HEADER in length.       */
	 missing_dateS,				/*  - Blok header does not begin with a date field.       */
	 bad_dateS,				/*  - Blok header contains token in date position with    */
						/*    DATE_CHARS rejected by convert_date_to_binary_      */
	 non_iso_dateS,				/*  - Blok header date is not in iso_date format.	        */

	 older_subr_intro_dateS,			/*  + Blok header date too old; violates rule:	        */
						/*     subroutine_intro_date >= all entrypoint_dates      */
	 bad_subr_intro_headerS,			/*  + Blok header line for subroutine intro ^= REF_NAME_  */
	 bad_subr_headerS,				/*  + Blok header line for subroutine entrypoint name(s)  */
	 bad_subr_epS,				/*  + Blok header subroutine entrypoint not found by      */
						/*     cv_entry_.				        */

	 bad_cmd_af_req_headerS,			/*  + Blok header line for command/AF/request/AR is not a */
						/*     comma-separated list of reference names	        */
	 bad_io_module_headerS,			/*  + Blok header line for IO_Module is not:	        */
						/*     IO_MODULE_NAME I/O Module		        */
	 bad_request_headerS,			/*  - Header words not identical to operation_names in    */
						/*    "List of requests" item for per-request blok.       */

           bad_dividerS,				/*  + Blok :[Info]: divider wrong for block kind	        */
	 bad_divider_namesS,			/*  + Blok_words disagree with Blok_names                 */
	 obsolete_dividerS,				/*  + Blok divider :Internal: obsolete; use :hcom:        */
	 order_divider_namesS,  			/*  + Blok_words order differs from Blok_names order      */

	 no_paragraphsS,				/*  - Blok has header line, but no paragraphs.	        */
	 no_Syntax_sectionS,			/*  - Blok is missing its "Syntax..." section.	        */
	 many_Syntax_sectionsS,			/*  - Blok contains too many "Syntax..." sections.        */
	 needs_ArgumentsS,				/*  - Blok needs an "Arguments" section of some type.     */
	 needs_Control_argumentsS,			/*  - Blok needs "Control arguments" section of some type */

						/* Operation Format errors			        */
	 multi_op_Arguments_missing_op_namesS,		/*  + Blok needs "Arguments" section that lists all       */
						/*    operation names for the syntax.is_operationS block  */
						/*    ordered same as they appear in "List of operations" */
						/*    of associated syntax.multi_operationsS block.       */
	 multi_op_header_bad_cmdReqIOmod_nameS,		/*  + Header word(1) is not short name of cmd/req/IOmod   */
	 multi_op_header_bad_op_nameS,		/*  + Header word(2) is not 1st operation/control name    */
						/*    (in "List of ... operations" item of associated     */
						/*     syntax.multi_operationsS or .multi_controlsS blok).*/
	 multi_op_name_not_listedS,			/*  + Header word(2) not in "List of ... operations".     */

	 bad_section_orderS				/*  - Blok section titles not in preferred order.	        */
	 ) bit(1) unal,
        3 error_pad bit(3) unal,
       iBlokP ptr;
	
  dcl  Blok char(iBlokP->iBlok.L) based(iBlokP->iBlok.P);	/* String of characters described by iBlokP->iBlok        */
						/*  (the current block).			        */

  dcl  Blok_names (iBlokP->iBlok.names.N) char(entrynameL) var based(addr(iBlokP->iBlok.names.nm(1)));
						/* Array of names found in current block's divider.       */
  dcl  Blok_words (iBlokP->iBlok.header.wordN) char(72) var based(addr(iBlokP->iBlok.header.word(1)));
						/* Array of words found in current block's header.        */


						/* The following table (in info_seg_specifications_.cds)  */
						/* gives rules for mapping the 1st or 1st/2nd section     */
						/* titles of a block onto a block kind value.	        */
						/* For example, a Command Info Block begins with a        */
						/* section titled:  Syntax as a command:	        */
  dcl 1 iBlok_kind aligned based (addr (info_seg_specifications_$block_kinds)),
      2 kinds,
        3 kindN fixed bin,				/* Number of rules in the table array.		        */
        3 array (0 refer (iBlok_kind.kinds.kindN)),	/* Elements of the array.			        */
	4 kindID fixed bin,				/*  - iBlok_kind_XXX value to use if block matches the    */
						/*    constraints of this rule.		        */

	4 method_or_title fixed bin,			/*  - Either an iSect_XXX value (section type constraint) */
						/*        or an iBlok_method_XXX value (method for        */
						/*           refining an existing iBlok.kind value).      */

	4 second_title fixed bin,			/*  - If .method_or_title = iBlok_method_XXX	        */
						/*     this is a section title to look for in applying    */
						/*     that method.				        */
						/*    If .method_or_title = iSect_XXX value:	        */
						/*     this is a second iSect_XXX value constraint.       */
						/*     Both section titles must exist as sections 1 & 2   */
						/*     of the block (though the two sections may appear   */
						/*     in either order).			        */
						/*    0: indicates there is no second_title constraint.   */
	4 third_title fixed bin;			/*  - If .method_or_title = iBlok_method_XXX	        */
						/*     this is another section title to look for in       */
						/*     applying that method.			        */
						/*    If .method_or_title = iSect_XXX value:	        */
						/*     this is 0 (no third_title constraint)	        */
						/*     Both section titles must exist as sections 1 & 2   */
						/*     of the block (though the two sections may appear   */
						/*     in either order).			        */
  dcl  info_seg_specifications_$block_kinds fixed bin external static;


						/* The following table (in info_seg_specifications_.cds)  */
						/* gives rules for mapping info seg or block names onto   */
						/* an iBlok_kind_XXX value.			        */
						/* For example, a name ending .gi.info maps to	        */
						/* iBlok_kind_GENERAL_INFO			        */
  dcl 1 iBlok_name  aligned based (addr (info_seg_specifications_$block_kind_names)),
      2 names,
        3 nameN fixed bin,
        3 array (0 refer (iBlok_name.names.nameN)),
	4 name_type fixed bin,			/* An iBlok_name_XXX constant:		        */
						/*  iBlok_name_ENDS: compare name(i) with end portion     */
						/*                   of info seg or block name.	        */
          4 name (2) char(entrynameL) var,		/* name(1) is entryname with .info suffix - as it appears */
						/*         on the info segment.		        */
						/* name(2) is entryname without .info suffix - as it      */
						/*         appears in a block divider name: field.        */
	4 kindID fixed bin;				/* iBlok_kind_XXX constant denoted by this name.	        */
  dcl  info_seg_specifications_$block_kind_names fixed bin external static;

						/* Values for iBlok_names.name_type(n)		        */
  dcl (iBlok_block_name_ENDS 	  init(1),		/*  - block_name ends with given suffix.	        */
       iBlok_name_ENDS          init(2)			/*  - file_name/block_name ends with given suffix.        */
       ) fixed bin int static options(constant);

  dcl (						/* Values for iBlok_names.name array index.	        */
       iBlok_NAME_WITH_info     init(1),		/*  - use name that ends  with .info suffix	        */
       iBlok_NAME_WITHOUT_info  init(2)			/*  - use name not ending with .info suffix	        */
       ) fixed bin int static options(constant);

						/* Values for iBlok.divider element.		        */
						/*  - ID column below is (shorthand) for each divider     */
						/*    in the iFile_structure.spec strings below.	        */
						/* Also, see below: iBlok_token string array	        */

  dcl (						/* ID   description				        */
       iBlok_divider_None                init( 0),	/*  N  No divider starter found.  Only 1st block can have */
						/*     no divider; any other blocks begin with a divider. */
       iBlok_divider_Entry		 init( 1),	/*  E  Divider starter = :Entry: (subroutine entrypoint)  */
       iBlok_divider_Info		 init( 2),	/*  I  Divider starter = :Info:		        */
       iBlok_divider_Info_no_ext_names	 init( 3),	/* [I] Divider starter = :[Info]:		        */
       iBlok_divider_hcom		 init( 4),	/*  H  Divider starter = :hcom:		        */
       iBlok_divider_hcom_obsolete	 init( 5)		/*  H  Divider starter = :Internal: (obsolete)	        */
       ) fixed bin int static options(constant);

						/* Values for the iBlok.kind element.		        */
  dcl (						/* FIRST SECTION TITLE or Block Divider is:	        */
       iBlok_kind_COMMAND                init( 1),	/*  Syntax as a command:			        */
       iBlok_kind_ACTIVE_FUNCTION	 init( 2),	/*  Syntax as an active function:		        */
       iBlok_kind_COMMAND_AF		 init( 3),	/*  [contains previous two kinds, in either order]        */

       iBlok_kind_GENERAL_INFO           init( 4),	/* First title is not one of those specified above.       */
						/* :Info: NAME.gi (or other suffixes)		        */
						/* Segment name:  NAME.gi.info (or other suffixes)        */

       iBlok_kind_SUBROUTINE_INTRO       init( 5),	/*  Function:				        */
       iBlok_kind_SUBROUTINE_BRIEF_INTRO init( 6),	/*  Entry points in <subroutine_name_>:		        */
						/*     (List is generated by the help command)	        */
       iBlok_kind_SUBROUTINE_ENTRY       init( 7),	/*  :Entry: <ep_name>: ...			        */

       iBlok_kind_REQUEST                init( 8),	/*  Syntax:				        */
       iBlok_kind_ACTIVE_REQUEST	 init( 9),	/*  Syntax as an active request:		        */
       iBlok_kind_REQUEST_AR		 init(10),	/*  [contains previous two kinds, in either order]        */
       iBlok_kind_SUBSYSTEM_SUMMARY      init(11),	/*  :Info: summary.topic:			        */
						/*   ...					        */
						/*  List of requests:			        */
       iBlok_kind_SUBSYSTEM_TOPIC        init(12),	/*  :Info: NAME.topic:			        */
						/*   or					        */
						/*  Notes on...				        */

       iBlok_kind_IO_MODULE		 init(13),	/*  Syntax of attach description:		        */
       iBlok_kind_IO_OPERATION	 init(14),	/*  Syntax of open description:		        */
						/*   or					        */
						/*  Syntax of close description:		        */
						/*   or					        */
						/*  Syntax of detach description:		        */
       iBlok_kind_IO_CONTROL		 init(15),	/*  Control order:				        */

       iBlok_kind_HISTORY_COMMENT	 init(16),	/*  :hcom: (a history comment)		        */

       iBlok_kind_Header_Only		 init(17),	/* Block consists only of a header line; no sections      */
						/*  or paragraphs.				        */

       iBlok_kind_Unknown                init(18)		/* Kind of block as yet undetermined.		        */
       ) fixed bin int static options(constant);

  dcl  iBlok_kind_display_string (18) char(36) var int static options(constant) init(
       "Command",					/* iBlok_kind_COMMAND			        */
       "Active Function",				/* iBlok_kind_ACTIVE_FUNCTION			        */
       "Command/Active Function",			/* iBlok_kind_COMMAND_AF			        */
       "General Info",				/* iBlok_kind_GENERAL_INFO			        */
       "Subroutine Introduction",			/* iBlok_kind_SUBROUTINE_INTRO		        */
       "Subroutine Brief Intro",			/* iBlok_kind_SUBROUTINE_BRIEF_INTRO		        */
       "Subroutine Entrypoint",			/* iBlok_kind_SUBROUTINE_ENTRY		        */
       "Subsystem Request",				/* iBlok_kind_REQUEST			        */
       "Subsystem Active Request",			/* iBlok_kind_ACTIVE_REQUEST			        */
       "Subsystem Request/Active Request",		/* iBlok_kind_REQUEST_AR			        */
       "Subsystem Summary",				/* iBlok_kind_SUBSYSTEM_SUMMARY		        */
       "Subsystem Topic",				/* iBlok_kind_SUBSYSTEM_TOPIC			        */
       "I/O Module",				/* iBlok_kind_IO_MODULE			        */
       "I/O Operation",				/* iBlok_kind_IO_OPERATION			        */
       "I/O Control",				/* iBlok_kind_IO_CONTROL			        */
       "History Comment",				/* iBlok_kind_HISTORY_COMMENT			        */
       "HEADER ONLY Info",				/* iBlok_kind_Header_Only			        */
       "UNKNOWN kind of information"			/* iBlok_kind_Unknown			        */
       );


  dcl 1 iBloksN aligned,				/* Count of blocks found in info segment (by divider)     */
        2 version fixed bin,				/*  - Version 2 structure.			        */
        2 counts,
          3 (all,					/*  - count of all blocks.			        */
	   None,					/*  - count of blocks with no divider		        */
	   Entry,					/*  - count of blocks with :Entry: divider	        */
	   Info,					/*  - count of blocks with :Info: divider	        */
	   Info_no_ext_names,			/*  - count of blocks with :[Info]: divider	        */
	   hcom,					/*  - count of blocks with :hcom: divider	        */
	   hcom_obsolete				/*  - count of blocks with :Internal: divider	        */
	   ) fixed bin,
        iBloksN_version_2 fixed bin int static options(constant) init(2);
%page;
/* --------------------------------------------------------------------------------
   STRUCTURE:  iFile

     Describes the content of one info segment.  

   Siblings:
     An iFile is threaded to a structure describing a higher-level aggregate.

     info_seg_data.files: Each iFile.sib is threaded to other iFile structures,
		      all being chained below the info_seg_data structure.

   Relatives:
     .bloks: a threaded list of blocks contained in this info segment.
     .lines: a threaded list of lines contained in this info segment.
   -------------------------------------------------------------------------------- */

  dcl 1 iFile aligned based (iFileP),			/* Structure describing an info_seg to be parsed or       */
						/*  examined by info_seg_ entrypoints.		        */
      2 common like iCommon,				/*  - ID; pointer to, and length of chars in info seg;    */
						/*    pointers to next/prev info segs to be examined.     */
      2 location,					/*  - location of info seg file in Multics file system:   */
        3 dir char(168) unal,				/*     - containing directory pathname		        */
        3 ent char(entrynameL) unal,			/*     - entryname within this directory	        */
        3 uid bit (36),				/*     - unique ID for info segment		        */
      2 names like iName100,				/*  - array of all names on info_seg (including .info)    */
						/*    in the order they would be listed by status -names  */
						/*    or the list command.			        */
      2 relatives,					/*  This highest-level structure has child components:    */
        3 bloks like iChild,				/*  - list of blocks contained in this info segment.      */
        3 lines like iChild,				/*  - list of lines contained in this info segment.       */
      2 caseI fixed bin,				/*  - classification of info seg by its pattern of block  */
						/*    kinds.  caseI is index into iFile_structure.array,  */
						/*    which gives rules for matching file's blocks with   */
						/*    supported block patterns.		        */
      2 structure fixed bin,				/*  - iFile_structure_XXX or iFile_struc_err_XXX value    */
						/*    associated with this caseI classification.	        */
						/*    This maps a supported pattern to a user-friendly    */
						/*    description.	For example:		        */
						/*      Info Segment - with History Comment	        */

      2 errors aligned,				/* ERROR possibilities found while parsing for lines.     */
						/*     Error comments starting with - are diagnosed by    */
						/*       info_seg_ and its info_seg_parse_ helper.        */
						/*     Error comments starting with + are diagnosed by    */
						/*       verify_info and its info_seg_verify_ helper.     */
        3 (all_nulS,				/*  - File contains only NUL (\000) characters.	        */
	 all_white_nulS,				/*  - File contains only HT SP NUL and NL chars.	        */
	 ends_nulS,				/*  - File ends with NUL characters.		        */
	 zero_lengthS,				/*  - File contains no characters.		        */

	 names_missing_info_suffixS,			/*  + File name does not end with .info		        */
	 names_extraS,				/*  + File has names not expected from headers/dividers   */
	 names_missingS,				/*  + File missing some name(s) that are required.        */
	 name_order_warningS			/*  + File name order differs from order predicted        */
						/*    from names in header lines/dividers.	        */
	 ) bit(1) unal,
       iFileP ptr;
	
  dcl  File char(iFileP->iFile.L) unal based(iFileP->iFile.P);
						/* Character contents of entire info segment.	        */

  dcl  File_names (iFileP->iFile.names.N) char(entrynameL) var based(addr(iFileP->iFile.names.nm(1)));
						/* Array of names on current info segment.	        */

  dcl (						/* Values for the iFile.structure element:	        */
						/*  supported patterns of blocks within info segment.     */

       iFile_structure_NO_DIVIDERS 	        init( 1),	/*  - 1 iBlok                 [ A ]		        */
						/*    A)      only iBlok.divider = iBlok_divider_None     */


       iFile_structure_SUBROUTINE    	        init( 2),	/*  - 2 or more iBloks:	[ A  B... ]	        */
						/*    A)     first iBlok.divider = iBlok_divider_None     */
						/*               <subroutine intro description>	        */
						/*    B) all other iBlok.divider = iBlok_divider_Entry    */
						/*               <subroutine entrypoint description>      */

       iFile_structure_INFO_SUBROUTINE_HCOM     init( 3),	/*  - 3 or more iBloks:	[ A  B... C ]	        */
						/*    A)     first iBlok.divider = iBlok_divider_Info     */
						/*               <subroutine intro description>	        */
						/*    B)    middle iBlok.divider = iBlok_divider_Entry    */
						/*               <subroutine entrypoint description>      */
						/*    C)      last iBlok.divider = iBlok_divider_hcom     */
						/*               <history comments>		        */

       iFile_structure_INFO_SUBROUTINE	        init( 4),	/*  - 2 or more iBloks:	[ A  B... ]	        */
						/*    A)     first iBlok.divider = iBlok_divider_Info     */
						/*               <subroutine intro description>	        */
						/*    B) all other iBlok.divider = iBlok_divider_Entry    */
						/*               <subroutine entrypoint description>      */

       iFile_structure_INFO_HCOM	        init( 5),	/*  - 2 or more iBloks:	[ A... B ]	        */
						/*    A)   leading iBlok.divider = iBlok_divider_Info     */
						/*               <info contents>		        */
						/*    B)      last iBlok.divider = iBlok_divider_hcom     */
						/*               <history comments>		        */

       iFile_structure_INFO	    	        init( 6),	/*  - 1 or more iBloks:	[ A... ]		        */
						/*    A)       all iBlok.divider = iBlok_divider_Info     */
						/*               <info contents>		        */

						/* ERROR values for iFile.structure		        */
       iFile_struc_err_UNSET	    	        init( 0),	/*  - structure not yet determined.		        */
       iFile_struc_err_EMPTY_INFO	        init(-1),	/*  - 0 iBlok structures; or 1 iBlok.emptyS	        */
       iFile_struc_err_HCOM_NOT_LAST	        init(-2),	/*  - History Comment block not last in info seg.	        */
       iFile_struc_err_INFO_SUBROUTINE_MIX      init(-3),	/*  - Unknown mixture of :Info: and :Entry: divider types.*/
       iFile_struc_err_1st_INFO_no_ext_names    init(-4),	/*  - 1st block :[Info]: -- it must be :Info:	        */
       iFile_struc_err_MISSING_1st_INFO	        init(-5),	/*  - 1st block no divider; other blocks :Info:	        */
       iFile_struc_err_MISSING_SUBROUTINE_INTRO init(-6),	/*  - all blocks :Entry: (1st block must have no divider) */
       iFile_struc_err_MULTIPLE_HCOM	        init(-7),	/*  - 2 or more History Comments in info seg.	        */
       iFile_struc_err_SUBROUTINE_INFO_MIX      init(-8),	/*  - :Entry: followed by :Info: blocks		        */
       iFile_struc_err_STRUCTURE_UNKNOWN        init(-9)	/*  - Unsupported pattern of block kinds.	        */
       ) fixed bin int static options(constant);

						/* The following table (in info_seg_specifications_.cds)  */
						/* gives rules for known block order patterns within      */
						/* info segments.				        */
  dcl 1 iFile_structure aligned based (addr (info_seg_specifications_$file_structures)),
      2 patterns,
        3 patternN fixed bin,
        3 array (0 refer (iFile_structure.patterns.patternN)),
          4 spec char(19) aligned,			/* - String pictorially describing pattern of dividers.   */
						/*     "3+   I  E...  H  "			        */
						/*      |    |  |     |_ last block is history comment    */
						/*      |    |  |_______ 1 or more :Entry: blocks	        */
						/*      |    |__________ first block is :Info:	        */
						/*      |_______________ 3 or more total blocks	        */

          4 display_label char(54) var,			/* - User-oriented label for this pattern.	        */
          4 structID fixed bin;			/* - An iFile_structure_XXX or iFile_struc_err_XXX value  */
						/*   identifying this block pattern.		        */
  dcl  info_seg_specifications_$file_structures fixed bin external static;

  dcl (iFile_case_UNSET	init( 0)			/* Initial value assigned to iFile.caseI when structure   */
       ) fixed bin int static options(constant);		/*  is first initialized.			        */

%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Structures referenced by the info_seg_ subroutine interface.			        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* --------------------------------------------------------------------------------
   STRUCTURE:  info_seg_data

     Describes data used by commands that invoke info_seg_$XXX routines to parse
     and examine info segments.

     info_seg_ creates an ssu_ standalone invocation to manage storage and generate
     output on behalf of its caller commands.  Its main data item is a list of
     info segments to be examined by info_seg_ (.files substructure).
   -------------------------------------------------------------------------------- */

  dcl 1 info_seg_data aligned based(info_seg_dataP),	/* Structure to hold info_seg_ parser information.        */
      2 version char(11),				/*  - version of this structure: info_seg_data_version_01 */
      2 standalone_invocationS bit(1) aligned,		/*  - T: info_seg_ provided the .sciP value.	        */
						/*    F: Caller provided the .sciP  value.	        */
						/*     - info_seg_$initialize sets bit = (.sciP = null)   */
						/*       so info_seg_$terminate knows whether to cleanup  */
						/*       the ssu_ standalone invocation.	        */
      2 ptrs,
        3 sciP ptr,					/*  - ssu_ invocation pointer.		        */
        3 areaP ptr,				/*  - translator_temp_ extendable no-freeing area pointer.*/
        3 std_areaP ptr,				/*  - standard Multics area (system free area).	        */
      2 relatives,
        3 files like iChild,				/*  - threaded list of iFile structures.	        */
       info_seg_dataP ptr;

  dcl  info_seg_data_version_01 char(11) int static options(constant) init("info_seg_01");
						/* Currently supported version of info_seg_data structure */
%page;
/* -----------------------------------------------------------------
    CHARACTERISTICS of info segments.
   ----------------------------------------------------------------- */

  dcl  info_seg_suffix char(4) int static options(constant) init("info");

						/* TOKEN beginning an info segment BLOCK divider.	        */
						/* See above:  iBlok_divider_XXX constants	        */
  dcl  iBlok_token (0:5)
          init ("",					/*  for block without a divider		        */
	      ":Entry:",				/*  for SUBROUTINE info seg:  each documents 1 entrypoint */
	      ":Info:",				/*  for blocks in  multi-block info segment.	        */
	      ":[Info]:",				/*  for blocks in  multi-block info segment  	        */
						/*    - divider names not copied onto info segment.       */
	      ":hcom:",				/*  for history comment block at end of info segment.     */
	      ":Internal:"				/*  for obsolete history comment block at end of info seg.*/
	      ) char(10) var int static options(constant);

  dcl (						/* LIMIT VALUES for info segments		        */
       INFO_CHARS_PER_LINE 		 init(71),	/*  excludes NL line delimiter char		        */
       INFO_CHARS_PER_HEADER 		 init(71),	/*  excludes NL line delimiter ending info header	        */
       INFO_CHARS_PER_SUBROUTINE_ENTRYPOINT_NAME		/*  PL/I allows 256 char entrypoint_name labels, but      */
				 init(32),	/*    help only supports names up to 32 chars in length.  */
       INFO_CHARS_PER_TITLE 		 init(70),	/*  excludes COLON section title delimiter char	        */
       INFO_LINES_PER_HEADER		 init( 2),	/*  maximum lines in a block divider & header	        */
       INFO_LINES_PER_PARAGRAPH	 init(15),	/*  maximum lines in a paragraph.		        */
       INFO_BLANK_LINES_BEFORE_PARAGRAPH init( 2) 	/*  required blank lines before a paragraph.	        */
       ) fixed bin int static options (constant);	

  dcl (						/* CHARACTER TYPES/GROUPS found in info segments	        */
       BS		 char (1) init (""),		/*  backspace				        */
       COLON         char (1) init (":"),		/*  colon					        */
       HT		 char (1) init ("	"),		/*  horizontal tab				        */
       INFO_DATE_CHARS   
		 char (12) init("0123456789/-"),	/*  digits plus slash and hyphen		        */
       INFO_HEADER_WORD_BREAK
		 char (2) init (" ,"),		/*  SP comma				        */
       INFO_LIST_WORD_BREAK
		 char (2) init (" ,"),		/*  SP comma				        */
       INFO_LINE_INDENT
		 char (2) init ("  "),		/*  SP SP					        */
						/*    Note: many info segs use 3 spaces for indents of    */
						/*    description parts of items in Arguments, 	        */
						/*    Control arguements, and List of ...  sections.      */
       INFO_REQUEST_NAME_CHARS 
		 char (2) init (".?"),		/*  period or question_mark (eg, requests like: ? .. .)   */

       INFO_SECTION_NO_TITLE_FABRICATION		/*  An untitled first section of info block is referred   */
		 char (12) init ("Introduction"),	/*    to (in titles response, etc) with this title.       */

       INFO_SUBROUTINE_INTRO_ENTRY_POINTS_IN_CONTENTS	/*  Contents of subroutine introduction section entitled  */
       		 char (39) init ("(List is generated by the help command)"),

       LEFT_BRACKET  char (1) init ("["),		/*  left-bracket				        */
       NL		 char (1) init ("
"			      ),			/*  newline				        */
       NUL	 char (1) init (" "),		/*  nul character				        */
       QUOTE	 char (1) init (""""),		/*  quote-mark character			        */
       RIGHT_BRACKET char (1) init ("]"),		/*  right-bracket				        */
       SP		 char (1) init (" "),		/*  space	character				        */
       WHITE_SPACE	 char (2) init ("	 "),		/*  HT SP					        */

       LOWER_CASE	 char (26) init("abcdefghijklmnopqrstuvwxyz"),
       UPPER_CASE	 char (26) init("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
						/*  characters for translating from upper to lowercase    */

       INFO_PRINTABLE char (98)			/*  characters that can be used in an info segment.       */
          init ("	"			/*  begins with BS HT NL 			        */
             || "
"            || " !""#$%&'()*+,-./0123456789:;<=>?"	/*  includes SP, with double-quote (") char escaped       */
             || "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_"
             || "`abcdefghijklmnopqrstuvwxyz{|}~"		/*  ends without DEL char			        */
                )
       ) int static options (constant);

/*  END OF:	info_seg_dcls_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
