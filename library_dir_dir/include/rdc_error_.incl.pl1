	/* START OF:	rdc_error_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

     dcl	MERROR_SEVERITY		fixed bin init (0),	/* Severity of highest-severity error.		*/
	SERROR_CONTROL		bit(2) init ("00"b),/* Global switches control error message format.	*/
	SERROR_PRINTED (dimension (error_control_table,1))
				bit(1) unaligned init ((dimension (error_control_table,1))(1)"0"b),
						/* Array bit is on if corresponding error message	*/
						/* in error_control_table has already been printed*/
	MIN_PRINT_SEVERITY		fixed bin init (0), /* Mimimum severity message that will be printed	*/
	PRINT_SEVERITY_CONTROL	bit(2) init ("11"b);/* Action if severity < MIN_PRINT_SEVERITY	*/

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* N__a_m_e:  rdc_error_.incl.pl1							*/
	/*									*/
	/*      This include segment is used by compilers generated by the reduction_compiler.	*/
	/* It defines a procedure which the compilers can use to print error messages.  	*/
	/*									*/
	/* E__n_t_r_y:  ERROR								*/
	/*									*/
	/*      Given an error number, this procedure prints a corresponding error message.	*/
	/* The message is stored in a compiler-defined error_control_table, along with an integer	*/
	/* which specifies the severity level of the error, and a switch which specifies whether	*/
	/* the source statement in which the error occurred (if any) should be printed after the	*/
	/* error message.  The printing of the error message may be supressed for all messages	*/
	/* having a severity less than a specified (MIN_PRINT_SEVERITY) value.  The ERROR	*/
	/*  procedure calls the lex_error_ subroutine to perform the formatting and printing of	*/
	/*  the error message.							*/
	/*									*/
	/* U__s_a_g_e									*/
	/*									*/
	/*      call ERROR (error_number);						*/
	/*									*/
	/* 1) error_number	is the index of one of the structures in the error_control_table	*/
	/*		which defines the error message to be printed.			*/
	/*									*/
	/* N__o_t_e_s									*/
	/*									*/
	/*      The format of the error_control_table is shown below.			*/
	/*									*/
	/*   dcl	1 error_control_table (2)	aligned internal static,			*/
	/*	  2 severity		fixed bin(17) unaligned init (2,3),		*/
	/*	  2 Soutput_stmt		bit(1) unaligned initial ("0"b,"1"b),		*/
	/*	  2 message		char(252) varying initial (			*/
	/*		"The reduction source segment does not contain any reductions.",	*/
	/*		"Reduction label  '^a'  is invalid."),				*/
	/*	  2 brief_message		char(100) varying initial (			*/
	/*		"", "'^a'");						*/
	/*									*/
	/* error_control_table is an array of structures, with one array element per error.	*/
	/* Each structure contains: a severity level for the error; a switch which specifies	*/
	/* whether the source statement being processed should be output after the error message;	*/
	/* the long form of the error message text;  and the brief form of the error message text.*/
	/* The dimension of the error_control_table array of structures, and the lengths of	*/
	/* message (long message) and brief_message (brief message), are compiler-defined.	*/
	/* structures and the lengths of the message and brief_message are compiler-defined.	*/
	/* The only requirement is that the messages be 256 characters or less in length.	*/
	/* (Remember that the longest character string which can be used in an initial attribute	*/
	/* is 254 characters in length.)						*/
	/*									*/
	/*      The severity number causes the error message to be preceded by a herald which	*/
	/* includes one of the following prefixes:					*/
	/*									*/
	/*       _s_e_v  _p_r_e_f_i_x 		  _e_x_p_l_a_n_a_t_i_o_n				*/
	/*	0 = COMMENT		- this is a comment.			*/
	/*	1 = WARNING		- a possible error has been detected.  The	*/
	/*				  compiler will still generate an object segment.	*/
	/*	2 = ERROR			- a probable error has been detected.  The	*/
	/*				  compiler will still generate an object segment.	*/
	/*	3 = FATAL ERROR		- an error has been detected which is so severe 	*/
	/*				  that no object segment will be generated.	*/
	/*	4 = TRANSLATOR ERROR	- an error has been detected in the operation of	*/
	/*				  the compiler or translator.  No object segment	*/
	/*				  will be generated.			*/
	/*									*/
	/* Full error messages are of the form:						*/
	/*									*/
	/*	_p_r_e_f_i_x _e_r_r_o_r__n_u_m_b_e_r, SEVERITY _s_e_v_e_r_i_t_y IN STATEMENT _n OF LINE _m		*/
	/*	_t_e_x_t__o_f__e_r_r_o_r__m_e_s_s_a_g_e						*/
	/*	SOURCE:								*/
	/*	_s_o_u_r_c_e__s_t_a_t_e_m_e_n_t							*/
	/*									*/
	/* If only one statement appears in line _m, then "STATEMENT _n OF" is omitted.		*/
	/* If the source statement has been printed in a previous error message, it is omitted.	*/
	/*									*/
	/*      The reduction compiler declares a bit string, SERROR_CONTROL, which controls the	*/
	/* text of an error message.  The compiler may set this bit string, as shown below.	*/
	/*									*/
	/*   SERROR_CONTROL		_m_e_a_n_i_n_g						*/
	/*	"00"b		the first time a particular error occurs, the long message	*/
	/*			is printed; the brief message is used in subsequent	*/
	/*			occurrences of that error.				*/
	/*        "10"b or "11"b	the long error message is always used.			*/
	/*	"01"b		the brief error message is always used.			*/
	/* The initial value of SERROR_CONTROL is "00"b.					*/
	/*									*/
	/*      The reduction_compiler creates a declaration for SERROR_PRINTED, an array	*/
	/* of switches (one per error).  The switch corresponding to a particular error is	*/
	/* turned on whenever the error message is printed.  This allows lex_error_ to detect	*/
	/* subsequent occurrences of that same error.					*/
	/*									*/
	/*      The reduction_compiler creates MERROR_SEVERITY, a fixed bin(17) integer		*/
	/* in which the severity of the highest-severity error encountered is maintained.	*/
	/* The compiler may reference this integer.					*/
	/*									*/
	/*      The reduction_compiler creates MIN_PRINT_SEVERITY, a fixed bin (17) integer	*/
	/* which controls the printing of error messages by the ERROR procedure.		*/
	/* Errors having a severity less than MIN_PRINT_SEVERITY will not cause lex_error_ to be	*/
	/* and no error will be printed.  The behaviour of the ERROR procedure for such errors	*/
	/* is controlled by the value of PRINT_SEVERITY_CONTROL, described below.		*/
	/* The compiler may set the value of MIN_PRINT_SEVERITY; its initial value is 0.	*/

	/*									*/
	/*      The reduction_compiler declares a bit string, PRINT_SEVERITY_CONTROL, which 	*/
	/* controls the updating of MERROR_SEVERITY and SERROR_PRINTED when the severity of an	*/
	/* error is less than MIN_PRINT_SEVERITY.  In such cases, the lex_error_ procedure is not	*/
	/* invoked, and the ERROR procedure must update these values as though lex_error_ were	*/
	/* called.  The compiler may set this bit string, as shown below.			*/
	/*									*/
	/* PRINT_SEVERITY_CONTROL	_m_e_a_n_i_n_g						*/
	/*	"00"b		update neither SERROR_PRINTED nor MERROR_SEVERITY.	*/
	/*	"01"b		update SERROR_PRINTED to reflect the error.		*/
	/*	"10"b		update MERROR_SEVERITY to reflect the error severity.	*/
	/*	"11"b		update SERROR_PRINTED and MERROR_SEVERITY appropriately.	*/
	/*The initial value of PRINT_SEVERITY_CONTROL is "11"b.				*/
	/*									*/
	/*      The ERROR procedure is simple to use, but it does limit the flexibility of the	*/
	/* error message.  A compiler action routine can output more flexible error messages	*/
	/* by calling lex_error_ directly.  See lex_error_ documentation for more details.	*/
	/*									*/
	/* S__t_a_t_u_s									*/
	/*									*/
	/* 0) Created:  April, 1974 by G. C. Dixon					*/
	/* 1) Modified: April, 1982 by E. N. Kittlitz.  Added MIN_PRINT_SEVERITY, 		*/
	/*		PRINT_SEVERITY_CONTROL.					*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

ERROR:	procedure (Nerror);

     dcl	Nerror			fixed bin;	/* Number of the error which was detected. (In)	*/

     dcl	Pstmt			ptr,
	1 erring_token		aligned based (Perring_token) like token,
	Perring_token		ptr,
	erring_token_value		char(erring_token.Lvalue) based (erring_token.Pvalue);

     dcl 	(max, null)		builtin;

     dcl	lex_error_		entry options (variable);


	if error_control_table.severity(Nerror) < MIN_PRINT_SEVERITY then do; /* don't print		*/
	     if PRINT_SEVERITY_CONTROL & "1"b then	/* update MERROR_SEVERITY			*/
		MERROR_SEVERITY = max (MERROR_SEVERITY, error_control_table.severity(Nerror));
	     if PRINT_SEVERITY_CONTROL & "01"b then	/* update SERROR_PRINTED			*/
		SERROR_PRINTED(Nerror) = "1"b;
	     return;
	end;
	Perring_token = Pthis_token;			/* address the current erring_token.		*/
	if error_control_table.Soutput_stmt(Nerror) then
	     if Perring_token = null then
		Pstmt = null;
	     else
		Pstmt = erring_token.Pstmt;		/* address the statement descriptor.		*/
	else
	     Pstmt = null;
	if Perring_token = null then
	     call lex_error_ (Nerror, SERROR_PRINTED(Nerror), (error_control_table.severity(Nerror)),
		MERROR_SEVERITY, Pstmt, Perring_token, SERROR_CONTROL, (error_control_table.message(Nerror)),
		(error_control_table.brief_message(Nerror)));
	else
	     call lex_error_ (Nerror, SERROR_PRINTED(Nerror), (error_control_table.severity(Nerror)),
		MERROR_SEVERITY, Pstmt, Perring_token, SERROR_CONTROL, (error_control_table.message(Nerror)),
		(error_control_table.brief_message(Nerror)), erring_token_value, erring_token_value, erring_token_value);

	end ERROR;

	/* END OF:	rdc_error_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
