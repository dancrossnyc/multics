/* START OF:	rdc_delete_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* N__a_m_e:  rdc_delete_.incl.pl1						*/
	/*									*/
	/*      This include segment is used by compilers generated by the reduction_compiler.	*/
	/* It defines a procedure which the compilers can use to delete tokens from their list of	*/
	/* input tokens.								*/
	/*									*/
	/* E__n_t_r_y:  DELETE								*/
	/*									*/
	/*      DELETE removes the input tokens identified by the starting and ending number	*/
	/* arguments from the list of input tokens.					*/
	/*									*/
	/* U__s_a_g_e									*/
	/*									*/
	/*      call DELETE (start, end);						*/
	/*									*/
	/* 1) start    is the number relative to the token identified by Pthis_token of the first	*/
	/*             token to be removed from the list. (In)				*/
	/* 2) end      is the number relative to the token identified by Pthis_token of the last	*/
	/*             token to be removed from the list. (In)				*/
	/*									*/
	/* N__o_t_e_s									*/
	/*									*/
	/*      The token identified by Pthis_token is regarded as token number 0.  Tokens	*/
	/* which precede it have negative numbers, and those which follow have positive numbers.	*/
	/*									*/
	/*      If the token identified by Pthis_token is one of those which are deleted, then	*/
	/* the first token in the list following those which have been deleted will be identified	*/
	/* by Pthis_token.  If in 'PUSH DOWN LANGUAGE' mode and there are no tokens following	*/
	/* those which have been deleted, then the first token preceding those which have been	*/
	/* deleted will be indentified by Pthis_token.					*/
	/*									*/
	/*      Note that DELETE(0,0) in 'PUSH DOWN LANGUAGE' mode has the effect of popping the	*/
	/* token off the top of the stack, and pushing a new token onto the stack in its place.	*/
	/*									*/
	/* S__t_a_t_u_s									*/
	/*									*/
	/* 0) Created by:  G. C. Dixon  in  February, 1975.				*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


DELETE:	procedure (Astart, Aend);

     dcl (Astart, Aend)		fixed bin;

     dcl (start, end)		fixed bin;	/* copies of our input arguments.		*/

	if Pthis_token = null then return;		/* If input list already exhausted, cannot delete.*/
	if Astart > Aend then do;			/* reverse input args if backwards.		*/
	     start = Aend;
	     end   = Astart;
	     end;
	else do;
	     start = Astart;
	     end   = Aend;
	     end;
	Ptoken = Pthis_token;			/* make sure these pointers are the same.	*/

	if start > 0 then call delete_positive (start, end);
						/* deleted tokens all follow Pthis_token.	*/
	else if end < 0 then call delete_negative (start, end);
						/* deleted tokens all precede Pthis_token.	*/
	else do;					/* deleted tokens include Pthis_token.		*/
	     if start < 0 then call delete_negative (start, -1);
						/* first, delete those which precede Pthis_token.	*/
	     if end > 0 then call delete_positive (1, end);
						/* then, delete those which follow Pthis_token.	*/
	     if token.Pnext = null then		/* if no more tokens follow Pthis_token,	*/
		if SPDL then			/*   and in 'PUSH DOWN LANGUAGE' mode,		*/
		     if token.Plast = null then	/*   and no more tokens precede Pthis_token, 	*/
			Ptoken = null;		/*   then all tokens have been deleted.		*/
		     else do;
			Ptoken = token.Plast;	/*   else still tokens on stack.  2nd top of stack*/
			token.Pnext = null;		/*   becomes top, and old top is deleted.	*/
			end;
		else Ptoken = null;			/*   not in 'PUSH DOWN LANGUAGE' mode; remaining	*/
						/*   tokens have been deleted.		*/
	     else do;				/* if there is a following token, make it be	*/
		Ptoken = token.Pnext;		/*   identified by Pthis_token, and delete the	*/
		call delete_negative (-1, -1);	/*   old Pthis_token.			*/
		end;
	     Pthis_token = Ptoken;
	     end;
	return;


delete_positive:	procedure (start, end);		/* This entry deletes tokens following Pthis_token*/

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* The procedure below handles deletion of tokens which precede and follow Pthis_token	*/
	/* in the same way by mapping the starting and ending token numbers into an inner and	*/
	/* outer token number, as shown below.						*/
	/*									*/
	/* 	NZ -> NZ -> NZ -> NZ -> NZ -> NZ -> NZ -> NZ -> NZ -> NZ -> NZ -> NZ -> NZ -> NZ -> NZ	*/
	/*                                           A|					*/
	/*                                           |					*/
	/*             A|              A|         Pthis_token    A|                        A|	*/
	/*             |              |                        |                        |	*/
	/*           start           end                     start                     end	*/
	/*           outer          inner                    inner                    outer	*/
	/*									*/
	/* This mapping allows preceding and following tokens to be deleted in the same way.	*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


     dcl (start, end)		fixed bin;

     dcl	1 token			based,		/* overlay for token converting token.Pnext/last	*/
	  2 pad			fixed bin,	/*   to a 2-element pointer array.		*/
	  2 P (1:2)		ptr unaligned,
         (Pinner, Pouter)		ptr,		/* pointers to inner/outer tokens.		*/
         ( inner,  outer)		fixed bin,	/* #s of inner/outer tokens (wrt Pthis_token)	*/
         (    in,  out  )		fixed bin,	/* elements of token.P for next inner/outer token	*/
	direction			fixed bin,	/* increment added to inner # to reach outer #.	*/
	i			fixed bin;	/* a do-group index.			*/
	inner = start;	outer = end;
	   in = 2;	  out = 1;
		direction = +1;

	go to common;

delete_negative:	entry (start, end);			/* This entry deletes tokens preceding Pthis_token*/

	inner = end;	outer = start;
	   in = 1;	  out = 2;
		direction = -1;

common:	Pinner = Ptoken;				/* start at Pthis_token.			*/
	do i = direction to inner by direction while (Pinner ^= null);
	     Pinner = Pinner -> token.P(out);		/* work out from Pthis_token until inner token is	*/
	     end;					/*   found.				*/
	if Pinner ^= null then do;			/* if inner token doesn't exist, nothing to delete*/
	     Pouter = Pinner;			/* starting at inner token, work out to outer one.*/
	     do i = inner+direction to outer by direction while (Pouter ^= null);
		Pouter = Pouter -> token.P(out);
		end;
	     if Pouter = null then			/* if outer token not found, delete all tokens 	*/
						/*   from inner one to outer-most.		*/
		Pinner -> token.P(in) -> token.P(out) = null;
	     else do;				/* otherwise, delete inner to outer token.	*/
		Pinner -> token.P(in) -> token.P(out) = Pouter -> token.P(out);
		if Pouter -> token.P(out) ^= null then
		     Pouter -> token.P(out) -> token.P(in) = Pinner -> token.P(in);
		end;
	     end;

	end delete_positive;

	end DELETE;

/* END OF:	rdc_delete_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
