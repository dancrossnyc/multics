/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */


lib_output_node_:	procedure;

     dcl						/*	parameters			*/
	ASrequirements		bit(72) aligned,	/* requirements bits determine output fields.	*/
	level			fixed bin(35),	/* indentation level at which node is to be	*/
						/* printed in the listing. (In)		*/
	Inode			fixed bin,	/* number of this node in the node list. (In)	*/
	Pprev_parent		ptr,		/* ptr to parent node of previous node which 	*/
						/*   was output. (In)			*/
	name			char(32),		/* name to be used in the cross reference	*/
						/* entry. (In)				*/
	path			char(168) varying;	/* path name to be used in the cross reference	*/
						/* entry. (In)				*/

     dcl	Iaccess_string (8)		fixed bin,	/* starting indices of 50-char chunks of access	*/
	Iacl			fixed bin,	/* number of ACL entries which have been output.	*/
						/*   string.				*/
	Idir_iacl			fixed bin,	/* number of directory IACLe output.		*/
	Iiacl			fixed bin,	/* number of segment   IACLe output.		*/
	Iname			fixed bin,	/* number of names which have been output.	*/
	Laccess_string		fixed bin,	/* length of non-blank portion of access string.	*/
	Lacl			fixed bin,	/* length of ACL we are outputting.		*/
	Lname			fixed bin,	/* length of the name field in the output, 	*/
	Llevel			fixed bin,	/* length of level field (in characters).	*/
						/* adjusted for indentation level.		*/
	Nindent			fixed bin,	/* number of spaces that names at this level are	*/
						/* to be indented.				*/
	Sfield_blank		bit(1) aligned init ("0"b),
						/* on if all node fields which can be put in 	*/
						/* right-hand column have been output.		*/
	Scleanup			bit(1) aligned init ("0"b),
						/* on if entered at the $cleanup entry point.	*/
	Sinfo			bit(1) aligned init ("0"b),
						/* on if output to go to user's terminal.	*/
	Snames_first		bit(1) aligned init ("0"b),
						/* on if all names to be output first.		*/
	1 Squota			aligned,		/* switches dealing with output of quota info.	*/
	  2 master_dir		bit(1) unal,	/*   on if master directory to be output.	*/ 
	 (2 quota,				/*   on if quota to be output.		*/
	  2 quota_used,				/*   on if quota used to be output.		*/
	  2 terminal_account,			/*   on if terminal account switch to be output.	*/
	  2 Ninf,					/*   on if number of inf directories with quota...*/
	  2 trp,					/*   on if time/record product to be output.	*/
	  2 dttrp)		bit(1) unal,	/*   on if date-time time/record product to be out*/
	Stpd			bit(1) aligned,	/* on if transparent paging dev switch  output	*/

	access_string		char(300),	/* character representation of an access class.	*/
	aim			char(100) varying,	/* character representation of AIM access switches*/
	attributes		char(100) varying,	/* object segment attributes string.		*/
	code			fixed bin(35),	/* a status code.				*/
	dir			char(168) varying,	/* dir part of a node's path name.		*/
	e			fixed bin,	/* entry point indicator for out_ch proc.	*/
	ent			char(32) varying,	/* entry part of a node's path name.		*/
	field			char(108),	/* character string output in right-hand column.	*/
	flag			char(1) aligned,	/* library_cleanup entry deletion flag.		*/
	i			fixed bin,	/* a string index.				*/
	iacc			fixed bin,	/* do-group index used in processing access string*/
	iacle			char(104),	/* character string containing IACL entries.	*/
	level_suppressed		bit(1) aligned,	/* on if no level field to be put into output line*/
	long			char(100),	/* an error message character string.		*/
	lvname			char(32),		/* a logical volume name.			*/
	lv_name			char(32) varying,	/* lvname without trailing blanks.		*/
	mode			char(4),		/* a mode character string.			*/
	pvname			char(32),		/* a physical volume name.			*/
	pv_name			char(32) varying,	/* pvname without trailing blanks.		*/
	rbs			char(12) varying,	/* a ring bracket character string.		*/
	saved_Iname		fixed bin,	/* save value of Iname across a test.		*/
	short			char(8),		/* an abbreviated error message char string.	*/
	type			char(20);		/* a character node type.			*/

     dcl (addr, binary, dimension, index, length, max, min, null, search, string, substr, reverse, verify)
				builtin;

     dcl						/*	entries				*/
	convert_authorization_$to_string_short entry (bit(72) aligned, char(*), fixed bin(35)),
	convert_binary_integer_$long_octal_string
				entry (fixed bin(71)) returns (char(25) varying),
	convert_binary_integer_$octal_string
				entry (fixed bin(35)) returns (char(13) varying),
	convert_status_code_	entry (fixed bin(35), char(8), char(100)),
         (cv_acl			variable,
	cv_acl_,
	cv_dir_acl_)		entry (ptr, fixed bin, char(*), fixed bin, bit(*)),
	date_time_		entry (fixed bin(71) aligned, char(*) aligned),
	date_time_$fstime		entry (bit(36), char(*) aligned),
	ioa_$ioa_switch		entry options (variable),
	lib_next_name_		entry (bit(72) aligned, ptr, fixed bin, ptr) returns (char(32)),
	lib_node_path_		entry (ptr, char(168) varying, char(32) varying),
	mdc_$find_lvname		entry (bit(36), char(*), fixed bin(35)),
	mdc_$find_volname		entry (bit(36), char(*), char(*), fixed bin(35));

     dcl						/*	static variables			*/
	FT (0:1)			char(5) int static init ("false", "true"),
	1 null_name_descriptor	aligned int static options(constant),
						/* a fake name descriptor which has no names.	*/
	  2 length		fixed bin(17) unal init (5),
	  2 version		fixed bin(17) unal init (1),
	  2 T			fixed bin init (1),
	  2 Pnext			ptr init (null),
	  2 N			fixed bin init (0),	/* no names in name array.			*/
	1 null_user_descriptor	aligned int static options(constant),
						/* a fake user descriptor which has no info.	*/
	  2 length		fixed bin(17) unal init (5),
	  2 version		fixed bin(17) unal init (1),
	  2 T			fixed bin init (6),
	  2 Pnext			ptr init (null),
	  2 L			fixed bin init (0),	/* no user information.			*/
	status_data_$dir_mode (0:7)	char(4) varying aligned ext static,
						/* array which maps directory mode into a 	*/
						/* printable string.			*/
	status_data_$mode (0:7)	char(4) varying aligned ext static,
						/* array which maps segment/msf/archive mode into	*/
						/* a printable string.			*/
	sys_info$max_seg_size	fixed bin(35) ext static;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


cleanup:	entry	(Pfcb, Pnode, ASrequirements, level, Pstarname, Inode, Pprev_parent);

	Scleanup = "1"b;

info:	entry	(Pfcb, Pnode, ASrequirements, level, Pstarname);

	Sinfo = "1"b;				/* output directed to user's terminal.		*/

map:	entry	(Pfcb, Pnode, ASrequirements, level, Pstarname);

print:	entry	(Pfcb, Pnode, ASrequirements, level, Pstarname);
						/* format for printing on the online printer.	*/

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* SET UP REQUIREMENTS BITS WHICH WILL DRIVE OUTPUT OF THE VARIOUS FIELDS:		*/
	/* 1) And requirements bits from node with those in our argument list; put result in our	*/
	/*    bit string we can overlay and modify as we like without harm.			*/
	/* 2) Turn off selected output bits to suppress "standard" data (zero bit count, bit	*/
	/*    count author = author, etc).						*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	Srequirements = node.Sreq & ASrequirements;	/* copy req bits to overlay with structure.	*/

	if S.dtc | S.compiler_name | S.compiler_version | S.compiler_options | S.object_info then
		  				/* Don't tell user an object segment isn't	*/
	     S.not_ascii = "0"b;			/*   printable.				*/
	if S.copy then				/* if user wants to know about the copy switch,	*/
	     S.copy = node.Scopy;			/* but it is not on, then don't mention it.	*/
	if S.safety then				/* do same for safety switch setting.		*/
	     S.safety = node.Ssafety;
	if S.records_used then			/* if user wants to know about records used and	*/
	     if S.current_length then			/* about current length, and if these two values	*/
		if node.records_used = node.current_length then
		     S.records_used = "0"b;		/* are equal, then don't mention records used.	*/
	if S.max_length then			/* output max length only if different from	*/
	     if node.max_length = sys_info$max_seg_size then
		S.max_length = "0"b;		/*  the maximum segment size.			*/
	if S.quota then do;				/* Set output switches for quota elements.	*/
	     string(Squota) = ""b;
	     Squota.master_dir = node.Smaster_dir;
	     if node.segment.quota_used ^= 0 | node.directory.quota_used ^= 0 then Squota.quota_used = "1"b;
	     if node.segment.quota ^= 0 | node.directory.quota ^= 0 then do;
		Squota.quota = "1"b;
		Squota.terminal_account = node.Sterminal_account | node.Sterminal_account_dir;
		if node.segment.Ninf_quota ^= 0 | node.directory.Ninf_quota ^= 0 then Squota.Ninf = "1"b;
		Squota.trp = "1"b;
		Squota.dttrp = "1"b;
		end;
	     end;
	else string(Squota) = "0"b;
	if S.bit_count_author then			/* suppress bit count author if same as author.	*/
	     if S.author then
		if node.bit_count_author = node.author then
		     S.bit_count_author = "0"b;
	if S.aim then				/* suppress AIM switch settings if not on.	*/
	     S.aim = node.Saim_security_oos | node.Saim_audit | node.Saim_multiple_class;
	if S.lvid then				/* suppress TPD switch if not on.		*/
	     Stpd = node.Stpd;
	else Stpd = "0"b;


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* ADDRESS DESCRIPTORS FOR VARIABLE-LENGTH or OPTIONAL INFORMATION CHAINED OFF THE NODE.	*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if Svalid.names then			/* access the name descriptor, if it exists.	*/
	     do PDnames = node.PD repeat Dnames.Pnext while (Dnames.T ^= Tnames);
		end;
	else
	     PDnames = addr (null_name_descriptor);	/* otherwise, fake a null name descriptor.	*/
	if S.dtc | S.compiler_name | S.compiler_version | S.compiler_options | S.object_info then
						/* address object info descriptor, if need be.	*/
	     do PDobj = node.PD repeat Dobj.Pnext while (Dobj.T ^= Tobj);
		end;
	if S.root_search_proc then			/* address the search_proc info descriptor.	*/
	     do PDsearch_proc = node.PD repeat Dsearch_proc.Pnext while (Dsearch_proc.T ^= Tsearch_proc);
		end;
	if S.user then				/* address user info descriptor, if need be.	*/
	     do PDuser = node.PD repeat Duser.Pnext while (Duser.T ^= Tuser);
		end;
	if S.kids_error then			/* address node array descriptor, if needed.	*/
	     do PDnodes = node.PD repeat Dnodes.Pnext while (Dnodes.header.T ^= Tnodes);
		end;
	if S.acl then do;				/* address ACL descriptor.			*/
	     if node.T = Tdirectory then do;
		do PDdir_acl = node.PD repeat Ddir_acl.Pnext while (Ddir_acl.T ^= Tdir_acl);
		     end;
		PDacl = PDdir_acl;			/* cheat by treating directory ACL descriptor	*/
		cv_acl = cv_dir_acl_;		/*   as segment ACL descriptor, and letting the	*/
		end;				/*   conversion routine worry about differences.	*/
	     else do;
		do PDacl = node.PD repeat Dacl.Pnext while (Dacl.T ^= Tacl);
		     end;
		cv_acl = cv_acl_;
		end;
	     end;
	if S.iacl then do;				/* address segment/directory IACL descriptors.	*/
	     do PDiacl = node.PD repeat Diacl.Pnext while (Diacl.T ^= Tiacl);
		end;
	     do PDdir_iacl = node.PD repeat Ddir_iacl.Pnext while (Ddir_iacl.T ^= Tdir_iacl);
		end;
	     end;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* DO COMPLICATED FIELD CONVERSIONS BEFORE STARTING THE OUTPUT.			*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if S.mode then
	     if node.T = Tdirectory then
		mode = status_data_$dir_mode (binary (node.Smode, 3));
	     else
		mode = status_data_$mode (binary (node.Smode, 3));
	if S.rb then do;
	     rbs = cv_dec(binary(node.rb(1), 35)) || ", ";
	     rbs = rbs || cv_dec(binary(node.rb(2), 35));
	     if node.T ^= Tdirectory then do;
		rbs = rbs || ", ";
		rbs = rbs || cv_dec(binary(node.rb(3), 35));
		end;
	     end;
	if S.access_class then do;
		call convert_authorization_$to_string_short (node.access_class, access_string, code);
		if code ^= 0 then do;
bad_access_class:        call convert_status_code_ (code, short, long);
		     access_string = "Error -  " || long;
		     Laccess_string = length(access_string) - verify (reverse (access_string), " ") + 1;
		     end;
		if access_string = "" then S.access_class = "0"b;
		else do;
		     Laccess_string = index(access_string," ");
split_access_class:	     Iaccess_string(1) = 1;
		     do iacc = 1 to dimension(Iaccess_string,1)-1;
			if Iaccess_string(iacc) > Laccess_string then
			     Iaccess_string(iacc+1) = Laccess_string+1;
			else if Laccess_string - Iaccess_string(iacc) + 1 <= 50 then
			     Iaccess_string(iacc+1) = Laccess_string+1;
			else Iaccess_string(iacc+1) = Iaccess_string(iacc) + 52 -
			     search (reverse (substr (access_string, Iaccess_string(iacc), 51)), " ,");
			end;
		     end;
	     end;
	if S.aim then do;
	     aim = "";
	     if node.Saim_audit then aim = "audit";
	     if node.Saim_multiple_class then do;
		if length(aim) ^= 0 then aim = aim || ", ";
		aim = aim || "multiple-class";
		end;
	     if node.Saim_security_oos then do;
		if length(aim) ^= 0 then aim = aim || ", ";
		aim = aim || "out-of-service";
		end;
	     end;

	if S.object_info then do;
	     attributes = "";
	     if Dobj.info.format.bound 	then attributes = attributes || "bound object";
	     if Dobj.info.format.old_format 	then do;
		if length (attributes) > 0 then attributes = attributes || ", ";
		attributes = attributes || "old format";
		end;
	     if Dobj.info.format.standard 	then;
	     else do;
		if length (attributes) > 0 then attributes = attributes || ", ";
		attributes = attributes || "non-standard format";
		end;
	     if Dobj.info.format.procedure	then;
	     else do;
		if length (attributes) > 0 then attributes = attributes || ", ";
		attributes = attributes || "data";
		end;
	     if Dobj.info.format.relocatable 	then;
	     else do;
		if length (attributes) > 0 then attributes = attributes || ", ";
		attributes = attributes || "non-relocatable";
		end;
	     if Dobj.info.format.gate 	then do;
		if length (attributes) > 0 then attributes = attributes || ", ";
		attributes = attributes || "gate (" ||
		     convert_binary_integer_$octal_string (Dobj.info.entry_bound) || ")";
		end;
	     if Dobj.info.format.separate_static then do;
		if length (attributes) > 0 then attributes = attributes || ", ";
		attributes = attributes || "separate static";
		end;
	     if Dobj.info.format.links_in_text	then do;
		if length (attributes) > 0 then attributes = attributes || ", ";
		attributes = attributes || "links in text";
		end;
	     if length (attributes) = 0 then attributes = "standard object";
	     end;
	if S.pvid then do;
	     S.pvid = "0"b;				/* NEVER OUTPUT THE PVNAME!			*/
	     call mdc_$find_volname (node.pvid, pvname, lvname, 0);
	     pv_name = substr(pvname,1, length(pvname) + 1 - verify(reverse(pvname)," "));
	     lv_name = substr(lvname,1, length(lvname) + 1 - verify(reverse(lvname)," "));
	     end;
	else if S.lvid then do;
	     call mdc_$find_lvname (node.lvid, lvname, 0);
	     lv_name = substr(lvname,1, length(lvname) + 1 - verify(reverse(lvname)," "));
	     end;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* OUTPUT THE LINES DESCRIBING THIS NODE WHICH ARE REQUIRED AND HAVE NOT BEEN SUPPRESSED.	*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	call set_field_widths;			/* set length of level, indentation, name fields	*/
	if S.new_line then				/* <NL> required at start of entry?		*/
	     call out_nl;				/* put one into output.			*/

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* For library_cleanup, output directory pathname, followed by a list of nodes, with list	*/
	/* entries numbered consecutively.  Flag entries to be deleted with *.		*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if Scleanup then do;
	     if S.pathname then do;
		S.pathname = "0"b;
		if Pprev_parent ^= null then
		     if node.Pparent = Pprev_parent then;
		     else do;
CLEANUP_PATH:		call lib_node_path_ (Pnode, dir, ent);
			if node.Pparent = null then
			     if dir = ">" then
				dir = dir || ent;
			     else dir = dir || ">" || ent;
			call out_pn (dir);
			if S.new_line then
			     call out_nl;
			end;
		else go to CLEANUP_PATH;
		end;
	     if Svalid.delete then
		flag = "*";
	     else flag = " ";
	     if S.type then do;
		S.type = "0"b;
		type = brief_node_type (node.T);
		end;
	     else type = "";
	     call out_cln (flag, Inode, type);
	     end;


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* If short terminal length requires that all names be output first, followed by other	*/
	/* fields, output the names, then make the <name> field zero length in lines which follow.*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if Snames_first then do;
	     ent = lib_next_name_ (Srequirements, PDnames, Iname, Pstarname);
	     do while (ent ^= "");
		call out_name (ent, "", "");
		ent = lib_next_name_ (Srequirements, PDnames, Iname, Pstarname);
		end;
	     Lname = 0;
	     end;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/*	LINE:<lv> <name>	<type>          in: <path-name>			*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if Sinfo then do;				/* Special case short terminals.		*/
	     if S.type then do;
		type = brief_node_type(node.T);
		call out_ch2 ("              type:", type);
		end;
	     if S.pathname & (level <= 1) then do;
		call lib_node_path_ (Pnode, dir, ent);
		if node.Pparent = null then do;
		     type = "              path:";
		     if dir = ">" then
			dir = dir || ent;
		     else dir = dir || ">" || ent;
		     end;
		else type = "              path:";
		saved_Iname = Iname;
		ent = lib_next_name_ (Srequirements, PDnames, Iname, Pstarname);
		Iname = saved_Iname;
		if ent = "" then do;
		     if length (dir) <= 16 then do;
			dir = dir || (19)" ";
			dir = substr(dir,1,19);
			dir = dir || get_field();
			i = length(dir) + 1 - verify(reverse(dir), " ");
			dir = substr(dir,1,i);
			end;
		     else do;
			Lname = Lname - 40;
			Sinfo = "0"b;
			end;
		     call out_vc2 (type, dir);
		     S.pathname = "0"b;
		     end;
		else if Nindent+Llevel+Lname+21+length(dir) <= fcb.line_length then do;
		     call out_vc2 (type, dir);
		     S.pathname = "0"b;
		     end;
		end;
	      end;


	else if S.type | S.pathname then do;
	     if S.type then
		type = brief_node_type(node.T);
	     else
		type = "";
	     if level > 1 then do;
		dir = (19)" " || get_field();
		i = length(dir) + 1 - verify(reverse(dir), " ");
		dir = substr(dir,1,i);
		end;
	     else if S.pathname then do;
		call lib_node_path_ (Pnode, dir, ent);
		if node.Pparent = null then do;	/* special case a library root node.		*/
		     substr (type, 15, 5) = "path:";
		     if dir = ">" then
			dir = dir || ent;
		     else dir = dir || ">" || ent;
		     end;
		else substr (type, 17, 3) = "in:";
		if length (dir) <= 16 then do;
		     dir = dir || (19)" ";
		     dir = substr(dir,1,19);
		     dir = dir || get_field();
		     i = length(dir) + 1 - verify(reverse(dir), " ");
		     dir = substr(dir,1,i);
		     end;
		end;
	     else
		dir = "";
	     call out_vc2 (type, dir);
	     S.pathname = "0"b;
	     end;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/*	LINE:	<name>	contents modified:	<date>		<field>		*/
	/*	LINE:	<name>	entry modified:	<date>		<field>		*/
	/*	LINE:	<name>	date used:	<date>		<field>		*/
	/*	LINE:	<name>	date dumped:	<date>		<field>		*/
	/*	LINE:	<name>	date compiled:	<date>		<field>		*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if node.T = Tarchive_comp then if S.dtem then do;
	     S.dtem = "0"b;
	     call out_ch3 (" component updated:", cv_date(node.dtem), get_field());
	     end;
	if S.dtm then do;
	     S.dtm = "0"b;
	     call out_ch3 (" contents modified:", cv_date(node.dtm), get_field());
	     end;
	if S.dtem then do;
	     S.dtem = "0"b;
	     call out_ch3 ("    entry modified:", cv_date(node.dtem), get_field());
	     end;
	if S.dtu then do;
	     S.dtu = "0"b;
	     call out_ch3 ("         date used:", cv_date(node.dtu), get_field());
	     end;
	if S.dtd then do;
	     S.dtd = "0"b;
	     call out_ch3 ("       date dumped:", cv_date(node.dtd), get_field());
	     end;
	if S.dtc then do;
	     S.dtc = "0"b;
	     if Dobj.info.format.bound then
		call out_ch3 ("        date bound:", cv_long_date(Dobj.info.compile_time), get_field());
	     else call out_ch3 ("     date compiled:", cv_long_date(Dobj.info.compile_time), get_field());
	     end;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/*	LINE:	<name>	msf indicator:	<decimal number>	<field>		*/
	/*	LINE:	<name>	bit count:	<decimal number>	<field>		*/
	/*	LINE:	<name>	length:		<decimal number>	<field>		*/
	/*	LINE:	<name>	records used:	<decimal number>	<field>		*/
	/*	LINE:	<name>	max length:	<decimal number>	<field>		*/
	/*	LINE:	<name>	offset:		<octal number>	<field>		*/
	/* 	LINE:	<name>	entry bound:	<octal number>	<field>		*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if S.msf_indicator then do;
	     S.msf_indicator = "0"b;
	     call out_ch3 ("     msf indicator:", cv_dec(node.msf_indicator), get_field());
	     end;
	if S.bit_count then do;
	     S.bit_count = "0"b;
	     call out_ch3 ("         bit count:", cv_dec(node.bit_count), get_field());
	     end;
	if S.current_length then do;
	     S.current_length = "0"b;
	     call out_ch3 ("            length:", cv_dec(node.current_length), get_field());
	     end;
	if S.records_used then do;
	     S.records_used = "0"b;
	     call out_ch3 ("      records used:", cv_dec(node.records_used), get_field());
	     end;
	if S.max_length then do;
	     S.max_length = "0"b;
	     call out_ch3 ("        max length:", cv_dec(node.max_length), get_field());
	     end;
	if S.offset then do;
	     S.offset = "0"b;
	     call out_ch3 ("            offset:", convert_binary_integer_$octal_string(node.offset),
		get_field());
	     end;
	if S.entry_bound then do;
	     S.entry_bound = "0"b;
	     call out_ch3 ("       entry bound:", convert_binary_integer_$octal_string(node.entry_bound),
		get_field());
	     end;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/*	LINE:	<name>	author:		<author>		<field>		*/
	/*	LINE:	<name>	bit count author:	<bit count author>	<field>		*/
	/*	LINE:	<name>	logical volume:	<lvname>		<field>		*/
	/*	LINE:	<name>	physical volume:	<pvname>		<field>		*/
	/*	LINE:	<name>	never on paging dv:	true		<field>		*/
	/*	LINE:	<name>	master  directory:	true		<field>		*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if S.author then if length(node.author) <= 16 then do;
	     S.author = "0"b;
	     call out_vc3 ("            author:", node.author, get_field());
	     end;
	if S.bit_count_author then if length(node.bit_count_author) <= 16 then do;
	     S.bit_count_author = "0"b;
	     call out_vc3 ("  bit count author:", node.bit_count_author, get_field());
	     end;
	if S.lvid then if length(lv_name) <= 16 then do;
	     S.lvid = "0"b;
	     if node.T = Tdirectory | node.T = Tmsf then
		call out_vc3 ("  sons log. volume:", lv_name, get_field());
	     else call out_vc3 ("    logical volume:", lv_name, get_field());
	     end;
	if S.pvid then if length (pv_name) <= 16 then do;
	     S.pvid = "0"b;
	     call out_vc3 ("   physical volume:", pv_name, get_field());
	     end;
	if Stpd then do;
	     Stpd = "0"b;
	     call out_ch3 ("never on paging dv:", "true", get_field());
	     end;
	if Squota.master_dir then do;
	     Squota.master_dir = "0"b;
	     call out_ch3 ("  master directory:", "true", get_field());
	     end;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/*	LINE:	<name>	access class:	<class string>	<field>		*/
	/*	LINE:	<name>	AIM attributes:	<aim attributes>	<field>		*/
	/*	LINE:	<name>	mode:		<mode string>	<field>		*/
	/*	LINE:	<name>	ring brackets:	<ring bracket>	<field>		*/
	/*	LINE:	<name>	safety switch:	on		<field>		*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if S.access_class then if Laccess_string <= 16 then do;
	     S.access_class = "0"b;
	     call out_ch3 ("      access class:", substr(access_string,1,Laccess_string), get_field());
	     end;
	if S.aim then if length(aim) <= 16 then do;
	     S.aim = "0"b;
	     call out_vc3 ("    AIM attributes:", aim, get_field());
	     end;
	if S.mode then do;
	     S.mode = "0"b;
	     call out_ch3 ("              mode:", mode, get_field());
	     end;
	if S.rb then do;
	     S.rb = "0"b;
	     call out_vc3 ("     ring brackets:", rbs, get_field());
	     end;
	if S.safety then do;
	     S.safety = "0"b;
	     call out_ch3 ("     safety switch:", "on", get_field());
	     end;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/*	LINE:	<name>	copy switch:	on		<field>		*/
	/*	LINE:	<name>	unique id:	<octal number>	<field>		*/
	/*	LINE:	<name>	<user label>:	<user info>	<field>		*/
	/*	LINE:	<name>	object attributes:	<object attributes>	<field>		*/
	/*	LINE:	<name>	printable:	<yes-or-no>	<field>		*/
	/*	LINE:	<name>	compiler:		<compiler-name>	<field>		*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if S.copy then do;
	     S.copy = "0"b;
	     call out_ch3 ("       copy switch:", "on", get_field());
	     end;
	if S.unique_id then do;
	     S.unique_id = "0"b;
	     call out_ch3 ("         unique id:",
		convert_binary_integer_$octal_string(binary (node.unique_id, 36)), get_field());
	     end;
	if S.user then if Duser.L <= 16 then do;
	     S.user = "0"b;
	     call out_ch3 (Duser.label || ":", Duser.info, get_field());
	     end;
	if S.object_info then if length (attributes) <= 16 then do;
	     S.object_info = "0"b;
	     call out_vc3 (" object attributes:", attributes, get_field());
	     end;
	if S.not_ascii then do;
	     S.not_ascii = "0"b;
	     call out_ch3 ("         printable:", "no", get_field());
	     end;
	if S.compiler_name then do;
	     S.compiler_name = "0"b;
	     call out_ch3 ("          compiler:", Dobj.info.compiler, get_field());
	     end;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* FINISH OUTPUTTING SHORT DATA BEFORE BEGINNING LONG DATA.				*/
	/* 1) Output remaining ACL entries, unless on short terminal or in 1-datum per line mode.	*/
	/* 2) Output remaining names, unless on short terminal.				*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if S.acl then
	     if Snames_first | Sinfo then;
	     else do;
		field = get_acl();
		do while (field ^= "");
		     call out_ch3 ("", "", field);
		     field = get_acl();
		     end;
		end;
	if ^Snames_first then if Sinfo then do;		/* For short terminals, print rest of names now.	*/
	     ent = lib_next_name_ (Srequirements, PDnames, Iname, Pstarname);
	     do while (ent ^= "");
		call out_name (ent, "", "");
		ent = lib_next_name_ (Srequirements, PDnames, Iname, Pstarname);
		end;
	     Lname = Lname - 40;
	     end;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* OUTPUT ITEMS LONGER THAN A SINGLE COLUMN					*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* 	LINE:	<name>	quota:		<quota>		<field>		*/
	/*	LINE:	<name>	quota used:	<quota used>	<field>		*/
	/*	LINE:	<name>	time * records(TR):	<time/record prod.>	<field>		*/
	/*	LINE:	<name>	date TR modified:	<date trp modified>	<field>		*/
	/*	LINE:	<name>	terminal account:	true		<field>		*/
	/*	LINE:	<name>	inf. term. accts.:	<number of dirs>	<field>		*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if Squota.quota then do;
	     Squota.quota = "0"b;
	     call out_ch3 ("             quota:",     cv_dec(node.segment.quota),
		         "         dir quota:  " || cv_dec(node.directory.quota));
	     end;
	if Squota.quota_used then do;
	     Squota.quota_used = "0"b;
	     call out_ch3 ("        quota used:",     cv_dec(node.segment.quota_used),
		         "    dir quota used:  " || cv_dec(node.directory.quota_used));
	     end;
	if Squota.trp then if length(cv_long_dec(node.segment.trp)) <= 16 then do;
	     Squota.trp = "0"b;
	     call out_ch3 ("time * records(TR):",     cv_long_dec(node.segment.trp), 
		         "            dir TR:  " || cv_long_dec(node.directory.trp));
	     end;
	if Squota.dttrp then do;
	     Squota.dttrp = "0"b;
	     call out_ch3 ("       TR modified:",     cv_date(node.segment.dttrp),
		         "   dir TR modified:  " || cv_date(node.directory.dttrp));
	     end;
	if Squota.terminal_account then do;
	     Squota.terminal_account = "0"b;
	     call out_ch3 (" terminal acct(TA):",     FT(binary(node.Sterminal_account,1)),
		         "            dir TA:  " || FT(binary(node.Sterminal_account_dir,1)));
	     end;
	if Squota.Ninf then do;
	     Squota.Ninf = "0"b;
	     call out_ch3 ("     # inferior TA:",     cv_dec(node.segment.Ninf_quota),
		         " dir # inferior TA:  " || cv_dec(node.directory.Ninf_quota));
	     end;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/*	LINE:	<name>	time * records(TR):	<time/record prod.>	<field>		*/
	/*	LINE:	<name>	           path:	<path>				*/
	/*	LINE:	<name>	author:		<author>				*/
	/*	LINE:	<name>	bit count author:	<bit count author>			*/
	/*	LINE:	<name>	device:		<device name>			*/
	/*	LINE:	<name>	compiler version:	<compiler version string>		*/
	/*	LINE:	<name>	compiler comment:	<compiler comment string>		*/
	/*	LINE:	<name>	search procedure:	<root search proc>			*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if Squota.trp then do;
	     Squota.trp = "0"b;
	     call out_ch2 ("time * records(TR):", cv_long_dec(node.segment.trp));
	     call out_ch2 ("	  dir TR:", cv_long_dec(node.directory.trp));
	     end;
	if S.pathname then if (level <= 1) then
	     call out_vc2 (type, dir);
	if S.author then do;
	     S.author = "0"b;
	     call out_vc2 ("            author:", node.author);
	     end;
	if S.bit_count_author then do;
	     S.bit_count_author = "0"b;
	     call out_vc2 ("  bit count author:", node.bit_count_author);
	     end;
	if S.lvid then do;
	     S.lvid = "0"b;
	     if node.T = Tdirectory | node.T = Tmsf then
		call out_vc2 ("  sons log. volume:", lv_name);
	     else call out_vc2 ("    logical volume:", lv_name);
	     end;
	if S.pvid then do;
	     S.pvid = "0"b;
	     call out_vc2 ("   physical volume:", pv_name);
	     end;
	if S.compiler_version then
	     if length (Dobj.cversion) > 0 then
		call out_vc2 ("  compiler version:", Dobj.cversion);
	if S.compiler_options then
	     if length (Dobj.comment) > 0 then
		call out_vc2 ("  compiler comment:", Dobj.comment);
	if S.root_search_proc then
	     call out_vc2 ("  search procedure:", Dsearch_proc.search_proc);

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/*	LINE:	<name>	object attributes:	<object attributes>			*/
	/*	LINE:	<name>	<user label>:	<user information>			*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if S.object_info then
	     call out_vc2 (" object attributes:", attributes);
	if S.user then
	     call out_ch2 (Duser.label || ":", Duser.info);

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/*	LINE:	<name>	links to:		<link path name>			*/
	/*	LINE:	<name>	error:		<error message>			*/
	/*	LINE:	<name>	access class:	<class string>			*/
	/*	LINE:	<name>	AIM attributes:	<aim attributes>			*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if S.link_target then
	     call out_vc2 ("          links to:", link_node.link_target);
	if S.kids_error then do;
	     call convert_status_code_ (Dnodes.C, short, long);
	     call out_ch2 ("             error:", long);
	     end;
	if S.access_class then do;
	     S.access_class = "0"b;
	     call out_ch2 ("      access class:",
			substr(access_string, Iaccess_string(1), Iaccess_string(2)-Iaccess_string(1)));
	     do iacc = 2 to dimension(Iaccess_string,1)-1 while (Iaccess_string(iacc) <= Laccess_string);
		call out_ch2 ("",
		     substr(access_string, Iaccess_string(iacc), Iaccess_string(iacc+1)-Iaccess_string(iacc)));
		end;
	     end;
	if S.aim then do;
	     S.aim = "0"b;
	     call out_vc2 ("    AIM attributes:", aim);
	     end;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* Finish printing any names that haven't been printed yet.				*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	ent = lib_next_name_ (Srequirements, PDnames, Iname, Pstarname);
	do while (ent ^= "");
	     call out_name (ent, "", "");
	     ent = lib_next_name_ (Srequirements, PDnames, Iname, Pstarname);
	     end;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* All names guaranteed printed, so we can force short terminal format.		*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if ^Snames_first & Sinfo then Lname = Lname - 40;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* Print ACL if hasn't been printed because of short terminal lengths.		*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if S.acl then do;
	     call out_ch2 ("               acl:", substr (get_acl(), 7));
	     field = get_acl();
	     do while (field ^= "");
		call out_ch2 ("", substr(field, 7));
		field = get_acl();
		end;
	     end;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* Print Segment and Directory IACLs.						*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if S.iacl then do;
	     iacle = get_iacl();
	     if iacle = "" then;
	     else do;
		call out_ch2 ("      segment IACL:", iacle);
		iacle = get_iacl();
		do while (iacle ^= "");
		     call out_ch2 ("", iacle);
		     iacle = get_iacl();
		     end;
		end;
	     iacle = get_dir_iacl();
	     if iacle = "" then;
	     else do;
		call out_ch2 ("    directory IACL:", iacle);
		iacle = get_dir_iacl();
		do while (iacle ^= "");
		     call out_ch2 ("" , iacle);
		     iacle = get_dir_iacl();
		     end;
		end;
	     end;
	return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


cross_reference:	entry	(Pfcb, Pnode, ASrequirements, level, name, path);


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/*	LINE:	<name>	<date>    see:	<parent-path>			*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	Srequirements = node.Sreq & ASrequirements;	/* copy user-specified requirements to aligned	*/
						/* bit string we can overlay, modifying 	*/
						/* requirements according to which node fields	*/
						/* are valid.				*/
	call set_field_widths;			/* set length of level, indentaiton, name fields.	*/
	if S.new_line then				/* <NL> req'd at start of entry?		*/
	     call out_nl;				/* put one into the output.			*/
	if S.user then				/* address user info descriptor, if need be.	*/
	     do PDuser = node.PD repeat Duser.Pnext while (Duser.T ^= Tuser);
		end;
	else PDuser = addr(null_user_descriptor);
	if S.user & Duser.L <= 14 then		/* if user info available, put it in cross-ref.	*/
	     type = Duser.info;
	else if node.T = Tarchive_comp then		/* for archive component, return dtem		*/
	     if S.dtem then
		type = cv_date (node.dtem);
	     else if S.dtm then			/* or dtm, if dtem not requested.		*/
		type = cv_date(node.dtm);
	     else if S.type then			/* or type, if dates not requested.		*/
		type = brief_node_type (node.T);
	     else type = "";
	else if node.T = Tlink then			/* for link, return dtem			*/
	     if S.dtem then
		type = cv_date (node.dtem);
	     else if S.type then			/* or type, if dtem not requested.		*/
		type = brief_node_type (node.T);
	     else
		type = "";
	else if S.dtm then				/* for everything else, return dtm		*/
	     type = cv_date (node.dtm);
	else if S.type then				/* or type.				*/
	     type = brief_node_type (node.T);
	else
	     type = "";
	substr (type, 15, 5) = " see:";		/* put path header into type string.		*/
	ent = name;
	call out_name (ent, type, path);		/* output the cross-reference entry.		*/
	return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


cv_date:	procedure	(date)				/* Internal procedure which converts a file	*/
	returns (char(16));				/* system date into a character string.		*/

     dcl	date			bit(36),		/* date to be converted.			*/
	long_date			fixed bin(71) aligned,
	date_string		char(16) aligned;	/* a date character string.			*/

	call date_time_$fstime (date, date_string);

	return (date_string);

cv_long_date:	entry (long_date)
		returns (char(16));

	call date_time_ (long_date, date_string);

	return (date_string);

	end cv_date;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

cv_dec:	procedure	(number)				/* Internal procedure to convert binary numbers	*/
	returns	(char(13) varying);			/* to decimal character strings.		*/

     dcl	number			fixed bin(35),	/* number to be converted. (In)		*/
	number_string		picture "------------9",
	Ifirst_significant_digit	fixed bin;	/* index of first significant digit in number_st.	*/
						/* form of converted number.			*/

	number_string = number;
	Ifirst_significant_digit = verify (number_string, " ");
	return (substr (number_string, Ifirst_significant_digit));

	end cv_dec;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */



cv_long_dec:	procedure (number)			/* Internal procedure to convert long binary	*/
		returns	(char(23) varying);		/* to decimal character strings.		*/

     dcl	number			fixed bin(71),	/* number to be converted. (In)		*/
	number_string		pic "----------------------9",
	Ifirst_significant_digit	fixed bin;

	number_string = number;
	Ifirst_significant_digit = verify (number_string, " ");
	return (substr (number_string, Ifirst_significant_digit));

	end cv_long_dec;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


get_acl:		procedure returns (char(106));	/* Internal procedure which returns the next	*/
						/* ACL entry, formatted for printed.		*/

     dcl	field			char(108);	/* temporary in which ACLe is formatted.	*/
	Iacl = Iacl + 1;				/* get index of next ACLe.			*/
	if Iacl > Dacl.N then do;			/* if there are no more ACLe's, return blank field*/
	     S.acl = "0"b;
	     if Iacl = 1 then			/* unless there is an error code.		*/
		if Dacl.C ^= 0 then do;
		     call convert_status_code_ (Dacl.C, short, long);
		     return ("acl:  " || long);
		     end;
	     return ("");
	     end;
	call cv_acl (addr(Dacl.acls), Iacl, field, 0, "100"b);
	if Iacl = 1 then return ("acl:  " || field);
	else return ("      " || field);		/* format/return the ACLe.			*/

	end get_acl;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


get_dir_iacl:	procedure returns(char(109));		/* Internal procedure to format segment IACLs.	*/

     dcl	iacle			char(42),
	i			fixed bin,	/* a do-group index.			*/
	r			pic "9";		/* Ring number.				*/

	Idir_iacl = Idir_iacl + 1;			/* see if IACLs exhausted.			*/
	if Idir_iacl > Ddir_iacl.N then do;		/* if so, return a blank string, unless there	*/
	     if Idir_iacl = 1 then			/*   is a non-zero error code.		*/
		if Ddir_iacl.C ^= 0 then do;
		     call convert_status_code_ (Ddir_iacl.C, short, long);
		     return ("Error -  " || long);
		     end;
	     return ("");
	     end;
	do i = 0 to 7 while ((Ddir_iacl.Iring(i) ^= Idir_iacl) | (Ddir_iacl.Nring(i) = 0));
	     end;					/* see if we are beginning IACL for a ring.	*/
	call cv_dir_acl_ (addr(Ddir_iacl.acls), Idir_iacl, iacle, 0, "100"b);
	if i < 8 then do;				/* if so, return ring number before ACLe.	*/
	     r = i;
	     return (r || ":  " || iacle);
	     end;
	else return ("    " || iacle);

	end get_dir_iacl;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


get_field:	procedure				/* Internal procedure which returns either an	*/
		returns (char(108));		/* ACL entry or another field value.		*/

     dcl	blank_field		char(108) aligned int static init ((108)" "),
	field			char(108) aligned;


	if Snames_first then go to return_blank;	/* library_info:  short terminal, no 3rd column.	*/

	if Sinfo then do;				/* library_info:  longer terminal, move 2nd col.	*/
	     saved_Iname = Iname;			/*    into names field after all names output.	*/
	     ent = lib_next_name_ (Srequirements, PDnames, Iname, Pstarname);
	     Iname = saved_Iname;
	     if ent = "" then do;
		Lname = Lname - 40;			/*    Output 3rd col. under 2nd's previous pos.	*/
		Sinfo = "0"b;
		end;
	     else go to return_blank;
	     end;

	if Sfield_blank then go to return_blank;	/* 3rd column output exhausted.		*/

	if S.acl then do;
	     field = get_acl();
	     go to return;
	     end;
	if S.access_class then if Laccess_string <= 22 then do;
	     S.access_class = "0"b;
	     field = "      access class:  " || access_string;
	     go to return;
	     end;
	if S.aim then if length(aim) <= 22 then do;
	     S.aim = "0"b;
	     field = "    AIM attributes:  " || aim;
	     go to return;
	     end;
	if S.mode then do;
	     S.mode = "0"b;
	     field = "              mode:  " || mode;
	     go to return;
	     end;
	if S.rb then do;
	     S.rb = "0"b;
	     field = "     ring brackets:  " || rbs;
	     go to return;
	     end;
	if S.safety then do;
	     S.safety = "0"b;
	     field = "     safety switch:  on";
	     go to return;
	     end;
	if S.user then if Duser.L <= 22 then do;
	     S.user = "0"b;
	     field = Duser.label || ":  " || Duser.info;
	     go to return;
	     end;
	if S.unique_id then do;
	     S.unique_id = "0"b;
	     field = "         unique id:  " ||
		convert_binary_integer_$long_octal_string((binary(node.unique_id,36)));
	     go to return;
	     end;
	if S.copy then do;
	     S.copy = "0"b;
	     field = "       copy switch:  on";
	     go to return;
	     end;
	if S.lvid then if length(lv_name) <= 22 then do;
	     S.lvid = "0"b;
	     if node.T = Tdirectory | node.T = Tmsf then
		field = "  sons log. volume:  " || lv_name;
	     else field = "    logical volume:  " || lv_name;
	     go to return;
	     end;
	if S.pvid then if length(pv_name) <= 22 then do;
	     S.pvid = "0"b;
	     field = "   physical volume:  " || pv_name;
	     go to return;
	     end;
	if Stpd then do;
	     Stpd = "0"b;
	     field = "never on paging dv:  " || "true";
	     go to return;
	     end;
	if S.author then if length(node.author) <= 22 then do;
	     S.author = "0"b;
	     field = "            author:  " || node.author;
	     go to return;
	     end;
	if S.bit_count_author then if length(node.bit_count_author) <= 22 then do;
	     S.bit_count_author = "0"b;
	     field = "  bit count author:  " || node.bit_count_author;
	     go to return;
	     end;
	if S.msf_indicator then do;
	     S.msf_indicator = "0"b;
	     field = "     msf indicator:  " || cv_dec (node.msf_indicator);
	     go to return;
	     end;
	if S.bit_count then do;
	     S.bit_count = "0"b;
	     field = "         bit count:  " || cv_dec (node.bit_count);
	     go to return;
	     end;
	if S.current_length then do;
	     S.current_length = "0"b;
	     field = "            length:  " || cv_dec (node.current_length);
	     go to return;
	     end;
	if S.records_used then do;
	     S.records_used = "0"b;
	     field = "      records used:  " || cv_dec (node.records_used);
	     go to return;
	     end;
	if S.max_length then do;
	     S.max_length = "0"b;
	     field = "        max length:  " || cv_dec (node.max_length);
	     go to return;
	     end;
	if S.offset then do;
	     S.offset = "0"b;
	     field = "            offset:  " || convert_binary_integer_$octal_string (node.offset);
	     go to return;
	     end;
	if S.entry_bound then do;
	     S.entry_bound = "0"b;
	     field = "       entry bound:  " || convert_binary_integer_$octal_string (node.entry_bound);
	     go to return;
	     end;
	if Squota.master_dir then do;
	     Squota.master_dir = "0"b;
	     field = "  master directory:" || "true";
	     go to return;
	     end;
	if node.T = Tarchive_comp then if S.dtem then do;
	     S.dtem = "0"b;
	     field = " component updated:  " || cv_date(node.dtem);
	     go to return;
	     end;
	if S.dtm then do;
	     S.dtm = "0"b;
	     field = " contents modified:  " || cv_date(node.dtm);
	     go to return;
	     end;
	if S.dtem then do;
	     S.dtem = "0"b;
	     field = "    entry modified:  " || cv_date(node.dtem);
	     go to return;
	     end;
	if S.dtu then do;
	     S.dtu = "0"b;
	     field = "         date used:  " || cv_date(node.dtu);
	     go to return;
	     end;
	if S.dtd then do;
	     S.dtd = "0"b;
	     field = "       date dumped:  " || cv_date(node.dtd);
	     go to return;
	     end;
	if S.dtc then do;
	     S.dtc = "0"b;
	     if Dobj.info.format.bound then
		field = "        date bound:  " || cv_long_date(Dobj.info.compile_time);
	     else field = "     date compiled:  " || cv_long_date(Dobj.info.compile_time);
	     go to return;
	     end;
	if S.compiler_name then do;
	     S.compiler_name = "0"b;
	     field = "          compiler:  " || Dobj.info.compiler;
	     go to return;
	     end;
	if S.object_info then if length (attributes) <= 22 then do;
	     S.object_info = "0"b;
	     field = " object attributes:  " || attributes;
	     go to return;
	     end;
	if S.not_ascii then do;
	     S.not_ascii = "0"b;
	     field = "         printable:  no";
	     go to return;
	     end;

	Sfield_blank = "1"b;
return_blank:
	return (blank_field);

return:	return (field);

	end get_field;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


get_iacl:		procedure returns(char(109));		/* Internal procedure to format segment IACLs.	*/

     dcl	iacle			char(42),
	i			fixed bin,	/* a do-group index.			*/
	r			pic "9";		/* Ring number.				*/

	Iiacl = Iiacl + 1;				/* see if IACLs exhausted.			*/
	if Iiacl > Diacl.N then do;			/* if so, return a blank string, unless there	*/
	     if Iiacl = 1 then			/*   is a non-zero error code.		*/
		if Diacl.C ^= 0 then do;
		     call convert_status_code_ (Diacl.C, short, long);
		     return ("Error -  " || long);
		     end;
	     return ("");
	     end;
	do i = 0 to 7 while ((Diacl.Iring(i) ^= Iiacl) | (Diacl.Nring(i) = 0));
	     end;					/* see if we are beginning IACL for a ring.	*/
	call cv_acl_ (addr(Diacl.acls), Iiacl, iacle, 0, "100"b);
	if i < 8 then do;				/* if so, return ring number before ACLe.	*/
	     r = i;
	     return (r || ":  " || iacle);
	     end;
	else return ("    " || iacle);

	end get_iacl;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

get_level:	procedure				/* Internal procedure to return the level field	*/
		returns	(char(2));

     dcl	blank_level		char(2) aligned int static init ("  "),
	level_string		char(2);		/* character representation of level.		*/

	if level_suppressed then			/* if no level required, return a blank string.	*/
	     return (blank_level);
	level_suppressed = "1"b;			/* suppress level in lines which follow.	*/
	level_string = cv_dec(level);
	return (level_string);			/* and return the character string number.	*/

	end get_level;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


out_ch2:	procedure	(label, value_ch);
						/* Internal procedure to output a line.		*/
	e = 1;					/* indicate character value.			*/
	go to common;


out_vc2:	entry	(label, value_vc);

	e = 2;					/* indicate varying character string value.	*/
	if length (value_vc) + 71 > fcb.line_length then
	     fcb.line_no = fcb.line_no + 1;
	go to common;


out_ch3:	entry	(label, value_ch, field);

	e = 3;					/* indicate character value and field value.	*/
	go to common;


out_vc3:	entry	(label, value_vc, field);

	e = 4;					/* indicate varying character value & field value.*/
	go to common;


out_name:	entry	(name, label, value_vc);

	e = 5;					/* indicate special name line.		*/
	go to common;


out_nl:	entry;

	e = 6;					/* indicate that a new_line char is to be output.	*/
	go to common;


out_pn:	entry 	(value_vc);			/* indicate that a new pathname to be output.	*/

	e = 7;
	go to common;


out_cln:	entry	(flag, Inode, type);		/* indicate library_cleanup 1st line to be output.*/

	e = 8;

     dcl	Inode			fixed bin,	/* node number.				*/
	field			char(108),	/* field to be placed in line.		*/
	flag			char(1) aligned,	/* deletion flag.				*/
	label			char(*),		/* label for the value field.			*/
	name			char(32) varying,	/* name to be placed in line.			*/
	type			char(20),		/* type of node.				*/
	value_ch			char(*),		/* a character string value.			*/
	value_no			fixed bin(35),	/* a number value.				*/
	value_vc			char(*) varying aligned;
						/* a varying character string value.		*/

     dcl	Lvalue			fixed bin,	/* maximum length of value part of field.	*/
	i			fixed bin;	/* a string index.				*/

common:	if fcb.line_no = fcb.page_text_length then	/* if current page is full, skip to a new page.	*/
	     call fcb.Eend_page();
	fcb.line_no = fcb.line_no + 1;		/* increment number of lines on current page.	*/

	go to out(e);				/* output line.				*/
out(1):	call ioa_$ioa_switch (fcb.Piocb, "^va^vx^va^21a^a", Llevel, get_level(), Nindent, 
			  Lname, lib_next_name_ (Srequirements, PDnames, Iname, Pstarname), label, value_ch);
	return;

out(2):	if length (value_vc) + Nindent + Lname + Llevel + 21 <= fcb.line_length then
	     call ioa_$ioa_switch (fcb.Piocb, "^va^vx^va^21a^a", Llevel, get_level(), Nindent, 
		Lname, lib_next_name_ (Srequirements, PDnames, Iname, Pstarname), label, value_vc);
	else do;
	     Lvalue = fcb.line_length - (Nindent + Lname + Llevel + 21);
	     i = Lvalue + 1 - index(reverse(substr(value_vc,1,Lvalue)), " ");
	     call ioa_$ioa_switch (fcb.Piocb, "^va^vx^va^21a^a", Llevel, get_level(), Nindent,
		Lname, lib_next_name_ (Srequirements, PDnames, Iname, Pstarname),
		label, substr(value_vc,1,i));
	     call ioa_$ioa_switch (fcb.Piocb, "^va^vx^va^21x^a", Llevel, get_level(), Nindent,
		Lname, lib_next_name_ (Srequirements, PDnames, Iname, Pstarname), substr(value_vc,i+1));
	     end;
	return;

out(3):	call ioa_$ioa_switch (fcb.Piocb, "^va^vx^va^21a^16a^3x^a", Llevel, get_level(), Nindent, 
			  Lname, lib_next_name_ (Srequirements, PDnames, Iname, Pstarname),
			  label, value_ch, field);
	return;

out(4):	call ioa_$ioa_switch (fcb.Piocb, "^va^vx^va^21a^16a^3x^a", Llevel, get_level(), Nindent, 
			  Lname, lib_next_name_ (Srequirements, PDnames, Iname, Pstarname),
			  label, value_vc, field);
	return;

out(5):	call ioa_$ioa_switch (fcb.Piocb, "^va^vx^va^21a^a", Llevel, get_level(), Nindent, 
			  Lname, name, label, value_vc);
	return;

out(6):	if fcb.line_no = 2 then			/* if top of page, forget new_line char.	*/
	     fcb.line_no = 1;
	else
	     call ioa_$ioa_switch (fcb.Piocb, "");
	return;

out(7):	call ioa_$ioa_switch (fcb.Piocb, "^/IN ^a:", value_vc);
	return;

out(8):	call ioa_$ioa_switch (fcb.Piocb, "^1a^vd^1x^va^a", flag, Llevel-2, Inode,
			  Lname, lib_next_name_ (Srequirements, PDnames, Iname, Pstarname), type);
	return;

	end out_ch2;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


set_field_widths:	procedure;			/* Internal procedure which sets the lengths	*/
						/* of the level number, name indentation, and	*/
						/* name fields, initializes the names-output	*/
						/* counter, and computes initial value of	*/
						/* level_suppressed switch.			*/

	Nindent = min (level+level-2, 14);		/* indent the names for nodes at successive levels*/
	Nindent = max (Nindent, 0);			/* of the tree by 2-spaces/node (max = 8 levels)	*/
	Llevel = min (level+level, 2);		/* level field is 2-char long, unless there is	*/
	Llevel = max (Llevel, 0);			/* no indentation.				*/
	level_suppressed = (Llevel = 0) | ^S.level;	/* suppress level field if there's no room for it	*/
						/* or if it's not required.			*/
	if Scleanup then				/* for library_cleanup, leave room for node list	*/
	     Llevel = 5;				/*   numbers, and for * deletion flag.		*/
	if Sinfo then				/* if output directed to user's terminal,	*/
	     if fcb.line_length >= 79 & ^S.acl then do;
		Nindent = 0;			/* shrink name column.			*/
		Lname = 34;
		end;
	     else if fcb.line_length >= 88 then do;
		Nindent = 0;
		Lname = 40;
		end;
	     else do;				/* For very short terminals, print 1 item/line.	*/
		Snames_first = "1"b;
		Nindent = 0;
		Lname = 34;
		end;
	else Lname = 48 - Nindent;			/* For file output, indent names by level.	*/
	if Sinfo then				/* For user's terminal, output single name 1st.	*/
	     if ^S.names & ^S.matching_names & S.primary_name then
		Snames_first = "1"b;
	Iname = 0;				/* so far, no names have been printed.		*/
	Iacl = 0;					/* so far, no ACL entries have been output.	*/
	Iiacl, Idir_iacl = 0;			/* so far, no IACL entries have been output.	*/

	end set_field_widths;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

%include lib_fcb_;

%include lib_based_args_;

%include lib_node_;


	end lib_output_node_;
