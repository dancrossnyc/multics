/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */

/* Modified 10/11/83 by Jim Lippard to remove references to sys_dates_ */
/* Modified 03/05/84 by Jim Lippard to return error_table_$logical_volume_not_connected			*/

multics_library_search_:	procedure options(rename((alloc_,smart_alloc_)));

     dcl						/* 		parameters		*/
/*	Pnode			ptr,		/* ptr to node to be examined/searched. (In)	*/
	path			char(168) varying;	/* path name of this node. (In)		*/
%include lib_based_args_;
     dcl	APstarname		ptr,		/* ptr to input starnames. (In)		*/
	APexclude			ptr,		/* ptr to input exclude search names. (In)	*/
	ASrequirements		bit(72) aligned,	/* requirements bits. (In)			*/
	AScontrol			bit(36) aligned,	/* control bits.				*/
	tree_level		fixed bin,	/* depth of our node in the tree. (In)		*/
	link_level		fixed bin,	/* number of links chased from last non-link node	*/
						/*    to reach our node. (In)			*/
	Parea			ptr,		/* ptr to an allocation area.			*/
	Adirector			entry (ptr, char(168) varying, ptr, bit(72) aligned,
				       bit(36) aligned, fixed bin, fixed bin, ptr, entry, ptr, ptr,
				       fixed bin(35)) variable,
						/* entry point where our search proc entered.(In)	*/
	PA			ptr,		/* ptr to our control argument struc. (In)	*/
	PA_saved			ptr,		/* saved copy of PA so we can return info to caller */
/*	PDnodes			ptr,		/* ptr to descendant nodes of input node. (Out)	*/
	Acode			fixed bin(35);	/* a status code. (Out)			*/

     dcl						/*		automatic variables		*/
	Soutputable		bit(1) aligned,	/* on if an MSF node is outputable.		*/
	1 auto_star		structure,	/* a star name temporary.			*/
	  2 N			fixed bin,
	  2 V			char(32),
	  2 C			fixed bin(35),
	code			fixed bin(35),	/* a status code.				*/
         (max_Scontrol, min_Scontrol)	bit(36) aligned,	/* max/min control bits.			*/
	1 director_args,				/* our control argument structure.		*/
	  2 command		fixed bin,	/*    command index.			*/
						/*      1 = library_info			*/
						/*      2 = library_map			*/
						/*      3 = library_print			*/
	  2 n_found		fixed bin,	/*    = number of entries found		*/
	  2 Pstar			ptr,		/*    = addr (starname) at level 1.		*/
	  2 Sreq			bit(72) aligned,	/*    = ASrequirements at level 1.		*/
	  2 Scontrol		bit(36) aligned,	/*    = AScontrol at level 1.			*/
	  2 search_type		fixed bin,	/*    type of search being performed.		*/
						/*      1 = online directories.		*/
						/*      2 = hardcore directories.		*/
         (i, j)			fixed bin,	/* a do-group index.			*/
	search_type		fixed bin;	/* type of search being performed, as specified	*/
						/*    in director_args.search_type.		*/

     dcl						/*		based variables		*/
	1 A			like director_args based (PA);
						/* our control argument structure.		*/

     dcl						/*		builtin functions		*/
         (addr, index, mod, null, reverse, string, substr)
				builtin;

     dcl						/*		entry constants		*/
	get_ring_			entry returns (fixed bin(6)),
	lib_free_node_$array	entry (ptr),
	lib_get_tree_		entry (ptr, char(168) varying, ptr, ptr, bit(72) aligned,
				       bit(36) aligned, fixed bin, fixed bin, ptr, entry, ptr, ptr,
				       fixed bin(35)),
	match_star_name_		entry (char(*), char(*), fixed bin(35));

     dcl						/*		static variables		*/
	Sinit			bit(1) aligned int static init ("1"b),
						/* switch:  on if requirements must be inited.	*/
	max_Srequirements (1:5)	bit(72) aligned int static,
         (max_cleanup_Scontrol,
	min_cleanup_Scontrol)	bit(36) aligned int static,
         (max_exec_Scontrol,
	max_list_info_Scontrol,
	max_object_Scontrol,
	max_source_Scontrol,
	min_exec_Scontrol,
	min_list_info_Scontrol,
	min_object_Scontrol,
	min_source_Scontrol) (1:4)
				bit(36) aligned int static,
         (Sreq_archive_comp_parent,
	Sreq_archive_comp_no_parent,
	Sreq_msf_comp,
	Sreq_link,
	Sreq_offline_seg,
	Sreq_seg) (1:5)
				bit(72) aligned int static,
         (error_table_$logical_volume_not_connected,
	error_table_$nomatch,
	error_table_$process_stopped,
	error_table_$undefined_order_request)
				fixed bin(35) ext static,
	ring			fixed bin(6) int static,
	1 starstar		int static options(constant),
	  2 N			fixed bin init(1),	/* starname structure for a star name of "**".	*/
	  2 V			char(32) init ("**"),
	  2 C			fixed bin(35) init (2);

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


offline_execution_dirs:
online_execution_dirs:
execution_dirs: entry (Pnode, path, APstarname, APexclude, ASrequirements, AScontrol, tree_level,
			link_level, Parea, Adirector, PA, PDnodes, Acode);

	Scontrol = AScontrol;
	if Sc.first_match & A.n_found > 0 then go to reject;
	go to execdir(A.command * 10 + tree_level);

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


offline_list_info_dirs:
online_list_info_dirs:
list_info_dirs: entry (Pnode, path, APstarname, APexclude, ASrequirements, AScontrol, tree_level,
			link_level, Parea, Adirector, PA, PDnodes, Acode);

	Scontrol = AScontrol;
	if Sc.first_match & A.n_found > 0 then go to reject;
	go to lsinfodir(A.command * 10 + tree_level);

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


offline_object_dirs:
online_object_dirs:
object_dirs: entry	(Pnode, path, APstarname, APexclude, ASrequirements, AScontrol, tree_level,
			 link_level, Parea, Adirector, PA, PDnodes, Acode);

	Scontrol = AScontrol;
	if Sc.first_match & A.n_found > 0 then go to reject;
	go to objdir(A.command * 10 + tree_level);

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


offline_source_dirs:
online_source_dirs:
source_dirs: entry	(Pnode, path, APstarname, APexclude, ASrequirements, AScontrol, tree_level,
			 link_level, Parea, Adirector, PA, PDnodes, Acode);

	Scontrol = AScontrol;
	if Sc.first_match & A.n_found > 0 then go to reject;
	go to searchdir(A.command * 10 + tree_level);

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

execdir(11):					/* library_info,  level 1:  execution dirs.	*/
execdir(21):					/* library_map,   level 1:  execution dirs.	*/
execdir(31):					/* library_print, level 1:  execution dirs.	*/
execdir(41):					/* library_fetch, level 1:  execution dirs.	*/
	if Sinit then call init_vars();		/* initialize internal static variables.	*/
	min_Scontrol = min_exec_Scontrol(A.command);	/* set up control info.			*/
	max_Scontrol = max_exec_Scontrol(A.command);
	go to online_level_1;


lsinfodir(11):					/* library_info,  level 1:  list/info dirs.	*/
lsinfodir(21):					/* library_map,   level 1:  list/info dirs.	*/
lsinfodir(31):					/* library_print, level 1:  list/info dirs.	*/
lsinfodir(41):					/* library_fetch, level 1:  list/info dirs.	*/
	if Sinit then call init_vars();		/* initialize internal static variables.	*/
	min_Scontrol = min_list_info_Scontrol(A.command);	/* set up control info.			*/
	max_Scontrol = max_list_info_Scontrol(A.command);
	go to online_level_1;


objdir(11):					/* library_info,  level 1:  object dirs.	*/
objdir(21):					/* library_map,   level 1:  object dirs.	*/
objdir(31):					/* library_print, level 1:  object dirs.	*/
objdir(41):					/* library_fetch, level 1:  object dirs.	*/
	if Sinit then call init_vars();		/* initialize internal static variables.	*/
	min_Scontrol = min_object_Scontrol(A.command);	/* set up control info.			*/
	max_Scontrol = max_object_Scontrol(A.command);
	go to online_level_1;


searchdir(11):					/* library_info,  level 1:  source dirs.	*/
searchdir(21):					/* library_map,   level 1:  source dirs.	*/
searchdir(31):					/* library_print, level 1:  source dirs.	*/
searchdir(41):					/* library_fetch, level 1:  source dirs.	*/
	if Sinit then call init_vars();		/* initialize internal static variables.	*/
	min_Scontrol = min_source_Scontrol(A.command);	/* set up control info.			*/
	max_Scontrol = max_source_Scontrol(A.command);
	go to online_level_1;



online_level_1:
	if node.T ^= Tdirectory then go to reject;	/* accept only directories as root nodes.	*/
	search_type = 1;
	call set_director_args (min_Scontrol, max_Scontrol, search_type);
						/* set up complete director control arguments.	*/
	node.Sreq = ""b;				/* output nothing about root directory.		*/
	call next_tree_level (Sreq_seg(A.command), reject);
						/* apply segment default requirements when	*/
						/*    getting the next level of the tree, and	*/
						/*    reject the directory root node of the tree	*/
						/*    if no matching library entries were found	*/
						/*    in that directory.			*/
	PA = PA_saved;
	A.n_found = director_args.n_found;
	go to return;

execdir(12):					/* library_info,  level 2:  exec ents.		*/
lsinfodir(12):					/* library_info,  level 2:  list/info ents.	*/
objdir(12):					/* library_info,  level 2:  object ents.	*/
searchdir(12):					/* library_info,  level 2:  source ents.	*/
execdir(22):					/* library_map,   level 2:  exec ents.		*/
lsinfodir(22):					/* library_map,   level 2:  list/info ents.	*/
objdir(22):					/* library_map,   level 2:  object ents.	*/
searchdir(22):					/* library_map,   level 2:  source ents.	*/
	Scontrol = A.Scontrol;
	if Sc.retain then;				/* eliminate nodes for library entries awaiting	*/
	else call reject_node_if_obsolete();		/*    deletion.				*/
	if node.Pparent -> node.T = Tlink then		/* mark first name of link target as outputable.	*/
	     Sreq.primary_name = "1"b;
	if node.T = Tsegment			/* for segments:				*/
	     then ;
	else if node.T = Tlink then do;		/* for links:				*/
	     if Sc.default then			/*    add further default requirements to link.	*/
		node.Sreq = (node.Sreq | Sreq_link(A.command)) & node.Svalid;
	     call next_tree_level ((ASrequirements), return);
	     end;
	else if node.T = Tarchive then do;		/* for archives:				*/
	     if Sc.components then
		Pstarname = addr(starstar);		/*    tell about all archive components.	*/
	     else Pstarname = A.Pstar;
	     Srequirements = A.Sreq;
	     if Sc.default then
		if Sc.container then		/*    say little about archive component if we	*/
		     Srequirements = Srequirements | Sreq_archive_comp_parent(A.command);
		else				/*    we are already given that info about parent.*/
		     Srequirements = Srequirements | Sreq_archive_comp_no_parent(A.command);
	     call next_tree_level_special (suppress_nomatch);
	     Sreq.cross_ref = "0"b;			/*  do not cross-reference archive names.	*/
	     if Sc.container then do;			/* say nothing about added names on parent archive*/
						/*   when all comps being listed unless asked.	*/
		Srequirements = A.Sreq;
		Pstarname = A.Pstar;
		if starname(1).C = 2 then do;		/* User is listing all comps in all archives.	*/
		     Sreq.names = S.names;		/*   Give only names explicitly reqd (non-default)*/
		     Sreq.matching_names = S.matching_names;
		     Sreq.primary_name = "1"b;	/*   But always return first name.		*/
		     end;
		else if Sc.components then		/* User listing all comps of one archive.	*/
		     Sreq.names = S.names;		/*   Only give all names if explicitly asked for.	*/
		end;
	     else if Sc.components & (A.command ^= library_info) then
		if Sc.default then do;
		     Srequirements = A.Sreq;
		     Sreq.names = S.names;
		     Sreq.matching_names = S.matching_names;
		     end;
		else;
	     else					/* if user didn't ask about parent archive,	*/
		node.Sreq = ""b;			/*    then mum's the word.			*/
	     end;
	else if node.T = Tmsf then			/* for msfs:				*/
	     call next_tree_level (Sreq_msf_comp(A.command), return);
	else go to reject;				/* reject all other node types.		*/
	go to return;


execdir(13):					/* library_info,  level 3:  exec comps.		*/
lsinfodir(13):					/* library_info,  level 3:  list/info comp?	*/
objdir(13):					/* library_info,  level 3:  object comps.	*/
searchdir(13):					/* library_info,  level 3:  source comps.	*/
execdir(23):					/* library_map,   level 3:  exec comps.		*/
lsinfodir(23):					/* library_map,   level 3:  list/info comp?	*/
objdir(23):					/* library_map,   level 3:  object comps.	*/
searchdir(23):					/* library_map,   level 3:  source comps.	*/
	Scontrol = A.Scontrol;
	Sreq.names = "1"b;				/* must always require that names of things	*/
						/*   at this level be output, so that when -match	*/
						/*   is specified, archive and MSF component names*/
						/*   are still printed.			*/
	if node.T = Tarchive_comp	 		/* for archive components:			*/
	     then ;
	else if node.Pparent -> node.T = Tmsf then do;	/* for msf components:			*/
	     if node.T = Tmsf_comp then;
	     else if node.T = Tlink then do;		/*    msf components which are links --		*/
chase_searchdir23:	if Sc.default then
		     node.Sreq = (node.Sreq | Sreq_link(A.command)) & node.Svalid;
		call next_tree_level ((ASrequirements), return);
		end;
	     else go to reject;
	     end;
	else if node.Pparent -> node.T = Tlink then do;	/* for msf components which are links --	*/
	     if node.T = Tsegment then;
	     else if node.T = Tlink then go to chase_searchdir23;
	     else go to reject;
	     end;
	else go to reject;				/* reject all other node types.		*/
	go to return;

execdir(32):					/* library_print, level 2:  exec ents.		*/
lsinfodir(32):					/* library_print, level 2:  list/info ents.	*/
objdir(32):					/* library_print, level 2:  object ents.	*/
searchdir(32):					/* library_print, level 2:  source ents.	*/
	Scontrol = A.Scontrol;
	if Sc.retain then;				/* eliminate nodes for library entries awaiting	*/
	else call reject_node_if_obsolete();		/*    deletion.				*/
	if node.Pparent -> node.T = Tlink then		/* mark first name of link target as outputable.	*/
	     Sreq.primary_name = "1"b;
	if node.T = Tsegment then			/* for segments:				*/
	     if node_outputable (Pnode) then;		/*    ensure outputability of node.		*/
	     else go to reject;
	else if node.T = Tlink then do;		/* for links:				*/
	     if Sc.default then			/*    add further default requirements to link.	*/
		node.Sreq = (node.Sreq | Sreq_link(A.command)) & node.Svalid;
	     call next_tree_level ((ASrequirements), reject);
	     end;					/*    reject link if its target is rejected.	*/
	else if node.T = Tarchive then do;		/* for archives:				*/
	     if Sc.components then			/*    if asked to, output all components of arch.	*/
		Pstarname = addr(starstar);
	     else					/*    otherwise, output matching components.	*/
		Pstarname = A.Pstar;
	     Srequirements = A.Sreq;
	     if Sc.default then
		Srequirements = Srequirements | Sreq_archive_comp_no_parent(A.command);
	     if node_outputable (Pnode) then do;	/*    if archive itself is outputable:		*/
		call next_tree_level_special (suppress_nomatch);
		node.Sreq = ""b;			/*       output entire archive _o_n_l_y if no comps 	*/
		end;				/*       match star names.			*/
	     else do;				/*    if archive is not printable:		*/
		call next_tree_level_special (reject);	/*       reject it if no matching comps found,	*/
		node.Sreq = ""b;			/*       or mark it unprintable if matches found.	*/
		end;
	     end;
	else if node.T = Tmsf then do;		/* for msfs:				*/
	     call next_tree_level (Sreq_msf_comp(3), return);
	     Dnodes.Pnext = node.PD;
	     node.PD = PDnodes;
	     Svalid.kids = "1"b;
	     Soutputable = node_outputable (Pnode);
	     node.PD = Dnodes.Pnext;
	     Dnodes.Pnext = null;
	     Svalid.kids = "0"b;
	     if ^Soutputable then go to reject;		/*    reject MSF if any components not outputable	*/
	     end;
	else go to reject;				/* reject all other node types.		*/
	go to return;

execdir(33):					/* library_print, level 3:  exec comps.		*/
lsinfodir(33):					/* library_print, level 3:  list/info comp?	*/
objdir(33):					/* library_print, level 3:  object comps.	*/
searchdir(33):					/* library_print, level 3:  source comps.	*/
	Scontrol = A.Scontrol;
	Sreq.names = "1"b;				/* must always require that names of things	*/
						/*   at this level be output, so that when -match	*/
						/*   is specified, archive and MSF component names*/
						/*   are still printed.			*/
	if node.T = Tarchive_comp then		/* for archive components:			*/
	     if node_outputable (Pnode) then;		/*    reject component if not outputable.	*/
	     else go to reject;
	else if node.Pparent -> node.T = Tmsf then do;	/* for msf components:			*/
	     if node.T = Tmsf_comp then;
	     else if node.T = Tlink then do;		/*    msf components which are links --		*/
chase_searchdir33:	if Sc.default then
		     node.Sreq = (node.Sreq | Sreq_link(A.command)) & node.Svalid;
		call next_tree_level ((ASrequirements), return);
		end;
	     end;
	else if node.Pparent -> node.T = Tlink then do;	/* for msf components which are links --	*/
	     if node.T = Tsegment then;
	     else if node.T = Tlink then go to chase_searchdir33;
	     end;
	else go to reject;				/* reject all other node types.		*/
	go to return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


execdir(42):					/* library_fetch, level 2:  exec ents.		*/
lsinfodir(42):					/* library_fetch, level 2:  list/info ents.	*/
objdir(42):					/* library_fetch, level 2:  object ents.	*/
searchdir(42):					/* library_fetch, level 2:  source ents.	*/
	Scontrol = A.Scontrol;
	if Sc.retain then;				/* eliminate nodes for library entries awaiting	*/
	else call reject_node_if_obsolete();		/*   deletion.				*/
	if node.T = Tsegment then;			/* for segments, all done.			*/
	else if node.T = Tlink then do;		/* for links:				*/
	     if Sc.default then			/*   add further default requirements to link.	*/
		node.Sreq = (node.Sreq | Sreq_link(A.command)) & node.Svalid;
	     if Sc.chase then			/*   if caller asked to chase links, do so.	*/
		call next_tree_level ((ASrequirements), return);
	     end;
	else if node.T = Tarchive then do;		/* for archives:				*/
	     if Sc.components then			/* tell about archive components.		*/
		Pstarname = addr(starstar);
	     else					/* tell about selected archive components.	*/
		Pstarname = A.Pstar;
	     if Sc.container then			/* wants to extract parent archive, not components*/
		Sreq.primary_name = "1"b;		/*   must return first name of archive as well.	*/
	     else do;				/* wants matching components, not parent archive.	*/
		Srequirements = A.Sreq;
		if Sc.default then Srequirements = Srequirements | Sreq_seg(4);
		call next_tree_level_special (return);
		node.Sreq = ""b;			/* return nothing about archive if matching	*/
		end;				/*   archive component(s) found.		*/
	     end;
	else if node.T = Tmsf then			/* for msfs:				*/
	     call next_tree_level (Sreq_msf_comp(A.command), return);
	else go to reject;				/* all other types of nodes should not be.	*/
	go to return;

execdir(43):					/* library_fetch, level 3:  exec comps.		*/
lsinfodir(43):					/* library_fetch, level 3:  list/info comp?	*/
objdir(43):					/* library_fetch, level 3:  object comps.	*/
searchdir(43):					/* library_fetch, level 3:  source comps.	*/
	Scontrol = A.Scontrol;
	if node.T = Tarchive_comp then
	     Sreq.primary_name = "1"b;		/* must get atleast first name back.		*/
	else if node.Pparent -> node.T = Tmsf then do;	/* for msf components:			*/
	     if node.T = Tmsf_comp then;
	     else if node.T = Tlink then do;		/*    msf components which are links --		*/
chase_searchdir43:	if Sc.default then
		     node.Sreq = (node.Sreq | Sreq_link(A.command)) & node.Svalid;
		call next_tree_level ((ASrequirements), return);
		end;
	     else go to reject;
	     end;
	else if node.Pparent -> node.T = Tlink then do;	/* for msf components which are links --	*/
	     if node.T = Tsegment then;
	     else if node.T = Tlink then go to chase_searchdir43;
	     else go to reject;
	     end;
	else go to reject;
	go to return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


execdir(51):					/* library_cleanup,level 1: execution dirs.	*/
lsinfodir(51):					/* library_cleanup,level 1: list/info dirs.	*/
objdir(51):					/* library_cleanup,level 1: object dirs.	*/
searchdir(51):					/* library_cleanup,level 1: source dirs.	*/
	if Sinit then call init_vars();		/* initialize internal static variables.	*/
	if node.T ^= Tdirectory then go to reject;	/* accept only directories as root nodes.	*/
	min_Scontrol = min_cleanup_Scontrol;
	max_Scontrol = max_cleanup_Scontrol;
	search_type = 1;
	call set_director_args (min_Scontrol, max_Scontrol, search_type);
						/* set up complete director control arguments.	*/
	node.Sreq = ""b;				/* output nothing about the root directory.	*/
	call next_tree_level (Sreq_seg(A.command), reject);
	go to return;				/* get nodes for lib entries p be deleted.	*/


execdir(52):					/* library_cleanup,level 2: exec ents.		*/
lsinfodir(52):					/* library_cleanup,level 2: list/info ents.	*/
objdir(52):					/* library_cleanup,level 2: object ents.	*/
searchdir(52):					/* library_cleanup,level 2: source ents.	*/
	if APstarname->starname.N = 1 then if APstarname->starname.V(1) = "!??????????????" then go to obsolete;
						/* if looking only for obsolete segments, skip	*/
						/* next check.				*/
	do PDnames = node.PD repeat Dnames.Pnext while (Dnames.T ^= Tnames);
	     end;					/* make sure entry has a unique name on it.	*/
	do i = 1 to APstarname->starname.N;
	     if APstarname->starname.V(i) = "!??????????????" then go to test;
	     end;
	go to obsolete;				/* omit test for unique name if no search name	*/
						/*   matches unique names.			*/
test:	if index (string(Dnames.names), "!") > 0 then
	     do i = 1 to Dnames.N;
		call match_star_name_ (Dnames.names(i), "!??????????????", code);
		if code = 0 then go to obsolete;
		end;
	go to reject;				/* reject nodes which aren't obsolete.		*/

obsolete:	if node.T = Tdirectory then go to reject;	/* can't delete directories; shouldn't anyway.	*/
	if node.T = Tarchive_comp then go to reject;	/* same for archive components.		*/
	if node.T = Tmsf_comp then go to reject;	/* same for msf components.			*/
	go to return;				/* all other types of nodes can be deleted.	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


hardcore_bc_dir:	entry     (Pnode, path, APstarname, APexclude, ASrequirements, AScontrol, tree_level,
			 link_level, Parea, Adirector, PA, PDnodes, Acode);

	Scontrol = AScontrol;
	if Sc.first_match & A.n_found > 0 then go to reject;
	go to hbd(A.command * 10 + tree_level);



hbd(11):						/* library_info,  level 1:  hardcore bc dir.	*/
hbd(21):						/* library_map,   level 1:  hardcore bc dir.	*/
hbd(31):						/* library_print, level 1:  hardcore bc dir.	*/
hbd(41):						/* library_fetch, level 1:  hardcore bc dir.	*/
	search_type = 2;				/* set search type info for hardcore.		*/

	if Sinit then call init_vars();		/* initialize internal static variables.	*/
	if node.T ^= Tdirectory then go to reject;	/* accept only the bound component dir as a root.	*/
	call set_director_args (min_object_Scontrol(A.command), max_object_Scontrol(A.command), search_type);
						/* set up complete director control arguments.	*/
	node.Sreq = ""b;				/* output nothing about the root directory.	*/
	Scontrol = A.Scontrol;			/* Because some of user's star names may match	*/
	Srequirements = A.Sreq;			/*    bc archives while others may match only	*/
	if Sc.default then Srequirements = Srequirements | Sreq_offline_seg(A.command);
	Pstarname = addr(starstar);			/*    bc archive components, we must search _a_l_l	*/
	call next_tree_level_special (reject);		/*    does not cost use anything if the user's	*/
	go to return;				/*    star name is "**".			*/

hbd(12):						/* library_info,  level 2:  hardcore bc archives.	*/
hbd(22):						/* library_map,   level 2:  hardcore bc archives.	*/
hbd(42):						/* library_fetch, level 2:  hardcore bc archives.	*/
	if ^Svalid.names then go to bc_nonames;
	do PDnames = node.PD repeat Dnames.Pnext while (Dnames.T ^= Tnames);
	     end;					/* If any of this bc archive's names match a	*/
	Pstarname = A.Pstar;			/*    user-specified star name, then output info	*/
						/*    about this bc archive.  Otherwise, don't.	*/
	do i = 1 to Dnames.N;
	     do j = 1 to starname.N;
		go to bc_test (starname.C(j));

bc_test(0):	if Dnames.names(i) = starname.V(j) then go to bc_match;
		else go to bc_nomatch;

bc_test(1):	call match_star_name_ (Dnames.names(i), starname.V(j), code);
		if code = 0 then go to bc_match;
		else go to bc_nomatch;

bc_test(2):	go to bc_match;
bc_nomatch:	end;
	     end;
bc_nonames:					/* Case 1:  no archive names match user star names*/
	if node.T ^= Tarchive then go to reject;	/*  Only archives handled in this case.		*/
	Scontrol = A.Scontrol;
	if starname.N = 1 then do;			/* speed up extraction of bind files.		*/
	     call match_star_name_ (starname.V(1), "**.bind", code);
	     if code = 0 then do;
		i = 33 - index(reverse(starname.V(1)), ".");
		auto_star.V = substr(starname.V(1),1,i) || "archive";
		call match_star_name_ (Dnames.names(1), auto_star.V, code);
		if code ^= 0 then go to reject;
		end;
	     end;
	if Sc.container then do;			/* user want's to know about parent archive	*/
						/*    of a matching archive component.		*/
	     call next_tree_level (Sreq_archive_comp_parent(A.command), reject);
	     if A.command = library_fetch then		/* for library_fetch, want to extract only the	*/
		call lib_free_node_$array (PDnodes);	/*   archive containing matching components, not	*/
						/*   the components as well.			*/
	     end;
	else do;					/* user doesn't want to know about parent archive.*/
	     node.Sreq = ""b;
	     call next_tree_level (Sreq_archive_comp_no_parent(A.command), reject);
	     end;
	go to return;
bc_match:						/* Case 2:  an archive name matches user star name*/
	if node.T ^= Tarchive then go to lsinfodir (A.command * 10 + tree_level);
	Scontrol = A.Scontrol;			/* set up control and requirements info.	*/
	Srequirements = A.Sreq;
	if Sc.default then 
	     if Sc.container then			/*    say little about archive component if we	*/
	          Srequirements = Srequirements | Sreq_archive_comp_parent(A.command);
	     else					/*    we are already given that info about parent.*/
	          Srequirements = Srequirements | Sreq_archive_comp_no_parent(A.command);

	if Sc.components then			/* user wants to know about _a_l_l archive comps	*/
	     Pstarname = addr(starstar);		/*    in this matching archive.		*/
	else					/* user wants info on only matching archive comps.*/
	     Pstarname = A.Pstar;
	call next_tree_level_special (suppress_nomatch);
	if A.command = library_fetch then		/* for library_fetch, if matching components	*/
	     node.Sreq = ""b;			/*    found, don't extract matching archive too.	*/
	else if ^Sc.container then 			/* if matching components found and parent info	*/
	     node.Sreq = ""b;			/*   not required, don't output it.		*/
	go to return;
 
hbd(13):						/* library_info,  level 3:  hardcore bc arch comp.*/
hbd(23):						/* library_map,   level 3:  hardcore bc arch comp.*/
	if node.Pparent -> node.T ^= Tarchive then go to reject;
						/* reject any node which isn't an archive comp.	*/
	Sreq.names = "1"b;				/* must always require that names of things	*/
						/*   at this level be output, so that when -match	*/
						/*   is specified, archive and MSF component names*/
						/*   are still printed.			*/
	go to return;


hbd(43):						/* library_fetch, level 3:  hardcore bc arch comp.*/
	if node.Pparent -> node.T ^= Tarchive then go to reject;
						/* reject any node (archive component or archived	*/
						/*   archive) which isn't in an archive.	*/
	Sreq.primary_name = "1"b;			/* must get atleast first name back.		*/
	go to return;

hbd(32):						/* library_print, level 2:  hardcore bc archives.	*/
	if node.T = Tarchive then node.Sreq = ""b;	/* an object archive itself can never be output.	*/
	if ^Svalid.names then go to bc_pr_nonames;
	do PDnames = node.PD repeat Dnames.Pnext while (Dnames.T ^= Tnames);
	     end;					/* If any of this bc archive's names match a	*/
	Pstarname = A.Pstar;			/*    user-specified star name, then output info	*/
						/*    about this bc archive.  Otherwise, don't.	*/
	do i = 1 to Dnames.N;
	     do j = 1 to starname.N;
		go to bc_pr_test (starname.C(j));

bc_pr_test(0):	if Dnames.names(i) = starname.V(j) then go to bc_pr_match;
		else go to bc_pr_nomatch;

bc_pr_test(1):	call match_star_name_ (Dnames.names(i), starname.V(j), code);
		if code = 0 then go to bc_pr_match;
		else go to bc_pr_nomatch;

bc_pr_test(2):	go to bc_pr_match;
bc_pr_nomatch:	end;
	     end;
bc_pr_nonames:					/* Case 1:  no archive names match user star names*/
	if node.T ^= Tarchive then go to reject;
	call next_tree_level (Sreq_archive_comp_no_parent(A.command), reject);
	go to return;

bc_pr_match:					/* Case 2:  an archive name matches user star name*/
	if node.T ^= Tarchive then go to lsinfodir(A.command * 10 + tree_level);
	Scontrol = A.Scontrol;			/* set up control and requirements info.	*/
	Srequirements = A.Sreq;
	if Sc.default then Srequirements = Srequirements | Sreq_archive_comp_no_parent(A.command);
	if Sc.components then			/* user wants to know about all components of	*/
	     Pstarname = addr(starstar);		/*    of this matching archive.		*/
	else					/* user wants info on only matching archive comps.*/
	     Pstarname = A.Pstar;
	call next_tree_level_special (reject);
	go to return;


hbd(33):						/* library_print, level 3:  hardcore bc arch comp.*/
	if node.Pparent -> node.T ^= Tarchive then go to reject;
						/* reject any node which isn't an archive comp.	*/
	if node_outputable (Pnode) then;		/* reject an unoutputable archive component.	*/
	else go to reject;
	Sreq.names = "1"b;				/* must always require that names of things	*/
						/*   at this level be output, so that when -match	*/
						/*   is specified, archive and MSF component names*/
						/*   are still printed.			*/
	go to return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


hardcore_object_dir: entry	(Pnode, path, APstarname, APexclude, ASrequirements, AScontrol, tree_level,
			 link_level, Parea, Adirector, PA, PDnodes, Acode);

	Scontrol = AScontrol;
	if Sc.first_match & A.n_found > 0 then go to reject;
	go to hod(A.command * 10 + tree_level);



hod(11):						/* library_info,  level 1:  hardcore object dir.	*/
hod(21):						/* library_map,   level 1:  hardcore object dir.	*/
hod(31):						/* library_print, level 1:  hardcore object dir.	*/
hod(41):						/* library_fetch, level 1:  hardcore object dir.	*/
	if Sinit then call init_vars();		/* initialize internal static variables.	*/
	search_type = 2;				/* set up search type.			*/

	if node.T ^= Tdirectory then go to reject;	/* accept only the object directory as a root.	*/
	call set_director_args (min_exec_Scontrol(A.command), max_exec_Scontrol(A.command), search_type);
						/* set up complete director control arguments.	*/
	node.Sreq = ""b;				/* output nothing about the root directory.	*/
	call next_tree_level (Sreq_offline_seg(A.command), reject);
						/* apply offline segment reqmts when getting	*/
	go to return;				/*    object segments at next tree level.	*/

hod(12):						/* library_info,  level 2:  hardcore object ents.	*/
hod(22):						/* library_map,   level 2:  hardcore object ents.	*/
hod(42):						/* library_fetch, level 2:  hardcore object ents.	*/
	if node.T ^= Tsegment then go to reject;	/* only segments are allowed in object dir.	*/
	go to return;				/* add system id to node information.		*/


hod(32):						/* library_print, level 2:  hardcore object ents.	*/
	if node.T ^= Tsegment then go to reject;	/* only segments are allowed in object dir.	*/
	if node_outputable (Pnode) then;		/* reject any unoutputable segment.		*/
	else go to reject;
	go to return;				/* add system id to node information.		*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


hardcore_source_dir: entry	(Pnode, path, APstarname, APexclude, ASrequirements, AScontrol, tree_level,
			 link_level, Parea, Adirector, PA, PDnodes, Acode);

	Scontrol = AScontrol;
	if Sc.first_match & A.n_found > 0 then go to reject;
	go to hsd(A.command * 10 + tree_level);


hsd(11):						/* library_info,  level 1:  hardcore source dir.	*/
hsd(21):						/* library_map,   level 1:  hardcore source dir.	*/
hsd(31):						/* library_print, level 1:  hardcore source dir.	*/
hsd(41):						/* library_fetch, level 1:  hardcore source dir.	*/
	search_type = 2;				/* set search type info for hardcore.		*/

	if Sinit then call init_vars();		/* initialize internal static variables.	*/
	if node.T ^= Tdirectory then go to reject;	/* accept only the source directory as a root.	*/
	call set_director_args (min_source_Scontrol(A.command), max_source_Scontrol(A.command), search_type);
						/* set up complete director control arguments.	*/
	node.Sreq = ""b;				/* output nothing about the source directory.	*/
	Scontrol = A.Scontrol;			/* set up control and requirements info in	*/
	Srequirements = A.Sreq;			/*    for getting next tree level.		*/
	if Sc.default then Srequirements = Srequirements | Sreq_offline_seg(A.command);
	Pstarname = A.Pstar;			/* access the user's star name.		*/
	code = 1;
	if A.command = library_info then		/* for library_info, if a single star name was	*/
	     if starname.N = 1 then			/*   given, and it matches archive name format,	*/
		call match_star_name_ (starname.V(1), "**.archive", code);
						/*   treat it as the search name w/o modification.*/
	if (starname.N = 1) & (code ^= 0) then do;	/* if he gave only 1 star name, we can look only	*/
						/*    in those source archives which might hold	*/
						/*    matches for that name.			*/
	     auto_star.N = 1;
	     auto_star.V = substr(starname.V(1),1,1) || "?.archive";
	     auto_star.C = 1;			/* map    "able.pl1" into "a?.archive";		*/
	     Pstarname = addr(auto_star);		/*	"*.alm"    into "*?.archive";		*/
	     end;					/*	"?able.*"  into "??.archive".		*/
	else if code = 0 then;			/* use user's archive name if in that format.	*/
	else					/* if more than one star name, we must look in	*/
	     Pstarname = addr(starstar);		/*    _a_l_l source archives for matches.		*/
	call next_tree_level_special (reject);		/* get tree nodes for archives which contain	*/
						/*    source components which match user's star	*/
	go to return;				/*    names.				*/


hsd(12):						/* library_info,  level 2:  hardcore source arch.	*/
hsd(22):						/* library_map,   level 2:  hardcore source arch.	*/
hsd(32):						/* library_print, level 2:  hardcore source arch.	*/
hsd(42):						/* library_fetch, level 2:  hardcore source arch.	*/
	if node.T ^= Tarchive then go to reject;	/* accept only source archives.		*/
	Pstarname = A.Pstar;			/* see if this archive can possible contain what	*/
	do PDnames = node.PD repeat Dnames.Pnext while (Dnames.T ^= Tnames);
	     end;					/*     what we're looking for.		*/
	do i = 1 to starname.N;
	     call match_star_name_ (Dnames.names(1), substr(starname.V(i),1,1) || "?.archive", code);
	     if code = 0 then go to hs_match;
	     end;
	go to reject;
hs_match:	if A.command ^= library_info then do;
	     call next_tree_level (Sreq_archive_comp_no_parent(A.command), reject);
						/* get tree nodes for matching source comps, but	*/
						/*    reject node for source archive if no	*/
						/*    matching source components are found.	*/
	     node.Sreq = ""b;
	     end;
	else do;					/* for library_info, allow information about the	*/
						/*   source archives, themselves.		*/
	     Scontrol = A.Scontrol;
	     Srequirements = A.Sreq;
	     if Sc.default then
		if Sc.container then		/*    say little about archive component if we	*/
		     Srequirements = Srequirements | Sreq_archive_comp_parent(A.command);
		else				/*    we are already given that info about parent.*/
		     Srequirements = Srequirements | Sreq_archive_comp_no_parent(A.command);
	     if APstarname = A.Pstar then do;		/* if user gave an archive name, rather than a	*/
						/*   component name, process things differently.	*/
		if Sc.components then do;		/* User wants all components back as well. OK	*/
		     Pstarname = addr(starstar);
		     call next_tree_level_special (return);
		     end;
		end;
	     else do;				/* user gave an archive component name.		*/
		Pstarname = A.Pstar;
		call next_tree_level_special (reject);	/* find matching archive components.		*/
		if ^Sc.container then
		    node.Sreq = ""b;
		end;
	     end;
	go to return;


hsd(13):						/* library_info,  level 3:  hardcore source comp.	*/
hsd(23):						/* library_map,   level 3:  hardcore source comp.	*/
hsd(33):						/* library_print, level 3:  hardcore source comp.	*/
hsd(43):						/* library_fetch, level 3:  hardcore source comp.	*/
	if node.T ^= Tarchive_comp then go to reject;	/* accept only archive components at this level.	*/
	Sreq.names = "1"b;				/* must always require that names of things	*/
						/*   at this level be output, so that when -match	*/
						/*   is specified, archive and MSF component names*/
						/*   are still printed.			*/
	go to return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


         execdir(61):
         lsinfodir(61):
         objdir(61):
         searchdir(61):
         ptd(61):
hbd(51): hbd(61):
hod(51): hod(61):
hsd(51): hsd(61):
	Acode = error_table_$undefined_order_request;	/* complain about unsupported commands/dirs	*/
	go to return;

reject:	Acode = error_table_$nomatch;			/* reject our input node.			*/
	return;

return:	if node.Sreq ^= ""b then A.n_found = A.n_found + 1;
	if Sc.first_match & A.n_found > 0 then Acode = error_table_$process_stopped;
	if PDnodes ^= null then
	     if Dnodes.C = error_table_$logical_volume_not_connected then Acode = Dnodes.C;
	return;					/* return our input node, in spite of any error	*/
						/*    in getting its descendant nodes.		*/

suppress_nomatch:					/* suppress a nomatch error when getting any	*/
	if PDnodes = null then;			/*    descendants of our input node.		*/
	else call lib_free_node_$array(PDnodes);
	go to return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

init_vars:  procedure;		  		/* This procedure initializes internal static	*/
						/*    variables which are used as constants.	*/
						/*    The variables include node requirement	*/
				 		/*    switches and search control switches.  They	*/
			 			/*    are initialized by referencing the switch	*/
						/*    bits by name to allow flexibility in	*/
						/*    reordering and extending the switches, and	*/
						/*    to simplify the interpretation of the	*/
						/*    array of switch bits.			*/

	ring = get_ring_();				/* get current ring number.			*/

	Srequirements = ""b;
	S.primary_name = "1"b;
	S.matching_names = "1"b;
	S.type = "1"b;
	S.pathname = "1"b;
	S.dtm = "1"b;
	S.level = "1"b;
	S.new_line = "1"b;
	S.kids_error = "1"b;
	Sreq_offline_seg(1) = Srequirements;		/* library_info:  default requirements		*/
	Sreq_seg(1) = Srequirements;

	string(S) = ""b;
	S.primary_name = "1"b;
	S.matching_names = "1"b;
	S.names = "1"b;
	S.type = "1"b;
	S.pathname = "1"b;
	S.dtm = "1"b;
	S.dtem = "1"b;
	S.copy = "1"b;
	S.safety = "1"b;
	S.level = "1"b;
	S.new_line = "1"b;
	S.kids_error = "1"b;
	S.cross_ref = "1"b;
	Sreq_offline_seg(2) = Srequirements;		/* library_map:  offline segs, default reqmts.	*/
	S.dtd = "1"b;
	S.current_length = "1"b;
	S.records_used = "1"b;
	S.max_length = "1"b;
	S.bit_count = "1"b;
	S.rb = "1"b;
	Sreq_seg(2) = Srequirements;			/* library_map:  online segs, default requirements*/

	string(S) = ""b;
	S.primary_name = "1"b;
	S.matching_names = "1"b;
	S.names = "1"b;
	S.type = "1"b;
	S.pathname = "1"b;
	S.dtm = "1"b;
	S.dtem = "1"b;
	S.copy = "1"b;
	S.level = "1"b;
	S.new_line = "1"b;
	S.kids_error = "1"b;
	Sreq_seg(3) = Srequirements;			/* library_print:  online segs, default reqmts.	*/
	Sreq_offline_seg(3) = Srequirements;		/* library_print:  offline segs, default reqmts.	*/

	string(S) = ""b;
	S.primary_name = "1"b;
	S.matching_names = "1"b;
	S.type = "1"b;
	S.pathname = "1"b;
	S.dtm = "1"b;
	S.copy = "1"b;
	S.bit_count = "1"b;
	S.dtc = "1"b;
	S.compiler_version = "1"b;
	S.compiler_options = "1"b;
	S.object_info = "1"b;
	S.level = "1"b;
	S.new_line = "1"b;
	S.kids_error = "1"b;
	Sreq_seg(4) = Srequirements;			/* library_fetch:  default requirements.	*/
	Sreq_offline_seg(4) = Srequirements;

	string(S) = ""b;
	S.primary_name = "1"b;
	S.matching_names = "1"b;
	S.type = "1"b;
	S.pathname = "1"b;
	S.dtem = "1"b;
	S.copy = "1"b;
	S.kids_error = "1"b;
	Sreq_seg(5) = Srequirements;			/* library_cleanup:  default requirements	*/

	string(S) = ""b;
	S.link_target = "1"b;
	Sreq_link(4) = Srequirements;			/* for library_fetch - add only link path.	*/
	S.dtem = "1"b;
	Sreq_link(1) = Srequirements;			/* requirements added by default for links.	*/
	Sreq_link(2) = Srequirements;
	Sreq_link(3) = Srequirements;
	Sreq_link(5) = Srequirements;

	Sreq_msf_comp(1) = Sreq_seg(1);		/* requirements for online msf comp = online segs.*/
	Sreq_msf_comp(2) = Sreq_seg(2);
	Sreq_msf_comp(3) = Sreq_seg(3);
	Sreq_msf_comp(4) = Sreq_seg(4);

	string(S) = ""b;				/* requirements for mapped archive components	*/
	S.primary_name = "1"b;
	S.matching_names = "1"b;
	S.names = "1"b;
	S.dtem = "1"b;
	S.level = "1"b;
	S.new_line = "1"b;
	S.kids_error = "1"b;
	Sreq_archive_comp_parent(1) = Srequirements;	/* for archive comp when parent archive listed.	*/
	S.cross_ref = "1"b;
	Sreq_archive_comp_parent(2) = Srequirements;
	S.cross_ref = "0"b;
	Sreq_archive_comp_parent(3) = Srequirements;
	Sreq_archive_comp_parent(4) = Sreq_seg(4);
	S.type = "1"b;
	S.pathname = "1"b;
	Sreq_archive_comp_no_parent(1) = Srequirements;	/* for archive comp when parent archive omitted.	*/
	Sreq_archive_comp_no_parent(2) = Srequirements;
	Sreq_archive_comp_no_parent(3) = Srequirements;
	S.bit_count = "1"b;
	S.dtc = "1"b;
	S.compiler_version = "1"b;
	S.compiler_options = "1"b;
	S.object_info = "1"b;
	S.level = "0"b;
	Sreq_archive_comp_no_parent(4) = Srequirements;

	max_Srequirements(2) = (72)"1"b;		/* any requirements are allowed for library_map.	*/
	Srequirements = (72)"1"b;
	S.cross_ref = "0"b;
	max_Srequirements(1) = Srequirements;		/* name cross-reference omitted for library_info. */
	max_Srequirements(3) = Srequirements;		/* same for library_print.			*/
	max_Srequirements(4) = Srequirements;		/* same for library_fetch.			*/
	max_Srequirements(5) = Srequirements;		/* same for library_cleanup.			*/

	min_cleanup_Scontrol = ""b;			/* library_cleanup:  no minimum control.	*/
	Scontrol = (36)"1"b;
	Sc.chase = "0"b;
	Sc.object_info = "0"b;
	Sc.acl = "0"b;
	Sc.iacl = "0"b;
	Sc.all_status = "0"b;
	Sc.check_ascii = "0"b;
	Sc.check_archive = "0"b;
	max_cleanup_Scontrol = Scontrol;		/* library_cleanup:  maximum control.		*/

	min_exec_Scontrol(1) = ""b;			/* library_info:   exec dirs, no minimum control.	*/
	min_exec_Scontrol(2) = ""b;			/* library_map:    exec dirs, no minimum control.	*/
	Scontrol = ""b;
	Sc.check_ascii = "1"b;
	min_exec_Scontrol(3) = Scontrol;		/* library_print:  exec dirs, check printability.	*/
	Scontrol = ""b;
	Sc.object_info = "1"b;
	min_exec_Scontrol(4) = Scontrol;		/* library_fetch:  exec dirs, check for obj seg.	*/
	Scontrol = (36)"1"b;
	Sc.check_archive = "0"b;
	max_exec_Scontrol(1) = Scontrol;		/* library_info:   exec dirs, no archives.	*/
	max_exec_Scontrol(2) = Scontrol;		/* library_map:    exec dirs, no archives.	*/
	max_exec_Scontrol(3) = Scontrol;		/* library_print:  exec dirs, no archives.	*/
	Sc.check_ascii = "0"b;
	max_exec_Scontrol(4) = Scontrol;		/* library_fetch:  no ascii check either.	*/

	min_list_info_Scontrol(1) = ""b;		/* library_info:   list/info, no minimum control.	*/
	min_list_info_Scontrol(2) = ""b;		/* library_map:    list/info, no minimum control.	*/
	min_list_info_Scontrol(3) = ""b;		/* library_print:  list/info, no minimum control.	*/
	min_list_info_Scontrol(4) = ""b;		/* library_fetch:  list/info, no minimum control.	*/
	Scontrol = (36)"1"b;
	Sc.object_info = "0"b;
	Sc.check_archive = "0"b;
	Sc.check_ascii = "0"b;
	max_list_info_Scontrol(1) = Scontrol;		/* library_info:   list/info, no checking needed.	*/
	max_list_info_Scontrol(2) = Scontrol;		/* library_map:    list/info, no checking needed.	*/
	max_list_info_Scontrol(3) = Scontrol;		/* library_print:  list/info, no checking needed.	*/
	max_list_info_Scontrol(4) = Scontrol;		/* library_fetch:  list/info, no checking needed.	*/

	Scontrol = ""b;
	Sc.check_archive = "1"b;
	min_object_Scontrol(1) = Scontrol;		/* library_info:   object dirs, check archives.	*/
	min_object_Scontrol(2) = Scontrol;		/* library_map:    object dirs, check archives.	*/
	Sc.check_ascii = "1"b;
	min_object_Scontrol(3) = Scontrol;		/* library_print:  object dirs, check printability*/
	Scontrol = ""b;
	Sc.check_archive = "1"b;
	Sc.object_info = "1"b;
	min_object_Scontrol(4) = Scontrol;		/* library_fetch:  object dirs, check arch/obj seg*/
	max_object_Scontrol(1) = (36)"1"b;		/* library_info:   object dirs, no maximum control*/
	max_object_Scontrol(2) = (36)"1"b;		/* library_map:    object dirs, no maximum control*/
	max_object_Scontrol(3) = (36)"1"b;		/* library_print:  object dirs, no maximum control*/
	max_object_Scontrol(4) = (36)"1"b;		/* library_fetch:  object dirs, no maximum control*/

	Scontrol = ""b;
	Sc.check_archive = "1"b;
	min_source_Scontrol(1) = Scontrol;		/* library_info:   source dirs, check archives.	*/
	min_source_Scontrol(2) = Scontrol;		/* library_map:    source dirs, check archives.	*/
	min_source_Scontrol(3) = Scontrol;		/* library_print:  source dirs, check archives.	*/
	min_source_Scontrol(4) = Scontrol;		/* library_fetch:  source dirs, check archives.	*/
	Scontrol = (36)"1"b;
	Sc.object_info = "0"b;
	Sc.check_ascii = "0"b;
	max_source_Scontrol(1) = Scontrol;		/* library_info:   source dirs, no obj/ascii segs.*/
	max_source_Scontrol(2) = Scontrol;		/* library_map:    source dirs, no obj/ascii segs.*/
	max_source_Scontrol(3) = Scontrol;		/* library_print:  source dirs, no obj/ascii segs.*/
	max_source_Scontrol(4) = Scontrol;		/* library_fetch:  source dirs, no obj/ascii segs.*/

	Sinit = "0"b;

	end init_vars;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


next_tree_level:	procedure (default_Sreq, error_return);	/* procedure which obtains descendants of our	*/
						/*    input node.				*/

     dcl	default_Sreq		bit(72) aligned,	/* default requirements switches. (In)		*/
	error_return		label;		/* error return point. (In)			*/

	Scontrol = A.Scontrol;
	Srequirements = A.Sreq;
	if Sc.default then Srequirements = Srequirements | default_Sreq;
						/* apply default requirements if asked to do so.	*/
	Pstarname = A.Pstar;


next_tree_level_special:	entry	(error_return);	/* entry for using special star names, etc.	*/

	call lib_get_tree_ (Pnode, path, Pstarname, APexclude, Srequirements, Scontrol, tree_level,
			link_level, Parea, Adirector, PA, PDnodes, code);
						/* get the node(s) at the descendant tree level.	*/
	if PDnodes = null then go to error_return;	/* a very serious error has occurred.		*/
	if Dnodes.C = error_table_$nomatch then		/* only other important error is no descendants.	*/
	     go to error_return;

	end next_tree_level;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


node_outputable:	procedure (Pnode_)			/* This internal procedure determines if a library*/
	     returns	(bit(1) aligned);		/* entry is outputable.			*/

     dcl	Pnode_			ptr;		/* ptr to node to be tested.			*/

     dcl	PDnodes_			ptr,		/* ptr to a node array descriptor.		*/
	i			fixed bin;	/* a do-group index.			*/

     dcl	1 Dnodes_			aligned based (PDnodes_),
		     				/* a node array descriptor.			*/
	  2 header		like Dnodes.header, 
	  2 nodes (Nnodes refer (Dnodes_.N))
				like node,

	1 node_			aligned based (Pnode_) like node,
		     				/* a node.				*/
	1 Svalid			aligned based (addr (node_.Svalid)) like Svalid_req;
		     				/* switches indicating which node info is valid.	*/

	if node_.T = Tsegment then			/* if this node is a segment,			*/
msf_comp:	     if node_.rb(2) < ring then;		/*    and it is readable in this ring,		*/
	     else if ^substr(node_.Smode,1,1) then;
	     else
arch_comp:	if node_.bit_count < 9 then;		/*    and it has a non-zero bit count,		*/
	     else if mod (node_.bit_count, 9) ^= 0 then;	/*    and its bit count says it contains chars,	*/
	     else if Svalid.object_info then;		/*    and it was not proven to be an obj segment	*/
	     else if Svalid.not_ascii then;
						/*    and it is not a non-ascii or pt seg, 	*/
	     else return ("1"b);			/*    then segment is outputable.		*/

	else if node_.T = Tmsf_comp then		/* if this node is an msf component, treat it	*/
	     go to msf_comp;			/*    like a segment.			*/

	else if node_.T = Tlink then			/* if this node is a link,			*/
	     if Svalid.kids then do;			/*    if the link was chased,			*/
	          do PDnodes_ = node_.PD repeat Dnodes_.Pnext while (Dnodes_.header.T ^= Tnodes);
		     end;
	     	return (node_outputable (addr (Dnodes_.nodes(1))));
	          end;				/*    Let outputability of link target determine	*/
	     else;				/*    outputability of link.			*/

	else if node_.T = Tarchive then		/* if this node is an archive,		*/
	     if Svalid.not_ascii then;		/*    and it is not a non-ascii archive,	*/
	     else return ("1"b);			/*    then it is outputable.			*/

	else if node_.T = Tarchive_comp then		/* if this node is an archive component,	*/
	     go to arch_comp;			/*    treat it like a segment to which we already	*/
		     				/*    know we have access.  (We found out it was	*/
		     				/*    an archive component, didn't we?)		*/

	else if node_.T = Tmsf then			/* if this node is an MSF, let it's outputability	*/
	     if Svalid.kids then do;			/*    hinge on outputability of its components.	*/
	          do PDnodes_ = node_.PD repeat Dnodes_.Pnext while (Dnodes_.header.T ^= Tnodes);
		     end;
	          do i = 1 to Dnodes_.N while (node_outputable (addr (Dnodes_.nodes(i))));
		     end;
		if i > Dnodes_.N then return ("1"b);	/*    if all components outputable, so if MSF.	*/
	          end;

	return ("0"b);				/* otherwise, node is not outputable.		*/

	end node_outputable;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


reject_node_if_obsolete:	procedure;		/* This procedure examines the names on a node to	*/
						/*    determine if any are unique names.  If so,	*/
						/*    then the node is rejected.		*/

	do PDnames = node.PD repeat Dnames.Pnext while (Dnames.T ^= Tnames);
	     end;
	if index (string(Dnames.names), "!") > 0 then
	     do i = 1 to Dnames.N;
	          call match_star_name_ (Dnames.names(i), "!??????????????", code);
	          if code = 0 then go to reject;
	          end;

	end reject_node_if_obsolete;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


set_director_args:	procedure (min_Scontrol, max_Scontrol, search_type);
						/* procedure to replace incoming director	*/
						/*    control argument, which is a command index,	*/
						/*    by a more elaborate structure which includes*/
						/*    all user arguments which might be modified	*/
						/*    when getting one tree level, and then be	*/
						/*    restored at the next tree level.		*/

     dcl (max_Scontrol, min_Scontrol)	bit(36) aligned,	/* min/max control switch settings. (In)	*/
	search_type		fixed bin;	/* search type. (In)			*/

	director_args.command = A.command;		/* fill in director arguments.		*/
	director_args.n_found = A.n_found;
	PA_saved = PA;
	PA = addr(director_args);
	A.Pstar = APstarname;
	A.Sreq = ASrequirements & max_Srequirements(A.command);
	Scontrol = AScontrol;
	Scontrol = Scontrol & max_Scontrol;
	Scontrol = Scontrol | min_Scontrol;
	A.Scontrol = Scontrol;
	A.search_type = search_type;

	end set_director_args;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

%include lib_node_;


%include lib_commands_;

	end multics_library_search_;
