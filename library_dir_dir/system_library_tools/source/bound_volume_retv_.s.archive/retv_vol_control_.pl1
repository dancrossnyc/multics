/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(89-08-31,GWMay), approve(89-10-03,MCR8135),
     audit(89-10-04,Beattie), install(89-10-10,MR12.3-1089):
     Updated to process version 3 of backup_volume_log.incl.pl1 structures.
                                                   END HISTORY COMMENTS */


/* format: style1,ind2,^inddcls,ifthenstmt,dclind2,declareind2,ifthendo,ifthen*/

retv_vol_control_: proc (inputp, code);

/*
   This routine computes the set of volumes that a retrieval request might be
   found on and then creates, if not already existent, the retriever_volume_control segment
   for that volume and adds an entry to it for the retrieval request. If the object
   does not have a branch in the hierarchy then the parent tree is searched until a existant
   superior directory is found. This directory is then recovered and the branch structure is appended.
*/
/* Modified 6/79 by D. Vinograd to add directory name space searching from files created by volume dumper.
   This feature means that if the directory name space file is available then one can check if an entry name
   is in the directory dumped on tape and thus not have to read the tape during branch retrieval.
  Modified: 8/83 by GA Texada to
	     1) not look in the volume logs when -manual has been specified.
	     2) announce only once that a volume may be searched when contents seg is missing.
	     3) Reformatted and moved the %include's too.
*/
dcl answer	     char (3) var;
dcl a_rvcp	     ptr;
dcl message	     char (256);
dcl char_num	     char (32);
dcl code		     fixed bin (35);
dcl comp_cycle_uid	     bit (36);
dcl found		     bit (1);
dcl comp_indx	     fixed bin;
dcl comp_open_time	     fixed bin (71);
dcl cons_cycle_uid	     bit (36);
dcl cons_indx	     fixed bin;
dcl cons_open_time	     fixed bin (71);
dcl contents_idx	     fixed bin;
dcl control_name	     char (32);
dcl dirname	     char (168);
dcl done		     bit (1);
dcl emode		     bit (36);
dcl ename		     char (32);
dcl entry_name	     char (32);
dcl entry_retrieval	     bit (1);
dcl rvlx		     fixed bin;
dcl idx		     fixed bin;
dcl lns		     fixed bin;
dcl logged	     bit (1);
dcl test_name	     char (32);
dcl ignore	     fixed bin (35);
dcl incr_indx	     fixed bin;
dcl incr_close_time	     fixed bin (71);
dcl cons_close_time	     fixed bin (71);
dcl comp_close_time	     fixed bin (71);
dcl incr_open_time	     fixed bin (71);
dcl latest_indx	     fixed bin;
dcl link_retrieval	     bit (1);
dcl lock		     bit (1);
dcl lsearch_name	     char (32);
dcl ncp		     ptr;
dcl nelemt	     fixed bin;
dcl no_contents_seg	     bit (1);
dcl num		     fixed bin;
dcl object_retrieval     bit (1);
dcl old_dirname	     char (168);
dcl open_time	     fixed bin (71);
dcl parent_check	     bit (1);
dcl pmode		     bit (36);
dcl psearch_name	     char (32);
dcl pvid		     bit (36);
dcl recursion_level	     fixed bin;
dcl search_name	     char (32);
dcl sortx		     fixed bin;
dcl sorty		     fixed bin;
dcl start_numeric	     fixed bin;
dcl type		     fixed bin;
dcl uid		     bit (36);
dcl vdtd		     bit (36) aligned;
dcl vlx		     fixed bin;
dcl volid		     bit (36);
dcl volname	     char (32);
dcl vtoce_derived_volname char (32);
dcl fcbp		     ptr;
dcl vtoce_volid	     (3) bit (36);
dcl dump_type	     fixed bin;
dcl nsp		     ptr;

dcl based_char_string    char (1048576) based (ptr (contents_namesp, backup_volume_contents.offset (contents_idx)));
dcl name_string	     based (nsp) char (lns);

dcl 1 local_rvce	     like rvce aligned;

dcl 1 volume_id	     aligned,
    2 char	     char (2) unaligned,
    2 num		     fixed bin unaligned;


dcl myname	     char (32) static init ("retv_vol_control_") options (constant);
dcl segment	     fixed bin int static init (1) options (constant);
dcl DIR		     fixed bin int static init (2) options (constant);
dcl LINK		     fixed bin int static init (3) options (constant);
dcl rw		     bit (3) int static init ("101"b) options (constant);
dcl sm		     bit (3) int static init ("110"b) options (constant);

dcl iox_$user_input	     ptr ext;
dcl error_table_$action_not_performed ext fixed bin (35);
dcl error_table_$segfault ext fixed bin (35);
dcl error_table_$bad_volid ext fixed bin (35);
dcl error_table_$locked_by_this_process ext fixed bin (35);
dcl error_table_$bad_segment ext fixed bin (35);
dcl error_table_$invalid_lock_reset ext fixed bin (35);

dcl retv_notify_	     entry (char (*), ptr, char (*));
dcl get_temp_segment_    entry (char (*), ptr, fixed bin (35));
dcl release_temp_segment_ entry (char (*), ptr, fixed bin (35));
dcl hcs_$terminate_noname entry (ptr, fixed bin (35));
dcl hcs_$fs_move_seg     entry (ptr, ptr, fixed bin (1), fixed bin (35));
dcl msf_manager_$close   entry (ptr);
dcl msf_manager_$open    entry (char (*), char (*), ptr, fixed bin (35));
dcl msf_manager_$get_ptr entry (ptr, fixed bin, bit (1), ptr, fixed bin, fixed bin (35));
dcl suffixed_name_$make  entry (char (*), char (*), char (*), fixed bin (35));
dcl expand_pathname_     entry (char (*), char (*), char (*), fixed bin (35));
dcl ioa_		     entry options (variable);
dcl ioa_$nnl	     entry options (variable);
dcl iox_$get_line	     entry (ptr, ptr, fixed bin, fixed bin, fixed bin (35));
dcl cv_dec_check_	     entry (char (*), fixed bin (35)) returns (fixed bin);
dcl command_query_	     entry options (variable);
dcl retv_report_$error_output entry options (variable);
dcl retv_report_$online_output entry options (variable);
dcl ioa_$rsnnl	     entry options (variable);
dcl message_segment_$update_message_index entry (fixed bin, fixed bin, bit (72) aligned, ptr, fixed bin (35));
dcl hcs_$make_seg	     entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
dcl mdc_$find_volname    entry (bit (36), char (*), char (*), fixed bin (35));
dcl set_lock_$lock	     entry (bit (36) aligned, fixed bin, fixed bin (35));
dcl set_lock_$unlock     entry (bit (36) aligned, fixed bin (35));
dcl hcs_$initiate	     entry (char (*), char (*), char (*), fixed bin, fixed bin, ptr, fixed bin (35));
dcl hc_backup_$retv_status entry (char (*), char (*), bit (72) aligned, char (*) aligned,
		     fixed bin, fixed bin, bit (36), bit (36), bit (36), bit (36),
		     (3) bit (36), bit (36) aligned, fixed bin (35));

dcl seg_fault_error	     condition;

dcl min		     builtin;
dcl hbound	     builtin;
dcl index		     builtin;
dcl ptr		     builtin;
dcl unspec	     builtin;
dcl null		     builtin;
dcl search	     builtin;
dcl max		     builtin;
dcl addr		     builtin;
dcl length	     builtin;
dcl size		     builtin;
dcl substr	     builtin;
dcl rtrim		     builtin;

/* initialize local variables to default values */
    code = 0;
    lock = "0"b;
    vtoce_derived_volname = "";
    entry_name = "";
    link_retrieval = "0"b;
    parent_check = "0"b;
    entry_retrieval = "0"b;
    object_retrieval = "0"b;
    vtoce_volid (*) = "0"b;
    uid = "0"b;
    vdtd = "0"b;
    emode = "0"b;
    pmode = "0"b;
    logged = "0"b;
    bvlp, rvcp, rvcep = null;
    contentsp, contents_namesp = null;
    recursion_level = 0;

/* pick up static ptrs */
    skip = retv_data_.skip;
    vlp = retv_data_.vlp;
						/* copy args from input structure */
    dirname = retv_input.dirname;
    ename = retv_input.ename;

/* Check to see if object in hierarchy. if so get what ever information we can about it. If not in the
   hierarcy then the uid will be zero */

status:
    call hc_backup_$retv_status (dirname, ename, retv_input.access_class, retv_input.requestor,
      retv_input.level, type, emode, pmode, uid, pvid, vtoce_volid, vdtd, code);

/* In cross retrieval case object must exist and must be a segment. Check that this is so */

    if retv_input.new_dirname ^= "" then do;
        if recursion_level ^= 0
	| uid = "0"b then do;
	  call ioa_$rsnnl ("Cannot locate ^a^[>^]^a for cross retrieval ", message, 0,
	    dirname, dirname ^= ">", ename);
	  call retv_notify_ (message, inputp, myname);
	  code = -1;
	  goto finish;
	end;
        if type ^= segment then do;
	  call ioa_$rsnnl ("Cross directory retrieval of ^a^[>^]^a not allowed", message, 0,
	    dirname, dirname ^= ">", ename);
	  call retv_notify_ (message, inputp, myname);
	  code = -1;
	  goto finish;
	end;
      end;

/* First check to see if requestor has the correct access.  Access must be sufficient to modify the object
   either directly or be able to set access at the parent level to do so. */

    if uid ^= "0"b & type ^= LINK then do;
        if type = segment & ((emode & rw) = rw | (pmode & sm) = sm) then goto access_ok;
        if (type = DIR | type = LINK) & ((emode & sm) = sm | (pmode & sm) = sm) then goto access_ok;
        call ioa_$rsnnl ("Incorrect access to retrieve ^a^[>^]^a", message, 0, dirname, dirname ^= ">", ename);
        code = -1;
        call retv_notify_ (message, inputp, myname);
        goto finish;
access_ok:
        if parent_check then entry_retrieval = "1"b;
        else object_retrieval = "1"b;

/* If dump information exists then determine the most recent volume id by back scanning the volume log for a match.
   The volume log is located by converting the object's pvid to name and initiating that name in the sub-system dir.
   If a time bracket has been specified then the found volume must fit within it. Save the volume name and id if found */

        if ^retv_data_.manual & (vtoce_volid (incr) ^= "0"b |
	vtoce_volid (cons) ^= "0"b |
	vtoce_volid (comp) ^= "0"b) then do;
	  call find_volume_log;
	  if bvlp = null then do;
no_volog:	      call retv_report_$error_output (code, myname, "Unable to locate ^a.volog", psearch_name);
	      goto finish;
	    end;
	  if ^lock then call lock_volume_log;
	  if code ^= 0 then do;
volog_lock_err: call retv_report_$error_output (code, myname, "Error locking ^a", psearch_name);
	      goto finish;
	    end;
	  lock = "1"b;

	  incr_open_time = 0;
	  cons_open_time = 0;
	  comp_open_time = 0;
	  incr_close_time = 0;
	  cons_close_time = 0;
	  comp_close_time = 0;
	  incr_indx, cons_indx, comp_indx = 0;

	  do idx = backup_volume_log.next to 1 by -1;
	    bvlep = addr (backup_volume_log.array (idx));
	    if vtoce_volid (incr) ^= "0"b & vtoce_volid (incr) = bvle.volid then do;
	        incr_open_time = bvle.open_time;
	        incr_close_time = bvle.close_time;
	        incr_indx = idx;
	      end;
	    else if vtoce_volid (cons) ^= "0"b & vtoce_volid (cons) = bvle.volid then do;
	        cons_open_time = bvle.open_time;
	        cons_close_time = bvle.close_time;
	        cons_indx = idx;
	      end;
	    else if vtoce_volid (comp) ^= "0"b & vtoce_volid (comp) = bvle.volid then do;
	        comp_open_time = bvle.open_time;
	        comp_close_time = bvle.close_time;
	        comp_indx = idx;
	      end;
	  end;

	  if retv_input.to_time ^= 0 then do;
	      if incr_open_time > retv_input.to_time then incr_indx = 0;
	      if cons_open_time > retv_input.to_time then cons_indx = 0;
	      if comp_open_time > retv_input.to_time then comp_indx = 0;
	    end;

	  if retv_input.from_time ^= 0 then do;
	      if incr_close_time < retv_input.from_time then incr_indx = 0;
	      if cons_close_time < retv_input.from_time then cons_indx = 0;
	      if comp_close_time < retv_input.from_time then comp_indx = 0;
	    end;

	  latest_indx = max (incr_indx, cons_indx, comp_indx);
	  if latest_indx ^= 0 then do;
	      bvlep = addr (backup_volume_log.array (latest_indx));
	      vtoce_derived_volname = bvle.volname;
	    end;

	end;

/* Now search the volume log as if there was no dump information, as well there might. Find the
   volume log, if not already found, lock it, and back scan it. If no time bracket is specified then we
   skip over incremental tapes that are superceeded by consolidated tape and consolidated tapes that are
   superceeded by complete dumps. If a time bracket is specified then we look at all the
   dump volumes in case the object was deleted prematurely. For each dump volume we find we add it to the
   volume list. Once the volume list is complete then try to save time by searching the contents seg for that
   volume if it is available. If it is and the object is not found in it then we
   can skip that dump volume. If the contents seg can not be found then the object is assumed to be on the
   dump volume. For each dump volume a search request is entered into the volume control segment.
   If this segemnt does not exist then it is created */

        if ^retv_data_.manual
	| (retv_data_.manual & recursion_level > 1) then do;
	  if bvlp = null then do;
	      call find_volume_log;
	      if bvlp = null then goto no_volog;
	    end;

	  if ^lock then do;
	      call lock_volume_log;
	      if code ^= 0 then goto volog_lock_err;
	    end;

	  lock = "1"b;
	  vlx = 0;
	  if retv_input.to_time = 0 & retv_input.from_time = 0 then do;
	      incr_open_time = 0;
	      cons_open_time = 0;
	      comp_open_time = 0;
	      cons_cycle_uid = "0"b;
	      comp_cycle_uid = "0"b;
	      do idx = backup_volume_log.next to 1 by -1;
	        bvlep = addr (backup_volume_log.array (idx));
	        if bvle.dump_type = incr then do;
		  if cons_open_time ^= 0 | comp_open_time ^= 0 then do;
		      if (cons_open_time ^= 0 & cons_open_time < bvle.close_time)
		        | (comp_open_time ^= 0 & comp_open_time < bvle.close_time)
		      then call update_volume_list;
		    end;
		  else do;
		      call update_volume_list;
		      incr_open_time = get_open_time ();
		    end;
		end;
	        else if bvle.dump_type = cons then do;
		  if comp_open_time ^= 0 then do;
		      if comp_open_time < bvle.close_time
		        | cons_cycle_uid = bvle.cycle_uid then call update_volume_list;
		    end;
		  else do;
		      call update_volume_list;
		      cons_open_time = get_open_time ();
		      cons_cycle_uid = bvle.cycle_uid;
		    end;
		end;
	        else if bvle.dump_type = comp then do;
		  if comp_cycle_uid ^= "0"b then do;
		      if comp_cycle_uid = bvle.cycle_uid then call update_volume_list;
		      comp_open_time = get_open_time ();
		    end;
		  else do;
		      comp_cycle_uid = bvle.cycle_uid;
		      comp_open_time = get_open_time ();
		      call update_volume_list;
		    end;
		end;
	      end;
	    end;
	  else do idx = backup_volume_log.next to 1 by -1;
	      bvlep = addr (backup_volume_log.array (idx));
	      call update_volume_list;
	    end;
	end;
        else do;
	  done = "0"b;
	  do vlx = 1 by 1 while (^done);
	    call get_volname;
	    retv_volume_list (vlx).open_time = 0;
	    if retv_volume_list (vlx).volname = "." then done = "1"b;
	    else retv_volume_list (vlx).use = "1"b;
	  end;
	  retv_volume_list.next = vlx - 2;
	end;
        do rvlx = 1 to retv_volume_list.next;
	if retv_volume_list (rvlx).use then do;
	    volname = retv_volume_list (rvlx).volname;
	    volid = retv_volume_list (rvlx).volid;
	    open_time = retv_volume_list (rvlx).open_time;
	    dump_type = retv_volume_list (rvlx).dump_type;
	    call find_contents_seg;
	    if contentsp = null then do;
	        no_contents_seg = "1"b;
	        if entry_retrieval
		| retv_input.to_time ^= 0
		| retv_input.from_time ^= 0
		| vtoce_derived_volname = volname
		| vtoce_derived_volname = "" then do;
		  call log_uid;
		  if ^(retv_volume_list (rvlx).announced) then do;
		      call retv_report_$online_output (0, myname,
		        "May search volume ^a because contents segment not available", volname);
		      retv_volume_list (rvlx).announced = "1"b;
		    end;
		end;
	      end;
	    else do;
	        call search_contents_seg (contents_idx, found);
	        if found then call log_uid;
	        call term_contents_segs;
	      end;
	  end;
        end;
      end;

/* We come here if an entry must be recovered, either because it does not already exist, or because the request
   is for a link.  If the entry does not exist then we reset dirname and ename to indicate that it is the
   parent directory that is wanted. */

    else do;
        recursion_level = recursion_level + 1;
        if type = LINK then link_retrieval = "1"b;
        parent_check = "1"b;
        entry_name = ename;
        old_dirname = dirname;
        call expand_pathname_ (old_dirname, dirname, ename, code);
        if code ^= 0 then do;
	  call ioa_$rsnnl ("Unable to expand ^a^[>^]^a", message, 0, retv_input.dirname,
	    retv_input.dirname ^= ">", retv_input.ename);
	  code = -1;
	  call retv_notify_ (message, inputp, myname);
	  goto finish;
	end;
        goto status;
      end;
finish:
    if code ^= 0 & code ^= -1 then do;
        call retv_report_$error_output (code, myname, "ERROR");
        code = 0;
      end;
    if ^logged & (code ^= -1) then do;
        call ioa_$rsnnl ("Online records indicate that ^a^[>^]^a^[>^a^;^s^] can not be found for^/retrieval of ^a^[>^]^a",
	message, (0), dirname, dirname ^= ">", ename, entry_name ^= "", entry_name, retv_input.dirname, retv_input.dirname ^= ">", retv_input.ename);
        call retv_notify_ (message, inputp, myname);
        code = -1;
      end;
    if lock then call unlock_volume_log;
    return;
sort: entry (a_rvcp, code);

/* This entry re sorts the entries in the control seg by the contents
   index. This index marks the relative position on the dump medium of each file.
   Thus sorting the entries allows the scan function in retrieve_from_volume_
   to operate a max efficiency.
*/
    rvcp = a_rvcp;
    code = 0;
    do sortx = 1 to retv_vol_control.n_entries;
      do sorty = 1 to retv_vol_control.n_entries;
        if retv_vol_control.array (sorty).in_use then do;
	  if retv_vol_control.array (sorty).contentsx < retv_vol_control.array (sortx).contentsx then do;
	      local_rvce = retv_vol_control.array (sortx);
	      retv_vol_control.array (sortx) = retv_vol_control.array (sorty);
	      retv_vol_control.array (sorty) = local_rvce;
	    end;
	end;
      end;
    end;
    return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


update_volume_list: proc;
dcl (new_entry, use)     bit (1);
dcl (vlx, sortx)	     fixed bin;

/* This proc is called to add a dump volume to the volume list associated with some object.
   It is added to the list if it contains any segments or directories  from this volume and
   it is not already in the list or in the dont use list.
   If the dump volume was created with a different dim then the one that will
   be used to read it the operator is queried as to wheter he wants to use it.
   If not it is added to the don't   use list so the question is asked only once */

    if bvle.dir_num = 0 & bvle.seg_num = 0 then return;

    do sortx = 1 to retv_skip_list.next;
      if bvle.volname = retv_skip_list (sortx).volname then return; /* dont use it */
    end;
    do sortx = 1 to retv_volume_list.next while
      (retv_volume_list (sortx).volname ^= bvle.volname
      & retv_volume_list (sortx).volid ^= bvle.volid);	/* already in list */
    end;
    if sortx > retv_volume_list.next then do;		/* add or update to the list */
        vlx, retv_volume_list.next = retv_volume_list.next + 1;
        new_entry = "1"b;
      end;
    else do;
        new_entry = "0"b;
        vlx = sortx;
      end;
    use = "1"b;
    if retv_input.to_time ^= 0 & bvle.open_time > retv_input.to_time then use = "0"b;
    if bvle.open_time > retv_input.submission_time then use = "0"b;
    if retv_input.from_time ^= 0 & bvle.close_time < retv_input.from_time then use = "0"b;
    retv_volume_list (vlx).volname = bvle.volname;
    retv_volume_list (vlx).volid = bvle.volid;
    retv_volume_list (vlx).use = use | retv_volume_list (vlx).use;
    if new_entry then do;
        retv_volume_list (vlx).open_time = bvle.open_time;
        retv_volume_list (vlx).announced, retv_volume_list (vlx).unused = "0"b;
      end;
    else retv_volume_list (vlx).open_time = min (bvle.open_time, retv_volume_list (vlx).open_time);
    retv_volume_list (vlx).close_time = max (retv_volume_list (vlx).close_time, bvle.close_time);
    retv_volume_list (vlx).dump_type = bvle.dump_type;

    if bvle.io_module ^= retv_data_.io_module then do;
        query_info.version = query_info_version_5;
        call command_query_ (addr (query_info), answer, myname, "^a ^a ^a ^a^/^a",
	"io outer module", bvle.io_module, "which wrote volume", bvle.volname,
	"different than that specified to read volume. Do you wish to use the volume ?");
        if answer = "no" then do;
	  retv_volume_list (vlx).use = "0"b;
	  retv_skip_list.next = retv_skip_list.next + 1;
	  retv_skip_list (retv_skip_list.next).volname = bvle.volname;
	end;
      end;
    return;
  end update_volume_list;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


find_volume_log: proc;

/* This proc is called to located the volume log associated with an object. It does this by converting
   the physical volume id of the object to a physical volume name and searching for it in the
   sub-system directory. If the volume log is found a few validity checks are made also. */

    bvlp = null;
    psearch_name = "";
    call mdc_$find_volname (pvid, psearch_name, lsearch_name, code);
    if code ^= 0 then do;
        call retv_report_$error_output (code, myname, "Unable to convert pvid to pvname");
        return;
      end;
    call suffixed_name_$make (psearch_name, "volog", search_name, code);
    if code ^= 0 then do;
        call retv_report_$error_output (code, myname, "Unable to construct ^a.volog", psearch_name);
        return;
      end;
    on seg_fault_error begin;
        bvlp = null;
        code = error_table_$segfault;
        goto find_volume_log_ret;
      end;
    call hcs_$initiate ((retv_data_.sys_dir), search_name, "", 0, 0, bvlp, code);
    if bvlp ^= null then do;
        code = 0;
        if backup_volume_log.pvname = pvname
	& backup_volume_log.pvid = pvid
	& (backup_volume_log.version = backup_volume_log_version_1) |
	  (backup_volume_log.version = backup_volume_log_version_2) |
	  (backup_volume_log.version = backup_volume_log_version_3) then ;
        else do;
	  bvlp = null;
	  code = error_table_$bad_segment;
	  call retv_report_$error_output (code, myname, "Invalid volog ^a>^a found",
	    retv_data_.sys_dir, search_name);
	end;
      end;
find_volume_log_ret:
    if bvlp = null then call retv_report_$error_output (code, myname, "Unable to locate ^a>^a",
	 retv_data_.sys_dir, search_name);
    return;
  end find_volume_log;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


lock_volume_log: proc;

/* This proc locks the volume log.  It treats invalid lock ids and mylocks as recoverable errors. For all others
   it returns an error code and leaves the volume log unlocked */

    call set_lock_$lock (backup_volume_log.lock, -1, code);
    if code ^= 0 then if code = error_table_$invalid_lock_reset then code = 0;
    if code = error_table_$locked_by_this_process then do;
        call retv_report_$error_output (code, myname, "Volume log ^a", psearch_name);
        code = 0;
        call unlock_volume_log;
        call lock_volume_log;
      end;
    return;
  end lock_volume_log;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


unlock_volume_log: proc;

/* This proc unlocks the volume log. */

    call set_lock_$unlock (backup_volume_log.lock, ignore);
    return;
  end unlock_volume_log;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


create_control_seg: proc;
dcl (nvol_idx, insert_idx) fixed bin;

/* This proc is caled to create a volume control seg for some specified dump volume.
   The volume control seg is created in the process directory and a pointer to
   it is mainted in a static array. The order of pointers in the static array is very important for
   it determines the order in which the dump volumes will be read.  For this reason empty volume control
   segments may be created as place markers so that a time wise order is maintained. Once the volume
   control segment has been located and verified a set of checks is carried out to see if the object
   should be recovered(searched for) from this dump volume. If so an entry is made in the
   control segment and the queue entry is updated to reflect this.
*/

    rvcp = null;
    call suffixed_name_$make (volname, "control", control_name, code);
    if code ^= 0 then do;
        call retv_report_$error_output (code, myname, "Unable to construct ^a.control", volname);
        return;
      end;
    call hcs_$make_seg ("", control_name, "", 01010b, rvcp, code);
    if rvcp = null then do;
bad_seg: call retv_report_$error_output (code, myname,
	"Unable to create control seg ^a", control_name);
        return;
      end;
						/* new control seg */
    if code = 0 then do;
        retv_vol_control.version = retv_vol_control_version_1;
        retv_vol_control.volname = volname;
        retv_vol_control.volid = volid;
        retv_vol_control.open_time = open_time;
        retv_vol_control.dump_type = dump_type;
        do nvol_idx = 1 to retv_data_.nvol
	while (retv_data_.rvcp (nvol_idx) -> retv_vol_control.open_time > open_time);
        end;
        if nvol_idx > retv_data_.nvol then do;		/* no match */
	  if retv_data_.nvol = hbound (retv_data_.rvcp, 1) then do;
	      rvcp = null;
	      call retv_report_$error_output (0, myname, "Limit of ^d control segs exceeded.",
	        hbound (retv_data_.rvcp, 1));
	      code = error_table_$action_not_performed;
	      return;
	    end;
	  retv_data_.nvol = retv_data_.nvol + 1;
	  retv_data_.rvcp (retv_data_.nvol) = rvcp;
	end;
        else do;
	  insert_idx = nvol_idx;
	  do nvol_idx = retv_data_.nvol to insert_idx by -1;
	    retv_data_.rvcp (nvol_idx + 1) = retv_data_.rvcp (nvol_idx);
	  end;
	  retv_data_.rvcp (insert_idx) = rvcp;
	  retv_data_.nvol = retv_data_.nvol + 1;
	end;
      end;

    code = 0;
  end create_control_seg;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


log_uid: proc;


/* This proc is called to insert a retrieval request in a specific control seg */

    call create_control_seg;
    if rvcp = null then goto finish;
    retv_vol_control.n_entries = retv_vol_control.n_entries + 1;
    retv_vol_control.in_use_cnt = retv_vol_control.in_use_cnt + 1;
    rvcep = addr (retv_vol_control.array (retv_vol_control.n_entries));
    rvce.in_use = "1"b;
    rvce.uid = uid;
    rvce.contentsx = contents_idx;
    rvce.vdtd = vdtd;
    rvce.dirname = dirname;
    rvce.ename = ename;
    rvce.entry_name = entry_name;
    rvce.to_time = retv_input.to_time;
    rvce.from_time = retv_input.from_time;
    rvce.queue = retv_data_.queue;
    rvce.retv_ms_id = retv_input.retv_ms_id;
    rvce.entry_retrieval = entry_retrieval;
    rvce.link_retrieval = link_retrieval;
    rvce.no_contents_seg = no_contents_seg;
    rvce.object_retrieval = object_retrieval;
    rvce.vtoce_volname = (vtoce_derived_volname ^= "");
    rvce.previous = retv_input.previous;
    if retv_input.uid = "0"b then do;
        retv_input.entry_name = rvce.entry_name;
        retv_input.entry_retrieval = entry_retrieval;
        retv_input.uid = rvce.uid;
        call update_queue_message;
      end;
    logged = "1"b;
    return;
  end log_uid;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


find_contents_seg: proc;

/* This proc locates the contents segment, if it exists, in the sub-system directory. If found it performs
   a few validity tests to be sure. The contents segment of a dump volume contains an array of uids,
   one for each object that was written on this volume */

    contentsp = null;
    call suffixed_name_$make (volname, "contents", search_name, code);
    if code ^= 0 then do;
        call retv_report_$error_output (code, myname, "Unable to construct ^a.contents", volname);
        return;
      end;
    call hcs_$initiate (rtrim (retv_data_.sys_dir) || ">contents", search_name, "", 0, 0, contentsp, code);
    on seg_fault_error begin;				/* it may not be there */
        contentsp = null;
        code = error_table_$segfault;
        goto find_contents_seg_ret;
      end;
    if contentsp ^= null then do;
        if backup_volume_contents.version ^= backup_volume_contents_version_3
        then call convert_contents_seg;
        if contentsp ^= null then do;
	  if (backup_volume_contents.volname = volname
	    & backup_volume_contents.volid = volid
	    & backup_volume_contents.version = backup_volume_contents_version_3) then return;
	  else do;
	      contentsp = null;
	      code = error_table_$bad_segment;
	      call retv_report_$error_output (code, myname, "Invalid contents seg ^a>contents>^a",
	        retv_data_.sys_dir, search_name);
	    end;
	end;
      end;
find_contents_seg_ret:
    if contentsp = null then
         call retv_report_$error_output (code, myname, "Unable to access ^a>contents>^a",
	 retv_data_.sys_dir, search_name);
    return;
  end find_contents_seg;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


search_contents_seg: proc (contents_idx, found);
dcl (contents_idx, startx, endx) fixed bin;
dcl found		     bit (1);

/* This proc searchs the contents segment for a match. If one is found then
   a code of zero is returned */

    found = "0"b;
    do contents_idx = backup_volume_contents.next to 1 by -1;
      if backup_volume_contents.uid (contents_idx) = uid then do;
	if entry_retrieval & backup_volume_contents.offset (contents_idx) > 0 then do;
	    call find_contents_names_seg;
	    if contents_namesp ^= null then do;
	        nsp = addr (based_char_string);
	        lns = index (based_char_string, ">>") + 1;
	        if index (name_string, rtrim (entry_name)) ^= 0 then do;
		  startx = 1;
		  endx = index (name_string, ">");
		  do while (endx > 0);
		    test_name = substr (name_string, startx, endx - 1);
		    if test_name = entry_name then goto gotit;
		    startx = startx + endx;
		    endx = index (substr (name_string, startx), ">");
		  end;
		  if substr (name_string, startx, lns - startx - 1) = entry_name then goto gotit;
		end;
	      end;
	    call msf_manager_$close (fcbp);
	  end;
	else do;
gotit:	    found = "1"b;
	    return;
	  end;
        end;
    end;
    return;
  end search_contents_seg;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


update_queue_message: proc;

/* This proc updates an existant message in the retrievers privite queue */

retry_update: call message_segment_$update_message_index (retv_data_.qidx (retriever), size (retv_input) * 36,
      retv_input.retv_ms_id, inputp, code);
    if code = error_table_$bad_segment then do;
        call retv_report_$error_output (code, myname, "Private queue has been salvaged");
        goto retry_update;
      end;
    if code ^= 0 then call retv_report_$error_output (code, myname, "Unable to update request in private queue");
  end update_queue_message;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


get_volname: proc;

/* This proc reads a dump volume name and converts it to a  volume id. Volume names are restricted to two or less
   acsii characters preceeding a numeric value(eg ic12345 is ok but qwqw01 is not). */

request: call ioa_$nnl ("Type retrieval volume name: ");	/* Make up request line. */
    call iox_$get_line (iox_$user_input, addr (retv_volume_list (vlx).volname),
      length (retv_volume_list (vlx).volname), nelemt, code);
    if code ^= 0 then do;
        call ioa_ ("input error");
        goto request;
      end;
    retv_volume_list (vlx).volname = substr (retv_volume_list (vlx).volname, 1, nelemt - 1); /* strip new line */
    if retv_volume_list (vlx).volname = "." then return;
    call set_volid_;
    if code ^= 0 then do;
        call ioa_ ("Invalid volume id ^a specified.", retv_volume_list (vlx).volname);
        goto request;
      end;
    return;
  end get_volname;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


set_volid_: proc;

/* This proc constructs a volume id from a volume name. This is a interim measure until all dump volume are registered
   and have a unique id. This construction restricts the volume name to two or less non numeric characters followed
   by any numeric value lest then 262144. */

/* when rcp_ interface is defined
   call rcp_$volname_info (retv_volume_list(vlx).volname, retv_volume_list(vlx).volid, code);
   if code ^= 0 then
   call retv_report_$error_output (code, myname, "Unable to set volid");

   but until then  fudge it */


    start_numeric = search (retv_volume_list (vlx).volname, "0123456789");
    if start_numeric > 3 | start_numeric = 0 then do;
bad_volid: code = error_table_$bad_volid;
        return;
      end;
    else do;
        if start_numeric > 1 then volume_id.char = substr (retv_volume_list (vlx).volname, 1, start_numeric - 1);
        else volume_id.char = "";
        char_num = substr (retv_volume_list (vlx).volname, start_numeric,
	length (retv_volume_list (vlx).volname) - start_numeric);
        num = cv_dec_check_ (char_num, code);
        if code ^= 0 then goto bad_volid;
        volume_id.num = num;
      end;
    retv_volume_list (vlx).volid = unspec (volume_id);
    return;
  end set_volid_;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


get_open_time: proc returns (fixed bin (71));
dcl temp		     fixed bin (71);
dcl jdx		     fixed bin;
    if bvle.dump_type = incr then return (bvle.open_time);
    do jdx = idx to 1 by -1;
      if backup_volume_log.array (jdx).cycle_uid = bvle.cycle_uid then
	 temp = backup_volume_log.array (jdx).open_time;
    end;
    return (temp);

  end get_open_time;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


find_contents_names_seg: proc;

/* This proc locates the contents_names segment, if it exists, in the sub-system directory.
   The contents_names segment of a dump volume contains the name space
   of the dirs dumped on the  dump volume. */

    contents_namesp = null;
    call suffixed_name_$make (volname, "contents_names", search_name, code);
    if code ^= 0 then do;
        call retv_report_$error_output (code, myname, "Unable to construct ^a.contents_name", volname);
        return;
      end;
    on seg_fault_error begin;				/* it may not be there */
        contents_namesp = null;
        goto find_contents_names_seg_ret;
      end;
    call msf_manager_$open (rtrim (retv_data_.sys_dir) || ">contents", search_name, fcbp, code);
    if code ^= 0 then do;
        call retv_report_$error_output (code, myname, "Unable to open ^a>contents>^a",
	retv_data_.sys_dir, search_name);
        return;
      end;
    call msf_manager_$get_ptr (fcbp, (backup_volume_contents.component (contents_idx)), "0"b,
      contents_namesp, 0, code);
    if code ^= 0 then
         call retv_report_$error_output (code, myname, "Unable to get ptr to component ^d of ^a>contents>^a",
	 backup_volume_contents.component (contents_idx), retv_data_.sys_dir, search_name);
find_contents_names_seg_ret:
    return;
  end find_contents_names_seg;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


convert_contents_seg: proc;
dcl contents_idx	     fixed bin;
    call get_temp_segment_ (myname, ncp, code);
    if code ^= 0 then do;
        call retv_report_$online_output (code, myname, "Unable to get temp for contents seg conversion");
        contentsp = null;
        return;
      end;
    ncp -> backup_volume_contents.version = backup_volume_contents_version_3;
    if backup_volume_contents.version = 2 then do;
        ncp -> backup_volume_contents.volname = v2_backup_volume_contents.volname;
        ncp -> backup_volume_contents.volid = v2_backup_volume_contents.volid;
        ncp -> backup_volume_contents.next = v2_backup_volume_contents.next;
      end;
    else if backup_volume_contents.version = 1 then do;
        ncp -> backup_volume_contents.volname = v1_backup_volume_contents.volname;
        ncp -> backup_volume_contents.volid = v1_backup_volume_contents.volid;
        ncp -> backup_volume_contents.next = v1_backup_volume_contents.next;
      end;
    else do;
        call retv_report_$online_output (0, myname, "Unable to convert ^a.contents because of unknown version ^d",
	volname, backup_volume_contents.version);
        contentsp = null;
        call release_temp_segment_ (myname, ncp, ignore);
        return;
      end;
    do contents_idx = 1 to ncp -> backup_volume_contents.next;
      if backup_volume_contents.version = 1 then do;
	ncp -> backup_volume_contents (contents_idx).uid = v1_backup_volume_contents (contents_idx).uid;
	ncp -> backup_volume_contents (contents_idx).component = 0;
	ncp -> backup_volume_contents (contents_idx).offset = 0;
	ncp -> backup_volume_contents (contents_idx).tape_loc = 0;
        end;
      else if backup_volume_contents.version = 2 then do;
	if v2_backup_volume_contents (contents_idx).offset = -1 then do;
	    ncp -> backup_volume_contents (contents_idx).component = 0;
	    ncp -> backup_volume_contents (contents_idx).offset = 0;
	  end;
	else do;
	    ncp -> backup_volume_contents (contents_idx).component =
	      v2_backup_volume_contents (contents_idx).component;
	    ncp -> backup_volume_contents (contents_idx).offset =
	      v2_backup_volume_contents (contents_idx).offset;
	  end;
	ncp -> backup_volume_contents (contents_idx).uid = v2_backup_volume_contents (contents_idx).uid;
        end;
    end;
    call hcs_$fs_move_seg (ncp, contentsp, 1, code);
    if code ^= 0 then do;
        call retv_report_$online_output (code, myname, "Unable to move converted contents seg");
        contentsp = null;
      end;
    call release_temp_segment_ (myname, ncp, ignore);
  end convert_contents_seg;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


term_contents_segs: proc;
dcl segp		     ptr;

/* This proc terminates the contents and contents name segs */

    do segp = contentsp;
      if segp ^= null then
	 call hcs_$terminate_noname (segp, code);
      if code ^= 0 then call retv_report_$error_output (code, myname, "Unable to terminate contents segs");
    end;

  end term_contents_segs;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

%include retv_data_;

%include retv_volume_list;
%include retv_request;

%include queue_msg_hdr;

%include retv_input;

%include retv_vol_control;

%include backup_volume_contents;

%include backup_volume_log;

%include backup_volume_header;
%include backup_pvol_info;

%include fs_vol_label;
%include backup_static_variables;

%include retv_skip_list;
%include query_info;

  end retv_vol_control_;
