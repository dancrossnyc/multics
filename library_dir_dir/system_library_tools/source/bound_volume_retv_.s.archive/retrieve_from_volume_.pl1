/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1991   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(88-08-10,GWMay), approve(88-10-05,MCR8005), audit(88-10-12,Farley),
     install(88-10-17,MR12.2-1173):
     Updated iox_ dcls and calls.
     Changed read mechanism to deal with incomplete data from dump tapes.
  2) change(91-11-12,Schroth), approve(91-12-02,MCR8252),
     audit(92-10-15,Zimmerman), install(92-10-21,MR12.5-1035):
     Correct error in truncating segments containing embedded nulled pages.
                                                   END HISTORY COMMENTS */


/* format: style1,ind2,^inddcls,ifthenstmt,dclind2,declareind2,ifthendo,ifthen*/

retrieve_from_volume_: proc (a_rvcp, code);


/* This proc searches a dump volume specified by the volume control seg for all the objects specified therein.
   If one is found, then the appropriate action, either entry appending, or object copying is attempted. If
   successful the operator, and the requestor if he indicated, are notified.  The dump volume is searched
   until no more useful information can be read. It is then closed but not detached in case the next volume to be read
   should be the same.
*/

/* Modified by D. Vinograd 6/79 to change check for logical header, to correct authorization in notify
   messages, to fix bug in buffer truncation, and xxx.
*/
/* Modified 2/10/82 by GA Texada to delete a recovered branch if the object cannot be recovered (hardcore 347)     */
/* Modified 4/27/82 by GA Texada to change error handling on read errors.     */
/* Modified July 1982 by GA Texada to fix a bug introduced above.		     */
/* Modified: 8/82 by GA Texada to fix phx07704				     */
/* Modified: 84-03-16 by BIM to put in temporary fix to retrieve multi-class segments. 
	   This introduces a security hole that is closed by code in ring zero 
	   that sets SOOS when retv-appending multiclass objects. */
/* Modified: 84-12-27 by Keith Loepere for version 2 create_branch_info. */
/* Modified 03/12/85 by Greg Texada to fix phx19165, don't give up so soon when resynching (D. Kitson)	*/

dcl a_rvcp	     ptr;
dcl aclc		     fixed bin;
dcl aclp		     ptr;
dcl aclrp		     bit (18);
dcl answer	     char (3) var;
dcl att_desc	     char (256);
dcl attributes	     bit (36);
dcl nelt		     fixed bin (21);
dcl code		     fixed bin (35);
dcl crbp		     ptr;
dcl dp		     ptr;
dcl dtd		     bit (36);
dcl dtm		     bit (36);
dcl emode		     bit (36);
dcl ename		     char (32) aligned;
dcl cslx		     fixed bin;
dcl nmx		     fixed bin;
dcl rvlx		     fixed bin;
dcl ignore	     fixed bin (35);
dcl iocbp		     ptr;
dcl long		     char (100) aligned;
dcl message	     char (512) var init ("");
dcl message_len	     fixed bin;
dcl new_contentsp	     ptr;
dcl nlc		     fixed bin;
dcl nlp		     ptr;
dcl nrp		     bit (18);
dcl object_read	     bit (1);
dcl object_size	     fixed bin (19);
dcl objectp	     ptr;
dcl page_bufferp	     ptr;
dcl page_offset	     fixed bin (21);
dcl pmode		     bit (36);
dcl pname		     char (168) aligned;
dcl pnl		     fixed bin;
dcl pvid		     bit (36);
dcl nel		     fixed bin (21);
dcl requests_left	     fixed bin;
dcl resynch_retry_count  fixed bin;
dcl resynching	     bit (1);
dcl resynching_completed bit (1);
dcl short		     char (8) aligned;
dcl temp_dirname	     char (168);
dcl temp_ename	     char (32);
dcl type		     fixed bin;
dcl uid		     bit (36);
dcl volid		     bit (36);
dcl volname	     char (32);
dcl vtoce_volid	     (3) bit (36);
dcl words_skipped	     fixed bin (35);

dcl page		     bit (BITS_PER_PAGE) aligned based;
dcl based_area	     area based (retv_data_.areap);
dcl copy		     (divide (nel, CHARS_PER_WORD, 17, 0)) fixed bin based;
dcl name_list	     (2) char (32) aligned based (nlp);

dcl 1 local_entry	     like entry;
dcl 1 local_retv_append_args like retv_append_args aligned;
dcl 1 local_create_branch_info like create_branch_info aligned;
dcl 1 local_mseg_return_args like mseg_return_args aligned;

dcl 1 acl_list	     (1) based (aclp) aligned,
    2 person	     char (32),
    2 project	     char (32),
    2 tag		     char (1),
    2 mode	     bit (36),
    2 ex_mode	     bit (36);


dcl dates_set	     defined attributes position (1) bit (1);
dcl dump_switches_set    defined attributes position (2) bit (1);
dcl dump_info_set	     defined attributes position (3) bit (1);
dcl pc_switches_set	     defined attributes position (4) bit (1);
dcl quota_info_set	     defined attributes position (5) bit (1);

dcl word		     (size (backup_volume_header)) bit (36) based (recordp);
dcl input_buf	     (divide (nelt, CHARS_PER_WORD, 17, 0)) bit (36) based (recordp);
dcl string	     bit (BITS_PER_WORD * size (backup_volume_header)) based (recordp);
dcl DELIMITED	     bit (1) aligned internal static options (constant)
		     init ("1"b);
dcl FORWARD_CHAR_POSITIONING fixed bin int static init (3) options (constant);
dcl myname	     char (32) int static init ("retrieve_from_volume_") options (constant);
dcl SEG		     fixed bin static init (1) options (constant);
dcl sm		     bit (3) int static init ("110"b) options (constant);
dcl directory	     fixed bin int static init (1) options (constant);

dcl (error_table_$namedup,
  error_table_$data_loss,
  error_table_$force_unassign,
  error_table_$notadir,
  error_table_$resource_unavailable,
  error_table_$noentry,
  error_table_$moderr,
  error_table_$vtoce_connection_fail,
  error_table_$bad_segment,
  error_table_$device_end,
  error_table_$end_of_info,
  error_table_$root)     fixed bin (35) ext static;

dcl retv_notify_	     entry (char (*), ptr, char (*));
dcl command_query_	     entry options (variable);
dcl hc_backup_$delete    entry (char (*), char (*), fixed bin (35));
dcl hc_backup_$set_bc    entry (char (*), char (*), fixed bin (24), fixed bin (24), fixed bin (35));
dcl hc_backup_$get_entry entry (char (*) aligned, char (*) aligned, ptr, fixed bin (35));
dcl hc_backup_$decode_uidpath entry ((16) bit (36) aligned, char (*), char (*), fixed bin (35));
dcl suffixed_name_$make  entry (char (*) aligned, char (*) aligned, char (*) aligned, fixed bin (35));
dcl hc_backup_$retv_status entry (char (*) aligned, char (*) aligned, bit (72) aligned, char (*) aligned,
		     fixed bin, fixed bin, bit (36), bit (36), bit (36), bit (36), (3) bit (36), bit (36), fixed bin (35));
dcl convert_status_code_ entry (fixed bin (35), char (8) aligned, char (100) aligned);
dcl hcs_$truncate_seg    entry (ptr, fixed bin (19), fixed bin (35));
dcl hcs_$make_seg	     entry (char (*) aligned, char (*) aligned, char (*) aligned, fixed bin (5), ptr, fixed bin (35));
dcl ioa_$rsnnl	     entry options (variable);
dcl message_segment_$incremental_read_index entry (fixed bin, ptr, bit (2), bit (72) aligned, ptr, fixed bin (35));
dcl message_segment_$update_message_index entry (fixed bin, fixed bin, bit (72) aligned, ptr, fixed bin (35));
dcl retv_report_$error_output entry options (variable);
dcl retv_report_$online_output entry options (variable);
dcl hc_backup_$retv_check entry (char (*) aligned, char (*) aligned, fixed bin, bit (36), fixed bin (35));
dcl hc_backup_$retv_add_acl entry (char (*) aligned, char (*) aligned, ptr, fixed bin, fixed bin (35));
dcl hc_backup_$retv_addname entry (char (*) aligned, char (*) aligned, char (*) aligned, fixed bin (35));
dcl hc_backup_$retv_hash_search entry (ptr, ptr, ptr, fixed bin (35));
dcl hc_backup_$retv_append entry (char (*) aligned, char (*) aligned, ptr, ptr, fixed bin (35));
dcl hc_backup_$retv_copy entry (char (*) aligned, char (*) aligned, bit (72) aligned, char (*) aligned, fixed bin,
		     ptr, ptr, bit (36), fixed bin (35));
dcl (addcharno, addr, bit, divide, fixed, index, length, min, null, ptr, rtrim, size, substr, unspec) builtin;

    rvcp = a_rvcp;
    code = 0;
    if retv_vol_control.in_use_cnt = 0 then return;	/* nothing to look at */
						/* pick static ptr */
    recordp = retv_data_.recordp;
    nlp = retv_data_.nlp;
    aclp = retv_data_.aclp;
    objectp = retv_data_.objectp;
    page_bufferp = retv_data_.page_buffer_ptr;
						/* initialize local variables */
    ms_arg_ptr = addr (local_mseg_return_args);
    resynching = "0"b;
    resynching_completed = "0"b;
    iocbp = null;
    inputp = null;
						/* initialize mail structure */

/* construct attach description */
    volname = retv_vol_control.volname;
    volid = retv_vol_control.volid;
    if retv_data_.input_volume_desc ^= "" then
      call ioa_$rsnnl (retv_data_.input_volume_desc, att_desc, (0), volname);
    else call ioa_$rsnnl ("tape_mult_ ^a -system", att_desc, (0), volname);

/* Check if volume to be read is same as last volume read. If so then its already mounted and at
   load point. If not then detach old volume and attach new volume. In either case open volume */

    if volname ^= retv_data_.last_volname then do;
        if retv_data_.input_iocbp ^= null then
	call iox_$detach_iocb (retv_data_.input_iocbp, ignore);
        iocbp = null;
retry:  call iox_$attach_name ("input_volume", iocbp, att_desc, null (), code);
        retv_data_.input_iocbp = iocbp;
        if code ^= 0 then do;
	  if code = error_table_$resource_unavailable |
	       code = error_table_$force_unassign then do;
	      if ^retv_vol_control.skip_query then do;
		query_info.version = query_info_version_5;
		call command_query_ (addr (query_info), answer, myname, "^/^a^/^a",
		     "The physical drive or dump volume is not available or is in use by an other process.",
		     "Do you wish to retry the attachment ");
		if answer = "yes" then goto retry;
		else retv_vol_control.skip_query = "1"b;
	        end;
	      else code = -1;			/* special code that we skipped volume */
	    end;
	  call retv_report_$error_output (code, myname, "Unable to attach dump volume ^a via desc ^a",
	       volname, att_desc);
	  goto finish;
	end;
      end;
    else iocbp = retv_data_.input_iocbp;

    call iox_$open (iocbp, Stream_input, "0"b, code);
    if code ^= 0 then do;
        call retv_report_$error_output (code, myname, "Unable to  open dump volume ^a", volname);
        goto finish;
      end;
    retv_data_.last_volname = volname;
    requests_left = retv_vol_control.n_entries;
    if retv_data_.long then do;
        call retv_report_$online_output (0, "", "Reading ^a looking for:", volname);
        do rvlx = 1 to retv_vol_control.n_entries;
	rvcep = addr (retv_vol_control.array (rvlx));
	if rvce.in_use then do;
	    if rvce.entry_retrieval then
	      call retv_report_$online_output (0, "", "Entry retrieval of ^a^[>^]^[^a>^;^s^]^a",
		 rvce.dirname, (rvce.dirname ^= ">"), (rvce.ename ^= ""), rvce.ename, rvce.entry_name);
	    else call retv_report_$online_output (0, "", "Object retrieval of ^a^[>^]^a",
		    rvce.dirname, (rvce.dirname ^= ">"), rvce.ename);
	  end;
        end;
      end;

/* This is the main reading loop. The reading scheme is like that of the reloader. Each read is checked for
   an error and if one occured recovery is attempted. Recovery is made a brute force resynching on the pattern
   contained in the record header.  If a read is ok then then the header pattern is checked. If ok then the rest of the
   header is read and checked for type. If it is contents seg then a check is made to see if
   the segment is online. If not an attempt is made to recover it for latter retrievals. If the version of the
   header does not check then the data in the record is skipped. */
search_loop:
    nel = CHARS_PER_WORD * size (backup_volume_header);
    call read (recordp, nel, nelt, ^DELIMITED, code);
    call check_input_error;

    if backup_volume_record.pattern1 ^= pattern1
         | backup_volume_record.pattern2 ^= pattern2
         | backup_volume_record.pattern3 ^= pattern3 then do;
        code = -1;
        call check_input_error;			/* treat as bad read */
      end;

pattern_match:
    nel = backup_volume_record.rec1_len - size (backup_volume_header) * CHARS_PER_WORD;
    call read (ptr (recordp, size (backup_volume_header)), nel, nelt,
         ^DELIMITED, code);
    call check_input_error;

    if backup_volume_record.rec1_type = contents_type then do;
        call record_contents_segment;
        goto search_loop;
      end;

    if backup_volume_record.rec1_type ^= vtoce_type then do;
        nel = backup_volume_record.rec2_len;
        if nel ^= 0 then call skip_chars;
        goto search_loop;
      end;

    if backup_volume_record.version ^= backup_volume_record_version_1 &
         backup_volume_record.version ^= backup_volume_record_version_2 then do;
        call retv_report_$error_output (0, myname, "Invalid volume record on dump volume ^a", volname);
        nel = backup_volume_record.rec2_len;
        if nel ^= 0 then call skip_chars;
        goto search_loop;
      end;

    if backup_volume_record.uid ^= "0"b then do;
        retv_data_.last_valid_puid = backup_volume_record.uid_path;
        retv_data_.last_valid_vtoce_ename = backup_volume_record.primary_name;
      end;
						/* inform operator of last valid object read */
    if resynching_completed & backup_volume_record.uid ^= "0"b then do;
        resynching_completed = "0"b;
        call retv_report_$error_output (0, myname,
	   "First object after resynching ^a on dump volume ^a", convert_puid_ (), volname);
      end;

    object_read = "0"b;

/* Once an object has been read successfully the volume control segment is scanned for a uid match.  */

    do rvlx = 1 to retv_vol_control.n_entries;
      rvcep = addr (retv_vol_control.array (rvlx));
      if rvce.in_use & rvce.uid = backup_volume_record.uid then do;

/* The two following checks make sure that that we recover either the most recent object or the object specified
   by the requestor.  As dump volumes are read in reverse chronological order once an object is
   recovered it should not be recovered again unless it comes from the same dump volume. The requestor may though
   want an object dumped within
   some specific time bracket.  If the conditions are not met we skip the request and try the next one. */

/* Now read the request associated with this control segment entry */

	call read_incremental_queue_message;
	inputp = mseg_return_args.ms_ptr;

	if (retv_input.object_recovered | retv_input.entry_recovered)
	     & retv_input.volid ^= volid then goto check_next_request;

	if ^rvce.entry_retrieval then do;
	    if (rvce.to_time ^= 0 & fixed (bit (backup_volume_record.time_dumped, 52), 52) > rvce.to_time)
	         | (rvce.from_time ^= 0 & fixed (bit (backup_volume_record.time_dumped, 52), 52) < rvce.from_time)
	         then goto check_next_request;
	  end;

/* The object is read only once even though there may be many request for it. When it was written on the
   dump volume it was written in a compact form with no full zero pages. Thus if csl does not
   equal records the zero pages must be reconstructed according to the file map. */

	if ^object_read then do;
	    object_read = "1"b;
	    nel = backup_volume_record.rec2_len;
	    if fixed (backup_volume_record.csl) = fixed (backup_volume_record.records) then do;
	        call read (objectp, nel, nelt,
		   (backup_volume_record.version > backup_volume_record_version_1), code);
	        call check_input_error;
	      end;
	    else do;
	        call read (page_bufferp, nel, nelt,
		   (backup_volume_record.version > backup_volume_record_version_1), code);
	        call check_input_error;

	        page_offset = 0;
	        do cslx = 0 to fixed (backup_volume_record.csl) - 1;
		if ^substr (backup_volume_record.fm (cslx), 1, 1) then do;
		    ptr (objectp, cslx * WORDS_PER_PAGE) -> page =
		         ptr (page_bufferp, page_offset) -> page;
		    page_offset = page_offset + WORDS_PER_PAGE;
		  end;
		else
		     ptr (objectp, cslx * WORDS_PER_PAGE) -> page = "0"b;
	        end;
	      end;
	  end;


/*  If the request is for entry retrieval then what has been recovered is a parent directory. First we locate
   the entry in the directory by name. Once located we constructed a name and access conrol lists. The we initialize
   some control structures and call a special entry in append which appends a given entry structure. If successful
   we notify the operator and requestor(if requested) and attemp to add the other names and the access
   information. If any failures occurr, the operator and possibly the requestor are notified. If though the request
   is for an object then the input buffer is truncated. Next a check is made to see if the object is already there.
   This may have happend as the result of a previous retrieval. If so we will only overwrite
   it if the dump copy is newer or the requestor has specified a time bracket. In either case the
   operator and possibly the requestor are notified.
*/

	if rvce.entry_retrieval then do;
	    call locate_entry;
	    if ep ^= null then do;
	        call build_name_list;
	        call build_access_list;
	        call init_append_args;
	        call ioa_$rsnnl ("^a^[>^]^a", pname, pnl, rvce.dirname, rvce.dirname ^= ">",
		   rvce.ename);
retry_append:     call hc_backup_$retv_append (pname, name_list (1), crbp, retv_append_argp, code);
	        if code ^= 0 then do;
		  if code = error_table_$namedup then do;
		      call ioa_$rsnnl ("Failed to append branch ^a^[>^]^a "
			 || "because object already there with other name",
			 message, (0), pname, pname ^= ">", name_list (1));
		      call retv_notify_ ((message), inputp, myname);
		      code = -1;
		    end;
		  retv_input.errcode = code;
		end;
	        else do;
		  retv_input.entry_recovered = "1"b;
		  call ioa_$rsnnl ("Appended branch ^a^[>^]^a", message, message_len,
		       pname, pname ^= ">", name_list (1));
		  call retv_notify_ ((message), inputp, myname);
		  call hc_backup_$retv_add_acl (pname, name_list (1), aclp, aclc, code);
		  if code ^= 0 then do;
		      call convert_status_code_ (code, short, long);
		      call ioa_$rsnnl ("Failed to append access list to ^a^[>^]^a because ^a",
			 message, message_len, pname, pname ^= ">", name_list (1), long);
		      call retv_notify_ ((message), inputp, myname);
		    end;
		  do nmx = 2 to nlc;
		    call hc_backup_$retv_addname (pname, name_list (1), name_list (nmx), code);
		    if code ^= 0 then do;
		        call convert_status_code_ (code, short, long);
		        call ioa_$rsnnl ("Failed to add name ^a to ^a^[>^]^a because ^a",
			   message, message_len, name_list (nmx), pname, pname ^= ">",
			   name_list (1), long);
		        call retv_notify_ ((message), inputp, myname);
		      end;
		  end;
		end;
	      end;
	    else goto check_next_request;
	  end;
	else do;
	    object_size = fixed (backup_volume_record.csl, 18, 0) * WORDS_PER_PAGE;
	    call hcs_$truncate_seg (objectp, object_size + 1, ignore); /* object_size + 1 is first word to discard */
	    if retv_input.new_dirname ^= "" then do;	/* cross object retrieval */
	        call hc_backup_$retv_status (retv_input.new_dirname, "",
		   retv_input.access_class, retv_input.requestor, retv_input.level, type,
		   emode, pmode, uid, pvid, vtoce_volid, dtd, code);
	        if code ^= 0 then do;
		  if uid = "0"b then
		    code = error_table_$noentry;
		  else if type ^= directory then
		    code = error_table_$notadir;
		  else if ^((emode & sm) = sm | (pmode & sm) = sm) then
		    code = error_table_$moderr;
		  call convert_status_code_ (code, short, long);
		  call ioa_$rsnnl ("Failed to cross retrieve into ^a  because ^a", message, message_len,
		       retv_input.new_dirname, long);
		  call retv_notify_ ((message), inputp, myname);
		  code = -1;
		  goto set_code;
		end;
	        ep = addr (local_entry);
	        call hc_backup_$get_entry (retv_input.dirname, retv_input.ename, ep, code);
	        if code ^= 0 then do;
		  call convert_status_code_ (code, short, long);
		  call ioa_$rsnnl (
		       "Failed to cross retrieve  ^a^[>^]^a because unable to locate ^a^[>^]^a because ^a",
		       message, message_len, retv_input.new_dirname, retv_input.new_dirname ^= ">",
		       retv_input.new_ename, retv_input.dirname, retv_input.dirname ^= ">",
		       retv_input.ename, long);
		  call retv_notify_ ((message), inputp, myname);
		  code = -1;
		  goto set_code;
		end;
	        backup_volume_record.uid = entry.uid;
	        backup_volume_record.dtd = "0"b;
	        backup_volume_record.volid (*) = "0"b;
	        call init_append_args;
	        retv_append_args.cross_segment = "1"b;
	        call hc_backup_$retv_append (retv_input.new_dirname, retv_input.new_ename, crbp,
		   retv_append_argp, code);
	        if code ^= 0 then do;
		  call convert_status_code_ (code, short, long);
		  call ioa_$rsnnl ("Failed to append cross retrieval branch ^a^[>^]^a  because ^a",
		       message, message_len, retv_input.new_dirname, retv_input.new_dirname ^= ">",
		       retv_input.new_ename, long);
		  call retv_notify_ ((message), inputp, myname);
		  code = -1;
		  goto set_code;
		end;
	        call hc_backup_$retv_copy (retv_input.new_dirname, retv_input.new_ename,
		   retv_input.access_class, retv_input.requestor, retv_input.level,
		   addr (backup_volume_record.vtoce), objectp, attributes, code);
	        if code ^= 0 then do;
		  call convert_status_code_ (code, short, long);
		  call ioa_$rsnnl ("Failed to copy cross retrieval object ^a^[>^]^a  because ^a",
		       message, message_len, retv_input.new_dirname, retv_input.new_dirname ^= ">",
		       retv_input.new_ename, long);
		  call retv_notify_ ((message), inputp, myname);
		  code = -1;
		  goto set_code;
		end;
	      end;
	    else do;				/* object retrieval */
	        call hc_backup_$retv_check (rvce.dirname, rvce.ename, type, dtm, code);
	        if code = error_table_$vtoce_connection_fail
		   | code = 0 & backup_volume_record.dtm >= dtm
		   | code = 0 & (rvce.from_time ^= 0 | rvce.to_time ^= 0)
		   | code = 0 & rvce.previous then do;
		  call hc_backup_$retv_copy (rvce.dirname, rvce.ename, retv_input.access_class,
		       retv_input.requestor, retv_input.level, addr (backup_volume_record.vtoce), objectp,
		       attributes, code);
		end;
	        else if code = 0 then do;
		  call ioa_$rsnnl ("Failed to recover object ^a^[>^]^a because more recent copy online",
		       message, message_len, rvce.dirname, rvce.dirname ^= ">", rvce.ename);
		  call retv_notify_ ((message), inputp, myname);
		  retv_input.errcode = -1;		/* in this case, we don't want to delete the recovered*/
		  goto update_message;		/* branch, or we would leave a connection failure.*/
		end;
	      end;
set_code:	    if code ^= 0 then do;
	        retv_input.errcode = code;
	        if retv_input.entry_recovered then do;
		  if retv_append_args.cross_segment then
		    call hc_backup_$delete ((retv_input.new_dirname),
		         (retv_input.new_ename), code);
		  else call hc_backup_$delete ((rvce.dirname), (rvce.ename), code);
		end;
	        goto update_message;
	      end;
	    else do;
	        if retv_input.new_dirname ^= "" then temp_dirname = retv_input.new_dirname;
	        else temp_dirname = rvce.dirname;
	        if retv_input.new_ename ^= "" then temp_ename = retv_input.new_ename;
	        else temp_ename = rvce.ename;
	        call ioa_$rsnnl ("Recovered ^[segment^;directory^] ^a^[>^]^a", message, message_len,
		   type = SEG, temp_dirname, temp_dirname ^= ">", temp_ename);
	        if ^backup_volume_record.dirsw then
		call set_bc (temp_dirname, temp_ename);
	        call retv_notify_ ((message), inputp, myname);
	        if attributes then do;
		  call ioa_$rsnnl
		       ("Failed to set ^[dates ^]^[dump_switches ^]^[dump_info ^]^[pc_switches ^]"
		       || "^[quota_info^] for ^a^[>^]^a",
		       message, message_len, dates_set, dump_switches_set, dump_info_set, pc_switches_set,
		       quota_info_set, temp_dirname, temp_dirname ^= ">", temp_ename);
		  call retv_notify_ ((message), inputp, myname);
		end;
	        retv_input.object_recovered = "1"b;
	        retv_input.errcode = 0;
	      end;
	  end;
update_message:
	retv_input.volid = volid;
	call update_queue_message;
	if retv_vol_control.dump_type ^= incr then requests_left = requests_left - 1;
	if requests_left = 0 then do;
	    call close;
	    goto finish;
	  end;
        end;
check_next_request:
    end;
    if ^object_read then do;
        nel = backup_volume_record.rec2_len;
        if nel ^= 0 then do;
/**** skip object, but use read procedure to skip the full object and check for
      object delimiters (if applicable). */
	  call read (objectp, nel, nelt,
	       (backup_volume_record.version > backup_volume_record_version_1), code);
	  call check_input_error;
	end;
      end;
    goto search_loop;
finish:
    if inputp ^= null then free retv_input in (based_area);
    return;

skip_chars: proc;

/* This proc skips foward the number of chars specified in the variable nel.
*/

    nelt = nel;
    call read (null (), nel, nelt, ^DELIMITED, code);
    call check_input_error;
  end skip_chars;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


check_input_error: proc;

/* This proc checks for errors after a read of the dump volume. It we have reached the end of the volume then a non
   local return is made and the main routine returns to its caller. Otherwise if an error has
   occurred we attempted to recover. If we are already recovering we terminate the retrieval. Of course
   in the errorless case we just return */

    if code ^= 0 | nelt ^= nel then do;
        if (code = error_table_$end_of_info | code = error_table_$device_end) then do;
	  if resynching then do;
	      call retv_report_$error_output (0, myname, "Resynchronization terminated by end of volume ^a",
		 volname);
	      call retv_report_$error_output (0, myname, "Skipped ^d words on dump volume ^a",
		 words_skipped, volname);
	    end;
	  call close;
	  goto finish;
	end;
        else do;
	  if ^resynching then do;
	      if nel ^= nelt then
	        call retv_report_$error_output (0, myname, "Read did not complete on dump volume ^a", volname);
	      if code = -1 then
	        call retv_report_$error_output (0, myname, "Invalid dump record header on ^a", volname);
	      else call retv_report_$error_output (code, myname, "I/O error reading dump volume ^a",
		      volname);
	      call retv_report_$error_output (0, myname,
		 "Invalid input record on dump volume ^a after ^a  - resynching started",
		 volname, convert_puid_ ());
	      resynch_retry_count = 0;
	      call resynch_input_volume;
	    end;
	  else do;				/* already had an error			*/
	      resynch_retry_count = resynch_retry_count + 1;
						/* keep track so we don't try this forever	*/
	      if resynch_retry_count > 64 then do;
		call retv_report_$error_output (code, myname,
		     "Resynchronization failed due to I/O error during resynching on volume ^a", volname);
		call close;
		goto finish;
	        end;
	    end;
	end;
      end;
  end check_input_error;

close: proc;

/* This proc closes the open switch. It does not detach it, as the next dump volume to be read
   may be the same volume just read. */

    call iox_$close (iocbp, code);
    if code ^= 0 then
      call retv_report_$error_output (code, myname, "Unable to close input volume ^a", volname);
  end close;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


resynch_input_volume: proc;

/* This proc  resynchronizes a dump volume by stepping through the input one word at a time until it
   recognizes the volume header unique pattern or until we get to the end of the volume. An upper
   bound of one million words is placed on the loop so it will finish */

    resynching = "1"b;
    input_buf (*) = "0"b;
    nel = CHARS_PER_WORD * size (backup_volume_header);
    call read (recordp, nel, nelt, ^DELIMITED, code);
    call check_input_error;

    words_skipped = 0;
test: if word (1) = pattern1 & word (4) = pattern2 & word (7) = pattern3 then do;
        call retv_report_$error_output (0, myname,
	   "Synchronization completed ^d words skipped on dump volume ^a",
	   words_skipped, volname);
        resynching = "0"b;
        resynching_completed = "1"b;
        goto pattern_match;
      end;

    string = substr (string, 37, (size (backup_volume_header) - 1) * BITS_PER_WORD);
    nel = CHARS_PER_WORD;
    call read (addr (word (size (backup_volume_header))), nel, nelt,
         ^DELIMITED, code);
    call check_input_error;

    words_skipped = words_skipped + 1;
    if words_skipped > 256 * WORDS_PER_PAGE then do;	/* put a limit on it */
        call retv_report_$error_output (0, myname, "Resynchronization failed on dump volume ^a", volname);
        code = error_table_$end_of_info;
        call check_input_error;
      end;
    goto test;
  end resynch_input_volume;

locate_entry: proc;

/* This proc locates an entry in a temp copy of a directory by using an interface to the
   ring 0 hash routine. It returns a non null entry pointer if the entry was found */

    ep = null;
    dp = objectp;
    np = addr (rvce.entry_name);
    call hc_backup_$retv_hash_search (dp, np, ep, code);
    if code ^= 0 then ep = null;
    if ep = null then return;
    if rvce.link_retrieval then if entry.bs then ep = null;
  end locate_entry;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


build_name_list: proc;

/* This proc constructs an array of names associated with some entry. */

    nlc = 0;
    do nrp = entry.name_frp repeat (np -> names.fp) while (nrp ^= "0"b);
      np = ptr (ep, nrp);
      nlc = nlc + 1;
      name_list (nlc) = np -> names.name;
    end;
    return;
  end build_name_list;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


build_access_list: proc;

/* This proc constructs an array of access control items associated with some entry */

    aclc = 0;
    if ^entry.bs then return;
    do aclrp = entry.acl_frp repeat (acl_entry.frp) while (aclrp ^= "0"b);
      aclep = ptr (ep, aclrp);
      aclc = aclc + 1;
      if acl_entry.pers_rp = "0"b then acl_list (aclc).person = "*";
      else acl_list (aclc).person = ptr (ep, acl_entry.pers_rp) -> access_name.name;
      if acl_entry.proj_rp = "0"b then acl_list (aclc).project = "*";
      else acl_list (aclc).project = ptr (ep, acl_entry.proj_rp) -> access_name.name;
      acl_list (aclc).tag = acl_entry.tag;
      acl_list (aclc).mode = acl_entry.mode;
      acl_list (aclc).ex_mode = acl_entry.ex_mode;
    end;
    return;
  end build_access_list;

record_contents_segment: proc;

/* This proc recovers a contents segment from the dump volume if it is not already online. */

    contentsp = recordp;
    call suffixed_name_$make (backup_volume_contents.volname, "contents", ename, code);
    if code ^= 0 then do;
        call retv_report_$error_output (code, myname, "Unable to construct ^a.contents",
	   backup_volume_contents.volname);
        return;
      end;
    call hcs_$make_seg (rtrim (retv_data_.sys_dir) || ">contents",
         ename, "", 01010b, new_contentsp, code);
    if code = 0 then new_contentsp -> copy = contentsp -> copy;
  end record_contents_segment;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

update_queue_message: proc;

/* This proc updates an existant message in the retrieve's private queue */

retry_update: call message_segment_$update_message_index (retv_data_.qidx (retriever),
         size (retv_input) * BITS_PER_WORD, rvce.retv_ms_id, inputp, code);
    if code ^= 0 then do;
        if code = error_table_$bad_segment then do;
	  call retv_report_$error_output (0, myname, "Private queue has been salvaged");
	  goto retry_update;
	end;
        else do;
	  call retv_report_$error_output (code, myname, "Update of private queue failed");
	  goto finish;
	end;
      end;
  end update_queue_message;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

read_incremental_queue_message: proc;

/* This proc reads a specified message from the retrievers private queue. It takes care to manage the allocated
   storage so it is not slowly eaten away */

    if inputp ^= null then free retv_input in (based_area);
reread: call message_segment_$incremental_read_index (retv_data_.qidx (retriever), retv_data_.areap,
         "00"b, rvce.retv_ms_id, ms_arg_ptr, code);
    if code ^= 0 then do;
        if code = error_table_$bad_segment then do;
	  call retv_report_$error_output (0, myname, "Private queue has been salvaged");
	  goto reread;
	end;
        else do;
	  call retv_report_$error_output (code, myname, "Read of private queue failed");
	  goto finish;
	end;
      end;
  end read_incremental_queue_message;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


init_append_args: proc;

/* This proc setups the control structures for the special entry appending call */

    crbp = addr (local_create_branch_info);
    crbp -> create_branch_info.version = create_branch_version_2;
    if entry.bs then crbp -> create_branch_info.dir_sw = entry.dirsw;
    else crbp -> create_branch_info.dir_sw = "0"b;
    if entry.bs then crbp -> create_branch_info.copy_sw = entry.copysw;
    else crbp -> create_branch_info.copy_sw = "0"b;
    crbp -> create_branch_info.chase_sw = "0"b;
    crbp -> create_branch_info.parent_ac_sw = "0"b;
    crbp -> create_branch_info.priv_upgrade_sw = "1"b;
    crbp -> create_branch_info.mode = "0"b;
    if entry.bs then crbp -> create_branch_info.rings (*) = fixed (entry.ring_brackets (*), 3);
    else crbp -> create_branch_info.rings (*) = 0;
    crbp -> create_branch_info.userid = retv_input.requestor;
    if entry.bs then crbp -> create_branch_info.bitcnt = entry.bc;
    else crbp -> create_branch_info.bitcnt = 0;
    crbp -> create_branch_info.quota = 0;
    crbp -> create_branch_info.dir_quota = 0;
    if entry.bs then crbp -> create_branch_info.access_class = entry.access_class;
    else crbp -> create_branch_info.access_class = "0"b;
    unspec (local_retv_append_args) = "0"b;
    retv_append_argp = addr (local_retv_append_args);
    retv_append_args.version = RETV_APPEND_ARGS_VERSION_1;
    retv_append_args.level = retv_input.level;
    retv_append_args.access_authorization = retv_input.access_class; /* user auth at time of err */
    retv_append_args.max_access_authorization = crbp -> create_branch_info.access_class; /* This is a LIE. We have no idea what the user's max */
						/* authorization is. This is high enough to make the append succeed, and then */
						/* append in ring zero will set it SOOS until an administrator wanders by. */
    retv_append_args.ep = ep;
    retv_append_args.link = ^entry.bs;
    return;

  end init_append_args;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


convert_puid_: proc returns (char (168) var);

/* This proc is used to convert a unique id pathname to an ascii pathname  */

dcl dn		     char (168);
dcl en		     char (32);
dcl ret_dn	     char (168);
    call hc_backup_$decode_uidpath (retv_data_.last_valid_puid, dn, en, code);
    if code = error_table_$root then ;
    else if code ^= 0 then return ("UNKNOWN_PATH>" || rtrim (retv_data_.last_valid_vtoce_ename));
    call ioa_$rsnnl ("^a^[>^]^[^a>^;^s^]^a", ret_dn, (0), dn, dn ^= ">", en ^= "", en, retv_data_.last_valid_vtoce_ename);
    return (ret_dn);
  end convert_puid_;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
read: proc (return_buffer_ptr,
       Nrequested_chars,
       Nreturned_chars,
       Sdelimited,
       code);

dcl return_buffer_ptr    ptr,
  Nrequested_chars	     fixed bin (21),
  Nreturned_chars	     fixed bin (21),
  Sdelimited	     bit (1) aligned,
  code		     fixed bin (35);

dcl input_buffer	     char (256 * CHARS_PER_PAGE)
		     based (retv_data_.input_buffer_ptr);

dcl return_string	     char (Nrequested_chars)
		     based (return_buffer_ptr);

dcl Nassign_chars	     fixed bin (21),
  Nread_chars	     fixed bin (21),
  end_of_record	     fixed bin,
  tape_check1 /* bit (72) */ char (8),
  tape_check2 /* bit (72) */ char (8);

    Nreturned_chars, Nread_chars, code = 0;

    do while (Nreturned_chars < Nrequested_chars & code = 0);
      if retv_data_.input_buffer_len = 0 then do;
	retv_data_.input_buffer_start = 1;

	if Sdelimited & Nreturned_chars = 0 then do;
	    call iox_$get_chars (retv_data_.input_iocbp,
	         addr (tape_check1), length (tape_check1), Nread_chars, code);
	    if code ^= 0 then return;
	  end;

	if return_buffer_ptr = null then do;
	    call iox_$position (retv_data_.input_iocbp, FORWARD_CHAR_POSITIONING,
	         Nrequested_chars - Nreturned_chars, code);
	    Nreturned_chars = Nreturned_chars + Nrequested_chars;
	  end;
	else do;
	    call iox_$get_chars (retv_data_.input_iocbp,
	         addcharno (return_buffer_ptr, Nreturned_chars),
	         Nrequested_chars - Nreturned_chars, Nread_chars, code);
	    Nreturned_chars = Nreturned_chars + Nread_chars;
	  end;
	if code ^= 0 then return;

	if Sdelimited then do;
	    call iox_$get_chars (retv_data_.input_iocbp,
	         addr (tape_check2), length (tape_check2), Nread_chars, code);
	    if code ^= 0 then
	      return;

	    if tape_check1 ^= tape_check2 then do;
						/* found a short segment, move       */
						/* return string into the temp input */
						/* buffer and start parsing          */
	        retv_data_.input_buffer_len = Nreturned_chars;
	        substr (input_buffer, 1, retv_data_.input_buffer_len) =
		   return_string;
	      end;
	  end;
        end;

      else
	 if Sdelimited then do;
	tape_check1 = substr (input_buffer,
	     retv_data_.input_buffer_start, length (tape_check1));
	tape_check2 = "";
	retv_data_.input_buffer_start =
	     retv_data_.input_buffer_start + length (tape_check1);
	retv_data_.input_buffer_len =
	     retv_data_.input_buffer_len - length (tape_check1);
        end;

      if retv_data_.input_buffer_len > 0 then do;
	Nassign_chars =
	     min (retv_data_.input_buffer_len, Nrequested_chars);

	if Sdelimited then do;
	    if tape_check1 ^= tape_check2 then do;
	        end_of_record = index (substr (input_buffer, retv_data_.input_buffer_start,
		   retv_data_.input_buffer_len), tape_check1);
	        if end_of_record > 0 then do;
		  Nassign_chars = end_of_record - 1;
		  if Nrequested_chars ^= Nassign_chars then
		    code = error_table_$data_loss;
		end;
	      end;
	  end;

	if return_buffer_ptr ^= null then
	  return_string = substr (input_buffer,
	       retv_data_.input_buffer_start, Nassign_chars);
	Nreturned_chars = Nassign_chars;

	retv_data_.input_buffer_start =
	     retv_data_.input_buffer_start + Nassign_chars;
	retv_data_.input_buffer_len =
	     retv_data_.input_buffer_len - Nassign_chars;

	if Sdelimited & retv_data_.input_buffer_len > 0 then do;
	    retv_data_.input_buffer_start =
	         retv_data_.input_buffer_start + length (tape_check2);
	    substr (input_buffer, 1, retv_data_.input_buffer_len) =
	         substr (input_buffer, retv_data_.input_buffer_start,
	         retv_data_.input_buffer_len - length (tape_check2))
	         || tape_check2;
	    retv_data_.input_buffer_start = 1;
	  end;
        end;
    end;

    return;
  end read;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


set_bc: proc (dirname, ename);
dcl old_bc	     fixed bin (24);
dcl (dirname, ename)     char (*);
dcl new_bc	     fixed bin (24);

/* This proc sets the bit count of the recovered object */

    new_bc = 9 * backup_volume_record.rec2_len;
    if fixed (backup_volume_record.csl, 9) ^= fixed (backup_volume_record.records, 9) then
      new_bc = new_bc + WORDS_PER_PAGE * BITS_PER_WORD * (fixed (backup_volume_record.csl, 9)
	 - fixed (backup_volume_record.records, 9));
    call hc_backup_$set_bc (dirname, ename, new_bc, old_bc, code);
    if code ^= 0 then do;
        call convert_status_code_ (code, short, long);
        call ioa_$rsnnl ("^a^/Bit count could not be set for ^a>^a because ^a",
	   message, 0, message, rvce.dirname, rvce.ename, long);
        return;
      end;
    if new_bc ^= old_bc then do;
        call ioa_$rsnnl ("^a^/Bit count of ^a>^a reset to ^d from ^d", message, 0,
	   message, dirname, ename, new_bc, old_bc);
      end;

  end set_bc;

%include retv_data_;
%include retv_request;
%include queue_msg_hdr;
%include retv_input;
%include mseg_return_args;
%include backup_static_variables;
%include backup_volume_contents;
%include backup_volume_record;
%include backup_volume_header;
%include backup_pvol_info;
%include fs_vol_label;
%include vtoce;
%include dir_entry;
%include dir_name;
%include dir_acl;
%include retv_vol_control;
%include retv_append_args;
%include create_branch_info;
%include iox_dcls;
%include iox_modes;
%include query_info;
%include system_constants;

  end retrieve_from_volume_;
