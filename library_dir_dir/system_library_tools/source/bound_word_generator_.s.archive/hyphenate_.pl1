/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   *********************************************************** */
/* This procedure tries to hyphenate a word supplied by the caller.

   dcl hyphenate_ entry(char(*), (*) bit(1) aligned, fixed bin);

   call hyphenate_ (word, returned_hyphens, code);

   1) word      A word consisting of ASCII letters to be hyphenated.
   The first character may be uppercase or lowercase; the other
   characters may be lowercase only.

   3) returned_hyphens
   A one bit in this array means that the corresponding
   character in word is to have a hyphen after it.

   3) code      Status code: 0  word has been successfully hyphenated.
   -1 word contains illegal characters.
   -2 word was more than 20 or less than 3 characters.
   Any positive value of code means the word couldn't
   be hyphenated.  In this case code is the position of the
   first character that was not accepted.

   The word is hyphenated by using random_word_ and whatever existing digram
   table is in use by random_word_ to determine the syllabification and pronounceability
   of the word supplied.  The standard random_unit_ routine is not used,
   except that random_unit_$probabilities is called by hyphenate_$probability.
*/

hyphenate_: procedure (word, returned_hyphens, code);
dcl  word char (*);
dcl  code fixed bin;
dcl  debug static bit (1) init ("0"b);
dcl  ioa_$nnl entry options (variable);
dcl  word_array (20) fixed bin static;			/* word spread out into units */
dcl  hyphenated_word (0:20) bit (1) aligned;		/* returned hyphens from random_word_ */
dcl  returned_hyphens (*) bit (1) aligned;		/* hyphens to be returned to caller */
dcl  split_point fixed bin;				/* set on internal call at 2-letter unit to be split */
dcl  word_length_in_chars fixed bin static;		/* length of word in characters */
dcl  word_length fixed bin static;			/* length of word_array in units */
dcl  i fixed bin;
dcl  j fixed bin;
dcl  chars char (2);
dcl  char char (1);
dcl  word_index fixed bin static;			/* index into word_array */
dcl  returned_word (0:20) fixed bin;			/* word returned by random_word_ */
dcl  vowel_flag bit (1);				/* 1 when random_vowel is called */
dcl  last_good_unit static fixed bin;			/* word_index of last good unit */
dcl  new_unit fixed bin;
dcl  random_word_ entry ((0:*)fixed bin, (0:*) bit (1) aligned,
     fixed bin, fixed bin, entry, entry);
dcl  random_unit_$probabilities entry ((*) float bin, (*) float bin);
dcl  probability float bin;				/* value of p returned to user */
dcl  calculate bit (1) static;			/* says we're calculating the probability of a word */
dcl  p float bin static;				/* accumulated product of probability for the word */
dcl  total_p_this_unit float bin;			/* total sum of probabilities of units that could be accepted in this position */
dcl  returned_length fixed bin;

/* probabilities of generating each unit at random */
/* obtained from a call to random_unit_$probabilities */

dcl (unit_probabilities based (u_p_ptr), vowel_probabilities based (v_p_ptr)) dim (n_units) float bin;
dcl (u_p_ptr, v_p_ptr) static ptr init (null ());
dcl  first_call static bit (1) init ("1"b);
%include digram_structure;
	split_point = 0;
	calculate = "0"b;				/* we aren't calculating probabilities, just hyphenating */
	goto continue;
						/*  */
						/* This entry is the same as hyphenate_, except that an additional value returned
						   is the probability that the word would have been generated by random_word_
						   using the current digram table and random_unit_ subroutine.  On the first call
						   to this entry, random_unit_$probabilities is called to obtain the probabilities
						   of all units.  If these change within a process, hyphenate_$reset must be called
						   before hyphenate_$probability is called again.
						*/

hyphenate_$probability: entry (word, returned_hyphens, code, probability);
	split_point = 0;
	p = 1;
	calculate = "1"b;
	if first_call then do;
	     allocate unit_probabilities, vowel_probabilities;
	     call random_unit_$probabilities (unit_probabilities, vowel_probabilities);
	     first_call = "0"b;
	end;
	goto continue;

/* This entry is used to reset the probability arrays in case a new
   version of random_unit_ (with different probabilities) is used.
   Note that if a new version of digrams is also supplied, the old
   digrams must be terminated. */

hyphenate_$reset: entry; first_call = "1"b;
	if v_p_ptr ^= null () then free unit_probabilities, vowel_probabilities;
	return;

/* This entry point is called internally as a recursive call to hyphenate_.
   It is referenced when random_word_ did not accept the word because a 2-letter unit
   was illegal.  In this case we call this entry and tell hyphenate_ to split the 2-letter
   unit into 2 separate units.  The splitpoint argument specifies which one to do this with. */

hyphenate_$split: entry (word, returned_hyphens, code, splitpoint);
dcl  splitpoint fixed bin;
	split_point = splitpoint;

continue:
	word_length_in_chars = length (word);
	if word_length_in_chars > 20 | word_length_in_chars < 3
	then
	     do;
	     code = -2;
	     if calculate then probability = 0;
	     return;
	end;

/* Now that we have the word we want to hyphenate, we try to divide it up ino units as defined
   in the digram table.  We start with the first two letters in the word, and see if they are equal to any
   of the 2-letter units.  If they are, we store the index of that unit in the word_array, and increment
   our word_index by 2.  If they are not, we see if the first letter is equal to any of the 1-letter units.
   If it is, we store that unit and increment the word_index by 1.  If still not found, the character is
   not defined as a unit in the digram table and the word is illegal.  Of course, the word may still not be
   "legal" according to random_word_ rules of pronunciation and the digram table, but we'll find that out
   later.
*/

	word_index = 1;
	do i = 1 to word_length_in_chars;
	     chars = substr (word, i, min (2, word_length_in_chars - i + 1));
	     if i = 1 then substr (chars, 1, 1) = translate (substr (chars, 1, 1), "abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
	     j = 1;
	     do j = 1 to n_units while (chars ^= letters (j)); /* look for 2-letter unit match */
	     end;
	     if j <= n_units & word_index ^= split_point
	     then					/* match found */
		do;
		word_array (word_index) = j;		/* store 2-letter unit index */
		word_index = word_index + 1;
		i = i + 1;			/* skip over next unit */
	     end;
	     else
	     do;					/* two-letter unit not found, search for 1-letter unit */
		char = substr (chars, 1, 1);
		if i = 1
		then char = translate (char, "abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
		char = substr (char, 1, 1);
		j = 1;
		do j = 1 to n_units while (char ^= letters (j));
		end;
		if j <= n_units
		then				/* match found */
		     do;
		     word_array (word_index) = j;	/* store 1-letter unit index */
		     word_index = word_index + 1;
		end;
		else
		do;				/* not found, unit is illegal */
		     code = -1;
		     if calculate then probability = 0;
		     return;
		end;
	     end;
	end;
	word_length = word_index - 1;
	word_index = 0;

/* Now call random_word_, trying to get the word hyphenated.  Special versions of random_unit and
   random_vowel are supplied that return units of the word we are trying to hyphenate rather than
   random units.
*/

	call random_word_ (returned_word, hyphenated_word, word_length_in_chars, returned_length, random_unit, random_vowel);
	goto accepted;

/* If random_unit ever finds that random_word_ did not accept a unit from the word to be hyphenated,
   a nonlocal goto directly to this label (which pops random_word_ off the stack) is made, and we
   abort the whole operation.  If the last unit tried (i.e. the one not accepted) was a 2-letter unit,
   we might be able to make the word legal by splitting that unit up into two 1-letter units and
   starting all over.  Unfortunately, this is a lot of code and complication for a relatively rare case.
*/

not_accepted: word_index = word_index - 1;		/* index of last unit accepted */
	p = 0;					/* zero probability if word was not accepted */

accepted:	if debug then if calculate then call ioa_$nnl ("^/");
	j = 1;
	returned_hyphens = "0"b;
	do i = 1 to word_length;
	     if i > word_index & word_index < word_length /* we never got done with the word */
	     then
		do;
		code = j;				/* word was not accepted */
		if letters_split (word_array (i)).second ^= " " /* was it not accepted because of an illegal */
		& split_point = 0
		then do;				/* 2-letter unit? */
		     p = 1;
		     call hyphenate_$split (word, returned_hyphens, code, i); /* try again with split pair */
		end;				/* Note: in even rarer cases, the unit that might be split to make this word legal is not the
						   unit that was rejected, but a previous unit.  It's too hard to deal with this case, so we'll refuse the word,
						   even though it might be legal.  As an example, using the standard digram table, "preeg-hu-o" is a legal word.
						   However, our first attempt was to supply p-r-e-e-gh-u-o units.  Random_word_ rejects the
						   "u" because it may not follow a "gh" unit in this context.  Since "u" is not a 2-letter
						   unit, we can't try to split it up, so the word is thrown out.  However, p-r-e-e-g-h-u-o
						   would have been acceptable to random_word_.  This is the only case where a
						   word that could have been produced by random_word_ will be rejected by hyphenate_. */
		if calculate then probability = p;
		return;				/* otherwise, return */
	     end;

/* set returned_hyphens bits corresponding to character in word.  Note that
   hyphens returned from random_word_ (hyphenated_word array) point to units,
   not characters. */

	     if letters_split (word_array (i)).second ^= " "
	     then j = j + 2;
	     else j = j + 1;
	     returned_hyphens (j-1) = hyphenated_word (i);
	end;
	code = 0;
	if calculate then probability = p;
	return;
						/*  */
						/* The internal procedures random_unit and random_vowel keep track of the acceptance or rejectance of
						   units they are supplying to random_word_.  Most of the code in the first part is to calculate probabilities
						   when hyphenate_$probability is called.
						*/
random_vowel: proc (returned_unit);
dcl  returned_unit fixed bin;
	     vowel_flag = "1"b;
	     goto generate;

random_unit:   entry (returned_unit);
	     vowel_flag = "0"b;

generate:

/* at this point, we either calculate probabilities or just go for another unit */

/* If probabilities are being calculated, we proceed as follows:
   In every position of the word, we send off to random_word_ all possible units except the one
   that is actually in the word.  We send these as negative numbers so that random_word_ will not actually use
   them, but will tell us whether they are legal.  Since we know the probabiliies of all units, the
   total of the probabilities of the acceptable units can be calculated and normalized to 1 in order
   to determine the probability of the unit we are actually trying.  For example, if "e" is the only legal
   unit in a given position of the word, then its probability of appearing in that position is 1, since
   random_word_ will not accept anything else.

   When all units but the actual unit have been tried, we send off the actual unit with a positive sign.
   It should be accepted by random_word_ if the word is legal, and the ratio of its probability
   to the total probability of the legal units is the probability of the unit being in this word position.
   This multiplied by the product of these probabilities of the previous units gives us a "running product"
   that will eventually yield the probability of the whole word.
*/

	     if calculate then do;			/* we are calculating */
		if debug then
		     if returned_unit < 0 then
			if returned_unit ^= -new_unit then
			     call ioa_$nnl ("^a,", letters (-returned_unit));
		if returned_unit = 0 & word_index = 0 then do; /* this is the first unit of the word */
		     total_p_this_unit = 0;		/* initialize probabilities */
		     word_index = 1;
		end;
		else if returned_unit = 0 & word_index ^= 0 then goto not_accepted; /* it tried to start a word all over on us */
		new_unit = word_array (word_index);	/* get the current unit from the word */
		if returned_unit > 0 then do;		/* was the last unit accepted */
		     if returned_unit = new_unit then do; /* yes, was it the one from this word position? */
			total_p_this_unit = 0;	/* initialize for next word position */
			word_index = word_index + 1;
			new_unit = word_array (word_index); /* get next unit from word, which now becomes current unit */
			returned_unit = 0;
		     end;
		     else do;			/* unit just accepted was not the one at this word position */
			if vowel_flag		/* add its probability to total for this position and keep trying more units */
			then total_p_this_unit = total_p_this_unit + vowel_probabilities (returned_unit);
			else total_p_this_unit = total_p_this_unit + unit_probabilities (returned_unit);
		     end;
		end;
		if -returned_unit = new_unit then goto not_accepted; /* current unit was not accepted */
skip_unit:
		returned_unit = abs (returned_unit) + 1; /* try next unit in unit table */
		if returned_unit = new_unit then returned_unit = returned_unit + 1; /* but skip the current one */
		if returned_unit > n_units
		then do;				/* we've tried all the other units, try the current one now */
						/* If we are trying the current unit for real, we can calculate the probability of
						   of this unit appearing at this position, assuming it will be accepted.
						   Ratio of probability of this unit to total
						   probability for the units accepted at this position gives the probability of this unit
						   having legally been generated at this position */
		     if vowel_flag
		     then p = p * vowel_probabilities (new_unit)/ (vowel_probabilities (new_unit) + total_p_this_unit);
		     else p = p * unit_probabilities (new_unit)/ (unit_probabilities (new_unit) + total_p_this_unit);
		     returned_unit = new_unit;
		end;
		else returned_unit = -returned_unit;	/* if not the current one, make it negative so it won't be used */
		if vowel_flag			/* if vowel was wanted and this isn't one, it can't be used */
		then if ^rules.vowel (abs (returned_unit))
		     then if ^rules.alternate_vowel (abs (returned_unit))
			then
			     if returned_unit < 0	/* if we didn't care to keep it anyway, just ignore */
			     then goto skip_unit;
			     else goto not_accepted;	/* if we wanted to keep it, the word is illegal */
		if debug then
		     if returned_unit > 0 then call ioa_$nnl ("^a^a_; ", letters (returned_unit), "");
	     end;

/* This section of code just supplies the next unit of the word */

	     else do;
		if returned_unit < 0 | (returned_unit = 0 & word_index ^= 0)
		then goto not_accepted;		/* if last unit was not accepted */
		word_index = word_index + 1;
		new_unit = word_array (word_index);	/* get next unit from word */
		if vowel_flag			/* if random_word_ wanted a vowel, and this next unit is not one, */
		then if ^rules.vowel (new_unit)	/* then we have to give up */
		     then if ^rules.alternate_vowel (new_unit) /* I wouldn't dare give random_word_ a non-vowel when it expects a vowel */
			then goto not_accepted;
		returned_unit = new_unit;
		return;
	     end;
	end;

debug_on:	entry; debug = "1"b; return;

debug_off: entry; debug = "0"b; return;
     end;
