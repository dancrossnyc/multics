/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */


carry_load: proc;

/* This module implements the carry_load, carry_map and carry_retrieve commands,
   which operate on tapes created by the carry_dump command.

   Usage:
   carry_load tape_number {-control_args}

   where:

   1. tape_number	is the ASCII identifier of a tape.

   2. control_args can be:

-comment STR, -com STR
   specifies a comment name for the previously specified tape.
-copy_dir PATH, -cpd PATH
   specifies a different directory in which to place retrieved copies.
-force, -fc
   loads tape even if it is more than 5 days old.
-next_vol STR, -nxv STR
   specifies a continuation tape.
-queue_dir PATH, -qd PATH
   specifies a different directory containing the carry queue.
-test
   does not load a tape; used for testing.

   One of the entries on a carry tape is a directory containing segments to be mailed
   to requestors when the requests are successfully loaded. This directory is named
   mail_to_carry and resides in the specified queue directory. After the load has been
   performed, error messages are inserted in these mail segments and copies of entries
   that cannot be loaded are retrieved under the directory >daemon_dir_dir>carry_dir>copies.

   Note: This command reloads an entire carry tape. To load particular entries from a tape,
   use the carry_retrieve command.

   Active function usage:

   [carry_load tape_number {-control_args}]

   returns true if the tape could be read, false otherwise.

   Other commands:

   carry_map tape_number

   to list the contents of a carry tape, and:

   carry_retrieve tape_number {-select} path1 {-new_dir path2} etc.

   to retrieve a specified entry from a carry tape, possibly into someplace new.
   With -select, prints list of tape contents and accepts line nuumbers of requests.

   Steve Herbst 1/16/77 */
/* -trim and bug fixes 08/03/79 S. Herbst */
/* carry_retrieve -select 09/05/79 S. Herbst */
/* Add -user & -next_vol 01/08/80 S. Herbst */
/* Add -comment & -copy_dir 07/30/80 S. Herbst */


%include backup_control;
dcl 1 request_info (request_count) aligned based,
    2 sender char (32) unaligned,			/* Person.Project */
    2 new_user char (32) unaligned,			/* access name for copy if different */
    2 type_string char (32) unaligned,			/* "Segment" or "Subtree" */
    2 path char (168) unaligned,			/* pathname on tape */
    2 incacc_sw bit (1) aligned,			/* ON if requestor lacks sma on parent */
    2 incacc_code fixed bin (35),			/* code from hcs_$get_user_effmode */
    2 copy_sw bit (1) aligned,			/* ON to retrieve copy */
    2 copy_path char (168) unaligned,			/* >ddd>carry_dir>copies>... */
    2 user_dir char (168) unaligned;			/* >ddd>ccarry_dir>copies>next_dir */

dcl  queue_dir char (168) init (">ddd>carry_dir");
dcl  copy_dir char (168) init (">daemon_dir_dir>carry_dir>copies");

dcl  WHITE_SPACE char (2) int static options (constant) init ("	 ");  /* HT SP */
dcl  DIGITS char (10) int static options (constant) init ("1234567890");

dcl copy_path_array (50) char (168);
dcl copy_sender_array (50) char (168);

dcl query_explanation char (168) int static options (constant) init
	("Type the numbers of the requests you want retrieved, with optional ""-new_dir PATH"", as in ""2 4 -nd >foo 6""");
dcl (dn, error_path, mail_dir_path, new_dn, process_dir, request_path, tape_log_path) char (168);
dcl (command, en, temp_en) char (32);
dcl  arg char (arg_len) based (arg_ptr);
dcl  return_string char (return_len) varying based (return_ptr);
dcl  mail_seg char (mail_seg_len) based (mail_seg_ptr);
dcl (buffer, error_line) char (500);
dcl  answer char (300) varying;
dcl (err_string, sender_string) char (100);
dcl  name_string char (65);
dcl (new_user_id, sender_id) char (32);
dcl (destination, ds_arg) char (23);
dcl  (comment, tape_number) char (32) int static;
dcl  newline char (1) int static options (constant) init ("
");
dcl 1 next_array (20) int static,
     2 next_vol char (32),
     2 next_comment char (32);

dcl retrieve_array (500) bit (1) unaligned;

dcl  dtm72 bit (72);
dcl (active_function, ds_sw, found_sw, force_sw, got_path, got_tape) bit (1) aligned;
dcl (mail_sw, new_dir_sw, print_log_sw, select_sw, test_sw) bit (1) aligned;
dcl  use_first_tape bit (1) aligned int static;
dcl  tape_attached bit (1) aligned init ("0"b);

dcl (bk_iocb, new_mail_iocb, old_mail_iocb, tape_log_iocb) ptr init (null);
dcl (eptr, nptr) ptr init (null);
dcl (area_ptr, arg_ptr, mail_seg_ptr, return_ptr, tape_log_ptr) ptr;
dcl  ptrs (2) ptr;
dcl (control_ptr, info_ptr) ptr init (null);

dcl mode fixed bin (5);
dcl (arg_count, arg_len, buffer_len, copies_omitted, days, ecount, error_line_len) fixed bin;
dcl (i, j, k, level, number_omitted, request_count, request_index, return_len, saved_request_count) fixed bin;
dcl (next_vol_count, next_vol_index) fixed bin int static;
dcl  mail_seg_len fixed bin;
dcl (mail_seg_bc, tape_log_bc) fixed bin (24);
dcl  code fixed bin (35);
dcl (now, time_written, four_days) fixed bin (71);
dcl  ONE_DAY fixed bin (71) int static options (constant) init (86400000000);
dcl  ONE_HOUR fixed bin (71) int static options (constant) init (3600000000);

dcl  area area based (area_ptr);

dcl 1 segment_acl (1) aligned,
    2 access_name char (32) unaligned,
    2 modes bit (36),
    2 zero_pad bit (36),
    2 status_code fixed bin (35);

dcl 1 entries (ecount) aligned based (eptr),
    2 type bit (2) unaligned,
    2 nnames fixed bin (15) unaligned,
    2 nindex fixed bin (17) unaligned;

dcl  star_names (99) char (32) aligned based (nptr);
%include branch_status;
%include query_info;
%include send_mail_info;
%include access_mode_values;
dcl  error_table_$badopt fixed bin (35) ext;
dcl  error_table_$end_of_info fixed bin (35) ext;
dcl  error_table_$incorrect_access fixed bin (35) ext;
dcl  error_table_$noentry fixed bin (35) ext;
dcl  error_table_$nomatch fixed bin (35) ext;
dcl  error_table_$no_dir fixed bin (35) ext;
dcl  error_table_$not_act_fnc fixed bin (35) ext;
dcl  error_table_$not_attached fixed bin (35) ext;
dcl  error_table_$request_pending fixed bin (35) ext;
dcl  error_table_$rqover fixed bin (35) ext;

dcl  absolute_pathname_ entry (char (*), char (*), fixed bin (35));
dcl (active_fnc_err_, active_fnc_err_$suppress_name) entry options (variable);
dcl  adjust_bit_count_ entry (char (168) aligned, char (32) aligned, bit (1) aligned, fixed bin (24), fixed bin (35));
dcl  backup_load_ entry (ptr, fixed bin (35));
dcl  bk_input$input_finish entry;
dcl  bk_ss_$holdsw bit (1) aligned ext;
dcl (com_err_, com_err_$suppress_name) entry options (variable);
dcl  command_query_ entry options (variable);
dcl  convert_date_to_binary_ entry (char (*), fixed bin (71), fixed bin (35));
dcl  convert_status_code_ entry (fixed bin (35), char (*), char (*));
dcl  cu_$arg_count entry (fixed bin, fixed bin (35));
dcl  cu_$af_return_arg entry (fixed bin, ptr, fixed bin, fixed bin (35));
dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
dcl  cu_$level_get entry (fixed bin);
dcl  cv_dec_ entry (char (*)) returns (fixed bin);
dcl  expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));
dcl  get_group_id_ entry returns (char (32));
dcl  get_pdir_ entry returns (char (168));
dcl  get_system_free_area_ entry returns (ptr);
dcl  get_temp_segments_ entry (char (*), (*)ptr, fixed bin (35));
dcl  hcs_$add_acl_entries entry (char (*), char (*), ptr, fixed bin, fixed bin (35));
dcl  hcs_$add_dir_acl_entries entry (char (*), char (*), ptr, fixed bin, fixed bin (35));
dcl  hcs_$chname_file entry (char (*), char (*), char (*), char (*), fixed bin (35));
dcl  hcs_$del_dir_tree entry (char (*), char (*), fixed bin (35));
dcl  hcs_$delentry_file entry (char (*), char (*), fixed bin (35));
dcl  hcs_$get_user_effmode entry (char (*), char (*), char (*), fixed bin, fixed bin (5), fixed bin (35));
dcl  hcs_$initiate_count entry (char (*), char (*), char (*), fixed bin (24), fixed bin (1), ptr, fixed bin (35));
dcl  hcs_$star_ entry (char (*), char (*), fixed bin (2), ptr, fixed bin, ptr, ptr, fixed bin (35));
dcl  hcs_$status_ entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));
dcl  hcs_$status_minf entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24), fixed bin (35));
dcl  hcs_$terminate_noname entry (ptr, fixed bin (35));
dcl (ioa_, ioa_$ioa_switch, ioa_$nnl, ioa_$rs, ioa_$rsnnl) entry options (variable);
dcl  iox_$attach_name entry (char (*), ptr, char (*), ptr, fixed bin (35));
dcl  iox_$close entry (ptr, fixed bin (35));
dcl  iox_$detach_iocb entry (ptr, fixed bin (35));
dcl  iox_$error_output ptr ext;
dcl  iox_$find_iocb entry (char (*), ptr, fixed bin (35));
dcl  iox_$get_line entry (ptr, ptr, fixed bin, fixed bin, fixed bin (35));
dcl  iox_$open entry (ptr, fixed bin, bit (1), fixed bin (35));
dcl  iox_$put_chars entry (ptr, ptr, fixed bin, fixed bin (35));
dcl  iox_$user_output ptr ext;
dcl  release_temp_segments_ entry (char (*), (*)ptr, fixed bin (35));
dcl  send_mail_ entry (char (*), char (*), ptr, fixed bin (35));
dcl  send_message_$notify_mail entry options (variable);
dcl  unique_chars_ entry (bit (1) aligned) returns (char (32));

dcl (addr, clock, divide, fixed, index, length, ltrim) builtin;
dcl (min, null, rtrim, search, substr, translate, unspec, verify) builtin;

dcl (cleanup, program_interrupt) condition;
						/*  */
	command = "carry_load";
	print_log_sw, select_sw = "0"b;

	call cu_$af_return_arg (arg_count, return_ptr, return_len, code);
	if code = error_table_$not_act_fnc then active_function = "0"b;
	else do;
	     active_function = "1"b;
	     return_string = "false";
	end;

	if arg_count = 0 then do;
USAGE:	     if active_function then call active_fnc_err_$suppress_name
		(0, "carry_load", "Usage:  [carry_load tape_number {-control_args}]");
	     else call com_err_$suppress_name
		(0, "carry_load", "Usage:  carry_load tape_number {-control_args}");
	     return;
	end;

	comment = "";
	ds_sw, force_sw, got_tape, test_sw = "0"b;
	next_vol_count = 0;
	next_vol_index = 1;

	do i = 1 to arg_count;

	     call cu_$arg_ptr (i, arg_ptr, arg_len, code);

	     if substr (arg, 1, 1) = "-" then
		if arg = "-force" | arg = "-fc" then force_sw = "1"b;
		else if arg = "-test" then test_sw = "1"b;
		else if arg = "-destination" | arg = "-ds" then do;
		     i = i + 1;
		     if i > arg_count then do;
			call warn (0, "carry_load", "No value specified for -destination.");
			return;
		     end;
		     ds_sw = "1"b;
		     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
		     ds_arg = arg;
		end;
		else if arg = "-queue_dir" | arg = "-qd" then do;
		     i = i + 1;
		     if i > arg_count then do;
			call warn (0, "carry_load", "No value specified for -queue_dir");
			return;
		     end;
		     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
		     call absolute_pathname_ (arg, queue_dir, code);
		     if code ^= 0 then do;
			call warn (code, "carry_load", arg);
			return;
		     end;
		end;
		else if arg = "-comment" | arg = "-com" then do;
		     i = i + 1;
		     if i > arg_count then do;
			call warn (0, "carry_load", "No value specified for -comment.");
			return;
		     end;
		     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
		     if next_vol_count = 0 then comment = arg;
		     else next_array.next_comment (next_vol_count) = arg;
		end;
		else if arg = "-copy_dir" | arg = "-cpd" then do;
		     i = i + 1;
		     if i > arg_count then do;
			call warn (0, "carry_load", "No value specified for -copy_dir");
			return;
		     end;
		     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
		     call absolute_pathname_ (arg, copy_dir, code);
		     if code ^= 0 then do;
			call warn (code, "carry_load", arg);
			return;
		     end;
		end;
		else if arg = "-next_vol" | arg = "-nxv" then do;
		     i = i + 1;
		     if i > arg_count then do;
			call warn (0, "carry_load", "No value specified for -next_vol.");
			return;
		     end;
		     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
		     next_vol_count = next_vol_count + 1;
		     next_array.next_vol (next_vol_count) = arg;
		     next_array.next_comment (next_vol_count) = "";
		end;
		else do;
		     code = error_table_$badopt;
		     if active_function then call active_fnc_err_ (code, "carry_load", "^a", arg);
		     else call com_err_ (code, "carry_load", "^a", arg);
		     return;
		end;

	     else if got_tape then go to USAGE;
	     else do;
		got_tape = "1"b;
		tape_number = arg;
	     end;
	end;
	if ^got_tape then go to USAGE;
	go to COMMON;
						/*  */
carry_map: entry;

	command = "carry_map";
	active_function = "0"b;
	print_log_sw = "1"b;

	call cu_$arg_count (arg_count, code);
	if arg_count = 0 then do;
USAGE2:	     call com_err_$suppress_name (0, "carry_map", "Usage:  carry_map tape_number {-next_vol ...}");
	     return;
	end;

	go to GET_ARGS;




carry_retrieve: entry;

	command = "carry_retrieve";
	active_function = "0"b;
	force_sw = "1"b;				/* read tape no matter how old */

	call cu_$arg_count (arg_count, code);
	if arg_count < 2 then do;
USAGE3:	     call com_err_$suppress_name (0, "carry_retrieve",
		"Usage: carry_retrieve tape_number {-control_args} {path1} {-new_dir path2} etc.");
	     return;
	end;

GET_ARGS:	ds_sw, got_tape, got_path, select_sw, test_sw = "0"b;
	comment = "";
	next_vol_count = 0;
	next_vol_index = 1;

	do i = 1 to arg_count;
	     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
	     if substr (arg, 1, 1) ^= "-" then
		if ^got_tape then do;
		     got_tape = "1"b;
		     tape_number = arg;
		end;
		else got_path = "1"b;
	     else if arg = "-next_vol" | arg = "-nxv" then do;
		i = i + 1;
		if i > arg_count then do;
		     call com_err_ (0, command, "No value specified for -next_vol");
		     return;
		end;
		call cu_$arg_ptr (i, arg_ptr, arg_len, code);
		next_vol_count = next_vol_count + 1;
		next_array.next_vol (next_vol_count) = arg;
	     end;
	     else if command = "carry_map" then do;
		call com_err_ (error_table_$badopt, "carry_map", "^a", arg);
		return;
	     end;
	     else if arg = "-test" then test_sw = "1"b;
	     else if arg = "-select" then select_sw = "1"b;
	     else if arg = "-no_select" then select_sw = "0"b;
	end;

	if command = "carry_map" then do;
	     if ^got_tape then go to USAGE2;
	end;
	else do;
	     if ^got_path & ^select_sw then go to USAGE3;
	     print_log_sw = select_sw;
	end;
						/*  */
COMMON:	on condition (cleanup) call clean_up;

/* Allocate and initialize a control structure to drive backup_load_ */

	call get_temp_segments_ (command, ptrs, code);
	if code ^= 0 then do;
	     call warn (code, command,
		"^/Unable to allocate temp segs in process directory.^/Cannot load tape.");
	     return;
	end;
	control_ptr = ptrs (1);
	info_ptr = ptrs (2);

	use_first_tape = "1"b;
	control_ptr -> backup_control.version = BACKUP_CONTROL_VERSION_5;
	control_ptr -> backup_control.tape_entry = load_tape_entry;
	unspec (control_ptr -> backup_control.options) = "0"b;
	control_ptr -> backup_control.debug_sw = "1"b;
	control_ptr -> backup_control.first = "1"b;

	if command = "carry_load" | select_sw then control_ptr -> backup_control.hold_sw = "1"b;
	else control_ptr -> backup_control.hold_sw = "0"b;

	if command = "carry_retrieve" & ^select_sw then go to RETRIEVE;

/* Load <tape_number>.tape_log segment */

	control_ptr -> backup_control.no_primary_sw = "0"b;  /* try by both given and primary path */

	call ioa_$rsnnl ("^a>^a.tape_log", tape_log_path, 168, queue_dir, tape_number);
	control_ptr -> backup_control.request_count = 1;
	control_ptr -> backup_control.path (1) = tape_log_path;

	if print_log_sw then do;
	     process_dir = get_pdir_ ();
	     call ioa_$rsnnl ("^a>^a.tape_log", tape_log_path, 168, process_dir, tape_number);
	     control_ptr -> backup_control.new_path (1) = tape_log_path;
	end;
	else control_ptr -> backup_control.new_path (1) = "";

	tape_attached = "1"b;

	call backup_load_ (control_ptr, code);

	if code = error_table_$not_attached then do;
NO_TAPE:	     call warn (0, command, "Tape " || rtrim (tape_number) || " is not available.");
	     go to RETURN;
	end;

	if print_log_sw then do;			/* print tape log segment */
	     if code ^= 0 then do;
		call com_err_ (code, command, "Unable to load ^a", tape_log_path);
		go to RETURN;
	     end;
	     else if ^control_ptr -> backup_control.loaded (1) then do;
		call com_err_ (control_ptr -> backup_control.status_code (1), command,
		     "Unable to load ^a", tape_log_path);
		go to RETURN;
	     end;

	     call adjust_bit_count_ ((process_dir), rtrim (tape_number) || ".tape_log", "1"b, tape_log_bc, code);
	     call hcs_$initiate_count (tape_log_path, "", "", tape_log_bc, 0, tape_log_ptr, code);
	     if select_sw then go to READ;
	     call ioa_ ("^/");
	     call iox_$put_chars (iox_$user_output, tape_log_ptr, divide (tape_log_bc, 9, 17, 0), code);
	     call ioa_ ("");
	     call hcs_$delentry_file (tape_log_path, "", code);
	     go to RETURN;
	end;

	if code ^= 0 then do;
	     call warn (code, command,
		"^/Segment " || rtrim (tape_log_path) || " not loaded.^/Cannot load tape.");
	     go to RETURN;
	end;
	else if ^control_ptr -> backup_control.loaded (1) then do;
	     if control_ptr -> backup_control.status_code (1) = 0 then
		call warn (0, command, "Segment " || rtrim (tape_log_path) || " not found on tape.
Cannot load tape.");
	     else call warn (control_ptr -> backup_control.status_code (1), command,
		"^/Segment " || rtrim (tape_log_path) || " not found.^/Cannot load tape.");
	     go to RETURN;
	end;

/* Read <tape_number>.tape_log */

READ:	segment_acl (1).access_name = "*.*.*";
	segment_acl (1).modes = "100"b;
	segment_acl (1).zero_pad = "0"b;
	call hcs_$add_acl_entries (tape_log_path, "", addr (segment_acl), 1, code);
	call adjust_bit_count_ ((queue_dir), (rtrim (tape_number) || ".tape_log"), "1"b, (0), code);

	call iox_$attach_name ("carry_tape_log", tape_log_iocb, "vfile_ " || tape_log_path, null, code);
	if code ^= 0 then do;
	     call warn (code, command, "^/Unable to attach ""carry_tape_log"" to " || tape_log_path);
	     go to RETURN;
	end;
	call iox_$open (tape_log_iocb, 1, "0"b, code);
	if code ^= 0 then do;
READ_ERROR:    call warn (code, command,
		"^/Unable to read " || rtrim (tape_log_path) || "^/Cannot load tape.");
	     go to RETURN;
	end;

	call iox_$get_line (tape_log_iocb, addr (buffer), length (buffer), buffer_len, code);
	if code ^= 0 then go to READ_ERROR;
	j = index (buffer, " to ");
	i = index (buffer, " written ");
	if i = 0 then do;
PARSE_ERROR:   call warn (0, command, "Syntax error in tape log " || tape_log_path);
	     call ioa_$ioa_switch (iox_$error_output, substr (buffer, 1, min (100, buffer_len)));
	     call ioa_$ioa_switch (iox_$error_output, "Cannot load tape.");
	     go to RETURN;
	end;
	destination = substr (buffer, j + 4, i - j - 4);
	if ds_sw then
	     if destination ^= ds_arg then do;
		call warn (0, command, "Tape destination " || rtrim (destination) ||
		     " does not match destination arg " || rtrim (ds_arg) || "^/Cannot load tape.");
		go to RETURN;
	     end;
	i = i + 9;
	call convert_date_to_binary_ (substr (buffer, i, buffer_len - i), time_written, code);
	if code ^= 0 then go to PARSE_ERROR;
	days = divide (clock () - time_written, ONE_DAY, 71, 0);
	if days > 5 & ^force_sw then do;
	     call ioa_$rsnnl ("Tape is ^d days old and may contain old data.^/Not loaded.",
		buffer, buffer_len, days);
	     call warn (0, command, substr (buffer, 1, buffer_len));
	     go to RETURN;
	end;

	if select_sw then call ioa_ ("^/^a", substr (buffer, 1, buffer_len));  /* print header */
						/*  */
/* Test that requestors have sma access to parent directories */

	call cu_$level_get (level);

	call iox_$get_line (tape_log_iocb, addr (buffer), length (buffer), buffer_len, code);

	request_count, control_ptr -> backup_control.request_count = 0;
	number_omitted = 0;

	if select_sw then
	     on program_interrupt go to QUERY_INIT;

	do while (code ^= error_table_$end_of_info);

	     if buffer_len >= 22
		     & substr (buffer, 1, 22) = "No requests submitted."
		     & control_ptr -> backup_control.request_count < 2 then do;

		call ioa_ ("Tape contains no requests.");
		if active_function then return_string = "true";
		go to RETURN;
	     end;

	     request_count, control_ptr -> backup_control.request_count = request_count + 1;
	     if select_sw then call ioa_$nnl ("^3d^2x^a", request_count, substr (buffer, 1, buffer_len));
	     i = index (buffer, "  ");
	     if i = 0 then go to PARSE_ERROR;
	     info_ptr -> request_info (request_count).type_string = substr (buffer, 1, 7);
	     control_ptr -> backup_control.no_primary_sw (request_count) = "1"b;
	     if substr (buffer, buffer_len, 1) = newline then buffer_len = buffer_len - 1;
	     if substr (buffer, buffer_len - 8, 9) = " -new_dir" then do;
		new_dir_sw = "1"b;
		buffer_len = buffer_len - 9;
	     end;
	     else new_dir_sw = "0"b;
	     if substr (buffer, buffer_len - 5, 6) = " -trim" then do;
		control_ptr -> backup_control.trim_sw (request_count) = "1"b;
		buffer_len = buffer_len - 6;
	     end;
	     else control_ptr -> backup_control.trim_sw (request_count) = "0"b;
	     sender_string = substr (buffer, i + 2, buffer_len - i - 1);
	     j = index (sender_string, " -user ");
	     if j = 0 then do;
		sender_id = sender_string;
		new_user_id = "";
	     end;
	     else do;
		sender_id = substr (sender_string, 1, j - 1);
		new_user_id = substr (sender_string, j + 7);
	     end;
	     info_ptr -> request_info (request_count).sender = sender_id;
	     info_ptr -> request_info (request_count).new_user = new_user_id;
	     request_path, control_ptr -> backup_control.path (request_count) = substr (buffer, 9, i - 9);
	     control_ptr -> backup_control.new_path (request_count) = "";
	     call expand_pathname_ (request_path, dn, en, code);
	     if code ^= 0 then go to NEXT_LINE;
	     if new_dir_sw then do;
		call iox_$get_line (tape_log_iocb, addr (buffer), length (buffer), buffer_len, code);
		if code = 0 then do;
		     request_path, control_ptr -> backup_control.new_path (request_count) =
			substr (buffer, 29, buffer_len - 29) || ">" || en;
		     if select_sw then call ioa_$nnl ("^5x^a", substr (buffer, 1, buffer_len));
		end;
	     end;
	     if select_sw then go to NEXT_LINE;		/* don't test access for carry_retrieve */
	     temp_en = "";				/* get access on parent */

GET_MODE:	     if substr (sender_id, length (rtrim (sender_id)) - 1, 1) = "." then
		call hcs_$get_user_effmode (dn, temp_en, sender_id, level, mode, code);
	     else call hcs_$get_user_effmode (dn, temp_en, rtrim (sender_id) || ".*", level, mode, code);

	     if (mode ^= SMA_ACCESS_BIN & code = 0) |
	     (code ^= 0 &
	     (code ^= error_table_$noentry | temp_en ^= "") &
	     code ^= error_table_$no_dir) then
		if temp_en = "" & info_ptr -> request_info (request_count).type_string = "Subtree" then do;
		     temp_en = en;			/* settle for sma on existing directory itself */
		     go to GET_MODE;
		end;
		else do;
		     info_ptr -> request_info (request_count).incacc_sw = "1"b;
		     info_ptr -> request_info (request_count).incacc_code = code;
		     info_ptr -> request_info (request_count).path =
			control_ptr -> backup_control.path (request_count);
		     control_ptr -> backup_control.path (request_count) = ">foo>foo"; /* not findable */
		end;

NEXT_LINE:     call iox_$get_line (tape_log_iocb, addr (buffer), length (buffer), buffer_len, code);
	end;

	if select_sw then do;			/* carry_retrieve -select */

QUERY_INIT:    unspec (query_info) = "0"b;
	     query_info.version = query_info_version_5;
	     query_info.suppress_name_sw = "1"b;
	     query_info.explanation_ptr = addr (query_explanation);
	     query_info.explanation_len = length (rtrim (query_explanation));

QUERY:	     call command_query_ (addr (query_info), answer, "carry_retrieve", "Request numbers:  ");

	     unspec (retrieve_array) = "0"b;
	     request_index = 0;			/* initialize */
	     answer = ltrim (answer, WHITE_SPACE);
	     do while (answer ^= "");

		dn = get_token ();

		if verify (rtrim (dn), DIGITS) = 0 then do;
		     request_index = cv_dec_ (dn);
		     if request_index < 1 | request_index > request_count then do;
			call com_err_ (0, "carry_retrieve", "No request number ^d", request_index);
			go to QUERY;
		     end;
		     retrieve_array (request_index) = "1"b;  /* to be retrieved */
		end;
		else if dn = "-new_dir" | dn = "-nd" then do;
		     if request_index = 0 then do;
			call com_err_ (0, "carry_retrieve", "-new_dir must follow a request number.");
			go to QUERY;
		     end;

		     dn = get_token ();

		     if dn = "" then do;
			call com_err_ (0, "carry_retrieve", "No value specified for -new_dir");
			go to QUERY;
		     end;
		     call absolute_pathname_ (dn, dn, code);
		     if code ^= 0 then do;
			call com_err_ (code, "carry_retrieve", "^a", dn);
			go to QUERY;
		     end;
		     call expand_pathname_ (control_ptr -> backup_control.path (request_index), "", en, code);
		     control_ptr -> backup_control.new_path (request_index) = rtrim (dn) || ">" || en;
		end;
		else do;
		     call com_err_ (0, "carry_retrieve",
			"Can only select request #'s, optionally followed by -nd PATH.");
		     go to QUERY;
		end;
	     end;
	     if substr (unspec (retrieve_array), 1, request_count) = "0"b then do;
		call com_err_ (0, "carry_retrieve", "No retrievals requested.");
		go to RETURN;
	     end;
	     do i = 1 to request_count;
		if ^retrieve_array (i) then
		     control_ptr -> backup_control.path (i) = ">foo>foo";  /* not findable dummy */
	     end;

	     tape_attached = "1"b;

	     go to RELOAD;
	end;
						/*  */
						/* Add mail_to_carry directory to the control structure */

	call ioa_$rsnnl ("^a>mail_to_carry", buffer, buffer_len, queue_dir);
	control_ptr -> backup_control.path (request_count + 1) = buffer;
	control_ptr -> backup_control.new_path (request_count + 1) = "";

	request_count, control_ptr -> backup_control.request_count = request_count + 1;

/* Delete old mail_to_carry directory */

	call hcs_$status_minf (queue_dir, "mail_to_carry", 1, 0, 0, code);
	if code ^= error_table_$noentry then do;
	     segment_acl (1).access_name = get_group_id_ ();
	     segment_acl (1).modes = "111"b;
	     call hcs_$add_dir_acl_entries (queue_dir, "mail_to_carry", addr (segment_acl), 1, code);
	     call hcs_$del_dir_tree (queue_dir, "mail_to_carry", code);
	     call hcs_$delentry_file (queue_dir, "mail_to_carry", code);
	end;

/* Pick up args to carry_retrieve */

RETRIEVE:	if command = "carry_retrieve" then do;

	     request_count, control_ptr -> backup_control.request_count = 0;

	     do i = 2 to arg_count;
		call cu_$arg_ptr (i, arg_ptr, arg_len, code);
		if substr (arg, 1, 1) = "-" then
		     if arg = "-new_dir" | arg = "-nd" | arg = "-move" | arg = "-mv" then
			if request_count = 0 then go to USAGE3;
			else do;
			     i = i + 1;
			     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
			     if code ^= 0 then go to USAGE3;
			     call absolute_pathname_ (arg, new_dn, code);
			     if code ^= 0 then do;
BADPATH:				call com_err_ (code, "carry_retrieve", "^a", arg);
				go to RETURN;
			     end;
			     control_ptr -> backup_control.new_path (request_count) =
				rtrim (new_dn) || ">" || en;
			end;
		     else do;
			call com_err_ (error_table_$badopt, "carry_retrieve", "^a", arg);
			go to RETURN;
		     end;
		else do;
		     request_count, control_ptr -> backup_control.request_count = request_count + 1;
		     call expand_pathname_ (arg, dn, en, code);
		     if code ^= 0 then go to BADPATH;
		     control_ptr -> backup_control.path (request_count) = rtrim (dn) || ">" || en;
		     control_ptr -> backup_control.new_path (request_count) = "";
		     control_ptr -> backup_control.no_primary_sw (request_count) = "1"b;
		end;
	     end;
	     tape_attached = "1"b;
	end;

	control_ptr -> backup_control.no_reload_sw = test_sw;

RELOAD:

/* Try loading each thing by primary path as well, just in case */

	do i = 1 to request_count;
	     control_ptr -> backup_control.requests (i + request_count) = control_ptr -> requests (i);
	     control_ptr -> backup_control.no_primary_sw (i + request_count) = "0"b;
	end;
	control_ptr -> backup_control.request_count = request_count * 2;

/* Perform the reload */

	call backup_load_ (control_ptr, code);

	if code = error_table_$not_attached then go to NO_TAPE;

	if code ^= 0 then do;
	     call warn (code, command, "^/Tape " || rtrim (tape_number) || " not loaded.");
	     go to RETURN;
	end;

/* See if any were loaded by primary path instead of the expected path */

	do i = 1 to request_count;
	     if ^control_ptr -> backup_control.found (i) &
		control_ptr -> backup_control.found (i + request_count) then
		     control_ptr -> backup_control.requests (i) =  /* copy the primary path's info */
			control_ptr -> backup_control.requests (i + request_count);
	end;
	control_ptr -> backup_control.request_count = request_count;

	if command = "carry_retrieve" then do;

	     do i = 1 to control_ptr -> backup_control.request_count;

		if control_ptr -> backup_control.path (i) ^= ">foo>foo" then do;	/* selected */
		     if ^control_ptr -> backup_control.loaded (i) then
			call ioa_$ioa_switch (iox_$error_output, "^a not ^[loaded^;found on tape^].",
			control_ptr -> backup_control.path (i),
			control_ptr -> backup_control.found (i));
		     if control_ptr -> backup_control.status_code (i) ^= 0 then do;
			dn = control_ptr -> backup_control.new_path (i);
			if dn = "" then dn = control_ptr -> backup_control.path (i);
			call com_err_ (control_ptr -> backup_control.status_code (i),
			     control_ptr -> backup_control.error_name (i), dn);
		     end;
		end;
	     end;
	     go to RETURN;
	end;

	if active_function then return_string = "true";

	if control_ptr -> backup_control.loaded (request_count) then mail_sw = "1"b; /* mail dir loaded */
	else mail_sw = "0"b;

/* Look for error codes */

	do i = 1 to control_ptr -> backup_control.request_count - 1;

	     if control_ptr -> backup_control.loaded (i) then call really_look (i);

	     if ^control_ptr -> backup_control.loaded (i) &
	       control_ptr -> backup_control.status_code (i) ^= error_table_$noentry then do;

		number_omitted = number_omitted + 1;

		if info_ptr -> request_info (i).incacc_sw then
		     control_ptr -> backup_control.path (i) = info_ptr -> request_info (i).path;
		else info_ptr -> request_info (i).path = control_ptr -> backup_control.path (i);

		if control_ptr -> backup_control.status_code (i) = 0 then do;
		     control_ptr -> backup_control.status_code (i) = error_table_$noentry;
		     control_ptr -> backup_control.error_name (i) = "";
		end;

/* Prepare to retrieve a copy */

		if control_ptr -> backup_control.found (i) then do;  /* only if found at all */
		     info_ptr -> request_info (i).copy_sw = "1"b;
		     dn = control_ptr -> backup_control.new_path (i);
		     if dn = "" then dn = control_ptr -> backup_control.path (i);
		     j = index (substr (dn, 2), ">");
		     if j ^= 0 then do;
			k = index (substr (dn, j + 2), ">");
			if k ^= 0 then
			     if index (substr (dn, j + k + 2), ">") ^= 0 then
				dn = substr (dn, j + k + 1);
		     end;
		     dn = rtrim (copy_dir) || dn;
		     info_ptr -> request_info (i).copy_path = dn;
		     j = index (substr (dn, length (rtrim (copy_dir)) + 2), ">");
		     if j = 0 then info_ptr -> request_info.user_dir (i) = "";
		     else info_ptr -> request_info.user_dir (i) = substr (dn, 1, j + length (rtrim (copy_dir)) + 1);
		end;
	     end;

	     code = control_ptr -> backup_control.status_code (i);
	     name_string = control_ptr -> backup_control.error_name (i);

	     if code ^= 0
	     & name_string ^= "hcs_$set_safety_sw"
	     & name_string ^= "hcs_$replace_dir_acl"
	     & name_string ^= "set_ring_brackets" then do;

/* Print error message */

		if info_ptr -> request_info (i).incacc_sw then do; /* Lack sma to requestor */
		     code = info_ptr -> request_info (i).incacc_code;
		     error_path = info_ptr -> request_info (i).path;

		     if code = 0 then buffer = "Requestor lacks sma access to parent directory.";
		     else buffer = "^/Cannot check requestor's access to parent directory.";

		     call warn (code, "carry_load", rtrim (buffer) || "  " || error_path);
		end;
		else if name_string = "ACL, ring brackets, safety switch" then do;
		     if control_ptr -> backup_control.new_path (i) ^= "" then
			error_path = control_ptr -> backup_control.new_path (i);
		     else error_path = control_ptr -> backup_control.path (i);
		     call ioa_$ioa_switch (iox_$error_output,
			"Warning: No access to set ACL, ring brackets, safety switch.  ^a", error_path);
		end;
		else do;
		     if control_ptr -> backup_control.found (i)
		     & control_ptr -> backup_control.new_path (i) ^= "" then
			error_path = control_ptr -> backup_control.new_path (i);
		     else error_path = control_ptr -> backup_control.path (i);

		     if code = error_table_$noentry then
			call warn (0, name_string, "Entry not found on tape: " || rtrim (error_path)
			     || " Entry not loaded.");
		     else call warn (code, name_string, error_path);
		end;

		if mail_sw then do;

/* Put error message in mail seg */

		     if code = error_table_$incorrect_access then
			err_string = "Incorrect access to some containing directory.";
		     else call convert_status_code_ (code, "", err_string);
		     if info_ptr -> request_info (i).incacc_sw then
			if code = 0 then
				call ioa_$rs ("carry_load: " || buffer || " ^a",
				     error_line, error_line_len, error_path);
			else call ioa_$rs ("carry_load: ^a ^a " || buffer,
			     error_line, error_line_len, err_string, error_path);
		     else if name_string = "ACL, ring brackets, safety switch" then
			call ioa_$rs ("Warning: No access to set ACL, ring brackets, safety switch.   ^a",
			     error_line, error_line_len, error_path);
		     else call ioa_$rs ("^a: ^a ^a", error_line, error_line_len,
			name_string, err_string, error_path);

		     sender_id = info_ptr -> request_info.new_user (i);
		     if sender_id = "" then sender_id = info_ptr -> request_info.sender (i);
		     call ioa_$rsnnl ("^a>mail_to_carry", dn, 168, queue_dir);
		     temp_en = unique_chars_ ("0"b);	/* prepare to copy mail seg */
		     call hcs_$chname_file (dn, sender_id, sender_id, temp_en, code);
		     if code ^= 0 then go to MAIL_END;

		     found_sw = "0"b;

		     call iox_$attach_name ("old_carry_mail", old_mail_iocb,
			"vfile_ " || rtrim (dn) || ">" || temp_en, null, code);
		     if code ^= 0 then go to MAIL_END;
		     call iox_$open (old_mail_iocb, 1, "0"b, code);
		     if code ^= 0 then go to DETACH_OLD;
		     call iox_$attach_name ("new_carry_mail", new_mail_iocb,
			"vfile_ " || rtrim (dn) || ">" || sender_id, null, code);
		     if code ^= 0 then go to CLOSE_OLD;
		     call iox_$open (new_mail_iocb, 2, "0"b, code);
		     if code ^= 0 then go to DETACH_NEW;

		     call iox_$get_line (old_mail_iocb, addr (buffer), length (buffer), buffer_len, code);

		     do while (code ^= error_table_$end_of_info);

			if ^found_sw then do;	/* still looking */

/* See if this is the right line */

			     request_path = substr (buffer, 9, index (buffer, " loaded ") - 9);
			     if request_path = error_path then do;

				found_sw = "1"b;
				if control_ptr -> backup_control.loaded (i) then do;
				     call iox_$put_chars (new_mail_iocb, addr (buffer), buffer_len, code);
				     call iox_$put_chars (new_mail_iocb, addr (error_line),
					error_line_len, code);
				end;
				else do;
				     call ioa_$ioa_switch (new_mail_iocb,
					"Unable to load ^a from tape ^a", error_path, tape_number);
				     error_line_len = length (rtrim (error_line));
				     call iox_$put_chars (new_mail_iocb, addr (error_line),
					error_line_len, code);
				     if unspec (info_ptr -> request_info (i).copy_path) = "0"b then
					call ioa_$ioa_switch (new_mail_iocb, "Check for copy in ^a", copy_dir);
				     else call ioa_$ioa_switch (new_mail_iocb, "Check for copy ^a",
					info_ptr -> request_info (i).copy_path);
				end;
			     end;
			     else call iox_$put_chars (new_mail_iocb, addr (buffer), buffer_len, code);
			end;
			else call iox_$put_chars (new_mail_iocb, addr (buffer), buffer_len, code);

			call iox_$get_line (old_mail_iocb, addr (buffer), length (buffer), buffer_len, code);
		     end;

		     call iox_$close (new_mail_iocb, code);
DETACH_NEW:	     call iox_$detach_iocb (new_mail_iocb, code);
CLOSE_OLD:	     call iox_$close (old_mail_iocb, code);
DETACH_OLD:	     call iox_$detach_iocb (old_mail_iocb, code);

		     call hcs_$delentry_file (dn, temp_en, code);
MAIL_END:		end;
	     end;
	end;

/* Print "not loaded" messages */

	do i = 1 to control_ptr -> backup_control.request_count - 1;

	     if ^control_ptr -> backup_control.loaded (i) then
		call ioa_$ioa_switch (iox_$error_output, "^a ^a not loaded.",
		info_ptr -> request_info (i).type_string,
		control_ptr -> backup_control.path (i));
	end;

	if command = "carry_retrieve" then go to RETURN;

/* Clean up old copies */

	call delete_old_copies;

/* Retrieve copies */

	saved_request_count = control_ptr -> backup_control.request_count - 1;
	request_count, control_ptr -> backup_control.request_count = 0;

	do i = 1 to saved_request_count;

	     if info_ptr -> request_info (i).copy_sw then do;

		request_count, control_ptr -> backup_control.request_count = request_count + 1;
		control_ptr -> backup_control.path (request_count) =
		     info_ptr -> request_info (i).path;
		control_ptr -> backup_control.new_path (request_count) =
		     info_ptr -> request_info (i).copy_path;
		control_ptr -> backup_control.status_code (request_count) = 0;

		info_ptr -> request_info (request_count).sender =
		     info_ptr -> request_info (i).sender;
		info_ptr -> request_info (request_count).new_user =
		     info_ptr -> request_info (i).new_user;
		info_ptr -> request_info (request_count).type_string =
		     info_ptr -> request_info (i).type_string;
	     end;
	end;

	if request_count = 0 then do;
	     bk_ss_$holdsw = "0"b;			/* demount tape */
	     call bk_input$input_finish;
	end;
	else do;
	     control_ptr -> backup_control.hold_sw = "0"b;

	     call backup_load_ (control_ptr, code);
	end;

	tape_attached = "0"b;

/* Set access on copies */

	segment_acl (1).modes = "111"b;
	copies_omitted = 0;

	do i = 1 to request_count;

	     if control_ptr -> backup_control.loaded (i) then call really_look (i);

	     if ^control_ptr -> backup_control.loaded (i) then do;
		if control_ptr -> backup_control.status_code (i) = error_table_$rqover then
		     call hcs_$delentry_file (control_ptr -> backup_control.new_path (i), "", code);
		if control_ptr -> backup_control.status_code (i) = error_table_$incorrect_access then
		     call com_err_ (0, "carry_load", "Incorrect access to some containing directory.  ^a",
			control_ptr -> backup_control.new_path (i));
		else if control_ptr -> backup_control.status_code (i) ^= 0 then
		     call com_err_ (control_ptr -> backup_control.status_code (i), "carry_load",
		     "^[Copy not loaded.  ^]^a", control_ptr -> backup_control.status_code (i) - 0,
		     control_ptr -> backup_control.new_path (i));
		copies_omitted = copies_omitted + 1;
		copy_path_array (copies_omitted) = control_ptr -> backup_control.new_path (i);
		copy_sender_array (copies_omitted) = info_ptr -> request_info (i).sender;
		if active_function then return_string = "false";
	     end;
	     sender_id = info_ptr -> request_info (i).new_user;
	     if sender_id = "" then sender_id = info_ptr -> request_info (i).sender;
	     segment_acl (1).access_name = substr (sender_id, 1, index (sender_id, ".") - 1) || ".*.*";
	     call expand_pathname_ (control_ptr -> backup_control.path (i), dn, en, code);
	     call hcs_$add_dir_acl_entries (dn, "", addr (segment_acl), 1, code);  /* parent */
	     if code ^= 0 & control_ptr -> backup_control.loaded (i) then call warn (code, "carry_load", dn);
	     if info_ptr -> request_info (i).user_dir ^= "" then
		call hcs_$add_dir_acl_entries (info_ptr -> request_info (i).user_dir, "",
		     addr (segment_acl), 1, code);
	     if info_ptr -> request_info (i).type_string = "Subtree" then
		call hcs_$add_dir_acl_entries (dn, en, addr (segment_acl), 1, code);
	     else call hcs_$add_acl_entries (dn, en, addr (segment_acl), 1, code);
	end;

/* Send mail to requestors */

	area_ptr = get_system_free_area_ ();
	send_mail_info.version = 2;
	send_mail_info.sent_from = "";
	unspec (send_mail_info.switches) = "0"b;
	send_mail_info.always_add = "1"b;

	call ioa_$rsnnl ("^a>mail_to_carry", mail_dir_path, 168, queue_dir);

	ecount = 0;

	call hcs_$star_ (mail_dir_path, "**", 3 /* all */, area_ptr, ecount, eptr, nptr, code);

	do i = 1 to ecount;

	     sender_id = star_names (entries (i).nindex);
	     call hcs_$initiate_count (mail_dir_path, sender_id, "", mail_seg_bc, 0, mail_seg_ptr, code);
	     if mail_seg_ptr ^= null then do;
		mail_seg_len = divide (mail_seg_bc, 9, 17, 0);

		call send_mail_ (sender_id, mail_seg, addr (send_mail_info), code);
		j = index (sender_id, ".");
		call send_message_$notify_mail (substr (sender_id, 1, j - 1), substr (sender_id, j + 1), code);
						/* send mail notification */
		call hcs_$terminate_noname (mail_seg_ptr, code);
	     end;
	end;

	call ioa_ ("carry_load: Normal termination.");
	if number_omitted ^= 0 then
	     call ioa_ ("^d request^[s^] not loaded in place.", number_omitted, number_omitted > 1);
	if copies_omitted ^= 0 then do;
	     call ioa_ ("OF THESE, ^d COPIES NOT LOADED:", copies_omitted);
	     do i = 1 to copies_omitted;
		call ioa_ ("^3x^a^3x^a", copy_path_array (i), copy_sender_array (i));
	     end;
	end;

RETURN:	call clean_up;

	return;
						/*  */
get_token: proc returns (char (168));

/* This internal procedure, used by carry_retrieve -select, returns the next
   space-separated token from the user's answer to "Request numbers:" query. */

dcl token char (168);

	if answer = "" then return ("");
	i = search (answer, WHITE_SPACE);
	if i = 0 then do;
	     token = answer;
	     answer = "";
	end;
	else do;
	     token = substr (answer, 1, i - 1);
	     answer = ltrim (substr (answer, i), WHITE_SPACE);
	end;
	return (token);

end get_token;
/**/
really_look: proc (i);

/* Checks that an entry has really been loaded with nonzero contents. */

dcl i fixed bin;
dcl path char (168);

	path = control_ptr -> backup_control.new_path (i);
	if path = "" then path = control_ptr -> backup_control.path (i);

	call hcs_$status_ (path, "", 1, addr (branch_status), null, code);

	if code = error_table_$noentry | code = error_table_$no_dir then do;
NOT_THERE:     control_ptr -> backup_control.loaded (i) = "0"b;
	     control_ptr -> backup_control.status_code (i) = error_table_$request_pending;
						/* "Request has not been completed" */
	end;
	else if code = 0 then do;
	     dtm72 = "0"b;
	     substr (dtm72, 21, 36) = branch_status.date_time_modified;  /* convert dtcm to clock time */
	     unspec (time_written) = unspec (dtm72);
	     if clock () - time_written > ONE_HOUR then go to NOT_THERE;
	     if branch_status.records = "0"b then go to NOT_THERE;
	end;

end really_look;
						/*  */
delete_old_copies: proc;

/* This internal procedure deletes all directories under >ddd>carry_dir>copies
   all of whose segments are more than 4 days old. */

	     call convert_date_to_binary_ ("4 days", four_days, code);
	     now = clock ();

	     segment_acl (1).access_name = get_group_id_ ();
	     segment_acl (1).modes = "111"b;

	     area_ptr = get_system_free_area_ ();
	     eptr, nptr = null;
	     on condition (cleanup) begin;
		if eptr ^= null then free eptr -> entries in (area);
		if nptr ^= null then free nptr -> star_names in (area);
	     end;

	     call hcs_$star_ (copy_dir, "**", 3 /* all */, area_ptr, ecount, eptr, nptr, code);
	     if code ^= 0 then return;

	     do i = 1 to ecount;
		en = star_names (entries (i).nindex);
		if ALL_OLD (copy_dir, en) then do;
		     call hcs_$del_dir_tree (copy_dir, en, code);
		     call hcs_$delentry_file (copy_dir, en, code);
		end;
	     end;

	     if eptr ^= null then free eptr -> entries in (area);
	     if nptr ^= null then free nptr -> star_names in (area);

	end delete_old_copies;
						/*  */
ALL_OLD:	proc (DN, EN) returns (bit (1) aligned);

/* This internal procedure, which calls itself recursively, returns ("1"b) if
   all segments below it are more than 2 weeks old. */

dcl (DN, EN) char (*);
dcl  DIR_NAME char (168);
dcl  ENAME char (32);
dcl (EPTR, NPTR) ptr;
dcl (ECOUNT, I) fixed bin;

	     call hcs_$status_ (DN, EN, 0, addr (branch_status), area_ptr, code);
	     if code ^= 0 then return ("0"b);

	     if branch_status.type = segment_type | branch_status.type = link_type then
		if now - fixed (branch_status.date_time_modified || (16)"0"b, 52) > four_days then return ("1"b);
		else return ("0"b);

	     else do;
		call hcs_$add_dir_acl_entries (DN, EN, addr (segment_acl), 1, code);
		EPTR, NPTR = null;
		on condition (cleanup) call free_names;
		DIR_NAME = rtrim (DN) || ">" || EN;
		call hcs_$star_ (DIR_NAME, "**", 3 /* all */, area_ptr, ECOUNT, EPTR, NPTR, code);
		if code ^= 0 then
		     if code = error_table_$nomatch then return ("1"b);
		     else return ("0"b);
		do I = 1 to ECOUNT;
		     ENAME = NPTR -> star_names (EPTR -> entries (I).nindex);

		     if ^ALL_OLD (DIR_NAME, ENAME) then do;
			call free_names;
			return ("0"b);
		     end;
		end;
		call free_names;
		return ("1"b);
	     end;

free_names:    proc;

		if EPTR ^= null then free EPTR -> entries in (area);
		if NPTR ^= null then free NPTR -> star_names in (area);

	     end free_names;

	end ALL_OLD;
						/*  */
load_tape_entry: entry (tape_label);

/* This entry point, called by backup_load_, returns carry_load's tape_number
   argument the first time it is called, -next_vol arguments succeeding times,
   and finally "" */

dcl  tape_label char (32);

	if use_first_tape then
	     if comment ^= "" then tape_label = rtrim (tape_number) || ",*" || translate (comment, ";", ",");
	     else tape_label = tape_number;
	else if next_vol_index <= next_vol_count then do;
	     tape_label = next_array.next_vol (next_vol_index);
	     if next_array.next_comment (next_vol_index) ^= "" then
		tape_label = rtrim (tape_label) || ",*" || translate (next_array.next_comment (next_vol_index), ";", ",");
	     next_vol_index = next_vol_index + 1;
	end;
	else tape_label = "";
	use_first_tape = "0"b;
	return;
						/*  */
warn:	proc (a_code, a_name, a_string);

/* This internal procedure prints an error message on error_output without signalling
   in the case of an active function. In the case of a command, it calls com_err_.
   We don't want active function error messages to abort exec_com's. */

dcl  a_code fixed bin (35);
dcl (a_name, a_string) char (*);

	     if active_function then do;
		if a_name = "" then a_name = "carry_load";
		if a_code = 0 then call ioa_$ioa_switch (iox_$error_output, "^a: " || a_string, a_name);
		else do;
		     call convert_status_code_ (a_code, "", err_string);
		     call ioa_$ioa_switch (iox_$error_output, "^a: ^a  " || a_string, a_name, err_string);
		end;
	     end;

	     else if a_name = "" then call com_err_$suppress_name (a_code, "carry_load", a_string);
	     else call com_err_ (a_code, a_name, a_string);

	end warn;


clean_up:	proc;

	     if tape_attached then do;
		call bk_input$input_finish;
		call iox_$find_iocb ("bk_input_1", bk_iocb, code);
		call iox_$close (bk_iocb, code);
		call iox_$detach_iocb (bk_iocb, code);
	     end;
	     if old_mail_iocb ^= null then call iox_$close (old_mail_iocb, code);
	     if old_mail_iocb ^= null then call iox_$detach_iocb (old_mail_iocb, code);
	     if new_mail_iocb ^= null then call iox_$close (new_mail_iocb, code);
	     if new_mail_iocb ^= null then call iox_$detach_iocb (new_mail_iocb, code);
	     if tape_log_iocb ^= null then call iox_$close (tape_log_iocb, code);
	     if tape_log_iocb ^= null then call iox_$detach_iocb (tape_log_iocb, code);

	     call release_temp_segments_ ("carry_load", ptrs, code);

	end clean_up;


     end carry_load;
