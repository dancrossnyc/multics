/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1989                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1986 *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(86-08-21,Fakoury), approve(86-08-21,MCR7515),
     audit(87-01-07,Farley), install(87-01-08,MR12.0-1263):
     Originally coded 0782 by Rick Fakoury for MR12.
  2) change(87-01-13,Fakoury), approve(87-01-13,MCR7515),
     audit(87-01-14,Martinson), install(87-01-14,MR12.0-1278):
     PBF to correct -deckfile short name to -df from -dkf.
  3) change(89-02-06,Fakoury), approve(90-10-03,MCR8147),
     audit(90-10-03,Parisek), install(90-10-25,MR12.4-1049):
     to to allow tape copy without using a deck file or list seg.
  4) change(89-06-01,Fakoury), approve(90-10-03,MCR8147),
     audit(90-10-03,Parisek), install(90-10-25,MR12.4-1049):
     to to insert a space in the copy tape attach description for TR21325
     to increase the size of att_desc from 64 to 181 for TR21336.
  5) change(90-10-30,Fakoury), approve(90-11-28,MCR8219),
     audit(90-11-28,Schroth), install(90-11-28,MR12.4-1051):
     PBF correct to previous installation: changed to call dfm_util_$make_key
     after call to get_cata for catalog record.
                                                   END HISTORY COMMENTS */

/* format: style4,ifthenstmt,ifthen,ind3,ll125,lineconind1 */
dfm_: proc ();

      return;					/* not a valid entry */



/* AUTOMATIC */

dcl  N fixed bin;
dcl  X fixed bin;
dcl  al fixed bin (21);
dcl  all_diskettes bit (1);
dcl  alp ptr;
dcl  ap ptr;
dcl  c_att_desc char (181);
dcl  code fixed bin (35);
dcl  decks_tb_deleted (10) char (24) varying;
dcl  deck_tb_patched char (24) varying;
dcl  deckfile_path char (168);
dcl  diskettes_tb_read (hbound (valid_diskettes, 1)) char (8) varying;
dcl  diskette_type char (4);
dcl  dkf_dir (3) char (168);
dcl  dkf_entry (3) char (32);
dcl  dkf_path (3) char (168);
dcl  dkf_path_idx fixed bin;
dcl  dl_patch bit (1);
dcl  dwg_num_tab char (2);
dcl  eof bit (1);
dcl  err bit (1);
dcl  lsf_dir char (168);
dcl  lsf_entry char (32);
dcl  i fixed bin;
dcl  j fixed bin;
dcl  list_all_keys bit (1);
dcl  mca bit (1);
dcl  mca_err bit (72);
dcl  mca_id char (4);
dcl  ml fixed bin (21);
dcl  n_diskettes_tb_read fixed bin;
dcl  nargs fixed bin;
dcl  npatches fixed bin;
dcl  ndecks_tb_deleted fixed bin;
dcl  of_dir char (168);
dcl  of_entry char (32);
dcl  of_path char (168);
dcl  output_mode_specified bit (1);
dcl  patch_length fixed bin;
dcl  patch_ptr ptr;
dcl  patch_word char (84) varying;
dcl  pname char (72) varying;
dcl  prod_num_tab char (2);
dcl  query_info_ptr ptr;
dcl  query_message char (256);
dcl  rl fixed bin (21);
dcl  sci_ptr ptr;
dcl  tdec fixed bin (35);
dcl  term bit (1);
dcl  user_entry char (8) varying;
dcl  user_reply char (256) varying;
dcl  vfile_open_mode fixed bin;
dcl  xofn char (2);
dcl  yes_sw bit (1);


/*  BASED */

dcl  add_pic pic "999999" based;
dcl  arg char (al) based (ap);
dcl  bin_arg fixed bin (35) based (ap);
dcl  bit_arg bit (al) based (ap);
dcl  1 df_keys based (dfm_data.dfkp) aligned,		/* template for deckfile catalog keys */
       2 n_entries fixed bin,				/* number of catalog entries */
       2 key (1 refer (df_keys.n_entries)) char (24);	/* entry search keys */

dcl  free_area area based (get_system_free_area_ ());

dcl  ptr_arg ptr based (ap);


/* BUILTINS */

dcl  addr builtin;
dcl  before builtin;
dcl  bin builtin;
dcl  char builtin;
dcl  clock builtin;
dcl  convert builtin;
dcl  index builtin;
dcl  hbound builtin;
dcl  lbound builtin;
dcl  length builtin;
dcl  ltrim builtin;
dcl  null builtin;
dcl  rtrim builtin;
dcl  search builtin;
dcl  string builtin;
dcl  substr builtin;
dcl  translate builtin;
dcl  unspec builtin;


/* CONDITIONS */

dcl  cleanup condition;


/* CONSTANTS */

dcl  deckfile char (16) int static options (constant) init (">tandd_deck_file");
dcl  false bit (1) int static options (constant) init ("0"b);
dcl  minargs fixed bin int static options (constant) init (3);
dcl  nl_sw bit (1) aligned int static options (constant) init ("0"b);
dcl  pad_sw bit (1) aligned int static options (constant) init ("0"b);
dcl  print bit (1) int static options (constant) init ("0"b);
dcl  system_dir char (21) int static options (constant) init
      (">system_library_tandd");
dcl  true bit (1) int static options (constant) init ("1"b);
dcl  wrapup bit (1) int static options (constant) init ("1"b);


/* EXTERNAL ENTRIES */

dcl  command_query_ entry () options (variable);
dcl  command_query_$yes_no entry () options (variable);
dcl  cu_$arg_count entry (fixed bin, fixed bin (35));
dcl  cu_$arg_list_ptr entry (ptr);
dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
dcl  date_time_ entry (fixed bin (52), char (*));
dcl  date_time_$format entry (char (*), fixed bin (71), char (*), char (*)) returns (char (250) var);
dcl  dfm_util_$ck_applic entry (ptr) returns (bit (1));
dcl  dfm_util_$copy_eof entry (ptr);
dcl  dfm_util_$delete_deck entry (ptr, char (24) var, fixed bin (35));
dcl  dfm_util_$detach_file entry (ptr, ptr);
dcl  dfm_util_$find_dkend entry (ptr, char (24) var, ptr, fixed bin, fixed bin (35));
dcl  dfm_util_$find_file entry (ptr, char (*), char (*));
dcl  dfm_util_$find_key entry (ptr, ptr, char (24) var, ptr, fixed bin (35));
dcl  dfm_util_$get_cata entry (ptr, ptr, char (24) var, ptr, ptr, fixed bin (35));
dcl  dfm_util_$insert_deck entry (ptr, ptr, ptr, fixed bin (21), char (24) varying);
dcl  dfm_util_$make_key entry (ptr);
dcl  dfm_util_$mca_attach entry (ptr, char (4));
dcl  dfm_util_$mca_detach entry (ptr);
dcl  dfm_util_$merge_files entry (ptr, ptr, ptr);
dcl  dfm_util_$mount_diskette entry (ptr, char (8) var, ptr) returns (bit (1));
dcl  dfm_util_$open_file entry (ptr, char (64), char (181), fixed bin (17), ptr);
dcl  dfm_util_$print_list entry (ptr, ptr, char (24) varying);
dcl  dfm_util_$read_deck entry (ptr, bit (1), bit (1));
dcl  dfm_util_$read_diskette entry (ptr, char (*), ptr, fixed bin (21), bit (72), fixed bin (35));
dcl  dfm_util_$update_list entry (ptr, fixed bin (2));
dcl  dfm_util_$valid_diskette entry (ptr, char (8) varying) returns (bit (1));
dcl  expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));
dcl  get_system_free_area_ entry () returns (ptr);
dcl  get_wdir_ entry returns (char (168));
dcl  hcs_$chname_file entry (char (*), char (*), char (*), char (*), fixed bin (35));
dcl  ioa_$general_rs entry (ptr, fixed bin, fixed bin, char (*), fixed bin (21), bit (1) aligned, bit (1) aligned);
dcl  ioa_$rsnnl entry () options (variable);
dcl  mca_$read_data entry (fixed bin, ptr, fixed bin (21), fixed bin (21), bit (72), fixed bin (35));
dcl  ssu_$arg_count entry (ptr, fixed bin);
dcl  ssu_$arg_ptr entry (ptr, fixed bin, ptr, fixed bin (21));
dcl  ssu_$abort_line entry () options (variable);
dcl  ssu_$abort_subsystem entry () options (variable);
dcl  ssu_$get_info_ptr entry (ptr) returns (ptr);
dcl  ssu_$get_temp_segment entry (ptr, char (*), ptr);
dcl  ssu_$get_subsystem_and_request_name entry (ptr) returns (char (72) var);
dcl  ssu_$print_message entry () options (variable);
dcl  ssu_$release_temp_segment entry (ptr, ptr);
dcl  sub_err_ entry () options (variable);


/* EXTERNAL STATIC */

dcl  error_table_$bad_arg fixed bin (35) ext static;
dcl  error_table_$noarg fixed bin (35) ext static;
dcl  error_table_$segnamedup fixed bin (35) ext static;
dcl  error_table_$too_many_names fixed bin (35) ext static;
dcl  iox_$user_output ext ptr;

/* PARAMETERS */

dcl  P_dfm_infop ptr parameter;
dcl  P_sci_ptr ptr parameter;


%page;

/* clean_up - general clean up rountine */

clean_up: entry (P_sci_ptr, P_dfm_infop);

      call setup_part1;
      call wrap_up;

      return;



%page;


/* This procedure is a general purpose complainer. If ABORT is true, then
   ssu_$abort_line is called. ssu_$print_message is called otherwise.	*/

/* calling sequence: dfm_$complain (dfm_datap, abort, code, ioa_control_string, arg1...argn) */

complain: entry options (variable);


dcl  ecode fixed bin (35);
dcl  message char (256);
dcl  ABORT bit (1);


      message = "";
      ml = 0;

      call cu_$arg_count (nargs, code);
      if nargs < minargs then
         call sub_err_ (code, "dfm_$complain", ACTION_CANT_RESTART, null, 0, "");

      do i = 1 to minargs;
         call cu_$arg_ptr (i, ap, al, code);
         if code ^= 0 then
	  call sub_err_ (code, "dfm_$complain", ACTION_CANT_RESTART,
	   null, 0, "encountered while attempting to get ^[dfm_datap^;abort^;code^] arg.", i);

         else if i = 1 then dfm_datap = ptr_arg;
         else if i = 2 then ABORT = bit_arg;
         else if i = 3 then ecode = bin_arg;
      end;

      sci_ptr = dfm_data.sci_ptr;

      if nargs > minargs then do;
         call cu_$arg_list_ptr (alp);
         call ioa_$general_rs (alp, 4, 5, message, ml, pad_sw, nl_sw);
      end;


      if ABORT then do;
         dfm_infop = dfm_data.infop;
         call wrap_up;				/* free the stuff I MAY have allocated */

         call ssu_$abort_line (sci_ptr, ecode, "^a", substr (message, 1, ml)); /* BYE! */
      end;
      else call ssu_$print_message (sci_ptr, ecode, "^a", substr (message, 1, ml));
      return;


%page;

/* delete_deck - entry to delete a deck a deckfile */

delete_deck: entry (P_sci_ptr, P_dfm_infop);


      call setup_part1;
      call setup_part2;
      dd = true;
      ndecks_tb_deleted = 0;

      on cleanup call wrap_up;

      call ssu_$arg_count (sci_ptr, nargs);

      if nargs > 0 then do i = 1 to nargs;
         call ssu_$arg_ptr (sci_ptr, i, ap, al);

         if arg = "-deckfile" | arg = "-df" then do;	/* user will specify path */
	  i = i + 1;
	  call ssu_$arg_ptr (sci_ptr, i, ap, al);
	  if al = 0 then
	     call complain (dfm_datap, wrapup, error_table_$bad_arg,
	      "obtaining ""-deckfile"" specification.", "");
	  else deckfile_path = arg;
         end;

         else if arg = "-brief" | arg = "-bf" then dfm_data.bf_sw = true; /* user doesn't want unnecessary nessages */

         else do;
	  ndecks_tb_deleted = ndecks_tb_deleted + 1;
	  if ndecks_tb_deleted > hbound (decks_tb_deleted, 1) then
	     call complain (dfm_datap, wrapup, error_table_$too_many_names,
	      "only ^d decks maybe deleted", hbound (decks_tb_deleted, 1));
	  decks_tb_deleted (ndecks_tb_deleted) = arg;
         end;
      end;

      if ndecks_tb_deleted = 0 then do;
         call complain (dfm_datap, print, error_table_$noarg,
	"No key given to specify the deck to be deleted.", "");

         query_message = "Enter a key or partial key for the deck to be deleted.";
         query_info.explanation_len = length (rtrim (query_message));
         query_info.explanation_ptr = addr (query_message);
         call command_query_ (query_info_ptr, user_reply, pname,
	"Enter: <key> ");

         ndecks_tb_deleted = 1;
         decks_tb_deleted (ndecks_tb_deleted) = user_reply;
      end;

      if ndecks_tb_deleted > 0 then do;

         call ssu_$get_temp_segment (sci_ptr, "catalog keys", dfm_data.dfkp); /* get temp seg for catalog keys */
         call ssu_$get_temp_segment (sci_ptr, "catalog list", dfm_data.lcatp); /* get temp seg for list catalog */
         dfm_data.liocb_ptr = iox_$user_output;
         dfm_data.terminal_out = true;
         dfm_data.deckfile_sw = true;			/* deckfile is required */

         call get_files;
         do i = 1 to ndecks_tb_deleted;
	  call dfm_util_$find_key (dfm_datap, dfm_data.fiocb_ptr,
	   decks_tb_deleted (i), dfm_data.dfkp, code);
	  if code ^= 0 then
	     call complain (dfm_datap, wrapup, code,
	      "attempting to find keys for ^a", decks_tb_deleted (i));

	  term = false;
	  if df_keys.n_entries > 1 then do j = 1 to df_keys.n_entries while (^term);
	     call command_query_$yes_no (yes_sw, 0, pname, "^d ^2s entries matched the key given",
	      "key given matched ^d entries. ^/Entry ^d is ^a - Is this the deck to be deleted?",
	      df_keys.n_entries, j, df_keys.key (j));
	     if yes_sw then do;
	        term = true;
	        j = j - 1;				/* adjust to correct value */
	     end;
	  end;

	  else j = 1;

	  if j <= df_keys.n_entries then do;
	     decks_tb_deleted (i) = df_keys.key (j);
	     call dfm_util_$delete_deck (dfm_datap, decks_tb_deleted (i), code);
	     if code ^= 0 then
	        call complain (dfm_datap, wrapup, code,
	         "attempting to delete deck ^a", decks_tb_deleted (i));
	     dfm_data.list_key = "ls." || rtrim (decks_tb_deleted (i));
	     call dfm_util_$print_list (dfm_datap, dfm_data.fiocb_ptr, dfm_data.list_key);
	  end;
         end;
      end;


      call wrap_up;

      return;

%page;

/* list - entry to generate a list file or display on the user terminal
   all or portion of the list information in a deckfile */


list: entry (P_sci_ptr, P_dfm_infop);

      call setup_part1;
      call setup_part2;

      dfm_data.list = true;
      list_all_keys = false;
      output_mode_specified = false;

      on cleanup call wrap_up;

      call ssu_$arg_count (sci_ptr, nargs);

      if nargs > 0 then do i = 1 to nargs;
         call ssu_$arg_ptr (sci_ptr, i, ap, al);

         if arg = "-all" | arg = "-a" then list_all_keys = true;

         else if arg = "-brief" | arg = "-bf" then
	  dfm_data.bf_sw = true;			/* user doesn't want unnecessary nessages */

         else if arg = "-deckfile" | arg = "-df" then do;	/* user will specify path */
	  i = i + 1;
	  call ssu_$arg_ptr (sci_ptr, i, ap, al);
	  if al = 0 then
	     call complain (dfm_datap, wrapup, error_table_$bad_arg,
	      "obtaining ""-deckfile"" specification.", "");
	  else deckfile_path = arg;
         end;

         else if arg = "-file_out" | arg = "-fo" then do;
	  dfm_data.terminal_out = false;
	  output_mode_specified = true;
         end;

         else if arg = "-term_out" | arg = "-to" then
	  dfm_data.terminal_out, output_mode_specified = true;

         else if dfm_data.list_key = "" then dfm_data.list_key = arg;
         else call complain (dfm_datap, wrapup, error_table_$bad_arg,
	     "More than one list key specified.", "");
      end;

      if ^list_all_keys & dfm_data.list_key = "" then do;
         call complain (dfm_datap, print, error_table_$noarg,
	"Insufficient number of args supplied.", "");

         query_message = "Enter a key for the file to be listed or all to create a complete deckfile.list.";
         query_info.explanation_len = length (rtrim (query_message));
         query_info.explanation_ptr = addr (query_message);
         call command_query_ (query_info_ptr, user_reply, pname,
	"Enter: <the key or -all.> ");

         if user_reply = "-all"
	| user_reply = "-a" then list_all_keys = true;
         else dfm_data.list_key = user_reply;
      end;

      if ^output_mode_specified & dfm_data.list_key ^= "" then do;
         dfm_data.terminal_out = true;
         dfm_data.page_no = 0;
      end;

      dfm_data.deckfile_sw = true;			/* deckfile is required */

      call get_files;
      call ssu_$get_temp_segment (sci_ptr, "catalog keys", dfm_data.lcatp); /* get temp seg for catalog keys */
      lcata.n_entries = 0;				/* initially set to 0 entries */
      if dfm_data.terminal_out then dfm_data.liocb_ptr = iox_$user_output;
      if list_all_keys then do i = lbound (list_types, 1) to hbound (list_types, 1);
         dfm_data.list_key = list_types (i);
         call dfm_util_$find_key (dfm_datap, dfm_data.fiocb_ptr, dfm_data.list_key, dfm_data.lcatp, code);
         if code ^= 0 then dfm_data.list_key = "";
         if dfm_data.list_key ^= "" then
	  call dfm_util_$print_list (dfm_datap, dfm_data.fiocb_ptr, dfm_data.list_key);
      end;

      else if dfm_data.list_key ^= "" then do;
         if index (dfm_data.list_key, "ls.") ^= 1 then dfm_data.list_key = "ls." || dfm_data.list_key;
         call dfm_util_$find_key (dfm_datap, dfm_data.fiocb_ptr, dfm_data.list_key, dfm_data.lcatp, code);
         if code ^= 0 then
	  call complain (dfm_datap, wrapup, code,
	   "attempting to find keys for ^a", dfm_data.list_key);

         if lcata.n_entries > 1 then do j = 1 to lcata.n_entries while (^term);
	  call command_query_$yes_no (yes_sw, 0, pname, "^d^2s entries matched the key given",
	   "key given matched ^d entries.^/ Entry ^d is ^a - Is this the file to be listed?",
	   lcata.n_entries, j, lcata.key (j));
	  if yes_sw then do;
	     term = true;
	     dfm_data.list_key = lcata.key (j);
	  end;
	  else dfm_data.list_key = "";
         end;

         if dfm_data.list_key = "" then
	  call complain (dfm_datap, wrapup, 0,
	   "There are no files to be listed", "");
         else call dfm_util_$print_list (dfm_datap, dfm_data.fiocb_ptr, dfm_data.list_key);
      end;

      call wrap_up;

      return;


%page;

/* list_diskettes - entry to list valid diskette types used in the
   load_from_diskette entry */

list_diskette_types: entry (P_sci_ptr, P_dfm_infop);

dcl  out_str char (hbound (valid_diskettes, 1) * 5) varying;

      call setup_part1;

      on cleanup call wrap_up;

      out_str = "";
      do i = 1 to hbound (valid_diskettes, 1);
         out_str = out_str || substr (valid_diskettes (i), 1, 3) || "  ";
      end;
      call complain (dfm_datap, print, 0, "^/^a^/", out_str);
      dfm_data.finished = true;
      dfm_info.flags.request_active = false;
      return;


%page;

/* load_from_diskette - entry to read MCA diskettes into a deckfile */

load_from_diskette: entry (P_sci_ptr, P_dfm_infop);

      call setup_part1;
      call setup_part2;
      dfm_data.lfd = true;
      dir_ptr = null;

      on cleanup begin;
         if dir_ptr ^= null then free directory in (free_area);
         call wrap_up;
      end;

      all_diskettes = false;
      mca = false;
      call ssu_$arg_count (sci_ptr, nargs);
      if nargs > 0 then do i = 1 to nargs;
         call ssu_$arg_ptr (sci_ptr, i, ap, al);

         if arg = "-mca" then do;
	  i = i + 1;
	  call ssu_$arg_ptr (sci_ptr, i, ap, al);
	  if al ^= 1 then
	     call complain (dfm_datap, wrapup, 0,
	      "arg following -mca arg incorrect", "");
	  else if search (arg, "abcd") = 0 then
	     call complain (dfm_datap, wrapup, 0,
	      "arg following -mca arg incorrect", "");
	  else mca = true;
	  mca_id = "mca" || arg;
         end;

         else if arg = "-brief"
	| arg = "-bf" then dfm_data.bf_sw = true;	/* user doesn't want unnecessary nessages */

         else if arg = "-deckfile"
	| arg = "-df" then do;			/* user will specify path */
	  i = i + 1;
	  call ssu_$arg_ptr (sci_ptr, i, ap, al);
	  if al = 0 then
	     call complain (dfm_datap, wrapup, error_table_$bad_arg,
	      "obtaining ""-deckfile"" specification.", "");
	  else deckfile_path = arg;
         end;

         else if arg = "-all" | arg = "-a" then all_diskettes = true;

         else if dfm_util_$valid_diskette (dfm_datap, (arg)) then do;
	  n_diskettes_tb_read = n_diskettes_tb_read + 1;
	  diskettes_tb_read (n_diskettes_tb_read) = arg;
         end;
         else call complain (dfm_datap, wrapup, 0, "Invalid arg ^a", arg);
      end;

      if n_diskettes_tb_read = 0 & ^all_diskettes then do;
         call complain (dfm_datap, print, error_table_$noarg,
	"A diskette to be read must be specified", "");

         query_message = "Enter a diskette name, or -all for all diskettes";
         query_info.explanation_len = length (rtrim (query_message));
         query_info.explanation_ptr = addr (query_message);
         call command_query_ (query_info_ptr, user_reply, pname,
	"Enter: <diskette name>");

         if user_reply = "-all"
	| user_reply = "-a" then all_diskettes = true;

         else do;
	  user_entry = substr (user_reply, 1, 8);
	  if dfm_util_$valid_diskette (dfm_datap, user_entry) then do;
	     n_diskettes_tb_read = 1;
	     diskettes_tb_read (n_diskettes_tb_read) = user_entry;
	  end;

	  else call complain (dfm_datap, wrapup, 0,
	        "Invalid diskette name, use list_diskette_types (ldt) request to obtain valid types", "");
         end;
      end;


      if ^mca then do;
         query_message = "Enter the mca (a-d) of the mca to be used";
         query_info.explanation_len = length (rtrim (query_message));
         query_info.explanation_ptr = addr (query_message);
         call command_query_ (query_info_ptr, user_reply, pname,
	" Enter MCA to be used ");
         if search (user_reply, "abcd") = 0 then
	  call complain (dfm_datap, wrapup, 0, "invalid mca id entered", "");
         else mca = true;
         mca_id = "mca" || rtrim (user_reply);
      end;


      if all_diskettes then do;
         n_diskettes_tb_read = hbound (valid_diskettes, 1);
         diskettes_tb_read = valid_diskettes;
      end;

      if n_diskettes_tb_read < 1 then
         call complain (dfm_datap, wrapup, 0, "no diskette type entered", "");

      call ssu_$get_temp_segment (sci_ptr, "catalog keys", dfm_data.lcatp); /* get temp seg for list catalog */

      call ssu_$get_temp_segment (sci_ptr, "diskette catalog", dfm_data.dcatp); /* get temp seg for diskette catalog */

      call ssu_$get_temp_segment (sci_ptr, "mca catalog", dfm_data.mcatp); /* get temp seg for mca catalog */

      call ssu_$get_temp_segment (sci_ptr, "mca data read buffer", dfm_data.mca_wksp); /* get temp seg for reading mca data */



/* attach and open needed files */

      dfm_data.deckfile_sw = true;			/* deckfile is required */
      call get_files;
      call dfm_util_$mca_attach (dfm_datap, mca_id);

%page;


/* main processing loop */


      call dfm_util_$get_cata (dfm_datap, dfm_data.fiocb_ptr,
       "cata.nio.mca", dfm_data.mcatp, dfm_data.mksp, code);
      if code ^= 0 then
         call complain (dfm_datap, wrapup, code, "can't get mca catalog", "");

      do i = 1 to n_diskettes_tb_read;
         unspec (dcata) = "0"b;

remount:
         if dfm_util_$mount_diskette (dfm_datap,
	translate (diskettes_tb_read (i), uc, lc), dfm_data.mca_wksp) then
	  call dfm_util_$read_diskette (dfm_datap, "HDR",
	   dfm_data.mca_wksp, rl, mca_err, code);

         else do;
	  call complain (dfm_datap, print, code, pname,
	   "Operator unable to mount diskette ^a", diskettes_tb_read (i));
	  query_message = "Problems encountered mounting the diskette. Enter:  - (a)bort, (s)kip or (r)etry? ";
	  query_info.explanation_len = length (rtrim (query_message));
	  query_info.explanation_ptr = addr (query_message);
	  call command_query_ (query_info_ptr, user_reply, pname,
	   "Enter:  - (a)bort, (s)kip or (r)etry? ");
	  if user_reply = "r" | user_reply = "retry" then goto remount;
	  if user_reply = "s" | user_reply = "skip" then goto next_disk;
	  else goto exit_lfd;
         end;

         header_ptr = dfm_data.mca_wksp;
         if mca_status.maj | mca_sub.data_p | code ^= 0
	| substr (translate (header.unique_id, lc, uc), 1, 3) ^= substr (diskettes_tb_read (i), 1, 3)
	| substr (header.title, 1, 4) ^= "UTIL" then do;
	  if substr (translate (header.unique_id, lc, uc), 1, 3) ^= substr (diskettes_tb_read (i), 1, 3) then do;
	     call complain (dfm_datap, print, pname,
	      "Diskette ^a mounted - instead of ^a? ", header.unique_id, diskettes_tb_read (i));
	     query_message = "Wrong diskette mounted. Enter:  - (a)bort, (s)kip or (r)etry? ";
	     query_info.explanation_len = length (rtrim (query_message));
	     query_info.explanation_ptr = addr (query_message);
	     call command_query_ (query_info_ptr, user_reply, pname,
	      "Enter:  - (a)bort, (s)kip or (r)etry? ");
	     if user_reply = "r" | user_reply = "retry" then goto remount;
	     if user_reply = "s" | user_reply = "skip" then goto next_disk;
	     else goto exit_lfd;
	  end;

next_disk:  if i < n_diskettes_tb_read then do;
	     call command_query_$yes_no (yes_sw, code, pname,
	      "Unable to read the HEADER - want to continue",
	      "Unable to read the ^a - read the next diskette?", "HEADER");
	     if yes_sw then goto next_diskette;
	     else goto exit_lfd;
	  end;
	  else call complain (dfm_datap, wrapup, code,
	        "reading ^a HEADER", (diskettes_tb_read (i)));
         end;

         call complain (dfm_datap, print, 0,
	"Mounted diskette ^a on drive ^d", header.unique_id, dfm_data.disk_num);
         N = bin (substr (header.x_of_n, 1, 9), 9);
         X = bin (substr (header.x_of_n, 10, 9), 9);
         unspec (xofn) = header.x_of_n;
         dir_number = 0;
         substr (unspec (dir_number), 21, 16) = header.dir_size.msb || header.dir_size.lsb;
         dir_number = dir_number / 16;
         dfm_data.edit_date = header.date_changed;
         diskette_type = header.equip_type;
         dwg_num_tab = substr (header.disk_dwg_num, 11);
         prod_num_tab = substr (header.unique_id, 7);
         dfm_data.current_disk_name = rtrim (header.unique_id);
         current_filename = rtrim ("HDR." || header.unique_id || prod_num_tab || "00");

         if i = 1 then call add_name ("mca.diskettes.rev." || prod_num_tab);
         call dfm_util_$get_cata (dfm_datap, dfm_data.fiocb_ptr,
	"cata.nio." || rtrim (header.unique_id), dfm_data.dcatp, dfm_data.dksp, code);
         if code ^= 0 then
	  call complain (dfm_datap, wrapup, code,
	   "can't get ^a catalog", header.unique_id);
         call file_deck (dfm_data.mca_wksp, rl);
         call dfm_util_$read_diskette (dfm_datap, "DIRECTORY",
	dfm_data.mca_wksp, rl, mca_err, code);

         if mca_status.maj | mca_sub.data_p | code ^= 0 then do;
	  if i < n_diskettes_tb_read then do;
	     call command_query_$yes_no (yes_sw, code, pname,
	      "Unable to read DIRECTORY file. Want to continue?",
	      "Unable to read ^a file. Read the next diskette?", "DIRECTORY");
	     if yes_sw then goto next_diskette;
	     else goto exit_lfd;
	  end;
	  else call complain (dfm_datap, wrapup, code,
	        "reading ^a DIRECTORY", diskettes_tb_read (i));
         end;

         dir_ptr = dfm_data.mca_wksp;
         alloc directory in (free_area) set (dir_ptr);
         directory = dfm_data.mca_wksp -> directory;
         current_filename = rtrim (diskette_type || ".DIRECTRY" || prod_num_tab || "00");
         call file_deck (dfm_data.mca_wksp, rl);

         do j = 1 to dir_number;
	  dire_ptr = addr (directory.array (j));
	  if (dire.path_name = ".DPSFILE" & j < dir_number)
	   | dire.deleted then goto next_file;
	  call dfm_util_$read_diskette (dfm_datap, "P=" || dire.path_name,
	   dfm_data.mca_wksp, rl, mca_err, code);
	  if mca_status.maj | code ^= 0 then do;
	     if j < dir_number then do;
	        call command_query_$yes_no (yes_sw, code, pname,
	         "Unable to read last file. Want to continue?",
	         "Unable to read file ^a. Read the next file?", dire.path_name);
	        if yes_sw then goto next_file;
	     end;
	     else do;
	        free directory in (free_area);
	        dir_ptr = null;
	        call complain (dfm_datap, wrapup, code,
	         "unable to read file ^a", dire.path_name);
	     end;
	  end;
	  current_filename = rtrim (dire.path_name || prod_num_tab || dwg_num_tab);
	  call file_deck (dfm_data.mca_wksp, rl);
next_file: end;
         free directory in (free_area);
         dir_ptr = null;
         current_filename = rtrim ("cata." || dfm_data.current_disk_name);
         rl = dcata.n_entries * 24 + 4;
         call file_deck (dfm_data.dcatp, rl);
next_diskette:
         dfm_data.hdr_sw = true;			/* force a new header */
      end;
      dfm_data.current_filename = rtrim ("cata.mca");
      rl = mcata.n_entries * 24 + 4;
      call file_deck (dfm_data.mcatp, rl);

      call dfm_util_$insert_deck (dfm_datap, dfm_data.fiocb_ptr, dfm_data.lcatp,
       length (unspec (lcata)), "ls.cata." || dfm_data.ls_type || ".list");
      call dfm_util_$print_list (dfm_datap, dfm_data.fiocb_ptr,
       "ls.cata." || dfm_data.ls_type || ".list");

exit_lfd:
      call wrap_up;

      return;


%page;

/* load_from_tape - entry to read an ifad or fnp tape into a deckfile */

load_from_tape: entry (P_sci_ptr, P_dfm_infop);

      call setup_part1;
      call setup_part2;
      dfm_data.lft = true;

      on cleanup call wrap_up;

      call ssu_$arg_count (sci_ptr, nargs);

      if nargs > 0 then do j = 1 to nargs;
         call ssu_$arg_ptr (sci_ptr, j, ap, al);
         if index (arg, "-") ^= 1 then do;		/* must be tape name */
	  dfm_data.t_att_desc = "tape_nstd_ " || arg;	/* start attach description */

	  if tdec = 6250 | tdec = 1600 | tdec = 800 | tdec = 556 | tdec = 200 then
	     dfm_data.t_att_desc = rtrim (dfm_data.t_att_desc) || " -density " || ltrim (char (tdec));

	  tape_name = before (arg, ",");		/* If comma, use stuff before */
	  dfm_data.l_att_desc = "vfile_ " || tape_name;	/* start listing attach description */
         end;

         else if arg = "-brief" | arg = "-bf" then dfm_data.bf_sw = true; /* user doesn't want unnecessary nessages */
         else if arg = "-firmware" | arg = "-fw" then do;
	  dfm_data.firmware_sw = true;		/* user just wants firmware loaded */
	  dfm_data.attach_copy, dfm_data.deckfile_sw = false;
         end;

         else if arg = "-copy" | arg = "-cp" then do;	/* user wantsd to make copy of ifad tape */
	  j = j + 1;
	  call ssu_$arg_ptr (sci_ptr, j, ap, al);
	  if al = 0 then
	     call complain (dfm_datap, wrapup, code,
	      "obtaining ""-copy"" tape reel specification.", "");
	  c_att_desc = "tape_nstd_ " || arg;		/* generate initial copy attach description */

	  if tdec = 6250 | tdec = 1600 | tdec = 800 | tdec = 556 | tdec = 200 then
	     c_att_desc = rtrim (c_att_desc) || " -density " || ltrim (char (tdec));
	  dfm_data.attach_copy = true;		/* set flag */
	  dfm_data.firmware_sw = false;
         end;

         else if arg = "-deckfile" | arg = "-df" then do;	/* user will specify path */
	  j = j + 1;
	  call ssu_$arg_ptr (sci_ptr, j, ap, al);
	  if al = 0 then
	     call complain (dfm_datap, wrapup, error_table_$bad_arg,
	      "obtaining ""-deckfile"" specification.", "");
	  else deckfile_path = arg;
	  dfm_data.deckfile_sw = true;
         end;

         else if arg = "-density" | arg = "-den" then do;	/* next arg must be density value */
	  j = j + 1;
	  call ssu_$arg_ptr (sci_ptr, j, ap, al);
	  if al = 0 then
	     call complain (dfm_datap, wrapup, code,
	      "obtaining ""-density"" specification.", "");
	  tdec = cv_dec_check_ (arg, code);
	  if code ^= 0 then go to bad_arg;
	  if tdec = 6250 | tdec = 1600 | tdec = 800 | tdec = 556 | tdec = 200 then do;
	     if dfm_data.attach_copy then do;		/* if setting density on copy tape */
	        c_att_desc = rtrim (c_att_desc) || " -density " || ltrim (char (tdec));
	        cd_sw = true;			/* set indicator */
	     end;
	     if dfm_data.tape_name ^= "" then
	        dfm_data.t_att_desc = rtrim (dfm_data.t_att_desc) || " -density " || ltrim (char (tdec));
	  end;
	  else go to bad_arg;			/* make him get it right */
         end;

         else if arg = "-patches" then
	  dfm_data.allow_0_cksum = true;		/* user wants to allow firmware decks with a 0 checksum */

         else if arg = "-track" | arg = "-tk" then do;	/* next arg must be 7 or 9 */
	  j = j + 1;
	  call ssu_$arg_ptr (sci_ptr, j, ap, al);	/* get track arg */
	  if al = 0 then				/* error */
	     call complain (dfm_datap, wrapup, code,
	      "obtaining ""-track"" specification.", "");
	  tdec = cv_dec_check_ (arg, code);		/* convert to dec. for check */
	  if code ^= 0 then go to bad_arg;		/* must be numeric */
	  if tdec ^= 7 & tdec ^= 9 then go to bad_arg;	/* and only 7 or 9 */
	  if dfm_data.attach_copy then		/* if track specification of copy tape */
	     c_att_desc = rtrim (c_att_desc) || " -track " || arg; /* insert leading blank */
	  else dfm_data.t_att_desc = rtrim (dfm_data.t_att_desc) || " -track " || arg;
         end;

         else do;
bad_arg:	  call complain (dfm_datap, wrapup, error_table_$bad_arg, "^a", arg);
         end;
      end;

      if ^dfm_data.attach_copy			/* if ^copy */
       & ^dfm_data.deckfile_sw			/* & ^deckfile */
       & ^dfm_data.firmware_sw			/* & ^firmware only */
       then dfm_data.deckfile_sw = true;		/* default is to use the deckfile */

      if ^dfm_data.firmware_sw & dfm_data.deckfile_sw	/* if ^firmware & deckfile */
       then dfm_data.firmware_sw = true;		/* default is to create firmware segs */

      if dfm_data.tape_name = "" then do;
         call complain (dfm_datap, print, error_table_$noarg,
	"A tape name must be supplied", "");

         query_message = "Enter the name of the tape, ifad or 6670bdt, to be mounted.";
         query_info.explanation_len = length (rtrim (query_message));
         query_info.explanation_ptr = addr (query_message);
         call command_query_ (query_info_ptr, user_reply, pname,
	"Enter <tape_name>: ");

         dfm_data.t_att_desc = "tape_nstd_ " || user_reply; /* start attach description */
         tape_name = before (user_reply, ",");		/* If comma, use stuff before */
         dfm_data.l_att_desc = "vfile_ " || dfm_data.tape_name; /* start listing attach description */
      end;

      if dfm_data.tape_name = "" then
         call complain (dfm_datap, wrapup, code,
	"^/Usage:^-load_from_tape reel_id {-control_args}", "");


      call ssu_$get_temp_segment (sci_ptr, "tape buffer", dfm_data.bptr); /* get temp segs for tape buffer */
      call ssu_$get_temp_segment (sci_ptr, "catalog buffer", dfm_data.catp); /* get temp segs for catalog buffer */
      call ssu_$get_temp_segment (sci_ptr, "catalog keys", dfm_data.lcatp); /* get temp seg for catalog keys */

      call get_files;				/* attach and open needed files */

      call add_name (dfm_data.tape_name);


      do while (^dfm_data.eot);			/* read tape until 2 eofs */
         call dfm_util_$read_deck (dfm_datap, eof, err);	/* read in next object deck */
         if err | (eof & one_eof) | dfm_data.eot then do;	/* if error condition or 2 eofs */
	  dfm_data.eot = true;			/* thats all there is to do */

	  if dfm_data.attach_copy then
	     call dfm_util_$copy_eof (dfm_datap);	/* if we are copying tape,write out 2nd eof */

	  if dfm_data.fnp_tape & ^err & ^dfm_data.list then do; /* write out fnp catalog record */
	     dfm_data.current_key = "cata." || rtrim (dfm_data.cat_key); /* form completed key */
	     call dfm_util_$insert_deck (dfm_datap, dfm_data.fiocb_ptr, dfm_data.catp,
	      length (unspec (cata)), dfm_data.current_key); /* and write catalog to deck file */
	     call dfm_util_$update_list (dfm_datap, cata_list_type); /* add catalog record to listing file */
	  end;
         end;
         else if eof then do;				/* if eof */
	  one_eof = true;				/* set flag */
	  if dfm_data.attach_copy then		/* if we are copying tape */
	     if ^dfm_data.copy_at_eof then		/* and copy tape is not already at end of file */
	        call dfm_util_$copy_eof (dfm_datap);	/* go write eof on copy tape */

	  if dfm_data.cat_build
	   & ^dfm_data.fnp_tape then do;		/* if we were building catalog */
	     dfm_data.cat_build, dfm_data.first_deck = false; /* reset flags */
	     if index (dfm_data.cat_key, "itr.") ^= 0 then do; /* if building itr catalog */
	        if id_blk.type = "itr" | id_blk.type = "mdr" then do; /* last entry must be firmware */
		 call complain (dfm_datap, print, 0, "Last object deck on itr file is not firmware", "");
		 call complain (dfm_datap, wrapup, 0, "Last object card image is:^/""^a""", dfm_data.obj_card);
	        end;
	        else do;				/* no errors form catalog name */
		 do i = cata.n_entries to 1 by -1 while (index (cata.key (i), ".") > 4);
		 end;				/* find first firmware deck */
		 cata.n_entries = cata.n_entries + 1;
		 dfm_data.cat_key = rtrim (dfm_data.cat_key)
		  || substr (cata.key (i + 1), 8, 6) || "." || substr (cata.key (i + 1), 20, 2);
	        end;
	     end;
	     dfm_data.current_key = "cata." || rtrim (dfm_data.cat_key); /* set current key */
	     call dfm_util_$insert_deck (dfm_datap, dfm_data.fiocb_ptr,
	      dfm_data.catp, length (unspec (cata)), dfm_data.current_key); /* and write catalog to deck file */
	     call dfm_util_$update_list (dfm_datap, cata_list_type); /* add catalog record to listing file */
	  end;
         end;

         else do;
	  one_eof = false;				/*  reset eof flag if set */
	  if dfm_data.list then			/* if just producing listing, take all decks */
	     call dfm_util_$update_list (dfm_datap, data_list_type); /* go add entry to listing file */

	  else if dfm_data.fnp_tape			/* no applicability check for fnp decks */
	   | (dfm_util_$ck_applic (dfm_datap)		/* check for Multics applicibilty */
	   & dfm_data.deckfile_sw) then
	     call file_deck (dfm_data.bptr, dfm_data.dlen * 4); /* just loading firmware, don't insert deck into deckfile */

         end;
      end;

      call dfm_util_$insert_deck (dfm_datap, dfm_data.fiocb_ptr, dfm_data.lcatp,
       length (unspec (lcata)), "ls.cata." || dfm_data.ls_type || ".list");

      call dfm_util_$print_list (dfm_datap, dfm_data.fiocb_ptr, "ls.cata." || dfm_data.ls_type || ".list");
      call wrap_up;
      return;


%page;

/* merge_deckfiles - entry to merge two or more tandd_deck_files */

merge_deckfiles: entry (P_sci_ptr, P_dfm_infop);

      call setup_part1;
      call setup_part2;
      dfm_data.mdf = true;

      call ssu_$arg_count (sci_ptr, nargs);
      dkf_path_idx = 1;				/* point to first path */

      do i = 1 to nargs;
         call ssu_$arg_ptr (sci_ptr, i, ap, al);

         if arg = "-brief"
	| arg = "-bf" then dfm_data.bf_sw = true;	/* user doesn't want unnecessary nessages */

         else if arg = "-output_file"
	| arg = "-of" then do;
	  i = i + 1;
	  call ssu_$arg_ptr (sci_ptr, i, ap, al);
	  if al = 0 then
	     call complain (dfm_datap, wrapup, code, "obtaining ""-output_file"" specification.", "");
	  else of_path = arg;
         end;

         else if dkf_path_idx > hbound (dkf_path, 1) then
	  call complain (dfm_datap, wrapup, error_table_$bad_arg,
	   "More than ^d deck files to be merged", hbound (dkf_path, 1));

         else do;
	  dkf_path (dkf_path_idx) = arg;
	  dkf_path_idx = dkf_path_idx + 1;
         end;
      end;

      if dkf_path (1) = "" then do;
         call complain (dfm_datap, print, error_table_$noarg,
	"At least one input deckfile path is required", "");

         query_message = "Input deckfile path may be either a path or -working_dir or -system";
         query_info.explanation_len = length (rtrim (query_message));
         query_info.explanation_ptr = addr (query_message);
         call command_query_ (query_info_ptr, user_reply, pname,
	"Enter <input deckfile path>: ");

         dkf_path (1) = user_reply;
      end;


      if of_path = "" & dfm_info.deckfile_dir = "" then do;
         call complain (dfm_datap, print, error_table_$noarg,
	"An output deckfile path is required", "");

         query_message = "Output deckfile path may be either a path or -working_dir or -system";
         query_info.explanation_len = length (rtrim (query_message));
         query_info.explanation_ptr = addr (query_message);
         call command_query_ (query_info_ptr, user_reply, pname,
	"Enter <output deckfile path>: ");

         of_path = user_reply;
      end;

      if dkf_path (1) = "" | of_path = "" then
         call complain (dfm_datap, wrapup, error_table_$noarg,
	"Both an input and output deckfile path are required", "");

      do i = lbound (dkf_path, 1) to hbound (dkf_path, 1);
         if dkf_path (i) = "-working_dir"
	| dkf_path (i) = "-wd" then
	  dkf_path (i) = rtrim (dir) || deckfile;

         else if dkf_path (i) = "-system"
	| dkf_path (i) = "-sys" then
	  dkf_path (i) = system_dir || deckfile;

         if of_path = "-working_dir"
	| of_path = "-wd" then
	  of_path = rtrim (dir) || ">" || deckfile;

         else if of_path = "-system"
	| of_path = "-sys" then
	  of_path = system_dir || ">" || deckfile;

         if of_path = dkf_path (i) then dkf_path (i) = "";
      end;

      call get_files;

      call ssu_$get_temp_segment (sci_ptr, "temp data buffer", dfm_data.bptr); /* get temp segs for data buffer */
      call ssu_$get_temp_segment (sci_ptr, "list catalog", dfm_data.lcatp); /* get temp segs for list catalog */

      do i = lbound (dfm_data.dkf_iocbp, 1) to hbound (dfm_data.dkf_iocbp, 1);
         if dfm_data.dkf_iocbp (i) ^= null & dfm_data.of_iocbp ^= null then
	  call dfm_util_$merge_files (dfm_datap, dfm_data.dkf_iocbp (i), dfm_data.of_iocbp);
      end;

      do i = lbound (list_types, 1) to hbound (list_types, 1);
         dfm_data.list_key = list_types (i);
         call dfm_util_$find_key (dfm_datap, dfm_data.of_iocbp, dfm_data.list_key, dfm_data.lcatp, code);
         if code ^= 0 then dfm_data.list_key = "";
         if dfm_data.list_key ^= "" then call dfm_util_$print_list (dfm_datap, dfm_data.of_iocbp, dfm_data.list_key);
      end;

      call wrap_up;
      return;

%page;

/* patch_deck - entry to add/delete a hex or octal patch card(s) into a deck
   in a deckfile and if it is a firmware deck create a firmware segment */

patch_deck: entry (P_sci_ptr, P_dfm_infop);

      call setup_part1;
      call setup_part2;
      dfm_data.pd = true;
      dl_patch = false;

      on cleanup call wrap_up;

      call ssu_$arg_count (sci_ptr, nargs);
      if nargs > 0 then do i = 1 to nargs;
         call ssu_$arg_ptr (sci_ptr, i, ap, al);

         if arg = "-brief"
	| arg = "-bf" then dfm_data.bf_sw = true;	/* user doesn't want unnecessary nessages */

         else if arg = "-deckfile" | arg = "-df" then do;
	  i = i + 1;
	  call ssu_$arg_ptr (sci_ptr, i, ap, al);
	  if al = 0 then
	     call complain (dfm_datap, wrapup, code, "obtaining ""-deckfile"" specification.", "");
	  else deckfile_path = arg;
         end;

         else if arg = "-delete" | arg = "-dl" then dl_patch = true;

         else if deck_tb_patched = "" then deck_tb_patched = arg;

         else call complain (dfm_datap, wrapup, error_table_$bad_arg, "only one deck may be patched");
      end;

      if deck_tb_patched = "" then do;
         call complain (dfm_datap, print, error_table_$noarg,
	"A search key for deck to be patched is required", "");

         query_message = "Enter a key or partial key to specify the deck to be patched.";
         query_info.explanation_len = length (rtrim (query_message));
         query_info.explanation_ptr = addr (query_message);
         call command_query_ (query_info_ptr, user_reply, pname,
	"Enter <key of deck to be patched>: ");

         deck_tb_patched = user_reply;

      end;


      call ssu_$get_temp_segment (sci_ptr, "temp buffer", dfm_data.bptr); /* get temp seg for temp buffer */
      call ssu_$get_temp_segment (sci_ptr, "catalog keys", dfm_data.dfkp); /* get temp seg for deckfile keys */
      call ssu_$get_temp_segment (sci_ptr, "list catalog", dfm_data.lcatp); /* get temp segs for list catalog */

      df_keys.n_entries = 0;				/* initialy set to 0 entries */
      lcata.n_entries = 0;

      dfm_data.deckfile_sw = true;			/* deckfile is required */

      call get_files;

      call dfm_util_$get_cata (dfm_datap, dfm_data.fiocb_ptr, "ls.cata.ifad.list", dfm_data.lcatp, dfm_data.lksp, code);
      if code ^= 0 then
         call complain (dfm_datap, wrapup, code, "can't get list catalog", "");

      call dfm_util_$find_key (dfm_datap, dfm_data.fiocb_ptr,
       deck_tb_patched, dfm_data.dfkp, code);
      if code ^= 0 then
         call complain (dfm_datap, wrapup, code, "attempting to find keys for ^a", deck_tb_patched);

      term = false;

      if df_keys.n_entries > 1 then do j = 1 to df_keys.n_entries while (^term);
         call command_query_$yes_no (yes_sw, 0, pname, "^d^2s entries matched the key given",
	"key given matched ^d entries.^/ Entry ^d is ^a - Is this the deck to be patched?",
	df_keys.n_entries, j, df_keys.key (j));

         if yes_sw then do;
	  term = true;
	  j = j - 1;				/* adjust to correct value */
         end;
      end;

      else j = 1;

      if j > df_keys.n_entries & ^term then
         call complain (dfm_datap, wrapup, 0, "There is no file to be patched", "");
      deck_tb_patched = df_keys.key (j);

      term = false;
      if ^dl_patch then
         do i = lbound (dfm_data.opatches, 1) to hbound (dfm_data.opatches, 1) while (^term);

         query_message = "Patch type may either be delete, chex, rhex or octal.";
         query_info.explanation_len = length (rtrim (query_message));
         query_info.explanation_ptr = addr (query_message);
         call command_query_ (query_info_ptr, user_reply, pname, "Enter patch type: ");

         if user_reply = "delete"
	| user_reply = "dl" then dl_patch, term = true;

         else if user_reply = "octal"
	| user_reply = "mask" then do;
	  ascii_cardp = addr (dfm_data.opatches (i));
	  o_patch = " ";
	  o_patch.type = user_reply;

	  query_message = "Enter the octal address of this patch.";
	  query_info.explanation_len = length (rtrim (query_message));
	  query_info.explanation_ptr = addr (query_message);
	  call command_query_ (query_info_ptr, user_reply, pname,
	   "Enter beginning address: ");
	  o_patch.add = user_reply;

	  query_message = "Enter the patches. Consecutive locations maybe separated by a (,) up to 10 patches";
	  query_info.explanation_len = length (rtrim (query_message));
	  query_info.explanation_ptr = addr (query_message);
	  call command_query_ (query_info_ptr, user_reply, pname, "Enter patch data: ");
	  o_patch.p_fld = user_reply;
	  call ioa_$rsnnl ("^6a ^5a^[60a^;^3x^57a^]^12x",
	   patch_word, patch_length, convert (add_pic, o_patch.add),
	   o_patch.type, (o_patch.type = "mask"), o_patch.p_fld);
	  call command_query_$yes_no (yes_sw, 0, pname,
	   "Is this patch correct", "Patch entered: ^/^a^/Is this correct?  ",
	   patch_word);
	  if yes_sw then string (opatches (i)) = patch_word;
	  else i = i - 1;
	  call command_query_$yes_no (yes_sw, 0, pname,
	   "MORE PATCHES?", "Are there anymore patches?");
	  if ^yes_sw then term = true;
	  patch_ptr = addr (dfm_data.opatches);
	  npatches = i;
         end;


         else if user_reply = "chex"
	| user_reply = "rhex" then do;
	  ascii_cardp = addr (dfm_data.hpatches (i));
	  h_patch = " ";
	  h_patch.type = user_reply;
	  query_message = "Enter the hex address of this patch.";
	  query_info.explanation_len = length (rtrim (query_message));
	  query_info.explanation_ptr = addr (query_message);
	  call command_query_ (query_info_ptr, user_reply, pname, "Enter address: ");
	  h_patch.add = "0000";
	  substr (h_patch.add, 5 - length (user_reply)) = user_reply;

	  query_message = "Enter the hex patch for this location.";
	  query_info.explanation_len = length (rtrim (query_message));
	  query_info.explanation_ptr = addr (query_message);
	  call command_query_ (query_info_ptr, user_reply, pname, "Enter patch data: ");
	  h_patch.inst = "0000";
	  substr (h_patch.inst, 5 - length (user_reply)) = user_reply;
	  call ioa_$rsnnl ("^4a  ^4a^5x^4a^61x", patch_word, patch_length,
	   h_patch.add, h_patch.type, h_patch.inst);
	  call command_query_$yes_no (yes_sw, 0, pname,
	   "Is this patch correct", "Patch entered ^/^a^/Is this correct?  ",
	   patch_word);
	  if yes_sw then string (dfm_data.hpatches (i)) = patch_word;
	  else i = i - 1;
	  call command_query_$yes_no (yes_sw, 0, pname,
	   "MORE PATCHES?", "Are there anymore patches?");
	  if ^yes_sw then term = true;
	  patch_ptr = addr (dfm_data.hpatches);
	  npatches = i;
         end;
      end;

      if dl_patch then npatches = 0;

      call dfm_util_$find_dkend (dfm_datap, deck_tb_patched, patch_ptr, npatches, code);
      if code ^= 0 then
         call complain (dfm_datap, wrapup, code, "attempting to patch file ^a", deck_tb_patched);

      call dfm_util_$insert_deck (dfm_datap, dfm_data.fiocb_ptr,
       dfm_data.lcatp, length (unspec (lcata)), "ls.cata.ifad.list");

      call dfm_util_$detach_file (dfm_datap, dfm_data.liocb_ptr);
      dfm_data.liocb_ptr = iox_$user_output;
      dfm_data.terminal_out = true;

      dfm_data.list_key = "ls." || rtrim (deck_tb_patched);

      call dfm_util_$find_key (dfm_datap, dfm_data.fiocb_ptr, dfm_data.list_key, dfm_data.lcatp, code);
      if code ^= 0 then
         call complain (dfm_datap, wrapup, code, "attempting to find keys for ^a", dfm_data.list_key);

      call dfm_util_$print_list (dfm_datap, dfm_data.fiocb_ptr, rtrim (lcata.key (1)));

      call wrap_up;
      return;


%page;

/* pi_handler - entry called by ssu_'s pi handler */

pi_handler: entry (P_sci_ptr);

      sci_ptr = P_sci_ptr;
      dfm_infop = ssu_$get_info_ptr (sci_ptr);
      dfm_datap = dfm_info.dfm_data_ptr;
      call wrap_up;
      return;



%page;

/* quit - entry to quit the request loop and exit the ssu envirnoment */

quit: entry (P_sci_ptr, P_dfm_infop);

      call setup_part1;

      call wrap_up;
      call ssu_$abort_subsystem (sci_ptr);
      return;



%page;


/* add name - int proc to add a name onto the current deckfile of list file */

add_name: proc (aname);

dcl  aname char (*);


      if dfm_data.deckfile_sw then do;
         call hcs_$chname_file (dkf_dir (1), dkf_entry (1), "", rtrim (aname) || ".deckfile", code);
         if code ^= 0 & code ^= error_table_$segnamedup then
	  call complain (dfm_datap, wrapup, code, "adding name ^a^/^-to ^a>^a",
	   rtrim (aname) || ".deckfile", dfm_data.dir, dfm_data.entry);

         if ^dfm_data.bf_sw & code = 0 then
	  call complain (dfm_datap, print, 0, "added name ^a^/^-to ^a>^a",
	   rtrim (aname) || ".deckfile", dfm_data.dir, dfm_data.entry);

         call hcs_$chname_file (lsf_dir, lsf_entry, "", rtrim (aname) || ".list", code);
         if code ^= 0 & code ^= error_table_$segnamedup then
	  call complain (dfm_datap, wrapup, code, "adding name ^a^/^-to ^a>^a",
	   rtrim (aname) || ".list", lsf_dir, lsf_entry);

         if ^dfm_data.bf_sw & code = 0 then
	  call complain (dfm_datap, print, 0, "added name ^a^/^-to ^a>^a",
	   rtrim (aname) || ".list", lsf_dir, lsf_entry);
      end;
   end add_name;

%page;

/* file_deck - internal proc to file a deck into a deckfile */

file_deck: proc (fptr, dlen);

dcl  dlen fixed bin (21);
dcl  fptr ptr;

      if dfm_data.lft
       & cata.n_entries = 0 then do;
         call dfm_util_$get_cata (dfm_datap, dfm_data.fiocb_ptr, "cata." || rtrim (dfm_data.cat_key),
	dfm_data.catp, dfm_data.cksp, code);
         if code ^= 0 then call complain (dfm_datap, wrapup, code,
	   "Attempting to do a get catalog for cata.^a", rtrim (dfm_data.cat_key));
      end;

      call dfm_util_$make_key (dfm_datap);		/* produce insertion key */

      call dfm_util_$insert_deck (dfm_datap, dfm_data.fiocb_ptr,
       fptr, dlen, dfm_data.current_key);		/* copy current deck into deckfile */

      call dfm_util_$update_list (dfm_datap, data_list_type); /* add current deck entry to listing file */

   end file_deck;


%page;

/* get_files internal proc to attach & open files depending on the operation performed. */

get_files: proc ();


/* attach and open tandd_deck_file */

      if dfm_data.deckfile_sw then do;
         if deckfile_path ^= "" then do;
	  if deckfile_path = "-working_dir"
	   | deckfile_path = "-wd" then
	     deckfile_path = rtrim (dir) || deckfile;

	  else if deckfile_path = "-system"
	   | deckfile_path = "-sys" then
	     deckfile_path = system_dir || deckfile;

	  call expand_pathname_ (deckfile_path, dkf_dir (1), dkf_entry (1), code);
	  if code ^= 0 then call complain (dfm_datap, wrapup, code,
	      "encountered while expanding path ^a", deckfile_path);
         end;
         else if dfm_info.deckfile_dir ^= "" then do;
	  dkf_dir (1) = dfm_info.deckfile_dir;
	  dkf_entry (1) = dfm_info.deckfile_entry;
         end;
         else do;
	  dkf_dir (1) = dfm_data.dir;
	  dkf_entry (1) = "tandd_deck_file";
         end;


         call dfm_util_$find_file (dfm_datap, dkf_dir (1), dkf_entry (1));

         dfm_data.dir = dkf_dir (1);
         dfm_data.entry = dkf_entry (1);

         if dfm_data.list then vfile_open_mode = Keyed_sequential_input;
         else vfile_open_mode = Keyed_sequential_update;
         call dfm_util_$open_file (dfm_datap, "dk_file_sw",
	"vfile_ " || rtrim (dkf_dir (1)) || ">" || rtrim (dkf_entry (1)), vfile_open_mode, dfm_data.fiocb_ptr);

      end;


/* attach and open tandd_deck_files for merging */

      else if dfm_data.mdf then do;
         do i = lbound (dkf_path, 1) to hbound (dkf_path, 1) while (dkf_path (i) ^= "");
	  call expand_pathname_ ((dkf_path (i)), dkf_dir (i), dkf_entry (i), code);
	  if code ^= 0 then call complain (dfm_datap, wrapup, code,
	      "encountered while expanding path ^a", dkf_path (i));

	  if dkf_path (i) ^= "" then do;
	     call dfm_util_$open_file (dfm_datap, "dkf_sw" || ltrim (char (i)),
	      "vfile_ " || rtrim (dkf_dir (i)) || ">" || rtrim (dkf_entry (i)),
	      Keyed_sequential_input, dfm_data.dkf_iocbp (i));
	  end;
         end;

         if of_path ^= "" then do;
	  call expand_pathname_ (of_path, of_dir, of_entry, code);
	  if code ^= 0 then call complain (dfm_datap, wrapup, code,
	      "encountered while expanding path ^a", of_path);
         end;

         else if dfm_info.deckfile_dir ^= "" then do;
	  of_dir = dfm_info.deckfile_dir;
	  of_entry = dfm_info.deckfile_entry;
         end;

         else do;
	  of_dir = dfm_data.dir;
	  of_entry = "tandd_deck_file";
         end;


         call dfm_util_$find_file (dfm_datap, of_dir, of_entry);

         dfm_data.dir = of_dir;
         dfm_data.entry = of_entry;

         call dfm_util_$open_file (dfm_datap, "of_sw",
	"vfile_ " || rtrim (of_dir) || ">" || of_entry,
	Keyed_sequential_update, dfm_data.of_iocbp);
      end;


/* attach and open copy tape using the "tape_nstd_" io module */

      if dfm_data.attach_copy then do;			/* only attach copy if indicated */
         call dfm_util_$open_file (dfm_datap, "copy_sw",
	rtrim (c_att_desc) || " -write", Sequential_output, dfm_data.ciocb_ptr);
      end;


/* attach and open listing file */


      if (dfm_data.deckfile_sw | dfm_data.mdf)
       & ^dfm_data.terminal_out then do;

         if of_dir ^= "" then lsf_dir = of_dir;
         else if dkf_dir (1) ^= "" then lsf_dir = dkf_dir (1);
         else if dfm_info.deckfile_dir ^= "" then lsf_dir = dfm_info.deckfile_dir;
         else lsf_dir = dfm_data.dir;
         lsf_entry = "deckfile.list";

         call dfm_util_$find_file (dfm_datap, lsf_dir, lsf_entry);

         if ^dfm_data.mdf & ^dfm_data.list then
	  call dfm_util_$open_file (dfm_datap, "list_sw",
	   rtrim ("vfile_ " || rtrim (lsf_dir) || ">" || rtrim (lsf_entry) || " -extend"),
	   Stream_input_output, dfm_data.liocb_ptr);

         else if dfm_data.mdf | dfm_data.list then
	  call dfm_util_$open_file (dfm_datap, "list_sw",
	   rtrim ("vfile_ " || rtrim (lsf_dir) || ">" || rtrim (lsf_entry)), Stream_output, dfm_data.liocb_ptr);

      end;

/* attach and open tape using the "tape_nstd_" io module */

      if dfm_data.lft then
         call dfm_util_$open_file (dfm_datap, "tape_sw", dfm_data.t_att_desc, Sequential_input, dfm_data.tiocb_ptr);



   end get_files;


%page;

/* setup_part1 - internal proc to set variables required by all entries */

setup_part1: proc;

      sci_ptr = P_sci_ptr;
      dfm_infop = P_dfm_infop;
      dfm_datap = dfm_info.dfm_data_ptr;
      dfm_data.infop = dfm_infop;
      dfm_data.sci_ptr = sci_ptr;
      pname = ssu_$get_subsystem_and_request_name (sci_ptr);
   end;

%page;

/* setup_part2 - internal proc to initialize variables required by some entries */

setup_part2: proc;


      dfm_info.flags.request_active = true;
      call date_time_ (clock (), dfm_data.time_string);	/* Convert date and time. */
      dfm_data.gtime_string = date_time_$format ("^yc^my^dm", clock (), "system_zone", "system_lang");
      dfm_data.dir = get_wdir_ ();			/* Get working directory. */

      dfm_data.bptr = null;
      dfm_data.catp = null;
      dfm_data.ciocb_ptr = null;
      dfm_data.dcatp = null;
      dfm_data.dfkp = null;

      do i = lbound (dfm_data.dkf_iocbp, 1) to hbound (dfm_data.dkf_iocbp, 1);
         dfm_data.dkf_iocbp (i) = null;
      end;

      dfm_data.fiocb_ptr = null;
      dfm_data.hbuff_p = null;
      dfm_data.lbuff_p = null;
      dfm_data.lcatp = null;
      dfm_data.liocb_ptr = null;
      dfm_data.mca_wksp = null;
      dfm_data.mcatp = null;
      dfm_data.of_iocbp = null;
      dfm_data.tiocb_ptr = null;

      dfm_data.dd = false;
      dfm_data.allow_0_cksum = false;
      dfm_data.attach_copy = false;
      dfm_data.cat_build = false;
      dfm_data.cd_sw = false;
      dfm_data.copy_at_eof = false;
      dfm_data.deckfile_sw = false;
      dfm_data.finished = false;
      dfm_data.eot = false;
      dfm_data.first_deck = false;
      dfm_data.first_write = false;
      dfm_data.firmware_sw = false;
      dfm_data.fnp_tape = false;
      dfm_data.hdr_sw = true;
      dfm_data.lfd = false;
      dfm_data.lft = false;
      dfm_data.list = false;
      dfm_data.one_eof = false;
      dfm_data.mdf = false;
      term = false;
      dfm_data.terminal_out = false;

      deck_tb_patched = "";
      deckfile_path = "";
      dfm_data.current_key = "";
      dfm_data.cat_key = "";
      dfm_data.list_key = "";
      dfm_data.tape_name = "";
      dfm_data.crec = 0;
      dfm_data.denno = 0;
      dfm_data.fnp_key = 0;
      n_diskettes_tb_read = 0;
      dfm_data.cfile = 1;				/* set first file number */
      dfm_data.pfile = 1;				/* set first file number */
      dfm_data.page_no = dfm_info.page_number;		/* and the page number */
      dkf_dir = "";
      dkf_entry = "";
      dkf_dir = "";
      dkf_entry = "";
      dkf_path = "";
      of_dir = "";
      of_entry = "";
      of_path = "";

      query_info_ptr = addr (query_info);
      query_info.yes_or_no_sw = false;
      query_info.version = query_info_version_6;
      query_info.suppress_name_sw = false;
      query_info.suppress_spacing = false;
      query_info.cp_escape_control = "11"b;
      query_info.literal_sw = false;
      query_info.prompt_after_explanation = true;
      query_info.padding = false;
      query_info.status_code = 0;
      query_info.question_iocbp, query_info.answer_iocbp = null ();
      query_info.repeat_time = 0;

   end;

%page;

/* wrap_up - int proc to perform request clean up */

wrap_up: proc ();
      if ^dfm_info.flags.request_active then return;
      dfm_info.page_number = dfm_data.page_no;		/* save page number if needed later */
      if dfm_data.liocb_ptr ^= null & ^dfm_data.terminal_out then
         call dfm_util_$detach_file (dfm_datap, dfm_data.liocb_ptr);
      dfm_data.liocb_ptr = null;

      if dfm_data.ciocb_ptr ^= null then
         call dfm_util_$detach_file (dfm_datap, dfm_data.ciocb_ptr);
      dfm_data.ciocb_ptr = null;

      do i = lbound (dfm_data.dkf_iocbp, 1) to hbound (dfm_data.dkf_iocbp, 1);
         if dfm_data.dkf_iocbp (i) ^= null then
	  call dfm_util_$detach_file (dfm_datap, dfm_data.dkf_iocbp (i));
         dfm_data.dkf_iocbp (i) = null;
      end;

      if dfm_data.fiocb_ptr ^= null then
         call dfm_util_$detach_file (dfm_datap, dfm_data.fiocb_ptr);
      dfm_data.fiocb_ptr = null;

      if dfm_data.of_iocbp ^= null then
         call dfm_util_$detach_file (dfm_datap, dfm_data.of_iocbp);
      dfm_data.of_iocbp = null;

      if dfm_data.tiocb_ptr ^= null then
         call dfm_util_$detach_file (dfm_datap, dfm_data.tiocb_ptr);
      dfm_data.tiocb_ptr = null;

      if dfm_data.lbuff_p ^= null then
         free dfm_data.lbuff_p -> lbuff in (free_area);
      dfm_data.lbuff_p = null;

      if dfm_data.hbuff_p ^= null then
         free dfm_data.hbuff_p -> hbuff in (free_area);
      dfm_data.hbuff_p = null;

      if dfm_data.m_attached then do;
         if ^mca_status.maj & mca_sub.data_p then
	  call mca_$read_data (dfm_data.mca_ioi_idx, dfm_data.mca_wksp,
	   max_words_to_rd, rl, "0"b, 0);
         call dfm_util_$mca_detach (dfm_datap);
      end;

      if dfm_data.bptr ^= null then
         call ssu_$release_temp_segment (sci_ptr, dfm_data.bptr);
      dfm_data.bptr = null;

      if dfm_data.catp ^= null then
         call ssu_$release_temp_segment (sci_ptr, dfm_data.catp);
      dfm_data.catp = null;

      if dfm_data.dcatp ^= null then
         call ssu_$release_temp_segment (sci_ptr, dfm_data.dcatp);
      dfm_data.dcatp = null;

      if dfm_data.dfkp ^= null then
         call ssu_$release_temp_segment (sci_ptr, dfm_data.dfkp);
      dfm_data.dfkp = null;

      if dfm_data.mca_wksp ^= null then
         call ssu_$release_temp_segment (sci_ptr, dfm_data.mca_wksp);
      dfm_data.mca_wksp = null;

      if dfm_data.lcatp ^= null then
         call ssu_$release_temp_segment (sci_ptr, dfm_data.lcatp);
      dfm_data.lcatp = null;

      if dfm_data.mcatp ^= null then
         call ssu_$release_temp_segment (sci_ptr, dfm_data.mcatp);
      dfm_data.mcatp = null;

      dfm_data.finished = true;
      dfm_info.flags.request_active = false;

   end;


%page;



%include dfm_info;
%page;
%include dfm_data;
%page;
%include iox_modes;
%page;
%include mca_diskette;
%page;
%include query_info;
%page;
%include sub_err_flags;


   end dfm_;
