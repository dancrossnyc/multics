/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1989                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1986 *
        *                                                         *
        *********************************************************** */

/****^  HISTORY COMMENTS:
  1) change(86-08-21,Fakoury), approve(86-08-21,MCR7515),
     audit(87-01-07,Farley), install(87-01-08,MR12.0-1263):
     Originally coded 0682 by Rick Fakoury for MR12.
  2) change(87-01-13,Fakoury), approve(87-01-13,MCR7515),
     audit(87-01-14,Martinson), install(87-01-14,MR12.0-1278):
     PBF to correct a missing blank else statement in ck_applic.
  3) change(87-01-22,Fakoury), approve(87-01-22,MCR7515),
     audit(87-01-22,Martinson), install(87-01-23,MR12.0-1291):
     Fixed a problem encountered merging a deckfile that contained a patch.
  4) change(88-05-30,Fakoury), approve(90-10-03,MCR8147),
     audit(90-10-03,Parisek), install(90-10-25,MR12.4-1049):
     to Fixed a bug in the merging of a deleted file.
  5) change(89-02-06,Fakoury), approve(90-10-03,MCR8147),
     audit(90-10-03,Parisek), install(90-10-25,MR12.4-1049):
     to to increase block count size and to allow a tape copy to be run
     without using a deck_file or list segment.
  6) change(89-06-01,Fakoury), approve(90-10-03,MCR8147),
     audit(90-10-03,Parisek), install(90-10-25,MR12.4-1049):
     to to increase the size of att_desc from 64 to 181 for TR21336.
  7) change(90-10-30,Fakoury), approve(90-11-28,MCR8219),
     audit(90-11-28,Schroth), install(90-11-28,MR12.4-1051):
     PBF correction to previous installation: correct and cleanup logic in
     ck_applic internal proc.
                                                   END HISTORY COMMENTS */

/* format: style4,ifthenstmt,ifthen,ind3,ll125,lineconind1 */
dfm_util_: proc ();

      return;					/* not a valid entry */


/* AUTOMATIC */

dcl  at_bot bit (1);
dcl  att_desc char (181);
dcl  bcard bit (540);				/* binary card */
dcl  bcnt fixed bin (18);				/* block count */
dcl  bcwp ptr;					/* block cont word p */
dcl  bit_count fixed bin (24);
dcl  c_rtrycnt fixed bin;				/* copy retry count */
dcl  cbcwp ptr;					/* current block cont word ptr */
dcl  cden char (5);					/* copy density */
dcl  code fixed bin (35);
dcl  cx fixed bin;					/* catalog index */
dcl  cvp ptr;					/* convert ptr */
dcl  cvp1 ptr;					/* cpnvert ptr hold */
dcl  dk_end bit (1);
dcl  dk_type char (6);
dcl  dkend_card char (80);
dcl  ename char (32);				/* entry name */
dcl  file_found bit (1);
dcl  first_patch bit (1);
dcl  first_rcd bit (1);				/* first record */
dcl  glrp ptr;					/* gcos log rec ptr */
dcl  glrbp ptr;					/* gcos logical record block ptr */
dcl  gki (20) bit (36);
dcl  gprp ptr;					/* gcos physical record ptr */
dcl  header_key char (24) varying;
dcl  hbuff_len fixed bin (21);			/* header buffer length */
dcl  i fixed bin;
dcl  id_ld bit (1);
dcl  ident_buf (40) bit (36) aligned;			/* load buffer */
dcl  info (20) bit (36);
dcl  info_ptr ptr;
dcl  iocbp ptr;
dcl  j fixed bin;
dcl  k fixed bin;
dcl  lbuff_len fixed bin (21);			/* line buffer length */
dcl  line_count fixed bin;
dcl  lx fixed bin;					/* load index */
dcl  m fixed bin;
dcl  merge_key char (24) varying;
dcl  mode fixed bin;
dcl  mvp ptr;					/* move ptr */
dcl  nbcwp ptr;					/* new blk cont wrd ptr */
dcl  new_iocbp ptr;
dcl  npatches fixed bin;				/* num of patches */
dcl  nwds fixed bin;				/* num of words */
dcl  obj_card_found bit (1);
dcl  ocardp ptr;					/* octal card ptr */
dcl  old_iocbp ptr;
dcl  patch_key char (24) varying;
dcl  pbuf_size fixed bin (21);			/* patch buffer size */
dcl  pptr ptr;					/* patch ptr */
dcl  psz fixed bin;					/* pad size */
dcl  px fixed bin;					/* patch index */
dcl  rcode fixed bin (35);
dcl  rec_len fixed bin (21);
dcl  rtrycnt fixed bin;
dcl  scode fixed bin (35);
dcl  segp ptr;
dcl  svp ptr;
dcl  sw_name char (64);
dcl  t_stat bit (12) aligned;
dcl  term bit (1);
dcl  type fixed bin (2);
dcl  user_access fixed bin (5);
dcl  v_patch bit (1);				/* valid patch */
dcl  wcatp ptr;
dcl  wksp ptr;
dcl  work_key char (24) varying;
dcl  yes_sw bit (1);


/* BUILTINS */

dcl  addr builtin;
dcl  addrel builtin;
dcl  after builtin;
dcl  before builtin;
dcl  bin builtin;
dcl  char builtin;
dcl  convert builtin;
dcl  currentsize builtin;
dcl  fixed builtin;
dcl  index builtin;
dcl  hbound builtin;
dcl  lbound builtin;
dcl  length builtin;
dcl  ltrim builtin;
dcl  null builtin;
dcl  ptr builtin;
dcl  rel builtin;
dcl  rtrim builtin;
dcl  string builtin;
dcl  substr builtin;
dcl  translate builtin;
dcl  unspec builtin;
dcl  verify builtin;


/* CONSTANTS */

dcl  bcd_dkend bit (72) int static options (constant) init
      ("532020202020202442254524"b3);			/* "$      dkend" in bcd */
dcl  bcd_media_code fixed bin (4) int static options (constant) init (2);
dcl  bcd_obj bit (78) int static options (constant) init
      ("53202020202020462241252363"b3);			/* "$      object" in bcd */
dcl  binary_media_code fixed bin (4) int static options (constant) init (1);
dcl  bof fixed bin int static options (constant) init (-1); /* beginning of file */
dcl  buf_size fixed bin (21) int static options (constant) init (4 * 1024); /* 1k buffer is plenty */
dcl  current_ring fixed bin int static options (constant) init (-1);
dcl  density (5) char (5) int static options (constant) init
      ("d6250", "d1600", "d800", "d556", "d200");

dcl  false bit (1) int static options (constant) init ("0"b);
dcl  fnp_355_edit_name char (4) int static options (constant) init ("0300");
dcl  fnp_355_type char (4) int static options (constant) init ("6600");
dcl  fnp_18x_edit_name char (4) int static options (constant) init ("2000");
dcl  fnp_6670_type char (4) int static options (constant) init ("6670");
dcl  fmt1 char (53) int static options (constant) init
      ("^[^5-^12s^; ^[^6x^1s^;^6a^]  ^4a  ^4a  ^2a/^2a/^2a  ");
dcl  fmt2 char (33) int static options (constant) init
      ("^[^6a  ^6a   ^2a^s^;^3s^4a^2-^]^]");
dcl  fmt3 char (62) int static options (constant) init
      ("^-^[    ^[^;^[yes^;no ^]^]^;^2s^64t^24a   ^2d   ^6o    ^8d^]^/");
dcl  g_label bit (72) int static options (constant) init	/* = "ge  600 btl " in bcd */
      ("272520200600002022634320"b3);

dcl  hdra char (18) int static options (constant) init ("Edit  Deck    Assm");
dcl  hdrb char (42) int static options (constant) init
      ("N__a_m_e  T__y_p_e    D__a_t_e");
dcl  hdra1 char (5) int static options (constant) init ("Ident");
dcl  hdrb1 char (46) int static options (constant) init
      ("C__o_d_e    M__o_d_e_l   R__e_v._");
dcl  hdrb2 char (12) int static options (constant) init ("T__y_p_e");
dcl  hdrb3 char (111) int static options (constant) init
      ("S__e_a_r_c_h K__e_y         C__o_m_p  O__f_f_s_e_t  L__e_n_g_t_h (_B__y_t_e_s)_");
dcl  hdra2 char (2) int static options (constant) init ("SS");
dcl  hdra3 char (40) int static options (constant) init
      ("Record             Location       Record");
dcl  hdra4 char (7) int static options (constant) init ("Multics");
dcl  hdrb4 char (30) int static options (constant) init
      ("A__p_p_l_i_c_a_b_l_e");

dcl  max_retrys fixed bin int static options (constant) init (10);
dcl  mpcbot bit (36) int static options (constant) init ("444723224663"b3);

dcl  NL char (1) int static options (constant) init ("
");
dcl  no_chase_sw fixed bin (1) int static options (constant) init (0);
dcl  no_type fixed bin (2) int static options (constant) init (-1);

dcl  print bit (1) int static options (constant) init ("0"b);
dcl  rec_cont_wrd bit (36) int static options (constant) init
      ("000016000200"b3);
dcl  sys_dir char (21) int static options (constant) init
      (">system_library_tandd");
dcl  true bit (1) int static options (constant) init ("1"b);

dcl  whitespace char (2) int static options (constant) init /* TAB and SPACE */
      ("	 ");
dcl  wrapup bit (1) int static options (constant) init ("1"b);


/* BASED and STRUCTURES */


dcl  1 bcw based (bcwp) aligned,
       (2 bsn fixed bin (18),
       2 blk_size fixed bin (18)) unsigned unaligned;

dcl  bit_buf bit (rec_len * 9) based (gprp);

dcl  1 cur_bcw like bcw aligned based (cbcwp);

dcl  data_move char (dfm_data.dlen * 4) based (dfm_data.bptr);

dcl  1 catalog based (c_ptr) aligned,
       2 n_entries fixed bin,
       2 key (1 refer (catalog.n_entries)) char (24);

dcl  free_area area based (get_system_free_area_ ());

dcl  1 glr based (glrp) aligned like gc_log_rec;

dcl  glrb bit (glr.rcw.rsize * 36) based (glrbp);

dcl  1 gpr based (gprp) aligned like gc_phy_rec;


dcl  id_bbuf bit (108) based (cvp);


dcl  1 new_bcw like bcw aligned based (nbcwp);

dcl  1 o_card based (ocardp) aligned,			/* template for an object card */
       (2 pad1 char (15),
       2 library char (6),				/* col 16 - either "hmpcj1" or "htnd  " */
       2 ld_type char (1),				/* col 22, module type */
       2 ss_type char (1),				/* col 23, subsystem type */
       2 pad2 char (3),
       2 m_applic char (1),				/* Multics applicability, non blank means not applicable */
       2 pad3 char (15),
       2 model char (6),				/* for hmpcj1 decks, controller model # */
       2 version char (6),				/* for hmpcj1 decks, model version # */
       2 pad4 char (5),
       2 assem char (1),				/* "m" for mpc assembler, "g" for gmap */
       2 call_name char (6),				/* module call name, or gecall name */
       2 ttl_date char (6),				/* date module assembled */
       2 edit_name char (4),				/* module edit name */
       2 pad5 char (4)) unaligned;



dcl  1 p_blk aligned int static,			/* patch card image storage */
       2 p_cnt fixed bin,				/* number of valid patches */
       2 p_card (200) char (80);			/* patch card image */

dcl  1 r_card based (dfm_data.cptr) aligned,		/* template for a binary card image */
       (2 type bit (12),				/* card type */
       2 count fixed bin (5),				/* number of wds controlled */
       2 ld_add bit (18),				/* loading address */
       2 pad (psz) bit (36),
       2 data (r_card.count) bit (36),
       2 nxt_c_wd bit (36)) unaligned;			/* to get nxt control wd */

dcl  1 rsi like rs_info aligned;			/* auto copy of record status info */

dcl  1 wcata based (wcatp),				/* working catalog */
       2 n_entries fixed bin,				/* number of catalog entries */
       2 key (1 refer (wcata.n_entries)) char (24);
						/* entry search keys */


/* EXTERNAL ENTRIES */

dcl  add_char_offset_ entry (ptr, fixed bin (21)) returns (ptr) reducible;
dcl  bcd_to_ascii_ entry options (variable);
dcl  command_query_$yes_no entry () options (variable);
dcl  dfm_$complain entry () options (variable);
dcl  get_system_free_area_ entry () returns (ptr);
dcl  gload_ entry (ptr, ptr, fixed bin (18), ptr, fixed bin (35));
dcl  gload_$allow_zero_checksums entry entry (char (*), char (*), char (*), ptr, ptr, fixed bin (18), ptr, fixed bin (35));
dcl  hcs_$get_link_target entry (char (*), char (*), char (*), char (*), fixed bin (35));
dcl  hcs_$get_user_effmode entry (char (*), char (*), char (*), fixed bin, fixed bin (5), fixed bin (35));
dcl  hcs_$initiate entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
dcl  hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
dcl  hcs_$set_bc_seg entry (ptr, fixed bin (24), fixed bin (35));
dcl  hcs_$status_minf entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24), fixed bin (35));
dcl  (ioa_, ioa_$ioa_switch, ioa_$rs) entry () options (variable);
dcl  iox_$attach_name entry (char (*), ptr, char (*), ptr, fixed bin (35));
dcl  iox_$close entry (ptr, fixed bin (35));
dcl  iox_$control entry (ptr, char (*), ptr, fixed bin (35));
dcl  iox_$delete_record entry (ptr, fixed bin (35));
dcl  iox_$detach_iocb entry (ptr, fixed bin (35));
dcl  iox_$open entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
dcl  iox_$position entry (ptr, fixed bin, fixed bin (21), fixed bin (35));
dcl  iox_$put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35));
dcl  iox_$read_record entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
dcl  iox_$rewrite_record entry (ptr, ptr, fixed bin (21), fixed bin (35));
dcl  iox_$seek_key entry entry options (variable);
dcl  iox_$write_record entry (ptr, ptr, fixed bin (21), fixed bin (35));
dcl  mca_$attach_mca entry (char (*), fixed bin (71), fixed bin, fixed bin (35));
dcl  mca_$detach_mca entry (fixed bin, fixed bin (35));
dcl  mca_$diskette_read entry (fixed bin, char (*), fixed bin, ptr, fixed bin (21), fixed bin (21), bit (72), fixed bin (35));
dcl  mca_$read_data entry (fixed bin, ptr, fixed bin (21), fixed bin (21), bit (72), fixed bin (35));
dcl  opr_query_ entry () options (variable);
dcl  tolts_alm_util_$ascii_to_bcd_ entry (char (*), bit (*));

/* EXTERNAL */

dcl  error_table_$fatal_error fixed bin (35) ext static;
dcl  error_table_$noentry fixed bin (35) ext static;
dcl  error_table_$no_file fixed bin (35) ext static;
dcl  error_table_$no_record fixed bin (35) ext static;
dcl  error_table_$end_of_info fixed bin (35) ext static;
dcl  error_table_$tape_error fixed bin (35) ext static;

/* PARAMETERS */

dcl  P_dfm_datap ptr;

%page;


/* ck_applic - entry to check for current deck Multics Applicability. If a deck is appicable, "1"b is returned.
   If deck is the first deck of an "itr" a catalog build is begun */

ck_applic: entry (P_dfm_datap) returns (bit (1));


      dfm_datap = P_dfm_datap;

      ocardp = addr (dfm_data.obj_card);
      if o_card.m_applic ^= " " then do;		/* only take deck if Multics applicable */
         if o_card.library = "hmpcj1" then		/* if itr deck */
	  if id_blk.type = "itr" then			/* space to nxt file */
	     call space_file ();			/* space to nxt file */
	  else if o_card.ss_type = "h" then		/* space over heals files */
	     call space_file ();			/* space to nxt file */
         return (false);				/* return false */
      end;
      else do;					/* Multics applicable */
         if o_card.library = "hmpcj1" then do;		/* if itr, mdr or firmware deck */
	  if id_blk.type = "mdr" then			/* if current deck an mdr */
	     if dfm_data.firmware_sw & ^dfm_data.deckfile_sw then do;
	        dfm_data.eot = true;			/* and we are only loading firmware, thats it */
	        return (false);
	     end;
	     else ;
	  else if id_blk.type ^= "itr"		/* else if firmware deck */
	   & dfm_data.firmware_sw then		/* and not just loading deckfile */
	     call ld_fw_deck (dfm_data.bptr);		/* go load core image for BOS */
	  if ^dfm_data.first_deck then do;		/* if first deck of current file */
	     dfm_data.cat_build, dfm_data.first_deck = true; /* set flag so we don't come back */
	     cata.n_entries = 0;			/* reset number of catalog entries */
	     dfm_data.cat_key = id_blk.type || ".";	/* form suffix part of catalog key */
	     if id_blk.type = "mdr" then do;		/* if building mdr catalog */
	        if o_card.ss_type = "t" then dfm_data.sstype = "tape "; /* tape catalog */
	        else if o_card.ss_type = "p" then dfm_data.sstype = "print"; /* printer catalog */
	        else if o_card.ss_type = "c" then dfm_data.sstype = "card "; /* card catalog */
	        else if o_card.ss_type = "d" then dfm_data.sstype = "disk "; /* disk catalog */
	        else do;
		 call dfm_$complain (dfm_datap, print, 0, /* unknown type */
		  "Unknown subsystem type (col 23) on $ object card ^/Last $ object card image is: ^/""^a""",
		  dfm_data.obj_card);

		 dfm_data.first_deck = false;		/* check next $ object card */
		 return (true);
	        end;
	        dfm_data.cat_key = rtrim (dfm_data.cat_key) || dfm_data.sstype; /* complete mdr catalog key */
	     end;
	  end;
         end;
      end;
      return (true);				/* return true */

%page;


/* copy_eof - entry to write end of file mark on copy tape */

copy_eof: entry (P_dfm_datap);


      dfm_datap = P_dfm_datap;

      call iox_$control (dfm_data.ciocb_ptr, "write_eof", null, code);
      dfm_data.copy_at_eof = true;			/* set copy eof flag */

      return;


%page;


/* delete_deck - entry to delete a deck in the T & D deckfile */


delete_deck: entry (P_dfm_datap, work_key, rcode);


      dfm_datap = P_dfm_datap;

      rcode = 0;					/* reset abort flag */

      call iox_$seek_key (dfm_data.fiocb_ptr, work_key, rec_len, code); /* set key for deletion */
      if code ^= 0 then do;
         rcode = code;
         return;
      end;

      call iox_$delete_record (dfm_data.fiocb_ptr, code);
      if code ^= 0 then do;
         rcode = code;
         return;
      end;

      term = false;
      allocate lbuff in (free_area) set (dfm_data.lbuff_p);
      lbuff = "";
      dfm_data.list_key = "ls." || rtrim (work_key);
      call iox_$seek_key (dfm_data.fiocb_ptr, dfm_data.list_key, rec_len, code);
      if code ^= 0 then call dfm_$complain (dfm_datap, wrapup, code,
	"attempting to seek key ^a ", dfm_data.list_key);
      call iox_$read_record (dfm_data.fiocb_ptr, dfm_data.lbuff_p, rec_len, lbuff_len, code);
      if code ^= 0 then call dfm_$complain (dfm_datap, wrapup, code,
	"attempting to read a keyed record ^a", dfm_data.list_key);

      call ioa_$rs ("^a^86t^7a ^14a^/", lbuff, lbuff_len,
       substr (lbuff, 1, index (lbuff, rtrim (work_key)) + length (rtrim (work_key))),
       "DELETED", substr (dfm_data.time_string, 1, 14));

      call insert_deck (dfm_datap, dfm_data.fiocb_ptr, dfm_data.lbuff_p, lbuff_len, (dfm_data.list_key));
      free dfm_data.lbuff_p -> lbuff in (free_area);
      dfm_data.lbuff_p = null;
      return;

%page;

/* detach_file -  entry to close and  detach file */

detach_file: entry (P_dfm_datap, iocb_ptr);

dcl  iocb_ptr ptr;

      dfm_datap = P_dfm_datap;

      call iox_$close (iocb_ptr, code);
      call iox_$detach_iocb (iocb_ptr, code);
      iocb_ptr = null;


      return;
%page;


/* find_dkend - entry to find either a $deckend card or a patch card */

find_dkend: entry (P_dfm_datap, work_key, pptr, npatches, rcode);


      dfm_datap = P_dfm_datap;

      abort, dk_end, end_file, first_rcd, first_patch = false; /* reset flags */
      id_ld, obj_card_found = false;
      p_blk.p_cnt = 0;				/* initialize patch count */
      cvp, cvp1 = null;

      call iox_$seek_key (dfm_data.fiocb_ptr, work_key, rec_len, code);
      if code ^= 0 then do;
         rcode = 0;
         return;
      end;
      unspec (rsi) = "0"b;
      rsi.version = rs_info_version_2;
      call iox_$control (dfm_data.fiocb_ptr, "record_status", addr (rsi), code);
      if code ^= 0 then do;
         rcode = 0;
         return;
      end;
      bcwp, gprp, mvp = rsi.record_ptr;
      cbcwp = dfm_data.bptr;
      pbuf_size = rec_len;

      do while (^dk_end);				/* loop until entire deck is read in */
         if ^first_rcd then do;			/* if first record of deck */
	  bcnt = gpr.bcw.bsn;			/* load block serial number */
	  first_rcd = true;
         end;
         else do;					/* if not first record, check BSN */
	  bcnt = bcnt + 1;				/* increment our block count */
	  if gpr.bcw.bsn ^= bcnt then			/* something wrong here */
	     call dfm_$complain (dfm_datap, wrapup, error_table_$fatal_error,
	      "Block serial number error at record ^d, file ^d ^/Block serial number was ^d, S/B ^d",
	      dfm_data.crec, dfm_data.cfile, gpr.bcw.bsn, bcnt);
         end;
         glrp = addr (gpr.gc_phy_rec_data (1));		/* get pointer to first logical record */
         nwds = 0;

         do while (nwds < gpr.bcw.blk_size);		/* iterate through all logical records */

	  if glr.rcw.media_code = 2 then do;		/* bcd card image */
	     glrbp = addr (glr.gc_log_rec_data);

	     if substr (glrb, 1, 78) = bcd_obj then do;	/* object card */
	        call bcd_to_ascii_ (glrb, dfm_data.obj_card); /* convert to ascii */
	        obj_card_found = true;		/* indicate that we have gotten object card */
	        ocardp = addr (dfm_data.obj_card);
	     end;

	     else do;
	        if o_card.library = "hmpcj1" & ^id_ld then do; /* if hmpcj1 lib and we haven't been here */
		 id_ld = true;			/* set flag so we don't come back */
		 if cvp1 = null then cvp1 = cvp;	/* if only 1 binary card */
		 call load_ident;			/* load ident block */
	        end;

	        if ck_patch (glrb) then do;		/* go check for patch card */
		 if ^first_patch then do;
		    dfm_data.dlen = fixed (rel (glrp)) - fixed (rel (mvp));
		    data_move = mvp -> data_move;	/* move data from begin to patch */
		    mvp = addrel (mvp, dfm_data.dlen);
		    dfm_data.bptr = addrel (dfm_data.bptr, dfm_data.dlen);
		    first_patch = true;
		 end;

		 call command_query_$yes_no (yes_sw, 0, "Patch Deck",
		  "A patch card has been found in the deck. Do you want to retain it?",
		  "Patch: ^/^a^/Found in deck ^a.^/Do you wish to retain it?", dfm_data.ascii_card, work_key);

		 if yes_sw then do;
		    dfm_data.dlen = glr.rcw.rsize + 1;	/* move the patch */
		    data_move = mvp -> data_move;
		    mvp = addrel (mvp, dfm_data.dlen);
		    dfm_data.bptr = addrel (dfm_data.bptr, dfm_data.dlen);
		 end;

		 else do;
		    mvp = addrel (mvp, glr.rcw.rsize + 1); /* adjust the ptr past the patch */
		    call remove_patch;
		 end;
	        end;


	        if substr (glrb, 1, 72) = bcd_dkend then do; /* dkend card */
		 call bcd_to_ascii_ (glrb, dkend_card); /* convert to ascii */
		 dk_end = true;
		 if ^first_patch then do;
		    dfm_data.dlen = fixed (rel (glrp)) - fixed (rel (mvp));
		    data_move = mvp -> data_move;
		    mvp = addrel (mvp, dfm_data.dlen);
		    dfm_data.bptr = addrel (dfm_data.bptr, dfm_data.dlen);
		 end;
		 if npatches > 0 then do i = 1 to npatches;
		    if dfm_data.opatches (i).type = "octal"
		     | dfm_data.opatches (i).type = "mask " then do;
		       dfm_data.opatches (i).dtime = dfm_data.gtime_string;
		       dfm_data.opatches (i).label = o_card.edit_name;
		       call tolts_alm_util_$ascii_to_bcd_ (string (dfm_data.opatches (i)), bcard);
		       if ^ck_patch (bcard) then
			call dfm_$complain (dfm_datap, wrapup, error_table_$fatal_error,
			 "patch: ^/^a^/ is an invalid patch");
		       bcard = rec_cont_wrd || substr (bcard, 1, 504);
		       mvp = addr (bcard);
		       dfm_data.dlen = 15;
		       data_move = mvp -> data_move;
		       dfm_data.bptr = addrel (dfm_data.bptr, dfm_data.dlen);
		    end;
		    else if substr (dfm_data.hpatches (i).type, 2) = "hex" then do;
		       dfm_data.hpatches (i).dtime = dfm_data.gtime_string;
		       dfm_data.hpatches (i).lbl = o_card.edit_name;
		       dfm_data.hpatches (i).prg_id = string (id_blk.revision);
		       dfm_data.hpatches (i).rev = string (id_blk.revision);
		       dfm_data.hpatches (i).lbl = o_card.edit_name;
		       call tolts_alm_util_$ascii_to_bcd_ (string (dfm_data.hpatches (i)), bcard);
		       if ^ck_patch (bcard) then
			call dfm_$complain (dfm_datap, wrapup, error_table_$fatal_error,
			 "patch: ^/^a^/ is an invalid patch", dfm_data.opatches (i));
		       bcard = rec_cont_wrd || substr (bcard, 1, 504);
		       mvp = addr (bcard);
		       dfm_data.dlen = 15;
		       data_move = mvp -> data_move;
		       dfm_data.bptr = addrel (dfm_data.bptr, dfm_data.dlen);
		    end;
		 end;
		 substr (dkend_card, 67, 6) = dfm_data.gtime_string;
		 call tolts_alm_util_$ascii_to_bcd_ (dkend_card, bcard);
		 bcard = rec_cont_wrd || substr (bcard, 1, 504);
		 mvp = addr (bcard);
		 dfm_data.dlen = 15;
		 data_move = mvp -> data_move;
		 dfm_data.bptr = addrel (dfm_data.bptr, dfm_data.dlen);
		 nbcwp = dfm_data.bptr;
		 new_bcw.blk_size = (fixed (rel (dfm_data.bptr)) - 1) - fixed (rel (cbcwp));
		 if new_bcw.blk_size > 308 then do;
		    cur_bcw.blk_size = 308;
		    new_bcw.blk_size = new_bcw.blk_size - 308;
		    new_bcw.bsn = cur_bcw.bsn + 1;
		 end;
		 else cur_bcw.blk_size = new_bcw.blk_size;
		 call insert_deck (dfm_datap, dfm_data.fiocb_ptr,
		  ptr (dfm_data.bptr, 0), fixed (rel (dfm_data.bptr)) * 4, work_key);
		 if o_card.library = "hmpcj1"
		  & id_blk.type ^= "itr" then
		    call ld_fw_deck (ptr (dfm_data.bptr, 0));
		 term = false;
		 dfm_data.list_key = "ls." || rtrim (work_key);
		 allocate lbuff in (free_area) set (dfm_data.lbuff_p);
		 lbuff = "";
		 call iox_$control (dfm_data.fiocb_ptr, "record_status", addr (rsi), code);
		 call iox_$seek_key (dfm_data.fiocb_ptr, rtrim (dfm_data.list_key), rec_len, code);
		 if code ^= 0 then call dfm_$complain (dfm_datap, wrapup, code,
		     "attempting to seek key ^a ", rtrim (dfm_data.list_key));
		 call iox_$read_record (dfm_data.fiocb_ptr, dfm_data.lbuff_p, rec_len, lbuff_len, code);
		 if code ^= 0 then call dfm_$complain (dfm_datap, wrapup, code,
		     "attempting to read a keyed record ^a", rtrim (dfm_data.list_key));
		 call ioa_$rs ("^a^86t^2d^90t^6o^103t^8d^[  PATCHED  ^14a^;^s]^/", lbuff, lbuff_len,
		  substr (lbuff, 1, index (lbuff, rtrim (work_key)) + length (rtrim (work_key))),
		  addr (rsi.descriptor) -> rs_desc.comp_num, fixed (rel (rsi.record_ptr), 18),
		  rsi.record_length, (p_blk.p_cnt > 0), substr (dfm_data.time_string, 1, 20));
		 call insert_deck (dfm_datap, dfm_data.fiocb_ptr, dfm_data.lbuff_p,
		  lbuff_len, (dfm_data.list_key));
		 free dfm_data.lbuff_p -> lbuff in (free_area);
		 dfm_data.lbuff_p = null;
		 if p_blk.p_cnt > 0 then
		    call put_patch;
		 term = true;
	        end;
	     end;
	  end;

	  else if glr.rcw.media_code = 1 then		/* binary card image */
	     if ^obj_card_found then			/* but no $ object card yet */
	        call dfm_$complain (dfm_datap, wrapup, error_table_$fatal_error,
	         "Binary card image preceeds $ object card at record ^d, file ^d",
	         dfm_data.crec, dfm_data.cfile);

	     else do;
	        cvp1 = cvp;				/* save ptr to last logical record */
	        cvp = glrp;				/* save ptr to current logical record */
	     end;
	  else call dfm_$complain (dfm_datap, wrapup,	/* not a bcd or binary card image */
	        error_table_$fatal_error, "Card type ^o detected at record ^d, file ^d",
	        glr.rcw.media_code, dfm_data.crec, dfm_data.cfile);
	  nwds = nwds + glr.rcw.rsize + 1;		/* increment number of words */
	  glrp = addrel (glrp, currentsize (glr));	/* set next logical record */
         end;
         dfm_data.crec = dfm_data.crec + 1;		/* increment current record number */
         gprp = addrel (gprp, currentsize (gpr));		/* append next block */
         cbcwp = addrel (cbcwp, bcw.blk_size + 1);
         bcwp = gprp;
      end;

      return;


%page;


/* find_file - entry to find the correct file */

find_file: entry (P_dfm_datap, d_name, e_name);

dcl  e_name char (*);
dcl  d_name char (*);

      dfm_datap = P_dfm_datap;

      type = no_type;				/* set to novalid value */
      file_found = false;
      yes_sw = false;
      term = false;

      do while (^term);
         call hcs_$status_minf (d_name, e_name, no_chase_sw, type, bit_count, code);
         if code ^= 0 then do;			/* err or noentry */
	  if code ^= error_table_$noentry then		/* error */
	     call dfm_$complain (dfm_datap, wrapup, code, "looking for ^a in ^a", e_name, d_name);
	  else do;				/* no entry */
	     if accessible (d_name, "", SMA_ACCESS_BIN) then do; /* dir access? */
	        call command_query_$yes_no (yes_sw, 0, "Find File",
	         "^a does not exist in ^a. Do you wish to create it?",
	         "File ^a does not exist in ^a. ^/Create it? ", e_name, d_name);
	        if yes_sw then do;			/* okey - create */
		 file_found, term = true;
		 if index (ename, ".list") ^= 0 then	/* if creating new list */
		    dfm_data.page_no = 0;
	        end;

	        else if d_name ^= sys_dir then		/* haven't tried >firmware */
		 d_name = sys_dir;			/* try it */
	        else goto exit_ff_loop;		/* user doesn't want any of these choices */
	     end;
	     else goto exit_ff_loop;			/* not enough access */
	  end;
         end;

         else if type = Directory then do;		/* entry exists - dir (msf) */
	  if accessible (d_name, "", SMA_ACCESS_BIN) then /* dir access? */
	     if d_name = sys_dir then			/* sys dir - ask */
	        if accessible (d_name, e_name, RW_ACCESS_BIN)
	         & ^dfm_data.list then do;
		 call command_query_$yes_no (yes_sw, 0, "Find File",
		  "^a does not exist in working dir. Use the one found in ^a?",
		  "You have access to modify ^a in ^a.^/Use it?", e_name, sys_dir);
		 if ^yes_sw then goto exit_ff_loop;
	        end;
	  file_found, term = true;			/* must be ok */
         end;

         else if type = Link then do;			/* entry exist & link */
	  call hcs_$get_link_target (d_name, e_name,	/* get dir & entry */
	   d_name, e_name, code);

	  if code ^= 0 then do;
	     if code ^= error_table_$noentry then	/* error */
	        call dfm_$complain (dfm_datap, wrapup, code,
	         "chasing link to ^a", d_name, e_name);

	     else if accessible (d_name, "", SMA_ACCESS_BIN) then do;
	        call command_query_$yes_no (yes_sw, 0, "Find File",
	         "^a is a link in your working dir.^/Use the one found in ^a?",
	         "You have access to create ^a in ^a. ^/Create it?", e_name, d_name);
	        if yes_sw then do;			/* okey - got it */
		 file_found, term = true;
		 if index (ename, ".list") ^= 0 then	/* if creating new list */
		    dfm_data.page_no = 0;
	        end;
	        else goto exit_ff_loop;
	     end;
	     else goto exit_ff_loop;			/* need more access */
	  end;

	  else if accessible (d_name, e_name, RW_ACCESS_BIN)
	   & ^dfm_data.list then do;
	     call command_query_$yes_no (yes_sw, 0, "Find File",
	      "^a is a link in your working dir. ^/Use the one found in ^a?",
	      "You have access to modify ^a in ^a. ^/Use it?", e_name, d_name);
	     if yes_sw then				/* okey - got it */
	        file_found, term = true;
	     else goto exit_ff_loop;			/* suer doesn't want it */
	  end;
	  else file_found, term = true;		/* must be ok */
         end;

         else if type = Segment			/* single segment deckfile */
	& index (e_name, ".list") = 0 then do;
	  if d_name = sys_dir then			/* sys dir - ask */
	     if accessible (d_name, e_name, RW_ACCESS_BIN)
	      & ^dfm_data.list then do;
	        call command_query_$yes_no (yes_sw, 0, "Find File",
	         "^a does not exist in working dir. Use the one found in ^a?",
	         "You have access to modify ^a in ^a.^/Use it?", e_name, sys_dir);
	        if ^yes_sw then goto exit_ff_loop;
	     end;
	  file_found, term = true;			/* must be ok */
         end;

         else if index (e_name, ".list") ^= 0
	& accessible (d_name, e_name, RW_ACCESS_BIN) then /* must be a listing seg */

	  file_found, term = true;

         else goto exit_ff_loop;			/* seg not valid */
      end;

exit_ff_loop:
      if ^file_found then				/* can't continue */
         call dfm_$complain (dfm_datap, wrapup, error_table_$no_file,
	"using ^a>^a", rtrim (d_name), rtrim (e_name));

      if ^dfm_data.bf_sw & file_found then
         call dfm_$complain (dfm_datap, print, 0, "using ^a>^a", rtrim (d_name), rtrim (e_name));

      return;

%page;


/* find_key - entry to find all search keys, given search key head */

find_key: entry (P_dfm_datap, iocbp, c_name, c_ptr, rcode);


dcl  c_ptr ptr;
dcl  c_name char (24) varying;

      dfm_datap = P_dfm_datap;

      rcode = 0;
      ename = c_name;				/* copy search name */
      info_ptr = addr (info);
      unspec (info) = "0"b;
      common_sl_info.version = sl_info_version_0;
      common_sl_info.list_type = 1;			/* set to reuse subset */
      common_sl_info.output_descriptors = true;		/* want descriptors */
      common_sl_info.array_limit = 1;			/* 1 element array */
      common_sl_info.desc_arrayp = null;		/* let vfile_ allocate area for storage */
      hi_sl_info.first_head (1).length, hi_sl_info.last_head (1).length = length (rtrim (ename));
      hi_sl_info.first_head (1).kptr, hi_sl_info.last_head (1).kptr = addr (ename);
      call iox_$control (iocbp, "select", info_ptr, code);	/* get select info */
      if code ^= 0 then do;				/* problem with select */
         rcode = code;
         return;
      end;
      call iox_$position (iocbp, bof, 0, code);		/* position to beginning of file */

      if code ^= 0 then do;				/* problem with select */
         rcode = code;
         return;
      end;
      catalog.n_entries = common_sl_info.count;		/* copy number of descriptors */
      gk_info_ptr = addr (gki);			/* set info ptr */
      unspec (gki) = "0"b;				/* clear structure first */
      gk_info.input_desc = true;			/* using input descriptors */
      gk_info.reset_pos = true;			/* don't change position */
      do i = 1 to common_sl_info.count;			/* find each key */
         gk_info.descrip = desc_array (i);		/* insert each descriptor */
         call iox_$control (iocbp, "get_key", gk_info_ptr, code);
         if code ^= 0 then do;			/* error */
	  rcode = code;
	  return;
         end;
         catalog.key (i) = gk_info.key;			/* copy key */
      end;
      common_sl_info.list_type = 0;			/* set to reuse subset */
      common_sl_info.subset_no = 0;
      common_sl_info.array_limit = 0;			/* 0 element array */
      common_sl_info.desc_arrayp = null;		/* let vfile_ allocate area for storage */
      call iox_$control (iocbp, "select", info_ptr, code);	/* reset current subset */
      rcode = 0;					/* If we get this far insure 0 code is returned */

      return;					/* thats it folks */

%page;


/* get_cata - entry to search a deckfile for a catalog. If one exists
   it is read out, else a new one is initialized. */

get_cata: entry (P_dfm_datap, iocbp, cata_name, wcatp, wksp, rcode);

dcl  rec_length fixed bin (21);
dcl  cata_name char (24) varying;


      dfm_datap = P_dfm_datap;

      call iox_$seek_key (iocbp, cata_name, rec_length, code);
      if code ^= 0 then do;
         if code = error_table_$no_record then do;
	  wcata.key = " ";
	  wcata.n_entries = 0;
	  code = 0;
         end;
      end;
      else call iox_$read_record (iocbp, wcatp, rec_length, rec_len, code);
      wksp = addr (wcata.key (1));
      rcode = code;

      return;

%page;


/* insert_deck - entry to insert current deck into the T & D deckfile */

insert_deck: entry (P_dfm_datap, iocbp, bufp, buf_len, work_key);


dcl  bufp ptr;
dcl  buf_len fixed bin (21);


      dfm_datap = P_dfm_datap;

      if ^dfm_data.deckfile_sw & ^dfm_data.mdf then return; /* not using a deckfile - return */

      call iox_$seek_key (iocbp, work_key, rec_length, code); /* set key for insertion */
      if code ^= error_table_$no_record then do;		/* if record already exists */
         if code = 0 then do;				/* check for common itr */
	  call iox_$rewrite_record (iocbp, bufp, buf_len, code); /* write the record */
	  if code ^= 0 then call dfm_$complain (dfm_datap, wrapup, code, /* fatal error - set abort flag */
	      "attempting to rewrite record whose key is ""^a"" to the ^a>^a",
	      work_key, dfm_data.dir, dfm_data.entry);
	  return;
         end;
         else if code ^= 0 then call dfm_$complain (dfm_datap, wrapup, code, /* fatal error - set abort flag */
	   "attempting to rewrite record whose key is ""^a"" to the ^a>^a",
	   work_key, dfm_data.dir, dfm_data.entry);
      end;
      call iox_$write_record (iocbp, bufp, buf_len, code);	/* write the record */
      if code ^= 0 then call dfm_$complain (dfm_datap, wrapup, code, /* fatal error - set abort flag */
	"attempting to write record whose key is ""^a"" to the ^a>^a",
	work_key, dfm_data.dir, dfm_data.entry);


      return;

%page;

/* make_key - entry to make up a key for insertion into the deckfile based on object card info */

make_key: entry (P_dfm_datap);

      dfm_datap = P_dfm_datap;
      ocardp = addr (dfm_data.obj_card);
      dfm_data.current_key = "";			/* initialize key first */

      if dfm_data.fnp_tape then do;			/* make special key for fnp bin deck tapes */
         dfm_data.fnp_key = dfm_data.fnp_key + 1;		/* increment fnp key number */
         dfm_data.current_key = "fnp." || dfm_data.fnp_type || ".pol." || ltrim (char (dfm_data.fnp_key)) || "." ||
	substr (o_card.edit_name, 1, 2);
      end;

      else if lfd then do;
         if index (dfm_data.current_filename, "cata.") ^= 0 then do;
	  dfm_data.current_key = rtrim ("cata.nio." || substr (dfm_data.current_filename, 6));
	  if index (dfm_data.current_filename, "mca") = 0
	   & index (mcata_key_string, dfm_data.current_key) = 0 then do;
	     mcata.n_entries = mcata.n_entries + 1;
	     mcata.key (mcata.n_entries) = dfm_data.current_key;
	  end;
         end;

         else do;
	  dfm_data.current_key = "nio." || rtrim (dfm_data.current_filename);
	  if index (dcata_key_string, dfm_data.current_key) = 0 then do;
	     dcata.n_entries = dcata.n_entries + 1;
	     dcata.key (dcata.n_entries) = dfm_data.current_key;
	  end;
         end;
         return;
      end;

      else if o_card.library = "hmpcj1" then do;		/* if mpc deck */
         if id_blk.type ^= "itr" & id_blk.type ^= "mdr" then/* if firmware deck */
	  dfm_data.current_key = string (id_blk.type_code); /* set firmware identification */
         else dfm_data.current_key = id_blk.type;		/* itr or mdr */
         dfm_data.current_key = rtrim (dfm_data.current_key) || "." || id_blk.ident;
         dfm_data.current_key = rtrim (dfm_data.current_key) || "." || o_card.edit_name;
         dfm_data.current_key = rtrim (dfm_data.current_key) || "." || id_blk.rev; /* set revision */
      end;

      else do;					/* must be htnd deck */
         if o_card.ss_type = "s" then			/* take care of special cases first */
	  dfm_data.current_key = "pas." || substr (o_card.edit_name, 1, 3); /* isolts deck */
         else if o_card.ss_type = "u" then		/* utility deck */
	  dfm_data.current_key = "utl." || o_card.call_name;
         else dfm_data.current_key = o_card.ss_type || "lt." || o_card.call_name; /* most common case */
         return;
      end;

      if index (cata_key_string, dfm_data.current_key) = 0 then do;
         cata.n_entries = cata.n_entries + 1;		/* increment  number of catalog entries */
         cata.key (cata.n_entries) = dfm_data.current_key;	/* and add current entry to catalog */
      end;

      return;

%page;


/* mca_attach - entry to attach an MCA for diskette reads */

mca_attach: entry (P_dfm_datap, mca_id);

dcl  mca_id char (4);


      dfm_datap = P_dfm_datap;

      if dfm_data.m_attached then return;
      call mca_$attach_mca (mca_id, 0, dfm_data.mca_ioi_idx, code);
      if code ^= 0 then
         call dfm_$complain (dfm_datap, wrapup, code, "Attempting to attach mca ^a", mca_id);
      dfm_data.m_attached = true;
      return;


%page;


/* mca_detach - entry to detach an MCA */

mca_detach: entry (P_dfm_datap);


      dfm_datap = P_dfm_datap;

      if ^dfm_data.m_attached then return;
      call mca_$detach_mca (dfm_data.mca_ioi_idx, code);
      if code ^= 0 then
         call dfm_$complain (dfm_datap, print, code, "Attempting to detach the mca", "");
      dfm_data.m_attached = false;

      return;


%page;


/* merge deckfiles - entry to merge two deckfiles */

merge_files: entry (P_dfm_datap, old_iocbp, new_iocbp);


      dfm_datap = P_dfm_datap;

      unspec (rsi) = "0"b;
      rsi.version = rs_info_version_2;
      allocate lbuff in (free_area) set (dfm_data.lbuff_p);
      lbuff = "";

      do i = lbound (list_types, 1) to hbound (list_types, 1);
         dfm_data.list_key = list_types (i);
         call find_key (dfm_datap, old_iocbp, (dfm_data.list_key), dfm_data.lcatp, code);
         if code ^= 0 then dfm_data.list_key = "";
         if dfm_data.list_key ^= "" then do;
	  call get_cata (dfm_datap, old_iocbp, dfm_data.list_key, dfm_data.lcatp, dfm_data.lksp, code);
	  if code ^= 0 then
	     call dfm_$complain (dfm_datap, wrapup, code, "attempting to find catalog for ^a", dfm_data.list_key);
	  do j = 1 to lcata.n_entries;
	     call iox_$seek_key (old_iocbp,		/* get the ls. key entry */
	      rtrim (lcata.key (j)), rec_len, code);
	     if code ^= 0 then
	        call dfm_$complain (dfm_datap, wrapup, code, "attempting to seek key ^a ", lcata.key (j));
	     call iox_$read_record (old_iocbp, dfm_data.lbuff_p, rec_len, lbuff_len, code);
	     if code ^= 0 then
	        call dfm_$complain (dfm_datap, wrapup, code, "attempting to read a keyed record ^a", lcata.key (j));

	     if index (lbuff, "DELETED") = 0
	      & index (lcata.key (j), ".hdr") = 0	/* if not hdr */
	      & index (lcata.key (j), ".P.") = 0 then do; /* or patch headr move data */
	        merge_key = substr (lcata.key (j), verify (lcata.key (j), "ls."));

	        call iox_$seek_key (old_iocbp, merge_key, rec_length, code);
	        if code ^= 0 then
		 call dfm_$complain (dfm_datap, wrapup, code, "attempting to seek key ^a ", merge_key);
	        call iox_$read_record (old_iocbp, dfm_data.bptr, rec_length, rec_len, code);
	        if code ^= 0 then
		 call dfm_$complain (dfm_datap, wrapup, code, "attempting to read a keyed record ^a", merge_key);
	        call insert_deck (dfm_datap, new_iocbp, dfm_data.bptr, rec_len, merge_key);
	        call iox_$control (new_iocbp, "record_status", addr (rsi), code); /* get record position */
	        call ioa_$rs ("^a^86t^2d^5x^6o^4x^8d^/", lbuff, lbuff_len,
	         substr (lbuff, 1, index (lbuff, rtrim (merge_key)) + length (rtrim (merge_key))),
	         addr (rsi.descriptor) -> rs_desc.comp_num, fixed (rel (rsi.record_ptr), 18), rsi.record_length);
	     end;
	     else do;				/* update time & pathname */
	        if after (lcata.key (j), ".hdr") = "1" then /* time */
		 call ioa_$rs ("^a^61tTime - ^a", lbuff, lbuff_len,
		  before (lbuff, "Time"), dfm_data.time_string);
	        else if after (lcata.key (j), ".hdr") = "2" then /* pathname */
		 call ioa_$rs ("^a^51tStored in ^a>^a", lbuff, lbuff_len,
		  before (lbuff, "Stored"), dfm_data.dir, dfm_data.entry);
	     end;

	     call insert_deck (dfm_datap, new_iocbp,	/* write the ls entry */
	      dfm_data.lbuff_p, lbuff_len, (lcata.key (j)));
	  end;
	  call insert_deck (dfm_datap, new_iocbp, dfm_data.lcatp, length (unspec (lcata)), dfm_data.list_key);
         end;
      end;
      free dfm_data.lbuff_p -> lbuff in (free_area);
      dfm_data.lbuff_p = null;

      return;

%page;


/* mount diskette - entry to instruct the operator to mount an MCA diskette */

mount_diskette: entry (P_dfm_datap, diskette_name, header_ptr) returns (bit (1));

dcl  diskette_name char (8) varying;


      dfm_datap = P_dfm_datap;

      opr_query_info.prim = "0 or 1";
      opr_query_info.alt = "unable";
      opr_query_info.r_comment = "";

      term = false;
      do i = 0 to 1 while (^term);
         dfm_data.disk_num = i;
read_diskette_hdr:
         call read_diskette (dfm_datap, "HDR", header_ptr, rec_len, "0"b, code);
         if code = 0 then do;
	  if substr (header.unique_id, 1, 3) = substr (diskette_name, 1, 3) then do;
	     term = true;
	     opr_query_info.q_sw = false;
	     call opr_query_ (addr (opr_query_info),
	      "Reading diskette ^a on drive ^d", header.unique_id, dfm_data.disk_num);
	     return (true);
	  end;
         end;
      end;


      if ^term then do;
ask_opr: call ioa_ ("requesting mount of ^a", diskette_name);
         opr_query_info.q_sw = true;
         opr_query_info.r_comment = "disk # used or unable";
         call opr_query_ (addr (opr_query_info),
	"Please mount diskette ^a and reply with", diskette_name);
         if opr_query_info.answer = "unable" then do;
	  call ioa_ ("unable to mount MCA diskette ^a", diskette_name);
	  return (false);
         end;
         else do;
	  dfm_data.disk_num = convert (dfm_data.disk_num, opr_query_info.answer);
	  if disk_num < 0 | dfm_data.disk_num > 1 then do;
	     call ioa_ ("operator returned incorrect reply - retrying");
	     goto ask_opr;
	  end;
	  else goto read_diskette_hdr;		/* read hdr and display message */
         end;
      end;

      return (false);				/* should never happen */


%page;

/* open_file - entry to attach and open files */

open_file: entry (P_dfm_datap, sw_name, att_desc, mode, iocbp);


      dfm_datap = P_dfm_datap;

      call iox_$attach_name (sw_name, iocbp, att_desc, null, code);
      if code ^= 0 then call dfm_$complain (dfm_datap, wrapup, code, "attaching ^a", sw_name);

      call iox_$open (iocbp, mode, "0"b, code);		/* open per mode */
      if code ^= 0 then call dfm_$complain (dfm_datap, wrapup, code, "opening ^a for ^a", sw_name, iox_modes (mode));

      return;

%page;

/* print_list - entry to generate a listing of the contents of a deckfile */

print_list: entry (P_dfm_datap, iocbp, work_key);


      dfm_datap = P_dfm_datap;

      if ^dfm_data.deckfile_sw & ^dfm_data.mdf then return;

      call iox_$position (iocbp, bof, 0, code);		/* position to beginning of file */
      if index (work_key, ".list") = 0 then
         call find_key (dfm_datap, iocbp, (dfm_data.list_key), dfm_data.lcatp, code);
      else call get_cata (dfm_datap, iocbp, work_key, dfm_data.lcatp, dfm_data.lksp, code);
      if code ^= 0 then
         call dfm_$complain (dfm_datap, wrapup, code, "attempting to find keys for ^a", work_key);

      k = 1;
      line_count = 0;
      allocate hbuff in (free_area) set (dfm_data.hbuff_p);
      allocate lbuff in (free_area) set (dfm_data.lbuff_p);
      hbuff = "";

      do j = 1 to lcata.n_entries;
         lbuff = "";
         call iox_$seek_key (iocbp, rtrim (lcata.key (j)), rec_len, code);
         if code ^= 0 then
	  call dfm_$complain (dfm_datap, wrapup, code, "attempting to seek key ^a ", lcata.key (j));

         call iox_$read_record (iocbp, dfm_data.lbuff_p, rec_len, lbuff_len, code);
         if code ^= 0 then
	  call dfm_$complain (dfm_datap, wrapup, code, "attempting to read a keyed record");

         if index (lcata.key (j), ".hdr") ^= 0 then do;
	  hbuff (k) = "";
	  if k = 1 then do;				/* Need to add page# */
	     dfm_data.page_no = dfm_data.page_no + 1;
	     line_count = 1;
	     call ioa_$rs ("^a,  Page - ^d", lbuff, lbuff_len,
	      before (lbuff, NL), dfm_data.page_no);
	  end;

	  hbuff (k) = rtrim (lbuff);
	  k = k + 1;
         end;
         if dfm_data.terminal_out then lbuff = substr (lbuff, verify (lbuff, whitespace));
         call iox_$put_chars (dfm_data.liocb_ptr, dfm_data.lbuff_p, length (rtrim (lbuff)), code);
         if code ^= 0 then
	  call dfm_$complain (dfm_datap, wrapup, code,
	   "attempting to ^[add to the deckfile.list^;display list output^]",
	   ^dfm_data.terminal_out);

         if k = hbound (hbuff, 1) + 1 then do;
	  call ioa_$ioa_switch (dfm_data.liocb_ptr, "^/");
	  k = 1;
         end;

         line_count = line_count + 1;
         if j < lcata.n_entries
	& lcata.n_entries > 1 then
	  if index (lcata.key (j + 1), ".hdr") = 0
	   & (index (lbuff, "cata") ^= 0 | line_count > 25) then do;
	     line_count = 0;
	     dfm_data.page_no = dfm_data.page_no + 1;
	     call ioa_$rs ("^a,  Page - ^d", hbuff (1), hbuff_len,
	      before (before (hbuff (1), NL), ",  Page"), dfm_data.page_no);

	     do i = lbound (hbuff, 1) to hbound (hbuff, 1);
	        call iox_$put_chars (dfm_data.liocb_ptr, addr (hbuff (i)), length (rtrim (hbuff (i))), code);
	        if code ^= 0 then
		 call dfm_$complain (dfm_datap, wrapup, code,
		  "attempting to ^[write list data^;display list output^]",
		  ^dfm_data.terminal_out);
	     end;
	     call ioa_$ioa_switch (dfm_data.liocb_ptr, "^/");
	  end;
      end;
      free dfm_data.lbuff_p -> lbuff in (free_area);
      dfm_data.lbuff_p = null;
      free dfm_data.hbuff_p -> hbuff in (free_area);
      dfm_data.hbuff_p = null;

      return;

%page;

/* read_deck - entry to read in the next sequential object deck from the tape */

read_deck: entry (P_dfm_datap, end_file, abort);


dcl  (end_file, abort) bit (1);


      dfm_datap = P_dfm_datap;

      at_bot = true;				/* initialize flags */
      abort, dk_end, end_file = false;
      first_rcd, id_ld, obj_card_found = false;
      p_blk.p_cnt = 0;				/* initialize patch count */
      if dfm_data.pfile < dfm_data.cfile then
         dfm_data.pfile = dfm_data.cfile;		/* update listing file designator if necessary */


      gprp = dfm_data.bptr;				/* set initial blk ptr to base of tape buff */
      cvp, cvp1 = null;

      do while (^dk_end);				/* loop until entire deck is read in */
         rtrycnt = 0;				/* reset retries */
retry_rd:
         call iox_$read_record (dfm_data.tiocb_ptr, gprp, buf_size, rec_len, code);
         if code ^= 0 then do;
	  if code ^= error_table_$end_of_info then	/* if not end of file */
	     if code = error_table_$tape_error then do;
	        if at_bot then do;			/* still at bot probably wrong density */
		 dfm_data.denno = dfm_data.denno + 1;	/* increment density number */
		 if dfm_data.denno > hbound (density, 1) then /* can't set it so abort */
		    go to get_stat;
		 call iox_$control (dfm_data.tiocb_ptr, "rewind", null, code);
		 call iox_$control (dfm_data.tiocb_ptr, density (dfm_data.denno), null, code); /* set density */
		 go to retry_rd;			/* and go try again */
	        end;
	        rtrycnt = rtrycnt + 1;		/* increment retry count */
	        if rtrycnt > max_retrys then do;	/* if we have retried max number of times */
get_stat:
		 call iox_$control (dfm_data.tiocb_ptr, "saved_status", addr (t_stat), scode);
		 call dfm_$complain (dfm_datap, wrapup, code,
		  "Tape status = ^4.3b, while reading record ^d, file ^d after 10 retries",
		  t_stat, dfm_data.crec, dfm_data.cfile); /* set abort indicator */
	        end;
	        call iox_$control (dfm_data.tiocb_ptr, "backspace_record", null, code);
	        go to retry_rd;
	     end;
	     else call dfm_$complain (dfm_datap, wrapup, code, /* not a tape error report it and abort */
		 "While reading record ^d, file ^d", dfm_data.crec, dfm_data.cfile);

	  else do;				/* end of file */
	     end_file = true;			/* set eof indicator */
	     dfm_data.cfile = dfm_data.cfile + 1;	/* increment position indicators */
	     dfm_data.crec = 0;
	     return;
	  end;
         end;
         if rec_len = 56 then				/* check for partial hdr label (GCOS EOV) */
	  if substr (bit_buf, 1, 72) = g_label then
	     if substr (bit_buf, 145, 216) = "0"b then do;/* if true, partial hdr label */
	        dfm_data.eot = true;			/* set EOV flags */
	        return;
	     end;
         if ^first_rcd then do;			/* if first record of deck */
	  bcnt = gpr.bcw.bsn;			/* load block serial number */
	  first_rcd = true;
         end;
         else do;					/* if not first record, check BSN */
	  bcnt = bcnt + 1;				/* increment our block count */
	  if gpr.bcw.bsn ^= bcnt then			/* something wrong here */
	     call dfm_$complain (dfm_datap, wrapup, error_table_$fatal_error,
	      "Block serial number error at record ^d, file ^d^/Block serial number was ^d, S/B ^d",
	      dfm_data.crec, dfm_data.cfile, gpr.bcw.bsn, bcnt); /* set abort flag */

         end;
         glrp = addr (gpr.gc_phy_rec_data (1));		/* get pointer to first logical record */
         nwds = 0;

         do while (nwds < gpr.bcw.blk_size);		/* iterate through all logical records */
	  if glr.rcw.media_code = bcd_media_code then do; /* bcd card image */
	     glrbp = addr (glr.gc_log_rec_data);
	     if substr (glrb, 1, 78) = bcd_obj then do;	/* object card */
	        call bcd_to_ascii_ (glrb, dfm_data.obj_card); /* convert to ascii */
	        obj_card_found = true;		/* indicate that we have gotten object card */
	        ocardp = addr (dfm_data.obj_card);
	        if (o_card.edit_name = fnp_18x_edit_name
	         | o_card.edit_name = fnp_355_edit_name)
	         & at_bot then do;			/* get set to build  fnp catalog key */
		 if o_card.edit_name = fnp_18x_edit_name then /* is this an 18x fnp */
		    dfm_data.fnp_type = fnp_6670_type;	/* yes, set type */
		 else if o_card.edit_name = fnp_355_edit_name then /* is it a 355 fnp */
		    dfm_data.fnp_type = fnp_355_type;
		 else call dfm_$complain (dfm_datap, wrapup,
		       error_table_$fatal_error,	/* neither one, can't be fnp tape */
		       "First object deck image has an edit name ^a which is not a valid first deck a binary deck tape",
		       o_card.edit_name);
		 dfm_data.fnp_tape = true;
		 dfm_data.cat_key = "fnp.pol." || dfm_data.fnp_type; /* start catalog key */
		 dfm_data.l_att_desc = rtrim (dfm_data.l_att_desc) || ".fnp." || dfm_data.fnp_type;
	        end;

	     end;
	     else do;				/* must be dkend or patch card */
	        if o_card.library = "hmpcj1" & ^id_ld then do; /* if hmpcj1 lib and we haven't been here */
		 id_ld = true;			/* set flag so we don't come back */
		 if cvp1 = null then		/* if only 1 binary card */
		    cvp1 = cvp;
		 call load_ident;			/* load ident block */
	        end;
	        if substr (glrb, 1, 72) = bcd_dkend then	/* dkend card */
		 dk_end = true;			/* set terminate condition */
	        else if ^ck_patch (glrb) then		/* go check for patch card */
		 call dfm_$complain (dfm_datap, wrapup, error_table_$fatal_error,
		  "BCD card image at record ^d, file ^d is not $ object, $ dkend, or valid patch card:^/""^a""",
		  dfm_data.crec, dfm_data.cfile, dfm_data.ascii_card); /* if error, get out */
	     end;
	  end;
	  else if glr.rcw.media_code = binary_media_code then /* binary card image */
	     if ^obj_card_found then			/* but no $ object card yet */
	        call dfm_$complain (dfm_datap, wrapup, error_table_$fatal_error,
	         "Binary card image preceeds $ object card at record ^d, file ^d", dfm_data.crec, dfm_data.cfile);
	     else do;
	        cvp1 = cvp;				/* save ptr to last logical record */
	        cvp = glrp;				/* save ptr to current logical record */
	     end;
	  else call dfm_$complain (dfm_datap, wrapup,
	        error_table_$fatal_error,		/* not a bcd or binary card image */
	        "Card type ^o detected at record ^d, file ^d", glr.rcw.media_code, dfm_data.crec, dfm_data.cfile);

	  at_bot = false;
	  nwds = nwds + glr.rcw.rsize + 1;		/* increment number of words */
	  glrp = addrel (glrp, currentsize (glr));	/* set next logical record */
         end;
         dfm_data.crec = dfm_data.crec + 1;		/* increment current record number */
         gprp = addrel (gprp, currentsize (gpr));		/* append next block */
      end;
      dfm_data.dlen = fixed (rel (gprp)) + 1;		/* set total deck length in words */

      return;

%page;

/* read_diskette - entry to read a specified diskette file */

read_diskette: entry (P_dfm_datap, filename, data_bufp, total_chars, mstat, rcode);


dcl  mca_buf_size fixed bin (21) init (16 * 1024);
dcl  (current_ptr, data_bufp) ptr;
dcl  filename char (*);
dcl  mstat bit (72);
dcl  ret_len fixed bin (21);
dcl  total_chars fixed bin (21);


      dfm_datap = P_dfm_datap;

      ret_len, total_chars = 0;
      code = 0;
      current_ptr = data_bufp;
      call mca_$diskette_read (dfm_data.mca_ioi_idx, filename,
       dfm_data.disk_num, current_ptr, mca_buf_size, ret_len, mstat, code);
rd_loop:
      rcode = code;
      dfm_data.statp = addr (mstat);
      dfm_data.sub_ptr = addr (mca_status.sub);
      if code ^= 0 then do;
         if mca_status.maj = "0"b & mca_sub.data_p then
	  call mca_$read_data (dfm_data.mca_ioi_idx, current_ptr, mca_buf_size, ret_len, "0"b, 0);
         return;
      end;
      current_ptr = add_char_offset_ (current_ptr, ret_len);
      total_chars = total_chars + ret_len;
      if mca_sub.data_p then do;
         call mca_$read_data (dfm_data.mca_ioi_idx, current_ptr, mca_buf_size, ret_len, mstat, code);
         goto rd_loop;
      end;

      else return;

%page;

/* update_list - entry to add current deck entry to listing file */

update_list: entry (P_dfm_datap, ltype);


dcl  ltype fixed bin (2);


      dfm_datap = P_dfm_datap;
      ocardp = addr (dfm_data.obj_card);
      unspec (rsi) = "0"b;
      rsi.version = rs_info_version_2;
      dfm_data.lib = false;				/* reset lib <switch */
      dfm_data.dtype, dfm_data.sstype = "";

      if dfm_data.fnp_tape then do;			/* if loading fnp bin. deck tape */
         dfm_data.sstype = "pol ";			/* this stands for Partial OnLine */
         dfm_data.dtype = "fnp ";
      end;
      else if dfm_data.lfd then do;
         dfm_data.sstype = "nio";
         dfm_data.dtype = substr (translate (dfm_data.current_disk_name, lc, uc), 1, 3);
      end;


      else if o_card.library = "hmpcj1" then do;		/* mpc library */
         dfm_data.lib = true;				/* set lib switch */
         dfm_data.sstype = substr (o_card.library, 1, 5);
         if id_blk.type ^= "itr" & id_blk.type ^= "mdr" then/* if firmware */
	  dfm_data.dtype = " fw ";
         else substr (dfm_data.dtype, 2, 3) = id_blk.type;	/* set itr or mdr type */
         if dk_type = " fw " & id_blk.type = "mdr" then dfm_data.hdr_sw = true;
         dk_type = dfm_data.dtype;
      end;

      else do;					/* must be htnd library */
         if o_card.ld_type = "m" then dfm_data.dtype = "mast"; /* pas2 master deck */
         else if o_card.ld_type = "s" then dfm_data.dtype = "slav";
         else if o_card.ld_type = "p" then dfm_data.dtype = "prog"; /* program deck */
         else if o_card.ld_type = "r" then dfm_data.dtype = "rloc"; /* relocatable deck */
         else dfm_data.dtype = "data";
         if o_card.ss_type = "p" then dfm_data.sstype = "polt";
         else if o_card.ss_type = "m" then dfm_data.sstype = "molt";

         else if o_card.ss_type = "c" then dfm_data.sstype = "colt";
         else if o_card.ss_type = "h" then dfm_data.sstype = "heal";
         else if o_card.ss_type = "u" then dfm_data.sstype = "util";
         else if o_card.ss_type = "s" then
	  if o_card.m_applic = " " then dfm_data.sstype = "isol";
	  else dfm_data.sstype = "solt";
      end;
      if ^dfm_data.list then				/* if just producing a listing, don't bother */
         call iox_$control (dfm_data.fiocb_ptr, "record_status", addr (rsi), code); /* get record position */

      if dfm_data.lfd then dfm_data.ls_type = "mca";
      else if dfm_data.fnp_tape then dfm_data.ls_type = "fnp";
      else dfm_data.ls_type = "ifad";

      if dfm_data.lib_type ^= dfm_data.sstype then do;
         dfm_data.lib_type = dfm_data.sstype;
         dfm_data.hdr_sw = true;
      end;

      if dfm_data.hdr_sw then call put_hdr ();		/* if we need a header then put it out */
      allocate lbuff in (free_area) set (dfm_data.lbuff_p);
      lbuff = "";

      if dfm_data.lfd then do;
         if index (dfm_data.current_filename, "DIR") ^= 0 then
	  dfm_data.current_filename = substr (dfm_data.current_filename, 6, 8);
         else if index (dfm_data.current_filename, "HDR") ^= 0 then
	  dfm_data.current_filename = substr (dfm_data.current_filename, 1, 7);
         else dfm_data.current_filename = substr (dfm_data.current_filename, 1, 8);
         call ioa_$rs ("^12t ^a ^31t ^a ^42t ^a ^58t ^21a ^86t  ^2d     ^6o    ^8d^/",
	lbuff, lbuff_len, dfm_data.current_filename, dfm_data.edit_date, dfm_data.sstype, dfm_data.current_key,
	addr (rsi.descriptor) -> rs_desc.comp_num, fixed (rel (rsi.record_ptr), 18), rsi.record_length);
      end;


      else call ioa_$rs (fmt1 || fmt2 || fmt3, lbuff, lbuff_len,
	  (ltype = cata_list_type), dfm_data.fnp_tape, o_card.call_name,
	  o_card.edit_name, dfm_data.dtype, substr (o_card.ttl_date, 1, 2),
	  substr (o_card.ttl_date, 3, 2), substr (o_card.ttl_date, 5, 2),
	  dfm_data.lib, id_blk.ident, o_card.model, id_blk.rev, dfm_data.sstype,
	  dfm_data.list, dfm_data.fnp_tape, (o_card.m_applic = " "), dfm_data.current_key,
	  addr (rsi.descriptor) -> rs_desc.comp_num, fixed (rel (rsi.record_ptr), 18), rsi.record_length);

      dfm_data.list_key = "ls." || rtrim (dfm_data.current_key);

      if index (lcata_key_string, dfm_data.list_key) = 0	/* entry not in the cata */
       | lib then do;				/* mpc cata build */
         lcata.n_entries = lcata.n_entries + 1;
         lcata.key (lcata.n_entries) = dfm_data.list_key;
      end;


      call insert_deck (dfm_datap, dfm_data.fiocb_ptr, dfm_data.lbuff_p, lbuff_len, dfm_data.list_key);
      free dfm_data.lbuff_p -> lbuff in (free_area);
      dfm_data.lbuff_p = null;
      if p_blk.p_cnt ^= 0 then			/* if patches exist... */
         call put_patch;				/* list them too */
      if dfm_data.attach_copy then			/* if we are writing copy tape */
         if ltype ^= cata_list_type then		/* and this is not a catalog record */
	  call write_copy ();			/* copy this deck too */

      return;

%page;

/* valid_diskette - entry to verify a diskette as a valid diskette type */

valid_diskette: entry (P_dfm_datap, diskette) returns (bit (1));


dcl  diskette char (8) varying;


      dfm_datap = P_dfm_datap;

      if index (string (valid_diskettes), substr (translate (diskette, lc, uc), 1, 3)) > 0 then return (true);

      else return (false);

%page;

/* accessible - int function that will check the user's access to system gates & data bases */

accessible: proc (dir, entry, lowest_access) returns (bit (1));

dcl  dir char (*);
dcl  entry char (*);
dcl  lowest_access fixed bin (5);

      call hcs_$get_user_effmode (dir, entry, "", current_ring, user_access, code);
      if code ^= 0 then call dfm_$complain (dfm_datap, wrapup, code,
	"attemping to get user access to ^a>^a.", dir, entry);

      if user_access >= lowest_access then return (true);

      else return (false);				/* if we made it - all ok */

   end accessible;

%page;


/* ck_patch - int proc to check a bcd card image for a valid patch card */

ck_patch: proc (bcd_card) returns (bit (1));

dcl  bcd_card bit (*);


      call bcd_to_ascii_ (bcd_card, dfm_data.ascii_card);
      ascii_cardp = addr (dfm_data.ascii_card);
      v_patch = false;				/* reset patch flag */

      if h_patch.type = "chex"
       | h_patch.type = "rhex" then			/* for cs or r/w mem */
         if o_card.assem = "m" then			/* and deck produced with mpc assembler */
	  if h_patch.lbl = o_card.edit_name then	/* if label matches */
	     if h_patch.rev = string (id_blk.revision) then /* and rev matches */
	        v_patch = true;			/* valid hex patch */
      if ^v_patch then				/* if  it wasn't hex patch */
         if o_patch.type = "octal" | o_patch.type = "mask" then
	  v_patch = true;				/* valid octal patch */
      if v_patch then do;				/* if one of the above */
         p_blk.p_cnt = p_blk.p_cnt + 1;			/* increment patch count */

         p_blk.p_card (p_blk.p_cnt) = dfm_data.ascii_card;	/* copy image */
      end;

      return (v_patch);

   end ck_patch;

%page;


/* ld_fw_deck - int proc to load core image of firmware deck into
   a segment named "fw.<ident>.<pgm_name>.<rev>" */

ld_fw_deck: proc (fw_dkp);

dcl  fw_dkp ptr;

      ename = "fw." || id_blk.ident || "." || o_card.edit_name ||
       "." || id_blk.rev;				/* form firmware seg name */
      call hcs_$initiate (dfm_data.dir, ename, "", 0, 0, segp, code); /* attempt to initiate seg */
      if segp = null then do;				/* seg does not exist, create it */
         call hcs_$make_seg (dfm_data.dir, ename, "", 01010b, segp, code);
         if segp = null then				/*  error creating segment */
	  call dfm_$complain (dfm_datap, wrapup, code,
	   "Unable to create ^a>^a", dfm_data.dir, ename);
      end;
      if dfm_data.allow_0_cksum then call gload_$allow_zero_checksums
	("dfm_util_", dfm_data.dir, ename, fw_dkp, segp, 0,
	addr (gload_data), code);			/* load the core image */
      else call gload_ (fw_dkp, segp, 0, addr (gload_data), code); /* load the core image */
      if code ^= 0 then				/* loading error */
         call dfm_$complain (dfm_datap, wrapup, code,
	"^a^/attempting to load core image of ^a>^a", gload_data.diagnostic, dfm_data.dir, ename);

      call hcs_$set_bc_seg (segp, fixed (gload_data.text_len) * 36, code); /* set bit count of fw seg */
      if code ^= 0 then				/* error setting bit count */
         call dfm_$complain (dfm_datap, wrapup, code, "Unable to set bit count of ^a>^a", dfm_data.dir, ename);

   end ld_fw_deck;

%page;

/* load_ident - int proc to load last 2 binary card images of hmpcj1 deck and extract the ident block */

load_ident: proc;


      lx = 0;					/* set initial load index */
      ident_buf = ""b;
      svp = glrp;
      glrp = cvp1;

      do while (glr.rcw.media_code = 1);		/* process only binary cards */
         dfm_data.cptr = addrel (glrp, 1);
         psz = 4;					/* set initial pad size to 4 */
         m = r_card.count;				/* set initial count */
         term = false;

         do while (^term);				/* load all words on card */

	  do i = 1 to r_card.count;
	     ident_buf (lx + i) = r_card.data (i);	/* copy data */
	  end;
	  lx = lx + r_card.count;			/* update load index */
	  if substr (r_card.nxt_c_wd, 1, 12) ^= "2005"b3
	   | m = glr.rcw.rsize - 8 then term = true;	/* all done */

	  else do;
	     dfm_data.cptr = addr (r_card.nxt_c_wd);	/* set for nxt control word */
	     psz = 0;				/* pad size = 0 */
	     m = m + r_card.count;			/* increment counter */
	  end;
         end;

         glrp = addrel (glrp, currentsize (glr));		/* set next logical record */
         if glr.rcw.media_code ^= binary_media_code
	& glr.rcw.media_code ^= bcd_media_code then	/* ck for new blk */
	  if glrp -> gpr.bcw.bsn = bcnt then		/* if looks like bcw */
	     glrp = addrel (glrp, 1);			/* go to nxt word */
      end;

/* we have all of the ident block loaded, now lets find the words we are interested in */

      term = false;

      do i = lbound (ident_buf, 1) to hbound (ident_buf, 1) while (^term);
         if ident_buf (i) = mpcbot then			/* if word = "mpcbot" in bcd */
	  term = true;
      end;

      cvp = addr (ident_buf (i - 10));			/* cvp pts to beginning of ident block */
      call bcd_to_ascii_ (id_bbuf, dfm_data.id_buf);	/* convert ident block to ascii */
      glrp = svp;

   end load_ident;


%page;


/* put_hdr - int proc to output a listing page header */

put_hdr: proc ();

      if lcata.n_entries = 0 & (dfm_data.deckfile_sw | dfm_data.mdf) then do;
         call get_cata (dfm_datap, dfm_data.fiocb_ptr,
	"ls.cata." || dfm_data.ls_type || ".list", dfm_data.lcatp, dfm_data.lksp, code);
         if code ^= 0 then
	  call dfm_$complain (dfm_datap, wrapup, code, "can't get list catalog", "");
      end;

      allocate hbuff in (free_area) set (dfm_data.hbuff_p);
      hbuff = "";

      if dfm_data.lfd then do;

         call ioa_$rs ("^| ^- Library - MCA ^61tTime - ^a", /* page# added during output */
	hbuff (1), hbuff_len, dfm_data.time_string);

         call ioa_$rs ("^10t Contents of MCA Diskette - ^a^51tStored in ^a>^a ",
	hbuff (2), hbuff_len, dfm_data.current_disk_name, dfm_data.dir, dfm_data.entry);

         call ioa_$rs ("^9t File ^24t DATE ^45t SS ^66t Record ^87t Location ^96t Record", hbuff (3), hbuff_len);

         call ioa_$rs ("^9t N__a_m_e ^20t M__o_d_i_f_i_e_d ^32t _t_y_p_e ^65t S__e_a_r_c_h K__e_y ^82t C__o_m_p      O__f_f_s_e_t    L__e_n_g_t_h (B__y_t_e_s)",
	hbuff (4), hbuff_len);
      end;

      else do;
         call ioa_$rs ("^|^-^a ^[POL^s^;^a ^] ^61tTime - ^a", /* page# added during output */
	hbuff (1), hbuff_len, "Library -", dfm_data.fnp_tape, o_card.library, dfm_data.time_string);

         call ioa_$rs ("^a ^[FNP ^a ^a^1s^;^2s^a^] ^a^51tStored in ^a>^a",
	hbuff (2), hbuff_len, "Contents of", dfm_data.fnp_tape, dfm_data.fnp_type, "Binary Deck Tape",
	"ITR, Firmware And Diagnostic (IFAD) Tape", dfm_data.tape_name, dfm_data.dir, dfm_data.entry);

         call ioa_$rs (" ^[ Call^;     ^]   ^a     ^[^a^2-^s^;^s ^a^2-^]^-^[ ^[^a^]^;^2s      ^a^]",
	hbuff (3), hbuff_len, (o_card.call_name ^= "" & ^dfm_data.fnp_tape), hdra,
	dfm_data.lib, hdra1, hdra2, dfm_data.list, ^dfm_data.fnp_tape, hdra4, hdra3);


         call ioa_$rs (" ^[ N__a_m_e^;     ^]   ^a    ^[^a^s^;^s^a^2-^]^-^[^[^a^]^;^2s    ^a^]",
	hbuff (4), hbuff_len, (o_card.call_name ^= "" & ^dfm_data.fnp_tape), hdrb,
	dfm_data.lib, hdrb1, hdrb2, dfm_data.list, ^dfm_data.fnp_tape, hdrb4, hdrb3);
      end;

      if dfm_data.deckfile_sw | dfm_data.mdf then do i = lbound (hbuff, 1) to hbound (hbuff, 1);
         header_key = "ls." || rtrim (dfm_data.lib_type) || "." || rtrim (dfm_data.dtype) || ".hdr" || ltrim (char (i));
         call insert_deck (dfm_datap, dfm_data.fiocb_ptr, addr (hbuff (i)),
	length (rtrim (hbuff (i))), header_key);
         if index (lcata_key_string, header_key) = 0 then do;
	  lcata.n_entries = lcata.n_entries + 1;
	  lcata.key (lcata.n_entries) = header_key;
         end;
      end;

      free dfm_data.hbuff_p -> hbuff in (free_area);
      dfm_data.hbuff_p = null;
      dfm_data.hdr_sw = false;			/* do header only once */

   end put_hdr;

%page;

/* put_patch - int proc to add patch card images to listing file */

put_patch: proc;


      allocate lbuff in (free_area) set (dfm_data.lbuff_p);
      lbuff = "";
      call ioa_$rs ("^/The following patch cards are contained in the above deck:^/", lbuff, lbuff_len);
      patch_key = "ls." || rtrim (work_key) || ".P.0";

      do i = 0 to p_blk.p_cnt;			/* output all patches */
         cx = index (lcata_key_string, rtrim (patch_key)) / 24 + 1; /* see if patch exists */
         if cx = 1 then do;				/* no patch found */

	  cx = index (lcata_key_string, rtrim (work_key)) / 24 + 1; /* find entry for deck */
	  lcata.n_entries = lcata.n_entries + 1;	/* bump total */
	  do j = lcata.n_entries to cx + i + 1 by -1;	/* make a slot */
	     lcata.key (j) = lcata.key (j - 1);
	  end;
	  lcata.key (cx + i + 1) = rtrim (patch_key);	/* insert new key in slot */
         end;
         else lcata.key (cx) = rtrim (patch_key);		/* key there - overwrite it */
         call insert_deck (dfm_datap, dfm_data.fiocb_ptr, dfm_data.lbuff_p,
	length (rtrim (lbuff)), rtrim (patch_key));

         if i < p_blk.p_cnt then do;			/* set up for next patch */
	  call ioa_$rs ("^5t^a^/", lbuff, lbuff_len, rtrim (p_blk.p_card (i + 1)));
	  patch_key = "ls." || rtrim (work_key) || ".P." || ltrim (char (i + 1));
         end;
      end;

      free dfm_data.lbuff_p -> lbuff in (free_area);
      dfm_data.lbuff_p = null;
      p_blk.p_cnt = 0;				/* initialize count */

   end put_patch;


%page;

/* remove_patch - int proc to remove a patch from deckfile */

remove_patch: proc ();

      px = p_blk.p_cnt;

      do i = 1 to px;				/* now remove the patch */
         p_blk.p_card (i) = p_blk.p_card (i + 1);
      end;

      p_blk.p_cnt = p_blk.p_cnt - 1;			/* from patch block */
      patch_key = "ls." || rtrim (work_key) || ".P.1";

dl_patch:
      cx = index (lcata_key_string, rtrim (patch_key)) / 24;

      do i = 1 to lcata.n_entries - 1 - cx;		/* move all entries down */
         lcata.key (cx + i) = lcata.key (cx + 1 + i);
      end;

      lcata.key (lcata.n_entries) = "";
      lcata.n_entries = lcata.n_entries - 1;

      if index (patch_key, ".P.0") = 0 & p_blk.p_cnt > 0 then
         do i = 1 to px;				/* change the key names */
         lcata.key (cx + i) = lcata.key (cx + i);
         lcata.key (cx + i) = "ls." || rtrim (work_key) || ".P." || ltrim (char (i));
      end;

      call iox_$seek_key (dfm_data.fiocb_ptr, patch_key, rec_len, code); /* set key for deletion */
      if code ^= 0 then
         call dfm_$complain (dfm_datap, wrapup, code, "attempting to seek ^a", patch_key);

      call iox_$delete_record (dfm_data.fiocb_ptr, code);
      if code ^= 0 then
         call dfm_$complain (dfm_datap, wrapup, code, "attempting to delete ^a", patch_key);

      if p_blk.p_cnt = 0 & index (patch_key, ".P.0") = 0 then do; /* cnt = 0 patch key not header */
         patch_key = "ls." || rtrim (work_key) || ".P.0";
         goto dl_patch;
      end;

   end remove_patch;


%page;

/* space_file - int proc to formward space to nxt tape file */

space_file: proc ();

      call iox_$control (dfm_data.tiocb_ptr, "forward_file", null, code);
      if code ^= 0 then
         call dfm_$complain (dfm_datap, wrapup, code, "while spacing a tape file", "");
      dfm_data.cfile = dfm_data.cfile + 1;		/* set correct position */
      dfm_data.crec = 0;
      dfm_data.one_eof = true;			/* set eof flag */

   end space_file;

%page;

/* write_copy - int proc to write current deck to copy tape */

write_copy: proc ();

      if ^dfm_data.first_write then do;			/* if this is the first time thru, set density */
         dfm_data.first_write = true;			/* set flag so we don't come back */

         if dfm_data.cd_sw | dfm_data.denno ^= 0 then do;	/* if user specified density */
	  if dfm_data.denno ^= 0 & ^dfm_data.cd_sw then	/* if master tape not standard density */
	     cden = density (dfm_data.denno);		/* set copy to same  (if not user specified) */
	  call iox_$control (dfm_data.ciocb_ptr, cden, null, code);
	  if code ^= 0 then
	     call dfm_$complain (dfm_datap, wrapup, code, "while setting copy tape density", "");
         end;
      end;

      gprp = dfm_data.bptr;				/* set block ptr to first phy. record */

      do while (bin (rel (gprp)) < dfm_data.dlen - 1 & ^dfm_data.eot); /* wrt entire deck */
         c_rtrycnt = 0;				/* initialize retry count */
retry_cp:
         call iox_$write_record (dfm_data.ciocb_ptr, gprp, (gpr.bcw.blk_size + 1) * 4, code);
         if code ^= 0 then				/* if error */

	  if code = error_table_$tape_error then do;	/* if write error */
	     c_rtrycnt = c_rtrycnt + 1;		/* increment retry count */

	     if c_rtrycnt > max_retrys then do;		/* exceeded error threshold */
	        call iox_$control (dfm_data.ciocb_ptr, "saved_status", addr (t_stat), scode);
	        call dfm_$complain (dfm_datap, print, code,
	         "Tape status = ^4.3b, while writing copy tape after 10 retrys", t_stat);
	        dfm_data.eot = true;
	     end;

	     else do;
	        call iox_$control (dfm_data.ciocb_ptr, "backspace_record", null, scode);
	        call iox_$control (dfm_data.ciocb_ptr, "erase", null, scode);
	        go to retry_cp;
	     end;
	  end;

	  else do;				/* not a tape error */
	     call dfm_$complain (dfm_datap, print, code, "while writing copy tape", "");
	     dfm_data.eot = true;			/* set abort flag */
	  end;
         else gprp = addrel (gprp, currentsize (gpr));	/* no error advance to next block */
      end;
      dfm_data.copy_at_eof = false;			/* we are no longer at an eof mark */

   end write_copy;

%page;
%include access_mode_values;
%page;
%include ak_info;
%page;
%include dfm_data;
%page;
%include gcos_ssf_records;
%page;
%include gload_data;
%page;
%include iox_modes;
%page;
%include mca_area;
%page;
%include mca_config_file;
%page;
%include mca_constants;
%page;
%include mca_data_area;
%page;
%include mca_diskette;
%page;
%include opr_query_info;
%page;
%include status_structures;
%page;
%include select_info;




   end dfm_util_;
