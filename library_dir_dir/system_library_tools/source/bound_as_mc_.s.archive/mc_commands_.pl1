/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/* format: style4 */

mc_commands_: proc;

/* This procedure is part of the message coordinator.
   It contains entries that support all of the message coordinator commands.
   *
   The message coordinator was originally created by Dennis Capps
   with advice from TH VanVleck in October of 1972.
   "mc_commands_" originally created by Bill Silver in May, 74.
   modified by D. M. Wells, July 1976, to understand about FTP channels
   modified by Robert Coren, August 1976, to use CDT
   Modified June 1981 by T. Casey for MR9.0 for new wakeup priorities.
   Modified January 1982 by E. N. Kittlitz to check for intty before searching cdt.
   *	84-11-16, W. Olin Sibert: Changed to call mc_con_rec_$check correctly
   1984-11-??, BIM: changes for iox_.
   1985-03-22, E. Swenson: to eliminate extra NL at end of messages and
   to log operator logout upon dropping a mc terminal.
   1985-04-05, E. Swenson: Fixed to handle dropping/substty on accepted
   channels whose multiplexer has not yet been loaded.
   1985-04-17, E. Swenson: To not attempt to sign out a terminal not signed
   on.
*/


/****^  HISTORY COMMENTS:
  1) change(85-12-19,MSharpe), approve(87-05-01,MCR7690),
     audit(87-05-10,Parisek), install(87-08-04,MR12.1-1055):
     The following modules were changed so that DSA channels could be used as
     MC terminals: new_tty, KILL_TTY, ATTACH_ATE, SEARCH_MC_ANSTBL. A new
     module, mc_login, was added for the same purpose.  It supports
     "login Person_id -operator -vchannel"; after the answering service has
     validated this user to be eligible for logging in as an operator, this
     routine is called to fill in the actual_channel_name of the pre-accepted
     virtual channel specified, and to attach the iocb for it.
     CDD-3/28/86: to clear out login server id in KILL_TTY
  2) change(87-02-05,GDixon), approve(87-05-01,MCR7690),
     audit(87-05-10,Parisek), install(87-08-04,MR12.1-1055):
     Modified for change to mc_anstbl.incl.pl1.  Entrypoint which reference
     mc_anstbl must now explicitly set mc_ansp from sc_stat_$mc_ansp.
     CDD-4/10/86: to set virtual and realy tty_name correctly.
  3) change(87-02-13,GDixon), approve(87-05-01,MCR7690),
     audit(87-05-10,Parisek), install(87-08-04,MR12.1-1055):
     Correct problem in mc_commands_$substty where target terminal is otw_ (the
     system console).  A previous substty operation (substty otw_ XXX)
     destroyed the ssu_ subsystem associated with the console; an attempt to
     substitute I/O back to the system console (substty XXX otw_) then assumes
     the ssu_ subsystem still exists.  Avoid the destroy operation for the
     system console. (phx20406)
  4) change(87-04-06,Parisek), approve(87-05-01,MCR7690),
     audit(87-07-17,Beattie), install(87-08-04,MR12.1-1055):
     Commented in the error_table_$(bad_vchannel vchn_active vchn_not_found)
     error assignments.
  5) change(87-04-23,GDixon), approve(87-05-01,MCR7690),
     audit(87-05-10,Parisek), install(87-08-04,MR12.1-1055):
     Fill in login_server_operator_response.process_group_id so message
     coordinator channels will have proper group id in connection list.
  6) change(87-05-04,Parisek), approve(87-05-01,MCR7690),
     audit(87-07-17,Beattie), install(87-08-04,MR12.1-1055):
     A. Set mc_atep for the valid otw_ mc_anstbl entry instead of leaving it
        null for returning to caller.
     B. Initialize the mc_ate.oper_info.personid.
  7) change(87-05-18,GDixon), approve(87-05-01,MCR7690),
     audit(87-05-10,Parisek), install(87-08-04,MR12.1-1055):
     Use revised calling sequence for uc_send_ls_response_.
  8) change(87-05-27,Parisek), approve(87-05-01,MCR7690),
     audit(87-07-17,Beattie), install(87-08-04,MR12.1-1055):
     A. If by chance the returned cdte pointer from DROP_CDT_TERMINAL is null,
        I added a call sys_log_ call to document the error.
     B. Removed FIND_CDTE internal procedure for locating the cdtep, and
        instead use the value of mc_ate.cdtep which is the cdtep previously
        set when the channel was originally attached.
     C. Pass the mc_atep (mc_anstbl entry pointer) as the parameter to
        DROP_CDT_TERMINAL instead of the tty name so the cdt entry pointer
        can be determined faster.
  9) change(87-06-12,Parisek), approve(87-05-01,MCR7690),
     audit(87-07-17,Beattie), install(87-08-04,MR12.1-1055):
     Added the P_utep parameter for mc_login so we can set the ute.proc_id to
     that of the target process which is needed in case the process is bumped.
 10) change(87-06-18,Parisek), approve(87-05-01,MCR7690),
     audit(87-07-17,Beattie), install(87-08-04,MR12.1-1055):
     Do not reference mc_ate.cdte for otw_ since otw_ has no cdt entry.  This
     corrects a null pointer fault problem when doing a substty of otw_ for
     another channel.
 11) change(87-06-26,Parisek), approve(87-06-26,MCR7690),
     audit(87-07-17,Beattie), install(87-08-04,MR12.1-1055):
      A. Add the access_class_range parameter to mc_login passed by it's caller.
      B. Check allowable access_class_range for dialed user.
      C. Add internal procs ABORT_DIALIN and DIALIN_OK for sending audit data.
      D. Call ABORT_DIALIN or DIALIN_OK where necessary in mc_login entry.
 12) change(87-08-07,Parisek), approve(87-08-07,MCR7690),
     audit(87-08-07,GDixon), install(87-08-07,MR12.1-1073):
     Change the audit action value for successful dialins to a positive
     (accepted) value from a negative (rejected) value.
 13) change(88-11-04,Parisek), approve(87-06-26,MCR7690), 
     audit(88-11-10,Beattie), install(88-11-14,MR12.2-1211):
     Check for a valid cdte pointer (mc_ate.cdtep) for a terminal dialed
     to the MC (DROP_CDT_TERMINAL internal proc) before attempting to reset
     the cdte information for that terminal.  Reestablished the FIND_CDTE
     internal proc for locating the cdtep for the dialed terminal in the
     case where mc_atep or mc_ate.cdtep is null.
                                                   END HISTORY COMMENTS */


declare  P_access_class (2) bit (72) aligned;
declare  P_cdtp ptr parameter;
declare  P_cdte_flag bit (1) aligned parameter;
declare  P_drop_terminal bit (1) aligned parameter;
declare  P_ls_handle bit (72) parameter;
declare  P_ls_procid bit (36) parameter;
declare  P_ls_term_ev_chn fixed bin (71) parameter;
declare  P_ls_resp_ev_chn fixed bin (71) parameter;
declare  P_mpx_name char (*) parameter;
declare  P_mc_ansp ptr parameter;
declare  P_mc_atep ptr parameter;
declare  P_mcmp ptr parameter;
declare  P_message_ptr ptr parameter;
declare  P_temp_SDBp ptr parameter;
declare  P_vchannel char (*) parameter;
declare  P_utep ptr parameter;

declare  inttyp ptr parameter;			/* (OUTPUT) ptr to mc_ate  */
declare  code fixed bin (35) parameter;			/* error code */

declare  Message_ptr pointer parameter;			/* used in reply and intercom */
declare  Message_length fixed bin (21) parameter;		/* ditto */

declare  insc char (*) parameter;			/* A source to route */
declare  instream char (*) parameter;			/* A stream for us to route */
declare  intty char (*) parameter;			/* A console for us to use */
declare  invc char (*) parameter;			/* Virt Cons   */
declare  param1 char (*) parameter;			/* A new target. */
declare  type char (*) parameter;			/* type of destination */


/* Declarations of POINTERS  */
declare
         bufferp2 ptr,				/* Addr of buffer2 */
         iutep ptr,					/* ptr to Initializer ute entry */
         mcmp ptr int static init (null),		/* to message seg for message coordinator */
         messp ptr int static init (null),
         mrtp ptr int static init (null),		/* to Message Routing Table */
         p ptr,					/* A temporary pointer used by substty */
         qp ptr,					/* to queue of lines to be typed on a device */
         streamp ptr,				/* to a stream entry in MRT */
         temp_SDBp ptr int static init (null),		/* to temp_SDB */
         vcep ptr,					/* to an entry in virtual console table */
         vconsp ptr int static init (null),		/* to Virtual CONSole table */
         wakeup_data_ptr ptr;

/* Fixed binary quantities */
declare
         autocode fixed bin (35) init (0),		/* error code in automatic storage */
         ls_status_code fixed bin (35) init (0),		/* ditto */
         dest fixed bin,				/* Index when looping thru phys devices in vcons_tab */
         fbtype fixed bin,				/* type of destination,1=>tty 2=>log 3=>sink */
         i fixed bin,				/* a temporary index */
         j fixed bin,				/* another temporary index */
         jj fixed bin,
         k fixed bin,				/* loop counter for protocol and router */
         lng fixed bin,				/* Length of formatted string for output */
         ls_event_channel fixed bin (71),		/* login server event channel; used for drop */
         mrt_source fixed bin,			/* Index of source entry in MRT */
         mrt_stream fixed bin,			/* Index of stream entry in source entry in MRT */
         nt fixed bin,				/* No of characters actually typed */
         state fixed bin,				/* 0 -- end of data, 1-- more to message */
         this_line fixed bin,				/* Current link in q of lines to be typed */
         vc fixed bin,				/* Index when looping thru vcons in MRT */
         vce fixed bin,				/* Index of Virtual Console table Entry */
         wakeup_data_len fixed bin (18);		/* length of mc_ate; passed to LS for dial wakeup */

/* Character strings */

declare  Destination char (*) varying;
declare  Message char (*);
dcl  old_operator_name char (32);			/* operator currently signed on */
declare  mpx_starname char (32);			/* star name that matches subchannels of mpx */

declare  message char (Message_length) based (Message_ptr);

declare  1 ls_operator_resp aligned like login_server_operator_response;
declare  1 ls_term_resp aligned like login_server_termination_response;
declare  1 CAI structure aligned like channel_audit_info automatic;

declare  buffer2 char (132);
declare  char32 char (32);				/* automatic intty */
declare  insca char (32);				/* automatic insc */
declare  instreama char (32);				/* automatic instream */
declare  iocb_name char (32);
declare  recipient char (32);				/* the source to which a reply is directed */
declare  tempdest char (32);				/* A temporary */
declare  vchannel char (32);				/* automatic P_vchannel */

/* BIT strings */
declare
         access_class_range (2) bit (72) aligned,		/* dialed aim class */
         authority bit (36),				/* Parameter Privileges for this console */
         created_seg (8) bit (1) init ((8) (1)"0"b),	/* In case we want to write messages */
         dont_log bit (1) init ("0"b),			/* "1"b=>Sentinel-- Needn't be logged */
         cdte_flag bit (1) aligned,			/* ""b=> channel not defined in cdt */
         ls_handle bit (72) aligned,			/* login server handle for channel; used for drop */
         ls_process_id bit (36) aligned,		/* login server process id; used for drop */
         must_send_operator_response bit (1),		/* "1"b=> respond to login server's operator request */
         new_vchn_flag bit (1),
         op_ok bit (1),				/* ""b => channel must be accepted by oprator */
         sendalarm bit (1),				/* TRUE if alarm message; at distribute */
         virtual_flag bit (1) aligned,			/* "1"b if intty in new_tty is a vchn name */
         zerobits bit (72) init (""b);			/* used for sending operator response */

/* BUILTIN FUNCTIONS */
declare
         addr builtin,
         clock builtin,
         index builtin,
         length builtin,
         null builtin,
         search builtin,
         size builtin,
         string builtin,
         substr builtin,
         unspec builtin,
         codeptr builtin,
         rtrim builtin;

/* CONSTANTS */

declare  (TRUE init ("1"b),
         FALSE init (""b)) bit (1) aligned int static options (constant);

/* EXTERNAL ENTRIES */

declare  aim_check_$greater entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
declare  as_access_audit_$channel entry (ptr, ptr, ptr, fixed bin, ptr, char (*));
declare  astty_$tty_event entry (ptr, fixed bin (35));
declare  ioa_$ioa_switch entry () options (variable);
declare  cdt_mgr_$find_cdt_channel entry (pointer, character (32), fixed binary, bit (1) aligned, fixed binary (35));
declare  convert_status_code_ entry (fixed binary (35), character (8) aligned, character (100) aligned);
declare  get_group_id_ entry () returns (char (32));
declare  get_process_access_class_ entry () returns (bit (72) aligned);
declare  get_process_id_ entry () returns (bit (36));
declare  get_ring_ entry () returns (fixed bin (3));
declare  hcs_$truncate_seg entry (ptr, fixed bin, fixed bin (35));
declare  hcs_$chname_seg entry (ptr, char (*), char (*), fixed bin (35));
declare  hcs_$wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
declare  hphcs_$ips_wakeup entry (bit (*) aligned, char (*));
declare  ioa_ entry options (variable);
declare  ioa_$rs entry options (variable);
declare  ioa_$rsnnl entry options (variable);
declare  ipc_$create_ev_chn entry (fixed bin (71), fixed bin (35));
declare  ipc_$decl_ev_call_chn entry (fixed bin (71), entry, ptr, fixed bin, fixed bin (35));
declare  ipc_$delete_ev_chn entry (fixed bin (71), fixed bin (35));
declare  lg_ctl_$logout_operator entry (ptr, char (*), char (*));
declare  lg_ctl_$logout_channel entry (ptr, char (*));
declare  log_write_$open entry (character (*), character (*), bit (1) aligned, pointer, fixed binary (35));
declare  log_write_$close entry (pointer, fixed binary (35));
declare  match_star_name_ entry (char (*), char (*), fixed bin (35));
declare  mc_con_rec_$check entry ();
declare  mc_util_$get_seg entry (char (*), ptr, fixed bin (35));
declare  mc_util_$mrt_source entry (char (*), fixed bin, fixed bin (35));
declare  mc_util_$mrt_stream entry (fixed bin, char (*), ptr, fixed bin, fixed bin (35));
declare  mc_util_$queue entry (ptr, bit (1), ptr, fixed bin, fixed bin, fixed bin (35));
declare  mc_wakeups_$typer_out entry;
declare  mrd_util_$write entry (ptr, ptr, fixed bin, fixed bin, fixed bin, fixed bin, fixed bin (35));
declare  sc_create_sci_ entry (pointer, fixed binary (35));
declare  sc_create_sci_$destroy entry (pointer);
declare  ssu_$get_info_ptr entry (ptr) returns (ptr);
declare  sys_log_$command_error entry options (variable);
declare  sys_log_ entry options (variable);
declare  uc_send_ls_response_ entry (ptr, fixed bin (18), bit (36) aligned,
	    bit (72) aligned, fixed bin (71), ptr, char (32) aligned,
	    fixed bin (35), fixed bin (35));
declare  unique_chars_ entry (bit (*)) returns (char (15));

/* EXTERNAL constants */
declare  as_error_table_$dialnotup fixed bin (35) ext static;
declare  (error_table_$action_not_performed,
         error_table_$ai_out_range,
         error_table_$bad_vchannel,
         error_table_$invalid_device,
         error_table_$io_no_permission,
         error_table_$ioname_not_active,
         error_table_$ioname_not_found,
         error_table_$ionmat,
         error_table_$noentry,
         error_table_$notalloc,
         error_table_$typename_not_found,
         error_table_$vchn_active,
         error_table_$vchn_not_found) fixed bin (35) ext static;

declare  cleanup condition;

%page;
init: entry (P_mc_ansp, P_cdtp, P_temp_SDBp, P_mcmp, P_message_ptr);

/* This entry is called by mc_util_$init.  It sets up all of the internal static
   variables needed by the other entries.
*/

	mc_ansp, sc_stat_$mc_ansp = P_mc_ansp;
	temp_SDBp = P_temp_SDBp;
	mcmp = P_mcmp;
	messp = P_message_ptr;

	mrtp = mc_anstbl.mrtp;
	vconsp = mc_anstbl.vconsp;

	return;
%page;

/* This is the reply command. */

reply_command: entry (Destination, Message_ptr, Message_length, inttyp, code);

	code = 0;
	recipient = Destination;
	mc_atep = inttyp;
	if mc_atep ^= null () then
	     if mc_ate.flags.reply_restricted then
		if mc_ate.restrict_reply ^= "" then	/* If there is a restriction on reply */
		     if recipient ^= mc_ate.restrict_reply then do; /* .. check it. */
			code = error_table_$io_no_permission; /* Naughty. */
			return;
		     end;

	call mc_util_$mrt_source (recipient, mrt_source, code);
	if code ^= 0 then return;			/* Couldn't find him. */
	if ^MRT.source (mrt_source).flags.init then	/* He's not attached. */
	     do;
noreply:	     code = error_table_$ioname_not_active;
	     return;
	end;
	temp_SDBp -> stream.hismess = MRT.source (mrt_source).hismess; /* Where to put the reply. */

	autocode = 0;				/* Write it. */

	call mrd_util_$write (temp_SDBp, Message_ptr, 0, (Message_length), nt, state, autocode);
	code = autocode;

	return;
%page;

/* This entry checks to see if the source named has enabled quits, by checking a bit in mc.message.
   If quits are enabled, it uses a highly-privileged interface to send an IPS quit. */

quit_command: entry (insc, inttyp, code);

	code = 0;
	insca = insc;
	if inttyp ^= null ()			/* Not send_admin_command_ or some other previleged entity */
	then if inttyp -> mc_ate.flags.reply_restricted then /* Is this terminal limited in who it can quit? */
		if inttyp -> mc_ate.restrict_reply ^= insca then do;
		     code = error_table_$io_no_permission; /* Naughty. */
		     return;
		end;

	call mc_util_$mrt_source (insca, mrt_source, code);
	if code ^= 0 then return;			/* Couldn't find him. */
	if ^MRT.source (mrt_source).flags.init then	/* He's not attached. */
	     do;
	     code = error_table_$ioname_not_active;
	     return;
	end;
	if substr (mcmp -> syscon_mseg.quit_bits, mrt_source, 1) then do; /* Quits enabled? */
	     call ioa_ ("Sending quit to ^a (^w)", MRT.source (mrt_source).source, MRT.source (mrt_source).hismess -> syscon_mseg.current_process_id);
	     call hphcs_$ips_wakeup (MRT.source (mrt_source).hismess -> syscon_mseg.current_process_id, "quit");
	end;
	else code = error_table_$io_no_permission;
	return;
%page;
intercom: entry (Destination, Message_ptr, Message_length, inttyp, code);

/**** This entry is called when an operator downstairs wants to talk to
      an operator upstairs. */

	code = 0;
	bufferp2 = addr (buffer2);

	char32 = Destination;
	mc_atep = SEARCH_MC_ANSTBL (char32, code);	/* Look up destination. */
	if code ^= 0 then return;			/* Quit if not in table. */
	if mc_ate.iocb = null ()
	then do;
	     code = error_table_$ioname_not_active;
	     return;
	end;

	call ioa_$rsnnl ("FROM ^a: ^a", buffer2, lng, inttyp -> mc_ate.real_tty_name, message);
	qp = mc_ate.queue_ptr;			/* Locate device queue for destination. */
	sendalarm = "0"b;				/* Don't make a fuss. */
	call mc_util_$queue (qp, sendalarm, bufferp2, lng, 0, code); /* Queue stuff for writing. */
	return;
%page;

/* This entry is called by system_control_ whenever an input line is typed.
   It logs the input line, so that we can find out what was said to the system,
   and it may broadcast the input line to other terminals if the mc_ate for the sending terminal specifies. */

note_input: entry (Message, inttyp, code);

	code = 0;
	if inttyp = null () then return;
	mc_ansp = sc_stat_$mc_ansp;
	bufferp2 = addr (buffer2);
	call ioa_$rs (" (input on ^a) ^a", buffer2, lng, inttyp -> mc_ate.real_tty_name, Message);
	sendalarm = "0"b;				/* Not that important. */

	if inttyp -> mc_ate.broadcast & ^inttyp -> mc_ate.broadcast_all
	then do;					/* Broadcast to specified list? */
	     do k = 1 to inttyp -> mc_ate.n_casts;	/* Scan broadcast list. */
		char32 = inttyp -> mc_ate.cast (k);	/* Get one destination. */
		mc_atep = SEARCH_MC_ANSTBL (char32, code); /* Hunt receiver. */
		if code = 0
		then if mc_atep ^= inttyp then do;	/* NEVER broadcast back to inputter. */
			qp = mc_ate.queue_ptr;	/* Locate queue segment. */
			call mc_util_$queue (qp, sendalarm, bufferp2, lng, 0, code);
		     end;
	     end;
	end;
	else if inttyp -> mc_ate.broadcast & inttyp -> mc_ate.broadcast_all then do; /* Broadcast to everybody? */
	     do k = 1 to mc_anstbl.current_size;	/* Check all consoles. */
		mc_atep = addr (mc_anstbl.entry (k));
		if mc_ate.flags.active then
		     if mc_atep ^= inttyp then do;	/* .. nor does it mean myself (silly) */
			qp = mc_ate.queue_ptr;
			call mc_util_$queue (qp, sendalarm, bufferp2, lng, 0, code);
		     end;
	     end;
	end;
	return;
%page;

/* This entry is called by admin to set the broadcast list for a terminal. The default is no broadcast. */

set_broadcast: entry (intty, instring, code);

dcl  instring char (*);

	code = 0;
	char32 = intty;				/* Search for this console. */
	mc_atep = SEARCH_MC_ANSTBL (char32, code);	/* .. */
	if code ^= 0 then return;

	if instring = "none" then do;			/* Reset switch. */
	     mc_ate.broadcast, mc_ate.broadcast_all = "0"b;
	     mc_ate.n_casts = 0;
	     mc_ate.cast (*) = "";
	end;
	else if instring = "all" then
	     mc_ate.broadcast, mc_ate.broadcast_all = "1"b;
	else do;					/* Must be list. */
	     mc_ate.n_casts = 0;			/* Clear list. */
	     mc_ate.broadcast = "1"b;
	     do i = 1 repeat i + j while (i < length (instring));
		j = search (substr (instring, i), ","); /* find next comma. */
		if j = 0 then j = length (instring) - i + 2;
		mc_ate.n_casts = mc_ate.n_casts + 1;
		mc_ate.cast (mc_ate.n_casts) = substr (instring, i, j - 1);
	     end;
	end;
	return;
%page;

/* This entry is called by admin to set the "reply restriction" for a terminal. */

set_restrict: entry (intty, instring, code);

	code = 0;
	char32 = intty;
	mc_atep = SEARCH_MC_ANSTBL (char32, code);
	if code ^= 0 then return;

	mc_ate.restrict_reply = instring;
	mc_ate.flags.reply_restricted = (instring ^= "");
	return;

%page;
new_vchannel: entry (intty, authority, inttyp, code);

/* This entry is the same as accept (below) except that the virtual channels
   created this way, must be "accepted" by the operator before being used. */

	code = 0;
	char32 = intty;
	new_vchn_flag = "1"b;
	virtual_flag = "1"b;
	cdte_flag = "0"b;

	goto COMMON_NEW;
%page;
new_tty: entry (intty, authority, P_cdte_flag, inttyp, code);

/* This entry accepts a console by symbolic name and adds it
   to the message coordinator's answer table.  It also creates a
   typeout queue segment for this new tty.

   First check for this console already hooked up. If not, do it.
   Return error_table_$ionmat if it's already here.

   mc_commands_$mc_login is used for creating entries in the mc_anstbl
   when the "login {person_id} -operator", without -vchannel, is used;
   it sets the mc_ate.pending flag.  Only these custom-made entries may
   be used for dsa channels when virtual channels are not used.
*/

	code = 0;
	char32 = intty;
	virtual_flag = (index (char32, ".") = 0) & (char32 ^= "otw_");
	cdte_flag = P_cdte_flag;			/* has a cdte ? */
	new_vchn_flag = ""b;

COMMON_NEW:					/* new_vchannel joins us here */

	must_send_operator_response = ""b;		/* i.e., we don't need to send a response */

	mc_atep = SEARCH_MC_ANSTBL (char32, code);
	inttyp = mc_atep;				/* output param */
	if code = 0
	then if ^mc_ate.flags.pending
	     then do;
		string (mc_ate.authority) = authority;	/* Reset authority flags. */
		if mc_ate.sci_ptr ^= null () then do;	/* not supposed to happen, but faults are un-nice. */
		     sc_subsystem_info_ptr = ssu_$get_info_ptr (mc_ate.sci_ptr);
		     sc_subsystem_info.restriction_flags = authority;
		end;
		code = error_table_$ionmat;
		return;
	     end;
	     else if mc_ate.flags.virtual		/* vchannel pending accept */
	     then do;
		mc_ate.flags.pending = ""b;
		if mc_ate.ls_procid ^= ""b		/* network line */
		then call FILL_RESPONSE_STRUCTURE ();
						/* prepare to reply to login_server operator request */

		call CONNECT_PHYSICAL_CHANNEL ();
		return;
	     end;
	     else ;

	else if (code ^= error_table_$ioname_not_found
	     & code ^= error_table_$ioname_not_active)
	then return;

	if mc_atep = null				/* need to allocate a new_entry */
	then do;
	     if ^cdte_flag & ^virtual_flag then do;	/* non-cdt channels are created upon "dialing in" */
		code = error_table_$ioname_not_found;	/* same code as a channel not in MC_SERVICE */
		return;
	     end;
	     j, mc_anstbl.current_size = mc_anstbl.current_size + 1;
	     mc_atep = addr (mc_anstbl.entry (j));
	end;

	else if ^cdte_flag & ^virtual_flag		/* requires pending entry */
	     & code = error_table_$ioname_not_found
	then return;

	code = 0;
	mc_ate.flags = ""b;
	mc_ate.pad_ptrs = ""b;
	mc_ate.flags.vchn_requires_accept = new_vchn_flag;
	mc_ate.queue_ptr = null;
	mc_ate.sci_ptr = null;
	mc_ate.iocb = null;
	mc_ate.cdtep = null;
	mc_ate.queue_event = 0;
	mc_ate.pad_ev_chn = ""b;
	mc_ate.virtual_tty_name = intty;
	mc_ate.oper_info.personid = "";


	string (mc_ate.authority) = authority;		/* What this typewriter is allowed to do. */
	mc_ate.flags.active = "1"b;

/* Now initiate or create queue seg. */

	if length (rtrim (mc_ate.virtual_tty_name)) + length (".queue")
	     <= 32 then call mc_util_$get_seg
		(rtrim (mc_ate.virtual_tty_name) || ".queue", qp, code);
	else do;
	     call mc_util_$get_seg (unique_chars_ (""b), qp, code);
	     if code = 0 then call hcs_$chname_seg (qp, "", intty, (0));
	end;

	if code ^= 0 then goto NEWERR;

	mc_ate.queue_ptr = qp;			/* Seg for queue of things to be typed. */
	mc_ate.n_casts = 0;
	mc_ate.restrict_reply = "";			/* .. and to whom. (default is everybody) */
	string (mc_ate.control) = "0"b;		/* Allowed to type but nothing waiting */

	call ipc_$create_ev_chn (mc_ate.queue_event, code); /* Channel to wake when want to type. */
	if code ^= 0 then goto NEWERR;

/* Set up console queue seg */
	call hcs_$truncate_seg (qp, 0, code);
	if code ^= 0 then goto NEWERR;

	device_queue.channel = mc_ate.queue_event;
	device_queue.device_name = intty;
	device_queue.mc_atep = mc_atep;

/* What to do when typer channel kicked. */
	call ipc_$decl_ev_call_chn (device_queue.channel, mc_wakeups_$typer_out, qp, MC_PRIO, code);
	if code ^= 0 then goto NEWERR;

	call mc_con_rec_$check ();			/* Check to see if we can use this
						   terminal for console recovery. */

	if virtual_flag then do;
	     mc_ate.flags.virtual = "1"b;
	     return;
	end;

	if mc_ate.ls_procid ^= ""b			/* network line */
	then call FILL_RESPONSE_STRUCTURE ();		/* prepare to reply to login_server operator request */


	call CONNECT_PHYSICAL_CHANNEL ();		/* attach iocb, event channel for dial/hangup, etc.
						   mc_login does this for virtual channels
						   when someone logs into one */
	if mc_ate.real_tty_name = "otw_" &
	     mc_ate.flags.the_system_console then	/* Define the mc_ate pointer for otw_ */
	     inttyp = addr (mc_anstbl.entry (1));

	if code = 0 then return;

NEWERR:

	if must_send_operator_response
	then do;
	     ls_operator_resp.status_code = code;
	     call uc_send_ls_response_ (addr (ls_operator_resp),
		size (ls_operator_resp), ls_process_id,
		ls_handle, ls_event_channel, addr (zerobits),
		(intty), 0, code);
	end;
	else ;

	call KILL_TTY (mc_atep);

	return;

%page;
mc_login: entry (intty, Operator_name, P_utep, P_vchannel, P_access_class, P_ls_procid, P_ls_term_ev_chn, P_ls_resp_ev_chn, P_ls_handle, code);

/*  This routine is called by dial_mgr_ to let us know that someone wishes
   to "login" as a message coordinator.

   If the P_vchannel is "", we create a pending mc_ate for the channel, and
   "sign on" the operator.  Only a "pending" entry may be used for a DSA
   channel; "accept" will not create or assign a free mc_ate to DSA channels.
   This is required for DSA channels since there is no CDTE to hold this
   information.

   If the P_vchannel is provided, and a "virtual" mc_ate already exists,
   we fill in the mc_ate.tty portion, attach the iocb and "sign on" the
   operator.

*/

	code = 0;
	char32 = intty;
	utep = P_utep;
	vchannel = P_vchannel;
	access_class_range = P_access_class;
	mc_ansp = sc_stat_$mc_ansp;
	dutp = as_data_$dutp;
	iutep = addr (dutbl.entry (1));		/* Initializer's ute entry ptr */

	op_ok = ""b;

	if vchannel = ""
	then do;
	     mc_atep = SEARCH_MC_ANSTBL (char32, code);
	     if code = 0				/* already active */
		| code = error_table_$ioname_not_active /* already pending */
	     then do;
		code = error_table_$ionmat;
		call ABORT_DIALIN (code, "");
		return;
	     end;

	     else if code ^= error_table_$ioname_not_found
	     then do;
		call ABORT_DIALIN (code, "");
		return;				/* "real" error */
	     end;

	     if mc_atep = null			/* create a new entry */
	     then do;
		if mc_anstbl.current_size = mc_anstbl.max_size
		then do;				/* no more room */
		     code = error_table_$notalloc;
		     call ABORT_DIALIN (code, "");
		     return;
		end;

		mc_anstbl.current_size = mc_anstbl.current_size + 1;
		mc_atep = addr (mc_anstbl.entry (mc_anstbl.current_size));
	     end;

	     unspec (mc_ate) = ""b;
	end;

	else do;					/* attach to a virtual channel */
	     if (index (vchannel, ".") ^= 0) | (vchannel = "otw_")
	     then do;
		code = error_table_$bad_vchannel;
		call ABORT_DIALIN (code, "");
		return;
	     end;

	     mc_atep = SEARCH_MC_ANSTBL (char32, code);
	     if (code = 0
		| code = error_table_$ioname_not_active)
	     then do;
		code = error_table_$ionmat;
		call ioa_$rsnnl ("Channel ^a already in use.", buffer2,
		     (0), char32);
		call sys_log_$command_error (-1, code,
		     "mc_commands_$mc_login", buffer2);
		call ABORT_DIALIN (code, "");
		return;
	     end;

	     else if code ^= error_table_$ioname_not_found
	     then do;
		call ABORT_DIALIN (code, "");
		return;				/* real error */
	     end;

	     mc_atep = SEARCH_MC_ANSTBL (vchannel, code);
	     if code = 0
	     then if mc_ate.iocb ^= null ()
		then do;
		     code = error_table_$vchn_active;
						/* vchannel already active */
		     call ABORT_DIALIN (code, "");
		     return;
		end;
		else ;

	     else do;
		if code = error_table_$ioname_not_found /* vchannel does not exist */
		then code = error_table_$vchn_not_found;
		call ABORT_DIALIN (code, "");
		return;
	     end;

	     if sc_stat_$vchn_requires_accept then do;
		do i = 1 to mc_anstbl.current_size while (^op_ok);
		     if (Operator_name = mc_anstbl.entry (i).oper_info.personid)
						/* operator already cleared */
		     then op_ok = "1"b;
		end;
	     end;
	     if ^mc_ate.flags.vchn_requires_accept then op_ok = "1"b;
	end;

	if aim_check_$greater (get_process_access_class_ (), access_class_range (1))
	then do;
	     call ABORT_DIALIN (error_table_$ai_out_range, "Channel not system_low");
	     return;
	end;

	mc_ate.virtual_tty_name = vchannel;
	mc_ate.real_tty_name = intty;
	mc_ate.sci_ptr = null ();
	mc_ate.cdtep = null ();

	mc_ate.ls_procid = P_ls_procid;		/* Accept wakeups from this process in mc_tty_ */
	mc_ate.ls_term_ev_chn = P_ls_term_ev_chn;
	mc_ate.ls_resp_ev_chn = P_ls_resp_ev_chn;
	mc_ate.ls_handle = P_ls_handle;

	call ipc_$create_ev_chn (mc_ate.event, code);
	if code ^= 0 then do;
	     call ABORT_DIALIN (code, "");
	     return;
	end;

	call ipc_$decl_ev_call_chn (mc_ate.event, mc_anstbl.cons_cont_proc,
	     mc_atep, MC_PRIO, code);
	if code ^= 0 then do;
	     call ABORT_DIALIN (code, "");
	     return;
	end;

	if utep ^= null then
	     ute.proc_id = get_process_id_ ();		/* Target process set in case a bump is done */
	if op_ok
	then do;
	     mc_ate.flags.pending = ""b;
	     call FILL_RESPONSE_STRUCTURE ();
	     call CONNECT_PHYSICAL_CHANNEL ();
	     if code ^= 0 then do;
		call ABORT_DIALIN (code, "");
		return;				/* let AS deal with the login_server */
	     end;
	end;
	else mc_ate.flags.pending = "1"b;		/* wait for "accept" */

/* Tell the operator */

	call sys_log_ (SL_LOG_BEEP, "^a: Channel ^a^[ vchannel (^a)^;^s^] dialed to Initializer (^a^[ ACCEPTED^])",
	     "mc_commands_$mc_login", mc_ate.real_tty_name,
	     mc_ate.flags.virtual, mc_ate.virtual_tty_name,
	     Operator_name, op_ok);

/* Sign on the operator */

	if ^sc_stat_$no_operator_login then
	     mc_ate.oper_info.personid = Operator_name;

	code = 0;
	call DIALIN_OK ();

	return;
%page;

remove_tty: entry (intty, P_drop_terminal, code);

/* This entry is called to remove a tty from the message coordinator.
   It removes all references to this channel from all vcons table entries.
   If intty is the name of the real channel connected to a virtual channel,
   the real channel is dropped, but the output to the virtual channel
   continues to get queued up, i.e., the virtual channel may be reused
   without needing to be "accepted" again.  Otherwise, the channel is removed
   from the list of destinations of all virtual consoles and the iocb, queue
   segment, event channels and the corresponding mc_ate are destroyed.

   If this entry is called from mc_tty_ when a terminal is disconnected,
   P_drop_terminal is ""b and no attempt is made to disconnect the line.
*/

	code = 0;
	char32 = intty;
	if index (char32, ".") ^= 0
	     | intty = "otw_"
	then virtual_flag = ""b;
	else virtual_flag = "1"b;

	mc_atep = SEARCH_MC_ANSTBL (char32, code);

	if code = error_table_$ioname_not_active
	then do;
	     if P_drop_terminal
	     then do;
		code = 0;
		if mc_ate.ls_procid = ""b & ^mc_ate.virtual
		then call DROP_CDT_TERMINAL (mc_atep, char32);
		else call SEND_OPERATOR_RESPONSE (mc_ate.real_tty_name,
			error_table_$action_not_performed);
	     end;
	     mc_ate.flags.pending = ""b;
	     mc_ate.real_tty_name = "";
	     mc_ate.oper_info.personid = "";
	     mc_ate.ls_procid = ""b;
	     return;
	end;

	if code ^= 0 then do;
	     code = 0;
	     call DROP_CDT_TERMINAL (mc_atep, char32);
	     if code ^= 0 then call
		     sys_log_ (SL_LOG_BEEP, "Unable to locate a CDT entry for ^a while attempting to drop it.",
		     char32);
	     return;
	end;


/* Find every reference to this typewriter that is made in the vcons tab */
	do vce = 1 to vcons_tab.no_of_vcons;
	     vcep = addr (vcons_tab.vcons (vce));
	     if vcons.flags.inuse			/* No need to look at empty entries */
	     then do dest = 1 to vcons.no_of_dest;
		if vcons.dest (dest).dest = char32 then /* found a reference */
		     do;				/* Get rid of it */
		     do i = dest to vcons.no_of_dest - 1;
			vcons.dest (i).type = vcons.dest (i + 1).type;
			vcons.dest (i).dest = vcons.dest (i + 1).dest;
			vcons.dest (i).queue_seg_ptr = vcons.dest (i + 1).queue_seg_ptr;
		     end;
		     vcons.no_of_dest = vcons.no_of_dest - 1;
		     goto rtnext;			/* Assume its not here twice */
		end;
	     end;
rtnext:	end;


/* Remember the star entry */
	vcep = addr (vcons_tab.star_entry);
	do dest = 1 to vcons.no_of_dest;
	     if vcons.dest (dest).dest = char32 then
		do;
		do i = dest to vcons.no_of_dest - 1;
		     vcons.dest (i).type = vcons.dest (i + 1).type;
		     vcons.dest (i).dest = vcons.dest (i + 1).dest;
		     vcons.dest (i).queue_seg_ptr = vcons.dest (i + 1).queue_seg_ptr;
		end;
		vcons.no_of_dest = vcons.no_of_dest - 1;
		goto rtnext1;
	     end;
	end;
rtnext1:

	if mc_ate.pending				/* pending on a vchannel */
	then do;
	     if P_drop_terminal
	     then do;
		code = 0;
		if mc_ate.ls_procid = ""b & ^mc_ate.virtual
		then call DROP_CDT_TERMINAL (mc_atep, char32);
		else call SEND_OPERATOR_RESPONSE (mc_ate.real_tty_name,
			error_table_$action_not_performed);
	     end;
	     if mc_ate.real_tty_name = char32		/* just drop the real tty of a vchannel */
	     then do;
		mc_ate.flags.pending = ""b;
		mc_ate.real_tty_name = "";
		mc_ate.oper_info.personid = "";
		mc_ate.ls_procid = ""b;
		return;
	     end;
	     else ;				/* drop down to call kill_tty */
	end;

	else if ^(mc_ate.flags.virtual & mc_ate.virtual_tty_name = char32
	     & mc_ate.real_tty_name = "")		/* all but vchns not connected to a real channel */
	then do;
	     call DELETE_IOCB (mc_atep);
	     if P_drop_terminal then do;
		if mc_ate.ls_procid = ""b
		then do;
		     call DROP_CDT_TERMINAL (mc_atep, char32);
		     if code = error_table_$noentry then
			call sys_log_ (SL_TYPE_BEEP, "Unable to locate a CDT entry for ^a while attempting to drop it.", mc_ate.real_tty_name);
		end;
		else do;
		     call SEND_TERMINATE_RESPONSE ();
		     mc_ate.ls_procid = ""b;
		end;
	     end;
	     if mc_ate.virtual_tty_name ^= char32
	     then do;				/* do not remove the mc_ate */
		mc_ate.signed_on = ""b;
		mc_ate.oper_info.personid = "";
		return;
	     end;
	end;

/* "Delete" the mc_ate, queue segment, the whole thing */

	code = 0;
	qp = mc_ate.queue_ptr;

	call KILL_TTY (mc_atep);			/* Remove the mc_ate */

	return;
%page;
/* This entry is essentially an abbreviation for the following sequence of calls:
   remove_tty(intty)
   new_tty   (param1)
   define    (<intty's_vconss>,param1) where <intty's vconss> successively takes on the
   names of all virtual consoles that were
   previously directed to intty.
   It is complicated by having to preserve the output destined for intty, which it puts
   in param1's queue by copying it wholesale.   */

substty: entry (intty, param1, P_cdte_flag, inttyp, P_drop_terminal, code);

	code = 0;
	char32 = intty;
	mc_atep = SEARCH_MC_ANSTBL (char32, code);
	if code ^= 0 then return;			/* Not there, meaningless. */

	inttyp = SEARCH_MC_ANSTBL ((param1), code);	/* We need to weed out the pending entries */
	if code = error_table_$ioname_not_active
	     | code = 0
	then if inttyp -> mc_ate.pending
	     then do;
		code = error_table_$action_not_performed;
		return;
	     end;

	cdte_flag = P_cdte_flag;

	call new_tty (param1, string (mc_ate.authority), cdte_flag,
	     inttyp, autocode);
	if autocode ^= 0 then
	     if autocode = error_table_$ionmat then autocode = 0;
	     else do;				/* Real error. */
		code = autocode;
		return;
	     end;

	p = inttyp -> mc_ate.queue_ptr;		/* Pointer to queue seg of new typewriter. */
	qp = mc_atep -> mc_ate.queue_ptr;		/* Pointer to queue seg of old typewriter. */

/* Change all the references in the virtual console table. */
	do vce = 1 to vcons_tab.no_of_vcons;
	     vcep = addr (vcons_tab.vcons (vce));
	     if vcons.flags.inuse then		/* No need to look at empty entries */
		do dest = 1 to vcons.no_of_dest;
		if vcons.dest (dest).dest = intty then	/* Found a reference */
		     do;				/* Change it */
		     vcons.dest (dest).dest = param1;
		     vcons.dest (dest).queue_seg_ptr = p;
		end;
	     end;
	end;

/* * */
	vcep = addr (vcons_tab.star_entry);
	do dest = 1 to vcons.no_of_dest;
	     if vcons.dest (dest).dest = intty then
		do;
		vcons.dest (dest).dest = param1;
		vcons.dest (dest).queue_seg_ptr = p;
	     end;
	end;

/* Now transfer all the pending output for intty to queue for param1 */
	if qp -> device_queue.no_of_messages = 0 then goto delete; /* Nothing to save */
	i = p -> device_queue.end_of_queue;		/* Link saved stuff to end of savior queue */
	if i ^= 0 then p -> device_queue.line (i).next_line = p -> device_queue.next_free + 1;
	j = p -> device_queue.next_free + 1;		/* Dont fiddle with free list. Just allocate blocks */
	this_line = qp -> device_queue.top_of_queue;

	do jj = 1 to 10000 while (this_line ^= 0);
	     p -> device_queue.line (j).not_done = qp -> device_queue.line (this_line).not_done;
	     p -> device_queue.line (j).alarm = qp -> device_queue.line (this_line).alarm;
	     p -> device_queue.line (j).offset = qp -> device_queue.line (this_line).offset;
	     p -> device_queue.line (j).source = qp -> device_queue.line (this_line).source;
	     p -> device_queue.line (j).line_length = qp -> device_queue.line (this_line).line_length;
	     p -> device_queue.line (j).string = qp -> device_queue.line (this_line).string;
	     this_line = qp -> device_queue.line (this_line).next_line;
	     if this_line = 0 then			/* This is the end of the chain */
		p -> device_queue.line (j).next_line = 0;
	     else do;
		p -> device_queue.line (j).next_line = j + 1;
		j = j + 1;
	     end;
	end;

	p -> device_queue.no_of_messages = p -> device_queue.no_of_messages + qp -> device_queue.no_of_messages;
	if p -> device_queue.top_of_queue = 0 then	/* Savior was previously empty */
	     do;
	     p -> device_queue.top_of_queue = p -> device_queue.next_free + 1;
	     call hcs_$wakeup (mc_anstbl.mc_procid, p -> device_queue.channel, 0, code); /* wake typer_out */
	end;
	p -> device_queue.end_of_queue = j;
	p -> device_queue.next_free = j;

delete:	call DELETE_IOCB (mc_atep);

	if mc_ate.ls_procid = ""b & ^mc_ate.virtual
	then call DROP_CDT_TERMINAL (mc_atep, char32);
	else call SEND_TERMINATE_RESPONSE ();

	if ^(mc_ate.flags.virtual & mc_ate.real_tty_name = char32)
	then call KILL_TTY (mc_atep);			/* Delete the typewriter. */

	return;
%page;
/* This is the guts of the define command.  The human interface is
   in admin_ which then calls this entry for every definition.
   If the specified tty is not found in the mc_anstbl, the vcons
   given the default destination and an error code is returned.
   If the specified vcons is already known, the new destination
   is added, otherwise a new vcons entry is created.  The real
   channel associated with a vchannel may be specified interchangeably
   with the vchannel to which it is connected.  Pending entries not
   associated with vchannels are treated like non-existent ttys.
   Pending entries associated with vchannels are rejected; the
   operator can define the vcons using the star_entry or the
   vchannel name. */

define: entry (invc, type, intty, code);

	code = 0;					/* initialization is bliss */
	if type = "tty" then
	     do;
	     fbtype = 1;
	     char32 = intty;
	     mc_atep = SEARCH_MC_ANSTBL (char32, code);	/* Look for this typewriter in mc_answer table */
	     if code ^= 0 then
		if code ^= error_table_$ioname_not_found
		     & code ^= error_table_$ioname_not_active
		then return;			/* A real error */
		else do;				/* Not there. Use default typewriter. */
		     qp = vcons_tab.star_entry.dest (1).queue_seg_ptr;
		     tempdest = vcons_tab.star_entry.dest (1).dest;
		     mc_atep = device_queue.mc_atep;
		end;
	     else do;				/* Found it. Get relevant info */
		if mc_ate.flags.pending & mc_ate.real_tty_name = char32
		then do;				/* the real channel pending accept on vchannel */
		     code = error_table_$action_not_performed;
		     return;
		end;

		qp = mc_ate.queue_ptr;
		tempdest = char32;
	     end;
	     vcep = SEARCH_VCONS_TAB (invc, vce, autocode); /* Look for this vcons in table */
	     if autocode = 0 then goto change_vce;	/* Found it. */
	     if autocode = error_table_$ioname_not_found then goto new_vce; /* Not there */
	     if code = 0 then code = autocode;		/* A real error. */
	     return;
	end;
	else if type = "log" then do;
	     fbtype = 2;
	     tempdest = intty;
	     call log_write_$open (sc_stat_$log_dir, tempdest, "1"b /* create ok */, qp, code);
	     if code ^= 0 then return;
	     vcep = SEARCH_VCONS_TAB (invc, vce, code);	/* Look for this vcons in table. */
	     if code = 0 then goto change_vce;		/* Found it. */
	     if code ^= error_table_$ioname_not_found then return; /* A real error */
	     code = 0;				/* not there */
	     goto new_vce;
	end;

	else if type = "sink" then
	     do;
	     fbtype = 3;
	     tempdest = intty;
	     qp = null;
	     vcep = SEARCH_VCONS_TAB (invc, vce, code);
	     if code = 0 then goto change_vce;
	     if code ^= error_table_$ioname_not_found then return; /* Not there */
	     code = 0;
	     goto new_vce;
	end;

	else do;					/* Bad type */
	     code = error_table_$typename_not_found;
	     return;
	end;

change_vce:
						/* Find out if this destination is already defined */
	do i = 1 to vcons.no_of_dest while (vcons.dest (i).dest ^= tempdest);
	end;
	if i > vcons.no_of_dest then			/* didn't find it */
	     if i > 8 then				/* Not room for it anyway */
		do;
		if code = 0 then code = error_table_$notalloc;
		return;
	     end;
	     else vcons.no_of_dest = i;		/* Allocate new entry */
	vcons.dest (i).type = fbtype;
	vcons.dest (i).dest = tempdest;
	vcons.dest (i).queue_seg_ptr = qp;
	return;

new_vce:
	if vcep = null then				/* There wasn't a vacant entry. */
	     do;
	     vce,
		vcons_tab.no_of_vcons = vcons_tab.no_of_vcons + 1; /* Allocate a new entry. */
	     vcep = addr (vcons_tab.vcons (vce));
	end;
	vcons.vcons = invc;
	vcons.no_of_dest = 1;
	vcons.flags.inuse = "1"b;
	vcons.dest (1).type = fbtype;
	vcons.dest (1).dest = tempdest;
	vcons.dest (1).queue_seg_ptr = qp;
	return;
%page;
redefine: entry (invc, intty, type, param1, code);

	code = 0;
	call undefine (invc, intty, code);
	if code ^= 0 then return;
	call define (invc, type, param1, code);
	return;
%page;
undefine: entry (invc, intty, code);

	code = 0;
	vcep = SEARCH_VCONS_TAB (invc, vce, code);
	if intty = "*" then goto udsMRT;		/* This vcons goes entirely away. */
	if code ^= 0 then return;			/* That vcons isn't there! */
						/* Find the destination and delete it. */
	do dest = 1 to vcons.no_of_dest;
	     if vcons.dest (dest).dest = intty then do;
		do i = dest to vcons.no_of_dest - 1;
		     if vcons.dest (i).type = 2 then
			call log_write_$close (vcons.dest (i).queue_seg_ptr, (0));
		     vcons.dest (i).dest = vcons.dest (i + 1).dest;
		     vcons.dest (i).type = vcons.dest (i + 1).type;
		     vcons.dest (i).queue_seg_ptr = vcons.dest (i + 1).queue_seg_ptr;
		end;
		vcons.no_of_dest = vcons.no_of_dest - 1;
		go to udsMRT;			/* If any daemon is stuck, go wake him */
	     end;
	end;

	code = error_table_$ioname_not_found;		/* Fell out of loop, bad tty name. */
	return;

udsMRT:						/* Eliminate all references in the MRT */
	do mrt_source = 1 to MRT.no_of_sources;
	     if MRT.source (mrt_source).flags.valid then	/* No need to look at empty entries */
		do mrt_stream = 1 to MRT.source (mrt_source).no_of_streams;
		streamp = addr (MRT.source (mrt_source).stream (mrt_stream));
		if stream.flags.valid then		/* No need to look at empty entries */
		     do vc = 1 to stream.no_of_vcons;
		     if stream.vcons (vc) = invc then do; /* Found a reference */
			if intty = "*" then do;	/* Deleting whole vcon? */
			     do i = vc to stream.no_of_vcons - 1;
				stream.vcons (i) = stream.vcons (i + 1);
				stream.vcons_index (i) = stream.vcons_index (i + 1);
			     end;
			     stream.no_of_vcons = stream.no_of_vcons - 1;
			end;
			call SHAKE_SOURCE (MRT.source (mrt_source).hismess);
						/* If any daemon waits this console, wake */
			goto udnext;		/* Assume it's not here twice */
		     end;
		end;
udnext:	     end;
	end;
	if intty ^= "*" then return;			/* Unless destroying a vcon entirely, done */

	streamp = addr (MRT.star_entry.stream);
	do vc = 1 to stream.no_of_vcons;
	     if stream.vcons (vc) = invc then do;
		do i = vc to stream.no_of_vcons - 1;
		     stream.vcons (i) = stream.vcons (i + 1);
		     stream.vcons_index (i) = stream.vcons_index (i + 1);
		end;
		stream.no_of_vcons = stream.no_of_vcons - 1;
		goto wipeout;
	     end;
	end;

wipeout:
	if code ^= 0 then return;			/* this vcons isn't there. */
	vcons.flags.inuse = "0"b;			/* Invalidate the entry */
	vcons_tab.no_of_vcons = vcons_tab.no_of_vcons - 1;
	return;
%page;
route: entry (insc, instream, invc, type, code);

	code = 0;
	insca = insc;
	instreama = instream;

/* Find out if this virtual console is known */
	vcep = SEARCH_VCONS_TAB (invc, vce, code);
	if code ^= 0 then
	     if code ^= error_table_$ioname_not_found then return;
	     else do;				/* Use default virtual console */
		vce = 1;
		vcep = addr (vcons_tab.vcons (1));
	     end;

/* Now find place in MRT */
/* source */
	call mc_util_$mrt_source (insca, mrt_source, autocode);
	if autocode ^= 0 then
	     if autocode = error_table_$ioname_not_found then goto new_source; /* not already routed */
	     else return;				/* real error */

/* stream */
	call mc_util_$mrt_stream (mrt_source, instreama, streamp, mrt_stream, autocode);
	if autocode ^= 0 then
	     if autocode = error_table_$ioname_not_found then goto new_stream;
	     else return;

/* See if this vcons already recieves messages from this source-stream */

	do vc = 1 to stream.no_of_vcons;
	     if stream.vcons (vc) = invc then goto refresh;
	end;

/* Not here. */
	if stream.no_of_vcons < 8 then		/* Room enough for another entry. */
	     vc, stream.no_of_vcons = stream.no_of_vcons + 1;
	else do;
	     code = error_table_$notalloc;
	     return;
	end;

refresh:
	if type = "alarm" then substr (stream.flags.alarm, vc, 1) = "1"b; /* Are these messages important? */
	else substr (stream.flags.alarm, vc, 1) = "0"b;
	stream.vcons (vc) = vcons_tab.vcons (vce).vcons;
	stream.vcons_index (vc) = vce;
	return;

new_stream:					/* Create a new stream entry for this source */
	if mrt_stream = 0 then			/* need to allocate a new one */
	     if MRT.source (mrt_source).no_of_streams < 8 then /* there's room enough */
		mrt_stream,
		     MRT.source (mrt_source).no_of_streams = MRT.source (mrt_source).no_of_streams + 1;
	     else do;				/* Not room enough */
		code = error_table_$notalloc;
		return;
	     end;

/* Successfully allocated or there was a vacant entry */
set_stream:
	streamp = addr (MRT.source (mrt_source).stream (mrt_stream));
	stream.flags.valid = "1"b;
	stream.flags.active = "0"b;
	stream.source = insc;
	stream.stream = instream;
	stream.ourmess = mcmp;
	stream.hismess = MRT.source (mrt_source).hismess;
	stream.source_index = mrt_source;
	stream.stream_index = mrt_stream;
	vc, stream.no_of_vcons = 1;
	goto refresh;

new_source:					/* Create new source entry in MRT */
	if mrt_source = 0 then			/* Need to allocate a new one */
	     mrt_source,
		MRT.no_of_sources = MRT.no_of_sources + 1;
						/* else have a vacant one */

	MRT.source (mrt_source).source = insc;
	MRT.source (mrt_source).hismess = null;
	mrt_stream,
	     MRT.source (mrt_source).no_of_streams = 1;
	string (MRT.source (mrt_source).flags) = "01"b;	/* Not initialized but valid */
	goto set_stream;
%page;
reroute: entry (insc, instream, invc, param1, type, code);

	code = 0;
	call deroute (insc, instream, invc, code);
	if code ^= 0 then return;
	call route (insc, instream, param1, type, code);
	return;
%page;
deroute: entry (insc, instream, invc, code);

	code = 0;
	insca = insc;
	instreama = instream;
	call mc_util_$mrt_source (insca, mrt_source, code);
	if code ^= 0 then return;
	call mc_util_$mrt_stream (mrt_source, instreama, streamp, mrt_stream, code);
	if code ^= 0 then return;

	call SHAKE_SOURCE (MRT.source (mrt_source).hismess);
	do vc = 1 to stream.no_of_vcons;
	     if stream.vcons (vc) = invc then do;
		do i = vc to stream.no_of_vcons - 1;
		     stream.vcons (i) = stream.vcons (i + 1);
		     stream.vcons_index (i) = stream.vcons_index (i + 1);
		end;

		stream.no_of_vcons = stream.no_of_vcons - 1;
		goto drend;
	     end;
	end;
	code = error_table_$ioname_not_found;

drend:	return;
%page;

declare  MC_atep pointer;
declare  Operator_name char (*);
declare  Ex_operator_name char (*);
declare  Code fixed bin (35);

sign_in: entry (MC_atep, Operator_name, Ex_operator_name);

	mc_atep = MC_atep;
	Ex_operator_name = "";

	if mc_ate.signed_on
	then Ex_operator_name = mc_ate.oper_info.personid;
	mc_ate.signed_on = "1"b;
	mc_ate.oper_info.personid = Operator_name;
	mc_ate.oper_info.last_input_time = clock ();
	return;

sign_out: entry (MC_atep, Ex_operator_name, Code);

	call SIGN_OUT (MC_atep, Ex_operator_name, Code);
	return;

%page;
listen_to_ttys: entry (P_mpx_name);

/* entry called when FNP comes up, listens to all accepted terminals on that FNP */

declare  error_string char (100) aligned;

	mc_ansp = sc_stat_$mc_ansp;
	if mc_ansp = null () then return;
	mpx_starname = rtrim (P_mpx_name) || ".*.**";

	do i = 1 to mc_anstbl.current_size;
	     mc_atep = addr (mc_anstbl.entry (i));
	     if mc_ate.flags.active
	     then do;
		call match_star_name_ (mc_ate.real_tty_name,
		     mpx_starname, autocode);
		if autocode = 0 then do;
		     if mc_ate.iocb ^= null () then do;
			if mc_anstbl.trace then call ioa_$ioa_switch
				(sc_stat_$master_iocb,
				"MC ^a listen_to_ttys: DETACHING.",
				mc_ate.real_tty_name);
			call iox_$close (mc_ate.iocb, (0));
			call iox_$detach_iocb (mc_ate.iocb, (0));
			call iox_$destroy_iocb (mc_ate.iocb, (0));
		     end;
		     if mc_anstbl.trace then call ioa_$ioa_switch
			     (sc_stat_$master_iocb,
			     "MC ^a listen_to_ttys: ATTACHING.",
			     mc_ate.real_tty_name);

		     call ATTACH_ATE (autocode);
		     if mc_anstbl.trace then do;
			if autocode = 0 then call ioa_$ioa_switch
				(sc_stat_$master_iocb,
				"MC ^a listen_to_ttys: ATTACHED",
				mc_ate.real_tty_name);
			else do;
			     call convert_status_code_ (autocode,
				(8)" ", error_string);
			     call ioa_$ioa_switch (sc_stat_$master_iocb,
				"MC ^a listen_to_ttys: ATTACH FAILED ^a",
				mc_ate.real_tty_name, error_string);
			end;
		     end;
		end;
	     end;
	end;
	return;

%page;
create_iocb: entry (P_mc_atep, code);

/**** Note, if this attach fails, we will have a null sci_ptr.  This will
      occur for tty channels if the multiplexer is not up.

      This routine is also called by mc_tty_ when the login server sends
      a DIALED_UP wakeup to our event channel.
****/

	mc_ansp = sc_stat_$mc_ansp;
	mc_atep = P_mc_atep;
	iocb_name = "mc" || unique_chars_ (""b) || "." ||
	     rtrim (mc_ate.real_tty_name);
	call iox_$attach_name (iocb_name, mc_ate.iocb,
	     "tty_ " || rtrim (mc_ate.real_tty_name) ||
	     " -hangup_on_detach -suppress_dial_manager",
	     codeptr (mc_commands_), code);
	if code ^= 0 then return;

	call iox_$control (mc_ate.iocb, "set_event_channel", addr (mc_ate.event), code); /* cannot be fast */
	if code ^= 0 then go to ERROR;

	call sc_create_sci_ (mc_ate.sci_ptr, code);
	if code ^= 0 then go to ERROR;

	mc_ate.oper_info.last_input_time = clock ();

	sc_subsystem_info_ptr = ssu_$get_info_ptr (mc_ate.sci_ptr);
	sc_subsystem_info.real_iocb = mc_ate.iocb;
	sc_subsystem_info.mc_atep = mc_atep;
	sc_subsystem_info.source_name = mc_ate.real_tty_name;
	sc_subsystem_info.restriction_flags = string (mc_ate.authority);
	sc_subsystem_info.print_ready = "1"b;		/* fake a prompt */
	call iox_$open (mc_ate.iocb, Stream_input_output, "0"b, code);
	if code ^= 0 then do;
	     if mc_ate.flags.virtual then goto ERROR;	/* Should not happen */
	     call iox_$control (mc_ate.iocb, "listen", null (), (0));
	     code = 0;
	end;
	call hcs_$wakeup (mc_anstbl.mc_procid, mc_ate.event, (0), (0)); /* cause mc_tty_ to notice the arrival. */
	return;

ERROR:
	call iox_$close (mc_ate.iocb, (0));
	call iox_$detach_iocb (mc_ate.iocb, (0));
	call iox_$destroy_iocb (mc_ate.iocb, (0));
	if mc_ate.event ^= 0
	then call ipc_$delete_ev_chn (mc_ate.event, (0));
	mc_ate.iocb = null ();
	return;



/* Internal Procedures Follow */
%page;

SEND_OPERATOR_RESPONSE: procedure (P_tty_name, P_code);

dcl  P_tty_name char (32) unaligned;
dcl  P_code fixed bin (35) parameter;
dcl  code fixed bin (35);

	call FILL_RESPONSE_STRUCTURE ();
	ls_operator_resp.status_code = P_code;

	call uc_send_ls_response_ (addr (ls_operator_resp),
	     size (ls_operator_resp), ls_process_id, ls_handle,
	     ls_event_channel, addr (zerobits),
	     (P_tty_name), 0, code);			/* log out user and drop line */

	return;
     end SEND_OPERATOR_RESPONSE;
%page;
SEND_TERMINATE_RESPONSE: procedure;

	unspec (ls_term_resp) = ""b;
	ls_term_resp.header.message_type = LS_TERMINATION_RESPONSE;
	ls_term_resp.header.version = LOGIN_SERVER_TERMINATION_RESPONSE_VERSION_1;
	ls_term_resp.process_id = mc_anstbl.mc_procid;
	wakeup_data_ptr = mc_atep;
	wakeup_data_len = size (mc_ate);
	ls_handle = mc_ate.ls_handle;
	ls_process_id = mc_ate.ls_procid;
	ls_event_channel = mc_ate.ls_term_ev_chn;

	call uc_send_ls_response_ (addr (ls_term_resp),
	     size (ls_term_resp), ls_process_id, ls_handle,
	     ls_event_channel, addr (zerobits),
	     (mc_ate.real_tty_name), 0, code);		/* log out user and drop line */
	return;
     end SEND_TERMINATE_RESPONSE;
%page;

DROP_CDT_TERMINAL: procedure (P_mc_atep, P_tty);

declare  P_mc_atep pointer parameter;
declare  P_tty char (32) unaligned parameter;
declare  wakeup_msg char (8);
declare  bin_msg fixed bin (71) based;
declare  mc_tty char (32) unaligned;

	mc_atep = P_mc_atep;
	mc_tty = P_tty;				/* channel name, only used in case mc_atep or mc_ate.cdtep = null */
	cdtep = null ();

	if mc_atep = null then cdtep = FIND_CDTE (mc_tty);
	else
	     if ^mc_ate.the_system_console then do;
	     if mc_ate.cdtep = null () then cdtep = FIND_CDTE (mc_tty);
	     else cdtep = mc_ate.cdtep;
	end;
	else do;
	     code = 0;				/* this is the booload console */
	     return;
	end;

	if cdtep ^= null ()
	then do;

	     if ^(cdte.in_use > NOW_FREE)
	     then go to SET_NO_ENTRY;			/* not ours now */

	     if cdte.service_type = MC_SERVICE
	     then do				/* usually an MC terminal */
		     cdte.in_use = NOW_HUNG_UP;
		cdte.current_service_type = INACTIVE;
						/* not now */
		return;				/* nothing more to do */
	     end;

	     if cdte.current_service_type = MC_SERVICE
	     then do;
		cdte.current_service_type = INACTIVE;

		call astty_$tty_event (cdtep, (0));
						/* get channel back from MC now */
		cdte.current_service_type = cdte.service_type;
						/* no longer */
		cdte.dialed_to_procid = "0"b;
		cdte.dial_ev_chn = 0;
		cdte.process = null ();
		cdte.tra_vec = WAIT_DIALUP;
		cdte.in_use = NOW_DIALED;
/**** Make dialup_ aware of the channel's new state. */
		wakeup_msg = "device";
		call hcs_$wakeup (as_data_$as_procid, cdte.event,
		     addr (wakeup_msg) -> bin_msg, code);
/**** If channel is authenticated, log it out */
		if cdte.flags.access_control.slave_dial
		then call lg_ctl_$logout_channel (cdtep, "drop");
	     end;
	     else if code ^= error_table_$ioname_not_found
	     then code = error_table_$action_not_performed;
	end;
	else

SET_NO_ENTRY:
	     code = error_table_$noentry;		/* +++ should be changed */
	return;

     end DROP_CDT_TERMINAL;
%page;

DELETE_IOCB: procedure (xp);


dcl  xp ptr parameter;				/* pointer to mc_ate entry */

	if ^(xp -> mc_ate.the_system_console) & (xp -> mc_ate.iocb ^= null)
	     & (mc_ate.cdtep ^= null)
	then do;
	     call iox_$control (xp -> mc_ate.iocb, "hangup", null (), (0));
	     call iox_$close (xp -> mc_ate.iocb, (0));
	     call iox_$detach_iocb (xp -> mc_ate.iocb, (0));
	     call iox_$destroy_iocb (xp -> mc_ate.iocb, (0));
	     call ipc_$delete_ev_chn (xp -> mc_ate.event, code);
	end;

	xp -> mc_ate.iocb = null ();
	xp -> mc_ate.real_tty_name = "";
	xp -> mc_ate.flags.pending = ""b;

/**** Check to see if we have deleted the terminal used for console recovery.
      This routine keys on mc_ate.active to find out if it has any good
      consoles left.  As far as console recovery goes, this terminal is no
      longer active; but if only the real channel of a vchannel is being
      dropped, the vchannel is still active.  Thus the twiddling of
      mc_ate.active below:   */

	mc_ate.active = ""b;
	call mc_con_rec_$check ();
	mc_ate.active = "1"b;


/**** Sign out any operator on this terminal.  And destroy the SSU
      invocation. */

	call SIGN_OUT (xp, old_operator_name, code);

/**** First check for a null sci_ptr.  This can happen if the multiplexer
      for this channel never came up. */

	if xp -> mc_ate.sci_ptr ^= null () then
	     do;
	     if code = 0				/* only if there was an operator signed on */
	     then call lg_ctl_$logout_operator (
		     ssu_$get_info_ptr (xp -> mc_ate.sci_ptr),
		     old_operator_name, "drop");
	     if ^xp -> mc_ate.the_system_console then
		call sc_create_sci_$destroy (xp -> mc_ate.sci_ptr);
	end;
	code = 0;
	return;

     end DELETE_IOCB;

%page;
KILL_TTY: procedure (xp);

dcl  xp ptr parameter;				/* pointer to mc_ate entry */

dcl  (j, jj, k) fixed bin;
dcl  qp ptr;

	if xp -> mc_ate.queue_event ^= 0
	then call ipc_$delete_ev_chn (xp -> mc_ate.queue_event, (0));


	if xp -> mc_ate.queue_ptr ^= null () then do;
	     qp = xp -> mc_ate.queue_ptr;
	     j = qp -> device_queue.top_of_queue;
	     do jj = 1 to 10000 while (j ^= 0);
		k = qp -> device_queue.line (j).source;
		if k > 0 then call SHAKE_SOURCE (MRT.source (k).hismess);
	     end;
	     call hcs_$truncate_seg (qp, 0, (0));
	end;

	xp -> mc_ate.flags.active,
	     xp -> mc_ate.flags.vchn_requires_accept,
	     xp -> mc_ate.flags.virtual = "0"b;		/* free the mc_ate entry */
	xp -> mc_ate.virtual_tty_name = "";
	string (xp -> mc_ate.control) = ""b;

	xp -> mc_ate.flags.signed_on = ""b;
	xp -> mc_ate.oper_info.personid = "";
	xp -> mc_ate.ls_procid = ""b;

	return;

     end KILL_TTY;
%page;
SEARCH_MC_ANSTBL: proc (typw, code) returns (ptr);
dcl  code fixed bin (35);
dcl  typw char (32);
dcl  xp ptr;
dcl  (i, j) fixed bin;

	mc_ansp = sc_stat_$mc_ansp;			/* Most entrypoints call this internal proc */
						/*  just after entry; let this proc set	    */
						/*  mc_ansp.			    */
	j = 0;
	do i = 1 to mc_anstbl.current_size;		/* Search through mc_anstbl */
	     xp = addr (mc_anstbl.entry (i));

	     if xp -> mc_ate.flags.active then		/* Entry in use? */
		if xp -> mc_ate.virtual_tty_name = typw
		     | xp -> mc_ate.real_tty_name = typw
						/* That's us! Say it, go home */
		then do;
		     code = 0;
		     return (xp);
		end;
		else ;
	     else if xp -> mc_ate.flags.pending		/* pending & ^vchn */
	     then if xp -> mc_ate.real_tty_name = typw
						/* That's us ! */
		then do;
		     code = error_table_$ioname_not_active;
		     return (xp);
		end;
		else ;

	     else if j = 0 then j = i;		/* An empty entry; remember first one. */
	     else ;

	end;
	if j = 0 then xp = null;
	else xp = addr (mc_anstbl.entry (j));
	code = error_table_$ioname_not_found;
	return (xp);

     end SEARCH_MC_ANSTBL;
%page;
SEARCH_VCONS_TAB: proc (vcon, vce, code) returns (ptr);
dcl  code fixed bin (35);
dcl  vcon char (*);
dcl  vce fixed bin;
dcl  xp ptr;
dcl  j fixed bin;

	if vcon = "*" then
	     do;
	     vce = 0;
	     xp = addr (vcons_tab.star_entry);
	     code = 0;
	     return (xp);
	end;
	j = 0;
	do vce = 1 to vcons_tab.no_of_vcons;
	     xp = addr (vcons_tab.vcons (vce));
	     if ^(xp -> vcons.flags.inuse) then		/* Empty entry? */
		if j = 0 then j = vce;		/* .. yes. remember first one. */
		else ;
	     else if xp -> vcons.vcons = vcon then
		do;
		code = 0;
		return (xp);
	     end;
	end;
	if j = 0 then xp = null;			/* Currently always happens */
	else xp = addr (vcons_tab.vcons (j));
	vce = j;
	code = error_table_$ioname_not_found;
	return (xp);

     end SEARCH_VCONS_TAB;

SHAKE_SOURCE: proc (xp);

dcl  xp ptr;

	if xp = null then return;
	if xp -> syscon_mseg.mescount ^= 0 then do;
	     xp -> syscon_mseg.mescount = 0;
	     if xp -> syscon_mseg.output_wait then do;
		xp -> syscon_mseg.output_wait = "0"b;
		call hcs_$wakeup (xp -> syscon_mseg.current_process_id,
		     xp -> syscon_mseg.ipc_el.channel, 0, code);
	     end;
	end;

     end SHAKE_SOURCE;
%page;
FILL_RESPONSE_STRUCTURE: procedure ();

	must_send_operator_response = "1"b;

	unspec (ls_operator_resp) = ""b;
	ls_operator_resp.header.message_type = LS_OPERATOR_RESPONSE;
	ls_operator_resp.header.version = LOGIN_SERVER_OPERATOR_RESPONSE_VERSION_1;
	ls_operator_resp.status_code = 0;
	ls_operator_resp.process_group_id = get_group_id_ ();
	ls_operator_resp.process_id = mc_anstbl.mc_procid;
	ls_operator_resp.event_channel = mc_ate.event;
	ls_operator_resp.ring = get_ring_ ();

	wakeup_data_ptr = mc_atep;
	wakeup_data_len = size (mc_ate);

	ls_handle = mc_ate.ls_handle;
	ls_process_id = mc_ate.ls_procid;
	ls_event_channel = mc_ate.ls_resp_ev_chn;

	return;

     end FILL_RESPONSE_STRUCTURE;
%page;
CONNECT_PHYSICAL_CHANNEL: procedure ();

	on cleanup begin;
	     call CPC_ERROR ();
	end;

	mc_ate.flags.signed_on = ^(mc_ate.oper_info.personid = "");

	if mc_ate.ls_procid = ""b
	then do;
	     mc_ate.real_tty_name = char32;
	     call ipc_$create_ev_chn (mc_ate.event, code);/* system console or not */
	     if code ^= 0 then go to CPC_ERROR_RETURN;

	     call ipc_$decl_ev_call_chn (mc_ate.event,
		mc_anstbl.cons_cont_proc, mc_atep, MC_PRIO, code);
	     if code ^= 0 then go to CPC_ERROR_RETURN;
	end;

	if mc_ate.real_tty_name = "otw_"
	then do;
	     mc_ate.flags.the_system_console = "1"b;
	     mc_ate.iocb = sc_stat_$master_iocb;
	     mc_ate.sci_ptr = sc_stat_$master_sci_ptr;
	end;
	else if must_send_operator_response		/* network line */
	then do;					/* wait for connect wakeup */
	     mc_ate.tra_vec = MC_WAIT_DIALUP;
	     call uc_send_ls_response_ (addr (ls_operator_resp),
		size (ls_operator_resp), ls_process_id,
		ls_handle, ls_event_channel, addr (zerobits),
		(mc_ate.real_tty_name), 0, code);

	     must_send_operator_response = ""b;
	     return;
	end;

	else do;
	     call ATTACH_ATE (code);
	     if code = error_table_$invalid_device	/* FNP down */
	     then code = 0;
	end;

	if code = 0 then return;

CPC_ERROR_RETURN:
	call CPC_ERROR ();
	return;

CPC_ERROR: procedure ();

	     if mc_ate.iocb ^= null () & char32 ^= "otw_"
	     then do;
		call iox_$close (mc_ate.iocb, (0));
		call iox_$detach_iocb (mc_ate.iocb, (0));
		call iox_$destroy_iocb (mc_ate.iocb, (0));
	     end;

	     mc_ate.flags.pending = ""b;
	     if ^mc_ate.flags.virtual			/* don't inactivate vchannels */
	     then mc_ate.flags.active = "0"b;
	     mc_ate.real_tty_name = "";
	     call ipc_$delete_ev_chn (mc_ate.event, (0));

	     return;
	end CPC_ERROR;

     end CONNECT_PHYSICAL_CHANNEL;
%page;
ATTACH_ATE:
     procedure (code);

declare  code fixed bin (35);
declare  cdtx fixed bin;
declare  fnp bit (1) aligned;

	if mc_ate.ls_procid = ""b then do;
	     call cdt_mgr_$find_cdt_channel (as_data_$cdtp,
		mc_ate.real_tty_name, cdtx, fnp, code);
	     if code ^= 0 then return;
	     if fnp then do;
		code = error_table_$ioname_not_found;
		return;
	     end;
	     cdtep = addr (as_data_$cdtp -> cdt.cdt_entry (cdtx));
	     mc_ate.cdtep = cdtep;
	     if cdte.in_use = 0 |
		cdte.current_service_type ^= MC_SERVICE
	     then do;
		code = error_table_$ioname_not_found;
		return;
	     end;
	end;

	mc_ate.tra_vec = MC_WAIT_DIALUP;
	mc_ate.sci_ptr = null ();			/* easier to check for null () */

	if mc_ate.ls_procid = ""b
	then call create_iocb (mc_atep, code);
	else ;					/* mc_tty_ will create the iocb for network channels
						   when the login server sends it a DIALED_UP wakeup */
	return;

     end ATTACH_ATE;
%page;
SIGN_OUT:
     procedure (MC_atep, Ex_operator_name, Code);

/**** This procedure actually does the work of signing out an MC terminal. */

dcl  MC_atep ptr parameter;
dcl  Ex_operator_name char (*) parameter;
dcl  Code fixed bin (35) parameter;

	mc_atep = MC_atep;
	Code = 0;
	if ^mc_ate.signed_on
	then Code = error_table_$action_not_performed;
	else do;
	     Ex_operator_name = mc_ate.oper_info.personid;
	     mc_ate.oper_info.personid = "";
	     mc_ate.signed_on = "0"b;
	end;
	return;
     end SIGN_OUT;
%page;
ABORT_DIALIN:
     procedure (P_ec, P_reason);

dcl  P_ec fixed bin (35) parameter;
dcl  P_reason char (*) parameter;

dcl  action fixed bin (17);
dcl  code_reason char (150) varying;
dcl  code_reason_al char (100) aligned;

	if P_ec = 0
	then code_reason = P_reason;
	else do;
	     call convert_status_code_ (P_ec, (""), code_reason_al);
	     code_reason = rtrim (code_reason_al);
	     if P_reason ^= ""
	     then do;
		code_reason = code_reason || ", ";
		code_reason = code_reason || rtrim (P_reason);
	     end;
	end;

	if utep ^= null ()
	then do;

	     action = -AS_AUDIT_CHANNEL_DIALIN;

	     CAI.channel_name = ute.tty_name;
	     CAI.valid = FALSE;
	     if vchannel = "" then CAI.valid.service_info = FALSE;
	     else CAI.valid.service_info = TRUE;
	     if CAI.valid.service_info then do;
		if mc_atep ^= null then
		     CAI.service_info = mc_ate.virtual_tty_name;
		else CAI.service_info = "Unknown";
	     end;
	     else CAI.service_info = "system";
	     CAI.valid.access_class = FALSE;
	     CAI.access_class = FALSE;
	     CAI.valid.access_class_range = FALSE;
	     CAI.access_class_range = access_class_range;
	     CAI.valid.user_validation_level = TRUE;
	     CAI.user_validation_level = iutep -> ute.initial_ring;
	     call as_access_audit_$channel (null, utep, iutep, action, addr (CAI), (code_reason));
	end;

	if P_ec ^= 0
	then code = P_ec;				/* export this error code */
	else code = as_error_table_$dialnotup;		/* default error message */

	return;

     end ABORT_DIALIN;
%page;
DIALIN_OK:
     procedure ();

dcl  action fixed bin (17);

	action = AS_AUDIT_CHANNEL_DIALIN;

	CAI.channel_name = ute.tty_name;
	CAI.valid = FALSE;
	if vchannel = "" then CAI.valid.service_info = FALSE;
	else CAI.valid.service_info = TRUE;
	if CAI.valid.service_info then do;
	     if mc_atep ^= null then
		CAI.service_info = mc_ate.virtual_tty_name;
	     else CAI.service_info = "Unknown";
	end;
	else CAI.service_info = "system";
	CAI.valid.access_class = TRUE;
	CAI.access_class = FALSE;
	CAI.valid.access_class_range = FALSE;
	CAI.access_class_range = access_class_range;
	CAI.valid.user_validation_level = TRUE;
	CAI.user_validation_level = iutep -> ute.initial_ring;

	call as_access_audit_$channel (null, utep, iutep, action, addr (CAI), "");
     end DIALIN_OK;
%page;
FIND_CDTE:
     procedure (P_tty_name) returns (ptr);

dcl  P_tty_name char (*) parameter;

dcl  cdtx fixed bin (17) automatic;
dcl  cdte_ptr pointer;
dcl  tty_name char (32);
dcl  fnp bit (1) aligned;

	tty_name = P_tty_name;
	call cdt_mgr_$find_cdt_channel (as_data_$cdtp, tty_name, cdtx, fnp, code);
	if code = 0 & ^fnp then do;
	     cdte_ptr = addr (as_data_$cdtp -> cdt.cdt_entry (cdtx));
	     return (cdte_ptr);
	end;
	else return (null ());

     end FIND_CDTE;
%page;

/* format: off */
%page; %include access_audit_bin_header;
%page; %include answer_table;
%page; %include as_audit_structures;
%page; %include as_data_;
%page; %include as_wakeup_priorities;
%page; %include author_dcl;
%page; %include cdt;
%page; %include daemon_user_table;
%page; %include device_queue;
%page; %include dialup_values;
%page; %include iox_entries;
%page; %include iox_modes;
%page; %include login_server_messages;
%page; %include mc_anstbl;
%page; %include mess_route_table;
%page; %include sc_stat_;
%page; %include sc_subsystem_info_;
%page; %include sys_log_constants;
%page; %include syscon_mseg;
%page; %include user_attributes;
%page; %include user_table_entry;
%page; %include user_table_header;
%page; %include vcons_tab;
%page;
/* BEGIN MESSAGE DOCUMENTATION

   Message:
   mc_commands_$mc_login: error: Channel XXXX already in use.

   S:	sc (error_output)

   T:	$response

   M:     The channel specified for MNA attachment is
   already in use by the message coordinator.

   A:	$tryagain

   Message:
   mc_commands_$mc_login:  Channel XXXX dialed to Initializer (NAME).

   S:	as (severity 1)

   T:	In response to a message coordinator dial request.

   M:     Informative message indicating that a successful dialin occured on
   the specified channel by the named operator.  A subsequent accept is
   required by an authenticated operator to complete the attachment.

   A:     $ignore

   Message:
   mc_commands_$mc_login:  Channel XXXX dialed to Initializer (NAME ACCEPTED).

   S:	as (severity 1)

   T:	In response to a message coordinator dial request.

   M:     Informative message indicating that a successful dialin occured on
   the specified channel by the named operator.

   A:     $ignore

   Message:
   mc_commands_$mc_login:  Channel XXXX vchannel (YYYY) dialed to Initializer (NAME).

   S:	as (severity 1)

   T:	In response to a message coordinator dial request.

   M:     Informative message indicating that a successful dialin occured on
   the specified channel by the named operator.  A subsequent accept is
   required by an authenticated operator to complete the attachment.

   A:     $ignore

   Message:
   mc_commands_$mc_login:  Channel XXXX vchannel (YYYY) dialed to Initializer (NAME ACCEPTED).

   S:	as (severity 1)

   T:	In response to a message coordinator dial request.

   M:     Informative message indicating that a successful dialin occured on
   the specified channel by the named operator.

   A:     $ignore

   Message:
   Unable to locate a CDT entry for XXXX while attempting to drop it.

   S:	as (severity 1)

   T:	In response to a drop operator command.

   M:     Notification that the CDT entry cannot be found to free it as
   a result of dropping the tty channel from the message coordinator.
   The mc_anstbl entry is freed at this point however.

   A:     $ignore

   END MESSAGE DOCUMENTATION */

     end mc_commands_;
