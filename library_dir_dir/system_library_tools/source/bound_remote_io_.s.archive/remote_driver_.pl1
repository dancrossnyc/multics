/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/* format: style4 */

/* format: off */

/* Standard remote device driver control module for the I/O daemon. */

/* Adapted from g115_driver_ by David Vinograd - March 1977 */
/* Modified by J. C. Whitmore, 4/78, for new dprint_msg format and Daemon upgrade */
/* Modified by J. C. Whitmore, 8/78, to defer requests over phys ll and for auto defer time init */
/* Modified by J. C. Whitmore, 10/78, to extend the number of RJE stations */
/* Modified by J. C. Whitmore, 3/79, for minor bug fixes */
/* Modified by C. Hornig, 6/79, for multiple minor devices of the same generic type */
/* Modified by J. C. Whitmore, 10/79, for binary punching and commands sep_cards, punch, pun_control */
/* Modified: 2 April 1981 by G. Palter correct a bug which causes use of "logout", "new_device", etc. requests during the
      processing of a request to cause a null pointer fault by iox_ followed by flushing the remaining requests
      in the queue */
/* Modified: October 1981 by C. Hornig to support attach_type 3 (dial_id) */
/* Modified: 9 November 1981 by G. Palter to use read_password_ to get the station password if it is omitted from the
      station command */
/* Modified: 17 November 1981 by G. Palter to not consider inability to set hangup_proc as fatal */
/* Modified: 11 December 1981 by G. Palter to support auto_go and force_ctl_char for printer minor devices */
/* Modified: November 1983 by C. Marker Added support for force_nsep */
/* Modified: January 1984 by C. Marker  Added probe as a legal command in test mode. */
/* Modified 1984-08-17 by E. Swenson for Version 2 PNTs. */
/* Modified 14 Feb 1984 by Jim Homan for logout_on_hangup */
/* Modified: February 23, 1985 by C. Marker to use version 5 message segments */


/****^  HISTORY COMMENTS:
  1) change(84-02-14,Homan), approve(87-04-06,MCR7656),
     audit(87-06-13,Beattie), install(87-08-06,MR12.1-1068):
     Submit logout_on_hangup changes for installation.
  2) change(87-05-01,Gilcrease), approve(87-05-14,MCR7686),
     audit(88-02-01,Farley), install(88-02-02,MR12.2-1019):
     Update to version 4 dprint_msg.
  3) change(88-02-18,Brunelle), approve(88-06-28,MCR7911),
     audit(88-10-26,Parisek):
     Add support for single/continuous paper type.
  4) change(88-08-29,Farley), approve(88-06-28,MCR7911),
     audit(88-10-26,Parisek):
     Updated for version 5 dprint_msg.
  5) change(88-10-31,Brunelle), approve(88-10-31,MCR7911),
     audit(88-11-01,Wallman):
     Correct problem of requiring a model name if single sheet mode defined.
                                                   END HISTORY COMMENTS */


/* format: on */

remote_driver_:
     procedure ();

	return;					/* this is not a legal entry */

/* Parameters */

dcl  a_argp ptr parameter;
dcl  a_source fixed bin parameter;			/* 1 = master console, 2 = slave */
dcl  a_state fixed bin parameter;			/* 0 = not quite ready to handle a request */
						/* 1 = drivers are ready */
						/* 2 = command entered after a quit */
dcl  a_stream char (*) parameter;
dcl  a_banner_type fixed bin parameter;			/* type of banner to be written  */
						/* 1 = heading banner            */
						/* 2 = tail banner               */
						/* 3 = error message             */
dcl  a_data_ptr ptr parameter;			/* pointer to output request data or  */
						/* to char(256) varying string error msg */
dcl  a_code fixed bin (35) parameter;			/* error code */

/* Automatic */

dcl  age fixed bin;
dcl  arg_string char (32);
dcl  argp ptr;
dcl  attach_desc char (256) var;
dcl  banner_type fixed bin;
dcl  code fixed bin (35);
dcl  control bit (36) aligned;
dcl  date_string char (24);
dcl  device_type char (32);
dcl  digit char (1);
dcl  element_size fixed bin;
dcl  err_msg char (200);
dcl  format_code fixed bin;
dcl  header_card2 char (80);
dcl  (i, idx) fixed bin;				/* general index variable */
dcl  ignore_code fixed bin (35);			/* error code to be ignored */
dcl  input_line char (80);
dcl  len fixed bin;
dcl  iocbp ptr;
dcl  major_args char (major_args_length) based (major_args_ptr);
dcl  major_args_length fixed bin int static;
dcl  major_args_name char (256) varying;
dcl  major_comm_module char (32) var;
dcl  major_desc char (256) var;
dcl  major_terminal_module char (32) var;
dcl  major_tty char (32) var;
dcl  minor_args char (minor_args_length) based (minor_args_ptr);
dcl  minor_args_length fixed bin int static;
dcl  minor_args_name char (256) varying;
dcl  model char (32) var;
dcl  my_area area based (my_area_ptr);			/* area to allocate in */
dcl  nchar fixed bin;
dcl  need_station bit (1);
dcl  new_ll fixed bin;				/* temp for the new phys line length */
dcl  new_lpi fixed bin;				/* and for the new lines per inch value */
dcl  new_pl fixed bin;				/* temp for setting the phys page length */
dcl  not bit (1);
dcl  omode char (256);
dcl  opr_msg char (160);				/* message to tell operator we are ready, etc. */
dcl  p ptr;
dcl  p2 ptr;
dcl  pos fixed bin;
dcl  pool_dir char (168);				/* dirname for the card pool root */
dcl  printer_count fixed bin;				/* number of printer minor devices (during init) */
dcl  punch_count fixed bin;				/* number of punch minor devices (during init) */
dcl  ready_device bit (1) aligned;			/* ON => there's at least one minor device that's ready */
dcl  req_string char (12);				/* place for the request number as characters */
dcl  rqt_string char (168) var;
dcl  save_code fixed bin (35);
dcl  source fixed bin;
dcl  state fixed bin;
dcl  station char (32);
dcl  station_password char (8);
dcl  status bit (72) aligned;				/* status code for old ios_ calls */
dcl  stream char (32) aligned;
dcl  temp_password char (8);
dcl  1 term_info aligned like terminal_info;
dcl  tries fixed bin;
dcl  value fixed bin;


dcl  st_code fixed bin (35) based;			/* first word of the ios_ status */
%page;

dcl  1 form_info aligned,				/* data from the form paging dim */
       2 page_length fixed bin,
       2 line_length fixed bin,
       2 line_no fixed bin,
       2 carriage_position fixed bin,
       2 aligned bit (1) unal,			/* tells if the dim considers the forms aligned */
       2 pad bit (35) unal;

dcl  1 hangup_info aligned,				/* structure used to set hangup_info proc */
       2 entry entry,
       2 data_ptr ptr,
       2 priority fixed bin;

dcl  1 read_info aligned,
       2 read_ev_chan fixed bin (71),
       2 input_ready bit (1) unal;

dcl  1 ev_chan_list aligned based,
       2 number fixed bin,
       2 channel (12) fixed bin (71);


dcl  1 cmd_list int static aligned,			/* iodd_parse_$command structure for request command level */
       2 max fixed bin init (5),			/* allow command and four args max */
       2 number_tokens_found fixed bin,
       2 cmd char (64) var,				/* the command part of the line */
       2 arg (4) char (64) var;			/* the arguments */

/* Based Variables */

dcl  sys_dir char (168) based;

dcl  1 arg_list aligned based (argp),			/* iodd_parse_$command structure */
       2 max_tokens fixed bin,			/* space allocated, do not change */
       2 n_tokens fixed bin,				/* number of tokens from command line (including cmd) */
       2 command char (64) var,			/* the first token is the command */
       2 arg (n_tokens - 1) char (64) var;		/* the other tokens are args to the command */

dcl  pun_ctl_ptr ptr;

dcl  1 pun_ctl based (pun_ctl_ptr),			/* punch control structure */
       2 sep_cards fixed bin,				/* 0 = none, 1 = standard: what type of separators to punch */
       2 modes,
         3 auto_punch bit (1) unal;			/* FALSE if we should come to request command level */
%page;

/* External Entries */

dcl  add_char_offset_ entry (ptr, fixed bin (21)) returns (ptr) reducible;
dcl  continue_to_signal_ entry (fixed bin (35));
dcl  date_time_ entry (fixed bin (71), char (*));
dcl  debug entry ();
dcl  do_prt_request_ entry (ptr, ptr, fixed bin (35));
dcl  do_prt_request_$error_during_request entry (char (*));
dcl  do_prt_request_$single_copy entry ();
dcl  expand_pathname_$add_suffix entry (char (*), char (*), char (*), char (*), fixed bin (35));
dcl  expand_pathname_$component entry (char (*), char (*), char (*), char (*), fixed bin (35));
dcl  get_system_free_area_ entry () returns (ptr);
dcl  initiate_file_$component entry (char (*), char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));
dcl  ioa_$rsnnl entry options (variable);
dcl  iodd_command_processor_ entry (fixed bin, fixed bin, char (*) aligned, fixed bin (35));
dcl  iodd_get_cmd_ entry (ptr, fixed bin, fixed bin, bit (36) aligned, char (*), fixed bin, fixed bin (35));
dcl  iodd_hangup_$iodd_hangup_ entry;
dcl  iodd_listen_ entry (ptr);
dcl  iodd_msg_ entry options (variable);
dcl  iodd_parse_$args entry (char (*) var, char (*)) returns (char (256) var);
dcl  ios_$attach entry (char (*), char (*), char (*), char (*), bit (72) aligned);
dcl  iox_$attach_ioname entry (char (*), ptr, char (*), fixed bin (35));
dcl  iox_$attach_ptr entry (ptr, char (*), ptr, fixed bin (35));
dcl  iox_$close entry (ptr, fixed bin (35));
dcl  iox_$control entry (ptr, char (*), ptr, fixed bin (35));
dcl  iox_$detach_iocb entry (ptr, fixed bin (35));
dcl  iox_$get_line entry (ptr, ptr, fixed bin, fixed bin, fixed bin (35));
dcl  iox_$look_iocb entry (char (*) aligned, ptr, fixed bin (35));
dcl  iox_$modes entry (ptr, char (*), char (*), fixed bin (35));
dcl  iox_$open entry (ptr, fixed bin, bit (36), fixed bin (35));
dcl  iox_$put_chars entry (ptr, ptr, fixed bin, fixed bin (35));
dcl  ipc_$block entry (ptr, ptr, fixed bin (35));
dcl  ipc_$drain_chn entry (fixed bin (71), fixed bin (35));
dcl  output_request_ entry (char (*), fixed bin, ptr, entry, fixed bin (35));
dcl  output_request_$error_during_request entry (char (*));
dcl  output_request_$set_single_copy entry ();
dcl  iod_info_$evaluate_forms_info entry (ptr, ptr, ptr, fixed bin (35));
dcl  iodd_parse_$command entry (char (*) aligned, ptr, fixed bin (35));
dcl  message_facility_$send_message_access_class entry (char (*), char (*), char (*), ptr, bit (72) aligned, fixed bin (35));
dcl  pool_manager_$clean_pool entry (char (*), fixed bin, fixed bin, fixed bin (35));
dcl  pool_manager_$init entry (char (*), fixed bin, bit (36) aligned, fixed bin (35));
dcl  probe entry ();
dcl  read_cards_ entry (char (*), ptr, char (*), bit (1) aligned, fixed bin (35));
dcl  read_cards_$set_rqt entry (char (*), char (*), fixed bin (35));
dcl  read_cards_$set_station entry (char (*), fixed bin (35));
dcl  read_password_$switch entry (ptr, ptr, char (*), char (*), fixed bin (35));
dcl  scramble_ entry (char (8)) returns (char (8));
dcl  set_iod_val entry (char (*), char (*));
dcl  (system_privilege_$ipc_priv_off,
     system_privilege_$ipc_priv_on,
     system_privilege_$ring1_priv_off,
     system_privilege_$ring1_priv_on) entry (fixed bin (35));
dcl  timer_manager_$alarm_wakeup entry (fixed bin(71), bit(2), fixed bin(71));
dcl  timer_manager_$sleep entry (fixed bin (71), bit (2));
dcl  validate_card_input_$station entry (char (*), char (*), char (*), fixed bin (35));
dcl  write_control_form_ entry (char (*) aligned, char (*) aligned, ptr, fixed bin (35));
dcl  write_sample_form_ entry (char (*) aligned, char (*) aligned, fixed bin (35));
dcl  write_sample_prt_banner_ entry (char (*), ptr, ptr, fixed bin (35));
%page;

/* Constants */

dcl  FALSE bit (1) int static options (constant) init ("0"b);
dcl  TRUE bit (1) int static options (constant) init ("1"b);
dcl  NL char (1) int static options (constant) init ("
");						/* the new-line character */

dcl  FF char (1) int static options (constant) init ("");						/* the form feed character */

dcl  STATION_PW_PROMPT char (23) static options (constant) init ("Enter station password:");
dcl  both fixed bin int static options (constant) init (0); /* master and slave for iodd_msg_ */
dcl  default_form_wait_time fixed bin int static options (constant) init (5);
dcl  error fixed bin int static options (constant) init (2);
dcl  error_message fixed bin int static options (constant) init (3);
dcl  head_banner fixed bin int static options (constant) init (1);
dcl  initial_print_rate fixed bin int static options (constant) init (3000); /* bits per second to the printer */
dcl  initial_punch_rate fixed bin int static options (constant) init (500); /* same for the punch */
dcl  line_length_default fixed bin int static options (constant) init (132);
dcl  line_length_max fixed bin int static options (constant) init (200);
dcl  line_length_min fixed bin int static options (constant) init (10);
dcl  log fixed bin int static options (constant) init (0);
dcl  lpi_default fixed bin int static options (constant) init (6);
dcl  lpi_max fixed bin int static options (constant) init (8);
dcl  lpi_min fixed bin int static options (constant) init (6);
dcl  master fixed bin int static options (constant) init (1);
dcl  minimum_quota fixed bin int static options (constant) init (10);
dcl  myname char (15) int static init ("remote_driver_") options (constant);
dcl  none fixed bin int static options (constant) init (0);
dcl  normal fixed bin int static options (constant) init (1);
dcl  page_length_default fixed bin int static options (constant) init (66);
dcl  page_length_max fixed bin int static options (constant) init (127);
dcl  page_length_min fixed bin int static options (constant) init (10);
dcl  pause_time_default fixed bin int static options (constant) init (10);
dcl  pause_time_max fixed bin int static options (constant) init (30);
dcl  printer_mode fixed bin int static options (constant) init (1);
dcl  printer_request fixed bin int static options (constant) init (1);
dcl  punch_raw_mode fixed bin int static options (constant) init (4);
dcl  punch_request fixed bin int static options (constant) init (2);
dcl  punch_rmcc_mode fixed bin int static options (constant) init (3);
dcl  request_command_level_state fixed bin int static options (constant) init (3);
dcl  runout_spacing_max fixed bin int static options (constant) init (60);
dcl  separator char (80) int static options (constant) init ((80)"<");
dcl  slave fixed bin int static options (constant) init (2);
dcl  slave_login_tries fixed bin int static options (constant) init (10);
dcl  space char (1) int static options (constant) init (" ");
dcl  standard fixed bin int static options (constant) init (1);
dcl  tail_banner fixed bin int static options (constant) init (2);
dcl  wakeup_time_default fixed bin int static options (constant) init (30);
dcl  zero fixed bin int static options (constant) init (0);
dcl  zero_code fixed bin int static options (constant) init (0);

/* Internal Static   */

dcl  alarm_channel fixed bin (71) int static;		/* channel used for time out checks */
dcl  ctl_msg_sent bit (1) int static init (FALSE);	/* flag set when msg sent ok */
dcl  default_printer pointer init (null ()) int static;	/* default printer driver_status pointer for commands */
dcl  default_punch pointer init (null ()) int static;	/* default punch driver_status pointer for commands */
dcl  hangup_proc_defined bit (1) int static;		/* TRUE if the device hangup proc has been set */
dcl  major_args_ptr ptr int static init (null);
dcl  minor_args_ptr ptr int static init (null);
dcl  my_area_ptr ptr int static init (null);
dcl  prt_rqt char (32) int static;
dcl  pun_rqt char (32) int static;
dcl  reader_attached bit (1) int static;		/* TRUE if the read cards command can be used */
dcl  save_request_label label int static;		/* for transfer on save command at request cmd level */
dcl  sys_priv bit (1) int static init ("1"b);		/* ON means user can set privs */
dcl  teleprinter_iocbp pointer init (null ()) int static;
dcl  terminal (2) char (32) int static;
dcl  time fixed bin (71) int static init (10);

dcl  1 ctl_wait_list int static aligned,		/* ipc wait list for the form terminal */
       2 number fixed bin,
       2 channel fixed bin (71);

dcl  1 event_info int static aligned,			/* info returned from ipc_$block */
       2 chan fixed bin (71),
       2 message fixed bin (71),
       2 sender bit (36),
       2 origin fixed bin,
       2 wait_list_index fixed bin;
%page;

dcl  1 card_info aligned int static like card_stream_info;	/* card input stream data */

dcl  1 smi aligned int static like send_mail_info;

/* Builtins */

dcl  (addr, after, before, char, character, clock, convert, copy, divide, index, length, ltrim, max, mod, null, rtrim, string, substr) builtin;

/* Conditions */

dcl  (any_other, card_command_level, cleanup, conversion,
     daemon_logout, daemon_new_device, daemon_slave_logout,
     linkage_error, no_coord, re_init, size) condition;

/*	EXTERNAL STATIC -- ERROR TABLE ENTRIES     */

dcl  error_table_$action_not_performed fixed bin (35) ext static;
dcl  error_table_$fatal_error fixed bin (35) ext static;
dcl  error_table_$io_no_permission fixed bin (35) ext static;
dcl  error_table_$ionmat fixed bin (35) ext static;
dcl  error_table_$no_operation fixed bin (35) ext static;
dcl  error_table_$noarg fixed bin (35) ext static;
dcl  error_table_$no_forms_table_defined fixed bin (35) ext static;
dcl  error_table_$not_closed fixed bin (35) ext static;
dcl  error_table_$not_detached fixed bin (35) ext static;
dcl  error_table_$undefined_order_request fixed bin (35) ext static;
dcl  iox_$error_output ext ptr;
%page;

/* This entrypoint is used to initialize the driver for the major and any
   minor devices defined. It is called from iodd_. */
init: entry (a_argp);

	on daemon_logout call drop_device;
	on daemon_slave_logout go to logout_slave;
	on daemon_new_device call drop_device;
	on no_coord call drop_device;

	stat_p = a_argp;				/* put the arg into static for easy reference */
	list_ptr = iodd_static.driver_list_ptr;		/* find list of driver status segs */
	text_strings_ptr = iodd_static.text_strings_ptr;	/* get ptr to i/o daemon table text area */

	if iodd_static.attach_type = ATTACH_TYPE_IOM then do; /* this driver expects a tty channel */
	     call iodd_msg_ (error, master, error_table_$fatal_error, myname,
		"The remote driver cannot attach to the IOM.");
	     return;				/* quit now */
	end;

	do i = 1 to iodd_static.assigned_devices;	/* initialize pointers for cleanup handler */
	     driver_ptr_list.stat_segp (i) -> driver_status.dev_out_iocbp = null ();
	     driver_ptr_list.stat_segp (i) -> driver_status.dev_ctl_ptr = null ();
	end;
	teleprinter_iocbp = null;

	iodd_static.dev_io_stream, iodd_static.dev_in_stream = "Undefined_stream!";
						/* we don't use these in this proc */

	on cleanup call detach_device;

/* this is the Type I station case
   "line:  variable;" from iod_tables */
	if iodd_static.attach_type = ATTACH_TYPE_VARIABLE_LINE then do;
	     ltep = addr (iodd_static.ltp -> line_tab.entries (iodd_static.line_tab_idx));

	     major_terminal_module, major_comm_module, major_tty = "";
	     call ioa_$rsnnl (return_string (lte.att_desc), major_desc, len, lte.chan_id);

	     teleprinter_iocbp = iodd_static.slave_in;	/* copy the iocbp set by iodd_ */

	     station = iodd_static.major_device;	/* these are the same for this case */

	     do i = 1 to iodd_static.assigned_devices;
		p = driver_ptr_list.stat_segp (i);
		p -> driver_status.attached = TRUE;	/* all will be used now */
	     end;
	     hangup_proc_defined = TRUE;		/* this was set by iodd_ for this type */
	end;
	else do;					/* this is the Type II station case */

	     hangup_proc_defined = FALSE;		/* be sure we set the hangup proc */

/* see if user wants major args to be found in a segment */
	     major_args_ptr = add_char_offset_ (addr (text_strings.chars), iodd_static.major_args.first_char - 1);
	     major_args_length = iodd_static.major_args.total_chars;
	     major_args_name = iodd_parse_$args ("indirect=", major_args);
	     if major_args_name ^= "" then do;		/* yes, grab that segment */
		call initiate_the_file (major_args_name, major_args_ptr, major_args_length, "major_args", code);
		if code ^= 0 then
		     go to clean_out;
	     end;
	     major_terminal_module, iodd_static.device_dim = iodd_parse_$args ("terminal=", major_args);

	     major_comm_module = iodd_parse_$args ("comm=", major_args);

	     major_tty = rtrim (iodd_static.attach_name);

	     model = iodd_parse_$args ("model=", major_args);

/* start building the attach description */
	     if iodd_static.attach_type = ATTACH_TYPE_DIAL then
		major_desc = "-tty ** -dial_id " || major_tty;
	     else major_desc = "-tty " || major_tty;

	     if major_terminal_module ^= "" then
		major_desc = major_desc || " -terminal " || major_terminal_module;

	     if major_comm_module ^= "" then
		major_desc = major_desc || " -comm " || major_comm_module;

	     major_desc = major_desc || space || iodd_parse_$args ("desc=", major_args);

	     call iodd_msg_ (normal, master, zero_code, "", "Attaching terminal.");

	     if iodd_parse_$args ("logout_on_hangup=", major_args) = "yes" then
		iodd_static.logout_on_hangup = TRUE;

	     if iodd_parse_$args ("slave=", major_args) = "yes" then do; /* is device also the slave? */

		iodd_static.slave_output = get_switch_name ("teleprinter");
		iodd_static.slave_input = iodd_static.slave_output;
						/* make them the same */

		attach_desc = "remote_teleprinter_ " || major_desc;
						/* build the real attach description */

		opr_msg = "ATTACH";
		call iox_$attach_ioname ((iodd_static.slave_output), teleprinter_iocbp, (attach_desc), code);
		if code ^= 0 & code ^= error_table_$ionmat & code ^= error_table_$not_detached then
		     go to tp_err;

		opr_msg = "OPEN";
		call iox_$open (teleprinter_iocbp, Stream_input_output, ""b, code);
		if code ^= 0 & code ^= error_table_$not_closed then do;
tp_err:
		     call iodd_msg_ (error, master, code, myname, "Unable to ""^a"" teleprinter for ^a.", opr_msg,
			iodd_static.attach_name);
		     call iodd_msg_ (normal, master, zero_code, "", "Attach description: ^a", attach_desc);
		     go to clean_out;
		end;

		call set_hangup_proc (teleprinter_iocbp);
						/* this will work or abort directly */

		call iox_$put_chars (teleprinter_iocbp, addr (FF), 1, ignore_code);

		p2 = addr (status);			/* set pointer so we can reference first word */
		call ios_$attach ("broadcast_errors", "broadcast_", (iodd_static.slave_output), "", status);
		if p2 -> st_code = 0 then		/* only switch error_output if this works */
		     call iox_$attach_ptr (iox_$error_output, "syn_ broadcast_errors", null, ignore_code);

		call iox_$control (teleprinter_iocbp, "read_status", addr (read_info), code);
		if code ^= 0 then do;		/* this is fatal...can't accept input. */
		     call iodd_msg_ (error, master, code, myname,
			"Fatal error.  Unable to order read_status for teleprinter.");
		     go to clean_out;
		end;

		iodd_static.chan_list_ptr -> ev_chan_list.channel (slave) = read_info.read_ev_chan;

		iodd_static.slave_ev_chan = read_info.read_ev_chan;

		iodd_static.slave_out = teleprinter_iocbp;
						/* set the slave iocbp ptrs */
		iodd_static.slave_in = teleprinter_iocbp;
		iodd_static.slave.active = TRUE;	/* slave terminal is now defined */
	     end;

/*	if a ctl terminal was defined, let it remain and inherit its slave status from iodd_ unless */
/*	it was changed above by slave= yes in the args */

	     if iodd_static.ctl_term.attached then do;
		ctl_wait_list.number = 1;
		ctl_wait_list.channel = iodd_static.ctl_ev_chan;
		alarm_channel = iodd_static.ctl_ev_chan;
		call iox_$modes (iodd_static.slave_in, "^hndlquit", omode, ignore_code);
						/* we reset read on quit */
	     end;
	     else do;
		ctl_wait_list.number = 0;		/* otherwise clear to avoid errors */
		ctl_wait_list.channel = 0;
		alarm_channel = 0;
	     end;


	     if iodd_static.slave.active then do;	/* set up switches for slave control */
		iodd_static.slave.accept_input = TRUE;
		iodd_static.slave.allow_quits = TRUE;
		iodd_static.slave.print_errors = TRUE;
		if iodd_static.slave_output = iodd_static.ctl_output then
		     iodd_static.slave.log_msg = FALSE; /* kill double messages */
		else iodd_static.slave.log_msg = TRUE;	/* send log msg to slave if not ctl terminal */
	     end;
	     else do;
		iodd_static.slave.accept_input = FALSE;
		iodd_static.slave.allow_quits = FALSE;
		iodd_static.slave.print_errors = FALSE;
		iodd_static.slave.log_msg = FALSE;
	     end;

	     call iox_$look_iocb (iodd_static.slave_output, iodd_static.slave_out, code);
	     if code ^= 0 then do;
		if iodd_static.slave.active then
		     call iodd_msg_ (error, master, code, myname, "Slave functions terminated.");
		iodd_static.slave.active = FALSE;	/* cannot be active */
		iodd_static.slave.print_errors = FALSE;
		iodd_static.slave.allow_quits = FALSE;
		iodd_static.slave.accept_input = FALSE;
	     end;

/* get iocbp for station password */
	     call iox_$look_iocb (iodd_static.slave_input, iodd_static.slave_in, code);
	     if code ^= 0 then do;			/* no one home? */
		if iodd_static.slave.active then
		     call iodd_msg_ (normal, master, code, myname, "Slave input terminated.");
		iodd_static.slave.accept_input = FALSE; /* like we said */
	     end;

/* find the device station so we can determine which minor devices to use */

	     station = iodd_parse_$args ("station=", major_args); /* station in major will over-ride */
	     if station ^= "" then do;		/* got one, all minor devices will be used */
		do i = 1 to iodd_static.assigned_devices;
		     p = driver_ptr_list.stat_segp (i); /* get ptr to driver status seg */
		     p -> driver_status.attached = TRUE;/* mark it as attached */
		end;
		need_station = FALSE;		/* we don't need to look for station */
	     end;
	     else do;
		need_station = TRUE;		/* look to the device for the station */
		if ^(iodd_static.slave.active & iodd_static.slave.accept_input) then do;
		     call iodd_msg_ (error, master, error_table_$fatal_error, myname,
			"No slave device to request operator input from.");
		     go to clean_out;
		end;
		call iodd_msg_ (normal, master, zero_code, "", "Requesting station identifier.");
	     end;

	     opr_msg = "Enter station command:" || NL;	/* ready to ask for device station */
	     do tries = 1 to 10 while (need_station);	/* try up to 10 times before giving up */
		call iox_$put_chars (iodd_static.slave_out, addr (opr_msg), length (rtrim (opr_msg)), code);
		if code ^= 0 then do;
try_to_recover:
		     call iodd_msg_ (error, master, code, myname,
			"Trouble initializing device.  Starting reinitialization.");
		     call drop_device;
		     iodd_static.re_init_in_progress = TRUE;
		     go to iodd_static.re_init_label;
		end;

		call iox_$control (iodd_static.slave_out, "runout", null, ignore_code);

		input_line = "";			/* clear any junk */
		call iox_$get_line (iodd_static.slave_in, addr (input_line), length (input_line), nchar, code);
		if code ^= 0 then
		     go to try_to_recover;

		station = before (iodd_parse_$args ("station", input_line), " ");
						/* see if it is a good command */
		station_password = rtrim (ltrim (after (iodd_parse_$args ("station", input_line), " ")));

		if station ^= "" then do;		/* if defined, check it out */
		     if station_password = "" then	/* ... left off password: ask for it */
			call read_password_$switch (iodd_static.slave_out, iodd_static.slave_in, STATION_PW_PROMPT,
			     station_password, ignore_code);
		     if station_password = "*" then	/* ... user really wants a blank password */
			station_password = "";

		     if station_password ^= "" then do;
			temp_password = station_password;
			station_password = scramble_ (temp_password);
			temp_password = "";
		     end;

		     call validate_card_input_$station (station, station_password, err_msg, code);
		     if code ^= 0 then do;
			call iodd_msg_ (normal, both, zero_code, "***", "^a: ^a", err_msg, station);
			go to enter_again;		/* ask the question once more */
		     end;
		     else do i = 1 to iodd_static.assigned_devices; /* look at each minor device */
			p = driver_ptr_list.stat_segp (i); /* get ptr to driver status seg */

/* see if user wants minor args to be found in a segment */
			minor_args_name = iodd_parse_$args ("indirect=", return_string (p -> driver_status.minor_args));
			if minor_args_name ^= "" then do; /* yes, grab that segment */
			     call initiate_the_file (minor_args_name, minor_args_ptr, minor_args_length,
				"minor_args", code);
			     if code ^= 0 then
				go to clean_out;
			end;
			else do;
						/* locate minor args for this minor device */
						/* in the i/o daemon tables text area */
			     minor_args_ptr = add_char_offset_ (addr (text_strings.chars), p -> driver_status.minor_args.first_char - 1);
			     minor_args_length = p -> driver_status.minor_args.total_chars;
			end;
			if station = iodd_parse_$args ("station=", minor_args) then do; /* match? */
			     need_station = FALSE;	/* we found a good one */
			     p -> driver_status.attached = TRUE; /* mark it as attached */
			end;
			else p -> driver_status.attached = FALSE; /* this one is invalid */
		     end;

		     if need_station then do;		/* indicate an error to the operator */
			err_msg = "No minor device for station: " || station;
			call iodd_msg_ (normal, both, zero_code, "***", err_msg);
		     end;
		end;
		else do;				/* no valid "STATION" command card */
		     call iodd_msg_ (normal, both, zero_code, "***", "No station command given.");
		end;
enter_again:
	     end;

	     if tries > slave_login_tries then
		go to logout_slave;			/* after 10 times, give up */

	     call iodd_msg_ (log, master, zero_code, "", "Driver initializing for station: ^a", station);

	end;

/* This is where the two attach types are again handled the same */

	terminal (master) = "user_output";		/* master terminal output stream for read_cards command */
	terminal (slave) = iodd_static.slave_output;

/* For each minor device marked as attached, find the type of device it is */

	prt_rqt = "printer";			/* default the request type names to standard */
	pun_rqt = "punch";
	reader_attached = FALSE;			/* reader not available yet */
	default_printer = null ();			/* no driver status seg for printer yet */
	default_punch = null ();			/* or for the punch */
	printer_count, punch_count = 0;		/* but count them as they are found */
	rqt_string = "";				/* no request types defined for this station yet */

	term_info.version = terminal_info_version;	/* set version number once for all possible calls */
	term_info.baud_rate = 0;			/* initialize to no-op just in case */

	iodd_static.current_devices = 0;		/* haven't found any good ones yet */
	ready_device = FALSE;			/* none of them are ready yet either */

	do i = 1 to iodd_static.assigned_devices;
	     p = driver_ptr_list.stat_segp (i);
	     p -> driver_status.ready = FALSE;		/* printer devices will honor auto_go */
	     p -> driver_status.generic_type = "";	/* not defined yet */
	     p -> driver_status.form_wait_time = default_form_wait_time; /* default wait time per ctl msg */
	     p -> driver_status.bit_rate_est = 0;	/* no output rate defined yet */
	     p -> driver_status.defer_time_limit = 0;	/* make operator specify */
	     p -> driver_status.dev_out_stream = "null_stream";

/* locate minor args for this minor device in the i/o daemon tables text area */
	     minor_args_ptr = add_char_offset_ (addr (text_strings.chars), p -> driver_status.minor_args.first_char - 1);
	     minor_args_length = p -> driver_status.minor_args.total_chars;

/* see if user wants minor args to be found in a segment */
	     minor_args_name = iodd_parse_$args ("indirect=", minor_args);
	     if minor_args_name ^= "" then do;		/* yes, grab that segment */
		call initiate_the_file (minor_args_name, minor_args_ptr, minor_args_length, "minor_args", code);
		if code ^= 0 then
		     go to clean_out;
	     end;
	     device_type = iodd_parse_$args ("dev=", minor_args);
						/* copy for easy reference */
	     if device_type = "printer" then do;	/* check if defined */
		if p -> driver_status.attached then do; /* only use the attached one */
		     if iodd_static.paper_type = PAPER_TYPE_SINGLE then do;
			if model = "" then
			     model = iodd_parse_$args ("model=", minor_args);
			if model ^= "" then
			     major_desc = major_desc || space || "-model " || model;
		     end;
		     call iodd_msg_ (normal, both, zero_code, "", "^/Initializing printer device: ^a",
			p -> driver_status.device_id);
		     printer_count = printer_count + 1;
		     p -> driver_status.generic_type = "printer";
						/* only printer functions can be done */
		     call minor_attach ("printer");
		     if printer_count = 1 then
			default_printer = p;
		     prt_rqt = p -> driver_status.req_type_label;
						/* get the request type */
		     if index (prt_rqt, ".") > 0 then
			prt_rqt = before (prt_rqt, ".");
						/* strip off device class */

		     call set_iod_val ("request_type", rtrim (prt_rqt));
		     if index (rqt_string, rtrim (prt_rqt)) = 0 then
			rqt_string = rqt_string || " " || rtrim (prt_rqt);
		     p -> driver_status.elem_size = BITS_PER_CHAR;
		     p -> driver_status.message_type = printer_request;
						/* expected dprint message type */

		     call iox_$control (p -> driver_status.dev_out_iocbp, "terminal_info", addr (term_info), code);
		     if code = 0 then
			p -> driver_status.bit_rate_est = term_info.baud_rate;
		     else p -> driver_status.bit_rate_est = initial_print_rate;
						/* set starting estimate */

		     allocate prt_ctl set (p -> driver_status.dev_ctl_ptr);
		     call get_prt_rqti_data (p);	/* find the request type info data for printer */
		     call iox_$control (p -> driver_status.dev_out_iocbp, "channel_stops",
			addr (prt_ctl.channel_stops), code);
		     if code ^= 0 then do;
			call iodd_msg_ (normal, both, code, myname, "Bad channel_stops order to printer.");
			go to logout_slave;
		     end;
		     call set_paper_info (slave, code);
		     if code ^= 0 then
			go to logout_slave;		/* proc gave the message */
		end;
	     end;
	     else if device_type = "punch" then do;
		if p -> driver_status.attached then do; /* only use the attached one */
		     call iodd_msg_ (normal, both, zero_code, "", "^/Initializing punch device: ^a",
			p -> driver_status.device_id);
		     punch_count = punch_count + 1;
		     p -> driver_status.generic_type = "punch";
						/* only punch functions for this one */

		     call minor_attach ("punch");
		     if punch_count = 1 then
			default_punch = p;		/* record the default status seg ptr */
		     pun_rqt = p -> driver_status.req_type_label;
						/* get the request type */
		     if index (pun_rqt, ".") > 0 then
			pun_rqt = before (pun_rqt, ".");
						/* strip off device class */

		     call set_iod_val ("pun_rqt", rtrim (pun_rqt));
		     if index (rqt_string, rtrim (pun_rqt)) = 0 then
			rqt_string = rqt_string || " " || rtrim (pun_rqt);
		     p -> driver_status.elem_size = BITS_PER_CHAR; /* in this driver, this is just a place holder */
		     p -> driver_status.message_type = punch_request;
						/* type of dprint msg expected */

		     call iox_$control (p -> driver_status.dev_out_iocbp, "terminal_info", addr (term_info), code);
		     if code = 0 then
			p -> driver_status.bit_rate_est = term_info.baud_rate;
		     else p -> driver_status.bit_rate_est = initial_punch_rate;

		     allocate pun_ctl set (p -> driver_status.dev_ctl_ptr);
		     pun_ctl_ptr = p -> driver_status.dev_ctl_ptr;
		     pun_ctl.sep_cards = standard;	/* set the default control parms */
		     pun_ctl.auto_punch = FALSE;	/* make the operator switch to autopunch if desired */
		     if p -> driver_status.rqti_ptr ^= null then
			call iodd_msg_ (normal, master, zero_code, myname, "This driver cannot decode a punch rqti seg.");
		end;
	     end;
	     else if device_type = "reader" then do;	/* this is only a dummy minor device used */
						/* to get the attach desc for the reader */
		if p -> driver_status.attached then do; /* only use the attached one */

		     p -> driver_status.attached = FALSE; /* it is never attached as far as */
						/* the coordinator is concerned */
		     if reader_attached then do;
			call iodd_msg_ (normal, master, zero_code, myname,
			     "Multiple reader devices specified.  Device ^a ignored.",
			     p -> driver_status.device_id);
		     end;
		     else do;
			call iodd_msg_ (normal, both, zero_code, "", "^/Initializing reader device: ^a",
			     p -> driver_status.device_id);
			p -> driver_status.generic_type = "card_rdr";
			call minor_attach ("reader");
			reader_attached = TRUE;	/* tell the read_cards command it can work */

			card_info.n_streams = 1;	/* remote_driver only supports one format */
			card_info.format (1) = "rmcc";/* and that's like MCC */
			card_info.control_stream, card_info.name (1) = p -> driver_status.dev_out_stream;
						/* use the same stream for data */
			card_info.el_size (1) = BITS_PER_CHAR; /* input is in characters of 9 bits each */
		     end;
		end;
	     end;
	     else do;				/* someone slipped in a zinger */
		call iodd_msg_ (normal, master, zero_code, myname, "Invalid ""dev="" arg ""^a"" for minor device ^a.",
		     device_type, p -> driver_status.device_id);
		p -> driver_status.attached = FALSE;	/* can't be attached in this case */
	     end;
	end;

	if iodd_static.current_devices = 0 then do;	/* trouble */
	     err_msg = "No minor devices found with ""dev="" arg which is known to this driver.";
	     call iodd_msg_ (error, master, zero_code, myname, err_msg);
	     code = 0;
	     go to logout_slave;			/* drop this one */
	end;

	if printer_count > 1 then do;
	     default_printer = null;			/* no default if more than one */
	     prt_rqt = "printer";
	     call set_iod_val ("request_type", rtrim (prt_rqt));
	end;
	if punch_count > 1 then do;
	     default_punch = null;			/* no default if more than one */
	     pun_rqt = "punch";
	     call set_iod_val ("pun_rqt", rtrim (pun_rqt));
	end;

	call set_iod_val ("rqt_string", (rqt_string));
	call set_iod_val ("station_id", rtrim (station));

	iodd_static.admin_ec_name = rtrim (station) || "_admin.ec";
	call read_cards_$set_station (station, ignore_code);
	call read_cards_$set_rqt (prt_rqt, pun_rqt, ignore_code); /* pass default rqt's to card input proc */

	iodd_static.form_type = iodd_parse_$args ("form_type=", major_args);
						/* set form type */
	if iodd_static.form_type = "" then
	     iodd_static.form_type = "std_ctl_msg";	/* if not found... */

	iodd_static.slave_hold = ^ready_device;		/* issue a "go" if at least one device is ^ready */

	smi.version = -1;				/* init to known state */

	call date_time_ (clock (), date_string);	/* get set for ready message */
	call iodd_msg_ (normal, both, zero_code, "", "^/^a driver on channel ^a ready at ^16a^/", iodd_static.major_device,
	     iodd_static.attach_name, date_string);

	call iodd_listen_ (stat_p);


/*  This is only for error recovery during initialization.  The listener will never return here. */
clean_out:
	call drop_device;
	if iodd_static.attach_type = ATTACH_TYPE_VARIABLE_LINE then do; /* new style, detach and wait for dialup */
	     iodd_static.re_init_in_progress = TRUE;
	     go to iodd_static.re_init_label;
	end;

	return;

logout_slave:					/* logout the slave device but not the process */
	iodd_static.re_init_in_progress = TRUE;		/* we do this by re-initializing the driver */

	call date_time_ (clock (), date_string);	/* get set for message */
	iodd_static.slave.log_msg = TRUE;		/* send to log and slave */
	call iodd_msg_ (log, both, zero_code, "", "Logout for station: ^a at ^a", station, date_string);

	if iodd_static.slave_out ^= null () then do;
	     call iox_$control (iodd_static.slave_out, "runout", null, ignore_code);
	     call iox_$control (iodd_static.slave_out, "end_write_mode", null, ignore_code);
	end;

	call drop_device;

	call iodd_msg_ (normal, master, zero_code, "", "Driver starting re-initialization.");

	go to iodd_static.re_init_label;		/* this will do everything */





drop_device: procedure ();

dcl  send_hangup bit (1);

/* internal proc to issue a hangup to the device before detaching */

	send_hangup = TRUE;				/* tell close_and_detach proc to send hangup */
	go to device_common;

detach_device: entry ();
	send_hangup = FALSE;			/* no send hangup */

device_common:
	if iodd_static.ctl_term.attached then
	     if iodd_static.ctl_output ^= iodd_static.slave_output then
		iodd_static.slave.active = FALSE;	/* if ctl term is slave, leave it to iodd_ */
	     else ;
	else iodd_static.slave.active = FALSE;		/* if no ctl terminal, no slave is left */
	call close_and_detach (teleprinter_iocbp, send_hangup);

	list_ptr = iodd_static.driver_list_ptr;
	do i = 1 to iodd_static.assigned_devices;
	     p = driver_ptr_list.stat_segp (i);
	     call close_and_detach (p -> driver_status.dev_out_iocbp, send_hangup);
	     if p -> driver_status.dev_ctl_ptr ^= null then
		free p -> driver_status.dev_ctl_ptr -> prt_ctl;
						/* free the prt_ctl or pun_ctl structures */
						/* Lucky free dosn't care about the structure name */
	end;

	call continue_to_signal_ (ignore_code);		/* in case this is called from a handler */

	return;

     end drop_device;
%page;

request:
     entry;

/*  This entry is called by iodd_listen_ when a request has been received from
   the coordinator for either of the logical drivers servicing the remote device.
   Here we just check to be sure that we can understand the request format and the requested
   print or punch data format.  Then the request is passed on to the proc which can handle
   that type of request.
*/

/* for cleanup handler */
	evaluate_forms_info_input_ptr,
	     evaluate_forms_info_output_ptr = null;

	p = iodd_static.driver_ptr;			/* find the current driver */
	p2 = addr (p -> driver_status.descriptor);	/* find the request descriptor */
	dmp = addr (p -> driver_status.message);	/* get ptr to message */

	if dmp -> queue_msg_hdr.hdr_version ^= queue_msg_hdr_version_1 then do; /* trouble */
	     call iodd_msg_ (log, both, zero_code, "", "Invalid message header.  Cannot read request ^d.^d.",
		p2 -> request_descriptor.seq_id, p2 -> request_descriptor.q);
	     p2 -> request_descriptor.keep_in_queue = TRUE;
						/* save for conversion later */
	     go to be_nice;
	end;
	if dmp -> queue_msg_hdr.message_type ^= p -> driver_status.message_type then do;
	     call iodd_msg_ (log, both, zero_code, "",	/* log the error */
		"Incorrect message type.^/Request ^d.^d for ^a (segment ^a) not processed.",
		p2 -> request_descriptor.seq_id, p2 -> request_descriptor.q,
		p2 -> request_descriptor.mseg_message_info_copy.sender_id,
		dmp -> queue_msg_hdr.ename);
	     p2 -> request_descriptor.cancelled = TRUE;	/* we don't want this one again */
be_nice:
	     p2 -> request_descriptor.dont_delete = TRUE; /* save the user's data */
	     p2 -> request_descriptor.finished = TRUE;	/* mark it done */
	     return;				/* it wasn't for us after all */
	end;
	if dprint_msg.version ^= dprint_msg_version_3	/* Previous version */
	     & dprint_msg.version ^= dprint_msg_version_4 /* Previous version */
	     & dprint_msg.version ^= dprint_msg_version_5 /* Current version */
	then do;					/* other trouble? */
	     call iodd_msg_ (log, both, zero_code, "",
		"Wrong message version found.^/Request ^d.^d for ^a (segment ^a) not processed",
		p2 -> request_descriptor.seq_id, p2 -> request_descriptor.q,
		p2 -> request_descriptor.mseg_message_info_copy.sender_id,
		dmp -> queue_msg_hdr.ename);
	     p2 -> request_descriptor.keep_in_queue = TRUE;
	     go to be_nice;
	end;
	if dprint_msg.version < dprint_msg_version_4 then /* Disallow -line_nbrs before version 4 */
	     dprint_msg.control.line_nbrs = FALSE;
	format_code = dprint_msg.output_module;		/* get the user defined format */

	if format_code = printer_mode then do;		/* if printer, check line length */
	     prt_ctl_ptr = p -> driver_status.dev_ctl_ptr;/* find the control info for this printer */
	     call evaluate_forms_options (code);	/* validate forms data */
	     if code ^= 0 then do;
		call iodd_msg_ (log, both, zero_code, "",
		     "Request ^d.^d for ^a (segment ^a) deferred.^/Forms evaluation error '^a'",
		     p2 -> request_descriptor.seq_id, p2 -> request_descriptor.q,
		     p2 -> request_descriptor.mseg_message_info_copy.sender_id,
		     dmp -> queue_msg_hdr.ename,
		     evaluate_forms_info_output.error_string);
		p2 -> request_descriptor.keep_in_queue = TRUE; /* defer it */
		if evaluate_forms_info_output_ptr ^= null then
		     free evaluate_forms_info_output;
		go to be_nice;
	     end;

/* adjust prt_ctl accordingly */
	     if dprint_msg.line_lth > prt_ctl.phys_line_length then do; /* platten wide enough */
		call iodd_msg_ (log, both, zero_code, "",
		     "Request ^d.^d for ^a (segment ^a) deferred.^/Requires a device with line length of ^d.",
		     p2 -> request_descriptor.seq_id, p2 -> request_descriptor.q,
		     p2 -> request_descriptor.mseg_message_info_copy.sender_id,
		     dmp -> queue_msg_hdr.ename, dprint_msg.line_lth);
		p2 -> request_descriptor.keep_in_queue = TRUE;
						/* defer it */
		go to be_nice;
	     end;
	end;
	else if format_code = punch_raw_mode then do;	/* for binary output */
	     element_size = 1;			/* treat as 1 bit at a time */
	end;
	else if format_code = punch_rmcc_mode then do;	/* for character output */
	     element_size = BITS_PER_CHAR;		/* for output_request_ */
	end;
	else do;					/* be sure it is defined */
	     call iodd_msg_ (log, both, zero_code, "",
		"Undefined output module in user request.^/Request ^d.^d for ^a (segment ^a) not processed",
		p2 -> request_descriptor.seq_id, p2 -> request_descriptor.q,
		p2 -> request_descriptor.mseg_message_info_copy.sender_id,
		dmp -> queue_msg_hdr.ename);
	     p2 -> request_descriptor.cancelled = TRUE;	/* we don't want this one again */
	     go to be_nice;
	end;

	iodd_static.quit_during_request = FALSE;	/* start clean */
	ctl_msg_sent = FALSE;			/* initialize to no msg yet */
	save_request_label = save_return;		/* init for non-local transfer on save command */

	on cleanup begin;
	     if p ^= null () then			/* this one should never be null, but ... */
		if p -> driver_status.dev_out_iocbp ^= null () then
		     call iox_$control (p -> driver_status.dev_out_iocbp, "end_write_mode", null, ignore_code);

	     if evaluate_forms_info_input_ptr ^= null then
		free evaluate_forms_info_input;
	     if evaluate_forms_info_output_ptr ^= null then
		free evaluate_forms_info_output;
	end;					/* let the I/O Module send an EOF if needed */

	if dprint_msg.message_type = printer_request then do;
	     call do_prt_request_ (p -> driver_status.dev_out_iocbp, stat_p, code);
	     if evaluate_forms_info_output_ptr ^= null then
		free evaluate_forms_info_output;
						/* this one is for the printer only */
	end;
	else do;
	     call output_request_ ((p -> driver_status.dev_out_stream), element_size, stat_p, print_banner, code);
	end;
	if code ^= 0 then do;
	     iodd_static.slave_hold = TRUE;		/* on errors go to command level for guidance */
	     if code = error_table_$io_no_permission then do; /* in case of hangup... */
		call iodd_msg_ (error, master, code, myname,
		     "Device in inconsistent state or hungup.  Must re-initialize.");
		signal re_init;
	     end;
	end;
save_return:					/* return point for save command at request cmd level */
	call iox_$control (p -> driver_status.dev_out_iocbp, "end_write_mode", null, code);
	if code = 0 then do;			/* we were able to release the line */
	     call timer_manager_$sleep (time, RELATIVE_SECONDS); /* sleep a few seconds */
						/* so remote device can send if needed */
	end;
	else if code = error_table_$undefined_order_request then do; /* this is ok also */
	     if iodd_static.test_entry then		/* be able to set a reasonable pace */
		if time > 1 then			/* simulate device */
		     call timer_manager_$sleep (time, RELATIVE_SECONDS);
	end;
	else do;					/* this is a real error */
	     call iodd_msg_ (error, master, code, myname, "From ""end_write_mode"" control");
	     iodd_static.slave_hold = TRUE;
	end;

	if iodd_static.slave.active then		/* flush any messages */
	     call iox_$control (iodd_static.slave_out, "runout", null, ignore_code);

	return;
%page;

/* This entrypoint is used to output the head/tail banner cards for a punch
   request.  It is referenced in the call to output_request_. */

print_banner: entry (a_stream, a_banner_type, a_data_ptr, a_code);

	stream = a_stream;
	banner_type = a_banner_type;
	ordatap = a_data_ptr;
	a_code, code = 0;

	p = iodd_static.driver_ptr;			/* save driver_ptr in short name variable */
	p2 = addr (p -> driver_status.descriptor);	/* get descriptor ptr just in case */
	dmp = addr (p -> driver_status.message);	/* get message ptr */
	iocbp = p -> driver_status.dev_out_iocbp;	/* get iocbp for control and writes */

	if dprint_msg.message_type ^= punch_request then do; /* this proc is for dpunch type message banner */
	     code = error_table_$action_not_performed;	/* return an error */
	     go to banner_ret;
	end;

	pun_ctl_ptr = p -> driver_status.dev_ctl_ptr;	/* get ready for using pun_ctl structure */

	if banner_type = head_banner then do;		/* this is for the header */
	     iodd_static.quit_during_request = FALSE;	/* start watching now */
	     if iodd_static.ctl_term.attached then do;	/* are we to inform the ctl terminal? */
		call write_control_form_ (iodd_static.form_type, iodd_static.ctl_output, ordatap, code);
		if code ^= 0 then do;
		     if code ^= error_table_$action_not_performed then do; /* this is normal */
			call iodd_msg_ (error, master, code, myname, "Writing message to control terminal.");
			iodd_static.slave_hold = TRUE;/* go back to command level when done */
		     end;
		     ctl_msg_sent = FALSE;		/* don't wait now */
		     code = 0;			/* we handled it */
		end;
		else ctl_msg_sent = TRUE;		/* all set */
		if ctl_wait_list.number = 1 then
		     call set_wait_timer;
	     end;
	     else ctl_msg_sent = FALSE;

	     format_code = dprint_msg.output_module;	/* get the punch format code */
	     if format_code = punch_raw_mode then
		arg_string = "raw";			/* set name for messages */
	     else arg_string = "rmcc";		/* this is the default */

	     if ^pun_ctl.auto_punch then do;		/* are we to come to command level */

		on conversion
		     begin;
		     call iodd_msg_ (normal, source, zero_code, "", "Argument conversion error.  Try again.");
		     go to ask;
		end;

		on size
		     begin;
		     call iodd_msg_ (normal, source, zero_code, "", "Argument numerical size error.  Try again.");
		     go to ask;
		end;

/* set to wait for input, no prompt master for command and to prompt slave for input */
		control = "101"b;

		call iodd_msg_ (log, slave, zero_code, "", "  Deck punch format:  ^a.", arg_string);

ask:
		call iodd_get_cmd_ (addr (input_line), length (input_line), len, control, "request", source, code);
		if code ^= 0 then do;		/* this is bad news */
		     iodd_static.slave_hold = TRUE;	/* go back to command level */
		     go to banner_ret;
		end;

		call iodd_parse_$command (substr (input_line, 1, len), addr (cmd_list), code);
		if code ^= 0 then do;
		     if code = error_table_$noarg then
			go to ask;
		     call iodd_msg_ (normal, source, code, myname, "Unable to parse command line.");
		     go to ask;
		end;

		if cmd_list.cmd = "help" then do;	/* check which command was given */
		     call iodd_msg_ (normal, source, zero_code, "", "Standard driver commands may be used, plus:^/");
		     call iodd_msg_ (normal, source, zero_code, "", "   copy N         -set the current copy number to N");
		     call iodd_msg_ (normal, source, zero_code, "", "   req_status     -get the copy and request numbers");
		     call iodd_msg_ (normal, source, zero_code, "", "   punch          -start data transfer");
		     go to ask;
		end;

		if cmd_list.cmd = "copy" then do;
		     if cmd_list.number_tokens_found ^= 2 then do; /* we must have 2 args which includes the N part */

bad_copy_arg:
			call iodd_msg_ (normal, source, zero_code, "",
			     "Invalid or missing argument.  Use copy N to set current copy number.");
			go to ask;
		     end;

		     value = convert (value, cmd_list.arg (1));
						/* convert char to fixed bin */
		     if value < 1 | value > ordata.copies then
			go to bad_copy_arg;

		     ordata.copy_no = value;		/* passed checks, so set the new current copy number */
		     go to ask;			/* see what is next */
		end;

		if cmd_list.cmd = "req_status" | cmd_list.cmd = "reqstatus" then do;
		     call iodd_msg_ (normal, source, zero_code, "",
			"Request ^d:  ^a^/^3xCurrent copy no:  ^d of ^d     Punch format: ^a", ordata.request_no,
			ordata.full_path, ordata.copy_no, ordata.copies, arg_string);
		     go to ask;
		end;

		if cmd_list.cmd = "debug" & iodd_static.test_entry & source = master then do;
		     call iodd_msg_ (normal, master, zero_code, "", "Calling debug");
		     call debug ();
		     go to ask;
		end;
		if (cmd_list.cmd = "probe" | cmd_list.cmd = "pb")
		     & iodd_static.test_entry
		     & source = master then do;
		     call iodd_msg_ (normal, master, zero_code, "", "Calling probe");
		     call probe ();
		     go to ask;
		end;

		if cmd_list.cmd ^= "punch" then do;	/* all but the punch command go to std cp */
		     call iodd_command_processor_ (source, request_command_level_state, substr (input_line, 1, len), code);
		     if code = 1 | code = 2 then do;	/* wants to go or start */
			if code = 2 & cmd_list.cmd = "save" then
			     go to save_request_label;
			call iodd_msg_ (normal, source, zero_code, "", "Invalid command.  Try again. - ^a", cmd_list.cmd);
		     end;
		     go to ask;
		end;
	     end;

	     call iox_$control (iocbp, "reset", null, code);
						/* clear modes and counts for all requests */
	     if code ^= 0 then
		go to banner_ret;


	     if dprint_msg.output_module = punch_raw_mode then do; /* binary punch request */
		call iox_$control (iocbp, "binary_punch", null, code);
						/* set binary mode */
		if code ^= 0 then do;		/* OOPS, drop this request */
		     call iodd_msg_ (normal, slave, zero_code, myname, "Unable to set binary punch mode");
		end;
		go to banner_ret;
	     end;
	     else if pun_ctl.sep_cards = standard then do;/* separator cards are for character punching only */
		req_string = ltrim (char (ordata.request_no));
						/* get number as characters */
		header_card2 = "";			/* clear the second header card */
		pos = 1;				/* where the next output char position is */

		do idx = 1 to length (rtrim (req_string));
						/* once for each digit */
		     digit = substr (req_string, idx, 1);
						/* pick it up */
		     substr (header_card2, pos, 5) = copy (digit, 5);
						/* repeat it 5 times */
		     pos = pos + 7;			/* bump the counter, leaving 2 spaces */
		end;

		substr (header_card2, pos + 5) = ordata.requestor;
						/* add on the requestor name */

		call iox_$put_chars (iocbp, addr (separator), length (separator), code);
		if code ^= 0 then
		     go to banner_ret;
		call iox_$put_chars (iocbp, addr (header_card2), length (header_card2), code);
		if code ^= 0 then
		     go to banner_ret;
		call iox_$put_chars (iocbp, addr (separator), length (separator), code);
		if code ^= 0 then
		     go to banner_ret;
		call iox_$control (iocbp, "runout", null, code);
		if code ^= 0 then
		     go to banner_ret;
		call iox_$control (iocbp, "reset", null, code);
	     end;
	end;
	else if banner_type = tail_banner then do;	/* time for the tail banner */
	     if pun_ctl.sep_cards = standard & dprint_msg.output_module ^= punch_raw_mode then do;
		do i = 1 to 2;
		     call iox_$put_chars (iocbp, addr (separator), length (separator), code);
		     if code ^= 0 then
			go to banner_ret;
		end;
	     end;

	     if ctl_wait_list.number = 1 then
		call wait_for_ctl_finish;
	end;
	else if banner_type = error_message then do;	/* this is for an error message */
						/* when we can punch in binary, we can write flip cards here */
	end;

/* 	all other banners are undefined. */

	else code = error_table_$action_not_performed;


banner_ret:
	a_code = code;
	if code ^= 0 then
	     p2 -> request_descriptor.keep_in_queue = TRUE;
						/* defer the request */
	return;
%page;

/* This is the command processor for special commands recognized by the remote
   driver.  Any unrecognized commands will be passed back to the general
   I/O daemon command processor for execution. */
command: entry (a_source, a_state, a_argp, a_code);

	argp = a_argp;				/* define the arg_list structure which contains "command" */
	source = a_source;
	state = a_state;
	terminal (2) = iodd_static.slave_output;	/* in case it has changed */

	on conversion
	     begin;				/* handler for conversion errors */
	     call iodd_msg_ (normal, source, zero_code, "", "Argument conversion error. Try again.");
	     go to cmd_error;
	end;

	save_code = a_code;				/* save the called value */
	a_code, code = 0;				/* say we handled it for now */

	if command = "help" then do;
	     call iodd_msg_ (normal, source, zero_code, "", "^/** Commands for the remote driver **^/");
	     call iodd_msg_ (normal, source, zero_code, "", "banner_bars [<minor_device>] [single | double | none]");
	     call iodd_msg_ (normal, source, zero_code, "", "banner_type [<minor_device>] [standard | brief | none]");
	     call iodd_msg_ (normal, source, zero_code, "", "clean_pool  <days allowed to remain>");
	     call iodd_msg_ (normal, source, zero_code, "",
		"paper_info [<minor_device>] [-ll <line_len>] [-pl <paper_len>] [-lpi <6 or 8>]");
	     call iodd_msg_ (normal, source, zero_code, "", "pause_time [<delay_time_between_requests>]");
	     call iodd_msg_ (normal, source, zero_code, "",
		"prt_control [<minor_device>] [^]KEY ... (KEYs: force_nep, force_esc, force_ctl_char, force_nsep, autoprint)"
		);
	     call iodd_msg_ (normal, source, zero_code, "", "pun_control [<minor_device>] [^]autopunch)");
	     call iodd_msg_ (normal, source, zero_code, "", "read_cards");
	     call iodd_msg_ (normal, source, zero_code, "", "runout_spacing  <number_of_lines>");
	     call iodd_msg_ (normal, source, zero_code, "", "sample_hs [<minor_device>]");
	     call iodd_msg_ (normal, source, zero_code, "", "sample_form");
	     call iodd_msg_ (normal, source, zero_code, "", "sep_cards [<minor_device>] [standard | none]");
	     call iodd_msg_ (normal, source, zero_code, "", "single");
	     go to end_cmd;
	end;
	if command = "ctl_term" | command = "ctlterm" then do; /* this was passed on by iodd_command_processor_ */
						/* to have us set the default form type */
	     iodd_static.form_type = "std_ctl_msg";	/* this is our default */
	     do i = 1 to iodd_static.assigned_devices;
		p = driver_ptr_list.stat_segp (i);	/* get ptr to driver status seg */
		p -> driver_status.form_wait_time = default_form_wait_time; /* set the default wait time */
	     end;
	     go to end_cmd;
	end;

	if command = "banner_bars" | command = "bannerbars" then do;
	     if arg_list.n_tokens > 2 then do;
		p = find_driver_status_seg_ptr (arg_list.arg (1));
						/* get driver status ptr for minor device given */
		i = 2;				/* arg 2 is the value argument */
	     end;
	     else do;				/* one arg - could be value for default or ... */
						/* could be minor device name with no value */
		p = default_printer;		/* try for the default printer */
		i = 1;				/* assume first arg is the value */
	     end;
	     value = -1;				/* no value defined yet */
	     if arg_list.n_tokens > 1 then do;		/* allow for no args at all */
		if arg_list.arg (i) = "-print" then
		     value = -1;
		else if arg_list.arg (i) = "double" then
		     value = NORMAL_BANNER_BARS;
		else if arg_list.arg (i) = "single" then
		     value = SINGLE_BANNER_BARS;
		else if arg_list.arg (i) = "none" then
		     value = NO_BANNER_BARS;
		else p = find_driver_status_seg_ptr (arg_list.arg (i));
	     end;

	     if p = null () then do;
no_printer:
		if arg_list.n_tokens = 1 then
		     opr_msg = "not specified.";
		else opr_msg = "not found: " || arg_list.arg (i);
		call iodd_msg_ (normal, source, zero_code, "", "Printer minor device ^a", opr_msg);
		go to cmd_error;
	     end;
	     if p -> driver_status.generic_type ^= "printer" then do; /* printer functions are only for printers */
not_a_printer:
		call iodd_msg_ (normal, source, zero_code, "", "Minor device ""^a"" is not a printer.",
		     p -> driver_status.device_id);
		go to cmd_error;
	     end;

	     prt_ctl_ptr = p -> driver_status.dev_ctl_ptr;/* get the control structure pointer */

	     if value = -1 then do;
		if prt_ctl.banner_bars = NORMAL_BANNER_BARS then
		     opr_msg = "double";
		else if prt_ctl.banner_bars = SINGLE_BANNER_BARS then
		     opr_msg = "single";
		else if prt_ctl.banner_bars = NO_BANNER_BARS then
		     opr_msg = "none";
		else opr_msg = "Undefined value";
		call iodd_msg_ (normal, source, zero_code, "", "Current value is:  ^a", opr_msg);
	     end;

	     else prt_ctl.banner_bars = value;

	     go to end_cmd;
	end;

	if command = "pause_time" | command = "pausetime" then do;
	     if arg_list.n_tokens > 1 then do;
		value = convert (value, arg_list.arg (1));
		if value < zero | value > pause_time_max then do;
		     call iodd_msg_ (normal, source, zero_code, "", "pause_time range: ^d to ^d seconds ", zero, pause_time_max);
		     go to cmd_error;
		end;
		time = value;
		go to end_cmd;
	     end;
	     else do;
		time = pause_time_default;		/* return to the default */
		go to end_cmd;
	     end;
	end;

	if command = "runout_spacing" | command = "runoutspacing" then do;
	     if arg_list.n_tokens > 1 then do;
		value = convert (value, arg_list.arg (1));
		if value < zero | value > runout_spacing_max then do; /* legal range? */
		     call iodd_msg_ (normal, source, zero_code, "", "runout_spacing range is ^d to ^d lines.",
			zero, runout_spacing_max);
		     go to cmd_error;
		end;
		call iox_$control (teleprinter_iocbp, "runout_spacing", addr (value), code);
		if code ^= 0 then do;
		     call iodd_msg_ (normal, source, zero_code, "", "Unable to set runout spacing for remote device.");
		     go to cmd_error;
		end;
		go to end_cmd;
	     end;
	     else do;
		call iodd_msg_ (normal, source, zero_code, "", "The runout_spacing command must have an argument");
		go to cmd_error;
	     end;
	end;

	if command = "paper_info" | command = "paperinfo" then do;
	     if arg_list.n_tokens > 1 then
		p = find_driver_status_seg_ptr (arg_list.arg (1));
						/* see if first arg matches a minor device */
	     else p = null;
	     if mod (arg_list.n_tokens, 2) = 0 then	/* odd number of args to cmd, first must be minor device */
		i = 2;				/* control args start  with arg 2 */
	     else do;				/* even number of args, wants default or made typing error */
		if p ^= null then do;		/* valid minor device name. operator typing error? */
		     if arg_list.arg (2) ^= "-print" then do; /* allow this exception */
			call iodd_msg_ (normal, source, zero_code, myname,
			     "Incorrect number of arguments.  Pairs of arguments follow minor device.");
			go to cmd_error;
		     end;
		     i = 2;			/* for the next arg test */
		end;
		else do;
		     p = default_printer;
		     i = 1;
		end;
	     end;
	     if p = null () then
		go to no_printer;
	     if p -> driver_status.generic_type ^= "printer" then
		go to not_a_printer;		/* only allow printers */
	     prt_ctl_ptr = p -> driver_status.dev_ctl_ptr;/* get the control pointer for this driver */

/* not enough args to change data, so print it */
	     if i >= arg_list.n_tokens | arg_list.arg (i) = "-print" then do;
		call iodd_msg_ (normal, source, zero_code, "",
		     "Physical paper width:  ^d characters.^/Physical paper length:  ^d lines at ^d lines per inch.",
		     prt_ctl.phys_line_length, prt_ctl.phys_page_length, prt_ctl.lines_per_inch);
		go to end_cmd;
	     end;

	     new_ll = prt_ctl.phys_line_length;
	     new_pl = prt_ctl.phys_page_length;
	     new_lpi = prt_ctl.lines_per_inch;

	     do i = i to n_tokens - 1 by 2;		/* check the arg pairs */
		if arg_list.arg (i) = "-ll" then
		     new_ll = convert (new_ll, arg_list.arg (i + 1));
		else if arg_list.arg (i) = "-pl" then
		     new_pl = convert (new_pl, arg_list.arg (i + 1));
		else if arg_list.arg (i) = "-lpi" then
		     new_lpi = convert (new_lpi, arg_list.arg (i + 1));
		else do;				/* bad control arg */
		     call iodd_msg_ (normal, source, zero_code, "", "Invalid control argument:  ^a", arg_list.arg (i));
		     go to cmd_error;
		end;
	     end;
	     if new_ll < line_length_min | new_ll > line_length_max then do; /* check the range */
		call iodd_msg_ (normal, source, zero_code, "", "Line length range is ^d to ^d.",
		     line_length_min, line_length_max);
		go to cmd_error;
	     end;

	     if ^(new_lpi = lpi_min | new_lpi = lpi_max) then do;
		call iodd_msg_ (normal, source, zero_code, "", "Lines per inch must be ^d or ^d.",
		     lpi_min, lpi_max);
		go to cmd_error;
	     end;
	     if new_pl < page_length_min then do;
		call iodd_msg_ (normal, source, zero_code, "", "Minimum paper length is ^d lines.",
		     page_length_min);
		go to cmd_error;
	     end;
	     if new_pl > page_length_max then do;
		call iodd_msg_ (normal, source, zero_code, "", "Maximum paper length is ^d lines.",
		     page_length_max);
		go to cmd_error;
	     end;

	     prt_ctl.phys_line_length = new_ll;
	     prt_ctl.phys_page_length = new_pl;
	     prt_ctl.lines_per_inch = new_lpi;

	     call iodd_msg_ (normal, source, zero_code, "", "Changing to:  ll ^d, pl ^d at ^d lines per inch.",
		prt_ctl.phys_line_length, prt_ctl.phys_page_length, prt_ctl.lines_per_inch);

	     call set_paper_info (source, code);
	     if code ^= 0 then
		go to cmd_error;

	     go to end_cmd;
	end;

	if command = "prt_control" | command = "prtcontrol" then do;
	     if arg_list.n_tokens > 1 then
		p = find_driver_status_seg_ptr (arg_list.arg (1));
						/* see if first arg matches a minor device */
	     else p = null;
	     if p ^= null then			/* first arg was a valid minor device name */
		i = 2;				/* value args start  with arg 2 */
	     else do;				/* wants default or made typing error */
		p = default_printer;		/* try for the default printer device */
		i = 1;				/* arg one starts the value */
	     end;
	     if p = null () then
		go to no_printer;
	     if p -> driver_status.generic_type ^= "printer" then
		go to not_a_printer;		/* only allow printers */
	     prt_ctl_ptr = p -> driver_status.dev_ctl_ptr;/* get the control pointer for this driver */

	     if arg_list.n_tokens <= i | arg_list.arg (i) = "-print" then do;
		call iodd_msg_ (normal, source, zero_code, "",
		     "Current values are:  ^[^^^]force_nep, ^[^^^]force_esc, ^[^^^]force_ctl_char, ^[^^^]force_nsep, ^[^^^]auto_print",
		     ^prt_ctl.force_nep, ^prt_ctl.force_esc, ^prt_ctl.force_ctl_char, ^prt_ctl.force_nsep,
		     prt_ctl.no_auto_print);
		go to end_cmd;
	     end;
	     do i = i to n_tokens - 1;		/* look at each argument */
		not = (substr (arg_list.arg (i), 1, 1) = "^");
						/* was first char a "^" */
		if not then
		     arg_string = substr (arg_list.arg (i), 2);
		else arg_string = arg_list.arg (i);
		if arg_string = "force_nep" | arg_string = "forcenep" then
		     prt_ctl.force_nep = ^not;
		else if arg_string = "force_esc" | arg_string = "forceesc" then
		     prt_ctl.force_esc = ^not;
		else if arg_string = "force_ctl_char" | arg_string = "forcectlchar" then
		     prt_ctl.force_ctl_char = ^not;
		else if arg_string = "auto_print" | arg_string = "autoprint" then
		     prt_ctl.no_auto_print = not;
		else if arg_string = "force_nsep" | arg_string = "forcensep" then
		     prt_ctl.force_nsep = ^not;
		else call iodd_msg_ (normal, source, zero_code, "", "Undefined argument: ^a", arg_list.arg (i));
	     end;
	     go to end_cmd;
	end;

	if command = "banner_type" | command = "bannertype" then do;
	     if arg_list.n_tokens > 2 then do;
		p = find_driver_status_seg_ptr (arg_list.arg (1));
						/* get driver status ptr for minor device given */
		i = 2;				/* arg 2 is the value argument */
	     end;
	     else do;				/* one arg - could be value for default or ... */
						/* could be minor device name with no value */
		p = default_printer;		/* try for the default printer */
		i = 1;				/* assume first arg is the value */
	     end;
	     value = -1;				/* no value defined yet */
	     if arg_list.n_tokens > 1 then do;		/* allow for no args at all */
		if arg_list.arg (i) = "-print" then
		     value = -1;
		else if arg_list.arg (i) = "none" then
		     value = NO_BANNERS;
		else if arg_list.arg (i) = "standard" then
		     value = NORMAL_BANNERS;
		else if arg_list.arg (i) = "brief" then
		     value = BRIEF_BANNERS;
		else p = find_driver_status_seg_ptr (arg_list.arg (i));
	     end;

	     if p = null () then
		go to no_printer;
	     if p -> driver_status.generic_type ^= "printer" then
		go to not_a_printer;		/* only allow printers */
	     prt_ctl_ptr = p -> driver_status.dev_ctl_ptr;/* get the control structure pointer */

	     if value = -1 then do;			/* print the current value */
		if prt_ctl.banner_type = NO_BANNERS then
		     opr_msg = "none";
		else if prt_ctl.banner_type = NORMAL_BANNERS then
		     opr_msg = "standard";
		else if prt_ctl.banner_type = BRIEF_BANNERS then
		     opr_msg = "brief";
		else opr_msg = "Undefined value";
		call iodd_msg_ (normal, source, zero_code, "", "Current value is:  ^a", opr_msg);
	     end;

	     else prt_ctl.banner_type = value;

	     go to end_cmd;
	end;

	if command = "sample_hs" | command = "samplehs" then do;
	     i = arg_list.n_tokens - 1;		/* define this in case of error */
	     if arg_list.n_tokens = 1 then
		p = default_printer;
	     else p = find_driver_status_seg_ptr (arg_list.arg (1));
	     if p = null () then
		go to no_printer;
	     if p -> driver_status.generic_type ^= "printer" then
		go to not_a_printer;		/* only allow printers */
	     prt_ctl_ptr = p -> driver_status.dev_ctl_ptr;

	     call iox_$control (p -> driver_status.dev_out_iocbp, "reset", null, ignore_code);
						/* clear everything */
	     call iox_$control (p -> driver_status.dev_out_iocbp, "inside_page", null, ignore_code);

	     call write_sample_prt_banner_ ("head_sheet", p -> driver_status.dev_out_iocbp, prt_ctl_ptr, ignore_code);

	     call iox_$control (p -> driver_status.dev_out_iocbp, "end_of_page", null, ignore_code);
	     call iox_$control (p -> driver_status.dev_out_iocbp, "runout", null, ignore_code);
						/* be sure it prints */
	     call iox_$control (p -> driver_status.dev_out_iocbp, "end_write_mode", null, ignore_code);
	     call timer_manager_$sleep (time, RELATIVE_SECONDS);

	     go to end_cmd;
	end;

	if command = "single" then do;		/* single space FF and VT for current request */
	     if iodd_static.request_in_progress then do;
		p = iodd_static.driver_ptr -> driver_status.dev_out_iocbp;
		call iox_$modes (p, "single", omode, ignore_code);
						/* set single mode */
		dmp = addr (iodd_static.driver_ptr -> driver_status.message);
		if dprint_msg.message_type = printer_request then
		     call do_prt_request_$single_copy ();
						/* avoid same problem if another copy requested */
		else call output_request_$set_single_copy ();
	     end;
	     else call iodd_msg_ (normal, source, zero_code, "", "No current request.");
	     go to end_cmd;
	end;

	if command = "pun_control" | command = "puncontrol" then do;
	     if arg_list.n_tokens > 1 then
		p = find_driver_status_seg_ptr (arg_list.arg (1));
						/* see if first arg matches a minor device */
	     else p = null;
	     if p ^= null then			/* first arg was a valid minor device name */
		i = 2;				/* value args start  with arg 2 */
	     else do;				/* wants default or made typing error */
		p = default_punch;			/* try for the default punch device */
		i = 1;				/* arg one starts the value */
	     end;
	     if p = null () then do;
no_punch:
		if arg_list.n_tokens = 1 then
		     opr_msg = "not specified.";
		else opr_msg = "not found: " || arg_list.arg (i);
		call iodd_msg_ (normal, source, zero_code, "", "Punch minor device ^a", opr_msg);
		go to cmd_error;
	     end;
	     if p -> driver_status.generic_type ^= "punch" then do; /* punch functions are only for punches */
not_a_punch:
		call iodd_msg_ (normal, source, zero_code, "", "Minor device ""^a"" is not a punch.",
		     p -> driver_status.device_id);
		go to cmd_error;
	     end;

	     pun_ctl_ptr = p -> driver_status.dev_ctl_ptr;/* get the control pointer for this driver */

	     if arg_list.n_tokens <= i | arg_list.arg (i) = "-print" then do;
		call iodd_msg_ (normal, source, zero_code, "", "Current value is:  ^[^^^]auto_punch", ^pun_ctl.auto_punch);
		go to end_cmd;
	     end;
	     do i = i to n_tokens - 1;		/* look at each argument */
		not = (substr (arg_list.arg (i), 1, 1) = "^");
						/* was first char a "^" */
		if not then
		     arg_string = substr (arg_list.arg (i), 2);
		else arg_string = arg_list.arg (i);
		if arg_string = "auto_punch" | arg_string = "autopunch" then
		     pun_ctl.auto_punch = ^not;
		else call iodd_msg_ (normal, source, zero_code, "", "Undefined argument: ^a", arg_list.arg (i));
	     end;
	     go to end_cmd;
	end;

	if command = "sep_cards" | command = "sepcards" then do;
	     if arg_list.n_tokens > 2 then do;
		p = find_driver_status_seg_ptr (arg_list.arg (1));
						/* get driver status ptr for minor device given */
		i = 2;				/* arg 2 is the value argument */
	     end;
	     else do;				/* one arg - could be value for default or ... */
						/* could be minor device name with no value */
		p = default_punch;			/* try for the default punch */
		i = 1;				/* assume first arg is the value */
	     end;
	     value = -1;				/* no value defined yet */
	     if arg_list.n_tokens > 1 then do;		/* allow for no args at all */
		if arg_list.arg (i) = "-print" then
		     value = -1;
		else if arg_list.arg (i) = "none" then
		     value = none;
		else if arg_list.arg (i) = "standard" then
		     value = standard;
		else p = find_driver_status_seg_ptr (arg_list.arg (i));
	     end;

	     if p = null () then
		go to no_punch;
	     if p -> driver_status.generic_type ^= "punch" then
		go to not_a_punch;			/* only allow punches */
	     pun_ctl_ptr = p -> driver_status.dev_ctl_ptr;/* get the control structure pointer */

	     if value = -1 then do;			/* print the current value */
		if pun_ctl.sep_cards = none then
		     opr_msg = "none";
		else if pun_ctl.sep_cards = standard then
		     opr_msg = "standard";
		else opr_msg = "Undefined value";
		call iodd_msg_ (normal, source, zero_code, "", "Current value is:  ^a", opr_msg);
	     end;

	     else pun_ctl.sep_cards = value;

	     go to end_cmd;
	end;

	if command = "read_cards" | command = "readcards" then do;
	     if reader_attached then do;
		if iodd_static.test_entry then	/* use a dummy pool root under pool_dir for test */
		     pool_dir = rtrim (iodd_static.sys_dir_ptr -> sys_dir) || ">card_pool";
						/* the test pool root */
		else pool_dir = "System_Card_Pool";	/* otherwise use the one coded in */

		call pool_manager_$init (pool_dir, minimum_quota, "1000"b, code);
						/* use 10 pages of quota initially */
						/* and set s *.*.* on initial acl of access class pool */
		if code ^= 0 then do;		/* oops! */
		     call iodd_msg_ (normal, source, code, myname, "Unable to initialize card pool.");
		     go to cmd_error;
		end;
		call iodd_msg_ (normal, source, zero_code, "", "Card input started.");
		if source = slave then
		     call iox_$control (iodd_static.slave_out, "runout", null, ignore_code);

		on card_command_level go to abort_read; /* grab control after record quota overflow */

		call read_cards_ (pool_dir, addr (card_info), terminal (source), (iodd_static.test_entry), code);
		if code ^= 0 then do;
		     call iodd_msg_ (normal, source, code, myname, "Check card deck format.");
		     go to cmd_error;
		end;
		go to end_cmd;

abort_read:
		call iodd_msg_ (normal, source, zero_code, "", "Use the ""clean_pool"" command and retry card input.");
		go to cmd_error;
	     end;
	     else do;
		call iodd_msg_ (normal, source, zero_code, "", "The card reader is not attached.");
		go to end_cmd;
	     end;
	end;

	if command = "sample_form" | command = "sampleform" then do;
	     if iodd_static.ctl_term.attached then do;	/* be sure there is a place to write */
		if iodd_static.forms then do;		/* are we simulating FF? */
		     call iox_$control (iodd_static.slave_out, "form_status", addr (form_info), code);
		     if code ^= 0 then do;		/* OOPS.... */
			iodd_static.forms = FALSE;
			iodd_static.slave_hold = TRUE;/* this is a problem for master terminal */
			call iodd_msg_ (error, both, code, myname,
			     "Bad form_status order call.  Form feed simulation terminated.");
			go to cmd_error;
		     end;
		     if ^form_info.aligned then
			call iox_$control (iodd_static.slave_out, "form_aligned", null, ignore_code);
						/* this will work */
		end;
		call write_sample_form_ (iodd_static.form_type, (iodd_static.ctl_output), code);
		if code ^= 0 then
		     if code ^= error_table_$action_not_performed then
			call iodd_msg_ (normal, source, code, myname, "Error writing form.");
		     else call iodd_msg_ (normal, source, zero_code, "", "No form type has been set.");
		go to end_cmd;
	     end;
	     call iodd_msg_ (normal, source, zero_code, "", "Control terminal is not attached.");
	     go to end_cmd;
	end;

	if command = "clean_pool" | command = "cleanpool" then do; /* garbage collect the card pool */
	     if source = slave then do;
		call iodd_msg_ (normal, source, zero_code, "", "The clean_pool command is restricted to the master terminal.")
		     ;
		go to cmd_error;
	     end;
	     if arg_list.n_tokens < 2 then do;		/* we must have an age arg */
		call iodd_msg_ (normal, source, zero_code, "", "Argument missing: days allowed to remain in the pool.");
		go to cmd_error;
	     end;
	     age = convert (age, arg_list.arg (1));	/* convert to binary */
	     if age < 1 then do;			/* be sure the value is right */
		call iodd_msg_ (normal, source, zero_code, "", "Invalid argument: ^a", arg_list.arg (1));
		go to cmd_error;
	     end;
	     if iodd_static.test_entry then		/* use a dummy pool root under sys_dir for test */
		pool_dir = rtrim (iodd_static.sys_dir_ptr -> sys_dir) || ">card_pool";
						/* this is the test pool root */
	     else pool_dir = "System_Card_Pool";	/* otherwise use the one coded in */
	     call pool_manager_$clean_pool (pool_dir, age, minimum_quota, code);
						/* let pool_manager_ do the work */
	     if code ^= 0 then
		call iodd_msg_ (normal, source, code, myname, "Unable to clean the card pool.");
	     go to end_cmd;
	end;

/*   When control passes here, the command is unknown.  So just return and let iodd_command_processor_ handle it. */

	a_code = save_code;
	return;

end_cmd:
	a_code = code;				/* pass back any defined errors */
	return;

cmd_error:
	a_code = error_table_$action_not_performed;	/* cause a resetread */
	return;
%page;

/* default error handler for the remote driver */
default_handler: entry (condition_info_ptr);

dcl  condition char (32);				/* fixed string for the call */

	condition = condition_info.condition_name;	/* this will indent funny */

	if iodd_static.request_in_progress then do;
	     dmp = addr (iodd_static.driver_ptr -> driver_status.message);
	     if dprint_msg.message_type = printer_request then /* had to know who to call */
		call do_prt_request_$error_during_request (condition);
	     else call output_request_$error_during_request (condition);
						/* take it away */
	end;
	return;					/* output_request_ should not return, but.... */
%page;
problem_notification: entry (msg_to_send);

/* this entry sends an express message to the user (if allowed) explaining the
   problem with the device.  If the user didn't get the message, try to send to
   an admin mailbox so someone can see there is a problem.  We don't care if 
   either of the recipients don't get the message.  We tried. */

dcl  msg_to_send char (*);

dcl  (user, project) char (32);
dcl  mbx_dirname char (168);
dcl  mbx_entname char (32);
dcl  mbx_access_class bit (72) aligned;

/* locate info on current request */
	driver_status_ptr = iodd_static.driver_ptr;
	mseg_message_info_ptr = addr (driver_status.descriptor);

/* if we are allowed to notify the user of the problem, then isolate the user
   name and project from the ID in the request and build the path to the user's
   mailbox */
	user = iodd_parse_$args ("notify_owner=", major_args);
	if user = "yes" then do;
	     user = before (mseg_message_info.sender_id, ".");
	     project = after (mseg_message_info.sender_id, ".");
	     project = before (project, ".");
	     mbx_dirname = ">udd>" || rtrim (project) || ">" || user;
	     mbx_entname = rtrim (user) || ".mbx";
	     mbx_access_class = mseg_message_info.sender_authorization;
	     call send_the_message;
	     if code = 0 then return;			/* got through OK */
	end;

/* if we got here, either the user isn't supposed to received the problem
   message or we tried to send it and the user would't receive the message.  In
   either case, we will see if there is an admin mailbox defined.  If there is,
   we will send the message there. */

	mbx_dirname = iodd_parse_$args ("admin_mbx=", major_args);
	if mbx_dirname = "" then return;		/* no admin address defined, forget it */

	call expand_pathname_$add_suffix (mbx_dirname, "mbx", mbx_dirname, mbx_entname, code);
	if code ^= 0 then return;

	mbx_access_class = mseg_message_info.sender_authorization;
	call send_the_message;

	return;

/* end problem_notification; */


send_the_message: proc;

/* internal entry used to send out the problem notification message */

dcl  (ipc_ind, r1_ind) fixed bin (35);

	if smi.version = -1 then do;			/* 1st call, must init */
	     smi.version = send_mail_info_version_2;
	     smi.wakeup = TRUE;
	     smi.mbz1 = ""b;
	     smi.always_add = FALSE;
	     smi.never_add = FALSE;
	     smi.notify = FALSE;
	     smi.acknowledge = FALSE;
	     smi.mbz = ""b;
	end;
	smi.sent_from = driver_status.dev_name_label;

	ipc_ind, r1_ind = -1;			/* set to non-zero to test call */

	if ^sys_priv then				/* tried once & failed */
	     go to send_it;				/* so don't bother to try again */

/* see if we can get our privileges turned on */
	on linkage_error begin;
	     sys_priv = "0"b;			/* stop trying if fail */
	     go to revert_handler;			/* send the message if possible */
	end;

	on any_other begin;
	     if r1_ind = 0 then
		call system_privilege_$ring1_priv_off (r1_ind);
	     if ipc_ind = 0 then
		call system_privilege_$ipc_priv_off (ipc_ind);
	     r1_ind, ipc_ind = -1;
	     call continue_to_signal_ (ignore_code);
	end;

	call system_privilege_$ring1_priv_on (r1_ind);

	call system_privilege_$ipc_priv_on (ipc_ind);

revert_handler:
	revert linkage_error;

send_it:	call message_facility_$send_message_access_class (mbx_dirname, mbx_entname,
	     msg_to_send, addr (smi), mbx_access_class, code);

	if r1_ind = 0 then
	     call system_privilege_$ring1_priv_off (r1_ind);

	if ipc_ind = 0 then
	     call system_privilege_$ipc_priv_off (ipc_ind);

     end send_the_message;
%page;

set_wait_timer:
     procedure ();

	call ipc_$drain_chn (ctl_wait_list.channel, code);
	if code ^= 0 then do;			/* avoid futher trouble, but not fatal */
	     ctl_wait_list.channel = 0;		/* stop trying */
	     ctl_wait_list.number = 0;
	     iodd_static.slave_hold = TRUE;		/* go back to command level for guidance */
	     ctl_msg_sent = FALSE;			/* and don't block */
	     call iodd_msg_ (error, master, zero_code, myname, "Bad call to ipc_$drain_chn.  Form synchronization terminated.");
	end;
	if ctl_msg_sent then
	     call timer_manager_$alarm_wakeup (p -> driver_status.form_wait_time, RELATIVE_SECONDS, alarm_channel);
	return;

     end set_wait_timer;



wait_for_ctl_finish:
     procedure ();

	if iodd_static.quit_during_request then do;	/* wakeup was lost */
	     ctl_msg_sent = FALSE;			/* cancel the flag */
	     return;
	end;
	if ctl_msg_sent then do;			/* avoid premature block on non-event */
	     ctl_msg_sent = FALSE;			/* ready for the next one */
	     call ipc_$block (addr (ctl_wait_list), addr (event_info), ignore_code);
						/* wait for form to finish */
	end;
	return;

     end wait_for_ctl_finish;



close_and_detach:
     procedure (a_iocbp, send_hangup);

dcl  a_iocbp ptr;
dcl  send_hangup bit (1);

	if a_iocbp = null then
	     return;

	if send_hangup then
	     call iox_$control (a_iocbp, "hangup", null, ignore_code);

	call iox_$close (a_iocbp, ignore_code);
	call iox_$detach_iocb (a_iocbp, ignore_code);

	a_iocbp = null;

	return;

     end close_and_detach;
%page;

minor_attach:
     procedure (Device);

declare  Device char (*) parameter;
declare  desc char (256) varying;
declare  mode fixed bin;
declare  device_io_module char (32) var;

	desc = major_desc || space || iodd_parse_$args ("desc=", minor_args);

	if Device = "printer" then
	     device_io_module = "remote_printer_";
	else if Device = "punch" then
	     device_io_module = "remote_punch_";
	else if Device = "reader" then
	     device_io_module = "remote_input_";

	attach_desc = device_io_module || " " || desc;
	p -> driver_status.dev_out_stream = get_switch_name (Device);

	call iox_$attach_ioname ((p -> driver_status.dev_out_stream), p -> driver_status.dev_out_iocbp, (attach_desc),
	     code);
	if code ^= 0 & code ^= error_table_$not_detached & code ^= error_table_$ionmat then
	     go to attach_error;

	if Device = "reader" then
	     mode = Stream_input;
	else mode = Stream_output;

	call iox_$open (p -> driver_status.dev_out_iocbp, mode, ""b, code);
	if code ^= 0 & code ^= error_table_$not_closed then do;
attach_error:
	     call iodd_msg_ (error, master, code, myname, "Attaching minor device:  ^a^/Attach desc:  ^a.",
		p -> driver_status.device_id, attach_desc);
	     go to clean_out;
	end;

	iodd_static.current_devices = iodd_static.current_devices + 1;

	if ^hangup_proc_defined then
	     call set_hangup_proc (p -> driver_status.dev_out_iocbp);

     end minor_attach;



get_switch_name:
     procedure (Device) returns (character (32));

declare  index fixed bin internal static init (0);
declare  Device char (*);

	index = index + 1;
	if index > 999 then
	     index = 1;				/* keep it reasonable */
	return (Device || "_" || ltrim (character (index)));

     end get_switch_name;
%page;

find_driver_status_seg_ptr:
     procedure (minor_device_name) returns (pointer);

dcl  minor_device_name varying character (*) aligned parameter;
dcl  i fixed bin;
dcl  stat_segp ptr;

	list_ptr = iodd_static.driver_list_ptr;		/* make reference easier to read */
	do i = 1 to driver_ptr_list.number;
	     stat_segp = driver_ptr_list.stat_segp (i);	/* get next driver status seg ptr */
	     if minor_device_name = stat_segp -> driver_status.device_id then
						/* look for minor name match */
		return (stat_segp);
	end;

	return (null ());				/* no minor device found with the requested name */

     end find_driver_status_seg_ptr;



set_hangup_proc:
     procedure (iocbp);

dcl  iocbp ptr;

/* this internal proc will set the device hangup procedure for the specified switch */

	hangup_info.entry = iodd_hangup_$iodd_hangup_;
	hangup_info.data_ptr = stat_p;
	hangup_info.priority = 1;
	call iox_$control (iocbp, "hangup_proc", addr (hangup_info), code);
	if code ^= 0 then
	     call iodd_msg_ (error, master, code, myname,
		"Warning: Could not establish handler for hangups from the device.");

	hangup_proc_defined = TRUE;			/* once is enuf */

	return;

     end set_hangup_proc;
%page;

set_paper_info:
     procedure (source, code);

dcl  code fixed bin (35);
dcl  source fixed bin;

	code = 0;

	call iox_$control (p -> driver_status.dev_out_iocbp, "paper_info", addr (prt_ctl.paper_info), code);
	if code ^= 0 then
	     if code = error_table_$no_operation then do; /* if dim couldn't, tell the operator */

		call iodd_msg_ (normal, source, zero_code, "",
		     "^/Mount VFU tape for ^d lines per page.^/Set printer for ^d lines/inch.",
		     prt_ctl.phys_page_length, prt_ctl.lines_per_inch);

		code = 0;				/* this is really ok */
	     end;
	     else do;
		call iodd_msg_ (normal, both, code, myname, "Unable to perform paper_info order.");
						/* a real error */
	     end;

	return;

     end set_paper_info;
%page;

get_prt_rqti_data:
     procedure (p);

dcl  p pointer;

/* internal procedure to get paper info and channel stops data from the rqt info segment
   or to establish some defaults if one is not being used */

	prt_ctl_ptr = p -> driver_status.dev_ctl_ptr;
	string (prt_ctl.flags) = ""b;

	if p -> driver_status.rqti_ptr ^= null then do;	/* if there is an rqti seg, use it */

	     prt_rqtip = p -> driver_status.rqti_ptr;	/* make the based references cleaner */
	     if prt_rqti.header.header_version ^= rqti_header_version_1 then do;
		call iodd_msg_ (error, both, error_table_$fatal_error, myname,
		     "prt rqt info header version ^d found (expected ^d)", prt_rqti.header.header_version,
		     rqti_header_version_1);
		go to clean_out;
	     end;

	     prt_ctl.meter = prt_rqti.header.meter;	/* do we take meter data? */
	     ready_device = ready_device | prt_rqti.header.auto_go;
	     p -> driver_status.ready = prt_rqti.header.auto_go;
						/* set the initial hold state as requested */
	     iodd_static.wakeup_time = max (wakeup_time_default, prt_rqti.header.driver_wait_time);
						/* seconds to wait for a request */
	     if prt_rqti.header.type_code = 0 then
		go to set_defaults;			/* this is only a header */
	     else if prt_rqti.header.type_code ^= 1 then do;
		call iodd_msg_ (error, both, error_table_$fatal_error, myname, "Wrong rqt info seg type for printer.")
		     ;
		go to clean_out;
	     end;

	     if prt_rqti.version ^= prt_rqti_version_1 then do; /* see if it is the right version */
		call iodd_msg_ (error, both, error_table_$fatal_error, myname,
		     "Wrong version of prt_rqti. Found ^d (expected ^d)", prt_rqti.version, prt_rqti_version_1);
		go to clean_out;
	     end;

	     if prt_rqti.opr_msg ^= "" then
		call iodd_msg_ (normal, both, zero_code, "", "^/^a", prt_rqti.opr_msg);
						/* give operator instructions */

	     prt_ctl.phys_page_length = prt_rqti.paper_length;
						/* get paper data for prtdim */
	     prt_ctl.phys_line_length = prt_rqti.paper_width;
	     prt_ctl.lines_per_inch = prt_rqti.lines_per_inch;

	     prt_ctl.channel_stops = prt_rqti.channel_stops;
						/* get VFU stops for printer */

	     prt_ctl.banner_type = prt_rqti.banner_type;	/* copy control info to writable storage */
	     prt_ctl.force_nep = prt_rqti.force_nep;
	     prt_ctl.force_esc = prt_rqti.force_esc;
	     prt_ctl.force_ctl_char = prt_rqti.force_ctl_char;
	     prt_ctl.no_auto_print = prt_rqti.no_auto_print;
	     prt_ctl.force_nsep = prt_rqti.force_nsep;
	     prt_ctl.banner_bars = prt_rqti.banner_bars;
	     prt_ctl.banner_indent = prt_rqti.banner_indent;
	     prt_ctl.banner_line = prt_rqti.banner_line;
	end;
	else do;					/* no rqti seg, so set some defaults */
	     prt_ctl.meter = FALSE;			/* no meters */
	     iodd_static.slave_hold = TRUE;		/* be sure to ask for a start command */
	     iodd_static.wakeup_time = wakeup_time_default; /* check every 30 seconds */
set_defaults:					/* set up the default paper data */
	     prt_ctl.phys_page_length = page_length_default; /* 11 inch paper at 6 lpi is 66 lines */
	     prt_ctl.phys_line_length = line_length_default; /* standard remote platten is 132 chars */
	     prt_ctl.lines_per_inch = lpi_default;	/* normal for good readibility */

	     string (prt_ctl.channel_stops) = FALSE;	/* no slew stops are defined */

	     prt_ctl.force_nep = FALSE;		/* let user have his way */
	     prt_ctl.force_esc = FALSE;
	     prt_ctl.force_ctl_char = FALSE;
	     prt_ctl.no_auto_print = FALSE;		/* print without requesting operator attn */
	     prt_ctl.force_nsep = FALSE;		/* print inner head and tail sheets for multiple copies */
	     prt_ctl.banner_type = NORMAL_BANNERS;	/* use normal head/tail sheets */
	     prt_ctl.banner_bars = NORMAL_BANNER_BARS;	/* means nothing for now */
	     prt_ctl.banner_indent = 0;		/* again */
	     prt_ctl.banner_line = 1;			/* again */
	end;


	return;

     end get_prt_rqti_data;
%page;

initiate_the_file:
     proc (pathname_string, args_ptr, args_length, message, code);

dcl  pathname_string char (256) varying;
dcl  args_ptr ptr;
dcl  args_length fixed bin;
dcl  message char (*);
dcl  code fixed bin (35);

dcl  dirname char (168);
dcl  entname char (32);
dcl  compname char (32);
dcl  args_bc fixed bin (24);

	call expand_pathname_$component ((pathname_string), dirname, entname, compname, code);
	if code ^= 0 then
	     return;
	call initiate_file_$component (dirname, entname, compname, R_ACCESS, args_ptr, args_bc, code);
	if code ^= 0 then
	     return;
	args_length = divide (args_bc + 8, 9, 17, 0);

     end initiate_the_file;

return_string: proc (target) returns (char (*));

/* routine to return a string from the i/o daemon tables text strings area */

dcl  1 target unaligned like text_offset;

	if target.total_chars = 0 then
	     return ("");
	else return (substr (text_strings.chars, target.first_char, target.total_chars));
     end return_string;
%page;
evaluate_forms_options: proc (error_code);

/* this subroutine will evaluate the forms option supplied by the user and the
   defaults defined for the request type and/or device.
*/

dcl  error_code fixed bin (35);

/* set to global ptrs to main groups in io daemon tables we will need */
	idtp = iodd_static.idtp;			/* device tables */
	mdtp = iodd_static.mdtp;			/* minor device tables */
	qgtp = iodd_static.qgtp;			/* request_type tables */
	dctp = iodd_static.dev_class_ptr;		/* device_class tables */
	text_strings_ptr = iodd_static.text_strings_ptr;	/* common text strings */

/* now set up ptrs to specific request type and device entries for this request */
	idtep = addr (iod_device_tab.entries (p -> driver_status.maj_index)); /* major device entry */
	mdtep = addr (minor_device_tab.entries (p -> driver_status.dev_index)); /* minor device entry */
	dctep = addr (dev_class_tab.entries (p -> driver_status.dev_class_index)); /* device_class entry */
	qgtep = addr (q_group_tab.entries (dcte.qgte_index)); /* request_type */

	if my_area_ptr = null then
	     my_area_ptr = get_system_free_area_ ();

/* set up the structure to pass in */
	if dprint_msg.version < dprint_msg_version_5 then
	     system_input_forms_string_length = length (rtrim (dprint_msg.forms));
	else system_input_forms_string_length = dprint_msg.forms_name_lth;
	evaluate_forms_info_input_ptr,
	     evaluate_forms_info_output_ptr = null;

	on cleanup begin;
	     if evaluate_forms_info_input_ptr ^= null then
		free evaluate_forms_info_input;
	     if evaluate_forms_info_output_ptr ^= null then
		free evaluate_forms_info_output;
	end;

	allocate evaluate_forms_info_input in (my_area);

	evaluate_forms_info_input.version = EVALUATE_FORMS_INFO_INPUT_VERSION_1;
	evaluate_forms_info_input.ithp = iodd_static.ithp;
	evaluate_forms_info_input.qgtep = qgtep;
	evaluate_forms_info_input.idtep = idtep;
	evaluate_forms_info_input.mdtep = mdtep;
	if dprint_msg.version < dprint_msg_version_5 then
	     evaluate_forms_info_input.forms_string = rtrim (dprint_msg.forms);
	else evaluate_forms_info_input.forms_string = dprint_msg.forms_name;
	evaluate_forms_info_input.area_ptr = my_area_ptr;

/* call common routine which does all forms validation */
	call iod_info_$evaluate_forms_info (p -> driver_status.rqti_ptr,
	     evaluate_forms_info_input_ptr, evaluate_forms_info_output_ptr,
	     error_code);
	if error_code = 0 | error_code = error_table_$no_forms_table_defined then do;
	     prt_ctl.phys_line_length = evaluate_forms_info_output.chars_per_line;
	     prt_ctl.phys_page_length = evaluate_forms_info_output.lines_per_page;
	     prt_ctl.lines_per_inch = evaluate_forms_info_output.lines_per_inch;
	     p -> driver_status.forms_validation_ptr = evaluate_forms_info_output_ptr;
	     error_code = 0;
	end;

	free evaluate_forms_info_input;

     end evaluate_forms_options;
%page; %include access_mode_values;
%page; %include card_stream_info;
%page; %include condition_info;
%page; %include device_class;
%page; %include dprint_msg;
%page; %include driver_ptr_list;
%page; %include driver_status;
%page; %include iod_constants;
%page; %include iod_device_tab;
%page; %include iod_tables_hdr;
%page; %include iod_line_tab;
%page; %include iodd_static;
%page; %include iox_modes;
%page; %include mseg_message_info;
%page; %include output_request_data;
%page; %include prt_ctl;
%page; %include prt_order_info;
%page; %include prt_rqti;
%page; %include q_group_tab;
%page; %include queue_msg_hdr;
%page; %include request_descriptor;
%page; %include send_mail_info;
%page; %include terminal_info;
%page; %include system_constants;
%page; %include system_forms_info;
%page; %include timer_manager_constants;

     end remote_driver_;
