/****^  ********************************************
        *                                          *
        * Copyright, (C) Honeywell Bull Inc., 1988 *
        *                                          *
        ******************************************** */


/****^  HISTORY COMMENTS:
  1) change(88-07-25,Brunelle), approve(88-07-25,MCR7911),
     audit(88-10-25,Wallman), install(88-11-08,MR12.2-1199):
     Created
  2) change(88-11-03,Brunelle), approve(88-11-03,MCR7911),
     audit(88-11-08,Wallman), install(88-11-08,MR12.2-1199):
     Removed code to put box around charges on tail sheet.
  3) change(88-11-14,Brunelle), approve(88-11-14,PBF7911),
     audit(88-11-14,Wallman), install(88-11-14,MR12.2-1212):
     Handle null ptr to ordata if printing separator only and output the
     separator only message in the aim display area.
                                                   END HISTORY COMMENTS */

/* format: style4 */


/* head and tail sheet programs for the Honeywell Bull model 80 laser printers
   liberally taken from head_sheet_ and tail_sheet_ */

iodd_hblp_banner_pages_: proc;

/* no entry here */
	return;

/* Parameters */

dcl  a_code fixed bin (35) parameter;			/* Return error code */
dcl  a_message char (*) parameter;
dcl  a_ordatap ptr parameter;				/* ptr to output_request_data */
dcl  a_prt_ctl_ptr pointer parameter;			/* pointer to prt_ctl */
dcl  a_switch pointer parameter;			/* IOCB ptr for same */

/* External Procedures & Variables */

dcl  bigletter_$five entry (char (*), entry);
dcl  date_time_$format entry (char (*), fixed bin (71), char (*), char (*)) returns (char (250) var);
dcl  hcs_$initiate_count entry (char (*), char (*), char (*), fixed bin (24), fixed bin (2), ptr, fixed bin (35));
dcl  hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
dcl  hcs_$terminate_noname entry (ptr, fixed bin (35));
dcl  hcs_$truncate_seg entry (ptr, fixed bin, fixed bin (35));
dcl  ioa_$rsnnl entry options (variable);
dcl  iox_$control entry (ptr, char (*), ptr, fixed bin (35));
dcl  iox_$modes entry (pointer, char (*), char (*), fixed bin (35));
dcl  iox_$put_chars entry (pointer, pointer, fixed bin (21), fixed bin (35));
dcl  system_info_$installation_id entry (char (*) aligned);
dcl  system_info_$max_rs_number entry (fixed bin);
dcl  system_info_$rs_name entry (fixed bin, char (*), fixed bin (35));

/* Builtins */

dcl  (addr, after, before, byte, divide, hbound, length, ltrim, max, null, reverse, rtrim, string, substr) builtin;

/* Internal Static */

dcl  CR char (1) defined CR_NL_FF position (1);
dcl  CR_NL char (2) defined CR_NL_FF position (1);
dcl  FF char (1) defined CR_NL_FF position (3);

/* The following line is defined with CR NL FF */
dcl  CR_NL_FF char (3) int static options (constant) init ("
");

dcl  HEAD fixed bin int static options (constant) init (1);
dcl  SEPARATOR fixed bin int static options (constant) init (3);
dcl  TAIL fixed bin int static options (constant) init (2);
dcl  copy_offset fixed bin int static;			/* where to put the copy number data for copy 2, 3,... */
dcl  installation char (32) aligned int static;		/* Local installation ID */
dcl  last_request_no fixed bin int static;		/* request number of the last request */
dcl  max_rs_number fixed bin int static init (-1);	/* maximum rate structure number */
dcl  rs_names (-1:9) char (32) static int init ((11) ("tail_sheet_ uninitialized"));
dcl  sysdir char (168) int static init (">daemon_dir_dir>io_daemon_dir");
dcl  templates_ptr ptr int static init (null);
dcl  time_format char (64) internal static options (constant) init ("^dn, ^dm ^mn ^9999yc, ^Hd:^MH ^za");

dcl  TOP_RQT_LINE fixed bin internal static options (constant) init (1);
dcl  BOTTOM_RQT_LINE fixed bin internal static options (constant) init (2);
dcl  TOP_SHORT_PATH fixed bin internal static options (constant) init (3);
dcl  BOTTOM_SHORT_PATH fixed bin internal static options (constant) init (4);
dcl  TOP_LONG_PATH fixed bin internal static options (constant) init (5);
dcl  BOTTOM_LONG_PATH fixed bin internal static options (constant) init (6);
dcl  ACCESS_CLASS fixed bin internal static options (constant) init (7);
dcl  BIG_ACCESS_CLASS fixed bin internal static options (constant) init (8);
dcl  HS_DATE_INSTALLATION fixed bin internal static options (constant) init (9);
dcl  HS_BIG_DESTINATION fixed bin internal static options (constant) init (10);
dcl  HS_BIG_HEADER fixed bin internal static options (constant) init (11);
dcl  HS_HEAD_DESTINATION fixed bin internal static options (constant) init (12);
dcl  HS_LANDSCAPE_DEST fixed bin internal static options (constant) init (13);
dcl  HS_LANDSCAPE_HEAD fixed bin internal static options (constant) init (14);

dcl  TS_TIME_REQUESTED fixed bin internal static options (constant) init (15);
dcl  TS_TIME_OUTPUT fixed bin internal static options (constant) init (16);
dcl  TS_OUTPUT_MODE fixed bin internal static options (constant) init (17);
dcl  TS_FORMS_CONTROL fixed bin internal static options (constant) init (18);
dcl  TS_RQT_QUEUE fixed bin internal static options (constant) init (19);
dcl  TS_HEAD_DESTINATION fixed bin internal static options (constant) init (20);
dcl  TS_PAGE_CHARGE fixed bin internal static options (constant) init (21);
dcl  TS_LINE_CHARGE fixed bin internal static options (constant) init (22);
dcl  TS_CHARGE_TO fixed bin internal static options (constant) init (23);
dcl  TS_RATE_STRUCTURE fixed bin internal static options (constant) init (24);

/* Automatic */

dcl  (i, j, n) fixed bin;				/* misc indices */
dcl  advert_bc fixed bin (24);			/* bitcount of advertising page */
dcl  advert_ptr ptr;				/* ptr to advertising page */
dcl  buffer char (buffer_length) based (buffer_ptr);	/* current output buffer */
dcl  buffer_length fixed bin (21) based (buffer_length_ptr);/* length of output buffer */
dcl  buffer_ptr ptr;				/* ptr to current output buffer */
dcl  buffer_length_ptr ptr;				/* ptr to current length of output buffer */
dcl  calc_page_charge float bin;			/* temporary storage for  page charge */
dcl  calc_line_charge float bin;			/* temporary storage for line charge */
dcl  dest char (64) aligned;				/* temp destination string */
dcl  head char (64) aligned;
dcl  iocbp pointer;					/* ptr to IOCB to output on */
dcl  line_75_chars char (75);
dcl  line_90_chars char (90);
dcl  message char (200) var;				/* internal copy of message to output */
dcl  real_page_count fixed bin;			/* Actual page count taking -no_separator into account. */
dcl  real_line_count fixed bin;			/* Actual line count taking -no_separator into account. */
dcl  temp char (280) aligned;				/* temp copy of message */
dcl  xcode fixed bin (35);

/* Based */

dcl  1 templates based (templates_ptr),
       2 head_sheet,
         3 lngth fixed bin (21),
         3 strng char (4096),
       2 tail_sheet,
         3 lngth fixed bin (21),
         3 strng char (4096),
       2 access_class,
         3 lngth fixed bin (21),
         3 strng char (1024),
       2 current_head_sheet,
         3 lngth fixed bin (21),
         3 strng char (8192),
       2 current_tail_sheet,
         3 lngth fixed bin (21),
         3 strng char (8192),
       2 position (24),
         3 horizontal fixed bin (17) unaligned,
         3 vertical fixed bin (17) unaligned;
%page;
/* output the front banner page for the output request.

   the head_sheet_ entrypoint has not been reproduced here since it was an old
   entrypoint used in the ios_ days */

print_head_sheet: entry (a_switch, a_prt_ctl_ptr, a_ordatap, a_code);

	iocbp = a_switch;

	a_code = 0;				/* no errors yet */
	ordatap = a_ordatap;			/* locate data about the output request */
	dmp = ordata.dpmp;				/* get ptr to dprint_msg */

	call create_head_sheet;
	if a_code ^= 0 then return;

	call print_the_banner_page (HEAD);

	return;
%page;
/* output the back banner page for the output request.

   the tail_sheet_ entrypoint has not been reproduced here since it was an old
   entrypoint used in the ios_ days */

print_tail_sheet: entry (a_switch, a_prt_ctl_ptr, a_ordatap, a_code);

	iocbp = a_switch;

	a_code = 0;				/* no errors yet */
	ordatap = a_ordatap;			/* locate data about the output request */
	dmp = ordata.dpmp;				/* get ptr to dprint_msg */

	call create_tail_sheet;
	if a_code ^= 0 then return;

	call print_the_banner_page (TAIL);

	return;
%page;
/* output a separator page.

   the separator entrypoint has not been reproduced here since it was an old
   entrypoint used in the ios_ days. */

print_separator: entry (a_switch, a_prt_ctl_ptr, a_message, a_code);

	iocbp = a_switch;

	ordatap = null;				/* this is not a real request for head_sheet */
	message = ltrim (rtrim (a_message));		/* copy and clean the message */
	a_code = 0;

	call create_head_sheet;			/* build a dummy head sheet page */
	if a_code ^= 0 then return;

	last_request_no = -1;			/* mark last head sheet as destroyed */
	copy_offset = 0;

/* if the message is real, center it using small bigletters */

	if message ^= "" then do;
	     temp = ltrim (rtrim (message));		/* strip leading & trailing spaces */
	     i = length (temp);			/* real message length */
	     head = "";				/* clear the heading */

/* Switch to 12 pitch and 8 LPI to make bigletters more readable. */
	     Select_font.body = 2;
	     call output_string (string (Select_font));
	     call output_string (Set_default_hmi);
	     Set_vmi.body = byte (7);
	     call output_string (string (Set_vmi));

	     Absolute_vertical_position.body = templates.position (BIG_ACCESS_CLASS).vertical;
	     call output_string (string (Absolute_vertical_position));

	     substr (head, max (1, divide (13 - i, 2, 17) + 1)) = substr (temp, 1, 13);
	     call bigletter_$five (substr (head, 1, 13), output_bigletters);
						/* write the big message */
	end;

/* add control chars to make the head sheet print */
	call output_string (CR);
	call output_string (FF);

	call print_the_banner_page (SEPARATOR);

	return;
%page;

/* tail_save.pl1 for the tail_sheet_ code goes here */

%page;
/* ------- INIT ENTRY ------- */

init: entry ();

	last_request_no = 0;
	return;


/* ------- SET CTL ENTRY ------- */

set_ctl: entry (a_prt_ctl_ptr, a_code);

/* This entry is used to get data on how the head sheet is to be aligned and
   how banner bars are to be printed */

/* we ignore since it has no meaning for us */

	a_code = 0;

	return;


/* ------- TEST ENTRY ------- */

test: entry (a_sys_dir);

/* define new directory to locate the advertising page in */

dcl  a_sys_dir char (*);

	sysdir = a_sys_dir;				/* for testing the new notice mechanism */
	return;
%page;

build_templates: proc;

/* this internal proc will create the buffer and set all the internal static
   values.  It will create the head and tail sheet templates based on an
   8.5 X 11 inch paper specification.

   There are a lot of numeric literal values here being plugged into many
   escape strings.  These escape strings are for the Honeywell Bull Model 80
   laser printer and are documented in the
   . PRU7260/7261/7262 Printer Programming Handbook
   . Order number HK12 */

	a_code = 0;				/* start clean */

	if templates_ptr = null then do;		/* initialize buffer seg in process dir */
	     call hcs_$make_seg ("", "banner_pages_.template", "", 01010b, templates_ptr, a_code);
	     if templates_ptr = null then
		return;				/* if it didn't work, return code to caller */
	end;
	call hcs_$truncate_seg (templates_ptr, 0, a_code);
	if a_code ^= 0 then
	     return;

	call system_info_$installation_id (installation);

	buffer_ptr = addr (templates.head_sheet.strng);
	buffer_length_ptr = addr (templates.head_sheet.lngth);
	buffer_length = 0;

/* Both the head sheet and tail sheet have much in common, so we first
   generate the common part. */

/* initialize printer to known state */
	call output_string (Soft_reset);

/* Select Courier 10 font. */
	Select_font.body = 1;
	call output_string (string (Select_font));

/* Set page orientation to portrait. */
	Set_page_orientation.body = 1;		/* Portrait */
	call output_string (string (Set_page_orientation));

/* Set the left and right margins. */
	Set_left_margin.body = 42;
	call output_string (string (Set_left_margin));

	Set_right_margin.body = 942;
	call output_string (string (Set_right_margin));

/* Draw border box.  The border box is 18/720 inches in width and slightly
   inside the page limits. */
	Draw_box.left_edge = 180;
	Draw_box.top_edge = 0;
	Draw_box.right_edge = 5526;
	Draw_box.bottom_edge = 7542;
	Draw_box.line_width = 18;
	call output_string (string (Draw_box));

/* Draw necessary horizontal lines.  Each line is 18/720 inches thick and
   begins just inside the left edge of the border box.  All lines are the same
   length, ending at the inside of the right edge of the border box.  The only
   difference in the lines is where they are drawn relative to the top limit. */
	Draw_line.left_edge = 198;			/* same for all lines */
	Draw_line.right_edge = 5508;			/* same for all lines */
	Draw_line.bottom_edge = 18;			/* same for all lines */

	Draw_line.top_edge = 320;			/* line 1 */
	call output_string (string (Draw_line));

	Draw_line.top_edge = 640;			/* line 2 */
	call output_string (string (Draw_line));

	Draw_line.top_edge = 2364;			/* line 5 */
	call output_string (string (Draw_line));

	Draw_line.top_edge = 2684;			/* line 6 */
	call output_string (string (Draw_line));

	Draw_line.top_edge = 6902;			/* line 7 */
	call output_string (string (Draw_line));

	Draw_line.top_edge = 7222;			/* line 8 */
	call output_string (string (Draw_line));

/* This is the end of the common head/tail sheet template.
   Copy what's done to the tail sheet string. */

	templates.tail_sheet.lngth = buffer_length;

	templates.tail_sheet.strng = buffer;

/* Add on the normal head sheet specific stuff. */

	Draw_line.left_edge = 198;			/* same for all lines */
	Draw_line.right_edge = 5508;			/* same for all lines */
	Draw_line.bottom_edge = 18;			/* same for all lines */

	Draw_line.top_edge = 1342;			/* line 3 */
	call output_string (string (Draw_line));

	Draw_line.top_edge = 1662;			/* line 4 */
	call output_string (string (Draw_line));

	Assign_font.body.font_number = 5;
	Assign_font.body.orientation = 2;
	Assign_font.body.font_name = "LETTER GOTHIC 15";

	call output_string (string (Assign_font.header));
	call output_string (rtrim (string (Assign_font.body)));
	call output_string (string (Assign_font.trailer));

/* Generate normal tail sheet specific parts. */

/****	buffer_ptr = addr (templates.tail_sheet.strng);
      buffer_length_ptr = addr (templates.tail_sheet.lngth);

      Draw_box.left_edge = 430;
      Draw_box.top_edge = 773;
      Draw_box.right_edge = 4864;
      Draw_box.bottom_edge = 1440;
      Draw_box.line_width = 9;
      call output_string (string (Draw_box)); ****/

/* Now generate access class specific stuff. */

	buffer_ptr = addr (templates.access_class.strng);
	buffer_length_ptr = addr (templates.access_class.lngth);
	buffer_length = 0;

	Draw_line.left_edge = 198;			/* same for all lines */
	Draw_line.right_edge = 5508;			/* same for all lines */
	Draw_line.bottom_edge = 18;			/* same for all lines */

	Draw_line.top_edge = 3386;
	call output_string (string (Draw_line));

	Draw_line.top_edge = 3706;
	call output_string (string (Draw_line));

/* Finally, store the horizontal and vertical positions for the various text
   lines used in the head and tail sheets. */

	templates.position (*).horizontal = 0;
	templates.position (*).vertical = 0;

	templates.position (TOP_RQT_LINE).vertical = 14;

	templates.position (BOTTOM_RQT_LINE).vertical = 494;

	templates.position (TOP_SHORT_PATH).vertical = 35;

	templates.position (BOTTOM_SHORT_PATH).vertical = 474;

	templates.position (TOP_LONG_PATH).vertical = 32;

	templates.position (BOTTOM_LONG_PATH).vertical = 470;

	templates.position (ACCESS_CLASS).vertical = 239;

	templates.position (BIG_ACCESS_CLASS).vertical = 193;

	templates.position (HS_BIG_DESTINATION).vertical = 57;
	templates.position (HS_HEAD_DESTINATION).vertical = 103;

	templates.position (HS_DATE_INSTALLATION).vertical = 171;

	templates.position (HS_BIG_HEADER).vertical = 125;

	templates.position (HS_LANDSCAPE_DEST).vertical,
	     templates.position (HS_LANDSCAPE_HEAD).vertical = 8;

	templates.position (HS_LANDSCAPE_HEAD).horizontal = 1260;

	templates.position (TS_TIME_REQUESTED).horizontal = 120;
	templates.position (TS_TIME_REQUESTED).vertical = 62;

	templates.position (TS_TIME_OUTPUT).horizontal = 120;
	templates.position (TS_TIME_OUTPUT).vertical = 70;

	templates.position (TS_OUTPUT_MODE).horizontal = 120;
	templates.position (TS_OUTPUT_MODE).vertical = 86;

	templates.position (TS_FORMS_CONTROL).horizontal = 120;
	templates.position (TS_FORMS_CONTROL).vertical = 94;

	templates.position (TS_RQT_QUEUE).horizontal = 120;
	templates.position (TS_RQT_QUEUE).vertical = 150;

	templates.position (TS_PAGE_CHARGE).horizontal = 120;
	templates.position (TS_PAGE_CHARGE).vertical = 110;

	templates.position (TS_LINE_CHARGE).horizontal = 120;
	templates.position (TS_LINE_CHARGE).vertical = 118;

	templates.position (TS_CHARGE_TO).horizontal = 120;
	templates.position (TS_CHARGE_TO).vertical = 126;

	templates.position (TS_RATE_STRUCTURE).horizontal = 120;
	templates.position (TS_RATE_STRUCTURE).vertical = 134;


	templates.position (TS_HEAD_DESTINATION).vertical = 171;

	templates.current_head_sheet.strng, templates.current_tail_sheet.strng = "";
	templates.current_head_sheet.lngth, templates.current_tail_sheet.lngth = 0;

/* if we've never done it before, get all the rate_structure names.
   For RS numbers > max_rs_number, system_info_ will return a name
   of the form " INVALID_RS_n". */

	if max_rs_number < 0 then do;
	     call system_info_$max_rs_number (max_rs_number);
	     do i = 0 to hbound (rs_names (i), 1);
		call system_info_$rs_name (i, rs_names (i), (0));
	     end;
	end;

	return;

     end build_templates;
%page;
create_head_sheet: proc;

/* this is a special-purpose routine to generate the head sheet for the
   Honeywell Bull laser printer */

dcl  copies_string char (22) aligned;			/* temp string where we build "Copy X of Y" */
dcl  copies_string_len fixed bin;			/* length of copies_string */
dcl  request_number char (20);			/* space for the 1st header line */
dcl  request_number_len fixed bin;			/* length of valid chars in request_number */

	if templates_ptr = null then do;
	     call build_templates;
	     if a_code ^= 0 then return;
	end;

/* copy in the common portion of the head sheet into the buffer */
	buffer_ptr = addr (templates.current_head_sheet.strng);
	buffer_length_ptr = addr (templates.current_head_sheet.lngth);

	buffer_length = templates.head_sheet.lngth;
	buffer = templates.head_sheet.strng;

/* get out of no output request data to process */
	if ordatap = null then return;

/* if we need to display the access class, add the access class specific strings */

	if ordata.access_class_string ^= "" then do;
	     i = buffer_length;
	     buffer_length = buffer_length + templates.access_class.lngth;
	     substr (buffer, i + 1) = substr (templates.access_class.strng, 1, templates.access_class.lngth);
	end;

/* Build the line with the request number, requestor, and optional copies. */

	line_75_chars = "";
	call ioa_$rsnnl ("^d", request_number, request_number_len, ordata.request_no);
	substr (line_75_chars, 1, request_number_len) = substr (request_number, 1, request_number_len);
	substr (line_75_chars, length (line_75_chars) - request_number_len + 1) = substr (request_number, 1, request_number_len);

	substr (line_75_chars, request_number_len + 5, 32) = ordata.requestor;

	if ordata.copies > 1
	then do;
	     if ordata.no_separator
	     then call ioa_$rsnnl ("^d copies", copies_string, copies_string_len, ordata.copies);
	     else call ioa_$rsnnl ("copy ^d of ^d", copies_string, copies_string_len, ordata.copy_no, ordata.copies);
	     substr (line_75_chars, length (line_75_chars) - copies_string_len - request_number_len - 3, copies_string_len) = substr (copies_string, 1, copies_string_len);
	end;

	Absolute_vertical_position.body = templates.position (TOP_RQT_LINE).vertical;
	call output_string (string (Absolute_vertical_position));
	call output_string (CR);
	call output_string (line_75_chars);

	Absolute_vertical_position.body = templates.position (BOTTOM_RQT_LINE).vertical;
	call output_string (string (Absolute_vertical_position));
	call output_string (CR);
	call output_string (line_75_chars);

/* Output the full pathname.  If the pathname is longer than can be displayed
   on a single 10-pitch line (>75 characters), then switch to 12-pitch.  If the
   pathname is longer than can be displayed on a single 12-pitch line (>90
   characters), then display the pathname on two lines.
*/

	if length (rtrim (ordata.full_path)) > length (line_75_chars)
	then do;					/* switch to 12 pitch */
	     Select_font.body = 2;			/* Elite 12 font */
	     call output_string (string (Select_font));
	     call output_string (Set_default_hmi);	/* 12 pitch */
	     if length (rtrim (ordata.full_path)) > length (line_90_chars)
	     then do;				/* 2-line pathname */
		Set_vmi.body = byte (7);		/* 8 LPI */
		call output_string (string (Set_vmi));

		Absolute_vertical_position.body = templates.position (TOP_LONG_PATH).vertical;
		call output_string (string (Absolute_vertical_position));
		call output_string (CR);
		call output_string (substr (ordata.full_path, 1, length (line_90_chars)));
		call output_string (CR_NL);
		call output_string (rtrim (substr (ordata.full_path, length (line_90_chars) + 1)));

		Absolute_vertical_position.body = templates.position (BOTTOM_LONG_PATH).vertical;
		call output_string (string (Absolute_vertical_position));
		call output_string (CR);
		call output_string (substr (ordata.full_path, 1, length (line_90_chars)));
		call output_string (CR_NL);
		call output_string (rtrim (substr (ordata.full_path, length (line_90_chars) + 1)));
	     end;
	     else do;				/* 1-line pathname */
		Absolute_vertical_position.body = templates.position (TOP_SHORT_PATH).vertical;
		call output_string (string (Absolute_vertical_position));
		call output_string (CR);
		call output_string (string (Begin_auto_center_mode));
		call output_string (rtrim (ordata.full_path));
		call output_string (string (End_auto_center_mode));

		Absolute_vertical_position.body = templates.position (BOTTOM_SHORT_PATH).vertical;
		call output_string (string (Absolute_vertical_position));
		call output_string (CR);
		call output_string (string (Begin_auto_center_mode));
		call output_string (rtrim (ordata.full_path));
		call output_string (string (End_auto_center_mode));
	     end;

	     Select_font.body = 1;			/* Courier 10 */
	     call output_string (string (Select_font));
	     call output_string (Set_default_hmi);	/* 10 pitch */
	end;
	else do;					/* 1-line pathname, 10 pitch */
	     Absolute_vertical_position.body = templates.position (TOP_SHORT_PATH).vertical;
	     call output_string (string (Absolute_vertical_position));
	     call output_string (CR);
	     call output_string (string (Begin_auto_center_mode));
	     call output_string (rtrim (ordata.full_path));
	     call output_string (string (End_auto_center_mode));

	     Absolute_vertical_position.body = templates.position (BOTTOM_SHORT_PATH).vertical;
	     call output_string (string (Absolute_vertical_position));
	     call output_string (CR);
	     call output_string (string (Begin_auto_center_mode));
	     call output_string (rtrim (ordata.full_path));
	     call output_string (string (End_auto_center_mode));
	end;

/* Build the date/time string and installation identifier. */

	line_75_chars = date_time_$format (time_format, ordata.time_start_request, "system_zone", "system_lang");
	substr (line_75_chars, length (line_75_chars) - length (rtrim (installation)) + 1) = rtrim (installation);

	Absolute_vertical_position.body = templates.position (HS_DATE_INSTALLATION).vertical;
	call output_string (string (Absolute_vertical_position));
	call output_string (CR);
	call output_string (line_75_chars);

/* Print destination and header in shadowed big letters. */

	if dprint_msg.destination = ""
	then dest = before (after (ordata.requestor, "."), ".");
	else dest = dprint_msg.destination;

	if dprint_msg.heading = ""
	then head = before (ordata.requestor, ".");
	else if substr (dprint_msg.heading, 1, 5) = " for "
	then head = substr (dprint_msg.heading, 6);
	else head = dprint_msg.heading;

/* Switch to 12 pitch and 8 LPI to make bigletters more readable. */

	Select_font.body = 2;
	call output_string (string (Select_font));
	call output_string (Set_default_hmi);
	Set_vmi.body = byte (7);
	call output_string (string (Set_vmi));

	Absolute_vertical_position.body = templates.position (HS_BIG_DESTINATION).vertical;
	call output_string (string (Absolute_vertical_position));
	call bigletter_$five (rtrim (substr (dest, 1, 13)), output_bigletters);

	Absolute_vertical_position.body = templates.position (HS_BIG_HEADER).vertical;
	call output_string (string (Absolute_vertical_position));
	call bigletter_$five (rtrim (substr (head, 1, 13)), output_bigletters);

	if ordata.access_class_string ^= "" then do;
	     Absolute_vertical_position.body = templates.position (BIG_ACCESS_CLASS).vertical;
	     call output_string (string (Absolute_vertical_position));
	     call bigletter_$five (rtrim (substr (ordata.access_class_string, 1, 13)), output_bigletters);
	end;

	Absolute_vertical_position.body = templates.position (HS_HEAD_DESTINATION).vertical;
	call output_string (string (Absolute_vertical_position));

	if length (rtrim (head)) + length (rtrim (dest)) + 2 > length (line_75_chars)
	then do;
	     line_90_chars = dest;
	     substr (line_90_chars, length (line_90_chars) - length (rtrim (head)) + 1) = rtrim (head);
	     call output_string (CR);
	     call output_string (line_90_chars);
	end;
	else do;
	     line_75_chars = dest;
	     substr (line_75_chars, length (line_75_chars) - length (rtrim (head)) + 1) = rtrim (head);
	     Select_font.body = 1;
	     call output_string (string (Select_font));
	     call output_string (Set_default_hmi);
	     Set_vmi.body = byte (9);
	     call output_string (string (Set_vmi));
	     call output_string (CR);
	     call output_string (line_75_chars);
	end;

	if ordata.access_class_string = ""
	then ;
	else do;
	     Select_font.body = 1;
	     call output_string (string (Select_font));
	     call output_string (Set_default_hmi);
	     Set_vmi.body = byte (9);
	     call output_string (string (Set_vmi));
	     Absolute_vertical_position.body = templates.position (ACCESS_CLASS).vertical;
	     call output_string (string (Absolute_vertical_position));
	     call output_string (CR);
	     call output_string (string (Begin_auto_center_mode));
	     call output_string (rtrim (ordata.access_class_string));
	     call output_string (string (End_auto_center_mode));
	end;

/* Now switch to landscape orientation and print the destination/header. */

	Set_page_orientation.body = 2;
	call output_string (string (Set_page_orientation));

	Select_font.body = 5;
	call output_string (string (Select_font));

/*	call output_string (Begin_proportional_mode); */

	Absolute_horizontal_position.body = templates.position (HS_LANDSCAPE_DEST).horizontal;
	call output_string (string (Absolute_horizontal_position));

	Absolute_vertical_position.body = templates.position (HS_LANDSCAPE_DEST).vertical;
	call output_string (string (Absolute_vertical_position));

	call output_string (rtrim (dest));

	Absolute_horizontal_position.body = templates.position (HS_LANDSCAPE_HEAD).horizontal;
	call output_string (string (Absolute_horizontal_position));

	call output_string (Begin_backward_print_mode);

	call output_string (reverse (rtrim (head)));

	call output_string (End_backward_print_mode);

/* 	call output_string (End_proportional_mode); */

/* add control strings so printer notice will print out in a reasonable manner */
	Set_page_orientation.body = 1;
	call output_string (string (Set_page_orientation));

	Select_font.body = 1;
	call output_string (string (Select_font));

	call output_string (CR);
	call output_string (FF);

	return;

     end create_head_sheet;
%page;
create_tail_sheet: proc;

/* this is a special-purpose routine to generate the tail sheet for the
   Honeywell Bull laser printer */

dcl  copies_string char (22) aligned;			/* temp string where we build "Copy X of Y" */
dcl  copies_string_len fixed bin;			/* length of copies_string */
dcl  request_number char (20);			/* space for the 1st header line */
dcl  request_number_len fixed bin;			/* length of valid chars in request_number */

	if templates_ptr = null then do;
	     call build_templates;
	     if a_code ^= 0 then return;
	end;

/* copy in the common portion of the tail sheet into the buffer */
	buffer_ptr = addr (templates.current_tail_sheet.strng);
	buffer_length_ptr = addr (templates.current_tail_sheet.lngth);

	buffer_length = templates.tail_sheet.lngth;
	buffer = templates.tail_sheet.strng;

/* if we need to display the access class, add the access class specific strings */

	if ordata.access_class_string ^= "" then do;
	     i = buffer_length;
	     buffer_length = buffer_length + templates.access_class.lngth;
	     substr (buffer, i) = substr (templates.access_class.strng, 1, templates.access_class.lngth);
	end;

/* Build the line with the request number, requestor, and optional copies. */

	line_75_chars = "";
	call ioa_$rsnnl ("^d", request_number, request_number_len, ordata.request_no);
	substr (line_75_chars, 1, request_number_len) = substr (request_number, 1, request_number_len);
	substr (line_75_chars, length (line_75_chars) - request_number_len + 1) = substr (request_number, 1, request_number_len);

	substr (line_75_chars, request_number_len + 5, 32) = ordata.requestor;

	if ordata.copies > 1 then do;
	     if ordata.no_separator then
		call ioa_$rsnnl ("^d copies", copies_string, copies_string_len, ordata.copies);
	     else call ioa_$rsnnl ("copy ^d of ^d", copies_string, copies_string_len, ordata.copy_no, ordata.copies);
	     substr (line_75_chars, length (line_75_chars) - copies_string_len - request_number_len - 3, copies_string_len) = substr (copies_string, 1, copies_string_len);
	end;

	Absolute_vertical_position.body = templates.position (TOP_RQT_LINE).vertical;
	call output_string (string (Absolute_vertical_position));
	call output_string (CR);
	call output_string (line_75_chars);

	Absolute_vertical_position.body = templates.position (BOTTOM_RQT_LINE).vertical;
	call output_string (string (Absolute_vertical_position));
	call output_string (CR);
	call output_string (line_75_chars);

/* Output the full pathname.  If the pathname is longer than can be displayed
   on a single 10-pitch line (>75 characters), then switch to 12-pitch.  If
   the pathname is longer than can be displayed on a single 12-pitch line (>90
   characters), then display the pathname on two lines. */

	if length (rtrim (ordata.full_path)) > length (line_75_chars) then do; /* switch to 12 pitch */
	     Select_font.body = 2;			/* Elite 12 font */
	     call output_string (string (Select_font));
	     call output_string (Set_default_hmi);	/* 12 pitch */
	     if length (rtrim (ordata.full_path)) > length (line_90_chars) then do; /* 2-line pathname */
		Set_vmi.body = byte (7);		/* 8 LPI */
		call output_string (string (Set_vmi));

		Absolute_vertical_position.body = templates.position (TOP_LONG_PATH).vertical;
		call output_string (string (Absolute_vertical_position));
		call output_string (CR);
		call output_string (substr (ordata.full_path, 1, length (line_90_chars)));
		call output_string (CR_NL);
		call output_string (rtrim (substr (ordata.full_path, length (line_90_chars) + 1)));

		Absolute_vertical_position.body = templates.position (BOTTOM_LONG_PATH).vertical;
		call output_string (string (Absolute_vertical_position));
		call output_string (CR);
		call output_string (substr (ordata.full_path, 1, length (line_90_chars)));
		call output_string (CR_NL);
		call output_string (rtrim (substr (ordata.full_path, length (line_90_chars) + 1)));
	     end;
	     else do;				/* 1-line pathname */
		Absolute_vertical_position.body = templates.position (TOP_SHORT_PATH).vertical;
		call output_string (string (Absolute_vertical_position));
		call output_string (CR);
		call output_string (string (Begin_auto_center_mode));
		call output_string (rtrim (ordata.full_path));
		call output_string (string (End_auto_center_mode));

		Absolute_vertical_position.body = templates.position (BOTTOM_SHORT_PATH).vertical;
		call output_string (string (Absolute_vertical_position));
		call output_string (CR);
		call output_string (string (Begin_auto_center_mode));
		call output_string (rtrim (ordata.full_path));
		call output_string (string (End_auto_center_mode));
	     end;

	     Select_font.body = 1;			/* Courier 10 */
	     call output_string (string (Select_font));
	     call output_string (Set_default_hmi);	/* 10 pitch */
	end;
	else do;					/* 1-line pathname, 10 pitch */
	     Absolute_vertical_position.body = templates.position (TOP_SHORT_PATH).vertical;
	     call output_string (string (Absolute_vertical_position));
	     call output_string (CR);
	     call output_string (string (Begin_auto_center_mode));
	     call output_string (rtrim (ordata.full_path));
	     call output_string (string (End_auto_center_mode));

	     Absolute_vertical_position.body = templates.position (BOTTOM_SHORT_PATH).vertical;
	     call output_string (string (Absolute_vertical_position));
	     call output_string (CR);
	     call output_string (string (Begin_auto_center_mode));
	     call output_string (rtrim (ordata.full_path));
	     call output_string (string (End_auto_center_mode));
	end;

	line_75_chars = "Requested:     " || rtrim (date_time_$format (time_format, dprint_msg.msg_time, "system_zone", "system_lang"));
	call output_position_and_string (TS_TIME_REQUESTED, rtrim (line_75_chars));

	line_75_chars = "Output:        " || rtrim (date_time_$format (time_format, ordata.time_start_request, "system_zone", "system_lang"));
	call output_position_and_string (TS_TIME_OUTPUT, rtrim (line_75_chars));

	if ordata.output_mode ^= "" then do;
	     call output_position_and_string (TS_OUTPUT_MODE, "Output mode:   " || rtrim (ordata.output_mode));
	end;

	if dprint_msg.version < dprint_msg_version_5 then do;
	     if dprint_msg.forms ^= "" then
		call output_position_and_string (TS_FORMS_CONTROL, "Forms control: " || rtrim (dprint_msg.forms));
	end;
	else if dprint_msg.forms_name_lth > 0 then
	     call output_position_and_string (TS_FORMS_CONTROL, "Forms control: " || dprint_msg.forms_name);

	call ioa_$rsnnl ("^a queue ^d^12x^a", temp, j, ordata.request_type, ordata.queue, ordata.device_name);
	call output_position_and_string (TS_RQT_QUEUE, rtrim (temp));

	if ordata.no_separator then
	     real_page_count = ordata.page_count * ordata.copies;
	else real_page_count = ordata.page_count;

	if ordata.charge > 0e0 then			/* calculate the page charge */
	     calc_page_charge = real_page_count * ordata.price_per_n_pages / ordata.n_pages_for_price;
	else calc_page_charge = 0e0;
	call ioa_$rsnnl ("^d pages^[ at $^.2f per ^d pages ^52t^10.2f^;^3s^]",
	     line_75_chars, n, real_page_count, (calc_page_charge > 0e0),
	     ordata.price_per_n_pages, ordata.n_pages_for_price, calc_page_charge);
	call output_position_and_string (TS_PAGE_CHARGE, rtrim (line_75_chars));

	if ordata.no_separator then
	     real_line_count = ordata.line_count * ordata.copies;
	else real_line_count = ordata.line_count;

	if ordata.charge > 0e0 then
	     calc_line_charge = real_line_count * ordata.price_per_n_lines / ordata.n_lines_for_price;
	else calc_line_charge = 0e0;
	call ioa_$rsnnl ("^d lines^[ at $^.2f per ^d lines ^52t^10.2f^;^3s^]",
	     line_75_chars, n, real_line_count, (calc_line_charge > 0e0),
	     ordata.price_per_n_lines, ordata.n_lines_for_price, calc_line_charge);
	call output_position_and_string (TS_LINE_CHARGE, rtrim (line_75_chars));

	call ioa_$rsnnl ("Charge to ^32a^52t^10.2f",
	     line_75_chars, n, ordata.requestor, ordata.charge);
	call output_position_and_string (TS_CHARGE_TO, rtrim (line_75_chars));

	if max_rs_number > 0 | ^ordata.no_accounting then do;
	     call ioa_$rsnnl (" Rate structure ^[unknown, ^a used^;^a^].",
		line_75_chars, n, ordata.rs_unavailable, rs_names ((ordata.rs_number)));
	     call output_position_and_string (TS_RATE_STRUCTURE, rtrim (line_75_chars));
	end;

	if ordata.access_class_string ^= "" then do;
	     Absolute_vertical_position.body = templates.position (ACCESS_CLASS).vertical;
	     call output_string (string (Absolute_vertical_position));
	     call output_string (CR);
	     call output_string (string (Begin_auto_center_mode));
	     call output_string (rtrim (ordata.access_class_string));
	     call output_string (string (End_auto_center_mode));

	     Select_font.body = 2;
	     call output_string (string (Select_font));
	     call output_string (Set_default_hmi);
	     Set_vmi.body = byte (7);
	     call output_string (string (Set_vmi));

	     Absolute_vertical_position.body = templates.position (BIG_ACCESS_CLASS).vertical;
	     call output_string (string (Absolute_vertical_position));
	     call bigletter_$five (rtrim (substr (ordata.access_class_string, 1, 13)), output_bigletters);
	end;

	Absolute_vertical_position.body = templates.position (TS_HEAD_DESTINATION).vertical;
	call output_string (string (Absolute_vertical_position));

	if dprint_msg.destination = "" then
	     dest = before (after (ordata.requestor, "."), ".");
	else dest = dprint_msg.destination;

	if dprint_msg.heading = "" then
	     head = before (ordata.requestor, ".");
	else if substr (dprint_msg.heading, 1, 5) = " for " then
	     head = substr (dprint_msg.heading, 6);
	else head = dprint_msg.heading;

	if length (rtrim (head)) + length (rtrim (dest)) + 2 > length (line_75_chars) then do;
	     Select_font.body = 2;
	     call output_string (string (Select_font));
	     call output_string (Set_default_hmi);
	     Set_vmi.body = byte (7);
	     call output_string (string (Set_vmi));

	     line_90_chars = dest;
	     substr (line_90_chars, length (line_90_chars) - length (rtrim (head)) + 1) = rtrim (head);
	     call output_string (CR);
	     call output_string (line_90_chars);
	end;
	else do;
	     Select_font.body = 1;
	     call output_string (string (Select_font));
	     call output_string (Set_default_hmi);
	     Set_vmi.body = byte (9);
	     call output_string (string (Set_vmi));

	     line_75_chars = dest;
	     substr (line_75_chars, length (line_75_chars) - length (rtrim (head)) + 1) = rtrim (head);
	     call output_string (CR);
	     call output_string (line_75_chars);
	end;

	call output_string (CR);
	call output_string (FF);

	return;

     end create_tail_sheet;
%page;
output_bigletters: proc (strp, lth);

/* this is routine bigletter_ calls with the expanded line */

dcl  strp ptr;
dcl  lth fixed bin;
dcl  bcs char (lth) based (strp);
dcl  i fixed bin;
dcl  temp char (204) aligned;

	temp = bcs;				/* copy to a clean string */
	i = length (rtrim (temp));			/* see how long it actually is */

/* we must manually insert CR & NL characters on each line.  Also, we surround
   the bigletter_ string with printer commands to make the asterisks appear in
   shadow mode to make them stand out a little more */

	call output_string (CR);
	call output_string (Begin_shadow_mode);
	call output_string (substr (temp, 1, i));
	call output_string (End_bold_and_shadow_mode);
	call output_string (CR_NL);

	return;

     end output_bigletters;

output_position_and_string: proc (position_index, string_to_output);

dcl  position_index fixed bin;
dcl  string_to_output char (*);

	Absolute_horizontal_position.body = templates.position (position_index).horizontal;
	Absolute_vertical_position.body = templates.position (position_index).vertical;
	call output_string (string (Absolute_horizontal_position));
	call output_string (string (Absolute_vertical_position));

	call output_string (string_to_output);

     end output_position_and_string;


output_string: proc (cs);

/* routine to copy the string it was passed into the current output buffer
   defined by buffer_ptr and buffer_length */

dcl  cs char (*) parameter;
dcl  start_char fixed bin;
dcl  num_chars fixed bin;

	start_char = buffer_length + 1;
	num_chars = length (cs);
	buffer_length = buffer_length + num_chars;

	substr (buffer, start_char, num_chars) = cs;

	return;

     end output_string;
%page;
print_the_banner_page: proc (which_page);

/* output the desired banner page */

dcl  which_page fixed bin;				/* 1 = head sheet
						   2 = tailsheet
                                                               3 = separator */

	if which_page = HEAD | which_page = SEPARATOR then do; /* use head sheet buffer */
	     buffer_ptr = addr (templates.current_head_sheet.strng);
	     buffer_length_ptr = addr (templates.current_head_sheet.lngth);
	end;
	else do;					/* use tail sheet buffer */
	     buffer_ptr = addr (templates.current_tail_sheet.strng);
	     buffer_length_ptr = addr (templates.current_tail_sheet.lngth);
	end;

/* The laser printer's banner pages requires rawo mode and no prt_conv_
   intervention.

   Also, we must reenable print mode if a head sheet, since tail sheet code
   disables it when it's through outputing the tail sheet.  This trick
   prevents any blank pages between the tail sheet of one request and the head
   sheet of the next. */

	if which_page = HEAD | which_page = SEPARATOR then
	     call iox_$modes (iocbp, "print", "", xcode); /* enable printing */
	call iox_$put_chars (iocbp, buffer_ptr, 0, xcode);
	call iox_$modes (iocbp, "rawo", "", xcode);
	call iox_$control (iocbp, "prt_conv_off", null (), xcode);
	call iox_$put_chars (iocbp, buffer_ptr, buffer_length, a_code);
	call iox_$control (iocbp, "prt_conv_on", null (), xcode);
	call iox_$modes (iocbp, "^rawo", "", xcode);
	if which_page = TAIL then do;			/* if tail sheet page */
	     call iox_$modes (iocbp, "^print", "", xcode);/* disenable printing */
	     return;				/* that all for tail sheet */
	end;
	if a_code ^= 0 then
	     return;

/* see if there is an printer notice page, if so print it if we are outputting the head sheet */
	if which_page = SEPARATOR then return;

	call hcs_$initiate_count (sysdir, "printer_notice", "", advert_bc, 0, advert_ptr, xcode);
	if advert_ptr ^= null then
	     if advert_bc > 0 then do;
		call iox_$modes (iocbp, "default", (""), a_code);
		call iox_$put_chars (iocbp, advert_ptr, divide (advert_bc, 9, 21, 0), a_code);
		call hcs_$terminate_noname (advert_ptr, xcode);
	     end;

	a_code = 0;

	return;
     end print_the_banner_page;
%page; %include dprint_msg;
%page; %include output_request_data;
%page; %include prt_ctl;
%page; %include queue_msg_hdr;
%page; %include iodd_hblp_commands;

     end iodd_hblp_banner_pages_;
