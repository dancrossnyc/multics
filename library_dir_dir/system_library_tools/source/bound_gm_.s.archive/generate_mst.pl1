/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1992   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(87-01-19,GDixon), approve(87-04-16,MCR7614),
     audit(87-05-21,Farley), install(87-07-15,MR12.1-1040):
     Add support for storing boot program as first segment of MST image stored
     in a file.
  2) change(87-10-19,Farley), approve(88-02-26,MCR7795),
     audit(88-03-03,Fawcett), install(88-03-15,MR12.2-1035):
     Added default_time_zone statement.
  3) change(87-10-19,Farley), approve(88-02-26,MCR7796),
     audit(88-03-03,Fawcett), install(88-03-15,MR12.2-1035):
     Added default_rpv_data statement.
  4) change(87-11-05,Farley), approve(88-05-13,PBF7795),
     audit(88-05-31,Fawcett), install(88-07-05,MR12.2-1053):
     Corrected default_time_zone code to not require a symbol name
     as part of the statement, as the documentation states.
  5) change(87-11-05,Farley), approve(88-05-13,PBF7796),
     audit(88-05-31,Fawcett), install(88-07-05,MR12.2-1053):
     Corrected default_rpv_data code to not require a symbol name
     as part of the statement, as the documentation states.
  6) change(92-09-21,Schroth), approve(92-10-15,MCR8275),
     audit(92-10-15,WAAnderson), install(92-10-21,MR12.5-1033):
     Corrected uninitialized variable error that was causing tapes to be left
     mounted.  phx21281.
                                                   END HISTORY COMMENTS */


generate_mst: gm: proc;

/* format: off */

/* *	GENERATE_MST
   *
   *	The Multics System Tape generator. This program parses header files and
   *	generates system tapes, performing a lot less error-checking than it should.
   *	Really, this and check_mst ought to be combined, and made reliable, but that
   *	is a project for another day.
   *
   *	Inherited from the dim and distant past; written time and time again by persons
   *	now unknown to us.
   *
   *	Modified 18 February 1981, W. Olin Sibert, to add add_segnames, delete_name,
   *	   and rationalize error message reporting mechanism.
   *	Modified 31 July, 1981, WOS, to add boot_program and data keywords.
   *	Modified: 11 January 1982 by G. Palter to fix add_segnames to not add names
   *	   of components which have no retained entrypoints
          Modified 6/6/82 BIM for boot_program AND first_name.
   *	Modified 8/23/84 JAF to increase name table from 100 to 150 entries
   *	Modified 3/14/85 by Keith Loepere to fix delete_name statement.
   */

/* declarations */

/* argument declarations */

dcl  a_header_path char (argl (1)) unaligned based (argp (1)), /* relative path name of driving header */
     tape_no char (argl (2)) unaligned based (argp (2));	/* numerical designation of output tape */

/* for fetching and aligning arguments */

dcl  argp (10) ptr,					/* array of pointers to unaligned arguments */
     argl (10) fixed bin (17),			/* array of argument lengths */
     code fixed bin (35),				/* error code */
     acount fixed bin (17),				/* ccmmand argument count */
     barg char (argl (i)) unaligned based (argp (i)),

     header_path char (168) aligned,			/* aligned version of argument */

     sysid char (8),				/* system id */
     versid char (8);

dcl  generated_time fixed bin (71);
dcl  generated_time_string char (32);

dcl     i fixed bin (17);				/* do loop index */
dcl  open_message char (100); 			/* message from gm_util1_$open */


/* for attaching */

dcl  path_list_name char (168) aligned,			/* full path name of list of search paths */
     hdrp ptr;					/* pointer to header */

dcl  path_array (10) char (168) aligned;		/* array of path names to be searched */

dcl  sys_desig char (24) aligned var;			/* system designation */
dcl  ion2 char (32) aligned;				/* ioname2 for attaching and detaching tape */

/* for reading */

dcl  numc fixed bin (17),				/* number of characters read */
     ndir fixed bin (17);				/* number of directories to be searched */

dcl  error_label label;				/* for error recovery */

dcl  out_sgna char (32) aligned;

/* for parsing header */

dcl  symp ptr init (null),				/* pointer to current symbol */
     arg char (numc) unaligned based (symp);		/* mask for looking at symbol */

dcl  seg_name char (32)aligned init (""),		/* reference name of segment */
     nnam fixed bin (17);				/* number of names found in header entry */

/* for processing keyword arguments */


/* for creating segment blocks */

dcl  in_p ptr,					/* pointer to segment in searched directory */
     segp ptr,					/* pointer to segment to be written on tape */

     bitcnt fixed bin (24),				/* bit count of segment as found */
     sg_b fixed bin (24),				/* bit count of block to be written */

     tx_l fixed bin (17),				/* length of text section */
     sg_l fixed bin (17);				/* length of block to be written */

dcl  cur_len_for_bitcnt fixed bin (18);			/* current length in words */


dcl  path_ptr ptr,

     1 path aligned based (path_ptr),			/* path name structure */
     2 size fixed bin (17),
     2 name char (168);

dcl  names_ptr ptr,

     1 seg_name_array aligned based (names_ptr),		/* name structure */
     2 count fixed bin (17),
     2 names (max_count),
     3 size fixed bin (17),
     3 name char (32);

dcl  acl_count_ptr ptr,
     acl_block_ptr ptr,
     acl_count fixed bin (17) based (acl_count_ptr);


dcl 1 acla based (acl_block_ptr) aligned,
    2 userid char (32),
    2 mode bit (36),
    2 pad bit (36),
    2 code fixed bin;


dcl  max_count fixed bin (17) static init (150),
     seg_name_l fixed bin (17);			/* to remember length of seg name */


dcl  seg_header_length fixed bin,			/* length of header data in words */
     header_words fixed bin (35),			/* number of words to be written in header write */
     wr_w fixed bin (17),				/* number of wds written in seg write */
     seg_hdrp ptr;					/* pointer to header info */

dcl 1 control_word based aligned,
    2 ident fixed bin (17) unal,			/* identifier portion of control word */
    2 length fixed bin (17) unal,			/* 2 length portion */
    2 col_no fixed bin (17) unal,			/* for 2 collection mark unal,number */
    2 col_sub_no fixed bin (17) unal;			/* for collection mark; */

dcl  cw_ptr ptr,					/* pointer to segment control word */

     header_max_size fixed bin static init (1500),	/* size of header data array */
     header_data (1500) fixed bin (35);			/* actual header data */

dcl (addr, addrel, after, before, bin, bit, clock, divide, fixed, index, length,
     maxlength, null, reverse, rtrim, substr, translate, unspec) builtin;

dcl  o_ln char (132) aligned;

dcl  last_path char (32) aligned;			/* for setting path_found */

dcl  oa_ptr ptr;					/* dcls for setting access in output line */

dcl  error_in_object_segment bit (1) aligned;

dcl  mst_tape_iocbp ptr init (null);
dcl  gm_output_iocbp ptr init (null);

dcl 1 output_access unaligned based (oa_ptr),
    2 (read, execute, write, privileged) bit (1);

dcl  output_access_word char (8) aligned;

dcl  tape_er_count fixed bin (17);			/* for keeping track of tape errors */

/* for system_id feature */

dcl  movewds bit (bitcnt) aligned based,		/* array to move seg into temp */
     real_in_p ptr,					/* save for original seg ptr */
     symbol_name char (32),				/* name of symbol to be overlaid with sysid */
     based_char_32 char (32) based,			/* for moving name  */
     based_bit_72 bit (72) based,
     time_as_bit bit (72),
     id_ptr pointer,
     default_rpv_data char (24) var,
     default_time_zone char (4),
    (lang_index, zone_index) fixed bin,
     unique_name char (15);				/* name of copied segment */

dcl 1 oi aligned like object_info;

dcl  object_segment bit (1) aligned;			/* flag to indicate whether oi is valid for current segment */


/* flag declarations */

dcl (sysid_hit,
     versid_hit,
     db_hit,
     hd_hit,
     do_hit,
     dr_hit,
     path_name_found,
     no_error_was_found,
     cur_length_found,
     bit_count_found,
     cache_found,
     acl_found,
     linkage_found,
     end_found,
     boot_program_has_been_processed,
     segments_have_been_processed
     ) bit (1) aligned;

dcl  sym_is_a_break fixed bin (1),
     eof_was_found fixed bin (1);

/* external declarations */

dcl  cu_$arg_count entry (fixed bin);
dcl  cu_$arg_ptr entry (fixed bin, pointer, fixed bin, fixed bin (35));
dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin);
dcl  date_time_$format entry (char (*), fixed bin (71), char (*), char (*)) returns (char (250) var);
dcl  decode_definition_$full entry (pointer, pointer, pointer) returns (bit (1) aligned);
dcl  delete_$ptr entry (pointer, bit (6), char (*), fixed bin (35));
dcl  gm_error_ entry (fixed bin (35), char (32) aligned, pointer, pointer, char (*),
     pointer, bit (1) aligned, bit (1) aligned, bit (1) aligned, pointer, pointer);
dcl  gm_util_ entry (char (32) aligned, fixed bin (17), pointer, pointer, bit (1) aligned, bit (1) aligned);
dcl  gm_util1_$close entry (pointer, pointer, bit (1) aligned);
dcl  gm_util1_$open entry (pointer, char (168) aligned, fixed bin, char (168) aligned, pointer, char (32) aligned,
     pointer, pointer, char (32) aligned, fixed bin (35), char (*), bit (1) aligned, bit (1) aligned, char (8));
dcl  gm_write_first_seg_ entry (pointer, fixed bin (24), pointer, pointer, bit (1) aligned, fixed bin (35));
dcl  gm_write_boot_program_ entry (ptr, fixed bin(24), char(*), ptr, bit(1) aligned,
				     bit(1) aligned, fixed bin(35));
dcl  hcs_$initiate_count entry (char (*) aligned, char (*) aligned, char (*),
     fixed bin (24), fixed bin, pointer, fixed bin (35));
dcl  hcs_$make_ptr entry (pointer, char (*), char (*), pointer, fixed bin (35));
dcl  hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), pointer, fixed bin (35));
dcl  hcs_$set_bc_seg entry (pointer, fixed bin (24), fixed bin (35));
dcl  hcs_$terminate_noname entry (pointer, fixed bin (35));
dcl  ioa_ entry options (variable);
dcl  iox_$control entry (pointer, char (*), pointer, fixed bin (35));
dcl  iox_$put_chars entry (pointer, pointer, fixed bin (21), fixed bin (35));
dcl  object_info_$brief entry (pointer, fixed bin (24), pointer, fixed bin (35));
dcl  parse_file_$parse_file_ptr entry (pointer, fixed bin (17), fixed bin (1), fixed bin (1));
dcl  parse_file_$parse_file_unset_break entry (char (*));
dcl  print_gen_info_ entry (pointer, fixed bin (24), char (*), fixed bin (35));
dcl  unique_chars_ entry (bit (*) aligned) returns (char (15));

dcl  gm_data_$default_path_list_name char (168) varying external static;

dcl  date_time_ entry (fixed bin(71), char(*));


dcl (error_table_$noarg,
     error_table_$noentry,
     error_table_$badopt) fixed bin (35) external static;

dcl  cleanup condition;

/*  */

/* initializations */

          generated_time = clock ();
	segments_have_been_processed = "0"b;
	boot_program_has_been_processed = "0"b;

	ndir,
	code = 0;

	real_in_p,
	in_p = null;

	seg_hdrp = addr (header_data);

	sltep = addrel (seg_hdrp, 1);

	names_ptr = addrel (seg_hdrp, 5);

	seg_hdrp -> control_word.ident = 0;

	oa_ptr = addr (sltep -> slte.access);

	last_path = " ";

	oi.version_number = object_info_version_2;

	on cleanup call CLEANUP_CONDITION_HANDLER;

/*  */

/* preliminary work */

	sysid_hit, versid_hit, db_hit, dr_hit, do_hit, hd_hit = "0"b;
	call cu_$arg_count (acount);
	do i = 1 to acount;				/* fetch arguments */
	     call cu_$arg_ptr (i, argp (i), argl (i), code);
	end;

	if acount < 2 then do;
noarg:	     code = error_table_$noarg;
	     call ERROR ("Argument missing.", "1"b);
	end;

	do i = 3 to acount while (i <= acount);		/* process optional args */
	     if barg = "-dr" | barg = "-directory" then dr_hit = "1"b;
	     else if barg = "-file" | barg = "-f" then db_hit = "1"b;
	     else if barg = "-notape" | barg = "notape" then do_hit = "1"b;
	     else if barg = "-hold" | barg = "-hd" then hd_hit = "1"b;
	     else if barg = "-sysid" | barg = "-sys_id" then do;
		if i = acount then go to noarg;
		i = i + 1;
		sysid_hit = "1"b;
		sysid = barg;
	     end;
	     else if barg = "-versid" | barg = "-vers_id" then do;
		if i = acount then go to noarg;
		i = i + 1;
		versid_hit = "1"b;
		versid = barg;
	     end;
	     else do;
		code = error_table_$badopt;
		call ERROR ("Invalid option specified.", "1"b);
	     end;
	end;

	header_path = a_header_path || ".header";	/* make the header name */
	i = index (reverse (a_header_path), ">") - 1;	/* locate last ">" */
	if i = -1 then sys_desig = a_header_path;
	else sys_desig = substr (a_header_path, argl (1) - i + 1, i); /* use it as the system designation */
	if ^sysid_hit then sysid = sys_desig;
	if ^versid_hit then versid = sysid;
	ion2 = tape_no;				/* create ioname 2 */
	out_sgna = sys_desig || ".list";		/* create the output listing file name */

	if dr_hit then path_list_name = sys_desig || ".search"; /* create special path list name if used */
	else path_list_name = gm_data_$default_path_list_name;

	call gm_util1_$open (addr (path_array), path_list_name, ndir, header_path, hdrp, ion2,
	     mst_tape_iocbp, gm_output_iocbp, out_sgna, code, open_message, db_hit, do_hit, sysid);
	if open_message ^= "" then
	     call ERROR (open_message, "1"b);

	call parse_file_$parse_file_unset_break (">_!*""."); /* ">","_","!","*",""","." should not be breaks */

/*  */

next_segment:
	path_name_found,
	acl_found,
	cur_length_found,
	bit_count_found,
	cache_found,
	linkage_found,
	end_found = "0"b;
	no_error_was_found = "1"b;

	error_label = skip_to_next_seg;

	call GET_NEXT_ARG;				/* Look at next keyword. */

	if arg = "fini" then do;			/* If end of tape ... */
close_out:     call gm_util1_$close (gm_output_iocbp, mst_tape_iocbp, hd_hit);
	     return;				/* This is the end. */
	end;

	else if arg = "collection" then do;		/* If end of collection ... */
	     call TEST_BREAK (":");

	     sltep -> control_word.length = 1;		/* set length */
	     sltep -> control_word.ident = 2;		/* set identifying portion */
	     call GET_NEXT_ARG;

	     if index (arg, ".") = 0
	     then do;
		sltep -> control_word.col_no = cv_dec_check_ (arg, code);
		if code ^= 0 then 
C_ERROR:		do;
		     call ERROR ("Malformed collection number " || arg, "1"b);
		end;
		sltep -> control_word.col_sub_no = 0;
	     end;
	     else do;
		sltep -> control_word.col_no = cv_dec_check_ (before (arg, "."), code);
		if code ^= 0 then go to C_ERROR;
		sltep -> control_word.col_sub_no = cv_dec_check_ (after (arg, "."), code);
		if code ^= 0 then go to C_ERROR;
	     end;

	     call TEST_BREAK (";");
	     call ioa_ ("Writing collection ^d.^d mark.", sltep -> control_word.col_no, sltep -> control_word.col_sub_no);
	     call WRITE_COLLECTION;
	end;

	else if arg = "name" then			/* If beginning of segment. */
	     call PROCESS_SEGMENT (NORMAL_SEG);

	else if arg = "object" then
	     call PROCESS_SEGMENT (WHOLE_OBJECT_SEG);

	else if arg = "text" then
	     call PROCESS_SEGMENT (TEXT_ONLY_SEG);

	else if arg = "data" then
	     call PROCESS_SEGMENT (DATA_SEG);

	else if arg = "first_name" then do;
	     if segments_have_been_processed then	/* Should be first thing in header. */
		call ERROR ("first_name statement encountered after other segment definitions.", "0"b);
	     call PROCESS_SEGMENT (FIRST_SEG);
	end;

	else if (arg = "boot_program") then do; 	/* Must come first */
	     if segments_have_been_processed | boot_program_has_been_processed then
		call ERROR ("boot_program statement encountered after other segment definitions.", "0"b);
	     call PROCESS_SEGMENT (BOOT_PROGRAM_SEG);
	end;

	else if arg = "fabricate" then
	     call PROCESS_SEGMENT (FABRICATED_SEG);

	else					/* Error. */
	     call ERROR ("Unrecognized primary keyword.", "0"b);


	go to next_segment;

/*  */

PROCESS_SEGMENT: proc (seg_type);

dcl  seg_type fixed bin;				/* segment type */


/* This next allows first_name to follow boot_program */

          if seg_type = BOOT_PROGRAM_SEG
	then boot_program_has_been_processed = "1"b;
	else segments_have_been_processed = "1"b;

	call TEST_BREAK (":");

	call GATHER_NAMES;				/* Gather up the names. */

	call INIT_SEGMENT;				/* Initiate segment and get lengths. */

	error_label = skip_to_next_statement;

seg_loop:
	call GET_NEXT_ARG;				/* Get next keyword. */

/* add_segnames statement */

	if (arg = "add_segnames") | (arg = "include_segnames") then /* Add all segnames to the list of names */
	     call GATHER_SEGNAMES ();

/* delete_name statement */

	else if (arg = "delete_name") | (arg = "delete_names") then
	     call DELETE_NAMES ();

/* pathname statement */

	else if (arg = "path_name") | (arg = "pathname") then do;
	     if acl_found then
		call ERROR ("""path_name"" keyword found after ""acl"" keyword.", "0"b);
	     path_name_found = "1"b;
	     call TEST_BREAK (":");

	     call GET_NEXT_ARG;
	     path.size = numc;
	     path.name = arg;			/* take path name from arg because it may be > 32 chars */
	     slte.branch_required = "1"b;

	     seg_header_length = seg_header_length + 1 + divide (numc + 3, 4, 17, 0); /* add it to header length */
	     if seg_header_length > header_max_size then
		call ERROR ("Header buffer area overflow.", "0"b);
	     cw_ptr = addrel (sltep, seg_header_length); /* set control word mask */
	     call TEST_BREAK (";");
	end;

/* access statement */

	else if arg = "access" then do;
	     call TEST_BREAK (":");
	     slte.access = "0000"b;
	     do while (arg ^= ";");
		call GET_NEXT_ARG;
		if arg = "read" then substr (slte.access, 1, 1) = "1"b;
		else if arg = "write" then substr (slte.access, 3, 1) = "1"b;
		else if arg = "execute" then substr (slte.access, 2, 1) = "1"b;
		else if arg = "privileged" then substr (slte.access, 4, 1) = "1"b;
		else call ERROR ("Invalid argument.", "0"b);

		call GET_NEXT_BREAK;
		if (arg ^= ",") & (arg ^= ";") then
		     call ERROR ("Invalid break.", "0"b);
	     end;
	end;

/* per_process statement */

	else if arg = "per_process" then
	     slte.per_process = YES_NO ();

/* wired statement */

	else if arg = "wired" then do;
	     slte.wired = YES_NO ();
	     if slte.wired then slte.link_sect_wired = "1"b;
	     if ^path_name_found then slte.paged = ^slte.wired;
	end;

/* init_seg statement */

	else if arg = "init_seg" then do;
	     slte.init_seg = YES_NO ();
	     if slte.init_seg then slte.paged = "1"b;
	end;

/* temp_seg statement */

	else if arg = "temp_seg" then do;
	     slte.temp_seg = YES_NO ();
	     if slte.temp_seg then slte.paged = "1"b;
	     slte.init_seg = slte.temp_seg;
	end;

/* firmware */

	else if arg = "firmware" then do;
	     slte.firmware_seg = YES_NO ();
	     if slte.firmware_seg
	     then slte.wired = "1"b;
	end;

/* paged statement */

	else if arg = "paged" then
	     slte.paged = YES_NO ();

/* cur_length statement */

	else if arg = "cur_length" then do;
	     call TEST_BREAK (":");
	     cur_len_for_bitcnt = GET_NUM ();
	     call TEST_BREAK (";");
	     slte.cur_length = bit (divide (cur_len_for_bitcnt + 1023, 1024, 9, 0), 9);
	     if ^bit_count_found then
		slte.bit_count = bit (bin (cur_len_for_bitcnt * 36, 24));
	     cur_length_found = "1"b;
	end;

/* ringbrack statement */

	else if arg = "ringbrack" then do;
	     call TEST_BREAK (":");
	     slte.ringbrack (1) = bit (bin (GET_NUM (), 3));
	     call GET_NEXT_BREAK;
	     if arg = "," then do;
		slte.ringbrack (2) = bit (bin (GET_NUM (), 3));
		call GET_NEXT_BREAK;
		if arg = "," then do;
		     slte.ringbrack (3) = bit (bin (GET_NUM (), 3));
		     call TEST_BREAK (";");
		end;
		else if arg = ";" then
		     slte.ringbrack (3) = slte.ringbrack (2);
		else
		     call ERROR ("Invalid break.", "0"b);
	     end;
	     else if arg = ";" then
		slte.ringbrack (3), slte.ringbrack (2) = slte.ringbrack (1);
	     else
		call ERROR ("Invalid break.", "0"b);
	end;

/* wired_link statement */

	else if arg = "wired_link" then
	     slte.link_sect_wired = YES_NO ();

/* combine_link statement */

	else if arg = "combine_link" then
	     slte.combine_link = YES_NO ();

/* acl statement */

	else if arg = "acl" then do;
	     call TEST_BREAK (":");

	     if ^acl_found then do;
		acl_count_ptr = cw_ptr;		/* set pointer to ACL entry count */
		acl_count = 0;
		cw_ptr = addrel (cw_ptr, 1);		/* set pointer to scw */
		seg_header_length = seg_header_length + 1;
		if seg_header_length > header_max_size then
		     call ERROR ("Header buffer area overflow.", "0"b);
		acl_found = "1"b;
		slte.acl_provided = "1"b;
	     end;

	     acl_count = acl_count + 1;
	     acl_block_ptr = cw_ptr;			/* set pointer for ACL fill-in */
	     seg_header_length = seg_header_length + 11;
	     if seg_header_length > header_max_size then
		call ERROR ("Header buffer area overflow.", "0"b);
	     cw_ptr = addrel (cw_ptr, 11);

	     call GET_NEXT_ARG;
	     acl_block_ptr -> acla.mode = "0"b;
	     if arg ^= "null" then do i = 1 to numc;
		if substr (arg, i, 1) = "r" then
		     substr (acl_block_ptr -> acla.mode, 1, 1) = "1"b;
		else if substr (arg, i, 1) = "e" then
		     substr (acl_block_ptr -> acla.mode, 2, 1) = "1"b;
		else if substr (arg, i, 1) = "w" then
		     substr (acl_block_ptr -> acla.mode, 3, 1) = "1"b;
		else
		     call ERROR ("Invalid argument.", "0"b);
	     end;

	     acl_block_ptr -> acla.pad = "0"b;
	     acl_block_ptr -> acla.code = 0;

	     call TEST_BREAK (",");

	     call GET_NEXT_ARG;
	     acl_block_ptr -> acla.userid = arg;

	     call TEST_BREAK (";");
	end;

/* bit_count statement */

	else if arg = "bit_count" then do;
	     call TEST_BREAK (":");
	     slte.bit_count = bit (bin (GET_NUM (), 24));
	     call TEST_BREAK (";");
	     if ^cur_length_found then
		slte.cur_length = bit (divide (divide (bin (slte.bit_count, 24) + 35, 36, 18, 0) + 1023, 1024, 9, 0));
	     bit_count_found = "1"b;
	end;

/* max_length statement */

	else if arg = "max_length" then do;
	     call TEST_BREAK (":");
	     slte.max_length = bit (bin (GET_NUM (), 9));
	     call TEST_BREAK (";");
	end;

/* cache statement */

	else if arg = "cache" then do;
	     slte.cache = YES_NO ();
	     cache_found = "1"b;
	end;

/* sys_id statement */

	else if (arg = "sys_id") | (arg = "sysid") then do;
	     call TEST_BREAK (":");
	     call GET_NEXT_ARG;
	     symbol_name = arg;
	     if real_in_p = null then
		call COPY_SEGMENT;
	     call hcs_$make_ptr (in_p, unique_name, symbol_name, id_ptr, code);
	     if code ^= 0 then
		call ERROR ("Unable to find sysid symbol.", "1"b);
	     id_ptr -> based_char_32 = sysid;
	     call TEST_BREAK (";");
	end;

/* vers_id statement */

	else if (arg = "vers_id") | (arg = "versid") then do;
	     call TEST_BREAK (":");
	     call GET_NEXT_ARG;
	     symbol_name = arg;
	     if real_in_p = null then
		call COPY_SEGMENT;
	     call hcs_$make_ptr (in_p, unique_name, symbol_name, id_ptr, code);
	     if code ^= 0 then
		call ERROR ("Unable to find versid symbol.", "1"b);
	     id_ptr -> based_char_32 = versid;
	     call TEST_BREAK (";");
	end;

/* generation_time statement */

	else if (arg = "generation_time") then do;
	     call TEST_BREAK (":");
	     call GET_NEXT_ARG;
	     symbol_name = arg;
	     if real_in_p = null then
		call COPY_SEGMENT;
	     call hcs_$make_ptr (in_p, unique_name, symbol_name, id_ptr, code);
	     if code ^= 0 then
		call ERROR ("Unable to find generation_time symbol.", "1"b);
	     time_as_bit = unspec (generated_time);
	     id_ptr -> based_bit_72 = time_as_bit;
	     call TEST_BREAK (";");
	end;

/* generation_time_string statement */

	else if (arg = "generation_time_string") then do;
	     call TEST_BREAK (":");
	     call GET_NEXT_ARG;
	     symbol_name = arg;
	     if real_in_p = null then
		call COPY_SEGMENT;
	     call hcs_$make_ptr (in_p, unique_name, symbol_name, id_ptr, code);
	     if code ^= 0 then
		call ERROR ("Unable to find generation_time_string symbol.", "1"b);
	     call date_time_ (generated_time, generated_time_string);
	     generated_time_string = translate (generated_time_string,
		" ", /* SPACE */
		"	"/* TAB */);
	     id_ptr -> based_char_32 = generated_time_string;
	     call TEST_BREAK (";");
	end;

/* default_time_zone statement */

	else if (arg = "default_time_zone") then do;
	     symbol_name = "default_time_zone";
	     if real_in_p = null then
		call COPY_SEGMENT;
	     call hcs_$make_ptr (in_p, unique_name, symbol_name, id_ptr, code);
	     if code ^= 0 then
		call ERROR ("Unable to find default_time_zone symbol.", "1"b);
	     call GET_NEXT_BREAK;
	     if (arg ^= ":") & (arg ^= ";") then
		call ERROR ("Invalid break.", "0"b);
	     if arg = ":" then do;			/* value defined */
		call GET_NEXT_ARG;
		default_time_zone = arg;
		call TEST_BREAK (";");
	     end;
	     else default_time_zone = date_time_$format ("^za", generated_time, "", "");
						/* use current perprocess time zone */
	     substr (id_ptr -> based_char_32, 1, 4) = default_time_zone;
	     symbol_name = rtrim (symbol_name) || "_delta";
	     call hcs_$make_ptr (in_p, unique_name, symbol_name, id_ptr, code);
	     if code ^= 0 then
		call ERROR ("Unable to find default_time_zone delta symbol.", "1"b);
	     do lang_index = 1 to ti_zone.number_lang;
		do zone_index = 1 to ti_zone.number_zone;
		     if ti_zone.short (lang_index, zone_index) = default_time_zone then goto found_time_zone;
		end;
	     end;
	     call ERROR ("Unable to find default_time_zone in time_info_.", "1"b);
found_time_zone:
	     time_as_bit = unspec (ti_zone.delta (lang_index, zone_index));
	     id_ptr -> based_bit_72 = time_as_bit;
	end;

/* default_rpv_data statement */

	else if (arg = "default_rpv_data") then do;
	     call TEST_BREAK (":");
	     symbol_name = "default_rpv_data";
	     if real_in_p = null then
		call COPY_SEGMENT;
	     call hcs_$make_ptr (in_p, unique_name, symbol_name, id_ptr, code);
	     if code ^= 0 then
		call ERROR ("Unable to find default_rpv_data symbol.", "1"b);
	     default_rpv_data = "";
	     call GET_NEXT_SYM;
	     do while (arg ^= ";");
		if length (default_rpv_data) + length (arg) + 1 > maxlength (default_rpv_data) then
		     call ERROR ("Maximum length of default_rpv_data has been exceeded.", "1"b);
		default_rpv_data = default_rpv_data || arg || " ";
		call GET_NEXT_SYM;
	     end;
	     substr (id_ptr -> based_char_32, 1, 24) = default_rpv_data;
	end;

/* abs_seg statement */

	else if arg = "abs_seg" then
	     slte.abs_seg = YES_NO ();

/* linkage statement */

	else if arg = "linkage" then do;
	     call TEST_BREAK (";");
	     if (seg_type ^= NORMAL_SEG) & (seg_type ^= WHOLE_OBJECT_SEG) then   /* "linkage" illegal others */
		call ERROR ("Linkage keyword with no segment block.", "0"b);
	     slte.link_provided = "1"b;

	     if seg_type = NORMAL_SEG then do;		/* name followed by linkage,want text only */
		sg_l, wr_w = oi.tlng;
		sg_b = sg_l * 36;
	     end;

	     if no_error_was_found then
		call WRITE_SEGMENT (seg_type);

	     sg_l, wr_w = oi.llng;			/* set link block length, words to be written */
	     sg_b = oi.llng * 36;			/* set linkage block bit count */

	     segp = oi.linkp;
	     seg_name = substr (seg_name, 1, seg_name_l) || ".link";
	     seg_name_array.count, nnam = 1;
	     seg_name_array.names (1).name = seg_name;
	     seg_name_array.names (1).size = seg_name_array.names (1).size + 5;
	     cw_ptr, path_ptr = addrel (names_ptr, 10);
	     seg_header_length = 14;

	     call gm_util_ (seg_name, seg_type, sltep, segp, "1"b, "0"b); /* initiate linkage slte */

	     acl_found,
	     cur_length_found,
	     bit_count_found,
	     cache_found = "0"b;
	     linkage_found = "1"b;
	end;

/* end statement */

	else if arg = "end" then do;
	     end_found = "1"b;
	     call TEST_BREAK (";");

	     if no_error_was_found then
		call WRITE_SEGMENT (seg_type);

	     if linkage_found then do;		/* Now do defs. */
		sg_l, wr_w = oi.dlng;
		sg_b = oi.dlng * 36;

		segp = oi.defp;
		seg_name = substr (seg_name, 1, seg_name_l) || ".defs";
		seg_name_array.names (1).name = seg_name;
		cw_ptr = addrel (names_ptr, 10);
		seg_header_length = 14;

		call gm_util_ (seg_name, seg_type, sltep, segp, "0"b, "1"b);

		acl_found,
		cur_length_found,
		bit_count_found,
		cache_found = "0"b;

		if no_error_was_found then
		     call WRITE_SEGMENT (seg_type);
	     end;

	     call TERM_SEGMENT;
	     return;				/* Back to caller. */
	end;

	else
	     call ERROR ("Illegal keyword.", "0"b);

	go to seg_loop;



skip_to_next_statement:
	do while (arg ^= ";");
	     call GET_NEXT_SYM;
	end;

	go to seg_loop;


/*  */

GATHER_NAMES: proc;

	do nnam = 1 by 1 while (nnam <= max_count);	/* Pick up names one by one. */
	     call GET_NEXT_ARG;
	     seg_name_array.names (nnam).size = numc;
	     seg_name_array.names (nnam).name = arg;
	     seg_name_array.count = nnam;

	     call GET_NEXT_BREAK;
	     if arg = ";" then do;			/* Return when names are finished. */
		seg_header_length = 5 + nnam * 9;
		path_ptr, cw_ptr = addrel (names_ptr, nnam * 9 + 1);
		return;
	     end;
	     else if arg ^= "," then
		call ERROR ("Invalid break.", "0"b);
	end;

	call ERROR ("Too many names.", "0"b);


     end GATHER_NAMES;

/*  */

GATHER_SEGNAMES: proc ();

/* This procedure adds all the segmames in a bound object segment to the list of names
   in the SLTE, thus avoiding the necessity of updating the header every time a component
   is added to a bound segment, and making the header considerably smaller as well.
   */

dcl  idx fixed bin;
dcl  current_name_count fixed bin;
dcl 1 def aligned like decode_definition_full;
dcl  defp pointer;
dcl  segname char (32);


	call TEST_BREAK (";");			/* No arguments may follow */

	defp = oi.defp;
	if (defp = null ()) | (^oi.bound) | (^object_segment) then	/* Must be both valid obj seg & bound. */
	     call ERROR ("The add_segnames statement may only be used with bound object segments.", "0"b);

	if (acl_found | path_name_found) then		/* Since names array is built before ACL or pathname */
	     call ERROR ("The add_segnames statement must come before either of ""acl"" or ""path_name"".", "0"b);

	current_name_count = seg_name_array.count;	/* So we can check that we aren't duplicating names */
	nnam = seg_name_array.count;			/* Remember it here, in case we don't find anything */

	do while (^decode_definition_$full (defp, addr (def), addr (oi))); /* loop through all definitions in the seg */
	     defp = def.next_def;			/* continue to next one, next time */
	     if ^def.ignore & (def.section = "segn")
	     then do;				/* It's a segname definition, so process it */
		segname = substr (def.symbol, 1, def.symbol_lng);
		do idx = 1 to current_name_count;	/* Is it already in the name array? */
		     if seg_name_array.names (idx).name = segname then
			goto TRY_NEXT_DEFINITION;	/* Yes. Ignore it. */
		     end;

		nnam = seg_name_array.count + 1;	/* Otherwise, add it to the array */
		if nnam > max_count then
		     call ERROR ("Too many names.", "0"b);

		seg_name_array.names (nnam).size = length (rtrim (segname));
		seg_name_array.names (nnam).name = segname;
		seg_name_array.count = nnam;
		end;
TRY_NEXT_DEFINITION:				/* skip to next one */
	     end;

	seg_header_length = 5 + nnam * 9;		/* update the size */
	path_ptr, cw_ptr = addrel (names_ptr, nnam * 9 + 1);

	return;
	end GATHER_SEGNAMES;

/*  */

DELETE_NAMES: proc;

/* This procedure is used to remove names from the name array if they are not to be
   included; it is used to eliminate extraneous segnames which were included by a
   previous add_segnames statement.
   */

dcl (idx, jdx) fixed bin;
dcl  segname char (32);


	call TEST_BREAK (":");

	if (acl_found | path_name_found) then		/* Since names array is built before ACL or pathname */
	     call ERROR ("The delete_name statement must come before either of ""acl"" or ""path_name"".", "0"b);

	nnam = seg_name_array.count;

	do while (arg ^= ";");			/* Find all the names to delete */
	     call GET_NEXT_ARG ();

	     segname = arg;
	     do idx = 1 to seg_name_array.count;	/* See if we can find the specified name */
		if seg_name_array.names (idx).name = segname then do; /* Found it */
		     if nnam = 1 then		/* You'd make it invisible, would you.... */
			call ERROR ("The delete_name statement would leave no names on the segment.", "0"b);

		     do jdx = idx to nnam - 1;	/* percolate all the other names down */
			seg_name_array.names (jdx) = seg_name_array.names (jdx + 1);
			end;

		     nnam = nnam - 1;		/* record the change in number of names */
		     seg_name_array.count = nnam;
		     goto GET_NEXT_NAME_TO_DELETE;	/* All done with this one */
		     end;
		end;

	     call ERROR ("Name to be deleted is not in name array for segment.", "0"b); /* Sorry */

GET_NEXT_NAME_TO_DELETE:
	     call GET_NEXT_BREAK ();

	     if (arg ^= ",") & (arg ^= ";") then
		call ERROR ("Invalid break.", "0"b);
	     end;

	seg_header_length = 5 + nnam * 9;
	path_ptr, cw_ptr = addrel (names_ptr, nnam * 9 + 1);

	return;					/* All done deleting names */
	end DELETE_NAMES;

/*  */

INIT_SEGMENT: proc;


	seg_name = seg_name_array.names (1).name;
	seg_name_l = seg_name_array.names (1).size;

	object_segment = "0"b;			/* until shown otherwise, assume it's not */

	if seg_type ^= FABRICATED_SEG then do;
	     do i = 1 to ndir while (in_p = null ());
		call hcs_$initiate_count (path_array (i), seg_name, "", bitcnt, 0, in_p, code);
		if (in_p = null ()) & (code ^= error_table_$noentry) then
		     call ERROR ("Invalid pathname in path list.", "1"b);
	     end;
	     if in_p = null () then
		call ERROR ("Missing segment.", "0"b);

	     call print_gen_info_ (in_p, bitcnt, "gm_output", code);
	end;

	else do;					/* no seg block,prepare to write out 0 length scw */
	     sg_l = 0;
	     slte.bit_count = "0"b;
	     slte.cur_length = "0"b;
	end;

	call gm_util_ (seg_name, seg_type, sltep, segp, "0"b, "0"b); /* initiate segment block slte */

	if seg_type ^= FABRICATED_SEG then do;
	     if seg_type ^= DATA_SEG then do;		/* Get object info for anything but pure data */
		call object_info_$brief (in_p, bitcnt, addr (oi), code);
		if (oi.linkp = null) | (code ^= 0) then do;
		     call ERROR ("Bad object segment.", "0"b);
		     slte.combine_link = "0"b;
		end;
		else object_segment = "1"b;		/* segment is a legitimate object segment, so oi is valid. */
	     end;
	     else slte.combine_link = "0"b;		/* Certainly don't combine for non-object */

	     if seg_type = TEXT_ONLY_SEG then do;	/* text keyword, set up text segment */
		tx_l = oi.tlng;			/* set block length from linkage pointer offset */
		wr_w, sg_l = tx_l;			/* set up text segment */
		sg_b = sg_l * 36;			/* set bit count of "t" or "tl" seg block */
	     end;
	     else do;				/* not object,take whole segment for now */
		sg_b = bitcnt;
		sg_l, wr_w = divide (bitcnt+35, 36, 17, 0);
	     end;

	     segp = in_p;
	end;


     end INIT_SEGMENT;


/*  */

COPY_SEGMENT: proc;


	real_in_p = in_p;
	unique_name = unique_chars_ ("0"b);
	call hcs_$make_seg ("", unique_name, unique_name, 1010b, in_p, code);
	if in_p = null () then
	     call ERROR ("Unable to create segment in process directory.", "1"b);
	in_p -> movewds = real_in_p -> movewds;		/* make new segment */
	call hcs_$set_bc_seg (in_p, bitcnt, code);
	segp = in_p;


     end COPY_SEGMENT;



TERM_SEGMENT: proc;


	if in_p ^= null then do;
	     if real_in_p ^= null then do;		/* sysid seg, must delete */
		call delete_$ptr (in_p, "100100"b, "generate_mst", code);
		if code ^= 0 then
		     call ERROR ("Unable to terminate segment in process directory.", "1"b);
		in_p = real_in_p;			/*  reset to original ptr */
		real_in_p = null;
	     end;
	     call hcs_$terminate_noname (in_p, code);	/* terminate the found segment */
	     if code ^= 0 then
		call ERROR ("Unable to terminate found segment.", "1"b);
	     else in_p = null;
	end;


     end TERM_SEGMENT;

     end PROCESS_SEGMENT;


/*  */

WRITE_SEGMENT: proc (seg_type);

dcl  seg_type fixed bin;


/* insert access in output line */

	output_access_word = "";			/* initialize all access fields to blank */
	if output_access.read then substr (output_access_word, 1, 1) = "R";
	if output_access.execute then substr (output_access_word, 2, 1) = "E";
	if output_access.write then substr (output_access_word, 3, 1) = "W";
	if output_access.privileged then substr (output_access_word, 4, 1) = "P";
	if output_access_word = "" then
	     call ERROR ("Invalid argument.", "0"b);

/* set bit count, cur_length if necessary */

	if ^(cur_length_found | bit_count_found) then
	if seg_type ^= FABRICATED_SEG then do;
		slte.bit_count = bit (sg_b, 24);
		slte.cur_length = bit (divide (divide (sg_b + 35, 36, 18, 0) + 1023, 1024, 9, 0), 9);
	     end;


/* Compute cache access */

	if ^cache_found				/* believe given spec */
	then if slte.per_process then slte.cache = "1"b;
	     else if output_access.write
	     | slte.init_seg
	     | slte.temp_seg then slte.cache = "0"b;
	     else slte.cache = "1"b;

	cw_ptr -> control_word.ident = 1;		/* set identity of segment control word */
	cw_ptr -> control_word.length = sg_l;
	header_words = seg_header_length+2;		/* add hcw,scw length */
	seg_hdrp -> control_word.length = seg_header_length;

/* write first segment */

	if (seg_type = FIRST_SEG) | (seg_type = BOOT_PROGRAM_SEG) then do;
	     if seg_type = FIRST_SEG then
		call gm_write_first_seg_ (sltep, sg_b, in_p, mst_tape_iocbp, error_in_object_segment, code);
	     else if do_hit then;			/* Do nothing if -notape specified */
	     else call gm_write_boot_program_ (in_p, sg_b, (seg_name), mst_tape_iocbp, db_hit, error_in_object_segment, code);

	     if code ^= 0 then do;
TAPE_ER:		if error_in_object_segment then
		     call ERROR ("Bad object segment.", "1"b);
		else call ERROR ("Unrecoverable tape error.", "1"b);
	     end;

	     if (db_hit | do_hit) then
		tape_er_count = 0;
	     else call iox_$control (mst_tape_iocbp, "error_count", addr (tape_er_count), code);

	     if tape_er_count ^= 0 then call ERROR ("Error writing first segment.", "1"b);
	end;

/* write out the header */

	else do;
	     call iox_$put_chars (mst_tape_iocbp, seg_hdrp, header_words*4, code);
	     if code ^= 0 then go to TAPE_ER;

/* now write out the segment */

	     if (seg_type = NORMAL_SEG)
	      | (seg_type = WHOLE_OBJECT_SEG)
	      | (seg_type = TEXT_ONLY_SEG)
	      | (seg_type = DATA_SEG) then do;

		call iox_$put_chars (mst_tape_iocbp, segp, wr_w * 4, code);
		if code ^= 0 then go to TAPE_ER;
	     end;
	end;

	return;



WRITE_COLLECTION: entry;


	call iox_$put_chars (mst_tape_iocbp, sltep, 8, code);
	if code ^= 0 then go to TAPE_ER;

	return;


     end WRITE_SEGMENT;


/*  */

GET_NEXT_SYM: proc;


	call parse_file_$parse_file_ptr (symp, numc, sym_is_a_break, eof_was_found);
	if eof_was_found = 1 then			/* error,eof found before "fini" */
	     call ERROR ("Physical end of header reached before logical end.", "1"b);

	return;


     end GET_NEXT_SYM;



GET_NEXT_ARG: proc;


	call GET_NEXT_SYM;

	if sym_is_a_break = 1 then			/* Should not be a break. */
	     call ERROR ("Break found when keyword or argument expected.", "0"b);

	return;


GET_NEXT_BREAK: entry;

	call GET_NEXT_SYM;

	if sym_is_a_break = 0 then			/* Must be a break. */
	     call ERROR ("Invalid break.", "0"b);

	return;


     end GET_NEXT_ARG;



TEST_BREAK: proc (break);

dcl  break char (1) aligned;				/* break char to be checked */

	call GET_NEXT_BREAK;

	if arg ^= break then
	     call ERROR ("Invalid break.", "0"b);

	return;


     end TEST_BREAK;


/*  */

YES_NO:	proc returns (bit (1) unal);

dcl  switch bit (1) aligned;


	call TEST_BREAK (":");
	call GET_NEXT_ARG;
	if arg = "yes" then switch = "1"b;
	else if arg = "no" then switch = "0"b;
	else call ERROR ("Invalid argument.", "0"b);

	call TEST_BREAK (";");

	return (switch);


     end YES_NO;



GET_NUM:	proc returns (fixed bin);


	call GET_NEXT_ARG;
	return (bin (fixed (arg, 6), 17));


     end GET_NUM;


/*  */

CLEANUP_CONDITION_HANDLER: proc;


	call gm_error_ (0, seg_name, symp, hdrp, "Cleanup handler invoked.", addr (o_ln), "1"b, end_found,
	     "0"b, in_p, gm_output_iocbp);

	call gm_util1_$close (gm_output_iocbp, mst_tape_iocbp, hd_hit);


     end CLEANUP_CONDITION_HANDLER;



ERROR:	proc (gm_message, fatal);		/* normal error handler */

dcl  gm_message char (*),				/* gm error message */
     fatal bit (1) aligned;				/* fatal error switch */


	call gm_error_ (code, seg_name, symp, hdrp, gm_message, addr (o_ln),
	     fatal, end_found, "0"b, in_p, gm_output_iocbp);

	if ^fatal then
	     go to error_label;
	else
	     go to close_out;


     end ERROR;



skip_to_next_seg:
	if end_found then do while (sym_is_a_break = 0);
	     call GET_NEXT_SYM;
	end;
	else do;
	     do while (arg ^= "end");
		call GET_NEXT_SYM;
	     end;
	     call GET_NEXT_SYM;
	end;
	end_found = "0"b;
	if arg ^= ";" then
	     go to skip_to_next_seg;
	else
	go to next_segment;


%page; %include gm_data;
%page; %include slte;
%page; %include object_info;
%page; %include decode_definition_str;
%page; %include time_names;

     end generate_mst;
