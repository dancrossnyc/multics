/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/* format: style4,delnl,insnl,ifthenstmt,ifthen */

/* format: off */

/* Spooling driver control module for the I/O daemon */

/* Created:  14 July 1975 by Janice B. Phillipps */
/* Modified: June 1976 by J. Phillipps to change modes declaration from char(128) to char(256), to initialize
      ordata.output_mode variable to null each time user line modes are parsed, and to correct one instance of request not
      being deleted from dprint queue */
/* Modified: January 1978 by J. C. Whitmore for new printer features and general clean up */
/* Modified: May 1978 by J. C. Whitmore for new dprint_msg format */
/* Modified: August 1978 by J. C. Whitmore for auto defer -> ll < phys_ll &  init xfr rate/limit */
/* Modified: June 1979 by C. Hornig to initialize driver_status.dev_ctl_ptr */
/* Modified: 25 December 1981 by G. Palter to initialize prt_ctl.flags so that any unimplemented features will not be
      accidently left on (eg: force_ctl_char) */
/* Modified by C. Marker, 02/23/85, to use version 5 message segments */


/****^  HISTORY COMMENTS:
  1) change(87-05-10,Gilcrease), approve(87-05-13,MCR7686),
     audit(88-02-01,Farley), install(88-02-02,MR12.2-1019):
     Update for dprint_msg version 4.
  2) change(88-08-19,Brunelle), approve(88-08-19,MCR7911),
     audit(88-10-21,Wallman), install(88-10-28,MR12.2-1199):
     Upgraded to version 5 iod tables.
  3) change(88-08-29,Farley), approve(88-08-19,MCR7911),
     audit(88-10-21,Wallman), install(88-10-28,MR12.2-1199):
     Updated for version 5 dprint_msg.
                                                   END HISTORY COMMENTS */


/* format: on */


spool_driver_:
     procedure ();

	return;

dcl  (addr, clock, null, substr, length, verify, divide, reverse, convert, max, mod, rtrim, string) builtin;

dcl  (cleanup, command_question, resume, conversion) condition;

dcl  date_string char (24),
     ec fixed bin (35),
     i fixed bin,					/* index variable */
     net fixed bin,
     opt char (3),
     rcode fixed bin (35),
     io_stat bit (72) aligned;			/* ios_ status code */

dcl  omode char (256) aligned;
dcl  p2 ptr;

dcl  whoami char (24) int static options (constant) init ("spool_driver_");
dcl  master fixed bin int static options (constant) init (1);
dcl  slave fixed bin int static options (constant) init (2);
dcl  both fixed bin int static options (constant) init (0);
dcl  log fixed bin int static options (constant) init (0);
dcl  normal fixed bin int static options (constant) init (1);
dcl  error fixed bin int static options (constant) init (2);
dcl  header fixed bin int static options (constant) init (1);
dcl  trailer fixed bin int static options (constant) init (2);
dcl  err_msg fixed bin int static options (constant) init (3);
dcl  demount_tape fixed bin init (1) int static options (constant);

dcl  1 static_ctl aligned int static like prt_ctl;	/* here we hold the default control values */

dcl  1 counts_data like counts;

dcl  1 spooling_data aligned,
       2 siptr ptr,
       2 line_length fixed bin;

dcl  stream char (32) aligned internal static;		/* stream for writing to printer */
dcl  static_sip ptr int static init (null);		/* static version of spooling info ptr */
dcl  p ptr internal static;
dcl  time fixed bin (71) internal static init (1);
dcl  no_restart_label label int static;

dcl  1 st aligned based (addr (io_stat)),		/* breakdown of status code */
       2 code fixed bin (35),
       2 flags bit (36);

dcl  space_ht_bs char (3) int static;			/* horiz carriage control chars */
dcl  nl_vt_ff char (3) int static;			/* vert carriage control chars, init nl || vt || ff */
dcl  BS char (1) int static options (constant) init ("");	/* the backspace char */
dcl  SP char (1) int static options (constant) init (" ");	/* the space character */
dcl  HT char (1) int static options (constant) init ("	");
						/* the horiz tab character */
dcl  NL char (1) int static options (constant) init ("
");						/* the new-line character */
dcl  VT char (1) int static options (constant) init ("");						/* the vertical tab character */
dcl  FF char (1) int static options (constant) init ("");						/* the form feed character */

dcl  spool_static_$norestart ext;
dcl  spool_static_$file_attch ext;
dcl  spool_static_$debug ext;
dcl  spool_static_$tally_printed ext;

dcl  error_table_$fatal_error fixed bin (35) ext static;
dcl  error_table_$action_not_performed fixed bin (35) ext static;

dcl  iox_$find_iocb entry (char (*) aligned, ptr, fixed bin (35));
dcl  convert_binary_integer_$decimal_string entry (fixed bin) returns (char (12) var);
dcl  date_time_ entry (fixed bin (71), char (*));
dcl  get_spooling_data_$renew_limits entry (ptr, char (*), fixed bin (35));
dcl  get_spooling_data_$initial entry (ptr, char (*), fixed bin (35));
dcl  head_sheet_$print_head_sheet entry (ptr, ptr, ptr, fixed bin (35));
dcl  ioa_ entry options (variable);
dcl  iodd_listen_ entry (ptr);
dcl  iodd_msg_ entry options (variable);
dcl  ios_$attach entry (char (*) aligned, char (*) aligned, char (*) aligned, char (*) aligned, bit (72) aligned);
dcl  ios_$changemode entry (char (*) aligned, char (*) aligned, char (*) aligned, bit (72) aligned);
dcl  ios_$detach entry (char (*) aligned, char (*) aligned, char (*) aligned, bit (72) aligned);
dcl  ios_$order entry (char (*) aligned, char (*) aligned, ptr, bit (72) aligned);
dcl  ios_$write entry (char (*) aligned, ptr, fixed bin, fixed bin, fixed bin, bit (72) aligned);
dcl  output_request_ entry (char (*) aligned, fixed bin, ptr, entry, fixed bin (35));
dcl  output_request_$error_during_request entry (char (*));
dcl  output_request_$set_single_copy entry ();
dcl  spooling_question_handler_ entry (ptr, fixed bin (35));
dcl  tail_sheet_$print_tail_sheet entry (ptr, ptr, ptr, fixed bin (35));
dcl  timer_manager_$sleep entry (fixed bin (71), bit (2) aligned);
dcl  write_sample_prt_banner_ entry (char (*), ptr, ptr, fixed bin (35));

/**/

init:
     entry (arg_p);

dcl  arg_p ptr;

	stat_p = arg_p;				/* pts to argument string */
	p = iodd_static.driver_ptr;			/* get pointer to driver_status seg */
	p -> driver_status.dev_ctl_ptr, prt_ctl_ptr = addr (static_ctl);
						/* use static device control */

	if iodd_static.attach_type ^= 1 then do;	/* this driver needs to look like printer driver */
						/* expects an IOM channel */
	     call iodd_msg_ (error, master, error_table_$fatal_error, whoami,
		"This driver requires a prph statement in iod_tables.");
	     return;				/* back to iodd_ */
	end;

	if iodd_static.assigned_devices > 1 then do;	/* be sure all is correct */
	     call iodd_msg_ (error, master, error_table_$fatal_error, whoami,
		"Multiple minor devices are not supported by the spool driver.");
	     return;
	end;

	if iodd_static.ctl_term.attached then do;	/* can't use a control terminal */
	     call iodd_msg_ (error, master, error_table_$fatal_error, whoami,
		"The spool driver cannot run with a control terminal.");
	     return;
	end;

	if ^iodd_static.test_entry then spool_static_$debug = 0;
						/* reset if not testing */

	spool_static_$norestart = 0;
	spool_static_$file_attch = 0;
	spool_static_$tally_printed = 0;

	iodd_static.device_dim = "spooldim_";		/* the only dim used by this driver */

	iodd_static.dev_io_stream, stream = "printer_output";
						/* record the stream name */
	p -> driver_status.dev_out_stream = stream;
	iodd_static.dev_in_stream = "Undefined_stream";	/* just to avoid un-initialized variables */

	call ios_$attach (stream, iodd_static.device_dim, iodd_static.attach_name, "", io_stat);
	if st.code ^= 0 then do;
	     call iodd_msg_ (error, master, st.code, whoami, "Unable to attach spooldim_ to ^a",
		iodd_static.attach_name);
	     return;
	end;

	call ios_$order (stream, "get_info_ptr", addr (spooling_data), io_stat);
	if st.code ^= 0 then do;
	     call iodd_msg_ (error, master, st.code, whoami, "Unable to get ptr to spooling_info.");
	     go to clean_out;
	end;

	static_sip, sip = spooling_data.siptr;		/* get the ptr once and for all */

	if spooling_info.version ^= spooling_info_version_4 then do;
	     call iodd_msg_ (error, master, 0, whoami, "Fatal error: Wrong version of spooling info structure.");
	     go to clean_out;
	end;


/* Get ready to clean up after a no_coord or re_init condition */

	on cleanup
	     begin;				/* they will try to transfer back to iodd_ by go to */
		if spool_static_$debug = 1 then call ioa_ ("spool_driver_: cleanup.");
		if spool_static_$tally_printed = 0 then call ios_$order (stream, "print_tally", null, io_stat);
		call ios_$detach (iodd_static.dev_io_stream, "", "", io_stat);
	     end;


	call iox_$find_iocb (p -> driver_status.dev_out_stream, p -> driver_status.dev_out_iocbp, ec);
	if ec ^= 0 then do;
	     call iodd_msg_ (error, master, ec, whoami, "Fatal error: Unable to get iocbp for device stream.");
	     go to clean_out;			/* that's all we can do... */
	end;

	string (prt_ctl.flags) = ""b;			/* insure any unimplemented flags are off */

	if p -> driver_status.rqti_ptr ^= null then do;	/* if there is an rqti seg, use it */

	     prt_rqtip = p -> driver_status.rqti_ptr;	/* make the based references cleaner */
	     if prt_rqti.header.header_version ^= rqti_header_version_1 then do;
		call iodd_msg_ (error, master, error_table_$fatal_error, whoami,
		     "prt rqt info version ^d found (expected ^d)", prt_rqti.header.header_version,
		     rqti_header_version_1);
		go to clean_out;
	     end;

	     prt_ctl.meter = prt_rqti.header.meter;	/* do we save meters for this rqt? */
	     iodd_static.slave_hold = ^(prt_rqti.header.auto_go);
						/* set the initial hold state as requested */
	     iodd_static.wakeup_time = max (30, prt_rqti.header.driver_wait_time);
						/* seconds to wait for a request */
	     if prt_rqti.header.type_code = 0 then go to set_defaults;
						/* this is only a header */
	     else if prt_rqti.header.type_code ^= 1 then do;
		call iodd_msg_ (error, master, error_table_$fatal_error, whoami,
		     "Wrong rqt info seg type for printer.");
		go to clean_out;
	     end;

	     if prt_rqti.version ^= prt_rqti_version_1 then do;
						/* see if it is the right version */
		call iodd_msg_ (error, master, error_table_$fatal_error, whoami,
		     "Wrong version of prt_rqti. Found ^d (expected ^d)", prt_rqti.version, prt_rqti_version_1);
		go to clean_out;
	     end;

	     if prt_rqti.opr_msg ^= "" then call iodd_msg_ (normal, both, 0, "", "^/^a", prt_rqti.opr_msg);
						/* give special operator instructions */

	     prt_ctl.phys_page_length = prt_rqti.paper_length;
						/* get paper data for prtdim */
	     prt_ctl.phys_line_length = prt_rqti.paper_width;
	     prt_ctl.lines_per_inch = prt_rqti.lines_per_inch;

	     prt_ctl.channel_stops (*) = prt_rqti.channel_stops (*);
						/* get VFU stops for prtdim */

	     prt_ctl.banner_type = prt_rqti.banner_type;	/* copy control info to writable storage */
	     prt_ctl.force_nep = prt_rqti.force_nep;
	     prt_ctl.force_esc = prt_rqti.force_esc;
	     prt_ctl.no_auto_print = prt_rqti.no_auto_print;
	     prt_ctl.banner_bars = prt_rqti.banner_bars;
	     prt_ctl.banner_indent = prt_rqti.banner_indent;
	     prt_ctl.banner_line = prt_rqti.banner_line;
	end;
	else do;					/* no rqti seg, so set some defaults */
	     prt_ctl.meter = "0"b;			/* don't keep any meters */
	     iodd_static.slave_hold = "1"b;		/* be sure to ask for a start command */
	     iodd_static.wakeup_time = 30;		/* check every 30 seconds */
set_defaults:					/* set up the default paper data */
	     prt_ctl.phys_page_length = 66;		/* 11 inch paper at 6 lpi is 66 lines */
	     prt_ctl.phys_line_length = 132;		/* assume the non-standard printer paper */
	     prt_ctl.lines_per_inch = 6;		/* normal for good readibility */

	     string (prt_ctl.channel_stops) = "0"b;	/* no slew stops are defined */

	     prt_ctl.force_nep = "0"b;		/* let user have his way */
	     prt_ctl.force_esc = "0"b;
	     prt_ctl.no_auto_print = "0"b;		/* print without requesting operator attn */
	     prt_ctl.banner_type = 1;			/* use normal head/tail sheets */
	     prt_ctl.banner_bars = 0;			/* means nothing for now */
	     prt_ctl.banner_indent = 0;		/* again */
	     prt_ctl.banner_line = 1;			/* again */
	end;


/* Now set up the DIM with the paper and channel stop data */

	call set_paper_info (slave, ec);
	if ec ^= 0 then go to clean_out;		/* message was printed by proc */

	call ios_$order (p -> driver_status.dev_out_stream, "channel_stops", addr (prt_ctl.channel_stops), io_stat);
	if st.code ^= 0 then do;
	     call iodd_msg_ (error, master, st.code, whoami, "Fatal error: Unable to perform channel_stops order.");
	     go to clean_out;			/* fatal error */
	end;

	call get_spooling_data_$initial (sip, opt, ec);
	if opt = "det" | ec ^= 0 then do;		/* actually both tests are the same */
	     call iodd_msg_ (normal, master, 0, "", "The spool driver is terminating.");
	     go to clean_out;
	end;

	p -> driver_status.attached = "1"b;
	p -> driver_status.ready = "1"b;
	p -> driver_status.busy = "0"b;
	p -> driver_status.request_pending = (36)"0"b;
	p -> driver_status.elem_size = 9;		/* output is in characters - 9 bits each */
	p -> driver_status.message_type = 1;		/* we only want dprint requests */
	p -> driver_status.bit_rate_est = 0;		/* no rate defined yet */
	p -> driver_status.defer_time_limit = 0;	/* make operator specify */

	iodd_static.slave_hold = "1"b;		/* ask for a command */

	nl_vt_ff = NL || VT || FF;			/* vert carriage control */
	space_ht_bs = SP || HT || BS;			/* horiz carriage control */

	if prt_ctl.phys_line_length > 132 then		/* this is probably an error */
	     call iodd_msg_ (error, master, 0, "",
		"^/Warning: Current line length is ^d.  The target device may only allow 132.",
		prt_ctl.phys_line_length);

	call date_time_ (clock (), date_string);	/* get set for ready message */
	call iodd_msg_ (normal, both, 0, "", "^/Spool driver ready at ^16a^/", date_string);

	call iodd_listen_ (stat_p);

clean_out:
	call ios_$detach (iodd_static.dev_io_stream, "", "", io_stat);
	return;

/**/

/* This entry is called by iodd_listen_ when a request for the spool driver has been received from the coordinator
   Validation is done here for correct and expected dprint request format.  This module calls output_request_, giving it
   the element size and stream name to use, and output_request_ checks user's access to data.  The stream to be used was
   set for this driver module in the init entry.  The print_banner argument to output_request_ defines the procedure that
   must be called before and after each dprint request is processed (each copy) to open or close the file on the ANSI tape
*/

request:
     entry ();

          p = iodd_static.driver_ptr;			/* make it general although it will always be the same */
	p2 = addr (p -> driver_status.descriptor);
	dmp = addr (p -> driver_status.message);	/* get ptr to message */
	prt_ctl_ptr = p -> driver_status.dev_ctl_ptr;	/* get current ctl structure */

	no_restart_label = kill_driver;		/* in case of error from higher block */

	if spool_static_$norestart = 1 then do;		/* something bad happened */
kill_driver:
	     call iodd_msg_ (error, master, 0, "", "Spool driver is logging out.");
	     iodd_static.current_devices = 0;		/* disable the go cmd */
	     iodd_static.runout_requests = "1"b;
	     iodd_static.logout_pending = "1"b;		/* ready for auto logout */
	     p -> driver_status.attached = "0"b;	/* disable the ready cmd */
	     p -> driver_status.ready = "0"b;		/* don't ask for another request */
	     iodd_static.step = "0"b;			/* disable step mode */
	     iodd_static.master_hold = "0"b;
	     iodd_static.slave_hold = "0"b;
	     return;
	end;

	if dmp -> queue_msg_hdr.hdr_version ^= queue_msg_hdr_version_1 then do;
						/* trouble */
	     call iodd_msg_ (log, both, 0, "", "Invalid message header.  Cannot read request ^d.^d.",
		p2 -> request_descriptor.seq_id, p2 -> request_descriptor.q);
	     p2 -> request_descriptor.keep_in_queue = "1"b;
						/* save for conversion later */
	     go to be_nice;
	end;
	if dmp -> queue_msg_hdr.message_type ^= p -> driver_status.message_type then do;
	     call iodd_msg_ (log, both, 0, "",		/* log the error */
		"Incorrect message type for this driver.^/Request ^d.^d for ^a (segment ^a) not processed.",
		p2 -> request_descriptor.seq_id, p2 -> request_descriptor.q,
		p2 -> request_descriptor.mseg_message_info_copy.sender_id,
		dmp -> queue_msg_hdr.ename);
	     p2 -> request_descriptor.cancelled = "1"b;	/* don't want this back */
be_nice:
	     p2 -> request_descriptor.dont_delete = "1"b; /* save the user's data */
	     p2 -> request_descriptor.finished = "1"b;	/* mark it done */
	     return;				/* it wasn't for us after all */
	end;
	if dprint_msg.version ^= dprint_msg_version_3 & dprint_msg.version ^= dprint_msg_version_4
	     & dprint_msg.version ^= dprint_msg_version_5 then do;
						/* other trouble? */
	     call iodd_msg_ (log, both, 0, "",
		"Wrong message version found.^/Request ^d.^d for ^a (segment ^a) not processed",
		p2 -> request_descriptor.seq_id, p2 -> request_descriptor.q,
		p2 -> request_descriptor.mseg_message_info_copy.sender_id,
		dmp -> queue_msg_hdr.ename);
	     p2 -> request_descriptor.keep_in_queue = "1"b;
	     go to be_nice;
	end;
	if dprint_msg.line_lth > prt_ctl.phys_line_length then do;
						/* platten wide enough */
	     call iodd_msg_ (log, both, 0, "",
		"Request ^d.^d for ^a (segment ^a) deferred.^/Requires a device with line length of ^d.",
		p2 -> request_descriptor.seq_id, p2 -> request_descriptor.q,
		p2 -> request_descriptor.mseg_message_info_copy.sender_id,
		dmp -> queue_msg_hdr.ename, dprint_msg.line_lth);
	     p2 -> request_descriptor.keep_in_queue = "1"b;
						/* defer it */
	     go to be_nice;
	end;

	iodd_static.quit_during_request = "0"b;		/* start clean */

	call output_request_ (stream, p -> driver_status.elem_size, stat_p, print_banner, rcode);
	if rcode ^= 0 then iodd_static.slave_hold = "1"b; /* ask for a command */

	if spool_static_$norestart = 1 then go to kill_driver;
						/* in case something happened */


/* Now check the limits */

	sip = static_sip;				/* set the auto ref ptr */

	if sip -> spooling_info.line_limit ^= 0 then do;
	     if sip -> spooling_info.spooling_line_count >= sip -> spooling_info.line_limit then
		sip -> spooling_info.spool_line_limit_sw = 1;
	end;
	if sip -> spooling_info.file_limit ^= 0 then do;
	     if sip -> spooling_info.spooling_file_count >= sip -> spooling_info.file_limit then
		sip -> spooling_info.spool_file_limit_sw = 1;
	end;

	opt = "";					/* clear the operator option string */

	if sip -> spooling_info.spool_file_limit_sw = 1 | sip -> spooling_info.spool_line_limit_sw = 1 then
	     call get_spooling_data_$renew_limits (sip, opt, ec);


/* Now close the file according to operators instructions */

	if opt = "det" then do;
	     call ios_$detach (stream, "", "", io_stat);
	     go to kill_driver;			/* drop this for ever */
	end;

	return;

/**/

print_banner:
     entry (a_stream, banner_type, data_ptr, code);

dcl  a_stream char (*);				/* stream to write banners on. we can ignore it here */
						/* because it is equal to "stream" from output_request_ call */

dcl  banner_type fixed bin;				/* banner_type of banner to be written  */
						/* 1 = header banner            */
						/* 2 = tail banner               */
						/* 3 = error message             */

dcl  data_ptr ptr;					/* pointer to output request data or  */
						/* to char(256) varying string error msg */
dcl  code fixed bin (35);				/* error code */
dcl  error_msg char (256) var based (data_ptr);

	p = iodd_static.driver_ptr;			/* get driver_status pointer */
	prt_ctl_ptr = p -> driver_status.dev_ctl_ptr;	/* and control structure */
	dmp = addr (p -> driver_status.message);	/* get pointer to message */
	ordatap = data_ptr;				/* set default ptr for output_request_data */

	if spool_static_$norestart = 1 then		/* got to stop */
	     go to no_restart_label;			/* make it a clean kill! */

	on command_question
	     begin;				/* handles tape_ansi_ querries */
		sip = static_sip;
		call spooling_question_handler_ (sip, ec);
						/* answer the question */
		if ec ^= 0 then do;
		     call iodd_msg_ (error, master, ec, whoami, "Unrecoverable error, reinit the driver.");
		     iodd_static.master_hold = "1"b;
		     p -> driver_status.busy = "0"b;	/* try the same request again */
		     signal resume;
		end;
	     end;


/* Call to attach thru tape_ansi_, head sheet comming up */

	sip = static_sip;				/* make spooling info references easy */


	if banner_type = header then do;

/* Heading banner for printer wanted */

	     if spool_static_$file_attch = 1 then	/* check if some file attached and/or open already */
		call ios_$order (stream, "file_close", null (), io_stat);
						/* call to close ansi tape file */

	     call ios_$order (stream, "file_open", null (), io_stat);
						/* call to open ansi tape file */
	     if st.code ^= 0 then do;			/* have to terminate */
		call iodd_msg_ (error, master, st.code, whoami, "Unable to open tape file.");
		code = st.code;			/* spooling_dim_order_ has taken tape down */
		call ios_$order (stream, "print_tally", null (), io_stat);
		spool_static_$norestart = 1;		/* want driver to logout or start new fileset */
		return;
	     end;

	     spool_static_$file_attch = 1;		/* a ansi tape file attached and open */
	     if spool_static_$debug = 1 then call ioa_ ("spool_driver_: ANSI file opened.");

	     call ios_$order (stream, "reset", null (), io_stat);
						/* get modes to a known format */
	     call ios_$order (stream, "inside_page", null (), io_stat);
						/* and page position */

	     if st.code ^= 0 then do;			/* trouble trying to write: give up */
		code = st.code;
		call ios_$order (stream, "file_close", addr (demount_tape), io_stat);
						/* close and drop tape */
		spool_static_$norestart = 1;
		return;
	     end;

	     call head_sheet_$print_head_sheet (p -> driver_status.dev_out_iocbp, prt_ctl_ptr, data_ptr, code);

	     call ios_$order (stream, "get_count", addr (counts_data), io_stat);
						/* get count of lines for spooling tallies */
	     sip -> spooling_info.spooling_line_count =
		sip -> spooling_info.spooling_line_count + counts_data.line_count;
						/* line count for head sheet */

	     call ios_$order (stream, "end_of_page", null (), io_stat);
						/* get ready for user data */
	     call ios_$order (stream, "reset", null (), io_stat);
						/* don't charge for advertizing */

	     call set_line_mode;			/* set indentation and line length before the first label */
	     call set_page_labels (stream, ec);

	     call ios_$write (stream, addr (FF), 0, 1, i, io_stat);
						/* start a fresh page and print any labels */

	     call set_user_output_modes;		/* only now can we set the page length */
	     return;
	end;


	if banner_type = trailer then do;

/* A tail sheet banner is wanted */

	     if iodd_static.test_entry then		/* be able to set a reasonable pace */
		if time > 1 then call timer_manager_$sleep (time, "11"b);
						/* simulate device */

	     call ios_$order (stream, "get_count", addr (counts_data), io_stat);
						/* save request line count */
	     sip -> spooling_info.spooling_line_count =
		sip -> spooling_info.spooling_line_count + counts_data.line_count;

	     call ios_$order (stream, "end_of_page", null (), io_stat);
						/* used to be bottom inside page  */
	     call ios_$order (stream, "reset", null (), io_stat);
						/* Don't use user's modes for tailsheet */
	     call ios_$order (stream, "outside_page", null (), io_stat);
						/* top outside page for tail sheet */

	     call tail_sheet_$print_tail_sheet (p -> driver_status.dev_out_iocbp, prt_ctl_ptr, data_ptr, code);

	     call ios_$order (stream, "get_count", addr (counts_data), io_stat);

	     sip -> spooling_info.spooling_line_count =
		sip -> spooling_info.spooling_line_count + counts_data.line_count;

	     sip -> spooling_info.spooling_file_count = sip -> spooling_info.spooling_file_count + 1;

	     call ios_$order (stream, "file_close", null (), io_stat);

	     if spool_static_$debug = 1 then call ioa_ ("spool_driver_: tape file closed.");
	     spool_static_$file_attch = 0;		/* turn off file open indicator */
	     return;
	end;


	if banner_type = err_msg then do;

/* Put out an error message */

	     call ios_$changemode (stream, "default", omode, io_stat);
						/* use known modes for errors */
	     call ios_$write (stream, data_ptr, 4, length (error_msg), net, io_stat);
						/* skip the first 4 chars(length) */
	     call ios_$changemode (stream, omode, "", io_stat);
						/* put it back for more output */
	     code = 0;				/* don't cause trouble during recovery */
	     return;
	end;


/* All other banner types are undefined */

	code = error_table_$action_not_performed;

	return;

/**/

command:
     entry (source, state, arg_list_p, c_code);

dcl  source fixed bin;				/* 1 = master console, 2 = slave */
dcl  state fixed bin;				/* 0 = not quite ready to handle a request */
						/* 1 = drivers are ready */
						/* 2 = command entered after a quit */
dcl  arg_list_p ptr;				/* ptr to structure returned by parse_command_ */
dcl  c_code fixed bin (35);				/* error code: zero if command handled correctly */
dcl  save_code fixed bin (35);			/* saved value of c_code when called */
						/* error_table_ code for bad syntax or unknown command */

dcl  1 arg_list aligned based (arg_list_p),		/* parse_command_ structure */
       2 max_tokens fixed bin,			/* space allocated, do not change */
       2 n_tokens fixed bin,				/* number of tokens from command line (including cmd) */
       2 command char (64) var,			/* the first token is the command */
       2 arg (n_tokens - 1) char (64) var;		/* the other tokens are args to the command */

dcl  new_pl fixed bin;				/* temp for setting the phys page length */
dcl  new_ll fixed bin;				/* temp for the new phys line length */
dcl  new_lpi fixed bin;				/* and for the new lines per inch value */
dcl  not bit (1);
dcl  value char (32);				/* temporary char string */


	on conversion
	     begin;				/* handler for conversion errors */
		call iodd_msg_ (normal, source, 0, "", "Argument conversion error. Try again.");
		go to cmd_error;
	     end;

	save_code = c_code;				/* save the called value */
	p = iodd_static.driver_ptr;			/* make this ready for command use */
	prt_ctl_ptr = p -> driver_status.dev_ctl_ptr;
	c_code, ec = 0;				/* say we handled it for now */


	if command = "help" then do;
	     call iodd_msg_ (normal, source, 0, "", "^/** Commands for the spool driver **^/");
	     call iodd_msg_ (normal, source, 0, "", "banner_bars [<minor_dev>]  single | double | none");
	     call iodd_msg_ (normal, source, 0, "", "banner_type [<minor_dev>]  standard | brief | none");
	     call iodd_msg_ (normal, source, 0, "",
		"paper_info [<minor_dev>] [-ll <line_len>] [-pl <paper_len>] [-lpi <6 or 8>]");
	     call iodd_msg_ (normal, source, 0, "",
		"prt_control [<minor_dev>] [^]KEY ... (KEYs: force_nep, force_esc, autoprint)");
	     call iodd_msg_ (normal, source, 0, "", "sample_hs [<minor_dev>]");
	     call iodd_msg_ (normal, source, 0, "", "single");
	     if test_entry then call iodd_msg_ (normal, source, 0, "", "time [<sleep_time>]");
	     call iodd_msg_ (normal, source, 0, "", "debug_on");
	     call iodd_msg_ (normal, source, 0, "", "debug_off");
	     go to end_cmd;
	end;

	if command = "debug_on" then do;
	     if ^iodd_static.test_entry then go to cmd_error;
	     spool_static_$debug = 1;
	     go to end_cmd;
	end;

	if command = "debug_off" then do;
	     if ^iodd_static.test_entry then go to cmd_error;
	     spool_static_$debug = 0;
	     go to end_cmd;
	end;

	if command = "time" then
	     if ^iodd_static.test_entry then do;	/* refuse to recognize if not testing */
		ec = save_code;
		go to end_cmd;
	     end;
	     else do;
		if n_tokens > 1 then
		     time = convert (time, arg (1));
		else time = 1;			/* return to the default..full speed */
		go to end_cmd;
	     end;

	if command = "banner_bars" | command = "bannerbars" then do;
	     if arg_list.n_tokens > 1 then		/* some arg given */
		if p -> driver_status.device_id = arg (1) then
		     i = 2;			/* minor device, args can start at number 2 */
		else i = 1;			/* first arg was a value */
	     else i = 1;				/* no args at all */
	     if arg_list.n_tokens = i | arg (i) = "-print" then do;
						/* give value */
		if prt_ctl.banner_bars = 0 then opr_msg = "double";
		else if prt_ctl.banner_bars = 1 then opr_msg = "single";
		else if prt_ctl.banner_bars = 2 then opr_msg = "none";
		else opr_msg = "Undefined value";
		call iodd_msg_ (normal, source, 0, "", "Current value is:  ^a", opr_msg);
		go to end_cmd;
	     end;
	     if arg (i) = "double" then prt_ctl.banner_bars = 0;
	     else if arg (i) = "single" then prt_ctl.banner_bars = 1;
	     else if arg (i) = "none" then prt_ctl.banner_bars = 2;
	     else do;
		call iodd_msg_ (normal, source, 0, "", "Undefined argument ^a.  Use single, double or none.", arg (1))
		     ;
		go to cmd_error;
	     end;

	     go to end_cmd;
	end;

	if command = "banner_type" | command = "bannertype" then do;
	     if arg_list.n_tokens > 1 then		/* some arg given */
		if p -> driver_status.device_id = arg (1) then
		     i = 2;			/* minor device, args can start at number 2 */
		else i = 1;			/* possibly first arg was a value */
	     else i = 1;				/* no args at all */
	     if n_tokens = i | arg (i) = "-print" then do;/* give the values */
		if prt_ctl.banner_type = 0 then opr_msg = "none";
		else if prt_ctl.banner_type = 1 then opr_msg = "standard";
		else if prt_ctl.banner_type = 2 then opr_msg = "brief";
		else opr_msg = "Undefined value";
		call iodd_msg_ (normal, source, 0, "", "Current value is:  ^a", opr_msg);
		go to end_cmd;
	     end;

	     if arg (i) = "standard" then prt_ctl.banner_type = 1;
	     else if arg (i) = "none" then prt_ctl.banner_type = 0;
	     else if arg (i) = "brief" then prt_ctl.banner_type = 2;
	     else do;
		call iodd_msg_ (normal, source, 0, "", "Banner type ^a is not defined.");
		go to cmd_error;
	     end;

	     go to end_cmd;
	end;

	if command = "single" then do;		/* operator wants to single space FF and VT */
	     if iodd_static.request_in_progress then do;
		call ios_$changemode (p -> driver_status.dev_out_stream, "single.", omode, io_stat);
						/* set mode */
		call output_request_$set_single_copy ();/* avoid same problem if another copy requested */
	     end;
	     else call iodd_msg_ (normal, source, 0, "", "No current request.");
	     go to end_cmd;
	end;

	if command = "paper_info" | command = "paperinfo" then do;
	     if arg_list.n_tokens > 1 then		/* some arg given */
		if p -> driver_status.device_id = arg (1) then
		     i = 2;			/* minor device, args can start at number 2 */
		else i = 1;			/* possibly first arg was a value */
	     else i = 1;				/* no args at all */
	     if n_tokens = i | arg (i) = "-print" then do;
		call iodd_msg_ (normal, source, 0, "",
		     "Physical paper width:  ^d characters ^/Physical paper length:  ^d lines (at ^d lines per inch)",
		     prt_ctl.phys_line_length, prt_ctl.phys_page_length, prt_ctl.lines_per_inch);
		go to end_cmd;
	     end;
	     if mod ((n_tokens - i), 2) = 1 then do;
		call iodd_msg_ (normal, source, 0, "",
		     "The paper_info command must have an even number of arguments.");
		go to cmd_error;			/* make him do it right */
	     end;

	     new_ll = prt_ctl.phys_line_length;		/* record the old values as the default */
	     new_pl = prt_ctl.phys_page_length;
	     new_lpi = prt_ctl.lines_per_inch;

	     do i = i to n_tokens - 1 by 2;		/* check the arg pairs */
		if arg (i) = "-ll" then new_ll = convert (new_ll, arg (i + 1));
		else if arg (i) = "-pl" then new_pl = convert (new_pl, arg (i + 1));
		else if arg (i) = "-lpi" then new_lpi = convert (new_lpi, arg (i + 1));
		else do;				/* bad control arg */
		     call iodd_msg_ (normal, source, 0, "", "Invalid control argument:  ^a", arg (i));
		     go to cmd_error;
		end;
	     end;
	     if new_ll < 10 | new_ll > 200 then do;	/* check the range */
		call iodd_msg_ (normal, source, 0, "", "Line length range is 10 to 200.");
		go to cmd_error;
	     end;

	     if ^(new_lpi = 6 | new_lpi = 8) then do;
		call iodd_msg_ (normal, source, 0, "", "Lines per inch must be 6 or 8.");
		go to cmd_error;
	     end;
	     if new_pl < 10 then do;
		call iodd_msg_ (normal, source, 0, "", "Minimum paper length is 10 lines.");
		go to cmd_error;
	     end;
	     if new_pl > 127 then do;
		call iodd_msg_ (normal, source, 0, "", "Maximum paper length is 127 lines.");
		go to cmd_error;
	     end;

	     prt_ctl.phys_line_length = new_ll;
	     prt_ctl.phys_page_length = new_pl;
	     prt_ctl.lines_per_inch = new_lpi;

	     call iodd_msg_ (normal, source, 0, "", "Changing to:  ll ^d, pl ^d at ^d lines per inch.",
		prt_ctl.phys_line_length, prt_ctl.phys_page_length, prt_ctl.lines_per_inch);

	     call set_paper_info (source, ec);

	     go to end_cmd;
	end;

	if command = "prt_control" | command = "prtcontrol" then do;
	     if arg_list.n_tokens > 1 then		/* some arg given */
		if p -> driver_status.device_id = arg (1) then
		     i = 2;			/* minor device, args can start at number 2 */
		else i = 1;			/* possibly first arg was a value */
	     else i = 1;				/* no args at all */
	     if n_tokens = i | arg (i) = "-print" then do;/* give the values */
		call iodd_msg_ (normal, source, 0, "", "Values are: ^[^^^]force_nep, ^[^^^]force_esc",
		     ^prt_ctl.force_nep, ^prt_ctl.force_esc);
	     end;
	     else do;
		do i = i to n_tokens - 1;		/* look at each argument */
		     not = (substr (arg (i), 1, 1) = "^");
						/* was first char a "^" */
		     if not then
			value = substr (arg (i), 2);
		     else value = arg (i);
		     if value = "force_nep" | value = "forcenep" then prt_ctl.force_nep = ^not;
		     else if value = "force_esc" | value = "forceesc" then prt_ctl.force_esc = ^not;
		     else call iodd_msg_ (normal, source, 0, "", "Undefined argument: ^a", arg (i));
		end;
	     end;
	     go to end_cmd;
	end;

	if command = "sample_hs" | command = "samplehs" then do;
	     if arg_list.n_tokens > 1 then		/* some arg given */
		if p -> driver_status.device_id = arg (1) then
		     i = 2;			/* minor device, args can start at number 2 */
		else i = 1;			/* possibly first arg was a value */
	     else i = 1;				/* no args at all */

	     if spool_static_$file_attch = 1 then	/* check if some file attached and/or open already */
		call ios_$order (stream, "file_close", null (), io_stat);
						/* call to close ansi tape file */

	     call ios_$order (stream, "file_open", null (), io_stat);
						/* call to open ansi tape file */
	     if st.code ^= 0 then do;			/* have to terminate */
		call iodd_msg_ (error, master, st.code, whoami, "Unable to open tape file.");
		go to cmd_error;
	     end;
	     spool_static_$file_attch = 1;		/* a ansi tape file attached and open */

	     call ios_$order (p -> driver_status.dev_out_stream, "reset", null, io_stat);
						/* clear everything */
	     call ios_$order (p -> driver_status.dev_out_stream, "inside_page", null, io_stat);

	     call write_sample_prt_banner_ ("head_sheet", p -> driver_status.dev_out_iocbp, prt_ctl_ptr, ec);

	     call ios_$order (p -> driver_status.dev_out_stream, "end_of_page", null, io_stat);
	     call ios_$order (p -> driver_status.dev_out_stream, "runout", null, io_stat);
						/* be sure it prints */

	     call ios_$order (stream, "file_close", null, io_stat);
	     spool_static_$file_attch = 0;

	     go to end_cmd;
	end;

/*	If we come past here, this command is illegal.  So make a clean return without changing anything. */

	c_code = save_code;				/* restore the original value */
	return;

end_cmd:
	c_code = ec;				/* pass back any defined errors */
	return;

cmd_error:
	c_code = error_table_$action_not_performed;	/* cause a resetread */
	return;

/**/

default_handler:
     entry (cond_ptr);

dcl  cond_ptr ptr;					/* pointer to the condition info structure */

dcl  condition char (32);				/* fixed string for the call */

dcl  1 cond_info aligned based (cond_ptr),		/* this is the level one declaration */
%include cond_info;

	condition = condition_name;

	if iodd_static.request_in_progress then		/* try to avoid mistakes */
	     call output_request_$error_during_request (condition);
						/* take it away */

	return;					/* output_request_ should not return, but.... */

/**/

set_user_output_modes:
     procedure ();

dcl  nm char (128) var;
dcl  om char (128) aligned;
dcl  i fixed bin;
dcl  v char (12) var;

	nm = rtrim (ordata.output_mode);		/* zero length if blank */
	if length (nm) > 0 then nm = nm || ",";		/* separate from new modes */
	if dprint_msg.esc | prt_ctl.force_esc then nm = nm || "esc,";
	if dprint_msg.control.nep | prt_ctl.force_nep then nm = nm || "noskip,";
	if dprint_msg.control.single then nm = nm || "single,";
	if dprint_msg.control.non_edited then nm = nm || "non_edited,";
	if dprint_msg.control.truncate then nm = nm || "truncate,";
	if dprint_msg.page_lth > 1 then do;
	     v = convert_binary_integer_$decimal_string (dprint_msg.page_lth);
	     nm = nm || "pl" || v || ",";
	end;
	i = length (nm);
	if i > 0 then do;
	     ordata.output_mode = nm;			/* save and put in fixed string */
	     substr (ordata.output_mode, i, 1) = " ";
	     call ios_$changemode (stream, ordata.output_mode, om, io_stat);
	     if st.code ^= 0 then ordata.output_mode = "";/* record mode only if set */
	end;

	return;


set_line_mode:
     entry;

	ordata.output_mode, nm = "";			/* clear the string */
	if dprint_msg.line_lth > 1 then do;
	     v = convert_binary_integer_$decimal_string (dprint_msg.line_lth);
	     nm = nm || "ll" || v || ",";
	end;
	if dprint_msg.lmargin > 1 then do;
	     v = convert_binary_integer_$decimal_string (dprint_msg.lmargin);
	     nm = nm || "in" || v || ",";
	end;
	i = length (nm);
	if i > 0 then do;
	     ordata.output_mode = nm;			/* save and put in fixed string */
	     substr (ordata.output_mode, i, 1) = " ";	/* make the end of the string clean */
	     call ios_$changemode (stream, ordata.output_mode, om, io_stat);
	     if st.code ^= 0 then ordata.output_mode = "";/* record mode only if set */
	end;

     end set_user_output_modes;

/**/

/* Establish top and bottom page label printing on the stream */

set_page_labels:
     procedure (stream, ec);

dcl  stream char (*) aligned;				/* stream to order labels on */
dcl  ec fixed bin (35);				/* error code ... for the future */
dcl  temp_label char (136);				/* temporary for cleaning the label */
dcl  translate builtin;
dcl  1 page_labels aligned,				/* structure for the order call */
       2 top_label char (136),
       2 bottom_label char (136);
dcl  len fixed bin;
dcl  ind fixed bin;
dcl  field fixed bin;				/* print field for centering */
dcl  set_labels bit (1);				/* will be set if there are labels */

	ec = 0;					/* start clean */
	set_labels = "0"b;

	page_labels.top_label, page_labels.bottom_label = " ";
						/* set leading blanks */

	if dprint_msg.line_lth < 1 then
	     field = prt_ctl.phys_line_length;		/* check printable field */
	else field = dprint_msg.line_lth;		/* believe what user asked for */

	if dprint_msg.lmargin > 0 then do;
	     field = field - dprint_msg.lmargin;	/* shorten by indentation */
	     ind = dprint_msg.lmargin;
	end;
	else ind = 1;				/* be sure we start in col 1 */

	temp_label = translate (dprint_msg.top_label, " ", nl_vt_ff);
						/* remove naughty characters */
	if verify (temp_label, space_ht_bs) > 0 then do;	/* anything other than white space? */
	     set_labels = "1"b;			/* we will have to make the order call */
	     len = length (temp_label) + 1 - verify (reverse (temp_label), " ");
						/* how long is  the label */
	     if (field > len) & dprint_msg.control.center_top_label then do;
		len = divide (field - len, 2, 17, 0) + ind;
						/* calculate the starting position */
		substr (page_labels.top_label, len) = temp_label;
						/* drop it in the right position */
	     end;
	     else page_labels.top_label = temp_label;	/* put it in as given (almost) */
	end;

	temp_label = translate (dprint_msg.bottom_label, " ", nl_vt_ff);
						/* do it again for the bottom label */
	if verify (temp_label, space_ht_bs) > 0 then do;
	     set_labels = "1"b;
	     len = length (temp_label) + 1 - verify (reverse (temp_label), " ");
	     if (field > len) & dprint_msg.control.center_bottom_label then do;
		len = divide (field - len, 2, 17, 0) + ind;
		substr (page_labels.bottom_label, len) = temp_label;
	     end;
	     else page_labels.bottom_label = temp_label;
	end;
	if set_labels then do;			/* only make the call if we need to */
	     call ios_$order (stream, "page_labels", addr (page_labels), io_stat);
	     ec = st.code;				/* for the future */
	end;

	return;

     end set_page_labels;

/**/

set_paper_info:
     procedure (source, code);

dcl  code fixed bin (35);
dcl  source fixed bin;

	code = 0;

	call ios_$order (p -> driver_status.dev_out_stream, "paper_info", addr (prt_ctl.paper_info), io_stat);
	if st.code ^= 0 then do;
	     call iodd_msg_ (normal, source, st.code, whoami, "Unable to perform paper_info order.");
	     code = st.code;
	     return;
	end;

	call iodd_msg_ (normal, source, 0, "",
	     "^/Tape will be formatted for ^d lines per physical page, at ^d lines/inch.^/", prt_ctl.phys_page_length,
	     prt_ctl.lines_per_inch);

	return;

     end set_paper_info;
%page; %include access_audit_user_info;
%page; %include dprint_msg;
%page; %include driver_status;
%page; %include iod_tables_hdr;
%page; %include iodd_static;
%page; %include mseg_message_info;
%page; %include output_request_data;
%page; %include prt_ctl;
%page; %include prt_order_info;
%page; %include prt_rqti;
%page; %include queue_msg_hdr;
%page; %include request_descriptor;
%page; %include spooling_info;

     end spool_driver_;
