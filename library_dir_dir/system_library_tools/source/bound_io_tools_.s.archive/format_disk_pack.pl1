/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


format_disk_pack:  fdp:	procedure;

/*
   Initially coded by J. A. Bush -- December, 1975
   Modified by J. A. Bush -- May 1976 for NSS to write format label on System volumes
   Modified by J. A. Bush -- July 1977 to fix bug making t.i. bits undefined if "-hbypass" and "-nodef" args were both used
   Modified by P. B. Kelley -- August 1978 to fix several bugs and remove dependence upon rec. 7 of Multics label.
			 Entire volume bad track list may now only be generated by "read_pack" & "format_pack" ops.
			 Changed structure of arguments passed to avoid "positional argument bugs".
			 Also provided consistency and constraints for formatting tracks.
*/

% include disk_pack;
% include fs_vol_label;

%include query_info;

dcl  iox_$attach_name	entry (char (*), ptr, char (*), ptr, fixed bin (35)),
     iox_$close		entry (ptr, fixed bin (35)),
     iox_$control		entry (ptr, char (*), ptr, fixed bin (35)),
     iox_$detach_iocb	entry (ptr, fixed bin (35)),
     iox_$modes		entry (ptr, char (*), char (*), fixed bin (35)),
     iox_$open		entry (ptr, fixed bin, bit (1) aligned, fixed bin (35)),
     iox_$seek_key		entry (ptr, char (256) varying, fixed bin (21), fixed bin (35)),
     iox_$read_record	entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35)),
     iox_$rewrite_record	entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35)),
    (ioa_, com_err_, ioa_$rsnnl, command_query_)	entry options (variable),
     cv_dec_check_		entry (char (*), fixed bin (35)) returns (fixed bin (35)),
     get_system_free_area_	entry returns (ptr),
     hcs_$initiate		entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35)),
     hcs_$fs_get_mode	entry (ptr, fixed bin (5), fixed bin (35)),
     cu_$arg_count		entry (fixed bin),
     cu_$arg_ptr		entry (fixed bin, ptr, fixed bin, fixed bin (35)),
     user_info_$process_type	entry ( fixed bin ),
     date_time_		entry (fixed bin (71), char (*));

dcl 1 trk_header_info aligned,			/* structure returned from rd_trk_header order */
    2 ha_cyl bit (16) unaligned,			/* home address cylinder number */
    2 ha_hd bit (16) unaligned,			/* home address head number */
    2 pad1 bit (2) unaligned,
    2 ti bit (2) unaligned,				/* track indicator bits */
    2 pad2 bit (10) unaligned,
    2 r0cti bit (2) unaligned,			/* record zero ti bits */
    2 r0ccyl bit (16) unaligned,			/* record zero count cylinder number */
    2 r0chd bit (16) unaligned,			/* record zero count head number */
    2 r0crn bit (8) unaligned,			/* record zero count  record number */
    2 pad3 bit (24) unaligned,
    2 r0df (8) bit (8) unaligned,			/* record zero data field */
    2 pad4 bit (4) unaligned;

dcl 1 fmt_info aligned,				/* user supplied structure for format_trk order */
    2 hz bit (2) unaligned,				/* header bypass information */
    2 ti bit (2) unaligned,				/* track indicator bits */
    2 alt_def_cyl fixed bin (16) unaligned,		/*  user supplied cyl and head address for alt or   */
    2 alt_def_hd fixed bin (16) unaligned;		/* defective track address */

dcl 1 dev_char_table aligned,				/* return structure from device_info order */
    2 subsystem_name char (4),			/* Disk subsystem name */
    2 device_name char (8),				/* Disk drive name */
    2 sect_per_dev fixed bin (35),			/* total no. of non-T&D sectors on pack */
    2 cyl_per_dev fixed bin,				/* no. of non-T&D cylinders on pack */
    2 sect_per_cyl fixed bin,				/* no of sectors per cylinder */
    2 sect_per_track fixed bin,			/* no. of sectors per track */
    2 num_label_sect fixed bin,			/* no. of sectors to reserve for label */
    2 num_alt_sect fixed bin,				/* no. of sectors to reserve for alt. track area */
    2 sect_size fixed bin (12);			/* no. of words in sector */

dcl 1 bounds,					/* return structure from getbounds order */
    2 low fixed bin (35),				/* low boundary */
    2 high fixed bin (35);				/* high disk boundary */

dcl (error_table_$noarg,
     error_table_$action_not_performed,
     error_table_$not_detached,
     error_table_$request_not_recognized) ext fixed bin (35);

dcl (code, seek_key, alt_add) fixed bin (35);
dcl  process_type fixed bin;
dcl ( ap, iocb_ptr, lsp, query_ptr ) ptr;
dcl  areap ptr;
dcl  formatp ptr;					/* pointer to format_label structure */
dcl (mode, i, j, cyl, head, line_pos, outlen, altb, rlen, legal_cyl, legal_hd) fixed bin;
dcl (al, n_args, sect_per_rec, use_sect_per_cyl, unuse_sect_per_cyl) fixed bin;
dcl  arg char (al) based (ap);
dcl  rec_len fixed bin (21);

dcl  rs_mode fixed bin (5);				/* rcp_sys_ acess mode */
dcl  execute bit (5) init ("00100"b);			/* execute permission */
dcl  Option	char (20) varying,
     answer	char (10) varying,
     erresponse	char (18) varying,
     response	char (18) varying,
     vol_id	char (32) varying;

dcl  adescrip	char (168),			/* rdisk_ attach description */
     dev_type	char (4),
     proc_name	char (16) init ("format_disk_pack"),
     pstring	char (5),
     ltime	char (24),
     out		char (256);
dcl  error label;
dcl  cleanup		condition,
     program_interrupt	condition;
dcl (already_printed, input, open, read, hold, defective, interactive, system, fmt_good, bypass, priv, rstsw, fstsw,
     write_attach, not_attached_by_me)
     bit (1) unaligned init ("0"b);
dcl (addr, bit, ceil, divide, fixed, hbound, index, length, mod, null, rtrim, substr, verify) builtin;
dcl  (alt_partition_present, multics_storage_system_volume, total_bad_track_list) bit(1) init ("0"b);
dcl  RECURSE bit(1) static init ("0"b);

dcl  multics_lab_rec fixed bin(23) unaligned;
dcl  1  MULTICS_LABEL aligned like label;

dcl  area area based (areap);

dcl max_bad_trks fixed bin(35) init(141);		/* maximum number of bad tracks - initialize for now */

dcl 1 FORMAT_INFO aligned based (formatp),		/* format data - allocated in system free */
    2 bad_trk_count fixed bin,			/* Number of defective tracks on this pack */
    2 bad_trks (max_bad_trks),			/* array of defective tracks */
      3 track_addr fixed bin (35),			/* First bad Multics record address on this bad track */
      3 alt_addr   fixed bin(35),			/* alternate addr ( = 0 if none) */
      3 bad_rcd_cnt fixed bin;			/* number of bad Multics records on this track */


	if RECURSE then do;				/* don't allow recursive calling */
	     call com_err_ (error_table_$action_not_performed, proc_name,
		"^/^a cannot be invoked recursively. Please type ^/ release -all ^/and try again.", proc_name);
	     return;
	end;
	query_ptr = addr (query_info);
	call user_info_$process_type ( process_type );
	if process_type ^= 1
	     then interactive = "0"b;
	     else interactive = "1"b;
	multics_lab_rec = LABEL_ADDR;
	call cu_$arg_count (n_args);
	if n_args < 2 then do;			/* not enough or no args */
	     call com_err_ (error_table_$noarg, proc_name);
puse:
	     call com_err_ (0, "", "Usage:^-format_disk_pack operation <-volume volume_name> {-control_args-}" );
	     call com_err_ (0, "", "^-^2xoperation:^5xformat_pack, read_pack, format_track, read_track, or read_label" );
	     call com_err_ (0, "", "^-^2xcontrol_args:^2x<-model model_name>, -system, -nodef, -hold, -hbypass"   );
	     call com_err_ (0, "", "^-^5xmodel_name may be: m451, m400, d190, or d181 (m400 default)");

	     return;
	end;
	vol_id = "";				/* initialize to check */
	dev_type = "m400";				/* default  */

	do i = 1 to n_args;				/* process arguments */
	     call cu_$arg_ptr (i, ap, al, code);
	     if code ^= 0 then do;
		call com_err_ (code, proc_name);
		return;
		end;
	     if i = 1 then do;			/* special case arg 1 = positional arg = order */
		if ( (arg ^= "format_track") & (arg ^= "format_pack")
		   & (arg ^= "read_track") & (arg ^= "read_pack")
		     & (arg ^= "read_label") ) then do;
		     call com_err_ (error_table_$request_not_recognized, proc_name, "^a", arg );
		     return;
		     end;
		Option = arg;			/* got a valid Option */
						/* make sure Option doesn't require "interactive" */
		if (^interactive) then if ( (Option ^= "format_pack") & (Option ^= "read_pack") & (Option ^= "read_label") ) then do;
		     call com_err_ (0, proc_name, "The ""^a"" operation is valid only from an interactive process.", Option );
		     return;
		     end;
		end;

	     else if ((arg = "-volume") | (arg = "-vol")) then do;	/* volume" name comes next */
		i = i + 1;				/* increment i */
		call cu_$arg_ptr ( i, ap, al, code );
		if ( (code ^= 0) | (al = 0) ) then do;		/* need volume name */
		     call com_err_ ( 0, proc_name, "Missing volume name after the ""-volume"" control argument." );
		     return;
		     end;
		vol_id = arg;
		end;

	     else if arg = "-model" then do;			/* model comes next */
		i = i + 1;
		call cu_$arg_ptr( i, ap, al, code );
		if ( (code ^= 0) | (al = 0) ) then do;		/* need model # after "-model" */
		     call com_err_ ( 0, proc_name, "Missing model after the ""-model"" control argument." );
		     return;
		     end;
		dev_type = arg;				/* got device type */
		end;

	     else if ( (arg = "-system") | (arg = "-sys") ) 	/* thinks they have system privileges */
		then system = "1"b;				/* we'll check for sure later. */

	     else if arg = "-hold" then do;			/* user doesn't want to release disk */
		if ^interactive then do;			/* can't "hold" from absentee */
		     call com_err_ (0, proc_name, "The ""-hold"" argument is only allowed from an interactive process.");
		     return;
		     end;
		hold = "1"b;
		end;

	     else if arg = "-hbypass"				/* bypass track headers already there */
		then bypass = "1"b;

	     else if arg = "-nodef" then do;			/* no defective tracks */
		if Option ^= "format_pack" then do;		/* only valid with this order */
		     call com_err_ (0, proc_name,
			"The ""-nodef"" argument is only valid with the ""format_pack"" order." );
		     return;
		     end;
		fmt_good = "1"b;				/* passed the test */
		end;

	     else do;					/* must be illegal option */
		call com_err_ (error_table_$request_not_recognized, proc_name, "^a", arg);
		return;
		end;
	     end;

	if vol_id = "" then do;				/* user must specify volume name */
	     call com_err_ (0, proc_name, "No volume specified. Cannot perform operation." );
	     return;
	     end;
						/* Do we have to attach the disk for writing?	*/
	if (Option = "format_pack" | Option = "format_track" )
	     then write_attach = "1"b;		/* definitely!	*/
	if (fmt_good | hold | bypass)
	     then write_attach = "1"b;		/* likewise..	*/

	on cleanup call release;			/* set up "cleanup" handler to release pack.	*/
	call mount;				/* and make call to mount the disk */
	if (code ^= 0 | ^open) then do;		/* error?	*/
	     call release;			/* make sure we release before exiting */
	     return;				/* couldn't mount, reason already given */
	     end;

	go to find_op;

option_lp:
	if ^interactive | (interactive & ^hold) then do;	/* release disk pack */
	     call release;
	     return;
	     end;
	if ^already_printed then do;			/* only print out instructions once */
	     already_printed = "1"b;
	     call ioa_ ("After ""Options:"", is typed out, enter one of the following options:");
	     call ioa_ ("""format_pack"", ""read_pack"", ""read_track"", ""format_track"", ""read_label"", or ""quit""");
	     end;

	yes_or_no_sw, suppress_name_sw = "0"b;
	call command_query_ (query_ptr, Option, "", "Options:");
find_op:
	if Option = "format_pack"
	     then call format_pack;

	else if Option = "read_pack" then do;
	     call read_pack;
	     end;

	else if Option = "read_label" then do;
	     call read_pack_label;
	     end;

	else if Option = "read_track" then do;
	     if ^interactive then do;			/* operation is not allowed in absentee mode */
abs_err:		call com_err_ (0, proc_name, "The ^a operation is only allowed from an ""interactive"" process.", Option);
		return;
		end;
	     call read_track;
	     end;

	else if Option = "format_track" then do;
	     if ^interactive
		then go to abs_err;			/* operation is not allowed in absentee mode */
						/* if Multics & it has no alt part., then don't allow this */
	     if (multics_storage_system_volume & ^alt_partition_present) then do;
		call ioa_ ("Multics Storage System volume ""^a"" has no ""alt"" partition defined.",
		     vol_id );
		call ioa_ ( "The ""format_track"" operation is not valid on this volume." );
		go to option_lp;
		end;
	     call format_track;			/* OK, we'll allow it */
	     end;

	else if Option = "quit" then do;
	     if open
		then call release;			/* dismount pack if mounted */
	     return;
	     end;

	else if ^already_printed then do;			/* if  the initial entry */
	     call com_err_ (0, proc_name, "Operation ^a not recognized", Option);
	     go to puse;
	     end;

	else call com_err_ (0, proc_name, "Illegal option ^a, reenter", Option);
	go to option_lp;

read_pack: proc;					/* read_pack subsystem */

				/* Forms seek addresses for the entire pack, then calls	*/
				/* the rd_sing_trk proc to process. Summary only at end.	*/
	     call ioa_ ("Begin ""read_pack"" operation");
						/* since this operation takes a long time */
						/* establish pi handler to say something  */
	     on program_interrupt			/* useful if user gets bored.              */
		call ioa_ ("Processing ^a", cseek (seek_key ) );

	     do seek_key = bounds.low to bounds.high - sect_per_track by sect_per_track;
		call rd_sing_trk (seek_key);		/* rd track header */
		if code ^= 0
		     then call com_err_ (0, proc_name, "Skipping to next track.");
		end;

	     revert program_interrupt;

						/* if we got this far then we've got the */
	     total_bad_track_list = "1"b;		/* total bad track list figured out.  */
						/* if we had any bad tracks  print them out */
	     call prt_bad_trks;

	     return;

	end read_pack;

read_track:  proc;					/* read track subsystem */

				/* Queries user for "ccc,hh" input, then calls the 	*/
				/* rd_sing_trk proc to process and print.		*/

	if ^rstsw then do;				/* print out instructions one time */
	     call ioa_ ("Enter track address as ""ccc,hh"" for cylinder and head");
	     call ioa_ ("Terminate query by typing ""quit"".");
	     rstsw = "1"b;			     	/* set switch so we don't print this out  again */
	     end;

	input = "1"b;
	do while (input);
read_track_er:
	     yes_or_no_sw = "0"b;
	     suppress_name_sw = "1"b;
	     call command_query_ (query_ptr, response, "", "Enter:");
	     if ( (response = "quit") | (length(response) = 0) ) then do;
		input = "0"b;
		call prt_bad_trks;			/* print out what we know */
		end;
	     else do;				/* still in the loop */
		erresponse = response;		/* save for error reporting */
		error = read_track_er;		/* set up error label */
		line_pos = 1;			/* start at beginning of input */
		rlen = length(response);		/* initial string length */
		seek_key = form_sk_add ();		/* convert address */
		call rd_sing_trk (seek_key);		/* call reader */
		end;
	     end;

	end read_track;

rd_sing_trk: proc (seek_key);				/* procedure to read headers of single trks */

				/* Makes call to rd_header to physically read track.	*/
				/* If called from the "read_track" option, then full	*/
				/* description of track's status is printed, otherwise,	*/
				/* only errors in track assignment are printed.		*/
				/* If the track is "defa" or "alt", then an attempt is	*/
				/* made to read the track which it points to for		*/
				/* verification. If this verification turns out false, then	*/
				/* user is warned appropriately.			*/

dcl
     seek_key	fixed bin(35),
     temp_seek_key	fixed bin(35),
     match_seek_key	fixed bin(35);


	call rd_header (seek_key);			/* go read the header */
	if code ^= 0
	     then return;				/* if error skip to next trk */

	if trk_header_info.ti = "00"b then do;		/* "good", form message for later */
		call ioa_$rsnnl ("Track ^a is formatted ""good"".", out, outlen, cseek(seek_key) );
		call remove (seek_key);		/* make sure it's out of def list */
		end;

	else if trk_header_info.ti = "11"b then do;	/* "def", form message for later  */
		call ioa_$rsnnl ("Track ^a is formatted ""def"", no alternate assigned.", out, outlen, cseek(seek_key) );
		call sort (seek_key, 0);		/* sort into defective list */
		end;

	else if trk_header_info.ti = "01"b then do;	/* alternate trk */
	     call remove (seek_key);			/* make sure it's out of def. list */
	     error = rd_sing_loop;
	     temp_seek_key = form_address ( (fixed(trk_header_info.r0ccyl)), (fixed(trk_header_info.r0chd)) );
						/* form message for later */
	     call ioa_$rsnnl ("Track ^a is formatted alternate for defective track ^a",
		out, outlen, cseek(seek_key), cseek(temp_seek_key) );
	     call rd_header (temp_seek_key);
	     if code ^= 0 then do;
						/* add to previous message for later */
		call ioa_$rsnnl ("^/Unable to verify original defective track.  ^a.",
		     out, outlen, cseek ( temp_seek_key) );
		go to rd_sing_loop;
		end;
						/* match defective and its assigned alt */
	     match_seek_key = form_address ( (fixed(trk_header_info.r0ccyl)), (fixed(trk_header_info.r0chd)) );
	     if match_seek_key ^= seek_key then do;	/* shouldn't be this way !! */
		call ioa_ ( "^/ERROR: Assignment mismatch.^/^a",
		     "Defective track and its alleged alternate do not agree." );
		call ioa_ ("Track ^a has been assigned as alternate for ^a,",
		     cseek (seek_key), cseek(temp_seek_key) );
		call ioa_ ("while ^a doesn't think ^a is its alternate.",
		     cseek(temp_seek_key), cseek(seek_key) );
		return;				/* return from here */
		end;
	     call sort (temp_seek_key, seek_key);		/* sort in original trk */
	     end;

	else if trk_header_info.ti = "10"b then do;	/* "defa" */
	     call sort (seek_key, 0);			/* sort into defective list */
	     error = rd_sing_loop;
	     temp_seek_key = form_address ( (fixed(trk_header_info.r0ccyl)), (fixed(trk_header_info.r0chd)) );
						/* form message for later */
	     call ioa_$rsnnl ("Track ^a is formatted defective, alternate track assigned - ^a",
		out, outlen, cseek(seek_key), cseek(temp_seek_key) );
	     call rd_header (temp_seek_key);		/* read alternate */
	     if code ^= 0 then do;
						/* add to previously formed message */
		call ioa_$rsnnl ("^/Unable to verify assigned alternate.  ^a",
		     out, outlen, cseek(seek_key) );
		go to rd_sing_loop;
		end;
	     match_seek_key = form_address ( (fixed(trk_header_info.r0ccyl)), (fixed(trk_header_info.r0chd)) );
	     if match_seek_key ^= seek_key then do;	/* this shouldn't happen */
		call ioa_ ( "ERROR: Assignment mismatch. Defective track and its assigned alternate do not match." );
		call ioa_ ("Track ^a has been formatted as defective with ^a as its assigned alternate.",
		     cseek(seek_key), cseek(temp_seek_key) );
		call ioa_ ("while ^a doesn't think its the alternate for ^a",
		     cseek(temp_seek_key), cseek(seek_key) );
		call ioa_ ("This is a serious discrepency and must be fixed before using disk.");
		return;				/* return from here */
		end;
	     call remove (seek_key);			/* we've already put it in without its alt , so */
	     call sort (seek_key, temp_seek_key);	/* sort in def and it's alt */
	     end;
rd_sing_loop:
	if Option = "read_track"			/* if we're in verbose mode, then */
	     then call ioa_ ("^a", out);		/* print out something */
	return;

	end rd_sing_trk;

format_pack: proc;					/* read pack and format pack subsystems */

				/* Forms seek address for entire pack then calls		*/
				/* format_trk for actual formating. If the "-nodef"	*/
				/* or "-hbypass" control argument was given, then previous	*/
				/* track info is ignored. Otherwise, the track is		*/
				/* first read and if "def", "defa", or "alt", then its	*/
				/* previous info is retained.				*/

	if (fmt_good | bypass) then do;		/* warn user */
	     call ioa_ ("^/Warning:  The ""-nodef"" and/or ""-hbypass"" control argument being specified,");
	     call ioa_ ("^-previous bad track information will be ignored.");
	     end;

	call ioa_ ("Begin ""format_pack"" operation");
						/* since this operation takes a long time */
						/* establish pi handler to say something  */
	on program_interrupt			/* useful if user gets bored.        */
	     call ioa_ ( "Processing ^a", cseek (seek_key) );

	if bypass
	     then fmt_info.hz = "00"b;		/* set up header bypass switch */
	     else fmt_info.hz = "01"b;
	FORMAT_INFO.bad_trk_count = 0;		/* initialize bad track counter */

	do seek_key = bounds.low to bounds.high - sect_per_track by sect_per_track;
	     fmt_info.ti = "00"b;			/* initially set ti bits for good trk */
	     fmt_info.alt_def_cyl = 0;		/* zap alt information */
	     fmt_info.alt_def_hd = 0;
	     if ^( bypass | fmt_good ) then do;		/* if we're not ignoring previous info */
		call rd_header (seek_key);		/* rd track header */
		if code ^= 0
		     then go to format_pack_er1;	 /* skip read on error, but try write */
		if trk_header_info.ti ^= "00"b then do;
		     fmt_info.ti = trk_header_info.ti;
		     fmt_info.alt_def_cyl = fixed(trk_header_info.r0ccyl);
		     fmt_info.alt_def_hd = fixed(trk_header_info.r0chd);
		     if trk_header_info.ti ^= "01"b	/* don't sort in "alt"'s */
			then call sort (seek_key, 0);		/* initially sort in as "def" */
		     if trk_header_info.ti = "10"b then do;	/* if "defa", then get alt */
			call remove (seek_key);
			call rd_sing_trk (seek_key);		/* this verifies, plus sorts in addr */
			end;
		     end;
		end;
format_pack_er1:
	     call format_trk (seek_key);		/* go format */
	     if code ^= 0
		then call com_err_ (0, proc_name, "Skipping to next track.");
	     end;
	revert program_interrupt;
						/* if we got this far then we've got the */
	total_bad_track_list = "1"b;			/* total bad track list figured out.     */
						/* if we had any bad tracks  print them out */
	call prt_bad_trks;
	return;
	end format_pack;

format_track: proc;				/* format_track subsystem			*/
					/* Queries user for cyl/head and status of track.	*/
					/* Calls fmt_sing_trk to do the actual formatting.*/
dcl  info bit(2) aligned;

	if (fmt_good | bypass) then do;		/* warn user */
	     call ioa_ ("^/Warning:  The ""-nodef"" and/or ""-hbypass"" control argument being specified,");
	     call ioa_ ("^-previous bad track information will be ignored.");
	     end;

	if ^fstsw then do;				/* print out instructions one time */
	     call ioa_ ("Enter tracks to be formatted as:^/  ""ccc,hh,good"" - for a good track");
	     call ioa_ ("  ""ccc,hh,def""  - for a defective track with no alternate assigned");
	     call ioa_ ("  ""ccc,hh,defa"" - for a defective track, alternate assigned");
	     call ioa_ ("Terminate query by typing ""quit"".");
	     fstsw = "1"b;				/* set switch so we don't print this out again */
	     end;

	input = "1"b;				/* make sure we go thru loop at least once */
	if bypass
	     then fmt_info.hz = "00"b;		/* set up header bypass switch */
	     else fmt_info.hz = "01"b;

	     do while (input);
fmt_loop_er1:					/* error label */
		yes_or_no_sw = "0"b;
		suppress_name_sw = "1"b;
		call command_query_ (query_ptr, response, "", "Enter:");
		if ( (response = "quit" ) | ( length (response) = 0 ) ) then do;
		     input = "0"b;			/* terminate query */
		     call prt_bad_trks;		/* print out the bad trk list */
		     end;
		else do;
		     erresponse = response;		/* save reponse for error reporting */
		     line_pos = 1;			/* start at the beginning of input */
		     rlen = length (response);	/* set up initial string length */
		     error = fmt_loop_er1;		/* set up error return label */
		     seek_key = form_sk_add ();	/* convert address */
		     pstring = parse ();		/* get type of format */

		     if pstring = "good"		/* check out action */
			then info = "00"b;		/* and set appropriate bit */
		     else if pstring = "defa"
			then info = "10"b;
		     else if pstring = "def"
			then info = "11"b;
		     else do;			/* none of the above ?? */
			call ioa_ ("Error in input parameters - ""^a"", please reenter.", erresponse );
			go to fmt_loop_er1;
			end;
		     call fmt_sing_trk(seek_key, info);	/* make call to fmt routine */
		     end;
fmt_sing_loop:
		end;
	end format_track;

fmt_sing_trk: proc ( seek_key, info );			/* procedure to format single tracks */

	/*  .................................................................................... 	*/
	/*									*/
	/*  The heart of the formatting routine.  Called by format_track subsystem.		*/
	/*  Rules:								*/
	/*     1) If the track is to be formatted as "good":				*/
	/*	If currently "good" or "def", then re-format it.				*/
	/*	If currently "defa", then re-format this track and its alternate as well.	*/
	/*	If currently "alt",  then don't re-format. User must re-format original first.	*/
	/*     2) If the track is to formatted as "def":					*/
	/*	If currently "good", or "def", then re-format it.				*/
	/*	If currently "defa", then user must re-format track as "good" first.		*/
	/*	If currently "alt",  then user must re-format original track first.		*/
	/*     3) If track is to formatted as "defa":					*/
	/*	If currently "good" or "def", then re-format and assign alternate.		*/
	/*	If currently "defa" or "alt", then report state and return.			*/
	/*     4) Tracks within the ALT partition may not be formatted as "defa".		*/
	/*     5) The T & D cylinder may be formatted with this command for test purposes, or	*/
	/*	for curiosity. However, it's presence is not mentioned when the cylinder	*/
	/*	range is listed, nor are these tracks used as possible alternate tracks.	*/
	/*	Those more informed will know what it's for.				*/
	/*  .................................................................................... 	*/

dcl
     seek_key	fixed bin(35),			/* input seek address */
     info		bit(2) aligned,			/* bits corresponding to format request */
     temp_seek_key	fixed bin(35),			/* temporary seek address */
     match_seek_key	fixed bin(35);			/* used for matching */

	code = 0;
	fmt_info.alt_def_cyl = 0;			/* initialize for now	*/
	fmt_info.alt_def_hd  = 0;
/* +++++++++++ */
/* good & def  */
/* +++++++++++ */
	if ( (info = "00"b) | (info = "11"b) ) then do;	/* same code for "good" & "def" */
	     call rd_header(seek_key);		/* read what's already there */
	     if code = 0 then do;			/* if we can read what's there then lets look at it */
						/* if we couldn't read, then branch to format section */
		if trk_header_info.ti = "00"b		/* if already "good", say nothing but proceed to */
		     then;			/* re-format it anyway   */

		else if trk_header_info.ti = "11"b	/* if previously "def" then do nothing proceed to */
		     then;			/* to format it anyway */

		else if trk_header_info.ti = "10"b then do;/* if previously "defa" then check it out */
		     error = fmt_sing_er2;		/* set up return label */
		     temp_seek_key = form_address( (fixed(trk_header_info.r0ccyl)), (fixed(trk_header_info.r0chd)) );
		     call rd_header(temp_seek_key);	/* read assigned alt to check */
		     if code ^= 0			/* got error reading, so skip this */
			then go to fmt_sing_er2;
		     if trk_header_info.ti = "01"b then do;	/* yup, was assigned alt trk */
			error = fmt_sing_er2;		/* if not valid address then ignore */
			match_seek_key = form_address ( (fixed(trk_header_info.r0ccyl)), (fixed(trk_header_info.r0chd)) );
							/* try for match against original address */
			if seek_key = match_seek_key then do;	/* MATCH, therefore must decide */
							/* if trying to format as "def", then force */
							/* user to re-format track "good" first */
			     if info = "11"b then do;
				call remove ( seek_key );
				call sort (seek_key, temp_seek_key);
				call ioa_ ("This track is currently formatted ""defa"" with ^a assigned alternate.",
				     cseek(temp_seek_key) );
				call ioa_ ("Track ^a must be re-formatted as ""good"" before formatting as ""def"".",
				     cseek(seek_key) );
				call ioa_ ("Track has not been modified." );
				return;
				end;

			     fmt_info.ti = "00"b;			/* set up for "good" */
			     call format_trk (temp_seek_key);		/* format alt as good */
			     if code ^= 0
				then go to fmt_sing_er2;
			     call remove (seek_key);
			     call ioa_ ("Previously assigned alternate track ^a formatted as ""good"".",
				cseek(temp_seek_key) );
			     end;
			end;
		     end;
		else if trk_header_info.ti = "01"b then do;	/* if previously "alt" then check it out */
		     error = fmt_sing_er2;			/* set up return label */
		     temp_seek_key = form_address ( (fixed(trk_header_info.r0ccyl)), (fixed(trk_header_info.r0chd)) );
		     call rd_header(temp_seek_key);		/* read original track to check */
		     if code ^= 0				/* got error reading, so skip this */
			then go to fmt_sing_er2;		/* allow user to format track */
		     if trk_header_info.ti = "10"b then do;	/* yup, it's really "defa" */
			match_seek_key = form_address ( (fixed(trk_header_info.r0ccyl)), (fixed(trk_header_info.r0chd)) );
							/* try for match against original address */
			if seek_key = match_seek_key then do;	/* MATCH */
							/* the user  must format orig. trk not this alt */
			     call sort (temp_seek_key, seek_key);	/* sort in original trk */
			     call ioa_ ("This track is formatted as the alternate for ^a.", cseek(temp_seek_key));
			     call ioa_ ("Original track ^a must be re-formatted first.", cseek(temp_seek_key) );
			     call ioa_ ("Track has not been modified." );
			     return;
			     end;
			end;
		     end;
		end;
fmt_sing_er2:
	     fmt_info.ti = info;			/* set ti bits to appropriate value */
	     call remove (seek_key);			/* remove this trk from the bad trk list */
	     call format_trk (seek_key);		/* format track */
	     if code ^= 0 then do;
		call ioa_ ("Unable to format requested track.");
		call ioa_ ("Track ^a not modified.", cseek(seek_key) );
		return;
		end;
	     if info = "00"b			/* spout appropriate message */
		then call ioa_ ("Track ^a formatted ""good"".", cseek(seek_key) );
		else do;
		     call ioa_ ("Track ^a formatted ""def"".", cseek(seek_key) );
		     call sort (seek_key, 0);
		     end;
	     end;

/* ++++ */
/* defa */
/* ++++ */
	else if info = "10"b then do;			/* "defa" */
	     if seek_key ^< altb then do;		/* check to make sure we aren't assigning an alternate */
						/* for an alternate. It just doesn't seem right */
		call ioa_ ("This track is within the ""alt"" partition. These tracks may not be formatted as ""defa""." );
		call ioa_ ("Track has not been modified."  );
		return;
		end;
	     call rd_header (seek_key);		/* first, read what's already there */
	     if code = 0 then do;			/* if no error, then check it out */
		if trk_header_info.ti = "00"b		/* if "good", then do nothing here */
		     then;			/* but re-format it later on */

		else if trk_header_info.ti = "11"b	/* if "def", then do nothing */
		     then;			/* but re-format it later */

		else if trk_header_info.ti = "10"b then do;	/* it's already "defa" !! */
							/* since it's already "defa", we don't want */
							/* re-format it if it's a valid assignment. */
		     temp_seek_key = form_address ( (fixed(trk_header_info.r0ccyl)), (fixed(trk_header_info.r0chd)) );
		     call rd_header (temp_seek_key);
		     if code ^= 0
			then go to fmt_sing_er3;		/* ignore what it might have been */
		     if trk_header_info.ti = "01"b then do;	/* it checks so far */
							/* let's print out what we're up to */
			call ioa_ ("This track is already formatted ""defa"" with ^a assigned alternate.",
			     cseek (temp_seek_key) );
			call ioa_ ("Track has not been modified.");
			return;
			end;
		     end;
		end;
fmt_sing_er3:
						/* find first free alternate trk */
	     trk_header_info.ti = "01"b;		/* make sure we go thru loop once */
	     do alt_add = altb to sect_per_dev by sect_per_track while (trk_header_info.ti = "01"b);
		call rd_header (alt_add);
		if code ^= 0
		     then return;
		end;

	     alt_add = alt_add - sect_per_track;	/* subtract 1 track's worth (do loop tells 1 too many */

						/* important, check for legal address. (note >= */
	     if ( alt_add >= sect_per_dev ) then do;
		call ioa_ ("All alternates have been assigned, cannot format track as ""defa""." );
		call ioa_ ("Track ^a has not been modified.", cseek(seek_key) );
		return;
		end;

						/* format alternate trk first */

	     fmt_info.ti = "01"b;
	     fmt_info.alt_def_cyl = rcyl(seek_key);
	     fmt_info.alt_def_hd = rhead(seek_key);
	     call format_trk (alt_add);		/* format the alternate trk */
	     if code ^= 0 then do;			/* didn't work */
		call ioa_ ("Unable to assign alternate. Requested track not formatted." );
		return;				/* skip track on error */
		end;
	     call remove (alt_add);			/* remove alternate trk from defective list if present */

	     fmt_info.ti = "10"b;			/* set ti bits for def alt assigned */
	     fmt_info.alt_def_cyl = rcyl(alt_add);
	     fmt_info.alt_def_hd  = rhead(alt_add);
	     call format_trk (seek_key);		/* format requested track */
	     if code ^= 0 then do;			/* oh oh... */
		call ioa_ ("Unable to format requested track. Track has not been modified.");
		fmt_info.ti = "00"b;		/* set ti bits to "good" */
		fmt_info.alt_def_cyl = 0;
		fmt_info.alt_def_hd  = 0;
		call format_trk (alt_add);		 /* re-assign the alt as "good" */
		if code ^= 0 then do;		/* whoops, blew the alternate... */
		     call ioa_ ("Unable to re-assign the alternate track as ""good"".");
		     return;
		     end;
		return;
		end;
	     call sort (seek_key, alt_add);		/* sort in the defective address */
	     call ioa_ ("Track ^a formatted ""defa"" with alternate track ^a assigned.",
		cseek(seek_key), cseek (alt_add) );
	     end;


	end fmt_sing_trk;

rd_header: proc (sk_add);
						/* procedure to execute the rd_trk_header control */
						/* order and do appropriate error processing */
dcl  sk_add fixed bin (35);				/* IN  = seek address */

rd_header_er:
	     call iox_$seek_key (iocb_ptr, asc (sk_add), rec_len, code);
	     call iox_$control (iocb_ptr, "rd_trk_header", addr (trk_header_info), code);
	     if code ^= 0 then do;
		call com_err_ (code, proc_name);	/* report error */
		call com_err_ (0, "", "^-While executing a rd_trk_header command on ^a",
		     cseek (sk_add));
		if interactive then do;
		     yes_or_no_sw = "1"b;
		     suppress_name_sw = "0"b;
		     call command_query_ (query_ptr, answer, "", "Do you wish to try again?");
		     if answer = "yes" then go to rd_header_er;
		     else return;			/* let caller decide */
		     end;
		end;

	end rd_header;

format_trk: proc (sk_add);
						/* procedure to execute the format_trk order */
						/* and do appropriate error processing */
dcl  sk_add fixed bin (35);				/* IN  = seek address */
dcl  save_hz bit (2) unaligned;
dcl  er_sw bit (1) unaligned;

	     er_sw = "0"b;				/* reset error switch if set */
format_trk_er:
	     call iox_$seek_key (iocb_ptr, asc (sk_add), rec_len, code);
	     call iox_$control (iocb_ptr, "format_trk", addr (fmt_info), code);
	     if code ^= 0 then do;
		call com_err_ (code, proc_name);	/* report error */
		call com_err_ (0, proc_name, "while executing a format_trk cmd on ^a",
		     cseek (sk_add));
		if interactive then do;
		     yes_or_no_sw = "1"b;
		     suppress_name_sw = "0"b;
		     call command_query_ (query_ptr, answer, "", "Do you wish to try again?");
		     if answer = "yes" then do;
			if ^er_sw then do;		/* do not wipe out orig hz bits */
			     save_hz = fmt_info.hz;	/* save users header bypass switch */
			     fmt_info.hz = "00"b;	/* set them for header bypass */
			     er_sw = "1"b;		/* set er_sw */
			     end;
			go to format_trk_er;
			end;
		     else return;			/* let caller decide */
		     end;
		end;

	     if er_sw
		then fmt_info.hz = save_hz;		/* if we had an error restore org. bypass sw */

	end format_trk;

mount:	proc;					/* procedure to attach a disk pack */

	if write_attach
	     then mode = 13;			/* Mode = direct update */
	     else mode = 11;			/* for reading only. *
						/* dev_type previously determined */
	     if system then do;			/* check users access to rcp_sys_ */
		call hcs_$initiate (">system_library_1", "rcp_sys_", "", 0, 0, lsp, code);
		if lsp ^= null then do;		/* if can be initiated */
		     call hcs_$fs_get_mode (lsp, rs_mode, code); /* check caller's access */
		     if code = 0
			then if (bit (rs_mode) & execute )
			     then priv = "1"b;
		     end;
		end;
						/* build attach description */

	     call ioa_$rsnnl ("rdisk_ ^a ^a", adescrip, i, dev_type, vol_id); /* set up constants */
	     if write_attach				/* if we have to write on disk */
		then call ioa_$rsnnl ("^a  -write", adescrip, i, adescrip );
	     if priv
		then call ioa_$rsnnl ("^a -sys", adescrip, i, adescrip); /* if user has system priv. */
	     call ioa_$rsnnl ("^a -size 4096", adescrip, i, adescrip);

						/* attach rdisk_ */
	     if write_attach
		then call ioa_ ("Mounting disk ^a for writing", vol_id);
		else call ioa_ ("Mounting disk ^a for reading", vol_id);
	     call iox_$attach_name ("fmt_io_switch", iocb_ptr, adescrip, null, code);
	     if code ^= 0 then do;
		if code ^= error_table_$not_detached then do;
		     call com_err_ ( code, proc_name, "Attempting to attach disk." );
		     return;
		     end;
		not_attached_by_me = "1"b;		/* remember that we didn't perform the attachment */
		end;

	     call iox_$open (iocb_ptr, mode, "0"b, code);	 /* open  the i/o switch */
	     if code ^= 0 then do;
		call com_err_ ( code, proc_name, "Attempting to open disk I/O switch." );
		return;
		end;
	     open = "1"b;				/* indicate we are now attached to a device */
	     call iox_$modes (iocb_ptr, "raw", "", code); /* put dim in the raw mode */
	     call iox_$control (iocb_ptr, "getbounds", addr (bounds), code); /* get sector bounds of pack */
	     call iox_$control (iocb_ptr, "device_info", addr (dev_char_table), code); /*  and device char */

	     if not_attached_by_me
		then call ioa_ ("Using pack ^a already mounted on ^a ^a.", vol_id, subsystem_name, device_name  );
		else call ioa_ ("Disk pack ^a mounted on ^a ^a", vol_id, subsystem_name, device_name);

	     legal_cyl = divide (bounds.high, sect_per_cyl, 17, 0) - 1; /* set up input limits for user */
	     legal_hd = divide (sect_per_cyl, sect_per_track, 17, 0) - 1;
	     sect_per_rec = 1024 / sect_size;
	     use_sect_per_cyl = divide (sect_per_cyl, sect_per_rec, 17, 0) * sect_per_rec;
	     unuse_sect_per_cyl = sect_per_cyl - use_sect_per_cyl;
	     altb = sect_per_dev - num_alt_sect;	/* compute beginning of alternate track area */

	areap = get_system_free_area_();
	max_bad_trks = (legal_cyl+1)*(legal_hd+1);
	allocate FORMAT_INFO in (area) set (formatp);
	FORMAT_INFO.bad_trk_count = 0;

	if Option ^= "read_label"			/* not if that's what we're doing anyway */
	     then call read_pack_label;		/* let's see what it is */
	code = 0;					/* if we got this far, it's mounted */

	end mount;


release:	proc;					/* procedure to close and detach the disk pack.  */

	RECURSE = "0"b;				/* reset recursion-checking switch */
	     if ^open
		then return;
	     call iox_$close        (iocb_ptr, code);	/* close the i/o switch */
	     open = "0"b;				/* reset open switch */

	     if formatp ^= null then do;
		free FORMAT_INFO in (area);
		formatp = null;
		end;
	     if not_attached_by_me			/* don't detach if previously attached */
		then return;
	     call iox_$detach_iocb  (iocb_ptr, code);	/* detach the drive */

	end release;

						/* prt_bad_trks - procedure to print out the defective */
						/* trk, bad Multics record info contained in the       */
						/* temporary bad_trk_segment.  It does not print       */
						/* tracks previously formatted.                        */
prt_bad_trks: proc;

dcl (i, j, out_len) fixed bin;
dcl  out_str char (100);

	     if total_bad_track_list			/* if we know where the bad tracks are... */
		then call ioa_ ("^/Summary of bad tracks for entire volume ""^a"".", vol_id);
		else call ioa_ ("^/Summary of bad tracks formatted this session." );

	     if bad_trk_count ^= 0 then do;		/* found some bad tracks */
		call ioa_ ("^/Defective tracks    Bad Multics records^5x(alternate, if ""defa"")^/");
		do i = 1 to bad_trk_count;		/* print out the bad trks */
		     call ioa_$rsnnl ("^a", out_str, out_len, cseek ( bad_trks(i).track_addr));
		     do j = 0 to bad_trks(i).bad_rcd_cnt - 1;
			call ioa_$rsnnl ("^a  ^6d", out_str, out_len, out_str,
			     phy_mul ( bad_trks(i).track_addr + (j*sect_per_rec)));
			end;
		     if bad_trks(i).alt_addr ^= 0
			then if bad_trks(i).bad_rcd_cnt = 3	/* check for proper spacing...  */
			     then call ioa_$rsnnl ("^a^4x^a", out_str, out_len, out_str, cseek(bad_trks(i).alt_addr) );
			     else call ioa_$rsnnl ("^a^12x^a", out_str, out_len, out_str, cseek(bad_trks(i).alt_addr) );
		     call ioa_ ("^a", out_str);
		     end;
		call ioa_ ("");
		end;

		else call ioa_ ("No defective tracks found.");

	end prt_bad_trks;

cseek: proc (key) returns (char(18));			/* procedure to convert binary seek address */
						/* to ascii cyl and head number */
dcl  key fixed bin (35);				/* IN  = seek address */
dcl (cyl, head, len) fixed bin;
dcl  chstr char (18);

	     if key < sect_per_cyl
		then cyl = 0;
		else cyl = divide ( key, sect_per_cyl, 17, 0 );

	     len = mod (key, sect_per_cyl);
	     if len <= 0
		then head = 0;
		else head = divide ( len, sect_per_track, 17, 0 );

	     call ioa_$rsnnl ("cyl ^4d, head ^2d", chstr, len, cyl, head);
	     return ( chstr );

	end cseek;

phy_mul: proc (key) returns (fixed bin);		/* entry to return Multics record number */
						/* for a given seek address */
dcl  key fixed bin (35),				/* IN  = seek address */
     mrecord fixed bin;				/* OUT = Multics record number */

	     mrecord = divide ( key, sect_per_cyl, 17, 0 );
	     return ( divide ( key - mrecord, 16, 17, 0 ) );

	end phy_mul;

rhead: proc (key) returns (fixed bin);			/* entry to return head number in binary */

dcl  key fixed bin (35),				/* IN  = seek address */
     head fixed bin,				/* OUT = head number */
     len fixed bin;

	     len = mod (key, sect_per_cyl);

	     if len <= 0
		then head = 0;
		else head = divide ( len, sect_per_track, 17, 0 );
	     return ( head );			/* user only wants head number */

	     end rhead;

rcyl: proc (key) returns (fixed bin);			/* entry to return cyl number */

dcl  key		fixed bin (35);			/* IN  = seek address */
						/* RETURN = cyl number */

	if key < sect_per_cyl
	     then return (0);
	     else return ( (divide (key, sect_per_cyl, 17, 0) )  );

	end rcyl;

asc:	proc (key) returns (char (12) varying);
						/* internal procedure to convert fixed binary */
						/* seek address into zero filled char. string for rdisk_ */
dcl  key fixed bin (35);				/* IN  = seek address */
dcl  seek_pic picture "99999999";
dcl  v_string char (12) varying;

	     seek_pic = key;
	     v_string = seek_pic;
	     return (v_string);

	end asc;

mul_phy:	proc (r) returns (fixed bin (35));
						/* procedure to convert a Multics */
						/* record number to a binary seek address */
dcl  r fixed bin (23) unaligned;			/* IN  = Multics record number */
dcl  s fixed bin (35);				/* OUT = seek address */

	     s = r * sect_per_rec;
	     s = divide (s, use_sect_per_cyl, 17, 0) * unuse_sect_per_cyl + s;
	     return (s);

	end mul_phy;

form_sk_add: proc returns (fixed bin (35));
						/* procedure to pick up input parameters for cyl and head */
						/* and convert them to binary seek address */
dcl (int_sa, int_sb) fixed bin (37);
	     pstring = parse ();			/* get cylinder # */
	     cyl = cv_dec_check_ (pstring, code);
	     if code ^= 0 then do;
form_sk_add_er1:
		call ioa_ ("Error in input parameters - ""^a"", please reenter", erresponse);
		go to error;			/* return to label varable */
	     end;
	     if ((cyl > legal_cyl) | (cyl < 0)) then do;	/* illegal cyl number */
						/* pretend T&D cyl doesn't exist */
		call ioa_ ("Cylinder ^d illegal, cylinder range for this device is 0 to ^d", cyl, legal_cyl);
		go to error;
	     end;
	     pstring = parse ();			/* get head # */
	     head = cv_dec_check_ (pstring, code);
	     if code ^= 0 then go to form_sk_add_er1;
	     if ((head > legal_hd) | (head < 0)) then do;	/* illegal head number */
		call ioa_ ("Head ^d illegal, head range for this device is 0 to ^d", head, legal_hd);
		go to error;
	     end;
	     int_sa = cyl * sect_per_cyl;		/* compute raw cylinder number */
	     if int_sa > bounds.high then
		code = 1;				/* cyl # > # cylinders per device */
	     int_sb = head * sect_per_track;		/* compute raw head address */
	     if int_sb > sect_per_cyl then
		code = 2;				/* head # > heads per device */
	     int_sa = int_sa + int_sb;		/* compute full address */
	     if int_sa > bounds.high then
		code = 3;				/* total address > device capicity */
	     if code ^= 0 then go to form_sk_add_er1;
	     return (int_sa);
	end form_sk_add;

parse:	proc returns (char (*));
						/* procedure to parse input line and return individual args */
dcl  i fixed bin;
dcl  string char (10) varying;
	if rlen ^> 0 then do;			/* we're out of business */
	     string = "NOT";
	     return ( string );
	end;
	i = index (substr (response, line_pos, rlen), ",");
	if i = 0 then do;				/* either blank or last parameter */
	     if substr ( response, line_pos, rlen) ^= ""	/* last one...	*/
		then string = substr ( response, line_pos, rlen);
		else string = "NOT";
	     rlen = 0;
	     return ( string );
	end;
	string = substr (response, line_pos, i-1);
	line_pos = line_pos + i;
	rlen = rlen - i;
	return ( string );
	end parse;

form_address: proc ( cyl, head) returns (fixed bin (35));

dcl
     head		fixed bin,
     cyl		fixed bin;
dcl (int_sa, int_sb) fixed bin (37);

	if cyl > legal_cyl then do;			/* cylinder number too big */
	     call ioa_ ("Cylinder ^d too large, cylinder range for this device is 0 to ^d", cyl, legal_cyl);
	     go to error;
	     end;
	if head > legal_hd then do;			/* head number to big */
	     call ioa_ ("Head ^d too large, head range for this device is 0 to ^d", head, legal_hd);
	     go to error;
	     end;
	int_sa = cyl * sect_per_cyl;			/* compute raw cylinder number */
	if int_sa > bounds.high then
	     code = 1;				/* cyl # > # cylinders per device */
	int_sb = head * sect_per_track;		/* compute raw head address */
	if int_sb > sect_per_cyl then
	     code = 2;		     		/* head # > heads per device */
	int_sa = int_sa + int_sb;			/* compute full address */
	if int_sa > bounds.high then
	     code = 3;				/* total address > device capicity */
	if code = 0
	     then return (int_sa);
	     else go to error;


	end form_address;


sort:	proc (key, alt_key);
						/* procedure to sort a new defective address into the bad_trk */
						/* list in ascending order */
dcl  key fixed bin (35);				/* IN  = seek address */
dcl  alt_key fixed bin(35);				/* alt addr if defa */
dcl (i, j) fixed bin;

/* first lets see if we can save ourselves some time and put the bad trk at the end of the list */

	     if bad_trk_count = 0 | key > bad_trks.track_addr (bad_trk_count) then do;
		bad_trk_count = bad_trk_count + 1;
		i, j = bad_trk_count;		/* set constants */
		go to set_new_add;			/* go store the new defective address */
	     end;

	     j = 0;				/* we must sort the new def. address in */
	     do i = 1 to bad_trk_count while (j = 0);
		if i > max_bad_trks then do;
		     call com_err_ ( 0, proc_name, "There are currently ^d bad track entries.^/^a",
			max_bad_trks, "Cannot add more to list." );
		     j = 1;				/* get out of loop */
		     end;
		else if key = FORMAT_INFO.bad_trks(i).track_addr then do; 	/* already exists in list */
		     if rhead ( key ) = legal_hd	/* if last trk on cyl maybe only part of trk used */
			then FORMAT_INFO.bad_trks(i).bad_rcd_cnt = divide ( sect_per_track, sect_per_rec, 17, 0 );
			else FORMAT_INFO.bad_trks(i).bad_rcd_cnt = ceil ( sect_per_track / sect_per_rec );
		     j = 1;			/* let's get out of the loop */
		     end;
		else if key < bad_trks.track_addr (i) then do; /* we found the right slot */
		     bad_trk_count = bad_trk_count + 1; /* increment the counter */
		     do j = bad_trk_count to i + 1 by -1; /* move all the rest of the def trks down one slot */
			FORMAT_INFO.bad_trks(j).track_addr = FORMAT_INFO.bad_trks(j-1).track_addr;
			FORMAT_INFO.bad_trks(j).alt_addr = FORMAT_INFO.bad_trks(j-1).alt_addr;
			FORMAT_INFO.bad_trks(j).bad_rcd_cnt = FORMAT_INFO.bad_trks(j-1).bad_rcd_cnt;
			end;
set_new_add:
		     bad_trks(i).track_addr = key;
		     bad_trks(i).alt_addr = alt_key;
		     if rhead (key) = legal_hd	/* if last trk on cyl maybe only part of trk used */
			then FORMAT_INFO.bad_trks(i).bad_rcd_cnt = divide (sect_per_track, sect_per_rec, 17, 0);
			else FORMAT_INFO.bad_trks(i).bad_rcd_cnt = ceil (sect_per_track / sect_per_rec);
		     end;
		end;
	     return;

	end sort;

remove:	proc (key);
						/* procedure to remove a track from the bad_trk list */
dcl  key fixed bin (35);				/* IN  = seek address */
dcl (i, j) fixed bin;

	     if bad_trk_count = 0
		then return;			/* can't remove someting that isn't there */
	     j = 0;
	     do i = 1 to bad_trk_count while (j = 0);
		if key = bad_trks.track_addr(i) then do;	/* found the trk now remove it from the list */
		     do j = i to bad_trk_count;	/* and take out the blank space */
			bad_trks(j).track_addr = bad_trks(j+1).track_addr;
			bad_trks(j).alt_addr = bad_trks(j+1).alt_addr;
			bad_trks(j).bad_rcd_cnt = bad_trks(j+1).bad_rcd_cnt;
			end;
		     bad_trk_count = bad_trk_count - 1; /* reduce the counter */
		     end;
		end;

	end remove;


read_pack_label: proc;				/* procedure for reading the Multics label record */

dcl  ALPHANUM char (71) init ("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123457189.?+_-()! ");

	call read_multics_label;
	if code ^= 0 then do;			/* must produce our own error messages */
	     if Option = "read_label"
		then call com_err_ (code, proc_name,
		     "^/While executing a read command on ""Multics label record"".");
	     return;
	     end;

	call ioa_ ("^/Multics label record information:");

	if labelp -> label.Multics ^= Multics_ID_String then do;
	     if ( verify ( labelp->label.pv_name, ALPHANUM ) ) = 0
		then if labelp->label.pv_name ^= " "
		     then call ioa_ ( "^2xphysical volume:^-^a", labelp->label.pv_name );
		     else call ioa_ ( "^2xphysical volume:^-^a", "(blank)" );
		else call ioa_ ( "cannot decipher physical volume name." );
	     if ( verify ( labelp->label.lv_name, ALPHANUM ) ) = 0
		then if labelp->label.lv_name = " "
		     then call ioa_ ( "^2xlogical volume:^-^a", "(blank)" );
		     else call ioa_ ( "^2xlogical volume:^-^a", labelp->label.lv_name );
		else call ioa_ ( "cannot decipher logical volume name." );
	     call ioa_ ("volume is not a ""Multics Storage System Volume""" );
	     multics_storage_system_volume = "0"b;	/*  set this switch (by default it's OFF) */
	     end;

	else do;
	     multics_storage_system_volume = "1"b;	/* make sure it's ON */
	     call ioa_ ( "^2xphysical volume:^-^a", labelp -> label.pv_name );
	     call ioa_ ( "^2xlogical volume:^-^a", labelp -> label.lv_name );
	     call date_time_ ( labelp -> label.time_registered, ltime );
	     call ioa_ ( "^2xregistered on:^-^a", ltime );
	     if labelp->label.nparts > 0 then do;	/* Aha, partitions present.  */
		call ioa_ ( "^2x# partitions:^-^d", labelp -> label.nparts );
		if labelp->label.nparts > 47		/* legal # of partitions MUST be < 48 */
		     then call ioa_ ("^5x(Number partitions too great!)");
		     else do j = 1 to labelp->label.nparts;
			call ioa_ ( "      ^4a^-from ^d for ^d", labelp -> label.parts(j).part,
			     labelp -> label.parts(j).frec, labelp -> label. parts(j).nrec );
			if labelp->label.parts(j).part = "alt"	/* look for "alt" partition */
			     then alt_partition_present = "1"b;
		     end;
		end;
	     else do;
		alt_partition_present = "0"b;
						/* shouldn't allow user to format_tracks on a valid */
						/* Multics pack which has NO alt partition */
		call ioa_ ("no partitions specified in label." );
		end;
	     end;

	call ioa_ ("legal cylinders:^-0:^d", legal_cyl);
	call ioa_ ("legal heads:^-0:^d^/", legal_hd );

	end read_pack_label;

						/* procedure to actually read the Multics label record */
read_multics_label: proc;

	labelp = addr (MULTICS_LABEL);
	seek_key = mul_phy (multics_lab_rec);
	call iox_$seek_key (iocb_ptr, asc (seek_key), rec_len, code);
	call iox_$read_record (iocb_ptr, labelp, 1024 * 4, rec_len, code);
	return;

	end read_multics_label;
     end format_disk_pack;
