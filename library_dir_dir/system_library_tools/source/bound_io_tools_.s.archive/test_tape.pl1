/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(1985-09-09,Farley), approve(1985-09-09,MCR6979),
     audit(1986-02-18,Coppola):
     Support FIPS.
  2) change(2016-01-15,Swenson), approve(2016-01-15,MCR10003):
     Fix to support 4-character time zone abbreviations.
                                                   END HISTORY COMMENTS */
/* Modified 12/20/79 by R.L. Coppola and Paul Farley to add 6250 b.p.i. capability */
/* Modified June 1980 by R.L. Coppola to clean up several bugs and provide detailed status
   reporting and support of MTP610's */

/* Modified Nov 1981 by Rich Coppola to fix bug in compatibility option */

/* Modified Apr 14, 1982 by Rich Coppola to fix bug in test for recursive calls
   probably caused by previous modification. */
/* Modified 7/7/82 BIM to restore arg processing busted by above. */
/* Modified September 1982 by C. Hornig to fix config processing. */
/* Modified October 1982 By Rich Coppola for changes in call to
   analyze_detail_stat_.
   Also removed config processing as that is done in analyze_detail_stat_
   and not needed here.
*/
/* Modified July/Aug. 1983 by Paul Farley to correct the following:
   Usage message (phx14639, phx15524) removed, none required.
   Added the current time to error & info messages.
   Added code to display current parameters after arg parsing (or to show dflt).
   Removed "-retry" arg, made it the default, and removed all code
   that was used when in "no retry" mode. Also if doing IO retry, the data
   alert messages will be only recorded and not printed.
   Fixed bug with data buffer loading when using -compare.
   Also if first drive of -compare string cannot be attached
   then the test will now terminate.
   Added code in interp_xstats to summarize the status list.
   Changed the ext_buffr to be a temp_seg, so that more errors could
   be captured.
   Modified Nov. 1984 by Paul Farley to write two EOFs at the end of a write
   so that the read pass can use this to know when to stop reading.
   Modified July 1985 by Paul Farley for FIPS tape.
*/

/* format: style4,delnl,insnl,ifthenstmt,indnoniterend */
test_tape:
     procedure options (variable);


dcl  (vid, den8, den16, den6250) bit (1),
     program_interrupt condition,
     (write_error, read_error, irrec_write, irrec_read, rd_comp_err) fixed bin,
     cleanup condition,
     track7 bit (1) init ("0"b),
     retry_in_progress bit (1) init ("0"b),
     set_den_sw bit (1) init ("0"b),
     (comment_sw, sys_sw) bit (1) init ("0"b),
     ext_sw bit (1) init ("1"b),
     timer_manager_$sleep entry (fixed bin (71), bit (2)),
     (code, ecode) fixed bin (35) init (0),
     ipc_$create_ev_chn entry (fixed bin (71), fixed bin (35)),
     com_err_ entry options (variable),
     ipc_$block entry (ptr, ptr, fixed bin (35)),
     fail char (100) varying,
     mask bit (36),
     doing char (16) varying init ("mount"),
     dev_name char (32) init (""),
     comment char (55) init (""),
     reel_comment char (64),
     name char (32) init (""),
     (man_ptrn, rand_ptrn) bit (1) init ("0"b),
     (rec_wrt, rec_rd) fixed bin init (0),
     seed fixed bin (35) init (34546657),
     num_ret float bin (27),
     buf_init bit (1) init ("0"b),
     bufarray (1040) bit (36),
     buftemp bit (37440) based (addr (bufarray)),
     rek fixed bin (35) based (addr (bufarray)),
     read_buff bit (37440),
     err_buff (1040) bit (36) based (addr (read_buff)),
     ntimes fixed bin (25),
     det_valid bit (1) aligned,
     ioi_idx fixed bin,
     rsr_data bit (216) unal,
     (at_eot, detected_eof) bit (1) init ("0"b),
     (read_sw, write_sw, rew_sw, clean_up_sw) bit (1) init ("0"b),
     comp_sw bit (1) init ("0"b),
     dev_sw bit (1) init ("0"b),
     dev_array (16) char (32) init ((16) ("")),
     num_drives fixed bin int static init (0),
     comp_lp_ctr fixed bin int static init (0),
     (tdcm_attached, tape_mounted) bit (1) int static init ("0"b),
     nargs fixed bin,
     err_sum_sw bit (1) init ("0"b),
     (argptr, dstat_ptr) ptr,
     arglen fixed bin (21),
     arg_string char (arglen) based (argptr),
     blank_rd fixed bin init (0),
     yy fixed bin,
     temp fixed bin (35),				/* temp for compiler bug */
     (reelid, save_reel) char (9) init (""),
     wait_flag bit (1) init ("0"b),
     (wait, wait_cnt) fixed bin (35) init (0),
     density bit (36),
     att_bffr bit (208) init ("0"b),
     ext_bffr_ptr ptr init (null),
     1 ext_bffr (da_cnt) aligned based (ext_bffr_ptr),
       2 xrec_no fixed bin,
       2 xdoing fixed bin,
       2 iom_status bit (36) aligned,
       2 ext_data bit (208) unal,
     recursive_ fixed bin internal static,
     da_cnt fixed bin init (0),
     1 wait_list aligned,
       2 n fixed bin,
       2 chan (1) fixed bin (71),
     ndc_sw bit (1) init ("0"b),
     codex fixed bin init (0),
     dev_type fixed bin init (0),
     1 message aligned,
       2 chname fixed bin (71),
       2 message fixed bin (71),
       2 sender bit (36),
       2 origin,
         3 (devsignal, ring) bit (18) unaligned,
       2 channel_index fixed bin,
     stat_ptr ptr,
     1 stat_chk aligned based (stat_ptr),
       2 stat_pad1 bit (2) unaligned,
       2 stat_maj bit (4) unaligned,
       2 stat_min bit (6) unaligned,
       2 stat_pad2 bit (24) unaligned,
     i fixed bin (35) init (0),
     (k, l) fixed bin,
     (wrx, rdx) fixed bin init (0),
     (substr, index, addr, baseptr, bin, char, empty, fixed, rel, rtrim, unspec, null, length, string) builtin,
     ioa_ entry options (variable),
     get_temp_segment_ entry (char (*), ptr, fixed bin (35)),
     release_temp_segment_ entry (char (*), ptr, fixed bin (35)),
     error_table_$resource_attached ext fixed bin (35),
     error_table_$multiple_io_attachment fixed bin (35) ext static,
     error_table_$resource_assigned ext fixed bin (35),
     error_table_$resource_unavailable ext fixed bin (35),
     error_table_$inconsistent ext fixed bin (35),
     error_table_$bad_density external fixed bin (35),
     error_table_$noarg external fixed bin (35),
     error_table_$badopt external fixed bin (35),
     random_$uniform entry (fixed bin (35), float bin (27)),
     cu_$arg_count entry (fixed bin, fixed bin (35)),
     cu_$arg_ptr entry (fixed bin, ptr, fixed bin (21), fixed bin (35)),
     cv_oct_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35)),
     cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35)),
     tdcm_$tdcm_attach entry (ptr, fixed bin (35)),
     tdcm_$tdcm_set_signal entry (ptr, fixed bin (35)),
     tdcm_$tdcm_reset_signal entry (ptr, fixed bin (35)),
     tdcm_$tdcm_message entry (ptr, char (*), fixed bin (1), fixed bin (35)),
     tdcm_$tdcm_iocall entry (ptr, fixed bin (35)),
     tdcm_$tdcm_detach entry (ptr, fixed bin (35));

dcl  rec_cap char (16) var,
     dev_spd char (8) var;


dcl  rec_tbl (0:11) char (16) var static options (constant)
	init ("1600", "200/556/800/1600", " ", " ", "200/556/800", "200/556", " ", " ", "800/1600", "556/800", "6250",
	"1600/6250");

dcl  spd_tbl (0:3) char (8) static options (constant) init (" 75 ips ", "        ", "125 ips ", "200 ips ");

dcl  dens_ (4) fixed bin static options (constant) init (6250, 1600, 0, 800);

dcl  ioi_$get_detailed_status entry (fixed bin, bit (1) aligned, bit (*), fixed bin (35));
dcl  analyze_detail_stat_ entry (char (*), bit (36) aligned, bit (*) unal, ptr, fixed bin (35));
dcl  analyze_detail_stat_$rsnnl entry (char (*), bit (36) aligned, bit (*) unal, char (*) var, bit (1), fixed bin (35));
dcl  analyze_device_stat_$rsnnl entry (char (*) var, ptr, bit (72) aligned, bit (18) aligned);
dcl  stat_tablep ptr;
dcl  tape_status_table_$tape_status_table_ ext;
%page;
/* Begin Here */

get_args:
	call cu_$arg_count (nargs, code);

	if code ^= 0 then do;
	     call com_err_ (code, "test_tape");
	     return;
	     end;

	if recursive_ = -1 then do;
	     code = error_table_$multiple_io_attachment;
	     call com_err_ (code, "test_tape", "test_tape has been recursively invoked.");
	     call com_err_ (0, "test_tape", "enter the release (rl) command and recall");
	     return;
	     end;

	stat_tablep = addr (tape_status_table_$tape_status_table_);

	read_sw = "1"b;
	string (comment) = "";
	string (reel_comment) = "";
	sys_sw = "0"b;
	ext_sw = "0"b;
	write_sw = "1"b;
	mask = (12)"010"b;
	ntimes = 100000;
	vid = "0"b;
	den8 = "0"b;
	den6250 = "0"b;
	den16 = "1"b;
	density = "000100000000000000000000000000000000"b;
	k = 0;
	write_error, read_error, irrec_write, irrec_read, rd_comp_err = 0;

arg_loop:
	do while (nargs - k > 0);

/* -------------------------------------------------------------------------------------------------- */
/*                                                                                                  */
/*     Set up the indicators to read only.                                                          */
/*                                                                                                  */
/* -------------------------------------------------------------------------------------------------- */
	     k = k + 1;
	     call cu_$arg_ptr (k, argptr, arglen, code);

	     if arg_string = "-r" | arg_string = "-read" then do;
		read_sw = "1"b;
		write_sw = "0"b;
		go to next_arg;
		end;



/* -------------------------------------------------------------------------------------------------- */
/*                                                                                                  */
/*     Set up the indicators to write only.                                                         */
/*                                                                                                  */
/* -------------------------------------------------------------------------------------------------- */
	     if arg_string = "-w" | arg_string = "-write" then do;
		read_sw = "0"b;
		write_sw = "1"b;
		go to next_arg;
		end;

/* --------------------------------------------------------------------------------------------------- */
/*                                                                                                   */
/*     Both read and write have been specifically requested even though these are the default        */
/*     no special processing is needed so proceed to the next argument                               */
/*                                                                                                   */
/* --------------------------------------------------------------------------------------------------- */


	     if arg_string = "-wr" | arg_string = "-write_read" then do;
		go to next_arg;
		end;


/* -------------------------------------------------------------------------------------------------- */
/*                                                                                                  */
/*     Pick up the pattern and check to be sure it is valid.                                        */
/*                                                                                                  */
/* -------------------------------------------------------------------------------------------------- */
	     if arg_string = "-ptrn" | arg_string = "-pattern" then do;
		if rand_ptrn then do;
ptrn_err:
		     call com_err_ (0, "test_tape", "Incompatible options, -ptrn and -random.");
		     go to bad_arg;
		     end;
		k = k + 1;
		if k > nargs then do;
		     code = error_table_$noarg;
		     call com_err_ (code, "test_tape", "Missing data pattern.");
		     go to bad_arg;
		     end;
		call cu_$arg_ptr (k, argptr, arglen, code);
		if index (arg_string, "-") ^= 0 then do;
		     code = error_table_$noarg;
		     call com_err_ (code, "test_tape", "Missing data pattern.");
		     go to bad_arg;
		     end;
		temp = cv_oct_check_ (arg_string, code);
		mask = unspec (temp);
		if code ^= 0 then do;
		     call com_err_ (code, "test_tape", "Character ^d of data pattern is invalid.");
		     go to bad_arg;
		     end;
		man_ptrn = "1"b;
		go to next_arg;
		end;

	     if arg_string = "-random" then do;
		if man_ptrn then goto ptrn_err;
		rand_ptrn = "1"b;
		goto next_arg;
		end;

/* --------------------------------------------------------------------------------------------------- */
/*                                                                                                   */
/*     Pick up the number of records to write and/or read and make sure it is a valid decimal number. */
/*                                                                                                   */
/* --------------------------------------------------------------------------------------------------- */

	     if arg_string = "-count" | arg_string = "-ct" then do;
		k = k + 1;
		if k > nargs then do;
		     code = error_table_$noarg;
		     call com_err_ (code, "test_tape", "Missing record count.");
		     go to bad_arg;
		     end;
		call cu_$arg_ptr (k, argptr, arglen, code);
		if index (arg_string, "-") ^= 0 then do;
		     code = error_table_$noarg;
		     call com_err_ (code, "test_tape", "Missing record count.");
		     go to bad_arg;
		     end;
		ntimes = cv_dec_check_ (arg_string, code);
		if code ^= 0 then do;
		     call ioa_ ("Character ^d of the record count is invalid.", code);
		     go to bad_arg;
		     end;
		go to next_arg;
		end;

/* -------------------------------------------------------------------------------------------------- */
/*                                                                                                  */
/*     Get the user designated volume id.                                                           */
/*                                                                                                  */
/* -------------------------------------------------------------------------------------------------- */
	     if arg_string = "-volume" | arg_string = "-vol" then do;
		k = k + 1;
		if k > nargs then do;
		     code = error_table_$noarg;
		     call com_err_ (code, "test_tape", "Missing volume id.");
		     go to bad_arg;
		     end;
		call cu_$arg_ptr (k, argptr, arglen, code);
		if char (arg_string, 1) = "-" then do;
		     code = error_table_$noarg;
		     call com_err_ (code, "test_tape", "Missing volume id.");
		     go to bad_arg;
		     end;
		reelid = arg_string;
		save_reel = reelid;
		vid = "1"b;
		go to next_arg;

		end;


/* ***********************************************
   *   Pick up any comments to reel information	  *
   *********************************************** */

	     if arg_string = "-comment" | arg_string = "-com" then do;
		k = k + 1;
		if k > nargs then do;
		     code = error_table_$noarg;
		     call com_err_ (code, "test_tape", "Missing Comment.");
		     go to bad_arg;
		     end;
		call cu_$arg_ptr (k, argptr, arglen, code);
		if index (arg_string, "-") ^= 0 then do;
		     code = error_table_$noarg;
		     call com_err_ (code, "test_tape", "Missing Comment.");
		     go to bad_arg;
		     end;

		if length (arg_string) > 55 then do;
		     code = error_table_$noarg;
		     call com_err_ (code, "test_tape", "Comment String > 55 chars.");
		     go to bad_arg;
		     end;

		comment = arg_string;
		comment_sw = "1"b;
		go to next_arg;
		end;

/* -------------------------------------------------------------------------------------------------- */

/*                                                                                                  */
/*     Pick up the specified density and set the indicator  accordingly.              */
/*                                                                                                  */
/* -------------------------------------------------------------------------------------------------- */
	     if arg_string = "-density" | arg_string = "-den" then do;
		k = k + 1;
		if k > nargs then do;
		     code = error_table_$noarg;
		     call com_err_ (code, "test_tape", "Missing density.");
		     go to bad_arg;
		     end;
		call cu_$arg_ptr (k, argptr, arglen, code);
		if arg_string = "800" then do;
		     den8 = "1"b;
		     den16 = "0"b;
		     den6250 = "0"b;
		     density = "001000000000000000000000000000000000"b;
		     end;

		else if arg_string = "1600" then do;
		     den8 = "0"b;
		     den16 = "1"b;
		     den6250 = "0"b;
		     density = "000100000000000000000000000000000000"b;
		     end;

		else if arg_string = "6250" then do;
		     den6250 = "1"b;
		     den8 = "0"b;
		     den16 = "0"b;
		     density = "000010000000000000000000000000000000"b;
		     end;


		else do;
		     code = error_table_$bad_density;
		     call com_err_ (code, "test_tape", "Only 800, 1600 or 6250 bpi may be specified for test_tape.");
		     go to bad_arg;
		     end;
		go to next_arg;
		end;


/* --------------------------------------------------------------------------------- */
/*            pick up type handler (7 or 9 track).                                       */
/*                        set track7 flag if requested                                    */
/* --------------------------------------------------------------------------------- */

	     if arg_string = "-track7" | arg_string = "-tk7" then do;
		den8 = "1"b;
		den16 = "0"b;
		den6250 = "0"b;
		track7 = "1"b;
		density = "001000000000000000000000000000000000"b;
		go to next_arg;
		end;

/* ------------------------------------------------------------------- */
/*     See if user wants to turn on Detailed Status output      */

/* ------------------------------------------------------------------- */

	     if arg_string = "-raw" then do;
		ext_sw = "1"b;
		go to next_arg;
		end;

/* ------------------------------------------------------------------- */
/*                                                                    */
/*	           See if this is a no data compare read pass              */
/*                                                                   */
/* ----------------------------------------------------------------- */

	     if arg_string = "-ndc" | arg_string = "no_data_compare" then do;
		ndc_sw = "1"b;
		go to next_arg;
		end;

/* **************************************
   *    See if user wants wait option    *
   ************************************** */

	     if arg_string = "-wait" | arg_string = "-wt" then do;
		wait_flag = "1"b;
		k = k + 1;
		if k > nargs then do;
		     wait_cnt = 2;			/* default */
		     goto done_args;
		     end;
		call cu_$arg_ptr (k, argptr, arglen, code);
		if index (arg_string, "-") ^= 0 then do;
		     wait_cnt = 2;			/* default */
		     k = k - 1;
		     goto next_arg;
		     end;
		wait_cnt = cv_dec_check_ (arg_string, code);
		if code ^= 0 then do;
		     call com_err_ (code, "test_tape", arg_string);
		     go to bad_arg;
		     end;
		goto next_arg;
		end;

/* *******************************************
   *    See if user wants a certain drive     *
   ******************************************* */

	     if arg_string = "-dv" | arg_string = "-device" then do;
		if comp_sw then goto no_good;
		k = k + 1;
		if k > nargs then do;
dv_error:
		     code = error_table_$noarg;
		     call com_err_ (code, "test_tape", "Missing device name");
		     go to bad_arg;
		     end;
		call cu_$arg_ptr (k, argptr, arglen, code);
		if index (arg_string, "-") ^= 0 then goto dv_error;
		dev_name = arg_string;
		dev_sw = "1"b;
		goto next_arg;
no_good:
		code = error_table_$inconsistent;
		call com_err_ (code, "test_tape", "Can't have both -device and -compare options at the same time!");
		go to bad_arg;
		end;

/* **************************************************
   *    See if user wants the compatability option   *
   ************************************************** */

	     if arg_string = "-comp" | arg_string = "-compare" then do;
		if dev_sw then goto no_good;
		num_drives = 0;
		do l = 1 by 1;
		     k = k + 1;
		     if k > nargs then do;
			if l < 3 then do;
comp_error:
			     code = error_table_$noarg;
			     call com_err_ (code, "test_tape", "Must have at least 2 devices to run compatability!")
				;
			     go to bad_arg;
			     end;
			goto done_args;
			end;
		     call cu_$arg_ptr (k, argptr, arglen, code);
		     if index (arg_string, "-") ^= 0 then do;
			if l < 3 then goto comp_error;
			k = k - 1;
			goto next_arg;
			end;
		     if l > 16 then do;
			call com_err_ (error_table_$badopt, "test_tape", "16 drives is the max.");
			go to bad_arg;
			end;
		     dev_array (l) = arg_string;
		     comp_sw = "1"b;
		     num_drives = num_drives + 1;
		end;
		end;

/* See if sys flag is wanted */

	     if arg_string = "-system" | arg_string = "-sys" then do;
		sys_sw = "1"b;
		go to next_arg;
		end;

	     if arg_string = "-retry" then goto next_arg; /* Default (obsolete arg) */

	     code = error_table_$badopt;
	     call com_err_ (code, "test_tape", "Invalid or unrecognizable parameter in string (^a).", arg_string);

bad_arg:
	     call com_err_ (0, "test_tape", "For a list of valid control args type ""help test_tape -bf"".");
	     return;
next_arg:
	end;

done_args:
	tsegp = null ();				/* so cleanup will work */
	tdcm_attached = "0"b;
	on cleanup call command_cleanup ("0"b);
	rek = 0;

/* Display current options to user. */

	call com_err_ (0, name_stamp (),
	     "Opt= tk-^[7^;9^],den-^[800^]^[1600^]^[6250^],mode-^[w^]^[r^],ct-^[entire^s^;^d^]^[,wt-^d^;^s^],ptrn-^[random^s^;^12.3b^]^[,ndc^]^[,raw^]^[,sys^]",
	     track7, den8, den16, den6250, write_sw, read_sw, (ntimes >= 100000), ntimes, wait_flag, wait_cnt,
	     rand_ptrn, mask, ndc_sw, ext_sw, sys_sw);
%page;

/* init tape for write and get it mounted */


/* -------------------------------------------------------------------------------------------------- */
/*                                                                                                  */
/*     Grab storage for the tseg structure.                                                         */
/*                                                                                                  */
/* -------------------------------------------------------------------------------------------------- */

	comp_lp_ctr = 0;
	if comp_sw then do;
comp_loop:
	     comp_lp_ctr = comp_lp_ctr + 1;
	     dev_name = dev_array (comp_lp_ctr);
	     if comp_lp_ctr > 1 then write_sw = "0"b;	/* turn off write */
	     end;

	call get_temp_segment_ (name_stamp (), ext_bffr_ptr, code);
	if code ^= 0 then do;
	     call com_err_ (code, name_stamp (), "Attempting to get a temporary segment!");
	     return;
	     end;
	allocate tseg;

	tseg.version_num = tseg_version_2;
	tseg.areap = null;
	call ipc_$create_ev_chn (tseg.ev_chan, code);
	if code ^= 0 then do;
	     call com_err_ (code, name_stamp (), "no event channel");
	     go to done;
	     end;

	if track7
	then tseg.tracks = 1;			/* We want a 7 track drive */


	else tseg.tracks = 0;			/* we want a 9 track tape */
sync:
	tseg.sync = 1;				/* we want async operation */
	tseg.get_size = 0;				/* no sizes returned */


	tseg.bufferptr (1) = bin (rel (addr (tseg.buffer (1))), 18);
	tseg.buffer_size (1) = 1040;
	tseg.mode (1) = 0;				/* binary records */
	tseg.density = density;


/* ----------------------------------------------------------------------------------------------- */
/*                                                                                               */
/* Attach drive and do initial rewind and unload.  Prepare to wait for tape mounted signal.      */
/*                                                                                               */
/* ----------------------------------------------------------------------------------------------- */

	if write_sw
	then tseg.write_sw = 1;
	else tseg.write_sw = 0;

	call tdcm_$tdcm_attach (tsegp, code);
	if code ^= 0 then do;
	     call com_err_ (code, name_stamp (), "tdcm attach bad");
	     go to done;
	     end;
	tdcm_attached = "1"b;

	call tdcm_$tdcm_set_signal (tsegp, code);
	if code ^= 0 then do;
	     call com_err_ (code, name_stamp (), "mount tape set signal bad");
	     go to done;
	     end;


/* ------------------------------------------------------------------------------------------------------- */
/*                                                                                                       */
/*     Set the volume id and issue the starting test message to the user.  Output a mount message        */
/*     to the operator and hang around waiting for a response from him to indicate that the tape is      */
/*     indeed mounted.                                                                                   */
/*                                                                                                       */
/* ------------------------------------------------------------------------------------------------------- */

attach:
	tape_mounted = "0"b;			/* No tape YET */
	if dev_sw | comp_sw
	then tseg.drive_name = dev_name;
	else tseg.drive_name = "";

	if vid
	then reel_comment = rtrim (save_reel);

	else do;
	     reel_comment = "test-tape";
	     save_reel = "test-tape";
	     end;

	if comment_sw then reel_comment = rtrim (reel_comment) || ",*" || rtrim (comment);

	if sys_sw then reel_comment = rtrim (reel_comment) || ",sys";

request_mount:
	call com_err_ (0, name_stamp (), "Requesting mount of volume ""^a""^[ on ^a^].", save_reel, (dev_sw | comp_sw),
	     tseg.drive_name);

	call tdcm_$tdcm_message (tsegp, reel_comment, tseg.write_sw, code);
	if code ^= 0 & code ^= error_table_$resource_attached & code ^= error_table_$resource_assigned then do;
	     call com_err_ (code, name_stamp (), "Unable to attach ^a", tseg.drive_name);
	     if wait_flag & (wait_cnt > wait) & code = error_table_$resource_unavailable then do;
		call com_err_ (0, name_stamp (), "I will wait 1 minute and then try again!");
		call timer_manager_$sleep (60, "11"b);
		wait = wait + 1;
		goto request_mount;
		end;
	     wait = 0;
	     if comp_sw then do;
		if comp_lp_ctr = 1 then do;
		     call com_err_ (0, name_stamp (), "Unable to continue test.");
		     call command_cleanup ("1"b);
		     return;
		     end;
		call com_err_ (0, name_stamp (), "Bypassing device ^a.", tseg.drive_name);
		goto done;
		end;
	     call command_cleanup ("1"b);
	     return;
	     end;

	else if code ^= 0 then do;
	     call com_err_ (code, name_stamp (), "Attaching tape.");
	     go to done;
	     end;

	wait = 0;
	call wait_io;				/* wait for drive ext signal */

/* ------------------------------------------------------------------------------------------------------- */
/*                                                                                                       */
/*     When the tape is officially mounted set the density if requested to do so.                        */
/*                                                                                                       */
/* ------------------------------------------------------------------------------------------------------- */

	tape_mounted = "1"b;			/* now official */

	if den8 | den16 | den6250 then do;
	     set_den_sw = "1"b;
	     doing = "set density";
	     if den8 then tseg.command_queue (1) = bin ("110000"b, 6);
	     if den16 then tseg.command_queue (1) = bin ("110101"b, 6);
	     if den6250 then tseg.command_queue (1) = bin ("100001"b, 6);
	     tseg.sync = 1;
	     tseg.buffer_count = 0;
	     tseg.command_count = 1;
	     call tdcm_$tdcm_iocall (tsegp, code);

	     if code ^= 0 then do;
		call com_err_ (code, name_stamp (), "Set density iocall failed.");
		go to done;
		end;


	     if tseg.completion_status = 1
	     then tseg.sync = 1;

	     else do;
		call ck_io (code, "0"b);
		call com_err_ (0, name_stamp (), "Set density io failed, terminating test.");
		go to done;
		end;
	     end;

	set_den_sw = "0"b;

	if ^buf_init then do;
	     if rand_ptrn then do;
		do i = 1 to 1040;
		     call random_$uniform (seed, num_ret);
		     bufarray (i) = unspec (num_ret);
		end;
		end;
	     else do i = 1 to 1040;
		bufarray (i) = mask;
	     end;

	     tseg.buffer (1) = buftemp;

	     buf_init = "1"b;
	     end;

	ws_ptr = baseptr (tseg.ws_segno);
	ioi_idx = ws.info.ioix;


	tseg.command_count = 2;
	tseg.command_queue (2) = bin ("100000"b, 6);	/* reset dev status */
	tseg.command_queue (1) = bin ("101001"b, 6);	/* reset device extended status */
	call tdcm_$tdcm_iocall (tsegp, code);
	recursive_ = -1;				/* prevent recursive calls */
	name = tseg.drive_name;

	on program_interrupt
	     call com_err_ (0, name_stamp (), "^a pass on ^a, processing record ^d", rtrim (doing),
		rtrim (tseg.drive_name), rek);


%page;

/* here we write test tape if requested, else go to read */

	if write_sw = "0"b then go to read_part;
	doing = "write";
	call com_err_ (0, name_stamp (), "Begin write pass on ^a^[ vol=^a^].", tseg.drive_name, vid, save_reel);

/*     Do this loop either till end of tape or until we reach the number of records specified  by the user in the -nrec parameter.        */


	rek, rec_wrt = 0;

	do i = 1 to ntimes;
	     rek = rek + 1;
	     wrx = i;
	     rec_wrt = rec_wrt + 1;

reissue_wr:
	     tseg.buffer (1) = buftemp;
	     call issue_rw;

	     if tseg.completion_status = 1 then go to write_ok;
						/* Completion Status was good */

	     stat_ptr = addr (tseg.hardware_status);

	     if stat_maj = "0001"b then go to reissue_wr;


	     call ck_io (code, "0"b);
	     if code = 1 then go to done;
	     if code = 3 then go to reissue_wr;
	     if code = 4 then go to eot_m;
	     if (code = 5) | (code = 9) then go to done;
	     if code = 6 then go to eot_m;


write_ok:
done_write:
	end;
%page;

eot_m:
	if code = 4
	then at_eot = "1"b;
	else at_eot = "0"b;
	doing = "write EOF";

	do i = 1 to 10;
	     tseg.buffer_count = 0;
	     tseg.command_count = 1;
	     tseg.command_queue (1) = bin ("101101"b, 6);
	     call tdcm_$tdcm_iocall (tsegp, code);

	     if code ^= 0 then do;
		call com_err_ (code, name_stamp (), "Write EOF^[ at EOT^;^] iocall failed.", at_eot);
		go to done;
		end;


	     if tseg.completion_status = 1
	     then go to write_second_eof;

	     else do;
		call ck_io (code, "0"b);
		if code = 4 then go to write_second_eof;
		call backspace (1);
		end;

	end;

	call com_err_ (0, name_stamp (), "Unable to write EOF^[ at EOT^;^], terminating test.", at_eot);
	go to done;


write_second_eof:
	doing = "write second EOF";

	do i = 1 to 10;
	     tseg.buffer_count = 0;
	     tseg.command_count = 1;
	     tseg.command_queue (1) = bin ("101101"b, 6);
	     call tdcm_$tdcm_iocall (tsegp, code);

	     if code ^= 0 then do;
		call com_err_ (code, name_stamp (), "Write second EOF^[ at EOT^;^] iocall failed.", at_eot);
		go to done;
		end;


	     if tseg.completion_status = 1
	     then go to rew;

	     else do;
		call ck_io (code, "0"b);
		if code = 4 then go to rew;
		call backspace (1);
		end;

	end;

	call com_err_ (0, name_stamp (), "Unable to write second EOF^[ at EOT^;^], terminating test.", at_eot);
	go to done;


rew:
	doing = "rewind";
	at_eot = "0"b;
	write_sw = "0"b;
	rew_sw = "1"b;

	do i = 1 to 5;
	     tseg.buffer_count = 0;
	     tseg.command_count = 1;
	     tseg.command_queue (1) = bin ("111000"b, 6);

	     call tdcm_$tdcm_iocall (tsegp, code);

	     if code ^= 0 then do;
		call com_err_ (code, name_stamp (), "rewind iocall failed");
		go to done;
		end;

	     if tseg.completion_status = 1 then go to wait_rew;

	     call ck_io (code, "0"b);			/*  got bad io stat */
	end;

	call com_err_ (0, name_stamp (), "Unable to issue rewind io, terminating test.");
	go to done;



wait_rew:
	do i = 1 to 120 while (rew_sw = "1"b);		/* Max = 10 minutes */

	     call timer_manager_$sleep (5, "11"b);	/* 5 relative seconds */
	     tseg.buffer_count = 0;
	     tseg.command_count = 1;
	     tseg.command_queue (1) = bin ("000000"b, 6);
	     call tdcm_$tdcm_iocall (tsegp, code);

	     if code ^= 0 then do;
		call com_err_ (code, name_stamp (), "check status iocall failed.");
		go to done;
		end;

	     if tseg.completion_status = 1 then do;
		rew_sw = "0"b;
		go to read_part;
		end;

	     if (addr (tseg.hardware_status) -> stat_chk.stat_maj = "0001"b)
		& (addr (tseg.hardware_status) -> stat_chk.stat_min = "000001"b)
	     then go to end_wait;


	     if tseg.completion_status = 2 then call ck_io (code, "0"b);

end_wait:
	end;

	call com_err_ (code, name_stamp (), "unable to perform rewind on device");
	go to done;
%page;


/* here to read tape and check how we did */

read_part:
	if read_sw = "0"b then go to done;


	detected_eof = "0"b;
	write_sw = "0"b;
	doing = "read";
	call com_err_ (0, name_stamp (), "Begin read pass on ^a^[ vol=^a^].", tseg.drive_name, vid, save_reel);
	tseg.write_sw = 0;				/* lets setup to do a read */

	rec_rd = 0;
	rek = 0;					/* record number for s/b data */

	do i = 1 to ntimes;
	     rek = rek + 1;
	     rdx = i;
	     rec_rd = rec_rd + 1;


reissue_rd:
	     call issue_rw;

	     if tseg.completion_status = 1 then do;
		detected_eof = "0"b;
		if ^ndc_sw
		then call ck_data;
		else go to end_read;
		end;

	     stat_ptr = addr (tseg.hardware_status);

	     if stat_maj = "0001"b then go to reissue_rd;

	     if tseg.completion_status = 2 then do;

		if stat_maj = "0100"b then do;
		     if stat_min = "001111"b | stat_min = "010011"b then do;
						/* 7 or 9 track eof signal */
			rek = rek - 1;
			rdx = rdx - 1;
			rec_rd = rec_rd - 1;

			if detected_eof then goto done;
						/* this makes two in a row! */
			detected_eof = "1"b;	/* one seen */
			goto end_read;
			end;
		     rew_sw = "1"b;			/* set so no retries */
		     call ck_io (code, "1"b);		/* got a parity err */
		     go to done;
		     end;

		call ck_io (code, "1"b);		/* how was it */
		if code = 1 then go to done;
		if code = 4 then do;
		     call com_err_ (code, name_stamp (), "EOT detected during read");
		     go to done;
		     end;

		if (code = 5) | (code = 9) then do;
		     call com_err_ (code, name_stamp (), "Unrecoverable Attention condition, Quit.");
		     codex = 9;
		     go to done;
		     end;
		end;
	     go to end_read;

end_read:
	     blank_rd = 0;
	end;

done:
	call summarize;				/* display results */

	call command_cleanup ("1"b);

	if (comp_sw) & (comp_lp_ctr < num_drives) then do;
	     read_error, write_error, rd_comp_err = 0;
	     irrec_write, irrec_read = 0;
	     blank_rd, rec_wrt, rec_rd = 0;
	     da_cnt = 0;
	     goto comp_loop;
	     end;

	return;
%page;
error:
     proc (efail, ecode);
dcl  efail char (*) varying,
     ecode fixed bin (35),
     more_sw bit (1),
     recn fixed bin;
dcl  t_maj bit (6) init ("000000"b);
dcl  is_interesting bit (1);
dcl  detailed_stat bit (208) unal based (dstat_ptr);
dcl  1 ext based (dstat_ptr),
       2 data (26) bit (8) unal;


	if retry_in_progress &			/* bypass if in retry */
	     ^(code = 9 | code = 5)
	then return;
	if read_sw then recn = rdx;

	if write_sw then recn = wrx;

	if (rew_sw | set_den_sw)
	then more_sw = "1"b;
	else more_sw = "0"b;


	call com_err_ (0, name_stamp (), "^a error^[ @ record ^9d^].", doing, ^more_sw, recn);
	call ioa_ ("^-^3x^a (^2o/^2o)", efail, stat_maj, stat_min);


	dstat_ptr = addr (ext_bffr (da_cnt).ext_data);

	if code = 9 | code = 5 then do;		/* if its an att. cond. */
	     call analyze_detail_stat_$rsnnl (name, (tseg.hardware_status), detailed_stat, efail, is_interesting, ecode)
		;
	     if is_interesting then call ioa_ ("^-^3xDetailed status: ^a", efail);
	     end;


	if ext_sw then do;
	     call ioa_ ("^/Detailed Status: ^( ^2.4b^) (hex)", ext.data (1), ext.data (2), ext.data (3), ext.data (4),
		ext.data (5), ext.data (6), ext.data (7), ext.data (8), ext.data (9), ext.data (10), ext.data (11),
		ext.data (12), ext.data (13), ext.data (14), ext.data (15), ext.data (16));
	     call ioa_ ("^10xByte => 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15^/");
	     call ioa_ ("^17x^( ^2.4b^) (hex)", ext.data (17), ext.data (18), ext.data (19), ext.data (20),
		ext.data (21), ext.data (22), ext.data (23), ext.data (24), ext.data (25), ext.data (26));
	     call ioa_ ("^10xByte => 16 17 18 19 20 21 22 23 24 25^/");
	     end;

	return;
     end error;
%page;

/* internal proc to determine type of error */

ck_io:
     proc (xcode, who_sw);

dcl  xcode fixed bin (35),
     stat_pad bit (36) aligned init ("0"b),
     who_sw bit (1);


	if tseg.completion_status ^= 2
	then					/* should not be here otherwise */
	     return;

	code = 0;					/* resett error status */


	if stat_maj = "0011"b & substr (stat_min, 1, 1) = "1"b then do;
						/* EOT Detected */
	     code = 4;
	     if stat_min ^= "100000"b then do;
		call analyze_device_stat_$rsnnl (fail, stat_tablep, (tseg.hardware_status || stat_pad), ("0"b));
		call error (fail, code);
		code = 2;
		end;
	     return;
	     end;

	if stat_maj = "0011"b & stat_min = "000010"b then do;
	     blank_rd = blank_rd + 1;
	     if blank_rd = 3 then do;
		call com_err_ (0, name_stamp (), "quitting test due to BLANK TAPE on READ statuses.");
		go to done;
		end;
	     end;

	call ioi_$get_detailed_status (ioi_idx, det_valid, rsr_data, code);
	if ^det_valid then rsr_data = "0"b;

	if tseg.write_sw = 1
	then					/* if we're  writing update the write errors */
	     write_error = write_error + 1;

	else read_error = read_error + 1;

	call analyze_device_stat_$rsnnl (fail, stat_tablep, (tseg.hardware_status || stat_pad), ("0"b));

	da_cnt = da_cnt + 1;			/* update error ctr */
	if da_cnt > 1000 then do;			/* too many errors */
	     call com_err_ (0, name_stamp (), "Too many errors encountered! ^/Fix tape drive and re-run!");
	     da_cnt = da_cnt - 1;			/* forget about this one */
	     call error (fail, code);
	     go to done;
	     end;


	ext_bffr (da_cnt).iom_status = tseg.hardware_status;
	ext_bffr (da_cnt).ext_data = substr (rsr_data, 1, 208);

	if tseg.write_sw = 1			/* if writing */
	then ext_bffr (da_cnt).xrec_no = wrx;

	else ext_bffr (da_cnt).xrec_no = rdx;

	ext_bffr (da_cnt).xdoing = tseg.write_sw;

check_stat:
	if stat_maj = "0011"b | stat_maj = "0010"b | stat_maj = "1011"b | stat_maj = "1010"b
	then go to err_stat (fixed (stat_maj, 4));

	else go to err_stat (9);


err_stat (3):					/* MTH Data Alert */
	code, codex = 2;
	call error (fail, code);
	if ^retry_in_progress then call retry_;
	return;

err_stat (11):					/* MPC Data Alert */
	if stat_min = "100000"b
	then code, codex = 9;			/* Marginal Condition */

	else code, codex = 2;
	call error (fail, code);
	if ^retry_in_progress then call retry_;
	return;


err_stat (10):					/* MPC Attention */
	code, codex = 9;

	if substr (stat_min, 3, 2) = "11"b then do;
	     code = 2;
	     call error (fail, code);
	     if ^retry_in_progress then call retry_;
	     return;
	     end;

	else if substr (stat_min, 3, 2) ^= "11"b then do;
	     code, codex = 9;
	     ext_sw = "1"b;
	     call error (fail, code);
	     ext_sw = "0"b;
	     go to done;
	     end;

err_stat (2):					/* MTH Attention */
	code, codex = 9;
	ext_sw = "1"b;
	call error (fail, code);
	ext_sw = "0"b;
	go to done;

/* should never get here. if we do report it and quit test */

err_stat (9):
	codex = 9;
	call com_err_ (0, name_stamp (), "Cannot process returned status, aborting test.");
	ext_sw = "1"b;
	call error (fail, code);
	ext_sw = "0"b;
	go to done;

     end ck_io;
%page;

retry_:
     proc;
dcl  (kntt, knt, gotit) fixed bin init (0);

	if index (doing, "EOT") ^= 0 then return;


	if rew_sw then return;

	retry_in_progress = "1"b;

	if doing = "write" then do;

	     do knt = 1 to 10;			/* allow  for 10 retries of a record */
		call backspace (1);

		call issue_rw;			/*  do the io */

		if tseg.completion_status = 1 then do;
		     code = 0;
		     retry_in_progress = "0"b;
		     return;
		     end;

		if tseg.completion_status = 2 then call ck_io (code, "0"b);

	     end;

	     irrec_write = irrec_write + 1;

/*  do a bksp/erase */

	     call com_err_ (0, name_stamp (), "10 unsuccessful attempts to write record ^d.", wrx);
	     call com_err_ (0, "", "^2-backspace/erase operation will be performed.");

	     tseg.command_count = 2;
	     tseg.command_queue (1) = bin ("100110"b, 6);
	     tseg.command_queue (2) = bin ("101100"b, 6);

	     call tdcm_$tdcm_iocall (tsegp, code);

	     if code ^= 0 then do;
		call com_err_ (code, name_stamp (), "backspace/erase  iocall failed, QUIT");
		go to done;
		end;

	     if tseg.completion_status = 1 then do;	/* good term */
		retry_in_progress = "0"b;
		code = 3;
		return;
		end;

	     else do;				/* abnormal term */

		call ck_io (code, "0"b);
		call com_err_ (0, name_stamp (), "backspace/erase failed, QUIT.");
		go to done;
		end;

	     retry_in_progress = "0"b;
	     end;					/* end of write retry */


	else do;					/* retry reads */

	     do knt = 1 to 3;			/* allow for 3 retries */
		call backspace (1);
		call issue_rw;

		if tseg.completion_status = 1 then do;	/* read ok */
		     call ck_data;			/* verify the data */
		     return;
		     end;

		else call ck_io (code, "1"b);
	     end;

	     call com_err_ (0, name_stamp (), "Unable to read record ^d.", rdx);
	     irrec_read = irrec_read + 1;
	     retry_in_progress = "0"b;
	     end;					/* end of read retry */
	retry_in_progress = "0"b;

	return;
     end retry_;


%page;

/* routine to issue read and write calls to tdcm */

issue_rw:
     proc;

	tseg.buffer_offset = 0;
	tseg.buffer_count = 1;
	tseg.command_count = 0;

	call tdcm_$tdcm_iocall (tsegp, code);


	if code ^= 0 then do;
	     call com_err_ (code, name_stamp (), "^a iocall failed", doing);
	     go to done;
	     end;

	return;
     end issue_rw;

backspace:
     proc (n);

dcl  (i, n) fixed bin;

	tseg.command_count = n;

	do i = 1 to n;
	     tseg.command_queue (i) = bin ("100110"b, 6); /* backspace cmd */
	end;

	call tdcm_$tdcm_iocall (tsegp, code);

	if code ^= 0 then do;
	     call com_err_ (code, name_stamp (), "backspace iocall failed.");
	     go to done;
	     end;

	tseg.command_count, code = 0;

	return;

     end backspace;
%page;
ck_data:
     proc;
dcl  kk fixed bin;

	if tseg.buffer (1) = buftemp
	then					/* if data compares */
	     return;				/*  all's well */

	rd_comp_err = rd_comp_err + 1;
	call com_err_ (0, name_stamp (), "data compare error at record  ^9d.", rdx);
	read_buff = tseg.buffer (1);
	do k = 1 to 1040;
	     if err_buff (k) ^= bufarray (k) then do;

		if k > 2
		then kk = k - 2;
		else kk = k;

		call ioa_ ("^/Data Word^9d^3x^9d^3x^9d^3x^9d", kk, kk + 1, kk + 2, kk + 3);
		call ioa_ ("Data Was:^4( ^.3b^)", err_buff (kk), err_buff (kk + 1), err_buff (kk + 2),
		     err_buff (kk + 3));
		call ioa_ ("Data S/B:^4( ^.3b^)^/", bufarray (kk), bufarray (kk + 1), bufarray (kk + 2),
		     bufarray (kk + 3));
		end;
	     return;
	end;

	return;
     end ck_data;
%page;
/* routine to wait for external signal form tape drine */

wait_io:
     proc;

	wait_list.n = 1;
	wait_list.chan (1) = tseg.ev_chan;
	call ipc_$block (addr (wait_list), addr (message), code);

	if code ^= 0 then do;
	     call com_err_ (code, name_stamp (), "ipc_$block failed");
	     go to done;
	     end;

	doing = "wait io";
ck_ready:
	tseg.buffer_count = 0;
	tseg.command_count = 1;
	tseg.command_queue (1) = bin ("100000"b, 6);
	call tdcm_$tdcm_iocall (tsegp, code);
	if code ^= 0 then do;
	     call com_err_ (code, name_stamp (), "status  check iocall bad");
	     go to done;
	     end;

	tseg.command_count = 0;			/* back to async */
	stat_ptr = addr (tseg.hardware_status);

	if stat_maj ^= "0000"b
	then if stat_min ^= "000010"b | stat_min ^= "000110"b then go to ck_ready;
	call tdcm_$tdcm_reset_signal (tsegp, code);
	if code ^= 0 then do;
	     call com_err_ (code, name_stamp (), "reset signal bad");
	     go to done;
	     end;


	return;

     end wait_io;					/* end wait_io of wait_io  */
%page;
interp_xstats:
     proc;

dcl  tks fixed bin init (0);
dcl  valid bit (1) init ("0"b);
dcl  (i, j, k) fixed bin;
dcl  (xx, num_in_list) fixed bin init (0);
dcl  curr_dens fixed bin init (0);			/* current density */
dcl  ret_chars fixed bin (21);
dcl  analysis_string char (120);
dcl  message_hold char (1016) varying;
dcl  1 analysis_list (num_in_list) aligned based (a_list_ptr),
       2 mess_count fixed bin,
       2 message char (1016) varying;
dcl  (ext_ptr, a_list_ptr) ptr;
dcl  rec_mode (0:1) char (1) internal static options (constant) init ("R", "W");
dcl  (tracks_v, cmts) bit (1) init ("0"b);
dcl  my_analp ptr init (null ());
dcl  code fixed bin (35);
dcl  (
     ioa_$rs,
     ioa_$nnl
     ) entry () options (variable);

	if da_cnt < 1 then return;
	curr_dens = dens_ (fixed (substr (density, 3, 3), 3));
	att_bffr = ext_bffr (1).ext_data;
	call analyze_detail_stat_ (name, ext_bffr (1).iom_status, ext_bffr (1).ext_data, my_analp, code);
	if code ^= 0 then return;
	if my_analp = null () then return;
	tape_analp = my_analp;
	if ^tape_analysis.fips_controller then do;
	     i = fixed (substr (att_bffr, 21, 4), 4);
	     rec_cap = rec_tbl (i);

	     i = fixed (substr (att_bffr, 30, 2), 2);
	     dev_spd = spd_tbl (i);
	     end;
	else do;
	     if substr (att_bffr, 53, 1)
	     then rec_cap = "1600/6250";
	     else rec_cap = "800/1600/6250";
	     if substr (att_bffr, 54, 3) = "011"b then dev_spd = " 75 ips ";
	     else if substr (att_bffr, 54, 3) = "100"b then dev_spd = "125 ips ";
	     else if substr (att_bffr, 54, 3) = "101"b then dev_spd = "200 ips ";
	     else dev_spd = "??? ips ";
	     end;

	call ioa_ (
	     "^/Device is an ^a,^2x^d track;^2xCurrent Recording Mode:^x^4dbpi^/Recording Capability:^2x^abpi;^5xDevice Speed:^2x^a.^/",
	     tape_analysis.mth_model, tape_analysis.num_tracks, curr_dens, rec_cap, dev_spd);


	call ioa_ ("^xCount^4xRecd #^2xR/W^2xData Bit(s) in Error^2xOther Detail Status Bit Decodes");
	call ioa_ ("========^2x======^2x===^2x====================^2x===============================");

	call get_temp_segment_ ("test_tape", a_list_ptr, code);
	if code ^= 0 then do;
	     call com_err_ (code, name_stamp (), "Attempting to get a temporary segment!");
	     return;
	     end;

	do i = 1 to da_cnt;
	     call analyze_detail_stat_ (name, ext_bffr (i).iom_status, ext_bffr (i).ext_data, my_analp, code);

	     if code ^= 0 then return;
	     if my_analp = null () then return;
	     tape_analp = my_analp;

	     if tape_analysis.num_analyzed > 0 then cmts = "1"b;

	     call ioa_$rs ("^6d^3x^1a^4x^18a^[^37t^a^]", analysis_string, ret_chars, ext_bffr (i).xrec_no,
		rec_mode (ext_bffr (i).xdoing), tape_analysis.tracks_in_error, cmts,
		rtrim (tape_analysis.analyses (1)));
	     message_hold = substr (analysis_string, 1, ret_chars);

	     do j = 2 to tape_analysis.num_analyzed;
		call ioa_$rs ("^47t^a", analysis_string, ret_chars, rtrim (tape_analysis.analyses (j)));
		message_hold = message_hold || substr (analysis_string, 1, ret_chars);
	     end;

	     do k = 1 to num_in_list;
		if analysis_list (k).message = message_hold then do;
		     analysis_list (k).mess_count = analysis_list (k).mess_count + 1;
		     goto next_xstats;
		     end;
	     end;
	     num_in_list = k;
	     analysis_list (k).mess_count = 1;
	     analysis_list (k).message = message_hold;
next_xstats:
	end;

	do k = 1 to num_in_list;
	     call ioa_$nnl ("^7d^3x^a", analysis_list (k).mess_count, analysis_list (k).message);
	end;

	call release_temp_segment_ (name_stamp (), a_list_ptr, code);
end_xstat:
	return;
     end interp_xstats;

%page;

command_cleanup:
     proc (term_condition);
dcl  term_condition bit (1);				/* 1 = just cleanup */
						/* 0 = display results and clean */

	if tsegp ^= null () then do;
	     if tape_mounted then do;
		tseg.command_count = 1;
		tseg.buffer_count = 0;
		tseg.command_queue (1) = bin ("111000"b, 6);
						/* rewind */
		call tdcm_$tdcm_iocall (tsegp, code);
		if ^term_condition then call summarize;
		tape_mounted = "0"b;		/* really still is! */
		end;
	     if tdcm_attached then do;
		call tdcm_$tdcm_detach (tsegp, code);
		tdcm_attached = "0"b;
		end;
	     free tseg;
	     end;
	if ext_bffr_ptr ^= null () then call release_temp_segment_ ("test_tape", ext_bffr_ptr, code);
	recursive_ = 0;

	return;

     end command_cleanup;
%page;
summarize:
     proc;
	if ^tape_mounted then return;			/* never got off the ground */
	call com_err_ (0, name_stamp (), "Test Complete on ^a^2xvol=^a (^4dbpi)", rtrim (name), rtrim (save_reel),
	     dens_ (fixed (substr (density, 3, 3), 3)));
	call ioa_ ("^/^/Records Written  ^9d", rec_wrt);
	call ioa_ ("Records Read     ^9d", rec_rd);

	yy = read_error + write_error + rd_comp_err;

	if yy = 0 then do;
	     call ioa_ ("^/No read/write errors encountered in test.^/");
	     return;
	     end;


	call ioa_ ("^14tRecoverable  Non-Recoverable");
	call ioa_ ("Write Errors^5x^7d^6x^11d", write_error, irrec_write);
	call ioa_ ("Read  Errors^5x^7d^6x^11d", read_error, irrec_read);
	call ioa_ ("Data Compare Errs^7d^/", rd_comp_err);
	call interp_xstats;
	call ioa_ ("^2/");

     end summarize;
%page;
name_stamp:
     proc () returns (char (17));
dcl  1 the_time unaligned int static,
       2 hour pic "99",
       2 minute pic "99",
       2 dot char (1) init ("."),
       2 tenth pic "9";

dcl  (clock, string, divide) builtin;
dcl  ec fixed bin (35);				/* use this, not "code" */
dcl  (hour_bin, minute_bin, second) fixed bin;
dcl  micro_second fixed bin (71);
dcl  decode_clock_value_$time
	entry (fixed bin (71), fixed bin, fixed bin, fixed bin, fixed bin (71), char (4), fixed bin (35));

	call decode_clock_value_$time (clock (), hour_bin, minute_bin, second, micro_second, "", ec);
	the_time.hour = hour_bin;
	the_time.minute = minute_bin;
	the_time.tenth = divide (second, 6, 17, 0);
	return ("test_tape: " || string (the_time));
     end name_stamp;
%page;
%include tdcm_info;
%page;
%include ioi_stat;
%page;
%include tseg;
%page;
%include analyze_det_stat_info;

     end test_tape;
