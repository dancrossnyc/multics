/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/* format: style4 */

/* format: off */

iodd_: proc;

/* This is not the main entry point.  It is used to set the entry variable for
   the driver module default handler if that entry was not defined.  We have
   to be able to call something! */

	return;


iodd_init: entry (system_dir, testing);

/* This is the initialization procedure for all IO Daemon drivers.  It is
   called with two arguments: system_dir which defines the directory which
   will contain the common IO Daemon data bases; and testing, which indicates
   that the driver is being run in test mode.  This procedure determines from
   the site operator which device is to be used, establishes communication
   with the IO Coordinator, attaches the device control terminal if needed,
   and transfers to the driver control procedure specified in the iod_tables
   source file.

   The design was adapted from the original IO Daemon driver designed by
   Robert S. Coren in September 1973.  This design is provided to make the
   IO Daemon compatible with the Access Isolation Mechanism.

   Coded in January 1975 by J. C. Whitmore.

   Modified in November 1975 by M. A. Braida
   to initialize data for seg_fault_error check.   */
/* Modified Nov 1977 by J. C. Whitmore for new iodd_static data, initiation of rqti segs, and condition handling */
/* Modified Mar 1978 by J. C. Whitmore for upgrade and addition of per RQT accounting and rqti seg from iod_tables */
/* Modified by J. C. Whitmore, 7/78, to setup for new driver -> coord command strategy & "x" cmd */
/* Modified by J. C. Whitmore, 10/78, to extend number of RJE stations (version 3 iod_tables format) */
/* Modified by J. C. Whitmore, 11/78, to start using driver version numbers starting at 5.0 (5 major changes since MR 6.0) */
/* Modified by J. C. Whitmore, 3/79 (V-5.1),  for minor message and logic bug fixes */
/* Modified by J. C. Whitmore, 5/79 (V-5.2), to retry listen attachment 5 times before aborting */
/* Modified by C. Hornig, 8/79 (V-5.3), for multiple minor devices of the same generic type */
/* Modified by J. C. Whitmore, 10/79 (V-5.4), for daemon_idle default condition handler */
/* Modified by E. N. Kittlitz, 6/81 (V-5.5), for UNCA rate structures */
/* Modified:  November 1981 by G. Palter, V-5.6, to use read_password_ to get the station password if it is omitted from
   the station command, to not consider inability to set hangup_proc as fatal, to call head_sheet_$test when in a test
   environment, FILL IN THE BLANK, and fix the following bugs from the I/O daemon error list:
      0032: phx11372
         When running an I/O daemon in test mode with the coordinator and driverin the same process, printing a single
         request, exiting the I/O daemon, re-entering the I/O daemon, and printing another request will cause the
         head/tail sheets of the first request to be printed surrounding the file specified in the second request */
/* Modified January 1982 by E. N. Kittlitz (V-5.7) for accounting change.
      accounting:nothing; in the IODT will really do nothing in io_daemon_account_. */
/* Modified January 1983 by C. Marker  Added probe as a legal command in test mode. */
/* Modified 1984-08-17 by E. Swenson for Version 2 PNTs. */
/* Modified February 23, 1985 by C. Marker to use version 5 message segments */


/****^  HISTORY COMMENTS:
  1) change(85-02-14,Homan), approve(87-04-06,MCR7656),
     audit(87-06-13,Beattie), install(87-08-06,MR12.1-1068):
     Add support for logout_on_hangup.
  2) change(88-02-18,Brunelle), approve(88-06-02,MCR7911),
     audit(88-10-19,Wallman), install(88-11-08,MR12.2-1199):
     Upgraded to version 5 iod tables.  Add support for head/tail_sheet entry
     variables and paper_type variable.  Remove calls to head_sheet_$init &
     tail_sheet_$init.
  3) change(88-11-03,Brunelle), approve(88-11-03,MCR7911),
     audit(88-11-03,Wallman), install(88-11-08,MR12.2-1199):
     Corrected a pass-by-value problem which was causing control terminal i/o
     to go to the message coordinator.
  4) change(88-11-11,Brunelle), approve(88-11-03,PBF7911),
     audit(88-11-14,Wallman), install(88-11-14,MR12.2-1212):
     Add a 10 second wait in all non-IOM configurations to allow the
     answering service at both ends of the communications line to handle
     all the traffic generated when a re_init is signalled.
                                                   END HISTORY COMMENTS */


/* format: on */
%page;
/* ----------- ARGUMENTS ------------- */

dcl  system_dir char (*),				/* directory containing common data bases */
     testing bit (1) aligned;				/* test mode indicator */


/* --------EXTERNAL ENTRIES---------- */

dcl  aim_check_$greater_or_equal entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
dcl  charge_user_ entry (char (*), char (*), ptr, fixed bin (35));
dcl  convert_dial_message_
	entry (fixed bin (71), char (*) aligned, char (*) aligned, fixed bin, 1 aligned like status_flags,
	fixed bin (35));
dcl  convert_ipc_code_ entry (fixed bin (35));
dcl  continue_to_signal_ entry (fixed bin (35));
dcl  cv_entry_ entry (char (*), ptr, fixed bin (35)) returns (entry);
dcl  debug entry options (variable);
dcl  dial_manager_$allow_dials entry (ptr, fixed bin (35));
dcl  dial_manager_$privileged_attach entry (ptr, fixed bin (35));
dcl  dial_manager_$release_channel entry (ptr, fixed bin (35));
dcl  get_at_entry_ entry (char (*), char (*) aligned, char (*) aligned, char (*)) returns (fixed bin (35));
dcl  get_group_id_ entry () returns (char (32));
dcl  get_group_id_$tag_star entry () returns (char (32));
dcl  get_process_id_ entry () returns (bit (36));
dcl  get_authorization_ entry () returns (bit (72) aligned);
dcl  hcs_$initiate entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
dcl  hcs_$make_ptr entry (ptr, char (*), char (*), ptr, fixed bin (35));
dcl  hcs_$terminate_name entry (char (*), fixed bin (35));
dcl  hcs_$terminate_file entry (char (*), char (*) aligned, fixed bin (1), fixed bin (35));
dcl  hcs_$terminate_noname entry (ptr, fixed bin (35));
dcl  hcs_$tty_index entry (char (*) aligned, fixed bin, fixed bin, fixed bin (35));
dcl  hcs_$wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
dcl  head_sheet_$print_head_sheet entry (ptr, ptr, ptr, fixed bin (35));
dcl  head_sheet_$print_separator entry (ptr, ptr, char (*), fixed bin (35));
dcl  head_sheet_$test entry (char (*));
dcl  ioa_$ioa_stream entry () options (variable);
dcl  ioa_$rsnnl entry () options (variable);
dcl  io_daemon_account_$set_line_prices entry (fixed bin, ptr, fixed bin (35));
dcl  iodd_command_processor_$init entry (ptr);
dcl  iodd_hangup_$iodd_hangup_ entry (ptr);
dcl  iodd_msg_ entry options (variable);
dcl  iodd_quit_handler_$init entry (ptr);
dcl  iodd_signal_handler_ entry;
dcl  iodd_signal_handler_$init entry (ptr);
dcl  ios_$attach entry (char (*) aligned, char (*) aligned, char (*) aligned, char (*) aligned, bit (72) aligned);
dcl  ios_$detach entry (char (*) aligned, char (*) aligned, char (*) aligned, bit (72) aligned);
dcl  ios_$write entry (char (*) aligned, ptr, fixed bin, fixed bin, fixed bin, bit (72) aligned);
dcl  ios_$order entry (char (*) aligned, char (*) aligned, ptr, bit (72) aligned);
dcl  ipc_$drain_chn entry (fixed bin (71), fixed bin (35));
dcl  ipc_$block entry (ptr, ptr, fixed bin (35));
dcl  ipc_$create_ev_chn entry (fixed bin (71), fixed bin (35));
dcl  ipc_$decl_ev_call_chn entry (fixed bin (71), ptr, ptr, fixed bin, fixed bin (35));
dcl  ipc_$delete_ev_chn entry (fixed bin (71), fixed bin (35));
dcl  ipc_$decl_ev_wait_chn entry (fixed bin (71), fixed bin (35));
dcl  logout entry () options (variable);
dcl  message_segment_$add_file entry (char (*), char (*), ptr, fixed bin, bit (72) aligned, fixed bin (35));
dcl  iodd_parse_$command entry (char (*), ptr, fixed bin (35));
dcl  probe entry options (variable);
dcl  print_devices entry options (variable);		/* command for data in iod tables */
dcl  print_line_ids entry options (variable);		/*	"	"	*/
dcl  read_password_$switch entry (ptr, ptr, char (*), char (*), fixed bin (35));
dcl  scramble_ entry (char (8)) returns (char (8));
dcl  set_iod_val entry options (variable);
dcl  set_lock_$lock entry (bit (36) aligned, fixed bin, fixed bin (35));
dcl  tail_sheet_$print_tail_sheet entry (ptr, ptr, ptr, fixed bin (35));
dcl  timer_manager_$alarm_call entry (fixed bin (71), bit (2), entry);
dcl  timer_manager_$reset_alarm_call entry (entry);
dcl  timer_manager_$alarm_wakeup entry (fixed bin (71), bit (2), fixed bin (71));
dcl  timer_manager_$reset_alarm_wakeup entry (fixed bin (71));
dcl  timer_manager_$sleep entry (fixed bin (71), bit (2));
dcl  validate_card_input_$station entry (char (*), char (*), char (*), fixed bin (35));
dcl  write_control_form_$init entry (ptr);


/* --------- AUTOMATIC ----------- */

dcl  code fixed bin (35);
dcl  dev_label char (32);
dcl  dev_class char (32);
dcl  queue_type char (32);				/* queue_type when we need to look for it */
dcl  request_type char (64);
dcl  table_time fixed bin (71);
dcl  first_arg char (32);
dcl  second_arg char (64);
dcl  dev_name char (32) aligned;
dcl  dim_name char (32) aligned;
dcl  (i, j) fixed bin;				/* index variables */
dcl  ig char (4);					/* dummy for get_at_entry_ call */
dcl  io_stat bit (72) aligned;
dcl  line char (120);
dcl  nchars fixed bin (21);
dcl  init_ev_chan fixed bin (71);
dcl  iodc_data_ptr ptr;
dcl  seg_name char (32);				/* temp for segment initialization */
dcl  question char (64);				/* question to ask operator */
dcl  use_default bit (1);				/* switch indicating that default device classes are used */
dcl  msgp ptr;					/* pointer to the event message */
dcl  message_id bit (72) aligned;			/* id if a message segment message */
dcl  driver_dir char (168);				/* path of driver major device directory */
dcl  rqt_name char (32);
dcl  rqt_string char (168) var;
dcl  rqti_dir char (168);				/* path of dir with rqti segs */
dcl  sys_dir char (168);				/* local copy of system directory path */
dcl  meter_dir char (168);				/* path of meter data segs directory */
dcl  entry_name char (32);				/* accounting proc entry point name */
dcl  entry_variable entry variable options (variable);
dcl  times fixed bin;				/* number of times the driver tries to find cord */
dcl  temp_dir char (168) varying;
dcl  temp_dir_entry char (256);
dcl  temp_password char (8);				/* temporary for password manipulation */
dcl  temp_ptr ptr;					/* random temporary pointer variable */
dcl  input_iocbp ptr;				/* iocb pointer for reading request type data */

dcl  1 st aligned based (addr (io_stat)),		/* breakout of an ios_ status code */
       2 code fixed bin (35) aligned,
       2 stat bit (36) aligned;

dcl  temp_label label variable;			/* for the fancy footwork needed to get a */
dcl  based_ptr ptr based;				/* referencing_dir pointer for the search rules */
dcl  ref_ptr ptr;
dcl  1 driver_message aligned like new_driver_msg;	/* allocate space for mseg message  structure */
%page;

/* ----------EXTERNAL STATIC ---------- */

dcl  iodd_stat_p ptr ext static;			/* external copy of stat_p */

dcl  error_table_$ionmat fixed bin (35) ext static;
dcl  error_table_$not_detached fixed bin (35) ext static;
dcl  error_table_$not_closed fixed bin (35) ext static;
dcl  error_table_$noentry fixed bin (35) ext static;
dcl  error_table_$ai_restricted fixed bin (35) ext static;
dcl  error_table_$user_not_found fixed bin (35) ext static;
dcl  error_table_$noarg fixed bin (35) ext static;
dcl  error_table_$badopt fixed bin (35) ext static;
dcl  error_table_$no_ext_sym fixed bin (35) ext static;
dcl  error_table_$no_operation fixed bin (35) ext static;
dcl  error_table_$namedup fixed bin (35) ext static;


/* ----------- INTERNAL STATIC -------- */

dcl  io_daemon_driver_version char (8) int static options (constant) init ("5.7");
						/* current version of the driver */
dcl  null_stream char (32) int static init ("iodd_null_stream") options (constant);
dcl  bel_string char (40) aligned int static options (constant) init ((40)"");
dcl  stars char (50) aligned int static options (constant) init ((5)"**********");
dcl  error fixed bin int static options (constant) init (2);
dcl  normal fixed bin int static options (constant) init (1);
dcl  master fixed bin int static options (constant) init (1);
dcl  slave fixed bin int static options (constant) init (2);
dcl  both fixed bin int static options (constant) init (0);
dcl  id char (24) int static options (constant) init ("iodd_");
dcl  STATION_PW_PROMPT char (23) static options (constant) init ("Enter station password:");
dcl  try_10_times fixed bin int static options (constant) init (10);
dcl  try_0_times fixed bin int static options (constant) init (0);

dcl  1 real_iodd_static int static aligned like iodd_static;/* allocation of iodd_static */

dcl  NL char (1) int static options (constant) init ("
");

dcl  FF char (1) int static options (constant) init ("");

dcl  1 driver_list aligned int static,			/* this is where the driver_ptr_list is allocated */
       2 dummy (32) fixed bin (71);			/* be sure we reserve enough space for 30 drivers */


/* ----------- BUILTINS ------- */

dcl  (addr, after, before, bit, char, fixed, hbound, index, length, ltrim,
     null, ptr, rtrim, size, string, substr, unspec) builtin;
%page;

/* ---------- STRUCTURES & MISC INCLUDE FILES ---------- */

dcl  1 request_dev aligned,				/* major and minor devices to request from coord */
       2 major_name char (32),			/* name of the major device */
       2 major_index fixed bin,			/* device table index for it */
       2 n_minor fixed bin,				/* number of minor devices requested */
       2 minor (30) aligned,				/* save room for 30 minor devices */
         3 name char (32) unal,			/* minor device name...unal for the compiler */
         3 index fixed bin,				/* device table index for it */
         3 dev_class char (32),			/* expected dvc to be used */
         3 dvc_index fixed bin;			/* device class table index for the dvc */

dcl  1 event_info aligned,				/* ipc_ info from a wakeup */
       2 channel fixed bin (71),			/* event channel signaled */
       2 message fixed bin (71),			/* event message sent to us */
       2 sender bit (36),				/* sender's process id */
       2 origin,
         3 dev_signal bit (18) unal,			/* was this a process or device? */
         3 rings bit (18) unal,			/* what ring sent it? */
       2 wait_list_index fixed bin;			/* where was the channel in the wait list */

dcl  1 ev_chan_list aligned,				/* wait list for ipc_$block */
       2 number fixed bin,
       2 channel (32) fixed bin (71);

dcl  1 read_info aligned,				/* structure to be filled in by read_status order */
       2 ev_chan fixed bin (71),			/* event_channel the stream blocks on */
       2 input_pending bit (1);			/* 1 if the stream is waiting for us to read */

dcl  1 input aligned,				/* structure to hold arguments input by the operator */
       2 max fixed bin,				/* <the most tokens we ever expect */
       2 number fixed bin,				/* current number of tokens */
       2 arg (4) char (64) var;			/* text of each token */

dcl  1 status_flags aligned,				/* status structure for convert_dial_message_ */
       2 dialed_up bit (1) unal,			/* 1 = device has dialed the process */
       2 hung_up bit (1) unal,			/* 1 = device has hung up */
       2 control bit (1) unal,			/* 1 = accepted, rejected or number signal */
       2 stat_pad bit (33) unal;

dcl  1 release_arg aligned like dial_manager_arg;		/* for calls to dial_manager_$release_channel */
%page;

dcl  (quit, any_other, daemon_logout, daemon_slave_logout, program_interrupt, no_coord, seg_fault_error,
     daemon_new_device, command_error, alrm, daemon_idle) condition;
%page;

	stat_p = addr (real_iodd_static);		/* initialize the pointer used for all iodd_static references */
	sys_dir = system_dir;			/* copy the arguments */
	iodd_static.sys_dir_ptr = addr (sys_dir);	/* so we can publish the dir name */
	iodd_static.flags.test_entry = testing;
	iodd_stat_p = stat_p;			/* make it easier to create iodd procs */
	iodd_static.io_daemon_version = io_daemon_driver_version;
						/* publish the version number */
	rqti_dir = rtrim (sys_dir) || ">rqt_info_segs";	/* this is where we find rqti segs */
	meter_dir = rtrim (sys_dir) || ">meter_data";	/* this is where we find the meter data segs */
	list_ptr = addr (driver_list);
	driver_ptr_list.number = 0;
	iodd_static.auto_start_delay = 60;		/* ready for early quit, 60 sec for auto-start */
	iodd_static.timer_chan = 0;
	iodd_static.cmd_ack_chan = 0;

	iodd_static.re_init_label = re_init_driver;
	iodd_static.no_coord_label = no_coord_signal;

	call iodd_signal_handler_$init (stat_p);	/* initialize our general signal handler */

	on quit call early_quit;			/* setup some condition handlers */
	on daemon_logout go to driver_logout_label;
	on daemon_slave_logout go to driver_logout_label;
	on daemon_new_device go to start_new_device_cleanup;
						/* this is how we transfer back after new_device command */
	on daemon_idle
	     begin;
	end;					/* do nothing but grab the condition */
	on any_other call iodd_signal_handler_;		/* we don't want the standard default */
						/* handler to come to command level */

	call ios_$order ("user_i/o", "quit_enable", null (), io_stat); /* be sure quits are enabled */

	code = get_at_entry_ ("user_i/o", dim_name, dev_name, ig); /* this MUST work */

	if dim_name = "mrd_" then do;			/* separate the streams for message coord */
	     call ios_$attach ("error_i/o", "mrd_", dev_name, "", io_stat);
	     call ios_$attach ("log_i/o", "mrd_", dev_name, "", io_stat);
	end;
	else do;					/* use the same streams for consistency */
	     call ios_$attach ("error_i/o", "syn", "user_i/o", "", io_stat);
	     call ios_$attach ("log_i/o", "syn", "user_i/o", "", io_stat);
	end;

	call ios_$attach ("master_output", "syn", "user_i/o", "", io_stat);
	call ios_$attach ("master_input", "syn", "user_i/o", "", io_stat);
	call ios_$attach ("error_output", "syn", "error_i/o", "", io_stat);
	call ios_$attach ("log_output", "syn", "log_i/o", "", io_stat);

	call iox_$look_iocb ("master_output", iodd_static.master_out, code);
	call iox_$look_iocb ("master_input", iodd_static.master_in, code);
	call iox_$look_iocb ("log_output", iodd_static.log_iocbp, code);
	call iox_$look_iocb ("error_i/o", iodd_static.error_io, code);

	call iodd_msg_ (normal, master, 0, "", "^/IO Daemon Driver Version: ^a^[^/Driver running in test mode.^]^/",
	     iodd_static.io_daemon_version, iodd_static.test_entry);

	temp_label = out;				/* get a pointer to use with make_ptr for reference proc */
	ref_ptr = addr (temp_label) -> based_ptr;
%page;

	iodd_static.ctl_term.ctl_attach_name = "";	/* initialize ctl_term once here, then let */
	iodd_static.ctl_term.ctl_attach_type = 0;	/* it be handled dynamically */
	iodd_static.ctl_term.ctl_dial_chan = 0;
	iodd_static.ctl_term.ctl_ev_chan = 0;
	iodd_static.ctl_term.ctl_device = "";
	iodd_static.ctl_term.ctl_dev_dim = "";
	iodd_static.ctl_term.attached = "0"b;

new_device:					/* we come here after a new_device command (from the handler) */
	iodd_static.ctl_term.form_type = "undefined_form";/* use default unless operator changes */
	iodd_static.ctl_term.forms = "0"b;		/* don't simulate terminal FF unless asked */
	iodd_static.slave.active = "0"b;		/* be sure slave functions are dead */
	iodd_static.slave_ev_chan = 0;
	iodd_static.slave_in, iodd_static.slave_out = null;
	iodd_static.slave_input, iodd_static.slave_output = null_stream;
	iodd_static.slave.allow_quits = "0"b;
	iodd_static.slave.accept_input = "0"b;
	iodd_static.slave.print_errors = "0"b;
	iodd_static.slave.log_msg = "0"b;		/* must ask for log messages */
	iodd_static.slave.echo_cmd = "0"b;		/* no echoing of command lines */
	iodd_static.slave.priv1 = "0"b;		/* driver module defined privleges */
	iodd_static.slave.priv2 = "0"b;		/* " */
	iodd_static.slave.priv3 = "0"b;		/* " */
	iodd_static.re_init_in_progress = "0"b;		/* this is not a re_init */
	iodd_static.wakeup_time = 30;			/* default to 30 seconds between wakeups */
	iodd_static.recursion_flag = "0"b;		/* be sure these are off for testing */
	iodd_static.no_coord_flag = "0"b;
	iodd_static.initialized = "0"b;
	iodd_static.dummy_ptr = null;			/* in case it has been set */
	iodd_static.attach_type = 0;
	iodd_static.line_tab_idx = 0;
	iodd_static.major_device = "";

	if iodd_static.timer_chan ^= 0 then
	     call ipc_$delete_ev_chn (iodd_static.timer_chan, code);
	if iodd_static.cmd_ack_chan ^= 0 then
	     call ipc_$delete_ev_chn (iodd_static.cmd_ack_chan, code);

	call ipc_$create_ev_chn (iodd_static.timer_chan, code); /* get an event channel for the timer */
	if code ^= 0 then do;			/* an error is very bad */
no_ipc:
	     call convert_ipc_code_ (code);
	     call iodd_msg_ (error, master, code, id, "Fatal error: Unable to create event channel.");
	     go to out;				/* not much else to do */
	end;

	call ipc_$create_ev_chn (iodd_static.cmd_ack_chan, code);
	if code ^= 0 then
	     go to no_ipc;

	call io_daemon_account_$set_line_prices (0, null, code); /* set up default prices */
%page;

/*	Get the device name and device class from the operator */

ask_for_dev:					/* for variable line, try new station */
	if iodd_static.attach_type = ATTACH_TYPE_VARIABLE_LINE then
	     go to get_tables;

	call iodd_msg_ (normal, master, 0, "", "Enter command or device/request_type:");
						/* ask for some input */
get_dev_id:
	call iox_$get_line (iodd_static.master_in, addr (line), 120, nchars, code);
	if code ^= 0 then do;
no_master:
	     call iodd_msg_ (error, master, code, id, "Fatal_error: Unable to read from master console.");
	     go to out;
	end;
	if nchars < 2 then
	     go to get_dev_id;			/* ignore null lines */

	input.max = 4;				/* most tokens allowed */
	call iodd_parse_$command (substr (line, 1, nchars), addr (input), code);
	if code ^= 0 then
	     if code = error_table_$noarg then
		go to get_dev_id;			/* line was all blank */
	     else do;
bad_line:
		call iodd_msg_ (normal, master, 0, "", "Invalid response.  Try again.");
		go to ask_for_dev;
	     end;
	if input.arg (1) = "quit" | input.arg (1) = "logout" then
	     go to out;				/* easy out */
	if input.arg (1) = "help" then do;
	     call iodd_msg_ (normal, master, 0, "", "Enter device name and optional request type, or any of:");
	     call iodd_msg_ (normal, master, 0, "", "logout, print_devices, listen <line_id>, print_line_ids");
	     go to ask_for_dev;
	end;
	if input.arg (1) = "print_line_ids" then do;
	     call print_line_ids ("-dir", rtrim (sys_dir));
	     go to ask_for_dev;
	end;
	if input.arg (1) = "print_devices" then do;	/* he forgot the device names */
	     call print_devices ("-dir", rtrim (sys_dir), "-an", before (get_group_id_$tag_star (), ".*"));
	     go to ask_for_dev;
	end;
	if length (input.arg (1)) > length (first_arg) then
	     go to bad_line;
	first_arg = input.arg (1);			/* save intact for reinit function */
	first_arg = before (first_arg, ".");		/* if major.minor, drop minor */
	if first_arg = "" then
	     go to bad_line;
	if input.number = 1 then			/* assume second arg is null if not given */
	     if first_arg = "listen" then
		go to bad_line;			/* requires an second arg */
	     else second_arg = "";
	else do;
	     if length (input.arg (2)) > length (second_arg) then
		go to bad_line;
	     second_arg = input.arg (2);		/* save the second_arg if not too big */
	end;

get_tables:

/* This label is put here so a reinit will work even if the working tables
   have changed.  Find the tables in iod_working_tables so we can validate the
   requested device and device class */

	seg_name = "iodc_data";			/* segment name for possible error msg */
	call init_seg (sys_dir, seg_name, iodc_data_ptr, try_10_times, code);
						/* use internal proc to initiate */
	if code ^= 0 then do;
fatal_init:
	     call iodd_msg_ (error, master, code, id, "^/Fatal error:  Unable to initiate ^a in ^a", seg_name, sys_dir);
	     if iodd_static.test_entry then
		call early_quit;			/* let the quit handler take it to */
	     go to out;				/* normally there is nothing to do but quit */
	end;

	seg_name = "iod_working_tables";		/* ....for error msg */
	call init_seg (sys_dir, seg_name, ithp, try_10_times, code);
	if code ^= 0 then
	     go to fatal_init;

	if iod_tables_hdr.version ^= IODT_VERSION_5 then do;
	     call iodd_msg_ (error, master, 0, id,
		"Fatal error: Incorrect version of iod_working_tables.");
	     go to out;				/* this is really bad!! */
	end;

/*	Set the pointers to each table within the iod_working_tables */

	iodd_static.ithp = ithp;
	iodd_static.ltp, ltp = ptr (ithp, iod_tables_hdr.line_tab_offset);
	iodd_static.idtp, idtp = ptr (ithp, iod_tables_hdr.device_tab_offset);
	iodd_static.mdtp, mdtp = ptr (ithp, iod_tables_hdr.minor_device_tab_offset);
	iodd_static.qgtp, qgtp = ptr (ithp, iod_tables_hdr.q_group_tab_offset);
	iodd_static.dev_class_ptr = ptr (ithp, iod_tables_hdr.dev_class_tab_offset);
	iodd_static.text_strings_ptr, text_strings_ptr = ptr (ithp, iod_tables_hdr.text_strings_offset);

/*	see if we have to wait for a remote station to dial up  */

	iodd_static.attach_type = 0;			/* start fresh, and avoid loop if tables change */

	if first_arg = "listen" then do;		/* YES, wait for a station */
						/* first validate the line_id given from master console */
	     iodd_static.line_tab_idx = 0;
	     do i = 1 to line_tab.n_lines while (iodd_static.line_tab_idx = 0);
		ltep = addr (line_tab.entries (i));	/* get entry pointer */
		if lte.line_id = second_arg then
		     iodd_static.line_tab_idx = i;
	     end;
	     if iodd_static.line_tab_idx = 0 then do;
		call iodd_msg_ (normal, master, 0, "", "No line table entry found for ^a", second_arg);
		go to ask_for_dev;
	     end;
	     call attach_and_listen (code);		/* attach line, wait for dialup, and validate the station id */
	     if code ^= 0 then
		go to new_device;			/* just to be sure */
	     request_type = "default";		/* try for default request types */
	     input_iocbp = iodd_static.slave_in;	/* if we need to ask for a request_type */
	end;
	else do;

/* this is the normal device and request type case */
/* search for the major device in the device table */
	     request_dev.major_index = 0;
	     do i = 1 to iod_device_tab.n_devices while (request_dev.major_index = 0);
		idtep = addr (iod_device_tab.entries (i));
						/* use new ptr for easy reference */
		if idte.dev_id = first_arg then
		     request_dev.major_index = i;	/* record the index */
	     end;
	     if request_dev.major_index = 0 then do;	/* not found */
		call iodd_msg_ (normal, master, 0, "", "Device ""^a"" not found in device table.", first_arg);
		go to ask_for_dev;			/* let him try again....or quit */
	     end;
	     if idte.attach_type = ATTACH_TYPE_VARIABLE_LINE then do;
						/* can't use Line variable type here */
		call iodd_msg_ (normal, master, 0, "", "Specified device must be used with the ""listen"" command.");
		go to ask_for_dev;
	     end;
	     iodd_static.attach_type = idte.attach_type;
	     iodd_static.attach_name = idte.attach_name;	/* initialize major device info in static */
	     iodd_static.major_device, request_dev.major_name = first_arg;
	     request_type = second_arg;		/* keep first_arg and second_arg intact */
	     input_iocbp = iodd_static.master_in;	/* in case we have to ask for a request type */
	end;
%page;

/*	Find each associated minor device and save the index and default device class */

	request_dev.n_minor = 0;			/* indicate that none have been found yet */

/* look for all posible minor devices...up to the max */
	do i = idte.first_minor to idte.last_minor while (request_dev.n_minor < hbound (request_dev.minor, 1));
	     mdtep = addr (minor_device_tab.entries (i)); /* set pointer to table entry */
	     if mdte.major_index = request_dev.major_index then do;

/* we found one that belongs to the major dev */
		request_dev.n_minor = request_dev.n_minor + 1; /* count it */
		request_dev.minor.name (request_dev.n_minor) = mdte.dev_id; /* copy the minor device name */
		request_dev.minor.index (request_dev.n_minor) = i; /* save the minor index */
		request_dev.minor.dvc_index (request_dev.n_minor) = mdte.default_dev_class; /* save the default device class index */
	     end;
	end;					/* end of the table search */

	if (request_dev.n_minor > 0) & (i <= idte.last_minor) then /* see if we omitted a minor device */
	     call iodd_msg_ (normal, slave, 0, "", "Restriction: only the first ^d minor devices will be used",
		hbound (request_dev.minor, 1));

	if request_dev.n_minor = 0 then do;		/* OOPS...the table is garbage */
	     call iodd_msg_ (error, both, 0, id,
		"Fatal error: Inconsistent data in minor_device_tab. Re-init the coordinator.");
	     if iodd_static.test_entry then
		call early_quit;			/* give programmer a look */
	     go to out;				/* then give up */
	end;

/*	See if we should force the operator to give a device class */

	if request_type = "" then			/* if no optional device class was given, check n_minor */
	     if request_dev.n_minor = 1 then
		use_default = "1"b;			/* assume the default */
	     else use_default = "0"b;			/* force response for multiple devices */
	else if request_type = "default" then
	     use_default = "1"b;			/* operator overrides */
	else use_default = "0"b;			/* take the given class or ask if multiple */

/*	Now we check out each possible device class for the requested devices */

	if request_dev.n_minor > 1 | use_default then do; /* must check further for the request type(s) */
	     do i = 1 to request_dev.n_minor;		/* for multiple minor devices we must ask for each dvc */
		if ^use_default | request_dev.minor (i).dvc_index = 0 then do;
						/* no default? */
get_dvc:
		     if request_dev.minor (i).dvc_index = 0 then
			question = "Enter request type for minor device ""^a"":";
		     else question = "Enter request type (or ""default"") for minor device ""^a"":";
		     call iodd_msg_ (normal, slave, 0, "", question, request_dev.minor.name (i));
		     call iox_$control (input_iocbp, "runout", null, code);
						/* invoke remote runout spacing */
		     call iox_$get_line (input_iocbp, addr (line), 120, nchars, code);
		     if code ^= 0 then
			go to new_device;
		     if nchars < 2 then
			go to get_dvc;		/* ignore blank lines */

		     input.max = 4;			/* most tokens allowed */
		     call iodd_parse_$command (substr (line, 1, nchars), addr (input), code);
						/* see what he said */
		     if code ^= 0 then do;
			if code = error_table_$noarg then
			     go to get_dvc;		/* try again if line was blank */
			else do;
bad_dvc:
			     call iodd_msg_ (normal, slave, 0, "", "Invalid response.");
			     call iox_$control (input_iocbp, "resetread", null, code);
						/* try for a clean start */
			     request_dev.minor (i).dvc_index = 0;
						/* not sure if it is the default any more */
			     go to get_dvc;
			end;
		     end;
		     if length (input.arg (1)) > length (request_type) then
			go to bad_dvc;
		     request_type = input.arg (1);
		     if request_type = "quit" | request_type = "new_device" | request_type = "newdevice" then
			go to ask_for_dev;
		     if request_type = "default" then do; /* be sure there is a default */
			if request_dev.minor (i).dvc_index = 0 then do;
			     call iodd_msg_ (normal, slave, 0, "", "No default has been specified.");
			     go to get_dvc;
			end;
		     end;
		     else do;			/* have to search for the specified dvc */

			call find_device_class (request_type, j, dev_class, queue_type, code);
						/* use internal proc */
			if code ^= 0 then
			     go to bad_dvc;		/* let him try again...msg has been sent */

			request_dev.minor (i).dvc_index = j;
						/* store the returned index */
		     end;
		end;

/*		Now check to be sure it is legal for this process. */

		call validate_request (i, code);	/* use the internal proc */
		if code ^= 0 then
		     go to bad_dvc;			/* error has been printed already */
	     end;
	end;					/* end of dvc request loop for multiple minor devices */

	else do;					/* we have a single device and a given request_type arg */

	     call find_device_class (request_type, j, dev_class, queue_type, code);
	     if code ^= 0 then
		go to ask_for_dev;			/* the message has already been printed */

	     request_dev.minor (1).dvc_index = j;	/* store the dvc index returned */

	     call validate_request (1, code);		/* check it out */
	     if code ^= 0 then
		go to ask_for_dev;			/* if bad, start over */
	end;

/*	WHEW...Now request_dev contains all the information needed to communicate to the coordinator */
%page;

re_init_junction:

/* This is the point of entry for re-initialization of the driver after a
   "no-coord" or "re_init" signal.  We can proceed on the assumption that the
   same major and minor devices and device classes will be used. */

	iodd_static.major_device = request_dev.major_name;/* this gets cleared by kill_device, so reset in case */
	iodd_static.admin_ec_name = rtrim (request_dev.major_name) || "_admin.ec";
						/* define x cmd ec name */
	iodd_static.coord_proc_id = iodc_data.proc_id;	/* save coordinators process id */
	iodd_static.driver_proc_id = get_process_id_ ();	/* and the drivers */
	iodd_static.no_coord_flag = "1"b;		/* accept a no_coord signal now */
	iodd_static.recursion_flag = "0"b;		/* be sure this is reset for reinit */
	iodd_static.request_in_progress = "0"b;
	iodd_static.initialized = "0"b;
	iodd_static.master_hold = "0"b;
	iodd_static.slave_hold = "0"b;
	iodd_static.step = "0"b;
	iodd_static.quit_during_request = "0"b;
	iodd_static.logout_pending = "0"b;
	iodd_static.runout_requests = "0"b;
	iodd_static.quit_signaled = "0"b;
	iodd_static.auto_logout_interval = 0;		/* default to no auto logout, must be set by command */
	iodd_static.assigned_devices = 0;		/* no devices at this point */
	iodd_static.current_devices = 0;
	iodd_static.output_device = "Undefined";
	iodd_static.auto_start_delay = 60;		/* wait 60 seconds after quit before auto-start */
	if iodd_static.attach_type ^= ATTACH_TYPE_VARIABLE_LINE then do;
						/* assume attachment good for variable line */
	     iodd_static.slave_in, iodd_static.slave_out = null;
						/* for now */
	     iodd_static.slave.active = "0"b;		/* slave must be re-defined */
	     iodd_static.slave_ev_chan = 0;
	     iodd_static.slave.accept_input = "0"b;
	     iodd_static.slave.print_errors = "0"b;
	     iodd_static.slave_output = null_stream;	/* we are done with this now */
	     iodd_static.slave_input = null_stream;
	end;
	iodd_static.slave.log_msg = "0"b;		/* must ask for log messages */
	iodd_static.slave.echo_cmd = "0"b;		/* don't echo cmds by default */
	iodd_static.slave.allow_quits = "0"b;
	iodd_static.dev_io_stream = null_stream;
	iodd_static.dev_in_stream = null_stream;
	iodd_static.dev_out_stream = null_stream;
	iodd_static.driver_ptr = null ();
	iodd_static.driver_list_ptr,			/* be ready to publish the list */
	     list_ptr = addr (driver_list);

	iodd_static.chan_list_ptr = addr (ev_chan_list);	/* wait list for ipc_$block */
	iodd_static.segptr = null;			/* signal_handler cannot rely on segptr */

	call ios_$attach ("error_output", "syn", "error_i/o", "", io_stat); /* reset error_output */

	call ios_$detach ("broadcast_errors", "", "", io_stat); /* avoid multiple attachments for sure */

	call ios_$attach ("broadcast_errors", "broadcast_", "error_i/o", "", io_stat); /* put back error stream */

	iodd_static.master_output = "master_output";	/* incase they got clobbered */
	iodd_static.master_input = "master_input";	/* save the default stream names */
	iodd_static.log_stream = "log_output";

	call iox_$look_iocb ("master_output", iodd_static.master_out, code);
						/* reset the important iocb ptrs */
	call iox_$look_iocb ("master_input", iodd_static.master_in, code);
	call iox_$look_iocb ("log_output", iodd_static.log_iocbp, code);
	call iox_$look_iocb ("error_i/o", iodd_static.error_io, code);

/*        check to see if the table has changed on us since we last looked */

	on seg_fault_error begin;
	     ithp = null;				/* indicate that we need to initiate */
	     go to get_tables;			/* and go back and get new indices */
	end;

	table_time = iod_tables_hdr.date_time_compiled;	/* reference through ptr to verify it */

	revert seg_fault_error;			/* don't special case the condition any longer */


/*	With all the static data initialized, get ready to request the devices */

	rqt_string = "";				/* build this as devices are initialized */
	driver_dir = rtrim (sys_dir) || ">" || request_dev.major_name;
	init_ev_chan = iodc_data.init_event_channel;	/* copy the coord's ipc chan */
	ev_chan_list.number = 2;			/* initially 2 channels in the wait list */
	ev_chan_list.channel (1) = 0;			/* this one is empty for now */
	ev_chan_list.channel (2) = iodd_static.timer_chan;/* timer is second priority */

	driver_ptr_list.number = 0;			/* assume that no driver status segs exist */

	new_driver_msg_p = addr (driver_message);	/* this is where we build the request */
	driver_message.lock_id = "0"b;		/* this will ensure that set_lock works */

	call set_lock_$lock (driver_message.lock_id, 0, code);
						/* store process lock id */
%page;

/* At this point we will loop through the requested minor devices, asking the
   IO coordinator to establish this process as the driver.  There is a lot of
   work to do for the initialization of each driver, so, the main loop will
   take a few pages of listing */

	if iodd_static.test_entry then
	     call iodd_msg_ (normal, master, 0, "", "Requesting devices from coordinator.");

	do i = 1 to request_dev.n_minor;		/* once around for each minor dev */

	     call ipc_$create_ev_chn (driver_message.wakeup_chan, code);
						/* get a channel for the coord to use */
	     if code ^= 0 then do;
		call convert_ipc_code_ (code);
		call iodd_msg_ (error, both, code, id, "Fatal error: Unable to create minor device event channel.");
		call kill_device;			/* drop any device assigned */
		go to out;			/* thats all she wrote! */
	     end;

	     ev_chan_list.channel (1) = driver_message.wakeup_chan;
						/* get ready to block for coord */
	     driver_message.device_index = request_dev.minor (i).index;
						/* fill in the rest of the request */
	     driver_message.dev_class_index = request_dev.minor (i).dvc_index;

	     call message_segment_$add_file (sys_dir, "coord_comm.ms", new_driver_msg_p, size (new_driver_msg) * 36,
		message_id, code);			/* send off the request */

	     if code ^= 0 then do;
		call iodd_msg_ (error, both, code, id,
		     "Fatal error: Unable to send new driver request to coord_comm.ms in ^a", sys_dir);
		call kill_device;			/* drop any we have */
		if iodd_static.test_entry then
		     call early_quit;		/* give programmer a look */
		go to out;			/* then bug out */
	     end;

	     unspec (event_message) = message_id;	/* give coord the message id in an event message */

	     call hcs_$wakeup (iodd_static.coord_proc_id, init_ev_chan, event_message, code);
	     if code ^= 0 then
		signal no_coord;			/* on error assume the coord is gone */

/*	now block until the coordinator gives us the device (up to 5 min max) */

	     call ipc_$drain_chn (iodd_static.timer_chan, code);
						/* clear the timer...in case */
	     call timer_manager_$alarm_wakeup (300, RELATIVE_SECONDS, iodd_static.timer_chan);
						/* start the clock */
	     call ipc_$block (addr (ev_chan_list), addr (event_info), code);
						/* and wait */
	     call timer_manager_$reset_alarm_wakeup (iodd_static.timer_chan);
						/* reset the clock */
	     if code ^= 0 then do;			/* bad news, and dumb code */
		call convert_ipc_code_ (code);
		call iodd_msg_ (error, both, code, id, "Fatal error: from  ipc_$block .");
		call kill_device;			/* flush any previous devices */
		if iodd_static.test_entry then
		     call early_quit;		/* take a peek, */
		go to out;			/* then forget it */
	     end;

/*	It was a legal wakeup, who sent it? */

	     if event_info.wait_list_index = 2 then do;	/* bad news if it was the timer */
		call iodd_msg_ (normal, both, 0, id, "Coordinator did not respond to new driver wakeup.");
		signal no_coord;			/* don't bother to flush devices */
	     end;

	     code = addr (event_info.message) -> ev_msg.code;
						/* see what the coord said */
	     if code ^= 0 then do;

		if request_dev.n_minor = 1 then
		     dev_label = request_dev.major_name;
		else dev_label = rtrim (request_dev.major_name) || "." || request_dev.minor (i).name;

		if code = 6 then do;		/* already assigned */
		     call iodd_msg_ (normal, both, 0, id, "Device ^a assigned to another process", dev_label);
		     go to ask_for_dev;		/* don't bother to flush */
		end;
		else if code = 7 then do;		/* already assigned to us, huh? */
		     call iodd_msg_ (normal, both, 0, id, "Device ^a already assigned to this process.", dev_label);
		end;				/* tell the operator, but, keep on truckin' */
		else do;				/* otherwise it is very bad */
		     call iodd_msg_ (error, both, 0, id, "Coordinator could not initialize ^a driver. Code = ^d",
			dev_label, code);
		     call kill_device;		/* we may have had some devices assigned */
		     go to ask_for_dev;		/* start all over again */
		end;

	     end;					/* when we pass here, we are almost home free */
%page;

/*	The coord gave the OK....so find the driver status segment */

	     call hcs_$initiate (driver_dir, request_dev.minor (i).name, "", 0, 1, driver_status_ptr, code);
	     if driver_status_ptr = null then do;
		call iodd_msg_ (error, both, code, id, "Unable to initiate driver status segment: ^a in ^a",
		     request_dev.minor (i).name, driver_dir);
		call kill_device;			/* drop it */
		go to ask_for_dev;			/* and start all over...UGH! */
	     end;

	     driver_ptr_list.number = driver_ptr_list.number + 1; /* add one to the list */
	     driver_ptr_list.stat_segp (driver_ptr_list.number) = driver_status_ptr; /* save the driver ptr */
	     driver_status.driver_chan = ev_chan_list.channel (1); /* and the event channel */
	     driver_status.last_wake_time = 0;		/* havn't asked for work yet */
	     driver_status.list_index = driver_ptr_list.number; /* for the future */
	     string (driver_status.status_flags) = "0"b;	/* clear the flags */
	     driver_status.dev_ctl_ptr = null;		/* don't leave uninitialized pointers around */

/*	Now find the accounting procedure we will use for this driver */
/*	It can be different for each minor device driver */

	     dctep = addr (iodd_static.dev_class_ptr -> dev_class_tab.entries (request_dev.minor (i).dvc_index));
	     qgtep = addr (iodd_static.qgtp -> q_group_tab.entries (dcte.qgte_index));

	     driver_status.generic_type = qgte.generic_type;
						/* record generic type for minor dev */

	     if return_string (qgte.accounting) = "nothing" then /* no accounting routine */
		driver_status.have_accounting = "0"b;	/* so indicate that */
	     else do;				/* otherwise it is more trouble */
		driver_status.have_accounting = "1"b;	/* so indicate that */
		if return_string (qgte.accounting) = "system" then /* use our special procedure */
		     driver_status.acct_entry = charge_user_;
		else do;
		     temp_dir_entry = return_string (qgte.accounting);

		     driver_status.acct_entry = cv_entry_ (temp_dir_entry, null (), code);
		     if code ^= 0 then do;
			if return_string (qgte.accounting) = "system" then
			     call iodd_msg_ (error, both, code, id,
				"Unable to get pointer to system accounting procedure: ^a", temp_dir_entry);
			else call iodd_msg_ (error, both, code, id, "Unable to get pointer to accounting procedure: ^a.",
				temp_dir_entry);
			call kill_device;
			go to ask_for_dev;		/* again */
		     end;
		end;
	     end;

/*	set up the line_charge prices for this logical driver */

	     call io_daemon_account_$set_line_prices (driver_ptr_list.number, qgtep, code);
	     if code ^= 0 then do;			/* OOPS */
		call iodd_msg_ (error, both, code, id, "Unable to set line charge prices for request type ^a.",
		     driver_status.req_type_label);
		call kill_device;
		go to ask_for_dev;
	     end;
%page;

/*	now see if there is a request type info seg specified for the driver */

	     entry_name = qgte.rqti_seg_name;		/* get the entry name from the iod_tables */
	     if entry_name ^= "" then do;		/* must find the rqti seg */
		call init_seg (rqti_dir, entry_name, driver_status.rqti_ptr, try_0_times, code);
						/* don't wait */
		if driver_status.rqti_ptr = null then do;
		     call iodd_msg_ (error, both, code, id, "Unable to find RQTI segment ^a.", entry_name);
		     call kill_device;
		     go to ask_for_dev;
		end;
	     end;
	     else driver_status.rqti_ptr = null;	/* be sure of no mistake */

	     rqt_name = before (rtrim (driver_status.req_type_label), ".");
						/* get the real request type name */

	     if index (rqt_string, rtrim (rqt_name)) = 0 then /* look for duplicates */
		rqt_string = rqt_string || " " || rtrim (rqt_name); /* add to the string */

/* associate minor device with rqt name for x command */
	     call set_iod_val (rtrim (driver_status.device_id), rtrim (rqt_name));

/*	Go back and look for the next minor device driver to be assigned */

	end;					/* That's all for the big loop */

/*	Time for final initialization */

	idtep = addr (iod_device_tab.entries (request_dev.major_index)); /* locate major device data */
	iodd_static.major_args = idte.args;

/* if user says single sheet then set it, else force to continuous forms */
	if idte.paper_type = PAPER_TYPE_SINGLE then
	     iodd_static.paper_type = idte.paper_type;
	else iodd_static.paper_type = PAPER_TYPE_CONTINUOUS;

	iodd_static.assigned_devices = driver_ptr_list.number; /* start with the first in the list */
	iodd_static.driver_ptr, driver_status_ptr = driver_ptr_list.stat_segp (1);
	iodd_static.output_device = iodd_static.driver_ptr -> driver_status.device_id;

/*	call the coord again and ask for the special command IPC channel (for drivers only) */

	event_message = 0;				/* clear the event message of trash */
	msgp = addr (event_message);			/* setup event message */
	msgp -> ev_msg.code = 5;			/* code 5: requesting cmd channel */
	msgp -> ev_msg.minor_dev_index =		/* name a minor device so coord can release */
	     driver_ptr_list.stat_segp (1) -> driver_status.dev_index;
	init_ev_chan = driver_ptr_list.stat_segp (1) -> driver_status.coord_chan;

/* get request chan */

	call hcs_$wakeup (iodd_static.coord_proc_id, init_ev_chan, event_message, code);
	if code ^= 0 then
	     signal no_coord;			/* on error assume the coord is gone */

	call ipc_$drain_chn (iodd_static.timer_chan, code);
						/* clear the timer...in case */
	call timer_manager_$alarm_wakeup (300, RELATIVE_SECONDS, iodd_static.timer_chan);

/* start the clock */

	ev_chan_list.channel (1) = driver_ptr_list.stat_segp (1) -> driver_status.driver_chan;

	call ipc_$block (addr (ev_chan_list), addr (event_info), code);
						/* and wait */

	call timer_manager_$reset_alarm_wakeup (iodd_static.timer_chan);
						/* reset the clock */
	if code ^= 0 then do;			/* bad news, and dumb code */
	     call convert_ipc_code_ (code);
	     call iodd_msg_ (error, both, code, id, "Fatal error: from  ipc_$block .");
	     call kill_device;			/* flush any previous devices */
	     if iodd_static.test_entry then
		call early_quit;			/* take a peek, */
	     go to out;				/* then forget it */
	end;

	if event_info.wait_list_index = 2 then do;	/* bad news if it was the timer */
	     call iodd_msg_ (normal, both, 0, id, "Coordinator did not respond to standard wakeup.");
	     signal no_coord;			/* don't bother to flush devices */
	end;

	iodd_static.coord_cmd_chan = event_info.message;	/* save the returned ev chan */

/*	Set the entry variables for calling the driver module */

	temp_dir = return_string (idte.driver_module);
	temp_dir_entry = temp_dir || "$init";
	iodd_static.driver_init = cv_entry_ (temp_dir_entry, null (), code);
	if code ^= 0 then do;
bad_entry:
	     call iodd_msg_ (error, both, code, id, "Unable to find driver module ""^a"".", temp_dir_entry);
	     call kill_device;
	     go to ask_for_dev;
	end;

	temp_dir_entry = temp_dir || "$request";
	iodd_static.driver_request = cv_entry_ (temp_dir_entry, null (), code);
	if code ^= 0 then
	     go to bad_entry;

	temp_dir_entry = temp_dir || "$command";
	iodd_static.driver_command = cv_entry_ (temp_dir_entry, null (), code);
	if code ^= 0 then
	     go to bad_entry;

	temp_dir_entry = temp_dir || "$default_handler";
	iodd_static.driver_default_handler = cv_entry_ (temp_dir_entry, null (), code);
	if code ^= 0 then do;
	     if code ^= error_table_$no_ext_sym then
		go to bad_entry;			/* we can handle one error only */
	     else do;
		temp_dir_entry = "iodd_$iodd_";
		iodd_static.driver_default_handler = cv_entry_ (temp_dir_entry, null (), code);
		if code ^= 0 then
		     go to bad_entry;		/* perish the thought! */
	     end;
	end;

/* set the entry variables for the head_sheet entries.  If not supplied in
   iod_tables, use default of head_sheet_ */

	temp_dir = return_string (idte.head_sheet);
	if temp_dir = "" then do;
	     iodd_static.print_head_sheet = head_sheet_$print_head_sheet;
	     iodd_static.print_head_separator = head_sheet_$print_separator;
	end;
	else do;
	     temp_dir_entry = temp_dir || "$print_head_sheet";
	     iodd_static.print_head_sheet = cv_entry_ (temp_dir_entry, null (), code);
	     if code ^= 0 then do;
bad_banner_entry:
		call iodd_msg_ (error, both, code, id, "Unable to find banner page module ""^a"".", temp_dir_entry);
		call kill_device;
		go to ask_for_dev;
	     end;

	     temp_dir_entry = temp_dir || "$print_separator";
	     iodd_static.print_head_separator = cv_entry_ (temp_dir_entry, null (), code);
	     if code ^= 0 then
		go to bad_banner_entry;
	end;

	if iodd_static.test_entry then do;		/* ... and that head sheet printer can find printer_notice */
	     if temp_dir = "" then
		call head_sheet_$test (sys_dir);
	     else do;
		temp_dir_entry = temp_dir || "$test";
		entry_variable = cv_entry_ (temp_dir_entry, null (), code);
		if code ^= 0 then
		     go to bad_banner_entry;
		call entry_variable (sys_dir);
	     end;
	end;

/* set the entry variables for the tail_sheet entries */
	temp_dir = return_string (idte.tail_sheet);
	if temp_dir = "" then
	     iodd_static.print_tail_sheet = tail_sheet_$print_tail_sheet;
	else do;
	     temp_dir_entry = temp_dir || "$print_tail_sheet";
	     iodd_static.print_tail_sheet = cv_entry_ (temp_dir_entry, null (), code);
	     if code ^= 0 then
		go to bad_banner_entry;
	end;

/*	Set up the wait list for blocking, except for the ctl_term entry */

	call iox_$control (iodd_static.master_in, "read_status", addr (read_info), code);
	if code ^= 0 then do;
	     call iodd_msg_ (error, both, code, id, "Attempting read_status control on master_input.");
	     call kill_device;
	     go to out;
	end;
	ev_chan_list.channel (1) = read_info.ev_chan;	/* save the master console event channel in first position */

	do i = 1 to driver_ptr_list.number;
	     ev_chan_list.channel (i + 2) = driver_ptr_list.stat_segp (i) -> driver_status.driver_chan;
	end;					/* leave the timer chan in position 2 for now */
	ev_chan_list.number = driver_ptr_list.number + 2;

	if iodd_static.attach_type = ATTACH_TYPE_VARIABLE_LINE then /* for line variable, device is the slave */
	     ev_chan_list.channel (2) = iodd_static.slave_ev_chan; /* the slave is defined as station device */

/*	Check on the control terminal. If we have one, its ev_chan will go into position 2 after attachment */
/*	unless this is a line variable type device.  Then allow ctl term, but not as the slave. */

	if iodd_static.ctl_term.attached then do;	/* check to see if it is still dialed */
	     call check_for_dialup (code);

	     if code = 0 then
		go to set_ctl_streams;		/* if still there, finish attachments */

	     if code = 5 then do;			/* this signals we are changing ctl terminals */
		line = NL || "hangup terminal" || NL;
		call ios_$write (iodd_static.ctl_io, addr (line), 0, length (rtrim (line)), (0), io_stat);
		call ios_$order (iodd_static.ctl_io, "runout", null, io_stat);
		call ipc_$decl_ev_wait_chn (iodd_static.ctl_dial_chan, code);

/* ready for dial_manager_ */

		release_arg.version = dial_manager_arg_version_2;
		release_arg.channel_name = iodd_static.ctl_device;
		release_arg.dial_channel = iodd_static.ctl_dial_chan;
		release_arg.dial_qualifier = "";

		call dial_manager_$release_channel (addr (release_arg), code);
		if code ^= 0 then
		     call ios_$order ((iodd_static.ctl_io), "hangup", null, io_stat);

/* do what we can to drop it */
		call ipc_$delete_ev_chn (iodd_static.ctl_dial_chan, code);
						/* no longer needed */
	     end;
	     call ios_$detach (iodd_static.ctl_io, "", "", io_stat);
						/* drop the dead terminal */
	     call ios_$detach (iodd_static.ctl_input, "", "", io_stat);
	     call ios_$detach (iodd_static.ctl_output, "", "", io_stat);
	     iodd_static.ctl_term.attached = "0"b;	/* all clear now */
	end;

	iodd_static.ctl_term.ctl_attach_name = idte.ctl_attach_name;
	iodd_static.ctl_term.ctl_attach_type = idte.ctl_attach_type;

	if iodd_static.ctl_attach_type = CTL_ATTACH_TYPE_TTY | iodd_static.ctl_attach_type = CTL_ATTACH_TYPE_DIAL then do;
	     call wait_for_dial (code);		/*  must ask answering service for terminal line or for dial */
	     if code ^= 0 then do;
		if code > 10 then
		     call iodd_msg_ (normal, master, code, id, "Unable to get dialed terminal.");
		else call iodd_msg_ (normal, master, 0, id, "Unable to get dialed terminal. code = ^d", code);
		call kill_device;
		go to ask_for_dev;
	     end;
	end;
	else if iodd_static.ctl_attach_type = CTL_ATTACH_TYPE_MC then do;
						/* we want the message coordinator */
	     iodd_static.ctl_dev_dim = "mrd_";
	     iodd_static.ctl_device = idte.ctl_attach_name;
						/* attach name was the device */
	end;
	else do;					/* otherwise, no ctl_term is required */
	     iodd_static.ctl_input = null_stream;	/* be sure all variables are cleared */
	     iodd_static.ctl_output = null_stream;
	     iodd_static.ctl_io = null_stream;
	     iodd_static.ctl_dev_dim = "Undefined";
	     iodd_static.ctl_dial_chan = 0;
	     iodd_static.ctl_ev_chan = 0;		/* this means the timer chan will be a dummy */
						/* in the event wait list...it avoids errors */
	     go to call_driver;			/* ready to pass this process along */
	end;

	call ios_$attach ("ctl_i/o", iodd_static.ctl_dev_dim, iodd_static.ctl_device, "", io_stat);
	if st.code ^= 0 then do;			/* couldn't attach? */
	     if st.code = error_table_$ionmat then
		go to set_ctl_streams;		/* already attached, ??? */
	     call iodd_msg_ (normal, master, st.code, id,
		"Attaching ""ctl_i/o"" to ""^a"" with  interface module ""^a"".", iodd_static.ctl_device,
		iodd_static.ctl_dev_dim);
	     call kill_device;
	     go to ask_for_dev;			/* might be better to ask operator what to do */
	end;

set_ctl_streams:					/* set the input, output, and error streams */
	iodd_static.ctl_term.attached = "1"b;		/* this must be true in all cases */
	iodd_static.ctl_io = "ctl_i/o";
	iodd_static.ctl_input = "ctl_input";
	iodd_static.ctl_output = "ctl_output";

	if iodd_static.ctl_term.forms then
	     dim_name = "form_";			/* use the paging dim for simulating forms */
	else dim_name = "syn";

	call ios_$attach ("ctl_input", dim_name, iodd_static.ctl_io, "", io_stat);
	if st.code ^= 0 then
	     if st.code ^= error_table_$ionmat then do;	/* let it ride if attached */
syn_err:
		call iodd_msg_ (normal, master, st.code, id, "Error attaching control terminal streams. Dim: ^a",
		     dim_name);
		go to start_new_device_cleanup;
	     end;

	call ios_$attach ("ctl_output", dim_name, iodd_static.ctl_io, "", io_stat);
	if st.code ^= 0 then
	     if st.code ^= error_table_$ionmat then
		go to syn_err;

/*	Put the control terminal event channel in the wait list */

	call ios_$order (iodd_static.ctl_io, "read_status", addr (read_info), io_stat);
	if st.code ^= 0 then do;			/* did someone lie?  this should always work */
	     call iodd_msg_ (normal, master, st.code, id, """read_status"" on stream ""^a"".", iodd_static.ctl_io);
	     go to start_new_device_cleanup;
	end;

	iodd_static.ctl_ev_chan = read_info.ev_chan;	/* save here for other uses */

	if ^iodd_static.slave.active then do;		/* if active, it was a line variable type */
						/* so don't make the control terminal the salve */
	     ev_chan_list.channel (2) = read_info.ev_chan;/* slave term is lower priority than master */
	     iodd_static.slave_ev_chan = read_info.ev_chan;

/*	Set the ctl_term as the slave device. */

	     iodd_static.slave_input = iodd_static.ctl_input;
	     iodd_static.slave_output = iodd_static.ctl_output;
	     iodd_static.slave.active = "1"b;

	     call iox_$look_iocb ((iodd_static.slave_output), iodd_static.slave_out, code);
	     if code ^= 0 then do;
slave_init_err:
		call iodd_msg_ (normal, master, code, id, "Unable to find slave iocbp.");
		go to start_new_device_cleanup;
	     end;

	     call iox_$look_iocb ((iodd_static.slave_input), iodd_static.slave_in, code);
	     if code ^= 0 then
		go to slave_init_err;

	     call ios_$order (iodd_static.ctl_io, "start", null (), io_stat);
	end;
%page;

call_driver:					/* call the init entry of the driver module */
	call set_iod_val ("device", rtrim (request_dev.major_name));
						/* set values for iod_val active function */
	call set_iod_val ("station_id", rtrim (request_dev.major_name));
	call set_iod_val ("channel", rtrim (iodd_static.attach_name));
	if iodd_static.assigned_devices > 1 then
	     request_type = "";			/* define request type if only one */
	else request_type = before (iodd_static.driver_ptr -> driver_status.req_type_label, ".");
	call set_iod_val ("request_type", rtrim (request_type));
	call set_iod_val ("rqt_string", (rqt_string));	/* define all the request types for iod_admin.ec */

	if ^iodd_static.slave.active then do;		/* set slave control modes if ctl term active */
	     iodd_static.slave.allow_quits = "0"b;
	     iodd_static.slave.accept_input = "0"b;
	     iodd_static.slave.print_errors = "0"b;
	end;
	else do;
	     dim_name = "broadcast_";
	     call ios_$attach ("broadcast_errors", dim_name, iodd_static.slave_output, "", io_stat);
	     if st.code ^= 0 then
		call iodd_msg_ (normal, both, st.code, id, "Unable to attach broadcast_errors to slave.");
	     else do;
		call ios_$attach ("error_output", "syn", "broadcast_errors", "", io_stat);
		if st.code ^= 0 then
		     call iodd_msg_ (normal, both, st.code, id,
			"Unable to attach error_output stream to broadcast_errors.");
	     end;

	     iodd_static.slave.allow_quits = "1"b;
	     iodd_static.slave.accept_input = "1"b;
	     iodd_static.slave.print_errors = "1"b;
	     if iodd_static.slave_output ^= iodd_static.ctl_output then
		iodd_static.slave.log_msg = "1"b;	/* send log msgs to slave if not the ctl terminal */
	end;

	if iodd_static.test_entry then		/* see if we are testing in one process */
	     if iodd_static.coord_proc_id = iodd_static.driver_proc_id then /* make them different for locking */
		iodd_static.driver_proc_id = bit (fixed (iodd_static.driver_proc_id, 35) + 100, 36);

	call iodd_command_processor_$init (stat_p);	/* be sure these related procs are initialized */
	call iodd_quit_handler_$init (stat_p);

	call write_control_form_$init (stat_p);

	iodd_static.initialized = "1"b;		/* tell the signal handler we are initialized */


	call iodd_static.driver_init (stat_p);		/* take it away */


/*	if we return, the driver was not able to initialize.  so try again */

	call iodd_msg_ (error, both, 0, id, "Unable to initialize driver.^/");

	go to start_new_device_cleanup;		/* let the handler do the work */
%page;

out:
	if iodd_static.test_entry then do;		/* make a clean return if testing */
	     if iodd_static.attach_type = ATTACH_TYPE_VARIABLE_LINE then
		call hangup_station;
	     call ipc_$delete_ev_chn (iodd_static.timer_chan, code);
	     call ipc_$delete_ev_chn (iodd_static.cmd_ack_chan, code);
	     call ipc_$delete_ev_chn (iodd_static.ctl_dial_chan, code);
	     call ipc_$delete_ev_chn (iodd_static.dial_ev_chan, code);
	     call ios_$attach ("error_output", "syn", "user_i/o", "", io_stat);

/* put it back where we found it */
	     call ios_$detach ("broadcast_errors", "", "", io_stat);
	     call ios_$order ("user_i/o", "start", null (), io_stat);

/* in case tty dim bug gives trouble */
	     return;				/* thereby going away */
	end;
	else call logout;				/* in normal mode must log out explicitly */

start_new_device_cleanup:

/* the transfer to here will invoke all cleanup handlers */
	call ios_$attach ("error_output", "syn", "error_i/o", "", io_stat);
						/* put it back in case it was changed */

	if iodd_static.attach_type = ATTACH_TYPE_VARIABLE_LINE then
	     call hangup_station;

	call kill_device;				/* inform the coordinator that current device is gone */
	go to new_device;				/* now go back and start over */

driver_logout_label:
	if iodd_static.ctl_term.attached then do;	/* we may have a new ctl_term */
	     call ipc_$delete_ev_chn (iodd_static.ctl_dial_chan, code);
						/* tell initializer */
	     line = NL || "hangup terminal" || NL;
	     call ios_$write (iodd_static.ctl_io, addr (line), 0, length (rtrim (line)), (0), io_stat);
	     call ios_$order (iodd_static.ctl_io, "runout", null, io_stat);
	     call ios_$order (iodd_static.ctl_io, "hangup", null, io_stat);
						/* now free the tty chan */
	     call ios_$detach (iodd_static.ctl_io, "", "", io_stat);
	end;
	call kill_device;				/* tell the coord if we can */
	call hangup_station;			/* this will tell iox_ we don't have the terminal */
	go to out;				/* this will correct for test mode */

re_init_driver:

/* this will invoke all cleanup handlers */
	call kill_device;
	if iodd_static.re_init_in_progress then		/* Only way to get here with this set... */
	     if iodd_static.logout_on_hangup then do;	/* is in case of a hangup */
		call iodd_msg_ (error, both, 0, id, "Driver logging out.  (hangup_on_logout in effect.)");
		goto out;
	     end;
	iodd_static.recursion_flag = "0"b;		/* clear incase of signal during attachment */
	iodd_static.re_init_in_progress = "0"b;		/* anyone who cares already knows */
	if iodd_static.attach_type = ATTACH_TYPE_VARIABLE_LINE then do;
						/* re-validate the station if line variable type */
	     if ^iodd_static.initialized then
		call hangup_station;		/* in case remote_driver_ couldn't hangup */
	     iodd_static.initialized = "0"b;
	     iodd_static.no_coord_flag = "0"b;
	     call timer_manager_$sleep (10, RELATIVE_SECONDS);	/* let answering service clean up */
	     go to get_tables;
	end;
	iodd_static.initialized = "0"b;
	if iodd_static.attach_type ^= ATTACH_TYPE_IOM then
	     call timer_manager_$sleep (10, RELATIVE_SECONDS);	/* let answering service clean up */
	if iodd_static.no_coord_flag then
	     go to re_init_junction;
	go to new_device;

no_coord_signal:

/* this will invoke all cleanup handlers then wait for a new coordinator */
	call kill_device;				/* this is to terminate the segs */
	iodd_static.recursion_flag = "0"b;
	iodd_static.initialized = "0"b;
	iodd_static.re_init_in_progress = "0"b;		/* all who care have seen this */

	call iodd_msg_ (error, master, 0, id, "Driver will await new coordinator.");
	times = 0;

check_proc_id:
	if iodc_data.proc_id ^= (36)"0"b then
	     if iodc_data.proc_id ^= iodd_static.coord_proc_id then
						/* see if there is a new process id */
		if iodd_static.attach_type = ATTACH_TYPE_VARIABLE_LINE then
		     go to get_tables;
		else go to re_init_junction;

/* 		not changed yet, wait 30 seconds and try again */

	times = times + 1;				/* record the number of times we sleep */
	if times > 10 then do;			/* only wait 5 minutes */

	     call iodd_msg_ (error, master, 0, id, "^a^/Waited too long for coordinator. Process logging out.^/^a^a",
		stars, stars, bel_string);
	     go to driver_logout_label;		/* nothing else left to do */

	end;
	call timer_manager_$sleep (30, RELATIVE_SECONDS);		/* sleep for 30 seconds, then... */
	go to check_proc_id;			/* try again */
%page;


/* ---------INTERNAL PROCEDURES ------------ */


early_quit: proc;

/* If we get a quit before regular handler is set up */


dcl  cmd char (80);
dcl  line char (32);
dcl  nc fixed bin (21);
dcl  stat bit (72) aligned;
dcl  give_start bit (1);

	give_start = "1"b;				/* give an auto start unless something happens */

	call ioa_$ioa_stream ("user_i/o", "^/Early ""quit""^/");

	call timer_manager_$alarm_call (iodd_static.auto_start_delay, RELATIVE_SECONDS, try_auto_start);

	on alrm call continue_to_signal_ (code);	/* let this go through */

	on any_other begin;
	     give_start = "0"b;			/* stop the auto start proc */
	     call timer_manager_$reset_alarm_call (try_auto_start);
						/* in case this frame goes away */
	     call continue_to_signal_ (code);
	end;

get_line:
	call ioa_$ioa_stream ("user_i/o", "Enter command(early quit):");
	call iox_$get_line (iodd_static.master_in, addr (cmd), 80, nc, code);
						/* get a command line */
	if give_start then do;			/* expecting to give an auto start? */
	     give_start = "0"b;			/* we got something, so cancel the auto_start */
	     call timer_manager_$reset_alarm_call (try_auto_start);
						/* don't use a bad frame */
	end;
	if code ^= 0 then
	     go to no_master;

	line = substr (cmd, 1, nc - 1);
	if line = "" then
	     go to get_line;			/* be nice about blank lines */

	if line = "start" then do;
auto_start:
	     call ios_$order ("user_i/o", "start", null, stat);
						/* be sure we don't lose a wakeup */
	     return;
	end;

	else if line = "new_device" then do;
	     go to start_new_device_cleanup;
	end;

	else if line = "logout" then do;
	     go to driver_logout_label;		/* assume he really means it */
	end;

	else if line = "return" then do;		/* return to the caller of iodd_$iodd_init */
	     if iodd_static.test_entry then
		go to out;
	end;

	else if line = "debug" then do;
	     if iodd_static.test_entry then do;
		call ioa_$ioa_stream ("user_i/o", "Calling debug");
						/* let him know what we are doing */
		call debug;
		go to get_line;
	     end;
	end;

	else if line = "probe" | line = "pb" then do;
	     if iodd_static.test_entry then do;
		call ioa_$ioa_stream ("user_i/o", "Calling probe");
						/* let him know what we are doing */
		call probe;
		go to get_line;
	     end;
	end;

	else if line = "pi" then do;
	     if iodd_static.test_entry then do;
		signal program_interrupt;
		go to get_line;			/* in case it returns */
	     end;
	end;

	else if line = "." | line = "hold" then
	     go to get_line;			/* we just cancelled the auto start */

	else if line = "help" then do;		/* tell what commands can be used */
	     call ioa_$ioa_stream ("user_i/o", "Commands at this level are: hold, start, new_device, logout");
	     if iodd_static.test_entry then
		call ioa_$ioa_stream ("user_i/o", "Test commands: debug, probe, return, pi");
	     go to get_line;
	end;

	call ioa_$ioa_stream ("user_i/o", "Invalid response: ""^a""  Type ""help"" for instructions.", line);
	go to get_line;

try_auto_start: proc;

	     if give_start then do;
		call ioa_$ioa_stream ("user_i/o", "Automatic start given.");
		go to auto_start;
	     end;
	     return;				/* otherwise forget it */

	end;

     end early_quit;
%page;


init_seg: proc (dir_name, seg_name, segp, num_times, ec);

/* Little procedure to initiate segments */

dcl  seg_name char (*);
dcl  segp ptr;
dcl  dir_name char (*);
dcl  num_times fixed bin;				/* number of times we should try to initiate */
dcl  ec fixed bin (35);
dcl  times fixed bin;

          times = 0;				/* haven't tried at all yet */
try_again:					/* be sure to set reference name */
	call hcs_$initiate (dir_name, seg_name, seg_name, 0, 1, segp, ec);
	if segp = null () then
	     if ec = error_table_$namedup then do;
		call hcs_$terminate_name (seg_name, ec);
		if ec = 0 then
		     go to try_again;
		return;				/* all attempts have failed */
	     end;
	     else if ec = error_table_$noentry then do;

/* wait a bit and try again (coordinator may create seg. when it comes up) */
		times = times + 1;			/* count the number of times we try */
		if times > num_times then
		     return;			/* after num_times give up */
		call timer_manager_$sleep (30, RELATIVE_SECONDS);
		go to try_again;
	     end;
	     else return;				/* unrecoverable error */
	ec = 0;
	return;
     end init_seg;
%page;

attach_and_listen: proc (code);

dcl  station_id char (32);
dcl  code fixed bin (35);
dcl  att_desc char (256);
dcl  tries fixed bin;
dcl  station_password char (8);
dcl  cmd_msg char (32);
dcl  err_msg char (80);
dcl  len fixed bin (21);

dcl  1 hangup_info aligned,				/* structure for the "hangup_proc" control order */
       2 entry entry,				/* entry to be called */
       2 data_ptr ptr,				/* pointer to be passed to entry */
       2 priority fixed bin;				/* ipc_ call chan priority */

	code = 0;
	tries = 0;				/* count the attach attempts, allow up to five */

/* make attach description */
	call ioa_$rsnnl ("remote_teleprinter_ " || return_string (lte.att_desc), att_desc, len, lte.chan_id);

attach_chan:
	tries = tries + 1;				/* increment the attempt count */
	if tries > 5 then do;			/* over 5, give up */
	     code = error_table_$no_operation;		/* be sure we abort this device */
	     call iodd_msg_ (error, master, 0, id, "All attach attempts failed.");
						/* sound beeper */
	     return;
	end;

	call iodd_msg_ (normal, master, 0, "", "Attaching line ""^a"" on channel (^a).", lte.line_id, lte.chan_id);

	call timer_manager_$sleep (5, RELATIVE_SECONDS);		/* pause to allow answering service to catch up */

	iodd_static.major_device = "";		/* no station defined at this point */
	iodd_static.attach_type = 0;			/* nothing really attached yet either */
	iodd_static.attach_name = "";
	request_dev.major_index = 0;
	request_dev.major_name = "";

	call iox_$attach_name ("teleprinter", iodd_static.slave_in, att_desc, null, code);
	if code ^= 0 then
	     if ^(code = error_table_$ionmat | code = error_table_$not_detached) then do;
						/* very bad */
		call iodd_msg_ (normal, master, code, id, "Unable to attach line.");
		call hangup_station;		/* just to be sure */
		go to attach_chan;			/* now try again */
	     end;

	call iox_$open (iodd_static.slave_in, Stream_input_output, ""b, code);
	if code ^= 0 then
	     if code ^= error_table_$not_closed then do;
		call iodd_msg_ (normal, master, code, id, "Unable to open line io switch.");
		call hangup_station;		/* just to be sure */
		go to attach_chan;			/* now try again */
	     end;

	iodd_static.slave.active = "1"b;		/* got a live one */
	iodd_static.slave.accept_input = "1"b;
	iodd_static.slave.print_errors = "1"b;
	iodd_static.slave_out = iodd_static.slave_in;	/* they are both the same */
	iodd_static.slave_input, iodd_static.slave_output = "teleprinter";
	iodd_static.attach_type = ATTACH_TYPE_VARIABLE_LINE;
						/* tell all what we did */
	iodd_static.attach_name = lte.chan_id;

	call iox_$control (iodd_static.slave_in, "read_status", addr (read_info), code);
	if code ^= 0 then do;
	     call iodd_msg_ (normal, master, code, id, "Attempting read_status control operation.");
	     call hangup_station;
	     go to attach_chan;			/* now try again */
	end;

	iodd_static.slave_ev_chan = read_info.ev_chan;	/* save this for later */

	hangup_info.entry = iodd_hangup_$iodd_hangup_;	/* in case answering service detects a hangup */
	hangup_info.data_ptr = stat_p;
	hangup_info.priority = 1;

	call iox_$control (iodd_static.slave_in, "hangup_proc", addr (hangup_info), code);
	if code ^= 0 then
	     call iodd_msg_ (normal, master, code, id,
		"Warning: Could not establish handler for hangups from the device.");

	call iodd_msg_ (normal, master, 0, "", "Requesting station identifier on line ""^a"".", lte.line_id);

	call iox_$put_chars (iodd_static.slave_out, addr (FF), 1, code);
						/* start a new page */
	if code ^= 0 then
	     go to drop_station;

	tries = 0;				/* attempt counter is now used for station IDs */
	cmd_msg = "Enter station command:" || NL;
	go to ask_for_station;

clear_input_buffer:					/* flush all input buffers */
	call iox_$control (iodd_static.slave_in, "resetread", null, code);

ask_for_station:
	tries = tries + 1;				/* increment the count of station ids requested */
	if tries > 10 then
	     go to drop_station;			/* over the limit, hangup the intruder */

	call iox_$put_chars (iodd_static.slave_out, addr (cmd_msg), length (rtrim (cmd_msg)), code);
	if code ^= 0 then do;
drop_station:  call hangup_station;
	     call iodd_msg_ (normal, master, code, id, "Trouble initializing station.  Will re-attach line.");
	     tries = 0;				/* reset the attach counter for new station */
	     call timer_manager_$sleep (10, RELATIVE_SECONDS);	/* let the line settle or operator send quit */
	     go to attach_chan;
	end;

	call iox_$control (iodd_static.slave_out, "runout", null, code);
						/* force out the message */

/*	Look for the command line:  station <station_id> <station_password>	 */

	line = "";				/* clear the input buffer */
	call iox_$get_line (iodd_static.slave_in, addr (line), 80, len, code);
	if code ^= 0 then
	     go to drop_station;

	line = rtrim (line, " " || NL);		/* strip any new line chars */

	if index (line, "station") = 0 then
	     go to bad_cmd;

	station_id = before (ltrim (after (line, "station")), " ");

	if station_id = "" then do;
bad_cmd:	     call iodd_msg_ (normal, both, 0, "***", "Invalid station command.");
	     go to clear_input_buffer;
	end;

	station_password = before (ltrim (after (line, rtrim (station_id))), " ");
	if station_password = "" then			/* ... left off password: ask for it */
	     call read_password_$switch (iodd_static.slave_out, iodd_static.slave_in, STATION_PW_PROMPT,
		station_password, code);
	if station_password = "*" then		/* ... user really wants a blank password */
	     station_password = "";

	if station_password ^= "" then do;
	     temp_password = station_password;
	     station_password = scramble_ (temp_password);
	     temp_password = "";			/* Security */
	end;
	call validate_card_input_$station (station_id, station_password, err_msg, code);
	station_password = "";			/* Security */
	if code ^= 0 then do;
	     call iodd_msg_ (normal, both, 0, "***", "^a: ^a", err_msg, station_id);
	     go to clear_input_buffer;
	end;

/*	assume the station_id and major device are the same */

	request_dev.major_name, iodd_static.major_device = station_id;

	request_dev.major_index = 0;
	do i = 1 to iod_device_tab.n_devices while (request_dev.major_index = 0);
	     idtep = addr (iod_device_tab.entries (i));	/* use new ptr for easy reference */
	     if idte.dev_id = request_dev.major_name then
		request_dev.major_index = i;		/* record the index */
	end;
	if request_dev.major_index = 0 then do;		/* not found */
	     call iodd_msg_ (normal, both, 0, "***", "Station ""^a"" not defined in iod_tables.",
		request_dev.major_name);
	     go to clear_input_buffer;		/* let him try again....or quit */
	end;

	if substr (lte.maj_dev_list, request_dev.major_index, 1) ^= "1"b then do;
						/* OOPS */
	     call iodd_msg_ (normal, both, 0, "***", "Station ""^a"" is not permitted to use Line ""^a"".", idte.dev_id,
		lte.line_id);
	     go to clear_input_buffer;
	end;

	call iodd_msg_ (normal, master, 0, "", "Driver initializing for station:  ^a", iodd_static.major_device);

	code = 0;					/* all was well, say so */

	return;

     end attach_and_listen;
%page;

find_device_class: proc (string, ind, dev_class, request_type, ec);

/* Internal procedure to search the queue group table and the device class
   table to find the device class index for the specified input string.
   The string is in the form of request_type.dev_class with the dev_class part
   being optional, thus assuming request_type.request_type.  */

dcl  string char (*);				/* input can be no more than 64 chars */
dcl  ind fixed bin;					/* the device class index - output */
dcl  dev_class char (32);				/* device class name used - output */
dcl  request_type char (32);				/* queue group name used - output */
dcl  ec fixed bin (35);				/* error code returned */
dcl  i fixed bin;					/* random fixed bin variable */
dcl  qgt_index fixed bin;				/* index of the queue group entry in the table */


	ec = 0;					/* clear the error code */

/* break it into two components, if there.  If only one component, make
   device_class the same as request_type */

	request_type = before (string, ".");
	dev_class = after (string, ".");
	if dev_class = "" then
	     dev_class = request_type;
	if request_type = "" then do;
	     ec = error_table_$badopt;		/* first char was ".", naughty */
	     call iodd_msg_ (normal, slave, 0, "", "Illegal form of request_type: ^a", string);
	     return;
	end;

/*	search the queue group table for the requested entry */
	do i = 1 to iodd_static.qgtp -> q_group_tab.n_q_groups;
	     if iodd_static.qgtp -> q_group_tab.entries (i).name = request_type then
		go to found_group;
	end;

	call iodd_msg_ (normal, slave, 0, "", "Request type ""^a"" not found in table.", request_type);
	ec = error_table_$badopt;
	return;

found_group:
	qgtep = addr (iodd_static.qgtp -> q_group_tab.entries (i));
						/* for easy reference */
	qgt_index = i;				/* save the index for the next test */

/*	Now look in the device class table for the entry which matches the dev_class and request_type */
	do i = qgte.first_dev_class to qgte.last_dev_class;
	     dctep = addr (iodd_static.dev_class_ptr -> dev_class_tab.entries (i));
	     if dcte.qgte_index = qgt_index then	/* must belong to the request_type */
		if dcte.id = dev_class then do;	/* and be the right name */
		     ind = i;			/* return the index of the entry */
		     return;
		end;
	end;

	ec = error_table_$badopt;			/* no entry found */
	call iodd_msg_ (normal, slave, 0, "", "Device class ""^a"" not found.", dev_class);
	return;

     end find_device_class;
%page;

validate_request: proc (ind, code);

/* Internal procedure to check that the device class index for the minor
   device in the request_dev structure specified by "ind" is valid for this
   process at its current access authorization.  The IO coordinator will make
   the same checks,  this check is made so we can properly respond to the
   operator at the right time if an error occurs. */

dcl  ind fixed bin;					/* minor device index in the request_dev structure */
dcl  code fixed bin (35);				/* error code to be returned */
dcl  ec fixed bin (35);				/* local error code */
dcl  i fixed bin;					/* index variables */
dcl  authorization bit (72) aligned;			/* access authorization of process */
dcl  dev_label char (32);				/* name for messages */
dcl  allowed_name char (24);				/* driver's name max of 22 char */
dcl  allowed_proj char (12);				/* driver's project...max of 9 char */
dcl  driver_name char (24);				/* driver's name max of 22 char */
dcl  driver_proj char (12);				/* driver's project...max of 9 char */
dcl  userid char (32);				/* copy of the required driver userid */

	i = ind;					/* copy the argument */
	if request_dev.n_minor = 1 then
	     dev_label = request_dev.major_name;
	else dev_label = char (rtrim (request_dev.major_name) || "." || request_dev.minor (i).name, length (dev_label));
	if request_dev.minor (i).dvc_index = 0 then do;
	     call iodd_msg_ (normal, both, 0, "", "No default request type has been assigned to device ""^a"".",
		dev_label);
	     code = error_table_$noentry;		/* indicate an error */
	     return;				/* nothing more we can check */
	end;

	dctep = addr (iodd_static.dev_class_ptr -> dev_class_tab.entries (request_dev.minor (i).dvc_index));

	ec = 0;					/* initialize the failure indicator */

/*	First check that this minor device is allowed for this device class */
	if ^(substr (dcte.device_list, request_dev.minor (i).index, 1)) then do;
						/* if the device bit is off...too bad */
	     call iodd_msg_ (normal, both, 0, "", "Device ""^a"" is not allowed for device class ""^a"".", dev_label,
		dcte.id);
	     ec = error_table_$noentry;		/* flag the error */
						/* then keep going to give all possible errors */
	end;

/*	Now check that the process access authorization is high enough to handle all requests */

	authorization = get_authorization_ ();		/* get current authorization */

	if ^aim_check_$greater_or_equal (authorization, dcte.max_access) then do;
						/* fail if authorization is not greater or equal */
						/* to highest request driver is to handle */
	     call iodd_msg_ (normal, both, 0, "",
		"Process access authorization is not sufficient for device class ""^a"".", dcte.id);
	     ec = error_table_$ai_restricted;		/* set the failure flag */
						/* this error should be error_table_$ai_restricted */

	end;

/*	Now check for the correct process group id of the driver */

	userid = get_group_id_ ();			/* get id of driver */
	driver_name = before (userid, ".");		/* and break into components */
	driver_proj = before (after (userid, "."), ".");

/* 		get ready to look at the q_group_tab entry */

	qgtep = addr (iodd_static.qgtp -> q_group_tab.entries (dcte.qgte_index));

	userid = qgte.driver_id;			/* get id of allowed drivers */
	allowed_name = before (userid, ".");		/* and break into components */
	allowed_proj = before (after (userid, "."), ".");

	if allowed_name ^= driver_name then		/* name must be equal or "*" to be accepted */
	     if allowed_name ^= "*" then
		go to name_err;			/* too bad for him */

	if allowed_proj ^= driver_proj then do;		/* project must match */
name_err:
	     call iodd_msg_ (normal, both, 0, "", "User ""^a.^a"" not authorized as driver for request type ""^a"".",
		driver_name, driver_proj, qgte.name);	/* tell the operator */
	     ec = error_table_$user_not_found;		/* indicate failure */
	end;

/*	If all was well give back the device class name */
	if ec = 0 then
	     request_dev.minor (i).dev_class = dcte.id;	/* save the dvc name */
	code = ec;				/* report any errors */

	return;


     end validate_request;
%page;

kill_device: proc;

/* internal procedure to tell the IO coordinator that the device and all
   minor devices which have been assigned to this process should be released */

dcl  coord_chan fixed bin (71);			/* place for copy of coord ev chan */
dcl  send bit (1);					/* flag to abort sending a wakeup */
dcl  recursion_flag bit (1);
dcl  i fixed bin;					/* local index variable */
dcl  (p, p1) ptr;					/* temp ptr for easy reading */
dcl  code fixed bin (35);

          recursion_flag = "0"b;

	on command_error ;
	on any_other begin;				/* in case driver_status is gone */
	     send = "0"b;				/* abort the wakeup */
	     if recursion_flag then
		go to forget_it;
	     recursion_flag = "1"b;
	     go to term_seg;			/* but try to clean up address space */
	end;

	if driver_ptr_list.number = 0 then do;		/* see if any have been assigned */
	     send = "0"b;				/* if not, abort wakeup */
	     go to term_seg;			/* try to terminate the parent dir */
	end;
	else send = "1"b;

	event_message = 0;				/* clear the event message of trash */
	msgp = addr (event_message);			/* setup event message */
	msgp -> ev_msg.code = 4;			/* code 4: we are about to logout */
	msgp -> ev_msg.minor_dev_index =		/* name a minor device so coord can release */
	     driver_ptr_list.stat_segp (1) -> driver_status.dev_index;
	coord_chan = driver_ptr_list.stat_segp (1) -> driver_status.coord_chan;

/* save this in temp because we must terminate status seg before using it */
term_seg:
	do i = 1 to driver_ptr_list.number;		/* first terminate all driver status segs */
	     p = driver_ptr_list.stat_segp (i);
	     if send then do;			/* can we still reference a driver status seg ? */
		call ipc_$delete_ev_chn (p -> driver_status.driver_chan, code);
		p1 = p -> driver_status.rqti_ptr;	/* get rqti ptr */
		if p1 ^= null then
		     call hcs_$terminate_noname (p1, code);
						/* try to terminate */
	     end;
	     call hcs_$terminate_noname (p, code);
	     if code ^= 0 then
		call iodd_msg_ (error, master, code, "kill_device",
		     "Warning: driver status segment may be initiated.");
	end;
	if iodd_static.major_device ^= "" then do;
	     call hcs_$terminate_file (sys_dir, iodd_static.major_device, 0, code);
	     if code ^= 0 then
		call iodd_msg_ (error, master, code, "kill_device",
		     "Warning: directory ^a in ^a may not be terminated.", iodd_static.major_device, sys_dir);
	end;
	iodd_static.major_device = "";		/* the device is gone */
	driver_ptr_list.number = 0;			/* assume all driver stat segs are gone */
	if send then				/* inform the coord only after all terminations are done */
	     call hcs_$wakeup (iodd_static.coord_proc_id, coord_chan, event_message, code);

/* forget error code....can't do anything about it */
forget_it:
	return;

     end kill_device;
%page;

hangup_station: proc;

dcl  ec fixed bin (35);


	if iodd_static.slave_out ^= null then do;	/* when defined, drop it */
	     call iox_$control (iodd_static.slave_out, "hangup", null, ec);
	     call iox_$close (iodd_static.slave_out, ec);
	     call iox_$detach_iocb (iodd_static.slave_out, ec);
	end;

	iodd_static.attach_name = "";
	iodd_static.slave_out, iodd_static.slave_in = null;
	iodd_static.slave.active = "0"b;		/* slave must be re-defined */
	iodd_static.slave.allow_quits = "0"b;
	iodd_static.slave.accept_input = "0"b;
	iodd_static.slave.print_errors = "0"b;
	iodd_static.slave.log_msg = "0"b;		/* must ask for log messages */
	iodd_static.slave.echo_cmd = "0"b;		/* don't echo cmds by default */
	iodd_static.slave.priv1 = "0"b;		/* driver module defined privleges */
	iodd_static.slave.priv2 = "0"b;		/* " */
	iodd_static.slave.priv3 = "0"b;		/* " */
	iodd_static.slave_output = null_stream;		/* we are done with this now */
	iodd_static.slave_input = null_stream;

	return;

     end hangup_station;
%page;

wait_for_dial: proc (ec);

/* Internal procedure to wait for a control terminal to be dialed to the driver
   process.  We have failed badly if a non-zero value is returned in "ec".  */

dcl  ec fixed bin (35);				/* error code */
dcl  n_dev fixed bin;				/* dummy for number of dialed dev arg */
dcl  1 dial_wait aligned,				/* wait list for dial wakeup */
       2 num fixed bin,
       2 chan fixed bin (71);

dcl  1 dial_arg aligned like dial_manager_arg;

	call ipc_$create_ev_chn (iodd_static.ctl_dial_chan, ec);
	if ec ^= 0 then
	     return;

	dial_wait.num = 1;				/* we will wait on one channel */
	dial_wait.chan = iodd_static.ctl_dial_chan;	/* this one */
	dial_arg.version = dial_manager_arg_version_2;	/* use the constant */
	dial_arg.dial_qualifier = char (iodd_static.ctl_attach_name, length (dial_arg.dial_qualifier));
	dial_arg.dial_channel = dial_wait.chan;
	dial_arg.channel_name = iodd_static.ctl_attach_name;
						/* this is the tty we want */

	dial_arg.dial_out_destination = "";
	dial_arg.reservation_string = "";
	if iodd_static.ctl_attach_type = CTL_ATTACH_TYPE_TTY then do;
						/* 1 is priv attach, 2 is dial */

	     call dial_manager_$privileged_attach (addr (dial_arg), ec);
						/* ask for it */
	     if ec ^= 0 then
		return;				/* if all is well we will wait */
	     call iodd_msg_ (normal, both, 0, "",
		"^a driver waiting for control terminal channel ""^a"" to become active.", iodd_static.major_device,
		iodd_static.ctl_attach_name);		/* tell operator */
	end;
	else do;					/* this is the dial case */
	     call dial_manager_$allow_dials (addr (dial_arg), ec);
	     if ec ^= 0 then
		return;

	     call iodd_msg_ (normal, both, 0, "", "^a driver waiting for control terminal ""^a"" to dial.",
		iodd_static.major_device, iodd_static.ctl_term.ctl_attach_name);
						/* tell operator we are waiting */
	end;

wait:
	call ipc_$block (addr (dial_wait), addr (event_info), ec);
	if ec ^= 0 then
	     return;

	call convert_dial_message_ (event_info.message, dev_name, dim_name, n_dev, status_flags, ec);
	if ec ^= 0 then
	     return;

	if status_flags.hung_up then do;		/* someone sent a hangup?? */
	     call iodd_hangup_$iodd_hangup_ (addr (event_info));
	     go to wait;				/* in case it returns */
	end;
	if ^status_flags.dialed_up then
	     go to wait;				/* we wait until a "dial" is received */

	iodd_static.ctl_device = dev_name;		/* save the device name here */
	iodd_static.ctl_dev_dim = dim_name;		/* and the dim */

	call hcs_$make_ptr (ref_ptr, "iodd_hangup_", "iodd_hangup_", temp_ptr, ec);
						/* for ipc_ call chan */
	if ec ^= 0 then
	     return;

	call ipc_$decl_ev_call_chn (iodd_static.ctl_dial_chan, temp_ptr, stat_p, 1, ec);
	if ec ^= 0 then
	     return;

	call iodd_msg_ (normal, both, 0, "", "Control terminal accepted.");
	return;

     end wait_for_dial;
%page;

check_for_dialup: proc (ec);


/* This internal procedure checks to be sure the control terminal is in the
   dialed up state.  The driver can do I/O to the terminal only when it is in
   the dialed up state.  Otherwise com_err_ and ioa_ will signal "io_error"
   when trying to write on the control terminal.  That causes nasty things to
   happen.

   Due to insufficient data from the standard tty dim, we have to call the
   hardcore tty interface directly.  This should be a temporary measure
   until a new order call can be defined.   (JCW - Jan 1975)

   Note, due to the use of the hardcore tty interface, this procedure cannot
   be used for a control terminal attached through mrd_.
*/

dcl  ec fixed bin (35);				/* error code to be returned */
dcl  tw_index fixed bin;				/* device index of the tty channel */
dcl  state fixed bin;				/* device state that we are after */
						/* 1 = inactive  - this cannot happen (they say) */
						/* 2 = waiting   - terminal is not there */
						/* 5 = dialed up - on this state we can go */

	ec = 0;					/* start clean */

	if iodd_static.ctl_attach_name ^= idte.ctl_attach_name
	     | iodd_static.ctl_attach_type ^= idte.ctl_attach_type then do; /* same device? */
	     ec = 5;				/* the changing device code for caller */
	     return;
	end;

	if iodd_static.ctl_dev_dim = "mrd_" then
	     return;				/* this is never a problem */

	call hcs_$tty_index (iodd_static.ctl_device, tw_index, state, ec);
	if ec ^= 0 then
	     return;				/* let caller handle all errors */

	if state ^= 5 then
	     ec = 10;				/* if not dialed up, drop the terminal */

	return;

     end check_for_dialup;
%page;

return_string: proc (target) returns (char (*));

/* little procedure to return a string from text_strings.chars given the
   first char index and total number of chars in the string */

dcl  1 target unaligned like text_offset;

	if target.total_chars = 0 then
	     return ("");
	else return (
		substr (iodd_static.text_strings_ptr -> text_strings.chars,
		target.first_char, target.total_chars)
		);

     end return_string;
%page; %include device_class;
%page; %include dial_manager_arg;
%page; %include driver_ptr_list;
%page; %include driver_status;
%page; %include iod_constants;
%page; %include iod_device_tab;
%page; %include iod_event_message;
%page; %include iod_line_tab;
%page; %include iod_tables_hdr;
%page; %include iodc_data;
%page; %include iodd_static;
%page; %include iox_dcls;
%page; %include iox_modes;
%page; %include mseg_message_info;
%page; %include new_driver_msg;
%page; %include q_group_tab;
%page; %include request_descriptor;
%page; %include timer_manager_constants;

     end iodd_;
