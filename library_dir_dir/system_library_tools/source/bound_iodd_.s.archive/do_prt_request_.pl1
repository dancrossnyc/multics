/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1990   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/* format: style4 */

/* Procedure for printing I/O Daemon dprint requests */

/* format: off */

/* Adapted from output_request_ by J. C. Whitmore, Sept. 1977 */
/* Modified by J. C. Whitmore, 4/78, for new dprint message format and bug fix */
/* Modified by J. C. Whitmore, 7/78, for auto defer; cancel delete on device error; save current request */
/* Modified by J. C. Whitmore, 11/78, to add path to device error msg, notify user on deferring request, and
      fix req_status arg error msg */
/* Modified by J. C. Whitmore, 3/79, to correct the size of string variables for correct assignments */
/* Modified by J. C. Whitmore, 5/79, to use end-of-page order only when printing page labels */
/* Modified by C. Hornig, 6/79, to take prt_ctl information out of static */
/* Modified by J. C. Whitmore, 1/80, to limit the scope of system_privileges_ for send mail (V5.4) */
/* Modified 04/01/81 by GA Texada to 1) make labels work all the time
			       2) call head_sheet_$test when in a test environment */
/* Modified: 11 December 1981 by G. Palter to support force_ctl_char, remove the call to head_sheet_$test as it has been
      moved to iodd_ where it belongs,  and fix the following io_daemon error list entries:
         0003: phx06955 phx11428
	  When running an I/O daemon through remote_driver_ with the line specified as "user_i/o", the message printed
	  by the "restart" request is cutoff in the middle as it is printed immediately before a "resetwrite" control
	  order
         0010: phx09171
	  The module do_prt_request_ should issue a "runout" order after printing the tail sheet and before printing the
	  charge message; otherwise, the charge message may appear in the middle of the tail sheet on remote printers
	  with no attached console */
/* Modified: November 1983 by C. Marker added support for force_nsep and no_separator */
/* Modified: 25 June 1984 by C. Marker changed to notify the user when unable to set line modes. */
/* Modified: 22 February 1984 by C. Marker changed to check if the page labels are the same as the access class of the segment and call access_audit_gate_$log_obj_ptr_user if they are not.  Changed to use version 5 message segments. */


/****^  HISTORY COMMENTS:
  1) change(87-05-10,Gilcrease), approve(87-08-06,MCR7686),
     audit(88-02-01,Farley), install(88-02-02,MR12.2-1019):
     Implement -nb output.
  2) change(88-10-24,Brunelle), approve(88-10-24,MCR7911),
     audit(88-10-25,Wallman), install(88-10-28,MR12.2-1199):
     Upgrade to support version 5 of I/O daemon tables.  Also support single &
     continuous forms paper; new head & tail sheet entry variables in
     iodd_static; forms processing control string for single sheet paper; etc.
  3) change(88-11-11,Brunelle), approve(88-11-11,MCR7911),
     audit(88-11-14,Wallman), install(88-11-14,MR12.2-1212):
     Correct problem of not suppressing trailing blank pages.
  4) change(90-09-10,Itani), approve(90-09-10,MCR8198),
     audit(90-09-21,WAAnderson), install(90-10-01,MR12.4-1034):
     Correct the problem of indenting centered labels.
                                                   END HISTORY COMMENTS */

/* format: on */

do_prt_request_: procedure (a_iocbp, a_stat_p, a_code);

/* Parameters */

dcl  a_iocbp ptr;					/* ptr to the io control block for iox_ */
dcl  a_stat_p ptr;					/* the value of stat_p from caller */
dcl  a_code fixed bin (35);				/* error code....used for driver_fatal_error */

/* Automatic */

dcl  access_class bit (72) aligned;			/* access class of user file */
dcl  auth bit (72) aligned;				/* authorization used to set banner access class */
dcl  auth_string char (680);				/* string form of auth */
dcl  char_count fixed bin (24);			/* total number of chars if the file */
dcl  chars_done fixed bin (24);			/* total chars printed between head & tail sheets */
dcl  chgsw bit (1);					/* indicate whether to charge */
dcl  ck_interval fixed bin;				/* number of lines between checkpoints */
dcl  ck_mode char (12) aligned;			/* mode string for prtdim to set checkpoints */
dcl  cmd_line char (80);				/* space for operator commands */
dcl  code fixed bin (35);
dcl  continuous_paper bit (1);			/* OFF is single sheet paper */
dcl  control bit (36) aligned;
dcl  copies_left fixed bin;				/* number if copies to be done this time thorugh */
dcl  ctl_msg_sent bit (1);
dcl  delete_msg char (32);
dcl  desc_ptr ptr;
dcl  dest char (24) aligned;
dcl  device_error bit (1);
dcl  ename char (32) aligned;				/* entry name of file for output */
dcl  err_mess char (200) var;
dcl  fcbp ptr;
dcl  force_ck_pt bit (1) aligned;
dcl  full_path char (168) aligned;
dcl  head char (64) aligned;				/* temp for the header */
dcl  header_done bit (1);				/* TRUE when header is printed */
dcl  how fixed bin;					/* code for how the segment should be printed */
dcl  i fixed bin;
dcl  iocbp ptr;
dcl  l fixed bin (24);
dcl  last_error_count fixed bin;			/* last printer error count read */
dcl  lg_msg char (100) aligned;
dcl  lg_sw bit (1) aligned;
dcl  line_mode char (32);				/* request modes for length & indentation */
dcl  mailname char (32) aligned;
dcl  max_comp fixed bin;
dcl  msg char (256) aligned;				/* space for operator messages */
dcl  n_sample_pages fixed bin;			/* count sample pages, to maintain alignment of paper */
dcl  nep_mode_set bit (1);				/* TRUE if request is being done in nep mode */
dcl  new_clock fixed bin (71);
dcl  new_cpu fixed bin (52);
dcl  new_pp fixed bin;
dcl  new_rate fixed bin (35);				/* new estimate of transmission rate */
dcl  new_waits fixed bin (35);
dcl  nt fixed bin (24);				/* number of elements processed on read */
dcl  old_clock fixed bin (71);
dcl  old_cpu fixed bin (52);
dcl  old_pp fixed bin;
dcl  old_rate fixed bin (35);
dcl  old_waits fixed bin (35);
dcl  omode char (256);				/* mode returned form dim */
dcl  paper_not_aligned bit (1) aligned;
dcl  pic picture "(11)-9";				/* dummy for fixed bin to char conversion */
dcl  printing bit (1);				/* TRUE when the actual printing is in progress */
dcl  restart_source fixed bin;			/* restart was from master or slave */
dcl  seconds fixed bin;
dcl  segp ptr;
dcl  set_page_labels bit (1);				/* TRUE - when we want to set labels */
dcl  short_msg char (8) aligned;
dcl  source fixed bin;				/* cmd source, master or slave */
dcl  start_char_offset fixed bin (24);			/* file offset at start of printing */
dcl  start_segp pointer;				/* pointer to first component if MSF otherwise to segment */
dcl  starting_page fixed bin (24);
dcl  stream char (32);				/* stream name for ios_ */
dcl  terminal (2) char (32);				/* streams for 1) master, or 2) slave */
dcl  time_est fixed bin;				/* estimated number of seconds to process request */
dcl  user_dir char (168) aligned;			/* directory containing users' segment */
dcl  val fixed bin;					/* for validation level */

%page;

/* Internal Static */

dcl  whoami char (32) int static options (constant) init ("do_prt_request_");
dcl  master fixed bin int static options (constant) init (1);
dcl  slave fixed bin int static options (constant) init (2);
dcl  (both, log) fixed bin int static options (constant) init (0);
dcl  normal fixed bin int static options (constant) init (1); /* normal streams for opr msgs */
dcl  error fixed bin int static options (constant) init (2);/* code for error streams */
dcl  tell_user bit (1) int static options (constant) init ("1"b); /* force error msg to user */
						/* go by user notify flag */

/* the following variables are for call to output_file */
dcl  PRINT fixed bin int static options (constant) init (1);
dcl  SAMPLE fixed bin int static options (constant) init (2);
dcl  SKIP fixed bin int static options (constant) init (3);
dcl  SAVE fixed bin int static options (constant) init (4);

dcl  factor float bin int static options (constant) init (0.75e0); /* smoothing factor for rate estimate */
dcl  stars char (40) int static options (constant) aligned init ((40)"*"); /* For error messages */

dcl  privileged bit (1) static init ("1"b);		/* TRUE if we can call phcs_ */
dcl  sys_priv bit (1) static init ("1"b);		/* TRUE if process cal call system_privilege_ */
dcl  first_call bit (1) static init ("1"b);		/* TRUE on first call */
dcl  fault_name char (32) aligned int static;
dcl  request_data_p ptr int static init (null);

dcl  err_label label int static;			/* point of return from condition handler */

dcl  bad_chars char (5) defined BAD_CHARS position (2);
dcl  nl_vt_ff char (3) defined BAD_CHARS position (4);	/* vert carriage control chars */
dcl  space_ht_bs char (3) defined BAD_CHARS position (1);	/* horiz carriage control chars */
dcl  VT char (1) defined BAD_CHARS position (5);		/* the vertical tab character */
dcl  FF char (1) defined BAD_CHARS position (6);		/* the form feed character */
						/* SP HT BS NL VT FF */
dcl  BAD_CHARS char (6) int static options (constant) init (" 	
");

/* External static */

dcl  access_operations_$io_daemon_set_page_labels bit (36) aligned external static;
dcl  error_table_$action_not_performed fixed bin (35) ext static;
dcl  error_table_$ai_restricted ext static fixed bin (35);
dcl  error_table_$dirseg ext static fixed bin (35);
dcl  error_table_$eof_record fixed bin (35) ext static;
dcl  error_table_$improper_data_format fixed bin (35) ext static;
dcl  error_table_$moderr fixed bin (35) ext static;
dcl  error_table_$noarg fixed bin (35) ext static;
dcl  error_table_$noentry fixed bin (35) ext static;
dcl  error_table_$out_of_bounds fixed bin (35) ext static;
dcl  error_table_$request_pending fixed bin (35) ext static;

%page;

/* External Entries */

dcl  access_audit_gate_$log_obj_ptr_user entry options (variable);
dcl  aim_check_$equal entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
dcl  aim_check_$greater entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
dcl  clock_ ext entry returns (fixed bin (71));		/* gets clock time */
dcl  continue_to_signal_ entry (fixed bin (35));
dcl  convert_authorization_$from_string entry (bit (72) aligned, char (*), fixed bin (35));
dcl  convert_authorization_$to_string entry (bit (72) aligned, char (*), fixed bin (35));
dcl  convert_ipc_code_ entry (fixed bin (35));
dcl  convert_status_code_ entry (fixed bin (35), char (*) aligned, char (*) aligned);
dcl  cpu_time_and_paging_ entry (fixed bin (35), fixed bin (52), fixed bin);
dcl  cu_$level_get entry (fixed bin);
dcl  date_time_ entry (fixed bin (71), char (*) aligned);
dcl  hcs_$fs_get_mode ext entry (ptr, fixed bin (5), fixed bin (35));
dcl  hcs_$fs_get_path_name entry (ptr, char (*) aligned, fixed bin, char (*) aligned, fixed bin (35));
dcl  hcs_$get_access_class entry (char (*) aligned, char (*) aligned, bit (72) aligned, fixed bin (35));
dcl  hcs_$get_user_effmode entry (char (*) aligned, char (*) aligned, char (*) aligned, fixed bin, fixed bin (5), fixed bin (35));
dcl  hcs_$status_minf entry (char (*) aligned, char (*) aligned, fixed bin, fixed bin (2), fixed bin (24), fixed bin (35));
dcl  io_daemon_account_ entry (entry, ptr);
dcl  ioa_$rsnnl entry options (variable);
dcl  iodd_command_processor_ entry (fixed bin, fixed bin, char (*), fixed bin (35));
dcl  iodd_get_cmd_ entry (ptr, fixed bin, fixed bin (24), bit (36) aligned, char (*), fixed bin, fixed bin (35));
dcl  iodd_msg_ entry options (variable);
dcl  iodd_parse_$args entry (char (*) var, char (*)) returns (char (256) var);
dcl  iodd_parse_$command entry (char (*), ptr, fixed bin (35));
dcl  iox_$control entry (ptr, char (*), ptr, fixed bin (35));
dcl  iox_$modes entry (ptr, char (*), char (*), fixed bin (35));
dcl  iox_$put_chars entry (ptr, ptr, fixed bin (24), fixed bin (35));
dcl  ipc_$block entry (ptr, ptr, fixed bin (35));
dcl  ipc_$drain_chn entry (fixed bin (71), fixed bin (35));
dcl  msf_manager_$close entry (ptr);
dcl  msf_manager_$get_ptr entry (ptr, fixed bin, bit (1), ptr, fixed bin (24), fixed bin (35));
dcl  msf_manager_$open entry (char (*) aligned, char (*) aligned, ptr, fixed bin (35));
dcl  phcs_$deactivate entry (ptr, fixed bin (35));
dcl  phcs_$set_kst_attributes entry (fixed bin, ptr, fixed bin (35));
dcl  probe entry ();
dcl  read_allowed_ entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
dcl  send_mail_$access_class entry (char (*) aligned, char (*) aligned, ptr, bit (72) aligned, fixed bin (35));
dcl  sys_info$max_seg_size fixed bin (35) ext static;
dcl  system_privilege_$ipc_priv_off entry (fixed bin (35));
dcl  system_privilege_$ipc_priv_on entry (fixed bin (35));
dcl  system_privilege_$ring1_priv_off entry (fixed bin (35));
dcl  system_privilege_$ring1_priv_on entry (fixed bin (35));
dcl  timer_manager_$alarm_wakeup entry (fixed bin (71), bit (2) aligned, fixed bin (71));
dcl  write_control_form_ entry (char (*) aligned, char (*) aligned, ptr, fixed bin (35));

%page;

/* Structures */

dcl  1 ksta like kst_attributes aligned internal static;

dcl  1 current aligned like print_driver_data.checkpoint;	/* this defines the current position in the file */

dcl  1 ck aligned,					/* The checkpoint history for the current file */
       2 last fixed bin,				/* The last entry in the chain */
       2 entry (10),				/* one entry for each checkpoint */
         3 forward fixed bin,				/* the forward thread */
         3 point like print_driver_data.checkpoint;	/* this is the checkpoint data */

dcl  1 position aligned like position_data;		/* see prt_order_info.incl.pl1 */
dcl  1 pg_labels aligned like page_labels;		/* see prt_order_info.incl.pl1 */
dcl  1 paper_info_data aligned like paper_info;		/* see prt_order_info.incl.pl1 */

dcl  1 static_ctl aligned int static like prt_ctl;	/* the default control values */

dcl  1 arg_list aligned,				/* for parsing command lines */
       2 max_tokens fixed bin,			/* the amount of space allocated */
       2 n_tokens fixed bin,				/* the number of tokens in the line */
       2 cmd char (64) var,				/* first token is the command */
       2 arg (3) char (64) var;			/* we allow three arguments max */

dcl  1 ctl_wait_list aligned int static,		/* we block on this list for ctl form sync */
       2 number fixed bin,				/* number of ipc channels */
       2 channel fixed bin (71);			/* this is the channel (only one) */


/* Builtins */

dcl  (addr, baseno, binary, bit, char, convert, divide, fixed, float,
     hbound, length, ltrim, min, mod, null, rtrim, string, substr, translate,
     unspec, verify) builtin;


/* Conditions */

dcl  (cleanup, linkage_error, daemon_again, daemon_again_slave, daemon_kill,
     daemon_defer, daemon_cancel, daemon_save, size, conversion, any_other)
	condition;

%page;

/* Copy arguments and initialize pointers and control switches */

	stat_p = a_stat_p;
	iocbp = a_iocbp;
	a_code = 0;				/* set to zero for now */
	chgsw = "0"b;				/* assume no charge yet */
	header_done = "0"b;				/* header not done yet */
	set_page_labels = "0"b;			/* start with no labels assumed */
	ck.last = 1;				/* use first checkpoint entry */
	arg_list.max_tokens = 4;			/* only 4 tokens allowed in command lines */

	terminal (master) = "user_output";		/* stream for master terminal output */
	terminal (slave) = iodd_static.slave_output;	/* check for active before use */
	last_error_count = -1;			/* set to undefined */
	printing = "0"b;				/* tell handler for daemon_save - not printing yet */
	continuous_paper = (iodd_static.paper_type = PAPER_TYPE_CONTINUOUS);

	if first_call then do;			/* init variables and see if we have phcs_ access */
	     call init_static_ctl ();
	     on linkage_error
		begin;
		privileged = "0"b;
		go to tough;
	     end;
	     string (ksta) = "0"b;			/*  make a null structure */
	     call phcs_$set_kst_attributes (binary (baseno (stat_p), 18), addr (ksta), (0));

/* This is a NOP - structure is 0. If we get here we are privileged */
	     ksta.set.tpd, ksta.value.tpd = "1"b;	/* Dont put on bulkstore just for lil ole me */
	     ksta.set.explicit_deactivate_ok, ksta.value.explicit_deactivate_ok = "1"b;
	     ksta.set.allow_write = "1"b;		/* Dont let me wreck user seg by accident */
	     ksta.set.tus, ksta.value.tus = "1"b;	/* Save a vtoc write */
tough:	     revert linkage_error;
	     first_call = "0"b;			/* First call initialization is done */
	end;
	if iodd_static.ctl_term.attached then do;	/* get ready to send message to ctl term */
	     ctl_wait_list.number = 1;
	     ctl_wait_list.channel = iodd_static.ctl_ev_chan;
	end;
	else ctl_wait_list.number = 0;		/* don't try to use this */

	driver_status_ptr = iodd_static.driver_ptr;	/* get ptr to the current driver status seg */
	evaluate_forms_info_output_ptr = driver_status.forms_validation_ptr;
	prt_ctl_ptr = driver_status.dev_ctl_ptr;	/* get print control information */
	if prt_ctl_ptr = null () then
	     prt_ctl_ptr = addr (static_ctl);		/* default values */
	desc_ptr = addr (driver_status.descriptor);	/* and to the request descriptor */
	mseg_message_info_ptr = desc_ptr;		/* first part of desciptor is mseg_message_info */
	dmp = addr (driver_status.message);		/* set dprint_msg default pointer */
	driver_data_p = addr (desc_ptr -> request_descriptor.driver_data); /* get ptr to printer_driver_data */
	request_data_p = addr (REQUEST);		/* for the single copy entry */
	fcbp, segp = null;				/* set up for cleanup handler */
	start_segp = null;
	stream = driver_status.dev_out_stream;		/* record the switch name for easy reference */

	on cleanup call clean_proc ();		/* establish a cleanup handler */

	err_label = abort_request;

/* Set up master structure used by this pgm. */

	string (REQUEST.control_flags) = ""b;		/* clear all the flags */
	REQUEST.requestor = mseg_message_info.sender_id;
	REQUEST.continued = desc_ptr -> request_descriptor.continued;
	REQUEST.restarted = desc_ptr -> request_descriptor.restarted;
	REQUEST.priority_request = desc_ptr -> request_descriptor.priority_request;
	REQUEST.separator = "1"b;			/* we always want a print separator first time */
	REQUEST.device_name = driver_status.dev_name_label;
	REQUEST.request_type = driver_status.req_type_label;
	REQUEST.queue = desc_ptr -> request_descriptor.q;
	REQUEST.charge_queue = desc_ptr -> request_descriptor.charge_q; /* coord may want a priority rate */
	REQUEST.request_no = desc_ptr -> request_descriptor.seq_id; /* coord assigned the number */
	REQUEST.restart_no = desc_ptr -> request_descriptor.prev_seq_id; /* previous number of request (0 = not restarted) */
	REQUEST.contd_no = desc_ptr -> request_descriptor.contd_seq_id; /* previous number of continued request (0 = not continued) */
	REQUEST.dpmp = dmp;
	if dprint_msg.delete_sw then
	     REQUEST.delete = 1;
	else REQUEST.delete = 0;
	REQUEST.line_nbrs = dprint_msg.line_nbrs;
	REQUEST.single_sheet = (iodd_static.paper_type = PAPER_TYPE_SINGLE);
	REQUEST.bit_count = 0;
	REQUEST.line_count = 0;
	REQUEST.page_count = 0;
	REQUEST.punsw = 0;				/* we are printing only */
	REQUEST.copies = dprint_msg.copies;
	REQUEST.no_separator = dprint_msg.no_separator | prt_ctl.force_nsep;
	if ^(REQUEST.continued | REQUEST.restarted) then
	     print_driver_data.copies_done = 0;		/* no copies assumed, unless continued or restarted */
						/* if none completed, it's not continued */
	else if print_driver_data.copies_done < 1 then
	     REQUEST.continued = "0"b;
	print_driver_data.copies_done = min (print_driver_data.copies_done, REQUEST.copies - 1); /* be sure we do at least one copy */
	copies_left = REQUEST.copies - print_driver_data.copies_done; /* might be partly done */
	REQUEST.copy_no = print_driver_data.copies_done + 1; /* we start with the next copy */
	REQUEST.notify = dprint_msg.notify;
	REQUEST.output_mode = "";			/* clear in case of error message */
	REQUEST.total_charge = 0e0;
	REQUEST.charge = 0e0;
	REQUEST.time_start_request = clock_ ();
	call date_time_ (REQUEST.time_start_request, REQUEST.date_time_start_request);

	l = length (rtrim (REQUEST.requestor)) - 2;	/* get length of Person.Project */
	mailname = substr (REQUEST.requestor, 1, l);
	unspec (send_mail_info) = "0"b;
	send_mail_info.version = send_mail_info_version_2;
	send_mail_info.wakeup = "1"b;
	send_mail_info.always_add = "1"b;
	send_mail_info.sent_from = REQUEST.request_type;

/* get pathname of file for operator and error messages */

	user_dir = dprint_msg.dirname;
	ename = dprint_msg.ename;
	call ioa_$rsnnl ("^a^[>^]^a", full_path, l, user_dir, (user_dir ^= ">"), ename);

	REQUEST.full_path = translate (full_path, "", bad_chars); /* force a page fault - HARDWARE BUG WRITEAROUND */
	full_path = translate (full_path, "", bad_chars); /* remove bad chars for banner */
	dprint_msg.destination = translate (dprint_msg.destination, "", bad_chars);
	dprint_msg.heading = translate (dprint_msg.heading, "", bad_chars);
	REQUEST.full_path = full_path;		/* save the clean copy */

/*  record the processing of this request in the log  */

	head = dprint_msg.heading;
	if substr (head, 1, 5) = " for " then		/* see if dprint added something */
	     head = substr (head, 6);			/* if so get rid of it */
	if head ^= "" then
	     call ioa_$rsnnl ("(for ""^a"" ", msg, l, head);
	else do;
	     l = 1;				/* no heading, get ready for a dest msg */
	     msg = "(";
	end;

	dest = dprint_msg.destination;
	if dest ^= "" then
	     call ioa_$rsnnl ("^vaat ""^a"")", msg, l, (l), substr (msg, 1, l), dest);
	else if l = 1 then
	     msg = "";				/* no head or dest case */
	else substr (msg, l, 1) = ")";		/* heading only case */

	call iodd_msg_ (log, both, 0, "",		/* let the subr do the work */
	     "Request ^d ^a q^d:  ^a^/^2x^[(^d copies) ^;^s^]^[priority ^d ^;^s^]from ^a ^a", REQUEST.request_no,
	     REQUEST.request_type, REQUEST.queue, full_path, (copies_left > 1), copies_left, REQUEST.priority_request,
	     REQUEST.charge_queue, REQUEST.requestor, msg);

/* Now we can print a header banner if an error occurs */

	err_mess = full_path;			/* let this sit here in case */

/* Find the access class to use for the banner */

	if aim_check_$greater (mseg_message_info.sender_authorization, driver_status.min_banner) then
	     auth = mseg_message_info.sender_authorization;
	else auth = driver_status.min_banner;		/* mark the output with auth */

	call convert_authorization_$to_string (auth, auth_string, code); /* get string form */
	if code ^= 0 then do;			/* oops....bad news */
	     call fatal_error (tell_user);		/* tell the operator, and user */
	     go to clean_out;			/* drop the request */
	end;

	l = length (rtrim (auth_string));		/* how long is the string */
	if l > 132 then do;				/* too long for normal output..check for short form */
	     call convert_authorization_$from_string (access_class, "system_high", code);
	     if code ^= 0 then do;			/* oops....bad news */
		call fatal_error (tell_user);		/* tell the operator, and user */
		go to clean_out;			/* drop the request */
	     end;
	     if aim_check_$equal (auth, access_class) then
		auth_string = "SYSTEM HIGH";		/* this is shorter */
	end;					/* save all we can for the label */
	REQUEST.access_class_string = char (auth_string, length (REQUEST.access_class_string));

/* check the requestor's access to the pathname he specified */

	val = mseg_message_info.sender_level;

	call check_user_access (user_dir, ename, code);	/* use the internal proc to do the work */
	if code ^= 0 then do;			/* oops....bad news */
	     call fatal_error (tell_user);		/* tell the operator, and user */
	     go to clean_out;			/* drop the request */
	end;

	call open_file (user_dir, ename, fcbp, max_comp, char_count, code); /* one call does a lot */
	if code ^= 0 then do;			/* oops....bad news */
	     call fatal_error (tell_user);		/* tell the operator, and user */
	     go to clean_out;			/* drop the request */
	end;

/* set up variables for recording checkpoints as we go through the file */

	ck_interval = 25;				/* define the interval for taking checkpoints */
	pic = ck_interval;				/* get the char form */
	ck_mode = "stop" || ltrim (pic);		/* express as the exact mode string */

/* set up the starting page and initialize each checkpoint */

	if (REQUEST.restarted | REQUEST.continued) & print_driver_data.checkpoint.page_no > 0 then
	     current = print_driver_data.checkpoint;	/* use the last checkpoint as the start */
	else do;
	     current.page_no = 1;			/* the current position is top of page 1 */
	     current.line_count = 0;
	     current.comp_no = 0;			/* start at the head of the file */
	     current.offset = 0;
	     current.file_offset = 0;
	end;

	starting_page = current.page_no;

	do i = 1 to hbound (ck.entry, 1);		/* init the checkpoints and set the threads */
	     ck.point (i) = current;			/* each checkpoint is current position for starters */
	     ck.entry (i).forward = i + 1;		/* each entry points to the next one */
	end;
	ck.entry (hbound (ck.entry, 1)).forward = 1;	/* the last entry points back to the start */

/* with the true total bitcount, we can make an estimate of the time needed to do the request */

	if driver_status.bit_rate_est > 0 then do;

	     chars_done = char_count * copies_left - current.file_offset; /* total is chars / copy * copies */
	     time_est = divide (chars_done * 9, driver_status.bit_rate_est, 17, 0);

	     if (driver_status.defer_time_limit > 0) &	/* if a limit is defined, check it */
		(time_est > driver_status.defer_time_limit + 6) then do; /* allow 6 sec fuzz */
						/* so estimate will look bigger than limit in msg */
		if REQUEST.priority_request then	/* priority requests go any way */
		     msg = "Defer time limit suspended for priority request.";
		else if REQUEST.restarted then	/* can't defer what is not in the queue */
		     msg = "Restarted request exceeds time limit but cannot be deferred.";
		else do;				/* drop this one */
		     desc_ptr -> request_descriptor.keep_in_queue = "1"b;
		     call iodd_msg_ (log, both, 0, "", "**Deferring request ^d. Printing time estimate: ^.1f mins.",
			REQUEST.request_no, float (time_est) / 60.0e0);
		     call ioa_$rsnnl ("Deferring request for ^a.^/Printing time estimate: ^.1f minutes.", msg, l,
			REQUEST.full_path, float (time_est) / 60.0e0);
		     call notify_user (substr (msg, 1, l));
		     go to clean_out;
		end;
	     end;
	     else msg = "";

	     if time_est > 60 | msg ^= "" then		/* tell operator if request will exceed 1 minute */
		call iodd_msg_ (log, slave, 0, "", "  Time estimate for request ^d:  ^.1f mins.^[^/^2x^a^]",
		     REQUEST.request_no, float (time_est) / 60.0e0, (msg ^= ""), msg);
	end;

	call check_labels (user_dir, ename, start_segp, code);
	if code ^= 0 then do;			/* oops....bad news */
	     call fatal_error (tell_user);		/* tell the operator, and user */
	     go to clean_out;			/* drop the request */
	end;

	call set_modes_and_labels;			/* set strings for later use */

	if starting_page > 1 | REQUEST.copy_no > 1 then
	     call iodd_msg_ (log, both, 0, "", "  Starting request ^d from page ^d of copy ^d of ^d.",
		REQUEST.request_no, starting_page, REQUEST.copy_no, REQUEST.copies);

/*  set up necessary condition handlers */

	on daemon_kill go to flush_request;		/* flush the current request */
	on daemon_cancel go to flush_request;		/* likewise,  the cancelled flag has been set */
	on daemon_defer go to defer_request;		/* for this one be nice (and quiet?) */
	on daemon_save
	     begin;				/* save the current request at the current position */
	     REQUEST.saved = "1"b;			/* get ready to mark tail sheet */
	     if printing then do;
		how = SAVE;
		call iox_$modes (iocbp, "1pg,print", (""), code); /* make the dim return at bottom of page */
	     end;
	end;
	on daemon_again
	     begin;				/* to restart the current request.... */
	     restart_source = master;			/* talking to the master terminal */
	     go to check_reprint_position;
	end;
	on daemon_again_slave
	     begin;				/* to restart the current request.... */
	     restart_source = slave;			/* talking to slave terminal */
	     go to check_reprint_position;
	end;

	iodd_static.request_in_progress = "1"b;		/* ready to accept kill, cancel etc. */
	control = "101"b;				/* for command lines, wait and prompt slave */
	paper_not_aligned = "0"b;			/* assume paper is aligned at top */
	force_ck_pt = "1"b;				/* and make sure that our counters agree with the dim */
	n_sample_pages = 0;				/* no samples yet for this request */

	call iox_$control (iocbp, "reset", null, code);	/* clear everything */

	if prt_ctl.no_auto_print then
	     go to ask;				/* need operator instructions? */
	else go to print_req;			/* no, sooo...let'er rip */


/* this is the point where we come to restart the current request */

restart_this_request:

	REQUEST.continued = "1"b;			/* make this look like a continuation */
	REQUEST.contd_no = REQUEST.request_no;		/* of this request */
	REQUEST.charge = 0e0;
	REQUEST.time_start_request = clock_ ();
	call date_time_ (REQUEST.time_start_request, REQUEST.date_time_start_request);
	control = "101"b;				/* wait for input and prompt */
	err_mess = "";
	paper_not_aligned = "1"b;			/* add 1 page */
	if REQUEST.copy_no = 1 then
	     REQUEST.separator = "1"b;		/* always mark copy no 1 */
	call skip_to_page (starting_page, code);
	if code ^= 0 then
	     call iodd_msg_ (error, restart_source, code, whoami, "^/Error skiping to starting page.");

%page;

/* Get another command */

ask:
	on conversion
	     begin;
	     call iodd_msg_ (normal, source, 0, "", "Argument conversion error.  Try again.");
	     go to ask;
	end;

	on size
	     begin;
	     call iodd_msg_ (normal, source, 0, "", "Argument numerical size error.  Try again.");
	     go to ask;
	end;

	call iodd_get_cmd_ (addr (cmd_line), 80, nt, control, "request", source, code); /* get a cmd */
	if code ^= 0 then do;
	     call driver_fatal_error (code, "Unable to read operator command.");
	     go to clean_out;
	end;

	call iodd_parse_$command (substr (cmd_line, 1, nt), addr (arg_list), code); /* this was here, so use it */
	if code ^= 0 then do;
	     if code = error_table_$noarg then
		go to ask;			/* be nice about blank lines */
	     call iodd_msg_ (normal, source, 0, "", "Unable to parse command line ^a.", cmd_line);
	     go to ask;
	end;

	if cmd = "help" then do;
	     call iodd_msg_ (normal, source, 0, "", "Standard driver commands may be used, plus:^/");
	     call iodd_msg_ (normal, source, 0, "", "   sample [N]    -print a sample page");
	     call iodd_msg_ (normal, source, 0, "", "   print  [N]    -start normal printing");
	     call iodd_msg_ (normal, source, 0, "",
		"      Where N is an optional page number. (+N or -N is relative to current page)^/");
	     call iodd_msg_ (normal, source, 0, "", "   copy N        -set the current copy number to N");
	     call iodd_msg_ (normal, source, 0, "", "   req_status [-lg]  -print info about current request");
	     call iodd_msg_ (normal, source, 0, "", "");
	     go to ask;
	end;

	if source = master & iodd_static.test_entry then	/* when testing allow a call to db */
	     if cmd = "probe" then do;
		call iodd_msg_ (normal, source, 0, "", "Calling probe");
		call probe ();
		go to ask;
	     end;

	if cmd = "req_status" | cmd = "reqstatus" then do;
	     if n_tokens > 1 then
		if arg (1) = "-lg" | arg (1) = "-long" then
		     lg_sw = "1"b;
		else do;
		     call iodd_msg_ (normal, source, 0, "", "Undefined argument ""^a"".  Use ""-lg"" or none.",
			arg (1));
		     go to ask;
		end;
	     else lg_sw = "0"b;

	     call iodd_msg_ (normal, source, 0, "", "Request ^d: ^a^/^3xfile components :  ^d,   char count :  ^d",
		REQUEST.request_no, full_path, max_comp + 1, char_count);
	     if lg_sw then
		call iodd_msg_ (normal, source, 0, "", "Current file position:");
	     call iodd_msg_ (normal, source, 0, "", "^3xpage no:^12d^4xcurrent copy no: ^d", current.page_no,
		REQUEST.copy_no);
	     if lg_sw then do;
		call iodd_msg_ (normal, source, 0, "",
		     "^3xline count:^9d^/^3xcomp no:^12d^/^3xoffset:^13d^/^3xfile offset:^8d", current.line_count,
		     current.comp_no, current.offset, current.file_offset);
		call iox_$modes (iocbp, "", omode, code); /* get the current modes */
		call iodd_msg_ (normal, source, 0, "", "^/^3xprinter mode: ^a", omode);
		call iox_$control (iocbp, "get_position", addr (position), code);
		call iodd_msg_ (normal, source, 0, "", "^3xdim at:  page ^d  line ^d  line_count ^d",
		     position.page_number, position.line_number, position.total_lines);
	     end;
	     call iodd_msg_ (normal, source, 0, "", "");	/* a blank line before the command request */
	     go to ask;

	end;

	if cmd = "sample" then do;
	     if n_tokens > 1 then do;
		call get_page_no (arg (1), starting_page, code);
		if code ^= 0 then do;
		     call iodd_msg_ (normal, source, 0, "", "Invalid page number: ^a", arg (1));
		     go to ask;
		end;
	     end;
	     else starting_page = current.page_no;

/* if this is the first sample page, output a separator page if
   1. continuous paper and expecting banner bars or
   2. single sheet paper (at all times) */
	     if (n_sample_pages = 0) then do;
		if (continuous_paper & (prt_ctl.banner_bars = NORMAL_BANNER_BARS | prt_ctl.banner_bars = SINGLE_BANNER_BARS))
		     | ^continuous_paper then do;
		     call iox_$control (iocbp, "inside_page", null, code);
		     call iodd_static.print_head_separator (iocbp, prt_ctl_ptr, "sample pages", code);
		     call iox_$control (iocbp, "inside_page", null, code);

/* count pages generated for separator page */
		     if continuous_paper then
			n_sample_pages = 2;
		     else n_sample_pages = 1;
		     REQUEST.separator = "1"b;
		     force_ck_pt = "1"b;		/* don't count what we just printed */
		end;
	     end;

	     call set_up_page_labels;			/* set up printer dim to output any page labels needed */

	     call skip_to_page (starting_page, code);
	     if code ^= 0 then do;
		call iodd_msg_ (error, source, code, "", "^a^/Unable to skip to page.", err_mess);
		go to ask;
	     end;

	     call output_file (SAMPLE, 0, code);	/* write one page at the current position in the file */
	     if code ^= 0 then do;
		call iodd_msg_ (error, source, code, "", "^a^/Error while printing sample page.", err_mess);
	     end;

	     n_sample_pages = n_sample_pages + 1;	/* bump the count of sample pages */

	     go to ask;
	end;

	if cmd = "copy" then do;			/* enter copy number */
	     if n_tokens > 1 then do;			/* be sure we have a value */
		i = convert (i, arg (1));		/* convert to binary */
		if i < 1 | i > REQUEST.copies then do;
		     call iodd_msg_ (normal, source, 0, "", "Copy number must be in the range 1 to ^d.",
			REQUEST.copies);
		     go to ask;
		end;
		REQUEST.copy_no = i;
		go to ask;
	     end;
	     call iodd_msg_ (normal, source, 0, "", "Expected argument missing.");
	     go to ask;
	end;

	if cmd ^= "print" then do;			/* all other commands except print go to the std cp */
	     force_ck_pt = "1"b;			/* in case a sample head sheet was printed */
	     call iodd_command_processor_ (source, 3, substr (cmd_line, 1, nt), code);
	     if code = 1 | code = 2 then do;
		if code = 2 & cmd = "save" then
		     go to clean_out;		/* save at this level is OK, just drop */
		call iodd_msg_ (normal, source, 0, "", "Invalid command. Try again or type help for instructions.");
	     end;
	     call set_modes_and_labels;		/* in case the force modes were changed */
	     go to ask;
	end;

/* now we have received  the print command and are ready to print the entire file */

	if n_tokens > 1 then do;			/* was a page number specified? */
	     call get_page_no (arg (1), starting_page, code);
	     if code ^= 0 then do;
		call iodd_msg_ (normal, source, 0, "", "Invalid page number: ^a", arg (1));
		go to ask;
	     end;
	end;
	else starting_page = current.page_no;

	call skip_to_page (starting_page, code);	/* check it before the head banner is printed */
	if code ^= 0 then do;
	     call iodd_msg_ (error, source, code, "", "^a^/Unable to skip to page.", err_mess);
	     go to ask;
	end;

	if source = master then
	     iodd_static.master_hold = "0"b;
	else if iodd_static.master_hold then do;	/* respect the master here too */
	     call iodd_msg_ (normal, source, 0, "", "Driver is in hold by master terminal.");
	     go to ask;
	end;

print_req:
	REQUEST.cpu_time = 0;			/* reset the usage data */
	REQUEST.real_time = 0;
	REQUEST.page_waits = 0;
	REQUEST.pre_pages = 0;
	err_mess = "";				/* clear any residual junk */
	starting_page = current.page_no;		/* the page to start this copy on */

/* need to check for head sheet alignment on continuous forms? */
	if n_sample_pages > 0 & continuous_paper then do;
	     if mod (n_sample_pages, 2) = 0 then
		call iox_$put_chars (iocbp, addr (FF), 1, code); /* this is really for remote devices */
	end;

	call iox_$control (iocbp, "get_error_count", addr (last_error_count), code);
	if code ^= 0 then
	     last_error_count = -1;			/* well we tried */

/* Iff we are on single sheet paper, stop multiple blank pages by suppressing
   consecutive form feeds */
	if ^continuous_paper then
	     call iox_$control (iocbp, "ff_suppress_on", null, code);

	do while (REQUEST.copy_no <= REQUEST.copies);	/* once around for each copy */

	     call print_head_banner (code);
	     if code ^= 0 then do;
		call driver_fatal_error (code, "Attempting to print head banner.");
		go to clean_out;
	     end;

	     call set_up_page_labels;			/* set up printer dim to output any page labels */

	     n_sample_pages = 0;			/* now we have a real head sheet */
	     REQUEST.separator = "0"b;		/* we want separator bars only the first time */

/*	now get to the correct top of page location and start printing */
/*	assume that head_sheet and advertizing  (plus the FF above) will leave us at top inside page */
/*	This only applies for continuous forms.  */

	     if continuous_paper then do;
		i = mod (starting_page, 2);		/* see if we are starting on an even or odd page */
		if i = 0 then do;			/* if the paper is in the wrong position, align it */
		     call iox_$put_chars (iocbp, addr (FF), 1, code);
		end;
	     end;

/*	now, after all that paper motion, set the dim position to agree with the current position */

	     force_ck_pt = "1"b;			/* set the position */
	     paper_not_aligned = "0"b;		/* don't move the paper */

	     call skip_to_page (starting_page, code);	/* sync with the dim */
	     if code ^= 0 then do;
		call driver_fatal_error (code, "First page synchronization.");
		go to clean_out;
	     end;

	     if desc_ptr -> request_descriptor.saved then
		how = SAVE;
	     else how = PRINT;
	     start_char_offset = current.file_offset;	/* get ready to see how many chars were done per sec */

	     call iox_$control (iocbp, "runout", null, code); /* be sure head sheet is done before clock reading */

	     call cpu_time_and_paging_ (old_waits, old_cpu, old_pp); /* keep time and page waits for accounting */
	     old_clock = clock_ ();			/* time copy started */

	     printing = "1"b;			/* tell daemon_save handler we are printing */

/* check to see if the user wants raw output.  if so then turn it on */
	     if evaluate_forms_info_output_ptr ^= null then do;
		if evaluate_forms_info_output.special_length ^= 0 then do;
		     if iodd_parse_$args ("output_type=", (evaluate_forms_info_output.special_string)) = "raw" then do;
			call iox_$control (iocbp, "prt_conv_off", null (), (0));
			call iox_$modes (iocbp, "rawo", "", (0));
		     end;
		end;
	     end;

	     call output_file (how, 0, code);		/* this will do it */
						/* reset raw output if user has asked for it */
	     if evaluate_forms_info_output_ptr ^= null then do;
		if evaluate_forms_info_output.special_length ^= 0 then do;
		     if iodd_parse_$args ("output_type=", (evaluate_forms_info_output.special_string)) = "raw" then do;
			call iox_$control (iocbp, "prt_conv_on", null (), (0));
			call iox_$modes (iocbp, "^rawo", "", (0));
		     end;
		end;
	     end;

	     if code ^= 0 then do;
		if ^(desc_ptr -> request_descriptor.saved & code = error_table_$request_pending) then do; /* BAD */
		     call driver_fatal_error (code, (err_mess));
		     go to clean_out;
		end;
	     end;
	     else print_driver_data.page_no = 0;	/* copy done, checkpoint is no longer valid */

	     printing = "0"b;			/* the printing has been done */

	     call iox_$control (iocbp, "runout", null, code); /* be sure copy is done before counting it */

	     if ^desc_ptr -> request_descriptor.saved then/* if leaving this til later, don't charge now */
		if REQUEST.copies > print_driver_data.copies_charged then do;
		     chgsw = "1"b;			/* user honestly deserves these charges */
		     print_driver_data.copies_charged = print_driver_data.copies_charged + 1;
		end;
		else chgsw = "0"b;
	     else chgsw = "0"b;

	     call charge_for_work;			/* do the accounting so we can put price on tail */

	     if last_error_count = -1 then
		device_error = ""b;			/* no error data */
	     else do;
		call iox_$control (iocbp, "get_error_count", addr (i), code);
		if code ^= 0 | i > last_error_count then
		     device_error = "1"b;
		else device_error = "0"b;		/* we can figure the transfer rate */
	     end;

	     if ^(iodd_static.quit_during_request | device_error) then do; /* can we update the rate estimate? */
		old_rate = driver_status.bit_rate_est;	/* get the last value */
		chars_done = char_count - start_char_offset; /* chars printed in time interval */
		seconds = divide (REQUEST.real_time, 1000000, 17); /* see how many seconds have passed */
		if seconds < 1 then
		     new_rate = old_rate;		/* avoid divide by zero */
		else new_rate = divide (chars_done * 9, seconds, 17, 0); /* get bits/sec */
		if old_rate > 0 then		/* use first good rate to start the estimate */
		     new_rate = fixed (old_rate * factor + new_rate * (1e0 - factor));
						/* use exp smoothing */
		driver_status.bit_rate_est = new_rate;	/* put back new value */
	     end;

	     if REQUEST.saved then do;		/* mark the listing suspended */
		call ioa_$rsnnl ("Processing suspended at page ^d.", err_mess, l, REQUEST.page_count);
		call error_write (0, err_mess);
	     end;

	     call print_tail_banner (code);		/* this will put on the tail banner */
	     if code ^= 0 then do;			/* some type of error..don't do it again */
		call driver_fatal_error (code, "Attempting to write tail banner.");
		go to clean_out;
	     end;

	     if desc_ptr -> request_descriptor.saved then
		go to clean_out;			/* suspend this request and get the next */


	     print_driver_data.copies_done = print_driver_data.copies_done + 1;
	     REQUEST.copy_no = REQUEST.copy_no + 1;	/* get ready for next copy */
	     header_done = "0"b;			/* ready for a new header */
	     starting_page = 1;			/* start the next copy at the begining */

	end;					/* done with this copy...check for more in while loop */

/*	we are now done with the request...so clean up */

	call iox_$control (iocbp, "runout", null, code);	/* be sure all printing is out before charge message */

	call iodd_msg_ (log, both, 0, "", "  Charge for request ^d: $^.2f  (^d lines,  ^d pages^[ per copy)^;)^]",
	     REQUEST.request_no, REQUEST.total_charge, REQUEST.line_count, REQUEST.page_count, (copies_left > 1));

	if REQUEST.notify then do;
	     call ioa_$rsnnl ("printed ^a $^.2f queue ^d ^a ^d", msg, l, REQUEST.full_path, REQUEST.total_charge,
		REQUEST.queue, REQUEST.device_name, REQUEST.request_no);
	     call notify_user (substr (msg, 1, l));
	end;

clean_out:					/* get ready for the next users' request */
	if last_error_count > -1 then do;		/* if error count is defined */
	     call iox_$control (iocbp, "get_error_count", addr (i), code);
	     if code ^= 0 | i > last_error_count then	/* if errors are possible */
		if ^desc_ptr -> request_descriptor.dont_delete then do; /* and user not told about it */
		     if REQUEST.delete = 1 then do;	/* tell user we cancelled his delete request */
			desc_ptr -> request_descriptor.dont_delete = "1"b;
			call ioa_$rsnnl ("Device error during request ^d.  Segment ^a will not be deleted.", msg, l,
			     REQUEST.request_no, REQUEST.full_path);
			call notify_user (substr (msg, 1, l));
		     end;
		end;
	end;

	desc_ptr -> request_descriptor.finished = "1"b;	/* say we are done with it */
	iodd_static.request_in_progress = "0"b;		/* no more commands can be effective */
	call clean_proc ();				/* get junk out of the address space */
	call iox_$control (iocbp, "runout", null, code);	/* make device disgorge */

	return;

check_reprint_position:

/* on restart, we transfer back here to release the stack frame with the dim,
   so the slave can again write to the remote device and request a cmd */
	call restart_request (restart_source);		/* give the request position */
	go to restart_this_request;			/* now go back and restart the request */

%page;

/*  This is where the condition handlers "go to" when something has gone wrong */

flush_request:					/* kill and cancel handlers jump back here */
	msg = "Operator aborted listing";		/* message for kill and cancel */
	chgsw = "0"b;				/* can't charge */
	go to no_delete;

abort_request:					/* unclaimed signals transfer to here */
	chgsw = ""b;				/* assume we can't charge user */

	msg = """" || rtrim (fault_name) || """ condition occured"; /* format basic message */

	if fault_name = "seg_fault_error" &		/* user deleted seg, charge for what was done */
	     iodd_static.segptr ^= null then do;
	     chgsw = "1"b;
	     delete_msg = "";			/* forget to tell user we won't delete his seg */
	end;
	else do;
no_delete:
	     if REQUEST.delete ^= 0 then
		delete_msg = "; segment will not be deleted";
	     else delete_msg = "";
	end;

	call ioa_$rsnnl ("^a during processing of request^a.", err_mess, l, msg, delete_msg);

	code = 0;

	call fatal_error (tell_user);			/* this will clean things up a bit */

	go to clean_out;				/* now drop the request */


defer_request:					/* leave this in the queue for a while */
	err_mess = "Operator deferred request until a later time.";
	chgsw = ""b;

	code = 0;

	call fatal_error (tell_user);

	go to clean_out;

%page;

/* ======================================================================================= */
/* ==============================    INTERNAL PROCEDURES    ============================== */
/* ======================================================================================= */



fatal_error: procedure (notify);

dcl  notify bit (1);

	REQUEST.notify = REQUEST.notify | notify;	/* set notify flag by arg if off */

	if ^REQUEST.notify & ^header_done then
	     call print_head_banner ((0));		/* try to tell requestor */

	if header_done then
	     call charge_for_work;			/* update REQUEST data if possible */

	call error_write (code, err_mess);

	if header_done then
	     call print_tail_banner ((0));		/* finish it off */

	call iodd_msg_ (log, both, 0, "", "Processing of request ^d terminated.", REQUEST.request_no);

	desc_ptr -> request_descriptor.dont_delete = "1"b;/* make sure we don't delete user seg */

	return;					/* let the caller flush the request */

     end fatal_error;

/* ===================================== */

error_write: procedure (code, message);			/* for writing error messages to console &
						   request stream */
dcl  code fixed bin (35);
dcl  message char (*) varying;

	short_msg, lg_msg = "";			/* clear any junk */
	if code ^= 0 then
	     call convert_status_code_ (code, short_msg, lg_msg);

	call ioa_$rsnnl ("Request for ^a. ^a ^a", msg, l, REQUEST.full_path, lg_msg, message);

	if REQUEST.notify then			/* this lets us be quiet about save and defer */
	     call notify_user (substr (msg, 1, l));

	call iodd_msg_ (log, both, 0, "", "**Request ^d: ^a ^a", REQUEST.request_no, lg_msg, message);

	if header_done then do;			/* must not do a "reset" or line and page count is lost */
	     call ioa_$rsnnl ("^2/^a^a^/io_daemon: ^a ^a^/^a^a^2/", msg, l, VT, stars, lg_msg, message, stars, VT);
	     call iox_$modes (iocbp, "default", omode, code);
	     call iox_$put_chars (iocbp, addr (msg), l, code);
	     call iox_$modes (iocbp, omode, (""), code);
	end;
	return;

     end error_write;

%page;

notify_user: procedure (message);

dcl  message char (*) aligned;
dcl  (ipc_ind, r1_ind, ec) fixed bin (35);

	ipc_ind, r1_ind = -1;			/* set to non-zero to test call */

	if ^sys_priv then
	     go to send_it;				/* if they failed once, .... */

	on linkage_error
	     begin;
	     sys_priv = "0"b;			/* stop trying if we fail */
	     go to revert_handler;			/* send the message if possible */
	end;

	on any_other
	     begin;
	     if r1_ind = 0 then
		call system_privilege_$ring1_priv_off (r1_ind);
	     if ipc_ind = 0 then
		call system_privilege_$ipc_priv_off (ipc_ind);
	     r1_ind, ipc_ind = -1;
	     call continue_to_signal_ (ec);
	end;

	call system_privilege_$ring1_priv_on (r1_ind);

	call system_privilege_$ipc_priv_on (ipc_ind);

revert_handler:
	revert linkage_error;

send_it:
	call send_mail_$access_class (mailname, message, addr (send_mail_info), mseg_message_info.sender_authorization,
	     ec);

	if r1_ind = 0 then
	     call system_privilege_$ring1_priv_off (r1_ind);

	if ipc_ind = 0 then
	     call system_privilege_$ipc_priv_off (ipc_ind);

	return;

     end notify_user;

%page;

charge_for_work: procedure ();

/* Accounting section, done at end of processing each copy of output. */

	new_clock = clock_ ();
	call cpu_time_and_paging_ (new_waits, new_cpu, new_pp);

	position.line_number = 0;			/* for the tail banner proc */
	position.total_lines = 0;			/* Clear these items */
	position.page_number = 0;
	call iox_$control (iocbp, "get_position", addr (position), code);

	REQUEST.line_count = position.total_lines;
	if position.line_number = 1 then
	     REQUEST.page_count = position.page_number - 1; /* if file ended with FF */
	else REQUEST.page_count = position.page_number;
	REQUEST.cpu_time = new_cpu - old_cpu;
	REQUEST.real_time = new_clock - old_clock;	/* real time for this copy */
	REQUEST.page_waits = fixed (new_waits - old_waits, 35);
	REQUEST.pre_pages = fixed (new_pp - old_pp, 35);

	if chgsw then do;				/* charge him */
	     if driver_status.have_accounting then do;
		call io_daemon_account_ (driver_status.acct_entry, addr (REQUEST));
	     end;
	     else do;
		REQUEST.price_per_n_lines,		/* zap all charges to zero */
		     REQUEST.price_per_n_pages,
		     REQUEST.charge = 0e0;
		REQUEST.no_accounting = "1"b;		/* and flag it */
	     end;
	end;
	else REQUEST.charge = 0e0;			/* give user a break */

	REQUEST.total_charge = REQUEST.total_charge + REQUEST.charge;

	return;

     end charge_for_work;

/* ============================== */

driver_fatal_error: procedure (code, err_msg);


dcl  code fixed bin (35);
dcl  err_msg char (*);

	call iodd_msg_ (error, both, code, whoami, "^a ^a ^/ Driver returning to command level.", err_msg, err_mess);

	desc_ptr -> request_descriptor.dont_delete = "1"b;/* give a reprieve....in case */
	desc_ptr -> request_descriptor.keep_in_queue = "1"b;

	a_code = code;				/* report driver_fatal_error */

	return;

     end driver_fatal_error;

%page;

check_labels: procedure (user_dir, ename, segptr, code);

/* Internal procedure to check that the top and bottom labels are
   the access class of the segment. */

dcl  access_class bit (72) aligned;
dcl  code fixed bin (35);
dcl  ename char (*) aligned;
dcl  level fixed bin;
dcl  user_dir char (*) aligned;
dcl  segptr pointer;
dcl  sys_info$access_class_floor bit (72) aligned external static;


dcl  1 local_audit_user_info aligned like audit_user_info;
dcl  1 local_audit_eventflags aligned like audit_event_flags;

	code = 0;

	if dprint_msg.top_label ^= dprint_msg.bottom_label then do;
LOG_AUDIT_MESSAGE:
	     call cu_$level_get (level);
	     unspec (local_audit_user_info) = ""b;
	     local_audit_user_info.version = audit_user_info_version_1;
	     local_audit_user_info.user_id = mseg_message_info.sender_id;
	     local_audit_user_info.ring = mseg_message_info.sender_level;
	     local_audit_user_info.process_id = mseg_message_info.sender_process_id;
	     local_audit_user_info.authorization = mseg_message_info.sender_authorization;
	     local_audit_user_info.authorization_range (1) = sys_info$access_class_floor;
	     local_audit_user_info.authorization_range (2) = mseg_message_info.sender_max_authorization;
	     local_audit_user_info.audit_flags = mseg_message_info.sender_audit;

	     unspec (local_audit_eventflags) = ""b;
	     local_audit_eventflags.grant = "1"b;

	     call access_audit_gate_$log_obj_ptr_user ("do_prt_request_", level, unspec (local_audit_eventflags),
		access_operations_$io_daemon_set_page_labels, segptr, 0, null (), 0, addr (local_audit_user_info));

	     return;
	end;

	call hcs_$get_access_class (user_dir, ename, access_class, code);
	if code ^= 0 then
	     return;

	call convert_authorization_$from_string (authorization, rtrim (dprint_msg.top_label), code);
	if code ^= 0 then do;
	     code = 0;
	     goto LOG_AUDIT_MESSAGE;			/* This isn't an access class */
	end;

	if ^(aim_check_$equal (access_class, authorization)) then
	     goto LOG_AUDIT_MESSAGE;

	return;
     end check_labels;

check_user_access: procedure (user_dir, ename, ec);

/* Internal procedure to check that the requestor has at least "r" access to
   the specified segment */

dcl  user_dir char (*) aligned;
dcl  ename char (*) aligned;
dcl  code fixed bin (35);
dcl  ec fixed bin (35);
dcl  mode fixed bin (5);
dcl  access_class bit (72) aligned;

	call hcs_$get_user_effmode (user_dir, ename, REQUEST.requestor, val, mode, code);
	if code ^= 0 then do;
	     if code = error_table_$noentry then
		err_mess = "";			/* simple case, just say no entry */
	     else err_mess = "Unable to get user's mode.";
	     ec = code;
	     return;
	end;

	if (bit (mode, 5) & "01000"b) = "0"b then do;
	     err_mess = "User does not have read access.";
	     ec = error_table_$moderr;
	     return;
	end;

	call hcs_$get_access_class (user_dir, ename, access_class, code);
	if code ^= 0 then do;
	     err_mess = "Unable to get access class of segment.";
	     ec = code;
	     return;
	end;

	if ^read_allowed_ (mseg_message_info.sender_authorization, access_class) then do;
	     ec = error_table_$ai_restricted;
	     err_mess = "User not allowed to read segment.";
	     return;
	end;

	ec = 0;					/* ok, user passed the checks */

	return;

     end check_user_access;

%page;

open_file: procedure (user_dir, ename, fcbp, max_comp, char_count, code);

dcl  user_dir char (*) aligned;
dcl  ename char (*) aligned;
dcl  fcbp ptr;
dcl  max_comp fixed bin;
dcl  char_count fixed bin (24);
dcl  code fixed bin (35);

dcl  comp_dir char (168) aligned;
dcl  comp_name char (32) aligned;
dcl  type fixed bin (2);
dcl  dir fixed bin int static options (constant) init (2);
dcl  dir_len fixed bin;
dcl  bc fixed bin (24);
dcl  mode fixed bin (5);
dcl  mult_ind fixed bin;



	char_count = 0;				/* clear the count so we can accumulate file length */

	call hcs_$status_minf (user_dir, ename, 1, type, bc, code); /* see what kind of a thing it is */
	if code ^= 0 then do;
	     err_mess = char ("Driver cannot get status of file: " || full_path, length (err_mess));
	     return;
	end;

	if type = dir then				/* directory */
	     if bc < 1 then do;			/* it was a directory */
		code = error_table_$dirseg;
		return;
	     end;
	     else max_comp = bc - 1;			/* MSF - highest component is bitcount less one */
	else max_comp = 0;				/* SSF - highest component is 0 */

	call msf_manager_$open (user_dir, ename, fcbp, code);
	if code ^= 0 then do;
	     err_mess = "Unable to open file: " || full_path;
	     return;
	end;

	do mult_ind = 0 to max_comp;			/* now we look at each component */

	     call msf_manager_$get_ptr (fcbp, mult_ind, "0"b, segp, bc, code);
	     if code ^= 0 then do;			/* we failed, don't try to do partial files */
		call ioa_$rsnnl ("Unable to get pointer to file component: ^d.", err_mess, dir_len, mult_ind);
		return;
	     end;

	     if mult_ind = 0 then
		start_segp = segp;			/* this is the first component */

/*		we got a pointer to something...where is it */
/*		and does the requestor have access to it? */

	     call hcs_$fs_get_path_name (segp, comp_dir, dir_len, comp_name, code);
	     if code ^= 0 then do;
		err_mess = "Could not get file component pathname.";
		return;
	     end;

	     call check_user_access (comp_dir, comp_name, code);
	     if code ^= 0 then do;			/* he tried to pull a fast one and got caught */
		err_mess = err_mess || "  " || substr (comp_dir, 1, dir_len) || ">" || comp_name;

/* most of err_mess was set by check_user_access */
		return;
	     end;

	     if bc < 9 then do;			/* must be at least one char per component */
		code = error_table_$improper_data_format; /* choose a good error message */
		err_mess = "Zero length segment: " || substr (comp_dir, 1, dir_len) || ">" || comp_name;
		return;
	     end;

	     REQUEST.bit_count = REQUEST.bit_count + bc;	/* total the bits for accounting */

	     char_count = char_count + divide (bc, 9, 24, 0); /* get char count like output_file will */

	     call hcs_$fs_get_mode (segp, mode, code);	/*  make sure daemon has access  */
	     if code ^= 0 then do;
		err_mess = "Driver process does not have access to segment.";
		return;
	     end;
	     if (bit (mode, 5) & "01000"b) = "0"b then do;
		err_mess = "Driver process does not have read access to segment.";
		code = error_table_$moderr;		/* give some access violation code */
		return;
	     end;
	end;


/* Now we know that the file is there and that the requestor has the correct access to it.
   The continued operation of the driver now assumes that the file will remain the same
   until the driver is done.  That is, the access will not change, the number of components will not
   change, and the size of each component will not change.  */


     end open_file;

%page;

output_file: procedure (how, ending_page, ec);

dcl  how fixed bin;					/* how the file is to be output: sample print skip or save */
dcl  ending_page fixed bin (24);			/* where to stop when skipping */
dcl  ec fixed bin (35);				/* you guessed it, error code */

dcl  bc fixed bin (24);
dcl  max_el fixed bin (24);
dcl  modes char (64);				/* mode string */
dcl  n fixed bin;
dcl  nel fixed bin (24);				/* number of chars to be printed on write */
dcl  nelt fixed bin (24);				/* number of chars processed by dim on return */
dcl  next fixed bin;
dcl  code fixed bin (35);				/* iox_ status code, local version */

dcl  wp ptr;					/* working pointer into the segment */
dcl  char_pos (sys_info$max_seg_size * 4) char (1) based;	/* array of one char elements to get wp */
dcl  seg_string char (max_el) based (segp);

dcl  1 temp aligned like print_driver_data.checkpoint;	/* temporary values for current position */

dcl  1 save_position aligned like position_data;		/* temporary for position at start of sample */


	ec = 0;					/* clear the error code */

	temp = current;				/* we will start at the current position */

	if how = SAMPLE then do;			/* print 1 page and put all position counters back as found */
	     modes = "1pg,print," || ck_mode;		/* return after printing 1 page */
	     call iox_$control (iocbp, "get_position", addr (save_position), code); /* save dim position */
	     if code ^= 0 then do;
		err_mess = "From get_position order for sample.";
		ec = code;
		return;
	     end;
	end;
	else if how = SKIP then do;			/* process file to ending_page without printing,
						   but save checkpoints on the way */
	     n = ending_page - current.page_no;		/* see how close to the end we are */
	     if n < ck_interval then do;		/* if close, use a small interval */
		pic = n;				/* get the interval as ascii */
		modes = "stop" || ltrim (pic);	/* make a mode string for the dim */
	     end;
	     else modes = ck_mode;			/* if not close, use the normal interval */

	     modes = char ("^print,^1pg," || modes, length (modes)); /* it is transparant in either case */
	end;
	else if how = SAVE then
	     modes = "print,1pg," || ck_mode;		/* for save, go to bottom of even page */
	else modes = "print,^1pg," || ck_mode;		/* default assumes how = print */

	call iox_$control (iocbp, "runout", null, code);
	call iox_$modes (iocbp, modes, omode, code);	/* set the modes */
	if code ^= 0 then
	     call iodd_msg_ (error, both, code, whoami, "Changing mode during output init to: ^a^/  from: ^a", modes,
		omode);

	segp = null;				/* don't try to deactivate */

next_comp:					/* done with last component */
	if segp ^= null & privileged then
	     call phcs_$deactivate (segp, (0));		/* so try to deactivate the seg */

	call msf_manager_$get_ptr (fcbp, temp.comp_no, "0"b, segp, bc, ec); /* get ptr to seg */
	if segp = null then do;
	     err_mess = "Invalid seg ptr to component.";
	     return;
	end;

	if privileged then				/* .. do it (gently if possible) */
	     call phcs_$set_kst_attributes (binary (baseno (segp), 18), addr (ksta), (0));

	max_el = divide (bc, 9, 24, 0);		/* see now many elements to write out */

/* if this is last (or only) component of file, remove any trailing VT or FF chars */
	if temp.comp_no = max_comp then do;
	     max_el = length (rtrim (seg_string, nl_vt_ff));
	end;

write_out:
	nel = max_el - temp.offset;			/* see how much is left to do */
	iodd_static.segptr = segp;			/* tell signal handler what segment we are using */
	wp = addr (segp -> char_pos (temp.offset + 1));	/* get ptr to next character */

	call iox_$put_chars (iocbp, wp, nel, code);	/* This is the actual output of segment */
	iodd_static.segptr = null;			/* not referencing user seg now */
	if code ^= 0 then do;
	     if code ^= error_table_$request_pending then do; /* we only want one code */
		ec = code;
		err_mess = "IO error during output of file.";
		return;
	     end;

/* code = error_table_$request_pending.  do something about it */
	     if how = SAMPLE then do;			/* Yes, and for sample we are done printing */

sample_done:	call iox_$control (iocbp, "set_position", addr (save_position), code); /* restore position */
		if code ^= 0 then
		     call iodd_msg_ (error, both, code, whoami,
			"Unable to restore position, set_position order.");

/* current position data was not changed */

		modes = "^1pg," || ck_mode;		/* restore the default checkpoints */

		call iox_$modes (iocbp, modes, omode, code);
		if code ^= 0 then
		     call iodd_msg_ (error, both, code, whoami, "Changing mode from ^a^/to ^a", omode, modes);

		call iox_$control (iocbp, "runout", null, code); /* be sure it prints */

		return;
	     end;

/* hit checkpoint for save, skip or print */
	     call iox_$control (iocbp, "get_position", addr (position), code); /* see where we are */
	     if code ^= 0 then do;
		ec = code;
		err_mess = "Error on get_position order for checkpoint.";
		return;
	     end;

	     nelt = position.total_chars - temp.file_offset; /* num chars done */

	     if how = SKIP then do;			/* if skipping, check for end of file */
		if (nel = nelt) & (temp.comp_no = max_comp) then do; /* this is bad - hit EOF */
		     force_ck_pt = "1"b;		/* be sure we re-sync the dim */
		     ec = error_table_$eof_record;	/* report it as an error */
		     call ioa_$rsnnl ("EOF reached at end of page ^d.", err_mess, l,
			position.page_number - 1);
		     return;			/* the page count from the dim is one too high */
		end;
	     end;

/* record the current position of the dim */
	     temp.page_no = position.page_number;
	     temp.line_count = position.total_lines;
	     temp.offset = temp.offset + nelt;
	     temp.file_offset = position.total_chars;

	     current = temp;			/* say this is a real page position */
	     if how = PRINT | how = SAVE then
		print_driver_data.checkpoint = current; /* make things consistent */

	     if how = SAVE then do;			/* getting ready to suspend request */
		n = mod (temp.page_no, 2);		/* check for even page */
		if n = 1 then do;			/* odd number means we just finished an even page */
		     ec = error_table_$request_pending; /* pass back "not finished" */
		     return;
		end;
	     end;

	     if current.page_no >= (ck.point (ck.last).page_no + ck_interval) then do; /* worth saving it */

		next = ck.entry (ck.last).forward;	/* find index of next checkpoint entry */
		ck.point (next) = current;		/* save the current checkpoint */
		ck.last = next;			/* advance the index */
	     end;

	     if how = SKIP then do;			/* see if we have skipped enough */

		if current.page_no = ending_page then
		     return;			/* all done */

		if current.page_no > ending_page then do; /* OOPS - a counting error */
		     force_ck_pt = "1"b;		/* re-sync the dim */
		     ec = error_table_$out_of_bounds;	/* give an error code */
		     call ioa_$rsnnl ("Skipped over end page ^d, at ^d.", err_mess, l, ending_page,
			current.page_no);
		     return;
		end;

		n = ending_page - current.page_no;	/* see how far we need to go */

		if n < ck_interval then do;		/* if close, use a small interval */

		     pic = n;			/* make it ascii */
		     modes = "stop" || ltrim (pic);	/* make the mode string */

		     call iox_$modes (iocbp, modes, omode, code);
		     if code ^= 0 then
			call iodd_msg_ (error, both, code, whoami,
			     "Changing mode near end of skip to: ^a^/  from: ^a", modes, omode);
		end;
	     end;					/* end of skip mode checks */
	     if nelt < nel then
		go to write_out;			/* when more to do, do it */
	     else go to end_of_comp;			/* otherwise this component is done, get next one */
	end;					/* end of skip or print checkpoint processing */

	temp.file_offset = temp.file_offset + nel;	/* record last output from this component */

end_of_comp:					/* get set for the next component, or quit if done */
	if temp.comp_no = max_comp then		/* we are at real end of file */
	     if how = PRINT | how = SAVE then do;	/* this is good */
		if privileged & ((REQUEST.copy_no = REQUEST.copies) | (max_comp > 0)) then /* done for a while */
		     call phcs_$deactivate (segp, (0)); /* so let the pages go */
		segp = null;
		return;
	     end;
	     else if how = SKIP then do;
		ec = error_table_$eof_record;		/* tried to skip too far */
		call iox_$control (iocbp, "get_position", addr (position), code);
		if code ^= 0 then
		     call iodd_msg_ (error, both, code, whoami, "get_position order.");
		if position.line_number = 1 then
		     call ioa_$rsnnl ("EOF reached at end of page ^d.", err_mess, l, position.page_number - 1);
		else call ioa_$rsnnl ("EOF at page ^d, line ^d.", err_mess, l, position.page_number,
			position.line_number);
		force_ck_pt = "1"b;			/* tell caller we are out of sync */
		return;
	     end;
	     else do;				/* sample was the last partial page */
		call iox_$put_chars (iocbp, addr (FF), 1, code); /* align the page */
		go to sample_done;			/* let it go by */
	     end;

	temp.comp_no = temp.comp_no + 1;		/* go on to the next component */
	temp.offset = 0;				/* start at the begining */

	go to next_comp;				/* deactivate old and get new */

     end output_file;

%page;

restart_request: procedure (source);

/* internal procedure used to tell operator where the request was  */

dcl  source fixed bin;

dcl  code fixed bin (35);
dcl  pg_count_msg char (80);				/* message for last page processed */
dcl  restart_msg char (200);
dcl  i fixed bin;

	call iox_$control (iocbp, "resetwrite", null, code); /* clear any junk out of the buffers */

	call iox_$control (iocbp, "get_position", addr (position), code);
	if code ^= 0 then
	     starting_page = current.page_no;		/* last known page data */
	else starting_page = position.page_number - 5;	/* start back 5 pages unless otherwise instructed */

	if starting_page < 1 then			/* be sure of a good page number */
	     starting_page = 1;
	call ioa_$rsnnl ("Driver positioned at page ^d of the file.", pg_count_msg, i, starting_page);

	REQUEST.copy_no = min (REQUEST.copies, print_driver_data.copies_done + 1); /* assume this for now */

	call ioa_$rsnnl ("Restarting request ^d at copy number ^d of ^d", restart_msg, i, REQUEST.request_no,
	     REQUEST.copy_no, REQUEST.copies);
	call iodd_msg_ (normal, source, 0, "", "^a^/^a^/", restart_msg, pg_count_msg);

	return;

     end restart_request;

%page;

get_page_no: procedure (a_page, a_pgn, ec);

dcl  a_page char (*) var aligned;
dcl  a_pgn fixed bin (24);
dcl  ec fixed bin (35);

dcl  sign char (1);
dcl  start fixed bin;
dcl  pgn fixed bin (24);


	ec = 0;					/* initialize the return code */

	if a_page = "" then do;			/* for a null string, use the current position */
	     a_pgn = current.page_no;
	     return;
	end;

	sign = substr (a_page, 1, 1);			/* see if this is a relative page number */

	if sign = "+" | sign = "-" then
	     start = 2;
	else start = 1;				/* this is the start of the number part */

	on conversion go to pgn_err;
	pgn = convert (pgn, substr (a_page, start));	/* convert it to binary */

	if pgn < 1 then do;				/* make "--N" illegal */
pgn_err:
	     ec = 10;				/* and keep the numbers in range */
	     return;
	end;

	if sign = "+" then
	     a_pgn = current.page_no + pgn;		/* forward N pages */

	else if sign = "-" then
	     a_pgn = current.page_no - pgn;		/* back N pages */

	else a_pgn = pgn;				/* an absolute page number */

	if a_pgn < 1 then
	     a_pgn = 1;				/* can't go back past start  */

	return;

     end get_page_no;

%page;

skip_to_page: procedure (starting_pg, ec);

dcl  starting_pg fixed bin (24);
dcl  ec fixed bin (35);

dcl  target fixed bin (24);
dcl  i fixed bin;
dcl  pg fixed bin (24);
dcl  high_page fixed bin (24);
dcl  ind fixed bin;
dcl  next fixed bin;
dcl  code fixed bin (35);				/* local error code */


	ec = 0;					/* start clean */

	target = starting_pg;			/* copy arg so we don't change the logic by accident */

	call iox_$modes (iocbp, (REQUEST.output_mode), omode, code); /* must skip under users modes */
	if code ^= 0 then do;
	     ec = code;
	     err_mess = "Unable to set user modes for page skip.";
	     return;
	end;

	if paper_not_aligned & continuous_paper then do;	/* we need to re sync the world */
	     call iox_$put_chars (iocbp, addr (FF), 1, code); /* first a FF */
	     if code ^= 0 then do;
		ec = code;
		err_mess = "IO error writing form feed to the printer.";
		return;
	     end;
	     call iox_$control (iocbp, "runout", null, code); /* be sure it is written */
	     paper_not_aligned = "0"b;		/* we are aligned now */
	     force_ck_pt = "1"b;			/* don't count the page just written */
	end;


	if ^force_ck_pt then			/* can we believe the current position */
	     if target = current.page_no then
		return;				/* we are already there */

	high_page = 0;				/* highest page <_ target */
	ind = 0;					/* index of checkpoint for high_page */

	do i = 1 to hbound (ck.entry, 1);		/* look at all entries...may not be in order */

	     pg = ck.point (i).page_no;		/* get the page number */
	     if (pg <= target) & (pg > high_page) then do;/* see if it is highest <_ target */
		high_page = pg;
		ind = i;
	     end;
	end;

	if ind = 0 then do;				/* start at begining */

	     current.page_no, position.page_number = 1;	/* begining is at page 1 */
	     current.line_count, position.total_lines = 0;
	     current.comp_no = 0;			/* first MSF component */
	     current.offset = 0;			/* first char in the file */
	     current.file_offset, position.total_chars = 0;
	     next = ck.entry (ck.last).forward;		/* get index of next checkpoint */
	     ck.point (next) = current;		/* save the start as the next checkpoint */
	     ck.last = next;			/* advance the index */

	end;
	else do;					/* we found a valid checkpoint */

	     if ^force_ck_pt then
		if (high_page < current.page_no) & (target > current.page_no) then
		     go to forward;

	     current.page_no, position.page_number = ck.point (ind).page_no;
	     current.line_count, position.total_lines = ck.point (ind).line_count;
	     current.comp_no = ck.point (ind).comp_no;
	     current.offset = ck.point (ind).offset;
	     current.file_offset, position.total_chars = ck.point (ind).file_offset;
	     ck.last = ind;				/* move the checkpoint index to this entry */

	end;

	call iox_$control (iocbp, "runout", null, code);
	call iox_$modes (iocbp, "^print", omode, code);	/* don't move the paper */

	call iox_$put_chars (iocbp, addr (FF), 1, code);	/* make believe we wrote a FF */

	call iox_$modes (iocbp, "print", omode, code);	/* back to normal mode */

	call iox_$control (iocbp, "set_position", addr (position), code); /* set dim page and line positions */
	if code ^= 0 then do;			/* OOPS */
	     ec = code;
	     err_mess = "Unable to set position for checkpoint.";
	     return;
	end;

	force_ck_pt = "0"b;				/* we can believe the current position data now */

	if target = current.page_no then
	     return;				/* can't be less than current at this point */

forward:
	call output_file (SKIP, target, ec);		/* now go forward to the top of the target page */

	call iox_$control (iocbp, "runout", null, code);
	call iox_$modes (iocbp, "print", omode, code);	/* be sure we stay in print mode */

	return;

     end skip_to_page;

%page;

set_modes_and_labels: procedure ();

dcl  nm char (256) var;
dcl  i fixed bin;
dcl  v char (12) var;
dcl  ll fixed bin;					/* line length for this request */
dcl  ind fixed bin;					/* line indentation */
dcl  temp_label char (136);				/* temporary for cleaning the label */
dcl  len fixed bin;

/* since this request may have a different forms specification than the previous
   reset the paper size data based on this request */
	if ^continuous_paper then do;
	     if evaluate_forms_info_output_ptr ^= null then do;
		paper_info_data.phys_page_length = evaluate_forms_info_output.lines_per_page;
		paper_info_data.phys_line_length = evaluate_forms_info_output.chars_per_line;
		paper_info_data.lines_per_inch = evaluate_forms_info_output.lines_per_inch;
		call iox_$control (iocbp, "paper_info", addr (paper_info_data), code);
		if code ^= 0 then do;
		     call convert_status_code_ (code, short_msg, lg_msg);
		     call ioa_$rsnnl ("^a  while setting paper size info", msg, l, lg_msg);
		     call notify_user (substr (msg, 1, l));

/* something happened while setting paper size info */
		     call driver_fatal_error (code, "Changing paper size info.");
		     go to clean_out;
		end;
		call iox_$control (iocbp, "reset", null, code); /* reset everything based on the new page/line lengths */
	     end;
	end;

	nm = "";					/* clear the string */
	if dprint_msg.line_lth > 1 then do;
	     ll = min (dprint_msg.line_lth, prt_ctl.phys_line_length); /* save lth up to max for labels */
	     pic = ll;				/* convert to char form */
	     v = ltrim (rtrim (pic));			/* strip blanks */
	     nm = "ll" || v || ",";			/* make it into a mode string */
	end;
	else ll = prt_ctl.phys_line_length;

	if dprint_msg.lmargin > 1 then do;
	     ind = dprint_msg.lmargin;		/* save the value */
	     pic = ind;				/* convert */
	     v = ltrim (rtrim (pic));
	     nm = nm || "in" || v || ",";
	end;
	else ind = 0;				/* default is no indentation */

	i = length (nm);
	line_mode = nm;				/* save the ll and ind modes alone */
	if i > 0 then
	     substr (line_mode, i, 1) = "";		/* drop the last comma */

	if dprint_msg.control.nep | prt_ctl.force_nep then do;
	     nm = nm || "noskip,";
	     nep_mode_set = "1"b;			/* labels are not valid in noskip */
	     set_page_labels = "0"b;			/* so be sure we turn them off */
	end;
	else nep_mode_set = "0"b;			/* try for labels */
	if dprint_msg.control.single then
	     nm = nm || "single,";
	if dprint_msg.control.non_edited then
	     nm = nm || "non_edited,";
	if dprint_msg.control.truncate then
	     nm = nm || "truncate,";
	if dprint_msg.page_lth > 1 then do;
	     pic = dprint_msg.page_lth;
	     v = ltrim (rtrim (pic));
	     nm = nm || "pl" || v || ",";
	end;
	if dprint_msg.esc | prt_ctl.force_esc then
	     nm = nm || "esc,";			/* do we need slew control */
	if dprint_msg.control.line_nbrs then		/* line numbers? */
	     nm = nm || "line_nbrs,";
	if prt_ctl.force_ctl_char then
	     nm = nm || "ctl_char,";			/* pass control characters to the printer */
	i = length (nm);				/* get the string length */
	REQUEST.output_mode = nm;
	if i > 0 then
	     substr (REQUEST.output_mode, i, 1) = "";	/* clobber the last comma */

	pg_labels.top_label, pg_labels.bottom_label = " ";/* set leading blanks */

	if ^nep_mode_set then do;			/* only if labels can be used */

	     temp_label = translate (dprint_msg.top_label, " ", nl_vt_ff); /* remove naughty characters */
	     if verify (temp_label, space_ht_bs) > 0 then do; /* anything other than white space? */
		set_page_labels = "1"b;		/* set the labels in the main loop */
		len = length (rtrim (temp_label));	/* how long is  the label */
		if (ll > len) & dprint_msg.control.center_top_label then do;
		     len = divide (ll - len - ind, 2, 17, 0) - divide(ind, 2, 17, 0) + 1; /* calculate starting position (dim adds ind) */
		     substr (pg_labels.top_label, len) = temp_label; /* drop it in the right position */
		end;
		else pg_labels.top_label = temp_label;	/* put it in as given (almost) */
	     end;

	     temp_label = translate (dprint_msg.bottom_label, " ", nl_vt_ff); /* do it again for the bottom label */
	     if verify (temp_label, space_ht_bs) > 0 then do;
		set_page_labels = "1"b;
		len = length (rtrim (temp_label));
		if (ll > len) & dprint_msg.control.center_bottom_label then do;
		     len = divide (ll - len - ind, 2, 17, 0) - divide(ind, 2, 17, 0) + 1;
		     substr (pg_labels.bottom_label, len) = temp_label;
		end;
		else pg_labels.bottom_label = temp_label;
	     end;
	end;

	return;

     end set_modes_and_labels;

%page;

print_head_banner: procedure (code);

dcl  code fixed bin (35);				/* error code */
dcl  ec fixed bin (35);

	iodd_static.quit_during_request = "0"b;		/* reset for each copy */
	code = 0;					/* clear the code */

	if iodd_static.ctl_term.attached then do;	/* message to ctl term? */
	     call write_control_form_ (iodd_static.form_type, iodd_static.ctl_output, addr (REQUEST), ec);
	     if ec ^= 0 then do;
		if ec ^= error_table_$action_not_performed then do; /* this one is normal */
		     call iodd_msg_ (error, master, ec, whoami, "Writing message on control terminal.");
		     iodd_static.slave_hold = "1"b;	/* avoid automatic start */
		end;
		ctl_msg_sent = "0"b;		/* don't wait for bad message */
	     end;
	     else ctl_msg_sent = "1"b;		/* say all was well, so we can wait */
	     if ctl_wait_list.number = 1 & ctl_msg_sent then do; /* are we going to sync with the term? */
		call ipc_$drain_chn (ctl_wait_list.channel, ec);
		if ec ^= 0 then do;			/* avoid futher trouble, but not fatal */
		     ctl_wait_list.channel = 0;	/* stop trying */
		     ctl_wait_list.number = 0;
		     iodd_static.slave_hold = "1"b;
		     ctl_msg_sent = "0"b;		/* don't wait , no wakeup will come */
		     call convert_ipc_code_ (ec);
		     call iodd_msg_ (error, master, ec, whoami, "print_head_banner bad call to ipc_drain");
		end;
		else call timer_manager_$alarm_wakeup (driver_status.form_wait_time, "11"b, ctl_wait_list.channel);
	     end;
	end;
	else ctl_msg_sent = "0"b;			/* don't wait */

	call iox_$control (iocbp, "reset", null, code);	/* get to a known format */
	call iox_$control (iocbp, "inside_page", null, code); /* and page position */

	if ^REQUEST.no_separator | REQUEST.copy_no = 1 then do;
	     call iodd_static.print_head_sheet (iocbp, prt_ctl_ptr, addr (REQUEST), code); /* write head sheet */
	     if code = 0 then
		header_done = "1"b;			/* for the error routines */
	end;					/*	otherwise ignore the banner type and just align the paper */

	call iox_$control (iocbp, "reset", null, code);	/* don't charge for advertizing */
	return;

     end print_head_banner;

%page;

print_tail_banner: procedure (code);

dcl  code fixed bin (35);
dcl  ec fixed bin (35);
dcl  odd_page bit (1);

dcl  1 event_info aligned,				/* info returned from ipc_$block */
       2 chan fixed bin (71),
       2 message fixed bin (71),
       2 sender bit (36),
       2 origin fixed bin,
       2 wait_list_index fixed bin;

	code = 0;					/* clear the error code */
	odd_page = (mod (position.page_number, 2) = 1);	/* did we stop on an odd page? */

	if nep_mode_set & continuous_paper then do;	/* in nep mode, check paper position */
	     if position.line_number > (prt_ctl.phys_page_length - divide (prt_ctl.lines_per_inch, 2, 17))
		& odd_page then do;
		call iox_$put_chars (iocbp, addr (FF), 1, code); /* move ahead when partially printed */
		odd_page = ""b;			/* now proceed as though we finished on even page */
	     end;
	end;
	else if set_page_labels then			/* if we owe a bottom label on last page */
	     call iox_$control (iocbp, "end_of_page", null, code);

	call iox_$control (iocbp, "reset", null, code);	/* clear the counters and page labels */

/* for remotes, move to the right page */
	if ^odd_page & iodd_static.attach_type ^= ATTACH_TYPE_IOM & continuous_paper then
	     call iox_$put_chars (iocbp, addr (FF), 1, code); /* move ahead when partially printed */

	call iox_$control (iocbp, "outside_page", null, code);
	if ^REQUEST.no_separator | (REQUEST.copy_no = REQUEST.copies) then
	     call iodd_static.print_tail_sheet (iocbp, prt_ctl_ptr, addr (REQUEST), code);

	if ^iodd_static.quit_during_request &		/* on quit, don't wait for ctl term  */
	     ctl_msg_sent then do;			/* avoid premature blocking */
	     call ipc_$block (addr (ctl_wait_list), addr (event_info), ec); /* wait for form to finish */
	     if ec ^= 0 then do;
		call convert_ipc_code_ (ec);
		call iodd_msg_ (error, master, ec, whoami, "Attempting to block for ctl_term.");
		iodd_static.slave_hold = "1"b;	/* go to cmd level */
	     end;
	end;

	return;

     end print_tail_banner;

%page;

init_static_ctl: procedure ();

	string (static_ctl.flags) = ""b;

	static_ctl.banner_type = NORMAL_BANNERS;
	static_ctl.banner_bars = NORMAL_BANNER_BARS;
	static_ctl.banner_indent = 0;
	static_ctl.banner_line = 1;

	static_ctl.phys_line_length = 136;
	static_ctl.phys_page_length = 66;
	static_ctl.lines_per_inch = 6;

	string (static_ctl.channel_stops) = "0"b;	/* no channel stops defined here */

	return;

     end init_static_ctl;


clean_proc: procedure ();

	iodd_static.segptr = null;			/* tell signal handler we are done with it */

	if fcbp ^= null then do;
	     if segp ^= null then
		if privileged then
		     call phcs_$deactivate (segp, (0));
	     call msf_manager_$close (fcbp);
	end;

	segp, fcbp = null;				/* because this is used for several functions */

	return;

     end clean_proc;
%page;
set_up_page_labels: proc;

/* this routine will set up the printer to generate labels if they are needed */

/* if this is single sheet paper and there is a control string to initialize
   the printer send it out now.  This is needed since head_sheet_ and
   tail_sheet_ programs for the printer might alter the characteristics of the
   printer in order to output their forms */

	if ^continuous_paper then do;
	     if evaluate_forms_info_output_ptr ^= null then do;
		if evaluate_forms_info_output.escape_length ^= 0 then do;
		     call iox_$modes (iocbp, "rawo", "", code);
		     call iox_$control (iocbp, "prt_conv_off", null (), code);
		     call iox_$put_chars (iocbp, addr (evaluate_forms_info_output.escape_string),
			(evaluate_forms_info_output.escape_length), code);
		     call iox_$control (iocbp, "prt_conv_on", null (), code);
		     call iox_$modes (iocbp, "^rawo", "", code);
		end;
	     end;
	end;

	if set_page_labels then do;			/* only if we need page labels */
	     if (prt_ctl.banner_type = NO_BANNERS & prt_ctl.banner_bars = NO_BANNER_BARS)
		| (prt_ctl.banner_type = NO_BANNERS & ^REQUEST.separator)
		| (REQUEST.no_separator & ^(REQUEST.copy_no = 1)) then
		call iox_$put_chars (iocbp, addr (FF), 1, code);

/* move below page label position for this page */
	     call iox_$control (iocbp, "end_of_page", null, code);
	     call iox_$modes (iocbp, line_mode, omode, code);
	     if code ^= 0 then do;
		call convert_status_code_ (code, short_msg, lg_msg);
		call ioa_$rsnnl ("^a  while setting user line modes to: ^a^/  from: ^a", msg, l, lg_msg,
		     line_mode, omode);
		call notify_user (substr (msg, 1, l));

/* The user tried to put the left margin after the right margin. */
		call driver_fatal_error (code, "Changing to user line modes.");
		go to clean_out;
	     end;

	     call iox_$control (iocbp, "page_labels", addr (pg_labels), code);
	     if code ^= 0 then do;
		call driver_fatal_error (code, "Setting page_labels.");
		go to clean_out;
	     end;
	end;
	if (set_page_labels) |			/* get the top label out			*/
						/* regardless of anything else		*/
	     ^((prt_ctl.banner_type = NO_BANNERS & prt_ctl.banner_bars = NO_BANNER_BARS)
	     | (prt_ctl.banner_type = NO_BANNERS & ^REQUEST.separator)
	     | (REQUEST.no_separator & ^(REQUEST.copy_no = 1))) then /* if no labels then */
	     call iox_$put_chars (iocbp, addr (FF), 1, code); /* if not at top_inside_page, go there */

     end set_up_page_labels;
%page;

/* ======== OTHER EXTERNAL ENTRIES ========= */

error_during_request: entry (cond);			/* for coming back after signal */

dcl  cond char (*);

	fault_name = cond;
	go to err_label;


single_copy: entry ();

/* abort multiple copies on command */

	request_data_p -> ordata.copies = 1;		/* force copy limit to 1 */
	return;

%page; %include access_audit_user_info;
%page; %include access_audit_eventflags;
%page; %include dprint_msg;
%page; %include driver_status;
%page; %include iod_constants;
%page; %include iod_tables_hdr;
%page; %include iodd_static;
%page; %include kst_attributes;
%page; %include mseg_message_info;
%page; %include output_request_data;
%page; %include print_driver_data;
%page; %include prt_ctl;
%page; %include prt_order_info;
%page; %include queue_msg_hdr;
%page; %include request_descriptor;
%page; %include send_mail_info;
%page; %include system_forms_info;

     end do_prt_request_;
