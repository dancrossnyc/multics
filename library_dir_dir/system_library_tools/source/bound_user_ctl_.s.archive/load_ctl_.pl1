/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/* format: style4 */
load_ctl_: proc (P_utep, P_satep, P_pdtep, P_unused1, P_unused2, P_debug,
	P_text, P_code);

/* LOAD_CTL_ - procedure to check whether a user may log in.

   This procedure is called by lg_ctl_ in the course of every login.

   Modified 750604 by T. Casey to implement priority scheduler interface.
   Modified May 1976 by T. Casey to allow prio sked to be turned on and off by MGT installations.
   Modified 760819 by Roy Planalp to pass error msg up to lg_ctl_
   Modified October 1976 by T. Casey for version 3 MGT.
   Modified September 1977 by T. Casey to (1) call reassign_work_classes_ even when
   .		maxu auto is off, and (2) not undo an abs stop at shift change.
   Modified May 1978 by T. Casey to execute shift_config_change.ec at appropriate times,
   .		to improve strategy for promoting secondary users (the latter courtesy of James Dougal),
   .		and to log instances of grace time in PDTE exceeding the limit in the SATE.
   Modified November 1978 by T. Casey for MR7.0 absentee load control. Significant change: absentee jobs are no longer
   counted in anstbl.extra_units. They are charged to their load control groups, as primary or secondary users.
   Modified April 1979 by T. Casey for MR7.0a to fix bugs and complete implementation of secondary foreground jobs.
   Modified July 1979 by T. Casey for MR8.0 to fix a design flaw in daemon load control.
   Modified June 1981 by E. N. Kittlitz for MR9.0 to make it compile again.
   Modified November 1981, E. N. Kittlitz.  user_table_entry conversion.
   Modified December 1981, E. N. Kittlitz.  whotab copy of autbl control info.
   Modified April 1982, E. N. Kittlitz. New AS initialization. set_maxunits uses biggest config if no match.

*/

/****^  HISTORY COMMENTS:
  1) change(86-06-05,GJohnson), approve(86-06-05,MCR7387),
     audit(86-06-10,Martinson), install(86-07-11,MR12.0-1092):
     Correct error message documentation.
  2) change(86-08-04,Swenson), approve(87-07-13,MCR7741),
     audit(87-07-23,Brunelle), install(87-08-04,MR12.1-1055):
      A) Use login server message buffer to return informative messages
         to MNA connections.
  3) change(87-04-27,GDixon), approve(87-07-13,MCR7741),
     audit(87-07-23,Brunelle), install(87-08-04,MR12.1-1055):
      A) Upgraded for change to answer_table.incl.pl1 and
         user_table_entry.incl.pl1.
      B) Fix attempt to set parameter not supplied to
         check_for_process_creation entrypoint.
  4) change(87-07-22,GDixon), approve(87-07-22,MCR7741),
     audit(87-07-23,Brunelle), install(87-08-04,MR12.1-1055):
      A) Add operator message document for undocumented sys_log_ calls.
      B) Use constants declared in sys_log_constants.incl.pl1 in sys_log_
         calls.
  5) change(87-10-04,Beattie), approve(87-10-26,MCR7785),
     audit(87-12-04,Parisek), install(87-12-07,MR12.2-1008):
     Accomodate changes in format of date_time strings.
                                                   END HISTORY COMMENTS */

/* Parameters */

dcl  P_code fixed bin (35) parameter;			/* status code */
dcl  P_debug char (8) aligned parameter;		/* unused */
dcl  P_pdtep ptr parameter;				/* pointer to user's PDT entry */
dcl  P_satep ptr parameter;				/* pointer to SAT entry for project */
dcl  P_text char (168) varying parameter;		/* text of error returned */
dcl  P_unused1 ptr parameter;				/* unused */
dcl  P_unused2 fixed bin parameter;			/* unused */
dcl  P_utep ptr parameter;				/* pointer to user's user table entry */

/* Automatic */

dcl (absentee, background, daemon, foreground, foreground_absentee, 
     interactive)bit (1) aligned init (""b),		/* what kind of user do we have? */
     ct1 char (16) aligned,				/* scratch date temp. */
     ec fixed bin,					/* error code */
    (i, j) fixed bin,				/* counters */
     junk char (8) aligned,
     longinfo char (100) aligned,
     maxprim fixed bin,				/* group maximum load units */
     mcode fixed bin (35),				/* remark by load_ctl_ about preemption */
     mesl fixed bin,
     msg3 char (100) aligned,				/* message buffer */
    (ncpu, nkmem, nbulk) fixed bin,			/* configuration variables */
    (pdtep, satep) ptr,				/* ptr to pdt entry and sat entry */
     check_for_process_creation_ep bit(1),		/* off if entered at main ep, */
						/* on if entered at check_for_process_creation ep */
     reject_abs bit (1) aligned init (""b),		/* turned on if abs job can never log in */
     time_now fixed bin (71),				/* current clock reading */
     unitsmax fixed bin;				/* anstbl.max_units - anstbl.extra_units */

dcl  1 wci_area like work_class_info aligned automatic;

/* Static */

dcl  ME char (32) initial ("load_ctl_") internal static options (constant);
dcl  NL char (1) int static init ("
");
dcl  tracing bit (1) aligned init ("0"b) int static;	/* Trace switch. */
dcl  prio_sked bit (1) aligned int static;		/* = true if the priority scheduler is enabled in the mgt */
dcl  first_group fixed bin int static;			/* = 1 for old mgt, 17 for new */

/* External */

dcl  as_error_table_$bumped_in_group fixed bin (35) ext;
dcl  as_error_table_$bumped_secondary fixed bin (35) ext;
dcl  as_error_table_$no_user_to_bump fixed bin (35) ext;
dcl  as_error_table_$groupmax fixed bin (35) ext;
dcl  as_error_table_$gpabsmax fixed bin (35) ext;
dcl  as_error_table_$grp_full fixed bin (35) ext;
dcl  as_error_table_$nf_nosec fixed bin (35) ext;
dcl  as_error_table_$no_group fixed bin (35) ext;
dcl  as_error_table_$not_full fixed bin (35) ext;
dcl  as_error_table_$preempt_emergency fixed bin (35) ext;
dcl  as_error_table_$preempt_emergency_prime fixed bin (35) ext;
dcl  as_error_table_$preempt_group fixed bin (35) ext;
dcl  as_error_table_$preempt_secondary fixed bin (35) ext;
dcl  as_error_table_$proj_max fixed bin (35) ext;
dcl  as_error_table_$protec_msg fixed bin (35) ext;
dcl  as_error_table_$protec_till_msg fixed bin (35) ext;
dcl  as_error_table_$saturate fixed bin (35) ext;
dcl  as_error_table_$subject fixed bin (35) ext;
dcl  as_error_table_$sys_full fixed bin (35) ext;
dcl  as_error_table_$sysgrpfl fixed bin (35) ext;
dcl  error_table_$out_of_sequence fixed bin (35) ext static;
dcl  error_table_$unimplemented_version fixed bin (35) ext static;

/* Builtins */

dcl  (addr, clock, divide, hbound, length, max, min, null, reverse, rtrim, string, substr, verify) builtin;

/* Entries */

dcl  absentee_user_manager_$update_whotab_abs_control entry;
dcl  absentee_utility_$au_send_wakeup entry;
dcl  admin_$abs entry options (variable);
dcl  as_meter_$read_config entry (fixed bin, fixed bin, fixed bin);
dcl  asu_$bump_code entry (ptr, fixed bin (35), char (8) aligned, fixed bin, fixed bin);
dcl  convert_status_code_ entry (fixed bin (35), char (8) aligned, char (100) aligned);
dcl  date_time_$format entry (char(*), fixed bin(71), char(*), char(*)) returns(char(250) var);
dcl  ec_shift_config_change_ entry (char (*), fixed bin, fixed bin, fixed bin, fixed bin, fixed bin, fixed bin);
dcl  hcs_$initiate entry (char (*), char (*) aligned, char (*), fixed bin (1), fixed bin (2), ptr, fixed bin);
dcl  ioa_$rs entry options (variable);
dcl  ioa_$rsnnl entry options (variable);
dcl  reassign_work_classes_ entry (fixed bin);
dcl  sub_err_ entry () options (variable);
dcl  sys_log_ entry options (variable);
dcl  sys_log_$error_log entry options (variable);

%page;
/* Program */
/*
   load_ctl_: proc (P_utep, P_satep, P_pdtep, P_unused1, P_unused2,
   P_debug, P_text, P_code);
*/
	utep = P_utep;
	satep = P_satep;
	pdtep = P_pdtep;
	P_debug = "";
	check_for_process_creation_ep = "0"b;
	goto COMMON;

check_for_process_creation:
     entry (P_utep, P_code);

	utep = P_utep;
	satep = ute.uprojp;
	pdtep = ute.pdtep;
	check_for_process_creation_ep = "1"b;

COMMON:
	P_code = 0;
	time_now = clock ();

/* What kind of user are we dealing with? */

	if ute.process_type = PT_DAEMON then daemon = "1"b;
	else if ute.process_type = PT_ABSENTEE then do;	/* absentee */
	     absentee = "1"b;
	     if ute.queue > 0 then			/* if queue number > 0 */
		background = "1"b;			/* it's a background job */
	     else foreground, foreground_absentee = "1"b; /* it's a foreground absentee job */
	end;
	else					/* interactive */
	     foreground, interactive = "1"b;


/* Recompute the load figures for each group */

	ansp = as_data_$ansp;
	autp = as_data_$autp;
	unitsmax = anstbl.max_units - anstbl.extra_units;
	mgt.total_units = 0;			/* will recompute this */
	do i = first_group to mgt.current_size;		/* look at all groups - skip over work classes */
	     mgtep = addr (mgt.entry (i));
	     if group.max_prim >= 0 then do;		/* recalculate maxprim */
		if group.denom = 0 then maxprim = 0;	/* Maxprim may have a fraction of maxunits */
		else maxprim = divide (group.num * unitsmax, group.denom, 17, 0);
		maxprim = maxprim + group.minu;	/* Plus some constant */
		maxprim = 10 * divide (max (maxprim, 0), 10, 17, 0);
						/* make nonnegative and multiple of 10 */
		mgt.total_units = mgt.total_units + maxprim;
		group.max_prim = maxprim;		/* also set into group table */
	     end;
	     if group.denom1 = 0 then maxprim = 0;
	     else maxprim = divide (group.num1 * unitsmax, group.denom1, 17, 0);
	     maxprim = maxprim + group.minamax;		/* Add in constant part */
	     maxprim = 10 * divide (max (maxprim, 0), 10, 17, 0);
	     group.absolute_max = maxprim;

	     group.absentee_limit = min (group.absentee_max, max (group.absentee_min,
		divide (group.absentee_pct * autbl.max_abs_users, 100, 17, 0)));

	     if group.absentee_limit = 0 then		/* if zero, check for these new parameters not being set */
		if group.absentee_min = 0 & group.absentee_pct = 0 then /* if they're unset, behave in pre-MR7.0 way */
		     group.absentee_limit = autbl.max_abs_users; /* which is to have all slots open to each group */

	end;

/* Now, assign a group to this user, checking to make sure it is valid */

	ute.group = project.group;			/* start with default group for project */

	if ute.at.igroup then			/* the pdt and sat attribute bits were anded together
						   in lg_ctl_ */
	     if permitted_proj_group (user.group) then	/* if group ok for project */
		if existing_group ((user.group)) then do; /* and it is in the mgt */
		     ute.group = user.group;
		     goto have_good_group;		/* My apologies to Dijkstra */
		end;

	if existing_group (ute.group) then		/* check existence of project's default group */
	     goto have_good_group;

	if ute.process_type = PT_ABSENTEE then		/* maybe we will have better luck with an absentee group */
	     call set_absentee_group;			/* if there is one */

	if existing_group (ute.group) then		/* if there was */
	     goto have_good_group;

/* If we fall thru, there was absolutely no load control group that we could put the guy in */

	call sys_log_ (SL_LOG_BEEP, "^a: Group ^a missing for ^a.^a", ME,
	     project.group, ute.person, ute.project);

	if absentee then reject_abs = "1"b;		/* no group is fatal */
	mcode = as_error_table_$no_group;		/* There is some difference of opinion about that ... */
	go to nolog;				/* but for now, we refuse to let him log in */

have_good_group:					/* come here from above, when group successfully assigned */

	if daemon then				/* daemons are not subject to load control */
	     goto logon1;				/* so skip over all the checking */

	if absentee then				/* if absentee job */
	     if ute.abs_run then			/* started by abs run command */
		if foreground then goto onprime;	/* skip the checking, but charge the group */
		else goto on_sec;

/* Here begins the load control decision */


	if group.max_prim < 0 then do;		/* Negative is special flag, take all the rest */
	     maxprim = unitsmax - mgt.total_units;
	     if maxprim <= 0 then
		call sys_log_ (SL_LOG_BEEP,
		"load_ctl_: maxu too small (^d), ^d units for group ^a",
		anstbl.max_units, maxprim, group.group_id);
	end;
	else maxprim = group.max_prim;

/* First check if project has maximum users or group is over absolute max.
   Somewhere, in the history of Multics, the value of project.max_users
   became obsolete.  It is set to 32767 in new_proj and is not changeable
   in edit_proj.  The print_sat command displays it as "maxprim".  This
   comment serves to document what I found when I tried to figure out
   what was hapenning in the following code.  -- Eric Swenson. */

	if project.n_users >= project.max_users then do;	/* Project is at maximum. */
	     mcode = as_error_table_$proj_max;
	     if background then goto nolog;		/* background absentee can't bump anybody */
	     if ^(ute.at.pm_ok) then go to nolog;	/* If cannot be primary, forget it. */
	     if ^(ute.at.bumping) then go to nolog;	/* If cannot bump, forget it. */
	     call findsb (2, 0, 1, -1, ec);		/* Try demoting some user on same proj */
	     call findsb (2, 1, 0, 1, ec);		/* Try bumping a secondary now. */
	     if ec > 0 then go to onprime1;		/* whee. */
	     call findsb (2, 0, 1, 2, ec);		/* Try to bump primary on project. Respect grace. */
	     if ec > 0 then go to onprime1;		/* Did we get one? */
	     go to nolog;
	end;

	if group.n_prim + group.n_sec + ute.user_weight > group.absolute_max then do;
	     mcode = as_error_table_$groupmax;
	     if background then goto nolog;
	     if ^ute.at.pm_ok then go to nolog;		/* If cannot be primary, forget it. */
	     if ^ute.at.bumping then go to nolog;	/* If cannot bump, forget it. */
	     call findsb (1, 0, 1, -1, ec);		/* First demote prime if possible. */
	     call findsb (1, 1, 0, 1, ec);		/* Demoting may have made a prime slot. */
	     if ec > 0 then go to onprime1;
	     go to fullup;
	end;

	if background then				/* if background absentee */
	     if group.n_abs >= group.absentee_limit then do; /* and group is at its background limit */
		mcode = as_error_table_$gpabsmax;
		goto nolog;
	     end;

/* Is system full? If not, check group limits here. */

	if anstbl.n_units + ute.user_weight <= anstbl.max_units then
	     if anstbl.max_users > anstbl.n_users then do;
		mcode = as_error_table_$not_full;
		if ute.at.guaranteed_login & foreground then go to onprime;
		if ute.at.pm_ok & foreground then	/* If user may be primary, check group full */
		     if group.n_prim + ute.user_weight <= maxprim then go to onprime;
		     else if ute.at.bumping then do;	/* all primary slots in use. try to demote somebody */
			call findsb (1, 0, 1, -1, ec);/* .. who is now prime but whose grace expired */
			if ec > 0 then go to onprime; /* .. and if so, give new fellow the prime */
			mcode = as_error_table_$grp_full;
		     end;

		if background then goto on_sec;	/* background absentee job is always a secondary user */
		if interactive & ute.at.sb_ok then go to on_sec; /* If cannot make interactive user prime,
						   can he be secondary? */

		if foreground_absentee & ute.uflags.foreground_secondary_ok then do; /* if fg abs job can be secondary */
		     autbl.n_sec_fg = autbl.n_sec_fg + 1; /* count secondary foreground jobs */
		     goto on_sec;
		end;

		mcode = as_error_table_$nf_nosec;	/* Sys not full, grp full, no secondary allowed */
		go to nolog;
	     end;

/* System is full, so we can only log this user in by bumping someone. */

	mcode = as_error_table_$sys_full;
	if ^(ute.at.pm_ok & foreground) then go to nolog; /* If user cannot be prime, forget it */
	if group.n_prim + ute.user_weight <= maxprim then do;
	     mcode = as_error_table_$bumped_secondary;
	     call findsb (0, 1, 0, 1, ec);		/* Must be secondary on system. Bump */
	     if ec = 0 then
		call sys_log_ (SL_LOG_SILENT,
		"^a: Too many primes. ^a.^a (^a) ^d/^d",
		ME, ute.person, ute.project, ute.group,
		anstbl.n_units, anstbl.max_units);
	     if anstbl.max_users > anstbl.n_users then go to onprime;
	     mcode = as_error_table_$saturate;		/* No APT entry available */
	     go to nolog;				/* Our fault. Sorry */
	end;

/* System full, group full. Can we bump some other user in the same group? */

	mcode = as_error_table_$sysgrpfl;

fullup:
	if background then goto nolog;		/* background user can't bump anybody */
	if ute.at.guaranteed_login then go to trybump;	/* guaranteed login will try to bump */
	if ^(ute.at.bumping) then go to nolog;		/* System is full unless someone on group can be bumped */
	if group.n_prim = 0 then go to nolog;		/* If nobody to bump, forget it */
trybump:	call findsb (1, 0, 1, 2, ec);			/* Search for prime in same group (respect grace) to bump */
	if ec = 0 then do;				/* if nobody bumped.. */
	     if ute.at.guaranteed_login then		/* Did we promise a login? */
		if anstbl.n_users < anstbl.max_users then do;
		     mcode = 0;			/* clear out error code */
		     go to onprime;
		end;
		else do;				/* yes, and no room. */
		     call findsb (0, 1, 0, 3, ec);	/* Emergency bump of secondary */
		     if ec = 0 then call findsb (0, -1, 1, 4, ec); /* Uh-oh. No secondaries. Primary? */
		     if ec = 0 then call findsb (0, -1, 0, 4, ec); /* Really in trouble. Anybody at all */
		     if ec > 0 then go to onprime;
		end;
	     mcode = as_error_table_$no_user_to_bump;
	     go to nolog;
	end;
onprime1: mcode = as_error_table_$bumped_in_group;

/* He can be logged in as a primary user */

onprime:	ute.standby_line = 0;			/* Note primary */
	group.n_prim = group.n_prim + ute.user_weight;
	call check_max_grace;			/* set grace time to min of PDTE and SATE values */
	ute.cant_bump_until = time_now + ute.bump_grace;
	if ute.at.brief | absentee then go to logon1;	/* Skip message if brief or absentee */
	call Write_User_Message (mcode, "");
	ct1 = "";
	mcode = as_error_table_$protec_msg;
	if ^ute.at.nobump then
	     if ute.bump_grace < 86400000000 then do;	/* Fix message to say how long he's safe. */
		ct1 = date_time_$format ("time", ute.cant_bump_until, "", "");
		mcode = as_error_table_$protec_till_msg;
	     end;
	call convert_status_code_ (mcode, junk, longinfo);
	if longinfo ^= "" then do;
	     call ioa_$rsnnl (rtrim (longinfo), msg3, mesl, ct1);
	     call Write_User_Message (0, (msg3));
	end;
	go to logon1;

/* He can be logged in as a secondary user */

on_sec:	ute.standby_line = 1;			/* Note secondary */
	group.n_sec = group.n_sec + ute.user_weight;
	ute.cant_bump_until = time_now;		/* true but uninteresting */
	call check_max_grace;			/* set grace time to min of PDTE and SATE values */
	if ute.at.brief | absentee then go to logon1;	/* skip message if brief mode or absentee */
	mcode = as_error_table_$subject;
	call Write_User_Message (mcode, "");
logon1:

/* Now, assign a work class based on the load control group */

	if background then do;			/* if background absentee */
	     autbl.n_background_abs = autbl.n_background_abs + 1; /* /* count total background jobs */
	     autbl.abs_units = autbl.abs_units + ute.user_weight; /* count total background units */
	     group.n_abs = group.n_abs + 1;		/* and count background users per group, before changing group */
	     if ^group.absentee.allowed then		/* if absentees not allowed in his group */
		call set_absentee_group;		/* try to find another group for him */
	     else ute.abs_group = group.group_id;	/* but if we can't, he stays in this group */
	end;

/* See if priority scheduler is supposed to be on or off */

	if ^prio_sked then do;			/* if prio sked was off, see if MGT installation turned it on */
	     if mgt.version_indicator = "VERSION" then	/* if good MGT */
		if mgt.prio_sked_on_tape then		/* and prio sked is on system tape */
		     if mgt.prio_sked_enabled then	/* and MGT says to use it */
			prio_sked = "1"b;		/* do so */
	end;
	else					/* it was on - see if it still is */
	     if ^mgt.prio_sked_enabled then		/* if MGT says to turn it off */
	     prio_sked = ""b;			/* do so */

	if prio_sked then do;			/* if running with priority scheduler enabled */
	     if background then			/* if background absentee */
		ute.work_class = group.abs_wc (anstbl.shift);
	     else ute.work_class = group.int_wc (anstbl.shift);
	end;
	else ute.work_class = 1;			/* it is definitely necessary that this be 1, and not zero or
						   garbage, when running with the priority scheduler disabled */


/* Update various counters of users and units */

	anstbl.n_users = anstbl.n_users + 1;
	anstbl.n_units = anstbl.n_units + ute.user_weight;
	if daemon then				/* if daemon process */
	     anstbl.extra_units = anstbl.extra_units + ute.user_weight; /* incrememnt extra units */
	project.n_users = project.n_users + 1;

	if autbl.abs_maxu_auto then			/* if operator has not set abs maxu manually, then */
	     if installation_parms.max_abs (anstbl.shift) ^= -1 then /* unless dynamic abs maxu is disabled */
		call set_abs_maxu;			/* go set it as function of interactive load */

	return;

/* Insert code for edit-only here if desired */

nolog:	if ^check_for_process_creation_ep then do;
	     call convert_status_code_ (mcode, (""), longinfo);
	     if longinfo ^= ""
		then P_text = substr (longinfo, 1, length (longinfo) + 1 - verify (reverse (longinfo), " ")) || NL;
	     else P_text = NL;
	end;
	P_code = mcode;
	ute.failure_reason = 3;			/* 3 means load_ctl_ said no */
	if reject_abs then				/* if absentee job with serious problem */
	     ute.login_result = 1;			/* don't let it keep trying to log in */
	else ute.login_result = 2;			/* 2 means allow another attempt */
	return;
%page;
/* ************************************************************************* */

/* ADDITIONAL ENTRY POINTS, IN ALPHABETIC ORDER  */

init: entry ();

/**** Entry called during AS initialization to initialize load control */

	if ^sc_stat_$Multics_typed | sc_stat_$Go_typed then
	     call sub_err_ (error_table_$out_of_sequence, "load_ctl_$init",
		ACTION_CANT_RESTART);
	wcip = addr (wci_area);
	string (work_class_info.switches) = ""b;	/* only need to clear the switches,
						   since they control what other variables are looked at */

	ansp = as_data_$ansp;
	autp = as_data_$autp;
	anstbl.extra_units = 0;			/* Clear control variables. */
	call hcs_$initiate (anstbl.sysdir, "mgt", "", 0, 1, mgtp, ec);
	if mgtp = null then
	     call sub_err_ (ec, "load_ctl_$init", ACTION_CANT_RESTART,
		null (), (0), "mgt");

/* The following code decides whether or not to run with the priority scheduler enabled */

	prio_sked = "0"b;				/* static switch - start with it off */
	first_group = 1;				/* static index - start by assuming old format mgt */

	if mgt.version_indicator = "VERSION " then do;	/* new format mgt (version 1 had no version stored in it) */
	     first_group = 17;			/* the first 16 are work classes */

	     if mgt.version = 2 then goto V2_MGT;	/* accept old MGTs for a while */
	     if mgt.version = MGT_version_3 then do;	/* if this is the version that we know about */
V2_MGT:
		mgt.prio_sked_on_tape = "1"b;		/* also tell them if it is there */
		if mgt.prio_sked_enabled then		/* see if administrator turned us off */
		     prio_sked = "1"b;		/* if he didn't, then we run with the priority scheduler */
	     end;					/* end version is ok do group */
	     else do;				/* possible incompatibility, or garbaged mgt */
		call sys_log_ (SL_LOG_BEEP,
		     "^a: Unknown mgt version number: ^d",
		     ME, mgt.version);
		call sub_err_ (error_table_$unimplemented_version,
		     ME, ACTION_CANT_RESTART);
	     end;

	end;					/* end mgt version >= 2 do group */

	maxprim = 0;				/* Check for error in tables. */
	do i = first_group to mgt.current_size;		/* .. and reset the table. */
	     mgtep = addr (mgt.entry (i));
	     if group.max_prim < 0 then
		if maxprim = 0 then maxprim = i;
		else
		     call sys_log_ (SL_LOG_BEEP,
		     "^a: more than one group has -1 max: ^a",
		     ME, group.group_id);
	     group.n_prim, group.n_sec, group.n_eo, group.n_abs = 0; /* Clear group counters. */

	end;


/* after act_ctl_$init has been called, and the shift is defined,
   as_init_ will call reassign_work_classes_, to set up the initial set of
   work classes.  (work class definitions are a function of shift, and the
   shift is not defined at this point in initialization.) */

	return;
%page;
lctraceoff: entry;

	tracing = "0"b;
	return;


lctraceon: entry;

	tracing = "1"b;
	return;
%page;
load_level: entry (resp, idle_pct);

dcl  resp fixed bin,				/* current response estimate */
     idle_pct float bin;				/* percentage idle */

	if as_data_$ansp = null then return;
	ansp = as_data_$ansp;
	autp = as_data_$autp;
	if anstbl.auto_maxu ^= 2 then return;
	if resp < anstbl.response_low then do;
	     anstbl.max_units = max (1.1e0 * anstbl.n_units, anstbl.n_units * (1e0 / (1e0 - idle_pct)));
	end;
	else if resp > anstbl.response_high then do;
	     anstbl.max_units = 0.9e0 * anstbl.n_units;
	end;
	else do;
	     anstbl.max_units = anstbl.n_units;
	end;
	whotab.mxunits = anstbl.max_units;

	return;

/* ****************************************************************************************************************** */

/* These two entry points have in common that they both read the config deck
   and search the config array for a matching configuration and shift.
   Then they set various shift-and-configuration-dependent parameters.
   The first only sets absentee parameters, and is called whenever the operator
   types "abs KEYWORD auto" where KEYWORD can be one of several.
   The second sets all parameters, including absentee, and starts the absentee
   facility if appropriate. It is called at startup time, and shift change,
   and whenever the operator types "maxu auto".
*/

set_abs_parms: entry;

dcl  abs_only bit (1) aligned;

	abs_only = "1"b;
	goto maxu_common;

set_maxunits: entry (oshf);

dcl  oshf fixed bin;				/* previous shift, if it just changed; else current shift */

	abs_only = ""b;
maxu_common:

	if as_data_$ansp = null then return;		/* if not initialized */
	ansp = as_data_$ansp;
	autp = as_data_$autp;
	if ^abs_only then do;
	     call reassign_work_classes_ (ec);
	     if ec ^= 0 then
		call sys_log_$error_log (SL_LOG_BEEP, ec, "load_ctl_",
		"During work class redefinition.");
	end;

	call as_meter_$read_config (ncpu, nkmem, nbulk);	/* Get current configuration. */

	if ^abs_only then
	     call ec_shift_config_change_ (anstbl.sysdir, oshf, anstbl.shift, anstbl.auto_maxu, ncpu, nkmem, nbulk);

	do i = 1 to installation_parms.ncon;		/* look up current configuration in config deck */
	     if ncpu <= installation_parms.cona (i).cpu then
		if nkmem <= installation_parms.cona (i).kmem then
		     if nbulk <= installation_parms.cona (i).kbulk then
			if anstbl.shift <= installation_parms.cona (i).shift then go to cfnd;
	end;
	i = installation_parms.ncon;			/* last one is used */
	call sys_log_ (SL_LOG_BEEP,
	     "^a: configuration not in tables. ^d cpu, ^d mem, ^d bulk, shift ^d
	using configuaration ^d cpu, ^d mem, ^d bulk, shift ^d",
	     ME, ncpu, nkmem, nbulk, anstbl.shift,
	     installation_parms.cona (i).cpu, installation_parms.cona (i).kmem,
	     installation_parms.cona (i).kbulk, installation_parms.cona (i).shift);

cfnd:
	if anstbl.auto_maxu ^= 0 then do;
	     anstbl.response_low = installation_parms.cona (i).response_low;
	     anstbl.response_high = installation_parms.cona (i).response_high;
	     if anstbl.auto_maxu = 1 then anstbl.max_units = installation_parms.cona (i).maxu_base;
	     whotab.mxunits = anstbl.max_units;
	end;

	if (^autbl.abs_up & ^autbl.abs_stopped) then	/* if abs not up and not stopped by operator, start it */
	     call admin_$abs ("start", "startup");

	if autbl.abs_up then do;			/* if absentee up, set parms not overridden by operator */

	     if autbl.abs_maxu_auto then do;
		if installation_parms.max_abs (anstbl.shift) = -1 then /* if dynamic abs maxu disabled */
		     whotab.max_abs_users, autbl.max_abs_users = installation_parms.cona (i).maxa; /* use per-shift constant */
		else call set_abs_maxu;		/* else go set abs maxu as function of interactive load */
	     end;

	     if autbl.abs_maxq_auto then
		autbl.last_queue_searched = installation_parms.cona (i).maxq;

	     if autbl.abs_qres_auto then
		do j = 1 to 4;
		autbl.qres (j) = min (installation_parms.max_qres (anstbl.shift, j),
		     max (installation_parms.min_qres (anstbl.shift, j),
		     divide (installation_parms.pct_qres (anstbl.shift, j) * autbl.max_abs_users, 100, 9, 0)));
	     end;

	     if autbl.abs_cpu_limit_auto then
		do j = 1 to 4;
		autbl.cpu_limit (j) = installation_parms.abs_cpu_max_limit (anstbl.shift, j);
	     end;

	     call absentee_user_manager_$update_whotab_abs_control; /* update public copy */
	     call absentee_utility_$au_send_wakeup;	/* parms changed, so tell abs to look for newly-eligible job */
	end;
	return;
%page;
unload: entry (P_utep, P_unused2);

          ansp = as_data_$ansp;
	autp = as_data_$autp;
	utep = P_utep;				/* copy arg */
	if ute.queue < 0 then do;			/* if daemon */
	     anstbl.extra_units = anstbl.extra_units - ute.user_weight; /* decrement extra units */
	     goto off1;
	end;
	do i = 1 to mgt.current_size;
	     mgtep = addr (mgt.entry (i));
	     if ute.queue > 0 then do;		/* if background absentee */
		if ute.abs_group = group.group_id then goto gf1;
	     end;
	     else if group.group_id = ute.group then go to gf1;
	end;
	call sys_log_ (SL_LOG_BEEP, "^a: group ^a missing at logout", ME,
	     ute.group);
	go to off1;
gf1:	if ute.standby_line = 0 then do;
	     group.n_prim = group.n_prim - ute.user_weight;
	     if group.n_sec > 0 then			/* If anybody needs promoting, then */
		if group.max_prim < 0 | group.max_prim >= group.n_prim then do;
		     time_now = clock ();		/* ... promote a secondary */
		     call findsb (1, 1, 0, 0, ec);	/* ... if any qualify */
		end;
	end;
	else do;
	     group.n_sec = group.n_sec - ute.user_weight;
	     if ute.foreground_secondary_ok then	/* if foreground secondary job */
		autbl.n_sec_fg = autbl.n_sec_fg - 1;	/* decremnt counter of that kind of job */
	end;
	if ute.queue > 0 then do;			/* if background absentee */
	     group.n_abs = group.n_abs - 1;		/* decrement counter */
	     autbl.abs_units = autbl.abs_units - ute.user_weight;
	     autbl.n_background_abs = autbl.n_background_abs - 1;
	end;

/* promote edit-only users here */

off1:	anstbl.n_users = anstbl.n_users - 1;
	anstbl.n_units = anstbl.n_units - ute.user_weight;
	satep = ute.uprojp;
	project.n_users = project.n_users - 1;

	if autbl.abs_maxu_auto then			/* if operator has not set abs maxu manually, then */
	     if installation_parms.max_abs (anstbl.shift) ^= -1 then /* unless dynamic abs maxu is disabled */
		call set_abs_maxu;			/* go set it as function of interactive load */

	return;


/* ****************************************************************************************************************** */


/* INTERNAL PROCEDURES, IN ALPHABETIC ORDER  */


check_max_grace: proc;

	if foreground_absentee & ute.standby_line = 0 then/* a primary foreground job has a cpu time limit */
	     ute.bump_grace = 525600;			/* but it is "protected from preemption" in real time terms */
	else do;
	     ute.bump_grace = user.bump_grace;		/* give grace time specified in PDTE */
	     if ute.bump_grace > project.grace_max then do; /* unless it exceeds the limit in the SATE */
		call sys_log_ (SL_LOG_SILENT,
		     "^a: reduced grace for ^a.^a from ^d (in PDTE) to ^d (in SATE)",
		     ME, ute.person, ute.project, ute.bump_grace, project.grace_max);
		ute.bump_grace = project.grace_max;
	     end;
	     ute.bump_grace = ute.bump_grace * 60000000;	/* convert it to microseconds */
	end;

	return;

     end check_max_grace;


/* ****************************************************************************************************************** */


existing_group: proc (a_group) returns (bit (1) aligned);

dcl  a_group char (8);
dcl  i fixed bin;

	do i = first_group to mgt.current_size;
	     mgtep = addr (mgt.entry (i));
	     if group.group_id = a_group then
		return ("1"b);			/* leaving mgtep set to it */
	end;

	call sys_log_ (SL_LOG_BEEP,
	     "^a: group ^a not found in mgt for ^a.^a",
	     ME, a_group, ute.person, ute.project);
	return ("0"b);

     end existing_group;


/* ****************************************************************************************************************** */


/* FINDSB - internal procedure to scan answer table.

   Can bump a user, promote a user, or demote a user.

   returns number of load units bumped (or promoted) in last arg

*/

findsb: proc (grpmatch, pmsc, respect_grace, action, n_preempted);

dcl  grpmatch fixed bin,				/* 1 = groups must match, 2 = projects, 0 = dnc */
     pmsc fixed bin,				/* 1 = secondary, 0 = prime, -1 = dnc */
     respect_grace fixed bin,				/* 1 = yes, 0 = no */
     action fixed bin,				/* >0 = bump, 0 = promote, -1 = demote */
     n_preempted fixed bin;

dcl  oldest_atep ptr,
     oldest_time fixed bin (71),
     i fixed bin,
     xgp ptr,
     bumpx fixed bin (35),
     why char (8) aligned,
     p ptr;

	n_preempted = 0;				/* initialize preemption counter */
bump_loop: if n_preempted >= ute.user_weight then return;
	oldest_time = time_now;			/* put highest-possible value in "oldest-time" */
	oldest_atep = null;				/* initialize pointer */

/* Got to search abs_user_tab for secondary foreground jobs, too */

	do i = 1 to anstbl.current_size;
	     p = addr (anstbl.entry (i));		/* get pointer to answer table entry */
	     call see_if_oldest;
	end;
	if autbl.n_sec_fg > 0 then			/* if secondary foreground absentees are logged in */
	     do i = 1 to autbl.current_size;
	     p = addr (autbl.entry (i));
	     if p -> ute.foreground_secondary_ok then
		call see_if_oldest;
	end;

	if oldest_atep = null then return;

	xgp = mgtep;				/* Special case if group already known. */
	if ute.group = oldest_atep -> ute.group then go to gf2;
	do i = 1 to mgt.current_size;			/* Not same group. must locate group of other guy */
	     xgp = addr (mgt.entry (i));
	     if xgp -> group.group_id = oldest_atep -> ute.group then go to gf2;
	end;
	call sys_log_ (SL_LOG_BEEP, "^a: group ^a missing at preempt", ME,
	     oldest_atep -> ute.group);
	return;

/* Found oldest guy. Do we promote or bump? */

gf2:	if action = 0 then do;			/* Promote the fellow to primary */
	     if tracing then
		call sys_log_ (SL_LOG_SILENT, "^a: promote ^a.^a.^a ^d",
		     ME, oldest_atep -> ute.person,
		     oldest_atep -> ute.project, xgp -> group.group_id,
		     xgp -> group.n_prim);
	     oldest_atep -> ute.standby_line = 0;
	     xgp -> group.n_prim = xgp -> group.n_prim + oldest_atep -> ute.user_weight;
	     xgp -> group.n_sec = xgp -> group.n_sec - oldest_atep -> ute.user_weight;
	     oldest_atep -> ute.cant_bump_until = oldest_atep -> ute.bump_grace /* give only enough grace time so */
		+ oldest_atep -> ute.login_time;	/* it expires when it would have if he had logged in as primary */
	     i = oldest_atep -> ute.whotabx;		/* Fix whotab too */
	     if i ^= 0 then do;			/* .. if he is a listed user */
		whotab.e (i).stby = 0;		/* Mark now primary */
		whotab.e (i).cant_bump_until = oldest_atep -> ute.cant_bump_until;
	     end;
	end;
	else if action = -1 then do;			/* Demote the user to secondary */
	     if ^oldest_atep -> ute.at.sb_ok then do;	/* .. oops, can't demote this guy */
		bumpx = as_error_table_$preempt_group;
		go to xbmp;
	     end;
maksb:	     oldest_atep -> ute.standby_line = 1;
	     if tracing then
		call sys_log_ (SL_LOG_SILENT, "^a: demote ^a.^a.^a ^d", ME,
		     oldest_atep -> ute.person,
		     oldest_atep -> ute.project, xgp -> group.group_id,
		     xgp -> group.n_prim);
	     xgp -> group.n_prim = xgp -> group.n_prim - oldest_atep -> ute.user_weight;
	     xgp -> group.n_sec = xgp -> group.n_sec + oldest_atep -> ute.user_weight;
	     i = oldest_atep -> ute.whotabx;
	     if i ^= 0 then whotab.e (i).stby = 1;
	end;
	else do;					/* Bump the user */
	     if action = 1 then bumpx = as_error_table_$preempt_secondary;
	     else if action = 2 then bumpx = as_error_table_$preempt_group;
	     else if action = 3 then bumpx = as_error_table_$preempt_emergency;
	     else bumpx = as_error_table_$preempt_emergency_prime;
xbmp:	     oldest_atep -> ute.preempted = 1;		/* indicate that user has been preempted */
	     call asu_$bump_code (oldest_atep, bumpx, why, j, installation_parms.warning_time);
	     call sys_log_ (SL_LOG, "^a: bumping ^a.^a for ^a.^a: ^a", ME,
		oldest_atep -> ute.person, oldest_atep -> ute.project,
		ute.person, ute.project, why);
	     if oldest_atep -> ute.standby_line = 0 then go to maksb;
	end;

	n_preempted = n_preempted + oldest_atep -> ute.user_weight;
	go to bump_loop;				/* Keep trying */


see_if_oldest: proc;

	     if p -> ute.active >= NOW_LOGGED_IN then	/* if this is a logged-in user */
		if p -> ute.preempted = 0 then do;	/* .. and hasn't been previously bumped, THEN */
		     if grpmatch = 1 then		/* if want groups to match, check */
			if ute.group ^= p -> ute.group then go to nope;
		     if grpmatch = 2 then		/* If projects must match, check. */
			if ute.project ^= p -> ute.project then go to nope;
		     if pmsc ^= -1 then		/* if care about prime/secondary */
			if pmsc ^= p -> ute.standby_line then go to nope;
		     if action = 0 then		/* Promoting? See if promotable. */
			if ^(p -> ute.at.pm_ok) then go to nope;
			else ;
		     else if p -> ute.at.nobump then go to nope;
		     if respect_grace = 1 then	/* does grace matter? */
			if (p -> ute.cant_bump_until) > time_now then go to nope;
		     if p -> ute.login_time < oldest_time then do; /* is this the oldest user? */
			if action = 0 then		/* if we are promoting, see if user has already been logged in
						   for a time >= his grace time */
			     if p -> ute.login_time + p -> ute.bump_grace <= time_now
			     then goto nope;	/* and if so, don't promote him */
			oldest_time = p -> ute.login_time;
			oldest_atep = p;
		     end;
		end;

nope:	     return;

	end see_if_oldest;

     end findsb;


/* ****************************************************************************************************************** */


permitted_proj_group: proc (a_group) returns (bit (1) aligned);

dcl  (a_group, t_group) char (8) aligned;
dcl  i fixed bin;

/* see if this group is legal for this project */
	do i = 0 to 2;
	     if i = 0 then t_group = project.group;
	     else t_group = project.groups (i);
	     if t_group = "*" then goto ok_for_pj;
	     if t_group = a_group then goto ok_for_pj;
	end;

	call sys_log_ (SL_LOG_BEEP,
	     "^a: group ^a not authorized for project ^a", ME,
	     a_group, ute.project);
	return ("0"b);

ok_for_pj:
	return ("1"b);

     end permitted_proj_group;


/* ****************************************************************************************************************** */


set_abs_maxu: proc;					/* set abs maxu from moving average of idle units */

dcl  current_idle_units fixed bin;			/* units not in use by interactives or daemons */
dcl  n_idle_units fixed bin;				/* number of samples in average */
dcl  sum_of_idle_units fixed bin;			/* for taking the average */
dcl  time_in_seconds fixed bin;			/* for keeping track of how old the samples are */
dcl  i fixed bin;					/* for do loops */

/* STATIC VARIABLES USED FOR KEEPING MOVING AVERAGE */

dcl  average_idle_units fixed bin int static;
dcl  first_idle_unit fixed bin int static init (1);	/* first valid sample in array */
dcl  last_idle_unit fixed bin int static init (0);	/* last valid sample in array */
dcl  prev_idle_units (25) fixed bin int static init ((25) 0); /* samples of idle units over specified time period */
dcl  sample_times (0:25) fixed bin (35) int static init ((26) 0); /* times the samples were taken */
						/* sample_times (0) is needed to get it started */

/* Compute current idle units. */

	current_idle_units = anstbl.max_units		/* start with total units available on the system */
	     - anstbl.n_units			/* deduct units currently in use */
	     + autbl.abs_units;			/* add back units used by absentees */

/* See if it is time to sample idle units again and recompute the average. */

	time_in_seconds = divide (anstbl.current_time, 1000000, 35, 0);

	if time_in_seconds - sample_times (last_idle_unit) >
						/* if time since we last sampled idle units is greater than */
	     divide (installation_parms.idle_time_constant_seconds, hbound (prev_idle_units, 1), 17, 0)
						/* desired sample interval */
	then do;					/* then take another sample and recompute the average */

/* Store the current sample */

	     last_idle_unit = last_idle_unit + 1;	/* use next array entry */
	     if last_idle_unit > hbound (prev_idle_units, 1) then /* wrap around if necessary */
		last_idle_unit = 1;
	     prev_idle_units (last_idle_unit) = current_idle_units; /* save the sample */
	     sample_times (last_idle_unit) = time_in_seconds; /* and the time it was taken */

/* Eliminate samples that are older than we want to include in the average. */

	     do while (sample_times (first_idle_unit) <
		time_in_seconds - installation_parms.idle_time_constant_seconds);
		prev_idle_units (first_idle_unit) = 0;	/* zero old sample */
		first_idle_unit = first_idle_unit + 1;	/* go to next sample */
		if first_idle_unit > hbound (prev_idle_units, 1) then /* wrap around if necessary */
		     first_idle_unit = 1;
	     end;

/* Add up the samples */

	     sum_of_idle_units = 0;
	     if last_idle_unit >= first_idle_unit then
		n_idle_units = last_idle_unit - first_idle_unit + 1;
	     else n_idle_units = hbound (prev_idle_units, 1) - (first_idle_unit - last_idle_unit - 1);

	     do i = 1 to hbound (prev_idle_units, 1);	/* old ones have been zeroed */
		sum_of_idle_units = sum_of_idle_units + prev_idle_units (i);
	     end;

/* Get the average */

	     average_idle_units = divide (sum_of_idle_units, n_idle_units, 17, 0);

	end;					/* end take sample and recompute average */

/* Use the smaller of the average and current value, for absentee load control */

	autbl.idle_units = min (current_idle_units, average_idle_units);

	autbl.max_abs_users = min (installation_parms.max_abs (anstbl.shift),
	     max (installation_parms.min_abs (anstbl.shift),
	     divide (installation_parms.pct_abs (anstbl.shift) * autbl.idle_units, 1000, 17, 0)));

	whotab.max_abs_users = autbl.max_abs_users;

	return;

     end set_abs_maxu;


/* ****************************************************************************************************************** */


set_absentee_group: proc;

dcl  i fixed bin;
dcl  save_mgtep ptr;

	save_mgtep = mgtep;				/* in case we can't find another group for him */
	ute.abs_group = group.group_id;		/* in either case, remember the original group */

	do i = first_group to mgt.current_size;
	     mgtep = addr (mgt.entry (i));

	     if group.absentee.default_group then
		if group.absentee.default_queue (ute.queue) then do;
		     ute.group = group.group_id;
		     return;			/* leaving mgtep pointing at the new group */
		end;

	end;					/* if we fall thru */
						/* we could not find another group to put him in */
	mgtep = save_mgtep;				/* so leave him in the one he's in now */

	return;

     end set_absentee_group;
%page;
Write_User_Message:
     procedure (P_code, P_message);

dcl  P_code fixed bin (35) parameter;
dcl  P_message char (*) parameter;

dcl  message char (512) automatic;
dcl  message_lth fixed bin automatic;
dcl  message_buffer_cur_lth fixed bin automatic;
dcl  message_buffer_max_lth fixed bin automatic;
dcl  message_buffer_ptr ptr automatic;
dcl  new_message_buffer_max_lth fixed bin automatic;
dcl  new_message_buffer_ptr ptr automatic;
dcl  system_area_ptr ptr automatic;

dcl  status_code_string char (100) aligned automatic;

dcl  message_buffer char (message_buffer_max_lth)
	based (message_buffer_ptr);
dcl  new_message_buffer char (new_message_buffer_max_lth)
	based (new_message_buffer_ptr);
dcl  system_area area based (system_area_ptr);

dcl  astty_$tty_force entry (ptr, ptr, fixed bin, fixed bin (35));
dcl  get_system_free_area_ entry () returns (ptr);

	if P_code ^= 0 then
	     call convert_status_code_ (P_code, (""), status_code_string);
	else status_code_string = "";

/**** Handle the case were the as_error_table_ entry specifies a null message.
      Only skip the message if both the code string and message string are
      null. */

	if (status_code_string = "") & (P_message = "") then
	     return;

	call ioa_$rs ("^[^a ^;^s^]^a", message, message_lth,
	     (status_code_string ^= ""), status_code_string,
	     rtrim (P_message));

	if ute.channel ^= null () then		/* user has a MCS channel */
	     call astty_$tty_force ((ute.channel), addr (message),
		message_lth, (0));
	else do;
	     message_buffer_ptr = as_data_$ls_message_buffer_ptr;
	     message_buffer_max_lth = as_data_$ls_message_buffer_max_lth;
	     message_buffer_cur_lth = as_data_$ls_message_buffer_cur_lth;

	     if message_buffer_cur_lth + message_lth > message_buffer_max_lth then do;
		new_message_buffer_max_lth = message_buffer_max_lth +
		     min (512, message_buffer_cur_lth + message_lth);
		system_area_ptr = get_system_free_area_ ();
		allocate new_message_buffer in (system_area)
		     set (new_message_buffer_ptr);
		substr (new_message_buffer, 1, message_buffer_cur_lth) =
		     substr (message_buffer, 1, message_buffer_cur_lth);
		free message_buffer;
		as_data_$ls_message_buffer_ptr,
		     message_buffer_ptr = new_message_buffer_ptr;
		as_data_$ls_message_buffer_max_lth,
		     message_buffer_max_lth = new_message_buffer_max_lth;
	     end;

	     substr (message_buffer, message_buffer_cur_lth + 1,
		message_lth) = message;
	     as_data_$ls_message_buffer_cur_lth = message_buffer_cur_lth +
		message_lth;
	end;
	return;
     end Write_User_Message;
%page;

/* format: off */
%page; %include absentee_user_table;
%page; %include answer_table;
%page; %include as_data_;
%page; %include as_data_definitions_;
%page; %include dialup_values;
%page; %include installation_parms;
%page; %include mgt;
%page; %include pdt;

dcl  pdtp ptr automatic init (null);			/* pdt needs it  */
%page; %include sat;
%page; %include sc_stat_;
%page; %include sub_err_flags;
%page; %include sys_log_constants;
%page; %include user_attributes;
%page; %include user_table_entry;
%page; %include user_table_header;
%page; %include whotab;
%page; %include work_class_info;
%page;
/* BEGIN MESSAGE DOCUMENTATION

   Message:
   load_ctl_: reduced grace for PERSON.PROJECT from MINUTES1 (in PDTE) to MINUTES2 (in SATE)

   S:	$as0

   T:	$run

   M:	The Project Definition Table (PDT) entry for PERSON.PROJECT specifies
   a larger grace time (time during which a process is protected from
   preemption) than does the System Administrator's Table (SAT) entry for the
   project.  The time given in the SAT entry is used.

   A:	$ignore


   Message:
   load_ctl_: bumping NAME1.PROJ for NAME2.PROJ: REASON

   S:	as (severity1)

   T:	$run

   M:	This message is typed out when a user is bumped.  A
   user may be bumped by another member of his load control
   group, in which case REASON is pr_grp, which
   means group preemption. If a secondary user is bumped
   by a primary user, either from the same group or from
   another group, REASON is pr_sec, meaning secondary
   user preemption. If REASON is pr_emrg, meaning
   emergency preemption, a system programmer was logging
   in and had to bump some user.  A user is usually given
   three minutes after this message to clean up
   and log out before being automatically logged out.

   A:	$ignore


   Message:
   load_ctl_: configuration not in tables.  X cpu, Y mem, W bulk, shift Z
	using configuartion XX cpu, YY mem, WW bulk, shift ZZ

   S:	as (severity2)

   T:	May occur at any time.

   M:	The automatic setting of maxunits by the load control
   facility was attempted, but the configuration tables did not have
   a configuration defined that matched the current configuration.  No
   change was made to the system parameters.  The system continues
   operation, selecting the last entry in the config tables (which should
   correspond to the largest system described by the system administrator.)
   The values assumed by automatic load control are given in the second line
   of the message.

   A:	Set maxunits and the absentee max manually.  Inform
   the system administrator so that he can update the load control
   tables.


   Message:
   load_ctl_: demote NAME.PROJ GROUP NNN

   S:	as (severity1)

   T:	$run

   M:	This is trace output.  This user has been demoted to
   secondary status.

   A:	$ignore
   To turn off this
   output, type load_ctl_$lctraceoff from admin mode.


   Message:
   load_ctl_: Entry not found. master_group_table

   S:	as (severity2)

   T:	$init

   M:	load_ctl_ cannot find the master_group_table.  The
   system will probably not be able to perform the bootload operation.

   A:	$inform


   Message:
   load_ctl_: group GRPID missing at preempt

   S:	as (severity2)

   T:	$run

   M:	The master_group_table entry for GRPID has vanished.
   The system is attempting to preempt a user from that group but
   cannot find the table entry for the group.  The system will attempt to
   continue.

   A:	$inform_sa


   Message:
   load_ctl_: group GRPID missing at logout

   S:	as (severity2)

   T:	$run

   M:	The master_group_table entry for GRPID has vanished.
   The system is attempting to logout a user from that group but
   cannot find the table entry for the group.  The system will attempt to
   continue.

   A:	$inform_sa


   Message:
   load_ctl_: Group GRPID missing for NAME.PROJ

   S:	as (severity2)

   T:	$run

   M:	The system administrator has designated that the project PROJ
   should be in the load control group GRPID but the entry in the
   master_group_table for that load control group is missing.  The
   user cannot log in.  This may be an indication that the segment
   master_group_table has been damaged.

   A:	$inform_sa


   Message:
   load_ctl_: group GRPID not found in mgt for NAME.PROJ

   S:	as (severity2)

   T:	$run

   M:	A system or project administrator has designated that the user
   NAME.PROJ should be in the load control group GRPID, but the master_group_table
   (mgt) has no entry for that group.  An attempt will be made to log the user in,
   using the default group for his project.  Subsequent messages will indicate
   the success or failure of this attempt.

   A:	$inform_sa


   Message:
   load_ctl_: group GRPID not authorized for project PROJ

   S:	as (severity2)

   T:	$run

   M:	A project administrator has designated that one of the users
   in project PROJ should be in the load control group GRPID, but the system
   administrator has not authorized that project to be in that group.  An attempt
   will be made to log the user in, using the default group for his project.
   Subsequent messages will indicate the success or failure of this attempt.

   A:	$inform_sa


   Message:
   load_ctl_: ERROR_MESSAGE  During work class redefinition

   S:	as (severity2)

   T:	While the system is running or during system startup.

   M:	Either some system table has been damaged or a system administrator
   was changing work class definitions at the time of a shift change, or when
   a "maxu auto" command was issued.  Error messages immediately preceding this one
   contain more information about the exact nature of the problem.

   A:	$contact_sa
   He may want you to type the
   "maxu auto" command to retry the operation that failed.  If that command
   produces no error messages, the problem has been eliminated.


   Message:
   load_ctl_: Unknown mgt version number:  NUMBER

   S:	as (severity2)

   T:	$init

   M:	Either the master_group_table (mgt) has been damaged,
   or its format is incompatible with the current Answering Service.
   The system cannot be brought up until a correct mgt is provided.

   A:	$contact_sa


   Message:
   load_ctl_: maxu too small (XX), YY units for group GRPID

   S:	as (severity2)

   T:	$run

   M:	The system administrator has specified that the load control
   group GRPID is to have "all the rest" of the primary load units
   after all other groups have taken their allocations from maxunits.
   However, maxunits is less than the sum of the primary allocations,
   giving the group GRPID the negative allocation of YY units.  The
   system proceeds, attempting to log the user in anyway.  Of course,
   the user is allowed secondary status only if he is allowed to log
   in at all.  This is often the result of the operator typing maxu 30
   instead of maxu 300, or some similar error.

   A:	Check the value of maxunits and, if a mistake was made,
   correct it.  If the maxunits value is correct, note this situation for
   the system administrator.


   Message:
   load_ctl_: more than one group has -1 max: GRPID

   S:	as (severity2)

   T:	$init

   M:	The system administrator has accidentally given more
   than one group a "take all the rest" maximum primary unit
   allocation.  The user control package cannot handle this situation.
   The second group with a -1 maxprim is listed.  The system completes
   startup and users can log in but maxunits may not be obeyed.

   A:	$contact_sa


   Message:
   load_ctl_: promote NAME.PROJ GROUP NNN

   S:	as (severity1)

   T:	$run

   M:	This is trace output.  This user has been promoted to
   primary status.

   A:	$ignore
   To turn off this
   output, type load_ctl_$lctraceoff from admin mode.


   Message:
   load_ctl_: Too many primes. NAME.PROJ (GROUP) MM/NN

   S:	as (severity0)

   T:	$run

   M:	This is trace output.  The system has been committed
   to allow a certain number of users from group GROUP
   to be logged in at one time.  In order to log this
   user in, some other user must be bumped, but all users
   have primary status and cannot be bumped.  This situation
   may be a consequence of system programmers with the
   overloading privilege logging in when the system is
   full.  The user is allowed to log in anyway.

   A:	$ignore

   END MESSAGE DOCUMENTATION */

     end load_ctl_;
