/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1992   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/* format: style4 */
act_ctl_: proc (p);

/* ACT_CTL_ - this procedure keeps records of usage for the system.
   The usage data for each user is stored in his PDT entry.
   Limits also in the PDT entry are checked and the user may be bumped.

   Special handling is given to the PDT entry for Initializer.SysDaemon.
   It contains the total system uptime, and the initializer process CPU usage.

   There are the following entries:

   act_ctl_$init			called when the system is brought up
   act_ctl_$open_account		called from "dialup_" when user identified
   .				.. this entrypoint makes an entrypoint in the accounting file
   act_ctl_$close_account		called from "dialup_" when user signs off.
   act_ctl_$cp			called from "dialup_" when process created (reset ate, check limit)
   act_ctl_$dp			called from "dialup_" when process destroyed (totals cputime)
   act_ctl_$check			called from "lg_ctl_" for permission to log user in
   act_ctl_$update			called every 15 minutes by event channel to update cpu time
   act_ctl_$shift_cmnd_update		called by shift command to do accounting update and switch to new shift
   act_ctl_$act_ctl_close		called when system shuts down

   There are also entrypoints to call from the console for testing.

   act_ctl_$act_ctl_disable		turns off charging
   act_ctl_$act_ctl_reable		turns it on again

*/

/* Originally coded by E. Stone, 9/25/69 */
/* Modified by J. Grochow, 10/10 to fix bugs */
/* Modified by J. Grochow to accept daemon calls, 1/21/70 */
/* Modified by J. Grochow to automatic update, 3/1/70 */
/* Converted to pl1 and modified by J. Grochow, 4/12/70 */
/* Modified some more by J. Grochow, 7/8/70 */
/* new user control 8/10/70 JMG */
/* Inactive check 9/2/70 JMG, whotab THVV */
/* daemon accounting 11/70 JMG */
/* metering 3/71 THVV */
/* modified for absentee 6/71 EDS */
/* new accounting 2/72 THVV */
/* 6180 version, as_error_table_, rework absentee, fix bugs, virtual cpu + frankstons 1/73 THVV */
/* Modified 741226 by PG for audit msgs */
/* Modified May 1976 by T. Casey to implement shift command and per-user cutoff warning thresholds */
/* Modified 760819 by Roy Planalp to respect -brief flag, to pass text of
   error msg to lg_ctl_, and to give user some grace when bumping for inactivity */
/* Modified 770623 by Robert Coren to not use obsolete terminal type fields in ATE */
/* Modified August 1977 by T. Casey to call device_acct_$broom when destroying
   a process, and to not leave event calls masked if unable to lock pdte. */
/* Modified May 1978 by T. Casey to pass old shift to load_ctl_$set_max_units */
/* Modified November 1978 by T. Casey for new absentee control parameters */
/* Modified April 1979 by T. Casey for MR7.0a to fix bugs in foreground absentee implementation. */
/* Modified August 1979 by T. Casey for MR8.0 for session cost and process preservation across hangups. */
/* shift change looping bug fixed December 1979, Ch Hornig */
/* Modified Feb 1980 by M. B. Armstrong to implement multiple rate structures (UNCA). */
/* Modified March 1980 by T. Casey to add metering. */
/* Modified June 1981 by E. N. Kittlitz for UNCA rate structures */
/* Modified June 1981 by T. Casey for MR9.0 for new wakeup priorities. */
/* Modified November 1981, E. N. Kittlitz.  user_table_entry conversion. */
/* Modified December 1981, E. N. Kittlitz.  user_warn controls */
/* Modified May 1982, E. N. Kittlitz. New AS initialization. */
/* Modified September 1982, E. N. Kittlitz. publish more stuff in answer_table */
/* Modified 1984-07-12 BIM for login authorization ranges. */
/* Modified 1985-01-11 by E. Swenson for new A.S. auditing */
/* Modified 1985-01-21, BIM: proper any_other handler. */
/* Modified 1985-03-28, E. Swenson to handle damaged PDTs at as
   initialization.
*/

/****^  HISTORY COMMENTS:
  1) change(86-04-04,Herbst), approve(87-07-13,MCR7697),
     audit(87-07-27,GDixon), install(87-08-03,MR12.1-1055):
     Changed write_message proc to call asu_$blast_user.
  2) change(86-05-13,GJohnson), approve(86-05-13,MCR7387),
     audit(86-05-13,Martinson), install(86-05-14,MR12.0-1055):
     Correct error message documentation.
  3) change(86-05-20,Gilcrease), approve(86-05-22,MCR7369),
     audit(86-06-23,LJAdams), install(86-06-30,MR12.0-1081):
               Allow "weekly" cutoffs. SCP6250.
  4) change(86-08-03,Swenson), approve(86-08-13,MCR7512),
     audit(86-08-13,EJSharpe), install(86-09-08,MR12.0-1150):
     Moved code for printing "Your authorization is..." to dialup_ so that this
     message can be displayed upon process reconnection. (Actual change date
     was 85-08-03)
  5) change(87-02-24,Brunelle), approve(87-07-13,MCR7697),
     audit(87-07-27,GDixon), install(87-08-03,MR12.1-1055):
     Changed activity_unbump entrypoint to use installation_parms.warning_time
     instead of installation_parms.update_time when making check for inactivity
     since bump was scheduled.
  6) change(87-04-06,Brunelle), approve(87-07-13,MCR7697),
     audit(87-07-27,GDixon), install(87-08-03,MR12.1-1055):
     Added statements to set anstbl.current_time = clock () to the following
     entrypoints: check, cp and activity_unbump.
  7) change(87-04-09,Brunelle), approve(87-07-13,MCR7694),
     audit(87-07-27,GDixon), install(87-08-03,MR12.1-1055):
     Set the value of system_area_ptr prior to passing it to
     network_accounting_.
  8) change(87-04-27,GDixon), approve(87-07-13,MCR7741),
     audit(87-07-22,Brunelle), install(87-08-03,MR12.1-1055):
     Upgraded for change to answer_table.incl.pl1 and user_table_entry.incl.pl1
  9) change(87-05-06,GDixon), approve(87-07-13,MCR7741),
     audit(87-07-22,Brunelle), install(87-08-03,MR12.1-1055):
     When mode = "test", call network_accounting_gate_$test.
 10) change(87-05-11,GDixon), approve(87-07-13,MCR7741),
     audit(87-07-22,Brunelle), install(87-08-03,MR12.1-1055):
      A) Replace use of literals with named constants when referencing
         ute.active.
      B) Replace use of literals with named constants when referencing
         ute.process_type.
 11) change(87-05-14,Brunelle), approve(87-07-13,MCR7697),
     audit(87-07-27,GDixon), install(87-08-03,MR12.1-1055):
      A) Add inactivity stabilization time of 200 milliseconds to inactivity
         unbump check.
 12) change(87-05-14,Brunelle), approve(87-07-13,MCR7694),
     audit(87-07-27,GDixon), install(87-08-03,MR12.1-1055):
      A) Add code to display any NAT records not used in accounting update.
 13) change(87-06-11,Brunelle), approve(87-07-13,MCR7694),
     audit(87-07-27,GDixon), install(87-08-03,MR12.1-1055):
      A) Added code to check any unused net accting records after to call to
         $get_process_total.
 14) change(87-06-28,GDixon), approve(87-07-13,MCR7694),
     audit(87-07-22,Brunelle), install(87-08-03,MR12.1-1055):
      A) Correct error messages printed after calls to
         network_accounting_gate_.
      B) Avoid signalling sub_error_ if network accounting initialization
         fails.
 15) change(87-07-22,Brunelle), approve(87-07-22,MCR7694),
     audit(87-07-27,GDixon), install(87-08-03,MR12.1-1055):
      A) Remove call to initialize network accounting.  It will go in
         ls_server_request.
      B) Conditionalize network accounting calls and update of data based on
         anstbl.login_server_present.
 16) change(87-07-22,Brunelle), approve(87-07-22,MCR7741),
     audit(87-07-27,GDixon), install(87-08-03,MR12.1-1055):
      A) Correct error message documentation.
      B) Remove entrypoints which are no longer called ($login_message &
         $act_ctl_noupdate)
 17) change(87-07-22,Brunelle), approve(87-07-22,MCR7697),
     audit(87-07-27,GDixon), install(87-08-03,MR12.1-1055):
     Add code to cause an inactive disconnected process to be bumped
     immediately instead of going through the normal warning sequence.
 18) change(87-07-28,Brunelle), approve(87-07-28,MCR7694),
     audit(87-07-28,GDixon), install(87-08-03,MR12.1-1055):
     Change so debug_na entrypoint calls network_accounting_gate_$debug to turn
     on inner ring debugging.
 19) change(87-07-31,Brunelle), approve(87-07-31,MCR7694),
     audit(87-08-01,GDixon), install(87-08-03,MR12.1-1055):
     Check version from network accounting.
 20) change(87-08-06,GDixon), approve(87-08-06,MCR7694),
     audit(87-08-06,Brunelle), install(87-08-06,MR12.1-1064):
     Set network_account_array_ptr to null before testing to see if the login
     server is present.  Otherwise, the ptr never gets set but is tested in a
     variety of places.
 21) change(87-08-12,Brunelle), approve(87-08-12,MCR7694),
     audit(87-08-12,GDixon), install(87-08-13,MR12.1-1085):
     Correct call to as_meter_$exit with NETUP_METER when no equivalent call
     to as_meter_$enter has occurred.
 22) change(92-08-28,Schroth), approve(92-10-14,MCR8263), audit(92-10-15,Vu),
     install(92-10-21,MR12.5-1038):
     Correctly update whotab.next_shift_change_time when a manually set shift
     crosses a defined shift boundary into the same shift as that set by the
     operator shift command.  phx21344.
                                                   END HISTORY COMMENTS */

/* parameters */

dcl  p ptr parameter;


/* constants */

dcl  INACTIVITY_STABILIZATION_TIME fixed bin (71) int static options (constant) init (200000);
dcl  MICROSECONDS_PER_HOUR fixed bin (35) int static options (constant) init (3600000000);
dcl  MICROSECONDS_PER_MINUTE float bin (63) int static options (constant) init (6.0e7);
dcl  MICROSECONDS_PER_WEEK fixed bin (71) int static options (constant) init (604800000000);
dcl  MILLION fixed bin (35) int static options (constant) init (1000000);
dcl  NEVER fixed bin (71) init (9435484800000000) internal static options (constant);
						/* This date is 12/31/2199 0000. GMT */

/* .. if Multics last this long we will have to fix */
dcl  NL char (1) int static options (constant) init ("
");
dcl  OPEN float bin init (1e37) internal static options (constant);
dcl  QNAME (0:4) char (4) int static options (constant) init (
	"Q FG",
	"Q 1",
	"Q 2",
	"Q 3",
	"Q 4");
dcl  TOLERANCE float bin (63) int static options (constant) init (0.05);
						/* Amount of discrepancy which will be ignored; 3 minutes/hour */


/* Internal Static */

dcl  alarmfail fixed bin int static init (0);		/* set when alarm clock failure detected */
dcl  initializer_pdtep ptr int static init (null);	/* ptr to initializer PDT entry */
dcl  last_update_interval fixed bin (71) internal static;	/* interval used to set timer */
dcl  mode char (4) aligned int static init ("norm");
dcl  next_update fixed bin (71) int static;		/* time for next update */
dcl  static_label label int static;			/* Label used if fault in update. */
dcl  static_nlogins fixed bin int static;		/* Total sessions since startup. */
dcl  static_total_dollar_charge float bin int static;	/* Total billed since startup. */
dcl  static_total_time_charged fixed bin (71) int static;	/* Total CPU time charged. */
dcl  system_area_ptr ptr int static init (null);
dcl  updatetime fixed bin (71) int static;		/* time update last performed */


/* Entries */

dcl  act_ctl_$update entry;
dcl  adjust_cutoff_ entry (ptr, fixed bin (71));
dcl  as_any_other_handler_ entry (character (*), entry, label, label);
dcl  as_meter_ entry (fixed bin (71), fixed bin (71), fixed bin (71), float bin, fixed bin, float bin, float bin, float bin);
dcl  as_meter_$as_meter_init entry (fixed bin (71), fixed bin, fixed bin (71), fixed bin (71));
dcl  as_meter_$as_meter_stop entry;
dcl  as_meter_$enter entry (fixed bin);
dcl  as_meter_$exit entry (fixed bin);
dcl  as_meter_$exit_values entry (fixed bin, fixed bin (34), fixed bin (71), fixed bin (71));
dcl  asu_$blast_user entry (ptr, char (*), char (*), fixed bin (35));
dcl  asu_$bump_code entry (ptr, fixed bin (35), char (8) aligned, fixed bin (35), fixed bin);
dcl  asu_$bump_user entry (ptr, char (*), fixed bin (35), fixed bin);
dcl  convert_status_code_ entry (fixed bin (35), char (8) aligned, char (100) aligned);
dcl  cu_$arg_count entry (fixed bin);
dcl  date_time_ entry (fixed bin (71), char (*));
dcl  datebin_ entry (fixed bin (71), fixed bin, fixed bin, fixed bin,
	fixed bin, fixed bin, fixed bin, fixed bin, fixed bin, fixed bin);
dcl  datebin_$next_shift_change entry (fixed bin (71), fixed bin (71), fixed bin, fixed bin);
dcl  datebin_$revert entry (fixed bin, fixed bin, fixed bin, fixed bin, fixed bin, fixed bin, fixed bin (71));
dcl  device_acct_$broom entry (ptr);
dcl  device_acct_$update entry (ptr);
dcl  get_system_free_area_ entry () returns (ptr);
dcl  hcs_$wakeup entry (bit (*) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
dcl  hphcs_$process_status entry (ptr);
dcl  initiate_file_ entry (char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));
dcl  ioa_$rs entry options (variable);
dcl  ioa_$rsnnl entry options (variable);
dcl  ipc_$create_ev_chn entry (fixed bin (71), fixed bin (35));
dcl  ipc_$decl_ev_call_chn entry (fixed bin (71), entry, ptr, fixed bin, fixed bin (35));
dcl  ipc_$mask_ev_calls entry (fixed bin (35));
dcl  ipc_$unmask_ev_calls entry (fixed bin (35));
dcl  load_ctl_$load_level entry (fixed bin, float bin);
dcl  load_ctl_$set_maxunits entry (fixed bin);
dcl  network_accounting_gate_$debug entry (bit (1));
dcl  network_accounting_gate_$get_process_total entry (bit (36) aligned, ptr, ptr, char (*), fixed bin (35));
dcl  network_accounting_gate_$read_and_reset_table entry (ptr, ptr, char (*), fixed bin (35));
dcl  pathname_ entry (char (*), char (*)) returns (char (168));
dcl  set_lock_$lock entry (bit (36) aligned, fixed bin, fixed bin (35));
dcl  set_lock_$unlock entry (bit (36) aligned, fixed bin (35));
dcl  sub_err_ entry () options (variable);
dcl  sys_log_ entry options (variable);
dcl  sys_log_$error_log entry options (variable);
dcl  terminate_file_ entry (ptr, fixed bin (24), bit (*), fixed bin (35));
dcl  timer_manager_$alarm_wakeup entry (fixed bin (71), bit (2), fixed bin (71));


/* External Static */

dcl  (as_error_table_$cut_proj_date,
     as_error_table_$cut_proj_funds,
     as_error_table_$cut_proj_other,
     as_error_table_$cut_user_cut_msg,
     as_error_table_$cut_user_date_msg,
     as_error_table_$cut_user_mlim_msg,
     as_error_table_$cut_user_shift_msg,
     as_error_table_$inactive,
     as_error_table_$proj_low_funds,
     as_error_table_$user_warn_days,
     as_error_table_$user_warn_funds,
     as_error_table_$user_warn_pct,
     as_error_table_$warn_proj_date) fixed bin (35) ext;

dcl  (error_table_$lock_wait_time_exceeded,
     error_table_$out_of_sequence) fixed bin (35) ext static;


/* Automatic */

dcl  absda fixed bin;				/* variable used with datebin_ */
dcl  asmtep ptr;
dcl  code fixed bin (35);				/* error codes */
dcl  coredelta fixed bin (71);			/* Memory usage since last update. */
dcl  cost float bin;				/* Dollar charge since last update. */
dcl  cpudelta fixed bin (71);				/* CPU since last update. */
dcl  crash_clock fixed bin (71);			/* used during init */
dcl  cur_rs_ptr ptr;
dcl  dd fixed bin;					/* variable used with datebin_ */
dcl  did_charge float bin (63);			/* for computing accounting errors */
dcl  discrepancy float bin (63);			/* for computing accounting errors */
dcl  ec fixed bin (35);				/* err code */
dcl  error_message char (500);			/* returned by subroutines */
dcl  format char (100) aligned;
dcl  hh fixed bin;					/* variable used with datebin_ */
dcl  hrs fixed bin;					/* format variable for logout message */
dcl  i fixed bin;					/* temp */
dcl  icode char (4);				/* ... id code */
dcl  interactive_signal char (8);
dcl  io_ops_delta fixed bin (71);			/* IO ops on terminal since last update. */
dcl  j fixed bin;					/* temp */
dcl  jobid char (32);				/* ... */
dcl  line char (168);				/* Format variable. */
dcl  logdelta fixed bin (71);				/* Connect since last update. */
dcl  mcode fixed bin (35);				/* message code */
dcl  mel float bin;
dcl  mhh float bin;
dcl  mins fixed bin (17);
dcl  minute fixed bin;				/* variable used with datebin_ */
dcl  mlth fixed bin;				/* Length of message. */
dcl  mm fixed bin;					/* variable used with datebin_ */
dcl  mqu float bin;
dcl  mrs float bin;					/* estimated response */
dcl  mtc fixed bin (71);				/* metering variable */
dcl  mti fixed bin (71);				/* metering variable */
dcl  mui fixed bin (71);				/* metering variable */
dcl  mws fixed bin;					/* ... page meter */
dcl  ncrash fixed bin;				/* used in determining how many left on */
dcl  nolog bit (1) aligned;				/* Used by check. TRUE if no login. */
dcl  pagefaults fixed bin (34);
dcl  pdtep ptr;					/* ptr to user pdt entry, for new accounting */
dcl  pdtn char (32);				/* name of pdt  */
dcl  pdtp ptr;					/* ptr to user pdt */
dcl  real_time fixed bin (71);
dcl  satep ptr;					/* ptr to sat entry for user project */
dcl  sd_ptr ptr;					/* ptr to SysDaemon sate */
dcl  secs fixed bin (17);
dcl  shf fixed bin;					/* variable used with datebin_ */
dcl  short char (8) aligned;				/* junk */
dcl  should_charge float bin (63);			/* for computing accounting errors */
dcl  some_time_ago fixed bin (71);			/* If has been blocked since before here, bump */
dcl  sss fixed bin;					/* variable used with datebin_ */
dcl  total_dsa_charges float bin;
dcl  ttykind char (32);				/* ... */
dcl  vcpu_time fixed bin (71);
dcl  wkd fixed bin;					/* variable used with datebin_ */
dcl  yy fixed bin;					/* variable used with datebin_ */


/* Automatic Structures */

dcl  1 abs_signal aligned,				/* Wakeup message sent when bumping absentee user */
       2 type char (4),				/* "alar" = cpu over, "inac" = inactive */
       2 index fixed bin (35);			/* index in abs_user_tab */

dcl  1 process_status_return aligned,			/* structure returned by hphcs_$process_status */
       2 target_proc bit (36),			/* Input process id. */
       2 total_page_faults fixed bin (35),		/* Total page faults in process. */
       2 aptptr ptr,				/* ptr to user APTE */
       2 up_exec fixed bin,				/* execution state. 1=run, 4=block */
       2 up_mp fixed bin,				/* multiprogramming state. */
       2 up_block fixed bin (71),			/* time of last block */
       2 up_cpu fixed bin (71),			/* CPU usage in microseconds */
       2 up_page fixed bin (71),			/* memory usage in Frankstons */
       2 virtual_cpu fixed bin (71),			/* Process virtual CPU time */
       2 extra2 fixed bin (71);


/* Based */

dcl  system_area area based (system_area_ptr);
dcl  zap_abs fixed bin (71) based (addr (abs_signal));	/* for wakeup call */
dcl  zap_user fixed bin (71) based (addr (interactive_signal)); /* for wakeup call */

/* Builtins */

dcl  (abs, addr, baseno, baseptr, before, binary, ceil, clock, divide,
     fixed, float, index, length, max, min, mod, null, reverse, rtrim, substr,
     verify) builtin;

/* Conditions */

dcl  any_other condition;
dcl  seg_fault_error condition;

%page;

/* Program */

init: entry ();

/* Entry called by as_init_ when system is being brought up */

	if mode = "dumm" then return;			/* Was accounting disabled before startup? */
	if ^sc_stat_$Multics_typed | sc_stat_$Go_typed then do;
	     code = error_table_$out_of_sequence;
	     go to init_sub_error;
	end;
	if substr (sysdir, 1, 8) ^= ">system_" then mode = "test";

/* now set event call channel to signal updating of accounting info */

init1:	ansp = as_data_$ansp;
	call ipc_$create_ev_chn (anstbl.acct_update_chn, code); /* Set up event-call channel for acct update. */
	call ipc_$decl_ev_call_chn (anstbl.acct_update_chn, act_ctl_$update, null, ACCT_UPDATE_PRIO, code);
	if code ^= 0 then do;
	     call sys_log_$error_log (SL_LOG_BEEP, code, "act_ctl_$init", "creating update channel");
	     go to init_sub_error;
	end;
	anstbl.acct_alarm_fail = 0;
	alarmfail = 0;				/* Turn off switch says clock is late. */

/* Find out what time and what shift it is */

	crash_clock = anstbl.current_time;		/* Get best guess at time of crash or down. */
	anstbl.current_time = clock ();		/* Read clock. */

/* Before we trust the shift information left in the header of whotab from the last session,
   we must check it for reasonableness, since datebin_ uses it to tell us what shift it is. */

	if whotab.next_shift_change_time >
	     anstbl.current_time + MICROSECONDS_PER_WEEK |/* shift end can never be > 1 week in future */
	     whotab.last_shift_change_time >=
	     anstbl.current_time |			/* start of current shift must be in the past */
	     whotab.next_shift_change_time >		/* shift length must be <= 1 week */
	     whotab.last_shift_change_time + MICROSECONDS_PER_WEEK |
	     whotab.shift < 0 | whotab.shift > 7 then	/* shift number can only be 0 to 7 */
	     whotab.next_shift_change_time = 0;		/* force datebin_ to look in shift table */

/* because datebin_$next_shift_change uses the value of whotab.next_shift_change_time,
   and further, initializes its output arguments before processing, we can't
   just pass in whotab.next_shift_change_time as an argument. */

	begin;
dcl  next_shift_change_time fixed bin (71);
dcl  current_shift fixed bin;
dcl  next_shift fixed bin;

	     call datebin_$next_shift_change (anstbl.current_time, next_shift_change_time, current_shift, next_shift);
	     whotab.next_shift_change_time = next_shift_change_time;
	     whotab.shift = current_shift;
	end;

	call datebin_ (anstbl.current_time, absda, mm, dd, yy, hh, minute, sss, wkd, shf);

	if anstbl.shift ^= shf then do;		/* if shift changed since last session */
	     anstbl.shift = shf;			/* save current shift */
	     whotab.last_shift_change_time = anstbl.current_time; /* remember when it changed */
	end;

	call datebin_$revert (mm, dd, yy, hh, 0, 0, next_update);

	if installation_parms.acct_update <= 0 then do;
	     call sys_log_ (SL_LOG_BEEP,
		"act_ctl_$init: illegal value (^d) for accounting update interval in installation_parms.",
		installation_parms.acct_update);
	     call sub_err_ (0, "act_ctl_", "s");
	end;

	do while (next_update < anstbl.current_time);	/* compute next update time */
	     next_update = next_update + installation_parms.acct_update * MILLION;
	end;
	call timer_manager_$alarm_wakeup (next_update, "00"b, anstbl.acct_update_chn);
	last_update_interval = installation_parms.acct_update; /* Save for clock check (in case inst_parms changes) */
	updatetime = anstbl.current_time;		/* Set time of last update. */

	static_total_time_charged = 0;		/* Clear per-bootload counters. */
	static_total_dollar_charge = 0e0;		/* ... */
	static_nlogins = 0;				/* ... */
	ncrash = 0;				/* Find out how many users were on when crashed. */
	call as_meter_$enter (FIXPDT_METER);
	do i = 1 to sat.current_size;			/* Yes. Scan sat for projects with users on */
	     satep = addr (sat.project (i));		/* Get ptr to project entry. */
	     if project.project_id = "SysDaemon" then do; /* Need to remember "SysDaemon" pdt location. */
		sd_ptr = satep;			/* .. for filling in DUT entry for initializer */
		go to get_pdt;			/* .. now search for initializer entry in pdt */
	     end;
	     if project.n_users ^= 0 then do;		/* Live project? */
get_pdt:		pdtn = project.project_id;		/* Yes. Make name of its PDT. */
		j = index (pdtn, " ");		/* ... */
		substr (pdtn, j, 4) = ".pdt";		/* ... */
		call initiate_file_ (pdtdir, pdtn, RW_ACCESS, pdtp, (0), code);
		if code ^= 0 then do;
		     call sys_log_$error_log (SL_LOG_BEEP, code,
			"act_ctl_$init", "Cannot unlock PDT ^a",
			pathname_ (pdtdir, pdtn));
		     go to new3;			/* Hopeless. */
		end;

/**** The following code ensures makes sure the PDT is not damaged.  If
      it is, we just log (and print) an error and skip to the next PDT. */
		on seg_fault_error
		     begin;
		     call sys_log_$error_log (SL_LOG_BEEP, 0,
			"act_ctl_$init", "The PDT is damaged.  Cannot unlock ^a.", pathname_ (pdtdir, pdtn));
		     goto new3;
		end;
		j = pdt.current_size;		/* provoke seg_fault_error */
		revert seg_fault_error;

		do j = 1 to pdt.current_size;		/* Scan thru PDT looking for losers. */
		     pdtep = addr (pdt.user (j));	/* Get ptr to user. */
		     if user.person_id = "Initializer" then
			if project.project_id = "SysDaemon" then
			     initializer_pdtep = pdtep; /* Remember where initializer entry is. */
		     if user.last_update > crash_clock then crash_clock = user.last_update;
		     ncrash = ncrash + user.now_in;	/* Count processes which died. */
		     user.crashes = user.crashes + user.now_in;
		     user.now_in = 0;		/* Now he's out. */
		     user.n_foreground = 0;
		     user.n_background = 0;
		     user.n_interactive = 0;
		     user.n_disconnected = 0;
		     user.lock = "0"b;		/* And entry is not locked. */
		end;
/**** Keep our KST tidy by terminating PDTs unless we really need them. */
		if project.project_id ^= "SysDaemon" then
		     call terminate_file_ (pdtp, 0, TERM_FILE_TERM, code);
	     end;
new3:	     project.n_users = 0;			/* Clear project activity count. */
	end;
	call as_meter_$exit (FIXPDT_METER);
	if initializer_pdtep = null then do;		/* If cannot find initializer entry, truble */
	     call sys_log_ (SL_LOG_BEEP, "act_ctl_$init: cannot locate Initializer.SysDaemon pdt entry");
	     go to init_sub_error;
	end;
	else do;					/* Worked ok. Fill in some useful stuff. */
	     dutp = as_data_$dutp;
	     utep = addr (dutbl.entry (1));		/* Initializer is always # 1 in DUT */
	     ute.pdtep = initializer_pdtep;
	     ute.uprojp = sd_ptr;
	     initializer_pdtep -> user.logins = initializer_pdtep -> user.logins + 1;
	end;
	call as_meter_$as_meter_init (crash_clock, ncrash, next_update, last_update_interval);
	if ncrash > 0 then initializer_pdtep -> user.crashes = initializer_pdtep -> user.crashes + 1;

	if system_area_ptr = null
	then system_area_ptr = get_system_free_area_ ();

	return;

init_sub_error:
	call sub_err_ (code, "act_ctl_$init", "s");
%page;
check: entry (p, sp, wordx, e_text, codex);

/* Called by lg_ctl_.
   Entrypoint is passed a pointer to the user and to the user's SAT entry.
   It determines whether the user is cut off and if so, types out a message.
   If the user is not permitted to log in, it returns an error code. */

dcl  wordx char (8) aligned;				/* reason. */
dcl  e_text char (168) varying;			/* long reason */
dcl  codex fixed bin (35);				/* Nonzero if no login. */
dcl  sp ptr;					/* Ptr to user SAT entry for his proj. */
dcl  dont_check bit (36) aligned;

	utep = p;
	satep = sp;
	goto CHECK_COMMON;

check_for_process_creation:
     entry (P_utep, wordx, e_text, codex);

dcl  P_utep ptr parameter;				/* pointer to user's UTE */

	utep = P_utep;

	satep = ute.uprojp;
	goto CHECK_COMMON;

CHECK_COMMON:
	if mode = "dumm" then return;			/* If accounting is off, forget it. */
	ansp = as_data_$ansp;
	anstbl.current_time = clock ();		/* Read clock. */
	codex = 0;
	dont_check = ""b;				/* bits set when we squawk about something */
	mcode = 0;
	if project.cutoff ^= " " then do;		/* See if project is cut off */
	     nolog = "0"b;				/* probably non-fatal. */
	     if project.cutoff = "X" then do;		/* X = no login, out of funds */
		nolog = "1"b;
		mcode = as_error_table_$cut_proj_funds;
	     end;
	     else if project.cutoff = "W" then ;	/* "almost out of funds" is handled below */
	     else if project.cutoff = "Y" then do;
		mcode = as_error_table_$cut_proj_funds;
		dont_check = "1"b;			/* already talked about money */
	     end;
	     else if project.cutoff = "T" then do;	/* T = no login, out of date */
		nolog = "1"b;
		mcode = as_error_table_$cut_proj_date;
	     end;
	     else if project.cutoff = "R" then ;	/* "near cutoff date" is handled below */
	     else if project.cutoff = "S" then do;
		mcode = as_error_table_$cut_proj_date;
		dont_check = dont_check | "01"b;	/* indicate complained about date */
	     end;
	     else mcode = as_error_table_$cut_proj_other;
	     if nolog then do;			/* Login permitted? */
		codex = mcode;			/* no */
		call convert_status_code_ (mcode, wordx, format);
		if format ^= ""			/* If installation has this msg */
		then e_text = substr (format, 1, length (format) + 1 - verify (reverse (format), " ")) || NL;
		else e_text = "";
		return;
	     end;
	     else if (mcode ^= 0 & ^ute.at.brief)
	     then call Write_User_Message (mcode, (wordx));
	end;

	pdtep = ute.pdtep;				/* locate pdt entry */

	call adjust_cutoff_ (pdtep, anstbl.current_time); /* for cutoff_warning and checklim */

	if ^ute.at.brief				/* if user didn't say -bf */
	then call cutoff_warning (dont_check);		/* maybe print "almost out of funds" or "near cutoff date" */
	call checklim (ute.queue, mcode);		/* Limit stop check. */
						/* If no go, puts reason in mcode, short, line */
	if mcode ^= 0 then do;			/* wups */
	     codex = mcode;				/* Tell lg_ctl_ */
	     wordx = short;
						/* mlth set by checklim... */
	     e_text = substr (line, 1, mlth);		/* tell user why he was refused */
	     return;
	end;
	return;
%page;
/* Entry called when user is logging in */
/* called by dialup_, absentee_user_manager_, daemon_user_manager_ & ftp_dialup_ */

open_account: entry (p);

	if mode = "dumm" then return;			/* accounting disabled */
	utep = p;					/* Copy ptr to answer table entry. */
	if ute.active < NOW_LOGGED_IN then return;	/* not logged in */
	ansp = as_data_$ansp;
	anstbl.current_time = clock ();		/* Read clock. */

	if ute.process_type = PT_ABSENTEE then do;
	     ttykind = "Absentee";			/* ... */
	     i = 169 - index (reverse (ute.input_seg), ">");
	     jobid = "(" || before (substr (ute.input_seg, i + 1), ".absin") || ")";
	     icode = QNAME (ute.queue);
	end;
	else if ute.process_type = PT_DAEMON then do;
	     ttykind = "Daemon";			/* ... */
	     jobid = "";				/* ... */
	     icode = ute.tty_id_code;			/* ... */
	end;
	else do;					/* interactive */
	     ttykind = ute.terminal_type;
	     jobid = "";				/* ... */
	     icode = ute.tty_id_code;			/* ... */
	end;
	static_nlogins = static_nlogins + 1;		/* Count one login. */
	if asmtp ^= null then
	     asmt.logins (ute.process_type) = asmt.logins (ute.process_type) + 1; /* also count them by process type */

	pdtep = ute.pdtep;				/* extract user pdt ptr */
	user.now_in = user.now_in + 1;		/* no need to lock entry, just doing aos */
	if ute.queue <= 0 then do;			/* accounting treats all foreground processes as interactive */
	     user.logins = user.logins + 1;
	     user.n_foreground = user.n_foreground + 1;
	     if ute.process_type = PT_INTERACTIVE then	/* but we must maintain an accurate count */
		user.n_interactive = user.n_interactive + 1; /* of real interactive processes */
	end;
	else do;
	     user.absentee (ute.queue).jobs = user.absentee (ute.queue).jobs + 1;
	     user.n_background = user.n_background + 1;
	end;
	user.last_update = anstbl.current_time;		/* Start last update for user. */

check_update:
						/* compute timer lag (if any) */
	discrepancy = anstbl.current_time - updatetime - (last_update_interval * MILLION);
	if discrepancy > 60e6 then do;		/* if clock is more than 1 minute late */
	     call sys_log_ (SL_LOG,
		"act_ctl_: alarm clock late or failing by ^.2f mins",
		discrepancy / MICROSECONDS_PER_MINUTE);
	     anstbl.acct_alarm_fail = 1;		/* publish that it failed this bootload */
	     alarmfail = 1;				/* set flag */
	     call act_ctl_$update;			/* call update manually */
	     alarmfail = 0;				/* reset switch */
	end;

	return;
%page;
/* Entry called on process creation */
/* called by dialup_, absentee_user_manager_, daemon_user_manager_ & ftp_dialup_ */

cp:  entry (p);

	ansp = as_data_$ansp;
	anstbl.current_time = clock ();		/* Read clock. */
	utep = p;					/* Copy answer table entry ptr. */
	ute.cpu_this_process = 0;			/* no usage so far, of course */
	ute.mem_this_process = 0;			/* ... */
	ute.last_update_time = clock ();		/* ... */

	if ute.queue = 0 & ^ute.adjust_abs_q_no then do;	/* Check limits at new_proc for interactive. */
	     if ute.n_processes > 1 then do;
		pdtep = ute.pdtep;			/* Obtain ptr to user PDT entry. */
		call adjust_cutoff_ (pdtep, anstbl.current_time);
		call checklim (0, mcode);		/* Check limits */
		if mcode ^= 0 then do;		/* splat */
		     call asu_$bump_user (utep, substr (line, 1, mlth), code,
			installation_parms.warning_time);
		     call sys_log_ (SL_LOG, "act_ctl_: bumping ^a.^a ^a", ute.person, ute.project,
			substr (line, 1, mlth));
		end;
	     end;
	end;
	return;
%page;
shift_cmnd_update: entry;

/* entry point to do an accounting update when shift is changed by shift command */
/* called by admin_ */

dcl  shift_cmnd bit (1) aligned;
	shift_cmnd = "1"b;
	goto update_common;

/* update entry point to find all processes and log their data */
/* called automatically by timer_manager call based on installation_parms.update_time */

update: entry;
	shift_cmnd = ""b;
update_common:

	if mode = "dumm" then return;			/* accounting disabled */

dcl  up_word char (12) aligned;			/* for update message */

	ansp = as_data_$ansp;
	anstbl.acct_last_update_time, anstbl.current_time = clock (); /* Read clock. */
	some_time_ago = anstbl.current_time - installation_parms.inactive_time * MILLION;
	call ipc_$mask_ev_calls (ec);			/* in case wait on lock */
	static_label = updret1;			/* Set up exit if fault during update. */
	on any_other
	     call as_any_other_handler_ ("act_ctl_", NULL_PROC, static_label, static_label);
	call as_meter_$enter (ACCTUP_METER);

	if alarmfail ^= 0 then up_word = "Manual";	/* Make message for operator. */
	else up_word = "Automatic";			/* ... */
	if shift_cmnd then up_word = "Shift cmnd";	/* ... */

rescan:	call datebin_ (anstbl.current_time, absda, mm, dd, yy, hh, minute, sss, wkd, shf);

/* get accounting data for all current DSA network connections */
	network_account_array_ptr = null ();
	if anstbl.login_server_present then do;
	     call as_meter_$enter (NETUP_METER);
	     call network_accounting_gate_$read_and_reset_table
		(system_area_ptr, network_account_array_ptr, error_message,
		code);
	     if code ^= 0 then
		call sys_log_$error_log (SL_LOG_BEEP, code,
		     "act_ctl_$update", "Error from " || error_message);
	     else do;
		if network_account_array_ptr ^= null then do;
		     if network_account_array.version ^= NET_ACCT_ARRAY_VERSION_1 then do;
			call sys_log_ (SL_LOG_BEEP,
			     "act_ctl_$update: Net accounting array version (^a) not supported.  Expected version (^a)",
			     network_account_array.version, NET_ACCT_ARRAY_VERSION_1);
			free network_account_array in (system_area);
			network_account_array_ptr = null;
		     end;
		end;
	     end;
	     call as_meter_$exit (NETUP_METER);
	end;

	do i = 1 to anstbl.current_size;		/* Look at all interactive users. */
	     utep = addr (anstbl.entry (i));		/* Get ptr to answer table entry. */
	     static_label = updend;			/* if error, try next guy */
	     if ute.active ^= NOW_HAS_PROCESS then go to updend; /* Does user have a process? */
	     if ute.destroy_flag > WAIT_LOGOUT_SIG then go to updend; /* Process is being destroyed, ignore it */
	     pdtep = ute.pdtep;			/* Yes. set up ptrs and update him. */
	     call update_user;			/* Update all usage. */
	     if ute.preempted > 0 then go to updend;	/* don't kick a man when he's down */
	     call adjust_cutoff_ (pdtep, anstbl.current_time);
	     call checklim (0, mcode);		/* User over limit? */
	     if mcode ^= 0 then do;			/* yup */
		call asu_$bump_user (utep, substr (line, 1, mlth), code, installation_parms.warning_time);
		call sys_log_ (SL_LOG, "act_ctl_: bumping ^a.^a ^a", ute.person, ute.project, substr (line, 1, mlth));
	     end;

/* now see if user should be bumped for inactivity */

	     if up_exec = 5				/* Is process stopped? */
		| up_exec = 4 then do;		/* .. or blocked? */
check_time:	if up_block >= some_time_ago then go to updend;
		if ute.at.nobump then go to updend;	/* no bump daemons */
		if ute.uflags.disconnected then do;

/* disconnected processes get bumped NOW */
		     interactive_signal = "bump";	/* Sending wakeup to dialup_ saying blocked too long */
		     call hcs_$wakeup (as_data_$as_procid, ute.event, zap_user, code);
		end;
		else do;

/* Give the user some time to call up and cancel the bump,
   or finish his work up gracefully */
		     call asu_$bump_code (utep, as_error_table_$inactive, short, code, installation_parms.warning_time);
		     call sys_log_ (SL_LOG, "act_ctl_: bumping ^a.^a for inactivity", ute.person, ute.project);
		end;
	     end;

updend:	     static_label = updret1;			/* If run off end of table or somethng. */
	end;

/* Now update usage for daemons. */

	dutp = as_data_$dutp;
	do i = 1 to dutbl.current_size;		/* Same sort of scan. */
	     utep = addr (dutbl.entry (i));		/* Use the fact that anstbl and dutbl look same */
	     static_label = skip_dmn;			/* Set up ucs transfer to go to next daemon. */
	     if ute.active ^= NOW_HAS_PROCESS then go to skip_dmn;
						/* skip if nobody there */
	     pdtep = ute.pdtep;			/* Get ptr to PDT entry for daemon */
	     call update_user;			/* Charge daemon. (Gets initializer too.) */
skip_dmn:	     static_label = updret1;
	end;

	autp = as_data_$autp;
	do i = 1 to autbl.current_size;		/* Now update absentees. */
	     utep = addr (autbl.entry (i));
	     static_label = skip_abs;			/* in case fault */
	     if ute.active = NOW_FREE then go to skip_abs;
	     pdtep = ute.pdtep;
	     call update_user;			/* Update all time counters */

	     if divide (ute.cpu_this_process, MILLION, 35, 0) > ute.max_cpu_time then
		if ^ute.at.nobump then do;		/* If over-ran cpu limit. */
		     call sys_log_ (SL_LOG, "act_ctl_: bumping abs^d ^a.^a - too much time",
			i, ute.person, ute.project);
		     abs_signal.type = "alar";	/* Sending wake to aum saying out of time */
		     go to send_wakeup;
		end;
	     if up_exec = 4 then do;
		if up_block >= some_time_ago then go to skip_abs;
		if ute.uflags.suspended then goto skip_abs; /* don't bump suspended job for inactivity */
		call sys_log_ (SL_LOG, "act_ctl_: bumping abs^d ^a.^a - inactive too long",
		     i, ute.person, ute.project);
		abs_signal.type = "inac";		/* Sending wake to aum saying blocked too long */
send_wakeup:	abs_signal.index = i;		/* .. set index for speedy finding of user */
		call hcs_$wakeup (whotab.abs_procid, whotab.abs_event, zap_abs, code);
	     end;

skip_abs:	     static_label = updret1;
	end;

/* free network_account_array in system area */
	if network_account_array_ptr ^= null then do;
	     call CHECK_NETWORK_ACCOUNTING_USE;
	     free network_account_array in (system_area);
	     network_account_array_ptr = null;
	end;

	call as_meter_ (mtc, mti, mui, mrs, mws, mhh, mel, mqu);

/* to see if two numbers are relatively equal, we use the following equation:
   .	|A-B|
   .	----- < TOLERANCE
   .	|A+B|
   .
   if this relation is true, A and B are equal within the "tolerance".
   due to the actual implementation (multiplying both sides by (A+B)),
   A+B must not be zero.
*/

	should_charge = float (mtc - mti, 63);		/* total availability. */
	did_charge = float (static_total_time_charged, 63); /* did charge this amount */
	discrepancy = should_charge - did_charge;	/* and this is the error term. */

	if discrepancy ^= 0e0			/* equation doesn't work if zero (and error is zero anyway!) */
	then if abs (discrepancy) >= TOLERANCE * abs (should_charge + did_charge)
	     then if mode ^= "test" then do;		/* doesn't work in test mode... */
		     call sys_log_ (SL_LOG, "act_ctl_: discrepancy of ^.2f mins", discrepancy / MICROSECONDS_PER_MINUTE);
		     call sys_log_ (SL_LOG_SILENT, "act_ctl_: charged ^.2f, available ^.2f mins",
			(did_charge / MICROSECONDS_PER_MINUTE), (should_charge / MICROSECONDS_PER_MINUTE));
		end;
	if shf ^= anstbl.shift then do;		/* Has shift changed? */
	     call sys_log_ (SL_LOG, "act_ctl_: changing shift from ^d to ^d", anstbl.shift, shf);
	     i = anstbl.shift;			/* remember old shift */
	     anstbl.shift = shf;

	     if ^shift_cmnd then do;			/* shift command sets whotab stuff */
		whotab.last_shift_change_time = anstbl.current_time; /* but we do it here at other shift changes */
		call datebin_$next_shift_change (anstbl.current_time, whotab.next_shift_change_time, whotab.shift, (0));
	     end;

	     call load_ctl_$set_maxunits (i);		/* The rules may have changed */
	     go to rescan;				/* Catch users with zero shift limit on new shift */
	end;
	else if anstbl.current_time >= whotab.next_shift_change_time then
	     call datebin_$next_shift_change (anstbl.current_time, whotab.next_shift_change_time, (0), (0));

	call load_ctl_$load_level (binary (mqu * 1e1), (mui * 1e1) / mtc);
updret1:	static_label = updret2;
	if alarmfail ^= 0 then go to updret2;		/* may have been called manually */
	if shift_cmnd then goto updret2;		/* or called by the shift command */
	next_update = next_update + installation_parms.acct_update * MILLION;
	last_update_interval = installation_parms.acct_update; /* save for alarm clock check */
	call timer_manager_$alarm_wakeup (next_update, "00"b, anstbl.acct_update_chn);
updret2:	static_label = return_immediately;
	updatetime = anstbl.current_time;		/* Remember when we did it */
	call ipc_$unmask_ev_calls (ec);		/* remember to allow logins again */
	call as_meter_$exit_values (ACCTUP_METER, pagefaults, vcpu_time, real_time);
	call sys_log_ (SL_LOG,
	     "act_ctl_: ^a update: users = ^d, pf=^d, vcpu=^.3f, rt=^.3f^[, answer table locked^]^[, install(s) pending^]",
	     up_word, anstbl.n_users, pagefaults, vcpu_time / 1.0e6, real_time / 1.0e6,
	     (anstbl.lock_count ^= 0), anstbl.update_pending);
return_immediately:
	return;
%page;
/* This entry is called whenever a process is destroyed, including at logout */
/* called by dialup_, absentee_user_manager_, daemon_user_manager_ & ftp_dialup_ */

dp:  entry (p);
	if mode = "dumm" then return;			/* accounting disabled */
	utep = p;					/* Copy ptr to answer table entry. */

	ansp = as_data_$ansp;
	anstbl.current_time = clock ();		/* Read clock. */

	cpudelta = ute.cpu_this_process;		/* dpg_ bumped cpu_usage */
	logdelta = anstbl.current_time - ute.last_update_time;
	coredelta = ute.mem_this_process;		/* ... */
	io_ops_delta = 0;				/* for now */
	static_total_time_charged = static_total_time_charged + cpudelta;

	pdtep = ute.pdtep;				/* get ptr to user pdte */
	if pdtep = null then go to check_update;	/* If null, forget update. */
	user.last_update = anstbl.current_time;		/* Note update. */
	call ipc_$mask_ev_calls (ec);			/* In case wait on lock, don't allow ev call. */
	call set_lock_$lock (user.lock, 300, ec);	/* lock user entry so can update charges */
	call ipc_$unmask_ev_calls ((0));		/* be sure not to leave them masked, whatever else happens */
	if ec = error_table_$lock_wait_time_exceeded then do;
	     call sys_log_$error_log (SL_LOG_BEEP, ec, "act_ctl_", "While destroying proc for ^a.^a",
		ute.person, ute.project);		/* Fuss. */
	     go to check_update;			/* But let him off easy. */
	end;
	if ute.queue = 0 then call charge_interactive;	/* Interactive user? */
	else if ute.queue < 0 then call charge_daemon;	/* Daemon? */
	else call charge_abs;			/* Other internal proc for absentees. */
	call device_acct_$broom (utep);		/* clean up any device_table slots for this process */

/* update any final DSA network charges for this user */
	network_account_array_ptr = null;
	if anstbl.login_server_present then do;
	     call as_meter_$enter (NETUP_METER);
	     call network_accounting_gate_$get_process_total (ute.proc_id,
		system_area_ptr, network_account_array_ptr, error_message,
		code);
	     if code ^= 0 then
		call sys_log_$error_log (SL_LOG_BEEP, code, "act_ctl_$dp",
		     "Error from " || error_message);
	     else do;
		if network_account_array_ptr ^= null then do;
		     if network_account_array.version ^= NET_ACCT_ARRAY_VERSION_1 then do;
			call sys_log_ (SL_LOG_BEEP,
			     "act_ctl_$dp:  Net accounting array version (^a) not supported.  Expected version (^a)",
			     network_account_array.version, NET_ACCT_ARRAY_VERSION_1);
			free network_account_array in (system_area);
			network_account_array_ptr = null;
		     end;
		end;
		call UPDATE_NETWORK_ACCOUNTING (utep);

/* free network_account_array in system area */
		call CHECK_NETWORK_ACCOUNTING_USE;
		if network_account_array_ptr ^= null then do;
		     free network_account_array in (system_area);
		     network_account_array_ptr = null;
		end;
	     end;
	     call as_meter_$exit (NETUP_METER);
	end;

	call set_lock_$unlock (user.lock, ec);		/* Done with PDT entry. */

	go to check_update;				/* Should clock have rung? */
%page;
/* This entrypoint is called when a user logs out. */
/* called by dialup_, absentee_user_manager_, daemon_user_manager_ & ftp_dialup_ */

close_account: entry (p);

	utep = p;					/* Copy ptr to answer tb */

	if mode = "dumm" then return;			/* accounting disabled */

	if ute.active < NOW_LOGGED_IN then return;	/* Ignore if nobody there. */
	ansp = as_data_$ansp;
	anstbl.current_time = clock ();		/* Read clock. */
	if ute.process_type = PT_ABSENTEE then do;
	     ttykind = "Absentee";			/* .. */
	     icode = QNAME (ute.queue);
	end;
	else if ute.process_type = PT_DAEMON then do;
	     ttykind = "Daemon";			/* .. */
	     icode = ute.tty_id_code;			/* .. */
	end;
	else do;					/* Interactive */
	     if ute.uflags.disconnected then
		ttykind = "DISCONNECTED";
	     else ttykind = ute.terminal_type;
	     icode = ute.tty_id_code;			/* .. */
	end;
	pdtep = ute.pdtep;				/* get ptr to user pdte */
	if pdtep ^= null then do;
	     user.now_in = decrement_and_check (user.now_in, "now_in");
	     if ute.queue <= 0 then do;
		user.n_foreground = decrement_and_check ((user.n_foreground), "n_foreground");
		if ute.process_type = PT_INTERACTIVE then do;
		     user.n_interactive = decrement_and_check ((user.n_interactive), "n_interactive");
		     if ute.disconnected then
			user.n_disconnected = decrement_and_check ((user.n_disconnected), "n_disconnected");
		end;
	     end;
	     else user.n_background = decrement_and_check ((user.n_background), "n_background");
	end;

	if asmtp ^= null then
	     asmt.logouts (ute.process_type) = asmt.logouts (ute.process_type) + 1;
						/* count logouts for metering */

	go to check_update;				/* Done. */
%page;
/* entry point called when system shutdown */
/* called by as_init_ */

act_ctl_close: entry;

	if mode = "dumm" then return;			/* accounting disabled */

	ansp = as_data_$ansp;
	anstbl.current_time = clock ();		/* Get time of shutdown */

	call as_meter_ (mtc, mti, mui, mrs, mws, mhh, mel, mqu);
	call as_meter_$as_meter_stop;			/* Stop metering. */

	secs = divide (static_total_time_charged, MILLION, 35, 0);
	mins = divide (secs, 60, 35, 0);		/* Format last message. */
	secs = mod (secs, 60);			/* .. */
	hrs = divide (mins, 60, 35, 0);		/* .. */
	mins = mod (mins, 60);			/* .. */
	call sys_log_ (SL_LOG, "act_ctl_: shutdown, ^d ^.2f ^.2f ^.2f ^.2f ^d:^d:^d $^.2f",
	     static_nlogins, mqu, mel, mhh, mrs,
	     hrs, mins, secs, static_total_dollar_charge);
	mode = "dumm";				/* disable accounting */
	return;

%page;
/* entry to see if process which has bump pending can have bump cancelled
   due to activity since warning of bump */
/* called by dialup_ */

activity_unbump: entry (a_atep, a_code);		/* see if a user is now active */

dcl  a_atep ptr;
dcl  a_code fixed bin (35);

	a_code = 0;				/* assume the best */
	ansp = as_data_$ansp;
	anstbl.current_time = clock ();		/* Read clock. */
	some_time_ago = anstbl.current_time - installation_parms.warning_time * MILLION
	     + INACTIVITY_STABILIZATION_TIME;
	call ipc_$mask_ev_calls (ec);			/* in case wait on lock */
	static_label = auret1;
	on any_other call as_any_other_handler_ ("act_ctl_", NULL_PROC, static_label, static_label);

	utep = a_atep;
	target_proc = ute.proc_id;			/* set up for call */
	call hphcs_$process_status (addr (process_status_return)); /* get process usage */

	if aptptr ^= null & up_exec = 4 & up_block < some_time_ago then
	     a_code = as_error_table_$inactive;		/* still no good */
	if debug_ia_sw then do;			/* DEBUG */
	     call sys_log_ (SL_LOG, "unbump check for ^a.^a, state = ^d, limit time = ^d, blocked at ^d, delta = ^d",
		ute.person, ute.project, up_exec, some_time_ago, up_block, some_time_ago - up_block);
	end;
auret1:	call ipc_$unmask_ev_calls (ec);
	return;
%page;

/* entry points to disable and reenable accounting for testing purposes */

act_ctl_disable: entry;

	mode = "dumm";
	call sys_log_ (SL_LOG, "act_ctl_: accounting disabled");
	return;

act_ctl_reable: entry;

	mode = "norm";				/* Turn accounting back on. */
	call sys_log_ (SL_LOG, "act_ctl_: accounting enabled.");
	ansp = as_data_$ansp;
	if anstbl.acct_update_chn = 0 then go to init1;	/* Have we started accounting? */
	return;

dcl  debug_ia_sw bit (1) int static init ("0"b);
dcl  ctlarg char (*);

debug_ia: entry (ctlarg);
	call cu_$arg_count (i);
	if i = 0 then
	     goto debug_ia_return;
	if ctlarg = "on" then
	     debug_ia_sw = "1"b;
	else if ctlarg = "off" then
	     debug_ia_sw = "0"b;
debug_ia_return:
	call sys_log_ (SL_LOG, "act_ctl_: Inactivity debug ^[on^;off^]", debug_ia_sw);
	return;


dcl  debug_na_sw bit (1) int static init ("0"b);

debug_na: entry (ctlarg);
	call cu_$arg_count (i);
	if i = 0 then
	     goto debug_na_return;
	if ctlarg = "on" then
	     debug_na_sw = "1"b;
	else if ctlarg = "off" then
	     debug_na_sw = "0"b;
	call network_accounting_gate_$debug (debug_na_sw);
debug_na_return:
	call sys_log_ (SL_LOG, "act_ctl_: Network accounting debug ^[on^;off^]", debug_na_sw);
	return;

%page;

/* internal subroutines */

/* This procedure calls the hardcore to find a process's usage, and then charges the usage
   via a call to charge_interactive, charge_daemon, or charge_abs. */

update_user: proc;

	target_proc = ute.proc_id;			/* set up for call */
	call hphcs_$process_status (addr (process_status_return)); /* get process usage */
	if aptptr = null then do;			/* Is user process there? */
	     call sys_log_ (SL_LOG_BEEP, "act_ctl_: process ^12.3b for ^a.^a vanished", ute.proc_id, ute.person,
		ute.project);
	     call asu_$bump_user (utep, "Process lost", code, 0);
	     return;				/* Can't update him. */
	end;

	cpudelta = process_status_return.virtual_cpu - ute.cpu_this_process; /* Calculate usage in process. */
	logdelta = anstbl.current_time - ute.last_update_time;
	coredelta = process_status_return.up_page - ute.mem_this_process;
	io_ops_delta = 0;				/* for now */

	call set_lock_$lock (user.lock, 15, ec);	/* lock user pdt entry */
	if ec = error_table_$lock_wait_time_exceeded then go to ugh1;
	static_label = ugh;				/* if error in this section, unlock user */
	ute.cpu_this_process = process_status_return.virtual_cpu; /* Fix up anstbl entry for next time. */
	ute.mem_this_process = process_status_return.up_page; /* ... */
	ute.last_update_time = anstbl.current_time;
	static_total_time_charged = static_total_time_charged + cpudelta;
	user.last_update = anstbl.current_time;		/* Note update in PDT */
	if ute.queue = 0 then call charge_interactive;
	else if ute.queue < 0 then call charge_daemon;
	else call charge_abs;
	call device_acct_$update (utep);		/* charge for tapes etc. */

/* update network accounting for this user */
	if anstbl.login_server_present then do;
	     call as_meter_$enter (NETUP_METER);
	     call UPDATE_NETWORK_ACCOUNTING (utep);
	     call as_meter_$exit (NETUP_METER);
	end;

ugh:	call set_lock_$unlock (user.lock, ec);		/* Now free PDT entry. */
ugh1:	return;

     end update_user;

%page;

/* This procedure charges an absentee for his usage. "pdtep", "atep", and the deltas must be set up. */

charge_abs: proc;

dcl  ii fixed bin;

	ii = ute.queue;				/* Extract queue number. */
	user.absentee (ii).cpu = user.absentee (ii).cpu + cpudelta;
	user.absentee (ii).memory = user.absentee (ii).memory + coredelta;
	cost = cpudelta * rs_ptrs (ute.rs_number) -> rate_structure.abs_cpu_price (ii) / MICROSECONDS_PER_HOUR +
	     coredelta * rs_ptrs (ute.rs_number) -> rate_structure.abs_mem_price (ii) / 1e6;
	user.absentee (ii).charge = user.absentee (ii).charge + cost;
	user.absolute_spent = user.absolute_spent + cost;
	user.dollar_charge = user.dollar_charge + cost;
	ute.session_cost = ute.session_cost + cost;
	static_total_dollar_charge = static_total_dollar_charge + cost;

     end charge_abs;

%page;

/* This procedure charges an interactive user for usage. "pdtep" and the deltas must be setup */

charge_interactive: proc;

dcl  ishft fixed bin;

	ishft = anstbl.shift;
	user.interactive.cpu (ishft) = user.interactive.cpu (ishft) + cpudelta;
	user.interactive.connect (ishft) = user.interactive.connect (ishft) + logdelta;
	user.interactive.core (ishft) = user.interactive.core (ishft) + coredelta;
	user.interactive.io_ops (ishft) = user.interactive.io_ops (ishft) + io_ops_delta;
	cost = cpudelta * rs_ptrs (ute.rs_number) -> rate_structure.cpu_price (ishft) / MICROSECONDS_PER_HOUR +
	     coredelta * rs_ptrs (ute.rs_number) -> rate_structure.core_price (ishft) / 1e6 +
	     logdelta * rs_ptrs (ute.rs_number) -> rate_structure.log_base_price (ishft) / MICROSECONDS_PER_HOUR +
	     io_ops_delta * rs_ptrs (ute.rs_number) -> rate_structure.io_ops_price (ishft) / MICROSECONDS_PER_HOUR;

	user.interactive.charge (ishft) = user.interactive.charge (ishft) + cost;
	user.dollar_charge = user.dollar_charge + cost;
	user.absolute_spent = user.absolute_spent + cost;
	ute.session_cost = ute.session_cost + cost;
	static_total_dollar_charge = static_total_dollar_charge + cost;

     end charge_interactive;

%page;

/* This procedure charges a daemon for usage. "pdtep" and the deltas must be setup
   the difference between this proc and charge_interactive is that daemons do not pay connect. */

charge_daemon: proc;

dcl  ishft fixed bin;

	ishft = anstbl.shift;
	user.interactive.cpu (ishft) = user.interactive.cpu (ishft) + cpudelta;
	user.interactive.connect (ishft) = user.interactive.connect (ishft) + logdelta;
	user.interactive.core (ishft) = user.interactive.core (ishft) + coredelta;
	user.interactive.io_ops (ishft) = user.interactive.io_ops (ishft) + io_ops_delta;
	cost = cpudelta * rs_ptrs (ute.rs_number) -> rate_structure.cpu_price (ishft) / MICROSECONDS_PER_HOUR +
	     coredelta * rs_ptrs (ute.rs_number) -> rate_structure.core_price (ishft) / 1e6 +
	     io_ops_delta * rs_ptrs (ute.rs_number) -> rate_structure.io_ops_price (ishft) / MICROSECONDS_PER_HOUR;

	user.interactive.charge (ishft) = user.interactive.charge (ishft) + cost;
	user.dollar_charge = user.dollar_charge + cost;
	user.absolute_spent = user.absolute_spent + cost;
	ute.session_cost = ute.session_cost + cost;
	static_total_dollar_charge = static_total_dollar_charge + cost;

     end charge_daemon;

%page;

/* Internal procedure to check resource limits.

   If a user should not be allowed to proceed, this program returns an error code
   and has set up the variables "line" and "mlth" with an explanation.
   Caller should ensure that adjust_cutoff_ has been called.

   Error codes are:

   .	shift limit exceeded (interactive)
   .	absolute limit exceeded
   .	month dollar limit exceeded
   .	cutoff date passed

   On entry, the variable "pdtep" must be pointing to the user's PDT entry.

*/

checklim: proc (abssw, errcd);

dcl  abssw fixed bin,				/* >0 if absentee -- don't check interactive limit */
     errcd fixed bin (35);				/* error code */

dcl  why char (32), limv float bin, ss fixed bin;

	errcd = 0;				/* clear error code */
	ss = anstbl.shift;
	if user.dollar_charge >= user.dollar_limit then do;
	     limv = user.dollar_limit;
	     errcd = as_error_table_$cut_user_mlim_msg;
	     why = "";
	end;
	if abssw <= 0 then				/* if not absentee, check shift limit */
	     if user.interactive.charge (ss) >= user.shift_limit (ss) then do;
		limv = user.shift_limit (ss);
		errcd = as_error_table_$cut_user_shift_msg;
		call convert_status_code_ (errcd, short, format);
		call ioa_$rs (format, line, mlth, limv, ss);
		return;
	     end;
	if user.absolute_spent >= user.absolute_limit then do;
	     limv = user.absolute_limit;
	     call date_time_ (user.absolute_cutoff, why);
	     errcd = as_error_table_$cut_user_cut_msg;
	end;
	if anstbl.current_time >= user.absolute_cutoff then do;
	     call date_time_ (user.absolute_cutoff, why);
	     errcd = as_error_table_$cut_user_date_msg;
	     call convert_status_code_ (errcd, short, format);
	     call ioa_$rs (format, line, mlth, why);
	     return;
	end;

	call convert_status_code_ (errcd, short, format); /* Get nice message for loser */
	call ioa_$rs (format, line, mlth, limv, why);
	return;

     end checklim;

%page;

cutoff_warning: proc (dont_check);

/* this procedure prints a warning message for the user if
   1) the project will be cut off soon (because of funds or date),
   2) the user will be cut off soon (because of funds or date),
   3) the user is supposed to get such warning messages, and
   4) this is not an absentee job. */

dcl  dont_check bit (36) aligned;

dcl  remaining float bin;
dcl  remaining_pct fixed bin;
dcl  (user_warn_days, user_warn_pct) fixed bin;
dcl  user_warn_dollars float bin;
dcl  (warn_days, warn_pct) fixed bin;
dcl  warn_dollars float bin;

dcl  ABS fixed bin init (1) static options (constant);
dcl  DAYS fixed bin init (2) static options (constant);
dcl  PCT fixed bin init (3) static options (constant);
dcl  SHIFT fixed bin init (6) static options (constant);
dcl  BILLING_PERIOD fixed bin init (7) static options (constant);

pom:	proc (type, v, period);
dcl  type fixed bin;
dcl  v float bin;
dcl  period fixed bin;

dcl  cut_date char (9);
dcl  reason char (64);

	     call date_time_ (user.absolute_cutoff, cut_date);
	     if type ^= DAYS then do;			/* periods 0-5 defined in adjust_cutoff_ */
		call ioa_$rsnnl ("^[ until" ||
		     "^[^; daily^; monthly^; yearly^; calendar year^; fiscal year^; weekly^]" ||
		     " cutoff on ^a^s^;^2s this ^[shift^;billing period^]^]",
		     reason, (0), period <= 6, period + 1, cut_date, period = SHIFT);
		if type = ABS then do;
		     call convert_status_code_ (as_error_table_$user_warn_funds, short, format);
		     call ioa_$rs (format, line, mlth, v, reason);
		end;
		else do;
		     call convert_status_code_ (as_error_table_$user_warn_pct, short, format);
		     call ioa_$rs (format, line, mlth, fixed (v), reason);
		end;
	     end;
	     else do;
		call convert_status_code_ (as_error_table_$user_warn_days, short, format);
		call ioa_$rs (format, line, mlth, cut_date);
	     end;
	     call write_message;
	end pom;

	if ute.queue > 0 | ute.adjust_abs_q_no then return; /* no use wasting any time if absentee */

	pdtp = baseptr (baseno (pdtep));		/* we have to look in the header of the user's pdt */

	if pdt.version >= 3 then do;			/* version 3 has warning thresholds in it */
	     user_warn_days = user.user_warn_days;
	     user_warn_pct = user.user_warn_pct;
	     user_warn_dollars = user.user_warn_dollars;
	     warn_days = user.warn_days;
	     warn_pct = user.warn_pct;
	     warn_dollars = user.warn_dollars;
	end;
	else do;					/* older pdts do not, so use defaults */
	     user_warn_days = 10;
	     user_warn_pct = 10;
	     user_warn_dollars = 10e0;
	     warn_days = 10;
	     warn_pct = 10;
	     warn_dollars = 10e0;
	end;

	if ^(dont_check & "1"b) & project.pct_balance < warn_pct | /* if low percentage-wise, or */
	     (project.pct_balance < 100 &		/* (proj w/no limit has pct=100 and dollars=0) */
	     project.dollars_to_cutoff < warn_dollars) then do; /* low in absolute dollars */
	     call convert_status_code_ (as_error_table_$proj_low_funds, short, format);
	     call ioa_$rs (format, line, mlth, project.dollars_to_cutoff, project.pct_balance);
	     call write_message;
	end;

	if ^(dont_check & "01"b) & project.days_to_cutoff < warn_days then do; /* if near cutoff date */
	     call convert_status_code_ (as_error_table_$warn_proj_date, short, format);
	     call ioa_$rs (format, line, mlth, project.days_to_cutoff);
	     call write_message;
	end;

	if user.dollar_limit < OPEN then do;
	     remaining = max (0e0, user.dollar_limit - user.dollar_charge);
	     if remaining < user_warn_dollars then	/* running out of monthly dollars */
		call pom (ABS, remaining, BILLING_PERIOD);
	     remaining_pct = ceil (remaining / max (1e-2, user.dollar_limit)) * 100e0;
	     if remaining_pct < user_warn_pct then	/* running out of monthly % */
		call pom (PCT, (remaining_pct), BILLING_PERIOD);

	end;
	if user.absolute_limit < OPEN then do;
	     remaining = max (0e0, user.absolute_limit - user.absolute_spent);
	     if remaining < user_warn_dollars then	/* running against periodic limit */
		call pom (ABS, remaining, user.absolute_increm);
	     remaining_pct = ceil (remaining / max (1e-2, user.absolute_limit)) * 100e0;
	     if remaining_pct < user_warn_pct then	/* running out of periodic % */
		call pom (PCT, (remaining_pct), user.absolute_increm);

	end;
	if user.shift_limit (anstbl.shift) < OPEN then do;
	     remaining = max (0e0, user.shift_limit (anstbl.shift) - user.interactive (anstbl.shift).charge);
	     if remaining < user_warn_dollars then
		call pom (ABS, remaining, SHIFT);
	     remaining_pct = ceil (remaining / max (1e-2, user.shift_limit (anstbl.shift))) * 100e0;
	     if remaining_pct < user_warn_pct then
		call pom (PCT, (remaining_pct), SHIFT);
	end;

	if user.absolute_increm = 0 then		/* absolute cutoff date in effect */
	     if user.absolute_cutoff < NEVER then
		if divide (user.absolute_cutoff - anstbl.current_time,
		     24 * 60 * 60 * MILLION, 71, 0) < user_warn_days then
		     call pom (DAYS, (0), 0);

	return;

     end cutoff_warning;

%page;

write_message: proc;				/* to write substr(line,1,mlth) on user or daemon terminal */

	if ute.queue = -1 then			/* daemon */
	     call sys_log_ (SL_LOG, substr (line, 1, mlth - 1)); /* omit newline since sys_log_ supplies one */
	else call asu_$blast_user (utep, substr (line, 1, mlth), "", 0);
	return;

     end write_message;

%page;
/* This procedure is called to decrement the various process counters in the pdt entry,
   and trap a bug where a counter can go negative. It returns the decremented value as a function
   return, because the counters are not all of the same precision. */

decrement_and_check: proc (counter, name) returns (fixed bin);

dcl  counter fixed bin;
dcl  name char (*);
dcl  return_value fixed bin;

	return_value = counter - 1;			/* decrement counter */
	if return_value < 0 then do;			/* trap bug */
	     call sys_log_ (SL_LOG_SILENT, "act_ctl_: ^a for ^a.^a is negative (^d) at logout; setting it to zero.",
		name, ute.person, ute.project, return_value);
	     return_value = 0;
	end;

	return (return_value);

     end decrement_and_check;


/* Internal procedure invoked when a fault occurs in update */

NULL_PROC: procedure; end NULL_PROC;			/* cleanup procedure with nothing in it */
%page;
Write_User_Message:
     procedure (P_code, P_message);

dcl  P_code fixed bin (35) parameter;
dcl  P_message char (*) parameter;

dcl  message char (512) automatic;
dcl  message_lth fixed bin automatic;
dcl  message_buffer_cur_lth fixed bin automatic;
dcl  message_buffer_max_lth fixed bin automatic;
dcl  message_buffer_ptr ptr automatic;
dcl  new_message_buffer_max_lth fixed bin automatic;
dcl  new_message_buffer_ptr ptr automatic;

dcl  status_code_string char (100) aligned automatic;

dcl  message_buffer char (message_buffer_max_lth)
	based (message_buffer_ptr);
dcl  new_message_buffer char (new_message_buffer_max_lth)
	based (new_message_buffer_ptr);

dcl  astty_$tty_force entry (ptr, ptr, fixed bin, fixed bin (35));

	if P_code ^= 0 then
	     call convert_status_code_ (P_code, (""), status_code_string);
	else status_code_string = "";

/**** Handle the case were the as_error_table_ entry specifies a null message.
      Only skip the message if both the code string and message string are
      null. */

	if (status_code_string = "") & (P_message = "") then
	     return;

	call ioa_$rs ("^[^a ^;^s^]^a", message, message_lth,
	     (status_code_string ^= ""), status_code_string,
	     rtrim (P_message));

	if ute.channel ^= null then			/* user has a MCS channel */
	     call astty_$tty_force ((ute.channel), addr (message),
		message_lth, (0));
	else do;
	     message_buffer_ptr = as_data_$ls_message_buffer_ptr;
	     message_buffer_max_lth = as_data_$ls_message_buffer_max_lth;
	     message_buffer_cur_lth = as_data_$ls_message_buffer_cur_lth;

	     if message_buffer_cur_lth + message_lth > message_buffer_max_lth then do;
		new_message_buffer_max_lth = message_buffer_max_lth +
		     min (512, message_buffer_cur_lth + message_lth);
		if system_area_ptr = null
		then system_area_ptr = get_system_free_area_ ();
		allocate new_message_buffer in (system_area)
		     set (new_message_buffer_ptr);
		substr (new_message_buffer, 1, message_buffer_cur_lth) =
		     substr (message_buffer, 1, message_buffer_cur_lth);
		free message_buffer in (system_area);
		as_data_$ls_message_buffer_ptr,
		     message_buffer_ptr = new_message_buffer_ptr;
		as_data_$ls_message_buffer_max_lth,
		     message_buffer_max_lth = new_message_buffer_max_lth;
	     end;

	     substr (message_buffer, message_buffer_cur_lth + 1,
		message_lth) = message;
	     as_data_$ls_message_buffer_cur_lth = message_buffer_cur_lth +
		message_lth;
	end;
	return;
     end Write_User_Message;
%page;
CHECK_NETWORK_ACCOUNTING_USE: proc;

/* this routine will scan through network accounting array and report any
   entries which weren't processed during the accounting update */

dcl  net_indx fixed bin;				/* index into network_account_array */
dcl  process_id_to_match bit (36) aligned;
dcl  purge_bit bit (1);
dcl  total_connect_seconds fixed bin (35);		/* connect time to charge for */
dcl  total_bytes fixed bin (35);			/* bytes to charge for */
dcl  total_packets fixed bin (35);			/* packets to charge for */

	if network_account_array_ptr = null then
	     return;

	total_bytes, total_packets, total_connect_seconds = 0;
	process_id_to_match, purge_bit = "0"b;

/* loop through all NAT entries */
	do net_indx = 1 to network_account_array.count;

/* look for NAT entries not used in accounting update */
	     if ^network_account_array.accounting (net_indx) then do;

/* found unused NAT entry, does it match one I'm accumulating for */
		if process_id_to_match ^= network_account_array.process_id (net_indx) then do;
		     if process_id_to_match ^= "0"b then do;
			call sys_log_ (SL_LOG_SILENT,
			     "act_ctl_$update: Processid ^w missing.
Not charged for ^d pkt, ^d byte & ^d seconds; was^[ not^] purged.",
			     process_id_to_match, total_packets,
			     total_bytes, total_connect_seconds,
			     ^purge_bit);
		     end;

/* reset to start accumulating for this user */
		     process_id_to_match = network_account_array.process_id (net_indx);
		     total_bytes, total_packets, total_connect_seconds = 0;
		     purge_bit = "0"b;
		end;
		total_bytes = total_bytes + network_account_array.byte_count (net_indx);
		total_packets = total_packets + network_account_array.packet_count (net_indx);
		total_connect_seconds = total_connect_seconds + network_account_array.connect_time (net_indx);
		if network_account_array.purged (net_indx) then
		     purge_bit = "1"b;
	     end;
	end;

	if process_id_to_match ^= "0"b then do;
	     call sys_log_ (SL_LOG_SILENT,
		"act_ctl_$update: Processid ^w missing.
Not charged for ^d pkt, ^d byte & ^d seconds; was^[ not^] purged.",
		process_id_to_match, total_packets, total_bytes,
		total_connect_seconds, ^purge_bit);
	end;

     end CHECK_NETWORK_ACCOUNTING_USE;
%page;
UPDATE_NETWORK_ACCOUNTING: proc (p);

/* routine to update PDT entry for user defined by p->utep.
   When this routine is called, the PDT is locked. */

dcl  p ptr;					/* utep to update */

dcl  found_entry bit (1);
dcl  net_indices_initialized bit (1) int static init ("0"b);
dcl  net_indx fixed bin;				/* index into network_account_array */
dcl  total_bytes fixed bin (35);			/* bytes to charge for */
dcl  total_connect_seconds fixed bin (35);		/* connect time to charge for */
dcl  total_packets fixed bin (35);			/* packets to charge for */

	if network_account_array_ptr = null then
	     return;

	utep = p;

/* scan through the network_account_array looking for 1st entry for this
   process ID.   Since the array is in ascending order based on the
   processid ID, we can stop if we hit an entry greater than the PID being
   scanned for.

   I know this is a brute force method but it will work for now */

	total_bytes, total_packets, total_connect_seconds = 0;
	total_dsa_charges = 0.0;
	found_entry = "0"b;

	do net_indx = 1 to network_account_array.count;
	     if ute.proc_id = network_account_array.process_id (net_indx) then do;
		total_bytes = total_bytes + network_account_array.byte_count (net_indx);
		total_packets = total_packets + network_account_array.packet_count (net_indx);
		total_connect_seconds = total_connect_seconds + network_account_array.connect_time (net_indx);
		network_account_array.accounting (net_indx) = "1"b; /* show entry accounted for */
		found_entry = "1"b;
	     end;
	     else if network_account_array.process_id (net_indx) > ute.proc_id then
		goto table_scan_done;
	end;
table_scan_done:
	if ^found_entry then return;			/* no entries in table for this user */

/* initialize network charge device indices if not already done so */
	if ^net_indices_initialized then
	     call INIT_NET_DEVICE_INDICES;

/* now update the data in the PDT */
	if total_bytes > 0 & devtab_ix_dsa_kilobyte > 0 then
	     call CHARGE_DEVICE (devtab_ix_dsa_kilobyte, float (total_bytes, 63) / 1000);
	if total_packets > 0 & devtab_ix_dsa_kilopacket > 0 then
	     call CHARGE_DEVICE (devtab_ix_dsa_kilopacket, float (total_packets, 63) / 1000);
	if total_connect_seconds > 0 & devtab_ix_dsa_hour > 0 then
	     call CHARGE_DEVICE (devtab_ix_dsa_hour, float (total_connect_seconds, 63) / 3600);

	if debug_na_sw then do;
	     call sys_log_ (SL_LOG_SILENT,		/* DEBUG */
		"act_ctl_$update: Added ^d pkts, ^d bytes & ^d connect seconds (total cost = $^.2f) to ^a.^a",
		total_packets, total_bytes, total_connect_seconds, total_dsa_charges, ute.person, ute.project);
	end;

     end UPDATE_NETWORK_ACCOUNTING;
%page;
CHARGE_DEVICE: proc (P_device_index, P_quantity);

dcl  P_device_index fixed bin;
dcl  P_quantity float bin (63);

	cost = rs_ptrs (ute.rs_number) -> rate_structure.device_price (P_device_index, anstbl.shift) * P_quantity;
	user.devices (P_device_index) = user.devices (P_device_index) + cost;
	user.dollar_charge = user.dollar_charge + cost;
	user.absolute_spent = user.absolute_spent + cost;
	ute.session_cost = ute.session_cost + cost;

/* ********************
   We should probabily make a decision when MNA becomes active to add
   this charge to static_total_dollar_charge and display total_dsa_charges
   as total_mna_charges on the shutdown line
   ******************** */

	total_dsa_charges = total_dsa_charges + cost;

     end CHARGE_DEVICE;



INIT_NET_DEVICE_INDICES: proc;

/* locate indices in installation parms device table for network data if not already found */
	do devtab_ix_dsa_kilobyte = 1 to installation_parms.ndevices
	     while (installation_parms.devtab (devtab_ix_dsa_kilobyte).device_id ^= dev_id (dev_dsa_kilobyte));
	end;
	if devtab_ix_dsa_kilobyte = installation_parms.ndevices + 1 then
	     devtab_ix_dsa_kilobyte = 0;

	do devtab_ix_dsa_kilopacket = 1 to installation_parms.ndevices
	     while (installation_parms.devtab (devtab_ix_dsa_kilopacket).device_id ^= dev_id (dev_dsa_kilopacket));
	end;
	if devtab_ix_dsa_kilopacket = installation_parms.ndevices + 1 then
	     devtab_ix_dsa_kilopacket = 0;

	do devtab_ix_dsa_hour = 1 to installation_parms.ndevices
	     while (installation_parms.devtab (devtab_ix_dsa_hour).device_id ^= dev_id (dev_dsa_hour));
	end;
	if devtab_ix_dsa_hour = installation_parms.ndevices + 1 then
	     devtab_ix_dsa_hour = 0;

     end INIT_NET_DEVICE_INDICES;

/* format: off */
%page; %include absentee_user_table;
%page; %include access_mode_values;
%page; %include answer_table;
%page; %include as_data_;
%page; %include as_data_definitions_;
%page; %include as_meter_numbers;
%page; %include as_meter_table;
%page; %include as_wakeup_priorities;
%page; %include author_dcl;
%page; %include devid;
%page; %include dialup_values;
%page; %include daemon_user_table;
%page; %include installation_parms;
%page; %include network_account_array;
%page; %include pdt;
%page; %include rate_structure;
%page; %include sat;
%page; %include sc_stat_;
%page; %include sys_log_constants;
%page; %include terminate_file;
%page; %include ttyp;
%page; %include user_attributes;
%page; %include user_table_entry;
%page; %include user_table_header;
%page; %include whotab;

%page;
/* BEGIN MESSAGE DOCUMENTATION

   Message:
   act_ctl_: accounting disabled

   S:	as (severity1)

   T:	May occur at any time.

   M:	The accounting system has been disabled by a call to
   act_ctl_$act_ctl_disable.

   A:	$ignore


   Message:
   act_ctl_: accounting enabled.

   S:	as (severity1)

   T:	May occur at any time.

   M:	The accounting system has been enabled, probably after a
   special session, by a call to act_ctl_$act_ctl_reable.

   A:	$ignore


   Message:
   act_ctl_: alarm clock late or failing by XX.XX mins

   S:	as (severity1)

   T:	$run

   M:	The alarm clock channel has not caused an accounting update
   to be performed when it was due. (The time between updates is stored
   in the segment installation_parms.) The system performs a manual
   accounting update.
   This message may appear if the system has entered BOS, and Multics has then been restarted by the GO command.  In such case,
   the message can be ignored.

   A:	$note


   Message:
   act_ctl_: MODE update: users = NN, pf=XX, vcpu=YY.Y, rt=ZZ.Z MESSAGE

   S:	as (severity1)

   T:	$run

   M:	Periodically, the accounting programs read and store the CPU usage
   for each user.  This message is printed when the update completes.
   MODE may be 'Automatic', in which case the update occurred at the normal
   system parameter time; 'Manual', where the normal update didn't occur;
   or 'Shift Cmnd' where the update occurred due to a shift command.
   XX is the number of page faults taken by Initializer for update.
   YY.Y is the virtual CPU time taken by Initializer for update.
   ZZ.Z is the real time taken by Initializer for update.
   MESSAGE may be one or both of the following strings:
   'answer table locked' or 'install(s) pending'

   A:	$ignore
   The number of seconds between accounting updates is a system parameter
   that an installation may change; it is stored in the segment
   installation_parms.


   Message:
   act_ctl_: bumping absNN NAME.PROJ - inactive too long

   S:	as (severity1)

   T:	$run

   M:	The absentee job on absentee slot NN for user NAME.PROJ
   has remained blocked too long. (The inactive time limit is
   stored in the segment installation_parms.) The absentee job
   is bumped.

   A:	$ignore


   Message:
   act_ctl_: bumping absXX NAME.PROJ - too much time

   S:	as (severity1)

   T:	$run

   M:	The absentee job on absentee slot XX for the user
   NAME.PROJ has exceeded the CPU time limit for the queue. (This
   limit is stored in the segment installation_parms.)
   The absentee job is bumped.

   A:	$ignore


   Message:
   act_ctl_: bumping NAME.PROJ for inactivity

   S:	as (severity1)

   T:	$run

   M:	The user with name NAME and project PROJ has been inactive too
   long, and is bumped off the system.  The maximum inactive time
   is stored in the segment installation_parms.

   A:	$ignore


   Message:
   act_ctl_: bumping NAME.PROJ. REASON

   S:	as (severity1)

   T:	$run

   M:	The user with name NAME and project PROJ has been bumped
   because some per-user limit has been exceeded. REASON tells what was
   wrong; it will be a message such as "User resource limit of
   $100 monthly exceeded," depending on which user limit has
   been exceeded.

   A:	$ignore


   Message:
   act_ctl_$init: cannot locate Initializer.SysDaemon pdt entry

   S:	as (severity2)

   T:	$init

   M:	The accounting system requires the entry for Initializer in
   the project SysDaemon to be present because certain system metering
   figures are kept there.  This entry cannot be found, either because
   SysDaemon.pdt has been lost, or because its contents have been destroyed.  The
   system will probably encounter a simfault_xxx error and be unable to
   start up.

   A:	$contact
   Do not attempt to
   run the system until this problem has been fixed.


   Message:
   act_ctl_: changing shift from x to y

   S:	as (severity1)

   T:	$run

   M:	The current accounting shift has changed.
   The table that tells the beginning time for each shift is stored
   in the segment installation_parms.

   A:	$ignore


   Message:
   act_ctl_: charged X, available Y mins

   S:	as (severity0)

   T:	$run

   M:	X is the sum of virtual CPU time charged to all processes and Y is the total virtual CPU time used by all processes.
   This message logs detailed accounting information and appears whenever the message "act_ctl_: discrepancy of XX.XX mins" appears.

   A:	$ignore


   Message:
   act_ctl_: discrepancy of XX.XX mins

   S:	as (severity1)

   T:	$run

   M:	The total time available from traffic control does not agree
   with the total time charged to users plus the Initializer time plus
   the idle time.  Some process has escaped being accounted for.

   A:	$inform_sa


   Message:
   act_ctl_$init: ERROR_MESSAGE. creating update channel

   S:	as (severity2)

   T:	$init

   M:	The timer channel that causes accounting updates to be performed
   could not be created.  All accounting updates will be manual,
   triggered by a user logging out.

   A:	$inform

   Message:
   act_ctl_: Lock wait time exceeded.  While destroying proc for NAME.PROJ

   S:	as (severity2)

   T:	$run

   M:	The accounting system was unable to lock the PDT entry for the
   user NAME in the project PROJ within its time limit (usually five minutes)
   This user attempted to log out or destroy a process.  The
   entry was probably locked because a system administrator or daemon process
   locked the entry and then failed.  The system attempts
   to continue.

   A:	$inform_sa


   Message:
   act_ctl_: process XXXXXXXXXXXX for NAME.PROJ vanished

   S:	as (severity2)

   T:	$run

   M:	Traffic control cannot locate a process for a user who should
   have one according to accounting.  The system attempts to run
   normally, but this user is not charged.  An attempt is
   made to bump the user in question.  This may be the first indication
   that the segment >system_control_1>answer_table has been damaged.

   A:	$note


   Message:
   act_ctl_: STRING for USER.PROJ is negative (NUM) at logout;
	 set it to zero.

   S:	as (severity2)

   T:	$run

   M:	A counter value of STRING was decremented by 1 and went negative.
   It was noticed when attempting to log out USER  on the PROJ project.
   This is a sign of possible damage to the PROJ pdt.

   A:	$note


   Message:
   act_ctl_$update: Processid XXXXXXXX missing.
   Not charged for XX pkt, YY byte and ZZ seconds; was/was not purged.

   S:	as (severity2)

   T:	$run

   M:	After charging network accounting usage for all users on the system,
   an entry was found for processid XXXXXXXX.  The XX, YY and ZZ are counts of
   the usage which the process had.  If the entry was for a process which is 
   no longer logged in, the accounting record was purged from the network 
   accounting file.

   A:	$note


   Message:
   act_ctl_: shutdown, NNN WW.WW XX.XX YY.YY ZZ.ZZ HH:MM:SS $DDD.DD

   S:	as (severity1)

   T:	$shut

   M:	A successful shutdown of the accounting portion of the system
   has been accomplished. NNN logins were recorded, for a total usage
   of HH:MM:SS of CPU time charged.  The other numbers are of interest
   to system administrators and programmers. WW.WW is the average queue
   length, XX.XX is the average eligible, YY.YY is the thrashing index,
   ZZ.ZZ is the average response, and DDD.DD is the total dollar charge
   since startup.  A shutdown of the hardcore system follows this
   message.

   A:	$ignore


   Message:
   act_ctl_$init: ERROR_MESSAGE. Cannot unlock PDT PATHNAME.

   S:	as (severity2)

   T:	$init

   M:	This message occurs during answering service initialization
   when attempting to unlock all PDTs.  ERROR_MESSAGE specifies the
   the reason for the problem.  The PDT is skipped.  Later problems
   may arise because of this error.
        
   A:	$inform

   Message:
   act_ctl_$init: The PDT is damaged. Cannot unlock PATHNAME.

   S:	as (severity2)

   T:	$init

   M:	This message occurs during answering service initialization
   when attempting to unlock all PDTs.  The specified PDT had its
   damaged switch turned on.  Because of this, it was not unlocked
   from the previous bootload.  It is skipped.  Later problems may
   arise when an attempt is made to reference this PDT.
        
   A:	$inform

   Message:
   act_ctl_$update: Error from ROUTINE: MESSAGE

   S:	as (severity2).

   T:	$run

   M:	The system encountered problems while referencing the
	network_accounting_table.  The network_accounting_ ROUTINE being
	called and MESSAGE text further describe the error.

   A:     $inform


   Message:
   act_ctl_$update: Net accounting array version (VERSION_RETURNED) not 
   supported.  Expected version (VERSION_SUPPORTED)

   S:	as (severity2).

   T:	$run

   M:	network_accounting_gate_$read_and_reset_table returned a structure
   version which act_ctl_ does not support.  $err

   A:     $contact_sm


   Message:
   act_ctl_$dp: Net accounting array version (VERSION_RETURNED) not 
   supported.  Expected version (VERSION_SUPPORTED)

   S:	as (severity2).

   T:	$run

   M:	network_accounting_gate_$read_and_reset_table returned a structure
   version which act_ctl_ does not support.  $err

   A:     $contact_sm


   Message:
   act_ctl_$init: illegal value (DD) for accounting update interval in installation_parms.

   S:	as (severity2)

   T:	$init

   M:	The value given in installation_parms.acct_update is less than or 
   equal to zero.  The installation_parms file is probabily damaged.

   A:	$contact
   Do not attempt to
   run the system until this problem has been fixed.


   END MESSAGE DOCUMENTATION */

     end act_ctl_;
