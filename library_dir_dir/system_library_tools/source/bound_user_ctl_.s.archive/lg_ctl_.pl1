/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/****^  HISTORY COMMENTS:
  1) change(86-05-13,GJohnson), approve(86-05-13,MCR7387),
     audit(86-05-13,Martinson), install(86-05-14,MR12.0-1055):
     Correct error message documentation.
  2) change(86-08-03,Swenson), approve(86-08-13,MCR7512),
     audit(86-08-13,EJSharpe), install(86-09-08,MR12.0-1150):
     Modified to check for RW access on channel ACS segments upon login.
     (Actual change date was 85-08-03)
  3) change(86-08-03,Swenson), approve(86-08-13,MCR7512),
     audit(86-08-13,EJSharpe), install(86-09-08,MR12.0-1150):
     Modified to correctly check authorizations for anonymous users.
     (Actual change date was 85-08-03)
  4) change(87-02-19,Farley), approve(87-07-06,MCR7691),
     audit(87-03-11,Fawcett), install(87-08-04,MR12.1-1055):
     Changed DETERMINE_AUTHORIZATIONS to use convert_access_class_$(minimum and
     maximum) instead of aim_check_$greater to find the minimum range of
     authorizations between the SAT, PDT and PNT.
  5) change(87-03-05,Farley), approve(87-07-06,MCR7691),
     audit(87-03-11,Fawcett), install(87-08-04,MR12.1-1055):
     Corrected to properly enforce password expiration interval.
  6) change(87-03-20,Beattie), approve(87-04-06,MCR7656),
     audit(87-07-21,Brunelle), install(87-08-04,MR12.1-1055):
     Add support for hasp operator subchannels to be login service.
  7) change(87-04-07,GDixon), approve(87-07-06,MCR7741),
     audit(87-07-21,Brunelle), install(87-08-04,MR12.1-1055):
      A) Correct coding standard violations.
      B) Changed to not reference whotab entry if none is associated with the
         ute.
      C) Changed to call asu_$blast_user instead of astty_$force_write when
         warning user of another login.
      D) Clear out the message buffer used to hold messages produced by
         act_ctl_ and load_ctl_.
      E) Eliminate lg_ctl_$reset entrypoint.  Either user_table_mgr_$allocate
         or $reset should be used instead. (dsa 206, dsa 214)
      F) Eliminate use of ute.logged_in flag, in favor of ute.active =
         NOW_LOGGED_IN.
      G) Remove code which prevents whotab.process_authorization from being
         set.
      H) Avoid referencing whotab entry if process does not appear in whotab.
      I) Upgraded for change to answer_table.incl.pl1 and
         user_table_entry.incl.pl1.
  8) change(87-05-12,GDixon), approve(87-07-06,MCR7741),
     audit(87-07-21,Brunelle), install(87-08-04,MR12.1-1055):
      A) Don't send warning of other login to disconnected or UFT processes.
         Neither could receive the warning or acted upon invalid logins.
  9) change(87-05-14,GDixon), approve(87-07-06,MCR7741),
     audit(87-07-21,Brunelle), install(87-08-04,MR12.1-1055):
      A) Avoid null_pointer fault when notifying MNA user of another login.
 10) change(87-06-22,GDixon), approve(87-07-06,MCR7741),
     audit(87-07-21,Brunelle), install(87-08-04,MR12.1-1055):
      A) Print login info when -brief is given (or defaults) and
         ute.active = NOW_LOGGED_IN.  Because it is being set to that
         prior to the test.
 11) change(87-06-22,GDixon), approve(87-06-30,MCR7656),
     audit(87-07-21,Brunelle), install(87-08-04,MR12.1-1055):
      A) Set outer module properly for hasp operator console logins.
      B) Avoid null_pointer fault when notifying MCS user of already-logged in
         DSA user.
 12) change(87-06-23,GDixon), approve(87-07-06,MCR7741),
     audit(87-07-21,Brunelle), install(87-08-04,MR12.1-1055):
      A) Move auditing of all logins involving process creation into
         as_access_audit_.  Continue to audit operator login/logout and
         connect loop logouts here.
 13) change(87-08-07,GDixon), approve(87-08-07,MCR7741),
     audit(87-08-07,Brunelle), install(87-08-10,MR12.1-1076):
      A) Call ASSERT_LOGGED_IN_STATE when "login Person -connect" was given
         and that person.project has no disconnected processes.
 14) change(87-10-04,Beattie), approve(87-10-26,MCR7785),
     audit(87-12-04,Parisek), install(87-12-07,MR12.2-1008):
     Accomodate changes in format of date_time strings.
 15) change(87-11-20,Parisek), approve(88-02-11,MCR7849),
     audit(88-02-23,Lippard), install(88-07-13,MR12.2-1047):
     Set the new answer_table element ute.lowest_ring to the highest of PDTs
     low ring value and SATs low ring value. SCP6367
 16) change(88-05-02,GDixon), approve(88-08-15,MCR7969),
     audit(88-08-03,Lippard), install(88-08-29,MR12.2-1093):
      A) Changed to expand project alias -change_default_project is used to
         modify pnte.default_project.
 17) change(89-01-17,TLNguyen), approve(89-01-17,MCR8054),
     audit(89-02-06,Parisek), install(89-02-27,MR12.3-1015):
     Supply the correct number of arguments relative to the control codes
     specified in a ioa_ control string for a call to sys_log_ to
     log the disconnected count for a user.
                                                   END HISTORY COMMENTS */

/* format: style4 */

lg_ctl_: procedure ();

/* LOGIN_CONTROL - User Control procedure to determine whether, and how,
   a given user who identified himself with a name/password/project
   combination should be logged into the system. It also contains the
   procedure to log a user out, and manages the system "whotab" which
   publishes who's logged in. */

/*
   Initially coded by Michael J. Spier, September 18, 1969
   Revised and recoded in PL/1 by Michael J. Spier, 12.22.69
   mod 8/14/70 to allow unregistered responders & correct for bumping oldest, THVV
   changed for absentee feb 71 EDS
   variable attributes & load ctl, THVV 12/71
   dynamic changing of password, J. Phillipps 7/72
   Modified 740821 by PG for authorizations, misc. bug fixes, etc.
   Modified 750313 by T. Casey to pass pnt size to up_pnt_$make_hash.
   Modified 750604 by T. Casey to move setting of load control group (ate.group) to load_ctl_
   .	(it got too complicated, with the coming of the priority scheduler)
   Modified 750805 by THVV for cdte
   Modified 751024 by T. Casey to process name of prelinked subsystem, from login line or from pdt.
   Modified 751110 by PG to change handling of -gpw errors
   Modified April 1976 by T. Casey to move check for correct typing of generated password to dialup_, and
   .		to initialize ate.recent_fatal_error_(time count).
   Modified 760804 by THVV for sending mail and telling long info as answer
   Modified July 1976 by T. Casey to make "initproc,direct" work right.
   Modified 760819 by Roy Planalp to pass error msg up to dialup_/ftp_dialup_,
   .	to send mail for bad pw, to obey -brief ctl arg, and not allow login if illegal ctl args are used.
   Modified October 1976 by T. Casey to fix bad password counting.
   Modified January, 1977, by D. M. Wells, to include line types in PDT user structure
   Modified April, 1977, by D. M. Wells, to fix bug introduced last time that caused
   .	term types to be wrong for the first login with AS 9.2
   Modified June, 1977, by Robert Coren to use TTT-style terminal types
   Modified September 1977 by T. Casey to prevent hanging up after login refusal in cases
   .	where successful login might be possible with differnt args.
   Modified May 1978 by T. Casey to put min of project and user pdir quota figures into user table entry,
   .	and to log instances of init_ring, max_ring, or pdir_quota in PDTE exceeding limits in SATE.
   Modified June 1978 by T. Casey to use hash tables to search SAT and PDTs.
   Modified Fall 1978 by Larry Johnson for ring-0 demultiplexing.
   Modified November 1978 by T. Casey for MR7.0 absentee enhancements.
   Modified April 1979 by T. Casey for MR7.0a to fix bugs in foreground absentee implementation.
   Modified July 1979 by B. Margulies to remove the v_outer_module attribute.
   Modified July 1979 by T. Casey for MR8.0 to support process preservation across hangups.
   Modified July 1979 by C. Hornig for new MSF PNT.
   Modified January 1980 by T. Casey to fix bugs in process preservation.
   Modified Feb 1980 by M. B. Armstrong to implement multiple rate structures. (UNCA)
   Modified September 1980 by C. Hornig to send login denial messages at user's default authorization
   Modified 1980*12*31 B. Margulies for reconnection outer module switch.
   Modified April 13 1981 by E. N. Kittlitz to honour -bf with disconnected procs
   Modified June 1981 by E. N. Kittlitz for UNCA rate structures
   Modified June 1981 by T. Casey for MR9.0 to improve absentee load control efficiency,
   .	by returning load_ctl_'s detailed reason for deferral to AUM.
   Modified September 1981 by E. N. Kittlitz to assume 'create' for FTP logins.
   Modified November 1981, E. N. Kittlitz.  user_table_entry conversion.
   Modified December 1981, E. N. Kittlitz.  whotab header extension.
   Modified April 1982, E. N. Kittlitz. New AS initialization.
   Modified June 1982,  E. N. Kittlitz. Force pdt disconnected count if it disagrees with answer_table.
   Modified September 1982, E. N. Kittlitz. dial/slave -user support. default login ring.
   Modified February 1983, E. N. Kittlitz. sort_disc_list fix per Schiller identified problem.
   Modified February 1983, J. Schiller to allow multiple connection loops for a user, and to fix bug so that max_ring is enforced (once again).
   Modified May 1983, E. N. Kittlitz. stop cross-AIM creates if AIM required on channel.
   Modified July 1983, B. Margolin, to update the Mail Table when the user changes his default project.
   Modified 84-04-02 BIM for AIM ranges on communications channels.
   Modified 84-07-12 BIM for login AIM ranges.
   Modified 84-08-28 by E. Swenson for Version 2 PNT calling sequences.
   Modified 10/02/84 by R. Michael Tague: Changed the directory containing
   the ACS segments for the device channels from as_data_$acsdir to
   as_data_$rcpdir.
   Modified 84-10-03 by E. Swenson to incorporate Jim Falksen's changes
   for date_time_$format.
   Modified 84-10-26 by E. Swenson to not respect the "brief" flag for
   security-relevant messages and to disregard the project-id in
   deciding whether to notify of additional logins.
   Modified 84-11-14 by E. A. Ranzenbach for whotab.session...
   Modified 84-12-17 by EJ Sharpe to use merge_access_audit_flags_
   Modified 1985-01-10, BIM: MC access control.
   Modified 85-01-10 by E. Swenson restructured for new AS auditing.
   Modified 85-01-15 by Keith Loepere for pdir_dir_quota.
   Modified 1985-01-23 by E. Swenson for binary audit messages.
   Modified 1985-02-12 by E. Swenson to fix multip checking.
   Modified 1985-03-04 by E. Swenson for password restrictions.
   Modified 1985-04-17 by E. Swenson to check for damaged PDTs.
   Modified 1985-04-19 by E. Swenson to initialize anstbl.session to
   "special" for special session rather than "init".
   Modified 1985-04-24 by E. Swenson to set projectid before notifying of
   bad passwords.
*/

/* pictures */

dcl  four_digits picture "9999";

/* builtins */

dcl  (addr, addrel, clock, index, length, max, min, mod, null,
     reverse, rtrim, string, substr, unspec, verify) builtin;

/* entries */

dcl  act_ctl_$check entry (ptr, ptr, char (8) aligned, char (*) varying, fixed bin (35));
dcl  aim_check_$equal entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
dcl  aim_check_$greater_or_equal entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
dcl  aim_check_$in_range entry (bit (72) aligned, (2) bit (72) aligned) returns (bit (1) aligned);
dcl  astty_$tty_force entry (ptr, ptr, fixed bin, fixed bin (35));
dcl  as_access_audit_$login entry (ptr, char(*));
dcl  as_access_audit_$logout entry (ptr, char(*));
dcl  asu_$blast_user entry (ptr, char (*), char (*), fixed bin (35));
dcl  asu_$format_ftp_msg entry (char (200) aligned, fixed bin, fixed bin, fixed bin) returns (char (200) aligned);
dcl  asu_$write_message entry (ptr, fixed bin (35), char (8) aligned, fixed bin (35));
dcl  display_access_class_ entry (bit (72) aligned) returns (character (32) aligned);
dcl  display_access_class_$range entry ((2) bit (72) aligned) returns (character (32) aligned);
dcl  convert_access_class_$maximum entry ((*) bit (72) aligned, fixed bin, bit (72) aligned);
dcl  convert_access_class_$minimum entry ((*) bit (72) aligned, fixed bin, bit (72) aligned);
dcl  convert_access_class_$to_string_short entry (bit (72) aligned, char (*), fixed bin (35));
dcl  convert_access_class_$to_string_range_short entry ((2) bit (72) aligned, character (*),
	fixed binary (35));
dcl  convert_status_code_ entry (fixed bin (35), char (8) aligned, char (100) aligned);
dcl  date_time_$format entry (char (*), fixed bin (71), char (*), char (*)) returns (char (250) var);
dcl  hash_$search entry (ptr, char (*), fixed bin, fixed bin (35));
dcl  hcs_$get_user_access_modes entry (char (*), char (*), char (*), fixed bin, bit (36) aligned, bit (36) aligned,
	fixed bin (35));
dcl  hcs_$initiate entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
dcl  ioa_$rs entry options (variable);
dcl  ioa_$rsnnl entry options (variable);
dcl  load_ctl_ entry (ptr, ptr, ptr, ptr, fixed bin, char (8) aligned, char (*) varying, fixed bin (35));
dcl  load_ctl_$unload entry (ptr, fixed bin);
dcl  mail_table_initializer_$set_dft_proj entry (char (*) var, char (*), fixed bin (35));
dcl  mc_check_access_$log_in_as_daemon entry (char (*), char (*), fixed bin (35));
dcl  merge_access_audit_flags_ entry (bit (36) aligned, bit (36) aligned) returns (bit (36) aligned);
dcl  pnt_manager_$admin_get_entry entry (char (*), ptr, fixed bin (35));
dcl  pnt_manager_$login_get_entry entry (char (*), char (*), ptr, fixed bin (35));
dcl  pnt_manager_$update_entry entry (ptr, bit (1), bit (1), fixed bin (35));
dcl  scramble_ entry (char (8) aligned) returns (char (8) aligned);
dcl  send_mail_$access_class entry (char (*), char (*), ptr, bit (72) aligned, fixed bin (35));
dcl  sub_err_ entry () options (variable);
dcl  sys_log_ entry options (variable);
dcl  sys_log_$error_log entry options (variable);
dcl  ttt_info_$decode_type entry (fixed bin, char (*), fixed bin (35));
dcl  ttt_info_$encode_type entry (char (*), fixed bin, fixed bin (35));
dcl  up_sat_$make_sat_hash entry (ptr, fixed bin, ptr, char (*), fixed bin (35));

/* external static */

dcl  as_error_table_$already_in_msg fixed bin (35) ext;
dcl  as_error_table_$already_in_notify_msg fixed bin (35) ext;
dcl  as_error_table_$already_in_warn_msg fixed bin (35) ext;
dcl  as_error_table_$bad_anon_pw fixed bin (35) ext;
dcl  as_error_table_$bad_password fixed bin (35) ext;
dcl  as_error_table_$bad_personid fixed bin (35) ext;
dcl  as_error_table_$bad_project fixed bin (35) ext;
dcl  as_error_table_$breach fixed bin (35) external;
dcl  as_error_table_$cant_give_dft_auth fixed bin (35) external;
dcl  as_error_table_$cant_give_that_authorization fixed bin (35) external;
dcl  as_error_table_$dft_auth_changed fixed bin (35) external;
dcl  as_error_table_$dft_proj_changed fixed bin (35) ext;
dcl  as_error_table_$dialup_error fixed bin (35) ext;
dcl  as_error_table_$illegal_hd_arg fixed bin (35) ext;
dcl  as_error_table_$illegal_ip_arg fixed bin (35) ext;
dcl  as_error_table_$illegal_om_arg fixed bin (35) ext;
dcl  as_error_table_$illegal_save_arg fixed bin (35) ext;
dcl  as_error_table_$illegal_ss_arg fixed bin (35) ext;
dcl  as_error_table_$last_login_msg fixed bin (35) ext;
dcl  as_error_table_$login_anon_msg fixed bin (35) ext;
dcl  as_error_table_$login_msg fixed bin (35) ext;
dcl  as_error_table_$long_ip_arg fixed bin (35) external;
dcl  as_error_table_$long_ss_arg fixed bin (35) external;
dcl  as_error_table_$multiple_login_msg fixed bin (35) external;
dcl  as_error_table_$must_change fixed bin (35) external;
dcl  as_error_table_$must_use_generate_pw fixed bin (35) external;
dcl  as_error_table_$n_disconnected_procs_msg fixed bin (35) ext;
dcl  as_error_table_$no_change fixed bin (35) ext;
dcl  as_error_table_$no_daemon_bit fixed bin (35) ext;
dcl  as_error_table_$no_disconnected_procs fixed bin (35) ext;
dcl  as_error_table_$no_line_permission fixed bin (35) ext;
dcl  as_error_table_$no_name fixed bin (35) ext;
dcl  as_error_table_$no_primary fixed bin (35) ext;
dcl  as_error_table_$not_in_pdt fixed bin (35) ext;
dcl  as_error_table_$password_changed fixed bin (35) ext;
dcl  as_error_table_$password_expired fixed bin (35) external;
dcl  as_error_table_$password_expired_msg fixed bin (35) external;
dcl  as_error_table_$password_locked fixed bin (35) ext;
dcl  as_error_table_$password_probe1_mail_msg fixed bin (35) ext;
dcl  as_error_table_$password_probe1_msg fixed bin (35) ext;
dcl  as_error_table_$password_probe_mail_msg fixed bin (35) ext;
dcl  as_error_table_$password_probe_msg fixed bin (35) ext;
dcl  as_error_table_$password_unused_too_long_msg fixed bin (35) external;
dcl  as_error_table_$pdt_missing fixed bin (35) ext;
dcl  as_error_table_$ring_too_low fixed bin (35) ext;
dcl  as_error_table_$ring_too_high fixed bin (35) ext;
dcl  as_error_table_$special_sess_msg fixed bin (35) ext;
dcl  as_error_table_$user_fg_cpu_limit fixed bin (35) ext;
dcl  as_error_table_$user_max_bg fixed bin (35) ext;
dcl  as_error_table_$user_max_fg fixed bin (35) ext;
dcl  error_table_$bad_password fixed bin (35) external static;
dcl  error_table_$checksum_failure fixed bin (35) external static;
dcl  error_table_$id_not_found fixed bin (35) external;
dcl  error_table_$messages_off fixed bin (35) external;
dcl  error_table_$out_of_sequence fixed bin (35) ext static;
dcl  error_table_$smallarg fixed bin (35) external;
dcl  error_table_$wakeup_denied fixed bin (35) external;

/* Internal Static */

dcl  (pdt_htp) ptr int static init (null);
dcl  tracing bit (1) aligned int static init ("0"b);	/* trace switch */

/* Constants */

dcl  DISC_STATE (0:5) char (12) internal static options (constant) initial
	(
	"connect loop",				/* no command */
	"connect loop",				/* list */
	"create",					/* create */
	"connect",				/* connect */
	"new_proc",				/* new_proc */
	"destroy"					/* destroy */
	);

dcl  ME char (7) initial ("lg_ctl_") internal static options (constant);
dcl  NL char (1) int static options (constant) init ("
");
dcl  PT_DIAL_SLAVE initial (-1) fixed bin internal static options (constant);
dcl  USECS_PER_DAY fixed bin (71) initial (86400000000) internal static options (constant);

dcl  SUCCESS bit (1) aligned initial ("1"b) internal static options (constant);

/* Automatic */

dcl  ans char (64);
dcl  answer char (200) aligned;			/* message buffer */
dcl  authorization (3) bit (72) aligned;
dcl  authorization_string char (200);
dcl  bstemp bit (36) aligned;
dcl  char64 char (64);				/* temporary */
dcl  code fixed bin (35);
dcl  coded_type fixed bin;				/* numeric form of terminal type */
dcl  debg char (8) aligned init ("");			/* Short message from as_error_table_ */
dcl  errmsg char (168) varying;
dcl  first_pass bit (1) aligned;			/* whether this is the first pass or not */
dcl  flonginfo char (100) aligned;			/* this is used to get long messages out of as_error_table_ */
dcl  i fixed bin;
dcl  id_code char (4) aligned;			/* idcode */
dcl  l fixed bin;
dcl  last_term_type char (32);			/* used when printing previous login info */
dcl  login_state char (12);				/* what the user is doing */
dcl  logout_reason char (12);				/* reason for the logout */
dcl  mcode fixed bin (35) init (0);			/* Error code, which is reason for no login. */
dcl  octal_auth_string char (32) aligned;
dcl  p ptr;
dcl  password_changed_flag bit (1) initial ("0"b);	/* Indicates we changed the password */
dcl  pdt_name char (32);
dcl  pdtep ptr;
dcl  pdtp ptr;
dcl  process_type fixed bin (17);			/* -1 => dial/slave validation, 1 = interactive, 2 = absentee, 3 = daemon */
dcl  process_types (-1:3) char (3) initial (
	"int",
	"???",
	"int",
	"abs",
	"dmn");
dcl  rewrite_pnte bit aligned;
dcl  satep ptr;
dcl  scan_reason fixed bin;				/* why should we scan the answer table: 0 = don't; 2 = find current login instance, warn it, and explain refusal; 3 = notify current login instances of the new login instance. */
dcl  tcdtep ptr;
dcl  temp_coded_type fixed bin;			/* temporary version of same */
dcl  temp_person_name char (28);			/* for searching PDT */
dcl  temp_term_type char (32);			/* sometimes holds random device type */
dcl  tty_term_type char (32) aligned;			/* current device type */
dcl  user_limit bit (1) aligned init (""b);		/* 1 if login rejected because of fg or bg limit */
dcl  userx fixed bin;
dcl  vlonginfo char (100) varying;
dcl  w_date char (80) aligned;
dcl  xdebg char (8) aligned;				/* .. same when is to be thrown away */
dcl  xlonginfo char (100) varying;			/* these are used to hold message control formats */
dcl  xpw char (8);

dcl  1 old_pnte aligned like pnt_entry;
dcl  1 pnte aligned like pnt_entry;

/* Parameters */

dcl  P_cdtep ptr parameter;				/* pointer to cdt entry for logout */
dcl  P_code fixed bin (35) parameter;			/* error code for caller */
dcl  P_password char (8) aligned parameter;		/* password to check */
dcl  P_reason char (*) parameter;			/* reason for a no-process logout */
dcl  P_startflag bit (1) aligned parameter;		/* session type */
dcl  P_status char (*) parameter;			/* text message for caller */
dcl  P_text char (168) varying parameter;		/* text message for caller */
dcl  P_utep pointer parameter;			/* user_table_entry pointer */

/* Conditions */

dcl  seg_fault_error condition;			/* for checking for PDT damage */
%page;
/* Program */

MAIN_RETURN:					/* main return point */
	return;
%page;
init: entry (P_startflag);

	if ^sc_stat_$Multics_typed | sc_stat_$Go_typed then
	     call sub_err_ (error_table_$out_of_sequence, "lg_ctl_$init", "s");
	ansp = as_data_$ansp;

	if ^P_startflag then do;			/* Starting special session? */
	     anstbl.session, whotab.session = "special";	/* indicate system is in special session */
	     four_digits = mod (clock (), 10000);	/* Generate a number between 000 and 9999 */
	     anstbl.login_word = four_digits;		/* and use it as login word */
	     call sys_log_ (SL_LOG, "lg_ctl_: login word is ""^a""", anstbl.login_word);
	     call ioa_$rs (convert_message (as_error_table_$special_sess_msg), anstbl.special_message, i, "");
	     anstbl.message_lng = i;
	     anstbl.message_update_time = clock ();
	end;
	else do;					/* Normal startup. */
	     anstbl.session, whotab.session = "normal";	/* Set session type. */
	     anstbl.login_word = "login   ";		/* Set standard login word. */
	end;

/* now reset all project entries in the system administrator's table */

	do i = 1 to sat.current_size;			/* Do all SAT entries. */
	     satep = addr (sat.project (i));		/* Get ptr to project entry. */
	     project.pdt_ptr = null;			/* reset project's PDT pointer */
	end;

	return;					/* Done. */
%page;
abs_in: entry (P_utep, P_status, P_code);

/**** This entry is called when attempting to log an absentee user in. */

/**** The path being followed here to validate absentee process
      logins needs to be kept in sync with path followed by interactive
      process logins in the login entrypoint.  This is important to
      maintain equivalent functional testing for both kinds of processes.
      If any changes are made within this entrypoint make sure 
      lg_ctl_$login is updated as needed. */

	P_status = "";

	call SETUP (PT_ABSENTEE);			/* copy parameters, set initial values */
	call VALIDATE_PERSON ();
	call LOOKUP_PROJECT ();
	call PROCESS_ATTRIBUTES ();
	call DETERMINE_AUTHORIZATIONS ();
	call CHECK_PROCESS_LIMITS ();
	call SET_UP_FOR_PROCESS_CREATION ();
	goto login_returns;
%page;
daemon_in: entry (P_utep, P_status, P_code);

/**** This entry is called to validate an attempted daemon login */

	P_status = "";

	call SETUP (PT_DAEMON);
	call VALIDATE_PERSON ();
	call PROCESS_CHANGE_ARGUMENTS ();
	call PROCESS_AUTH_ARGUMENT ();
	call LOOKUP_PROJECT ();

	if ute.anonymous = 1 then do;
	     mcode = as_error_table_$not_in_pdt;
	     goto login_incorrect;
	end;

	call check_daemon_source_acs (mcode);
	if mcode ^= 0 then
	     go to login_abort_1;

	call PROCESS_ATTRIBUTES ();

/**** Ensure this user has the "daemon" attribute.  If not, do not allow
      the login.  This prevents operator mistakes and ensures operators
      don't log in just anyone. */

	if ^ute.at.daemon then do;
	     mcode = as_error_table_$no_daemon_bit;
	     go to login_incorrect;
	end;

	call DETERMINE_AUTHORIZATIONS ();
	call CHECK_PROCESS_LIMITS ();
	call SET_UP_FOR_PROCESS_CREATION ();
	goto login_returns;
%page;
validate: entry (P_utep, P_password, P_text, P_code);

/**** Special entry for validating the use of "dial" / "slave" preaccess
      commands. */

	call SETUP (PT_DIAL_SLAVE);
	call VALIDATE_PERSON ();
	call PERFORM_PASSWORD_CHECKS ();
	call CHECK_FOR_SECURITY_BREACH ();
	call PROCESS_CHANGE_ARGUMENTS ();
	call PROCESS_AUTH_ARGUMENT ();
	call LOOKUP_PROJECT ();

	if ute.anonymous = 1 then
	     if user.password ^= "" then		/* If anonymous user has password, check it. */
		if scramble_ (user.password) ^= P_password then do;
		     mcode = as_error_table_$bad_anon_pw;
		     go to login_incorrect;		/* anonymous user's password is incorrect */
		end;

	if cdte.flags.access_control.slave_dial then
	     if ^check_channel_acs () then do;
		mcode = as_error_table_$no_line_permission;
		go to login_abort_1;
	     end;

	call PROCESS_ATTRIBUTES ();
	call DETERMINE_AUTHORIZATIONS ();
	call CHECK_CHANNEL_ACCESS_CLASS ();

/* for dial and slave, allows server to learn name given on -user control argument. */
	cdte.user_name.project = substr (ute.project, 1, length (cdte.user_name.project));
	cdte.user_name.person = substr (ute.person, 1, length (cdte.user_name.person));
	ute.login_result = 0;
	mcode = 0;
	go to login_returns;
%page;
login: entry (P_utep, P_password, P_text, P_code);

/**** Come here to validate an interactive login */

/**** The path being followed here to validate interactive process
      logins needs to be kept in sync with path followed by absentee
      process logins in the abs_in entrypoint.  This is important to
      maintain equivalent functional testing for both kinds of processes.
      If any changes are made within this entrypoint make sure 
      lg_ctl_$abs_in is updated as needed. */

	call SETUP (PT_INTERACTIVE);

	first_pass = ute.active < NOW_LOGGED_IN;	/* remember this if the first pass */

	call VALIDATE_PERSON ();

/**** Here, we test for a fairly unusual condition, namely, that the user
      has logged in successfully, and we have already checked his password,
      and may have even changed it, and we've notified him of any bad
      passwords, and printed all the messages connected with a successful
      login.  But he had one or more disconnected processes and didn't give
      one of the connect arguments on the login line, so we returned to
      dialup_ to ask him what to do. And he said to create a new process.
      So now we're back here, to see if he can have another process, and
      if so, to set up the parameters for it. But we have to skip over the
      password checking and message printing that we already did.

      ute.active >= NOW_LOGGED_IN tells us that we're in this situation. */

	if ute.active < NOW_LOGGED_IN then do;		/* skip these checks, done already */
	     call PERFORM_PASSWORD_CHECKS ();
	     call CHECK_FOR_SECURITY_BREACH ();
	     call PROCESS_CHANGE_ARGUMENTS ();
	end;

	call PROCESS_AUTH_ARGUMENT ();
	call LOOKUP_PROJECT ();

	if ute.anonymous = 1 then
	     if user.password ^= "" then		/* If anonymous user has password, check it. */
		if scramble_ (user.password) ^= P_password then do;
		     mcode = as_error_table_$bad_anon_pw;
		     go to login_incorrect;		/* anonymous user's password is incorrect */
		end;


	if cdte.flags.access_control.login then
	     if ^check_channel_acs () then do;
		mcode = as_error_table_$no_line_permission;
		goto login_abort_1;
	     end;

	call PROCESS_ATTRIBUTES ();

	if ute.active < NOW_LOGGED_IN then		/* first trip through lg_ctl_ */
	     call SET_OUTER_MODULE ();

	call DETERMINE_AUTHORIZATIONS ();
	call CHECK_CHANNEL_ACCESS_CLASS ();
	call CHECK_PROCESS_LIMITS ();

/**** If this is not an anonymous login, we must check for such things
      as already logged in and ^multip, or for the existence of
      disconnected processes. */

	if ute.anonymous ^= 1 then
	     call CHECK_FOR_MULTIPLE_LOGINS ();

	call SET_UP_FOR_PROCESS_CREATION ();
	goto login_returns;
%page;
login_returns:
	if process_type ^= PT_DIAL_SLAVE & ute.uprojp ^= null then do;
						/* If project is empty, */
	     satep = ute.uprojp;			/* .. try to clean up our KST */
	     if project.n_users <= 0 then
		if project.project_id ^= "SysDaemon" then do;

/* See comment at label logout_returns. */

		     if project.n_users < 0
			| ute.login_result = 0 then	/* if n_users has illegal value, log it */
			call sys_log_ (SL_LOG_SILENT, "lg_ctl_: project.n_users = ^d for ^a (login ^a)",
			     project.n_users, project.project_id, ute.person);

/* *		     call hcs_$terminate_noname (project.pdt_ptr, code); /* */
/* *		     project.pdt_ptr = null;		/* If needed again we re-initiate. */
		end;
	end;

	if ute.login_result ^= 0 then do;
	     P_code = mcode;			/* return detailed reason to caller */
	     if ute.failure_reason = 1		/* if lg_ctl_ said no */
	     then do;				/* expand mcode into short and long messages */
		call convert_status_code_ (mcode, debg, flonginfo);
		i = length (flonginfo) + 1 - verify (reverse (flonginfo), " ");
		if process_type = PT_INTERACTIVE | process_type = PT_DIAL_SLAVE
						/* interactive/validate, return long message */
		then do;
		     if i = length (flonginfo) + 1	/* if expanded message was all blanks */
		     then P_text = "";		/* return a null string */
		     else P_text = substr (flonginfo, 1, i) || NL; /* else return message with NL appended */
		end;
		else if process_type = PT_ABSENTEE	/* if absentee, return message to AUM in P_status */
		then do;
		     P_status = flonginfo;
		end;
		else P_status, flonginfo = debg;	/* for daemons, return short form, and replace long one with it,
						   for use below */
	     end;
	     else do;				/* but if act_ctl_ or load_ctl_ said no, they returned errmsg */
		if process_type = PT_INTERACTIVE
		then P_text = errmsg;		/* return it in P_text for interactive */
		else if process_type = PT_ABSENTEE
		then P_status = errmsg;		/* or in P_status for absentee */
		else P_status = debg;		/* but just return the short form, for daemons */

		if process_type ^= PT_DAEMON		/* if not daemon */
		then flonginfo = errmsg;		/* put returned long message in flonginfo,
						   where lg_ctl_'s message would have been */
		else flonginfo = debg;		/* but if daemon, put the short message there */
	     end;
	end;

lrt2:						/* come here if reason is "already logged in" */

	if ute.login_result = 0 then			/* successful login */
	     if first_pass then			/* only do this the first time through */
		call AUDIT_LOGIN (SUCCESS);
	     else ;				/* don't log anything if we've already done it */

/**** Avoid logging 2nd and subsequent instances of absentee refused by load
      control.  */

	else do;
	     if ^(ute.login_result = 2 & ute.uflags.deferral_logged) then

		call AUDIT_LOGIN (^SUCCESS);

	     if ute.login_result = 2 then		/* if normal deferral */
		ute.uflags.deferral_logged = "1"b;	/* remember not to log deferral of this job again */
	end;

	if process_type ^= PT_INTERACTIVE & process_type ^= PT_DIAL_SLAVE then
	     P_status = flonginfo;			/* Tell daemon or abs about failure */
	else P_password = "";			/* .. blank password of interactive. */
	return;					/* Done. */
%page;
login_incorrect:
	if rewrite_pnte then
	     call maybe_write_pnte;
login_abort_2:
	ute.login_result = 2;			/* allow guy to try once more */
	if process_type = PT_ABSENTEE & ^user_limit then
	     ute.login_result = 1;			/* abs can only retry if user limit was reason */
	ute.failure_reason = 1;			/* lg_ctl_ proper threw him out */
	go to login_returns;

login_abort_1:
	ute.login_result = 1;			/* it's hopeless, hang him up right away */
	ute.failure_reason = 1;			/* lg_ctl_ proper threw him out */
	go to login_returns;
%page;
abs_out: entry (P_utep);

/**** This entry is called when an absentee process logs out */

	if as_data_$ansp = null then return;		/* procedure not initialized */
	ansp = as_data_$ansp;
	if as_procid ^= anstbl.as_procid then return;	/* privileged entry point */

	process_type = PT_ABSENTEE;			/* Absentee. */
	utep = P_utep;				/* copy ptr to AUT entry */

	if ute.queue > 0 then			/* if not foreground absentee */
	     whotab.abs_users = whotab.abs_users - 1;	/* decrease count of absentee users */
	else whotab.fg_abs_users = whotab.fg_abs_users - 1; /* else decrease foreground user count */
	go to logout_returns;
%page;
daemon_out: entry (P_utep);

	if as_data_$ansp = null then return;		/* procedure not initialized */
	ansp = as_data_$ansp;
	if as_procid ^= anstbl.as_procid then return;	/* privileged entry pint */

	process_type = PT_DAEMON;			/* daemon */
	utep = P_utep;				/* copy ptr */

	whotab.n_daemons = whotab.n_daemons - 1;	/* count down */
	go to logout_returns;
%page;
logout: entry (P_utep);

	if as_data_$ansp = null then return;		/* procedure not initialized */
	ansp = as_data_$ansp;
	if as_procid ^= anstbl.as_procid then return;	/* privileged entry point */

	process_type = PT_INTERACTIVE;		/* normal user */
	utep = P_utep;				/* copy ptr */

	if ^(ute.active = NOW_LOGGED_IN & ute.proc_create_ok) then do; /* check if ute has a real, logged in user */
	     call sys_log_ (SL_LOG_SILENT, "lg_ctl_$logout: called with active=^d,^[^;^^^]proc_create_ok for ^a.^a ^a ute ^p",
		ute.active, ute.proc_create_ok, ute.person, ute.project, ute.tty_name, utep);
	     return;				/* don't decrement counters twice */
	end;

logout_returns:
	call load_ctl_$unload (utep, process_type);	/* May promote somebody. */
	if ute.uprojp ^= null then do;		/* If project is empty, */
	     satep = ute.uprojp;			/* .. try to clean up our KST */
	     if project.n_users <= 0 then
		if project.project_id ^= "SysDaemon" then do;

/* There is a bug in the pdt reference counting, that causes the reference count to go to zero
   while there are still users logged in on the project. To avoid the repercussions arising
   from terminating a pdt while there are still pointers to it in other
   user table entries, the code to terminate the pdt is being commented out, and replaced
   by a statement to log the instance of the ref count going to zero, to help
   find the cause of the bug that is making it go to zero too soon. This will
   result in higher segment numbers being used in the initializer process, but there are 4095
   segment numbers available, and the bug that caused the lot to overflow when high segment numbers
   were used has been fixed in MR8.0 */

		     if project.n_users < 0 then	/* log only if illegal value */
			call sys_log_ (SL_LOG_SILENT, "lg_ctl_: project.n_users = ^d for ^a (logout ^a)",
			     project.n_users, project.project_id, ute.person);

/* *		     call hcs_$terminate_noname (project.pdt_ptr, code); /* */
/* *		     project.pdt_ptr = null;		/* If needed again we re-initiate. */
/* *		     ute.pdtep = null;		/* this ptr is now invalid; simfault if we try to use it */
		end;
	end;

	ute.active = NOW_DIALED;			/* indicate user no longer logged-in */

	whotab.n_users = whotab.n_users - 1;		/* count users down. */
	whotab.n_units = whotab.n_units - ute.user_weight;
	userx = ute.whotabx;			/* locate whotab entry */
	if userx ^= 0 then do;			/* If user had entry, free it. */
	     whotab.e (userx).active = NOW_FREE;	/* mark idle */
	     whotab.e (userx).person, whotab.e (userx).project = "";
	     whotab.e (userx).chain = whotab.freep;	/* chain free entries together. */
	     whotab.freep = userx;			/* put on top of chain */
	     ute.whotabx = 0;			/* unhook from anstbl */
	end;

	call AUDIT_LOGOUT ("");			/* perform auditing */
	return;
%page;
logout_no_process:
     entry (P_utep, P_reason);

/**** This entry is used by programs which effectively logout an
      anthenticated user, when no process is associated with the
      specified utep */

	if as_data_$ansp = null then return;
	ansp = as_data_$ansp;
	if as_procid ^= anstbl.as_procid then return;

	utep = P_utep;

/**** This entry is only used for interactive logins */

	process_type = PT_INTERACTIVE;

	call AUDIT_LOGOUT (P_reason);
	return;
%page;
logout_channel:
     entry (P_cdtep, P_reason);

/**** This entry is used by programs which effectively logout an authenticated
      user/channel when a process is not affected by the logout. */

	if as_data_$ansp = null then return;
	ansp = as_data_$ansp;
	if as_procid ^= anstbl.as_procid then return;

	cdtep = P_cdtep;				/* get pointer to the cdte */

	call sys_log_ (SL_LOG, "LOGOUT^20t^a.^a int ^a (^a)", 
	     cdte.user_name.person, cdte.user_name.project, cdte.name,
	     P_reason);

	cdte.user_name.person = "";			/* reset these values */
	cdte.user_name.project = "";
	return;
%page;
login_operator:
     entry (P_sc_subsystem_info_ptr, P_success_sw, P_operator_name, P_reason);

/**** This entry is called by sc_requests_ to log operator logins.
      Currently the password checking is done within sc_requests_,
      but this should be moved here for consistency. */

dcl  P_sc_subsystem_info_ptr ptr parameter;		/* pointer to relevant info */
dcl  P_success_sw bit (1) aligned parameter;		/* whether this is successful or not */
dcl  P_operator_name char (*) parameter;		/* name of operator logging in */

	sc_subsystem_info_ptr = P_sc_subsystem_info_ptr;

	call sys_log_ (SL_LOG, "LOGIN^[^; DENIED^]^20t^a.Operator opr ^a (^a)",
	     P_success_sw, P_operator_name, sc_subsystem_info.source_name,
	     P_reason);
	return;
%page;
logout_operator:
     entry (P_sc_subsystem_info_ptr, P_operator_name, P_reason);

/**** This entry is called by sc_requests_ to log operator logouts. */

	sc_subsystem_info_ptr = P_sc_subsystem_info_ptr;

	call sys_log_ (SL_LOG, "LOGOUT^20t^a.Operator opr ^a (^a)",
	     P_operator_name, sc_subsystem_info.source_name, P_reason);
	return;
%page;
trace_on:
     entry ();

	tracing = "1"b;
	call sys_log_ (SL_LOG, "lg_ctl_: tracing turned on.");
	return;


trace_off:
     entry ();

	tracing = "0"b;
	call sys_log_ (SL_LOG, "lg_ctl_: tracing turned off.");
	return;
%page;
convert_message:
     procedure (p_status_code) returns (char (100) varying);

declare  p_status_code fixed binary (35) parameter;
declare  long character (100) aligned automatic;

/* A side effect of invoking this function is that the short form of the
   message is available in the global variable xdebg */

	call convert_status_code_ (p_status_code, xdebg, long);

	return (rtrim (long, " "));

     end convert_message;
%page;
maybe_write_pnte:
     procedure ();

	call pnt_manager_$update_entry (addr (pnte),
	     password_changed_flag,			/* Are we changing the password? */
	     "0"b,				/* lg_ctl_ doesn't use the network password */
	     code);
	rewrite_pnte = "0"b;
	if code ^= 0 then do;
	     call sys_log_$error_log (SL_LOG_BEEP, code, "lg_ctl_", "Error updating PNT entry of ^a.", ute.person);
	     mcode = as_error_table_$dialup_error;
	     goto login_abort_2;
	end;
     end maybe_write_pnte;
%page;
check_channel_acs:
     procedure () returns (bit (1) aligned);

dcl  group_id char (32);
dcl  mode bit (36) aligned;
dcl  ok bit (1) aligned;
dcl  type char (8);
dcl  user_id char (32);

	if ute.login_flags.dial_pw then type = "dial";
	else if ute.login_flags.slave_pw then type = "slave";
	else type = "login";
	if ute.person = "" then mode = ""b;
	else do;
	     user_id = rtrim (ute.person) || "." || rtrim (ute.project);
	     group_id = rtrim (user_id) || "." || "a";
	     call hcs_$get_user_access_modes (as_data_$rcpdir, rtrim (cdte.name) || ".acs", group_id, 0, mode, ""b, code);
	     if code ^= 0 then do;
		call sys_log_$error_log (SL_LOG, code, "lg_ctl_", "Unable to check access for channel ^a.", cdte.name);
		mode = ""b;
	     end;
	end;

	ok = (mode & RW_ACCESS) = RW_ACCESS;

	if ^ok then
	     call sys_log_ (SL_LOG_SILENT, "lg_ctl_: ^a access to channel ^a by ^a denied by ACS.",
		type, cdte.name, user_id);
	return (ok);
     end check_channel_acs;
%page;
check_daemon_source_acs:
     procedure (code);

dcl  group_id char (32);
dcl  code fixed bin (35);

	call ioa_$rsnnl ("^a.^a.z", group_id, (0), ute.person, ute.project);
	call mc_check_access_$log_in_as_daemon (group_id, ute.tty_name, code); /* This logs its decision */
	return;

     end check_daemon_source_acs;
%page;
BAD_PASSWORD:
     procedure ();

/**** This procedure is called for interactive users when the password
      supplied is invalid.  This code was moved from the inline code
      for clarity. */

	pnte.n_bad_pw = pnte.n_bad_pw + 1;
	pnte.n_bad_pw_since_good = pnte.n_bad_pw_since_good + 1;
	pnte.time_last_bad_pw = anstbl.current_time;
	pnte.last_bad_pw_reported = "0"b;
	pnte.bad_pw_term_id = cdte.tty_id_code;
	pnte.bad_pw_term_type = cdte.current_terminal_type;
	pnte.bad_pw_line_type = cdte.cur_line_type;
	rewrite_pnte = "1"b;
	if pnte.n_bad_pw_since_good = 1
	then vlonginfo = convert_message (as_error_table_$password_probe1_mail_msg);
	else vlonginfo = convert_message (as_error_table_$password_probe_mail_msg);

	if vlonginfo ^= ""
	then do;
	     unspec (send_mail_info) = "0"b;		/* prepare to tell the user */
	     send_mail_info.version = 1;
	     send_mail_info.wakeup = "1"b;
	     send_mail_info.always_add = "1"b;
	     send_mail_info.sent_from = "login";

	     if pnte.n_bad_pw_since_good = 1 then
		call ioa_$rs (vlonginfo, answer, i, ute.person, tty_term_type, cdte.tty_id_code);
	     else call ioa_$rs (vlonginfo, answer, i, ute.person, pnte.n_bad_pw_since_good, tty_term_type, cdte.tty_id_code);

	     call ioa_$rsnnl ("^a.^a", pdt_name, (0), ute.person, ute.project);
	     call send_mail_$access_class (pdt_name, substr (answer, 1, i), addr (send_mail_info), pnte.default_person_authorization, code);
	     if (code ^= 0) & (code ^= error_table_$wakeup_denied) & (code ^= error_table_$messages_off)
	     then do;
		call ioa_$rsnnl ("^a.^a", pdt_name, (0), ute.person, pnte.default_project);
		call send_mail_$access_class (pdt_name, substr (answer, 1, i), addr (send_mail_info), pnte.default_person_authorization, code);

/* if that fails, we save the info to print later */

		if (code = 0) | (code = error_table_$wakeup_denied) | (code = error_table_$messages_off)
		then pnte.flags.last_bad_pw_reported = "1"b;
	     end;
	     else pnte.flags.last_bad_pw_reported = "1"b;
	end;
	if mod (pnte.n_bad_pw_since_good, installation_parms.login_tries - 1) = 0 then

/* Somebody is hacking. Tell operator */

	     call sys_log_ (SL_LOG_BEEP, "lg_ctl_: too many bad passwords for ^a.^a from ^a (^a terminal ""^a"").",
		ute.person, ute.project, ute.tty_name, tty_term_type, id_code);
	return;
     end BAD_PASSWORD;
%page;
CHECK_FOR_MULTIPLE_LOGINS:
     procedure ();

/**** This procedure is called for interactive, non-anonymous logins to
      check for the existence of other interactive processes.  If the
      user does not have the multip attribute and there are other interactive
      processes, the login is rejected.  Other cases are handled as well. */

	cdte.n_disconnected_procs = 0;		/* be sure there's no garbage in these */
	cdte.disconnected_ate_index = 0;
	if user.n_disconnected = 0 then do;		/* if user has no disconnected processes */
	     if cdte.disconnected_proc_command = 0	/* and user didn't give one of the special args */
		| cdte.disconnected_proc_command = 2 then do; /* or said -create, see if we can create a process for him */

		if ute.at.multip then		/* user has interactive processes, but it's ok */
		     scan_reason = 3;		/* but notify the current login instances of the new one */
		else scan_reason = 2;		/* he doesn't have multip; warn current one and say no to him */
	     end;

	     else do;
		call asu_$write_message (utep, as_error_table_$no_disconnected_procs, debg, code);
						/* say "You have no disconnected processes" */
		call ASSERT_LOGGED_IN_STATE ();
		call ASSERT_INTERACTIVE_LOGIN ();	/* record we are logged in */
		login_state = "connect loop";
		goto login_returns;
	     end;
	end;					/* end user has no disconnected processes */

	else do;					/* user does have disconnected processes */
	     if ute.active < NOW_LOGGED_IN then do;	/* if we didn't already do this */
		vlonginfo = convert_message (as_error_table_$n_disconnected_procs_msg);
		if (vlonginfo ^= "") & (^ute.at.brief | cdte.disconnected_proc_command = 0)
		then do;				/* if site hasn't turned off the message, say
						   You have N disconnected processes. */
		     call ioa_$rs (vlonginfo, answer, l, user.n_disconnected, (user.n_disconnected > 1));
		     call astty_$tty_force (cdtep, addr (answer), l, (0));
		end;
	     end;

	     if cdte.disconnected_proc_command = 2 then do; /* create */
		if ute.at.multip then		/* if its ok */
		     scan_reason = 3;		/* tell current instances about the new one */
		else scan_reason = 2;		/* warn current instance about the attempt */
	     end;
	     else if cdte.service_type ^= FTP_SERVICE then do; /* we'll do something with the disconnected processes */
		call ASSERT_LOGGED_IN_STATE ();
		call BUILD_DISCONNECTED_LIST ();
		call ASSERT_INTERACTIVE_LOGIN ();	/* record we are logged in */
		login_state = DISC_STATE (cdte.disconnected_proc_command);
		goto login_returns;
	     end;
	end;					/* end there are disconnected processes */

	if scan_reason ^= 0 then
	     call SCAN_ANSWER_TABLE (scan_reason);
	return;
     end CHECK_FOR_MULTIPLE_LOGINS;
%page;
SCAN_ANSWER_TABLE:
     procedure (P_reason);

/**** This procedure is called to scan the answer table for the existence
      of other interactive processes.  The reason for the scan is specified
      as P_reason.  2 specifies that we are to find any other
      instances warn them of the attempted login and refuse the login.
      3 specifies that we are to find any other instances and warn them
      of the new instance. */

dcl  P_reason fixed bin (17) parameter;			/* The reason why we are scanning */
dcl  found_identical_userid bit (1) aligned;		/* whether exact match found */
dcl  n_processes fixed bin (17);			/* number of other processes */
dcl  saved_utep ptr;				/* ptr to ute of other login instance for ^multip */
dcl  try_message bit (1) aligned;			/* whether to attempt a message */


	try_message = "1"b;				/* initially we will */
	found_identical_userid = "0"b;		/* not yet */
	n_processes = 0;

	do i = 1 to anstbl.current_size;		/* Scan through answer table. */
	     p = addr (anstbl.entry (i));		/* get pointer to answer table entry */
	     if p -> ute.active > NOW_LOGGED_IN		/* if this is a logged-in user with a process */
		& p ^= utep			/* (and not the temporary ate used by this dialup) */
		& p -> ute.person = ute.person	/* if the name is the same */
		& p -> ute.anonymous = 0		/* check only authenticated users */
	     then do;

		n_processes = n_processes + 1;	/* count user's processes as we find them */
		if p -> ute.project = ute.project	/* identical match */
		     & P_reason = 2			/* and we're we don't have multip */
		then do;
		     found_identical_userid = "1"b;
		     saved_utep = p;
		end;
	          if p -> ute.tag ^= TAG_UFT		/* if not a file transfer process */
		   & ^p -> ute.disconnected then	/* and not a disconnected process */

		call WARN_OF_ANOTHER_LOGIN (P_reason, try_message, found_identical_userid);
	     end;					/* end ate belongs to another instance of user logging in */
	end;					/* end scan of answer table */

	if P_reason = 2 & found_identical_userid then do; /* deny login */
	     mcode = as_error_table_$already_in_msg;	/* Too bad. */

	     if saved_utep -> ute.disconnected then	/* if logged in proc is disconnected, don't try to use the cdte */
		temp_term_type = "DISCONNECTED";	/* make up a reasonable terminal type */
	     else temp_term_type = saved_utep -> ute.terminal_type;

	     call ioa_$rs (convert_message (mcode), P_text, l,
		saved_utep -> ute.person, saved_utep -> ute.project,
		temp_term_type,
		saved_utep -> ute.tty_id_code);
	     ute.login_result = 2;			/* Login is denied, but don't hang up on the user */
	     debg = xdebg;				/* log reason for denial */
	     ute.failure_reason = 1;
	     go to lrt2;				/* take special return */
	end;					/* end reason = 2 */

	else if n_processes > 0			/* he has other processes */
	then do;					/* print "This is your Nth interactive login instance." */
	     n_processes = n_processes + 1;		/* add in this new process, too. */
	     xlonginfo = convert_message (as_error_table_$multiple_login_msg);
	     if (n_processes > 9) & (n_processes < 20)
	     then xdebg = as_data_$teens_suffix (n_processes);
	     else xdebg = as_data_$suffix (mod (n_processes, 10));

	     call ioa_$rs (xlonginfo, answer, i, n_processes, xdebg);
						/* "This is your 3rd interactive login instance." */
	     call astty_$tty_force (cdtep, addr (answer), i, code);
	end;
     end SCAN_ANSWER_TABLE;
%page;
BUILD_DISCONNECTED_LIST:
     procedure ();

/**** This procedure builds a list of all disconnected processes belonging
      to this user. */

dcl  back_thread fixed bin (17);			/* index of last disconnected process found */
dcl  i fixed bin (17);				/* temporary index of ute entries */
dcl  n_processes fixed bin (17);			/* number of other processes found */
dcl  p ptr;					/* temporary pointer to ute entries */

	n_processes = 0;				/* no processes found yet */
	back_thread = 0;				/* no entries yet */
	do i = 1 to anstbl.current_size;		/* scan through the answer table */
	     p = addr (anstbl.entry (i));		/* get pointer to ute */
	     if p -> ute.active > NOW_LOGGED_IN		/* if associated with a process */
		& p ^= utep			/* and not the temporary ute for this dialup */
		& p -> ute.anonymous = 0		/* and not a anonymous user */
		& p -> ute.person = ute.person	/* and the same personid */
		& p -> ute.project = ute.project	/* and the same project */
	     then do;
		n_processes = n_processes + 1;	/* increment number found */
		if p -> ute.disconnected then do;	/* found a disconnected one */
		     if back_thread = 0 then		/* list is empty */
			cdte.disconnected_ate_index = i; /* thread this ute onto the list header */
		     else addr (anstbl.entry (back_thread)) -> ute.next_disconnected_ate_index = i; /* else thread this ute onto the end of the list */
		     back_thread = i;		/* remember where the end of the list is */
		     cdte.n_disconnected_procs = cdte.n_disconnected_procs + 1; /* count the number of entries on the list */
		end;				/* end found a disconnected one */
	     end;					/* end found an appropriate process */
	end;					/* end scan of answer table */

	if cdte.n_disconnected_procs ^= user.n_disconnected then do; /* these got out of sync somehow */
	     call sys_log_ (SL_LOG, "^a: disconnected count for ^a.^a is ^d in cdte, ^d in pdte, n_processes = ^d.", ME, ute.person, ute.project, cdte.n_disconnected_procs, user.n_disconnected, n_processes);
	     user.n_disconnected = cdte.n_disconnected_procs; /* reset */
	end;
	if cdte.n_disconnected_procs > 1 then		/* we have some */
	     call SORT_DISC_LIST ();			/* sort the list */

	return;
     end BUILD_DISCONNECTED_LIST;
%page;
SORT_DISC_LIST:
     procedure ();

dcl  (lp1, lp2, lpp) ptr;
dcl  (li, ll, lx1, lx2) fixed bin;
dcl  sorted bit (1) aligned;

/* Interchange sort */

	sorted = ""b;				/* get the outer loop started */

	do ll = cdte.n_disconnected_procs to 2 by -1	/* each pass is 1 shorter than previous one */
	     while (^sorted);			/* quit early if we find them in order */

	     sorted = "1"b;				/* assume they're in order; this is turned off if we do an interchange */
	     lpp = null;				/* no previous entry */
	     lx1 = cdte.disconnected_ate_index;		/* index of first entry */

	     do li = 1 to ll - 1;			/* make one pass thru unsorted part of list */

/* Get indices and pointers to the next pair of entries to be compared.
   The list is singly-threaded. A -> B, B -> C, and C -> D. We are going to compare B and C,
   and interchange them if they are out of order. A might be the head of the list, and
   D might not exist. If we interchange, we will want to end up with:
   A -> C, C -> B, B -> D. lpp is ptr to A. lx1, lp1 point to B, lx2, lp2 point to C,
   and lp2 -> ate.next_disconnected_ate_index  points to D. */

		lp1 = addr (anstbl.entry (lx1));	/* pointer to first item */
		lx2 = lp1 -> ute.next_disconnected_ate_index; /* index of second one of this pair */
		lp2 = addr (anstbl.entry (lx2));	/* ptr to it */

/* Compare login times. Interchange if first is younger than second. We want oldest process first in list */

		if lp1 -> ute.login_time > lp2 -> ute.login_time then do;
						/* if time1 is greater, proc1 is younger */
		     if li = 1 then			/* if A is head of list */
			cdte.disconnected_ate_index = lx2; /* make head be C */
		     else lpp -> ute.next_disconnected_ate_index = lx2; /* else make previous entry point at C */
		     lp1 -> ute.next_disconnected_ate_index = lp2 -> ute.next_disconnected_ate_index; /* make B point at D */
		     lp2 -> ute.next_disconnected_ate_index = lx1; /* make C point at B */
		     lpp = lp2;			/* C is now preceding */
						/* lx1 for compare with new next */
		     sorted = ""b;			/* remember that we did an interchange */
		end;				/* end interchange */
		else do;				/* no swap, just advance */
		     lpp = lp1;			/* now we're the previous item */
		     lx1 = lx2;			/* make second of previous pair the first of next pair */
		end;

	     end;					/* end one pass thru list */

	end;					/* end outer loop */

	return;

     end SORT_DISC_LIST;
%page;
WARN_OF_ANOTHER_LOGIN:
     procedure (P_reason, P_message_flag, P_identical_userid);

dcl  P_reason fixed bin (17) parameter;
dcl  P_message_flag bit (1) aligned parameter;
dcl  P_identical_userid bit (1) aligned parameter;
dcl  try_blasting bit (1) aligned;			/* whether to try blasting or not */

	try_blasting = "0"b;			/* not unless the we can't send the message */
	if P_reason = 2 & P_identical_userid
	then mcode = as_error_table_$already_in_warn_msg;
	else mcode = as_error_table_$already_in_notify_msg;

	vlonginfo = convert_message (mcode);
	if vlonginfo ^= "" then do;			/* unless site has disabled this */
	     call ioa_$rs (vlonginfo, answer, l, ute.person, ute.person,
		ute.project, tty_term_type, id_code);

	     if P_message_flag then do;		/* if we're to attempt a message */
		unspec (send_mail_info) = "0"b;
		send_mail_info.version = 1;
		send_mail_info.wakeup = "1"b;
		send_mail_info.always_add = "1"b;
		send_mail_info.sent_from = "answering service";
		call ioa_$rsnnl ("^a.^a", pdt_name, (0), p -> ute.person, p -> ute.project);
		call send_mail_$access_class (pdt_name, substr (answer, 1, l), addr (send_mail_info),
		     p -> ute.process_authorization, code);

		if (code = 0			/* if we succeeded in sending the message */
		     | code = error_table_$wakeup_denied/* or if it got into the mbx ok, but */
		     | code = error_table_$messages_off) then /* the user won't see it until he prints messages */
		     P_message_flag = "0"b;		/* remember not to do it again */
		else try_blasting = "1"b;
	     end;

/**** If we did not succeed in sending the message, try to blast this
      instance of the user.  If we can't a message, we will blast all
      instances of this user. */

	     if try_blasting then do;
		if ^p -> ute.disconnected		/* else if it isn't a disconnected process */
		     & ^p -> ute.at.no_warning	/* and it didn't log in -no_warning */
		then do;				/* then blast the warning on its terminal */
		     tcdtep = p -> ute.channel;
		     if tcdtep ^= null then		/* not MNA user */
		     if tcdtep -> cdte.service_type = FTP_SERVICE
		     then answer = asu_$format_ftp_msg (answer, l, l, 050);
		     call asu_$blast_user (utep, (answer), "", 0);
		end;				/* end not disconnected */
	     end;					/* end blast code */
	end;					/* end of site selectable code */

     end WARN_OF_ANOTHER_LOGIN;
%page;
NOTIFY_USER_OF_LOGIN:
     procedure ();

/**** This procedure is invoked when we have successfully "logged in".
      We notify the user of this (if we haven't already and if we wants
      to know.  */

	if ^ute.at.brief & ute.active < NOW_HAS_PROCESS then do;
						/* Do we print logged-in message? */
	     w_date = date_time_$format ("date_time", anstbl.current_time, "", ""); /* get login time in ASCII */
	     if ute.anonymous = 0 then xlonginfo = convert_message (as_error_table_$login_msg);
	     else xlonginfo = convert_message (as_error_table_$login_anon_msg);
	     call ioa_$rs (xlonginfo, answer, i,	/* Use error explanation as control string. */
		ute.person, ute.project, w_date, tty_term_type, id_code);
	     call astty_$tty_force (cdtep, addr (answer), i, code);

	     if ute.anonymous = 0 then do;		/* Compose last-login message */
		if user.last_login_time ^= 0 then do;	/* If ever logged in before. */
		     w_date = date_time_$format ("date_time", user.last_login_time, "", "");
		     xlonginfo = convert_message (as_error_table_$last_login_msg);
		     if xlonginfo ^= "" then do;	/* If installation wants this. */
						/* Due to an error on my part in the conversion */
						/* from AS 9.1a to AS 9.2, the old term_type */
						/* field is the new line_type field, thus */
						/* the strangeness in the next few lines. - dmw */
			if (user.last_login_type = 0) /* there is no term type 0 */
			then temp_coded_type = user.last_login_line_type; /* thus old form */
			else temp_coded_type = user.last_login_type;
			call ttt_info_$decode_type (temp_coded_type, temp_term_type, code);
			if code ^= 0 then temp_term_type = "";
			if user.last_login_line_type >= LINE_UNKNOWN
			     | user.last_login_type = 0 /* old form, no line type */
			then last_term_type = temp_term_type;
			else call ioa_$rsnnl ("^a ^a", last_term_type, (0),
				line_types (user.last_login_line_type),
				temp_term_type);
			call ioa_$rs (xlonginfo, answer, i, w_date,
			     last_term_type, user.last_login_unit);
			call astty_$tty_force (cdtep, addr (answer), i, code);
		     end;
		end;
	     end;
	end;
	return;
     end NOTIFY_USER_OF_LOGIN;
%page;
VALIDATE_PERSON:
     procedure ();

/**** This procedure validates the value of ute.person.  It checks
      the password for interactive logins and authenticated dial/slave
      use. */

	login_state = ute.login_code;

	rewrite_pnte = "0"b;
	if ute.person = "" then do;			/* It's hopeless. He didn't say who he was */
	     mcode = as_error_table_$no_name;		/* Tell him we need to know */
	     go to login_abort_2;			/* Give another chance. */
	end;
	if ute.anonymous = 1 then do;			/* Anonymous user? */
	     if ute.project = "" then
	          ute.project = substr(ute.person,1,length(ute.project));
						/* Can't have default project here */
	     return;				/* No PNT processing for anonymous users */
	end;

	if ute.login_flags.cpw
	then xpw = ute.old_password;
	else xpw = P_password;

/**** We only check passwords for interactive users, not daemons or
      absentees.  However, if we've already checked the password as
      in the case of connecting to a disconnected process, we don't
      check it again.  This latter condition is signaled by the
      ute.active >= NOW_LOGGED_IN.  In either case, we need the
      pnte entry for the specified user.

      Note that pnt_manager_$login_get_entry checks the supplied password
      while pnt_manager_$admin_get_entry does not. */

	if (process_type = PT_INTERACTIVE & ute.active < NOW_LOGGED_IN)
	     | process_type = PT_DIAL_SLAVE then
	     call pnt_manager_$login_get_entry ((ute.person), xpw, addr (pnte), code);
	else call pnt_manager_$admin_get_entry ((ute.person), addr (pnte), code);

	if code ^= 0 then do;
	     if code = error_table_$id_not_found	/* Invalid user-id */
	     then do;
		mcode = as_error_table_$bad_personid;
		goto login_incorrect;
	     end;
	     else if code = error_table_$checksum_failure /* Damaged PNT entry */
	     then do;
		call sys_log_$error_log (SL_LOG_BEEP, code, ME, "Checksum failure reading PNT entry of ^a.", ute.person);
		mcode = as_error_table_$dialup_error;
		goto login_abort_1;
	     end;
	     else if code = error_table_$bad_password	/* Only for interactive users */
	     then do;
		ute.person = substr (pnte.user_id, 1, length (ute.person)); /* In case alias was used */
		if ute.project = "" then
		     ute.project = substr(pnte.default_project,1,length(ute.project));
		call BAD_PASSWORD ();
		mcode = as_error_table_$bad_password;
		goto login_incorrect;
	     end;
	     else do;				/* Some other error we don't know how to handle */
		call sys_log_$error_log (SL_LOG_BEEP, code, ME, "Error reading PNT entry of ^a.", ute.person);
		mcode = as_error_table_$dialup_error;
		goto login_abort_1;
	     end;
	end;

	old_pnte = pnte;				/* Save copy of pnt entry since we're about to modify it */

	ute.person = substr (pnte.user_id, 1, length (ute.person)); /* Found in PNT. Put real name in case alias. */
	if ute.project = "" then do;
	     ute.project = substr(pnte.default_project,1,length(ute.project));
	end;
     end VALIDATE_PERSON;
%page;
PROCESS_CHANGE_ARGUMENTS:
     procedure ();

/**** This procedure process the -change_default_project, and
      -change_default_authorization control arguments to the login command */

	if ute.anonymous = 1 then			/* anonymous users aren't allowed */
	     return;

	if ute.login_flags.cdp then			/* Default project change requested? */
	     if ^pnte.flags.nochange then do;		/* Ok to do this? */
	          call hash_$search (sat_htp, ute.project, i, code);
		if code = 0 then do;		/* If project alias used, expand it. */
		     satep = addr(sat.project(i));
		     if ute.project ^= project.project_id then
		     if ute.project  = project.alias then
			ute.project = project.project_id;
		     end;
		pnte.default_project = ute.project;	/* Set new value. */
		rewrite_pnte = "1"b;
		if ^ute.at.brief
		then call asu_$write_message (utep, as_error_table_$dft_proj_changed, debg, code);
	     end;
	     else do;
		mcode = as_error_table_$no_change;
		go to login_incorrect;
	     end;

	if ute.login_flags.cda			/* Default authorization change requested? */
	then if ^pnte.flags.nochange			/* OK? */
	     then do;
		pnte.default_person_authorization = ute.process_authorization;
		rewrite_pnte = "1"b;
		if ^ute.at.brief
		then call asu_$write_message (utep, as_error_table_$dft_auth_changed, debg, code);
	     end;
	     else do;				/* Not allowed to change things. */
		mcode = as_error_table_$no_change;
		goto login_incorrect;
	     end;

	if ute.login_flags.cdp & rewrite_pnte then do;
	     call mail_table_initializer_$set_dft_proj (rtrim (pnte.user_id), rtrim (pnte.default_project), code);
	     if code ^= 0 then
		call sys_log_$error_log (SL_LOG_BEEP, code, "lg_ctl_", "Changing Mail Table default project for ^a to ^a",
		     pnte.user_id, pnte.default_project);
	end;
	if rewrite_pnte then call maybe_write_pnte;
	return;

     end PROCESS_CHANGE_ARGUMENTS;
%page;
PERFORM_PASSWORD_CHECKS:
     procedure ();

/**** This procedure performs various checks on the password flags stored
      in the PNT and on the password options specified on the command line. */


	if ute.anonymous = 1 then
	     return;				/* we do not perform these checks for anonymous users */

	if ute.login_flags.cpw & ^ute.login_flags.generate_pw & pnte.flags.generate_pw then do;
	     mcode = as_error_table_$must_use_generate_pw;
	     goto login_incorrect;
	end;

	if ^ute.login_flags.cpw then			/* if he didn't ask to change */
	     do;
	     if pnte.flags.must_change then
		do;
		if ^pnte.flags.generate_pw then
		     mcode = as_error_table_$must_change;
		else mcode = as_error_table_$must_use_generate_pw;
		goto login_incorrect;
	     end;
	     if installation_parms.password_change_interval ^= 0 then
						/* and the site has an enforced interval */
		if (anstbl.current_time - pnte.time_pw_changed) >
		     (installation_parms.password_change_interval *
		     USECS_PER_DAY) then
		     do;
		     vlonginfo = convert_message (
			as_error_table_$password_expired_msg);
		     call ioa_$rs (vlonginfo, answer, i,
			installation_parms.password_change_interval);
		     call astty_$tty_force (cdtep, addr (answer), i, (0));
		     if ^pnte.flags.generate_pw then
			mcode = as_error_table_$must_change;
		     else mcode = as_error_table_$must_use_generate_pw;
		     goto login_incorrect;
		end;
		else ;
	end;

	if installation_parms.password_expiration_interval ^= 0 then
						/* and the site has an enforced interval */
/**** Check to see if last good password given longer ago than the limit */
	     if ((anstbl.current_time - pnte.time_last_good_pw) >
		(installation_parms.password_expiration_interval *
		USECS_PER_DAY)) &
/**** Check to see that an administrator has not yet re-validated the userid */
		((anstbl.current_time - pnte.user_validated_time) >
		(installation_parms.password_expiration_interval *
		USECS_PER_DAY)) then
		do;
		vlonginfo = convert_message (
		     as_error_table_$password_unused_too_long_msg);
		call ioa_$rs (vlonginfo, answer, i,
		     installation_parms.password_expiration_interval);
		call astty_$tty_force (cdtep, addr (answer), i, (0));
		mcode = as_error_table_$password_expired;
		goto login_incorrect;
	     end;
	     else ;

	pnte.n_good_pw = pnte.n_good_pw + 1;
	pnte.time_last_good_pw = anstbl.current_time;
	rewrite_pnte = "1"b;

/**** We used to check pnte.flags.last_bad_pw_reported here to decide
      whether to print the message "Your password was ..." on the terminal
      upon login.  Since it is possible (and likely) that the user logging
      in will have never seen the mail sent telling him that his password
      was used incorrectly, we remove that check and force the message
      on his terminal.  The theory is that if there really is someone trying
      to guess a password, and he does manage to succeed and get in, he
      will most likely delete any mail telling the REAL user that someone
      was hacking. */

	if pnte.n_bad_pw_since_good > 0 then do;	/* Security here */
	     w_date = date_time_$format ("date_time", pnte.time_last_bad_pw, "", "");
	     if pnte.n_bad_pw_since_good = 1
	     then vlonginfo = convert_message (as_error_table_$password_probe1_msg); /* Get singular-plural correct */
	     else vlonginfo = convert_message (as_error_table_$password_probe_msg); /* Tell user he has been tried. */
	     if vlonginfo ^= "" then do;		/* .. if installation wants this feature */
		temp_term_type = pnte.bad_pw_term_type;
		if pnte.bad_pw_line_type >= LINE_UNKNOWN
		then ;
		else call ioa_$rsnnl ("^a ^a", temp_term_type, (0), line_types (pnte.bad_pw_line_type),
			temp_term_type);

		if pnte.n_bad_pw_since_good = 1
		then call ioa_$rs (vlonginfo, answer, i, w_date,
			temp_term_type, pnte.bad_pw_term_id);
		else call ioa_$rs (vlonginfo, answer, i, pnte.n_bad_pw_since_good, w_date,
			temp_term_type, pnte.bad_pw_term_id);
		call astty_$tty_force (cdtep, addr (answer), i, code);
	     end;
	     pnte.last_bad_pw_reported = "1"b;
	     rewrite_pnte = "1"b;
	end;

	if pnte.last_bad_pw_reported
	then pnte.n_bad_pw_since_good = 0;

	if pnte.flags.trap then			/* Are we watching this guy? */
	     call sys_log_ (SL_LOG_BEEP, "lg_ctl_: password used ^a.^a ^a ^a ^a",
		ute.person, ute.project, ute.tty_name, tty_term_type, id_code);

	if (pnte.flags.pw_time_lock & anstbl.current_time < pnte.password_timelock)
	     | pnte.flags.lock then do;		/* is password locked? */
	     mcode = as_error_table_$password_locked;	/* Yes. No login for you. */
	     go to login_incorrect;			/* (but we won't tell you we caught you) */
	end;

	if ute.login_flags.cpw
	then if pnte.flags.nochange
	     then do;
		mcode = as_error_table_$no_change;
		goto login_incorrect;
	     end;
	     else do;
		pnte.password = P_password;
		password_changed_flag = "1"b;
		pnte.time_pw_changed = anstbl.current_time;
		pnte.flags.must_change = "0"b;
		rewrite_pnte = "1"b;
		if ^ute.at.brief
		then call asu_$write_message (utep, as_error_table_$password_changed, debg, code);
	     end;

	return;
     end PERFORM_PASSWORD_CHECKS;
%page;
PROCESS_AUTH_ARGUMENT:
     procedure ();

/**** If the user did not specify an authorization on the login line, then
      if anonymous, default to system_low, otherwise, use PNT default
      authorization */

	if ^ute.login_flags.auth_given then		/* If -auth not specified, use default */
	     if ute.anonymous = 1 then do;
		ute.process_authorization = ""b;
	     end;
	     else do;
		ute.process_authorization = pnte.default_person_authorization;
	     end;
	return;
     end PROCESS_AUTH_ARGUMENT;
%page;
LOOKUP_PROJECT:
     procedure ();

lookup_loop:
	call hash_$search (sat_htp, ute.project, i, code);
	if code ^= 0 then do;
proj_not_there: mcode = as_error_table_$bad_project;	/* Unknown project. */
	     go to login_incorrect;			/* Again, you lose. */
	end;
	satep = addr (sat.project (i));		/* get pointer to SAT entry that project hashes to */
	if ute.project ^= project.project_id then	/* it better be the right project */
	     if ute.project ^= project.alias then do;	/* otherwise the hash table has been clobbered */
		call sys_log_ (SL_LOG_BEEP, "lg_ctl_: sat.ht has ""^a"", SAT has ""^a"" at ^p",
		     ute.project, project.project_id, satep);
		call up_sat_$make_sat_hash (satp, sat.n_projects, sat_htp, ans, code);
		if code ^= 0 then do;
		     call sys_log_$error_log (SL_LOG_BEEP, "lg_ctl_", "unable to rehash sat.ht: ^a", ans);
		     mcode = as_error_table_$dialup_error;
		     goto login_abort_1;
		end;
		else goto lookup_loop;		/* go try the lookup again */
	     end;

	if project.state ^= 1 then do;
	     call sys_log_ (SL_LOG_BEEP, "lg_ctl_: project ^a, state ^d, still in sat.ht", project.project_id, project.state);
	     goto proj_not_there;
	end;


	ute.project = project.project_id;		/* in case alias was used */
	if project.pdt_ptr ^= null then pdtp = project.pdt_ptr; /* May have found PDT already. */
	else do;					/* initiate project's PDT */
	     pdt_name = rtrim (project.project_id) || ".pdt"; /* Stick on suffix */
	     call hcs_$initiate (pdtdir, pdt_name, "", 0, 0, pdtp, code);
	     if pdtp = null then do;			/* If pdt is missing, */
		call sys_log_$error_log (SL_LOG_BEEP, code, "lg_ctl_", "^a>^a", pdtdir, project.project_id);
		mcode = as_error_table_$pdt_missing;	/* Not able to log him in if no pdt */
		go to login_abort_2;		/* but user might have another project to try */
	     end;
	     project.pdt_ptr = pdtp;			/* save ptr in SAT for next time */
	end;
	if project.rs_number < 0 | project.rs_number > whotab.n_rate_structures then do;
	     call sys_log_ (SL_LOG_BEEP, "lg_ctl_: project ^a has invalid rate_structure number ^d. Using rate_structure 0.",
		project.project_id, project.rs_number);
	     ute.rs_number = 0;
	end;
	else ute.rs_number = project.rs_number;		/* plug in the rate_structure */

/* now search project's PDT to locate person's user profile */

	temp_person_name = ute.person;		/* name we are searching for */

	if ute.anonymous ^= 0 then			/* if user logging in is anonymous */
	     if ^project.at.anonymous then		/* but the project is not permitted anonymous users */
		goto not_in_pdt;			/* don't waste time searching */
	     else temp_person_name = "*";		/* search for "*" in pdt */

	pdtep = null ();				/* flag that we haven't found it yet */

/**** Here we test for a PDT with its damage switched turned on.  If the
      PDT is damaged, we refuse the login with our canned message and
      refuse the login. */

	on condition (seg_fault_error)
	     begin;
	     call sys_log_ (SL_LOG_BEEP, "lg_ctl_: PDT for project ^a has its damage switch set.  Login for user ^a refused.", ute.project, ute.person);
	     mcode = as_error_table_$dialup_error;
	     goto login_abort_1;
	end;

	i = pdt.ht_relp;				/* check for seg_fault_error */

	revert seg_fault_error;

	if pdt.ht_relp > 0 then do;			/* if hash table there, use it */
	     pdt_htp = addrel (pdtp, pdt.ht_relp);
	     if pdt_htp -> htable.id ^= "ht01" & pdt_htp -> htable.id ^= "ht02" then do; /* we gotta check at least a little bit */
		call sys_log_ (SL_LOG_BEEP, "lg_ctl_: no hash table at ^o of ^a.pdt", pdt.ht_relp, project.project_id);
	     end;
	     else do;
		call hash_$search (pdt_htp, temp_person_name, i, code);
		if code ^= 0 then goto not_in_pdt;
		pdtep = addr (pdt.user (i));
		if user.state ^= 1 then do;
		     call sys_log_ (SL_LOG_BEEP, "lg_ctl_: user ^a, state ^d, still in hash table of ^a.pdt",
			temp_person_name, user.state, project.project_id);
		     goto not_in_pdt;
		end;

		if user.person_id ^= temp_person_name then do;
		     call sys_log_ (SL_LOG_BEEP, "lg_ctl_: hash table of ^a.pdt has ^a, pdt has ^a, at ^p",
			project.project_id, temp_person_name, user.person_id, pdtep);
		     pdtep = null ();
		end;
	     end;
	end;

	if pdtep = null then			/* not found in hash table or bad hash table */
	     do i = 1 to pdt.current_size while (pdtep = null ()); /* Scan PDT entries. */
	     pdtep = addr (pdt.user (i));		/* Get ptr to entry. */
	     if user.state = 1 then do;		/* if this is an active PDT entry */
		if user.person_id ^= temp_person_name then /* if user name matches */
		     pdtep = null ();
	     end;
	     else pdtep = null ();
	end;

	if pdtep = null () then
not_in_pdt:    do;
	     mcode = as_error_table_$not_in_pdt;	/* Failed to find (regular/anonymous) entry. */
	     go to login_incorrect;
	end;
	ute.pdtep = pdtep;				/* save ptr to PDT entry, where accounting stuff is */
	ute.uprojp = satep;				/* ... and ptr to SAT entry too */
	return;
     end LOOKUP_PROJECT;
%page;
PROCESS_ATTRIBUTES:
     procedure ();

/* now, on with more mundane affairs */

	string (ute.ur_at) = string (ute.ur_at) &
	     ((string (user.at) & string (project.at)) |
	     USER_ATTRIBUTES_always_allowed);		/* Don't let user clear bits he's not allowed to alter */
	string (ute.at) = string (ute.at) | ^
	     USER_ATTRIBUTES_settable_by_user;		/* Turn on those user cannot turn off */
	string (ute.at) = string (ute.at) |
	     (string (user.at) & USER_ATTRIBUTES_default_in_pdt &
	     ^string (ute.ur_at));			/* turn on defaults if user didn't specify */
	string (ute.at) = string (ute.at) &
	     ((string (user.at) & string (project.at)) |
	     USER_ATTRIBUTES_always_allowed);		/* Turn off any user is not allowed to have */
	bstemp = string (ute.at) &
	     (string (ute.ur_at) | USER_ATTRIBUTES_settable_by_user);
						/* remember those that user set */
	string (ute.at) = string (ute.at) &
	     ^USER_ATTRIBUTES_settable_by_user;		/* turn off any bits that user is allowed to control. */
	string (ute.at) = string (ute.at) | bstemp;	/* turn on those that user or default turned on */

	if ute.at.guaranteed_login then ute.at.nobump = "1"b;

/* The process-saving attributes, disconnect_ok and save_on_disconnect, need special handling.
   After the above logic, each is on in ate.at only if it was on in both sate and pdte.
   First we force both on if both were on in sate. */

	if project.at.save_on_disconnect		/* if on in sate, force it on for all users on project */
	     & project.at.disconnect_ok then		/* (if project also has disconnect_ok), avoiding the need to */
	     ute.at.save_on_disconnect, ute.at.disconnect_ok = "1"b; /* install pdt to turn on saving for whole proj */

/* Then we turn on save_on_disconnect if it was on in the pdte, even if it wasn't on in the sate. */
	if user.at.save_on_disconnect then ute.at.save_on_disconnect = "1"b;

	if ute.anonymous = 1 then			/* if user is anonymous */
	     ute.at.save_on_disconnect, ute.at.disconnect_ok = ""b; /* we can't save his process */


/* Now, we look at the resulting attributes, together with the login arguments, and decide what to do. */

	if process_type = PT_INTERACTIVE then do;	/* only for an interactive process */
	     if ^cdte.nosave_arg then			/* user can always say -nosave, and this needs no permission */
						/* but if he didn't say it */
		if ute.at.disconnect_ok then		/* and he has permission to save disconnected processes */
		     if ute.at.save_on_disconnect	/* and he wants them to be saved by default */
			| cdte.save_arg then	/* or he asked for saving via the login argument */
			ute.uflags.save_if_disconnected = "1"b; /* then save this one if it becomes disconnected */

/* Finally, we abort with an error message if user gave -save argument but lacks permission. */

	     if cdte.save_arg & ^ute.at.disconnect_ok then do;
		mcode = as_error_table_$illegal_save_arg;
		goto login_incorrect;
	     end;
	end;
	return;

     end PROCESS_ATTRIBUTES;
%page;
DETERMINE_AUTHORIZATIONS:
     procedure ();

/**** Here we determine the user process authorization and maximum
      authorization.  We also set the audit flags. */

/* Currently, we only allow anonymous users to log in at system_low
   authorization.  To lift this restriction, all that is necessary
   is to delete the following statement. */

	if ute.anonymous = 1 then
	     ute.process_authorization = ""b;

	ute.process_authorization_range (*) = ""b;

/**** Set the process minimum authorization to the maximum of the following */

	authorization (1) = user.user_authorization (1);
	authorization (2) = project.project_authorization (1);
	if ute.anonymous = 1 then			/* anonymous have no pnte */
	     authorization (3) = project.project_authorization (1);
	else authorization (3) = pnte.person_authorization (1);

	call convert_access_class_$maximum (authorization, 3, ute.process_authorization_range (1));

/**** Set the process maximum authorization to the minimum of the following */

	authorization (1) = user.user_authorization (2);
	authorization (2) = project.project_authorization (2);
	if ute.anonymous = 1 then			/* anonymous have no pnte */
	     authorization (3) = project.project_authorization (2);
	else authorization (3) = pnte.person_authorization (2);

	call convert_access_class_$minimum (authorization, 3, ute.process_authorization_range (2));

/**** Merge the audit flags from the SAT and the PNT.  If the user is
      anonymous, there is no PNT entry and we've already set the ute.audit
      flags to the value in the SAT. */

	if ute.anonymous ^= 1			/* user is not anonymous */
	then ute.audit = merge_access_audit_flags_ (project.audit, pnte.audit);
	else ute.audit = project.audit;		/* anonymous users have no PNT entry */

/* Compare the requested or default authorization with the computed
   authorization range and reject the login if this authorization is
   outside the allowed range. */

	if ^aim_check_$in_range (ute.process_authorization /* requested | default */, ute.process_authorization_range)
	then do;
	     if ute.login_flags.auth_given | process_type = PT_ABSENTEE
	     then mcode = as_error_table_$cant_give_that_authorization;
	     else mcode = as_error_table_$cant_give_dft_auth; /* Cannot login at dft authorization */
	     go to login_incorrect;
	end;
	return;

     end DETERMINE_AUTHORIZATIONS;
%page;
CHECK_PROCESS_LIMITS:
     procedure ();

/* Now, check user's limit on foreground or background processes (whichever this is),
   and the user's max cpu time limit on foreground absentee jobs, if this is one. */

	scan_reason = 0;				/* no need to scan answer table yet */
	if ute.queue <= 0 then do;			/* foreground process */

	     if process_type = PT_ABSENTEE then do;	/* foreground absentee job; check cpu time limit */
		i = project.abs_foreground_cpu_limit;	/* pick up project limit */
		if i = 0 then i = user.abs_foreground_cpu_limit; /* zero means no project limit, so pick up user limit */
		else if user.abs_foreground_cpu_limit > 0 then /* nonzero project limit; if user limit nonzero, */
		     i = min (i, user.abs_foreground_cpu_limit); /* get the smaller of the two */
		if i > 0 then			/* if there is a limit */
		     if ute.max_cpu_time > i then do;	/* if limit too high, job is in error */
			mcode = as_error_table_$user_fg_cpu_limit; /* so reject it */
			goto login_abort_1;		/* 1 means fatal error, don't allow a retry */
		     end;
		if ^ute.at.pm_ok & ^ute.uflags.foreground_secondary_ok then do; /* fg job from no_primary user */
		     mcode = as_error_table_$no_primary;/* explain why */
		     goto login_abort_1;		/* and reject the job */
		end;
	     end;

	     i = project.max_foreground;		/* pick up project limit */
	     if i = 0 then i = user.max_foreground;	/* zero means no project limit, so pick up user limit */
	     else if user.max_foreground > 0 then	/* nonzero project limit; if user limit nonzero, */
		i = min (i, user.max_foreground);	/* get the smaller of the two */
	     if i > 0 then				/* if there is a limit */
		if user.n_foreground ^< i then do;	/* if user is at limit, refuse the login */

/* At this point, we must distinguish between a number of cases:
   1) user has one or more disconnected interactive processes, and doesn't want another one:
   - in this case, we want to go build a list of the disconnected processes and return it to dialup_;
   2) user wants another interactive process, but has one and doesn't have multip:
   - in this case, we go print an "already logged in from..." message, and warn
   - the existing process about the attempt;
   3) user wants another foreground process but is at his foreground limit:
   - in this case, we return the foreground limit error code.
*/

		     if process_type = PT_INTERACTIVE then do;
						/* interactive */
			if user.n_disconnected > 0 & cdte.disconnected_proc_command ^= 2 &
			     cdte.service_type ^= FTP_SERVICE then do; /* case 1 */
			     if ute.active < NOW_LOGGED_IN then do;
						/* if we didn't already do this */
				vlonginfo = convert_message (as_error_table_$n_disconnected_procs_msg);
				if (vlonginfo ^= "") & (^ute.at.brief | cdte.disconnected_proc_command = 0)
				then do;		/* if site hasn't turned off the message, say
						   You have N disconnected processes. */
				     call ioa_$rs (vlonginfo, answer, l, user.n_disconnected, (user.n_disconnected > 1));
				     call astty_$tty_force (cdtep, addr (answer), l, (0));
				end;
			     end;
			     call ASSERT_LOGGED_IN_STATE ();
			     call BUILD_DISCONNECTED_LIST (); /* build list of disconnected processes */
			     call ASSERT_INTERACTIVE_LOGIN (); /* record wherever appropriate that we are logged in */
			     login_state = DISC_STATE (cdte.disconnected_proc_command);
			     goto login_returns;
			end;

			if ^ute.at.multip & user.n_interactive > 0 then do; /* case 2 */
			     scan_reason = 2;	/* find the current process, warn it, and say no to this login */
			     call SCAN_ANSWER_TABLE (scan_reason);
			end;
		     end;				/* end interactive */
		     else do;			/* foreground absentee, case 3 */
			mcode = as_error_table_$user_max_fg;
			user_limit = "1"b;		/* remember to allow deferral and retry, if absentee */
			goto login_abort_2;		/* 2 means nonfatal error, allow retry */
		     end;				/* end foreground absentee, case 3 */
		end;
	end;

	else if ^ute.abs_run then do;			/* background absentee, and not abs run command */
	     i = project.max_background;		/* pick up project limit */
	     if i = 0 then i = user.max_background;	/* zero means no project limit, so pick up user limit */
	     else if user.max_background > 0 then	/* nonzero project limit; if user limit nonzero, */
		i = min (i, user.max_background);	/* get the smaller of the two */
	     if i > 0 then				/* if both were zero, there is no limit at all */
		if user.n_background ^< i then do;	/* if user is at limit, refuse the login */
		     mcode = as_error_table_$user_max_bg;
		     user_limit = "1"b;		/* remember to allow deferral and retry, if absentee */
		     goto login_abort_2;		/* 2 means nonfatal error, allow retry */
		end;
	end;

	return;
     end CHECK_PROCESS_LIMITS;
%page;
SET_UP_FOR_PROCESS_CREATION:
     procedure ();

	login_state = "create";			/* we're going to attempt to create a process */
	call act_ctl_$check (utep, satep, debg, errmsg, mcode); /* check for account's validity  */
	if mcode ^= 0 then do;
	     if process_type ^= PT_ABSENTEE then	/* if not absentee */
		ute.login_result = 2;		/* act_ctl_ threw him out; let user try different project */
	     else ute.login_result = 1;		/* but absentee can't try different project */
	     ute.failure_reason = 2;			/* record this fact here */
	     go to login_returns;
	end;

/**** Set up the initial procedure (initproc) and the subsystem (for
      prelinking) */

	call SETUP_INITIAL_PROCEDURE ();
	call SETUP_SUBSYSTEM ();

	call SETUP_LOGIN_RING ();

	if project.pdir_quota > 0			/* there is a limit */
	then do;
	     if user.pdir_quota > project.pdir_quota then
		call sys_log_ (SL_LOG_SILENT, "lg_ctl_: reduced pdir quota for ^a.^a from ^d (in PDTE) to ^d (in SATE)",
		     ute.person, ute.project, user.pdir_quota, project.pdir_quota);
	     ute.pdir_quota = min (project.pdir_quota, user.pdir_quota); /* constrain */
	end;
	else ute.pdir_quota = user.pdir_quota;		/* no limit, PA can ask for the ceiling! */

	ute.lot_size = user.lot_size;			/* Set up size of process tables */
	ute.kst_size = user.kst_size;			/* ... */
	ute.cls_size = user.cls_size;			/* ... */

/* Determine user's load control weight. */

	ute.user_weight = -1;			/* flags not set yet */

	do i = 1 to sat.uwt_size while (ute.user_weight = -1); /* scan User Weight Table to determine user's weight */
	     if ute.init_proc = sat.uwt (i).initproc then
		ute.user_weight = sat.uwt (i).units;	/* Found initproc. Extract weight. */
	end;

	if ute.user_weight = -1 then
	     ute.user_weight = as_data_$default_weight;	/* Unknown initproc. Assign default weight. */

/* Locate user's home directory, using default homedir and possible -hd login argument */

	if ute.home_dir ^= "" then			/* Specifying home dir. */
	     if ^ute.at.vhomedir then do;		/* he is not allowed */
		mcode = as_error_table_$illegal_hd_arg;
		go to login_incorrect;
	     end;
	     else ;				/* if he is allowed to set it, then nothing to do */
	else ute.home_dir = user.home_dir;		/* use PDT default */

/* User is legal for login. Check if he will overload system. */

	call load_ctl_ (utep, satep, pdtep, pntep, process_type, debg, errmsg, mcode);
	if mcode ^= 0 then
	     go to login_returns;			/* load_ctl_ said no go */
	call ASSERT_LOGGED_IN_STATE ();

	call PUBLISH_LOGIN ();

	ute.uflags.proc_create_ok = "1"b;		/* tell dialup_ that we've set the process creation variables */

	return;
     end SET_UP_FOR_PROCESS_CREATION;
%page;
PUBLISH_LOGIN:
     procedure ();

/* Now inform everybody else he's on */

	whotab.n_users = whotab.n_users + 1;		/* Increase user count in public database */
	whotab.n_units = whotab.n_units + ute.user_weight;/* And total weight. */

	if ute.at.nolist then ute.whotabx = 0;		/* Is this user an "unlisted" user? */
	else do;
	     if whotab.freep = 0 then do;		/* Listed user. Find slot in "whotab" */
		whotab.laste = whotab.laste + 1;	/* Grow whotab a little. */

/* The conversion from version 0 to version 1 of whotab requires that we fib about
   laste.  There are actually laste - laste_adjust entries.  See as_init_. */

		userx = whotab.laste - whotab.laste_adjust; /* no free slots. increase table size */
	     end;
	     else do;				/* have a free slot */
		userx = whotab.freep;		/* Take off chain (LIFO) */
		whotab.freep = whotab.e (userx).chain;	/* .. */
	     end;
	     ute.whotabx = userx;			/* Fill in answer_table slot so's we can delete */

	     if ute.anonymous = 1 then		/* Fill in "whotab" entry. */
		whotab.e (userx).person = "anonymous";	/* Anonymous users get no name. (might be obscene) */
	     else whotab.e (userx).person = ute.person;	/* Name of registered user */
	     whotab.e (userx).project = ute.project;	/* Publish project. */
	     whotab.e (userx).units = ute.user_weight;	/* Weight. */
	     whotab.e (userx).timeon = anstbl.current_time; /* Time of login. */
	     whotab.e (userx).anon = ute.anonymous;	/* Anonymous switch. */
	     whotab.e (userx).stby = ute.standby_line;	/* will be dummy for absentee */
	     whotab.e (userx).active = NOW_LOGGED_IN;	/* state. */
	     whotab.e (userx).idcode = id_code;		/* Set up terminal ID */
	     whotab.e (userx).group = ute.group;	/* Load group. */

	     whotab.e (userx).cant_bump_until = ute.cant_bump_until;
	     whotab.e (userx).proc_type = process_type;	/* 1 = interactive, 2 = absentee, 3 = daemon */

	     whotab.e (userx).process_authorization = ute.process_authorization;
	     whotab.e (userx).fg_abs, whotab.e (userx).disconnected, whotab.e (userx).suspended = ""b;
	end;

	if process_type = PT_DAEMON then		/* Daemon? */
	     whotab.n_daemons = whotab.n_daemons + 1;	/* yup, count him */
	else if process_type = PT_ABSENTEE then do;	/* for absentee process */
	     if ute.queue > 0 then do;		/* if not foreground absentee */
		whotab.abs_users = whotab.abs_users + 1;/* increment count of absentee users */
		if ute.whotabx > 0 then
		     whotab.e (userx).fg_abs = ""b;	/* and be sure foreground flag is cleared */
	     end;
	     else do;				/* but if foreground */
		whotab.fg_abs_users = whotab.fg_abs_users + 1; /* increment count of foreground abs users */
		if ute.whotabx > 0 then
		     whotab.e (userx).fg_abs = "1"b;	/* and set foreground flag for this user */
	     end;
	end;
	else
	     call ASSERT_INTERACTIVE_LOGIN ();
	return;

     end PUBLISH_LOGIN;
%page;
ASSERT_LOGGED_IN_STATE:
     procedure ();

	ute.active = NOW_LOGGED_IN;			/* indicate user is logged in */
	ute.login_time = anstbl.current_time;		/* Record time of login too */
	ute.login_result = 0;			/* Set "login succeeded" flag */
	return;

     end ASSERT_LOGGED_IN_STATE;
%page;
CHECK_CHANNEL_ACCESS_CLASS:
     procedure ();

/**** If we haven't learned an access class from config or from
      hardcore, and the user has given us a password, then we
      can make the multi-class to single-class mapping be using
      the process authorization, which is already known to be
      in the range. Since this procedure is only called in cases
      where we have a name and a password, we can establish the
      access class here. */

	if ^cdte.current_access_class_valid
	then do;					/* we are going to use USER auth as channel acc. */
	     if ^aim_check_$in_range (ute.process_authorization,
		cdte.access_class) then go to MAKE_AIM_CODE; /* we should log this, as well */
	     cdte.current_access_class (*) = ute.process_authorization;
	     cdte.current_access_class_valid = "1"b;
	end;

	else
	     if ^aim_check_$equal (cdte.current_access_class (1), ute.process_authorization)
	then
MAKE_AIM_CODE:
	     do;
	     if ute.login_flags.auth_given | process_type = PT_ABSENTEE
	     then mcode = as_error_table_$cant_give_that_authorization;
	     else mcode = as_error_table_$cant_give_dft_auth; /* Cannot login at dft authorization */
	     go to login_incorrect;
	end;
	return;

     end CHECK_CHANNEL_ACCESS_CLASS;
%page;
SET_OUTER_MODULE:
     procedure ();

	if ute.outer_module ^= " "
	then do;					/* Tried to specify DIM? */
	     if ^ute.at.vinitproc then do;		/* Yes. this may or may not be ok */
		mcode = as_error_table_$illegal_om_arg;
		go to login_incorrect;
	     end;
	end;

/**** If the user legally gave -om we have the om in the ute.  Otherwise
      the ute.outer_module is null.  Now figure out what to do for
      defaults.  First try for something useful in the pdte.  If the pdte
      just says "tty_" we calculate the default based on the line type anyway.
      Pdte (user).outer_module is pretty useless as it can't be cased for
      circumstances */

	if ute.outer_module = "" then do;		/* we need a default */
	     ute.outer_module = user.outer_module;	/* PDT value */
	     if ute.outer_module = ""
		| ute.outer_module = as_data_$tty_dim then do;
		ute.outer_module = as_data_$tty_dim;	/* default */

		if cdte.line_type = LINE_MC
		then ute.outer_module = as_data_$mrd_dim;
		else if cdte.line_type = LINE_G115
		then ute.outer_module = as_data_$g115_dim;
		else if cdte.line_type = LINE_BSC
		then ute.outer_module = "tty_";
		if cdte.line_type = LINE_HASP_OPR
		then ute.outer_module = "hasp_stream_";
	     end;					/* the calculation of om */
	end;					/* we need a default */
	return;

     end SET_OUTER_MODULE;
%page;
SETUP:
     procedure (P_process_type);

dcl  P_process_type fixed bin (17) parameter;

	if as_data_$ansp = null then
	     goto MAIN_RETURN;
	ansp = as_data_$ansp;
	if as_procid ^= anstbl.as_procid then
	     goto MAIN_RETURN;
	utep = P_utep;
	P_code = 0;
	process_type = P_process_type;
	if process_type = PT_INTERACTIVE | process_type = PT_DIAL_SLAVE then
	     cdtep = ute.channel;
	else cdtep = null ();

/**** Set the values of tty_term_type and id_code which are used in
      status and log messages */

	if process_type = PT_ABSENTEE then do;
	     tty_term_type = "Absentee";
	     id_code = "";
	end;
	else if process_type = PT_DAEMON then do;
	     tty_term_type = "Daemon";
	     id_code = ute.tty_id_code;
	end;
	else do;					/* Interactive login or dial/slave */
	     if cdte.cur_line_type >= LINE_UNKNOWN	/* check if we should mention line type name */
	     then tty_term_type = cdte.current_terminal_type; /* for pretty error message */
	     else call ioa_$rsnnl ("^a ^a", tty_term_type, (0), line_types (cdte.cur_line_type),
		     cdte.current_terminal_type);

	     call ttt_info_$encode_type (cdte.current_terminal_type, coded_type, code);
	     if code ^= 0 then
		coded_type = 0;
	     id_code = cdte.tty_id_code;
	end;

	first_pass = "1"b;				/* if this is not, we'll reset later */

/**** anstbl.session_uid_counter is a counter, incremented each time we
      attempt to identify and authenticate a user.  It is used to tie
      together various events which pertain to an authenticated "session". */

	anstbl.session_uid_counter = anstbl.session_uid_counter + 1;
	ute.session_uid = anstbl.session_uid_counter;

/**** Clear out the message buffer used to hold messages produced by
      act_ctl_ and load_ctl_. */

	as_data_$ls_message_buffer_cur_lth = 0;

	return;

     end SETUP;
%page;
CHECK_FOR_SECURITY_BREACH:
     procedure ();

/* Check for possible breach of physical security. This is when a user
   somehow gets access to a terminal whose access class is
   higher than his own authorization. (A person at level_1 should not
   normally have access to terminals used at level_2).
   This is only enabled for those communications lines whose access class
   range reflects a physical security policy.  Note that we only check
   a user's maximum authorization against the terminal's minimum
   access class.  For anonymous users, who have no PNT entry, we assume
   the access authorization of system_low */

dcl  max_auth bit (72) aligned;			/* user's maximum authorization */

	if cdte.flags.audit_access_error then do;	/* If we should check */
	     if ute.anonymous = 1 then
		max_auth = ""b;			/* system_low */
	     else max_auth = pnte.person_authorization (2); /* PNT max */

	     if ^aim_check_$greater_or_equal (max_auth, cdte.access_class (1))
	     then do;
		call SECURITY_BREACH ();
		mcode = as_error_table_$breach;
		go to login_incorrect;
	     end;
	end;
	return;

SECURITY_BREACH:
	procedure ();

/**** This procedure handles a physical security breach.  This is when
      a person has managed to gain access to a terminal of higher
      access_class than his/her maximum authorization.  E.g. someone
      with a SECRET clearance gaining access to a terminal in a TOP
      SECRET area. */

	     call sys_log_ (SL_LOG_BEEP,
		"lg_ctl_: breach of physical security by ^a.^a from ^a (^a terminal ""^a"").",
		ute.person, ute.project, ute.tty_name, tty_term_type, id_code);
	     octal_auth_string = display_access_class_ (max_auth);
	     call convert_access_class_$to_string_short (max_auth, authorization_string, code);
	     if code ^= 0
	     then if code = error_table_$smallarg
		then code = 0;
		else authorization_string = "";

	     call sys_log_ (SL_LOG, "lg_ctl_: person authorization is ^a (^a)", octal_auth_string, authorization_string);
	     octal_auth_string = display_access_class_$range (cdte.access_class);
	     call convert_access_class_$to_string_range_short (cdte.access_class, authorization_string, code);
	     if code ^= 0
	     then if code = error_table_$smallarg	/* ignore this one */
		then code = 0;
		else authorization_string = "";	/* punt */

	     call sys_log_ (SL_LOG, "lg_ctl_: terminal access class is ^a (^a)", octal_auth_string, authorization_string);
	     return;
	end SECURITY_BREACH;

     end CHECK_FOR_SECURITY_BREACH;
%page;
SETUP_INITIAL_PROCEDURE:
     procedure ();

/* User may have given initproc (-po) and/or subsystem (-ss) on login line.
   Project administrator may have specified default values for those variables in the pdt.
   In both cases, the initproc and subsystem names are packed together in a single
   char (64) variable, formerly reserved for initproc alone (because of space problems in the tables).
   Further, user must have the vinitproc attribute in order to give either argument on the login line.
   Finally, if user has given one, and the other is in the pdt, we may discover that they will not
   both fit into a 64 character string, and we have to reject the one from the login line.

   While processing the initproc string, we also replace a trailing ",direct" by a switch setting.

*/

	if ute.uflags.ss_given then			/* if user gave subsystem on login line, copy it, to avoid */
	     char64 = substr (ute.init_proc, ute.ip_len + 1, ute.ss_len); /* clobbering it while setting initproc */

/* Process initproc */

	if ute.uflags.ip_given then do;		/* if user gave initproc on login line */
	     if ^ute.at.vinitproc then do;		/* if he is not allowed to do so */
		mcode = as_error_table_$illegal_ip_arg;
		go to login_incorrect;		/* login refused */
	     end;
	end;

	else do;
	     if user.uflags.ip_given then		/* if new style pdt */
		i = user.ip_len;			/* length of initproc string is stored in it */
	     else do;				/* but of old style, we have to compute it */
		i = -1 + index (user.initial_procedure, " "); /* scan for trailing blank */
		if i = -1 then i = 64;		/* if none, it is 64 chars long */
	     end;

	     substr (ute.init_proc, 1, i) = substr (user.initial_procedure, 1, i);
	     ute.ip_len = i;
	     ute.uflags.dont_call_init_admin = user.uflags.dont_call_init_admin; /* copy the ",direct" switch */
	end;

/* If the initproc string ends in ",direct", strip off the ",direct" and turn on the switch */

	if ute.ip_len >= 8 then			/* if there is room for it */
	     if substr (ute.init_proc, ute.ip_len - 6, 7) = ",direct" then do; /* and its there */
		ute.uflags.dont_call_init_admin = "1"b;
		ute.ip_len = ute.ip_len - 7;
	     end;

	return;
     end SETUP_INITIAL_PROCEDURE;
%page;
SETUP_SUBSYSTEM:
     procedure ();

/**** Process the subsystem argument, used for prelinking */

	if ute.uflags.ss_given then do;
	     if ^ute.at.vinitproc then do;		/* if user not allowed to vary initproc OR subsystem */
		mcode = as_error_table_$illegal_ss_arg;
		go to login_incorrect;
	     end;
	     i = ute.ss_len;
	end;
	else
	     if user.uflags.ss_given then do;
	     i = user.ss_len;
	     char64 = substr (user.initial_procedure, user.ip_len + 1, user.ss_len);
	end;
	else i = -1;

	if i ^= -1 then do;				/* if there is a subsystem from anywhere */
	     if i + ute.ip_len > 64 then do;		/* if sum of lengths toolong, refuse login */
		if ute.uflags.ip_given then do;	/* initproc was from login line */
		     mcode = as_error_table_$long_ip_arg;
		     go to login_incorrect;
		end;				/* then fall back thru here, guaranteed to succeed */
		else do;				/* subsystem was from login line */
		     mcode = as_error_table_$long_ss_arg;
		     goto login_incorrect;
		end;
	     end;

	     else do;
		substr (ute.init_proc, ute.ip_len + 1, i) = substr (char64, 1, i);
		ute.ss_len = i;
		ute.uflags.ss_given = "1"b;
	     end;
	end;
	return;
     end SETUP_SUBSYSTEM;
%page;
SETUP_LOGIN_RING:
     procedure ();

/**** Set up the initial, minimum, and maximum ring information */

/* determine user initial ring */

	if user.low_ring < project.min_ring then
	     call sys_log_ (SL_LOG_SILENT, "lg_ctl_: raised initial ring for ^a.^a from ^d (in PDTE) to ^d (in SATE)",
		ute.person, ute.project, user.low_ring, project.min_ring);

	if ute.initial_ring ^= -1 then do;		/* user specified -ring */
	     i = ute.initial_ring;			/* so use that */
	end;
	else i = user.default_ring;			/* default: -1, 0 or # */

	i = max (project.min_ring,			/* SAT: -1 or # */
	     user.low_ring,				/* PDT: 0 or # */
	     i);					/* -ring or default */

	if i <= 0
	then i = as_data_$dft_user_ring;		/* apply defaults */

	if ute.initial_ring ^= -1			/* if -ring was specified */
	then if ute.initial_ring < i			/* and can't go that low */
	     then do;
		mcode = as_error_table_$ring_too_low;
		go to login_incorrect;
	     end;

	if i > as_data_$max_user_ring then i = as_data_$max_user_ring;
	ute.initial_ring = i;			/* Project may raise */

/* determine user max ring */

	if user.high_ring > project.max_ring then
	     call sys_log_ (SL_LOG_SILENT, "lg_ctl_: lowered max ring for ^a.^a from ^d (in PDTE) to ^d (in SATE)",
		ute.person, ute.project, user.high_ring, project.max_ring);

	if project.max_ring <= 0
	then userx = as_data_$dft_user_ring + 1;
	else userx = project.max_ring;

	userx = min (userx,				/* SAT: 0 or # */
	     user.high_ring,			/* PDT: # */
	     as_data_$max_user_ring);			/* # */

	if userx < ute.initial_ring			/* initial must be less than max */
	then do;
	     mcode = as_error_table_$ring_too_high;
	     go to login_incorrect;
	end;

	ute.highest_ring = userx;			/* Put into answer table. */
	ute.lowest_ring = max (project.min_ring,
	     user.low_ring);			/* Put into answer table also. */
	return;
     end SETUP_LOGIN_RING;
%page;
UPDATE_LOGGED_IN_INFO:
     procedure ();

	if ute.anonymous = 0 then do;			/* Anonymous users don't keep this info */
	     user.last_login_time = anstbl.current_time;	/* Update last login stuff. */
	     user.last_login_unit = cdte.tty_id_code;	/* .. */
	     user.last_login_type = coded_type;		/* .. */
	     user.last_login_line_type = cdte.cur_line_type;
	end;
	return;

     end UPDATE_LOGGED_IN_INFO;
%page;
ASSERT_INTERACTIVE_LOGIN:
     procedure ();

	call NOTIFY_USER_OF_LOGIN ();
	call UPDATE_LOGGED_IN_INFO ();
	return;
     end ASSERT_INTERACTIVE_LOGIN;
%page;
AUDIT_LOGIN:
     procedure (P_success_flag);

dcl  P_success_flag bit (1) aligned parameter;

	if ^P_success_flag then 
	     login_state = debg;
	call as_access_audit_$login (utep, login_state);
	return;
     end AUDIT_LOGIN;
%page;
AUDIT_LOGOUT:
     procedure (P_reason);

dcl  P_reason char (*) parameter;			/* reason for logout */

	if P_reason ^= "" then
	     logout_reason = P_reason;
	else
	     logout_reason = ute.logout_type;		/* kind of logout */
	if logout_reason < "" then
	     logout_reason = "hangup";
	else if logout_reason = "alar" then
	     logout_reason = "autologout";

	call as_access_audit_$logout (utep, logout_reason);

	return;
     end AUDIT_LOGOUT;

/* format: off */
%page; %include absentee_user_table;
%page; %include access_mode_values;
%page; %include answer_table;
%page; %include as_data_;
%page; %include as_data_definitions_;
%page; %include author_dcl;
%page; %include cdt;
%page; %include dialup_values;
%page; %include hashst;
dcl  htp ptr automatic init(null);			/* hastst needs  */
%page; %include installation_parms;
%page; %include line_types;
%page; %include pdt;
%page; %include pnt_entry;
%page; %include sat;
%page; %include sc_stat_;
%page; %include sc_subsystem_info_;
%page; %include send_mail_info;
%page; %include sys_log_constants;
%page; %include ttyp;
%page; %include user_attributes;
%page; %include user_table_entry;
%page; %include user_table_header;
%page; %include whotab;

/* format: on */
%page;
/* BEGIN MESSAGE DOCUMENTATION

   Message:
   lg_ctl_: login word is "QQQQ"

   S:	as (severity1)

   T:	$init

   M:	If multics is typed, a random 4-digit login word
   is made up.

   A:	If any system programmers are to be allowed access to the system
   during this special session, inform them of the login word.  To allow
   normal use of Multics, type "word login".  In order to start the absentee
   facility, which special sessions disable, type "abs start".


   Message:
   lg_ctl_: project.n_users = N for PROJECT (login PERSON)

   S:     as (severity0)

   T:	$run

   M:	The value of project.n_users for project PROJECT went negative
   while attempting to login PERSON.  The user was permitted login but
   there may be discrepancies which may affect future operations.

   A:	$contact_sa


   Message:
   lg_ctl_$logout: called with active=N,{^}proc_create_ok for NAME.PROJ TTY ute MM||NN

   S:	as (severity0)

   T:	$run

   M:	At attempt was made to logout a process which was not logged in.
   This is most likely the cause of a login error in the answering service.

   A:     $contact_sa


   Message:
   lg_ctl_: project.n_users = N for PROJ (logout PERSON)

   S:     as (severity0)

   T:	$run

   M:	The count of the active users on a project went negative when 
   attempting to logout PERSON.  This is most likely the result of a logic 
   error in the answering service or a damaged PDT.

   A:	$contact_sa


   Message:
   lg_ctl_: tracing turned on.

   S:	as (severity1)

   T:	$run

   M:	A system administrator has enabled tracing of the module lg_ctl_.
   Debugging information will appear on the console.

   A:	$ignore


   Message:
   lg_ctl_: tracing turned off.

   S:	as (severity1)

   T:	$run

   M:	A system adminstrator has disabled tracing of the module lg_ctl_.

   A:	$ignore


   Message:
   lg_ctl_: ERROR_MESSAGE.  Error updating PNT entry of USER.

   S:	as (severity2)

   T:	$run

   M:	The system was unable to update the PNT for the user.
   Login for the user was refused.

   A:	$contact_sa


   Message:
   lg_ctl_: ERROR_MESSAGE. Unable to check access for channel CHANNEL.

   S:	as (severity 1)

   T:	$run

   M:	The channel CHANNEL has the check_acs attribute set. However,
   it was not possible to examine the Access Control Segment for the
   reason noted in ERROR_MESSAGE.  Login for the user attempting to use this
   channel was refused.

   A:     $inform_sa


   Message:
   lg_ctl_: TYPE access to channel CHANNEL by NAME.PROJ denied by ACS.

   S:	as (severity 0)

   T:	$run

   M:	The user NAME.PROJ attempted to use the TYPE command while
   dialed-up on channel CHANNEL. However, the access to the channel
   is restricted by Access Control Segment, and the user is not permitted
   to use the channel.

   A:     $ignore


   Message:
   lg_ctl_: too many bad passwords for NAME.PROJ from CHANNEL (TYPE terminal "ID").

   S:	as (severity2)

   T:	$run

   M:	The user identified by NAME on the project PROJ has either forgotten
   his password or someone else is trying to guess it.  The system has refused
   the login for an installation-specified number of times before this message
   is printed.  The maximum number of times the password can be used
   incorrectly before this message is printed is stored in the segment
   installation_parms.

   A:	$contact_sa


   Message:
   lg_ctl_: disconnected count for USER is N1 in cdte, N2 in pdte, n_processes=N3.

   S:     as (severity1)

   T:	$run

   M:	The PDT entry for the user indicates that the user has a different
   number of disconnected processes than could actually be found in the
   answer_table.  The PDT count is forced to the count of disconnected
   processes found in the answer_table. If this message occurs repeatedly
   for a given user, notify the system administrator.

   A:	$ignore


   Message:
   lg_ctl_: ERROR_MESSAGE. Checksum failure reading PNT entry of USER.

   S:	as (severity2)

   T:	$run

   M:	The PNT entry for USER is damaged.  It may have to be recreated,
   or the entire PNT may have to be retrieved in special session.  This
   can occur as a result of a damaged PNT, or due to a logic error in the
   answering service.

   A:	$contact_sa


   Message:
   lg_ctl_: ERROR_MESSAGE. Error reading PNT entry of USER.

   S:	as (severity2)

   T:	$run

   M:	This indicates that the system was unable to access the PNT.
   Login for the user was refused.

   A:	$contact_sa
   Some or all users will be unable to log in.


   Message:
   lg_ctl_: ERROR_MESSAGE. Changing Mail Table default project for USER to PROJ

   S:	as (severity2)

   T:	$run

   M:	USER.PROJ logged in with the -change_default_project control
   argument, but it was not possible to change his Mail Table entry
   for the reason noted in ERROR_MESSAGE.  USER's default project was changed,
   though, but the Mail Table and the PNT are now inconsistent.

   A:	$inform_sa


   Message:
   lg_ctl_: password used PERS.PROJ CHANNEL TERM_TYPE ID

   S:	as (severity2)

   T:	$run

   M:	The system administrator has set a password trap on
   the password for the person PERS.  This message is typed when the
   person tries to log in.  The login was attempted from a TERM_TYPE terminal
   with identification code ID, using channel CHANNEL.

   A:	Unless the system administrator has asked you to watch for
   this message, ignore it.  The system administrator can locate this
   message in the log and is presumably watching for it.


   Message:
   lg_ctl_: sat.ht has "WWWW", SAT has "xxxx" at MM|NN.

   S:	as (severity2)

   T:	$run

   M:	The SAT and its hash table are out of step or a storage system
   error has occurred. This could be the result of an incomplete reload.
   The system attempts to rehash the table and continue.

   A:	$notify_sa


   Message:
   lg_ctl_: ERROR_MESSAGE. unable to rehash sat.ht: REASON

   S:	as (severity2)

   T:	$run

   M:	An attempt to recreate the SAT hash table failed.  The user
   attempting to log in was denied login.  In all probably no users will
   be able to log in until the situation is repaired.

   A:	$contact_sa


   Message:
   lg_ctl_: project PROJ, state N, still in sat.ht

   S:	as (severity2)

   T:	$run

   M:	A user on a deleted project attempted to log in, and the supposedly
   deleted project was still in the SAT hash table. The user is refused login.
   The SAT and its hash table are out of step. The system continues operating.

   A:	$inform


   Message:
   lg_ctl_: ERROR_MESSAGE. >sc1>pdt>PROJ.pdt

   S:	as (severity2)

   T:	$run

   M:	All users on project PROJ are unable to log in because
   the project's pdt cannot be accessed for the reason ERROR_MESSAGE.

   A:	$contact_sa
   If the file was lost due to a crash, it may be possible to retrieve it.
   If the file cannot be retrieved, the person in charge of the project or
   the system administrator has to regenerate the file.


   Message:
   lg_ctl_: project PROJECT has invalid rate_structure number N. Using rate_structure 0.

   S:     as (severity2)

   T:	$run

   M:	The SAT entry for the project has an invalid rate_structure number.
   The user is allowed to log in, but is charged at the default rate (i.e.
   according to rate_structure 0)  Notify the system administrator so that
   the SAT entry may be corrected.  This message will occur for each login
   using project PROJECT.

   A:	$contact_sa


   Message:
   lg_ctl_: PDT for project PROJECTID has its damage switch set.
   Login for user PERSONID refused.

   S:     $as2

   T:	$contact

   M:	During a login attempt of user PERSONID on project PROJECTID,
   the system noticed the damage switch set on the PDT for this project.
   The login was denied.  A system administrator should determine whether
   the PDT is in fact damaged.  If not, he/she should turn off the damage
   switch for the PDT (i.e. switch_off damage >sc1>pdt>PROJECTID.pdt)  If
   the PDT appears damaged, then it should be retrieved from backup tape
   or re-installed when the system is in special session.


   Message:
   lg_ctl_: no hash table at WWWWWW of PROJ.pdt

   S:	as (severity2)

   T:	$run

   M:	A user is logging in to project PROJ. The project's pdt does not
   have a hash table, even though the pdt header says it does. The system
   attempts to log the user in anyway. Possibly the PDT has been damaged.

   A:	$inform


   Message:
   lg_ctl_: user PERSON, state N, still in hash table of PROJ.pdt

   S:	as (severity2)

   T:	$run

   M:	A deleted user attempted to log in to project PROJ, and his name was
   still in the hash table of the project's PDT. The user is refused login.
   The PDT has probably been damaged by a software malfunction.

   A:	$inform


   Message:
   lg_ctl_: hash table of PROJ.pdt has PERS, pdt has PERS2, at MM|NN

   S:	as (severity2)

   T:	$run

   M:	The PDT for PROJ is out of step with its hash table.
   The system attempts to log the user in. The PDT must be re-installed
   in order to correct the problem.

   A:	$contact_sa


   Message:
   lg_ctl_: reduced pdir quota for PERSON.PROJECT from N (in PDTE) to M (in SATE)

   S:     as (severity0)

   T:	$run

   M:	The value for process directory quota specified in the PDT entry
   for PERSON on project PROJECT was greater than the maximum allowed process
   directory quota specified in the SAT entry for PROJECT.  The SAT value
   was used for this login.  The project administrator for the project should
   set the value within the limits imposed by the system administrator.

   A:	$ignore


   Message:
   lg_ctl_: breach of physical security by NAME.PROJ from CHANNEL (TYPE terminal "ID").
   .br
   lg_ctl_: person authorization is AUTH_NUM (AUTH_STRING)
   .br
   lg_ctl_: terminal access class is AUTH_NUM (AUTH_STRING)

   S:	as (severity2)

   T:	$run

   M:	The user identified in the first message by NAME on the project
   PROJ has somehow gotten access to a terminal with an access class higher
   than his own authorization.  The next two messages give additional
   information, where AUTH_NUM is an encoding of the authorization or access
   class in numeric form and AUTH_STRING is the mnemonic form.  The login is
   refused and the terminal is hung up.

   A:	Notify the system security administrator.


   Message:
   lg_ctl_: raised initial ring for PERSON.PROJECT from N (in PDTE) to M (in SATE)

   S:	as (severity0)

   T:	$run

   M:	The value for the initial ring specified in the PDT entry for
   PERSON on project PROJECT was lower than than allowed for the project
   in the SAT.  The value in the SAT was used in logging in this user.
   The project adminstrator should change the value in the PDT to
   conform to the limits imposed by the system adminstrator.

   A:	$ignore


   Message:
   lg_ctl_:  lowered max ring for PERSON.PROJECT from N (in PDTE) to M (in SATE)

   S:	as (severity0)

   T:	$run

   M:	The value for the max ring specified in the PDT entry for PERSON
   on project PROJECT was lower than the maximum allowed ring in the SAT
   for the project.  The SAT value was used for this login.  The project
   administrator should change the PDT value to conform to the limits
   imposed by the system administrator.


   Message:
   LOGIN       PERSON.PROJECT PROC_TYPE CHANNEL (STATE)

   S:	as (severity1)

   T:	$run

   M:	The user PERSON.PROJECT was successfully identified and
   authenticated on channel CHANNEL.  The process type, PROC_TYPE,
   indicates the type of login and can be either "int", "dmn", "opr",
   or "Q N".  These correspond to "interactive", "daemon", "operator",
   or "absentee" logins.  "Q N" designates the absentee queue. STATE
   indicates the state of the login.  It can either be "create", indicating
   that a process was created for the user; "connect loop", indicating that
   the user was queried as to what he/she wanted to do with respect to
   disconnected processes; or some other value indicating what was
   done to the user's disconnected processes.


   Message:
   LOGIN DENIED PERSON.PROJECT PROC_TYPE CHANNEL (REASON)

   S:	as (severity1)

   T:	$run

   M:	An operator login was denied for PERSON.PROJECT on channel CHANNEL
   for the reason specified in REASON.  The process type is opr for
   operator login attempts.


   Message:
   LOGOUT      PERSON.PROJECT PROC_TYPE CHANNEL (REASON)

   S:	as (severity1)

   T:	$run

   M:	The user, PERSON.PROJECT, on channel CHANNEL, with process
   type PROC_TYPE either logged out, or was logged out.  The reason
   is specified in REASON.  This user/channel logout did not
   affect a process.  This can occur for slave dialed channels or
   channels dropped from message coordinator service.

   Message:
   lg_ctl_: PDT for project PROJECTID has its damage switch set.
   Login for user PERSONID refused.

   S:     as (severity2)

   T:	$contact

   M:	During a login attempt of user PERSONID on project PROJECTID,
   the system noticed the damage switch set on the PDT for this project.
   The login was denied.  A system administrator should determine whether
   the PDT is in fact damaged.  If not, he/she should turn off the damage
   switch for the PDT (i.e. switch_off damage >sc1>pdt>PROJECTID.pdt)  If
   the PDT appears damaged, then it should be retrieved from backup tape
   or re-installed when the system is in special session.


   END MESSAGE DOCUMENTATION */


     end lg_ctl_;
