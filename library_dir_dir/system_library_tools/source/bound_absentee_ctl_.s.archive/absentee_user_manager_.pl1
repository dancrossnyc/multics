/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/* format: style4 */
absentee_user_manager_: proc (ev_msg_ptr);

/* main answering service procedure of absentee facility */
/* coded by E. Stone and modified 9/71 */
/* Modified many times since 1971. */
/* Modified April 1976 by T. Casey to check for "initxxxx" process termination event message */
/* Modified 7/76 by THVV to send mail and get rid of gotos and little arrows */
/* Modified September 1977 by T. Casey to log all ignored wakeups and make error message buffer longer. */
/* Modified May 1978 by T. Casey for resource reservations, per-queue reserved slots, and check for lost stopstop wakeup */
/* Modified November 1978 by T. Casey for MR7.0 absentee control parameters */
/* Modified March 1979 by T. Casey for MR7.0a absentee process suspension and trm_ signalling. */
/* Modified March 1980 by Tom Casey to add metering. */
/* Modified December 1980 by E. N. Kittlitz for bugfixes */
/* Modified June 1981 by T. Casey for MR9.0 for absentee load control perf. improvements, and do only one login per wakeup */
/* Modified September 22, 1981 by T. Casey for MR9.0 to fix bug in handling of termstop wakeup. */
/* Modified November 1981, E. N. Kittlitz.  user_table_entry conversion. */
/* Modified December 1981, E. N. Kittlitz.  copy abs control values to whotab. */
/* Modified April 1982, E. N. Kittlitz. New AS initialization. bugfixes. */
/* Modified October 1982, E. N. Kittlitz. Fix cancellation validation, check cancellation by person only */
/* Modified November 1982, E. N. Kittlitz.  Fix validate_user_cancellation null pointer on notify_ca_sender */
/* Modified 1984-07-20 BIM for version 2 UTE */
/* Modified 1984-11-27 by E. Swenson for IPC event channel validation.
   Modified 1985-01-16 by E. Swenson to set ute.tag before calling lg_ctl_.
   Modified 1985-04-19 by E. Swenson to fix any other handler.
*/

/****^  HISTORY COMMENTS:
  1) change(86-05-13,GJohnson), approve(86-05-13,MCR7387),
     audit(86-05-13,Martinson), install(86-05-14,MR12.0-1055):
     Correct error message documentation.
  2) change(86-05-19,Gilcrease), approve(86-05-20,MCR7370),
     audit(86-06-25,Lippard), install(86-06-30,MR12.0-1082):
               Change UTE version, for -truncate absout, SCP6297.
  3) change(86-05-19,Lippard), approve(85-12-30,MCR7326),
     audit(86-10-27,GDixon), install(86-10-28,MR12.0-1200):
     Modified 07 November 1985 (above date to satisfy picky hcom)
     by Jim Lippard to add entry points login_any_absentee and
     cancel_absentee, and remove code for user IPC messages.
  4) change(87-04-26,GDixon), approve(87-07-12,MCR7741),
     audit(87-07-23,Brunelle), install(87-08-04,MR12.1-1055):
      A) Upgraded for change to answer_table.incl.pl1 and
         user_table_entry.incl.pl1.
      B) Note new user-signalled event for the disconnect command (disconn).
         Although the command cannot be used in absentee processes, if the user
         attempts to call terminate_process_ for a disconnection, we will
         instead destroy the process.
      C) Replace calls to lg_ctl_$reset with user_table_mgr_$reset. (dsa 214)
  5) change(87-05-04,GDixon), approve(87-07-12,MCR7741),
     audit(87-07-23,Brunelle), install(87-08-04,MR12.1-1055):
      A) Remove one more call to lg_ctl_$reset.
      B) Avoid setting ute.ute_index; let user_table_mgr_ do this.
      C) Avoid setting ute.active = NOW_FREE; let user_table_mgr_$free do
         this.
  6) change(87-05-10,GDixon), approve(87-07-12,MCR7741),
     audit(87-07-23,Brunelle), install(87-08-04,MR12.1-1055):
      A) Correct absN field in LOGIN/LOGOUT messages.  It should reference
         the ute_index.
  7) change(87-05-11,GDixon), approve(87-07-12,MCR7741),
     audit(87-07-23,Brunelle), install(87-08-04,MR12.1-1055):
      Changes to more properly maintain anstbl.n_abs_run:
       A) Don't set autbl.n_abs_run, since user_table_mgr_ is doing that.
       B) Change any_other strategy to ensure that user_table_mgr_$free always
          gets called when error occurs after user_table_mgr_$allocate.
  8) change(87-05-14,GDixon), approve(87-07-12,MCR7741),
     audit(87-07-23,Brunelle), install(87-08-04,MR12.1-1055):
     Use constants to set ute.tag.
  9) change(87-05-20,Lippard), approve(87-07-12,MCR7709),
     audit(87-07-23,Brunelle), install(87-08-04,MR12.1-1055):
      A) Modified to not attempt to process absentee logins when absentee has
         been stopped.
      B) Don't create ute.event channel, since user_table_mgr_$allocate does
         this.
 10) change(87-07-12,GDixon), approve(87-07-12,MCR7741),
     audit(87-07-23,Brunelle), install(87-08-04,MR12.1-1055):
      A) Remove windows in cleanup handling.
      B) Change cleanup handler to call user_table_mgr_$free to release the
         UTE if an error occurs.
      C) Establish cleanup and any_other handlers at $cancel_absentee,
         $login_any_absentee and $aum_abs_run entrypoints.
      D) Remove call to dial_ctl_$dial_broom, since dpg_ now calls this
         routine.
 11) change(87-08-18,GDixon), approve(87-08-18,MCR7741),
     audit(87-08-19,Brunelle), install(87-08-20,MR12.1-1092):
      A) Changed handler for rlse signal (sent by abs release command) to
         send a wakeup to the suspended absentee process after calling
         asu_$release_suspended_process.  asu_ used to send this wakeup, but
         no longer does due to a change for MNA.
 12) change(87-12-08,GDixon), approve(88-08-15,MCR7969),
     audit(88-08-03,Lippard), install(88-08-29,MR12.2-1093):
      A) Change alarm___ code to handle alarm sent by asu_$bump_user to bump
         an absentee process.  Absentee jobs can be bumped for many reasons
         (eg, locking of the user's password).  asu_$bump_user should work
         for absentee jobs, whatever the reason.  The real reason for bumping
         is in the as log, put there by the caller of asu_$bump_user.
                                                   END HISTORY COMMENTS */

dcl  absentee_rq_chn fixed bin (71) int static,		/* channel used to signal new requests. */
     termstop char (8) aligned int static options (constant) init ("termstop"),
     termstop_msg fixed bin (71) based (addr (termstop)),
     STOPstop char (8) aligned int static options (constant) init ("STOPstop"),
     STOPstop_msg fixed bin (71) based (addr (STOPstop)),
     slack fixed bin int static options (constant) init (2),/* slack to allow 2 interactive processes to get in */
     absentee_procid bit (36) aligned int static,		/* process id of absentee user manager */
     static_label label int static,			/* error transfer */
     trace bit (1) aligned int static init ("0"b);

dcl  unlock_msg int static fixed bin (71);		/* message sent by unlock procedure */
dcl  unlock_string char (8) int static options (constant) init ("unlock"); /* contents of that message */

dcl  abs_stop_before_startup bit (1) aligned int static init (""b);
dcl  job_term_reasons (13) char (64) int static options (constant) init
	("Job terminated.",
	"Job executed new_proc command.",
	"",
	"",
	"",
	"",
	"Process initialization error.",
	"Process could not attach I/O streams.",
	"Process could not locate initial procedure.",
	"Process requested disconnect, which is not allowed.",
	"error.",
	"error.",
	"Job executed new_proc command.");

dcl  common_channel_signals (8) char (4) int static options (constant) init (
	"alar",					/* 1 */
	"inac",					/* 2 */
	"bump",					/* 3 */
	"term",					/* 4 */
	"canc",					/* 5 */
	"caxx",					/* 6 */
	"susp",					/* 7 */
	"rlse");					/* 8 */

dcl  bump_reasons (9) char (64) int static options (constant) init (
	"Job exceeded cpu limit.",
	"Process inactive too long.",
	"Operator bumped job.",
	"Operator terminated process.",
	"Operator canceled job.",
	"Job bumped at user's request.",
	"Process ignored sus_ signal.",
	"Process used too much cpu time while suspended.",
	"System bumped job.");


dcl  (i, j) fixed bin,				/* temp & useful counter */
     code fixed bin (35),				/* error code */
     ignore_code fixed bin (35),			/* cross ref. will show where we deliberately ignore error code */
     ix fixed bin,
     cpu fixed bin (71),
     old_cpu fixed bin (71),
     pp fixed bin,
     pf fixed bin,
     secs float bin,
     aborting bit (1) aligned init ("0"b);		/* set TRUE by ucs handler. */

dcl  cpu_time_limit fixed bin (71);
dcl  absentee_tty_name char (32);
dcl  wakeup_over_common_channel bit (1) aligned init (""b);
dcl  wakeup_from_as bit (1) aligned init (""b);
dcl  wakeup_from_user bit (1) aligned init (""b);
dcl  wakeup_from_ring_zero bit (1) aligned init (""b);
dcl  abs_run_sw bit (1) aligned init (""b);
dcl  abs_arg_ptr ptr init (null);
dcl  (code_mask_ev_calls, code_unmask_ev_calls) fixed bin (35);
dcl  status char (100) aligned,			/* reason for failure to login absentee user */
     reason char (256) varying init ("ERROR"),
     hisid char (32),
     abort_message char (256),
     shxx char (8) aligned,				/* short version of error code. */
     loxx char (100) aligned,				/* long ditto */
     id char (24) int static init ("absentee_user_manager_") options (constant),
     initid char (32) int static init ("absentee_user_manager_$init") options (constant),
     error_message_2 char (36) aligned int static
	init ("Don't bring up absentee facility."),
     error_message_3 char (32) aligned int static
	init ("Error in initializing absentee.");

dcl  ev_msg_ptr ptr;				/* parameter - pointer to entire event message */

dcl  1 ev_msg aligned based (ev_msg_ptr),
       2 ev_chan fixed bin (71),
       2 ev_message bit (72),
       2 from_proc bit (36) aligned,
       2 origin aligned,
         3 dev_signal bit (18) unaligned,
         3 sender_ring bit (18) unaligned,
       2 datap ptr;					/* ptr to AUT entry. */

dcl  1 ev_msg1 aligned based (ev_msg_ptr),
       2 ev_chan fixed bin (71),
       2 signal char (8),
       2 origin,
         3 dev_signal bit (18) unal,
         3 sender_ring bit (18) unal,
       2 datap ptr;

dcl  1 ev_msg2 aligned based (ev_msg_ptr),
       2 ev_chan fixed bin (71),
       2 what char (4),
       2 ix fixed bin (35),
       2 origin,
         3 dev_signal bit (18) unal,
         3 sender_ring bit (18) unal,
       2 datap ptr;


dcl  absentee_user_manager_$absentee_user_manager_ entry;
dcl  absentee_utility_ entry (ptr, ptr, fixed bin (35));
dcl  absentee_utility_$au_send_ctl_wakeup entry;
dcl  absentee_utility_$clear_lc_list entry;
dcl  absentee_utility_$delete_message entry (ptr);
dcl  absentee_utility_$init_au entry (fixed bin (35));
dcl  absentee_utility_$mark_request_running entry (ptr);
dcl  absentee_utility_$set_resource_timer entry;
dcl  absentee_utility_$term_au entry;
dcl  act_ctl_$close_account entry (ptr);
dcl  act_ctl_$cp entry (ptr);
dcl  act_ctl_$dp entry (ptr);
dcl  act_ctl_$open_account entry (ptr);
dcl  as_dump_ entry (char (*) aligned);
dcl  (as_meter_$enter, as_meter_$exit) entry (fixed bin);
dcl  asu_$check_for_stopped_process entry (ptr, char (*)) returns (bit (1) aligned);
dcl  asu_$find_process entry (bit (*) aligned, fixed bin, ptr);
dcl  asu_$release_suspended_process entry (ptr);
dcl  asu_$send_term_signal entry (ptr, fixed bin) returns (bit (1) aligned);
dcl  asu_$start_process entry (ptr);			/* used to start a process running */
dcl  asu_$suspend_process entry (ptr);
dcl  available_slots_ entry (fixed bin, fixed bin, (4) fixed bin, (4) fixed bin) returns (fixed bin);
dcl  clock_ entry returns (fixed bin (71));
dcl  convert_status_code_ entry (fixed bin (35), char (8) aligned, char (100) aligned);
dcl  cpg_$cpg_abs entry (ptr, fixed bin (35));
dcl  dpg_ entry (ptr, char (*));
dcl  dpg_$finish entry (ptr);
dcl  condition_ entry (char (*), entry);
dcl  freen_ entry (ptr);
dcl  get_process_id_ entry (bit (36) aligned);
dcl  hcs_$get_usage_values entry (fixed bin, fixed bin (71), fixed bin);
dcl  hcs_$truncate_seg entry (ptr, fixed bin, fixed bin (35));
dcl  hphcs_$set_cpu_monitor entry (bit (36) aligned, fixed bin (71), fixed bin (35));
dcl  hcs_$wakeup entry (bit (*) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
dcl  ioa_$rsnnl entry options (variable);
dcl  ipc_$create_ev_chn entry (fixed bin (71), fixed bin (35));
dcl  ipc_$decl_ev_call_chn entry (fixed bin (71), entry, ptr, fixed bin, fixed bin (35));
dcl  ipc_$delete_ev_chn entry (fixed bin (71), fixed bin (35));
dcl  ipc_$mask_ev_calls entry (fixed bin (35));
dcl  ipc_$unmask_ev_calls entry (fixed bin (35));
dcl  lg_ctl_$abs_in entry (ptr, char (*) aligned, fixed bin (35));
dcl  lg_ctl_$abs_out entry (ptr);
dcl  lv_request_$cleanup_process entry (bit (36) aligned);
dcl  rcp_sys_$cancel_id entry (fixed bin (71), char (*), fixed bin (35));
dcl  rcp_sys_$pre_claim entry (fixed bin (71), char (*), bit (36) aligned, fixed bin (35));
dcl  rcp_sys_$unassign_process entry (bit (36) aligned, fixed bin (35));
dcl  request_id_ entry (fixed bin (71)) returns (char (19));
dcl  send_mail_$access_class entry (char (*), char (*), ptr, bit (72) aligned, fixed bin (35));
dcl  sub_err_ entry () options (variable);
dcl  sys_log_ entry options (variable);
dcl  sys_log_$error_log entry options (variable);
dcl  timer_manager_$reset_alarm_wakeup entry (fixed bin (71));
dcl  user_table_mgr_$allocate	entry (fixed bin) returns(ptr);
dcl  user_table_mgr_$free entry (ptr);

dcl  as_error_table_$illegal_signal ext fixed bin (35);
dcl  error_table_$messages_deferred ext fixed bin (35);
dcl  error_table_$messages_off ext fixed bin (35);
dcl  error_table_$noentry ext fixed bin (35);
dcl  error_table_$out_of_sequence fixed bin (35) ext;
dcl  sys_info$max_seg_size fixed bin (35) ext static;

dcl  (addr, baseno, divide, fixed, hbound, max, null, rel, rtrim, size, string, substr, unspec) builtin;
%page;
/* MAIN ENTRY POINT absentee_user_manager_: proc (ev_msg_ptr); MAIN ENTRY POINT */


/* Initialize */

	autp = as_data_$autp;
	ansp = as_data_$ansp;
	code_mask_ev_calls, code_unmask_ev_calls = -1;

	utep = null;				/* Cause fault if bug. */
	call condition_ ("cleanup", cleaner_up);

	anstbl.current_time = clock_ ();
	absentee_tty_name = "unknown absentee";		/* never did find the absentee job... */

	if trace then do;
	     call hcs_$get_usage_values (pf, old_cpu, pp);
	end;

	static_label = retr;			/* Set up error exit label. */
	call condition_ ("any_other", ucs);		/* Set up a handler in case of fault. */
	call as_meter_$enter (AUM_METER);

/* Decode the ipc message.
   The interprocess message which invoked absentee_user_manager_ (via event call)
   may come from any of several sources.
   a) login from admin, in answering service, if abs maxu has changed
   b) aum_ctl, which we send ourselves before returning after a login
   c) FUNCxxxx from admin or answering service, requesting action on slot xxxx
   d) others from absentee process, reporting problems logging in, or reporting finish

*/

	if ev_msg.from_proc = absentee_procid then	/* remember if message is from answering service * */
	     wakeup_from_as = "1"b;
	if ev_msg.origin.sender_ring = ""b then		/* and whether from ring zero or outer ring */
	     wakeup_from_ring_zero = "1"b;

/* See if message was sent over common absentee request channel */

	if ev_msg.ev_chan = absentee_rq_chn then do;	/* If message sent over common absentee request channel */
	     wakeup_over_common_channel = "1"b;		/* remember what channel the wakeup came over */
	     if ev_msg1.signal = "login   " then	/* Someone suggests that we check queues for a job to log in */
		goto lg;				/* do so */
						/* not "login" */

	     if ev_msg1.signal = "aum_ctl" then do;	/* we sent ourselves this one */
		if ^wakeup_from_as then goto evil;	/* or did we? If not, complain and exit */
		if ^autbl.aum_ctl then		/* if we did but we don't need it any more */
		     goto retr;			/* exit quickly */

		goto lg;				/* we wanted to see if we could log in any more absentees,
						   but we went blocked to give higher priority work a chance
						   to get done ahead of absentee logins. */
	     end;

	     if ^wakeup_from_as then			/* if wakeup is not from answering service */
		goto evil;			/* then it is illegal */

/* Second word of message is index of aute. Check its validity before using it. */

	     if (ev_msg2.ix <= 0 | ev_msg2.ix > autbl.current_size) then
						/* if index is garbage, decide what complaint to make */
		if wakeup_from_as then goto inval_mess; /* we sent ourselves a bad one. log it for debugging */
		else goto evil;			/* user sent bad one. log to detect playful or malicious users */

	     ix = ev_msg2.ix;			/* Get index of entry */
	     utep = addr (autbl.entry (ix));		/* get address of entry in absentee user table */
	     absentee_tty_name = ute.tty_name;		/* for errors, which absentee channel */

/* First word of message is reason for bumping the job. Check its validity and then take the appropriate action */

	     do i = 1 to hbound (common_channel_signals, 1)
		while (ev_msg2.what ^= common_channel_signals (i)); end;

	     if i > hbound (common_channel_signals, 1) then do; /* if signal unrecognized */
		if wakeup_from_as then goto inval_mess; /* report that we sent ourselves a bad one */
		else goto evil;			/* unknown message from unknown source */
	     end;					/* end message not recognized */

/* Signals from abs suspend and abs release commands get special processing, here. */

	     if i = 7 then do;			/* susp */
		call asu_$suspend_process (utep);
		goto retr;
	     end;
	     if i = 8 then do;			/* rlse */
		call asu_$release_suspended_process (utep);
/**** Now send the process a wakeup over the event channel setup by the
      sus_ signal handler, to kick the process into action again. */
		call hcs_$wakeup (ute.proc_id, ute.sus_channel, (0), code);
		if code ^= 0 then
		     call sys_log_$error_log (SL_LOG_SILENT, code, id,
			"Trying to wakeup ^a.^a.^a process after abs release.",
			ute.person, ute.project, ute.tag);
		goto retr;
	     end;

/* The rest of the signals are various kinds of bumps. They all end up destroying the absentee process */

	     ute.logout_type = ev_msg2.what;		/* brief reason for bumping is first 4 chars of signal */
	     if asu_$send_term_signal (utep, i) then	/* if we send trm_, to give process a chance to clean up */
		goto retr;			/* wait for it to do so. It will send termsgnl when it's done */
	     reason = bump_reasons (i);		/* if we don't send trm_, continue logging it out */
	end;					/* end message sent over common channel */

/* If not common channel, message must have been sent over a running job's event channel */

	else do;					/* message over running job's channel */
	     utep = ev_msg.datap;			/* Extract ptr to AUT entry. */
	     if baseno (utep) ^= baseno (autp) then go to evil; /* WOOPS */

	     if ev_msg.from_proc = ute.proc_id then	/* remember whether wakeup is from absentee user */
		wakeup_from_user = "1"b;

	     ix = ute.ute_index;			/* Will need this for queue threading. */

/* See what the message is. Then either take some special action, or set reason and logout type and destroy the process. */

	     reason = ev_msg1.signal;			/* Default reason */
	     if ute.destroy_flag = WAIT_LOGOUT_SIG & ute.preempted ^= PREEMPT_TERM_SENT then
						/* if brief reason not already set  */
		ute.logout_type = ev_msg2.what;	/* do it now */

/* Scan table of user signals for match with this message. */

	     do i = 1 to n_signals while (ev_msg1.signal ^= signals (i)); end;

/* But before checking for a match, see if it was one of the few system signals,
   such as alarm___, cpulimit, and termstop, that absentee jobs can generate */

	     if ev_msg1.signal = "alarm___" then do;	/* alarm timer - process ignored sus_ or trm_ signal */
		if ^wakeup_from_as then goto evil;	/* alarm___ not valid unless from a.s. */
		if ute.preempted = PREEMPT_TERM_SENT then do;
						/* it was trm_ */
ignored_term:
		     call wakeup_error ("Process ignored trm_ signal.");
		     reason = rtrim (bump_reasons (ute.logout_index));
		     reason = reason || " Process ignored trm_ signal.";
		     goto destroy;
		end;
		else if ute.sus_sent then do;		/* it was sus_ */
ignored_sus:
		     ute.logout_type = "isus";	/* brief reason for bump */
		     reason = bump_reasons (7);	/* long reason */
		     call wakeup_error (reason);	/* tell operator why we're bumping it */
		     if asu_$send_term_signal (utep, 7) then goto retr; /* maybe let it signal finish first */
		     else goto destroy;		/* but if not, bump it now */
		end;
	          else if ute.preempted = PREEMPT_BUMPED	/* asu_$bump_user was called for this proc */
		then do;
		     ute.logout_type = "sbmp";
		     reason = bump_reasons (9);
		     if asu_$send_term_signal (utep, 9) then goto retr;
		     else goto destroy;
		end;
		else do;				/* we were not expecting an alarm___ */
		     call wakeup_error ("Ignoring unexpected alarm___ for"); /* log  it */
		     goto retr;			/* and ignore it */
		end;
	     end;					/* end alarm___ */

	     else if ev_msg1.signal = "cpulimit" then do; /* process used too much cpu time
						   after sus_ or trm_, or while running */
		if ^wakeup_from_ring_zero then goto evil; /* cpulimit can only come from ring zero */
		if ute.ignore_cpulimit then do;	/* cpulimit timer can't be turned off */
		     ute.ignore_cpulimit = ""b;	/* so we turn on this switch when we want to turn it off */
		     goto retr;			/* and if it goes off with the switch on, we ignore it */
		end;
		call reset_alarm;			/* turn off the alarm timer */
		if ute.preempted = PREEMPT_TERM_SENT then
						/* it was trm_ that the process ignored */
		     goto ignored_term;		/* code to handle that condition already exists above */
		else if ute.sus_sent then do;		/* it was sus_ */
		     if ^ute.suspended then		/* if process ignored it completely */
			goto ignored_sus;		/* code to handle that is also found above */
		     ute.logout_type = "csus";	/* brief reason for bump */
		     reason = bump_reasons (8);	/* explain exactly what happened */
		     call wakeup_error (reason);	/* tell operator why we're bumping it */
		     if asu_$send_term_signal (utep, 8) then goto retr; /* maybe let it signal finish */
		     else goto destroy;		/* but if not, bump it now */
		end;
		else do;				/* user-specified cpu time limit ran out */
		     ute.logout_type = "cpul";	/* brief reason for bumping job */
		     if asu_$send_term_signal (utep, 1) /* maybe send trm_ signal and give job a chance to clean up */
						/* 1 is index of "too much cpu time" in reason lists */
		     then goto retr;		/* if signal sent, wait for job to log out */

/* if signal not sent */
		     reason = bump_reasons (1);	/* set reason */
		     goto destroy;			/* and go destroy the process immediately */
		end;
	     end;					/* end cpulimit */

/* Check for termstop wakeup.
   That wakeup means that the original wakeup, giving the reason for the process termination,
   never arrived; a stopstop wakeup arrived out of sequence, and we sent ourselves
   a termstop and a STOPstop to get back in sequence.
   We have no way of knowing what the original reason was. */

	     else if ev_msg1.signal = "termstop" then do;
		ute.logout_type = "tstp";		/* try to say termstop in 4 letters */
		reason = "termstop";
		goto destroy;
	     end;

/* it was not one of the system signals.  See if it's one of the user signals from the table we scanned above. */

	     else if i <= n_signals then do;		/* if it was */
		if ^wakeup_from_user then goto evil;	/* reject it if it's not from the owner of the aute */
		if i = 14 then do;			/* termsgnl gets special processing */
		     if ute.preempted = PREEMPT_TERM_SENT then do;
						/* if we were expecting it */
			call reset_alarm;		/* turn off alarm timer */
			reason = bump_reasons (ute.logout_index); /* get original reason for bump */
			goto destroy;		/* Sorry Edsger, but I'm in a hurry */
		     end;
		     else do;			/* we weren't expecting it */
			call wakeup_error ("Unexpected termsgnl from"); /* log it */
			ev_msg2.ix = as_error_table_$illegal_signal;
			goto convert_term_code;	/* report error and terminate process */
		     end;
		end;				/* end termsgnl */
		else if i <= hbound (job_term_reasons, 1) then reason = job_term_reasons (i);
		else reason = "error.";
	     end;

/* Signal not in table. See if it is fatal process error, with code in second word */

	     else if ev_msg2.what = "term" | ev_msg2.what = "init" then do; /* User process got fatal error. */
		if ^wakeup_from_user then goto evil;	/* reject it if it's not from this user */
convert_term_code:	call convert_status_code_ (ev_msg2.ix, shxx, loxx);
		reason = loxx;
		call sys_log_ (0, "^a: process terminated ^a.^a abs^d ^a", id,
		     ute.person, ute.project, ix, shxx);
	     end;

/* No. Maybe it is stopstop */

	     else if ev_msg1.signal = "stopstop" then reason = ""; /* Process finished dying */
	     else if ev_msg1.signal = "STOPstop" then reason = ""; /* Re-synch wakeup. */

/* It is none of the known ASCII messages. It might be the event channel that a suspended process has gone blocked on. */

	     else if ute.sus_sent & ^ute.suspended then do; /* if waiting for response to sus_ signal, this must be it */
		if ^wakeup_from_user then goto evil;	/* reject it if it's from some other user */
		unspec (ute.sus_channel) = ev_msg.ev_message; /* save the event channel that the process is blocked on */
		if ute.ignore_cpulimit then do;	/* if process was released before it responded to sus_ */
		     ute.sus_sent = ""b;		/* clear the suspended flag */
		     call hcs_$wakeup (ute.proc_id, ute.sus_channel, (0), (0)); /* tell process it may run */
		end;				/* leave the ignore_cpulimit switch on */
		else do;				/* if not released already */
		     ute.suspended = "1"b;		/* remember that it's suspended */
		     call reset_alarm;		/* turn off the alarm timer */
		     goto retr;			/* that's all. get out immediately */
		end;
	     end;

/* None of the above. Log it and reject it. */
	     else go to evil;			/* a hacker */

/* See if we were expecting termsgnl but got something else from the user process.
   (If we had gotten termsgnl, we would have gone directly to destroy, and not ended up here.) */

	     if ute.preempted = PREEMPT_TERM_SENT then do;/* if waiting for termsgnl */
		call reset_alarm;			/* turn off alarm so it won't go off at an awkward time */
		if reason ^= "" then do;		/* reason says why termsgnl didn't come - f.p.e. maybe */
		     reason = rtrim (reason);		/* add some further explanation of what happened */
		     reason = reason || " while handling trm_ signal after: ";
		     reason = reason || rtrim (bump_reasons (ute.logout_index));
		end;
		else do;				/* reason is blank, so construct an explanation */
		     reason = rtrim (bump_reasons (ute.logout_index));
		     reason = reason || " Process did not respond properly to trm_ signal.";
		end;
	     end;

	end;					/* end message over running job's channel */

/* This section destroys an absentee process. Pointer "autp" points to the absentee_user_table entry. */

destroy:
	if ev_msg1.signal ^= "stopstop" then do;	/* First or second pass? */
	     if ev_msg1.signal = "STOPstop" then do;	/* STOPstop is a.s.'s simulation of stopstop */
		if ^wakeup_from_as then goto evil;	/* reject it if not from a.s. */
		else if ute.destroy_flag ^= WAIT_LOGOUT then goto log_ignored_msg;
		else go to kill;			/* STOPstop used to re-synchronize */
	     end;
	     if ev_msg1.signal = "termstop" then
		if ute.destroy_flag ^= WAIT_LOGOUT_SIG then goto log_ignored_msg;
	     if ute.active < NOW_LOGGED_IN then go to evil;

/* Validate origin of wakeup before destroying process */

	     if ^wakeup_from_user then		/* if wakeup not from the absentee process itself */
		if ^wakeup_from_as then		/* and not from answering service */
		     if ^wakeup_from_ring_zero then	/* and not from ring zero */
			goto evil;		/* log and reject the wakeup */


	     if ute.destroy_flag >= WAIT_LOGOUT then	/* if apparently waiting for stopstop */
		if asu_$check_for_stopped_process (utep, id) then /* and process is, in fact, stopped */
		     goto kill;			/* go finish its destruction */

destroy1:						/* come here if fault between creating and starting process */
	     ute.active = NOW_LOGGED_IN;		/* Indicate there is no process. */
	     ute.destroy_flag = WAIT_LOGOUT;		/* .. and set up to finish destroying. */
	     call rcp_sys_$unassign_process (ute.proc_id, ignore_code);
	     if ute.lvs_attached then
		call lv_request_$cleanup_process (ute.proc_id);
	     call dpg_ (utep, (ev_msg2.what));		/* First pass. Request destruction. */

	     if reason ^= "" then do;
		call ioa_$rsnnl ("Absentee job ^a ^a terminated. ^a",
		     abort_message, j, ute.input_seg, request_id_ (ute.request_id), reason);
		call notify_request_owner (abort_message);
	     end;
	     else if ute.notify then			/* if user requested notification */
		call notify ("logged out");		/* tell him the job logged out */
	     go to retr;				/* And that's all for now. We'll wait for the stopstop. */
	end;

/* The process must run a bit to destroy itself. it will send a "stopstop" when it is really dead. */

	if substr (anstbl.sysdir, 1, 4) = ">sys" then	/* Unless testing, ... */
	     if ev_msg.origin.sender_ring then go to evil;/* stopstop must come from ring 0 */

	if ute.destroy_flag = WAIT_LOGOUT_SIG then do;	/* oops. */
	     call sys_log_ (0, "^a: premature stopstop for ^a", id, ute.tty_name);
	     call hcs_$wakeup (whotab.abs_procid, ute.event, termstop_msg, code);
	     call hcs_$wakeup (whotab.abs_procid, ute.event, STOPstop_msg, code);
	     return;
	end;

/* Here we really finish killing the process */

kill:	static_label = no_go;			/* In case of fault. */
	call dpg_$finish (utep);			/* Now finish the process destruct. */
	call act_ctl_$dp (utep);			/* Sign process off accounting. */

	if ute.queue > 0 then			/* track background jobs */
	     autbl.n_abs (ute.queue) = autbl.n_abs (ute.queue) - 1;

cleanup:	ute.active = NOW_LOGGED_IN;			/* Make sure it says "no process" */

	anstbl.lock_count = anstbl.lock_count + 1;	/* lock answer table */
	call act_ctl_$close_account (utep);		/* Close out account */
	call lg_ctl_$abs_out (utep);			/* tell system that absentee user not logged in */
no_go:	static_label = free;			/* If fault here just get out fast */

	if ute.reservation_id ^= 0 then do;		/* if job had a reservation */
	     call rcp_sys_$cancel_id (ute.reservation_id,
		rtrim (ute.person) || "." || rtrim (ute.project) || ".*", code);
	     if code ^= 0 then			/* badcall = reservation doesn't belong to this user */
		if code ^= error_table_$noentry then	/* noentry = no such reservation, i.e., it was canceled already */
		     call sys_log_$error_log (1, code, id, "attempting to cancel reservation ^a for ^a.^a ^a",
			request_id_ (ute.reservation_id), ute.person, ute.project, ute.tty_name);
	end;

	call unlock;				/* unlock answer table */

	if ^(ute.abs_attributes.restartable & ute.logout_type = "bump") then do; /* if not bump of restartable request */
	     call ipc_$mask_ev_calls (code_mask_ev_calls);
	     call absentee_utility_$delete_message (utep);/* delete the request from the queue */
	     if code_mask_ev_calls = 0 & code_unmask_ev_calls ^= 0 then do;
		call ipc_$unmask_ev_calls (code_unmask_ev_calls);
		code_mask_ev_calls, code_unmask_ev_calls = -1;
	     end;
	end;

free:     static_label = retr;
	call user_table_mgr_$free (utep);		/* clear out abs user table entry */

	if aborting then go to retr;			/* If unclaimed signal in progress give up. */

/* Fall through and try to log in another process */

/* But before we do ...
   We just did a logout. So maybe a request on the load control list could log in now.
   So clear the list and give them all a chance to try loging in. */

	if autbl.lc_list then			/* if there is a non-empty list */
	     call absentee_utility_$clear_lc_list;
%page;
/* ------------------------------------------------------- */

/* This section is entered if a user has just queued a job or if admin has signalled that
   it has increased max absentees. We will try to log in an absentee job if possible. */

lg:

	if ^autbl.abs_up | autbl.abs_stopped then	/* don't allow absentee logins if */
	     goto retr;				/*   absentee facility is stopped. */

	if anstbl.n_users > 0 then			/* absentee not to take last APT entry */
	     if (anstbl.n_users + slack) >= anstbl.max_users then do;
		if abs_run_sw then
		     call sys_log_ (-1, "^a (abs run): System too full; no absentee jobs can be started now.", id);
		goto retr;
	     end;

	static_label = lgfail;			/* in case blow in message seg stuff */

	utep = user_table_mgr_$allocate (PT_ABSENTEE);
	if utep = null then go to retr;
	ix = ute.ute_index;

	code = 0;					/* clear error code */

	ute.logout_type = "logi";			/* logout reason, in case of fault while logging in */

call_au:						/* come here when load control says no,
						   to defer request and get another */
						/* NOTE that code contains load control deferral reason */

	if abs_run_sw then				/* if called by abs run command */
	     ute.abs_run = "1"b;			/* tell AU to find and run a particular job */

	call ipc_$mask_ev_calls (code_mask_ev_calls);
						/* if a job is being deferred, code contains the deferral reason -
						   THUS code MIGHT BE AN INPUT VARIABLE HERE - BE CAREFUL */
	call absentee_utility_ (utep, abs_arg_ptr, code); /* get next candidate for absentee process */
	if code_mask_ev_calls = 0 & code_unmask_ev_calls ^= 0 then do;
	     call ipc_$unmask_ev_calls (code_unmask_ev_calls);
	     code_mask_ev_calls, code_unmask_ev_calls = -1;
	end;

	if code ^= 0 then do;			/* if no job can log in now, we'll eventually go blocked */
lgfail:	     static_label = retr;
	     call user_table_mgr_$free (utep);		/* clear abs user table entry */
	     autbl.aum_ctl = ""b;			/* tell everyone that we quit 'cause there's nothing to do */
	     if autbl.lc_list then			/* if there's an lc list */
		call absentee_utility_$clear_lc_list;	/* clear it, so we'll start fresh at next login wakeup */
						/* NOTE: if we only clear it when there's an absentee logout,
						   then foreground jobs waiting for slots to be vacated
						   by interactive logouts could be delayed unnecessarily. */
	     go to retr;
	end;

/* Call user control */

	ute.tty_id_code = "none";
	ute.tag = TAG_ABSENTEE;
	call ioa_$rsnnl ("abs^d", ute.tty_name, i, ix);

	anstbl.lock_count = anstbl.lock_count + 1;	/* lock answer table */

	static_label = cleanup;			/* In case of fault. */
	call as_meter_$enter (ABS_TRYLOG_METER);	/* meter number and cost of login attempts */

	call lg_ctl_$abs_in (utep, status, code);	/* try to login absentee user */
						/* if code is nonzero, it says why job couldn't log in */
	call as_meter_$exit (ABS_TRYLOG_METER);

	if ute.login_result ^= 0 then do;		/* if job cannot be logged in */
	     if ute.args_ptr ^= null then call freen_ (ute.args_ptr); /* first, free its argument storage */
	     if ute.arg_lengths_ptr ^= null then call freen_ (ute.arg_lengths_ptr);

	     if ute.login_result = 2 then do;		/* if it could log in later */
		call unlock;			/* unlock answer table before we forget we had it locked */
		goto call_au;			/* go defer it and get another request */
						/* NOTE that deferral reason is being passed to AU in code */
	     end;
						/* else send user a message and then dispose of the request */
	     call ioa_$rsnnl ("Unable to login job ^a. ^a", abort_message, j, ute.input_seg, status);
	     call notify_request_owner (abort_message);
	     go to no_go;
	end;

/* Fill in absentee user table entry. lg_ctl_ and act_ctl_ will fill in standard part */

	ute.n_processes = 1;			/* constants */
	call ipc_$decl_ev_call_chn (ute.event, absentee_user_manager_$absentee_user_manager_,
	     utep, ABS_LOGIN_PRIO, ignore_code);

	ute.active = NOW_LOGGED_IN;			/* Indicate that slot is in use. */

	call act_ctl_$open_account (utep);		/* open account for absentee user session */
	call cpg_$cpg_abs (utep, code);		/* create absentee process */
	if code ^= 0 then do;			/* Oh, ick */
	     call sys_log_$error_log (1, code, id, "Creating proc for ^a.^a",
		ute.person, ute.project);
	     call convert_status_code_ (code, shxx, loxx);
	     call ioa_$rsnnl ("Unable to create process for job ^a. ^a", abort_message, j, ute.input_seg, loxx);
	     call notify_request_owner (abort_message);
	     go to cleanup;
	end;

	static_label = destroy1;			/* In case of fault, kill process. */
	if ute.queue > 0 then			/* count background jobs */
	     autbl.n_abs (ute.queue) = autbl.n_abs (ute.queue) + 1;

	call act_ctl_$cp (utep);			/* start process accounting */
	ute.active = NOW_HAS_PROCESS;			/* Indicate that there is now a process. */
	ute.destroy_flag = WAIT_LOGOUT_SIG;		/* And that the next thing to happen is logout. */
	call unlock;				/* unlock answer table */

	if ute.args_ptr ^= null then call freen_ (ute.args_ptr); /* Free args .. copied into PIT */
	if ute.arg_lengths_ptr ^= null then call freen_ (ute.arg_lengths_ptr);

	if ute.reservation_id ^= 0 then do;		/* if this job has a reservation */
	     call rcp_sys_$pre_claim (ute.reservation_id, /* tell RCP the process id to which it belongs */
		rtrim (ute.person) || "." || rtrim (ute.project) || ".*", ute.proc_id, code);
	     if code ^= 0 then			/* noentry = no such reservation;
						   badcall = reservation doesn't belong to this user */
		call sys_log_$error_log (1, code, id, "attempting to pre-claim reservation ^a for ^a.^a ^a",
		     request_id_ (ute.reservation_id), ute.person, ute.project, ute.tty_name);
	end;

/* Set cpu monitor to limit the cpu time this process can use. */

	cpu_time_limit = ute.max_cpu_time * 1000000;	/* convert seconds to usec. */
	call hphcs_$set_cpu_monitor (ute.proc_id, cpu_time_limit, ignore_code);

/**** Now kick the process out of its initially blocked state */

	call asu_$start_process (utep);

/* Notify user, if requested, and rewrite job in queue to show that it's running. */

	if ute.notify then				/* if user asked for notification */
	     call notify ("logged in");		/* tell him it logged in */
	call absentee_utility_$mark_request_running (utep); /* do what the name implies */

/* We're all finished logging in one absentee request. There might be others that could log in.
   Instead of trying to log more in now, we'll go blocked and give other answering service work, of higher
   priority (e.g., interactive logins) a chance to get done. But we'll send ourselves a wakeup ("aum_ctl") over
   the login event channel, so that we'll get a chance to run again when there's nothing of higher priority to be done.

   (If we're here because of an operator "abs run" command, we don't bother sending the wakeup.) */

	if ^abs_run_sw then				/* if not abs run command */
	     call absentee_utility_$au_send_ctl_wakeup;	/* then go send the wakeup */

retr:
	static_label = retr1;
	do i = -1 to 4;				/* see if we need to set a resource timer */
	     if autbl.rsc_waiting (i) > 0 then		/* if there are jobs waiting for resources */
		if available_slots_ (max (1, i), autbl.max_abs_users, (autbl.qres), (autbl.n_abs)) > 0 then do;
						/* and there are slots available to them */
		     call absentee_utility_$set_resource_timer; /* check for resource availability periodically */
		     i = 4;			/* get out of the loop */
		end;
	end;

	if code_mask_ev_calls = 0 & code_unmask_ev_calls ^= 0 then
	     call ipc_$unmask_ev_calls (code_unmask_ev_calls); /* event calls should not be masked now; we have no reason to
						   believe they are, but we're just being cautious */

	if trace & ^abs_run_sw then do;
	     static_label = retr1;
	     call hcs_$get_usage_values (pf, cpu, pp);
	     secs = (cpu - old_cpu) * 1e-6;
	     call sys_log_ (1, "^a: Trace ^.3f ^a ^w ^w", id, secs, ev_msg2.what,
		ev_msg2.ix, ev_msg.from_proc);
	end;

retr1:	static_label = return_immediately;
	call as_meter_$exit (AUM_METER);

return_immediately:
	return;

inval_mess: call sys_log_ (1, "^a: Strange event message ^w^w from Initializer", id, ev_msg2.what, ev_msg2.ix);
	go to retr;

evil:	call asu_$find_process (ev_msg.from_proc, i, utep);
	if utep = null then
	     call sys_log_ (1, "^a: Strange event message ^24.3b from user proc ^w",
		id, ev_msg.ev_message, ev_msg.from_proc);
	else
	     call sys_log_ (1, "^a: Strange event message ^24.3b from ^a.^a ^a",
		id, ev_msg.ev_message, ute.person, ute.project, ute.tty_name);
	go to retr;

log_ignored_msg:
	call sys_log_ (0, "^a: ignored wakeup ^24.3b from ^w for ^a",
	     id, ev_msg.ev_message, ev_msg.from_proc, absentee_tty_name);
	goto retr;
%page;
/* ENTRY: cancel_absentee
   This entry point cancels a specified job.  It is called by
   asr_abs_command_server_ after the canceller has already been validated.

   This entry hacks up the information aum_ requires.  In the future, when
   all the IPC garbage has been removed from this module, this can be made
   much cleaner. */

cancel_absentee: entry (P_job_ptr);
dcl  (P_job_ptr) ptr;
dcl  1 hack_event_message aligned like ev_msg;

	autp = as_data_$autp;
	ansp = as_data_$ansp;

	call as_meter_$enter (AUM_METER);

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* Do NOT establish a cleanup on unit here.  Since UTEp is input, we may not */
/* free it if an error occurs.  Also, since what failed is the cancellation  */
/* attempt and the job is still running, we shouldn't free its UTE.	       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	code_mask_ev_calls, code_unmask_ev_calls = -1;
	utep = P_job_ptr;
	call condition_ ("any_other", ucs);
	static_label = retr;			

/* bump_reasons (6) = User bump.  This code will have to change if
   admin_$abs is modified to call this entry point to bump or cancel
   a specific absentee. */
	reason = bump_reasons (6);

/* This is needed solely for the call to dpg_. */
	ev_msg_ptr = addr (hack_event_message);
	ev_msg2.what, ute.logout_type = "canc";
	goto destroy1;
%page;
/* ENTRY POINT to log in any absentee.  It is called by asr_abs_command_server_
   to wakeup AUM to see if a newly-entered job can be run.  It just branches
   to lg. */

login_any_absentee: entry;

	autp = as_data_$autp;
	ansp = as_data_$ansp;
	call as_meter_$enter (AUM_METER);
	utep = null;
	code_mask_ev_calls, code_unmask_ev_calls = -1;
	call condition_ ("cleanup", cleaner_up);
	call condition_ ("any_other", ucs);
	static_label = retr;
	go to lg;
%page;
/* ENTRY POINT to log in a specified job. Called by admin when abs run command is given. */

aum_abs_run: entry (a_arg_ptr);

dcl  a_arg_ptr ptr;					/* ptr to structure describing job to be run */

	autp = as_data_$autp;
	ansp = as_data_$ansp;
	call as_meter_$enter (AUM_METER);
	utep = null;
	static_label = retr;
	code_mask_ev_calls, code_unmask_ev_calls = -1;
	call condition_ ("cleanup", cleaner_up);
	call condition_ ("any_other", ucs);
	abs_run_sw = "1"b;				/* remember where we came in */
	abs_arg_ptr = a_arg_ptr;			/* copy ptr to arg structure */
	goto lg;					/* go get an aute and call AU to get the job from the Q */

%page;
abs_as_init: entry;

/* entry called when system is brought up */

	autp = as_data_$autp;
	ansp = as_data_$ansp;
	code_mask_ev_calls, code_unmask_ev_calls = -1;

	if ^sc_stat_$Multics_typed | sc_stat_$Go_typed then do /* no! */
		code = error_table_$out_of_sequence;
init_error:    call sub_err_ (code, initid, "s");
	     return;
	end;
	call hcs_$truncate_seg (autp, 0, code);		/* truncate absentee user table */
	if code ^= 0 then do;
	     call sys_log_$error_log (1, code, initid, "Cannot truncate absentee_user_table.");
	     go to init_error;
	end;
	autbl.mnbz = "1"b;				/* cause records used > 0 */
						/* now those having r access can read header */
	autbl.header_version = AUTBL_version_4;		/* set up some other bumf */
	autbl.entry_version = UTE_version_4;
	autbl.user_table_type = PT_ABSENTEE;		/* absentee table */
	autbl.header_length = fixed (rel (addr (autbl.entry (1))));
	autbl.max_size = divide (sys_info$max_seg_size - autbl.header_length, size (ute), 17, 0);
	autbl.number_free, autbl.first_free = 0;

	if abs_stop_before_startup then		/* abs stop command given before startup */
	     autbl.abs_stopped = "1"b;		/* this means don't start absentee */
	call update_whotab_abs_copy;			/* just like it says */
	return;

%page;
init_aum: entry (a_code);

dcl  a_code fixed bin (35);

/* entry called when absentee facility is brought up */

	autp = as_data_$autp;
	ansp = as_data_$ansp;
	code_mask_ev_calls, code_unmask_ev_calls = -1;

	unspec (unlock_msg) = unspec (unlock_string);	/* initialize message sent by unlock procedure */
	call ipc_$create_ev_chn (absentee_rq_chn, a_code);/* Create event channels. */
	if a_code ^= 0 then go to chn_error;

	call ipc_$decl_ev_call_chn (absentee_rq_chn, absentee_user_manager_$absentee_user_manager_,
	     (null), ABS_LOGIN_PRIO, a_code);
	if a_code ^= 0 then do;
chn_error:     call sys_log_$error_log (2, a_code, id, "Cannot create absentee event channel.");
	     return;
	end;

	call get_process_id_ (absentee_procid);		/* get process id of absentee user manager */
	autbl.as_procid = absentee_procid;		/* copy process id into absentee_user_table */
	whotab.abs_procid = absentee_procid;		/* copy process id and event channel into whotable */
	whotab.abs_event = absentee_rq_chn;		/* so that ear can send wakeup to absentee */

	call absentee_utility_$init_au (a_code);
						/* initialize utility which handles message segment */
	if a_code ^= 0 then do;
	     call sys_log_ (1, "^a: ^a ^a", id, error_message_2, error_message_3);
	     return;
	end;
	call update_whotab_abs_copy;

	return;
%page;
term_aum: entry;

/* entry call when absentee facility is shutdown */

	autp = as_data_$autp;
	ansp = as_data_$ansp;
	code_mask_ev_calls, code_unmask_ev_calls = -1;

	if ^sc_stat_$Go_typed then do;		/* abs stop command given before startup */
	     abs_stop_before_startup = "1"b;		/* remember this in int static since startup truncates AUTBL */
	     return;
	end;

	call ipc_$delete_ev_chn (absentee_rq_chn, code);

	whotab.abs_procid = (36)"0"b;
	whotab.abs_event = 0;

	call absentee_utility_$term_au;
	call update_whotab_abs_copy;

	return;

aum_trace: entry;

	trace = "1"b;

	return;

aum_no_trace: entry;

	trace = "0"b;

	return;

update_whotab_abs_control: entry;

	autp = as_data_$autp;
	ansp = as_data_$ansp;
	call update_whotab_abs_copy;			/* call internal procedure to do work */
	return;
%page;
/* INTERNAL PROCEDURES, IN ALPHABETIC ORDER */

cleaner_up: proc;
	if utep = null then return;
	call user_table_mgr_$free (utep);
     end cleaner_up;
%page;
notify: proc (message);				/* user said ear -notify, so do so */

dcl  message char (*);

	call ioa_$rsnnl ("Absentee job ^a ^a ^a.",
	     abort_message, j, ute.input_seg, request_id_ (ute.request_id), message);
	call notify_request_owner (abort_message);
	return;

     end notify;
%page;
notify_request_owner: proc (message);			/* send message to owner of absentee request in aute */

dcl  message char (*);

	if ute.proxy then
	     call ioa_$rsnnl ("^a.^a", hisid, (0), ute.proxy_person, ute.proxy_project);
	else call ioa_$rsnnl ("^a.^a", hisid, (0), ute.person, ute.project);
	call send_mail (hisid, ute.process_authorization, rtrim (message));
	return;

     end notify_request_owner;
%page;
reset_alarm: proc;

	call timer_manager_$reset_alarm_wakeup (ute.event);
	return;

     end reset_alarm;
%page;
send_mail: proc (user_id, auth, message);

dcl  user_id char (32);
dcl  auth bit (72) aligned;
dcl  message char (*);

	unspec (send_mail_info) = "0"b;
	send_mail_info.version = 1;
	send_mail_info.wakeup = "1"b;
	send_mail_info.always_add = "1"b;
	send_mail_info.sent_from = "absentee";

	call send_mail_$access_class (user_id, message, addr (send_mail_info), auth, code);
	if code ^= 0
	     & code ^= error_table_$messages_deferred
	     & code ^= error_table_$messages_off then
	     call sys_log_$error_log (0, code, id, "Unable to notify user ^a of absentee event", user_id);
	return;

     end send_mail;
%page;
ucs: proc (mcptr, condname, coptr, infoptr, continue);

dcl  mcptr ptr parameter;
dcl  condname char (*) parameter;
dcl  coptr ptr parameter;
dcl  infoptr ptr parameter;
dcl  continue bit (1) parameter;
dcl  mbuf char (256) aligned;
dcl  mlth fixed bin;
dcl  non_local_exit bit (1);
dcl  as_check_condition_ entry (char (*), bit (1), bit (1));

	call as_check_condition_ (condname, continue, non_local_exit);
	if continue | non_local_exit then
	     return;

	call ioa_$rsnnl ("^a: Error: ^a", mbuf, mlth, id, condname);
	call sys_log_ (2, "^a", mbuf);
	call as_dump_ (mbuf);

	aborting = "1"b;				/* don't try to log any more guys in */
	go to static_label;

     end ucs;
%page;
unlock: procedure;

/* internal procedure to unlock answer table lock */
/* copied from dialup_ */

dcl  code fixed bin (35);
	anstbl.lock_count = anstbl.lock_count - 1;
	if anstbl.lock_count < 0 then anstbl.lock_count = 0;
	if anstbl.lock_count = 0 then
	     if code_mask_ev_calls = 0 & code_unmask_ev_calls ^= 0 then
		call ipc_$unmask_ev_calls (code_unmask_ev_calls);

	if anstbl.lock_count = 0 then if anstbl.update_pending = "1"b then
		do;
		anstbl.update_pending = "0"b;
		call hcs_$wakeup (anstbl.as_procid, anstbl.update_channel, unlock_msg, code);
	     end;

     end unlock;
%page;
update_whotab_abs_copy: proc;

/* procedure called when something in absentee_user_table has changed that should
   be reflected in the whotab published copy. */

	if whoptr = null then return;			/* cover our posterior */
	if autp = null then return;			/* ditto */
	whotab.n_abs (*) = autbl.n_abs (*);		/* number in each queue */
	whotab.abs_qres (*) = autbl.qres (*);		/* background queue information */
	whotab.abs_cpu_limit (*) = autbl.cpu_limit (*);	/* auto or operator set cpu max */
	string (whotab.abs_control) = string (autbl.control); /* little bitties */
	return;					/* all done */
     end;
%page;
wakeup_error: proc (msg);

dcl  msg char (*) varying;

	call sys_log_ (0, "^a: ^a ^a.^a ^a", id, msg, ute.person, ute.project, ute.tty_name);
	return;

     end wakeup_error;
%page; %include absentee_user_table;
%page; %include answer_table;
%page; %include as_data_;
%page; %include as_data_definitions_;
%page; %include as_meter_numbers;
%page; %include as_wakeup_priorities;
%page; %include dialup_values;
%page; %include installation_parms;
%page; %include sc_stat_;
%page; %include send_mail_info;
%page; %include sys_log_constants;
%page; %include user_attributes;
%page; %include user_table_entry;
%page; %include user_table_header;
%page; %include whotab;
%page;
/* BEGIN MESSAGE DOCUMENTATION

   Message:
   absentee_user_manager_$init: MESSAGE. Cannot truncate absentee_user_table.

   S:	as (severity1)

   T:	$init

   M:	It was not possible to clear the absentee_user_table segment.

   A:	$contact


   Message:
   absentee_user_manager_: ERROR_MESSAGE.  Trying to wakeup PERSON.PROJECT.TAG
   process after abs release.

   S:	$as0

   T:	Called in response to an operator abs release command.

   M:	A failure occurred while sending a wakeup to the absentee process 
   being released.  ERROR_MESSAGE is the text associated with the
   error code returned by hcs_$wakeup.

   A:	$ignore


   Message:
   absentee_user_manager_: event calls were masked.

   S:	sc (user_output)

   T:	$run

   M:	This message indicates a serious error in the Initializer
   programs.  The system attempts to recover and keep running.

   A:	$notify


   Message:
   absentee_user_manager_: Error in initializing absentee.  Don't bring up absentee facility

   S:	as (severity1)

   T:	$run

   M:	The absentee mechanism will not initialize.

   A:	$inform
   Do _n_o_t try to
   initialize the absentee facility.


   Message:
   absentee_user_manager_: Error: CONDITION

   S:	as (severity2)

   T:	$run

   M:	An unexpected fault has occurred while performing some
   absentee function such as logging in a new absentee user.  The
   system automatically performs an Answering Service dump and
   attempts to recover.

   A:	No action is required unless the condition persists.
   If this message occurs repeatedly, try stopping the absentee
   facility; inform the programming staff.


   Message:
   absentee_user_manager_: ERROR_MESSAGE.  Cannot create absentee event channel

   S:	as (severity2)

   T:	$init

   M:	The absentee facility could not create part of its
   communications mechanism.  No absentee process can be logged in.

   A:	Try the abs start command again.  If the absentee
   facility still fails, inform the programming staff.


   Message:
   absentee_user_manager_: ERROR_MESSAGE.  Creating proc for NAME.PROJ

   S:	as (severity2)

   T:	$run

   M:	A storage system error prevented the absentee user from
   logging in.  This is due to some error in the process
   creating mechanism.  The user is not logged in.

   A:	$inform
   Shut down the
   absentee facility with an abs bump * * and an abs stop
   if this message occurs repeatedly.


   Message:
   absentee_user_manager_: Premature stopstop for ID

   S:	as (severity0)

   T:	$run

   M:	An error has occurred while trying to destroy the absentee process ID.  The system recovers and continues.

   A:	$ignore


   Message:
   absentee_user_manager_: Process terminated USER.PROJ ID MESSAGE.

   S:	as (severity0)

   T:	$run

   M:	The absentee process ID of USER.PROJ has terminated for the reason specified, and will be logged out.

   A:	$ignore


   Message:
   absentee_user_manager_: Strange event message WWWWWWWWWWWW WWWWWWWWWWWW from Initializer

   S:	as (severity1)

   T:	$run

   M:	An unrecognizable event message has been received from
   the Answering Service.  Its value is printed in octal.
   Usually, the first word is the function code and the second
   word is the index in the absentee user table.  This condition is
   due to a error in the Answering Service or absentee programs.  The
   system ignores the signal and goes on.  The absentee facility may
   cease to operate.

   A:	If absentee jobs will no longer run, try an abs stop
   and an abs start.  Inform the system programming staff.


   Message:
   absentee_user_manager_: Strange event message  WWWWWWWWWWWW  WWWWWWWWWWWW  from user proc WWWWWWWWWWWW

   S:	as (severity1)

   T:	$run

   M:	This message is similar to the preceding message described
   above, except that the signal does not come from the Initializer but
   from some other process.  The process ID of the sending process is printed
   in octal.  The event message was not a valid item.  The system ignores
   the signal and goes on.

   A:	If absentee jobs will no longer run, try an abs stop and an abs start.
   Inform the system programming staff.


   Message:
   absentee_user_manager_: Strange event message WWWWWWWWWWWW WWWWWWWWWWWW from NAME.PROJ TTY

   S:	as (severity1)

   T:	$run

   M:	This message is similar to the preceding message, except that the name, project, and tty name of the user sending
   the wakeup are printed.  The system ignores the signal and goes on.

   A:	$ignore


   Message:
   absentee_user_manager_: Trace ....

   S:	as (severity1)

   T:	$run

   M:	This is trace output.  It begins coming out about every
   five minutes after absentee_user_manager_$aum_trace_on is called.

   A:	$ignore
   To shut this message off, type: absentee_user_manager_$aum_trace_off
   while in admin mode.


   Message:
   absentee_user_manager_: ERROR attempting to cancel reservation R for USER.PROJ absN

   S:	as (severity1)

   T:	$run

   M:	The system was unable to cancel a resource reservation for an
   absentee process that is being destroyed. The resource(s) might remain
   unavailable to other users. There is some problem in the resource reservation mechanism.

   A:	$inform


   Message:
   absentee_user_manager_: ERROR attempting to pre-claim reservation R for USER.PROJ absN

   S:	as (severity1)

   T:	$run

   M:	The system was unable to assign a resource reservation to an
   absentee job that is being logged in. The job will be run, but it
   might fail if the resources it needs happen to be unavailable when it
   requests them. There is some problem in the resource reservation mechanism.

   A:	$inform


   Message:
   absentee_user_manager_ (abs run): System too full; no absentee jobs can be started now.

   S:	as (severity1)

   T:	In response to an abs run command.

   M:	The system is too near the upper limit on logged in users to start any absentee jobs.

   A:	If the immediate running of the job is essential, use "abs stop queue all"
   to halt all other absentee logins, change the login word to halt all interactive logins,
   and either wait for a process to log out, or bump one, before repeating the abs run command.


   END MESSAGE DOCUMENTATION */

     end absentee_user_manager_;
