/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1992   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/* format: style2 */
up_cdt_:
     procedure (user_cdtp, wordcount, instaldir, instalname, instalp, ansp, ip, answer, code);

/* UP_CDT_ - update the Channel Definition Table (CDT)

   This program checks a candidate CDT for acceptability before installing.
   THVV Aug 75
   Modified 751024 by PG to check terminal access_class vs. authorization,
   not max_authorization, to fix bug in bumping innocent users.
   Modified 760603 by Roy P. Planalp to recognize and attach channels of
   service_type FTP
   Modified 760826 by Mike Grady to update version 2 CDTs
   Modified November 1976 by T. Casey to fix bug in changing terminal access class.
   Modified June 1977 by Robert Coren to use terminal type names instead of numbers and to
   .		   check that specified terminal types are in TTT.
   Modified September 1977 by T. Casey to make channel deletions reversible during the same bootload, and fix bugs.
   Modified January 1978 by T. Casey to fix bug in previous modification.
   Modified February 1978 by G. Dixon to fix bug in Sept 77 modification.
   Modified Fall 1978 by Larry Johnson for ring-0 demultiplexing.
   Modified April 1979 by Larry Johnson for fnpe changes.
   Modified January 1981 by E. N. Kittlitz to eliminate CDTE.phone_no.
   Modified November 1981, E. N. Kittlitz.  user_table_entry conversion.
   Modified December 1981, Benson I. Margulies. trees in the cdts.
   Modified February 1982, E. N. Kittlitz. xxx.install.acs conversion.
   Modified July 1982, BIM, fixes to tree stuff.
   Modified July 1982, E. N. Kittlitz. to not listen to masked channel.
   Modified October 1982, E. N. Kittlitz. change some sys_log_ severities.
   Modified 84-03-26 BIM for version 5 cdt, aim ranges.
   Modified 1984-08-07 BIM to initialize mpxe fields for new multiplexers.
   Modified:
   10/05/84 by R. Michael Tague:  up_sysctl_$check_acs now returns a bit (36)
   mode string instead of a fixed bin (5) and no longer takes a directoy arg.
*/


/****^  HISTORY COMMENTS:
  1) change(87-04-28,GDixon), approve(87-07-13,MCR7741),
     audit(87-07-15,Hartogs), install(87-08-04,MR12.1-1055):
     Updated for change to user_table_entry.incl.pl1.
  2) change(92-10-14,Schroth), approve(92-10-14,MCR8264),
     audit(92-10-15,Zimmerman), install(92-10-21,MR12.5-1036):
     Correct several potential null pointer faults when attempting to install a
     new CDT.
                                                   END HISTORY COMMENTS */


/* parameters */

	dcl     (user_cdtp, instalp, ansp, ip)
				 ptr,
	        wordcount		 fixed bin;
	dcl     code		 fixed bin (35) parameter;
	dcl     instaldir		 char (*),
	        instalname		 char (*),
	        answer		 char (*);

/* entries */

	dcl     aim_check_$equal	 entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
	dcl     aim_check_$greater_or_equal
				 entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
	dcl     aim_check_$in_range	 entry (bit (72) aligned, (2) bit (72) aligned) returns (bit (1) aligned);
	dcl     astty_$tty_order	 entry (ptr, char (*), ptr, fixed bin (35));
	dcl     asu_$asu_listen	 entry (ptr, fixed bin (35));
	dcl     cdt_mgr_$find_cdt_channel
				 entry (ptr, char (32), fixed bin, bit (1) aligned, fixed bin (35));
	dcl     cdt_mgr_$thread	 entry (ptr, fixed bin (35));
	dcl     cdt_mgr_$thread_out_cdt_channel
				 entry (ptr, fixed bin);
	dcl     cdt_mgr_$thread_in_cdt_channel
				 entry (ptr, fixed bin);
	dcl     display_access_class_	 entry (bit (72) aligned) returns (character (32) aligned);
	dcl     display_access_class_$range
				 entry ((2) bit (72) aligned) returns (character (32) aligned);

	dcl     find_condition_info_	 entry (ptr, ptr, fixed bin (35));
	dcl     (get_temp_segment_, release_temp_segment_)
				 entry (char (*), ptr, fixed bin (35));
	dcl     hcs_$delentry_seg	 entry (ptr, fixed bin (35));
	dcl     hcs_$set_safety_sw	 entry (char (*), char (*), bit (1) aligned, fixed bin (35));
						/* SWS */
	dcl     hcs_$set_bc		 entry (char (*), char (*), fixed bin (24), fixed bin (35));
	dcl     hcs_$terminate_noname	 entry (ptr, fixed bin (35));
	dcl     cu_$level_get	 entry (fixed bin);
	dcl     sys_log_		 entry options (variable);
	dcl     sys_log_$error_log	 entry options (variable);
	dcl     ttt_info_$terminal_data
				 entry (character (*), fixed binary, fixed binary, pointer, fixed binary (35));
	dcl     asu_$attach_channel	 entry (ptr, fixed bin (35));
	dcl     asu_$bump_code	 entry (ptr, fixed bin (35), char (8), fixed bin (35), fixed bin);
	dcl     asu_$write_chn_message entry (ptr, fixed bin (35), char (8), fixed bin (35));
	dcl     asu_$asu_remove	 entry (ptr);
	dcl     hcs_$initiate	 entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr,
				 fixed bin (35));	/*	dcl     ttt_info_$terminal_data
/*				 entry (char (*), fixed bin, fixed bin, ptr, fixed bin (35));
*/
	dcl     up_sysctl_$check_acs	 entry (char (*), char (*), fixed bin, bit (36) aligned, fixed bin (35));

/* external static */

	dcl     sc_stat_$sysdir	 character (168) unaligned external;
	dcl     as_error_table_$chn_auth_excludes
				 fixed bin (35) external static;
	dcl     as_error_table_$chn_deleted
				 fixed bin (35) external static;
	dcl     as_error_table_$chn_svc_changed
				 fixed bin (35) external static;
	dcl     error_table_$action_not_performed
				 fixed bin (35) external static;

/* automatic */

	dcl     (auth_string, old_auth_string)
				 char (32) aligned;
	dcl     (line_type, service_type)
				 fixed bin;
	dcl     system_high		 bit (72) aligned;

	dcl     fnp_sw		 bit (1) aligned;
	dcl     (i, cdtx)		 fixed bin;
	dcl     movelen		 fixed bin (24);
	dcl     mode		 bit (36) aligned;
	dcl     ring		 fixed bin;
	dcl     debg		 char (8);
	dcl     offset		 fixed bin (18);
	dcl     (p, q, old_cdtp, new_cdtp)
				 ptr;
	dcl     retry_count		 fixed bin;

/* internal static */

	dcl     acs_name		 char (32) int static options (constant) init ("cdt.install.acs");

	dcl     (
	        LEGAL		 char (95)
				 init
				 /* Printables except PAD, semicolon, but with BS */ (
				 " !""#$%&'()*+,-./0123456789:<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
				 ),
	        REMOVE_THIS_CHANNEL	 fixed bin initial (100),
						/* this channel is being removed from service */
	        ATTACH_THIS_CHANNEL	 fixed bin initial (200),
						/* this channel is being added */
	        LISTEN_TO_THIS_CHANNEL fixed bin initial (300),
						/* this channel existed before, but line type was changed */
	        DELETE_THIS_CHANNEL	 fixed bin initial (400),
						/* this channel being deleted */
	        UNDELETE_THIS_CHANNEL	 fixed bin initial (500)
						/* deleted channel being added back */
	        )			 internal static options (constant);

/* based */

	dcl     1 movetable		 based aligned,
		2 moveary		 (movelen) bit (36) aligned;

	dcl     1 CDT		 aligned like cdt based;
						/* No dangerous implicit qualification */
	dcl     1 CDTE		 aligned like cdte based;
	dcl     1 FNPE		 aligned like fnpe based;

/* Condition */

	dcl     sub_error_		 condition;

/* builtin */

	dcl     (addr, clock, hbound, null, size, string, verify, unspec, wordno)
				 builtin;
%page;
/* ============================================ */


/* There are three copies of the CDT referenced in this procedure. All references are by explicit use of pointers:
   user_cdtp points to the supplied CDT (the one that was given to us to be installed);
   old_cdtp points to the old CDT (>sc1>cdt);
   new_cdtp points to the temporary segment in which we will build a new CDT by merging the supplied one with the current one;
   p and q point to CDT entries. They are used for different purposes in various parts of the program. */

/* Check the validity of the supplied CDT and the access permissions of the installer. */

	retry_count = 0;

RETRY_INSTALLATION:
	cdtp = null;				/* TAKE A FAULT IF WE FORGET TO QUALIFY */
	cdtep = null;
	fnpep = null;
	mpxep = null;
	new_cdtp = null;
	old_cdtp = null;

	system_high = installation_parms.access_authorization_ceiling;
	call cu_$level_get (ring);

	answer = "";
	instalp = null;				/* pre-set returned pointer */
	instaldir = sc_stat_$sysdir;			/* used to be anstbl */
	instalname = "cdt";
	if wordcount < 64
	then do;					/* make sure segment contains something */
		answer = "wordcount < 64";
		code = error_table_$action_not_performed;
		go to RETURN;
	     end;
	if user_cdtp -> CDT.version ^= CDT_version
	then do;					/* Check right overlay dcl */
		answer = "incorrect table version";
		code = error_table_$action_not_performed;
		go to RETURN;
	     end;
	if user_cdtp -> CDT.current_size > user_cdtp -> CDT.max_size
	then do;
		answer = "current_size > max_size";
		code = error_table_$action_not_performed;
		go to RETURN;
	     end;
	if user_cdtp -> CDT.n_cdtes > user_cdtp -> CDT.current_size
	then do;
		answer = "n_cdtes > current_size";
		code = error_table_$action_not_performed;
		go to RETURN;
	     end;
	offset = wordno (addr (user_cdtp -> cdt.cdt_entry (1))) + (size (cdte) * user_cdtp -> cdt.current_size);
	if offset ^= wordcount
	then do;
		answer = "size inconsistent with wordcount";
		code = error_table_$action_not_performed;
		go to RETURN;
	     end;
	call up_sysctl_$check_acs (acs_name, (user_cdtp -> CDT.author.proc_group_id), ring, mode, code);
	if (code ^= 0) | ((mode & RW_ACCESS) ^= RW_ACCESS)
	then do;
		answer = "access violation";
		code = error_table_$action_not_performed;
		go to RETURN;
	     end;

	call hcs_$initiate (instaldir, instalname, "", 0, 0, old_cdtp, code);
	if old_cdtp = null
	then do;
		answer = "cannot initiate old CDT";
		code = error_table_$action_not_performed;
		go to RETURN;
	     end;


/* Go thru all channel entries in supplied CDT. */
/* p is a cdtep */

	do i = 1 to user_cdtp -> CDT.current_size;
	     p = addr (user_cdtp -> cdt.cdt_entry (i));
	     if verify (p -> CDTE.name, LEGAL) ^= 0
	     then do;
		     answer = "name not ASCII";
		     code = error_table_$action_not_performed;
		     go to RETURN;
		end;

/* Make sure that the channel is threaded in */

	     on sub_error_
		begin;
		     call NEW_CDT_DAMAGE;
		end;

	     if p -> CDTE.in_use > NOW_FREE
	     then do;
		     call cdt_mgr_$find_cdt_channel (user_cdtp, (p -> CDTE.name), cdtx, fnp_sw, code);
		     if code ^= 0
		     then do;
			     answer = "channel not threaded in. " || p -> CDTE.name;
			     go to RETURN;
			end;
		     if fnp_sw
		     then do;
			     code = error_table_$action_not_performed;
			     answer = "non-FNP channel with FNP name " || p -> CDTE.name;
			     go to RETURN;
			end;
		     if cdtx ^= i
		     then do;
			     code = error_table_$action_not_performed;
			     answer = "Multiple or misthreaded channel " || p -> CDTE.name;
			     go to RETURN;
			end;
		end;
	     revert sub_error_;

	     if ^valid_aim_range (p -> CDTE.access_class)
	     then do;
		     answer = "access_class range invalid";
		     code = error_table_$action_not_performed;
		     go to RETURN;
		end;
	     if p -> CDTE.service_type > MPX_SERVICE
	     then do;
		     answer = "illegal service type for " || p -> CDTE.name;
		     code = error_table_$action_not_performed;
		     go to RETURN;
		end;
	     if p -> CDTE.charge_type > 16
	     then do;
		     answer = "illegal charge type for " || p -> CDTE.name;
		     code = error_table_$action_not_performed;
		     go to RETURN;
		end;
	     if (p -> CDTE.line_type < LINE_TELNET) | (p -> CDTE.line_type > max_line_type)
	     then do;
		     answer = "illegal line type for " || p -> CDTE.name;
		     code = error_table_$action_not_performed;
		     go to RETURN;
		end;



	     if p -> CDTE.initial_terminal_type ^= ""
	     then do;
		     call ttt_info_$terminal_data (p -> CDTE.initial_terminal_type, (p -> CDTE.line_type), 0, null,
			code);
		     if code ^= 0
		     then do;
			     answer = "illegal terminal type for " || p -> CDTE.name;
			     code = error_table_$action_not_performed;
			     return;
			end;

		end;
	end;

/* protect active multiplexers from deletion or changes in service type */

	on sub_error_ call OLD_CDT_DAMAGE;

	do i = 1 to hbound (old_cdtp -> CDT.fnp_entry, 1);
	     if old_cdtp -> CDT.fnp_entry (i).daughter ^= 0
	     then call protect_mpxes (old_cdtp -> CDT.fnp_entry (i).daughter,
		     old_cdtp -> CDT.fnp_entry (i).daughter_count);
	end;
	if old_cdtp -> CDT.threads.daughter ^= 0
	then call protect_mpxes (old_cdtp -> CDT.threads.daughter, old_cdtp -> CDT.threads.daughter_count);

	revert sub_error_;

/* Individual items in supplied CDT look ok.
   Now, build a new CDT in a temporary segment, by merging the old one with the supplied one.
   We copy the old one into the temporary segment and then start making changes to that copy.
   Although comments speak of examining and making changes to the old one, the code actually references the copy.
   Since user pointers to CDT entries are kept, we must not change the position of any existing CDT entry. */

	call get_temp_segment_ ("up_cdt_", new_cdtp, code);
	if new_cdtp = null
	then do;
		call sys_log_$error_log (2, code, "up_cdt_", "cannot make temp");
		go to RETURN;
	     end;
	movelen =
	     wordno (addr (user_cdtp -> CDT.cdt_entry (1))) /* size of header plus the FNP entries */
	     + old_cdtp -> CDT.current_size * size (cdte);/* plus the cdt entries */
	new_cdtp -> movetable = old_cdtp -> movetable;	/* Shlup */

/* NOTHING should reference off of old_cdtp from here to the final */
/* stage of the installation. */

/* copy header of new cdt over old cdt header, except for meters. */

	new_cdtp -> CDT.author.lock = ""b;
	new_cdtp -> CDT.author.proc_group_id = user_cdtp -> CDT.author.proc_group_id;
	new_cdtp -> CDT.author.table = user_cdtp -> CDT.author.table;
	new_cdtp -> CDT.author.w_dir = user_cdtp -> CDT.author.w_dir;
	new_cdtp -> CDT.author.last_install_time = clock ();
	new_cdtp -> CDT.max_size = user_cdtp -> CDT.max_size;
						/* current_size gets set below, while adding channel entries */
	new_cdtp -> CDT.version = CDT_version;

	new_cdtp -> CDT.acceptable_fnp_tbf = user_cdtp -> CDT.acceptable_fnp_tbf;
	new_cdtp -> CDT.spare_channel_count = user_cdtp -> CDT.spare_channel_count;

/* copy FNP entries of new CDT into old CDT, except for dynamic stuff */

	do i = 1 to hbound (new_cdtp -> CDT.fnp_entry, 1);/* scan the FNP entries */
	     p = addr (new_cdtp -> CDT.fnp_entry (i));	/* p points to an old FNP entry */
	     q = addr (user_cdtp -> CDT.fnp_entry (i));	/* q points to a new FNP entry */

	     if p -> FNPE.state ^= FNP_FREE & q -> FNPE.state ^= FNP_FREE
	     then do;				/* both in use */
		     call copy_fnpe;		/* does not disturb threads ! */
		     p -> FNPE.current_service_type = p -> FNPE.service_type;
		     call merge_subtrees (addr (p -> FNPE.threads), addr (q -> FNPE.threads));
						/* p old, q new */
		end;
	     else if p -> FNPE.state = FNP_FREE & q -> FNPE.state > FNP_FREE
	     then do;				/* adding FNP */
		     call copy_fnpe;		/* not including threads */
		     call init_mpxe (addr (p -> FNPE.mpxe));
		     p -> FNPE.state = NOT_CONFIGURED;
		     unspec (p -> FNPE.threads) = ""b;
		     p -> FNPE.threads.next_sister, p -> FNPE.threads.prev_sister = -2;
		     p -> FNPE.threads.mother = 0;
		     p -> FNPE.threads.daughter, p -> FNPE.threads.daughter_count = 0;
		     call add_subtree (addr (q -> FNPE.threads));
						/* add them all */
		end;
	     else if p -> FNPE.state ^= FNP_FREE & q -> FNPE.state = FNP_FREE
	     then do;				/* deleteing FNP */
		     call delete_subtree (addr (p -> FNPE.threads));
		     p -> FNPE.service_type = INACTIVE;
		     p -> FNPE.current_service_type = INACTIVE;
		     unspec (p -> FNPE.threads) = ""b;
		end;
	end;

	p, q = null;				/* until something else defines them */

	call merge_subtrees (addr (new_cdtp -> cdt.threads), addr (user_cdtp -> cdt.threads));
						/** All the channels are merged and updated */

/* We are finally ready to update the actual CDT and get the access set */

	instalp = old_cdtp;				/* return ptr to >sc1>cdt */
	call hcs_$delentry_seg (user_cdtp, code);	/* delete the new CDT (the one they gave us to install) */

	user_cdtp = null;				/* here or gone, its not interesting */

	wordcount = wordno (addr (user_cdtp -> CDT.cdt_entry (1))) + new_cdtp -> CDT.current_size * size (cdte);
	movelen = wordcount;
	old_cdtp -> movetable = new_cdtp -> movetable;	/* Copy new CDT over old one fast. */

	call release_temp_segment_ ("up_cdt_", new_cdtp, (0));
						/* nuf */
	new_cdtp = null;

	call hcs_$set_bc (instaldir, instalname, 36 * wordcount, code);
	call hcs_$set_safety_sw (instaldir, instalname, "1"b, code);

/* old_cdtp is the new, live, cdt in >sc1.
   Now make one last pass and attach/listen/remove the channels which
   were reconfigured by the installation of the new CDT. */

	do i = 1 to old_cdtp -> CDT.current_size;
	     q = addr (old_cdtp -> CDT.cdt_entry (i));

/* The following tests for special values of CDTE.in_use must remain in the order of
   decreasing special values, so the tests for >= will work right. The purpose of the >=
   tests is to let us add a large number to CDTE.in_use, preserving its value
   and setting a flag on the CDTE at the same time */

	     if q -> CDTE.in_use = UNDELETE_THIS_CHANNEL
	     then do;				/* a configured channel was deleted, then added back */
		     q -> CDTE.in_use = NOW_HUNG_UP;	/* so we can use it immediately */
		     q -> CDTE.current_service_type = q -> CDTE.service_type;
		     if q -> CDTE.current_service_type = ANS_SERVICE
		     then begin;
			     declare listen		      bit (1);
			     listen = "0"b;
			     if q -> CDTE.mother < 0
			     then if old_cdtp -> CDT.fnp_entry (-q -> CDTE.mother).mpxe.state = MPX_UP
				then listen = "1"b;
				else ;
			     else if q -> CDTE.mother > 0
			     then do;
				     mpxep = addr (old_cdtp -> CDT.cdt_entry (q -> CDTE.mother).initial_command);
				     if mpxe.state = MPX_UP
				     then listen = "1"b;
				end;
			     else listen = "1"b;	/* top level in ANS_SERVICE? why not! */
			     if listen & q -> cdte.state ^= TTY_MASKED
			     then do;
				     call asu_$attach_channel (q, code);
				     call asu_$asu_listen (q, code);
				end;
			end;
		end;
	     else if q -> CDTE.in_use >= DELETE_THIS_CHANNEL
	     then do;
		     q -> CDTE.in_use = q -> CDTE.in_use - DELETE_THIS_CHANNEL;
						/* put back real in_use value */
		     if q -> CDTE.current_service_type ^= MPX_SERVICE
		     then call asu_$asu_remove (q);	/* so asu_remove will do the right thing */
		     if q -> CDTE.tra_vec = WAIT_REMOVE /* should not be true for MPX's */
		     then /* if dialup_ will remove channel after destroying process */
			q -> CDTE.tra_vec = WAIT_DELETE_CHANNEL;
						/* tell dialup_ to mark the cdte deleted, instead */
		     else do;
			     q -> CDTE.in_use = CHANNEL_DELETED;
						/* but if no process, mark it deleted now */
			     q -> CDTE.current_service_type = INACTIVE;
						/* inactive */

			end;
		end;
	     else if q -> CDTE.in_use = LISTEN_TO_THIS_CHANNEL
	     then do;				/* We assume CDTE.dim did not change */
						/* (because the old line was never removed) */
		     line_type = q -> CDTE.line_type;	/* Unpack new line type */
		     call astty_$tty_order (q, "set_line_type", addr (line_type), code);

		     if line_type = LINE_TELNET
		     then do;
			     service_type = q -> CDTE.service_type;
						/* Unpack service type */
			     call astty_$tty_order (q, "set_service_type", addr (service_type), code);
			end;

		     if q -> cdte.state ^= TTY_MASKED
		     then call asu_$asu_listen (q, code);
		end;
	     else if q -> CDTE.in_use = ATTACH_THIS_CHANNEL
	     then do;
		     if q -> CDTE.state ^= TTY_MASKED
		     then do;
			     call asu_$attach_channel (q, code);
			     call asu_$asu_listen (q, code);
			end;
		end;
	     else if q -> CDTE.in_use >= REMOVE_THIS_CHANNEL
	     then do;
		     q -> CDTE.in_use = q -> CDTE.in_use - REMOVE_THIS_CHANNEL;
						/* restore real value of in_use */
		     call asu_$asu_remove (q);	/* so asu_remove will do the right thing */
		end;
	end;

	code = 0;

RETURN:
	return;


/* Internal procedure to change the service type of a channel */

change_service_type:
     procedure (p, q);

	dcl     (p, q)		 pointer;		/* p is FROM, q is TO */

/* automatic */

	dcl     jumpx		 fixed bin;

/* program */

	call sys_log_ (0, "up_cdt_: changing service type for channel ^a ^a from ^d^[^x(cur:^d)^;^s^] to ^d",
	     q -> CDTE.name, q -> CDTE.comment, p -> CDTE.service_type,
	     (p -> CDTE.service_type ^= p -> CDTE.current_service_type), p -> CDTE.current_service_type,
	     q -> CDTE.service_type);

	if p -> CDTE.current_service_type < 1 | p -> CDTE.current_service_type > 8 | q -> CDTE.service_type < 1
	     | q -> CDTE.service_type > 8 | q -> CDTE.service_type = 5
	then do;
		call sys_log_ (2, "up_cdt_: Service type out of range for ^a", q -> CDTE.name);
		return;				/* we'll take a fault if we try to continue */
	     end;

	jumpx = 10 * p -> CDTE.current_service_type + q -> CDTE.service_type;
	go to change (jumpx);

change (11):					/* ANS -> ANS */
change (22):					/* FTP -> FTP */
change (33):					/* MC -> MC */
change (44):					/* SLAVE -> SLAVE */
change (66):					/* OUT -> OUT */
change (77):					/* INACTIVE -> INACTIVE */
change (88):					/* MPX -> MPX */
	return;

change (12):					/* ANS -> FTP */
	p -> CDTE.in_use = LISTEN_TO_THIS_CHANNEL;
	return;

change (13):					/* ANS -> MC */
	p -> CDTE.in_use = p -> CDTE.in_use + REMOVE_THIS_CHANNEL;
	goto tell_user;

change (14):					/* ANS -> SLAVE */
change (17):					/* ANS -> INACTIVE */
change (18):					/* ANS -> MPX */
	p -> CDTE.in_use = p -> CDTE.in_use + REMOVE_THIS_CHANNEL;
	goto tell_user;

change (16):					/* ANS -> OUT */
	return;

change (21):					/* FTP -> ANS */
	p -> CDTE.in_use = LISTEN_TO_THIS_CHANNEL;
	return;

change (23):					/* FTP -> MC */
change (24):					/* FTP -> SLAVE */
change (27):					/* FTP -> INACTIVE */
change (28):					/* FTP -> MPX */
	p -> CDTE.in_use = p -> CDTE.in_use + REMOVE_THIS_CHANNEL;
	goto tell_user;

change (26):					/* FTP -> OUT */
	p -> CDTE.in_use = LISTEN_TO_THIS_CHANNEL;
	return;

change (31):					/* MC -> ANS */
change (32):					/* MC -> FTP */
change (34):					/* MC -> SLAVE */
change (36):					/* MC -> OUT */
change (37):					/* MC -> INACTIVE */
change (38):					/* MC -> MPX */
						/* Don't attach a former MC channel. If MC is still using it, the operator would
   get upset. Let attach command or next bootload attach it. */
	return;

change (41):					/* SLAVE -> ANS */
change (42):					/* SLAVE -> FTP */
	p -> CDTE.in_use = ATTACH_THIS_CHANNEL;
	return;
change (43):					/* SLAVE -> MC */
change (47):					/* SLAVE -> INACTIVE */
change (48):					/* SLAVE -> MPX */
	return;

change (46):					/* SLAVE -> OUT */
	p -> CDTE.in_use = ATTACH_THIS_CHANNEL;
	return;

change (51):					/* DIAL -> ANS */
change (52):					/* DIAL -> FTP */
	p -> CDTE.in_use = ATTACH_THIS_CHANNEL;
	return;
change (53):					/* DIAL -> MC */
change (54):					/* DIAL -> SLAVE */
change (56):					/* DIAL -> OUT */
change (57):					/* DIAL -> INACTIVE */
change (58):					/* DIAL -> NPX */
	return;

change (61):					/* OUT -> ANS */
	return;

change (62):					/* OUT -> FTP */
	p -> CDTE.in_use = LISTEN_TO_THIS_CHANNEL;
	return;

change (63):					/* OUT -> MC */
change (67):					/* OUT -> INACTIVE */
change (68):					/* OUT -> MPX */
	p -> CDTE.in_use = p -> CDTE.in_use + REMOVE_THIS_CHANNEL;
	goto tell_user;

change (64):					/* OUT -> SLAVE */
	p -> CDTE.in_use = p -> CDTE.in_use + REMOVE_THIS_CHANNEL;
	goto tell_user;

change (71):					/* INACTIVE -> ANS */
change (72):					/* INACTIVE -> FTP */
change (76):					/* INACTIVE -> OUT */
	p -> CDTE.in_use = ATTACH_THIS_CHANNEL;
	return;
change (73):					/* INACTIVE -> MC */
change (74):					/* INACTIVE -> SLAVE */
change (78):					/* INACTIVE -> MPX */
	return;

change (81):					/* MPX -> ANS */
change (82):					/* MPX -> FTP */
change (83):					/* MPX -> MC */
change (84):					/* MPX -> SLAVE */
change (85):					/* MPX -> DIAL */
change (86):					/* MPX -> OUT */
change (87):					/* MPX -> INACTIVE */
	p -> CDTE.in_use = p -> CDTE.in_use + REMOVE_THIS_CHANNEL;
	return;

tell_user:
	if p -> CDTE.in_use >= NOW_LOGGED_IN + REMOVE_THIS_CHANNEL
	then /* if somebody is there, tell them why it's going to hang up */
	     call asu_$write_chn_message (p, as_error_table_$chn_svc_changed, debg, code);
	return;
     end change_service_type;

/* Internal proc to copy new FNP entry into old FNP entry */

copy_fnpe:
     procedure;					/* p and q are implicit parameters */

	p -> FNPE.type = q -> FNPE.type;
	p -> FNPE.memory = q -> FNPE.memory;
	p -> FNPE.service_type = q -> FNPE.service_type;
	p -> FNPE.mpx_type = q -> FNPE.mpx_type;
	p -> FNPE.coreimage = q -> FNPE.coreimage;
	p -> FNPE.nlslas = q -> FNPE.nlslas;
	p -> FNPE.nhslas = q -> FNPE.nhslas;
	return;

     end copy_fnpe;

/* Internal procedure to copy NEW cdt entry over OLD cdt entry */

copy_cdte:
     proc (from_cdtep, to_cdtep);

	declare (from_cdtep, to_cdtep) pointer;

	to_cdtep -> CDTE.access_class = from_cdtep -> CDTE.access_class;
	to_cdtep -> CDTE.comment = from_cdtep -> CDTE.comment;
	to_cdtep -> CDTE.charge_type = from_cdtep -> CDTE.charge_type;
	to_cdtep -> CDTE.service_type = from_cdtep -> CDTE.service_type;
	to_cdtep -> CDTE.current_service_type = from_cdtep -> CDTE.service_type;
	to_cdtep -> CDTE.line_type = from_cdtep -> CDTE.line_type;
	to_cdtep -> CDTE.initial_terminal_type = from_cdtep -> CDTE.initial_terminal_type;
	if ^(from_cdtep -> CDTE.autobaud)
	then to_cdtep -> CDTE.baud_rate = from_cdtep -> CDTE.baud_rate;
	to_cdtep -> CDTE.modem_type = from_cdtep -> CDTE.modem_type;
	to_cdtep -> CDTE.answerback = from_cdtep -> CDTE.answerback;
	string (to_cdtep -> CDTE.flags) = string (from_cdtep -> CDTE.flags);
	to_cdtep -> CDTE.mpx_type = from_cdtep -> CDTE.mpx_type;
	to_cdtep -> CDTE.mpx_service = from_cdtep -> CDTE.mpx_service;
	if to_cdtep -> CDTE.current_service_type ^= MPX_SERVICE
	then to_cdtep -> CDTE.initial_command = from_cdtep -> CDTE.initial_command;
	return;

     end copy_cdte;



merge_subtrees:
     procedure (old_thread_ptr, new_thread_ptr);


	declare (old_thread_ptr, new_thread_ptr)
				 pointer;

	declare 1 old_threads	 aligned like channel_threads based (old_thread_ptr);
	declare 1 new_threads	 aligned like channel_threads based (new_thread_ptr);


	declare old_x		 fixed bin;	/* current position in old tree (cdtx) */
	declare new_x		 fixed bin;	/* current position in new tree (cdtx) */

	declare (old_check, new_check) fixed bin;	/* chain chase counters */
	declare (old_limit, new_limit) fixed bin;	/* copied so that thread_in wont disturb */

/**** Note that this merge takes place in place in the "old" cdt. */
/**** This works because thread_in's always happen in the part of */
/**** the tree that has already been visited. */

/**** the following cases happen when channels stop being multiplexers */
/**** or start, for that matter */

	if old_threads.daughter_count = 0 |		/** **/
	     new_threads.daughter_count = 0
	then do;

		if old_threads.daughter_count = 0 & new_threads.daughter_count = 0
						/* its winter, and the trees are bare */
		then return;

		if old_threads.daughter_count = 0
		then call add_subtree (new_thread_ptr); /* easy case */

		if new_threads.daughter_count = 0
		then call delete_subtree (old_thread_ptr);
						/* another easy case */
		return;
	     end;

	old_x = old_threads.daughter;
	if old_x = 0
	then call OLD_CDT_DAMAGE;			/* dcount ^= ndaughters */
	new_x = new_threads.daughter;
	if new_x = 0
	then call NEW_CDT_DAMAGE;			/* dcount ^= ndaughters */

	old_check, new_check = 0;			/* check them off as we use them up */
	old_limit = old_threads.daughter_count;
	new_limit = new_threads.daughter_count;

COMPARE_TWO_CHANNELS:				/* This is the basic loop. */
	begin;
	     declare 1 ocdte	      aligned like cdte based (addr (new_cdtp -> CDT.cdt_entry (old_x)));
	     declare 1 ncdte	      aligned like cdte based (addr (user_cdtp -> CDT.cdt_entry (new_x)));


/**** The RULES: ****/
/****  ** if the old name is alphaless than the new name, than it is a  **/
/****     deleted channel, for if it were in the new tree, we would have **/
/****     seen it already. **/
/**** ** if the old name is equal to the new name, things are peachy. **/
/**** ** if the old name is greater than the new name, then the new name **/
/****    must be added. For if it were not, we would have already seen the **/
/****    equal old name. ******/


	     if ocdte.name < ncdte.name
	     then
DELETE:
		do;				/* Deleted Channel */
		     call delete_channel (old_x);	/* deletes children too. */
		     old_x = ocdte.threads.next_sister;
		     old_check = old_check + 1;
		     if old_check > old_limit
		     then call OLD_CDT_DAMAGE;

		     if old_x = 0			/* run out, rest must be added */
		     then
NO_MORE_OLD:
			begin;			/* construct dummy thread block */
			     declare 1 t		      aligned like channel_threads;
			     unspec (t) = ""b;
			     t.daughter_count = new_threads.daughter_count - new_check;
			     t.daughter = new_x;	/* start by adding this. */
			     t.mother = new_threads.mother;
			     t.next_sister, t.prev_sister = 0;
						/* lie */
			     call add_subtree (addr (t));
						/* adds children too */
			     return;		/* merge complete at this level */
			end NO_MORE_OLD;

		     go to COMPARE_TWO_CHANNELS;
		end DELETE;

	     else if ocdte.name = ncdte.name
	     then
MERGE:
		do;				/* Ha HA! */

		     call update_channel (old_x, new_x);/* change data */
		     old_check = old_check + 1;	/* use up channels */
		     if old_check > old_limit
		     then call OLD_CDT_DAMAGE;
		     new_check = new_check + 1;
		     if new_check > new_limit
		     then call NEW_CDT_DAMAGE;
		     if ocdte.threads.daughter ^= 0 & ncdte.threads.daughter ^= 0
		     then call merge_subtrees (addr (ocdte.threads), addr (ncdte.threads));
		     else if ocdte.threads.daughter ^= 0
		     then call delete_subtree (addr (ocdte.threads));
		     else call add_subtree (addr (ncdte.threads));
						/* RECURSE */
		     if ocdte.next_sister = 0		/** No more there */
			& ncdte.next_sister = 0	/** chains at end */
		     then return;
		     old_x = ocdte.threads.next_sister; /** chase both chains **/
		     new_x = ncdte.threads.next_sister; /** before trying to add remainder **/
		     if old_x = 0			/** to avoid adding this new_x twice */
		     then go to NO_MORE_OLD;
		     if new_x = 0
		     then
NO_MORE_NEW:
			begin;			/* the rest of the old chain goes away */
			     declare 1 t		      aligned like channel_threads;
			     unspec (t) = ""b;
			     t.daughter_count = old_threads.daughter_count - old_check;
			     t.mother = old_threads.mother;
			     t.next_sister, t.prev_sister = 0;
			     t.daughter = old_x;
			     call delete_subtree (addr (t));
			     return;		/* End of merge at this level */
			end;
		     go to COMPARE_TWO_CHANNELS;
		end MERGE;

	     else
ADD:
		do;				/* old > new, new is added ! */
		     call add_channel (new_x);	/* allocates cdte, fills in, threads in, and recurses over children */
		     new_check = new_check + 1;
		     if new_check > new_limit
		     then call NEW_CDT_DAMAGE;
		     new_x = ncdte.threads.next_sister;
		     if new_x = 0
		     then go to NO_MORE_NEW;
		     go to COMPARE_TWO_CHANNELS;
		end ADD;

	end COMPARE_TWO_CHANNELS;			/* never get here */
     end merge_subtrees;


add_subtree:
     procedure (thread_ptr);				/* simplified version that just adds */

	declare thread_ptr		 pointer;
	declare 1 threads		 aligned like channel_threads based (thread_ptr);
	declare x			 fixed bin;
	declare check		 fixed bin;
	declare original_daughter_count
				 fixed bin;

	check = 0;
	if threads.daughter_count = 0
	then return;

	do x = threads.daughter repeat (user_cdtp -> CDT.cdt_entry (x).threads.next_sister) while (x ^= 0);

	     check = check + 1;
	     if check > threads.daughter_count
	     then call NEW_CDT_DAMAGE;
	     call add_channel (x);			/* easy enough */
	end;
	return;

delete_subtree:
     entry (thread_ptr);

	check = 0;
	if threads.daughter_count = 0
	then return;

	original_daughter_count = threads.daughter_count;

	do x = threads.daughter repeat (new_cdtp -> CDT.cdt_entry (x).threads.next_sister) while (x ^= 0);
	     check = check + 1;
	     if check > original_daughter_count
	     then call OLD_CDT_DAMAGE;
	     call delete_channel$$no_protect (x);
	end;
     end add_subtree;

%page;

/**** Okay, now all we need are procedures to handle the cases */

update_channel:
     procedure (oldx, newx);

	/*** Take care of channels in both cdts, that may have stuff to do to them */
	/*** Note that we merge from new into old. */

	declare (oldx, newx)	 fixed bin;

	declare 1 ocdte		 aligned like cdte based (addr (new_cdtp -> CDT.cdt_entry (oldx)));
	declare 1 ncdte		 aligned like cdte based (addr (user_cdtp -> CDT.cdt_entry (newx)));


	if ocdte.in_use = CHANNEL_DELETED
	then do;					/* old channel is marked deleted */
		ocdte.in_use = UNDELETE_THIS_CHANNEL;	/* we are un-deleting it */
		call sys_log_ (0, "up_cdt_: Adding previously-deleted channel ^a ^a", ocdte.name, ocdte.comment);
	     end;


/* For channels that are configured and might be in use, changing the service type or line type requires some action
   (like doing a bump, a hangup, or a listen), in addition to changing the service_type or line_type variables */

	if ocdte.in_use ^= NOT_CONFIGURED & ocdte.in_use ^= UNDELETE_THIS_CHANNEL
	then do;					/* only for real channels */

/**** Check for change in service type */
		if ocdte.service_type ^= ncdte.service_type
		then call change_service_type (addr (ocdte), addr (ncdte));

/* Check for change in line type */
		if ocdte.line_type ^= ncdte.line_type
		then do;
			if ((ncdte.service_type = ANS_SERVICE)
						/** if giving to AS */
			     | (ncdte.service_type = FTP_SERVICE))
						/** **/
			     & ((ocdte.current_service_type = ANS_SERVICE)
						/** & now held by AS */
			     | (ocdte.current_service_type = FTP_SERVICE)) & ocdte.in_use <= NOW_LISTENING
						/* noone connected */
			then do;			/* use old CDTE to get old CDTE.dim, etc */
						/* stop listening so can reset old line type later */
				call astty_$tty_order (addr (ocdte), "hangup", null, code);
				ocdte.in_use = LISTEN_TO_THIS_CHANNEL;
			     end;
		     end;
	     end;

/* Check for change in access class */
	if ^equal_aim_ranges (ocdte.access_class (*), ncdte.access_class (*))
	then do;
		old_auth_string = display_access_class_$range (ocdte.access_class (*));
		auth_string = display_access_class_$range (ncdte.access_class (*));
		utep = null ();			/* start assuming noone */
		call sys_log_ (0, "up_cdt_: changing access class of channel ^a from ^a to ^a", ocdte.name,
		     old_auth_string, auth_string);
		if ((ocdte.current_service_type = ANS_SERVICE)
						/** **/
		     | (ocdte.current_service_type = FTP_SERVICE))
		then do;
			if unspec (ocdte.process) ^= ""b
						/* is this possibly a valid process? */
			then utep = ocdte.process;	/* Get ptr to process now using. */
			if utep ^= null
			then /* .. if any */
			     if ute.active >= NOW_LOGGED_IN
				& ^aim_check_$in_range (ute.process_authorization, ncdte.access_class)
				& ute.preempted = 0
			     then do;
				     old_auth_string = display_access_class_$range (ncdte.access_class);
				     auth_string = display_access_class_ (ute.process_authorization);
				     call sys_log_ (1,
					"up_cdt_: bumping ^a.^a, channel ^a access class ^a no longer includes user authorization ^a.",
					ute.person, ute.project, ocdte.name, old_auth_string, auth_string);
				     call asu_$bump_code (utep, as_error_table_$chn_auth_excludes, debg, code,
					(0) /* NO GRACE ! */);
				end;
		     end;
	     end;

/* Copy other stuff from new CDTE into merged one */
	call copy_cdte (addr (ncdte), addr (ocdte));
     end update_channel;


delete_channel:
     procedure (cdtx);

	declare cdtx		 fixed bin;
	declare no_protect		 bit (1) aligned;

	no_protect = "0"b;				/* Protect by using DELETE_THIS_CHANNEL */
	go to Join;

delete_channel$$no_protect:
     entry (cdtx);

	no_protect = "1"b;				/* Deleting parent mpx, definitively flush this */

Join:
	declare 1 dcdte		 aligned like cdte based (addr (new_cdtp -> CDT.cdt_entry (cdtx)));

	call sys_log_ (0, "up_cdt_: Deleting channel ^a ^a", dcdte.name, dcdte.comment);

	if dcdte.threads.daughter_count > 0
	then call delete_subtree (addr (dcdte.threads));	/* get rid of kiddies */
						/* since we wont decend further */
						/* note that _subtree calls no_protect */

/***** Ignoring in_use for no_protect is allowed because */
/***** an inactive multiplexer cannot have active subchannels */

	if dcdte.in_use = NOT_CONFIGURED | no_protect
	then /* if channel was never "live" */
	     do;
		dcdte.in_use = NOW_FREE;
		on sub_error_ call OLD_CDT_DAMAGE;
		call cdt_mgr_$thread_out_cdt_channel (new_cdtp, cdtx);
						/* free the CDTE immediately */
	     end;
	else do;					/* otherwise take channel out of service in several steps */
						/* no matter what the channel's service type is, */
		if dcdte.in_use >= NOW_DIALED		/* if somebody there, tell them what's happening */
		then call asu_$write_chn_message (addr (dcdte), as_error_table_$chn_deleted, debg, code);
		dcdte.in_use = dcdte.in_use + DELETE_THIS_CHANNEL;
						/* set reminder to delete it later */
	     end;
     end delete_channel;


add_channel:
     procedure (cdtx);

	declare cdtx		 fixed bin;
	declare 1 acdte		 aligned like cdte based (addr (user_cdtp -> CDT.cdt_entry (cdtx)));
	declare nx		 fixed bin;

	do nx = 1 to new_cdtp -> CDT.current_size /* find a free entry */
	     while (new_cdtp -> CDT.cdt_entry (nx).in_use ^= NOW_FREE);
	end;
	if nx = new_cdtp -> CDT.current_size + 1
	then /* if no free ones within the old CDT */
	     do;
		if nx > hbound (new_cdtp -> CDT.cdt_entry, 1)
		then do;
			answer = "Too many channels defined.";
			code = error_table_$action_not_performed;
			go to RETURN;
		     end;
		new_cdtp -> CDT.current_size = nx;	/* add a new entry to the end * */
	     end;

	begin;
	     declare 1 ncdte	      aligned like cdte based (addr (new_cdtp -> cdt.cdt_entry (nx)));
	     ncdte.in_use = NOT_CONFIGURED;		/* new chn */
	     ncdte.name = acdte.name;
	     call copy_cdte (addr (acdte), addr (ncdte)); /* FROM, TO */
	     if ncdte.line_type = LINE_TELNET
	     then ncdte.in_use = ATTACH_THIS_CHANNEL;
	     ncdte.event = 0;
	     ncdte.tra_vec = 0;
	     ncdte.count = 0;
	     ncdte.twx = 0;
	     ncdte.state = 0;
	     ncdte.current_terminal_type = "";
	     ncdte.tty_id_code = "";
	     ncdte.process = null;
	     ncdte.dialed_to_procid = ""b;
	     ncdte.next_channel = 0;
	     ncdte.n_dialups = 0;			/* Reset meters. */
	     ncdte.n_logins = 0;
	     ncdte.dialed_up_time = 0;
	     ncdte.dialup_time = 0;
	     if ncdte.service_type = MPX_SERVICE
	     then call init_mpxe (addr (ncdte.initial_command));
	     on sub_error_ call NEW_CDT_DAMAGE;
	     call cdt_mgr_$thread_in_cdt_channel (new_cdtp, nx);
	     auth_string = display_access_class_$range (ncdte.access_class);
	     call sys_log_ (0, "up_cdt_: Adding channel ^a ^a ^a", ncdte.name, ncdte.comment, auth_string);
	     call add_subtree (addr (acdte.threads));

	end;
     end add_channel;


init_mpxe:
     procedure (nmpxep);

	declare nmpxep		 pointer;

	nmpxep -> mpxe.current_service_type = INACTIVE;	/* The first load has to be explicit */
	nmpxep -> mpxe.n_bootloads = 0;
	nmpxep -> mpxe.time_initial_load = 0;
	nmpxep -> mpxe.time_last_load = 0;
	nmpxep -> mpxe.time_last_crash = 0;
	nmpxep -> mpxe.time_load_start = 0;
	nmpxep -> mpxe.last_tbf = 0;
	return;
     end init_mpxe;


protect_mpxes:
     procedure (muxx, d_limit);			/* This is recursive ... */

	declare muxx		 fixed bin unal;	/* always cdtx, never fnpx */
	declare d_limit		 fixed bin unal;
	declare check		 fixed bin;
	declare newx		 fixed bin;
	declare x			 fixed bin;

/* we visit each MUX in the old cdt (old_cdtp) */

	check = 0;
	do x = muxx repeat (old_cdtp -> CDT.cdt_entry (x).threads.next_sister) while (x ^= 0);
	     p = addr (old_cdtp -> CDT.cdt_entry (x));
	     check = check + 1;
	     if check > d_limit | check > old_cdtp -> cdt.n_cdtes
	     then call OLD_CDT_DAMAGE;
	     if p -> CDTE.current_service_type = MPX_SERVICE
	     then do;
		     mpxep = addr (p -> CDTE.initial_command);
		     if (mpxe.state ^= FNP_DOWN) & (mpxe.state ^= FNP_UNKNOWN)
		     then do;			/* found an active one */
			     call cdt_mgr_$find_cdt_channel (user_cdtp, (p -> cdte.name), newx, ("0"b), code);
			     if code = 0
			     then do;
				     q = addr (user_cdtp -> CDT.cdt_entry (newx));
				     if q -> CDTE.service_type ^= MPX_SERVICE
				     then do;
					     answer =
						"Cant change service type for active mpx " || p -> CDTE.name;
					     code = error_table_$action_not_performed;
					     go to RETURN;
					end;
				end;
			     else do;
				     answer = "cant delete active mpx " || p -> CDTE.name;
				     code = error_table_$action_not_performed;
				     go to RETURN;
				end;
			end;
		end;				/* interesting state */
	     if p -> CDTE.threads.daughter_count > 0
	     then call protect_mpxes (p -> CDTE.threads.daughter, p -> CDTE.threads.daughter_count);
	end;					/* the doloop */
     end protect_mpxes;


OLD_CDT_DAMAGE:
     procedure;

	go to OLD_CDT_DAMAGE_LABEL;			/* place to hang breakpoint in debugging */
     end OLD_CDT_DAMAGE;

OLD_CDT_DAMAGE_LABEL:				/* the copy of the current CDT is sick. Retry */
	if retry_count = 0
	then do;
		call sys_log_ (1, "up_cdt_: CDT thread damage in live CDT. Rethreading.");
		on sub_error_
		     begin;
			call find_condition_info_ (null, addr (auto_condition_info), (0));
			sub_error_info_ptr = auto_condition_info.info_ptr;
			call sys_log_$error_log (1, code, "up_cdt_", "cdt_mgr_$thread: ^a.",
			     sub_error_info.info_string);
/***** Return, cdt_mgr_ will do what recovery it can. */
		     end;

		call cdt_mgr_$thread (old_cdtp, code);
		if code ^= 0
		then go to GIVE_UP;
		call sys_log_ (1, "up_cdt_: Rethreading complete.");
		retry_count = 1;
		call cleanup;
		go to RETRY_INSTALLATION;

GIVE_UP:
		call sys_log_ (1, "up_cdt_: Repeated CDT threading errors. Installation aborted.");
		call cleanup;
		code = error_table_$action_not_performed;
		answer = "live CDT threading errors, shutdown and reboot to correct";
		go to RETURN;
	     end;

NEW_CDT_DAMAGE:
     procedure;
	answer = "CDT threading error(s) in supplied CDT";
	code = error_table_$action_not_performed;
	go to RETURN;
     end;

valid_aim_range:
     procedure (range) returns (bit (1) aligned) reducible;

	declare range		 (2) bit (72) aligned;

	if ^aim_check_$greater_or_equal (range (2), range (1))
						/* valid range ? */
	then return ("0"b);
	if ^aim_check_$greater_or_equal (system_high, range (2))
						/* valid for the system ? */
	then return ("0"b);
	else return ("1"b);
     end valid_aim_range;


equal_aim_ranges:
     procedure (r1, r2) returns (bit (1) aligned);	/* the every bif would fix this */
	declare (r1, r2)		 (2) bit (72) aligned;

	return (aim_check_$equal (r1 (1), r2 (1)) & aim_check_$equal (r1 (2), r2 (2)));
     end equal_aim_ranges;

cleanup:
     procedure;

	if new_cdtp ^= null
	then call release_temp_segment_ ("up_cdt_", new_cdtp, (0));
	if old_cdtp ^= null
	then call hcs_$terminate_noname (old_cdtp, (0));
     end cleanup;


%page;
%include access_mode_values;
%page;
%include author_dcl;
%page;
%include cdt;
%page;
%include condition_info;
	declare 1 auto_condition_info	 aligned like condition_info;
%include condition_info_header;
%page;
%include dialup_values;
%page;
%include installation_parms;
%page;
%include line_types;
%page;
%include sub_error_info;
%page;
%include user_attributes;
%page;
%include user_table_entry;

     end up_cdt_;
