/****^  ********************************************
        *                                          *
        * Copyright, (C) Honeywell Bull Inc., 1987 *
        *                                          *
        ******************************************** */


/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* This module is part of the Multics Network Architecture (MNA) version of  */
/* user control.  MNA user control serves users coming into Multics via      */
/* separate networks (eg, the Distributed Systems Architecture (DSA)	       */
/* network.  MNA user control is not used for logins through the Multics     */
/* Communications System (MCS).  A separate MCS user control system serves   */
/* MCS users.						       */
/*							       */
/* To Be Supplied:						       */
/*  1) Brief module description.  See MDD010 or MTBs 751 and 752 for details */
/*     about this module, and its relationship to modules in the MCS user    */
/*     control system.					       */
/*  2) Operator error message documentation.  This program calls	       */
/*     sys_log_$general but does not contain the required descriptions of    */
/*     these messages.  This omission was waived for initial installation    */
/*     of the subsystem by the auditor, security coordinator, and by MDC     */
/*     management.						       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

/****^  HISTORY COMMENTS:
  1) change(86-04-19,Swenson), approve(87-07-13,MCR7737),
     audit(87-04-24,GDixon), install(87-08-04,MR12.1-1055):
     Initial coding.
  2) change(87-04-21,GDixon), approve(87-07-13,MCR7737),
     audit(87-07-30,Brunelle), install(87-08-04,MR12.1-1055):
      A) For notification of other processes for this personid, require that
         a process exist, not just that user be logged in.
      B) Changed DETERMINE_AUTHORIZATIONS to use convert_access_class_$(minimum
         and maximum) instead of aim_check_$greater to find the minimum range
         of authorizations between the SAT, PDT and PNT.
      C) Corrected to properly enforce password expiration interval.
      D) Removed references to ute.uflags.logged_in.
      E) Make all decisions on which internal procs to run in Setup, rather
         than making some there and some in the main procedure.
      F) Upgraded for change to answer_table.incl.pl1 and
         user_table_entry.incl.pl1
  3) change(87-05-12,GDixon), approve(87-07-13,MCR7737),
     audit(87-07-30,Brunelle), install(87-08-04,MR12.1-1055):
      A) Don't send login notifications to disconnected or UFT processes.
         Neither can receive the message or act upon an invalid login.
         (dsa 119)
      B) Don't send bad password information to UFT processes, since they
         cannot pass it along to the user (there is no user at the terminal).
  4) change(87-05-14,GDixon), approve(87-07-13,MCR7737),
     audit(87-07-30,Brunelle), install(87-08-04,MR12.1-1055):
      A) Replace use of uc_validate_info.channel_info.line_type with
         ute.line_type.
      B) Correct person_id (= anonymous) in group_id of anonymous users.
                                                   END HISTORY COMMENTS */

/* format: style4,indattr */

uc_login_:
     procedure (P_uc_validate_info_ptr, P_utep, P_code);

/* Parameters */

dcl  P_uc_validate_info_ptr ptr parameter;
dcl  P_utep	        ptr parameter;
dcl  P_code	        fixed bin (35) parameter;

/* Automatic */

dcl  authorization	        (3) bit (72) aligned;
dcl  auth_string	        char (200);
dcl  auth_string_octal      char (32);
dcl  code		        fixed bin (35) automatic;
dcl  1 flags	        structure aligned automatic,
       2 anonymous	        bit (1) unaligned,
       2 check_password     bit (1) unaligned,
       2 check_physical_security_breach
		        bit (1) unaligned,
       2 check_change_arguments
		        bit (1) unaligned,
       2 check_authorization_argument
		        bit (1) unaligned,
       2 check_daemon_access bit (1) unaligned,
       2 check_channel_access
		        bit (1) unaligned,
       2 check_channel_access_class bit (1) unaligned,
       2 check_anonymous_password bit (1) unaligned,
       2 pad1	        bit (27) unaligned;
dcl  htp		        ptr;
dcl  ip		        ptr automatic;
dcl  maybe_update_pnte      bit (1) aligned automatic;
dcl  pdtep	        ptr automatic;
dcl  pdtp		        ptr automatic;
dcl  1 pnte	        structure aligned like pnt_entry;
dcl  1 old_pnte	        structure aligned like pnt_entry;
dcl  satep	        ptr automatic;
dcl  satp		        ptr automatic;
dcl  whoptr	        ptr automatic;

/* Entries */

dcl  aim_check_$greater_or_equal
		        entry (bit (72) aligned, bit (72) aligned)
		        returns (bit (1) aligned);
dcl  aim_check_$in_range    entry (bit (72) aligned,
		        (2) bit (72) aligned)
		        returns (bit (1) aligned);
dcl  as_access_audit_$login entry (ptr, char (*));
dcl  asu_$blast_user        entry (ptr, char (*), char (*), fixed bin (35));
dcl  convert_access_class_$maximum
		        entry ((*) bit (72) aligned, fixed bin, bit (72) aligned);
dcl  convert_access_class_$minimum
		        entry ((*) bit (72) aligned, fixed bin, bit (72) aligned);
dcl  convert_access_class_$to_string_short
		        entry (bit (72) aligned, char (*), fixed bin (35));
dcl  convert_access_class_$to_string_range_short
		        entry ((2) bit (72) aligned, char (*),
		        fixed bin (35));
dcl  convert_status_code_   entry (fixed bin (35), char (8) aligned,
		        char (100) aligned);
dcl  display_access_class_  entry (bit (72) aligned) returns (char (32) aligned);
dcl  display_access_class_$range
		        entry ((2) bit (72) aligned)
		        returns (char (32) aligned);
dcl  hash_$search	        entry (ptr, char (*), fixed bin (35),
		        fixed bin (35));
dcl  hcs_$get_user_access_modes
		        entry (char (*), char (*), char (*),
		        fixed bin, bit (36) aligned,
		        bit (36) aligned, fixed bin (35));
dcl  initiate_file_	        entry (char (*), char (*), bit (*), ptr,
		        fixed bin (24), fixed bin (35));
dcl  ioa_$rs	        entry () options (variable);
dcl  ioa_$rsnnl	        entry () options (variable);
dcl  mail_table_initializer_$set_dft_proj
		        entry (char (*), char (*), fixed bin (35));
dcl  mc_check_access_$log_in_as_daemon
		        entry (char (*), char (*), fixed bin (35));
dcl  merge_access_audit_flags_
		        entry (bit (36) aligned, bit (36) aligned)
		        returns (bit (36) aligned);
dcl  pnt_manager_$admin_get_entry
		        entry (char (*), ptr, fixed bin (35));
dcl  pnt_manager_$login_get_entry
		        entry (char (*), char (*), ptr,
		        fixed bin (35));
dcl  pnt_manager_$update_entry
		        entry (ptr, bit (1) aligned,
		        bit (1) aligned, fixed bin (35));
dcl  scramble_	        entry (char (8)) returns (char (8));
dcl  ttt_info_$decode_type  entry (fixed bin, char (*), fixed bin (35));
dcl  ttt_info_$encode_type  entry (char (*), fixed bin, fixed bin (35));
dcl  up_sat_$make_sat_hash  entry (ptr, fixed bin, ptr, char (*), fixed bin (35));

/* External */

dcl  (as_error_table_$already_in_notify_msg,
     as_error_table_$bad_anon_pw,
     as_error_table_$bad_password,
     as_error_table_$bad_personid,
     as_error_table_$bad_project,
     as_error_table_$breach,
     as_error_table_$breach_msg,
     as_error_table_$cant_give_dft_auth,
     as_error_table_$cant_give_that_authorization,
     as_error_table_$dialup_error,
     as_error_table_$must_change,
     as_error_table_$must_use_generate_pw,
     as_error_table_$no_change,
     as_error_table_$no_line_permission,
     as_error_table_$not_in_pdt,
     as_error_table_$operator_not_allowed,
     as_error_table_$password_expired,
     as_error_table_$password_locked,
     as_error_table_$password_probe_mail_msg,
     as_error_table_$password_probe1_mail_msg,
     as_error_table_$password_trap,
     as_error_table_$pdt_missing,
     as_error_table_$person_auth_msg,
     as_error_table_$terminal_auth_msg,
     as_error_table_$too_many_bad_pw) fixed bin (35) ext static;
dcl  (error_table_$bad_arg,
     error_table_$bad_password,
     error_table_$id_not_found,
     error_table_$messages_off,
     error_table_$smallarg,
     error_table_$wakeup_denied) fixed bin (35) ext static;

/* Constant */

dcl  ALLOW_RETRY	        bit (1) aligned initial ("1"b)
		        internal static options (constant);
dcl  FALSE	        bit (1) aligned initial ("0"b)
		        internal static options (constant);
dcl  ME		        char (9) initial ("uc_login_")
		        internal static options (constant);
dcl  SYSTEM_LOW	        bit (72) aligned initial (""b)
		        internal static options (constant);
dcl  TRUE		        bit (1) aligned initial ("1"b)
		        internal static options (constant);
dcl  USECS_PER_DAY	        fixed bin (71) initial (86400000000)
		        internal static options (constant);

/* Builtin */

dcl  (addr, addrel, clock, length, mod, null, rtrim, string, substr, unspec)
		        builtin;

/* Conditions */

dcl  seg_fault_error        condition;
%page;
/* Program */

/**** TBS: Fault Handler */
	call Setup ();
	call Validate_Personid ();
	if flags.check_password then
	     call Check_Password_Flags ();
	if flags.check_physical_security_breach then
	     call Check_Physical_Security_Breach ();
	if flags.check_change_arguments then
	     call Process_Change_Arguments ();
	if flags.check_authorization_argument then
	     call Check_Authorization_Argument ();
	call Validate_Projectid ();
	if flags.check_anonymous_password then
	     call Check_Anonymous_Password ();
	if flags.check_daemon_access then
	     call Check_Daemon_Access ();
	if flags.check_channel_access then
	     call Check_Channel_Access ();
	call Process_Attributes ();
	call Check_Access_Authorization ();
	if flags.check_channel_access_class then
	     call Check_Channel_Access_Class ();

	call Login ();

RETURN:
	P_code = code;
	if maybe_update_pnte then
	     if unspec (old_pnte) ^= unspec (pnte) then
		call Update_Pnte ();
	return;
%page;
Setup:
     procedure ();

	uc_validate_info_ptr = P_uc_validate_info_ptr;
	utep = P_utep;
	code = 0;

	ansp = as_data_$ansp;
	ip = as_data_$rs_ptrs (0);
	satp = as_data_$satp;
	whoptr = as_data_$whoptr;

	anstbl.current_time = clock ();

	unspec (flags) = ""b;
	if ute.process_type = PT_INTERACTIVE then do;
	     flags.check_password = TRUE;
	     flags.check_physical_security_breach = TRUE;
	     flags.check_change_arguments = TRUE;
	     flags.check_authorization_argument = TRUE;
	     flags.check_daemon_access = FALSE;
	     flags.check_channel_access = TRUE;
	     flags.check_channel_access_class = TRUE;
	end;
	else if ute.process_type = PT_ABSENTEE then
	     do;
	     flags.check_password = FALSE;
	     flags.check_physical_security_breach = FALSE;
	     flags.check_change_arguments = FALSE;
	     flags.check_authorization_argument = FALSE;
	     flags.check_daemon_access = FALSE;
	     flags.check_channel_access = FALSE;
	     flags.check_channel_access_class = FALSE;
	end;
	else if ute.process_type = PT_DAEMON then
	     do;
	     flags.check_password = FALSE;
	     flags.check_physical_security_breach = FALSE;
	     flags.check_change_arguments = TRUE;
	     flags.check_authorization_argument = TRUE;
	     flags.check_daemon_access = TRUE;
	     flags.check_channel_access = FALSE;
	     flags.check_channel_access_class = FALSE;
	end;
	else
	     call Abort (error_table_$bad_arg, ^ALLOW_RETRY);

	if ^uc_validate_info.flags.check_channel_access then
	     flags.check_channel_access = FALSE;

	if ute.anonymous = 1 then
	     do;
	     flags.anonymous = TRUE;
	     flags.check_password = FALSE;
	     flags.check_anonymous_password = uc_validate_info.flags.check_anonymous_password;
	     flags.check_change_arguments = FALSE;
	end;
	else
	     flags.anonymous = FALSE;

	anstbl.session_uid_counter = anstbl.session_uid_counter + 1;
	ute.session_uid = anstbl.session_uid_counter;
	maybe_update_pnte = FALSE;
	return;
     end Setup;
%page;
Validate_Personid:
     procedure ();

dcl  password	        char (32) automatic;

	if ute.person = "" then
	     call Abort (as_error_table_$bad_personid, ALLOW_RETRY);

	if flags.anonymous then
	     if ute.project = "" then
		do;
		ute.project = ute.person;
		return;
	     end;

	if flags.check_password then
	     do;
	     if ute.login_flags.cpw then
		password = ute.old_password;
	     else
		password = uc_validate_info.password;

	     unspec (pnte) = ""b;
	     call pnt_manager_$login_get_entry (ute.person, password, addr (pnte),
		code);
	end;
	else
	     call pnt_manager_$admin_get_entry (ute.person, addr (pnte), code);

	if code = error_table_$id_not_found then
	     call Abort (as_error_table_$bad_personid, ALLOW_RETRY);
	else if code ^= error_table_$bad_password & code ^= 0 then
	     do;
	     call Log_Error_with_Code (SL_LOG_BEEP, code,
		"Reading PNT entry for ^a.", ute.person);
	     call Abort (as_error_table_$dialup_error, ^ALLOW_RETRY);
	end;

/* If we get here, we were able to read the PNT entry.  The password,
   however, may still have been incorrect. */

	old_pnte = pnte;
	maybe_update_pnte = TRUE;

	ute.person = substr (pnte.user_id, 1, length (ute.person));
	if ute.project = "" then
	     ute.project = pnte.default_project;

	if code = error_table_$bad_password then
	     do;
	     call Bad_Password ();
	     call Abort (as_error_table_$bad_password, ALLOW_RETRY);
	end;

/**** Check to see if user is login in as an operator.  Validate his
      authorization to do so. */

	if ute.login_flags.operator then
	     if ^pnte.flags.operator then
		call Abort (as_error_table_$operator_not_allowed,
		     ALLOW_RETRY);

/**** Personid is validated */

	return;
%page;
Bad_Password:
	procedure ();

dcl  mail_for_user	        char (128) automatic;
dcl  message	        char (256) automatic;

	     pnte.n_bad_pw = pnte.n_bad_pw + 1;
	     pnte.n_bad_pw_since_good = pnte.n_bad_pw_since_good + 1;
	     pnte.time_last_bad_pw = anstbl.current_time;
	     pnte.last_bad_pw_reported = FALSE;
	     pnte.bad_pw_term_id = ute.tty_id_code;
	     pnte.bad_pw_term_type = ute.terminal_type;
	     pnte.bad_pw_line_type = ute.line_type;

	     if pnte.n_bad_pw_since_good = 1 then
		message =
		     Convert_Message (as_error_table_$password_probe1_mail_msg);
	     else
		message = Convert_Message (as_error_table_$password_probe_mail_msg);

	     if message ^= "" then
		do;
		if pnte.n_bad_pw_since_good = 1 then
		     call ioa_$rs (message, mail_for_user, (0), ute.person,
			ute.terminal_type, ute.tty_id_code);
		else
		     call ioa_$rs (message, mail_for_user, (0), ute.person,
			pnte.n_bad_pw_since_good, ute.terminal_type,
			ute.tty_id_code);

		call Send_User_Mail (ute.person, ute.project, mail_for_user,
		     pnte.default_person_authorization, code);
		if (code ^= 0) & (code ^= error_table_$wakeup_denied)
		     & (code ^= error_table_$messages_off) then
		     do;
		     call Send_User_Mail (ute.person, (pnte.default_project),
			mail_for_user, pnte.default_person_authorization, code);
		     if code = 0 then
			pnte.flags.last_bad_pw_reported = "1"b;
		end;
		else
		     pnte.flags.last_bad_pw_reported = "1"b;
	     end;
	     if mod (pnte.n_bad_pw_since_good, installation_parms.login_tries) = 0 then do;
		call Log_Coded_Error (SL_LOG_BEEP,
		     as_error_table_$too_many_bad_pw, ute.person,
		     ute.project, ute.tty_name, ute.terminal_type,
		     ute.tty_id_code);
	     end;
	     return;
	end Bad_Password;

     end Validate_Personid;
%page;
Check_Password_Flags:
     procedure ();

	if ute.login_flags.cpw & ^ute.login_flags.generate_pw & pnte.flags.generate_pw
	then
	     call Abort (as_error_table_$must_use_generate_pw, ALLOW_RETRY);

	if installation_parms.password_expiration_interval ^= 0 then
	     if ((anstbl.current_time - pnte.time_last_good_pw)
		> (installation_parms.password_expiration_interval
		* USECS_PER_DAY))
		& ((anstbl.current_time - pnte.user_validated_time)
		> (installation_parms.password_expiration_interval
		* USECS_PER_DAY)) then
		do;
		uc_validate_info.password_unused_too_long = TRUE;
		uc_validate_info.password_interval = installation_parms.password_expiration_interval;
		call Abort (as_error_table_$password_expired,
		     ^ALLOW_RETRY);
	     end;

	if ^ute.login_flags.cpw then
	     do;
	     if pnte.flags.must_change then
		do;
		if ^pnte.flags.generate_pw then
		     call Abort (as_error_table_$must_change, ALLOW_RETRY);
		else call Abort (as_error_table_$must_use_generate_pw,
			ALLOW_RETRY);
	     end;

	     if installation_parms.password_change_interval ^= 0 then
		if (anstbl.current_time - pnte.time_pw_changed)
		     > (installation_parms.password_change_interval
		     * USECS_PER_DAY) then
		     do;
		     uc_validate_info.password_expired = TRUE;
		     uc_validate_info.password_interval = installation_parms.password_change_interval;
		     if ^pnte.flags.generate_pw then
			call Abort (as_error_table_$must_change,
			     ALLOW_RETRY);
		     else call Abort (as_error_table_$must_use_generate_pw,
			     ALLOW_RETRY);
		end;
	end;

	pnte.n_good_pw = pnte.n_good_pw + 1;
	pnte.time_last_good_pw = anstbl.current_time;

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* We used to check pnte.flags.last_bad_pw_reported here to decide whether   */
/* to print the message "Your password was ..." on the terminal upon login.  */
/* Since it is possible (and likely) that the user logging in will have      */
/* never seen the mail sent telling him that his password was used	       */
/* incorrectly, we remove that check and force the message on his terminal.  */
/* The theory is that if there really is someone trying to guess a password, */
/* and he does manage to succeed and get in, he will most likely delete any  */
/* mail telling the REAL user that someone was hacking.		       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if pnte.n_bad_pw_since_good > 0 &
	     ute.tag ^= TAG_UFT then			/* UFT processes cannot send msgs to user */
	     do;
	     uc_validate_info.last_bad_pw_info.time = pnte.time_last_bad_pw;
	     uc_validate_info.last_bad_pw_info.number =
		pnte.n_bad_pw_since_good;
	     uc_validate_info.last_bad_pw_info.terminal_type =
		pnte.bad_pw_term_type;
	     uc_validate_info.last_bad_pw_info.terminal_id =
		pnte.bad_pw_term_id;
	     uc_validate_info.last_bad_pw_info.line_type =
		pnte.bad_pw_line_type;
	     pnte.last_bad_pw_reported = "1"b;
	end;
	else do;					/* better than returning garbage */
	     uc_validate_info.last_bad_pw_info.time = 0;
	     uc_validate_info.last_bad_pw_info.number = 0;
	     uc_validate_info.last_bad_pw_info.terminal_type = "";
	     uc_validate_info.last_bad_pw_info.terminal_id = "";
	     uc_validate_info.last_bad_pw_info.line_type = 0;
	end;

	if pnte.last_bad_pw_reported then
	     pnte.n_bad_pw_since_good = 0;

	if pnte.flags.trap then do;
	     call Log_Coded_Error (SL_LOG_BEEP,
		as_error_table_$password_trap, ute.person, ute.project,
		ute.tty_name, ute.terminal_type, ute.tty_id_code);
	end;
	if (pnte.flags.pw_time_lock & anstbl.current_time < pnte.password_timelock)
	     | pnte.flags.lock then
	     call Abort (as_error_table_$password_locked, ^ALLOW_RETRY);

	if ute.login_flags.cpw then
	     if pnte.flags.nochange then
		call Abort (as_error_table_$no_change, ALLOW_RETRY);
	     else
		do;
		pnte.password = uc_validate_info.password;
		pnte.time_pw_changed = anstbl.current_time;
		pnte.flags.must_change = FALSE;
		uc_validate_info.changed_password = TRUE;
	     end;
	return;
     end Check_Password_Flags;
%page;
Check_Physical_Security_Breach:
     procedure ();

dcl  maximum_authorization  bit (72) aligned automatic;

	if flags.anonymous then
	     maximum_authorization = SYSTEM_LOW;
	else
	     maximum_authorization = pnte.person_authorization (2);

	if ^aim_check_$greater_or_equal (maximum_authorization,
	     uc_validate_info.channel_info.access_class_range (1)) then
	     do;
	     call Log_Coded_Error (SL_LOG_BEEP, as_error_table_$breach_msg,
		ute.person, ute.project, ute.tty_name, ute.terminal_type,
		ute.tty_id_code);

	     auth_string_octal =
		display_access_class_ (maximum_authorization);
	     call convert_access_class_$to_string_short (
		maximum_authorization, auth_string, code);
	     if code ^= 0 then
		if code = error_table_$smallarg then
		     code = 0;
		else auth_string = "";
	     call Log_Coded_Error (SL_LOG, as_error_table_$person_auth_msg,
		auth_string_octal, auth_string);

	     auth_string_octal = display_access_class_$range (
		uc_validate_info.channel_info.access_class_range);
	     call convert_access_class_$to_string_range_short (
		uc_validate_info.channel_info.access_class_range,
		auth_string, code);
	     if code ^= 0 then
		if code = error_table_$smallarg then
		     code = 0;
		else auth_string = "";
	     call Log_Coded_Error (SL_LOG, as_error_table_$terminal_auth_msg,
		auth_string_octal, auth_string);

	     call Abort (as_error_table_$breach, ^ALLOW_RETRY);
	end;
	return;
     end Check_Physical_Security_Breach;
%page;
Process_Change_Arguments:
     procedure ();

	if ute.login_flags.cdp then
	     if ^pnte.flags.nochange then
		do;
		pnte.default_project = substr (ute.project, 1, length (pnte.default_project));
		uc_validate_info.changed_default_project = TRUE;
	     end;
	     else
		call Abort (as_error_table_$no_change, ALLOW_RETRY);

	if ute.login_flags.cda then
	     if ^pnte.flags.nochange then
		do;
		pnte.default_person_authorization = ute.process_authorization;
		uc_validate_info.default_authorization_changed = TRUE;
	     end;
	     else
		call Abort (as_error_table_$no_change, ALLOW_RETRY);


	if uc_validate_info.changed_default_project then
	     do;
	     call mail_table_initializer_$set_dft_proj (rtrim (pnte.user_id),
		rtrim (pnte.default_project), code);
	     if code ^= 0 then
		call Log_Error_with_Code (SL_LOG_BEEP, code,
		     "Changing Mail Table default project for ^a to ^a",
		     pnte.user_id, pnte.default_project);
	end;
	return;
     end Process_Change_Arguments;
%page;
Check_Authorization_Argument:
     procedure ();

	if ^ute.login_flags.auth_given then
	     if flags.anonymous then
		ute.process_authorization = SYSTEM_LOW;
	     else
		ute.process_authorization = pnte.default_person_authorization;
	return;
     end Check_Authorization_Argument;
%page;
Validate_Projectid:
     procedure ();

dcl  ans		        char (64) automatic;
dcl  i		        fixed bin (35) automatic;
dcl  pdt_entryname	        char (32) automatic;
dcl  pdt_htp	        ptr automatic;
dcl  temp_person_name       char (32) automatic;

lookup_loop:
	call hash_$search (as_data_$sat_htp, ute.project, i, code);
	if code ^= 0 then
	     call Abort (as_error_table_$bad_project, ALLOW_RETRY);

	satep = addr (sat.project (i));
	if ute.project ^= project.project_id then
	     if ute.project ^= project.alias then
		do;
		call Log_Error_with_Code (SL_LOG_SILENT, -1,
		     "sat.ht has ""^a"", SAT has ""^a"" at ^p",
		     ute.project, project.project_id, satep);
		call up_sat_$make_sat_hash (satp, sat.n_projects,
		     as_data_$sat_htp, ans, code);
		if code ^= 0 then
		     do;
		     call Log_Error_with_Code (SL_LOG, code,
			"Unable to rehash sat.ht: ^a", ans);
		     call Abort (as_error_table_$dialup_error,
			^ALLOW_RETRY);
		end;
		else
		     goto lookup_loop;		/* go try the lookup again */
	     end;

	if project.state ^= 1 then
	     do;
	     call Log_Error_with_Code (SL_LOG_SILENT, -1,
		"Project ^a, state ^d, still in sat.ht",
		project.project_id, project.state);
	     call Abort (as_error_table_$bad_project, ALLOW_RETRY);
	end;

	ute.project = project.project_id;		/* in case alias */
						/* was used.     */

	if project.pdt_ptr ^= null () then
	     pdtp = project.pdt_ptr;
	else
	     do;
	     pdt_entryname = rtrim (project.project_id) || ".pdt";
	     call initiate_file_ (as_data_$pdtdir, pdt_entryname, RW_ACCESS,
		pdtp, (0), code);
	     if code ^= 0 then
		do;
		call Log_Error_with_Code (SL_LOG_SILENT, code, "^a>^a",
		     as_data_$pdtdir, project.project_id);
		call Abort (as_error_table_$pdt_missing, ALLOW_RETRY);
	     end;
	     project.pdt_ptr = pdtp;
	end;

	if project.rs_number < 0 | project.rs_number > whotab.n_rate_structures
	then
	     do;
	     call Log_Error_with_Code (SL_LOG_BEEP, -1,
		"Project ^a has invalid rate_structure number ^d. Using rate_structure 0.",
		project.project_id, project.rs_number);
	     ute.rs_number = 0;
	end;
	else
	     ute.rs_number = project.rs_number;

	temp_person_name = ute.person;

	if flags.anonymous then
	     if ^project.at.anonymous then
		call Abort (as_error_table_$not_in_pdt, ALLOW_RETRY);
	     else
		temp_person_name = "*";

	pdtep = null ();

	on seg_fault_error
	     begin;
	     call Log_Error_with_Code (SL_LOG_BEEP, -1,
		"PDT for project ^a has its damage switch set.  Login for user ^a refused.",
		ute.project, ute.person);
	     call Abort (as_error_table_$dialup_error, ^ALLOW_RETRY);
	end;
	i = pdt.ht_relp;
	revert seg_fault_error;

	if pdt.ht_relp > 0 then
	     do;
	     pdt_htp = addrel (pdtp, pdt.ht_relp);
	     if pdt_htp -> htable.id ^= "ht01" & pdt_htp -> htable.id ^= "ht02"
	     then
		do;
		call Log_Error_with_Code (SL_LOG_BEEP, -1,
		     "No hash table at ^o of ^a.pdt", pdt.ht_relp,
		     project.project_id);
	     end;
	     else
		do;
		call hash_$search (pdt_htp, temp_person_name, i, code);
		if code ^= 0 then
		     call Abort (as_error_table_$not_in_pdt, ALLOW_RETRY);
		pdtep = addr (pdt.user (i));
		if user.state ^= 1 then
		     do;
		     call Log_Error_with_Code (SL_LOG_BEEP, -1,
			"User ^a, state ^d, still in hash table of ^a.pdt",
			temp_person_name, user.state, project.project_id);
		     call Abort (as_error_table_$not_in_pdt, ALLOW_RETRY);
		end;

		if user.person_id ^= temp_person_name then
		     do;
		     call Log_Error_with_Code (SL_LOG_BEEP, -1,
			"Hash table of ^a.pdt has ^a, pdt has ^a, at ^p",
			project.project_id, temp_person_name,
			user.person_id, pdtep);
		     pdtep = null ();
		end;
	     end;
	end;

	if pdtep = null then
	     do i = 1 to pdt.current_size while (pdtep = null ());
	     pdtep = addr (pdt.user (i));
	     if user.state = 1 then
		do;
		if user.person_id ^= temp_person_name then
		     pdtep = null ();
	     end;
	     else
		pdtep = null ();
	end;

	if pdtep = null () then
	     call Abort (as_error_table_$not_in_pdt, ALLOW_RETRY);

	ute.pdtep = pdtep;
	ute.uprojp = satep;
	return;
     end Validate_Projectid;
%page;
Check_Anonymous_Password:
     procedure ();

	if user.password ^= "" then
	     if scramble_ ((user.password)) ^= uc_validate_info.password then
		call Abort (as_error_table_$bad_anon_pw, ALLOW_RETRY);
	return;
     end Check_Anonymous_Password;
%page;
Check_Daemon_Access:
     procedure ();

dcl  group_id	        char (32) automatic;

	call ioa_$rsnnl ("^a.^a.z", group_id, (0), ute.person, ute.project);
	call mc_check_access_$log_in_as_daemon (group_id, ute.tty_name, code);
	if code ^= 0 then
	     call Abort (code, ^ALLOW_RETRY);
	return;
     end Check_Daemon_Access;
%page;
Check_Channel_Access:
     procedure ();

dcl  group_id	        char (32) automatic;
dcl  mode		        bit (36) aligned automatic;
dcl  type		        char (8) automatic;

	if ute.login_flags.dial_pw then
	     type = "dial";
	else if ute.login_flags.slave_pw then
	     type = "slave";
	else
	     type = "login";

	call ioa_$rsnnl ("^[anonymous^s^;^a^].^a.^a", group_id, (0),
	     (ute.anonymous = 1), ute.person, ute.project, ute.tag);

	call hcs_$get_user_access_modes (as_data_$rcpdir,
	     rtrim (ute.tty_name) || ".acs", group_id, 0, mode, (""b), code);
	if code ^= 0 then
	     do;
	     call Log_Error_with_Code (SL_LOG, code,
		"Unable to check access for channel ^a.", ute.tty_name);
	     mode = ""b;
	end;

	if (mode & RW_ACCESS) ^= RW_ACCESS then
	     call Abort (as_error_table_$no_line_permission, ^ALLOW_RETRY);
	return;
     end Check_Channel_Access;
%page;
Process_Attributes:
     procedure ();

dcl  bstemp	        bit (36) aligned automatic;

/**** Don't let user set attributes disallowed by SAT or PDT */
	string (ute.ur_at) = string (ute.ur_at) &
	     ((string (user.at) & string (project.at))
	     | USER_ATTRIBUTES_always_allowed);

/**** Turn on attributes which user cannot set. */
	string (ute.at) =
	     string (ute.at) | ^USER_ATTRIBUTES_settable_by_user;

/**** Turn on defaults for attributes user didn't specify. */
	string (ute.at) = string (ute.at) |
	     (string (user.at) & USER_ATTRIBUTES_default_in_pdt &
	     ^string (ute.ur_at));

/**** Turn off attributes denied by SAT or PDT */
	string (ute.at) = string (ute.at) &
	     ((string (user.at) & string (project.at))
	     | USER_ATTRIBUTES_always_allowed);

/**** Remember attributes set by user. */
	bstemp = string (ute.at) &
	     (string (ute.ur_at) | USER_ATTRIBUTES_settable_by_user);

/**** Turn off attributes user is allowed to set. */
	string (ute.at) = string (ute.at) &
	     ^USER_ATTRIBUTES_settable_by_user;

/**** Set user-settable attributes according to user wishes. */
	string (ute.at) = string (ute.at) | bstemp;

	if ute.at.guaranteed_login then
	     ute.at.nobump = "1"b;

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* The process-saving attributes, disconnect_ok and save_on_disconnect, need */
/* special handling.  After the above logic, each is on in ute.at only if it */
/* was on in both SAT and PDT.				       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

/****  First we force both on if both were on in SAT. */
	if project.at.save_on_disconnect & project.at.disconnect_ok then
	     ute.at.save_on_disconnect, ute.at.disconnect_ok = "1"b;

/****  Then turn on save_on_disconnect if on in PDT, even if off in SAT */
	if user.at.save_on_disconnect then
	     ute.at.save_on_disconnect = "1"b;

/****  Process saving is impossible for anonymous users. */
	if flags.anonymous then
	     ute.at.save_on_disconnect, ute.at.disconnect_ok = ""b;

     end Process_Attributes;
%page;
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* Here we determine the user process authorization and maximum	       */
/* authorization.  We also set the audit flags.			       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

Check_Access_Authorization:
     procedure ();

/**** Currently, we only allow anonymous users to log in at system_low
      authorization.  To lift this restriction, all that is necessary
      is to delete the following statement. */
	if flags.anonymous then
	     ute.process_authorization = SYSTEM_LOW;

	ute.process_authorization_range (*) = ""b;

/**** Set the process minimum authorization to the maximum of the following */
	authorization (1) = user.user_authorization (1);
	authorization (2) = project.project_authorization (1);
	if ute.anonymous = 1 then			/* anonymous have no pnte */
	     authorization (3) = project.project_authorization (1);
	else authorization (3) = pnte.person_authorization (1);
	call convert_access_class_$maximum (authorization, 3, ute.process_authorization_range (1));

/**** Set the process maximum authorization to the minimum of the following */
	authorization (1) = user.user_authorization (2);
	authorization (2) = project.project_authorization (2);
	if ute.anonymous = 1 then			/* anonymous have no pnte */
	     authorization (3) = project.project_authorization (2);
	else authorization (3) = pnte.person_authorization (2);
	call convert_access_class_$minimum (authorization, 3, ute.process_authorization_range (2));

/**** Merge the audit flags from the SAT and the PNT.  If the user is
      anonymous, there is no PNT entry se we set the ute.audit to the SAT
      value. */
	if flags.anonymous then
	     ute.audit = project.audit;
	else
	     ute.audit = merge_access_audit_flags_ (project.audit, pnte.audit);

/**** Compare the requested or default authorization with the computed
      authorization range and reject the login if this authorization is
      outside the allowed range. */
	if ^aim_check_$in_range (ute.process_authorization,
	     ute.process_authorization_range) then
	     do;
	     if ute.login_flags.auth_given | ute.process_type = PT_ABSENTEE
	     then
		call Abort (as_error_table_$cant_give_that_authorization,
		     ALLOW_RETRY);
	     else
		call Abort (as_error_table_$cant_give_dft_auth,
		     ALLOW_RETRY);
	end;

     end Check_Access_Authorization;
%page;
Check_Channel_Access_Class:
     procedure ();

	if ^aim_check_$in_range (ute.process_authorization,
	     uc_validate_info.channel_info.access_class_range) then do;

	     if ute.login_flags.auth_given | ute.process_type = PT_ABSENTEE then
		call Abort (as_error_table_$cant_give_that_authorization,
		     ALLOW_RETRY);
	     else
		call Abort (as_error_table_$cant_give_dft_auth,
		     ALLOW_RETRY);
	end;
     end Check_Channel_Access_Class;
%page;
Login:
     procedure ();

dcl  temp_code	        fixed bin (35) automatic;
dcl  temp_coded_type        fixed bin automatic;
dcl  temp_terminal_type     char (32) automatic;

	ute.login_result = 0;
	ute.active = NOW_LOGGED_IN;
	ute.login_time = anstbl.current_time;
	call as_access_audit_$login (utep, "");
	if ^flags.anonymous then
	     do;

/**** Tell caller about last login info */

	     uc_validate_info.last_login_info.time = user.last_login_time;
	     if user.last_login_type = 0 then		/* no such thing, old type */
		temp_coded_type = user.last_login_line_type;
	     else
		temp_coded_type = user.last_login_type;
	     call ttt_info_$decode_type (temp_coded_type, temp_terminal_type, code)
		;
	     if code ^= 0 then
		temp_terminal_type = "UNKNOWN";
	     uc_validate_info.last_login_info.terminal_type =
		temp_terminal_type;
	     uc_validate_info.last_login_info.terminal_id =
		user.last_login_unit;
	     uc_validate_info.last_login_info.line_type =
		user.last_login_line_type;

/**** Update last login info for next time */

	     user.last_login_time = anstbl.current_time;
	     user.last_login_unit =
		ute.tty_id_code;
	     call ttt_info_$encode_type (ute.terminal_type,
		temp_coded_type, temp_code);
	     user.last_login_type = temp_coded_type;
	     if temp_code ^= 0 then
		user.last_login_type = 0;
	     user.last_login_line_type = ute.line_type;

/**** Tell caller about number of disconnected processes. */

	     uc_validate_info.number_disconnected_processes =
		user.n_disconnected;
	end;

/**** Update the who table */

	call Update_Whotable ();

/**** Notify other login instances of this login */

	call Notify_Other_Instances ();
	code = 0;
	return;
%page;
Notify_Other_Instances:
	procedure ();

dcl  code		        fixed bin (35) automatic;
dcl  i		        fixed bin automatic;
dcl  mail_for_user	        char (256);
dcl  notified_instance      bit (1) aligned automatic;
dcl  temp_lth	        fixed bin (21) automatic;
dcl  temp_string	        char (100) automatic;
dcl  temp_utep	        ptr automatic;

	     notified_instance = FALSE;
	     do i = 1 to anstbl.current_size while (^notified_instance);
		temp_utep = addr (anstbl.entry (i));
		if temp_utep ^= utep &
		     temp_utep -> ute.active >= NOW_HAS_PROCESS &
		     temp_utep -> ute.anonymous = 0 &
		     temp_utep -> ute.person = ute.person &
		     ^temp_utep -> ute.disconnected &
		     temp_utep -> ute.tag ^= TAG_UFT then do;
		     temp_string = Convert_Message (as_error_table_$already_in_notify_msg);
		     call ioa_$rsnnl (temp_string, mail_for_user, temp_lth,
			ute.person, ute.person, ute.project,
			ute.terminal_type, ute.tty_id_code);
		     call Send_User_Mail (temp_utep -> ute.person,
			temp_utep -> ute.project,
			substr (mail_for_user, 1, temp_lth),
			ute.process_authorization, code);
		     if code = 0 then
			notified_instance = TRUE;
		     else do;
			call asu_$blast_user (temp_utep, mail_for_user,
			     (""), code);
			if code = 0 then
			     notified_instance = TRUE;
		     end;
		end;
	     end;
	     return;
	end Notify_Other_Instances;
     end Login;
%page;
Abort:
     procedure (P_code, P_allow_retry);

dcl  P_code	        fixed bin (35) parameter;
dcl  P_allow_retry	        bit (1) aligned parameter;

dcl  status_code_string     char (8) aligned automatic;

	code = P_code;
	if code ^= 0 then
	     call convert_status_code_ (code, status_code_string, (""));
	else status_code_string = "";

	if P_allow_retry then
	     ute.login_result = 2;			/* allow retry */
	else ute.login_result = 1;			/* don't allow retry */
	ute.failure_reason = 1;			/* 1 = "lg_ctl_" said no */
	call as_access_audit_$login (utep, (status_code_string));
	goto RETURN;
     end Abort;
%page;
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* Log_Error_with_Code: log an error via sys_log_$general and continue       */
/* execution.						       */
/*							       */
/* Syntax:  call Log_Error_with_Code (severity, code, ioa_ctl, args);	       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

Log_Error_with_Code:
     procedure options (variable);

dcl  cu_$arg_list_ptr       entry returns (ptr);
dcl  sys_log_$general       entry (ptr);

	sl_info = sl_info_sev_code_msg;
	sl_info.caller = ME;
	sl_info.arg_list_ptr = cu_$arg_list_ptr ();
	call sys_log_$general (addr (sl_info));

     end Log_Error_with_Code;

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* Log_Coded_Error: log an error via sys_log_$general and continue	       */
/* execution.						       */
/*							       */
/* Syntax:  call Log_Error_with_Code (severity, ioa_ctl_in_error_code, args); */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


Log_Coded_Error:
     procedure options (variable);

dcl  cu_$arg_list_ptr       entry returns (ptr);
dcl  sys_log_$general       entry (ptr);

	sl_info = sl_info_sev_coded_msg;
	sl_info.caller = ME;
	sl_info.arg_list_ptr = cu_$arg_list_ptr ();
	call sys_log_$general (addr (sl_info));

     end Log_Coded_Error;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
%page;
Convert_Message:
     procedure (P_code) returns (char (100) varying);

dcl  P_code	        fixed bin (35) parameter;
dcl  message	        char (100) aligned automatic;

	call convert_status_code_ (P_code, (""), message);
	return (rtrim (message));

     end Convert_Message;
%page;
Update_Pnte:
     procedure ();

	call pnt_manager_$update_entry (addr (pnte),
	     (uc_validate_info.changed_password), FALSE, code);
	maybe_update_pnte = FALSE;
	if code ^= 0 then
	     do;
	     call Log_Error_with_Code (SL_LOG_BEEP, code,
		"Error updating PNT entry for ^a.", ute.person);
	     call Abort (as_error_table_$dialup_error, ALLOW_RETRY);
	end;
	return;
     end Update_Pnte;
%page;
%page;
Send_User_Mail:
     procedure (P_personid, P_projectid, P_message, P_access_class, P_code);

dcl  P_personid	        char (*) parameter;
dcl  P_projectid	        char (*) parameter;
dcl  P_message	        char (*) parameter;
dcl  P_access_class	        bit (72) aligned parameter;
dcl  P_code	        fixed bin (35) parameter;

dcl  pdt_name	        char (32) automatic;
dcl  send_mail_$access_class entry (char (*), char (*), ptr, bit (72) aligned, fixed bin (35));

	unspec (send_mail_info) = ""b;
	send_mail_info.version = send_mail_info_version_2;
	send_mail_info.sent_from = "login";
	send_mail_info.switches.wakeup = TRUE;
	send_mail_info.always_add = TRUE;

	call ioa_$rsnnl ("^a.^a", pdt_name, (0), P_personid, P_projectid);
	call send_mail_$access_class (pdt_name, rtrim (P_message), addr (send_mail_info), P_access_class, code);
	if (code = 0) | (code = error_table_$wakeup_denied)
	     | (code = error_table_$messages_off) then
	     P_code = 0;
	else P_code = code;
	return;
%page; %include send_mail_info;
     end Send_User_Mail;
%page;
Update_Whotable:
     procedure ();

/**** Publish the login in the whotab */

dcl  whotab_idx	        fixed bin automatic;

	whoptr = as_data_$whoptr;
	whotab.n_users = whotab.n_users + 1;
	if ute.at.nolist then do;
	     whotab_idx = 0;
	     ute.whotabx = 0;
	end;
	else do;
	     if whotab.freep = 0 then do;		/* no free slots up to max */
		whotab.laste = whotab.laste + 1;
		whotab_idx = whotab.laste - whotab.laste_adjust;
	     end;
	     else do;				/* have a free slot */
		whotab_idx = whotab.freep;
		whotab.freep = whotab.e (whotab_idx).chain;
	     end;
	     ute.whotabx = whotab_idx;
	     if ute.anonymous = 1 then
		whotab.e (whotab_idx).person = "anonymous";
	     else whotab.e (whotab_idx).person = ute.person;
	     whotab.e (whotab_idx).project = ute.project;
	     whotab.e (whotab_idx).units = 0;		/* filled in later */
	     whotab.e (whotab_idx).timeon = anstbl.current_time;
	     whotab.e (whotab_idx).anon = ute.anonymous;
	     whotab.e (whotab_idx).stby = 0;		/* later */
	     whotab.e (whotab_idx).active = NOW_LOGGED_IN;
	     whotab.e (whotab_idx).idcode = ute.tty_id_code;
	     whotab.e (whotab_idx).group = "";		/* later */
	     whotab.e (whotab_idx).cant_bump_until = 0;	/* later */
	     whotab.e (whotab_idx).proc_type = ute.process_type;
	     whotab.e (whotab_idx).process_authorization = ute.process_authorization;
	     whotab.e (whotab_idx).fg_abs, whotab.e (whotab_idx).disconnected, whotab.e (whotab_idx).suspended = FALSE;
	end;

	if ute.process_type = PT_DAEMON then		/* daemon process */
	     whotab.n_daemons = whotab.n_daemons + 1;
	else if ute.process_type = PT_ABSENTEE then do;	/* absentee process */
	     if ute.queue > 0 then do;		/* background absentee */
		whotab.abs_users = whotab.abs_users + 1;
		if whotab_idx > 0 then
		     whotab.e (whotab_idx).fg_abs = FALSE;
	     end;
	     else do;				/* foreground absentee */
		whotab.fg_abs_users = whotab.fg_abs_users + 1;
		if whotab_idx > 0 then
		     whotab.e (whotab_idx).fg_abs = TRUE;
	     end;
	end;
	return;
     end Update_Whotable;

/* format: off */
%page; %include access_mode_values;
%page; %include as_data_;
%page; %include answer_table;
%page; %include dialup_values;
%page; %include hashst;
%page; %include installation_parms;
%page; %include line_types;
%page; %include pdt;
%page; %include pnt_entry;
%page; %include sat;
%page; %include sys_log_constants;
%page; %include uc_validate_info;
%page; %include user_attributes;
%page; %include user_table_entry;
%page; %include user_table_header;
%page; %include whotab;

     end uc_login_;
