/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


	

/****^  HISTORY COMMENTS:
  1) change(88-09-16,GDixon), approve(88-09-20,MCR8009),
     audit(88-09-22,Brunelle), install(88-10-06,MR12.2-1138):
      A) Changed update_seg to avoid reference through unset pointer for
         update_seg delete operation.
                                                   END HISTORY COMMENTS */


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* N__a_m_e:  upd_install_task_							*/
	/*									*/
	/*      This procedure is the lowest-level task translator for the Multics Online Updater.*/
	/* Its input is a single-segment installation request, and its output is a sequence of	*/
	/* primitive subtasks which perform the installation.				*/
	/*									*/
	/* U__s_a_g_e									*/
	/*									*/
	/*      dcl upd_install_task_ entry (bit(36) aligned, ptr, ptr, fixed bin(35), fixed bin,	*/
	/*	ptr, fixed bin, (3) char(168), (3) char(32), (3) fixed bin(5), (3) ptr, 	*/
	/*	(3) fixed bin, (3) ptr, (3) fixed bin, bit(36) aligned, ptr, fixed bin(18),	*/
	/*	bit(1), char(168) aligned, fixed bin(35), fixed bin(35));			*/
	/*									*/
	/*      call upd_install_task_ (ctlw, areap, parentp, acode, asev, taskp, seqno,	*/
	/*	dir, seg, rb, ap, an, np, nn, options, max_length, full_recovery, log_dir, 	*/
	/*	installation_date, de_installation_date);				*/
	/*									*/
	/*  1) ctlw	a Multics Online Updater task control word.(In)			*/
	/*  2) areap	ptr to a caller-supplied area.(In)				*/
	/*  3) parentp	ptr to the caller's argument list.  It may be a null ptr.(In)	*/
	/*  4) acode	0.(In)							*/
	/*		a status code.(Out)						*/
	/*  5) asev	0.(In)							*/
	/*		a severity number.(Out)					*/
	/*  6) taskp	a null ptr.(In)						*/
	/*		ptr to the task control block for this call.(Out)			*/
	/*  7) seqno	a Multics Online Updater task sequence number.(In)		*/
	/*  8) dir (3)	new, old, and target segment directory names.(In)			*/
	/*  9) seg (3)	new, old, and target segment entry names.(In)			*/
	/* 10) rb (3)	ring brackets for target segment.(In)				*/
	/* 11) ap (3)	replace, delete, and add ACL array ptrs.(In)			*/
	/* 12) an (3)	replace, delete, and add ACL array entry dimensions.(In)		*/
	/* 13) np (3)	replace, delete, and add name list ptrs.(In)			*/
	/* 14) nn (3)	replace, delete, and add name list dimensions.(In)		*/
	/* 15) options	option bits:						*/
	/*     bit 1	on if the names of an archive's components are to be added to the	*/
	/*		archive itself.						*/
	/*     bit 2	on if names are to be copied from the "old" segment to the "target".	*/
	/*     bit 3	on if a "special" segment is being installed.			*/
	/*     bit 4	on if installation is to be recorded in a log.			*/
	/*     bit 5	on if information gathering to be deferred until "run" time.	*/
	/*     bit 6	on if max length setting has been explicitly specified.		*/
	/* 16) temp	a null ptr.(In)						*/
	/*		ptr to the information structure allocated by upd_install_task_.(Out)	*/
	/* 17) max_length	the value for the maximum length attribute of added or replaced	*/
	/*		segments.							*/
	/* 18) full_recovery							*/
	/*		on if the "special" target segments can be deleted when the		*/
	/*		ctlw says to run in "de_install" mode.				*/
	/* 19) log_dir								*/
	/*		if bit 4 of "options" is "on", then this argument is the documentation*/
	/*		directory where the description of the installation is to be recorded.*/
	/* 20) installation_date							*/
	/*		a Multics Storage System value for the date and time at which the 	*/
	/*		installation of the modification was performed.			*/
	/*		If this is zero, then the installation is being performed now. (In)	*/
	/* 21) de_installation_date							*/
	/*		a Multics Storage System value for the date and time at which any	*/
	/*		de-installation of the modification is performed.  If this is zero on	*/
	/*		input, then the de-installation is being performed now.(In)		*/
	/*									*/
	/* N__o_t_e_s									*/
	/*									*/
	/*      The type of installation operation to be performed (replace, add, move, or delete)*/
	/* is determined from the directory array, as follows:				*/
	/*									*/
	/*	dir(1)>seg(1)	the path name of the "new" segment to be installed.	*/
	/*	dir(2)>seg(2)	the path name of the "old" segment to be deleted.		*/
	/*	dir(3)>seg(3)	the path name of the "target" segment which is the result	*/
	/*			of the installation.				*/
	/*									*/
	/* The following combinations of path names invoke recognized installation operations:	*/
	/*									*/
	/*	dir(1)>seg(1), dir(2)>seg(2), dir(3)>seg(3)	Replace operation		*/
	/*	dir(1)>seg(1),      ""      , dir(3)>seg(3)	Add operation		*/
	/*	     ""      , dir(2)>seg(2), dir(3)>seg(3)	Move operation		*/
	/*	     ""      , dir(2)>seg(2),      ""		Delete operation		*/
	/*									*/
	/* Any other combination of pathnames is considered invalid, and triggers a		*/
	/* severity 4 error in the Multics Online Updater error handler.			*/
	/*									*/
	/*      If a target segment is to be installed, and an old segment is to be deleted	*/
	/* (as in a replace or move operation), special action is taken if ap(1) (ptr to	*/
	/* the replacement ACL array) and/or np(1) (ptr to the replacement name list) are null.	*/
	/* If ap(1) = null, then the ACL from the "old" segment is copied onto the "target"	*/
	/* segment.  If np(1) = null, then for a move operation, the names of the "old" segment	*/
	/* are placed on the "target" segment; and for a replace operation, the names of the	*/
	/* "new" segment are placed on the "target" segment, if option bit 2 is off;		*/
	/* the names of the "old" segment are placed on the "target" segment, if option bit 2 is	*/
	/* on.  Also, if a target segment is to be installed, and an old segment is to be deleted	*/
	/* (as in a replace or move operation), special action is taken if rb(1) (first ring	*/
	/* bracket for the target segment) is zero.  The rings will be listed on the old segment	*/
	/* and be placed on the target segment.  Otherwise, the caller is responsible for filling	*/
	/* in the ring bracket array (rb(1), rb(2), rb(3)), for the target segment.		*/
	/*									*/
	/*      If option bit 1 is on, then: for a replace operation, if the "new"		*/
	/* segment is an archive, the names of its components are added to the "target" segment;	*/
	/* for an add operation, if the "new" segment is an archive, the names of its components	*/
	/* are added to the "target" segment;  for a move operation, if the "old" segment	*/
	/* is an archive, the names of its components are added to the "target" segment.	*/
	/*									*/
	/*      If option bit 3 is on, then the "target" segment is said to be a "special"	*/
	/* segment, which is accorded the following special attention:			*/
	/*									*/
	/* 1) "special" segments are installed last, after all other segments.		*/
	/* 2) "special" segments are not deleted, and their ACL's are left intact, when		*/
	/*    upd_install_task_ is invoked in "de_install" mode (via the ctlw) after having been	*/
	/*    invoked in "install" mode, if (and only if) the full_recovery switch		*/
	/*    is off.  If it is not off, then "special" segments are deleted as a part of	*/
	/*    "de_install" mode processing.						*/
	/*									*/
	/*      If option bit 5 is on, the the new and old segment unique ids, the names on	*/
	/* the new and old segments, the ACL on the old segment, and the names of new segment	*/
	/* archive components are not gathered until upd_install_task_ is executed in "run" mode.	*/
	/* Otherwise, these things are gathered the first time upd_install_task_ is executed in	*/
	/* any mode.								*/
	/*									*/
	/*      If option bit 6 is off, then the max length attribute of the "target" segment	*/
	/* will acquire a default value.  If the "target" segment is a "special segment", then	*/
	/* the max length attribute will be set to the segments current length.  Otherwise, the	*/
	/* max length will default to sys_info$default_max_length.  If option bit 6 is on, then	*/
	/* the max length will assume the value of the max_length argument passed by the caller.	*/
	/*									*/
	/* N__a_m_e:  upd_install_task_$init						*/
	/*									*/
	/*      This procedure is invoked only once during the installation of a modification,	*/
	/* (a group of related segments that are to be installed at the same time).  Its output	*/
	/* is a sequence of primitive subtasks which type messages to the installer informing	*/
	/* him or her of the progress of the installation.				*/
	/*									*/
	/* U__s_a_g_e									*/
	/*									*/
	/*      dcl upd_install_task_$init entry (bit(36) aligned, ptr, ptr, fixed bin(35),	*/
	/*	fixed bin, ptr, fixed bin, bit(1), bit(1), ptr);				*/
	/*									*/
	/*      call upd_install_task_$init (ctlw, areap, parentp, acode, asev, taskp, seqno,	*/
	/*	special_segs, full_recovery, temp);					*/
	/*									*/
	/* 1) - 7)	are as above.						*/
	/* 8) special_segs								*/
	/*		on if "special" segs are being installed as part of the		*/
	/*		modification.(In)						*/
	/* 9) full_recovery								*/
	/*		is as above.(In)						*/
	/* 10) temp	a null ptr.(In)						*/
	/*		ptr to the information structure allocated by upd_install_task_$init	*/
	/*		for its own use.(Out)					*/
	/*									*/
	/* S__t_a_t_u_s									*/
	/*									*/
	/* 1) Created:  May, 1972 by P. R. Bos						*/
	/* 2) Modified: Dec, 1972 by G. C. Dixon - upd_install_task_$init, "special" segments,	*/
	/*				   full_recovery added; improved error recovery	*/
	/*				   message information values passed to subtasks.	*/
	/* 3) Modified: Dec, 1972 by G. C. Dixon - "deferred gathering" option added		*/
	/* 4) Modified: May, 1973 by P.B. Kelley - added upd_ring_task_ to task list to perform	*/
	/*				   all ring bracket tasks.	  		*/
	/* 5) Modified: Nov, 1974 by P.B. Kelley - added option 6 to incorporate max length	*/
	/*				   attribute setting.			*/
	/* 6) Modified: Mar, 1981 by E. N. Kittlitz - added get_entry_bound entry, support        */
	/*				   for setting EB in copy task.                   */
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

/**/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


upd_install_task_:	procedure (ctlw, areap, parentp, acode, asev, taskp, seqno,
			 dir, seg, rb, ap, an, np, nn, options, temp, max_length,
			full_recovery_sw,  log_dir, in_date, de_in_date)
		options ( rename ((alloc_, smart_alloc_ )) );


     dcl	ctlw			bit(36) aligned,	/* control word */
	areap			ptr,		/* pointer to user area */
	parentp			ptr,		/* pointer to parent task */
	acode			fixed bin(35),	/* returned status code */
	asev			fixed bin,	/* severity code to match */
	taskp			ptr,		/* pointer to task for this call */
	seqno			fixed bin,	/* task seqno for this call */
	dir (3)			char(168),	/* dirname array (upd, old, target) */
	seg (3)			char(32),		/* entryname array */
	rb (3)			fixed bin(5),	/* ring brackets for target seg */
	ap (3)			ptr,		/* acl pointer array (replace, delete, add) */
	an (3)			fixed bin,	/* corresponding acl sizes */
	np (3)			ptr,		/* name list pointer array */
	nn (3)			fixed bin,	/* name list sizes */
	options			bit(36) aligned,	/* name options */
	temp			ptr,		/* pointer to "t" or "it" structure (initially null) */
	max_length		fixed bin(18),	/* max seg length attribute */
	full_recovery_sw		bit(1),		/* on if segs can be deleted in "de_install" */
	special_segs_sw		bit(1),		/* on if special segments are being installed. */
	log_dir			char(168) aligned,	/* documentation directory */
	ioseg			char(32) aligned,	/* name of current io seg */
	in_date			fixed bin(35),	/* 0, or file system value for date of installation */
	de_in_date		fixed bin(35);	/* 0, or value for date of any de_installation */

     dcl (addr, fixed, index, length, mod, null, substr)
				builtin;

     dcl	cu_$arg_list_ptr		entry (ptr),
	ioa_$ioa_stream		entry options (variable),
	upd_print_acl_		entry (ptr, fixed bin, bit(*)),
	unique_chars_		entry (bit(*)) returns (char(15)),
	upd_add_task_		entry (char(*), ptr),
	upd_print_err_		entry options (variable),
	upd_print_names_		entry (ptr, fixed bin, bit(*)),
	upd_task_err_		entry options (variable);

     dcl	upd_acl_task_$add		entry (bit(36) aligned, ptr, ptr, fixed bin(35), fixed bin, ptr, fixed bin,
				char(168), char(32), char(32), bit(36) aligned, ptr, fixed bin),
	upd_acl_task_$delete	entry (bit(36) aligned, ptr, ptr, fixed bin(35), fixed bin, ptr, fixed bin,
				char(168), char(32), char(32), bit(36) aligned, ptr, fixed bin),
	upd_acl_task_$list		entry (bit(36) aligned, ptr, ptr, fixed bin(35), fixed bin, ptr, fixed bin,
				char(168), char(32), char(32), bit(36) aligned, ptr, fixed bin),
	upd_acl_task_$list_inacl	entry (bit(36) aligned, ptr, ptr, fixed bin(35), fixed bin, ptr, fixed bin,
				char(168), char(32), char(32), bit(36) aligned, ptr, fixed bin, (3) fixed bin(5)),
	upd_acl_task_$replace	entry (bit(36) aligned, ptr, ptr, fixed bin(35), fixed bin, ptr, fixed bin,
				char(168), char(32), char(32), bit(36) aligned, ptr, fixed bin, bit(1)),
	upd_copy_seg_task_		entry (bit(36) aligned, ptr, ptr, fixed bin(35), fixed bin, ptr, fixed bin,
				char(168), char(32), char(32), bit(36) aligned,
				char(168), char(32), char(32), bit(36) aligned, fixed bin(18), fixed bin (14), bit(1)),
	upd_doc_task_$get_tree	entry (bit(36) aligned, ptr, ptr, fixed bin(35), fixed bin, ptr, fixed bin,
				(3) char(168), (3) char(32), (3) bit(36) aligned, ptr),
	upd_doc_task_$write_tree	entry (bit(36) aligned, ptr, ptr, fixed bin(35), fixed bin, ptr, fixed bin,
				ptr, fixed bin(35), fixed bin(35), char(168) aligned, bit(1) aligned),
	upd_message_task_		entry (bit(36) aligned, ptr, ptr, fixed bin(35), fixed bin, ptr, fixed bin,
				bit(1), bit(1), bit(1) aligned, ptr, fixed bin, ptr, fixed bin),
	upd_name_task_$add		entry (bit(36) aligned, ptr, ptr, fixed bin(35), fixed bin, ptr, fixed bin,
				char(168), char(32), char(32), bit(36) aligned, ptr, fixed bin),
	upd_name_task_$delete	entry (bit(36) aligned, ptr, ptr, fixed bin(35), fixed bin, ptr, fixed bin,
				char(168), char(32), char(32), bit(36) aligned, ptr, fixed bin),
	upd_name_task_$free		entry (bit(36) aligned, ptr, ptr, fixed bin(35), fixed bin, ptr, fixed bin,
				char(168), char(32), char(32), bit(36) aligned, ptr, fixed bin),
	upd_name_task_$list		entry (bit(36) aligned, ptr, ptr, fixed bin(35), fixed bin, ptr, fixed bin,
				char(168), char(32), char(32), bit(36) aligned, ptr, fixed bin),
	upd_name_task_$list_archive	entry (bit(36) aligned, ptr, ptr, fixed bin(35), fixed bin, ptr, fixed bin,
				char(168), char(32), char(32), bit(36) aligned, ptr, fixed bin),
	upd_ring_task_$list		entry (bit(36) aligned, ptr, ptr, fixed bin(35), fixed bin, ptr, fixed bin,
				char(168), char(32), char(32), bit(36) aligned, (3) fixed bin(5)),
	upd_ring_task_$set		entry (bit(36) aligned, ptr, ptr, fixed bin(35), fixed bin, ptr, fixed bin,
				char(168), char(32), char(32), bit(36) aligned, (3) fixed bin(5), bit(1)),
	upd_status_task_$get_uid	entry (bit(36) aligned, ptr, ptr, fixed bin(35), fixed bin, ptr, fixed bin,
				char(168), char(32), bit(36) aligned);

     dcl (error_table_$badcall,
	error_table_$not_done)	ext fixed bin(35);

     dcl  sys_info$default_max_length	ext static fixed bin(18);

     dcl	argp			ptr,		/* arglist pointer */
	cp			ptr,		/* control word pointer */
	sp			ptr,		/* for overlay on "sws" */
	tp			ptr;		/* pointer to "t" structure */

     dcl	aclsw (3)			bit(2) int static init ("10"b, "00"b, "10"b),
	logsw			bit(1) aligned,	/* c.logsw | (c.errsw & asev ^= 0) */
	sws			bit(18) aligned,	/* define type of call, from args */
	state			bit(36) aligned,	/* = sws || ^sws */
	ndig_ctl			bit(36) aligned,	/* control word for non-deferred subtasks */
	no_print_ctl		bit(36) aligned,	/* control word for subtasks which print normally */
	print_ctl			bit(36) aligned;	/* control word for subtasks which print in detail */

     dcl	ndig_mask (9)		bit(36) int static init (	/* non-deferred information gathering mask */
							/* for the condition state word. */
		"010000000000000000000000000000001000"b,	/*  (1)  dsw(2) & ^option(5) */
		"010000000000000000000000000000001000"b,	/*  (2)  dsw(2) & ^option(5) */
		"011000000000000000000000000100001000"b,	/*  (3)  dsw(2) & dsw(3) & ^rbsw & ^option(5)  */
		"011000000000000000000100000000001010"b,	/*  (4)  dsw(2) & dsw(3) & ^asw(1) & ^option(5) &^o(7)*/
		"001000000000000010000100000000001000"b,	/*  (5)   dsw(3) & ^asw(1) & ^option(5) & option(7)*/
		"100000000000000000000001000000001000"b,	/*  (6)  dsw(1) & ^option(5) */
		"001000000000000000000000100000001000"b,	/*  (7)  dsw(3) & ^nsw(1) & ^option(5) */
		"001000000010000000000000000000001000"b,	/*  (8)  dsw(3) & option(1) & ^option(5) */
		"000000000000010000000000000000001000"b);	/*  (9)  option(4) & ^option(5) */

     dcl	mask (30)			bit(36) int static init (	/* condition masks for state word */
		"010000000000001000000000000000000000"b,	/*  (1)  dsw(2) & option(5) */
		"010000000000001000000000000000000000"b,	/*  (2)  dsw(2) & option(5) */
		"011000000000001000000000000100000000"b,	/*  (3)  dsw(2) & dsw(3) & ^rbsw & option(5)  */
		"011000000000001000000100000000000010"b,	/*  (4)  dsw(2) & dsw(3) & ^asw(1) & option(5) & ^o(7)*/
		"001000000000001010000100000000000000"b,	/*  (5)  dsw(3) & ^asw(1) & option(5) & option(7) */
		"100000000000001000000000000000000000"b,	/*  (6)  dsw(1) & option(5) */
		"001000000000001000000000100000000000"b,	/*  (7)  dsw(3) & ^nsw(1) & option(5) */
		"001000000010001000000000000000000000"b,	/*  (8)  dsw(3) & option(1) & option(5) */
		"000000000000011000000000000000000000"b,	/*  (9)  option(4) & option(5) */
		"001000000000000000000000000000100000"b,	/* (10)  dsw(3) & ^option(3) */
		"001000000000100000000000000000000000"b,	/* (11)  dsw(3) & option(3) */
		"001000000000000000000000000000100000"b,	/* (12)  dsw(3) & ^option(3) */
		"001000000000100000000000000000000000"b,	/* (13)  dsw(3) & option(3) */
		"001000000000000000000000000000100000"b,	/* (14)  dsw(3) & ^option(3) */
		"001000000000100000000000000000000000"b,	/* (15)  dsw(3) & option(3) */
		"001010000000000000000000000000000000"b,	/* (16)  dsw(3) & asw(2) */
		"001001000000000000000000000000000000"b,	/* (17)  dsw(3) & asw(3) */
		"010000000000000000000000000000000000"b,	/* (18)  dsw(2) */
		"010000000000000000000000000000100000"b,	/* (19)  dsw(2) & ^option(3) */
		"001000000000000000000000000000100000"b,	/* (20)  dsw(3) & ^option(3) */
		"001000001000000000000000000000100000"b,	/* (21)  dsw(3) & nsw(3) & ^option(3) */
		"001000000010000000000000000000100000"b,	/* (22)  dsw(3) & option(1) & ^option(3) */
		"001000010000000000000000000000100000"b,	/* (23)  dsw(3) & nsw(2) & ^option(3) */
		"010000000000100000000000000000000000"b,	/* (24)  dsw(2) & option(3) */
		"001000000000100000000000000000000000"b,	/* (25)  dsw(3) & option(3) */
		"001000001000100000000000000000000000"b,	/* (26)  dsw(3) & nsw(3) & option(3) */
		"001000000010100000000000000000000000"b,	/* (27)  dsw(3) & option(1) & option(3) */
		"001000010000100000000000000000000000"b,	/* (28)  dsw(3) & nsw(2) & option(3) */
		"001000000000000000000000000000000000"b,	/* (29)  dsw(3) */
		"000000000000010000000000000000000000"b);	/* (30)  option(4) */

     dcl	a			fixed bin,	/* action index */
	i			fixed bin;	/* random */

     dcl	action_table (0:7)		fixed bin int static init (0, 0, 4, 3, 0, 2, 0, 1);

     dcl	amsg (4)			char(28) int static init ("Access control list", "ACL deletions", "ACL additions", "Initial access control list"),
	msg1 (4)			char(4) int static init ("by", "Add", "", ""),
	msg2 (4)			char(8) int static init ("Replace", "", "Move", "Delete"),
	msg3 (4)			char(4) int static init ("as", "as", "to", ""),
	nmsg (3)			char(16) int static init ("Names", "Name deletions", "Name additions"),
	install_message (5)		char (58) aligned varying init (
				"Beginning installation of ",
				"",
				"Copying special target segments.",
				"Adding names to special target segments.",
				"Installation complete."),
	de_install_message (5)	char (61) aligned varying init (
				"De-installation complete.",
				"Non-special target segments deleted.",
				"Special target segments deleted.",
				"Names removed from special target segments.",
				"Beginning De-installation of ");

     dcl	bdir			char(168) based,	/* based dirname */
	bseg			char(32) based,	/* based entryname */
	buid			bit(36) aligned based;	/* based uid */

     dcl	area			area based (areap);	/* caller-supplied area */

     dcl	1 s			aligned based (sp),	/* exploded version of "sws" */
	 (2 dsw (3)		bit(1),		/* non-zero if dir(i) ^= "" */
	  2 asw (3)		bit(1),		/* non-zero if ap(i) ^= null */
	  2 nsw (3)		bit(1),		/* non-zero if np(i) ^= null */
	  2 rbsw			bit(1),		/* non-zero if rb(1) ^= 0 */
	  2 option (7)		bit(1)) unal;	/* 1-7: copy of option bits */

     dcl	1 c			aligned based (cp),	/* exploded control word */
	 (2 de_install_sw		bit(1),		/* non-zero if in de_install mode */
	  2 tasksw		bit(1),		/* non-zero if to set up task */
	  2 compsw		bit(1),		/* non-zero if compile-only task */
	  2 runsw			bit(1),		/* non-zero if call to be processed immediately */
	  2 trunsw		bit(1),		/* non-zero if subtask list to be processed */
	  2 logsw			bit(1),		/* non-zero if in print mode */
	  2 errsw			bit(1),		/* non-zero if printing error tasks only */
	  2 briefsw		bit(1),		/* non-zero if brief mode */
	  2 detailsw		bit(1),		/* non-zero if to print subtasks */
	  2 clear_code_sw		bit(1),		/* non-zero if to clear error codes and try again */
	  2 clear_uid_sw		bit(1)) unal;	/* non-zero if to clear unique ids */

     dcl	1 t			aligned based (tp),	/* internal temporaries which need preserving */
	  2 t,					/* dummy name list for temp name on new seg */
	    3 name		char(32) unal,	/* fudge alignment */
	    3 pcode		fixed bin(35),	/* process code */
	    3 rcode		fixed bin(35),	/* restore code */
	  2 tp			ptr,		/* pointer to "t.t" */
	  2 d,					/* dummy name list for temp name on old seg */
	    3 name		char(32) unal,	/* name (fudge alignment) */
	    3 pcode		fixed bin(35),	/* process code */
	    3 rcode		fixed bin(35),	/* restore code */
	  2 dp			ptr,		/* pointer to "t.d" */
	  2 nldp			ptr,		/* pointer to dirname of seg to have names listed */
	  2 nlsp			ptr,		/* pointer to entryname of same */
	  2 nlup			ptr,		/* pointer to uid of same */
	  2 cpdp			ptr,		/* pointer to dirname of seg to be copied */
	  2 cpsp			ptr,		/* pointer to entryname of same */
	  2 cpup			ptr,		/* pointer to uid of same */
	  2 a			fixed bin,	/* action code */
	  2 state			bit(36),		/* state word (sws || ^sws) */
	  2 np,					/* pointers to generated name arrays */
	    3 old			ptr init (null),	/* names to be removed from old seg */
	    3 arc			ptr init (null),	/* component names for archive */
	  2 nn,					/* name list sizes (go with "t.np.xxx") */
	    3 old			fixed bin init (0),	/* names to be removed from old seg */
	    3 arc			fixed bin init (0),	/* archive component names */
	  2 treep			ptr init (null),	/* ptr to modification description tree */
	  2 maxlen		fixed bin(18),	/* max length */
	  2 eb			fixed bin (14),     /* entry bound */
	  2 logdir		char(168) aligned init (""), /* documentation directory */
	  2 argp			ptr init (null),	/* arglist pointer, for subtask parentp */
	  2 taskp (30)		ptr init ((30) null),	/* task pointer array for subtasks */
	  2 seqno (30)		fixed bin init (
				     2,3,4,5,6,7,8,9,10,12,
				     14,15,16,17,18,19,20,21,22,23,
				     24,25,26,27,28,30,31,32,33,36),
	  2 code (30)		fixed bin(35) init ((30) 0),	/* subtask status codes */
	  2 sev (30)		fixed bin init ((30) 0),	/* subtask severity codes */
	  2 uid (3)		bit(36) init ((3) (36) "0"b),	/* unique id's for all three segs */
	  2 fwd_logging_done_sw	bit(1) aligned init ("0"b),	/* non-zero if installation was logged */
	  2 log_dir_sw		bit(1) aligned init ("0"b),	/* non-zero if logdir cannot be changed */
	  2 one			fixed bin init (1),	/* constant "1" */
	  2 recover		bit(1) unal init ("1"b);	/* static for "always full recovery switch" */

     dcl	1 it			aligned based (tp),	/* internal temps used by upd_install_task_$init */
	  2 argp			ptr init (null),	/* static ptr to our arg list */
	  2 taskp (5)		ptr init ((5) null),/* subtasks tasp ptrs. */
	  2 code (5)		fixed bin(35) init ((5) 0),
						/* status code 			*/
	  2 sev  (5)		fixed bin init ((5) 0),
						/* severity code. */
	  2 seqno (5)		fixed bin init (1, 11, 13, 29, 34),
						/* sequence number of task execution order. */
	  2 fwd_done_sw (5)		bit(1) aligned init ((5)(1)"0"b),
						/* fwd message printed switches. */
	  2 fwd_msgp (5)		ptr,		/* ptr to "install" messages. */
	  2 rev_msgp (5)		ptr,		/* ptr to "de_install" messages. */
	  2 fwd_msgl (5)		fixed bin,	/* length of "install" messages. */
	  2 rev_msgl (5)		fixed bin,	/* length of "de_install" messages. */
	  2 print			bit(1) unal init ("1"b),
						/* static switch for "always print message" */
	  2 noprint		bit(1) unal init ("0"b);
						/* static switch for "never print message" */

     dcl	fwd_msg			char (it.fwd_msgl(i)) aligned based (it.fwd_msgp(i)),
	rev_msg			char (it.rev_msgl(i)) aligned based (it.rev_msgp(i));

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/**/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


	call cu_$arg_list_ptr (argp);			/* get pointer to arglist */
	cp = addr (ctlw);				/* get pointer to control word */
	if c.de_install_sw then			/* upd_install_task_ does not run in de_install */
	     return;				/* bye.. */
	print_ctl = ctlw & "00010111110"b;		/* form subtask control words */
	no_print_ctl = ctlw & "00010111010"b;		/* suppresses detailed printing of some tasks */
	ndig_ctl = ctlw & "0001"b;
	if c.compsw then do;			/* if we're compiling subtasks, */
	     print_ctl = print_ctl | "01"b;		/* set tasksw for them */
	     no_print_ctl = no_print_ctl | "01"b;
	     end;
	if c.tasksw then				/* if we're allocating a task, */
	     ndig_ctl = ndig_ctl | "0001"b;		/* "run" non-deferred information gatherers now. */

	if temp = null then do;			/* allocated temps yet? */
	     sp = addr (sws);			/* reference sws as arrays */
	     sws = "0"b;				/* zero them first */
	     do i = 1 to 3;				/* 3 of everything */
		s.dsw(i) = (dir(i) ^= "");		/* test all kinds of conditions */
		s.asw(i) = (ap(i) ^= null);		/* see which acls given */
		s.nsw(i) = (np(i) ^= null);		/* see which name lists given */
		end;
	     if s.dsw(3)				/* if there is to exist a target seg */
		then s.rbsw = (rb(1) ^= 0);		/* were rings given for it? */
	     substr (sws, 11, 7) = substr(options,1,7);	/* fill in caller's option bits */
	     a = action_table (fixed (substr (sws, 1, 3)));
						/* s.dsw define type of call */
	     if a = 0 then do;			/* unknown action */
		call upd_task_err_(error_table_$badcall, 4, argp, "upd_install_task_", "Unknown action implied.");
		return;
		end;
	     state = sws || ^sws;			/* form 36 bit state word for masking */
	     allocate t in (area);			/* allocate space for temps, etc. */
	     t.t.name = unique_chars_("0"b);		/* get temp name for new seg */
	     t.d.name = unique_chars_("0"b);		/* and a handle for old seg */
	     t.t.pcode, t.d.pcode = error_table_$not_done;/* initialize status codes on dummy name lists */
	     t.t.rcode, t.d.rcode = 0;
	     t.tp = addr (t.t);			/* get pointers to them also */
	     t.dp = addr (t.d);
	     if a < 3 then do;			/* replace or add operation */
		t.cpdp, t.nldp = addr (dir(1));	/* copying, getting names from new seg */
		t.cpsp, t.nlsp = addr (seg(1));
		t.cpup, t.nlup = addr (t.uid(1));
		if s.dsw(2) & s.option(2) then do;	/* user wants names from old seg */
		     t.nldp = addr (dir(2));		/* so change them */
		     t.nlsp = addr (seg(2));
		     t.nlup = addr (t.uid(2));
		     end;
		end;
	     else if a = 3 then do;			/* move operation */
		t.cpdp, t.nldp = addr (dir(2));	/* everything comes from old seg */
		t.cpsp, t.nlsp = addr (seg(2));
		t.cpup, t.nlup = addr (t.uid(2));
		end;
	     else do;				/* delete operation */
		t.cpdp, t.nldp, t.cpsp, t.nlsp, t.cpup, t.nlup = null;
		end;
	     t.a = a;				/* save action code */
	     t.logdir = log_dir;			/* copy documentation directory; it gets changed later */
	     if a < 4 then
		call get_entry_bound (t.cpdp -> bdir, t.cpsp -> bseg, t.eb);
						/* try for entry bound */
	     else t.eb = 0;
	     if (options & "000001"b) then		/* max length */
		t.maxlen = max_length;		/* fill in from caller */
	     else if (options & "001000"b) then		/* give default for special segs */
		t.maxlen = 0;			/* (will be set to curlen) */
	     else					/* give default for non-special segs */
		t.maxlen = sys_info$default_max_length;	/* (system default) */
						/* perform non-deferred information gathering */
	     t.argp = argp;
	     if (state & ndig_mask(1)) = ndig_mask(1) then/* get unique id of old seg */
		call upd_status_task_$get_uid (ndig_ctl, areap, t.argp, t.code(1), t.sev(1), t.taskp(1), t.seqno(1),
		     dir(2), seg(2), t.uid(2));
	     if (state & ndig_mask(2)) = ndig_mask(2) then/* list names on old seg, to remove later */
		call upd_name_task_$list (ndig_ctl, areap, t.argp, t.code(2), t.sev(2), t.taskp(2), t.seqno(2),
		     dir(2), seg(2), seg(2), t.uid(2), t.np.old, t.nn.old);
	     if (state & ndig_mask(3)) = ndig_mask(3) then/* get rings of old seg to put on new seg */
		call upd_ring_task_$list (ndig_ctl, areap, t.argp, t.code(3), t.sev(3), t.taskp(3), t.seqno(3),
		     dir(2), seg(2), seg(2), t.uid(2), rb);
	     if (state & ndig_mask(4)) = ndig_mask(4) then/* get acl of old seg to put on new seg */
		call upd_acl_task_$list (ndig_ctl, areap, t.argp, t.code(4), t.sev(4), t.taskp(4), t.seqno(4),
		     dir(2), seg(2), seg(2), t.uid(2), ap(1), an(1));
	     if (state & ndig_mask(5)) = ndig_mask(5) then/* get acl of old seg to put on new seg */
		call upd_acl_task_$list_inacl (ndig_ctl, areap, t.argp, t.code(4), t.sev(4), t.taskp(4), t.seqno(4),
		     dir(3), seg(3), seg(3), t.uid(3), ap(1), an(1), rb);
	     if (state & ndig_mask(6)) = ndig_mask(6) then/* get unique id of new seg */
		call upd_status_task_$get_uid (ndig_ctl, areap, t.argp, t.code(5), t.sev(5), t.taskp(5), t.seqno(5),
		     dir(1), seg(1), t.uid(1));
	     if (state & ndig_mask(7)) = ndig_mask(7) then/* get name list for target seg from new seg */
		call upd_name_task_$list (ndig_ctl, areap, t.argp, t.code(6), t.sev(6), t.taskp(6), t.seqno(6),
		     t.nldp -> bdir, t.nlsp -> bseg, t.nlsp -> bseg, t.nlup -> buid, np(1), nn(1));
	     if (state & ndig_mask(8)) = ndig_mask(8) then/* archive option, get name list from components */
		call upd_name_task_$list_archive (ndig_ctl, areap, t.argp, t.code(7), t.sev(7), t.taskp(7), t.seqno(7),
		     t.cpdp -> bdir, t.cpsp -> bseg, t.cpsp -> bseg, t.cpup -> buid, t.np.arc, t.nn.arc);
	     if (state & ndig_mask(9)) = ndig_mask(9) then/* log option; get modification description tree */
		call upd_doc_task_$get_tree (ndig_ctl, areap, t.argp, t.code(8), t.sev(8), t.taskp(8), t.seqno(8),
		     dir, seg, t.uid, t.treep);

	     t.state = state;			/* save state word */
	     temp = tp;				/* have caller save pointer for us */
	     end;
	else do;					/* already done, we were interrupted */
	     tp = temp;				/* just get it back again */
	     a = t.a;				/* make code a little more efficient */
	     state = t.state;
	     end;


	if c.tasksw then 				/* allocating a task? */
	     call upd_add_task_("upd_install_task_", argp);
	logsw = c.logsw;				/* non-zero if printing */
	if c.errsw then if asev = 0 then		/* error option, print if error only */
	     logsw = "0"b;				/* reset bit if no error */

	if c.clear_code_sw then do;			/* user wants error codes cleared for a retry */
	     acode,
	     asev,
	     t.code,
	     t.sev = 0;
	     end;

	if c.clear_uid_sw then			/* user wants unique id's cleared for a retry */
	     t.uid = "0"b;				/* reloader resets uid's on all segments. */
						/* uid's stored in io seg must be set to 0 to do a */
						/* restore after a reload has been done. */

	if ^t.log_dir_sw then			/* if we can still update the log directory */
	     t.logdir = log_dir;			/* then do it */

	if logsw then do;				/* user wants to know what's going on (don't we all) */
	     sp = addr (state);			/* overlay structure on it */
	     if c.detailsw then			/* space up paper a bit */
		call ioa_$ioa_stream ("installation_list_", "^|^/");
	     else
		call ioa_$ioa_stream ("installation_list_", "^/");
	     if s.dsw(2) then			/* replacing, moving or deleting somebody? */
		call ioa_$ioa_stream ("installation_list_", "^10a^a>^a", (msg2(a)), dir(2), seg(2));
	     if s.dsw(1) then			/* adding or replacing? */
		call ioa_$ioa_stream ("installation_list_", "^10a^a>^a", (msg1(a)), dir(1), seg(1));
	     if dir(2) = dir(3) then if seg(2) = seg(3) then	/* replace with target = old, omit third msg */
		go to skip;			/* skip */
	     if s.dsw(3) then			/* somebody going in? */
		call ioa_$ioa_stream ("installation_list_", "^10a^a>^a", (msg3(a)), dir(3), seg(3));
skip:	     if c.briefsw then			/* brief mode? */
		go to brief;			/* yes, skip options */
	     if (options & "1111111"b) then do;		/* tell user what options are */
		call ioa_$ioa_stream ("installation_list_", "^5xOptions:");
		if s.option(1) then
		     call ioa_$ioa_stream ("installation_list_", "^-Add component names");
		if s.option(2) then
		     call ioa_$ioa_stream ("installation_list_", "^-Use old names");
		if s.option(3) then
		     call ioa_$ioa_stream ("installation_list_", "^-Special segment");
		if s.option(4) then
		     call ioa_$ioa_stream ("installation_list_", "^-Log the installation");
		if s.option(5) then
		     call ioa_$ioa_stream ("installation_list_", "^-Deferred information gathering");
		if s.option(6) then
		     call ioa_$ioa_stream ("installation_list_", "^-Set maximum length");
		end;
	     if c.detailsw | c.errsw then		/* do print args in full if they will be printed */
		go to end_log_print;		/* later. */
	     if s.rbsw then				/* print ring brackets option, if exists */
		call ioa_$ioa_stream ("installation_list_", "^5xSet ring brackets:^/^10x^d,^d,^d",
		     rb(1), rb(2), rb(3) );
	     if t.eb > 0 then
		call ioa_$ioa_stream ("installation_list_", "^5xSet entry bound:^/^10x^d", t.eb);

	     if option(7) then do;			/* user requested INACL */
		     call ioa_$ioa_stream ("installation_list_", "^5x^a:", (amsg(4)));	/* print header */
		     call upd_print_acl_(ap(1), an(1), (aclsw(1)));
	     end;		
	     else do i = 1 to 3;				/* print acl options */
		if ap(i) ^= null then do;		/* this one here? */
		     call ioa_$ioa_stream ("installation_list_", "^5x^a:", (amsg(i)));	/* print header */
		     call upd_print_acl_(ap(i), an(i), (aclsw(i)));
		     end;
		end;
	     do i = 1 to 3;				/* print name options */
		if np(i) ^= null then do;		/* this one here? */
		     call ioa_$ioa_stream ("installation_list_", "^5x^a:", (nmsg(i)));	/* print header */
		     call upd_print_names_(np(i), nn(i), "00"b);
		     end;
		end;
	     if s.option(1) then do;			/* archive option? */
		call ioa_$ioa_stream ("installation_list_", "^5xArchive component names:");	/* print header */
		call upd_print_names_(t.np.arc, t.nn.arc, "00"b);	/* print name list */
		end;
	     if s.option(4) then do;			/* print Log information */
		call ioa_$ioa_stream ("installation_list_", "^5xLog Information:");		/* print header */
		call upd_doc_task_$write_tree ("00000100000"b, areap, null, 0, 0, null, 0,
		     t.treep, in_date, de_in_date, t.logdir, "0"b);	/* pass only minimum arguments */
		end;
brief:	     if asev ^= 0 then			/* was there an error last time? */
		call upd_print_err_(acode, asev);	/* yes, print it */
	     end;

end_log_print:
	t.argp = argp;				/* set parentp for subtasks in static. */
	ndig_ctl = ctlw & "000001110"b;		/* ndig's can only print from this point on, */
						/* and never in detail. */
	if ^c.detailsw & ^c.errsw then do;		/* user want subtasks printed? */
	     print_ctl = print_ctl & "11110000010"b;		/* no, mask out all print bits */
	     no_print_ctl = no_print_ctl & "11110000010"b;
	     ndig_ctl = "0"b;
	     end;

	if ndig_ctl = "0"b then			/* no more ndig tasks? */
	     go to check_dig;			/* see if there are any deferred tasks to do */

	if logsw then				/* don't confuse user */
	     call ioa_$ioa_stream ("installation_list_", "Subtasks follow.");		/* tell him which is which */
	if (state & ndig_mask(1)) = ndig_mask(1) then	/* get unique id of old seg */
	     call upd_status_task_$get_uid (ndig_ctl, areap, t.argp, t.code(1), t.sev(1), t.taskp(1), t.seqno(1),
	          dir(2), seg(2), t.uid(2));
	if (state & ndig_mask(2)) = ndig_mask(2) then	/* list names on old seg, to remove later */
	     call upd_name_task_$list (ndig_ctl, areap, t.argp, t.code(2), t.sev(2), t.taskp(2), t.seqno(2),
	          dir(2), seg(2), seg(2), t.uid(2), t.np.old, t.nn.old);
	if (state & ndig_mask(3)) = ndig_mask(3) then	/* get rings of old seg to put on new seg */
		call upd_ring_task_$list (ndig_ctl, areap, t.argp, t.code(3), t.sev(3), t.taskp(3), t.seqno(3),
		     dir(2), seg(2), seg(2), t.uid(2), rb);
	if (state & ndig_mask(4)) = ndig_mask(4) then	/* get acl of old seg to put on new seg */
	     call upd_acl_task_$list (ndig_ctl, areap, t.argp, t.code(4), t.sev(4), t.taskp(4), t.seqno(4),
	          dir(2), seg(2), seg(2), t.uid(2), ap(1), an(1));
	if (state & ndig_mask(5)) = ndig_mask(5) then	/* get INACL of target dir */
	     call upd_acl_task_$list_inacl (ndig_ctl, areap, t.argp, t.code(5), t.sev(5), t.taskp(5), t.seqno(5),
	          dir(3), seg(3), seg(3), t.uid(3), ap(1), an(1), rb);
	if (state & ndig_mask(6)) = ndig_mask(6) then	/* get unique id of new seg */
	     call upd_status_task_$get_uid (ndig_ctl, areap, t.argp, t.code(6), t.sev(6), t.taskp(6), t.seqno(6),
	          dir(1), seg(1), t.uid(1));
	if (state & ndig_mask(7)) = ndig_mask(7) then	/* get name list for target seg from new seg */
	     call upd_name_task_$list (ndig_ctl, areap, t.argp, t.code(7), t.sev(7), t.taskp(7), t.seqno(7),
	          t.nldp -> bdir, t.nlsp -> bseg, t.nlsp -> bseg, t.nlup -> buid, np(1), nn(1));
	if (state & ndig_mask(8)) = ndig_mask(8) then	/* archive option, get name list from components */
	     call upd_name_task_$list_archive (ndig_ctl, areap, t.argp, t.code(8), t.sev(8), t.taskp(8), t.seqno(8),
	          t.cpdp -> bdir, t.cpsp -> bseg, t.cpsp -> bseg, t.cpup -> buid, t.np.arc, t.nn.arc);
	if (state & ndig_mask(9)) = ndig_mask(9) then	/* log option; get modification description tree */
	     call upd_doc_task_$get_tree (ndig_ctl, areap, t.argp, t.code(9), t.sev(9), t.taskp(9), t.seqno(9),
		dir, seg, t.uid, t.treep);

check_dig:
	if no_print_ctl = "0"b then			/* nothing more to do */
	     return;				/* scram */

	if (no_print_ctl & "01"b) then		/* if we're setting up the subtasks */
	     t.log_dir_sw = "1"b;			/* log directory cannot be changed from now on */

	if (state & mask(1)) = mask(1) then		/* get unique id of old seg */
	     call upd_status_task_$get_uid (no_print_ctl, areap, t.argp, t.code(1), t.sev(1), t.taskp(1), t.seqno(1),
		dir(2), seg(2), t.uid(2));
	if (state & mask(2)) = mask(2) then		/* list names on old seg, to remove later */
	     call upd_name_task_$list (no_print_ctl, areap, t.argp, t.code(2), t.sev(2), t.taskp(2), t.seqno(2),
		dir(2), seg(2), seg(2), t.uid(2), t.np.old, t.nn.old);
	if (state & mask(3)) = mask(3) then		/* get rings of old seg to put on new seg */
	     call upd_ring_task_$list (no_print_ctl, areap, t.argp, t.code(3), t.sev(3), t.taskp(3), t.seqno(3),
		dir(2), seg(2), seg(2), t.uid(2), rb);
	if (state & mask(4)) = mask(4) then		/* get acl of old seg to put on new seg */
	     call upd_acl_task_$list (no_print_ctl, areap, t.argp, t.code(4), t.sev(4), t.taskp(4), t.seqno(4),
		dir(2), seg(2), seg(2), t.uid(2), ap(1), an(1));
	if (state & mask(5)) = mask(5) then		/* get acl of old seg to put on new seg */
	     call upd_acl_task_$list_inacl (no_print_ctl, areap, t.argp, t.code(5), t.sev(5), t.taskp(5), t.seqno(5),
		dir(2), seg(2), seg(2), t.uid(2), ap(1), an(1), rb);
	if (state & mask(6)) = mask(6) then		/* get unique id of new seg */
	     call upd_status_task_$get_uid (no_print_ctl, areap, t.argp, t.code(6), t.sev(6), t.taskp(6), t.seqno(6),
		dir(1), seg(1), t.uid(1));
	if (state & mask(7)) = mask(7) then		/* get name list for target seg from new seg */
	     call upd_name_task_$list (no_print_ctl, areap, t.argp, t.code(7), t.sev(7), t.taskp(7), t.seqno(7),
		t.nldp -> bdir, t.nlsp -> bseg, t.nlsp -> bseg, t.nlup -> buid, np(1), nn(1));
	if (state & mask(8)) = mask(8) then		/* archive option, get name list from components */
	     call upd_name_task_$list_archive (no_print_ctl, areap, t.argp, t.code(8), t.sev(8), t.taskp(8), t.seqno(8),
		t.cpdp -> bdir, t.cpsp -> bseg, t.cpsp -> bseg, t.cpup -> buid, t.np.arc, t.nn.arc);
	if (state & mask(9)) = mask(9) then		/* log option; get modification description tree */
	     call upd_doc_task_$get_tree (no_print_ctl, areap, t.argp, t.code(9), t.sev(9), t.taskp(9), t.seqno(9),
		dir, seg, t.uid, t.treep);
	if (state & mask(10)) = mask(10) then		/* copy segment (new/old -> target) (non-special) */
	     call upd_copy_seg_task_(print_ctl, areap, t.argp, t.code(10), t.sev(10), t.taskp(10), t.seqno(10),
		t.cpdp -> bdir, t.cpsp -> bseg, t.cpsp -> bseg, t.cpup -> buid, dir(3), t.t.name, seg(3), 
		t.uid(3), t.maxlen, t.eb, t.recover);
	if (state & mask(11)) = mask(11) then		/* copy segment (new/old -> target) (special) */
	     call upd_copy_seg_task_(print_ctl, areap, t.argp, t.code(11), t.sev(11), t.taskp(11), t.seqno(11),
		t.cpdp -> bdir, t.cpsp -> bseg, t.cpsp -> bseg, t.cpup -> buid, dir(3), t.t.name, seg(3),
		t.uid(3), t.maxlen, t.eb, full_recovery_sw);
	if (state & mask(12)) = mask(12) then		/* set ring brackets (target) (non-special) */
	     call upd_ring_task_$set (no_print_ctl, areap, t.argp, t.code(12), t.sev(12), t.taskp(12), t.seqno(12),
		dir(3), t.t.name, seg(3), t.uid(3), rb, t.recover);
	if (state & mask(13)) = mask(13) then		/* set ring brackets (target) (special) */
	     call upd_ring_task_$set (no_print_ctl, areap, t.argp, t.code(13), t.sev(13), t.taskp(13), t.seqno(13),
		dir(3), t.t.name, seg(3), t.uid(3), rb, full_recovery_sw);
	if (state & mask(14)) = mask(14) then		/* replace acl (target) (non-special) */
	     call upd_acl_task_$replace (print_ctl, areap, t.argp, t.code(14), t.sev(14), t.taskp(14), t.seqno(14),
		dir(3), t.t.name, seg(3), t.uid(3), ap(1), an(1), t.recover);
	if (state & mask(15)) = mask(15) then		/* replace acl (target) (special) */
	     call upd_acl_task_$replace (print_ctl, areap, t.argp, t.code(15), t.sev(15), t.taskp(15), t.seqno(15),
		dir(3), t.t.name, seg(3), t.uid(3), ap(1), an(1), full_recovery_sw);
	if (state & mask(16)) = mask(16) then		/* delete from acl (target) */
	     call upd_acl_task_$delete (print_ctl, areap, t.argp, t.code(16), t.sev(16), t.taskp(16), t.seqno(16),
		dir(3), t.t.name, seg(3), t.uid(3), ap(2), an(2));
	if (state & mask(17)) = mask(17) then		/* add to acl (target) */
	     call upd_acl_task_$add (print_ctl, areap, t.argp, t.code(17), t.sev(17), t.taskp(17), t.seqno(17),
		dir(3), t.t.name, seg(3), t.uid(3), ap(3), an(3));
	if (state & mask(18)) = mask(18) then		/* add name (old) (unique) */
	     call upd_name_task_$add (print_ctl, areap, t.argp, t.code(18), t.sev(18), t.taskp(18), t.seqno(18),
		dir(2), seg(2), seg(2), t.uid(2), t.dp, t.one);
	if (state & mask(19)) = mask(19) then		/* free names (old) (non-special) */
	     call upd_name_task_$free (print_ctl, areap, t.argp, t.code(19), t.sev(19), t.taskp(19), t.seqno(19),
		dir(2), t.d.name, seg(2), t.uid(2), t.np.old, t.nn.old);
	if (state & mask(20)) = mask(20) then		/* add names (target) (-name) (non-special) */
	     call upd_name_task_$add (print_ctl, areap, t.argp, t.code(20), t.sev(20), t.taskp(20), t.seqno(20),
		dir(3), t.t.name, seg(3), t.uid(3), np(1), nn(1));
	if (state & mask(21)) = mask(21) then		/* add names (target) (-add_name) (non-special) */
	     call upd_name_task_$add (print_ctl, areap, t.argp, t.code(21), t.sev(21), t.taskp(21), t.seqno(21),
		dir(3), t.t.name, seg(3), t.uid(3), np(3), nn(3));
	if (state & mask(22)) = mask(22) then		/* add names (target) (-archive) (non-special) */
	     call upd_name_task_$add (print_ctl, areap, t.argp, t.code(22), t.sev(22), t.taskp(22), t.seqno(22),
		dir(3), t.t.name, seg(3), t.uid(3), t.np.arc, t.nn.arc);
	if (state & mask(23)) = mask(23) then		/* delete names (target) (-delete_name) (non-special) */
	     call upd_name_task_$delete (print_ctl, areap, t.argp, t.code(23), t.sev(23), t.taskp(23), t.seqno(23),
		dir(3), t.t.name, seg(3), t.uid(3), np(2), nn(2));
	if (state & mask(24)) = mask(24) then		/* free names (old) (special) */
	     call upd_name_task_$free (print_ctl, areap, t.argp, t.code(24), t.sev(24), t.taskp(24), t.seqno(24),
		dir(2), t.d.name, seg(2), t.uid(2), t.np.old, t.nn.old);
	if (state & mask(25)) = mask(25) then		/* add names (target) (-name) (special) */
	     call upd_name_task_$add (print_ctl, areap, t.argp, t.code(25), t.sev(25), t.taskp(25), t.seqno(25),
		dir(3), t.t.name, seg(3), t.uid(3), np(1), nn(1));
	if (state & mask(26)) = mask(26) then		/* add names (target) (-add_name) (special) */
	     call upd_name_task_$add (print_ctl, areap, t.argp, t.code(26), t.sev(26), t.taskp(26), t.seqno(26),
		dir(3), t.t.name, seg(3), t.uid(3), np(3), nn(3));
	if (state & mask(27)) = mask(27) then		/* add names (target) (-archive) (special) */
	     call upd_name_task_$add (print_ctl, areap, t.argp, t.code(27), t.sev(27), t.taskp(27), t.seqno(27),
		dir(3), t.t.name, seg(3), t.uid(3), t.np.arc, t.nn.arc);
	if (state & mask(28)) = mask(28) then		/* delete names (target) (-delete_name) (special) */
	     call upd_name_task_$delete (print_ctl, areap, t.argp, t.code(28), t.sev(28), t.taskp(28), t.seqno(28),
		dir(3), t.t.name, seg(3), t.uid(3), np(2), nn(2));
	if (state & mask(29)) = mask(29) then		/* delete names (target) (unique) */
	     call upd_name_task_$delete (print_ctl, areap, t.argp, t.code(29), t.sev(29), t.taskp(29), t.seqno(29),
		dir(3), seg(3), seg(3), t.uid(3), t.tp, t.one);
	if (state & mask(30)) = mask(30) then		/* log option; write formatted tree into log */
	     call upd_doc_task_$write_tree (print_ctl, areap, t.argp, t.code(30), t.sev(30), t.taskp(30), t.seqno(30),
		t.treep, in_date, de_in_date, t.logdir, t.fwd_logging_done_sw);

	return;					/* sigh */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */



/**/


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


get_entry_bound:	entry (Dir, Seg, Eb);

     dcl  (Dir, Seg)		char (*),
	Eb			fixed bin (14);

     dcl  bc 			fixed bin (24),	/* bitcount for get_entry_bound */
	code			fixed bin (35),
	mode			fixed bin (5),
	segp			ptr,		/* seg pointer for get_entry_bound */
	1 obj_info		like object_info aligned;

     dcl  (bit, unspec)		builtin;

     dcl  cleanup			condition;

     dcl  (get_group_id_		entry() returns(char(32)),
	get_ring_			entry() returns(fixed bin(3)),
	hcs_$get_user_effmode	entry (char(*), char(*), char(*), fixed bin, fixed bin(5), fixed bin(35)),
     	hcs_$initiate_count		entry (char(*), char(*), char(*), fixed bin(24), fixed bin(2), ptr, fixed bin(35)),
	hcs_$terminate_noname	entry (ptr, fixed bin(35)),
	object_info_$brief		entry (ptr, fixed bin(24), ptr, fixed bin(35)));

	Eb = -1;					/* default to no successful status */
	segp = null;

	call hcs_$get_user_effmode ( Dir, Seg, get_group_id_ (), get_ring_ (), mode, code);
	if code ^= 0 | (bit (mode,5) & "01000"b ^= "01000"b) then
	     return;				/* no read access */

	on cleanup begin;
	     if segp ^= null then call hcs_$terminate_noname ( segp, (0));
	end;

	call hcs_$initiate_count ( Dir, Seg, "", bc, 0, segp, code);
	if segp = null then return;			/* should never happen */
	unspec ( obj_info) = ""b;
	obj_info.version_number = object_info_version_2;

	call object_info_$brief ( segp, bc, addr (obj_info), code);
	if code = 0 & obj_info.gate then		/* really an object and really a gate */
	     Eb = obj_info.entry_bound;
	else Eb = 0;				/* otherwise no entry bound */
	call hcs_$terminate_noname ( segp, code);
	return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/**/


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


init:	entry (ctlw, areap, parentp, acode, asev, taskp, seqno, special_segs_sw, full_recovery_sw, temp, ioseg);
						/* installer message task initialization. */

	call cu_$arg_list_ptr (argp);			/* get ptr to arglist for use by called pgms */
	cp = addr (ctlw);				/* overlay the control word */
	if c.de_install_sw then			/* upd_install_task_$init doesn't run in de_install */
	     return;

	if temp = null then do;			/* allocated temps yet? */
	     i = mod ( index(ioseg, " ") + 32, 33);	/* calculate length of io seg name */
	     install_message(1) = install_message(1)||substr(ioseg,1,i); /* form new forward msg */
	     allocate it in (area);			/* if not, allocate and fill in. */
	     de_install_message(5) = de_install_message(5)||substr(ioseg,1,i); /* and new reverse msg */
						/* (bug in optimize forces this placement) */
	     do i = 1 to 5;				/* copy messages into static. */
		it.fwd_msgl(i) = length (install_message(i));
		allocate fwd_msg in (area);
		fwd_msg = install_message(i);

		it.rev_msgl(i) = length (de_install_message(i));
		allocate rev_msg in (area);
		rev_msg = de_install_message(i);
		end;
	     temp = tp;				/* store ptr to it in caller-preserved argument. */
	     end;
	else
	     tp = temp;				/* if so, get ptr to it. */

	if c.tasksw then				/* allocating a task? */
	     call upd_add_task_ ("upd_install_task_$init", argp);

	no_print_ctl = ctlw & "000100000"b;			/* for subtask control word (allow only runsw) */
	if c.compsw then				/* if we're compiling a subtask list, then */
	     no_print_ctl = no_print_ctl | "01"b;			/* turn on tasksw for our subtasks. */

	if no_print_ctl = "0"b then				/* nothing more to do? */
	     return;				/* then return. */

	it.argp = argp;				/* set parentp for use by our subtasks */

	call upd_message_task_ (no_print_ctl, areap, it.argp, it.code(1), it.sev(1), it.taskp(1), it.seqno(1),
	     it.print, it.print, it.fwd_done_sw(1), it.fwd_msgp(1), it.fwd_msgl(1), it.rev_msgp(1), it.rev_msgl(1));
						/* first msg - start/end */
	call upd_message_task_ (no_print_ctl, areap, it.argp, it.code(2), it.sev(2), it.taskp(2), it.seqno(2),
	     it.noprint, it.print, it.fwd_done_sw(2), it.fwd_msgp(2), it.fwd_msgl(2), it.rev_msgp(2), it.rev_msgl(2));
						/* second msg - copy/delete (non-special) */
	if special_segs_sw then
	     call upd_message_task_ (no_print_ctl, areap, it.argp, it.code(3), it.sev(3), it.taskp(3), it.seqno(3),
		special_segs_sw, full_recovery_sw, it.fwd_done_sw(3), it.fwd_msgp(3), it.fwd_msgl(3), 
		it.rev_msgp(3), it.rev_msgl(3));
						/* third msg - copy/delete (special) */
	if special_segs_sw then
	     call upd_message_task_ (no_print_ctl, areap, it.argp, it.code(4), it.sev(4), it.taskp(4), it.seqno(4),
		special_segs_sw, special_segs_sw, it.fwd_done_sw(4), it.fwd_msgp(4), it.fwd_msgl(4), 
		it.rev_msgp(4), it.rev_msgl(4));
						/* fourth msg - names_on/names_off (special) */
	call upd_message_task_ (no_print_ctl, areap, it.argp, it.code(5), it.sev(5), it.taskp(5), it.seqno(5),
	     it.print, it.print, it.fwd_done_sw(5), it.fwd_msgp(5), it.fwd_msgl(5), it.rev_msgp(5), it.rev_msgl(5));
						/* fifth msg - end/start */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


%include object_info;


	end upd_install_task_;
