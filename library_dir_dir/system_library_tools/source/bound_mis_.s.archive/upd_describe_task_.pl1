/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */



/*	This first generation MIS task is similar in function to upd_install_task_.  And,	*/
/*	like upd_install_task_$init, this task is allocated only once per installation.		*/
/*	When executed, it sets up a subtask, upd_doc_task_$write_prose, which is		*/
/*	responsible for adding a description of the installation to Installations.log		*/
/*	and Installations.info, the documentation segments.				*/
/*	Currently, the entries upd_doc_task_$write_tree and upd_doc_task_$write_prose		*/
/*	are responsible for locking and unlocking the documentation segments while		*/
/*	adding information.  If the need ever arises to have two or more online		*/
/*	Installers performing installations concurrently, then it is suggested that		*/
/*	the lock and unlock tasks be generated by this program to guarantee			*/
/*	consistency within the documentation segments.					*/
/*										*/
/*	P. B. Kelley								*/

upd_describe_task_:	proc ( ctlw, areap, parentp, acode, asev, taskp, seqno, temp, log_directory, descp, install_date )

		options ( rename (( alloc_, smart_alloc_)) );

dcl
     ctlw		bit (36) aligned,			/* control word */
     areap	ptr,				/* ptr to Area */
     parentp	ptr,				/* ptr to parent */
     acode	fixed bin(35),			/* error code */
     asev		fixed bin,			/* error severity */
     taskp	ptr,				/* task ptr */
     seqno	fixed bin,			/* sequence number */
     temp		ptr,				/* ptr to temporaries */
     log_directory	char (168) aligned,			/* documentation directory */
     descp	ptr,				/* ptr to description structure */
     install_date	fixed bin(35);			/* date of installation */

dcl  1 c	aligned based (addr(ctlw)),			/* definition of ctlw bits */
      (2  reverse_sw	bit (1),
       2  task_sw		bit (1),
       2  compile_sw	bit (1),
       2  run_sw		bit (1),
       2  task_run_sw	bit (1),
       2  log_sw		bit (1),
       2  error_sw		bit (1),
       2  brief_sw		bit (1),
       2  detail_sw		bit (1),
       2  clear_code_sw	bit (1),
       2  clear_uid_sw	bit (1) )unal;
/*  */
dcl
     addr		builtin,
     argp		ptr,
     control	bit(36) aligned,
     entry	char(32) init ("upd_describe_task_"),
     null		builtin,
     tp		ptr;
dcl
     cu_$arg_list_ptr	entry (ptr),
     ioa_$ioa_stream	entry options (variable),
     upd_add_task_		entry (char(*), ptr),
     upd_doc_task_$write_prose entry (bit(36) aligned, ptr, ptr, fixed bin(35), fixed bin, ptr, fixed bin,
			     char (168) aligned, ptr, fixed bin(35), bit(1) aligned, fixed bin);

dcl  1 t  aligned based (tp),				/* internal temps */
       2 argp		ptr,			/* arglist pointer */
       2 taskp		ptr init (null),		/* task pointer for subtasks */
       2 seqno		fixed bin init (34),	/* sequence number for subtask */
       2 code		fixed bin (35) init (0),	/* subtask status code */
       2 sev		fixed bin init (0),		/* subtask severity */
       2 log_directory	char (168) aligned,		/* documentation directory */
       2 descp		ptr,			/* ptr to description structure */
       2 max_line_size	fixed bin init (65),	/* max. line size */
       2 fwd_done_sw	bit (1) aligned init ("0"b);	/* "on" if description already documented */

dcl  Area area based (areap);				/* area */

/*  */

	call cu_$arg_list_ptr (argp);				/* get the arg. list ptr */
	if c.reverse_sw then				/* can't run in reverse */
	     return;
	if c.task_sw then
	     call upd_add_task_ (entry, argp);			/* allocate task into 1st generation */
							/* task list */
	control = (ctlw & "00100111100"b);			/* allow only "cpmpile" or "print" */
	if c.log_sw then					/* if we're logging... */
	     control = control & "00000111100"b;		/* mask all but the print bits */
	if c.compile_sw then
	     control = "01"b;				/* if compiling, then set tasksw for subtasks */

	if control = "0"b then
	     return;					/* nothing to do */

	if temp = null then					/* if temps don't exist yet */
	     if (control & "01"b) then do;			/* and we're setting up subtasks */
	     allocate t in (Area);			     	/* allocate temps */
	     t.argp = argp;
	     t.log_directory = log_directory;
	     t.descp = descp;
	     temp = tp;
	     end;

	tp = temp;					/* just get it back again */

	if (control & "00000000100"b) then			/* if printing detail */
	     call ioa_$ioa_stream ( "installation_list_", "^|");	/* start on a NEW PAGE */

	if temp ^= null then				/* if temps have been allocated */
	     call upd_doc_task_$write_prose (control, areap, t.argp, t.code, t.sev, t.taskp, t.seqno,
		t.log_directory, t.descp, install_date, t.fwd_done_sw, t.max_line_size);
	else						/* I guess we're only printing */
	     call upd_doc_task_$write_prose (control, null, null, 0, 0, null, 0,
		log_directory, descp, install_date, "0"b, 65);

	return;

	end upd_describe_task_;
