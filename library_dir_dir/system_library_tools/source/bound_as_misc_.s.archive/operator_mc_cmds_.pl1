/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1985 *
        *                                                         *
        *********************************************************** */

/****^  HISTORY COMMENTS:
  1) change(86-01-07,MSharpe), approve(87-07-09,MCR7690),
     audit(87-07-30,Parisek), install(87-08-04,MR12.1-1055):
     Removed the message_coordinator commands from admin_ and created this
     program.  Added accept_vchn which accepts virtual channel names.  Fixed
     accept to leave broadcast list alone if not specified.
  2) change(87-04-07,Parisek), approve(87-07-09,MCR7690),
     audit(87-08-03,Beattie), install(87-08-04,MR12.1-1055):
     Bypass printing error message on MC terminal if code returned by
     mc_commands_$new_tty is error_table_$ioname_not_active. We don't care if
     it's not active cause if not it will become active after "accept".
  3) change(87-04-26,GDixon), approve(87-07-09,MCR7690),
     audit(87-07-30,Parisek), install(87-08-04,MR12.1-1055):
     Upgraded for change to answer_table.incl.pl1.
  4) change(87-06-25,Parisek), approve(87-06-25,MCR7690),
     audit(87-08-03,Beattie), install(87-08-04,MR12.1-1055):
     Created a new internal procedure for searching the answer table for DSA MC
     user (no proc), and send a "bump" wakeup to AS to remove the ute for the
     user only when "drop" or "substty" is called.
  5) change(87-06-29,Parisek), approve(87-06-29,MCR7690),
     audit(87-08-03,Beattie), install(87-08-04,MR12.1-1055):
     Ignore error_table_$action_not_performed returned from asu_$bump_user if
     dsa channel.
                                                   END HISTORY COMMENTS */

/* format: style4,indattr */

%page;
operator_mc_cmds_:
     proc ();

/* AUTOMATIC */

dcl  answer	        char (256) init ("");
dcl  arg_count	        fixed bin (17);
dcl  arg_index	        fixed bin (17);
dcl  arg_length	        fixed bin (21);
dcl  arg_list_ptr	        ptr;
dcl  arg_ptr	        ptr;
dcl  attauth	        bit (36);			/*  .. privilege bits */
dcl  attchan	        char (32);			/* .. channel ID or file name */
dcl  attchan1	        char (32);			/* .. channel ID or file name */
dcl  attype	        char (8);			/* .. attachment type (file or tty) */
dcl  auth_flag	        bit (1) aligned;
dcl  bc_flag	        bit (1) aligned;
dcl  bc_list	        char (329) aligned;		/* 10 char (32) + 9 separating commas */
dcl  cdte_flag	        bit (1) aligned;		/* 1=>attchan is defined in cdt */
dcl  code		        fixed bin (35);
dcl  comname	        char (32) aligned;
dcl  dsa_flag	        bit (1) aligned;		/* dsa channel specified */
dcl  iutep                  ptr;			/* Initializer's utep */
dcl  reply_target	        char (32);
dcl  source	        char (8);			/* Source name, used in "route" */
dcl  stream	        char (32);			/* .. stream name */
dcl  target_flag	        bit (1) aligned;
dcl  vcon		        char (32);			/* .. virtual console name */
dcl  vcon1	        char (32);			/* .. virtual console name */
dcl  virtual_dsa            bit (1) aligned;		/* virtual dsa channel ident */

dcl 1 CAI structure aligned like channel_audit_info automatic;

/* CONSTANTS */

declare  (TRUE init ("1"b),
	FALSE init (""b)) bit (1) aligned int static options (constant);

/* BASED */

dcl  arg		        char (arg_length) based (arg_ptr);

/* BUILTIN */

dcl  (addr, index, length, null, rtrim, substr)   builtin;

/* ENTRY */

dcl  as_access_audit_$channel
                            entry (ptr, ptr, ptr, fixed bin, ptr, char(*));
dcl  asu_$bump_user         entry (ptr, char (*), fixed bin (35), fixed bin);
dcl  cu_$arg_list_ptr       entry returns (ptr);
dcl  cu_$arg_ptr_rel        entry (fixed bin, ptr, fixed bin (21), fixed bin (35), ptr);
dcl  cu_$arg_count_rel      entry (fixed bin, ptr, fixed bin (35));
dcl  cv_oct_check_	        entry (char (*), fixed bin (35)) returns (bit (36));
dcl  get_process_access_class_
                            entry () returns (bit (72) aligned);
dcl  get_process_id_        entry () returns (bit (36));
dcl  hcs_$initiate	        entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
dcl  initiate_file_         entry (char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));
dcl  ioa_$rsnnl	        entry options (variable);
dcl  mc_commands_$new_tty   entry (char (*), bit (36), bit (1) aligned,
			ptr, fixed bin (35));
dcl  mc_commands_$new_vchannel
		        entry (char (*), bit (36), ptr, fixed bin (35));
dcl  mc_commands_$set_restrict
		        entry (char (*), char (*), fixed bin (35));
dcl  mc_commands_$set_broadcast
		        entry (char (*), char (*), fixed bin (35));
dcl  mc_commands_$remove_tty
		        entry (char (*), bit (1) aligned, fixed bin (35));
dcl  mc_commands_$define    entry (char (*), char (*), char (*), fixed bin (35));
dcl  mc_commands_$deroute   entry (char (*), char (*), char (*), fixed bin (35));
dcl  mc_commands_$route     entry (char (*), char (*), char (*), char (*), fixed bin (35));
dcl  mc_commands_$reroute   entry (char (*), char (*), char (*), char (*), char (*), fixed bin (35));
dcl  mc_commands_$undefine  entry (char (*), char (*), fixed bin (35));
dcl  mc_commands_$redefine  entry (char (*), char (*), char (*), char (*), fixed bin (35));
dcl  mc_commands_$substty   entry (char (*), char (*), bit (1) aligned, ptr,
			 bit (1) aligned, fixed bin (35));
dcl  sys_log_$command       entry options (variable);
dcl  sys_log_$command_error entry options (variable);
dcl  terminate_file_        entry (ptr, fixed bin (24), bit (*), fixed bin (35));

/* EXTERNAL */

dcl  error_table_$action_not_performed 
                            fixed bin(35) ext static; 
dcl  error_table_$bad_arg   fixed bin (35) ext;
dcl  error_table_$bad_channel
		        fixed bin (35) ext;
dcl  error_table_$badopt    fixed bin (35) ext;
dcl  error_table_$ioname_not_active
                            fixed bin (35) ext;
dcl  error_table_$ioname_not_found
		        fixed bin (35) ext;
dcl  error_table_$ionmat    fixed bin (35) ext;
dcl  error_table_$noentry   fixed bin (35) ext; 
%page;

/* The following ten entries are used to invoke service functions of
   the answering service message coordinator program, which distributes
   messages from sources within the answering service and sources in
   daemon processes attached via "mrd_", to virtual consoles which in
   turn are connected either to real channels or to logs.
*/
accept:
     entry options (variable);

/**** The operator "accept" command.  It adds a new terminal to the
      message coordinator. */

          dutp = as_data_$dutp;	
          iutep = addr (dutbl.entry (1));		/* Initializer's utep for audit */

	arg_list_ptr = cu_$arg_list_ptr ();
	comname = "operator_mc_cmds_: accept";				/* Set up command name for err msg */

	call validate;				/* locate answer table */
	answer = "Usage: accept channel_id {authority} {target} {broadcast_list}";
	arg_index = 1;
	call cu_$arg_ptr_rel (arg_index, arg_ptr, arg_length, code,
	     arg_list_ptr);				/* arg 1 is tty id */
	if code ^= 0
	then go to ERROR_RETURN;			/* required */

	attchan = arg;

	if attchan = "otw_"
	then do;
	     answer = "This name is reserved for the system console.";
	     code = error_table_$bad_channel;
	     goto ERROR_RETURN;
	end;

	else if index (attchan, ".") ^= 0
	     then do;
		cdtep = null ();			/* may not be a terminal */
		if index (attchan, "dsa.") = 1	/* not in cdte; this test should be modified when other
						   formats of channel names become acceptable */

		then cdte_flag = ""b;
		else do;
		     cdte_flag = "1"b;
		     call check_acceptable (code);	/* make sure not used by answering service */

		     if code ^= 0
		     then go to ANSWER_RETURN;	/* error message will have been set up */
		end;

		if cdtep ^= null ()			/* if an MCS channel ... */
		then cdte.current_service_type = MC_SERVICE;
						/* flag as MC channel */
	     end;

	arg_index = arg_index + 1;
	auth_flag = "1"b;				/* assume authority is supplied */
	call cu_$arg_ptr_rel (arg_index, arg_ptr, arg_length, code,
	     arg_list_ptr);
	if code ^= 0
	then do;
	     auth_flag = ""b;			/* authority not supplied */
	     attauth = (36)"1"b;			/* second arg, if supplied, is privilege level */
	end;
	else if arg = "full"
	then attauth = (36)"1"b;			/* full is the current default */
	else if arg = "none"
	then attauth = (36)"0"b;			/* output-only terminals are ok */
	else if arg = "reply"
	then do;					/* as are reply-only */
	     attauth = "0"b;
	     addr (attauth) -> rcodebits.reply = "1"b;
						/* system_control_ checks these bits when command issured */
	end;
	else if arg = "daemon"
	then do;					/* also daemon-control */
	     attauth = "0"b;
	     addr (attauth) -> rcodebits.reply = "1"b;
	     addr (attauth) -> rcodebits.intercom = "1"b;
	     addr (attauth) -> rcodebits.exec = "1"b;
	end;
	else if arg = "query"
	then do;					/* almost zero privilege */
	     attauth = "0"b;
	     addr (attauth) -> rcodebits.status = "1"b;
	end;
	else do;					/* Assume octal. */
	     attauth = cv_oct_check_ (arg, code);
	     if code ^= 0
	     then do;
		answer = "unknown privilege code";
		go to ANSWER_RETURN;
	     end;
	end;

	answer = "Failed to accept " || attchan || ".";	/* prepare error message */
	call mc_commands_$new_tty (attchan, attauth, cdte_flag, arg_ptr,
	      code);				/* grab the new tty and set it up;
						   arg_ptr is actually superfluous here; turn_on_mc_
						   uses the value returned for the system console */

	if code = error_table_$ionmat
	then do;
	     call cu_$arg_count_rel (arg_count, arg_list_ptr, (0));
	     if arg_count = arg_index
	     then do;
		if ^auth_flag
		then				/* no new value supplied */
		     call sys_log_$command (SL_LOG, "operator_mc_cmds_: accept: ^a set to ""full"".", attchan);
		go to RETURN;
	     end;
	     code = 0;				/* go ahead and reset other attributes */
	end;

	if code = error_table_$ioname_not_active then;	/* Suppress error message on MC terminal */
	else if code ^= 0 then do;
	     if code = error_table_$ioname_not_found
	     then answer = "Channel " || attchan || "is not in Message Coordinator service.";
	     go to ERROR_RETURN;
	end;

	arg_index = arg_index + 1;
	call cu_$arg_ptr_rel (arg_index, arg_ptr, arg_length, code,
	     arg_list_ptr);				/* Next argument may be reply restricter. */
	if code ^= 0
	then do;
	     call AUDIT_OK ();
	     goto RETURN;				/* leave the rest alone */
	end;
	if arg ^= "*"
	then do;
	     answer = "Failed to set restriction to " || arg || ".";
	     call mc_commands_$set_restrict (attchan, arg, code);
	     if code ^= 0
	     then go to ERROR_RETURN;
	end;
	else do;
	     answer = "Failed to reset restriction.";
	     call mc_commands_$set_restrict (attchan, "", code);
	     if code ^= 0
	     then go to ERROR_RETURN;
	end;

	arg_index = arg_index + 1;
	call cu_$arg_ptr_rel (arg_index, arg_ptr, arg_length, code,
	     arg_list_ptr);				/* Next argument maybe broadcast list. */
	if code = 0
	then do;					/* optional. */
	     answer = "Failed to set broadcast list to " || arg || ".";
	     call mc_commands_$set_broadcast (attchan, arg, code);
	     if code ^= 0
	     then go to ERROR_RETURN;
	end;

	call AUDIT_OK ();
	go to RETURN;

%page;
accept_vchn:
     entry options (variable);

/**** The operator "accept_vchn" command.  It adds a new virtual channel
      to the message coordinator.  Virtual channels thus defined must be
      manually accepted by an operator when a user attempts to use them.*/

	arg_list_ptr = cu_$arg_list_ptr ();
	comname = "operator_mc_cmds_: accept_vchn";			/* Set up command name for err msg */

	call validate;				/* locate answer table */
	answer = "Usage: accept_vchn channel_id -auth authority -target reply_target -bc_list input_broadcast_list";
	call cu_$arg_ptr_rel (1, arg_ptr, arg_length, code, arg_list_ptr);
						/* arg 1 is tty id */
	if code ^= 0
	then go to ERROR_RETURN;			/* required */

	attchan = arg;				/* copy arg */

	if index (attchan, ".") ^= 0
	then do;
	     answer = rtrim (attchan) ||
		".  Virtual channel names may not contain a "".""";
	     code = error_table_$bad_channel;
	     goto ERROR_RETURN;
	end;

	else if attchan = "otw_"
	     then do;
		answer = "This name is reserved for the system console.";
		code = error_table_$bad_channel;
		goto ERROR_RETURN;
	     end;

	auth_flag, target_flag, bc_flag = ""b;
	reply_target, bc_list = "";

	arg_index = 2;
	do while (arg_index <= arg_count);
	     call cu_$arg_ptr_rel (arg_index, arg_ptr, arg_length, code, arg_list_ptr);
	     arg_index = arg_index + 1;

	     if arg = "-auth" | arg = "-authority"
	     then do;
		auth_flag = "1"b;			/* necessary arg */

		call cu_$arg_ptr_rel (arg_index, arg_ptr, arg_length, code, arg_list_ptr);
		if code ^= 0
		then goto ERROR_RETURN;

		arg_index = arg_index + 1;

		if arg = "full"
		then attauth = (36)"1"b;		/* full is the current default */
		else if arg = "none"
		then attauth = (36)"0"b;		/* output-only terminals are ok */
		else if arg = "reply"
		then do;				/* as are reply-only */
		     attauth = "0"b;
		     addr (attauth) -> rcodebits.reply = "1"b;
						/* system_control_ checks these bits when command issued */
		end;

		else if arg = "daemon"
		then do;				/* also daemon-control */
		     attauth = "0"b;
		     addr (attauth) -> rcodebits.reply = "1"b;
		     addr (attauth) -> rcodebits.intercom = "1"b;
		     addr (attauth) -> rcodebits.exec = "1"b;
		end;

		else if arg = "query"
		then do;				/* almost zero privilege */
		     attauth = "0"b;
		     addr (attauth) -> rcodebits.status = "1"b;
		end;

		else do;				/* bad arg */
		     code = error_table_$bad_arg;
		     answer =
			"-auth may be followed by one of the following:^/ full, none, reply, daemon, query"
			;

		     go to ERROR_RETURN;
		end;
	     end;

	     else if arg = "-target"
	     then do;
		call cu_$arg_ptr_rel (arg_index, arg_ptr, arg_length, code, arg_list_ptr);
		if code ^= 0
		then goto ERROR_RETURN;

		target_flag = "1"b;
		arg_index = arg_index + 1;

		if arg_length > length (reply_target)
		then do;
		     code = error_table_$bad_arg;
		     answer = "Bad reply target: " || arg;
		     goto ERROR_RETURN;
		end;

		reply_target = arg;
	     end;

	     else if arg = "-bc_list" | arg = "-bcl"
	     then do;
		call cu_$arg_ptr_rel (arg_index, arg_ptr, arg_length, code, arg_list_ptr);
		if code ^= 0
		then goto ERROR_RETURN;

		bc_flag = "1"b;
		arg_index = arg_index + 1;
		if arg_length > length (bc_list)
		then do;
		     code = error_table_$bad_arg;
		     answer = "Bad broadcast list: " || arg;
		     goto ERROR_RETURN;
		end;
		bc_list = arg;
	     end;
	     else do;
		code = error_table_$badopt;
		answer = "Argument not accepted: " || arg;
		goto ERROR_RETURN;
	     end;
	end;

	if ^auth_flag
	then attauth = (36)"1"b;

	answer = "Failed to accept " || attchan || ".";

	call mc_commands_$new_vchannel (attchan, attauth, arg_ptr, code);
						/* set up a new virtual channel */

	if code = error_table_$ionmat
	then do;
	     if ^auth_flag				/* no new value supplied */
						/* so report that we assumed default */
	     then call sys_log_$command (SL_LOG, "operator_mc_cmds_: accept_vchn: ^a set to ""full"".", attchan);
	     if ^bc_flag & ^target_flag		/* user specified nothing else to do; */
	     then goto RETURN;

	     code = 0;				/* go ahead and reset other attributes */
	end;


	if code ^= 0
	then go to ERROR_RETURN;

	if target_flag
	then do;

	     if reply_target ^= "*"
	     then do;
		answer = "Failed to set restriction to " || reply_target
		     || ".";
		call mc_commands_$set_restrict (attchan, reply_target,
		     code);
		if code ^= 0
		then go to ERROR_RETURN;
	     end;
	     else do;
		answer = "Failed to reset restriction.";
		call mc_commands_$set_restrict (attchan, "", code);
		if code ^= 0
		then go to ERROR_RETURN;
	     end;
	end;

	if bc_flag
	then do;
	     answer = "Failed to set broadcast list to " || rtrim(bc_list) || ".";
	     call mc_commands_$set_broadcast (attchan, (rtrim (bc_list)),
		code);
	     if code ^= 0
	     then go to ERROR_RETURN;
	end;

	go to RETURN;

%page;
/* Make entry in Message Routing Table */

route:
     entry options (variable);
	arg_list_ptr = cu_$arg_list_ptr ();
	comname = "operator_mc_cmds_: route";
	call validate;
	answer = "Incorrect number of arguments.";
	call cu_$arg_ptr_rel (1, arg_ptr, arg_length, code, arg_list_ptr);
						/* Get first argument, source id */
	if code ^= 0
	then go to ERROR_RETURN;
	source = arg;				/* Copy source id */
	call cu_$arg_ptr_rel (2, arg_ptr, arg_length, code, arg_list_ptr);
	if code ^= 0
	then go to ERROR_RETURN;
	stream = arg;				/* Copy stream id */
	call cu_$arg_ptr_rel (3, arg_ptr, arg_length, code, arg_list_ptr);
						/* get vcon */
	if code ^= 0
	then go to ERROR_RETURN;
	if substr (arg, 1, 1) = "*"
	then do;					/* Want to ring the bell? */
	     attype = "alarm";			/* yes. */
	     vcon = substr (arg, 2);
	end;
	else do;
	     attype = "";
	     vcon = arg;
	end;
	answer = "route unsuccessful.";
	call mc_commands_$route (source, stream, vcon, attype, code);
	if code ^= 0
	then go to ERROR_RETURN;
	go to RETURN;

/* Define virtual console */

define:
     entry options (variable);
	arg_list_ptr = cu_$arg_list_ptr ();
	comname = "operator_mc_cmds_: define";
	call validate;
	answer = "Incorrect number of arguments.";
	call cu_$arg_ptr_rel (1, arg_ptr, arg_length, code, arg_list_ptr);
						/* first arg is vcon id */
	if code ^= 0
	then go to ERROR_RETURN;
	vcon = arg;
	call cu_$arg_ptr_rel (2, arg_ptr, arg_length, code, arg_list_ptr);
						/* get attachment type */
	if code ^= 0
	then go to ERROR_RETURN;
	attype = arg;
	call cu_$arg_ptr_rel (3, arg_ptr, arg_length, code, arg_list_ptr);
						/* get channel id */
	if code ^= 0
	then go to ERROR_RETURN;
	attchan = arg;
	answer = "define unsuccessful.";
	call mc_commands_$define (vcon, attype, attchan, code);
	if code ^= 0
	then go to ERROR_RETURN;
	go to RETURN;

/* Redefine destination for virtual console */

redefine:
     entry options (variable);
	arg_list_ptr = cu_$arg_list_ptr ();
	comname = "operator_mc_cmds_: redefine";
	call validate;
	answer = "Incorrect number of arguments.";
	call cu_$arg_ptr_rel (1, arg_ptr, arg_length, code, arg_list_ptr);
						/* get vocn */
	if code ^= 0
	then go to ERROR_RETURN;
	vcon = arg;
	call cu_$arg_ptr_rel (2, arg_ptr, arg_length, code, arg_list_ptr);
						/* get dest */
	if code ^= 0
	then go to ERROR_RETURN;
	attchan = arg;
	call cu_$arg_ptr_rel (3, arg_ptr, arg_length, code, arg_list_ptr);
	if code ^= 0
	then go to ERROR_RETURN;
	attype = arg;
	call cu_$arg_ptr_rel (4, arg_ptr, arg_length, code, arg_list_ptr);
	if code ^= 0
	then go to ERROR_RETURN;
	attchan1 = arg;
	answer = "redefine unsuccessful.";
	call mc_commands_$redefine (vcon, attchan, attype, attchan1, code);
	if code ^= 0
	then go to ERROR_RETURN;
	go to RETURN;

/* Undefine channel from virtual console. (formerly deldest) */

undefine:
     entry options (variable);
	arg_list_ptr = cu_$arg_list_ptr ();
	comname = "operator_mc_cmds_: undefine";
	call validate;
	answer = "Incorrect number of arguments.";
	call cu_$arg_ptr_rel (1, arg_ptr, arg_length, code, arg_list_ptr);
						/* get vcon */
	if code ^= 0
	then go to ERROR_RETURN;
	vcon = arg;
	call cu_$arg_ptr_rel (2, arg_ptr, arg_length, code, arg_list_ptr);
						/* get dest */
	if code ^= 0
	then go to ERROR_RETURN;
	attchan = arg;
	answer = "undefine unsuccessful.";
	call mc_commands_$undefine (vcon, attchan, code);
	if code ^= 0
	then go to ERROR_RETURN;
	go to RETURN;

/* Swap one destination (terminal or file) for another */

substty:
     entry options (variable);
	arg_list_ptr = cu_$arg_list_ptr ();
	comname = "operator_mc_cmds_: substty";
	call validate;
	answer = "Incorrect number of arguments.";
	call cu_$arg_ptr_rel (1, arg_ptr, arg_length, code, arg_list_ptr);
						/* get channel */
	if code ^= 0
	then go to ERROR_RETURN;
	attchan1 = arg;

	virtual_dsa = ""b;
	if (index (attchan1, "dsa.") = 1) | (index (attchan1, ".") = 0) then do;
	     dsa_flag = "1"b;
	     if index (attchan1, ".") = 0 then virtual_dsa = "1"b;
	end;
	else dsa_flag = ""b;
	call cu_$arg_ptr_rel (2, arg_ptr, arg_length, code, arg_list_ptr);
						/* get new channel */
	if code ^= 0
	then go to ERROR_RETURN;
	attchan = arg;
	if attchan = attchan1
	then do;					/* bad idea */
	     answer = "cannot substty for same channel";
	     go to ANSWER_RETURN;
	end;
	if index (attchan, "dsa.") = 1
	then cdte_flag = ""b;
	else if (index (attchan, ".") ^= 0) | (attchan = "otw_")
	     then do;
	     call check_acceptable (code);
	     if code ^= 0
	     then go to ANSWER_RETURN;		/* answer set up by check_acceptable */

	     if attchan ^= "otw_"
	     then cdte.current_service_type = MC_SERVICE;	/* mark as belonging to MC */
	     cdte_flag = "1"b;
	end;

	if dsa_flag then call process_dsa_ute ((attchan1));

	answer = "removing channel " || attchan1;
	call mc_commands_$substty (attchan1, attchan, cdte_flag, arg_ptr,
	     "1"b, code);				/* arg_ptr is actually useless; it's required because
						   turn_on_mc_ and mc_commands_$substty use it to get
						   the value returned from mc_commands_$new_tty */

	if code = error_table_$action_not_performed
	then do;
	     call ioa_$rsnnl ("Channel ^a not dialed to initializer",
		answer, (0), attchan);
	     goto ANSWER_RETURN;
	end;
	if code = error_table_$noentry
	then do;
	     call ioa_$rsnnl ("Channel ^a not configured.", answer, (0),
		attchan1);
	     goto ANSWER_RETURN;
	end;
	else if code ^= 0
	then goto ERROR_RETURN;

	goto RETURN;
%page;
deroute:
     entry options (variable);

/**** Operator "deroute" command.  Deletes an entry in the Message Routing
      Table. */

	arg_list_ptr = cu_$arg_list_ptr ();
	comname = "operator_mc_cmds_: deroute";
	call validate;
	answer = "Incorrect number of arguments.";
	call cu_$arg_ptr_rel (1, arg_ptr, arg_length, code, arg_list_ptr);
						/* get source */
	if code ^= 0
	then go to ERROR_RETURN;
	source = arg;
	call cu_$arg_ptr_rel (2, arg_ptr, arg_length, code, arg_list_ptr);
						/* get stream */
	if code ^= 0
	then go to ERROR_RETURN;
	stream = arg;
	call cu_$arg_ptr_rel (3, arg_ptr, arg_length, code, arg_list_ptr);
						/* get vcon */
	if code ^= 0
	then go to ERROR_RETURN;
	vcon = arg;
	answer = "deroute unsuccessful.";
	call mc_commands_$deroute (source, stream, vcon, code);
	if code ^= 0
	then go to ERROR_RETURN;
	go to RETURN;

/* REROUTE - modify entry in Message Routing Table */

reroute:
     entry options (variable);
	arg_list_ptr = cu_$arg_list_ptr ();
	comname = "operator_mc_cmds_: reroute";
	call validate;
	answer = "Incorrect number of arguments.";
	call cu_$arg_ptr_rel (1, arg_ptr, arg_length, code, arg_list_ptr);
						/* get source */
	if code ^= 0
	then go to ERROR_RETURN;
	source = arg;
	call cu_$arg_ptr_rel (2, arg_ptr, arg_length, code, arg_list_ptr);
						/* get stream */
	if code ^= 0
	then go to ERROR_RETURN;
	stream = arg;
	call cu_$arg_ptr_rel (3, arg_ptr, arg_length, code, arg_list_ptr);
						/* get old vcon */
	if code ^= 0
	then go to ERROR_RETURN;
	vcon = arg;
	call cu_$arg_ptr_rel (4, arg_ptr, arg_length, code, arg_list_ptr);
						/* get new vcon */
	if code ^= 0
	then go to ERROR_RETURN;
	if substr (arg, 1, 1) = "*"
	then do;					/* ring bell? */
	     attype = "alarm";
	     vcon1 = substr (arg, 2);
	end;
	else do;					/* no */
	     attype = "";
	     vcon1 = arg;
	end;
	answer = "reroute unsuccessful.";
	call mc_commands_$reroute (source, stream, vcon, vcon1, attype, code);
	if code ^= 0
	then go to ERROR_RETURN;
	go to RETURN;
%page;

drop:
     entry options (variable);

/**** Operator "drop" command.  Removes a terminal from the message
      coordinator. */

          dutp = as_data_$dutp;	
          iutep = addr (dutbl.entry (1));		/* Initializer's utep for audit */

	arg_list_ptr = cu_$arg_list_ptr ();
	comname = "operator_mc_cmds_: drop";				/* set up command name */
	call validate;				/* locate anstbl */
	answer = "Incorrect number of arguments.";
	call cu_$arg_ptr_rel (1, arg_ptr, arg_length, code, arg_list_ptr);
						/* get channel */
	if code ^= 0
	then go to ERROR_RETURN;

	attchan = arg;
	virtual_dsa = ""b;
	if (index (attchan, "dsa.") = 1) | (index (attchan, ".") = 0) then do;
	     dsa_flag = "1"b;
	     if index (attchan, ".") = 0 then virtual_dsa = "1"b;
	end;
	else dsa_flag = ""b;

	cdtep = null;
	answer = "drop unsuccessful.";

	if dsa_flag then call process_dsa_ute (attchan);
	else call mc_commands_$remove_tty (attchan, "1"b, code);
						/* get rid of tty */
	if code = error_table_$action_not_performed
	then do;
	     call ioa_$rsnnl ("Channel ^a not dialed to initializer",
		answer, (0), attchan);
	     goto ANSWER_RETURN;
	end;
	if code = error_table_$noentry
	then do;
	     call ioa_$rsnnl ("Channel ^a not configured.", answer, (0),
		attchan);
	     goto ANSWER_RETURN;
	end;
	if code = error_table_$ioname_not_found
	then do;
	     call ioa_$rsnnl (
		"Channel ^a not a message coordinator terminal.",
		 answer, (0), attchan);
	     goto ANSWER_RETURN;
	end;
	else if code ^= 0
	then goto ERROR_RETURN;
		
	call AUDIT_OK ();
	go to RETURN;

%page;
/*   THAT'S IT FOLKS!   */

ERROR_RETURN:
	call sys_log_$command_error (SL_TYPE, code, comname, answer);
	go to RETURN;

ANSWER_RETURN:
	call sys_log_$command (SL_TYPE, "^a: error: ^a", comname, answer);
	go to RETURN;

RETURN:
	return;					/* almost all entries exit here */

/* INTERNAL PROCEDURES */

validate:
     proc;

	if ^sc_stat_$Multics_typed
	then as_data_$sysdir = sc_stat_$sysdir;

	if as_data_$ansp = null
	then do;
	     call hcs_$initiate (sysdir, "answer_table", "", 0, 0, as_data_$ansp, code);
	     as_procid = get_process_id_ ();
	     if as_data_$ansp = null
	     then do;
		call sys_log_$command_error (SL_LOG_BEEP, code, comname, "^a>answer_table", sysdir);
		go to RETURN;
	     end;
	end;
	ansp = as_data_$ansp;

	if whoptr = null
	then do;
	     call hcs_$initiate (sysdir, "whotab", "", 0, 0, whoptr, code);
	     if whoptr = null
	     then call sys_log_$command_error (SL_LOG_BEEP, code, comname, "^a>whotab", sysdir);
	end;
	if ip = null
	then do;
	     call hcs_$initiate (sysdir, "installation_parms", "", 0, 1, ip, code);
	     if ip = null
	     then call sys_log_$command_error (SL_LOG_BEEP, code, comname, "^a>installation_parms", sysdir);
	end;
	if scdtp = null
	then do;
	     call hcs_$initiate (sysdir, "cdt", "", 0, 1, scdtp, code);
	     if scdtp = null
	     then call sys_log_$command_error (SL_LOG_BEEP, code, comname, "^a>cdt", sysdir);
	end;
	call cu_$arg_count_rel (arg_count, arg_list_ptr, (0));
						/* AF invocation not an issue */
	return;					/* end of setup */
     end validate;
%page;

/* Internal procedure to check that channel given as argument to operator
   ACCEPT and SUBSTTY commands is available.  There are 3 cases:
   1) The CMF specified "service: mc;"
   2) The operator typed "dial system" on the terminal
   3) The operator typed "slave" on the terminal
   All other cases are rejected.
*/

check_acceptable:
     procedure (P_code);

dcl  P_code	        fixed bin (35) parameter;

	P_code = 0;
	if attchan = "otw_"
	then return;				/* "The" console is always cool */

	cdtep = FIND_CDTE (attchan);
	if cdtep ^= null ()
	then do;
	     if cdte.current_service_type = MC_SERVICE
	     then return;
	     else if cdte.current_service_type = SLAVE_SERVICE
	     then return;
	     else if cdte.current_service_type = INACTIVE
	     then return;				/* drop sets it to INACTIVE. Allow accept to get it back */
	     else do;				/* AS or FTP line. don't mess */
		P_code = 2;
		answer = "channel not available";
		return;
	     end;
	end;
	P_code = 2;
	answer = "channel not defined in cdt.";
	return;
     end check_acceptable;
%page;
FIND_CDTE:
     procedure (P_channel_name) returns (ptr);

dcl  P_channel_name	        char (*) parameter;

dcl  cdtep	        ptr automatic;
dcl  i		        fixed bin (17) automatic;

	do i = 1 to scdtp -> cdt.current_size;
	     cdtep = addr (scdtp -> cdt.cdt_entry (i));
	     if cdtep -> cdte.in_use > NOW_FREE
	     then if cdtep -> cdte.name = P_channel_name
		then return (cdtep);
	end;
	return (null ());
     end FIND_CDTE;

process_dsa_ute:
	procedure (chan_name);

dcl  chan_name		char (32) parm;
dcl  i                        fixed bin;
dcl  continue                 bit (1);

	continue = "1"b;
	if virtual_dsa then do;
	     call initiate_file_ (sysdir, "mc_anstbl", R_ACCESS, mc_ansp, (0), code);
	     if mc_ansp = null then do;
		call ioa_$rsnnl ("trying to access ^a>mc_anstbl", answer, (0), sysdir);
		goto ERROR_RETURN;
	     end;
	     do i = 1 to mc_anstbl.current_size while (continue);
		mc_atep = addr (mc_anstbl.entry (i));
		if chan_name = mc_ate.virtual_tty_name then do;
		     chan_name = mc_ate.real_tty_name;
		     continue = ""b;
		end;
	     end;
	     call terminate_file_ (mc_ansp, 0, TERM_FILE_TERM, (0));
	end;

	continue = "1"b;
	do i = 1 to anstbl.current_size while (continue);
	     utep = addr (anstbl.entry (i));
	     if ute.active = NOW_LOGGED_IN
		then do;
		if chan_name = ute.tty_name
		     then do;
		     if comname = "operator_mc_cmds_: substty" then do;
			if ute.login_flags.operator then ute.login_flags.operator = ""b;
			else if ute.login_flags.special_pw.dial_pw then
			     ute.login_flags.special_pw.dial_pw = ""b;
		     end;

		     call asu_$bump_user (utep, "", code, 0);
		     if code = error_table_$action_not_performed then code = 0;
		     else if code ^= 0 then do;
			answer = "removing user (no proc) on channel " || chan_name;
			goto ERROR_RETURN;
		     end;
		     continue = ""b;
		end;
	     end;
	end;

   end process_dsa_ute;
%page;
AUDIT_OK:
     procedure ();

dcl     action fixed bin (17);

          if rtrim(comname) = "operator_mc_cmds_: attach" then
	     action = AS_AUDIT_CHANNEL_ATTACH;
	else do;
	     action = AS_AUDIT_CHANNEL_DETACH;
	     if cdtep = null then cdtep = FIND_CDTE ((attchan));		/* Hasn't been established for drop */
	end;

	CAI.channel_name = cdte.name;
	CAI.valid = FALSE;
	CAI.valid.service_info = FALSE;
	CAI.service_info = "system";
	CAI.valid.access_class = TRUE;
	CAI.access_class = FALSE;
	CAI.valid.access_class_range = FALSE;
	CAI.access_class_range = get_process_access_class_ ();
	CAI.valid.user_validation_level = TRUE;
	CAI.user_validation_level = iutep->ute.initial_ring;

	call as_access_audit_$channel (cdtep, null, iutep, action, addr (CAI), "");
     end AUDIT_OK;

%page; %include access_audit_bin_header;
%page; %include access_mode_values;
%page; %include answer_table;
%page; %include as_audit_structures;
%page; %include as_data_;
%page; %include as_data_definitions_;
%page; %include author_dcl;
%page; %include cdt;
%page; %include daemon_user_table;
%page; %include dialup_values;
%page; %include login_server_messages;
%page; %include mc_anstbl;
%page; %include mc_restriction_codes;
%page; %include sc_stat_;
%page; %include sys_log_constants;
%page; %include terminate_file;
%page; %include user_attributes;
%page; %include user_table_entry;
%page; %include user_table_header;
%page;
/* BEGIN MESSAGE DOCUMENTATION
   Message:
   operator_mc_cmds_: COMMAND: ERROR_TABLE_MESSAGE  SYSDIR>answer_table

   S:	$as1

   T:	In response to an operator command, COMMAND.

   M:	The system was unable to access the answer_table in SYSDIR.

   A:	$inform


   Message:
   operator_mc_cmds_: COMMAND: ERROR_TABLE_MESSAGE  SYSDIR>whotab

   S:	$as1

   T:	In response to an operator command, COMMAND.

   M:	The system was unable to access the whotab in SYSDIR.

   A:	$inform


   Message:
   operator_mc_cmds_: COMMAND: ERROR_TABLE_MESSAGE  SYSDIR>installation_parms

   S:	$as1

   T:	In response to an operator command, COMMAND.

   M:	The system was unable to access the installation_parms in SYSDIR.

   A:	$inform


   Message:
   operator_mc_cmds_: COMMAND: ERROR_TABLE_MESSAGE  SYSDIR>cdt

   S:	$as1

   T:	In response to an operator command, COMMAND.

   M:	The system was unable to access the cdt in SYSDIR.

   A:	$inform


   Message:
   operator_mc_cmds_: accept: error:  unknown privilege code

   S:	$as1

   T:	In response to an operator accept command.

   M:	The operator has typed accept CHANNEL PRIVILEGE but PRIVILEGE is
   not a known privilege code.

   A:	$tryagain


   Message:
   operator_mc_cmds_: accept: ERROR_TABLE_MESSAGE Usage: accept channel_id {authority} {target} {broadcast_list}

   S:	$as1

   T:	In response to an operator accept command.

   M:	The operator has issued an accept command without any arguments.

   A:	$tryagain


   Message:
   operator_mc_cmds_: accept: ERROR_TABLE_MESSAGE Failed to accept CHANNEL.

   S:	$as1

   T:	In response to an operator accept command.

   M:	The operator has issued an accept CHANNEL command, but CHANNEL cannot
   be accepted.

   A:	$tryagain


   Message:
   operator_mc_cmds_: accept:  CHANNEL set to "full".

   S:	$as1

   T:	In response to an operator accept command.

   M:	CHANNEL is already in use and authorization request has not changed
   from it's current state.

   A:	$tryagain


   Message:
   operator_mc_cmds_: accept: ERROR_TABLE_MESSAGE Channel CHANNEL is not in
   Message Coordinator service.

   S:	$as1

   T:	In response to an operator accept command.

   M:	CHANNEL cannot be accepted as a message coordinator terminal.

   A:	$tryagain


   Message:
   operator_mc_cmds_: accept: ERROR_TABLE_MESSAGE Failed to set restriction to RESTRICTION.

   S:	$as1

   T:	In response to an operator accept command.

   M:	Failed to set the reply restriction.

   A:	$tryagain


   Message:
   operator_mc_cmds_: accept: ERROR_TABLE_MESSAGE Failed to reset restriction.

   S:	$as1

   T:	In response to an operator accept command.

   M:	Failed to reset the reply restriction.

   A:	$tryagain


   Message:
   operator_mc_cmds_: accept: ERROR_TABLE_MESSAGE Failed to set broadcast list to BROADCAST_LIST.

   S:	$as1

   T:	In response to an operator accept command.

   M:	Failed to set the broadcast list BROADCAST_LIST.

   A:	$tryagain


   Message:
   operator_mc_cmds_: accept: ERROR_TABLE_MESSAGE This name is reserved for the system console.

   S:	$as1

   T:	In response to an operator accept command.

   M:	Attempt to accept identifier "otw_" which is THE identifier for the
   master console, which is automatically accepted on bootload.

   A:	$tryagain


   Message:
   operator_mc_cmds_: accept: channel not available

   S:	$as1

   T:	In response to an operator accept command.

   M:	Channel cannot be used as a message coordinator channel.

   A:	$tryagain


   Message:
   operator_mc_cmds_: accept: channel not defined in cdt.

   S:	$as1

   T:	In response to an operator accept command.

   M:	Channel is not found in the system cdt and therefore cannot be used.

   A:	$tryagain


   Message:
   operator_mc_cmds_: accept: Ioname already attached and active. accept unsuccessful.

   S:	$as1

   T:	In response to an operator accept command.

   M:	The error was returned from mc_commands_$new_tty causing the accept
   to abort. 

   A:	$tryagain


   Message:
   operator_mc_cmds_: accept: ERROR_TABLE_MESSAGE accept unsuccessful.

   S:	$as1

   T:	In response to an operator accept command.

   M:	The error was returned from mc_commands_$new_tty causing the accept
   to abort. 

   A:	$tryagain


   Message:
   operator_mc_cmds_: accept: Ioname not found. accept unsuccessful.

   S:	$as1

   T:	In response to an operator accept command.

   M:	The error was returned from mc_commands_$new_tty causing the accept
   to abort. Channel not found in the cdt or pre-accepted as a virtual channel.

   A:	$tryagain


   Message:
   operator_mc_cmds_: COMMAND: ERROR_TABLE_MESSAGE Incorrect number of arguments.

   S:	$as1

   T:	In response to an operator command COMMAND.

   M:	Insufficient number of arguments supplied with the command.

   A:	$tryagain


   Message:
   operator_mc_cmds_: drop: error: Channel CHANNEL not a message coordinator terminal.

   S:	$as1

   T:	$response

   M:	Cannot drop CHANNEL as it cannot be found attached to the message coordinator.

   A:	$inform


   Message:
   operator_mc_cmds_: drop: error: Channel CHANNEL not configured.

   S:	$as1

   T:	$response

   M:	Channel CHANNEL is not defined in the system cdt.

   A:	$inform


   Message:
   operator_mc_cmds_: drop: error: Channel CHANNEL not dialed to initializer.

   S:	$as1

   T:	$response

   M:	CHANNEL must be dialed to the initializer before being dropped.

   A:	$inform


   Message:
   operator_mc_cmds_: drop: ERROR_TABLE_MESSAGE drop unsuccessful.

   S:	$as1

   T:	In response to an operator drop command.

   M:	An error was returned from mc_commands_$remove_tty causing the drop
   to abort.

   A:	$tryagain

   Message:
   operator_mc_cmds_: COMMAND: ERROR_TABLE_MESSAGE removing user (no proc) on channel CHANNEL

   S:     $as1

   T:     $response

   M:     An error described by ERROR_TABLE_MESSAGE occured while attempting
   the operator command, COMMAND.

   A:     $inform

   Message:
   operator_mc_cmds_: COMMAND: ERROR_TABLE_MESSAGE trying to access SYSDIR>mc_anstbl

   S:	$as1

   T:	In response to an operator command, COMMAND.

   M:     The system was not able to access the mc_anstbl in SYSDIR.

   A:	$inform


   Message:
   operator_mc_cmds_: substty: error: cannot substty for same channel

   S:	$as1

   T:	In response to an operator substty command.

   M:	The operator has attempted to use substty to substitute
   a channel for itself.

   A:	$tryagain


   Message:
   operator_mc_cmds_: substty: error: channel not available

   S:	$as1

   T:	In response to an operator accept command.

   M:	Channel cannot be used as a message coordinator channel.

   A:	$tryagain


   Message:
   operator_mc_cmds_: substty: error: channel not defined in cdt.

   S:	$as1

   T:	In response to an operator accept command.

   M:	Channel is not found in the system cdt and therefore cannot be used.

   A:	$tryagain


   Message:
   operator_mc_cmds_: substty:  ERROR_TABLE_MESSAGE removing channel CHANNEL

   S:	$as1

   T:	In response to an operator substty command.

   M:	Unable to remove CHANNEL designated as the source of the substitution.

   A:	$tryagain


   Message:
   operator_mc_cmds_: substty: Channel CHANNEL not dialed to initializer

   S:	$as1

   T:	In response to an operator substty command.

   M:	Channel CHANNEL was not previously dialed to the initializer and thus
   cannot be substituted.

   A:	$tryagain


   Message:
   operator_mc_cmds_: substty: Channel CHANNEL not configured.

   S:	$as1

   T:	In response to an operator substty command.

   M:	Channel CHANNEL is not found in the system cdt.

   A:	$tryagain


   Message:
   operator_mc_cmds_: substty: ERROR_TABLE_MESSAGE substty unsuccessful.

   S:	$as1

   T:	In response to an operator substty command.

   M:	An error was returned from mc_commands_$substty causing the substty
   to abort.

   A:	$tryagain


   Message:
   operator_mc_cmds_: substty: Ioname not found. substty unsuccessful.

   S:	$as1

   T:	In response to an operator substty command.

   M:	An error was returned from mc_commands_$substty causing the substty
   to abort.  Could not locate source channel in mc_anstbl.

   A:	$tryagain


   Message:
   operator_mc_cmds_: substty: Ioname not found. substty unsuccessful.

   S:	$as1

   T:	In response to an operator substty command.

   M:	The error was returned from mc_commands_$new_tty causing the substty
   to abort. The target channel not found in the cdt or pre-accepted as a
   virtual channel.

   A:	$tryagain


   Message:
   operator_mc_cmds_: substty: The requested action was not performed. substty unsuccessful.

   S:	$as1

   T:	In response to an operator substty command.

   M:	An error was returned from mc_commands_$substty causing the substty
   to abort. The target channel is in a "pending" state, which means it has
   not been accepted yet.

   A:	$tryagain


   Message:
   operator_mc_cmds_: redefine: ERROR_TABLE_MESSAGE redefine unsuccessful.

   S:	$as1

   T:	In response to an operator redefine command.

   M:	An error was returned from mc_commands_$redefine causing the redefine
   to abort.

   A:	$tryagain


   Message:
   operator_mc_cmds_: redefine: Ioname not found. redefine unsuccessful.

   S:	$as1

   T:	In response to an operator redefine command.

   M:	An error was returned from mc_commands_$redefine causing the redefine
   to abort. Could not locate VCONS in vcons_tab.

   A:	$tryagain


   Message:
   operator_mc_cmds_: redefine: Ioname not active. redefine unsuccessful.

   S:	$as1

   T:	In response to an operator redefine command.

   M:	An error was returned from mc_commands_$redefine causing the redefine
   to abort. Target channel not active in the mc_anstbl.

   A:	$tryagain


   Message:
   operator_mc_cmds_: redefine: Action not performed. redefine unsuccessful.

   S:	$as1

   T:	In response to an operator redefine command.

   M:	An error was returned from mc_commands_$redefine causing the redefine
   to abort. Target channel found requiring an accept in mc_anstbl.

   A:	$tryagain


   Message:
   operator_mc_cmds_: redefine: Typename not found. redefine unsuccessful.

   S:	$as1

   T:	In response to an operator redefine command.

   M:	An error was returned from mc_commands_$redefine causing the redefine
   to abort. Target VCONS type not known.

   A:	$tryagain


   Message:
   operator_mc_cmds_: redefine: Allocation could not be performed. redefine unsuccessful.

   S:	$as1

   T:	In response to an operator redefine command.

   M:	The operator has issued a redefine VCONS SOURCE STREAM VCONS
   command but the system could not make the new entry in the
   message routing table.  No action was taken.

   A:	$tryagain


   Message:
   operator_mc_cmds_: define: ERROR_TABLE_MESSAGE define unsuccessful.

   S:	$as1

   T:	In response to an operator define command.

   M:	An error was returned from mc_commands_$define causing the define
   to abort.

   A:	$tryagain


   Message:
   operator_mc_cmds_: define: Ioname not found. define unsuccessful.

   S:	$as1

   T:	In response to an operator define command.

   M:	An error was returned from mc_commands_$define causing the define
   to abort. Could not locate VCONS in vcons_tab.

   A:	$tryagain


   Message:
   operator_mc_cmds_: define: Ioname not active. define unsuccessful.

   S:	$as1

   T:	In response to an operator define command.

   M:	An error was returned from mc_commands_$define causing the define
   to abort. Target channel not active in the mc_anstbl.

   A:	$tryagain


   Message:
   operator_mc_cmds_: define: Action not performed. define unsuccessful.

   S:	$as1

   T:	In response to an operator define command.

   M:	An error was returned from mc_commands_$define causing the define
   to abort. Target channel found requiring an accept in mc_anstbl.

   A:	$tryagain


   Message:
   operator_mc_cmds_: define: Typename not found. define unsuccessful.

   S:	$as1

   T:	In response to an operator define command.

   M:	An error was returned from mc_commands_$define causing the define
   to abort. Target VCONS type not known.

   A:	$tryagain


   Message:
   operator_mc_cmds_: define: There is no room to make requested allocations.

   S:	$as1

   T:	In response to an operator define command.

   M:	The operator has issued a define SOURCE STREAM VCONS
   command but the system could not make the new entry in the
   message routing table.  No action was taken.

   A:	$tryagain


   Message:
   operator_mc_cmds_: route: There is no room to make requested allocations.

   S:	$as1

   T:	In response to an operator route command.

   M:	The operator has issued a route SOURCE STREAM VCONS command
   but the system had no room to make the new entry in the message
   routing table.  There may be up to 16 sources, each with 8 streams,
   and each stream may have up to 8 virtual consoles.  No action was taken.

   A:	$tryagain


   Message:
   operator_mc_cmds_: route: ERROR_TABLE_MESSAGE route unsuccessful.

   S:	$as1

   T:	In response to an operator route command.

   M:	An error was returned from mc_commands_$route causing the route
   to abort.

   A:	$tryagain


   Message:
   operator_mc_cmds_: route: Ioname not found. route unsuccessful.

   S:	$as1

   T:	In response to an operator route command.

   M:	An error was returned from mc_commands_$route causing the route
   to abort. VCONS not located in vcons_tab.

   A:	$tryagain


   Message:
   operator_mc_cmds_: undefine: ERROR_TABLE_MESSAGE undefine unsuccessful.

   S:	$as1

   T:	In response to an operator undefine command.

   M:	An error was returned from mc_commands_$undefine causing the
   undefine to abort.

   A:	$tryagain


   Message:
   operator_mc_cmds_: undefine: Ioname not found. undefine unsuccessful.

   S:	$as1

   T:	In response to an operator undefine command.

   M:	An error was returned from mc_commands_$undefine causing the
   undefine to abort. Could not locate VCONS in vcons_tab.

   A:	$tryagain


   Message:
   operator_mc_cmds_: reroute: ERROR_TABLE_MESSAGE reroute unsuccessful.

   S:	$as1

   T:	In response to an operator reroute command.

   M:	An error was returned from mc_commands_$reroute causing the
   reroute to abort.

   A:	$tryagain


   Message:
   operator_mc_cmds_: reroute: There is no room to make requested allocations.

   S:	$as1

   T:	In response to an operator reroute command.

   M:	The operator has issued a reroute SOURCE STREAM OLD_VCONS
   NEW_VCONS command but the system had no room to make the new entry
   in the message routing table.  There may be up to 16 sources, each
   with 8 streams, and each stream may have up to 8 virtual consoles.
   No action was taken.

   A:	$tryagain


   Message:
   operator_mc_cmds_: deroute: ERROR_TABLE_MESSAGE reroute unsuccessful.

   S:	$as1

   T:	In response to an operator deroute command.

   M:	An error was returned from mc_commands_$deroute causing the
   deroute to abort.

   A:	$tryagain


   Message:
   operator_mc_cmds_: deroute: There is no room to make requested allocations.

   S:	$as1

   T:	In response to an operator deroute command.

   M:	The operator has issued a deroute SOURCE STREAM VCONS
   command but the system had no room to make the new entry
   in the message routing table.  There may be up to 16 sources, each
   with 8 streams, and each stream may have up to 8 virtual consoles.
   No action was taken.

   A:	$tryagain


   Message:
   operator_mc_cmds_: accept_vchn: ERROR_TABLE_MESSAGE Usage: accept_vchn
     channel_id -auth authority -target reply_target -bc_list input_broadcast_list

   S:	$as1

   T:	In response to an operator accept_vchn command.

   M:	Incorrect number of arguments supplied.

   A:	$tryagain


   Message:
   operator_mc_cmds_: accept_vchn: Incorrect IO channel specification. DOT  Virtual channel names may not contain a DOT

   S:	$as1

   T:	In response to an operator accept_vchn command.

   M:	The DOT (".") character cannot be used in the virtual channel specifier.

   A:	$tryagain


   Message:
   operator_mc_cmds_: accept_vchn: Incorrect IO channel specification.
   This name is reserved for the system console.

   S:	$as1

   T:	In response to an operator accept_vchn command.

   M:	The specified virtual channel name given was "otw_".  This identifier
   cannot be used as it identifies the system console.

   A:	$tryagain


   Message:
   operator_mc_cmds_: accept_vchn: Invalid argument  -auth may be followed by one of the following:
   full, none, reply, daemon, query

   S:	$as1

   T:	In response to an operator accept_vchn command.

   M:	An incorrect argument to the -auth control argument was supplied.

   A:	$tryagain


   Message:
   operator_mc_cmds_: accept_vchn: Invalid argument  Bad reply target: TARGET

   S:	$as1

   T:	In response to an operator accept_vchn command.

   M:	An incorrect argument to the -reply control argument was supplied.

   A:	$tryagain


   Message:
   operator_mc_cmds_: accept_vchn: Specified control argument is not accpeted
   Argument not accepted: ARGUMENT

   S:	$as1

   T:	In response to an operator accept_vchn command.

   M:	An incorrect control argument was supplied to the accept_vchn request.

   A:	$tryagain


   Message:
   operator_mc_cmds_: accept_vchn: ERROR_TABLE_MESSAGE  Failed to accept VCHANNEL

   S:	$as1

   T:	In response to an operator accept_vchn command.

   M:	Unable to pre-accept VCHANNEL as a virtual channel identifier.

   A:	$tryagain


   Message:
   operator_mc_cmds_: accept_vchn: Invalid argument  Bad broadcast list: BROADCAST_LIST

   S:	$as1

   T:	In response to an operator accept_vchn command.

   M:	Incorrect argument supplied to the -bc_list control argument.

   A:	$tryagain


   Message:
   operator_mc_cmds_: accept_vchn: Ioname already attached and active. 
   VCHANNEL set to full.

   S:	$as1

   T:	In response to an operator accept_vchn command.

   M:	VCHANNEL already active and authorization request is same.

   A:	$tryagain


   Message:
   operator_mc_cmds_: accept_vchn: ERROR_TABLE_MESSAGE Failed to set restriction to REPLY_TARGET

   S:	$as1

   T:	In response to an operator accept command.

   M:	Failed to set the reply restriction for REPLY_TARGET.

   A:	$tryagain


   Message:
   operator_mc_cmds_: accept_vchn: ERROR_TABLE_MESSAGE Failed to reset restriction.

   S:	$as1

   T:	In response to an operator accept command.

   M:	Failed to reset the reply restriction.

   A:	$tryagain


   Message:
   operator_mc_cmds_: accept_vchn: ERROR_TABLE_MESSAGE Failed to set broadcast list to BROADCAST_LIST.

   S:	$as1

   T:	In response to an operator accept command.

   M:	Failed to set the broadcast list for BROADCAST_LIST.

   A:	$tryagain


   END MESSAGE DOCUMENTATION */

     end operator_mc_cmds_;
