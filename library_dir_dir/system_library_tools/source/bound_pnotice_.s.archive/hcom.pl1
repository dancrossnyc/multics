/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1985 *
        *                                                         *
        *********************************************************** */

/****^  HISTORY COMMENTS:
  1) change(1985-09-03,LJAdams), approve(1985-11-06,MCR7278),
     audit(1986-02-19,Gilcrease), install(1986-02-19,MR12.0-1021):
     This is the driver program for the history
     comment programs that provide tracking of software changes and ensure that
     the format and placement of software change notices are standard.
  2) change(1986-04-17,LJAdams), approve(1986-04-17,MCR7386),
     audit(1986-05-19,Gilcrease), install(1986-06-05,MR12.0-1071):
     When using an active function, if there is an invalid argument given set
     return string to false.  If there was an invalid argument do not take
     operand of argument as a comment spec for ADD, CHECK, or INSTALL.
  3) change(1986-05-05,LJAdams), approve(1986-05-05,MCR7386),
     audit(1986-05-19,Gilcrease), install(1986-06-05,MR12.0-1071):
     Added ability to fill or not fill comments using the -fill or -no_fill
     arguments.
  4) change(1986-09-02,LJAdams), approve(1986-09-02,MCR7526),
     audit(1986-11-05,GDixon), install(1986-11-12,MR12.0-1213):
     Reformatted error messages to be consistent.
     
     hcom get with no fields specified was not returning all fields available.
  5) change(2016-01-15,Swenson), approve(2016-01-15,MCR10006):
     Fix history_comment to use 4-digit years and be able to handle current
     date/times when there are existing history comments without thinking that
     the new ones are in the past.
                                                   END HISTORY COMMENTS */

history_comment:
hcom:
     proc;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* This command is used to insert history_comments into source_programs.        	*/
/* The command uses the pnotice_language_info_ database (created by CDS) to obtain        */
/* information on the source language segment.			          	*/
/*									*/
/* Status:								*/
/* 0) Created	   June 1985 by LJ Adams					*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


/*  A U T O M A T I C  */
	dcl     code		 fixed bin (35),
	        control		 fixed bin,
	        current_date	 char (10),
	        error_msg		 char (100) varying,
	        (i, j)		 fixed bin (24),
	        operation		 fixed bin,	/* used to indicate if operation has been set	*/
	        Sactive_function_err	 bit (1),
	        Sfill_arg		 bit (1),
	        user_name		 char (24),
	        valid		 bit (1) init ("0"b);


/*  E X T E R N A L   E N T R I E S  */
	dcl     cu_$generate_call	 entry (entry, ptr),
	        cv_entry_		 entry (char (*), ptr, fixed bin (35)) returns (entry),
	        date_time_$format	 entry (char (*), fixed bin (71), char (*), char (*)) returns (char (250) var),
	        get_temp_segments_	 entry (char (*), (*) ptr, fixed bin (35)),
	        hcom_cfix_validate_	 entry (char (*) var, char (*) var, char (*) var, bit (1), char (*) var, char (*) var, char (100) var),
	        hcom_default_validate_ entry (char (*) var, char (*) var, char (*) var, bit (1), char (*) var, char (*) var, char (100) var),
	        hcom_site_validate_	 entry options (variable),
	        hcom_process_path_	 entry (ptr),
	        ioa_		 entry () options (variable),
	        release_temp_segments_ entry (char (*), (*) ptr, fixed bin (35)),
	        requote_string_	 entry (char (*)) returns (char (*)),
	        user_info_		 entry (char (*), char (*), char (*));

/*  I N T E R N A L   S T A T I C  */
	dcl     FALSE		 bit (1) int static options (constant) init ("0"b),
	        NL		 char (1) int static options (constant) init ("
"),
	        TRUE		 bit (1) int static options (constant) init ("1"b);

	dcl     ctl		 (9, 2) char (20) var int static options (constant) init (
				 "-summary", "-sm", /* control args that take an operand.		*/
				 "-approve", "-apv",
				 "-install", "-in",
				 "-validate", "-vdt",
				 "-critical_fix", "-cfix",
				 "-fill", "-fi",
				 "-no_fill", "-nfi",
				 "-original", "-orig",
				 "-field_names", "-fn");

/*  E X T E R N A L   S T A T I C  */
	dcl     (error_table_$active_function,
	        error_table_$bad_arg,
	        error_table_$badopt,
	        error_table_$bigarg,
	        error_table_$improper_data_format,
	        error_table_$inconsistent,
	        error_table_$noarg)	 fixed bin (35) ext static;

/*  B U I L T I N  */
	dcl     (addr, after, before, clock, codeptr, convert, hbound, index, lbound,
	        length, maxlength, null, rtrim, string, substr, verify)
				 builtin;

/*  C O N D I T I O N S  */
	dcl     (cleanup,
	        linkage_error)	 condition;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* 1) Initialize error routine and argument structure.				*/
/* 2) Find out how we were invoked (command/af).					*/
/* 3) Determine what operation is being performed.				*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	Pd = addr (auto_hcom_data);
	call check_error$init ();
	call init$args;
	call get_invocation_type (d.Saf);

	do while (get_arg () & d.ag.op.name = NOTSET);	/* get operation value     */
	     if index (arg, "-") = 1 then do;		/* control args that take  */
		     control = NOTSET;		/*   an operand	       */
		     do j = lbound (ctl, 2) to hbound (ctl, 2) while (control = NOTSET);
			do i = lbound (ctl, 1) to hbound (ctl, 1) while (control = NOTSET);
			     if arg = ctl (i, j) then control = i;
			     if i = hbound (ctl, 1) then /* -fn takes multiple ops  */
				if check_arg$field_name () then ;
				else /* other control args take */
				     if get_arg () then ; /*  exactly one operand.   */
			end;
		     end;				/* diagnose bad control    */
		end;				/*  args later.	       */
	     else do;
		     do j = lbound (oper, 2) to hbound (oper, 2) while (d.ag.op.name = NOTSET);
			do i = lbound (oper, 1) to hbound (oper, 1) while (d.ag.op.name = NOTSET);
			     if arg = oper (i, j) then d.ag.op.name = i;
			end;
		     end;
		     if d.ag.op.name = NOTSET then
			call check_error$fatal (error_table_$bad_arg, CALLER, "^3x^a is not a valid operation.^/^3xSyntax: ^[[^]hcom operation path {-control_args}^[]^]
^3xOperation: ^a^6(, ^a^),^/^3x^a^(, ^a^)", arg, d.Saf, d.Saf, oper (*, 1));
		end;
	end;
	if d.ag.op.name = NOTSET then
	     call check_error$fatal (error_table_$noarg, CALLER, "^3xAn operation must be given.^/^3xSyntax:    ^[[^]hcom operation path {-control_args}^[]^]
^3xOperation: ^a^6(, ^a^),^/^3x^a^(, ^a^)", d.Saf, d.Saf, oper (*, 1));

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* 1) Set argument defaults based upon the operation.				*/
/* 2) Check active function (af) invocations to be sure the specified operation is	*/
/*    allowed as an active function.  Set default af return value.			*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if d.ag.op.name = ADD then
	     d.ag.input.select.sm, d.ag.input.select.apv = INPUTxxx;

	if d.ag.op.name = CHECK then /* set defaults				*/
	     d.ag.ctl.errors = ^d.Saf;
	else if d.ag.op.name = INSTALL then do;
		d.ag.input.select.in = INPUTxxx;
		d.ag.ctl.errors = ^d.Saf;
	     end;

	if d.Saf then do;				/* active function				*/
		if d.ag.op.name = CHECK | d.ag.op.name = EXISTS |
		     d.ag.op.name = INSTALL | d.ag.op.name = COMPARE then
						/* set default return value			*/
		     call set_return_arg ("true");
		else if d.ag.op.name = GET then ;
		else call check_error$fatal (error_table_$active_function, CALLER, "^/^3x^a is not a valid active function operation.",
			oper (d.ag.op.name, 1));	/* diagnose operations which don't work as AF	*/
	     end;
	else do;					/* Some commands hold their true/false result	*/
		if d.ag.op.name = EXISTS then /* in an hcom-provided pseudo-return value.	*/
		     call set_return_arg ("true");	/* This result is then printed when all segs 	*/
	     end;					/* are processed.				*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* 1) Scan arguments, and store control arg and operand values in the d.ag substructure.	*/
/*    a) since each control arg is accepted for several operations, control argument	*/
/*       matching and operand processing is done in a series of check_arg functions.	*/
/*       These functions return TRUE if the control arg was accepted, and FALSE		*/
/*       otherwise.  If TRUE and the control arg requires operands, then the check_arg	*/
/*       function has already processed the operands.				*/
/*    b) Noncontrol arguments are positional in order of appearance in the argument	*/
/*       list.  First comes the operation name, then the source pathname.  All remaining	*/
/*       noncontrol args are part of the comment specifier string.			*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	call reprocess_args (1);			/* Rescan the entire argument list.		*/
	operation = NOTSET;				/* Even though we know what the operation is, we	*/
						/*   must skip over the operation name in the	*/
						/*   arg list.  The operation variable determines */
						/*   whether or not we have already seen this name*/

	do while (get_arg ());
	     if index (arg, "-") = 1 then do;		/* process control args			*/
		     go to OP_CTL_ARGS (d.ag.op.name);

OP_CTL_ARGS (1):					/* ADD					*/
		     if check_arg$summary () then ;
		     else if check_arg$apv () then ;
		     else if check_arg$cfix () then ;
		     else if check_arg$install () then ;
		     else if check_arg$vdt () then ;
		     else if check_arg$fill () then ;
		     else call check_arg$ERROR;
		     goto END_OP_CTL_ARGS;

OP_CTL_ARGS (2):					/* ADD_FIELD				*/
		     if check_arg$apv () then ;
		     else if check_arg$cfix () then ;
		     else if check_arg$audit () then ;
		     else if check_arg$install () then ;
		     else if check_arg$vdt () then ;
		     else if check_arg$orig () then ;
		     else call check_arg$ERROR;
		     goto END_OP_CTL_ARGS;

OP_CTL_ARGS (3):					/* CHECK					*/
		     if check_arg$orig () then ;
		     else if check_arg$error () then ;
		     else if check_arg$vdt () then ;
		     else call check_arg$ERROR;
		     goto END_OP_CTL_ARGS;

OP_CTL_ARGS (4):					/* COMPARE				*/
		     if check_arg$orig () then ;
		     else if check_arg$vdt () then ;
		     else call check_arg$ERROR;
		     goto END_OP_CTL_ARGS;

OP_CTL_ARGS (5):					/* DISPLAY				*/
		     if check_arg$orig () then ;
		     else if check_arg$vdt () then ;
		     else call check_arg$ERROR;
		     goto END_OP_CTL_ARGS;

OP_CTL_ARGS (6):					/* EXISTS					*/
		     if check_arg$orig () then ;
		     else if check_arg$vdt () then ;
		     else call check_arg$ERROR;
		     goto END_OP_CTL_ARGS;

OP_CTL_ARGS (7):					/* FORMAT					*/
		     if check_arg$orig () then ;
		     else if check_arg$rnb () then ;
		     else if check_arg$vdt () then ;
		     else if check_arg$fill () then ;
		     else call check_arg$ERROR;
		     goto END_OP_CTL_ARGS;

OP_CTL_ARGS (8):					/* GET					*/
		     if check_arg$orig () then ;
		     else if check_arg$field_name () then ;
		     else if check_arg$vdt () then ;
		     else call check_arg$ERROR;
		     goto END_OP_CTL_ARGS;

OP_CTL_ARGS (9):					/* INSTALL				*/
		     if check_arg$orig () then ;
		     else if check_arg$error () then ;
		     else if check_arg$apv () then ;
		     else if check_arg$cfix () then ;
		     else if check_arg$install_required () then ;
		     else if check_arg$vdt () then ;
		     else call check_arg$ERROR;
		     goto END_OP_CTL_ARGS;

OP_CTL_ARGS (10):					/* REPLACE_FIELD				*/
		     if check_arg$orig () then ;
		     else if check_arg$no_summary () then ;
		     else if check_arg$apv () then ;
		     else if check_arg$cfix () then ;
		     else if check_arg$audit () then ;
		     else if check_arg$install () then ;
		     else if check_arg$vdt () then ;
		     else if check_arg$fill () then ;
		     else call check_arg$ERROR;
		     goto END_OP_CTL_ARGS;

END_OP_CTL_ARGS:
		end;

	     else if operation = NOTSET then /* First positional arg is operation keyword.	*/
		operation = d.ag.op.name;

	     else if operation ^= NOTSET & d.ag.source.path = "" then
		d.ag.source.path = arg;		/* Second positional arg is the path name.        */

	     else if operation ^= NOTSET & d.ag.source.path ^= "" then do;
		     if d.ag.op.name = ADD | d.ag.op.name = CHECK | /* Third positional arg is a comment spec	*/
			d.ag.op.name = INSTALL then do;
			     if Sactive_function_err then
				;
			     else do;
				     call set_return_arg ("false");
				     call check_error (error_table_$bad_arg, CALLER, "^3x^a^/^3xA comment specifier is not valid for the ^a operation.",
					arg, oper (d.ag.op.name, 1));
				end;
			end;
		     else
			call get_com_spec ();
		end;
	end;					/* get_arg				*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* 1) Diagnose command when no source pathname is given.				*/
/* 2) Diagnose use of old/new/diff com_spec when -original not given.			*/
/* 3) Set operation type (modify source vs no-modify) based upon operation name.	*/
/* 4) Based upon type of operation, set default control argument values for unset	*/
/*    control arguments, for cases where defaults depend upon what related control args	*/
/*    WERE given by the user.							*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if d.ag.source.path = "" then /* missing pathname				*/
	     call check_error (error_table_$noarg, CALLER, "^/^3xPathname of a source program must be given.");

	if d.orig.path = "" then
	     if d.com_spec.selected.old | d.com_spec.selected.new | d.ag.op.name = COMPARE then
		call check_error (error_table_$inconsistent, CALLER, "^3x-original must be given with the old or new comment specifier, or the compare operation.");

	if d.ag.op.name = ADD | d.ag.op.name = ADD_FIELD | /* set MODIFY operations			*/
	     d.ag.op.name = FORMAT | d.ag.op.name = INSTALL |
	     d.ag.op.name = REPLACE_FIELD then
	     d.ag.op.type = MODIFY;
	else
	     d.ag.op.type = NO_MODIFY;

	if d.ag.op.name = ADD then do;		/* set default input control args		*/
		if d.ag.input.select.sm = NOxxx then
		     d.ag.input.select.sm = INPUTxxx;	/*   summary field is required for ADD op.	*/
	     end;
	else if d.ag.op.name = ADD_FIELD then do;
		if d.ag.input.select.sm = NOxxx & d.ag.input.select.apv = NOxxx &
		     d.ag.input.select.aud = NOxxx & d.ag.input.select.in = NOxxx then
		     d.ag.input.select.apv = INPUTxxx;
	     end;
	else if d.ag.op.name = GET then
	     if string (d.ag.output) = FALSE then do i = 1 to hbound (d.field_array, 1);
						/* if GET op and no flds specified return all flds*/
		     substr (string (d.ag.output), i, 1) = TRUE;
		     d.field_array (i) = i;
		end;
	     else if d.ag.op.name = REPLACE_FIELD then do;
		     if d.ag.input.select.sm = NOxxx & d.ag.input.select.apv = NOxxx &
			d.ag.input.select.aud = NOxxx & d.ag.input.select.in = NOxxx then
			call check_error (error_table_$noarg, CALLER, "^/^3xField input control arguments are required for the replace_field operation.");
		     if Sfill_arg then
			if d.ag.input.select.sm = INPUTxxx |
			     d.ag.input.select.sm = OPERANDxxx then ;
			else
			     call check_error (error_table_$bad_arg, CALLER, "^/^3xThe -fill/-no_fill arg can only be used if -sm or -ism is also specified.");
		end;

	if string (d.com_spec.selected) = FALSE & /* set default com_spec			*/
	     d.com_spec.Nrange = 0 then do;		/* values.				*/
		if d.ag.op.name = ADD_FIELD then do;
			d.com_spec.selected.unaud = (d.ag.input.select.aud >= OPERANDxxx);
			d.com_spec.selected.unapv = (d.ag.input.select.apv >= OPERANDxxx);
			d.com_spec.selected.unin = (d.ag.input.select.in >= OPERANDxxx);
			d.com_spec.selected.aud = (d.ag.input.select.aud = CLEARxxx);
			d.com_spec.selected.apv = (d.ag.input.select.apv = CLEARxxx);
			d.com_spec.selected.in = (d.ag.input.select.in = CLEARxxx);
		     end;
		else if d.ag.op.name = CHECK then do;
			if d.ag.orig.path ^= "" then
			     d.com_spec.selected.new = TRUE;
			else
			     d.com_spec.selected.icpt = TRUE;
		     end;
		else if d.ag.op.name = DISPLAY then do;
			if d.ag.orig.path ^= "" then
			     d.com_spec.selected.new = TRUE;
			else
			     d.com_spec.selected.all = TRUE;
		     end;
		else if d.ag.op.name = EXISTS | d.ag.op.name = FORMAT |
		     d.ag.op.name = INSTALL then
		     d.com_spec.selected.all = TRUE;
		else if d.ag.op.name = GET | d.ag.op.name = REPLACE_FIELD then
		     call check_error (error_table_$noarg, CALLER, "^/^3xComment specifiers are required for the ^a operation.",
			oper (d.ag.op.name, 1));
	     end;

	if d.ag.input.value.approve_value ^= "" then do;	/* validate the approve value if given		*/
		valid = FALSE;
		if d.Scfix then do;
						/* critical fix				*/
			call hcom_cfix_validate_ ((CALLER), APPROVAL_FIELD_NAME, d.ag.input.value.approve_value, valid,
			     d.ag.input.value.approve_value, "", error_msg);
			if ^valid then
			     call check_error (-1, CALLER, "^3xInvalid approve value:  ^a^/^3x^a", d.ag.input.value.approve_value, error_msg);
		     end;
		else do;
			call d.ag.vdt ((CALLER), APPROVAL_FIELD_NAME, d.ag.input.value.approve_value, valid,
			     d.ag.input.value.approve_value, "", error_msg);
			if ^valid & error_msg = "" then do; /* user answered no to mcr question		*/
				Serror_has_occurred = TRUE;
				goto FATAL_ERROR;
			     end;
			else if ^valid then
			     call check_error (-1, CALLER, "^3xInvalid approve value:  ^a^/^3x^a", d.ag.input.value.approve_value, error_msg);
		     end;
	     end;
	if d.ag.input.value.install_id ^= "" then do;	/* validate the install id if given		*/
		valid = FALSE;
		if d.Scfix then
		     call hcom_cfix_validate_ ((CALLER), INSTALL_FIELD_NAME, d.ag.input.value.install_id, valid,
			d.ag.input.value.install_id, "", error_msg);
		else
		     call d.ag.vdt ((CALLER), INSTALL_FIELD_NAME, d.ag.input.value.install_id, valid, d.ag.input.value.install_id, "", error_msg);
		if ^valid then
		     call check_error (-1, CALLER, "^3xInvalid install id:  ^a^/^3x^a", d.ag.input.value.install_id, error_msg);
	     end;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* 1) Stop execution if any errors were reported earlier.				*/
/* 2) Establish cleanup handler for temporary segments.				*/
/* 3) Get all temp segments needed for any hcom operation.				*/
/* 4) Call hcom_process_path_ to process all the arguments.				*/
/* 5) Release all temp segments and return.					*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if check_error$error_has_occurred () then do;
	     if d.Saf then
	        call set_return_arg ("false");
	     go to FATAL_ERROR;
	     end;

	on cleanup call hcom_janitor ();

	call get_temp_segments_ (CALLER, temp_seg_array, code);
	call check_error$fatal (code, CALLER, "^/^3xError obtaining temporary segments.");

	call hcom_process_path_ (addr (d));

	if d.ag.op.name = EXISTS & ^d.Saf then
	     call ioa_ ("^a", ret);

FATAL_ERROR:
	call hcom_janitor ();
	return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* The check_arg function entrypoints return TRUE if the current control argument is one	*/
/* accepted by a given entrypoint; and FALSE otherwise.  If TRUE is returned and the	*/
/* control argument accepts operands, then check_arg processes the operands.  Values in	*/
/* the d.ag structure are adjusted appropriately based upon the given control argument	*/
/* and its operands.							*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

check_arg:
     proc;

check_arg$apv:
     entry returns (bit (1));

	if arg = "-approve" | arg = "-apv" then do;
		if get_op ("An approval value is required.  For example, MCR6734.", arg) then do;
			if op = "" then do;
				d.ag.input.value.approve_value = "";
				d.ag.input.value.approve_dt = "";
				d.ag.input.apv = CLEARxxx;
			     end;
			else do;
				if length (op) > maxlength (d.ag.input.approve_value) then
				     call check_error (error_table_$bigarg, CALLER, "^3x-approve ^a^/An approve value must^/^3xbe <= ^d characters long.", d.ag.input.approve_value, maxlength (d.ag.input.value.approve_value));

				d.ag.input.value.approve_value = op;
				d.ag.input.value.approve_dt = current_date;
				d.ag.input.apv = OPERANDxxx;
			     end;
		     end;
		return (TRUE);
	     end;
	else if arg = "-input_approve" | arg = "-iapv" then do;
		d.ag.input.value.approve_value = "";
		d.ag.input.value.approve_dt = "";
		d.ag.input.apv = INPUTxxx;
		return (TRUE);
	     end;
	else if arg = "-no_approve" | arg = "-napv" then do;
		d.ag.input.value.approve_value = "";
		d.ag.input.value.approve_dt = "";
		d.ag.input.apv = NOxxx;
		return (TRUE);
	     end;
	return (FALSE);

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

check_arg$audit:
     entry returns (bit (1));

	if arg = "-audit" | arg = "-aud" then do;
		d.ag.input.value.audit_person = rtrim (user_name);
		d.ag.input.value.audit_dt = current_date;
		d.ag.input.aud = OPERANDxxx;
		return (TRUE);
	     end;
	else if arg = "-no_audit" | arg = "-naud" then do;
		d.ag.input.value.audit_person = "";
		d.ag.input.value.audit_dt = "";
		d.ag.input.aud = NOxxx;
		return (TRUE);
	     end;
	return (FALSE);

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
check_arg$cfix:
     entry returns (bit (1));

	if arg = "-cfix" then do;
		d.Scfix = TRUE;
		if d.ag.input.apv = OPERANDxxx & index (d.ag.input.value.approve_value, "fix_") = 0 then
		     call check_error (error_table_$bad_arg, CALLER, "^3x-approve ^a^/The cfix arg has been specified a critical fix number is required.",
			d.ag.input.approve_value);
		d.ag.vdt = hcom_cfix_validate_;
		return (TRUE);
	     end;
	return (FALSE);


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

check_arg$error:
     entry returns (bit (1));

	if arg = "-errors" | arg = "-er" then do;
		d.ag.ctl.errors = TRUE;
		return (TRUE);
	     end;
	else if arg = "-no_errors" | arg = "-ner" then do;
		d.ag.ctl.errors = FALSE;
		return (TRUE);
	     end;
	return (FALSE);

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

check_arg$field_name:
     entry returns (bit (1));

	dcl     (field, i, j, k)	 fixed bin,
	        match		 fixed bin (1),
	        (OPTIONAL		 init (0),
	        REQUIRED		 init (1)) fixed bin (1) int static options (constant);

	dcl     field_name		 (9, 2) char (20) var int static options (constant) init (
				 "change_date", "cdt", /* 1*/
				 "change_person_id", "cpi", /* 2*/
				 "approve_date", "apvdt", /* 3*/
				 "approve_id", "apvi", /* 4*/
				 "audit_date", "auddt", /* 5*/
				 "audit_person_id", "audpi", /* 6*/
				 "install_date", "indt", /* 7*/
				 "install_id", "ini", /* 8*/
				 "summary", "sm");	/* 9*/

	d.field_array (*), k = 0;

	if arg = "-field_name" | arg = "-fn" then do;	/* multiple -fn controls   */
						/*   add to existing names */
		if get_op ("One or more field names are required.", arg) then ;
		do match = REQUIRED, OPTIONAL by 1 while (get_op ("", arg));
		     field = 0;
		     do j = lbound (field_name, 2) to hbound (field_name, 2) while (field = 0);
			do i = lbound (field_name, 1) to hbound (field_name, 1) while (field = 0);
			     if op = field_name (i, j) then
				field = i;
			end;
		     end;

		     if field > 0 then do;
			     substr (string (d.ag.output), field, 1) = TRUE;
			     k = k + 1;		/* store fld no so display can be positional	*/
			     d.field_array (k) = field;
			end;
		     else if match = REQUIRED then do;
			     call check_error (-1, CALLER, "^3xUnknown history comment field name: ^a ^a", arg, op);
			     return (TRUE);
			end;
		     else do;
			     call put_op ();
			     return (TRUE);
			end;
		end;
		return (TRUE);
	     end;
	return (FALSE);

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
check_arg$fill:
     entry returns (bit (1));

	if arg = "-no_fill" | arg = "-nfi" then do;
		d.ag.ctl.fill = FALSE;
		Sfill_arg = TRUE;
		return (TRUE);
	     end;
	else if arg = "-fill" | arg = "-fi" then do;
		d.ag.ctl.fill = TRUE;
		Sfill_arg = TRUE;
		return (TRUE);
	     end;

	return (FALSE);

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

check_arg$install_required:
     entry returns (bit (1));
     
          if arg = "-no_install" | arg = "-nin" then
             return (FALSE);

check_arg$install:
     entry returns (bit (1));

	if arg = "-install" | arg = "-in" then do;
		if get_op ("An install id is required.  For example, MR12.0-00234.", arg) then do;
			if op = "" then do;
				d.ag.input.value.install_id = "";
				d.ag.input.value.install_dt = "";
				d.ag.input.in = CLEARxxx;
			     end;
			else do;
				if Lop > maxlength (d.ag.input.install_id) then
				     call check_error (error_table_$bigarg, CALLER, "^3x-install ^a^/An install value must be <= ^d",
					op, maxlength (d.ag.input.value.install_id));

				d.ag.input.value.install_id = op;
				d.ag.input.value.install_dt = current_date;
				d.ag.input.in = OPERANDxxx;
			     end;
		     end;
		return (TRUE);
	     end;

	else if arg = "-input_install" | arg = "-iin" then do;
		d.ag.input.value.install_id = "";
		d.ag.input.value.install_dt = "";
		d.ag.input.in = INPUTxxx;
		return (TRUE);
	     end;

	else if arg = "-no_install" | arg = "-nin" then do;
		d.ag.input.value.install_id = "";
		d.ag.input.value.install_dt = "";
		d.ag.input.in = NOxxx;
		return (TRUE);
	     end;

	return (FALSE);


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

check_arg$orig:
     entry returns (bit (1));

	if arg = "-original" | arg = "-orig" then do;
		if get_op ("   Pathname of original version of the segment is required.", arg) then
		     d.ag.orig.path = op;
		return (TRUE);
	     end;
	return (FALSE);

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

check_arg$rnb:
     entry returns (bit (1));

	if arg = "-renumber" | arg = "-rnb" then do;
		d.ag.ctl.renumber = TRUE;
		return (TRUE);
	     end;
	else if arg = "-no_renumber" | arg = "-nrnb" then do;
		d.ag.ctl.renumber = FALSE;
		return (TRUE);
	     end;
	return (FALSE);

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

check_arg$no_summary:
     entry returns (bit (1));

	if arg = "-no_summary" | arg = "-nsm" then do;
		d.ag.input.value.summary = "";
		d.ag.input.sm = NOxxx;
		return (TRUE);
	     end;

check_arg$summary:
     entry returns (bit (1));

	if arg = "-summary" | arg = "-sm" then do;
		if get_op ("A change summary is required.", arg) then do;
			if op = "" then do;
				call check_error (error_table_$bad_arg, CALLER, "^3x^a """" Clearing the summary field is not allowed.", arg);
			     end;
			else do;
				if length (op) > maxlength (d.ag.input.summary) then
				     call check_error (error_table_$bigarg, CALLER, "^3xOperand of -summary must be <= ^d characters 
               long.", op, maxlength (d.ag.input.value.summary));

				d.ag.input.value.summary = op || NL;
				d.ag.input.sm = OPERANDxxx;
			     end;
		     end;
		return (TRUE);
	     end;
	else if arg = "-input_summary" | arg = "-ism" then do;
		d.ag.input.value.summary = "";
		d.ag.input.sm = INPUTxxx;
		return (TRUE);
	     end;
	return (FALSE);

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

check_arg$vdt:
     entry returns (bit (1));

	if arg = "-validate" | arg = "-vdt" then do;
		if get_op ("A validation routine acceptable to cv_entry_ is required.", arg) then do;
			d.ag.vdt = cv_entry_ (op, codeptr (FATAL_ERROR), code);

			call check_error (code, CALLER, "^3x^a ^a^/^3xInvalid validation entry name",
			     arg, op);
		     end;
		return (TRUE);
	     end;
	return (FALSE);
						/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

check_arg$ERROR:
     entry;

	call check_error (error_table_$badopt, CALLER, "^3x^a^/^3xfor the ^a operation.", arg, oper (d.ag.op.name, 1));
	if d.Saf then do;
		call set_return_arg ("false");
		Sactive_function_err = TRUE;
	     end;

	return;

     end check_arg;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

	dcl     Serror_has_occurred	 bit (1);		/* On if check_error has detected an error.	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* Syntax:  dcl check_error entry options(variable);				*/
/* 	  call check_error (code, procedure_name, ioa_ctl_str, args);		*/
/*     or:  dcl check_error$fatal entry options(variable);				*/
/*	  call check_error$fatal (code, procedure_name, ioa_ctl_str, args);		*/
/*									*/
/* Function: calls com_err_ or active_fnc_error_ as appropriate, to report an error on	*/
/* behalf of vtm.  check_error continues processing after the error is reported (but	*/
/* only if the user types "start" after active_fnc_err_ is called), whereas		*/
/* check_error$fatal stops all processing after the error message is printed.		*/
/*									*/
/* Args:									*/
/* code (fixed bin(35))							*/
/*    a status code.							*/
/* procedure_name (char(*))							*/
/*    name of the procedure reporting the error.					*/
/* ioa_ctl_str								*/
/*    error message								*/
/* args									*/
/*    args ioa_ will substitute into the error message.				*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


check_error:
     proc options (variable);

	dcl     Pcode		 ptr,
	        Serrors_are_fatal	 bit (1),		/* On if errors are fatal.			*/
	        code		 fixed bin (35) based (Pcode);

	dcl     com_err_		 entry () options (variable),
	        cu_$arg_list_ptr	 entry returns (ptr),
	        cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin (21), fixed bin (35));


	Serrors_are_fatal = FALSE;
	go to COMMON;

check_error$fatal:
     entry options (variable);

	Serrors_are_fatal = TRUE;
	go to COMMON;

COMMON:	call cu_$arg_ptr (1, Pcode, 0, 0);		/* Access error table code argument.		*/
	if code = 0 then return;			/* If non-zero, this ISN'T an error.		*/
	Serror_has_occurred = TRUE;
	if code = -1 then code = 0;			/* No error table code fits the desired err msg.	*/
	call cu_$generate_call (com_err_, cu_$arg_list_ptr ());
	if Serrors_are_fatal then do;
	     if d.Saf then
	        call set_return_arg ("false");
	     go to FATAL_ERROR;
	     end;
	return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* Syntax:  call check_error$init();						*/
/*									*/
/* Function:  Initializes switch indicating that no errors occurred so far.		*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

check_error$init:
     entry;

	Serror_has_occurred = FALSE;
	return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* Syntax:  error_has_occurred = check_error$error_has_occurred();			*/
/*									*/
/* Function:  tell callers if any errors have occurred so far.			*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


check_error$error_has_occurred:
     entry returns (bit (1));

	return (Serror_has_occurred);

     end check_error;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

	dcl     Iarg		 fixed bin,	/* Current argument being processed.		*/
	        Larg		 fixed bin (21),	/* Length of current argument.		*/
	        Lop		 fixed bin (21),	/* Length of current ctl arg operand.		*/
	        Lret		 fixed bin (21),	/* Max length of AF return value.		*/
	        Nargs		 fixed bin,	/* Number of arguments.			*/
	        Parg		 ptr,		/* Ptr to current argument.			*/
	        Pop		 ptr,		/* Ptr to current operand.			*/
	        Pret		 ptr,		/* Ptr to AF return value.			*/
	        arg		 char (Larg) based (Parg),
	        op		 char (Lop) based (Pop),
	        ret		 char (Lret) varying based (Pret),
	        true_false_value	 char (5) varying,
	        (arg_ptr		 variable,
	        cu_$af_arg_ptr,
	        cu_$arg_ptr)	 entry (fixed bin, ptr, fixed bin (21), fixed bin (35)),
	        cu_$af_return_arg	 entry (fixed bin, ptr, fixed bin (21), fixed bin (35)),
	        (err		 variable,
	        active_fnc_err_,
	        com_err_)		 entry () options (variable);

get_invocation_type:				/* Were we invoked as command or af?  Arg count?	*/
     proc (Saf);

	dcl     Saf		 bit (1) aligned;

	call cu_$af_return_arg (Nargs, Pret, Lret, code);
	if code = 0 then do;
		Saf = TRUE;
		arg_ptr = cu_$af_arg_ptr;
		err = active_fnc_err_;
		ret = "";
	     end;
	else do;
		Saf = FALSE;
		arg_ptr = cu_$arg_ptr;
		err = com_err_;
		Pret = addr (true_false_value);
		Lret = maxlength (true_false_value);
		ret = "";
	     end;
	Iarg = 0;					/* No args processed so far.			*/

     end get_invocation_type;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

get_arg:
     proc returns (bit (1));				/* Returns TRUE if another argument exists.	*/
						/*   Its value is accessible via arg variable.	*/

	if Iarg + 1 > Nargs then
	     return (FALSE);
	Iarg = Iarg + 1;
	call arg_ptr (Iarg, Parg, Larg, code);
	return (TRUE);

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

get_op:
     entry (str, arg1) returns (bit (1));		/* Returns TRUE if another argument exists.	*/
						/*   Its value is accessible via op variable.	*/

	dcl     str		 char (*),
	        arg1		 char (*);

	if Iarg + 1 > Nargs then do;
		if str ^= "" then
		     call check_error (error_table_$noarg, CALLER, "^3xOperand of ^a^/^a", arg1, str);
		return (FALSE);
	     end;
	Iarg = Iarg + 1;
	call arg_ptr (Iarg, Pop, Lop, code);
	return (TRUE);

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

put_arg:						/* Return argument or      */
put_op:						/* operand to list of      */
     entry;					/* unprocessed d.ag.       */

	Iarg = Iarg - 1;
	return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


reprocess_args:					/* Reprocess argument list again, starting with	*/
     entry (Ith_arg);				/*   the Ith argument.			*/

	dcl     Ith_arg		 fixed bin;

	Iarg = Ith_arg - 1;				/* get_arg adds 1 before reading an arg.	*/
	return;

     end get_arg;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

set_return_arg:					/* Set AF return value.			*/
     proc (str);

	dcl     str		 char (*);

	ret = str;
	return;

add_to_return_arg:
     entry (str);

	if ret = "" then
	     ret = requote_string_ (str);
	else do;
		ret = ret || " ";
		ret = ret || requote_string_ (str);
	     end;
	return;


add_to_return_arg_var:
     entry (str_var);

	dcl     str_var		 char (*) varying;

	if ret = "" then
	     ret = requote_string_ ((str_var));
	else do;
		ret = ret || " ";
		ret = ret || requote_string_ ((str_var));
	     end;
	return;

     end set_return_arg;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

get_com_spec:
     proc;

	dcl     from_arg		 char (80) var,
	        (spec, i, j)	 fixed bin,
	        to_arg		 char (80) var;

	dcl     specs		 (11, 2) char (12) var int static options (constant) init (
				 "all", "a",	/*  1 */
				 "old", "~",	/*  2 */
				 "new", "~",	/*  3 */
				 "complete", "cpt", /*  4 */
				 "incomplete", "icpt", /*  5 */
				 "approved", "apv", /*  6 */
				 "unapproved", "unapv", /*  7 */
				 "audited", "aud",	/*  8 */
				 "unaudited", "unaud", /*  9 */
				 "installed", "in", /* 10 */
				 "uninstalled", "unin"); /* 11 */

	spec = 0;
	do j = lbound (specs, 2) to hbound (specs, 2) while (spec = 0);
	     do i = lbound (specs, 1) to hbound (specs, 1) while (spec = 0);
		if arg = specs (i, j) then
		     spec = i;
	     end;
	end;
	if spec > 0 then
	     substr (string (d.com_spec.selected), spec, 1) = TRUE;

	else do;
		d.com_spec.Nrange = d.com_spec.Nrange + 1;
		d.com_spec.range (d.Nrange) = 0;
		from_arg = before (arg, ":");
		to_arg = after (arg, ":");
		d.com_spec.from (d.Nrange) = get_range (from_arg);

		if to_arg ^= "" then /* one part				*/
		     d.com_spec.to (d.Nrange) = get_range (to_arg);
	     end;					/*range*/
	return;

get_range:
     proc (arg_in) returns (1 like d.com_spec.range.from);

	dcl     arg_in		 char (80) var;
	dcl     1 arg_out		 like d.com_spec.range.from;

	dcl     operand		 char (80) var,
	        addend		 char (80) var;

	operand, addend = "";
	arg_out = 0;
	arg_out.set = SET;

	if index (arg_in, "+") > 0 then do;
		operand = before (arg_in, "+");
		addend = after (arg_in, "+");
		arg_out.op = PLUS;
	     end;
	else if index (arg_in, "-") > 0 then do;
		operand = before (arg_in, "-");
		addend = after (arg_in, "-");
		arg_out.op = MINUS;
	     end;
	else do;
		operand = arg_in;
		addend = "";
		arg_out.op = UNSET;
	     end;

	if verify (operand, "0123456789") = 0 then
	     arg_out.no = convert (arg_out.no, operand);
	else do;
		if operand = "first" | operand = "f" then
		     arg_out.no = 1;
		else if operand = "last" | operand = "l" then
		     arg_out.set = LAST;
		else call check_error$fatal (error_table_$badopt, CALLER, "^3x^a.", arg_in);
	     end;

	if addend ^= "" then do;
		if verify (addend, "0123456789") = 0 then
		     arg_out.addend = convert (arg_out.addend, addend);
		else
		     call check_error (error_table_$improper_data_format, CALLER, "^/^3xThe addend must be numeric:  ^a", addend);
	     end;

	return (arg_out);

     end get_range;

     end get_com_spec;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


hcom_janitor:
     proc;

	dcl     code		 fixed bin (35);

	if temp_seg_array (1) ^= null then
	     call release_temp_segments_ (CALLER, temp_seg_array, code);

     end hcom_janitor;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


init$args:
     proc;

	current_date = date_time_$format ("^9999yc-^my-^dm", clock (), "", "");
	call user_info_ (user_name, "", "");

	d.ag.op.name = NOTSET;
	d.ag.op.type = NO_MODIFY;

	Sactive_function_err = FALSE;
	Sfill_arg = FALSE;

	on linkage_error
	     begin;
		d.Ssite = FALSE;
		d.ag.vdt = hcom_default_validate_;
		goto CONTINUE;
	     end;

	d.ag.vdt = hcom_site_validate_;
	d.Ssite = TRUE;

CONTINUE:
	d.ag.ctl.renumber = FALSE;
	d.ag.ctl.errors = TRUE;
	d.ag.ctl.fill = TRUE;
	d.ag.source.path, d.ag.source.dir, d.ag.source.ent, d.ag.source.comp = "";
	d.ag.source.ent_type = 0;
	d.ag.orig = d.ag.source;
	d.ag.input.select = NOxxx;
	d.ag.input.value.change_dt = current_date;
	d.ag.input.value.seqno = 0;
	d.ag.input.value.selected = FALSE;
	d.ag.input.value.Ieq = 0;
	d.ag.input.value.comment_no = 0;
	d.ag.input.value.change_person = rtrim (user_name);
	d.ag.input.value.approve_dt = "";
	d.ag.input.value.approve_value = "";
	d.ag.input.value.audit_dt = "";
	d.ag.input.value.audit_person = "";
	d.ag.input.value.install_dt = "";
	d.ag.input.value.install_id = "";
	d.ag.input.value.summary = "";
	d.ag.output = FALSE;

	d.com_spec.selected = FALSE;
	d.com_spec.matched = FALSE;
	d.com_spec.Nrange, d.com_spec.range = 0;

	d.check_error$fatal = check_error$fatal;
	d.set_return_arg = set_return_arg;
	d.add_to_return_arg = add_to_return_arg;
	d.add_to_return_arg_var = add_to_return_arg_var;
	d.Saf = FALSE;
	d.Scfix = FALSE;
	d.Scfix_found = FALSE;

	d.seg_arch.dir, d.seg_arch.ent, d.seg_arch.comp = "";
	d.seg_arch.comp_type = NOCOMP;
	d.seg_arch.Pseg = null;
	d.seg_arch.Lseg, d.seg_arch.Lsegbc = 0;

	d.seg = d.seg_arch, by name;
	d.seg.Lseg_in, d.seg.Lseg_out = 0;
	d.seg.ec_version, d.seg.type, d.seg.text_pos = 0;
	d.seg.cmt_bgn, d.seg.cmt_end = "";
	d.seg.Pbox = null;
	d.seg.Loldbox = 0;
	d.seg.Lnewbox = 0;

	d.orig_seg = d.seg;

	d.temp_seg = null;

     end init$args;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

%include hcom_data;

	dcl     1 auto_hcom_data	 like d automatic;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

%include hcom_field_names;
     end history_comment;
