/****^  ********************************************
        *                                          *
        * Copyright, (C) Honeywell Bull Inc., 1987 *
        *                                          *
        ******************************************** */

/****^  HISTORY COMMENTS:
  1) change(87-01-05,GDixon), approve(87-04-15,MCR7617),
     audit(87-06-22,RBarstad), install(87-07-15,MR12.1-1040):
     Completely rewritten, combining copy and compare functions into a single
     command.
                                                   END HISTORY COMMENTS */

copy_dump_tape:
	proc options(variable);
	
    dcl	ME			char(17),		/* command called*/
	abort_sw			bit(1),		/* on: -abort    */
	code			fixed bin(35),
	1 compared		aligned like copied,/* count compares*/
	1 copied			aligned,		/* count copied  */
	  2 segs			fixed bin,	/*  entries      */
	  2 msfs			fixed bin,	/*  msfs	       */
	1 cpbf			aligned like inbf,	/* copy record   */
	1 cphe			aligned like inhe based (cpbf.hp),
	1 cphe_name		aligned like inhe_name based (cpbf.hp),
	1 cplast			aligned like inlast,/* last rec read */
						/*  from copy    */
						/*  tape.	       */
	1 inbf			aligned,		/* input record  */
	  2 blrh,					/*  backup dump  */
	    3 zz1			char(32),		/*   record head */
	    3 english		char(56),
	    3 zz2			char(32),
	    3 sizes,
	      4 hl		fixed bin(21),
	      4 segl		fixed bin(21),
	  2 hp			ptr,		/*  header ptr   */
	  2 segp			ptr,		/*  segment ptr  */
	1 inhe			aligned like h based (inbf.hp),
						/*  header       */
	1 inhe_name		aligned based (inbf.hp),
	  2 dname			char(168) varying,
	  2 ename			char(32) varying,
	1 inlast			aligned,		/* last seg read */
	  2 path			unal,		/*  from in tape.*/
	    3 dir			char (168),
	    3 ent			char (32),
	  2 sizes,
	    3 he			fixed bin(35),
	    3 seg			fixed bin(35),
	1 input			aligned,		/* input medium  */
	  2 header		like in_out.header,
	  2 vol (20)		like in_out.vol,	/*  tape names   */
	1 map			aligned,		/* map file      */
	  2 header		like in_out.header,
	1 map_prev		aligned,		/* map file      */
	  2 header		like in_out.header,
	1 mbf			aligned like inbf based(addr(inbf)),
						/* master record */
	1 mhe			aligned like h based (mbf.hp),
						/*  header       */
	1 mhe_name		aligned like inhe_name based (mbf.hp),
	1 mlast			aligned like inlast,/* last record   */
						/*  read from    */
						/*  master tape. */
	maximize_devices_sw		bit(1),		/* on: -maxdv    */
	operation_now		fixed bin,	/* cur function  */
	operation_wanted		fixed bin,	/* wanted fcn    */
	1 output			aligned,		/* output medium */
	  2 header		like in_out.header,
	  2 vol (20)		like in_out.vol,	/*  tape names   */
	1 select			aligned,		/* copy selected */
	  2 header		like in_out.header, /*  files only   */
	  2 listp			ptr,		/*  path list    */
	  2 select_sw		bit(1),		/*  on: -select  */
						/*   without opt,*/
						/*   -select used*/
						/*  by compare ep*/
	state			fixed bin,	/* result of     */
						/*  read_seg fcn */
	trace			fixed bin;	/* -trace XXX    */

    dcl	1 in_out			aligned based (in_outp),
	  2 header,
	    3 name		char(8) varying,	/* log file name */
	    3 iocbp		ptr,		/* IOCB ptr      */
	    3 target_iocbp		ptr,
	    3 mode		fixed bin,	/* opening mode  */
	    3 recx		fixed bin,	/* cur rec       */
	    3 vfile,				/* input file    */
	      4 path		char(168) unal,
	      4 expath		char(168) unal,
	      4 charpos		fixed bin(35),	/* pos of last   */
						/*  char read    */
	    3 tape,				/* input tapes.  */
	      4 voln		fixed bin,	/*  total	       */
	      4 volx		fixed bin,	/*  current      */
	      4 track		fixed bin,	/*  track	       */
	      4 density		fixed bin,	/*  density      */
	  2 vol (20),
	    3 name		char(32),		/*  vol names    */
	    3 device		char(32),		/*  device used  */
	in_outp			ptr,		/* ptr to input  */
						/*  or output    */
	severity			fixed bin based (severityp),
	severityp			ptr;

    dcl  (addr, bin, char, clock, dim, divide, hbound, index,
	lbound, length, ltrim, max, maxlength, min, mod, null, ptr, rtrim,
	search, string, substr, unspec, verify)
				builtin;

    dcl	cleanup			condition;

    dcl	absolute_pathname_		entry (char(*), char(*), fixed bin(35)),
	absolute_pathname_$add_suffix	entry (char(*), char(*), char(*), fixed bin(35)),
 	backup_map_$beginning_line	entry (fixed bin(52), ptr, fixed bin),
	backup_map_$detail_line2	entry (char(32) aligned, fixed bin(9),
				     char(10) aligned, fixed bin(52),
				     fixed bin(52), fixed bin(52),
				     fixed bin(52), fixed bin(52)),
	backup_map_$detach_for_cdt	entry (fixed bin(35)),
	backup_map_$directory_line	entry (ptr, fixed bin),
	backup_map_$heading_line	entry,
	backup_map_$init_for_cdt	entry (char(128) var),
	backup_map_$name_line	entry (ptr, fixed bin),
	backup_map_$tapes		entry (ptr, fixed bin),
	backup_map_$terminal_line	entry (fixed bin(52), fixed bin),
	backup_util$idline		entry (char(*), char(*), ptr,
				     fixed bin),
	convert_ipc_code_		entry options(variable),
	cu_$arg_list_ptr		entry returns(ptr),
	date_time_$format		entry (char(*), fixed bin(71),
				     char(*), char(*))
				     returns(char(250) var),
	get_line_length_$switch	entry (ptr, fixed bin(35)) returns(fixed bin),
	get_shortest_path_		entry (char(*)) returns(char(168)),
	ioa_			entry() options(variable),
	iox_$attach_name		entry (char(*), ptr, char(*), ptr,
				     fixed bin(35)),
	iox_$attach_ptr		entry (ptr, char(*), ptr,
				     fixed bin(35)),
	iox_$close		entry (ptr, fixed bin(35)),
	iox_$control		entry (ptr, char(*), ptr,
				     fixed bin(35)),
	iox_$destroy_iocb		entry (ptr, fixed bin(35)),
	iox_$detach_iocb		entry (ptr, fixed bin(35)),
	iox_$find_iocb		entry (char(*), ptr, fixed bin(35)),
	iox_$get_chars		entry (ptr, ptr, fixed bin(21),
				     fixed bin(21), fixed bin(35)),
	iox_$get_line		entry (ptr, ptr, fixed bin(21),
				     fixed bin(21), fixed bin(35)),
	iox_$modes		entry (ptr, char(*), char(*),
				     fixed bin(35)),
	iox_$move_attach		entry (ptr, ptr, fixed bin(35)),
	iox_$open			entry (ptr, fixed bin, bit(1) aligned,
				     fixed bin(35)),
	iox_$position		entry (ptr, fixed bin, fixed bin(35),
				     fixed bin(35)),
	iox_$put_chars		entry (ptr, ptr, fixed bin(21),
				     fixed bin(35)),
	ipc_$block		entry (ptr, ptr, fixed bin(35)),
	ipc_$create_ev_chn		entry (fixed bin(71), fixed bin(35)),
	ipc_$delete_ev_chn		entry (fixed bin(71), fixed bin(35)),
	pathname_			entry (char(*), char(*))
				     returns(char(168)),
	rcp_$assign_device		entry (char (*), ptr, fixed bin (71),
				     char (*), bit (36) aligned,
				     fixed bin (35)),
	rcp_$check_assign		entry (bit (36) aligned, ptr, char (*),
				     fixed bin, fixed bin (35)),
	rcp_$copy_list		entry (ptr, fixed bin (21),
				     fixed bin (35)),
	rcp_$unassign		entry (bit (36) aligned, bit (*),
				     char (*), fixed bin (35)),
	ssu_$get_invocation_count	entry (ptr, fixed bin, fixed bin),
	ssu_$get_temp_segment	entry (ptr, char(*), ptr),
	unique_chars_		entry (bit(*)) returns(char(15));

    dcl	BLOCK_SIZE		fixed bin int static options(constant) init(256),
	BLRH_DELIMITER		char(32) int static options(constant)
				init(
				  " z z z z z z z z z z z z z z z z"),
	BLRH_ENGLISH		char(56) int static options(constant)
				init("This is the beginning of a backup logical record."),
         (DESTROY			init(1),
          KEEP			init(2)) fixed bin int static options(constant),
         (FALSE			init("0"b),
	TRUE			init("1"b)) bit(1) int static options(constant),
	FOR_MOVE_ATTACH		fixed bin int static options(constant) init(-1),
         (REJECTS			init(-1),
	OFF			init(0),
	COPY			init(1),
	COMPARE			init(2),
	COPY_AND_COMPARE		init(3)) fixed bin int static options(constant),
         (OK			init(0),
	READ_AGAIN		init(1),
	NOMORE			init(2)) fixed bin int static options(constant),
	compare_dump_tape_severity_	fixed bin ext static init (0),
	copy_dump_tape_map_		char(168) varying ext static init(""),
	copy_dump_tape_severity_	fixed bin ext static init (0),
	copy_dump_tape_tapes	char(300) varying ext static init(""),
         (error_table_$bad_opt,
	error_table_$device_end,
	error_table_$end_of_info,
	error_table_$inconsistent,
	error_table_$noarg,
	error_table_$not_detached,
	error_table_$resource_reserved,
	error_table_$resource_unavailable,
	error_table_$too_many_names,
	error_table_$wrong_no_of_args)
				fixed bin(35) ext static;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* ENTRY POINT IDENTIFICATION:				       */
/* 1) Identify command entrypoint.				       */
/* 2) Set operation code.					       */
/* 3) Identify command severity variable.			       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	ME = "copy_dump_tape";
	operation_wanted = COPY;
	severityp = addr(copy_dump_tape_severity_);
	copy_dump_tape_tapes = "";
	copy_dump_tape_map_ = "";
	go to COPY_COMPARE;
	
compare_dump_tape:
	entry options(variable);
	
	ME = "compare_dump_tape";
	operation_wanted = COMPARE;
	severityp = addr(compare_dump_tape_severity_);
	go to COPY_COMPARE;

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* INVOCATION TYPE AND ARGUMENTS:				       */
/* 1) Set severity variable to indicate success.			       */
/* 2) Initialize variables used in cleanup handler, and establish handler.   */
/* 3) Create standalone ssu_ invocation for argument processing.	       */
/* 4) Initialize argument handling routines.			       */
/* 5) Process input arguments, reporting any errors as they are encountered. */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

COPY_COMPARE:
	severity = 0;
	sci_ptr = null;
	call initialize_args();
	on cleanup call cleanup_invocation();
	call ssu_$standalone_invocation (sci_ptr, ME, "1.0",
	   cu_$arg_list_ptr(), exit_proc, code);
	call check_invocation_type (ALLOW_COMMAND);
	call process_args();

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* PROCESSING:						       */
/* 1) If -select was given, process the select file to build a select tree.  */
/* 2) If -map was given, open the map file.			       */
/* 3) If tapes are being used for input or output, survey tape drives	       */
/*    assigned to the process.				       */
/* 4) If copying, attach input/output files, do the copying, detach	       */
/*    input/output files.  If output was to tape, report which tapes were    */
/*    actually written on.					       */
/* 5) If comparing, attach master/copy files, do the comparing, detach       */
/*    input/output files.					       */
/* 6) If copying and comparing, report discrepancy between number of segs    */
/*    copied vs number compared.				       */
/* 7) If -trace, report any -select pathnames that were not matched.	       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if select.vfile.path ^= "" then do;
	   call ioa_ ("");
	   call attach (addr(select), Stream_input);
	   call skip_seg$init();
	   call ssu_$print_message (sci_ptr, 0,
	      "^a: ^d select lines processed.", hhmmm(), select.recx);
	   call detach (addr(select), DESTROY);
	   end;

	if map.vfile.path ^= "" then do;
	   call ioa_ ("");
	   call attach (addr(map), Stream_output);
	   copy_dump_tape_map_ = map.vfile.expath;
	   end;

	if input.tape.voln > 0 | output.tape.voln > 0 then
	   call tape_drive$survey();

	if mod (operation_wanted, 2) = COPY then do;
	   operation_now = COPY;
	   call header("BEGIN COPYING", input, output);
	   call attach (addr(input), Stream_input);
	   call attach (addr(output), Stream_output);
	   call map_seg$init (output);
	   call copy_segs();
	   if output.tape.voln > 0 then do;
	      output.tape.voln = output.tape.volx;
	      call ioa_ ("");
	      call ssu_$print_message (sci_ptr, 0,
	         "NOTE: Files were copied onto ^d ^a tape^[s^]:^v( ^a^)^/",
	         output.tape.voln, output.header.name, output.tape.voln>1,
	         output.tape.voln, output.vol.name);
	      copy_dump_tape_tapes = output.vol(1).name;
	      do output.tape.volx = 2 to output.tape.voln;
	         copy_dump_tape_tapes = copy_dump_tape_tapes || " ";
	         copy_dump_tape_tapes = copy_dump_tape_tapes ||
		  output.vol(output.tape.volx).name;
	         end;
	      end;
	   end;

	if operation_wanted >= COMPARE then do;
	   operation_now = COMPARE;
	   call header ("BEGIN COMPARING", input, output);
	   call attach (addr(input), Stream_input);
	   call attach (addr(output), Stream_input);
	   call compare_segs();
	   end;

	if operation_wanted = COPY_AND_COMPARE then do;
	   operation_now = COPY_AND_COMPARE;
	   if copied.segs ^= compared.segs |
	      copied.msfs ^= compared.msfs then do;
	      severity = max(severity, 3);
	      call ioa_ ("");
	      call error (sci_ptr, -1,
	         "^a: FATAL ERROR: Copy/Compare Count Discrepancy.
Copied:    ^5d segment^[s,^;, ^] ^5d msf^[s^]
Compared:  ^5d segment^[s,^;, ^] ^5d msf^[s^]",
	         hhmmm(),
	         copied.segs, copied.segs^=1, copied.msfs, copied.msfs^=1, 
	         compared.segs, compared.segs^=1, compared.msfs, compared.msfs^=1);
	      end;
	   end;

	call skip_seg$term();

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* REVOCATION AND EXIT:					       */
/*   This point is reached when normal processing completes successfully,    */
/* or when the error$fatal routine is called to abnormally end processing.   */
/*							       */
/* 1) Report status of all processing.				       */
/* 2) Cleanup the standalone invocation.			       */
/* 3) Return to command processor.				       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

EXIT:	call ioa_ ("");
	call ssu_$print_message (sci_ptr, 0,
"^a: ^[Copy^;Compare^;Copy and compare^] ^" ||
"[completed successfully.^;
^;completed successfully,
  except for unmatched lines in select file (severity 2 error).
^;failed due to 
  comparison errors (severity 3 error).
^;failed due to 
  fatal error (severity 4 error).^]^2/", 
	   hhmmm(), operation_wanted, severity+1);
	call cleanup_invocation();
	return;

exit_proc:
	proc;
	severity = max(severity, 4);
	go to EXIT;
	end exit_proc;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* ATTACH to TAPE or STORAGE SYSTEM FILE:			       */
/* 1) Name and get pointer to I/O switch.			       */
/* 2) Attach and open switch.  Tapes are attached by mount_next_tape_vol.    */
/* 3) Report the attachment.					       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

attach:	proc (iop, mode);

    dcl	iop			ptr,
	1 io			aligned like input based(iop),
	mode			fixed bin;
    dcl	atd			char(300) varying,
	code			fixed bin(35),
	count			fixed bin,
	io_switch_name		char(32);

	io.mode = mode;
	io.recx = 0;
	call ssu_$get_invocation_count (sci_ptr, count, 0);
	io_switch_name = rtrim(ME) || "." || ltrim(char(count)) ||
	   "." || io.header.name;
	if mode = FOR_MOVE_ATTACH then
	   call iox_$find_iocb (io_switch_name, io.target_iocbp, code);
	else
	   call iox_$find_iocb (io_switch_name, io.iocbp, code);

	if io.vfile.path ^= "" then do;
	   atd = "vfile_ " || rtrim(io.vfile.expath);
	   if mode = Stream_input then
	      atd = atd || " -old";
	   call iox_$attach_ptr (io.iocbp, (atd), null, code);
	   call error$fatal (sci_ptr, code,
	      "^/FATAL ERROR: Attaching ^a file ^a.", io.header.name,
	      io.vfile.expath);
	   call iox_$open (io.iocbp, mode, ""b, code);
	   call error$fatal (sci_ptr, code,
	      "^/FATAL ERROR: Opening ^a file ^a for ^a.", io.header.name,
	      io.vfile.expath, iox_modes(mode));
	   call ssu_$print_message (sci_ptr, 0,
	      "^a: Attached ^a for ^a to file:^/  ^a.^[^/  (^a)^]",
	      hhmmm(), io.header.name, iox_modes(mode),
	      io.vfile.expath, trace ^= OFF, atd);
	   io.vfile.charpos = 0;
	   end;
	else if io.tape.voln > 0 then do;
	   io.tape.volx = 0;
	   if mount_next_tape_vol (io) then;
	   else
	      call error$fatal (sci_ptr, -1,
	         "FATAL ERROR: Unable to attach^[ first^] ^a tape ^a.",
	         io.tape.voln>1, io.header.name, io.vol(1).name);
	   end;
	end attach;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* ARGUMENT PROCESSING:					       */
/* Declare variables and subroutines needed for argument processing.	       */
/*							       */
/* CHECK INVOCATION TYPE:					       */
/* 1) Initialize error handling subroutines.			       */
/* 2) Determine whether invoked as command or af.			       */
/* 3) Is this type of invocation allowed?			       */
/* 4) Initialize af return argument, and index of current argument.	       */
/*							       */
/* SEE OTHER ARGUMENT PROCESSING PROGRAMS:			       */
/*   get_arg, get_ctl_arg, get_opt, get_num_opt			       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

    dcl	af_sw			bit(1) aligned,	/* on: active fnc*/
	arg			char(argl) based(argp),
	argl			fixed bin(21),	/* current arg   */
	argp			ptr,
	argn			fixed bin,	/* arg count     */
	argx			fixed bin,	/* arg index     */
	num_opt			fixed bin,	/* numeric option*/
	opt			char(optl) based(optp),
	optl			fixed bin(21),	/* current option*/
	optp			ptr,
	ret			char(retl) varying based(retp),
	retl			fixed bin(21),	/* af return val */
	retp			ptr,
	sci_ptr			ptr;		/* ssu_ info ptr */

    dcl	ssu_$abort_subsystem	entry() options(variable),
	ssu_$arg_ptr		entry (ptr, fixed bin, ptr, fixed bin(21)),
	ssu_$destroy_invocation	entry (ptr),
	ssu_$print_message		entry() options(variable),
	ssu_$return_arg		entry (ptr, fixed bin, bit(1) aligned, ptr, fixed bin(21)),
       	ssu_$standalone_invocation	entry (ptr, char(*), char(*), ptr,
				     entry, fixed bin(35));

    dcl  (ALLOW_COMMAND		init(1),
          ALLOW_AF			init(2),
	ALLOW_COMMAND_AF		init(3)) fixed bin int static options(constant);

check_invocation_type:
	proc (allowed);

    dcl	allowed			fixed bin;
    dcl  (error_table_$active_function,
	error_table_$not_act_fnc)	fixed bin(35) ext static;

	call error$init();
	call ssu_$return_arg (sci_ptr, argn, af_sw, retp, retl);
	if allowed = ALLOW_COMMAND & af_sw then
	   call error$fatal (sci_ptr, error_table_$active_function);
	else if allowed = ALLOW_AF & ^af_sw then
	   call error$fatal (sci_ptr, error_table_$not_act_fnc);
	else if allowed = ALLOW_COMMAND_AF then;
	if af_sw then
	   ret = "";
	argx = 0;
	end check_invocation_type;



/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* CLEANUP:						       */
/* 1) Close attachment (via syn_) of map switch used by backup_map_ subrs.   */
/* 2) Unassign any reserved tape drives we assigned to the process.	       */
/* 3) Silently close/detach all opened I/O switches.		       */
/* 4) Destroy the ssu_ invocation (releasing temp segs obtained thru ssu_).  */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

cleanup_invocation:
       	proc;

	call map_seg$term();
	call tape_drive$term();

	call detach (addr(input),    DESTROY);
	call detach (addr(output),   DESTROY);
	call detach (addr(map),      DESTROY);
	call detach (addr(select),   DESTROY);

	if sci_ptr ^= null then
	   call ssu_$destroy_invocation (sci_ptr);
	end cleanup_invocation;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* COMPARE A SEGMENT FROM MASTER with SEGMENT FROM COPY MEDIUM:	       */
/* 1) Initialize error detect remembering switch.  If any comparisons fail,  */
/*    report the error, and let the error routine remember that one	       */
/*    occurred.						       */
/* 2) Compare pathnames of the two segments from backup logical record       */
/*    headers.						       */
/* 3) Compare length of backup logical record headers.		       */
/* 4) Compare header words.					       */
/* 5) Compare segment lengths.				       */
/* 6) Compare segment words.					       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

compare_seg:
       	proc (bf1, bf2, segx) returns (bit(1));

    dcl   1 (bf1, bf2)		aligned like inbf,
	segx			fixed bin;

    dcl	first_disagreement		fixed bin(18),
	words_disagreeing		fixed bin(18),
	wordx			fixed bin(18);

    dcl	1 he1			aligned like h based (bf1.hp),
	1 he2			aligned like h based (bf2.hp),
	1 he1_name		aligned like inhe_name based (bf1.hp),
	1 he2_name		aligned like inhe_name based (bf2.hp),
	he1_words (bf1.hl)		fixed bin(35) based (bf1.hp),
	he2_words (bf2.hl)		fixed bin(35) based (bf2.hp),
	seg1_words (bf1.segl)	fixed bin(35) based (bf1.segp),
	seg2_words (bf2.segl)	fixed bin(35) based (bf2.segp);

	call error$init();
	if he1_name.dname ^= he2_name.dname |
	   he1_name.ename ^= he2_name.ename then
	   call error (sci_ptr, -1,
	      "^a: Segment ^d -- Pathname Discrepancy.
  Master: ^a
  Copy:   ^a", hhmmm(), segx,
	      rtrim(pathname_((he1.dname), (he1.ename)), " >"),
	      rtrim(pathname_((he2.dname), (he2.ename)), " >"));
	else if dim(he1_words,1) ^= dim(he2_words,1) then
	   call error (sci_ptr, -1,
	      "^a: Segment ^d -- Record Header Length Discrepancy.
  Master: ^5d words for ^a 
  Copy:   ^5d words for ^a", hhmmm(), segx,
	      dim(he1_words,1), rtrim(pathname_((he1.dname), (he1.ename)), " >"),
	      dim(he2_words,1), rtrim(pathname_((he2.dname), (he2.ename)), " >"));

	else if unspec(he1_words) ^= unspec(he2_words) then do;
	   words_disagreeing = 0;
	   first_disagreement = 0;
	   do wordx = lbound(he1_words,1) to hbound(he1_words,1);
	      if he1_words(wordx) ^= he2_words(wordx) then do;
	         words_disagreeing = words_disagreeing + 1;
	         if words_disagreeing = 1 then
		  first_disagreement = wordx;
	         end;
	      end;
	   call error (sci_ptr, -1,
	      "^a: Segment ^d -- Record Header Discrepancy, ^d word^[s^].
--FIRST DISCREPANCY--
  Master: word(^d) = ^w, for ^a 
  Copy:   word(^d) = ^w, for ^a", hhmmm(), segx,
	      words_disagreeing^=1, words_disagreeing,
	      first_disagreement, he1_words(first_disagreement),
	      rtrim(pathname_((he1.dname), (he1.ename)), " >"),
	      first_disagreement, he2_words(first_disagreement),
	      rtrim(pathname_((he2.dname), (he2.ename)), " >"));
	   end;
	else if dim(seg1_words,1) ^= dim(seg2_words,1) then
	   call error (sci_ptr, -1,
	      "^a: Segment ^d -- Segment Length Discrepancy.
  Master: ^5d words for ^a 
  Copy:   ^5d words for ^a", hhmmm(), segx,
	      dim(seg1_words,1), rtrim(pathname_((he1.dname), (he1.ename)), " >"),
	      dim(seg2_words,1), rtrim(pathname_((he2.dname), (he2.ename)), " >"));
	else if unspec(seg1_words) ^= unspec(seg2_words) then do;
	   words_disagreeing = 0;
	   first_disagreement = 0;
	   do wordx = lbound(seg1_words,1) to hbound(seg1_words,1);
	      if seg1_words(wordx) ^= seg2_words(wordx) then do;
	         words_disagreeing = words_disagreeing + 1;
	         if words_disagreeing = 1 then
		  first_disagreement = wordx;
	         end;
	      end;
	   call error (sci_ptr, -1,
	      "^a: Segment ^d -- Segment Contents Discrepancy, ^d word^[s^].
--FIRST DISCREPANCY--
  Master: word(^d) = ^w, for ^a 
  Copy:   word(^d) = ^w, for ^a", hhmmm(), segx,
	      words_disagreeing^=1, words_disagreeing,
	      first_disagreement, seg1_words(first_disagreement),
	      rtrim(pathname_((he1.dname), (he1.ename)), " >"),
	      first_disagreement, seg2_words(first_disagreement),
	      rtrim(pathname_((he2.dname), (he2.ename)), " >"));
	   end;
	if error$occurred() then do;
	   severity = max(severity, 3);
	   return (FALSE);
	   end;
	else
	   return (TRUE);

	end compare_seg;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* COMPARE ALL SEGMENTS ON COPY with SEGMENTS ON MASTER:		       */
/* 1) Get temp segments to hold dir entry header, and entry contents	       */
/*    (segment) from master and copy tapes.			       */
/* 2) Initialize variables for "last entry read".  This is needed since a    */
/*    backup tape can end with a complete segment while backup_dump thinks   */
/*    the segment was incomplete.  Therefore, it rewrites the segment at     */
/*    the beginning of the next tape.  Such duplicate entries are ignored    */
/*    via the "last entry read" variables.			       */
/* 3) Read master and copy segs in a loop until input is exhausted.	       */
/*    Reading occurs in two steps: first read the header; then read the      */
/*    segment contents if header says this segment participates in the       */
/*    comparison.  Some master segments may be omitted from comparison,      */
/*    because they aren't selected by the -select file.		       */
/* 4) If master entry wasn't selected, then skip it.		       */
/* 5) If master selected, compare the two segs.  Count segs comparing equal. */
/* 6) Report how many entries and msfs were successfully compared.	       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

compare_segs:
       	proc ();

    dcl  (compare_continues, need_copy, need_master)
				bit(1),
         (error_count, extra_masters)	fixed bin,
	MAX_ERRORS		fixed bin int static options(constant) init(20);

	if mbf.hp = null then
	   call ssu_$get_temp_segment (sci_ptr, "master header", mbf.hp);
	if mbf.segp = null then
	   call ssu_$get_temp_segment (sci_ptr, "master segment", mbf.segp);
	call ssu_$get_temp_segment (sci_ptr, "copy header", cpbf.hp);
	call ssu_$get_temp_segment (sci_ptr, "copy segment", cpbf.segp);

	mlast.path = "";
	mlast.sizes = 0;
	cplast.path = "";
	cplast.sizes = 0;

	error_count, extra_masters = 0;
	compare_continues = TRUE;
	need_master = TRUE;
	need_copy = TRUE;
	do while (compare_continues);
	   if need_copy then do;
READ_COPY:      if read_seg$header(cpbf, cplast, output) then do;
	         state = read_seg$contents (cpbf, cplast, output);
	         if state = READ_AGAIN then go to READ_COPY;
	         else if state = OK then
		  need_copy = FALSE;
	         end;
	      end;

	   if need_master then do;
	      if read_seg$header(mbf, mlast, input) then
	         need_master = FALSE;
	      end;

	   if need_master & need_copy then		/* When input    */
	      compare_continues = FALSE;		/* ends from     */
						/* both, compare */
						/* is done.      */

	   else if need_master then do;		/* copy has seg  */
						/*  not on master*/
	      compared.segs = compared.segs + 1;
	      if (cphe.record_type = sec_dir |
	         cphe.record_type = ndc_directory) &
	         cphe.bitcnt > 0 then
	         compared.msfs = compared.msfs + 1;
	      call error (sci_ptr, -1,
"^a: Segment ^d -- 
  Copy contains segment not on master media.
  Copy:  ^a",      hhmmm(), compared.segs,
	         rtrim(pathname_((cphe.dname), (cphe.ename))," >"));
	      error_count = error_count + 1;
	      if abort_sw then
	         compare_continues = FALSE;
	      else if error_count > MAX_ERRORS then
	         compare_continues = FALSE;
	      else
	         need_copy = TRUE;
	      end;

	   else if skip_seg (mbf, cpbf, need_copy) then do;
	      state = read_seg$skip_contents(mbf, mlast, input);
	      need_master = TRUE;			/* master seg    */
	      end;				/*  not selected */

	   else if need_copy then do;			/* master has seg*/
						/*  not on copy  */
	      state = read_seg$skip_contents (mbf, mlast, input);
	      need_master = state = NOMORE;
	      if ^need_master then do;
	         extra_masters = extra_masters + 1;
	         call error (sci_ptr, -1,
"^a: Segment ^d -- 
  Master contains segment not on copy media.
  Master:  ^a",	  hhmmm(), compared.segs+extra_masters,
		  rtrim(pathname_((mhe.dname),(mhe.ename))," >"));
	         error_count = error_count + 1;
	         if abort_sw then
		  compare_continues = FALSE;
	         else if error_count > MAX_ERRORS then
		  compare_continues = FALSE;
	         else
		  need_master = TRUE;
	         end;
	      end;

	   else do;				/* read rest of  */
						/*  master       */
	      state = read_seg$contents(mbf, mlast, input);
	      if state ^= OK then			/* master seg    */
	         need_master = TRUE;			/*  incomplete.  */
	      else do;				/* compare segs  */
	         if compare_seg(mbf, cpbf, compared.segs+1) then do;
		  compared.segs = compared.segs + 1;
		  if (mhe.record_type = sec_dir |
		      mhe.record_type = ndc_directory) &
		      mhe.bitcnt > 0 then
		     compared.msfs = compared.msfs + 1;
		  need_master, need_copy = TRUE;
		  end;
	         else do;
		  error_count = error_count + 1;
		  if abort_sw then
		     compare_continues = FALSE;
		  else if error_count > MAX_ERRORS then
		     compare_continues = FALSE;
		  else if mhe_name.dname <= cphe_name.dname &
			mhe_name.ename <= cphe_name.ename then
		     need_master = TRUE;
		  else
		     need_copy = TRUE;
		  end;
	         end;
	      end;
	   end;

	call detach (addr(input), KEEP);
	call detach (addr(output), KEEP);

	call ioa_ ("");
	call ssu_$print_message (sci_ptr, 0,
	   "^a: Compared ^d entr^[ies^;s^], including ^d multisegment file^[s^].^[
^d comparison error^[ was^;s were^] found.^]^/",
	   hhmmm(), compared.segs, compared.segs^=1,
	   compared.msfs, compared.msfs^=1,
	   error_count>0, error_count, error_count=1);
	if error_count > 0 then
	   severity = max(severity,3);
	return;

	end compare_segs;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* COPYING ENTRIES:						       */
/* 1) Get temp segments to hold dir entry header, and entry contents	       */
/*    (segment).						       */
/* 2) Initialize variables for last entry read.			       */
/* 3) Initialize map file.					       */
/* 4) Read segs in a loop until input is exhausted.		       */
/* 5) If entry just read is same as last entry, then skip it.  This can      */
/*    occur if an entry just fits on the end of one tape, but was rewritten  */
/*    at the beginning of the next tape.			       */
/* 6) If not same as last entry, then write it onto the output.  Put segment */
/*    into the map.  Count number of segs actually copied.		       */
/* 7) Report how many entries and msfs were copied.		       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


copy_segs:
       	proc ();

	call ssu_$get_temp_segment (sci_ptr, "input header", inbf.hp);
	call ssu_$get_temp_segment (sci_ptr, "input segment", inbf.segp);

	inlast.path = "";
	inlast.sizes = 0;

	state = READ_AGAIN;
	do while (read_seg$header(inbf, inlast, input) & state^=NOMORE);
	   if skip_seg (inbf, inbf, FALSE) then
	      state = read_seg$skip_contents(inbf, inlast, input);
	   else do;
	      state = read_seg$contents(inbf, inlast, input);
	      if state = READ_AGAIN then;
	      else if state = NOMORE then;
	      else do;
	         if write_seg(inbf, output) then do;
		  call map_seg  (inbf);
		  copied.segs = copied.segs + 1;
		  if (inhe.record_type = sec_dir |
		      inhe.record_type = ndc_directory) &
		      inhe.bitcnt > 0 then
		     copied.msfs = copied.msfs + 1;
		  end;
	         else do;
		  call error$fatal (sci_ptr, -1,
		     "^a: FATAL ERROR: Too few output tapes to hold all copied files.",
		     hhmmm());
		  end;
	         end;
	      end;
	   end;

	call detach (addr(input), KEEP);
	call detach (addr(output), KEEP);

	call ioa_("");
	call ssu_$print_message (sci_ptr, 0,
	   "^a: Copied ^d entr^[ies^;y^], including ^d multisegment file^[s^].^/",
	   hhmmm(), copied.segs, copied.segs^=1,
	   copied.msfs, copied.msfs^=1);

	end copy_segs;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* CLOSE/DETACH I/O SWITCHES:					       */
/* 1) Check if switch was even found (or if already destroyed).	       */
/* 2) If switch was used used for iox_$move_attach, move back the original   */
/*    attachment.						       */
/* 3) Otherwise, close an opened switch; detach an attached switch.	       */
/* 4) If disposition = DESTROY, then destroy the I/O switch.	       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

detach:	proc (iop, disp);

    dcl	iop			ptr,
	disp			fixed bin;

    dcl	1 io			aligned based (iop),
	  2 header		like in_out.header,
	  2 vol (0 refer (io.header.voln))
				like in_out.vol;

	if io.iocbp = null then;

	else if io.mode = FOR_MOVE_ATTACH then do;
	   call iox_$detach_iocb (io.iocbp, code);
	   call iox_$move_attach (io.target_iocbp, io.iocbp, code);
	   call iox_$destroy_iocb (io.target_iocbp, code);
	   io.iocbp = null;
	   end;

	else do;
	   if io.iocbp -> iocb.open_descrip_ptr ^= null then do;
	      if io.vfile.path ^= "" then do;
	         call iox_$close (io.iocbp, code);
	         call error (sci_ptr, code,
		  "^/Closing ^a file: ^a", io.header.name,
		  io.vfile.expath);
	         end;
	      else do;
	         call iox_$close (io.iocbp, code);
	         call error (sci_ptr, code,
		  "^/^a: Closing ^a tape: ^a", hhmmm(), io.header.name,
		  io.vol(io.tape.volx).name);
	         end;
	      end;

	   if io.iocbp -> iocb.attach_descrip_ptr ^= null then do;
	      if io.vfile.path ^= "" then do;
	         call iox_$detach_iocb (io.iocbp, code);
	         call error (sci_ptr, code,
		  "^/Detaching ^a file: ^a", io.header.name,
		  io.vfile.expath);
	         end;
	      else do;
	         call iox_$detach_iocb (io.iocbp, code);
	         call error (sci_ptr, code,
		  "^/^a: Detaching ^a tape: ^a", hhmmm(), io.header.name,
		  io.vol(io.tape.volx).name);
	         if disp = KEEP then
		  call ssu_$print_message (sci_ptr, 0,
		     "^a: Dismounted ^a tape: ^a", hhmmm(), io.header.name,
		     io.vol(io.tape.volx).name);
	         end;
	      end;
	   end;

	if io.iocbp ^= null then
	if disp = DESTROY then do;
	   call iox_$destroy_iocb (io.iocbp, code);
	   io.iocbp = null;
	   end;

	end detach;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* ERROR REPORTING ROUTINES:					       */
/* 1) Nonfatal errors set a switch, which can be tested via error_occurred   */
/*    function.						       */
/* 2) Fatal errors abort the subsystem by calling the exit_proc, which       */
/*    branches to the EXIT label to exit the command.		       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

    dcl	error_occurred_sw		bit(1);

error: 	proc options (variable);

    dcl	code			fixed bin(35) based (codep),
	codep			ptr;

    dcl	cu_$arg_list_ptr		entry returns(ptr),
	cu_$arg_ptr		entry (fixed bin, ptr, fixed bin(21),
				     fixed bin(35)),
	cu_$generate_call		entry (entry, ptr);

    dcl	CODE_ARG			fixed bin int static options(constant) init(2),
         (FALSE			init("0"b),
	TRUE			init("1"b)) bit(1) int static options(constant);

	call cu_$arg_ptr (CODE_ARG, codep, 0, 0);
	if code = 0 then return;
	if code = -1 then code = 0;
	error_occurred_sw = TRUE;
	call cu_$generate_call (ssu_$print_message, cu_$arg_list_ptr());
	return;

error$init:
	entry;

	error_occurred_sw = FALSE;
	return;
	

error$occurred:
	entry returns (bit(1));

	return (error_occurred_sw);
	

error$fatal:
	entry options(variable);
	
	call cu_$arg_ptr (CODE_ARG, codep, 0, 0);
	if code = 0 then return;
	if code = -1 then code = 0;
	error_occurred_sw = TRUE;
	call ioa_ ("");
	call cu_$generate_call (ssu_$abort_subsystem, cu_$arg_list_ptr());
	end error;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* ARGUMENT GETTING FUNCTIONS:				       */
/*  get_arg: 	Get next argument.				       */
/*  get_arg_count:	Get number of arguments.			       */
/*  get_ctl_arg:	Get next argument, which must be a control argument.     */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

get_arg:	proc returns (bit(1));

    dcl  (FALSE			init("0"b),
	TRUE			init("1"b)) bit(1) int static options(constant);

	if argx < argn then do;
	   argx = argx + 1;
	   call ssu_$arg_ptr (sci_ptr, argx, argp, argl);
	   return (TRUE);
	   end;
	else
	   return (FALSE);
	end get_arg;


get_arg_count:
       	proc returns (fixed bin);
	return (argn);
	end get_arg_count;
       

get_ctl_arg:
       	proc returns (bit(1));

    dcl	index			builtin;

    dcl  (FALSE			init("0"b),
	TRUE			init("1"b)) bit(1) int static options(constant),
	error_table_$bad_arg	fixed bin(35) ext static;

	if get_arg() then
	   if index(arg, "-") = 1 then
	      return (TRUE);
	   else
	      call error$fatal (sci_ptr, error_table_$bad_arg,
	      "^a.^/A control argument was expected.", arg);
	return (FALSE);
	end get_ctl_arg;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* EXTRACT FINAL ENTRYNAME from pathname			       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

get_entry:
       	proc (path) returns (char(32));

    dcl	path			char(168);
	
    dcl	code			fixed bin(35),
	dir			char(168),
	ent			char(32);

    dcl	expand_pathname_		entry (char(*), char(*), char(*), fixed bin(35));

	call expand_pathname_ (path, dir, ent, code);
	return (ent);
	end get_entry;



















/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* CONTROL ARG OPERAND GETTING FUNCTIONS:			       */
/*  get_num_opt:  Gets next arg, treats it as an integer operand, checks     */
/*	        that its value is valid.			       */
/*  get_opt:      Gets next arg.				       */
/*							       */
/* Both allow the caller to specify whether the operand is required (an      */
/* opt_desc is provided) or optional (opt_desc="").		       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

get_num_opt:
	proc (arg_name, opt_desc, default_value, allowed_values)
	returns (bit(1));

    dcl	arg_name			char(*),
	opt_desc			char(*),
	default_value		fixed bin,
	allowed_values (*)		fixed bin;

    dcl	valx			fixed bin;

    dcl  (convert, dim, hbound, lbound)	builtin;

    dcl  (FALSE			init("0"b),
	TRUE			init("1"b)) bit(1) int static options(constant),
         (error_table_$bad_arg,
	error_table_$noarg)		fixed bin(35) ext static;

	if argx < argn then do;
	   argx = argx + 1;
	   call ssu_$arg_ptr (sci_ptr, argx, optp, optl);
	   if verify (opt, "0123456789") > 0 then go to BAD_OPT;
	   num_opt = convert (num_opt, opt);
	   do valx = lbound(allowed_values,1)
	          to hbound(allowed_values,1)
	       while (num_opt ^= allowed_values(valx));
	      end;
	   if valx <= hbound(allowed_values,1) then
	      return (TRUE);
	   else do;
BAD_OPT:	      call error (sci_ptr, error_table_$bad_arg,
	         "^a ^a
^a must be followed by a^[n^] ^a.^[
Default value is:^- ^d^;^s^]^[
Allowed ^[value is^;values are^]:^-^( ^d^)^]",
	         arg_name, opt, arg_name,
	         vowel(opt_desc), opt_desc, 
	         default_value ^= -1, default_value,
	       ^(dim(allowed_values,1)=1 & default_value=allowed_values(1)),
	         dim(allowed_values,1)=1, allowed_values);
	      return (FALSE);
	      end;
	   end;
	else if opt_desc ^= "" then do;
	   call error (sci_ptr, error_table_$noarg,
	      "^/^a must be followed by a^[n^] ^a.^[
Default value is:^- ^d^;^s^]^[
Allowed ^[value is^;values are^]:^-^( ^d^)^]", arg_name,
	      vowel(opt_desc), opt_desc,
	      default_value ^= -1, default_value,
	      ^(dim(allowed_values,1)=1 & default_value=allowed_values(1)),
	      dim(allowed_values,1)=1, allowed_values);
	   return (FALSE);
	   end;
	end get_num_opt;

get_opt:	proc (arg_name, opt_desc) returns (bit(1));

    dcl	arg_name			char(*),
	opt_desc			char(*);

    dcl  (FALSE			init("0"b),
	TRUE			init("1"b)) bit(1) int static options(constant),
	error_table_$noarg		fixed bin(35) ext static;

	if argx < argn then do;
	   argx = argx + 1;
	   call ssu_$arg_ptr (sci_ptr, argx, optp, optl);
	   if index(opt, "-") = 1 then do;		/* options cannot*/
	      argx = argx - 1;			/*  look like    */
	      go to NO_OPT;				/*  control args */
	      end;
	   else
	      return (TRUE);
	   end;
	else
NO_OPT:	   if opt_desc ^= "" then do;
	      call error (sci_ptr, error_table_$noarg,
	         "^/^a must be followed by a^[n^] ^a.", arg_name,
	         vowel(opt_desc), opt_desc);
	      return (FALSE);
	      end;
	return (FALSE);
	end get_opt;


vowel: 	proc (str) returns (bit(1));			/* does opt_desc */
						/* begin with a  */
						/* vowel?	       */

    dcl	str			char(*),
         (FALSE			init("0"b),
	TRUE			init("1"b)) bit(1) int static options(constant);

	if search ("aeiouAEIOU", substr(str,1,1)) > 0 then
	   return (TRUE);
	else
	   return (FALSE);
	end vowel;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* MAJOR OPERATION HEADER:					       */
/* Pretty-print a header describing:				       */
/* 1) the name of the operation about to begin;			       */
/* 2) the input media;					       */
/* 3) the output media.					       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

header:	proc (op, in, out);

    dcl	op			char(*),
	1 in			aligned like input,
	1 out			aligned like output;

    dcl  (from, to)			char(32) varying,
	indent			fixed bin;

    dcl	SP			char(1) int static options(constant) init(" ");

	call ioa_ ("");
	call ssu_$print_message (sci_ptr, 0,
	   "^a: ^a...", hhmmm(), op);

	call label (from, "from", in);
	call label (to,   "to",  out);
	indent = max (length(from), length(to)) + length(SP);
	call medium (from, indent, in);
	call medium (to,   indent, out);
	return;


label:	proc (lab, name, out);			/* compute value */
						/* of media label*/

    dcl	lab			char(32) varying,
	name			char(*),
	1 out			aligned like output;

	lab = "  ";
	lab = lab || name;
	lab = lab || " ";
	lab = lab || out.header.name;
	if out.vfile.path ^= "" then 
	   lab = lab || " file:";
	else if out.tape.voln = -1 then
	   lab = lab || " sink:";
	else if out.tape.voln ^= 1 then
	   lab = lab || " tapes:";
	else
	   lab = lab || " tape:";

	end label;


medium:	proc (lab, indent, out);			/* print medium  */
						/* label & value */

    dcl	lab			char(32) varying,
	indent			fixed bin,
	1 out			aligned like output;
	
    dcl	code			fixed bin(35),
	len			fixed bin,
	maxlen			fixed bin,
	printed			fixed bin,
	x			fixed bin;

	if out.vfile.path ^= "" then
	   call ioa_ ("^a^vt ^a", lab, indent, out.vfile.expath);
	else if out.tape.voln = -1 then
	   call ioa_ ("^a^vt ^a", lab, indent, "discard");
	else if out.tape.voln > 0 then do;
	   len = indent-1;
	   maxlen = get_line_length_$switch (null, code);
	   if code ^= 0 then maxlen = 79;
	   printed = 0;
	   do x = 1 to out.tape.voln;
	      if len + length(SP) + length(out.vol(x).name) > maxlen then do;
	         call ioa_ ("^a^vt^vs^v( ^a^)",
		  lab, indent, printed, x-1-printed, out.vol(*).name);
	         printed = x-1;
	         lab = "";
	         end;
	      end;
	   call ioa_ ("^a^vt^vs^v( ^a^)",
	      lab, indent, printed, x-1-printed, out.vol(*).name);
	   end;
	end medium;
	end header;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* CURRENT TIME: in form of ^Hd^99v.9MH (ie, HHMM.M).		       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

hhmmm: 	proc returns (char(6) varying);

    dcl	1 time_form		aligned,
	  2 hhmm			char(4) unal,
	  2 ss			pic "99" unal,
	result			char(6) varying;

    dcl	time			builtin;

	string(time_form) = substr(time(),1,length(string(time_form)));
	result = time_form.hhmm;
	result = result || ".";
	result = result || ltrim(char(divide(time_form.ss, 6, 1, 0)));
	return (result);

	end hhmmm;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* INITIALIZATION.						       */
/* 1) Initialize variables holding argument values.		       */
/* 2) Initialize other program data variables.			       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

initialize_args:
	proc;

    dcl	UNSET			char(1) int static options(constant) init("~"),
	UNSPECIFIED		ptr int static options(constant) init(null);

	in_outp = UNSPECIFIED;

	if operation_wanted = COMPARE then
	   input.header.name = "master";
	else
	   input.header.name = "input";
	input.iocbp = null;
	input.target_iocbp = null;
	input.mode = 0;
	input.recx = 0;
	input.vfile.path, input.vfile.expath = ""; input.vfile.charpos = 0;
	input.tape.voln,  input.tape.volx = 0;
	input.tape.track, input.tape.density = 0;
	input.vol(*) = "";

	output = input;
	if operation_wanted = COMPARE then
	   output.header.name = "copy";
	else
	   output.header.name = "output";

	select = output, by name;
	select.name = "select";
	select.listp = null;
	select.select_sw = FALSE;

	map = output, by name;
	map.name = "map";
	map.vfile.path = UNSET;

	map_prev = map;
	map_prev.name = "map_prev";

	abort_sw = FALSE;
	maximize_devices_sw = FALSE;
	trace = OFF;

	inbf.blrh.zz1, inbf.blrh.zz2 = BLRH_DELIMITER;
	inbf.blrh.english = BLRH_ENGLISH;
	inbf.blrh.hl, inbf.blrh.segl = 0;
	inbf.hp, inbf.segp = null;
	cpbf = inbf;

	copied, compared = 0;

	pp = addr(pp);				/* Used in an    */
						/* include file  */
	call tape_drive$init();
	
	end initialize_args;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* ADD A MAP ENTRY for a segment.				       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

    dcl	map_last_dir		char(168);

map_seg:	proc (bf);

    dcl	1 bf			aligned like inbf,
	bp			ptr,
	1 b			aligned like br based(bp),
	1 he			aligned like h based (bf.hp),
	nn			fixed bin,
	np			ptr,
	nx			fixed bin,
	1 n (nn)			aligned based (np),
	  2 l			fixed bin(17) uns unal,
	  2 pad			bit(19) unal,
	  2 string		char(32) unal,
	1 seg			aligned,
	  2 type			char(10),
	  2 blocks		fixed bin(9),
	  2(dtem, dtd, dtu, dtcm)	fixed bin(52);

    dcl	TYPE_STRING (0:20)		char(10) aligned int static options(constant) init (
	  "link", "segment", "directory", "directory",
	  (15)*,  "segment", "directory");

    dcl	sys_info$page_size		fixed bin external static,
	sys_info$seg_size_256K	fixed bin external static;

	if map.vfile.path = "" then
	   return;

	if map_last_dir ^= he.dname then do;
	   map_last_dir  = he.dname;
	   call backup_map_$directory_line (addr(he.dname), he.dlen);
	   end;

	seg.type = TYPE_STRING (he.record_type);
	bp = ptr (addr(he), he.bp);
	seg.blocks = min (bin (bp -> br (1).cl, 9),
	   divide (sys_info$seg_size_256K + sys_info$page_size - 1,
	   sys_info$page_size, 17, 0));
	seg.dtem = bin (b.dtbm, 52, 0); seg.dtd  = bin (b.dtd,  52, 0);
	seg.dtu  = bin (b.dtu,  52, 0); seg.dtcm = bin (b.dtm,  52, 0);

	call backup_map_$detail_line2 (he.ename, seg.blocks, seg.type,
	   clock(), seg.dtem, seg.dtd, seg.dtu, seg.dtcm);

	np = ptr (addr(he), b.namerp);  nn = bin (b.nnames, 17);
	if he.record_type ^= ndc_directory_list then 
	do nx = 2 to nn;
	   call backup_map_$name_line (addr(n.string(nx)), (n.l(nx)));
	   end;

	end map_seg;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* BACKUP MAP INITIALIZATION:					       */
/* 1) Return if -map not given.				       */
/* 2) The backup_map_ subr does all its output on the map I/O switch, so     */
/*    attach it as a synonym for the switch our map file is attached thru.   */
/* 3) Put description of output medium in map header line, along with	       */
/*    current date, and name of -select file.			       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

       

map_seg$init:
       	proc (out);

    dcl	1 out			aligned like output;

    dcl	date_time_string		char(40) varying,
	map_header		char(300) varying,
	map_line			char(300),
	out_header		char(128) varying;

	if map.vfile.path = "" then
	   return;

	call iox_$attach_name ("map", map_prev.iocbp,
	   "syn_ " || map.iocbp -> iocb.name, null, code);
	if code = error_table_$not_detached then do;
	   call attach (addr(map_prev), FOR_MOVE_ATTACH);
	   call iox_$move_attach (map_prev.iocbp, map_prev.target_iocbp,
	      code);
	   call error$fatal (sci_ptr, code,
	      "^/FATAL ERROR: Moving attachment of map switch.");
	   call iox_$attach_name ("map", map_prev.iocbp,
	      "syn_ " || map.iocbp -> iocb.name, null, code);
	   end;
	call error$fatal (sci_ptr, code,
	   "^/FATAL ERROR: Attaching map switch as synonym for ^a.",
	   map.iocbp -> iocb.name);

	if out.vfile.path ^= "" then
	   out_header = "File: " || get_entry (out.vfile.path);
	else if out.tape.voln > 1 then
	   out_header = "Tape: " || out.vol(1).name;
	else
	   out_header = "discard sink";
	call backup_map_$init_for_cdt (out_header);

	date_time_string = date_time_$format ("date_time", clock(), "", "");
	call backup_util$idline (map.vfile.expath,
	   (date_time_string), addr(map_line), length(map_line));

	map_line = out_header;
	call backup_map_$tapes (addr(map_line), length(rtrim(map_line)));

	map_header = rtrim(ME);
	map_header = map_header || " version 1.0";
	if select.vfile.path ^= "" then do;
	   map_header = map_header || " -select ";
	   map_header = map_header || select.vfile.expath;
	   end;
	map_line = map_header;
	call backup_map_$beginning_line (clock(), addr(map_line),
	   length(map_line));

	map_last_dir = "";
	end map_seg$init;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* BACKUP MAP NEW OUTPUT TAPE:				       */
/* 1) Change name of output tape in the map.			       */
/* 2) Repeat directory name at top of new map page.		       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

       

map_seg$new_tape:
	proc (out);

    dcl	1 out			aligned like output;

    dcl	map_line			char(300);

	if map.vfile.path = "" then
	   return;

	if out.tape.voln > 0 then do;
	   map_line = "Tape: " || out.vol(out.tape.volx).name;
	   call backup_map_$tapes (addr(map_line), length(rtrim(map_line)));
	   end;
	call backup_map_$heading_line();
	map_last_dir = "";

	end map_seg$new_tape;
	


/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* BACKUP MAP TERMINATION:					       */
/* 1) Detach synonym for map switch.				       */
/* 2) Close the map file.					       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

map_seg$term:
	proc;

    dcl	code			fixed bin(35);

	if map.vfile.path = "" then;
	else do;
	   if map_prev.iocbp ^= null then do;
	      call backup_map_$terminal_line (clock(), 0);
	      call backup_map_$detach_for_cdt (code);
	      call detach (addr(map_prev), DESTROY);
	      call detach (addr(map), DESTROY);
	      end;
	   end;
	end map_seg$term;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* MOUNT NEXT TAPE:						       */
/* 1) Detach current input or output tape.			       */
/* 2) If no more tapes exist, return FALSE.			       */
/* 3) Otherwise, select drive on which to mount tape (if -maxdv given).      */
/* 4) Attach and open the tape, via tape_mult_.  For stream_output	       */
/*    openings, set mode to asynchronous.  This means we must do an	       */
/*    error_count operation after every backup logical record, to ensure     */
/*    that it gets completely written to tape.			       */
/* 5) Report time to tape mount to the user.			       */
/* 6) Find out for sure (from RCP) which tape drive the tape was mounted on  */
/*    (if -maxdv given).					       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

mount_next_tape_vol:
       	proc (io) returns (bit(1));

    dcl	1 io			aligned like input;

    dcl	atd			char(256) varying,
	code			fixed bin(35);

	if io.iocbp -> iocb.open_descrip_ptr ^= null then 
	   call detach (addr(io), KEEP);

	if io.tape.volx >= io.tape.voln then
	   return (FALSE);

	io.tape.volx = io.tape.volx + 1;
	if io.vol(io.tape.volx).device ^= "" then
	   call tape_drive$select_another_device (io);
	else
	   call tape_drive$select_a_device (io);

	atd = "tape_mult_ " || rtrim(io.vol(io.tape.volx).name);
	if io.mode = Stream_output | 
	   (^maximize_devices_sw &
	    io.header.name = "output" &
	    operation_wanted = COPY_AND_COMPARE) then
	   atd = atd || " -write";
	if io.vol(io.tape.volx).device ^= "" then do;
	   atd = atd || " -device ";
	   atd = atd || rtrim(io.vol(io.tape.volx).device);
	   end;
	atd = atd || " -density ";
	atd = atd || ltrim(char(io.tape.density));
	atd = atd || " -track ";
	atd = atd || ltrim(char(io.tape.track));
	atd = atd || " -error_tally";

	call ssu_$print_message (sci_ptr, 0,
	   "^a: Mounting ^a tape ^a^[ on ^a^;^s^].^[^/  (^a)^]",
	   hhmmm(), io.header.name, io.vol(io.tape.volx).name,
	   io.vol(io.tape.volx).device ^= "", io.vol(io.tape.volx).device,
	   trace ^= OFF, atd);
	call iox_$attach_ptr (io.iocbp, (atd), null, code);
	call error$fatal (sci_ptr, code,
	   "^/^a: FATAL ERROR: Attaching ^a tape ^a for ^[reading^;writing^].",
	   hhmmm(), io.header.name, io.vol(io.tape.volx).name,
	   io.mode=Stream_input);
	call iox_$open (io.iocbp, io.mode, ""b, code);
	call error$fatal (sci_ptr, code,
	   "^/^a: FATAL ERROR: Opening ^a tape ^a for ^[reading^;writing^].",
	   hhmmm(), io.header.name, io.vol(io.tape.volx).name,
	   io.mode=Stream_input);
	if io.mode = Stream_output then do;
	   call iox_$modes (io.iocbp, "async", "", code);
	   call error$fatal (sci_ptr, code,
	      "^/^a: FATAL ERROR: Setting aync mode on ^a tape: ^a",
	      hhmmm(), io.header.name, io.vol(io.tape.volx).name);
	   end;
	call tape_drive$find_device (io.vol(io.tape.volx));
	call ssu_$print_message (sci_ptr, 0,
	   "^a: Finished mounting ^a tape: ^a",
	   hhmmm(), io.header.name, io.vol(io.tape.volx).name);
	return (TRUE);

	end mount_next_tape_vol;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* PROCESS ARGUMENTS					       */
/* 1) Match argument to ctl_arg name and operands.		       */
/* 2) Validate that proper input and output media are specified.	       */
/* 3) Complete specification of map pathname if -map is given.	       */
/*							       */
/* NOTE: Several control arguments affect either input or output media,      */
/*       depending upon whether -input_XXX or -output_XXX control arg was    */
/*       most recently given.  in_outp records this choice.		       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

process_args:
	proc;

    dcl	UNSET			char(1) int static options(constant) init("~"),
	UNSPECIFIED		ptr int static options(constant) init(null),
	VAL_7_9 (2)		fixed bin int static options(constant) init(7, 9),
	VAL_8_16_62 (3)		fixed bin int static options(constant) init(800, 1600, 6250);

    dcl	opt_desc			char(32);

	if get_arg_count() = 0 then
	   call error$fatal (sci_ptr, error_table_$wrong_no_of_args,
  	      "^/Usage:  ^a INPUT_SPEC OUTPUT_SPEC^[ {-compare}^] {-control_args}",
	      ME, operation_wanted = COPY);

CTL_ARG_LOOP:
	do while (get_ctl_arg ());
	   if arg = "-input_volume" | arg = "-ivol" then do;
	      in_outp = addr(input);
SET_REEL:	      in_out.tape.voln = 0;
	      in_out.vol(*) = "";
	      input.tape.track = 9;
	      input.tape.density = 1600;
	      in_out.vfile.path = "";
	      opt_desc = in_out.header.name || " tape volume name";
	      if get_opt (arg, opt_desc) then do;
	         in_out.tape.voln = 1;
	         in_out.vol(1).name = opt;
	         end;
	      do while (get_opt ("", ""));
	         if in_out.tape.voln >= hbound(in_out.vol,1) then
		  call error (sci_ptr, error_table_$too_many_names,
		     "^a ^a.^/Only ^d names may be given.", arg, opt,
		     hbound(in_out.vol,1));
	         else do;
		  in_out.tape.voln = in_out.tape.voln + 1;
		  in_out.vol(in_out.tape.voln).name = opt;
		  end;
	         end;
	      end;

	   else if arg = "-input_file" | arg = "-if" then do;
	      in_outp = addr(input);
SET_PATH:	      in_out.tape.voln = 0;
	      in_out.vol(*) = "";
	      in_out.tape.track, in_out.tape.density = 0;
	      in_out.vfile.path = "";
	      opt_desc = in_out.header.name || " file pathname";
	      if get_opt (arg, opt_desc) then do;
	         if in_out_selected() then do;
		  in_out.vfile.path = opt;
		  call absolute_pathname_ (in_out.vfile.path,
		     in_out.vfile.expath, code);
		  call error (sci_ptr, code, "^a ^a", arg, opt);
		  if code = 0 then
		     in_out.vfile.expath = get_shortest_path_ (in_out.vfile.expath);
		  end;
	         end;
	      end;

	   else if arg = "-output_volume" | arg = "-ovol" then do;
	      in_outp = addr(output);
	      go to SET_REEL;
	      end;
	   else if arg = "-output_file" | arg = "-of" then do;
	      in_outp = addr(output);
	      go to SET_PATH;
	      end;
	   else if (arg = "-output_discard" | arg = "-od") &
		  mod(operation_wanted,2) = COPY then do;
	      in_outp = addr(output);
	      in_out.tape.voln = -1;
	      in_out.vol(*) = "";
	      in_out.tape.track, in_out.tape.density = 0;
	      in_out.vfile.path = "";
	      end;

	   else if (arg = "-master_volume" | arg = "-mvol") &
		 operation_wanted = COMPARE then do;
	      in_outp = addr(input);
	      go to SET_REEL;
	      end;
	   else if (arg = "-copy_volume" | arg = "-cvol") &
		 operation_wanted = COMPARE then do;
	      in_outp = addr(output);
	      go to SET_REEL;
	      end;

	   else if arg = "-track" | arg = "-tk" then do;
	      if get_num_opt (arg, "tape track specification", 9, VAL_7_9) then do;
	         if in_out_selected() then
		  in_out.tape.track = num_opt;
	         end;
	      end;
	   else if arg = "-density" | arg = "-den" then do;
	      if get_num_opt (arg, "tape density specification", 1600, VAL_8_16_62) then do;
	         if in_out_selected() then 
		  in_out.tape.density = num_opt;
	         end;
	      end;

	   else if arg = "-abort" then
	      abort_sw = TRUE;
	   else if arg = "-no_abort" | arg = "-nabort" then
	      abort_sw = FALSE;

	   else if arg = "-trace" then do;
	      if get_opt ("", "") then do;
	         if opt = "rejects" | opt = "reject" | opt = "rej" then
		  trace = REJECTS;
	         else if opt = "off" then
		  trace = OFF;
	         else if opt = "copy" | opt = "cp" then
		  trace = COPY;
	         else if opt = "compare" | opt = "cmp" then
		  trace = COMPARE;
	         else if opt = "all" | opt = "a" then
		  trace = COPY_AND_COMPARE;
	         else
		  call error (sci_ptr, error_table_$bad_opt,
		     "^a ^a^/Allowed trace types are:
  off
  rejects, rej
  copy, cp
  compare, cmp
  all, a", arg, opt);
	         end;
	      else if operation_wanted = COMPARE then
	         trace = COMPARE;
	      else 
	         trace = COPY;
	      end;
	   else if arg = "-no_trace" | arg = "-ntrace" then
	      trace = OFF;

	   else if arg = "-maximize_devices" | arg = "-maxdv" then
	      maximize_devices_sw = TRUE;
	   else if arg = "-no_maximize_devices" | arg = "nmaxdv" then
	      maximize_devices_sw = FALSE;

	   else if arg = "-select" | arg = "-slct" then do;
	      opt_desc = select.header.name || " file pathname";
	      if operation_wanted = COMPARE then	/* -select path  */
						/* optional for  */
						/* old compare ep*/
	         if get_opt ("", "") then go to SET_SELECT;
	         else select.select_sw = TRUE;
	      else if get_opt (arg, opt_desc) then do;
SET_SELECT:        select.vfile.path = opt;
	         call absolute_pathname_ (select.vfile.path,
		  select.vfile.expath, code);
	         call error (sci_ptr, code, "^a ^a", arg, opt);
	         if code = 0 then
		  select.vfile.expath = get_shortest_path_ (select.vfile.expath);
	         end;
	      end;
	   else if arg = "-no_select" | arg = "-nslct" then do;
	      select.vfile.path = "";
	      select.select_sw = FALSE;
	      end;

	   else if (arg = "-compare" | arg = "-cmp") &
		 mod(operation_wanted,2) = COPY then
	      operation_wanted = COPY_AND_COMPARE;
	   else if (arg = "-no_compare" | arg = "-ncmp") &
		 mod(operation_wanted,2) = COPY then
	      operation_wanted = COPY;

	   else if arg = "-map" & mod(operation_wanted,2) = COPY then do;
	      map.vfile.path = "";			/* Use default   */
						/*  map path     */
	      if get_opt ("", "") then do;		/* optional path */
	         map.vfile.path = opt;
	         call absolute_pathname_$add_suffix (map.vfile.path, "map",
		  map.vfile.expath, code);
	         call error (sci_ptr, code, "^a ^a", arg, opt);
	         if code = 0 then
		  map.vfile.expath = get_shortest_path_ (map.vfile.expath);
	         end;
	      end;
	   else if (arg = "-no_map" | arg = "-nmap") &
		 mod(operation_wanted,2) = COPY then do;
	      map.vfile.path = UNSET;
	      end;
	   else
	      call error (sci_ptr, error_table_$bad_opt, "^a", arg);
	   end CTL_ARG_LOOP;

	if error$occurred() then			/* stop now if   */
	   call error$fatal (sci_ptr, -1);		/* ctl arg errs  */

	if input.tape.voln = 0 & input.vfile.path = "" then
	   call error$fatal (sci_ptr, error_table_$noarg,
	      " An input specification must be
given by -input_volume or -input_file control arguments.");
	if output.tape.voln = 0 & output.vfile.path = "" then
	   call error$fatal (sci_ptr, error_table_$noarg,
	      " An output specification must be
given by -output_volume, -output_file or -output_discard control arguments.");

	if input.tape.density  = 0 then input.tape.density  = 1600;
	if input.tape.track    = 0 then input.tape.track    = 9;
	if output.tape.density = 0 then output.tape.density = 1600;
	if output.tape.track   = 0 then output.tape.track   = 9;

	if output.tape.voln = -1 &
	   operation_wanted = COPY_AND_COMPARE then
	   call error$fatal (sci_ptr, error_table_$inconsistent,
	      "^/-compare is inconsistent with -output_discard.");

	if map.vfile.path = UNSET then
	   map.vfile.path = "";
	else if map.vfile.path = "" then do;
	   if output.vfile.path ^= "" then
	      map.vfile.path = get_entry(output.vfile.path);
	   else if output.tape.voln > 0 then
	      map.vfile.path = output.vol(1).name;
	   else if select.vfile.path ^= "" then 
	      map.vfile.path = get_entry (select.vfile.path);
	   else
	      map.vfile.path = unique_chars_(""b);
	   call absolute_pathname_$add_suffix (map.vfile.path, "map",
	      map.vfile.expath, code);
	   call error$fatal (sci_ptr, code,
	      "Adding map suffix to -output_file or -output_volume name ^a.",
	      map.vfile.path);
	   map.vfile.expath = get_shortest_path_ (map.vfile.expath);
	   end;
	return;


/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* ARG CONSISTENCY CHECKER:					       */
/* 1) Check for -input_XXX or -output_XXX having been specified, prior to    */
/*    receiving -track or -density.				       */
/* 2) If neither -input_XXX nor -output_XXX was given, diagnose error.       */
/* 3) Otherwise return TRUE to caller.				       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

in_out_selected:
	proc returns (bit(1));

	if in_outp = UNSPECIFIED then do;
	   call error (sci_ptr, error_table_$inconsistent,
	      "^/^a must follow -input_volume, -input_file, -output_volume, -output_file, or^/-output_discard.", arg);
	   return (FALSE);
	   end;
	return (TRUE);

	end in_out_selected;

	end process_args;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* READ LINE FROM FILE:					       */
/* 1) Read line from -select file.  Remove trailing NL.		       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


    dcl	line			char(300) varying;

read_line:
       	proc (inp) returns (bit(1));

    dcl	inp			ptr,
	1 in			aligned like select based(inp);

    dcl	code			fixed bin(35);

    dcl	1 line_buffer		aligned based(addr(line)),
	  2 l			fixed bin(21),
	  2 data			char(300);

    dcl	HT_SP			char(2) int static options(constant) init("	 "),
	NL			char(1) int static options(constant) init("
");

RE_READ:	call iox_$get_line (in.iocbp, addr(line_buffer.data),
	   length(line_buffer.data), line_buffer.l, code);
	if code = 0 then do;			/* remove NL     */
	   in.recx = in.recx + 1;
	   line = substr (line, 1, length(line) - length(NL));
	   line = ltrim(line, HT_SP);
	   line = rtrim(line, HT_SP);
	   if line = "" then go to RE_READ;		/* blank line    */
	   return (TRUE);
	   end;
	else if code = error_table_$end_of_info then do;
	   line = "";
	   return (FALSE);
	   end;
	else
	   call error$fatal (sci_ptr, code,
	      "^/FATAL ERROR: Reading line ^d from ^a file ^a.", in.recx,
	      in.name, in.vfile.expath);

	end read_line;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* READ BACKUP LOGICAL RECORD HEADER:				       */
/*   Read the header and segment attributes of next segment from input       */
/* medium.  If it is a segment we are interested in, then we will read       */
/* segment contents later; otherwise, we will iox_$position (skip) over the  */
/* segment contents.					       */
/*							       */
/* 1) Decide whether input is from vfile_ or tape.		       */
/* 2) If from vfile_, read size fields from backup logical record header     */
/*    (blrh), followed by the attributes of the segment.		       */
/* 3) If from tape, read backup logical record header itself from tape,      */
/*    followed by the attributes of the segment.  If current tape is	       */
/*    exhausted, mount next tape and try reading blrh again.	       */
/* 4) Return TRUE if another header exists, FALSE if input is exhausted.     */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

read_seg$header:
	proc (bf, last, in) returns(bit(1));

    dcl	1 bf			aligned like inbf,
	1 he			aligned like h based (bf.hp),
	1 last			aligned like inlast,
	1 in			aligned like input;

    dcl   1 blrh			aligned like inbf.blrh based,
	1 blrh_sizes		aligned like inbf.blrh.sizes based,
	readl			fixed bin(21),
	readneed			fixed bin(21);

    dcl	size			builtin;

	if in.vfile.path ^= "" then do;		/* read from file*/
	   call iox_$get_chars (in.iocbp, addr(bf.blrh.sizes),
	      size(blrh_sizes) * CHARS_PER_WORD, readl, code);
	   if code = 0 &
	      readl = size(blrh_sizes) * CHARS_PER_WORD then do;
	      in.vfile.charpos = in.vfile.charpos + readl;
	      bf.blrh.zz1, bf.blrh.zz2 = BLRH_DELIMITER;
	      bf.blrh.english = BLRH_ENGLISH;
	      call iox_$get_chars (in.iocbp, addr(he),
	         bf.blrh.hl * CHARS_PER_WORD, readl, code);
	      if code = 0 &
	         readl = bf.blrh.hl * CHARS_PER_WORD then do;
	         in.vfile.charpos = in.vfile.charpos + readl;
	         return (TRUE);
	         end;
	      end;
	   if code = error_table_$end_of_info then
	      return (FALSE);
	   else
	      call error$fatal (sci_ptr, code,
	         "^/^a: FATAL ERROR: Reading header of record ^d of ^a file:^/  ^a.",
	         hhmmm(), in.recx+1, in.header.name, in.vfile.expath);
	   end;

	else if in.iocbp -> iocb.open_descrip_ptr = null then
	   return (FALSE);				/* all input     */
						/* tapes 	       */
						/* exhausted     */

	else do;					/* read from tape*/
REREAD:	   call iox_$get_chars (in.iocbp, addr(bf.blrh),
	      size(blrh) * CHARS_PER_WORD, readl, code);
	   if code = 0 &
	      readl = size(blrh) * CHARS_PER_WORD then do;
	      if bf.blrh.zz1 ^= BLRH_DELIMITER |
	         bf.blrh.zz2 ^= BLRH_DELIMITER |
	         bf.blrh.english ^= BLRH_ENGLISH then
	         call error$fatal (sci_ptr, -1,
	         "^a: FATAL ERROR: Reading header of record ^d of ^a file:^/  ^a.
Record did not begin with a proper backup logical record header.
Header.zz1:     ^a
Header.english: ^a
Header.zz2:     ^a",
	         hhmmm(), in.recx, in.header.name, in.vol(in.tape.volx).name,
	         bf.blrh.zz1, bf.blrh.english, bf.blrh.zz2);

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* blrh + he, and seg are written in 256-word blocks, so we must round up    */
/* the amount we read to the next 256-word boundary.  At this point,	       */
/* blrh-words have already been read.				       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	      readneed = bf.blrh.hl + size(blrh) + BLOCK_SIZE - 1;
	      readneed = readneed - mod(readneed, BLOCK_SIZE) - size(blrh);
	      call iox_$get_chars (in.iocbp, addr(he),
	         readneed * CHARS_PER_WORD, readl, code);
	      if code = 0 &
	         readl = readneed * CHARS_PER_WORD then do;
	         if last.dir ^= "" &
		  last.path.dir = he.dname   &
		  last.path.ent = he.ename   &
		  last.sizes.he = bf.blrh.hl &
		  last.sizes.seg= bf.blrh.segl then do;
		  call ssu_$print_message (sci_ptr, 0,
		     "^a: Skipping duplicate ^a segment:^/  ^a",
		     hhmmm(), in.header.name,
		     rtrim(pathname_(last.path.dir, last.path.ent), " >"));
		  readneed = bf.blrh.segl + BLOCK_SIZE - 1;
		  readneed = readneed - mod(readneed, BLOCK_SIZE);
		  call iox_$position (in.iocbp, 3,
		     readneed * CHARS_PER_WORD, code);
		  if code = 0 then 
		     go to REREAD;
		  end;
	         return (TRUE);
	         end;
	      end;
	   if code = error_table_$end_of_info then do;
	      if mount_next_tape_vol (in) then
	         go to REREAD;
	      else
	         return (FALSE);
	      end;
	   else
	      call error$fatal (sci_ptr, code,
	         "^/^a: FATAL ERROR: Reading header of record ^d of ^a tape: ^a.",
	         hhmmm(), in.recx+1, in.header.name,
	         in.vol(in.tape.volx).name);
	   end;

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* READ SEGMENT CONTENTS:					       */
/* 1) If input from vfile, read segment contents based upon sizes from blrh. */
/* 2) If input from tape, read segment contents based upon sizes from blrh.  */
/*    Record pathname of segment as the last one which was read completely   */
/*    from tape.						       */
/* 3) In either case, there are three possible outcomes: reading segment     */
/*    contents was successful (OK); input was exhausted (NOMORE); segment    */
/*    contents was incomplete on this tape, need to read header from next    */
/*    tape (READ_AGAIN).					       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

read_seg$contents:
	entry (bf, last, in) returns (fixed bin);

	if in.vfile.path ^= "" then do;		/* read from file*/
	   if bf.blrh.segl > 0 then do;
	      call iox_$get_chars (in.iocbp, bf.segp,
	         bf.blrh.segl * CHARS_PER_WORD, readl, code);
	      if code = 0 &
	         readl = bf.blrh.segl * CHARS_PER_WORD then do;
	         in.vfile.charpos = in.vfile.charpos + readl;
	         in.recx = in.recx + 1;
	         return (OK);
	         end;
	      end;
	   else do;
	      in.recx = in.recx + 1;
	      return (OK);
	      end;
	   if code = error_table_$end_of_info then
	      return (NOMORE);
	   else
	      call error$fatal (sci_ptr, code,
	         "^/^a: FATAL ERROR: Reading contents of record ^d of ^a file:^/  ^a.",
	         hhmmm(), in.recx+1, in.header.name, in.vfile.expath);
	   end;
	else do;					/* read from tape*/
	   if bf.blrh.segl > 0 then do;
	      readneed = bf.blrh.segl + BLOCK_SIZE - 1;
	      readneed = readneed - mod(readneed, BLOCK_SIZE);
	      call iox_$get_chars (in.iocbp, bf.segp,
	         readneed * CHARS_PER_WORD, readl, code);
	      if code = 0 &
	         readl = readneed * CHARS_PER_WORD then do;
SETREAD:	         in.recx = in.recx + 1;
	         last.path.dir = he.dname;
	         last.path.ent = he.ename;
	         last.sizes.he = bf.blrh.hl;
	         last.sizes.seg= bf.blrh.segl;
	         return (OK);
	         end;
	      end;
	   else go to SETREAD;

	   if code = error_table_$end_of_info then do;
	      if mount_next_tape_vol (in) then
	         return (READ_AGAIN);
	      else
	         return (NOMORE);
	      end;
	   else
	      call error$fatal (sci_ptr, code,
	         "^/^a: FATAL ERROR: Reading contents of record ^d of ^a tape: ^a",
	         hhmmm(), in.recx+1, in.header.name,
	         in.vol(in.tape.volx).name);
	   end;

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* SKIP SEGMENT CONTENTS:					       */
/* 1) If input from vfile, skip segment contents based upon sizes from blrh. */
/* 2) If input from tape, skip segment contents based upon sizes from blrh.  */
/*    Record pathname of segment as the last one which was read completely   */
/*    from tape.						       */
/* 3) In either case, there are three possible outcomes: skipping segment    */
/*    contents was successful (OK); input was exhausted (NOMORE); segment    */
/*    contents was incomplete on this tape, need to read header from next    */
/*    tape (READ_AGAIN).					       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

read_seg$skip_contents:
	entry (bf, last, in) returns (fixed bin);

	if in.vfile.path ^= "" then do;		/* read from file*/
	   if bf.blrh.segl > 0 then do;
	      readl = bf.blrh.segl * CHARS_PER_WORD;
	      call iox_$position (in.iocbp, 2, in.vfile.charpos + readl,
	         code);
	      if code = 0 then do;
	         in.vfile.charpos = in.vfile.charpos + readl;
	         in.recx = in.recx + 1;
	         return (OK);
	         end;
	      end;
	   else do;
	      in.recx = in.recx + 1;
	      return (OK);
	      end;
	   if code = error_table_$end_of_info then
	      return (NOMORE);
	   else
	      call error$fatal (sci_ptr, code,
	         "^/^a: FATAL ERROR: Skipping contents of record ^d of ^a file:^/  ^a",
	         hhmmm(), in.recx+1, in.header.name, in.vfile.expath);
	   end;
	else do;					/* read from tape*/
	   if bf.blrh.segl > 0 then do;
	      readneed = bf.blrh.segl + BLOCK_SIZE - 1;
	      readneed = readneed - mod(readneed, BLOCK_SIZE);
	      call iox_$position (in.iocbp, 3, 
	         readneed * CHARS_PER_WORD, code);
	      if code = 0 then do;
SETSKIP:	         in.recx = in.recx + 1;
	         last.path.dir = he.dname;
	         last.path.ent = he.ename;
	         last.sizes.he = bf.blrh.hl;
	         last.sizes.seg= bf.blrh.segl;
	         return (OK);
	         end;
	      end;
	   else go to SETSKIP;

	   if code = error_table_$end_of_info then do;
	      if mount_next_tape_vol (in) then
	         return (READ_AGAIN);
	      else
	         return (NOMORE);
	      end;
	   else
	      call error$fatal (sci_ptr, code,
	         "^/^a: FATAL ERROR: Skipping contents of record ^d of ^a tape: ^a",
	         hhmmm(), in.recx+1, in.header.name,
	         in.vol(in.tape.volx).name);
	   end;

	end read_seg$header;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* PERFORM -select SELECTIONS:				       */
/*   skip_seg chooses which records from the master tape should be selected  */
/* for copying onto copy tape, or for comparision with contents of copy      */
/* tape.							       */
/*							       */
/* SELECT INITIALIZATION:					       */
/* 1) Get temp segment to hold -select data.			       */
/* 2) Read lines from -select file, and add them to -select data list.       */
/*							       */
/* PARSE SELECT LINES:					       */
/* 1) Lines beginning with ^ identify entries NOT to be selected.	       */
/* 2) Lines ending with >** identify entire subtrees to be selected or       */
/*    rejected.						       */
/*							       */
/* SELECT TERMINATION:					       */
/* 1) Report lines in -select data which were not matched by entries on the  */
/*    master tape.						       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

skip_seg$init:
       	proc;

    dcl	1 list			aligned based (select.listp),
	  2 n			fixed bin,
	  2 x			fixed bin,
	  2 e (0 refer (list.n)),
	    3 path		char(168) varying,
	    3 type		fixed bin(17) unal,
	    3 dont_select		fixed bin(1) uns unal,
	    3 subtree		bit(1) unal,
	    3 matched		bit(1) unal,
	    3 added_as_msf		bit(1) unal,
	    3 pad1		bit(14) unal;

    dcl  (UNKNOWN			init(-1),
	LINK			init(0),
	SEG			init(1),
	DIR			init(2),
	MSF			init(3)) fixed bin int static options(constant),
	TYPE_NAME (-1:3)		char(7) varying int static options(constant) init(
				"UNKNOWN", "LINK", "SEG", "DIR",
				"MSF");

	call ssu_$get_temp_segment (sci_ptr, "select_paths", select.listp);
	list.n, list.x = 0;
	do while (read_line(addr(select)));
	   call add_to_select_list (line, UNKNOWN, FALSE, FALSE);
	   end;
	return;

add_to_select_list:
	proc (line, type, matched, added_as_msf);

    dcl	line			char(*) varying,
	type			fixed bin,
	matched			bit(1),
	added_as_msf		bit(1);

    dcl	1 en			aligned like list.e;

	list.n = list.n + 1;
	if substr (line, 1, length("^")) = "^" then do;
	   en.path = substr (line, 2);
	   en.dont_select = 1;
	   end;
	else do;
	   en.path = line;
	   en.dont_select = 0;
	   end;
	en.type = type;
	en.matched = matched;
	en.added_as_msf = added_as_msf;
	en.pad1 = ""b;
	en.subtree = FALSE;
	if length (en.path) >= length (">**") then
	if substr(en.path, length(en.path)-length(">**")+1,
				     length(">**")) = ">**" then do;
	   en.path = substr(en.path, 1,  length(en.path)-length(">**"));
	   en.subtree = TRUE;
	   end;
	list.e(list.n) = en;
	end add_to_select_list;


skip_seg$term:
       	entry;
	
    dcl	header_needed		bit(1);

	if select.vfile.path = "" then
	   return;
	header_needed = TRUE;
	do list.x = lbound(list.e,1) to hbound(list.e,1);
	   if ^list.e(list.x).matched then do;
	      if header_needed then do;
	         call ioa_ ("");
	         call error (sci_ptr, -1, "^a: Unmatched Select Entries:",
		  hhmmm());
	         header_needed = FALSE;
	         end;
	      call ioa_ ("^[^^^; ^]^a^[>**^]",
	         list.e(list.x).dont_select=1, list.e(list.x).path,
	         list.e(list.x).subtree);
	      severity = 2;
	      end;
	   end;
	return;
	
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* MATCH SEGS AGAINST -select FILE SPECS:			       */
/* There are several cases of selection, which are dealt with separately.    */
/*  1) -select was not specified				       */
/*       =>  all master segs are matched.			       */
/*  2) compare_dump_tape -select was given without a SELECT_PATH (an	       */
/*     obsolete feature implemented for compatibility sake)		       */
/*       =>  master seg whose path matches copy seg path is "selected";      */
/*	   other master segs are not matched.			       */
/*  3) copy_dump_tape -select SELECT_PATH			       */
/*     compare_dump_tape -select SELECT_PATH			       */
/*       =>  use specs in SELECT_PATH to determine match status of master    */
/*	   segs.						       */
/*							       */
/* Type 3 selection will be explained below, since it is somewhat complex.   */
/* If -trace XXX is given, then selected or rejected master seg paths are    */
/* printed.  The first set of code below sets up that tracing.	       */
/*							       */
/* The following selection results are possible:			       */
/*  SELECTED: master seg path exactly matches path in -select file.	       */
/*  SELECTED_SUBTREE: master seg path is in the subtree below one of the     */
/*    paths in the -select file, and subtree selection was specified for     */
/*    that path.						       */
/*  SUPERIOR_DIR: master seg is an entry superior in the hierarchy tree to   */
/*    one of the paths in the -select file.			       */
/*  REJECTED: master seg path exactly matches a ^path in -select file.       */
/*  REJECTED_SUBTREE: master seg path is in the subtree below one of the     */
/*    ^paths in the -select file, subtree selection was specified, and the   */
/*    master seg did not match a later path in the -select file.  NOTE:      */
/*    order of paths in -select file is important; they should be sorted by  */
/*    pathname.						       */
/*  REJECTED_SUPERIOR_DIR: master seg is an entry superior in the hierarchy  */
/*    tree to one of the ^paths in the -select file and the master seg did   */
/*    not match a later path in the -select file.			       */
/*  UNMATCHED: master seg did not fit one of the criteria above.	       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


    dcl  (UNMATCHED			init(0),
	SUPERIOR_DIR		init(1),
	REJECTED_SUPERIOR_DIR	init(2),
	SELECTED			init(3),
	REJECTED			init(4),
	SELECTED_SUBTREE		init(5),
	REJECTED_SUBTREE		init(6)) fixed bin int static options(constant),
	STATE_NAME (0:6)		char(16) varying int static options(constant) init(
				"unmatched",
				"superior dir",
				"rejected sup dir",
				"selected",
				"rejected",
				"selected subtree",
				"rejected subtree");

skip_seg: entry (mbf, cpbf, need_copy) returns(bit(1));

    dcl	1 mbf			aligned like inbf,
	1 cpbf			aligned like inbf,
	need_copy			bit(1);

    dcl	1 seg			aligned,
	  2 path			char(168) varying,
	  2 type			fixed bin,
	  2 state			fixed bin;

    dcl	1 cphe_name		aligned like inhe_name based (cpbf.hp),
	1 mhe			aligned like h based (mbf.hp),
	1 mhe_name		aligned like inhe_name based (mbf.hp);

	if select.vfile.path ^= "" | 
	   trace = REJECTS |
	   trace = operation_now | 
	   trace = COPY_AND_COMPARE then do;
	   seg.path = rtrim(pathname_ ((mhe.dname), (mhe.ename)), " >");
	   if mhe.record_type = LINK then
	      seg.type = LINK;
	   else if mhe.record_type = sec_seg |
		 mhe.record_type = ndc_segment then
	      seg.type = SEG;
	   else if mhe.record_type = ndc_directory |
		 mhe.record_type = ndc_directory_list |
		 mhe.record_type = sec_dir then
	      seg.type = DIR;
	   if seg.type = DIR & mhe.bitcnt > 0 then
	      seg.type = MSF;
	   end;

	seg.state = UNMATCHED;			/* assume master */
						/*  seg unmatched*/

	if select.vfile.path = "" then		/* not selecting */
	   state = SELECTED;			/*  skip nothing */

	else if select.select_sw then do;		/* -select given */
						/* without path  */
	   if need_copy then			/* copy media    */
	      state = UNMATCHED;			/*  exhausted?   */
	   else 
	   if mbf.blrh.hl    = cpbf.blrh.hl &		/* see if two    */
	      mbf.blrh.segl  = cpbf.blrh.segl &		/*  segs are the */
	      mhe_name.dname = cphe_name.dname &	/*  same.	       */
	      mhe_name.ename = cphe_name.ename then
	      state = SELECTED;
	   end;

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* TYPE 3 SELECTION:					       */
/* 1) Loop through each -select file pathname specification, comparing it    */
/*    with the master seg path.				       */
/* 2) Check master seg path as superior to select file path, equal to it,    */
/*    or inferior to it.  If any test is true, then apply any ^path criteria */
/*    for that select file path.				       */
/* 3) For equal paths, assign the type of the master seg (LINK, SEG, DIR,    */
/*    MSF) to the select path entry.  If the type = DIR, mark the select     */
/*    path for subtree selection, since dir select paths are really dir      */
/*    subtree select paths.					       */
/* 4) For an MSF in a selected directory which does not have subtree	       */
/*    specified (now an impossibility because of (3), but I'll leave this    */
/*    code in anyway), add the MSF dir to the selection list so its	       */
/*    components will be properly copied.			       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	else do;
	   do list.x = lbound(list.e,1) to hbound(list.e,1);
	      if length(seg.path) < length(list.e(list.x).path) &
	         seg.path = 
	            substr(list.e(list.x).path,1,
	                   min(length(list.e(list.x).path),
		             length(seg.path))) &
	         seg.type = DIR then
	         seg.state = SUPERIOR_DIR + list.e(list.x).dont_select;
	      else if list.e(list.x).path = seg.path then do;
	         seg.state = SELECTED + list.e(list.x).dont_select;
	         list.e(list.x).matched = TRUE;
	         if list.e(list.x).type = UNKNOWN then
		  list.e(list.x).type = seg.type;
	         else if list.e(list.x).type = MSF &
		       mhe.record_type = ndc_directory_list then;
	         else if list.e(list.x).type ^= seg.type then
		  call error$fatal (sci_ptr, -1,
		     "^a: FATAL ERROR: Type Mismatch Discrepancy.
   Path:  ^a
   Master:^23tType ^a
   Select Item(^d):^23tType ^a^[, added as an MSF^].",
		     hhmmm(), seg.path, TYPE_NAME(seg.type),
		     list.x, TYPE_NAME(list.e(list.x).type),
		     list.e(list.x).added_as_msf);
	         if list.e(list.x).type = DIR then
		  list.e(list.x).subtree = TRUE;
	         end;
	      else if list.e(list.x).path = mhe_name.dname &
		   (list.e(list.x).type = DIR |
		    list.e(list.x).type = MSF) &
		    seg.type ^= DIR then do;
	         seg.state = SELECTED + list.e(list.x).dont_select;	      
	         if list.e(list.x).type = DIR &		/* Add MSF to    */
		 ^list.e(list.x).subtree &		/* list to be    */
		  list.e(list.x).dont_select=0 &	/* sure all comps*/
		  seg.type = MSF then		/* get copied.   */
		  call add_to_select_list (seg.path, MSF, TRUE, TRUE);
	         end;


	      else if length(seg.path) > length(list.e(list.x).path) then
		 if list.e(list.x).path = 
		       substr(seg.path,1,length(list.e(list.x).path)) &
		    list.e(list.x).type = DIR &
		    list.e(list.x).subtree then
	         seg.state = SELECTED_SUBTREE + list.e(list.x).dont_select;
	      end;
	   end;

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* 
/* TRACE SELECTIONS:
/* Trace the selection mechanism, listing either selected entries, rejected  */
/* entries or all entries.  The trace entry includes the selection result    */
/* (one of the STATE_NAME values).				       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if trace = operation_now then do;
	   if seg.state = UNMATCHED |
	      seg.state = REJECTED |
	      seg.state = REJECTED_SUPERIOR_DIR |
	      seg.state = REJECTED_SUBTREE then;
	   else
	      call ioa_ (" ^va ^[^va^2s^;^2s^va^] ^a",
	      maxlength(STATE_NAME(1)),  STATE_NAME(seg.state),
	      seg.type = MSF,
	      maxlength(RECORD_TYPE(1)), TYPE_NAME(seg.type),
	      maxlength(RECORD_TYPE(1)), RECORD_TYPE(mhe.record_type),
	      get_shortest_path_((seg.path)));
	   end;
	else if trace = REJECTS then do;
	   if seg.state = UNMATCHED |
	      seg.state = REJECTED |
	      seg.state = REJECTED_SUPERIOR_DIR |
	      seg.state = REJECTED_SUBTREE then
	      call ioa_ (" ^va ^[^va^2s^;^2s^va^] ^a",
	         maxlength(STATE_NAME(1)),  STATE_NAME(seg.state),
	         seg.type = MSF,
	         maxlength(RECORD_TYPE(1)), TYPE_NAME(seg.type),
	         maxlength(RECORD_TYPE(1)), RECORD_TYPE(mhe.record_type),
	         get_shortest_path_((seg.path)));
	   end;
	else if trace = COPY_AND_COMPARE then do;
	   call ioa_ (" ^va ^[^va^2s^;^2s^va^] ^a",
	      maxlength(STATE_NAME(1)),  STATE_NAME(seg.state),
	      seg.type = MSF,
	      maxlength(RECORD_TYPE(1)), TYPE_NAME(seg.type),
	      maxlength(RECORD_TYPE(1)), RECORD_TYPE(mhe.record_type),
	      get_shortest_path_((seg.path)));
	   end;

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* RETURN SELECTION RESULT as a TRUE/FALSE value.			       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	if seg.state = REJECTED_SUPERIOR_DIR | seg.state = REJECTED  |
	   seg.state = REJECTED_SUBTREE      | seg.state = UNMATCHED   then
	   return (TRUE);
	else
	   return (FALSE);

	end skip_seg$init;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* TAPE DRIVE MAXIMIZATION:					       */
/*   -maximize_devices (-maxdv) has two goals: to ensure that all devices    */
/* available to the process get used equally during a copy/compare	       */
/* operation; and to ensure that a tape written (copied) on one drive is     */
/* read (compared) on a different drive.  This involves several operations,  */
/* that will be described below.				       */
/*							       */
/*   The tape_drives structure is the central database for these	       */
/* operations.  It includes the number of drives reserved/assigned to the    */
/* process, a round-robin device selector, and event channel for device      */
/* operations, and for each device: device name, volume name last mounted    */
/* on the device, track and density specs, assignment rcp_id and a flag      */
/* indicating whether copy_dump_tape assigned a reserved device to the       */
/* process.						       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

       

    dcl	1 tape_drives		aligned,
	  2 count			fixed bin,	/* no devices    */
	  2 dvx			fixed bin,	/* cur device    */
	  2 event_wait_list		like event_wait_channel,
	  2 device (6),
	    3 name		char(32),
	    3 vol			char(32),
	    3 track		fixed bin,
	    3 density		bit(36),
	    3 rcp_id		bit(36),
	    3 assigned_by_us	bit(1) aligned;

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* ASSIGN RESERVED TAPE DRIVE:				       */
/*   This is called to assign a tape drive already reserved to the process.  */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


tape_drive$assign:
       	proc (dx);

    dcl	dx			fixed bin;

    dcl	code			fixed bin(35),
	1 ev_info			aligned like event_wait_info,
	statex			fixed bin,
	1 ti			aligned like tape_info;

	tape_drives.device(dx).assigned_by_us = FALSE;

	ti.version_num = tape_info_version_3;
	ti.usage_time = 0;
	ti.wait_time = 0;
	ti.system_flag = FALSE;
	ti.device_name =
	   substr(tape_drives.device(dx).name,1,length(ti.device_name));
	ti.model = 0;
	ti.tracks = 0;
	ti.density = ""b;
	ti.speed = ""b;
	ti.unused_qualifier = ""b;
	ti.volume_name = "";
	ti.write_flag = FALSE;
	ti.position_index = 0;
	ti.volume_type = 0;
	ti.volume_density = 0;
	ti.opr_auth = FALSE;

	call rcp_$assign_device (DEVICE_TYPE(TAPE_DRIVE_DTYPEX), addr(ti),
	   tape_drives.event_wait_list.channel_id(1), "",
	   tape_drives.device(dx).rcp_id, code);
	if code = error_table_$resource_unavailable |
	   code = error_table_$resource_reserved then;
	else
	   call error (sci_ptr, code,
	      "^/^a: Assigning tape drive ^a.", hhmmm(),
	      tape_drives.device(dx).name);

ASSIGN_CHECK:
	call rcp_$check_assign (tape_drives.device(dx).rcp_id,
	   addr(ti), "", statex, code);
	go to ASSIGN(statex);
	
ASSIGN(0):
	tape_drives.device(dx).assigned_by_us = TRUE;
	return;
	
ASSIGN(1):
	call ipc_$block (addr(tape_drives.event_wait_list),
	   addr(ev_info), code);
	if code ^= 0 then do;
	   call convert_ipc_code_ (code);
	   call error$fatal (sci_ptr, code,
	      "While blocking for tape_drive$assign.");
	   end;
	go to ASSIGN_CHECK;
	
ASSIGN(2):					/* long wait.    */
	return;

ASSIGN(3):					/* fatal error   */
	call error (sci_ptr, code,
	   "^/^a: Assigning tape drive ^a.", hhmmm(),
	   tape_drives.device(dx).name);
	return;

	end tape_drive$assign;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* VOLUME MOUNTED ON TAPE DRIVE:				       */
/*   This finds out which device a given tape volume was actually mounted    */
/* upon.  Prior to availability of "tape_mult_ VOL -device DEV", there was   */
/* no way to tell RCP which device to mount the tape on.  Even with the -dv  */
/* attach arg, there is no absolute assurance.  So this procedure surveys    */
/* RCP data to find out which device it was actually mounted on.	       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


tape_drive$find_device:
       	proc (vol);

    dcl	1 vol			aligned like in_out.vol;

    dcl	code			fixed bin(35),
         (da, dx)			fixed bin;

	vol.device = "";
	if tape_drives.count = 0 then return;
	call rcp_$copy_list (rli_ptr, WORDS_PER_SEGMENT, code);
	do da = 1 to rli.head.num_attach while (vol.device="");
	   attach_ptr = addr(rli.attaches(da));
	   if attach.dtypex = TAPE_DRIVE_DTYPEX then
	   if vol.name =   attach.volume_name then do;
	      vol.device = attach.device_name;
	      do dx = 1 to tape_drives.count 
	         while (tape_drives.device(dx).name ^= attach.device_name);
	         end;
	      if dx <= tape_drives.count then
	         tape_drives.device(dx).vol = vol.name;
	      end;
	   end;
	return;

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* SELECT A TAPE DRIVE:					       */
/*   This procedure selects a drive on which to mount a given volume.  If    */
/* the volume was mounted before during copying, then		       */
/* $select_another_device is called to select a different device during      */
/* comparing.  Otherwise, $select_a_device is called to select a device on   */
/* a round-robin basis.					       */
/*							       */
/* Selection is done by:					       */
/* 1) Surveying attached devices to see which devices are already occupied   */
/*    for mounts.						       */
/* 2) Scanning the remaining devices (round-robin) to find one with	       */
/*    compatible track/density attributes.			       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


tape_drive$select_another_device:
	entry (io);

    dcl	1 io			aligned like input;

    dcl	densityx			fixed bin,
	selected_dx		fixed bin,
	unwanted_device		char(32);

	unwanted_device = io.vol(io.tape.volx).device;
	go to SELECT_JOIN;
	
tape_drive$select_a_device:
	entry (io);

	unwanted_device = "~";
	go to SELECT_JOIN;
	
SELECT_JOIN:
	if tape_drives.count = 0 then return;
	call rcp_$copy_list (rli_ptr, WORDS_PER_SEGMENT, code);

	tape_drives.device(*).vol = "";
	do da = 1 to rli.head.num_attach;
	   attach_ptr = addr(rli.attaches(da));
	   if attach.dtypex = TAPE_DRIVE_DTYPEX then do;
	      do dx = 1 to tape_drives.count 
	         while (tape_drives.device(dx).name ^= attach.device_name);
	         end;
	      if dx <= tape_drives.count then
	         tape_drives.device(dx).vol = attach.volume_name;
	      end;
	   end;
	
	if io.tape.density = 800 then
	   densityx = 3;
	else if io.tape.density = 1600 then
	   densityx = 4;
	else if io.tape.density = 6250 then
	   densityx = 5;
	else densityx = 4;

	tape_drives.dvx = mod(tape_drives.dvx+1, tape_drives.count);
						/* start point   */
	
	selected_dx = 0;
	do dx = tape_drives.dvx+1 to tape_drives.count
	          while (selected_dx = 0),
	        1 to tape_drives.dvx
	          while (selected_dx = 0);
	   if tape_drives.device(dx).name = unwanted_device |
	      tape_drives.device(dx).vol ^= "" |
	      tape_drives.device(dx).track ^= io.tape.track |
	      ^substr(tape_drives.device(dx).density, densityx, 1) then;
	   else selected_dx = dx;
	   end;

	if selected_dx ^= 0 then 
	   io.vol(io.tape.volx).device =
	      tape_drives.device(selected_dx).name;
	return;
	
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* SURVEY TAPE DRIVES:					       */
/*  This procedure finds out which drives are reserved or assigned to the    */
/*  process.						       */
/* 1) Those just reserved to the process get assigned to it, so	       */
/*    their track/density attributes become known (the attributes are not    */
/*    listed in the device_resvs structure).			       */
/* 2) Then all assigned devices are recorded in the tape_drives structure.   */
/* 3) Finally, the user is told which devices are available for use.	       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


tape_drive$survey:
	entry;

	if ^maximize_devices_sw then return;

	tape_drives.count = 0;
	tape_drives.dvx = -1;
	tape_drives.device.name = "";
	tape_drives.device.vol = "";
	tape_drives.device.track = 0;
	tape_drives.device.density = ""b;
	tape_drives.device.rcp_id = ""b;
	tape_drives.device.assigned_by_us = FALSE;

	call ipc_$create_ev_chn (tape_drives.event_wait_list.channel_id(1), code);
	call error$fatal (sci_ptr, code, "Creating an event wait channel.");
	tape_drives.event_wait_list.n_channels = 1;

	call ssu_$get_temp_segment (sci_ptr, "tape survey", rli_ptr);
	rli.head.version_num = rli_version_4;
	call rcp_$copy_list (rli_ptr, WORDS_PER_SEGMENT, code);
	call error (sci_ptr, code, "Getting tape survey data.");
	if code ^= 0 then return;

	do da = 1 to rli.head.num_device_resv;
	   device_resv_ptr = addr(rli.device_resvs(da));
	   if substr(device_resv.device_name,1,length("tap")) = "tap" then do;
	      if tape_drives.count < hbound(tape_drives.device,1) then do;
	         tape_drives.count, dx = tape_drives.count + 1;
	         tape_drives.device(dx).name = device_resv.device_name;
	         end;
	      end;
	   end;

	if tape_drives.count > 0 then do;		/* assign resv   */
	   do dx = 1 to tape_drives.count;		/*  devs to get  */
						/*  attributes   */
	      do da = 1 to rli.head.num_dassign
	        while (rli.dassigns(da).device_name ^= 
		     tape_drives.device(dx).name);
	         end;
	      if da > rli.head.num_dassign then		/* not already   */
	         call tape_drive$assign (dx);		/*  assigned?    */
	      end;				/*  I'll do it.  */
	   call rcp_$copy_list (rli_ptr, WORDS_PER_SEGMENT, code);
	   end;					/* new rcp info  */

	do da = 1 to rli.head.num_dassign;		/* fill in       */
	   dassign_ptr = addr(rli.dassigns(da));	/*  tape_drives  */
	   if dassign.dtypex = TAPE_DRIVE_DTYPEX then do; /*  for assigned */
	      do dx = 1 to tape_drives.count		/*  drives.      */
	        while (tape_drives.device(dx).name ^= dassign.device_name);
	         end;
	      if dx >  tape_drives.count &
	         dx <= hbound(tape_drives.device,1) then
	         tape_drives.count = dx;
	      if tape_drives.count >= dx then do;
	         tape_drives.device(dx).name = dassign.device_name;
	         tape_drives.device(dx).track = dassign.qualifiers(1);
	         tape_drives.device(dx).density =
		  unspec(dassign.qualifiers(2));
	         end;
	      end;
	   end;

	call ioa_("");
	if tape_drives.count > 0 then
	   call ssu_$print_message (sci_ptr, 0,
	      "^a: ^d tape drive^[s^] assigned to process:^/ ^v( ^a^)",
	      hhmmm(), tape_drives.count, tape_drives.count^=1,
	      tape_drives.count, tape_drives.device.name);
	else
	   call error (sci_ptr, -1,
	      "No tape drives are currently assigned to or reserved for
the process.  The -maximize_devices operation will not occur.");
	return;

%include rcp_list_info;

	end tape_drive$find_device;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* TAPE DRIVE INITIALIZATION:					       */
/*   Initialize the tape_drives structure.			       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

tape_drive$init:
	proc;

	tape_drives.count = 0;
	tape_drives.dvx = -1;
	tape_drives.event_wait_list.channel_id = -1;
	tape_drives.device(*).name, tape_drives.device(*).vol = "";
	tape_drives.device(*).track = 0;
	tape_drives.device(*).density, tape_drives.device(*).rcp_id,
	   tape_drives.device(*).assigned_by_us = ""b;

	end tape_drive$init;


/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* TAPE DRIVE TERMINATION:					       */
/* 1) Unassigned reserved devices assigned by us.			       */
/* 2) Delete the event channel used for RCP operations.		       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


tape_drive$term:
	proc;

    dcl	code			fixed bin(35),
	dx			fixed bin;

	do dx = 1 to tape_drives.count;
	   if tape_drives.device(dx).assigned_by_us then
	      call tape_drive$unassign (dx);
	   end;

	if tape_drives.event_wait_list.channel_id(1) ^= -1 then
	   call ipc_$delete_ev_chn (tape_drives.event_wait_list.channel_id(1), code);
	end tape_drive$term;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* TAPE DRIVE UNASSIGN:					       */
/*   Unassign a tape drive assigned by copy_dump_tape.		       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


tape_drive$unassign:
       	proc (dx);

    dcl	dx			fixed bin;
    dcl	code			fixed bin(35);

	call rcp_$unassign (tape_drives.device(dx).rcp_id, ""b, "", code);
	call error (sci_ptr, code,
	   "^/^a: Unassigning tape drive ^a.", hhmmm(),
	   tape_drives.device(dx).name);
	tape_drives.device(dx).assigned_by_us = FALSE;

	end tape_drive$unassign;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* WRITE BACKUP LOGICAL RECORD HEADER and SEGMENT:		       */
/* 1) Decide whether output is to vfile_ or tape.			       */
/* 2) If to vfile, write out blrh sizes, the segment attributes in the       */
/*    remainder of blrh, and the segment contents.		       */
/* 3) If to tape, write out the blrh with segment attributes, and the	       */
/*    segment contents.  The blrh and contents must each be written as a     */
/*    group of 256 word blocks, so that blrh's begin on a 256-char tape      */
/*    record boundary.  After brlh/contents are written, do an error_count   */
/*    control request to synchronize output, forcing any unwritten tape      */
/*    buffers onto tape to ensure the segment actually gets written to       */
/*    tape.						       */
/* 4) When end-of-volume is found on one output tape, switch to the next     */
/*    tape and rewrite entire blrh/contents on new tape.		       */
/* 5) Both types return TRUE if the segment is successfully written, FALSE   */
/*    if it isn't.						       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

write_seg:	proc (bf, out) returns(bit(1));

    dcl	1 bf			aligned like inbf,
	1 he			aligned like h based (bf.hp),
	1 out			aligned like output;

    dcl	count			fixed bin(21);

    dcl   1 blrh			aligned like inbf.blrh based,
	1 blrh_sizes		aligned like inbf.blrh.sizes based,
	writel			fixed bin(21);

    dcl   size			builtin;

	if out.vfile.path ^= "" then do;		/* write file    */
	   call iox_$put_chars (out.iocbp, addr(bf.blrh.sizes),
	      size(blrh_sizes) * CHARS_PER_WORD, code);
	   if code = 0 then do;
	      call iox_$put_chars (out.iocbp, addr(he),
	         bf.blrh.hl * CHARS_PER_WORD, code);
	      if code = 0 then do;
	         if bf.blrh.segl > 0 then do;
		  call iox_$put_chars (out.iocbp, bf.segp,
		     bf.blrh.segl * CHARS_PER_WORD, code);
		  if code = 0 then do;
		     out.recx = out.recx + 1;
		     return (TRUE);
		     end;
		  end;
	         else do;
		  out.recx = out.recx + 1;
		  return (TRUE);
		  end;
	         end;
	      end;

	   if code = error_table_$end_of_info then
	      return (FALSE);
	   else
	      call error$fatal (sci_ptr, code,
	         "^/^a: FATAL ERROR: Writing ^a file ^a, record ^d.",
	         hhmmm(), out.header.name, out.vfile.expath, out.recx+1);
	   end;

	else if out.tape.voln > 0 then do;		/* write tape    */
REWRITE:	   call iox_$put_chars (out.iocbp, addr(bf.blrh),
	      size(blrh) * CHARS_PER_WORD, code);
	   if code = 0 then do;

/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*							       */
/* blrh + he, and seg are written in 256-word blocks, so we must round up    */
/* the amount we write to the next 256-word boundary.  At this point,	       */
/* blrh-words have already been written.			       */
/*							       */
/* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	      writel = bf.blrh.hl + size(blrh) + BLOCK_SIZE - 1;
	      writel = writel - mod(writel, BLOCK_SIZE) - size(blrh);
	      call iox_$put_chars (out.iocbp, addr(he),
	         writel * CHARS_PER_WORD, code);
	      if code = 0 then do;
	         if bf.blrh.segl > 0 then do;
		  writel = bf.blrh.segl + BLOCK_SIZE - 1;
		  writel = writel - mod(writel, BLOCK_SIZE);
		  call iox_$put_chars (out.iocbp, bf.segp,
		     writel * CHARS_PER_WORD, code);
		  end;
	         end;
	      end;
	   if code = 0 then do;
	      call iox_$control (out.iocbp, "error_count", addr(count),
	         code);
	      if code = 0 then do;
	         out.recx = out.recx + 1;
	         return (TRUE);
	         end;
	      end;
	   if code = error_table_$end_of_info | 
	      code = error_table_$device_end  then do;
	      if mount_next_tape_vol (out) then do;
	         call map_seg$new_tape (out);
	         go to REWRITE;
	         end;
	      else
	         return (FALSE);
	      end;
	   else
	      call error$fatal (sci_ptr, code,
	         "^/^a: FATAL ERROR: Writing ^a tape ^a, record ^d.",
	         hhmmm(), out.header.name,
	         out.vol(out.tape.volx).name, out.recx+1);
	   end;

	else do;					/* discard out   */
	   out.recx = out.recx + 1;
	   return (TRUE);
	   end;
	end write_seg;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

%include backup_dir_list;
 
    dcl	pp			ptr;

%include backup_preamble_header;

%include backup_record_types;

%include event_wait_channel;

%include event_wait_info;

%include iocb;

%include iox_modes;

%include rcp_resource_types;

%include rcp_tape_info;

%include system_constants;

	end copy_dump_tape;
