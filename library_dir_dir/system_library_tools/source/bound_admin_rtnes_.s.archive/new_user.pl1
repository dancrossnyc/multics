/****^  ***************************************************************
        *                                                             *
        * Copyright (c) 1982 by Massachusetts Institute of Technology *
        *                                                             *
        * Copyright, (C) Honeywell Information Systems Inc., 1982     *
        *                                                             *
        * Copyright (c) 1972 by Massachusetts Institute of            *
        * Technology and Honeywell Information Systems, Inc.          *
        *                                                             *
        *************************************************************** */



/****^  HISTORY COMMENTS:
  1) change(1986-08-04,Parisek), approve(1986-10-02,MCR7541),
     audit(1986-10-14,Martinson), install(1986-10-15,MR12.0-1186):
     Set the date/time password was changed in the PNT entry.
  2) change(1986-08-04,Parisek), approve(1986-10-02,MCR7541),
     audit(1986-10-14,Martinson), install(1986-10-15,MR12.0-1186):
     Bypasses mail table updates if items to be changed do not effect the mail
     table.
  3) change(1986-08-06,Parisek), approve(1986-10-02,MCR7541),
     audit(1986-10-14,Martinson), install(1986-10-15,MR12.0-1186):
     In the event of a linkage_error,  a cleaner error message is printed
     before termination.
  4) change(1986-08-06,Parisek), approve(1986-10-02,MCR7541),
     audit(1986-10-14,Martinson), install(1986-10-15,MR12.0-1186):
     Leave "notes" in URF as is,  if null string ("") is input to "Notes:"
     query.  To delete notes input of "." is needed.  This makes the null
     string and period (".") input consistent with the same responses of
     other field queries.
  5) change(2020-01-22,Swenson), approve(2020-01-22,MCR10074),
     audit(2020-02-01,GDixon), install(2020-02-01,MR12.6g-0039):
     Fix new_user$cga to really be verbose as it was intended and as it is
     documented to be.
                                                   END HISTORY COMMENTS */


/* format: style4 */
new_user: procedure options (separate_static, variable);

/* new_user: define new users and put in the PNT and URF */
/* Rewritten July 1979 by C. Hornig */
/* Modified August 1980 by J. N. R. Barnecut to process notes. */
/* Modified September 1982 by E. N. Kittlitz to reject reserved passwords. */
/* Modified October 1982 by J. I. Schiller to add -no_password_info and
   -password_info to print_pnt, fixed new_user$nua to check if an alias
   is in use before prompting for any additional information (which it
   would have to throw away if the alias is in use). also fixed it to
   verify that user_id's only have valid characters in them */
/* Modified July 1983 by B. Margolin to update the Mail Table when
   Person_ids and aliases are registered or changed, and to check Person_ids
   and aliases against the Mail Table before allowing them to be assigned. */
/* Modified August 1983 by B. Margolin to allow aliases to be deleted and to
   use a larger character string for the audit flags. */
/* Modified 1984-09-14 by E. Swenson for Version 2 PNT interface.
   The new format supports a login authorization range and is
   specified as min_auth:max_auth.  The keyword "network_pw" is now
   used to describe the network_password (formerly the card input
   password.  The keyword "card_pw" is a synonym for "network_pw"
   for compatibility. */
/* Modified 84-09-25 for "operator" attribute... -E. A. Ranzenbach */
/* Modified 84-12-14 by EJ Sharpe for new audit flags, init set_password and set_network_password */
/* Modified 85-03-05 by E. Swenson for user revalidation */

declare  pp pointer init (null ());			/* projfile pointer */
declare  sadp pointer init (null ());			/* sys_admin_data pointer */
declare  sadir character (168) init (">udd>SysAdmin>admin") internal static;

/* Constant */

dcl  sysdir char (168) initial (">system_control_1") internal static options (constant);
	

/* External Static */

dcl  error_table_$bad_arg fixed bin (35) external static;
dcl  error_table_$bad_index fixed bin (35) external static;
dcl  error_table_$checksum_failure fixed bin (35) external static;
dcl  error_table_$id_not_found fixed bin (35) external static;
dcl  error_table_$inconsistent fixed bin (35) external static;
dcl  error_table_$long_record fixed bin (35) external static;
dcl  error_table_$moderr fixed bin (35) external static;
dcl  error_table_$no_record fixed bin (35) external static;
dcl  mlsys_et_$ambiguous_address fixed bin (35) external static;

declare  iox_$user_input pointer external static;

/* External Entries */

dcl  check_password_ entry (char (*), char (*), fixed bin (35));
dcl  com_err_ entry options (variable);
dcl  command_query_ entry () options (variable);
dcl  convert_access_audit_flags_$from_string entry (char (*), bit (36) aligned, fixed bin (35));
dcl  convert_access_audit_flags_$edit_from_string entry (char (*), bit (36) aligned, fixed bin (35));
dcl  convert_access_audit_flags_$to_string entry (bit (36) aligned, char (*), fixed bin (35));
dcl  convert_authorization_$from_string entry (bit (72) aligned, char (*), fixed bin (35));
dcl  convert_authorization_$to_string_short entry (bit (72) aligned, char (*), fixed bin (35));
dcl  convert_date_to_binary_ entry (char (*), fixed bin (71), fixed bin (35));
dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
dcl  cu_$arg_count entry (fixed bin, fixed bin (35));
dcl  date_time_$format entry (char (*), fixed bin (71), char (*), char (*)) returns (char (250) var);
dcl  ioa_ entry options (variable);
dcl  ioa_$nnl entry options (variable);
dcl  iox_$get_line entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
dcl  initiate_file_ entry (char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));
dcl  terminate_file_ entry (ptr, fixed bin (24), bit (*), fixed bin (35));
dcl  mail_table_$get entry (char (*) varying, ptr, char (*), fixed bin (35));
dcl  mail_table_priv_$add entry (ptr, bit (1), fixed bin (35));
dcl  mail_table_priv_$add_alias entry (char (*) varying, char (*) varying, bit (1), fixed bin (35));
dcl  mail_table_priv_$delete_alias entry (char (*) varying, bit (1), fixed bin (35));
dcl  mail_table_priv_$get entry (char (*) varying, ptr, fixed bin (35));
dcl  mail_table_priv_$update entry (ptr, bit (1), fixed bin (35));
dcl  mail_table_priv_$test entry (char (*));
dcl  pathname_ entry (char (*), char (*)) returns (char (168));
dcl  pnt_admin_gate_$add_entry entry (character (*), pointer, fixed bin (35));
dcl  pnt_admin_gate_$get_entry entry (character (*), pointer, fixed bin (35));
dcl  pnt_manager_$get_abs_entry entry (fixed bin (35), pointer, fixed bin (35));
dcl  pnt_manager_$get_entry entry (character (*), pointer, fixed bin (35));
dcl  pnt_manager_$add_entry entry (character (*), pointer, fixed bin (35));
dcl  pnt_manager_$test entry (char (*));
dcl  pnt_manager_$update_entry entry (ptr, bit (1), bit (1), fixed bin (35));
dcl  read_password_ entry (char (*), char (*));
dcl  scramble_ entry (char (8)) returns (char (8));
dcl  urf_manager_$test entry (char (*));
dcl  urf_manager_$get_entry entry (character (*), pointer, fixed bin (35));
dcl  urf_manager_$add_entry entry (character (*), pointer, fixed bin (35));
dcl  urf_manager_$update_entry entry (character (*), pointer, pointer, fixed bin (35));
dcl  entry_var entry variable;

/* Automatic */

declare
         1 (pnte, old_pnte, alias_pnte) aligned like pnt_entry,
         1 (urfe, old_urfe) aligned like urf_entry,
         1 mte aligned like mail_table_entry,
         uid character (32) aligned,
         ap pointer,
         al fixed bin (21),
         argument character (al) based (ap),
         rec fixed bin (35),
         line character (256) aligned,
         code fixed bin (35),
         initial character,
         (loud, alias_allowed, arg_given, changing) bit aligned;
dcl  ip ptr initial (null ());			/* pointer to installation_parms */
dcl  set_network_password bit (1) init ("0"b);		/* Whether we need to change this */
dcl  set_password bit (1) init ("0"b);			/* Whether we need to change this */
dcl  what char (12);
dcl  whoami char (32) automatic;
	

declare  (addr, clock, index, length, min, null, rtrim, search, substr,
         unspec, verify) builtin;

declare  clean_up condition;
declare  new_user_stop condition;
declare  linkage_error condition;
	

/* * * * * * * * * * NEW_USER * * * * * * * * * */

	loud = "1"b;
	alias_allowed = "0"b;
	goto common;

/* * * * * * * * * * NU * * * * * * * * * */

nu:  entry options (variable);

	loud, alias_allowed = "0"b;
	goto common;

/* * * * ** * * * * * NUA * * * * * * * * * */

nua: entry options (variable);

	loud = "0"b;
	alias_allowed = "1"b;

/* * * * * * * * * * * * * * * * * * * */

common:
	whoami = "new_user";
	arg_given, changing = "0"b;
	on clean_up call cleaner;
	call initialize ();
	on new_user_stop goto stop_given;
	on linkage_error begin;
	     code = error_table_$moderr;
	     goto NO_ACCESS_TO_GATE;
	end;
	entry_var = pnt_admin_gate_$add_entry;
	revert linkage_error;
add_user:
	unspec (pnte) = ""b;
	pnte.version = PNT_ENTRY_VERSION_2;
	pnte.audit = sys_admin_data.default_audit_flags;

	if loud then call ioa_ ("^/Enter full user name (Last, First I.)");
	call read_name;
	if loud then call ioa_ ("^/Enter mailing address");
	call read_address;
	if loud then call ioa_ ("^/Enter programmer number");
	call read_prog_number;
	if loud then call ioa_ ("^/Enter notes");
	call read_notes;
	if loud then call ioa_ ("^/Enter default project");
	call read_project;
	pnte.alias = "";
	if alias_allowed then do;
	     if loud then call ioa_ ("^/Enter alias");
	     call read_alias;
	     if loud then call ioa_ ("^/User registration flags:");
	     call read_flags;
	     if loud then call ioa_ ("^/User authorization range:");
	     call read_authorization_range (pnte.person_authorization);
	     if loud then call ioa_ ("Default user authorization:");
	     call read_default_authorization (pnte.default_person_authorization);
	     if loud then call ioa_ ("^/Audit flags:");
	     call read_audit;
	end;

	call read_password ("Password:", pnte.private.password, pnte.public.flags.has_password, pnte.private.pw_flags.short_pw, ("0"b));

	call read_password ("Network Password:", pnte.private.network_password, pnte.public.flags.has_network_password, pnte.private.pw_flags.short_network_pw, ("0"b));

	if substr (urfe.last_name, 1, 1) = "*" then goto ask_uid;
	if ^uid_exists (urfe.last_name) then goto got_uid;
	if initial ^= "" then if ^uid_exists (substr (urfe.first_name, 1, 1) || initial || urfe.last_name) then goto got_uid;
	if ^uid_exists (substr (urfe.first_name, 1, 1) || urfe.last_name) then goto got_uid;
ask_uid:
	call ioa_ ("^/Please suggest a user ID for ""^a, ^a""", urfe.last_name, urfe.first_name);
read_uid:
	call read_line ("userid^-");
	if line = "" then goto read_uid; else uid = rtrim(line);
	if uid_exists (uid) then goto read_uid;

got_uid:
	call ioa_ ("^/User ID assigned is ""^a"".", uid);
	if ^yes_no ("Is this OK? ") then goto read_uid;

	pnte.user_id = uid;
	pnte.bad_pw_term_id, pnte.bad_pw_term_type = "";

	pnte.user_validated_time = clock ();		/* indicate validated */
	call pnt_manager_$add_entry ((uid), addr (pnte), code);
	if code ^= 0 then do;
	     call com_err_ (code, whoami, "Updating PNT.");
	     goto stop_given;
	end;
	call urf_manager_$add_entry ((uid), addr (urfe), code);
	if code ^= 0 then
	     call com_err_ (code, whoami, "Updating URF.");

	mte.version = MAIL_TABLE_ENTRY_VERSION_1;
	mte.name = rtrim (uid);
	mte.default_project = rtrim (pnte.default_project);
	mte.mailing_address = "";
	mte.acs_path.dir, mte.acs_path.entry = "";
	call mail_table_priv_$add (addr (mte), "1"b, code);
	if code ^= 0 then
	     call com_err_ (code, whoami, "Updating MAIL_TABLE.");

	if pnte.alias ^= "" then do;
	     call mail_table_priv_$add_alias (rtrim (uid), rtrim (pnte.alias), "1"b, code);
	     if code ^= 0 then
		call com_err_ (code, whoami, "Updating MAIL_TABLE.");
	end;

stop_given:
	if yes_no ("^/More users to add? ") then goto add_user;

RETURN_TO_CALLER:

	call cleaner;

	return;

/* * * * * * * * * * CHANGE * * * * * * * * * */

change: entry options (variable);

	alias_allowed = "0"b;
	loud = "1"b;
	goto change_common;

cg:  entry options (variable);

	alias_allowed, loud = "0"b;
	goto change_common;

cga: entry options (variable);

	loud = "0"b;
	alias_allowed = "1"b;

change_common:
	whoami = "new_user$change";

/**** Initialize these for cleanup handler */
	pp = null ();
	sadp = null ();
	ip = null ();
	on clean_up
	     call cleaner;

	call initialize ();
	arg_given = "0"b;
	changing = "1"b;
	uid, what, line = "";
	call cu_$arg_ptr (1, ap, al, code);
	if code = 0 then do;
	     uid = argument;
	     call cu_$arg_ptr (2, ap, al, code);
	     if code = 0 then do;
		what = argument;
		call cu_$arg_ptr (3, ap, al, code);
		if code = 0 then do;
		     line = argument;
		     arg_given = "1"b;
		end;
	     end;
	end;
	on new_user_stop goto RETURN_TO_CALLER;

	on linkage_error begin;
	     code = error_table_$moderr;
	     goto NO_ACCESS_TO_GATE;
	end;
	entry_var = pnt_admin_gate_$get_entry;
	revert linkage_error;

	if uid = "" then do;
read_cg_uid:   line = "";
	     call read_line ("User ID^-^-");
	     uid = rtrim(line);
	end;
	call pnt_manager_$get_entry ((uid), addr (old_pnte), code);
	if code ^= 0 then do;
	     call com_err_ (code, whoami, "Searching PNT for ^a.", uid);
	     goto read_cg_uid;
	end;
	uid = old_pnte.user_id;
	call urf_manager_$get_entry ((uid), addr (old_urfe), code);
	if code ^= 0 then do;
	     call com_err_ (code, whoami, "Searching URF for ^a.", uid);
	     goto read_cg_uid;
	end;

	urfe = old_urfe;
	pnte = old_pnte;

	if what ^= "" then do;			/* if item name given, see if it is legal */

/* These declarations are here so that anyone who adds change items to
   the list of "if" statements below will see that the item name must
   be added in two places. */

dcl  change_items char (54) int static options (constant) init
	("name,addr,progn,notes,proj,pass,cpass,npass,revalidate");
dcl  cga_items char (47) int static options (constant) init
	("alias,flags,auth,dfauth,audit");

	     if index (change_items, rtrim (what)) ^= 0 then
		goto change_item_ok;
	     if alias_allowed then
		if index (cga_items, rtrim (what)) ^= 0 then
		     goto change_item_ok;
	     call com_err_ (0, whoami, "Illegal change item ""^a"". Must be one of:^/^a^[,^a^].",
		what, change_items, alias_allowed, cga_items);
	     goto RETURN_TO_CALLER;
	end;
change_item_ok:

	if what = "" | what = "name" then do;
  	    if loud then call ioa_ ("^/Enter full user name (Last, First I.)");
              call read_name;
          end;
	if what = "" | what = "addr" then do;
              if loud then call ioa_ ("^/Enter mailing address");
	    call read_address;
	end;
	if what = "" | what = "progn" then do;
	    if loud then call ioa_ ("^/Enter programmer number");
	    call read_prog_number;
	end;
	if what = "" | what = "notes" then do;
              if loud then call ioa_ ("^/Enter notes");
	    call read_notes;
          end;
	if what = "" | what = "proj" then do;
              if loud then call ioa_ ("^/Enter default project");
	    call read_project;
          end;
	if (what = "" | what = "alias") & alias_allowed then do;
	     if loud then call ioa_ ("^/Enter alias");
	     call read_alias;
          end;
	if what = "" | what = "pass" then
	     do;
	     call read_password ("Password", pnte.private.password,
		pnte.public.flags.has_password,
		pnte.private.pw_flags.short_pw, set_password);
	                                               /* Don't forget to update date/time password was changed. */
	     if set_password then pnte.public.time_pw_changed = clock ();
	end;
	if what = "" | what = "cpass" | what = "npass" then
	     call read_password ("Network Password",
		pnte.private.network_password,
		pnte.public.flags.has_network_password,
		pnte.private.pw_flags.short_network_pw,
		set_network_password);
	if alias_allowed then do;
	     if what = "" | what = "flags" then do;
                    if loud then call ioa_ ("^/User registration flags:");
		call read_flags;
               end;
	     if what = "" | what = "auth" then do;
                    if loud then call ioa_ ("^/User authorization range:");
		call read_authorization_range (pnte.person_authorization);
               end;
	     if what = "" | what = "dfauth" then do;
	          if loud then call ioa_ ("Default user authorization:");
		call read_default_authorization (pnte.default_person_authorization);
               end;
	     if what = "" | what = "audit" then do;
	          if loud then call ioa_ ("^/Audit flags:");
		call read_audit;
	     end;
	     if what = "" | what = "revalidate" then
		call REVALIDATE_USER ();
	end;

	call urf_manager_$update_entry ((uid), addr (old_urfe), addr (urfe),
	     code);
	if code ^= 0 then
	     call com_err_ (code, whoami, "Updating URF entry.");

	call pnt_manager_$update_entry (addr (pnte), set_password,
	     set_network_password, code);
	if code ^= 0 then
	     call com_err_ (code, whoami, "Updating PNT entry.");

	                                               /* Updating the mail table is not nessesary with some change items. */
	if what = "name" | what = "addr" | what = "proj" | what = "alias" then do;
	     mte.version = MAIL_TABLE_ENTRY_VERSION_1;
	     call mail_table_priv_$get (rtrim (uid), addr (mte), code);
	     if code = 0 then do;
		mte.default_project = rtrim (pnte.default_project);
		call mail_table_priv_$update (addr (mte), "1"b, code);
		if code ^= 0 then call com_err_ (code, whoami, "Updating Mail Table.");
		if pnte.alias ^= old_pnte.alias then do;
		     if pnte.alias = "" then do;		/* Delete the alias */
			call mail_table_priv_$delete_alias (rtrim (old_pnte.alias), "1"b, code);
			if code ^= 0 then call com_err_ (code, whoami, "Deleting the alias from the Mail Table.");
			else do;
			     call mail_table_priv_$add_alias (rtrim (uid), rtrim (old_pnte.alias), "0"b, code);
			     if code ^= 0 then
				call com_err_ (code, whoami, "Adding the alias back to the Mail Table.");
			end;
		     end;
		     else do;
			call mail_table_priv_$add_alias (rtrim (uid), rtrim (pnte.alias), "1"b, code);
			if code ^= 0 then call com_err_ (code, whoami, "Adding new alias to Mail Table.");
		     end;
		end;
	     end;
	     else call com_err_ (code, whoami, "Retrieving Mail Table entry.");
	end;

	goto RETURN_TO_CALLER;
%page;
print_pnt:
     entry options (variable);

/**** This entry implements the command to display the contents of a
      user's PNT entry (or those of all users). */

declare  (nargs, i) fixed bin,
         (print_urf, print_all, password_info_set,
         no_password_info) bit aligned;

	whoami = "print_pnt";
	print_urf = "1"b;
	print_all = "1"b;
	changing = "0"b;
	call cu_$arg_count (nargs, code);
	if code ^= 0 then goto RETURN_TO_CALLER;
	on linkage_error begin;
	     code = error_table_$moderr;
	     goto NO_ACCESS_TO_GATE;
	end;
	entry_var = pnt_admin_gate_$get_entry;
	revert linkage_error;

	password_info_set = "0"b;
	no_password_info = "0"b;			/* Give the password info by default */
	do i = 1 to nargs;
	     call cu_$arg_ptr (i, ap, al, code);
	     if /* case */ argument = "-brief" | argument = "-bf" then print_urf = "0"b;
	     else if argument = "-password_info" | argument = "-no_password_info" then do;
		if password_info_set then do;
		     call com_err_ (error_table_$inconsistent,
			whoami, "-password_info and -no_password_info cannot both appear on a command line");
		     return;
		end;
		if argument = "-no_password_info" then no_password_info = "1"b;
		password_info_set = "1"b;
	     end;
	     else if substr (argument, 1, 1) = "-" then do;
		call com_err_ (error_table_$bad_arg, whoami,
		     "^a", argument);
		return;
	     end;
	     else print_all = "0"b;
	end;

	if ^print_all then do i = 1 to nargs;
	     call cu_$arg_ptr (i, ap, al, code);
	     if substr (argument, 1, 1) ^= "-" then do;
		uid = argument;
		call pnt_manager_$get_entry ((uid), addr (pnte), code);
		if code ^= 0 then do;
		     call com_err_ (code, whoami, "Reading PNT entry of ^a.", uid);
		     return;
		end;
		call print_it;
	     end;
	end;
	else do rec = 1 by 1;
	     call pnt_manager_$get_abs_entry (rec, addr (pnte), code);
	     if code = 0 then call print_it;
	     else if code = error_table_$checksum_failure
	     then call com_err_ (code, whoami, "Checksum failure on record ^d.", rec);
	     else if code ^= error_table_$no_record then do;
		if code ^= error_table_$bad_index
		then call com_err_ (code, whoami, "Reading from PNT.");
		return;
	     end;
	end;
	return;
%page;
print_it:
     procedure ();

/**** This procedure displays a single PNT entry. */

dcl  purf bit aligned;

	if print_urf then do;
	     call urf_manager_$get_entry ((pnte.user_id), addr (urfe), code);
	     purf = (code = 0);
	end;
	else purf = "0"b;

	call ioa_ ("^/User ID:^-^-^a", pnte.user_id);
	if purf then do;
	     call print_name;
	     call print_address;
	     call print_prog_number;
	     call print_notes;
	end;
	call print_project;
	call print_alias;
	call print_flags;
	call print_authorization_range (pnte.person_authorization);
	call print_default_authorization (pnte.default_person_authorization);
	call print_audit;
	if no_password_info then do;
	     if pnte.n_good_pw = 0 then
		call ioa_ ("Never logged in.");
	     else call ioa_ ("Last logged in at ^a.",
		     dt (pnte.time_last_good_pw));
	     return;
	end;
	call ioa_ ("^-^d good passwords given, last at ^a.",
	     pnte.n_good_pw, dt (pnte.time_last_good_pw));
	call ioa_ ("^-^d bad passwords given, last at ^a from ^a ^a terminal ^a.",
	     pnte.n_bad_pw, dt (pnte.time_last_bad_pw),
	     line_types (pnte.bad_pw_line_type), pnte.bad_pw_term_type,
	     pnte.bad_pw_term_id);
	if pnte.time_pw_changed ^= 0 then
	     call ioa_ ("^-Password changed: ^a", dt (pnte.time_pw_changed));
	call ioa_ ("^-User last validated on ^a", dt (pnte.user_validated_time));
     end print_it;
%page;
initialize:
     procedure ();

/**** This procedure initiates several files needed to execute this
      command. */

	call initiate_file_ (sadir, "projfile", R_ACCESS, pp, (0), code);
	if code ^= 0 then do;
	     call com_err_ (code, whoami, "Unable to initiate ^a.", pathname_ (sadir, "projfile"));
	     goto RETURN_TO_CALLER;
	end;

	call initiate_file_ (sadir, "sys_admin_data", R_ACCESS, sadp, (0), code);
	if code ^= 0
	then do;
	     call com_err_ (code, whoami, "Unable to initiate ^a.", pathname_ (sadir, "sys_admin_data"));
	     goto RETURN_TO_CALLER;
	end;

	call initiate_file_ (sysdir, "installation_parms", R_ACCESS, ip, (0), code);
	if code ^= 0 then
	     do;
	     call com_err_ (code, whoami, "Unable to initiate ^a.", pathname_ (sysdir, "installation_parms"));
	     goto RETURN_TO_CALLER;
	end;
	return;
     end initialize;
%page;
cleaner:
     procedure ();

/**** This is the cleanup handler for new_user */

dcl  tptr pointer;					/* temp pointer */

	if pp ^= null ()
	then do;
	     tptr = pp;
	     pp = null ();
	     call terminate_file_ (tptr, 0, TERM_FILE_TERM, (0));
	end;

	if sadp ^= null ()
	then do;
	     tptr = sadp;
	     sadp = null ();
	     call terminate_file_ (tptr, 0, TERM_FILE_TERM, (0));
	end;

	if ip ^= null () then
	     do;
	     tptr = ip;
	     ip = null ();
	     call terminate_file_ (tptr, 0, TERM_FILE_TERM, (0));
	end;
	return;

     end cleaner;


/* * * * * * * * * * READ_LINE * * * * * * * * * */

read_line: procedure (Prompt);

declare  (Prompt) character (*) aligned parameter;
declare  nelemt fixed bin (21),
         code fixed bin (35);

	if arg_given then do;
	     arg_given = "0"b;
	     return;
	end;

read_it:	call ioa_$nnl (Prompt);
	call iox_$get_line (iox_$user_input, addr (line), length (line), nelemt, code);
	if code = 0 then do;
	     substr (line, nelemt) = "";
	     if substr (line, 1, 4) = "stop" then signal new_user_stop;
	     return;
	end;

	do while (code = error_table_$long_record);
	     call iox_$get_line (iox_$user_input, addr (line), length (line), nelemt, code);
	end;
	if code = 0 then do;
	     call ioa_ ("Line too long.");
	     goto read_it;
	end;
	call com_err_ (code, whoami, "Reading from user_input.");
	goto RETURN_TO_CALLER;
     end read_line;


/* * * * * * * * * * UID_EXISTS * * * * * * * * * */

uid_exists: procedure (Uid) returns (bit aligned);

declare  Uid character (*) aligned parameter;
declare  code fixed bin (35);
declare  1 test_urfe aligned like urf_entry;

	uid = substr (Uid, 1, min (length (Uid), 20));
	call urf_manager_$get_entry ((uid), addr (test_urfe), code);
	if code = 0 then do;
	     call ioa_ ("""^a"" is in use by ^a, ^a; ^a.", uid, test_urfe.last_name, test_urfe.first_name, test_urfe.address);
	     return ("1"b);
	end;
	else if code = error_table_$id_not_found then do;
	     code = 0;
	     call mail_table_$get (rtrim (uid), null (), (""), code);
	     if code = 0 | code = mlsys_et_$ambiguous_address then do;
		call ioa_ ("""^a"" is in use as a Mail Table entry name.", uid);
		return ("1"b);
	     end;
	     if code = error_table_$id_not_found then do;
		if check_legal (uid) then return ("0"b);
		call ioa_ ("""^a"" is not a valid user_id.", uid);
		return ("1"b);
	     end;
	     else do;
		call com_err_ (code, whoami, "Getting name from MAIL_TABLE.");
		go to RETURN_TO_CALLER;
	     end;
	end;
	else do;
	     call com_err_ (code, whoami, "Getting entry from URF.");
	     goto RETURN_TO_CALLER;
	end;
     end uid_exists;
%page;
read_password:
     procedure (Prompt, Password, Has_pw, Short_pw, Pword_changed);

/**** This procedure prompts for and changes, if necessary, the specified
      password. */

declare  Prompt character (*);
declare  Password character (32) aligned parameter;
declare  Has_pw bit unaligned parameter;
declare  Short_pw bit (1) unaligned parameter;
declare  (p1, p2) character (8);
dcl  Pword_changed bit (1) parameter;
dcl  error_message char (64) automatic;			/* informative error message */
dcl  code fixed bin (35) automatic;			/* local status code */

	Pword_changed = "0"b;			/* Assume not changed yet */
read_them: call read_password_ (Prompt, p1);
	if p1 = "*"
	then if changing
	     then return;
	     else do;
		Password = "";
		Pword_changed = "1"b;
		Has_pw = "0"b;
		return;
	     end;
	else do;
	     call check_password_ (p1, error_message, code);
	     if code ^= 0 then
		do;
		call ioa_ ("^a", error_message);
		goto read_them;
	     end;
	end;

	call read_password_ ("Password again:", p2);
	if p1 ^= p2 then do;
	     call ioa_ ("Passwords don't agree -- try again.");
	     goto read_them;
	end;
	Password = scramble_ ((p1));
	Pword_changed = "1"b;
	p1, p2 = "";
	Has_pw = "1"b;
	Short_pw = "1"b;				/* We don't support 32 char passwords yet */
     end read_password;

/* * * * * * * * * * PRINT_ALIAS * * * * * * * * * */

print_alias: procedure;
	if (pnte.alias ^= "") | changing
	then call ioa_ ("Alias:^-^-^a", pnte.alias);
     end;

/* * * * * * * * * * READ_ALIAS * * * * * * * * * */

read_alias: procedure;
	if changing then call print_alias;
read_alias_again:
	call read_line ("Alias^-^-");
	if line = "" | line = "no" | line = "stop" then return;
	if changing then
	     if line = "." then do;			/* Means to delete the alias. */
		pnte.alias = "";
		return;
	     end;
	     else if line = pnte.alias then return;	/* Changed to itself */
	call pnt_manager_$get_entry ((line), addr (alias_pnte), code);
	if code = 0 then do;
	     call ioa_ ("The alias ""^a"" is already in use by ^a. Try another.", line, alias_pnte.user_id);
	     goto read_alias_again;
	end;
	code = 0;
	call mail_table_$get ((line), null (), (""), code);
	if code = 0 | code = mlsys_et_$ambiguous_address then do;
	     call ioa_ ("The alias ""^a"" is already in use as a Mail Table entry name.", line);
	     go to read_alias_again;
	end;
	if copy_and_check_length (line, pnte.alias, "alias") then goto read_alias_again;
     end read_alias;

/* * * * * * * * * * PRINT_PROG_NUMBER * * * * * * * * * */

print_prog_number: procedure;
	if urfe.prog_number ^= "none" | changing
	then call ioa_ ("Prog. number:^-^a", urfe.prog_number);
     end print_prog_number;

/* * * * * * * * * * READ_PROG_NUMBER * * * * * * * * * */

read_prog_number: procedure;

read_it:
	if changing then call print_prog_number;
	call read_line ("Prog. number^-");
	if changing
	then if (line = "") | (line = "no")
	     then return;
	     else ;
	else if line = "" then line = "none";
	if copy_and_check_length (line, urfe.prog_number, "programmer number")
	then goto read_it;
	if line ^= "none"
	then if verify (line, "0123456789 ") ^= 0
	     then call ioa_ ("WARNING: Programmer number contains non-numeric characters.");
	urfe.prog_number = rtrim(line);
     end read_prog_number;

/* * * * * * * * * * PRINT_AUDIT * * * * * * * * * */

print_audit: procedure;
declare  audit_string character (256);

	if pnte.audit = ""b & ^changing then return;
	call convert_access_audit_flags_$to_string (pnte.audit, audit_string, code);
	if code = 0
	then call ioa_ ("Audit Flags:^-^a", audit_string);
	else call ioa_ ("Audit Flags:^-""^12.3b""b3 (illegal format)", pnte.audit);
     end print_audit;

/* * * * * * * * * * READ_AUDIT * * * * * * * * * */

read_audit: procedure;

	if changing then do;
change_loop:   call print_audit;
	     call read_line ("Audit Flags^-");
	     if line = "" | line = "no" then return;
	     call convert_access_audit_flags_$edit_from_string ((line), pnte.audit, code);
	     if code ^= 0 then do;
		call com_err_ (code, whoami, "Converting audit string.");
		goto change_loop;
	     end;
	end;
	else do;
read_it:	     call read_line ("Audit Flags^-");
	     call convert_access_audit_flags_$from_string ((line), pnte.audit, code);
	     if code ^= 0 then do;
		call com_err_ (code, whoami, "Converting audit string.");
		goto read_it;
	     end;
	end;

	return;

     end read_audit;

/* * * * * * * * * * PRINT_AUTHORIZATION * * * * * * * * * * */

print_default_authorization: procedure (Which);

declare  Which bit (72) aligned parameter;
declare  auth_string character (256);

	if Which = ""b & ^changing then return;
	call convert_authorization_$to_string_short (Which, auth_string, code);
	call ioa_$nnl ("^a: ", "Default Authorization");
	if code = 0 then do;
	     if auth_string = "" then
		auth_string = "system_low";
	     call ioa_ ("^a", auth_string);
	end;
	else call ioa_ ("""^24.3b""b3", Which);
     end print_default_authorization;
%page;
print_authorization_range: procedure (P_auth_range);

dcl  P_auth_range (2) bit (72) aligned parameter;
dcl  auth_string char (256);
dcl  convert_authorization_$to_string_range_short entry ((2) bit (72) aligned, char (*), fixed bin (35));

	if P_auth_range (1) = ""b & P_auth_range (2) = ""b & ^changing
	then return;
	call convert_authorization_$to_string_range_short (P_auth_range, auth_string, code);
	call ioa_$nnl ("^a: ", "Authorization Range");
	if code = 0 then
	     call ioa_ ("^a", auth_string);
	else call ioa_ ("^24.3b:^24.3b", P_auth_range (1), P_auth_range (2));

     end print_authorization_range;
%page;
/* * * * * * * * * * * READ_AUTHORIZATION * * * * * * * * * */

read_default_authorization: procedure (Which);

declare  Which bit (72) aligned parameter;

read_it:
	if changing then
	     call print_default_authorization (Which);
	call read_line ("Default Authorization: ");
	if (line = "" | line = "no") & changing then return;
	call convert_authorization_$from_string (Which, (line), code);
	if code ^= 0 then do;
	     call com_err_ (code, whoami, "Converting authorization.");
	     goto read_it;
	end;
     end read_default_authorization;
%page;
read_authorization_range: procedure (P_auth_range);

dcl  P_auth_range (2) bit (72) aligned parameter;
dcl  convert_authorization_$from_string_range entry ((2) bit (72) aligned, char (*), fixed bin (35));

read_it:	if changing then
	     call print_authorization_range (P_auth_range);
	call read_line ("Authorization Range: ");
	if (line = "" | line = "no") & changing then return;
	call convert_authorization_$from_string_range (P_auth_range, (line), code);
	if code ^= 0 then do;
	     call com_err_ (code, whoami, "Converting authorization range.");
	     goto read_it;
	end;
	return;
     end read_authorization_range;
%page;
/* * * * * * * * * * PRINT_FLAGS * * * * * * * * * */

print_flags: procedure;
declare  lock_time character (14);

	lock_time = date_time_$format ("date_time", pnte.password_timelock,
	     "", "");
	call ioa_ ("Flags:^-^-^[^^^]password,^[^^^]network_pw,^[^^^]trap,^[^^^]lock,^[^^^]change,^[^^^]must_change,^[^^^]generate,^[^^^]operator,^[time_lock=^a^;^^time_lock^s^]",
	     ^pnte.has_password, ^pnte.has_network_password,
	     ^pnte.flags.trap, ^pnte.flags.lock, pnte.flags.nochange, ^pnte.flags.must_change, ^pnte.flags.generate_pw, ^pnte.flags.operator, pnte.flags.pw_time_lock, lock_time);
     end print_flags;
%page;
read_flags: procedure ();

/**** This internal procedure displays the current PNT flag settings and
      offers to change them.  */

dcl  (i, j) fixed bin;
dcl  mode_value bit aligned;

read_them:
	if changing then
	     call print_flags;
	call read_line ("Flags^-^-");
	if line = "" | line = "no" then
	     return;
	i = 1;
	do while (i <= length (line));
	     j = index (substr (line, i), ",") - 1;
	     if j < 0 then j = length (line) - i + 1;
	     if substr (line, i, 1) = "^"
	     then do;
		mode_value = "0"b;
		i = i + 1;
		j = j - 1;
	     end;
	     else mode_value = "1"b;
	     if substr (line, i, j) = "" then ;
	     else if substr (line, i, j) = "password" then
		pnte.flags.has_password =
		     pnte.flags.has_password & mode_value;
	     else if substr (line, i, j) = "network_pw" then
		pnte.flags.has_network_password =
		     pnte.flags.has_network_password & mode_value;
/**** Still support the old "card_pw" */
	     else if substr (line, i, j) = "card_pw" then
		pnte.flags.has_network_password =
		     pnte.flags.has_network_password & mode_value;
	     else if substr (line, i, j) = "trap" then
		pnte.flags.trap = mode_value;
	     else if substr (line, i, j) = "lock" then
		pnte.flags.lock = mode_value;
	     else if substr (line, i, j) = "change" then
		pnte.flags.nochange = ^mode_value;
	     else if substr (line, i, j) = "must_change" then
		pnte.flags.must_change = mode_value;
	     else if j >= 9 & substr (line, i, 9) = "time_lock" then do;
		if ^mode_value
		then pnte.password_timelock = 0;
		else do;
		     if j < 11 | substr (line, i + 9, 1) ^= "=" then do;
			call ioa_ ("Bad time lock specified.");
			goto read_them;
		     end;
		     call convert_date_to_binary_ (substr (line, i + 10, j - 10), pnte.password_timelock, code);
		     if code ^= 0 then do;
			call com_err_ (code, whoami, "Time lock.");
			goto read_them;
		     end;
		end;
		pnte.flags.pw_time_lock = mode_value;
	     end;
	     else if substr (line, i, j) = "generate" then
		pnte.flags.generate_pw = mode_value;
	     else if substr (line, i, j) = "operator" then pnte.flags.operator = mode_value;
	     else do;
		call ioa_ ("Invalid flag ""^a"" specified.", substr (line, i, j));
		goto read_them;
	     end;
	     i = i + j + 1;
	end;
     end read_flags;

/* * * * * * * * * * PRINT_PROJECT * * * * * * * * * * */

print_project: procedure;
	call ioa_ ("Project ID:^-^a", pnte.default_project);
     end print_project;

/* * * * * * * * * * READ_PROJECT * * * * * * * * * */

read_project: procedure;
declare  i fixed bin;

read_it:
	if changing then call print_project;
	call read_line ("Project ID^-");
	if line = "" | line = "No"
	then if changing
	     then return;
	     else goto read_it;
	if pp ^= null ()
	then do i = 1 to projfile.nproj;
	     if line = projfile.projfiletab (i).id then goto good_project;
	end;
	if length (rtrim (line)) > 9 then do;
	     call ioa_ ("Project name length > 9 characters.");
	     goto read_it;
	end;
	if pp ^= null () then call ioa_ ("WARNING: Project name not in projfile.");
good_project:
	urfe.project, pnte.default_project = rtrim(line);
     end read_project;

/* * * * * * * * * * * PRINT_NOTES * * * * * * * * * * * */

print_notes: procedure;
	call ioa_ ("Notes:^-^-^a", urfe.notes);
     end;

/* * * * * * * * * * * READ_NOTES * * * * * * * * * * * */

read_notes: procedure;

read_it:
	if changing then call print_notes;
	call read_line ("Notes^-^-");
	if changing then
	     if line = "" then return;
	     else if line = "." then line = "";
	if copy_and_check_length (line, urfe.notes, "notes field")
	then goto read_it;
	return;					/* 10/19/82 Jis: Always return, don't force user to give a notes field */
						/*	else if changing then return; */
						/* 	else goto read_it;  */
     end read_notes;

/* * * * * * * * * * * PRINT_ADDRESS * * * * * * * * * * */

print_address: procedure;
	call ioa_ ("Address:^-^-^a", urfe.address);
     end;

/* * * * * * * * * * READ_ADDRESS * * * * * * * * * */

read_address: procedure;

read_it:
	if changing then call print_address;
	call read_line ("Address^-^-");
	if line = "" then
	     if changing then return;
	     else goto read_it;
	else if copy_and_check_length (line, urfe.address, "address")
	then goto read_it;
     end read_address;

/* * * * * * * * * * * PRINT_NAME * * * * * * * * * */

print_name: procedure;
	call ioa_ ("Full name:^-^a, ^a^[ : ^a^;^s^]",
	     urfe.last_name, urfe.first_name, (urfe.title ^= ""), urfe.title);
     end;

/* * * * * * * * * * READ_NAME * * * * * * * * * */

read_name: procedure;
declare  (i1, i2, i4) fixed bin;

read_it:
	if changing then call print_name;
	call read_line ("Full name^-^-");
	if line = "" then if changing then return; else goto read_it;
	i2 = search (line, ":");
	if i2 = 0
	then urfe.title = "";
	else do;
	     i1 = search (substr (line, i2 + 1), " ");
	     if copy_and_check_length (substr (line, i2 + 1, i1 - 1),
		urfe.title, "title") then goto read_it;
	     substr (line, i2, i1) = "";
	end;

	i1 = search (line, ",");
	if i1 = 0 then do;
	     call ioa_ ("A comma must immediately follow the last name.");
	     goto read_it;
	end;
	if copy_and_check_length (substr (line, 1, i1 - 1), urfe.last_name, "last name")
	then goto read_it;
	if urfe.last_name = "" then do;
	     call ioa_ ("No last name given.");
	     goto read_it;
	end;
	if verify (substr (urfe.last_name, 1, 1), "*ABCDEFGHIJKLMNOPQRSTUVWXYZ") ^= 0
	then call ioa_ ("WARNING: Last name does not begin with capital letter.");
	substr (line, 1, i1) = "";

	i2 = verify (line, " ");			/* find beginning of first name */
	if i2 = 0 then do;
	     call ioa_ ("No first name givien.");
	     goto read_it;
	end;
	if copy_and_check_length (substr (line, i2), urfe.first_name, "first name")
	then goto read_it;
	if verify (substr (urfe.first_name, 1, 1), "ABCDEFGHIJKLMNOPQRSTUVWXYZ") ^= 0
	then call ioa_ ("WARNING: First name does not begin with a capital letter.");
	i4 = search (substr (line, i2), " ");
	if i4 = 0
	then initial = "";				/* first name no initial */
	else do;
	     initial = substr (line, i2 + i4, 1);	/* first name middle name */
	     if verify (initial, " ABCDEFGHIJKLMNOPQRSTUVWXYZ") ^= 0
	     then call ioa_ ("WARNING: Middle initial is not a capital letter.");
	end;
     end read_name;

/* * * * * * * * * * YES_NO * * * * * * * * * */

yes_no: procedure (Prompt) returns (bit aligned);
declare  Prompt character (*) aligned parameter;

read_it:	call read_line (Prompt);
	if line = "yes" | line = "y" then return ("1"b);
	else if line = "no" | line = "n" then return ("0"b);
	else do;
	     call ioa_ ("Please answer ""yes"", ""no"", ""y"", or ""n"".");
	     goto read_it;
	end;
     end yes_no;
%page;
dt:  procedure (Date) returns (character (16) aligned);

/**** This function returns a character string representation of
      a date-time. */

dcl  Date fixed bin (71);
dcl  date char (16);

	if Date = 0 then return ("NEVER");
	date = date_time_$format ("date_time", Date, "", "");
	return (date);
     end;

/* * * * * * * * * * CHECK_LEGAL * * * * * * * * * */

check_legal: proc (Thunk) returns (bit (1));
declare  Thunk char (*) aligned;
declare  ILLEGAL_FOR_UIDS char (4) init (" 	.;") internal static options (constant);

	if search (rtrim (Thunk), ILLEGAL_FOR_UIDS) = 0 then
	     return ("1"b);
	else return ("0"b);

     end check_legal;

/* * * * * * COPY_AND_CHECK_LENGTH * * * * * * * */

/* Check to see if Input fits in Output, complaining and returning true if
   it doesn't, copying and returning false if it does. */
copy_and_check_length:
     proc (Input, Output, Name) returns (bit (1));

dcl  (Input, Output, Name) char (*) aligned;

	if length (rtrim (Input)) > length (Output) then do;
	     call ioa_ ("The ^a ""^a"" is too long.  Maximum length is ^d.",
		Name, Input, length (Output));
	     return ("1"b);
	end;
	else do;
	     Output = Input;
	     return ("0"b);
	end;
     end copy_and_check_length;

/* * * * * * * * * * TEST * * * * * * * * * */

new_user_test:
     entry (Test_dir);

declare  Test_dir character (*) parameter;

	sadir = Test_dir;
	call pnt_manager_$test (Test_dir);
	call urf_manager_$test (Test_dir);
	call mail_table_priv_$test (Test_dir);
	return;
%page;
REVALIDATE_USER:
     procedure ();

/**** This procedure is used to revalidate a user.  User revalidation
      is used in order to prevent the expiration of a user's password
      if the installation parameter "password_expiration_interval" is
      set to a non-zero value.  If this parameter is non-zero, then
      if a user has not successfully logged in within the specified
      interval, he/she is refused the login.  If this occurs, a system
      administrator must issue the "new_user$cga Userid revalidate"
      command in order to revalidate the user.  This command line may
      be used to anticipate the password expiration of a user and
      ensure that the user is not denied login.  This is necessary,
      for instance for server processes (network, IMFT, mailer) which
      log in with passwords, but which do not have a means of coping
      with this situation.

      If this procedure was invoked because of the command line specified
      above, the user-revalidation time in the PNT entry is updated
      to the current time.  If this procedure is invoked due to the
      new_user$cga prompt-mode, then the user is prompted as to whether
      or not he/she wants to revalidate the user. */

dcl  1 qi aligned like query_info;
dcl  explanation char (182) initial (
	"Answering ""yes"" to this question will allow the user to log in even though he/she may not have logged in with the password_expiration_interval defined in the installation parameters.") internal static options (constant);
dcl  appropriate_answer_given bit (1) aligned;
dcl  answer char (4);

	if what = "revalidate" then
	     pnte.user_validated_time = clock ();
	else if installation_parms.password_expiration_interval ^= 0 then
	     do;
	     unspec (qi) = ""b;
	     qi.version = query_info_version_6;
	     qi.switches.prompt_after_explanation = "1"b;
	     qi.question_iocbp = null ();
	     qi.answer_iocbp = null ();
	     qi.explanation_ptr = addr (explanation);
	     qi.explanation_len = length (explanation);
	     appropriate_answer_given = "0"b;
	     do while (^appropriate_answer_given);
		call command_query_ (addr (qi), answer, whoami,
		     "User last validated at ^a, revalidate?",
		     dt (pnte.user_validated_time));
		if answer = "yes" | answer = "y" then
		     do;
		     appropriate_answer_given = "1"b;
		     pnte.user_validated_time = clock ();
		end;
		else if answer = "no" | answer = "n" | answer = "" then
		     appropriate_answer_given = "1"b;
	     end;
	end;
	return;
     end REVALIDATE_USER;


NO_ACCESS_TO_GATE:
     call com_err_ (code, whoami, "pnt_admin_gate_");
     return;


/* format: off */
%page;%include access_mode_values;
%page;%include installation_parms;
%page;%include line_types;
%page;%include mail_table_entry;
%page;%include pnt_entry;
%page;%include projfile;
%page;%include query_info;
%page;%include sys_admin_data;
%page;%include terminate_file;
%page;%include urf_entry;
/* format: on */

     end new_user;
