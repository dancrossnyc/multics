/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */

/* format: style3 */

/* This command prints out a "Multics Usage and Revenue Report." */
/* Coded October 1975 by Jim Homan
   Modified Feb 1980 by M. B. Armstrong to implement multiple rate structures.
   Modified August 1981 by T. Casey to eliminate reference to master_proj in bin,
   -		and change all declarations of rs_number to eliminate "(9) unsigned unaligned".
   Modified 1984-08-31 BIM for V3 use_totals, usage message.
*/

usage_and_revenue:
     proc;
dcl	(
	xtotp,					/* pointer to old use_totals segment */
	cptr,					/* pointer to control file */
	gptr,					/* pointer to groups structure */
	arg_list_ptr
	)		ptr,			/* pointer to argument list for usage_and_revenue */
	null		builtin,
	(
	ngroups,					/* # of groups in report, # of elements in groups structure */
	clen,					/* # of groups in report, # of elements in groups structure */
	i,
	j
	)		fixed bin,
	rate_ix		fixed bin,
	ec		fixed bin (35),		/* error code */
	daily		bit (1),			/* Is this daily or monthly report? */
	OK		bit (1),			/* Is it OK to continue? */
	first_time	bit (1) init ("1"b),
	short_date	char (8),
	size		condition,
	sysprint		file output stream print;	/* All output goes to sysprint */
dcl	1 titles,					/* Titles for first page */
	  2 company	char (120),		/* Company name, double spaced */
	  2 dept		char (120),		/* department name, double spaced */
	  2 report_title	char (50),		/* ...usage and revenue report */
	  2 time_span	char (42),		/* For mm/dd/yy hhmm dddto mm/dd/yy hhmm ddd */
	  2 system	char (24);		/* Current System: xxx */


declare	max_rs_number	fixed bin;
declare	P_ptr		pointer;
dcl	1 P		(0:max_rs_number) based (P_ptr),
						/* all the prices for all rate structures */
	  2 rs_name	char (32),		/* name for this rate */
	  2 abs_cpu_rates	(1:4) float bin,		/* installation price for absentee cpu time ($/hr) */
	  2 abs_memory_rates
			(1:4) float bin,		/* installation price for absentee memory usage ($/Kmu) */
	  2 connect_rates	(0:7) float bin,		/* installation price for terminal connect time ($/hr) */
	  2 memory_rates	(0:7) float bin,		/* installation price for memory usage ($/Kmu) */
	  2 disk_rates	float bin,		/* installation price for disk storage ($/page-sec) */
	  2 cpu_rates	(0:7) float bin,		/* installation price for interactive cpu time ($/hr) */
	  2 lines_rates	(1:4) float bin,		/* installation price for line printer lines ($/K-lines) */
	  2 ioops_rates	(0:7) float bin,		/* installation price for I/O operations ($/K) */
	  2 reg_rates	float bin,		/* user registration charge ($/month) */
	  2 device_table	aligned,
	    3 ndevices	fixed bin,		/* number of devices used */
	    3 dvt		(16),
	      4 device_id	char (8),
	      4 device_rates
			(0:7) float bin;		/* $/hr */
dcl	shift_table	(336) fixed bin;		/* table of shift #'s for each half hour in week */
dcl	cu_$arg_list_ptr	entry (ptr);		/* multics subroutine */
dcl	com_err_		entry options (variable);
dcl	system_info_$rs_name
			entry (fixed bin, char (*), fixed bin (35));
dcl	system_info_$max_rs_number
			entry (fixed binary);
dcl	system_info_$shift_table
			entry ((336) fixed bin);

dcl	(addr, bin, divide, hbound, index, length, lineno, max, min, mod, multiply, onloc, pageno, reverse, sign,
	substr, sum, verify)
			builtin;

/* the groups structure is filled in by the procedures parse_control_file, initial, add_bins and conversions_and_sums. */

/* structure to hold everything that gets printed in the report */

dcl	1 groups		(ngroups) based (gptr),
	  2 bins		(301) fixed bin,		/* the usage bins specified in control file for this group */
	  2 groups	(9) fixed bin,		/* the other groups specified in control file for this group */
	  2 all_bins	(301) fixed bin,		/* all the usage bins which go into this group */
	  2 title		char (24),		/* the title for this group, as specified in control file */
	  2 title_line_1	char (12),		/* first part of the title */
	  2 title_line_2	char (12),		/* second part of the title */
	  2 projects	fixed bin,		/* number of projects included in this group */
	  2 users		fixed bin,		/* number of users included in this group */
	  2 devices$	float bin,		/* device charges */
	  2 misc_dollars	float bin,		/* miscellaneous charges */
	  2 disk,					/* disk statistics */
	    3 page_days	float bin,
	    3 page_days$	float bin,		/* charge for disk storage */
	    3 quota	fixed bin (35),		/* normal storage quota */
	    3 usage	fixed bin (35),		/* pages of normal storage */
	  2 interactive,				/* interactive usage statistics */
	    3 shifts	(0:7),
	      4 cpu	float bin,		/* cpu hours */
	      4 cpu_dollars float bin,		/* charge for cpu time */
	      4 memory	float bin,		/* memory units */
	      4 memory_dollars
			float bin,		/* charge for memory */
	      4 connect	float bin,		/* connect hours */
	      4 connect_dollars
			float bin,		/* charge for connect time */
	      4 ioops	float bin,		/* terminal io ops */
	      4 ioops_dollars
			float bin,		/* total charges for shift */
	      4 total_dollars
			float bin,		/* total charges for shift */
	      4 dollars_per_hour
			float bin,		/* average cost per connect hour */
	    3 total	like groups.interactive.shifts,
						/* total for all shifts */
	    3 sessions	fixed bin,		/* number of logins */
	    3 dollars_per_session
			float bin,		/* dollars per connect hour */
	    3 hours_per_session
			float bin,		/* average session length */
	  2 absentee,				/* absentee usage statistics */
	    3 queues	(4),
	      4 cpu	float bin,		/* cpu hours */
	      4 cpu_dollars float bin,		/* charge for cpu time */
	      4 memory	float bin,		/* memory units */
	      4 memory_dollars
			float bin,		/* charge for memory */
	      4 jobs	fixed bin,		/* number of absentee jobs */
	      4 total_dollars
			float bin,		/* total charges for queue */
	      4 dollars_per_job
			float bin,		/* average cost per absentee job */
	    3 total	like groups.absentee.queues,	/* dtotal for all queues */
	  2 iod,					/* IO Daemon statistics */
	    3 queues	(4),
	      4 lines	float bin,		/* number of lines printed */
	      4 lines_dollars
			float bin,		/* print charges */
	    3 total	like groups.iod.queues,	/* total for all queues */
	  2 total,				/* overall totals */
	    3 cpu		float bin,		/* cpu hours */
	    3 cpu_dollars	float bin,		/* charge for cpu time */
	    3 memory	float bin,		/* memory units */
	    3 memory_dollars
			float bin,		/* charge for memory use */
	    3 today_dollars float bin,		/* total charges today */
	    3 month_dollars float bin;		/* total charges for month */

declare	ME		char (32) init ("usage_and_revenue") int static options (constant);

declare	cleanup		condition;
%page;
%include access_mode_values;
%include terminate_file;
%page;
%include use_totals;


	use_totals_ptr, xtotp, gptr, P_ptr = null ();
	on cleanup
	     begin;
		call clean_up (use_totals_ptr, xtotp, gptr);
	     end;
	call system_info_$max_rs_number (max_rs_number);
	allocate P set (P_ptr);
	close file (sysprint);
	open file (sysprint) linesize (300) pagesize (66);/* open sysprint with a big linesize  and a pagesize
						   larger than any of the pages in the report */
	call cu_$arg_list_ptr (arg_list_ptr);		/* get pointer to argument list */
	call process_args (arg_list_ptr, use_totals_ptr, xtotp, daily, cptr, clen, OK);
	if ^OK
	then do;
		call clean_up (use_totals_ptr, xtotp, null);
		return;
	     end;
	call parse_control_file (cptr, clen, OK);
	if ^OK
	then do;
		call clean_up (use_totals_ptr, xtotp, gptr);
error:
		return;
	     end;
	call system_info_$shift_table (shift_table);
	do rate_ix = 0 to hbound (P, 1);		/* get all the prices */
	     call system_info_$rs_name (rate_ix, P (rate_ix).rs_name, ec);
	     if ec ^= 0
	     then do;
		     P (rate_ix) = P (0);		/* assumes default will not cause an error */
		     P (rate_ix).rs_name = "";
		end;
	     else call get_prices (rate_ix, P (rate_ix));
	end;
	call make_titles (daily, titles, short_date);
	do i = 1 to ngroups;
	     call initial (i);
	     do j = 1 to hbound (groups.all_bins, 2) while (groups (i).all_bins (j) ^= 0);
		call add_bins (i, groups (i).all_bins (j), daily,
		     P (use_totals.ut (groups (i).all_bins (j)).rs_number));
	     end;
	end;
	call conversions_and_sums;
	on size
	     begin;				/* Handle size condition on output as gracefully as possible */
		call clean_up (use_totals_ptr, xtotp, gptr);
		call com_err_ (0, ME, "Number too big for output format. Error occurred in routine ^a.", onloc ());
		go to error;
	     end;
	call revenue_summary (daily, titles);
	call interactive_summary (short_date);
	call absentee_summary (short_date);
	call iod_summary (short_date);
	call system_stats (daily, short_date);
	call disk_stats ();
	if daily
	then call times_available ();
	if ^daily
	then call group_composition (short_date);
	if ^daily
	then do rate_ix = 0 to hbound (P, 1);
		if P (rate_ix).rs_name ^= ""
		then call rates_and_shifts (P (rate_ix), shift_table, short_date);
	     end;

	call footnote (short_date);
	revert size;
	call clean_up (use_totals_ptr, xtotp, gptr);

process_args:
     proc (ap, use_totals_ptr, xtotp, daily, cptr, clen, OK);

/* This procedure processes the arguments to usage_and_revenue.
   Parameters:
   ap - input - Pointer to usage_and_revenue argument list.
   use_totals_ptr - output - Pointer to current use_totals segment.
   xtotp - output - Pointer to old use_totals segment.
   daily - output -"1"b if daily report, "0"b if monthly report.
   cptr - output - Pointer to control file.
   clen - output - Length of control file (number of characters).
   OK - output - "1"b if everything ok, "0"b if error was detected and com_err_ called. */

dcl	(use_totals_ptr, xtotp, cptr, ap)
			ptr,
	count		fixed bin (24),
	clen		fixed bin,
	(daily, OK)	bit (1),
	dn		char (168),
	en		char (32),
	ec		fixed bin (35),		/* error code returned from multics subroutines */
	argptr		ptr,			/* ptr to usage_and_revenue argument */
	arglen		fixed bin (21),		/* length of usage_and_revenue argument */
	arg		char (arglen) based (argptr), /* usage_and_revenue argument */
	null		builtin;
dcl	arg_count		fixed bin;
dcl	error_table_$unimplemented_version
			external fixed bin (35);
dcl	com_err_		entry options (variable),
	cu_$arg_ptr_rel	entry (fixed bin, ptr, fixed bin (21), fixed bin (35), ptr);
dcl	cu_$arg_count_rel	entry (fixed bin, ptr, fixed bin (35));
dcl	com_err_$suppress_name
			entry () options (variable);

	call cu_$arg_count_rel (arg_count, ap, ec);
	if ec ^= 0
	then do;
		call com_err_ (ec, ME);
		OK = "0"b;
		return;
	     end;
	if arg_count < 2
	then do;
		call com_err_$suppress_name (0, ME,
		     "Usage: usage_and_revenue Control_File Current_Use_Totals.use_totals {Previous_Use_Totals.use_totals}"
		     );
		OK = "0"b;
		return;
	     end;

	OK = "1"b;
	call get_seg_from_arg (1, ap, "control", cptr, count, dn, en, OK);
	if ^OK
	then return;
	clen = divide (count, 9, 17, 0);
	call get_seg_from_arg (2, ap, "use_totals", use_totals_ptr, count, dn, en, OK);
	if ^OK
	then return;
	if use_totals.version ^= USE_TOTALS_VERSION_3
	then do;
bad_version:
		call com_err_ (error_table_$unimplemented_version, ME, "For seg ^a>^a.
Use convert_MR10_2_use_totals to convert to version 3.", dn, en);
		OK = "0"b;
		return;
	     end;
	call cu_$arg_ptr_rel (3, argptr, arglen, ec, ap);
	if ec = 0
	then do;
		call get_seg_from_arg (3, ap, "use_totals", xtotp, count, dn, en, OK);
		if ^OK
		then return;
		if xtotp -> use_totals.version ^= USE_TOTALS_VERSION_3
		then goto bad_version;
	     end;
	if xtotp = null
	then daily = "0"b;
	else daily = "1"b;


get_seg_from_arg:
     proc (argno, ap, suffix, p, count, dn, en, OK);

/* This procedure gets the pathname of a segment from an argument list and
   returns a pointer to the segment and its bit count.
   Parameters:
   argno  - input - The number of the argument to be used as pathname
   ap - input - Pointer to the argument list.
   suffix - input - required suffix on segment.
   count - output - Bit count of the segment.
   p - output - Pointer to the segment.
   OK - output - "0"b if error was detected and com_err_ called. "1"b if everything was ok. */

dcl	argno		fixed bin,
	count		fixed bin (24),
	OK		bit (1),
	(ap, p)		ptr,
	ec		fixed bin (35),		/* error code returned from multics subroutines */
	argptr		ptr,			/* ptr to usage_and_revenue argument */
	arglen		fixed bin (21),		/* length of usage_and_revenue argument */
	arg		char (arglen) based (argptr), /* usage_and_revenue argument */
	dn		char (*),			/* directory name */
	en		char (*),			/* entry name */
	null		builtin;
dcl	suffix		char (*);

dcl	cu_$arg_ptr_rel	entry (fixed bin, ptr, fixed bin (21), fixed bin (35), ptr);
dcl	expand_pathname_$add_suffix
			entry (character (*), character (*), character (*), character (*), fixed binary (35));
dcl	initiate_file_	entry (character (*), character (*), bit (*), pointer, fixed binary (24), fixed binary (35))
			;
dcl	com_err_		entry options (variable);
	OK = "1"b;
	call cu_$arg_ptr_rel (argno, argptr, arglen, ec, ap);
						/* get the argument */
	if ec ^= 0
	then do;
		call com_err_ (ec, ME);		/* couldn't find the argument */
		OK = "0"b;
		return;
	     end;
	call expand_pathname_$add_suffix (arg, suffix, dn, en, ec);
	if ec ^= 0
	then do;
		call com_err_ (ec, ME, "^a", arg);
		OK = "0"b;
		return;
	     end;
	call initiate_file_ (dn, en, R_ACCESS, p, count, ec);
	if ec ^= 0
	then do;
		call com_err_ (ec, ME, "^a>^a", dn, en);
		OK = "0"b;
		return;
	     end;
     end get_seg_from_arg;
     end process_args;

get_prices:
     proc (rs_number, P);

/* This procedure calls the different system_info_ entry points to get all the system rate
   and shift info.
   Parameters:
   are all input parameters */

dcl	rs_number		fixed bin;		/* rate structure to use */
dcl	1 P,
	  2 rs_name	char (32),		/* name for this rate */
	  2 abs_cpu_rates	(1:4) float bin,		/* installation price for absentee cpu time ($/hr) */
	  2 abs_memory_rates
			(1:4) float bin,		/* installation price for absentee memory usage ($/Kmu) */
	  2 connect_rates	(0:7) float bin,		/* installation price for terminal connect time ($/hr) */
	  2 memory_rates	(0:7) float bin,		/* installation price for memory usage ($/Kmu) */
	  2 disk_rates	float bin,		/* installation price for disk storage ($/page-sec) */
	  2 cpu_rates	(0:7) float bin,		/* installation price for interactive cpu time ($/hr) */
	  2 lines_rates	(1:4) float bin,		/* installation price for line printer lines ($/K-lines) */
	  2 ioops_rates	(0:7) float bin,		/* installation price for I/O operations ($/K) */
	  2 reg_rates	float bin,		/* user registration charge ($/month) */
	  2 device_table	aligned,
	    3 ndevices	fixed bin,		/* number of devices used */
	    3 dvt		(16),
	      4 device_id	char (8),
	      4 device_rates
			(0:7) float bin;		/* $/hr */

dcl	system_info_$prices_rs
			entry (fixed bin, (0:7) float bin, (0:7) float bin, (0:7) float bin, (0:7) float bin,
			float bin, float bin),	/* Gets interactive installation prices */
	system_info_$io_prices_rs
			entry (fixed bin, (4) float bin),
						/* gets daemon installation prices */
	system_info_$abs_prices_rs
			entry (fixed bin, (4) float bin, (4) float bin),
						/* gets absentee installation prices */
	system_info_$device_prices_rs
			entry (fixed bin, fixed bin, ptr);

	call system_info_$prices_rs (rs_number, P.cpu_rates, P.connect_rates, P.ioops_rates, P.memory_rates,
	     P.disk_rates, P.reg_rates);
	call system_info_$abs_prices_rs (rs_number, P.abs_cpu_rates, P.abs_memory_rates);
	call system_info_$io_prices_rs (rs_number, P.lines_rates);
	call system_info_$device_prices_rs (rs_number, P.device_table.ndevices, addr (P.device_table.dvt (1)));
     end get_prices;

parse_control_file:
     proc (cptr, clen, OK);

/* This procedure reads through the control file, determines the number of
   groups (=ngroups), allocates the groups structure  and for each element in the groups structure it fills in
   bins,groups,all_bins,title,title_line_1 and title_line_2.
   Parameters:
   cptr - input - pointer to the control file segment
   clen - input - length of the control file segment
   OK - output - "0"b if error has been detected and com_err_ called.  "1"b if everything ok */

dcl	(i, j, k, m, n)	fixed bin,
	clen		fixed bin,
	cptr		ptr,
	OK		bit (1),
	all_done		bit (1),
	ec		fixed bin (35);
dcl	com_err_		entry options (variable);
dcl	get_temp_segment_	entry (character (*), pointer, fixed binary (35));

dcl	bin		bit (1);
dcl	(start1, start2)	fixed bin;
dcl	(end_of_line, end_of_file)
			bit (1);
dcl	control		char (clen) based (cptr);
dcl	line		char (400) var,
	title		char (24);
dcl	1 more_groups	(9),
	  2 all_processed	bit (1) init ((9) (1)"0"b),
	  2 group_titles	(9) char (24) aligned init ((81) (1)""),
	  2 group_numbers	(9) fixed bin init ((81) 0),
	  2 nbins		fixed bin,
	  2 ng		fixed bin,
	  2 nall_bins	fixed bin;
	call get_temp_segment_ (ME, gptr, ec);
	if ec ^= 0
	then do;
		call com_err_ (ec, ME);
		OK = "0"b;
		return;
	     end;
	start1 = 1;
	call get_line (control, start1, line, end_of_file);
	if end_of_file
	then do;
		call com_err_ (0, ME, "No valid lines in control file");
		OK = "0"b;
		return;
	     end;
	ngroups = 0;
	do while (^end_of_file);
	     ngroups = ngroups + 1;
	     if ngroups > 9
	     then do;
		     call com_err_ (0, ME, "More than 9 groups specified in control file.");
		     OK = "0"b;
		     return;
		end;
	     groups (ngroups).bins (*) = 0;
	     start2 = 1;
	     call get_group_title (line, start2, title, end_of_line);
	     if end_of_line
	     then do;
		     call com_err_ (0, ME, "^a:^a", "Bad line in control file", line);
		     OK = "0"b;
		     return;
		end;
	     groups (ngroups).title = title;
	     call split_title (groups (ngroups).title, groups (ngroups).title_line_1, groups (ngroups).title_line_2);
	     call get_bin_title (line, start2, title, bin, end_of_line);
	     if end_of_line
	     then do;
		     call com_err_ (0, ME, "^a:^a", "Bad line in control file", line);
		     OK = "0"b;
		     return;
		end;
	     do while (^end_of_line);
		if bin
		then do;
			i = 1;
			do while (use_totals.ut (i).utype ^= title & i <= use_totals.ntypes);
			     i = i + 1;
			end;
			if i > use_totals.ntypes
			then do;
				call com_err_ (0, ME, "Line contains an invalid bin name: ^a", line);
				OK = "0"b;
				return;
			     end;
			else do;
				j = 1;
				do while (groups (ngroups).bins (j) ^= 0 & j <= hbound (groups.bins, 2));
				     j = j + 1;
				end;
				if j > hbound (groups.bins, 2)
				then do;
					call com_err_ (0, ME,
					     "Too many bins specified in control file line: ^a", line);
					OK = "0"b;
					return;
				     end;
				else groups (ngroups).bins (j) = i;
			     end;
		     end;
		else do;
			i = 1;
			do while (more_groups (ngroups).group_titles (i) ^= "" & i <= 9);
			     i = i + 1;
			end;
			if i > 9
			then do;
				call com_err_ (0, ME, "Too many groups specified in control file line: ^a", line);
				OK = "0"b;
				return;
			     end;
			else more_groups (ngroups).group_titles (i) = title;
		     end;
		call get_bin_title (line, start2, title, bin, end_of_line);
	     end;
	     call get_line (control, start1, line, end_of_file);
	end;
	groups (*).all_bins (*) = 0;
	groups (*).groups (*) = 0;
	do i = 1 to ngroups;
	     groups (i).all_bins (*) = groups (i).bins (*);
	     j = 1;
	     do while (groups (i).all_bins (j) > 0);
		j = j + 1;
	     end;
	     more_groups (i).nbins, more_groups (i).nall_bins = j - 1;
	     do j = 1 to 9 while (more_groups (i).group_titles (j) ^= "");
		k = 1;
		do while (more_groups (i).group_titles (j) ^= groups (k).title & k <= ngroups);
		     k = k + 1;
		end;
		if k > ngroups
		then do;
			call com_err_ (0, ME,
			     "Reference to group ""^a"" in control file, but no group by that title exists",
			     more_groups (i).group_titles (j));
			OK = "0"b;
			return;
		     end;
		else do;
			more_groups (i).group_numbers (j) = k;
			groups (i).groups (j) = k;
		     end;
	     end;
	     more_groups (i).ng = j - 1;
	     if more_groups (i).ng = 0
	     then more_groups (i).all_processed = "1"b;
	end;
	all_done = "0"b;
	do i = 1 to 9 while (^all_done);
	     all_done = "1"b;
	     do j = 1 to ngroups;
		if ^more_groups (j).all_processed
		then do k = 1 to 9;
			n = more_groups (j).group_numbers (k);
			if n > 0
			then if more_groups (n).all_processed
			     then do;
				     if more_groups (n).nall_bins + more_groups (j).nall_bins
					> hbound (groups.bins, 2)
				     then do;
					     call com_err_ (0, ME, "Too many bins specified for group ^a",
						groups (j).title);
					     OK = "0"b;
					     return;
					end;
				     do m = 1 to more_groups (n).nall_bins;
					groups (j).all_bins (m + more_groups (j).nall_bins) =
					     groups (n).all_bins (m);
				     end;
				     more_groups (j).nall_bins =
					more_groups (j).nall_bins + more_groups (n).nall_bins;
				     more_groups (j).group_numbers (k) = 0;
				end;
			     else all_done = "0"b;
		     end;
		if sum (more_groups (j).group_numbers (*)) = 0
		then more_groups (j).all_processed = "1"b;
	     end;
	end;
	if ^all_done
	then do;
		call com_err_ (0, ME, "There is a circular reference to groups in the control file.");
		OK = "0"b;
		return;
	     end;
split_title:
     proc (title, line1, line2);

/* This procedure takes a group title and breaks it into 2 lines
   Parameters:
   title - input - group title
   line1,line2 - output - the 2 shorter lines */

dcl	title		char (24),
	(line1, line2)	char (12),
	t		char (24) var,
	(i, j, m, l1, s2, l2, m1, m2)
			fixed bin;

	line1, line2 = "";
	t = substr (title, 1, min (length (title), length (title) - verify (reverse (title), " ") + 1));
	m = length (t) / 2;
	i = index (reverse (substr (t, 1, m)), " ");
	j = index (substr (t, m + 1), " ");
	if i = 0 & j = 0
	then do;
		if length (t) < 12
		then substr (line2, 13 - length (t)) = t;
		else do;
			line1 = substr (t, 1, 12);
			line2 = substr (t, 13);
		     end;
	     end;
	else if (i > 0 & j = 0) | (i > 0 & j > 0 & i < j)
	then do;
		l1 = m - i;
		s2 = l1 + 2;
		l2 = length (t) - l1 - 1;
		m2 = max (1, 12 - l2 + 1);
		m1 = m2 + (l2 - l1 + 1) / 2;
		substr (line1, m1) = substr (t, 1, l1);
		substr (line2, m2) = substr (t, s2);
	     end;
	else if (j > 0 & i = 0) | (j > 0 & i > 0 & j < i)
	then do;
		l1 = m + j - 1;
		s2 = l1 + 2;
		l2 = length (t) - l1 - 1;
		m1 = max (1, 12 - l1 + 1);
		m2 = m1 + (l1 - l2 + 1) / 2;
		substr (line1, m1) = substr (t, 1, l1);
		substr (line2, m2) = substr (t, s2);
	     end;
     end split_title;
get_line:
     proc (c, s, l, eof);

/* This procedure gets the next line from the control file.
   Parameters:
   c - input - the control file
   s - input,output - the current position in the control file
   l - output - the next line
   eof - output - "1"b if there are no more lines in file */

dcl	c		char (*),
	l		char (*) var,
	(s, i)		fixed bin,
	eof		bit (1),
	NL		char (1) init ("
");

	if s > length (c)
	then eof = "1"b;
	else do;
		i = index (substr (c, s), NL);
		if i = 0
		then eof = "1"b;
		else do;
			i = i + s;
			l = substr (c, s, i - s - 1);
			s = i;
			eof = "0"b;
			if substr (l, 1, 1) = "*"
			then /* ignore comment lines */
			     call get_line (c, s, l, end_of_file);
		     end;
	     end;
     end get_line;
get_group_title:
     proc (l, s, t, eol);

/* This procedure extracts the group title from the beginning of a control fileline.
   Parameters:
   l - input - the control file line
   s - input,output - the current position within the line
   t - output - the group title
   eol - output - "1"b if there is no group title  in line */

dcl	l		char (*) var,
	t		char (*),
	eol		bit (1),
	(s, i)		fixed bin;

	i = index (substr (l, s), ":");
	if i = 0
	then eol = "1"b;
	else do;
		t = substr (l, s, i - s);
		eol = "0"b;
		s = i + 1;
	     end;
     end get_group_title;
get_bin_title:
     proc (l, s, t, b, eol);

/* This procedure extracts bin or group titles from a control file line.
   Parameters:
   l - input - the control file line
   s - input,output - the current position within the line
   t - output - the next bin or group title
   b - output - "1"b if bin title, "0"b if group title
   eol - output - "1"b if there are no more titles in the line */

dcl	l		char (*) var,
	t		char (*),
	(s, i)		fixed bin,
	eol		bit (1),
	b		bit (1);

	if s > length (l)
	then do;
		eol = "1"b;
		return;
	     end;
	eol = "0"b;
	i = index (substr (l, s), ",");
	if i = 0
	then i = length (l) + 2;
	else i = i + s;
	if substr (l, s, 1) = """" & substr (l, i - 2, 1) = """"
	then do;
		t = substr (l, s + 1, i - s - 3);
		b = "0"b;
	     end;
	else do;
		t = substr (l, s, i - s - 1);
		b = "1"b;
	     end;
	s = i;
     end get_bin_title;
     end parse_control_file;

make_titles:
     proc (daily, titles, short_date);

/* This procedure sets up the titles for the report.
   Parameters:
   daily - input - "1"b if daily report, "0"b if monthly report
   titles - output - the titles for the report
   short_date - output - date to be printed in top left corner of pages */

dcl	daily		bit (1);
dcl	1 titles,					/* Titles for 1st and last pages */
	  2 company	char (120),		/* Company name, double spaced */
	  2 dept		char (120),		/* department name, double spaced */
	  2 report_title	char (50),		/* ...usage and revenue report */
	  2 time_span	char (42),		/* For mm/dd/yy hhmm dddto mm/dd/yy hhmm ddd */
	  2 system	char (24);		/* Current System: xxx */
dcl	short_date	char (8);
dcl	dummy		char (1);
dcl	system_info_$titles entry (char (*), char (*), char (*), char (*));
	call system_info_$titles (dummy, dummy, titles.company, titles.dept);
	if daily
	then titles.report_title = "Multics Usage and Revenue Report";
	else titles.report_title = "**** Monthly Multics Usage and Revenue Report ****";
	if daily
	then titles.time_span =
		"For " || format_time (xtotp -> use_totals.period_end) || " to "
		|| format_time (use_totals.period_end);
	else titles.time_span =
		"For " || format_time (use_totals.period_begin) || " to " || format_time (use_totals.period_end);
	short_date = substr (format_time (use_totals.period_end), 1, 8);
	titles.system = "Current System: " || use_totals.last_sysid;
     end make_titles;

initial:
     proc (n);

/* This procedure zeroes out the data in one element of the groups structure.
   Parameters:
   n - input - the element to be zeroed out */

dcl	n		fixed bin;

	groups (n).devices$ = 0;
	groups (n).misc_dollars = 0;
	groups (n).disk = 0;
	groups (n).interactive = 0;
	groups (n).absentee = 0;
	groups (n).iod = 0;
	groups (n).total = 0;
     end initial;

add_bins:
     proc (out, in, daily, P);

/* This procedure takes data from one bin of use_totals and adds it to one element of groups
   plus calculates the charges for those items that use the "get_prices" charges.
   Parameters:
   out -input - the element of groups to to the data
   in - input - the bin from which data comes
   daily - input - is this daily or monthly report?
   P - input - is the prices for the rate to be used for bin "in"
*/

dcl	(out, in)		fixed bin,
	daily		bit (1);
dcl	1 P,					/* all the prices for one rate structure */
	  2 rs_name	char (32),		/* name for this rate */
	  2 abs_cpu_rates	(1:4) float bin,		/* installation price for absentee cpu time ($/hr) */
	  2 abs_memory_rates
			(1:4) float bin,		/* installation price for absentee memory usage ($/Kmu) */
	  2 connect_rates	(0:7) float bin,		/* installation price for terminal connect time ($/hr) */
	  2 memory_rates	(0:7) float bin,		/* installation price for memory usage ($/Kmu) */
	  2 disk_rates	float bin,		/* installation price for disk storage ($/page-sec) */
	  2 cpu_rates	(0:7) float bin,		/* installation price for interactive cpu time ($/hr) */
	  2 lines_rates	(1:4) float bin,		/* installation price for line printer lines ($/K-lines) */
	  2 ioops_rates	(0:7) float bin,		/* installation price for I/O operations ($/K) */
	  2 reg_rates	float bin,		/* user registration charge ($/month) */
	  2 device_table	aligned,
	    3 ndevices	fixed bin,		/* number of devices used */
	    3 dvt		(16),
	      4 device_id	char (8),
	      4 device_rates
			(0:7) float bin;		/* $/hr */

/* add the data from current use_totals */
	groups (out).projects = groups (out).projects + use_totals.ut (in).nproj;
	groups (out).users = groups (out).users + use_totals.ut (in).nusers;
	groups (out).devices$ = groups (out).devices$ + sum (use_totals.ut (in).devices (*));
	groups (out).misc_dollars = groups (out).misc_dollars + use_totals.ut (in).misc;
	groups (out).disk.page_days = groups (out).disk.page_days + use_totals.ut (in).disk_psec;
	groups (out).disk.page_days$ = groups (out).disk.page_days$ + P.disk_rates * use_totals.ut (in).disk_psec;
	groups (out).disk.quota = groups (out).disk.quota + use_totals.ut (in).disk_quota;
	groups (out).disk.usage = groups (out).disk.usage + use_totals.ut (in).disk_usage;
	groups (out).interactive.shifts (*).cpu =
	     groups (out).interactive.shifts (*).cpu + use_totals.ut (in).interactive (*).cpu;
	groups (out).interactive.shifts (*).cpu_dollars =
	     groups (out).interactive.shifts (*).cpu_dollars
	     + P.cpu_rates (*) * use_totals.ut (in).interactive (*).cpu / 3.6e9;
	groups (out).interactive.shifts (*).memory =
	     groups (out).interactive.shifts (*).memory + use_totals.ut (in).interactive (*).core;
	groups (out).interactive.shifts (*).memory_dollars =
	     groups (out).interactive.shifts (*).memory_dollars
	     + P.memory_rates (*) * use_totals.ut (in).interactive (*).core / 1e6;
	groups (out).interactive.shifts (*).connect =
	     groups (out).interactive.shifts (*).connect + use_totals.ut (in).interactive (*).connect;
	groups (out).interactive.shifts (*).ioops =
	     groups (out).interactive.shifts (*).ioops + use_totals.ut (in).interactive (*).io_ops;
	groups (out).interactive.shifts (*).ioops_dollars =
	     groups (out).interactive.shifts (*).ioops_dollars
	     + P.ioops_rates (*) * use_totals.ut (in).interactive (*).io_ops;
	groups (out).interactive.shifts (*).total_dollars =
	     groups (out).interactive.shifts (*).total_dollars + use_totals.ut (in).interactive (*).charge;
	groups (out).interactive.sessions = groups (out).interactive.sessions + use_totals.ut (in).logins;
	groups (out).absentee.queues (*).cpu =
	     groups (out).absentee.queues (*).cpu + use_totals.ut (in).absentee (*).cpu;
	groups (out).absentee.queues (*).cpu_dollars =
	     groups (out).absentee.queues (*).cpu_dollars
	     + P.abs_cpu_rates (*) * use_totals.ut (in).absentee (*).cpu / 3.6e9;
	groups (out).absentee.queues (*).memory =
	     groups (out).absentee.queues (*).memory + use_totals.ut (in).absentee (*).memory;
	groups (out).absentee.queues (*).memory_dollars =
	     groups (out).absentee.queues (*).memory_dollars
	     + P.abs_memory_rates (*) * use_totals.ut (in).absentee (*).memory / 1e6;
	groups (out).absentee.queues (*).jobs =
	     groups (out).absentee.queues (*).jobs + use_totals.ut (in).absentee (*).jobs;
	groups (out).absentee.queues (*).total_dollars =
	     groups (out).absentee.queues (*).total_dollars + use_totals.ut (in).absentee (*).charge;
	groups (out).iod.queues (*).lines = groups (out).iod.queues (*).lines + use_totals.ut (in).iod (*).lines;
	groups (out).iod.queues (*).lines_dollars =
	     groups (out).iod.queues (*).lines_dollars + P.lines_rates (*) * use_totals.ut (in).iod (*).lines / 1e3;
	groups (out).total.today_dollars =
	     groups (out).total.today_dollars + use_totals.ut (in).dollar_charge + use_totals.ut (in).misc;
	groups (out).total.month_dollars =
	     groups (out).total.month_dollars + use_totals.ut (in).dollar_charge + use_totals.ut (in).misc;

/* for daily report, subtract off data from old use_totals */
	if daily
	then do;
		groups (out).devices$ = groups (out).devices$ - sum (xtotp -> use_totals.ut (in).devices (*));
		groups (out).misc_dollars = groups (out).misc_dollars - xtotp -> use_totals.ut (in).misc;
		groups (out).disk.page_days = groups (out).disk.page_days - xtotp -> use_totals.ut (in).disk_psec;
		groups (out).disk.page_days$ =
		     groups (out).disk.page_days$ - P.disk_rates * xtotp -> use_totals.ut (in).disk_psec;
		groups (out).interactive.shifts (*).cpu =
		     groups (out).interactive.shifts (*).cpu - xtotp -> use_totals.ut (in).interactive (*).cpu;
		groups (out).interactive.shifts (*).cpu_dollars =
		     groups (out).interactive.shifts (*).cpu_dollars
		     - P.cpu_rates (*) * xtotp -> use_totals.ut (in).interactive (*).cpu / 3.6e9;
		groups (out).interactive.shifts (*).memory =
		     groups (out).interactive.shifts (*).memory - xtotp -> use_totals.ut (in).interactive (*).core;
		groups (out).interactive.shifts (*).memory_dollars =
		     groups (out).interactive.shifts (*).memory_dollars
		     - P.memory_rates (*) * xtotp -> use_totals.ut (in).interactive (*).core / 1e6;
		groups (out).interactive.shifts (*).connect =
		     groups (out).interactive.shifts (*).connect
		     - xtotp -> use_totals.ut (in).interactive (*).connect;
		groups (out).interactive.shifts (*).ioops =
		     groups (out).interactive.shifts (*).ioops - xtotp -> use_totals.ut (in).interactive (*).io_ops;
		groups (out).interactive.shifts (*).ioops_dollars =
		     groups (out).interactive.shifts (*).ioops_dollars
		     - P.ioops_rates (*) * xtotp -> use_totals.ut (in).interactive (*).io_ops;
		groups (out).interactive.shifts (*).total_dollars =
		     groups (out).interactive.shifts (*).total_dollars
		     - xtotp -> use_totals.ut (in).interactive (*).charge;
		groups (out).interactive.sessions =
		     groups (out).interactive.sessions - xtotp -> use_totals.ut (in).logins;
		groups (out).absentee.queues (*).cpu =
		     groups (out).absentee.queues (*).cpu - xtotp -> use_totals.ut (in).absentee (*).cpu;
		groups (out).absentee.queues (*).cpu_dollars =
		     groups (out).absentee.queues (*).cpu_dollars
		     - P.abs_cpu_rates (*) * xtotp -> use_totals.ut (in).absentee (*).cpu / 3.6e9;
		groups (out).absentee.queues (*).memory =
		     groups (out).absentee.queues (*).memory - xtotp -> use_totals.ut (in).absentee (*).memory;
		groups (out).absentee.queues (*).memory_dollars =
		     groups (out).absentee.queues (*).memory_dollars
		     - P.abs_memory_rates (*) * xtotp -> use_totals.ut (in).absentee (*).memory / 1e6;
		groups (out).absentee.queues (*).jobs =
		     groups (out).absentee.queues (*).jobs - xtotp -> use_totals.ut (in).absentee (*).jobs;
		groups (out).absentee.queues (*).total_dollars =
		     groups (out).absentee.queues (*).total_dollars - xtotp -> use_totals.ut (in).absentee (*).charge;
		groups (out).iod.queues (*).lines =
		     groups (out).iod.queues (*).lines - xtotp -> use_totals.ut (in).iod (*).lines;
		groups (out).iod.queues (*).lines_dollars =
		     groups (out).iod.queues (*).lines_dollars
		     - P.lines_rates (*) * xtotp -> use_totals.ut (in).iod (*).lines / 1e3;
		groups (out).total.today_dollars =
		     groups (out).total.today_dollars - xtotp -> use_totals.ut (in).dollar_charge
		     - xtotp -> use_totals.ut (in).misc;
	     end;
     end add_bins;

conversions_and_sums:
     proc;

/* This procedure adds up totals, makes units conversions, calculates the breakdown of charges,
   calculates some averages, and "rounds" everything for printing.
   Parameters:
   all parameters are input */

dcl	(i, j)		fixed bin;

/* first get the totals for all shifts, all queues, etc. */
	do i = 1 to ngroups;
	     groups (i).interactive.total.cpu = sum (groups (i).interactive.shifts (*).cpu);
	     groups (i).interactive.total.memory = sum (groups (i).interactive.shifts (*).memory);
	     groups (i).interactive.total.connect = sum (groups (i).interactive.shifts (*).connect);
	     groups (i).interactive.total.ioops = sum (groups (i).interactive.shifts (*).ioops);
	     groups (i).interactive.total.total_dollars = sum (groups (i).interactive.shifts (*).total_dollars);
	     groups (i).absentee.total.cpu = sum (groups (i).absentee.queues (*).cpu);
	     groups (i).absentee.total.memory = sum (groups (i).absentee.queues (*).memory);
	     groups (i).absentee.total.jobs = sum (groups (i).absentee.queues (*).jobs);
	     groups (i).absentee.total.total_dollars = sum (groups (i).absentee.queues (*).total_dollars);
	     groups (i).iod.total.lines = sum (groups (i).iod.queues (*).lines);
	end;

/* now make units conversions.  Convert cpu and connect time from microseconds to hours,
   memory from milli-mu to kmu, and page-seconds to page-days */
	groups (*).disk.page_days = groups (*).disk.page_days / (60 * 60 * 24);
	groups (*).interactive.shifts (*).cpu = groups (*).interactive.shifts (*).cpu / 3.6e9;
	groups (*).interactive.total.cpu = groups (*).interactive.total.cpu / 3.6e9;
	groups (*).interactive.shifts (*).connect = groups (*).interactive.shifts (*).connect / 3.6e9;
	groups (*).interactive.total.connect = groups (*).interactive.total.connect / 3.6e9;
	groups (*).interactive.shifts (*).memory = groups (*).interactive.shifts (*).memory / 1e6;
	groups (*).interactive.total.memory = groups (*).interactive.total.memory / 1e6;
	groups (*).absentee.queues (*).cpu = groups (*).absentee.queues (*).cpu / 3.6e9;
	groups (*).absentee.total.cpu = groups (*).absentee.total.cpu / 3.6e9;
	groups (*).absentee.queues (*).memory = groups (*).absentee.queues (*).memory / 1e6;
	groups (*).absentee.total.memory = groups (*).absentee.total.memory / 1e6;
	groups (*).total.cpu = groups (*).total.cpu / 3.6e9;
	groups (*).total.memory = groups (*).total.memory / 1e6;

/* now calculate the remaining breakdown of charges (those not done by add_bins) */
/* note that because consoleless daemons have connect usage, but do not have
   connect charges, connect charges are not simply usage*rates.  connect charges are
   therefore calculated by subtracting all other interactive charges from the total
   interactive charges */

	do i = 1 to ngroups;
	     groups (i).interactive.total.cpu_dollars = sum (groups (i).interactive.shifts (*).cpu_dollars);
	     groups (i).interactive.total.memory_dollars = sum (groups (i).interactive.shifts (*).memory_dollars);
	     groups (i).interactive.total.ioops_dollars = sum (groups (i).interactive.shifts (*).ioops_dollars);
	     groups (i).interactive.shifts (*).connect_dollars =
		groups (i).interactive.shifts (*).total_dollars - groups (i).interactive.shifts (*).cpu_dollars
		- groups (i).interactive.shifts (*).memory_dollars - groups (i).interactive.shifts (*).ioops_dollars;
	     groups (i).interactive.total.connect_dollars =
		groups (i).interactive.total.total_dollars - groups (i).interactive.total.cpu_dollars
		- groups (i).interactive.total.memory_dollars - groups (i).interactive.total.ioops_dollars;
	     groups (i).absentee.total.cpu_dollars = sum (groups (i).absentee.queues (*).cpu_dollars);
	     groups (i).absentee.total.memory_dollars = sum (groups (i).absentee.queues (*).memory_dollars);
	     groups (i).iod.total.lines_dollars = sum (groups (i).iod.queues (*).lines_dollars);
	end;

/* now get a few more totals */
	groups (*).total.cpu = groups (*).interactive.total.cpu + groups (*).absentee.total.cpu;
	groups (*).total.cpu_dollars = groups (*).interactive.total.cpu_dollars + groups (*).absentee.total.cpu_dollars;
	groups (*).total.memory = groups (*).interactive.total.memory + groups (*).absentee.total.memory;
	groups (*).total.memory_dollars =
	     groups (*).interactive.total.memory_dollars + groups (*).absentee.total.memory_dollars;

/* calculate a few averages, being careful to avoid zerodivide */
	do i = 1 to ngroups;
	     do j = 0 to 7;
		if groups (i).interactive.shifts (j).connect > 0
		then do;
			groups (i).interactive.shifts (j).dollars_per_hour =
			     groups (i).interactive.shifts (j).total_dollars
			     / groups (i).interactive.shifts (j).connect;
			groups (i).interactive.total.dollars_per_hour =
			     groups (i).interactive.total.total_dollars / groups (i).interactive.total.connect;
		     end;
	     end;
	     if groups (i).interactive.sessions > 0
	     then do;
		     groups (i).interactive.dollars_per_session =
			groups (i).interactive.total.total_dollars / groups (i).interactive.sessions;
		     groups (i).interactive.hours_per_session =
			groups (i).interactive.total.connect / groups (i).interactive.sessions;
		end;
	     do j = 1 to 4;
		if groups (i).absentee.queues (j).jobs > 0
		then groups (i).absentee.queues (j).dollars_per_job =
			groups (i).absentee.queues (j).total_dollars / groups (i).absentee.queues (j).jobs;
	     end;
	     if groups (i).absentee.total.jobs > 0
	     then groups (i).absentee.total.dollars_per_job =
		     groups (i).absentee.total.total_dollars / groups (i).absentee.total.jobs;
	end;

/* "Round" */
	groups (*).devices$ = groups (*).devices$ + sign (groups (*).devices$) * 5e-3;
	groups (*).misc_dollars = groups (*).misc_dollars + sign (groups (*).misc_dollars) * 5e-3;
	groups (*).interactive = groups (*).interactive + sign (groups (*).interactive) * 5e-3;
	groups (*).disk = groups (*).disk + sign (groups (*).disk) * 5e-3;
	groups (*).absentee = groups (*).absentee + sign (groups (*).absentee) * 5e-3;
	groups (*).iod = groups (*).iod + sign (groups (*).iod) * 5e-3;
	groups (*).total = groups (*).total + sign (groups (*).total) * 5e-3;
	groups (*).disk.page_days = groups (*).disk.page_days + sign (groups (*).disk.page_days) * .495e0;

/* et voil'a, ready to be printed */
     end conversions_and_sums;

revenue_summary:
     proc (daily, titles);

/* This procedure prints the Revenue Summary portion of the report.
   Parameters:
   daily - input - "1"b if daily report, "0"b if monthly report
   titles - input - the titles to be printed at beginning of report */
dcl	i		fixed bin,
	daily		bit (1);
dcl	1 titles,					/* Titles for 1st page */
	  2 company	char (120),		/* Company name, double spaced */
	  2 dept		char (120),		/* department name, double spaced */
	  2 report_title	char (50),		/* ...usage and revenue report */
	  2 time_span	char (42),		/* For mm/dd/yy hhmm dddto mm/dd/yy hhmm ddd */
	  2 system	char (24);		/* Current System: xxx */
dcl	usage		format;			/* this is used to select the formats for either the daily or monthly report */

/* formats for monthly report */
f1:
	format (skip, col (20), a (7), x (9), a (3), x (8), a (6), x (5), a (8), x (8), a (4), x (8), a (4), x (35),
	     a (5));
f2:
	format (skip, col (21), a (5), x (9), a (5), x (9), a (3), x (9), a (3), x (8), a (7), x (4), a (9), x (6),
	     a (7), x (8), a (5), x (6), a (7));
f3:
	format (skip, col (2), a (5), x (7), 3 p "zz,zzz,zz9.v99", 3 p "z,zzz,zzz,zz9v");
f4:
	format (skip, col (2), a (8), x (4), 9 p "--,---,--9.v99");

/* formats for daily report */
f5:
	format (skip, col (18), a (7), x (8), a (3), x (7), a (6), x (4), a (8), x (7), a (4), x (7), a (4), x (32),
	     a (5), x (7), a (5));
f6:
	format (skip, col (19), a (5), x (8), a (5), x (8), a (3), x (8), a (3), x (7), a (7), x (3), a (9), x (5),
	     a (7), x (7), a (5), x (5), a (7), x (5), a (7));
f7:
	format (skip, col (2), a (5), x (6), 3 p "z,zzz,zz9.v99", 3 p "zzzz,zzz,zz9v");
f8:
	format (skip, col (2), a (8), x (3), 10 p "-,---,--9.v99");


/* print titles for 1st page */
	call print_centered (23 - 2 * ngroups, titles.company);
	call print_centered (2, titles.dept);
	call print_centered (2, titles.report_title);
	call print_centered (2, titles.time_span);
	call print_centered (2, titles.system);
	call print_centered (2, "R__e_v_e_n_u_e S__u_m_m_a_r_y");
	if daily
	then do;					/* assign formats and print headers for daily report */
		usage = f7;
		put skip (2) edit ("Connect", "CPU", "Memory", "Terminal", "Unit", "Disk", "Total", "Month") (r (f5));
		put edit ("Hours", "Hours", "Kmu", "I/O", "Records", "Page-Days", "Devices", "Misc.", "Charges",
		     "Charges") (r (f6));
	     end;
	else do;					/* assign formats and print headers for monthly report */
		usage = f3;
		put skip (2) edit ("Connect", "CPU", "Memory", "Terminal", "Unit", "Disk", "Total") (r (f1));
		put edit ("Hours", "Hours", "Kmu", "I/O", "Records", "Page-Days", "Devices", "Misc.", "Charges")
		     (r (f2));
	     end;
	do i = 1 to ngroups;
	     put edit (groups (i).title) (skip (2), a);
	     put edit ("Usage", groups (i).total.connect, groups (i).total.cpu, groups (i).total.memory,
		groups (i).interactive.total.ioops, groups (i).iod.total.lines, groups (i).disk.page_days) (r (usage))
		;
	     if daily
	     then put edit ("$Charges", groups (i).total.connect_dollars, groups (i).total.cpu_dollars,
		     groups (i).total.memory_dollars, groups (i).interactive.total.ioops_dollars,
		     groups (i).iod.total.lines_dollars, groups (i).disk.page_days$, groups (i).devices$,
		     groups (i).misc_dollars, groups (i).total.today_dollars, groups (i).total.month_dollars) (r (f8))
		     ;
	     else put edit ("$Charges", groups (i).total.connect_dollars, groups (i).total.cpu_dollars,
		     groups (i).total.memory_dollars, groups (i).interactive.total.ioops_dollars,
		     groups (i).iod.total.lines_dollars, groups (i).disk.page_days$, groups (i).devices$,
		     groups (i).misc_dollars, groups (i).total.today_dollars) (r (f4));
	end;
     end revenue_summary;

interactive_summary:
     proc (short_date);

/* This procedure prints the Interactive Summary portion of the report.
   Parameter:
   short_date - input - the date to be printed at top of each page */
dcl	shift_used	(0:7) fixed bin;
dcl	nshifts		fixed bin;
dcl	short_date	char (8);
dcl	i		fixed bin,
	shift_names	(0:7) char (8)
			init ("Shift 0:", "Shift 1:", "Shift 2:", "Shift 3:", "Shift 4:", "Shift 5:", "Shift 6:",
			"Shift 7:");

f0:
	format (page, a (8), col (127), a (4), p "z9");
f1:
	format (skip, x (76 - 6 * ngroups), 9 a (12));
f2:
	format (skip (2), x (56 - 6 * ngroups), a (8), x (2), a (10), 9 p "z,zzz,zz9.v99");
f3:
	format (skip, x (66 - 6 * ngroups), a (10), 9 p "-,---,--9.v99");
f4:
	format (skip (2), x (56 - 6 * ngroups), a (8), x (2), a (10), 9 p "zzzz,zzz,zz9v");
f5:
	format (skip, x (66 - 6 * ngroups), a (10), 9 p "----,---,--9v");

	shift_used = 0;
	do i = 0 to 7;
	     if sum (groups (*).interactive.shifts (i).cpu) > 0
	     then shift_used (i) = 1;
	end;
	nshifts = sum (shift_used);
	if nshifts > 0
	then do;
		put file (sysprint) edit (short_date, "Page", pageno (sysprint)) (r (f0));
		call print_centered (1, "I__n_t_e_r_a_c_t_i_v_e S__u_m_m_a_r_y:_ C_P_U_ H__o_u_r_s");
		put file (sysprint) edit (groups (*).title_line_1) (skip, r (f1));
		put file (sysprint) edit (groups (*).title_line_2) (r (f1));
		do i = 0 to 7;
		     if shift_used (i) > 0
		     then put file (sysprint)
			     edit (shift_names (i), "Usage", groups (*).interactive.shifts (i).cpu) (r (f2))
			     ("$Charges", groups (*).interactive.shifts (i).cpu_dollars) (r (f3));
		end;
		put file (sysprint)
		     edit ("Total:", "Usage", groups (*).interactive.total.cpu) (r (f2))
		     ("$Charges", groups (*).interactive.total.cpu_dollars) (r (f3));
	     end;
	shift_used = 0;
	do i = 0 to 7;
	     if sum (groups (*).interactive.shifts (i).connect) > 0
	     then shift_used (i) = 1;
	end;
	nshifts = sum (shift_used);
	if nshifts > 0
	then do;
		if lineno (sysprint) > 50 - 3 * nshifts
		then put file (sysprint) edit (short_date, "Page", pageno (sysprint)) (r (f0));
		else put file (sysprint) skip (3);
		call print_centered (1, "I__n_t_e_r_a_c_t_i_v_e S__u_m_m_a_r_y:_ C__o_n_n_e_c_t H__o_u_r_s");
		put file (sysprint) edit (groups (*).title_line_1) (skip, r (f1));
		put file (sysprint) edit (groups (*).title_line_2) (r (f1));
		do i = 0 to 7;
		     if shift_used (i) > 0
		     then put file (sysprint)
			     edit (shift_names (i), "Usage", groups (*).interactive.shifts (i).connect) (r (f2))
			     ("$Charges", groups (*).interactive.shifts (i).connect_dollars) (r (f3));
		end;
		put file (sysprint)
		     edit ("Total:", "Usage", groups (*).interactive.total.connect) (r (f2))
		     ("$Charges", groups (*).interactive.total.connect_dollars) (r (f3));
	     end;
	shift_used = 0;
	do i = 0 to 7;
	     if sum (groups (*).interactive.shifts (i).memory) > 0
	     then shift_used (i) = 1;
	end;
	nshifts = sum (shift_used);
	if nshifts > 0
	then do;
		if lineno (sysprint) > 50 - 3 * nshifts
		then put file (sysprint) edit (short_date, "Page", pageno (sysprint)) (r (f0));
		else put file (sysprint) skip (3);
		call print_centered (1, "I__n_t_e_r_a_c_t_i_v_e S__u_m_m_a_r_y:_ M__e_m_o_r_y K__m_u");
		put file (sysprint) edit (groups (*).title_line_1) (skip, r (f1));
		put file (sysprint) edit (groups (*).title_line_2) (r (f1));
		do i = 0 to 7;
		     if shift_used (i) > 0
		     then put file (sysprint)
			     edit (shift_names (i), "Usage", groups (*).interactive.shifts (i).memory) (r (f2))
			     ("$Charges", groups (*).interactive.shifts (i).memory_dollars) (r (f3));
		end;
		put file (sysprint)
		     edit ("Total:", "Usage", groups (*).interactive.total.memory) (r (f2))
		     ("$Charges", groups (*).interactive.total.memory_dollars) (r (f3));
	     end;
	shift_used = 0;
	do i = 0 to 7;
	     if sum (groups (*).interactive.shifts (i).ioops) > 0
	     then shift_used (i) = 1;
	end;
	nshifts = sum (shift_used);
	if nshifts > 0
	then do;
		if lineno (sysprint) > 50 - 3 * nshifts
		then put file (sysprint) edit (short_date, "Page", pageno (sysprint)) (r (f0));
		else put file (sysprint) skip (3);
		call print_centered (1, "I__n_t_e_r_a_c_t_i_v_e S__u_m_m_a_r_y:_ T__e_r_m_i_n_a_l I_/_O_");
		put file (sysprint) edit (groups (*).title_line_1) (skip, r (f1));
		put file (sysprint) edit (groups (*).title_line_2) (r (f1));
		do i = 0 to 7;
		     if shift_used (i) > 0
		     then put file (sysprint)
			     edit (shift_names (i), "Usage", groups (*).interactive.shifts (i).ioops) (r (f4))
			     ("$Charges", groups (*).interactive.shifts (i).ioops_dollars) (r (f3));
		end;
		put file (sysprint)
		     edit ("Total:", "Usage", groups (*).interactive.total.ioops) (r (f2))
		     ("$Charges", groups (*).interactive.total.ioops_dollars) (r (f3));
	     end;
	shift_used = 0;
	do i = 0 to 7;
	     if sum (groups (*).interactive.shifts (i).total_dollars) > 0
	     then shift_used (i) = 1;
	end;
	nshifts = sum (shift_used);
	if nshifts > 0
	then do;
		if lineno (sysprint) > 47 - 3 * nshifts
		then put file (sysprint) edit (short_date, "Page", pageno (sysprint)) (r (f0));
		else put file (sysprint) skip (3);
		call print_centered (1, "I__n_t_e_r_a_c_t_i_v_e S__u_m_m_a_r_y: T__o_t_a_l I__n_t_e_r_a_c_t_i_v_e C__h_a_r_g_e_s");
		put file (sysprint) edit (groups (*).title_line_1) (skip, r (f1));
		put file (sysprint) edit (groups (*).title_line_2) (r (f1));
		do i = 0 to 7;
		     if shift_used (i) > 0
		     then put file (sysprint)
			     edit (shift_names (i), "$Charges", groups (*).interactive.shifts (i).total_dollars)
			     (r (f2)) ("$/Hour", groups (*).interactive.shifts (i).dollars_per_hour) (r (f3));
		end;
		put file (sysprint)
		     edit ("Total:", "$Charges", groups (*).interactive.total.total_dollars) (r (f2))
		     ("$/Hour", groups (*).interactive.total.dollars_per_hour) (r (f3))
		     ("Sessions", groups (*).interactive.sessions) (r (f5))
		     ("$/Session", groups (*).interactive.dollars_per_session) (r (f3))
		     ("Hr/Session", groups (*).interactive.hours_per_session) (r (f3));
	     end;
     end interactive_summary;

absentee_summary:
     proc (short_date);

/* this procedure prints the Absentee Summary portion of the report.
   Parameter:
   short_date - input - the date to print at top of each page */
dcl	short_date	char (8);
dcl	queue_used	(4) fixed bin;
dcl	nqueues		fixed bin;
dcl	i		fixed bin,
	queue_names	(4) char (8) init ("Queue 1:", "Queue 2:", "Queue 3:", "Queue 4:");

f0:
	format (page, a (8), col (127), a (4), p "z9");
f1:
	format (skip, x (76 - 6 * ngroups), 9 a (12));
f2:
	format (skip (2), x (56 - 6 * ngroups), a (8), x (2), a (10), 9 p "z,zzz,zz9.v99");
f3:
	format (skip, x (66 - 6 * ngroups), a (10), 9 p "-,---,--9.v99");
f4:
	format (skip (2), x (56 - 6 * ngroups), a (8), x (2), a (10), 9 p "zzzz,zzz,zz9v");
f5:
	format (skip, x (66 - 6 * ngroups), a (10), 9 p "----,---,--9v");

	queue_used = 0;
	do i = 1 to 4;
	     if sum (groups (*).absentee.queues (i).cpu) > 0
	     then queue_used (i) = 1;
	end;
	nqueues = sum (queue_used);
	if nqueues > 0
	then do;
		put file (sysprint) edit (short_date, "Page", pageno (sysprint)) (r (f0));
		call print_centered (1, "A__b_s_e_n_t_e_e S__u_m_m_a_r_y:_ C_P_U_ H__o_u_r_s");
		put file (sysprint) edit (groups (*).title_line_1) (skip, r (f1));
		put file (sysprint) edit (groups (*).title_line_2) (r (f1));
		do i = 1 to 4;
		     if queue_used (i) > 0
		     then put file (sysprint)
			     edit (queue_names (i), "Usage", groups (*).absentee.queues (i).cpu) (r (f2))
			     ("$Charges", groups (*).absentee.queues (i).cpu_dollars) (r (f3));
		end;
		put file (sysprint)
		     edit ("Total:", "Usage", groups (*).absentee.total.cpu) (r (f2))
		     ("$Charges", groups (*).absentee.total.cpu_dollars) (r (f3));
	     end;
	queue_used = 0;
	do i = 1 to 4;
	     if sum (groups (*).absentee.queues (i).memory) > 0
	     then queue_used (i) = 1;
	end;
	nqueues = sum (queue_used);
	if nqueues > 0
	then do;
		if lineno (sysprint) > 50 - 3 * nqueues
		then put file (sysprint) edit (short_date, "Page", pageno (sysprint)) (r (f0));
		else put file (sysprint) skip (3);
		call print_centered (1, "A__b_s_e_n_t_e_e S__u_m_m_a_r_y:_ M__e_m_o_r_y K__m_u");
		put file (sysprint) edit (groups (*).title_line_1) (skip, r (f1));
		put file (sysprint) edit (groups (*).title_line_2) (r (f1));
		do i = 1 to 4;
		     if queue_used (i) > 0
		     then put file (sysprint)
			     edit (queue_names (i), "Usage", groups (*).absentee.queues (i).memory) (r (f2))
			     ("$Charges", groups (*).absentee.queues (i).memory_dollars) (r (f3));
		end;
		put file (sysprint)
		     edit ("Total", "Usage", groups (*).absentee.total.memory) (r (f2))
		     ("$Charges", groups (*).absentee.total.memory_dollars) (r (f3));
	     end;
	do i = 1 to 4;
	     if sum (groups (*).absentee.queues (i).total_dollars) > 0
	     then queue_used (i) = 1;
	end;
	nqueues = sum (queue_used);
	if nqueues > 0
	then do;
		if lineno (sysprint) > 49 - 3 * nqueues
		then put file (sysprint) edit (short_date, "Page", pageno (sysprint)) (r (f0));
		else put file (sysprint) skip (3);
		call print_centered (1, "A__b_s_e_n_t_e_e S__u_m_m_a_r_y: T__o_t_a_l A__b_s_e_n_t_e_e C__h_a_r_g_e_s");
		put file (sysprint) edit (groups (*).title_line_1) (skip, r (f1));
		put file (sysprint) edit (groups (*).title_line_2) (r (f1));
		do i = 1 to 4;
		     if queue_used (i) > 0
		     then put file (sysprint)
			     edit (queue_names (i), "$Charges", groups (*).absentee.queues (i).total_dollars)
			     (r (f2)) ("Jobs", groups (*).absentee.queues (i).jobs) (r (f5))
			     ("$/Job", groups (*).absentee.queues (i).dollars_per_job) (r (f3));
		end;
		put file (sysprint)
		     edit ("Total:", "$Charges", groups (*).absentee.total.total_dollars) (r (f2))
		     ("Jobs", groups (*).absentee.total.jobs) (r (f5))
		     ("$/Job", groups (*).absentee.total.dollars_per_job) (r (f3));
	     end;
     end absentee_summary;

iod_summary:
     proc (short_date);

/* This procedure prints the IO Daemon Summary portion of the report.
   Parameter:
   short_date - input - the date to be printed at top of each page */
dcl	queue_used	(4) fixed bin;
dcl	nqueues		fixed bin;
dcl	short_date	char (8);
dcl	i		fixed bin,
	queue_names	(4) char (8) init ("Queue 1:", "Queue 2:", "Queue 3:", "Queue 4:");

f0:
	format (page, a (8), col (127), a (4), p "z9");
f1:
	format (skip, x (76 - 6 * ngroups), 9 a (12));
f2:
	format (skip (2), x (56 - 6 * ngroups), a (8), x (2), a (10), 9 p "z,zzz,zz9.v99");
f3:
	format (skip, x (66 - 6 * ngroups), a (10), 9 p "-,---,--9.v99");
f4:
	format (skip (2), x (56 - 6 * ngroups), a (8), x (2), a (10), 9 p "zzzz,zzz,zz9v");
f5:
	format (skip, x (66 - 6 * ngroups), a (10), 9 p "----,---,--9v");

	queue_used = 0;
	do i = 1 to 4;
	     if sum (groups (*).iod.queues (i).lines) > 0
	     then queue_used (i) = 1;
	end;
	nqueues = sum (queue_used);
	if nqueues > 0
	then do;
		put file (sysprint) edit (short_date, "Page", pageno (sysprint)) (r (f0));
		call print_centered (1, "I_/_O_ D__a_e_m_o_n S__u_m_m_a_r_y:_ L__i_n_e_s");
		put file (sysprint) edit (groups (*).title_line_1) (skip, r (f1));
		put file (sysprint) edit (groups (*).title_line_2) (r (f1));
		do i = 1 to 4;
		     if queue_used (i) > 0
		     then put file (sysprint)
			     edit (queue_names (i), "Usage", groups (*).iod.queues (i).lines) (r (f4))
			     ("$Charges", groups (*).iod.queues (i).lines_dollars) (r (f3));
		end;
		put file (sysprint)
		     edit ("Total:", "Usage", groups (*).iod.total.lines) (r (f4))
		     ("$Charges", groups (*).iod.total.lines_dollars) (r (f3));
	     end;
     end iod_summary;

system_stats:
     proc (daily, short_date);

/* This procedure extracts system usage info from use_totals and prints the System Statistics
   portion of the report.
   Parameters:
   daily - input - "1"b if daily report, "0"b if monthly
   short_date - input - date to be printed at top of pages */
dcl	(day_units, total_units)
			float bin,
	(i, j)		fixed bin,
	daily		bit (1),
	short_date	char (8);
dcl	days		float bin,
	(xcpu, xmem)	fixed bin;
dcl	1 sys_stats	(3),			/* today,average,month */
	( 2 starts,
	  2 crashes,
	  2 mtbf,
	  2 hrs_avail,
	  2 cpu_avail,
	  2 two_cpu,
	  2 cpu_billed,
	  2 overhead,
	  2 idle,
	  2 zidle,
	  2 mpidle,
	  2 nmpidle,
	  2 max_units,
	  2 reconfigs
	  )		float bin;

/* daily formats */
f0:
	format (skip (2), col (76), a (5), x (6), a (5));
f1:
	format (skip, x (40), a (29), p "zzz,zzz,zz9v", p "zzz,zzz,zz9v");
f2:
	format (skip, x (40), a (29), p "zzzz,zz9.v99", p "zzzz,zz9.v99");
f3:
	format (skip, x (42), a (27), p "zzzz,zz9.v99", p "zzzz,zz9.v99");

/* monthly formats */

f4:
	format (skip, x (40), a (29), p "zzzz,zz9.v99", p "zzz,zzz,zz9v");
f5:
	format (skip, x (40), a (29), x (11), p "zzzz,zz9.v99");
f6:
	format (skip, x (40), a (29), 2 p "zzzz,zz9.v99");
f7:
	format (skip, x (42), a (27), x (11), p "zzzz,zz9.v99");
f8:
	format (skip (3), col (75), a (5), col (74), a (7), x (6), a (5));

	sys_stats (3).starts = use_totals.sys_starts;
	sys_stats (3).crashes = use_totals.sys_crash;
	sys_stats (3).hrs_avail = use_totals.uptime;
	sys_stats (3).cpu_avail = use_totals.cpu_avail;
	sys_stats (3).cpu_billed = use_totals.total_cpu;
	sys_stats (3).idle = use_totals.idle;
	sys_stats (3).zidle = use_totals.zidle;
	sys_stats (3).mpidle = use_totals.mpidle;

	if daily
	then do;
		sys_stats (1).starts = sys_stats (3).starts - xtotp -> use_totals.sys_starts;
		sys_stats (1).crashes = sys_stats (3).crashes - xtotp -> use_totals.sys_crash;
		sys_stats (1).hrs_avail = sys_stats (3).hrs_avail - xtotp -> use_totals.uptime;
		sys_stats (1).cpu_avail = sys_stats (3).cpu_avail - xtotp -> use_totals.cpu_avail;
		sys_stats (1).cpu_billed = sys_stats (3).cpu_billed - xtotp -> use_totals.total_cpu;
		sys_stats (1).idle = sys_stats (3).idle - xtotp -> use_totals.idle;
		sys_stats (1).zidle = sys_stats (3).zidle - xtotp -> use_totals.zidle;
		sys_stats (1).mpidle = sys_stats (3).mpidle - xtotp -> use_totals.mpidle;
	     end;
	xcpu, xmem = -1;
	sys_stats (3).reconfigs = -1;
	sys_stats (1).reconfigs = 0;
	sys_stats (1).max_units, sys_stats (3).max_units = 0;
	day_units, total_units = 0;
	do i = 1 to use_totals.max_day_log;
	     do j = 1
		to 96 * bin (i ^= use_totals.max_day_log) + use_totals.max_qhour * bin (i = use_totals.max_day_log);
		if ^(use_totals.daylog (i).qh (j).cpu = xcpu & use_totals.daylog (i).qh (j).kmem = xmem)
		     & use_totals.daylog (i).qh (j).cpu ^= 0
		then do;
			sys_stats (3).reconfigs = sys_stats (3).reconfigs + 1;
			if daily
			then if use_totals.daylog (i).qh (j).time > xtotp -> use_totals.period_end
			     then sys_stats (1).reconfigs = sys_stats (1).reconfigs + 1;
			xcpu = use_totals.daylog (i).qh (j).cpu;
			xmem = use_totals.daylog (i).qh (j).kmem;
		     end;
		if daily
		then if use_totals.daylog (i).qh (j).time > xtotp -> use_totals.period_end
		     then if use_totals.daylog (i).qh (j).nunits > sys_stats (1).max_units
			then sys_stats (1).max_units = use_totals.daylog (i).qh (j).nunits;
		if use_totals.daylog (i).qh (j).nunits > sys_stats (3).max_units
		then sys_stats (3).max_units = use_totals.daylog (i).qh (j).nunits;
		if use_totals.daylog (i).qh (j).nunits > day_units
		then day_units = use_totals.daylog (i).qh (j).nunits;
	     end;
	     total_units = total_units + day_units;
	     day_units = 0;
	end;
	sys_stats (3).mtbf = sys_stats (3).hrs_avail / (sys_stats (3).crashes + 1);
	sys_stats (3).two_cpu = sys_stats (3).cpu_avail - sys_stats (3).hrs_avail;
	if daily
	then do;
		sys_stats (1).mtbf = sys_stats (1).hrs_avail / (sys_stats (1).crashes + 1);
		sys_stats (1).two_cpu = sys_stats (1).cpu_avail - sys_stats (1).hrs_avail;
	     end;
	if sys_stats (3).cpu_avail > 0
	then do;
		sys_stats (3).overhead =
		     (sys_stats (3).cpu_avail - sys_stats (3).cpu_billed - sys_stats (3).idle)
		     / sys_stats (3).cpu_avail * 100e0;
		sys_stats (3).idle = sys_stats (3).idle / sys_stats (3).cpu_avail * 100e0;
		sys_stats (3).zidle = sys_stats (3).zidle / sys_stats (3).cpu_avail * 100e0;
		sys_stats (3).mpidle = sys_stats (3).mpidle / sys_stats (3).cpu_avail * 100e0;
		sys_stats (3).nmpidle = sys_stats (3).idle - sys_stats (3).zidle - sys_stats (3).mpidle;
	     end;
	if daily
	then if sys_stats (1).cpu_avail > 0
	     then do;
		     sys_stats (1).overhead =
			(sys_stats (1).cpu_avail - sys_stats (1).cpu_billed - sys_stats (1).idle)
			/ sys_stats (1).cpu_avail * 100e0;
		     sys_stats (1).idle = sys_stats (1).idle / sys_stats (1).cpu_avail * 100e0;
		     sys_stats (1).zidle = sys_stats (1).zidle / sys_stats (1).cpu_avail * 100e0;
		     sys_stats (1).mpidle = sys_stats (1).mpidle / sys_stats (1).cpu_avail * 100e0;
		     sys_stats (1).nmpidle = sys_stats (1).idle - sys_stats (1).zidle - sys_stats (1).mpidle;
		end;
	sys_stats (3).hrs_avail = sys_stats (3).hrs_avail / 3.6e9;
	sys_stats (3).cpu_avail = sys_stats (3).cpu_avail / 3.6e9;
	sys_stats (3).cpu_billed = sys_stats (3).cpu_billed / 3.6e9;
	sys_stats (3).two_cpu = sys_stats (3).two_cpu / 3.6e9;
	sys_stats (3).mtbf = sys_stats (3).mtbf / 3.6e9;
	sys_stats (3).max_units = sys_stats (3).max_units / 10e0;
	if daily
	then do;
		sys_stats (1).hrs_avail = sys_stats (1).hrs_avail / 3.6e9;
		sys_stats (1).cpu_avail = sys_stats (1).cpu_avail / 3.6e9;
		sys_stats (1).cpu_billed = sys_stats (1).cpu_billed / 3.6e9;
		sys_stats (1).two_cpu = sys_stats (1).two_cpu / 3.6e9;
		sys_stats (1).mtbf = sys_stats (1).mtbf / 3.6e9;
		sys_stats (1).max_units = sys_stats (1).max_units / 10e0;
	     end;
	if ^daily
	then do;
		days = use_totals.period_end - use_totals.period_begin;
		days = days / 8.64e10;
		sys_stats (2).starts = sys_stats (3).starts / days;
		sys_stats (2).crashes = sys_stats (3).crashes / days;
		sys_stats (2).hrs_avail = sys_stats (3).hrs_avail / days;
		sys_stats (2).cpu_avail = sys_stats (3).cpu_avail / days;
		sys_stats (2).two_cpu = sys_stats (3).two_cpu / days;
		sys_stats (2).cpu_billed = sys_stats (3).cpu_billed / days;
		sys_stats (2).reconfigs = sys_stats (3).reconfigs / days;
		sys_stats (2).max_units = total_units / (days * 10e0);
	     end;

/* "Round" */
	sys_stats = sys_stats + 5e-3;

	put edit (short_date, "Page", pageno (sysprint)) (page, a (8), col (127), a (4), p "z9");
	if ^daily
	then put skip (6);
	call print_centered (4, "S__y_s_t_e_m P__e_r_f_o_r_m_a_n_c_e _a_n_d A__v_a_i_l_a_b_i_l_i_t_y");

	if daily
	then do;
		put edit ("Today", "Month") (r (f0));
		put skip;
		put edit ("Starts", (sys_stats (i).starts do i = 1, 3)) (r (f1));
		put edit ("Crashes", (sys_stats (i).crashes do i = 1, 3)) (r (f1));
		put edit ("Mean Time Between Failures", (sys_stats (i).mtbf do i = 1, 3)) (r (f2));
		put edit ("Hours Available", (sys_stats (i).hrs_avail do i = 1, 3)) (r (f2));
		put edit ("CPU Hours", (sys_stats (i).cpu_avail do i = 1, 3)) (r (f2));
		put edit ("Two-CPU Hours", (sys_stats (i).two_cpu do i = 1, 3)) (r (f2));
		put edit ("Virtual CPU Hours Billed", (sys_stats (i).cpu_billed do i = 1, 3)) (r (f2));
		put edit ("% CPU Overhead", (sys_stats (i).overhead do i = 1, 3)) (r (f2));
		put edit ("% Idle", (sys_stats (i).idle do i = 1, 3)) (r (f2));
		put edit ("% Zero Idle", (sys_stats (i).zidle do i = 1, 3)) (r (f3));
		put edit ("% Multiprogramming Idle", (sys_stats (i).mpidle do i = 1, 3)) (r (f3));
		put edit ("% Nonmultiprogramming Idle", (sys_stats (i).nmpidle do i = 1, 3)) (r (f3));
		put edit ("Maximum Load Units", (sys_stats (i).max_units do i = 1, 3)) (r (f2));
		put edit ("Reconfigurations", (sys_stats (i).reconfigs do i = 1, 3)) (r (f1));
	     end;
	else do;
		put edit ("Daily", "Average", "Month") (r (f8));
		put skip;
		put edit ("Starts", (sys_stats (i).starts do i = 2, 3)) (r (f4));
		put edit ("Crashes", (sys_stats (i).crashes do i = 2, 3)) (r (f4));
		put edit ("Mean Time Between Failures", sys_stats (3).mtbf) (r (f5));
		put edit ("Hours Available", (sys_stats (i).hrs_avail do i = 2, 3)) (r (f6));
		put edit ("CPU Hours", (sys_stats (i).cpu_avail do i = 2, 3)) (r (f6));
		put edit ("Two-CPU Hours", (sys_stats (i).two_cpu do i = 2, 3)) (r (f6));
		put edit ("Virtual CPU Hours Billed", (sys_stats (i).cpu_billed do i = 2, 3)) (r (f6));
		put edit ("% CPU Overhead", sys_stats (3).overhead) (r (f5));
		put edit ("% Idle", sys_stats (3).idle) (r (f5));
		put edit ("% Zero Idle", sys_stats (3).zidle) (r (f7));
		put edit ("% Multiprogramming Idle", sys_stats (3).mpidle) (r (f7));
		put edit ("% Nonmultiprogramming Idle", sys_stats (3).nmpidle) (r (f7));
		put edit ("Maximum Load Units", (sys_stats (i).max_units do i = 2, 3)) (r (f6));
		put edit ("Reconfigurations", (sys_stats (i).reconfigs do i = 2, 3)) (r (f4));
	     end;
     end system_stats;

disk_stats:
     proc ();

/* this procedure prints out the Disk Statistics portion of the report. */
dcl	i		fixed bin;

	call print_centered (3, "D__i_s_k S__t_a_t_i_s_t_i_c_s:  U__s_e _o_f >__u_d_d S__t_o_r_a_g_e");
	put edit ("Quota", "Used") (skip (2), x (73), a (5), x (7), a (4));
	put skip;
	do i = 1 to ngroups;
	     put edit (groups (i).title, groups (i).disk.quota, groups (i).disk.usage)
		(skip, x (43), a (24), 2 p "zzz,zzz,zz9v");
	end;
     end disk_stats;

times_available:
     proc;

/* This procedure extracts data from the daylog portion of use_totals and prints
   the Times Available section of the report. */
dcl	(i, j)		fixed bin,
	(from, to)	char (17),
	(lup, ldown)	char (14),
	(ctime, stime)	fixed bin (71),
	reason		char (12);

	call print_centered (3, "T__i_m_e_s A__v_a_i_l_a_b_l_e T__o_d_a_y");
	put edit ("Length of", "Length of") (skip (2), x (68), a (9), x (21), a (9));
	put edit ("From", "To", "Uptime", "Reason Down", "Downtime")
	     (skip, x (32), a (4), x (17), a (2), x (15), a (6), x (5), a (13), x (5), a (8));
	put skip;
	ctime = 0;
	do i = 1 to use_totals.max_day_log;
	     do j = 1
		to 96 * bin (i ^= use_totals.max_day_log) + use_totals.max_qhour * bin (i = use_totals.max_day_log);
		if use_totals.daylog (i).qh (j).crashtime > xtotp -> use_totals.period_end
		     & use_totals.daylog (i).qh (j).crashtime < use_totals.period_end
		     & use_totals.daylog (i).qh (j).time ^= 0
		then do;
			reason = "";
			if use_totals.daylog (i).qh (j).dump_number ^= 0
			then reason = ltrim (char (use_totals.daylog (i).qh (j).dump_number));
			else if j = 96
			then if use_totals.daylog (i + 1).qh (1).dump_number ^= 0
			     then reason = ltrim (char (use_totals.daylog (i + 1).qh (1).dump_number));
			     else ;
			else if use_totals.daylog (i).qh (j + 1).dump_number ^= 0
			then reason = ltrim (char (use_totals.daylog (i).qh (j + 1).dump_number));
			if reason ^= "shutdown" & reason ^= "crash" & reason ^= ""
			then reason = "crash #" || reason;
			if ctime > 0
			then do;
				call elapsed_time (use_totals.daylog (i).qh (j).starttime - ctime, ldown);
				put edit (ldown) (x (1), a (14));
			     end;
			ctime = use_totals.daylog (i).qh (j).crashtime;
			to = format_time (use_totals.daylog (i).qh (j).crashtime);
			from = format_time (use_totals.daylog (i).qh (j).starttime);
			call elapsed_time (use_totals.daylog (i).qh (j).crashtime
			     - use_totals.daylog (i).qh (j).starttime, lup);
			put edit (from, to, lup, reason)
			     (skip, x (26), a (17), x (3), a (17), x (1), a (14), x (3), a (12));
		     end;
	     end;
	end;
	if use_totals.daylog (max_day_log).qh (max_qhour).time > 0
	then stime = use_totals.daylog (max_day_log).qh (max_qhour).starttime;
	else stime = use_totals.period_end;
	if ctime > 0
	then do;
		call elapsed_time (stime - ctime, ldown);
		put edit (ldown) (x (1), a (14));
	     end;
	if stime > ctime
	then do;
		from = format_time (stime);
		put edit (from) (skip, x (26), a (17));
	     end;
elapsed_time:
     proc (time, string);

/* This procedure converts a time in microseconds into a character string repesenting the
   time in hours and minutes
   Parameters:
   time - input - the time in microseconds
   string - output - character representation of the time */
/* 1 min = 60,000,000 microseconds
   1 hour = 3,600,000,000 microseconds */

dcl	(time, temp, temp2) fixed bin (71),
	string		char (*),
	minutes		pic "z9",
	hours		pic "zzz9";

	if time <= 0
	then do;
		string = "";
		return;
	     end;
	temp = time;
	temp2 = divide (temp, 3600000000, 71, 0);
	hours = min (temp2, 9999);
	temp = temp - multiply (temp2, 3600000000, 71, 0);
	temp2 = divide (temp + 30000000, 60000000, 71, 0);
	minutes = temp2;
	if hours > 0
	then string = hours || " Hr " || minutes || " Min";
	else string = "        " || minutes || " Min";
     end elapsed_time;
     end times_available;

group_composition:
     proc (short_date);

/* This procedure prints out the group composition section of the report
   Parameter:
   short_date - input - date to be printed at top of each page */
dcl	(total, ll, i, j, k, m, n)
			fixed bin,
	temp		char (12),
	short_date	char (8),
	s		char (24) var,
	bin_used		(hbound (groups.bins, 2)) fixed bin init ((hbound (groups.bins, 2)) 0),
	ioa_$rsnnl	entry options (variable);

	put edit (short_date, "Page", pageno (sysprint)) (page, a (8), col (127), a (4), p "z9");
	call print_centered (1, "C__o_m_p_o_s_i_t_i_o_n _o_f _t_h_e G__r_o_u_p_s _i_n _t_h_i_s R_e__p_o_r_t");
	do i = 1 to ngroups;
	     call ioa_$rsnnl ("^a", s, m, groups (i).title);
	     put edit ("""", s, """ consists of ") (skip (2), x (30), a (1), a, a (14));
	     ll = 21 + m;
	     call ioa_$rsnnl ("^d", s, m, groups (i).projects);
	     if groups (i).projects > 1
	     then do;
		     put edit (s, " projects with ") (a, a (15));
		     ll = ll + 15 + m;
		end;
	     else do;
		     put edit (s, " project with ") (a, a (14));
		     ll = ll + 14 + m;
		end;
	     call ioa_$rsnnl ("^d", s, m, groups (i).users);
	     if groups (i).projects > 1
	     then do;
		     put edit (s, " users.  The projects are") (a, a (25));
		     ll = ll + 25 + m;
		end;
	     else do;
		     put edit (s, " users.  The project is") (a, a (23));
		     ll = ll + 23 + m;
		end;
	     total = 0;
	     do j = 1 to hbound (groups.bins, 2) while (groups (i).bins (j) > 0);
		bin_used (groups (i).bins (j)) = 1;
		n = 0;
		do k = 1 to use_totals.n_select;
		     if use_totals.select_ut (k) = groups (i).bins (j)
		     then n = n + 1;
		end;
		if n = 0
		then total = total + 1;
		else total = total + n;
	     end;
	     n = 0;
	     do j = 1 to hbound (groups.bins, 2) while (groups (i).bins (j) > 0);
		do k = 1 to use_totals.n_select;
		     if use_totals.select_ut (k) = groups (i).bins (j)
		     then do;
			     n = n + 1;
			     temp = use_totals.select_proj (k);
			     call print (n, total, ll, temp);
			end;
		end;
	     end;
	     if n < total
	     then do;
		     n = n + 1;
		     call print (n, total, ll, "all projects not otherwise specified");
		end;
	     if sum (groups (i).groups (*)) > 0
	     then do;
		     call print (n, total, ll, "those projects included in the group(s)");
		     total = 0;
		     do j = 1 to 9 while (groups (i).groups (j) > 0);
			total = total + 1;
		     end;
		     do j = 1 to 9 while (groups (i).groups (j) > 0);
			call print (j, total, ll, groups (groups (i).groups (j)).title);
		     end;
		end;
	     put edit (".") (a (1));
	end;
	if sum (bin_used) < ntypes
	then do;
		total, m, n = 0;
		do j = 1 to ntypes;
		     if bin_used (j) = 0
		     then do;
			     n = n + use_totals.ut (j).nproj;
			     m = m + use_totals.ut (j).nusers;
			     do k = 1 to use_totals.n_select;
				if use_totals.select_ut (k) = j
				then total = total + 1;
			     end;
			end;
		end;
		if n ^= 0
		then do;
			call ioa_$rsnnl ("^d", s, k, n);
			put edit (s, " projects with ") (skip (2), x (30), a, a (15));
			ll = 20 + k;
			call ioa_$rsnnl ("^d", s, k, m);
			put edit (s, " users are not included in this report.  The projects are") (a, a (57));
			ll = k + 56;
			n = 0;
			do j = 1 to ntypes;
			     if bin_used (j) = 0
			     then do;
				     n = n + 1;
				     do k = 1 to use_totals.n_select;
					if use_totals.select_ut (k) = j
					then do;
						n = n + 1;
						temp = use_totals.select_proj (k);
						call print (n, total, ll, temp);
					     end;
				     end;
				end;
			end;
			put edit (".") (a (1));
		     end;
	     end;
print:
     proc (n, total, ll, title);

/* This procedure is called to print each item in the list of projects belonging to a group.
   It determines what to put between items (, or and) and where to break lines.
   Parameters:
   n - input - the position of the item in the list
   total - input - the total number of items in the list
   ll - input,output - the column position within the current output line
   title - input - the item to be printed */

dcl	(n, total, ll)	fixed bin,
	title		char (*),
	s		char (120) var,
	m		fixed bin;

	call ioa_$rsnnl ("^a", s, m, title);
	if ll + m > 85
	then do;
		if n > 1
		then if n < total
		     then put edit (",", s) (a, skip, x (26), a);
		     else put edit (" and", s) (a, skip, x (26), a);
		else put edit (s) (skip, x (26), a);
		ll = m;
	     end;
	else do;
		if n > 1
		then if n < total
		     then put edit (", ", s) (a, a);
		     else put edit (" and ", s) (a, a);
		else put edit (s) (x (1), a);
		ll = ll + m + 2;
	     end;
     end print;
     end group_composition;

rates_and_shifts:
     proc (P, shift_table, short_date);

/* This procedure prints the Rates portion of the report.
   Parameters:
   are all input parameters */

dcl	1 P,					/* all the prices for one rate structure */
	  2 rs_name	char (32),		/* name for this rate */
	  2 abs_cpu_rates	(1:4) float bin,		/* installation price for absentee cpu time ($/hr) */
	  2 abs_memory_rates
			(1:4) float bin,		/* installation price for absentee memory usage ($/Kmu) */
	  2 connect_rates	(0:7) float bin,		/* installation price for terminal connect time ($/hr) */
	  2 memory_rates	(0:7) float bin,		/* installation price for memory usage ($/Kmu) */
	  2 disk_rates	float bin,		/* installation price for disk storage ($/page-sec) */
	  2 cpu_rates	(0:7) float bin,		/* installation price for interactive cpu time ($/hr) */
	  2 lines_rates	(1:4) float bin,		/* installation price for line printer lines ($/K-lines) */
	  2 ioops_rates	(0:7) float bin,		/* installation price for I/O operations ($/K) */
	  2 reg_rates	float bin,		/* user registration charge ($/month) */
	  2 device_table	aligned,
	    3 ndevices	fixed bin,		/* number of devices used */
	    3 dvt		(16),
	      4 device_id	char (8),
	      4 device_rates
			(0:7) float bin;		/* $/hr */
dcl	shift_table	(336) fixed bin,		/* table of shift #'s for each half hour in week */
	shifts		(7, 0:47) fixed bin def (shift_table),
	day_names		(7) char (3) init ("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"),
	(shift, start_time, end_time, day, day2, time, time2, cur_shft)
			fixed bin,
	(match, this_shift_used)
			bit (1);
dcl	nn		(4) fixed bin,
	(i, j, k, l, n)	fixed bin,
	s		char (8) var,
	yes		bit (1),
	ioa_$rsnnl	entry options (variable);
dcl	short_date	char (8);


	put edit (short_date, "Page", pageno (sysprint)) (page, a (8), col (127), a (4), p "z9");
	call print_centered (1, "The following prices are currently in effect for rate structure - " || rs_name);
	call print_centered (2, "I__n_t_e_r_a_c_t_i_v_e R__a_t_e_s");
	put edit ("CPU", "Connect", "Memory", "Terminal I/O")
	     (skip (2), x (53), a (3), x (8), a (7), x (9), a (6), x (3), a (12));
	put skip;
	do i = 0 to 7;
	     if cpu_rates (i) > 0 | memory_rates (i) > 0 | connect_rates (i) > 0 | ioops_rates (i) > 0
	     then put edit ("Shift", i, ":", cpu_rates (i) + 5e-3, "/Hr", connect_rates (i) + 5e-3, "/Hr",
		     memory_rates (i) + 5e-3, "/Kmu", ioops_rates (i) + 5e-3, "/K")
		     (skip, x (33), a (5), p "z9", a (1), 2 (p "$,$$$,$$9.v99", a (3)), p "$$$$,$$9.v99", a (4),
		     p "$$,$$$,$$9.v99", a (2));
	end;
	call print_centered (2, "A__b_s_e_n_t_e_e R__a_t_e_s");
	put edit ("CPU", "Memory") (skip (2), x (68), a (3), x (9), a (6));
	put skip;
	do i = 1 to 4;
	     if abs_cpu_rates (i) > 0 | abs_memory_rates (i) > 0
	     then put edit ("Queue", i, ":", abs_cpu_rates (i) + 5e-3, "/Hr", abs_memory_rates (i) + 5e-3, "/Kmu")
		     (skip, x (49), a (5), p "z9", a (1), p "$$$$,$$9.v99", a (3), p "$$$$,$$9.v99", a (4));
	end;
	call print_centered (2, "I_/_O_ D__a_e_m_o_n R__a_t_e_s");
	put edit ("Lines") (skip (2), x (72), a (5));
	put skip;
	do i = 1 to 4;
	     if lines_rates (i) > 0
	     then put edit ("Queue", i, ":", lines_rates (i) + 5e-3, "/K")
		     (skip, x (55), a (5), p "z9", a (1), p "$,$$$,$$9.v99", a (2));
	end;
	yes = "0"b;
	do i = 1 to ndevices;
	     if sum (dvt (i).device_rates (*)) > 0
	     then yes = "1"b;
	end;
	if yes
	then do;
		call print_centered (2, "D__e_v_i_c_e R__a_t_e_s");
		i = 1;
		do while (i <= ndevices);
		     nn = 0;
		     n = 1;
		     do while (n <= 4 & i <= ndevices);
			if sum (dvt (i).device_rates (*)) > 0
			then do;
				nn (n) = i;
				n = n + 1;
			     end;
			i = i + 1;
		     end;
		     n = n - 1;
		     if n > 0
		     then do;
			     call ioa_$rsnnl ("^a", s, l, dvt (nn (1)).device_id);
			     put edit (s) (skip (2), x ((156 - n * 15) / 2), x (8 - l), a);
			     do j = 2 to n;
				call ioa_$rsnnl ("^a", s, l, dvt (nn (j)).device_id);
				put edit (s) (x (7), x (8 - l), a);
			     end;
			     put skip;
			     do j = 0 to 7;
				yes = "0"b;
				do k = 1 to n while (^yes);
				     if dvt (nn (k)).device_rates (j) > 0
				     then yes = "1"b;
				end;
				if yes
				then do;
					put edit ("Shift", j, ":")
					     (skip, x ((126 - n * 15) / 2), a (5), p "z9", a (1));
					do k = 1 to n;
					     put edit (dvt (nn (k)).device_rates (j) + 5e-3, "/Hr")
						(p "$,$$$,$$9.v99", a (3));
					end;
				     end;
			     end;
			end;
		end;
	     end;
	if reg_rates > 0 | disk_rates > 0
	then do;
		call print_centered (2, "O__t_h_e_r R__a_t_e_s");
		put skip;
		if disk_rates > 0
		then put edit (disk_rates * 2592e3 + 5e-3, "/disk-page per month (", disk_rates, "/page-second )")
			(skip, x (35), p "$$$,$$9.v99", a, e (16), a);
		if reg_rates > 0
		then put edit (reg_rates, " per month registration fee per user") (skip, x (42), p "$$$,$$9.v99", a);
	     end;
	call print_centered (3, "The current shift schedule is:");
	put edit ("Shift", "Hours", "Days") (skip (2), x (44), a (5), x (3), a (5), x (5), a (4));
	put skip;
	do shift = 0 to 7;
	     this_shift_used = "0"b;
	     do day = 1 to 7;
		cur_shft = -2;
		do time = 0 to 47;
		     if shifts (day, time) = shift & cur_shft ^= shift
		     then do;
			     start_time = time;
			     cur_shft = shift;
			end;
		     if (shifts (day, time) ^= shift | time = 47) & cur_shft = shift
		     then do;
			     if shifts (day, time) = shift
			     then end_time = time;
			     else end_time = time - 1;
			     cur_shft = -2;
			     do time2 = start_time to end_time;
				shifts (day, time2) = -1;
			     end;
			     if ^this_shift_used
			     then do;
				     this_shift_used = "1"b;
				     put edit (shift) (skip, x (46), p "9");
				end;
			     put edit (start_time / 2, mod (start_time, 2) * 30, "-", (end_time + 1) / 2,
				mod (end_time + 1, 2) * 30) (col (51), 2 p "99", a (1), 2 p "99");
			     put edit (day_names (day)) (x (3), a);
			     do day2 = day + 1 to 7;
				match = "1"b;
				do time2 = start_time to end_time;
				     if shifts (day2, time2) ^= shift
				     then match = "0"b;
				end;
				if match
				then if start_time ^= 0
				     then if shifts (day2, start_time - 1) = shift
					then match = "0"b;
				if match
				then if end_time ^= 47
				     then if shifts (day2, end_time + 1) = shift
					then match = "0"b;
				if match
				then do;
					put edit (",", day_names (day2)) (a, a);
					do time2 = start_time to end_time;
					     shifts (day2, time2) = -1;
					end;
				     end;
			     end;
			end;
		end;
	     end;
	end;
     end rates_and_shifts;

footnote:
     proc (short_date);

/* this procedure checks to see if a segment named usage_and_revenue_footnote exists in the working directory.
   If it does, its contents are printed following the report.
   Parameter:
   short_date - input - date to be printed at top of each page. */
dcl	null		builtin;
dcl	note		char (nl) based (np),
	nl		fixed bin,
	np		ptr,
	(i, j)		fixed bin,
	bit_count		fixed bin (24),
	ec		fixed bin (35),
	short_date	char (8),
	NL		char (1) init ("
");
dcl	get_wdir_		entry returns (char (168));
dcl	initiate_file_	entry (character (*), character (*), bit (*), pointer, fixed binary (24), fixed binary (35))
			;
dcl	terminate_file_	entry (pointer, fixed binary (24), bit (*), fixed binary (35));

	call initiate_file_ (get_wdir_ (), "usage_and_revenue_footnote", R_ACCESS, np, bit_count, ec);
	if ec ^= 0
	then return;
	nl = divide (bit_count, 9, 17, 0);
	put edit (short_date, "Page", pageno (sysprint)) (page, a (8), col (127), a (4), p "z9");
	put skip (3);
	j = 1;
	do i = 1 to nl;
	     if substr (note, i, 1) = NL
	     then do;
		     put edit (substr (note, j, i - j)) (skip, x (15), a (i - j));
		     j = i + 1;
		end;
	     else if i - j > 100
	     then do;
		     put edit (substr (note, j, i - j + 1)) (skip, x (15), a (i - j + 1));
		     j = i;
		end;
	end;
	call terminate_file_ (np, (0), TERM_FILE_TERM, (0));
     end;

clean_up:
     proc (use_totals_ptr, xtotp, gptr);

/* This procedure terminates the use_totals segments, deletes the temporary
   segment used for groups and prints a final CR.
   Parameters:
   use_totals_ptr,xtotp - input - pointer to use_totals segment to be terminated
   gptr - input - pointer to temporary segment to be deleted */

dcl	(use_totals_ptr, xtotp, gptr)
			ptr;

dcl	ec		fixed bin (35);
dcl	terminate_file_	entry (pointer, fixed binary (24), bit (*), fixed binary (35));
dcl	release_temp_segment_
			entry (character (*), pointer, fixed binary (35));

	if use_totals_ptr ^= null ()
	then call terminate_file_ (use_totals_ptr, (0), TERM_FILE_TERM, ec);
	if xtotp ^= null ()
	then call terminate_file_ (xtotp, (0), TERM_FILE_TERM, ec);
	if gptr ^= null ()
	then call release_temp_segment_ (ME, gptr, ec);
	if P_ptr ^= null ()
	then free P;
	P_ptr = null ();
	put file (sysprint) skip;
	close file (sysprint);
     end clean_up;

format_time:
     proc (time) returns (char (*));

/* this procedure returns a character representation of the time, formatted slightly differently from the way
   that date_time_ formats it.
   Parameter:
   time -input - system clock time */

dcl	time		fixed bin (71),
	date_time_str	char (24),
	date		char (9) def date_time_str pos (1),
	stime		char (4) def date_time_str pos (11),
	day		char (4) def date_time_str pos (21);
dcl	date_time_	entry (fixed bin (71), char (*));

	call date_time_ (time, date_time_str);
	return (date || stime || day);
     end format_time;

print_centered:
     proc (skips, string);

/* print_centered prints one line which consists of the input parameter "string" centered on a
   132-character line with "skips" NL's at the beginning of the line.
   Parameters:
   skips - input - # of NL's
   string - input - string to be centered and printed */

dcl	string		char (*),			/* input parameter */
	skips		fixed bin;
dcl	(i, j, k, l)	fixed bin;
dcl	(verify, length, reverse, translate)
			builtin;

dcl	BS		char (1) init ("");		/* backspace */
dcl	non_print		char (32) /* All control characters from octal 0 to octal 40 except
						   backspace */ init (" 
  ");


	i = verify (string, non_print);		/* ignore leading blanks and control characters */
	if i = 0
	then do;					/* if there are no printable characters then print
						   a blank line and return */
		put file (sysprint) skip (skips);
		return;
	     end;
	j = length (string) - verify (reverse (string), non_print) + 1;
	l = j - i + 1;				/* length of string without leading and trailing blanks and
						   control characters */
	do k = i to j;
	     if substr (string, k, 1) = BS
	     then l = l - 2;			/* subtract 2 from length for each backspace in the string */
	end;					/* print the line, substituting blanks for all
						   control characters in the string */
	put file (sysprint) skip (skips)
	     edit (translate (substr (string, i, j - i + 1), "", non_print)) (x (66 - l / 2), a);
     end print_centered;
     end usage_and_revenue;
