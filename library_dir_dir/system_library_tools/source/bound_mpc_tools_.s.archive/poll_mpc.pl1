
/****^  HISTORY COMMENTS:
  1) change(2017-01-10,Hurst), approve(2017-01-10,MCR10026),
     audit(2017-01-10,Swenson), install(2017-01-10,MR12.6f-0012):
     Change mis-spelled "consequtive" to "consecutive".
                                                   END HISTORY COMMENTS */

/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */


/* POLL_MPC - Command to periodically poll mpc's and log the statistics they contain */
/* Written March 1980 by Larry Johnson */
/* Modified December 1980 by Rich Coppola to clear statistics block, and add
   mpc registers to logged data */
/* Modified May 1982 by Rich Coppola to add support for EURC */
/* Modified October 1982 by C. Hornig for new PRPH TAP card. */
/* Modified Dec. 1983 by Paul Farley to fix a problem with suspend/release
   tape controller interrupt processing when more than one physical connection
   is configured.
   Modified June 1984 by Paul Farley to fix a problem with the command_cleanup
   proc not exiting properly. Call programs char_mpc_ and stat_mpc_ with a ptr
   to the MPC image. Add support for the new MSP800 (DAU).
   Modified March 1985 by Paul Farley to double DAU config area for 64 devices
   and correct a bug in the blocked_too_long entry (PBF).
*/

/* format: style4,delnl,insnl,ifthenstmt,indnoniterend */
poll_mpc:
     proc;

/* Parameters */

dcl  arg_event_call_info_ptr ptr;

/* Automatic */

dcl  code fixed bin (35);
dcl  argp ptr;
dcl  argl fixed bin;
dcl  argno fixed bin;
dcl  n_args fixed bin;
dcl  more_args bit (1);
dcl  arg_list_ptr ptr;
dcl  output_file char (201);
dcl  i fixed bin;
dcl  mpc_cnt fixed bin;
dcl  mpc_list (32) char (4);
dcl  char8 char (8) aligned;
dcl  1 auto_mpc_data aligned like mpc_data automatic;
dcl  event_message fixed bin (71);
dcl  mpc_mem_bin (0:4095) bit (16) unal;		/* mpc mem converted to binary */
dcl  eurc_stats (0:83) bit (16) unal;			/* eurc stats converted to bin */
dcl  dau_data (0:759) bit (16) unal;			/* DAU config and stats */
dcl  special_status_flag bit (1) aligned;		/* on if special status valid			*/
dcl  special_status_word bit (36) aligned;
dcl  my_event_wait_list_ptr ptr;
dcl  1 my_event_wait_list aligned,
       2 n_channels fixed binary init (1),		/* number of channels in wait list */
       2 pad bit (36),
       2 channel_id (2) fixed binary (71);

/* Constants */

dcl  d451_stat_size fixed bin int static options (constant) init (512);
dcl  d600_stat_size fixed bin int static options (constant) init (1024);
dcl  tape_stat_size fixed bin int static options (constant) init (128);
dcl  mpc_memory_size fixed bin int static options (constant) init (4096);
dcl  name char (8) int static options (constant) init ("poll_mpc");
dcl  OPERATION (9) char (20) var int static options (constant)
	init ("Attaching", "Read R/W memory", "Suspending IO (IOI)", "Suspend MPC", "Clear Dev Stats", "Release MPC",
	"Releasing IO (IOI)", "Detaching", "Reading DAU");

/* Static */

dcl  CMD_EXIT label int static;
dcl  static_log_mpc_datap ptr int static init (null);
dcl  time_int fixed bin int static init (0);
dcl  (tape_sw, disk_sw, urp_sw, eurc_sw, dau_sw) bit (1) int static init ("0"b);
dcl  mpc_attached bit (1) int static init ("0"b);
dcl  stopped_io bit (1) int static init ("0"b);		/* This is set if IOI suspended io */
dcl  mtp_suspended bit (1) int static init ("0"b);	/* Set if the mpc accepted the 'suspend' command */
dcl  log_mpc_datap ptr int static init (null);
dcl  log_mpc_entryp ptr int static;
dcl  log_mpc_data_n_mpcs fixed bin int static;
dcl  workp ptr int static;
dcl  error_message char (128) var int static;
dcl  (time_sw, output_file_sw, debug_sw, log_sw, off_sw, on_sw, finish_sw) bit (1) int static;
dcl  OP fixed bin int static init (0);
dcl  ATTACH_MPC fixed bin int static init (1);
dcl  READ_MPC_MEM fixed bin int static init (2);
dcl  IOI_SUS_MTP fixed bin int static init (3);
dcl  SUS_MTP fixed bin int static init (4);
dcl  WRITE_MPC_MEM fixed bin int static init (5);
dcl  REL_MTP fixed bin int static init (6);
dcl  IOI_REL_MTP fixed bin int static init (7);
dcl  DETACH_MPC fixed bin int static init (8);
dcl  READ_DAU fixed bin int static init (9);
dcl  ATT_ERR fixed bin int static init (1);		/* Couldn' attach */
dcl  IOI_WRKSP fixed bin int static init (2);		/* Couldn't get ioi workspace */
dcl  IO_ERR fixed bin int static init (3);		/* IO err of some sort */
dcl  STAT_ERR fixed bin int static init (4);		/* error getting mpc stats */
dcl  IPC_ERR fixed bin int static init (5);		/* ^turn io ch to event call ch */
dcl  CONN_ERR fixed bin int static init (6);		/* Error on the connect */
dcl  SUS_ERR fixed bin int static init (7);		/* The MTP needs more than */
						/* just a detach */
						/* Based */

dcl  arg char (argl) based (argp);

dcl  1 log_mpc_data aligned based (log_mpc_datap),
       2 n_mpcs fixed bin,				/* Number of mpcs configured */
       2 index fixed bin,				/* Index to the one currently being polled */
       2 overrun_count fixed bin,			/* Consecutive polling cycles missed because previous one slow */
       2 timer_event fixed bin (71),			/* Event channel for driving polling */
       2 prev_cycle_start fixed bin (71),		/* Start of last round */
       2 prev_mpc_start fixed bin (71),			/* Start of current mpc */
       2 prev_cycle_end fixed bin (71),			/* Type previous cycle completed last mpc */
       2 next_cycle_sched fixed bin (71),		/* Time of next scheduled run */
       2 interval fixed bin (71),			/* Time (in microseconds) between scheduled runs */
       2 iocbp ptr,
       2 workp ptr,
       2 flags unal,
         3 debug bit (1),
         3 log bit (1),
         3 output_file bit (1),
         3 finish bit (1),
         3 io_in_progress bit (1),
         3 pad bit (31),
       2 attach_desc char (256) var,
       2 attach_data like attach_mpc_data,		/* For attaching current mpc */
       2 mpc_entry (log_mpc_data_n_mpcs refer (log_mpc_data.n_mpcs)) like log_mpc_entry;

dcl  1 log_mpc_entry aligned based (log_mpc_entryp),
       2 mpc_name char (4),
       2 times_dumped fixed bin (35),
       2 times_failed fixed bin (35),
       2 fail_count fixed bin,			/* Count of consecutive failures */
       2 alarm bit (1),				/* Alarm sensed for this MPC */
       2 prev_err_reg bit (16),			/* Last copy of the err data reg */
       2 prev_err_ctr fixed bin,			/* last count of the err int ctr */
       2 prev_stat_ctr_cnt fixed bin,			/* last count of the */
       2 on bit (1);

dcl  1 buf aligned based (workp),			/* The IOI buffer segment */
       2 idcw1 bit (36),				/* Will be read controller main memory */
       2 dcw1 bit (36),				/* Addr=buf.control, tally=1 */
       2 idcw2 bit (36),				/* Will be initiate read data transfer */
       2 dcw2 bit (36),				/* Address=buf.mem, tally=rest of segment */
       2 control,					/* Describes where data is in mpc */
         3 addr bit (16) unal,			/* Addr in mpc memory */
         3 tally bit (16) unal,			/* Count in mpc words */
         3 fill bit (4) unal,
       2 mem (0:mpc_memory_size - 1) bit (18) unal;	/* This is the mpc memory */

dcl  1 buf1 aligned based (workp),
       2 idcw1 bit (36),
       2 dcw1 bit (36),
       2 control,
         3 addr bit (16) unal,
         3 tally bit (16) unal,
         3 fill bit (16) unal,
       2 release_data bit (36) unal;

dcl  1 stat_buf aligned based (workp),			/* The IOI buffer segment */
       2 idcw1 bit (36),				/* Will be read controller main memory */
       2 dcw1 bit (36),				/* Addr=stat_buf.control, tally=1 */
       2 idcw2 bit (36),				/* Will be initiate read data transfer */
       2 dcw2 bit (36),				/* Address=stat_buf.mem, tally=rest of segment */
       2 control,					/* Describes where data is in mpc */
         3 addr bit (16) unal,			/* Addr in mpc memory */
         3 tally bit (16) unal,			/* Count in mpc words */
         3 fill bit (4) unal,
       2 stats (0:83) bit (18) unal;			/* EURC statistics in ASCII */

dcl  1 dau_buf aligned based (workp),			/* The IOI buffer segment */
       2 cf_idcw bit (36),				/* Read Configuration (24o) */
       2 cf_dcw bit (36),				/* Addr=dau_buf.data(0), tally=65 */
       2 st_idcw bit (36),				/* Read/Clear Statistics (16o) */
       2 st_dcw bit (36),				/* Address=dau_buf.data(130), tally=315 */
       2 data (0:759) bit (18) unal;			/* Config & statistics area */


/* External */

dcl  analyze_device_stat_$rsnnl entry (char (*) var, ptr, bit (72), bit (18));
dcl  config_$find entry (char (4) aligned, ptr);
dcl  com_err_ entry options (variable);
dcl  cu_$arg_count entry (fixed bin);
dcl  absolute_pathname_ entry (char (*), char (*), fixed bin (35));
dcl  cu_$arg_list_ptr entry (ptr);
dcl  cu_$arg_ptr_rel entry (fixed bin, ptr, fixed bin, fixed bin (35), ptr);
dcl  hcs_$wakeup entry (bit (*), fixed bin (71), fixed bin (71), fixed bin (35));
dcl  get_process_id_ entry () returns (bit (36));
dcl  convert_ipc_code_ entry (fixed bin (35));
dcl  (
     ioa_,
     ioa_$nnl
     ) entry options (variable);
dcl  ipc_$create_ev_chn entry (fixed bin (71), fixed bin (35));
dcl  ipc_$decl_ev_call_chn entry (fixed bin (71), ptr, ptr, fixed bin, fixed bin (35));
dcl  ipc_$decl_ev_wait_chn entry (fixed bin (71), fixed bin (35));
dcl  timer_manager_$reset_alarm_wakeup entry (fixed bin (71));
dcl  ipc_$drain_chn entry (fixed bin (71), fixed bin (35));
dcl  timer_manager_$alarm_wakeup entry (fixed bin (71), bit (2), fixed bin (71));
dcl  timer_manager_$reset_alarm_call entry (entry);
dcl  timer_manager_$alarm_call entry (fixed bin (71), bit (2), entry);
dcl  ipc_$delete_ev_chn entry (fixed bin (71), fixed bin (35));
dcl  ipc_$set_wait_prior entry (fixed bin (35));
dcl  ipc_$block entry (ptr, ptr, fixed bin (35));
dcl  attach_mpc_ entry (ptr, fixed bin (35));
dcl  detach_mpc_ entry (ptr, fixed bin (35));
dcl  decode_mpc_stats_$err_data_ entry (ptr, ptr);
dcl  ioi_$get_special_status entry (fixed bin, bit (1) aligned, bit (36) aligned, fixed bin (35));
dcl  ioi_$suspend_devices entry (fixed bin, fixed bin (35));
dcl  ioi_$release_devices entry (fixed bin, fixed bin (35));
dcl  ioi_$workspace entry (fixed bin, ptr, fixed bin (18), fixed bin (35));
dcl  ioi_$connect entry (fixed bin, fixed bin (18), fixed bin (35));
dcl  char_mpc_ entry (ptr, ptr);
dcl  stat_mpc_ entry (ptr, ptr, ptr, bit (1));
dcl  stat_mpc_$return_dau_data entry (ptr, ptr, ptr, fixed bin (35));
dcl  stat_mpc_$return_mpc_data entry (ptr, ptr, ptr, bit (1), fixed bin (35));
dcl  stat_mpc_$eurc entry (ptr, ptr, ptr, bit (1));
dcl  stat_mpc_$dau entry (ptr, ptr, ptr, bit (1));
dcl  iox_$attach_name entry (char (*), ptr, char (*), ptr, fixed bin (35));
dcl  iox_$open entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
dcl  iox_$close entry (ptr, fixed bin (35));
dcl  iox_$detach_iocb entry (ptr, fixed bin (35));
dcl  rcp_$detach entry (bit (36) aligned, bit (*), fixed bin, char (*), fixed bin (35));
dcl  hphcs_$syserr_binary entry options (variable);
dcl  hphcs_$syserr entry options (variable);
dcl  analyze_ioi_imess_ entry (ptr, ptr, char (*) var);
dcl  get_temp_segment_ entry (char (*), ptr, fixed bin (35));
dcl  release_temp_segment_ entry (char (*), ptr, fixed bin (35));

dcl  error_table_$too_many_args ext fixed bin (35);
dcl  error_table_$noarg ext fixed bin (35);
dcl  error_table_$badopt ext fixed bin (35);
dcl  error_table_$inconsistent ext fixed bin (35);
dcl  error_table_$unable_to_do_io fixed bin (35) ext static;

dcl  (cleanup, conversion) condition;

dcl  (addr, bin, bit, clock, codeptr, currentsize, hbound, null, rel, rtrim, size, substr, unspec, sum) builtin;
%page;
/* Command entry to setup the command */

	call cu_$arg_count (n_args);
	call cu_$arg_list_ptr (arg_list_ptr);
	argno = 1;
	more_args = (argno <= n_args);
	time_sw = "0"b;
	output_file_sw = "0"b;
	debug_sw = "0"b;
	log_sw = "0"b;
	off_sw = "0"b;
	on_sw = "0"b;
	finish_sw = "0"b;
	mpc_cnt = 0;
	mpc_list (*) = "";
	CMD_EXIT = done;				/* Set command_cleanup's return label. */


	do while (more_args);
	     call get_arg;
	     if substr (arg, 1, 1) ^= "-" then do;	/* Must be mpc name */
		if mpc_cnt >= hbound (mpc_list, 1) then do;
		     call com_err_ (error_table_$too_many_args, name, "More than ^d MPC's listed.",
			hbound (mpc_list, 1));
		     go to error_return;
		     end;
		mpc_cnt = mpc_cnt + 1;
		mpc_list (mpc_cnt) = arg;
		end;
	     else if arg = "-time" | arg = "-tm" then do;
		if ^more_args then do;
missing:
		     call com_err_ (error_table_$noarg, name, "After ^a.", arg);
		     go to error_return;
		     end;
		call get_arg;
		on conversion go to bad_time;
		time_int = bin (arg);
		revert conversion;
		if time_int <= 0 then do;
bad_time:
		     call com_err_ (0, name, "Invalid time specified: ^a", arg);
		     go to error_return;
		     end;
		time_sw = "1"b;
		end;
	     else if arg = "-output_file" | arg = "-of" then do;
		if ^more_args then go to missing;
		call get_arg;
		call absolute_pathname_ (arg, output_file, code);
		if code ^= 0 then do;
		     call com_err_ (code, name, "^a", arg);
		     go to error_return;
		     end;
		output_file_sw = "1"b;
		end;
	     else if arg = "-log" then log_sw = "1"b;
	     else if arg = "-stop" | arg = "-sp" then do;
		off_sw = "1"b;
		on_sw = "0"b;
		end;
	     else if arg = "-start" | arg = "-sr" then do;
		on_sw = "1"b;
		off_sw = "0"b;
		end;
	     else if arg = "-finish" then finish_sw = "1"b;
	     else if arg = "-debug" | arg = "-db" then debug_sw = "1"b;
	     else do;
		call com_err_ (error_table_$badopt, name, "^a", arg);
		go to error_return;
		end;
	end;
%page;
/* This code handles modifications to running polling */

	if static_log_mpc_datap ^= null () then do;
	     log_mpc_datap = static_log_mpc_datap;
	     if log_mpc_data.finish then do;
		call com_err_ (0, name, "Finish operation in progress.  Requests not accepted until it completes.");
		go to error_return;
		end;
	     if n_args = 0 then do;			/* Some argument required to adjust polling */
		call com_err_ (error_table_$noarg, name, "Polling already in progress.");
		go to error_return;
		end;
	     if time_sw then log_mpc_data.interval = 60 * 1000000 * time_int;
	     if debug_sw then log_mpc_data.debug = "1"b;
	     if output_file_sw then do;
		log_mpc_data.attach_desc = "vfile_ " || rtrim (output_file) || " -extend";
		log_mpc_data.output_file = "1"b;
		end;
	     if log_sw then log_mpc_data.log = "1"b;
	     if on_sw | off_sw | (mpc_cnt > 0) then do;
		if mpc_cnt > 0 then call validate_mpc_list;
		if ^(on_sw | off_sw) then on_sw = "1"b;
		do i = 1 to log_mpc_data.n_mpcs;
		     log_mpc_entryp = addr (log_mpc_data.mpc_entry (i));
		     if listed_mpc () then do;
			log_mpc_entry.on = on_sw;
			if on_sw then log_mpc_entry.fail_count = 0;
			if log_mpc_data.debug
			then call ioa_ ("^a: Polling ^[enabled^;disabled^] for MPC ^a.", name, on_sw,
				log_mpc_entry.mpc_name);
			end;
		end;
		end;
	     if finish_sw then do;
		call timer_manager_$reset_alarm_wakeup (log_mpc_data.timer_event);
		call ipc_$drain_chn (log_mpc_data.timer_event, code);
		char8 = "finish";
		unspec (event_message) = unspec (char8);
		call hcs_$wakeup (get_process_id_ (), log_mpc_data.timer_event, event_message, code);
		if code ^= 0 then do;
		     call convert_ipc_code_ (code);
		     call com_err_ (code, name, "Unable to send finish wakeup.");
		     end;
		log_mpc_data.finish = "1"b;
		end;
	     go to done;
	     end;
%page;
/* This code handles starting polling for the first time */

	if on_sw | off_sw | finish_sw then do;
	     call com_err_ (error_table_$inconsistent, name,
		"^/^-Args -start, -stop, -finish not permitted before polling started.");
	     go to error_return;
	     end;
	if ^(log_sw | output_file_sw) then log_sw = "1"b;

	on cleanup call command_cleanup;

	call setup_static_data;

	log_mpc_data.iocbp = null ();
	log_mpc_data.debug = debug_sw;

	if mpc_cnt > 0 then call validate_mpc_list;

	do i = 1 to log_mpc_data.n_mpcs;
	     log_mpc_entryp = addr (log_mpc_data.mpc_entry (i));
	     if listed_mpc () then do;
		log_mpc_entry.on = "1"b;
		log_mpc_entry.prev_err_reg = "0"b;
		log_mpc_entry.prev_err_ctr = 0;
		log_mpc_entry.prev_stat_ctr_cnt = 0;
		end;
	end;

	log_mpc_data.log = log_sw;
	if output_file_sw then do;
	     log_mpc_data.attach_desc = "vfile_ " || rtrim (output_file) || " -extend";
	     log_mpc_data.output_file = "1"b;
	     end;

	if ^time_sw then time_int = 15;
	log_mpc_data.interval = time_int * 60 * 1000000;

	call ipc_$create_ev_chn (log_mpc_data.timer_event, code);
	if code ^= 0 then do;
	     call convert_ipc_code_ (code);
	     call com_err_ (code, name, "Unable to create event channel.");
	     go to error_return;
	     end;
	call ipc_$decl_ev_call_chn (log_mpc_data.timer_event, codeptr (timer_wakeup), log_mpc_datap, 30, code);
						/* Priority = 30 appropriate in Initializer */
	if code ^= 0 then do;
	     call convert_ipc_code_ (code);
	     call com_err_ (code, name, "Unable to setup event call channel.");
	     go to error_return;
	     end;

	char8 = "start";
	unspec (event_message) = unspec (char8);
	log_mpc_data.next_cycle_sched = clock ();
	call hcs_$wakeup (get_process_id_ (), log_mpc_data.timer_event, event_message, code);
	if code ^= 0 then do;
	     call convert_ipc_code_ (code);
	     call com_err_ (code, name, "Unable to send first wakeup.");
	     go to error_return;
	     end;
	static_log_mpc_datap = log_mpc_datap;

done:
	return;

error_return:
	call command_cleanup;
	return;
%page;
/* Timer wakeup to start polling operation */

timer_wakeup:
     entry (arg_event_call_info_ptr);

	CMD_EXIT = done;				/* Set command_cleanup's return label. */
	on cleanup call command_cleanup;
	event_call_info_ptr = arg_event_call_info_ptr;
	log_mpc_datap = event_call_info.data_ptr;

	if log_mpc_datap ^= static_log_mpc_datap then return;
						/* Spurious */
	if event_call_info.channel_id ^= log_mpc_data.timer_event then return;
						/* Likewise */

	unspec (char8) = unspec (event_call_info.message);
	if log_mpc_data.debug then do;
	     call ioa_$nnl ("Timer wakeup: ^a. Processing:", char8);
	     do i = 1 to log_mpc_data.n_mpcs;
		log_mpc_entryp = addr (log_mpc_data.mpc_entry (i));
		if log_mpc_entry.on then call ioa_$nnl (" ^a", log_mpc_entry.mpc_name);
	     end;
	     call ioa_ ("");
	     end;

	if log_mpc_data.index ^= 0 then do;		/* Previous operation still in progress */
	     log_mpc_entryp = addr (log_mpc_data.mpc_entry (log_mpc_data.index));
	     call com_err_ (0, name, "Polling overrun. Previous cycle still in progress, processing ^a.",
		log_mpc_entry.mpc_name);
	     log_mpc_data.overrun_count = log_mpc_data.overrun_count + 1;
	     if log_mpc_data.overrun_count >= 3 then do;
		log_mpc_data.finish = "1"b;
		call com_err_ (0, name, "Polling abandoned. Too many polling overruns occured.");
		end;
	     end;
	else log_mpc_data.overrun_count = 0;		/* Keeping up ok */

	if ^log_mpc_data.finish then do;
	     log_mpc_data.next_cycle_sched = log_mpc_data.next_cycle_sched + log_mpc_data.interval;
	     do while (log_mpc_data.next_cycle_sched <= clock ());
		log_mpc_data.next_cycle_sched = log_mpc_data.next_cycle_sched + log_mpc_data.interval;
	     end;
	     call timer_manager_$alarm_wakeup (log_mpc_data.next_cycle_sched, "00"b, log_mpc_data.timer_event);
	     end;

	if log_mpc_data.index ^= 0 then return;

/* Attach output file if specified */

	if log_mpc_data.output_file then do;
	     call iox_$attach_name ("poll_mpc", log_mpc_data.iocbp, (log_mpc_data.attach_desc), null (), code);
	     if code ^= 0 then do;
		call com_err_ (code, name, "Unable to attach output file.");
		log_mpc_data.iocbp = null ();
		go to process_next_mpc;
		end;
	     call iox_$open (log_mpc_data.iocbp, Stream_output, "0"b, code);
	     if code ^= 0 then do;
		call com_err_ (code, name, "Unable to open output file.");
		call iox_$detach_iocb (log_mpc_data.iocbp, code);
		log_mpc_data.iocbp = null ();
		end;
	     end;

/* Find the next mpc to run */

process_next_mpc:
	i = log_mpc_data.index + 1;
	if i > log_mpc_data.n_mpcs then do;		/* Cycle complete */
	     log_mpc_data.prev_cycle_end = clock ();
	     log_mpc_data.index = 0;
	     if log_mpc_data.iocbp ^= null () then do;
		call iox_$close (log_mpc_data.iocbp, code);
		call iox_$detach_iocb (log_mpc_data.iocbp, code);
		log_mpc_data.iocbp = null ();
		end;
	     if log_mpc_data.finish then do;		/* This is last cycle */
		call ioa_ ("^a: Finished.", name);
		call ipc_$delete_ev_chn (log_mpc_data.timer_event, code);
		call command_cleanup;
		end;
	     return;
	     end;

	log_mpc_data.index = i;
	log_mpc_entryp = addr (log_mpc_data.mpc_entry (i));
	if ^log_mpc_entry.on then go to process_next_mpc;

/* Attach next mpc */

	log_mpc_data.prev_mpc_start = clock ();
	log_mpc_entry.times_dumped = log_mpc_entry.times_dumped + 1;
	attach_mpc_datap = addr (log_mpc_data.attach_data);
	unspec (attach_mpc_data) = "0"b;
	attach_mpc_data.version = attach_mpc_data_version_1;
	attach_mpc_data.mpc_name = log_mpc_entry.mpc_name;
	attach_mpc_data.caller_name = name;
	attach_mpc_data.report = "1"b;
	OP = ATTACH_MPC;
	call attach_mpc_ (attach_mpc_datap, code);

	if code ^= 0 then do;
	     call detach_and_count (ATT_ERR);
	     go to process_next_mpc;
	     end;

	mpc_attached = "1"b;			/* remember */

	if log_mpc_data.debug
	then call ioa_ ("^a: ^a ^a (^a)", name, OPERATION (OP), attach_mpc_data.mpc_name, attach_mpc_data.device_name);

/* When an entry is created in ioi_ to check the state of the suspend
   devices flag for an MPC, the following should be added to skip the
   MPC if the IO is suspended. This way poll_mpc will not hang!

   *	call ioi_$check_suspend_state (or whatever)
   *	     (attach_mpc_data.ioi_index, io_suspended, code);
   *	if io_suspended then do;
   *	     call detach_and_count (SUSPENDED_ERR);
   *	     goto process_next_mpc;
   *	end;
*/

	if substr (attach_mpc_data.mpc_name, 1, 3) = "urp" then do;
	     tape_sw, disk_sw, dau_sw = "0"b;
	     urp_sw = "1"b;
	     eurc_sw = "0"b;
	     do i = 1 to hbound (eurc_model_numbers, 1) while (eurc_sw = "0"b);
		if attach_mpc_data.model = eurc_model_numbers (i) then eurc_sw = "1"b;
	     end;
	     end;

	else if substr (attach_mpc_data.mpc_name, 1, 3) = "msp" then do;
	     disk_sw = "1"b;
	     urp_sw, eurc_sw, tape_sw, dau_sw = "0"b;
	     if attach_mpc_data.model = 800 then dau_sw = "1"b;
	     end;

	else if substr (attach_mpc_data.mpc_name, 1, 3) = "mtp" then do;
	     tape_sw = "1"b;
	     urp_sw, disk_sw, dau_sw, eurc_sw = "0"b;
	     end;

	call ioi_$workspace (attach_mpc_data.ioi_index, workp, size (buf), code);
	if code ^= 0 then do;
	     call com_err_ (code, name, "Unable to set workspace for ^a.", attach_mpc_data.mpc_name);
	     call detach_and_count (IOI_WRKSP);
	     go to process_next_mpc;
	     end;

	log_mpc_data.workp = workp;


	if dau_sw
	then OP = READ_DAU;
	else OP = READ_MPC_MEM;
	if eurc_sw then call build_eurc_idcw;
	else if dau_sw then call build_dau_idcw;
	else call build_idcw;
	call do_io (code);
	if code ^= 0 then goto process_next_mpc;
	return;					/* Return, allowing I/O to complete */


%page;

/* Wakup handler for I/O completion events */

io_wakeup:
     entry (arg_event_call_info_ptr);

	CMD_EXIT = done;				/* Set command_cleanup's return label. */
	on cleanup call command_cleanup;
	event_call_info_ptr = arg_event_call_info_ptr;
	log_mpc_datap = event_call_info.data_ptr;
	if log_mpc_datap ^= static_log_mpc_datap then return;
						/* Spurious */
	if ^log_mpc_data.io_in_progress then return;
	if log_mpc_data.index = 0 then return;
	log_mpc_entryp = addr (log_mpc_data.mpc_entry (log_mpc_data.index));
	attach_mpc_datap = addr (log_mpc_data.attach_data);
	if attach_mpc_data.ioi_channel ^= event_call_info.channel_id then return;

	log_mpc_data.io_in_progress = "0"b;

	workp = log_mpc_data.workp;
	imp = addr (event_call_info.message);


	if imess.er | (imess.level ^= "3"b3) then do;
	     call analyze_ioi_imess_ (imp, attach_mpc_data.status_tablep, error_message);
	     call com_err_ (0, name, "I/O error on ^a: ^a", log_mpc_entry.mpc_name, error_message);
	     if log_mpc_data.log
	     then call hphcs_$syserr (3, "poll_mpc: I/O error on ^a: ^a", log_mpc_entry.mpc_name, error_message);

	     call detach_and_count (IO_ERR);
	     go to process_next_mpc;
	     end;

	if OP = READ_DAU then do;

	     mpc_datap = addr (auto_mpc_data);		/* Setup for memory checking rtn */
	     mpc_data.type = attach_mpc_data.type;
	     mpc_data.model = attach_mpc_data.model;
	     mpc_data.name = attach_mpc_data.mpc_name;

	     do i = 0 to 759;
		substr (dau_data (i), 1, 8) = substr (dau_buf.data (i), 2, 8);
		substr (dau_data (i), 9, 8) = substr (dau_buf.data (i), 11, 8);
	     end;
	     call char_mpc_ (addr (dau_data (0)), mpc_datap);
	     if log_mpc_data.debug
	     then call ioa_ ("^a: Firmware rev ^a (HW rev ^2.4b hex) for ^a.", name, mpc_data.fw_rev, mpc_data.dau_rev,
		     attach_mpc_data.mpc_name);

	     if log_mpc_data.iocbp ^= null ()
	     then call stat_mpc_$dau (addr (dau_data (0)), log_mpc_data.iocbp, mpc_datap, "0"b);

	     if log_mpc_data.log then do;
		call get_temp_segment_ ("poll_mpc", poll_mpc_datap, code);
		poll_mpc_specp = addr (poll_mpc_data.specific);
		call stat_mpc_$return_dau_data (addr (dau_data (0)), poll_mpc_datap, mpc_datap, code);

		if code ^= 0 then do;
		     call com_err_ (code, name, "Unable to process statistics for ^a", log_mpc_entry.mpc_name);
		     call detach_and_count (STAT_ERR);
		     go to process_next_mpc;
		     end;

		if poll_dau_data.err_interrupts ^= 0 then call dau_err_alarm;
		if sum (poll_dau_data.psi_cntr) ^= 0 then call dau_stat_alarm;
		call hphcs_$syserr_binary (5, poll_mpc_datap, SB_mpc_poll, currentsize (poll_mpc_data),
		     "poll_mpc: Polled ^a.", log_mpc_entry.mpc_name);

		poll_mpc_specp = null ();
		call release_temp_segment_ ("poll_mpc", poll_mpc_datap, code);
		end;
	     end;

	else if OP = READ_MPC_MEM then do;

	     mpc_datap = addr (auto_mpc_data);		/* Setup for memory checking rtn */
	     mpc_data.type = attach_mpc_data.type;
	     mpc_data.model = attach_mpc_data.model;
	     mpc_data.name = attach_mpc_data.mpc_name;

	     if eurc_sw = "0"b
	     then do i = 0 to mpc_memory_size - 1;
		substr (mpc_mem_bin (i), 1, 8) = substr (buf.mem (i), 2, 8);
		substr (mpc_mem_bin (i), 9, 8) = substr (buf.mem (i), 11, 8);
	     end;

	     else if eurc_sw = "1"b
	     then do i = 0 to 83;			/* convert it to binary */
		substr (eurc_stats (i), 1, 8) = substr (stat_buf.stats (i), 2, 8);
		substr (eurc_stats (i), 9, 8) = substr (stat_buf.stats (i), 11, 8);
	     end;

	     call char_mpc_ (addr (mpc_mem_bin), mpc_datap);
	     if log_mpc_data.debug
	     then call ioa_ ("^a: Firmware rev ^a for ^a.", name, mpc_data.fw_rev, attach_mpc_data.mpc_name);

	     if log_mpc_data.iocbp ^= null () then do;
		if eurc_sw
		then call stat_mpc_$eurc (addr (eurc_stats), log_mpc_data.iocbp, mpc_datap, "0"b);
		else call stat_mpc_ (addr (mpc_mem_bin), log_mpc_data.iocbp, mpc_datap, "0"b);
		end;

	     if log_mpc_data.log then do;
		call get_temp_segment_ ("poll_mpc", poll_mpc_datap, code);
		poll_mpc_specp = addr (poll_mpc_data.specific);
		if eurc_sw
		then call stat_mpc_$return_mpc_data (addr (eurc_stats), poll_mpc_datap, mpc_datap, eurc_sw, code);
		else call stat_mpc_$return_mpc_data (addr (mpc_mem_bin), poll_mpc_datap, mpc_datap, eurc_sw, code);

		if code ^= 0 then do;
		     call com_err_ (code, name, "Unable to process statistics for ^a", log_mpc_entry.mpc_name);
		     call detach_and_count (STAT_ERR);
		     go to process_next_mpc;
		     end;

		if ^eurc_sw then do;		/* DISK or TAPE MPC, use same format */
		     if poll_mtp_data.register ^= "0"b then call mpc_reg_alarm;

		     if sum (poll_mtp_data.polled_stat_counters) ^= 0 then call mpc_stat_alarm;
		     end;
		call hphcs_$syserr_binary (5, poll_mpc_datap, SB_mpc_poll, currentsize (poll_mpc_data),
		     "poll_mpc: Polled ^a.", log_mpc_entry.mpc_name);

		poll_mpc_specp = null ();
		call release_temp_segment_ ("poll_mpc", poll_mpc_datap, code);
		end;
	     end;

	if log_mpc_data.log = "0"b then go to wakeup_end; /* thats it then */

	if (disk_sw & ^dau_sw)
	then if OP = READ_MPC_MEM then do;		/* now clear the dev stat block */
		OP = WRITE_MPC_MEM;			/* if we just read the rw mem */
		call build_idcw;
		call do_io (code);
		if code ^= 0 then go to process_next_mpc;
		return;
		end;

	if tape_sw then do;				/* special case the MTP */
	     call suspend_mtp (code);
	     if code ^= 0 then go to process_next_mpc;
	     end;

wakeup_end:
	call DETACH_MPC_;

	log_mpc_entry.fail_count = 0;

	go to process_next_mpc;


%page;

/* routine to return the tape mpc to use if the mpc does not respond to a connect for io */

blocked_too_long:
     entry;

	log_mpc_datap = static_log_mpc_datap;
	if ^log_mpc_data.io_in_progress then return;
	if log_mpc_data.index < 1 then return;
	log_mpc_entryp = addr (log_mpc_data.mpc_entry (log_mpc_data.index));
	attach_mpc_datap = addr (log_mpc_data.attach_data);
	CMD_EXIT = done;				/* Set command_cleanup's return label. */
	call release_tape_mpc (-1, 0);		/* ensure mpc gets released */
	call detach_and_count (SUS_ERR);
	go to process_next_mpc;



%page;
build_eurc_idcw:
     proc;

/* Build dcw list to get statistics from EURC MPC */

	idcwp = addr (stat_buf.idcw1);		/* First IDCW */
	stat_buf.idcw1 = "0"b;
	idcw.command = "31"b3;			/* Command is read Statistics */
	idcw.code = "111"b;				/* This makes it an IDCW */
	idcw.control = "10"b;			/* Set continue bit */
	idcw.chan_cmd = "41"b3;			/* Indicate special controller command */
	idcw.count = "15"b3;

	dcwp = addr (stat_buf.dcw1);
	stat_buf.dcw1 = "0"b;
	dcw.address = rel (addr (stat_buf.control));	/* Get offset to control word */
	dcw.tally = "000000000010"b;

	idcwp = addr (stat_buf.idcw2);		/* Second IDCW */
	stat_buf.idcw2 = "0"b;
	idcw.command = "06"b3;			/* Command is initiate read data transfer */
	idcw.code = "111"b;				/* Code is 111 to make it an idcw */
	idcw.chan_cmd = "40"b3;			/* Special controller command */

	dcwp = addr (stat_buf.dcw2);
	stat_buf.dcw2 = "0"b;
	dcw.address = rel (addr (stat_buf.stats));	/* Offset to core image */
	dcw.tally = "0052"b3;			/* It returns 42 words */
	return;

     end build_eurc_idcw;
%page;
build_dau_idcw:
     proc;

/* Build dcw list to get configuration and statistics from DAU MSP */

	idcwp = addr (dau_buf.cf_idcw);		/* First IDCW */
	dau_buf.cf_idcw = "0"b;
	idcw.command = "24"b3;			/* Command is read Configuration */
	idcw.code = "111"b;				/* IDCW */
	idcw.control = "10"b;			/* Set continue bit */
	idcw.chan_cmd = "30"b3;			/* Want list in dev# order */

	dcwp = addr (dau_buf.cf_dcw);
	dau_buf.cf_dcw = "0"b;
	dcw.address = rel (addr (dau_buf.data (0)));	/* Get offset to config data area */
	dcw.tally = "0101"b3;			/* 65 words */

	idcwp = addr (dau_buf.st_idcw);		/* Second IDCW */
	dau_buf.st_idcw = "0"b;
	idcw.command = "16"b3;			/* Command is read/clear statistics */
	idcw.code = "111"b;				/* IDCW */

	dcwp = addr (dau_buf.st_dcw);
	dau_buf.st_dcw = "0"b;
	dcw.address = rel (addr (dau_buf.data (130)));	/* Offset to statistic data area */
	dcw.tally = "0473"b3;			/* 315 words */
	return;

     end build_dau_idcw;
%page;
build_idcw:
     proc;

/* Build read or write (dev stat block) main memory dcw list */

	idcwp = addr (buf.idcw1);			/* First IDCW */
	buf.idcw1 = "0"b;

	if OP = READ_MPC_MEM
	then idcw.command = "02"b3;			/* Command is read controller main memory (ASCII) */
	else idcw.command = "32"b3;			/* Command is write main memory (binary) */

	idcw.code = "111"b;				/* This makes it an IDCW */
	idcw.control = "10"b;			/* Set continue bit */
	idcw.chan_cmd = "40"b3;			/* Indicate special controller command */
	dcwp = addr (buf.dcw1);
	buf.dcw1 = "0"b;
	dcw.address = rel (addr (buf.control));		/* Get offset to control word */
	dcw.tally = "000000000001"b;
	idcwp = addr (buf.idcw2);			/* Second IDCW */
	buf.idcw2 = "0"b;
	idcw.code = "111"b;				/* Code is 111 to make it an idcw */
	idcw.chan_cmd = "40"b3;			/* Special controller command */
	dcwp = addr (buf.dcw2);
	buf.dcw2 = "0"b;
	dcw.address = rel (addr (buf.mem));		/* Offset to core image */
	dcw.tally = bit (bin (size (buf) - bin (rel (addr (buf.mem)), 18), 12));
						/* Rest of seg */

	if OP = READ_MPC_MEM then do;
	     idcw.command = "06"b3;			/* Command is initiate read data transfer */
	     buf.addr = "0"b;			/* Mpc address to start is 0 */
	     buf.tally = bit (bin (mpc_memory_size, 16), 16);
	     end;

	else do;					/* Command will be write */
	     buf.mem (*) = "0"b;
	     idcw.command = "16"b3;			/* Command is initiate write  data transfer */
	     buf.addr = bit (bin (mpc_data.dev_stat_addr, 16), 16);
						/* Mpc address to start */

	     if disk_sw then do;
		if mpc_data.model < 600
		then buf.tally = bit (bin (d451_stat_size, 16), 16);

		else buf.tally = bit (bin (d600_stat_size, 16), 16);
		end;

	     else if tape_sw then buf.tally = bit (bin (tape_stat_size, 16), 16);
	     end;

	buf.fill = "0"b;

	return;

     end build_idcw;
%page;
build_sus_rel_idcw:
     proc;


	idcwp = addr (buf1.idcw1);			/* First IDCW */
	buf1.idcw1 = "0"b;
	if OP = SUS_MTP
	then idcw.command = "00"b3;			/* Command is suspend controller */
	else idcw.command = "20"b3;			/* Command is release controller */
	idcw.code = "111"b;				/* This makes it an IDCW */
	idcw.chan_cmd = "40"b3;			/* Indicate special controller command */

	dcwp = addr (buf1.dcw1);
	buf1.dcw1 = "0"b;
	dcw.address = rel (addr (buf1.control));	/* Get offset to control word */
	dcw.tally = "000000000000"b;

	return;

     end build_sus_rel_idcw;

%page;

/* Cleanup handler for command interface */

command_cleanup:
     proc;


	call DETACH_MPC_;				/* detach if attached */
	if static_log_mpc_datap ^= null then do;
	     attach_mpc_datap = addr (log_mpc_data.attach_data);
	     if attach_mpc_data.rcp_id ^= "0"b then call rcp_$detach (attach_mpc_data.rcp_id, "0"b, 0, "", code);
	     attach_mpc_data.rcp_id = "0"b;
	     if attach_mpc_data.ioi_channel ^= 0 then call ipc_$delete_ev_chn (attach_mpc_data.ioi_channel, code);
	     attach_mpc_data.ioi_channel = 0;
	     if log_mpc_datap ^= null then call ipc_$delete_ev_chn (log_mpc_data.timer_event, code);
	     end;

	mpc_attached = "0"b;
	log_mpc_data_n_mpcs = 0;
	static_log_mpc_datap = null ();
	if static_log_mpc_datap = null () & log_mpc_datap ^= null () then free log_mpc_data;

	goto CMD_EXIT;				/* EXIT program */
     end command_cleanup;

%page;

DETACH_MPC_:
     proc;
dcl  code fixed bin (35);
dcl  detach_count fixed bin;

	if ^mpc_attached then return;

	OP = DETACH_MPC;
	detach_count = 1;
DETACH:
	call detach_mpc_ (attach_mpc_datap, code);

	if code ^= 0 then do;
	     detach_count = detach_count + 1;
	     if detach_count < 4
	     then go to DETACH;

	     else do;

		call com_err_ (code, name, "Cannot detach MPC ^a,", attach_mpc_data.mpc_name);
		call command_cleanup;
		end;
	     end;

	mpc_attached = "0"b;

	if log_mpc_data.debug
	then call ioa_ ("^a: ^a ^a (^a)", name, OPERATION (OP), attach_mpc_data.mpc_name, attach_mpc_data.device_name);

	disk_sw, tape_sw, urp_sw, eurc_sw, dau_sw = "0"b;

	return;

     end DETACH_MPC_;

%page;
detach_and_count:
     proc (err_code);

dcl  err_code;

	log_mpc_entry.times_failed = log_mpc_entry.times_failed + 1;
	log_mpc_entry.fail_count = log_mpc_entry.fail_count + 1;
	if log_mpc_entry.fail_count >= 3 then do;
	     if ^log_mpc_data.finish
	     then call com_err_ (0, name, "Polling of ^a turned off because of too many consecutive failures.",
		     log_mpc_entry.mpc_name);
	     log_mpc_entry.on = "0"b;
	     end;

	if err_code ^= SUS_ERR
	then					/* special case these errors */
	     call DETACH_MPC_;
	return;

     end detach_and_count;

%page;

do_io:
     proc (acode);

dcl  (icode, acode) fixed bin (35);


	call ipc_$decl_ev_call_chn (attach_mpc_data.ioi_channel, codeptr (io_wakeup), log_mpc_datap, 30, icode);

	if icode ^= 0 then do;
	     call convert_ipc_code_ (icode);
	     call com_err_ (icode, name, "Unable to turn ioi channel into event call channel.");
	     call detach_and_count (IPC_ERR);
	     acode = icode;
	     return;
	     end;

	if log_mpc_data.debug
	then call ioa_ ("^a: Issuing Connect to ^a  for ^a (^a)", name, OPERATION (OP), attach_mpc_data.mpc_name,
		attach_mpc_data.device_name);

	call ioi_$connect (attach_mpc_data.ioi_index, 0, icode);

	if icode ^= 0 then do;
	     call com_err_ (icode, name, "Unable to issue connect to dump memory.");
	     call detach_and_count (CONN_ERR);
	     acode = icode;
	     return;
	     end;

	log_mpc_data.io_in_progress = "1"b;
	acode = 0;

	return;
     end do_io;
%page;

do_tape_io:
     proc (spec_sw, acode);

dcl  (acode, CODE) fixed bin (35);
dcl  spec_sw bit (1);				/* if ON need a SPECIAL			*/
dcl  1 auto_event_wait_info like event_wait_info;

	acode, CODE = 0;
	my_event_wait_list_ptr = addr (my_event_wait_list);
	event_wait_info_ptr = addr (auto_event_wait_info);
	my_event_wait_list.channel_id (1) = attach_mpc_data.ioi_channel;
	call ipc_$create_ev_chn (my_event_wait_list.channel_id (2), CODE);
	if CODE ^= 0 then goto common_ret;

	if log_mpc_data.debug
	then call ioa_ ("^a: Issuing Connect to ^a  for ^a (^a)", name, OPERATION (OP), attach_mpc_data.mpc_name,
		attach_mpc_data.device_name);

/* Do the io operation */

	call ipc_$decl_ev_wait_chn (attach_mpc_data.ioi_channel, CODE);
	if CODE ^= 0 then go to common_ret;

	call ipc_$set_wait_prior (CODE);
	if CODE ^= 0 then go to common_ret;

	call ipc_$drain_chn (attach_mpc_data.ioi_channel, CODE);
	if CODE ^= 0 then goto common_ret;

	call ioi_$connect (attach_mpc_data.ioi_index, 0, CODE);
	if CODE ^= 0 then go to common_ret;

	call timer_manager_$alarm_call (60, "11"b, blocked_too_long);

	call ipc_$block (my_event_wait_list_ptr, event_wait_info_ptr, CODE);
	call timer_manager_$reset_alarm_call (blocked_too_long);
	if CODE ^= 0 then go to common_ret;


	attach_mpc_datap = addr (log_mpc_data.attach_data);
	log_mpc_data.io_in_progress = "0"b;
	workp = log_mpc_data.workp;

	imp = addr (event_wait_info.message);		/* Status is here */
	if imess.time_out then do;
time_err:
	     error_message = "Timeout.";
	     goto err_mess;
	     end;

	if imess.er then do;			/* Error */
	     call analyze_device_stat_$rsnnl (error_message, attach_mpc_data.status_tablep, (imess.status), ("0"b));
err_mess:
	     CODE = error_table_$unable_to_do_io;
	     call com_err_ (CODE, name, "I/O error occured: ^a", error_message);
	     go to common_ret;
	     end;
	error_message = "terminate";
	if spec_sw then do;
	     if imess.level = "3"b3 then do;
		call terminate (CODE);
		if CODE ^= 0 then do;
		     if CODE = -1 then goto err_mess;
		     else if CODE = -2 then goto wrong_stat;
		     goto common_ret;
		     end;
		call drain (CODE);
		if CODE ^= 0 then do;
		     if CODE = -1
		     then goto time_err;
		     else goto common_ret;
		     end;
		call special (CODE);
		if CODE ^= 0 then do;
		     if CODE = -1 then goto err_mess;
		     else if CODE = -2 then goto wrong_stat;
		     goto common_ret;
		     end;
		end;
	     else if imess.level = "7"b3 then do;
		call special (CODE);
		if CODE ^= 0 then do;
		     if CODE = -1 then goto err_mess;
		     else if CODE = -2 then goto wrong_stat;
		     goto common_ret;
		     end;

spec_drain:
		call drain (CODE);
		if CODE ^= 0 then do;
		     if CODE = -1 then goto time_err;
		     goto common_ret;
		     end;
		if imess.level = "7"b3 then goto spec_drain;
						/* Controller has multiple connections. */
						/* Will ignore all other specials from the other channels. */
		call terminate (CODE);
		if CODE ^= 0 then do;
		     if CODE = -1 then goto err_mess;
		     else if CODE = -2 then goto wrong_stat;
		     goto common_ret;
		     end;
		end;
	     call ipc_$drain_chn (attach_mpc_data.ioi_channel, CODE);
						/* forget any extra specials. */
	     if CODE ^= 0 then goto common_ret;

	     end;

	if ^(spec_sw) & (imess.level ^= "3"b3) then goto wrong_stat;
	acode = 0;				/* went ok */

	return;

common_ret:
	acode = CODE;
	return;

wrong_stat:
	CODE = error_table_$unable_to_do_io;
	call com_err_ (CODE, name, "Unexpected level ^.3b status when ^a expected.", imess.level, error_message);
	go to common_ret;

     end do_tape_io;
%page;
drain:
     proc (acode);
dcl  acode fixed bin (35);

	acode = 0;
	call timer_manager_$reset_alarm_wakeup (my_event_wait_list.channel_id (2));
						/* Remove outstanding alarm */
	call ipc_$drain_chn (my_event_wait_list.channel_id (2), acode);
						/* Reset timer channel */
	if acode ^= 0 then return;
	call timer_manager_$alarm_wakeup (60, "11"b, my_event_wait_list.channel_id (2));
						/* Set 60 second timer */
	my_event_wait_list.n_channels = 2;		/* Waiting for i/o or timer event now */
	call ipc_$block (addr (my_event_wait_list), event_wait_info_ptr, acode);
						/* Wait for something to happen */
	if acode ^= 0 then return;
	if event_wait_info.channel_id = my_event_wait_list.channel_id (2) then do;
						/* If time out */
	     acode = -1;				/* caller knows what to do			*/
	     return;
	     end;
     end drain;
%page;
get_arg:
     proc;

	call cu_$arg_ptr_rel (argno, argp, argl, code, arg_list_ptr);
	if code ^= 0 then do;
	     call com_err_ (code, name, "Can't happen.");
	     go to error_return;
	     end;
	argno = argno + 1;
	more_args = (argno <= n_args);
	return;

put_arg:
     entry;

	argno = argno - 1;
	more_args = (argno <= n_args);
	return;

     end get_arg;
%page;


/* Function to return 1 if mpc was listed in command line.  If none were listed, 1 is returned for all mpc's */

listed_mpc:
     proc returns (bit (1));

dcl  i fixed bin;

	if mpc_cnt = 0 then return ("1"b);
	do i = 1 to mpc_cnt;
	     if log_mpc_entry.mpc_name = mpc_list (i) then return ("1"b);
	end;
	return ("0"b);

     end listed_mpc;

%page;

mpc_reg_alarm:
     proc;

dcl  (i, j, k, l) fixed bin init (0);
dcl  (hint, plural_sw) bit (1) init ("0"b);


	if log_mpc_entry.alarm then do;		/* It's happened before */
	     if (log_mpc_entry.prev_err_ctr = poll_mtp_data.interrupt_counter)
		& (log_mpc_entry.prev_err_reg = poll_mtp_data.register)
	     then return;				/* Same one */
	     if log_mpc_entry.prev_err_reg ^= poll_mtp_data.register then go to update_count;
						/* Update and notify the OPR */
	     if log_mpc_entry.prev_err_ctr ^= poll_mtp_data.interrupt_counter then do;
update_count:
		if poll_mtp_data.interrupt_counter > log_mpc_entry.prev_err_ctr
		then k = poll_mtp_data.interrupt_counter - log_mpc_entry.prev_err_ctr;
		else if poll_mtp_data.interrupt_counter < log_mpc_entry.prev_err_ctr
		then k = poll_mtp_data.interrupt_counter;

		go to send_alarm;
		end;

	     return;

	     end;

send_alarm:
	allocate mpc_stat_anal;
	if k = 0 then k = poll_mtp_data.interrupt_counter;
	if k > 1 then plural_sw = "1"b;
	log_mpc_entry.alarm = "1"b;
	log_mpc_entry.prev_err_reg = poll_mtp_data.register;
	log_mpc_entry.prev_err_ctr = poll_mtp_data.interrupt_counter;


	call decode_mpc_stats_$err_data_ (poll_mpc_datap, mpc_stat_analp);
	do i = 1 to mpc_stat_anal.num_interps;
	     if substr (mpc_stat_anal.message (i), 1, 1) = "" then return;
						/* spurious */

	     if substr (mpc_stat_anal.HINT (i), 1, 1) = " "
	     then hint = "0"b;
	     else hint = "1"b;

	     call hphcs_$syserr (3,
		"poll_mpc: MPC ^a has had ^d ^a error^[s^] since the last poll.^/^[^2-Suspect the ^a^/^]^2-Please inform your CSD representative."
		, log_mpc_entry.mpc_name, k, rtrim (mpc_stat_anal.message (i)), plural_sw, hint,
		rtrim (mpc_stat_anal.HINT (i)));

	end;

	return;
     end mpc_reg_alarm;

%page;

mpc_stat_alarm:
     proc;
dcl  k fixed bin;
dcl  plural_sw bit (1) init ("0"b);


	if log_mpc_entry.prev_stat_ctr_cnt = sum (poll_mtp_data.polled_stat_counters) then return;
						/* no change */

	if sum (poll_mtp_data.polled_stat_counters) = 0 then return;
						/* MPC booted or no errors ever */

	if sum (poll_mtp_data.polled_stat_counters) > log_mpc_entry.prev_stat_ctr_cnt then do;
						/*  an error has occurred */

	     k = (sum (poll_mtp_data.polled_stat_counters) - log_mpc_entry.prev_stat_ctr_cnt);
	     log_mpc_entry.prev_stat_ctr_cnt = sum (poll_mtp_data.polled_stat_counters);

	     if k > 1
	     then plural_sw = "1"b;
	     else plural_sw = "0"b;

	     call hphcs_$syserr (3,
		"poll_mpc: MPC ^a has had ^d PSI-LA error^[s^] since the last poll.^/^2-Please inform your CSD Representative."
		, log_mpc_entry.mpc_name, k, plural_sw);
	     end;

	return;
     end mpc_stat_alarm;

%page;

dau_err_alarm:
     proc;

dcl  (i, j, k, l) fixed bin init (0);

	if log_mpc_entry.alarm then do;		/* It's happened before */
	     if log_mpc_entry.prev_err_ctr = poll_dau_data.err_interrupts then return;
						/* Same one */
						/* Update and notify the OPR */
	     if poll_dau_data.err_interrupts > log_mpc_entry.prev_err_ctr
	     then k = poll_dau_data.err_interrupts - log_mpc_entry.prev_err_ctr;
	     else if poll_dau_data.err_interrupts < log_mpc_entry.prev_err_ctr then k = poll_dau_data.err_interrupts;

	     end;

	if k = 0 then k = poll_dau_data.err_interrupts;
	log_mpc_entry.alarm = "1"b;
	log_mpc_entry.prev_err_reg = ""b;		/* DAU doesn't have one */
	log_mpc_entry.prev_err_ctr = poll_dau_data.err_interrupts;

	call hphcs_$syserr (3,
	     "poll_mpc: DAU ^a has had ^d error^[s^] since the last poll.^/^2-Please inform your CSD representative.",
	     log_mpc_entry.mpc_name, k, (k > 1));

	return;
     end dau_err_alarm;

%page;

dau_stat_alarm:
     proc;
dcl  (k, err_sum) fixed bin;

	err_sum = sum (poll_dau_data.psi_cntr) - poll_dau_data.psi_cntr (13)
						/* PSI-0 IIW faults */
	     - poll_dau_data.psi_cntr (14)		/* PSI-1 IIW faults */
	     - poll_dau_data.psi_cntr (15)		/* PSI-2 IIW faults */
	     - poll_dau_data.psi_cntr (16);		/* PSI-3 IIW faults */
	if err_sum = 0 then return;			/* only IIW errors */
	if log_mpc_entry.prev_stat_ctr_cnt = err_sum then return;
						/* no change */

	if err_sum > log_mpc_entry.prev_stat_ctr_cnt then do;
						/*  an error has occurred */

	     k = err_sum - log_mpc_entry.prev_stat_ctr_cnt;
	     log_mpc_entry.prev_stat_ctr_cnt = err_sum;

	     call hphcs_$syserr (3,
		"poll_mpc: DAU ^a has had ^d PSI error^[s^] since the last poll.^/^2-Please inform your CSD Representative."
		, log_mpc_entry.mpc_name, k, (k > 1));
	     end;

	return;
     end dau_stat_alarm;

%page;

release_tape_mpc:
     proc (err_code, acode);
dcl  (err_code, rel_count) fixed bin;
dcl  (acode, code) fixed bin (35);

	code = acode;
	rel_count = 1;

	if err_code ^= 0
	then					/* let someone know there was an error */
	     call com_err_ (code, name, "There was an error while MPC ^a was suspended, release will be attempted.",
		attach_mpc_data.mpc_name);

	if mtp_suspended = "1"b then do;		/* Get MPC going again */
	     OP = REL_MTP;

	     if log_mpc_data.debug
	     then call ioa_ ("^a: ^a ^a (^a)", name, OPERATION (OP), attach_mpc_data.mpc_name,
		     attach_mpc_data.device_name);

RETRY_REL:
	     call build_sus_rel_idcw;
	     call do_tape_io ("1"b, code);

	     if code ^= 0 then do;
		rel_count = rel_count + 1;
		if rel_count < 4
		then go to RETRY_REL;

		else do;				/* we are in trouble */
		     call com_err_ (code, name, "Cannot release MPC ^a. Suggest reloading firmware.",
			attach_mpc_data.mpc_name);

/* Make an attempt to get IOI to release */

		     call ioi_$release_devices (attach_mpc_data.ioi_index, code);

		     call command_cleanup;		/*  and QUIT */
		     end;
		end;
	     end;

	mtp_suspended = "0"b;			/* Made it, the MPC itself is now free for io */

%page;

/* Now get IOI to allow IO on the mtp again */


	if stopped_io = "1"b then do;			/* Get IOI to allow io again */
	     OP = IOI_REL_MTP;

	     if log_mpc_data.debug
	     then call ioa_ ("^a: ^a ^a (^a)", name, OPERATION (OP), attach_mpc_data.mpc_name,
		     attach_mpc_data.device_name);

	     call ioi_$release_devices (attach_mpc_data.ioi_index, code);

	     if code ^= 0 then do;
		call com_err_ (code, name, "Call to ioi_$release_devices failed.");

/* we are really in trouble */

		call com_err_ (code, name, "Cannot release MPC ^a.", attach_mpc_data.mpc_name);

		call command_cleanup;		/*  and QUIT */
		end;
	     end;

	stopped_io = "0"b;
	acode = 0;

	return;

     end release_tape_mpc;

%page;

/* Routine to setup static data-base */

setup_static_data:
     proc;

dcl  i fixed bin;

/* First, count mpc's */

	log_mpc_data_n_mpcs = 0;
	mpc_cardp = null ();
	call config_$find ("mpc", mpc_cardp);
	do while (mpc_cardp ^= null ());
	     if substr (mpc_card.name, 1, 3) = "msp" | substr (mpc_card.name, 1, 3) = "mtp"
		| substr (mpc_card.name, 1, 3) = "urp"
	     then log_mpc_data_n_mpcs = log_mpc_data_n_mpcs + 1;
	     call config_$find ("mpc", mpc_cardp);
	end;
	if log_mpc_data_n_mpcs = 0 then do;
	     call com_err_ (0, name, "No MPC's configured. Polling not initiated.");
	     go to error_return;
	     end;

	allocate log_mpc_data;
	unspec (log_mpc_data) = "0"b;
	log_mpc_data.n_mpcs = log_mpc_data_n_mpcs;

	mpc_cardp = null ();
	do i = 1 to log_mpc_data.n_mpcs;
skip_mpc:
	     call config_$find ("mpc", mpc_cardp);
	     if substr (mpc_card.name, 1, 3) ^= "msp" & substr (mpc_card.name, 1, 3) ^= "mtp"
		& substr (mpc_card.name, 1, 3) ^= "urp"
	     then go to skip_mpc;
	     log_mpc_entryp = addr (log_mpc_data.mpc_entry (i));
	     log_mpc_entry.mpc_name = mpc_card.name;
	end;
	return;

     end setup_static_data;

%page;

/* Internal proc to handle special interrupt from suspend and release operations
   to the tape MPC */

special:
     proc (acode);
dcl  acode fixed bin (35);

	acode = 0;
	error_message = "special";
	if imess.level ^= "7"b3 then do;
	     acode = -2;				/* maps to wrong status in caller		*/
	     return;
	     end;

	call ioi_$get_special_status (attach_mpc_data.ioi_index, special_status_flag, special_status_word, acode);
	if acode ^= 0 then do;
no_special:
	     call com_err_ (acode, name, "Attempting to get special status word.");
	     return;
	     end;
	io_special_status_ptr = addr (special_status_word);
	if ^(special_status_flag | io_special_status.t) then do;
	     acode = -1;				/* caller knows what to do			*/
	     return;
	     end;
	if OP = SUS_MTP then do;
	     if log_mpc_data.debug
	     then call ioa_ ("^a: Processing SUSPEND special status for ^a: Status = ^w", name,
		     attach_mpc_data.mpc_name, special_status_word);

	     if substr (special_status_word, 27, 1)
	     then mtp_suspended = "1"b;
	     else do;				/* suspend didn't work			*/
		acode = error_table_$unable_to_do_io;
		call com_err_ (acode, name, "MTP was not suspended.");
		return;
		end;
	     end;
	else if OP = REL_MTP then do;
	     if log_mpc_data.debug
	     then call ioa_ ("^a: Processing RELEASE special status for ^a: Status = ^w", name,
		     attach_mpc_data.mpc_name, special_status_word);

	     if substr (special_status_word, 26, 1)
	     then mtp_suspended = "0"b;
	     else do;				/* release didn't work			*/
		acode = error_table_$unable_to_do_io;
		call com_err_ (acode, name, "MTP was not released.");
		return;
		end;
	     end;
     end special;
%page;
terminate:
     proc (acode);

dcl  acode fixed bin (35);

	acode = 0;
	error_message = "terminate";			/* Special interupt expected now */

	if log_mpc_data.debug
	then call ioa_ ("^a: Processing Terminate status for ^a:^/Level = ^.3b, Status = ^w", name,
		attach_mpc_data.mpc_name, imess.level, imess.status);

	if imess.level ^= "3"b3 then do;		/* If not termination */
	     acode = -2;				/* caller knows what to do			*/
	     return;
	     end;

	if imess.er then do;			/* Error */
	     call analyze_device_stat_$rsnnl (error_message, attach_mpc_data.status_tablep, (imess.status), ("0"b));
	     acode = -1;				/* caller knows what to do			*/
	     return;
	     end;

     end terminate;
%page;
/*  Internal subroutine to control the suspending, clearing of dev stats, and
   releasing of the tape controller */

suspend_mtp:
     proc (CODE);

dcl  (CODE, scode) fixed bin (35);

	call suspend_tape_mpc (scode);

	if scode ^= 0 then do;
	     call DETACH_MPC_;
	     CODE = scode;
	     return;
	     end;

	OP = WRITE_MPC_MEM;
	call build_idcw;
	call do_tape_io ("0"b, scode);		/* special case the suspend */

	if scode ^= 0 then do;
	     call release_tape_mpc (IO_ERR, scode);
	     call detach_and_count (SUS_ERR);
	     CODE = scode;
	     return;
	     end;

	call release_tape_mpc (0, 0);			/* normal release */
	CODE = 0;
	return;

     end suspend_mtp;

%page;

suspend_tape_mpc:
     proc (acode);

dcl  (code, acode, saved_code) fixed bin (35);

	stopped_io, mtp_suspended = "0"b;
	OP = IOI_SUS_MTP;

	if log_mpc_data.debug
	then call ioa_ ("^a: ^a ^a (^a)", name, OPERATION (OP), attach_mpc_data.mpc_name, attach_mpc_data.device_name);

/* This waits for all i/o to finish */

	call ioi_$suspend_devices (attach_mpc_data.ioi_index, code);


	if code ^= 0 then go to IOI_SUS_ERR;

	stopped_io = "1"b;				/* MUST remember this */
	OP = SUS_MTP;
	call build_sus_rel_idcw;
	call do_tape_io ("1"b, code);			/* now clear stat block */


	if code = 0 then do;			/* PHEW */
	     acode = 0;
	     mtp_suspended = "1"b;			/* MUST remember this also */
	     return;
	     end;
	go to SUS_MTP_ERR;


IOI_SUS_ERR:
	saved_code = code;				/* release_tape can wipe it out */
	call detach_and_count (SUS_ERR);		/* keep track of failures */
	go to com_err_ret;


SUS_MTP_ERR:
	call detach_and_count (SUS_ERR);
	call release_tape_mpc (SUS_ERR, code);		/* let him clean up */
com_err_ret:
	acode = saved_code;
	return;

     end suspend_tape_mpc;

%page;

/* Be sure all mpc's given on comnmand line are configured. */

validate_mpc_list:
     proc;

dcl  (i, j) fixed bin;

	do i = 1 to mpc_cnt;
	     do j = 1 to log_mpc_data.n_mpcs;
		log_mpc_entryp = addr (log_mpc_data.mpc_entry (j));
		if mpc_list (i) = log_mpc_entry.mpc_name then go to mpc_ok;
	     end;
	     call com_err_ (0, name, "MPC ^a is not configured, or is not pollable.", mpc_list (i));
	     mpc_list (i) = "";
	     mpc_cnt = mpc_cnt - 1;
	     go to error_return;
mpc_ok:
	end;
	return;

     end validate_mpc_list;


%page;
/*   Begin Message Documentation
   *
   *    Message:
   *    poll_mpc: Polled MPC_NAME.
   *
   *    S:     $info
   *
   *    T:     $run
   *
   *    M:     Polled the MPC identified by MPC_NAME and placed the polled
   *           data in the syserr_log.
   *
   *    Message:
   *    poll_mpc: I/O error on MPC_NAME ERROR_MESSAGE.
   *
   *    S:     $info
   *
   *    T:     $run
   *
   *    M:     poll_mpc experienced an I/O error atempting to poll the mpc.
   *           Three consecutive errors for MPC_NAME will suspend polling of
   *           this mpc.
   *
   *    Message:
   *    poll_mpc: MPC MPC_NAME has had X ERROR_NAME error(s) since the last poll.
   *
   *              SUSPECT the YYY wwb. (If known).
   *
   *              Please inform your CSD representative.
   *
   *     S:     $beep
   *
   *     T:     $run
   *
   *     M:     An internal mpc error, error data register or LA-PSI error counter,
   *            was detected in the named MPC. The number of errors detected since
   *            the last poll is identified by X. The type of error identified by
   *            ERROR_NAME is an interpretation of the register or counter name,
   *            i.e., X/Y OPERAND PARITY ERROR. In some cases a board causing
   *            the error can be identified. if this is the case the SUSPECT board
   *            will be identified by YYY to aid the FE.
   *
   *     A:     Call CSD.
   *            If the subsystem serviced by this MPC is experiencing other
   *            errors or the errors encountered between polling cycles is
   *            increasing remove the MPC from service, if possible. This is
   *            important for disk subsystems as file system damage may
   *            occur.
   *
   *     END MESSAGE DOCUMENTATION */

%page;
%include attach_mpc_data;
%page;
%include config_mpc_card;
%page;
%include event_call_info;
%page;
%include iom_pcw;
%page;
%include iom_dcw;
%page;
%include ioi_stat;
%page;
%include dump_mpc_data;
%page;
%include iox_modes;
%page;
%include poll_mpc_data;
%page;
%include syserr_binary_def;
%page;
%include event_wait_info;
%page;
%include eurc_model_numbers;
%page;
%include io_special_status;

     end poll_mpc;
