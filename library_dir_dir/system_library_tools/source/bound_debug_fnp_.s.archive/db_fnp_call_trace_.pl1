/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */


/* DB_FNP_CALL_TRACE_ - A procedure to decode a subroutine calling chain in a FNP dump */
/* Written Spetember 1978 by Larry Johnson */

/* This module contains a great deal of imbedded knowledge about how the fnp procedure generate calls.
   It uses a set of heuristics to search backwards from a given starting point to find
   the object code generated by a 'subr' macro. */

/* The following is a detailed description of the subr sequence:

   .	name	ind	0		entry point, and return address word

   .	*	If 'inh' is used, the following is generated

   .		sti	namsi-*		save current indicators
   .		inh			and mask interrupts

   .	*	Next, individual registers are saved.
   .	*	0-6 register saves may follow here selected from (a,q,x1,x2,x3,i)

   .		sta	namsa-*
   .		stx1	namsx1-*
   .		stx3	namsx3-*

   .	*	Now branch to body of subroutine.

   .		tra	start-*

   .	*	For the conveniece of the return macro, the subroutine exit
   .	*	sequence is generated here. The return macro transfers
   .	*	to this point.

   .	*	First, reload all saved registers

   .		lda	namsa-*
   .		ldx1	namsx1-*
   .		ldx3	namsx3-*
   .		ldi	namsi-*

   .	*	And return.

   .		tra	name-*,*

   .	*	Someday, a subroutine name may be stored here, in bcd. This is not
   .	*	done now, but would appear as follows:

   .		bci	6/name

   .	*	Next follows save area for all saved registers

   .	namsi	bss	1
   .	namsa	bss	1
   .	namsx1	bss	1
   .	namsx3	bss	1

   .	*	Next comes the body of the subroutine

   .	start	null
*/

db_fnp_call_trace_: proc (arg_corep, arg_fnp, arg_cmd_infop, arg_expr_infop);

/* Parameters */

dcl  arg_corep ptr;
dcl  arg_fnp fixed bin;
dcl  arg_cmd_infop ptr;
dcl  arg_expr_infop ptr;

/* Automatic */

dcl  i fixed bin;
dcl  code fixed bin (35);
dcl  corep ptr;
dcl  fnp fixed bin;
dcl  debug_sw bit (1);				/* Set if -debug used */
dcl  long_sw bit (1);				/* Set if -long used */
dcl  trace_addr fixed bin;

dcl  mem_buf (0:511) bit (18) unal;			/* To hold memory data */
dcl  buf_org fixed bin;				/* Starting address of stuff in mem_buf */
dcl  n_words_in_buf fixed bin;			/* Count of good words */

/* Static */

dcl  constants_setup bit (1) int static init ("0"b);	/* Set when static initialized */
dcl  ld_opcodes (6) bit (18) unal int static;		/* Opcodes of load instruction */
dcl  st_opcodes (6) bit (18) unal int static;		/* Opcodes of store instructions */
dcl  tra bit (18) int static;				/* Opcode of tra instruction */
dcl  inh bit (18) int static;				/* Opcode of inhibit instruction */

/* Constants */

dcl  name char (18) int static options (constant) init ("db_fnp_call_trace_");
dcl  reg_names (6) char (2) int static options (constant) init ("i", "a", "q", "x1", "x2", "x3");
dcl  opmask bit (18) int static options (constant) init ("077000"b3);

/* External */

dcl  ioa_ entry options (variable);
dcl  com_err_ entry options (variable);
dcl  db_fnp_eval_ entry (ptr, fixed bin, char (*), ptr, char (*), fixed bin, fixed bin (35));
dcl  db_fnp_reader_$get_operand entry (ptr);
dcl  db_fnp_edit_inst_$assemble entry (ptr, fixed bin, char (*), ptr, bit (18), fixed bin (35));
dcl  sub_err_ entry options (variable);
dcl  db_fnp_memory_$fetch entry (ptr, fixed bin, fixed bin, fixed bin, ptr, fixed bin (35));
dcl  db_fnp_util_$edit_module_addr_paren entry (ptr, fixed bin, fixed bin, char (*) var, fixed bin (35));

dcl (addr, bin, dim, hbound, max, min, null, string, unspec, substr) builtin;

/* Copy arguments */

	fnp = arg_fnp;
	corep = arg_corep;
	expr_infop = arg_expr_infop;
	cmd_infop = arg_cmd_infop;
	if ^constants_setup then call setup_constants;

/* First argument is address to trace from */

	call db_fnp_reader_$get_operand (cmd_infop);
	if cmd_info.error then go to error_return;
	if cmd_info.endline then do;
	     call ioa_ ("Address missing.");
	     go to error_return;
	end;
	call db_fnp_eval_ (corep, fnp, operand, expr_infop, "", trace_addr, code);
	if code ^= 0 then go to error_return;

/* Remaining arguments are control arguments */

	debug_sw, long_sw = "0"b;
	call db_fnp_reader_$get_operand (cmd_infop);
	if cmd_info.error then go to error_return;
	do while (^cmd_info.endline);
	     if operand = "-long" | operand = "-lg" then long_sw = "1"b;
	     else if operand = "-debug" | operand = "-db" then debug_sw = "1"b;
	     else do;
		call ioa_ ("Unrecognized operand: ^a", operand);
		go to error_return;
	     end;
	     call db_fnp_reader_$get_operand (cmd_infop);
	     if cmd_info.error then go to error_return;
	end;

/* Now loop backwards decoding subroutine levels */

	call trace_level;
	do while (trace_addr ^= 0);
	     call trace_level;
	end;

	return;

error_return:
	cmd_info.flush = "1"b;
	return;


/* Procedure that does the  real work of finding a subr */

trace_level: proc;

dcl  i fixed bin;
dcl  w bit (18);
dcl  tra_addr fixed bin;				/* Address if the  second tra instruction */
dcl  ca fixed bin;					/* Current address during scan */
dcl  fb8 fixed bin (8) unal;				/* For bit->fixed conversions */
dcl  st_found (6) bit (1) unal;			/* Mask saying which store instructions found */
dcl  ld_found (6) bit (1) unal;			/* Mask saying which load instructions found */
dcl  ld_target (6) fixed bin;				/* Targets of the ld instructuons */
dcl  max_target fixed bin;
dcl  n_loads fixed bin;
dcl  target fixed bin;
dcl  msg char (64) var;

dcl 1 mi unal,					/* Machine instruction */
    2 i bit (1),					/* Indirect bit */
    2 x bit (2),					/* Index register */
    2 c bit (6),					/* Opcode */
    2 d bit (9);					/* Displacement */

/* Start with address given */

	     ca = trace_addr + 1;

/* Look backwards for a tra instruction.  It must have indirection, no index register,
   and a negative displacement. This the tra that returns from the subr. */

tra_scan:	     ca = ca - 1;
	     w = get_word (ca);			/* Read word */
	     if (w & opmask) ^= tra then go to tra_scan;
	     string (mi) = w;
	     if ^mi.i then go to tra_scan;		/* No indirection */
	     if mi.x then go to tra_scan;		/* Index present */
	     if ^substr (mi.d, 1, 1) then go to tra_scan; /* Displacement not negative */

	     tra_addr = ca;				/* Save address of tra */
	     if debug_sw then call ioa_ ("Fould likely tra at ^a: ^.3b", ed (ca), w);

/* The tra should be preceeded by 0-6 ldxx instructions. All should have no indirection,
   no index register, and an effective address greater than the tra */

	     string (st_found) = "0"b;
	     string (ld_found) = "0"b;
	     n_loads = 0;
	     max_target = tra_addr;

ldxx_scan:     ca = ca - 1;
	     w = get_word (ca);
	     do i = 1 to hbound (ld_opcodes, 1);	/* See if some kind of load */
		if (w & opmask) = ld_opcodes (i) then do; /* Got it */
		     string (mi) = w;
		     if mi.i | mi.x then do;		/* These both should be zero */
ldxx_scan_fail:		if debug_sw then call ioa_ ("ldxx scan failed at ^a: ^.3b", ed (ca), w);
			ca = tra_addr;		/* Back to tra */
			go to tra_scan;		/* And go look for new likely tra */
		     end;
		     if ld_found (i) then go to ldxx_scan_fail; /* Already had one of these */
		     unspec (fb8) = mi.d;		/* Get  signed displacement */
		     target = ca + fb8;		/* Effective address */
		     if target <= tra_addr then go to ldxx_scan_fail;
		     n_loads = n_loads + 1;		/* This is good load */
		     ld_found (i) = "1"b;
		     ld_target (i) = target;
		     max_target = max (max_target, target);
		     go to ldxx_scan;
		end;
	     end;

/* Found a non-ldx opcode. This should be the entry sequence tra to max_target */

	     if (w & opmask) ^= tra then go to ldxx_scan_fail; /* Not a tra */
	     string (mi) = w;			/* To check other fields */
	     if mi.i | mi.x then go to ldxx_scan_fail;
	     unspec (fb8) = mi.d;
	     target = ca + fb8;			/* Target of tra */
	     if n_loads > 0 then			/* If there were loads, .. */
		if target ^= (max_target + 1) then go to ldxx_scan_fail; /* Should point immiditely after save areas */
		else;				/* It does, ok */
	     else if target ^= max_target + 1 then	/* No loads, target should be here */
		if target ^= max_target + 3 then	/* Or here, to allow for two word name someday */
		     go to ldxx_scan_fail;		/* No good target */

/* The middle tra is good. Need to check preceeding stxx instructions */

stxx_scan:     ca = ca - 1;
	     w = get_word (ca);
	     if string (st_found) = string (ld_found) then go to stxx_scan_done; /* All loads have been matched by stores */
	     do i = 1 to hbound (st_opcodes, 1);	/* Look up in store list */
		if (w & opmask) = st_opcodes (i) then do; /* A match */
		     string (mi) = w;		/* For further analysis */
		     if mi.i | mi.x then do;		/* Can't have these */
stxx_scan_fail:		if debug_sw then call ioa_ ("stxx scan failed at ^a: ^.3b", ed (ca), w);
			ca = tra_addr;		/* Back to tra scanning */
			go to tra_scan;
		     end;
		     unspec (fb8) = mi.d;
		     target = ca + fb8;		/* Target of stxx */
		     if ^ld_found (i) then go to stxx_scan_fail; /* No corresponding ldxx instruction */
		     if ld_target (i) ^= target then go to stxx_scan_fail; /* Target must be same */
		     if st_found (i) then go to stxx_scan_fail; /* Duplicate */
		     st_found (i) = "1"b;
		     go to stxx_scan;
		end;
	     end;

/* All stxx instructions have been scanned. The only possible discrepency left between loads and stores,
   is a missing sti, which will occur if 'inh' is used in subr */

	     if string (st_found) ^= string (ld_found) then do; /* There is discrepency */
		if (string (st_found) | "100000"b) ^= string (ld_found) then go to stxx_scan_fail; /* Not just missing sti */
		if w ^= inh then go to stxx_scan_fail;	/* Expect inh instruction here */
		ca = ca - 1;
		w = get_word (ca);
		if (w & opmask) ^= st_opcodes (1) then	/* This better be missing sti */
		     go to stxx_scan_fail;		/* No, too bad */
		ca = ca - 1;
		w = get_word (ca);			/* Read retrun address word */
	     end;

stxx_scan_done:

/* Scan is all done. current word is return address */

	     i = trace_addr;			/* Hold starting addr */
	     trace_addr = 0;
	     if w = "000000"b3 then msg = "never called";
	     else if w = "000001"b3 then do;
		msg = "called form master dispatcher";
		ca = ca + 3;			/* Space over dummy subr */
	     end;
	     else if w = "000002"b3 then do;
		msg = "called from secondary dispatcher";
		ca = ca + 3;
	     end;
	     else do;
		trace_addr = bin (w);		/* For pervious level */
		msg = "called from " || ed (trace_addr);
	     end;

	     call ioa_ ("^a in subr at ^a, ^a", ed (i), ed (ca), msg);

	     if long_sw then do;
		do i = 1 to hbound (reg_names, 1);
		     if ld_found (i) then call ioa_ ("^-^4a^.3b", reg_names (i), get_word (ld_target (i)));
		end;
	     end;

	     return;

	end trace_level;

/* Procedure to manage internal memory buffer. If the word requested is in the buffer, it is returned.
   Otherwise, a new buffer is read with the current address near the end. This allows a small amount of forward scanning
   and a large amount of backeards scanning before more memory must be read */

get_word:	proc (ad) returns (bit (18));

dcl  ad fixed bin;

	     if n_words_in_buf = 0 then do;		/* Empty, must read */
read_new_buf:	buf_org = (max (0, ad - (dim (mem_buf, 1) - 32)));
		if debug_sw then call ioa_ ("Reading memory locations ^o-^o", buf_org, buf_org + hbound (mem_buf, 1));
		call db_fnp_memory_$fetch (corep, fnp, buf_org, dim (mem_buf, 1), addr (mem_buf), code);
		if code ^= 0 then do;
		     call com_err_ (code, name, "Unable to read ^o-^o", buf_org, buf_org + hbound (mem_buf, 1));
		     go to error_return;
		end;
		n_words_in_buf = dim (mem_buf, 1);
	     end;

	     if ad < buf_org | ad > buf_org + n_words_in_buf - 1 then /* Not in current window */
		go to read_new_buf;

	     return (mem_buf (ad - buf_org));

	end get_word;

/* Prccodure to return edited module address */

ed:	proc (ad) returns (char (32) var);

dcl  ad fixed bin;
dcl  temp char (32) var;

	     call db_fnp_util_$edit_module_addr_paren (corep, fnp, ad, temp, code);
	     if code ^= 0 then do;
		call com_err_ (code, name, "Unable to edit ^o.", ad);
		go to error_return;
	     end;

	     return (temp);

	end ed;

/* Compute some baseic needed for life of process */

setup_constants: proc;

dcl  i fixed bin;

	     inh = opc ("inh");			/* Inhibit instruction */
	     tra = opc ("tra");			/* Tra instruction */
	     do i = 1 to hbound (reg_names, 1);
		st_opcodes (i) = opc ("st" || reg_names (i));
		ld_opcodes (i) = opc ("ld" || reg_names (i));
	     end;
	     constants_setup = "1"b;
	     return;

	end setup_constants;

opc:	proc (opname) returns (bit (18));

dcl  opname char (*);
dcl  inst bit (18);

	     call db_fnp_edit_inst_$assemble (corep, fnp, opname, expr_infop, inst, code); /* "assemble" into instruction */
	     if code ^= 0 then call sub_err_ (code, name, "s", null, (0), "Unable to get opcode for ""^a"".", opname);
	     return (inst);

	end opc;

%include debug_fnp_data;

     end db_fnp_call_trace_;
