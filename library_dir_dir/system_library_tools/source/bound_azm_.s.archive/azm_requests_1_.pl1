/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(87-01-14,Parisek), approve(87-07-09,MCR7746),
     audit(87-07-17,Fawcett), install(87-07-28,MR12.1-1049):
     Check online libraries for segment when "display" cannot locate it in the
     translation_table (when instruction format is not wanted).  Print message
     stating seg was not found in fdump, then display data from online copy.
     (phx19329).
  2) change(87-01-16,Parisek), approve(87-07-09,MCR7746),
     audit(87-07-17,Fawcett), install(87-07-28,MR12.1-1049):
     Bypass call to amu_$fdump_mpt_revert_idx if segment was previously
     replaced by another segment (via "replace" request) so the subsequent
     call to amu_$get_name_ will return the replaced segment path.
  3) change(87-02-24,Parisek), approve(87-07-09,MCR7746),
     audit(87-07-17,Fawcett), install(87-07-28,MR12.1-1049):
     If structure name given with display -as is "dte" then interpret it as
     ioi_dte as defined in the structure_names info segment.
                                                   END HISTORY COMMENTS */


azm_requests_1_: proc ();

	return;					/* not an entrypoint */

/* format: style4,delnl,insnl,ifthenstmt,indnoniterend,ifthendo,ifthen,^thendo */


/* Assorted requests for analyze_multics. */

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* 0) Created: 06/25/83 by B. Braun to divide up old azm_misc_requests_. This module	*/
	/* contains the requests apte, aste, machine_conditions, list_processes, select_process,	*/
	/* history_regs, apply, display, display_absolute, sdw, configuration_deck.		*/
	/*									*/
          /* Modified 19 Jan 84 by BLB changes to machine_conditions so -prds and -pds accept long  */
	/* names (phx16722), interprets a virt-addr better (phx16723) drop EIS data from default  */
	/* mc output (phx16724), fix mc -dump so doesn't fault thru invalid ptr.                  */
	/* Modified 19 Jan 84 by BLB changes to list_processes so -count in AF works (phx16580)   */
	/* Modified 03 Oct 84 by BLB to fix "mc -anything -pds".				*/
	/* Modified 18 Oct 84 by BLB to fix aste to work with unpaged_page_tables.		*/
	/* Modified 08 Nov 84 by BLB to fix display AF error message.			*/
	/* Modified 21 Jan 85 by BLB to fix sdw request, to print all sdws, not just ones where   */
	/*      the directed fault bit is on.						*/
	/* Modified March 86 by P. Leatherman to fix core map entry offset.                       */
	/* Modified March 86 by P. Leatherman to fix pointers arg to the mc request.              */
	/* Modified March 86 by P. Leatherman to have the display command say if the segment      */
	/* isn't in the dump and then search hardcore for it.                                     */
          /*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

dcl  (
     P_sci_ptr pointer,
     P_azm_info_ptr pointer
     ) parameter;

/* Automatic */

dcl  PTWF char (32);
dcl  af_sw bit (1) aligned;
dcl  arg_position fixed bin;
dcl  all_sw bit (1);
dcl  axp ptr init (null);
dcl  apte_array_ptr ptr;
dcl  apte_array_index fixed bin;
dcl  apte_offset fixed bin (18);
dcl  argl fixed bin (21);
dcl  argno fixed bin;
dcl  argp pointer;
dcl  axstring char (9) init ("");
dcl  bd_sdw fixed bin (24);
dcl  bitcount fixed bin(35);
dcl  block fixed bin;
dcl  brief_sw bit (1) init ("0"b);
dcl  cleanup condition;
dcl  cdevadd char (16);
dcl  coremaptr ptr;
dcl  code fixed bin (35);
dcl  command_arg fixed bin;
dcl  cond_frame bit (1);
dcl  config_arg_str char (256) var;
dcl  core_add fixed (18);
dcl  configp ptr init (null);
dcl  copy_ptr pointer;
dcl  cpu_name char (1);
dcl  cpu_sw bit(1);
dcl  cur_sw bit(1);
dcl  cur_erf bit (1) init ("0"b);
dcl  ct_sw bit(1);
dcl  data_buf_ptr ptr;
dcl  dbr fixed bin (24);
dcl  dbr_sw bit(1);
dcl  del_cur_erf bit (1) init ("0"b);
dcl  del_erf bit (1) init ("0"b);
dcl  devadd bit (22);
dcl  devadd_nulled_flag bit (1) defined (devadd);
dcl  devadd_record_no bit (18) defined (devadd);
dcl  devadd_add_type bit (4) defined (devadd) pos (19);
dcl  dir_name char (168);
dcl  dir_name_lth fixed bin;
dcl  dir_sw bit (1) init ("0"b);
dcl  display_ptr pointer;
dcl  display_size fixed bin (18);
dcl  dsegp ptr init (null);
dcl  erfs_found bit (1) init ("0"b);
dcl  entryname char (32);
dcl  expand_ptr_sw bit (1) init ("0"b);
dcl  expand_sw bit (1) init ("0"b);			/* "1"b = expand syserr binary data */
dcl  interpreted_hregs bit (1);
dcl  fdevadd fixed (18);
dcl  first fixed bin (18);
dcl  first_segno fixed bin;
dcl  first1 fixed bin (18);
dcl  first_erf bit (1) init ("0"b);
dcl  first_ptr_arg fixed bin;
dcl  first_value_set bit (1) init ("0"b);
dcl  forward_search bit (1) init ("0"b);
dcl  frame_entry bit (1) init ("0"b);
dcl  1 hard_ptr_space like hardcore_cur;
dcl  header_sw bit(1);
dcl  hdr_printed bit (1) init ("0"b);
dcl  hold_index fixed bin;
dcl  hr_switches bit (5);
dcl  hregs_from_dump bit (1);
dcl  hregs_from_pds bit (1);
dcl  hregs_fm_ptrval bit (1);
dcl  ignore fixed bin;
dcl  index_changed bit (1);
dcl  is_wired bit (1);
dcl  is_paged bit (1);
dcl  (i, k) fixed bin;				/* for iterations */
dcl  last fixed bin init (0);
dcl  last_erf bit (1) init ("0"b);
dcl  last_ptw bit (36);
dcl  last_segno fixed bin;
dcl  list_erfs bit (1) init ("0"b);
dcl  list_state(0:6) bit(1);
dcl  ll fixed bin init (0);
dcl  ln fixed bin init (0);
dcl  long_sw bit (1);
dcl  match_names (10) char (32) varying;
dcl  match_str char (256) var init ("");		/* the syserr string to match on */
dcl  mc_from_ptrval bit (1);

dcl  1 mc_area like mc;
dcl  mc_arg bit (36) aligned;			/* place in stack to keep the arg bits passed to azm_display_mc_ */
dcl  mcp_fim_sw bit (1);
dcl  mcp_pgflt_sw bit (1);
dcl  mcp_sig_sw bit (1);
dcl  mcpr_fim_sw bit (1);
dcl  mcpr_int_sw bit (1);
dcl  mcpr_systroub_sw bit (1);
dcl  mem_addr fixed bin (24);
dcl  mem_dump bit (1);
%page;
dcl  1 modes_sw aligned,
       2 char_sw bit (1) unal,
       2 inst_sw bit (1) unal,
       2 bcd_sw bit (1) unal,
       2 ptr_sw bit (1) unal,
       2 pptr_sw bit (1) unal,
       2 bit4_sw bit (1) unal,
       2 ebcdic8_sw bit (1) unal,
       2 ebcdic9_sw bit (1) unal;
dcl  mem_tag fixed bin;
dcl  n_match_names fixed bin;
dcl  n_subscripts fixed bin;
dcl  nargs fixed bin;
dcl  new_range fixed bin (21);
dcl  next_erf bit (1) init ("0"b);
dcl  no_aste_tr_info bit(1);
dcl  offset fixed bin (18);
dcl  only_au bit (1);
dcl  only_cu bit (1);
dcl  only_du bit (1);
dcl  only_ou bit (1);
dcl  octal_sw bit(1);
dcl  outername char (32);
dcl  pidbit			bit(36);
dcl  pid	fixed bin(36);
dcl  pcd_args char (256);
dcl  pcd_argsp ptr;
dcl  pcd_args_len fixed bin (21);
dcl  pds_sw bit (1);
dcl  prev_erf bit (1) init ("0"b);
dcl  prds_sw bit (1);
dcl  print_all_trans bit (1) init ("0"b);
dcl  proc_ptr pointer;
dcl  procl  fixed bin(21);
dcl  proc_sw bit(1);
dcl  process_idx fixed bin;
dcl  pts fixed bin (24);
dcl  pvtx_name char (16) varying;
dcl  range fixed bin (18);
dcl  range1 fixed bin (18);
dcl  range_value_set bit (1) init ("0"b);
dcl  raw_syserr_data bit (1) init ("0"b);		/* "1"b = print it in octal */
dcl  real_address fixed bin (35);
dcl  reason char (80) var;
dcl  repeat_ bit (1);
dcl  ret_str char (168) var init ("");
dcl  rv_lth fixed bin (21);
dcl  rv_ptr ptr;
dcl  sci_ptr pointer;				/* assorted info pointers */
dcl  sdw_address fixed bin(26);
dcl  segln fixed bin (35) init (0);
dcl  segno fixed bin;
dcl  segno1 fixed bin;
dcl  sigstp ptr;
dcl  slog_code fixed bin init (3);			/* the syserr_code, default to =< 3 */
dcl  sptp ptr;
dcl  start_configp ptr init (null);
dcl  str char (16);
dcl  struct_name char (256) varying;
dcl  struct_sw bit (1) init ("0"b);
dcl  subscripts (2, 16) fixed bin (24);
dcl  symbol_ptr ptr;
dcl  t_pr_name char (4);
dcl  temp_name char (32);
dcl  temp_num fixed bin;
dcl  temp_ptr ptr;
dcl  temp_ptr1 ptr;
dcl  temp_range fixed bin (18);
dcl  temp_str char (24) var init ("");
dcl  threaded_hregs bit (1);
dcl  tally_states (0:6) fixed bin;
dcl  totals_only  bit(1);
dcl  trailer_sw bit (1);
dcl  unsubscripted_name char (256);
dcl  vs char (99) varying;
dcl  why_erf bit (1) init ("0"b);
%page;

/* Based */

dcl  1 apte_array (apte_array_index) based (apte_array_ptr),
       2 ptr ptr,
       2 off fixed bin (18),
       2 index fixed bin;

dcl  arg char (argl) based (argp);
dcl  proc_arg char (procl) based (proc_ptr);
dcl  pt_word fixed based (ptp);
dcl  ret_ptr ptr based (data_buf_ptr);
dcl  rv_str char (rv_lth) varying based (rv_ptr);
dcl  RS (range) bit (36) based (data_buf_ptr);
dcl  RSP (range) ptr aligned based (data_buf_ptr);
dcl  RSPP (range) ptr unal based (data_buf_ptr);

dcl  1 sig_stack like signaller_stack based (sigstp);


/* Constants */

dcl  CPU_NAME char (8) init ("abcdefgh") internal static options (constant);

dcl  (RUN				init(1),
      RDY				init(2),
      WAIT			init(3),
      BLK				init(4),
      STP				init(5),
      PTL				init(6)) 
			fixed bin int static options (constant);

dcl  process_st (0:6) char (9) varying int static options (constant)
	init ("empty", "running", "ready", "waiting", "blocked", "stopped", "ptlocking");

/* Builtins */

dcl  (addr, addrel, baseno, baseptr, 
      char, convert, divide, fixed, hbound,
      index, lbound, length, ltrim, mod, null,
      pointer, rel, rtrim, size, substr, unspec) builtin;

/* Conditions */

%page;

/* External Entries */

dcl  adjust_bit_count_		entry (char(168), char(32), bit(1) aligned, fixed bin(35), fixed bin(35));
dcl  amu_$definition_ptr		entry (ptr, char (*), char (*), fixed bin (35)) returns (ptr);
dcl  amu_$definition_set_from		entry (ptr, char (*), ptr, fixed bin (35));
dcl  amu_$definition_get_prn		entry (ptr, char (*), ptr, fixed bin (35));
dcl  amu_$definition_set_prn		entry (ptr, char (*), fixed bin, fixed bin (18), fixed bin (35));
dcl  amu_$do_translation		entry (ptr, fixed bin, ptr, fixed bin (18), fixed bin (18), fixed bin (35));
dcl  amu_$do_translation_hunt_ptr	entry (ptr, ptr, ptr, fixed bin (35));
dcl  amu_$do_translation_hunt		entry (ptr, fixed bin, ptr, fixed bin (18), fixed bin (18), fixed bin (35));
dcl  amu_$error_for_caller		entry () options (variable);
dcl  amu_$fdump_mpt_fill_proc_table	entry (ptr, fixed bin (24), fixed bin, char (1), bit(1), fixed bin (35));
dcl  amu_$fdump_mpt_current_process	entry (ptr);
dcl  amu_$fdump_mpt_current_process_af	entry (ptr, ptr, fixed bin (21));
dcl  amu_$fdump_mpt_temp_change_idx	entry (ptr, fixed bin);
dcl  amu_$fdump_mpt_change_idx	entry (ptr, fixed bin);
dcl  amu_$fdump_mpt_revert_idx	entry (ptr);
dcl  amu_$fdump_translate_to_temp_seg	entry (ptr, ptr, ptr, fixed bin (35));
dcl  amu_$get_name_no_comp		entry (ptr, ptr) returns (char (*));
dcl  amu_$get_name			entry (ptr, ptr) returns (char (*));
dcl amu_$get_segno_from_name		entry (ptr, ptr, char(*), fixed bin, fixed bin(35));
dcl amu_$get_va_args		entry (ptr, ptr, ptr, fixed bin, ptr);
dcl amu_$get_va_args_given_start	entry (ptr, ptr, ptr, fixed bin, fixed bin, ptr);
dcl  amu_$hardcore_info_set_cur_ptrs	entry (ptr, ptr);
dcl  amu_$print_char_dump		entry (ptr, fixed bin (18), fixed bin (18));
dcl  amu_$print_char_dump_af		entry (ptr, fixed bin (18), fixed bin (18), ptr, fixed bin(21));
dcl  amu_$print_apte		entry (ptr, ptr, fixed bin (18), fixed bin);
dcl  amu_$print_dump_oct		entry (ptr, fixed bin (18), fixed bin (18));
dcl  amu_$print_dump_pptr		entry (ptr, fixed bin (18), fixed bin (18));
dcl  amu_$print_dump_pptr_exp		entry (ptr, ptr, fixed bin (18), fixed bin (18));
dcl  amu_$print_dump_ptr		entry (ptr, fixed bin (18), fixed bin (18));
dcl  amu_$print_dump_ptr_exp		entry (ptr, ptr, fixed bin (18), fixed bin (18));
dcl  amu_$print_inst_dump		entry (ptr, fixed bin (18), fixed bin (18));
dcl  amu_$return_val_per_process	entry (ptr, fixed bin) returns (bit (1));
dcl  amu_$slt_search_seg_ptr		entry (ptr, ptr, char (32), ptr, fixed bin (35));
dcl amu_$tc_data_get_apt_entry	entry (ptr, fixed bin, bit(36), fixed bin(18), ptr, fixed bin);
dcl  amu_$tc_data_get_dbr		entry (ptr, fixed bin (18), fixed bin (24));
dcl  amu_$translate_get		entry (ptr, fixed bin, ptr, fixed bin (35));
dcl  amu_$translate_force_add		entry (ptr, ptr, fixed bin, fixed bin (35));
dcl  display_data_$for_azm		entry (pointer, bit (*) aligned, (*) char (*) varying, fixed bin, pointer,
     pointer, fixed bin (18), pointer, pointer, (2, *) fixed bin (24), fixed bin, fixed bin (35));
dcl  azm_display_mc_		entry (ptr, ptr, ptr, ptr, fixed bin (35));
dcl  azm_dump_mem_			entry (ptr, fixed bin (24), fixed bin, fixed bin, fixed bin (18), fixed bin, bit (1), bit (1), fixed bin (35));
dcl  azm_find_mem_box_$bf		entry (ptr, fixed bin (35), fixed bin, fixed bin (18), fixed bin (35));
dcl  hran_$bos_no_thread		entry (ptr, ptr, bit (5));
dcl  hran_$hran_bos		entry (ptr, ptr, bit (1));
dcl  hran_$hranl		entry (ptr, ptr, bit (1));
dcl  hran_$no_thread		entry (ptr, ptr, bit (5));
dcl  azm_str_util_			entry (ptr, bit (18), fixed bin (35));
dcl  cu_$cp			entry (ptr, fixed bin (21), fixed bin (35));
dcl  (cv_dec_check_, cv_oct_check_)	entry (char (*), fixed bin (35)) returns (fixed bin (35));
dcl  date_time_			entry (fixed bin (71), char (*));
dcl dump_segment_			entry (ptr, ptr, fixed bin, fixed bin(18), fixed bin(18), bit(*));
dcl dump_segment_$string		entry (ptr, fixed bin(21), ptr, fixed bin, fixed bin(18), fixed bin(18), bit(*));
dcl  get_line_length_$switch		entry (ptr, fixed bin (35)) returns (fixed bin);
dcl  hcs_$fs_get_path_name		entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
dcl  (
     ioa_,
     ioa_$nnl,
     ioa_$rsnnl
     ) entry options (variable);
dcl iox_$user_output		ptr ext static;
dcl  ssu_$abort_line		entry options (variable);
dcl  ssu_$apply_request_util		entry (ptr, fixed bin, ptr, fixed bin (21), fixed bin (21));
dcl  ssu_$arg_count			entry (pointer, fixed bin, bit (1) aligned);
dcl  ssu_$arg_ptr			entry (pointer, fixed bin, pointer, fixed bin (21));
dcl  ssu_$get_temp_segment		entry (ptr, char(*), ptr);
dcl  ssu_$print_message		entry options (variable);
dcl  ssu_$release_temp_segment	entry (ptr, ptr);
dcl  ssu_$return_arg		entry (ptr, fixed bin, bit (1) aligned, ptr, fixed bin (21));
dcl ssu_$get_subsystem_and_request_name
				entry (ptr) returns(char(72) var);
dcl  structure_ref_$parse		entry (char (*), char (*), char (*), 
     (2, *) fixed bin (24), fixed bin, (*) char (*) varying, fixed bin, fixed bin (35));
dcl  structure_find_$search		entry (char (*), pointer, fixed bin (35));
dcl  sys_info$max_seg_size fixed bin (35) ext static;

/* error codes */

dcl  amu_et_$big_idx fixed bin (35) external static;
dcl  amu_et_$dbr_not_found fixed bin (35) external static;
dcl  amu_et_$free_core fixed bin (35) external static;
dcl  amu_et_$invalid_segno fixed bin (35) ext static;
dcl  amu_et_$neg_range fixed bin (35) ext static;
dcl  amu_et_$no_translation fixed bin (35) ext static;
dcl  amu_et_$not_implemented fixed bin (35) ext static;
dcl  amu_et_$not_stack_seg  fixed bin (35) ext static;
dcl  amu_et_$proc_not_dumped fixed bin (35) ext static;
dcl  amu_et_$seg_not_dumped fixed bin (35) ext static;
dcl  error_table_$badopt fixed bin (35) external static;
dcl  error_table_$noarg fixed bin (35) external static;
dcl  error_table_$bad_arg fixed bin (35) external static;
dcl  error_table_$inconsistent fixed bin (35) external static;
dcl  error_table_$too_many_args fixed bin (35) external static;
%page;
azm_requests_1_$apte:
     entry (P_sci_ptr, P_azm_info_ptr);

    call set_up;
    if ^trans_selected () then call ssu_$abort_line (sci_ptr, 0, "No dump selected.");

    apte_array_ptr = null();
    on cleanup begin;
       if apte_array_ptr ^= null () then 
	call ssu_$release_temp_segment (sci_ptr, apte_array_ptr);
	end;

    call process_common_args();

    call ssu_$get_temp_segment (sci_ptr, "azm-apt", apte_array_ptr);

    if ^proc_sw & ^cur_sw then do;
       do i = 1 to hbound(list_state, 1);
          apte_array_index = 0;
	if list_state(i) then do;
	   call amu_$tc_data_get_apt_entry (amu_info_ptr, i, "0"b, -1, apte_array_ptr, apte_array_index);
	   tally_states(i) = apte_array_index;
	   if apte_array_index = 0 & ^(all_sw | ct_sw) then call ioa_("No aptes in the ^a state.", process_st(i));
	   do k = 1 to apte_array_index;
	      if ^totals_only then call amu_$print_apte (amu_info_ptr, apte_array (k).ptr, apte_array (k).off, 
	                            apte_array (k).index);
	      end;
             end;
          end;
       if ct_sw then call print_totals();
       end;

    else do;
       if cur_sw then process_idx = amu_info.process_idx;
       else call determine_process_idx(apte_offset, pid, process_idx);

       if process_idx >= 0 then do;
          if process_idx > hbound (fdump_process_table.array, 1) then 
             call ssu_$abort_line (sci_ptr, amu_et_$big_idx, "^a.", proc_arg);

          hold_index = amu_info.process_idx;
          call amu_$fdump_mpt_temp_change_idx (amu_info_ptr, hold_index);
          call amu_$fdump_mpt_change_idx (amu_info_ptr, process_idx);
	apte_offset = fdump_process_table.array(process_idx).apte_offset;
          call amu_$fdump_mpt_revert_idx (amu_info_ptr);
	end;

       apte_array_index = 0;
       call amu_$tc_data_get_apt_entry (amu_info_ptr, -1, convert(pidbit, pid), apte_offset, 
			         apte_array_ptr, apte_array_index);
       if apte_array_index = 0 & ^all_sw then call ioa_("No apte with ^[offset ^a^;process_id ^a^] found.", 
				      apte_offset>0, proc_arg);
       do i = 1 to apte_array_index;
          call amu_$print_apte (amu_info_ptr, apte_array (i).ptr, apte_array (i).off, apte_array (i).index);
          end;
       end;

    if apte_array_ptr ^= null() then call ssu_$release_temp_segment (sci_ptr, apte_array_ptr);

    return;
%page;
azm_requests_1_$aste:
     entry (P_sci_ptr, P_azm_info_ptr);

dcl  (aste_sw, bf_sw, pt_sw) bit (1);

	call set_up;
	if ^trans_selected () then call ssu_$abort_line (sci_ptr, 0, "No dump selected.");

	code = 0;
	if nargs = 0 then call ssu_$abort_line (sci_ptr, error_table_$noarg, "^/Usage: aste segno/segname {-ctl_args}.");
	segno = -1;
	offset = -1;
          aste_sw, bf_sw, pt_sw, trailer_sw, no_aste_tr_info = "0"b;
	arg_position = 0;
	data_buf_ptr = null;
	on condition(cleanup) begin;
	   if data_buf_ptr ^= null() then call ssu_$release_temp_segment(sci_ptr, data_buf_ptr);
	   end;
         
	ll = get_line_length_$switch (null (), segln);	/* get terminal lin length */

          do argno = 1 to nargs;
	   call ssu_$arg_ptr (sci_ptr, argno, argp, argl);

	   if char(arg, 1) ^= "-" then do;		/* assume it's a segno/segname		*/
	      arg_position = argno;
	      end;

	   else if arg = "-tr" | arg = "-trailer" then trailer_sw = "1"b;
             else if arg = "-pt" | arg = "-page_table" then pt_sw = "1"b;
             else if arg = "-aste" then aste_sw = "1"b;
             else if arg = "-bf" | arg = "-brief" then do;
	      aste_sw, trailer_sw = "1"b;
	      pt_sw = "0"b;
	      end;
             else if arg = "-lg" | arg = "-long" then
	      aste_sw, trailer_sw, pt_sw = "1"b;
	   else call ssu_$abort_line (sci_ptr, error_table_$bad_arg, """^a.""", arg);
	   end;

	if arg_position = 0 then call ssu_$abort_line (sci_ptr, error_table_$noarg, " Missing the segno/segname.");
	else do;
	   call ssu_$arg_ptr (sci_ptr, arg_position, argp, argl);
	   segno = cv_oct_check_ (arg, code);
             if code ^= 0 then do;			/* see if name */
	      if index(arg, "$|") > 0 then call ssu_$abort_line (sci_ptr, 0,
                   "Segment name is not valid.  It has an offset or name is a symbol. ^a", arg);
	      call amu_$get_segno_from_name (sci_ptr, amu_info_ptr, arg, segno, code);
                if code ^= 0 then call ssu_$abort_line (sci_ptr, code, "^a", arg);
	      end;
	   end;

	hardcore_cur_ptr = addr (hard_ptr_space);
	call amu_$hardcore_info_set_cur_ptrs (amu_info_ptr, hardcore_cur_ptr);
	if hardcore_cur.sstp = null then do;
	     call ssu_$abort_line (sci_ptr, 0, "No sst.");
	     return;
	     end;

	if ^(aste_sw | trailer_sw | pt_sw) then   /* set the default */
             aste_sw, pt_sw = "1"b;

	sstp = hardcore_cur.sstp;
	upt_ptr = hardcore_cur.uptp;
	call amu_$do_translation_hunt_ptr (amu_info_ptr, pointer (baseptr (hardcore_info.dseg), (2 * segno)), sdwp,
	     code);				/* get a pointer to the SDW for the segment */
	if code ^= 0 then call ssu_$abort_line (sci_ptr, code, "Cannot get pointer to SDW for SEGNO ^o.", segno);


          if ^(sdw.df) then call ssu_$abort_line (sci_ptr, 0, "No aste for segment ^o.", segno);
             

	if sdw.unpaged then do;			/* see if the segment is paged */
	     call ioa_ ("Segment ^o is not paged.", segno);
	     return;
	     end;

          sdw_address = fixed (sdw.add, 26);
	if upt_ptr ^= null() then do;
	   if (((sdw_address > upt.upt_absloc & sdw_address < upt.upt_last_loc))      /* found in unpaged_page_tables */
	      | ((sdw_address > upt.iupt_absloc & sdw_address < upt.iupt_last_loc))) /* found in int_unpaged_page_tables */
             then do;
	      no_aste_tr_info = "1"b;
	      if aste_sw | trailer_sw then call ioa_("No ^[aste^] ^[or ^]^[trailer^] info for ^a (Seg ^o).", 
	                      aste_sw, (aste_sw & trailer_sw), trailer_sw, 
			  amu_$get_name_no_comp (amu_info_ptr, baseptr (segno)), segno);
	      end;
             end;

          if ^(no_aste_tr_info) then do;
   	   astep = pointer (sstp, fixed (sdw.add, 24) - fixed (sst.ptwbase, 18) - sst.astsize);
						/* get a pointer to the ast entry */
	   offset = fixed (rel (astep), 18) - fixed (rel (sstp), 18);
	   call ioa_ ("ASTE For ^a (Seg ^o), at SST|^o.", amu_$get_name_no_comp (amu_info_ptr, baseptr (segno)), segno,
	     offset);
	   end;

       if aste_sw & ^(no_aste_tr_info) then do;
	first1 = sst.astsize;
	call amu_$print_dump_oct (astep, offset, first1);
	call amu_$slt_search_seg_ptr (hardcore_cur.sltp, hardcore_cur.sltntp, "pvt", temp_ptr, code);
	if code ^= 0 then call ssu_$abort_line (sci_ptr, 0, "Cannot get pvt.");
	call amu_$do_translation_hunt_ptr (amu_info_ptr, temp_ptr, pvtp, code);
	if code ^= 0 then call ssu_$abort_line (sci_ptr, 0, "Cannot get pvt.");
	pvt_arrayp = addr (pvt.array);
	pvtep = addr (pvt_array (aste.pvtx));
	if substr (pvte.devname, 1, 3) = "dsk" then
	     call ioa_$rsnnl ("^a device ^d", pvtx_name, ln, pvte.devname, pvte.logical_area_number);
	else pvtx_name = "";

	call ioa_ ("^/uid = ^w, vtocx ^o on pvtx ^o^[ (^a)^]", fixed (aste.uid, 35), aste.vtocx, aste.pvtx,
	     pvtx_name ^= "", pvtx_name);
	call ioa_ ("max len ^d, ^d recs used, ^d in core, cur len ^d", fixed (aste.msl, 9), fixed (aste.records, 9),
	     fixed (aste.np, 9), fixed (aste.csl, 9));
	if aste.dtu then
	     call ioa_ ("Used ^a", dtc (aste.dtu));
	else call ioa_ ("Not updated as used.");
	if aste.dtm then
	     call ioa_ ("Modified ^a", dtc (aste.dtm));
	else call ioa_ ("Not updated as modified.");
	if aste.par_astep | aste.infl | aste.infp then
	     call ioa_ ("Par astep = ^o, Son = ^o, brother = ^o", fixed (aste.par_astep, 18), fixed (aste.infp, 18),
		fixed (aste.infl, 18));
	if aste.uid = "0"b then call ioa_ ("Hardcore segno = ^o", fixed (aste.strp, 18));
	else if aste.strp then call ioa_ ("Trailer thread = ^o", fixed (aste.strp, 18));
	else call ioa_ ("No trailer thread.");

	if aste.dirsw then do;
	     if aste.master_dir then
		call ioa_ ("Aste for a master directory.");
	     else call ioa_ ("Aste for a directory.");
	     end;
	else if aste.master_dir then call ioa_ ("Says master dir, but not directory.");

	if aste.quota (0) ^= 0 | aste.quota (1) ^= 0 then
	     call ioa_ ("     Quota (S D) = (^d ^d)", aste.quota (0), aste.quota (1));
	if aste.used (0) ^= 0 | aste.used (1) ^= 0 then
	     call ioa_ ("     QUsed (S D) = (^d ^d)", aste.used (0), aste.used (1));

	vs = "";
	call ioa_$nnl ("^/");
	if aste.usedf then call vput ("usedf ");
	if aste.init then call vput ("init ");
	if aste.gtus then call vput ("gtus ");
	if aste.hc then call vput ("hc ");
	if aste.hc_sdw then call vput ("hc_sdw ");
	if aste.any_access_on then call vput ("aaon ");
	if aste.write_access_on then call vput ("waccon ");
	if aste.inhibit_cache then call vput ("inhcch ");
	if aste.explicit_deact_ok then call vput ("xdok ");
	if aste.ehs then call vput ("ehs ");
	if aste.nqsw then call vput ("nqsw ");
	if aste.tqsw (0) then call vput ("seg-tqsw ");
	if aste.tqsw (1) then call vput ("dir-tqsw ");
	if aste.fmchanged then call vput ("fmch ");
	if aste.fms then call vput ("fms ");
	if aste.npfs then call vput ("npfs ");
	if aste.gtpd then call vput ("gtpd ");
	if aste.dnzp then call vput ("dnzp ");
	if aste.per_process then call vput ("per_proc ");
	if aste.fmchanged1 then call vput ("fmch1 ");
	if aste.damaged then call vput ("damaged ");
	if aste.ddnp then call vput ("ddnp ");
	if aste.pack_ovfl then call vput ("oopv ");

	call vput ("FLUSH");
	pts = sst.pts (fixed (aste.ptsi, 3));

       end;  /* if aste_sw */

    if pt_sw then do;
       /* get core map pointer */
       first = fixed (baseno (sstp));
       if first = fixed (baseno (sst.cmp)) then	/* core map is in same seg as sst */
	coremaptr = pointer (sstp, rel (sst.cmp));
       else do;
	temp_ptr1 = sst.cmp;
	call ssu_$get_temp_segment (sci_ptr, "azm-data_buf", data_buf_ptr);
	segno = fixed (baseno (temp_ptr1), 17);
	first = 0;
	range = sys_info$max_seg_size;
	call get_data_ (data_buf_ptr, segno, first, range, code);
	if code ^= 0 then do;
	   call ssu_$release_temp_segment(sci_ptr, data_buf_ptr);
	   call ssu_$abort_line(sci_ptr, code, "");
	   end;
	coremaptr = addrel (data_buf_ptr, first);
	end;

       if no_aste_tr_info then do;
          bd_sdw = fixed (sdw.bound, 24) * 16;
	pts = divide (bd_sdw+1023, 1024, 18); /* always round up */
          if ((sdw_address > upt.upt_absloc & sdw_address < upt.upt_last_loc)) then 
	   sptp = addrel(upt_ptr, (sdw_address - upt.upt_absloc));      
	else if (sdw_address > upt.iupt_absloc & sdw_address < upt.iupt_last_loc) then	   
	   sptp = addrel(upt_ptr, (sdw_address - upt.iupt_absloc));  
	end;
       else sptp = addrel (astep, size (aste));
       repeat_ = "0"b;
       /* print header only if have ptws */
       if (pts - 1) >=0 then call ioa_ ("^/PAGE      PT        DEVADD    PD COPY^/");	
       do i = 0 to pts - 1 by 1;
          ptp = addr (sptp -> ptwa (i));
	devadd = ptp -> mptw.devadd;
	if i ^= 0 & i ^= pts - 1 & unspec (ptw) = last_ptw & devadd_add_type = "000"b & ^ptw.df then
	   repeat_ = "1"b;
	else do;
	   if repeat_ then do;
	      repeat_ = "0"b;
	      call ioa_ ("====");
	      end;
	   else ;
	if ptw.df then do;
	   core_add = fixed (devadd_record_no);
	   core_add = divide (core_add, 16, 18, 0) + 2;
	   if coremaptr ^= null then do;
	      cmep = addr (coremaptr -> cma (core_add));
	      devadd = cme.devadd;
	      end;
	   else devadd = "0"b;
	  end;
	str = "";
	PTWF = "";
	if ptw.df then
	   call ioa_$rsnnl ("^[phu^x^]^[phm1^x^]^[nypd^x^]^[phm^x^]^[phu1^x^]^[wired^x^]^[os^x^]",
	   PTWF,ln,ptw.phu,ptw.phm1,ptw.nypd,ptw.phm,ptw.phu1,ptw.wired,ptw.os);
	fdevadd = fixed (devadd_record_no);
	if devadd_add_type & add_type.non_null then
	   call ioa_$rsnnl ("^6o", cdevadd, ln, fdevadd);
	else cdevadd = "  null";
	if devadd_nulled_flag & devadd_add_type = add_type.disk then do;
	   devadd_nulled_flag = "0"b;
	   fdevadd = fixed (devadd_record_no);
	   call ioa_ ("^4o  ^w  ^6o^31t(nulled)^5x^a", i, pt_word, fdevadd, PTWF);
	   end;
	else call ioa_ ("^4o  ^w  ^6a^31t^13x^a", i, pt_word, cdevadd, PTWF);
	end;
       last_ptw = unspec (ptw);
       end;
       end;  /* if pt_sw */

       if trailer_sw & ^(no_aste_tr_info) then do;
	if ((aste.strp ^= "0"b) & (aste.uid ^= "0"b)) then do;
	     call ioa_ ("Known as:");
	     call azm_str_util_ (amu_info_ptr, aste.strp, code);
	     if code ^= 0 then call ssu_$abort_line (sci_ptr, code, "");
	     end;
          else call ioa_("^/No Trailer Information.");
       end;

       if data_buf_ptr ^= null() then call ssu_$release_temp_segment(sci_ptr, data_buf_ptr);
return;
%page;
azm_requests_1_$config_deck:
     entry (P_sci_ptr, P_azm_info_ptr);

	call set_up;
	if ^trans_selected () then call ssu_$abort_line (sci_ptr, 0, "No dump selected.");

	data_buf_ptr = null;
	on condition(cleanup) begin;
	   if data_buf_ptr ^= null() then call ssu_$release_temp_segment(sci_ptr, data_buf_ptr);
	   end;

	reason = "";
	temp_name = "config_deck";
	hardcore_cur_ptr = addr (hard_ptr_space);
	call amu_$hardcore_info_set_cur_ptrs (amu_info_ptr, hardcore_cur_ptr);
	call amu_$slt_search_seg_ptr (hardcore_cur.sltp, hardcore_cur.sltntp, temp_name, temp_ptr, code);

	if code ^= 0 then do;
	     reason = "config_deck not found.";
	     goto four_letter_word;
	     end;

	call ssu_$get_temp_segment (sci_ptr, "azm-cd", data_buf_ptr);

	range = sys_info$max_seg_size;
	call get_data_ (data_buf_ptr, fixed (baseno (temp_ptr), 18), 0, range, code);
	if code ^= 0 then do;			/* set by get_data_ */
	     reason = "translating config deck.";
	     go to four_letter_word;
	     end;

	argno = 1;
	config_arg_str = "";
	do argno = argno to nargs;			/* build arg str to pass on to pcd */
	     call ssu_$arg_ptr (sci_ptr, argno, argp, argl);
	     if arg = "-pn" | arg = "-pathname" then
		call ssu_$abort_line (sci_ptr, error_table_$bad_arg, """^a"" is not allowed within azm.", arg);

	     config_arg_str = config_arg_str || " " || arg;
	end;

	call hcs_$fs_get_path_name (data_buf_ptr, dir_name, dir_name_lth, entryname, code);
	if code ^= 0 then do;
	     call ssu_$abort_line (sci_ptr, code, "Expanding name of temp config_deck.");
	     go to four_letter_word;
	     end;

          call adjust_bit_count_(dir_name, entryname, "1"b, bitcount, code);
	if code ^= 0 then do;
	     call ssu_$abort_line (sci_ptr, code, "Adjusting bitcount of temp config_deck.");
	     go to four_letter_word;
	     end;

	pcd_args = "pcd " || rtrim (config_arg_str) || " -pn " || rtrim (dir_name) || ">" || rtrim (entryname);
	pcd_args_len = length (pcd_args);
	pcd_argsp = addr (pcd_args);
	call cu_$cp (pcd_argsp, pcd_args_len, code);
	if code ^= 0 then do;
	     reason = "Calling pcd.";
	     go to four_letter_word;
	     end;

four_letter_word:
	if data_buf_ptr ^= null then call ssu_$release_temp_segment (sci_ptr, data_buf_ptr);
	if reason ^= "" then call ssu_$abort_line (sci_ptr, code, reason);
	return;
%page;
azm_requests_1_$display_abs:
     entry (P_sci_ptr, P_azm_info_ptr);

     mem_dump = "1"b;
     goto COMMON_DISPLAY;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

azm_requests_1_$display:
     entry (P_sci_ptr, P_azm_info_ptr);

          mem_dump = "0"b;

COMMON_DISPLAY:
	call set_up;
	if ^trans_selected () then call ssu_$abort_line (sci_ptr, 0, "No dump selected.");

	if af_sw then rv_str = "";
          unsubscripted_name, match_names = "";
	n_match_names, subscripts (*,*), n_subscripts = 0;
          display_ptr, copy_ptr, symbol_ptr = null();
          data_buf_ptr = null();
	on condition(cleanup) begin;
	   if data_buf_ptr ^= null() then call ssu_$release_temp_segment(sci_ptr, data_buf_ptr);
	   if display_ptr ^= null() then call ssu_$release_temp_segment(sci_ptr, display_ptr);
	   end;

	unspec (modes_sw) = "0"b;
	long_sw, struct_sw = "0"b;
	process_idx = -1;
	if nargs = 0 then  call ssu_$abort_line (sci_ptr, error_table_$noarg,
               "^/Usage: ^[da <absolute-addr>^;display <virtual-addr> {+-exp}^] {range} {-ctl_args}", mem_dump);

	argno = 1;
	call ssu_$arg_ptr (sci_ptr, argno, argp, argl);

	if mem_dump then do;
	     mem_addr = cv_oct_check_ (arg, code);
	     first = mem_addr;
	     if code ^= 0 then call ssu_$abort_line (sci_ptr, 0, "Address to dump must be octal ""^a"".", arg);

	     if nargs < 2 then
		range = 1;
	     else do;
		argno = argno + 1;
		call ssu_$arg_ptr (sci_ptr, argno, argp, argl);
		range = cv_oct_check_ (arg, code);
		if code ^= 0 then do;
		     goto GET_DUMP_CTL_ARGS;		/* assume ctl_arg */
		     end;
		end;
	     argno = argno + 1;
	     end;

	else do;  /* display request with virtual-addr */
	   va_args_ptr = addr(va_args);
	   va.range = 1;
	   va.segno, va.offset, va.offset_modifier,
	   va.va_position, va.ecode  = 0;
	   va.va_switches = "0"b;
	   va.error_msg, va.va_string = "";
	   va.resolved_va = null();
	   call amu_$get_va_args(sci_ptr, amu_info_ptr, argp, nargs, va_args_ptr);
	   if va.ecode ^= 0 | va.error_msg ^="" then call ssu_$abort_line (sci_ptr, va.ecode, "^a", va.error_msg);
	   segno = va.segno;
	   first = va.offset;
	   range = va.range;
	   end;
    
GET_DUMP_CTL_ARGS:
	do argno = argno to nargs;
	   call ssu_$arg_ptr (sci_ptr, argno, argp, argl);
	   if arg = "-ch" | arg = "-ascii" | arg = "-character" then do;
	      modes_sw.char_sw = "1"b;
	      end;
	   else if arg = "-ptr" | arg = "-p" then modes_sw.ptr_sw = "1"b;
	   else if arg = "-pptr" | arg = "-pp" then modes_sw.pptr_sw = "1"b;
	   else if arg = "-pptrx" | arg = "-ppx" then do;
	      if af_sw then go to DUMP_AF_ARG_ERR;
	      modes_sw.pptr_sw = "1"b;
	      expand_ptr_sw = "1"b;
	      end;
	   else if arg = "-ptrx" | arg = "-px" then do;
	      if af_sw then go to DUMP_AF_ARG_ERR;
	      expand_ptr_sw = "1"b;
	      modes_sw.ptr_sw = "1"b;
	      end;
	   else if arg = "-as" then do;
	      if af_sw then go to DUMP_AF_ARG_ERR;
	      struct_sw = "1"b;
	      call get_next_arg("structure_name", argp, argl);
	      outername = arg;
	      if outername = "dte" then struct_name = "ioi_dte";
						/* KLUDGE to interpret correct dte structure */
	      else struct_name = arg;
	      end;
             else if arg = "-long" | arg = "-lg" then do;
	      if af_sw then go to DUMP_AF_ARG_ERR;
	      long_sw = "1"b;
	      end;
	   else if arg = "-inst" | arg = "-i" | arg = "-instruction" then do;
	      if af_sw then go to DUMP_AF_ARG_ERR;
	      modes_sw.inst_sw = "1"b;
	      end;
	   else if arg = "-oc" | arg = "-octal" then ;
	   else do;
	      if mem_dump then call ssu_$abort_line(sci_ptr, error_table_$badopt, " ^a", arg);
	      if ^va_arg(argno) then do;
	         if substr(arg,1,1) = "-" then code = error_table_$badopt;
	         else code = error_table_$bad_arg;
	         call ssu_$abort_line(sci_ptr, code, " ^a", arg);
	         end;
  	      end;
   	   end;

          if (struct_sw | long_sw) & mem_dump then call ssu_$abort_line (sci_ptr, error_table_$badopt,
					 "^[-as^;-long^].", struct_sw);
          if long_sw & ^struct_sw then call ssu_$abort_line (sci_ptr, 0, "-long is only valid with -as.", "");
          if struct_sw & unspec (modes_sw) ^= "0"b then call ssu_$abort_line (sci_ptr, 
					      error_table_$inconsistent, "-as and other control args.", "");

	call ssu_$get_temp_segment (sci_ptr, "azm-display", data_buf_ptr);

          if struct_sw then do;
	   call dump_as_structure(long_sw); 
	   goto END_OF_DUMP;
	   end;

	if range < 0 then call ssu_$abort_line(sci_ptr, amu_et_$neg_range, "^a", va.va_string); 
	if range = 0 then range = 1;
	offset = range;
	if modes_sw.ptr_sw then do;
	     if mod (first, 2) ^= 0 then do;		/* MUST be on even wd bndry */
		call ssu_$abort_line (sci_ptr, 0, "Dump of pointer must start on even word boundary.");
		go to END_OF_DUMP;
		end;
	     temp_range = range * 2;
	     go to GET_DUMP_DATA;
	     end;

	if range = 1 then
	     temp_range = 2;
	else temp_range = range;

GET_DUMP_DATA:

	if mem_dump then do;
	     call azm_dump_mem_ (amu_info_ptr, mem_addr, process_idx, segno, first, mem_tag, is_wired, is_paged, code);

	     if code ^= 0 then do;
		if af_sw then go to DUMP_AF_ERROR;
		if code = amu_et_$free_core then do;
		     call ioa_ ("^/Mem Addr ^8o is in free core (MEM ^a).", mem_addr,
			substr (CPU_NAME, (mem_tag + 1), 1));
		     goto END_OF_DUMP;
		     end;
		if code = amu_et_$proc_not_dumped then do;
		     call ioa_ ("^/Mem Addr ^8o (MEM ^a) owned by a process not dumped (SEGNO ^o).", mem_addr,
			substr (CPU_NAME, (mem_tag + 1), 1), segno);
		     goto END_OF_DUMP;
		     end;
		call ssu_$abort_line (sci_ptr, code, "");
		end;
	     call amu_$fdump_mpt_temp_change_idx (amu_info_ptr, process_idx);
	     index_changed = "1"b;
	     end;   /* of if mem_dump */

	temp_ptr = pointer (baseptr (segno), first);
	if ^modes_sw.inst_sw then
	   call get_data_ (data_buf_ptr, segno, first, temp_range, code);
	else call hunt_for_code (segno, first, temp_range);

chk_range:
	if temp_range = 0 then call ssu_$abort_line (sci_ptr, 0, "Location ^o not found in Seg ^o.", first + range, segno);

          if code ^= 0 then do;
	     if code = amu_et_$seg_not_dumped & ^modes_sw.inst_sw then do;
		call ssu_$print_message (sci_ptr, code, " ^o|^o ^|^10xGetting data from the online storage.", segno, range);
		code = 0;
		call hunt_for_code (segno, first, temp_range);
		goto chk_range;
	     end;
	     if data_buf_ptr ^= null() then call ssu_$release_temp_segment(sci_ptr, data_buf_ptr);
	     call ssu_$abort_line (sci_ptr, code, " ^o|^o", segno, range);
	     end;

	if af_sw then do;
	     if temp_range < range then range = temp_range;
	     go to DUMP_AF;
	end;
	else if temp_range < range then do;
		range = temp_range;
		call ioa_ ("Last loc is ^o range will be ^o",(first + range),range);
	     end;
	real_address = mem_addr;
	if mem_dump then call azm_find_mem_box_$bf (amu_info_ptr, real_address, segno, first, code);
	call ioa_ ("^[ABS_WIRED ^]^[Un-Paged ^]^[Paged ^]Segno ^o ^a^[,Owned by Process index ^d:^]",
	     (mem_dump & is_wired), (mem_dump & ^is_paged), (mem_dump & is_paged), segno,
	     amu_$get_name (amu_info_ptr, temp_ptr), process_idx^= -1, process_idx);

	if unspec (modes_sw) = "0"b then do;
	     if mod (first, 2) = 0 then do;		/* check for its pointer */
		if range = 1 then do;
		     if data_buf_ptr -> its.its_mod = ITS_MODIFIER | data_buf_ptr -> its.its_mod = ITP_MODIFIER then
			range = 2;
		     end;
		end;

	     call amu_$print_dump_oct (data_buf_ptr, first, range);
	     end;
	else if modes_sw.ptr_sw then do;
	     range = mod(range,2) + range;
	     if expand_ptr_sw = "0"b then
		call amu_$print_dump_ptr (data_buf_ptr, first, range);
	     else call amu_$print_dump_ptr_exp (amu_info_ptr, data_buf_ptr, first, range);
	     end;

	else if modes_sw.pptr_sw then do;
	     if expand_ptr_sw = "0"b then
		call amu_$print_dump_pptr (data_buf_ptr, first, range);
	     else call amu_$print_dump_pptr_exp (amu_info_ptr, data_buf_ptr, first, range);
	     end;
	else if modes_sw.char_sw then do;
	     call amu_$print_char_dump (data_buf_ptr, first, range);
	     end;
	else if modes_sw.inst_sw then do;
	     call amu_$print_inst_dump (data_buf_ptr, first, range);
	     end;

	if offset > range then
	     call ioa_ ("dump: Offset ^o not found in Seg ^o, Last location = ^o.", first + offset, segno,
		(first + range) - 1);


	go to END_OF_DUMP;
DUMP_AF:

	if unspec (modes_sw) = "0"b then		/* octal dump */
	     call ioa_$rsnnl ("^v(^w ^)", rv_str, ignore, range, RS);

	else if modes_sw.ptr_sw then			/* as a ptr */
	     call ioa_$rsnnl ("^v(^p ^)", rv_str, ignore, range, RSP);

	else if modes_sw.pptr_sw then			/* as a packed ptr */
	     call ioa_$rsnnl ("^v(^p ^)", rv_str, ignore, range, RSPP);

	else if modes_sw.char_sw then 
   	     call amu_$print_char_dump_af (data_buf_ptr, first, range, rv_ptr, rv_lth);

END_OF_DUMP:
	if index_changed = "1"b then do;
	     call amu_$fdump_mpt_revert_idx (amu_info_ptr);
	     index_changed = "0"b;
	     end;
          if data_buf_ptr ^= null() then call  ssu_$release_temp_segment(sci_ptr, data_buf_ptr);
	return;					/* end of dump entry */

DUMP_AF_ARG_ERR:
          if data_buf_ptr ^= null() then call  ssu_$release_temp_segment(sci_ptr, data_buf_ptr);
	call ssu_$abort_line (sci_ptr, 0, "^a not available in the active request.", arg);
	return;

DUMP_AF_ERROR:
          if data_buf_ptr ^= null() then call  ssu_$release_temp_segment(sci_ptr, data_buf_ptr);
	call ssu_$abort_line (sci_ptr, code, "");
	return;

%page;
azm_requests_1_$ds:
     entry (P_sci_ptr, P_azm_info_ptr);

    call set_up;
    if ^trans_selected () then call ssu_$abort_line (sci_ptr, 0, "No Dump has been specified.");

    if nargs = 0 then  call ssu_$abort_line (sci_ptr, error_table_$noarg,
              "^/Usage: ds <virtual-addr> {+-offset_modifier} {range} {-ctl_args}");

    display_ptr, copy_ptr, symbol_ptr = null();
    data_buf_ptr = null();
    on condition(cleanup) begin;
       if data_buf_ptr ^= null() then call ssu_$release_temp_segment(sci_ptr, data_buf_ptr);
       if display_ptr ^= null() then call ssu_$release_temp_segment(sci_ptr, display_ptr);
       end;

    /* init va_args */

    va_args_ptr = addr(va_args);
    va.range = 1;
    va.segno, va.offset, va.offset_modifier,
       va.va_position, va.ecode  = 0;
    va.va_switches = "0"b;
    va.error_msg, va.va_string = "";
    va.resolved_va = null();

    call ssu_$arg_ptr (sci_ptr, 1, argp, argl);
    call amu_$get_va_args(sci_ptr, amu_info_ptr, argp, nargs, va_args_ptr);
    if va.ecode ^= 0 | va.error_msg ^="" then do;
       call ssu_$abort_line (sci_ptr, va.ecode, "^a", va.error_msg);
       end;
  

/*  Set defaults for the call to dump_segment_. These don't
    necessary related to what the user specified on the request line 
*/
    dump_segment_format_structure = "0"b;
    dump_segment_format_structure.octal, 
    dump_segment_format_structure.offset, 
    dump_segment_format_structure.raw_data,
    dump_segment_format_structure.suppress_duplicates,
    dump_segment_format_structure.interpreted_data = "1"b; 

    if af_sw then do;  /* set defaults for active_request */
       dump_segment_format_structure.suppress_duplicates,   /* -nsd	     */
       dump_segment_format_structure.interpreted_data,      /* -nit	     */
       dump_segment_format_structure.offset  = "0"b;        /* -no_address */
       end;

    /* init other things */

    process_idx = -1;
    block, code = 0;
    unsubscripted_name, match_names = "";
    n_match_names, subscripts (*,*), n_subscripts = 0;

    if af_sw then header_sw = "0"b;    /* no header for active request */
    else header_sw = "1"b;              /* default is to print header */
    struct_sw, long_sw, index_changed = "0"b;  
    argno = 1;
    do argno = argno to nargs;
       call ssu_$arg_ptr (sci_ptr, argno, argp, argl);
       if (arg = "-long" | arg = "-lg") then do;
	dump_segment_format_structure.long, long_sw = "1"b;
	dump_segment_format_structure.short = "0"b;
	end;
       else if (arg = "-suppress_duplicates" | arg = "-sd") then do;
          if af_sw then goto AF_DS_ERROR;
          dump_segment_format_structure.suppress_duplicates = "1"b;
	end;
       else if (arg = "-no_suppress_duplicates" | arg = "-nsd") then
          dump_segment_format_structure.suppress_duplicates = "0"b;
       else if arg = "-raw" then
	dump_segment_format_structure.raw_data = "1"b;
       else if arg = "-no_raw" | arg = "-nraw" then
	dump_segment_format_structure.raw_data = "0"b;
       else if arg = "-interpreted" | arg = "-it" then do;
          if af_sw then goto AF_DS_ERROR;	       
	dump_segment_format_structure.interpreted_data = "1"b;
	end;
       else if arg = "-no_interpret" | arg = "-nit" then
          dump_segment_format_structure.interpreted_data = "0"b;
       else if arg = "-character" | arg = "-ch" | arg = "-ascii" then do;
          dump_segment_format_structure.ascii, dump_segment_format_structure.interpreted_data = "1"b;
	dump_segment_format_structure.bit4, dump_segment_format_structure.ebcdic8, 
	dump_segment_format_structure.ebcdic9, dump_segment_format_structure.bcd = "0"b;
	end;
       else if arg = "-bcd" then do;
          dump_segment_format_structure.bcd, dump_segment_format_structure.interpreted_data = "1"b;
	dump_segment_format_structure.ascii, dump_segment_format_structure.bit4,
	dump_segment_format_structure.ebcdic8, dump_segment_format_structure.ebcdic9 = "0"b;
	end;
       else if arg = "-ebcdic9" then do;
          dump_segment_format_structure.ebcdic9, dump_segment_format_structure.interpreted_data = "1"b;
	dump_segment_format_structure.ascii, dump_segment_format_structure.bit4,
	dump_segment_format_structure.ebcdic8 = "0"b;
	end;
       else if arg = "-ebcdic8" then do;
          dump_segment_format_structure.ebcdic8, dump_segment_format_structure.interpreted_data = "1"b;
	dump_segment_format_structure.ascii, dump_segment_format_structure.bit4,
	dump_segment_format_structure.ebcdic9 = "0"b;
	end;
       else if arg = "-4bit" then do;
          dump_segment_format_structure.bit4, dump_segment_format_structure.interpreted_data = "1"b;
	dump_segment_format_structure.ascii, dump_segment_format_structure.ebcdic8,
	dump_segment_format_structure.ebcdic9 = "0"b;
	end;
       else if arg = "-hex8" then do;
          dump_segment_format_structure.hex8, dump_segment_format_structure.raw_data = "1"b;
	dump_segment_format_structure.hex9, dump_segment_format_structure.octal = "0"b;
	end;
       else if arg = "-hex9" then do;
          dump_segment_format_structure.hex9, dump_segment_format_structure.raw_data = "1"b;
	dump_segment_format_structure.hex8, dump_segment_format_structure.octal = "0"b;
	end;
       else if arg = "-octal" | arg = "-oc" then do;
          dump_segment_format_structure.octal, dump_segment_format_structure.raw_data = "1"b;
	dump_segment_format_structure.hex8, dump_segment_format_structure.hex9 = "0"b;
	end;
       else if (arg = "-short" | arg = "-sh")  then do;
          dump_segment_format_structure.short = "1"b;
	dump_segment_format_structure.long = "0"b;
	end;
       else if (arg = "-address" | arg = "-addr") then do;
          if af_sw then goto AF_DS_ERROR;
	dump_segment_format_structure.offset = "1"b;
	end;
       else if (arg = "-no_address" | arg = "-naddr") then dump_segment_format_structure.offset = "0"b;
       else if arg = "-as" then do;
          if af_sw then goto AF_DS_ERROR;
	struct_sw = "1"b;
	call get_next_arg("structure_name", argp, argl);
	outername,  struct_name = arg;
	end;
       else if (arg = "-header" | arg = "-he") then do;
          if af_sw then goto AF_DS_ERROR;
	header_sw = "1"b;
	end;
       else if (arg = "-no_header" | arg = "-nhe") then header_sw = "0"b;
       else if (arg = "-block" | arg = "-bk") then do;
          if af_sw then goto AF_DS_ERROR;
	call get_next_arg("block size", argp, argl);  /* check next arg, if octal then use as offset */
	block = cv_oct_check_ (arg, code); 
	if code ^= 0 then call ssu_$abort_line(sci_ptr, 0, "block size is non-octal ^a", arg);
	end;	
       else do;
          if ^va_arg(argno) then do;
	   if substr(arg,1,1) = "-" then code = error_table_$badopt;
	   else code = error_table_$bad_arg;
	   call ssu_$abort_line(sci_ptr, code, " ^a", arg);
	   end;
          end;
       end;   /* arg processing */
   
/* Check for legal formats and finish setting variables */

    if struct_sw then call ssu_$print_message(sci_ptr, 0, "For now other control args are ignored except -lg.^/");

    call ssu_$get_temp_segment (sci_ptr, "azm-display", data_buf_ptr);

    segno = va.segno;
    first = va.offset;
    range = va.range;

    if struct_sw then do;
       call dump_as_structure(dump_segment_format_structure.long); 
       goto END_OF_DS;
       end;

    temp_ptr = pointer (baseptr (segno), first);
    call hunt_for_code (segno, first, temp_range);

    if mod (first, 2) = 0 then do;		/* check for its pointer */
       if range = 1 then do;
          if data_buf_ptr -> its.its_mod = ITS_MODIFIER | data_buf_ptr -> its.its_mod = ITP_MODIFIER then
	   range = 2;
	end;
       end;

    if header_sw then call ioa_ ("Segno ^o ^a^[,Owned by Process index ^d:^]^/",
       segno, amu_$get_name (amu_info_ptr, temp_ptr), process_idx^= -1, process_idx);

    dump_segment_format_structure.command_output = "1"b;    

    if af_sw then do;
       rv_str = "";
       call dump_segment_$string(rv_ptr, rv_lth, data_buf_ptr, block, first, range, dump_segment_format);
       end;
    else call dump_segment_(iox_$user_output, data_buf_ptr, block, first, range, dump_segment_format);

END_OF_DS:
	if index_changed = "1"b then do;
	     call amu_$fdump_mpt_revert_idx (amu_info_ptr);
	     index_changed = "0"b;
	     end;
          if data_buf_ptr ^= null() then call  ssu_$release_temp_segment(sci_ptr, data_buf_ptr);
	return;					/* end of dump entry */

AF_DS_ERROR:
    
    call ssu_$abort_line (sci_ptr, error_table_$badopt, "^a", arg); 
    return;
%page;
azm_requests_1_$extract_seg:
     entry (P_sci_ptr, P_azm_info_ptr);

    call set_up;
    if ^trans_selected () then call ssu_$abort_line (sci_ptr, 0, "No dump selected.");

    if nargs < 2 then call ssu_$abort_line(sci_ptr, error_table_$noarg, "^/Usage: ap virtual-addr {range} command_line");

    /* init va_args */

    va_args_ptr = addr(va_args);
    va.range = 0;
    va.segno, va.offset, va.offset_modifier,
       va.va_position, va.ecode  = 0;
    va.va_switches = "0"b;
    va.error_msg, va.va_string = "";
    va.resolved_va = null();

    call ssu_$arg_ptr (sci_ptr, 1, argp, argl);
    call amu_$get_va_args(sci_ptr, amu_info_ptr, argp, nargs, va_args_ptr);
    if va.ecode ^= 0 | va.error_msg ^="" then do;
       call ssu_$abort_line (sci_ptr, va.ecode, "^a", va.error_msg);
       end;

    command_arg = -1;
    do argno = 1 to nargs;		/* looping to catch any invalid args */
       call ssu_$arg_ptr (sci_ptr, argno, argp, argl); 
       if ^va_arg(argno) then do;
          if command_arg < 0 then command_arg = argno;
	else call ssu_$abort_line(sci_ptr, error_table_$bad_arg, " ^a", arg);
          end;
       end;   /* arg processing */

    range = va.range;
    segno = va.segno;
    first = va.offset;

    if range = 0 then range = sys_info$max_seg_size;
    data_buf_ptr = null ();
    on cleanup begin;
       if data_buf_ptr ^= null () then 
	call ssu_$release_temp_segment (sci_ptr, data_buf_ptr);
       end;

    call ssu_$get_temp_segment (sci_ptr, "azm-apply", data_buf_ptr);

    call get_data_ (data_buf_ptr, segno, first, range, code);
    if code ^= 0 then do;
       call ssu_$release_temp_segment (sci_ptr, data_buf_ptr);
       call ssu_$abort_line (sci_ptr, code, "No translation.");
       end;

    call ssu_$apply_request_util (sci_ptr, command_arg, data_buf_ptr, (range * 4), new_range);
    call ssu_$release_temp_segment (sci_ptr, data_buf_ptr);

    revert cleanup;
return;					/* end of extract_seg */
%page;

azm_requests_1_$history_regs:

     entry (P_sci_ptr, P_azm_info_ptr);

dcl want_both bit(1);

    call set_up;
    if ^trans_selected () then call ssu_$abort_line (sci_ptr, 0, "No dump selected.");

    hregs_from_dump, hregs_fm_ptrval, cond_frame, hregs_from_pds = "0"b;
    interpreted_hregs, octal_sw, want_both = "0"b;
    only_cu, only_ou, only_au, only_du = "0"b;
    threaded_hregs = "1"b;				/* default */
    data_buf_ptr = null();
    on condition(cleanup) begin;
       if data_buf_ptr ^= null() then call ssu_$release_temp_segment(sci_ptr, data_buf_ptr);
       end;

    do argno = 1 to nargs;
       call ssu_$arg_ptr (sci_ptr, argno, argp, argl);

       if char(arg, 1) ^= "-" then do;		/* assume it's a virtual-addr			*/
          if hregs_fm_ptrval then call ssu_$abort_line(sci_ptr, error_table_$bad_arg, 
			         "Or virtual address specified more than once. ^a", arg);
	hregs_fm_ptrval = "1"b;
	arg_position = argno;
	end;
       else if arg = "-dump" then do;
          if amu_info.type = SAVED_PROC_TYPE then call ssu_$abort_line(sci_ptr, 0,
					"-dump is not applicable for analyzing process dirs.");
	dumpptr = fdump_info.dump_seg_ptr (0);
	temp_ptr = addr (dump.ouhist);
	hregs_from_dump = "1"b;
	end;
       else if arg = "-pds" then do;
          hregs_from_pds = "1"b;
	end;
       else if arg = "-cond" | arg = "-condition" then do;
	cond_frame = "1"b;
	call get_next_arg("virtual-addr", argp, argl);
	arg_position = argno;
	end;
       else if arg = "-cu" then do;
	only_cu = "1"b;
	threaded_hregs = "0"b;
          end;
      else if arg = "-ou" then do;
         only_ou = "1"b;
         threaded_hregs = "0"b;
         end;
      else if arg = "-au" then do;
         only_au = "1"b;
         threaded_hregs = "0"b;
         end;
      else if arg = "-du" then do;
         only_du = "1"b;
         threaded_hregs = "0"b;
         end;
      else if arg = "-no_thread" then do;
         threaded_hregs = "0"b;
         end;
      else if arg = "-octal" | arg = "-oc" then do;
         octal_sw = "1"b;
         end;
      else if arg = "-interpret" then do;
         interpreted_hregs = "1"b;
         end;
      else if arg = "-thread" then do;
         threaded_hregs = "1"b;
         end;
      else call ssu_$abort_line(sci_ptr, error_table_$bad_arg, "^a", arg);
      end;  /* arg processing do loop */
  
    if ^(hregs_from_dump | hregs_fm_ptrval | cond_frame | hregs_from_pds) 
       then  hregs_from_pds = "1"b;			/* set the default */
    else if ((hregs_from_dump & hregs_fm_ptrval) 
            | (hregs_from_dump & hregs_from_pds)
	  | (hregs_from_dump & cond_frame)
	  | (hregs_fm_ptrval & cond_frame)
	  | (hregs_fm_ptrval & hregs_from_pds))
	  then call ssu_$abort_line(sci_ptr, error_table_$inconsistent,
            "^[ -dump^]^[ -pds^]^[ -cond^]^[ virtual-addr^]", hregs_from_dump, hregs_from_pds, cond_frame, hregs_fm_ptrval);

    if ^(only_cu | only_ou | only_au | only_du) 
       then only_au, only_cu, only_ou = "1"b;		/* set the default				*/
    if octal_sw then do;
       if interpreted_hregs then want_both = "1"b;
       end;
    else interpreted_hregs = "1"b;			/* set default				*/
    
    if (hregs_fm_ptrval | cond_frame) then do;    /* get the virtual addr */
       /* init va_args */
       va_args_ptr = addr(va_args);
       va.range = 0;
       va.segno, va.offset, va.offset_modifier,
       va.va_position, va.ecode  = 0;
       va.va_switches = "0"b;
       va.error_msg, va.va_string = "";
       va.resolved_va = null();
       call amu_$get_va_args_given_start(sci_ptr, amu_info_ptr, argp, arg_position, nargs, va_args_ptr);
       if va.ecode ^= 0 | va.error_msg ^="" then call ssu_$abort_line (sci_ptr, va.ecode, "^a", va.error_msg);
       segno = va.segno;
       first = va.offset;
       end;
 
    call ssu_$get_temp_segment (sci_ptr, "azm-hregs", data_buf_ptr);

    if cond_frame then do;
       sp = addrel (baseptr (segno), first);	/* get stk ptr */
						/* get ret ptr */
       temp_ptr1 = addr (stack_frame.return_ptr);
       segno1 = fixed (baseno (temp_ptr1), 18);
       first1 = fixed (rel (temp_ptr1), 18);
       range = 2;
       call get_data_ (data_buf_ptr, segno1, first1, range, code);
       if code ^= 0 then goto HREGS_RETURN;

       ret_str = amu_$get_name (amu_info_ptr, ret_ptr);
       if index (ret_str, "return_to_ring_") ^= 0 | index (ret_str, "signaller") ^= 0 then do;
          sigstp = addrel (addr (stack_frame.timer), +1);
	temp_ptr1 = addr (sig_stack.history_registers);
	first = fixed (rel (temp_ptr1), 18);
	go to END_HR_ARGS;
	end;
      else if index (ret_str, "fim") ^= 0 then do;
	first = first + 96;			/* from fim */
	go to END_HR_ARGS;
	end;

      else call ssu_$abort_line (sci_ptr, 0, "^p is not a condition frame.", addrel (baseptr (segno), first));
       end;

END_HR_ARGS:
	range = 128;				/* need 128 words */

    hr_switches = interpreted_hregs || only_ou || only_cu || only_au || only_du;

    if hregs_from_pds then do;		/* default is pds */
       temp_ptr = amu_$definition_ptr (amu_info_ptr, "pds", "history_reg_data", code);
       if code ^= 0 then do;
	call ssu_$abort_line (sci_ptr, code, "");
	return;
	end;
       segno = fixed (baseno (temp_ptr), 17);
       first = fixed (rel (temp_ptr), 18);
       end;


    temp_ptr1 = addrel (baseptr (segno), first);
    call ioa_ ("History Registers at ^[(^p) ^a^;^2s^]^[time of Dump from Bootload CPU^]", ^hregs_from_dump,
    temp_ptr1, amu_$get_name (amu_info_ptr, temp_ptr1), hregs_from_dump);

    if hregs_from_dump then do;
       if threaded_hregs then do;
          if want_both | octal_sw then  call hran_$hran_bos (temp_ptr, null(), "1"b);
          else call hran_$hran_bos (temp_ptr, null (), "0"b);
          end;
       else do; /* not threaded */
          if want_both then do;
	   call hran_$bos_no_thread (temp_ptr, null(), hr_switches);
	   hr_switches = "0"b || only_ou || only_cu || only_au || only_du;
	   call hran_$bos_no_thread (temp_ptr, null(), hr_switches);  /* also display the octal representation */
	   end;
          else call hran_$bos_no_thread (temp_ptr, null(), hr_switches);
       end;
       return;   /* all done */
       end;

    /* get hregs from the pds */

    call get_data_ (data_buf_ptr, segno, first, range, code);
    if code ^= 0 then goto HREGS_RETURN;

    if threaded_hregs then do;
       if want_both | octal_sw then  call hran_$hranl (data_buf_ptr, null, "1"b);
       else call hran_$hranl (data_buf_ptr, null, "0"b);
       end;
    else do; /* not threaded */
       if want_both then do;
	call hran_$no_thread (data_buf_ptr, null, hr_switches);
          hr_switches = "0"b || only_ou || only_cu || only_au || only_du;
          call hran_$no_thread (data_buf_ptr, null, hr_switches);  /* also display the octal representation */
	end;
       else call hran_$no_thread (data_buf_ptr, null, hr_switches);
       end;

HREGS_RETURN:
   if data_buf_ptr ^= null() then call ssu_$release_temp_segment(sci_ptr, data_buf_ptr);  
   if code ^= 0 then  call ssu_$abort_line (sci_ptr, code, "");

   return;

%page;
azm_requests_1_$list_proc:
     entry (P_sci_ptr, P_azm_info_ptr);

    call set_up;
    if ^trans_selected () then call ssu_$abort_line (sci_ptr, 0, "No current dump selected.");

    call process_common_args();

    if ^proc_sw then do;
       if cur_sw then do;
	if af_sw then call amu_$fdump_mpt_current_process_af (amu_info_ptr, rv_ptr, rv_lth);
	else call amu_$fdump_mpt_current_process (amu_info_ptr);
	end;
       else call list_by_state();
       goto END_LSP;
       end;

    call determine_process_idx (apte_offset, pid, process_idx);

    if process_idx >= 0 then do;
       if process_idx > hbound (fdump_process_table.array, 1) then 
          call ssu_$abort_line (sci_ptr, amu_et_$big_idx, "^a.", proc_arg);

       hold_index = amu_info.process_idx;
       call amu_$fdump_mpt_temp_change_idx (amu_info_ptr, hold_index);
       call amu_$fdump_mpt_change_idx (amu_info_ptr, process_idx);
       if af_sw then call amu_$fdump_mpt_current_process_af (amu_info_ptr, rv_ptr, rv_lth);
       else call amu_$fdump_mpt_current_process (amu_info_ptr);
       call amu_$fdump_mpt_revert_idx (amu_info_ptr);
       goto END_LSP;
       end;

    if pid > 0 then do;				/* match on process-ids to get the process_idx    */
       pidbit = convert(pidbit, pid);
       hold_index = amu_info.process_idx;
       call amu_$fdump_mpt_temp_change_idx (amu_info_ptr, hold_index);
       found = "0"b;
       do i = 0 to hbound (fdump_process_table.array, 1) while (^found);
	call amu_$fdump_mpt_change_idx (amu_info_ptr, i);
	Pproc = fdump_process_table.array(i).process_info_ptr;
	if Pproc->process_info.pid = pidbit then do;
	   found = "1"b;
	   if af_sw then call amu_$fdump_mpt_current_process_af (amu_info_ptr, rv_ptr, rv_lth);
	   else call amu_$fdump_mpt_current_process (amu_info_ptr);
	   end;
	end;
       call amu_$fdump_mpt_revert_idx (amu_info_ptr);
       if ^(found) then call ssu_$abort_line (sci_ptr, 0, "Process with id ^a not found in dump.", proc_arg);
       goto END_LSP;
       end;

    if apte_offset > 0  then do;
       hold_index = amu_info.process_idx;
       call amu_$fdump_mpt_temp_change_idx (amu_info_ptr, hold_index);
       found = "0"b;
       do i = 0 to hbound (fdump_process_table.array, 1) while (^found);
	call amu_$fdump_mpt_change_idx (amu_info_ptr, i);
	if apte_offset = fdump_process_table(i).apte_offset then do;
	   found = "1"b;
	   if af_sw then call amu_$fdump_mpt_current_process_af (amu_info_ptr, rv_ptr, rv_lth);
	   else call amu_$fdump_mpt_current_process (amu_info_ptr);
	   end;
	end;
       call amu_$fdump_mpt_revert_idx (amu_info_ptr);
       if ^(found) then call ssu_$abort_line (sci_ptr, 0, "Process with APTE offset ^a not found in dump.", proc_arg);
       end;

END_LSP:	 
    return;
%page;

/* Entry is for displaying machine condition frames */

azm_requests_1_$mc:
     entry (P_sci_ptr, P_azm_info_ptr);

dcl 1 what_regs based (arg_bits_ptr) aligned,
      2 dont_care bit(6) unal,
      2 registers bit(11) unal,
      2 dont_care2 bit(18) unal;

dcl (dump_sw, args_specified, va_sw) bit(1);

    call set_up;
    if ^trans_selected () then call ssu_$abort_line (sci_ptr, 0, "No dump selected.");
    data_buf_ptr = null();
    on condition(cleanup) begin;
       if data_buf_ptr ^= null() then call ssu_$release_temp_segment(sci_ptr, data_buf_ptr);
       end;
    code, range1 = 0;
    dump_sw, va_sw, args_specified, octal_sw = "0"b;
    mcp_pgflt_sw, mcp_fim_sw, mcp_sig_sw = "0"b;
    mcpr_int_sw, mcpr_fim_sw, mcpr_systroub_sw, all_sw = "0"b;
    pds_sw, prds_sw, cond_frame, mc_from_ptrval = "0"b;
    arg_bits_ptr = addr (mc_arg);
    mc_arg = "0"b;
    arg_bits_def.set_ptr = "1"b;			/* always set temp ptrs when mc request is called */

    if nargs = 0 then do;			/* default to -scu -pr6 and the prmc value if ^= null() */
       first_ptr_arg = 0;
       arg_bits_def.scu, arg_bits_def.pr (6) = "1"b;
       arg_bits_def.tpr, arg_bits_def.mc_err = "1"b;
       arg_bits_def.flt, arg_bits_def.tm = "1"b;
       arg_bits_def.eis = "1"b;
       t_pr_name = "prmc";
       call amu_$definition_get_prn (amu_info_ptr, t_pr_name, temp_ptr, code);
       if code ^= 0 then call ssu_$abort_line (sci_ptr, code, "The MC pointer 'prmc' is not set.");
       if temp_ptr = null () then call ssu_$abort_line (sci_ptr, 0,
          "The machine condition pointer 'prmc' is not set. See the set request.");
       segno = fixed (baseno (temp_ptr), 17);
       first = fixed (rel (temp_ptr), 18);
       goto READY_TO_PRINT;
       end;

    /* process arguments */
    /* init va_args */

    va_args_ptr = addr(va_args);
    va.range = -1;
    va.segno, va.offset, va.offset_modifier,
       va.va_position, va.ecode  = 0;
    va.va_switches = "0"b;
    va.error_msg, va.va_string = "";
    va.resolved_va = null();

    call ssu_$arg_ptr (sci_ptr, 1, argp, argl);
    call amu_$get_va_args(sci_ptr, amu_info_ptr, argp, nargs, va_args_ptr);
    if va.valid_va then va_sw = "1"b;
    va.range_idx = 0;  /* A range is not valid for mc request */
    segno = va.segno;
    first = va.offset;

    do argno = 1 to nargs;
       call ssu_$arg_ptr (sci_ptr, argno, argp, argl);
       if arg = "-dump" then do; /*  want mc at the time of the FDUMP */
          if amu_info.type = SAVED_PROC_TYPE then call ssu_$abort_line(sci_ptr, 0,
					"-dump is not applicable for analyzing process dirs.");
          if amu_info.type = FDUMP_TYPE | amu_info.type = FDUMP_PROCESS_TYPE then do;
	    data_buf_ptr = fdump_info.dump_seg_ptr (0);
	    arg_bits_def.dump = "1"b;
	    dump_sw = "1"b;
	    end;
           else call ssu_$abort_line (sci_ptr, 0, "Translation is not an FDUMP.");
           end;

        else if arg = "-pds" then do;
	 pds_sw = "1"b;
	 call get_mc_specifiers();
	 end;

        else if arg = "-prds" then do;
           if amu_info.type = SAVED_PROC_TYPE then call ssu_$abort_line(sci_ptr, 0,
					 "-prds is not applicable for analyzing process dirs.");
	 prds_sw = "1"b;
	 call get_mc_specifiers();
	 end;

        else if arg = "-misc" then args_specified, arg_bits_def.mis = "1"b;
        else if arg = "-mc_err" then args_specified, arg_bits_def.mc_err = "1"b;
        else if arg = "-flt" | arg = "-faults" then args_specified, arg_bits_def.flt = "1"b;
        else if arg = "-tm" | arg = "-time" then args_specified, arg_bits_def.tm = "1"b;
        else if arg = "-eis" then args_specified, arg_bits_def.eis = "1"b;
        else if arg = "-lg" | arg = "-long" then args_specified, arg_bits_def.all = "1"b;
        else if arg = "-oc" | arg = "-octal" then args_specified, octal_sw = "1"b;
        else if arg = "-scu" then args_specified, arg_bits_def.scu = "1"b;
        else if arg = "-ppr" then args_specified, arg_bits_def.ppr = "1"b;
        else if arg = "-tpr" then args_specified, arg_bits_def.tpr = "1"b;
        else if arg = "-regs"| arg = "-registers" then do;
           args_specified = "1"b;
	 call get_mc_reg_list();
	 end;
        else if arg = "-prs"| arg = "-pointers" then do;
           args_specified = "1"b;
	 call get_mc_pr_list();
	 end;
       else do;
          if ^va_arg(argno) then do;
	   if substr(arg,1,1) = "-" then code = error_table_$badopt;
	   else code = error_table_$bad_arg;
	   call ssu_$abort_line(sci_ptr, code, " ^a", arg);
	   end;
          end;
       end;   /* arg processing */

     if (dump_sw & prds_sw) | (dump_sw & pds_sw) | (dump_sw & va_sw) |
        (prds_sw & pds_sw) |  (prds_sw & va_sw) | (pds_sw & va_sw) then
        call ssu_$abort_line(sci_ptr, error_table_$inconsistent, "
             ^[virtual-address ^]^[-prds ^]^[-pds ^]^[-dump ^]", va_sw, prds_sw, pds_sw, dump_sw);

     if ^(args_specified) then do;  /* set the default */
        arg_bits_def.scu, arg_bits_def.pr (6) = "1"b;
        arg_bits_def.tpr, arg_bits_def.mc_err = "1"b;
        arg_bits_def.flt, arg_bits_def.tm = "1"b;
        end;
     else if octal_sw then do;
        if (index (what_regs.registers, "1"b) > 0) | arg_bits_def.eis | arg_bits_def.scu | arg_bits_def.all 
           then arg_bits_def.long = "1"b;
        else call ssu_$abort_line(sci_ptr, error_table_$noarg, "^/ -octal is used in conjunction with -scu | -regs | -eis.");
        end;

     if ^(dump_sw | prds_sw | pds_sw | va_sw) then do;      /* use the default value from prmc if not set then error */
        t_pr_name = "prmc";
        call amu_$definition_get_prn (amu_info_ptr, t_pr_name, temp_ptr, code);
        if code ^= 0 then call ssu_$abort_line (sci_ptr, code, "The MC pointer 'prmc' is not set.");
        if temp_ptr = null () then call ssu_$abort_line (sci_ptr, 0,
           "The machine condition pointer 'prmc' is not set. See the set request.");
        segno = fixed (baseno (temp_ptr), 17);
        first = fixed (rel (temp_ptr), 18);
        end;

     if prds_sw | pds_sw then do;
        call mc_by_keyword();
        goto END_MC;
        end;

     if va_sw then do;
        call ssu_$get_temp_segment (sci_ptr, "azm-mc", data_buf_ptr);
        call get_stack (segno, code);		/* returns stack base ptr if a stack */
        if code ^= 0 then do;
           if code = amu_et_$not_stack_seg then do;
	    goto READY_TO_PRINT;
	    end;
	 else call ssu_$abort_line(sci_ptr, code);
           end;

        sp = addrel (sb, first);	/* get stk frame ptr */
				/* get return ptr */
        temp_ptr1 = stack_frame.return_ptr;
        segno1 = fixed (baseno (temp_ptr1), 18);
        first1 = fixed (rel (temp_ptr1), 18);
        range1 = 2;

        ret_str = amu_$get_name (amu_info_ptr, temp_ptr1);

        if index (ret_str, "return_to_ring_0") > 0
           | index (ret_str, "signaller") > 0
	 | index (ret_str, "$fim") ^= 0
	   then  first = first+48;              /* goto where machine conditions start in frame		*/

        else;  /* use what the user says */
      end;

READY_TO_PRINT:
   
    call ioa_ ("Machine Conditions from ^[(^p) ^a^;^2s^]^[Dump^].", ^arg_bits_def.dump,
	  addrel (baseptr (segno), first), amu_$get_name (amu_info_ptr, addrel (baseptr (segno), first)),
	  arg_bits_def.dump);

    call common_mc();

END_MC:	
   if data_buf_ptr ^= null() then call ssu_$release_temp_segment(sci_ptr, data_buf_ptr);
   if code ^= 0 then call ssu_$abort_line (sci_ptr, code, "");

   return;					/* end mc entry */
%page;
azm_requests_1_$sdw:
     entry (P_sci_ptr, P_azm_info_ptr);

    call set_up;
    if ^trans_selected () then call ssu_$abort_line (sci_ptr, 0, "No dump selected.");

    if nargs > 2 then call ssu_$abort_line(sci_ptr, error_table_$too_many_args, "^/Usage: sdw {segno/name} {segno/name}.");

    segno = hardcore_info.dseg;
    code = 0;
    data_buf_ptr = null();
    on condition(cleanup) begin;
       if data_buf_ptr ^= null() then call ssu_$release_temp_segment(sci_ptr, data_buf_ptr);
       end;

    first_segno = 0;				/* set up default range */
    last_segno = divide (sys_info$max_seg_size, 2, 17, 0) - 1;
    if nargs = 0 then goto GET_SDWS;			/* wants it ALL */

    /* First argument will be a segno/name  */

    call ssu_$arg_ptr (sci_ptr, 1, argp, argl);
    first_segno = cv_oct_check_ (arg, code);
    if code ^= 0 then do;			/* see if name */
       if index(arg, "$|") > 0 then call ssu_$abort_line (sci_ptr, 0,
          "Segment name is not valid.  It has an offset or name is a symbol. ^a", arg);
       call amu_$get_segno_from_name (sci_ptr, amu_info_ptr, arg, first_segno, code);
       if code ^= 0 then call ssu_$abort_line (sci_ptr, code, "^a", arg);
       end;

    if nargs = 2 then do;
       call ssu_$arg_ptr (sci_ptr, 2, argp, argl);
       last_segno = cv_oct_check_ (arg, code);
       if code ^= 0 then do;			/* see if name */
          if index(arg, "$|") > 0 then call ssu_$abort_line (sci_ptr, 0,
             "Segment name is not valid.  It has an offset or name is a symbol. ^a", arg);
	call amu_$get_segno_from_name (sci_ptr, amu_info_ptr, arg, last_segno, code);
	if code ^= 0 then call ssu_$abort_line (sci_ptr, code, "^a", arg);
	end;
       end;
    else last_segno = first_segno;

    if first_segno > last_segno then call ssu_$abort_line (sci_ptr, code, 
       "The starting segment number ^o must be less than then ending segment ^o.", first_segno, last_segno);

    if last_segno > divide (sys_info$max_seg_size, 2, 17, 0) - 1 then 
       call ssu_$abort_line (sci_ptr, code, "The ^o specified is too large to be contained in DSEG.", last_segno);

GET_SDWS:
  
    if first_segno = last_segno then  range, range1 = 2;
    else range, range1 = ((last_segno + 1) * 2) - (first_segno * 2);

    call ssu_$get_temp_segment (sci_ptr, "azm-sdw", data_buf_ptr);
    call get_data_ (data_buf_ptr, segno, (first_segno * 2), range, code);

    if range < range1 then do;
       i = last_segno - divide ((range1 - range), 2, 0, 17);
       if nargs = 0 then call ioa_ ("Segment ^o is not known to this process^[, last known segment is ^o^].", 
          last_segno, first_segno ^= last_segno, i);

       if last_segno = first_segno | first_segno > i then go to SDWERR;
       last_segno = i;
       end;

    hdr_printed = "0"b;
    sdwp = data_buf_ptr;
    do segno = first_segno to last_segno;
       call ioa_$rsnnl ("^[R^; ^]^[E^; ^]^[W^; ^]^[P^; ^]^[U^; ^]^[G^; ^]^[C^; ^]^[DF^;  ^]", axstring, (0),
				/* generate the REWPUGCDF string */
	     sdw.read, sdw.execute, sdw.write, sdw.privileged, sdw.unpaged, sdw.entry_bound_sw, sdw.cache, sdw.df);

       if ^hdr_printed then call ioa_ (" ADDRESS RNGS  CA-MAX REWPUGCDF EBOUND SEGNO SEGMENT-NAME");
       hdr_printed = "1"b;
       call ioa_ ("^8o  ^.3b^.3b^.3b  ^6o ^9a ^6o ^5o ^a", fixed (sdw.add, 24), sdw.r1, sdw.r2, sdw.r3,
	     ((fixed ("0"b || sdw.bound, 18) + 1) * 16) - 1, axstring, fixed (sdw.entry_bound, 14), segno,
	     amu_$get_name_no_comp (amu_info_ptr, baseptr (segno)));

       if sdw.df_no ^= "0"b then call ioa_ ("****The sdw.df_no is ^.3b, should be 0****", "0"b || sdw.df_no);

       sdwp = addrel (sdwp, 2);
       end;  /* end loop */

SDWERR:
    if data_buf_ptr ^= null then call ssu_$release_temp_segment (sci_ptr, data_buf_ptr);

    if ^(hdr_printed) then call ioa_ ("No valid SDW^[s^] found (^o^[ - ^o^]).",
       first_segno ^= last_segno, first_segno, first_segno ^= last_segno, last_segno);

return;
%page;
azm_requests_1_$select_proc:
     entry (P_sci_ptr, P_azm_info_ptr);

dcl found				bit(1);
dcl Pproc				ptr;

    call set_up;
    if ^trans_selected () then call ssu_$abort_line (sci_ptr, 0, "No current dump selected.");

    proc_ptr = null();
    proc_sw, dbr_sw, brief_sw, cpu_sw = "0"b;
    dbr, pid, apte_offset = 0;
    cpu_name = "";
    process_idx = -1;
    
    if nargs = 0 then do;
       process_idx = amu_info.process_idx;
       goto PRINT_CURRENT;
       end;

    do argno = 1 to nargs;
       call ssu_$arg_ptr (sci_ptr, argno, argp, argl);

       if substr (arg, 1, 1) ^= "-" then do;
          procl = argl;
	proc_ptr = argp;
          proc_arg = arg;
	proc_sw = "1"b;
	end;
       else if arg = "-cpu" then do;
	call get_next_arg ("CPU tag", proc_ptr, procl);
	cpu_sw = "1"b;
	end;
       else if arg = "-dbr" then do;
	call get_next_arg ("dbr_value", proc_ptr, procl);
	dbr_sw = "1"b;
	end;
       else if arg = "-bf" | arg = "-brief" then brief_sw = "1"b;
       else if arg = "-lg" | arg = "-long" then brief_sw = "0"b;
       else do;
	call ssu_$abort_line (sci_ptr, error_table_$badopt, "Not a valid arg ""^a"".", arg);
	end;
       end;
  
    if proc_sw & (dbr_sw | cpu_sw) then	call ssu_$abort_line (sci_ptr, error_table_$inconsistent, 
                                        "process_specifier and^[ -dbr^]^[ -cpu^]", dbr_sw, cpu_sw);

    if ^(proc_sw) then if ^(dbr_sw | cpu_sw) then call ssu_$abort_line (sci_ptr, 0,
                  "No process specified.^/Usage: slp {process_specifier | -dbr dbr_value | -cpu TAG} {-bf | -lg}");

    if dbr_sw then do;
       dbr = cv_oct_check_ (proc_arg, code);
       if code ^= 0 then do;
	call ssu_$abort_line (sci_ptr, error_table_$badopt, "DBR value not octal ""^a"".", proc_arg);
	end;
       end;
    else if cpu_sw then do;
       if procl >= 2 then goto bad_name;
       i = index (CPU_NAME, proc_arg);
       if i = 0 then do;
bad_name:
	call ssu_$abort_line (sci_ptr, error_table_$bad_arg, "CPU tag must be a thru h ""^a"".", proc_arg);
	end;
       cpu_name = proc_arg;
       end;
    else do;  /* have a process indicator */
       apte_offset, pid = 0;
       call determine_process_idx (apte_offset, pid, process_idx);
       end;

    if apte_offset > 0  then do;
       index_changed = "1"b;
       call amu_$fdump_mpt_temp_change_idx (amu_info_ptr, lbound (fdump_process_table.array, 1));
       call amu_$tc_data_get_dbr (amu_info_ptr, apte_offset, dbr);
       if dbr = -1 then do;
          call ioa_ ("APTE at ^o is empty", apte_offset);
          return;
          end;
       end;

      if pid > 0 then do;				/* match on process-ids to get the process_idx    */
       pidbit = convert(pidbit, pid);
       hold_index = amu_info.process_idx;
       call amu_$fdump_mpt_temp_change_idx (amu_info_ptr, hold_index);
       found = "0"b;
       do i = 0 to hbound (fdump_process_table.array, 1) while (^found);
	call amu_$fdump_mpt_change_idx (amu_info_ptr, i);
	Pproc = fdump_process_table.array(i).process_info_ptr;
	if Pproc->process_info.pid = pidbit then do;
	   found = "1"b;
	   process_idx = i;
	   end;
	end;
       call amu_$fdump_mpt_revert_idx (amu_info_ptr);
       if ^(found) then call ssu_$abort_line (sci_ptr, 0, "Process with id ^a not found in dump.", proc_arg);
       end;

PRINT_CURRENT:
    code = 0;
    call amu_$fdump_mpt_fill_proc_table (amu_info_ptr, dbr, process_idx, cpu_name, brief_sw, code);
    if code ^= 0 then do;
       if dbr_sw then code = amu_et_$dbr_not_found;
       call ssu_$abort_line (sci_ptr, code, " ^[""^a""^;^s^].", proc_ptr^= null(), proc_arg);
       end;

    return;
%page;
common_mc:
     proc;

/* now we should know where to get the mc from and what parts the user wants so
   set up to get the data and then get it */

	if ^arg_bits_def.dump then do;
	     range = 48;
	     data_buf_ptr = addr (mc_area);
	     call get_data_ (data_buf_ptr, segno, first, range, code);
	     end;					/* now that we have the data get it printed */

	call azm_display_mc_ (sci_ptr, amu_info_ptr, data_buf_ptr, arg_bits_ptr, code);
	if code ^= 0 then call ssu_$abort_line (sci_ptr, code, "");
	else if (arg_bits_def.set_ptr & arg_bits_def.mc_stored & ^arg_bits_def.dump) then do;
	     temp_ptr = pointer (baseptr (segno), first);
	     call ioa_ ("Setting Temporary pointers from ^p.", temp_ptr);
	     t_pr_name = "prmc";
	     call amu_$definition_set_prn (amu_info_ptr, t_pr_name, segno, first, code);
	     t_pr_name = "prs";
	     call amu_$definition_set_from (amu_info_ptr, t_pr_name, data_buf_ptr, code);
	     t_pr_name = "pr6";
	     call amu_$definition_get_prn (amu_info_ptr, t_pr_name, temp_ptr, code);
	     if cond_frame then
		first = first - 48;
	     else do;
		segno = fixed (baseno (temp_ptr), 17);
		first = fixed (rel (temp_ptr), 18);
		end;
	     t_pr_name = "prfr";
	     call amu_$definition_set_prn (amu_info_ptr, t_pr_name, segno, first, code);
	     end;
	if arg_bits_def.dump then
	     if arg_bits_def.set_ptr then call ioa_ ("^/Cannot set temporary pointers from the dump registers.");

     end common_mc;
%page;
dump_as_structure:  proc(long_sw);
		
dcl long_sw bit(1);
             amu_info.sci_ptr = sci_ptr; /* need this for amu_get_name_$for_structure */
	   display_size = sys_info$max_seg_size;
	   copy_ptr = pointer(baseptr(segno), first);
  	   call get_data_ (data_buf_ptr, segno, first, display_size, code);
	   if code ^= 0 then do;
	      call ssu_$release_temp_segment (sci_ptr, data_buf_ptr); 
	      call ssu_$abort_line (sci_ptr, code, "");
                end;
	   call structure_ref_$parse ((struct_name), (""), unsubscripted_name, subscripts, n_subscripts, 
	                                 match_names, n_match_names, code);
	   if (code ^= 0) then call ssu_$abort_line (sci_ptr, 0, "Syntax error in structure reference ^a.", struct_name);
	   call structure_find_$search (unsubscripted_name, symbol_ptr, code);
	   if (code ^= 0) then call ssu_$abort_line (sci_ptr, 0, "Cannot get library definition for ^a", 
			        unsubscripted_name);

      	   call display_data_$for_azm (null (), (^long_sw), match_names, n_match_names, amu_info_ptr,
	                             data_buf_ptr, display_size, copy_ptr, symbol_ptr, subscripts, n_subscripts, code); 
	   if (code ^= 0) then call ssu_$abort_line (sci_ptr, code, "^a", struct_name);

end dump_as_structure;
%page;
determine_process_idx:  proc(apte_offset, pid, pidx);

dcl apte_offset			fixed bin(18),
    pidx				fixed bin,
    pid				fixed bin(36),
    proc_idx			fixed bin(35),
    code				fixed bin(35);

proc_idx = cv_dec_check_ (proc_arg, code);
if code ^= 0 then do;
   call ssu_$abort_line (sci_ptr, error_table_$badopt, "Process indicator is invalid. ""^a"".", proc_arg);
   end;

if proc_idx < 3000 then do;  /* have a process index */
   pidx = proc_idx;
   end;

else if proc_idx > 777777 then do; /* octal process-id */
   pid = cv_oct_check_ (proc_arg, code);
   if code ^= 0 then call ssu_$abort_line (sci_ptr, error_table_$badopt, "Process-id not octal ""^a"".", proc_arg);

   end;

else do;  /* must be an octal APTE offset */
   apte_offset = cv_oct_check_ (proc_arg, code);
   if code ^= 0 then call ssu_$abort_line (sci_ptr, error_table_$badopt, "APTE offset not octal ""^a"".", proc_arg);
   end;

end determine_process_idx;
%page;
dtc:
     proc (b) returns (char (24));

dcl  b bit (36) parameter;
dcl  buf bit (72);
dcl  fbuf fixed (71);
dcl  date char (24);

	buf = "0"b;
	substr (buf, 21) = b;
	unspec (fbuf) = unspec (buf);
	call date_time_ (fbuf, date);

	return (date);

     end dtc;

%page;
get_data_:
     proc (data_ptr, seg, word, number, a_code);


dcl  data_ptr ptr;
dcl  seg fixed bin;
dcl  sidx fixed bin;
dcl  (word, number) fixed bin (18);
dcl  a_code fixed bin (35);

          a_code = 0;
	index_changed = "0"b;
          if azm_info.in_erf then do;
   	   if ^amu_$return_val_per_process (amu_info_ptr, seg) then do;
	      index_changed = "1"b;
	      call amu_$fdump_mpt_temp_change_idx (amu_info_ptr, lbound (fdump_process_table.array, 1));
	      end;
	   end;
	call amu_$do_translation (amu_info_ptr, seg, data_ptr, word, number, a_code);
	if index_changed = "1"b then do;
	     do sidx = 1 to translation_table.n_entries while (seg ^= translation_table (sidx).segno);
	     end;
	     if translation_table.flags (sidx).replaced then return;
	     else call amu_$fdump_mpt_revert_idx (amu_info_ptr);
	     index_changed = "0"b;
	end;

     end get_data_;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

get_mc_pr_list: proc();
	
dcl i fixed bin;
	      
	      va_sw = "0"b;
    if argno = nargs then do;  /* set the default */
       arg_bits_def.prs = "1"b;
       goto END_PR;
       end;

    argno = argno + 1;
    do i = argno to nargs;
       call ssu_$arg_ptr (sci_ptr, i, argp, argl);
       if substr (arg, 1, 1) = "-" then do; 

	if i = argno then  /* set the default */
	   arg_bits_def.prs = "1"b;
	   goto END_PR;
	end;
       else do;
	temp_num = cv_oct_check_ (arg, code);
	if code ^= 0 then call ssu_$abort_line (sci_ptr, error_table_$bad_arg,
	                            "Invalid pointer reg specified ""^a"".", arg);
	if ^(temp_num < 0 | temp_num > 7) then
             arg_bits_def.pr (temp_num) = "1"b;
	else call ssu_$abort_line (sci_ptr, error_table_$bad_arg,
		"Invalid pointer reg specified < 0 | > 7 ""^a"".", arg);
          end;
       end;
END_PR:
    argno = i - 1;   /* reset argno */
    return;

end get_mc_pr_list;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

get_mc_reg_list: proc();
	       
dcl i fixed bin;

    if argno = nargs then do;  /* set the default */
       arg_bits_def.regs = "1"b;
       goto END_REG;
       end;

    argno = argno + 1;
    do i = argno to nargs;
       call ssu_$arg_ptr (sci_ptr, i, argp, argl);
       if substr (arg, 1, 1) = "-" then do; 
	if i = argno then  /* set the default */
	   arg_bits_def.regs = "1"b;
          goto END_REG;
	end;
       else if substr (arg, 1, 1) = "x" then do;
	temp_num = cv_oct_check_ (substr (arg, 2, 1), code);
	if code ^= 0 then call ssu_$abort_line (sci_ptr, error_table_$bad_arg, "bad x reg ""^a"".", arg);
	arg_bits_def.xreg (temp_num) = "1"b;
	end;
       else if arg = "a" then arg_bits_def.areg = "1"b;
       else if arg = "q" then arg_bits_def.qreg = "1"b;
       else if arg = "all" then arg_bits_def.regs = "1"b;
       end;
END_REG:
  argno = i - 1;   /* reset argno */
  return;

end get_mc_reg_list;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

get_mc_specifiers:  proc();
		
dcl i fixed bin;

 if argno = nargs then do; /* set the defaults */
    if pds_sw then mcp_pgflt_sw, mcp_fim_sw, mcp_sig_sw = "1"b;
    else mcpr_int_sw, mcpr_fim_sw, mcpr_systroub_sw = "1"b;
    return;
    end;

 argno = argno + 1;
 do i = argno to nargs;
    call ssu_$arg_ptr (sci_ptr, i, argp, argl);
    if substr (arg, 1, 1) = "-" then do;
       if i = argno then do;  /* set the default "all" */
          if pds_sw then mcp_pgflt_sw, mcp_fim_sw, mcp_sig_sw = "1"b;
          else mcpr_int_sw, mcpr_fim_sw, mcpr_systroub_sw = "1"b;
	end;
       goto END_SPECS;
       end;
    else if arg = "all" then do;
       if pds_sw then mcp_pgflt_sw, mcp_fim_sw, mcp_sig_sw = "1"b;
       else mcpr_int_sw, mcpr_fim_sw, mcpr_systroub_sw = "1"b;
        end;
    else do;
       if pds_sw then do;
          if va_sw then if index (arg, va.va_string) > 0 then va_sw = "0"b;
	if arg = "pgf" | arg = "page_fault"  | arg = "page_fault_data" then
             mcp_pgflt_sw = "1"b;
	else if arg = "fim" | arg = "fim_data" then mcp_fim_sw = "1"b;
	else if arg = "sig" | arg = "signal" | arg = "signaller" | arg = "signal_data" then
             mcp_sig_sw = "1"b;
	else call ssu_$abort_line (sci_ptr, error_table_$bad_arg, """^a"".", arg);
	end;
       else if prds_sw then do;
          if va_sw then if index (arg, va.va_string) > 0 then va_sw = "0"b;
	if arg = "fim" | arg = "fim_data" then mcpr_fim_sw = "1"b;
	else if arg = "int" | arg = "interrupt" | arg = "interrupt_data" then
             mcpr_int_sw = "1"b;
	else if arg = "sys" | arg = "system_trouble" | arg = "sys_trouble_data" then
	   mcpr_systroub_sw = "1"b;
	else call ssu_$abort_line (sci_ptr, error_table_$bad_arg, """^a"".", arg);
          end;
	else call ssu_$abort_line (sci_ptr, error_table_$bad_arg, """^a"".", arg);
       end;
    end;   /* arg processing loop */

END_SPECS:	
    argno = i - 1;   /* reset argno */
    return;

end get_mc_specifiers;
%page;
get_new_trans:      proc (segno, code);

/* get a translation for the seg and place / replace it in the translation table */

dcl code fixed bin(35);
dcl segno fixed bin;

dcl  1 temp_trans like translation;
dcl temp_proc_hold fixed bin;

    translation_ptr = addr (temp_trans);
    if amu_info.type = FDUMP_PROCESS_TYPE then do;
       if ^amu_$return_val_per_process (amu_info_ptr, segno) then do;
					/* could be stack for logger */
	temp_proc_hold = amu_info.process_idx;
	call amu_$fdump_mpt_change_idx (amu_info_ptr, 0);
	call amu_$fdump_translate_to_temp_seg (amu_info_ptr, baseptr (segno), translation_ptr, code);
	call amu_$fdump_mpt_change_idx (amu_info_ptr, temp_proc_hold);
	end;
       else do;
	call amu_$fdump_translate_to_temp_seg (amu_info_ptr, baseptr (segno), translation_ptr, code);
	end;
       end;

    else if  amu_info.type = SAVED_PROC_TYPE then do;
       code = amu_et_$no_translation;
       return;
       end;

    else do;
       code = amu_et_$not_implemented;
       return;
       end;

    if code ^= 0 then  return;
    call amu_$translate_force_add (amu_info_ptr, translation_ptr, segno, code);
    if code ^= 0 then return;

end get_new_trans;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

get_next_arg: proc(Arg_expected, ap1, al1);

/*  This guy gets the next argument from the argument string, complaining if it's not there  */

dcl Arg_expected			char(*);
dcl (ap1				ptr,
     al1				fixed bin(21));
	    
	if (argno + 1) > nargs then do;
	     call ssu_$abort_line(sci_ptr, error_table_$noarg, "A ^a expected after ^a.", Arg_expected, arg);
	     return;
	     end;

	argno = argno + 1;
	call ssu_$arg_ptr (sci_ptr, argno, ap1, al1);
     
end get_next_arg;
%page;
get_stack:       proc(stack_no, code);

dcl stack_no fixed bin(17);
dcl code fixed bin(35);

    code = 0;

    call amu_$translate_get (amu_info_ptr, stack_no, translation_ptr, code);
    if translation_ptr = null then do;		/* if null then no trans */
       if code = amu_et_$invalid_segno then do;   /* not valid segno */
	call amu_$error_for_caller (amu_info_ptr, code, ssu_$get_subsystem_and_request_name,
	          "Cannot get segment ^o.", stack_no);
	return;
          end;
       else do;				/*  OK now translate it into a temp seg */
	call get_new_trans (stack_no, code);
	if code ^= 0 then do;
	   call amu_$error_for_caller (amu_info_ptr, code, ssu_$get_subsystem_and_request_name,
	          "Unable to translate segment ^o.", stack_no);
  	   return;
	   end;
	end;
       end;

    else do;		/* if translated see if it is in a temp seg */
       if ^translation.flags.in_temp_seg & ^translation.flags.in_perm_seg then do;
			/* is not in a temp seg so retranslate it */
          call get_new_trans(stack_no, code);
	if code ^= 0 then do;
	   call amu_$error_for_caller (amu_info_ptr, code, ssu_$get_subsystem_and_request_name,
	          "Unable to translate segment ^o.", stack_no);
  	   return;
	   end;
	end;
       end;

    sb = translation.part1.ptr;
    if ^thread_ptr_val (stack_header.stack_begin_ptr, stack_no) then
       code = amu_et_$not_stack_seg;
    else if ^thread_ptr_val (stack_header.stack_end_ptr, stack_no) then
       code = amu_et_$not_stack_seg;

end get_stack;
%page;
hunt_for_code:

     proc (seg, word, number);

dcl  seg fixed bin;
dcl  (word, number) fixed bin (18);

	index_changed = "0"b;
          if azm_info.in_erf then do;
  	   if ^amu_$return_val_per_process (amu_info_ptr, seg) then do;
	      index_changed = "1"b;
	      call amu_$fdump_mpt_temp_change_idx (amu_info_ptr, lbound (fdump_process_table.array, 1));
	      end;
	   end;
	call amu_$do_translation_hunt (amu_info_ptr, seg, data_buf_ptr, word, number, code);
	if index_changed = "1"b then do;
	     call amu_$fdump_mpt_revert_idx (amu_info_ptr);
	     index_changed = "0"b;
	     end;
     end hunt_for_code;
%page;
list_by_state:  proc();
	      
dcl state_found bit(1);

    state_found = "0"b;
    hold_index = amu_info.process_idx;
    call amu_$fdump_mpt_temp_change_idx (amu_info_ptr, hold_index);
    do i = 0 to hbound (fdump_process_table.array, 1);
       call amu_$fdump_mpt_change_idx (amu_info_ptr, i);
       Pproc = fdump_process_table.array(i).process_info_ptr;
       if list_state(Pproc->process_info.state) then do;
          state_found = "1"b;
	tally_states(Pproc->process_info.state) = tally_states(Pproc->process_info.state) + 1;
	if ^totals_only then do;
	   if af_sw then call amu_$fdump_mpt_current_process_af (amu_info_ptr, rv_ptr, rv_lth);
	   else call amu_$fdump_mpt_current_process (amu_info_ptr);
	   end;
	end;
       end;
    if ^state_found then do;
       if af_sw then rv_str = "";
       else if ^ct_sw then call ssu_$abort_line(sci_ptr, 0, "No processes in the dump met state criteria specified.");
       end;
    if ct_sw then call print_totals();
    call amu_$fdump_mpt_revert_idx (amu_info_ptr);

end list_by_state;
%page;
mc_by_keyword: proc();

	if mcp_pgflt_sw then do;
	     temp_ptr = amu_$definition_ptr (amu_info_ptr, "pds", "page_fault_data", code);
	     segno = fixed (baseno (temp_ptr), 17);
	     first = fixed (rel (temp_ptr), 18);
	     call ioa_ ("^/Machine conditions from pds$page_fault_data:");
	     call common_mc();
	     end;
	if mcp_fim_sw then do;
	     temp_ptr = amu_$definition_ptr (amu_info_ptr, "pds", "fim_data", code);
	     segno = fixed (baseno (temp_ptr), 17);
	     first = fixed (rel (temp_ptr), 18);
	     call ioa_ ("^/Machine conditions from pds$fim_data:");
	     call common_mc();
	     end;
	if mcp_sig_sw then do;
	     temp_ptr = amu_$definition_ptr (amu_info_ptr, "pds", "signal_data", code);
	     segno = fixed (baseno (temp_ptr), 17);
	     first = fixed (rel (temp_ptr), 18);
	     call ioa_ ("^/Machine conditions from pds$signal_data:");
	     call common_mc();
	     end;


	if mcpr_int_sw then do;
	     temp_ptr = amu_$definition_ptr (amu_info_ptr, "prds", "interrupt_data", code);
	     segno = fixed (baseno (temp_ptr), 17);
	     first = fixed (rel (temp_ptr), 18);
	     call ioa_ ("^/Machine conditions from prds$interrupt_data:");
	     call common_mc();
	     end;
	if mcpr_fim_sw then do;
	     temp_ptr = amu_$definition_ptr (amu_info_ptr, "prds", "fim_data", code);
	     segno = fixed (baseno (temp_ptr), 17);
	     first = fixed (rel (temp_ptr), 18);
	     call ioa_ ("^/Machine conditions from prds$fim_data:");
	     call common_mc();
	     end;
	if mcpr_systroub_sw then do;
	     temp_ptr = amu_$definition_ptr (amu_info_ptr, "prds", "sys_trouble_data", code);
	     segno = fixed (baseno (temp_ptr), 17);
	     first = fixed (rel (temp_ptr), 18);
	     call ioa_ ("^/Machine conditions from prds$sys_trouble_data:");
	     call common_mc();
	     end;

end mc_by_keyword;
%page;
print_totals:  proc();

dcl i fixed bin;

    if af_sw then rv_str = "";
    if af_sw & totals_only then rv_str = ltrim(char(fdump_process_table.size + 1));
    else do;
       do i = 1 to hbound(list_state,1);
          if list_state(i) then do;
	   if af_sw then rv_str = rv_str || " " || ltrim(char(tally_states(i)));
	   else  
	      call ioa_$nnl("^/Processes ^a =^21t^d.", process_st(i), tally_states(i));
	   end;
          end;
       if totals_only then  call ioa_$nnl("^/Total processes =^21t^d.", fdump_process_table.size + 1);
       end;

end print_totals;
%page;
process_common_args:  proc();

    ct_sw, cur_sw, totals_only, proc_sw, all_sw, brief_sw = "0"b;
    process_idx = -1;
    pid, apte_offset = 0;
    list_state(*) = "0"b;
    tally_states(*) = 0;

    if nargs = 0 then do;
       list_state(*) = "1"b;
       end;

    do argno = 1 to nargs;
       call ssu_$arg_ptr (sci_ptr, argno, argp, argl);

       if substr (arg, 1, 1) ^= "-" then do;
          procl = argl;
	proc_ptr = argp;
          proc_arg = arg;
	proc_sw = "1"b;
	end;
       else if arg = "-a" | arg = "-all" then do;
          all_sw, list_state(*) = "1"b;
	end;
       else if arg = "-ct" | arg = "-count" then do;
          ct_sw = "1"b;
	end;
       else if arg = "-cur" | arg = "-current" then do;
	cur_sw = "1"b;
	end;
       else if arg = "-blk" | arg = "-blocked" then do;
          list_state(BLK) = "1"b;
	end;
       else if arg = "-ptl" | arg = "-page_table_lock" then do;
          list_state(PTL) = "1"b;
	end;
       else if arg = "-rdy" | arg = "-ready" then do;
          list_state(RDY) = "1"b;
	end;
       else if arg = "-run" then do;
          list_state(RUN) = "1"b;
	end;
       else if arg = "-stop" | arg = "-stopped" then do;
          list_state(STP) = "1"b;
	end;
       else if arg = "-wait" then do;
          list_state(WAIT) = "1"b;
	end;
       else do;
	call ssu_$abort_line (sci_ptr, error_table_$badopt, "Not a valid arg ""^a"".", arg);
	end;
       end;

    if (proc_sw | cur_sw) & nargs >1 then call ssu_$abort_line (sci_ptr, error_table_$inconsistent, 
                                       "^[process_specifier^;-current^] and -ctl_args", proc_sw);
    
    if ct_sw then 
       if nargs = 1 then do;
	totals_only = "1"b;
	list_state(*) = "1"b;
	end;

end process_common_args;
%page;
set_up:
     proc;

	sci_ptr = P_sci_ptr;
	azm_info_ptr = P_azm_info_ptr;
	amu_info_ptr = azm_info.aip;
	call ssu_$return_arg (sci_ptr, nargs, af_sw, rv_ptr, rv_lth);
	if ^af_sw then call ssu_$arg_count (sci_ptr, nargs, af_sw);

     end set_up;
%page;
thread_ptr_val:
     proc (vptr, segno) returns (bit (1));

dcl vptr ptr;
dcl segno fixed bin;
dcl ret_bit bit(1);
dcl any_other condition;

    ret_bit="0"b;
    on condition (any_other) begin;
       goto RET_VAL;
       end;

    if addr (vptr) -> its.its_mod = ITS_MODIFIER then do;
       if segno = fixed (baseno (vptr), 17) then
	ret_bit= "1"b;
       else ret_bit= "0"b;
       end;
    else ret_bit ="0"b;

RET_VAL:
    return(ret_bit);

end thread_ptr_val;
%page;
trans_selected:
     proc () returns (bit (1));

         return (^(amu_info_ptr = null()));

     end trans_selected;
%page;
va_arg:  proc(a_pos) returns(bit(1));
         
dcl a_pos fixed bin;
dcl i fixed bin;
dcl arg_positions (3) aligned based (Ppos);
/*dcl 1 arg_positions	 aligned based (Ppos),
      2 indx (3) fixed bin; */
dcl Ppos ptr;

    Ppos = addr(va.va_position);
    do i = 1 to hbound(arg_positions,1);
       if a_pos = arg_positions(i) then return("1"b);
       end;
    
    return("0"b);
end va_arg;
%page (1);
vput:
     proc (x);


dcl  x char (*) parameter;

	if x = "FLUSH" | length (vs) > ll - 10 then do;
	     if vs = "" then
		call ioa_ ("No Flags.");
	     else call ioa_ ("Flags: ^a", vs);
	     vs = "";
	     end;
	vs = vs || x;

	return;

     end vput;
%page;%include add_type;
%page;%include amu_fdump_info;
%page;%include amu_hardcore_info;
%page;%include amu_info; 
%page;%include amu_mc;
%page;%include amu_process_info;
%page;%include amu_translation;
%page;%include aste;
%page;%include azm_info;
%page;%include azm_va_args;
%page;%include bos_dump;
%page;%include cmp;
%page;%include dump_segment_format;
%page;%include its;
%page;%include mc;
%page;%include ptw;
%page;%include pvt;
%page;%include pvte;
%page;%include sdw;
%page;%include signaller_stack;
%page;%include sst;
%page;%include stack_frame;
%page;%include stack_header;
%page;%include unpaged_page_tables;

     end azm_requests_1_;
