/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(86-12-10,DGHowe), approve(86-12-10,MCR7595),
     audit(87-01-07,JRGray), install(87-01-09,MR12.0-1267):
     Changed to use include file arg_list.incl.pl1 and to check the mbz in
     command_name_arglist rather than the pad2 field in arg_list for zero.
  2) change(86-12-15,Parisek), approve(87-07-09,MCR7746),
     audit(87-07-23,Fawcett), install(87-07-28,MR12.1-1049):
     Eliminate "garbage" in argument displays because of bad pointer offset
     values,  and look at proper arg list structure when call_type is
     Envptr_supplied_call_type.
  3) change(87-06-29,Parisek), approve(87-07-09,MCR7746),
     audit(87-07-23,Fawcett), install(87-07-28,MR12.1-1049):
     Increased the string size of bound_comp_name from 64 chars to 128 chars
     since some pathnames exceed 64 chars.
                                                   END HISTORY COMMENTS */

azm_stack_trace_:
     proc (P_caller, P_sci_ptr, P_amu_info_ptr, P_stack_ptr, P_fwd_sw, P_arg_sw, P_long_sw, P_force_sw, P_for_number, P_code);

/* Modified 12/1/83 by B. Braun to not call interpret_ptr_ to obtain info for the ARGs of a stack frame.  This 
is because interpret_ptr_ references the current process and not the FDUMP, So we call amu_$get_name instead. 
   Modified Sept 1984 by R. A. Fawcett to remove displaying args when looking for an entry 
      also remove warning messages from frame_args_ and look for argumnet data via "hunt" so that 
      the object code can be found .
   Modified Jan 21 1985 by B. Braun to add a P_caller to all entries.
*/
 

/* format: style4,delnl,insnl,ifthenstmt,indnoniterend,ifthendo,ifthen,^thendo */
/* Parameters */

dcl  (P_amu_info_ptr, P_sci_ptr, P_stack_ptr, P_entry_ptr) ptr;
dcl  (P_fwd_sw, P_arg_sw, P_long_sw, P_force_sw) bit (1);
dcl  P_for_number fixed bin;
dcl  P_code fixed bin (35);
dcl  P_ring_zero bit (1);				/* Automatic */
dcl  P_caller char(*);

dcl  temp_ptr ptr init (null);
dcl  entry_name char (36) init ("");
dcl  (pxss_ptr, page_ptr) ptr init (null);
dcl  wire_ptr ptr init (null ());
dcl  frame_number fixed bin init (0);
dcl  search_entry_ptr ptr init (null);
dcl  temp_proc_hold fixed bin init (0);
dcl  (stop, no_arg_ptr, not_first) bit (1) init ("0"b);
dcl  stack_frames_fwd fixed bin init (0);
dcl  stack_frames_rev fixed bin init (0);
dcl  number_mcs fixed bin init (0);
dcl  next_frame_mc bit (1);
dcl  check_err_sw bit (1) init ("0"b);
dcl  for_number fixed bin init (0);
dcl  number_of_valid_stacks fixed bin init (0);
dcl  code fixed bin (35) init (0);
dcl  (offset, first) fixed bin (18) init (0);
dcl  stack_offset fixed bin (18) init (0);
dcl  segno fixed bin init (0);
dcl  bound_comp_name char (128) init ("");
dcl  based_regs (8) fixed bin (35) based;
dcl  data_buf_ptr ptr init (null);
dcl  (fwd_sw, arg_sw, long_sw, force_sw, error_rev, error_fwd, pg_err) bit (1) init ("0"b);
dcl  (save_prev_sp, save_next_sp) ptr init (null);
dcl  (last_found_fwd_sp, last_found_rev_sp) ptr init (null);
dcl  stack_ptr ptr init (null);
dcl  1 temp_trans like translation;
dcl  frames_array_fwd (stack_frames_fwd) ptr based (frames_fwd_ptr);
dcl  frames_array_rev (stack_frames_rev) ptr based (frames_rev_ptr);
dcl  frames_fwd_ptr ptr init (null);
dcl  frames_rev_ptr ptr init (null);
dcl  temp_word bit (36) aligned init ("0"b);
dcl  temp_desc fixed bin (35) init (0);
dcl  temp_entry_ptr ptr init (null);
dcl  (temp_arg_ptr, temp_desc_ptr) ptr init (null);
dcl  1 page_err_regs,
       2 pg_ptr (0:7) ptr,
       2 ou_regs (8) fixed bin (35);
dcl  sys_info$max_seg_size fixed bin (35) ext static;
dcl  max_stack_size fixed bin (18);
dcl  fwd_bound_sw bit (1) init ("0"b);
dcl  max_words fixed bin (18) init (0);
dcl  argp ptr init (null);
dcl  ap ptr init (null);				/* ptr to arglist. */
dcl  strp ptr init (null);
dcl  tp ptr init (null);
dcl  xdesc (64) ptr;
dcl  tdesc (64) ptr;
dcl  t_args_p (0:128) ptr;
dcl  arg_list_length fixed bin (18) init (0);
dcl  (i, j, jd, k) fixed bin init (0);
dcl  (min_arg, max_arg, type, xtype) fixed bin init (0);
dcl  (no_args, no_desc, strl, ndims, scale) fixed bin init (0);
dcl  (xstrl, xndims, xscale, xnargs, tnargs) fixed bin init (0);
dcl  c75 char (75) aligned init ("");
dcl  (ttype, xttype) char (40) init ("");
dcl  ascii_representation char (132) varying init ("");

dcl  (packed, xpacked) bit (1) aligned init ("0"b);
dcl  begin_block_entries (2) bit (36) aligned internal static options (constant)
	init ("000614272100"b3 /* tsp2 pr0|614 */, "001376272100"b3 /* tsp2 pr0|1376 */);

dcl  1 its_ptr aligned like its;

dcl  ptr_array (0:10) ptr based (argp);
dcl  packptr ptr based unaligned;
dcl  fword (4) fixed bin (35) based (argp);
dcl  bcs char (100) based (argp);
dcl  char_string char (strl) based (argp);
dcl  based_bit bit (36) aligned based;
dcl  bit_string bit (strl) based (argp);
dcl  1 label_variable based (argp) aligned,
       2 ptr ptr,
       2 stack ptr;

dcl  1 temp_arg,
       2 var_pad fixed bin,				/* placed here so args can start on mod 2 bound */
       2 var_length fixed bin,			/* if desc type is varing */
       2 a_buf (50) fixed bin (71);			/* save 100 words for translation of arg */
dcl  log_seg_ptr ptr;
dcl  log_mess_len fixed bin (21);
dcl  log_mess char (log_mess_len) based (log_seg_ptr);
dcl  LEGAL char (96) int static
	init
	/* Printables except PAD, but with BS */ (
	" !""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~");

dcl  (
     amu_et_$not_implemented,
     amu_et_$no_translation,
     amu_et_$looping_problem,
     error_table_$action_not_performed,
     error_table_$seg_not_found,
     amu_et_$invalid_segno,
     amu_et_$entry_not_found,
     amu_et_$no_valid_stacks,
     amu_et_$not_stack_seg,
     amu_et_$end_ptr_oob
     ) fixed bin (35) ext static;

dcl  (
     ioa_,
     ioa_$nnl,
     ioa_$rsnnl
     ) entry () options (variable);
dcl  condition_ entry (char (*), entry);
dcl  get_entry_arg_descs_ entry (ptr, fixed bin, (*) ptr, fixed bin (35));
dcl  decode_descriptor_ entry (ptr, fixed bin, fixed bin, bit (1) aligned, fixed bin, fixed bin, fixed bin);
dcl  sci_ptr ptr;
dcl  arithmetic_to_ascii_ entry (ptr, fixed bin, bit (1) aligned, fixed bin, fixed bin, char (132) varying);
dcl  amu_$definition_set_prn entry (ptr, char (*), fixed bin, fixed bin (18), fixed bin (35));
dcl  amu_$definition_ptr entry (ptr, char (*), char (*), fixed bin (35)) returns (ptr);
dcl  azm_syserr_$returns_string entry (ptr, ptr, fixed bin, fixed bin (35), ptr, fixed bin (21), fixed bin (35));
dcl  azm_ret_x7_stack_$pxss entry (fixed bin, fixed bin, fixed bin);
dcl  azm_ret_x7_stack_$page entry (fixed bin, fixed bin, fixed bin);
dcl  amu_$return_val_per_process entry (ptr, fixed bin) returns (bit (1));
dcl  amu_$fdump_mpt_change_idx entry (ptr, fixed bin);
dcl  amu_$error_for_caller entry () options (variable);
dcl  amu_$print_dump_oct entry (ptr, fixed bin (18), fixed bin (18));
dcl  amu_$get_name entry (ptr, ptr) returns (char (*));
dcl  amu_$get_name_no_comp entry (ptr, ptr) returns (char (*));
dcl  amu_$translate_get entry (ptr, fixed bin, ptr, fixed bin (35));
dcl  amu_$translate_force_add entry (ptr, ptr, fixed bin, fixed bin (35));
dcl  amu_$fdump_translate_to_temp_seg entry (ptr, ptr, ptr, fixed bin (35));
dcl  ssu_$get_temp_segment	entry (ptr, char(*), ptr);
dcl  ssu_$print_message 	entry() options(variable);
dcl  ssu_$release_temp_segment	entry (ptr, ptr);
dcl  amu_$do_translation_by_ptr entry (ptr, ptr, fixed bin (18), ptr, fixed bin (35));
dcl  amu_$do_translation_hunt_ptr entry (ptr, ptr, ptr, fixed bin (35));
dcl  amu_$do_translation_hunt entry (ptr, fixed bin, ptr, fixed bin (18), fixed bin (18), fixed bin (35));
dcl  amu_$definition_set_from entry (ptr, char (*), ptr, fixed bin (35));
dcl  azm_display_mc_ entry (ptr, ptr, ptr, ptr, fixed bin (35));
dcl  azm_display_mc_$regs_only entry (ptr, ptr, ptr, ptr, fixed bin (35));
dcl  (addr, addrel, baseno, baseptr, index, hbound, lbound,
     min, null, pointer, substr, fixed, max, rel, rtrim, verify, unspec) builtin;
dcl (cleanup, fault_tag_1)  condition;
%page;

	entry_name = "azm_stack_trace";
	sci_ptr = P_sci_ptr;
	for_number = P_for_number;
	frames_fwd_ptr = null ();
	frames_rev_ptr = null ();
	amu_info_ptr = P_amu_info_ptr;
	stack_ptr = P_stack_ptr;
	fwd_sw = P_fwd_sw;
	force_sw = P_force_sw;
	arg_sw = P_arg_sw;
	long_sw = P_long_sw;

          on condition(cleanup) begin;
	   if frames_fwd_ptr ^= null() then call ssu_$release_temp_segment(sci_ptr, frames_fwd_ptr);
	   if frames_rev_ptr ^= null() then call ssu_$release_temp_segment(sci_ptr, frames_rev_ptr);
	   end;
	     
	call get_stack;
	if code ^= 0 then goto ERROR;
	if stack_offset = 0 then do;
	     sp = pointer (sb, fixed (rel (stack_header.stack_begin_ptr), 18));
	     if fixed (rel (sp), 18) >= fixed (rel (stack_header.stack_end_ptr), 18) then do;
		if ^force_sw then do;
		     P_stack_ptr = stack_header.stack_end_ptr;
		     code = amu_et_$no_valid_stacks;
		     goto ERROR;
		     end;
		else fwd_sw = "1"b;
		end;
	     end;
	else do;
	     sp = pointer (sb, stack_offset);		/* use the offset the user gave us */
	     force_sw = "1"b;
	     end;

	error_rev, error_fwd = "0"b;
	stack_frames_fwd, stack_frames_rev = 0;
	call CHECK_THREAD;
	if code ^= 0 then goto ERROR;
	if fwd_sw then
	     sp = frames_array_fwd (1);
	else sp = frames_array_rev (1);
	stop = "0"b;

	if ^fwd_sw & error_rev & ^force_sw then do;
	     call ioa_ ("Trace will be Forward.");
	     fwd_sw = "1"b;
	     end;
PRINT_STACK:
	on fault_tag_1 begin;
	   call ssu_$print_message (sci_ptr,0,"fault_tag_1 cannot continue");
	   P_code,code = 0;
	   goto NORMAL_RETURN;
	   end;

	call ioa_ ("^/^[Forward^;Reverse^] trace of ^a (Seg ^o)", fwd_sw,
	     amu_$get_name_no_comp (amu_info_ptr, P_stack_ptr), fixed (baseno (P_stack_ptr), 17));
	call ioa_ ("Number of stack frames ^[^d^;^s^]^[^d^;^s^].^[^/Previous stack frame ^p.^]", fwd_sw,
	     stack_frames_fwd, ^fwd_sw, stack_frames_rev, fwd_sw, stack_frame.prev_sp);

	call ioa_ ("Stack begin = ^p Stack end = ^p", stack_header.stack_begin_ptr, stack_header.stack_end_ptr);
	call ioa_ ("FRAME^13tRETURN_PTR");
	frame_number, number_mcs = 0;
	pxss_ptr = amu_$definition_ptr (amu_info_ptr, "pxss", "block", code);
	if code ^= 0 then do;
	     P_code = code;
	     return;
	     end;
	page_ptr = amu_$definition_ptr (amu_info_ptr, "page_fault", "done", code);
	if code ^= 0 then do;
	     P_code = code;
	     return;
	     end;
	call check_next;
	pg_err = "0"b;
	do while (^stop);
	     bound_comp_name = amu_$get_name (amu_info_ptr, stack_frame.return_ptr);
	     call ioa_ ("^12p^12p ^a", real_ptr (sp),
	        pointer(stack_frame.return_ptr,rel(stack_frame.return_ptr)),
	        bound_comp_name);
	     call savex_stack_;
	     call mc_frame ("0"b);

	     if long_sw | arg_sw then do;
		call display_args;
		if index (bound_comp_name, "$page_error") ^= 0 then do;
		     if fwd_sw then do;
			if ^pg_err then do;
			     call display_page_err_regs;
			     call ioa_ (" ");
			     pg_err = "1"b;
			     end;
			end;
		     else do;
			if pg_err then do;
			     call display_page_err_regs;
			     call ioa_ (" ");
			     pg_err = "0"b;
			     end;
			else pg_err = "1"b;
			end;
		     end;

		end;
	     no_arg_ptr = "0"b;
	     if long_sw then call display_frame;
	     call check_next;
	end;
	if ^fwd_sw then do;
	     call ioa_ ("Previous stack frame ^p", stack_frame.prev_sp);
	     end;
	if error_fwd & error_rev & ^force_sw then do;
	     fwd_sw = ^fwd_sw;
	     error_fwd, error_rev = "0"b;
	     goto PRINT_STACK;
	     end;
	P_code = 0;
	goto NORMAL_RETURN;
%page;
ERROR:
	P_code = code;
NORMAL_RETURN:
	if frames_fwd_ptr ^= null() then call ssu_$release_temp_segment(sci_ptr, frames_fwd_ptr);
	if frames_rev_ptr ^= null() then call ssu_$release_temp_segment(sci_ptr, frames_rev_ptr);
	return;
%page;


azm_stack_trace_$check_for_entry:
     entry (P_caller, P_sci_ptr, P_amu_info_ptr, P_stack_ptr, P_entry_ptr, P_code);

	entry_name = "azm_stack_trace_$check_for_entry";
	search_entry_ptr = P_entry_ptr;
	sci_ptr = P_sci_ptr;
	check_err_sw = "0"b;
	call common_check_entry();
	P_code = code;
	goto NORMAL_RETURN;
%page;
azm_stack_trace_$check_for_mc:
     entry (P_caller, P_sci_ptr, P_amu_info_ptr, P_stack_ptr, P_ring_zero, P_code);
	code, P_code = 0;
	entry_name = "azm_stack_trace_$check_for_mc";
	sci_ptr = P_sci_ptr;
	force_sw = "0"b;
	call set_up_search;
	if code ^= 0 then goto ERROR;
	fwd_sw = "1"b;
	number_mcs = 0;
	call check_next;
	do while (^stop);
	     if P_ring_zero | next_frame_mc then do;
		if number_mcs = 0 then
		     call mc_frame ("1"b);
		else call mc_frame ("0"b);
		end;
	     if stack_frame_flags.signaller then
		next_frame_mc = "1"b;
	     else next_frame_mc = "0"b;
	     if number_mcs = 4 then do;
		code = amu_et_$looping_problem;
		goto ERROR;
		end;
	     if code ^= 0 then goto ERROR;
	     call check_next;
	end;
	if number_mcs = 0 then P_code = error_table_$action_not_performed;
	goto NORMAL_RETURN;
%page;
azm_stack_trace_$check_for_syserr:
     entry (P_caller, P_sci_ptr, P_amu_info_ptr, P_stack_ptr, P_code);

	entry_name = "azm_stack_trace_$check_for_syserr";
	amu_info_ptr = P_amu_info_ptr;
	sci_ptr = P_sci_ptr;
	search_entry_ptr = amu_$definition_ptr (amu_info_ptr, "syserr_real", "syserr_real", code);
	if code ^= 0 then goto ERROR;
	check_err_sw = "1"b;
	wire_ptr = amu_$definition_ptr (amu_info_ptr, "wire_stack", "wire_stack", code);

	call common_check_entry();
	if code = amu_et_$entry_not_found then do;
	   search_entry_ptr = amu_$definition_ptr (amu_info_ptr,
	      "syserr_real", "binary", code);
	   if code ^= 0 then goto ERROR;
	   call common_check_entry();
	   if code = amu_et_$entry_not_found then do;
	      search_entry_ptr = amu_$definition_ptr (amu_info_ptr,
	         "syserr_real", "error_code", code);
	      if code ^= 0 then goto ERROR;
	      call common_check_entry();
	      end;
	   end;
	P_code = code;
	goto NORMAL_RETURN;
%page;
check_next:
     proc;

     frame_number = frame_number + 1;
     if for_number >= 1 then if frame_number > for_number then do;
	 stop = "1"b;
	 return;
	 end;
     if fwd_sw then do;
        if frame_number > stack_frames_fwd then do;
	 stop = "1"b;
	 end;
        else sp = frames_array_fwd (frame_number);
        end;
     else do;
        if frame_number > stack_frames_rev then do;
	 stop = "1"b;
	 end;
        else sp = frames_array_rev (frame_number);
        end;

end check_next;
%page;


CHECK_THREAD:
     proc;

	fwd_bound_sw = "0"b;
	max_stack_size = sys_info$max_seg_size;
	if force_sw then
	     if ^fwd_sw then goto Check_stack_thread_rev;
	call ssu_$get_temp_segment (sci_ptr, "stack_frames_fwd", frames_fwd_ptr);

Check_stack_thread_fwd:

	on fault_tag_1 begin;
	   goto stack_error_fwd;
	   end;
	stop = "0"b;
	not_first = "0"b;
	save_prev_sp = stack_frame.prev_sp;
	do while (^stop);
	     if (fixed (rel (stack_frame.next_sp), 18) < max_stack_size) then
		if thread_ptr_val (stack_frame.next_sp, not_first) then
		     if (fixed (rel (sp), 18) < fixed (rel (stack_frame.next_sp), 18)) then
			if fixed (rel (stack_frame.next_sp), 18) <= fixed (rel (stack_header.stack_end_ptr), 18)
			then if fixed (rel (stack_frame.next_sp), 18) ^= fixed (rel (stack_header.stack_end_ptr))
			     then do;
fwd_next_frame:
				do i = 1 to stack_frames_fwd;
				     if frames_array_fwd (i) = sp then do;
					call ioa_ ("Stack frame wraps around");
					stop = "1"b;
					end;
				end;

				stack_frames_fwd = stack_frames_fwd + 1;
				frames_array_fwd (stack_frames_fwd) = sp;
				save_prev_sp = sp;
				not_first = "1"b;
				sp = pointer (sb, fixed (rel (stack_frame.next_sp), 18));
				end;

			     else do;
				stop = "1"b;
				stack_frames_fwd = stack_frames_fwd + 1;
				frames_array_fwd (stack_frames_fwd) = sp;
				end;
			else do;
			     if force_sw then
				goto fwd_next_frame;
			     else do;
				call ioa_ ("^-(fwd) next_sp > stack_end_ptr for frame ^p", real_ptr (sp));
				goto stack_error_fwd;
				end;
			     end;

		     else do;
			call ioa_ ("^-(fwd) next_sp >= sp: sp = ^p", real_ptr (sp));
			goto stack_error_fwd;
			end;
		else do;
		     call ioa_ ("^-(fwd) next_sp not valid ^p sp ^p", stack_frame.next_sp, real_ptr (sp));
		     goto stack_error_fwd;
		     end;
	     else do;
		call ioa_ ("^-(fwd) next_sp out_of_bounds ^p sp ^p", stack_frame.next_sp, real_ptr (sp));
		fwd_bound_sw = "1"b;
		goto stack_error_fwd;
		end;
	end;
	goto good_thread_fwd;
stack_error_fwd:
	stack_frames_fwd = stack_frames_fwd + 1;
	frames_array_fwd (stack_frames_fwd) = sp;
	error_fwd = "1"b;

good_thread_fwd:

	revert fault_tag_1;
	last_found_fwd_sp = sp;
	if force_sw then return;			/* Now check rev */

Check_stack_thread_rev:

	on fault_tag_1 begin;
	   goto stack_error_rev;
	   end;
	call ssu_$get_temp_segment (sci_ptr, "stack_frames_rev", frames_rev_ptr);
	stop = "0"b;
	not_first = "1"b;
	if stack_offset = 0 then do;
	     if fwd_bound_sw then sp = last_found_fwd_sp;
	     if (fixed (rel (stack_header.stack_end_ptr), 18) < max_stack_size) then
		sp = pointer (sb, fixed (rel (stack_header.stack_end_ptr), 18));
	     else do;
		if force_sw & ^fwd_sw then do;
		     code = amu_et_$end_ptr_oob;
		     return;
		     end;
		end;
	     if ^thread_ptr_val (stack_frame.prev_sp, not_first) then do;
		sp = last_found_fwd_sp;
		end;
	     else do;
		sp = pointer (sb, fixed (rel (stack_frame.prev_sp), 18));
		end;
	     end;
	else do;
	     sp = pointer (sp, stack_offset);
	     end;

	if ^thread_ptr_val (stack_frame.next_sp, not_first) then do;
	     sp = last_found_fwd_sp;
	     end;

	do while (^stop);
	     if thread_ptr_val (stack_frame.prev_sp, not_first) then
		if (fixed (rel (sp), 18) > fixed (rel (stack_frame.prev_sp), 18))
		     | rel (sp) = rel (stack_header.stack_begin_ptr) then
		     if fixed (rel (stack_frame.prev_sp), 18) >= fixed (rel (stack_header.stack_begin_ptr), 18) then
			if fixed (rel (sp), 18) ^= fixed (rel (stack_header.stack_begin_ptr)) then do;
rev_next_frame:
			     do i = 1 to stack_frames_rev;
				if frames_array_rev (i) = sp then do;
				     call ioa_ ("Stack frame wraps around");
				     stop = "1"b;
				     end;
			     end;

			     save_next_sp = sp;
			     stack_frames_rev = stack_frames_rev + 1;
			     frames_array_rev (stack_frames_rev) = sp;
			     sp = pointer (sb, fixed (rel (stack_frame.prev_sp), 18));
			     if fixed (rel (sp), 18) = fixed (rel (stack_header.stack_begin_ptr), 18) then
				not_first = "0"b;

			     end;
			else do;
			     stack_frames_rev = stack_frames_rev + 1;
			     frames_array_rev (stack_frames_rev) = sp;
			     stop = "1"b;
			     end;
		     else do;
			if fixed (rel (sp), 18) = fixed (rel (stack_header.stack_begin_ptr), 18) then do;
			     stop = "1"b;
			     stack_frames_rev = stack_frames_rev + 1;
			     frames_array_rev (stack_frames_rev) = sp;
			     end;
			else do;
			     call ioa_ ("^-(rev) prev_sp (^p) < stack_begin_ptr for frame ^p", stack_frame.prev_sp,
				real_ptr (sp));
			     goto stack_error_rev;
			     end;
			end;

		else do;
		     call ioa_ ("^-(rev) prev_sp ^p > sp for frame ^p", stack_frame.prev_sp, real_ptr (sp));
		     goto stack_error_rev;
		     end;
	     else do;
		call ioa_ ("^-(rev) prev_sp not valid ^p for frame ^p", stack_frame.prev_sp, real_ptr (sp));
		goto stack_error_rev;
		end;
	end;
	goto good_thread_rev;

stack_error_rev:

	stack_frames_rev = stack_frames_rev + 1;
	frames_array_rev (stack_frames_rev) = sp;
	error_rev = "1"b;

good_thread_rev:

	revert fault_tag_1;
	last_found_rev_sp = sp;
	return;

     end CHECK_THREAD;
%page;
common_check_entry:       proc();

dcl this_frame bit (1);

     fwd_sw = "0"b;
     force_sw = "0"b;
     call set_up_search;
     if code ^= 0 then return;
     stop = "0"b;
     pxss_ptr = amu_$definition_ptr (amu_info_ptr, "pxss", "block", code);
     if code ^= 0 then return;
     page_ptr = amu_$definition_ptr (amu_info_ptr,
        "page_fault", "done", code);
     if code ^= 0 then return;
     pg_err = "0"b;
     call check_next;
     do while (^stop);
        this_frame = "0"b;
        bound_comp_name = " ";
        if stack_frame.entry_ptr = search_entry_ptr then
	 this_frame = "1"b;
        if check_err_sw then do;
	 bound_comp_name = amu_$get_name (amu_info_ptr,
	    stack_frame.entry_ptr);
	 if index(bound_comp_name,"syserr_real") ^= 0
	    then this_frame = "1"b;
	 end;
        if this_frame then do;
	 if check_err_sw then do;
	    call ssu_$get_temp_segment (sci_ptr, rtrim(entry_name),log_seg_ptr);
	    call azm_syserr_$returns_string (sci_ptr, amu_info_ptr,
	       1, 99, log_seg_ptr, log_mess_len, code);
	    if code ^= 0 then do;
	       call ssu_$release_temp_segment(sci_ptr, log_seg_ptr);
	       return;
	       end;
	    call ioa_$nnl ("Syserr message:^/^3x^a", log_mess);
	    call ssu_$release_temp_segment(sci_ptr, log_seg_ptr);
	    end;
	 call ioa_ ("^/^2x^a^/stack frame at ^p",
	    amu_$get_name (amu_info_ptr, stack_frame.entry_ptr),
	    real_ptr (sp));
	 call check_next;
	 bound_comp_name = amu_$get_name (amu_info_ptr,
	    stack_frame.return_ptr);
	 if check_err_sw then do;
skip_frame:        
	    if (index(bound_comp_name,"wire_stack") ^= 0) |
	       (index(bound_comp_name, "pl1_operator") ^= 0) then do;
	       call check_next;
	       bound_comp_name = amu_$get_name (amu_info_ptr,
		stack_frame.return_ptr);
	       goto skip_frame;
	       end;
	    end;
tell_called_by:
	 call ioa_ ("^/^2xcalled by ^p^2x^a^/at stack frame ^p",
	    stack_frame.return_ptr, bound_comp_name,real_ptr (sp));
	 call savex_stack_;
	 call check_page_err;
	 if pg_err then do;
	    call check_next;
	    goto tell_called_by;
	    end;
	 call ioa_ ("^3xSetting frame ptr (prfr) to ^p", real_ptr (sp));
	 call amu_$definition_set_prn (amu_info_ptr, "prfr",
	    fixed (baseno (real_ptr (sp)), 17),
	    fixed (rel (real_ptr (sp)), 18), code);
	 if code ^= 0 then return;
	 return;
	 end;
        call check_next;
        end;
     code = amu_et_$entry_not_found;
     return;

end common_check_entry;
%page;

check_page_err:
        proc;

        if index (bound_comp_name, "$page_error") ^= 0 then do;
	 if pg_err then do;
	    call ioa_ ("ENTRY PTR ^p ^a", stack_frame.entry_ptr,
	       amu_$get_name (amu_info_ptr, stack_frame.entry_ptr));
	    call display_page_err_regs;
	    call ioa_ ("Setting temporary pointer regs from ^p",
	       real_ptr (sp));
	    call amu_$definition_set_from (amu_info_ptr, "prs",
	       sp, code);
	    pg_err = "0"b;
	    end;
	 else pg_err = "1"b;
	 end;
        end check_page_err;
%page;
display_args:
     proc;					/* this will display the args for this frame */
	if no_arg_ptr then return;			/* do not print the args for this frame */
	if addr (stack_frame.entry_ptr) -> its.its_mod = ITS_MODIFIER then
	     if addr (stack_frame.entry_ptr) -> its.segno ^= "0"b then
		if stack_frame.entry_ptr ^= null then
		     call ioa_ ("^/^-Entry ptr ^p ^a", stack_frame.entry_ptr,
			amu_$get_name (amu_info_ptr, stack_frame.entry_ptr));
	if addr (stack_frame.operator_and_lp_ptr) -> its.its_mod = ITS_MODIFIER then
	     if addr (stack_frame.operator_and_lp_ptr) -> its.segno ^= "0"b then
		if stack_frame.operator_and_lp_ptr ^= null then
		     call ioa_ ("^-Operator/Link ptr ^p", stack_frame.operator_and_lp_ptr);
	if addr (stack_frame.arg_ptr) -> its.its_mod = ITS_MODIFIER then
	     if addr (stack_frame.arg_ptr) -> its.segno ^= "0"b then
		if stack_frame.arg_ptr ^= null then do;
		     call ioa_ ("^-Arg ptr ^p ", stack_frame.arg_ptr);
		     call print_args;
		     return;
		     end;
	call ioa_ ("^-Arg ptr ^p invalid^/", stack_frame.arg_ptr);
     end display_args;
%page;


display_frame:
     proc;					/* This will display the oct dump of the frame */

	call amu_$print_dump_oct (sp, fixed (rel (sp), 18),
	     (fixed (rel (stack_frame.next_sp), 18) - fixed (rel (sp), 18)));
	call ioa_ ("^/");
	return;
     end display_frame;
%page;

display_page_err_regs:
     proc;
	temp_word = "0"b;
	page_err_regs.pg_ptr = sp -> mc.prs;
	page_err_regs.ou_regs = addrel (sp, 32) -> based_regs;
	arg_bits_ptr = addr (temp_word);
	arg_bits_def.prs, arg_bits_def.regs = "1"b;
	call ioa_ ("REGS saved by page_error:");
	call azm_display_mc_$regs_only (sci_ptr, amu_info_ptr, addr (page_err_regs), arg_bits_ptr, code);
     end display_page_err_regs;
%page;
frame_args_:
     proc;

dcl  (xargp, ret_arg_ptr) ptr;

	unspec (ap), unspec (its_ptr) = unspec (stack_frame.arg_ptr);

	t_args_p (*) = null;

/* Extract argument ptr. */
	if its_ptr.its_mod ^= ITS_MODIFIER /* use valid pl1 code */ then go to badap;
	if ap = null then do;
badap:
	     if addr (sp -> stack_frame.entry_ptr) -> its.its_mod = ITS_MODIFIER then
		if sp -> stack_frame.entry_ptr ^= null then
		     do j = 1 to hbound (begin_block_entries, 1);
		     if addrel (sp -> stack_frame.entry_ptr, 1) -> based_bit = begin_block_entries (j) then do;
			call ioa_ ("^-Begin block; no arguments.");
			return;
			end;
		end;
	     call ioa_ ("^-Bad argument pointer.");
	     return;
	     end;
	call amu_$do_translation_hunt_ptr (amu_info_ptr, stack_frame.arg_ptr, ap, code);
	if code ^= 0 then do;
	     call amu_$error_for_caller (amu_info_ptr, code, P_caller, "translate segment ^p", stack_frame.arg_ptr);
	     code = 0;
	     return;
	     end;
	no_args = ap->command_name_arglist.arg_count;		/* get the number of arguments */
	no_desc = ap->command_name_arglist.desc_count;		/* and the number of descriptors */
	if ^valid_arg_list () then do;
	     call ioa_ ("^-Arg list header invalid");
	     code = 0;
	     return;
	     end;
	arg_list_length = (no_args + no_desc + 1) * 2;
	if no_args = 0 then do;			/* check for no arguments */
	     call ioa_ ("^-No arguments.");
	     return;

	     end;
	     
	ap = addr (t_args_p);
	call amu_$do_translation_by_ptr (amu_info_ptr, stack_frame.arg_ptr, arg_list_length, ap, code);
	if code ^= 0 then do;
	     call amu_$error_for_caller (amu_info_ptr, code, P_caller, "Segment pointer ^p", stack_frame.arg_ptr);
	     code = 0;
	     return;
	     end;

	if baseno (stack_frame.entry_ptr) ^= "0"b then do;
	     call amu_$do_translation_hunt_ptr (amu_info_ptr, stack_frame.entry_ptr, temp_entry_ptr, code);
	     if code ^= 0 then do;
		if code = error_table_$seg_not_found then do;
		     temp_entry_ptr = stack_frame.entry_ptr;
		     code = 0;
		end;
		else do;
		     call amu_$error_for_caller (amu_info_ptr, code, P_caller,
			"Entry ptr ^p. Unable to determine arguments.", stack_frame.entry_ptr);
		     code = 0;
		     return;
		end;
	     end;

	     call get_entry_arg_descs_ (temp_entry_ptr, xnargs, xdesc, code);
	     if code ^= 0 then do;
	          code = 0;
		xnargs = 0;
		end;  
	     end;

	else xnargs = 0; 

	if no_args > 64 then do;
	     call ioa_ ("^-Only first 64 args of ^d will be listed.", no_args);
	     no_args = 64;
	     if xnargs > 64 then xnargs = 64;
	     if no_desc ^= 0 then no_desc = 64;
	     end;
	min_arg = 1;				/* print out all arguments */
	max_arg = no_args;
	max_words = 100;
	call condition_ ("any_other", intproc);
	argp = addr (temp_arg.a_buf);
	do j = min_arg to max_arg;			/* loop through the desired number of args */
	     temp_arg_ptr = ap -> ptr_array (j);	/* get pointer to the argument */
	     if temp_arg_ptr ^= null then do;		/* now get the arg data 100 words should do it */
		call amu_$do_translation_hunt (amu_info_ptr, fixed(baseno(temp_arg_ptr),17), 
		   addr (temp_arg.a_buf), fixed(rel(temp_arg_ptr),18), max_words, code);
		if code ^= 0 then do;
		     call ioa_ ("^-ARG ^2d: Cannot get data at ^p^/^-^7x^a", j, temp_arg_ptr, 
			     amu_$get_name  (amu_info_ptr, temp_arg_ptr));
		     code = 0;
		     goto skiparg;
		     end;
		end;
	     else do;				/* pointer to arg = null */
		call ioa_ ("^-ARG ^2d: pointer to this arg is null ", j);
		goto skiparg;
		end;
	     if no_desc ^= 0 then do;			/* if we have descriptors, look at them */
						/* get the pointer to the descriptor */
		if ap->arg_list_with_envptr.call_type = Envptr_supplied_call_type then
		     jd = j+1;
		else jd = j;

		if t_args_p (no_args + jd) = null then goto guess;
		call amu_$do_translation_hunt_ptr (amu_info_ptr, t_args_p (no_args + jd), temp_desc_ptr, code);
		if code ^= 0 then do;
		   code = 0;
		   goto guess;
		   end;

		call decode_descriptor_ (temp_desc_ptr, 0, type, packed, ndims, strl, scale);
/* Does procedure expect arguments? */
		if xnargs >= j then
/* Yes. Do we know what this arg should be? */
		     if xdesc (jd) ^= null then do;
			call amu_$do_translation_hunt_ptr (amu_info_ptr,
			     pointer (stack_frame.entry_ptr, fixed (rel (xdesc (jd)), 18)), tdesc (jd), code);
			if code ^= 0 then do;
			     call amu_$error_for_caller (amu_info_ptr, code, P_caller, "translate xdesc ^p",
				xdesc (jd));
			     code = 0;
			     return;
			     end;

			call decode_descriptor_ (tdesc (jd), 0, xtype, xpacked, xndims, xstrl, xscale);
			if xtype ^= type then do;
			     if type >= lbound (data_type_info_$info, 1) & type <= hbound (data_type_info_$info, 1)
			     then ttype = rtrim(type_name (type));
			     else call ioa_$rsnnl ("type ^d", ttype, k, type);
			     if xtype >= lbound (data_type_info_$info, 1)
				& xtype <= hbound (data_type_info_$info, 1) then
				xttype = rtrim(type_name (xtype));
			     else call ioa_$rsnnl ("type ^d", xttype, k, xtype);
			     end;
			end;
		end;
	     else do;				/* try to find out what type by heuristics */
guess:
		packed = "0"b;
		scale = 0;
		ndims = 0;
		if addr (temp_arg.a_buf (1)) -> its.its_mod = ITS_MODIFIER then
		     type = pointer_dtype;		/* assume pointer */
		else do;
		     strl = verify (bcs, LEGAL) - 1;	/* Scan for last legal char in string. */
		     if strl < 0 then strl = 100;	/* If all legal, print first 100. */
		     if strl >= 2 then
			type = char_dtype;
		     else type = -1;		/* full word octal */
		     end;
		end;
	     	
	     call check_bit_offset (temp_arg_ptr, argp, ret_arg_ptr);
	     if ret_arg_ptr ^= null then do;
		xargp = argp;
		argp = ret_arg_ptr;
	     end;
	     if type = varying_bit_dtype | type = varying_char_dtype then do;
						/* get the length */
		call amu_$do_translation_hunt (amu_info_ptr, fixed (baseno (argp), 17),
		     addrel (addr (temp_arg.a_buf), -1), (fixed (rel (argp), 18) - 1), 1, code);
		if code ^= 0 then do;
		     call ioa_ ("^-ARG ^2d: ^w", j, fword (1));
		     code = 0;
		     goto skiparg;
		     end;
		end;

	     if type = -1 then call ioa_ ("^-ARG ^2d: ^w", j, fword (1));
						/* no descriptor; print full word octal */

	     else if type < lbound (data_type_info_$info, 1) | type > hbound (data_type_info_$info, 1) then
		call ioa_ ("^-ARG ^2d: (bad type ^d at ^p) ^w", j, type, argp, temp_arg.a_buf (1));

	     else if data_type_info_$info (type).arithmetic then do;
		call arithmetic_to_ascii_ (argp, type, packed, strl, scale, ascii_representation);
		call ioa_ ("^-ARG ^2d: ^a", j, ascii_representation);
		end;

	     else if type = pointer_dtype then do;	/* Pointer */
		if packed then do;			/* packed ptr */
		     tp = argp -> packptr;
		     go to pptr;
		     end;
		if argp -> its.its_mod = ITS_MODIFIER then do;
		     tp = argp -> ptr_array (0);
pptr:

		     call ioa_ ("^-ARG ^2d: ^p  ^a", j, tp, amu_$get_name (amu_info_ptr, tp));
		     end;
		else call ioa_ ("^-ARG ^2d: ^w  ^w", j, fword (1), fword (2));
		end;

	     else if type = offset_dtype /* Offset */ then call ioa_ ("^-ARG ^2d: ^w", j, fword (1));

	     else if type = label_dtype | type = entry_dtype /* Label, Entry */ then do;
   	          call ioa_ ("^-ARG ^2d: ^p  ^a", j, label_variable.ptr, amu_$get_name (amu_info_ptr, argp->label_variable.ptr));
		end;

	     else if type = bit_dtype | type = varying_bit_dtype /* Bit string */ then do;
		if type = varying_bit_dtype then strl = addrel (argp, -1) -> fword (1);
		c75 = """";			/* initial quote */
		k = 0;				/* count 1-bits */
		do i = 1 to min (strl, 72);
		     if substr (bit_string, i, 1) then do;
			k = k + 1;
			substr (c75, i + 1, 1) = "1";
			end;
		     else substr (c75, i + 1, 1) = "0";
		end;
		substr (c75, i + 1, 2) = """b";
		if (strl <= 72 & strl > 1) then	/* Maybe compress representation */
		     if k = 0 then call ioa_$rsnnl ("(^d)""0""b", c75, k, strl);
		     else if k = strl then call ioa_$rsnnl ("(^d)""1""b", c75, k, strl);
		call ioa_ ("^-ARG ^2d: ^a", j, c75);
		end;

	     else if type = char_dtype | type = varying_char_dtype /* Character string */ then do;
		if type = varying_char_dtype then strl = min (80, max (addrel (argp, -1) -> fword (1), 0));
		call ioa_ ("^-ARG ^2d: ""^va""", j, strl, char_string);
		end;

	     else if type = file_dtype /* File */ then do;
		call ioa_ ("^-ARG ^2d: ", j);

		end;

	     else call ioa_ ("^-ARG ^2d: (^a at ^p) ^w", j, type_name (type), argp, fword (1));

	     if ndims > 0 then call ioa_ ("^-^-(^d-dim array)", ndims);
	     if ret_arg_ptr ^= null then argp = xargp;
skiparg:
	end;

/* ------------------------------------------------------- */

intproc:
	proc (mcp, cname, cop, infop, cont);
dcl  (mcp, cop, infop) ptr,
     cname char (*),
     cont bit (1);

/* format: ^delnl */
	     if cname = "program_interrupt"
		| cname = "finish"
		| cname = "quit"
	     then do;
		cont = "1"b;
		return;
		end;
						/* format: revert */
	     if cname = "cleanup"
	     then return;

	     if infop ^= null
	     then if infop -> condition_info_header.action_flags.quiet_restart
		then return;

	     call ioa_ ("^-ARG ^2d not accessible. - ^a", j, cname);
	     go to skiparg;
	end;

     end frame_args_;
%page;
valid_arg_list:
     proc returns (bit (1));
	if ap->command_name_arglist.mbz ^= "0"b then
	     return ("0"b);
	if ap->command_name_arglist.call_type ^= Interseg_call_type then
	     if ap->command_name_arglist.call_type ^= Envptr_supplied_call_type then
		if ap->command_name_arglist.call_type ^= Quick_call_type then
		     return ("0"b);
	if no_desc ^= 0 then
	     if no_desc ^= no_desc then return ("0"b);
	return ("1"b);
     end valid_arg_list;
%page;


check_bit_offset:
     proc (P_temp_arg_ptr, P_argp, P_ret_arg_ptr);

dcl  (P_temp_arg_ptr, P_argp, P_ret_arg_ptr) ptr parameter;

/* Check for existence of a ptr offset NOT specifying beginning of octal word boundary. */

     P_ret_arg_ptr = null;
     if addr(P_temp_arg_ptr) -> its.bit_offset ^= ""b then do;
	P_ret_arg_ptr = P_argp;
	addr(P_ret_arg_ptr) -> its.bit_offset = addr(P_temp_arg_ptr) -> its.bit_offset;
     end;
     return;
end check_bit_offset;
%page;



get_new_trans:
     proc;

/* get a translation for the seg and place / replace it in the translation table */

    translation_ptr = addr (temp_trans);
    if amu_info.type = FDUMP_PROCESS_TYPE then do;
       if ^amu_$return_val_per_process (amu_info_ptr, segno) then do;
					/* could be stack for logger */
	temp_proc_hold = amu_info.process_idx;
	call amu_$fdump_mpt_change_idx (amu_info_ptr, 0);
	call amu_$fdump_translate_to_temp_seg (amu_info_ptr, baseptr (segno), translation_ptr, code);
	call amu_$fdump_mpt_change_idx (amu_info_ptr, temp_proc_hold);
	end;
       else do;
	call amu_$fdump_translate_to_temp_seg (amu_info_ptr, baseptr (segno), translation_ptr, code);
	end;
       end;
  
    else if  amu_info.type = SAVED_PROC_TYPE then do;
       code = amu_et_$no_translation;
       return;
       end;

    else do;
       code = amu_et_$not_implemented;
       return;
       end;


	if code ^= 0 then do;
		P_code = code;
		return;
	     end;
	call amu_$translate_force_add (amu_info_ptr, translation_ptr, segno, code);
	if code ^= 0 then do;

		P_code = code;
		return;
	     end;

     end get_new_trans;
%page;


get_stack:
     proc;
	sb = pointer (stack_ptr, 0);
	segno = fixed (baseno (sb), 17);
	stack_offset = fixed (rel (stack_ptr), 18);

/* see if this segno for this Process and erf is translated */
	call amu_$translate_get (amu_info_ptr, segno, translation_ptr, code);

	if translation_ptr = null then do;		/* if null then no trans */
		if code = amu_et_$invalid_segno then do;/* not valid segno */
			P_code = code;
			return;
		     end;
		else do;				/*  OK now translate it into a temp seg */

			call get_new_trans;
			if code ^= 0 then do;
				P_code = code;
				return;
			     end;
		     end;
	     end;


	else do;					/* if translated see if it is in a temp seg */
		if ^translation.flags.in_temp_seg & ^translation.flags.in_perm_seg then do;
						/* is not in a temp seg so retranslate it */
			call get_new_trans;
			if code ^= 0 then do;
				P_code = code;
				return;
			     end;
		     end;
	     end;

	sb = translation.part1.ptr;

	if ^thread_ptr_val (stack_header.stack_begin_ptr, "1"b) then
	     code = amu_et_$not_stack_seg;
	else if ^thread_ptr_val (stack_header.stack_end_ptr, "1"b) then
	     code = amu_et_$not_stack_seg;
     end get_stack;
%page;



mc_frame:
     proc (set_for);
	dcl     set_for		 bit (1);

	dcl     mcp		 ptr;
	dcl     out		 char (168);
	out = amu_$get_name (amu_info_ptr, stack_frame.return_ptr);
	if index (out, "return_to_ring_") ^= 0 | index (out, "$fim|") ^= 0 then do;
		number_mcs = number_mcs + 1;
		call ioa_ ("FIM FRAME found at ^p", real_ptr (sp));
		mcp = addrel (sp, 48);
		temp_word = "0"b;
		arg_bits_ptr = addr (temp_word);
		arg_bits_def.set_ptr = set_for;
		arg_bits_def.ppr, arg_bits_def.tpr, arg_bits_def.pr (6) = "1"b;
		call ioa_ ("Machine Conditions at ^p: ", real_ptr (mcp));
		call azm_display_mc_ (sci_ptr, amu_info_ptr, mcp, arg_bits_ptr, code);
		if code ^= 0 then call amu_$error_for_caller (amu_info_ptr, code, P_caller);

		if set_for then do;
			call ioa_ ("Setting temporary pointers from machine conditions at ^p", real_ptr (mcp));
			call amu_$definition_set_prn (amu_info_ptr, "prmc", fixed (baseno (real_ptr (mcp)), 17),
			     fixed (rel (real_ptr (mcp)), 18), code);
			if code ^= 0 then call amu_$error_for_caller (amu_info_ptr, code, P_caller);

			call amu_$definition_set_from (amu_info_ptr, "prs", mcp, code);
			if code ^= 0 then call amu_$error_for_caller (amu_info_ptr, code, P_caller);


			call amu_$definition_set_prn (amu_info_ptr, "prfr", fixed (baseno (real_ptr (sp)), 17),
			     fixed (rel (real_ptr (sp)), 18), code);
			if code ^= 0 then call amu_$error_for_caller (amu_info_ptr, code, P_caller);

		     end;
		no_arg_ptr = "1"b;			/* do not try to print the args for this frame */
	     end;

	return;

     end mc_frame;
%page;


print_args:
     proc;
	if addr (stack_frame.arg_ptr) -> its.its_mod = ITS_MODIFIER then
	     if addr (stack_frame.arg_ptr) -> its.segno ^= "0"b then
		if stack_frame.arg_ptr ^= null then do;
			call frame_args_;
			call ioa_ (" ");
			return;
		     end;
	call ioa_ ("Arg_ptr invalid ^p^/", stack_frame.arg_ptr);



     end print_args;

%page;


real_ptr:
     proc (given_p) returns (ptr);
	dcl     temp_ptr		 ptr;
	dcl     given_p		 ptr;


	temp_ptr = pointer (baseptr (segno), fixed (rel (given_p), 18));
	return (temp_ptr);
     end real_ptr;
%page;


savex_stack_:
     proc;
	dcl     1 save_stack	 (20) based (stackp),
		2 upper		 fixed bin (17) unal,
		2 lower		 fixed bin (17) unal;
	dcl     stackp		 ptr;
	dcl     num_based		 fixed bin unal based;
	dcl     print_savex		 bit (1);
	dcl     (number, id_offset, i, rel_offset, stack_size) fixed bin;
	dcl     temp_name_ptr	 ptr;
	dcl     segno		 fixed bin (17);

	print_savex = "0"b;
	segno = fixed (baseno (stack_frame.return_ptr), 17);
	if segno = fixed (baseno (pxss_ptr), 17) then do;
		call azm_ret_x7_stack_$pxss (rel_offset, id_offset, stack_size);
		print_savex = "1"b;
	     end;
	if segno = fixed (baseno (page_ptr), 17) then do;
		call azm_ret_x7_stack_$page (rel_offset, id_offset, stack_size);
		print_savex = "1"b;
	     end;

	if ^print_savex then return;
	stackp = addrel (sp, rel_offset);
	number = addrel (sp, id_offset) -> num_based - fixed (rel (stackp), 17);

	if (number > 0) & (number <= stack_size) then
	     call ioa_ ("^2-savex_stack at ^p, stack_size ^o, valid ^o",
		real_ptr (stackp), stack_size, number);
	else return;
	do i = number by -1 to 1;
	     temp_name_ptr = pointer (baseptr (segno), save_stack (i).upper);
	     call ioa_ ("^2-^3x^o^3x^a", save_stack (i).upper,
		amu_$get_name (amu_info_ptr, temp_name_ptr));
	end;
     end savex_stack_;
%page;



set_up_search:
     proc;
	amu_info_ptr = P_amu_info_ptr;
	frames_fwd_ptr, frames_rev_ptr = null ();
	stack_ptr = P_stack_ptr;
	call get_stack;
	if code ^= 0 then return;
	for_number = 0;
	sp = pointer (sb, fixed (rel (stack_header.stack_begin_ptr), 18));
	if fixed (rel (sp), 18) >= fixed (rel (stack_header.stack_end_ptr), 18) then do;
		code = amu_et_$no_valid_stacks;
		return;
	     end;
	stack_frames_fwd, stack_frames_rev = 0;
	call CHECK_THREAD;
	if code ^= 0 then goto ERROR;
	stop = "0"b;
	frame_number = 0;
     end set_up_search;
%page;



thread_ptr_val:
     proc (vptr, segno_check) returns (bit (1));
	dcl     vptr		 ptr;
	dcl     segno_check		 bit (1);

dcl ret_bit bit(1);
dcl any_other condition;
ret_bit="0"b;
on condition (any_other) begin;
   goto RET_VAL;
   end;

	if addr (vptr) -> its.its_mod = ITS_MODIFIER then
	     if segno_check then
		if segno = fixed (baseno (vptr), 17) then
		     ret_bit= "1"b;
		else ret_bit= "0"b;
	     else ret_bit = "1"b;
	else ret_bit ="0"b;

revert any_other;
RET_VAL:
    return(ret_bit);
     end thread_ptr_val;
%page; %include amu_info;
%page; %include amu_mc;
%page; %include amu_translation;
%page; %include arg_list;
%page; %include condition_info_header;
%page; %include data_type_info_;
%page; %include its;
%page; %include mc;
%page; %include probe_data_type_names;
%page; %include stack_frame;
%page; %include stack_header;
%page; %include std_descriptor_types;

     end azm_stack_trace_;

