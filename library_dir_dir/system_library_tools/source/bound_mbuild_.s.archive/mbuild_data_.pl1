
/****^  HISTORY COMMENTS:
  1) change(2019-08-17,GDixon), approve(2019-10-27,MCR10069),
     audit(2020-01-20,Swenson), install(2020-01-20,MR12.6g-0035):
     mbuild subroutines that performs various operations on structures declared
     in mbuild_data_.incl.pl1.
  2) change(2020-07-06,GDixon), approve(2021-02-22,MCR10086),
     audit(2021-03-17,Swenson), install(2021-03-17,MR12.6g-0051):
      A) Fix bug in reporting install_ec progress.
      B) Detect Seg.name duplication in mbuild_data_$scan_Tb_insert entrypoint.
         (Ticket #213)
  3) change(2020-11-09,GDixon), approve(2021-02-22,MCR10086),
     audit(2021-03-17,Swenson), install(2021-03-17,MR12.6g-0051):
      A) Fix bug in mbuild_data_$get_Seg handling of Seg being DELETEd.
      B) Change mbuild_data_$scan_Tb_insert to order Seg being DELETEd
         before other Seg's of same type being ADDed or REPLACEd.
      C) Fix bug in mbuild_data_$get_Seg handling of archive components.
                                                   END HISTORY COMMENTS */

mbuild_data_:
     proc(AsciP, Abuild_dataP) returns(bit(1) aligned);

  dcl  PROC char(12) int static options(constant) init("mbuild_data_");

     return (check_parms(mbuild_data_version_3));
/* -------------------- */

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* SUBROUTINE:  mbuild_data_							        */
	/*									        */
	/* Function:  main provider of helper routines for the mbuild subsystem.		        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

  dcl (addr, divide, hbound, length, maxlength, null, rtrim, size) builtin;
     
  dcl (cleanup) condition;

  dcl  get_shortest_path_ entry (char(*)) returns(char(168));
  dcl  get_wdir_ entry() returns(char(168));
  dcl  hcs_$status_minf entry (char(*), char(*), fixed bin(1), fixed bin(2), fixed bin(24), fixed bin(35));
  dcl  initiate_file_$component entry (char(*), char(*), char(*), bit(*), ptr, fixed bin(24), fixed bin(35));
  dcl  ioa_ entry() options(variable);

  dcl  mbuild_Tlist_$empty_Seg_inArch_list entry (ptr);
  dcl  mbuild_Tlist_$find_BOUNDOBJ entry (ptr, char(*) var, char(*) var, ptr) returns(ptr);
  dcl  mbuild_Tlist_$find_Seg entry (ptr, char(*) var, char(*) var, ptr) returns(ptr);
  dcl  mbuild_Tlist_$find_UNBOUNDOBJ entry (ptr, char(*) var, char(*) var, ptr) returns(ptr);

  dcl  mbuild_analyze_$populated_threads entry (ptr, bit(1)) returns(bit(1) aligned);
  dcl  mbuild_archive_$prepared entry (ptr, bit(1)) returns(bit(1) aligned);
  dcl  mbuild_compile_$exist_all_Unbound_obj entry (ptr, bit(1) unal) returns(bit(1) aligned);

  dcl  mbuild_info_find_$paradigm_by_index entry (fixed bin) returns(ptr);
  dcl  mbuild_info_find_$seg_type_for_seg_name entry (char(*) var) returns(ptr);

  dcl  mbuild_install_$exists_Build_exec_com entry (ptr) returns(bit(1) aligned);

  dcl  mbuild_lib_names_$release_lib_names entry (ptr);

  dcl  mbuild_library_$archive_table entry (char(*), char(*) var, char(*) var, (*) char(32) var, fixed bin,
	fixed bin(35));
  dcl  mbuild_library_$get_primary_name entry (ptr, char(*), char(*), fixed bin(35)) returns(char(32));
  dcl  mbuild_library_$library_directories entry (char(*) var, (*) char(200) var, fixed bin, fixed bin(35));
  dcl  mbuild_library_$locate_Seg entry (ptr, ptr);
  dcl  mbuild_library_$search entry (char(*) var, char(*) var, (*) char(200) var, fixed bin, fixed bin(35));

  dcl  mbuild_print_$Seg entry (ptr, ptr, char(32) var, char(32) var);

  dcl  mbuild_scan_$found_segments entry (ptr) returns(bit(1) aligned);

  dcl  mbuild_set_$description entry (ptr) returns(char(*));
  dcl  mbuild_set_$description_stored entry (ptr) returns(bit(1) aligned);
  dcl  mbuild_set_$release_description entry (ptr);
  dcl  mbuild_set_$store_description entry (ptr, char(*) var);

  dcl  ssu_$get_area entry (ptr, ptr, char(*), ptr);
  dcl  terminate_file_ entry (ptr, fixed bin(24), bit(*), fixed bin(35));

  dcl  translator_temp_$allocate entry (ptr, fixed bin) returns(ptr);
  dcl  translator_temp_$get_segment entry (char(*) aligned, ptr, fixed bin(35));
  dcl  translator_temp_$release_all_segments entry (ptr, fixed bin(35));

  dcl (error_table_$badstar,
       error_table_$entlong,
       error_table_$namedup,
       mbuild_et_$unknown_segment_type) fixed bin(35) ext static;

%page;
/* ======================================================================
 *
 * ENTRYPOINT:  mbuild_data_$initialize_build_lists
 * 
 * Function:    Completely (re-)initialize all threads, discarding any
 *              data structures created earlier.		        
 *
 * Callers:   
 *  mbuild command: each time the mbuild command is invoked 
 *                   in the process.
 *  scan request:   each time install directory is (re-)scanned.
 *                   Scanning several times during an invocation might 
 *                   happen to look for new files added to a changeset; 
 *                   or after removing derived files from the changeset 
 *                   (via a clean request).
 *
 * ====================================================================== */

initialize_build_lists:
     entry (Abuild_dataP);

/*dcl  Abuild_dataP ptr;				/* Pointer to build_data structure.		        */
						/*  (actually declared in mbuild_data_.incl.pl1)	        */
     bld.directory = get_shortest_path_ (get_wdir_());	/* Always use working dir as the installation directory.  */
     bld.build_script_prefix = get_build_script_prefix();	/*  - Update the script prefix as well.		        */

/* ----------------------------------------------------------------------
    Many subroutines only work with a standard-format area.
    Get the standard area obtained (and cleaned-up) by ssu_.
 * ---------------------------------------------------------------------- */

     call ssu_$get_area (bld.sciP, null(), "standard area", bld.ssu_areaP);


/* ----------------------------------------------------------------------
    Get an allocation area suitable for use by lex_string_/reductions.
    This is a non-free area in which each allocation extends bounds of
    the area, and data is tightly-packed.

     - If we're starting over (as might happen with a scan or read 
       request), free any temporary area remaining from prior 
       initialization.
     - Preserve any Description value known to mbuild.
 * ---------------------------------------------------------------------- */

  dcl  description char(2000) var;
     description =  mbuild_set_$description (addr(bld));	/* Temporarily copy current Description, if any.	        */

     call mbuild_set_$release_description (addr(bld));	/* Any Description: field is stored as a structure in     */
						/*  translator_temp_ storage, which we release below.     */
     call mbuild_lib_names_$release_lib_names (addr(bld));

     if bld.areaP ^= null() then do;
	call translator_temp_$release_all_segments (bld.areaP, code);
	if code ^= 0 then
	     call ssu_$print_message (bld.sciP, code, "mbuild_data_$initialize_build_lists releasing temp segments.");
	end;

     call translator_temp_$get_segment (ssu_$get_subsystem_name (bld.sciP), bld.areaP, code);
     if code ^= 0 then 
	call ssu_$abort_subsystem (bld.sciP, code, "mbuild_data_$initialize_build_lists calling translator_temp_.");

     call mbuild_set_$store_description (addr(bld), description);


/* ----------------------------------------------------------------------
    Reset the seq.type array (used by scan_Tb_insert entrypoint) to 
    insert Seg() structures into the scan_Tb thread in an order sorted
    for printing.  

    Note: The 8 most-important Seg(<seg-type>) type names appear in a 
          static array in fixed order, to control the order in which
          such Seg() data is displayed by a print request.  

	This static array of seg types is declared/used by the
          type_seq routine (and by other callers).  
           - Less-frequently seen seg types are automatically added 
	   to the list as such segments are found via scan or read 
	   requests.
           - Since the array is retained across invocations of mbuild 
             within the same process, these lesser types need to be 
	   removed from that array each time mbuild is invoked within 
	   a process.  This call removes them more frequently: each 
             time the data maintained by mbuild data is (re-)initialized.
 * ---------------------------------------------------------------------- */

     call type_seq$init_seq();


/* ----------------------------------------------------------------------
    Initialize all the threaded lists based in build_data.
 * ---------------------------------------------------------------------- */

     call Tlist_initialize (addr(bld.Seg_Tb),	       addr(bld));

RESET_BUILD_LISTS:
     call Tlist_initialize (addr(bld.scan_Tb),           addr(bld));
     call Tlist_initialize (addr(bld.INTERMEDIATE_Tb),   addr(bld));
     call Tlist_initialize (addr(bld.BOUNDOBJ_Tb),       addr(bld));
     call Tlist_initialize (addr(bld.COMPILE_Tb),	       addr(bld));
     call Tlist_initialize (addr(bld.UNBOUNDOBJ_Tb),     addr(bld));
     call Tlist_initialize (addr(bld.source_Tb),	       addr(bld));
     call Tlist_initialize (addr(bld.bindfile_Tb),       addr(bld));
     call Tlist_initialize (addr(bld.source_arch_Tb),    addr(bld));
     call Tlist_initialize (addr(bld.object_arch_Tb),    addr(bld));
     call Tlist_initialize (addr(bld.Bound_obj_Tb),      addr(bld));
     call Tlist_initialize (addr(bld.Unbound_obj_Tb),    addr(bld));
     call Tlist_initialize (addr(bld.target_only_Tb),    addr(bld));
     call Tlist_initialize (addr(bld.object_x_only_Tb),  addr(bld));
     call Tlist_initialize (addr(bld.listing_Tb),	       addr(bld));
     call Tlist_initialize (addr(bld.mbuild_support_Tb), addr(bld));

     call reset_build_progress (addr(bld));		/* Almost all progress is lost by above initializations.  */

     return;
%page;
/* ======================================================================
 *
 * ENTRYPOINT:  mbuild_data_$reset_build_lists
 * 
 * Function:    Mostly (re-)initialize all threads, but retaining the
 *              Seg_Tb thread, and all Segs thereon.
 *
 * Callers:   
 *  read request:   each time the MCRnnn.mb build script is (re-)parsed
 *                   looking for edits to that file.  Such operations
 *                   rebuild the scan_Tb list of segments found in the
 *                   install directory, based upon (perhaps edited)
 *                   entries in the build script file.
 *
 * ====================================================================== */

reset_build_lists:
     entry (Abuild_dataP);

     do SegP = Tlist_first_item (addr(bld.Seg_Tb))
        repeat Tlist_next_item  (addr(Seg.Seg_Td)) while (SegP ^= null() );
	call reset_Seg (SegP);			/* Remove all connections to existing Seg structures.     */
	end;
     goto RESET_BUILD_LISTS;

%page;
/* ======================================================================
 *
 * ENTRYPOINT:  mbuild_data_$get_build_progress
 * 
 * Function:    Examine threaded lists and other stored data to determine:
 *               - if a build description field has been set;
 *               - if a scan or read requests has created a list of
 *                 original-content files in the installation directory.
 *               - if an analyze request has populated the other threaded
 *                 lists.
 *	       - if all original-content source files have been compiled
 *	         successfully (their derived-content Unbound_obj exists),
 *	         and any UNBOUNDOBJ have existing object segments, ready
 *	         to install.
 *	       - if all Bound_obj and their component archives are ready
 *	         to install.
 *               - if an install_ec request generated a Build_exec_com.
 *
 * Callers:   
 *  Use this entrypoint to determine if enough data is available to allow
 *  them to perform their function (e.g., save request checks whether 
 *  an analyze request has built the threaded lists needed for saving the
 *  build script into a .mb file).
 *    OR
 *  Use this entrypoint to determine if earlier build attempt created
 *  data that needs to be cleaned up before the next attempted build.
 *
 * ====================================================================== */

get_build_progress:
     entry (Abuild_dataP) returns (bit(*) aligned);

     bld_progress = F;
     bld_progress.describedS  = mbuild_set_$description_stored (addr(bld));
     bld_progress.scannedS    = mbuild_scan_$found_segments (addr(bld));
     bld_progress.analyzedS   = mbuild_analyze_$populated_threads (addr(bld), bld_progress.scannedS);     

     if  bld.progress.compiledS  then
	bld_progress.compiledS   = T;
     else bld_progress.compiledS   = mbuild_compile_$exist_all_Unbound_obj (addr(bld), bld_progress.analyzedS);

     if  bld.progress.compiledS & bld.progress.preppedS  then
	bld_progress.preppedS    = T;
     else bld_progress.preppedS    = mbuild_archive_$prepared (addr(bld), bld_progress.compiledS);
     
     if  bld.progress.compiledS & bld.progress.preppedS  then
	bld_progress.install_ecS = mbuild_install_$exists_Build_exec_com (addr(bld));

     string(bld.progress) = string(bld_progress);
     return (string(bld_progress));

/* ----------------------------------------------------------------------
   SUPPORTING ENTRYPOINTS

   The following entrypoints are called when requests being monitored 
   complete their actions.  These entrypoints call back into that request
   at another entrypoint, to permit the request's code to determine actual
   completion and success/failure of those actions.
   ---------------------------------------------------------------------- */

archive_prep_build_progress_update:			/* Determine success of an archive_prep invocation.       */
     entry (Abuild_dataP);

     bld.progress.preppedS = mbuild_archive_$prepared (addr(bld), bld.progress.compiledS);
     return;
     
clean_build_progress_update:				/* This entrypoint clears past progress, so need to       */
     entry (Abuild_dataP);				/*  perform a given request can be re-evaluated after a   */
     						/*  clean operation.			        */
     bld.progress.compiledS = F;
     bld.progress.preppedS = F;
     bld.progress.install_ecS = F;
     return;

compile_build_progress_update:			/* Determine success of a comcpile invocation.	        */
     entry (Abuild_dataP);

     bld.progress.compiledS = mbuild_compile_$exist_all_Unbound_obj (addr(bld), bld.progress.analyzedS);
     return;

install_ec_build_progress_update:			/* Determine success of an install_ec invocation.	        */
     entry (Abuild_dataP, AerrorsN);

  dcl  AerrorsN fixed bin;
     
     if  AerrorsN > 0  then
	bld.progress.install_ecS = F;
     else bld.progress.install_ecS = mbuild_install_$exists_Build_exec_com (addr(bld));
     return;


/* ======================================================================
   ENTRYPOINT:  mbuild_data_$reset_build_progress

   Function:  Initializes bld.progress values when mbuild is first invoked;
	    and resets those values if a scan or read requests starts over 
	    in building the changeset.

   Callers:   initialize_build_lists and reset_build_lists (entrypoints above)
   ====================================================================== */

reset_build_progress:
     entry (Abuild_dataP);
     
     bld.progress = F;
     bld.progress.describedS  = mbuild_set_$description_stored (addr(bld));     
     return;

%page;
/* ======================================================================
   ENTRYPOINT:  mbuild_data_$unknown_library_found

   Function:    Check scan_Tb list for Seg.library containing "UNKNOWN".

   Output:      Returns T if Seg's with UNKNOWN library are found; F otherwise.
   ====================================================================== */
unknown_library_found:
     entry (Abuild_dataP, Aprint) returns (bit(1) aligned);
     
  dcl  Aprint bit(1) aligned;				/*  = F: no message printed			        */
						/*  = T: print each Seg with UNKNOWN library	        */

  dcl (prior_archive_title,
       prior_type_name) char(32) var init("");
  dcl  unknown_lib_found bit(1) aligned init(F);

     do SegP = Tlist_first_item (addr(bld.scan_Tb))
        repeat Tlist_next_item  (addr(Seg.scan_Td))  while (SegP ^= null());
     
	if index(Seg.library, "UNKNOWN") > 0 then do;
	     if Aprint then do;
		if ^unknown_lib_found then
		     call ioa_ ("^/The following segments have an UNKNOWN library:");
		call mbuild_print_$Seg (bld.sciP, SegP, prior_archive_title, prior_type_name);
		end;
	     unknown_lib_found = T;
	     end;
	end;
     return (unknown_lib_found);

%page;
/* ======================================================================
 *
 * ENTRYPOINT:  mbuild_data_$get_COMPILE
 * 
 * Purpose:     A COMPILE structure is a relationship structure that
 *              manages compilation of a Seg(source) by a translator.
 *	      This structure:
 *               - locates original-content source files requiring 
 *                 compilation; and 
 *               - points to derived output files from such compilation 
 *	         (e.g., intermediate PL/I file generated
 *                 by reductions command; 
 *	       - points to object segment resulting from the compilation; 
 *	       - points to optional listing file produced by the
 *	         compilation.
 *
 * Threads:     build_data.COMPILE_Tb - list of all COMPILE structures.
 *               - This entrypoint automatically adds each new COMPILE
 *                 structure to the COMPILE_Tb thread, as the structure
 *                 is created.
 *
 * Notes:       There is no attempt to look for an already-existing
 *              COMPILE structure handling compilation of the same
 *              AsourceP->Seg(source) file.  Program logic within
 *              callers of this routine must guarantee only one
 *	      COMPILE structure is generated to manage each source
 *	      segment.
 * ====================================================================== */

get_COMPILE:
     entry (Abuild_dataP, Aname, Alibrary, AsourceP) returns(ptr);
     
/*dcl  Abuild_dataP ptr;				/* Pointer to build_data structure.		        */
  dcl  Aname char(*) var;				/* Name    of Seg(source) structure to be compiled.       */
  dcl  Alibrary char(*) var;				/* Library of Seg(seg) structure.		        */
  dcl  AsourceP ptr;				/* Pointer to Seg(source) structure to be compiled.       */

     COMPILEp = translator_temp_$allocate (bld.areaP, size(COMPILE));
     COMPILE.info = "";				/* Get storage for new COMPILE structure.	        */
     COMPILE.request_Td = Tlist_initial_data;
     COMPILE.COMPILE_Td = Tlist_initial_data;
     COMPILE.ptrs = null();

     COMPILE.struct = "COMP";				/* Initialize COMPILE.info components of the structure.   */
     COMPILE.type = "COMPILE";
     COMPILE.name = Aname;
     COMPILE.library = Alibrary;
     COMPILE.sourceP = AsourceP;
     
     if  AsourceP ^= null()  then do;
	COMPILE.compiler = AsourceP->Seg.compiler;
	COMPILE.compile_options = AsourceP->Seg.compile_options;
	end;

     call Tlist_add_to_tail (addr(bld.COMPILE_Tb), addr(COMPILE), addr(COMPILE.COMPILE_Td));
     return ( addr(COMPILE) );
%page;
/* ======================================================================
 *
 * ENTRYPOINT:  mbuild_data_$get_BOUNDOBJ
 * 
 * Purpose:     A BOUNDOBJ structure is a relationship structure that
 *              manages creation of a Seg(Bound_obj) by a bind operation,
 *              and installation of that bound object, with updates to
 *              all of its original content sources.
 *
 * Function:    Allocate and populate a new BOUNDOBJ structure, which:
 *               - manages inputs needed to create/update this bound
 *	         object segment (source archives, object archives, 
 *                 bindfile).
 *               - manages outputs from the bind command: the derived 
 *	         bound object segment; any bindmap (.list) file.
 *
 * Threads:     build_data.BOUNDOBJ_Tb - list of all BOUNDOBJ structures.
 *               - This entrypoint automatically adds each new BOUNDOBJ
 *                 structure to the BOUNDOBJ_Tb thread, as the structure
 *                 is created.
 *	       - This entrypoint searches for any existing BOUNDOBJ
 *                 structure handling a bound object of same name and 
 *                 and library as that specified by caller.  If found,
 *	         that existing BOUNDOBJ structure is returned, instead
 *	         of creating a new structure.
 *
 * ====================================================================== */

get_BOUNDOBJ:
     entry (Abuild_dataP, Aname, Alibrary, Aoperation, AbindfileP) returns(ptr);
     
/*dcl  Abuild_dataP ptr;				/* Pointer to build_data structure.		        */
/*dcl  Aname char(*) var;				/* Name of Seg structure to look for/create.	        */
/*dcl  Alibrary char(*) var;				/* Library of seg structure to look for.	        */
/*dcl  Aoperation char(*) var;			/* = "ADD", "REPLACE", "DELETE"		        */
  dcl  AbindfileP ptr;				/* Pointer to Seg(bindfile) structure controlling bind.   */

     BOUNDOBJp = mbuild_Tlist_$find_BOUNDOBJ (Abuild_dataP, Aname, Alibrary, null() );
     if BOUNDOBJp ^= null then do;			/* Return any existing BOUNDOBJ structure for this        */
						/*  bound object name and library...		        */
	if Aoperation = "DELETE" then do;		/* For DELETE op, both .operation and primary name        */
						/*  of existing BOUNDOBJ entry must match inputs. Else,   */
						/*  we're deleting old BOUNDOBJ, replacing with new       */
						/*  version.				        */
	     if BOUNDOBJ.operation ^= "DELETE" then goto MAKE_NEW_BOUNDOBJ;
	     if BOUNDOBJ.name ^= Aname         then goto MAKE_NEW_BOUNDOBJ;
	     end;
	if Alibrary ^= "" & BOUNDOBJ.library = "" then	/*  - Inputs provided by latest caller for bound object   */
	     BOUNDOBJ.library = Alibrary;		/*    can supply data items not known to earlier caller.  */
	if Aoperation ^= "" & BOUNDOBJ.operation = "" then
	     BOUNDOBJ.operation = Aoperation;
	if AbindfileP ^= null() & BOUNDOBJ.bindfileP = null() then
	     BOUNDOBJ.bindfileP = AbindfileP;
	goto GET_BOUNDOBJ_RETURN;
	end;

MAKE_NEW_BOUNDOBJ:					/* RULE: Always get Seg(<type>) labels from mbuild_info_  */
     segtP = mbuild_info_find_$seg_type_for_seg_name (Aname);    
     if segtP = null() then do;
	call ssu_$print_message (bld.sciP, mbuild_et_$unknown_segment_type, "Ignoring BOUNDOBJ: ^a", Aname);
	return ( null() );
	end;

     BOUNDOBJp = translator_temp_$allocate (bld.areaP, size(BOUNDOBJ));
     BOUNDOBJ.info = "";				/* Get storage for new BOUNDOBJ structure.	        */
     BOUNDOBJ.request_Td = Tlist_initial_data;
     BOUNDOBJ.BOUNDOBJ_Td = Tlist_initial_data;
     BOUNDOBJ.ptrs = null();
     BOUNDOBJ.sourceArchsN = 0;

     call Tlist_initialize (addr(BOUNDOBJ.sourceArchs_Tb), addr(BOUNDOBJ));
     call Tlist_initialize (addr(BOUNDOBJ.objectArchs_Tb), addr(BOUNDOBJ));

     BOUNDOBJ.struct = "BND";				/* Initialize BOUNDOBJ.info components of the structure.  */
     BOUNDOBJ.type = segt.mbuild_type;
     BOUNDOBJ.name = Aname;
     BOUNDOBJ.library = Alibrary;
     BOUNDOBJ.operation = Aoperation;
     BOUNDOBJ.bindfileP = AbindfileP;

     call mbuild_library_$locate_Seg (addr(bld), addr(BOUNDOBJ));
						/* Look for existing bound object in Multics Libraries.   */

     if index(BOUNDOBJ.library,"UNKNOWN") > 0  & Alibrary ^= ""  then
	BOUNDOBJ.library = Alibrary;			/* Use caller-supplied library name when ADDing bound obj */
     BOUNDOBJ.library = before(BOUNDOBJ.library,".");	/* For BOUNDOBJ, remove <lib-dir> component of library    */

  dcl  search_lib char(32) var;
  dcl  paths (10) char(200) var;
     if BOUNDOBJ.operation ^= "ADD" then do;		/* RULE: Count source archives existing in Multics Libs.  */
	if  index(BOUNDOBJ.library, "UNKNOWN") = 0  &  BOUNDOBJ.library ^= ""  then
	     search_lib = BOUNDOBJ.library || ".source";
	else search_lib = "source";
	call mbuild_library_$search (search_lib, BOUNDOBJ.name || ".**.archive", paths, BOUNDOBJ.sourceArchsN, code);
	if code = error_table_$badstar then 
	     call mbuild_library_$search (search_lib, BOUNDOBJ.name || ".*.archive", paths, BOUNDOBJ.sourceArchsN, code);
	end;

     call Tlist_add_to_tail (addr(bld.BOUNDOBJ_Tb), addr(BOUNDOBJ), addr(BOUNDOBJ.BOUNDOBJ_Td));

GET_BOUNDOBJ_RETURN:
     return ( addr(BOUNDOBJ) );
%page;
/* ======================================================================
 *
 * ENTRYPOINT:  mbuild_data_$get_UNBOUNDOBJ
 * 
 * Purpose:     An UNBOUNDOBJ structure is a relationship structure that
 *              manages installation of a Seg(Unbound_obj) that was 
 *              derived from a compile operation.
 * 
 * Function:    Allocate and populate a new UNBOUNDOBJ structure, which:
 *               - manages input needed to create/update this unbound
 *	         object segment: sourceP->Seg(source) 
 *
 * Threads:     build_data.UNBOUNDOBJ_Tb - list of all UNBOUNDOBJ structs.
 *               - This entrypoint automatically adds each new UNBOUNDOBJ
 *                 structure to the UNBOUNDOBJ_Tb thread, as the structure
 *                 is created.
 *	       - This entrypoint searches for any existing UNBOUNDOBJ
 *                 structure handling an unbound object of same name and 
 *                 and library as that specified by caller.  If found,
 *	         that existing UNBOUNDOBJ structure is returned, instead
 *	         of creating a new structure.
 *
 * ====================================================================== */

get_UNBOUNDOBJ:
     entry (Abuild_dataP, Aname, Alibrary, Aoperation, AsourceP) returns(ptr);
     
/*dcl  Abuild_dataP ptr;				/* Pointer to build_data structure.		        */
/*dcl  Aname char(*) var;				/* Name of unbound object structure to look for/create.   */
/*dcl  Alibrary char(*) var;				/* Library in which unboud object will be installed.      */
/*dcl  Aoperation char(*) var;			/* = "ADD", "REPLACE", "DELETE"		        */
/*dcl  AsourceP ptr;				/* Pointer to Seg(source) structure compiled into the     */
						/*  UNBOUNDOBJ.				        */

     UNBOUNDOBJp = mbuild_Tlist_$find_UNBOUNDOBJ (Abuild_dataP, Aname, "", null() );
						/*  - Don't use Alibrary in searching... since different  */
						/*    lib names may have been devised by user editing     */
						/*    build script file which add names to Unbound_obj.   */
     if UNBOUNDOBJp ^= null then do;
	if Aoperation = "DELETE" then do;		/* For DELETE op, both .operation and primary name        */
						/*  of existing UNBOUNDOBJ entry must match inputs. Else, */
						/*  we're deleting old UNBOUNDOBJ, replacing with new     */
						/*  version.				        */
	     if UNBOUNDOBJ.operation ^= "DELETE" then goto MAKE_NEW_UNBOUNDOBJ;
	     if UNBOUNDOBJ.name ^= Aname	 then goto MAKE_NEW_UNBOUNDOBJ;
	     end;
	if Alibrary ^= "" & UNBOUNDOBJ.library = "" then 
	     UNBOUNDOBJ.library = Alibrary;
	if Aoperation ^= "" & UNBOUNDOBJ.operation = "" then
	     UNBOUNDOBJ.operation = Aoperation;
	if AsourceP ^= null() & UNBOUNDOBJ.sourceP = null() then
	     UNBOUNDOBJ.sourceP = AsourceP;
	goto GET_UNBOUNDOBJ_RETURN;
	end;

MAKE_NEW_UNBOUNDOBJ:				/* RULE: Always get Seg(<type>) labels from mbuild_info_  */
     segtP = mbuild_info_find_$seg_type_for_seg_name (Aname);
     if segtP = null() then do;
	call ssu_$print_message (bld.sciP, mbuild_et_$unknown_segment_type, "Ignoring UNBOUNDOBJ: ^a", Aname);
	return ( null() );
	end;

     UNBOUNDOBJp = translator_temp_$allocate (bld.areaP, size(UNBOUNDOBJ));
     UNBOUNDOBJ.info = "";				/* Get storage for new UNBOUNDOBJ structure.	        */
     UNBOUNDOBJ.request_Td = Tlist_initial_data;
     UNBOUNDOBJ.UNBOUNDOBJ_Td = Tlist_initial_data;
     UNBOUNDOBJ.ptrs = null();

     UNBOUNDOBJ.struct = "UBND";			/* Initialize UNBOUNDOBJ.info components of the structure.*/
     UNBOUNDOBJ.type = segt.mbuild_type;
     UNBOUNDOBJ.name = Aname;
     UNBOUNDOBJ.library = Alibrary;
     UNBOUNDOBJ.operation = Aoperation;
     UNBOUNDOBJ.sourceP = AsourceP;

     call mbuild_library_$locate_Seg (addr(bld), addr(UNBOUNDOBJ));
						/* This controls .library and .operation values. 	        */
     
     if index(UNBOUNDOBJ.library,"UNKNOWN") > 0  & Alibrary ^= ""  then
	UNBOUNDOBJ.library = Alibrary;
     UNBOUNDOBJ.library = before(UNBOUNDOBJ.library, ".");

     call Tlist_add_to_tail (addr(bld.UNBOUNDOBJ_Tb), addr(UNBOUNDOBJ), addr(UNBOUNDOBJ.UNBOUNDOBJ_Td));

GET_UNBOUNDOBJ_RETURN:
     return ( addr(UNBOUNDOBJ) );
%page;     
/* ======================================================================
 *
 * ENTRYPOINT:  mbuild_data_$get_Seg
 * 
 * Purpose:     A Seg structure represents a real segment found in the
 *              install directory.  It may be an original content file 
 *              found in that directory before a build starts; or a 
 *              derived file generated by the build.
 *
 * Function:    Allocate and populate a new Seg structure, which:
 *               - tracks name and location of the segment within the
 *	         Multics Libraries.
 *               - type of operation being performed on the segment.
 *               - associated source or object archive that may hold
 *	         an original content segment when it is installed.
 *
 * Threads:     build_data.Seg_Tb - list of all Seg structures.
 *               - This entrypoint automatically adds each new Seg
 *                 structure to the Seg_Tb thread, as the structure
 *                 is created.
 *	       - This entrypoint searches for any existing Seg
 *                 structure handling a segment of same name and 
 *                 and library as that specified by caller.  If found,
 *	         that existing Seg structure is returned, instead
 *	         of creating a new structure.
 *
 * ====================================================================== */

get_Seg:
     entry (Abuild_dataP, Atype, Aname, Alibrary, Aoperation, Aarchive_name) returns(ptr);

/*dcl  Abuild_dataP ptr;				/* Pointer to build_data structure.		        */
  dcl  Atype char(*) var;				/*  = [mbt seg Aname -type] value		        */
/*dcl  Aname char(*) var;				/* Name    of Seg structure to look for/create.	        */
/*dcl  Alibrary char(*) var;				/* Library of Seg structure to look for.	        */
  dcl  Aoperation char(*) var;			/*  = "ADD", "REPLACE", "UPDATE" or "DELETE"	        */
						/*    UPDATE used only on archives.  It distinguishes     */
						/*     between the usual operation for an existing        */
						/*     archive: updating individual components therein;   */
						/*     versus  an operation that replaces the entire      */
						/*     archive contents without individual comp updates.  */
  dcl  Aarchive_name char(*) var;			/* Name of containing archive (if known); else ""	        */

     SegP = mbuild_Tlist_$find_Seg (Abuild_dataP, Aname, "", null() );
     if SegP ^= null then do;				/* If Seg with Aname already exists...		        */
	if Aarchive_name ^= ""  &			/*  - we're looking for Seg in a specific archive	        */
	   Seg.archive_name ^= ""  &			/*  - found Seg has an archive		        */
	   Seg.archive_name ^= Aarchive_name  then	/*  - but no match for our wished for archive_name        */
	     goto MAKE_NEW_Seg;
	if Aoperation = "DELETE" then do;		/* For DELETE op, both .operation and primary name        */
						/*  of existing Seg entry must match inputs. Otherwise,   */
						/*  we're deleting old seg, replacing with a new version. */
	     if Seg.operation ^= "DELETE" then goto MAKE_NEW_Seg;
	     if Seg.name ^= Aname	    then goto MAKE_NEW_Seg;
	     end;
	if Atype ^= ""      then Seg.type = Atype;
	if Alibrary ^= ""   then Seg.library = Alibrary;
	if Aoperation ^= "" then Seg.operation = Aoperation;
	if Aarchive_name ^= "" & Seg.archive_name = "" then
	     Seg.archive_name = Aarchive_name;
	goto GET_SEG_RETURN;
	end;

MAKE_NEW_Seg:					/* RULE: Always get Seg(<type>) labels from mbuild_info_  */
     segtP = mbuild_info_find_$seg_type_for_seg_name (Aname);
						/* Get Multics Libraries segment type.		        */
     if segtP = null() then do;
	call ssu_$print_message (bld.sciP, mbuild_et_$unknown_segment_type, "Ignoring Seg: ^a", Aname);
	return ( null() );
	end;

     SegP = translator_temp_$allocate (bld.areaP, size(Seg));
     Seg.info = "";					/* Get storage for new Seg structure.		        */
     Seg.request_Td      = Tlist_initial_data;
     Seg.Seg_Td          = Tlist_initial_data;		/* Seg structures can appear on many different threaded   */
     Seg.pdm_Td          = Tlist_initial_data;		/*  lists.  Initialize the thread data for each kind of   */
     Seg.scan_Td         = Tlist_initial_data;		/*  list.					        */
     Seg.INTERMEDIATE_Td = Tlist_initial_data;
     Seg.archs_Td        = Tlist_initial_data;
     Seg.inArch_Td	     = Tlist_initial_data;

     call Tlist_initialize (addr(Seg.inArch_Tb), addr(Seg));/* A Seg(XXXX_arch) defines its own list of Seg()s        */
						/*  contained within the archive (or being added/updated  */
						/*  within the archive.			        */
     Seg.ptrs = null();

     Seg.struct = "Seg";				/* Initialize Seg.info components of the structure.       */
     Seg.type = Atype;
     Seg.name = Aname;
     Seg.library = Alibrary;
     Seg.operation = Aoperation;
     Seg.archive_name = Aarchive_name;

     Seg.compiler        = segt.compiler;
     Seg.compile_options = segt.default_compile_options;
     if Seg.type = unknown_type then 
	Seg.type = segt.mbuild_type;
     if Seg.library = "" | Seg.library = "UNKNOWN" then
	Seg.library = segt.default_library;
     Seg.seg_typeP = segtP;

     pdmP = mbuild_info_find_$paradigm_by_index (segt.build_paradigm);
     if pdmP = null() then do;			/* Get Multics Libraries build paradigm for this segment. */
	call ssu_$print_message (bld.sciP, 0, "Seg creation failed: ^a (invalid build paradigm: ^d)",
	     Seg.name, segt.build_paradigm);
	SegP = null();				/* Skip over this segment with unknown build paradigm.    */
	goto GET_SEG_RETURN;
	end;
     Seg.build_typeP = pdmP;

     call mbuild_library_$locate_Seg (addr(bld), addr(Seg));/* Controls Seg.library, .operation and .archive_name     */
						/*  values.				        */

     if index(Seg.library,"UNKNOWN") > 0  & Alibrary ^= "" & index(Alibrary,"UNKNOWN") = 0 then
	Seg.library = Alibrary;

     if segt.build_paradigm = PDM_mbuild_support then do;	/* Build support files never get installed.	        */
	Seg.library = "";
	Seg.operation = "";
	end;

     call Tlist_add_to_tail (addr(bld.Seg_Tb), SegP, addr(Seg.Seg_Td));
						/* Add structure to our list of Segs.		        */
GET_SEG_RETURN:
     return (SegP);
%page;
/* ======================================================================
 *
 * ENTRYPOINT:  mbuild_data_$disconnect_Seg
 * 
 * Purpose:     Remove a Seg structure from all of its threads except
 *              the Seg_Tb, and disconnect its between-structure
 *              pointers for: COMPILE, BOUNDOBJ, UNBOUNDOBJ
 *              This call should only be used for derived-content Segs.
 *
 * Threads:     all those that include this Seg, except the Seg_Tb.
 *
 * ====================================================================== */

disconnect_Seg:
     entry (ASegP);

     if ASegP = null() then return;
     SegP = ASegP;
     if  ^disconnectable_Seg(SegP)  then return;		/* Never disconnect a Seg created by scan or analyze.     */

DISCONNECT:
     call Tlist_remove (addr(Seg.request_Td));		/* Remove membership from all containing lists.	        */
     call Tlist_remove (addr(Seg.pdm_Td));
     call Tlist_remove (addr(Seg.scan_Td));
     call Tlist_remove (addr(Seg.INTERMEDIATE_Td));
     call Tlist_remove (addr(Seg.archs_Td));
     call Tlist_remove (addr(Seg.inArch_Td));

     call mbuild_Tlist_$empty_Seg_inArch_list (SegP);	/* Totally empty list maintained by this Seg.	        */

     if Seg.BOUNDOBJp ^= null() then
	Seg.BOUNDOBJp = null();			/* Backpointer for Seg.archs_Td list.		        */

     if Seg.COMPILEp ^= null() then do;
	if Seg.type = "listing" then
	     Seg.COMPILEp->COMPILE.listingP = null();
	else if Seg.type = "Unbound_obj" then
	     Seg.COMPILEp->COMPILE.objectP = null();
	else if Seg.type = "source"  &  Seg.produced_by_compiler ^= "" then
	     Seg.COMPILEp->COMPILE.INTERMEDIATEp = null();
	else if Seg.type = "source" then;		/* Relationship from analyze request: COMPILE -> sourceP  */
						/*  Never destroy that relation without also invalidating */
						/*  bld.progress.compiledS.			        */
	Seg.COMPILEp = null();
	end;

     if Seg.UNBOUNDOBJp ^= null()  &  Seg.type ^= "source"  then 
	Seg.UNBOUNDOBJp = null();

     return;
     
/* ======================================================================
 *
 * ENTRYPOINT:  mbuild_data_$reset_Seg
 * 
 * Purpose:     Remove a Seg structure from all of its threads except
 *              the Seg_Tb, and disconnect its between-structure
 *              pointers for: COMPILE, BOUNDOBJ, UNBOUNDOBJ
 *              This call should only be used by $reset_build_lists!
 *
 * Threads:     all those that include this Seg, except the Seg_Tb.
 *
 * ====================================================================== */

reset_Seg:
     entry (ASegP);

     SegP = ASegP;
     if Seg.UNBOUNDOBJp ^= null()  then 
	Seg.UNBOUNDOBJp = null();

     goto DISCONNECT;

%page;
/* ======================================================================
 *
 * ENTRYPOINT:  mbuild_data_$exists_component
 * 
 * Purpose:     Returns true if segment represented by Seg() structure
 *              is contained as a component of an archive in the build dir.
 *
 * ====================================================================== */

exists_component:
     entry (Abuild_dataP, ASegP) returns (bit(1) aligned);

  dcl  comp_name (1) char(32) var;
  dcl  comp_nameN fixed bin;

     call mbuild_library_$archive_table (bld.directory, ASeg.archive_name, ASeg.name, comp_name, comp_nameN, code);
     return ( code = 0  &  comp_nameN = 1 );


/* ======================================================================
 *
 * ENTRYPOINT:  mbuild_data_$exists_Seg
 * 
 * Purpose:     Returns true if segment represented by Seg() structure
 *              exists in the build directory.
 *
 * ====================================================================== */

exists_Seg:
     entry (Abuild_dataP, ASegP) returns (bit(1) aligned);

  dcl  primary_name char(32);

  dcl  NO_CHASE fixed bin(1) int static options(constant) init(0);
  dcl  SEGMENT fixed bin int static options(constant) init(1);
  dcl  bitCount fixed bin(24);
  dcl  entryType fixed bin(2);

     call hcs_$status_minf (bld.directory, (ASeg.name), NO_CHASE, entryType, bitCount, code);
     if  code = 0  &  entryType = SEGMENT  then do;
	primary_name = mbuild_library_$get_primary_name (addr(bld), bld.directory, (ASeg.name), code);
	return ( ASeg.name = primary_name );
	end;
     return ( F );
     
%page;
/* ======================================================================
 *
 * ENTRYPOINT:  mbuild_data_$replacing_identical_Seg
 * 
 * Purpose:     Returns true if segment represented by Seg() structure
 *              in a REPLACE or UPDATE operation has identical contents 
 *	      with its targeted library segment. 
 *
 * ====================================================================== */

replacing_identical_Seg:
     entry (Abuild_dataP, ASegP) returns (bit(1) aligned);
     
  dcl  identicalS bit(1) aligned init(F);
     
  dcl  lib_dirs (2) char(200) var,
       lib_dirsN fixed bin;

  dcl  new bit(newBC) aligned based(newP),
       newBC fixed bin(24),
       newP ptr;
     
  dcl  target bit(targetBC) aligned based(targetP),
       targetBC fixed bin(24),
       targetP ptr;

     newP, targetP = null();
     if  ^(ASeg.operation = "REPLACE" | ASeg.operation = "UPDATE")  then  goto IDENTICAL_RETURN;

     call mbuild_library_$library_directories (ASeg.library,  lib_dirs, lib_dirsN, code);
     if lib_dirsN ^= 1 then  goto IDENTICAL_RETURN;	/* - Get library directory for target segment	        */

     on cleanup call replace_identical_janitor (newP, targetP);
     
     call initiate_file_$component (bld.directory, (ASeg.name), "", R_ACCESS, newP, newBC, code);
     if  newP = null()  then  goto IDENTICAL_RETURN;

     if ASeg.archive_name  ^= "" then
	call initiate_file_$component ((lib_dirs(1)), (ASeg.archive_name), (ASeg.name), R_ACCESS, targetP, targetBC, code);
     else call initiate_file_$component ((lib_dirs(1)), (ASeg.name), "", R_ACCESS, targetP, targetBC, code);
     if  targetP = null()  then  goto IDENTICAL_RETURN;

     if  newBC ^= targetBC  then  goto IDENTICAL_RETURN;	/* Do bit-by-bit comparison; to check data segments       */

     identicalS =  (new = target);

IDENTICAL_RETURN:
     call replace_identical_janitor (newP, targetP);
     return ( identicalS );

replace_identical_janitor:
     proc (AnewP, AtargetP);
    
  dcl (AnewP, AtargetP) ptr;
     
     call terminate_file_ (newP, 0, TERM_FILE_TERM, code);
     call terminate_file_ (targetP, 0, TERM_FILE_TERM, code);

     end replace_identical_janitor;
%page;
/* ======================================================================
 *
 * ENTRYPOINT:  mbuild_data_$scan_Tb_insert
 * 
 * Purpose:     Insert Seg() structures into scan_Tb thread (list of
 *              original content segments found in install directory),
 *              ordered by Seg.type, Seg.archive_name, and Seg.name.
 *              mbuild_print_ uses this ordering to meaninfully present
 *              segment information to the user.
 *
 * Function:    Seg(<seg-type>) provides a good ordering IFF most-often-seen
 *              types are always presented with more important items first,
 *              followed by lesser (supporting?) items.
 *               - See the seq structure in the type_seq internal procedure.
 *
 * Threads:     build_data.scan_Tb - list of all segments found by
 *              either scan or read requests.
 *
 * ====================================================================== */

scan_Tb_insert:					/* Insert Seg items into scan_Tb list in order they will  */
     entry (Abuild_dataP, ASegP, Acode);		/*  be printed.				        */

  dcl (ASegP, BSegP) ptr;
  dcl  Acode fixed bin(35);
  dcl 1 (ASeg based(ASegP), 
         BSeg based(BSegP)) aligned like Seg;
  dcl (AS_seq, BS_seq) fixed bin;
  dcl  cmp_seq bit(1) aligned;
     
     Acode = 0;

     AS_seq = type_seq(ASegP);			/* Get <seg-type> sequence number for Seg being added.    */

     do BSegP = Tlist_first_item (addr(bld.scan_Tb))
         repeat Tlist_next_item  (addr(BSeg.scan_Td)) while (BSegP ^= null());
	if  ASegP = BSegP  then do;			/* Detect/reject attempt to insert Seg structure that is  */
	     Acode = error_table_$namedup;		/*  already in the scan_Tb list.		        */
	     return;
	     end;

	BS_seq = type_seq(BSegP);			/* Compare type-sequence number with that of Seg's now    */
						/*  in the scan_Tb list.			        */
	if  AS_seq < BS_seq  then goto FOUND_scan_Tb_point;
						/* New Seg has sequence lower than current list element?  */
						/*  - Insert new Seg before current list element.	        */
	if  AS_seq = BS_seq  then do;			/* New Seg has same sequence as current list element?     */
	     cmp_seq = name_seq_before (ASegP, BSegP);	/*  - Compare Seg.archive_name and Seg.name of both Segs  */
	     if  cmp_seq  then goto FOUND_scan_Tb_point;	/*    to determine ordering.			        */
	     end;
	end;
     call Tlist_add_to_tail (addr(bld.scan_Tb), addr(ASeg), addr(ASeg.scan_Td));
						/* List contains no structures sequenced > new item.      */
     return;					/*  - Add new item to tail of list.		        */

FOUND_scan_Tb_point:
     call Tlist_insert_before(addr(bld.scan_Tb), addr(ASeg), addr(ASeg.scan_Td), addr(BSeg.scan_Td));     
						/* Comparison determined new Seg should be inserted       */
						/*  ahead of current list item BSegP->Seg().	        */
     return;
%page;
/* ----------------------------------------------------------------------
   UTILITY PROCEDURES

   Support routines for scan_Tb_insert entrypoint.
   ---------------------------------------------------------------------- */

name_seq_before:					/* Determine sequence of two Seg() having same type by    */
     proc (ASegP, BSegP) returns (bit(1) aligned);	/*  comparing their Seg.archive_name and Seg.name values. */
     
  dcl (ASegP, BSegP) ptr;
  dcl 1 (ASeg based(ASegP), 
         BSeg based(BSegP)) aligned like Seg;
     
     if  ASeg.archive_name ^= ""  &  BSeg.archive_name  = ""  then return (T);
     if  ASeg.archive_name  = ""  &  BSeg.archive_name ^= ""  then return (F);

     if  ASeg.archive_name ^= ""  &  BSeg.archive_name ^= ""  &  ASeg.archive_name ^= BSeg.archive_name  then
	return ( ASeg.archive_name < BSeg.archive_name );

     return ( ASeg.name <= BSeg.name );

     end name_seq_before;


type_seq:						/* Determine sequence of ordering Seg by its <seg-type>   */
     proc (ASegP) returns (fixed bin);

  dcl  ASegP ptr;
  dcl 1 ASeg aligned like Seg based (ASegP);

  dcl 1 seq aligned int static,			/* List of important <seg-type> values, to which lesser   */
      2 N fixed bin init(10),				/*  <seg-type>s may be added as encountered in a given    */
      2 type (30) char(20) var init(			/*  install directory.			        */
        "Build_script", "Build_exec_com", "Build_log", "Build_io",
        "Bound_obj", "bindfile", "source_arch", "source",	/* For current <seg-type> values known in Multics         */
        "Unbound_obj", "Include", "Info",		/*  Libraries, type:  mbt seg -tp		        */
        (19)(1)"");

  dcl  seqI fixed bin;

     do seqI = 1 to seq.N while (seq.type(seqI) ^= ASeg.type);
	end;
     if seqI <= seq.N then				/* Found ASeg.type in seq.type list.		        */
	goto RETURN_type_seq;
     if seqI > hbound(seq.type,1) then do;		/* Is type list overflowing?			        */
	seqI = seq.N + 1;
	goto RETURN_type_seq;
	end;
     seq.N = seqI;					/* Add ASeg.type to type list.		        */
     seq.type(seqI) = ASeg.type;

RETURN_type_seq:
     if ASeg.operation = "DELETE" then
	return (seqI*2 - 1);
     else return (seqI*2);
     

type_seq$init_seq:					/* Remove lesser <seg-type> values from sequence list.    */
     entry();					/*  This leaves only the 8 important types given as       */
						/*  initial values in seq structure declared above.       */
     seq.N = 8;
     return;

type_of_interest:					/* Compare an input Seg's <seg-type> to see if it is one  */
     entry(Atype) returns (bit(1) aligned);		/*  of the important types declared above.	        */

  dcl  Atype char(*) var;
     
     do seqI = 1 to 8 while (seq.type(seqI) ^= Atype);
	end;
     return ( seqI <= 8 );

     end type_seq;
%page;
/* ======================================================================
 *
 * ENTRYPOINT:  mbuild_data_$derived_Seg
 *
 * Function:  use build paradigm information to determine if Seg contains
 *            derived content.

 * ====================================================================== */

derived_Seg:
     entry (ASegP) returns (bit(1) aligned);

     SegP = ASegP;
     segtP = Seg.seg_typeP;
     if segtP ^= null() then do;
	if (segt.build_paradigm = PDM_source_arch & Seg.operation ^= "ADD") |
	    segt.build_paradigm = PDM_object_arch |
	    segt.build_paradigm = PDM_Bound_obj   |
	    segt.build_paradigm = PDM_Unbound_obj |
              segt.build_paradigm = PDM_listing  then
	     return (T);
	else if  segt.build_paradigm = PDM_source  then do;
	     return (ASeg.produced_by_compiler ^= "");
	     end;
	else if  segt.build_paradigm = PDM_mbuild_support  then 
	     return (F);

	else return (F);
	end;
     return (F);

/* ======================================================================
 *
 * ENTRYPOINT:  mbuild_data_$disconnectable_Seg
 *
 * Function:  use build paradigm information to determine if Seg was
 *            created AFTER analyze request.  Structs from analyze should
 *	    not be disconnected.
 * ====================================================================== */

disconnectable_Seg:
     entry (ASegP) returns (bit(1) aligned);

     SegP = ASegP;
     segtP = Seg.seg_typeP;
     if segtP ^= null() then do;
	if  segt.build_paradigm = PDM_object_arch |
	    segt.build_paradigm = PDM_Bound_obj   |
	    segt.build_paradigm = PDM_Unbound_obj |
              segt.build_paradigm = PDM_listing  then
	     return (T);
	else if  segt.build_paradigm = PDM_source  then do;
	     return (ASeg.produced_by_compiler ^= "");	/* See if Seg(source) is an intermediate product of a     */
	     end;					/*  2-step COMPILE relationship.		        */
	else if  segt.build_paradigm = PDM_mbuild_support  then 
	     return (F);

	else return (F);
	end;
     return (F);

/* ======================================================================
 *
 * ENTRYPOINT:  mbuild_data_$mbuild_support_Seg
 *
 * Function:  use build paradigm information to determine if Seg follows
 *            the PDM_mbuild_support paradigm.

 * ====================================================================== */

mbuild_support_Seg:
     entry (ASegP) returns (bit(1) aligned);

     SegP = ASegP;
     segtP = Seg.seg_typeP;
     if segtP ^= null() then
	if  segt.build_paradigm = PDM_mbuild_support  then 
	     return (T);
     return (F);

/* ======================================================================
 *
 * ENTRYPOINT:  mbuild_data_$new_source_component
 *
 * Function:  use Seg(source) information to determine if segment is
 *            a component of a new Seg(source_arch) being ADDed.
 *
 * ====================================================================== */

new_source_component:
     entry (Abuild_dataP, ASegP) returns (bit(1) aligned);

     SegP = ASegP;
     if  Seg.type = "source"  &   Seg.archive_name ^= ""  then do;
						/* Test whether install directory has been analyzed.    */
	string(bld_progress) = get_build_progress (addr(bld));
	if bld_progress.analyzedS then
	     sArchP = Tlist_holder(addr(Seg.inArch_Td));
	else sArchP = mbuild_Tlist_$find_Seg (Abuild_dataP, Seg.archive_name, "", null() );

	if sArchP ^= null then
	     if sArch.operation = "ADD" then
		return (T);
	end;
     return (F);

%page;
/* ======================================================================
 *
 * ENTRYPOINT:  mbuild_data_$important_type
 * 
 * Purpose:     Requests like print and save want to present important
 *              Seg(<seg-type>) types with special type-specific labels;
 *              whereas, lesser types are presented with Seg(<seg-type)
 *              labels.
 *
 * Function:    return True if Seg(<seg-type>) has one of those 
 *              important types. 
 *               - See the seq structure in the type_seq internal procedure.
 *
 * ====================================================================== */

important_type:
     entry (Atype) returns (bit(1) aligned);

     return (type_of_interest(Atype));			/* implementation: just call internal procedure above.    */
%page;
/* ----------------------------------------------------------------------
 *  1) Split build_data.directory into containing dir and entryname.
 *  2) Use entryname as build_data.build_script_prefix.
 * ---------------------------------------------------------------------- */
get_build_script_prefix:				/* Get build script name: <install-dir-entryname>	        */
     proc () returns (char(32) var);
     
  dcl  expand_pathname_ entry (char(*), char(*), char(*), fixed bin(35));

  dcl  code fixed bin(35); 
  dcl  dir_path char(168);
  dcl  entryname char(32);

     call expand_pathname_ ((bld.directory), dir_path, entryname, code);
     if code ^= 0 then				/* Remove final entryname part of directory path	        */
						/*  This should never fail.  directory comes from	        */
						/*  get_wdir_();				        */
	call ssu_$abort_subsystem (AsciP, code, "get_script_path: Calling expand_pathname_ for ^a", bld.directory);
	
     if length(rtrim(entryname)) > maxlength(bld.build_script_prefix) then
	call ssu_$abort_subsystem (AsciP, error_table_$entlong,
	     "Build directory entryname (^a) limited to ^d characters.", 
	     entryname, maxlength(bld.build_script_prefix));

     return ( rtrim(entryname) );

     end get_build_script_prefix;

%page;
%include ssu_subroutine_dcls_;
%page;
%include mbuild_request_parms_;
%page;
%include mbuild_data_;
%page;
%include mbuild_info_;
%page;
%include mbuild_Tlist_;
%page;
%include access_mode_values;
%include terminate_file;

     end mbuild_data_;
