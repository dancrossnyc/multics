/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

compare_mst: proc;

/* format: off */

/* This command mounts two mst tapes (the names of which are given as arguments)
   and compares them, printing out all significant changes.

   Written 9/20/74 by C. D. Tavares.

   Rewritten by Kobziar 3/75 to handle additions, deletions, and moves. Also allows saving of segment contents
   if they are different, and header copmparisons corrected to ignore acl pad field.
   Can compare any number of collections, ie. service or bos tapes.

   Modified 11/05/80, W. Olin Sibert, to add -file control argument.
   Modified 06/08/84, Keith Loepere, to work when an object appears on a tape more than once.
   */


/****^  HISTORY COMMENTS:
  1) change(87-01-12,GDixon), approve(87-04-16,MCR7614),
     audit(87-05-21,Farley), install(87-07-15,MR12.1-1040):
     Add support for comparing MST data coming from either tape or disk files,
     via -master_file and -copy_file control args.  Add a severity variable
     to allow testing of success/fail of the compare operation.  Modernize code
     somewhat (it needs more work, at some point in future, however).
                                                   END HISTORY COMMENTS */


%page;
	dcl     REWP		 char (64) static aligned options(constant)
				 initial ("NULL   P  W   WP E   E P EW  EWPR   R  PR W R WPRE  RE PERW REWP");
	dcl     OFF_ON		 char (8) static aligned options(constant) initial ("OFF ON  ");
	dcl    (UNSET		 init(0),
	        MASTER		 init(1),
	        COPY		 init(2)) fixed bin int static options(constant);
	dcl     abs_changes		 fixed bin int static options(constant) init (45);
	dcl     mst_name		 (2) char (19) varying int static options(constant)
				 initial ("compare_mst.master.", "compare_mst.copy.");
	dcl     rew		 char (24) static aligned options(constant) initial ("n    w e  ewr  r wre rew");

	dcl     arg		 char(argl) based(argp),
	        opt		 char(optl) based(optp);

	dcl     bits		 (bit_len) bit (1) unaligned based (bits_ptr); /* for index comparisons */

	dcl     1 bootstrap_header	 aligned based,	/* special format for bound_bootload_0 header */
		2 header_control_word like mst1.header_control_word aligned,
		2 slte		 like slte aligned,
		2 minus_ones	 (18) fixed bin (35), /* bad filler */
		2 segment_control_word like mst1.segment_control_word aligned;

	dcl     1 collection_mark_data based,
		2 pad		 bit (36),	/* header word */
		2 major		 fixed bin (18) uns unal,
		2 minor		 fixed bin (18) uns unal;

	dcl     header_words	 (bit_len) based fixed bin; /* entire header */

	dcl     1 mst1		 aligned based (mst_ptr (1)), /* Format of an MST segment header */
		2 header		 aligned,
		  3 header_control_word aligned,
		    4 collection_mark bit (18) unaligned, /* if non-zero, this is a 2-word collection mark only */
		    4 header_length	 fixed bin (17) unaligned, /* length of REST of header, not counting first 2 wds */

		  3 slte		 like slte aligned, /* first word of slte is a dummy, rest used */

		  3 names_array	 aligned,		/* this is always there, except for bound_bootload_0 */
		    4 n_names	 fixed bin aligned, /* number of names */
		    4 name_element	 (n_names (1)) aligned,
		      5 n_chars	 fixed bin aligned, /* number of chars in each name */
		      5 name	 char (32) aligned, /* the name */

		  3 pathname_array	 (has_branch (1)) aligned, /* This may or may not be there, hence the zero subscripting */
		    4 pathname_length fixed bin aligned,/* pathname is exactly this long, plus spaces to fill */
		    4 pathname	 char (path_length (1)) aligned, /* out to end of a word */

		  3 acl_structure	 (has_acl (1)) aligned, /* This also may or may not be there */
		    4 n_acls	 fixed bin,	/* number of acl entries */
		    4 acl		 (n_acls (1)) aligned, /* Each acl */
		      5 accessname	 char (32) aligned,
		      5 mode	 bit (3) aligned,	/* r, e, w */
		      5 pad	 (2) fixed bin,

		  3 segment_control_word aligned,	/* This tells about the segment following */
		    4 ident	 fixed bin (17) unaligned, /* This is always a one */
		    4 segment_length fixed bin (17) unaligned; /* in words, of seg following */


	dcl     1 mst2		 based (mst_ptr (2)) aligned, /* same thing as mst1; look up there. */
		2 header		 aligned,
		  3 header_control_word aligned,
		    4 collection_mark bit (18) unaligned,
		    4 header_length	 fixed bin (17) unaligned,

		  3 slte		 like slte aligned,

		  3 names_array	 aligned,
		    4 n_names	 fixed bin aligned,
		    4 name_element	 (n_names (2)) aligned,
		      5 n_chars	 fixed bin aligned,
		      5 name	 char (32) aligned,

		  3 pathname_array	 (has_branch (2)) aligned,
		    4 pathname_length fixed bin aligned,
		    4 pathname	 char (path_length (2)) aligned,

		  3 acl_structure	 (has_acl (2)) aligned,
		    4 n_acls	 fixed bin,
		    4 acl		 (n_acls (2)) aligned,
		      5 accessname	 char (32) aligned,
		      5 mode	 bit (3) aligned,
		      5 pad	 (2) fixed bin,

		  3 segment_control_word aligned,
		    4 ident	 fixed bin (17) unaligned,
		    4 segment_length fixed bin (17) unaligned;

	dcl     segment_1		 (seg_length (1)) based fixed bin;
	dcl     segment_2		 (seg_length (2)) based fixed bin;

	dcl     sys_id_pickup	 char (8) aligned based;

	dcl     1 tp_name		 based aligned,
		2 order_info,			/* info that we maintain relative to an object's order on the tape. */
		  3 name		 char (32),	/* primary name of seg */
		  3 org_index	 fixed bin,	/* value of org sequence in list before sort */
		  3 major_collection fixed bin,	/* segment contained within */
		  3 minor_collection fixed bin,
		  3 sw		 unaligned,	/* status of this seg */
		    4 col		 bit (1),		/* indicates a collection mark */
		    4 add		 bit (1),
		    4 del		 bit (1),
		    4 mov		 bit (1),
		2 info_ptr	 ptr,		/* pts to seg  body if saving or moved */
		2 head_ptr	 ptr,		/* pts to header if seg  has been moved */
		2 move_index	 fixed bin,	/* points to second list's correspondin g seg */
		2 pos_n		 fixed bin;	/* points to place in list where orjg name now is stored */

	dcl     1 tp1_names		 (name_count (1)) based (np (1)) aligned like tp_name;
	dcl     1 tp2_names		 (name_count (2)) based (np (2)) aligned like tp_name;

	dcl     argl		 fixed bin(21);
	dcl     anp		 (2) ptr;
	dcl     argp		 pointer;
	dcl     arg_count		 fixed bin;
	dcl     argx		 fixed bin;
	dcl     atd		 char(256);
	dcl     bit_len		 fixed bin;
	dcl     bits_ptr		 pointer;
	dcl     boot_label		 (2) bit(1) aligned;
	dcl     boot_ptr		 (2) ptr;
	dcl     bootstrap_sw	 (2) bit (1) aligned;
	dcl     1 bpi		 (2) aligned like boot_program_info;
	dcl     code		 fixed bin (35);
	dcl     collection		 bit (1) aligned;
	dcl     copy_ptr		 ptr;
	dcl     has_acl		 dimension (2) fixed bin;
	dcl     has_branch		 dimension (2) fixed bin;
	dcl     have_sysid		 bit (1) aligned;
	dcl     i			 fixed bin;
	dcl     in_den		 (2) fixed bin;
	dcl     in_file_name	 (2) char(168);
	dcl     in_tape_name	 (2) char(32);
	dcl     iocb_ptr		 (2) ptr;
	dcl     j			 fixed bin;
	dcl     k			 fixed bin;
	dcl     l1_index		 fixed bin;
	dcl     l2_index		 fixed bin;
	dcl     master_copy		 fixed bin;
	dcl     mst_ptr		 (2) pointer;
	dcl     mst_ptr_hold	 (2) ptr;
	dcl     n_acls		 dimension (2) fixed bin;
	dcl     n_names		 dimension (2) fixed bin;
	dcl     name_count		 (2) fixed bin;
	dcl     name_len		 fixed bin(18) uns unal;
	dcl     nelemt		 fixed bin (21);
	dcl     np		 (2) ptr;
	dcl     optl		 fixed bin(21);
	dcl     optp		 ptr;
	dcl     path_length		 dimension (2) fixed bin;
	dcl     saving		 bit (1);
	dcl     sci_ptr		 ptr;
	dcl     seg_len		 fixed bin(18) uns unal;
	dcl     seg_length		 (2) fixed bin;
	dcl     segment_name	 char (32);
	dcl     set		 fixed bin;
	dcl     skip_1		 bit (1) aligned;
	dcl     sys_id		 (2) char (8) aligned;

	dcl     absolute_pathname_	 entry (char(*), char(*), fixed bin(35));
	dcl     com_err_		 entry options (variable);
	dcl     cu_$arg_list_ptr	 entry returns(ptr);
	dcl     get_shortest_path_	 entry (char(*)) returns(char(168));
	dcl     get_wdir_		 entry returns (char (168));
	dcl     initiate_file_$create	 entry (char(*), char(*), bit(*), ptr, bit(1) aligned, fixed bin(24),
				     fixed bin(35));
	dcl     ioa_		 entry options (variable);
	dcl     iox_$attach_name	 entry (char (*), ptr, char (*), ptr, fixed bin (35));
	dcl     iox_$close		 entry (ptr, fixed bin (35));
	dcl     iox_$control	 entry (ptr, char(*), ptr, fixed bin(35));
	dcl     iox_$detach_iocb	 entry (ptr, fixed bin (35));
	dcl     iox_$get_chars	 entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
	dcl     iox_$open		 entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
	dcl     parse_tape_reel_name_	 entry (char(*), char(*));
	dcl     ssu_$abort_subsystem	 entry() options(variable);
	dcl     ssu_$arg_count	 entry (ptr, fixed bin);
	dcl     ssu_$arg_ptr	 entry (ptr, fixed bin, ptr, fixed bin(21));
	dcl     ssu_$destroy_invocation
				 entry (ptr);
	dcl     ssu_$get_temp_segment	 entry (ptr, char(*), ptr);
	dcl     ssu_$standalone_invocation
				 entry (ptr, char(*), char(*), ptr, entry, fixed bin(35));
	dcl     terminate_file_	 entry (ptr, fixed bin(24), bit(*), fixed bin(35));
	dcl     unique_chars_	 entry (bit(*)) returns(char(15));


          dcl     compare_mst_severity_  fixed bin ext static init(0);

	dcl    (error_table_$bad_arg,
	        error_table_$badopt,
	        error_table_$end_of_info,
	        error_table_$inconsistent,
	        error_table_$noarg)
				 fixed bin (35) external static;

	dcl     (abs, addr, binary, char, convert, divide, index, length,
	         ltrim, max, null, ptr, reverse, rtrim, size, string, substr)
				 builtin;

	dcl     cleanup		 condition;
%page;
	compare_mst_severity_ = 4;
	bits_ptr = null ();
	boot_ptr = null ();
	iocb_ptr = null ();
	mst_ptr_hold = null ();
	np = null ();
	sci_ptr = null();
	on cleanup call clean_up;

	call ssu_$standalone_invocation (sci_ptr, "compare_mst", "1.0",
	   cu_$arg_list_ptr(), exit_proc, code);
	if code ^= 0 then call com_err_ ("compare_mst", code, "Creating standalone ssu_ subsystem.");

	bootstrap_sw = "0"b;			/* set for first pass */
	have_sysid = "0"b;
	saving = "0"b;

	call ssu_$arg_count (sci_ptr, arg_count);
	
	in_file_name, in_tape_name = "";
	in_den = UNSET;
	master_copy = UNSET;

	do argx = 1 to arg_count;
	   call ssu_$arg_ptr (sci_ptr, argx, argp, argl);
	   if index (arg, "-") = 1 then do;
	      if arg = "-save" then
	         saving = "1"b;
	      else if arg = "-master_volume" | arg = "-mvol" then do;
	         master_copy = MASTER;
SETTAPE:	         in_tape_name(master_copy), in_file_name(master_copy) = "";
	         if argx = arg_count then
		  call ssu_$abort_subsystem (sci_ptr, error_table_$noarg,
		     "^a must be followed by a tape volume name.", arg);
	         else do;
		  argx = argx + 1;
		  call ssu_$arg_ptr (sci_ptr, argx, optp, optl);
		  in_tape_name(master_copy) = opt;
		  end;
	         end;
	      else if arg = "-master_file" | arg = "-mf" then do;
	         master_copy = MASTER;
SETFILE:	         in_tape_name(master_copy), in_file_name(master_copy) = "";
	         if argx = arg_count then
		  call ssu_$abort_subsystem (sci_ptr, error_table_$noarg,
		     "^a must be followed by a file name.", arg);
	         else do;
		  argx = argx + 1;
		  call ssu_$arg_ptr (sci_ptr, argx, optp, optl);
		  in_file_name(master_copy) = opt;
		  end;
	         master_copy = UNSET;
	         end;
	      else if (arg = "-copy_volume" | arg = "-cvol") then do;
	         master_copy = COPY;
	         go to SETTAPE;
	         end;
	      else if (arg = "-copy_file" | arg = "-cf") then do;
	         master_copy = COPY;
	         go to SETFILE;
	         end;
	      else if arg = "-density" | arg = "-den" then do;
	         if argx = arg_count then
		  call ssu_$abort_subsystem (sci_ptr, error_table_$noarg,
		     "^a must be followed by a tape density.", arg);
	         else do;
		  argx = argx + 1;
		  call ssu_$arg_ptr (sci_ptr, argx, optp, optl);
		  if opt = "800" | opt = "1600" | opt = "6250" then do;
		     if master_copy = UNSET then
		        call ssu_$abort_subsystem (sci_ptr,
			 error_table_$inconsistent,
			 "^a ^a must follow either -mvol or -cvol.", arg,
			 opt);
		     else
		        in_den(master_copy) = convert(in_den(1), opt);
		     end;
		  else
		     call ssu_$abort_subsystem (sci_ptr,
		        error_table_$bad_arg,
		        "^a ^a^/Allowed densities are: 800, 1600, 6250.",
		        arg, opt);
		  end;
	         end;
	      else
	         call ssu_$abort_subsystem (sci_ptr, error_table_$badopt, arg);
	      end;
	   else if in_tape_name(MASTER) = "" & in_file_name(MASTER) = "" then
	      in_tape_name(MASTER) = arg;
	   else if in_tape_name(COPY) = "" & in_file_name(COPY) = "" then
	      in_tape_name(COPY) = arg;
	   else
	      call ssu_$abort_subsystem (sci_ptr, error_table_$bad_arg, arg);
	   end;

	do i = MASTER to COPY;
	   if in_tape_name(i) = "" & in_file_name(i) = "" then
	      call ssu_$abort_subsystem (sci_ptr, error_table_$noarg,
	         "^/A ^[master^;copy^] tape or file must be specified via -^[m^;c^]vol or -^[m^;c^]f.",
	         i, i, i);
	   end;

          do i = MASTER to COPY;
	   call ssu_$get_temp_segment (sci_ptr, "boot pgm", boot_ptr(i));
	   call ssu_$get_temp_segment (sci_ptr, "buffer", mst_ptr_hold(i));
	   call ssu_$get_temp_segment (sci_ptr, "tape names", np(i));
	   call get_in_medium (i);
	   end;
	mst_ptr = mst_ptr_hold;
	call ssu_$get_temp_segment (sci_ptr, "bit seg", bits_ptr);
	compare_mst_severity_ = 0;
%page;
	call ioa_ ("^/Begin comparison.");

	if boot_label(MASTER) ^= boot_label(COPY) then do;
	   call ioa_ (
	      "^/^[Master^;Copy^] MST has a bootload label program, while ^[Master^;Copy^] MST does not.",
	      boot_label(MASTER), boot_label(COPY));
	   compare_mst_severity_ = max(compare_mst_severity_, 3);
	   end;
	else if boot_label(MASTER) then do;
	   if bpi(MASTER).boot_program_name ^= bpi(COPY).boot_program_name then do;
	      call ioa_ ("Boot program names disagree.
  Master:  ^a
  Copy:    ^a", bpi(MASTER).boot_program_name, bpi(COPY).boot_program_name);
	      compare_mst_severity_ = max(compare_mst_severity_, 3);
	      end;
	   else if bpi(MASTER).boot_program_text_length ^=
		 bpi(COPY).boot_program_text_length then do;
	      call ioa_ ("Boot program lengths disagree.
  Master:  ^d
  Copy:    ^d",    bpi(MASTER).boot_program_text_length,
	         bpi(COPY).boot_program_text_length);
	      compare_mst_severity_ = max(compare_mst_severity_, 3);
	      end;
	   else do;
	      seg_length(MASTER) = bpi(MASTER).boot_program_text_length;
	      seg_length(COPY)   = bpi(COPY).boot_program_text_length;
	      mst_ptr = bpi.boot_program_ptr;
	      segment_name = "bootload label program";
	      call check_segments();
	      mst_ptr = mst_ptr_hold;
	      end;
	   end;
%page;

	call read_tape (MASTER);

/* rewind first tape */
	call rewind_in_medium (MASTER);

	call read_tape (COPY);

	if have_sysid then call ioa_ ("System ^a to ^a", sys_id (MASTER), sys_id (COPY));

/* rewind tape COPY */
	call rewind_in_medium (COPY);

	call sort_names (MASTER);
	call sort_names (COPY);
	call list_comp;				/* get add,del,and mov bits set up */

	bootstrap_sw = "0"b;			/* reset for second pass */
	l1_index, l2_index = 1;
	skip_1 = "0"b;
%page;

/* now do the dirty work */
	do while ((l1_index ^> name_count (MASTER)) & (l2_index ^> name_count (COPY)));
	   j = tp2_names (l2_index).pos_n;		/* use tape order to process names */
	   if skip_1 then do;
	      skip_1 = "0"b;
	      goto try_2;
	      end;
	   i = tp1_names (l1_index).pos_n;


	   call read_header (MASTER, collection);
	   if collection then
	      if ^tp1_names (i).sw.col then do;
out_of_sync:       compare_mst_severity_ = max(compare_mst_severity_, 3);
	         call ssu_$abort_subsystem (sci_ptr, 0,
		  "tape out of sync.");
	         end;
	      else do;
	         if tp1_names (i).sw.del then do;
		  call ioa_ ("^a mark deleted.", tp1_names (i).name);
		  compare_mst_severity_ = max(compare_mst_severity_, 3);
		  end;
	         l1_index = l1_index + 1;
	         goto loop_cont;
	         end;
	   else if segment_name ^= tp1_names (i).name then goto out_of_sync;


	   if tp1_names (i).sw.del then do;
	      call ioa_ ("^a deleted", segment_name);
	      compare_mst_severity_ = max(compare_mst_severity_, 3);
	      call skip_block (MASTER);
	      l1_index = l1_index + 1;
	      goto loop_cont;
	      end;

						/* if moved, has first been read in already ? */
	   if tp1_names (i).sw.mov then if tp1_names (i).move_index ^= 0 then do;
						/* top segment already in  */
	      set = tp1_names (i).move_index; /* pick up other list offset */
	      mst_ptr (COPY) = tp2_names (set).head_ptr;
	      call header_setup_2;
	      call check_headers;
	      call read_segment (MASTER);
	      mst_ptr (COPY) = tp2_names (set).info_ptr;
	      call check_segments;
	      mst_ptr (COPY) = mst_ptr_hold (COPY);
	      l1_index = l1_index + 1;
	      goto loop_cont;
	      end;
	   else do;				/* save the header and body */
	      call ioa_ ("^a moved down.", segment_name);
	      compare_mst_severity_ = max(compare_mst_severity_, 3);
	      call ssu_$get_temp_segment (sci_ptr,
	         "header", tp1_names(i).head_ptr);
	      bit_len = mst1.header_length + 2;
	      tp1_names (i).head_ptr -> header_words = mst_ptr (MASTER) -> header_words;
	      call ssu_$get_temp_segment (sci_ptr,
	         "info", tp1_names(i).info_ptr);
	      mst_ptr (MASTER) = tp1_names (i).info_ptr;
	      call read_segment (MASTER);
	      mst_ptr (MASTER) = mst_ptr_hold (MASTER);
	      l1_index = l1_index + 1;
	      goto loop_cont;
	      end;

try_2:
	   call read_header (COPY, collection);
	   if collection then
	      if ^tp2_names (j).sw.col then goto out_of_sync;
	      else do;
	         if tp2_names (j).sw.add then do;
		  call ioa_ ("^a mark added.", tp2_names (j).name);
		  compare_mst_severity_ = max(compare_mst_severity_, 3);
		  end;
	         l2_index = l2_index + 1;
	         skip_1 = "1"b;
	         goto loop_cont;
	         end;
	   else if segment_name ^= tp2_names (j).name then goto out_of_sync;


	   if tp2_names (j).sw.add then do;
	      call ioa_ ("^a added.", segment_name);
	      compare_mst_severity_ = max(compare_mst_severity_, 3);
	      if saving then do;
	         call initiate_file_$create (get_wdir_(),
		  "tp2." || segment_name, RW_ACCESS,
		  tp2_names (j).info_ptr, "0"b, 0, code);
	         if tp2_names (j).info_ptr = null then goto make_x;
	         mst_ptr (COPY) = tp2_names (j).info_ptr;
	         call read_segment (COPY);
	         mst_ptr (COPY) = mst_ptr_hold (COPY);
	         call terminate_file_ (tp2_names(j).info_ptr,
		  seg_length(COPY) * BITS_PER_WORD, TERM_FILE_TRUNC_BC_TERM, 
		  code);
	         end;
	      else call skip_block (COPY);
	      l2_index = l2_index + 1;
	      skip_1 = "1"b;
	      goto loop_cont;
	      end;


	   if tp2_names (j).sw.mov then
	   if tp2_names (j).move_index ^= 0 then do;
	      set = tp2_names (j).move_index;
	      mst_ptr (MASTER) = tp1_names (set).head_ptr;
	      call header_setup_1;
	      call check_headers;
	      call read_segment (COPY);
	      mst_ptr (MASTER) = tp1_names (set).info_ptr;
	      call check_segments;
	      mst_ptr (MASTER) = mst_ptr_hold (MASTER);
	      l2_index = l2_index + 1;
	      skip_1 = "1"b;
	      goto loop_cont;
	      end;
	   else do;
	      call ioa_ ("^a moved up.", segment_name);
	      compare_mst_severity_ = max(compare_mst_severity_, 3);
	      call ssu_$get_temp_segment (sci_ptr, "hdr." || segment_name,
	         tp2_names (j).head_ptr);
	      bit_len = mst2.header_length + 2;
	      tp2_names (j).head_ptr -> header_words = mst_ptr (COPY) -> header_words;
	      call ssu_$get_temp_segment (sci_ptr, "tp2." || segment_name,
	         tp2_names (j).info_ptr);
	      mst_ptr (COPY) = tp2_names (j).info_ptr;
	      call read_segment (COPY);
	      mst_ptr (COPY) = mst_ptr_hold (COPY);
	      l2_index = l2_index + 1;
	      skip_1 = "1"b;
	      goto loop_cont;
	      end;
						/* compare segments */
	   call check_headers;
	   call read_segment (MASTER);
	   call read_segment (COPY);
	   call check_segments;
	   l1_index = l1_index + 1;
	   l2_index = l2_index + 1;
loop_cont:
	   end;					/* do while */

	if l1_index > name_count (MASTER) then if l2_index ^> name_count (COPY)
	   then i = 2;
	else goto detach_and_return;			/* process end of longer tape */
	else i = 1;

	if i = 1 then j = l1_index;
	else j = l2_index;
	do while (j ^> name_count (i));
	   call read_header (i, collection);
	   if collection then goto incr_j;
	   k = np (i) -> tp1_names (j).pos_n;
	   if segment_name ^= np (i) -> tp1_names (k).name then goto out_of_sync;
	   if np (i) -> tp1_names (k).sw.add then do;
	      call ioa_ ("^a added.", segment_name);
	      compare_mst_severity_ = max(compare_mst_severity_, 3);
	      if saving then do;
	         call initiate_file_$create (get_wdir_ (),
		  "tp2." || segment_name, RW_ACCESS, mst_ptr (i), ""b, 0,
		  code);
	         if mst_ptr (i) = null then goto make_x;
	         call read_segment (i);
	         call terminate_file_ (mst_ptr (i),
		  seg_length(i) * BITS_PER_WORD, TERM_FILE_TRUNC_BC_TERM,
		  code);
	         mst_ptr (i) = mst_ptr_hold (i);
	         end;
	      else call skip_block (i);
	      end;
	   else do;				/* must be deleted */
	      call skip_block (i);
	      call ioa_ ("^a deleted.", segment_name);
	      compare_mst_severity_ = max(compare_mst_severity_, 3);
	      end;
incr_j:	   j = j + 1;
	   end;
	call ioa_ ("End of comparison.^/");

detach_and_return:
	call clean_up;
	return;					/* successful job finish */

exit_proc:
	procedure;
	go to detach_and_return;
	end exit_proc;

make_x:   compare_mst_severity_ = max(compare_mst_severity_, 4);
	call ssu_$abort_subsystem (sci_ptr, code,
	   "Making -save segment in working directory.");
	go to detach_and_return;
%page;
clean_up: proc;
	do i = MASTER to COPY;
	   if iocb_ptr (i) = null ()
	      then go to CLEAN;
	   call iox_$close (iocb_ptr (i), code);
	   call iox_$detach_iocb (iocb_ptr (i), code);
CLEAN:	   end;
	call ssu_$destroy_invocation (sci_ptr);
	end;
%page;
get_data:	proc (index, data_ptr, data_words);

    dcl	index			 fixed bin,
	data_ptr			 ptr,
	data_words		 fixed bin(18) uns unal;

	call iox_$get_chars (iocb_ptr(index),
	   data_ptr, data_words * CHARS_PER_WORD, (0), code);
	if code = error_table_$end_of_info then go to detach_and_return;
	else if code ^= 0 then do;
	   call ssu_$abort_subsystem (sci_ptr, code,
	      "Tape error on ^[master^;copy^] tape.", index);
	   end;
	end get_data;


get_in_file:
	proc (index);

    dcl	index			 fixed bin;

    dcl	1 control_word		 aligned,
	  2 type			 fixed bin (17) unaligned,
	  2 count			 fixed bin (18) uns unal;

	call absolute_pathname_ (in_file_name(index),
	   in_file_name(index), code);
	if code ^= 0 then
	   call ssu_$abort_subsystem (sci_ptr, code, "^[-if^;-of^] ^a.",
	      index, in_file_name);

	in_file_name(index) = get_shortest_path_ (in_file_name(index));

	call iox_$attach_name (mst_name(index) || unique_chars_(""b),
	   iocb_ptr(index), "vfile_ " || in_file_name(index) || " -old",
	   null, code);
	if code ^= 0 then
	   call ssu_$abort_subsystem (sci_ptr, code,
	      "Cannot attach input file ^a.", in_file_name(index));

REWIND_FILE:
	call iox_$open (iocb_ptr(index), Stream_input, ("0"b), code);
	if code ^= 0 then 
	   call ssu_$abort_subsystem (sci_ptr, code,
	      "Cannot open input file ^a.", in_file_name(index));

	call get_data (index, addr (control_word), size(control_word));
	if control_word.type = -1 then do;		/* bootload program control word */
						/* It is written as a name, followed by the pgm.	*/

	   bpi(index).version = BOOT_PROGRAM_INFO_VERSION_1;
						/* set version */
	   boot_label(index) = "1"b;			/* set flag to copy onto output tape */
	   name_len = divide (length (bpi(index).boot_program_name), CHARS_PER_WORD, 18, 0);
	   seg_len = control_word.count - name_len;	/* set copy length */
	   call get_data (index, addr (bpi(index).boot_program_name), name_len);
	   call get_data (index, boot_ptr(index), seg_len);
						/* copy boot program in to temp seg */
	   bpi(index).boot_program_ptr = boot_ptr(index); /* set new boot program ptr */
	   bpi(index).boot_program_text_length = seg_len;
	   end;
	else do;
	   boot_label(index) = "0"b;
	   call iox_$close (iocb_ptr(index), (0));
	   call iox_$open (iocb_ptr(index), Stream_input, ""b, (0));
	   end;
	return;

rewind_in_file:
	entry (index);

	call iox_$close (iocb_ptr(index), code);
	if code ^= 0 then do;
	   compare_mst_severity_ = max(compare_mst_severity_, 4);
	   call ssu_$abort_subsystem (sci_ptr, code,
	      "error in reopening. Aborting.");
	   end;
	go to REWIND_FILE;

     end get_in_file;


get_in_medium:
  	proc (index);

    dcl	index			 fixed bin;

	if in_file_name(index) ^= "" then
	   call get_in_file (index);
	else if in_tape_name(index) ^= "" then
	   call get_in_tape (index);
	return;

rewind_in_medium:
	entry (index);

	if in_file_name(index) ^= "" then
	   call rewind_in_file (index);
	else
	   call rewind_in_tape (index);

	end get_in_medium;

get_in_tape:
	proc (index);
	
    dcl	index			 fixed bin;

    dcl	copy			 (seg_len) fixed bin(35) based;

	call parse_tape_reel_name_ (in_tape_name(index), atd);
	if in_den(index) ^= UNSET
	   then atd = rtrim (atd) || " -density " || ltrim (char (in_den(index)));

	call iox_$attach_name (mst_name(index) || unique_chars_ (""b),
	   iocb_ptr(index), "tape_mult_ " || rtrim (atd), null, code);
	if code ^= 0 then
	   call ssu_$abort_subsystem (sci_ptr, code,
	      "Cannot attach input tape ^a.", in_tape_name(index));

REWIND_TAPE:
	call iox_$open (iocb_ptr(index), Stream_input, ("0"b), code);
	if code ^= 0 then 
	   call ssu_$abort_subsystem (sci_ptr, code,
	      "Cannot open input tape ^a.", in_tape_name(index));

	bpi(index).version = BOOT_PROGRAM_INFO_VERSION_1;	/* set version */
	call iox_$control (iocb_ptr(index), "get_boot_program",
	   addr (bpi(index)), code);
	if code ^= 0 then
	   call ssu_$abort_subsystem (sci_ptr, code,
	      "Getting bootload program info from input tape ^a.",
	      in_tape_name(index));

	if bpi(index).boot_program_ptr ^= null then do;	/* if this tape has a boot label... */
	   boot_label(index) = "1"b;			/* set flag to copy onto output tape */
	   seg_len = bpi(index).boot_program_text_length;
						/* set copy length */
	   boot_ptr(index) -> copy = bpi(index).boot_program_ptr -> copy;
						/* copy boot program in to temp seg */
	   bpi(index).boot_program_ptr = boot_ptr(index);
						/* set new boot program ptr */
	   end;
	else
	   boot_label(index) = "0"b;
	return;
	
rewind_in_tape:
	entry (index);
	
	call iox_$close (iocb_ptr (index), code);
	if code ^= 0 then do;
	   compare_mst_severity_ = max(compare_mst_severity_, 4);
	   call ssu_$abort_subsystem (sci_ptr, code,
	      "error in rewind, aborting");
	   end;
	go to REWIND_TAPE;

	end get_in_tape;
%page;
read_header: proc (index, found_mark);

	dcl     found_mark		 bit (1) aligned;
	dcl     index		 fixed bin;

/* Get two words.  The first word will tell you how many more words to read to complete
   the header (i.e., it is the header length minus 2.)  If the collection mark is on, however, it
   is complete in itself.  In that case, you
   must reach in and get a whole fresh header. */


	call iox_$get_chars (iocb_ptr (index), mst_ptr (index), 8, nelemt, code); /* read 2 words */
	if code = 0 then do;
	   if mst_ptr (index) -> mst1.collection_mark then do;
	      found_mark = "1"b;			/* don't read rest of header; there is none */
	      return;
	      end;
	   else call iox_$get_chars (iocb_ptr (index), ptr (mst_ptr (index), 2),
	      mst_ptr (index) -> mst1.header_length * 4, nelemt, code);
						/* read rest of header */
	   if code ^= 0 then call check_status;
	   found_mark = "0"b;

	   if index = 1 then call header_setup_1;
	   else call header_setup_2;
	   end;
	else if code ^= error_table_$end_of_info then call check_status;

	end;
%page;
header_setup_1: proc;

	n_names (MASTER) = mst_ptr (MASTER) -> mst1.n_names;
						/* pull out number of names */
	if n_names (MASTER) = -1 then do;		/* special bootstrap processing */
	   if bootstrap_sw (MASTER) then do;
	      call ioa_ ("second bound_bootload_0 found on master tape. Aborting.");
	      compare_mst_severity_ = max(compare_mst_severity_, 3);
	      goto detach_and_return;
	      end;
	   bootstrap_sw (MASTER) = "1"b;
	   n_names (MASTER) = 0;
	   has_acl (MASTER) = 0;
	   n_acls (MASTER) = 0;
	   has_branch (MASTER) = 0;
	   path_length (MASTER) = 0;
	   segment_name = "bound_bootload_0";
	   seg_length (MASTER) = mst_ptr (MASTER) -> bootstrap_header.segment_length;
	   end;
	else do;
	   has_acl (MASTER) = binary (mst_ptr (MASTER) -> mst1.slte.acl_provided); /* is there an acl? */
	   has_branch (MASTER) = binary (mst_ptr (MASTER) -> mst1.slte.branch_required); /* is there a pathname? */
	   if has_branch (MASTER) = 1 then path_length (MASTER) = mst_ptr (MASTER) -> mst1.pathname_length (1); /* get length */
	   else path_length (MASTER) = 0;
	   if has_acl (MASTER) = 1 then n_acls (MASTER) = mst_ptr (MASTER) -> mst1.n_acls (1);
	   else n_acls (MASTER) = 0;
	   segment_name = mst_ptr (MASTER) -> mst1.name (MASTER);
	   seg_length (MASTER) = mst_ptr (MASTER) -> mst1.segment_length;
	   end;
	end;

header_setup_2: proc;				/* must use references based on mst2 varibs */

	n_names (COPY) = mst_ptr (COPY) -> mst2.n_names;
	if n_names (COPY) = -1 then do;
	   if bootstrap_sw (COPY) then do;
	      call ioa_ ("second bound_bootload_0 found on copy tape. Aborting.");
	      compare_mst_severity_ = max(compare_mst_severity_, 3);
	      goto detach_and_return;
	      end;
	   bootstrap_sw(COPY) = "1"b;
	   n_names (COPY) = 0;
	   has_acl (COPY) = 0;
	   n_acls (COPY) = 0;
	   has_branch (COPY) = 0;
	   path_length (COPY) = 0;
	   segment_name = "bound_bootload_0";
	   seg_length (COPY) = mst_ptr (COPY) -> bootstrap_header.segment_length;
	   end;
	else do;
	   has_acl (COPY) = binary (mst_ptr (COPY) -> mst2.slte.acl_provided);
	   has_branch (COPY) = binary (mst_ptr (COPY) -> mst2.slte.branch_required);
	   if has_branch (COPY) = 1 then path_length (COPY) = mst_ptr (COPY) -> mst2.pathname_length (1);
	   else path_length (COPY) = 0;
	   if has_acl (COPY) = 1 then n_acls (COPY) = mst_ptr (COPY) -> mst2.n_acls (1);
	   else n_acls (COPY) = 0;
	   segment_name = mst_ptr (COPY) -> mst2.name (1);
	   seg_length (COPY) = mst_ptr (COPY) -> mst2.segment_length;
	   end;
	end;
%page;
check_headers: proc;


	if mst1.header_length ^= mst2.header_length then goto header_discrepancy;

	bit_len = mst1.header_length + 2;		/* comparison of headers here */
	bits = mst_ptr (MASTER) -> header_words = mst_ptr (COPY) -> header_words;
	if (^string (bits)) ^= ""b then
	if ((n_acls (MASTER) = 0) | (n_acls (COPY) = 0)) then goto header_discrepancy;
	else do;					/* zero pad in acl structure */
	   do k = 1 to n_acls (MASTER);
	      mst1.acl (1, k).pad (1), mst1.acl (1, k).pad (2) = 0;
	      end;
	   do k = 1 to n_acls (COPY);
	      mst2.acl (1, k).pad (1), mst2.acl (1, k).pad (2) = 0;
	      end;
	   bits = mst_ptr (MASTER) -> header_words = mst_ptr (COPY) -> header_words;
	   if (^string (bits)) ^= ""b then goto header_discrepancy;
	   end;
	return;

header_discrepancy:
	call ioa_ ("^/Segment ^a:", segment_name);
	compare_mst_severity_ = max(compare_mst_severity_, 3);

/* Now find out exactly why. */
	if mst_ptr (MASTER) -> mst1.access ^= mst_ptr (COPY) -> mst2.access then
	   call ioa_ ("^-SDW access has changed from ^a to ^a",
	      substr (REWP, binary (mst_ptr (MASTER) -> mst1.access) * 4 + 1, 4),
	      substr (REWP, binary (mst_ptr (COPY) -> mst2.access) * 4 + 1, 4));
	if mst_ptr (MASTER) -> mst1.cache ^= mst_ptr (COPY) -> mst2.cache then
	   call ioa_ ("^-Cache bit has changed from ^a to ^a",
	      substr (OFF_ON, binary (mst_ptr (MASTER) -> mst1.cache) * 4 + 1, 3),
	      substr (OFF_ON, binary (mst_ptr (COPY) -> mst2.cache) * 4 + 1, 3));
	if mst_ptr (MASTER) -> mst1.wired ^= mst_ptr (COPY) -> mst2.wired then
	   call ioa_ ("^-Wired bit has changed from ^a to ^a.",
	      substr (OFF_ON, binary (mst_ptr (MASTER) -> mst1.wired) * 4 + 1, 3),
	      substr (OFF_ON, binary (mst_ptr (COPY) -> mst2.wired) * 4 + 1, 3));
	if mst_ptr (MASTER) -> mst1.paged ^= mst_ptr (COPY) -> mst2.paged then
	   call ioa_ ("^-Paged bit has changed from ^a to ^a.",
	      substr (OFF_ON, binary (mst_ptr (MASTER) -> mst1.paged) * 4 + 1, 3),
	      substr (OFF_ON, binary (mst_ptr (COPY) -> mst2.paged) * 4 + 1, 3));
	if mst_ptr (MASTER) -> mst1.per_process ^= mst_ptr (COPY) -> mst2.per_process then
	   call ioa_ ("^-Per-process bit has changed from ^a to ^a.",
	      substr (OFF_ON, binary (mst_ptr (MASTER) -> mst1.per_process) * 4 + 1, 3),
	      substr (OFF_ON, binary (mst_ptr (COPY) -> mst2.per_process) * 4 + 1, 3));
%page;
	if mst_ptr (MASTER) -> mst1.acl_provided ^= mst_ptr (COPY) -> mst2.acl_provided then
	   call ioa_ ("^-ACL-provided switch has changed from ^a to ^a.",
	      substr (OFF_ON, binary (mst_ptr (MASTER) -> mst1.acl_provided) * 4 + 1, 3),
	      substr (OFF_ON, binary (mst_ptr (COPY) -> mst2.acl_provided) * 4 + 1, 3));
	else if has_acl (MASTER) = 1 then
	     if n_acls (MASTER) ^= n_acls (COPY) then goto print_acls;
	else do;
	   bit_len = 11 * n_acls (MASTER) + 1;
	   anp (MASTER) = addr (mst1.acl_structure (1));
	   anp (COPY) = addr (mst2.acl_structure (1));
	   bits = anp (MASTER) -> header_words = anp (COPY) -> header_words;
	   if (^string (bits)) ^= ""b then do;
print_acls:     call ioa_ ("^-Number of ACLs was ^d, now is ^d.",
	         n_acls (MASTER), n_acls (COPY));
	      if abs (n_acls (MASTER) - n_acls (COPY)) > abs_changes then do;
too_much:	         compare_mst_severity_ = max(compare_mst_severity_, 4);
	         call ssu_$abort_subsystem (sci_ptr, 0,
		  "Probable bad tape, aborting.");
	         goto detach_and_return;
	         end;
	      call ioa_ ("^5xACL was:");
	      do k = 1 to n_acls (MASTER);
	         call ioa_ ("^-^3a  ^a",
		  substr (rew, binary (mst_ptr (MASTER) -> mst1.acl (1, k).mode) * 3 + 1, 3),
		  mst_ptr (MASTER) -> mst1.acl (1, k).accessname);
	         end;
	      call ioa_ ("^5xACL is:");
	      do k = 1 to n_acls (COPY);
	         call ioa_ ("^-^3a  ^a",
		  substr (rew, binary (mst_ptr (COPY) -> mst2.acl (1, k).mode) * 3 + 1, 3),
		  mst_ptr (COPY) -> mst2.acl (1, k).accessname);
	         end;
	      end;
	   end;
	if mst_ptr (MASTER) -> mst1.branch_required ^= mst_ptr (COPY) -> mst2.branch_required then
	   call ioa_ ("^-Hierarchy-branch required indicator has changed from ^a to ^a.",
	      substr (OFF_ON, binary (mst_ptr (MASTER) -> mst1.branch_required) * 4 + 1, 3),
	      substr (OFF_ON, binary (mst_ptr (COPY) -> mst2.branch_required) * 4 + 1, 3));
	else if has_branch (MASTER) = 1 then
	     if mst_ptr (MASTER) -> mst1.pathname (1) ^= mst_ptr (COPY) -> mst2.pathname (1) then
	   call ioa_ ("^-Pathname has changed from ^a to ^a.",
	      mst_ptr (MASTER) -> mst1.pathname (1), mst_ptr (COPY) -> mst2.pathname (1));
	if mst_ptr (MASTER) -> mst1.init_seg ^= mst_ptr (COPY) -> mst2.init_seg then
	   call ioa_ ("^-Initialization-seg indicator has changed from ^a to ^a.",
	      substr (OFF_ON, binary (mst_ptr (MASTER) -> mst1.init_seg) * 4 + 1, 3),
	      substr (OFF_ON, binary (mst_ptr (COPY) -> mst2.init_seg) * 4 + 1, 3));
	if mst_ptr (MASTER) -> mst1.temp_seg ^= mst_ptr (COPY) -> mst2.temp_seg then
	   call ioa_ ("^-Temp-seg indicator has changed from ^a to ^a.",
	      substr (OFF_ON, binary (mst_ptr (MASTER) -> mst1.temp_seg) * 4 + 1, 3),
	      substr (OFF_ON, binary (mst_ptr (COPY) -> mst2.temp_seg) * 4 + 1, 3));
%page;
	if mst_ptr (MASTER) -> mst1.link_provided ^= mst_ptr (COPY) -> mst2.link_provided then
	   call ioa_ ("^-Linkage-provided indicator has changed from ^a to ^a.",
	      substr (OFF_ON, binary (mst_ptr (MASTER) -> mst1.link_provided) * 4 + 1, 3),
	      substr (OFF_ON, binary (mst_ptr (COPY) -> mst2.link_provided) * 4 + 1, 3));
	if mst_ptr (MASTER) -> mst1.link_sect ^= mst_ptr (COPY) -> mst2.link_sect then
	   call ioa_ ("^-Linkage-segment indicator has changed from ^a to ^a.",
	      substr (OFF_ON, binary (mst_ptr (MASTER) -> mst1.link_sect) * 4 + 1, 3),
	      substr (OFF_ON, binary (mst_ptr (COPY) -> mst2.link_sect) * 4 + 1, 3));
	if mst_ptr (MASTER) -> mst1.link_sect_wired ^= mst_ptr (COPY) -> mst2.link_sect_wired then
	   call ioa_ ("^-Linkage-wired indicator has changed from ^a to ^a.",
	      substr (OFF_ON, binary (mst_ptr (MASTER) -> mst1.link_sect_wired) * 4 + 1, 3),
	      substr (OFF_ON, binary (mst_ptr (COPY) -> mst2.link_sect_wired) * 4 + 1, 3));
	if mst_ptr (MASTER) -> mst1.combine_link ^= mst_ptr (COPY) -> mst2.combine_link then
	   call ioa_ ("^-Combine-linkage switch has changed from ^a to ^a.",
	      substr (OFF_ON, binary (mst_ptr (MASTER) -> mst1.combine_link) * 4 + 1, 3),
	      substr (OFF_ON, binary (mst_ptr (COPY) -> mst2.combine_link) * 4 + 1, 3));
	if mst_ptr (MASTER) -> mst1.pre_linked ^= mst_ptr (COPY) -> mst2.pre_linked then
	   call ioa_ ("^-Pre-linked indicator has changed from ^a to ^a.",
	      substr (OFF_ON, binary (mst_ptr (MASTER) -> mst1.pre_linked) * 4 + 1, 3),
   	      substr (OFF_ON, binary (mst_ptr (COPY) -> mst2.pre_linked) * 4 + 1, 3));
	if mst_ptr (MASTER) -> mst1.cur_length ^= mst_ptr (COPY) -> mst2.cur_length then
	   call ioa_ ("^-Cur-length has changed from ^o to ^o.",
	      binary (mst_ptr (MASTER) -> mst1.cur_length, 35),
	      binary (mst_ptr (COPY) -> mst2.cur_length, 35));
	if mst_ptr (MASTER) -> mst1.ringbrack (1) ^= mst_ptr (COPY) -> mst2.ringbrack (1) |
	   mst_ptr (MASTER) -> mst1.ringbrack (2) ^= mst_ptr (COPY) -> mst2.ringbrack (2) |
	   mst_ptr (MASTER) -> mst1.ringbrack (3) ^= mst_ptr (COPY) -> mst2.ringbrack (3) then
	   call ioa_ ("^-Ring brackets have changed from ^d,^d,^d to ^d,^d,^d.",
	      binary (mst_ptr (MASTER) -> mst1.ringbrack (1), 35),
	      binary (mst_ptr (MASTER) -> mst1.ringbrack (2), 35),
	      binary (mst_ptr (MASTER) -> mst1.ringbrack (3), 35),
	      binary (mst_ptr (COPY) -> mst2.ringbrack (1), 35),
	      binary (mst_ptr (COPY) -> mst2.ringbrack (2), 35),
	      binary (mst_ptr (COPY) -> mst2.ringbrack (3), 35));
	if mst_ptr (MASTER) -> mst1.segno ^= mst_ptr (COPY) -> mst2.segno then
	   call ioa_ ("^-Segment number has changed from ^o to ^o.",
	      binary (mst_ptr (MASTER) -> mst1.segno, 35),
	      binary (mst_ptr (COPY) -> mst2.segno, 35));
	if mst_ptr (MASTER) -> mst1.max_length ^= mst_ptr (COPY) -> mst2.max_length then
	   call ioa_ ("^-Max length has changed from ^o to ^o.",
	      binary (mst_ptr (MASTER) -> mst1.max_length, 35),
	      binary (mst_ptr (COPY) -> mst2.max_length, 35));
	if mst_ptr (MASTER) -> mst1.bit_count ^= mst_ptr (COPY) -> mst2.bit_count then
	   call ioa_ ("^-Bit count has changed from ^d to ^d.",
	      binary (mst_ptr (MASTER) -> mst1.bit_count, 35),
	      binary (mst_ptr (COPY) -> mst2.bit_count, 35));
%page;
	if n_names (MASTER) = 0 then return;		/* bound_bootload_0 */
	if n_names (MASTER) ^= n_names (COPY) then goto print_names;
	else do;
	   bit_len = 9 * n_names (MASTER) + 1;
	   anp (MASTER) = addr (mst1.names_array);
	   anp (COPY) = addr (mst2.names_array);
	   bits = anp (MASTER) -> header_words = anp (COPY) -> header_words;
	   if (^string (bits)) ^= ""b then do;
print_names:    call ioa_ ("^-Number of names was ^d, now is ^d.",
	         n_names (MASTER), n_names (COPY));
	      if abs (n_names (MASTER) - n_names (COPY)) > abs_changes then goto too_much;
	      call ioa_ ("^5xNames were:");
	      do k = 1 to n_names (MASTER);
	         call ioa_ ("^-^a", mst_ptr (MASTER) -> mst1.name (k));
	         end;
	      call ioa_ ("^5xNames are:");
	      do k = 1 to n_names (COPY);
	         call ioa_ ("^-^a", mst_ptr (COPY) -> mst2.name (k));
	         end;
	      end;
	   end;
	if mst_ptr (MASTER) -> mst1.segment_length ^= mst_ptr (COPY) -> mst2.segment_length then
	   call ioa_ ("^-Segment length has changed from ^o to ^o.",
	      mst_ptr (MASTER) -> mst1.segment_length, mst_ptr (COPY) -> mst2.segment_length);

	end;
%page;
skip_block: proc (index);
	dcl     index		 fixed bin;
						/* positioning not supported, so just read */
	call iox_$get_chars (iocb_ptr (index), mst_ptr (index), seg_length (index) * 4, nelemt, code);
	if code ^= 0 then call check_status;
	end;

read_segment: proc (index);
	dcl     index		 fixed bin;

	call iox_$get_chars (iocb_ptr (index), mst_ptr (index), seg_length (index) * 4, nelemt, code);
	if code ^= 0 then call check_status;

	end;

check_status: proc;
	compare_mst_severity_ = max(compare_mst_severity_, 4);
          call ssu_$abort_subsystem (sci_ptr, code, 
	   "Error in manipulating tapes.");
	end;

read_tape: proc (index);

	dcl     index		 fixed bin parameter;

	dcl     i			 fixed bin;
	dcl     last_collection_mark	 fixed bin;
	dcl     name_index		 fixed bin;
	dcl     1 tp_names		 (name_count (index)) based (np (index)) aligned like tp_name;

	last_collection_mark = 0;
	name_index, name_count (index) = 0;
	do while (code ^= error_table_$end_of_info);	/* get the whole tape */
	   call read_header (index, collection);
	   if code = 0 then do;
	      name_index, name_count (index) = name_count (index) + 1;
	      tp_names (name_index).org_index = name_index;
	      tp_names (name_index).pos_n = name_index;	/* init */
	      tp_names (name_index).head_ptr = null;
	      tp_names (name_index).info_ptr = null;
	      if index = 1 then tp_names (name_index).sw.del = "1"b;
						/* assume not on other tape */
	      else tp_names (name_index).sw.add = "1"b; /* assume everything new */
	      if collection then do;
	         do i = last_collection_mark + 1 to name_index;
						/* record collection contained within */
		  tp_names (i).major_collection = mst_ptr (index) -> collection_mark_data.major;
		  tp_names (i).minor_collection = mst_ptr (index) -> collection_mark_data.minor;
		  end;
	         last_collection_mark = name_index;
	         
	         tp_names (name_index).name = "collection." ||
		  ltrim (char (mst_ptr (index) -> collection_mark_data.major)) ||
		  "." || ltrim (char (mst_ptr (index) -> collection_mark_data.minor));
	         tp_names (name_index).sw.col = "1"b;
	         end;
	      else do;
	         tp_names (name_index).name = segment_name;
	         call skip_block (index);
	         if segment_name = "active_all_rings_data" then do;
		  have_sysid = "1"b;
		  sys_id (index) = mst_ptr (index) -> sys_id_pickup;
		  end;
	         end;
	      end;
	   end;

	if substr (tp_names (name_index).name, 1, 10) ^= "collection" then do;
	   call ioa_ ("tape ^d does not end in a collection mark.", index);
	   compare_mst_severity_ = max(compare_mst_severity_, 3);
	   end;
	return;
	end;
%page;
check_segments: proc;

	if seg_length (MASTER) ^= seg_length (COPY) then goto check_saving;
	bit_len = seg_length (MASTER);			/* ready for bit comparison */

	bits = mst_ptr (MASTER) -> segment_1 = mst_ptr (COPY) -> segment_1; /* set up equal bits */

	if (^string (bits)) ^= ""b then goto segment_contents_discrepancy; /* something has been changed. */

	return;


segment_contents_discrepancy:
	k = index (string (bits), "0"b) - 1;		/* j tells which word first noticed as changed */
	call ioa_ ("^/Segment ^a contains differences from word ^o.", segment_name, k);
	compare_mst_severity_ = max(compare_mst_severity_, 3);
	k = bit_len - index (reverse (string (bits)), "0"b);
	call ioa_ ("^-last difference found at word ^o.", k);
check_saving:
	if saving then do;
	   call initiate_file_$create (get_wdir_ (),
	      "tp1." || segment_name, RW_ACCESS, copy_ptr, ""b, 0, code);
	   if copy_ptr = null then return;
	   copy_ptr -> segment_1 = mst_ptr (MASTER) -> segment_1;
	   call terminate_file_ (copy_ptr, size(segment_1) * BITS_PER_WORD,
	      TERM_FILE_TRUNC_BC_TERM, code);

	   call initiate_file_$create (get_wdir_ (),
	      "tp2." || segment_name, RW_ACCESS, copy_ptr, ""b, 0, code);
	   if copy_ptr = null then return;
	   copy_ptr -> segment_2 = mst_ptr (COPY) -> segment_2;
	   call terminate_file_ (copy_ptr, size(segment_2) * BITS_PER_WORD,
	      TERM_FILE_TRUNC_BC_TERM, code);
	   end;
	return;
	end;
%page;
sort_names: proc (index);
						/* shell sort, keeping track of original position */
	dcl     index		 fixed bin;

	dcl     1 hold_info		 aligned like tp_name.order_info;
	dcl     sd		 fixed bin;
	dcl     si		 fixed bin;
	dcl     sj		 fixed bin;
	dcl     sk		 fixed bin;
	dcl     1 tp_names		 (name_count (index)) aligned based (np (index)) like tp_name;

	sd = name_count (index);

down:	sd = 1 + 2 * divide (sd, 4, 17, 0);
	do si = 1 to name_count (index) - sd;
	   sj = si + sd;
up:	   sk = sj - sd;
	   if tp_names (sk).name <= tp_names (sj).name then goto ok;
	   
	   hold_info = tp_names (sk).order_info;

	   tp_names (sk).order_info = tp_names (sj).order_info;
	   tp_names (tp_names (sk).org_index).pos_n = sk;

	   tp_names (sj).order_info = hold_info;
	   tp_names (tp_names (sj).org_index).pos_n = sj;
	   
	   if sk > sd then do;
	      sj = sk;
	      goto up;
	      end;
ok:	   end;
	if sd > 1 then goto down;

	end;
%page;
name_search: proc (tp_name_ptr, index, ret_ans);

/* See if name exists on list(index).  Do binary search, preferring the object
in the same collection as before. */

	dcl     index		 fixed bin;
	dcl     ret_ans		 fixed bin;
	dcl     tp_name_ptr		 ptr;

	dcl     low_index		 fixed bin;
	dcl     high_index		 fixed bin;
	dcl     1 tp_names		 (name_count (index)) aligned based (np (index)) like tp_name;

	ret_ans = 0;
	low_index = 1;
	high_index = name_count (index);
	do while (high_index > low_index);
	   k = divide (low_index + high_index, 2, 17);
	   if tp_names (k).name = tp_name_ptr -> tp_name.name then go to match;
	   else if tp_names (k).name < tp_name_ptr -> tp_name.name then low_index = k + 1; /* name in high half of subdivision */
	   else high_index = k - 1;			/* low half */
	   end;
	if high_index < 1 then return;
	if low_index > name_count (index) then return;
	if tp_names (high_index).name = tp_name_ptr -> tp_name.name then do;
	   k = high_index;
match:

/* Name the same; look for the one in the same collection. */

	   do ret_ans = k to name_count (index) while (tp_name_ptr -> tp_name.name = tp_names (ret_ans).name), 
		      k - 1 to 1 by -1 while (tp_name_ptr -> tp_name.name = tp_names (ret_ans).name);
	      if tp_name_ptr -> tp_name.major_collection = tp_names (ret_ans).major_collection &
	         tp_name_ptr -> tp_name.minor_collection = tp_names (ret_ans).minor_collection then return;
	      end;
	   ret_ans = ret_ans + 1;			/* pick first one found */
	   end;
	return;
	end;
%page;
list_comp: proc;					/* find out what's added, deleted, or moved */
						/* process in original order to get add/del counts rigHt */
	dcl     add_count		 fixed bin;
	dcl     del_count		 fixed bin;
	dcl     offset_1		 fixed bin;
	dcl     offset_2		 fixed bin;

	do i = 1 to name_count (MASTER);
	   call name_search (addr (tp1_names (tp1_names (i).pos_n)), 2, offset_1);
	   if offset_1 = 0 then go to d_lp_c;		/* remains marked as deleted */
	   else do;
	      tp1_names (tp1_names (i).pos_n).sw.del = "0"b;
	      tp2_names (offset_1).sw.add = "0"b;
	      end;
d_lp_c:	   end;
						/* check for movement by matching list position */
	i, j = 1;
	add_count, del_count = 0;
						/* need process only shortest list */
	do while ((i <= name_count (MASTER)) & (j <= name_count (COPY)));
	   if tp1_names (tp1_names (i).pos_n).sw.del |
	      tp1_names (tp1_names (i).pos_n).move_index ^= 0 then do;
	      i = i + 1;
	      go to l_cont;
	      end;
	   if tp2_names (tp2_names (j).pos_n).sw.add |
	      tp2_names (tp2_names (j).pos_n).move_index ^= 0 then do;
	      j = j + 1;
	      go to l_cont;
	      end;
						/* if names equal then ok */
	   if tp1_names (tp1_names (i).pos_n).name = tp2_names (tp2_names (j).pos_n).name then do;
	      i = i + 1;
	      j = j + 1;
	      goto l_cont;
	      end;
						/* see which side moved */
	   call name_search (addr (tp1_names (tp1_names (i).pos_n)), COPY, offset_2);
	   call name_search (addr (tp2_names (tp2_names (j).pos_n)), MASTER, offset_1);
						/* find out which is farther, ignore adds,deletes */
	   del_count = tp1_names (offset_1).org_index - tp1_names (tp1_names (i).pos_n).org_index;
	   add_count = tp2_names (offset_2).org_index - tp2_names (tp2_names (j).pos_n).org_index;
						/* mark one as moved */
	   if del_count > add_count then do;		/* first tape's match is lower */
	      tp2_names (tp2_names (j).pos_n).sw.mov = "1"b;
	      tp1_names (offset_1).sw.mov = "1"b;
	      tp1_names (offset_1).move_index = tp2_names (j).pos_n;
	      j = j + 1;
	      goto l_cont;
	      end;
	   else do;
	      tp1_names (tp1_names (i).pos_n).sw.mov = "1"b;
	      tp2_names (offset_2).sw.mov = "1"b;
	      tp2_names (offset_2).move_index = tp1_names (i).pos_n;
	      i = i + 1;
	      goto l_cont;
	      end;
l_cont:	   end;					/* do while */
	end;					/* proc */
%page; %include access_mode_values;
%page; %include iox_modes;
%page; %include slte;
%page; %include system_constants;
%page; %include tape_mult_boot_info;
%page; %include terminate_file;
     end;
