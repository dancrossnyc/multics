/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1990   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(88-06-20,Berno), approve(88-07-13,MCR7928),
     audit(88-06-20,Parisek), install(88-07-19,MR12.2-1061):
     Modified code for implementing the UNCP multiplexer (DSA gateway)
     interface implementation.
  2) change(88-09-28,Brunelle), approve(88-01-26,MCR7813),
     audit(88-10-12,Blair), install(88-10-17,MR12.2-1171):
     Upgrade to TTT_version 4 with c_chars structure changing from 3 to 15
     chars.
  3) change(90-06-26,Schroth), approve(90-07-09,MCR8183),
     audit(90-07-31,WAAnderson), install(90-08-16,MR12.4-1024):
     Changed to ensure that the caller does not block indefinitely when output
     is subdivided and yields no real output (whitespace or edited out), to
     properly set current line counter upon FF or VT, and to free allocated
     buffer chains on crawlout.
                                                   END HISTORY COMMENTS */

/* format: style4,delnl,insnl,^ifthendo */
tty_write:
     proc (twx, a_readp, a_offset, a_nelem, a_nelemt, a_state, ercode);
						/* tty output conversion */


/* 	Date Last Modified and Reason

   Rewritten 11/3/75 by Robert S. Coren
   Modified 04/22/77 by J. Stern to introduce TCBs and WTCBs
   Modified July 78 by J. Nicholls to use channel_manager to write data out, to allow for implementation of multiplexing
   Modified fall of 1979 by Robert Coren to allocate automatic buffers in begin block
   Modified fall of 1979 by Robert Coren for output flow control
   Modified December 1979 by C. Hornig to fix bug in automatic stack frame allocation
   Modified December 1979 by Robert Coren to fix various bugs
   Call metering added October 1980 by Robert Coren
   White-space bug fixed November 1980 by Robert Coren
   write_set_mark entry added February 1981 by Robert Coren
   Modified March 1981 by Robert Coren to fix bugs with null end-of-page string
   Modified June 1981 by Robert Coren to add write_whole_string entry and keep global call count
   Modified June 1982 by Robert Coren to return MASKED state if appropriate
   Modified November 1982 by Robert Coren to return wtcb.error_code
   Modified October 1983 by E. N. Kittlitz for write_whole_string check longest_possible, not use a_offset
   Modified December 1983 by Robert Coren to set buffer tally before copying user data in case of crawlout
   Report on June 1983 - modifications for the Datanet 7100.f.d.
   Report on April 1984 - modifications for the 10.2 f.d.
   Date of the last modification - 17/04/84  
*/

/* PARAMETERS */

dcl  twx fixed bin;					/* device index */
dcl  a_readp ptr;					/* pointer to user's data */
dcl  a_offset fixed bin (21);				/* character to offset to add to readp */
dcl  a_nelem fixed bin (21);				/* number of characters supplied */
dcl  a_string char (*);				/* string to output (for write_set_mark entry) */
dcl  a_mark_flag bit (1);				/* whether to set a mark (write_whole_string entry) */
dcl  a_nelemt fixed bin (21);				/* number of characters shipped (OUTPUT) */
dcl  a_state fixed bin;				/* current state of channel (OUTPUT) */
dcl  ercode fixed bin (35);				/* status code (OUTPUT) */


/* AUTOMATIC */

dcl  state fixed bin;
dcl  devx fixed bin;				/* local copy of device index */
dcl  readp ptr;					/* local copy of a_readp */
dcl  offset fixed bin (21);				/* local copy of a_offset */
dcl  nelem fixed bin (21);				/* local copy of a_nelem */
dcl  nelemt fixed bin (21);				/* local copy of a_nelemt */

dcl  locked_entry bit (1);
dcl  forcesw bit (1);
dcl  mark_entry bit (1);
dcl  whole_string bit (1);

dcl  ttytp ptr;					/* pointer to tty_tables segment */
dcl  tctp ptr;					/* pointer to TCT table */
dcl  mvtp ptr;					/* pointer to translation table */
dcl  special_ptr ptr;				/* pointer to special chars table */
dcl  delay_ptr ptr;					/* pointer to delay table */
dcl  max_space fixed bin;				/* maximum number of words this guy can have */
dcl  max_chars fixed bin;				/* maximun number of character of output */
dcl  max_chars_in_buf fixed bin;			/* number of characters in maximum-size buffer */
dcl  input_ptr ptr;					/* pointer to user-supplied data */
dcl  final_outp ptr;				/* pointer to where output is to be taken from */
dcl  output_length fixed bin (21);			/* length of actual output in chars */

dcl  source_ptr ptr;
dcl  source_len fixed bin;
dcl  target_ptr ptr;
dcl  target_len fixed bin;

dcl  cap_source_ptr ptr;
dcl  cap_target_ptr ptr;
dcl  cap_tab_ptr ptr;
dcl  scanned_len fixed bin;

dcl  time_spent fixed bin (71);
dcl  start_time fixed bin (71);			/* clock time at entry */
dcl  chars_moved bit (1);
dcl  white_sw bit (1);
dcl  line_count fixed bin;				/* number of lines on page so far */
dcl  col fixed bin;					/* current column position */
dcl  wcol fixed bin;				/* column position after addition of white space */
dcl  oldcol fixed bin;
dcl  old_tally fixed bin;
dcl  seqp ptr;					/* pointer to output sequence */
dcl  i fixed bin;
dcl  xor bit (18);					/* used in switching buffer pointers */
dcl  shift bit (2);
dcl  new_char_count fixed bin;
dcl  old_head fixed bin (18);				/* old value of wtcb.write_first */
dcl  old_tail fixed bin (18);				/* old value of wtcb.write_last */
dcl  old_end_frame bit (1);				/* old value of wtcb.end_frame */
dcl  break_length fixed bin;				/* no. of characters before end-of-page */
dcl  break_flag bit (1) aligned;			/* indicates presence of end_of_page */
dcl  null_for_eop bit (1);				/* indicates sending NUL character to force end-of-page */
dcl  n_delays fixed bin;
dcl  back_chars fixed bin;				/* no. of characters required for backward carriage motion */
dcl  forward_chars fixed bin;				/* no. of characters required for forward carriage motion */
dcl  horiz float bin;
dcl  vert fixed bin;
dcl  ll fixed bin;					/* number of output characters on current line */
dcl  escape_index fixed bin;				/* index of output escape sequence */

dcl  headp ptr;
dcl  send bit (1);
dcl  new_head fixed bin;
dcl  n_pages fixed bin;
dcl  lastp ptr;

dcl  bufp ptr;
dcl  prevp ptr;
dcl  buf_size fixed bin;
dcl  orig_buf_size fixed bin;
dcl  reached_needed bit (1);
dcl  new_buffer_count fixed bin;
dcl  first_buffer bit (1);
dcl  old_lastp ptr;
dcl  words_needed fixed bin;
dcl  new_bufp ptr;
dcl  new_buf fixed bin;
dcl  chars_in_buf fixed bin;
dcl  lchar fixed bin;
dcl  old_char_count fixed bin;
dcl  nchars fixed bin;
dcl  cur_space fixed bin;
dcl  cur_chain_len fixed bin;
dcl  end_chain bit (1);
dcl  uncp_flag bit (1);				/* designate UNCP mpx */

dcl  1 util aligned,				/* structure passed to tty_util_ subroutines */
       2 stringp ptr,
       2 stringl fixed bin,
       2 ctally fixed bin,
       2 tablep ptr,				/* pointer to translation table */
       2 indicator fixed bin,				/* returned by tty_util_$find_char */
       2 pad (3) fixed bin;				/* workspace used by tty_util_ */

dcl  1 illegal_char_args aligned,
       2 ic_stringp ptr,
       2 ic_stringl fixed bin,
       2 ic_tally fixed bin,
       2 pad fixed bin,
       2 found_flag bit (1) aligned,
       2 pad2 (4) fixed bin;

dcl  auto_buf_len fixed bin;				/* internal buffer length */
dcl  allocated_buffers bit(1);			/* on if buffers have been obtained */

/* INTERNAL STATIC */

dcl  NOT_INTERESTING fixed bin int static options (constant) init (0);
dcl  NEW_LINE fixed bin int static options (constant) init (1);
dcl  CARRIAGE_RETURN fixed bin int static options (constant) init (2);
dcl  TAB_MULTIPLE_SPACE fixed bin int static options (constant) init (3);
dcl  BACK_SPACE fixed bin int static options (constant) init (4);
dcl  VERTICAL_TAB fixed bin int static options (constant) init (5);
dcl  FORM_FEED fixed bin int static options (constant) init (6);
dcl  OCTAL_ESCAPE fixed bin int static options (constant) init (7);
dcl  RED_SHIFT fixed bin int static options (constant) init (8);
dcl  BLACK_SHIFT fixed bin int static options (constant) init (9);
dcl  INSERT_NO_COUNT fixed bin int static options (constant) init (10);
dcl  INSERT_NO_COUNT_2 fixed bin int static options (constant) init (11);
dcl  SKIP fixed bin int static options (constant) init (12);
dcl  SPECIAL_ESCAPE fixed bin int static options (constant) init (16);

dcl  HUNG_UP fixed bin int static options (constant) init (1);
dcl  LISTENING fixed bin int static options (constant) init (2);
dcl  DIALED_UP fixed bin int static options (constant) init (5);
dcl  MASKED_STATE fixed bin int static options (constant) init (-1);

dcl  max_chain_len fixed bin int static init (16) options (constant);
dcl  reduction_factor float bin int static init (0.8) options (constant);
						/* for allowing for growth of user's string */
dcl  ascii_escape_octal bit (9) int static options (constant) init ("033"b3);
dcl  ascii_escape_char char (1) based (addr (ascii_escape_octal));
dcl  escape_char char (1) int static init ("\") options (constant);
dcl  backspace char (1) int static init ("") options (constant);
						/* backspace */
dcl  space char (1) int static init (" ") options (constant);
dcl  tab char (1) int static init ("	") options (constant);
						/* horizontal tab */
dcl  carriage_return char (1) int static init ("") /* carriage return */ options (constant);
dcl  nl char (1) int static options (constant) init ("
");						/* line feed */

dcl  num_array (0:7) char (1) int static options (constant) init ("0", "1", "2", "3", "4", "5", "6", "7");
						/* for octal escapes */
dcl  eop_sentinel_octal fixed bin (9) unsigned int static init (011111111b) options (constant);
						/* i.e., 377(8) */
dcl  eop_sentinel char (1);
dcl  cont_char char (1) int static init ("c") options (constant);
dcl  shifter (16) bit (1) int static options (constant) init ("0"b, (2) (1)"1"b, (13) (1)"0"b);
dcl  delay_char fixed bin int static options (constant) init (0);
dcl  upper_shift fixed bin int static options (constant) init (28);
						/* i.e., 34(8) */
dcl  lower_shift fixed bin int static options (constant) init (31);
						/* i.e., 37(8) */

dcl  lower_to_caps_edited (128) bit (9) int static options (constant)
	init ("000"b3, "001"b3, "002"b3, "003"b3, "004"b3, "005"b3, "006"b3, "007"b3, "010"b3, "011"b3, "012"b3,
	"013"b3, "014"b3, "015"b3, "016"b3, "017"b3, "020"b3, "021"b3, "022"b3, "023"b3, "024"b3, "025"b3, "026"b3,
	"027"b3, "030"b3, "031"b3, "032"b3, "033"b3, "034"b3, "035"b3, "036"b3, "037"b3, "040"b3, "041"b3, "042"b3,
	"043"b3, "044"b3, "045"b3, "046"b3, "047"b3, "050"b3, "051"b3, "052"b3, "053"b3, "054"b3, "055"b3, "056"b3,
	"057"b3, "060"b3, "061"b3, "062"b3, "063"b3, "064"b3, "065"b3, "066"b3, "067"b3, "070"b3, "071"b3, "072"b3,
	"073"b3, "074"b3, "075"b3, "076"b3, "077"b3, "100"b3, "101"b3, "102"b3, "103"b3, "104"b3, "105"b3, "106"b3,
	"107"b3, "110"b3, "111"b3, "112"b3, "113"b3, "114"b3, "115"b3, "116"b3, "117"b3, "120"b3, "121"b3, "122"b3,
	"123"b3, "124"b3, "125"b3, "126"b3, "127"b3, "130"b3, "131"b3, "132"b3, "133"b3, "134"b3, "135"b3, "136"b3,
	"137"b3, "140"b3, "101"b3, "102"b3, "103"b3, "104"b3, "105"b3, "106"b3, "107"b3, "110"b3, "111"b3, "112"b3,
	"113"b3, "114"b3, "115"b3, "116"b3, "117"b3, "120"b3, "121"b3, "122"b3, "123"b3, "124"b3, "125"b3, "126"b3,
	"127"b3, "130"b3, "131"b3, "132"b3, "173"b3, "174"b3, "175"b3, "176"b3, "177"b3);

dcl  lower_to_caps_nonedited (128) bit (9) int static options (constant)
	init ("000"b3, "001"b3, "002"b3, "003"b3, "004"b3, "005"b3, "006"b3, "007"b3, "010"b3, "011"b3, "012"b3,
	"013"b3, "014"b3, "015"b3, "016"b3, "017"b3, "020"b3, "021"b3, "022"b3, "023"b3, "024"b3, "025"b3, "026"b3,
	"027"b3, "030"b3, "031"b3, "032"b3, "033"b3, "034"b3, "035"b3, "036"b3, "037"b3, "040"b3, "041"b3, "042"b3,
	"043"b3, "044"b3, "045"b3, "046"b3, "047"b3, "050"b3, "051"b3, "052"b3, "053"b3, "054"b3, "055"b3, "056"b3,
	"057"b3, "060"b3, "061"b3, "062"b3, "063"b3, "064"b3, "065"b3, "066"b3, "067"b3, "070"b3, "071"b3, "072"b3,
	"073"b3, "074"b3, "075"b3, "076"b3, "077"b3, "100"b3, "501"b3, "502"b3, "503"b3, "504"b3, "505"b3, "506"b3,
	"507"b3, "510"b3, "511"b3, "512"b3, "513"b3, "514"b3, "515"b3, "516"b3, "517"b3, "520"b3, "521"b3, "522"b3,
	"523"b3, "524"b3, "525"b3, "526"b3, "527"b3, "530"b3, "531"b3, "532"b3, "133"b3, "134"b3, "135"b3, "136"b3,
	"137"b3, "140"b3, "101"b3, "102"b3, "103"b3, "104"b3, "105"b3, "106"b3, "107"b3, "110"b3, "111"b3, "112"b3,
	"113"b3, "114"b3, "115"b3, "116"b3, "117"b3, "120"b3, "121"b3, "122"b3, "123"b3, "124"b3, "125"b3, "126"b3,
	"127"b3, "130"b3, "131"b3, "132"b3, "173"b3, "174"b3, "175"b3, "176"b3, "177"b3);

/* The following declaration is hopefully temporary until prefix characters are encoded in conversion tables */

dcl  prefix char (1) int static init (">") options (constant);
						/* = 076 = 2741 prefix character */

declare LONGEST_POSSIBLE_STRING fixed bin init (8128) int static options (constant);

/* ENTRIES */

dcl  pxss$ring_0_wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
dcl  tty_lock$lock_channel entry (fixed bin, fixed bin (35)),
     tty_lock$unlock_channel entry (fixed bin);

dcl  tty_index$initialize_tcb entry (ptr, ptr);
dcl  tty_util_$mvt entry (ptr);
dcl  tty_util_$scm entry (ptr);
dcl  tty_util_$find_char entry (ptr);
dcl  tty_util_$illegal_char entry (ptr);


/* BASED */

dcl  1 mvt_args aligned based (addr (util)),		/* overlay of tty_util_ structure used for mvt entry */
       2 stringptr ptr,
       2 stringlen fixed bin,
       2 pad fixed bin,
       2 tablep ptr,
       2 targetp ptr;

dcl  1 scm_args aligned based (addr (util)),		/* overlay of util structure used for scm entry */
       2 stringptr ptr,
       2 stringlen fixed bin,
       2 scm_tally fixed bin,
       2 search_mask bit (2) aligned,
       2 found_flag bit (1) aligned;

dcl  based_onechar char (1) based;
dcl  based_chars (0:1) char (1) based unal;		/* used for bumping string pointers */

dcl  output_chars char (output_length) based;
dcl  tally_chars char (ctally) based;
dcl  chars_to_copy char (nchars) based;

dcl  1 seq based aligned like c_chars;				/* template of special chars sequence */

/* EXTERNAL STATIC */

dcl  tty_tables$ ext static;
dcl  error_table_$improper_data_format fixed bin (35) ext static;
dcl  error_table_$invalid_device fixed bin (35) ext static;
dcl  error_table_$io_no_permission fixed bin (35) ext static;
dcl  error_table_$line_status_pending fixed bin (35) ext static;
dcl  error_table_$noalloc fixed bin (35) ext static;
dcl  error_table_$bad_arg fixed bin (35) ext static;
dcl  error_table_$bigarg fixed bin (35) ext static;
dcl  pds$processid bit (36) ext static;


dcl  (addr, bin, bool, byte, clock, divide, fixed, float, hbound, index, length, max,
     min, mod, null, ptr, rank, rel, reverse, string, substr, unspec) builtin;

dcl  cleanup condition;

%include tty_convert;

%include tty_buf;

%include tty_buffer_block;
%include wtcb;

%include tcb;

%include lct;

%include tty_space_man_dcls;

%include channel_manager_dcls;
%include multiplexer_types;
%include net_event_message;

	locked_entry = "0"b;
	forcesw = "0"b;				/* normal call, check buffer limit */
	go to join;

/* privileged entry to bypass buffer limit check - thru hphcs_ - used by answering service */

tty_write_force:
     entry (twx, a_readp, a_offset, a_nelem, a_nelemt, a_state, ercode);

	locked_entry = "0"b;
	go to force_join;


/* entry used to write whole output string or nothing, and optionally set a mark */

tty_write_whole_string:
     entry (twx, a_string, a_mark_flag, a_nelemt, a_state, ercode);

	locked_entry, forcesw = "0"b;
	mark_entry = a_mark_flag;
	whole_string = "1"b;
	go to set_nelem;


/* entry used when sending prompts and questions to distinguish between type-ahead and response */

tty_write_set_mark:
     entry (twx, a_string, a_nelemt, a_state, ercode);

	whole_string, locked_entry, forcesw = "0"b;
	mark_entry = "1"b;
set_nelem:
	nelem = length (a_string);
	offset = 0;
	readp = addr (a_string);
	go to mark_join;



/* special internally-known entry which is called with channel already locked */

locked:
     entry (twx, a_readp, a_offset, a_nelem, a_nelemt, a_state, ercode);

	locked_entry = "1"b;			/* mark it as this entry so we don't lock/unlock */

force_join:
	forcesw = "1"b;

join:
	nelem = a_nelem;
	readp = a_readp;
	whole_string, mark_entry = "0"b;
	offset = a_offset;

mark_join:
	start_time = clock ();
	nelemt = 0;
	a_nelemt = 0;
	a_state = 0;
	ercode = 0;
	ttybp = addr (tty_buf$);			/* get ptrs to tty_buf, tty_data */

	devx = twx;				/* copy device index */
	lctp = tty_buf.lct_ptr;			/* init pointer to lct */
	if devx < 1 | devx > lct.max_no_lctes
	then do;
	     ercode = error_table_$invalid_device;
	     return;
	end;

	uncp_flag = is_parent_mpx (UNCP_MPX);

	if ^locked_entry
	then do;
	     call tty_lock$lock_channel (devx, ercode);	/* lock the channel lock */
	     if ercode ^= 0
	     then return;
	end;

	allocated_buffers = "0"b;
	on cleanup
	begin;
	     if allocated_buffers
	     then do;
		allocated_buffers = "0"b;		/* don't try again */
		call free_buffers;
	     end;
	     if ^locked_entry
	     then call tty_lock$unlock_channel (devx);
	end;					/* cleanup block */

	lctep = addr (lct.lcte_array (devx));		/* get entry of interest */
	if lcte.channel_type ^= TTY_MPX		/* not our type */
	then do;
no_permission:
	     ercode = error_table_$io_no_permission;
	     go to unlock;
	end;

	wtcbp = lcte.data_base_ptr;			/* get pointers to control blocks */
	tcbp = wtcb.tcb_ptr;			/* get tcb pointer */
	if ^wtcb.tcb_initialized
	then call tty_index$initialize_tcb (wtcbp, tcbp);

	if pds$processid ^= wtcb.hproc
	then if (pds$processid ^= wtcb.uproc) | ^tcb.uproc_attached
	     then go to no_permission;

	if wtcb.flags.dialed
	then state = DIALED_UP;
	else if wtcb.flags.listen
	then state = LISTENING;
	else if wtcb.flags.masked
	then state = MASKED_STATE;
	else state = HUNG_UP;

	if state ^= DIALED_UP
	then do;
	     if pds$processid = wtcb.hproc
	     then a_state = state;
	     go to no_permission;
	end;

	a_state = state;

	if wtcb.flags.line_status_present
	then do;
	     ercode = error_table_$line_status_pending;
	     go to unlock;
	end;

	if wtcb.error_code ^= 0
	then do;
	     ercode = wtcb.error_code;
	     wtcb.error_code = 0;
	     go to unlock;
	end;

	if nelem < 0
	then do;
	     ercode = error_table_$bad_arg;
	     go to unlock;
	end;
						/* Added for the Datanet 7100. */
	if uncp_flag then do;
	     if readp = addr (wtcb.prompt)
		then do;
		wtcb.send_turn = "1"b;
		if nelem = 0
		     then do;
		     if wtcb.write_last ^= 0
			then do;
			blockp = ptr (ttybp, wtcb.write_last);
			buffer.turn = "1"b;
			wtcb.send_turn = "0"b;
		     end;
		end;
	     end;
	end;

	ercode = 0;
	if nelem = 0
	then go to all_done;

	eop_sentinel = byte (eop_sentinel_octal);

	if ^tcb.modes.rawom				/* if we're interested in conversion */
	then do;
	     ttytp = addr (tty_tables$);
	     if tcb.output_tctrp = ""b
	     then tctp = null;
	     else tctp = ptr (ttytp, tcb.output_tctrp);
	     if tcb.output_mvtrp = ""b
	     then mvtp = null;
	     else mvtp = ptr (ttytp, tcb.output_mvtrp);
	     if tcb.specialrp = ""b
	     then special_ptr = null;
	     else special_ptr = ptr (ttytp, tcb.specialrp);
	     if tcb.delayrp = ""b
	     then delay_ptr = null;
	     else delay_ptr = ptr (ttytp, tcb.delayrp);
	end;

/**/
/* calculate number of buffers line is allowed to have */

	if forcesw
	then max_space = tty_buf.bleft - 32;		/* force entry can have as many as it needs */
	else do;
	     cur_space = 0;
	     cur_chain_len = 0;
	     if wtcb.write_first ^= 0
	     then do;
		blockp = ptr (ttybp, wtcb.write_first);
		end_chain = "0"b;
		do while (^end_chain);
		     cur_space = cur_space + 16 * (buffer.size_code + 1);
		     cur_chain_len = cur_chain_len + 1;
		     if buffer.next = 0
		     then end_chain = "1"b;
		     else blockp = ptr (ttybp, buffer.next);
		end;
	     end;
	     max_space =
		min (divide (tty_buf.bleft, output_bpart, 17, 0) - cur_space,
		(max_chain_len - cur_chain_len) * (wtcb.max_buf_size - 1));
	end;

	max_chars_in_buf = 4 * (wtcb.max_buf_size - 1) - wtcb.buffer_pad;

	if max_space <= 0
	then 
NO_SPACE_WRITE_NOTHING:
	do;
	     nelemt = 0;
	     go to nothing_written;
	end;					/* otherwise only certain fraction can be allocated */

	max_chars = min (4 * max_space, LONGEST_POSSIBLE_STRING);	/* don't overflow tty_buf or the stack */

/* Determine good sizes for internal automatic buffers for the duration of this call */
/* max_chars takes account of all policy limitations */

	auto_buf_len = min (max_chars, 512 + 2 * nelem);	/* leave lots of leeway */
	max_chars = auto_buf_len;
	if whole_string & nelem > max_chars		/* can't possibly take all of this */
	then do;
	     if nelem <= LONGEST_POSSIBLE_STRING
	     then go to NO_SPACE_WRITE_NOTHING;
	     ercode = error_table_$bigarg;
	     go to unlock;
	end;

	begin;					/* giant begin block */

dcl  buffer_1 char (auto_buf_len) aligned;		/* first internal workspace buffer */
dcl  buffer_2 char (auto_buf_len) aligned;		/* second internal workspace buffer */

	     input_ptr = readp;
	     input_ptr = addr (input_ptr -> based_chars (offset));

	     nelemt = -1;				/* to indicate first time around */

restart:						/* come here if we have to start over */
	     if tcb.modes.rawom			/* raw output, simple */
	     then do;
		final_outp = input_ptr;		/* copy straight from user's data */
		if nelemt < 0			/* i.e. not restart */
		then nelemt = min (nelem, max_chars);
		output_length = nelemt;
	     end;

	     else do;				/* else we must massage the input */
		if nelemt < 0			/* if not already set */
		then nelemt = min (nelem, fixed (reduction_factor * max_chars));

		line_count = wtcb.actline;
		col = wtcb.actcol;
		wcol = wtcb.white_col;

		final_outp, source_ptr = input_ptr;	/* to begin with */
		source_len = nelemt;
		target_ptr = addr (buffer_1);
		target_len = 0;

		if tcb.modes.upper_case
		then call convert_to_upper_case;	/* translate lower-case to caps? */

/* ** FORMATTING ** */

		if tctp ^= null			/* must have output conversion table */
		     & special_ptr ^= null		/* and special chars table too */
		then do;
		     target_len = 0;		/* initially */
		     chars_moved = "0"b;
		     white_sw = (wcol ^= col);	/* depends on whether there's white space left from last call */

		     final_outp = target_ptr;		/* where we expect stuff to end up */

		     if tcb.linemax > 0
		     then do;
			if line_count >= tcb.linemax	/* did input cause EOP condition ? */
			then do;			/* yes, write eop sequence now */
			     seqp = addr (special_ptr -> special_chars.end_of_page);
			     if seqp -> seq.count > 0	/* must have something to write */
			     then do;
				call insert_sequence ("0"b);
				call insert_char (eop_sentinel);
				line_count = 0;
			     end;
			end;
		     end;

		     util.tablep = tctp;		/* formatting table */
		     util.stringp = source_ptr;
		     util.stringl = source_len;

		     do while (util.stringl > 0);	/* main formatting loop */

			oldcol = col;
			call tty_util_$find_char (addr (util));
						/* find next interesting character */

			call move_formated_chars;

			if ^white_sw
			then wcol = col;		/* so next white-space calculation will be right */

		     end;				/* end of formatting loop */

		     if white_sw			/* take care of trailing white space */
		     then if nelemt = nelem		/* if output really ends in white space */
			then call insert_white;
			else if target_len = 0	/* only white? */
			     then call insert_white;	/* expand it */

		end;

		else target_len = source_len;		/* no conversion performed */

		if mvtp ^= null
		then call translation;		/* translation required */

		output_length = target_len;
	     end;					/* end of all conversion phases */

/* ****ALLOCATE BUFFERS AND PASS OUTPUT ON*** */

	     new_char_count, new_buffer_count = 0;

	     if output_length > 0			/* assuming there's anything left after conversion */
	     then do;
		first_buffer = "1"b;
		old_end_frame = wtcb.end_frame;

		if wtcb.write_last = 0
		then do;
		     send = "1"b;			/* there's nothing ahead of it, so we'll send it on */
		     old_head, old_tail = 0;
		end;

		else do;				/* save information about old chain */
		     lastp, old_lastp = ptr (ttybp, wtcb.write_last);
		     send = "0"b;			/* we'll just hang on to this */
		     old_head = wtcb.write_first;
		     old_tail = wtcb.write_last;
		end;

		n_pages = 0;
		headp = null;
		new_head = 0;
		allocated_buffers = "1"b;		/* crawlout can now safely free them */

		do while (output_length > 0);		/* copy for as long as necessary */
		     n_pages = n_pages + 1;

		     if tcb.modes.rawom		/* if raw mode don't check for end of page */
		     then go to no_break;

		     break_length = index (final_outp -> output_chars, eop_sentinel) - 1;
						/* look for page break */
		     if break_length < 0
		     then do;
no_break:
			break_flag = "0"b;		/* no end-of-page markers */
			break_length = output_length;
		     end;

		     else do;
			break_flag = "1"b;
			if break_length = 0
			then do;			/* eop sentinel was first thing */
			     final_outp -> based_chars (0) = byte (delay_char);
						/* send out a NUL because we have to send something to alert lower level */
			     break_length = 1;
			     null_for_eop = "1"b;
			end;
			else null_for_eop = "0"b;
		     end;

		     if tcb.block_acknowledge & tcb.oflow & tcb.max_output_block > 0
						/* new buffer at every end-of-block */
		     then break_length = min (break_length, tcb.max_output_block);

		     output_length = output_length - break_length;

		     do while (break_length > 0);

/* do we have a buffer with room in it? */

			if wtcb.write_last = 0
			then go to get_new_buf;
			if lastp -> buffer.tally < max_chars_in_buf & ^lastp -> buffer.flags.end_of_page
			     & ^(tcb.block_acknowledge & tcb.oflow & tcb.max_output_block > 0)
			then do;
			     lchar = lastp -> buffer.tally;

/* make new buffer as big as appropriate */

			     buf_size, orig_buf_size = 16 * (lastp -> buffer.size_code + 1);
			     reached_needed = "0"b;	/* assume not yet reached appropriate size */
			     do while (^reached_needed);
				chars_in_buf = 4 * (buf_size - 1) - wtcb.buffer_pad;
				if lchar + break_length <= chars_in_buf
						/* room in this buffer for rest of output */
				     | chars_in_buf = max_chars_in_buf
						/* or we've already reached maximum allowable size */
				then reached_needed = "1"b;
				else buf_size = buf_size + 16;
						/* try next size */
			     end;

			     if buf_size ^= orig_buf_size
						/* if we need a new size */
			     then do;		/* get new buffer, and copy contents of old one */
				call tty_space_man$get_buffer (devx, buf_size, OUTPUT, new_bufp);
				if new_bufp ^= null /* only do this if we could get it, of course */
				then do;
				     nchars = lastp -> buffer.tally;
				     source_ptr = addr (lastp -> buffer.chars (0));
				     target_ptr = addr (new_bufp -> buffer.chars (0));
				     target_ptr -> chars_to_copy = source_ptr -> chars_to_copy;
				     new_bufp -> buffer.tally = lastp -> buffer.tally;
				     wtcb.write_last = bin (rel (new_bufp), 18);
						/* this will now be end of chain */

						/* Add for the Datanet 7100. */
				     if uncp_flag then new_bufp -> buffer.turn = lastp -> buffer.turn;
						/* copy turn flag into new buffer */

/* thread new buffer onto end of chain in place of old one */

				     prevp = ptr (ttybp, wtcb.write_first);
						/* start at head */
				     if prevp = lastp
						/* is it tail also? */
				     then wtcb.write_first = wtcb.write_last;
						/* that's simple */
				     else do;	/* else we'll scan the chain */
					do prevp = prevp repeat ptr (ttybp, prevp -> buffer.next)
					     while (prevp -> buffer.next ^= bin (rel (lastp), 18)
					     & prevp -> buffer.next ^= 0);
					end;
					prevp -> buffer.next = wtcb.write_last;
						/* found the next-to-last one */
				     end;

				     call tty_space_man$free_buffer (devx, OUTPUT, lastp);
						/* give the old one back */
				     lastp = new_bufp;

				     if first_buffer
				     then do;
					old_lastp = lastp;
					old_tail = wtcb.write_last;
					if wtcb.write_first = wtcb.write_last
					then old_head = wtcb.write_first;
				     end;
				end;

				else chars_in_buf = 4 * (orig_buf_size - 1) - wtcb.buffer_pad;
						/* couldn't get bigger buffer, use original size */
			     end;

			     bufp = addr (lastp -> buffer.chars (lchar));
			     old_char_count = lastp -> buffer.tally;
			     nchars = min (break_length, chars_in_buf - lchar);
			end;

			else do;			/* no, we'll have to get one */
get_new_buf:
			     words_needed =
				max (16,
				min (wtcb.max_buf_size,
				16 * divide (break_length + wtcb.buffer_pad + 67, 64, 17, 0)));
			     call tty_space_man$get_buffer (devx, words_needed, OUTPUT, new_bufp);
			     if new_bufp = null	/* couldn't get the space */
			     then go to free_and_try_again;
			     new_buf = bin (rel (new_bufp), 18);
			     chars_in_buf = 4 * (words_needed - 1) - wtcb.buffer_pad;

			     if first_buffer
			     then do;
				new_head = new_buf;
				first_buffer = "0"b;
			     end;

			     new_buffer_count = new_buffer_count + 1;
			     lchar = 0;
			     if wtcb.write_last ^= 0	/* chain already abuilding */
			     then lastp -> buffer.next = new_buf;
			     else wtcb.write_first = new_buf;

			     wtcb.write_last = new_buf;
						/* in any case */
			     lastp = new_bufp;
			     string (lastp -> buffer.flags) = "0"b;

			     old_char_count = 0;
			     bufp = addr (lastp -> buffer.chars (0));
			     nchars = min (break_length, chars_in_buf);
			end;

			lastp -> buffer.tally = old_char_count + nchars;
			lastp -> buffer.flags.break = "0"b;
						/* not at end of user data */
			bufp -> chars_to_copy = final_outp -> chars_to_copy;
						/* put characters in buffer */
			final_outp = addr (final_outp -> based_chars (nchars));
			new_char_count = new_char_count + nchars;
			break_length = break_length - nchars;

						/* Add for the Datanet 7100. */
			if uncp_flag then do;
			     if break_length = 0
				then do;
				lastp -> buffer.turn = wtcb.send_turn;
				wtcb.send_turn = "0"b;
			     end;
			end;
		     end;


		     if break_flag			/* did we stop because of end-of-page? */
		     then do;
			lastp -> buffer.flags.end_of_page = "1"b;
			if ^null_for_eop		/* if we haven't laready skipped over sentinel */
			then do;
			     final_outp = addr (final_outp -> based_chars (1));
						/* skip over sentinel */
			     output_length = output_length - 1;
			end;
		     end;

		     if tcb.block_acknowledge & tcb.oflow & tcb.max_output_block > 0
		     then do;			/* insert end_of_block char */
			if lastp -> buffer.tally < chars_in_buf
						/* it'll fit in last buffer */
			then do;
			     lastp -> buffer.chars (lastp -> buffer.tally) =
				substr (tcb.output_suspend_etb_seq.chars, 1, 1);
			     lastp -> buffer.tally = lastp -> buffer.tally + 1;
			end;

			else do;			/* unfortunately, we have to allocate a whole buffer for this char */
			     call tty_space_man$get_buffer (devx, 16, OUTPUT, new_bufp);
			     if new_bufp = null
			     then go to free_and_try_again;
			     string (new_bufp -> buffer.flags) = "0"b;
			     new_bufp -> buffer.tally = 1;
			     new_bufp -> buffer.chars (0) = substr (tcb.output_suspend_etb_seq.chars, 1, 1);
			     wtcb.write_last, lastp -> buffer.next = bin (rel (new_bufp), 18);
			     lastp = new_bufp;
			end;
		     end;
		end;				/* end of buffer-allocation loop */

		if nelem = nelemt
		then do;
		     lastp -> buffer.flags.break = "1"b;/* end of user data */
		     lastp -> buffer.flags.mark = mark_entry;
		end;

		if send & wtcb.send_output		/* if this is first new output, we'll pass it on */
		then do;
		     if n_pages > 1
		     then do;			/* peel off first page if there's more than one */
			blockp = ptr (ttybp, wtcb.write_first);

			do while (^buffer.end_of_page & buffer.next ^= 0);
						/* find last buffer of page */
			     blockp = ptr (ttybp, buffer.next);
			end;

			lastp = blockp;		/* this is it */
		     end;

		     else lastp = ptr (ttybp, wtcb.write_last);
						/* if only 1 page, last buffer is last buffer of page */
		     if mark_entry
		     then wtcb.mark_set = lastp -> buffer.mark;
						/* we're sending the mark now */
		     new_head = lastp -> buffer.next;	/* this will be the head of the remaining chain (if any) */
		     headp = ptr (ttybp, wtcb.write_first);
		     wtcb.write_first = lastp -> buffer.next;
						/* update wtcb pointers now (we'll restore them if necessary) */
		     if wtcb.write_first = 0
		     then wtcb.write_last = 0;	/* ensure consistency always */
		     lastp -> buffer.next = 0;	/* break the chain at page end */
		     wtcb.end_frame = lastp -> buffer.end_of_page;

		     call channel_manager$write (devx, headp, ercode);
		     if ercode = error_table_$noalloc
		     then do;
			nelemt = 0;		/* this means they couldn't take it at all */
			call free_buffers;
			go to nothing_written;
		     end;
		     else do;
			if ercode ^= 0
			then do;
			     call free_buffers;	/* get rid of anything we've got left (it's unwritable) */
			     if wtcb.write_first ^= 0 /* and I mean ANYTHING */
			     then do;
				call tty_space_man$free_chain (devx, OUTPUT, ptr (ttybp, wtcb.write_first));
				wtcb.write_first, wtcb.write_last = 0;
				wtcb.mark_set = "0"b;
						/* all bets are off */
			     end;
			end;

			else if headp ^= null
			then do;			/* didn't take it all */
			     wtcb.write_first = bin (rel (headp));
			     blockp = headp;
			     do while (buffer.next ^= 0);
						/* find end of returned chain */
				blockp = ptr (ttybp, buffer.next);
			     end;

			     buffer.next = new_head;	/* hook it back on */
			     if wtcb.write_last = 0	/* sent all we had */
			     then wtcb.write_last = bin (rel (blockp));
						/* this is now end of the chain */

			     if mark_entry
			     then wtcb.mark_set = "0"b;
						/* override any previously-set mark */
			end;
			wtcb.send_output = "0"b;	/* no more till he asks for it */
		     end;
		end;
	     end;

	     if ^tcb.modes.rawom
	     then do;				/* only if messed around with it */
		wtcb.actcol = col;
		wtcb.actline = line_count;
		wtcb.white_col = wcol;
	     end;

	     if nelemt < nelem
	     then do;				/* we couldn't get them all out this time */
		i = (nelem - nelemt);		/* approximate num of chars left to output */
		if tty_buf.minbuf = 0 | tty_buf.minbuf > i
		then tty_buf.minbuf = i;		/* if new minimum, set it */

		tty_buf.totbuf = tty_buf.totbuf + i;	/* set blocked-for-write meters  */
		tty_buf.nblocked = tty_buf.nblocked + 1;

		/*** If we did not consume all of our caller's output but
		generated no output, ensure that the process sees a wakeup
		so that the rest of the output will be handled. */
		
		if wtcb.send_output			/* nothing in progress */
		then do;
		     unspec (net_event_message) = "0"b;
		     net_event_message.version = NET_EVENT_MESSAGE_VERSION_1;
		     net_event_message.network_type = MCS_NETWORK_TYPE;
		     net_event_message.handle = devx;
		     net_event_message.type = MCS_WRITE_MSG;
		     call pxss$ring_0_wakeup (wtcb.uproc, wtcb.event, net_event_message_arg, (0));
		     wtcb.wflag = "0"b;
		end;
		else wtcb.flags.wflag = "1"b;		/* so wakeup will happen when write completes */
	     end;

	     tcb.cumulative_meters.write_chars = tcb.cumulative_meters.write_chars + nelemt;
	     tcb.cumulative_meters.write_calls = tcb.cumulative_meters.write_calls + 1;
	     tty_buf.write_calls = tty_buf.write_calls + 1;
	     tty_buf.noutchars = tty_buf.noutchars + nelemt;
						/* keep count of output chars per type */
	     tty_buf.nrawwrite = tty_buf.nrawwrite + new_char_count;
	     go to all_done;

free_and_try_again:					/* here if we or next level couldn't allocate buffers */
	     call free_buffers;
	     tty_buf.output_buffer_overflow = tty_buf.output_buffer_overflow + 1;
try_again:					/* here if we overflowed internal buffer space */
	     if whole_string			/* mustn't subdivide caller's string */
	     then do;
		nelemt = 0;
		go to nothing_written;
	     end;

	     tty_buf.output_restart = tty_buf.output_restart + 1;

	     nelemt = divide (nelemt, 2, 18, 0);	/* cut in half to try again */
	     if nelemt > 0				/* does that leave us anything to process? */
	     then go to restart;
	     else go to nothing_written;



/* *** ERROR BRANCH FOR FAULTY TABLE VALUES *** */

table_error:
	     ercode = error_table_$improper_data_format;
	     go to unlock;

/* ***********INTERNAL PROCEDURES********* */

copy_chars:
     proc;

/* This procedure copies ctally characters form source_ptr to target_ptr */

	target_len = target_len + ctally;
	if target_len > max_chars			/* check for overflow */
	then go to try_again;

	target_ptr -> tally_chars = source_ptr -> tally_chars;

	source_ptr = addr (source_ptr -> based_chars (ctally));
						/* bump pointers */
	target_ptr = addr (target_ptr -> based_chars (ctally));
	return;

     end /* copy_chars */;

insert_char:
     proc (one_char);

/* This procedure places a single character in the output string */

dcl  one_char char (1);

	target_len = target_len + 1;
	if target_len > max_chars			/* mustn't overflow buffer space */
	then go to try_again;

	target_ptr -> based_onechar = one_char;
	target_ptr = addr (target_ptr -> based_chars (1));
	return;

     end /* insert_char */;

insert_delays:
     proc (ndelays);

/* This procedure inserts a specified number of delay characters into the output */

dcl  ndelays fixed bin;
dcl  i fixed bin;

	if ndelays <= 0
	then return;				/* nothing to do */

	target_len = target_len + ndelays;
	if target_len > max_chars			/* red warning */
	then go to try_again;			/* tough */

	do i = 0 to ndelays - 1;			/* remember based_chars starts at 0 */
	     target_ptr -> based_chars (i) = byte (delay_char);
	end;

	target_ptr = addr (target_ptr -> based_chars (ndelays));
						/* bump pointer */
	return;

     end /* insert_delays */;

insert_sequence:
     proc (a_col_sw);

/* This procedure inserts the character sequence pointed to by seqp */
/* col_sw tells whether or not to check for overflowing line-length */

dcl  a_col_sw bit (1) aligned;
dcl  col_sw bit (1) aligned;
dcl  i fixed bin;
dcl  auto_len fixed bin;

	col_sw = a_col_sw;
	c_chars_ptr = seqp;				/* make compiler happy */
	auto_len = seqp -> seq.count;			/* copy sequence length into automatic */
	if auto_len = 0
	then return;				/* no sequence */

	if auto_len < 0 | auto_len > hbound (c_chars.chars, 1)/* probably not a real sequence */
	then go to table_error;

	target_len = target_len + auto_len;
	if target_len > max_chars
	then go to try_again;

	if seqp -> seq.chars (1) = ascii_escape_char
	then col_sw = "0"b;				/* if escape sequence, best not to mess with the columns */
	do i = 1 to auto_len;
	     if col_sw				/* do we care about column position? */
	     then do;				/* yes */
		if seqp -> seq.chars (i) = backspace	/* back up with delays in this case */
		then do;
		     col = max (0, col - 1);
		     if delay_ptr ^= null
		     then call insert_delays (delay_ptr -> delay.backspace);
		end;

		else if rank (seqp -> seq.chars (i)) < 32
		then ;				/* if so, then probably doesn't move carriage */
						/* adding 0 is just as good as + 1 when we don't know what
						   the chars really do to the terminal */

		else do;
		     if ((tcb.colmax > 0) & (col >= tcb.colmax))
		     then call insert_nl ("1"b);
		     col = col + 1;
		end;
	     end;

	     target_ptr -> based_onechar = seqp -> seq.chars (i);
	     target_ptr = addr (target_ptr -> based_chars (1));
						/* bump pointer */
	end;

	return;

     end /* insert_sequence */;

insert_white:
     proc;

/* this procedure puts white space into the output string */

	if wcol ^= col				/* make sure we're not already where we belong */
	then do;
	     if tcb.colmax > 0
	     then do while (wcol > tcb.colmax);		/* put in any necessary new-lines */
		call insert_nl ("1"b);
		oldcol = 2;
		wcol = wcol - tcb.colmax + 2;
	     end;

	     if wcol < col				/* we're going to have to back up */
	     then if wcol = 0			/* that one's easy */
		then call insert_cr;		/* just put in carriage return */

		else if special_ptr -> special_chars.cr_seq.count > 0
		then do;				/* figure out which way to back up */
		     back_chars = col - wcol;		/* that's how many backspaces it would take */
		     if back_chars <= 6		/* in this case don't bother calculating other */
		     then forward_chars = back_chars;	/* to make sure test will fail */
		     else if tcb.modes.tabm
		     then forward_chars = divide (wcol, 10, 17, 0) + mod (wcol, 10) + 1;
						/* tabs + spaces + cr */
		     else forward_chars = wcol + 1;	/* spaces + cr */

		     if back_chars - forward_chars > 6 | special_ptr -> special_chars.bs_seq.count = 0
						/* no backspace available */
		     then call insert_cr;		/* thereby setting col to 0, we'll do forward later */
		     else call insert_bs (back_chars);	/* put in necessary number of backspaces */
		end;

		else call insert_bs (col - wcol);

	     if wcol > col				/* we have to go forward */
	     then do;
		if tcb.modes.tabm			/* might we use tabs? */
		then do;
		     do while (wcol - col > 10);	/* tabs are relevant */
			call insert_tab;		/* will update col */
		     end;

		     if mod (wcol, 10) <= mod (col, 10) /* room for another tab */
		     then call insert_tab;
		end;

		do col = col by 1 while (col < wcol);
		     call insert_char (space);	/* put in spaces as required */
		end;
	     end;
	end;

	oldcol = wcol;
	white_sw = "0"b;				/* we've done it now */
	return;

     end /* insert_white */;

insert_nl:
     proc (esc_sw);

/* This procedure inserts new-line sequences in the output string */
/* esc_sw indicates whether a "\c" sequence should be added */

dcl  esc_sw bit (1) aligned;
dcl  delay_before bit (1) aligned;
dcl  eop_sw bit (1) aligned;
dcl  eop_seqp ptr;
dcl  seqp ptr;
dcl  based_target_chars char (target_len) based;

	eop_sw = "0"b;
	eop_seqp = null;

	if tcb.linemax > 0
	then do;
	     line_count = line_count + 1;
	     eop_sw = (line_count >= tcb.linemax);
	     if eop_sw
	     then do;
		eop_seqp = addr (special_ptr -> special_chars.end_of_page);
		if eop_seqp -> seq.count = 0		/* null end-of-page sequence */
		then eop_seqp = null;
		line_count = 0;
	     end;
	end;

	if eop_sw & (eop_seqp = null)			/* omit end-of-page marker and put sentinel before newline */
	then do;
	     if target_len = 0			/* don't let sentinel be first thing in output */
	     then call insert_char (byte (delay_char));	/* so insert a NUL */
	     call insert_char (eop_sentinel);
	end;

	else do;
	     seqp = addr (special_ptr -> special_chars.nl_seq);
						/* this is the sequence we will use */

	     if delay_ptr ^= null			/* delays needed */
	     then do;
		horiz = delay_ptr -> delay.horz_nl;
		vert = delay_ptr -> delay.vert_nl;

		if vert < 0			/* special */
		then do;				/* means minimum line length */
		     ll = index (reverse (final_outp -> based_target_chars), nl) - 1;
						/* find latest nl */
		     if ll < 0
		     then ll = target_len;
		     n_delays = max (0, -vert - ll);

		     delay_before = "1"b;		/* put delays before sequence */
		end;

		else do;				/* normal delays */
		     delay_before = "0"b;		/* delays after nl */
		     n_delays = vert + fixed (float (col) * horiz, 17, 0);
		end;
	     end;

	     else n_delays = 0;

	     if delay_before			/* do it now */
	     then if n_delays > 0			/* if at all */
		then call insert_delays (n_delays);

	     call insert_sequence_internal;		/* put in the sequence */

	     if ^delay_before
	     then if n_delays > 0
		then call insert_delays (n_delays);

	     if eop_sw
	     then do;
		seqp = eop_seqp;
		call insert_sequence_internal;	/* put in end-of-page warning */
		call insert_char (eop_sentinel);	/* put in sentinel for copying phase */
	     end;
	end;

	if esc_sw					/* was this nl because of line overflow? */
	then do;
	     call insert_char (escape_char);
	     call insert_char (cont_char);
	     col = 2;
	end;

	else col = 0;

	return;

insert_sequence_internal:
	proc;

/* this is an internal procedure in insert_nl because if insert_nl calls */
/* insert_sequence both procedures become non-quick
   because insert_sequence has the potential to call insert_nl, thus they
   would be recursive and by definition recursion is reason for being non-quick
*/

dcl  i fixed bin;
dcl  auto_len fixed bin;

	     c_chars_ptr = seqp;			/* make compiler happy */
	     auto_len = seqp -> seq.count;		/* copy sequence length into automatic */
	     if auto_len = 0
	     then return;				/* no sequence */

	     if auto_len < 0 | auto_len > hbound (c_chars.chars, 1)	/* probably not a real sequence */
	     then go to table_error;

	     target_len = target_len + auto_len;
	     if target_len > max_chars
	     then go to try_again;

	     do i = 1 to auto_len;
		target_ptr -> based_chars (i - 1) = seqp -> seq.chars (i);
	     end;

	     target_ptr = addr (target_ptr -> based_chars (auto_len));
						/* bump pointer */
	     return;

	end /* insert_sequence_internal */;

     end /* insert_nl */;

insert_cr:
     proc;

/* This procedure inserts a carriage return */

	if col = 0
	then return;				/* no need */

	seqp = addr (special_ptr -> special_chars.cr_seq);
	if seqp -> seq.count = 0
	then call insert_bs (col);			/* if cr not implemented, use backspaces */

	else do;
	     call insert_sequence ("0"b);
	     if delay_ptr ^= null
	     then if delay_ptr -> delay.horz_nl ^= 0
		then call insert_delays (
			max (delay_ptr -> delay.horz_nl * col + max (0, delay_ptr -> delay.vert_nl), 1));

	     col = 0;
	end;

	return;

     end /* insert_cr */;

insert_bs:
     proc (how_many);

/* This procedure inserts a specified number of backspaces in the output string */

dcl  how_many fixed bin;
dcl  count fixed bin;
dcl  i fixed bin;
dcl  bs_char char (1);
dcl  new_col fixed bin;

	count = min (how_many, col);
	if count <= 0
	then return;

	seqp = addr (special_ptr -> special_chars.bs_seq);
	if seqp -> seq.count = 0			/* no backspace for this terminal */
	then do;
	     new_col = col - count;
	     seqp = addr (special_ptr -> special_chars.cr_seq);
						/* do carriage return, then forward space */
	     if seqp -> seq.count = 0
	     then return;				/* nothing to do here */
	     call insert_sequence ("0"b);
	     if delay_ptr ^= null
	     then if delay_ptr -> delay.horz_nl ^= 0
		then if delay_ptr -> delay.vert_nl >= 0
		     then call insert_delays (max (fixed (delay_ptr -> delay.horz_nl * float (col), 17, 0), 1));

	     col = 0;
	     if new_col = 0
	     then return;				/* all done */

	     if tcb.modes.tabm			/* use tabs if appropriate */
	     then do;
		do while (new_col - col >= 10);
		     call insert_tab;
		end;

		if mod (new_col, 10) < mod (col, 10)	/* room for another */
		then call insert_tab;
	     end;

	     do col = col by 1 while (col < new_col);
		call insert_char (space);		/* fill it up with spaces */
	     end;

	     return;
	end;

	if seqp -> seq.count > 1			/* not simply backspace */
	then do i = 1 to count;
	     call insert_sequence ("0"b);		/* we will have to handle the column position our self */
	     col = max (0, col - 1);			/* and we will do it here for a back space */
	end;

	else do;					/* backspace itself, deal with delays */
	     if delay_ptr = null
	     then n_delays = 0;
	     else n_delays = delay_ptr -> delay.backspace;

	     bs_char = seqp -> seq.chars (1);

	     if n_delays > 0			/* normal delay timing */
	     then do i = 1 to count;
		call insert_delays (n_delays);
		call insert_char (bs_char);
	     end;

	     else do;
		if n_delays < 0			/* this means timing for overstrike */
		then if -n_delays > count		/* so multiple backspaces can count instead of delays */
		     then call insert_delays (-n_delays - count);

		target_len = target_len + count;
		if target_len > max_chars		/* we will blow the buffer */
		then go to try_again;

		do i = 1 to count;
		     target_ptr -> based_chars (i - 1) = bs_char;
		end;

		target_ptr = addr (target_ptr -> based_chars (count));
	     end;

	     col = col - count;			/* we backed up */
	end;

	return;

     end /* insert_bs */;

insert_tab:
     proc;

/* this procedure inserts a horizontal tab */

dcl  i fixed bin;
dcl  count fixed bin;

	count = 10 - mod (col, 10);

	if count = 1				/* no point putting in tab for one space */
	then call insert_char (space);

	else do;
	     if tcb.modes.tabm & special_ptr -> special_chars.tab_seq.count > 0
						/* tabs are real */
	     then do;
		call insert_char (tab);
		if delay_ptr ^= null
		then do;
		     n_delays =
			delay_ptr -> delay.const_tab + fixed (delay_ptr -> delay.var_tab * float (count), 17, 0);
		     if n_delays > 0
		     then call insert_delays (n_delays);
		end;
	     end;

	     else do;				/* must simulate with spaces */
		target_len = target_len + count;
		if target_len > max_chars
		then go to try_again;		/* we can't let this happen */

		do i = 1 to count;
		     target_ptr -> based_chars (i - 1) = space;
		end;

		target_ptr = addr (target_ptr -> based_chars (count));
	     end;
	end;

	col = col + count;
	return;

     end /* insert_tab */;

translation:
     proc;

/* This procedure does a character translation of the output buffer using a move and translate operation */

	source_ptr, util.stringp = final_outp;		/* we'll start picking up where final stuff was left */

	if final_outp = addr (buffer_1)		/* use the buffer not already occupied */
	then target_ptr = addr (buffer_2);
	else target_ptr = addr (buffer_1);

	util.stringl = target_len;
	util.tablep = mvtp;
	mvt_args.targetp = target_ptr;
	call tty_util_$mvt (addr (util));		/* do the translation itself */

	final_outp = target_ptr;			/* now */

	if shifter (wtcb.line_type)			/* do we have to put in case shifts? */
	then do;
	     source_ptr, util.stringp = target_ptr;	/* we'll have to move again, probably */
	     xor = bool (rel (addr (buffer_1)), rel (addr (buffer_2)), "0110"b);
						/* use to switch buffers */
	     target_ptr, final_outp = ptr (target_ptr, bool (xor, rel (target_ptr), "0110"b));

	     shift = "01"b;				/* new write chain starts in lower also */

	     scm_args.search_mask = bool (shift, "11"b, "0110"b);
						/* look for opposite shift */
	     call tty_util_$scm (addr (util));

	     if ^scm_args.found_flag			/* no shift changes at all */
	     then final_outp = source_ptr;		/* we won't move anything */
	     else do;
		target_len = 0;
		if ctally > 0			/* move characters to left of found shift */
		then call copy_chars;

		do while (scm_args.found_flag);
		     if ctally = 0
		     then call insert_shift;
		     else do;
			i = -1;			/* necessary to fool compiler */
			if target_ptr -> based_chars (i) ^= prefix
			then call insert_shift;

			else do;			/* previous char was prefix, mustn't shift */
			     call insert_char (source_ptr -> based_chars (0));
						/* put unshifted char in */
			     stringp, source_ptr = addr (source_ptr -> based_chars (1));
						/* skip over it */
			     stringl = stringl - 1;
			end;
		     end;

		     call tty_util_$scm (addr (util));
		     if ctally > 0
		     then call copy_chars;		/* move any we scanned over */
		end;

		if shift = "10"b			/* if we ended up in upper */
		then call insert_char (byte (lower_shift));
						/* change to lower */
		tcb.actshift = "01"b;
	     end;
	end;

	return;

     end translation;				/* end of translation phase */

insert_shift:
     proc;

/*  This procedure inserts the proper shift character into the stream for an IBM 2741 like shift device */

	if shift = "01"b				/* we were in lower case */
	then call insert_char (byte (upper_shift));	/* put in upper shift */
	else call insert_char (byte (lower_shift));	/* or lower, as the case may be */

	scm_args.search_mask = shift;			/* switch to look for other shift */
	shift = bool (shift, "11"b, "0110"b);

	return;

     end insert_shift;

convert_to_upper_case:
     proc;

/*
   This procedure takes a string from buffer 1 and sets up the necessary variables
   and the translates the stream into uper case characters in buffer 2 using the
   move and translate operation.  The characters may either be edited
   or not. (i.e. true upper case has an escape before it or not)
*/


	target_ptr = addr (buffer_2);
	chars_moved = "0"b;

	if tcb.modes.edited
	then cap_tab_ptr = addr (lower_to_caps_edited);
	else cap_tab_ptr = addr (lower_to_caps_nonedited);

/* we'll have to be careful to step over characters greater than 177 */

	cap_source_ptr, ic_stringp = source_ptr;
	cap_target_ptr = addr (buffer_1);
	ic_stringl = source_len;
	illegal_char_args.found_flag = "1"b;		/* so "while" will work at least once */
	scanned_len = 0;

	do while (illegal_char_args.found_flag & ic_stringl > 0);
	     call tty_util_$illegal_char (addr (illegal_char_args));
						/* look for funny character */

/* now just scan the string up to the character found (if any) */

	     if illegal_char_args.ic_tally > 0		/* if there's a string to scan */
	     then do;
		util.stringp = cap_source_ptr;
		util.stringl = ic_tally;
		util.tablep = cap_tab_ptr;

		mvt_args.targetp = cap_target_ptr;
		call tty_util_$mvt (addr (util));

		if ^tcb.modes.edited
		then do;				/* in ^edited mode, must insert escapes */
		     source_ptr, util.stringp = cap_target_ptr;
		     scm_args.search_mask = "10"b;	/* look for chars with high-order bit on */
		     scm_args.found_flag = "1"b;	/* so "while" will work right */

		     do while (scm_args.found_flag);
			call tty_util_$scm (addr (util));
			if scm_args.found_flag	/* found a capital */
			then do;
			     if ^chars_moved	/* first time we've had to move any */
			     then do;
				ctally = ctally + scanned_len;
						/* take the ones we skipped before */
				source_ptr = addr (buffer_1);
						/* have to pick up all chars so far */
			     end;

			     if ctally > 0
			     then call copy_chars;	/* copy all chars left of it */
			     call insert_char (escape_char);

			     source_len = source_len + 1;
						/* we've added a character to be scanned */
			     chars_moved = "1"b;
			     unspec (util.stringp -> based_onechar) =
				unspec (util.stringp -> based_onechar) & "011111111"b;
						/* turn off high-order bit */
			end;

			else if chars_moved		/* we didn't find one, did we move any chars? */
			then call copy_chars;	/* move the rest */

		     end;
		end;				/* through looking for caps */
	     end;

	     if illegal_char_args.found_flag
	     then do;				/* if we've had to stop for high-order bits at all */

		if chars_moved			/* we've had to copy for escapes */
		then call insert_char (cap_source_ptr -> based_chars (ic_tally));
						/* copy untouched funny char */

		else cap_target_ptr -> based_chars (ic_tally) = cap_source_ptr -> based_chars (ic_tally);

		scanned_len = scanned_len + ic_tally + 1;

/* adjust pointers to start looking after it */

		ic_stringp, cap_source_ptr = addr (cap_source_ptr -> based_chars (ic_tally + 1));
		cap_target_ptr = addr (cap_target_ptr -> based_chars (ic_tally + 1));
		ic_stringl = ic_stringl - 1;
	     end;
	end;

	if chars_moved				/* have to adjust some pointers */
	then do;
	     source_ptr = addr (buffer_2);		/* chars are in buffer_2 now */
	     target_ptr = addr (buffer_1);
	end;
	else source_ptr = addr (buffer_1);		/* make sure this gets set */

	return;

     end convert_to_upper_case;

move_formated_chars:
     proc;

/*
   This procedure is called to move chars to a different
   buffer when some reformating is necessary due to the encountering of some
   special characters in the present buffer
*/


	chars_moved = "1"b;				/* we'll have to do some moving */

	if ctally > 0				/* we have some uninteresting ones to pick up */
	then do;
	     if white_sw
	     then call insert_white;			/* pick up any outstanding white space */
	     col = col + ctally;
	     if tcb.dont_count_next			/* first char doesn't count */
	     then do;
		col = col - 1;
		tcb.dont_count_next = "0"b;
	     end;
	     if ((tcb.colmax > 0) & (col > tcb.colmax))
	     then call wrap_lines;
	     else do;				/* wrap_lines would this for us */
		call copy_chars;
		wcol = col;
	     end;
	end;

	else if tcb.dont_count_next			/* we're supposed to swallow first char whole */
	then do;
	     ctally = 1;				/* get it */
	     call copy_chars;

	     if indicator = 3 | indicator = 7		/* we're still pointing at it */
	     then do;
		stringp = addr (stringp -> based_chars (1));
						/* bump pointer */
		stringl = stringl - 1;		/* decrement length */
	     end;

	     indicator = NOT_INTERESTING;		/* don't do anything else about this char */
	end;

/* now examine indicator */

	if indicator = NOT_INTERESTING		/* no interesting characters */
	then if white_sw
	     then call insert_white;			/* add white space if necessary */
	     else ;				/* otherwise go around again */

	else if indicator = NEW_LINE			/* new-line */
	then do;
	     white_sw = "0"b;			/* throw away any outstanding white space */
	     call insert_nl ("0"b);			/* put the nl in */
	end;

	else if indicator = CARRIAGE_RETURN		/* carriage return */
	then do;
	     white_sw = "1"b;			/* we'll process this later as white space */
	     wcol = 0;				/* taking us to column zero */
	end;

	else if indicator = TAB_MULTIPLE_SPACE		/* tab or multiple blanks */
	then call scan_white ("0"b);

	else if indicator = BACK_SPACE		/* backspace */
	then do;
	     wcol = max (0, wcol - 1);		/* back up the "white" column */
	     call scan_white ("1"b);

	end;

	else if indicator = VERTICAL_TAB | indicator = FORM_FEED
						/* vertical tab or form-feed */
	then if tcb.modes.vertsp			/* if we're processing such */
	     then do;
		if indicator = VERTICAL_TAB		/* vertical tab */
		then do;
		     if tcb.linemax > 0		/* if we're counting lines */
		     then do;
			line_count = line_count + 10 - mod (line_count, 10);
						/* next vt stop */
			if line_count >= tcb.linemax	/* over to new page */
			then do;
			     seqp = addr (special_ptr -> special_chars.end_of_page);
			     call insert_sequence ("0"b);
						/* mark end-of-page if necessary */
			     call insert_char (eop_sentinel);
			     line_count = 0;
			end;
		     end;
		     seqp = addr (special_ptr -> special_chars.vt_seq);
		end;

		else do;				/* else it is a form feed */
		     if tcb.linemax > 0
		     then do;			/* if we care about page length */
			seqp = addr (special_ptr -> special_chars.end_of_page);
			call insert_sequence ("0"b);
			call insert_char (eop_sentinel);
		     end;
		     line_count = 0;
		     seqp = addr (special_ptr -> special_chars.ff_seq);
		end;

		call insert_sequence ("0"b);
		if delay_ptr ^= null
		then call insert_delays (delay_ptr -> delay.vt_ff);

		col = 0;				/* implied new-line always */
		white_sw = "0"b;
	     end;

	     else if ^tcb.modes.edited		/* we'll have to escape it */
	     then do;
		i = -1;				/* so compiler won't complain */
		stringp = addr (stringp -> based_chars (i));
						/* back up by one */
		stringl = stringl + 1;
		call octal_escape;
	     end;
	     else ;

	else if indicator = OCTAL_ESCAPE		/* octal escape */
	then call octal_escape;

	else if indicator = RED_SHIFT | indicator = BLACK_SHIFT
						/* ribbon shift */
	then if tcb.modes.redm			/* if this is interesting */
	     then do;
		if white_sw
		then call insert_white;		/* if video terminal this is noticable */
		if indicator = RED_SHIFT
		then seqp = addr (special_ptr -> special_chars.red_ribbon_shift);
		else seqp = addr (special_ptr -> special_chars.black_ribbon_shift);

		call insert_sequence ("0"b);
	     end;
	     else ;

	else if indicator = INSERT_NO_COUNT		/* insert without counting column position */
	then do;
	     if white_sw
	     then call insert_white;
	     ctally = 1;
	     call copy_chars;
	end;

	else if indicator = INSERT_NO_COUNT_2		/* neither this char nor next one affects column position */
	then do;
	     if white_sw
	     then call insert_white;
	     ctally = min (stringl + 1, 2);		/* copy this one and next (if present) */
	     call copy_chars;

	     if ctally = 2				/* get them both */
	     then do;
		stringp = addr (stringp -> based_chars (1));
						/* bump past escaped char */
		stringl = stringl - 1;
	     end;

	     else tcb.dont_count_next = "1"b;		/* wasn't a next one, catch it next time */
	end;

	else if indicator = SKIP			/* ignore this one entirely */
	then ;

	else if indicator > SPECIAL_ESCAPE
	then do;					/* special escape sequence */
	     escape_index = indicator - 16;
	     if escape_index > special_ptr -> special_chars.escape_length
						/* not a good index */
	     then go to table_error;

	     if white_sw
	     then call insert_white;
	     if tcb.modes.edited
	     then seqp = addr (special_ptr -> special_chars.edited_escapes (escape_index));
	     else seqp = addr (special_ptr -> special_chars.not_edited_escapes (escape_index));

	     call insert_sequence ("1"b);
	end;

	else go to table_error;			/* invalid indicator */

	if stringl > 0				/* if we're going around again */
	then source_ptr = stringp;			/* update source pointer */

	return;

     end move_formated_chars;

wrap_lines:
     proc;

/*
   This procedure is called when the output line exceeds the maximum number
   of columns we think the device has
*/

	if tcb.colmax < 1
	then return;				/* we should not have come here */
	do while (col > tcb.colmax);			/* did we go over end of line? */
	     old_tally = ctally;
	     ctally = max (0, tcb.colmax - oldcol);	/* move first chunk */
	     if ctally > 0
	     then call copy_chars;
	     call insert_nl ("1"b);			/* insert new-line and continuation marker */

	     ctally = old_tally - ctally;
	     oldcol = 2;
	     col = col + ctally;
	end;

	if ctally > 0				/* any more chars to copy? */
	then call copy_chars;			/* do it */
	wcol = col;				/* further white space will start here */

	return;

     end wrap_lines;


scan_white:
     proc (advanced);

/*
   This procedure is called when it is necessary to deside what to do with characters
   that only move the carriage's column position.  It then updates the appropriate
   pointers or white space counters
*/

dcl  advanced bit (1) parameter;			/* indicates whether pointer has been advanced over first white character */
dcl  done bit (1);
dcl  first_time bit (1);

	done = "0"b;
	first_time = "1"b;
	white_sw = "1"b;
	do while (util.stringl > 0 & ^done);
	     if stringp -> based_onechar = backspace
	     then wcol = max (0, wcol - 1);

	     else if stringp -> based_onechar = space
	     then wcol = wcol + 1;

	     else if stringp -> based_onechar = tab
	     then wcol = wcol + 10 - mod (wcol, 10);	/* to next tab stop */

	     else if stringp -> based_onechar = carriage_return
	     then wcol = 0;

	     else done = "1"b;

	     if ^done | (first_time & ^advanced)	/* in case first character wasn't really whitespace */
	     then do;				/* we want to advance pointer anyway */
		stringp = addr (stringp -> based_chars (1));
						/* bump stringp by one char */
		stringl = stringl - 1;
		first_time = "0"b;
	     end;
	end;
	return;

     end scan_white;

octal_escape:
     proc;

/*
   This procedure is called when a character is encountered that is meaningless
   to the device, so it is printed in the form of escapeXXX (i.e. \014)
*/
	if ^tcb.modes.edited
	then do;
	     if white_sw
	     then call insert_white;			/* insert any outstanding white space */
	     if ((tcb.colmax > 0) & (col >= tcb.colmax))	/* in case we went off end of line */
	     then call insert_nl ("1"b);

	     call insert_char (escape_char);		/* put escape in */
	     col = col + 1;

	     do i = 1 to 9 by 3;
		if ((tcb.colmax > 0) & (col >= tcb.colmax))
						/* if we go off end of line */
		then call insert_nl ("1"b);		/* put in nl and continuation marker */

		call insert_char (num_array (fixed (substr (unspec (stringp -> based_onechar), i, 3), 3)));
		col = col + 1;
	     end;
	end;

	stringp = addr (stringp -> based_chars (1));	/* bump over escaped character */
	stringl = stringl - 1;
     end octal_escape;

	end /* giant begin block */;

all_done:
	a_nelemt = nelemt;				/* return number of chars processed */

						/* Add for the Datanet 7100. */
	if uncp_flag then do;
	     if wtcb.send_turn
		then do;
		if ^wtcb.flags.wru			/* if not reading answerback  */
		     then if wtcb.receive_mode_device	/* must we tell multiplexer to turn line around? */
		     then do;
			call channel_manager$control (devx, "enter_receive", null, ercode);
						/* yes, do it */
			wtcb.send_turn = "0"b;
		     end;
		     else ;
		     else wtcb.flags.wru = "0"b;	/* won't be reading answerback again */
	     end;
	end;

unlock:
	time_spent = clock () - start_time;
	tcb.cumulative_meters.write_time = tcb.cumulative_meters.write_time + time_spent;
	tty_buf.write_time = tty_buf.write_time + time_spent;
	if ^locked_entry
	then call tty_lock$unlock_channel (devx);	/* unlock channel lock if necessary */

	return;

nothing_written:
	if wtcb.send_output
	then call tty_space_man$needs_space (devx);	/* make sure space happens anyway */
	else wtcb.wflag = "1"b;
	ercode = 0;
	go to all_done;				/* exit */

free_buffers:
     proc;

/* procedure to free any buffers we allocated but can't use */

	if headp ^= null				/* we'd peeled off a page */
	then do;					/* Add for the Datanet 7100. */
	     if uncp_flag then wtcb.send_turn = lastp -> buffer.turn;
	     call tty_space_man$free_chain (devx, OUTPUT, headp);
	end;
	if new_head ^= 0
	then call tty_space_man$free_chain (devx, OUTPUT, ptr (ttybp, new_head));

	wtcb.end_frame = old_end_frame;
	wtcb.write_first = old_head;			/* back to how we were when we came in */
	wtcb.write_last = old_tail;
	if wtcb.write_last ^= 0
	then ptr (ttybp, wtcb.write_last) -> buffer.next = 0;

	return;
     end /* free_buffers */;


is_parent_mpx:					/* Check for match of channel's parent mpx type and input mpx type */
     proc (parent_mpx_type) returns (bit (1));

dcl parent_mpx_type fixed bin;
dcl temp_lctep ptr;
     
	lctep = addr (lct.lcte_array (devx));
	if lcte.major_channel_devx ^= 0 then do;
	     temp_lctep = addr (lct.lcte_array (lcte.major_channel_devx));
	     if temp_lctep->lcte.channel_type = parent_mpx_type then return ("1"b);
	end;
	else if lcte.channel_type = parent_mpx_type then return ("1"b);
	return ("0"b);
     end is_parent_mpx;

     end /* tty_write */;
