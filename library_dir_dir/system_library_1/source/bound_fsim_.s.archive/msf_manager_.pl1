/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/* msf_manager_ manipulates multi-segment files.

   It uses file control blocks, created by the open entry.
   */


/****^  HISTORY COMMENTS:
  1) change(83-12-20,Margolin), approve(), audit(), install():
     pre-hcom comments:
     Initially coded May 1972 by Dan Bricklin.
     Modified July 1973 by E. Stone to work for both 64k and 256k MSFs
     to terminate MSFs completely, and to save the bitcount in the adjust entry
     
     Modified April 1974 by E. Stone to add the acl_delete and acl_add entries
     to remove the obsolete entries list_acl and replace_acl which depended on CACLS
     
     Modified by Kobziar on 7-10-74 to have the acl commands change the msf dir acl last
     
     Modified 9/6/75 by Steve Herbst to chase links and store link target in fcb
     
     Modified 6/21/77 by M. Asherman to call hcs_$initiate and initiate_count with
     proper setting of the copy_ctl_sw argument
     
     Modified 7/26/77 by M. Asherman to honor setting of safety_switch on msf
     by not deleting components on call to adjust entry in this case
     
     Modified 05/05/78 by C. D. Tavares to add AIM-upgraded MSF capability.
     error_table_$inconsistent_msf added and error codes reworked 09/10/79 S. Herbst
     Modified:
     06/08/82 by Lindsey Spratt:  Added new entrypoint, msf_get_ptr, which
                 guarantees the msf is always an MSF (i.e., even with only
                 component 0 there is a directory with one component named "0").
                 Changed to use the pathname_ function to build fcb.path.
     
     2/1/83 Jay Pattin to make ACL entries force access if necessary.
     6/23/83 Jay Pattin to fix bug in access forcing change
     Repaired to properly return acls for users with null effective access,
     BIM, 831010.
     12/20/83 by Matthew Pierret: Changed acl entries to always ensure that the MSF
            directory has an acl entry for *.*.* and that all MSF directory acl
            entries have modes no less than 's'.
  2) change(84-01-19,Pierret), approve(), audit(), install():
     Added substr around the (d e)name_arg args when
            assigning their values to fcb.(d e)name to avoid potential
            stringsize conditions.
     12/27/84 by Keith Loepere for version 2 create_branch_info.
  3) change(85-12-24,Margolin), approve(86-02-24,MCR7325),
     audit(86-06-19,Lippard), install(86-07-17,MR12.0-1097):
     Changed msf_manager_$adjust to truncate to the bit boundary instead of the
     word boundary.  Fixed some declarations.
  4) change(86-07-11,Margolin), approve(86-07-11,MCR7325),
     audit(86-07-11,GDixon), install(86-07-17,MR12.0-1097):
     Simplified code based upon new bit-boundary modifications of change (3).
  5) change(87-01-07,GWMay), approve(87-01-07,PBF7325), audit(87-01-09,GDixon),
     install(87-01-12,MR12.0-1268):
     added the subroutines "msf_initiate_file_" and "msf_terminate_file_" to
     provide to needed functions of the system subroutines "initiate_file_" and
     "terminate_file_".  The internal routines are needed because the system
     subroutines are located in the systems_standard_library and are not
     available at system reload time.  The subroutines cannot be moved to
     system_library_1 because they also reference >sss subroutines.
                                                   END HISTORY COMMENTS */


/* format: style2 */
msf_manager_:
     procedure;

/**** *
   NOTE: This program contains a partial fix for a problem. The problem was
   that the dir acl was is changed to match the msf acl.   Thus, when a user
   had null effective access to an MSF, she had null access to the msf
   dir, and could not list the acl of the first component.  

   This was fixed partially by changing the acl entries to never change the
   acl such that 's' mode is removed from any entry.  The remaining problem
   is that existing MSFs that have null access modes on the MSF dir are not
   helped by the change.

   This can be wrote around by using the acl of the dir itself to deduce
   the MSF acl. Unfortunately, there is no extended acl on the dir,
   so the extended modes are returned null.

    The complete fix is to run MSF's in ring 2, leaving s to * on the
    ring 2 dir, and thus allowing component zero's acl to be listed,
    always.

    This should be addresses at a later time. --BIM */


	dcl     aclp		 ptr;
	dcl     areap		 ptr;
	dcl     area_ret_ptr	 ptr;
	dcl     acl_idx		 fixed bin;
	dcl     bc		 fixed bin (24);
	dcl     bitcount		 fixed bin (24);
	dcl     cleanup		 condition;
	dcl     (code, code1)	 fixed bin (35);
	dcl     component		 fixed bin;
	dcl     createsw		 bit (1);
	dcl     force_msf_creation	 bit (1) aligned;
	dcl     forced_access	 bit (1) aligned;
	dcl     char		 builtin;
	dcl     changed		 bit (1);
	dcl     current_user	 char (32);
	dcl     cu_$level_get	 entry returns (fixed bin (3));
	dcl     cv_dec_check_	 entry (char (*), fixed bin (35)) returns (fixed bin (35));
	dcl     dac		 fixed bin;
	dcl     dap		 ptr init (null);
	dcl     delete		 fixed bin static init (2) options (constant);
	dcl     delete_$path	 entry (char (*), char (*), bit (6) aligned, char (*), fixed bin (35));
	dcl     delete_$ptr		 entry (ptr, bit (6) aligned, char (*), fixed bin (35));
	dcl     divide		 builtin;
	dcl     dname_arg		 char (*);
	dcl     ename_arg		 char (*);
	dcl     entry_name		 char (32);
	dcl     eptr		 ptr init (null);
	dcl     error_table_$badpath	 ext fixed bin (35);
	dcl     error_table_$badcall	 ext fixed bin (35);
	dcl     error_table_$dirseg	 ext fixed bin (35);
	dcl     error_table_$incorrect_access
				 fixed bin (35) ext static;
	dcl     error_table_$inconsistent_msf
				 ext fixed bin (35);
	dcl     error_table_$no_s_permission
				 ext fixed bin (35);
	dcl     error_table_$noentry	 ext fixed bin (35);
	dcl     error_table_$nomatch	 ext fixed bin (35);
	dcl     error_table_$not_seg_type
				 ext fixed bin (35);
	dcl     error_table_$safety_sw_on
				 ext fixed (35);
	dcl     fcbp		 ptr;
	dcl     free_area		 area based (get_system_free_area_ ());
	dcl     get_group_id_	 entry returns (char (32));
	dcl     get_group_id_$tag_star entry returns (char (32));
	dcl     get_system_free_area_	 entry () returns (ptr);
	dcl     hcs_$add_acl_entries	 entry (char (*), char (*), ptr, fixed bin, fixed bin (35));
	dcl     hcs_$add_dir_acl_entries
				 entry (char (*), char (*), ptr, fixed bin, fixed bin (35));
	dcl     hcs_$add_inacl_entries entry (char (*), char (*), ptr, fixed bin, fixed bin (3), fixed bin (35));
	dcl     hcs_$create_branch_	 entry (char (*), char (*), ptr, fixed bin (35));
	dcl     hcs_$delete_acl_entries
				 entry (char (*), char (*), ptr, fixed bin, fixed bin (35));
	dcl     hcs_$delete_dir_acl_entries
				 entry (char (*), char (*), ptr, fixed bin, fixed bin (35));
	dcl     hcs_$delete_inacl_entries
				 entry (char (*), char (*), ptr, fixed bin, fixed bin (3), fixed bin (35));
	dcl     hcs_$get_access_class	 ext entry (char (*), char (*), bit (72) aligned, fixed bin (35));
	dcl     hcs_$get_link_target	 entry (char (*), char (*), char (168), char (32), fixed bin (35));
	dcl     hcs_$get_max_length	 entry (char (*), char (*), fixed bin (19), fixed bin (35));
	dcl     hcs_$get_max_length_seg
				 entry (ptr, fixed bin (19), fixed bin (35));
	dcl     hcs_$get_ring_brackets entry (char (*), char (*), (3) fixed bin (3), fixed bin (35));
	dcl     hcs_$get_user_effmode	 entry (char (*), char (*), char (*), fixed bin, fixed bin (5), fixed bin (35));
	dcl     hcs_$initiate	 entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr,
				 fixed bin (35));
	dcl     hcs_$initiate_count	 entry (char (*), char (*), char (*), fixed bin (24), fixed bin (2), ptr,
				 fixed bin (35));
	dcl     hcs_$list_dir_acl	 entry (char (*), char (*), ptr, ptr, ptr, fixed bin, fixed bin (35));
	dcl     hcs_$list_acl	 entry (char (*), char (*), ptr, ptr, ptr, fixed bin, fixed bin (35));
	dcl     hcs_$make_seg	 entry (char (*), char (*), char (*), fixed bin, pointer, fixed bin (35));
	dcl     hcs_$replace_acl	 entry (char (*), char (*), ptr, fixed bin, bit (1), fixed bin (35));
	dcl     hcs_$replace_dir_acl	 entry (char (*), char (*), ptr, fixed bin, bit (1), fixed bin (35));
	dcl     hcs_$replace_inacl	 entry (char (*), char (*), ptr, fixed bin, bit (1), fixed bin (3),
				 fixed bin (35));
	dcl     hcs_$set_bc		 entry (char (*), char (*), fixed bin (24), fixed bin (35));
	dcl     hcs_$set_bc_seg	 entry (ptr, fixed bin (24), fixed bin (35));
	dcl     hcs_$set_max_length	 entry (char (*), char (*), fixed bin (19), fixed bin (35));
	dcl     hcs_$star_		 entry (char (*), char (*), fixed bin (2), ptr, fixed bin, ptr, ptr,
				 fixed bin (35));
	dcl     hcs_$status_minf	 entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24),
				 fixed bin (35));
	dcl     hcs_$terminate_file	 entry (char (*), char (*), fixed bin (1), fixed bin (35));
	dcl     hcs_$terminate_noname	 entry (ptr, fixed bin (35));
	dcl     hcs_$truncate_file	 entry (char (*), char (*), fixed bin, fixed bin (35));
	dcl     hcs_$truncate_seg	 entry (ptr, fixed bin, fixed bin (35));
	dcl     ltrim		 builtin;
	dcl     min		 builtin;
	dcl     mod		 builtin;
	dcl     pathname_		 entry (char (*), char (*)) returns (char (168));
	dcl     i			 fixed bin;
	dcl     index		 builtin;
	dcl     ibp		 ptr;
	dcl     j			 fixed bin;
	dcl     lastp		 ptr init (null);
	dcl     length		 builtin;
	dcl     make_msf_		 entry (char (*), char (*), (3) fixed bin (3), fixed bin (35));
	dcl     max		 builtin;
	dcl     max_length		 fixed bin (19);
	dcl     msf		 fixed bin static init (2) options (constant);
	dcl     name		 char (32);
	dcl     names		 (1000) char (32) based (nptr);
	dcl     not_exists		 fixed bin static init (-1) options (constant);
	dcl     nptr		 ptr init (null);
	dcl     null		 builtin;
	dcl     num_of_entries	 fixed bin;
	dcl     P_switches		 bit (3) parameter;
	dcl     ring		 fixed bin (3);
	dcl     scode		 fixed bin (35);
	dcl     saved_mode		 bit (36) aligned;
	dcl     segptr		 ptr;
	dcl     sds		 bit (1);
	dcl     set_bc_sw		 bit (1) def (switches) pos (1);
	dcl     ssf		 fixed bin static init (1) options (constant);
	dcl     STAR_STAR_USERID	 init ("*.*.*") char (32) aligned internal static options (constant);
	dcl     substr		 builtin;
	dcl     switches		 bit (3);
	dcl     sys_info$max_seg_size	 ext fixed bin (19);
	dcl     temp_acc		 bit (72) aligned;
	dcl     temp_segptr		 ptr;
	dcl     terminate		 fixed bin static init (1) options (constant);
	dcl     terminate_sw	 bit (1) def (switches) pos (3);
	dcl     truncate_sw		 bit (1) def (switches) pos (2);
	dcl     type		 fixed bin (2);
	dcl     (addr, unspec)	 builtin;
	dcl     unmake_msf_		 entry (char (*), char (*), bit (1), (3) fixed bin (3), fixed bin (35));

	dcl     1 s_acl		 (acl_count) based (aclp) aligned,
		2 userid		 char (32),
		2 mode		 bit (3) unaligned,
		2 mbz1		 bit (33) unaligned,
		2 mbz2		 bit (36),
		2 err_code	 fixed bin (35),
	        1 d_acl		 (dac) based (dap) aligned,
		2 userid		 char (32),
		2 mode		 bit (3) unaligned,
		2 mbz1		 bit (33) unaligned,
		2 err_code	 fixed bin (35),
	        1 d_acl_entry	 aligned like d_acl;
%page;

%include access_mode_values;
%include acl_structures;
%page;
%include create_branch_info;
%page;
%include terminate_file;
%page;
%include system_constants;
%page;
	dcl     1 branch_info	 aligned automatic like create_branch_info;

	dcl     1 entries		 (num_of_entries) based (eptr) aligned,
		2 type		 bit (2) unal,
		2 nname		 bit (16) unal,
		2 nindex		 fixed bin (17) unal;

	dcl     1 fcb		 based (fcbp) aligned,
						/* the multi-segment file control block */
		2 version		 fixed bin,	/* version of this structure - 0 now */
		2 type		 fixed bin,	/* form of msf - ssf, msf, or not_exists */
		2 max_components	 fixed bin,	/* maximum number of components (same as bitcount) */
		2 max_len		 fixed bin (19),	/* Max number of words in each component. */
		2 pad		 (1) fixed bin,
		2 pathnames	 unaligned,	/* dirnname, ename, and combined of the file */
		  3 dname		 char (168),
		  3 ename		 char (32),
		  3 path		 char (168),
		2 initiated_components,		/* information about the initiated components in the file */
		  3 number	 fixed bin,	/* how many are initiated */
		  3 highest_value	 fixed bin,	/* the highest component value of those inited */
		  3 listp		 ptr,		/* ptr to head of the list of inited segs */
		2 rbs		 (3) fixed bin (3), /* save ring bracks */
		2 upgrade_sw	 bit (1) aligned,	/* if components are multiclass segments */
		2 access_class	 bit (72) aligned;	/* acc if upgrade_sw ON */
						/* DRV - add volume backup switch to FCB here */

	dcl     1 initiation_bead	 based (ibp) aligned,
						/* one for each initiated component of the msf */
		2 component	 fixed bin,	/* which component it is */
		2 bitcount	 fixed bin (24),	/* its bitcount */
		2 segptr		 ptr,		/* a ptr to it */
		2 next		 ptr;		/* next bead in list or null */





/*  */
/* The open entry creates a file control block, returning a ptr.  It puts it in the area returned
   by get_system_free_area_.  The file need not exist to have a file control block. */


open:
     entry (dname_arg, ename_arg, fcbp, code);






	fcbp = null;				/* first set fcbp to null, in case of errors */


	allocate fcb in (free_area) set (fcbp);		/* allocate the file control block */

	fcb.version = 0;				/* set the version to the current version - 0 */
	fcb.dname = substr (dname_arg, 1, min (length (fcb.dname), length (dname_arg)));
	fcb.ename = substr (ename_arg, 1, min (length (fcb.ename), length (ename_arg)));
						/* substr is used to prevent potential stringsize */
	fcb.number = 0;				/* none are initiated */
	fcb.highest_value = 0;			/* so no highest value of those initiated */
	fcb.listp = null;				/* no list of those initiated */

	call hcs_$status_minf (fcb.dname, fcb.ename, 1, type, bitcount, code);
						/* find out about it */

	if code = 0 | code = error_table_$no_s_permission
	then do;
		if type < 1 | type > 2
		then go to BAD_MSF;
		fcb.type = type;			/* if no error, then type of msf is type */
		if code = 0
		then call hcs_$get_link_target (fcb.dname, fcb.ename, fcb.dname, fcb.ename, code1);
	     end;
	else do;					/* else if error, then not_exists */
		fcb.type = not_exists;
		fcb.max_len = sys_info$max_seg_size;	/* File will grow to largest allowed size. */
		fcb.rbs (*) = cu_$level_get ();
		fcb.upgrade_sw = ""b;

/* DRV - initialize volume backup switch in FCB here */

	     end;

/* concatenate the dname and ename to make a path name */

	fcb.path = pathname_ ((fcb.dname), (fcb.ename));

	if fcb.type = ssf
	then do;					/* If single segment file. */
		fcb.max_components = 1;		/* Only one component. */
		call hcs_$get_max_length (fcb.dname, fcb.ename, fcb.max_len, code);
		if code ^= 0
		then go to free_it;			/* Get max length of existing SSF. */

		call hcs_$get_access_class (fcb.dname, fcb.ename, fcb.access_class, code);
		if code ^= 0
		then goto free_it;

		call hcs_$get_access_class (fcb.dname, "", temp_acc, code);
		if code ^= 0
		then do;
			code = 0;
			fcb.upgrade_sw = "0"b;
		     end;
		else if fcb.access_class ^= temp_acc
		then fcb.upgrade_sw = "1"b;


/* DRV - get volume backup switch from SSF here and insert it into FCB */

	     end;

	else if fcb.type ^= msf
	then fcb.max_components = 0;			/* if not exists, then no components */

	else do;					/* is already an MSF */
		if bitcount = 0
		then do;				/* if type directory, and zero bc, then error */
			code = error_table_$dirseg;
free_it:
			free fcbp -> fcb in (free_area);
						/* free the file control block */
			return;
		     end;

		fcb.max_components = bitcount;	/* otherwise, get number of components from bitcount */

		call hcs_$get_ring_brackets (fcb.path, "0", fcb.rbs, code);
						/* get ring brackets of component 0 */
		if code ^= 0
		then fcb.rbs (*) = cu_$level_get ();

		call hcs_$get_max_length (fcb.path, "0", fcb.max_len, code);
						/* Get max length of component 0. */
		if code ^= 0
		then fcb.max_len = sys_info$max_seg_size;

		call hcs_$get_access_class (fcb.path, "0", fcb.access_class, code);
		if code ^= 0
		then fcb.upgrade_sw = ""b;

		else do;
			call hcs_$get_access_class (fcb.path, "", temp_acc, code);
			if code ^= 0
			then fcb.upgrade_sw = ""b;
			else if temp_acc ^= fcb.access_class
			then fcb.upgrade_sw = "1"b;
		     end;

/* DRV - get volume backup switch from component 0 here */

		code = 0;

	     end;

	return;					/* return to caller */


/* The msf_get_ptr entry works like the get_ptr entry (below) except it
forces the creation of an MSF, even if only component 0 is referenced.  If the
file already exists as an SSF, however, it won't be converted as long as only
component 0 is referenced.  */

msf_get_ptr:
     entry (fcbp, component, createsw, segptr, bc, code);
	force_msf_creation = "1"b;
	goto GET_PTR_JOIN;

/* The get_ptr entry will return a ptr to the specified component in the
file.  If not found, it will attempt to create it if createsw = "1"b.  If the
file is a single_segment_file (SSF), and a component greater than zero is
requested, this entry will call make_msf_ to change the file from an SSF to an
MSF.  */

get_ptr:
     entry (fcbp, component, createsw, segptr, bc, code);

	force_msf_creation = "0"b;
GET_PTR_JOIN:
	code = 0;
	segptr = null;				/* start with a null return pointer */

	if component < 0
	then go to BAD_ARG;				/* make a check on the request */

	if fcb.type = not_exists
	then /* if the file did not previously exist then */
	     if ^createsw
	     then go to NOT_FOUND;			/* if the callers does not want it created, error */
	     else do;
		     if ^force_msf_creation
		     then do;
			     call hcs_$make_seg (dname, ename, "", 01010b, segptr, code);
						/* otherwise, create a segment */
			     if segptr = null
			     then return;		/* if unable, then error */

			     call hcs_$get_link_target (dname, ename, fcb.dname, fcb.ename, code);
						/* store target in fcb */
			     if code ^= 0
			     then return;
			     i = index (fcb.dname, " ");
			     if i = 0
			     then if fcb.ename = ""
				then fcb.path = fcb.dname;
				else go to BAD_PATH;
			     else fcb.path = substr (fcb.dname, 1, i - 1) || ">" || fcb.ename;
			     bc = 0;		/* bitcount starts at zero */
			     fcb.type = ssf;	/* starts as an ssf */
			     fcb.max_components = 1;	/* with only one component */
			     if component = 0
			     then go to fill_in_bead; /* if caller only wants comp. zero, then almost done */
			end;
		     call make_msf_ (dname, ename, fcb.rbs, code);
						/* otherwise, change it to an msf */
		     if code ^= 0
		     then return;			/* error */
		     fcb.type = msf;		/* now it is an msf */
		     call delete_$path (path, "0", "100100"b, "", code);
						/* delete the zero component */
		     if code ^= 0
		     then return;
		     fcb.max_components = 0;		/* none inited now */
		     go to make_seg_msf;		/* now pretend that we started with an msf */
		end;

	if fcb.type = ssf
	then do;					/* if it was an ssf */
		if component ^= 0
		then /* if caller wants other than comp. zero */
		     if createsw
		     then do;			/* and wants it to be created then */
			     call make_msf_ (dname, ename, fcb.rbs, code);
						/* change to an msf */
			     if code ^= 0
			     then return;
			     fcb.type = msf;
			     go to make_seg_msf;	/* and pretend we started that way */
			end;
		     else go to NOT_FOUND;		/* else, if not to be created, error */

		if initiated_components.number = 1
		then do;				/* if a component has already been inited */
			ibp = fcb.listp;		/* only can be one - component zero, what we want */
already_initiated:
			bc = initiation_bead.bitcount;/* we have the bitcount saved from an init call */
			segptr = initiation_bead.segptr;
						/* and the ptr saved */
			return;			/* that's it, finished */
		     end;

		else do;				/* else, if not already inited */
			call hcs_$initiate_count (dname, ename, "", bc, 1, segptr, code);
						/* try to initiated it */
			if segptr = null
			then return;		/* error */
			go to fill_in_bead;		/* make an initiation bead */
		     end;

	     end;


	if fcb.type ^= msf
	then go to BAD_CONTROL_BLOCK;			/* bad type field in fcb */

	ibp = find_component (component);		/* see if comp. already was initiated */
	if ibp ^= null
	then go to already_initiated;			/* if so, return the old values */

not_initiated:
	call hcs_$initiate_count (path, make_char (component), "", bc, 1, segptr, code);
						/* else try to initiate it */

	if segptr ^= null
	then go to fill_in_bead;			/* ok, so make an initiation bead */

	if ^createsw
	then return;				/* if not to create it, then give up */
make_seg_msf:
	current_user = get_group_id_$tag_star ();
	entry_name = make_char (component);

	unspec (branch_info) = ""b;

	branch_info.version = create_branch_version_2;
	branch_info.chase_sw = ""b;
	branch_info.priv_upgrade_sw = fcb.upgrade_sw;
	branch_info.parent_ac_sw = ^branch_info.priv_upgrade_sw;
	branch_info.access_class = fcb.access_class;
	branch_info.mode = "101"b;
	branch_info.rings = fcb.rbs;
	branch_info.userid = current_user;

	call hcs_$create_branch_ (path, entry_name, addr (branch_info), code);
	if code ^= 0
	then return;

	call hcs_$set_max_length (path, entry_name, fcb.max_len, code);
	if code ^= 0
	then return;

/* DRV - set volume backup switch on new seg here */

	call hcs_$initiate (path, entry_name, "", 0, 1, segptr, code);
	if segptr = null
	then return;				/* if failed, then give up */

	bc = 0;					/* bitcount starts at zero */
	if component + 1 > fcb.max_components
	then do;					/* if max_components needs to be upped */
		fcb.max_components = component + 1;
		call hcs_$set_bc (dname, ename, component + 1, code);
		if code ^= 0
		then return;
	     end;

fill_in_bead:
	allocate initiation_bead in (free_area) set (ibp);/* make an initiation bead */

	initiation_bead.component = component;		/* fill it in */
	initiation_bead.bitcount = bc;
	initiation_bead.segptr = segptr;
	initiation_bead.next = fcb.listp;		/* thread this at the head of the list */
						/* open initializes first fcb.listp to null */

	if component >= fcb.max_components
	then fcb.max_components = component + 1;
	fcb.highest_value = max (fcb.highest_value, component);
						/* remember highest value */
	fcb.listp = ibp;				/* thread into list */
	fcb.number = fcb.number + 1;

	code = 0;

	return;					/* thats it */

/* The adjust entry can set the bitcount, truncate, and terminate the components of an MSF.  It
   is given a maximum component, and bitcount within that component.  All components before
   that component are given bitcount sys_info$max_seg_size, and all after are deleted.
   What it is to do is determined by switches: "bxt"b, where b is set bitcount,
   x is truncate, and t is terminate. */


adjust:
     entry (fcbp, component, bc, P_switches, code);






	switches = P_switches;

	if component < 0
	then go to BAD_ARG;				/* check argument */

	if fcb.type = not_exists
	then go to NOT_FOUND;			/* see if file is around */

	if fcb.type = ssf
	then do;					/* if only a single segment */
		if component ^= 0
		then go to SEGMENT;			/* can't adjust to that length (>0) */
		ibp = find_component (0);		/* see if it was initiated */
adjust_ssf:
		if truncate_sw & (mod (bc, 36) ^= 0)
		then if ibp = null
		     then begin;			/* have to zero extra bits */
			     temp_segptr = null;
			     on cleanup
				begin;
				     if temp_segptr ^= null
				     then call msf_terminate_file_ (temp_segptr, 0, TERM_FILE_TERM, (0));
				end;

			     call msf_initiate_file_ (dname, ename, W_ACCESS, temp_segptr, (0), code);
			     if code ^= 0
			     then return;
			     if set_bc_sw
			     then do;
				     call msf_terminate_file_ (temp_segptr, bc, TERM_FILE_TRUNC_BC_TERM, code);
				     set_bc_sw = "0"b;
				end;
			     else call msf_terminate_file_ (temp_segptr, bc, (TERM_FILE_TRUNC | TERM_FILE_TERM),
				     code);
			     if code ^= 0
			     then return;
			     truncate_sw = "0"b;
			end;
		     else do;
			     if set_bc_sw
			     then do;
				     call msf_terminate_file_ (initiation_bead.segptr, bc, TERM_FILE_TRUNC_BC,
					code);
				     initiation_bead.bitcount = bc;
				     set_bc_sw = "0"b;
				end;
			     else call msf_terminate_file_ (initiation_bead.segptr, bc, TERM_FILE_TRUNC, code);
			     if code ^= 0
			     then return;
			     truncate_sw = "0"b;
			end;


		if set_bc_sw
		then do;				/* if we are to set the bitcount */
			if ibp = null
			then call hcs_$set_bc (dname, ename, bc, code);
						/* use normal entry if no pointer to set bc */
			else call hcs_$set_bc_seg (initiation_bead.segptr, bc, code);
						/* else use faster ptr entry if we have it */
			if code ^= 0
			then return;
			if ibp ^= null
			then initiation_bead.bitcount = bc;
		     end;

		if truncate_sw
		then do;				/* shall we truncate it? */
			if ibp = null
			then call hcs_$truncate_file (dname, ename, divide (bc, 36, 17, 0), code);
						/* use the truncate entries */
			else call hcs_$truncate_seg (initiation_bead.segptr, divide (bc, 36, 17, 0), code);
			if code ^= 0
			then return;
		     end;

		if terminate_sw
		then do;				/* shall we terminate it */
			if ibp = null
			then call hcs_$terminate_file (dname, ename, 0, code);
			else call remove_bead (terminate);
						/* remove the initiation bead while terming it */
			code = 0;			/* set code to 0 */
		     end;

		return;

	     end;

	if fcb.type ^= msf
	then go to BAD_CONTROL_BLOCK;			/* not msf */

	if component = 0
	then do;					/* it msf, and want to end up with ssf */
		lastp = null;			/* terminate and remove beads of all ^=0 */
		ibp = fcb.listp;
		do i = 1 to fcb.number while (ibp ^= null);
		     if initiation_bead.component ^= 0
		     then call remove_bead (terminate);
		     else lastp = ibp;
		     if lastp = null
		     then ibp = fcb.listp;
		     else ibp = lastp -> initiation_bead.next;
		end;
		if fcb.listp = null
		then fcb.number = 0;		/* if none left (0 not inited) */
		else fcb.number = 1;		/* if zero was initied */
		call unmake_msf_ (dname, ename, (bc ^= 0), fcb.rbs, code);
						/* make an ssf, copy only if bc>0 */
		if code ^= 0
		then if code ^= error_table_$safety_sw_on
						/* real error */
		     then return;			/* abort */
		     else go to adjust_loop;		/* still zero contents */
		fcb.type = ssf;
		fcb.max_components = 1;
		go to adjust_ssf;			/* pretend we are an ssf */
	     end;

	if component > fcb.max_components
	then go to BAD_ARG;				/* component too high */

adjust_loop:
	forced_access = "0"b;
	on cleanup call free_allocated_storage;		/* in case we are quitted out of, cleanup area */

	call hcs_$star_ (path, "**", 2, get_system_free_area_ (), num_of_entries, eptr, nptr, code);
						/* find all the names(i.e. components) */
	if code ^= 0
	then go to finished_adjust;			/* error */

	do i = 1 to num_of_entries;			/* do for each entry */
	     name = names (entries (i).nindex);		/* find the i-th name */
	     j = cv_dec_check_ (name, code);		/* see that it is a number */
	     if code ^= 0
	     then go to BAD_MSF;
	     if j < 0
	     then go to BAD_MSF;			/* check that it is ok */

	     ibp = find_component (j);		/* see if we perchance have a ptr to it */

	     if j = component
	     then /* if the adjusting component */
		if truncate_sw
		then do;				/* shall we truncate that one? */
			if mod (bc, 36) = 0
			then do;
				if ibp = null
				then call hcs_$truncate_file (path, name, divide (bc, 36, 17, 0), code);
				else call hcs_$truncate_seg (initiation_bead.segptr, divide (bc, 36, 17, 0), code);
				if code ^= 0
				then go to finished_adjust;
			     end;
			else if ibp = null
			then begin;		/* have to initiate it to zero the bits */
				temp_segptr = null;
				on cleanup
				     begin;
					if temp_segptr ^= null
					then call msf_terminate_file_ (temp_segptr, 0, TERM_FILE_TERM, (0));
				     end;

				call msf_initiate_file_ (path, name, W_ACCESS, temp_segptr, (0), code);
				if code ^= 0
				then go to finished_adjust;
				if set_bc_sw
				then call msf_terminate_file_ (temp_segptr, bc, TERM_FILE_TRUNC_BC_TERM, code);
				else call msf_terminate_file_ (temp_segptr, bc,
					(TERM_FILE_TRUNC | TERM_FILE_TERM), code);
				if code ^= 0
				then go to finished_adjust;
			     end;
			else do;
				if set_bc_sw
				then call msf_terminate_file_ (initiation_bead.segptr, bc, TERM_FILE_TRUNC_BC,
					code);
				else call msf_terminate_file_ (initiation_bead.segptr, bc, TERM_FILE_TRUNC, code);
				if code ^= 0
				then go to finished_adjust;
			     end;


		     end;

	     if j <= component
	     then do;				/* up to and including adjusting comp */
		     if set_bc_sw
		     then do;			/* shall we set the bitcount? */
			     if j = component
			     then bitcount = bc;	/* adjusting - do to "bc" */
			     else do;		/* else an entire file's worth */
				     if ibp = null
				     then call hcs_$get_max_length (path, name, max_length, code);
				     else call hcs_$get_max_length_seg (initiation_bead.segptr, max_length, code);
				     if code ^= 0
				     then go to finished_adjust;
				     bitcount = 36 * max_length;
				end;
			     if ^(truncate_sw & (j = component) & (mod (bc, 36) ^= 0))
						/** truncate_sw processing handles last
				    component in this case **/
			     then do;
				     if ibp = null
				     then call hcs_$set_bc (path, name, bitcount, code);
						/* set the bitcount */
				     else call hcs_$set_bc_seg (initiation_bead.segptr, bitcount, code);
				     if code ^= 0
				     then go to finished_adjust;
				end;
			     if ibp ^= null
			     then initiation_bead.bitcount = bitcount;
			end;

		     if terminate_sw
		     then do;			/* shall we terminate it? */
			     if ibp = null
			     then call hcs_$terminate_file (path, name, 0, code);
			     else call remove_bead (terminate);
						/* remove initiation bead while terming */
			     code = 0;		/* set code to 0 */
			end;
		end;

	     else do;				/* components after the adjusting one */
		     if ibp = null
		     then call delete_$path (path, name, "000100"b, "", code);
						/* delete it */
		     else do;
			     call remove_bead (delete);
			     code = scode;
			end;
		     if code ^= 0
		     then if code = error_table_$safety_sw_on
			then do;			/* still zero contents */
				call hcs_$truncate_file (path, name, 0, code);
				if code ^= 0
				then go to finished_adjust;
						/* abort */
				call hcs_$set_bc (path, name, 0, code);
				if code ^= 0
				then go to finished_adjust;
				else code = error_table_$safety_sw_on;
						/*
						   prevents resetting max_components */
			     end;
			else go to finished_adjust;
		end;

	end;

	if (code = 0) & (component + 1 ^= fcb.max_components)
	then do;					/* have to reset the max_components */
		fcb.max_components = component + 1;
		call hcs_$set_bc (dname, ename, component + 1, code);
	     end;

finished_adjust:
	if code ^= 0
	then if code = error_table_$safety_sw_on	/* not an error to user */
	     then code = 0;
	call free_allocated_storage;			/* clean up */

	return;

/* The close entry frees the file control block.  It will terminate all components that are still
   thought to be initiaed, freeing their initiation beads. */


close:
     entry (fcbp);




	lastp = null;
	ibp = fcb.listp;

	do i = 1 to fcb.number + 1 while (ibp ^= null);
	     call remove_bead (terminate);
	     ibp = fcb.listp;
	end;

	free fcbp -> fcb in (free_area);

	return;

/* The acl_list entry returns the acl on the MSF */


acl_list:						/* entry for listing acls */
     entry (fcbp, areap, area_ret_ptr, aclp, acl_count, code);


	if fcb.type = msf
	then do;

		eptr, nptr, dap = null;
		forced_access = "0"b;

		on cleanup call free_allocated_storage ();
						/* in case we are quitted out of, cleanup area */
		call ensure_access ("1"b);

		ring = cu_$level_get ();		/* get validation level */
		call hcs_$list_acl (path, "0", areap, area_ret_ptr, aclp, acl_count, code);
		if code = error_table_$incorrect_access
		then call DEDUCE_ACL_FROM_DIR_ACL;
		if code = error_table_$noentry | code = error_table_$dirseg
		then code = error_table_$inconsistent_msf;

		call free_allocated_storage ();
	     end;

	else if fcb.type = ssf
	then call hcs_$list_acl (dname, ename, areap, area_ret_ptr, aclp, acl_count, code);

	else go to BAD_CONTROL_BLOCK;

	return;

/* The acl_delete entry deletes the acl on an MSF */


acl_delete:					/* entry for deleting acls */
     entry (fcbp, aclp, acl_count, code);



	if fcb.type = not_exists
	then go to NOT_FOUND;			/* dumb move */

	if fcb.type = ssf
	then do;					/* one segment simple case */
		call hcs_$delete_acl_entries (dname, ename, aclp, acl_count, code);
						/* do it */
		return;
	     end;

	if fcb.type ^= msf
	then go to BAD_CONTROL_BLOCK;

	eptr, nptr, dap = null;
	forced_access = "0"b;

	on cleanup call free_allocated_storage;		/* in case we are quitted out of, cleanup area */
	call ensure_access ("0"b);

	ring = cu_$level_get ();			/* get current level */
	call hcs_$delete_inacl_entries (dname, ename, aclp, acl_count, ring, code);
						/* remove entries from inacl */
	if code ^= 0
	then go to error_return;


	call hcs_$star_ (path, "**", 3, get_system_free_area_ (), num_of_entries, eptr, nptr, code);
						/* get all names */
	if code ^= 0
	then if code = error_table_$nomatch
	     then go to DEL_DIR;
	     else go to error_return;

	do i = 1 to num_of_entries;			/* go through list */
	     call hcs_$delete_acl_entries (path, names (entries (i).nindex), aclp, acl_count, code);
	     if code ^= 0
	     then do;
INCONSISTENT:
		     code = error_table_$inconsistent_msf;
		     go to error_return;
		end;
	end;


	call free_allocated_storage;

DEL_DIR:						/* delete the directory acl entries on the msf directory */
	call hcs_$delete_dir_acl_entries (dname, ename, aclp, acl_count, code);
						/* remove entries from dir acl */
	if code ^= 0
	then go to error_return;

/* the *.*.* entry should not be removed from the directory acl */
/* see if that entry is included in the segment acl */
	do acl_idx = 1 to acl_count while (s_acl (acl_idx).userid ^= STAR_STAR_USERID);
	end;
	if acl_idx <= acl_count
	then do;					/* the *.*.* entry was deleted - return it */
		d_acl_entry.userid = STAR_STAR_USERID;
		d_acl_entry.mode = S_ACCESS;
		d_acl_entry.mbz1 = "0"b;
		d_acl_entry.err_code = 0;

		call hcs_$add_dir_acl_entries (dname, ename, addr (d_acl_entry), 1 /* acl count */, code);
						/* add the directory acl entry for *.*.* */
		if code ^= 0
		then go to error_return;
	     end;

	return;

/* The acl_add entry adds the acl on an MSF */


acl_add:						/* entry for adding acls */
     entry (fcbp, aclp, acl_count, code);


	if fcb.type = not_exists
	then go to NOT_FOUND;			/* dumb move */

	if fcb.type = ssf
	then do;					/* one segment simple case */
		call hcs_$add_acl_entries (dname, ename, aclp, acl_count, code);
						/* do it */
		return;
	     end;

	if fcb.type ^= msf
	then go to BAD_CONTROL_BLOCK;

	eptr, nptr, dap = null;
	forced_access = "0"b;

	on cleanup call free_allocated_storage;		/* in case we are quitted out of, cleanup area */
	call ensure_access ("0"b);

	ring = cu_$level_get ();			/* get current level */
	call hcs_$add_inacl_entries (dname, ename, aclp, acl_count, ring, code);
						/* add entries to inacl */
	if code ^= 0
	then go to error_return;

	call hcs_$star_ (path, "**", 3, get_system_free_area_ (), num_of_entries, eptr, nptr, code);
						/* get all names */
	if code ^= 0
	then if code = error_table_$nomatch
	     then go to ADD_DIR;
	     else go to error_return;

	do i = 1 to num_of_entries;			/* go through list */
	     call hcs_$add_acl_entries (path, names (entries (i).nindex), aclp, acl_count, code);
	     if code ^= 0
	     then go to INCONSISTENT;
	end;

ADD_DIR:						/* add the directory acl on the msf directory */
	dac = acl_count;				/* the directory and segment acl's have the same number of entries */

	call GET_DIR_ACL;				/* get structure for directory acls */

	call hcs_$add_dir_acl_entries (dname, ename, dap, dac, code);
						/* add entries to dir acl */
	if code ^= 0
	then go to error_return;


	call free_allocated_storage;

	return;

/* The acl_replace entry replaces the acl on an MSF */


acl_replace:					/* entry for replacing acls */
     entry (fcbp, aclp, acl_count, sds, code);




	if fcb.type = not_exists
	then go to NOT_FOUND;			/* dumb move */

	if fcb.type = ssf
	then do;					/* one segment simple case */
		call hcs_$replace_acl (dname, ename, aclp, acl_count, sds, code);
						/* do it */
		return;
	     end;

	if fcb.type ^= msf
	then go to BAD_CONTROL_BLOCK;

	eptr, nptr, dap = null;
	forced_access = "0"b;

	on cleanup call free_allocated_storage;		/* in case we are quitted out of, cleanup area */
	call ensure_access ("0"b);

	ring = cu_$level_get ();			/* get current level */
	call hcs_$replace_inacl (dname, ename, aclp, acl_count, sds, ring, code);
						/* put new acl on inacl */
	if code ^= 0
	then go to error_return;

	call hcs_$star_ (path, "**", 3, get_system_free_area_ (), num_of_entries, eptr, nptr, code);
						/* get all names */
	if code ^= 0
	then if code = error_table_$nomatch
	     then go to RPL_DIR;
	     else go to error_return;

	do i = 1 to num_of_entries;			/* go through list */
	     call hcs_$replace_acl (path, names (entries (i).nindex), aclp, acl_count, sds, code);
	     if code ^= 0
	     then go to INCONSISTENT;
	end;

RPL_DIR:						/* replace the directory acl on the msf directory */
						/* is there an entry for *.*.* in the given acl? */
	do acl_idx = 1 to acl_count while (s_acl (acl_idx).userid ^= STAR_STAR_USERID);
	end;
	if acl_idx <= acl_count
	then dac = acl_count;			/* a *.*.* entry is in the segment acl */
	else dac = acl_count + 1;			/* no *.*.* entry is in the segment acl - the directory acl needs an extra entry */

	call GET_DIR_ACL;				/* allocate a directory acl (d_acl) and convert the segment acl */
						/* entries into directory acl entries */

	if dac > acl_count
	then do;					/* add an entry for *.*.* */
		d_acl (dac).userid = STAR_STAR_USERID;
		d_acl (dac).mode = S_ACCESS;
		d_acl (dac).mbz1 = "0"b;
		d_acl (dac).err_code = 0;
	     end;


	call hcs_$replace_dir_acl (dname, ename, dap, dac, sds, code);
						/* put on dir acl */


error_return:
	call free_allocated_storage;

	return;

/* I N T E R N A L   P R O C E D U R E S */


find_component:					/* sees if initiation bead exists for which */
     proc (which) returns (ptr);


	dcl     ip		 ptr,
	        which		 fixed bin;






	if fcb.highest_value < component
	then return (null);				/* greater than highest value inited, so not there */

	ip = fcb.listp;				/* start at begining of list */
	lastp = null;

	do while (ip ^= null);			/* look through whole list */
	     if ip -> initiation_bead.component = which
	     then return (ip);			/* if comp "which", then return ptr to bead */
	     lastp = ip;				/* lastp points to last bead */
	     ip = ip -> initiation_bead.next;		/* now look for next */
	end;

	return (null);				/* not found */

     end find_component;


remove_bead:					/* remove an initiation bead */
     proc (how);					/* how says to delete or terminate */



	dcl     how		 fixed bin;



	if how = terminate
	then call hcs_$terminate_noname (initiation_bead.segptr, scode);
						/* if terminate,then do it */
	else if how = delete
	then call delete_$ptr (initiation_bead.segptr, "000100"b, "", scode);
						/* else if delete,then delete it */

	if lastp = null
	then fcb.listp = ibp -> initiation_bead.next;	/* if no bead before it in list */
	else lastp -> initiation_bead.next = ibp -> initiation_bead.next;
						/* else fill in bead before it, to unthread */

	fcb.number = fcb.number - 1;			/* decrement number inited */

	free ibp -> initiation_bead in (free_area);	/* free the initiation bead */

	return;					/* that's it for this routine */

     end remove_bead;
%page;
GET_DIR_ACL:					/* transform segment acls to directory acls */
     proc;					/* for adding or replacing the acl of the MSF itself */
						/* 'dac' must be set to the number of directory acl entries */

	dcl     acl_idx		 fixed bin;



	allocate d_acl in (free_area) set (dap);

	do acl_idx = 1 to acl_count;			/* copy segment acl to directory acl */
	     d_acl (acl_idx).userid = s_acl (acl_idx).userid;
						/* copy user name */
	     if (s_acl (acl_idx).mode & W_ACCESS) = ""b
	     then d_acl (acl_idx).mode = S_ACCESS;	/* all dir entries must have at least 's' */
	     else d_acl (acl_idx).mode = SMA_ACCESS;	/* 'w' on msf requires 'sma' on dir */

	     d_acl (acl_idx).mbz1 = "0"b;
	     d_acl (acl_idx).err_code = 0;
	end;

     end GET_DIR_ACL;
%page;
ensure_access:
     proc (list_switch);

	declare list_switch		 bit (1) aligned,
	        mode		 fixed bin (5),
	        1 one_acl		 aligned,
		2 name		 char (32),
		2 mode		 bit (36),
		2 code		 fixed bin (35);

	call hcs_$get_user_effmode (dname, ename, "", -1, mode, code);
	if code ^= 0
	then return;				/* let actual acl error be reported */

	if mode >= SM_ACCESS_BIN
	then return;				/* have sufficient access */

	one_acl.name = get_group_id_ ();
	call hcs_$list_dir_acl (dname, ename, null (), null (), addr (one_acl), 1, (0));
	changed = (one_acl.code = 0);
	saved_mode = one_acl.mode;

	one_acl.mode = SMA_ACCESS;
	forced_access = "1"b;

	call hcs_$add_dir_acl_entries (dname, ename, addr (one_acl), 1, (0));

	if ^list_switch
	then do i = 1 to acl_count;			/* if we are going to frob it, don't put it back */
		if s_acl.userid (i) = one_acl.name
		then do;
			forced_access = "0"b;
			return;
		     end;
	     end;

	return;
     end ensure_access;


remove_access:
     proc ();

	declare 1 delete_acl	 aligned,
		2 name		 char (32),
		2 code		 fixed bin (35),
	        1 one_acl		 aligned,
		2 name		 char (32),
		2 mode		 bit (36),
		2 code		 fixed bin (35);

	if changed
	then do;
		one_acl.name = get_group_id_ ();
		one_acl.mode = saved_mode;

		call hcs_$add_dir_acl_entries (dname, ename, addr (one_acl), 1, (0));
	     end;
	else do;
		delete_acl.name = get_group_id_ ();
		call hcs_$delete_dir_acl_entries (dname, ename, addr (delete_acl), 1, (0));
	     end;

	return;
     end remove_access;
%page;
free_allocated_storage:				/* clean up routine */
     proc;

	if forced_access
	then call remove_access ();

	if nptr ^= null
	then free names in (free_area);

	if eptr ^= null
	then free entries in (free_area);

	if dap ^= null
	then free dap -> d_acl in (free_area);

	return;

     end free_allocated_storage;			/**/
make_char:
     proc (c_number) returns (char (32));

/* change a number into a char(32) string */


	dcl     c_number		 fixed bin;


	return (ltrim (char (c_number)));

     end make_char;





/*  */
/* Error reporting statements */


BAD_ARG:
BAD_CONTROL_BLOCK:
	code = error_table_$badcall;
	return;

BAD_MSF:
	code = error_table_$inconsistent_msf;
	return;

BAD_PATH:
	code = error_table_$badpath;
	return;

NOT_FOUND:
	code = error_table_$noentry;
	return;

SEGMENT:
	code = error_table_$not_seg_type;
	return;

msf_initiate_file_:
     procedure (P_dirname, P_entryname, P_mode, P_seg_ptr, P_bit_count, P_code);


/* parameters */

	declare P_bit_count		 fixed binary (24);
	declare P_code		 fixed binary (35);
	declare P_dirname		 char (*);
	declare P_entryname		 char (*);
	declare P_mode		 bit (*);
	declare P_seg_ptr		 pointer;

/* automatic */

	declare bit_count		 fixed binary (24);
	declare code		 fixed binary (35);
	declare 1 effective_mode,
		2 pad1		 bit (1),
		2 read		 bit (1),
		2 execute		 bit (1),
		2 write		 bit (1),
		2 pad2		 bit (1);
	declare effective_mode_bin	 fixed binary (5);
	declare 1 required_mode,
		2 read		 bit (1),
		2 execute		 bit (1),
		2 write		 bit (1);

/* builtin */

	declare (bit, null, string)	 builtin;

/* external static */

	declare error_table_$no_e_permission
				 fixed binary (35) external static;
	declare error_table_$no_r_permission
				 fixed binary (35) external static;
	declare error_table_$no_w_permission
				 fixed binary (35) external static;

	declare hcs_$fs_get_mode	 entry (pointer, fixed binary (5), fixed binary (35));
	declare hcs_$initiate_count	 entry (char (*), char (*), char (*), fixed binary (24), fixed binary (2),
				 pointer, fixed binary (35));

	string (required_mode) = P_mode;
	P_seg_ptr = null;
	P_bit_count = 0;
	P_code = 0;

	call hcs_$initiate_count (P_dirname, P_entryname, "", bit_count, 0, P_seg_ptr, code);

	if P_seg_ptr = null
	then return;

	call hcs_$fs_get_mode (P_seg_ptr, effective_mode_bin, code);
	if code = 0
	then do;
		string (effective_mode) = bit (effective_mode_bin);

		if required_mode.read & ^effective_mode.read
		then code = error_table_$no_r_permission;

		else if required_mode.write & ^effective_mode.write
		then code = error_table_$no_w_permission;

		else if required_mode.execute & ^effective_mode.execute
		then code = error_table_$no_e_permission;
	     end;

	if code ^= 0
	then do;
		call msf_terminate_file_ (P_seg_ptr, 0, TERM_FILE_TERM, 0);
		P_code = code;
		P_bit_count = 0;
	     end;
	else P_bit_count = bit_count;

	return;

     end msf_initiate_file_;
%page;
msf_terminate_file_:
     procedure (P_seg_ptr, P_bit_count, P_switches, P_code);

	declare P_seg_ptr		 pointer;
	declare P_bit_count		 fixed binary (24);
	declare P_switches		 bit (*);
	declare P_code		 fixed binary (35);

/* automatic */

	declare bit_count		 fixed binary (24);
	declare code		 fixed binary (35);
	declare 1 tfs		 aligned like terminate_file_switches;

/* based */

	declare segment		 bit (BITS_PER_SEGMENT) based;

/* builtin */

	declare (divide, mod, null, pointer, string, substr)
				 builtin;

/* entry */

	declare hcs_$set_bc_seg	 entry (pointer, fixed binary (24), fixed binary (35));
	declare hcs_$terminate_noname	 entry (pointer, fixed binary (35));
	declare hcs_$truncate_seg	 entry (pointer, fixed binary (19), fixed binary (35));


	P_code = 0;
	bit_count = P_bit_count;
	string (tfs) = P_switches;

	if P_seg_ptr = null
	then return;

	P_seg_ptr = pointer (P_seg_ptr, 0);


	if tfs.truncate
	then do;
		substr (P_seg_ptr -> segment, bit_count + 1, mod (-bit_count, 36)) = ""b;
		call hcs_$truncate_seg (P_seg_ptr, divide (bit_count + 35, 36, 19), code);
		if code ^= 0
		then P_code = code;
	     end;

	if tfs.set_bc
	then do;
		call hcs_$set_bc_seg (P_seg_ptr, bit_count, code);
		if code ^= 0 & P_code = 0
		then P_code = code;
	     end;

	if tfs.terminate
	then do;
		call hcs_$terminate_noname (P_seg_ptr, code);
		if code ^= 0 & P_code = 0
		then P_code = code;
		P_seg_ptr = null;
	     end;

     end msf_terminate_file_;
%page;
DEDUCE_ACL_FROM_DIR_ACL:
     procedure;


	declare 1 dracl		 (dracl_count) aligned like directory_acl_entry based (dracl_ptr);
	declare dracl_ptr		 pointer;
	declare dracl_count		 fixed bin;
	declare ax		 fixed bin;

	code = 0;
	dracl_ptr = null ();
	on cleanup
	     begin;
		if dracl_ptr ^= null
		then do;
			free dracl;
			dracl_ptr = null ();
		     end;
	     end;

	if aclp = null ()
	then call FULL_DEDUCE_ACL;
	else call SPECIFIC_DEDUCE_ACL;
	return;

FULL_DEDUCE_ACL:
     procedure;


	declare user_area		 area based (areap);

	call hcs_$list_dir_acl (fcb.dname, fcb.ename, get_system_free_area_ (), dracl_ptr, null (), dracl_count, code);
	if code ^= 0
	then return;

	acl_count = dracl_count;
	allocate segment_acl_array in (user_area);
	do ax = 1 to dracl_count;
	     segment_acl_array (ax).access_name = dracl (ax).access_name;
	     segment_acl_array (ax).mode = TRANSLATE_MODE (dracl (ax).mode);
	     segment_acl_array (ax).extended_mode = ""b;	/* This is WRONG, but we cannot fix it. */
	     segment_acl_array (ax).status_code = 0;
	end;
	free dracl;
	area_ret_ptr = acl_ptr;
	return;
     end FULL_DEDUCE_ACL;

SPECIFIC_DEDUCE_ACL:
     procedure;

	declare system_area		 area based (get_system_free_area_ ());

	dracl_count = acl_count;
	allocate dracl in (system_area);
	dracl (*) = segment_acl_array (*), by name;
	call hcs_$list_dir_acl (fcb.dname, fcb.ename, null (), null (), dracl_ptr, dracl_count, code);
	if code ^= 0
	then do;
		segment_acl_array (*).status_code = dracl (*).status_code;
		free dracl;
		return;
	     end;

	do ax = 1 to acl_count;
	     segment_acl_array (ax).mode = TRANSLATE_MODE (dracl (ax).mode);
	     segment_acl_array (ax).extended_mode = ""b;
	end;

	free dracl;
	return;

     end SPECIFIC_DEDUCE_ACL;
     end DEDUCE_ACL_FROM_DIR_ACL;

TRANSLATE_MODE:
     procedure (Dir_bits) returns (bit (36) aligned);
	declare Dir_bits		 bit (36) aligned;

	return (substr (Dir_bits, 1, 1) || "0"b || substr (Dir_bits, 2, 1));
     end TRANSLATE_MODE;

     end msf_manager_;
