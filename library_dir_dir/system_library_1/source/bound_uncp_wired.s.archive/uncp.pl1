/****^  *********************************************************
        *                                                       *
        * Copyright, (C) BULL HN Information Systems Inc., 1989 *
        *                                                       *
        * Copyright, (C) Honeywell Bull Inc., 1988              *
        *                                                       *
        * Copyright (c) 1972 by Massachusetts Institute of      *
        * Technology and Honeywell Information Systems, Inc.    *
        *                                                       *
        ********************************************************* */



/****^  HISTORY COMMENTS:
  1) change(88-06-09,Berno), approve(88-07-13,MCR7928),
     audit(88-06-09,Parisek), install(88-07-19,MR12.2-1061):
     Initially extracted from dn355.pl1, this module implements the
     Multics DSA UNCP multiplexer interface.
  2) change(89-04-03,Farley), approve(89-04-24,MECR0010),
     audit(89-04-04,Parisek), install(89-04-24,MR12.3-1031):
     Modified sub-mailbox management to allow holding of information in local
     storage after sub-mbx is freed during interrupt processing and to
     centeralize the assignment of the sub-mbxes.  Changed return_mbx/send_mbx
     subroutine to re-assign sub-mbx and copy local storage into sub-mbx when
     required.
  3) change(89-06-01,Farley), approve(89-06-01,MCR8109),
     audit(89-06-02,Parisek), install(89-06-01,MR12.3-1052):
     Offical installation of above changes..
                                                   END HISTORY COMMENTS */

/* format: style4,insnl,delnl,^ifthendo */
uncp:
     procedure;
	return;					/* should never be called here */

/* 	Date last modified and reason

   Written 10/08/74 by F. A. Canali for new tty dim
   Modified by Robert Coren and Mike Grady to fix bugs and add features
   Modified by Robert Coren 10/08/75 for multiple 355s
   Modified by J. Stern 04/22/77 to introduce WTCBs
   Modified by J. Stern 06/23/77 to behave correctly when no submailboxes available
   Modified by J. Stern 07/28/77 to use all 3 words of command data in submailbox
   Modified Jan.-Feb. 1978 to use variable-size output buffers and fix some bugs
   Modified 3/13/78 by Robert Coren to use clock builtin instead of clock_ and to get correct
   time at hangup_fnp_lines entry
   Modified August 1978 by Robert Coren for demultiplexing
   Modified November 8, 1978 by Robert Coren to introduce FNP-initiated mailboxes
   Modified July 2 1979 by B. Greenberg for negotiated echo.
   Modified March 1980 by Robert Coren to eliminate use of circular buffer.
   Modified April 1980 by Robert Coren to add metering information.
   Modified 1980 December by Art Beattie to ignore interrupts in invalid levels.  Also allowed command_data for
   send_wcd operations to be 216 bits long (6 * 36-bit word).  Corrected error message documentation.
   Modified December 1980 by Robert Coren to handle report_meters opcode
   Modified April 1981 by Chris Jones for io_manager conversion


   THE FOLLOWING HISTORY COMMENTS APPLY TO THE FRENCH VERSION OF dn355.pl1
   (uncp.pl1).

   Adapted in January 1982 after version MR8.0 for the Datanet 7100
   Installed at level MR9.1 in July 1982.
   Correction of out_of_bounds after an ineffectgive read (J. Barre)
   Open a connection with 2 terminals to fully test
   Installed at level MR10.1 in June 1983
   Installed at level MR11.0 in August 1983
   * Padding (3) assigned fields missing in dn355_data.incl.pl1.
   Installed at level MR12.0 in January 1987

   Date of the last modification: 06/01/1987
*/

/*	TRACE TO DEBUG		*/

dcl  1 trace int static options (constant),
       2 load bit (1) unal init ("1"b),
       2 mailbox bit (1) unal init ("0"b),
       2 buffer_in bit (1) unal init ("0"b),
       2 buffer_out bit (1) unal init ("0"b);

dcl  max_special_name fixed bin int static options (constant) init (12);
dcl  special_name (12) bit (36) int static options (constant) init ("444665252362"b3,
						/* "MOVECS" bcd */
	"444665250000"b3,				/* "MOVE00" bcd */
	"444665250101"b3,				/* "MOVE11" bcd */
	"534521623145"b3,				/* "$NASIN" bcd */
	"534521624646"b3,				/* "$NASOO" bcd */
	"446443633145"b3,				/* "MULTIN" bcd */
	"446443634646"b3,				/* "MULTOO" bcd */
	"534346272020"b3,				/* "$LOG  " bcd */
	"434621242020"b3,				/* "LOAD  " bcd */
	"512226202020"b3,				/* "RBF   " bcd */
	"512226203145"b3,				/* "RBF IN" bcd */
	"512226204646"b3);				/* "RBF OO" bcd */

dcl  dial_name (12) char (8) int static options (constant) init ("d FTF  
", "d FTF  
", "d FTF  
", "d NASF 
", "d NASF 
", "Multics", "Multics", "d LOG  
", "d LOAD 
", "d RBF  
", "rbfdsa", "rbfdsa");

dcl  qorig fixed bin (24),
     da fixed bin (24);

dcl  sub_mbx_sent bit (1);				/* flag to indicate actual sub_mbx usage */
dcl  sub_mbx_no fixed bin;				/* sub mailbox index */
dcl  sub_mbx_array (8) bit (36) aligned based (subp);	/* bit overlay on mbx's */
dcl  1 local_sub_mbx aligned like sub_mbx;		/* local copy of sub_mbx */

dcl  (bufp, charp, qptr, other_pcbp) ptr,		/* random pointers used */
     timw fixed bin (24),				/* local slot for mailbox timw */
     (level, dno, i, ix, q_first, q_count, chars_left, numchars, k, j) fixed bin,
						/* random halfwords used */
     devx fixed bin,				/* index of current channel */
     operation fixed bin (8),				/* local slot for delay queue operation */
     lano bit (3) unal,				/* local slot for line number */
     nblocks fixed bin;				/* number of blocks allocated */

dcl  fnp_name char (1) aligned;			/* for syserr calls */

dcl  no_response bit (1) aligned;			/* set by send_mbx to indicate that DIA didn't respond */

dcl  interrupt_entry bit (1);				/* whether entered through dn7100$interrupt */
dcl  input_count fixed bin;				/* count sent with accept_dir_input */
dcl  inchain bit (18);				/* pointer to head of newly-allocated input chain */

dcl  chan_lctep ptr;				/* pointer to subchannel's LCTE */
dcl  inchain_ptr ptr;				/* pointer to new input chain */
dcl  bits_per_char fixed bin;
dcl  max_buf_chars fixed bin;				/* number of characters to go in largest buffer at this speed */

dcl  wire_arg fixed bin (71);
dcl  wire_ptr ptr;
dcl  masked bit (1);
dcl  queue_locked bit (1);

dcl  syserr_severity fixed bin (35);

dcl  SYSERR_announce fixed bin int static options (constant) init (0);
dcl  SYSERR_crash fixed bin int static options (constant) init (1);
dcl  SYSERR_beep fixed bin int static options (constant) init (3);
dcl  SYSERR_log fixed bin int static options (constant) init (4);
						/* These syserr constants are used in place of the
						   constants defined in syserr_constants.incl.pl1
						   because of the use of the "CRASH" constant
						   declared in mcs_interrupt_info.incl.pl1 which
						   is also declared as a constant in syserr_constants.incl.pl1. */

dcl  LOOP_LIMIT fixed bin int static options (constant) init (100000);
						/* used to wait for DIA to clear PCW */
dcl  FNP_DOWN fixed bin int static options (constant) init (2);

dcl  initial_pcw bit (36) int static init ("000000000000000000000000000000111001"b);
						/* initial dia pcw */

dcl  INT_LEVEL_1 fixed bin int static options (constant) init (1);
dcl  INT_LEVEL_3 fixed bin int static options (constant) init (3);
dcl  INT_LEVEL_7 fixed bin int static options (constant) init (7);

dcl  BAUD_9600 fixed bin int static options (constant) init (9600);

dcl  MAX_FREE_BUFFERS fixed bin (35) int static options (constant) init (16000000000);

dcl  BPC_10 fixed bin int static options (constant) init (10);
dcl  BPC_8 fixed bin int static options (constant) init (8);/* bits per character */

dcl  MAX_CHANNEL_BUFFER fixed bin int static options (constant) init (128);

dcl  CMD_DATA_LEN_3 fixed bin int static options (constant) init (3);
						/* length of command_data in 6 bit chars */

dcl  MAX_MBX_REQ_CNT fixed bin (35) int static options (constant) init (262143);

dcl  EIGHT fixed bin int static options (constant) init (8);

dcl  CONNECTION_TYPE_1 bit (12) int static options (constant) init ("3145"b3);
dcl  CONNECTION_TYPE_2 bit (12) int static options (constant) init ("4646"b3);

dcl  timwb (0:6) bit (1) based (addr (timw)),		/* timw as a bit array */
     used_string bit (7) based (addr (datanet_mbx.mbx_used_flags.used (0)));
						/* mailbox used flags as a bit string */
						/* The 8th sub-mbx is not used */

dcl  (addr, substr, stac, stacq, string, ptr, rel, index, fixed, divide, bin, max, min, null, length, bit, unspec, hbound,
     lbound, size, verify) builtin;			/* builtin functions used */

dcl  unal_number fixed bin (17) unal based,		/* handy way of referencing an unaligned number */
     chars char (numchars) based;			/* handy way of moving character strings */

dcl  input_chars char (chars_left) based;		/* for scanning entire input */

dcl  smbx_cmd_data_long bit (216) unaligned based (addr (sub_mbx.command_data));

dcl  tc_data$system_shutdown ext fixed bin;		/* external variables used */
dcl  pds$processid bit (36) aligned ext static;

dcl  ff_cr_lf char (3) int static options (constant) init ("
");

dcl  form_feed init ("") char (1) int static options (constant);


dcl  syserr entry options (variable),			/* external entries called */
     ldac entry (ptr) returns (fixed bin (24)),
     dn355_util$compute_parity entry (bit (36)) returns (bit (36)),
     (
     uncp_boot_interrupt,
     uncp_boot_interrupt$system_fault
     ) entry (fixed bin),
     uncp_boot_interrupt$request_init entry (fixed bin),
     pxss$ring_0_wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35)),
     pxss$unique_ring_0_wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35)),
     pxss$notify entry (fixed bin);

dcl  pmut$wire_and_mask entry (fixed bin (71), ptr);
dcl  pmut$unwire_unmask entry (fixed bin (71), ptr);
dcl  1 auto_net_event_message aligned like net_event_message;
dcl  1 auto_fnp_msg aligned like fnp_msg;
dcl  fnp_event_message fixed bin (71);

dcl  1 q_entry aligned like fnp_queue_entry based (qptr);

dcl  new_qp ptr;					/* temporary to newly-allocated block */
dcl  new_qrel fixed bin;

dcl  1 wrap_q_address aligned based (addr (sub_mbx.command_data (3))),
						/* overlay for rtx on wrapped queue */
       2 wrap_ptr bit (18) unal,
       2 wrap_cnt fixed bin (18) unsigned unal;

dcl  fault_name char (16);				/* 355 fault name */


dcl  cleanup condition;

%include tty_buf;

%include uncp_buf;

%include tty_buffer_block;

%include lct;
%include pcb;
%include dn355_data;

dcl  1 gateway_buf aligned based (blockp),
       2 cnt fixed bin (18) unsigned unaligned,
       2 pad bit (18) unaligned;

dcl  gateway_header bit (36) based (blockp);

dcl  buf_words (256) fixed bin based;

%include dn355_mailbox;

dcl  connect_to_slave_nowait init (76) fixed bin (8) init static options (constant);

%include mailbox_ops;

%include mcs_interrupt_info;

%include dn355_messages;

%include fnp_queue_entry;
%include channel_manager_dcls;
%include tty_space_man_dcls;

%include line_types;
%include baud_rates;

%include net_event_message;
%page;
%include fnp_mpx_msg_;
%include io_manager_dcls;
%page;
interrupt:
     entry (x_dno, x_level, x_status);			/* entry from iom_manager */

dcl  x_dno fixed bin (35);				/* index from assignment time */
dcl  x_level fixed bin (3);				/* interrupt level */
dcl  x_status bit (36) aligned;			/* status after special or fault */

	if tc_data$system_shutdown ^= 0
	then return;				/* ignore 355's if shut down in progress */
	interrupt_entry = "1"b;

	call setup;
	level = x_level;				/* copy level to local stack */
	if datanet_info.trace
	then do;
	     if level ^= INT_LEVEL_3 | ^fnp_info.running
	     then syserr_severity = SYSERR_announce;
	     else syserr_severity = SYSERR_log;
	     call syserr (syserr_severity,
		"uncp: FNP ^a level ^d status ^w^[ running^]^[ bootloading^]^[ t_and_d_in_progress^]", fnp_name,
		level, x_status, fnp_info.running, fnp_info.bootloading, fnp_info.t_and_d_in_progress);
	end;
	if level ^= INT_LEVEL_3 & level ^= INT_LEVEL_7
	then do;					/* if not a good interrupt level */
	     call syserr (SYSERR_beep, "uncp: FNP ^a invalid interrupt level ^o", fnp_name, level);
	     if fnp_info.bootloading
	     then if level = INT_LEVEL_1		/* system fault */
		then call uncp_boot_interrupt$system_fault (dno);
	     return;				/* lets hope its benign */
	end;

	if (^fnp_info.t_and_d_in_progress) & (^fnp_info.running) & (^fnp_info.bootloading)
	then return;				/* spurious interrupt */

	if ^stac (addr (lcte.lock), pds$processid)	/* somebody else has it */
	then do;

	     do while (^stac (addr (fnp_info.queue_lock), pds$processid));
	     end;

	     if level = INT_LEVEL_7
	     then fnp_info.level_7_pending = "1"b;
	     else fnp_info.level_3_pending = "1"b;

	     if stac (addr (lcte.lock), pds$processid)	/* in case it got unlocked meanwhile */
	     then call process_int_queue ("0"b);

	     else if ^stacq (fnp_info.queue_lock, "0"b, pds$processid)
	     then call syserr (SYSERR_crash, "uncp: inconsistent queue lock");
	end;

	else do;
	     call process_int (level);

	     do while (^stac (addr (fnp_info.queue_lock), pds$processid));
	     end;					/* check the queue to see if anything came in while we had the lock */

	     call process_int_queue ("0"b);
	end;

	return;

global_exit:					/* if abort out of an internal proc */
	if interrupt_entry
	then do;
	     if stacq (lcte.lock, "0"b, pds$processid)	/* make sure we undo anything we did */
	     then if lcte.notify_reqd
		then do;
		     lcte.notify_reqd = "0"b;
		     call pxss$notify (tty_ev);
		end;

	     lcte.locked_for_interrupt = "0"b;

	end;
	return;

/* entry to send a command to the FNP */
send_wcd:
     entry (a_fnpp, a_pcbp, opa, chrsa, data);

dcl  a_fnpp ptr,					/* parameters */
     a_pcbp ptr,
     opa fixed bin (8),
     data bit (*),					/* allow use of 6 words in sub_mbx */
     chrsa fixed bin (8);				/* numeric */

dcl  tdata bit (8 * 36);
dcl  data_len fixed bin (8);

	pcbp = a_pcbp;
	go to send_join;

send_global_wcd:
     entry (a_fnpp, opa, chrsa, data);

	pcbp = null ();
	fnpp = a_fnpp;
	if opa = dial
	then do;
	     do ix = 1 to max_special_name while (special_name (ix) ^= substr (data, 1, 36));
	     end;
	     if ix <= max_special_name
	     then fnp_info.active_bit (ix) = substr (data, 37, 1);
	     return;
	end;

send_join:
	interrupt_entry = "0"b;
	fnpp = a_fnpp;
	ttybp = addr (tty_buf$);			/* get ptr to tty buf */
	infop = addr (dn355_data$);			/* and dn 355 info */
	uncpbp = datanet_info.uncp_bufp;		/* get ptr to uncp buf */
	lctep = fnp_info.lcte_ptr;
	operation = opa;				/* and copy op to local stack */
	if ^fnp_info.running &			/* can't talk to it if it's not listening */
	     (^fnp_info.bootloading | operation ^= init_complete)
	then return;

	no_response = "0"b;
	dno = fnp_info.fnp_number;
	mbxp = fnp_info.mbx_pt;			/* get pointer to mailbox */
	data_len = min (length (tdata), chrsa);		/* compute bit length of command data */
	if data_len > 0
	then tdata = substr (data, 1, data_len);
	else tdata = "0"b;

	if pcbp ^= null
	then if operation = disconnect_this_line
	     then if pcb.dialed = "0"b
		then return;

	if operation = accept_direct_output
	then if pcb.dumpout
	     then do;
		call throw_away_output;
		pcb.dumpout = "0"b;
	     end;

	if operation = enter_receive
	then do;
	     if pcb.connection_type = "10"b
	     then return;

	     ix = pcb.baud_rate;
	     if ix ^= BAUD_9600
	     then do;
		pcb.turn = "1"b;
		call send_dial;
		return;
	     end;

	     if pcb.write_last ^= 0
	     then do;
		blockp = ptr (ttybp, pcb.write_last);
		buffer.turn = "1"b;
		return;
	     end;
	     else do;
		pcb.enter_receive_pending = "1"b;
		if pcb.end_frame | ^pcb.send_output
		then return;
		else operation = accept_direct_output;
	     end;

	end;

	call assign_sub_mbx (sub_mbx_no, subp);		/* find a free sub mbx */
	if sub_mbx_no = -1				/* no submailbox */
	then do;
	     call make_q_entry (operation, data_len, tdata);
	     fnp_info.mbx_unavailable = fnp_info.mbx_unavailable + 1;
						/* form q entry element from data */
	end;

	else do;					/* we have a sub mbx, ship it off to the 355 */
	     if pcbp ^= null ()
	     then do;
		string (sub_mbx.line_number) = string (pcb.line_number);
						/* move line number to sub mbx */
		devx = pcb.devx;
	     end;

	     else string (sub_mbx.line_number) = "0"b;	/* unless no pcb (global call) */

	     sub_mbx.op_code = operation;		/* set sub mbx op */
	     sub_mbx.cmd_data_len = divide (data_len, 6, 17, 0);
						/* set data length */
	     if operation = accept_direct_output	/* if output op */
	     then do;
		if ^pcb.flags.dialed		/* output without a dialup? */
		then call throw_away_output;		/* discard it */

		else call process_send_output (sub_mbx_no, "0"b);
	     end;

	     else do;
		sub_mbx.io_cmd = wcd;		/* set write control data cmd */
		smbx_cmd_data_long = substr (tdata, 1, data_len);
						/* move command data to sub mbx */
		call send_mbx (sub_mbx_no);		/* ship the mbx off to the 355 */
		fnp_info.output_control_transactions = fnp_info.output_control_transactions + 1;
	     end;

	     if ^sub_mbx_sent
	     then call release_sub_mbx (sub_mbx_no);

	     if no_response
	     then call report_fnp_no_response;
	end;


	return;					/* return to caller */

process_interrupt_queue:
     entry (x_dno);

	interrupt_entry = "0"b;
	call setup;
	on cleanup call check_lock;
	masked = "1"b;				/* have to mask and wire while holding queue lock */
	call pmut$wire_and_mask (wire_arg, wire_ptr);

	do while (^stac (addr (fnp_info.queue_lock), pds$processid));
	end;
	queue_locked = "1"b;

	call process_int_queue ("1"b);
	return;

setup:
     proc;

	ttybp = addr (tty_buf$);			/* get addr of tty buffer segment */
	dno = x_dno;				/* copy 355 number to local stack */
	infop = addr (dn355_data$);			/* get address 0f 355 info segment  */
	uncpbp = datanet_info.uncp_bufp;		/*   initialise l adresse du segment uncp_buf   */

	fnpp = addr (datanet_info.per_datanet (dno));
	fnp_name = fnp_info.fnp_tag;
	mbxp = fnp_info.mbx_pt;			/* get mailbox pointer */
	lctep = fnp_info.lcte_ptr;
	n_pcbs = fnp_info.no_of_channels;		/* set number of channel control blocks to number of channels */

	return;
     end setup;

process_int_queue:
     proc (caller_masked);

/* called with queue locked. Empties the queue, and must unlock it when done */

dcl  caller_masked bit (1);				/* indicates whether caller explicitly called pmut$wire_and_mask */

	do while (dequeue (level));
	     fnp_info.processed_from_q = fnp_info.processed_from_q + 1;
						/* meter */
	     if ^stacq (fnp_info.queue_lock, "0"b, pds$processid)
	     then call syserr (SYSERR_crash, "uncp: inconsistent queue lock");

	     queue_locked = "0"b;
	     if caller_masked
	     then call pmut$unwire_unmask (wire_arg, wire_ptr);
	     masked = "0"b;

	     call process_int (level);

	     if caller_masked
	     then do;				/* if we unmasked, we have to mask again */
		masked = "1"b;
		call pmut$wire_and_mask (wire_arg, wire_ptr);
	     end;

	     do while (^stac (addr (fnp_info.queue_lock), pds$processid));
	     end;
	     queue_locked = "1"b;
	end;

	lcte.locked_for_interrupt = "0"b;
	if ^stacq (lcte.lock, "0"b, pds$processid)
	then call syserr (SYSERR_crash, "uncp: LCTE lock ^^= processid");

	if ^stacq (fnp_info.queue_lock, "0"b, pds$processid)
	then call syserr (SYSERR_crash, "uncp: inconsistent queue lock");

	queue_locked = "0"b;
	if caller_masked
	then call pmut$unwire_unmask (wire_arg, wire_ptr);
	masked = "0"b;

	if lcte.notify_reqd
	then do;
	     lcte.notify_reqd = "0"b;
	     call pxss$notify (tty_ev);
	end;

	return;

dequeue:
	proc (a_level) returns (bit (1));

dcl  a_level fixed bin;

	     if fnp_info.level_3_pending
	     then do;
		fnp_info.level_3_pending = "0"b;
		a_level = INT_LEVEL_3;
		return ("1"b);
	     end;

	     else if fnp_info.level_7_pending
	     then do;
		fnp_info.level_7_pending = "0"b;
		a_level = INT_LEVEL_7;
		return ("1"b);
	     end;

	     else return ("0"b);

	end /* dequeue */;
     end /* process_int_queue */;

process_int:
     proc (a_level);

/* internal procedure to process an interrupt, either when it occurs or from the queue */

dcl  a_level fixed bin;

	level = a_level;

	lcte.locked_for_interrupt = "1"b;
	if level = INT_LEVEL_7
	then do;					/* emergency interrupt */

	     if fnp_info.t_and_d_in_progress
	     then do;
		if fnp_info.t_and_d_lev_7_occurred
		then return;
		fnp_info.t_and_d_lev_7_occurred = "1"b;
t_and_d_join:
		if fnp_info.t_and_d_notify_requested
		then do;
		     call pxss$notify (tty_ev);
		     fnp_info.t_and_d_notify_requested = "0"b;
		end;
		unspec (auto_net_event_message) = "0"b;
		auto_net_event_message.version = NET_EVENT_MESSAGE_VERSION_1;
		auto_net_event_message.network_type = MCS_NETWORK_TYPE;
		auto_net_event_message.handle = dno;
		auto_net_event_message.type = level;
		unspec (net_event_message_arg) = unspec (auto_net_event_message);
		call pxss$unique_ring_0_wakeup (fnp_info.boot_process_id, fnp_info.boot_ev_chan,
		     net_event_message_arg, 0);
		return;
	     end;

	     fault_name = "STOPPING DATANET";
	     call syserr (SYSERR_beep, "uncp: emergency interrupt from FNP ^a: ^a", fnp_info.fnp_tag, fault_name);
	     timw = ldac (addr (datanet_mbx.term_inpt_mpx_wd));
	     if fnp_info.running
	     then call purge_write_texte;


	     call report_fnp_crash;			/* report it and hang up lines */
	     return;				/* done with this interrupt */
	end;

	if unspec (datanet_mbx.mailbox_requests) = "777777000000"b3
	then do;					/* DSA requesting init */
	     datanet_mbx.mailbox_requests = datanet_mbx.mailbox_requests + 1;

	     if trace.load
	     then call syserr (SYSERR_log, "uncp: request_init");

	     timw = ldac (addr (datanet_mbx.term_inpt_mpx_wd));
	     if fnp_info.running
	     then call purge_write_texte;
	     call uncp_boot_interrupt$request_init (dno);
	     fnp_info.uncp_pcbx1, fnp_info.uncp_pcbx2 = 0;
	     return;
	end;

	if fnp_info.bootloading			/* if this is bootload status */
	then do;
	     timw = ldac (addr (datanet_mbx.term_inpt_mpx_wd));
	     if timwb (0)
	     then do;				/* 1st mailbox for WCD_init_complete */
		subp = addr (datanet_mbx.dn355_sub_mbxes (0));
		datanet_mbx.mbx_used_flags.used (0) = "0"b;
						/* free the mailbox */
		datanet_mbx.num_in_use = datanet_mbx.num_in_use - 1;
		if (sub_mbx.io_cmd = wcd) & (sub_mbx.op_code = init_complete)
		then do;

		     if trace.load
		     then call syserr (SYSERR_log, "uncp: WCD init_complete acknowledgement");

		     call uncp_boot_interrupt (dno);	/* let special routine figure it out */
		     fnp_info.uncp_pcbx1, fnp_info.uncp_pcbx2 = 0;
		end;
	     end;
	     return;				/* Don't analyze the mailbox */
	end;




	if fnp_info.t_and_d_in_progress
	then do;
	     if fnp_info.t_and_d_lev_3_occurred
	     then return;
	     fnp_info.t_and_d_lev_3_occurred = "1"b;
	     go to t_and_d_join;
	end;

	if ^fnp_info.running			/* if this interrupt is premature, ignore it */
	then return;


	no_response = "0"b;				/* initially */




	if used_string ^= (7)"1"b
	then call spend_submailboxes;			/* if some free mailboxes */

/* process any submailboxes which have been returned by the 355 */

	timw = ldac (addr (datanet_mbx.term_inpt_mpx_wd));/* get timw and clear */


/* mailbox number 0 & number  15 are reserved to init and abort */

	do i = lbound (timwb, 1) to hbound (timwb, 1);	/* loop over submailbox indicators */

	     if timwb (i) & ^no_response
	     then do;				/* if mailbox was returned by 355 then we have something to do */
		sub_mbx_no = i;
		unspec (local_sub_mbx) = unspec (datanet_mbx.dn355_sub_mbxes (sub_mbx_no));
		subp = addr (local_sub_mbx);
		if trace.mailbox
		then call syserr (SYSERR_log, "uncp: mbx received # ^o ^2( ^/ ^4( ^w ^) ^)", sub_mbx_no,
			sub_mbx_array);
		datanet_mbx.mbx_used_flags.used (sub_mbx_no) = "0"b;
						/* clear submailbox used flag */
		sub_mbx_no = -1;			/* indicate use of local copy */

		datanet_mbx.num_in_use = datanet_mbx.num_in_use - 1;
		fnp_info.cumulative_mbx_in_use = fnp_info.cumulative_mbx_in_use + datanet_mbx.num_in_use;
		fnp_info.mbx_in_use_updated = fnp_info.mbx_in_use_updated + 1;


		call get_line_number;

/* WRITE COMMAND DATA		*/

		if sub_mbx.io_cmd = wcd
		then do;
		     if (devx ^= -1) & (sub_mbx.op_code = disconnect_this_line)
		     then do;
			if pcb.dialed
			then do;
			     call throw_away_output;
			     if pcb.connection_type ^= "01"b
			     then call channel_manager$interrupt (devx, HANGUP, ""b);
disconnect_other_line:
			     if (pcb.connection_type ^= "00"b) & (pcb.uncp_pcbx ^= 0)
			     then do;
				other_pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (pcb.uncp_pcbx));
				if other_pcbp -> pcb.dialed
				then do;
				     string (sub_mbx.line_number) = string (other_pcbp -> pcb.line_number);
				     call return_mbx (sub_mbx_no);
				end;
			     end;
			end;
			pcb.dialed = "0"b;
			pcb.baud_rate = 0;
		     end;

		     if (devx ^= -1) & (sub_mbx.op_code = disconnect_accepted)
		     then do;
			sub_mbx.op_code = disconnect_this_line;
			goto disconnect_other_line;
		     end;


		end;				/* just free submbx */

		else do;

/*        WRITE TEXTE			*/

		     if sub_mbx.io_cmd = wtx
		     then do;			/* check for write text */
			pcb.output_mbx_pending = "0"b;
			if pcb.connection_type = "10"b
			then pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (pcb.uncp_pcbx));
			if sub_mbx.command_data (3) ^= "0"b
			then do;
			     da = bin (sub_mbx.data_addr, 18) - tty_buf.absorig;
						/* get offset in tty buf   */
			     blockp = ptr (ttybp, da);/* set ptr to buffer */
			     gateway_header = sub_mbx.command_data (3);


			     call tty_space_man$free_chain ((pcb.devx), OUTPUT, blockp);
						/* and the output chain */



			end;
		     end;

/*        READ CONTROL DATA		*/

		     else if sub_mbx.io_cmd = rcd
		     then do;			/* check for control stuff */
			if (sub_mbx.op_code = accept_direct_input) | (sub_mbx.op_code = send_output)
			then do;


			     fnp_info.bleft_355 = 0;	/* make it safe */

			     if fnp_info.free_size > MAX_FREE_BUFFERS
			     then do;
				fnp_info.free_size = 0;
				fnp_info.free_count = 0;
			     end;

			     fnp_info.free_size = fnp_info.free_size + fnp_info.bleft_355;
			     fnp_info.free_count = fnp_info.free_count + 1;
			end;
			if sub_mbx.op_code = accept_direct_input
			then fnp_info.input_data_transactions = fnp_info.input_data_transactions + 1;
			else fnp_info.input_control_transactions = fnp_info.input_control_transactions + 1;



/*	ACCEPT NEW TERMINAL		*/

			if sub_mbx.op_code = accept_new_terminal
			then do;			/* check for new terminal on line */
			     if devx = -1
			     then do;
				sub_mbx.io_cmd = wcd;
				sub_mbx.op_code = terminal_rejected;
				sub_mbx.cmd_data_len = 0;
				call return_mbx (sub_mbx_no);
			     end;
			     else do;


				pcb.line_type = LINE_ASCII;
				pcb.send_lf = "0"b;



				pcb.baud_rate = BAUD_9600;
						/* highest speed for UNCP */

				do j = 1 to n_sync_line_types while (sync_line_type (j) ^= pcb.line_type);
				end;
				pcb.sync_line = (j <= n_sync_line_types);

				if ^pcb.sync_line	/* asynchronous */
				then bits_per_char = BPC_10;
				else bits_per_char = BPC_8;
						/* assumption for synchronous lines */

				max_buf_chars =
				     divide (divide (pcb.baud_rate, bits_per_char, 17, 0), buf_per_second, 17, 0);
				pcb.max_buf_size = min (16 * divide (max_buf_chars + 67, 64, 17, 0), 128);
						/* round up to multiple of 16 words */
				if pcb.line_type = LINE_COLTS
				then pcb.max_buf_size = MAX_CHANNEL_BUFFER;
						/* COLTS channel always gets big buffers */
				pcb.dialed, pcb.enter_receive_pending, pcb.turn, pcb.dumpout, pcb.send_output =
				     "0"b;
				pcb.connection_type = "00"b;

				sub_mbx.op_code = terminal_accepted;
						/* inform 355 that term is ok */
				sub_mbx.cmd_data_len = CMD_DATA_LEN_3;
						/* we will put write buffer threshold in command data */
				if ^pcb.high_speed	/* less than 1200 baud */
				then addr (sub_mbx.command_data) -> unal_number = 2;
						/* set low write buffer threshold */
				else addr (sub_mbx.command_data) -> unal_number = 4;
						/* set high write buffer threshold */
				sub_mbx.io_cmd = wcd;
				call return_mbx (sub_mbx_no);
			     end;
			end;

/*	DISCONNECTED LINE		*/

			else if sub_mbx.op_code = disconnected_line
			then do;			/* see if line just hung up */
			     if pcb.dialed
			     then do;
				call throw_away_output;
				if pcb.connection_type ^= "01"b
				then call channel_manager$interrupt (devx, HANGUP, ""b);
			     end;
			     pcb.dialed = "0"b;
			     sub_mbx.io_cmd = wcd;
			     sub_mbx.op_code = disconnect_accepted;
			     call return_mbx (sub_mbx_no);
			end;

/*	BREAK CONDITION		*/

			else if sub_mbx.op_code = break_condition
			then do;			/* check for break */
			     if pcb.dialed
			     then do;
				if pcb.hndlquit
				then call throw_away_output;
				call channel_manager$interrupt (devx, QUIT, ""b);
				pcb.turn = "1"b;
			     end;
			     sub_mbx.io_cmd = wcd;
			     sub_mbx.op_code = break_acknowledged;
			     sub_mbx.cmd_data_len = 0;
			     call return_mbx (sub_mbx_no);
			     call make_q_entry (accept_direct_output, 0, ""b);
						/* BREAK sends the turn */
			end;

/*	SEND OUTPUT		*/

			else if sub_mbx.op_code = send_output
			then do;			/* is this request for output? */
			     if pcb.dialed
			     then do;
				if pcb.connection_type = "10"b
				then pcb.turn = "1"b;
				call process_send_output (sub_mbx_no, "1"b);
			     end;

			end;

/*	ACCEPT DIRECT INPUT		*/

			else if sub_mbx.op_code = accept_direct_input
			then do;			/* check for input from terminal */
			     if pcb.dialed
			     then call process_accept_input;
			end;


/*	CONNECT TO SLAVE		*/
/*	CONNECT TO SLAVE WITH NO WAIT	*/
			else if (sub_mbx.op_code = connect_to_slave) | (sub_mbx.op_code = connect_to_slave_nowait)
			then do;
			     pcb.extra_nl, pcb.lfecho = "0"b;
			     do ix = 1 to max_special_name while (special_name (ix) ^= sub_mbx.command_data (1));
			     end;
			     if ix <= max_special_name
			     then do;
				if (dial_name (ix) = "Multics") | (dial_name (ix) = "rbfdsa")
				then fnp_info.active_bit (ix) = "1"b;

				if ^fnp_info.active_bit (ix)
				then do;
				     sub_mbx.io_cmd = wcd;
				     sub_mbx.op_code = disconnect_this_line;
				     call return_mbx (sub_mbx_no);
				     goto no_dialup;
				end;
			     end;

			     if ix > max_special_name
			     then do;
				ix = BAUD_9600;
				pcb.turn, pcb.extra_nl, pcb.lfecho = "1"b;
			     end;
			     else do;
				pcb.baud_rate = ix;
				if index (special_name (ix), CONNECTION_TYPE_1) ^= 0
				then pcb.connection_type = "01"b;
				if index (special_name (ix), CONNECTION_TYPE_2) ^= 0
				then pcb.connection_type = "10"b;
			     end;

			     pcb.dialed = "1"b;

			     if pcb.connection_type = "01"b
			     then do;
				pcb.uncp_pcbx = 0;
				if fnp_info.uncp_pcbx1 = 0
				then do;
				     fnp_info.uncp_pcbx1 = j;
				     sub_mbx.op_code = enter_receive;
				     call return_mbx (sub_mbx_no);
				end;
				else if fnp_info.uncp_pcbx2 = 0
				then fnp_info.uncp_pcbx2 = j;
				goto no_dialup;
			     end;

			     if pcb.connection_type = "10"b
			     then do;
				if fnp_info.uncp_pcbx1 = 0
				then do;
				     call syserr (SYSERR_announce,
					"uncp: Connection on output only not awaited. (dial '^a')",
					dial_name (ix));
				     goto no_dialup;
				end;
				else do;
				     other_pcbp =
					addr (fnp_info.pcb_array_ptr -> pcb_array (fnp_info.uncp_pcbx1));
				     other_pcbp -> pcb.uncp_pcbx = j;
				     pcb.uncp_pcbx = fnp_info.uncp_pcbx1;
				     pcb.turn = "1"b;
				     if dial_name (ix) = "Multics"
				     then other_pcbp -> pcb.extra_nl = "1"b;

				     if (dial_name (ix) = "Multics") | (dial_name (ix) = "rbfdsa")
				     then other_pcbp -> pcb.baud_rate, pcb.baud_rate = BAUD_9600;


				     fnp_info.uncp_pcbx1 = 0;
				     if fnp_info.uncp_pcbx2 ^= 0
				     then do;
					other_pcbp =
					     addr (fnp_info.pcb_array_ptr -> pcb_array (fnp_info.uncp_pcbx2));
					fnp_info.uncp_pcbx1 = fnp_info.uncp_pcbx2;
					fnp_info.uncp_pcbx2 = 0;
					string (sub_mbx.line_number) = string (other_pcbp -> pcb.line_number);
					sub_mbx.op_code = enter_receive;
					call return_mbx (sub_mbx_no);
					j = fnp_info.hsla_idx (0);
					do j = j to fnp_info.no_of_channels while (fnp_info.uncp_pcbx2 = 0);
					     other_pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (j));
					     if other_pcbp -> pcb.dialed
						& (other_pcbp -> pcb.connection_type = "01"b)
						& (other_pcbp -> pcb.uncp_pcbx = 0)
					     then if (fnp_info.uncp_pcbx1 ^= j)
						then fnp_info.uncp_pcbx2 = j;
					end;
				     end;
				end;
			     end;

			     dialup_info.line_type = LINE_ASCII;
			     dialup_info.receive_mode_device = "0"b;
			     if pcb.connection_type = "00"b
			     then dialup_info.receive_mode_device = "1"b;
			     dialup_info.baud_rate = ix;
			     dialup_info.max_buf_size = pcb.max_buf_size;
			     dialup_info.buffer_pad = 0;
			     dialup_info.pad = "0"b;
			     interrupt_info = unspec (dialup_info);
			     call channel_manager$interrupt (devx, DIALUP, interrupt_info);
			     call process_send_output (sub_mbx_no, "1"b);
no_dialup:
			end;

			else if devx ^= -1
			then call syserr (SYSERR_announce,
				"uncp: unrecognized op code ^o with rcd from FNP ^a for devx ^o", sub_mbx.op_code,
				substr ("abcdefgh", dno, 1), devx);
						/* someone goofed */

		     end;

/*        READ TEXTE			*/

		     else if sub_mbx.io_cmd = rtx
		     then do;
			call process_rtx;		/* check for read text */
			if pcb.connection_type = "01"b
			then do;
			     sub_mbx.op_code = enter_receive;
			     call return_mbx (sub_mbx_no);
			end;
		     end;
		     else call syserr (SYSERR_beep, "uncp: unrecognized io command ^o from FNP ^a for line ^o",
			     sub_mbx.io_cmd, substr ("abcdefgh", dno, 1), bin (string (sub_mbx.line_number), 10));
						/* complain */
		end;


	     end;
	end;

/* use spend_submailboxes    */


	if ^no_response & used_string ^= (7)"1"b
	then					/* see if we freed some submailboxes */
	     call spend_submailboxes;




	if no_response				/* if someone discovered that the FNP was gone */
	then call report_fnp_no_response;

/* Supprimer le label exit avec deverrouillage de lcte.lock   */

	return;					/* return to iom_manager */
     end /* process_int  */;

/* An internal procedure to perform interrupt-time tasks that consume submailboxes.
   First check for queued up work. Then attend to FNP mailbox requests. */

spend_submailboxes:
     proc;

	if fnp_info.count ^= 0
	then call process_q;			/* were we waiting for a free mbx */


	do while (datanet_mbx.mailbox_requests ^= datanet_mbx.last_mbx_req_count);
						/* try to service mailbox requests */
	     call assign_sub_mbx (sub_mbx_no, subp);	/* find a free sub mbx */
	     if sub_mbx_no = -1
	     then return;				/* none available, will try again at next interrupt. */
	     sub_mbx.io_cmd = rcd;			/* set rcd in sub mailbox. */
	     call send_mbx (sub_mbx_no);		/* now ship submailbox off uncp. */
	     datanet_mbx.last_mbx_req_count = datanet_mbx.last_mbx_req_count + 1;
	     if datanet_mbx.last_mbx_req_count > MAX_MBX_REQ_CNT
	     then datanet_mbx.last_mbx_req_count = 0;
	     if ^sub_mbx_sent
	     then call release_sub_mbx (sub_mbx_no);
	end;
     end /* spend_submailboxes */;

process_q:
     proc;

/* process the queue of mailbox operations that could not be performed
   because no mailboxes wre available
*/

	q_first = fnp_info.cur_ptr;
	q_count = fnp_info.count;
	sub_mbx_no = 0;				/* preset mbx# for do while */

	do while (q_count > 0 & sub_mbx_no >= 0);
	     call assign_sub_mbx (sub_mbx_no, subp);	/* find a free sub mbx */
	     if sub_mbx_no >= 0			/* now we can have one */
	     then do;
		qptr = ptr (ttybp, q_first);
		if q_entry.pcb_offset ^= "0"b		/* for a specific channel */
		then do;
		     pcbp = ptr (ttybp, q_entry.pcb_offset);
		     string (sub_mbx.line_number) = string (pcb.line_number);
		     devx = pcb.devx;
		end;
		else string (sub_mbx.line_number) = ""b;

		if q_entry.opcode = accept_direct_output
		then if pcb.dialed
		     then call process_send_output (sub_mbx_no, "0"b);
		     else ;

		else do;
		     sub_mbx.io_cmd = wcd;
		     sub_mbx.op_code = q_entry.opcode;
		     sub_mbx.cmd_data_len = divide (q_entry.cmd_count, 6, 8, 0);
		     smbx_cmd_data_long = substr (q_entry.cmd_data, 1, q_entry.cmd_count);
		     call send_mbx (sub_mbx_no);
		     fnp_info.output_control_transactions = fnp_info.output_control_transactions + 1;
		end;

		if no_response			/* give up in this case */
		then goto update_q_ptrs;

		q_first = q_entry.next;		/* on to next queue entry */
		q_count = q_count - 1;
		call tty_space_man$free_space (size (q_entry), qptr);
		if ^sub_mbx_sent
		then call release_sub_mbx (sub_mbx_no);
	     end;

	     else fnp_info.mbx_unavailable = fnp_info.mbx_unavailable + 1;
	end;

update_q_ptrs:
	fnp_info.cur_ptr = q_first;
	fnp_info.count = q_count;
	if q_count = 0
	then fnp_info.last_ptr = 0;

	return;
     end /* process_q */;

send_dial:
     proc;
	pcb.send_output = "1"b;
	devx = pcb.devx;

	if pcb.write_last ^= 0
	then do;
	     blockp = ptr (ttybp, pcb.write_last);
	     if buffer.turn
	     then pcb.turn = "1"b;
	     call throw_away_output;
	end;

	if pcb.turn = "1"b
	then do;
	     call tty_space_man$get_chain (devx, 16, 1, INPUT, inchain_ptr);
	     if inchain_ptr = null
	     then do;
		call syserr (SYSERR_announce, "uncp: special_dial, Failure of buffer to make '^a'", dial_name (ix));
		call channel_manager$interrupt (devx, QUIT, ""b);
		return;
	     end;
	     inchain = rel (inchain_ptr);
	     blockp = inchain_ptr;
	     numchars = EIGHT;
	     bufp = addr (dial_name (ix));
	     charp = addr (buffer.chars);
	     charp -> chars = bufp -> chars;
	     buffer.tally = numchars;
	     rtx_info.break_char = "1"b;
	     rtx_info.output_in_fnp = "0"b;
	     rtx_info.output_in_ring_0 = "0"b;
	     rtx_info.input_count = EIGHT;
	     rtx_info.chain_head = inchain;
	     rtx_info.chain_tail = rel (blockp);
	     interrupt_info = unspec (rtx_info);
	     call channel_manager$interrupt (devx, ACCEPT_INPUT, interrupt_info);
	     pcb.baud_rate = BAUD_9600;
	     pcb.dumpout = "1"b;
	end;
	call channel_manager$interrupt (devx, SEND_OUTPUT, ""b);
	return;

     end send_dial;

/* internal subroutine to process send output */

process_send_output:
     proc (a_mbx_num, interrupt_entry);

dcl  a_mbx_num fixed bin;				/* -1 indicates mailbox not already allocated */
dcl  mbx_num fixed bin;
dcl  interrupt_entry bit (1) aligned;			/* indicates whether or not called on interrupt side */

	mbx_num = a_mbx_num;

	if pcb.end_frame | pcb.output_mbx_pending	/* if we're waiting for form-feed */
	then do;
	     pcb.flags.send_output = "1"b;		/* we'll want output eventually */
	     if pcb.turn = "1"b
	     then call channel_manager$interrupt (devx, SEND_OUTPUT, ""b);
						/* For the Quit problem */
	     return;				/* don't do anything else */
	end;

	if pcb.enter_receive_pending | pcb.send_lf
	then do;
	     sub_mbx.op_code = enter_receive;
	     call send_mbx (mbx_num);
	     return;
	end;

	if pcb.write_first = 0
	then do;

	     pcb.flags.send_output = "1"b;		/* if no output then just set flag */
	     call channel_manager$interrupt (devx, SEND_OUTPUT, ""b);
	end;

	else do;
	     ix = pcb.baud_rate;
	     if ix ^= BAUD_9600
	     then do;
		call send_dial;
		return;
	     end;

	     if pcb.turn = "0"b
	     then return;				/* Don't emit without the turn ON */

	     if mbx_num = -1			/* caller didn't supply one */
	     then do;
		call assign_sub_mbx (mbx_num, subp);	/* find a free sub mbx */
		if mbx_num = -1			/* still? we didn't get one */
		then do;
		     call make_q_entry (accept_direct_output, 0, ""b);
		     fnp_info.mbx_unavailable = fnp_info.mbx_unavailable + 1;
		     return;			/* we'll catch it later */
		end;
		else do;
		     string (sub_mbx.line_number) = string (pcb.line_number);
		end;
	     end;


	     pcb.flags.send_output = "0"b;		/* make sure flag clear */


/*						no DCW with UNCP  */

	     blockp = ptr (ttybp, pcb.write_first);	/* get ptr to buffer */
	     if buffer.tally = 0			/* we don't want this in a dcw */
	     then call syserr (SYSERR_crash, "uncp: output buffer at ^o has zero tally", pcb.write_first);

/*						no DCW with UNCP    */


	     pcb.write_first = buffer.next;		/* now bump to next buffer */
	     pcb.write_cnt = pcb.write_cnt - buffer.tally;/* decrement count of chars in chain */


	     if buffer.flags.end_of_page		/* if this buffer fills a page/screen */
	     then pcb.flags.end_frame = "1"b;		/* remember it */


	     if pcb.write_first ^= 0
	     then buffer.flags.turn = "0"b;		/* Give up turn if terminating  */


	     sub_mbx.op_code = accept_direct_output;
	     if buffer.flags.turn
	     then pcb.flags.end_frame = "0"b;
	     if buffer.flags.turn | buffer.flags.end_of_page
	     then do;
		sub_mbx.op_code = accept_last_output;
		pcb.turn = "0"b;
	     end;

	     sub_mbx.command_data (1) = "0"b;		/* make sure it starts clean */
	     sub_mbx.data_addr = bit (bin (bin (rel (blockp), 18) + tty_buf.absorig, 18), 18);
	     j = bin (buffer.tally, 18);
	     sub_mbx.word_cnt = 1 + divide (j + 3, 4, 18, 0);
	     buffer.next = 0;			/* indicate end of active write block */
	     sub_mbx.command_data (3) = gateway_header;	/* save buffer header in command_data (3) */
	     gateway_buf.cnt = j;
	     gateway_buf.pad = "0"b;
	     sub_mbx.io_cmd = wtx;			/* set write text io command */

	     if trace.buffer_out
	     then call syserr (SYSERR_log, "uncp: buffer = ^v( ^w ^) ", sub_mbx.word_cnt, blockp -> buf_words);

	     if pcb.connection_type = "01"b & sub_mbx.op_code = accept_direct_output
	     then string (sub_mbx.line_number) =
		     string (addr (fnp_info.pcb_array_ptr -> pcb_array (pcb.uncp_pcbx)) -> pcb.line_number);
	     pcb.output_mbx_pending = "1"b;
	     call send_mbx (mbx_num);			/* ship sub mbx off to 355 */
	     fnp_info.output_data_transactions = fnp_info.output_data_transactions + 1;
						/* meter */
	     if pcb.write_first = 0
	     then do;				/* see if we ran out of buffers */
		pcb.write_last = 0;			/* zero ptr to last */
		if interrupt_entry
		then call channel_manager$interrupt (devx, SEND_OUTPUT, ""b);
						/* wakeup the user */
	     end;
	end;

	return;					/* and return to caller */
     end;

/* internal procedure to respond to accept_input mailbox */

process_accept_input:
     proc;

	input_count = fixed (substr (sub_mbx.command_data (1), 1, 18), 18) + 4;
						/* get char count */

	j = divide (input_count + 3, 4, 17, 0);		/* compute number of words of circular buffer needed */

	do while (^stac (addr (uncp_buf.cq_lock), pds$processid));
						/* lock the circular queue lock */
	end;

	k = uncp_buf.cq_max_size - uncp_buf.cq_next;
	if j <= uncp_buf.cq_free			/* if there's space in the queue */
	then if enough_input_space (j)		/* and buffers to spare */
	     then do;
		if j > k
		then if j <= uncp_buf.cq_free - k
		     then uncp_buf.cq_next = 0;
		     else go to reject;

		qorig = tty_buf.absorig + fixed (rel (addr (uncp_buf.circular_queue (0))));
						/* get abs origin of circular buffer */

		uncp_buf.cq_free = uncp_buf.cq_free - j;/* decrement count of free wds in circ buf */

		if uncp_buf.circular_queue_size > MAX_FREE_BUFFERS
		then do;				/* getting too big */
		     uncp_buf.circular_queue_size = 0;	/* reset */
		     uncp_buf.queue_ave_cnt = 0;
		end;
		uncp_buf.circular_queue_size = uncp_buf.circular_queue_size +
						/* update the ave size */
		     (uncp_buf.cq_max_size - uncp_buf.cq_free);
						/* with current size */
		uncp_buf.queue_ave_cnt = uncp_buf.queue_ave_cnt + 1;
						/* bump q count */

		uncp_buf.circular_queue (uncp_buf.cq_next) = 0;
		sub_mbx.data_addr = bit (bin (qorig + uncp_buf.cq_next, 18), 18);
						/* leave abs buffer addr for 355 */
		uncp_buf.cq_next = uncp_buf.cq_next + j;/* compute new cb free area offset */

		wrap_ptr = "0"b;			/* clear wrap around ptr in sub mbx */
		wrap_cnt = 0;			/* and count in sub mbx */

		if uncp_buf.cq_next > uncp_buf.cq_max_size
		then do;				/* we have wrap around */
		     wrap_ptr = bit (bin (qorig, 18), 18);
						/* leave wrap around pointer in sub mbx */
		     uncp_buf.cq_next = uncp_buf.cq_next - uncp_buf.cq_max_size;
						/* adjust free buffer offset */
		     wrap_cnt = input_count - 4 * (j - uncp_buf.cq_next);
						/* leave wrap count in sub mbx */
		     sub_mbx.word_cnt = input_count - wrap_cnt;
						/* and adjust word count */
		end;



		else sub_mbx.word_cnt = j;		/* words count */

		if uncp_buf.cq_next = uncp_buf.cq_max_size
		then uncp_buf.cq_next = 0;		/* exactly end of cb */


		if trace.buffer_in
		then call syserr (SYSERR_log, "uncp$process_accept_input: cq_next = ^w , cq_free = ^w , count = ^w ",
			uncp_buf.cq_next, uncp_buf.cq_free, j);

		sub_mbx.op_code = input_accepted;	/* inform 355 that we will take input now */
		sub_mbx.io_cmd = rtx;
		call return_mbx (sub_mbx_no);
	     end;

	     else go to reject;

	else do;
	     uncp_buf.queue_full_cnt = uncp_buf.queue_full_cnt + 1;
						/* bump q full count */
reject:
	     sub_mbx.io_cmd = wcd;
	     sub_mbx.op_code = reject_request_temp;	/* inform 355 that we can not accept input
						   at the present time */
	     call return_mbx (sub_mbx_no);
	     fnp_info.input_reject_count = fnp_info.input_reject_count + 1;
	     call channel_manager$interrupt (devx, INPUT_REJECTED, ""b);
	end;

	if ^stacq (uncp_buf.cq_lock, "0"b, pds$processid)
	then call syserr (SYSERR_crash, "uncp: inconsistent circular queue lock.");

     end /* process_accept_input */;

/* internal proc to process rtx */
process_rtx:
     proc;

dcl  (real_word_cnt, real_wrap_cnt) fixed bin;
dcl  chars_to_move fixed bin;
dcl  left_in_buffer fixed bin;
dcl  char_array (0:numchars) char (1) unaligned based;

	sub_mbx.command_data (3) = "0"b;

	bufp = ptr (ttybp, bin (sub_mbx.data_addr, 24) - tty_buf.absorig);
	real_word_cnt = bufp -> unal_number;
	if real_word_cnt = 0
	then goto update_free;

	real_wrap_cnt = wrap_cnt;
	lcte.meters.in_bytes = lcte.meters.in_bytes + real_word_cnt;

	rtx_info.break_char = "1"b;
	call check_ff ("0"b);			/* see if input ends with a form feed */
	input_count = real_word_cnt + real_wrap_cnt;
	if input_count ^= 0				/* must have been a single FF that we discarded */
	then do;

	     rtx_info.output_in_fnp = "0"b;
	     rtx_info.output_in_ring_0 = (pcb.write_first ^= 0);
	     rtx_info.input_count = input_count;
	     if input_count > (tty_buf.bleft - abs_buf_limit) * 4
						/* not now though */
	     then go to no_input_space;

	     nblocks = divide (input_count + bsizec - 1, bsizec, 17, 0);
						/* figure out how many we'll need */
	     call tty_space_man$get_chain (devx, 16, nblocks, INPUT, inchain_ptr);
	     if inchain_ptr = null
	     then do;
no_input_space:
		call syserr (SYSERR_announce,
		     "uncp: Unable to allocate input buffers for line ^o, input has been lost",
		     string (pcb.line_number));
		call channel_manager$interrupt (devx, QUIT, ""b);
						/* get the word to him somehow */
		go to update_free;
	     end;
	     inchain = rel (inchain_ptr);

	     bufp = ptr (ttybp, bin (sub_mbx.data_addr, 24) - tty_buf.absorig + 1);
						/* get ptr to input buf */

	     if trace.buffer_in
	     then call syserr (SYSERR_log, "uncp: compte = ^w , buffer recu :  ^v( ^w ^) ", input_count,
		     divide (input_count + 3, 4, 17, 0), bufp -> buf_words);

	     chars_left = real_word_cnt + real_wrap_cnt;
	     blockp = inchain_ptr;			/* pointer to first buffer */
	     charp = addr (buffer.chars);
	     chars_to_move = real_word_cnt;		/* up to end of circular buffer */
	     left_in_buffer = bsizec;			/* initially */

	     do while (chars_left > 0);
		numchars = min (left_in_buffer, chars_to_move);
		charp -> chars = bufp -> chars;	/* chars is declared char (numchars) */
		chars_left = chars_left - numchars;
		chars_to_move = chars_to_move - numchars;
		buffer.tally = buffer.tally + numchars;

		if chars_left > 0			/* there are more to do */
		then do;
		     if chars_to_move <= 0		/* used up first set */
		     then if real_wrap_cnt > 0	/* are there any more? */
			then do;
			     bufp = addr (uncp_buf.circular_queue (0));
			     chars_to_move = real_wrap_cnt;
			end;
			else ;

		     else bufp = addr (bufp -> char_array (numchars));

		     if buffer.tally = bsizec		/* buffer is full */
		     then do;
			blockp = ptr (ttybp, buffer.next);
						/* so move to next */
			charp = addr (buffer.chars);
			left_in_buffer = bsizec;
		     end;

		     else do;
			charp = addr (charp -> char_array (numchars));
			left_in_buffer = left_in_buffer - numchars;
		     end;
		end;
	     end;

	     rtx_info.chain_head = inchain;
	     rtx_info.chain_tail = rel (blockp);
	     interrupt_info = unspec (rtx_info);
	     call channel_manager$interrupt (devx, ACCEPT_INPUT, interrupt_info);
	     pcb.turn = "1"b;
	     if pcb.lfecho
	     then pcb.send_lf = "1"b;
	end;

/* the following statement must generate an ASQ instruction or there will be a locking problem */


update_free:
	uncp_buf.cq_free = uncp_buf.cq_free + sub_mbx.word_cnt;

	call make_q_entry (accept_direct_output, 0, ""b);

	return;					/* and return to caller */

check_ff:
	proc (in_mbx);				/* internal procedure to check input for form-feed */

dcl  in_mbx bit (1);
dcl  wrapped bit (1);

	     rtx_info.formfeed_present = "0"b;		/* for now */
	     if pcb.sync_line			/* form feeds not interesting in this case */
	     then return;
	     wrapped = "0"b;



	     if wrap_ptr = "0"b
	     then do;
		bufp = ptr (ttybp, bin (sub_mbx.data_addr, 24) - tty_buf.absorig + 1);
		chars_left = real_word_cnt;
	     end;


	     if pcb.extra_nl
	     then substr (bufp -> input_chars, chars_left, 1) = "
";

	     if substr (bufp -> input_chars, chars_left, 1) = form_feed
						/* yup, input ends with FF */
	     then rtx_info.formfeed_present = "1"b;
	     if pcb.flags.end_frame & rtx_info.break_char /* time to restart suspended output */
	     then do;
		if (chars_left <= 2) & ^wrapped
		then if verify (substr (bufp -> input_chars, 1, chars_left), ff_cr_lf) = 0
		     then do;			/* this input is just to restart output, discard it */
			if in_mbx
			then numchars = 0;
			else real_word_cnt = 0;
		     end;
		pcb.flags.end_frame = "0"b;
		pcb.turn = "1"b;
		if pcb.enter_receive_pending
		then call make_q_entry (accept_direct_output, 0, "0"b);


		if pcb.flags.send_output		/* more output to ship */
		then if pcb.write_first ^= 0		/* it's waiting in tty_buf */
		     then call make_q_entry (accept_direct_output, 0, ""b);
						/* we'll get to it shortly */
		     else call channel_manager$interrupt (devx, SEND_OUTPUT, ""b);
	     end;

	end /* check_ff */;

     end /* process_rtx */;

/* internal proc to check if this channel can have input space */

enough_input_space:
     proc (count) returns (bit (1));

dcl  count fixed bin;

	lctp = tty_buf.lct_ptr;
	chan_lctep = addr (lct.lcte_array (devx));
	return (chan_lctep -> lcte.input_words + count <= divide (tty_buf.bleft, input_bpart, 17, 0));
     end /* enough_input_space */;


/* internal proc to put an element onto delay queue */

make_q_entry:
     proc (opc, cnt, databits);

dcl  (opc, cnt) fixed bin (8),			/* parameters */
     databits bit (8 * 36);

	call tty_space_man$get_space (size (q_entry), new_qp);
	if new_qp = null
	then do;
	     call syserr (SYSERR_crash, "uncp: unable to allocate block for delay queue");
	     return;
	end;

	if opc = accept_direct_output
	then pcb.flags.send_output = "0"b;		/* Correction for the untimely disconnects */
	new_qrel = bin (rel (new_qp));
	if fnp_info.cur_ptr = 0			/* nothing in the queue yet */
	then fnp_info.cur_ptr = new_qrel;
	else do;
	     qptr = ptr (ttybp, fnp_info.last_ptr);
	     q_entry.next = new_qrel;			/* make the preceding entry point to the new one */
	end;

	fnp_info.last_ptr = new_qrel;
	qptr = new_qp;
	fnp_info.count = fnp_info.count + 1;
	fnp_info.q_entries_made = fnp_info.q_entries_made + 1;

	q_entry.opcode = opc;			/* set q element op code */
	q_entry.cmd_count = cnt;			/* and command count */
	if pcbp ^= null ()
	then q_entry.pcb_offset = rel (pcbp);
	else q_entry.pcb_offset = "0"b;
	q_entry.next = 0;
	q_entry.cmd_data = databits;			/* move data to q element */
	return;					/* return to caller */
     end;

/* internal procedure to derive devx & PCB pointer from mailbox line number */

get_line_number:
     proc;

	pcbp = null;
	devx = -1;

	if string (sub_mbx.line_number) ^= "0"b
	then do;
	     sub_mbx.line_number.is_hsla = "1"b;	/* with uncp every line is high speed */
	     lano = sub_mbx.line_number.la_no;		/* get line adapter number for devx lookup */
	     if sub_mbx.is_hsla
	     then j = fnp_info.hsla_idx (fixed (lano));
	     else j = fnp_info.lsla_idx (fixed (lano));	/* get starting position */
	     do j = j to fnp_info.no_of_channels;	/* loop thru devx table */
		pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (j));
		if string (pcb.line_number) = string (sub_mbx.line_number)
		then go to match;			/* check for right slot */
	     end;
	     if (sub_mbx.io_cmd = rcd) & (sub_mbx.op_code = accept_new_terminal)
	     then do;
		devx = -1;
		return;
	     end;
	     else if sub_mbx.io_cmd ^= wcd
	     then do;
		call syserr (SYSERR_beep, "uncp$interrupt: no slot number match for sub mbx ^o, FNP ^a", i,
		     substr ("abcdefgh", dno, 1));	/* bitch */
		sub_mbx.io_cmd = 0;			/* To force an error */
	     end;
	     return;
match:
	     devx = pcb.devx;			/* copy devx to automatic */
	     if pcb.connection_type = "01"b
	     then do;
		other_pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (pcb.uncp_pcbx));
		devx = other_pcbp -> pcb.devx;
	     end;
	end;
	return;

     end /* get_line_number */;


/* internal procedure to locate and assign a free sub mailbox */

assign_sub_mbx:
     proc (a_sub_mbx_no, a_subp);

dcl  a_sub_mbx_no fixed bin;
dcl  a_subp ptr;
dcl  sub_mbx_num fixed bin;

	sub_mbx_num = index (used_string, "0"b) - 1;
	if sub_mbx_num = -1
	then do;					/* none available */
	     a_sub_mbx_no = -1;
	     a_subp = null ();
	     return;
	end;

	datanet_mbx.mbx_used_flags.used (sub_mbx_num) = "1"b;
						/* set used flag */
	datanet_mbx.num_in_use = datanet_mbx.num_in_use + 1;
	fnp_info.max_mbx_in_use = max (fnp_info.max_mbx_in_use, datanet_mbx.num_in_use);
	fnp_info.cumulative_mbx_in_use = fnp_info.cumulative_mbx_in_use + datanet_mbx.num_in_use;
	fnp_info.mbx_in_use_updated = fnp_info.mbx_in_use_updated + 1;
	unspec (datanet_mbx.dn355_sub_mbxes (sub_mbx_num)) = "0"b;
	sub_mbx_sent = "0"b;
	a_sub_mbx_no = sub_mbx_num;
	a_subp = addr (datanet_mbx.dn355_sub_mbxes (sub_mbx_num));
	return;
     end assign_sub_mbx;
%skip (3);
/* internal procedure to release a sub mailbox when it wasn't really needed */

release_sub_mbx:
     proc (a_sub_mbx_no);

dcl  a_sub_mbx_no fixed bin;

	if a_sub_mbx_no < 0 | a_sub_mbx_no > 6
	then return;				/* not a valid mbx# */
	datanet_mbx.mbx_used_flags.used (a_sub_mbx_no) = "0"b;
						/* reset used flag */
						/* and decrement counters */
	fnp_info.cumulative_mbx_in_use = fnp_info.cumulative_mbx_in_use - datanet_mbx.num_in_use;
	fnp_info.mbx_in_use_updated = fnp_info.mbx_in_use_updated - 1;
	datanet_mbx.num_in_use = datanet_mbx.num_in_use - 1;
	return;
     end release_sub_mbx;


/* internal procedure to ship sub mbx off to 355 */
return_mbx:
send_mbx:
     proc (a_mbx_no);

dcl  a_mbx_no fixed bin;
dcl  mbx_no fixed bin;
dcl  counter fixed bin;
dcl  output_data_ptr ptr;
dcl  output_data (3) bit (36) aligned based (output_data_ptr);
dcl  1 ima aligned like io_manager_arg;

	mbx_no = a_mbx_no;
	if mbx_no = -1				/* caller running with local copy */
	then do;
	     call assign_sub_mbx (mbx_no, subp);	/* find a free sub mbx */
	     if mbx_no = -1				/* OUCH! Should have had one! */
	     then do;
		call syserr (SYSERR_crash, "uncp: unable to re-assign fnp sub-mailbox.");
		return;
	     end;
	     unspec (sub_mbx) = unspec (local_sub_mbx);	/* copy in local info */
	     a_mbx_no = mbx_no;
	end;

	if ^fnp_info.io_manager_assigned
	then do;
	     no_response = "1"b;			/* lie, but effectively */
	     return;
	end;

	do counter = 1 to LOOP_LIMIT while (datanet_mbx.dia_pcw.command ^= "0"b);
						/* loop until dia picks up last command */
	end;
	if counter > LOOP_LIMIT			/* it never did */
	then no_response = "1"b;

	else do;
	     no_response = "0"b;

	     if (mbx_no >= 0) & (mbx_no <= 6)
	     then do;
		sub_mbx.dn355_no = substr (bit (fnp_info.fnp_number), 7);
		if sub_mbx.op_code = enter_receive
		then do;
		     sub_mbx.io_cmd = wtx;
		     output_data_ptr = fnp_info.dcw_list_array_ptr;
		     output_data (*) = ""b;

		     sub_mbx.command_data (1) = "0"b;
		     sub_mbx.command_data (2) = "0"b;
		     sub_mbx.command_data (3) = "0"b;
		     if pcb.send_lf
		     then do;
			sub_mbx.op_code = accept_direct_output;
			unspec (output_data (2)) = "000001000000"b3;
			unspec (output_data (3)) = "012000000000"b3;
			sub_mbx.word_cnt = 2;
			sub_mbx.data_addr =
			     bit (bin (tty_buf.absorig + fixed (rel (addr (output_data (2)))), 18), 18);
			pcb.send_lf = "0"b;
		     end;
		     else do;
			sub_mbx.op_code = accept_last_output;
			output_data (1) = "0"b;
			sub_mbx.word_cnt = 1;
			sub_mbx.data_addr =
			     bit (bin (tty_buf.absorig + fixed (rel (addr (output_data (1)))), 18), 18);
			pcb.enter_receive_pending, pcb.turn = "0"b;
		     end;
		     call get_line_number;
		     pcb.output_mbx_pending = "1"b;
		end;

		if sub_mbx.op_code = accept_last_output
		then do;
		     call get_line_number;
		     if pcb.connection_type = "10"b
		     then do;
			pcb.turn = "1"b;
			sub_mbx.op_code = accept_direct_output;
		     end;
		end;

		if (sub_mbx.io_cmd = rtx) | (sub_mbx.io_cmd = wtx)
		then sub_mbx.pad3 = (15)"0"b3 || "777"b3;
	     end;

	     sub_mbx.line_number.is_hsla = "0"b;	/*  for the line_number into uncp */

	     if trace.mailbox
	     then call syserr (SYSERR_log, "uncp$send_mbx: # ^o ^2( ^/ ^4( ^w ^) ^)", mbx_no, sub_mbx_array);

	     string (datanet_mbx.dia_pcw) = initial_pcw;	/* initialize pcw */
	     datanet_mbx.dia_pcw.mbx_no = bit (fixed (mbx_no + 1, 6), 6);
						/* set sub mbx number */

	     string (datanet_mbx.dia_pcw) = dn355_util$compute_parity (string (datanet_mbx.dia_pcw));
						/* set the parity bit; bit 22 */


	     ima.chx = fnp_info.io_manager_chx;
	     ima.ptp = fnp_info.ptp;
	     call io_manager$connect_direct (ima);	/* kick 355 */
	     sub_mbx_sent = "1"b;			/* show actual use of mbx */

	     return;				/* return to caller */
	end;
     end send_mbx;

/* entry and internal proc to hangup all lines on an FNP */

hangup_fnp_lines:
     entry (a_fnp_no);

dcl  a_fnp_no fixed bin;

	infop = addr (dn355_data$);
	ttybp = addr (tty_buf$);
	uncpbp = datanet_info.uncp_bufp;
	call hangup_fnp (a_fnp_no);
	return;


hangup_fnp:
     proc (fnp_no);

dcl  fnp_no fixed bin;

	fnpp = addr (datanet_info.per_datanet (fnp_no));
	do j = 1 to fnp_info.no_of_channels;
	     pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (j));
	     if pcb.dialed
	     then do;
		call throw_away_output;
		if pcb.connection_type ^= "10"b
		then call channel_manager$interrupt ((pcb.devx), CRASH, ""b);
	     end;
	end;

	if fnp_info.count > 0			/* get rid of any outstanding delay queue entries */
	then do;
	     q_count = fnp_info.count;
	     q_first = fnp_info.cur_ptr;
	     do q_count = q_count to 0 by -1 while (q_first ^= 0);
		qptr = ptr (ttybp, q_first);		/* get real pointer to queue entry */
		q_first = qptr -> q_entry.next;	/* save pointer to next one */
		call tty_space_man$free_space (size (q_entry), qptr);
	     end;

	     fnp_info.count, fnp_info.cur_ptr, fnp_info.last_ptr = 0;
	end;

     end;



throw_away_output:
     proc;

/* throws away pending write chain on quit and hangup */

	if pcb.write_first ^= 0
	then do;
	     call tty_space_man$free_chain ((pcb.devx), OUTPUT, ptr (ttybp, pcb.write_first));
	     pcb.write_first, pcb.write_last, pcb.write_cnt = 0;

	end;

	pcb.end_frame = "0"b;

	return;
     end /* throw_away_output */;

/* internal procedure to report that DIA never set PCW to 0 */

report_fnp_no_response:
     proc;

	call syserr (SYSERR_beep, "uncp: FNP ^a did not respond to mailbox interrupt", fnp_info.fnp_tag);
	call report_fnp_crash;			/* treat it like a crash */
	return;

     end /* report_fnp_no_response */;


/* internal procedure to tell initializer and clean up when FNP crashes */

report_fnp_crash:
     proc;

	fnp_info.running = "0"b;			/* it isn't any more */

/*		if fnp_info.dump_patch_in_progress	 somebody's waiting for this */
/*		then call pxss$notify (FNP_DUMP_PATCH_EVENT);  don't let them wait forever */

	if ^fnp_info.bootloading			/* if we weren't still loading it */
	then					/* now report hangups for all lines that were dialed to it */
	     call hangup_fnp (dno);
	else fnp_info.bootloading = "0"b;

	auto_fnp_msg.state = FNP_DOWN;		/* tell the responsible process */
	auto_fnp_msg.fnp_no = dno;
	auto_fnp_msg.flags = "0"b;
	unspec (fnp_event_message) = unspec (auto_fnp_msg);
	call pxss$ring_0_wakeup (fnp_info.boot_process_id, fnp_info.boot_ev_chan, fnp_event_message, 0);

	return;

     end report_fnp_crash;

purge_write_texte:
     proc;
	do i = 0 to 6;
	     if timwb (i)
	     then do;
		subp = addr (datanet_mbx.dn355_sub_mbxes (i));
		call get_line_number;
		if sub_mbx.io_cmd = wtx
		then do;
		     if pcb.output_mbx_pending & sub_mbx.command_data (3) ^= "0"b
		     then do;
			da = bin (sub_mbx.data_addr, 18) - tty_buf.absorig;
			blockp = ptr (ttybp, da);	/* set ptr to buffer */
			if pcb.connection_type = "10"b
			then pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (pcb.uncp_pcbx));
			gateway_header = sub_mbx.command_data (3);
			call tty_space_man$free_chain ((pcb.devx), OUTPUT, blockp);
		     end;
		end;
		if sub_mbx.io_cmd = rtx
		then if sub_mbx.word_cnt ^= 0
		     then do;
			uncp_buf.cq_free = uncp_buf.cq_free + sub_mbx.word_cnt;
			sub_mbx.word_cnt = 0;
		     end;
		datanet_mbx.mbx_used_flags.used (i) = "0"b;
		datanet_mbx.num_in_use = datanet_mbx.num_in_use - 1;
	     end;
	end;
	return;
     end;						/* purge_write_texte */

check_lock:
     proc;

/* the cleanup procedure -- makes sure we don't crawl out with lock set */

	if queue_locked
	then call syserr (SYSERR_crash, "uncp: attempted crawlout with FNP queue locked");

	else if masked
	then call pmut$unwire_unmask (wire_arg, wire_ptr);/* it's probably too late, but just in case */

	return;
     end check_lock;
%page;

/* Begin message documentation invisible

   *  This documentation lacks the standard token heading but rather uses
   *  lowercase and the keyword invisible so that the messages documented
   *  below will not be included in the standard error message documentation
   *  shipment.

   Message:
   uncp: invalid interrupt level N

   S:  $beep

   T:  $run

   M:  An FNP interrupt has been received with an invalid interrupt level of
   octal value N and will be ignored.  If this message is displayed when a
   DN6670 is being powered up, this message can be ignored.  If this message
   occurs under any other circumstances, there might be something wrong with
   the system's interface with the FNP and should be investigated by FE
   representatives.

   A:  $inform


   Message:
   uncp: emergency interrupt from FNP X: FAULT
   .br
   FNP instruction counter = IC
   .br
   channel CHN, fault status = FS
   .br
   FNP_MODULE: REASON_FOR_CRASH

   S:  $beep

   T:  $run

   M:  An emergency interrupt has been received from FNP X indicating
   it has crashed.  All lines dialed to FNP X will be hung up.  The
   crash was nominally caused by a fault of type FAULT.  Lines
   following the first line of the message appear only in certain cases
   and provide additional information about the nature of the crash.

   A:  The system will automatically attempt to reboot the crashed FNP.
   Subsequent messages will indicate the success or failure of this attempt.
   No action is required now, but action may be required if the
   automatic reboot fails.


   Message:
   uncp$interrupt: no slot number match for sub mbx N, FNP X

   S:  $beeper

   T:  $run

   M:  An error has occurred processing submailbox N for FNP X.
   The submailbox indicates a line number for which no match could
   be found.

   A:  $inform


   Message:
   uncp: Message from FNP X: MESSAGE

   S:  $info

   T:  $run

   M:  An error has been detected by FNP X as explained by MESSAGE.

   A:  No action is required by the operator to deal with the error mentioned
   in the message.  Action may be required by appropriate personnel to correct
   the problem that caused the error and undo what the FNP may have done to
   continue operation.  This may require shutting down the FNP for repairs by
   Field Engineering and reboot of the FNP to restore full operation.


   Message:
   uncp$interrupt: unrecognized op code OPCODE with rcd from FNP X for devx N

   S:  $beeper

   T:  $run

   M:  An invalid op code, OPCODE, has been received from FNP X for device
   index N in a mailbox containing an rcd (read control data) command.

   A:  $inform


   Message:
   uncp$interrupt: unrecognized io command from FNP X for line N

   S:  $beeper

   T:  $run

   M:  An invalid io command was received from FNP X for line N.

   A:  $inform


   Message:
   uncp: output buffer at N has zero tally

   S:  $crash

   T:  $run

   M:  An output buffer with a zero tally has been found at offset N
   in the segment tty_buf.

   A:  $inform


   Message:
   uncp: unable to allocate block for delay queue

   S:  $crash

   T:  $run

   M: There was insufficient space left in tty_buf to allocate a block
   in which to build a delay queue.

   A:  $inform


   Message:
   FNP X did not respond to mailbox interrupt

   S:  $beep

   T:  $run

   M:  An attempt to interrupt FNP X was unsuccessful. The FNP is assumed
   to be down.

   A:  The system will automatically attempt to reboot the crashed FNP.
   Subsequent messages will indicate the success or failure of this attempt.
   No action is required now, but action may be required if the
   automatic reboot fails.


   Message:
   uncp: inconsistent queue lock

   S:  $crash

   T:  $run

   M:  A process attempted to unlock the interrupt queue lock without having it
   locked.

   A:  $inform


   Message:
   uncp: LCTE lock ^= processid

   S:     $crash

   T:     $run

   M:  The FNP channel lock did not contain the processid of the process
   attempting to unlock it.


   Message:
   uncp: attempted crawlout with FNP queue locked

   S:	$crash

   T:	$run

   M:	An attempt was made to crawl out while an FNP queue lock (a processor
   lock) was locked.

   A:	$inform


   Message:
   uncp$interrupt: line number of 0 with non-global opcode in submbx N, FNP X

   S:  $beeper

   T:  $run

   M:  Mailbox N from FNP X contained a non-global opcode which requires a
   non-zero line number.


   Message:
   uncp: unable to re-assign fnp sub-mailbox.

   S:	$crash

   T:	$run

   M:	During interrupt processing the sub-mailbox from the FNP is
   copied to local storage and the sub-mbx freed.  As part of handling the
   interrupt a need to return information to the FNP was found.  However the
   sub-mbx could not be re-assigned.
   $err

   A:	$inform
   $recover

   End message documentation invisible */


     end uncp;
