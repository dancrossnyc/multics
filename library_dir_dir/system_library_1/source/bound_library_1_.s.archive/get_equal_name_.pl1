/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* N__a_m_e:  get_equal_name_							*/
	/*									*/
	/*      This subroutine implements the Multics Storage System Equals Convention.	*/
	/* A target name is constructed by combining components and subcomponents from an 	*/
	/* entry name and an equal name which are supplied as arguments.  The construction	*/
	/* follows the rules given under "Equal Names" in Section 3 of the MPM Reference Guide.	*/
	/*									*/
	/* U__s_a_g_e									*/
	/*									*/
	/*      dcl  get_equal_name_ entry (char(*), char(*), char(32), fixed bin(35));		*/
	/*									*/
	/*      call get_equal_name_ (entry, equal, target, code);				*/
	/*									*/
	/* 1) entry	is the entry name. (In)					*/
	/*									*/
	/* 2) equal	is the equal name. (In)					*/
	/*									*/
	/* 3) target	is the target name which is constructed. (Out)			*/
	/*									*/
	/* 4) code	is a status code, which may be one of the following. (Out)		*/
	/*									*/
	/*    0		the target name was constructed without error.			*/
	/*									*/
	/*    error_table_$bad_equal_name						*/
	/*		the equal name has a bad format.				*/
	/*									*/
	/*    error_table_$badequal							*/
	/*		there was no letter or component in the entry name which corresponds	*/
	/*		to a % or = in the equal name.  A null string will be used for the	*/
	/*		missing letter or component in the target name which is returned.	*/
	/*									*/
	/*    error_table_$longeql							*/
	/*		the target name to be constructed is longer than 32 characters.	*/
	/*		Only the first 32 characters are returned.			*/
	/*									*/
	/* S__t_a_t_u_s									*/
	/*									*/
	/* 0) Created:  July, 1973 by G. C. Dixon					*/
	/*	a) This program replaces equal_, which is now obsolete.			*/
	/* 1) Modified: June 15, 1979 by G. Palter					*/
	/*	a) Added the triple equal component.					*/
	/* 2) Modified: 3 April 1981 by G. Palter					*/
	/*	a) Added the component entrypoint for the archive component equal name	*/
	/*	   convention							*/
	/*	b) Added the check_equal_name_ entrypoint which validates the syntax and	*/
	/*	   of a supplied equal name						*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */



	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* A__l_g_o_r_i_t_h_m								*/
	/*									*/
	/*      The basic algorithm used to construct the target name is:			*/
	/*									*/
	/* 1) Parse the equal name into components and subcomponents.			*/
	/*    a) each name component is classified into one of the following types:		*/
	/*	         _t_y_p_e      _f_o_r_m_a_t	_d_e_s_c_r_i_p_t_i_o_n				*/
	/*		13	===	a triple equal sign component			*/
	/*		14	==	a double equal sign component			*/
	/*		15	OO	a component of one or more other characters	*/
	/*				(characters besides "=", "%", or ".")		*/
	/*		16	O=%	a component containing %'s or ='s and other chars	*/
	/*		17	=	a single equal sign component			*/
	/*		18	BAD	a bad equal name component format.		*/
	/*    b) each component is, in turn, divided into one or more subcomponents of the	*/
	/*       following types:							*/
	/*	         _t_y_p_e      _f_o_r_m_a_t	_d_e_s_c_r_i_p_t_i_o_n				*/
	/*		1	O's	a string of one or more consecutive other chars.	*/
	/*		2	%'s	a string of one or more consecutive %'s.	*/
	/*		3	='s	a string of one, two, or three consecutive ='s.	*/
	/*       Thus, component types === (13), == (14), OO (15), and = (17) are each composed	*/
	/*       of a single subcomponent, and component type O=% (16) is composed of two	*/
	/*       or more components.							*/
	/*									*/
	/* 2) Parse the entry name into components.					*/
	/*									*/
	/* 3) Construct the target name from the parsed equal and entry names.		*/
	/*									*/
	/*      The hardest part of this process is the parsing of the equal name into components	*/
	/* and subcomponents, while at the same time checking for a bad equal name.  The 	*/
	/* current restraints on the format of equal names are:				*/
	/*									*/
	/* 1) The equal name is an entry name composed of 32 or fewer ASCII characters		*/
	/*    or spaces, excluding ">" and "<".  That is,					*/
	/*	0 < length(equal) <= 32						*/
	/*	E_i <= PAD								*/
	/*	       E_i ^= ">"							*/
	/*	       E_i ^= "<"							*/
	/*    where E_i are the characters of the equal name.				*/
	/*									*/
	/* 2) The equal name is composed of from one to sixteen components, none of which may	*/
	/*    be null.  That is, the equal name may not begin or end with a period ("."), and	*/
	/*    may not contain two or more consecutive periods.				*/
	/*									*/
	/* 3) Each component of an equal name may contain one or more %'s, each of which	*/
	/*    represents the corresponding letter in the corresponding component of the entry	*/
	/*    name.								*/
	/*									*/
	/* 4) Each equal name component may contain one =, which represents the corresponding	*/
	/*    component of the entry name.  An equal component which contains an = may not	*/
	/*    contain %'s.								*/
	/*									*/
	/* 5) An equal name may contain, at most, one == (double equal sign) component in	*/
	/*    any component position which represents all components of the entry name		*/
	/*    which are not represented by other components of the equal name.		*/
	/*									*/
	/* 6) An equal name may contain one or more === (triple equal sign) components in any	*/
	/*    component position which represents the original name.  If === is used, no	*/
	/*    == component or component containing %'s or ='s may be used.			*/
	/*									*/
	/*									*/
	/*									*/
	/*      Each component of the equal name is parsed by a finite state machine, the diagram	*/
	/* of which is shown below.  The process of parsing each component begins in state _s_t_a_r_t	*/
	/* and it continues through the machine, according to the characters of the equal name	*/
	/* component ("=", "%", ".", or another character) until a period ends the component, or	*/
	/* until all of the characters of the equal name have been exhausted.  The parsing	*/
	/* process identifies bad equal names (terminal state B_A_D_), and it also classifies each	*/
	/* valid  component as being one of the component types mentioned above.  The type is	*/
	/* defined to be the state value of the finite state machine when the component has been	*/
	/* parsed.  During the parsing, information about the location and length of each	*/
	/* component and subcomponent is gathered for later use during the construction of the	*/
	/* target name.								*/

	/*                                                 _________
	                                                  |         |
	                                ------------------|  start  |--------------
	                                |                %|________0_|=            |
	                                |                  .|     |O              |
	                                |                   |     |               |
	                                |                   V     |               |
	                                |                18(BAD)  |               |
	                                |                         |               |
	                                |                  _______V__              |
	                                |                 |         |             |
	                                |     ------------|    O    |--------     |
	                                |     |          %|________1_|=      |     |
	                                |     |            .|     |O        |     |
	                                |     |             |     |         |     |
	       16(O%=)   18(BAD)        |     |             V     |         |     |
	            A     A             |     |          15(OO)   |         |     |
	            |     |             |     |                   |         |     |
	           .__|_______|=_  %        _V______V__           _______V__ O      |     |
	      --->|         |-------->|         |        %|         |----   |     |
	      |   |   %OO   |  ------>|    %    |<--------|   OO    |   |   |     |
	      ----|________7_|  | -----|________4_|         |________5_|<---   |     |
	         O     A       | |   O .| %|  |=           .|     |=        |     |
	               |       | |      |  |  |             |     |         |     |
	               |       | |      V  |  V             V     |         |     |
	               |       | | 16(O%=) | 18(BAD)    15(OO)    |         |     |
	               |       | |         |                      |         |     |
	           ___O__|____ % | |     ____V_____ %         _______V__        |     |
	          |         |--- |    |         |----     |         |       |     |
	          |   %O    |<----    |   %%    |   |     |   O=    |<-------     |
	          |________3_|<--------|________8_|<---     |________9_|             |
	           .|     |=         O .|     |=           .|     |O              |
	            |     |             |     |             |     |               |
	            V     V             V     V             V     |               |
	       16(O%=)   18(BAD)   16(O%=)   18(BAD)   16(O%=)    |               |
	                                                          |               |
	                                                   _______V__           ___V______
	                                                %=|         |        O|         |%
	                                       18(BAD)<---|   =O    |<--------|    =    |--->18(BAD)
	                                                  |________2_|         |_______1_0_|
	                                                   .|     |O           .|     |=
	                                                    |     |             |     |
	                                                    V     |             V     |
	                                               16(O%=)    |          17(=)    |
	          -------|                                        |                   |
	          |   ___V______                            _______V___ O         _______V___
	          |  |         |O%=                     %=|         |----     |         |O%
	          |  |    ==   |--->18(BAD)    18(BAD)<---|   =OO   |   |     |   ==    |--->18(BAD)
	          |  |______1_2__|                          |________6_|<---     |_______1_1_|
	          |      .|                                   .|               =|    .|
	          |       |                                    |                |     |
	          |       V                                    V                |     V
	          |     13(===)                             16(O%=)             |   14(==)
		|						  |
                    ---------------------------------------------------------------		
										*/
	/* The finite state machine is defined by the variable, nstate, in the program below.	*/


get_equal_name_:	procedure (Aentry, Aequal, Atarget, code);

     dcl	Aentry			char(*),		/* the entry name. (In)			*/
	Aequal			char(*),		/* the equal name. (In)			*/
	Atarget			char(32),		/* the target name. (Out)			*/
	code			fixed bin(35);	/* the status code returned.(Out)		*/

     dcl	P_entryname		char(*) parameter,	/* archive/entry name. (In)			*/
	P_component		char(*) parameter,	/* component name. (In)			*/
	P_equal_entryname		char(*) parameter,	/* archive/entry equal name. (In)		*/
	P_equal_component		char(*) parameter,	/* component equal name. (In)			*/
	P_target_entryname		char(32) parameter, /* target archive/entry name. (Out)		*/
	P_target_component		char(32) parameter; /* target component name. (Out)		*/

     dcl	P_equalname		char(*) parameter;	/* equal name to be validated. (In)		*/

     dcl	1 Cen (33)		aligned automatic,	/* array elements identify entry name components.	*/
	  2 Ien			fixed bin,	/* index of component into entry name.		*/
	  2 Len			fixed bin,	/* length of component.			*/
	1 Ceq (17)		aligned automatic,	/* array elements identify equal name components.	*/
	  2 Ieq			fixed bin,	/* index of component into equal name.		*/
	  2 Leq			fixed bin,	/* length of component.			*/
	  2 Teq			fixed bin,	/* type of component:			*/
						/*   13 = === (triple equal sign component)	*/
						/*   14 = == (double equal sign component)	*/
						/*   15 = O or OO				*/
						/*   16 = O=, =O, =OO, %, %%, %O, or %OO	*/
						/*   17 = = (single equal sign component)	*/
						/*   18 = bad equal name format		*/
	  2 SCeq			fixed bin,	/* index into Csub of 1st subcomponent of this	*/
						/* component.				*/
	1 Csub (32)		aligned,		/* table of subcomoponents of the equal name.	*/
	  2 Isub			fixed bin,	/* index into component of start of subcomponent.	*/
	  2 Lsub			fixed bin,	/* length of subcomponent.		*/
	  2 Tsub			fixed bin,	/* type of subcomponent:			*/
						/*   1 = O's (other chars besides =, %, or .)	*/
						/*   2 = %'s				*/
						/*   3 = =				*/
	Lentry			fixed bin,	/* real length of the entry name.		*/
	Lequal			fixed bin,	/* real length of the equal name.		*/
	Nen			fixed bin,	/* number of components in the entry name.	*/
	Neq			fixed bin,	/* number of components in the equal name.	*/
	Nequalequal		fixed bin,	/* number of any double equal sign component.	*/
	Nsub			fixed bin,	/* number of subcomponents in the equal name.	*/
	archive_equal_code		fixed bin(35),	/* status code for archive name's processing.	*/
	char			char(1) aligned,	/* a character temp.			*/
	double_equal		bit(1) aligned,	/* on if == component has already been parsed.	*/
	triple_equal		bit(1) aligned,	/* on if one or more === components found.	*/
	other_equal		bit(1) aligned,	/* on if components with %'s or ='s found.	*/
	check_entry		bit(1) aligned,	/* on if check_equal_name_ called.		*/
	original_archive		bit(1) aligned,	/* on if original name has archive & component.	*/
	target_archive		bit(1) aligned,	/* on if target will have archive & component.	*/
	entry			char(32) aligned,	/* aligned copy of entry name.		*/
	equal			char(32) aligned,	/* aligned copy of equal name.		*/
	entryname			char(32),		/* copy of input archive name w/o ".archive".	*/
	equal_entryname		char(32),		/* copy of archive equal name w/o ".archive".	*/
	i			fixed bin,	/* a do-group index.			*/
	j			fixed bin,	/* a do-group index.			*/
	state			fixed bin,	/* number of finite state machine's current state.*/
	target			char(34) varying aligned;
						/* target name being constructed.  Its 1st char	*/
						/* is always a "." which is ignored.  After	*/
						/* construction, if its length is greater than	*/
						/* 33 (32 + 1st char), then it is too long.	*/

     dcl	1 Oentry			aligned based (addr (entry)),
	  2 char (33)		char(1) unal,	/* overlay for entry name.			*/
	1 Oequal			aligned based (addr (equal)),
	  2 char (33)		char(1) unal;	/* overlay for equal name.			*/

     dcl (addr, length, rtrim, substr)	builtin;

     dcl	PAD			char(1) aligned static options (constant) initial (""),
						/* An ASCII PAD character \177.		*/
	Tbad			fixed binary static options (constant) initial (18),
						/* type code used for bad star name.		*/
	Tequal			fixed binary static options (constant) initial (17),
						/* type code used for single equal name component	*/
	Totherother		fixed binary static options (constant) initial (15),
						/* type code used for simple component.		*/
	Tequalequal		fixed binary static options (constant) initial (14),
						/* type code used for double equal name component.*/
	Tequalequalequal		fixed binary static options (constant) initial (13),
						/* type code used for triple equal name component.*/

         (error_table_$bad_equal_name,
	error_table_$badequal,
	error_table_$entlong,
	error_table_$longeql,
	error_table_$no_archive_for_equal)
				fixed binary (35) external,

	nstate (0:12, 4)		fixed binary static options (constant) initial (
				/*							*/
				/*	TABLE OF NEXT STATES				*/
				/*							*/
				/* Current	 E q u a l   N a m e   C h a r a c t e r	*/
				/* _S__t_a_t_e_	"_._"_	"_=_"_	"_%_"_     O__t_h_e_r		*/
				/*							*/
				/*    0	*/	18,	10,	 4,	 1,
				/*    1	*/	15,	 9,	 4,	 5,
				/*    2	*/	16,	18,	18,	 6,
				/*    3	*/	16,	18,	 4,	 7,
				/*    4	*/	16,	18,	 8,	 3,
				/*    5	*/	15,	 9,	 4,	 5,
				/*    6	*/	16,	18,	18,	 6,
				/*    7	*/	16,	18,	 4,	 7,
				/*    8	*/	16,	18,	 8,	 3,
				/*    9	*/	16,	18,	18,	 2,
				/*   10	*/	17,	11,	18,	 2,
				/*   11	*/	14,	12,	18,	18,
				/*   12   */	13,	18,	18,	18);

/*  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */



	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/*	1) compute and validate real length of equal name.			*/
	/*	2) parse equal name into components and subcomponents.			*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	check_entry = "0"b;

	Lequal = length (rtrim (Aequal));
	if Lequal > 32 then				/* an equal name longer than 32 chars is bad.	*/
	     go to bad_equal_name;
	if Lequal = 0 then				/* a null equal name is bad.			*/
	     go to bad_equal_name;

	equal = Aequal;				/* copy equal name to aligned temp for efficiency.*/

	call parse_equal_name;			/* parse it into components and subcomponents.	*/

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/*	1) compute real length of entry name, making sure its not too long.		*/
	/*	2) if equal name was "===",  "==", "==.=", or "=.==" then look no further.	*/
	/*	   Target is a copy of the entry name.					*/
	/*	3) else finish computing length of entry name.				*/
	/*	4) parse entry name into components.					*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	Lentry = length (rtrim (Aentry));
	if Lentry > 32 then				/* ignore any chars beyond the 32nd.		*/
	     Lentry = 32;

	if Neq = 1 then
	     if (Teq(1) = Tequalequalequal) | (Teq(1) = Tequalequal) then
		go to copy;			/* equal = "===" or "=="			*/
	     else;
	else if Neq = 2 then
	     if Teq(1) = Tequalequal then
		if Teq(2) = Tequal then
		     go to copy;			/* equal = "==.="				*/
		else;
	     else if Teq(1) = Tequal then
		if Teq(2) = Tequalequal then
		     go to copy;			/* equal = "=.=="				*/

	entry = Aentry;				/* copy entry name to aligned temp for efficiency.*/

	Nen = 1;					/* parse entry name into components.		*/
	Ien(1) = 1;
	Len(1) = 0;
	do i = 1 to Lentry;
	     if Oentry.char(i) = "." then do;
		Nen = Nen + 1;
		Ien(Nen) = i + 1;
		Len(Nen) = 0;
		end;
	     else
		Len(Nen) = Len(Nen) + 1;
	     end;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/*	Build target name from entry name and equal name by:			*/
	/*	1) constructing target components corresponding to the equal name components 	*/
	/*	   appearing before any double equal sign component.			*/
	/*	2) constructing target components corresponding to the double equal sign.	*/
	/*	3) constructing target components corresponding to the equal name components	*/
	/*	   appearing after any double equal sign component.			*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	target = "";				/* initialize the target. So far, it has 0 length.*/
	code = 0;					/* initialize return code, so that copy programs	*/
						/* can fill in error code if they find one.	*/
	if double_equal then do;			/* if a double equal sign component was found,	*/
	     do i = 1 to Nequalequal - 1;		/* first process equal components up to ==.	*/
		target = target || ".";		/* append "." to target ("." preceding 1st 	*/
						/* component will be ignored when copying target	*/
						/* into Atarget, below).			*/
		call copy_ (i, i);
		end;

	     do i = Nequalequal to Nen - (Neq - Nequalequal);
		target = target || ".";		/* then process components of entry name which	*/
		call copy_ (Nequalequal, i);		/* correspond to the ==.			*/
		end;

	     Nequalequal = i - Nequalequal - 1;
	     do i = i to Nen;			/* finally, process remaining components of 	*/
		target = target || ".";		/* the equal name.				*/
		call copy_ (i - Nequalequal, i);
		end;

	     do i = i + 1 to Neq;			/* if there were no components of entry name	*/
		target = target || ".";		/* which correspond to the == component, then	*/
		call copy_ (i, i);			/* copy any remaining components of equal name	*/
		end;				/* into the target name.			*/
	     end;

	else 					/* if no double equal sign component was found,	*/
	     do i = 1 to Neq;			/* then just process each equal name component.	*/
		target = target || ".";
		call copy_ (i, i);
		end;

	Atarget = substr (target, 2);			/* copy target into parm, ignoring 1st "."	*/
	if length (target) > 33 then			/* if target (minus leading ".") was too long,	*/
	     go to long;				/* then tell caller.			*/
	return;


copy:	Atarget = Aentry;				/* The target name is the same as the entry name.	*/
	code = 0;
	return;

bad_equal_name:
	code = error_table_$bad_equal_name;		/* The equal name has a bad format.		*/
	if ^check_entry then
	     Atarget = "";
	return;

long:	code = error_table_$longeql;			/* the target would be too long.		*/
	return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
/*  */

/* Implement the archive component pathname equal convention:  See MPM Reference Guide for a description of this
   convention */

component:
     entry (P_entryname, P_component, P_equal_entryname, P_equal_component, P_target_entryname, P_target_component, code);

	P_target_entryname, P_target_component = "";	/* initialize output parameters */
	code = 0;

	if (length (rtrim (P_entryname)) > 32) | (length (rtrim (P_component)) > 32)
	then do;					/* original name is too long */
	     code = error_table_$entlong;
	     return;
	end;

	if (length (rtrim (P_equal_entryname)) > 32) | (length (rtrim (P_equal_component)) > 32)
	then do;					/* equal name is too long */
COMPONENT_BAD_EQUAL_NAMES:
	     code = error_table_$bad_equal_name;
	     return;
	end;

	if (P_equal_entryname = "") then		/* this one can not be a null string */
	     go to COMPONENT_BAD_EQUAL_NAMES;


/* Classify the original and target names with respect to archive components */

	original_archive = (P_component ^= "");		/* original name uses archive components */

	target_archive = (P_equal_component ^= "");	/* target name will use archive components */


	if ^original_archive & ^target_archive
	then do;

/* Case 1: original and target names are not archive component names */

	     call get_equal_name_ (P_entryname, P_equal_entryname, P_target_entryname, code);
	end;					/* do the actual work */


	else if original_archive & ^target_archive
	then do;

/* Case 2: original is archive component name and target is not an archive component name:  Apply the equal name specified
	 for the target to the component name of the original */

	     call get_equal_name_ (P_component, P_equal_entryname, P_target_entryname, code);
	end;


	else if ^original_archive & target_archive
	then do;

/* Case 3: original name is not an archive name and the target is an archive name:  Apply the equal name provided for the
	 target component to the original entryname; if an equal name is specified for the target archive, this use of
	 the archive component pathname equal name convention is in error */

	     call check_equal_name_ (P_equal_entryname, archive_equal_code);

	     if (archive_equal_code ^= 0) then		/* bad syntax or equal convention is used */
		if (archive_equal_code = 1) | (archive_equal_code = 2) then
		     code = error_table_$no_archive_for_equal;
		else code = archive_equal_code;	/* bad syntax in equal name */

	     else					/* archive name doesn't use equal convention: OK so far */
	     if add_archive_suffix (P_equal_entryname, P_target_entryname) then
		call get_equal_name_ (P_entryname, P_equal_component, P_target_component, code);

	     else code = error_table_$entlong;		/* archive name too long for ".archive" suffix */
	end;


	else do;

/* Case 4: both original and target are archive component pathnames:  Apply the equal name to each part; strip the
	 ".archive" suffix from the archive names first, however */

	     call check_equal_name_ (P_equal_entryname, code);
		if (code > 2) then return;		/* illegal equal name */

	     call check_equal_name_ (P_equal_component, code);
		if (code > 2) then return;

	     entryname = strip_archive_suffix (P_entryname);
	     equal_entryname = strip_archive_suffix (P_equal_entryname);

	     call get_equal_name_ (entryname, equal_entryname, P_target_entryname, archive_equal_code);

	     if (archive_equal_code = 0) | (archive_equal_code = error_table_$longeql) then
		call get_equal_name_ (P_component, P_equal_component, P_target_component, code);
	     else do;				/* bad syntax or something */
		code = archive_equal_code;
		return;
	     end;

	     if add_archive_suffix (P_target_entryname, P_target_entryname)
		then;				/* archive name is fine: use code from component */
	     else code = error_table_$longeql;		/* couldn't form the archive name */
	end;

	return;

/*  */

/* Validates the syntax of a supplied equal name and whether the name actually employs the equal convention */

check_equal_name_:
     entry (P_equalname, code);

	check_entry = "1"b;

	Lequal = length (rtrim (P_equalname));

	if (Lequal = 0) | (Lequal > 32) then		/* too long or short */
	     code = error_table_$bad_equal_name;

	equal = P_equalname;			/* copy into area used for parsing */

	call parse_equal_name ();			/* parse it as best you can */

	if (other_equal | double_equal | triple_equal) then
						/* some form of equal convention is used */
	     if (Neq = 1) then			/* 1 component */
		if (Teq(1) = Tequalequalequal) | (Teq(1) = Tequalequal) then
		     code = 2;			/* "===" or "==": target will be same as original */
		else code = 1;			/* target is some variant of original */

	     else if (Neq = 2) then			/* 2 components */
		if ((Teq(1) = Tequalequal) & (Teq(2) = Tequal)) | ((Teq(1) = Tequal) & (Teq(2) = Tequalequal)) then
		     code = 2;			/* "==.=" or "=.==": target will be same as original */
		else code = 1;			/* target is some variant of original */

	     else code = 1;				/* > 2 components: target is some variant of original */

	else code = 0;				/* equal convention not used: target bears no resemblence to
						   the original name */
	return;

/*  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */



	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/*	This internal procedure parses an equal name into classified components,	*/
	/*	and further parses each component into classified subcomponents.  The 	*/
	/*	equal name is assumed to reside in _e_q_u_a_l, and L__e_q_u_a_l is assumed to be		*/
	/*	its length.							*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

parse_equal_name:	procedure;


	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/*	1) Initialize variables used to parse the equal name.			*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

	state = 0;				/* start parsing with finite state machine in	*/
	double_equal = "0"b;			/* state zero.  No == components encountered yet.	*/
	Nequalequal = 0;
	triple_equal = "0"b;
	other_equal = "0"b;

	Neq = 1;					/* Start parsing 1st equal name component.	*/
	Ieq(1) = 1;				/* 1st component starts with 1st char of equal	*/
	Leq(1) = 0;				/* name, and has zero length so far.		*/
	SCeq(1) = 1;				/* 1st subcomponent in 1st component		*/

	Nsub = 0;					/* No subcomponents have been found so far.	*/
						/* is subcomponent number 1.			*/

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* 	Use the finite state machine to parse the equal name, 1 char at a time.	*/
	/*	1) validate each character (char ^= ">", ^= "<", <= PAD)			*/
	/*	2) transfer to next parsing state, according to character value (".", "=", "%",	*/
	/*	   or another char.							*/
	/*	3) each non-terminal state updates the information in the component and	*/
	/*	   subcomponent array tables which record the location and length of each	*/
	/*	   component, and the location (relative to the start of the component), and	*/
	/*	   length of each subcomponent.  Each terminal state updates the indices into	*/
	/*	   these arrays, prior to starting to parse the next component and subcomponent.*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


	do i = 1 to Lequal;
	     char = Oequal.char(i);			/* copy char for efficiency.			*/
	     if char = "." then
		state = nstate (state, 1);
	     else if char = "=" then
		state = nstate (state, 2);
	     else if char = "%" then
		state = nstate (state, 3);
	     else if char = ">" then
		go to bad_equal_name;
	     else if char = "<" then
		go to bad_equal_name;
	     else if char > PAD then
		go to bad_equal_name;
	     else
		state = nstate (state, 4);
	     go to parse (state);

parse(1):						/* state = O; input char was another.		*/
parse(2):						/* state = O=; input char was another.		*/
parse(3):						/* state = %O; input char was another.		*/
	     Nsub = Nsub + 1;			/* this char starts a new subcomponent.		*/
   	     Isub(Nsub) = Leq(Neq) + 1;		/* record index into component of start of	*/
	     Lsub(Nsub) = 1;			/* subcomponent, and start with length of 1.	*/
	     Tsub(Nsub) = 1;			/* record subcomponent type of 1 (O's).		*/
	     go to next_char;

parse(4):						/* state = %; input char was %.		*/
	     Nsub = Nsub + 1;			/* this char starts a new subcomponent.		*/
	     Isub(Nsub) = Leq(Neq) + 1;		/* record index into component of start of	*/
	     Lsub(Nsub) = 1;			/* subcomponent, and start with length of 1.	*/
	     Tsub(Nsub) = 2;			/* record subcomponent type of 2 (%'s).		*/
	     go to next_char;

parse(5):						/* state = OO; input char was another.		*/
parse(6):						/* state = =OO; input char was another.		*/
parse(7):						/* state = %OO; input char was another.		*/
parse(8):						/* state = %%; input char was %.		*/
	     Lsub(Nsub) = Lsub(Nsub) + 1;		/* add this char to length count of subcomponent.	*/
	     go to next_char;

parse(9):	     					/* state = O=; input char was =		*/
parse(10):					/* state = =; input char was =		*/
	     Nsub = Nsub + 1;			/* this char begins a new subcomponent.		*/
	     Isub(Nsub) = Leq(Neq) + 1;		/* record index into component of start of	*/
	     Lsub(Nsub) = 1;			/* subcomponent, and start with a length of 1.	*/
	     Tsub(Nsub) = 3;			/* record subcomponent type of 3 (=).		*/
	     go to next_char;

parse(11):					/* state = ==; input char was =		*/
parse(12):					/* state = ===; input char was =		*/
	     go to next_char;			/* nothing req'd for == or === component.	*/



parse(13):					/* terminal state = ===; input char was "."	*/
	     triple_equal = "1"b;
	     go to finish_component;

parse(14):					/* terminal state = ==; input char was "."	*/
	     if double_equal then			/* make sure there's only 1 double equal sign 	*/
		go to bad_equal_name;		/* in the equal name.			*/
	     double_equal = "1"b;
	     Nequalequal = Neq;
	     go to finish_component;

parse(15):					/* terminal state = O or OO			*/
parse(16):					/* terminal state = O=, =O, =OO, %, %%, %O or %OO	*/
parse(17):					/* terminal state = =			*/
						/* input char was "."			*/
	     if state ^= Totherother then		/* have some use of equals convention.		*/
		other_equal = "1"b;

finish_component:
	     Teq(Neq) = state;			/* type of this component is state number.	*/
	     Neq = Neq + 1;				/* prepare to process the next component.	*/
	     Ieq(Neq) = i+1;			/* next component begins with next character.	*/
	     Leq(Neq) = -1;				/* it has 0 length so far.			*/
						/* (This value will be 0 when it is updated to	*/
						/*  reflect the "." we're processing now.)	*/
	     SCeq(Neq) = Nsub + 1;			/* component begins with next subcomponent.	*/
	     state = 0;				/* switch to the state used to begin parsing a	*/
	     go to next_char;			/* component.				*/

parse(18):     					/* terminal state = bad equal name format.	*/
	     go to bad_equal_name;

next_char:     Leq(Neq) = Leq(Neq) + 1;			/* update component's length to include current	*/
	     end;					/* input char, then parse the next input char.	*/

	state = nstate (state, 1);			/* fudge contents of component array to make it	*/
	if state = Tbad then			/* look like equal name ended with a null	*/
	     go to bad_equal_name;			/* component.  Fill in state of last component	*/
	else if state = Tequalequal then do;		/* if state is valid (not bad equal name state,	*/
	     if double_equal then			/* or 2nd double equal component).		*/
		go to bad_equal_name;
	     double_equal = "1"b;
	     Nequalequal = Neq;
	     end;
	else if state = Tequalequalequal then
	     triple_equal = "1"b;
	else if state ^= Totherother then
	     other_equal = "1"b;

	Teq(Neq) = state;
	SCeq(Neq + 1) = Nsub + 1;

	if triple_equal & (other_equal | double_equal) then
	     go to bad_equal_name;			/* may not have === with any other type.	*/

	end parse_equal_name;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


/*  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */



	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/*	This internal procedure constructs a target name component from an entry name	*/
	/*	component and an equal name component.  A different type of construction is	*/
	/*	used to each type of equal name component.				*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


copy_:	procedure	(Xeq, Xen);

     dcl	Xeq			fixed bin,	/* number of equal name component.		*/
	Xen			fixed bin;	/* number of entry name component.		*/

     dcl	Is			fixed bin,	/* index of subcomponent to be copied, relative to*/
						/* start of component in entry name or equal name.*/
	Leq			fixed bin,	/* length of equal name component.		*/
	Len			fixed bin,	/* length of entry name component.		*/
	Ls			fixed bin,	/* length of subcomponent.			*/
	Peq			ptr,		/* ptr to equal name component.		*/
	Pen			ptr,		/* ptr to entry name component.		*/
	Ps			ptr;		/* ptr to subcomponent to be copied.		*/

     dcl	en			char(Len) based (Pen),
						/* the entry name component.			*/
	eq			char(Leq) based (Peq),
						/* the equal name component.			*/
	s			char(Ls) based (Ps);/* subcomponent to be copied.			*/

	Peq = addr (Oequal.char(Ieq(Xeq)));		/* overlay the equal name component.		*/
	Leq = Ceq(Xeq).Leq;
	if Xen <= Nen then do;			/* if an entry component corresponding to the	*/
						/* equal component exists, then		*/
	     Pen = addr (Oentry.char(Ien(Xen)));	/* overlay the entry name component.		*/
	     Len = Cen(Xen).Len;
	     end;
	else do;					/* otherwise, use a null entry component.	*/
	     Pen = Peq;
	     Len = 0;
	     end;

	go to copy (Teq(Xeq));			/* perform construction, according to type of	*/
						/* equal name component.			*/

copy(13):						/* equal component is ===			*/
	target = target || substr (entry, 1, Lentry);	/* add original name to target.		*/
	return;

copy(14):						/* equal component is ==			*/
	target = target || en;			/* add entry name component to target.		*/
	return;

copy(15):						/* equal component is O or OO			*/
	target = target || eq;			/* add equal name component to the target.	*/
	return;


copy(16):						/* equal component is %, %%, %O, %OO, O=, =O, 	*/
						/* or =OO					*/
	if Xen > Nen then				/* an entry name component corresponding to the	*/
	     code = error_table_$badequal;		/* equal name component must exist.  If it doesn't*/
						/* report the error and assume a null entry name	*/
						/* component exists.			*/
	do j = SCeq(Xeq) to SCeq(Xeq+1) - 1;		/* process each subcomponent of equal name, 	*/
	     go to sub_comp(Tsub(j));			/* where each subcomponent type is a special case	*/

sub_comp(1):   					/* type 1: OO's				*/
	     Ps = addr (substr (eq, Isub(j)));		/* overlay subcomponent of equal component.	*/
	     Ls = Lsub(j);
	     target = target || s;			/* add subcomponent to target.		*/
	     go to end_sub_loop;

sub_comp(2):					/* type 2: %%'s				*/
	     Is = Isub(j);				/* get index and length of subcomponent.	*/
	     Ls = Lsub(j);
	     if Is+Ls-1 > Len then do;		/* if entry component isn't long enough to	*/
		code = error_table_$badequal;		/* have characters corresponding to the %'s of the*/
		if Is > Len then do;		/* equal component, then report error to caller,	*/
		     Is = 1;			/* and adjust index and length of subcomponent to	*/
		     Ls = 0;			/* use whatever corresponding characters are there*/
		     end;
		else
		     Ls = Len - Is + 1;
		end;
	     Ps = addr (substr (en, Is));		/* get ptr to entry name subcomponent.		*/
	     target = target || s;			/* add subcomponent to target name.		*/
	     go to end_sub_loop;

sub_comp(3):					/* type 3: =				*/
	     target = target || en;			/* add entry name to target.			*/
end_sub_loop:  end;
	return;


copy(17):						/* equal component is =			*/
	if Xen > Nen then				/* if entry component corresponding to equal	*/
	     code = error_table_$badequal;		/* component, tell caller and assume null entry	*/
						/* component.				*/
	else					/* otherwise, add entry component to target.	*/
	     target = target || en;

	end copy_;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  */

/* Adds the suffix ".archive" to the supplied name if not already present and returns "1"b if the resulting name is OK */

add_archive_suffix:
	procedure (p_input_name, p_output_name) returns (bit (1) aligned);

dcl (p_input_name, p_output_name) character (*) parameter;
dcl  temporary_name character (33) varying;

	     temporary_name = rtrim (p_input_name);

	     if (temporary_name = ".archive") then	/* bad format */
		go to COMPONENT_BAD_EQUAL_NAMES;

	     else if (length (temporary_name) < length ("X.archive")) then
		temporary_name = temporary_name || ".archive";

	     else if (substr (temporary_name, (length (temporary_name) - length (".archive") + 1)) ^= ".archive") then
		temporary_name = temporary_name || ".archive";

	     p_output_name = temporary_name;

	     if length (temporary_name) > 32 then
		return ("0"b);			/* adding the suffix made the name too long */ 
	     else return ("1"b);

	end add_archive_suffix;

/*  */

/* Strip the ".archive" suffix from the name, if present */

strip_archive_suffix:
	procedure (p_input_name) returns (character (32));

dcl  p_input_name character (*) parameter;
dcl  temporary_name character (32) varying;

	     temporary_name = rtrim (p_input_name);

	     if (temporary_name = ".archive") then
		go to COMPONENT_BAD_EQUAL_NAMES;

	     else if (length (temporary_name) < length ("X.archive")) then
		return (temporary_name);

	     else if (substr (temporary_name, (length (temporary_name) - length (".archive") + 1)) ^= ".archive") then
		return (temporary_name);

	     else return (substr (temporary_name, 1, (length (temporary_name) - length (".archive"))));

	end strip_archive_suffix;

	end get_equal_name_;
