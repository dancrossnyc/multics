/****^  *****************************************************
        *                                                   *
        * Copyright, (C) Honeywell Bull Inc., 1987          *
        *                                                   *
        * Copyright (C) 1982 by Massachusetts Institute of  *
        * Technology and Honeywell Information Systems Inc. *
        *                                                   *
        ***************************************************** */

/*^			Match Star Name

   This module implements the Multics Star Convention, as described in the
   MPM Reference Guide, Honeywell publication AG91.  It is a complete
   reimplementation of the Star Convention for MR12, and is redefined in an
   upward compatible manner to accept previously invalid input.

   The Star Convention is used to partition sets of names or named entities
   into two subsets: those that match, and those that don't.  Either subset
   may be empty.  For example, a directory may contain a set of files, and
   each file may have several entrynames.  A starname can be used to select
   all the files which have at least one entryname which matches the
   starname.  Further processing is generally done on the selected subset.

   This procedure implements the comparison of a single starname to an
   entryname.  Two results are interesting: either they match, or they do
   not.  It is left to the caller to iterate over sets of entrynames and
   starnames as appropriate.  The starname may be invalid, in which case a
   match is impossible, although a mismatch can in some cases be detected
   before the syntax error is found.

   The Star Convention is defined as follows:

    1.  Names, whether entrynames or starnames, are PL/I character strings.
        Trailing ASCII space characters are not significant for purposes of
        comparison, so that names stored in variables of different length can
        be considered equal.  The end of the name precedes any such spaces.

    2.  Names are divided into components.  Any name has at least one
        component, which is bounded by the beginning and end of the name.  If
        Dots (periods) are present, they delimit the name into multiple
        components.  If two component boundaries are consecutive, they define
        a null component between them.

    3.  Starnames are comparison templates which contain literal characters,
        component delimiters, and wildcard characters.  Components are
        delimited by Dots.  Star (asterisk) and Query (question mark)
        characters can be grouped to form four different wildcard constructs.
        Any character other than Dot, Star, Query or a trailing space matches
        itself only.
        
    4.  A starname which contains no wildcard characters can be compared to
        an entryname using standard PL/I rules for character string equality.
       
    5.  Each Query character stands alone, so a string of three Query
        characters is three occurences of the Query construct.  Each Query
        matches exactly one character in the entryname, but may not match a
        Dot, so that it can't cross a component boundary.

    6.  Each isolated Star character can match any number of characters
        within a component, including none at all.  A single Star may not
        match a Dot in the entryname, so that it can't cross component
        boundaries.

    7.  A Doublestar consists of two consecutive Star characters.  A run of
        more than two consecutive Star characters is illegal.  A Doublestar
        has one of two meanings, depending on its context.

    8.  A Doublestar component is a Doublestar which has a component boundary
        on both sides.  Any other Doublestar is said to be floating.

    9.  A floating Doublestar matches any number of characters in the
        entryname, including none.  It can even match a Dot, so that it can
        cross component boundaries.

   10.  A Doublestar component matches any number of entire components in the
        entryname, including none.  It can't match partial components.  Dots
        in the starname act like literal characters in all other situations,
        but when they delimit a Doublestar component they need not correspond
        to a Dot in the entryname.  When a Doublestar component matches zero
        components in the entryname, it nevertheless must occur at a
        component boundary in the entryname.

   Examples:

      "foobar" and "foo?ar" each match "foobar",
		        but do not match "fobar", "foo.ar" or "fooobar".

      "foo*" matches "foo" and "foobar" but does not match "foo.bar".

      "**bar" matches "foobar" and "foo.bar" but does not match "bar.foo".

      ".**." matches ".", ".." and ".foo." but does not match "" or "foo.".

      "foo***" and "*.***" are invalid.

			Implementation

   The old match_star_name_ completely parsed the starname into components
   and subcomponents (delimited by a Star in the component) before starting
   comparison.  That implementation imposed a number of restrictions which
   have been removed.  Starnames and entrynames were limited to 32
   characters in length; null in starnames components were illegal; only one
   Star was permitted in each component, except for a single Doublestar
   component.

   Permitting the starname and entryname to each be up to a segment in
   length, permitting multiple Stars per component and permitting multiple
   Doublestars per starname required a complete rethinking of the matching
   strategy.  Since the description of a parsed starname can easily take up
   more space than the starname does, parsing the whole name in advance is
   no longer feasible.  Instead, the parser obtains a certain amount of
   information, and then the matching routines are called.  If they succeed,
   more parse and match iterations are done until either a mismatch is
   found, the star name is exhausted, or an invalid construct is found.

   The parser is designed to recover as much information as can be easily
   represented.  What is returns is an encoding which is described by the
   following diagram:

      [Star construct][Query count][literal string][boundary]

   First, combinations of Stars and Dots are parsed, to develop the Star
   construct.  This phase ends if a character other than Dot or Star is
   found, the starname is exhausted, if two consecutive dots are found, or
   if more than two consecutive Star components are found.  If the
   terminating character is a Query, a count of consecutive Queries is made
   in phase 2.  Stars embeded in Queries in most cases can be either ignored
   or added to the Star construct, because "?*" is equivalent to "*?".  When
   a character which is neither a Query not a Star is encountered, we begin
   phase 3, the collection of a literal character string.  The literal
   string ends when a Query or a Star is found, or when the starname is
   exhausted.  If the string is terminated by a Star which is immediately
   preceded by a Dot, that final Dot is part of the Star construct and not
   part of the literal string.

   The parser returns this information in an integer which encodes the Star
   construct and several binary choices.  Were there any Queries?  Any
   literal string?  Is the starname exhausted?  Did the literal string end
   on a component boundary?  In addition, a Query count is returned.  If
   there was a literal string, its position and length are returned.  The
   encoded value is used to select a comparison routine.  If the comparison
   succeeds, and the star name is not exhausted, then the parser will be
   reinvoked to continue parsing from where it left off.  The parser
   position and state are remembered against this eventuality.  For example,
   if a Star is found following a literal string, then parsing resumes with
   the first character beyond that Star; the Star is already remembered in
   the new parser state that will be used if the literal compares
   sucessfully.

   When matching following a Star or a Doublestar, a mismatch might not be
   detected until the parser had been reinvoked, perhaps several times.  For
   example, the starname "*x?y" would first parse the first two characters,
   then match the first two, next parse the last two characters, and finally
   match the last two.  If the second comparison step failed, it might be
   possible for the first comparison step to match at different place where
   the second comparison could succeed.  In this case, a failing comparison
   invokes a backup routine which tries to find an alternative match and
   restores the parser to a former position and state.  Because Stars match
   within a component, and Doublestars match the whole name, there are two
   possible retry levels.  If Star retry fails, Doublestar retry can attempt
   another component.

   Extensive optimizations have been performed to permit the PL/I compiler
   to generate the most efficient possible code.  The most streamlined
   operation is matching, which may be used to iterate over large locked
   directories in ring zero.  The parser recognizes starnames which match
   all possible names in a single call, so it isn't even necessary to look
   at the entryname in that case.  The parser is also used for analyzing
   names, which is less time critical.  To improve space efficiency without
   hurting performance, some tables have been paired so that each word
   contains one entry from each table, one in the high halfword and the
   other in the low halfword.

			Check Star Name

   There are 4 classes of star names: 1) names which contain no wildcard
   characters, 2) names which match all possible names, 3) invalid names,
   and 4) names which contain wildcard characters but don't match all
   possible names.  If there are no wildcard characters, then PL/I
   comparison can be used.  Indeed, the name can be looked up in a hash
   table, or by binary search.  Detecting and specially processing such
   names can greatly improve performance.  If a starname matches all
   possible names, then there is no need to actually compare them; all the
   entities are selected for processing.  Names which contain three or more
   consecutive Stars are invalid; such names select nothing.  Only the
   remaining class of names *requires* the use of match_star_name_.

   Although all four classes of names can be used with match_star_name_, it
   may be much more efficient to classify them in advance.  The
   check_star_name_ subroutine is provided for this purpose.  However,
   because starnames are often used with the Multics file system, a number
   of optional validity checks can be performed by check_star_name_.

   There are three entrypoints:

   1.  check_star_name_ is the most general and convenient.  It validates
       and classifies star names.  A bit string parameter permits an
       arbitrary combination of the optional tests.  An include file,
       check_star_name.incl.pl1, exists to aid in constructing control bit
       strings and interpreting the classification.  A number of error codes
       can be returned depending on the tests selected.

   2.  check_star_name_$entry is an obsolete entrypoint retained for
       compatibility with the many existing programs which call it.  It is
       used to validate file system entrynames.  A fixed set of validity
       checks is always made.  The starname classification is returned as a
       nonstandard error code rather than as a separate argument.  The only
       standard error code returned is error_table_$badstar, which for
       compatibility must cover all error cases.  The selected tests include
       rejecting null components, nonASCII characters, pathname delimiters,
       the archive pathname delimiter, and names more than 32 characters
       long.

   3.  check_star_name_$path is an obsolete entrypoint retained for
       compatibility with the many existing programs which call it.  It is
       used to validate file system pathnames.  A fixed set of validity
       checks is always made.  The starname classification is returned as a
       nonstandard error code rather than as a separate argument.  The only
       standard error code returned is error_table_$badstar, which for
       compatibility must cover all error cases.  The selected tests include
       processing pathname delimiters and the archive convention, and
       rejecting null components, nonASCII characters and names more than 32
       characters long.

   The checks for invalid delimiters and null components could have been
   added as additional steps in the testing process.  However, a separate
   TCT table for finding the various delimiters would have increased the
   size of the program, and the additional tests would have made
   check_star_name_ slower.  Instead, these tests are made in the parsing
   routine at the cost of some additional complexity.

   History      Author            Modification
    8 Jul 1982  J. Spencer Love   Initial coding.
   19 Nov 1984  J. Spencer Love   Audit and MCR changes for MR11.
   25 Jan 1985  J. Spencer Love   Fix bug in check_star_name_$path.
*/


/****^  HISTORY COMMENTS:
  1) change(86-08-12,JSLove), approve(86-08-14,MCR7518),
     audit(86-08-14,FCSmith), install(86-10-02,MR12.0-1174):
     Changed new check_star_name_ entrypoint to take 4 arguments, adding the
     test selection control mask and separate star_type arguments.
  2) change(88-03-15,Parisek), approve(88-03-29,MCR7872),
     audit(88-04-14,LJAdams), install(88-04-26,MR12.2-1042):
     Set pi.match_name_exhausted during COMPARE_STAR_UNDOTTED_LITERAL_DOT when
     all of the match_name has been parsed. phx21106.
                                                   END HISTORY COMMENTS */


/* format: style3,ifthenstmt,indcomtxt,indproc,idind30 */
%page;
match_star_name_:
     procedure (P_match_entry_name, P_match_star_name, P_match_status);

declare	P_check_control		bit (36) parameter,
	P_check_star_name		char (*) parameter,
	P_check_star_type		fixed bin (2) parameter,
	P_check_status		fixed bin (35) parameter,
	P_match_entry_name		char (*) parameter,
	P_match_star_name		char (*) parameter,
	P_match_status		fixed bin (35) parameter,
	P_nonstandard_status	fixed bin (35) parameter;

declare	(addr, index, length, maxlength, rank, reverse, rtrim, search, string, substr, unspec)
				builtin;

declare	match_name_length		fixed bin (21),	/* The length of the string to be matched to the star name. */
	match_name_ptr		ptr,		/* The address of the string to be matched to the starname. */
	star_name_length		fixed bin (21),	/* The length of the star name to be parsed.		*/
	star_name_ptr		ptr,		/* The address of the star name to be parsed.		*/
	star_type			fixed bin (2),	/* The classification according to check_star_name_.	*/
	status			fixed bin (35),	/* Internal error code for the check procedures.		*/
	temp			fixed bin (21);	/* Temporary used in comparison routines.		*/

declare	1 cs			aligned like check_star;

declare	1 pi			aligned,		/* The complete current state of the parse and match.	*/
	  2 starstar,				/* The state subset that must be restored for ** retry.	*/
	    3 star,				/* The state subset that must be restored for * retry.	*/
	      4 operations,				/* These two are grouped for efficient assignment.	*/
	        5 comparison	fixed bin unaligned,/* The comparison routine to be invoked.		*/
	        5 state		fixed bin unaligned,/* The state of the parser Finite State Machine.		*/
	      4 parse_position	fixed bin (21),	/* Zero origin index of the next star name char to parse.	*/
	      4 parse_query_count	fixed bin (21),	/* The number of Queries for the next or final comparison.	*/
	      4 literal_position	fixed bin (21),	/* Zero origin index of a literal substring of star name.	*/
	      4 literal_length	fixed bin (21),	/* Length of a literal substring of the star name.	*/
	      4 dot_count		fixed bin (21),	/* The number of Dots in the current literal substring.	*/
	      4 match_position	fixed bin (21),	/* Zero origin position of the remaining match string.	*/
	      4 match_length	fixed bin (21),	/* The length of the remaining match string.		*/
	    3 compare_query_count	fixed bin (21),	/* The number of Queries for the current comparison.	*/
	  2 match_name_exhausted	bit (1) aligned;	/* Have already matched against last component.		*/

declare	1 star_retry_info		aligned like pi.star,
	1 starstar_retry_info	aligned like pi.starstar;

declare	match_name		char (match_name_length) based (match_name_ptr),
	star_name			char (star_name_length) based (star_name_ptr);

declare	ARCHIVE_DELIM		initial ("::") char (2) static options (constant),
	ASCII_HIGH		initial (127) fixed bin (9) static options (constant),
	DOT			initial (".") char (1) static options (constant),
	ENTRYPOINT_CHARS		initial ("$|") char (2) static options (constant),
	EQUAL_CHARS		initial ("=%") char (2) static options (constant),
	MAXIMUM_FILESYS_LENGTH	initial (32) fixed bin (17) static options (constant),
	PATH_CHARS		initial ("<>") char (2) static options (constant);

declare	(
	error_table_$archive_pathname,
	error_table_$bad_arg,
	error_table_$bad_file_name,
	error_table_$badequal,
	error_table_$badpath,
	error_table_$badstar,
	error_table_$entlong,
	error_table_$inconsistent,
	error_table_$invalid_ascii,
	error_table_$nostars,
	error_table_$nomatch,
	error_table_$null_name_component
	)			fixed bin (35) external;
%page;
/* The comparison codes are generated by tables in the parse subroutine, and
   used as subscripts on the COMPARE label array.  The following particular
   codes are used by the check_star_name_ entrypoints.  MATCHES_EVERYTHING
   identifies a type 2 star name if it is returned on the first call to the
   parser.  MATCHES_LITERAL and MATCHES_NOTHING identify a type 0 star name
   if either is returned on the first call to the parser.  Comparisons less
   than MATCHES_ERROR indicate that the end of the star name has been
   reached, and comparisons greater than MATCHES_ERROR indicate that further
   parsing remains to be done.				       */

declare	(
	MATCHES_ANYTHING		initial (-17),
	MATCHES_ERROR		initial (0),
	MATCHES_LITERAL		initial (-1),
	MATCHES_NOTHING		initial (-4)
	)			fixed bin static options (constant);
%page;
%include check_star_name;
%page;
/* match_star_name_:  procedure (P_match_entry_name, P_match_star_name, P_match_status);				*/

	star_name_length = maxlength (P_match_star_name); /* Pick up star name parameter for analysis.  Here we get	*/
	star_name_ptr = addr (P_match_star_name);	/* the length and the address, then trim off trailing	*/
	star_name_length = length (rtrim (star_name));	/* blanks.  We look at the parameter only once.		*/

	string (cs) = CHECK_STAR_IGNORE_ALL;

	unspec (pi.operations) = ""b;			/* Initialize parser.				*/
	pi.parse_position, pi.parse_query_count = 0;

	call parse ();				/* Take our first look at the starname.			*/

	if pi.comparison = MATCHES_ANYTHING then go to MATCH_EXIT;

	match_name_length = maxlength (P_match_entry_name);
						/* We have to look at the string to match, so get it and	*/
	match_name_ptr = addr (P_match_entry_name);	/* rtrim it.  We don't copy the match name; it costs too	*/
	match_name_length = length (rtrim (match_name));	/* much and can be of any length.			*/

	pi.match_name_exhausted = "0"b;		/* Initialize for the comparison routines.		*/
	pi.match_length = match_name_length;
	pi.match_position = 0;			/* Start here.					*/
	unspec (star_retry_info.operations) = ""b;	/* No checkpoint yet.				*/
	unspec (starstar_retry_info.operations) = ""b;	/* Bo checkpoint yet.				*/

	go to COMPARE (pi.comparison);		/* Start comparing star name to match name.		*/
%page;
COMPARE (-29):					/* Compare  **.?oE					*/
	call literal_end ();			/* Reduce to **.?E					*/

COMPARE (-28):					/* Compare  **.?E					*/
	pi.match_length = pi.match_length - pi.parse_query_count;
	if pi.match_length < 0 then go to NO_MATCH_EXIT;	/* Make sure there is enough room for the Queries.	*/

	if index (substr (match_name, pi.match_position + pi.match_length + 1, pi.parse_query_count), DOT) - 1 >= 0
	then go to NO_MATCH_EXIT;			/* Reject if a Dot is found where one shouldn't be.	*/

	go to COMPARE_MUST_END_ON_COMPONENT_BOUNDARY;


COMPARE (-27):					/* Compare  *.**.E					*/
	call skip_component ();			/* Reduce to C**.E					*/

	if ^pi.match_name_exhausted
	then go to COMPARE_MUST_END_ON_COMPONENT_BOUNDARY;
	else go to NO_MATCH_EXIT;			/* Final component must be null, but if we have already	*/
						/* matched END then we are short on components.		*/

COMPARE (-26):					/* Compare  *.**.oE					*/
	call skip_component ();			/* Reduce to **.oE					*/

COMPARE (-25):					/* Compare  **.oE					*/
	call literal_end ();			/* Reduce to **.E					*/

COMPARE (-24):					/* Compare  **.E					*/
COMPARE_MUST_END_ON_COMPONENT_BOUNDARY:
	if pi.match_length = 0
	then if ^pi.match_name_exhausted
	     then go to MATCH_EXIT;			/* If we are at end, nevertheless the END must not have	*/
	     else go to NO_MATCH_EXIT;		/* already been matched, or we are short on components.	*/

	if substr (match_name, pi.match_position + pi.match_length, 1) = DOT then go to MATCH_EXIT;
						/* Since not at end, must have literal Dot.		*/

NO_MATCH_EXIT:					/* Indicate that star name does not match string.		*/
	P_match_status = error_table_$nomatch;

	return;
%page;
COMPARE (-23):					/* Compare  **?oE					*/
	call literal_end ();			/* Reduce to **?E					*/

COMPARE (-22):					/* Compare  **?E					*/
	pi.match_length = pi.match_length - pi.parse_query_count;
	if pi.match_length < 0 then go to NO_MATCH_EXIT;	/* Make sure there is enough room for the Queries.	*/

	if index (substr (match_name, pi.match_position + pi.match_length + 1, pi.parse_query_count), DOT) - 1 >= 0
	then go to NO_MATCH_EXIT;			/* Reject if a Dot is found where one shouldn't be.	*/

	go to MATCH_EXIT;


COMPARE (-21):					/* Compare  *.**oE					*/
	call skip_component ();			/* Reduce to **oE					*/

COMPARE (-20):					/* Compare  **oE					*/
	call literal_end ();			/* Reduce to **E					*/

	go to MATCH_EXIT;


COMPARE (-19):					/* Compare  *.**.*E					*/
	call skip_component ();			/* Reduce to C**.*E					*/

COMPARE (-18):					/* Compare  C**.*E					*/
	if pi.match_name_exhausted then go to NO_MATCH_EXIT;
						/* There must be at least one component left.		*/

COMPARE (-17):					/* Compare  **	(MATCHES_ANYTHING)			*/
MATCH_EXIT:					/* Indicate that star name matches string.		*/
	P_match_status = 0;

	return;
%page;
COMPARE (-16):					/* Compare  o.*oE					*/
	call literal_end ();			/* Reduce to o.*E					*/

COMPARE (-15):					/* Compare  o.*E					*/
	call must_be_at_dot ();			/* Reduce to *E					*/

	go to COMPARE_MUST_BE_LAST_COMPONENT;


COMPARE (-14):					/* Compare  *.*E					*/
	call skip_component ();			/* Reduce to C*E					*/

COMPARE (-13):					/* Compare  C*E					*/
	if ^pi.match_name_exhausted
	then go to COMPARE_MUST_BE_LAST_COMPONENT;	/* END of match name must not already have been matched or	*/
	else go to NO_MATCH_EXIT;			/* match name has too few components.			*/


COMPARE (-12):					/* Compare  *?oE					*/
	call literal_end ();			/* Reduce to *?E					*/

COMPARE (-11):					/* Compare  *?E					*/
	if pi.match_length >= pi.parse_query_count
	then go to COMPARE_MUST_BE_LAST_COMPONENT;	/* There must be enough room for the Queries.		*/
	else go to NO_MATCH_EXIT;


COMPARE (-10):					/* Compare  *.*oE					*/
	call skip_component ();			/* Reduce to *oE					*/

COMPARE (-9):					/* Compare  *oE					*/
	call literal_end ();			/* Reduce to *E					*/

COMPARE (-8):					/* Compare  *E					*/
COMPARE_MUST_BE_LAST_COMPONENT:
	if index (substr (match_name, pi.match_position + 1, pi.match_length), DOT) - 1 < 0
	then go to MATCH_EXIT;			/* Last component can't contain any Dots.		*/
	else go to RETRY_STARSTAR;
%page;
COMPARE (-7):					/* Compare  ?E					*/
	if pi.match_length ^= pi.parse_query_count
	then if pi.match_length < pi.parse_query_count
	     then go to NO_MATCH_EXIT;		/* There must be exactly enough room.  If there is too much */
	     else go to RETRY_STAR;			/* we can retry but too little is immediately fatal.	*/

	if index (substr (match_name, pi.match_position + 1, pi.match_length), DOT) - 1 < 0
	then go to MATCH_EXIT;			/* Queries can't match Dots.				*/
	else go to NO_MATCH_EXIT;


COMPARE (-6):					/* Compare  *.E					*/
	call skip_component ();			/* Reduce to CE					*/

COMPARE (-5):					/* Compare  CE					*/
	if pi.match_name_exhausted then go to NO_MATCH_EXIT;
						/* We must be at end, but END must not already have been	*/
						/* matched.					*/

COMPARE (-4):					/* Compare  BE	(MATCHES_NOTHING)			*/
	if pi.match_length = 0
	then go to MATCH_EXIT;			/* Requires that no match name be left.			*/
	else go to RETRY_STARSTAR;			/* Needed for CE but Doublestars can't preceded BE	*/

COMPARE (-3):					/* Compare  ?oE					*/
	pi.compare_query_count = pi.parse_query_count;	/* Adjust environment for (non-terminal) skip_queries.	*/
	call skip_queries ();			/* Reduce to oE					*/

	go to COMPARE_LITERAL_END;


COMPARE (-2):					/* Compare  *.oE					*/
	call skip_component ();			/* Reduce to oE					*/

	unspec (star_retry_info.operations) = ""b;	/* We are in a new component, so no Star retry is possible. */

COMPARE (-1):					/* Compare  oE	(MATCHES_LITERAL)			*/
COMPARE_LITERAL_END:
	if substr (star_name, pi.literal_position + 1) = substr (match_name, pi.match_position + 1, pi.match_length)
	then go to MATCH_EXIT;
	else go to RETRY_STAR;


COMPARE (0):					/* MATCHES_ERROR					*/
	P_match_status = error_table_$badstar;		/* Indicate that star name is not valid.		*/

	return;
%page;
/* Here follows a procedure which is used to match literals found at the
   ends of star names.  The following restrictions apply to its use:  if
   used by the same star name, components must be skipped by calling
   skip_component BEFORE calling literal_end, and the literal must be
   matched first, which effectively shortens the match name by subtracting
   from pi.match_length, before Queries can be matched.		       */


literal_end:
     procedure ();					/* Procedure to match string at end of match name.	*/

	pi.literal_length = star_name_length - pi.literal_position;
						/* Trim characters to be matched for Queries, if any.	*/

	pi.match_length = pi.match_length - pi.literal_length;
	if pi.match_length < 0 then go to NO_MATCH_EXIT;	/* Make sure there is enough room for the literal.	*/

	if substr (star_name, pi.literal_position + 1, pi.literal_length)
	     ^= substr (match_name, pi.match_position + pi.match_length + 1, pi.literal_length)
	then go to NO_MATCH_EXIT;			/* Reject if character mismatch.			*/

	return;

     end literal_end;
%page;
RETRY_COMPARE (1):					/* Retry    **.?o					*/
RETRY_STARSTAR_DOT_QUERY_LITERAL:			/* CROCK:  Saved pi.match_length is adjustment value.	*/
	pi.match_position = pi.match_position + pi.match_length + 1;
	pi.match_length = match_name_length - pi.match_position;
	if pi.match_length < 0 then go to NO_MATCH_EXIT;	/* Punt if match name is exhausted.			*/

COMPARE (1):					/* Compare  **.?o					*/
COMPARE_STARSTAR_DOT_QUERY_LITERAL:
	temp = index (substr (match_name, pi.match_position + 1, pi.match_length), DOT) - 1;
	if temp < 0 then temp = pi.match_length;	/* Find end of current component.			*/
	else if temp < pi.compare_query_count
	then do;					/* Loop until component holds Queries or last component.	*/
		pi.match_position = pi.match_position + (temp + 1);
		pi.match_length = pi.match_length - (temp + 1);
		go to COMPARE_STARSTAR_DOT_QUERY_LITERAL;
	     end;

	pi.match_position = pi.match_position + pi.compare_query_count;
	pi.match_length = pi.match_length - pi.compare_query_count;
						/* Skip over Queries.				*/
	if pi.literal_length > pi.match_length then go to NO_MATCH_EXIT;
						/* Give up if match name exhausted.			*/

	if substr (star_name, pi.literal_position + 1, pi.literal_length)
	     ^= substr (match_name, pi.match_position + 1, pi.literal_length)
	then do;					/* Does match name match literal substring at this point?	*/
		pi.match_length = temp - pi.compare_query_count;
						/* Calculate retry offset.				*/
		go to RETRY_STARSTAR_DOT_QUERY_LITERAL; /* If not, try next component.			*/
	     end;

	starstar_retry_info = pi.starstar;		/* Save in case of retry and calculate retry offset.	*/
	starstar_retry_info.match_length = temp - pi.compare_query_count;

	pi.match_position = pi.match_position + pi.literal_length;
	pi.match_length = pi.match_length - pi.literal_length;
						/* Skip literal substring and get next installment.	*/
	go to PARSE_NEW_COMPONENT;
%page;
COMPARE (2):					/* Compare  **?o					*/
	pi.match_position = pi.match_position + pi.compare_query_count;
	pi.match_length = pi.match_length - pi.compare_query_count;
	if pi.match_length < 0 then go to NO_MATCH_EXIT;	/* There must be at least Query count characters left.	*/
						/* Skip over them ONCE before doing first index.		*/

COMPARE_STARSTAR_QUERY_LITERAL:			/* Retry enters here.				*/
	temp =
	     index (substr (match_name, pi.match_position + 1, pi.match_length),
	     substr (star_name, pi.literal_position + 1, pi.literal_length)) - 1;
	if temp < 0
	then do;					/* Check for zero length literal substring.		*/
		if pi.literal_length > 0 then go to NO_MATCH_EXIT;
						/* If there is a literal string then index failed.	*/
						/* Otherwise skip to end of component, but not over Dot.	*/
						/* This is valid because the only way we can have a null	*/
						/* literal string is if the next thing is a Dot Star.	*/
		temp = index (substr (match_name, pi.match_position + 1, pi.match_length), DOT) - 1;
		if temp < 0 then temp = pi.match_length;/* Make it the whole rest of the last component.		*/
	     end;

	pi.match_position = pi.match_position + temp;	/* Skip over the intervening characters.		*/
	pi.match_length = pi.match_length - temp;

	if index (substr (match_name, pi.match_position - pi.compare_query_count + 1, pi.compare_query_count), DOT) - 1
	     < 0
	then go to HAVE_STARSTAR_MATCH;		/* If no Dot is found where Queries are, then success.	*/

RETRY_COMPARE (2):					/* Retry	  **?o					*/
	pi.match_position = pi.match_position + 1;	/* Space ove character beyond previous match to try again.	*/
	pi.match_length = pi.match_length - 1;		/* Give up if the match name is exhausted.		*/
	if pi.match_length < 0 then go to NO_MATCH_EXIT;

	go to COMPARE_STARSTAR_QUERY_LITERAL;		/* Go search for literal substring.			*/
%page;
COMPARE (5):					/* Compare  *.**.o					*/
	call skip_component ();			/* Convert to  **.o					*/

	pi.comparison = 3;				/* Update comparison index for retry if needed.		*/

COMPARE (3):					/* Compare  **.o					*/
	if pi.literal_length > pi.match_length then go to NO_MATCH_EXIT;

	if substr (match_name, pi.match_position + 1, pi.literal_length)
	     = substr (star_name, pi.literal_position + 1, pi.literal_length)
	then go to HAVE_STARSTAR_MATCH;

RETRY_COMPARE (3):					/* Retry	  **.o					*/
	pi.comparison = 4;				/* Change to **o					*/
	pi.literal_position = pi.literal_position - 1;	/* Since it wasn't immediate, include the Dot into the	*/
	pi.literal_length = pi.literal_length + 1;	/* literal substring and use **o comparison.		*/

	go to COMPARE_STARSTAR_LITERAL;


RETRY_COMPARE (4):					/* Retry	  **o					*/
	pi.match_position = pi.match_position + 1;	/* Set position one character beyond previous match and try */
	pi.match_length = pi.match_length - 1;		/* again.  Give up if match name is exhausted.		*/
	if pi.match_length <= 0 then go to NO_MATCH_EXIT;

COMPARE (4):					/* Compare  **o					*/
COMPARE_STARSTAR_LITERAL:
	temp =
	     index (substr (match_name, pi.match_position + 1, pi.match_length),
	     substr (star_name, pi.literal_position + 1, pi.literal_length)) - 1;
	if temp < 0 then go to NO_MATCH_EXIT;		/* Find the next occurance of the literal string, if any.	*/

	pi.match_position = pi.match_position + temp;	/* Skip over intervening characters.			*/
	pi.match_length = pi.match_length - temp;

HAVE_STARSTAR_MATCH:
	starstar_retry_info = pi.starstar;		/* Save current state in case this match attempt fails.	*/

	pi.match_position = pi.match_position + pi.literal_length;
	pi.match_length = pi.match_length - pi.literal_length;
						/* Skip over the actual literal string.			*/
	go to PARSE_NEW_COMPONENT;			/* Doublestar supercedes any previous Star construct info.	*/


COMPARE (6):					/* Compare  *.**o					*/
	call skip_component ();			/* Convert to  **o					*/

	pi.comparison = 4;				/* Update comparison index for retry if needed.		*/
	go to COMPARE_STARSTAR_LITERAL;		/* Finish comparison.				*/
%page;
COMPARE (7):					/* Compare  ?o					*/
	call skip_queries ();			/* Reduce to o					*/

	go to COMPARE_LITERAL;


COMPARE (8):					/* Compare  *.o					*/
	call skip_component ();			/* Reduce to o					*/

	unspec (star_retry_info.operations) = ""b;	/* We are in a new component now.			*/

COMPARE (9):					/* Compare  o					*/
COMPARE_LITERAL:
	pi.match_length = pi.match_length - pi.literal_length;
	if pi.match_length < 0 then go to NO_MATCH_EXIT;	/* Give up if there isn't room for literal substring.	*/

	if substr (star_name, pi.literal_position + 1, pi.literal_length)
	     ^= substr (match_name, pi.match_position + 1, pi.literal_length)
	then go to RETRY_STAR;			/* Try again if the literal substring doesn't match here.	*/

	pi.match_position = pi.match_position + pi.literal_length;
						/* Skip over matched literal string.			*/

	call parse ();				/* Get next installment.				*/

	go to COMPARE (pi.comparison);		/* Deliver it.					*/


RETRY_STAR:					/* Retry	  *o	(not at component boundary)		*/
	if unspec (star_retry_info.operations) ^= ""b
	then do;					/* Handle Star checkpoint, if any.			*/
		pi.star = star_retry_info;		/* Restore parser to point of most recent Star.		*/
		pi.match_position = pi.match_position + 1;
		pi.match_length = pi.match_length - 1;	/* Start scanning beyond previous match.		*/

		go to COMPARE_STAR_LITERAL;		/* We know that literal is Dotless, of nonzero length and	*/
						/* that it is not followed by a Dot, or we couldn't be	*/
						/* here, so we needn't check.				*/

RETRY_STARSTAR:
		unspec (star_retry_info.operations) = ""b;
	     end;					/* Doublestar retry supercedes Star checkpoint info.	*/

	if unspec (starstar_retry_info.operations) = ""b then go to NO_MATCH_EXIT;
						/* If no saved checkpoint, match fails.			*/

	pi.starstar = starstar_retry_info;		/* Restore parser to point of most recent DoubleStar.	*/
						/* One of comparisons 1 to 4 will be retried.		*/
	go to RETRY_COMPARE (pi.comparison);
%page;
COMPARE (10):					/* Compare  o.*o	(not at component boundary)		*/
	call must_be_at_dot ();			/* Reduce to *o					*/

	go to COMPARE_STAR_LITERAL;


COMPARE (11):					/* Compare  ?*o	(not at component boundary)		*/
	call skip_queries ();			/* Reduce to *o					*/

	go to COMPARE_STAR_LITERAL;


COMPARE (12):					/* Compare  *.*o	(not at component boundary)		*/
	call skip_component ();			/* Reduce to *o					*/

COMPARE (13):					/* Compare  *o	(not at component boundary)		*/
COMPARE_STAR_LITERAL:				/* Retry comes here.				*/
	if pi.dot_count > 0
	then do;					/* If crossed component boundary, can't retry.		*/
		call compare_star_dotted_literal ();
		go to PARSE_NEW_COMPONENT;		/* Skip over literal and get next installment.		*/
	     end;

	temp = index (substr (match_name, pi.match_position + 1, pi.match_length), DOT) - 1;
	if temp < 0 then temp = pi.match_length;	/* Find out length of this component.			*/

	temp =
	     index (substr (match_name, pi.match_position + 1, temp),
	     substr (star_name, pi.literal_position + 1, pi.literal_length)) - 1;
	if temp < 0 then go to RETRY_STARSTAR;		/* Search this component for the literal string.		*/

	pi.match_position = pi.match_position + temp;	/* Skip intervening characters.			*/
	pi.match_length = pi.match_length - temp;

	star_retry_info = pi.star;			/* Save in case of retry.				*/

	pi.match_position = pi.match_position + pi.literal_length;
	pi.match_length = pi.match_length - pi.literal_length;
						/* Skip over literal AFTER save.			*/

	call parse ();				/* Get next installment.				*/

	go to COMPARE (pi.comparison);		/* Deliver it.					*/
%page;
COMPARE (14):					/* Compare  o.*oC					*/
	call must_be_at_dot ();			/* Reduce to *oC					*/

	if pi.dot_count = 0
	then go to COMPARE_STAR_UNDOTTED_LITERAL_DOT;	/* Select easy or hard comparison based on whether literal	*/
	else go to COMPARE_STAR_DOTTED_LITERAL_DOT;	/* string crosses component boundary.			*/


COMPARE (15):					/* Compare  ?*oC					*/
	if pi.dot_count = 0 then go to COMPARE_STAR_UNDOTTED_LITERAL_DOT;
						/* If easy case, don't need to explicitly skip Queries.	*/
	call skip_queries ();

COMPARE_STAR_DOTTED_LITERAL_DOT:
	call compare_star_dotted_literal ();

	if pi.match_length > 0
	then do;					/* Must be at component boundary.			*/
		unspec (star_retry_info.operations) = ""b;
		call must_be_at_dot ();
	     end;

	go to PARSE_NEW_COMPONENT;			/* Get next installment.				*/


compare_star_dotted_literal:
     procedure ();					/* Take advantage of knowing literal contains a Dot to	*/
						/* avoid using multi-char index operators which are slower. */

	temp = index (substr (match_name, pi.match_position + 1, pi.match_length), DOT)
	     - index (substr (star_name, pi.literal_position + 1, pi.literal_length), DOT);
	if temp < 0 then go to RETRY_STARSTAR;		/* Line up the first Dots, if any in match name.		*/

	pi.match_position = pi.match_position + temp;	/* Skip over intervening characters.			*/
	pi.match_length = pi.match_length - temp;

	if substr (star_name, pi.literal_position + 1, pi.literal_length)
	     ^= substr (match_name, pi.match_position + 1, pi.literal_length)
	then go to RETRY_STARSTAR;			/* See if literal string is at designated position.  If	*/
						/* not, no RETRY_STAR because component bound crossed.	*/

	pi.match_position = pi.match_position + pi.literal_length;
	pi.match_length = pi.match_length - pi.literal_length;
						/* Skip over literal substring.			*/

	return;

     end compare_star_dotted_literal;
%page;
COMPARE (16):					/* Compare  *.*oC					*/
	call skip_component ();			/* Reduce to *oC					*/

COMPARE (17):					/* Compare  *oC					*/
COMPARE_STAR_LITERAL_DOT:				/* If there are any Dots in the literal then it crosses	*/
						/* component boundaries.  Use the harder comparison.	*/
	if pi.dot_count > 0 then go to COMPARE_STAR_DOTTED_LITERAL_DOT;

COMPARE_STAR_UNDOTTED_LITERAL_DOT:			/* Fast comparison for simple case.			*/
	temp = index (substr (match_name, pi.match_position + 1, pi.match_length), DOT) - 1;
	if temp < 0 then temp = pi.match_length;	/* Find the end of the current component.		*/

	temp = temp - pi.literal_length;		/* Back up by the number of literal characters.		*/
	if temp < pi.compare_query_count then go to NO_MATCH_EXIT;
						/* There must be room in the component for all Queries and	*/
	pi.match_position = pi.match_position + temp;	/* literals.  Skip over intervening characters.		*/

	if substr (star_name, pi.literal_position + 1, pi.literal_length)
	     ^= substr (match_name, pi.match_position + 1, pi.literal_length)
	then go to RETRY_STARSTAR;			/* If it doesn't match, can't be in this component.	*/

	pi.match_position = pi.match_position + pi.literal_length;
	pi.match_length = match_name_length - pi.match_position;

	if pi.match_length > 0
	then do;					/* Skip over Dot if present.  End of match name is OK too.	*/
		pi.match_position = pi.match_position + 1;
		pi.match_length = pi.match_length - 1;
	     end;
	else pi.match_name_exhausted = "1"b;		/* End of match name */

	go to PARSE_NEW_COMPONENT;			/* Get next installment.				*/
%page;
COMPARE (18):					/* Compare at boundary (for case  o.** => C**)		*/
	if pi.match_position < match_name_length
	then call must_be_at_dot ();			/* If any chars left, then boundary is literal Dot.	*/
	else pi.match_name_exhausted = "1"b;		/* Otherwise end of match name is boundary.		*/

	go to PARSE_NEW_COMPONENT;			/* Get next installment.				*/


COMPARE (19):					/* Compare  .	(for case o.*? => *?)		*/
	call must_be_at_dot ();			/* Reduce to C					*/

	go to PARSE_NEW_COMPONENT;			/* Get next installment.				*/


COMPARE (20):					/* Compare  o.*.					*/
	call must_be_at_dot ();			/* Reduce to *.					*/
	call skip_component ();			/* Reduce to C					*/

	go to PARSE_NEW_COMPONENT;			/* Get next installment.				*/


must_be_at_dot:
     procedure ();					/* The Dot turned out to be a literal one.		*/

	pi.match_length = pi.match_length - 1;		/* See if the Dot fits in the name.			*/
	if pi.match_length < 0 then go to NO_MATCH_EXIT;

	if substr (match_name, pi.match_position + 1, 1) ^= DOT then go to RETRY_STAR;
						/* If not a Dot, then still in the same component.	*/

	pi.match_position = pi.match_position + 1;	/* Yup.  Skip over the Dot.				*/

	return;

     end must_be_at_dot;
%page;
COMPARE (21):					/* Compare  *.*.					*/
	call skip_component ();			/* Reduce to *.					*/

COMPARE (22):					/* Compare  *.	(for cases *.? => ? and o**. => C**.)	*/
	call skip_component ();			/* Reduce to C					*/

PARSE_NEW_COMPONENT:
	unspec (star_retry_info.operations) = ""b;	/* In a new component, now, so no Star can be retried.	*/

	call parse ();				/* Continue with next installment of the star name.	*/

	go to COMPARE (pi.comparison);



skip_component:
     procedure ();					/* Find the next Dot in the match name or its end.  If the	*/
						/* end has already been reached by a previous call, there	*/
						/* are not enough components.  pi.match_name_exhausted is	*/
						/* required to indicate that an imaginary END character	*/
						/* beyond the end of the match name has also been matched.	*/

	temp = index (substr (match_name, pi.match_position + 1, pi.match_length), DOT);
	if temp = 0
	then do;					/* No Dots left.					*/
		if pi.match_name_exhausted then go to NO_MATCH_EXIT;
		pi.match_name_exhausted = "1"b;	/* Have matched END as well as last character.		*/
		pi.match_length = 0;		/* Nothing left.					*/
	     end;
	else do;					/* Skip over component.				*/
		pi.match_position = pi.match_position + temp;
		pi.match_length = pi.match_length - temp;
	     end;

	return;

     end skip_component;
%page;
COMPARE (23):					/* Compare  ?	(for case ?** => o**)		*/
	call skip_queries ();			/* After this comparison, we can't depend on being at a	*/
						/* component boundary in the match name.		*/

	call parse ();				/* Get next installment.				*/

	go to COMPARE (pi.comparison);		/* Deliver it.					*/


COMPARE (24):					/* Compare  **?	(for case **?** => o**)		*/
	do while (pi.match_length >= pi.compare_query_count);
						/* Find the first Dotless substring at least long enough	*/
						/* to contain the designated number of consecutive Queries. */
	     temp = index (substr (match_name, pi.match_position + 1, pi.compare_query_count), DOT);
	     if temp = 0 | temp > pi.compare_query_count
	     then do;				/* Eureka.					*/
		     pi.match_position = pi.match_position + pi.compare_query_count;
		     pi.match_length = pi.match_length - pi.compare_query_count;

		     go to PARSE_NEW_COMPONENT;	/* Get next installment.				*/
		end;

	     pi.match_position = pi.match_position + temp;/* Skip past the Dot we found and try again.		*/
	     pi.match_length = pi.match_length - temp;
	end;

	go to NO_MATCH_EXIT;



skip_queries:
     procedure ();					/* See if the match name has enough non-Dot characters at	*/
						/* the current position to match the star name here.	*/

	pi.match_length = pi.match_length - pi.compare_query_count;
	if pi.match_length < 0 then go to NO_MATCH_EXIT;	/* There must be at least the requisite number of chars.	*/

	if index (substr (match_name, pi.match_position + 1, pi.compare_query_count), DOT) - 1 >= 0
	then go to RETRY_STARSTAR;			/* If we found a Dot then RETRY_STAR is out of the running. */

	pi.match_position = pi.match_position + pi.compare_query_count;
						/* Skip over the designated substring.			*/
	return;

     end skip_queries;
%page;
/* The check_star_name_ entrypoint permits flexible validation and
   classification of starnames.  See check_star_name.incl.pl1 for the values
   which can be used to construct the P_check_control argument and the
   values which can be returned in the P_check_star_type argument.  Please
   refer to the code in the following procedures for comments explaining the
   action of each control flag in detail.  */

check_star_name_:
     entry (P_check_star_name, P_check_control, P_check_star_type, P_check_status);

	string (cs) = P_check_control;		/* This entrypoint lets caller specify.			*/

	call check ();				/* Do the work.					*/

	P_check_star_type = star_type;
	P_check_status = status;

	return;
%page;
/* The check_star_name_$entry entrypoint is obsolete and is retained for
   compatibility with its many callers.  The use of the check_star_name_
   entrypoint (next page) is recommended for new applications and when
   updating old programs.  Except for returning a nonstandard code, its
   operation is the same as check_star_name_ with the following control bits
   set: IGNORE_ENTRYPOINT, IGNORE_EQUAL.  */

check_star_name_$entry:
     entry (P_check_star_name, P_nonstandard_status);

	string (cs) = CHECK_STAR_ENTRY_DEFAULT;		/* Select options as listed above.			*/

	go to CHECK_FILESYS_COMMON;


/* The check_star_name_$path entrypoint is obsolete and is retained for
   compatibility with its many callers.  The use of the check_star_name_
   entrypoint (next page) is recommended for new applications and when
   updating old programs.  Except for returning a nonstandard code, its
   operation is the same as check_star_name_ with the following control bits
   set: IGNORE_ENTRYPOINT, IGNORE_EQUAL, PROCESS_ARCHIVE, PROCESS_PATH.  */

check_star_name_$path:
     entry (P_check_star_name, P_nonstandard_status);

	string (cs) = CHECK_STAR_PATH_DEFAULT;		/* Select options as listed above.			*/

CHECK_FILESYS_COMMON:
	call check ();				/* Do the work.					*/

	if status = 0
	then P_nonstandard_status = star_type;		/* Construct nonstandard code.			*/
	else P_nonstandard_status = error_table_$badstar;

	return;
%page;
check:
     procedure ();

declare	idx			fixed bin (21),
	multi_part_name		bit (1) aligned,
	saved_length		fixed bin (21),
	saved_position		fixed bin (21);

	if cs.unimplemented ^= ""b
	then do;
		status = error_table_$bad_arg;	/* UNIMPLEMENTED test(s) were selected.			*/
		go to ERROR;
	     end;

	if (cs.ignore_archive & cs.process_archive) | (cs.ignore_entrypoint & cs.process_entrypoint)
	     | (cs.ignore_path & cs.process_path)
	then do;					/* Incompatible tests were selected.			*/
		status = error_table_$inconsistent;
		go to ERROR;
	     end;

	star_name_length = maxlength (P_check_star_name); /* Pick up star name and rtrim it.  The check entrypoints	*/
	star_name_ptr = addr (P_check_star_name);	/* use different parameter names so the compiler doesn't	*/
	star_name_length = length (rtrim (star_name));	/* helpfully generate useless code to permit the same	*/
						/* parameter to appear in more than one position.		*/

	multi_part_name = "0"b;
	pi.parse_position = 0;			/* Initially assume that the whole string is to be tested.	*/
	star_type = STAR_TYPE_USE_PL1_COMPARE;
	status = 0;

/**** The absolute pathname of the root (">") and relative pathnames
      consisting only of one or more "<" characters are valid, so accept a
      null entryname after either delimiter.  Do not automatically accept
      an entirely null path.  We are not responsible for validating
      pathname syntax, as expand_pathname_ can do a better job. */

	if cs.process_path
	then do;
		pi.parse_position = search (reverse (star_name), PATH_CHARS) - 1;
		if pi.parse_position < 0
		then pi.parse_position = 0;
		else pi.parse_position = star_name_length - pi.parse_position;

		if pi.parse_position > 0
		then do;
			if ^cs.ignore_nonascii
			then do idx = 1 to pi.parse_position;

				if rank (substr (star_name, idx, 1)) > ASCII_HIGH
				then do;
					status = error_table_$badpath;
					go to ERROR;
				     end;
			     end;

			if pi.parse_position = star_name_length then return;
		     end;
	     end;

	if cs.process_archive
	then do;
		idx = index (substr (star_name, pi.parse_position + 1), ARCHIVE_DELIM) - 1;
		if idx >= 0
		then do;
			saved_length = star_name_length;
			star_name_length = pi.parse_position + idx;
			saved_position = star_name_length + length (ARCHIVE_DELIM);

			call check_substring ();
			if status ^= 0 then go to ERROR;

			pi.parse_position = saved_position;
			star_name_length = saved_length;
			if pi.parse_position = star_name_length then go to BAD_FILE_NAME;
			multi_part_name = "1"b;
		     end;
	     end;

	if cs.process_entrypoint
	then do;
		idx = search (substr (star_name, pi.parse_position + 1), ENTRYPOINT_CHARS) - 1;
		if idx = 0 then go to BAD_FILE_NAME;
		else if idx > 0
		then do;
			saved_length = star_name_length;
			star_name_length = pi.parse_position + idx;
			saved_position = star_name_length + 1;

			call check_substring ();
			if status ^= 0 then go to ERROR;

			pi.parse_position = saved_position;
			star_name_length = saved_length;
			cs.ignore_length = "1"b;
			if pi.parse_position = star_name_length then cs.ignore_null = "1"b;
			multi_part_name = "1"b;
		     end;
	     end;

	call check_substring ();
	if status ^= 0 then go to ERROR;

	if star_type ^= STAR_TYPE_USE_PL1_COMPARE
	then if cs.reject_wild then status = error_table_$nostars;
	     else if multi_part_name then star_type = STAR_TYPE_USE_MATCH_PROCEDURE;

	return;

BAD_FILE_NAME:
	status = error_table_$bad_file_name;

ERROR:
	star_type = STAR_TYPE_USE_PL1_COMPARE;
	if status = 0 then status = error_table_$badstar;

	return;
%page;
/*^This routine analyzes star names for the check_star_name_ entrypoints.
   It does no matching, and is not as speed critical as the match_star_name_
   entrypoint.  It doesn't know much about the parser.  It knows enough to
   put the parser in its initial state, and it knows three comparison index
   values and the fact that comparison values greater than MATCH_ERROR mean
   that the star name is not yet entirely parsed.  */


check_substring:
	procedure ();

	     if ^cs.ignore_length & star_name_length - pi.parse_position > MAXIMUM_FILESYS_LENGTH
	     then do;
		     status = error_table_$entlong;
		     return;
		end;

	     if ^cs.ignore_archive & index (substr (star_name, pi.parse_position + 1), ARCHIVE_DELIM) ^= 0
	     then do;
		     status = error_table_$archive_pathname;
		     return;
		end;

	     if ^cs.ignore_nonascii & ^multi_part_name
	     then do idx = pi.parse_position + 1 to star_name_length;

		     if rank (substr (star_name, idx, 1)) > ASCII_HIGH
		     then do;
			     status = error_table_$invalid_ascii;
			     return;
			end;
		end;

	     unspec (pi.operations) = ""b;		/* Initialize parser.				*/
	     pi.parse_query_count = 0;
	     status = 0;

	     call parse ();				/* Start scanning the star name.			*/

	     if pi.comparison = MATCHES_ANYTHING
	     then do;
		     star_type = STAR_TYPE_MATCHES_EVERYTHING;
		     return;
		end;

	     if pi.comparison = MATCHES_LITERAL | pi.comparison = MATCHES_NOTHING then return;

	     do while ("1"b);

		if pi.comparison <= MATCHES_ERROR
		then do;
			if pi.comparison = MATCHES_ERROR then go to ERROR;
			star_type = STAR_TYPE_USE_MATCH_PROCEDURE;
			return;
		     end;

		call parse ();			/* Continue scanning the star name.			*/
	     end;

	end check_substring;

     end check;
%page;
/*^This is where the knowledge of star name format resides.  The contract of
   the parser is to be able to identify type 0 and type 2 star names in a
   single call, to detect bad star names, and to provide information to
   drive the comparison routines when called repeatedly while matching type
   1 star names.  The parser states are shown on the next page.  Each time
   the parser is called, it returns up to four items of information:
   
   1) a Star construct (made up of Stars and Dots),
   2) a string of Queries,
   3) a literal string, and
   4) why parsing stopped.

   The parser returns when:

   1) the Star construct becomes more complex than can be represented in an
      assigned state value,
   2) a string of Queries is ended by a Star,
   3) a literal string is ended by a Star or a Query, or
   4) the end of the star name is encountered.

   Once as much of the star name as possible has been parsed, we return up
   to 5 numbers.  The index of the comparison routine for a subscripted
   goto, the count of Queries, and the position, and length of a literal
   substring of the star name.  The count of the number of Dots in the
   literal string is also returned to determine whether the literal crosses
   a component boundary (an actual count is used rather than just a flag,
   because the count can be decremented if a Star follows a Dot at the end
   of a literal).  The comparison index is based on the Star construct (if
   any) and whether Queries or a Literal are present.  In many cases, only
   some of the numbers are valid, but the comparison index is always valid.

   The parser postpones the comparison of a Doublestar as long as possible
   in the hope of finding a literal to index for or reaching the end of the
   star name.  This is done purely for reasons of efficiency: the Doublestar
   compare routines must back up the parser if certain kinds of mismatch
   occur so they can retry the comparison farther down the match name.  An
   example of a star name that might require this is "**a?a".  The first "a"
   is indexed for, then the parser is called again to get the "?a".  If it
   doesn't match, the parser is backed up and the next "a" is indexed for.
   An example of such postponement is converting "**.*.*.a" effectively into
   "*.*.**.a".  The parser also postpones comparison of Stars by commuting
   Stars and Queries (e.g., "?*?*?" is the same as "*???") because they may
   need to also back up within a component.  Star names like "*a?a" can fail
   at the query and require repositioning.			       */

parse:
     procedure ();

declare	break_pos			fixed bin (21);

declare	BREAK_CHARS		initial (".*?<>=%$|") char (9) static options (constant),
	STAR_CHARS		initial (".*?") char (3) static options (constant);
%page;
/* format: off */

/*			PARSE STATE TABLE

      0  B               12  **?*            24  o               37  o.
      1  B*              13  *?              25  *o              38  *o.
      2  *.              14  ?               26  *.o             39  *.o.
      3  *.*             15  ?*              27  *.*o            40  *.*o.
      4  *.**            16  C               28  *.**o           41  *.**o.
      5  *.**.           17  C*              29  *.**.o          42  *.**.o.
      6  *.**.*          18  C**             30  **o             43  **o.
      7  B**             19  C**.            31  **.o            44  **.o.
      8  B**.            20  C**.*           32  **.?o           45  **.?o.
      9  B**.*           21  o*              33  **?o            46  **?o.
     10  **.?            22  o**             34  *?o             47  *?o.
     11  **?             23  o.*             35  ?o              48  ?o.
                                             36  o.*o            49  o.*o.

   Notes on nomenclature:

   B   Represents the beginning of the star name.
   C   Represents a component boundary (may include B).
   o   Represents a literal, which may be null.  See next paragraph.
   E   (not shown here, but in the comparison routines) represents the end
       of the star name.

   The Star, Dot and Query characters represent themselves.

   When a literal is shown to the left of a star construct, it means that
   a literal or Query preceded the star construct.  The comparison routine
   has already matched that literal or Query.  However, its presence must
   still be remembered.  State 21 exists so that state 22 can be detected.
   State 22 is required in order to handle a Doublestar which does not begin
   at a component boundary.  States 23, 36 and 49 are used when a literal
   is ended by a ".*" because the Dot hasn't yet been compared but may not
   be a literal dot.  States 18 and 19 exist so that state 20 can be
   detected.  States 16, 17 and 20 respectively differ from states 0, 1 and
   9 because they have already skipped to the end of the preceding component
   in the match name and must check that the end of the match name has not
   already been reached.

   One of the design constraints of the parser is that it be able to digest
   any type 0 or type 2 star names in the first call.  This is done for
   higher performance.  This requires the most complex state 6 "*.**.*"
   to parse type 2 names like "**.*.**.**".

   Queries where they occur indicate the presence of at least one Query.
   The actual number of Queries is in pi.compare_query_count for
   nonterminal comparisons, and pi.parse_query_count at the end.

   Although 24 states are needed to represent all the distinct Star
   constructs which don't have literals, only 13 are needed when a literal
   is present, because some state information can be discarded.

   To keep track of null components and to recognize state 23 "o.*", an
   additional 13 states are used which indicate that a Dot is the last
   character of the literal.					       */
%page;
/* The END_OPS array selects the comparison routine for the last part of the
   star name.  All the values are negative numbers, so that the
   check_star_name_ entrypoints can tell that the end of the star name has
   been reached.  A value of zero (i.e., MATCHES_ERROR) is also interpreted
   as the end of the star name, but a positive value indicates that further
   parsing is required.

   The END_OPS array does not need a "state" value, since the parser is
   never reentered when the end of the star name is reached.  The
   HAVE_LITERAL array has been combined with it in place of the unneeded
   state table to save space.  The HAVE_LITERAL array is used without
   structure qualification because I judged it more confusing to emphasize
   the irrelevant connection to END_OPS.

   HAVE_LITERAL is used to change the parser state when a literal is
   started.  It is used in a number of action routines to save creating
   additional state tables.					       */


declare	1 END_OPS		(0:49) aligned static options (constant),

	  2 comparison		fixed bin unaligned initial
/*                                        +0    +1    +2    +3    +4    +5    +6    +7    +8    +9   +10   +11   +12	*/
/* NO LITERAL 		  0+   */ ( -4,   -8,   -6,  -14,  -17,  -27,  -19,  -17,  -24,  -17,  -28,  -22,
/*			 12+   */  -22,  -11,   -7,  -11,   -5,  -13,  -17,  -24,  -18,   -8,  -17,  -15,
/* LITERAL LAST		 24+   */   -1,   -9,   -2,  -10,  -21,  -26,  -20,  -25,  -29,  -23,  -12,   -3,  -16,
/* DOT LAST		 37+   */   -1,   -9,   -2,  -10,  -21,  -26,  -20,  -25,  -29,  -23,  -12,   -3,  -16),

	  2 HAVE_LITERAL		fixed bin unaligned initial
/*                                        +0    +1    +2    +3    +4    +5    +6    +7    +8    +9   +10   +11,  +12	*/
/* NO LITERAL 		  0+   */ ( 24,   25,   26,   27,   28,   29,   28,   30,   31,   30,   32,   33,
/*			 12+   */   33,   34,   35,   34,   24,   25,   30,   31,   30,   25,   30,   36,
/* LITERAL LAST		 24+   */   24,   25,   26,   27,   28,   29,   30,   31,   32,   33,   34,   35,   36,
/* DOT LAST		 37+   */   24,   25,   26,   27,   28,   29,   30,   31,   32,   33,   34,   35,   36);
%page;
/*^This array contains the comparison and future state values used when Dots
   are encountered.  The comparison value is negative when no comparison is
   to be performed.  In this case, the state is updated and the parser
   continues.  However, in some cases, the Dot must be interpreted as a
   literal Dot, (e.g. following a Query).  In this case, the Dot could cause
   a null component (either at the beginning of the star name or two
   consecutive Dots).  So there are three negative values:

   -1) The parser continues with only a state change.
   -2) A literal starts, but it is a null component.
   -3) A literal starts.

   When there is no literal, a positive comparison value causes the
   corresponding comparison routine to be invoked.  This reduces the amount
   of encoded state we have to remember.  For example, if we have state 3
   "*.*" then we invoke a comparison routine.  This means we don't need a
   state value for "*.*.".

   When there is already a literal, no comparison routine is ever invoked.
   The dot is simply added to the end of the literal.  There are 13 basic
   literal prefix states (see states 24 through 36), but an additional
   13 states are used to remember that the literal ends with a Dot.  This
   is used to detect null components and literals anding in ".*".	       */


declare	1 DOT_OPS		(0:49) aligned static options (constant),

	  2 comparison		fixed bin unaligned initial
/*                                        +0    +1    +2    +3    +4    +5    +6    +7    +8    +9   +10   +11   +12	*/
/* NO LITERAL 		  0+   */ ( -2,   -1,   -2,   21,   -1,   -2,   21,   -1,   -2,   -1,   -3,   -3,
/*			 12+   */   -3,   -3,   -3,   -3,   -2,   22,   -1,   -2,   22,   -1,   22,   20,
/* LITERAL LAST		 24+   */    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
/* DOT LAST		 37+   */    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0),

	  2 state			fixed bin unaligned initial
/*                                        +0    +1    +2    +3    +4    +5    +6    +7    +8    +9   +10   +11   +12	*/
/* NO LITERAL 		  0+   */ ( 37,    2,   39,   16,    5,   42,   19,    8,   44,    5,   45,   46,
/*			 12+   */   46,   47,   48,   47,   37,   16,   19,   44,   19,    2,   19,   16,
/* LITERAL LAST		 24+   */   37,   38,   39,   40,   41,   42,   43,   44,   45,   46,   47,   48,   49,
/* DOT LAST		 37+   */   37,   38,   39,   40,   41,   42,   43,   44,   45,   46,   47,   48,   49);


/* The DOT_LAST table below is used to detect null components and to
   determine when a Star following a literal is immediately preceded by a
   Dot. When detecting null components, it is convenient to assume that
   a Dot precedes the beginning of the star name, but no literal is present
   in this case so it does not affect the parsing of an initial Star.	       */


declare	DOT_LAST			(0:49) bit (1) aligned static options (constant) initial

/*                                    +0     +1     +2     +3     +4     +5     +6     +7     +8     +9    +10    +11	*/
/* NO LITERAL              0+   */ (  "1"b,  "0"b,  "1"b,  "0"b,  "0"b,  "1"b,  "0"b,  "0"b,  "1"b,  "0"b,  "0"b,  "0"b,
/*                        12+   */    "0"b,  "0"b,  "0"b,  "0"b,  "1"b,  "0"b,  "0"b,  "1"b,  "0"b,  "0"b,  "0"b,  "0"b,
/* LITERAL LAST	*/	  (13) ("0"b),
/* DOT LAST	*/	  (13) ("1"b));
%page;
/* This array contains the comparison and future state values used when
   Stars are encountered.  It can be thought of as conceptually divided into
   three regions.  The first 24 values are used when there is no literal.
   The next 13 values are used when there is a literal which does not end
   in a Dot, and the last 13 values are used when there is a literal which
   ends in a Dot.  When the comparison value is negative, it means that no
   comparison is performed.  In this case, the state is updated and parsing
   continues.  In all other cases, parsing is suspended and some comparison
   is selected.  When there is no literal, parsing is suspended either
   because the Star construct has become obviously not of type 2 (matches
   anything), or because a Doublestar has been detected following a Query.

   Any Star following a literal forces comparison.  When the literal ends in
   a Dot, the Dot is removed from the literal and becomes part of the new
   Star construct if comparison succeeds, since the Dot could be followed by
   a Doublestar.  NOTE: the literal may be reduced to zero length by the
   removal of the Dot.

   Identities are used to minimize the number of parser states:

     Simplest      More complex
      B**		B**.**
      C**		C**.**
      *.**	*.**.**
      *.**.	B**.*.
      *?		?*	*?*
      **?		**?*					       */


declare	1 STAR_OPS		(0:49) aligned static options (constant),

	  2 comparison		fixed bin unaligned initial
/*                                        +0    +1    +2    +3    +4    +5    +6    +7    +8    +9   +10   +11   +12	*/
/* NO LITERAL 		  0+   */ ( -1,   -1,   -1,   -1,    0,   -1,   -1,    0,   -1,   -1,   -1,   -1,
/*			 12+   */   24,   -1,   -1,   23,   -1,   -1,    0,   -1,   -1,   -1,    0,   18,
/* LITERAL LAST		 24+   */    9,   13,    8,   12,    6,    5,    4,    3,    1,    2,   11,    7,   10,
/* DOT LAST		 37+   */    9,   17,    8,   16,    6,    5,    4,    3,    1,    2,   15,    7,   14),
				   
	  2 state			fixed bin unaligned initial
/*                                        +0    +1    +2    +3    +4    +5    +6    +7    +8    +9   +10   +11   +12	*/
/* NO LITERAL 		  0+   */ (  1,    7,    3,    4,    0,    6,    4,    0,    9,    7,   12,   12,
/*			 12+   */   22,   15,   15,   22,   17,   18,    0,   20,   18,   22,    0,   18,
/* LITERAL LAST		 24+   */   21,   21,   21,   21,   21,   21,   21,   21,   21,   21,   21,   21,   21,
/* DOT LAST		 37+   */   23,   17,   23,   17,   23,   23,   23,   23,   23,   23,   17,   23,   17);
%page;
/* Here are the state and comparison values used when Queries are
   encountered.  The comparison value is negative when no comparison need be
   performed.  In this case, the Query is counted, the state is updated, and
   parsing continues.  The cases where a Query forces a comparison when
   there is no literal are all cases where a complex Star construct must be
   simplified before the Query can be assimilated.  For example, "*.*?" is
   reduced to "*?" by doing the comparison for "*.".  This helps keep the
   number of states down.  Queries always force comparisons when there is
   already a literal since it would be too complex to try to continue
   accumulating state information.  No table entries are needed for the
   cases where a literal is ended by a Dot because when the Query is
   preceded by a literal the state value is obtained from the
   HAVE_LITERAL array, which doesn't contain those values.		       */


declare	1 QUERY_OPS		(0:36) aligned static options (constant),

	  2 comparison		fixed bin unaligned initial
/*                                        +0    +1    +2    +3    +4    +5    +6    +7    +8    +9   +10   +11   +12	*/
/* NO LITERAL 		  0+   */ ( -1,   -1,   22,   22,   22,   22,   22,   -1,   -1,   -1,   -1,   -1,
/*			 12+   */   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   19,
/* LITERAL LAST		 24+   */    9,   13,    8,   12,    6,    5,    4,    3,    1,    2,   11,    7,   10),

	  2 state			fixed bin unaligned initial
/*                                        +0    +1    +2    +3    +4    +5    +6    +7    +8    +9   +10   +11   +12	*/
/* NO LITERAL 		  0+   */ ( 14,   13,   14,   13,   11,   10,   11,   11,   10,   11,   10,   11,
/*			 12+   */   11,   13,   14,   13,   14,   13,   11,   10,   11,   13,   11,   13,
/* LITERAL LAST		 24+   */   14,   14,   14,   14,   14,   14,   14,   14,   14,   14,   14,   14,   14);

/* format: on */
%page;
/*^Here is where we start parsing.  When the parser is entered, we have no
   literal, and to keep the size of some of the dispatch tables down and
   increase efficiency we have two different scanners: this one and another
   for when we have a literal.  We find the first break character, if any.
   There are three cases:

   1.  If there is no break character, we branch to an action routine which
       determines whether there is a trailing literal and sets up the final
       comparison.
   2.  If there is a break character but no literal, we branch to the
       appropriate action routine which will arrange any state
       transformations and comparisons.
   3.  If there is a break character with a preceding literal, we branch to
       a different action routine, after first saving the position of the
       start of the literal and stepping the parser over the new literal and
       break char.						       */


SCAN_NO_LITERAL:
	break_pos = search (substr (star_name, pi.parse_position + 1), BREAK_CHARS) - 1;
	if break_pos < 0 then go to STAR_NAME_EXHAUSTED;
	if break_pos = 0
	then do;					/* Skip parser over break char, and dispatch on it.	*/
		pi.parse_position = pi.parse_position + 1;
		go to BREAK (index (STAR_CHARS, substr (star_name, pi.parse_position, 1)));
	     end;

	pi.literal_position = pi.parse_position;	/* Remember where the literal starts.			*/

	pi.parse_position = pi.parse_position + break_pos + 1;
						/* Skip parser over literal substring and following break.	*/

	go to LITERAL_BREAK (index (STAR_CHARS, substr (star_name, pi.parse_position, 1)));


/* We come here when we are finished parsing the star name.  If we never
   before encountered a literal, we come to STAR_NAME_EXHAUSTED, otherwise
   to LITERAL_EXHAUSTED on the next page.  On this page, there is no old
   literal, but there may be a new literal.  If we were already at the end
   of the star name, there is no literal.			       */


STAR_NAME_EXHAUSTED:				/* No breaks left in star name.			*/
	if pi.parse_position = star_name_length
	then do;					/* Star name ends with Dot, Star or Query.		*/
		if DOT_LAST (pi.state) & ^cs.ignore_null then go to REJECT_NULL;
		pi.operations = END_OPS (pi.state);	/* Set final comparison type.				*/
		return;				/* Go to final comparison.				*/
	     end;

	pi.operations = END_OPS (HAVE_LITERAL (pi.state));/* First note existence of literal, and then select the	*/
						/* comparison.					*/

	pi.literal_position = pi.parse_position;	/* Remember where literal begins.			*/

	return;					/* Go to final comparison.				*/
%page;
/*^Here is the other scanner.  In this case, we know we have scanned before,
   and that we have a literal.  The three cases are slightly different:

   1.  There is no break character.  The star name is known to end in a
       literal, but we must check that it does not end in a null component.
   2.  There is no new literal string, so this break follows the preceding
       one consecutively.  A dispatch table is used which aids in detecting
       null components (two Dots in a row), since the first break must
       be valid in a literal (i.e., not a Star or a Query).
   3.  Like #3 above, but dispatched differently to extend the literal.      */


SCAN_LITERAL:
	break_pos = search (substr (star_name, pi.parse_position + 1), BREAK_CHARS) - 1;
	if break_pos < 0 then go to LITERAL_EXHAUSTED;	/* If none left then finish up star name.		*/
	if break_pos = 0
	then do;					/* Skip parser over break char, and dispatch on it.	*/
		pi.parse_position = pi.parse_position + 1;
		go to LITERAL_BREAK_BREAK (index (STAR_CHARS, substr (star_name, pi.parse_position, 1)));
	     end;

	pi.parse_position = pi.parse_position + break_pos + 1;
						/* Skip parser over literal substring and following break.	*/

	go to LITERAL_LITERAL_BREAK (index (STAR_CHARS, substr (star_name, pi.parse_position, 1)));


/* If the last component is null, we may reject it.  This was not an issue
   above since the trailing literal ensured a nonnull last component.  For
   LITERAL_EXHAUSTED, trailing nonbreak characters ensure that a Dot can't
   be the final character.  If a Dot is last, and we are checking a file
   system name, we reject it.  Otherwise, we have a simpler state transition
   than on the preceding page.				       */


LITERAL_EXHAUSTED:					/* Literal terminated by end of star name.		*/
	if pi.parse_position = star_name_length
	then if DOT_LAST (pi.state) & ^cs.ignore_null then go to REJECT_NULL;
						/* Null final components forbidden in file names.		*/

	pi.operations = END_OPS (pi.state);		/* Set final comparison type.				*/

	return;					/* Go to final comparison.				*/
%page;
/* Here we handle Dots.					       */


BREAK (1):					/* Dot, with no literal under construction.		*/
	pi.operations = DOT_OPS (pi.state);		/* Update FSM.  UNSPEC used for benefit of the following	*/
						/* statement after -list and -long_profile.		*/

	if substr (unspec (pi.operations), 1, 1) then go to DOT_ACTION (pi.comparison);
						/* If comparison is negative, then scanning may continue	*/
						/* with one of the following three actions.  Otherwise,	*/
						/* we must return and perform the comparison first.	*/
	return;


DOT_ACTION (-1):					/* Dot is part of Star construct (e.g., "*." or "**.")	*/
	go to SCAN_NO_LITERAL;			/* Find the NEXT break character.			*/


DOT_ACTION (-2):					/* Dot is first character of star name or follows another	*/
	if ^cs.ignore_null then go to REJECT_NULL;	/* Dot immediately.  Null components are forbidden in	*/
						/* file system names and this may be enforced by the	*/
						/* check_star_name_ entrypoints.			*/

DOT_ACTION (-3):					/* Dot is first character of literal.			*/
	pi.literal_position = pi.parse_position - 1;	/* Remember that literal begins here, and includes Dot.	*/

	pi.dot_count = 1;				/* There is one Dot in this literal so far (this one).	*/

	go to SCAN_LITERAL;				/* Find the NEXT break character, if any.		*/


LITERAL_BREAK (1):					/* Dot, preceded by one or more nobreak characters.	*/
	pi.operations = DOT_OPS (HAVE_LITERAL (pi.state));/* Note existence of literal and that Dot is last.	*/

	pi.dot_count = 1;				/* This literal has one Dot in it (this one) so far.	*/

	go to SCAN_LITERAL;				/* Go scan some more.				*/


LITERAL_BREAK_BREAK (1):				/* Dot, preceded by a literal Dot or invalid char.	*/
	if DOT_LAST (pi.state) & ^cs.ignore_null then go to REJECT_NULL;
						/* Have ".." and null components are prohibited in filesys. */

LITERAL_LITERAL_BREAK (1):				/* Dot, preceded by two or more nonbreak characters.	*/
	pi.operations = DOT_OPS (pi.state);		/* Remember that literal now ends in a Dot.		*/

	pi.dot_count = pi.dot_count + 1;

	go to SCAN_LITERAL;				/* Find NEXT break character.				*/
%page;
/* Here we handle Stars.					       */


BREAK (2):					/* Star, with no literal under construction.		*/
	pi.operations = STAR_OPS (pi.state);		/* Update FSM.  UNSPEC used for benefit of the following	*/
						/* statement after -list and -long_profile.		*/

	if substr (unspec (pi.operations), 1, 1) then go to SCAN_NO_LITERAL;
						/* If comparison is negative (high bit set) then no	*/
						/* comparison need be performed, and scanning continues.	*/
						/* (Negative comparisons indicate that the star name has	*/
						/* ended, which can't happen here.)			*/
	go to JOIN_STAR;				/* Otherwise, merge into return path.			*/

LITERAL_BREAK_BREAK (2):				/* Star, preceded by a literal Dot or invalid char.	*/
	if ^DOT_LAST (pi.state) then go to LITERAL_STAR;

	pi.operations = STAR_OPS (pi.state);		/* We know that the last character was a Dot.		*/

	pi.literal_length = pi.parse_position - pi.literal_position - 2;
						/* Compute literal length not to include the Dot and Star.	*/
	pi.dot_count = pi.dot_count - 1;		/* And uncount the Dot we removed.			*/

	go to JOIN_STAR;				/* Merge into return path.				*/

LITERAL_BREAK (2):					/* Star, preceded by one or more nonbreak chars.		*/
	pi.dot_count = 0;				/* Literal has no Dots in it and never will.		*/

LITERAL_LITERAL_BREAK (2):				/* Star, preceded by two or more nonbreak characters.	*/
LITERAL_STAR:					/* Note we have a literal, which does not end in a Dot.	*/
	pi.operations = STAR_OPS (HAVE_LITERAL (pi.state));

	pi.literal_length = pi.parse_position - pi.literal_position - 1;
						/* Calculate length of literal, not to include the Star.	*/

JOIN_STAR:					/* Do final accounting and exit.			*/
	pi.compare_query_count = pi.parse_query_count;	/* Tell compare routines about Queries, if any.		*/
	pi.parse_query_count = 0;			/* No Queries for next parse since break is a Star.	*/

	return;					/* Go to the comparison routine.			*/
%page;
/* Here we handle Queries that are not immediately preceded by literals.  In
   most cases, we can adjust the FSM state to note that the last character
   is a Query, increment the count of Queries, and continue parsing.  In
   some cases, a comparison is required to simplify the state (e.g., turning
   "*.*?" into "*?").					       */


BREAK (3):					/* Query, with no literal under construction.		*/
	pi.parse_query_count = pi.parse_query_count + 1;	/* Count the query.					*/

	pi.operations = QUERY_OPS (pi.state);		/* Update FSM state.  UNSPEC used here for next statement	*/
						/* after examining -list file and -long_profile.		*/

	if substr (unspec (pi.operations), 1, 1) then go to SCAN_NO_LITERAL;
						/* Indicates no comparison case.			*/

	return;					/* Go to the comparison routine.			*/
						/* Needn't set pi.compare_query_count because the selected	*/
						/* comparison will never check for Queries.		*/


/* Here we handle Queries that are immediately preceded by literals.  In
   this case, it is always necessary to do a comparison, since the parser is
   gravid with state information and cannot continue.  So we make all the
   preparations for a full blown comparison, including calculating the
   length of the literal (which is always nonzero) and making the old Query
   count available (which may be zero).  The parser's internal Query count
   is set to one so that this Query need not be reparsed.		       */


LITERAL_BREAK (3):					/* Query preceded by one or more nonbreak characters.	*/
	pi.dot_count = 0;				/* Literal has no Dots in it and never can.		*/

LITERAL_BREAK_BREAK (3):				/* Query preceded by a literal Dot or invalid char.	*/
LITERAL_LITERAL_BREAK (3):				/* Query preceded by two or more nonbreak characters.	*/
	pi.operations = QUERY_OPS (HAVE_LITERAL (pi.state));
						/* Arrange to invoke the correct comparison routine and	*/
						/* update the FSM state for later.			*/

	pi.literal_length = pi.parse_position - pi.literal_position - 1;
						/* Calculate length of literal string not to include Query. */

	pi.compare_query_count = pi.parse_query_count;	/* Copy count of leading Queries for compare routines.	*/
	pi.parse_query_count = 1;			/* Count this new Query for later.			*/

	return;					/* Go to the comparison routine.			*/
%page;
/* We come here if we encounter an invalid break character.  If we are
   matching, or checking with all invalid character tests disabled, then we
   just treat the invalid break as a literal character.  Otherwise, we must
   identify the invalid break character, and reject it if so required.
   Because this is only required when checking star names, it could be argued
   that this might be better done outside the parser.  This is faster, more
   compact, and perhaps illustrative of literal processing.  */


BREAK (0):					/* Invalid break, with no literal started yet.		*/
	pi.literal_position = pi.parse_position - 1;	/* Remember literal starts here, and includes invalid char. */

LITERAL_BREAK (0):					/* Invalid break, preceded by one or more nonbreaks.	*/
	pi.dot_count = 0;				/* Constant has no Dots in it yet.			*/

LITERAL_BREAK_BREAK (0):				/* Invalid break, preceded by a literal ending in a break.	*/
LITERAL_LITERAL_BREAK (0):				/* Invalid break, preceded by two or more nonbreaks.	*/
	pi.operations = END_OPS (pi.state);		/* Set state to HAVE_LITERAL, which is folded into the	*/
						/* END_OPS structure to save space.  This assignment is	*/
						/* more efficient than pi.state = HAVE_LITERAL (pi.state);	*/

	if index (ENTRYPOINT_CHARS, substr (star_name, pi.parse_position, 1)) ^= 0
	then do;
		if cs.ignore_entrypoint then go to SCAN_LITERAL;
		status = error_table_$bad_file_name;
		go to REJECT;
	     end;

	if index (EQUAL_CHARS, substr (star_name, pi.parse_position, 1)) ^= 0
	then do;
		if cs.ignore_equal then go to SCAN_LITERAL;
		status = error_table_$badequal;
		go to REJECT;
	     end;

	if index (PATH_CHARS, substr (star_name, pi.parse_position, 1)) ^= 0
	then do;
		if cs.ignore_path then go to SCAN_LITERAL;
		status = error_table_$bad_file_name;
		go to REJECT;
	     end;

REJECT_NULL:					/* Here for null component or reserved characters.	*/
	status = error_table_$null_name_component;

REJECT:
	pi.comparison = MATCHES_ERROR;		/* Set fatal comparison type.				*/

	return;					/* Go to fatal comparison routine.			*/

     end parse;

     end match_star_name_;
