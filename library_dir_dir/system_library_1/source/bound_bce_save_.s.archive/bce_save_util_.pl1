/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1986 *
        *                                                         *
        *********************************************************** */

/* format: style4,declareind10,dclind10,idind20,indattr,delnl,insnl,ifthenstmt */

bce_save_util_:
     procedure (a_sri_ptr);

/****^  HISTORY COMMENTS:
  1) change(86-09-18,Farley), approve(86-07-18,MCR7439),
     audit(86-09-24,Fawcett), install(86-10-20,MR12.0-1189):
     Collection of Save/Restore routines that are not part of the main
     stream save/restore loop and do not reference main stream procedures.
     Therefore they can take the time to push a stack frame.
  2) change(87-07-07,Farley), approve(87-07-17,MCR7733),
     audit(87-07-21,Fawcett), install(87-07-31,MR12.1-1051):
     Changed most of the calls to ioa_ and com_err_ to calls to syserr and
     syserr$error_code so that a time stamp will be included in the output..
  3) change(87-11-04,Farley), approve(88-02-26,MCR7811),
     audit(88-03-03,Fawcett), install(88-03-15,MR12.2-1035):
     Changed premount_check entry to only display the pre-mount message if the
     usable tape device count is greater than 1. This is needed because
     bce_save is now calling this entry without checking this count.
  4) change(87-11-16,Farley), approve(88-02-26,MCR7811),
     audit(88-03-03,Fawcett), install(88-03-15,MR12.2-1035):
     Removed the setting of part.zrec, since this value was moved to pv.zrec
     and does not need to be set to a -1.
                                                   END HISTORY COMMENTS */

dcl	a_sri_ptr		ptr parameter;		/* pointer to save/restore info */

	return;					/* main entry not used */
%page;
/**** This entry will display the contents of the "Info" tape. */

bce_save_util_$display_info_tape:
     entry (a_sri_ptr);

	call SETUP;
	call ioa_ ("^/^2x^a, version (^a)^/", info_tape_label.title, info_tape_label.version);
	call ioa_ ("^4xSave time = ^a",
	     date_time_$format ("clock", info_tape_label.save_time, "system_zone", "system_lang"));
	call ioa_ ("^4xTape set ""^a"", which contains ^d tapes^/^4xVolumes in set = ^d", info_tape_label.tape_set,
	     info_tape_label.tapes_in_set, info_tape_label.vol_array_size);
	call ioa_ (
	     "^2/^57tType of^/^50tDevice^xRecords^3xBegin^2xEnd^/^2xPhysical Volume^40tPVID^50tType^3xSaved^5xTape^3xTape^/"
	     );
	do volx = lbound (info_tape_label.vol_array, 1) to info_tape_label.vol_array_size;
	     vol_infop = addr (info_tape_label.vol_array (volx));
	     if vol_info.data_saved = PART_ONLY then do;
		rx = lbound (vol_info.region, 1);
		vol_begin_tape = vol_info.region (1).begins_on_tape;
		vol_end_tape = vol_info.region (vol_info.nregions).ends_on_tape;
	     end;
	     else do;
		rx = lbound (vol_info.region, 1) + 1;	/* skip vtoc/paging region info */
		vol_begin_tape = vol_info.region (1).begins_on_tape;
		vol_end_tape = vol_info.region (1).ends_on_tape;
	     end;
	     call ioa_ ("^2x^32a^x^12.3b^2x^4a^3x^[PV_ONLY  ^;PART_ONLY^;PV/PART  ^]^2x^3d^4x^3d", vol_info.pvname,
		vol_info.pvid, device_names (vol_info.dev_type), vol_info.data_saved + 1, vol_begin_tape,
		vol_end_tape);
	     do rx = rx to vol_info.nregions;
		call ioa_ ("^4xpartition - ^a^68t^3d^4x^3d", vol_info.region (rx).part_name,
		     vol_info.region (rx).begins_on_tape, vol_info.region (rx).ends_on_tape);
	     end;
	end;
	call ioa_ ("^2/");
	return;
%page;
/**** This entry is responsible for setting up the IOI workspace to
      allow for the IO buffers to work properly.  The workspace is setup so
      that the first page is reserved for the IO buffers and status queue
      and the remaining pages will be used for the actual data, minus the
      header (which is in the tape buffer).  This allows the data to be on
      page boundaries and easily sent to/from tape and disk without ever
      having to move it to different memory areas.  NOTE: the first 32
      words of the workspace will be reserved for other IO posibilities. */

bce_save_util_$init_buffers:
     entry (a_sri_ptr);

	call SETUP;
	tcb.buf_listx = bin (rel (tcb.wksp), 18) + 32;
	tcb.nbufs = 0;
	do iobp = ptr (tcb.wksp, tcb.buf_listx) repeat ptr (tcb.wksp, iob.next_bufx) while (tcb.nbufs < MAX_BUFFERS);
	     unspec (iob) = ""b;			/* clear buffer */
	     iob.next_bufx = bin (rel (iobp), 18) + size (iob);
						/* point to next buffer */
	     call FREE_BUFFER;			/* mark it as FREE */
	     iob.disk_post_buf = si.first_disk_post_buf + tcb.nbufs;
						/* set correct disk posting buffer */
	     tcb.nbufs = tcb.nbufs + 1;		/* up the buffer count */
	     if tcb.nbufs = MAX_BUFFERS then do;	/* LAST? */
		iob.next_bufx = 0;			/* mark this as the last */
		tcb.statusx = bin (rel (iobp), 18) + size (iob);
						/* status queue is after last buffer */
	     end;

	     iob.datax = bit (bin (tcb.nbufs * PAGE_SIZE, 18), 18);
						/* page addr = page (buf#) */

	     dcwp = addr (iob.header_dcw);
	     dcw.address = rel (addr (iob.head));
	     dcw.type = IOTP;
	     dcw.tally = bit (bin (size (rec_header), 12));

	     dcwp = addr (iob.data_dcw);
	     dcw.address = iob.datax;
	     dcw.type = IOTD;
	     dcw.tally = bit (bin (PAGE_SIZE, 12));	/* 1 page */
	end;

	tcb.status_count = tcb.nbufs;
	tcb.status_idx = 0;
	si.ioi_statusx = tcb.statusx;
	call ioi_set$status (tcb.ioi_index, si.ioi_statusx, (tcb.status_count), code);
	if code ^= 0 then do;
	     call syserr$error_code (BEEP, code, "^a: Setting status index for ^a.^66t***^/^-", my_name, tcb.name);
	     call ABORT;
	end;

	return;
%page;
/**** Entry to attach the tape device specified in tcb, via IOI. */

bce_save_util_$ioi_attach:
     entry (a_sri_ptr);

	call SETUP;
	unspec (tcb.ioi_ev_chn) = ""b;
	substr (unspec (tcb.ioi_ev_chn), 37, 36) = unspec (substr (tcb.name, 4, 4));
	tcb.wksp = null ();
	si.ioi_statusx = -1;
	call ioi_assignment$assign (tcb.ioi_index, tcb.name, tcb.ioi_ev_chn, OFF, code);
	if code ^= 0 then do;
	     call syserr$error_code (BEEP, code, "^a: Attaching ^a.^66t***^/^-", my_name, tcb.name);
	     call ABORT;
	end;
	call ioi_set$max_workspace (tcb.ioi_index, WORKSPACE_SIZE, code);
	if code ^= 0 then do;
	     call syserr$error_code (BEEP, code, "^a: Setting max workspace for ^a.^66t***^/^-", my_name, tcb.name);
unassign_device:
	     call ioi_assignment$unassign (tcb.ioi_index, code);
	     if code ^= 0 then call syserr$error_code (BEEP, code, "^a: Unassigning ^a.^66t***^/^-", my_name, tcb.name);
	     call ABORT;
	end;
	call ioi_set$workspace (tcb.ioi_index, tcb.wksp, WORKSPACE_SIZE, code);
	if code ^= 0 then do;
	     call syserr$error_code (BEEP, code, "^a: Setting up workspace for ^a.^66t***^/^-", my_name, tcb.name);
	     goto unassign_device;
	end;
	return;
%page;
/**** Entry for finding out if a given tape device is a FIPS type.
      Which is done by finding the first valid device model number from
      the PRPH card, then looking this device up in the config_data_
      segment.  If device numbers start at zero, then it is assumed to be
      part of a FIPS subsystem. */

bce_save_util_$is_fips_device:
     entry (a_sri_ptr) returns (bit (1));
dcl	tap_groupx	fixed bin;

	call SETUP;
	call config_$find_periph (substr (tcb.name, 1, 4), prph_tap_cardp);
	if prph_tap_cardp = null () then do;
	     call syserr (ANNOUNCE, "^a(^a): Tape subsystem ""^a"" is not defined in the config.", my_name, si.tape_set,
		substr (tcb.name, 1, 4));
	     call ABORT;
	end;
	do tap_groupx = lbound (prph_tap_card.group, 1) to hbound (prph_tap_card.group, 1);
	     if prph_tap_card.group (tap_groupx).model ^= 0 then do;
		do i = lbound (config_data_$tape_drive_model_names.names, 1)
		     to config_data_$tape_drive_model_names.count;
		     if config_data_$tape_drive_model_names.names (i).model = prph_tap_card.group (tap_groupx).model
		     then return (config_data_$tape_drive_model_names.names (i).device_0_valid);
		end;
		return (NO);
	     end;
	end;
	return (NO);
%page;
/**** Entry to find the last used vtoce from the vtoc_map, then
      use that to calculate the last vtoc record that is in use.  This
      is done to allow the save to not have to save the vtoc records that
      are not being used, hence speeding up the save. */

bce_save_util_$last_vtoc_used:
     entry (a_sri_ptr) returns (fixed bin (18));
dcl	ALL_FREE_IN_WORD	bit (32) int static options (constant) init ("ffffffff"b4);
dcl	bit_idx		fixed bin;
dcl	last_vtoc_record_used
			fixed bin (18);
dcl	last_vtoce_used	fixed bin;
dcl	vtoce_bit		fixed bin;

	call SETUP;
	call GET_DISK_BUFFER;
	iob.head.rec_on_pv = VTOC_MAP_ADDR;
	call READ_DISK;				/* read vtoc map */
	do while (^DISK_DATA_READY ());
	end;
	si.vol_map_ptr -> page = si.datap -> page;	/* will get overlayed by vol_map */
	call FREE_BUFFER;
	vtoc_mapp = si.vol_map_ptr;
	bit_idx = mod (vtoc_map.n_vtoce, VTOCES_PER_WORD);
	if bit_idx = 0 then bit_idx = VTOCES_PER_WORD;	/* show full word */
	bit_map_wordp = addr (vtoc_map.bit_map (vtoc_map.bit_map_n_words - 1));
	vtoce_bit = find_bit_$last_off (substr (bit_map_word.bits, 1, bit_idx));
	if vtoce_bit > 0 then do;			/* last word has used VTOCE */
	     last_vtoce_used = ((vtoc_map.bit_map_n_words - 1) * VTOCES_PER_WORD) + vtoce_bit - 1;
	     goto set_vtoc_record;
	end;
	do i = vtoc_map.bit_map_n_words - 2 by -1 to lbound (vtoc_map.bit_map, 1);
	     bit_map_wordp = addr (vtoc_map.bit_map (i));
	     if bit_map_word.bits ^= ALL_FREE_IN_WORD then goto found_last;
	end;
	return (VTOC_ORIGIN);			/* No used vtoces */
found_last:
	last_vtoce_used = (i * VTOCES_PER_WORD) + find_bit_$last_off (bit_map_word.bits) - 1;
set_vtoc_record:
	last_vtoc_record_used =
	     VTOC_ORIGIN
	     +
	     divide ((last_vtoce_used + VTOCES_PER_RECORD (pvt_array (pv.pvtx).device_type)),
	     VTOCES_PER_RECORD (pvt_array (pv.pvtx).device_type), 18);
	vtoc_mapp = null ();
	return (last_vtoc_record_used);
%page;
/**** This entry is for finding the number of the tape that should
      be on the current tape device during a restore. */

bce_save_util_$locate_tape_number:
     entry (a_sri_ptr);

	call SETUP;
	do volx = lbound (info_tape_label.vol_array, 1) to info_tape_label.vol_array_size
	     while (info_tape_label.vol_array (volx).pvname ^= pv.name);
	end;
	si.vol_info_ptr, vol_infop = addr (info_tape_label.vol_array (volx));

	if pv.only_part then do;
	     do partx = pv.part_idx repeat part_array (partx).next_idx while (part_array (partx).complete);
	     end;
	     do rx = lbound (vol_info.region, 1) to vol_info.nregions
		while (vol_info.region (rx).part_name ^= part_array (partx).name);
	     end;
	     si.first_tape_number = vol_info.region (rx).begins_on_tape;
	     do partx = partx repeat part_array (partx).next_idx while (partx ^= 0);
	     end;
	     do rx = lbound (vol_info.region, 1) to vol_info.nregions
		while (vol_info.region (rx).part_name ^= part_array (partx).name);
	     end;
	     si.last_tape_number = vol_info.region (rx).ends_on_tape;
	end;
	else do;
	     do rx = lbound (vol_info.region, 1) to vol_info.nregions while (vol_info.region (rx).part_name ^= "");
	     end;
	     si.first_tape_number = vol_info.region (rx).begins_on_tape;
	     si.last_tape_number = vol_info.region (rx).ends_on_tape;
	end;
	if si.tape_seq_number < si.first_tape_number then si.tape_seq_number = si.first_tape_number;
	if si.tape_seq_number = 0 & info_tape_label.tape_number ^= "Info"
	then si.tape_seq_number = bin (info_tape_label.tape_number, 17);
						/* start search with this tape */
	return;
%page;
/**** This entry determines if another tape, after the current one, is going
      to be needed. If needed, then a pre-mount message will be displayed to
      the operator if more than 1 device is usable. */

bce_save_util_$premount_check:
     entry (a_sri_ptr);
dcl	info_volx		fixed bin;
dcl	LARGE_TAPE_NUMBER	fixed bin int static options (constant) init (9999);
dcl	temp_pvx		fixed bin;

	call SETUP;
	si.next_tape_number = si.tape_seq_number + 1;	/* default to next tape# */
	if tcb.tape_vol_number = "" then return;	/* no current tape mounted */
	if si.restart then si.tape_seq_number = bin (tape_label.tape_number, 17);
						/* start with restart tape# */
	if si.tape_seq_number < si.last_tape_number then do;
						/* current region continues on next tape */
	     si.next_tape_number = si.tape_seq_number + 1;
	     goto display_premount;
	end;
	si.next_tape_number = LARGE_TAPE_NUMBER;	/* start very high */
	do temp_pvx = si.pvx to si.pv_count;
	     do info_volx = lbound (info_tape_label.vol_array, 1) to info_tape_label.vol_array_size
		while (info_tape_label.vol_array (info_volx).pvname ^= pv_array (temp_pvx).name);
	     end;
	     if pv_array (temp_pvx).only_part then do;
		do temp_partx = pv_array (temp_pvx).part_idx repeat part_array (temp_partx).next_idx
		     while (temp_partx ^= 0);
		     if ^part_array (temp_partx).complete then do;
			do rx = lbound (info_tape_label.vol_array (info_volx).region, 1)
			     to info_tape_label.vol_array (info_volx).nregions
			     while (info_tape_label.vol_array (info_volx).region (rx).part_name
			     ^= part_array (temp_partx).name);
			end;
			if info_tape_label.vol_array (info_volx).region (rx).begins_on_tape > si.tape_seq_number
			then if info_tape_label.vol_array (info_volx).region (rx).begins_on_tape
				< si.next_tape_number
			     then si.next_tape_number =
				     info_tape_label.vol_array (info_volx).region (rx).begins_on_tape;
			     else ;
			else if info_tape_label.vol_array (info_volx).region (rx).ends_on_tape > si.tape_seq_number
			then if info_tape_label.vol_array (info_volx).region (rx).ends_on_tape < si.next_tape_number
			     then si.next_tape_number =
				     max (info_tape_label.vol_array (info_volx).region (rx).begins_on_tape + 1,
				     si.tape_seq_number + 1);
			     else ;
			if si.next_tape_number = si.tape_seq_number + 1 then goto display_premount;
						/* can't get much closer */
		     end;
		end;
	     end;
	     else do;
		do rx = lbound (info_tape_label.vol_array (info_volx).region, 1)
		     to info_tape_label.vol_array (info_volx).nregions
		     while (info_tape_label.vol_array (info_volx).region (rx).part_name ^= "");
		end;
		if info_tape_label.vol_array (info_volx).region (rx).begins_on_tape > si.tape_seq_number
		then if info_tape_label.vol_array (info_volx).region (rx).begins_on_tape < si.next_tape_number
		     then si.next_tape_number = info_tape_label.vol_array (info_volx).region (rx).begins_on_tape;
		     else ;
		else if info_tape_label.vol_array (info_volx).region (rx).ends_on_tape > si.tape_seq_number
		then if info_tape_label.vol_array (info_volx).region (rx).ends_on_tape < si.next_tape_number
		     then si.next_tape_number =
			     max (info_tape_label.vol_array (info_volx).region (rx).begins_on_tape + 1,
			     si.tape_seq_number + 1);
		     else ;
		if si.next_tape_number = si.tape_seq_number + 1 then goto display_premount;
						/* can't get much closer */
	     end;
	end;
	if si.next_tape_number = LARGE_TAPE_NUMBER | si.next_tape_number <= si.tape_seq_number then do;
	     si.next_tape_number = si.tape_seq_number + 1;/* assume next # in sequence */
	     return;
	end;
display_premount:
	if si.usable_tape_devices > 1
	then call syserr (ANNOUNCE, "^a(^a): Please pre-mount tape# ^d on ^a.", my_name, si.tape_set,
		si.next_tape_number, FIND_NEXT_TAPE_DEVICE ());
	return;
%page;
/**** Entry that is called to read and validate a volume label.  If
      doing a restore, then several checks are also made between the
      volume label and the volume info contained in the tape label. */

bce_save_util_$read_pv_label:
     entry (a_sri_ptr);

	call SETUP;
read_pv_label:
	call read_disk ((pv.pvtx), (LABEL_ADDR), vol_preamblep, code);
	if code ^= 0 then do;
	     call syserr$error_code (BEEP, code, "^a: Could not read label of ^a on ^a.^66t***^/^-", my_name, pv.name,
		pv.device);
disk_error_query:
	     call bce_query (opr_input, "^a(^a): Do you want to retry or remove the pv? ", my_name, si.tape_set);
	     if opr_input = "retry" then goto read_pv_label;
	     else if opr_input ^= "remove" then do;
		call ioa_ ("^a(^a): Invalid input ""^a"". Must be ""retry"" or ""remove"".", my_name, si.tape_set,
		     opr_input);
		goto disk_error_query;
	     end;
	     pv.removed = YES;
	     return;
	end;
	if vol_preamble.Multics ^= Multics_ID_String then do;
	     call syserr (ANNOUNCE, "^a(^a): Volume on ^a is not a ^a.^[^;^66t***^/^-Removing from PV list.^]", my_name,
		si.tape_set, pv.device, Multics_ID_String, restoring);
	     if restoring then do;
		if pv.only_part then do;
		     call syserr (ANNOUNCE,
			"^a(^a): Unable to restore only partitions. Removing from PV list.^66t***", my_name,
			si.tape_set);
		     pv.removed = YES;
		end;
	     end;
	     else pv.removed = YES;
	     pv.real_name = pv.name;
	     return;
	end;
	call date_time_ (vol_preamble.time_map_updated, date_time_string);
	call ioa_ ("");
	call syserr (ANNOUNCE, "^a(^a): ^a ^a on ^a^/^2-Last updated: ^[Never Updated^s^;^a^]", my_name, si.tape_set,
	     Multics_ID_String, vol_preamble.pv_name, pv.device, (vol_preamble.time_map_updated = 0), date_time_string);
	pv.real_name = vol_preamble.pv_name;
	if pv.real_name ^= pv.name then do;
	     if restoring
	     then if ^pv.only_part
		then call syserr (ANNOUNCE, "^a(^a): Volume ^a will become ^a, as requested.^66t***", my_name,
			si.tape_set, vol_preamble.pv_name, pv.name);
		else ;
	     else do;
		call syserr (ANNOUNCE, "^a(^a): Volume was expected to be ^a. Removing from PV list.^66t***", my_name,
		     si.tape_set, pv.name);
		pv.removed = YES;
		return;
	     end;
	end;

	if ^restoring & pv.all_parts then do;
	     call bce_save_util_$setup_all_parts (srip);
	     if pv.removed then return;
	end;
	if pv.part_requested & (^restoring | pv.only_part) then do;
						/* only do when saving, or restoring only parts */
	     call SORT_PARTITION_LIST;
	     do partx = lbound (part_array, 1) to si.part_count;
						/* see if part defined */
		si.part_ptr, partp = addr (part_array (partx));
		if part.pv_name = pv.name & part.name ^= ALL_PARTS then do;
		     do i = lbound (vol_preamble.parts, 1) to vol_preamble.nparts
			while (vol_preamble.parts (i).part ^= part.name);
		     end;
		     if i > vol_preamble.nparts
		     then part.removed, part.complete = YES;
						/* part not on volume */
		     else do;
			part.frec = vol_preamble.parts (i).frec;
			part.lrec = vol_preamble.parts (i).frec + vol_preamble.parts (i).nrec - 1;
			part.nrec = vol_preamble.parts (i).nrec;
			if pv.restart.rec_on_pv > part.lrec then part.complete = YES;
			call ioa_ ("^- Partition ^4a:^2x^6d^2xfor^x^5d records^[ (^ad)^;^s^]", part.name, part.frec,
			     part.nrec, part.complete, my_name);
		     end;
		end;
	     end;
	     do partx = lbound (part_array, 1) to si.part_count;
						/* report about any that were removed */
		if part_array (partx).pv_name = pv.name & part_array (partx).removed
		then call syserr (ANNOUNCE,
			"^a(^a): Partition ^a is not defined on ^a.^66t***^/^-Removing from partition list.",
			my_name, si.tape_set, part_array (partx).name, vol_preamble.pv_name);
	     end;
	     if pv.only_part then do;
		do partx = lbound (part_array, 1) to si.part_count
		     while (part_array (partx).pv_name ^= pv.name | part_array (partx).removed);
		end;
		if partx > si.part_count then do;
		     call syserr (ANNOUNCE,
			"^a(^a): Removing volume ^a from PV list,^66t***^/^-because all partitions were removed.",
			my_name, si.tape_set, pv.name);
		     pv.removed = YES;
		     return;
		end;
	     end;
	end;

	if restoring then do;
	     do volx = lbound (info_tape_label.vol_array, 1) to info_tape_label.vol_array_size
		while (info_tape_label.vol_array (volx).pvname ^= pv.name);
	     end;
	     if volx > info_tape_label.vol_array_size then do;
		call syserr (ANNOUNCE, "^a(^a): Volume ^a not found in tape label.^66t***^/^-Removing from PV list.",
		     my_name, si.tape_set, pv.name);
		pv.removed = YES;
		return;
	     end;
	     si.vol_info_ptr, vol_infop = addr (info_tape_label.vol_array (volx));
	     if pv.part_requested then do;
		call SORT_PARTITION_LIST;
		do partx = lbound (part_array, 1) to si.part_count;
						/* see if part defined */
		     if part_array (partx).pv_name = pv.name & part_array (partx).name ^= ALL_PARTS then do;
			si.part_ptr, partp = addr (part_array (partx));
			do i = lbound (vol_info.region, 1) to vol_info.nregions
			     while (part.name ^= vol_info.region (i).part_name);
			end;
			if i > vol_info.nregions then do;
						/* part not found */
			     call syserr (ANNOUNCE,
				"^a(^a): Partition ^a on ^a was not saved.^66t***^/^-Removing from partition list.",
				my_name, si.tape_set, part.name, pv.name);
			     part.removed, part.complete = YES;
			end;
		     end;
		end;
	     end;
	     if pv.only_part then do;
		if vol_info.data_saved = PV_ONLY then do;
		     call syserr (ANNOUNCE,
			"^a(^a): No partitions were saved for volume ^a.^66t***^/^-Removing from PV list.", my_name,
			si.tape_set, vol_info.pvname);
		     pv.removed = YES;
		end;
		return;
	     end;
	     if vol_info.data_saved = PART_ONLY then do;
		call syserr (ANNOUNCE,
		     "^a(^a): Only partitions were saved for volume ^a.^66t***^/^-Removing from PV list.", my_name,
		     si.tape_set, vol_info.pvname);
		pv.removed = YES;
		return;
	     end;
	     if ^pv.only_part & (vol_info.dev_type ^= pvt_array (pv.pvtx).device_type) then do;
		call syserr (ANNOUNCE,
		     "^a(^a): Device type mis-match. ^a is on a ^a,^66t***^/^-but was saved from a ^a. Removing from PV list.",
		     my_name, si.tape_set, pv.name, device_names (pvt_array (pv.pvtx).device_type),
		     device_names (vol_info.dev_type));
		pv.removed = YES;
	     end;
	     return;
	end;

/* Doing Save */
/* check label times */

	if ^pv.all then do;
	     if vol_preamble.time_map_updated = vol_preamble.time_unmounted then goto label_ok;
	     if vol_preamble.time_map_updated = vol_preamble.time_salvaged
		& vol_preamble.time_map_updated > vol_preamble.time_unmounted
	     then goto label_ok;
	     call syserr (ANNOUNCE,
		"^a(^a): Volume ^a requires salvaging.^66t***^/^-Setting -all to save all paging records on the volume.",
		my_name, si.tape_set, pv.name);
	     pv.all = YES;
	end;
label_ok:
	if pv.name = "rpv" then do;
	     do partx = lbound (part_array, 1) to si.part_count
		while (part_array (partx).pv_name ^= pv.name | part_array (partx).name ^= "conf");
	     end;
	     if partx > si.part_count
	     then call syserr (ANNOUNCE, "^a(^a): The ""conf"" partition of rpv is not being saved.^66t***", my_name,
		     si.tape_set);
	     do partx = lbound (part_array, 1) to si.part_count
		while (part_array (partx).pv_name ^= pv.name | part_array (partx).name ^= "file");
	     end;
	     if partx > si.part_count
	     then call syserr (ANNOUNCE, "^a(^a): The ""file"" partition of rpv is not being saved.^66t***", my_name,
		     si.tape_set);
	     do partx = lbound (part_array, 1) to si.part_count
		while (part_array (partx).pv_name ^= pv.name | part_array (partx).name ^= "log");
	     end;
	     if partx > si.part_count
	     then call syserr (ANNOUNCE, "^a(^a): The ""log"" partition of rpv is not being saved.^66t***", my_name,
		     si.tape_set);
	end;

/* Now fill in some of the volume info */

	if si.restart then do;
	     do volx = lbound (tape_label.vol_array, 1) to tape_label.vol_array_size
		while (tape_label.vol_array (volx).pvname ^= pv.name);
	     end;
	     if volx > tape_label.vol_array_size then do;
		call syserr (ANNOUNCE,
		     "^a(^a): Volume ^a not found in restart tape label.^66t***^/^-Removing from PV list.", my_name,
		     si.tape_set, pv.name);
		pv.removed = YES;
		return;
	     end;
	     si.vol_info_ptr, vol_infop = addr (tape_label.vol_array (volx));
	     if vol_info.pvid ^= vol_preamble.pvid then do;
		call syserr (ANNOUNCE,
		     "^a(^a): Volume ^a's PVID does not match^66t***^/^-the one in the restart tape label. Removing from PV list.",
		     my_name, si.tape_set, pv.name);
		pv.removed = YES;
		return;
	     end;
	     if (pv.only_part & vol_info.data_saved ^= PART_ONLY)
		| (^pv.part_requested & vol_info.data_saved = BOTH_SAVED) then do;
		call syserr (ANNOUNCE,
		     "^a(^a): Type of data being saved for volume ^a^66t***^/^-does not match the type in the restart tape label.^/^-Removing from PV list.",
		     my_name, si.tape_set, pv.name);
		pv.removed = YES;
		return;
	     end;
	     do partx = lbound (part_array, 1) to si.part_count;
		if part_array (partx).pv_name = vol_info.pvname then do;
		     do i = lbound (vol_info.region, 1) to vol_info.nregions
			while (vol_info.region (i).part_name ^= part_array (partx).name);
		     end;
		     if i > vol_info.nregions then do;
			call syserr (ANNOUNCE,
			     "^a(^a): Partition ^a of volume ^a^66t***^/^-is not defined in the restart tape label. Removing from PV list.",
			     my_name, si.tape_set, part_array (partx).name, vol_info.pvname);
			pv.removed = YES;
			return;
		     end;
		end;
	     end;
	end;
	else do;					/* normal path */
	     tape_label.vol_array_size = tape_label.vol_array_size + 1;
	     si.vol_info_ptr, vol_infop = addr (tape_label.vol_array (tape_label.vol_array_size));
	     si.first_rec, si.last_rec, vol_info.restart.rec_on_pv, vol_info.restart.rec_in_type = -1;
	     vol_info.pvname = vol_preamble.pv_name;
	     vol_info.pvid = vol_preamble.pvid;
	     if pv.only_part then vol_info.data_saved = PART_ONLY;
	     else if pv.part_requested then vol_info.data_saved = BOTH_SAVED;
	     else vol_info.data_saved = PV_ONLY;
	     vol_info.dev_type = pvt_array (pv.pvtx).device_type;
	     vol_info.nregions = 0;
	     if ^pv.only_part then do;		/* define vtoc/paging region */
		vol_info.nregions = vol_info.nregions + 1;
		vol_info.region (vol_info.nregions).part_name = "";
		vol_info.region (vol_info.nregions).begins_on_tape = 0;
		vol_info.region (vol_info.nregions).ends_on_tape = 0;
	     end;
	     do partx = lbound (part_array, 1) to si.part_count;
		if part_array (partx).pv_name = pv.name & ^part_array (partx).removed then do;
		     vol_info.nregions = vol_info.nregions + 1;
		     vol_info.region (vol_info.nregions).part_name = part_array (partx).name;
		     vol_info.region (vol_info.nregions).begins_on_tape = 0;
		     vol_info.region (vol_info.nregions).ends_on_tape = 0;
		end;
	     end;
	     vol_info.current_region = 1;
	end;
	return;
%page;
/**** Entry to read and parse save/restore control files that are kept in
      the FILE partition on the RPV. */

bce_save_util_$scan_control_file:
     entry (a_sri_ptr);
dcl	cf		char (cf_len) based (cf_ptr);
dcl	cf_arg		char (cf_arg_lth) based (cf_arg_ptr);
dcl	cf_arg_lth	fixed bin;
dcl	cf_arg_ptr	ptr;
dcl	1 cf_array	(32) aligned based (cf_array_ptr) like cf_info;
dcl	cf_array_ptr	ptr;
dcl	cf_idx		fixed bin (21);
dcl	cf_len		fixed bin (21);
dcl	cf_line		char (256) varying;
dcl	cf_line_start	fixed bin;
dcl	cf_ptr		ptr;
dcl	chk_start		fixed bin;
dcl	expect_cf_arg	bit (1);
dcl	have_cf_arg	bit (1);
dcl	line_count	fixed bin;
dcl	nl_idx		fixed bin;
dcl	part_device	char (8);
dcl	part_pv_name	char (32);
dcl	temp_pvtx		fixed bin (17);

	call SETUP;
	cf_array_ptr = sri.cf_arrayp;
	call bootload_fs_$get_ptr ((cf_array (sri.cfx).name), cf_array (sri.cfx).ptr, cf_array (sri.cfx).length, code);
	if code ^= 0 then do;
	     call syserr$error_code (BEEP, code, "^a: Initiating ^a for set-^d^66t***^/^-", my_name,
		cf_array (sri.cfx).name, setx);
	     call ABORT;
	end;
	cf_ptr = cf_array (sri.cfx).ptr;
	cf_len = cf_array (sri.cfx).length;
	cf_idx = 1;
	line_count = 0;
	do while (cf_idx < cf_len);
	     nl_idx = index (substr (cf, cf_idx), NL);
	     if nl_idx = 0 then do;
		call ioa_ ("^a: Line ^d of ^a does not end with a line_feed character.", my_name, line_count + 1,
		     cf_array (sri.cfx).name);
		call ABORT;
	     end;
	     line_count = line_count + 1;
	     cf_line = ltrim (rtrim (substr (cf, cf_idx, nl_idx), BREAKS), BREAKS);
	     cf_arg_ptr = addr (cf_line);
	     cf_line_start = 1;
	     have_cf_arg = YES;
	     if index (COMMENT_CHARS, substr (cf_line, 1, 1)) > 0 then have_cf_arg = NO;
						/* skip comment line */
	     expect_cf_arg = YES;
	     do while (have_cf_arg);
		call GET_CF_ARG;
		if ^have_cf_arg then goto end_cf_arg_scan;
		if ^expect_cf_arg then do;
		     call ioa_ ("^a: Invalid argument ""^a""^/^-at line ^d of ^a for set-^[^a^s^;^s^d^].", my_name,
			cf_arg, line_count, cf_array (sri.cfx).name, (si.tape_set ^= ""), si.tape_set, setx);
		     call ABORT;
		end;

/**** tape_set, ts TAPE_SET_NAME */

		if cf_arg = "tape_set" | cf_arg = "ts" then do;
		     if si.tape_set ^= "" then do;
			call ioa_ ("^a: Attempt to multiply define tape set name ""^a""^/^-at line ^d of ^a.",
			     my_name, si.tape_set, line_count, cf_array (sri.cfx).name);
			call ABORT;
		     end;
		     call GET_CF_ARG;		/* get tape set name */
		     if ^have_cf_arg then do;
bad_ts_arg:
			call ioa_ ("^a: Invalid tape_set request at line ^d of ^a.", my_name, line_count,
			     cf_array (sri.cfx).name);
			call ABORT;
		     end;
		     if cf_arg_lth > length (si.tape_set) then goto bad_ts_arg;
		     do i = lbound (set_info, 1) to setx - 1;
						/* check for multiple definitions */
			if set_info (i).tape_set = cf_arg then do;
			     call ioa_ ("^a: Tape set ^a has been multiply defined^/^-at line ^d of ^a.", my_name,
				cf_arg, line_count, cf_array (sri.cfx).name);
			     call ABORT;
			end;
		     end;
		     si.tape_set = cf_arg;		/* now save name */
		     expect_cf_arg = NO;
		end;

/**** tape_device, td TAPE_DEVICE {-density N, -den N, density=N, den=N, d=N} */

		else if cf_arg = "tape_device" | cf_arg = "td" then do;
		     si.tape_count = si.tape_count + 1;
		     si.usable_tape_devices = si.usable_tape_devices + 1;
		     if si.tape_count > hbound (tcb_array, 1) then do;
			call ioa_ ("^a: Attempt to define more than ^d tape devices for set-^[^a^s^;^s^d^].",
			     my_name, hbound (tcb_array, 1), (si.tape_set ^= ""), si.tape_set, setx);
			call ABORT;
		     end;
		     si.tcb_ptr, tcbp = addr (tcb_array (si.tape_count));
		     unspec (tcb) = ""b;		/* start fresh */

		     call GET_CF_ARG;		/* get device name */
		     if ^have_cf_arg then do;
bad_td_arg:
			call ioa_ ("^a: Invalid tape_drive request at line ^d of ^a for set-^[^a^s^;^s^d^].",
			     my_name, line_count, cf_array (sri.cfx).name, (si.tape_set ^= ""), si.tape_set, setx);
			call ABORT;
		     end;
		     if substr (cf_arg, 1, 3) ^= "tap" then goto bad_td_arg;
		     do i = lbound (set_info, 1) to setx;
						/* check for multiple definitions */
			do j = FIRST_TAPE_DEV_IDX to set_info (i).tape_count;
			     tcb_arrayp = addr (tcb_area (i, 0));
			     if tcb_array (j).name = cf_arg then do;
				call ioa_ ("^a: Device ^a has been multiply defined.", my_name, cf_arg);
				call ABORT;
			     end;
			end;
		     end;
		     tcb.name = cf_arg;		/* now save name */

		     call GET_CF_ARG;		/* get density, if available. */
		     if ^have_cf_arg then do;		/* no arg */
			if restoring
			then tcb.density = ANY_DENSITY;
						/* restore, allow any */
			else tcb.density = DEN6250;	/* save, default to 6250 */
			goto end_cf_arg_scan;
		     end;
		     if substr (cf_arg, 1, 2) = "-d" then do;
			call GET_CF_ARG;
			if ^have_cf_arg then goto bad_td_arg;
			if cf_arg = "6250" then tcb.density = DEN6250;
			else if cf_arg = "1600" then tcb.density = DEN1600;
			else if cf_arg = "800" then tcb.density = DEN800;
			else if cf_arg = "556" then tcb.density = DEN556;
			else goto bad_td_arg;
		     end;
		     else do;
			if after (cf_arg, "=") = "6250" then tcb.density = DEN6250;
			else if after (cf_arg, "=") = "1600" then tcb.density = DEN1600;
			else if after (cf_arg, "=") = "800" then tcb.density = DEN800;
			else if after (cf_arg, "=") = "556" then tcb.density = DEN556;
			else goto bad_td_arg;
		     end;
		     expect_cf_arg = NO;
		end;

/**** physical_volume, pv PV_NAME DEVICE_NAME {-all} */

		else if cf_arg = "physical_volume" | cf_arg = "pv" then do;
		     si.pv_count = si.pv_count + 1;
		     if si.pv_count > hbound (pv_array, 1) then do;
			call ioa_ ("^a: Attempt to ^a more than ^d physical volumes for set-^[^a^s^;^s^d^].",
			     my_name, my_name, hbound (pv_array, 1), (si.tape_set ^= ""), si.tape_set, setx);
			call ABORT;
		     end;
		     si.pv_ptr, pvp = addr (pv_array (si.pv_count));
		     unspec (pv) = ""b;		/* start fresh */

		     call GET_CF_ARG;		/* get pv_name */
		     if ^have_cf_arg then do;
bad_pv_arg:
			call ioa_ ("^a: Invalid pv request at line ^d of ^a for set-^[^a^s^;^s^d^].", my_name,
			     line_count, cf_array (sri.cfx).name, (si.tape_set ^= ""), si.tape_set, setx);
			call ABORT;
		     end;
		     if restoring
		     then chk_start = 1;		/* check all sets */
		     else chk_start = setx;		/* only check this set */
		     do i = chk_start to setx;
			pv_arrayp = addr (pv_area (i, 1));
			do j = lbound (pv_array, 1) to si.pv_count;
						/* check for multiple definitions */
			     if pv_array (j).name = cf_arg then do;
				call ioa_ (
				     "^a: PV ^a has been multiply defined at line ^d of ^a for set-^[^a^s^;^s^d^].",
				     my_name, cf_arg, line_count, cf_array (sri.cfx).name, (si.tape_set ^= ""),
				     si.tape_set, setx);
				call ABORT;
			     end;
			end;
		     end;
		     pv.name = cf_arg;		/* now save name */

		     call GET_CF_ARG;		/* get device name */
		     if ^have_cf_arg then goto bad_pv_arg;
		     if cf_arg_lth > 8 then goto bad_pv_arg;
		     pv.device = cf_arg;
		     call disk_name_pvtx ((pv.device), temp_pvtx, code);
		     if code ^= 0 then do;
			call com_err_ (code, my_name, pv.device);
			goto bad_pv_arg;
		     end;
		     pv.pvtx = temp_pvtx;
		     if ^restoring then do;
			call GET_CF_ARG;		/* check for -all */
			if ^have_cf_arg then pv.all = NO;
			else if cf_arg = "-all" | cf_arg = "-a" then pv.all = YES;
			else goto bad_pv_arg;
		     end;
		     pv.restart.rec_on_pv, pv.restart.rec_in_type = 0;
		     pv.only_part = NO;
		     pv.part_requested = NO;
		     pv.complete = NO;
		     pv.removed = NO;
		     expect_cf_arg = NO;
		end;

/**** partition, part PV_NAME DEVICE_NAME PART_NAME(-all) {PART_NAME ...} */

		else if cf_arg = "partition" | cf_arg = "part" then do;
		     call GET_CF_ARG;		/* get pv_name */
		     if ^have_cf_arg then do;
bad_part_arg:
			call ioa_ ("^a: Invalid part request at line ^d of ^a for set-^[^a^s^;^s^d^].", my_name,
			     line_count, cf_array (sri.cfx).name, (si.tape_set ^= ""), si.tape_set, setx);
			call ABORT;
		     end;
		     part_pv_name = cf_arg;		/* now save pv_name */

		     call GET_CF_ARG;		/* get device name */
		     if ^have_cf_arg then goto bad_part_arg;
		     if cf_arg_lth > 8 then goto bad_part_arg;
		     part_device = cf_arg;
		     call disk_name_pvtx (part_device, temp_pvtx, code);
		     if code ^= 0 then do;
			call com_err_ (code, my_name, part_device);
			goto bad_part_arg;
		     end;

		     call GET_CF_ARG;		/* get part_name */
		     if ^have_cf_arg then goto bad_part_arg;
						/* must have at least one */
		     do while (have_cf_arg);
			si.part_count = si.part_count + 1;
			if si.part_count > hbound (part_array, 1) then do;
			     call ioa_ ("^a: Attempt to ^a more than ^d partitions for set-^[^a^s^;^s^d^].",
				my_name, my_name, hbound (part_array, 1), (si.tape_set ^= ""), si.tape_set, setx);
			     call ABORT;
			end;
			si.part_ptr, partp = addr (part_array (si.part_count));
			unspec (part) = ""b;	/* start fresh */
			part.pv_name = part_pv_name;	/* save pv_name */
			part.device = part_device;
			part.pv_pvtx = temp_pvtx;

			if cf_arg = "alt" | cf_arg = "hc" then do;
			     call ioa_ ("^a: Not allowed to ^a the ""^a"" partition.", my_name, my_name, cf_arg);
			     goto bad_part_arg;
			end;
			if part.pv_name = "rpv" & cf_arg = "bce" then do;
			     call ioa_ ("^a: Not allowed to ^a the ""bce"" partition of the RPV.", my_name, my_name)
				;
			     goto bad_part_arg;
			end;
			if restoring
			then chk_start = 1;		/* check all sets */
			else chk_start = setx;	/* only check this set */
			if cf_arg = ALL_PARTS
			then doing_all_parts = YES;
			else doing_all_parts = NO;
			do i = chk_start to setx;
			     part_arrayp = addr (part_area (i, 1));
			     part_entries = 0;
			     do j = lbound (part_array, 1) to si.part_count;
				if part_array (j).pv_name = part.pv_name then do;
				     part_entries = part_entries + 1;
				     if part_array (j).name = ALL_PARTS then doing_all_parts = YES;
						/* check for multiple definitions */
				     if part_array (j).name = cf_arg then do;
					call ioa_ (
					     "^a: Partition ^a of ^a has been multiply defined at line ^d of ^a for set-^[^a^s^;^s^d^].",
					     my_name, cf_arg, part.pv_name, line_count, cf_array (sri.cfx).name,
					     (si.tape_set ^= ""), si.tape_set, setx);
					call ABORT;
				     end;
				end;
			     end;
			     if doing_all_parts & part_entries > 1 then do;
				call ioa_ (
				     "^a: Invalid partition request at line ^d of ^a for set-^[^a^s^;^s^d^].^/^-No other partition names can be given when ""-all"" is used.",
				     my_name, line_count, cf_array (sri.cfx).name, (si.tape_set ^= ""),
				     si.tape_set, setx);
				call ABORT;
			     end;
			end;
			part.name = cf_arg;
			if PARTITION_COUNT (part.pv_name) > MAX_PARTS_PER_VOL then do;
			     call ioa_ ("^a: Attempt to ^a more than ^d partitions per volume for ^a.", my_name,
				my_name, MAX_PARTS_PER_VOL, part.pv_name);
			     call ABORT;
			end;
			part.complete = NO;
			part.removed = NO;
			part.frec, part.lrec, part.nrec = -1;
			part.tfrec, part.tlrec, part.tnrec = -1;

			call GET_CF_ARG;		/* get next part name */
		     end;
		     expect_cf_arg = NO;
		end;

/**** control_file, cf CONTROL_FILE_NAME */

		else if cf_arg = "control_file" | cf_arg = "cf" then do;
		     call GET_CF_ARG;
		     if ^have_cf_arg then do;
			call ioa_ (
			     "^a: No file given for control_file request at line ^d of ^a for set-^[^a^s^;^s^d^].",
			     my_name, line_count, cf_array (sri.cfx).name, (si.tape_set ^= ""), si.tape_set, setx);
			call ABORT;
		     end;
		     sri.cf_count = sri.cf_count + 1;	/* extend control file array */
		     if sri.cf_count > hbound (cf_array, 1) then do;
			call ioa_ ("^a: Attempt to process more than ^d control files.", my_name,
			     hbound (cf_array, 1));
			call ABORT;
		     end;
		     if cf_arg_lth > length (cf_array (1).name) then do;
			call ioa_ ("^a: Illegal control file name ""^a"" on line ^d of ^a for set-^[^a^s^;^s^d^].",
			     my_name, cf_arg, line_count, cf_array (sri.cfx).name, (si.tape_set ^= ""), si.tape_set,
			     setx);
			call ABORT;
		     end;
		     unspec (cf_array (sri.cf_count)) = ""b;
		     do i = lbound (cf_array, 1) to sri.cf_count - 1
			while (cf_array (i).name ^= cf_arg | (cf_array (i).set ^= setx & ^restoring));
		     end;
		     if i ^= sri.cf_count then do;
			call ioa_ (
			     "^a: Control file ""^a"" has be multiply specified on line ^d of ^a for set-^[^a^s^;^s^d^].",
			     my_name, cf_arg, line_count, cf_array (sri.cfx).name, (si.tape_set ^= ""), si.tape_set,
			     setx);
			call ABORT;
		     end;
		     cf_array (i).name = cf_arg;
		     cf_array (i).set = setx;
		     cf_array (i).length = 0;
		     cf_array (i).ptr = null ();
		     expect_cf_arg = NO;
		end;
		else do;
		     call ioa_ ("^a: Invalid request ""^a""^/^-at line ^d of ^a for set-^[^a^s^;^s^d^].", my_name,
			cf_arg, line_count, cf_array (sri.cfx).name, (si.tape_set ^= ""), si.tape_set, setx);
		     call ABORT;
		end;
end_cf_arg_scan:
	     end;
next_cf_line:
	     cf_idx = cf_idx + nl_idx;		/* skip to next line */
	end;
	return;
%page;
/**** This entry is used to scan the tape device survey data, returned
      by the tape controller. Then extract the speed and densities available.
      a_tcbp is required because we may have switched to the controller tcb
      to do the survey but need to reference the device tcb. */

bce_save_util_$scan_survey_data:
     entry (a_sri_ptr, a_tcbp);
dcl	a_tcbp		ptr;

	call SETUP;
	do i = lbound (survey_ws.handler, 1) to hbound (survey_ws.handler, 1);
	     if unspec (survey_ws.data.handler (i)) ^= ""b & survey_ws.data.handler (i).number = a_tcbp -> tcb.device
	     then goto found_device;
	end;
	call syserr$error_code (BEEP, error_table_$no_device, "^a: ^a", my_name, a_tcbp -> tcb.name);
	return;

found_device:
	if ^survey_ws.data.handler (i).operational then do;
	     call syserr$error_code (BEEP, error_table_$device_not_usable, "^a: ^a", my_name, a_tcbp -> tcb.name);
	     return;
	end;

	a_tcbp -> tcb.densities_available = density_table (survey_ws.data.handler (i).density);
	if a_tcbp -> tcb.write_tape & (a_tcbp -> tcb.densities_available & a_tcbp -> tcb.density) = ""b then do;
						/* density not available */
	     call syserr$error_code (BEEP, error_table_$bad_density, "^a: ^a", my_name, a_tcbp -> tcb.name);
	     return;
	end;
	density_idx = index (a_tcbp -> tcb.density, ON);
	a_tcbp -> tcb.density_command = density_commands (density_idx);

	a_tcbp -> tcb.speed = speed_table (survey_ws.data.handler (i).speed);
	if a_tcbp -> tcb.speed = ""b then do;		/* something is amiss */
	     call syserr$error_code (BEEP, error_table_$incorrect_device_type, "^a: ^a", my_name, a_tcbp -> tcb.name);
	     return;
	end;
	a_tcbp -> tcb.surveyed = YES;
	return;
%page;
/**** Entry to create entries in the part_array when "-all" was
      given in the part request. When saving, the info comes from the
      vol_preamble. When restoring, the info comes from the info_tape_label. */

bce_save_util_$setup_all_parts:
     entry (a_sri_ptr);

	call SETUP;
	if restoring then do;
	     do volx = lbound (info_tape_label.vol_array, 1) to info_tape_label.vol_array_size
		while (info_tape_label.vol_array (volx).pvname ^= pv.name);
	     end;
	     if volx > info_tape_label.vol_array_size then return;
						/* volume not defined */
	     si.vol_info_ptr, vol_infop = addr (info_tape_label.vol_array (volx));
	     if vol_info.data_saved = PV_ONLY then do;
		if pv.only_part then do;		/* game over for this PV */
		     call syserr (ANNOUNCE,
			"^a(^a): No partitions were saved for volume ^a.^66t***^/^-Removing from PV list.", my_name,
			si.tape_set, vol_info.pvname);
		     pv.removed = YES;
		end;
		return;
	     end;
	     do i = lbound (vol_info.region, 1) to vol_info.nregions;
		if vol_info.region (i).part_name ^= "" then do;
		     do partx = lbound (part_array, 1) to si.part_count
			while (part_array (partx).pv_name ^= pv.name
			| part_array (partx).name ^= vol_info.region (i).part_name);
			if part_array (partx).pv_name = pv.name & part_array (partx).name = ALL_PARTS then do;
			     si.part_ptr, partp = addr (part_array (partx));
			     goto fill_in_part_entry_for_restore;
						/* reuse this entry */
			end;
		     end;
		     if partx > si.part_count then do;	/* need to add */
			if partx > hbound (part_array, 1)
			then call syserr (ANNOUNCE,
				"^a(^a): Unable to ^a ""^a"" partition.^66t***^/^-Internal partition list full.",
				my_name, si.tape_set, my_name, vol_preamble.parts (i).part);
			else if PARTITION_COUNT (pv.name) = MAX_PARTS_PER_VOL
			then call syserr (ANNOUNCE,
				"^a(^a): Unable to ^a ""^a"" partition.^66t***^/^-^d partitions already defined",
				my_name, si.tape_set, my_name, vol_preamble.parts (i).part, MAX_PARTS_PER_VOL);
			else do;
			     si.part_count = partx;
			     si.part_ptr, partp = addr (part_array (si.part_count));
fill_in_part_entry_for_restore:
			     unspec (part) = ""b;
			     part.name = vol_info.region (i).part_name;
			     part.pv_name = pv.name;
			     part.device = pv.device;
			     part.pv_pvtx = pv.pvtx;
			     part.complete = NO;
			     part.removed = NO;
			     part.frec, part.lrec, part.nrec = -1;
			     part.tfrec, part.tlrec, part.tnrec = -1;
			end;
		     end;
		end;
	     end;
	end;
	else do;					/* doing a save */
	     part_entries = 0;
	     do i = lbound (vol_preamble.parts, 1) to vol_preamble.nparts;
		if vol_preamble.parts (i).part ^= "alt" & vol_preamble.parts (i).part ^= "bce"
		     & vol_preamble.parts (i).part ^= "hc" then do;
		     do partx = lbound (part_array, 1) to si.part_count
			while (part_array (partx).pv_name ^= pv.name
			| part_array (partx).name ^= vol_preamble.parts (i).part);
			if part_array (partx).pv_name = pv.name & part_array (partx).name = ALL_PARTS then do;
			     si.part_ptr, partp = addr (part_array (partx));
			     goto fill_in_part_entry_for_save;
						/* reuse this entry */
			end;
		     end;
		     if partx > si.part_count then do;	/* need to add */
			if partx > hbound (part_array, 1)
			then call syserr (ANNOUNCE,
				"^a(^a): Unable to ^a ""^a"" partition.^66t***^/^-Internal partition list full.",
				my_name, si.tape_set, my_name, vol_preamble.parts (i).part);
			else if PARTITION_COUNT (pv.name) = MAX_PARTS_PER_VOL
			then call syserr (ANNOUNCE,
				"^a(^a): Unable to ^a ""^a"" partition.^66t***^/^-^d partitions already defined",
				my_name, si.tape_set, my_name, vol_preamble.parts (i).part, MAX_PARTS_PER_VOL);
			else do;
			     si.part_count = partx;
			     si.part_ptr, partp = addr (part_array (si.part_count));
fill_in_part_entry_for_save:
			     unspec (part) = ""b;
			     part.name = vol_preamble.parts (i).part;
			     part.pv_name = pv.name;
			     part.device = pv.device;
			     part.pv_pvtx = pv.pvtx;
			     part.complete = NO;
			     part.removed = NO;
			     part.frec = vol_preamble.parts (i).frec;
			     part.lrec = vol_preamble.parts (i).frec + vol_preamble.parts (i).nrec - 1;
			     part.nrec = vol_preamble.parts (i).nrec;
			     part.tfrec, part.tlrec, part.tnrec = -1;
			end;
		     end;
		     part_entries = part_entries + 1;
		end;
	     end;
	     if part_entries = 0 then do;
		if pv.only_part then do;
		     call syserr (ANNOUNCE,
			"^a(^a): Removing volume ^a from PV list,^66t***^/^-because there are no partitions to save.",
			my_name, si.tape_set, pv.name);
		     pv.removed = YES;
		     return;
		end;
		call syserr (ANNOUNCE,
		     "^a(^a): Reverting ""-all"" partition request^66t***^/^-for volume ^a, because there are no partitions to save.",
		     my_name, si.tape_set, pv.name);
		pv.part_requested, pv.all_parts = NO;
		return;
	     end;
	end;
	call SORT_PARTITION_LIST;
	return;
%page;
/**** Entry that is called after a time-out waiting for a tape mount.
      That asks if the current device should be skipped and the next
      device in the list be used.  It might be that the current device is
      defective and the tape cannot be mounted. */

bce_save_util_$skip_tape_device:
     entry (a_sri_ptr) returns (bit (1));

	call SETUP;
skip_query:
	call bce_query (opr_input, "^a(^a): Would you like to skip to the next tape device?", my_name, si.tape_set);
	if opr_input = "yes" | opr_input = "y" then return (YES);
	else if opr_input = "no" | opr_input = "n" then return (NO);
	else if opr_input = "remove" then do;
	     if si.usable_tape_devices = 1 then do;
		call ioa_ ("^a(^a): Unable to remove ^a. This is the last device.", my_name, si.tape_set, tcb.name);
		goto skip_query;
	     end;
	     tcb.removed = YES;			/* remove & */
	     si.usable_tape_devices = si.usable_tape_devices - 1;
	     return (YES);				/* skip device */
	end;
	else if opr_input = "help" | opr_input = "?" then do;
	     call ioa_ ("Valid inputs are:");
	     call ioa_ ("yes, y^21t- Skip this device and go to next.");
	     call ioa_ ("no, n^21t- Continue to use this device.");
	     call ioa_ ("remove^21t- Remove this device, skip to next.");
	     goto skip_query;
	end;
	else do;
	     call ioa_ ("Invalid input ""^a"". Type ""help"" or ""?"" for valid inputs.", opr_input);
	     goto skip_query;
	end;
	return;
%page;
/**** This entry is used during a restore to get the PV list generated
      from processing the control files into the same order that the save
      tape label has them in.  This is necessary to allow sequential tape
      processing. */

bce_save_util_$sort_pv_list:
     entry (a_sri_ptr);
dcl	pv_from_idx	fixed bin;
dcl	1 pv_hold_area	aligned like pv;
dcl	pv_to_idx		fixed bin;
dcl	temp_volx		fixed bin;

	call SETUP;
	pv_to_idx = 1;				/* start with first PV slot */
	do temp_volx = lbound (info_tape_label.vol_array, 1) to info_tape_label.vol_array_size;
	     do pv_from_idx = lbound (pv_array, 1) to si.pv_count;
		if pv_array (pv_from_idx).name = info_tape_label.vol_array (temp_volx).pvname then do;
		     pv_hold_area = pv_array (pv_to_idx);
						/* save current info */
		     pv_array (pv_to_idx) = pv_array (pv_from_idx);
						/* swap in new info */
		     pv_array (pv_from_idx) = pv_hold_area;
						/* replace with old */
		     pv_to_idx = pv_to_idx + 1;
		     goto next_tape_vol;
		end;
	     end;
next_tape_vol:
	end;
	return;
%page;
/**** Entry to connect all the non-removed partitions for a given
      pv into a threaded list.  Then the part_idx in the pv entry is
      setup to point to the start of the list. */

bce_save_util_$thread_partition_list:
     entry (a_sri_ptr);
dcl	first_part_idx	fixed bin;
dcl	prev_part_idx	fixed bin;

	call SETUP;
	do si.pvx = lbound (pv_array, 1) to si.pv_count;
	     si.pv_ptr, pvp = addr (pv_array (si.pvx));
	     if pv.part_requested then do;
		prev_part_idx = -1;
		do partx = lbound (part_array, 1) to si.part_count;
		     if part_array (partx).pv_name = pv.name & ^part_array (partx).removed then do;
			if prev_part_idx > 0
			then part_array (prev_part_idx).next_idx = partx;
			else first_part_idx = partx;
			part_array (partx).next_idx = 0;
			prev_part_idx = partx;
		     end;
		end;
		pv.part_idx = first_part_idx;
	     end;
	end;
	return;
%page;
/**** ABORT - Routine to force program termination and cleanup to be done. */

ABORT:
     procedure;

	signal sub_request_abort_;
	return;
     end ABORT;
%page;
/**** Routine to check if an outstanding disk I/O has completed. Returns
      YES or NO based on the results.

      NOTE: This routine is duplicated in bce_save.pl1 to save having to
      push a stack frame. */

DISK_DATA_READY:
     procedure () returns (bit (1));

	if iob.state = DISK_READY then return (YES);
	call bootload_disk_io$test_done (iob.disk_post_buf, code);
	if code = error_table_$not_done then return (NO);
	if code ^= 0 then do;			/* until something better */
	     call syserr$error_code (BEEP, code, "^a: ^a", my_name, pv.name);
	     call ABORT;
	end;
	iob.state = DISK_READY;
	iob.state_time = clock ();
	return (YES);
     end DISK_DATA_READY;
%page;
/**** Procedure to find the next tape device to be used and return
      its name. */

FIND_NEXT_TAPE_DEVICE:
     procedure () returns (char (8));
dcl	temp_tcbx		fixed bin;

	do temp_tcbx = si.tcbx + 1 to si.tape_count while (tcb_array (temp_tcbx).removed);
	end;
	if temp_tcbx > si.tape_count then do;		/* wrap around */
	     do temp_tcbx = FIRST_TAPE_DEV_IDX to si.tape_count while (tcb_array (temp_tcbx).removed);
	     end;
	     if temp_tcbx > si.tape_count then return ("????");
	end;
	return (tcb_array (temp_tcbx).name);
     end FIND_NEXT_TAPE_DEVICE;
%page;
/**** Small routine to mark an I/O buffer as free.

      NOTE: This routine is duplicated in bce_save.pl1 to save having to
      push a stack frame. */

FREE_BUFFER:
     procedure;

	iob.state = FREE;
	iob.state_time = clock ();
	return;
     end FREE_BUFFER;
%page;
/**** This procedure is used to locate the next argument in a line.
      If one is found a pointer, length and flag are set. Otherwise
      the flag is reset, which will be used to sequence to the next
      line. */

GET_CF_ARG:
     procedure;

	if cf_line_start > length (cf_line) then do;
	     have_cf_arg = NO;
	     return;
	end;
	cf_arg_lth = search (substr (cf_line, cf_line_start), BREAKS) - 1;
	if cf_arg_lth = -1 then cf_arg_lth = length (cf_line) - cf_line_start + 1;

	if cf_arg_lth = 0 then do;
	     have_cf_arg = NO;
	     return;
	end;
	cf_arg_ptr = addr (substr (cf_line, cf_line_start));
	cf_line_start = cf_line_start + cf_arg_lth + 1;
	have_cf_arg = YES;
	return;
     end GET_CF_ARG;
%page;
/**** Routine to locate a free I/O buffer and mark it as suspended for
      disk I/O.  The caller must have previously called BUFFER_AVAILABLE
      so that the routine does not abort when none can be found.

      NOTE: This routine is duplicated in bce_save.pl1 to save having to
      push a stack frame. */

GET_DISK_BUFFER:
     procedure;

	do iobp = ptr (tcb.wksp, tcb.buf_listx) repeat ptr (tcb.wksp, iob.next_bufx) while (rel (iobp) ^= ""b);
	     if iob.state = FREE then do;
		iob.state = DISK_SUSPEND;
		iob.state_time = clock ();
		iob.next_statex = 0;
		si.datap = ptr (tcb.wksp, iob.datax);
		return;
	     end;
	end;
	call syserr (CRASH, "bce_save_util_: Out of disk buffers for ^a.", si.tape_set);
     end GET_DISK_BUFFER;
%page;
/**** Procedure to find the number of requested partitions for a given
      volume. The threads are not used, as they may not be setup. */

PARTITION_COUNT:
     procedure (p_pvname) returns (fixed bin);
dcl	p_pvname		char (32) aligned parm;
dcl	part_count_for_vol	fixed bin;

	part_count_for_vol = 0;
	do temp_partx = lbound (part_array, 1) to si.part_count;
	     if part_array (temp_partx).pv_name = p_pvname then part_count_for_vol = part_count_for_vol + 1;
	end;
	return (part_count_for_vol);
     end PARTITION_COUNT;
%page;
/**** Routine that take an I/O buffer that has been queued for a disk read
      and asks that it now take place.

      NOTE: This routine is duplicated in bce_save.pl1 to save having to
      push a stack frame. */

READ_DISK:
     procedure;

	iob.state = DISK_BUSY;
	iob.state_time = clock ();
	call bootload_disk_io$queue_read ((pv.pvtx), (iob.head.rec_on_pv), 1, ptr (tcb.wksp, iob.datax),
	     iob.disk_post_buf, code);
	return;
     end READ_DISK;
%page;
/**** Routine to setup the per-set pointers. */

SETUP:
     procedure;

	srip = a_sri_ptr;
	if sri.version_id ^= sri_version_1 then do;
	     call syserr$error_code (BEEP, error_table_$unimplemented_version, "^a: sri", my_name);
	     call ABORT;
	end;
	setx = sri.set_index;
	restoring = sri.doing_restore;
	my_name = sri.whoami;
	pvt_arrayp = sri.pvt_array_ptr;
	si_ptr = addr (set_info (setx));
	if si.version_id ^= si_version_1 then do;
	     call syserr$error_code (BEEP, error_table_$unimplemented_version, "^a: si", my_name);
	     call ABORT;
	end;
	iobp = null ();
	info_tape_labelp = si.info_tape_label_ptr;
	part_arrayp = addr (part_area (setx, 1));
	partp = si.part_ptr;
	pv_arrayp = addr (pv_area (setx, 1));
	pvp = si.pv_ptr;
	tape_labelp = si.tape_label_ptr;
	tcb_arrayp = addr (tcb_area (setx, 0));
	tcbp = si.tcb_ptr;
	vol_preamblep = si.vol_preamble_ptr;
	vol_infop = si.vol_info_ptr;
	return;
     end SETUP;
%page;
/**** This procedure is used during a save or restore to get the Partition
      list generated from processing the control files into an order that
      will match the way that they will be saved or restored.  This is
      necessary to allow sequential tape processing.  During a save the
      order is based on the physical position of the partition on the
      volume being saved.  During a restore the order is based on the
      sequence they are in the vol_info.regions array. */

SORT_PARTITION_LIST:
     procedure;
dcl	low_part_frec	fixed bin;
dcl	low_px		fixed bin;
dcl	part_from_idx	fixed bin;
dcl	1 part_hold_area	aligned like part;
dcl	part_to_idx	fixed bin;
dcl	px		fixed bin;
dcl	sort_done		bit (1);
dcl	water_mark	fixed bin;


	if restoring then do;
	     do part_to_idx = lbound (part_array, 1) to si.part_count
		while (part_array (part_to_idx).pv_name ^= pv.name);
						/* locate first partition */
	     end;
	     do rx = lbound (vol_info.region, 1) to vol_info.nregions;
		do part_from_idx = part_to_idx to si.part_count;
		     if part_array (part_from_idx).pv_name = pv.name
			& part_array (part_from_idx).name = vol_info.region (rx).part_name then do;
			part_hold_area = part_array (part_to_idx);
						/* save current info */
			part_array (part_to_idx) = part_array (part_from_idx);
						/* swap in new info */
			part_array (part_from_idx) = part_hold_area;
						/* replace with old */
			do part_to_idx = part_to_idx + 1 to si.part_count
			     while (part_array (part_to_idx).pv_name ^= pv.name);
						/* locate next partition */
			end;
			goto next_rx;
		     end;
		end;
next_rx:
	     end;
	end;
	else do;
	     sort_done = NO;
	     do part_to_idx = lbound (part_array, 1) to si.part_count
		while (part_array (part_to_idx).pv_name ^= pv.name);
						/* locate first partition */
	     end;
	     water_mark = 0;
	     do while (^sort_done);
		low_part_frec = vol_preamble.vol_size;	/* set to highest possible */
		do px = lbound (vol_preamble.parts, 1) to vol_preamble.nparts;
		     if vol_preamble.parts (px).frec < low_part_frec & vol_preamble.parts (px).frec > water_mark
		     then do;
			low_part_frec = vol_preamble.parts (px).frec;
			low_px = px;
		     end;
		end;
		if low_part_frec < vol_preamble.vol_size then do;
		     water_mark = low_part_frec;	/* bring up the low end */
		     do part_from_idx = part_to_idx to si.part_count;
			if part_array (part_from_idx).pv_name = pv.name
			     & part_array (part_from_idx).name = vol_preamble.parts (low_px).part then do;
			     part_hold_area = part_array (part_to_idx);
						/* save current info */
			     part_array (part_to_idx) = part_array (part_from_idx);
						/* swap in new info */
			     part_array (part_from_idx) = part_hold_area;
						/* replace with old */
			     do part_to_idx = part_to_idx + 1 to si.part_count
				while (part_array (part_to_idx).pv_name ^= pv.name);
						/* locate next partition */
			     end;
			     goto next_low_part;
			end;
		     end;
		end;
		else sort_done = YES;
next_low_part:
	     end;
	end;
	return;
     end SORT_PARTITION_LIST;
%page;
/**** Automatic */

dcl	code		fixed bin (35);
dcl	date_time_string	char (24);
dcl	density_idx	fixed bin;
dcl	doing_all_parts	bit (1);
dcl	i		fixed bin;
dcl	j		fixed bin;
dcl	my_name		char (8);
dcl	opr_input		char (128);		/* area to hold operator input */
dcl	partx		fixed bin;
dcl	part_entries	fixed bin;
dcl	restoring		bit (1);
dcl	rx		fixed bin;
dcl	setx		fixed bin (17);		/* current set_info index */
dcl	temp_partx	fixed bin;
dcl	volx		fixed bin;
dcl	vol_begin_tape	fixed bin;
dcl	vol_end_tape	fixed bin;

/**** Based variables */

dcl	1 cf_info		aligned based,
	  2 name		char (32),		/* name of file */
	  2 set		fixed bin,		/* SET file is in */
	  2 length	fixed bin (21),		/* char length of file */
	  2 ptr		ptr;			/* pointer to file */

dcl	1 part_area	(4, 64) aligned like part based (sri.part_area_ptr);

dcl	1 pv_area		(4, 63) aligned like pv based (sri.pv_area_ptr);

dcl	1 set_info	(4) aligned like si based (sri.set_infop);

dcl	1 tcb_area	(4, 0:16) aligned like tcb based (sri.tcb_area_ptr);

dcl	page		(0:1023) bit (36) aligned based;

/**** Constants & Builtins */

dcl	ALL_PARTS		char (4) int static options (constant) init ("-all");
dcl	ANY_DENSITY	bit (5) int static options (constant) init ("11111"b);
dcl	BREAKS		char (5) int static options (constant) init ("
	 ");						/* breaks: NL HT SP VT FF */
dcl	COMMENT_CHARS	char (3) int static options (constant) init ("""/&");
dcl	DEN556		bit (5) int static options (constant) init ("01000"b);
dcl	DEN800		bit (5) int static options (constant) init ("00100"b);
dcl	DEN1600		bit (5) int static options (constant) init ("00010"b);
dcl	DEN6250		bit (5) int static options (constant) init ("00001"b);
dcl	FIRST_TAPE_DEV_IDX	fixed bin int static options (constant) init (1);
dcl	IOTD		bit (2) unaligned int static options (constant) init ("00"b);
dcl	IOTP		bit (2) unaligned int static options (constant) init ("01"b);
dcl	MAX_BUFFERS	fixed bin int static options (constant) init (6);
dcl	MAX_PARTS_PER_VOL	fixed bin int static options (constant) init (7);
dcl	NL		char (1) int static options (constant) init ("
");
dcl	NO		bit (1) aligned int static options (constant) init ("0"b);
dcl	OFF		bit (1) aligned int static options (constant) init ("0"b);
dcl	ON		bit (1) aligned int static options (constant) init ("1"b);
dcl	VTOCES_PER_WORD	fixed bin (17) int static options (constant) init (32);
dcl	WORKSPACE_SIZE	fixed bin (18) int static options (constant) init (7168);
dcl	YES		bit (1) aligned int static options (constant) init ("1"b);
dcl	density_commands	(5) bit (6) int static options (constant) init ("64"b3, "61"b3, "60"b3, "65"b3, "41"b3);
dcl	density_table	(0:15) bit (5) int static options (constant)
						/* Used to set density characteristic. */
			init ("00010"b,		/* 1600 */
			"11100"b,			/* 200 , 556 , 800 */
			"00000"b,			/* Invalid */
			"00000"b,			/* Invalid */
			"11110"b,			/* 200, 556, 800, 1600 */
			"01110"b,			/* 556, 800, 1600 */
			"00000"b,			/* Invalid */
			"00111"b,			/* 800, 1600, 6250 */
			"00110"b,			/* 800, 1600 */
			"01100"b,			/* 556, 800 */
			"00000"b,			/* Invalid */
			"00011"b,			/* 1600, 6250 */
			"00000"b,			/* Invalid */
			"00000"b,			/* Invalid */
			"00000"b,			/* Invalid */
			"00000"b);		/* Invalid */
dcl	speed_table	(0:7) bit (3) int static options (constant)
						/* Used to set speed characteristics. */
			init ("000"b,		/* Invalid */
			"100"b,			/* 75 ips */
			"010"b,			/* 125 ips */
			"000"b,			/* Invalid */
			"001"b,			/* 200 ips */
			"000"b,			/* Invalid */
			"000"b,			/* Invalid */
			"000"b);			/* Invalid */

/**** Buffer State Constants */

dcl	FREE		fixed bin int static options (constant) init (0);
dcl	DISK_SUSPEND	fixed bin int static options (constant) init (1);
dcl	DISK_BUSY		fixed bin int static options (constant) init (3);
dcl	DISK_READY	fixed bin int static options (constant) init (4);

dcl	(addr, after, bin, bit, clock, divide, hbound, index, lbound, length, ltrim, max, mod, null, ptr, rel, rtrim,
	search, size, substr, unspec)
			builtin;

dcl	sub_request_abort_	condition;

/**** External variables & entries */

dcl	error_table_$bad_density
			fixed bin (35) ext static;
dcl	error_table_$device_not_usable
			fixed bin (35) ext static;
dcl	error_table_$incorrect_device_type
			fixed bin (35) ext static;
dcl	error_table_$no_device
			fixed bin (35) ext static;
dcl	error_table_$not_done
			fixed bin (35) ext static;
dcl	error_table_$unimplemented_version
			fixed bin (35) ext static;

dcl	bce_query		entry options (variable);
dcl	bootload_disk_io$queue_read
			entry (fixed bin, fixed bin (18), fixed bin, ptr, fixed bin, fixed bin (35));
dcl	bootload_disk_io$test_done
			entry (fixed bin, fixed bin (35));
dcl	bootload_fs_$get_ptr
			entry (char (*), ptr, fixed bin (21), fixed bin (35));
dcl	com_err_		entry () options (variable);
dcl	config_$find_periph entry (char (4) aligned, ptr);
dcl	date_time_	entry (fixed bin (71), char (*));
dcl	date_time_$format	entry (char (*), fixed bin (71), char (*), char (*)) returns (char (250) var);
dcl	disk_name_pvtx	entry (char (8), fixed bin (17), fixed bin (35));
dcl	ioa_		entry () options (variable);
dcl	ioi_assignment$assign
			entry (fixed bin, char (*) aligned, fixed bin (71), bit (1) aligned, fixed bin (35));
dcl	ioi_assignment$unassign
			entry (fixed bin, fixed bin (35));
dcl	ioi_set$max_workspace
			entry (fixed bin, fixed bin (18), fixed bin (35));
dcl	ioi_set$status	entry (fixed bin, fixed bin (18), fixed bin (8), fixed bin (35));
dcl	ioi_set$workspace	entry (fixed bin, ptr, fixed bin (18), fixed bin (35));
dcl	read_disk		entry (fixed bin, fixed bin (18), ptr, fixed bin (35));
dcl	syserr		entry () options (variable);
dcl	syserr$error_code	entry () options (variable);
dcl	find_bit_$last_off	entry (bit (*)) returns (fixed bin (24));
%page;
%include bce_ioi_post_area;
%page;
%include bce_subsystem_info_;
%page;
%include bsr_structures;
%page;
%include bsr_tape_data;
%page;
%include bootload_post_area;
%page;
%include config_data_dcls;
%page;
%include config_prph_tap_card;
%page;
%include disk_pack;
%page;
%include fs_dev_types;
%page;
%include io_status_word;
%page;
%include ioi_stat;
%page;
%include iom_dcw;
%page;
%include iom_pcw;
%page;
%include pvt;
%page;
%include pvte;
%page;
%include syserr_constants;
%page;
%include tape_error_interp;
%page;
%include vol_map;
%page;
%include vtoc_map;
%page;
/*^ BEGIN MESSAGE DOCUMENTATION

   Message:
   bce_save_util_: Out of disk buffers for TAPE_SET.

   S:	$crash

   T:	$init

   M:	$err

   A:	$inform

   Message:
   restore: Attaching TAPE_DEV. ERR_MESSAGE

   S:	$beep

   T:	$init

   M:	IOI has returned a non-zero error code in response to a request
   to assign TAPE_DEV.

   A:	$recover

   Message:
   restore: Could not read label of PV_NAME on DISK_DEV. ERR_MESSAGE

   S:	$beep

   T:	$init

   M:	The volume label of the PV could not be read due to the error
   given in ERR_MESSAGE.

   A:	A operator query is done to find out if the read should be
   retried or the PV removed from the list.

   Message:
   restore(TAPE_SET): Device type mis-match. PV_NAME is on a DEV_TYPE,
	but was saved from a DEV_TYPE.

   S:	$info

   T:	$init

   M:	The program is unable to restore the contents of the PV because
   the disk device currently being used is different than the one in use
   when the PV was saved.  Only partitions can be restored to PVs mounted
   on different devices.

   A:	$recover

   Message:
   restore: Initiating CONTROL_FILE_NAME for set-TAPE_SET_IDX ERR_MESSAGE

   S:	$beep

   T:	$init

   M:	An error was detected while initiating the restore control file.

   A:	$inform $recover

   Message:
   restore(TAPE_SET): MULTICS_VOL_ID PV_NAME on DISK_DEV
                       Last updated: DATE_TIME

   S:	$info

   T:	$init

   M:	Just an informative message.

   A:	$ignore

   Message:
   restore(TAPE_SET): No partitions were saved for volume PV_NAME.
                      Removing from PV list.
   S:	$info

   T:	$init

   M:	A request has been made to restore one or more partitions on

   PV_NAME, but the save tape indicates that no partitions were saved.

   A:	Remove the partition reference from the control file.

   Message:
   restore(TAPE_SET): Only partitions were saved for volume PV_NAME.

   S:	$info

   T:	$init

   M:	A request to restore the contents of a PV has been made, but
   when the PV was saved only partitions were included.

   A:	Correct the control file(s) accordingly.

   Message:
   restore(TAPE_SET): Partition PARTITION_NAME is not defined on PV_NAME.

   S:	$info

   T:	$init

   M:	A request to restore specific partition has been made, but the
   partition does not exist of the PV.

   A:	Correct the control file(s) accordingly.

   Message:
   restore(TAPE_SET): Partition PARTITION_NAME on PV_NAME was not saved.

   S:	$info

   T:	$init

   M:	A request was made to restore a partition from a PV, but the
   partition was not saved as part of this tape set.

   A:	Correct the control file(s) accordingly.

   Message:
   restore(TAPE_SET): Please pre-mount tape# TAPE_NUMBER on TAPE_DEV.

   S:	$info

   T:	$init

   M:	The program is able to look ahead and find the tape that will be
   required next. This is an informative message that allows the restore
   to move at a faster pace.

   A:	Mount the specified tape on the specified device.

   Message:
   restore(TAPE_SET): Removing volume PV_NAME from PV list,
	because all partitions were removed.

   S:	$info

   T:	$init

   M:	It is nolonger necessary for the program to keep track of the
   PV, since all of the partition requests have been removed.

   A:	Correct the control files accordingly.

   Message:
   restore: Setting max workspace for TAPE_DEV. ERR_MESSAGE

   S:	$beep

   T:	$init

   M:	IOI has returned a non-zero error code in response to a request
   to set the max workspace size for TAPE_DEV.

   A:	$inform

   Message:
   restore: Setting up workspace for TAPE_DEV. ERR_MESSAGE

   S:	$beep

   T:	$init

   M:	IOI has returned a non-zero error code from the request to
   create a workspace for TAPE_DEV.

   A:	$inform

   Message:
   restore: TAPE_DEV ERR_MESSAGE

   S:	$beep

   T:	$init

   M:	An error occured while scanning the tape subsystem survey data.

   A:	$recover

   Message:
   restore(TAPE_SET): Tape subsystem "SUB_SYS" is not defined in the config.

   S:	$info

   T:	$init

   M:	No "prph" entry could be found for the tape subsystem.

   A:	Correct config_deck or save/restore control file(s) to indicate
   proper tape subsystem.

   Message:
   restore(TAPE_SET): Unable to restore "PARTITION_NAME" partition.
	Internal partition list full.

   S:	$info

   T:	$init

   M:	More partitions have been requested than the program can handle.

   A:	Change control files to reduce the number defined, possibly by
   breaking them up into seperate tape sets.

   Message:
   restore(TAPE_SET): Unable to restore "PARTITION_NAME" partition.
	N partitions already defined

   S:	$info

   T:	$init

   M:	An attempt has been made to restore more than the N maximum
   partitions allowed.

   A:	Change control files(s) to reduce the number requested.

   Message:
   restore(TAPE_SET): Unable to restore only partitions.

   S:	$info

   T:	$init

   M:	A request to restore partition information on this PV was made,
   but the PV does not contain a vaild label to locate the partition
   information.  The PV is removed from the restore list.

   A:	$recover

   Message:
   restore(TAPE_SET): Volume PV_NAME not found in tape label.
		  Removing from PV list.

   S:	$info

   T:	$init

   M:	A request was made to restore a PV, but the PV was not saved as
   part of this tape set.

   A:	Correct the control file(s) accordingly.

   Message:
   restore(TAPE_SET): Volume PV_NAME will become NEW_PV_NAME, as requested.

   S:	$info

   T:	$init

   M:	The PV to be restored currently has a dirrerent label than that
   to be restored. This is only an informative message to make the user
   aware of the change.

   A:	$ignore

   Message:
   restore(TAPE_SET): Volume on DISK_DEV is not a MULTICS_VOL_ID.

   S:	$info

   T:	$init

   M:	Informative message to let the operator know that the volume
   does not currently contain a valid Multics label.

   A:	$ignore

   Message:
   restore: si ERR_MESSAGE

   S:	$beep

   T:	$init

   M:	An error has been found with the internal "si" structure. $err

   A:	$inform

   Message:
   restore: sri ERR_MESSAGE

   S:	$beep

   T:	$init

   M:	An error has been found with the internal "sri" structure. $err

   A:	$inform

   Message:
   save: Attaching TAPE_DEV. ERR_MESSAGE

   S:	$beep

   T:	$init

   M:	IOI has returned a non-zero error code in response to a request
   to assign TAPE_DEV.

   A:	$recover

   Message:
   save: Could not read label of PV_NAME on DISK_DEV. ERR_MESSAGE

   S:	$beep

   T:	$init

   M:	The volume label of the PV could not be read due to the error
   given in ERR_MESSAGE.

   A:	A operator query is done to find out if the read should be
   retried or the PV removed from the list.

   Message:
   save: Initiating CONTROL_FILE_NAME for set-TAPE_SET_IDX ERR_MESSAGE

   S:	$beep

   T:	$init

   M:	An error was detected while initiating the save control file.

   A:	$inform $recover

   Message:
   save(TAPE_SET): MULTICS_VOL_ID PV_NAME on DISK_DEV
                       Last updated: DATE_TIME

   S:	$info

   T:	$init

   M:	Just an informative message.

   A:	$ignore

   Message:
   save(TAPE_SET): Partition PARTITION_NAME is not defined on PV_NAME.

   S:	$info

   T:	$init

   M:	A request to save specific partition has been made, but the
   partition does not exist of the PV.

   A:	Correct the control file(s) accordingly.

   Message:
   save(TAPE_SET): Partition PARTITION_NAME of volume PV_NAME
	is not defined in the restart tape label.

   S:	$info

   T:	$init

   M:	There is an inconsistency between the restart tape and the save
   control file(s).

   A:	Either correct the control file(s) or start the save over from
   the beginning.

   Message:
   save(TAPE_SET): Removing volume PV_NAME from PV list,
	because there are no partitions to save.

   S:	$info

   T:	$init

   M:	Only partition requests were made for this volume and now for
   various reasons there are none left to save.

   A:	$recover

   Message:
   save(TAPE_SET): Removing volume PV_NAME from PV list,
	because all partitions were removed.

   S:	$info

   T:	$init

   M:	It is nolonger necessary for the program to keep track of the
   PV, since all of the partition requests have been removed.

   A:	Correct the control files accordingly.

   Message:
   save(TAPE_SET): Reverting "-all" partition request
	for volume PV_NAME, because there are no partitions to save.

   S:	$info

   T:	$init

   M:	This PV_NAME has no partitions defined.

   A:	$ignore

   Message:
   save: Setting max workspace for TAPE_DEV. ERR_MESSAGE

   S:	$beep

   T:	$init

   M:	IOI has returned a non-zero error code in response to a request
   to set the max workspace size for TAPE_DEV.

   A:	$inform

   Message:
   save: Setting up workspace for TAPE_DEV. ERR_MESSAGE

   S:	$beep

   T:	$init

   M:	IOI has returned a non-zero error code from the request to
   create a workspace for TAPE_DEV.

   A:	$inform

   Message:
   save: TAPE_DEV ERR_MESSAGE

   S:	$beep

   T:	$init

   M:	An error occured while scanning the tape subsystem survey data.

   A:	$recover

   Message:
   save(TAPE_SET): Tape subsystem "SUB_SYS" is not defined in the config.

   S:	$info

   T:	$init

   M:	No "prph" entry could be found for the tape subsystem.

   A:	Correct config_deck or save/restore control file(s) to indicate
   proper tape subsystem.

   Message:
   save(TAPE_SET): The "conf" partition of rpv is not being saved.

   S:	$info

   T:	$init

   M:	Just an informative message.

   A:	Add the request to the save control file if desired.

   Message:
   save(TAPE_SET): The "file" partition of rpv is not being saved.

   S:	$info

   T:	$init

   M:	Just an informative message.

   A:	Add the request to the save control file if desired.

   Message:
   save(TAPE_SET): The "log" partition of rpv is not being saved.

   S:	$info

   T:	$init

   M:	Just an informative message.

   A:	Add the request to the save control file if desired.

   Message:
   save(TAPE_SET): Type of data being saved for volume PV_NAME
	does not match the type in the restart tape label.

   S:	$info

   T:	$init

   M:	There is an inconsistency between the restart tape and the save
   control file(s).

   A:	Either correct the control file(s) or start the save over from
   the beginning.

   Message:
   save(TAPE_SET): Unable to save "PARTITION_NAME" partition.
	Internal partition list full.

   S:	$info

   T:	$init

   M:	More partitions have been requested than the program can handle.

   A:	Change control files to reduce the number defined, possibly by
   breaking them up into seperate tape sets.

   Message:
   save(TAPE_SET): Unable to save "PARTITION_NAME" partition.
	N partitions already defined

   S:	$info

   T:	$init

   M:	An attempt has been made to save more than the N maximum
   partitions allowed.

   A:	Change control files(s) to reduce the number requested.

   Message:
   save(TAPE_SET): Volume PV_NAME not found in restart tape label.

   S:	$info

   T:	$init

   M:	There is an inconsistency between the restart tape and the save
   control file(s).

   A:	Either correct the control file(s) or start the save over from
   the beginning.

   Message:
   save(TAPE_SET): Volume PV_NAME requires salvaging.
	Setting -all to save all paging records on the volume.

   S:	$info

   T:	$init

   M:	Just an informative message.

   A:	$ignore

   Message:
   save(TAPE_SET): Volume PV_NAME's PVID does not match
	the one in the restart tape label.

   S:	$info

   T:	$init

   M:	There is an inconsistency between what is on the restart tape
   and what is currently defined on the PV's disk label.

   A:	Start the save over from the beginning.

   Message:
   save(TAPE_SET): Volume on DISK_DEV is not a MULTICS_VOL_ID.

   S:	$info

   T:	$init

   M:	The volume to be saved is not a valid Multics volume and
   therefore cannot be saved.

   A:	$recover

   Message:
   save(TAPE_SET): Volume was expected to be PV_NAME.

   S:	$info

   T:	$init

   M:	The PV name read from the disk label does not match the PV name
   that was defined in the save control file(s).

   A:	Correct the control file to show the proper PV name mounted on
   the device.

   Message:
   save: si ERR_MESSAGE

   S:	$beep

   T:	$init

   M:	An error has been found with the internal "si" structure. $err

   A:	$inform

   Message:
   save: sri ERR_MESSAGE

   S:	$beep

   T:	$init

   M:	An error has been found with the internal "sri" structure. $err

   A:	$inform

   END MESSAGE DOCUMENTATION */

     end bce_save_util_;
