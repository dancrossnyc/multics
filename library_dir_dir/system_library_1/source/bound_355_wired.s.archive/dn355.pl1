/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/* format: style4,insnl,delnl,^ifthendo */
dn355:
     procedure;
	return;					/* should never be called here */

/* 	Date last modified and reason

   Written 10/08/74 by F. A. Canali for new tty dim
   Modified by Robert Coren and Mike Grady to fix bugs and add features
   Modified by Robert Coren 10/08/75 for multiple 355s
   Modified by J. Stern 04/22/77 to introduce WTCBs
   Modified by J. Stern 06/23/77 to behave correctly when no submailboxes available
   Modified by J. Stern 07/28/77 to use all 3 words of command data in submailbox
   Modified Jan.-Feb. 1978 to use variable-size output buffers and fix some bugs
   Modified 3/13/78 by Robert Coren to use clock builtin instead of clock_ and to get correct
   time at hangup_fnp_lines entry
   Modified August 1978 by Robert Coren for demultiplexing
   Modified November 8, 1978 by Robert Coren to introduce FNP-initiated mailboxes
   Modified July 2 1979 by B. Greenberg for negotiated echo.
   Modified March 1980 by Robert Coren to eliminate use of circular buffer.
   Modified April 1980 by Robert Coren to add metering information.
   Modified 1980 December by Art Beattie to ignore interrupts in invalid levels.  Also allowed command_data for
   send_wcd operations to be 216 bits long (6 * 36-bit word).  Corrected error message documentation.
   Modified December 1980 by Robert Coren to handle report_meters opcode
   Modified April 1981 by Chris Jones for io_manager conversion
   Modified September 1981 by Robert Coren to record character counts in LCTE meters and to force COLTS buffer size to maximum
   Modified February 1982 by C. Hornig for MR10 io_manager.
   Modified June 1982 by Robert Coren to process "line_masked" opcode.
   Modified 1984-07-28 BIM for dn355_boot_interrupt$system_fault.
   Modified 1984-07-30 BIM for paged mode IOM.
   Modified September 1984 by Robert Coren to use include file to define delay queue entries
*/

/****^  HISTORY COMMENTS:
  1) change(86-04-23,Coren), approve(86-04-23,MCR7300),
     audit(86-06-19,Beattie), install(86-07-08,MR12.0-1089):
     To handle 8-word echo-break tables.
  2) change(86-06-19,Kissel), approve(86-07-30,MCR7475), audit(86-09-04,Coren),
     install(86-10-09,MR12.0-1181):
     Changed to support the new tty event message format declared in
     net_event_message.incl.pl1 which replaces tty_event_message.incl.pl1.
  3) change(87-07-20,Farley), approve(88-02-24,MCR7791),
     audit(88-03-09,Beattie), install(88-03-15,MR12.2-1035):
     Changed no response loop to use a real time constant and retry the timeout
     or error one time along with reporting the problem.  If no response occurs
     after the retry then the FNP will be crashed.
                                                   END HISTORY COMMENTS */
%page;
interrupt:
     entry (x_dno, x_level, x_status);			/* entry from iom_manager */

dcl  x_dno fixed bin (35);				/* index from assignment time */
dcl  x_level fixed bin (3);				/* interrupt level */
dcl  x_status bit (36) aligned;			/* status after special or fault */

	if tc_data$system_shutdown ^= 0
	then return;				/* ignore 355's if shut down in progress */
	interrupt_entry = "1"b;

	call setup;
	level = x_level;				/* copy level to local stack */
	if datanet_info.trace
	then do;
	     if level ^= 3 | ^fnp_info.running
	     then syserr_severity = just_tell;
	     else syserr_severity = log;
	     call syserr (syserr_severity,
		"dn355: FNP ^a level ^d status ^w^[ running^]^[ bootloading^]^[ t_and_d_in_progress^]", fnp_name,
		level, x_status, fnp_info.running, fnp_info.bootloading, fnp_info.t_and_d_in_progress);
	end;
	if level ^= 3 & level ^= 7
	then do;					/* if not a good interrupt level */
	     call syserr (beeper, "dn355: FNP ^a invalid interrupt level ^o", fnp_name, level);
	     if fnp_info.bootloading
	     then if level = 1			/* system fault */
		then call dn355_boot_interrupt$system_fault (dno);
	     return;				/* lets hope its benign */
	end;

	if (^fnp_info.t_and_d_in_progress) & (^fnp_info.running) & (^fnp_info.bootloading)
	then return;				/* spurious interrupt */

	if ^stac (addr (lcte.lock), pds$processid)	/* somebody else has it */
	then do;

	     do while (^stac (addr (fnp_info.queue_lock), pds$processid));
	     end;

	     if level = 7
	     then fnp_info.level_7_pending = "1"b;
	     else fnp_info.level_3_pending = "1"b;

	     if stac (addr (lcte.lock), pds$processid)	/* in case it got unlocked meanwhile */
	     then call process_int_queue ("0"b);

	     else if ^stacq (fnp_info.queue_lock, "0"b, pds$processid)
	     then call syserr (crash_system, "dn355: inconsistent queue lock");
	end;

	else do;
	     call process_int (level);

	     do while (^stac (addr (fnp_info.queue_lock), pds$processid));
	     end;					/* check the queue to see if anything came in while we had the lock */

	     call process_int_queue ("0"b);
	end;

	return;

global_exit:					/* if abort out of an internal proc */
	if interrupt_entry
	then do;
	     if stacq (lcte.lock, "0"b, pds$processid)	/* make sure we undo anything we did */
	     then if lcte.notify_reqd
		then do;
		     lcte.notify_reqd = "0"b;
		     call pxss$notify (tty_ev);
		end;

	     lcte.locked_for_interrupt = "0"b;

	end;
	return;

/* entry to send a command to the FNP */
send_wcd:
     entry (a_fnpp, a_pcbp, opa, chrsa, data);

dcl  a_fnpp ptr,					/* parameters */
     a_pcbp ptr,
     opa fixed bin (8),
     data bit (*),
     chrsa fixed bin (8);				/* numeric */

dcl  tdata bit (8 * 36);				/* could be up to 8 words for set_echnego_break_table */
dcl  data_len fixed bin (8);

	pcbp = a_pcbp;
	go to send_join;

send_global_wcd:
     entry (a_fnpp, opa, chrsa, data);

	pcbp = null ();

send_join:
	interrupt_entry = "0"b;
	fnpp = a_fnpp;
	ttybp = addr (tty_buf$);			/* get ptr to tty buf */
	infop = addr (dn355_data$);			/* and dn 355 info */
	lctep = fnp_info.lcte_ptr;
	operation = opa;				/* and copy op to local stack */
	if ^fnp_info.running			/* can't talk to it if it's not listening */
	then return;

	no_response = "0"b;
	dno = fnp_info.fnp_number;
	mbxp = fnp_info.mbx_pt;			/* get pointer to mailbox */
	data_len = min (length (tdata), chrsa);		/* compute bit length of command data */
	if data_len > 0
	then tdata = substr (data, 1, data_len);
	else tdata = "0"b;

	i = index (used_string, "0"b);		/* find a free sub mbx */
	if i = 0					/* no submailbox */
	then do;
	     call make_q_entry (operation, data_len, tdata);
	     fnp_info.mbx_unavailable = fnp_info.mbx_unavailable + 1;
						/* form q entry element from data */
	end;

	else do;					/* we have a sub mbx, ship it off to the 355 */
	     subp = addr (datanet_mbx.dn355_sub_mbxes (i - 1));
						/* get sub mbx addr */
	     if pcbp ^= null ()
	     then do;
		string (sub_mbx.line_number) = string (pcb.line_number);
						/* move line number to sub mbx */
		devx = pcb.devx;
	     end;

	     else string (sub_mbx.line_number) = "0"b;	/* unless no pcb (global call) */

	     sub_mbx.op_code = operation;		/* set sub mbx op */
	     sub_mbx.cmd_data_len = divide (data_len, 6, 17, 0);
						/* set data length */
	     if operation = accept_direct_output	/* if output op */
	     then do;
		if ^pcb.flags.dialed		/* output without a dialup? */
		then call throw_away_output;		/* discard it */

		else call process_send_output (i - 1, "0"b);
	     end;

	     else if operation = set_echnego_break_table
	     then do;
		if pcb.flags.dialed
		then call send_echo_table (i - 1, tdata);
	     end;

	     else do;
		sub_mbx.io_cmd = wcd;		/* set write control data cmd */
		smbx_cmd_data_long = substr (tdata, 1, data_len);
						/* move command data to sub mbx */
		call send_mbx (i - 1);		/* ship the mbx off to the 355 */
		fnp_info.output_control_transactions = fnp_info.output_control_transactions + 1;
	     end;


	     if no_response
	     then call report_fnp_no_response;
	end;


	return;					/* return to caller */

process_interrupt_queue:
     entry (x_dno);

	interrupt_entry = "0"b;
	call setup;
	on cleanup call check_lock;
	masked = "1"b;				/* have to mask and wire while holding queue lock */
	call pmut$wire_and_mask (wire_arg, wire_ptr);

	do while (^stac (addr (fnp_info.queue_lock), pds$processid));
	end;
	queue_locked = "1"b;

	call process_int_queue ("1"b);
	return;

setup:
     proc;

	ttybp = addr (tty_buf$);			/* get addr of tty buffer segment */
	dno = x_dno;				/* copy 355 number to local stack */
	infop = addr (dn355_data$);			/* get address of 355 info segment */

	fnpp = addr (datanet_info.per_datanet (dno));
	fnp_name = fnp_info.fnp_tag;
	mbxp = fnp_info.mbx_pt;			/* get mailbox pointer */
	lctep = fnp_info.lcte_ptr;

	return;
     end setup;

process_int_queue:
     proc (caller_masked);

/* called with queue locked. Empties the queue, and must unlock it when done */

dcl  caller_masked bit (1);				/* indicates whether caller explicitly called pmut$wire_and_mask */

	do while (dequeue (level));
	     fnp_info.processed_from_q = fnp_info.processed_from_q + 1;
						/* meter */
	     if ^stacq (fnp_info.queue_lock, "0"b, pds$processid)
	     then call syserr (crash_system, "dn355: inconsistent queue lock");

	     queue_locked = "0"b;
	     if caller_masked
	     then call pmut$unwire_unmask (wire_arg, wire_ptr);
	     masked = "0"b;

	     call process_int (level);

	     if caller_masked
	     then do;				/* if we unmasked, we have to mask again */
		masked = "1"b;
		call pmut$wire_and_mask (wire_arg, wire_ptr);
	     end;

	     do while (^stac (addr (fnp_info.queue_lock), pds$processid));
	     end;
	     queue_locked = "1"b;
	end;

	lcte.locked_for_interrupt = "0"b;
	if ^stacq (lcte.lock, "0"b, pds$processid)
	then call syserr (crash_system, "dn355: LCTE lock ^^= processid");

	if ^stacq (fnp_info.queue_lock, "0"b, pds$processid)
	then call syserr (crash_system, "dn355: inconsistent queue lock");

	queue_locked = "0"b;
	if caller_masked
	then call pmut$unwire_unmask (wire_arg, wire_ptr);
	masked = "0"b;

	if lcte.notify_reqd
	then do;
	     lcte.notify_reqd = "0"b;
	     call pxss$notify (tty_ev);
	end;

	return;

dequeue:
	proc (a_level) returns (bit (1));

dcl  a_level fixed bin;

	     if fnp_info.level_3_pending
	     then do;
		fnp_info.level_3_pending = "0"b;
		a_level = 3;
		return ("1"b);
	     end;

	     else if fnp_info.level_7_pending
	     then do;
		fnp_info.level_7_pending = "0"b;
		a_level = 7;
		return ("1"b);
	     end;

	     else return ("0"b);

	end /* dequeue */;
     end /* process_int_queue */;

process_int:
     proc (a_level);

/* internal procedure to process an interrupt, either when it occurs or from the queue */

dcl  a_level fixed bin;

	level = a_level;

	lcte.locked_for_interrupt = "1"b;
	if level = 7
	then do;					/* emergency interrupt */

	     if fnp_info.t_and_d_in_progress
	     then do;
		if fnp_info.t_and_d_lev_7_occurred
		then return;
		fnp_info.t_and_d_lev_7_occurred = "1"b;
t_and_d_join:
		if fnp_info.t_and_d_notify_requested
		then do;
		     call pxss$notify (tty_ev);
		     fnp_info.t_and_d_notify_requested = "0"b;
		end;
		unspec (auto_net_event_message) = "0"b;
		auto_net_event_message.version = NET_EVENT_MESSAGE_VERSION_1;
		auto_net_event_message.network_type = MCS_NETWORK_TYPE;
		auto_net_event_message.handle = dno;
		auto_net_event_message.type = level;
		unspec (net_event_message_arg) = unspec (auto_net_event_message);
		call pxss$unique_ring_0_wakeup (fnp_info.boot_process_id, fnp_info.boot_ev_chan,
		     net_event_message_arg, 0);
		return;
	     end;

/* figure out reason for crash according to data in mailbox header */

	     fault_type = datanet_mbx.crash_data.fault_code;
	     if fault_type > hbound (dn355_messages$fault_names, 1) | fault_type < 0
	     then fault_name = "unknown fault";
	     else fault_name = dn355_messages$fault_names (fault_type);

	     call syserr (beeper, "dn355: emergency interrupt from FNP ^a: ^a", fnp_info.fnp_tag, fault_name);

	     if datanet_mbx.crash_data.ic ^= 0
	     then call syserr (just_tell, "FNP instruction counter = ^6o", datanet_mbx.crash_data.ic);

	     if fault_type = iom_channel_fault
	     then call syserr (just_tell, "channel ^o, fault status = ^6o", datanet_mbx.crash_data.fault_word,
		     datanet_mbx.crash_data.iom_fault_status);

	     else if fault_type = illegal_opcode
	     then if dn355_word.opcode = die_code	/* did 355 crash deliberately? */
		then do;
		     modulep = addr (dn355_messages$per_module);
		     module_num = fixed (dn355_word.modnum, 4);
		     if module_num > 0 & module_num <= hbound (dn355_modules.list_offset, 1)
			& dn355_word.crash_code > 0 & dn355_word.crash_code <= hbound (modulep -> message_offset, 1)
		     then do;
			reasonp = ptr (modulep, dn355_modules.list_offset (module_num));
			reasonp = ptr (reasonp, reasonp -> message_offset (dn355_word.crash_code));

			call syserr (just_tell, "^a: ^a", dn355_modules.name (module_num), dn355_reason.msg);
		     end;
		end;

	     call report_fnp_crash;			/* report it and hang up lines */
	     return;				/* done with this interrupt */
	end;

/* level must be 3, a normal everyday 355 interrupt */

	if fnp_info.bootloading			/* if this is bootload status */
	then do;
	     call dn355_boot_interrupt (dno);		/* let special routine figure it out */
	     return;
	end;

	if fnp_info.t_and_d_in_progress
	then do;
	     if fnp_info.t_and_d_lev_3_occurred
	     then return;
	     fnp_info.t_and_d_lev_3_occurred = "1"b;
	     go to t_and_d_join;
	end;

	if ^fnp_info.running			/* if this interrupt is premature, ignore it */
	then return;

	no_response = "0"b;				/* initially */

	if fnp_info.count > 0			/* had we had to wait for a free mbx? */
	then call process_q;

/* process any submailboxes which have been returned by the 355 */

	timw = ldac (addr (datanet_mbx.term_inpt_mpx_wd));/* get timw and clear */

	do i = 0 to 7;				/* loop over submailbox indicators */

	     if timwb (i) & ^no_response
	     then do;				/* if mailbox was returned by 355 then we have something to do */

		subp = addr (datanet_mbx.dn355_sub_mbxes (i));
						/* get pointer to sub mailbox */
		datanet_mbx.mbx_used_flags.used (i) = "0"b;
						/* clear submailbox used flag */
		datanet_mbx.num_in_use = datanet_mbx.num_in_use - 1;
		fnp_info.cumulative_mbx_in_use = fnp_info.cumulative_mbx_in_use + datanet_mbx.num_in_use;
		fnp_info.mbx_in_use_updated = fnp_info.mbx_in_use_updated + 1;

		if sub_mbx.io_cmd = wcd
		then do;
		     if sub_mbx.op_code = dump_mem | sub_mbx.op_code = patch_mem
		     then do;
			fnp_info.dump_patch_in_progress = "0"b;
			call pxss$notify (FNP_DUMP_PATCH_EVENT);
		     end;

		     else if sub_mbx.op_code = report_meters
		     then do;
			call get_line_number;
			if devx = -1
			then if fnp_info.get_meters_waiting
						/* fnp_multiplexer is waiting for global meters */
			     then do;
				fnp_info.get_meters_waiting = "0"b;
				call pxss$notify (FNP_METER_EVENT);
			     end;
			     else ;		/* copy_meters for whole FNP shouldn't arise */

			else if pcb.get_meters_waiting/* waiting for channel's meters */
			then do;
			     pcb.get_meters_waiting = "0"b;
			     call pxss$notify (FNP_METER_EVENT);
			end;

			else pcb.copied_meters_ready = "1"b;
						/* must be copy_meters, mark it so call side can copy them to unwired */
		     end;
		end;				/* just free submbx */

		else do;
		     call get_line_number;
		     if sub_mbx.io_cmd = wtx
		     then do;			/* check for write text */

			pcb.output_mbx_pending = "0"b;
			dcwlptr = addr (fnp_info.dcw_list_array_ptr -> dcw_list_array (i));
			chain_head_ptr = ptr (ttybp, bin (dcw_list (1).dcw_ptr, 18) - (tty_buf.absorig + dataoff));
			call tty_space_man$free_chain ((pcb.devx), OUTPUT, chain_head_ptr);
						/* and the output chain */

			if sub_mbx.command_data (1) ^= "0"b
						/* immediate send-output */
			then call process_send_output (i, "1"b);

		     end;



		     else do;
			call syserr (beeper, "dn355: unrecognized io command ^o from FNP ^a for line ^o",
			     sub_mbx.io_cmd, fnp_info.fnp_tag, bin (string (sub_mbx.line_number), 10));
						/* complain */
			call report_fnp_crash;	/* act as if FNP crashed */
			return;
		     end;
		end;
	     end;
	end;

	do i = 8 to 11;				/* now look at FNP-initiated mailboxes */
	     if timwb (i) & ^no_response
	     then do;
		subp = addr (datanet_mbx.fnp_sub_mbxes (i - 8));
		call get_line_number;

		if sub_mbx.io_cmd = rcd
		then do;				/* check for control stuff */

		     if (sub_mbx.op_code = accept_direct_input) | (sub_mbx.op_code = send_output)
			| (sub_mbx.op_code = input_in_mailbox)
		     then do;
			fnp_info.bleft_355 = fnp_sub_mbx.n_free_buffers - 4;
						/* get the buffer count from 355 */

			if fnp_info.bleft_355 < 0
			then			/* if above was too much correction */
			     fnp_info.bleft_355 = 0;	/* make it safe */


			if fnp_info.free_size > 16000000000
			then do;
			     fnp_info.free_size = 0;
			     fnp_info.free_count = 0;
			end;

			fnp_info.free_size = fnp_info.free_size + fnp_info.bleft_355;
			fnp_info.free_count = fnp_info.free_count + 1;
		     end;

		     if sub_mbx.op_code = accept_direct_input | sub_mbx.op_code = input_in_mailbox
		     then fnp_info.input_data_transactions = fnp_info.input_data_transactions + 1;
		     else fnp_info.input_control_transactions = fnp_info.input_control_transactions + 1;

		     if sub_mbx.op_code = accept_new_terminal
		     then do;			/* check for new terminal on line */


			pcb.line_type, dialup_info.line_type = bin (sub_mbx.command_data (1), 17);
			if sub_mbx.command_data (2)
			then pcb.baud_rate = baud_table (bin (sub_mbx.command_data (2), 17));

			do j = 1 to n_sync_line_types while (sync_line_type (j) ^= pcb.line_type);
			end;
			pcb.sync_line = (j <= n_sync_line_types);

			if ^pcb.sync_line		/* asynchronous */
			then bits_per_char = 10;
			else bits_per_char = 8;	/* assumption for synchronous lines */

			max_buf_chars =
			     divide (divide (pcb.baud_rate, bits_per_char, 17, 0), buf_per_second, 17, 0);
			pcb.max_buf_size = min (16 * divide (max_buf_chars + 67, 64, 17, 0), 128);
						/* round up to multiple of 16 words */
			if pcb.line_type = LINE_COLTS
			then pcb.max_buf_size = 128;	/* COLTS channel always gets big buffers */

			dialup_info.baud_rate = pcb.baud_rate;
			dialup_info.max_buf_size = pcb.max_buf_size;
			dialup_info.buffer_pad = 0;
			dialup_info.receive_mode_device = (dialup_info.line_type = LINE_ETX);
			dialup_info.pad = "0"b;
			pcb.dialed = "1"b;

			sub_mbx.op_code = terminal_accepted;
						/* inform 355 that term is ok */
			sub_mbx.cmd_data_len = 3;	/* we will put write buffer threshold in command data */
			if ^pcb.high_speed		/* less than 1200 baud */
			then addr (sub_mbx.command_data) -> unal_number = 2;
						/* set low write buffer threshold */
			else addr (sub_mbx.command_data) -> unal_number = 4;
						/* set high write buffer threshold */
			sub_mbx.io_cmd = wcd;
			call return_mbx (i);
			interrupt_info = unspec (dialup_info);
			call channel_manager$interrupt (devx, DIALUP, interrupt_info);

		     end;


		     else if sub_mbx.op_code = disconnected_line
		     then do;			/* see if line just hung up */
			pcb.dialed = "0"b;
			call throw_away_output;
			call channel_manager$interrupt (devx, HANGUP, ""b);
			call free_mbx (i);

		     end;

		     else if sub_mbx.op_code = wru_timeout
		     then do;			/* 355 couldn't get answerback */
			if pcb.dialed
			then call channel_manager$interrupt (devx, WRU_TIMEOUT, ""b);
			call free_mbx (i);
		     end;

		     else if sub_mbx.op_code = break_condition
		     then do;			/* check for break */

			if pcb.dialed
			then do;
			     if pcb.hndlquit
			     then call throw_away_output;
			     call channel_manager$interrupt (devx, QUIT, ""b);
			end;
			call free_mbx (i);
		     end;


		     else if sub_mbx.op_code = send_output
		     then do;			/* is this request for output? */

			call free_mbx (i);
			if pcb.dialed
			then call process_send_output (-1, "1"b);
						/* -1 indicates no current mailbox */
		     end;


		     else if sub_mbx.op_code = accept_direct_input
		     then do;			/* check for input from terminal */

			if pcb.dialed
			then call process_accept_input;

			else do;
			     sub_mbx.io_cmd = wcd;	/* we'll tell him to hang up */
			     sub_mbx.op_code = disconnect_this_line;
			     call return_mbx (i);
			end;
		     end;

		     else if sub_mbx.op_code = error_message
		     then do;			/* error message from 355 */
			offset = bin (error_msg.data (1), 18);
						/* get which error message this is */
			if offset > 0 & offset <= hbound (dn355_messages$error_messages, 1)
			then do;
			     offset = dn355_messages$error_messages (offset);
						/* offset of message */
			     reasonp = addr (dn355_messages$error_messages);
						/* get ptr */
			     reasonp = ptr (reasonp, offset);
						/* now we have message */
			     reason_msg = dn355_reason.msg;
			end;

			else reason_msg = "unrecognized error ^o ^o ^o";

			do ix = 1 to 3;
			     full_words (ix) = bin (error_msg.data (ix + 1), 18);
			end;
			call syserr (just_tell, "dn355: Message from FNP ^a: " || reason_msg, fnp_info.fnp_tag,
			     full_words);
			call free_mbx (i);
		     end;

		     else if sub_mbx.op_code = input_in_mailbox
		     then do;
			if pcb.dialed
			then call process_input_in_mbx;
			else do;
			     sub_mbx.io_cmd = wcd;	/* tell him to give up */
			     sub_mbx.op_code = disconnect_this_line;
			     call return_mbx (i);
			end;
		     end;

		     else if sub_mbx.op_code >= first_acu_op_code & sub_mbx.op_code <= last_acu_op_code
		     then do;			/* acu failure */
			interrupt_info = bit (bin (sub_mbx.op_code, 9));
			call channel_manager$interrupt (devx, DIAL_STATUS, interrupt_info);
			call free_mbx (i);
		     end;

		     else if sub_mbx.op_code = line_status
		     then do;			/* some status from fnp */
			interrupt_info = substr (unspec (sub_mbx.command_data), 1, 72);
			call channel_manager$interrupt (devx, LINE_STATUS, interrupt_info);
			call free_mbx (i);
		     end;

		     else if sub_mbx.op_code = ack_echnego_init
		     then do;
			call free_mbx (i);
			call channel_manager$interrupt (devx, ACKNOWLEDGE_ECHNEGO_INIT, "0"b);
		     end;

		     else if sub_mbx.op_code = ack_echnego_stop
		     then do;
			call free_mbx (i);
			call channel_manager$interrupt (devx, ACKNOWLEDGE_ECHNEGO_STOP, "0"b);
		     end;

		     else if sub_mbx.op_code = line_masked
		     then do;			/* see if channel was masked */
			pcb.dialed, pcb.listen = "0"b;
			call throw_away_output;
			call syserr (just_tell,
			     "dn355: FNP masked channel ^a.h^d^[0^;^]^d for excessive interrupts", fnp_info.fnp_tag,
			     binary (sub_mbx.line_number.la_no, 3), (binary (sub_mbx.line_number.slot_no, 6) < 10),
			     binary (sub_mbx.line_number.slot_no, 6));
			call channel_manager$interrupt (devx, MASKED, ""b);
			call free_mbx (i);

		     end;

		     else do;
			call syserr (beeper, "dn355: unrecognized op code ^o with rcd from FNP ^a for devx ^o",
			     sub_mbx.op_code, fnp_info.fnp_tag, devx);
						/* someone goofed */
			call report_fnp_crash;
			return;
		     end;
		end;



		else if sub_mbx.io_cmd = rtx
		then call process_rtx;		/* check for read text */

		else do;
		     call syserr (beeper, "dn355: unrecognized io command ^o from FNP ^a for line ^o", sub_mbx.io_cmd,
			fnp_info.fnp_tag, bin (string (sub_mbx.line_number), 10));
						/* complain */
		     call report_fnp_crash;		/* give up on this FNP */
		     return;
		end;
	     end;
	end;


	if ^no_response				/* assuming we believe FNP is still there */
	then if fnp_info.count > 0
	     then call process_q;


	if no_response				/* if someone discovered that the FNP was gone */
	then call report_fnp_no_response;

	return;
     end /* process_int */;

process_q:
     proc;

/* process the queue of mailbox operations that could not be performed
   because no mailboxes wre available
*/

	q_first = fnp_info.cur_ptr;
	q_count = fnp_info.count;
	i = 1;					/* preset while variable */

	do while (q_count > 0 & i > 0);
	     i = index (used_string, "0"b);
	     if i > 0				/* now we can have one */
	     then do;
		subp = addr (datanet_mbx.dn355_sub_mbxes (i - 1));
		qptr = ptr (ttybp, q_first);
		if q_entry.pcb_offset ^= "0"b		/* for a specific channel */
		then do;
		     pcbp = ptr (ttybp, q_entry.pcb_offset);
		     string (sub_mbx.line_number) = string (pcb.line_number);
		     devx = pcb.devx;
		end;
		else string (sub_mbx.line_number) = ""b;

		if q_entry.opcode = accept_direct_output
		then if pcb.dialed
		     then call process_send_output (i - 1, "0"b);
		     else ;

		else if q_entry.opcode = set_echnego_break_table
		then if pcb.dialed
		     then call send_echo_table (i - 1, q_entry.cmd_data);
		     else ;

		else do;
		     sub_mbx.io_cmd = wcd;
		     sub_mbx.op_code = q_entry.opcode;
		     sub_mbx.cmd_data_len = divide (q_entry.cmd_count, 6, 8, 0);
		     smbx_cmd_data_long = substr (q_entry.cmd_data, 1, q_entry.cmd_count);
		     call send_mbx (i - 1);
		     fnp_info.output_control_transactions = fnp_info.output_control_transactions + 1;
		end;

		if no_response			/* give up in this case */
		then go to update_q_ptrs;

		q_first = q_entry.next;		/* on to next queue entry */
		q_count = q_count - 1;
		call tty_space_man$free_space (size (q_entry), qptr);
	     end;

	     else fnp_info.mbx_unavailable = fnp_info.mbx_unavailable + 1;
	end;

update_q_ptrs:
	fnp_info.cur_ptr = q_first;
	fnp_info.count = q_count;
	if q_count = 0
	then fnp_info.last_ptr = 0;

	return;
     end /* process_q */;

/* internal subroutine to process send output */

process_send_output:
     proc (a_mbx_num, interrupt_entry);

dcl  a_mbx_num fixed bin;				/* -1 indicates mailbox not already allocated */
dcl  mbx_num fixed bin;
dcl  interrupt_entry bit (1) aligned;			/* indicates whether or not called on interrupt side */

	mbx_num = a_mbx_num;
	if pcb.end_frame | pcb.output_mbx_pending	/* if we're waiting for form-feed  or we got delayed */
	then do;
	     pcb.flags.send_output = "1"b;		/* we'll want output eventually */
	     return;				/* don't do anything else */
	end;

	if pcb.write_first = 0
	then do;
	     pcb.flags.send_output = "1"b;		/* if no output then just set flag */
	     call channel_manager$interrupt (devx, SEND_OUTPUT, ""b);
	end;

	else do;
	     if mbx_num = -1			/* caller didn't supply one */
	     then do;
		mbx_num = index (used_string, "0"b) - 1;/* find a free one */

		if mbx_num = -1			/* still? we didn't get one */
		then do;
		     call make_q_entry (accept_direct_output, 0, ""b);
		     fnp_info.mbx_unavailable = fnp_info.mbx_unavailable + 1;
		     return;			/* we'll catch it later */
		end;
		else do;
		     subp = addr (datanet_mbx.dn355_sub_mbxes (mbx_num));
		     string (sub_mbx.line_number) = string (pcb.line_number);
		end;
	     end;


	     pcb.flags.send_output = "0"b;		/* make sure flag clear */
	     dcwlptr = addr (fnp_info.dcw_list_array_ptr -> dcw_list_array (mbx_num));

	     sub_mbx.data_addr = bit (bin (bin (rel (dcwlptr), 18) + tty_buf.absorig, 18), 18);
	     output_limit =
		max (
		min (divide ((fnp_info.bleft_355 - tc_data$fnp_buffer_threshold) * 60, output_bpart, 17, 0),
		max_chain_len * 4 * (pcb.max_buf_size - 1)), 1);

	     output_chars = 0;			/* none so far */
	     continue = "1"b;
	     do j = 1 to max_chain_len while (pcb.write_first ^= 0 & output_chars < output_limit & continue);
						/* set up dcw list */
		dcw_list (j).dcw_ptr = bit (bin (pcb.write_first + dataoff + tty_buf.absorig, 18), 18);
						/* set dcw abs addr */
		blockp = ptr (ttybp, pcb.write_first);	/* get ptr to buffer */
		if buffer.tally = 0			/* we don't want this in a dcw */
		then call syserr (crash_system, "dn355: output buffer at ^o has zero tally", pcb.write_first);

		dcw_list (j).dcw_tally = bit (buffer.tally, 9);
						/* set dcw tally from buffer */
		dcw_list (j).pad = "0"b;		/* 355 depends on this */
		pcb.write_first = buffer.next;	/* now bump to next buffer */
		pcb.write_cnt = pcb.write_cnt - buffer.tally;
						/* decrement count of chars in chain */
		output_chars = output_chars + buffer.tally;
						/* keep count of characters sent */
		if buffer.flags.end_of_page		/* if this buffer fills a page/screen */
		then do;
		     pcb.flags.end_frame = "1"b;	/* remember it */
		     continue = "0"b;		/* terminate the loop */
		end;
	     end;

	     chain_len = max (j - 1, 1);		/* this is now the length of the chain */

	     sub_mbx.word_cnt = chain_len;		/* we have maximum length dcw list */
	     sub_mbx.op_code = accept_direct_output;	/* and do not have last buffer */
	     sub_mbx.command_data (1) = "0"b;		/* make sure it starts clean */
	     sub_mbx.io_cmd = wtx;			/* set write text io command */
	     pcb.output_mbx_pending = "1"b;
	     buffer.next = 0;			/* indicate end of active write block */
	     call send_mbx (mbx_num);			/* ship sub mbx off to 355 */
	     fnp_info.output_data_transactions = fnp_info.output_data_transactions + 1;
	     lcte.meters.out_bytes = lcte.meters.out_bytes + output_chars;
						/* meter */

	     if /* tree */ pcb.write_first = 0
	     then do;				/* see if we ran out of buffers */
		pcb.write_last = 0;			/* zero ptr to last */
		if interrupt_entry
		then call channel_manager$interrupt (devx, SEND_OUTPUT, ""b);
						/* wakeup the user */
	     end;
	     else if chain_len < max_chain_len & ^pcb.flags.end_frame
						/* must have stopped because there wasn't enough space */
		then fnp_info.fnp_space_restricted_output = fnp_info.fnp_space_restricted_output + 1;
	end;

	return;					/* and return to caller */
     end;

/* internal subroutine to process set_echnego_break_table operation */

/* Because the echo table is 8 words long, it won't fit in a sub_mbx, so we
   have to send the FNP the address so it can read the table. To avoid extra
   storage overhead, and the necessity of freeing storage when the operation
   completes, the table is put in the dcw_list area corresponding to the mailbox. */

send_echo_table:
     procedure (mbx_num, table_bits);

dcl  mbx_num fixed bin;
dcl  table_bits bit (8 * 36);

dcl  table_ptr pointer;
dcl  bits_to_send bit (8 * 36) based;

	if ^pcb.dialed
	then return;
	table_ptr = addr (fnp_info.dcw_list_array_ptr -> dcw_list_array (mbx_num));
	table_ptr -> bits_to_send = table_bits;
	sub_mbx.op_code = set_echnego_break_table;
	sub_mbx.io_cmd = wcd;
	sub_mbx.data_addr = bit (bin (bin (rel (table_ptr), 18) + tty_buf.absorig, 18), 18);
	sub_mbx.word_cnt = 8;

	call send_mbx (mbx_num);
	fnp_info.output_control_transactions = fnp_info.output_control_transactions + 1;
	return;
     end send_echo_table;

/* internal procedure to respond to accept_input mailbox */

process_accept_input:
     proc;

dcl  tally fixed bin;
dcl  buf_size fixed bin;
dcl  prev_blockp ptr;

	input_count = input_sub_mbx.n_chars;		/* get char count */
	j = divide (input_count + 3, 4, 17, 0);		/* compute number of words of circular buffer needed */

	if enough_input_space (j) & pcb.read_first = 0
	then do;
	     do k = 1 to input_sub_mbx.n_buffers;
		tally = input_sub_mbx.dcw (k).tally;
		buf_size = 16 * divide (tally + 67, 64, 17, 0);
						/* get next higher multiple of 16 words */
		call tty_space_man$get_buffer (devx, buf_size, INPUT, blockp);
		if blockp = null ()			/* couldn't get the space */
		then do;
		     if pcb.read_first ^= 0		/* if we started building a chain */
		     then call tty_space_man$free_chain (devx, INPUT, ptr (ttybp, pcb.read_first));
		     pcb.read_first = 0;
		     go to reject;
		end;

		if pcb.read_first = 0
		then pcb.read_first = bin (rel (blockp));
		else prev_blockp -> buffer.next = bin (rel (blockp));

		buffer.tally = tally;
		input_sub_mbx.dcw (k).abs_addr =
		     bit (bin (tty_buf.absorig + bin (rel (addr (buffer.chars))), 24), 24);
						/* point DCW at data portion of buffer */
		prev_blockp = blockp;
	     end;

	     pcb.read_last = bin (rel (blockp));

	     sub_mbx.op_code = input_accepted;		/* inform 355 that we will take input now */
	     sub_mbx.io_cmd = rtx;
	     call return_mbx (i);
	end;

	else do;
reject:
	     sub_mbx.io_cmd = wcd;
	     sub_mbx.op_code = reject_request_temp;	/* inform 355 that we can not accept input
						   at the present time */
	     call return_mbx (i);
	     fnp_info.input_reject_count = fnp_info.input_reject_count + 1;
	     call channel_manager$interrupt (devx, INPUT_REJECTED, ""b);
	end;

     end /* process_accept_input */;

/* internal proc to process rtx */
process_rtx:
     proc;

dcl  real_word_cnt fixed bin;
dcl  n_words fixed bin;
dcl  buf_size fixed bin;
dcl  source_ptr ptr;
dcl  target_ptr ptr;

	fnp_info.input_data_transactions = fnp_info.input_data_transactions + 1;
	real_word_cnt = input_sub_mbx.n_chars;
	lcte.meters.in_bytes = lcte.meters.in_bytes + real_word_cnt;
	rtx_info.break_char = substr (input_sub_mbx.command_data, 18, 1);
	call check_ff ("0"b);			/* see if input ends with a form feed */
	input_count = real_word_cnt;
	if input_count ^= 0				/* must have been a single FF that we discarded */
	then do;
	     rtx_info.output_in_fnp = substr (input_sub_mbx.command_data, 17, 1);
	     rtx_info.output_in_ring_0 = (pcb.write_first ^= 0);
	     rtx_info.input_count = input_count;
	     rtx_info.chain_head = bit (pcb.read_first, 18);
	     rtx_info.chain_tail = bit (pcb.read_last, 18);
	     interrupt_info = unspec (rtx_info);
	     call channel_manager$interrupt (devx, ACCEPT_INPUT, interrupt_info);
	end;

	else call tty_space_man$free_chain (devx, INPUT, ptr (ttybp, pcb.read_first));

	pcb.read_first, pcb.read_last = 0;

	call free_mbx (i);

	return;					/* and return to caller */

process_input_in_mbx:
     entry;

/* we will copy input directly from mailbox into one buffer (if possible) */

	numchars = fnp_sub_mbx.n_chars;
	rtx_info.break_char = substr (fnp_sub_mbx.command_data, 18, 1);
	call check_ff ("1"b);
	if numchars > 0
	then do;
	     n_words = divide (numchars + 3, 4, 17, 0);
	     if enough_input_space (n_words)
	     then do;
		buf_size = 16 * (divide (n_words + 17, 16, 17, 0));
						/* get next multiple of 16 words */
		call tty_space_man$get_buffer (devx, buf_size, INPUT, blockp);
		if blockp = null
		then go to not_enough_space;

		source_ptr = addr (fnp_sub_mbx.input_data);
		target_ptr = addr (buffer.chars);
		target_ptr -> chars = source_ptr -> chars;
		buffer.tally = numchars;
		rtx_info.output_in_fnp = substr (fnp_sub_mbx.command_data, 17, 1);
		rtx_info.output_in_ring_0 = (pcb.write_first ^= 0);
		rtx_info.input_count = numchars;
		rtx_info.chain_head, rtx_info.chain_tail = rel (blockp);
						/* only one buffer */
		lcte.meters.in_bytes = lcte.meters.in_bytes + numchars;
		interrupt_info = unspec (rtx_info);
		call channel_manager$interrupt (devx, ACCEPT_INPUT, interrupt_info);
		call free_mbx (i);
	     end;

	     else do;				/* space test failed */
not_enough_space:
		sub_mbx.io_cmd = wcd;		/* tell him we can't take it */
		sub_mbx.op_code = reject_request_temp;
		call return_mbx (i);
		call channel_manager$interrupt (devx, INPUT_REJECTED, ""b);
	     end;
	end;

	else call free_mbx (i);			/* nothing there except form_feed */
	return;

check_ff:
	proc (in_mbx);				/* internal procedure to check input for form-feed */

dcl  in_mbx bit (1);

	     rtx_info.formfeed_present = "0"b;		/* for now */
	     if pcb.sync_line			/* form feeds not interesting in this case */
	     then return;

	     if in_mbx
	     then do;
		bufp = addr (fnp_sub_mbx.input_data);
		chars_left = numchars;
	     end;

	     else do;
		blockp = ptr (ttybp, pcb.read_last);
		chars_left = buffer.tally;
		bufp = addr (buffer.chars);
	     end;

	     if substr (bufp -> input_chars, chars_left, 1) = form_feed
						/* yup, input ends with FF */
	     then rtx_info.formfeed_present = "1"b;
	     if pcb.flags.end_frame & rtx_info.break_char /* time to restart suspended output */
	     then do;
		if (chars_left <= 2)
		then if verify (substr (bufp -> input_chars, 1, chars_left), ff_cr_lf) = 0
		     then do;			/* this input is just to restart output, discard it */
			if in_mbx
			then numchars = 0;
			else real_word_cnt = 0;
		     end;
		pcb.flags.end_frame = "0"b;
		if pcb.flags.send_output		/* more output to ship */
		then if pcb.write_first ^= 0		/* it's waiting in tty_buf */
		     then call make_q_entry (accept_direct_output, 0, ""b);
						/* we'll get to it shortly */
		     else call channel_manager$interrupt (devx, SEND_OUTPUT, ""b);
	     end;

	end /* check_ff */;

     end /* process_rtx */;

/* internal proc to check if this channel can have input space */

enough_input_space:
     proc (count) returns (bit (1));

dcl  count fixed bin;

	lctp = tty_buf.lct_ptr;
	chan_lctep = addr (lct.lcte_array (devx));
	return (chan_lctep -> lcte.input_words + count <= divide (tty_buf.bleft, input_bpart, 17, 0));
     end /* enough_input_space */;


/* internal proc to put an element onto delay queue */

make_q_entry:
     proc (opc, cnt, databits);

dcl  (opc, cnt) fixed bin (8),			/* parameters */
     databits bit (8 * 36);

	call tty_space_man$get_space (size (q_entry), new_qp);
	if new_qp = null
	then do;
	     call syserr (crash_system, "dn355: unable to allocate block for delay queue");
	     return;
	end;

	new_qrel = bin (rel (new_qp));
	if fnp_info.cur_ptr = 0			/* nothing in the queue yet */
	then fnp_info.cur_ptr = new_qrel;
	else do;
	     qptr = ptr (ttybp, fnp_info.last_ptr);
	     q_entry.next = new_qrel;			/* make the preceding entry point to the new one */
	end;

	fnp_info.last_ptr = new_qrel;
	qptr = new_qp;
	fnp_info.count = fnp_info.count + 1;
	fnp_info.q_entries_made = fnp_info.q_entries_made + 1;

	q_entry.opcode = opc;			/* set q element op code */
	q_entry.cmd_count = cnt;			/* and command count */
	if pcbp ^= null ()
	then q_entry.pcb_offset = rel (pcbp);
	else q_entry.pcb_offset = "0"b;
	q_entry.next = 0;
	q_entry.cmd_data = databits;			/* move data to q element */
	return;					/* return to caller */
     end;

/* internal procedure to derive devx & PCB pointer from mailbox line number */

get_line_number:
     proc;

dcl  x fixed bin;

	if string (sub_mbx.line_number) = "0"b
	then do;					/* some type of global request */
	     do x = 1 to hbound (global_opcodes, 1) while (sub_mbx.op_code ^= global_opcodes (x));
	     end;					/* make sure it really is */
	     if x > hbound (global_opcodes, 1)
	     then do;				/* else can the FNP */
		call syserr (beeper, "dn355: line number of 0 with non-global opcode in submbx ^o, FNP ^a", i,
		     fnp_info.fnp_tag);
		call report_fnp_crash;
		go to global_exit;
	     end;

	     pcbp = null;
	     devx = -1;
	end;

	else do;
	     n_pcbs = fnp_info.no_of_channels;
	     if string (sub_mbx.line_number) = TANDD_LINE_NUMBER
						/* don't decode this, go straight to it */
	     then pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (fnp_info.tandd_pcbx));
	     else do;
		lano = sub_mbx.line_number.la_no;	/* get line adapter number for devx lookup */
		if sub_mbx.is_hsla
		then j = fnp_info.hsla_idx (fixed (lano));
		else j = fnp_info.lsla_idx (fixed (lano));
						/* get starting position */
		do j = j to n_pcbs;			/* loop thru devx table */
		     pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (j));
		     if string (pcb.line_number) = string (sub_mbx.line_number)
		     then go to match;		/* check for right slot */
		end;
		call syserr (beeper, "dn355: no slot number match for sub mbx ^o, FNP ^a", i, fnp_info.fnp_tag);
						/* bitch */
		call report_fnp_crash;
		go to global_exit;
	     end;

match:
	     devx = pcb.devx;			/* copy devx to automatic */

	end;
	return;

     end /* get_line_number */;


/* internal procedure to ship sub mbx off to 355 */
send_mbx:
return_mbx:
     proc (a_mbx_no);

dcl  a_mbx_no fixed bin;
dcl  mbx_no fixed bin;
dcl  pcw_error bit (1);
dcl  timeout_time fixed bin (71);
dcl  1 ima aligned like io_manager_arg;

	mbx_no = a_mbx_no;
	go to test_pcw;

free_mbx:
     entry (a_mbx_no);				/* this for those which haven't been rewritten */

	mbx_no = a_mbx_no + 4;			/* use different interrupt level for freeing */

test_pcw:
	if ^fnp_info.io_manager_assigned
	then do;
	     no_response = "1"b;			/* lie, but effectively */
	     return;
	end;

	no_response = "0"b;
	if datanet_mbx.dia_pcw.command ^= "0"b
	then do;					/* first a quick check to save time */
wait_for_response:
	     timeout_time = clock () + TWO_SECONDS;
	     do while ((clock () < timeout_time) & (datanet_mbx.dia_pcw.command ^= "0"b));
						/* loop until dia picks up last command */
	     end;
	     if datanet_mbx.dia_pcw.error | datanet_mbx.dia_pcw.command ^= "0"b
	     then do;
		if ^no_response
		then do;
		     pcw_error = datanet_mbx.dia_pcw.error;
		     no_response = "1"b;
		     datanet_mbx.dia_pcw.error = "0"b;
		     string (datanet_mbx.dia_pcw) = dn355_util$compute_parity (string (datanet_mbx.dia_pcw));
						/* recompute parity */
		     ima.chx = fnp_info.io_manager_chx;
		     ima.ptp = fnp_info.ptp;
		     call io_manager$connect_direct (ima);
						/* re-kick FNP */
		     call syserr (just_tell,
			"dn355: ^[Error^;Timeout^] sending mailbox interrupt to FNP ^a, will retry.", pcw_error,
			fnp_info.fnp_tag);
		     goto wait_for_response;
		end;
	     end;
	     else goto send_new_connect;
	end;
	else do;
send_new_connect:
	     no_response = "0"b;

	     if mbx_no < 8				/* one of ours */
	     then do;
		datanet_mbx.mbx_used_flags.used (mbx_no) = "1"b;
		datanet_mbx.num_in_use = datanet_mbx.num_in_use + 1;
		fnp_info.max_mbx_in_use = max (fnp_info.max_mbx_in_use, datanet_mbx.num_in_use);
		fnp_info.cumulative_mbx_in_use = fnp_info.cumulative_mbx_in_use + datanet_mbx.num_in_use;
		fnp_info.mbx_in_use_updated = fnp_info.mbx_in_use_updated + 1;
	     end;					/* set used flag */
	     string (datanet_mbx.dia_pcw) = initial_pcw;	/* initialize pcw */
	     datanet_mbx.dia_pcw.mbx_no = bit (fixed (mbx_no, 6), 6);
						/* set sub mbx number */

	     string (datanet_mbx.dia_pcw) = dn355_util$compute_parity (string (datanet_mbx.dia_pcw));
						/* set the parity bit; bit 22 */

	     ima.chx = fnp_info.io_manager_chx;
	     ima.ptp = fnp_info.ptp;
	     call io_manager$connect_direct (ima);	/* kick 355 */

	     return;				/* return to caller */
	end;
     end send_mbx;

/* entry and internal proc to hangup all lines on an FNP */

hangup_fnp_lines:
     entry (a_fnp_no);

dcl  a_fnp_no fixed bin;

	ttybp = addr (tty_buf$);
	infop = addr (dn355_data$);
	call hangup_fnp (a_fnp_no);
	return;


hangup_fnp:
     proc (fnp_no);

dcl  fnp_no fixed bin;

	fnpp = addr (datanet_info.per_datanet (fnp_no));
	n_pcbs = fnp_info.no_of_channels;
	do j = 1 to n_pcbs;
	     pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (j));
	     if pcb.dialed
	     then do;
		call throw_away_output;
		call channel_manager$interrupt ((pcb.devx), CRASH, ""b);
	     end;
	end;

	if fnp_info.count > 0			/* get rid of any outstanding delay queue entries */
	then do;
	     q_count = fnp_info.count;
	     q_first = fnp_info.cur_ptr;
	     do q_count = q_count to 0 by -1 while (q_first ^= 0);
		qptr = ptr (ttybp, q_first);		/* get real pointer to queue entry */
		q_first = qptr -> q_entry.next;	/* save pointer to next one */
		call tty_space_man$free_space (size (q_entry), qptr);
	     end;

	     fnp_info.count, fnp_info.cur_ptr, fnp_info.last_ptr = 0;
	end;

     end;



throw_away_output:
     proc;

/* throws away pending write chain on quit and hangup */

	if pcb.write_first ^= 0
	then do;
	     call tty_space_man$free_chain ((pcb.devx), OUTPUT, ptr (ttybp, pcb.write_first));
	     pcb.write_first, pcb.write_last, pcb.write_cnt = 0;

	end;

	pcb.end_frame = "0"b;

	return;
     end /* throw_away_output */;

/* internal procedure to report that DIA never set PCW to 0 */

report_fnp_no_response:
     proc;

	call syserr (beeper, "dn355: FNP ^a did not respond to mailbox interrupt", fnp_info.fnp_tag);
	call report_fnp_crash;			/* treat it like a crash */
	return;

     end /* report_fnp_no_response */;


/* internal procedure to tell initializer and clean up when FNP crashes */

report_fnp_crash:
     proc;

	fnp_info.running = "0"b;			/* it isn't any more */
	if fnp_info.dump_patch_in_progress		/* somebody's waiting for this */
	then call pxss$notify (FNP_DUMP_PATCH_EVENT);	/* don't let them wait forever */

	if ^fnp_info.bootloading			/* if we weren't still loading it */
	then					/* now report hangups for all lines that were dialed to it */
	     call hangup_fnp (dno);
	else fnp_info.bootloading = "0"b;

	auto_fnp_msg.state = FNP_DOWN;		/* tell the responsible process */
	auto_fnp_msg.fnp_no = dno;
	auto_fnp_msg.flags = "0"b;
	unspec (fnp_event_message) = unspec (auto_fnp_msg);
	call pxss$ring_0_wakeup (fnp_info.boot_process_id, fnp_info.boot_ev_chan, fnp_event_message, 0);

	return;

     end report_fnp_crash;
check_lock:
     proc;

/* the cleanup procedure -- makes sure we don't crawl out with lock set */

	if queue_locked
	then call syserr (crash_system, "dn355: attempted crawlout with FNP queue locked");

	else if masked
	then call pmut$unwire_unmask (wire_arg, wire_ptr);/* it's probably too late, but just in case */

	return;
     end check_lock;
%page;
/* Main program declarations */

dcl  (dcwlptr, bufp, qptr) ptr,			/* random pointers used */
     timw fixed bin (24),				/* local slot for mailbox timw */
     (level, dno, i, ix, q_first, q_count, chars_left, numchars, k, j, chain_len) fixed bin,
						/* random halfwords used */
     devx fixed bin,				/* index of current channel */
     operation fixed bin (8),				/* local slot for delay queue operation */
     lano bit (3) unal;				/* local slot for line number */
dcl  fnp_name char (1) aligned;			/* for syserr calls */

dcl  no_response bit (1) aligned;			/* set by send_mbx to indicate that DIA didn't respond */

dcl  interrupt_entry bit (1);				/* whether entered through dn355$interrupt */

dcl  input_count fixed bin;				/* count sent with accept_dir_input */

dcl  chan_lctep ptr;				/* pointer to subchannel's LCTE */
dcl  chain_head_ptr ptr;				/* pointer to output chain to be freed */
dcl  output_limit fixed bin;				/* maximum number of output chars to be sent at once */
dcl  output_chars fixed bin;				/* number of output chars sent so far */

dcl  bits_per_char fixed bin;
dcl  max_buf_chars fixed bin;				/* number of characters to go in largest buffer at this speed */

dcl  wire_arg fixed bin (71);
dcl  wire_ptr ptr;
dcl  masked bit (1);
dcl  queue_locked bit (1);
dcl  continue bit (1);				/* for premature termination of loops */

dcl  offset fixed bin;				/* offset of error message in dn355_messages */
dcl  syserr_severity fixed bin (35);

/* Codes used for syserr are declared here because syserr_constants.incl.pl1 cannot
   be used, owing to a naming conflict with mcs_interrupt_info.incl.pl1.
*/

dcl  (
     dataoff init (1),				/* offset in buffer of data */
     max_chain_len init (16),				/* maximum dcw chain length */
     just_tell init (0),				/* syserr message, no alarm */
     beeper init (3),				/* syserr ring beeper */
     log init (4),
     crash_system init (1)
     ) fixed bin int static options (constant);		/* argument to syserr */

dcl  FNP_DOWN fixed bin int static options (constant) init (2);

dcl  initial_pcw bit (36) int static init ("000000000000000000000000000000111001"b);
						/* initial dia pcw */
dcl  TANDD_LINE_NUMBER bit (10) int static options (constant) init ((10)"1"b);
						/* i.e., 1777 octal */
dcl  TWO_SECONDS fixed bin (71) int static options (constant) init (2000000);
						/* used to wait for DIA to clear PCW */

dcl  timwb (0:11) bit (1) based (addr (timw)),		/* timw as a bit array */
     used_string bit (8) based (addr (datanet_mbx.mbx_used_flags.used (0)));
						/* mailbox used flags as a bit string */

dcl  (addr, binary, substr, stac, stacq, string, ptr, rel, index, fixed, divide, bin, max, min, null, length, bit, unspec,
     hbound, size, verify, clock) builtin;		/* builtin functions used */

dcl  unal_number fixed bin (17) unal based,		/* handy way of referencing an unaligned number */
     chars char (numchars) based;			/* handy way of moving character strings */

dcl  input_chars char (chars_left) based;		/* for scanning entire input */

dcl  smbx_cmd_data_long bit (216) unaligned based (addr (sub_mbx.command_data));

dcl  tc_data$system_shutdown ext fixed bin;		/* external variables used */
dcl  tc_data$fnp_buffer_threshold ext static fixed bin;
dcl  pds$processid bit (36) aligned ext static;

dcl  ff_cr_lf char (3) int static options (constant) init ("
");

dcl  form_feed init ("") char (1) int static options (constant);

dcl  syserr entry options (variable),			/* external entries called */
     ldac entry (ptr) returns (fixed bin (24)),
     dn355_util$compute_parity entry (bit (36)) returns (bit (36)),
     (
     dn355_boot_interrupt,
     dn355_boot_interrupt$system_fault
     ) entry (fixed bin),
     pxss$ring_0_wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35)),
     pxss$unique_ring_0_wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35)),
     pxss$notify entry (fixed bin);

dcl  pmut$wire_and_mask entry (fixed bin (71), ptr);
dcl  pmut$unwire_unmask entry (fixed bin (71), ptr);
dcl  1 auto_net_event_message aligned like net_event_message;
dcl  1 auto_fnp_msg aligned like fnp_msg;
dcl  fnp_event_message fixed bin (71);

dcl  1 dcw_list (max_chain_len) aligned based (dcwlptr),	/* dcw list for output */
       2 dcw_ptr bit (18) unal,			/* pointer to buffer */
       2 pad bit (9) unal,				/* unused */
       2 dcw_tally bit (9) unal;			/* tally */

dcl  1 dcw_list_array (0:7) aligned based,
       2 dcw_list_template (max_chain_len) like dcw_list;

dcl  1 q_entry aligned like fnp_queue_entry based (qptr);

dcl  new_qp ptr;					/* temporary to newly-allocated block */
dcl  new_qrel fixed bin;

dcl  1 dn355_word unal based (addr (datanet_mbx.fault_word)),
						/* format of 355 crash word */
       2 modnum bit (4),				/* module number (1 - 8) */
       2 opcode fixed bin (4),
       2 crash_code fixed bin (8);			/* used to index list of messages */

dcl  fault_type fixed bin;				/* 355 fault code */
dcl  fault_name char (16);				/* 355 fault name */
dcl  module_num fixed bin;				/* 355 module number */

dcl  iom_channel_fault fixed bin int static init (9);
dcl  illegal_opcode fixed bin int static init (3);
dcl  die_code fixed bin int static init (9);

dcl  1 error_msg aligned based (addr (sub_mbx.command_data (1))),
						/* error message data */
       2 data (4) bit (18) unal;

dcl  full_words (3) fixed bin;

dcl  reason_msg char (64);

dcl  cleanup condition;
%page;
%include baud_rates;
%page;
%include channel_manager_dcls;
%page;
%include dn355_data;
%page;
%include dn355_mailbox;
%page;
%include dn355_messages;
%page;
%include fnp_mpx_msg_;
%page;
%include fnp_queue_entry;
%page;
%include io_manager_dcls;
%page;
%include lct;
%page;
%include line_types;
%page;
%include mailbox_ops;
%page;
%include mcs_interrupt_info;
%page;
%include net_event_message;
%page;
%include pcb;
%page;
%include tty_buf;
%page;
%include tty_buffer_block;
%page;
%include tty_space_man_dcls;
%page;
/* BEGIN MESSAGE DOCUMENTATION

   Message:
   dn355: FNP X invalid interrupt level N

   S:  $beep

   T:  $run

   M:  An FNP interrupt has been received from frontend X with an invalid
   interrupt level of octal value N and will be ignored.  If this message is
   displayed when a DN6670 is being powered up, this message can be ignored.
   If this message occurs under any other circumstances, there might be
   something wrong with the system's interface with the FNP and should be
   investigated by FE representatives.

   A:  $inform


   Message:
   dn355: emergency interrupt from FNP X: FAULT
   .br
   FNP instruction counter = IC
   .br
   channel CHN, fault status = FS
   .br
   FNP_MODULE: REASON_FOR_CRASH

   S:  $beep

   T:  $run

   M:  An emergency interrupt has been received from FNP X indicating
   it has crashed.  All lines dialed to FNP X will be hung up.  The
   crash was nominally caused by a fault of type FAULT.  Lines
   following the first line of the message appear only in certain cases
   and provide additional information about the nature of the crash.

   A:  The system will automatically attempt to reboot the crashed FNP.
   Subsequent messages will indicate the success or failure of this attempt.
   No action is required now, but action may be required if the
   automatic reboot fails.


   Message:
   dn355: no slot number match for sub mbx N, FNP X

   S:  $beeper

   T:  $run

   M:  An error has occurred processing submailbox N for FNP X.
   The submailbox indicates a line number for which no match could
   be found.

   A:  $inform


   Message:
   dn355: Message from FNP X: MESSAGE

   S:  $info

   T:  $run

   M:  An error has been detected by FNP X as explained by MESSAGE.

   A:  No action is required by the operator to deal with the error mentioned
   in the message.  Action may be required by appropriate personnel to correct
   the problem that caused the error and undo what the FNP may have done to
   continue operation.  This may require shutting down the FNP for repairs by
   Field Engineering and reboot of the FNP to restore full operation.


   Message:
   dn355: FNP masked channel NAME for excessive interrupts

   S:  $info

   T:  $run

   M:  The FNP has masked the channel whose name is NAME because it was
   generating interrupts faster than they could be handled.

   A: The interruptions can be caused by any number of problems.  This
   can be caused by the dataset leads changing too fast for the FNP
   software to handle properly; disconnecting or connecting FNP cables,
   powering off or on a hardwired terminal, a bad modem, etc.  It is
   also possible that the FNP channel hardware is defective.  Future
   attempts to use this channel may possibly crash the FNP.  CS
   representatives may need to be called to investigate.  An "attach"
   command will be necessary to put the channel back in service.


   Message:
   dn355: unrecognized op code OPCODE with rcd from FNP X for devx N

   S:  $beeper

   T:  $run

   M:  An invalid op code, OPCODE, has been received from FNP X for device
   index N in a mailbox containing an rcd (read control data) command.

   A:  $inform


   Message:
   dn355: unrecognized io command C from FNP X for line N

   S:  $beeper

   T:  $run

   M:  An invalid io command was received from FNP X for line N. C is the
   octal representation of the command.

   A:  $inform


   Message:
   dn355: output buffer at N has zero tally

   S:  $crash

   T:  $run

   M:  An output buffer with a zero tally has been found at offset N
   in the segment tty_buf.

   A:  $inform


   Message:
   dn355: unable to allocate block for delay queue

   S:  $crash

   T:  $run

   M: There was insufficient space left in tty_buf to allocate a block
   in which to build a delay queue.

   A:  $inform


   Message:
   dn355: FNP X did not respond to mailbox interrupt

   S:  $beep

   T:  $run

   M:  An attempt to interrupt FNP X was unsuccessful. The FNP is assumed
   to be down.

   A:  The system will automatically attempt to reboot the crashed FNP.
   Subsequent messages will indicate the success or failure of this attempt.
   No action is required now, but action may be required if the
   automatic reboot fails.


   Message:
   dn355: inconsistent queue lock

   S:  $crash

   T:  $run

   M:  A process attempted to unlock the interrupt queue lock without having it
   locked.

   A:  $inform


   Message:
   dn355: LCTE lock ^= processid

   S:     $crash

   T:     $run

   M:  The FNP channel lock did not contain the processid of the process
   attempting to unlock it.


   Message:
   dn355: attempted crawlout with FNP queue locked

   S:	$crash

   T:	$run

   M:	An attempt was made to crawl out while an FNP queue lock (a processor
   lock) was locked.

   A:	$inform


   Message:
   dn355: line number of 0 with non-global opcode in submbx N, FNP X

   S:  $beeper

   T:  $run

   M:  Mailbox N from FNP X contained a non-global opcode which requires a
   non-zero line number.


   Message:
   dn355: FNP X level L status S STATE

   S:   $info

   T:   $run

   M:   An interrupt at a level other than 3 (or possibly at level 3 if the
   FNP is not running) was received from FNP X. S is an octal representation
   of the status accompanying the interrupt. STATE indicates the current state
   of the FNP: running, bootloading, or in T&D. This message only appears if
   tracing is enabled for the specified FNP.

   A:   None required.


   Message:
   dn355: Error sending mailbox interrupt to FNP X, will retry.

   S:  $info

   T:  $run

   M:  An error has been detected in the transmission of a mailbox interrupt
   to the FNP.  The transmission will be retried once.

   A:  None required.


   Message:
   dn355: Timeout sending mailbox interrupt to FNP X, will retry.

   S:  $info

   T:  $run

   M:  The FNP did not respond within 2 seconds to the previously
   sent mailbox interrupt.  The transmission will be retried once.

   A:  None required.


   END MESSAGE DOCUMENTATION */


     end dn355;
