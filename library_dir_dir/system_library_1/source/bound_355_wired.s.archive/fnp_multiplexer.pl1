/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/* format: style4,delnl,insnl,^ifthendo */
fnp_multiplexer:
     proc;

/* This is the called multiplexer module for FNP channels. It calls dn355
   *  to pass mailboxes on to the FNP. Important data structures are:
   *	fnp_info (in dn355_data) : info about the FNP as a whole
   *	pcb (physical channel block) : allocated in tty_buf. Contains per-channel info
   *
*/

/* Written 08/15/78 by Robert Coren */
/* Modified 04/11/79 by Robert Coren to handle all modes at once */
/* Modified 06/29/79 by Bernard Greenberg for FNP echo negotiation */
/* Modified 79 Aug 21 by Art Beattie to support 64K DN6670s. */
/* Modified various times in 1980 by Robert Coren to add metering */
/* Modified May 1981 by Robert Coren to keep get_meters order from using user-supplied
   pointer while FNP channel is locked */
/* Modified late summer 1981 by Robert Coren to handle tandd_attach order and COLTS channel */
/* Modified fall 1981 by Robert Coren to assign smaller buffer sizes */
/* Modified November 1981 by Robert Coren to fix bug whereby terminate_multiplexer
   didn't initialize ttybp */
/* Modified June 1982 by Robert Coren to correct precision of FNP addresses. */
/* Modified November 1983 by Robert Coren to make priv_control check the pointer set by get_fnp_meters */
/* Modified 83-12-16 BIM for io_manager calls */
/* Modified 84-05-18 BIM for correction to ioa_ strings */
/* Modified 1984-08-02 BIM for bug in shutdown_mpx handling of booting fnp */
/* Modified 1984-09-25 BIM for paged mode fnp load. (page table filling) */
/* Modified September 1984 by Robert Coren to free copied meters in
   terminate_multiplexer and to exit loop in send_global if FNP is down */
/* Modified November 1984 by Robert Coren to zero pad fields in copied meters
   so random junk from the FNP doesn't get left in tty_area */
/* Modified November 1984 by Robert Coren to use tty_area_manager to allocate and free saved meters */

/****^  HISTORY COMMENTS:
  1) change(86-04-23,Coren), approve(86-04-23,MCR7300),
     audit(86-06-19,Beattie), install(86-07-08,MR12.0-1089):
     To process 256-bit echo negotiation break tables.
  2) change(86-12-12,Beattie), approve(86-12-17,MECR0005),
     audit(86-12-12,Brunelle), install(86-12-17,MR12.0-1250):
     Declare an argument in call to fnp_util$free_page_table to accept the
     error code being returned. (phx20712)
  3) change(86-12-12,Beattie), approve(86-12-29,MCR7598),
     audit(87-01-07,Brunelle), install(87-01-12,MR12.0-1268):
     Declare an argument in call to fnp_util$free_page_table to accept the
     error code being returned. (phx20712)
                                                   END HISTORY COMMENTS */

%page;
/* PARAMETERS */

dcl  a_devx fixed bin;				/* devx of FNP channel */
dcl  a_init_info_ptr ptr;
dcl  a_fnpp ptr;
dcl  a_subchan fixed bin;
dcl  a_chainp ptr;
dcl  a_mi_flag bit (1) aligned;
dcl  a_code fixed bin (35);
dcl  a_output_ptr ptr;
dcl  a_order char (*);
dcl  a_data_ptr ptr;
dcl  a_mode_list_ptr ptr;
dcl  a_modes char (*);


/* AUTOMATIC */

dcl  code fixed bin (35);				/* standard system error code */
dcl  devx fixed bin;				/* of FNP channel */
dcl  my_chan_name char (1);
dcl  dno fixed bin;					/* FNP number */
dcl  pcb_space fixed bin;
dcl  space_needed fixed bin;
dcl  output_ptr ptr;				/* pointer to caller's output data */
dcl  chanx fixed bin;				/* index of PCB */
dcl  output_length fixed bin;				/* number of output characters */
dcl  sourcep ptr;
dcl  (i, j) fixed bin;
dcl  lastp ptr;					/* pointer to last buffer in already-exisitng chain */

dcl  order char (32);
dcl  data_ptr ptr;					/* pointer to order info structure */
dcl  set_write_status bit (1);
dcl  locked bit (1);
dcl  old_mask fixed bin (71);
dcl  mask_ptwp ptr;
dcl  queue_locked bit (1);
dcl  mylock bit (1);
dcl  opcode fixed bin (8);				/* mailbox opcode */
dcl  alter_type fixed bin (8);			/* alter parameters subop */
dcl  check bit (1);
dcl  mbx_data_len fixed bin;				/* in bits */
dcl  mbx_data bit (4 * 36) based (addr (mbx_data_long));
dcl  mbx_data_long bit (8 * 36);
dcl  alter_data bit (4 * 36) varying;
dcl  dumpin bit (1);
dcl  dumpout bit (1);
dcl  get_meters bit (1);
dcl  temp_saved_meters_ptr ptr;
dcl  meter_ptr ptr;
dcl  lcmp ptr;
dcl  fnp_meters_ptr ptr;
dcl  ret_meters_ptr ptr;
dcl  local_line_type fixed bin;
dcl  phone_no_len fixed bin;				/* in bits */
dcl  phone_digits (32) bit (6);
dcl  next_digit fixed bin (6) unsigned;			/* value of next dialout digit */
dcl  digit_pos fixed bin;				/* how far along we are in phone number */
dcl  opend bit (1);					/* whether or not output is pending */

dcl  modex fixed bin;
dcl  mode_name char (8);
dcl  mode_on bit (1);				/* mode to be turned on or off */
dcl  mode_set (36) bit (1);
dcl  hndlquit_set bit (1);
dcl  base_len fixed bin;
dcl  block_len fixed bin;
dcl  chars_per_buf fixed bin;
dcl  chars_per_sec fixed bin;

dcl  wire_arg fixed bin (71);
dcl  wire_ptr ptr;
dcl  hsla_flag bit (1);
dcl  old_flag bit (1);
dcl  pcb_space_ptr ptr;
dcl  prev_la_no fixed bin;
dcl  la_no fixed bin;
dcl  subchan fixed bin;
dcl  his_fnp_no fixed bin;				/* FNP number in supplied channel name */
dcl  pcbx fixed bin;
dcl  found bit (1);
dcl  past bit (1);
dcl  n_fnp_words fixed bin;
dcl  ignore bit (1);
dcl  name char (32);
dcl  temp_addr fixed bin;
dcl  fnp_dump_ptr ptr;
dcl  dump_patch_space fixed bin;			/* amount of space required by an fnp_(dump patch) order */
dcl  dump_patch_time fixed bin (71);			/* clock time when a dump or patch order was initiated */


dcl  1 dump_fnp_data aligned,				/* command data for dump_fnp & patch_fnp */
       2 abs_addr fixed bin (24),			/* absolute address of ring-zero buffer */
       2 fnp_addr fixed bin (18) unsigned unaligned,	/* address in FNP */
       2 fnp_len fixed bin (18) unsigned unaligned;	/* number of 18-bit words */

dcl  1 fnp_break_data aligned,			/* command data for fnp_break order */
       2 lineno fixed bin (17) unal,			/* line number, derived from tty name */
       2 fnp_addr fixed bin (18) unsigned unal,
       2 action fixed bin (17) unal,
       2 flags bit (18) unal;

dcl  1 echnego_break_table aligned,
       2 words (0:15) unaligned,
         3 bits bit (16) unaligned,
         3 pad bit (2) unaligned;

/* BASED */

dcl  based_fb_word fixed bin based;
dcl  based_bit1 bit (1) based;
dcl  based_bit2 bit (2) based;
dcl  based_bit18 bit (18) based;
dcl  based_bit72 bit (72) based;
dcl  based_bit108 bit (108) based;
dcl  based_echo_table_bits bit (WIRED_ECHO_BREAK_SIZE + 1) based;
dcl  fnp_data (n_fnp_words) bit (18) based;

dcl  phone_chars char (32) varying based;		/* phone number passed with dial_out order */

dcl  1 wr_stat aligned based,				/* for write_status */
       2 ev_chan fixed bin (71),
       2 output_pending bit (1);

dcl  1 rd_stat aligned based,				/* for read_status */
       2 ev_chan fixed bin (71),
       2 input_available bit (1);

dcl  1 dump_fnp_info based (data_ptr) aligned,		/* structure passed for dump_fnp and patch_fnp */
       2 fnp_address fixed bin (24),
       2 fnp_len fixed bin,				/* number of 18=bit words */
       2 bufp ptr,					/* pointer to caller's buffer */
       2 old_value_ptr ptr;				/* pointer to previous values (patch only) */

dcl  1 fnp_break_info aligned based (data_ptr),		/* structure passed on fnp_break order */
       2 chan_name char (6),				/* tty name, optional */
       2 fnp_addr fixed bin,				/* addr in fnp to set break */
       2 action fixed bin,				/* request type */
       2 flags bit (36);				/* special action flags */

dcl  1 echo_start_data aligned based (data_ptr),		/* Echo starting data */
       2 ctr fixed bin (35),				/* Synchronization counter */
       2 screenleft fixed bin (35);			/* Length left on screen */

/* BUILTINS & CONDITIONS */

dcl  (addr, addrel, bin, bit, clock, divide, hbound, length, null, ptr, rel, rtrim, size, stac, stacq, string, substr,
     unspec) builtin;

dcl  area condition;


/* ENTRIES */

dcl  pxss$notify entry (fixed bin);
dcl  dn355$send_wcd entry (ptr, ptr, fixed bin (8), fixed bin, bit (*));
dcl  dn355$send_global_wcd entry (ptr, fixed bin (8), fixed bin, bit (*));
dcl  dn355$hangup_fnp_lines entry (fixed bin);
dcl  dn355$process_interrupt_queue entry (fixed bin);
dcl  dn355$interrupt entry;
dcl  fnp_util$fill_page_table entry (fixed bin, fixed bin (35));
dcl  fnp_util$free_page_table entry (fixed bin, fixed bin (35));
dcl  fnp_util$unwire entry (fixed bin, fixed bin (35));
dcl  tty_lock$lock_lcte entry (ptr, fixed bin (35));
dcl  tty_area_manager$allocate entry (fixed bin, ptr);
dcl  tty_area_manager$free entry (fixed bin, ptr);
dcl  lock$lock_fast entry (pointer);
dcl  lock$unlock_fast entry (pointer);
dcl  syserr entry options (variable);
dcl  syserr$error_code entry options (variable);
dcl  parse_tty_name_ entry (char (*), fixed bin, bit (1), fixed bin, fixed bin);
dcl  parse_fnp_name_ entry (char (*), fixed bin);
dcl  pxss$addevent entry (fixed bin);
dcl  pxss$delevent entry (fixed bin);
dcl  pxss$wait entry;

/* EXTERNAL STATIC */

dcl  (
     error_table_$noalloc,
     error_table_$undefined_order_request,
     error_table_$bad_mode,
     error_table_$bad_channel,
     error_table_$buffer_big,
     error_table_$invalid_write,
     error_table_$dev_offset_out_of_bounds,
     error_table_$seglock,
     error_table_$mpx_down,
     error_table_$timeout,
     error_table_$unimplemented_version,
     error_table_$no_channel_meters,
     error_table_$resource_not_free,
     error_table_$io_assigned,
     error_table_$io_not_assigned,
     error_table_$io_not_configured,
     error_table_$io_not_available,
     error_table_$invalid_state
     ) ext static fixed bin (35);

dcl  pds$processid ext static bit (36) aligned;
dcl  pds$process_group_id ext static char (32) aligned;

/* INTERNAL STATIC */

/* The following are declared here because syserr_constants.incl.pl1 cannot
   be used, owing to a naming conflict with mcs_interrupt_info.incl.pl1.
*/

dcl  ANNOUNCE fixed bin internal static options (constant) init (0);
dcl  CRASH_SYSTEM fixed bin internal static options (constant) init (1);

dcl  DCW_LIST_SIZE fixed bin int static options (constant) init (16);
dcl  DUMP_PATCH_LIMIT fixed bin (35) int static options (constant) init (10000000);
						/* i.e., 10 seconds */

/* The following facts about the the lists of modes below are IMPORTANT.
   *  The modes which have corresponding alter_parameters subtypes are the same as the modes
   *  that are valid for asynchronous lines only, and no data is associated with the
   *  alter_parameters other than on/off, with the following exceptions:
   *	blk_xfer and iflow require additional data (buffer sizes)
   *	hndlquit is valid for any line, but is expressed by alter_parameters
   *
   *  Therefore, hndlquit is handled explicitly, and blk_xfer and iflow must come after those modes having alter_paramters
   *  subop types. Anyone modifying these lists should be aware of this circumstance.
*/

dcl  good_modes (1) char (8) int static options (constant)	/* modes recognized for all lines */
	init ("hndlquit");

dcl  async_only_modes (15) char (8) int static options (constant)
						/* modes recognized for async lines only */
	init ("crecho", "tabecho", "lfecho", "echoplex", "fulldpx", "replay", "polite", "breakall", "prefixnl",
	"no_outp", "8bit", "oddp", "oflow", "iflow", "blk_xfer");

dcl  IFLOW_INDEX fixed bin internal static options (constant) init (14);
dcl  BLK_XFER_INDEX fixed bin internal static options (constant) init (15);

dcl  full_dpx_modes (7) char (8) int static options (constant)
						/* modes requiring full duplex line type */
	init ("crecho", "tabecho", "lfecho", "echoplex", "fulldpx", "iflow", "oflow");

dcl  mode_alter_types (13) fixed bin (8) int static options (constant)
						/* alter_paramters subops corresponding to modes */
	init (8,					/* crecho */
	14,					/* tabecho */
	9,					/* lfecho */
	20,					/* echoplex */
	3,					/* fulldpx */
	23,					/* replay */
	24,					/* polite */
	27,					/* breakall */
	28,					/* prefixnl */
	33,					/* no_outp */
	32,					/* 8bit */
	31,					/* oddp */
	30);					/* oflow */

/* INCLUDE FILES */

%page;
%include tty_buf;
%page;
%include tty_buffer_block;
%page;
%include lct;
%page;
%include dn355_data;
%page;
%include pcb;
%page;
%include mailbox_ops;
%page;
%include tty_space_man_dcls;
%page;
%include line_types;
%page;
%include mux_init_info;
%page;
%include io_chnl_util_dcls;
%include mcs_modes_change_list;
%include flow_control_info;
%include channel_manager_dcls;
%include mcs_interrupt_info;
%include fnp_meters;
%include fnp_channel_meters;
%include get_comm_meters_info;
%include io_manager_dcls;
%include mcs_echo_neg_sys;

init_multiplexer:
     entry (a_devx, a_init_info_ptr, a_fnpp, a_code);

/* This entry is called to initialize data bases preparatory to loading an FNP
   *  In particular, it initializes the appropriate entry in fnp_info, and allocates
   *   and initializes PCBs
*/


	devx = a_devx;
	miip = a_init_info_ptr;
	mii_chan_count = mux_init_info.no_channels;
	pcb_space_ptr = null ();			/* make cleanup safe */
	infop = addr (dn355_data$);
	ttybp = addr (tty_buf$);
	lctp = tty_buf.lct_ptr;

	lcntp = lct.lcnt_ptr;			/* get channel name */
	if length (rtrim (lcnt.names (devx))) ^= 1
	then go to bad_channel;
	my_chan_name = rtrim (lcnt.names (devx));
	call parse_fnp_name_ (my_chan_name, dno);
	if dno < 0				/* unreasonable name */
	then do;
bad_channel:
	     a_code = error_table_$bad_channel;
	     go to init_exit;
	end;

	fnpp = addr (datanet_info.per_datanet (dno));
	call TRACE ("init_multiplexer");		/* only error trace if bad devx */

	if my_chan_name ^= fnp_info.fnp_tag
	then go to bad_channel;
	if ^tty_buf.fnp_config_flags (dno)
	then go to bad_channel;

	call lock$lock_fast (addr (datanet_info.configuration_lock));
						/* noone else can configure */
	fnp_info.lcte_ptr = addr (lct.lcte_array (devx));

	if fnp_info.t_and_d_in_progress		/* lcte will be invalid, but still */
	then do;
	     code = error_table_$io_not_available;
	     go to init_abort;
	end;

	call assign_channel (code);			/* under config lock */
	if code ^= 0
	then go to init_abort;			/* it may have been deconfigured while we were farting around */

	call fnp_util$fill_page_table ((fnp_info.fnp_number), code);
	if code ^= 0
	then go to init_abort;			/* IOI has problems? */

	do i = 0 to 2;				/* initialize line-number indexes */
	     fnp_info.hsla_idx (i) = -1;
	     fnp_info.lsla_idx (i) = -1;
	end;
	do i = 3 to 5;				/* 3 more for LSLAs */
	     fnp_info.lsla_idx (i) = -1;
	end;

	pcb_space = size (pcb) * mii_chan_count;	/* get enough space for an array of PCBs */
	space_needed = pcb_space + 8 * DCW_LIST_SIZE;
	call tty_space_man$get_space (space_needed, pcb_space_ptr);
	if pcb_space_ptr = null			/* this would be unfortunate */
	then do;
	     a_code = error_table_$noalloc;
	     go to init_abort;
	end;
	n_pcbs, fnp_info.no_of_channels = mii_chan_count;
	pcb_space_ptr -> pcb_array (*).saved_meters_ptr = null ();
						/* for cleanup */
	fnp_info.pcb_array_ptr = pcb_space_ptr;
	fnp_info.dcw_list_array_ptr = addrel (pcb_space_ptr, pcb_space);
	string (fnp_info.flags) = "0"b;
	prev_la_no = -1;				/* so test will work right the first time */
	old_flag = "1"b;				/* HSLA channels (if any) are always first */

/*
   * The following code assigns line numbers and sets the adapter indexes
   * It assumes that channels in mux_init_info are sorted in ascending order
*/

	do pcbx = 1 to n_pcbs;
	     pcbp = addr (pcb_space_ptr -> pcb_array (pcbx));
	     unspec (pcb) = "0"b;
	     pcb.saved_meters_ptr = null ();		/* for cleanup dept */
	     pcb.devx = mux_init_info.channels (pcbx).devx;
	     lctep = addr (lct.lcte_array (pcb.devx));
	     lcte.subchannel = pcbx;
	     name = mux_init_info.channels (pcbx).name;
	     call parse_tty_name_ (name, his_fnp_no, hsla_flag, la_no, subchan);
	     if his_fnp_no ^= dno
	     then do;
		code = error_table_$bad_channel;
		go to init_abort;
	     end;
	     if la_no = 7
	     then fnp_info.tandd_pcbx = pcbx;
	     else if (la_no ^= prev_la_no | hsla_flag ^= old_flag)
						/* first subchannel on this adapter */
	     then do;
		if hsla_flag
		then fnp_info.hsla_idx (la_no) = pcbx;
		else fnp_info.lsla_idx (la_no) = pcbx;
		prev_la_no = la_no;
		old_flag = hsla_flag;
	     end;

	     pcb.subchan = subchan;
	     pcb.is_hsla = hsla_flag;
	     pcb.la_no = bit (bin (la_no, 3), 3);
	     if hsla_flag
	     then pcb.slot_no = bit (bin (subchan, 6), 6);


/*	     * lsla slot number has to wait for baud rate supplied at bootload time */

	     on area
		begin;
		code = error_table_$noalloc;
		go to init_abort;
	     end;

	     call tty_area_manager$allocate (size (fnp_channel_meters), temp_saved_meters_ptr);
	     pcb.saved_meters_ptr = temp_saved_meters_ptr;
	end;

	call lock$unlock_fast (addr (datanet_info.configuration_lock));

	a_fnpp = fnpp;				/* pass this back */
	a_code = 0;
init_exit:
	return;

init_abort:
	call TRACE_ERROR ("init_multiplexer", code);
	call lock$unlock_fast (addr (datanet_info.configuration_lock));
	if pcb_space_ptr ^= null
	then do;
	     do pcbx = 1 to n_pcbs;
		pcbp = addr (pcb_space_ptr -> pcb_array (pcbx));
		if pcb.saved_meters_ptr ^= null ()
		then call tty_area_manager$free (size (fnp_channel_meters), (pcb.saved_meters_ptr));
	     end;
	     call tty_space_man$free_space (space_needed, pcb_space_ptr);
	end;
	a_code = code;
	return;

terminate_multiplexer:
     entry (a_fnpp, a_code);

/* This entry is called after FNP crash or shutdown in order to free PCBs */

	fnpp = a_fnpp;
	ttybp = addr (tty_buf$);
	infop = addr (dn355_data$);
	locked = "0"b;
	call TRACE ("terminate_multiplexer");
	call lock;
	if code ^= 0
	then go to terminate_return;

	if fnp_info.bootloading | fnp_info.wired | fnp_info.running
						/* bad time to terminate */
	then code = error_table_$invalid_state;

	else do;
	     do i = 1 to fnp_info.no_of_channels;
		pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (i));
		if pcb.write_first ^= 0
		then call tty_space_man$free_chain ((pcb.devx), OUTPUT, ptr (ttybp, pcb.write_first));
		if pcb.read_first ^= 0
		then call tty_space_man$free_chain ((pcb.devx), INPUT, ptr (ttybp, pcb.read_first));
		call tty_area_manager$free (size (fnp_channel_meters), (pcb.saved_meters_ptr));
		if pcb.copied_meters_offset ^= 0	/* free this if it's there */
		then do;
		     call tty_space_man$free_space (size (fnp_channel_meters), ptr (ttybp, pcb.copied_meters_offset));
		     pcb.copied_meters_offset = 0;
		end;
	     end;

	     string (fnp_info.flags) = "0"b;
	     call tty_space_man$free_space (size (pcb) * fnp_info.no_of_channels + 8 * DCW_LIST_SIZE,
		fnp_info.pcb_array_ptr);
	     fnp_info.pcb_array_ptr = null;
	     code = 0;
	end;

	if fnp_info.io_manager_assigned
	then call unassign_channel (code);		/* not deconfigured on us */
	call fnp_util$free_page_table ((fnp_info.fnp_number), (0));
						/* even if we lost the assignment ... */
	call unlock;

terminate_return:
	if code ^= 0
	then call TRACE_ERROR ("terminate_multiplexer", code);
	a_code = code;
	return;

start:
     entry (a_fnpp, a_code);

/* entry to enable an FNP by sending "accept_calls" order */

	fnpp = a_fnpp;
	infop = addr (dn355_data$);
	call TRACE ("start");
	chanx = 1;				/* this is irrelevant, but will make setup happy */
	call setup;
	if code = 0
	then do;
	     call dn355$send_global_wcd (fnpp, accept_calls, 18,
		bit (bin (bin (rel (addr (tty_buf.free_space)), 18) + tty_buf.absorig, 18), 18));
	     call unlock;				/* setup locked */
	end;
	if code ^= 0
	then call TRACE_ERROR ("start", code);
	a_code = code;
	return;


stop:
     entry (a_fnpp, a_code);

/* entry to disable an FNP from further dialups (by sending dont_accept_calls order) */

	fnpp = a_fnpp;
	infop = addr (dn355_data$);
	call TRACE ("stop");
	chanx = 1;				/* as for start entry */
	call setup;
	if code = 0
	then do;
	     call dn355$send_global_wcd (fnpp, dont_accept_calls, 0, ""b);
	     call unlock;				/* setup locked */
	end;
	if code ^= 0
	then call TRACE_ERROR ("stop", code);
	a_code = code;
	return;


shutdown:
     entry (a_fnpp, a_code);

/* This entry simulates an FNP crash; if the FNP is up, all lines will be hung up */

	infop = addr (dn355_data$);
	fnpp = a_fnpp;
	if fnpp = null ()
	then do;
	     if datanet_info.trace
	     then call syserr (ANNOUNCE, "fnp_multiplexer$shutdown: Called with null fnp_ptr");
	     go to shutdown_return;
	end;
	call TRACE ("shutdown");
	infop = addr (dn355_data$);

	if fnp_info.wired | fnp_info.bootloading	/* do the user ring a favor */
	then do;
	     if datanet_info.trace
	     then call syserr (ANNOUNCE, "fnp_multiplexer$shutdown: Called with FNP wired.");
	     call fnp_util$unwire ((fnp_info.fnp_number), code);
	     if code ^= 0
	     then call syserr$error_code (ANNOUNCE, code, "fnp_multiplexer$shutdown: Failed to unwire fnp.");
	end;

	locked = "0"b;
	if fnp_info.running				/* if it's up now */
	then do;
	     call lock;
	     call dn355$hangup_fnp_lines ((fnp_info.fnp_number));
	     fnp_info.running = "0"b;
	     call unlock;
	end;


shutdown_return:
	a_code = 0;
	return;


read:
     entry (a_fnpp, a_subchan, a_chainp, a_mi_flag, a_code);

/* this is a dummy entry, dn355 never holds input at interrupt time */

	a_chainp = null;
	a_mi_flag = "0"b;
	a_code = 0;
	return;


write:
     entry (a_fnpp, a_subchan, a_output_ptr, a_code);

	fnpp = a_fnpp;
	chanx = a_subchan;
	output_ptr = a_output_ptr;

	call setup;
	if code ^= 0
	then do;
	     a_code = code;
	     return;
	end;

/* figure out length of chain */

	blockp = output_ptr;
	output_length = buffer.tally;			/* to start with */

	do while (buffer.next ^= 0);
	     blockp = ptr (ttybp, buffer.next);
	     output_length = output_length + buffer.tally;
	end;

	if pcb.write_last ^= 0			/* existing write chain */
	then do;
	     lastp = ptr (ttybp, pcb.write_last);
	     lastp -> buffer.next = bin (rel (output_ptr));
	end;

	else pcb.write_first = bin (rel (output_ptr));

	pcb.write_last = bin (rel (blockp));		/* in any case */
	pcb.write_cnt = pcb.write_cnt + output_length;

	if pcb.send_output				/* if the FNP is ready for it */
	then call dn355$send_wcd (fnpp, pcbp, accept_direct_output, 0, ""b);

	code = 0;
write_exit:
	call unlock;
	if code = 0
	then a_output_ptr = null ();			/* so caller will know we took it all */
	a_code = code;
	return;

control:
     entry (a_fnpp, a_subchan, a_order, a_data_ptr, a_code);

	fnpp = a_fnpp;
	chanx = a_subchan;
	order = a_order;
	data_ptr = a_data_ptr;

	dumpin, dumpout, set_write_status, get_meters = "0"b;
						/* initialize local variables */
	opcode, alter_type = -1;
	check = "0"b;

	if order = "read_status"			/* there's never any at this level */
	then do;
	     data_ptr -> rd_stat.input_available = "0"b;
	     a_code = 0;
	     return;
	end;

	else if order = "hangup"
	then do;
	     mbx_data_len = 0;
	     mbx_data = ""b;
	     opcode = disconnect_this_line;
	end;

	else if order = "wru"
	then do;
	     alter_type = Wru;
	     alter_data = ""b;
	end;

	else if order = "interrupt"
	then do;
	     alter_type = Break;
	     alter_data = ""b;
	end;

	else if order = "start_xmit_hd" | order = "stop_xmit_hd"
	then do;
	     alter_type = Xmit_hold;
	     alter_data = "00000000"b || (order = "start_xmit_hd");
	end;

	else if order = "set_input_message_size"
	then do;
	     mbx_data = bit (bin (data_ptr -> based_fb_word, 18), 18);
	     opcode = sync_msg_size;
	end;

	else if order = "line_control"
	then do;
	     mbx_data_len = 72;
	     mbx_data = data_ptr -> based_bit72;
	     opcode = line_control;
	end;

	else if order = "set_framing_chars"
	then do;
	     mbx_data_len = 18;
	     mbx_data = data_ptr -> based_bit18;	/* two characters are packed in halfword */
	     opcode = set_framing_chars;
	end;

	else if order = "set_delay"
	then do;
	     mbx_data_len = 108;
	     mbx_data = data_ptr -> based_bit108;	/* 6 18-bit values */
	     opcode = set_delay_table;
	end;

	else if order = "abort"			/* i.e., resetread or resetwrite */
	then do;
	     dumpin = substr (data_ptr -> based_bit2, 2, 1);
						/* we'll simply save this info for later */
	     dumpout = substr (data_ptr -> based_bit2, 1, 1);
	end;

	else if order = "set_line_type"
	then do;
	     mbx_data_len = 18;
	     local_line_type = data_ptr -> based_fb_word;
	     if local_line_type <= 0 | local_line_type > max_line_type
	     then go to order_error;
	     check = "1"b;				/* we'll have to look at PCB (after locking) */
	     opcode = set_line_type;
	end;

	else if order = "dial_out"
	then do;					/* we have to convert digits (in char. form) to 6-bit BCD */
	     digit_pos = 0;
	     do i = 1 to length (data_ptr -> phone_chars);/* should never see "X" in phone number */
		next_digit = index ("0123456789XXX!", substr (data_ptr -> phone_chars, i, 1)) - 1;
						/* a value of 13 tells autocall unit to wait for a */
						/* dial tone before asking for another dialing digit */
		if next_digit >= 0
		then if next_digit < 10 | next_digit = 13
		     then do;			/* it's actually a digit */
			digit_pos = digit_pos + 1;
			phone_digits (digit_pos) = bit (next_digit, 6);
		     end;
	     end;

	     phone_no_len = 6 * digit_pos;
	     opcode = dial;
	     check = "1"b;				/* special stuff required here too */
	end;

	else if order = "listen"
	then do;
	     alter_type = Listen;
	     alter_data = "000000001"b;
	end;

	else if order = "write_status"
	then set_write_status = "1"b;

	else if order = "enter_receive"
	then do;
	     mbx_data_len = 0;
	     mbx_data = ""b;
	     opcode = enter_receive;
	end;
	else if order = "start_negotiated_echo"
	then do;
	     mbx_data_len = 36;
	     mbx_data =
		bit (fixed (data_ptr -> echo_start_data.ctr, 18), 18)
		|| bit (fixed (data_ptr -> echo_start_data.screenleft, 18), 18);
	     opcode = start_negotiated_echo;
	end;
	else if order = "set_echnego_break_table"
	then do;
	     mbx_data_len = length (unspec (echnego_break_table));
	     unspec (echnego_break_table) = ""b;	/* Get pads */
	     do i = 0 to hbound (echnego_break_table.words, 1);
		echnego_break_table.bits (i) = substr (data_ptr -> based_echo_table_bits, 1 + 16 * i, 16);
	     end;
	     mbx_data_long = unspec (echnego_break_table);
	     opcode = set_echnego_break_table;
	end;
	else if order = "init_echo_negotiation"
	then do;
	     mbx_data_len = 0;
	     mbx_data = ""b;
	     opcode = init_echo_negotiation;
	end;
	else if order = "stop_negotiated_echo"
	then do;
	     mbx_data_len = 0;
	     mbx_data = ""b;
	     opcode = stop_negotiated_echo;
	end;
	else if order = "input_flow_control_chars"
	then do;
	     mbx_data_len = 36;
	     if data_ptr -> input_flow_control_info.resume_seq.count = 0
						/* turning it all off */
	     then mbx_data = ""b;
	     else do;
		mbx_data =
		     unspec (substr (data_ptr -> input_flow_control_info.suspend_seq.chars, 1, 1))
		     || unspec (substr (data_ptr -> input_flow_control_info.resume_seq.chars, 1, 1))
		     || data_ptr -> input_flow_control_info.timeout;
		if data_ptr -> input_flow_control_info.suspend_seq.count = 0
		then substr (mbx_data, 1, 9) = "0"b;	/* don't send suspend char if there isn't one */
	     end;
	     opcode = input_fc_chars;
	end;
	else if order = "output_flow_control_chars"
	then do;
	     mbx_data_len = 36;
	     if data_ptr -> output_flow_control_info.suspend_or_etb_seq.count = 0
						/* no chars */
	     then mbx_data = "0"b;
	     else mbx_data =
		     unspec (substr (data_ptr -> output_flow_control_info.suspend_or_etb_seq.chars, 1, 1))
		     || unspec (substr (data_ptr -> output_flow_control_info.resume_or_ack_seq.chars, 1, 1))
		     || data_ptr -> output_flow_control_info.block_acknowledge;
	     opcode = output_fc_chars;
	end;

	else if order = "copy_meters"
	then do;
	     opcode = report_meters;
	     check = "1"b;
	end;

	else if order = "get_meters"
	then do;
	     ret_meters_ptr = data_ptr -> get_comm_meters_info.parent_ptr;
	     if ret_meters_ptr = null ()
	     then return;
	     else if ret_meters_ptr -> fnp_chan_meter_struc.version ^= FNP_CHANNEL_METERS_VERSION_1
	     then do;
		a_code = error_table_$unimplemented_version;
		return;
	     end;

	     else get_meters = "1"b;
	end;

	else if order = "tandd_attach"
	then do;					/* simulate a dialup without bothering the FNP (channel is hung up already) */
	     call setup;
	     if code ^= 0
	     then do;
		a_code = code;
		return;
	     end;

	     if pcb.listen | pcb.dialed		/* can't have this */
	     then do;
		call unlock;
		a_code = error_table_$resource_not_free;
		return;
	     end;

	     pcb.dialed = "1"b;
	     pcb.tandd_attached = "1"b;
	     unspec (dialup_info) = ""b;
	     dialup_info.baud_rate = 1200;		/* just so it's something */
	     dialup_info.line_type = LINE_ASCII;	/* make everyone's life easier */
	     dialup_info.max_buf_size = 16;		/* COLTS wants small buffers */
	     call channel_manager$interrupt ((pcb.devx), DIALUP, unspec (dialup_info));
	     call unlock;
	     a_code = 0;
	     return;
	end;

	else do;
order_error:
	     a_code = error_table_$undefined_order_request;
	     return;
	end;

	code = 0;
	call setup;
	if code ^= 0
	then do;
	     a_code = code;
	     return;
	end;

	if opcode = disconnect_this_line		/* hangup */
	then do;
	     pcb.listen, pcb.tandd_attached = "0"b;
	end;

	if opcode = start_negotiated_echo & (pcb.write_first ^= 0
						/* We have queued output */
	     | pcb.output_mbx_pending)
	then do;					/* The FNP has not take the mbx. */
						/* handler re-do it when he sees this. */
	     call unlock;
	     a_code = error_table_$invalid_write;
	     return;
	end;


	if alter_type ^= -1				/* alter_parameters required */
	then do;
	     if alter_type = Listen
	     then do;				/* need to tell it buffer size */
		alter_data = alter_data || fnp_buf_size ();
		pcb.listen = "1"b;
	     end;

	     mbx_data_len = length (alter_data) + 9;	/* 9 bits for subop type */
	     mbx_data = bit (bin (alter_type, 9), 9) || alter_data;
	     opcode = alter_parameters;
	end;

	if opcode ^= -1				/* we do have to send the FNP something */
	then do;
	     if check				/* anything special about it */
	     then do;
		if opcode = set_line_type		/* make sure this is OK */
		then if pcb.listen
		     then do;			/* it isn't */
			call unlock;
			go to order_error;
		     end;

		     else do;
			mbx_data = bit (bin (local_line_type, 18), 18);
			do i = 1 to n_sync_line_types while (local_line_type ^= sync_line_type (i));
			end;

			pcb.sync_line = (i <= n_sync_line_types);
		     end;

		else if opcode = dial		/* in this case we have to supply buffer size first */
		then do;				/* because no listen was done */
		     mbx_data_len = 36;
		     alter_data = bit (bin (Set_buffer_size, 9), 9) || "000000001"b;
		     mbx_data = alter_data || fnp_buf_size ();
		     call dn355$send_wcd (fnpp, pcbp, alter_parameters, mbx_data_len, mbx_data);

		     mbx_data_len = phone_no_len;
		     mbx_data_long = string (phone_digits);
		end;
		else if opcode = report_meters
		then do;
		     call tty_space_man$get_space (size (fnp_channel_meters), meter_ptr);
						/* get a buffer for the FNP meters */
		     if meter_ptr = null ()		/* couldn't get it */
		     then do;
			call unlock;
			a_code = error_table_$noalloc;
			return;
		     end;

		     pcb.copied_meters_offset = bin (rel (meter_ptr), 18);
		     mbx_data = bit (bin (tty_buf.absorig + pcb.copied_meters_offset, 18), 18);
		     mbx_data_len = 18;
		end;
	     end;

	     call dn355$send_wcd (fnpp, pcbp, opcode, mbx_data_len, mbx_data_long);
	end;

	else do;
	     if dumpin
	     then call dn355$send_wcd (fnpp, pcbp, alter_parameters, 9, bit (bin (Dumpinput, 9), 9));

	     if dumpout
	     then do;				/* first get rid of any ring 0 output */
		if pcb.write_first ^= 0
		then do;
		     call tty_space_man$free_chain ((pcb.devx), OUTPUT, ptr (ttybp, pcb.write_first));
		     pcb.write_first, pcb.write_last, pcb.write_cnt = 0;
		end;


		call dn355$send_wcd (fnpp, pcbp, alter_parameters, 9, bit (bin (Dumpoutput, 9), 9));

		if pcb.end_frame
		then do;
		     pcb.end_frame = "0"b;
		     if pcb.send_output
		     then call channel_manager$interrupt ((pcb.devx), SEND_OUTPUT, ""b);
		end;
	     end;

	     if set_write_status
	     then opend = (pcb.write_first ^= 0);	/* this has to be in automatic, return structure isn't wired */

	     if get_meters
	     then do;
		call get_fnp_meters ("0"b);
		call unlock;

		if code = 0
		then ret_meters_ptr -> fnp_chan_meter_struc.synchronous = pcb.sync_line;
		if fnp_meters_ptr ^= null ()
		then do;
		     if unspec (fnp_meters_ptr -> fnp_channel_meters) = "0"b
		     then code = error_table_$no_channel_meters;
		     else do;
			ret_meters_ptr -> fnp_chan_meter_struc.current_meters =
			     fnp_meters_ptr -> fnp_channel_meters;
			ret_meters_ptr -> fnp_chan_meter_struc.saved_meters =
			     pcb.saved_meters_ptr -> fnp_channel_meters;
		     end;

		     call tty_space_man$free_space (size (fnp_channel_meters), fnp_meters_ptr);
		end;
	     end;
	end;

	call unlock;
	if set_write_status
	then data_ptr -> wr_stat.output_pending = opend;
	a_code = code;

	return;

check_modes:
     entry (a_fnpp, a_subchan, a_mode_list_ptr, a_code);

/* this entry is used to determine if this multiplexer understands or accepts a given set of modes */

	fnpp = a_fnpp;
	chanx = a_subchan;
	mclp = a_mode_list_ptr;
	if mcl.version ^= mcl_version_2
	then do;
	     a_code = error_table_$unimplemented_version;
	     return;
	end;

	call setup;				/* now we need PCB pointer */
	if code ^= 0
	then do;
	     a_code = code;
	     return;
	end;

	do modex = 1 to mcl.n_entries;
	     mclep = addr (mcl.entries (modex));
	     mode_name = substr (mcle.mode_name, 1, 8);
	     mode_on = mcle.mode_switch;

	     do i = 1 to hbound (good_modes, 1) while (mode_name ^= good_modes (i));
	     end;

	     if i <= hbound (good_modes, 1)		/* tree */
						/* it's one of the ones we always recognize */
	     then mcle.mpx_mode = "1"b;
	     else do;
		do i = 1 to hbound (async_only_modes, 1) while (mode_name ^= async_only_modes (i));
		end;

		if i > hbound (async_only_modes, 1)	/* we've never heard of this one at all */
		then mcle.mpx_mode = "0"b;
		else do;
		     mcle.mpx_mode = ^pcb.sync_line;	/* this mode is meaningful for asynchronous lines only */

		     do i = 1 to hbound (full_dpx_modes, 1) while (mode_name ^= full_dpx_modes (i));
		     end;

		     if (mode_name = "no_outp" | mode_name = "8bit" | mode_name = "oddp") & mode_on
		     then if ^pcb.is_hsla
			then go to bad_mode;

		     if i <= hbound (full_dpx_modes, 1) /* if this was a mode requiring full duplex capability */
		     then if mode_on
			then if pcb.line_type ^= LINE_ASCII & pcb.line_type ^= LINE_ASYNC1
				& pcb.line_type ^= LINE_ASYNC2 & pcb.line_type ^= LINE_ASYNC3
			     then do;
bad_mode:
				if mcle.force
				then mcle.mpx_mode = "0"b;
				else do;
				     code = error_table_$bad_mode;
				     mcle.error = "1"b;
				end;
			     end;

		end;
	     end;
	end;

	call unlock;				/* setup locked */
	a_code = code;
	return;

set_modes:
     entry (a_fnpp, a_subchan, a_mode_list_ptr, a_code);

/* this entry sets a specified set of mode (probably by calling dn355$send_wcd) */

	fnpp = a_fnpp;
	chanx = a_subchan;
	mclp = a_mode_list_ptr;
	if mcl.version ^= mcl_version_2
	then do;
	     a_code = error_table_$unimplemented_version;
	     return;
	end;

	call setup;
	if code ^= 0
	then do;
	     a_code = code;
	     return;
	end;

	hndlquit_set = "0"b;
	string (mode_set) = "0"b;			/* nothing set yet */

	do modex = 1 to mcl.n_entries;
	     mclep = addr (mcl.entries (modex));
	     if mcle.mpx_mode			/* if this is one we're interested in */
	     then call process_mode (mcle.mode_name, mcle.mode_switch);
	end;

	if mcl.init
	then do;					/* if "init" we must turn off the ones that weren't mentioned */
	     if ^hndlquit_set
	     then call process_mode ("hndlquit", "0"b);

	     do modex = 1 to hbound (async_only_modes, 1);
		if ^mode_set (modex)
		then call process_mode (async_only_modes (modex), "0"b);
	     end;
	end;

	call unlock;
	a_code = code;
	return;



get_modes:
     entry (a_fnpp, a_subchan, a_modes, a_code);

/* this is a dummy, we don't keep records of modes at this level */

	a_modes = "";
	a_code = 0;
	return;

priv_control:
     entry (a_fnpp, a_order, a_data_ptr, a_code);

/* entry for privileged global orders */

	fnpp = a_fnpp;
	order = a_order;
	data_ptr = a_data_ptr;

	if order = "dump_fnp"
	then do;
	     call setup_fnp;
	     if code ^= 0
	     then do;
		a_code = code;
		return;
	     end;

	     locked = "0"b;
	     call send_global (dump_mem);
	     if code ^= 0
	     then go to end_dump_mem;

/* send_global will wait; come back here after notify */

	     n_fnp_words = dump_fnp_info.fnp_len;
	     dump_fnp_info.bufp -> fnp_data = fnp_dump_ptr -> fnp_data;

end_dump_mem:
	     if code ^= error_table_$timeout		/* else we have to abandon the buffer */
	     then call tty_space_man$free_space (dump_patch_space, fnp_dump_ptr);
						/* this was allocated by setup_fnp */
	     ignore = stacq (fnp_info.dump_patch_lock, "0"b, pds$processid);
	end;

	else if order = "get_meters"
	then do;
	     fnp_meterp = data_ptr -> get_comm_meters_info.subchan_ptr;
	     if fnp_meterp ^= null
	     then do;
		if fnp_meters.version ^= FNP_METERS_VERSION_2
		then code = error_table_$unimplemented_version;
		else do;
		     ttybp = addr (tty_buf$);		/* we'll need this */
		     call lock;
		     if code ^= 0
		     then do;
			a_code = code;
			return;
		     end;

		     call get_fnp_meters ("1"b);

		     if code = 0
		     then do;
			fnp_meters.n_channels = fnp_info.no_of_channels;
			fnp_meters.output_mbx_in_use_cum = fnp_info.cumulative_mbx_in_use;
			fnp_meters.output_mbx_updates = fnp_info.mbx_in_use_updated;
			fnp_meters.output_mbx_unavailable = fnp_info.mbx_unavailable;
			fnp_meters.max_output_mbx_in_use = fnp_info.max_mbx_in_use;
			fnp_meters.queue_entries_made = fnp_info.q_entries_made;
			fnp_meters.input_rejects = fnp_info.input_reject_count;
			fnp_meters.processed_from_q = fnp_info.processed_from_q;
			fnp_meters.fnp_channel_locked = fnp_info.fnp_channel_locked;
			fnp_meters.input_data_transactions = fnp_info.input_data_transactions;
			fnp_meters.output_data_transactions = fnp_info.output_data_transactions;
			fnp_meters.input_control_transactions = fnp_info.input_control_transactions;
			fnp_meters.output_control_transactions = fnp_info.output_control_transactions;
			fnp_meters.fnp_space_restricted_output = fnp_info.fnp_space_restricted_output;
			fnp_meters.fnp_mem_size = fnp_info.fnp_mem_size;
			begin;
declare  iom fixed bin (3);
declare  chan fixed bin (7);
			     call io_chnl_util$name_to_iom (fnp_info.io_chanid, iom, chan, (0));
			     fnp_meters.iom_number = iom;
			     fnp_meters.iom_chan_no = chan;
			end;

		     end;

		     call unlock;

		     if fnp_meters_ptr ^= null ()	/* let's make sure this is for real */
		     then do;
			data_ptr -> get_comm_meters_info.subchan_ptr -> fnp_meters.from_fnp =
			     fnp_meters_ptr -> fnp_global_meters;

			call tty_space_man$free_space (size (fnp_global_meters), fnp_meters_ptr);
		     end;

		     lctep = fnp_info.lcte_ptr;	/* since we don't call channel_manager, */
		     lcmp = data_ptr -> get_comm_meters_info.logical_chan_ptr;
						/* we have to copy logical channel data ourselves */
		     if lcmp ^= null ()
		     then do;
			lcmp -> logical_chan_meters.current_meters = lcte.meters;
			unspec (lcmp -> logical_chan_meters.saved_meters) = "0"b;
						/* no saved meters for an FNP */
		     end;
		end;
	     end;
	end;

	else code = error_table_$undefined_order_request;

	a_code = code;
	return;

hpriv_control:
     entry (a_fnpp, a_order, a_data_ptr, a_code);

/* entry for highly-privileged global orders */

	fnpp = a_fnpp;
	order = a_order;
	data_ptr = a_data_ptr;
	locked = "0"b;
	code = 0;

	if order = "patch_fnp"
	then do;
	     call setup_fnp;
	     if code ^= 0
	     then do;
		a_code = code;
		return;
	     end;
	     n_fnp_words = dump_fnp_data.fnp_len;
	     sourcep = dump_fnp_info.bufp;

	     fnp_dump_ptr -> fnp_data = sourcep -> fnp_data;
	     call syserr (ANNOUNCE, "fnp_multiplexer: patching FNP ^a for ^a:", fnp_info.fnp_tag, pds$process_group_id);
						/* tell operator about it */

	     temp_addr = dump_fnp_data.fnp_addr;
	     do i = 1 to dump_fnp_data.fnp_len;
		call syserr (ANNOUNCE, "^6w from ^6.3b to ^6.3b", temp_addr,
		     dump_fnp_info.old_value_ptr -> fnp_data (i), dump_fnp_info.bufp -> fnp_data (i));
		temp_addr = temp_addr + 1;
	     end;

	     call send_global (patch_mem);		/* send it off and wait */
	     if code ^= error_table_$timeout		/* else we have to abandon the buffer */
	     then call tty_space_man$free_space (dump_patch_space, fnp_dump_ptr);
						/* this was allocated by setup_fnp */
	     ignore = stacq (fnp_info.dump_patch_lock, "0"b, pds$processid);
	end;

	else if order = "fnp_break"
	then do;
	     call setup_fnp;
	     if code ^= 0
	     then do;
		a_code = code;
		return;
	     end;
	     fnp_break_data.action = fnp_break_info.action;
						/* copy info */
	     fnp_break_data.fnp_addr = fnp_break_info.fnp_addr;
	     fnp_break_data.flags = substr (fnp_break_info.flags, 1, 18);
	     name = fnp_break_info.chan_name;
	     if name = ""
	     then fnp_break_data.lineno = -1;		/* no line, i.e. any line */
	     else do;
		call name_to_pcb (name);
		if code ^= 0
		then do;
		     a_code = code;
		     return;
		end;
		fnp_break_data.lineno = bin (string (pcb.line_number));
	     end;

	     mbx_data = addr (fnp_break_data) -> based_bit72;
	     if ^locked
	     then call lock;
	     if code = 0
	     then do;
		call dn355$send_global_wcd (fnpp, fnp_break, 72, mbx_data);
		call unlock;
	     end;
	end;

	else if order = "enable_breakall_mode"
	then ;

	else if order = "disable_breakall_mode"
	then ;

	else code = error_table_$undefined_order_request;

hpriv_exit:
	a_code = code;
	return;

fnp_lock:
     entry (a_fnpp, a_code);				/* Non-wired lock entry */

	fnpp = a_fnpp;
	call lock;
	a_code = code;
	return;

fnp_unlock:
     entry (a_fnpp);

	fnpp = a_fnpp;
	mylock = "0"b;
	locked = "1"b;
	call unlock;
	return;

setup:
     proc;

/* initial setup for per-channel stuff */


	code = 0;					/* innocent until proven guilty */
	ttybp = addr (tty_buf$);
	infop = addr (dn355_data$);
	locked, queue_locked = "0"b;
	call lock;
	if code ^= 0
	then return;

	if fnp_info.running
	then pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (chanx));
	else do;
	     call unlock;
	     code = error_table_$mpx_down;
	     return;
	end;

	if pcb.copied_meters_ready			/* dn355 left them for us */
	then if ^lcte.locked_for_interrupt		/* make sure we're on call side */
	     then call save_copied_meters;

	return;
     end setup;



setup_fnp:
     proc;

dcl  (fnp_address, fnp_len) fixed bin (18);

/* this procedure is used instead of setup for privileged global orders */

	if fnpp = null ()
	then go to setup_fnp_down;
	code = 0;
	if fnp_info.mbx_pt = null ()			/* this one isn't configured */
	     | ^fnp_info.running			/* or it isn't up */
	then do;
setup_fnp_down:
	     code = error_table_$mpx_down;
	     return;
	end;

	ttybp = addr (tty_buf$);
	infop = addr (dn355_data$);

	if order = "fnp_break"
	then return;				/* done if break order */
	if fnp_info.dump_patch_disabled
	then do;
	     code = error_table_$timeout;
	     return;
	end;

	fnp_address = dump_fnp_info.fnp_address;
	fnp_len = dump_fnp_info.fnp_len;
	if order = "dump_fnp"
	then do;					/* check dump params */
	     if fnp_len <= 0 | fnp_len > 64
	     then do;
bad_fnp_len:
		code = error_table_$buffer_big;
		return;
	     end;
	end;
	else if order = "patch_fnp"
	then if fnp_len <= 0 | fnp_len > 32
	     then go to bad_fnp_len;

	if (fnp_address < 0) | ((fnp_address + fnp_len) > fnp_info.fnp_mem_size)
	then do;
	     code = error_table_$dev_offset_out_of_bounds;
	     return;
	end;

	if ^stac (addr (fnp_info.dump_patch_lock), pds$processid)
						/* lock the dump_patch function */
	then do;					/* if possible */
	     code = error_table_$seglock;
	     return;
	end;

	dump_patch_space = divide (fnp_len + 1, 2, 17, 0);
	call tty_space_man$get_space (dump_patch_space, fnp_dump_ptr);
	if fnp_dump_ptr = null			/* couldn't get the space */
	then do;
	     code = error_table_$noalloc;
	     ignore = stacq (fnp_info.dump_patch_lock, "0"b, pds$processid);
	     return;
	end;

	dump_patch_time = clock ();
	fnp_info.dump_patch_in_progress = "1"b;
	dump_fnp_data.abs_addr = bin (rel (fnp_dump_ptr)) + tty_buf.absorig;
						/* dump/patch is paged too ... */
	dump_fnp_data.fnp_addr = fnp_address;
	dump_fnp_data.fnp_len = fnp_len;
	return;

     end setup_fnp;

save_copied_meters:
     proc;

/* internal procedure called  to pick up copied meters left in tty_buf by FNP */

dcl  copied_meters_ptr ptr;

	if pcb.copied_meters_offset ^= 0		/* make sure it's legit */
	then do;
	     copied_meters_ptr = ptr (ttybp, pcb.copied_meters_offset);

/* zero out pad fields, which contain random junk (possibly input) from the FNP */

	     if pcb.sync_line
	     then copied_meters_ptr -> fnp_sync_meters.pad (*) = 0;
	     else copied_meters_ptr -> fnp_async_meters.pad (*) = 0;

	     pcb.saved_meters_ptr -> fnp_channel_meters = copied_meters_ptr -> fnp_channel_meters;
	     call tty_space_man$free_space (size (fnp_channel_meters), copied_meters_ptr);
						/* through with buffer now */
	     pcb.copied_meters_offset = 0;
	     pcb.copied_meters_ready = "0"b;
	end;

	return;
     end save_copied_meters;

process_mode:
     proc (mode_name, mode_on);

dcl  mode_name char (*);
dcl  mode_on bit (1);
dcl  mode_name_index fixed bin;

	alter_data = "00000000"b || mode_on;

	if mode_name = "hndlquit"
	then do;
	     alter_type = Hndlquit;
	     pcb.hndlquit = mode_on;
	     hndlquit_set = "1"b;
	end;

	else if ^pcb.sync_line			/* if we haven't already decided what to do */
	then do;
	     if mode_name = "blk_xfer" | mode_name = "iflow"
						/* special stuff here */
	     then do;
		if mode_name = "blk_xfer"
		then do;
		     mode_name_index = BLK_XFER_INDEX;
		     alter_type = Block_xfer;
		end;
		else do;
		     mode_name_index = IFLOW_INDEX;
		     alter_type = Input_flow_control;
		end;

		if mode_on
		then do;				/* we have to tell it buffer sizes */
		     chars_per_sec = divide (pcb.baud_rate, 10, 17, 0);
		     base_len, block_len = divide (chars_per_sec, buf_per_second, 17, 0);
						/* and 1/2 second thereafter */
		end;
		else do;
		     base_len = 56;
		     block_len = 0;
		end;

		alter_data = alter_data || bit (bin (base_len, 18), 18) || bit (bin (block_len, 18), 18);
		mode_set (mode_name_index) = "1"b;
	     end;

	     else do;
		do i = 1 to hbound (mode_alter_types, 1) while (mode_name ^= async_only_modes (i));
		end;				/* note that blk_xfer is the last async_mode */

		if i > hbound (mode_alter_types, 1)
		then code = error_table_$bad_mode;

		else do;
		     alter_type = mode_alter_types (i);
		     mode_set (i) = "1"b;		/* this one is set now */
		end;
	     end;
	end;

	if code = 0
	then do;
	     mbx_data = bit (bin (alter_type, 9), 9) || alter_data;
	     call dn355$send_wcd (fnpp, pcbp, alter_parameters, length (alter_data) + 9, mbx_data);
	end;
	return;
     end;

send_global:
     proc (opcode);

/* this procedure calls dn355$send_global_wcd for the dump_fnp and patch_fnp orders */

dcl  opcode fixed bin (8);

	call pxss$addevent (FNP_DUMP_PATCH_EVENT);	/* so we'll be able to wait */
	mbx_data = addr (dump_fnp_data) -> based_bit72;
	call lock;
	if code ^= 0
	then return;

	call dn355$send_global_wcd (fnpp, opcode, 72, mbx_data);
	call unlock;

	call pxss$wait;				/* mustn't do anything till it's done */

	do while (fnp_info.dump_patch_in_progress);	/* didn't complete yet */
	     if ^fnp_info.running			/* FNP crashed out from under us */
	     then do;
		code = error_table_$mpx_down;
		fnp_info.dump_patch_in_progress = "0"b; /* so we'll get out of loop */
	     end;

	     else if clock () - dump_patch_time > DUMP_PATCH_LIMIT
						/* time's up! */
	     then do;
		code = error_table_$timeout;		/* can this operation */
		fnp_info.dump_patch_disabled = "1"b;
		fnp_info.dump_patch_in_progress = "0"b;
		call syserr (ANNOUNCE, "fnp_multiplexer: ^[dump^;patch^]_fnp order to FNP ^a timed out.",
		     opcode = dump_mem, fnp_info.fnp_tag);
	     end;

	     else do;				/* must be someone else's notify */
		call pxss$addevent (FNP_DUMP_PATCH_EVENT);
		if fnp_info.dump_patch_in_progress	/* make sure it still hasn't happened */
		then call pxss$wait;
		else call pxss$delevent (FNP_DUMP_PATCH_EVENT);
						/* never mind, it's done */
	     end;

	end;

	return;					/* all right, we're done */

     end send_global;

get_fnp_meters:
     proc (global);

/* subroutine to issue request for meters from FNP and wait for them to arrive */

dcl  global bit (1) parameter;			/* indicates whether subchannel or whole FNP */
dcl  space_size fixed bin;
dcl  fnp_meter_wait_start fixed bin (71);

	if fnp_info.dump_patch_disabled
	then do;
	     code = error_table_$timeout;		/* don't even try */
	     fnp_meters_ptr = null ();		/* so caller won't try to free space */
	     return;
	end;

	if global
	then space_size = size (fnp_global_meters);
	else space_size = size (fnp_channel_meters);

	call tty_space_man$get_space (space_size, fnp_meters_ptr);
	if fnp_meters_ptr = null ()
	then do;
	     code = error_table_$noalloc;
	     return;
	end;

	mbx_data = bit (bin (tty_buf.absorig + bin (rel (fnp_meters_ptr)), 18), 18);
	call pxss$addevent (FNP_METER_EVENT);
	fnp_meter_wait_start = clock ();

	if global					/* it's for whole FNP */
	then do;
	     if fnp_info.get_meters_waiting
	     then do;
		code = error_table_$seglock;		/* can't have two going at once */
		return;
	     end;

	     fnp_info.get_meters_waiting = "1"b;
	     call dn355$send_global_wcd (fnpp, report_meters, 18, mbx_data);
	     pcbp = fnpp;				/* to avoid faults in loop test */
	end;

	else do;
	     pcb.get_meters_waiting = "1"b;
	     call dn355$send_wcd (fnpp, pcbp, report_meters, 18, mbx_data);
	end;

	call unlock;				/* while waiting */
	call pxss$wait;
	call lock;				/* while checking */

	do while ((global & fnp_info.get_meters_waiting) | (^global & pcb.get_meters_waiting));
	     if ^fnp_info.running
	     then do;
		code = error_table_$mpx_down;
		go to abort_get_meters;
	     end;

	     else if clock () - fnp_meter_wait_start > DUMP_PATCH_LIMIT
	     then do;
		code = error_table_$timeout;
		fnp_info.dump_patch_disabled = "1"b;
		call syserr (ANNOUNCE,
		     "fnp_multiplexer: get_meters order for FNP ^a^[^s^;, line ^o,^] timed out.", fnp_info.fnp_tag,
		     global, string (pcb.line_number));
abort_get_meters:
		if global
		then fnp_info.get_meters_waiting = "0"b;
		else pcb.get_meters_waiting = "0"b;
	     end;

	     else do;
		call unlock;			/* in case we wait some more */
		call pxss$addevent (FNP_METER_EVENT);
		if (global & fnp_info.get_meters_waiting) | (^global & pcb.get_meters_waiting)
						/* check if it happened since we checked */
		then call pxss$wait;
		else call pxss$delevent (FNP_METER_EVENT);
		call lock;
	     end;
	end;

	return;
     end get_fnp_meters;

name_to_pcb:
     proc (name);

dcl  name char (*);

	code = 0;
	call parse_tty_name_ (name, his_fnp_no, hsla_flag, la_no, subchan);
	call lock;
	if code ^= 0
	then return;

	if his_fnp_no ^= fnp_info.fnp_number
	then go to bad_device;

	if hsla_flag
	then pcbx = fnp_info.hsla_idx (la_no);
	else pcbx = fnp_info.lsla_idx (la_no);
	if pcbx = -1
	then go to bad_device;

	found, past = "0"b;
	do j = pcbx to fnp_info.no_of_channels while (^past & ^found);
	     pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (j));
	     if pcb.la_no ^= bit (bin (la_no, 3), 3)
	     then past = "1"b;
	     else if pcb.slot_no = bit (bin (subchan, 6), 6)
	     then found = "1"b;
	end;

	if ^found
	then do;
bad_device:
	     call unlock;
	     code = error_table_$bad_channel;
	     return;
	end;

	return;
     end name_to_pcb;

lock:
     proc;

/* subroutine to lock the mailbox lock (which incidentally protects PCBs too) */

	if fnpp = null ()
	then do;
	     code = error_table_$mpx_down;
	     return;
	end;

	code = 0;

	lctep = fnp_info.lcte_ptr;
	if lcte.lock = pds$processid			/* called as result of our own interrupt? */
	then if lcte.locked_for_interrupt
	     then mylock = "1"b;			/* remember not to unlock it */
	     else call syserr (CRASH_SYSTEM, "fnp_multiplexer: mylock error");
	else do;
	     mylock = "0"b;
	     call tty_lock$lock_lcte (lctep, code);
	     locked = (code = 0);
	end;
	return;
     end lock;



unlock:
     proc;

/* subroutine to release mailbox lock and process queued interrupts */

	if locked
	then if ^mylock
	     then do;

		call dn355$process_interrupt_queue ((fnp_info.fnp_number));
		locked = "0"b;			/* it unlocks the channel lock when it's done */

	     end;
	return;

     end unlock;


fnp_buf_size:
     proc returns (bit (18));

/* internal procedure returns correct buffer size for FNP to use, based on baud rate
   *  and synchronous/asynchronous
*/

	do i = 1 to n_sync_line_types while (pcb.line_type ^= sync_line_type (i));
	end;

	if i <= n_sync_line_types
	then do;
	     pcb.sync_line = "1"b;
	     chars_per_buf = divide (divide (pcb.baud_rate, 8, 17, 0), buf_per_second, 17, 0);
	end;

	else do;
	     pcb.sync_line = "0"b;
	     chars_per_buf = 56;			/* always minimum for asynchronous */
	end;

	return (bit (bin (chars_per_buf, 18), 18));
     end fnp_buf_size;


/**** Wired entrypoints to talk to io_manager for both fnp_multiplexer
      and the fnp_util TandD code. These should be called under
      the FNP lcte lock. */

declare  a_fnp_no fixed bin;
declare  fnp_no fixed bin;

assign:
     entry (a_fnp_no, a_code);

	infop = addr (dn355_data$);
	call TRACE ("assign");
	fnp_no = a_fnp_no;
	fnpp = addr (datanet_info.per_datanet (fnp_no));
	call assign_channel (code);
	a_code = code;
	return;


unassign:
     entry (a_fnp_no, a_code);

	fnp_no = a_fnp_no;
	infop = addr (dn355_data$);
	call TRACE ("unassign");
	fnpp = addr (datanet_info.per_datanet (fnp_no));

	call unassign_channel (code);
	a_code = code;
	return;


assign_channel:
     procedure (code);
declare  code fixed bin (35);

	code = 0;
	if ^fnp_info.available
	then do;
	     code = error_table_$io_not_configured;	/* "not available" */
	     go to assign_channel_return;
	end;

	if fnp_info.io_manager_assigned
	then do;
	     code = error_table_$io_assigned;
	     go to assign_channel_return;
	end;

	call io_manager$assign (fnp_info.io_manager_chx, fnp_info.io_chanid, dn355$interrupt, (fnp_info.fnp_number),
	     (null ()), code);
	fnp_info.io_manager_assigned = (code = 0);
assign_channel_return:
	if datanet_info.trace | datanet_info.debug_stop
	then call syserr (ANNOUNCE, "fnp_multiplexer$assign_channel: Assignment of FNP ^a ^[succeeded^;failed^].",
		fnp_info.fnp_tag, (code = 0));
	if code ^= 0
	then call TRACE_ERROR ("assign_channel", code);
	return;
     end assign_channel;

unassign_channel:
     procedure (code);
declare  code fixed bin (35);


	if ^fnp_info.io_manager_assigned
	then do;
	     code = error_table_$io_not_assigned;
	     go to unassign_return;
	end;
	call io_manager$unassign (fnp_info.io_manager_chx, code);
	if code = 0
	then fnp_info.io_manager_assigned = "0"b;
unassign_return:
	if datanet_info.trace | datanet_info.debug_stop
	then call syserr$error_code (ANNOUNCE, code,
		"fnp_multiplexer$unassign_channel: Unassignment of FNP ^a ^[failed^;succeeded^].", fnp_info.fnp_tag,
		(code ^= 0));
	if code ^= 0
	then call TRACE_ERROR ("unassign_channel", code);
	return;
     end unassign_channel;

TRACE:
     procedure (Entry);

declare  Entry char (32);

	if datanet_info.trace
	then call syserr (ANNOUNCE, "fnp_multiplexer$^a: Tracing call.", Entry);
	return;



TRACE_ERROR:
     entry (Entry, Code);

declare  Code fixed bin (35);

	if datanet_info.trace | datanet_info.debug_stop
	then call syserr$error_code (ANNOUNCE, Code, "fnp_multiplexer$^a: Tracing error.", Entry);
	if datanet_info.debug_stop
	then call syserr (CRASH_SYSTEM, "fnp_multiplexer: debugging stop (type go to continue).");
	return;
     end TRACE;

/* BEGIN MESSAGE DOCUMENTATION

   Message:
   fnp_multiplexer: patching FNP X for USER:
   ADDR from XXX to YYY

   S:	$info

   T:	$run

   M:	The memory of FNP X is being patched by the privileged
   user whose user_id is USER. ADDR is the absolute location in FNP memory that is being
   patched (in octal); XXX and YYY are the old and new values of the location
   respectively (also in octal).
   The second line may be repeated (with different values) if more than one word
   is being patched.

   A:	This information is for logging purposes.


   Message:
   fnp_multiplexer: mylock error

   S:	$crash

   T:	$run

   M:	An attempt has been made to lock an FNP channel lock to a process
   that already has it locked.

   A:	$inform


   Message:
   fnp_multiplexer: NAME order to FNP X timed out.

   S:	$info

   T:	$run

   M:	NAME is "get_meters", "dump_fnp", or "patch_fnp". The named order to
   FNP X failed to complete within 10 seconds. The buffer space associated
   with the order has been abandoned, and get_meters, dump, and patch orders
   to that FNP are disabled until the FNP is reloaded.

   A:	$inform


   Message:
   fnp_multiplexer: get_meters order for FNP X, line N, timed out.

   S:     $info

   T:     $run

   M:     A get_meters order for line N of FNP X failed to complete within 10
   seconds. The buffer space associated with the order has been abandoned, and
   get_meters, dump, and patch orders to that FNP are disabled until the FNP
   is reloaded.


   Message:
   fnp_multiplexer$shutdown: Failed to unwire fnp. ERROR.

   S:	$info

   T:	$run

   M:	An attempt to unwire the pages used for I/O to an FNP failed at FNP
   shutdown. ERROR contains the message derived from a standard system error
   code.

   A:	$inform


   Message:
   fnp_multiplexer$shutdown: Called with null fnp_ptr

   S:	$info

   T:	$run

   M:	A call was made to the shutdown entry with a null pointer to
   fnp_info. This message only appears if tracing is enabled for the specified
   FNP. 

   A:	$inform


   Message:
   fnp_multiplexer$shutdown: Called with FNP wired.

   S:	$info

   T:	$run

   M:	A call was made to the shutdown entry while the pages for I/O for an
   FNP were still wired.
   This message only appears if tracing is enabled for the specified FNP.

   A:	none required.


   Message:
   fnp_multiplexer$assign_channel: Assignment of FNP X {succeeded | failed}.

   S:	$info

   T:	$run

   M:	Indicates the result of a call to io_manager$assign for FNP X.
   This message only appears if tracing is enabled for the specified FNP.

   A:	none required.


   Message:
   fnp_multiplexer$unassign_channel: Unassignment of FNP X {succeeded | failed}.

   S:	$info

   T:	$run

   M:	Indicates the result of a call to io_manager$unassign for FNP X.
   This message only appears if tracing is enabled for the specified FNP.

   A:	none required.


   Message:
   fnp_multiplexer$ENTRY: Tracing call.

   S:	$info

   T:	$run

   M:	A call was made to the ENTRY entry.
   This message only appears if tracing is enabled for the specified FNP.

   A:	none required.


   Message:
   fnp_multiplexer$ENTRY: Tracing error. ERROR.

   S:	$info

   T:	$run

   M:	The error code represented by ERROR was encountered by ENTRY.
   This message only appears if tracing is enabled for the specified FNP.

   A:	none required.


   Message:
   fnp_multiplexer: debugging stop (type go to continue).

   S:	$crash

   T:	$run

   M:	An error has been encountered in setting up an FNP, and debugging
   mode is turned on.

   A:	Use BCE commands to analyze the condition, if necessary; type "go"
   to resume system operation.

   END MESSAGE DOCUMENTATION */



     end fnp_multiplexer;
