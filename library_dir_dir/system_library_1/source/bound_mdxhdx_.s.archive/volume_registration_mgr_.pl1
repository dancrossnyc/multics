/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(85-07-10,EJSharpe), approve(86-02-20,MCR7304),
     audit(86-03-27,CLJones), install(86-04-23,MR12.0-1044):
     added get_access_for_attach entrypoint in order for
     rcp_attach_lv_ to perform security auditing
     The two "get_access" entries should be merged into
     an access kernel for MDC and LV mgmt.
                                                   END HISTORY COMMENTS */


/* format: style1,insnl,linecom,indcomtxt,^inddcls,^indnoniterdo */

volume_registration_mgr_:
vrm_:
     proc;

/* Logical Volume Registration Guts.

   This program knows where the volume registration data for
   logical volumes is kept.

   It contain entries called by the volume_registration_cmds_
   and service entries called by many other programs.

   The whole program runs in ring 1.

   Written by T. H. VanVleck
   Modified July 1981 by J. Bongiovanni to validate lvx.
   Modified 83-12-06 BIM to use RCP privilege to circumvent AIM.
   Modified 83-12-07 BIM to update disk table from vol registration.
   Modified 84-08-21 by EJ Sharpe
   This module used to be named "hdx".
   removed entries: read_hv, read_pv, write_hv, delete_hv, make_link,
   and chname_hv.  Replaced with add_lvr, add_pvr, read_lvr, read_pvr,
   change_lvr, change_pvr, delete_lvr, and delete_pvr.  These entries
   do their own work (don't rely on ring 4 caller) and now set a lock
   while changing the database.  Also, added auditing of database
   changes, removed ACS link hack, changed module name to
   volume_registration_mgr_, and generally improved the code.  (This
   was all in order to move the registration commands from the operator
   interface to the system administrator's - for B2.)
   One more thing - fixed hardcore error #643 - LV access now not
   dependant on AIM and ring brackets of ACS.
   Modified 84-10-31 by EJ Sharpe for some misc upgrades and change get_access
   entry to return bit (36) modes instead of fixed bin (5).
   Modified 84-12-17 by EJ Sharpe for fixes:
   1) use currentsize instead of size in reference to volume_registration
   2) attempt delete of MDCS before deleting registration data file
   3) use hcs_$get_user_raw_mode for LV access computation
   Modified 84-12-27 by Keith Loepere for version 2 create_branch_info.
   Modified 85-01-18 by EJ Sharpe for handling unexpected conditions properly
   in a ring 1 process (e.g. Dumper)
*/
%page;
/* PARAMETERS */

dcl     a_lvname		 char (*);		/* Logical Volume name */
dcl     a_lv_access_class_range
			 (2) bit (72) aligned;	/* returned from get_access_for_attach */
dcl     a_dtp		 ptr;			/* disk_table ptr */
dcl     a_ptr		 ptr;			/* ptr to volume_registration or pv_registration */
dcl     a_ec		 fixed bin (35);		/* error code */
dcl     a_pvname		 char (*);		/* Physical Volume name */
dcl     a_device_type	 fixed bin;		/* model of disk drive */
dcl     a_lvid		 bit (36);		/* Logical volume uid */
dcl     a_pvid		 bit (36);		/* Physical volume ID (input) */
dcl     a_level		 fixed bin (3);		/* validation level (input) */
dcl     a_mode		 bit (36) aligned;		/* effective mode (output) */
dcl     a_pub_bit		 bit (1) aligned;		/* volume is public (output) */
dcl     a_pvap		 ptr;			/* ptr to pva (input) */
dcl     a_npv		 fixed bin;		/* number returned (output) */
dcl     a_lvx		 fixed bin;		/* logical volume index (in disk_table) */
dcl     a_dtep		 ptr;			/* disk_table entry ptr */
dcl     a_dn		 char (*);		/* dir name */
dcl     a_dn2		 char (*);		/* dir name */


/* AUTOMATIC */

dcl     MYNAME		 char (65) init ("");	/* first thing set by each entry */
dcl     lvid_changed	 bit (1);			/* flag used by change-lvr */
dcl     pvid_changed	 bit (1);			/* flag used by change_pvr */
dcl     lvid		 bit (36) aligned;		/* temp */
dcl     old_lvid		 bit (36) aligned;		/* used by change_lvr */
dcl     new_lvid		 bit (36) aligned;		/* used by change_lvr */
dcl     pvid		 bit (36) aligned;		/* temp */
dcl     old_pvid		 bit (36) aligned;		/* used by change_pvr */
dcl     new_pvid		 bit (36) aligned;		/* used by change_pvr */
dcl     uname		 char (32);		/* unique name temp */
dcl     uname2		 char (32);		/* unique name temp */
dcl     old_uname		 char (32);		/* used by change_(lvr pvr) */
dcl     new_uname		 char (32);		/* used by change_(lvr pvr) */
dcl     pvname		 char (32);		/* temp */
dcl     old_pvname		 char (32);		/* used by change_pvr */
dcl     new_pvname		 char (32);		/* used by change_pvr */
dcl     lvname		 char (32);		/* temp */
dcl     old_lvname		 char (32);		/* used by change_lvr */
dcl     new_lvname		 char (32);		/* used by change_lvr */
dcl     old_aa_str		 char (168);		/* access auth string used by change_lvr */
dcl     new_aa_str		 char (168);		/* access auth string used by change_lvr */
dcl     old_dt_reg		 char (24);		/* date-time string used by change_pvr */
dcl     new_dt_reg		 char (24);		/* date-time string used by change_pvr */
dcl     level		 fixed bin;
dcl     npvrp		 ptr;			/* pointer to new pv_reg struct */
dcl     nvrp		 ptr;			/* pointer to new vol_reg struct */
dcl     upvrp		 ptr;			/* pointer to user's pv_reg struct */
dcl     uvrp		 ptr;			/* pointer to user's vol_reg struct */
dcl     tsegp		 ptr init (null);		/* pointer to temporary seg */
dcl     databasep		 ptr init (null);		/* pointer to volume registration database */
dcl     dn		 char (168);		/* Volume registration DB dir */
dcl     en		 char (32);		/* Volume registration DB entry */
dcl     mode		 bit (36) aligned;		/* access mode */
dcl     type		 fixed bin (2);		/* entry type */
dcl     bc		 fixed bin (24);		/* bit count */
dcl     (i, j)		 fixed bin;		/* index vars */
dcl     owner		 char (32);		/* Person.Project of vol owner */
dcl     (proj, oproj)	 char (9);		/* temps for access check */
dcl     (pers, opers)	 char (22);		/* temps for access check */
dcl     old_level		 fixed bin init (-1);
dcl     ec		 fixed bin (35);		/* error code */
dcl     ec2		 fixed bin (35);		/* error code */
dcl     make_lve		 bit (1);			/* flag for lvname_info/ get_lv_pvinfo */
dcl     auth_mnemonics	 char (172);		/* string to hold human readable form of AIM stuff */
dcl     temp_str		 char (512);		/* temp area for formatting strings */
dcl     tstr_len		 fixed bin (21);		/* length of formatted strings */
dcl     pub_bit		 bit (1) aligned;		/* used in get_access */
dcl     set_access_range	 bit (1) aligned;		/* indicator for get_access/get_access_for_attach entries */

dcl     access_class_range	 (2) bit (72) aligned init ("0"b, sys_info$access_class_ceiling);

dcl     1 aa		 aligned,			/* access for lv.** segs */
	2 name		 char (32) init ("*.*.*"),
	2 mode		 bit (36) init ("101"b),
	2 mbz		 bit (36) init ((36)"0"b),
	2 code		 fixed bin (35);

dcl     1 dacl		 aligned,			/* access for >lv */
	2 name		 char (32) init ("*.SysAdmin.*"),
	2 mode		 bit (36) init ("111"b),
	2 code		 fixed bin (35);

dcl     1 CBI		 aligned like create_branch_info;


/* STATIC */

dcl     testing		 bit (1) static init ("0"b);

dcl     sdtp		 ptr static init (null);
dcl     first		 bit (1) static init ("1"b);

dcl     PRIV		 (0:1) char (8) static options (constant) init ("private", "public");
dcl     LVNAME_LEGAL	 char (76) int static options (constant) init
						/* Valid characters for LV names. */
			 (" '_`~^+-.{}:!0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
dcl     PVNAME_LEGAL	 char (37) int static options (constant) init
			 ("0123456789abcdefghijklmnopqrstuvwxyz_");
dcl     PV		 bit (1) static init ("0"b) options (constant);
dcl     LV		 bit (1) static init ("1"b) options (constant);
dcl     INIT		 bit (1) static init ("0"b) options (constant);
dcl     DONT_INIT		 bit (1) static init ("1"b) options (constant);
dcl     SMALL_DT		 fixed bin (71) static options (constant) init (2019686401000000);
						/* 01/01/65 00:00:01 */

dcl     ROOT		 char (168) static init (">lv");
						/* may be changed by "test" entrypoint */
dcl     LV_DIR		 char (168) static init (">lv");
						/* may be changed by "test" entrypoint */

dcl     (REAL_LV_DIR)	 char (168) static init (">lv") options (constant);


/* MISC */

dcl     sys_info$access_class_ceiling
			 bit (72) aligned external;

dcl     (cleanup, any_other)	 condition;

dcl     (addr, baseno, clock, currentsize, fixed, hbound, index, lbound, length, null, rtrim, string, substr, unspec,
        verify)		 builtin;


/* ERROR CODES */

dcl     error_table_$improper_data_format
			 fixed bin (35) ext;
dcl     error_table_$unimplemented_version
			 fixed bin (35) ext;
dcl     error_table_$action_not_performed
			 fixed bin (35) ext;
dcl     error_table_$argerr	 fixed bin (35) ext;
dcl     error_table_$bad_segment
			 fixed bin (35) ext;
dcl     error_table_$unregistered_volume
			 fixed bin (35) ext;
dcl     error_table_$fatal_error
			 fixed bin (35) ext;
dcl     error_table_$bad_volid fixed bin (35) ext;
dcl     error_table_$incorrect_device_type
			 fixed bin (35) ext;
dcl     error_table_$segknown	 fixed bin (35) ext;
dcl     error_table_$segnamedup
			 fixed bin (35) ext;
dcl     error_table_$namedup	 fixed bin (35) ext;
dcl     error_table_$bad_arg	 fixed bin (35) ext;
dcl     error_table_$unexpected_condition
			 fixed bin (35) ext;


/* ENTRIES */

dcl     aim_check_$in_range	 entry (bit (72) aligned, (2) bit (72) aligned) returns (bit (1));
dcl     aim_check_$greater_or_equal
			 entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
dcl     ioa_$general_rs	 entry (ptr, fixed bin, fixed bin, char (*), fixed bin (21), bit (1) aligned,
			 bit (1) aligned);
dcl     admin_gate_$syserr	 entry () options (variable);
dcl     admin_gate_$syserr_error_code
			 entry () options (variable);
dcl     admin_gate_$reclassify_sys_seg
			 entry (char (*), char (*), bit (72) aligned, fixed bin (35));
dcl     display_access_class_	 entry (bit (72) aligned) returns (char (32) aligned);
dcl     date_time_$format	 entry (char (*), fixed bin (71), char (*), char (*)) returns (char (250) var);
dcl     get_temp_segment_	 entry (char (*), ptr, fixed bin (35));
dcl     get_ring_		 entry () returns (fixed bin (3));
dcl     get_initial_ring_	 entry () returns (fixed bin);
dcl     release_temp_segment_	 entry (char (*), ptr, fixed bin (35));
dcl     vrm_lock_$vrm_data_init
			 entry ();
dcl     vrm_lock_$lock	 entry (fixed bin (35));
dcl     vrm_lock_$cleanup	 entry ();
dcl     cu_$arg_list_ptr	 entry (ptr);
dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
dcl     cu_$level_get	 entry (fixed bin);
dcl     cu_$level_set	 entry (fixed bin);
dcl     com_err_		 entry () options (variable);
dcl     continue_to_signal_	 entry (fixed bin (35));
dcl     expand_path_	 entry (ptr, fixed bin (21), ptr, ptr, fixed bin (35));
dcl     expand_pathname_	 entry (char (*), char (*), char (*), fixed bin (35));
dcl     pathname_		 entry (char (*), char (*)) returns (char (168));
dcl     mdc_repair_$make_mdcs	 entry (char (*), bit (36) aligned, fixed bin (35));
dcl     mdc_repair_$update_lvid
			 entry (char (*), bit (36) aligned, bit (36) aligned, fixed bin (35));
dcl     mdc_repair_$rename_mdcs
			 entry (char (*), bit (36) aligned, char (*), fixed bin (35));
dcl     mdc_repair_$delete_mdcs
			 entry (char (*), bit (36) aligned, fixed bin (35));
dcl     mdc_repair_$recreate_mdcs
			 entry (char (*), bit (36) aligned, fixed bin (35));
dcl     mdc_init_		 entry ();
dcl     get_authorization_	 entry () returns (bit (72) aligned);
dcl     get_privileges_	 entry () returns (bit (36) aligned);
dcl     get_group_id_	 entry () returns (char (32));
dcl     hcs_$replace_acl	 entry (char (*), char (*), ptr, fixed bin, bit (1), fixed bin (35));
dcl     hcs_$append_link	 entry (char (*), char (*), char (*), fixed bin (35));
dcl     hcs_$chname_seg	 entry (ptr, char (*), char (*), fixed bin (35));
dcl     hcs_$create_branch_	 entry (char (*), char (*), ptr, fixed bin (35));
dcl     hcs_$get_user_raw_mode entry (char (*), char (*), char (*), bit (36) aligned, fixed bin (35));
dcl     delete_$path	 entry (char (*), char (*), bit (36) aligned, char (*), fixed bin (35));
dcl     delete_$ptr		 entry (ptr, bit (36) aligned, char (*), fixed bin (35));
dcl     hcs_$add_dir_acl_entries
			 entry (char (*), char (*), ptr, fixed bin, fixed bin (35));
dcl     hcs_$initiate	 entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
dcl     hcs_$make_seg	 entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
dcl     hcs_$set_bc_seg	 entry (ptr, fixed bin (24), fixed bin (35));
dcl     hcs_$set_damaged_sw	 entry (char (*), char (*), bit (1), fixed bin (35));
dcl     hcs_$set_damaged_sw_seg
			 entry (ptr, bit (1), fixed bin (35));
dcl     hphcs_$set_rpv	 entry (char (*), char (*), fixed bin (35));
dcl     hcs_$status_minf	 entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24), fixed bin (35));
dcl     hcs_$terminate_noname	 entry (ptr, fixed bin (35));
dcl     hcs_$truncate_seg	 entry (ptr, fixed bin (19), fixed bin (35));
dcl     read_allowed_	 entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
dcl     write_allowed_	 entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
dcl     unique_chars_	 entry (bit (*)) returns (char (15));
dcl     convert_access_class_$to_string_short
			 entry (bit (72) aligned, char (*), fixed bin (35));
%page;
/* ===================================================== */

/* INIT - Entry called during system initialization to get set up. */
/*          Salvaging, if necessary, is done later by mdx$init. */

init:
     entry (a_dtp);					/* Called from mdx */

/**** **************************************************************************

      This entry is called at system initialization time by mdx$init (which is
      invoked by disk_table_$init just prior to ring-1 initializer command level).
      This "init" entry simply saves a copy of the disk_table points for later
      use, sets up its lock segment >sl1>vrm_data, and calls mdc_init_ (which
      simply sets up the lock segment for Master Directory Control).

      ************************************************************************** ****/

	MYNAME = "volume_registration_mgr_$init";

	sdtp = a_dtp;				/* Save ptr to disk_table */
	call hcs_$set_damaged_sw_seg (sdtp, "0"b, (0));	/* We will salvage */
	call vrm_lock_$vrm_data_init ();		/* set up lock seg */
	call mdc_init_;				/* get master directory control going */

	return;
%page;

/* ===================================================== */
/* Primitive entry points to read and write volume registration segments.

   read_lvr
   read_pvr
   add_lvr
   add_pvr
   delete_lvr
   delete_pvr
   change_lvr
   change_pvr

   These entries are called through mdc_priv_ from volume_registration_cmds_ */
/* ===================================================== */



/* READ_LVR - Entry to return registration database for given LV */

read_lvr:
     entry (a_lvname, a_ptr, a_ec);

/**** **************************************************************************

      Reads the LV registration data, including the data for all
      PVs belonging to that LV, into a place provided by the caller.
      The caller supplies the PV name.

      ************************************************************************** ****/

	MYNAME = "volume_registration_mgr_$read_lvr";

	on any_other call emergency_exit;
	on cleanup call clean_up;

/* COPY ARGS */
	lvname = a_lvname;
	uvrp = a_ptr;

	call locate_ (lvname, LV, INIT);		/* Parse name */

	uvrp -> volume_registration = volume_registration;/* Copy whole seg to user ring */

	ec = 0;
	goto EXIT;
%page;


/* READ_PVR - Entry to return data structure for given PV */

read_pvr:
     entry (a_pvname, a_ptr, a_ec);			/* Same thing given pvname */

/**** **************************************************************************

      Reads the PV registration data for a single PV into a place provided by the
      caller.  The caller supplies the PV name.

      ************************************************************************** ****/

	MYNAME = "volume_registration_mgr_$read_pvr";

	on any_other call emergency_exit;
	on cleanup call clean_up;

/* COPY ARGS */
	pvname = a_pvname;
	upvrp = a_ptr;

	call locate_ (pvname, PV, INIT);		/* Parse name */

	do i = 1 to volume_registration.npv;
	     if volume_registration.pv (i).pvname = pvname
	     then do;
		ec = 0;
						/* copy PV entry into user ring structure */
		upvrp -> pv_registration = volume_registration.pv (i);
		goto EXIT;
	     end;
	end;

	ec = error_table_$bad_segment;
	call announce_syserr ("PV entry missing from database ""pv.^a"".", pvname);

	goto EXIT;
%page;


/* ADD_LVR - Entry to create a registration database for a new LV */

add_lvr:
     entry (a_lvname, a_ptr, a_ec);

/**** **************************************************************************

      Adds a new registration data segment to the volume registration database.  The
      caller provides a volume_registration structure containing the LV attributes
      and the attributes for a single PV.  The structure is the same as that used
      for the ring-1 data segment.  If all validation passes, the caller's structure
      is copied into a new segment names "lv.LVNAME".  Three addnames are added to
      the segment corresponding to the LVID, PVNAME, and PVID.  This entry is not
      used for creating the RLV registration.  RLV registration is done during
      system initialization by the entry "check_volume_registration".  The Master
      Directory Control entry "create_mdcs" is called to create its data segment
      which corresponds to the LV registratoin data segment.

      The code is implemented like:

      entry
      setup
      copy args
      lock database
      check caller's LV and PV registration data
      check existance of LV and PV already in database
      make a new segment in database for this LV
      {if anything goes wrong after this, delete the new segment}
      copy caller's data into database
      add proper names to new segment
      call MDC to create its database for the new LV
      create proper database links if necessary
      cleanup
      exit

      ************************************************************************** ****/

	MYNAME = "volume_registration_mgr_$add_lvr";

	on any_other call emergency_exit;
	on cleanup call clean_up;

/* COPY ARGS */
	lvname = a_lvname;
	uvrp = a_ptr;
	call get_tseg;				/* place to copy user structure */
	vrp = tsegp;
						/* we'll check to make sure number of entries is correct
						   before attempting to copy the beast into our ring.
						   It'll be checked again after copying the structure
						   by "check_new_lv" */
	if uvrp -> volume_registration.npv ^= 1
	then do;
	     ec = error_table_$bad_arg;
	     goto EXIT;
	end;
	volume_registration = uvrp -> volume_registration;

/* Verify consistancy of arguments */
	if verify (lvname, LVNAME_LEGAL) ^= 0 | volume_registration.lvname ^= lvname
	then do;
	     ec = error_table_$argerr;
	     goto EXIT;
	end;

	call vrm_lock_$lock (ec);
	if ec ^= 0
	then goto EXIT;

	call check_new_lv (vrp);
	call check_new_pv (addr (volume_registration.pv (1)));

	if name_exists (LV_DIR, "lv." || lvname) |
	     name_exists (LV_DIR, "lvid." || unique_chars_ ((volume_registration.lvid))) |
	     name_exists (LV_DIR, "pv." || volume_registration.pv (1).pvname) |
	     name_exists (LV_DIR, "pvid." || unique_chars_ ((volume_registration.pv (1).pvid)))
	then do;
	     ec = error_table_$namedup;
	     goto EXIT;
	end;

	call locate_ (lvname, LV, DONT_INIT);		/* Just parse th name */
	call hcs_$make_seg (dn, en, "", 1010b, databasep, ec);
						/* Create new lv seg */
	if ec ^= 0
	then goto EXIT;
	nvrp = databasep;

	call hcs_$replace_acl (dn, en, addr (aa), 1, "0"b /* SysDaemon OK */, ec);
	if ec ^= 0
	then goto REMOVE_NEW_LV;

	call admin_gate_$reclassify_sys_seg (dn, en, sys_info$access_class_ceiling, ec);
	if ec ^= 0
	then goto REMOVE_NEW_LV;

	nvrp -> volume_registration = volume_registration;/* Copy whole structure */
	vrp = nvrp;				/* Now refer to the new copy */
	pvrp = addr (volume_registration.pv (1));	/* ... and to the only PV */

/* If any of the following operations fail we'll back out
   the new LV simply by deleting its database */

	uname = "lvid." || unique_chars_ ((volume_registration.lvid));
	call hcs_$chname_seg (vrp, "", uname, ec);
	if ec ^= 0
	then goto REMOVE_NEW_LV;
	call hcs_$chname_seg (vrp, "", "pv." || pv_registration.pvname, ec);
	if ec ^= 0
	then goto REMOVE_NEW_LV;
	uname2 = "pvid." || unique_chars_ ((pv_registration.pvid));
	call hcs_$chname_seg (vrp, "", uname2, ec);
	if ec ^= 0
	then goto REMOVE_NEW_LV;

	call mdc_repair_$make_mdcs (lvname, volume_registration.lvid, ec);
	if ec ^= 0
	then goto REMOVE_NEW_LV;

	call log_it ("Added new LV ""^a"".", lvname);
	call log_it ("Added new PV ""^a"" to LV ""^a"".", volume_registration.pv (1).pvname, lvname);

	if dn ^= LV_DIR
	then do;
						/* add links */
	     call hcs_$append_link (LV_DIR, en, pathname_ (dn, en), ec);
	     if ec ^= 0
	     then call announce_syserr_code (ec, "Could not append link for LV name.");
	     call hcs_$append_link (LV_DIR, uname, pathname_ (dn, uname), ec);
	     if ec ^= 0
	     then call announce_syserr_code (ec, "Could not append link for LVID.");
	     call hcs_$append_link (LV_DIR, "pv." || pv_registration.pvname,
		pathname_ (dn, "pv." || pv_registration.pvname), ec);
	     if ec ^= 0
	     then call announce_syserr_code (ec, "Could not append link for PV name.");
	     call hcs_$append_link (LV_DIR, uname2, pathname_ (dn, uname2), ec);
	     if ec ^= 0
	     then call announce_syserr_code (ec, "Could not append link for PVID.");
	end;

	ec = 0;					/* success! */

	goto EXIT;


REMOVE_NEW_LV:					/* come to this point if something went wrong
						   in the middle of new database creation.  */

	string (delete_options) = ""b;
	delete_options.force = "1"b;
	delete_options.segment = "1"b;
	delete_options.raw = "1"b;
	call delete_$ptr (nvrp, string (delete_options), "", ec2);
	if ec2 ^= 0
	then
	     call announce_syserr_code (ec2, "Unable to back out database ""lv.^a"".", lvname);
	else databasep = null ();			/* be nice to our clean_up handler */
	goto EXIT;
%page;


/* ADD_PVR - Entry to add a new PV entry to an existing LV */

add_pvr:
     entry (a_lvname, a_ptr, a_ec);

/**** **************************************************************************

      This entry adds the registration data for a single PV to an existing LV
      registration data segment.  If all attributes in the given pv_registration
      structure are valid, it is added to the end of the "pv" array in the LV data
      segment.  Two addnames are appended to the LV registration data segment entry
      corresponding to the PV name and PVID.  If the LV registration data segment is
      in ">", two links are created in ">lv" corresponding to these two new
      addnames.

      The code is implemented like:

      entry
      setup
      copy args
      check caller's registration data for new PV
      lock database
      check existance of PV already in database
      find proper LV data segment for this new PV
      search LV data for PV already exists (DB consistancy check)
      copy caller's PV data into database
      add proper names to LV data segment
      bump LV's number of PV's (to include new PV data)
      add proper database links if necessary
      cleanup
      exit

      ************************************************************************** ****/

	MYNAME = "volume_registration_mgr_$add_pvr";

	on any_other call emergency_exit;
	on cleanup call clean_up;

/* COPY ARGS */
	lvname = a_lvname;
	upvrp = a_ptr;
	call get_tseg;				/* place to copy user's structure */
	pvrp = tsegp;
	pv_registration = upvrp -> pv_registration;

	call check_new_pv (pvrp);

	call vrm_lock_$lock (ec);
	if ec ^= 0
	then goto EXIT;

/* Check to see if there's already a database with this name */
	uname = "pvid." || unique_chars_ ((pv_registration.pvid));
	if name_exists (LV_DIR, "pv." || pv_registration.pvname) | name_exists (LV_DIR, uname)
	then do;
	     ec = error_table_$namedup;
	     goto EXIT;
	end;

	call locate_ (lvname, LV, INIT);

/* we've already checked for its existance above, here we'll
   double check to make sure there's no record with the pvname
   already in the file.	*/
	do i = 1 to volume_registration.npv while (volume_registration.pv (i).pvname ^= pv_registration.pvname);
	end;
	if i <= volume_registration.npv
	then do;
	     call announce_syserr ("Extra PV entry ""^a"" in database ""lv.^a"".", pvname, lvname);
	     ec = error_table_$bad_segment;
	     goto EXIT;
	end;

	volume_registration.pv (i) = pv_registration;	/* OOB ref */
	pvrp = addr (volume_registration.pv (i));	/* start using DB */

	pvname = pv_registration.pvname;
	call hcs_$chname_seg (vrp, "", "pv." || pvname, ec);
	if ec ^= 0
	then goto EXIT;
	call hcs_$chname_seg (vrp, "", uname, ec);
	if ec ^= 0
	then do;
						/* must remove other name we just put on */
	     call hcs_$chname_seg (vrp, "pv." || pvname, "", ec2);
	     if ec2 ^= 0
	     then call announce_syserr_code (ec2, "Unable to back out database addname ""pv.^a"".", pvname);
	     goto EXIT;
	end;

	volume_registration.npv = i;			/* now, let it be legally in the array */

	call log_it ("Added new PV ""^a"" to LV ""^a"".", pvname, lvname);

	if dn ^= LV_DIR
	then do;
						/* add links */
	     call hcs_$append_link (LV_DIR, "pv." || pvname, pathname_ (dn, "pv." || pvname), ec);
	     if ec ^= 0
	     then call announce_syserr_code (ec, "Could not append link for PV name.");
	     call hcs_$append_link (LV_DIR, uname, pathname_ (dn, uname), ec);
	     if ec ^= 0
	     then call announce_syserr_code (ec, "Could not append link for PVID.");
	end;

	ec = 0;

	goto EXIT;
%page;


/* DELETE_LVR - Entry to remove a volume registration database. */

delete_lvr:
     entry (a_lvname, a_ec);

/**** **************************************************************************

      This entry deletes the registration data segment for the given LV.  If the
      segment was in ">", the links corresponding to the LV and all the PVs are
      removed from ">lv".  The Master Directory Control entry "delete_mdcs" is
      called to delete its data segment which corresponds to the deleted LV
      registration data segment.

      The code is implemented like:

      entry
      setup
      copy args
      lock database
      locate LV registration data segment
      copy data to temporary
      delete the segment
      log deletion of each PV
      delete associated database links if necessary
      call MDC to delete its database for the LV
      cleanup
      exit

      ************************************************************************** ****/

	MYNAME = "volume_registration_mgr_$delete_lvr";

	on any_other call emergency_exit;
	on cleanup call clean_up;

/* COPY ARGS */
	lvname = a_lvname;

	call get_tseg;

	call vrm_lock_$lock (ec);
	if ec ^= 0
	then goto EXIT;

	call locate_ (lvname, LV, INIT);
	lvid = volume_registration.lvid;		/* save this for later... */

	call mdc_repair_$delete_mdcs (lvname, lvid, ec);
	if ec ^= 0
	then goto EXIT;

	tsegp -> volume_registration = volume_registration;
						/* make copy so we can log individual PV deletions later. */

	string (delete_options) = ""b;
	delete_options.force = "1"b;
	delete_options.segment = "1"b;
	delete_options.raw = "1"b;
	call delete_$ptr (vrp, string (delete_options), "", ec);
						/* this removes the LV (and all its PVs) */
	if ec ^= 0
	then goto EXIT;
	databasep = null ();			/* be nice to our clean_up handler */

	vrp = null;				/* so we dont ref deleted seg */

	do i = 1 to tsegp -> volume_registration.npv;
	     pvname = tsegp -> volume_registration.pv (i).pvname;
	     pvid = tsegp -> volume_registration.pv (i).pvid;
	     call log_it ("Deleted PV ""^a"" from LV ""^a"".", pvname, lvname);
	     if dn ^= LV_DIR
	     then do;
						/* remove links */
		string (delete_options) = ""b;
		delete_options.force = "1"b;
		delete_options.link = "1"b;
		delete_options.raw = "1"b;
		call delete_$path (LV_DIR, "pv." || pvname, string (delete_options), "", ec);
		if ec ^= 0
		then call announce_syserr_code (ec, "Could not remove PV name database link.");
		call delete_$path (LV_DIR, "pvid." || unique_chars_ ((pvid)), string (delete_options), "", ec);
		if ec ^= 0
		then call announce_syserr_code (ec, "Could not remove PVID database link.");
	     end;
	end;
	call log_it ("Deleted LV ""^a"".", lvname);

	if dn ^= LV_DIR
	then do;
						/* remove links for LV */
	     string (delete_options) = ""b;
	     delete_options.force = "1"b;
	     delete_options.link = "1"b;
	     delete_options.raw = "1"b;
	     call delete_$path (LV_DIR, "lv." || lvname, string (delete_options), "", ec);
	     if ec ^= 0
	     then call announce_syserr_code (ec, "Could not remove LV name database link.");
	     call delete_$path (LV_DIR, "lvid." || unique_chars_ ((lvid)), string (delete_options), "", ec);
	     if ec ^= 0
	     then call announce_syserr_code (ec, "Could not remove LVID database link.");
	end;

	go to EXIT;
%page;


/* DELETE_PVR - Entry to remove a single PV entry from an LV database. */

delete_pvr:
     entry (a_pvname, a_ec);

/**** **************************************************************************

      This entry deletes the registration data for a single PV.  The two addnames
      corresponding to the PV are removed from the LV registration data segment.
      The "pv" array is compressed so that the remaining active entries are
      contiguous.  If the registration data segment is in ">", the two links
      corresponding to the PV are removed from ">lv".

      The code is implemented like:

      entry
      setup
      copy args
      lock database
      locate database segment containing the PV
      find the PV entry
      remove the entry
      adjust "number of PVs" in the header
      delete associated database links if necessary
      cleanup
      logout

      ************************************************************************** ****/

	MYNAME = "volume_registration_mgr_$delete_pvr";

	on any_other call emergency_exit;
	on cleanup call clean_up;

/* COPY ARGS */
	pvname = a_pvname;

	call vrm_lock_$lock (ec);
	if ec ^= 0
	then goto EXIT;

	call locate_ (pvname, PV, INIT);		/* get volume registration database containing the PV */

	if volume_registration.npv = 1
	then do;					/* we won't delete the last PV */
	     ec = error_table_$action_not_performed;
	     goto EXIT;
	end;

	do i = 1 to volume_registration.npv while (volume_registration.pv (i).pvname ^= pvname);
	end;

	if i > volume_registration.npv
	then do;
	     ec = error_table_$bad_segment;
	     call announce_syserr ("PV entry missing from database ""pv.^a"".", pvname);
	     goto EXIT;
	end;

/* get rid of the names */
	call hcs_$chname_seg (vrp, "pv." || pvname, "", ec);
	if ec ^= 0
	then goto EXIT;
	uname = "pvid." || unique_chars_ ((volume_registration.pv (i).pvid));
	call hcs_$chname_seg (vrp, uname, "", ec);
	if ec ^= 0
	then do;
						/* put other name back on to retain consistancy */
	     call hcs_$chname_seg (vrp, "", "pv." || pvname, ec2);
	     if ec2 ^= 0
	     then call announce_syserr_code (ec2, "Unable to replace database name ""pv.^a"".", pvname);
	     goto EXIT;
	end;

/* squash the database */
	do j = i + 1 to volume_registration.npv;
	     volume_registration.pv (j - 1) = volume_registration.pv (j);
	end;
	volume_registration.npv = volume_registration.npv - 1;

	call hcs_$truncate_seg (vrp, currentsize (volume_registration), ec);
	if ec ^= 0
	then call announce_syserr_code (ec, "Trimming registration.");

	call log_it ("Deleted PV ""^a"" from LV ""^a"".", pvname, volume_registration.lvname);

	call locate_ ((volume_registration.lvname), LV, DONT_INIT);
						/* find out real location of segment */
	if dn ^= LV_DIR
	then do;
						/* remove links */
	     string (delete_options) = ""b;
	     delete_options.force = "1"b;
	     delete_options.link = "1"b;
	     delete_options.raw = "1"b;
	     call delete_$path (LV_DIR, "pv." || pvname, string (delete_options), "", ec);
	     if ec ^= 0
	     then call announce_syserr_code (ec, "Could not remove PV name database link.");
	     call delete_$path (LV_DIR, uname, string (delete_options), "", ec);
	     if ec ^= 0
	     then call announce_syserr_code (ec, "Could not remove PVID database link.");
	end;

	ec = 0;

	goto EXIT;				/* all done */
%page;


/* CHANGE_LVR - Entry to change logical volume data. */

change_lvr:
     entry (a_lvname, a_ptr, a_ec);

/**** **************************************************************************

      This entry changes selected attributes of an LV.  The caller supplies a
      volume_registration structure with no "pv" array entries.  All attributes are
      validated before any changes are made.  Changes to the LV name or LVID are
      propagated to Master Directory Control through a call to its entry
      "update_lvid" and "rename_mdcs".  Also, changes to the LV name or LVID make it
      necessary to change the LV registration data segment names (and possibly the
      names of links in ">lv").

      The code is implemented like:

      entry
      setup
      copy args
      check caller's registration data structure
      lock the database
      locate LV data segment
      make LVID change if requested
      make NAME change if requested (back out LVID change if unable to make NAME change)
      make other changes as requested
      cleanup
      exit

      ************************************************************************** ****/

/* a_lvname is the current name of the volume, it may change
   depending upon the incoming value of volume_registration.lvname */

	MYNAME = "volume_registration_mgr_$change_lvr";

	on any_other call emergency_exit;
	on cleanup call clean_up;

/* COPY ARGS */
	lvname = a_lvname;
	uvrp = a_ptr;
	call get_tseg;				/* space for copy of user's structure */
	nvrp = tsegp;
						/* let's make sure it isn't just garbage */
						/* we'll check again after the copy */
	if uvrp -> volume_registration.npv ^= 0
	then do;
	     ec = error_table_$bad_arg;
	     goto EXIT;
	end;
	nvrp -> volume_registration = uvrp -> volume_registration;
	if nvrp -> volume_registration.npv ^= 0
	then do;
	     ec = error_table_$bad_arg;
	     goto EXIT;
	end;

	call check_lv (nvrp);

	call vrm_lock_$lock (ec);
	if ec ^= 0
	then goto EXIT;

	call locate_ (lvname, LV, INIT);


/* The next bit of code is a touch hairy.  We need to add (potentially)
   2 names in two places each.  Should anything go wrong, we need to undo
   names already in place.  Thus, there's a slightly complicated mechanism
   for backing out partial changes.		*/

	lvid_changed = "0"b;
	if volume_registration.lvid ^= nvrp -> volume_registration.lvid
	then do;
	     new_lvid = nvrp -> volume_registration.lvid;
	     old_lvid = volume_registration.lvid;

	     old_uname = "lvid." || unique_chars_ ((old_lvid));
	     new_uname = "lvid." || unique_chars_ ((new_lvid));

	     call hcs_$chname_seg (vrp, old_uname, new_uname, ec);
	     if ec ^= 0
	     then do;
		if ec ^= error_table_$namedup &
		     ec ^= error_table_$segnamedup	/* if not normal error... */
		then call announce_syserr_code (ec, "Unexpected trouble changing name ""^a"".", old_uname);
		goto EXIT;
	     end;
	     volume_registration.lvid = new_lvid;	/* whew */
	     lvid_changed = "1"b;

	     call mdc_repair_$update_lvid (lvname, old_lvid, new_lvid, ec);
	     if ec ^= 0
	     then do;
						/* must back out the change... */
		call hcs_$chname_seg (vrp, new_uname, old_uname, ec2);
		if ec2 ^= 0
		then call announce_syserr_code (ec2, "Unable to change name ""^a"" back to ""^a"".",
			new_uname, old_uname);
		else volume_registration.lvid = old_lvid;
		goto EXIT;
	     end;

/* we won't log change yet - first see if name change goes OK */
	end;

	if volume_registration.lvname ^= nvrp -> volume_registration.lvname
	then do;
	     new_lvname = nvrp -> volume_registration.lvname;
	     old_lvname = volume_registration.lvname;

	     if old_lvname = "root"
	     then do;
						/* can't let this happen */
		ec = error_table_$bad_arg;
		go to back_out_lvid_change;		/* and exit */
	     end;

	     call hcs_$chname_seg (vrp, "lv." || old_lvname, "lv." || new_lvname, ec);
	     if ec ^= 0
	     then do;
						/* ugh! now we have to back out preceeding lvid changes. */
		if ec ^= error_table_$namedup &
		     ec ^= error_table_$segnamedup	/* if not normal error... */
		then call announce_syserr_code (ec, "Unexpected error changing name on ""lv.^a"".", old_lvname);
back_out_lvid_change:
		if lvid_changed
		then do;
		     call hcs_$chname_seg (vrp, new_uname, old_uname, ec2);
		     if ec2 ^= 0
		     then call announce_syserr_code (ec2, "Unable to change name ""^a"" back to ""^a"".",
			     new_uname, old_uname);
		     else do;
			volume_registration.lvid = old_lvid;
			call mdc_repair_$update_lvid (lvname, new_lvid, old_lvid, ec2);
			if ec2 ^= 0
			then call announce_syserr_code (ec2, "Unable to back out LVID change to ""^a.mdcs"".",
				lvname);
		     end;
		end /* back_out_lvid_change */;

		goto EXIT;
	     end;

/* update the internal name */
	     volume_registration.lvname = new_lvname;

/* now make sure MDC keeps up */
	     call mdc_repair_$rename_mdcs (old_lvname, volume_registration.lvid, new_lvname, ec);
	     if ec ^= 0
	     then do;
						/* now we need to back out lvname change AND lvid change */
		call hcs_$chname_seg (vrp, "lv." || new_lvname, "lv." || old_lvname, ec2);
		if ec2 ^= 0
		then call announce_syserr_code (ec2, "Unable to change name ""^a"" back to ""^a"".",
			new_lvname, old_lvname);
		else do;
		     volume_registration.lvname = old_lvname;
		     goto back_out_lvid_change;
		end;

		goto EXIT;
	     end;

	     call log_it ("Changed name of LV ""^a"" to ""^a"".", lvname, new_lvname);

	     if dn ^= LV_DIR
	     then do;
						/* adjust link */
		string (delete_options) = ""b;
		delete_options.force = "1"b;
		delete_options.link = "1"b;
		delete_options.raw = "1"b;
		call delete_$path (LV_DIR, "lv." || old_lvname, string (delete_options), "", ec);
		if ec ^= 0
		then call announce_syserr_code (ec, "Couldn't delete link for old LV name.");
		call hcs_$append_link (LV_DIR, "lv." || new_lvname, pathname_ (dn, "lv." || new_lvname), ec);
		if ec ^= 0
		then call announce_syserr_code (ec, "Couldn't create link for new LV name.");
	     end;
	end;

	if lvid_changed
	then do;					/* now we can log the LVID change - we wont be backing it out */
	     call log_it ("Changed LVID of LV ""^a"" from ""^w"" to ""^w"".", lvname, old_lvid, new_lvid);

	     if dn ^= LV_DIR
	     then do;
						/* adjust link */
		string (delete_options) = ""b;
		delete_options.force = "1"b;
		delete_options.link = "1"b;
		delete_options.raw = "1"b;
		call delete_$path (LV_DIR, old_uname, string (delete_options), "", ec);
		if ec ^= 0
		then call announce_syserr_code (ec, "Couldn't delete link for old LVID.");
		call hcs_$append_link (LV_DIR, new_uname, pathname_ (dn, new_uname), ec);
		if ec ^= 0
		then call announce_syserr_code (ec, "Couldn't create link for new LVID.");
	     end;
	end;

/* the rest of the changes are easy... */

	if volume_registration.access_class_range (2) ^= nvrp -> volume_registration.access_class_range (2)
	then do;
	     old_aa_str = display_access_class_ (volume_registration.access_class_range (2));
	     new_aa_str = display_access_class_ (nvrp -> volume_registration.access_class_range (2));
	     call convert_access_class_$to_string_short (nvrp -> volume_registration.access_class_range (2),
		auth_mnemonics, ec);
	     if ec ^= 0
	     then do;
		call announce_syserr_code (ec, "Unable to convert max auth to name_string.");
		auth_mnemonics = "can't convert";
	     end;
	     volume_registration.access_class_range (2) = nvrp -> volume_registration.access_class_range (2);
	     call log_it ("Changed max access class of LV ""^a"" from ""^a"" to ""^a"". (^a)",
		lvname, old_aa_str, new_aa_str, auth_mnemonics);
	end;

	if volume_registration.access_class_range (1) ^= nvrp -> volume_registration.access_class_range (1)
	then do;
	     old_aa_str = display_access_class_ (volume_registration.access_class_range (1));
	     new_aa_str = display_access_class_ (nvrp -> volume_registration.access_class_range (1));
	     call convert_access_class_$to_string_short (nvrp -> volume_registration.access_class_range (1),
		auth_mnemonics, ec);
	     if ec ^= 0
	     then do;
		call announce_syserr_code (ec, "Unable to convert min auth to name_string.");
		auth_mnemonics = "can't convert";
	     end;
	     volume_registration.access_class_range (1) = nvrp -> volume_registration.access_class_range (1);
	     call log_it ("Changed min access class of LV ""^a"" from ""^a"" to ""^a"" (^a).",
		lvname, old_aa_str, new_aa_str, auth_mnemonics);
	end;

	if volume_registration.volume_owner ^= nvrp -> volume_registration.volume_owner
	then do;
	     call log_it ("Changed owner of LV ""^a"" from ""^a"" to ""^a"".", lvname,
		volume_registration.volume_owner, nvrp -> volume_registration.volume_owner);
	     volume_registration.volume_owner = nvrp -> volume_registration.volume_owner;
	end;

	if volume_registration.public ^= nvrp -> volume_registration.public
	then do;
	     call log_it ("Changed LV ""^a"" to ^[PUBLIC^;PRIVATE^].", lvname, volume_registration.public);
	     volume_registration.public = nvrp -> volume_registration.public;
	end;

	if volume_registration.acs_path ^= nvrp -> volume_registration.acs_path
	then do;
	     volume_registration.acs_path = nvrp -> volume_registration.acs_path;
	     call log_it ("Changed ACS pathname for LV ""^a"" to ""^a"".", lvname, volume_registration.acs_path);
	end;

	ec = 0;					/* to be sure */

	goto EXIT;
%page;


/* CHANGE_PVR - Entry to change information about a particular PV */

change_pvr:
     entry (a_pvname, a_ptr, a_ec);

/**** **************************************************************************

      This entry changes selected attributes of a PV.  The caller supplies a
      pv_registration structure with all members initialized.  All attributes are
      validated before any changes are made.  If the LV name or LVID changes it is
      necessary to also change the corresponding names on the LV registration data
      segment (and possibly the names of links in ">lv").

      The code is implemented like:

      entry
      setup
      copy_args
      check caller's registration data structure
      lock database
      locate registration data segment
      find PV entry in data segment
      make PVID change if requested
      make NAME change if requested (back out PVID change if error is encountered)
      make other changes as requested
      cleanup
      exit

      ************************************************************************** ****/

	MYNAME = "volume_registration_mgr_$change_pvr";

	on any_other call emergency_exit;
	on cleanup call clean_up;

/* COPY ARGS */
	pvname = a_pvname;
	upvrp = a_ptr;
	call get_tseg;				/* place to make copy of user's structure */
	npvrp = tsegp;
	npvrp -> pv_registration = upvrp -> pv_registration;
						/* copy the structure */

	call check_pv (npvrp);

	call vrm_lock_$lock (ec);
	if ec ^= 0
	then goto EXIT;

	call locate_ (pvname, PV, INIT);

	do i = 1 to volume_registration.npv while (volume_registration.pv (i).pvname ^= pvname);
	end;

	if i > volume_registration.npv
	then do;
	     call announce_syserr ("PV entry missing from database ""pv.^a"".", pvname);
	     ec = error_table_$bad_segment;
	     goto EXIT;
	end;

	pvrp = addr (volume_registration.pv (i));

/* now - make the changes */

/* as in "change_lvr" we have to make potentially two name changes
   but only to the volume registration database (i.e. not any MDCS) */

	pvid_changed = "0"b;
	if pv_registration.pvid ^= npvrp -> pv_registration.pvid
	then do;
	     old_pvid = pv_registration.pvid;
	     new_pvid = npvrp -> pv_registration.pvid;
	     old_uname = "pvid." || unique_chars_ ((old_pvid));
	     new_uname = "pvid." || unique_chars_ ((new_pvid));

	     call hcs_$chname_seg (vrp, old_uname, new_uname, ec);
	     if ec ^= 0
	     then do;
		if ec ^= error_table_$namedup &
		     ec ^= error_table_$segnamedup	/* check for unusual errors... */
		then call announce_syserr_code (ec, "Unexpected trouble changing name ""^a"".", old_uname);
		goto EXIT;
	     end;

	     pv_registration.pvid = new_pvid;
	     pvid_changed = "1"b;
	end;

	if pv_registration.pvname ^= npvrp -> pv_registration.pvname
	then do;
	     old_pvname = pv_registration.pvname;
	     new_pvname = npvrp -> pv_registration.pvname;

	     if old_pvname = "rpv"
	     then do;
		ec = error_table_$bad_arg;		/* can't let 'em do this */
		goto back_out_pvid_change;		/* and exit */
	     end;

	     call hcs_$chname_seg (vrp, "pv." || old_pvname, "pv." || new_pvname, ec);
	     if ec ^= 0
	     then do;
		if ec ^= error_table_$namedup &
		     ec ^= error_table_$segnamedup	/* check for unusual errors... */
		then call announce_syserr_code (ec, "Unexpected trouble changing name ""^a"".", old_pvname);

back_out_pvid_change:
		if pvid_changed
		then do;				/* must back out other name change */
		     call hcs_$chname_seg (vrp, new_uname, old_uname, ec2);
		     if ec2 ^= 0
		     then call announce_syserr_code (ec2, "Unable to back out PVID change to ""^a.mdcs"".", pvname);
		     else pv_registration.pvid = old_pvid;
		end;
		goto EXIT;
	     end;
	     pv_registration.pvname = new_pvname;
	     call log_it ("Changed name of PV ""^a"" to ""^a"".", old_pvname, new_pvname);
	     call locate_ ((volume_registration.lvname), LV, DONT_INIT);
						/* find out real location of segment */
	     if dn ^= LV_DIR
	     then do;
						/* adjust link */
		string (delete_options) = ""b;
		delete_options.force = "1"b;
		delete_options.link = "1"b;
		delete_options.raw = "1"b;
		call delete_$path (LV_DIR, "pv." || old_pvname, string (delete_options), "", ec);
		if ec ^= 0
		then call announce_syserr_code (ec, "Couldn't delete link for old PV name.");
		call hcs_$append_link (LV_DIR, "pv." || new_pvname, pathname_ (dn, "pv." || new_pvname), ec);
		if ec ^= 0
		then call announce_syserr_code (ec, "Couldn't create link for new PV name.");
	     end;
	end;

	if pvid_changed
	then do;
						/* now we can log that fact - since it ain't gonna be backed out */
	     call log_it ("Changed PVID of PV ""^a"" from ""^w"" to ""^w"".", pvname, old_pvid, new_pvid);
	     call locate_ ((volume_registration.lvname), LV, DONT_INIT);
						/* find out real location of segment */
	     if dn ^= LV_DIR
	     then do;
						/* adjust link */
		string (delete_options) = ""b;
		delete_options.force = "1"b;
		delete_options.link = "1"b;
		delete_options.raw = "1"b;
		call delete_$path (LV_DIR, old_uname, string (delete_options), "", ec);
		if ec ^= 0
		then call announce_syserr_code (ec, "Couldn't delete link for old PVID.");
		call hcs_$append_link (LV_DIR, new_uname, pathname_ (dn, new_uname), ec);
		if ec ^= 0
		then call announce_syserr_code (ec, "Couldn't create link for new PVID.");
	     end;
	end;

	if pv_registration.model ^= npvrp -> pv_registration.model
	then do;
	     call log_it ("Changed model of PV ""^a"" from ""^d"" to ""^d"".", pvname,
		MODELN (pv_registration.model), MODELN (npvrp -> pv_registration.model));
	     pv_registration.model = npvrp -> pv_registration.model;
	end;

	if pv_registration.location ^= npvrp -> pv_registration.location
	then do;
	     call log_it ("Changed location of PV ""^a"" from ""^a"" to ""^a"".", pvname, pv_registration.location,
		npvrp -> pv_registration.location);
	     pv_registration.location = npvrp -> pv_registration.location;
	end;

	if pv_registration.mfg_serial ^= npvrp -> pv_registration.mfg_serial
	then do;
	     call log_it ("Changed mfg_serial of PV ""^a"" from ""^a"" to ""^a"".", pvname, pv_registration.mfg_serial,
		npvrp -> pv_registration.mfg_serial);
	     pv_registration.mfg_serial = npvrp -> pv_registration.mfg_serial;
	end;

	if pv_registration.date_registered ^= npvrp -> pv_registration.date_registered
	then do;
	     old_dt_reg = date_time_$format ("date_time", pv_registration.date_registered, "", "");
	     new_dt_reg = date_time_$format ("date_time", npvrp -> pv_registration.date_registered, "", "");
	     call log_it ("Changed date_registered of PV ""^a"" from ""^a"" to ""^a"".",
		pvname, old_dt_reg, new_dt_reg);
	     pv_registration.date_registered = npvrp -> pv_registration.date_registered;
	end;

	if pv_registration.password ^= npvrp -> pv_registration.password
	then do;
	     call log_it ("Changed password of PV ""^a"".", pvname);
						/* don't tell what it was or now is... */
	     pv_registration.password = npvrp -> pv_registration.password;
	end;

	goto EXIT;
%page;

/* ------------------------------------------------------- */

/* Service entries called by various other programs which need to know about
   volume registration information. Status, dumper, master dir control, mount */

/* ------------------------------------------------------- */



/* PVNAME_INFO - Entry to return information about a given PV */

pvname_info:
     entry (a_pvname, a_pvid, a_lvname, a_lvid, a_device_type, a_ec);

/**** **************************************************************************

      This entry returns the PVID, LV name, LVID, and device type (model index)
      for a given PV name.

      ************************************************************************** ****/

	MYNAME = "volume_registration_mgr_$pvname_info";

	on any_other call emergency_exit;
	on cleanup call clean_up;

	pvname = a_pvname;

	call vrm_lock_$lock (ec);
	if ec ^= 0
	then goto EXIT;

	call locate_ (pvname, PV, INIT);
	do i = 1 to volume_registration.npv while (pvname ^= volume_registration.pv (i).pvname);
	end;
	if i > volume_registration.npv
	then do;
	     ec = error_table_$unregistered_volume;
	     call announce_syserr ("PV entry not found in database ""pv.^a"".", pvname);
	     goto EXIT;
	end;

	ec = 0;
	a_pvid = volume_registration.pv (i).pvid;
	a_device_type = volume_registration.pv (i).model;
	a_lvname = volume_registration.lvname;
	a_lvid = volume_registration.lvid;

	goto EXIT;
%page;

/* FIND_LVID - Entry to return LVID given LV name */

find_lvid:
     entry (a_lvname, a_lvid, a_ec);			/* Translate name to uid */

/**** **************************************************************************

      This entry returns the LVID for a given LV name.

      ************************************************************************** ****/

	MYNAME = "volume_registration_mgr_$find_lvid";

	on any_other call emergency_exit;
	on cleanup call clean_up;

	lvname = a_lvname;

	call vrm_lock_$lock (ec);
	if ec ^= 0
	then goto EXIT;

	call locate_ (lvname, LV, INIT);

	a_lvid = volume_registration.lvid;		/* Return the value */
	ec = 0;

	go to EXIT;
%page;

/* FIND_VOLNAME - Entry to return LV and PV names given PVID */

find_volname:
     entry (a_pvid, a_pvname, a_lvname, a_ec);		/* pvid -> pvname, lvname (dumper) */

/**** **************************************************************************

      This entry returns the PV name and LV name for a given PVID.

      ************************************************************************** ****/

	MYNAME = "volume_registration_mgr_$find_volname";

	on any_other call emergency_exit;
	on cleanup call clean_up;

	pvid = a_pvid;				/* copy input arg */
						/* init return values */
	a_pvname, a_lvname = "";

	uname = "pvid." || unique_chars_ ((pvid));	/* Use name on segment */

	call vrm_lock_$lock (ec);
	if ec ^= 0
	then goto EXIT;

	call locate_uid_ (pvid, PV, INIT);

	do i = 1 to volume_registration.npv while (volume_registration.pv (i).pvid ^= pvid);
	end;
	if i > volume_registration.npv
	then do;
	     call announce_syserr ("PV entry not found in database ""^a"".", uname);
	     ec = error_table_$bad_volid;
	     goto EXIT;
	end;

	a_pvname = volume_registration.pv (i).pvname;	/* Rah. Divulge volume name */
	a_lvname = volume_registration.lvname;		/* Hand back volume name */
	ec = 0;

	go to EXIT;
%page;

/* FIND_LVNAME - Entry to return LV name given the LVID */

find_lvname:
     entry (a_lvid, a_lvname, a_ec);			/* lvid -> lvname */

/**** **************************************************************************

      This entry returns the LV name for a given LVID.

      ************************************************************************** ****/

	MYNAME = "volume_registration_mgr_$find_lvname";

	on any_other call emergency_exit;
	on cleanup call clean_up;

	lvid = a_lvid;
	a_lvname = "";				/* init return value */

	uname = "lvid." || unique_chars_ ((lvid));	/* Use the trick names */

	call vrm_lock_$lock (ec);
	if ec ^= 0
	then goto EXIT;

	call locate_uid_ (lvid, LV, INIT);

	a_lvname = volume_registration.lvname;
	ec = 0;

	go to EXIT;
%page;

/* GET_ACCESS - Entry to return callers' access to given LV */

get_access:
     entry (a_lvname, a_level, a_mode, a_pub_bit, a_ec);	/* Effective mode to lv (mount, mdc) */

	set_access_range = "0"b;
	goto GET_ACCESS_JOIN;

get_access_for_attach:
     entry (a_lvname, a_level, a_mode, a_pub_bit, a_lv_access_class_range, a_ec);
						/* special entry for rcp_attach_lv_ */

	a_lv_access_class_range = sys_info$access_class_ceiling;
						/* initial value */
	set_access_range = "1"b;

GET_ACCESS_JOIN:


/**** **************************************************************************

      This entry computes the callers access mode to a given LV.  The code first
      checks the AIM access range and RCP_PRIVILEGE.  If neither of these are
      acceptable, the mode returned is "null".  Otherwise, the access will be
      computed from the ACS.  If no acs_path is registered, or if the ACS itself is
      missing, the access returned is "REW" for the owner, "null" for all others.

      NOTE: NOTE: this code should really be removed and made into "lv_access_kernel_"

      The code is implemented like:

      entry
      setup
      copy args
      lock database
      locate registration data segment for LV
      if process access class out of range or process not privileged
      then return NULL mode
      else if ACS exists for LV
      then return process's raw mode to ACS
      else if process is LV owner
      then return REW mode
      else return NULL mode
      cleanup
      exit

      ************************************************************************** ****/


	MYNAME = "volume_registration_mgr_$get_access";

	on any_other call emergency_exit;
	on cleanup call clean_up;

	lvname = a_lvname;				/* copy input args */
	level = a_level;

	call vrm_lock_$lock (ec);
	if ec ^= 0
	then goto EXIT;

	call locate_ (lvname, LV, INIT);

	if ^((read_allowed_ (get_authorization_ (), volume_registration.access_class_range (1))
	     & write_allowed_ (get_authorization_ (), volume_registration.access_class_range (2)))
	     | ((get_privileges_ () & RCP_PRIVILEGE) ^= ""b))
	then do;
	     mode = N_ACCESS;			/* if vol off aim limits, n.g. */
	     pub_bit = "0"b;
	end;
	else do;
	     if volume_registration.acs_path ^= ""
	     then do;
		call expand_pathname_ ((volume_registration.acs_path), dn, en, ec);
		if ec ^= 0
		then do;
		     call announce_syserr_code (ec, "Bad ACS path in database ""lv.^a"".", lvname);
		     goto NO_ACS;			/* check for owner mode */
		end;

		call hcs_$get_user_raw_mode (dn, en, "", mode, ec);
						/* ignores ring brackets and AIM */
		if ec ^= 0
		then goto NO_ACS;			/* check for owner mode */
		pub_bit = volume_registration.public;
	     end;
	     else do;
NO_ACS:						/* ACS need not exist */
		uname = get_group_id_ ();
		j = length (rtrim (uname));
		substr (uname, j - 1) = "";		/* Blank instance tag */
		j = index (uname, ".");
		pers = substr (uname, 1, j - 1);
		proj = substr (uname, j + 1);
		j = index (volume_registration.volume_owner, ".");
		opers = substr (volume_registration.volume_owner, 1, j - 1);
		oproj = substr (volume_registration.volume_owner, j + 1);

		if (pers = opers | opers = "*") & (proj = oproj | oproj = "*")
		then mode = REW_ACCESS;		/* Volume owner always REW */
		else if volume_registration.public
		then mode = RW_ACCESS;		/* Everybody has RW to public vols */
		else mode = N_ACCESS;		/* Private vol, no ACS */
		pub_bit = volume_registration.public;
	     end;

	end;

	a_mode = mode;				/* Tell user */
	a_pub_bit = pub_bit;
	if set_access_range
	then a_lv_access_class_range = volume_registration.access_class_range;

	ec = 0;
	go to EXIT;
%page;

/* LVNAME_INFO - Entry to return information about PVs given an LV name */

lvname_info:
     entry (a_lvname, a_pvap, a_npv, a_ec);

/**** **************************************************************************

      This entry returns a specialized structure of information on
      all PVs belonging to a given LV name.

      The code is implemented like:

      entry
      setup
      copy args
      lock database
      locate registration data segment for LV
      fill in caller's structure with info on all PVs in the LV
      cleanup
      exit

      ************************************************************************** ****/

dcl     pvap		 ptr;

dcl     1 pva		 (100) based (pvap) aligned,	/* This entrypoint fills in a struc */
	2 pvname		 char (32),		/* .. listing all volumes */
	2 device_type	 fixed bin,		/* .. and their model numbers */
	2 pvid		 bit (36);		/* and pvid */

	MYNAME = "volume_registration_mgr_$lvname_info";

	make_lve = "0"b;				/* dont fiddle with disk table */
	goto lv_pvinfo_common;
%page;

/* GET_LV_PVINFO - Entry to do same as LVNAME_INFO plus make LVE in disk table */
/*	This entry is called by disk_table_ (via initializer_mdc_) and by mdx */

get_lv_pvinfo:
     entry (a_lvname, a_pvap, a_npv, a_lvx, a_ec);	/* Get lv pv list, make lve */

/**** **************************************************************************

      This entry has the same function as "lvname_info".  In addition
      it will return the index of the corresponding LV disk_table entry.
      If there is no corresponding disk table LV entry, it will be created.

      The code is implemented like:

      entry
      setup
      copy args
      lock database
      locate registration data segment for LV
      locate disk table LV entry or make one if not already existing
      fill in caller's structure with info on all PVs in the LV
      cleanup
      exit

      ************************************************************************** ****/

	MYNAME = "volume_registration_mgr_$get_lv_pvinfo";

	make_lve = "1"b;				/* update disk table */


lv_pvinfo_common:

	on any_other call emergency_exit;
	on cleanup call clean_up;

	dtp = sdtp;
	dtep = null;				/* not needed at this entry */
	lvname = a_lvname;
	pvap = a_pvap;

	call vrm_lock_$lock (ec);
	if ec ^= 0
	then goto EXIT;

	call locate_ (lvname, LV, INIT);
	if make_lve
	then a_lvx = get_lve ();

	do i = 1 to volume_registration.npv;
	     pva (i).pvname = volume_registration.pv (i).pvname;
	     pva (i).device_type = volume_registration.pv (i).model;
	     pva (i).pvid = volume_registration.pv (i).pvid;
	end;
	a_npv = volume_registration.npv;
	ec = 0;
	go to EXIT;
%page;

/* FIND - Entry to fill in disk table from volume registration data */
/* 	This entry is called by mdx 		*/

find:
     entry (a_dtep, a_ec);

/**** **************************************************************************

      This entry will create an LV disk table entry given an index
      to a disk table PV entry.  The LV entry will correspond to the
      LV of the given PV.

      The code is implemented like:

      entry
      setup
      copy args
      lock database
      locate registration data segment containing PV
      locate disk table LV entry or create one if it doesnt exist
      locate PV entry in the data segment
      if model in registration data and disk table are the same
      then copy to registered PVID into the disk table
      else there's an error
      cleanup
      exit

      ************************************************************************** ****/

	MYNAME = "volume_registration_mgr_$find";

	on any_other call emergency_exit;
	on cleanup call clean_up;

	dtp = sdtp;
	dtep = a_dtep;
	pvname = dte.pvname;			/* dte.pvname is input */

	call vrm_lock_$lock (ec);
	if ec ^= 0
	then goto EXIT;

	call locate_ (pvname, PV, INIT);
	dte.lvx = get_lve ();

	do i = 1 to volume_registration.npv while (volume_registration.pv (i).pvname ^= dte.pvname);
	end;
	if i <= volume_registration.npv
	then do;
	     if dte.device_type = volume_registration.pv (i).model
	     then do;
		dte.pvid = volume_registration.pv (i).pvid;
						/* Found stuff. Get pvid */
		ec = 0;
	     end;
	     else ec = error_table_$incorrect_device_type;
	end;
	else do;
	     call announce_syserr ("PV entry missing from ""pv.^a"".", pvname);
	     ec = error_table_$bad_volid;
	end;

	go to EXIT;
%page;

/* CHECK_VOLUME_REGISTRATION -  Salvage the registration database. */

check_volume_registration:
     entry (a_dtep, a_ec);				/* salvager module */

/**** **************************************************************************

      This entry is called during system initialization to validate/re-create the
      volume registration database.  "mdx$init" (which had previously called our
      "init" entry) scans the old disk table and calls here for each entry that had
      a valid drive mounted in the previous session.  This is evidence that the PV
      should have a valid registration.

      On the first call this entry will create ">lv" if necessary (i.e.  if its a
      new system or was booted with NOLV).

      The disk table PV entry is checked to determine that it points to a valid disk
      table LV entry.  If not, the disk table LV entry is recreated from the PV's LV
      registration data.  If the LV registration can't be determined, nothing more
      can be done but issue a console message.

      If the disk table does contain a valid LV entry for the PV in question it is
      compared to the LV registration data.  If the LV registration disagrees with
      the disk table entry, or can't be found, it is recreated.  (Thus, the disk
      table is the more trusted database.)

      If the PV registration data disagrees with the disk table PV entry, the
      registration data is "fixed" to be the same.  If the PV registration doesn't
      exist in the LV registration data segment, it is recreated there.

      This entry also ensures that all proper addnames and links are in place.

      The code is implemented like:

      entry
      setup
      (no need to copy args or lock database)
      if first call then create ">lv" if it doesn't exist
      validate PV name in disk table entry

      if disk table LV entry invalid
      then if PV is registered
      then recreate disk table LV entry
      else return to caller as failure

      validate LV name in disk table entry
      if LV registration data segment non existant
      then create new one and fill in header
      else validate existing header information - recreate if anything in error

      create proper database link for LV name if necessary
      create proper data seg addname for LVID
      create proper database link for LVID if necessary

      create proper database link for MDC data seg if necessary
      call MDC to recreate its data seg for the LV as it sees fit

      create proper data seg addname for PV name
      create proper database link for PV name if necessary

      if PV entry does not exist in data seg
      then create it
      else validate PVID and device type against disk table entry
      - update registration entry with disk table info if in error

      create proper data seg addname for PVID
      create proper database link for PVID if necessary

      cleanup
      exit

      ************************************************************************** ****/

	MYNAME = "volume_registration_mgr_$check_volume_registration";

	on any_other
	     begin;
		a_ec = error_table_$unexpected_condition;
		goto CK_VREG_EXIT;
	     end;
	on cleanup ;

/* No locking is needed at this entrypoint since
   only the Initializer exists */

	a_ec = 0;
	if first
	then do;					/* We are always called at least once (for the root) */
	     first = "0"b;
	     i = length (rtrim (LV_DIR));
	     call expand_path_ (addr (LV_DIR), (i), addr (dn), addr (en), ec);
	     call hcs_$status_minf (dn, en, 0, type, bc, ec);
	     if ec ^= 0 | type ^= 2
	     then do;
		unspec (CBI) = ""b;
		CBI.version = create_branch_version_2;
		CBI.dir_sw = "1"b;
		CBI.parent_ac_sw = "1"b;
		CBI.mode = "111"b;
		CBI.rings (1) = 7;
		CBI.rings (2) = 7;
		CBI.rings (3) = 7;
		CBI.userid = get_group_id_ ();
		call hcs_$create_branch_ (dn, en, addr (CBI), ec);
		if ec ^= 0
		then call announce_syserr_code (ec, "Cannot re-create ^a.", LV_DIR);
		else do;
		     call hcs_$add_dir_acl_entries (dn, en, addr (dacl), 1, ec);
		     if ec ^= 0
		     then call announce_syserr_code (ec, "Cannot add SysAdmin access to ^a.", LV_DIR);
		end;
	     end;
	     if LV_DIR = REAL_LV_DIR
	     then do;				/* Make LV dir be on RPV */
		call hphcs_$set_rpv (dn, en, ec);
		if ec ^= 0
		then call announce_syserr_code (ec, "Putting LV dir on RPV");
	     end;
	end;

	dtp = sdtp;
	dtep = a_dtep;
	if verify (rtrim (dte.pvname), PVNAME_LEGAL) ^= 0
	then return;				/* Dont reregister crap */
	if dte.lvx <= 0 | dte.lvx > dt.n_lv_entries
	then go to lvfail;
	lvep = addr (dt.lv_array (dte.lvx));
	if ^lve.used
	then do;
lvfail:
	     pvname = dte.pvname;			/* Invalid lve. Try to recover */
	     call locate_ (pvname, PV, DONT_INIT);
	     call hcs_$initiate (dn, en, "", 0, 0, vrp, ec);
						/* look in pv seg for lvname */
	     if vrp = null
	     then do;				/* Cannot find pv */
		call announce_syserr_code (ec, "Cannot reregister PV ""^a"".", pvname);
		a_ec = ec;			/* unable to proceed */
		return;				/* .. because i dont know what lv */
	     end;
	     dte.lvx = get_lve ();
	     call hcs_$terminate_noname (vrp, (0));
	end;
	lvname = lve.lvname;
	if verify (lvname, LVNAME_LEGAL) ^= 0
	then return;
	call locate_ (lvname, LV, DONT_INIT);
	call hcs_$initiate (dn, en, "", 0, 0, vrp, ec);	/* LV should be registered */
	if vrp = null
	then do;
	     call hcs_$make_seg (dn, en, "", 1010b, vrp, ec);
						/* Wasn't. Make new */
	     if vrp = null
	     then do;
		call announce_syserr_code (ec, "Cannot reregister LV ""^a"".", lvname);
		a_ec = ec;
		return;
	     end;
	     call admin_gate_$reclassify_sys_seg (dn, en, sys_info$access_class_ceiling, ec);
	     if ec ^= 0
	     then call announce_syserr_code (ec, pathname_ (dn, en));
remake_lv:
	     volume_registration.version = Volume_Registration_Version_2;
	     volume_registration.lvid = lve.lvid;
	     volume_registration.lvname = lvname;
	     owner = get_group_id_ ();
	     i = length (rtrim (owner));
	     volume_registration.volume_owner = substr (owner, 1, i - 2);
	     volume_registration.public = lve.public;
	     volume_registration.access_class_range (1) = lve.min_access_class;
	     volume_registration.access_class_range (2) = lve.max_access_class;
	     volume_registration.acs_path = "";
	     call announce_syserr ("Reregistered ^a LV ^a LVID ^w", PRIV (fixed (lve.public, 1)), lvname, lve.lvid);
	     call hcs_$replace_acl (dn, en, addr (aa), 1, "0"b /* SysDaemon OK */, ec);
	end;
	else do;
	     call hcs_$set_damaged_sw_seg (vrp, "0"b, ec);/* Salvaging ourself */
	     ec = 0;
	     if volume_registration.lvname ^= lvname
	     then ec = 2;
	     if volume_registration.lvid ^= lve.lvid
	     then ec = 3;
	     if volume_registration.public ^= lve.public
	     then ec = 4;
	     if volume_registration.access_class_range (1) ^= lve.min_access_class
	     then ec = 5;
	     if volume_registration.access_class_range (2) ^= lve.max_access_class
	     then ec = 6;
	     if volume_registration.version ^= Volume_Registration_Version_2
	     then call convert_database (ec);		/* to new version */
	     if ec ^= 0
	     then do;
		call announce_syserr_code (ec, "lv.^a disagreed with disk_table. It was rebuilt.", lvname);
		go to remake_lv;
	     end;
	end;
	if dn ^= LV_DIR				/* The ROOT lv must be linked to special */
	then call hcs_$append_link (LV_DIR, en, pathname_ (dn, en), ec);
	uname = "lvid." || unique_chars_ ((volume_registration.lvid));
						/* Force unique name back on */
	call hcs_$chname_seg (vrp, "", uname, ec);
	if ec ^= 0
	then if ec ^= error_table_$segnamedup
	     then call announce_syserr_code (ec, "Cant add name ""^a"" to ""^a"".", uname, en);
	if dn ^= LV_DIR
	then call hcs_$append_link (LV_DIR, uname, pathname_ (dn, uname), ec);
						/* ACS linking code was removed from this point - ejs */
	uname = rtrim (lvname) || ".mdcs";
	if dn ^= LV_DIR
	then call hcs_$append_link (LV_DIR, uname, pathname_ (dn, uname), (0));
	call hcs_$set_damaged_sw (LV_DIR, uname, "0"b, (0));
						/* Don't fault */
	call mdc_repair_$recreate_mdcs (lvname, (volume_registration.lvid), ec);
	if ec ^= 0
	then if ec ^= error_table_$namedup
	     then call announce_syserr_code (ec, "Cannot make mdcs for LV ^a", lvname);

	pvname = dte.pvname;
	en = "pv." || pvname;
	call hcs_$chname_seg (vrp, "", en, ec);		/* Put pv name back on */
	if ec ^= 0
	then if ec ^= error_table_$segnamedup
	     then call announce_syserr_code (ec, "Cant add name ""^a"" to ""^a"".", en, lvname);
	if dn ^= LV_DIR
	then call hcs_$append_link (LV_DIR, en, pathname_ (dn, en), ec);

	do i = 1 to volume_registration.npv while (volume_registration.pvname (i) ^= pvname);
	end;
	if i > volume_registration.npv
	then do;
	     volume_registration.pv (i).pvid = dte.pvid;	/* Vol was not in lv */
	     volume_registration.pv (i).pvname = pvname;
	     volume_registration.pv (i).model = dte.device_type;
	     volume_registration.pv (i).location = "online";
	     volume_registration.pv (i).mfg_serial = "registered by crash recovery";
	     volume_registration.pv (i).password = "0"b;
	     volume_registration.pv (i).date_registered = clock ();
	     volume_registration.npv = volume_registration.npv + 1;
	     call announce_syserr ("Reregistered PV ^a PVID ^w in LV ^a",
		volume_registration.pv (i).pvname, volume_registration.pv (i).pvid, lvname);
	     call hcs_$set_bc_seg (vrp, 36 * currentsize (volume_registration), ec);
	end;
	else do;
	     if volume_registration.pv (i).pvid ^= dte.pvid
		| volume_registration.pv (i).model ^= dte.device_type
	     then call announce_syserr ("Registration for PV ^a was different from disk_table.", pvname);
	     volume_registration.pv (i).pvid = dte.pvid;
	     volume_registration.pv (i).model = dte.device_type;
	end;
	uname = "pvid." || unique_chars_ ((volume_registration.pv (i).pvid));
	call hcs_$chname_seg (vrp, "", uname, ec);	/* Put name back on */
	if ec ^= 0
	then if ec ^= error_table_$segnamedup
	     then call announce_syserr_code (ec, "Cant add name ""^a"" to ""^a"".", uname, lvname);
	if dn ^= LV_DIR				/* Hard case */
	then call hcs_$append_link (LV_DIR, uname, pathname_ (dn, uname), ec);

	call hcs_$terminate_noname (vrp, ec);

CK_VREG_EXIT:
	return;
%page;
/* -------------------------------------------------- */
/* INTERNAL SUPPORT ROUTINES                          */
/* -------------------------------------------------- */


log_it:						/* log changes to databases */
     proc options (variable);

dcl     severity		 fixed bin;
dcl     based_msg		 char (tstr_len) based (addr (temp_str));
dcl     alp		 pointer;

	severity = LOG;
	goto log_it_join;

announce_syserr:
     entry options (variable);

	severity = ANNOUNCE;

log_it_join:
	on any_other ;

	call cu_$arg_list_ptr (alp);
	call ioa_$general_rs (alp, 1, 2, temp_str, tstr_len, "0"b /* no pad */, "0"b /* nnl */);

	if testing
	then call com_err_ (0, MYNAME, "(^[SYSERR^;SYSLOG^]) ^a (^a)", (severity = ANNOUNCE), based_msg,
		get_group_id_ ());
	else call admin_gate_$syserr (severity, "^a: ^a (^a)", MYNAME, based_msg, get_group_id_ ());

	return;

     end log_it;

/* -------------------------------------------------- */

announce_syserr_code:				/* console msg about something awful */
     proc options (variable);

dcl     ecode		 fixed bin (35) based (ecode_p);
dcl     ecode_p		 pointer;
dcl     ecode_len		 fixed bin (21);		/* ignored */
dcl     based_msg		 char (tstr_len) based (addr (temp_str));
dcl     severity		 fixed bin;
dcl     based_packed_ptr	 ptr unal based;
dcl     alp		 pointer;


	severity = ANNOUNCE;

	on any_other ;

	call cu_$arg_list_ptr (alp);
	call ioa_$general_rs (alp, 2, 3, temp_str, tstr_len, "0"b /* no pad */, "0"b /* nnl */);
	call cu_$arg_ptr (1, ecode_p, ecode_len, ec2);

	if testing
	then call com_err_ (ecode, MYNAME, "(^[SYSERR^;SYSLOG^]) ^a (^a)", (severity = ANNOUNCE), based_msg,
		get_group_id_ ());
	else call admin_gate_$syserr_error_code
		(ANNOUNCE, ecode, "^a:^[ Code=^d.^;^s^] ^a (^a)", MYNAME,
		(baseno (addr (ecode) -> based_packed_ptr) = "0"b), ecode, based_msg, get_group_id_ ());

	return;

     end announce_syserr_code;

/* -------------------------------------------------- */

clean_up:						/* tidy the place before we leave */
     proc;

dcl     tptr		 ptr;

	if tsegp ^= null
	then do;
	     tptr = tsegp;
	     tsegp = null;				/* so we don't try to do it again... */
	     call release_temp_segment_ ((MYNAME), tptr, ec2);
	     if ec2 ^= 0
	     then call announce_syserr_code (ec2, "Unable to release temp segment.");
	end;

	if databasep ^= null
	then do;
	     tptr = databasep;
	     databasep = null;
	     call hcs_$terminate_noname (tptr, ec2);
	     if ec2 ^= 0
	     then call announce_syserr_code (ec2, "Unable to terminate database reference.");
	end;

	call vrm_lock_$cleanup ();

	if old_level ^= -1
	then call cu_$level_set (old_level);

	a_ec = ec;				/* tell caller our final status */

     end clean_up;

/* -------------------------------------------------- */

emergency_exit:					/* just in case ... */
     proc;

	if get_ring_ () = get_initial_ring_ ()		/* inner ring process? */
	then do;
	     call continue_to_signal_ (ec);		/* behave like user ring subroutine */
	     if ec ^= 0
	     then goto EXIT;
	end;
	else do;					/* throw fit if inner ring */
	     call announce_syserr ("Unexpected error occurred.  Database may be in an inconsistant state.");
	     ec = error_table_$unexpected_condition;
	     goto EXIT;				/* "clean_up" called from there... */
	end;


     end emergency_exit;

/* -------------------------------------------------- */

get_tseg:						/* get temporary for caller */
     proc;

	if tsegp ^= null ()
	then do;
						/* should only need one temporary per invocation */
	     ec = error_table_$fatal_error;
	     call announce_syserr (ec, "Attempting to get second temp segment.");
	     goto EXIT;
	end;
	else do;
	     call get_temp_segment_ ((MYNAME), tsegp, ec);
	     if ec ^= 0
	     then goto EXIT;
	end;

     end get_tseg;

/* -------------------------------------------------- */

check_lv:						/* procedure to validate data for LV registration */
     proc (p);

dcl     p			 ptr;

	ec = error_table_$bad_arg;			/* guilty 'til proven innocent */

	if p -> volume_registration.version ^= Volume_Registration_Version_2
	then do;
	     ec = error_table_$unimplemented_version;	/* we'll be a little more specific here */
	     goto EXIT;
	end;
	if p -> volume_registration.lvid = "0"b
	then goto EXIT;
	if p -> volume_registration.lvname = ""
	then goto EXIT;
	if verify (rtrim (p -> volume_registration.lvname), LVNAME_LEGAL) ^= 0
	then goto EXIT;
	if ^aim_check_$in_range (p -> volume_registration.access_class_range (2), access_class_range)
	then goto EXIT;
	if ^aim_check_$in_range (p -> volume_registration.access_class_range (1), access_class_range)
	then goto EXIT;
	if ^aim_check_$greater_or_equal (p -> volume_registration.access_class_range (2),
	     p -> volume_registration.access_class_range (1))
	then goto EXIT;
	if p -> volume_registration.volume_owner = ""
	then goto EXIT;
	if p -> volume_registration.acs_path ^= ""
	then do;
	     call expand_pathname_ ((p -> volume_registration.acs_path), dn, en, ec2);
	     if ec2 ^= 0
	     then do;
		ec = ec2;
		goto EXIT;
	     end;
	     j = length (rtrim (en));
	     if substr (en, j - 3, 4) ^= ".acs"
	     then goto EXIT;
	end;

/* we'll leave validation of "npv" up to our caller */

/* passed all tests */
	ec = 0;
	return;

     end check_lv;

/* -------------------------------------------------- */

check_new_lv:					/* validate NEW LV registration data */
     proc (p);

dcl     p			 ptr;

	call check_lv (p);				/* will return if all OK */

	if p -> volume_registration.npv ^= 1
	then do;
	     ec = error_table_$bad_arg;
	     goto EXIT;
	end;

	ec = 0;
	return;

     end check_new_lv;

/* -------------------------------------------------- */

check_pv:						/* validate PV registration data */
     proc (p);

dcl     p			 ptr;			/* points to pv_registration structure */

	ec = error_table_$bad_arg;
	if p -> pv_registration.pvid = "0"b
	then goto EXIT;
	if p -> pv_registration.model > hbound (MODELN, 1) |
	     p -> pv_registration.model < lbound (MODELN, 1)
	then goto EXIT;
	if verify (rtrim (p -> pv_registration.pvname), PVNAME_LEGAL) ^= 0
	then goto EXIT;
	if p -> pv_registration.location = ""
	then p -> pv_registration.location = "uninitialized";
	if p -> pv_registration.mfg_serial = ""
	then p -> pv_registration.mfg_serial = "uninitialized";
	if p -> pv_registration.date_registered > clock () | p -> pv_registration.date_registered < SMALL_DT
	then goto EXIT;
						/* the two bits of "password" may be anything */

	ec = 0;
	return;

     end check_pv;

/* -------------------------------------------------- */

check_new_pv:					/* validate registration data for NEW PV */
     proc (p);

dcl     p			 ptr;

	call check_pv (p);
						/* no special data checks for new PVs at this time */
	return;

     end check_new_pv;

/* -------------------------------------------------- */

name_exists:					/* see if name exists in given directory */
     proc (dname, ename) returns (bit (1));

dcl     dname		 char (*);
dcl     ename		 char (*);

	call hcs_$status_minf (dname, ename, 0, type, bc, ec2);
	if ec2 ^= 0
	then return ("0"b);
	else return ("1"b);

     end name_exists;

/* -------------------------------------------------- */

locate_:						/* find and set pointer to registration database */
     proc (name, lvflag, dont_init_it);

dcl     name		 char (*);
dcl     (lvflag, dont_init_it) bit (1);


	if lvflag
	then do;
	     if name = "root"
	     then
		dn = ROOT;
	     else dn = LV_DIR;
	     en = "lv." || name;
	end;
	else do;
	     if name = "rpv"
	     then
		dn = ROOT;
	     else dn = LV_DIR;
	     en = "pv." || name;
	end;

	call cu_$level_get (old_level);
	call cu_$level_set (get_ring_ ());		/* SET LEVEL FOR OUR CALLER */

	if ^dont_init_it
	then do;
	     call hcs_$initiate (dn, en, "", 0, 0, databasep, ec);
						/* Locate volume registration for p|lv */
	     if ec = error_table_$segknown
	     then do;
						/* program error */
		call announce_syserr_code (ec, "Database - ""^a"".", en);
		ec = 0;
	     end;
	     else if ec ^= 0
	     then do;
		ec = error_table_$unregistered_volume;
		goto EXIT;
	     end;

	     vrp = databasep;			/* this database is "volume_registration" */
	     if volume_registration.version ^= Volume_Registration_Version_2
	     then do;
		call convert_database (ec);
		if ec ^= 0
		then goto EXIT;
	     end;
	end;

     end locate_;

/* -------------------------------------------------- */

locate_uid_:					/* find registration and set pointer based on LVID or PVID */
     proc (uid, lvflag, dont_init_it);

dcl     uid		 bit (36) aligned;
dcl     (lvflag, dont_init_it) bit (1);

	dn = LV_DIR;				/* we don't know whether it's a root volume
						   or not.  However, the LV_DIR contains links
						   for all the unique names ... */

	if lvflag
	then en = "lvid." || unique_chars_ ((uid));
	else en = "pvid." || unique_chars_ ((uid));

	call cu_$level_get (old_level);
	call cu_$level_set (get_ring_ ());		/* SET LEVEL FOR OUR CALLER */

	if ^dont_init_it
	then do;
	     call hcs_$initiate (dn, en, "", 0, 0, databasep, ec);
						/* Locate volume registration for p|lv */
	     if ec = error_table_$segknown
	     then do;
						/* program error */
		call announce_syserr_code (ec, "Database - ""^a"".", en);
		ec = 0;
	     end;
	     else if ec ^= 0
	     then do;
		ec = error_table_$unregistered_volume;
		goto EXIT;
	     end;

	     vrp = databasep;			/* this database is "volume_registration" */
	     if volume_registration.version ^= Volume_Registration_Version_2
	     then do;
		call convert_database (ec);
		if ec ^= 0
		then goto EXIT;
	     end;
	end;

     end locate_uid_;

/* -------------------------------------------------- */

get_lve:						/* routine to update Logical Volume entry in disk_table */
     proc () returns (fixed bin);

/* This entry modifies "disk_table" on behalf of the following entries:

   check_volume_registration
   find
   get_lv_pvinfo
   lvname_info

*/

dcl     (freex, j)		 fixed bin init (0);
dcl     found		 bit (1) init ("0"b);
dcl     lvx		 fixed bin;

	do j = 1 to dt.n_lv_entries while (^found);
	     lvep = addr (dt.lv_array (j));
	     if ^lve.used
	     then if freex = 0
		then freex = j;
		else ;
	     else if lve.lvname = volume_registration.lvname
	     then do;
		lvx = j;
		found = "1"b;
	     end;
	end;
	if ^found
	then do;
	     if freex = 0
	     then freex, dt.n_lv_entries = dt.n_lv_entries + 1;
	     lvx = freex;
	     lvep = addr (dt.lv_array (freex));
	     unspec (lve) = ""b;
	     lve.used = "1"b;
	end;
	else lvep = addr (dt.lv_array (lvx));

/* Always make sure disk table is up to date with our manipulations */

	lve.public = volume_registration.public;
	lve.lvid = volume_registration.lvid;
	lve.lvname = volume_registration.lvname;
	lve.min_access_class = volume_registration.access_class_range (1);
	lve.max_access_class = volume_registration.access_class_range (2);

	return (lvx);

     end get_lve;

/* -------------------------------------------------- */

convert_database:					/* routine to convert from version 1 to version 2 database */
     procedure (a_ec);

dcl     a_ec		 parameter fixed bin (35);
dcl     temp_class		 bit (72) aligned;

	if volume_registration.version ^= 1
	then a_ec = error_table_$improper_data_format;
	else do;
						/* switch access class values */
	     temp_class = volume_registration.access_class_range (1);
	     volume_registration.access_class_range (1) = volume_registration.access_class_range (2);
	     volume_registration.access_class_range (2) = temp_class;
	     volume_registration.version = Volume_Registration_Version_2;
	     call announce_syserr ("Converted "">lv>lv.^a"" to version 2.", volume_registration.lvname);
	     a_ec = 0;
	end;

	return;

     end convert_database;

/* -------------------------------------------------- */


/* ************************************************** */
/* This is the main exit for all entries              */
/* ************************************************** */

EXIT:
	call clean_up;
	return;

/* -------------------------------------------------- */

test:
     entry (a_dn);

/* PUT US IN TEST MODE - i.e. don't use the real databases */

	ROOT, LV_DIR = a_dn;
	testing = "1"b;

	return;

/* ------------------------------ */

test2:
     entry (a_dn, a_dn2);

/* same as above entry, except ROOT and LV_DIR may be specified differently */

	ROOT = a_dn;
	LV_DIR = a_dn2;
	testing = "1"b;

	return;
%page;
%include aim_privileges;
%page;
%include volume_registration;
%page;
%include disk_table;
%page;
%include create_branch_info;
%page;
%include fs_dev_types;
%page;
%include syserr_constants;
%page;
%include access_mode_values;
%page;
%include delete_options;
%page;
/* BEGIN MESSAGE DOCUMENTATION

   Message:
   volume_registration_mgr_$ENTRY: Attempting to get second temp segment. (GROUP_ID)

   S:	$info

   T:	$run

   M:	$err
   All entrypoints to volume_registration_mgr_ require at most one
   temporary segment.

   A:	$contact


   Message:
   volume_registration_mgr_$ENTRY: Database - {lvid.UNIQUE | lv.LVNAME | pvid.UNIQUE | pv.PVNAME}. (GROUP_ID) Segment already known to process.

   S:	$info

   T:	$run

   M:	$err
   The inner ring module always trerminates references to the database segments
   upon return to its caller.  It found the specified segment already initiated
   upon entry to the specified routine.

   A:	$contact


   Message:
   volume_registration_mgr_$ENTRY: Unable to release temp segment. (GROUP_ID) ERROR_MESSAGE

   S:	$info

   T:	$run

   M:	$err
   Some unexpected state is preventing the module from releasing its temporary
   segment.

   A:	$contact


   Message:
   volume_registration_mgr_$ENTRY: Unable to terminate database reference. (GROUP_ID) ERROR_MESSAGE

   S:	$info

   T:	$run

   M:	$err
   Some unexpected state is preventing the module from terminating reference
   to a database segment.

   A:	$contact


   Message:
   volume_registration_mgr_$ENTRY: Unexpected error occurred.  Database may be in an inconsistant state. (GROUP_ID)

   S:	$info

   T:	$run

   M:	$err
   Some unexpected condition was signalled while the module was executing.

   A:	$contact


   Message:
   volume_registration_mgr_$add_lvr: Added new LV "LVNAME". (GROUP_ID)

   S:	$log

   T:	$run

   M:	A new storage system logical volume has been registered on the system.

   A:	$ignore


   Message:
   volume_registration_mgr_$add_lvr: Added new PV "PVNAME" to LV "LVNAME". (GROUP_ID)

   S:	$log

   T:	$run

   M:	A new storage system physical volume has been registered on the system.

   A:	$ignore


   Message:
   volume_registration_mgr_$add_lvr: Could not append link for {LV name | LVID | PV name | PVID}. (GROUP_ID) ERROR_MESSAGE

   S:	$info

   T:	$run

   M:	A link could not be added into >lv whose target is a database segment
   located under the root directory.  Future database references may not be
   possible.

   A:	$contact


   Message:
   volume_registration_mgr_$add_lvr: Unable to back out database "lv.LVNAME". (GROUP_ID) ERROR_MESSAGE

   S:	$info

   T:	$run

   M:	When attempting to register a new logical volume, some error occurred.
   The entry then attempted to remove the database segment just created.  This
   removal failed.

   A:	$contact


   Message:
   volume_registration_mgr_$add_pvr: Added new PV "PVNAME" to LV "LVNAME". (GROUP_ID) -log-

   S:	$log

   T:	$run

   M:	A new storage system physical volume has been registered on the system.

   A:	$ignore


   Message:
   volume_registration_mgr_$add_pvr: Could not append link for {PV name| PVID}. (GROUP_ID) ERROR_MESSAGE

   S:	$info

   T:	$run

   M:	A link could not be added into >lv whose target is a database segment
   located under the root directory.  Future database references may not be
   possible.

   A:	$contact


   Message:
   volume_registration_mgr_$add_pvr: Extra PV entry "PVNAME" in database "lv.LVNAME". (GROUP_ID)

   S:	$info

   T:	$run

   M:	$err
   An entry for the specified PV was found in the database segment for
   the specified LV where no segment addname indicated its existance.

   A:	$contact


   Message:
   volume_registration_mgr_$add_pvr: Unable to back out database addname "pv.PVNAME". (GROUP_ID) ERROR_MESSAGE

   S:	$info

   T:	$run

   M:	An error occurred while registering a new PV.  The entry attmpts to
   undo all work up to the point of the error.  In this case, it was unable to
   undo its manipulations and left a spurious addname "pv.PVNAME" on the
   database segment.

   A:	$contact


   Message:
   volume_registration_mgr_$change_lvr: Changed ACS pathname for LV "LVNAME" to "PATH". (GROUP_ID)

   S:	$log

   T:	$run

   M:	The registered ACS pathname of a storage system logical volume has been
   changed as indicated.

   A:	$ignore


   Message:
   volume_registration_mgr_$change_lvr: Changed LV "LVNAME" to {PRIVATE | PUBLIC}. (GROUP_ID)

   S:	$log

   T:	$run

   M:	The access type of the specified logical volume has been changed.

   A:	$ignore


   Message:
   volume_registration_mgr_$change_lvr: Changed LVID of LV "LVNAME" from "LVID1" to "LVID2". (GROUP_ID)

   S:	$log

   T:	$run

   M:	The registered logical volume unique ID has been changed for the
   specified LV.

   A:	$ignore


   Message:
   volume_registration_mgr_$change_lvr: Changed name of LV "LVNAME1" to "LVNAME2". (GROUP_ID)

   S:	$log

   T:	$run

   M:	The registered name of a storage system logical volume has been
   changed as indicated.

   A:	$ignore


   Message:
   volume_registration_mgr_$change_lvr: Changed owner of LV "LVNAME" from "Person1.Project1" to "Person2.Project2". (GROUP_ID)

   S:	$log

   T:	$run

   M:	The owner of a storage system logical volume has been changed as indicated.

   A:	$ignore


   Message:
   volume_registration_mgr_$change_lvr: Changed {max | min} access class of LV "LVNAME" from "AUTH_STR1" to "AUTH_STR2". (GROUP_ID)

   S:	$log

   T:	$run

   M:	The access class of a storage system logical volume has been changed as indicated.

   A:	$ignore


   Message:
   volume_registration_mgr_$change_lvr: Couldn't {delete | create} link for {old | new} {LV name | LVID}. (GROUP_ID) ERROR_MESSAGE

   S:	$info

   T:	$run

   M:	A link for the specified database segment residing under the root
   directory could not be created in >lv.

   A:	$contact


   Message:
   volume_registration_mgr_$change_lvr: Unable to back out LVID change to "LVNAME.mdcs". (GROUP_ID) ERROR_MESSAGE

   S:	$info

   T:	$run

   M:	$err
   While changing attributes of the logical volume LVNAME, an error was
   encountered.  The entry then attempted to remove some changes already
   made to the registration database.  In this case, it could not remove
   the LVID change to the master directory control database LVNAME.mdcs.

   A:	$contact


   Message:
   volume_registration_mgr_$change_lvr: Unable to change name "lv.LVNAME1" back to "lv.LVNAME2" (GROUP_ID) ERROR_MESSAGE

   S:	$info

   T:	$run

   M:	$err
   While changing attributes ot the logical volume LVNAME, an error was
   encountered.  The entry then attempted to remove some changes already
   made to the registration database.  In this case, it could not remove
   theLV name change.

   A:	$contact


   Message:
   volume_registration_mgr_$change_lvr: Unable to change name "lvid.UNIQUE1" back to "lvid.UNIQUE2". (GROUP_ID) ERROR_MESSAGE

   S:	$info

   T:	$run

   M:	$err
   While changing attributes ot the logical volume LVNAME, an error was
   encountered.  The entry then attempted to remove some changes already
   made to the registration database.  In this case, it could not remove
   LVID name change.

   A:	$contact


   Message:
   volume_registration_mgr_$change_lvr: Unable to convert {max | min} auth to name_string. (GROUP_ID) ERROR_MESSAGE

   S:	$info

   T:	$run

   M:	$err
   A binary authorization string could not be converted to its readable
   representation.

   A:	$contact


   Message:
   volume_registration_mgr_$change_lvr: Unexpected error changing name on "lv.LVNAME". (GROUP_ID) ERROR_MESSAGE

   S:	$info

   T:	$run

   M:	$err
   An unexpected error occured while changing the name on an LV registration
   data segment.  The message explains the trouble.

   A:	$contact


   Message:
   volume_registration_mgr_$change_lvr: Unexpected trouble changing name "lvid.UNIQUE". (GROUP_ID) ERROR_MESSAGE

   S:	$info

   T:	$run

   M:	$err
   An unexpected error occured while changing the name on an LV registration
   data segment.  The message explains the trouble.

   A:	$contact


   Message:
   volume_registration_mgr_$change_pvr: Changed PVID of PV "PVNAME" from "PVID1" to "PVID2" (GROUP_ID)

   S:	$log

   T:	$run

   M:	The registered physical volume unique IFD has been changed as indicated.

   A:	$ignore


   Message:
   volume_registration_mgr_$change_pvr: Changed date_registered of PV "PVNAME" from "DT1" to "DT2". (GROUP_ID)

   S:	$log

   T:	$run

   M:	The registered date for the specified PV has been changed as indicated.

   A:	$ignore


   Message:
   volume_registration_mgr_$change_pvr: Changed location of PV "PVNAME" from "LOC1" to "LOC2". (GROUP_ID)

   S:	$log

   T:	$run

   M:	The registered location of the specified PV has been changed as indicated.

   A:	$ignore


   Message:
   volume_registration_mgr_$change_pvr: Changed mfg_serial of PV "PVNAME" from "STR1" to "STR2". (GROUP_ID)

   S:	$log

   T:	$run

   M:	The registered serial of the specified PV has been changed as indicated.

   A:	$ignore


   Message:
   volume_registration_mgr_$change_pvr: Changed model of PV "PVNAME" from "TYPE1" to "TYPE2". (GROUP_ID)

   S:	$log

   T:	$run

   M:	The registered model number of the specified PV has been changed as indicated.

   A:	$ignore


   Message:
   volume_registration_mgr_$change_pvr: Changed name of PV "PVNAME1" to "PVNAME2". (GROUP_ID)

   S:	$log

   T:	$run

   M:	The registered name of the specified PV has been changed as indicated.

   A:	$ignore


   Message:
   volume_registration_mgr_$change_pvr: Changed password of PV "PVNAME". (GROUP_ID)

   S:	$log

   T:	$run

   M:	The registered password of the specified PV has been changed as indicated.

   A:	$ignore


   Message:
   volume_registration_mgr_$change_pvr: Couldn't {delete | create} link for {old | new} {PV name | PVID}. (GROUP_ID) ERROR_MESSAGE

   S:	$info

   T:	$run

   M:	A link for a database segment residing in the root directory could
   not be created in >lv.  This may make some registration data inaccessible.

   A:	$contact


   Message:
   volume_registration_mgr_$change_pvr: PV entry missing from database "pv.PVNAME". (GROUP_ID)

   S:	$info

   T:	$run

   M:	$err
   An entry for the specified PV could not be found in the data segment although
   an addname for that PV exists on the segment entry.

   A:	$contact


   Message:
   volume_registration_mgr_$change_pvr: Unable to back out PVID change. (GROUP_ID) ERROR_MESSAGE

   S:	$info

   T:	$run

   M:	While making changes to the registered PV attributes an error was encountered.
   The module attempts to remove any work already done on other attributes.
   For reasons given in ERROR_MESSAGE the PVID change could not be removed.

   A:	$contact


   Message:
   volume_registration_mgr_$change_pvr: Unexpected trouble changing name "pv.PVNAME". (GROUP_ID) ERROR_MESSAGE

   S:	$info

   T:	$run

   M:	While making changes to the registered PV attributes an error was encountered.
   The module attempts to remove any work already done on other attributes.
   For reasons given in ERROR_MESSAGE the PV name change could not be removed.

   A:	$contact


   Message:
   volume_registration_mgr_$change_pvr: Unexpected trouble changing name "pvid.UNIQUE". (GROUP_ID) ERROR_MESSAGE

   S:	$info

   T:	$run

   M:	An unexpected state made the program unable to change the database
   name associated with the PV unique ID.

   A:	$contact


   Message:
   volume_registration_mgr_$check_volume_registration: ERROR_MESSAGE. cannot re-create >lv

   S:	$info

   T:	$init

   M:	When the system is bootloaded, it checks
   the list of packs which were mounted during the last bootload
   to make sure that each one has a valid logical and physical volume registration.
   If the registration does not exist, the registration files are reconstructed.
   These registration files reside in the directory >lv,
   which is also remade if it was lost or did not exist.
   .sp
   This message indicates that there is a problem in re-creating >lv.
   Other error messages will follow and reregistration will fail.

   A:	$inform


   Message:
   volume_registration_mgr_$check_volume_registration: ERROR_MESSAGE. Putting LV dir on RPV

   S:	$info

   T:	$init

   M:	When the system is bootloaded, it checks
   the list of packs which were mounted during the last bootload
   to make sure that each one has a valid logical and physical volume registration.
   While re-creating >lv, the system attempted to
   set the directory flag which means "RPV only"
   and failed to do so.

   A:	$inform


   Message:
   volume_registration_mgr_$check_volume_registration: ERROR_MESSAGE.  Cannot add SysAdmin access to >lv.

   S:	$info

   T:	$init

   M:	After creating a new >lv directory, an attempt is made to add
   "sma" access for *.SysAdmin.*.  This failed.

   A:	$inform


   Message:
   volume_registration_mgr_$check_volume_registration: ERROR_MESSAGE. Cannot reregister pv PVNAME

   S:	$info

   T:	$init

   M:	When the system is bootloaded, it checks
   the list of packs which were mounted during the last bootload
   to make sure that each one has a valid logical and physical volume registration.
   .sp
   The system was unable to re-register the physical volume PVNAME
   because its logical volume entry could not be located in the old disk_table
   and its physical volume registration file could not be found.
   The volume will have to be re-registered manually.

   A:	If PVNAME is garbage, ignore this message.
   Otherwise, use add_vol_registration to re-register the volume.


   Message:
   volume_registration_mgr_$check_volume_registration: ERROR_MESSAGE. Cannot reregister lv LVNAME

   S:	$info

   T:	$init

   M:	When the system is bootloaded, it checks
   the list of packs which were mounted during the last bootload
   to make sure that each one has a valid logical and physical volume registration.
   .sp
   The system was unable to append a branch for
   >lv>lv.LVNAME.
   The logical volume will have to be re-registered manually.

   A:	Use the add_vol_registration command
   to re-register the volume manually.


   Message:
   volume_registration_mgr_$check_volume_registration:  ERROR_MESSAGE.  PATH

   S:	$info

   T:	$init

   M:	An error occurred when trying to reclassify a new lv.** seg
   as a multi-class system segment.

   A:	$inform


   Message:
   volume_registration_mgr_$check_volume_registration: Reregistered TYPE lv LVNAME lvid WWWW

   S:	$info

   T:	$init

   M:	When the system is bootloaded, it checks
   the list of packs which were mounted during the last bootload
   to make sure that each one has a valid logical and physical volume registration.
   The registration file for LVNAME
   did not exist and was reconstructed.
   .sp
   This message is always produced for the root logical volume during a cold boot of the Multics hierarchy.

   A:	Use the list_vol_registration command
   to list the registration and check it against the
   re-created copy.
   Correct it with change_vol_registration if necessary.


   Message:
   volume_registration_mgr_$check_volume_registration: Code N. lv.LVNAME disagreed with disk_table. It was rebuilt.

   S:	$info

   T:	$init

   M:	When the system is bootloaded, it checks
   the list of packs which were mounted during the last bootload
   to make sure that each one has a valid logical and physical volume registration.
   The registration file lv.LVNAME was found
   but disagreed with the disk_table_, and so it was corrected.
   The meaning of the codes can be determined from the
   listing of volume_registration_mgr_; it is rarely important.

   A:	Use list_vol_registration to examine the remade
   registration, and correct it with change_vol_registration if necessary.


   Message:
   volume_registration_mgr_$check_volume_registration: ERROR_MESSAGE. Cant add name lvid.UNIQUE to lv.LVNAME

   S:	$info

   T:	$init

   M:	When the system is bootloaded, it checks
   the list of packs which were mounted during the last bootload
   to make sure that each one has a valid logical and physical volume registration.
   The registration file for LVNAME did not have the additional name
   constructed from the volume unique ID,
   and an error was discovered trying to add it.
   If this name is on another segment, confusion will result.

   A:	$inform
   Enter admin mode and
   do a "list >lv>**"
   command.


   Message:
   volume_registration_mgr_$check_volume_registration: ERROR_MESSAGE. Cannot make mdcs for LVNAME

   S:	$info

   T:	$init

   M:	When the system is bootloaded, it checks
   the list of packs which were mounted during the last bootload
   to make sure that each one has a valid logical and physical volume registration.
   An error occurred while reconstructing
   LVNAME.mdcs.
   Operation on master directories for LVNAME may encounter problems.

   A:	$inform_sa


   Message:
   volume_registration_mgr_$check_volume_registration: ERROR_MESSAGE. Cant add name pv.PVNAME to LVNAME

   S:	$info

   T:	$init

   M:	When the system is bootloaded, it checks
   the list of packs which were mounted during the last bootload
   to make sure that each one has a valid logical and physical volume registration.
   .sp
   An error occurred adding the name pv.PVNAME to >lv>lv.LVNAME.
   If this name is missing or on another segment, confusion will result.

   A:	$inform
   Enter admin mode and do a
   "list >lv>**"
   command.


   Message:
   volume_registration_mgr_$check_volume_registration: Reregistered pv PVNAME pvid WWWW in lv LVNAME

   S:	$info

   T:	$init

   M:	When the system is bootloaded, it checks
   the list of packs which were mounted during the last bootload
   to make sure that each one has a valid logical and physical volume registration.
   Registration for PVNAME was added to
   the registration file for LVNAME.
   .sp
   This message is always produced for the root physical volume, rpv, during a cold boot of the Multics hierarchy.

   A:	Use the list_vol_registration command
   to check the registration.
   If necessary, correct it with change_vol_registration.


   Message:
   volume_registration_mgr_$check_volume_registration: Registration for PVNAME was different from disk_table

   S:	$info

   T:	$init

   M:	When the system is bootloaded, it checks
   the list of packs which were mounted during the last bootload
   to make sure that each one has a valid logical and physical volume registration.
   The physical volume ID or model number of PVNAME
   was wrong in the registration files and was corrected.

   A:	$inform_sa


   Message:
   volume_registration_mgr_$check_volume_registration: ERROR_MESSAGE. Cant add name pvid.UNIQUE to LVNAME

   S:	$info

   T:	$init

   M:	When the system is bootloaded, it checks
   the list of packs which were mounted during the last bootload
   to make sure that each one has a valid logical and physical volume registration.
   An error occurred adding the name pvid.UNIQUE to >lv>lv.LVNAME.
   If this name is missing or is on another segment, confusion will result.

   A:	$inform
   Enter admin mode and do a
   "list >lv>**"
   command.


   Message:
   volume_registration_mgr_$delete_lvr: Could not remove {PV name | PVID | LV name | LVID} database link. (GROUP_ID) ERROR_MESSAGE

   S:	$info

   T:	$run

   M:	An unexpected state prevented the program from removing the database
   links associated with an LV just deleted.  The links (in >lv) should be
   removed by hand using Ring_1_Repair.

   A:	$contact


   Message:
   volume_registration_mgr_$delete_lvr: Deleted LV "LVNAME". (GROUP_ID)

   S:	$log

   T:	$run

   M:	The registration for the spcified logical volume has been removed.

   A:	$ignore


   Message:
   volume_registration_mgr_$delete_lvr: Deleted PV "PVNAME" from LV "LVNAME". (GROUP_ID)

   S:	$log

   T:	$run

   M:	The registration for the specified physical volume was removed while
   removing the entire logical volume registration.

   A:	$ignore


   Message:
   volume_registration_mgr_$delete_lvr: Unable to delete MDCS "LVNAME.mdcs". (GROUP_ID) ERROR_MESSAGE

   S:	$info

   T:	$run

   M:	After deleting the registration for a logical volume the module was
   unable to delete the corresponding master directory control database indicated
   in the message.

   A:	$contact


   Message:
   volume_registration_mgr_$delete_pvr: Could not remove {PV name | PVID} database link. (GROUP_ID) ERROR_MESSAGE

   S:	$info

   T:	$run

   M:	An unexpected state prevented the removal of database links associated
   with a PV registration that was just deleted.  The links should be deleted
   by hand using Ring_1_Repair.

   A:	$contact


   Message:
   volume_registration_mgr_$delete_pvr: Deleted PV "PVNAME" from LV "LVNAME". (GROUP_ID)

   S:	$log

   T:	$run

   M:	The registration fo the specified PV has been deleted.

   A:	$ignore


   Message:
   volume_registration_mgr_$delete_pvr: PV entry missing from database "pv.PVNAME". (GROUP_ID)

   S:	$info

   T:	$run

   M:	$err
   The entry for the specified PV could not be located in the database
   segment although its name appears on the segment entry.

   A:	$contact


   Message:
   volume_registration_mgr_$delete_pvr: Trimming registration. (GROUP_ID) ERROR_MESSAGE

   S:	$info

   T:	$run

   M:	An unexpected state prevented the trimming of a registration database
   segment.  This will not hinder subsystem performance.

   A:	$contact


   Message:
   volume_registration_mgr_$delete_pvr: Unable to replace database name "pv.PVNAME". (GROUP_ID) ERROR_MESSAGE

   S:	$info

   T:	$run

   M:	$err
   While deleting the registration for the specified PV an error occurred.
   The program attempts to undo any changes to "leave things as they were."
   The attempt to put back the database segment name (as indicated) failed.

   A:	$contact


   Message:
   volume_registration_mgr_$find: PV entry missing from "pv.PVNAME". (GROUP_ID)

   S:	$info

   T:	$run

   M:	$err
   The entry for the specified PV could not be found in the registration database
   segment although the name appears on the segment's entry.

   A:	$contact


   Message:
   volume_registration_mgr_$find_volname: PV entry not found in database "pvid.UNIQUE". (GROUP_ID)

   S:	$info

   T:	$run

   M:	$err
   The entry for the specified PV could not be found in the registration database
   segment although the name appears on the segment's entry.

   A:	$contact


   Message:
   volume_registration_mgr_$get_access: ACS not segment - "PATH". (GROUP_ID)

   S:	$info

   T:	$run

   M:	The ACS indicated in the logical volume registration database is
   not a segment.  The database entry should be corrected using "change_volume_registration".

   A:	$contact_sa


   Message:
   volume_registration_mgr_$get_access: Bad ACS path in database "lv.LVNAME". (GROUP_ID) ERROR_MESSAGE

   S:	$info

   T:	$run

   M:	$err
   The ACS pathname entry in the LVNAME database is illegal.  This should not
   happen normally because the ring-1 primitives check all paths before
   entering them into the database.

   A:	$contact


   Message:
   volume_registration_mgr_$pvname_info: PV entry not found in database "pv.PVNAME". (GROUP_ID)

   S:	$info

   T:	$run

   M:	$err
   The entry for the specified PV could not be found in the registration database
   segment although the name appears on the segment's entry.

   A:	$contact


   Message:
   volume_registration_mgr_$read_pvr: PV entry missing from database "pv.PVNAME". (GROUP_ID)

   S:	$info

   T:	$run

   M:	$err
   The entry for the specified PV could not be found in the registration database
   segment although the name appears on the segment's entry.

   A:	$contact


   END MESSAGE DOCUMENTATION */

     end volume_registration_mgr_;
