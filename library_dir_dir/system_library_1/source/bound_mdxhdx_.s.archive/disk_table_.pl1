/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/****^  HISTORY COMMENTS:
  1) change(86-06-05,GJohnson), approve(86-06-05,MCR7387),
     audit(86-06-10,Martinson), install(86-07-17,MR12.0-1091):
     Correct error message documentation.
  2) change(86-06-30,Fawcett), approve(86-06-30,MCR7383),
     audit(86-06-30,LJAdams), install(86-07-17,MR12.0-1097):
     Add support for subvolumes, 3380 and 3390.
  3) change(88-04-18,Farley), approve(88-05-26,MCR7880),
     audit(88-06-07,Parisek), install(88-07-05,MR12.2-1052):
     Corrected problem in dry_run_mhv execution by removing the zeroing of the
     return error code in MHV, which was making the dry run appear to succeed.
     Also corrected several coding violations.
                                                   END HISTORY COMMENTS */

/* format: style2,^inddcls,indcomtxt */

disk_table_:
     proc;

/* DISK_TABLE_ - manage the system's Disk Table.

   This program is called by system_startup_ and sc_command_
   to manage a table parallel to the PVT
   which contains the long names of volumes
   and various other management information.

   Atually this program is just message typing and arg counting.. see mdx for the real stuff.

   This program refers to "hv" and "hvol" which mean Hierarchy Volume.
   The new term is "Logical Volume", which means the same thing.

   See MTB-213 by Bernie Greenberg for the design.

   By Tom VanVleck, and Bernie Greenberg.
   Modified April 1976 by Greenberg for demounter, parallel drive assignment, new salv interface (28-4).
   Modified September 1976 by Greenberg for auto mhvs by lv_request, init_vol -no_reg.
   Modified December 1976 by Greenberg for dte.demounted, mhv drive selector recoded.
   Modified March 1977 by Greenberg for init_vol -copy, ss_io_reconfig.
   Modified February 1977 by Greenberg for init_vol -copy.
   Modified July 1977 by T. Casey to add set_lv_pdir_bit entry.
   Modified August 1981 by J. Bongiovanni to improve synchronization of the
   various copies of the disk table
   Modified December 1981 by J. Bongiovanni to allow mounting LVEs on mhv dry run
   Modified April 1982 by J. Bongiovanni for better init_vol argument parsing
   Modified 831122 by E. A. Ranzenbach for set_vacate_pdirs_bit entry.
   Modified 84-08-29 by EJ Sharpe for auto registration of RLV PVs during cold boot
   Modified 84-10-30 by EJ Sharpe for some minor fixes
   Modified 85-01-31 by Keith Loepere for real error codes.
   Modified 1985-04-02, BIM: don't suggest drives for non-demountable
   disks. Report missing root physical volumes at accept_rlv time.
   (Note that those messages will be repeated each time that
   system_startup_ calls $accept_rlv.)
   Modified 04/85 by RAF to support subvolumes.
*/


dcl     (i, j)		 fixed bin,
        demount_problem	 bit (1),
        took		 bit (1),
        (lpv, llv, bfsw, ldrive)
			 bit (1),			/* for list entry */
        copy_sw		 bit (1) aligned,
        rlv_sw		 bit (1) aligned,
        fb71		 fixed bin (71),
        ap		 ptr,
        al		 fixed bin,
        bchr		 char (al) based (ap),
        pvap		 ptr,
        npv		 fixed bin,
        match_dtx		 fixed bin,		/* Used in dt scan */
        trial		 fixed bin,		/* 1ce for no *offs, 2 for yes */
        mhvtest_lvx		 fixed bin,		/* for referencecounting vols */
        tpvtx		 fixed bin,		/* for mhv error drive */
        last_sv		 fixed bin,
        pvname		 char (32),
        pvname1		 char (32),
        lvname		 char (32),
        drive_arg		 char (8) aligned,
        publicstr		 char (10),
        drivea		 char (2),
        drive_id		 char (8),
        arg		 char (64),
        arg_list_ptr	 ptr,
        ignore_num		 fixed bin,
        ignore_ec		 fixed bin (35),
        ec		 fixed bin (35);

dcl     (a_pvname, a_copydrive, a_drive, a_lvname)
			 char (*) parm;

dcl     new		 bit (1);			/* TRUE if made new disk_table */
dcl     sdtp		 ptr static init (null);
dcl     cu_$level_get	 entry (fixed bin);
dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin, fixed bin (35));
dcl     cu_$arg_list_ptr	 entry (ptr);
dcl     level		 fixed bin;

dcl     1 pva		 (100) based (pvap) aligned,
	2 pvname		 char (32),
	2 device_type	 fixed bin,
	2 pad		 fixed bin;

dcl     1 pvinfo		 aligned like pv_registration;

dcl     (
        ARG1		 fixed bin init (1),
        ARG2		 fixed bin init (2),
        STOP_MOUNT		 fixed bin init (1),
        START_DEMOUNT	 fixed bin init (2),
        FINISH_DEMOUNT	 fixed bin init (3)
        )			 internal static options (constant);

dcl     (
        ioa_,
        ioa_$rsnnl
        )			 entry options (variable);
dcl     com_err_		 entry options (variable);
dcl     hcs_$make_seg	 entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
dcl     disk_table_$accept_rlv entry (fixed bin (35));
dcl     lv_request_$dhv	 entry (char (*));
dcl     lv_request_$mhv_complete
			 entry (fixed bin, ptr);
dcl     disk_rebuild_caller	 entry (ptr, fixed bin, fixed bin, bit (36) aligned);
dcl     initializer_mdc_$rlvolcheck
			 entry (fixed bin, fixed bin, bit (36) aligned, fixed bin (35));
dcl     initializer_mdc_$init	 entry (ptr, bit (1), fixed bin (35));
dcl     initializer_mdc_$get_lv_pvinfo
			 entry (char (*), ptr, fixed bin, fixed bin, fixed bin (35));
dcl     initializer_mdc_$mhv	 entry (fixed bin, fixed bin, fixed bin (35));
dcl     initializer_mdc_$demount_lv
			 entry (fixed bin, fixed bin, fixed bin (35));
dcl     initializer_mdc_$demount_pv
			 entry (fixed bin, fixed bin (35));
dcl     initializer_mdc_$take	 entry (char (*), fixed bin, bit (1), fixed bin (35));
dcl     initializer_mdc_$assert
			 entry (char (*), fixed bin, fixed bin (35));
dcl     initializer_mdc_$volsalv
			 entry (char (*), fixed bin, bit (36) aligned, fixed bin (35));
dcl     initializer_mdc_$forget
			 entry (fixed bin, fixed bin (35));
dcl     initializer_mdc_$set_lv_pdir_bit
			 entry (char (*), bit (1) aligned, fixed bin (35));
dcl     initializer_mdc_$set_vacate_pdirs_bit
			 entry (char (*), bit (1) aligned, fixed bin (35));
dcl     initializer_mdc_$ss_io_reconfig
			 entry (fixed bin, bit (1) aligned, fixed bin (35));
dcl     init_disk_pack_	 entry (ptr, ptr, fixed bin, ptr, fixed bin (35));
dcl     init_disk_pack_$parse_args
			 entry (ptr, char (*), char (*), bit (1) aligned, bit (1) aligned, fixed bin (35));
dcl     initializer_mdc_$read_disk_table
			 entry (ptr, fixed bin (35));
dcl     volume_registration_mgr_$add_pvr
			 entry (char (*), ptr, fixed bin (35));
dcl     disk_table_$accept_all entry (fixed bin (35));
dcl     mdx$reregister	 entry (char (*), fixed bin, fixed bin (35));

dcl     (addr, clock, length, null, rtrim, substr, unspec, char, verify)
			 builtin;

dcl     error_table_$unregistered_volume
			 fixed bin (35) ext;
dcl     error_table_$action_not_performed
			 fixed bin (35) ext;

/* ======================================================== */

init:
     entry (rc);					/* called by system_startup_ */

dcl     rc		 fixed bin (35);		/* errcode */
dcl     rce		 bit (1);			/* sw for rc entries */

	rce = "1"b;
	call initializer_mdc_$init (sdtp, new, rc);
	if new
	then call com_err_ (rc, "disk_table_", "New disk_table created");
	else if rc ^= 0
	then call com_err_ (rc, "disk_table_", "");

	return;

/* -------------------------------------------------------- */

accept_all:
     entry (rc);

	rce = "1"b;
	rc = 0;

	call copy_disk_table ();
	do i = 1 to dt.n_entries;
	     dtep = addr (dt.array (i));
	     if ^dte.used
	     then /* Take only unused volumes */
		if dte.storage_system & ^dte.deleted
		then if dte.known | dte.pre_accepted
		     then do;
			     call initializer_mdc_$take ((dte.pvname), i, took, ec);
			     if ec ^= 0
			     then call print_error;
			     if ec ^= 0
			     then rc = ec;		/* Remember if any screwed up */
			     else if took & dte.lvx ^= 1
			     then call announce_mount ((dte.lvx));
			end;
	end;
	return;

/* -------------------------------------------------------- */

general_mhv:
     entry (rc);					/* Entry to induce a general mhv, and report results */

	rce = "1"b;
	call mhv ("-all");				/* start the mhvs */
	call copy_disk_table ();
	do i = 1 to dt.n_lv_entries;			/* Scan the lve array */
	     lvep = addr (dt.lv_array (i));
	     if lve.used & ^lve.hv_mounted & ^lve.demounted_only
	     then do;
		     rc = error_table_$action_not_performed;
		     call com_err_ (0, "disk_table_", "Some volumes are incomplete. Complete or demount them.");
		     return;
		end;
	end;
	rc = 0;
	return;


accept_rlv:
     entry (rc);

/**** NOTE: this procedure does not do the "find a free drive and
      request a mount" thing that the normal "alv" command does.
      Operators must always tell US where root LV pv's are to be
      found. Could/should this be changed? --BIM */

	rce = "1"b;
	rc = 0;
	call copy_disk_table ();
	call initializer_mdc_$mhv ((dt.array (dt.rpvx).lvx), tpvtx, rc);
	ec = rc;
	if rc ^= 0
	then do;
		if tpvtx > 0
		then do;
			dtep = addr (dt.array (tpvtx));
			call print_error;		/* Still return the code and prevent exit to ring 4 */
		     end;
		else call list_missing_rlv_pvs;	/* whether code is 1 (missing vol) or something else, the call to get_lv_pvinfo will detect it. */
						/* our caller just tests the code for 0 */
		rc = 1;
	     end;
	return;

list_missing_rlv_pvs:
     procedure;

	call copy_disk_table ();
	call initializer_mdc_$get_lv_pvinfo ("root", pvap, npv, ignore_num, ec);
						/* Read the registry */
	if ec ^= 0
	then do;					/* Impossible! */
		call com_err_ (ec, "disk_table_",
		     "Cannot get volume registration info for the root logical volume.^/ Shutdown and reboot with ""boot nolv""."
		     );
		return;
	     end;

	call ioa_ ("The root logical volume is incomplete.");
	call MHV ("root", "0"b, 0);			/* Find some drives, print some messages */
	return;

     end list_missing_rlv_pvs;


accept:
     entry;

	rce = "0"b;
	call cu_$arg_ptr (ARG1, ap, al, ec);
	if ec ^= 0
	then go to gruz;
	if bchr = "-all" | bchr = "-a"
	then do;
		call disk_table_$accept_all (ignore_ec);
		return;
	     end;
	pvname = bchr;
	call cu_$arg_ptr (ARG2, ap, al, ec);
	if ec ^= 0
	then do;
gruz:
		call com_err_ (ec, "disk_table_", "");
ret:
		if rce
		then rc = ec;
		return;
	     end;
	call parse_drive_id (bchr);
	call verify_drive;				/* check drive for free */

	call initializer_mdc_$take (pvname, i, took, ec);
	call copy_disk_table ();
	if ec ^= 0
	then call print_error;
	else if took
	then call announce_mount ((dte.lvx));
	else if dt.array (i).used
	then if dt.array (i).lvx ^= 1
	     then call ioa_ ("added pv ^a to mounted lv ^a.", pvname, dt.lv_array (dt.array (i).lvx).lvname);
	return;



mount_hvol:
mhv:
     entry options (variable);

	rce = "0"b;
	call cu_$arg_ptr (ARG1, ap, al, ec);
	if ec ^= 0
	then go to gruz;
	call copy_disk_table ();
	if bchr = "-all" | bchr = "-a"
	then do;
		do j = 1 to dt.n_lv_entries;
		     lvep = addr (dt.lv_array (j));
		     if lve.used & ^lve.hv_mounted & ^lve.demounted_only
		     then do;
			     call mhv ((lve.lvname));
			     call copy_disk_table ();
			end;
		end;
		return;
	     end;
	lvname = bchr;
	j = 0;					/* -1 suppresses lve creation */
	call initializer_mdc_$get_lv_pvinfo (lvname, pvap, npv, j, ec);
	if ec ^= 0
	then do;
		call com_err_ (ec, "disk_table_", "^a", lvname);
		return;
	     end;
	call copy_disk_table ();
	lvep = addr (dt.lv_array (j));
	if lve.hv_mounted
	then do;
		call com_err_ (0, "disk_table_", "lv ^a already mounted", lvname);
		return;
	     end;
	else if lve.demounting
	then do;
		call com_err_ (0, "disk_table_", "lv ^a cannot be mounted, in process of demount.", lvname);
		return;
	     end;
	call initializer_mdc_$mhv (j, tpvtx, ec);
	call copy_disk_table ();
	if ec = 0
	then do;
		call announce_mount (j);
		return;
	     end;
	else if tpvtx > 0
	then do;
		dtep = addr (dt.array (tpvtx));
		call print_error;

	     end;

	call MHV (lvname, "0"b, 0);			/* test is off */
	return;

/* --------------------------------------------------------- */

dry_run_mhv:
     entry (a_lvname, rc);

	lvname = a_lvname;
	rce = "1"b;
	j = 0;
	call initializer_mdc_$get_lv_pvinfo (lvname, pvap, npv, j, ec);
	if ec ^= 0
	then do;
		rc = ec;				/* He'll get tired after a while */
		return;
	     end;

	rc = 0;					/* show initial success */

/* do NOT copy disk table -- lv_request_ is munging current copy for test purposes */

	dtp = sdtp;

	do i = 1 to dt.n_lv_entries while (dt.lv_array (i).lvname ^= lvname);
	end;
	if i > dt.n_lv_entries
	then do;					/* Put phony one in there */
		dt.n_lv_entries = i;
		lvep = addr (dt.lv_array (i));
		unspec (lve) = "0"b;
		lve.lvname = lvname;
	     end;

	mhvtest_lvx = i;
	dt.lv_array (mhvtest_lvx).mounting = "1"b;	/* Note elegant effect upon mhvver */

	call MHV (lvname, "1"b, mhvtest_lvx);		/* this sets rc */
	return;



/**** Assume that pva and npv are set on entry to this procedure */

MHV:
     procedure (lvname, mhvtest, mhvtest_lvx);

declare mhvtest		 bit (1) aligned;
declare mhvtest_lvx		 fixed bin;
declare lvname		 char (*);

	do i = 1 to npv;
	     call MHV_ONE_PV;
	end;
	return;

MHV_ONE_PV:
     procedure;					/* i is global parm (ycch) specifying which pv */

declare (found, found_good_drive)
			 bit (1) aligned;

	pvname = pva (i).pvname;			/* for calls &c */
	found = "0"b;				/* set to one iff we find it mounted */
	found_good_drive = "0"b;			/* set to one iff we have a drive in mind to mount it on */

/**** NOTE: the following assumes that there can only be one dte
      with a given PV name in the entire disk table. */

	do j = 1 to dt.n_entries while (^found & ^found_good_drive);
	     dtep = addr (dt.array (j));
	     if dte.pvname = pvname
	     then if dte.used | dte.known
		then found = "1"b;			/* its already mounted */
		else if dte.pre_accepted | dte.demounted
		then found_good_drive = "1"b;

/**** + ASSUME: pv names are unique across the system.
      no pv can be listed twice in the disk table.

      THEN:   if this entry has our pv name, is available for
      storage system use, then it will be either already
      known (test above) or free, since no other LV
      could claim it. Thus it is the last place that we
      saw this disk pack. Since disk packs are notorious
      for their tendency to stay where one leaves them,
      we should tell the operator to spin it up HERE. */

		else if dte.storage_system & ^dte.deleted & (dte.device_type = pva (i).device_type)
		then found_good_drive = "1"b;
	end;

	if ^found
	then do;

		if ^found_good_drive & media_removable (pva (i).device_type)
						/* we can search for a good drive for 451's */
						/* for non-demountables we either know where it was */
						/* or stay mute, to avoid fatuous suggestions. */
		then do trial = 1 to 3 while (^found_good_drive);
			do j = 1 to dt.n_entries while (^found_good_drive);
			     dtep = addr (dt.array (j));
						/*  Here are usability criteria */
			     if dte.storage_system & ^dte.deleted
						/** available at all */
				& ^(dte.used | dte.known)
						/** not in use already */
				& dte.device_type = pva (i).device_type
						/** the right kind */
			     then if (^(dte.pre_accepted & dt.lv_array (dte.lvx).mounting)
						/** we can't be planning to mount something else here */
				     | (mhvtest & dt.lv_array (dte.lvx).good_candidate))
						/** unless this is a dry run and we propose to demount this lv */
				     & ^((trial = 1) & dte.demounted)
						/** dont unseat in pass 1, we might mount it again */
				     & ^((trial < 3) & dte.pre_accepted)
						/** we are trying to mount something else here */
				then found_good_drive = "1"b;
			end;
		     end;


/**** We arrive here directly if the first loop found that the
      drive that the pack used to be on is available. In that
      case found_good_drive will be on. If the first loop found nothing,
      then found_good_drive will be on if the second loop found
      a place to put the pack. For a non-demountable pack,
      the second loop does not run, and we never set found_good_drive. */

		if found_good_drive
		then do;
			j = j - 1;		/* both loops fall out of the bottom after do has bumped the index */
						/* dtep is ok */
			if mhvtest
			then do;			/* claim tbl spot */
				dte.pre_accepted = "1"b;
				dte.demounted = "0"b;
				dte.lvx = mhvtest_lvx;
				dte.pvname = pvname;
			     end;
			else do;			/* assume for real */
				if dte.pre_accepted
				then ec = 0;
				else do;
					call initializer_mdc_$assert (pvname, j, ec);
					call copy_disk_table;
					if ec ^= 0
					then call print_error;
				     end;
				if ec = 0
				then call ioa_ ("mount pack ^a on ^a", dte.pvname, dte.drive_name);
			     end;
		     end;				/* End of found_good_drive case */
		else if media_removable (pva (i).device_type)
		then do;				/* If we couldn't suggest a drive for a 451, its an error. */
			if mhvtest
			then do;			/* no drive avl */
				rc = 1;		/* experiment failed */
				return;
			     end;
			else call ioa_ ("disk_table_: no drive available for ^a of ^a", pvname, lvname);
		     end;
		else do;				/* its a fixed disk, so we report the problem and claim success. The site must have a home for it someplace */
			if mhvtest
			then /* only mhvtest has an rc */
			     rc = 0;
			call ioa_ ("mount pack ^a.", pva (i).pvname);
		     end;
	     end;
	return;
     end MHV_ONE_PV;

     end MHV;


/* ------------------------------------------------------- */

get_dtp:
     entry returns (ptr);

	rce = "0"b;
	call copy_disk_table ();
	return (dtp);

/* -------------------------------------------------------- */


set_lv_pdir_bit:
     entry (a_lvname, a_bit, rc);

dcl     a_bit		 bit (1) aligned parm;

	rce = "1"b;
	call initializer_mdc_$set_lv_pdir_bit (a_lvname, a_bit, rc);
	call copy_disk_table ();
	return;


/* -------------------------------------------------------- */


set_vacate_pdirs_bit:
     entry (a_lvname, a_bit, rc);

	rce = "1"b;
	call initializer_mdc_$set_vacate_pdirs_bit (a_lvname, a_bit, rc);
	call copy_disk_table ();
	return;


/* -------------------------------------------------------- */

initialize_disk:
     entry;

	rce = "0"b;
	call cu_$arg_list_ptr (arg_list_ptr);
	call init_disk_pack_$parse_args (arg_list_ptr, drive_id, pvname1, copy_sw, rlv_sw, ec);
	if ec ^= 0
	then goto ret;

	call parse_drive_id (drive_id);

	if copy_sw
	then pvname = "";
	else pvname = pvname1;
	call verify_drive;				/* Check drive not in use, pvname not is use, set ptrs */


	if copy_sw
	then do;
		do j = 1 to dt.n_entries
		     while (
		     ^(dt.array (j).pvname = pvname1 & dt.array (j).storage_system
		     & (dt.array (j).used | dt.array (j).known | dt.array (j).pre_accepted)));
		end;
		if j > dt.n_entries
		then do;
			call ioa_ ("disk_table_: ^a not found.", pvname1);
			return;
		     end;
		dtep = addr (dt.array (j));
	     end;
	else do;
		call initializer_mdc_$assert (pvname1, i, ec);
		if ec = error_table_$unregistered_volume & rlv_sw
		then do;				/* rlv_sw will be on if operator supplied the "-rlv"
						   control to "init_vol" AND if we're running in
						   ring 1 AND we're in the midst of a cold boot.
						   We will automatically register the PV on the
						   root LV.  This will allow the initial system
						   to have a multi pack RLV.
						*/
			fb71 = clock ();
			pvinfo.pvid = substr (unspec (fb71), 36, 36);
			pvinfo.model = dte.device_type;
						/* will be stuck with this */
			pvinfo.pvname = pvname1;
			pvinfo.location = drive_id;
			pvinfo.mfg_serial = "registered at cold boot";
			pvinfo.date_registered = fb71;
			pvinfo.password = ""b;	/* register the PV */
			call volume_registration_mgr_$add_pvr ("root", addr (pvinfo), ec);
			if ec ^= 0
			then do;
				call print_error;	/* nothing we can do, must retry cold boot */
				return;
			     end;
			call initializer_mdc_$assert (pvname1, i, ec);
						/* try it again, with registration */
		     end;
		call copy_disk_table ();
		if ec ^= 0
		then do;
			call print_error;
			return;
		     end;

	     end;
	call init_disk_pack_ (dtp, dtep, i, arg_list_ptr, ec);
	return;

/* ------------------------------------------------------- */

reregister:
     entry;

	rce = "0"b;
	call cu_$level_get (level);
	if level ^= 1
	then do;
		call ioa_ ("disk_table_: cannot reregister from ring 4");
		return;
	     end;
	call cu_$arg_ptr (ARG1, ap, al, ec);
	if ec ^= 0
	then go to gruz;
	pvname = bchr;
	call cu_$arg_ptr (ARG2, ap, al, ec);
	if ec ^= 0
	then go to gruz;
	call parse_drive_id (bchr);
	call verify_drive;				/* Check drive not in use */

	call mdx$reregister (pvname, i, ec);
	if ec ^= 0
	then if ec < 100
	     then call print_error;
	     else call com_err_ (ec, "disk_table_", "error reregistering ^a", drive_arg);
	return;

/* -------------------------------------------------------- */

demount_hvol:
     entry;
dhv:
     entry (a_lvname);

	rce = "0"b;
	call cu_$arg_ptr (ARG1, ap, al, ec);
	if ec ^= 0
	then go to gruz;

	lvname = bchr;

	call copy_disk_table ();

	do j = 1 to dt.n_lv_entries while (^dt.lv_array (j).used | (dt.lv_array (j).lvname ^= lvname));
	end;
	if j > dt.n_lv_entries
	then do;
		call com_err_ (0, "disk_table_", "lv ^a not found", lvname);
		return;
	     end;

	lvep = addr (dt.lv_array (j));

	if lve.mounting
	then do;
		call initializer_mdc_$demount_lv (j, STOP_MOUNT, ec);
		call copy_disk_table ();
		if ec ^= 0
		then do;
			call com_err_ (ec, "disk_table_", "cannot stop mount of ^a", lvname);
			return;
		     end;

		call lv_request_$dhv (lvname);

		call copy_disk_table ();

		if lve.demounting & lve.lvname = lvname /* potential interlock? */
		then call ioa_ ("disk_table_: demounting partially mounted volume ^a", lvname);
		else do;
			call ioa_ ("mount of ^a stopped", lvname);
			return;
		     end;
	     end;
	else if lve.demounting
	then call ioa_ ("continuing demount of lv ^a", lvname);
	else if ^lve.hv_mounted
	then do;
		call ioa_ ("lv ^a is not mounted", lvname);
		return;
	     end;
	else if lve.pdirs_ok
	then do;
		call ioa_ (" lv ^a may contain process directories. Will not be demounted.", lvname);
		return;
	     end;
	else do;
		call lv_request_$dhv (lvname);
		call initializer_mdc_$demount_lv (j, START_DEMOUNT, ec);
		call copy_disk_table ();
		if ec ^= 0
		then do;
			call com_err_ (ec, "disk_table_", "Cannot demount lv ^a.", lvname);
			return;
		     end;
	     end;

	demount_problem = "0"b;

	do i = 1 to dt.n_entries;
	     dtep = addr (dt.array (i));
	     if (dte.lvx = j) & dte.used & dte.storage_system
	     then do;
		     call initializer_mdc_$demount_pv (i, ec);
		     call copy_disk_table ();
		     if ec ^= 0
		     then do;
			     demount_problem = "1"b;
			     call com_err_ (ec, "disk_table_", "Could not demount pv ^a of lv ^a (^a)", dte.pvname,
				lve.lvname, dte.drive_name);
			end;
		end;
	end;

	if demount_problem
	then call com_err_ (0, "disk_table_", "Could not finish demount of lv ^a", lvname);
	else do;
		call initializer_mdc_$demount_lv (j, FINISH_DEMOUNT, ec);
		call copy_disk_table ();
		if ec ^= 0
		then call com_err_ (ec, "disk_table_", "Could not finish demount of lv ^a", lvname);
		else call ioa_ ("demounted lv ^a", lvname);
	     end;
	return;

/* -------------------------------------------------------- */

remove:
     entry;

	rce = "0"b;
	call cu_$arg_ptr (1, ap, al, ec);
	if ec ^= 0
	then go to gruz;
	if bchr = "-all" | bchr = "-a"
	then do;
		call copy_disk_table ();
		do i = 1 to dt.n_entries;
		     dtep = addr (dt.array (i));
		     if dte.storage_system & ^dte.deleted & ^dte.used & (dte.known | dte.pre_accepted)
		     then do;
			     call initializer_mdc_$forget (i, ec);
			     call copy_disk_table ();
			end;
		end;
		return;
	     end;
	call parse_drive_id (bchr);

	call copy_disk_table ();
	do i = 1 to dt.n_entries;
	     dtep = addr (dt.array (i));
	     if dte.drive_name = drive_arg
	     then do;
		     if ^dte.storage_system
		     then call ioa_ ("disk_table_: ^a is an IO drive", drive_arg);
		     else if dte.deleted
		     then call ioa_ ("disk_table_: ^a is deleted", drive_arg);
		     else if dte.used
		     then call ioa_ ("disk_table_: ^a in use with ^a", drive_arg, dte.pvname);
		     else if dte.pre_accepted | dte.known
		     then do;
			     call initializer_mdc_$forget (i, ec);
			     call copy_disk_table ();
			end;
		     else call ioa_ ("disk_table_: ^a not in use.", dte.drive_name);
		     return;
		end;
	end;
	call ioa_ ("disk_table_: cannot locate ^a", drive_arg);
	return;

/* ------------------------------------------------------- */

io_ss_reconfig:
     entry;

	rce = "0"b;
	call cu_$arg_ptr (ARG1, ap, al, ec);
	if ec ^= 0
	then go to gruz;

	call parse_drive_id (bchr);

	call cu_$arg_ptr (ARG2, ap, al, ec);
	if ec ^= 0
	then go to gruz;

	if ^(bchr = "io" | bchr = "ss" | bchr = "storage_system")
	then do;
		call ioa_ ("disk_table_: ""^a"" is not ""io"", ""storage_system"", or ""ss"".", bchr);
		return;
	     end;

	call copy_disk_table;
	do i = 1 to dt.n_entries while (substr (dt.array (i).drive_name, 1, 7) ^= drive_arg);
	end;
	if i > dt.n_entries
	then do;
		call ioa_ ("disk_table_: ^a not found.", drive_arg);
		return;
	     end;
	if dt.array (i).is_sub_vol
	then do;
		last_sv = (i + dt.array (i).num_of_sv) - 1;
	     end;
	else do;
		last_sv = i;
	     end;

	do i = i to last_sv;
	     call initializer_mdc_$ss_io_reconfig (i, (substr (bchr, 1, 1) = "i"), ec);
	     call copy_disk_table ();
	     if ec ^= 0
	     then call com_err_ (ec, "disk_table_");
	end;
	return;

/* --------------------------------------------------------- */

list:
     entry;

	rce = "0"b;
	lpv, llv, bfsw, ldrive = "0"b;
	call cu_$arg_ptr (ARG1, ap, al, ec);
	if ec = 0
	then do;
		if bchr = "-pv"
		then do;
			lpv = "1"b;
			call cu_$arg_ptr (ARG2, ap, al, ec);
			if ec ^= 0
			then go to gruz;
			arg = bchr;
		     end;
		else if bchr = "-bf" | bchr = "-brief"
		then bfsw = "1"b;
		else if bchr = "-mounts" | bchr = "-mt"
		then do;
			call copy_disk_table;
			go to list_hvols;
		     end;
		else if bchr = "-lv" | bchr = "-hv"
		then do;
			llv = "1"b;
			call cu_$arg_ptr (ARG2, ap, al, ec);
			if ec ^= 0
			then go to gruz;
			arg = bchr;
		     end;
		else do;
			ldrive = "1"b;
			call parse_drive_id (bchr);
		     end;
	     end;

	call copy_disk_table ();
	do i = 1 to dt.n_entries;
	     dtep = addr (dt.array (i));
	     if ldrive & (dte.drive_name ^= drive_arg)
	     then go to skip;
	     lvep = addr (dt.lv_array (dte.lvx));
	     if lve.hv_mounted
	     then lvname = lve.lvname;
	     else call ioa_$rsnnl ("(^a)", lvname, ignore_num, lve.lvname);
	     if ^dte.storage_system
	     then if dte.deleted
		then if ldrive
		     then call ioa_ ("^a (deleted io drive)", dte.drive_name);
		     else ;
		else call ioa_ ("^a (io drive)", dte.drive_name);
	     else if dte.deleted
	     then if ldrive
		then call ioa_ ("^a deleted", drive_arg);
		else ;
	     else do;
		     if lpv & (^(dte.used | (dte.known | dte.pre_accepted)) | (dte.pvname ^= arg))
		     then go to skip;
		     if llv & ((^lve.used) | (lve.lvname ^= arg))
		     then go to skip;
		     if dte.used
		     then call ioa_ ("^a ^8a ^8a", dte.drive_name, dte.pvname, lvname);
		     else if dte.known
		     then call ioa_ ("^a ^8a ^8a ***", dte.drive_name, dte.pvname, lvname);
		     else if dte.pre_accepted
		     then call ioa_ ("^a ^8a ^8a *", dte.drive_name, dte.pvname, lvname);
		     else if llv | bfsw
		     then go to skip;
		     else call ioa_ ("^a", dte.drive_name);
		end;
skip:
	end;
	if llv | lpv | ldrive
	then return;				/* List out mounts and demounts in progresss */

list_hvols:
	do i = 1 to dt.n_lv_entries;
	     lvep = addr (dt.lv_array (i));
	     if lve.public
	     then publicstr = "public";
	     else publicstr = "private";
	     if lve.mounting
	     then call ioa_ ("^7a lv ^a mount in progress", publicstr, lve.lvname);
	     if lve.demounting
	     then call ioa_ ("^7a lv ^a demount in progress", publicstr, lve.lvname);
	end;
	return;

/* --------------------------------------------------------------- */

volsalv:
     entry (a_pvname, a_drive, salv_opt_bits, rc);

	rce = "1"b;
	pvname = a_pvname;
	ap = addr (a_drive);
	al = length (a_drive);
	rc = 1;
	call parse_drive_id (bchr);
	if salv_opts.check
	then do;
		call disk_table_$accept_rlv (ec);
		if ec ^= 0
		then do;
			call copy_disk_table ();
			go to ret;
		     end;
	     end;

	call verify_drive;				/* change args to dtx */

	call initializer_mdc_$volsalv (pvname, i, salv_opt_bits, ec);
	call copy_disk_table ();
	if ec > 0 & ec < 100
	then do;
		call print_error;
		ec = error_table_$action_not_performed;
	     end;
	rc = ec;
	return;

/* ------------------------------------------------------- */

volsalvall:
     entry (salv_opt_bits, rc);

	rce = "1"b;
	if salv_opts.check
	then do;
		call disk_table_$accept_rlv (ec);
		if ec ^= 0
		then do;
			call copy_disk_table ();
			go to ret;
		     end;
	     end;

	call copy_disk_table ();

	do i = 1 to dt.n_entries;
	     dtep = addr (dt.array (i));
	     if ^dte.used
	     then if dte.storage_system & ^dte.deleted & ^dte.used & (dte.known | dte.pre_accepted)
		then do;
			pvname = dte.pvname;
			call initializer_mdc_$volsalv (pvname, i, salv_opt_bits, ec);
			if ec ^= 0
			then if ec < 100
			     then call print_error;
			     else call com_err_ (ec, "disk_table_", "salvaging ^a on ^a", pvname, dte.drive_name);
		     end;
	end;

	call copy_disk_table ();

	return;

/* -------------------------------------------------------------------- */

volrlvcheck:
     entry (a_pvname, a_drive, a_copydrive, salv_opt_bits, rc);

dcl     rbldsw		 bit (1) aligned;

	rbldsw = "0"b;
	goto copy_vol;

rbld_disk:
     entry (a_pvname, a_drive, a_copydrive, salv_opt_bits, rc);

	rbldsw = "1"b;

copy_vol:
	rce = "1"b;
	call copy_disk_table ();
	ap = addr (a_copydrive);
	al = length (a_copydrive);
	rc = 1;
	call parse_drive_id (bchr);
	pvname = "";				/* verify object drive */
	call verify_drive;
	j = i;
	if dte.pre_accepted
	then call initializer_mdc_$forget (j, ignore_ec);

	pvname = a_pvname;
	ap = addr (a_drive);
	al = length (a_drive);
	call parse_drive_id (bchr);
	do i = 1 to dt.n_entries;
	     if dt.array (i).drive_name = drive_arg
	     then go to vlrlvc1;
	end;

	call com_err_ (0, "disk_table_", "cannot locate ^a", drive_arg);
	rc = 4;
	return;
vlrlvc1:
	dtep = addr (dt.array (i));
	if dte.used & (dte.pvname = pvname)
	then ;
	else do;
		call verify_drive;

		call initializer_mdc_$take (pvname, i, took, rc);
		if rc ^= 0
		then do;
			call copy_disk_table ();
			return;
		     end;
	     end;

	call copy_disk_table ();
	dtep = addr (dt.array (i));

	if ^rbldsw
	then if dte.lvx ^= 1
	     then do;
		     call com_err_ (0, "disk_table_", "^a is not part of root volume", pvname);
		     return;
		end;

	rc = 0;
	if salv_opts.check
	then do;
		call disk_table_$accept_rlv (ec);
		if ec ^= 0
		then do;
			call copy_disk_table ();
			go to ret;
		     end;
	     end;
	call copy_disk_table ();

	if rbldsw
	then call disk_rebuild_caller (dtp, i, j, salv_opt_bits);
	else call initializer_mdc_$rlvolcheck (i, j, salv_opt_bits, rc);
	return;

/* --------------------------------------------------------------- */
salv_flag:
     entry () returns (bit (1));

	rce = "0"b;
	call copy_disk_table ();
	do i = 1 to dt.n_entries;
	     dtep = addr (dt.array (i));
	     if dte.storage_system & ^dte.deleted & dte.used & (dte.lvx = 1)
	     then if dte.need_salvage
		then return ("1"b);
	end;
	return ("0"b);				/* All clean */

parse_drive_id:
     proc (drive_id);

dcl     drive_id		 char (*);
dcl     id_len		 fixed bin;

	id_len = length (rtrim (drive_id));
	if char (drive_id, 3) ^= "dsk" | id_len < 7
	then do;
faugh:
		call ioa_ ("disk_table_: invalid drive id ""^a""", drive_id);
		ec = 10;
		go to ret;
	     end;
	if id_len >= 9
	then goto faugh;
	drive_arg = drive_id;
	if substr (drive_id, 5, 1) ^= "_"
	then go to faugh;
	drivea = substr (drive_id, 6, 2);
	if drivea = ""
	then go to faugh;
	if verify (drivea, "0123456789") ^= 0
	then go to faugh;
	if id_len = 8
	then do;
		if verify (substr (drive_id, 8, 1), valid_sv_string) ^= 0
		then goto faugh;
	     end;

     end parse_drive_id;

verify_drive:
     procedure;					/* Int proc to check not-in-use drive */

	call copy_disk_table ();
	match_dtx = -1;
	do i = 1 to dt.n_entries;			/* Search for named volume */
	     dtep = addr (dt.array (i));
	     if ^dte.storage_system & (drive_arg = dte.drive_name)
	     then do;
		     call ioa_ ("disk_table_: ^a is an IO drive", drive_arg);
		     ec = 5;
		     go to ret;
		end;
	     else if dte.deleted & (drive_arg = dte.drive_name)
	     then do;
		     call ioa_ ("disk_table_: ^a is deleted", drive_arg);
		     ec = 4;
		     go to ret;
		end;
	     else if dte.used
	     then do;
		     if dte.pvname = pvname
		     then do;			/* If already in table, error */
			     call ioa_ ("disk_table_: ^a already in use on ^a.", pvname, dte.drive_name);
			     ec = 1;
			     go to ret;
			end;
		     else if dte.drive_name = drive_arg
		     then do;			/* if somebody else on there */
			     call ioa_ ("disk_table_: ^a in use: contains ^a", drive_arg, dte.pvname);
			     ec = 2;
			     go to ret;
			end;
		     else ;
		end;
	     else if dte.known & (dte.pvname = pvname) & (dte.drive_name ^= drive_arg)
	     then do;
		     call ioa_ ("disk_table_: ^a currently known to be on  ^a.", pvname, dte.drive_name);
		     ec = 3;
		     go to ret;
		end;
	     else if dte.drive_name = drive_arg
	     then match_dtx = i;			/* Unused */
	end;

	if match_dtx > 0
	then do;					/* If we found it */
		dtep = addr (dt.array (match_dtx));
		i = match_dtx;
		return;
	     end;
	call ioa_ ("disk_table_: cannot locate ^a", drive_arg);
	ec = 4;
	go to ret;
     end verify_drive;

print_error:
     proc;
	call com_err_ (ec, "disk_table_", "Cannot verify label of ^a", dte.drive_name);

     end print_error;

copy_disk_table:
     proc ();

/* This internal procedure is called whenever a fresh copy of the disk_table
   is needed in the user ring... */

	call cu_$level_get (level);
	if level = 1
	then dtp = sdtp;
	else do;
		if sdtp = null
		then call hcs_$make_seg ("", "", "", 1011b, sdtp, ignore_ec);
		dtp = sdtp;
		call initializer_mdc_$read_disk_table (dtp, ignore_ec);
	     end;
	pvap = addr (dt.lv_array (dt.max_n_entries + 1));

     end copy_disk_table;

announce_mount:
     proc (lvxa);

dcl     lvxa		 fixed bin;

	call ioa_ ("lv ^a mounted", dt.lv_array (lvxa).lvname);
	if lvxa ^= 1
	then /* Not for the root */
	     call lv_request_$mhv_complete (lvxa, dtp);
     end;

%include fs_dev_types;
%include disk_table;

%include salv_options;

%include volume_registration;

/* BEGIN MESSAGE DOCUMENTATION

   Message:
   disk_table_: no drive available for PVNAME LVNAME

   S:	$initializer_io

   T:	$run

   M:	An alv LVNAME command was unable to allocate a drive for PVNAME.

   A:	Demount some un-needed logical volume and try again.


   Message:
   disk_table_: PVNAME not found.

   S:	$initializer_io

   T:	$run

   M:	An initialize_disk -copy command could not find the source volume.

   A:	$tryagn


   Message:
   disk_table_: cannot reregister from ring 4

   S:	$initializer_io

   T:	$run

   M:	A reregister command was issued from ring 4.

   A:	$tryagn


   Message:
   disk_table_: demounting partially mounted volume LVNAME

   S:	$initializer_io

   T:	$run

   M:	The operator issued a dlv LVNAME command
   for a logical volume for which a previous dlv command did not succeed.

   A:	$ignore


   Message:
   mount of LVNAME stopped

   S:	$initializer_io

   T:	$run

   M:	The operator issued a dlv LVNAME command for a volume which was being mounted.

   A:	$ignore


   Message:
   lv LVNAME is not mounted

   S:	$initializer_io

   T:	$run

   M:	The operator issued a dlv LVNAME command but LVNAME was not mounted.

   A:	$tryagn


   Message:
   continuing demount of lv LVNAME

   S:	$initializer_io

   T:	$run

   The operator issued a dlv command for a logical volume for which a previous dlv command failed.

   A:	$ignore


   Message:
   demounted lv LVNAME

   S:	$initializer_io

   T:	$run

   M:	The demount of the logical volume LVNAME is complete.

   A:	$ignore


   Message:
   disk_table_: DRIVENAME is an IO drive

   S:	$initializer_io

   T:	$run

   M:	The operator issued a del_vol command but the
   drive is an IO drive.

   A:	$tryagn


   Message:
   disk_table_: DRIVENAME is deleted

   S:	$initializer_io

   T:	$run

   M:	A del_vol command was issued
   but the drive has been deleted.

   A:	$tryagn


   Message:
   disk_table_: DRIVE in use with PVNAME

   S:	$initializer_io

   T:	$run

   M:	A del_vol DRIVE command was issued
   but the drive is currently in use.

   A:	$tryagn
   To demount the pack,
   use the dlv command.


   Message:
   disk_table_: DRIVE not in use.

   S:	$initializer_io

   T:	$run

   M:	A del_vol command was issued
   but nothing is on the drive.

   A:	$tryagn


   Message:
   disk_table_: cannot locate DRIVE

   S:	$initializer_io

   T:	$run

   M:	A del_vol DRIVE command was issued
   but there is no such drive in the configuration.

   A:	$tryagn


   Message:
   disk_table_: "KEY" is not "io", "storage_system", or "ss".

   S:	$initializer_io

   T:	$run

   M:	The operator issued an set_drive_usage DRIVE KEY command.
   KEY is invalid.

   A:	$tryagn


   Message:
   disk_table_: DRIVE not found.

   S:	$initializer_io

   T:	$run

   M:	The operator issued an set_drive_usage DRIVE KEY command,
   but DRIVE is not in the current configuration.

   A:	$tryagn


   Message:
   disk_table_: invalid drive id "ARG"

   S:	$initializer_io

   T:	$run

   M:	The drive id ARG does not have the form
   dskX_NN.

   A:	$tryagn


   Message:
   disk_table_: DRIVE is an IO drive

   S:	$initializer_io

   T:	$run

   M:	A command has been issued to affect DRIVE,
   but it is currently in use as an IO drive.

   A:	$tryagn
   Use the set_drive_usage command to change it if necessary.


   Message:
   disk_table_: DRIVE is deleted

   S:	$initializer_io

   T:	$run

   M:	The drive named is deleted.

   A:	$tryagn


   Message:
   disk_table_: PVNAME already in use on DRIVE.

   S:	$initializer_io

   T:	$run

   M:	An attempt to add a physical volume
   finds the volume already in use on another drive.

   A:	$tryagn


   Message:
   disk_table_: DRIVE in use: contains PVNAME

   S:	$initializer_io

   T:	$run

   M:	An attempt to
   use DRIVE finds it already in use.

   A:	$tryagn


   Message:
   disk_table_: PVNAME currently known to be on DRIVE

   S:	$initializer_io

   T:	$run

   M:	An attempt to specify that PVNAME
   is on a certain drive
   finds it on another drive.

   A:	$tryagn
   Use the del_vol command if necessary to cause the system to
   forget DRIVE's old contents, if a pack has been moved.


   Message:
   disk_table_: cannot locate DRIVE

   S:	$initializer_io

   T:	$run

   M:	A command specifying DRIVE
   was issued but no such drive can be found.

   A:	$tryagn


   Message:
   lv LVNAME mounted

   S:	$initializer_io

   T:	$run

   M:	The mounting of LVNAME is complete.

   A:	$tryagn


   Message:
   disk_table_: ERROR_MESSAGE. New disk_table created

   S:	$initializer_io

   T:	$init

   M:	The system has created a new copy of the
   segment >disk_table at initialization time.
   The copy from the previous bootload could not be found.
   The position of all previously mounted volumes has been forgotten.

   A:	Use the av command to specify the
   position of all volumes,
   and the alv command to mount them.


   Message:
   disk_table_: ERROR_MESSAGE.

   S:	$initializer_io

   T:	$init

   M:	An error has been returned from
   initializer_mdc_$init.
   $err
   Subsequent attempts to mount volumes may malfunction.

   A:	$contact


   Message:
   disk_table_: Some volumes are incomplete. Complete or demount them.

   S:	$initializer_io

   T:	$init

   M:	Initialization has failed to
   remount all the volumes which were previously known,
   in response to a startup command.

   A:	Use the list_disks command to
   find out which volumes are incomplete.
   Use the av or dlv commands to
   rectify the situation,
   and try startup again.


   Message:
   disk_table_: ERROR_MESSAGE. Cannot get volume registration for the root
   logical volume.
   .brf
   Shutdown and reboot with "boot nolv".

   S:	$initializer_io

   T:	$init

   M:	The system is unable to read the volume registration for the root
   logical volume, and cannot therefore determine if the root is complete.

   A:	Shutdown. If you can mount the entire root, do so, describe all
   volumes on the root config card, "boot stan nosc", and fix the registration. If
   this fails, shutdown, and "boot nolv".


   Message:
   disk_table_: The root logical volume is incomplete.

   S:	$initializer_io

   T:	$init

   M:	Some registered  physical volume(s) of the root logical volume are
   not mounted, but the operator has attempted to execute a command that requires
   the root to be completely mounted. This message is followed by mount messages
   for the missing volumes.


   A:	Mount the missing volumes, and notify the system of their location
   with the add_vol command.


   Message:
   disk_table_: ERROR_MESSAGE.

   S:	$initializer_io

   T:	$run

   M:	An error has occurred in a storage system disk manipulation command.

   A:	$tryagn


   Message:
   disk_table_: ERROR_MESSAGE. LVNAME

   S:	$initializer_io

   T:	$run

   M:	An error occurred trying to get
   the list of physical volumes which comprise LVNAME.

   A:	$tryagn


   Message:
   disk_table_: lv LVNAME already mounted

   S:	$initializer_io

   T:	$run

   M:	An alv LVNAME command
   finds LVNAME already mounted.

   A:	$tryagn


   Message:
   disk_table_: lv LVNAME  cannot be mounted, in process of demount.

   S:	$initializer_io

   T:	$run

   M:	An alv LVNAME command was issued
   but the logical volume is in the process of demounting.

   A:	$tryagn


   Message:
   disk_table_: ERROR_MESSAGE. error reregistering DRIVE

   S:	$initializer_io

   T:	$run

   M:	The reregister DRIVE command did not succeed.

   A:	$tryagn


   Message:
   disk_table_: lv LVNAME not found

   S:	$initializer_io

   T:	$run

   M:	A dlv LVNAME command was issued
   but no such logical volume is mounted.

   A:	$tryagn


   Message:
   disk_table_: ERROR_MESSAGE. cannot stop mount of LVNAME

   S:	$initializer_io

   T:	$run

   M:	A dlv LVNAME command was issued
   but an error prevents the dlv from working.

   A:	$tryagn


   Message:
   disk_table_: ERROR_MESSAGE. Cannot demount lv LVNAME

   S:	$initializer_io

   T:	$run

   M:	A dlv LVNAME command was issued
   but an error prevents the dlv from working.

   A:	$tryagn


   Message:
   disk_table_: ERROR_MESSAGE. Could not demount pv PVNAME of lv LVNAME (DRIVE)

   S:	$initializer_io

   T:	$run

   M:	An error occurred when trying to demount
   a physical volume.
   This may be due to process directory or wired segments being on this physical volume.
   The del_lv command will be partially successful when this happens.

   A: Determine which processes, if any, have
   process directories on this logical volume and bump or terminate them.
   Use list_disks to determine which volumes are still mounted, and try dlv again.
   $inform


   Message:
   disk_table_: Could not finish demount of lv LVNAME

   S:	$initializer_io

   T:	$run

   M:	The system encountered a problem
   trying to delete the
   logical volume LVNAME.

   A:	$inform


   Message:
   disk_table_: ERROR_MESSAGE. salvaging PVNAME on DRIVE

   S:	$initializer_io

   T:	$run

   M:	An error occurred while doing
   a salvage_vol -all.

   A:	$tryagn


   Message:
   disk_table_: cannot locate DRIVE

   S:	$initializer_io

   T:	$run

   M:	A disk_rebuild command cannot locate
   the output drive.

   A:	$tryagn


   Message:
   disk_table_: Cannot verify label of DRIVE: REASON

   S:	$initializer_io

   T:	$run

   M:	An error occurred checking the label of DRIVE.
   Usually either the drive is not ready, or the pack label does not match the required pack label.

   A:	$tryagn


   Message:
   disk_table_: ERROR_MESSAGE. Cannot verify label of DRIVE

   S:	$initializer_io

   T:	$run

   M:	An error occurred checking the label of the pack on DRIVE.
   Usually either the drive is not ready, or the pack label does not match the required pack label.

   A:	$tryagn


   Message:
   added pv PVNAME to mounted lv LVNAME.

   S:	$initializer_io

   T:	$run

   M:	An av command was used to increase the size of a mounted volume.

   A:	$ignore


   Message:
   mount pack PVNAME {on DRIVE}

   S:	$initializer_io

   T:	$run

   M:	This message occurs when the system
   is attempting to mount a logical volume
   and finds one or more physical volumes
   have not been made known via the add_vol command.
   If the pack is a non-demountable volume, a DRIVE
   will only be printed if the system knows the drive on which the pack
   was previously mounted. If the pack is a demountable volume, then
   a DRIVE will be printed always. If the system does not know
   the drive on which the pack was last mounted, then
   it chooses a drive where the pack should be mounted
   and prints this message.

   A:	Mount the pack specified.
   If it is not convenient to use the specified DRIVE,
   use another.
   Then use the add_vol command
   to tell the system that the physical volume has been mounted.
   When all packs have been mounted and either accepted via add_vol
   or are on the drives where the system called for them, issue a "alv LVNAME" command to accept them
   all at once. The logical volume will be put in use.


   END MESSAGE DOCUMENTATION */

     end disk_table_;
