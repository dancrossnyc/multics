/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/* format: style3 */

/**** THE INTERPROCESS COMMUNICATION FACILITY. This procedure is resident in 
      all non-hardcore rings (1:7) to manipulate the event channels of those
      rings. Every ring has its own Event Channel Table (ECT) and Event
      Channel Index Table (ECIT) which is created dynamically when
      ipc_$create_ev_chn is invoked for the first time in that ring.

      IPC manipulates the ECT pointed to either by the validation ring number
      or by the event channel name. Only ipc_$block refers to its
      current-ring's ECT for event-call interrogation, all other calls to
      IPC manipulate the ECT in which the event channel given as argument is
      located, provided that it is not an inner ring. */

/* format: off */

/*
   IPC may return one of the following error codes:

   0 = no error

   error_table_$wrong_channel_ring
     = ring access violation (event channel resides in other than current ring)

   error_table_$invalid_channel
     = event channel not found in ECT (incorrect event channel name)

   error_table_$not_a_wait_channel
     = attempting to wait for event call channel

   error_table_$event_calls_not_masked
     = attempting to unmask event calls when event call already unmasked

   error_table_$event_channel_cutoff
     = attempting to read a channel or go blocked on a group of channels
       all of which have been cutoff 

   error_table_$event_channel_not_cutoff
     = attempting to reconnect a channel which has not been cutoff

   error_table_$bad_arg
     = erroneous argument
*/

/* format: on */

/* 
   Initially coded by the very hands of Michael J. Spier, August 26, 1968
   Rewritten for new ipc by Eleanor Donner Jan 1981 
   Modified September 1981 by J. Bongiovanni to fix the most obscure bug I've 
          ever seen
   Modified September 1983 by Chris Jones to count event calls pending, not all events pending.
   Modified 1984-11-02 by E. Swenson for new IPC event channel validation. 
*/


/****^  HISTORY COMMENTS:
  1) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
     audit(86-10-08,Fawcett), install(86-11-03,MR12.0-1206):
     Changed to support control point management.  These changes were actually
     done in February 1985 by G. Palter.
  2) change(86-08-12,Kissel), approve(86-08-12,MCR7479),
     audit(86-10-08,Fawcett), install(86-11-03,MR12.0-1206):
     Changed to add the create_event_channel and run_event_calls entries to
     support async event channels.
                                                   END HISTORY COMMENTS */


ipc_real_:
     procedure ();
	return;					/* not an entry */

/* Parameters */

dcl	P_create_arg_ptr	ptr parameter;
dcl	P_event_channel_name
			fixed bin (71) parameter;
dcl	P_event_channel_type
			fixed bin parameter;
dcl	P_code		fixed bin (35) parameter;
dcl	P_fast_channel_id	fixed binary (18) parameter;
dcl	P_procedure_ptr	ptr parameter;
dcl	P_event_wait_list_ptr
			ptr parameter;
dcl	P_datap		ptr parameter;
dcl	P_priority	fixed bin (17) parameter;
dcl	P_procedure_entry	entry (ptr) variable parameter;
dcl	P_old_control_point_id
			bit (36) aligned parameter;
dcl	P_new_control_point_id
			bit (36) aligned parameter;
dcl	P_found_event	fixed bin (17) parameter;
dcl	P_event_wait_info_ptr
			ptr parameter;
dcl	P_mask		bit (36) aligned parameter;

/* External Entries */

dcl	continue_to_signal_ entry (fixed bin (35));
dcl	cu_$level_get	entry returns (fixed bin (3));
dcl	cu_$level_set	entry (fixed bin (3));
dcl	cu_$make_entry_value
			entry (ptr, entry);
dcl	get_ring_		entry returns (fixed bin (3));
dcl	hcs_$assign_channel entry (fixed bin (71), fixed bin (35));
dcl	hcs_$delete_channel ext entry (fixed bin (71), fixed bin (35));
dcl	hcs_$fblock	entry (bit (36) aligned, bit (1) aligned);
dcl	hcs_$read_events	entry (bit (36) aligned, bit (1) aligned);
dcl	hcs_$reset_ips_mask entry (bit (36) aligned, bit (36) aligned);
dcl	hcs_$set_ips_mask	entry (bit (36) aligned, bit (36) aligned);
dcl	ipc_util_$create_ect
			entry (ptr);
dcl	ipc_util_$delete_entry
			entry (ptr, ptr);
dcl	ipc_util_$ect_error_handler
			entry (fixed bin (35));
dcl	ipc_util_$make_entry
			entry (ptr, fixed bin (8), ptr, fixed bin (15));
dcl	ipc_util_$verify_channel
			entry (fixed bin (71), ptr, bit (1) aligned, fixed bin (35));
dcl	ipc_util_$verify_regular_channel
			entry (fixed bin (71), ptr, fixed bin (35));
dcl	ipc_validate_$encode_event_channel_name
			entry (fixed bin (18), fixed bin (35), bit (3) aligned, fixed bin (15), fixed bin (3),
			bit (1) aligned, fixed bin (18), fixed bin (71));

/* External Static */

dcl	error_table_$bad_arg
			fixed bin (35) ext;
dcl	error_table_$event_calls_not_masked
			fixed bin (35) ext;
dcl	error_table_$event_channel_cutoff
			fixed bin (35) ext;
dcl	error_table_$event_channel_not_cutoff
			fixed bin (35) ext;
dcl	error_table_$inconsistent_ect
			fixed bin (35) ext;
dcl	error_table_$not_a_wait_channel
			fixed bin (35) ext;
dcl	error_table_$unimplemented_version
			fixed bin (35) ext static;
dcl	ipc_data_$fast_channel_events
			bit (36) aligned ext;
dcl	ipc_data_$event_calls_pending
			fixed bin ext;

/* Automatic */

dcl	added_to_waiting_lists
			bit (1) aligned;
dcl	block_val		fixed bin (3);
dcl	call_channel_procedure
			entry (ptr) variable;
dcl	1 call_info	aligned like event_call_info;
dcl	check_channels	bit (1) aligned;
dcl	cur_ring		fixed bin (3);
dcl	current_control_point_id
			bit (36) aligned;
dcl	ecit_idx		fixed bin (15);
dcl	entry_type	fixed bin (8);
dcl	1 entry_value	aligned,
	  2 ep_ptr	ptr,
	  2 env_ptr	ptr;
dcl	event_call_in_progress
			bit (1) aligned;
dcl	ev_chn_flags	bit (3) aligned;
dcl	event_channel_type	fixed bin;
dcl	fb71		fixed bin (71);
dcl	found_call_event	bit (1) aligned;
dcl	found_event	fixed bin;
dcl	found_wait_event	bit (1) aligned;
dcl	inhibit_count	fixed bin;
dcl	is_fast		bit (1) aligned;
dcl	last_ectep	ptr;
dcl	loop		fixed bin;
dcl	mask		bit (36) aligned;
dcl	msg_ptr		ptr;
dcl	saved_message_thread
			pointer;
dcl	temp_found_event	fixed bin;

/* Builtins */

dcl	addr		builtin;
dcl	codeptr		builtin;
dcl	environmentptr	builtin;
dcl	null		builtin;
dcl	stackbaseptr	builtin;
dcl	substr		builtin;
dcl	unspec		builtin;

/* Conditions */

dcl	any_other		condition;
dcl	cleanup		condition;

/* Constants */

dcl	(ON, YES, TRUE)	bit (1) aligned static options (constant) init ("1"b);
dcl	(OFF, NO)		bit (1) aligned static options (constant) init ("0"b);
%page;
create_ev_chn:
     entry (P_event_channel_name, P_code);

/****  This entry creates an event wait channel and returns the channel 
       name. */

	call find_ectp;				/* get pointer to ECT header for current ring  */

	mask = ""b;				/* for any_other handler */
	on any_other call any_other_handler ();

	call mask_ips_interrupts (mask);

	call ipc_util_$make_entry (ect_ptr, WAIT, ectep, ecit_idx);

/* set message and control point queue pointers to null values */

	wait_channel.first_ev_msgp, wait_channel.last_ev_msgp = null ();
	wait_channel.first_wcpp, wait_channel.last_wcpp = null ();

	ev_chn_flags = ""b;				/* we don't support anything else yet. */
	cur_ring = get_ring_ ();

	call ipc_validate_$encode_event_channel_name (ect_header.r_offset, ect_header.r_factor, ev_chn_flags, ecit_idx,
	     cur_ring, REGULAR_CHANNEL_TYPE, (ect_header.seed), fb71);
	ect_header.seed = ect_header.seed + 1;

/* put name in channel entry and return arg */

	wait_channel.name, unspec (P_event_channel_name) = unspec (fb71);

/* thread into list of wait channels */

	call thread_channel (WAIT);
	call unmask_ips_interrupts (mask);

	P_code = 0;
	return;
%page;
create_event_channel:
     entry (P_create_arg_ptr, P_event_channel_name, P_code);

/**** This entry creates an event channel of the specified type.  The procedure
      entry, data pointer, and priority arguments are ignored for wait type
      channels and used for call type channels. */

	ipc_create_arg_structure_ptr = P_create_arg_ptr;

	P_event_channel_name = 0;			/* Initialize the outputs. */
	P_code = 0;

	if ipc_create_arg_structure.version ^= ipc_create_arg_structure_v1
	then do;
		P_code = error_table_$unimplemented_version;
		return;
	     end;

/* Set up to create the event channel. */

	call find_ectp;				/* get pointer to ECT header for current ring  */

	mask = ""b;				/* for any_other handler */
	on any_other call any_other_handler ();

	call mask_ips_interrupts (mask);

	/*** Create a fast event wait channel. */

	if ipc_create_arg_structure.channel_type = FAST_EVENT_CHANNEL_TYPE
	then do;
		call hcs_$assign_channel (P_event_channel_name, P_code);
	     end;

	/*** Create a normal event wait channel. */

	else if ipc_create_arg_structure.channel_type = WAIT_EVENT_CHANNEL_TYPE
	then do;
		call ipc_util_$make_entry (ect_ptr, WAIT, ectep, ecit_idx);

		/*** Set message and control point queue pointers to null values. */

		wait_channel.first_ev_msgp, wait_channel.last_ev_msgp = null ();
		wait_channel.first_wcpp, wait_channel.last_wcpp = null ();

		ev_chn_flags = NORMAL_CHANNEL_FLAGS;
		cur_ring = get_ring_ ();

		call ipc_validate_$encode_event_channel_name (ect_header.r_offset, ect_header.r_factor, ev_chn_flags,
		     ecit_idx, cur_ring, REGULAR_CHANNEL_TYPE, (ect_header.seed), fb71);
		ect_header.seed = ect_header.seed + 1;

		/*** Put the name in the channel entry and the return argument. */

		wait_channel.name = unspec (fb71);
		unspec (P_event_channel_name) = unspec (fb71);

		/*** Thread into the list of wait channels. */

		call thread_channel (WAIT);
	     end;

	/*** Create a normal or IPS wkp_ event call channel. */

	else if ipc_create_arg_structure.channel_type = CALL_EVENT_CHANNEL_TYPE
	     | ipc_create_arg_structure.channel_type = ASYNC_CALL_EVENT_CHANNEL_TYPE
	then do;
		call ipc_util_$make_entry (ect_ptr, CALL, ectep, ecit_idx);

		/*** Set up the call channel structure. */

		call_channel.type = CALL;

		call_channel.first_ev_msgp, call_channel.last_ev_msgp = null ();

		call_channel.data_ptr = ipc_create_arg_structure.call_data_ptr;
		call_channel.procedure_ptr = codeptr (ipc_create_arg_structure.call_entry);
		call_channel.environment_ptr = environmentptr (ipc_create_arg_structure.call_entry);
		call_channel.priority = ipc_create_arg_structure.call_priority;
		call_channel.control_point_id = get_control_point_id_ ();
		call_channel.call_inhibit = OFF;

		/*** Set the flag that indicates what type of call channel this is. */
		/*** Since this information is also encoded in the channel name */
		/*** we only set this flag here and it remains the way we set it */
		/*** for the life of this entry. */

		if ipc_create_arg_structure.channel_type = CALL_EVENT_CHANNEL_TYPE
		then do;
			call_channel.flags.async_call = "0"b;
			ev_chn_flags = NORMAL_CHANNEL_FLAGS;
		     end;

		else do;
			call_channel.flags.async_call = "1"b;
			ev_chn_flags = SEND_IPS_WKP_CHANNEL_FLAGS;
		     end;

		cur_ring = get_ring_ ();

		call ipc_validate_$encode_event_channel_name (ect_header.r_offset, ect_header.r_factor, ev_chn_flags,
		     ecit_idx, cur_ring, REGULAR_CHANNEL_TYPE, (ect_header.seed), fb71);
		ect_header.seed = ect_header.seed + 1;

		/*** Put the name in the channel entry and the return argument. */

		call_channel.name = unspec (fb71);
		unspec (P_event_channel_name) = unspec (fb71);

		/*** Thread into the list of call channels. */

		call thread_channel (CALL);
	     end;

	/*** He wants some type we have never heard of. */

	else P_code = error_table_$bad_arg;

/* All done, unmask and return, the channel name and the code have been set. */

	call unmask_ips_interrupts (mask);

	return;
%page;
create_fast_ev_chn:
     entry (P_fast_channel_id, P_code);

/****  This entry creates a wait channel definition for a fast event channel.
       This wait channel definition is only used when control point management
       is enabled to track the control points which have blocked on the fast
       channel. */

	call find_ectp;				/* get pointer to ECT header for current ring  */

	mask = ""b;				/* for any_other handler */
	on any_other call any_other_handler ();

	call mask_ips_interrupts (mask);

	call ipc_util_$make_entry (ect_ptr, WAIT, ectep, ecit_idx);
	if P_fast_channel_id ^= ecit_idx
	then do;					/* fast channel's ECT index must match its ID */
		call ipc_util_$delete_entry (ect_ptr, ectep);
		call inconsistent_ect ();		/* ... will never return */
	     end;

	wait_channel.fast_channel = YES;		/* this is a fast channel ECT entry */
	wait_channel.fast_channel_id = P_fast_channel_id;

	wait_channel.first_ev_msgp, wait_channel.last_ev_msgp = null ();
	wait_channel.first_wcpp, wait_channel.last_wcpp = null ();

/* Create the channel's name */

	ev_chn_flags = NORMAL_CHANNEL_FLAGS;
	cur_ring = get_ring_ ();
	call ipc_validate_$encode_event_channel_name (ect_header.r_offset, ect_header.r_factor, ev_chn_flags, ecit_idx,
	     cur_ring, FAST_CHANNEL_TYPE, (P_fast_channel_id), fb71);
	wait_channel.name = unspec (fb71);

/* Thread into list of wait channels */

	call thread_channel (WAIT);
	call unmask_ips_interrupts (mask);

	P_code = 0;
	return;
%page;
decl_ev_call_chn:
     entry (P_event_channel_name, P_procedure_ptr, P_datap, P_priority, P_code);

	call find_ectp;

	mask = ""b;				/* for any_other handler */
	on any_other call any_other_handler ();

	call cu_$make_entry_value (P_procedure_ptr, call_channel_procedure);
	call MAKE_EVENT_CALL (call_channel_procedure);

	return;
%page;
decl_event_call_chn:
     entry (P_event_channel_name, P_procedure_entry, P_datap, P_priority, P_code);

	call find_ectp;

	mask = ""b;				/* for any_other handler */
	on any_other call any_other_handler ();

	call MAKE_EVENT_CALL (P_procedure_entry);

	return;
%page;
decl_ev_wait_chn:
     entry (P_event_channel_name, P_code);

/****
      This entry turns an event channel into a wait channel.  It works on
      asynchronous call channels as well as normal call channels.  If the
      channel was asynchronous, then the IPS "wkp_" will still be sent, but
      will essentially be a no-op.
****/

	call find_ectp;
	call ipc_util_$verify_channel (P_event_channel_name, ectep, is_fast, P_code);

/* return if unable to locate channel or if already a wait channel */
/* fast channels are considered to be wait channels */

	if (P_code ^= 0) | (is_fast = YES)
	then return;

	if (wait_channel.type = WAIT)
	then return;

/* On with the show. */

	mask = ""b;				/* for any_other handler */
	on any_other call any_other_handler ();

	call mask_ips_interrupts (mask);

/* Save the list of pending messages */

	call save_channel_message_thread (saved_message_thread);

/* Remove last vestiges of this channel being a call channel, but leave the
   flags alone just in case it becomes a call channel again. */

	call_channel.priority = 0;
	call_channel.call_inhibit = OFF;
	call unthread_channel;

/* Complete conversion into a wait channel */

	wait_channel.type = WAIT;
	wait_channel.first_wcpp, wait_channel.last_wcpp = null ();
	wait_channel.fast_channel_id, wait_channel.unused2 = 0;
	call thread_channel (WAIT);

/* Rethread any pending messages saved above */

	call rethread_channel_message_thread (saved_message_thread);

	call unmask_ips_interrupts (mask);

	return;
%page;
reset_ev_call_chn:
     entry (P_event_channel_name, P_code);

/**** This entry resets a call channel's inhibit flag */

	call find_ectp;
	call ipc_util_$verify_regular_channel (P_event_channel_name, ectep, P_code);

	if P_code ^= 0
	then return;

	if call_channel.type = CALL
	then call_channel.call_inhibit = OFF;

	return;
%page;
/* Reassigns ownership of all event call channels from one control point to
   another -- This entrypoint is called by the control point manager whenever
   it destroys a control point. */

reassign_call_channels:
     entry (P_old_control_point_id, P_new_control_point_id);

	call find_ectp ();

	mask = ""b;				/* for any_other handler */
	on any_other call any_other_handler ();

	call mask_ips_interrupts (mask);

	do ectep = ect_header.firstp (CALL) repeat (call_channel.next_chanp) while (ectep ^= null ());
	     if call_channel.type ^= CALL
	     then call inconsistent_ect ();
	     if call_channel.control_point_id = P_old_control_point_id
	     then call_channel.control_point_id = P_new_control_point_id;
	end;

	call unmask_ips_interrupts (mask);

	return;
%page;
delete_ev_chn:
     entry (P_event_channel_name, P_code);

/**** This entry deletes an event channel */

	call find_ectp;
	call ipc_util_$verify_channel (P_event_channel_name, ectep, is_fast, P_code);
	if P_code ^= 0
	then return;

	call decl_ev_wait_chn (P_event_channel_name, P_code);
						/* make it event-wait channel */
	if P_code ^= 0
	then return;

	call drain_chn (P_event_channel_name, P_code);	/* reset channel to zero */

	mask = ""b;				/* for any_other handler */
	on any_other call any_other_handler ();

	call mask_ips_interrupts (mask);

	call reset_channel_wcps ();			/* any waiting control points should now get an error */

	if is_fast = YES
	then call hcs_$delete_channel (P_event_channel_name, P_code);
	else do;
		call unthread_channel;
		call ipc_util_$delete_entry (ect_ptr, ectep);
		P_code = 0;
	     end;

	call unmask_ips_interrupts (mask);

	return;
%page;
drain_chn:
     entry (P_event_channel_name, P_code);

/**** Drains all currently waiting event messages from the channel. */

	found_event = 1;				/* set default values */
	P_code = 0;

	do loop = 1 to 2;
	     do while (found_event = 1 & P_code = 0);	/* read events until channel empty */
		call read_ev_chn (P_event_channel_name, found_event, addr (call_info), P_code);
	     end;

	     if loop = 1				/* drain channel even if it has been cutoff */
	     then if P_code ^= 0
		then if P_code = error_table_$event_channel_cutoff
		     then do;
			     call reconnect (P_event_channel_name, (0));
			     P_code = 0;
			end;
	end;
	return;
%page;
cutoff:
     entry (P_event_channel_name, P_code);

/**** Sets a flag to temporarily disable the channel for reading 
      purposes. */

	call find_ectp;
	call set_inhibit_switch (1);
	return;
%page;
reconnect:
     entry (P_event_channel_name, P_code);

/**** Resets the inhibit flag reactivating the channel. */

	call find_ectp;
	call set_inhibit_switch (-1);
	return;
%page;
set_call_prior:
     entry (P_code);

/**** For this ring, set priority so that event call channels are
      interrogated before event wait channels. */

	call find_ectp;
	call set_priority_switch (ON);
	return;
%page;
set_wait_prior:
     entry (P_code);

/**** For this ring, set priority so that event wait channels are
      interrogated before event call channels. */

	call find_ectp;
	call set_priority_switch (OFF);
	return;
%page;
mask_ev_calls:
     entry (P_code);

/**** Cause calls to ipc_$block ignore event call channels in this
      ring. */

	call find_ectp;
	call set_mask (1);
	return;
%page;
unmask_ev_calls:
     entry (P_code);

/**** Cause calls to ipc_$block to respond to event call channels
      again for this ring. */

	call find_ectp;
	call set_mask (-1);
	return;
%page;
read_ev_chn:
     entry (P_event_channel_name, P_found_event, P_event_wait_info_ptr, P_code);

/**** Read an event message out of an event channel */

	call find_ectp;
	inhibit_count, P_found_event = 0;

	call ipc_util_$verify_channel (P_event_channel_name, ectep, is_fast, P_code);
	if P_code ^= 0
	then return;

/* Only call ring-0 if the ECT does not already have any messages for this channel */

	block_val = cu_$level_get ();			/* for cleanup handler required by copy_itt_messages */
	cur_ring = get_ring_ ();
	on cleanup call cu_$level_set (block_val);

	mask = ""b;				/* for any_other handler required by copy_itt_messages */
	on any_other call any_other_handler ();

	if is_fast = YES
	then do;
		call read_fast_channel (P_event_channel_name, P_found_event, P_event_wait_info_ptr);
		if P_found_event = 0
		then do;				/* nothing known already: ask ring 0 */
			call copy_itt_messages (NO);
			call read_fast_channel (P_event_channel_name, P_found_event, P_event_wait_info_ptr);
		     end;
	     end;

	else do;					/* regular channel */
		if wait_channel.first_ev_msgp = null ()
		then call copy_itt_messages (NO);	/* nothing known already: ask ring 0 */
		call read_channel (inhibit_count, P_found_event, P_event_wait_info_ptr);
		if inhibit_count ^= 0		/* logical error, channel inhibited */
		then P_code = error_table_$event_channel_cutoff;
	     end;

	return;
%page;
/**** This entry waits for events to be signalled over event channels */

full_block:
     entry (P_event_wait_list_ptr, P_event_wait_info_ptr, P_code);

	call find_ectp ();

	event_wait_list_ptr = P_event_wait_list_ptr;
	event_wait_info_ptr = P_event_wait_info_ptr;
	event_wait_info.channel_index = 0;		/* reset channel-index to zero  */

	event_wait_list_n_channels = event_wait_list.n_channels;
						/* get number of channels to read  */

	if event_wait_list_n_channels <= 0
	then do;					/* erroneous argument  */
		P_code = error_table_$bad_arg;
		return;
	     end;

	block_val = cu_$level_get ();			/* for cleanup handler requried by copy_itt_messages ... */
	cur_ring = get_ring_ ();			/* ... and hardcore_block */

	event_call_in_progress = NO;			/* for cleanup handler required by check_call_channels */

	added_to_waiting_lists = NO;			/* for cleanup handler if there are multiple control points */

	on cleanup
	     begin;
		if added_to_waiting_lists = YES	/* this control point will no longer be waiting */
		then call delete_from_waiting_lists_caller (event_wait_list_ptr);
		if event_call_in_progress = YES	/* the event call has been aborted */
		then do;
			call_channel.call_inhibit = OFF;
			event_call_in_progress = NO;
		     end;
		call cu_$level_set (block_val);
	     end;

	mask = ""b;				/* for any_other handler required by copy_itt_messages */
	on any_other call any_other_handler ();

	current_control_point_id = get_control_point_id_ ();


/* Main loop of ipc_$full_block */

	do while (TRUE);

	     call copy_itt_messages (NO);		/* get pending ITT messages */

/* format: off */
	     check_channels =			/* we can only check for events if ... */
		(have_multiple_control_points () = NO) |/* ... there is only one control point or ... */
		(ect_header.wakeup_control_points = NO);/* ... all control points are in their proper state */
/* format: on */

/* Check the channels for a pending event to satisfy this block */

	     do while (check_channels = YES);

		if ect_header.call_priority = YES
		then do;				/* check call channels first */
			call check_call_channels (ANY_CALL_EVENT_CHANNEL_TYPE, found_call_event);
			if found_call_event = NO
			then do;
				call check_wait_channels (found_wait_event);
				if (found_wait_event = YES) | (P_code ^= 0)
				then go to RETURN_FROM_FULL_BLOCK;
			     end;
		     end;

		else do;				/* check the wait channels first */
			call check_wait_channels (found_wait_event);
			if (found_wait_event = YES) | (P_code ^= 0)
			then go to RETURN_FROM_FULL_BLOCK;
			call check_call_channels (ANY_CALL_EVENT_CHANNEL_TYPE, found_call_event);
		     end;

		check_channels =
		     (found_call_event = YES)
		     & ((have_multiple_control_points () = NO) | (ect_header.wakeup_control_points = NO));
	     end;

/* Control arrives here iff we have to block until an event arrives -- If there
   are multiple control points in the process, this control point will now
   relinquish control of the process to someone else.  If there's only one
   control point, we can call ring 0 to block the process directly. */

	     if have_multiple_control_points () = YES
	     then do;
		     if added_to_waiting_lists = NO	/* put this control point on each channel's waiting list */
		     then do;
			     call add_to_waiting_lists ();
			     if P_code ^= 0
			     then go to RETURN_FROM_FULL_BLOCK;
			end;
		     call block_if_no_pending_events ();/* mark us blocked unless there are available events */
		     if P_code ^= 0
		     then go to RETURN_FROM_FULL_BLOCK;
		     if ect_header.wakeup_control_points = YES
		     then call wakeup_blocked_control_points ();
		     call cpm_$scheduler ();		/* find a control point to run */
		end;

	     else call hardcore_block ();
	end;


/* Control arrives here when it's time to return to our caller and we might
   have passed through the main loop at least once */

RETURN_FROM_FULL_BLOCK:
	if added_to_waiting_lists = YES
	then call delete_from_waiting_lists ();

	return;
%page;
/* This entrypoint is called by the control point scheduler when there are
   no control points in the ready state.  The purpose of this entrypoint is
   to wait for any IPC event (fast or regular) to occur and to then notify
   the control points waiting for those events.  The notification will place
   said control points into the ready state and the scheduler will then
   select the one with the highest priority to process its wakeup. */

wait_for_an_event:
     entry ();

	call find_ectp ();

	block_val = cu_$level_get ();			/* for cleanup handler requried by copy_itt_messages ... */
	cur_ring = get_ring_ ();			/* ... and hardcore_block */
	on cleanup call cu_$level_set (block_val);

	mask = ""b;				/* for any_other handler required by copy_itt_messages */
	on any_other call any_other_handler ();

	call copy_itt_messages (YES);			/* pick up any events that have already arrived */

	if ect_header.wakeup_control_points = YES
	then call wakeup_blocked_control_points ();	/* inform the waiting control points if we found anything */
	else call hardcore_block ();			/* otherwise, wait for something to happen */

	return;
%page;
run_event_calls:
     entry (P_event_channel_type, P_code);

/*
   * This entry causes any pending event calls of the specified type to be run.
   * It makes one pass through the chains of pending events instead of scanning
   * from the beginning of the chain after each event is processed (like
   * full_block).  The major reason for this entry is for use by the wkp_ IPS
   * signal, whose contract is to run any pending event calls in the process.
*/

	event_channel_type = P_event_channel_type;

	if event_channel_type ^= CALL_EVENT_CHANNEL_TYPE & event_channel_type ^= ASYNC_CALL_EVENT_CHANNEL_TYPE
	     & event_channel_type ^= ANY_CALL_EVENT_CHANNEL_TYPE
	then do;
		P_code = error_table_$bad_arg;
		return;
	     end;

	call find_ectp ();

	block_val = cu_$level_get ();			/* Save the validation ring number. */
	cur_ring = get_ring_ ();			/* Get the current ring number for calls to ring 0. */

	event_call_in_progress = NO;			/* Triggers cleanup action. */
						/* Prevents check_call_channels procedure from being non-quick. */
	on cleanup
	     begin;
		if event_call_in_progress = YES
		then do;
			call_channel.call_inhibit = OFF;
			event_call_in_progress = NO;
		     end;

		call cu_$level_set (block_val);
	     end;

/* Set up an any_other handler for copy_itt_messages and current_control_point_id for check_call_channels. */

	mask = ""b;
	on any_other call any_other_handler ();

	current_control_point_id = get_control_point_id_ ();

/*
   * Calling copy_itt_messages once will get the pending events.  As long as
   * we don't call it again we won't get any more events in the ECT.  This is
   * how we guarantee that only the events that were pending when we are called
   * will be handled even though check_call_channels starts from the beginning
   * of the event messages each time we call it.
*/

	call copy_itt_messages (NO);

	found_call_event = YES;			/* Do the loop at least once. */

	do while (found_call_event);			/* Loop until no more. */
	     call check_call_channels (P_event_channel_type, found_call_event);
	end;

	return;
%page;
find_ectp:
     procedure ();

/**** Internal procedure to get a pointer to the ECT for this ring.
      If there is none, one will be created. */

	ect_ptr = stackbaseptr () -> stack_header.ect_ptr;
	if ect_ptr = null
	then call ipc_util_$create_ect (ect_ptr);

     end find_ectp;
%page;
/* Pickup any new event messages which have arrived since we last blocked */

copy_itt_messages:
     procedure (p_set_wcp);

dcl	p_set_wcp		bit (1) aligned parameter;

dcl	an_ectep		pointer;
dcl	1 a_call_channel	like call_channel aligned based (an_ectep);
dcl	1 a_wait_channel	like wait_channel aligned based (an_ectep);
dcl	channel_id	fixed binary;
dcl	code		fixed bin (35);


/* Check with ring 0 if there are no ITT messages already in the ECT */

	if ect_header.firstp (ITT_MESSAGE) = null
	then do;
		if block_val ^= cur_ring
		then call cu_$level_set (cur_ring);
		call hcs_$read_events (ipc_data_$fast_channel_events, ("0"b));
		if block_val ^= cur_ring
		then call cu_$level_set (block_val);
	     end;


/* Record newly arrived fast events if multiple control points are present
   in this process as more than one such control point may be blocked on a
   fast channel */

	if (p_set_wcp = YES) | (have_multiple_control_points () = YES)
	then do;

		do an_ectep = ect_header.firstp (WAIT) repeat (a_wait_channel.next_chanp) while (an_ectep ^= null ());
		     if a_wait_channel.type ^= WAIT
		     then call inconsistent_ect ();
		     if a_wait_channel.fast_channel = YES
		     then do;
			     channel_id = a_wait_channel.fast_channel_id;
			     if (substr (ipc_data_$fast_channel_events, channel_id, 1) = YES)
				& (substr (ect_header.last_fast_channel_events, channel_id, 1) = NO)
			     then do;		/* this is a fresh event */
				     a_wait_channel.wakeup_control_points = YES;
				     ect_header.wakeup_control_points = YES;
				end;
			end;
		end;

		ect_header.last_fast_channel_events = ipc_data_$fast_channel_events;
	     end;					/* remember the new events */


/* Process the ITT messages */

	call mask_ips_interrupts (mask);

	do msg_ptr = ect_header.firstp (ITT_MESSAGE) repeat (ect_header.firstp (ITT_MESSAGE)) while (msg_ptr ^= null);

	     ect_header.firstp (ITT_MESSAGE) = msg_ptr -> itt_message.next_itt_msgp;
	     if ect_header.lastp (ITT_MESSAGE) = msg_ptr
	     then ect_header.lastp (ITT_MESSAGE) = null;
	     ect_header.count (ITT_MESSAGE) = ect_header.count (ITT_MESSAGE) - 1;

	     call ipc_util_$verify_regular_channel (msg_ptr -> itt_message.channel_id, an_ectep, code);

	     if code = 0
	     then do;

/* This ITT message is intended for an existing channel -- add it to the appropriate queues */

		     msg_ptr -> event_message.chanp = an_ectep;

		     if (p_set_wcp = YES) | (have_multiple_control_points () = YES)
		     then ect_header.wakeup_control_points, a_wait_channel.wakeup_control_points = YES;
						/* must notify all control points in the process */

		     if a_call_channel.type = CALL
		     then do;
			     msg_ptr -> event_message.priority = a_call_channel.priority;
			     call insert_event_call_message (msg_ptr);
			     ect_header.total_call_wakeups = ect_header.total_call_wakeups + 1;
			end;
		     else do;
			     call insert_event_wait_message (msg_ptr);
			     ect_header.total_wait_wakeups = ect_header.total_wait_wakeups + 1;
			end;

		     ect_header.total_wakeups = ect_header.total_wakeups + 1;
		     a_wait_channel.wakeup_count = a_wait_channel.wakeup_count + 1;
		end;


	     else do;

/* This ITT message is not intended for an existing channel -- throw it away */

		     call ipc_util_$delete_entry (ect_ptr, msg_ptr);
		     ect_header.ittes_tossed = ect_header.ittes_tossed + 1;
		end;

	end;

	call unmask_ips_interrupts (mask);

	return;

     end copy_itt_messages;
%page;
/* Scans the list of outstanding event messages for call channels -- If a
   message is found for a channel which is not inhibited and which was declared
   a call channel by this control point, and the channel is the right type,
   the message is removed from the queue and the call handler is invoked. */

check_call_channels:
     procedure (P_event_channel_type, P_found_call_event);

dcl	P_event_channel_type
			fixed bin parameter;
dcl	P_found_call_event	bit (1) aligned parameter;

dcl	call_msgp		ptr;
dcl	ev_chn_flags	bit (3) aligned;
dcl	got_message	fixed bin;
dcl	is_fast		bit (1) aligned;
dcl	rcode		fixed bin (35);
dcl	saved_channel_name	fixed bin (71);


	P_found_call_event = NO;			/* assume failure */

	if ect_header.mask_call_count > 0		/* all event calls are shut off */
	then return;


/* Scan the list of call event messages */

	got_message = 0;

	do call_msgp = ect_header.firstp (EV_CALL_MESSAGE) repeat (call_msgp)
	     while ((call_msgp ^= null ()) & (got_message = 0));

	     ectep = call_msgp -> event_message.chanp;	/* find the channel which owns this message */
	     if call_channel.type ^= CALL
	     then call inconsistent_ect ();

	     if call_channel.control_point_id = current_control_point_id
	     then do;				/* It is for this control point. */
		     if (^call_channel.flags.async_call
			& (P_event_channel_type = CALL_EVENT_CHANNEL_TYPE
			| P_event_channel_type = ANY_CALL_EVENT_CHANNEL_TYPE))
			| (call_channel.flags.async_call
			& (P_event_channel_type = ASYNC_CALL_EVENT_CHANNEL_TYPE
			| P_event_channel_type = ANY_CALL_EVENT_CHANNEL_TYPE))
		     then call read_channel ((0), got_message, addr (call_info));
		     else ;			/* This one is not for us. */
		end;

	     call_msgp = call_msgp -> event_message.next_ev_msgp;
	end;

	if got_message = 0				/* nothing found */
	then return;


/* An acceptable message was found -- Invoke the call channel's procedure */

	unspec (saved_channel_name) = unspec (call_channel.name);

	entry_value.ep_ptr = call_channel.procedure_ptr;
	entry_value.env_ptr = call_channel.environment_ptr;
	unspec (call_channel_procedure) = unspec (entry_value);

	call_info.data_ptr = call_channel.data_ptr;

	event_call_in_progress = YES;			/* inform full_block's cleanup handler */

	call_channel.call_inhibit = ON;		/* prevent recursive invocations of this channel's handler */


	/*** Call the user's program */
	if have_multiple_control_points () = YES	/* must always use cpm_ to insure our I/O switches are OK */
	then call cpm_$generate_call_preferred (current_control_point_id, call_channel_procedure, addr (call_info), (0))
		;
	else call call_channel_procedure (addr (call_info));

	call ipc_util_$verify_regular_channel (saved_channel_name, (null ()), rcode);
	if rcode = 0				/* channel wasn't deleted by the handler ... */
	then call_channel.call_inhibit = OFF;		/* ... so we can allow subsequent wakeups */

	event_call_in_progress = NO;			/* full_block's cleanup handler need not worry about it */

	P_found_call_event = YES;			/* keep checking channels */

	return;

     end check_call_channels;
%page;
check_wait_channels:
     procedure (P_found_event_wait);

dcl	P_found_event_wait	bit (1) aligned parameter;

dcl	temp_channel_name	fixed bin (71);
dcl	1 message_info	aligned like event_wait_info;
dcl	loop		fixed bin;

	P_found_event_wait = NO;
	inhibit_count = 0;

	do loop = 1 to event_wait_list_n_channels;

	     temp_channel_name = event_wait_list.channel_id (loop);

	     call ipc_util_$verify_channel (temp_channel_name, ectep, is_fast, P_code);
	     if P_code ^= 0
	     then return;

	     if is_fast = YES
	     then call read_fast_channel (temp_channel_name, temp_found_event, addr (message_info));
	     else do;
		     if wait_channel.type ^= WAIT
		     then do;
			     P_code = error_table_$not_a_wait_channel;
			     return;
			end;
		     call read_channel (inhibit_count, temp_found_event, addr (message_info));
		end;
	     if temp_found_event ^= 0
	     then do;
		     event_wait_info.channel_id = message_info.channel_id;
		     event_wait_info.message = message_info.message;
		     event_wait_info.sender = message_info.sender;
		     event_wait_info.dev_signal = message_info.dev_signal;
		     event_wait_info.ring = message_info.ring;
		     event_wait_info.channel_index = loop;
		     P_found_event_wait = YES;
		     return;
		end;
	end;

	if inhibit_count = event_wait_list_n_channels
	then do;
		P_code = error_table_$event_channel_cutoff;
		return;
	     end;

     end check_wait_channels;
%page;
read_channel:
     proc (P_inhibit_count, P_found_event, P_event_wait_info_ptr);

/**** Internal procedure to read one event message out of a channel. */

dcl	P_inhibit_count	fixed bin parameter;
dcl	P_found_event	fixed bin parameter;
dcl	P_event_wait_info_ptr
			ptr parameter;

dcl	msg_ptr		ptr;

	P_found_event = 0;				/* set default return values */

	if call_channel.type = CALL & call_channel.call_inhibit = YES
	then return;				/*  event call procedure being called */

	if wait_channel.inhibit_count ^= 0		/* channel inhibited, must not be read  */
	then do;
		P_inhibit_count = P_inhibit_count + 1;	/* increment count of inhibited channels */
		return;				/* ignore inhibited channel */
	     end;

/* having reached this point, we know that we have the right to try
   and read the event channel.				*/

	call mask_ips_interrupts (mask);

	msg_ptr = wait_channel.first_ev_msgp;
	if msg_ptr ^= null ()			/* there's a message waiting */
	then do;
		call unthread_event_message (msg_ptr);	/* remove it from the queue */
		if wait_channel.first_ev_msgp = null () /* don't notify other control points if no events are left */
		then wait_channel.wakeup_control_points = NO;

		P_event_wait_info_ptr -> event_wait_info = msg_ptr -> event_message.message_data, by name;
						/* return message to caller of ipc_$block */

		P_found_event = 1;			/* set indicator = successful  */

		call ipc_util_$delete_entry (ect_ptr, msg_ptr);
						/* delete the message entry  */
	     end;

	call unmask_ips_interrupts (mask);

     end read_channel;
%page;
read_fast_channel:
     proc (P_channel_name, P_found_event, P_event_wait_info_ptr);

dcl	P_channel_name	fixed bin (71) parameter;
dcl	P_found_event	fixed bin parameter;
dcl	P_event_wait_info_ptr
			ptr parameter;

dcl	channel_index	fixed bin;
dcl	unspec		builtin;

dcl	1 ev_chn_name	aligned like event_channel_name automatic;

	P_found_event = 0;
	unspec (ev_chn_name) = unspec (P_channel_name);
	if ev_chn_name.type = REGULAR_CHANNEL_TYPE
	then return;

	channel_index = ev_chn_name.unique_id;
	if substr (ipc_data_$fast_channel_events, channel_index, 1) = NO
	then return;

/**** Indicate we've read the event out. */

	substr (ipc_data_$fast_channel_events, channel_index, 1) = NO;

	wait_channel.wakeup_control_points = NO;	/* don't notify other control points about this channel now */
	substr (ect_header.last_fast_channel_events, channel_index, 1) = NO;
						/* ... but be sure later events will notify */

/**** And fill in return info */

	P_event_wait_info_ptr -> event_wait_info.channel_id = P_channel_name;
	P_event_wait_info_ptr -> event_wait_info.message = 0;
	P_event_wait_info_ptr -> event_wait_info.sender, P_event_wait_info_ptr -> event_wait_info.dev_signal = ""b;
	P_event_wait_info_ptr -> event_wait_info.ring = ev_chn_name.ring;

	P_found_event = 1;

	return;

     end read_fast_channel;
%page;
/* Insert the given message into the event call queue based on its priority */

insert_event_call_message:
     procedure (p_msg_ptr);

dcl	p_msg_ptr		pointer parameter;

dcl	1 next_event_message
			like event_message aligned based (next_msg_ptr);
dcl	next_msg_ptr	pointer;
dcl	1 p_event_message	like event_message aligned based (p_msg_ptr);
dcl	prev_msg_ptr	pointer;

	p_event_message.type = EV_CALL_MESSAGE;

	prev_msg_ptr = null ();			/* assume it goes at the beginning of the queue */

	do next_msg_ptr = ect_header.firstp (EV_CALL_MESSAGE) repeat (next_event_message.next_ev_msgp)
	     while (next_msg_ptr ^= null ());
	     if next_event_message.chanp -> call_channel.type ^= CALL
	     then call inconsistent_ect ();
	     if next_event_message.priority > p_event_message.priority
	     then go to INSERT_THE_MESSAGE;
	     else prev_msg_ptr = next_msg_ptr;
	end;

INSERT_THE_MESSAGE:
	call thread_event_message (p_msg_ptr, prev_msg_ptr);

	return;

     end insert_event_call_message;



/* Insert the given message onto the tail of the event wait queue */

insert_event_wait_message:
     procedure (p_msg_ptr);

dcl	p_msg_ptr		pointer parameter;

	p_msg_ptr -> event_message.type = EV_WAIT_MESSAGE;

	call thread_event_message (p_msg_ptr, ect_header.lastp (EV_WAIT_MESSAGE));

	return;

     end insert_event_wait_message;
%page;
/* Thread an event message into the list of active messages after the
   specified message */

thread_event_message:
     procedure (p_msg_ptr, p_prev_msg_ptr);

dcl	p_msg_ptr		pointer parameter;
dcl	p_prev_msg_ptr	pointer parameter;

dcl	message_type	fixed binary;
dcl	1 next_event_message
			like event_message aligned based (next_msg_ptr);
dcl	next_msg_ptr	pointer;
dcl	owning_chanp	pointer;
dcl	1 p_event_message	like event_message aligned based (p_msg_ptr);
dcl	1 prev_event_message
			like event_message aligned based (prev_msg_ptr);
dcl	prev_msg_ptr	pointer;

	message_type = p_event_message.type;
	owning_chanp = p_event_message.chanp;

	if ((message_type = EV_WAIT_MESSAGE) & (owning_chanp -> wait_channel.type ^= WAIT))
	     | ((message_type = EV_CALL_MESSAGE) & (owning_chanp -> call_channel.type ^= CALL))
	then call inconsistent_ect ();

/* First add the message to the end of the per-channel thread */

	if owning_chanp -> wait_channel.first_ev_msgp = null ()
	then do;					/* this is the first message for the channel */
		if owning_chanp -> wait_channel.last_ev_msgp ^= null ()
		then call inconsistent_ect ();
		owning_chanp -> wait_channel.first_ev_msgp = p_msg_ptr;
		p_event_message.prev_chan_msgp = null ();
	     end;
	else do;					/* the per-channel thread already has something on it */
		if owning_chanp -> wait_channel.last_ev_msgp = null ()
		then call inconsistent_ect ();
		if owning_chanp -> wait_channel.last_ev_msgp -> event_message.next_chan_msgp ^= null ()
		then call inconsistent_ect ();
		owning_chanp -> wait_channel.last_ev_msgp -> event_message.next_chan_msgp = p_msg_ptr;
		p_event_message.prev_chan_msgp = owning_chanp -> wait_channel.last_ev_msgp;
	     end;

	owning_chanp -> wait_channel.last_ev_msgp = p_msg_ptr;
	p_event_message.next_chan_msgp = null ();

/* Now add the message to the per-type thread */

	prev_msg_ptr = p_prev_msg_ptr;		/* this parameter could be ect_header.lastp (type) and, since
						   its passed by reference, the value would change as we set
						   ect_header.lastp (type) when adding to end of the queue */

	if prev_msg_ptr = null ()
	then do;					/* add it to the beginning */
		next_msg_ptr = ect_header.firstp (message_type);
		ect_header.firstp (message_type) = p_msg_ptr;
	     end;
	else do;					/* add it to the middle or the end */
		if prev_event_message.type ^= message_type
		then call inconsistent_ect ();
		next_msg_ptr = prev_event_message.next_ev_msgp;
		prev_event_message.next_ev_msgp = p_msg_ptr;
	     end;

	if next_msg_ptr = null ()
	then do;					/* add it to the end */
		if ect_header.lastp (message_type) ^= prev_msg_ptr
		then call inconsistent_ect ();
		ect_header.lastp (message_type) = p_msg_ptr;
	     end;
	else do;					/* add it to the beginning or the middle */
		if next_event_message.type ^= message_type
		then call inconsistent_ect ();
		next_event_message.prev_ev_msgp = p_msg_ptr;
	     end;

	p_event_message.prev_ev_msgp = prev_msg_ptr;
	p_event_message.next_ev_msgp = next_msg_ptr;

/* Update the appropriate counters */

	ect_header.count (message_type) = ect_header.count (message_type) + 1;
	if message_type = EV_CALL_MESSAGE		/* let ipc_fast_ know */
	then ipc_data_$event_calls_pending = ipc_data_$event_calls_pending + 1;

	return;

     end thread_event_message;
%page;
/* Unthread an event message from the list of active messages */

unthread_event_message:
     procedure (p_msg_ptr);

dcl	p_msg_ptr		pointer parameter;

dcl	message_type	fixed binary;
dcl	owning_chanp	pointer;
dcl	1 p_event_message	like event_message aligned based (p_msg_ptr);

	message_type = p_event_message.type;
	owning_chanp = p_event_message.chanp;

	if ((message_type = EV_WAIT_MESSAGE) & (owning_chanp -> wait_channel.type ^= WAIT))
	     | ((message_type = EV_CALL_MESSAGE) & (owning_chanp -> call_channel.type ^= CALL))
	then call inconsistent_ect ();

/* First remove this message from the per-channel thread */

	if p_event_message.prev_chan_msgp = null ()
	then do;					/* this is the first message for the channel */
		if owning_chanp -> wait_channel.first_ev_msgp ^= p_msg_ptr
		then call inconsistent_ect ();
		owning_chanp -> wait_channel.first_ev_msgp = p_event_message.next_chan_msgp;
	     end;
	else do;					/* this is in the middle of the channel's thread */
		if p_event_message.prev_chan_msgp -> event_message.next_chan_msgp ^= p_msg_ptr
		then call inconsistent_ect ();
		p_event_message.prev_chan_msgp -> event_message.next_chan_msgp = p_event_message.next_chan_msgp;
	     end;

	if p_event_message.next_chan_msgp = null ()
	then do;					/* this is the last message for the channel */
		if owning_chanp -> wait_channel.last_ev_msgp ^= p_msg_ptr
		then call inconsistent_ect ();
		owning_chanp -> wait_channel.last_ev_msgp = p_event_message.prev_chan_msgp;
	     end;
	else do;					/* this is in the middle of the channel's thread */
		if p_event_message.next_chan_msgp -> event_message.prev_chan_msgp ^= p_msg_ptr
		then call inconsistent_ect ();
		p_event_message.next_chan_msgp -> event_message.prev_chan_msgp = p_event_message.prev_chan_msgp;
	     end;

	p_event_message.prev_chan_msgp, p_event_message.next_chan_msgp = null ();

/* Now remove this message from the per-type thread */

	if p_event_message.prev_ev_msgp = null ()
	then do;					/* this is the first message for the type */
		if ect_header.firstp (message_type) ^= p_msg_ptr
		then call inconsistent_ect ();
		ect_header.firstp (message_type) = p_event_message.next_ev_msgp;
	     end;
	else do;					/* this is in the middle of the type's thread */
		if p_event_message.prev_ev_msgp -> event_message.next_ev_msgp ^= p_msg_ptr
		then call inconsistent_ect ();
		p_event_message.prev_ev_msgp -> event_message.next_ev_msgp = p_event_message.next_ev_msgp;
	     end;

	if p_event_message.next_ev_msgp = null ()
	then do;					/* this is the last message for the type */
		if ect_header.lastp (message_type) ^= p_msg_ptr
		then call inconsistent_ect ();
		ect_header.lastp (message_type) = p_event_message.prev_ev_msgp;
	     end;
	else do;					/* this is in the middle of the type's thread */
		if p_event_message.next_ev_msgp -> event_message.prev_ev_msgp ^= p_msg_ptr
		then call inconsistent_ect ();
		p_event_message.next_ev_msgp -> event_message.prev_ev_msgp = p_event_message.prev_ev_msgp;
	     end;

	p_event_message.prev_ev_msgp, p_event_message.next_ev_msgp = null ();

/* Update the appropriate counters */

	ect_header.count (message_type) = ect_header.count (message_type) - 1;
	if message_type = EV_CALL_MESSAGE		/* let ipc_fast_ know */
	then ipc_data_$event_calls_pending = ipc_data_$event_calls_pending - 1;

	return;

     end unthread_event_message;
%page;
/* Save the list of pending messages for the "current" channel -- The messages
   are unthreaded from the "active" messages */

save_channel_message_thread:
     procedure (p_saved_message_thread);

dcl	p_saved_message_thread
			pointer parameter;
dcl	(msg_ptr, prev_msg_ptr, next_msg_ptr)
			pointer;

	p_saved_message_thread, prev_msg_ptr = null ();

	do msg_ptr = wait_channel.first_ev_msgp repeat (next_msg_ptr) while (msg_ptr ^= null ());
	     next_msg_ptr = msg_ptr -> event_message.next_chan_msgp;
	     call unthread_event_message (msg_ptr);
	     if prev_msg_ptr = null ()
	     then p_saved_message_thread = msg_ptr;	/* this is the first message in the list */
	     else prev_msg_ptr -> event_message.next_chan_msgp = msg_ptr;
	     prev_msg_ptr = msg_ptr;
	end;

	return;

     end save_channel_message_thread;



/* Rethread the list of pending messages for the "current" channel */

rethread_channel_message_thread:
     procedure (p_saved_message_thread);

dcl	p_saved_message_thread
			pointer parameter;
dcl	next_msg_ptr	pointer;

	do msg_ptr = p_saved_message_thread repeat (next_msg_ptr) while (msg_ptr ^= null ());
	     next_msg_ptr = msg_ptr -> event_message.next_chan_msgp;
	     if msg_ptr -> event_message.chanp ^= ectep
	     then call inconsistent_ect ();
	     if wait_channel.type = WAIT
	     then call insert_event_wait_message (msg_ptr);
	     else do;
		     msg_ptr -> event_message.priority = call_channel.priority;
		     call insert_event_call_message (msg_ptr);
		end;
	end;

	return;

     end rethread_channel_message_thread;
%page;
thread_channel:
     proc (P_entry_type);

dcl	P_entry_type	fixed bin (8) parameter;

	last_ectep = ect_header.lastp (P_entry_type);

/* list is empty */

	if last_ectep = null
	then do;					/* thread in at beginning of list */
		ect_header.firstp (P_entry_type) = ectep;
		wait_channel.prev_chanp = null;
	     end;
	else do;					/* thread in at end of list */
		wait_channel.prev_chanp = last_ectep;
		last_ectep -> wait_channel.next_chanp = ectep;
	     end;

/* fill in forward thread and tail of list */

	wait_channel.next_chanp = null;
	ect_header.lastp (P_entry_type) = ectep;

	ect_header.count (P_entry_type) = ect_header.count (P_entry_type) + 1;

     end thread_channel;
%page;
unthread_channel:
     procedure ();

	entry_type = wait_channel.type;		/* save type of ect entry */

/* if first channel adjust head of list */

	if wait_channel.prev_chanp = null
	then ect_header.firstp (entry_type) = wait_channel.next_chanp;

/* otherwise thread out back pointer */
	else wait_channel.prev_chanp -> wait_channel.next_chanp = wait_channel.next_chanp;

/* if last channel in list adjust tail of list*/
	if wait_channel.next_chanp = null
	then ect_header.lastp (entry_type) = wait_channel.prev_chanp;

/* otherwise thread out forward pointer */
	else wait_channel.next_chanp -> wait_channel.prev_chanp = wait_channel.prev_chanp;

/* set threads to null in entry */
	wait_channel.next_chanp, wait_channel.prev_chanp = null;

	ect_header.count (entry_type) = ect_header.count (entry_type) - 1;

     end unthread_channel;
%page;
MAKE_EVENT_CALL:
     procedure (P_call_procedure);

/**** This internal procedure is called to turn the specified event
      channel into an event call channel.  The channel must be valid
      and not be a special (i.e. fast) channel.  Implicit parameters are 
      P_event_channel_name, P_datap, P_priority, and P_code. */

dcl	P_call_procedure	entry (ptr) variable;

	call ipc_util_$verify_regular_channel (P_event_channel_name, ectep, P_code);
	if P_code ^= 0				/* do not allow fast channels */
	then return;

	call mask_ips_interrupts (mask);

/* Save the list of any pending messages -- If the channel is already a call
   channel, we may still have to rethread it as its priority may be changed.
   In either case, leave the flag indicating whether it is an async call
   channel alone, since it was set when the channel was created, and should
   not be changed (since it is also encoded in the channel name). */

	call save_channel_message_thread (saved_message_thread);

/* Convert it into a call channel */

	if wait_channel.type = WAIT
	then do;
		call reset_channel_wcps ();		/* any waiting control points should now get an error */
		call unthread_channel;
		call_channel.type = CALL;
		call thread_channel (CALL);
	     end;

	call_channel.data_ptr = P_datap;
	call_channel.procedure_ptr = codeptr (P_call_procedure);
	call_channel.environment_ptr = environmentptr (P_call_procedure);
	call_channel.priority = P_priority;
	call_channel.control_point_id = get_control_point_id_ ();
	call_channel.call_inhibit = OFF;

/* Rethread any pending messages for this channel */

	call rethread_channel_message_thread (saved_message_thread);

	call unmask_ips_interrupts (mask);

     end MAKE_EVENT_CALL;
%page;
set_inhibit_switch:
     procedure (P_inhibit_value);

dcl	P_inhibit_value	fixed bin (17) parameter;

	call ipc_util_$verify_regular_channel (P_event_channel_name, ectep, P_code);
	if P_code ^= 0
	then return;

	wait_channel.inhibit_count = wait_channel.inhibit_count + P_inhibit_value;

	if wait_channel.inhibit_count < 0
	then do;
		wait_channel.inhibit_count = 0;
		P_code = error_table_$event_channel_not_cutoff;
	     end;

     end set_inhibit_switch;
%page;
set_priority_switch:
     procedure (P_priority_switch);

dcl	P_priority_switch	bit (1) aligned parameter;

	P_code = 0;
	ect_header.flags.call_priority = P_priority_switch;

     end set_priority_switch;
%page;
set_mask:
     procedure (P_mask_value);

dcl	P_mask_value	fixed bin;

	P_code = 0;
	ect_header.mask_call_count = ect_header.mask_call_count + P_mask_value;

	if ect_header.mask_call_count < 0		/* logical error, unpaired mask/unmask */
	then do;
		ect_header.mask_call_count = 0;	/* reset mask to 0 */
		P_code = error_table_$event_calls_not_masked;
						/* code = logical error in use of IPC */
	     end;

     end set_mask;
%page;
/* Mask all IPS interrupts */

mask_ips_interrupts:
     procedure (p_mask);

dcl	p_mask		bit (36) aligned parameter;

	call hcs_$set_ips_mask (""b, p_mask);

     end mask_ips_interrupts;



/* Restore the IPS mask to its state prior to calling mask_ips_interrupts */

unmask_ips_interrupts:
     procedure (p_mask);

dcl	p_mask		bit (36) aligned parameter;

	if substr (p_mask, 36, 1) = ON
	then call hcs_$reset_ips_mask (p_mask, p_mask);

     end unmask_ips_interrupts;



/* Invoke unmask_ips_interrupts -- This entrypoint exists to prevent making
   the unmask_ips_interrupts internal procedure non-quick by invoking it
   from within an on unit. */

unmask_ips_interrupts_caller:
     entry (P_mask);

	call unmask_ips_interrupts (P_mask);
	return;
%page;
/* Report that the ECT is inconsistent -- This procedure will never return as
   ipc_util_$ect_error_handler generates a fatal process error */

inconsistent_ect:
     procedure ();

	call unmask_ips_interrupts (mask);
	call ipc_util_$ect_error_handler (error_table_$inconsistent_ect);

     end inconsistent_ect;



/* The any_other handler established whenever we have masked IPS signals */

any_other_handler:
     procedure ();

	call unmask_ips_interrupts_caller (mask);

	call continue_to_signal_ ((0));		/* be sure the error gets through */

     end any_other_handler;
%page;
hardcore_block:
     procedure ();

/**** This procedure merely calls hardcore to block the process (or not,
      if there are new event wakeups).  It makes sure that the validation
      level is set to the current ring before doing so. */

	if cur_ring ^= block_val
	then call cu_$level_set (cur_ring);

	call hcs_$fblock (ipc_data_$fast_channel_events, ("0"b));

	if cur_ring ^= block_val
	then call cu_$level_set (block_val);

	return;

     end hardcore_block;
%page;
/* Determines if more than one control point is defined in this process */

have_multiple_control_points:
     procedure () returns (bit (1) aligned);

	if stackbaseptr () -> stack_header.cpm_enabled
	then return (cpm_data_$n_control_points > 1);
	else return (NO);

     end have_multiple_control_points;
%page;
/* Adds the current control point to the list of control points waiting for
   an event to be signalled on each of the channels in a call to ipc_$block */

add_to_waiting_lists:
     procedure ();

dcl	loop		fixed binary;

	do loop = 1 to event_wait_list_n_channels;	/* insure that all the channels are OK first */
	     call ipc_util_$verify_channel (event_wait_list.channel_id (loop), ectep, ("0"b), P_code);
	     if P_code ^= 0
	     then return;
	     if wait_channel.type ^= WAIT
	     then do;
		     P_code = error_table_$not_a_wait_channel;
		     return;
		end;
	end;

	call mask_ips_interrupts (mask);

	do loop = 1 to event_wait_list_n_channels;

	     call ipc_util_$verify_channel (event_wait_list.channel_id (loop), ectep, ("0"b), (0));

	     do wcpp = wait_channel.first_wcpp repeat (waiting_control_point.next_wcpp) while (wcpp ^= null ());
		if waiting_control_point.control_point_id = current_control_point_id
		then do;				/* this control point is already blocked on this channel */
			waiting_control_point.block_count = waiting_control_point.block_count + 1;
			go to PROCESS_NEXT_CHANNEL;
		     end;
	     end;

	     /*** Current control point not already blocked on this channel
		-- Setup another waiting_control_point for the channel */

	     call ipc_util_$make_entry (ect_ptr, WAITING_CP, wcpp, (0));
	     waiting_control_point.control_point_id = current_control_point_id;
	     waiting_control_point.block_count = 1;

	     if wait_channel.first_wcpp = null ()
	     then do;				/* first control point for this channel */
		     if wait_channel.last_wcpp ^= null ()
		     then call inconsistent_ect ();
		     wait_channel.first_wcpp = wcpp;
		     waiting_control_point.prev_wcpp = null ();
		end;
	     else do;				/* add to the end of the list for this channel */
		     if wait_channel.last_wcpp = null ()
		     then call inconsistent_ect ();
		     if wait_channel.last_wcpp -> waiting_control_point.next_wcpp ^= null ()
		     then call inconsistent_ect ();
		     wait_channel.last_wcpp -> waiting_control_point.next_wcpp = wcpp;
		     waiting_control_point.prev_wcpp = wait_channel.last_wcpp;
		end;

	     wait_channel.last_wcpp = wcpp;		/* this control point is now the tail of the list */
	     waiting_control_point.next_wcpp = null ();

PROCESS_NEXT_CHANNEL:
	end;

	added_to_waiting_lists = YES;

	call unmask_ips_interrupts (mask);

     end add_to_waiting_lists;
%page;
/* Make the current control point BLOCKED -- If, however, there are either wait
   or call events pending which are destined for this control point, we must
   not enter the BLOCKED state.  If we did block, we would remain blocked
   until another event arrived which could possibly never happen. */

block_if_no_pending_events:
     procedure ();

dcl	loop		fixed binary;


/* First check the channels on which we are blocked */

	do loop = 1 to event_wait_list_n_channels;

	     call ipc_util_$verify_channel (event_wait_list.channel_id (loop), ectep, ("0"b), P_code);
	     if P_code ^= 0
	     then return;
	     if wait_channel.type ^= WAIT
	     then do;
		     P_code = error_table_$not_a_wait_channel;
		     return;
		end;

	     if wait_channel.fast_channel = YES
	     then if substr (ipc_data_$fast_channel_events, wait_channel.fast_channel_id, 1) = YES
		then return;
		else ;

	     else /*** if wait_channel.fast_channel = NO then */
		if wait_channel.first_ev_msgp ^= null ()
	     then return;
	     else ;
	end;


/* No events for any of the above channels -- Check all call channels */

	do ectep = ect_header.firstp (CALL) repeat (call_channel.next_chanp) while (ectep ^= null ());

	     if call_channel.type ^= CALL
	     then call inconsistent_ect ();

	     if call_channel.control_point_id = current_control_point_id
	     then if call_channel.first_ev_msgp ^= null ()
		then return;
	end;


/* Control arrives here iff there are no events already present for
   this control point -- Block. */

	call cpm_$block ();

	return;

     end block_if_no_pending_events;
%page;
/* Removes the current control point from the above lists --
   A non-quick version of this procedure follows on the next page*/

delete_from_waiting_lists:
     procedure ();

dcl	code		fixed binary (35);
dcl	loop		fixed binary;

	call mask_ips_interrupts (mask);

	do loop = 1 to event_wait_list_n_channels;

	     call ipc_util_$verify_channel (event_wait_list.channel_id (loop), ectep, ("0"b), code);
	     if code ^= 0				/* the channel is no longer OK: skip it */
	     then go to PROCESS_NEXT_CHANNEL;
	     if wait_channel.type ^= WAIT		/* the channel is no longer a wait channel: skip it */
	     then go to PROCESS_NEXT_CHANNEL;

	     do wcpp = wait_channel.first_wcpp repeat (waiting_control_point.next_wcpp) while (wcpp ^= null ());

		if waiting_control_point.control_point_id = current_control_point_id
		then do;				/* found the proper entry */

			if waiting_control_point.block_count = 1
			then do;			/* this is the only time we were waiting on this channel */
				if waiting_control_point.prev_wcpp = null ()
				then do;		/* this was the first control point for this channel */
					if wait_channel.first_wcpp ^= wcpp
					then call inconsistent_ect ();
					wait_channel.first_wcpp = waiting_control_point.next_wcpp;
				     end;
				else do;		/* remove this control point from the middle of the list */
					if waiting_control_point.prev_wcpp -> waiting_control_point.next_wcpp
					     ^= wcpp
					then call inconsistent_ect ();
					waiting_control_point.prev_wcpp -> waiting_control_point.next_wcpp =
					     waiting_control_point.next_wcpp;
				     end;
				if waiting_control_point.next_wcpp = null ()
				then do;		/* this is the last control point for this channel */
					if wait_channel.last_wcpp ^= wcpp
					then call inconsistent_ect ();
					wait_channel.last_wcpp = waiting_control_point.prev_wcpp;
				     end;
				else do;		/* remove this control point from the middle of the list */
					if waiting_control_point.next_wcpp -> waiting_control_point.prev_wcpp
					     ^= wcpp
					then call inconsistent_ect ();
					waiting_control_point.next_wcpp -> waiting_control_point.prev_wcpp =
					     waiting_control_point.prev_wcpp;
				     end;
				call ipc_util_$delete_entry (ect_ptr, wcpp);
			     end;

			else waiting_control_point.block_count = waiting_control_point.block_count - 1;
						/* this control point is still waiting on this channel */

			go to PROCESS_NEXT_CHANNEL;
		     end;
	     end;

	     call inconsistent_ect ();		/* we aren't on the channel's list but we should be */

PROCESS_NEXT_CHANNEL:
	end;

	added_to_waiting_lists = NO;

	call unmask_ips_interrupts (mask);

     end delete_from_waiting_lists;



/* Invoke delete_from_waiting_lists -- This entrypoint exists to prevent making
   the delete_from_waiting_lists internal procedure non-quick by invoking it
   from within an on unit. */

delete_from_waiting_lists_caller:
     entry (P_event_wait_list_ptr);

	call find_ectp ();

	event_wait_list_ptr = P_event_wait_list_ptr;
	event_wait_list_n_channels = event_wait_list.n_channels;

	current_control_point_id = get_control_point_id_ ();

	mask = ""b;				/* for any_other handler */
	on any_other call any_other_handler ();

	call delete_from_waiting_lists ();

	return;
%page;
/* Wakeup blocked control points -- If a control point is blocked on an event
   wait channel, it must be notified when a message arrives on that channel.
   Further, if a message arrives for an event call channel, the control point
   which "owns" that channel must be notified. */

wakeup_blocked_control_points:
     procedure ();

dcl	1 a_wait_channel	like wait_channel aligned based (an_ectep);
dcl	1 a_call_channel	like call_channel aligned based (an_ectep);
dcl	an_ectep		pointer;

	do an_ectep = ect_header.firstp (WAIT) repeat (a_wait_channel.next_chanp) while (an_ectep ^= null ()),
	     ect_header.firstp (CALL) repeat (a_call_channel.next_chanp) while (an_ectep ^= null ());
	     if a_wait_channel.wakeup_control_points = YES
	     then call wakeup_channel_control_points (an_ectep);
	end;

	ect_header.wakeup_control_points = NO;

	return;

     end wakeup_blocked_control_points;



/* Wakeup the control points waiting on a single channel */

wakeup_channel_control_points:
     procedure (p_ectep);

dcl	p_ectep		pointer parameter;

dcl	1 p_call_channel	like call_channel aligned based (p_ectep);
dcl	1 p_wait_channel	like wait_channel aligned based (p_ectep);

	if p_wait_channel.type = WAIT
	then do;					/* a wait channel */
		do wcpp = p_wait_channel.first_wcpp repeat (waiting_control_point.next_wcpp) while (wcpp ^= null ());
		     call cpm_$wakeup (waiting_control_point.control_point_id, (0));
		end;
		p_wait_channel.wakeup_control_points = NO;
	     end;

	else do;					/* a call channel */
		call cpm_$wakeup (p_call_channel.control_point_id, (0));
		p_call_channel.wakeup_control_points = NO;
	     end;

	return;

     end wakeup_channel_control_points;
%page;
/* Resets a channel's waiting control points -- Any control points blocked on
   the channel are sent wakeups so that they may run and find that the channel
   has either been deleted or converted to an event call channel.  The list of
   waiting control points is then deleted from the ECT. */

reset_channel_wcps:
     procedure ();

dcl	next_wcpp		pointer;

	if (have_multiple_control_points () = YES) & (wait_channel.wakeup_control_points = YES)
	then call wakeup_channel_control_points (ectep);

	if wait_channel.first_wcpp ^= null ()
	then do;
		do wcpp = wait_channel.first_wcpp repeat (next_wcpp) while (wcpp ^= null ());
		     next_wcpp = waiting_control_point.next_wcpp;
		     call ipc_util_$delete_entry (ect_ptr, wcpp);
		end;
		wait_channel.first_wcpp, wait_channel.last_wcpp = null ();
	     end;

	return;

     end reset_channel_wcps;

/* format: off */
%page; %include ect_structures;
%page; %include event_call_info;
%page; %include event_channel_name;
%page; %include event_wait_info;
%page; %include event_wait_list;
%page; %include ipc_create_arg;
%page; %include stack_header;
%page; %include cpm_entries;
%page; %include cpm_data_;
/* format: on */

     end ipc_real_;
