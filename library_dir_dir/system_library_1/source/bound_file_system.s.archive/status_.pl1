/****^  **************************************************************
        *                                                            *
        * Copyright, (C) Massachusetts Institute of Technology, 1983 *
        *                                                            *
        * Copyright, (C) Honeywell Information Systems Inc., 1982    *
        *                                                            *
        * Copyright (c) 1972 by Massachusetts Institute of           *
        * Technology and Honeywell Information Systems, Inc.         *
        *                                                            *
        ************************************************************** */



/* format: style2 */

status_:
     proc (a_dir_name, a_entryname, a_chase, a_return_struc_ptr, a_return_area_ptr, a_code);

/* STATUS returns the contents of a specified entry
   in a directory.
   dir_name = path name of directory (input)
   entry = name of the entry to be listed (input)
   chase = a switch when =1 means list the branch pointed to by "entry" (input)
   type = indicates whether "entry" (output) is a non-dir branch (=1),
   dir branch (=2), or a link (=0)
   return_struc_ptr = the pointer to the structure in which items from "entry" will be returned
   status_area_ptr = pointer to an area in which the names will be returned
   if it is null, no names will be returned. */


/* ************************************************************************** */
/* ************************************************************************** */
/* ************************************************************************** */
/*
   *
   *    NN    NN   OOOOOO   TTTTTTTT  EEEEEEEE
   *    NNN   NN  OO    OO     TT     EE
   *    NN N  NN  OO    OO     TT     EE
   *    NN NN NN  OO    OO     TT     EEEEEEE
   *    NN  N NN  OO    OO     TT     EE
   *    NN  NNNN  OO    OO     TT     EE
   *    NN   NNN  OO    OO     TT     EE
   *    NN    NN   OOOOOO      TT     EEEEEEEE
   *
   *    The variable status_call MUST be set in any entry to this program
   *    before any calls to fatal_error, or the establishment of any
   *    cleanup handler. It should be set to zero for attributes, and
   *    other values for status info. Only status_ and status_long_
   *    should set values other than 0 and 3.
   *
   /**************************************************************************** */
/* *************************************************************************** */
/* *************************************************************************** */


/****^  HISTORY COMMENTS:
  1) change(85-10-31,Lippard), approve(86-06-02,MCR7427),
     audit(86-06-17,Farley), install(86-06-17,MR12.0-1077):
      Modified to zero out status_branch structures before calling dc_find
      so that status_link.pathname_length is zeroed when user doesn't have
      status permission on the containing directory.
  2) change(86-05-20,Lippard), approve(86-06-02,MCR7427),
     audit(86-06-17,Farley), install(86-06-17,MR12.0-1077):
      Modified to not set status_branch.nnames if user doesn't have status
      permission, change status_for_backup to not return bogus information.
  3) change(86-07-03,Farley), approve(86-07-03,MCR7427),
     audit(86-07-03,Fawcett), install(86-07-07,MR12.0-1086):
     This change is a PBF to installation 1077. The effective mode was being
     returned one bit position off.
                                                   END HISTORY COMMENTS */

/* Modified 1985-05-08, EJ Sharpe: added get_mdir_status_priv, made get_mdir_status non-privileged,
	changed get_mdir_status_uid to get_mdir_status_uid_priv */
/* Modified 1985-04-19, BIM: include parent access class in entry_access_info */
/* Modified 04/08/85 by Keith Loepere to use fs_modes when possible (gets priv init right). */
/* Modified 03/25/85 by M. Pandolf to add get_access_(info info_seg) entries */
/* Modified 02/21/85 by E. Swenson to add get_user_access_modes_seg entry */
/* Modified 10/19/84 by Keith Loepere to properly copy status_for_backup. */
/* Modified 9/25/84 by EJ Sharpe for new entry get_user_raw_mode */
/* Modified 6/14/84 Keith Loepere to use the new dc_find */
/* Modified 1/84 BIM for 18 bit quota values */
/* Modified 6/9/83 Jay Pattin to not require status permission in get_author, get_bc_author, and status_for_backup */
/* Modified 830427 BIM to set dp in the root case. */
/* Modified 2/26/83 Jay Pattin to add get_uid_file */
/* Modified 1/3/83 Jay Pattin to add get_user_access_modes */
/* Modified 2/83, BIM, to stop zeroing the version in status_for_backup  and fix Harcore 519. */
/* Modified September 1982, J. Bongiovanni, for synchronized switch, init bug */
/* Modified 3/82, BIM: (1) stop using sfs, (2) get_user_exmode,
   (3) overall cleanup, (4) general branch entrypoint.
   /* Modified 06/08/81, WOS: (1) Accept default of -1 for ring number in get_user_effmode,
   (2): Return documented directory mode values in get_user_effmode (turn off "e" bit)
   (3): Return access without regard to dir_name access if requested username
   is that of calling process, in get_user_effmode. */
/* Modified 11/26/80 W. Olin Sibert to fail when returning names in wrong component of extensible area */
/* Modified 10/79 by Mike Grady to set ptrs and counts before getting space in system
   free seg for names and such. Bug found by GDixon. */
/* Modified 9 Feb 79 by D. Spector to allow call to access_mode$user return an
   error code (status_$get_user_effmode) */
/* Modified 11/15/78 by C. D. Tavares to use status_structures.incl.pl1 */
/* Modified July 1977 by THVV for Bratt's MCR 2364 to return all but names in no_s_permission case */
/* Modified 07/77 by THVV for bad_dir_ check */
/* Modified July 1976 by R. Bratt to return uid in partial info case */
/* Modified June 1976 by R. Bratt to call find_$finished */
/* Modified April 1976 by R. Bratt to check mountedness and return partial info */
/* Modified March 1976 by Larry Johnson for master_dir status entries */
/* Modified March 1976 by R. Bratt for tpd */
/* 11/17/75 RE Mullen: status_for_backup to ret UID's and master_dir */
/* 9/25/75 RE Mullen: remove obsolete seg_activity and backup_branch_info entrypoints */
/* 9/25/75 RE Mullen: status_for_backup to not go to vtoc for maxlength */
/* Modified for NSS 4/75 by THVV */

	dcl     a_access_class	 bit (72) aligned parameter;
	dcl     a_auth		 char (*) parameter;
	dcl     a_bkptr		 ptr parameter;
	dcl     a_bitcnt		 fixed bin (24) parameter;
	dcl     a_chase		 fixed bin (1) parameter;
	dcl     a_code		 fixed bin (35) parameter;
	dcl     a_dates		 (*) bit (36) parameter;
	dcl     a_dir_name		 char (*) parameter;
	dcl     a_entryname		 char (*) parameter;
	dcl     a_ex_modes		 bit (36) aligned parameter;
	dcl     a_max_length	 fixed bin (19) parameter;
	dcl     a_mode		 fixed bin (5) parameter;
	dcl     a_modes		 bit (36) aligned parameter;
						/* note difference in dcl */
	dcl     a_ncd		 fixed bin parameter;
	dcl     a_nid		 fixed bin parameter;
	dcl     a_quota		 fixed bin (18) parameter;
	dcl     a_return_area_ptr	 ptr parameter;
	dcl     a_return_struc_ptr	 ptr parameter;
	dcl     a_ring		 fixed bin parameter;
	dcl     a_safety_sw		 bit (1) parameter;
	dcl     a_seg_usage		 fixed bin (35) parameter;
	dcl     a_segptr		 ptr parameter;
	dcl     a_type		 fixed bin (2) parameter;
	dcl     a_uidpath		 (0:15) bit (36) aligned parameter;
	dcl     a_user		 char (*) parameter;
	dcl     a_voluid		 bit (36) aligned parameter;

/* VARIABLES */

	dcl     access_class	 bit (72) aligned;
	dcl     auth		 char (32) aligned;
	dcl     bitcnt		 fixed bin (24);
	dcl     bkptr		 ptr;
	dcl     1 bks		 aligned like status_for_backup;
	dcl     called_find		 bit (1) aligned init ("0"b);
	dcl     chase		 fixed bin (1);
	dcl     code		 fixed bin (35);
	dcl     cur_length		 fixed bin (35);
	dcl     dates		 (5) bit (36);
	dcl     dir_name		 char (168);
	dcl     dummy		 fixed bin (35);
	dcl     entryname		 char (32);
	dcl     1 local_entry_access_info
				 like entry_access_info;
	dcl     ex_mode_entry	 bit (1) aligned;
	dcl     exmode		 bit (36) aligned;
	dcl     have_s_permission	 bit (1) aligned init ("1"b);
	dcl     i			 fixed bin;
	dcl     locked		 bit (1) aligned init ("0"b);
	dcl     max_length		 fixed bin (19);
	dcl     mode		 bit (36) aligned;
	dcl     n_names_to_allocate	 fixed bin;
	dcl     name_rp		 bit (18) aligned;
	dcl     names_seen		 fixed bin;
	dcl     ncd		 fixed bin;
	dcl     nid		 fixed bin;
	dcl     nnp		 ptr;
	dcl     pathname_length_to_allocate
				 fixed bin;
	dcl     pathname_supplied	 bit (1) aligned;
	dcl     pathname_varying	 char (168) varying;
	dcl     pvid		 bit (36) aligned;
	dcl     1 qcell		 like quota_cell aligned automatic;
	dcl     r			 (3) fixed bin (3);
	dcl     raw_mode_entry	 bit (1) aligned;
	dcl     rec_used		 fixed bin (9);
	dcl     return_area_ptr	 pointer;
	dcl     return_names_or_pathname
				 bit (1) aligned;
	dcl     return_names_ptr	 pointer init (null ());
	dcl     return_pathname_ptr	 pointer init (null ());
	dcl     return_pathname_sw	 bit (1);
	dcl     return_struc_ptr	 ptr;
	dcl     rexmode		 bit (36) aligned;
	dcl     ring		 fixed bin;
	dcl     rmode		 bit (36) aligned;
	dcl     root_lvid		 bit (36) aligned;	/* logical volume ID of the root */
	dcl     safety_sw		 bit (1) aligned;
	dcl     saved_dir_change_pclock
				 fixed bin (35);
	dcl     seg_usage		 fixed bin (35);
	dcl     segptr		 pointer;
	dcl     status_call		 fixed bin (3);
	dcl     tcode		 fixed bin (35);
	dcl     type		 fixed bin;
	dcl     uid		 bit (36) aligned;
	dcl     uidpath		 (0:15) bit (36) aligned;
	dcl     user		 char (32) aligned;
	dcl     vol_dtd		 bit (36);
	dcl     volid		 (3) bit (36);
	dcl     vtocx		 fixed bin;

/* * * * * TEXT SECTION REFERENCES * * * * * * * */

	dcl     ENTRY_status_	 initial (1) fixed binary (3) internal static options (constant);
						/* note that there is code in this program which */
	dcl     ENTRY_status_long	 initial (2) fixed binary (3) internal static options (constant);
						/* assumes this ordering of these indicators */
	dcl     ENTRY_status_min	 initial (3) fixed binary (3) internal static options (constant);
						/* section of the procedure */

/* BASED */

	dcl     return_area		 area based (return_area_ptr);
	dcl     return_names	 (n_names_to_allocate) character (32) unaligned based (return_names_ptr);
	dcl     return_pathname	 aligned based (return_pathname_ptr) char (pathname_length_to_allocate);
	dcl     1 status_branch_short	 aligned based (status_ptr) like status_branch.short;

/* EXTERNAL */

	dcl     error_table_$bad_arg	 fixed bin (35) external;
	dcl     error_table_$dirseg	 fixed bin (35) external;
	dcl     error_table_$link	 fixed bin (35) external;
	dcl     error_table_$mdc_not_mdir
				 fixed bin (35) external;
	dcl     error_table_$no_s_permission
				 fixed bin (35) external;
	dcl     error_table_$noalloc	 fixed bin (35) external;
	dcl     error_table_$notalloc	 fixed bin (35) external;
	dcl     error_table_$null_info_ptr
				 fixed bin (35) external;
	dcl     error_table_$root	 fixed bin (35) external;
	dcl     error_table_$unimplemented_version
				 fixed bin (35) static external;
	dcl     pds$process_group_id	 char (32) aligned external static;
	dcl     pvt$root_lvid	 bit (36) aligned external;
	dcl     pvt$root_pvid	 bit (36) aligned external;
	dcl     pvt$root_vtocx	 fixed bin external;

/* ENTRIES */

	dcl     acc_name_$get	 entry (ptr, ptr);
	dcl     access_mode$effective	 entry (ptr, bit (36) aligned, bit (36) aligned, fixed bin (35));
	dcl     access_mode$raw	 entry (ptr, bit (36) aligned, bit (36) aligned, fixed bin (35));
	dcl     access_mode$user	 entry (ptr, char (32) aligned, bit (36) aligned, bit (36) aligned,
				 fixed bin (35));
	dcl     fs_modes$locked	 entry (ptr, bit (36) aligned, bit (36) aligned, (3) fixed bin (3),
				 fixed bin (35));
	dcl     get_pathname_	 entry (fixed bin (17), char (*) varying, fixed bin (35));
	dcl     level$get		 entry () returns (fixed bin (3));
	dcl     lock$dir_lock_read	 entry (ptr, fixed bin (35));
	dcl     lock$dir_unlock	 entry (ptr);
	dcl     mountedp		 entry (bit (36) aligned) returns (fixed bin (35));
	dcl     uid_path_util$get	 entry (ptr, dim (0:15) bit (36) aligned, fixed bin (35));
	dcl     vtoc_attributes$get_dump_info
				 entry (bit (36) aligned, bit (36) aligned, fixed bin, bit (36), (3) bit (36),
				 fixed bin (35));
	dcl     vtoc_attributes$get_dump_switches
				 entry (bit (36) aligned, bit (36) aligned, fixed bin, fixed bin, fixed bin,
				 fixed bin (35));
	dcl     vtoc_attributes$get_info
				 entry (bit (36) aligned, bit (36) aligned, fixed bin, ptr, fixed bin (35));
	dcl     vtoc_attributes$get_quota
				 entry (bit (36) aligned, bit (36) aligned, fixed bin, ptr, fixed bin,
				 fixed bin (35));

/* MISC */

	dcl     (addr, baseno, bin, divide, fixed, hbound, ptr, null, rel, segno, substr, unspec)
				 builtin;

	dcl     area		 condition;
	dcl     bad_dir_		 condition;
	dcl     cleanup		 condition;
	dcl     seg_fault_error	 condition;
	dcl     stringsize		 condition;
%page;
/* status:	proc (a_dir_name, a_entryname, a_chase, a_return_struc_ptr, a_return_area_ptr, a_code); */

	status_call = ENTRY_status_;
	go to status_join;				/* Join common code. */


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

long:
     entry (a_dir_name, a_entryname, a_chase, a_return_struc_ptr, a_return_area_ptr, a_code);

	status_call = ENTRY_status_long;

/* status_ and status_long join here. status_min* does not come in here */

status_join:
	return_struc_ptr = a_return_struc_ptr;
	return_area_ptr = a_return_area_ptr;
	call copy_and_check_pathname_arg;
	chase = a_chase;
	code = 0;
	tcode = 0;
	status_ptr = return_struc_ptr;
	n_names_to_allocate = 0;
	pathname_length_to_allocate = 0;

	if status_call = ENTRY_status_
	then unspec (status_branch_short) = ""b;	/* clear it out */
	else unspec (status_branch) = ""b;

	on cleanup call clean_up_status_;

/* Now set some bit flags to determine what work will be needed */

	return_names_or_pathname = (return_area_ptr ^= null);

RETRY_STATUS:
	call dc_find$obj_status_attributes_read (dir_name, entryname, chase, ep, code);
	if code = error_table_$no_s_permission
	then have_s_permission = "0"b;
	else if code ^= 0
	then call fatal_error (code);
	locked, called_find = "1"b;

	dp = ptr (ep, 0);

	call get_type;				/* Get segment type, bit count, and ring brackets. */

/* See how much stuff to allocate */
/* the qualifier of entry is set already */
/* assume we need entry.nnames, and only discover bad_dir_ later */

	if ^return_names_or_pathname
	then do;
		n_names_to_allocate = 0;
		pathname_length_to_allocate = 0;
	     end;
	else do;
		n_names_to_allocate = entry.nnames;
		if type = Link
		then pathname_length_to_allocate = link.pathname_size;

/* Now unlock, allocate, and relock */

		saved_dir_change_pclock = dir.change_pclock;

		call lock$dir_unlock (dp);		/* unlock, i say */
		locked = "0"b;			/* for cleanup benefit */

		on area call fatal_error (error_table_$noalloc);

		if n_names_to_allocate > 0
		then do;
			if have_s_permission
			then allocate return_names in (return_area) set (return_names_ptr);
			else n_names_to_allocate = 0; /* if no status, we have no name structure to copy */
		     end;
		if pathname_length_to_allocate > 0
		then allocate return_pathname in (return_area) set (return_pathname_ptr);

		if return_names_ptr ^= null | return_pathname_ptr ^= null
		then do;
			if (return_names_ptr ^= null & baseno (return_names_ptr) ^= baseno (return_area_ptr))
			     | (return_pathname_ptr ^= null
			     & baseno (return_pathname_ptr) ^= baseno (return_area_ptr))
			then call fatal_error (error_table_$notalloc);


/* note that we could retry the allocation to try to get it into the */
/* segment, but there is a better entrypoint on the way anyway */

/* now relock and check for races */
/* if the dir has been deleted, we could seg-fault here */

			on seg_fault_error signal bad_dir_;

			call lock$dir_lock_read (dp, code);
			if code ^= 0
			then call fatal_error (code);
			locked = "1"b;
			revert seg_fault_error;

			if dir.change_pclock ^= saved_dir_change_pclock
			then do;
				call unlock_dir;
				call clean_up_status_;
						/* free storage */
				go to RETRY_STATUS;
			     end;
		     end;
	     end;

/* Okay, now the dir is locked, and any allocated storage needed */
/* to return the data has been allocated */
/* go ahead and fill things in */

	if type ^= Link
	then do;					/* if a branch */
		if type = Directory
		then tcode = 0;			/* RLV always mounted */
		else tcode = mountedp (dir.sons_lvid);	/* check mountedness */
		if tcode = 0
		then call get_vtoc;			/* okay its mounted */
		else unspec (sc_info) = "0"b;		/* DAMN, give him partial info, N.B. tcode must get out */

		rec_used = sc_info.records;
		cur_length = sc_info.csl;
	     end;
	else tcode = 0;

	uid = entry.uid;				/* can always know uid */

	status_branch.type = type;			/* set fixed information */

/* status_branch.nnames is set to 0 when no names are allocated, regardless of
   whether or not the caller has status permission. As per specs in documentation. */
	status_branch.nnames = 0;
	if n_names_to_allocate > 0			/* we have allocated them */
	then do;
		status_branch.names_relp = rel (return_names_ptr);
		status_branch.nnames = entry.nnames;

		names_seen = 0;
		do name_rp = entry.name_frp repeat ptr (dp, name_rp) -> names.fp while (name_rp ^= ""b);

		     nnp = ptr (dp, name_rp);
		     if nnp -> names.type ^= NAME_TYPE | nnp -> names.owner ^= entry.uid
			| nnp -> names.entry_rp ^= rel (ep)
		     then signal bad_dir_;
		     names_seen = names_seen + 1;
		     if names_seen > n_names_to_allocate
		     then signal bad_dir_;
		     return_names (names_seen) = nnp -> names.name;
		end;
		if names_seen < n_names_to_allocate
		then signal bad_dir_;
	     end;

	if type = Link
	then do;
		if return_pathname_ptr ^= null
		then do;
			status_link.pathname_relp = rel (return_pathname_ptr);
			on stringsize signal bad_dir_;
(stringsize):
			return_pathname = link.pathname;
			revert stringsize;
		     end;

		status_link.dtem = entry.dtem;
		status_link.dtd = entry.dtd;
		status_link.pathname_length = link.pathname_size;
	     end;
	else do;					/* branch only items */
		status_branch.dtu = sc_info.dtu;
		status_branch.dtcm = sc_info.dtm;
		call access_mode$effective (ep, mode, exmode, dummy);
		if type = Segment
		then status_branch.mode = "0"b || substr (mode, 1, 3);
		else status_branch.mode = "0"b || substr (exmode, 1, 1) || "1"b || substr (exmode, 2, 2);
		status_branch.records_used = rec_used;

		call access_mode$raw (ep, rmode, rexmode, dummy);
						/* get raw bits for pad field */
		if type = Segment
		then mode = "0"b || substr (rmode, 1, 3);
		else mode = "0"b || substr (rexmode, 1, 1) || "1"b || substr (rexmode, 2, 2);
		status_branch.raw_mode = substr (mode, 1, 5);

		if status_call ^= ENTRY_status_long
		then goto GOOD_RETURN;

		status_branch.long.dtd = entry.dtd;
		status_branch.long.dtem = entry.dtem;
		if type = Directory
		then status_branch.long.lvid = entry.sons_lvid;
		else status_branch.long.lvid = ptr (ep, 0) -> dir.sons_lvid;
		status_branch.long.current_length = divide (cur_length, 1024, 11, 0);
		status_branch.long.bit_count = bitcnt;
		status_branch.long.copy_switch = entry.copysw;
		status_branch.long.tpd_switch = entry.tpd;
		status_branch.long.mdir_switch = entry.master_dir;
		status_branch.long.damaged_switch = sc_info.damaged;
		status_branch.long.synchronized_switch = sc_info.synchronized;
		status_branch.long.ring_brackets (*) = r (*);
		status_branch.long.uid = entry.uid;
	     end;

GOOD_RETURN:
	if tcode = 0 & ^have_s_permission
	then tcode = error_table_$no_s_permission;

	call unlock_dir;

	a_code = tcode;				/* remember LV problems */
						/* or no_s_permission */
	return;
%page;
mins:
     entry (a_segptr, a_type, a_bitcnt, a_code);

	status_call = ENTRY_status_min;
	call copy_and_check_segptr_arg;

	call dc_find$obj_attributes_read_ptr (segptr, ep, code);
	if code ^= 0
	then call fatal_error (code);
	locked = "1"b;

	go to min_join;


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

minf:
     entry (a_dir_name, a_entryname, a_chase, a_type, a_bitcnt, a_code);


	status_call = ENTRY_status_min;
	call copy_and_check_pathname_arg;
	chase = a_chase;

	call dc_find$obj_attributes_read (dir_name, entryname, chase, ep, code);
	if code ^= 0
	then call fatal_error (code);
	locked, called_find = "1"b;

min_join:
	dp = ptr (ep, 0);

	call get_type;				/* Get type and bit count. */

	call unlock_dir;				/* Unlock_dir the directory now. */

	a_type = type;				/* Return the segment type. */
	a_bitcnt = bitcnt;				/* Return the bit count. */

	go to RETURN;
%page;
get_author:
     entry (a_dir_name, a_entryname, a_chase, a_auth, a_code);

	status_call = ENTRY_status_min;
	call copy_and_check_pathname_arg;
	chase = a_chase;

	call dc_find$obj_attributes_read (dir_name, entryname, chase, ep, code);
	if code ^= 0
	then call fatal_error (code);
	locked, called_find = "1"b;

	dp = ptr (ep, 0);

	call acc_name_$get (addr (entry.author), addr (auth));
						/* decode the name */

	call unlock_dir;				/* Unlock directory before returning info. */

	a_auth = auth;

	go to RETURN;


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

get_bc_author:
     entry (a_dir_name, a_entryname, a_auth, a_code);


	status_call = ENTRY_status_min;
	call copy_and_check_pathname_arg;

	call dc_find$obj_attributes_read (dir_name, entryname, 1, ep, code);
	if code ^= 0
	then call fatal_error (code);
	locked, called_find = "1"b;

	dp = ptr (ep, 0);

	call acc_name_$get (addr (entry.bc_author), addr (auth));

	call unlock_dir;

	a_auth = auth;

	go to RETURN;
%page;
get_uid_file:
     entry (a_dir_name, a_entryname, a_uid, a_code);

	declare a_uid		 bit (36) aligned parameter;

	status_call = ENTRY_status_min;
	call copy_and_check_pathname_arg ();

	call dc_find$obj_attributes_read (dir_name, entryname, 1, ep, code);
	if code ^= 0
	then call fatal_error (code);
	locked, called_find = "1"b;

	dp = ptr (ep, 0);

	uid = entry.uid;

	call unlock_dir ();

	a_uid = uid;
	go to RETURN;
%page;
get_user_access_modes:
     entry (a_dir_name, a_entryname, a_user, a_ring, a_modes, a_ex_modes, a_code);
						/* modes returned as bit strings (36) */
	ex_mode_entry = "1"b;
	raw_mode_entry = "0"b;
	pathname_supplied = "1"b;
	ring = a_ring;
	goto GET_MODE_JOIN;

get_user_access_modes_seg:
     entry (a_segptr, a_user, a_ring, a_modes, a_ex_modes, a_code);

	ex_mode_entry = "1"b;
	raw_mode_entry = "0"b;
	pathname_supplied = "0"b;
	ring = a_ring;
	goto GET_MODE_JOIN;

get_user_effmode:
     entry (a_dir_name, a_entryname, a_user, a_ring, a_mode, a_code);
						/* mode returned as fixed bin (5) */
	ex_mode_entry = "0"b;
	raw_mode_entry = "0"b;
	pathname_supplied = "1"b;
	ring = a_ring;
	goto GET_MODE_JOIN;

get_user_raw_mode:
     entry (a_dir_name, a_entryname, a_user, a_modes, a_code);
						/* mode returned as bit string (36) */
	ex_mode_entry = "0"b;
	raw_mode_entry = "1"b;
	pathname_supplied = "1"b;

GET_MODE_JOIN:
	user = a_user;				/* copy arg */

	if user = pds$process_group_id
	then user = "";				/* Make the default work (and not require s) */

	if (user = "")
	then /* Don't require dir_name access for this */
	     status_call = ENTRY_status_min;
	else status_call = 0;			/* Otherwise, not a status entry */

	if pathname_supplied
	then call copy_and_check_pathname_arg ();
	else call copy_and_check_segptr_arg ();		/* must be segptr entry */

	if ring < 0
	then ring = level$get ();			/* Default to validation level */
	else if ring > 7
	then ring = 7;				/* And make it "valid" */

	if pathname_supplied
	then do;
		if status_call = ENTRY_status_min
		then call dc_find$obj_attributes_read (dir_name, entryname, 1, ep, code);
						/* allow no s but non-null on object */
		else call dc_find$obj_status_read (dir_name, entryname, 1, ep, code);
	     end;
	else do;
		if status_call = ENTRY_status_min
		then call dc_find$obj_attributes_read_ptr (segptr, ep, code);
		else call dc_find$obj_status_read_ptr (segptr, ep, code);
	     end;

	if code ^= 0
	then call fatal_error (code);

	locked = "1"b;
	if pathname_supplied
	then called_find = "1"b;

	dp = ptr (ep, 0);

	if (user ^= "")
	then /* Someone other than ourselves */
	     call access_mode$user (ep, user, mode, exmode, code);
	else call access_mode$raw (ep, mode, exmode, code);
						/* Otherwise, determine our own mode */
	if code ^= 0
	then call fatal_error (code);

	call get_type;				/* Get segment type, ring brackets and bitcount. */

	call unlock_dir;				/* Unlock the directory now. */

	if raw_mode_entry
	then do;					/* don't need to factor in ring brackets */
		if type = Directory
		then a_modes = exmode;		/* "111"b = sma */
		else a_modes = mode;		/* "111"b = rew */
		goto RETURN;
	     end;

	if type = Directory
	then do;					/* for directories */
		mode = exmode;
		exmode = ""b;
		if ring <= r (1)
		then ;				/* all access allowed */
		else if ring <= r (2)
		then mode = (mode & "100"b);		/* status only */
		else mode = "0"b;
		if ^ex_mode_entry
		then mode = substr (mode, 1, 1) || "0"b || substr (mode, 2, 2);
						/* map "sma" into "rwa" */
	     end;
	else do;					/* a real segment */
		if ring < r (1)
		then mode = (mode & "101"b);
		else if ring = r (1)
		then ;
		else if ring <= r (2)
		then mode = (mode & "110"b);
		else if ring <= r (3)
		then mode = (mode & "010"b);
		else mode = "0"b;
	     end;

	if ex_mode_entry
	then do;
		a_modes = mode;
		a_ex_modes = exmode;
	     end;
	else a_mode = fixed (substr (mode, 1, 4), 5);	/* Return the effective mode. */
						/* the forth bit of the bit string */
						/* mode alignes with the lsb of the fixed bin number a_mode */
	go to RETURN;
%page;
status_for_backup:
     entry (a_dir_name, a_entryname, a_bkptr, a_code);

	status_call = ENTRY_status_min;
	call copy_and_check_pathname_arg;

	bkptr = a_bkptr;

	if bkptr = null
	then call fatal_error (error_table_$bad_arg);

	if bkptr -> status_for_backup.version ^= status_for_backup_version_2
	then call fatal_error (error_table_$unimplemented_version);

	call dc_find$obj_attributes_read (dir_name, entryname, 1, ep, code);
	if code ^= 0
	then call fatal_error (code);
	locked, called_find = "1"b;

	dp = ptr (ep, 0);

	unspec (bks) = "0"b;
	bks.version = status_for_backup_version_2;
	bks.switches.safety = entry.safety_sw;
	bks.switches.tpd = entry.tpd;
	bks.switches.security_oosw = entry.security_oosw;
	bks.switches.audit_flag = entry.audit_flag;
	bks.switches.multiple_class = entry.multiple_class;
	bks.switches.entrypt = entry.entrypt_sw;
	bks.entrypt_bound = entry.entrypt_bound;
	bks.access_class = entry.access_class;

	if entry.dirsw
	then do;
		bks.lvid = entry.sons_lvid;
		bks.switches.master_dir = entry.master_dir;
	     end;
	else bks.lvid = dp -> dir.sons_lvid;

	bks.pvid = entry.pvid;

	call acc_name_$get (addr (entry.author), addr (bks.author));

	call acc_name_$get (addr (entry.bc_author), addr (bks.bc_author));

	call unlock_dir;

	bkptr -> status_for_backup = bks;		/* return data to user */

	go to RETURN;
%page;

get_safety_sw_ptr:
     entry (a_segptr, a_safety_sw, a_code);

	status_call = ENTRY_status_min;
	call copy_and_check_segptr_arg;

	call dc_find$obj_attributes_read_ptr (segptr, ep, code);
	if code ^= 0
	then call fatal_error (code);
	locked = "1"b;

	go to safety_sw_join;


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


get_safety_sw:
     entry (a_dir_name, a_entryname, a_safety_sw, a_code);


	status_call = ENTRY_status_min;
	call copy_and_check_pathname_arg;

	call dc_find$obj_attributes_read (dir_name, entryname, 1, ep, code);
	if code ^= 0
	then call fatal_error (code);
	locked, called_find = "1"b;

safety_sw_join:
	dp = ptr (ep, 0);

	safety_sw = entry.safety_sw;

	call unlock_dir;

	a_safety_sw = safety_sw;

	go to RETURN;
%page;
get_seg_usage_ptr:
     entry (a_segptr, a_seg_usage, a_code);

	status_call = ENTRY_status_min;
	call copy_and_check_segptr_arg;

	call dc_find$obj_attributes_read_ptr (segptr, ep, code);
	if code ^= 0
	then call fatal_error (code);
	locked = "1"b;

	go to seg_usage_join;


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


get_seg_usage:
     entry (a_dir_name, a_entryname, a_seg_usage, a_code);


	status_call = ENTRY_status_min;
	call copy_and_check_pathname_arg;

	call dc_find$obj_attributes_read (dir_name, entryname, 1, ep, code);
	if code ^= 0
	then call fatal_error (code);
	locked, called_find = "1"b;

seg_usage_join:
	dp = ptr (ep, 0);

	if type = Directory
	then tcode = error_table_$dirseg;		/* Dirs have quota instead */
	else tcode = mountedp (dir.sons_lvid);		/* Make sure seg is mounted by user */
	if tcode ^= 0
	then call fatal_error (tcode);

	call get_vtoc;				/* Read AST or VTOCE */
	seg_usage = sc_info.pf_count;
	call unlock_dir;

	a_seg_usage = seg_usage;
	go to RETURN;
%page;

get_dates_ptr:
     entry (a_segptr, a_dates, a_code);

	status_call = ENTRY_status_min;
	call copy_and_check_segptr_arg;

	call dc_find$obj_attributes_read_ptr (segptr, ep, code);
	if code ^= 0
	then call fatal_error (code);
	locked = "1"b;

	go to dates_join;


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


get_dates:
     entry (a_dir_name, a_entryname, a_dates, a_code);


	status_call = ENTRY_status_min;
	call copy_and_check_pathname_arg;

	call dc_find$obj_attributes_read (dir_name, entryname, 1, ep, code);
	if code ^= 0
	then call fatal_error (code);
	locked, called_find = "1"b;

dates_join:
	dp = ptr (ep, 0);

	call get_vtoc_dates;

	dates (1) = sc_info.dtu;
	dates (2) = sc_info.dtm;
	dates (3) = entry.dtem;
	dates (4) = entry.dtd;
	dates (5) = vol_dtd;

	call unlock_dir;

	do i = 1 to hbound (a_dates, 1);
	     a_dates (i) = dates (i);
	end;

	go to RETURN;
%page;

get_volume_dump_switches_ptr:
     entry (a_segptr, a_nid, a_ncd, a_code);

	status_call = ENTRY_status_min;
	call copy_and_check_segptr_arg;

	call dc_find$obj_attributes_read_ptr (segptr, ep, code);
	if code ^= 0
	then call fatal_error (code);
	locked = "1"b;

	go to volume_dump_switches_join;


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


get_volume_dump_switches:
     entry (a_dir_name, a_entryname, a_nid, a_ncd, a_code);


	status_call = ENTRY_status_min;
	call copy_and_check_pathname_arg;

	call dc_find$obj_attributes_read (dir_name, entryname, 1, ep, code);
	if code ^= 0
	then call fatal_error (code);
	locked, called_find = "1"b;

volume_dump_switches_join:
	dp = ptr (ep, 0);

	call get_vtoc_volume_dump_switches;

	call unlock_dir;

	a_nid = nid;
	a_ncd = ncd;

	go to RETURN;
%page;

get_max_length_ptr:
     entry (a_segptr, a_max_length, a_code);

	status_call = ENTRY_status_min;
	call copy_and_check_segptr_arg;

	call dc_find$obj_attributes_read_ptr (segptr, ep, code);
	if code ^= 0
	then call fatal_error (code);
	locked = "1"b;

	go to max_length_join;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

get_max_length:
     entry (a_dir_name, a_entryname, a_max_length, a_code);



	status_call = ENTRY_status_min;
	call copy_and_check_pathname_arg;

	call dc_find$obj_attributes_read (dir_name, entryname, 1, ep, code);
	if code ^= 0
	then call fatal_error (code);
	locked, called_find = "1"b;

max_length_join:
	dp = ptr (ep, 0);

	if type = Directory				/* check mountedness for non-dirs */
	then tcode = 0;
	else tcode = mountedp (dir.sons_lvid);
	if tcode ^= 0
	then call fatal_error (tcode);

	call get_vtoc;
	max_length = sc_info.msl;

	call unlock_dir;

	a_max_length = max_length;

	go to RETURN;
%page;
get_access_class_ptr:
     entry (a_segptr, a_access_class, a_code);

	status_call = ENTRY_status_min;
	call copy_and_check_segptr_arg;

	call dc_find$obj_attributes_read_ptr (segptr, ep, code);
	if code ^= 0
	then call fatal_error (code);
	locked = "1"b;

	go to access_class_join;

get_access_class:
     entry (a_dir_name, a_entryname, a_access_class, a_code);

	status_call = ENTRY_status_min;
	call copy_and_check_pathname_arg;

	call dc_find$obj_attributes_read (dir_name, entryname, 1, ep, code);
	if code ^= 0
	then call fatal_error (code);
	locked, called_find = "1"b;

access_class_join:
	dp = ptr (ep, 0);

	access_class = entry.access_class;

	call unlock_dir;

	a_access_class = access_class;

	go to RETURN;
%page;

get_access_info:
     entry (a_dir_name, a_entryname, a_chase, a_return_struc_ptr, a_code);

	chase = a_chase;
	pathname_supplied = "1"b;

	go to get_access_info_join;

get_access_info_seg:
     entry (a_segptr, a_return_struc_ptr, a_code);

	pathname_supplied = "0"b;

get_access_info_join:
	status_call = ENTRY_status_min;

	entry_access_info_ptr = a_return_struc_ptr;
	if entry_access_info_ptr = null ()
	then call fatal_error (error_table_$null_info_ptr);
	else if entry_access_info.version ^= ENTRY_ACCESS_INFO_VERSION_1
	then call fatal_error (error_table_$unimplemented_version);

	if pathname_supplied
	then do;
		call copy_and_check_pathname_arg ();

		call dc_find$obj_attributes_read (dir_name, entryname, chase, ep, code);
		if code ^= 0
		then call fatal_error (code);

		dp = ptr (ep, 0);

		locked, called_find = "1"b;
	     end;
	else do;
		call copy_and_check_segptr_arg ();

		call dc_find$obj_attributes_read_ptr (segptr, ep, code);
		if code ^= 0
		then call fatal_error (code);

		dp = ptr (ep, 0);

		locked = "1"b;
	     end;

	if ^entry.bs				/* if entry is a link */
	then call fatal_error (error_table_$link);	/* we can't continue */
	else do;
		if called_find			/* use expensive access lookup */
		then call access_mode$effective (ep, mode, exmode, code);
		else call fs_modes$locked (segptr, mode, exmode, r, code);
						/* r gets overwritten at get_type */
		if code ^= 0
		then call fatal_error (code);

		call get_pathname_ (bin (segno (dp), 17, 0), pathname_varying, code);
		if code ^= 0
		then call fatal_error (code);

		local_entry_access_info.version = ENTRY_ACCESS_INFO_VERSION_1;

		call get_type;
		local_entry_access_info.type = type;

		local_entry_access_info.dir_name = pathname_varying;
		local_entry_access_info.entryname = addr (entry.primary_name) -> names.name;

		local_entry_access_info.uid = entry.uid;

		local_entry_access_info.ring_brackets (*) = r (*);
		if type = Directory
		then local_entry_access_info.extended_ring_brackets (*) = 0;
		else do i = 1 to 3;
			local_entry_access_info.extended_ring_brackets (i) = fixed (entry.ex_ring_brackets (i), 3);
		     end;


		if type = Segment
		then do;
			local_entry_access_info.effective_access_modes = mode;
			local_entry_access_info.extended_access_modes = exmode;
		     end;
		else do;
			local_entry_access_info.effective_access_modes = exmode;
			local_entry_access_info.extended_access_modes = ""b;
		     end;

		local_entry_access_info.access_class = entry.access_class;
		local_entry_access_info.multiclass = entry.multiple_class;
		local_entry_access_info.parent_access_class = dir.access_class;

	     end;

	call unlock_dir ();

	entry_access_info = local_entry_access_info;

	go to RETURN;

%page;

/* Status entries used by master directory control */

get_mdir_status:
     entry (a_dir_name, a_entryname, a_uidpath, a_voluid, a_quota, a_code);

	status_call = 0;
	call copy_and_check_pathname_arg;
	return_pathname_sw = "0"b;

	call dc_find$obj_status_read (dir_name, entryname, 0, ep, code);
						/* find it without chasing link */
	goto mdir_common;

get_mdir_status_priv:
     entry (a_dir_name, a_entryname, a_uidpath, a_voluid, a_quota, a_code);

	status_call = 0;
	call copy_and_check_pathname_arg;
	return_pathname_sw = "0"b;

	call dc_find$obj_status_read_priv (dir_name, entryname, 0, ep, code);
						/* find it without chasing link */

mdir_common:
	if code ^= 0
	then if code = error_table_$root
	     then go to mdir_root;			/* the root is NOT locked. we are making up this info */
	     else call fatal_error (code);

	dp = ptr (ep, 0);
	locked, called_find = "1"b;

	call check_master_dir;			/* must be master dir, which is on RLV */
	call get_vtoc_quota;			/* get vtoce atrrbiutes */

	a_quota = qcell.received;			/* and quota received */
	a_voluid = entry.sons_lvid;
	if ^return_pathname_sw
	then do;					/* need uid pathname */
		call uid_path_util$get (dp, uidpath, code);
		if code ^= 0
		then call fatal_error (code);
		uidpath (dir.tree_depth + 1) = entry.uid;
						/* finish name */
		a_uidpath = uidpath;
	     end;
	else do;
		a_dir_name = dir_name;
		a_entryname = entryname;
	     end;

	call unlock_dir;
	go to RETURN;

mdir_root:
	code = 0;					/* clear residual error_table_$root */
	dp = null;

	call get_vtoc_root;				/* read roots vtoc entry */
	a_quota = qcell.received;
	a_voluid = root_lvid;
	if ^return_pathname_sw
	then do;					/* make up pathname of root */
		uidpath = "0"b;
		uidpath (0) = (36)"1"b;
		a_uidpath = uidpath;
	     end;
	else do;
		a_dir_name = ">";
		a_entryname = "";
	     end;
	go to RETURN;

/* this entry is similiar to above, but is given a uid pathname to start with */

get_mdir_status_uid_priv:
     entry (a_uidpath, a_dir_name, a_entryname, a_voluid, a_quota, a_code);

	status_call = 0;
	call copy_and_check_pathname_arg;
	return_pathname_sw = "1"b;			/* remember to return pathname */
	uidpath = a_uidpath;
	call dc_find$obj_status_read_priv_uid (uidpath, dir_name, entryname, ep, code);
						/* find entry and lock dir_name */
	go to mdir_common;



/* procedure to check for a master directory */

check_master_dir:
     proc;

	if entry.bs
	then if entry.dirsw
	     then if entry.master_dir
		then do;
			code = 0;
			return;
		     end;
	call fatal_error (error_table_$mdc_not_mdir);


     end check_master_dir;
%page;
get_vtoc:
     proc;

	uid = entry.uid;
	pvid = entry.pvid;
	vtocx = entry.vtocx;
	call vtoc_attributes$get_info (uid, pvid, vtocx, addr (sc_info), dummy);
	if dummy ^= 0
	then call fatal_error (dummy);

     end get_vtoc;

get_vtoc_dates:
     proc;

	call get_vtoc;
	call vtoc_attributes$get_dump_info (uid, pvid, vtocx, vol_dtd, volid, dummy);
	if dummy ^= 0
	then call fatal_error (dummy);

     end get_vtoc_dates;

get_vtoc_volume_dump_switches:
     proc;

	uid = entry.uid;
	pvid = entry.pvid;
	vtocx = entry.vtocx;
	call vtoc_attributes$get_dump_switches (uid, pvid, vtocx, nid, ncd, dummy);
	if dummy ^= 0
	then call fatal_error (dummy);

     end get_vtoc_volume_dump_switches;


get_vtoc_quota:
     proc;					/* special get_vtoc for master dirs */

	uid = entry.uid;
	pvid = entry.pvid;
	vtocx = entry.vtocx;
	call vtoc_attributes$get_quota (uid, pvid, vtocx, addr (qcell), 0, code);
	if code ^= 0
	then call fatal_error (code);

     end get_vtoc_quota;

get_vtoc_root:
     proc;					/* get vtoce for the root master dir */

	uid = (36)"1"b;
	pvid = pvt$root_pvid;
	vtocx = pvt$root_vtocx;
	root_lvid = pvt$root_lvid;
	call vtoc_attributes$get_quota (uid, pvid, vtocx, addr (qcell), 0, code);
	if code ^= 0
	then call fatal_error (code);
	unspec (uidpath) = "0"b;			/* make up uidpathname */
	uidpath (0) = (36)"1"b;
	return;

     end get_vtoc_root;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

unlock_dir:
     proc;

	if called_find
	then call dc_find$finished (dp, locked);	/* unlock and unuse */
	else if locked
	then call lock$dir_unlock (dp);
	locked, called_find = "0"b;
     end unlock_dir;
%page;

get_type:
     proc;


	if entry.bs
	then do;					/* entry is a branch */
		if entry.dirsw
		then do;				/* entry is a directory branch */
			type = Directory;
			r (1) = fixed (entry.ex_ring_brackets (1), 3);
						/* return extended ring brackets */
			r (2) = fixed (entry.ex_ring_brackets (2), 3);
			r (3) = r (2);
		     end;
		else do;				/* entry is a non_directory branch */
			type = Segment;
			r (1) = fixed (entry.ring_brackets (1), 3);
						/* return ring brackets */
			r (2) = fixed (entry.ring_brackets (2), 3);
			r (3) = fixed (entry.ring_brackets (3), 3);
		     end;
		bitcnt = entry.bc;
	     end;

	else do;					/* entry is a link */
		type = Link;
		bitcnt = 0;
	     end;


     end get_type;
%page;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

fatal_error:
     procedure (e_code);
	declare e_code		 fixed bin (35);

	call unlock_dir;				/* cleanup */
	call clean_up_status_;			/* free storage if already dereferenced */

	a_code = e_code;
	go to ERR_RETURN;
     end fatal_error;

RETURN:
	a_code = 0;
ERR_RETURN:
	return;

copy_and_check_segptr_arg:
     procedure;

	segptr = a_segptr;
	if segptr = null
	then call fatal_error (error_table_$null_info_ptr);
     end copy_and_check_segptr_arg;

copy_and_check_pathname_arg:
     procedure;

	dir_name = a_dir_name;
	entryname = a_entryname;
	if dir_name = ""
	then call fatal_error (error_table_$bad_arg);
     end copy_and_check_pathname_arg;

clean_up_status_:
     procedure;

/* ASSUME that if we are called as a cleanup handler that */
/* a crawlout is in progress, and we should leave the dir locked */
/* so that verify_lock will find it. */


	if status_call = ENTRY_status_ | status_call = ENTRY_status_long
	then do;
		if return_names_ptr ^= null
		then free return_names;
		if return_pathname_ptr ^= null
		then free return_pathname;
	     end;
	if called_find				/* will be false on error exits */
	then do;
		call dc_find$finished (dp, "0"b);	/* dereference, but leave locked so verify_lock will salvage */
		called_find = "0"b;
	     end;
     end clean_up_status_;
%page;
%include dc_find_dcls;
%page;
%include dir_entry;
%page;
%include dir_header;
%page;
%include dir_link;
%page;
%include dir_name;
%page;
%include entry_access_info;
%page;
%include fs_types;
%page;
%include quota_cell;
%page;
%include sc_info;
%page;
%include status_for_backup;
%page;
%include status_structures;
     end status_;
