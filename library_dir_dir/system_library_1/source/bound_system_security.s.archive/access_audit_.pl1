/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(86-05-13,GJohnson), approve(86-05-13,MCR7387),
     audit(86-05-13,Martinson), install(86-05-14,MR12.0-1056):
     Correct error message documentation.
  2) change(88-01-13,Fawcett), approve(88-05-02,MCR7881),
     audit(88-06-21,Farley), install(88-08-02,MR12.2-1074):
     Changed to support always auditing of an fs_object whose entry.audit_flag
     has been set. This DOES NOT INHIBIT any other auditing cases if the flag
     is turned off.
  3) change(88-08-08,Farley), approve(88-08-08,PBF7881),
     audit(88-08-09,Martinson), install(88-08-09,MR12.2-1084):
     Changed always audit to only look at branches (no links) and to only
     audit ring-1 objects for segment level accesses..
                                                   END HISTORY COMMENTS */


/* format: style1,insnl,linecom,indcomtxt,^inddcls,^indnoniterdo */

access_audit_:
     procedure;

/* format: off */
/******
     Revisions:
     1985-04-08 EJ Sharpe - fix message text a bit, fix some comments
     1985-04-01 KP Loepere - removed check_entry_ptr in favor of new alm version.
     1985-03-04 EJ Sharpe - remove national chars, select proper sorting class for messages
     1985-01-22 EJ Sharpe - changes per code audit, reformat
     1985-01-13 EJ Sharpe - added message documenation and fixed some msgs
     1985-01-11 EJ Sharpe - optimization to unlock directory a bit earlier
     1985-01-07 EJ Sharpe - stack frame optimizations, fix audit check computation
			some routines removed to form access_audit_log_fault_ and access_audit_util_
			cleaned up syserr messages, etc.
     1984-12-06 EJ Sharpe - fix bug in log_fault text message, output full
			error table text for normal audit.
     1984-11-29 EJ Sharpe - fix threshold comparison, fix suppression of
			caller supplied msg when obj_name is null
     1984-11-26 EJ Sharpe - added caller_level argument for logging entries
			also added the four "obj path" entries
     1984-11-15 EJ Sharpe - fixed some alignment problems, optional message
			string is now included in our generated message
			instead of being the complete message itself
     1984-11-11 EJ Sharpe - removed a_msg_str parameters, misc fixes
     1984-11-08 EJ Sharpe - misc fixes, and respect "null entry ptr means root" convention
     1984-11-02 EJ Sharpe - added capability to deal with link entries
     1984-10-30 EJ Sharpe - a number of minor changes
     1984-10-18 EJ Sharpe - added check_* entries
     1984-10-17 EJ Sharpe - major changes for revised audit flag strategy
     1984-10-09 EJ Sharpe - created
******/
%page;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* ACCESS_AUDIT_								*/
	/*									*/
	/* This module performs most security auditing.  Trusted Computer Base (TCB) subsystems	*/
	/* call upon this module to format system audit messages or simply determine whether	*/
	/* auditing of a given event is necessary.					*/
	/*									*/
	/* See also:								*/
	/* access_audit_log_fault_ - performs auditing for fim				*/
	/* access_audit_util_ - contains utility functions				*/
	/* access_audit_check_ep_ - inspects audit flags for file system			*/
	/* fim - performs its own inspection of the process audit flags			*/
	/* page_fault - performs its own auditing of a particular covert channel while masked	*/
	/*									*/
	/* The following entries format security audit messages for insertion in the syserr log.	*/
	/*									*/
	/*       access_audit_$log_general						*/
	/*       access_audit_$log_general_user						*/
	/*		These entries log an event with no associated object.		*/
	/*									*/
	/*       access_audit_$log_obj_class_range					*/
	/*       access_audit_$log_obj_class_range_user					*/
	/*		These entries log an event where the involved object is not a storage */
	/*		system entity and whose access class is specified as a		*/
	/*		range (e.g. tape_drives).					*/
	/*									*/
	/*       access_audit_$log_obj_class						*/
	/*       access_audit_$log_obj_class_user					*/
	/*		These entries log an event where there is some arbitrary object	*/
	/*		involved.							*/
	/*									*/
	/*       access_audit_$log_obj_path						*/
	/*       access_audit_$log_obj_path_user					*/
	/*       access_audit_$log_obj_ptr						*/
	/*       access_audit_$log_obj_ptr_user						*/
	/*       access_audit_$log_entry_ptr						*/
	/*       access_audit_$log_entry_ptr_user					*/
	/*		These entries log an event where the involved object is a storage	*/
	/*		system entity.						*/
	/*									*/
	/*       access_audit_$log_no_process						*/
	/*		This is a special entry to log an event where there is no process	*/
	/*		associated with that event (e.g. preaccess).			*/
	/*									*/
	/*									*/
	/*  The following entries do not produce a log entry.  Instead they simply check the	*/
	/*  process audit flags and system audit thresholds against the given event.  A bit "1"	*/
	/*  or "0" is returned indicating that auditing is required or not, respectively.	*/
	/*									*/
	/*      access_audit_$check_general						*/
	/*      access_audit_$check_general_user					*/
	/* 	     These entries are called when there is no object associated with the	*/
	/*	     event (e.g. privilege setting, sending a wakeup, etc.).  The "user" entry	*/
	/*	     is called for proxy users.					*/
	/*									*/
	/*      access_audit_$check_obj_class_range					*/
	/*      access_audit_$check_obj_class_range_user					*/
	/* 	     These entries are called when the object associated with the event is not	*/
	/* 	     a storage system object and that object has an access class range (e.g.	*/
	/* 	     tape drives).  The "user" entry is called for proxy users.		*/
	/*									*/
	/*      access_audit_$check_obj_class						*/
	/*      access_audit_$check_obj_class_user					*/
	/* 	     These entries are called when an arbitrary object is associated with the	*/
	/* 	     event which has a single access class.  This may be a storage system	*/
	/* 	     object.  The "user" entry is called for proxy users.  (Note:  The user of	*/
	/* 	     this is preferred over the "obj_ptr" and "entry_ptr" entries for reasons	*/
	/* 	     of efficiency (when the caller "knows" the access class)).		*/
	/*									*/
	/*      access_audit_$check_obj_path						*/
	/*      access_audit_$check_obj_path_user					*/
	/*      access_audit_$check_obj_ptr						*/
	/*      access_audit_$check_obj_ptr_user					*/
	/* 	     These entries are called when the object associated with the event is a	*/
	/* 	     storage system entity.  The caller supplies either a pointer to the	*/
	/* 	     object itself.  The "user" entries					*/
	/* 	     are called for proxy users.  (Note:  When the caller already "knows" the	*/
	/* 	     access class of the object, the "obj_class" access_audit_$check_ entries	*/
	/* 	     should be used for efficiency purposes.)				*/
	/*									*/
	/*									*/
	/* The functions of each of these entries is explained in greater detail in the comment   */
	/* preceeding each entry respectively.						*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* format: on */
%page;

/*	PARAMETERS	*/

dcl     a_caller		 parameter char (*);	/* name of calling routine */
dcl     a_caller_level	 parameter fixed bin;	/* level to be reflected in audit message */
dcl     a_entry_ptr		 parameter pointer;		/* ptr to storage sys obj's dir entry */
dcl     a_err_code		 parameter fixed bin (35);	/* sys error code to put in audit message */
dcl     a_event_flags	 parameter bit (36) aligned;	/* actually is the audit flag index */
dcl     a_group_id		 parameter char (*);	/* for no_process entry only */
dcl     a_info_ptr		 parameter pointer;		/* caller's binary info fo the audit message */
dcl     a_info_size		 parameter fixed bin (21);	/* size of caller's binary info */
dcl     a_obj_class		 parameter bit (72) aligned;	/* access class of arbitrary object */
dcl     a_obj_class_range	 (2) parameter bit (72) aligned;
						/* access class range of non-stoarge-sys obj */
dcl     a_obj_name		 parameter char (*);	/* name of object (usually non-storage-system) */
dcl     a_obj_path		 parameter char (*);	/* pathname of storage system object */
dcl     a_obj_ptr		 parameter pointer;		/* ptr to storage system object */
dcl     a_oper_code		 parameter bit (36) aligned;	/* unique operation code for the TCB event */
dcl     a_user_audit_flags	 parameter bit (36) aligned;	/* audit flag array for proxy user */
dcl     a_user_auth		 parameter bit (72) aligned;	/* authorization of proxy user */
dcl     a_user_info_ptr	 parameter pointer;		/* structure of proxy user process info */


/*	CONSTANTS		*/

dcl     True		 bit (1) aligned int static options (constant) init ("1"b);
dcl     False		 bit (1) aligned int static options (constant) init ("0"b);

/*   Unique identifier for each logging entrypoint */
dcl     (
						/*	Check_*			init (00), - default value - see dcl for "entrypoint" */
        Log_General		 init (01),
        Log_General_User	 init (02),
        Log_Obj_Class_Range	 init (03),
        Log_Obj_Class_Range_User
			 init (04),
        Log_Obj_Class	 init (05),
        Log_Obj_Class_User	 init (06),
        Log_Obj_Path	 init (07),
        Log_Obj_Path_User	 init (08),
        Log_Obj_Ptr		 init (09),
        Log_Obj_Ptr_User	 init (10),
        Log_Entry_Ptr	 init (11),
        Log_Entry_Ptr_User	 init (12),
        Log_No_Process	 init (13)
        )			 fixed bin static internal options (constant);

/*   use unique entry identifier as index to get textual name */
dcl     EntryNames		 (0:13) char (24) int static options (constant) init (
			 "check_*",
			 "log_general",
			 "log_general_user",
			 "log_obj_class_range",
			 "log_obj_class_range_user",
			 "log_obj_class",
			 "log_obj_class_user",
			 "log_obj_path",
			 "log_obj_path_user",
			 "log_obj_ptr",
			 "log_obj_ptr_user",
			 "log_entry_ptr",
			 "log_entry_ptr_user",
			 "log_no_process");



/*	AUTOMATIC		*/

dcl     arg_list_ptr	 pointer;			/* pointer to our args */
dcl     called_dc_find	 bit (1) aligned;		/* specifies whether we should call dc_find$finished */
dcl     caller		 char (64);		/* arg copy */
dcl     caller_level	 fixed bin;		/* arg copy */
dcl     caller_supplied_text_sw
			 bit (1) aligned;		/* indicates caller supplied optional msg str arg */
dcl     caller_text_buff	 char (256);		/* we'll format caller's ctl str and opt args here */
dcl     caller_text_len	 fixed bin (21);		/* length of the text after formline_ */
dcl     caller_text_ptr	 pointer;			/* ptr to caller_text_buff */
dcl     char528v		 char (528) var;		/* temp var */
dcl     check_result	 bit (1) aligned;		/* result of flag/threshold evaluation */
dcl     check_sw		 bit (1) aligned;		/* flag indicating we're just checking, no logging */
dcl     code		 fixed bin (35);		/* err code returned from entries we call */
dcl     control_str_arg_index	 fixed bin;		/* tells formline_ where control str is */
dcl     entry_ptr		 pointer;			/* arg copy */
dcl     entrypoint		 fixed bin init (0);	/* entry point index */
dcl     entry_type_str	 char (10);		/* "segment", "directory", or "link" */
dcl     err_code		 fixed bin (35);		/* arg copy */
dcl     1 event_flags	 aligned like audit_event_flags;
						/* arg copy */
dcl     group_id		 char (32) aligned;		/* arg copy */
dcl     have_entry_sw	 bit (1) aligned;		/* indicates we have a ptr to a dir entry */
dcl     have_obj_path_sw	 bit (1) aligned;		/* indicates we have a path argument */
dcl     i			 fixed bin;		/* utility index */
dcl     info_ptr		 pointer;			/* arg copy */
dcl     info_size		 fixed bin (21);		/* arg copy */
dcl     initial_cpu		 fixed bin (71);		/* for metering */
dcl     initial_pagefaults	 fixed bin;		/* for metering */
dcl     link_info_valid_sw	 bit (1) aligned;		/* indicates that link info may be put into log */
dcl     local_bin_data_area	 (26) bit (36) aligned;
						/* small area to build extended binary data */
dcl     1 local_audit_header	 aligned like audit_record_header_proxy;
						/* binary data header */
dcl     locked_dir		 bit (1) aligned;		/* flag indicating that we've locked the directory */
dcl     meter_index		 fixed bin;		/* indicates metering bucket to use */
dcl     n_args		 fixed bin;		/* number of arguments passed to us */
dcl     obj_class		 bit (72) aligned;		/* arg copy */
dcl     obj_class_range	 (2) bit (72) aligned;	/* arg copy */
dcl     object_info_valid_sw	 bit (1) aligned;		/* indicates that ssobj can be put in log */
dcl     obj_path		 char (168);		/* arg copy */
dcl     obj_name		 char (168) defined (obj_path);
						/* arg copy, path and name are mutually exclusive */
dcl     obj_ptr		 pointer;			/* arg copy */
dcl     1 oper_code		 aligned like encoded_access_op;
						/* arg copy */
dcl     1 process_audit_flags	 aligned like audit_flags;	/* audit flags of process being audited */
dcl     process_auth	 bit (72) aligned;		/* auth of process being audited */
dcl     msg_text_buff	 char (512) aligned;	/* ioa_$rsnpnnl assembles the text message here */
						/* 512 chars is all syserr will use... */
dcl     msg_text_len	 fixed bin (21);		/* length of text */
dcl     msg_text_ptr	 pointer;			/* ptr to msg_text_buff */
dcl     user_entry_sw	 bit (1) aligned;		/* flag indicating proxy user info available */
dcl     1 user_info		 aligned like audit_user_info;/* arg copy */


/*	BASED		*/

dcl     caller_text		 char (caller_text_len) based (caller_text_ptr);
						/* caller's text arg or caller_text_buff */
dcl     msg_text		 char (msg_text_len) based (msg_text_ptr);
						/* the part of msg_text_buff that ioa_$rsnpnnl set up */


/*	MISCELLANEOUS	*/

dcl     addr		 builtin;
dcl     hbound		 builtin;
dcl     index		 builtin;
dcl     lbound		 builtin;
dcl     length		 builtin;
dcl     max		 builtin;
dcl     null		 builtin;
dcl     pointer		 builtin;
dcl     rel		 builtin;
dcl     rtrim		 builtin;
dcl     segno		 builtin;
dcl     size		 builtin;
dcl     string		 builtin;
dcl     substr		 builtin;
dcl     unspec		 builtin;


/*	EXTERNAL		*/

dcl     (
        access_operations_$mseg_delete,
        access_operations_$mseg_open,
        access_operations_$mseg_close,
        access_operations_$mseg_attr_read,
        access_operations_$mseg_attr_mod,
        access_operations_$mseg_access_read,
        access_operations_$mseg_access_mod,
        access_operations_$mseg_accept_wakeups
        )			 bit (36) aligned ext static;

dcl     active_all_rings_data$hcscnt
			 fixed bin external;

/* Note - The next four externals hold the access audit metering data. */
/*	active_hardcore_data$access_audit_num_meters" is set to the dimension. */
/*        This value is (n_audit_objects*6) + n_audit_events + 1. */
/*	This dimension should be increased as audit objects/events are added. */
dcl     active_hardcore_data$access_audit_num_meters
			 fixed bin external;
dcl     active_hardcore_data$access_audit_count
			 (1) fixed bin (35) external;
dcl     active_hardcore_data$access_audit_check_count
			 (1) fixed bin (35) external;
dcl     active_hardcore_data$access_audit_cpu_time
			 (1) fixed bin (71) external;
dcl     active_hardcore_data$access_audit_pagefaults
			 (1) fixed bin (35) external;

dcl     error_table_$invalidsegno
			 fixed bin (35) external;
dcl     error_table_$mylock	 fixed bin (35) external;
dcl     error_table_$no_dir	 fixed bin (35) external;
dcl     error_table_$noentry	 fixed bin (35) external;
dcl     error_table_$root	 fixed bin (35) external;
dcl     pds$access_authorization
			 bit (72) aligned external;
dcl     pds$audit_flags	 bit (36) aligned external;
dcl     pds$max_access_authorization
			 bit (72) aligned external;
dcl     pds$process_group_id	 char (32) aligned external;
dcl     pds$process_id	 bit (36) aligned external;
dcl     sys_info$access_class_ceiling
			 bit (72) aligned external;
dcl     sys_info$access_class_floor
			 bit (72) aligned external;
dcl     sys_info$audit_covert_channel
			 bit (1) aligned external;
dcl     sys_info$covert_channel_threshold
			 bit (72) aligned external;
dcl     sys_info$audit_successful_access
			 bit (1) aligned external;
dcl     sys_info$successful_access_threshold
			 bit (72) aligned external;
dcl     sys_info$audit_unsuccessful_access
			 bit (1) aligned external;
dcl     sys_info$unsuccessful_access_threshold
			 bit (72) aligned external;


/*	ENTRIES		*/

dcl     access_mode$raw	 entry (pointer, bit (36) aligned, bit (36) aligned, fixed bin (35));
dcl     arg_count_		 entry (fixed bin);
dcl     arg_list_ptr_	 entry (pointer);
dcl     dc_find$finished	 entry (pointer, bit (1) aligned);
dcl     dc_find$obj_for_audit	 entry (char (168), char (32), pointer, fixed bin (35));
dcl     display_access_class_	 entry (bit (72) aligned) returns (char (32) aligned);
dcl     display_access_class_$range
			 entry ((2) bit (72) aligned) returns (char (32) aligned);
dcl     convert_access_operation_
			 entry (bit (36) aligned) returns (char (50));
dcl     convert_status_code_	 entry (fixed bin (35), char (8) aligned, char (100) aligned);
dcl     cu_$arg_ptr_rel	 entry (fixed bin, ptr, fixed bin (21), fixed bin (35), ptr);
dcl     get_pathname_	 entry (fixed bin (17), char (*) varying, fixed bin (35));
dcl     formline_		 entry (fixed bin, fixed bin, pointer, fixed bin (21), fixed bin, pointer);
dcl     ioa_$rsnpnnl	 entry options (variable);
dcl     level$get		 entry () returns (fixed bin);
dcl     lock$dir_unlock	 entry (pointer);
dcl     sum$getbranch_root_my	 entry (pointer, bit (36) aligned, pointer, fixed bin (35));
dcl     syserr		 entry options (variable);
dcl     syserr$multiple_binary entry options (variable);
dcl     uid_path_util$get	 entry (ptr, dim (0:15) bit (36) aligned, fixed bin (35));
dcl     usage_values	 entry (fixed bin, fixed bin (71));
%page;
/* format: off */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* LOG_GENERAL, LOG_GENERAL_USER - Entries.					*/
	/*									*/
	/* These entries set up an audit message for an event associated with no object in	*/
	/* particular (e.g. privilege setting, wakeup sending, etc).  The "user" entry is used	*/
	/* for proxy users.								*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* format: on */

log_general:
     entry (a_caller, a_caller_level, a_event_flags, a_oper_code, a_obj_name, a_err_code, a_info_ptr, a_info_size
	) options (variable);

	call meter_start;
	call arg_list_ptr_ (arg_list_ptr);
	call arg_count_ (n_args);
	call setup_log_entry (Log_General, 8);		/* copy args, etc */

	obj_name = a_obj_name;
	obj_class = sys_info$access_class_ceiling;	/* fake out check_flags... */

	if check_flags_and_thresholds ()
	then call log_audit_message;

	call meter_stop;
	return;



log_general_user:
     entry (a_caller, a_caller_level, a_event_flags, a_oper_code, a_obj_name, a_err_code, a_info_ptr, a_info_size,
	a_user_info_ptr) options (variable);

	call meter_start;
	call arg_list_ptr_ (arg_list_ptr);
	call arg_count_ (n_args);
	call setup_log_entry (Log_General_User, 9);	/* copy args, etc */

	obj_name = a_obj_name;
	obj_class = sys_info$access_class_ceiling;	/* fake out check_flags... */

	if check_flags_and_thresholds ()
	then call log_audit_message;

	call meter_stop;
	return;
%page;
/* format: off */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* LOG_OBJ_CLASS, LOG_OBJ_CLASS_USER  - Entries.					*/
	/*									*/
	/* These entries set up the audit log message for an event associated with an arbitrary	*/
	/* object.  The "user" entry is called for proxy users.				*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* format: on */

log_obj_class:
     entry (a_caller, a_caller_level, a_event_flags, a_oper_code, a_obj_class, a_obj_name, a_err_code, a_info_ptr,
	a_info_size) options (variable);

	call meter_start;
	call arg_list_ptr_ (arg_list_ptr);
	call arg_count_ (n_args);
	call setup_log_entry (Log_Obj_Class, 9);	/* copy args, etc */

	obj_name = a_obj_name;
	obj_class = a_obj_class;

	if check_flags_and_thresholds ()
	then call log_audit_message;

	call meter_stop;
	return;



log_obj_class_user:
     entry (a_caller, a_caller_level, a_event_flags, a_oper_code, a_obj_class, a_obj_name, a_err_code, a_info_ptr,
	a_info_size, a_user_info_ptr) options (variable);

	call meter_start;
	call arg_list_ptr_ (arg_list_ptr);
	call arg_count_ (n_args);
	call setup_log_entry (Log_Obj_Class_User, 10);	/* copy args, etc */

	obj_name = a_obj_name;
	obj_class = a_obj_class;

	if check_flags_and_thresholds ()
	then call log_audit_message;

	call meter_stop;
	return;
%page;
/* format: off */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* LOG_OBJ_CLASS_RANGE, LOG_OBJ_CLASS_RANGE_USER  - Entries.			*/
	/*									*/
	/* This entry sets up the audit log message for an event associated with an arbitrary	*/
	/* object.  The object's access class is a range.  The "user" entry is called for proxy	*/
	/* users.									*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* format: on */

log_obj_class_range:
     entry (a_caller, a_caller_level, a_event_flags, a_oper_code, a_obj_class_range, a_obj_name, a_err_code,
	a_info_ptr, a_info_size) options (variable);

	call meter_start;
	call arg_list_ptr_ (arg_list_ptr);
	call arg_count_ (n_args);
	call setup_log_entry (Log_Obj_Class_Range, 9);	/* copy args, etc */

	obj_name = a_obj_name;
	obj_class_range = a_obj_class_range;
	obj_class = obj_class_range (2);

	if check_flags_and_thresholds ()
	then call log_audit_message;

	call meter_stop;
	return;



log_obj_class_range_user:
     entry (a_caller, a_caller_level, a_event_flags, a_oper_code, a_obj_class_range, a_obj_name, a_err_code,
	a_info_ptr, a_info_size, a_user_info_ptr) options (variable);

	call meter_start;
	call arg_list_ptr_ (arg_list_ptr);
	call arg_count_ (n_args);
	call setup_log_entry (Log_Obj_Class_Range_User, 10);
						/* copy args, etc */

	obj_name = a_obj_name;
	obj_class_range = a_obj_class_range;
	obj_class = obj_class_range (2);

	if check_flags_and_thresholds ()
	then call log_audit_message;

	call meter_stop;
	return;
%page;
/* format: off */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* LOG_OBJ_PATH, LOG_OBJ_PATH_USER - Entries.					*/
	/*									*/
	/* These entries log an event involving a storage system object.  The caller supplies a	*/
	/* pathname to that object.  This routine extracts the necessary information from the	*/
	/* directory entry of that object.  The "user" entry is called for proxy users.		*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* format: on */

log_obj_path:
     entry (a_caller, a_caller_level, a_event_flags, a_oper_code, a_obj_path, a_err_code, a_info_ptr, a_info_size
	) options (variable);

	call meter_start;
	call arg_list_ptr_ (arg_list_ptr);
	call arg_count_ (n_args);
	call setup_log_entry (Log_Obj_Path, 8);		/* copy args, etc */

	obj_path = a_obj_path;
	have_obj_path_sw = True;

	call get_entry_ptr_and_class;

	if check_flags_and_thresholds ()
	then call log_audit_message;
	else call unlock_dir;

	call meter_stop;
	return;



log_obj_path_user:
     entry (a_caller, a_caller_level, a_event_flags, a_oper_code, a_obj_path, a_err_code, a_info_ptr, a_info_size,
	a_user_info_ptr) options (variable);

	call meter_start;
	call arg_list_ptr_ (arg_list_ptr);
	call arg_count_ (n_args);
	call setup_log_entry (Log_Obj_Path_User, 9);	/* copy args, etc */

	obj_path = a_obj_path;
	have_obj_path_sw = True;

	call get_entry_ptr_and_class;

	if check_flags_and_thresholds ()
	then call log_audit_message;
	else call unlock_dir;

	call meter_stop;
	return;
%page;
/* format: off */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* LOG_OBJ_PTR, LOG_OBJ_PTR_USER - Entries.					*/
	/*									*/
	/* These entries log an event involving a storage system object.  The caller supplies a	*/
	/* pointer to that object.  This routine extracts the necessary information from the	*/
	/* directory entry of that object.  The "user" entry is called for proxy users.		*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* format: on */

log_obj_ptr:
     entry (a_caller, a_caller_level, a_event_flags, a_oper_code, a_obj_ptr, a_err_code, a_info_ptr, a_info_size
	) options (variable);

	call meter_start;
	call arg_list_ptr_ (arg_list_ptr);
	call arg_count_ (n_args);
	call setup_log_entry (Log_Obj_Ptr, 8);		/* copy args, etc */

	obj_ptr = a_obj_ptr;

	call get_entry_ptr_and_class;

	if check_flags_and_thresholds ()
	then call log_audit_message;
	else call unlock_dir;

	call meter_stop;
	return;



log_obj_ptr_user:
     entry (a_caller, a_caller_level, a_event_flags, a_oper_code, a_obj_ptr, a_err_code, a_info_ptr, a_info_size,
	a_user_info_ptr) options (variable);

	call meter_start;
	call arg_list_ptr_ (arg_list_ptr);
	call arg_count_ (n_args);
	call setup_log_entry (Log_Obj_Ptr_User, 9);	/* copy args, etc */

	obj_ptr = a_obj_ptr;

	call get_entry_ptr_and_class;

	if check_flags_and_thresholds ()
	then call log_audit_message;
	else call unlock_dir;

	call meter_stop;
	return;
%page;
/* format: off */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* LOG_ENTRY_PTR, LOG_ENTRY_PTR_USER - Entries.					*/
	/*									*/
	/* This entry logs an event involving a storage system object.  The caller supplies a	*/
	/* pointer to the directory entry of that object.  This routine extracts the necessary	*/
	/* information from the directory entry of that object.  The "user" entry is called for	*/
	/* proxy users.								*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* format: on */

log_entry_ptr:
     entry (a_caller, a_caller_level, a_event_flags, a_oper_code, a_entry_ptr, a_err_code, a_info_ptr, a_info_size
	) options (variable);

	call meter_start;
	call arg_list_ptr_ (arg_list_ptr);
	call arg_count_ (n_args);
	call setup_log_entry (Log_Entry_Ptr, 8);	/* copy args, etc */

	entry_ptr = a_entry_ptr;
	have_entry_sw = True;

	call get_entry_ptr_and_class;

	call log_audit_message;			/* the caller must run check itself */

	call meter_stop;
	return;



log_entry_ptr_user:
     entry (a_caller, a_caller_level, a_event_flags, a_oper_code, a_entry_ptr, a_err_code, a_info_ptr, a_info_size,
	a_user_info_ptr) options (variable);

	call meter_start;
	call arg_list_ptr_ (arg_list_ptr);
	call arg_count_ (n_args);
	call setup_log_entry (Log_Entry_Ptr_User, 9);	/* copy args, etc */

	entry_ptr = a_entry_ptr;
	have_entry_sw = True;

	call get_entry_ptr_and_class;

	call log_audit_message;			/* the caller must call check itself */

	call meter_stop;
	return;
%page;
/* format: off */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* LOG_NO_PROCESS - Entrypoint.						*/
	/*									*/
	/* This entry is used for logging events where there is no process involved (e.g.	*/
	/* preaccess).  Since there is no process, there can be no check on the audit flags.	*/
	/* Thus, it is assumed the event must be audited.					*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* format: on */

log_no_process:
     entry (a_caller, a_caller_level, a_event_flags, a_oper_code, a_obj_name, a_err_code, a_info_ptr, a_info_size,
	a_group_id) options (variable);

	call meter_start;
	call arg_list_ptr_ (arg_list_ptr);
	call arg_count_ (n_args);
	call setup_log_entry (Log_No_Process, 9);	/* copy args, etc */

	obj_name = a_obj_name;
	group_id = a_group_id;

	call log_audit_message;

	call meter_stop;
	return;
%page;
/* format: off */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* CHECK_GENERAL, CHECK_GENERAL_USER - Entries.					*/
	/*									*/
	/* These entries perform just the audit flag/threshold check for general auditing cases	*/
	/* where there is no associated object.  The "user" entry is called for proxy users.	*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* format: on */

check_general:
     entry (a_event_flags, a_oper_code)
	returns (bit (1) aligned);

	call meter_start;
	check_sw = True;
	user_entry_sw = False;
	have_entry_sw = False;

	unspec (event_flags) = a_event_flags;
	unspec (oper_code) = a_oper_code;
	obj_class = sys_info$access_class_ceiling;	/* make sure thresholds don't bother us */
	process_auth = pds$access_authorization;
	unspec (process_audit_flags) = pds$audit_flags;

	check_result = check_flags_and_thresholds ();

	call set_meter_index;
	call meter_stop;

	return (check_result);



check_general_user:
     entry (a_event_flags, a_oper_code, a_user_auth, a_user_audit_flags)
	returns (bit (1) aligned);

	call meter_start;
	check_sw = True;
	user_entry_sw = True;
	have_entry_sw = False;

	unspec (event_flags) = a_event_flags;
	unspec (oper_code) = a_oper_code;
	obj_class = sys_info$access_class_ceiling;
	process_auth = a_user_auth;
	unspec (process_audit_flags) = a_user_audit_flags;

	check_result = check_flags_and_thresholds ();

	call set_meter_index;
	call meter_stop;

	return (check_result);
%page;
/* format: off */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* CHECK_OBJ_CLASS_RANGE, CHECK_OBJ_CLASS_RANGE_USER - Entries.			*/
	/*									*/
	/* These entries just check the audit flags/thresholds in respect to the specified	*/
	/* event in cases where the associated object class is expressed as a range (not a	*/
	/* storage system entity).  The "user" entry is called for proxy users.		*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* format: on */

check_obj_class_range:
     entry (a_event_flags, a_oper_code, a_obj_class_range)
	returns (bit (1) aligned);

	call meter_start;
	check_sw = True;
	user_entry_sw = False;
	have_entry_sw = False;

	unspec (event_flags) = a_event_flags;
	unspec (oper_code) = a_oper_code;
	obj_class = a_obj_class_range (2);		/* assume higher end for auditing purposes */
	process_auth = pds$access_authorization;
	unspec (process_audit_flags) = pds$audit_flags;

	check_result = check_flags_and_thresholds ();

	call set_meter_index;
	call meter_stop;

	return (check_result);


check_obj_class_range_user:
     entry (a_event_flags, a_oper_code, a_obj_class_range, a_user_auth, a_user_audit_flags)
	returns (bit (1) aligned);

	call meter_start;
	check_sw = True;
	user_entry_sw = True;
	have_entry_sw = False;

	unspec (event_flags) = a_event_flags;
	unspec (oper_code) = a_oper_code;
	obj_class = a_obj_class_range (2);		/* assume higher end for auditing purposes */
	process_auth = a_user_auth;
	unspec (process_audit_flags) = a_user_audit_flags;

	check_result = check_flags_and_thresholds ();

	call set_meter_index;
	call meter_stop;

	return (check_result);
%page;
/* format: off */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* CHECK_OBJ_CLASS, CHECK_OBJ_CLASS_USER - Entries.				*/
	/*									*/
	/* These entries just check the audit flags/thresholds in respect to an event where	*/
	/* there is an arbitrary object involved.  The object may be a storage system object.	*/
	/* The "user" entry is called for proxy users.					*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* format: on */

check_obj_class:
     entry (a_event_flags, a_oper_code, a_obj_class)
	returns (bit (1) aligned);

	call meter_start;
	check_sw = True;
	user_entry_sw = False;
	have_entry_sw = False;

	unspec (event_flags) = a_event_flags;
	unspec (oper_code) = a_oper_code;
	obj_class = a_obj_class;
	process_auth = pds$access_authorization;
	unspec (process_audit_flags) = pds$audit_flags;

	check_result = check_flags_and_thresholds ();

	call set_meter_index;
	call meter_stop;

	return (check_result);



check_obj_class_user:
     entry (a_event_flags, a_oper_code, a_obj_class, a_user_auth, a_user_audit_flags)
	returns (bit (1) aligned);

	call meter_start;
	check_sw = True;
	user_entry_sw = True;
	have_entry_sw = False;

	unspec (event_flags) = a_event_flags;
	unspec (oper_code) = a_oper_code;
	obj_class = a_obj_class;
	process_auth = a_user_auth;
	unspec (process_audit_flags) = a_user_audit_flags;

	check_result = check_flags_and_thresholds ();

	call set_meter_index;
	call meter_stop;

	return (check_result);
%page;
/* format: off */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* CHECK_OBJ_PATH, CHECK_OBJ_PATH_USER - Entries.					*/
	/*									*/
	/* These entries just check the audit flags/thresholds in respect to an event associated	*/
	/* with a storage system object.  The "user" entry is called for proxy users.		*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* format: on */

check_obj_path:
     entry (a_event_flags, a_oper_code, a_obj_path)
	returns (bit (1) aligned);

	call meter_start;
	check_sw = True;
	user_entry_sw = False;

	unspec (event_flags) = a_event_flags;
	unspec (oper_code) = a_oper_code;
	obj_path = a_obj_path;
	have_obj_path_sw = True;
	obj_ptr = null;
	entry_ptr = null;
	have_entry_sw = False;
	call get_entry_ptr_and_class;
	call unlock_dir;
	process_auth = pds$access_authorization;
	unspec (process_audit_flags) = pds$audit_flags;

	check_result = check_flags_and_thresholds ();

	call set_meter_index;
	call meter_stop;

	return (check_result);

check_obj_path_user:
     entry (a_event_flags, a_oper_code, a_obj_path, a_user_auth, a_user_audit_flags)
	returns (bit (1) aligned);

	call meter_start;
	check_sw = True;
	user_entry_sw = True;

	unspec (event_flags) = a_event_flags;
	unspec (oper_code) = a_oper_code;
	obj_path = a_obj_path;
	have_obj_path_sw = True;
	obj_ptr = null;
	entry_ptr = null;
	have_entry_sw = False;
	call get_entry_ptr_and_class;
	call unlock_dir;
	process_auth = a_user_auth;
	unspec (process_audit_flags) = a_user_audit_flags;

	check_result = check_flags_and_thresholds ();

	call set_meter_index;
	call meter_stop;

	return (check_result);
%page;
/* format: off */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* CHECK_OBJ_PTR, CHECK_OBJ_PTR_USER - Entries.					*/
	/*									*/
	/* These entries just check the audit flags/thresholds in respect to an event associated	*/
	/* with a storage system object.  The "user" entry is called for proxy users.		*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* format: on */

check_obj_ptr:
     entry (a_event_flags, a_oper_code, a_obj_ptr)
	returns (bit (1) aligned);

	call meter_start;
	check_sw = True;
	user_entry_sw = False;

	unspec (event_flags) = a_event_flags;
	unspec (oper_code) = a_oper_code;
	have_obj_path_sw = False;
	obj_ptr = a_obj_ptr;
	entry_ptr = null;
	have_entry_sw = False;
	call get_entry_ptr_and_class;
	call unlock_dir;
	process_auth = pds$access_authorization;
	unspec (process_audit_flags) = pds$audit_flags;

	check_result = check_flags_and_thresholds ();

	call set_meter_index;
	call meter_stop;

	return (check_result);

check_obj_ptr_user:
     entry (a_event_flags, a_oper_code, a_obj_ptr, a_user_auth, a_user_audit_flags)
	returns (bit (1) aligned);

	call meter_start;
	check_sw = True;
	user_entry_sw = True;

	unspec (event_flags) = a_event_flags;
	unspec (oper_code) = a_oper_code;
	have_obj_path_sw = False;
	obj_ptr = a_obj_ptr;
	entry_ptr = null;
	have_entry_sw = False;
	call get_entry_ptr_and_class;
	call unlock_dir;
	process_auth = a_user_auth;
	unspec (process_audit_flags) = a_user_audit_flags;

	check_result = check_flags_and_thresholds ();

	call set_meter_index;
	call meter_stop;

	return (check_result);
%page;
/* format: off */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* LOG_AUDIT_MESSAGE - Internal Procedure.					*/
	/*									*/
	/* This routine performs the sequence of calls required to format data for the audit log	*/
	/* entry and actually write the entry.  It is called by all access_audit_$log_*		*/
	/* entrypoints.								*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* format: on */

log_audit_message:
     procedure ();

	call build_object_info;

	call unlock_dir;				/* finished with looking at entry itself */

	if caller_supplied_text_sw
	then do;
	     call cu_$arg_ptr_rel (control_str_arg_index, caller_text_ptr, caller_text_len, code, arg_list_ptr);
	     if code ^= 0
	     then do;
		call syserr (SYSERR_PRINT_ON_CONSOLE, MSG_Text_Ptr, EntryNames (entrypoint),
		     pds$process_group_id, caller);
dcl     MSG_Text_Ptr	 char (86) int static options (constant)
			 init (
			 "access_audit_$^a: (^a) Unexpected error obtaining caller text pointer.  Caller=""^a"".");
		goto no_caller_text;
	     end;
	     else if caller_text_len = 0		/* null string? */
	     then goto no_caller_text;
	     else if caller_text = ""			/* fixed string of blanks? */
	     then goto no_caller_text;
	     else if n_args > control_str_arg_index	/* caller have optional args? */
	     then do;
		caller_text_ptr = addr (caller_text_buff);
		caller_text_len = length (caller_text_buff);
		call formline_ (control_str_arg_index, control_str_arg_index + 1,
		     caller_text_ptr, caller_text_len, 0, arg_list_ptr);
	     end;
	     else					/* leave ptr and length to caller's argument */
		;
	end;
	else do;					/* caller supplied no text */
no_caller_text:
	     caller_text_ptr = addr (caller_text_buff);	/* just so it's a valid pointer */
	     caller_text_len = 0;
	     caller_supplied_text_sw = False;
	end;

	call form_audit_message_text;

	call form_audit_record_header;

	call write_log_message;

	return;

     end log_audit_message;
%page;
/* format: off */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* BUILD_OBJECT_INFO - Internal Procedure.					*/
	/*									*/
	/* This routine is used by the access_audit_$log_* entries which deal with storage system	*/
	/* object exclusively.  Its function is to set up the binary info structure with	*/
	/* pertinent information about the segment/directory.				*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* format: on */

build_object_info:
     procedure;

	entry_type_str = "";

	if have_entry_sw
	then if entry_ptr ^= null ()
	     then if entry_ptr -> entry.bs
		then do;
		     if entry_ptr -> entry.dirsw
		     then entry_type_str = "directory";
		     else entry_type_str = "segment";

		     audit_ssobj_info_ptr = addr (local_bin_data_area);
		     if size (local_bin_data_area) < size (audit_ssobj_info)
		     then do;
			call syserr (SYSERR_PRINT_ON_CONSOLE, MSG_Alloc_SSObj);
dcl     MSG_Alloc_SSObj	 char (56) int static options (constant)
			 init ("access_audit_: Insufficient room to allocate ssobj data.");
			goto setup_path;
		     end;

/* build ssobj info structure for a seg or dir */
		     unspec (audit_ssobj_info) = ""b;
		     audit_ssobj_info.info_type = AAB_ss_object;
		     call uid_path_util$get (pointer (entry_ptr, 0), audit_ssobj_info.parent_uid_path, code);
		     if code ^= 0
		     then do;
			call syserr (SYSERR_LOG_OR_PRINT, MSG_Dir_UID, EntryNames (entrypoint),
			     pds$process_group_id, segno (entry_ptr), error_text (code), caller);
dcl     MSG_Dir_UID		 char (93) int static options (constant)
			 init (
			 "access_audit_$^a: (^a) Unable to get UID path for directory ^o due to ""^a"".  Caller=""^a""."
			 );
			audit_ssobj_info.parent_uid_path = "0"b;
						/* all invalid */
		     end;
		     audit_ssobj_info.entry_uid = entry_ptr -> entry.uid;
		     audit_ssobj_info.dtem = entry_ptr -> entry.dtem;
		     audit_ssobj_info.access_class = entry_ptr -> entry.access_class;
		     call access_mode$raw (entry_ptr, audit_ssobj_info.raw_mode, audit_ssobj_info.ex_mode, code);
		     if code ^= 0
		     then do;
			call syserr (SYSERR_LOG_OR_PRINT, MSG_Raw_Access, EntryNames (entrypoint),
			     pds$process_group_id, entry_ptr, error_text (code), caller);
dcl     MSG_Raw_Access	 char (97) int static options (constant)
			 init (
			 "access_audit_$^a: (^a) Unable to get raw access modes for entry ^p due to ""^a"".  Caller=""^a""."
			 );
			audit_ssobj_info.raw_mode = "0"b;
			audit_ssobj_info.ex_mode = "0"b;
		     end;
		     audit_ssobj_info.ring_brackets = entry_ptr -> entry.ring_brackets;
		     audit_ssobj_info.ex_ring_brackets = entry_ptr -> entry.ex_ring_brackets;
		     audit_ssobj_info.dirsw = entry_ptr -> entry.dirsw;
		     audit_ssobj_info.per_process_sw = entry_ptr -> entry.per_process_sw;
		     audit_ssobj_info.safety_sw = entry_ptr -> entry.safety_sw;
		     audit_ssobj_info.multiple_class = entry_ptr -> entry.multiple_class;
		     audit_ssobj_info.audit_flag = entry_ptr -> entry.audit_flag;
		     audit_ssobj_info.security_oosw = entry_ptr -> entry.security_oosw;
		     audit_ssobj_info.entrypt_sw = entry_ptr -> entry.entrypt_sw;
		     audit_ssobj_info.master_dir = entry_ptr -> entry.master_dir;
		     audit_ssobj_info.access_class = entry_ptr -> entry.access_class;

		     object_info_valid_sw = True;
		end;
		else do;
		     entry_type_str = "link";

		     audit_link_info_ptr = addr (local_bin_data_area);
		     if size (local_bin_data_area) < size (audit_link_info)
		     then do;
			call syserr (SYSERR_PRINT_ON_CONSOLE, MSG_Alloc_Link);
dcl     MSG_Alloc_Link	 char (55) int static options (constant)
			 init ("access_audit_: Insufficient room to allocate link data.");
			goto setup_path;
		     end;

/* build link info structure */
		     unspec (audit_link_info) = ""b;
		     audit_link_info.info_type = AAB_ss_link;
		     call uid_path_util$get (pointer (entry_ptr, 0), audit_link_info.parent_uid_path, code);
		     if code ^= 0
		     then do;
			call syserr (SYSERR_LOG_OR_PRINT, MSG_Dir_UID, EntryNames (entrypoint),
			     pds$process_group_id, segno (entry_ptr), error_text (code), caller);
			audit_link_info.parent_uid_path = "0"b;
						/* all invalid */
		     end;
		     audit_link_info.entry_uid = entry_ptr -> link.uid;
		     audit_link_info.dtem = entry_ptr -> link.dtem;

		     link_info_valid_sw = True;
		end;
	     else entry_type_str = "directory";		/* root */
	else entry_type_str = "";			/* don't know what it is */

/* set up the textual pathname in char528v (used by form_audit_message_text) */
setup_path:
	if ^have_entry_sw
	then char528v = ">NOENTRY";			/* no entry */
	else if entry_ptr = null
	then char528v = ">";			/* root */
	else do;
						/* first get path of directory */
	     call get_pathname_ (segno (entry_ptr), char528v, code);
	     if code ^= 0
	     then do;
		call syserr (SYSERR_LOG_OR_PRINT, MSG_Gen_Path, EntryNames (entrypoint),
		     pds$process_group_id, entry_ptr, error_text (code), caller);
dcl     MSG_Gen_Path	 char (93) int static options (constant)
			 init (
			 "access_audit_$^a: (^a) Unable to generate path for entry at ^p due to ""^a"".  Caller=""^a""."
			 );
		char528v = ">???";
	     end;
	     else do;
						/* append entry name to path */
		if char528v = ">"			/* avoid ">>foo" */
		then char528v = char528v || rtrim (pointer (entry_ptr, entry_ptr -> entry.name_frp) -> names.name);
		else do;
		     char528v = char528v || ">";
		     char528v = char528v || rtrim (pointer (entry_ptr, entry_ptr -> entry.name_frp) -> names.name);
		end;
	     end;
	end;

	return;

     end build_object_info;
%page;
/* format: off */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* FORM_AUDIT_MESSAGE_TEXT - Internal Procedure.					*/
	/*									*/
	/* This procedure formats a text message for the audit log.  This message		*/
	/* depends upon which access_audit_$log_* entry was called.				*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* format: on */

form_audit_message_text:
     procedure ();

dcl     Default_Ctl_Str	 char (168) static options (constant) init (
			 "Audit (^a): ^[GRANTED^;DENIED^] ^a^[ (^a)^;^s^] for ^a (^a) Level=^d^[ (on behalf of ^a (^a))^;^s^s^]^[ to^[ ^a^;^s^] ^a (^a)^;^s^s^s^s^]^[ <^a>^;^s^].^[ Code=^a^]"
			 );

dcl     class_str		 char (32);
dcl     event_flags_str	 char (100) varying;
dcl     type_str		 char (10);
dcl     user_group_id	 char (32);
dcl     user_auth_str	 char (32) aligned;

	type_str = "";

	if entrypoint = Log_Obj_Path
	     | entrypoint = Log_Obj_Path_User
	     | entrypoint = Log_Entry_Ptr
	     | entrypoint = Log_Obj_Ptr
	     | entrypoint = Log_Entry_Ptr_User
	     | entrypoint = Log_Obj_Ptr_User
	then do;
						/* in this case char528v has already been set by build_object_info */
	     type_str = entry_type_str;
	     if char528v = ">NOENTRY"
	     then class_str = "cannot get entry";
	     else if char528v = ">???"
	     then class_str = "cannot get pathname";
	     else if char528v = ">"
	     then class_str = "root";
	     else class_str = display_access_class_ (obj_class);
	     if entrypoint = Log_Obj_Path
		| entrypoint = Log_Obj_Path_User
	     then char528v = obj_path;		/* use textual path caller supplied */
	end;
	else
	     if entrypoint = Log_Obj_Class
	     | entrypoint = Log_Obj_Class_User
	then do;
	     char528v = obj_name;
	     class_str = display_access_class_ (obj_class);
	end;
	else
	     if entrypoint = Log_Obj_Class_Range
	     | entrypoint = Log_Obj_Class_Range_User
	then do;
	     char528v = obj_name;
	     class_str = display_access_class_$range (obj_class_range);
	end;
	else
	     if entrypoint = Log_General
	     | entrypoint = Log_General_User
	then do;
	     char528v = obj_name;
	     class_str = "no access class";
	end;
	else
	     if entrypoint = Log_No_Process
	then do;
	     char528v = obj_name;
	     class_str = "no access class";
	end;
						/* if entrypoint invalid */
	else do;
	     call syserr (SYSERR_PRINT_ON_CONSOLE, MSG_Illegal_Entry, pds$process_group_id, entrypoint, caller);
dcl     MSG_Illegal_Entry	 char (112) int static options (constant)
			 init (
			 "access_audit_$UNKNOWN: (^a) Illegal entrypoint index ""^d"" detected in form_audit_message_text.  Caller=""^a""."
			 );
	     char528v = "UNKNOWN";
	     class_str = "error in access_audit_";
	end;

	if user_entry_sw
	then do;
	     user_group_id = audit_user_info.user_id;
	     user_auth_str = display_access_class_ (audit_user_info.authorization);
	end;
	else do;
	     user_group_id = "";
	     user_auth_str = "";
	end;

	event_flags_str = "";			/* construct string of event flags */
	do i = 1, 3 to hbound (Short_Event_Names, 1);	/* all flags except "granted" */
	     if substr (string (event_flags), i, 1) = "1"b
	     then do;
		if event_flags_str ^= ""
		then event_flags_str = event_flags_str || ", ";
		event_flags_str = event_flags_str || rtrim (Short_Event_Names (i));
	     end;
	end;

	msg_text_ptr = addr (msg_text_buff);		/* set up based msg_text */
	msg_text_len = length (msg_text_buff);		/* ioa_ will change the length */

	call ioa_$rsnpnnl (Default_Ctl_Str, msg_text_buff, msg_text_len,
	     caller, event_flags.grant, convert_access_operation_ (unspec (oper_code)),
	     (event_flags_str ^= ""), event_flags_str,
	     pds$process_group_id, display_access_class_ (pds$access_authorization), caller_level,
	     user_entry_sw, user_group_id, user_auth_str,
	     (char528v ^= ""), (type_str ^= ""), type_str, char528v, class_str, caller_supplied_text_sw, caller_text,
	     (err_code ^= 0), error_text (err_code));

	return;

     end form_audit_message_text;
%page;
/* format: off */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* FORM_AUDIT_RECORD_HEADER - Internal Procedure.					*/
	/*									*/
	/* This routine assembles the standard record header for the audit message.		*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* format: on */

form_audit_record_header:
     procedure;

/* local_audit_header is the size of audit_record_header_proxy
   which will be sufficient to use as audit_record_header as well */

	unspec (local_audit_header) = ""b;
	audit_record_ptr = addr (local_audit_header);

	if user_entry_sw
	then audit_record_header_proxy.type = ARH_TYPE_PROXY;
	else audit_record_header_proxy.type = ARH_TYPE_NO_PROXY;

	audit_record_header_proxy.version = ACCESS_AUDIT_HEADER_VERSION_3;

	if user_entry_sw
	then do;
						/* copy the proxy user's info */
	     call parse_group_id (audit_user_info.user_id,
		audit_record_header_proxy.person (2), audit_record_header_proxy.project (2),
		audit_record_header_proxy.tag (2));
	     audit_record_header_proxy.ring (2) = audit_user_info.ring;
	     audit_record_header_proxy.anonymous (2) = (substr (audit_user_info.user_id, 1, 9) = "anonymous");
	     audit_record_header_proxy.process_id (2) = audit_user_info.process_id;
	     audit_record_header_proxy.authorization (2) = audit_user_info.authorization;
	     audit_record_header_proxy.subjects (2).authorization_range (*) = audit_user_info.authorization_range (*);
	end;

	if entrypoint = Log_No_Process
	then do;
	     audit_record_header_proxy.subject_is_process = False;
	     call parse_group_id (group_id,
		audit_record_header_proxy.person (1), audit_record_header_proxy.project (1),
		audit_record_header_proxy.tag (1));
	end;
	else do;
	     audit_record_header_proxy.subject_is_process = True;
	     call parse_group_id (pds$process_group_id,
		audit_record_header_proxy.person (1), audit_record_header_proxy.project (1),
		audit_record_header_proxy.tag (1));
	     audit_record_header_proxy.ring (1) = caller_level;
	     audit_record_header_proxy.anonymous (1) = (substr (pds$process_group_id, 1, 9) = "anonymous");
	     audit_record_header_proxy.process_id (1) = pds$process_id;
	     audit_record_header_proxy.authorization (1) = pds$access_authorization;
	     audit_record_header_proxy.subjects (1).authorization_range (1) = sys_info$access_class_floor;
						/* don't know this in hardcore */
	     audit_record_header_proxy.subjects (1).authorization_range (2) = pds$max_access_authorization;
	end;

	audit_record_header_proxy.operation_code = unspec (oper_code);
	audit_record_header_proxy.event_flags = unspec (event_flags);

	return;

parse_group_id:					/* procedure internal to form_audit_record_header */
     procedure (group_id, person, project, tag);

dcl     group_id		 parameter char (32) aligned;
dcl     person		 parameter char (22);
dcl     project		 parameter char (9);
dcl     tag		 parameter char (1);
dcl     l_group_id		 char (32);

	l_group_id = group_id;
	person, project, tag = "";

	i = index (l_group_id, ".");
	if i = 0
	then do;
	     person = substr (l_group_id, 1, length (person));
	     return;
	end;
	else if i > 1
	then person = substr (l_group_id, 1, i - 1);

	l_group_id = substr (l_group_id, i + 1);

	i = index (l_group_id, ".");
	if i = 0
	then do;
	     project = substr (l_group_id, 1, length (project));
	     return;
	end;
	else if i > 1
	then project = substr (l_group_id, 1, i - 1);

	tag = substr (l_group_id, i + 1);

	return;

     end parse_group_id;

     end form_audit_record_header;
%page;
/* format: off */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* WRITE_LOG_MESSAGE - Internal Procedure.					*/
	/*									*/
	/* This procedure interfaces with the logging software to add an audit message to the	*/
	/* logs.									*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* format: on */

write_log_message:
     procedure;

dcl     1 bin_info_array	 (3 /* max */) aligned,	/* argument for syserr$multiple_binary */
	2 p		 pointer,
	2 len		 fixed bin;
dcl     n_pieces		 fixed bin;
dcl     syserr_code		 fixed bin;

/* first piece is the header */
	n_pieces = 1;
	p (n_pieces) = addr (audit_record_header);
	if user_entry_sw
	then len (n_pieces) = size (audit_record_header_proxy);
	else len (n_pieces) = size (audit_record_header);

/* next piece is the ssobj or link info, if available */
	if object_info_valid_sw
	then do;
	     n_pieces = n_pieces + 1;
	     p (n_pieces) = addr (audit_ssobj_info);
	     len (n_pieces) = size (audit_ssobj_info);
	end;
	else if link_info_valid_sw
	then do;
	     n_pieces = n_pieces + 1;
	     p (n_pieces) = addr (audit_link_info);
	     len (n_pieces) = size (audit_link_info);
	end;

/* last piece is what the caller supplied, if available */
	if info_ptr ^= null ()
	then do;
	     n_pieces = n_pieces + 1;
	     p (n_pieces) = info_ptr;
	     len (n_pieces) = info_size;
	end;

	syserr_code = SYSERR_LOG_OR_PRINT;
	if event_flags.cc_1_10 | event_flags.cc_10_100
	then syserr_code = syserr_code + SYSERR_COVERT_CHANNEL;
	else if event_flags.grant
	then syserr_code = syserr_code + SYSERR_SUCCESSFUL_ACCESS;
	else syserr_code = syserr_code + SYSERR_UNSUCCESSFUL_ACCESS;

	call syserr$multiple_binary (syserr_code, addr (bin_info_array), n_pieces, SB_access_audit, msg_text);

	return;

     end write_log_message;
%page;
/* format: off */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* CHECK_FLAGS_AND_THRESHOLDS - Internal Procedure.				*/
	/*									*/
	/* This routine does the actual checking to determine if auditing is necessary.		*/
	/*									*/
	/* The following variables must be set before invocation of this routine:		*/
	/*									*/
	/*		obj_class							*/
	/*		process_auth						*/
	/*		process_audit_flags						*/
	/*		event_flags						*/
	/*		oper_code							*/
	/*		have_entry_sw						*/
	/*		user_entry_sw						*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* format: on */

check_flags_and_thresholds:
     procedure () returns (bit (1) aligned);

dcl     object_index	 fixed bin;
dcl     oper_level		 fixed bin;

/* check to see if object's audit flag is on */

	if have_entry_sw
	then if entry_ptr ^= null ()
	     then if entry_ptr -> entry.bs &
		     entry_ptr -> entry.audit_flag
		then do;
		     if (^entry_ptr -> entry.dirsw &	/* ring-1 object ? */
			unspec (entry_ptr -> entry.ring_brackets (*)) = "111"b3)
		     then do;
			if unspec (oper_code) = access_operations_$mseg_delete |
			     unspec (oper_code) = access_operations_$mseg_open |
			     unspec (oper_code) = access_operations_$mseg_close |
			     unspec (oper_code) = access_operations_$mseg_attr_read |
			     unspec (oper_code) = access_operations_$mseg_attr_mod |
			     unspec (oper_code) = access_operations_$mseg_access_read |
			     unspec (oper_code) = access_operations_$mseg_access_mod |
			     unspec (oper_code) = access_operations_$mseg_accept_wakeups
			then return (True);
			else ;
		     end;
		     else return (True);
		end;

	if event_flags.special_op			/* presently we always log special events */
	then return (True);
	else do;
						/* first check if a covert channel event */

	     if event_flags.cc_1_10 | event_flags.cc_10_100
	     then if sys_info$audit_covert_channel
		then if within_threshold (process_auth, (sys_info$covert_channel_threshold)) | event_flags.receiver
		     then if (event_flags.cc_1_10 & process_audit_flags.cc_1_10)
			     | (event_flags.cc_10_100 & process_audit_flags.cc_10_100)
			then return (True);

/* next, check for admin or privileged operation */

	     if event_flags.admin_op & process_audit_flags.admin_ops
	     then return (True);
	     else ;

	     if event_flags.priv_op & process_audit_flags.priv_ops
	     then return (True);
	     else ;


/* now for the real successful/unsuccessful access type checks */

/* check system wide audit flags */

	     if event_flags.grant
	     then if ^sys_info$audit_successful_access
		then return (False);
		else ;
	     else if ^sys_info$audit_unsuccessful_access
	     then return (False);
	     else ;

/* check thresholds */

	     if event_flags.grant
	     then if ^within_threshold (obj_class, (sys_info$successful_access_threshold))
		then return (False);		/* below threshold */
		else ;
	     else if ^within_threshold (obj_class, (sys_info$unsuccessful_access_threshold))
	     then return (False);
	     else ;

/* finally check the user's audit flags */

	     object_index = oper_code.audit_type.object_type;
	     if object_index < lbound (process_audit_flags.objects, 1)
		| object_index > hbound (process_audit_flags.objects, 1)
	     then do;
						/* some events may legally be associated with no type of object */
		if (event_flags.cc_1_10 | event_flags.cc_10_100 | event_flags.priv_op | event_flags.admin_op)
		then return (False);
		else do;
		     call syserr (SYSERR_PRINT_ON_CONSOLE, MSG_Parm_Combo, EntryNames (entrypoint),
			pds$process_group_id, unspec (oper_code), string (event_flags), ^check_sw, caller);
dcl     MSG_Parm_Combo	 char (118) int static options (constant)
			 init (
			 "access_audit_$^a: (^a) Encountered illegal parameter combination.  OperCode=^w  EventFlags=^w.^[  Caller=""^a"".^;^s^]"
			 );
		     return (True);			/* audit for usefulness in debugging */
		end;
	     end;

	     oper_level = oper_code.audit_type.access_type;
						/* all 2-bit combos OK */

	     if event_flags.grant
	     then if process_audit_flags.objects (object_index).grant_level >= oper_level
		then return (True);
		else return (False);
	     else if process_audit_flags.objects (object_index).deny_level >= oper_level
	     then return (True);
	     else return (False);

	end;


within_threshold:
     proc (test, thresh) returns (bit (1) aligned);
						/* procedure internal to check_flags and thresholds
						   used to compare a test class/auth against a given threshold */
dcl     test		 bit (72) aligned parameter;
dcl     thresh		 bit (72) aligned parameter;

	if addr (test) -> aim_template.level >= addr (thresh) -> aim_template.level
	then return (True);
	else if (addr (test) -> aim_template.categories & addr (thresh) -> aim_template.categories)
	then return (True);
	else return (False);

     end within_threshold;

     end check_flags_and_thresholds;
%page;
/* format: off */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* GET_ENTRY_PTR_AND_CLASS - Internal Procedure.					*/
	/*									*/
	/* Routine to obtain a pointer to the directory entry of a storage system object given a	*/
	/* pointer to that object and the access class of that object.  This routine will set the	*/
	/* global switch "locked_dir" if it was necessary to lock the directory.  The caller will	*/
	/* call "unlock_dir" if the switch is set and all operations are complete.  (Most callers	*/
	/* of the log_obj_ptr and log_entry_ptr entrypoints already have the directory locked).	*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* format: on */

get_entry_ptr_and_class:
     procedure ();

	called_dc_find = False;
	locked_dir = False;

	obj_class = sys_info$access_class_ceiling;	/* assume worst case */

	if rel (entry_ptr) = "0"b
	then do;
						/* assume entry_ptr arg was actually the obj_ptr */
	     obj_ptr = entry_ptr;
	     have_entry_sw = False;
	end;

	if have_entry_sw				/* caller supplied entry ptr? */
	then ;					/* we have nothing to do... */
	else if obj_ptr ^= null			/* caller supplied object ptr? */
	then do;
	     if segno (obj_ptr) <= active_all_rings_data$hcscnt
	     then obj_class = sys_info$access_class_floor;/* no entry */
	     else do;
						/* we'll make an entry pointer ourselves and maybe lock the dir */
		call sum$getbranch_root_my (pointer (obj_ptr, 0), "0"b, entry_ptr, code);
		if code = error_table_$mylock
		then code = 0;
		else if code = error_table_$root
		then code = 0;
		else if code = error_table_$noentry | code = error_table_$invalidsegno
		then ;				/* let these by... */
		else if code ^= 0
		then do;
		     call syserr (SYSERR_LOG_OR_PRINT, MSG_Entry_Ptr, EntryNames (entrypoint),
			pds$process_group_id, segno (obj_ptr), error_text (code));
dcl     MSG_Entry_Ptr	 char (76) int static options (constant)
			 init ("access_audit_$^a: (^a) Unable to get entry pointer for seg ^o due to ""^a"".");
		     return;
		end;
		else locked_dir = True;		/* we locked it, remember to unlock it later */

		have_entry_sw = (code = 0);
	     end;
	end;
	else if have_obj_path_sw			/* caller supplied object path? */
	then do;					/* get entry pointer from pathname */
	     call dc_find$obj_for_audit (obj_path, "", entry_ptr, code);
	     if code = error_table_$root		/* shouldn't get mylock */
	     then code = 0;
	     else if code = error_table_$noentry | code = error_table_$no_dir
	     then ;				/* let these by... */
	     else if code ^= 0
	     then do;
		call syserr (SYSERR_LOG_OR_PRINT, MSG_Entry_Ptr_Path, EntryNames (entrypoint),
		     pds$process_group_id, obj_path, error_text (code));
dcl     MSG_Entry_Ptr_Path	 char (80) int static options (constant)
			 init ("access_audit_$^a: (^a) Unable to get entry pointer for seg ""^a"" due to ""^a"".");
		return;
	     end;
	     else do;
		called_dc_find = True;
		locked_dir = True;
	     end;

	     have_entry_sw = (code = 0);
	end;
	else do;					/* caller supplied nothing? */
	     call syserr (SYSERR_PRINT_ON_CONSOLE, MSG_Improper_Call, EntryNames (entrypoint), pds$process_group_id,
		^check_sw, caller)
		;
dcl     MSG_Improper_Call	 char (108) int static options (constant)
			 init (
			 "access_audit_$^a: (^a) Improper calling sequence (from ""get_entry_ptr_and_class"").^[  Caller=""^a"".^;^s^]"
			 );
	end;

	if have_entry_sw
	then if entry_ptr ^= null ()
	     then if entry_ptr -> entry.bs
		then obj_class = entry_ptr -> entry.access_class;
		else obj_class = pointer (entry_ptr, "0"b) -> dir.access_class;
						/* it's a link */
	     else obj_class = sys_info$access_class_floor;/* it's the root directory */

	return;

     end get_entry_ptr_and_class;
%page;
/* format: off */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* UNLOCK_DIR - Internal Procedure.						*/
	/*									*/
	/* This routine unlocks the directory if access_audit_ locked it.			*/
	/*									*/
	/* The switches "called_dc_find" and "locked_dir" are set by get_entry_ptr_and_class.	*/
	/* However, the $log_* entries may end up calling here before get_entry_ptr_and_class	*/
	/* has been executed.  Therefore, setup_log_entry sets these both to False.		*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* format: on */

unlock_dir:
     procedure ();

	if called_dc_find
	then call dc_find$finished (pointer (entry_ptr, 0), locked_dir);
	else if locked_dir
	then call lock$dir_unlock (pointer (entry_ptr, 0));

	locked_dir = False;				/* so we don't try it again */
	called_dc_find = False;

	return;

     end unlock_dir;
%page;
/* format: off */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* ERROR_TEXT - Internal Procedure.						*/
	/*									*/
	/* Procedure to return the short error message mnemonic associated with an error_table_	*/
	/* entry.									*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* format: on */

error_text:
     procedure (ec) returns (char (100) aligned);

dcl     ec		 parameter fixed bin (35);

dcl     char8		 char (8) aligned;
dcl     char100		 char (100) aligned;

	call convert_status_code_ (ec, char8, char100);

	return (char100);

     end error_text;
%page;
/* format: off */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* METER_START - Internal Procedure.						*/
	/*									*/
	/* Initializes the meter variables.						*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* format: on */

meter_start:
     procedure;

	call usage_values (initial_pagefaults, initial_cpu);

	return;

     end meter_start;
%page;
/* format: off */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* METER_STOP - Internal Procedure.						*/
	/*									*/
	/* Compute resource usage since "meter_start" was invoked.  Add into appropriate meter	*/
	/* bucket.								*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* format: on */

meter_stop:
     procedure;

dcl     final_cpu		 fixed bin (71);
dcl     final_pagefaults	 fixed bin;

	active_hardcore_data$access_audit_count (meter_index) =
	     active_hardcore_data$access_audit_count (meter_index) + 1;

	if check_sw
	then active_hardcore_data$access_audit_check_count (meter_index) =
		active_hardcore_data$access_audit_check_count (meter_index) + 1;

	call usage_values (final_pagefaults, final_cpu);

	active_hardcore_data$access_audit_cpu_time (meter_index) =
	     active_hardcore_data$access_audit_cpu_time (meter_index) + (final_cpu - initial_cpu);
	active_hardcore_data$access_audit_pagefaults (meter_index) =
	     active_hardcore_data$access_audit_pagefaults (meter_index) + (final_pagefaults - initial_pagefaults);

	return;

     end meter_stop;
%page;
/* format: off */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
	/*									*/
	/* SETUP_LOG_ENTRY - Internal Procedure.	(Used by logging entries only)	*/
	/* SET_METER_INDEX - Internal Entry.	(Used check_* entries)			*/
	/*									*/
	/* 1. Set up global variables.						*/
	/* 2. Check that proper number of arguments have been supplied.			*/
	/* 3. Copy args.								*/
	/* 4. Set up metering bucket index.						*/
	/*									*/
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* format: on */

setup_log_entry:
     proc (a_entrypoint, a_args_needed);

dcl     a_entrypoint	 fixed bin parameter;
dcl     a_args_needed	 fixed bin parameter;

/* Set up global variables */

	entrypoint = a_entrypoint;			/* set global variable */
	control_str_arg_index = a_args_needed + 1;	/* tells formline_ where the control string is */
	caller_supplied_text_sw = (control_str_arg_index <= n_args);

	check_sw = False;
	object_info_valid_sw = False;
	link_info_valid_sw = False;
	have_entry_sw = False;			/* assume no ptr to object's dir entry */
	have_obj_path_sw = False;

	locked_dir = False;
	called_dc_find = False;
	obj_ptr = null ();
	entry_ptr = null ();
	obj_class = sys_info$access_class_ceiling;

/* Check number of arguments */

	if n_args < a_args_needed
	then do;
	     if n_args > 0				/* have "caller" ? */
	     then caller = a_caller;
	     else caller = "";
	     call syserr (SYSERR_PRINT_ON_CONSOLE, MSG_Insuff_Args, EntryNames (entrypoint),
		pds$process_group_id, n_args, (n_args > 0), caller);
dcl     MSG_Insuff_Args	 char (94) int static options (constant)
			 init (
			 "access_audit_$^a: (^a) Called with insufficient arguments (#args= ^d).^[  Caller=""^a"".^;^s^]"
			 );
	     goto ERROR_EXIT;
	end;

/* Copy args */

	caller = a_caller;
	caller_level = max (a_caller_level, level$get ());
	unspec (event_flags) = a_event_flags;
	unspec (oper_code) = a_oper_code;
	err_code = a_err_code;
	info_ptr = a_info_ptr;
	info_size = a_info_size;
						/* binary info structure is copied by write_log_message */

	if entrypoint = Log_General_User
	     | entrypoint = Log_Obj_Class_Range_User
	     | entrypoint = Log_Obj_Class_User
	     | entrypoint = Log_Obj_Path_User
	     | entrypoint = Log_Obj_Ptr_User
	     | entrypoint = Log_Entry_Ptr_User
	then do;
	     user_entry_sw = True;
	     audit_user_info_ptr = a_user_info_ptr;
	     user_info = audit_user_info;		/* copy the structure */
	     audit_user_info_ptr = addr (user_info);	/* now we'll ref local copy */
	end;
	else user_entry_sw = False;

/* message text string and other optional args are copied by formline_ */

/* individual entry is responsible for copying a_group_id, a_obj_name, a_obj_class,
   a_obj_class_range, a_obj_path, a_obj_ptr, or a_entry_ptr as appropriate */


/* set up input to audit flag/threshold check, "obj_class" must
   be set up by the individual entry */
	if user_entry_sw
	then do;
	     process_auth = audit_user_info.authorization;
	     unspec (process_audit_flags) = audit_user_info.audit_flags;
	end;
	else do;
	     process_auth = pds$access_authorization;
	     unspec (process_audit_flags) = pds$audit_flags;
	end;


/* Set up meter bucket index */

set_meter_index:
     entry ();

/* first check to see if we're auditing on a specific event */
	i = n_audit_objects * 2 * n_audit_access_types;
						/* if entrypoint = Log_Fault then meter_index = i + FAULTS_AUDIT_FLAG_INDEX; (see access_audit_log_fault_) */
	if event_flags.admin_op
	then meter_index = i + ADMIN_OP_AUDIT_FLAG_INDEX;
	else if event_flags.priv_op
	then meter_index = i + PRIV_OP_AUDIT_FLAG_INDEX;
	else if event_flags.cc_1_10
	then meter_index = i + CC_1_10_AUDIT_FLAG_INDEX;
	else if event_flags.cc_10_100
	then meter_index = i + CC_10_100_AUDIT_FLAG_INDEX;

	else					/* we're auditing on object type */
	     if oper_code.audit_type.object_type < lbound (process_audit_flags.objects, 1)
	     | oper_code.audit_type.object_type > hbound (process_audit_flags.objects, 1)
	     | oper_code.audit_type.access_type < 1	/* 0 allowed only for admin, priv, and covert channel events */
						/* |  oper_code.audit_type.access_type > n_audit_access_types (can't happen) */
	then goto ILLEGAL_INDEX;
	else do;
	     meter_index = (oper_code.audit_type.object_type - 1) * 2 * n_audit_access_types
		+ oper_code.audit_type.access_type;
	     if ^event_flags.grant
	     then meter_index = meter_index + n_audit_access_types;
	end;

	if meter_index >= active_hardcore_data$access_audit_num_meters
	then do;
ILLEGAL_INDEX:
	     call syserr (SYSERR_LOG_OR_PRINT, MSG_Meter_Index, EntryNames (entrypoint),
		pds$process_group_id, unspec (oper_code), string (event_flags), ^check_sw, caller);
dcl     MSG_Meter_Index	 char (108) int static options (constant)
			 init (
			 "access_audit_$^a: (^a) Encountered illegal meter index.  OperCode=^w  EventFlags=^w.^[  Caller=""^a"".^;^s^]"
			 );
	     meter_index = active_hardcore_data$access_audit_num_meters;
	end;

     end setup_log_entry;

ERROR_EXIT:
	return;

/* format: off */
%page; %include access_audit_flags;
%page; %include access_audit_eventflags;
%page; %include access_audit_encoded_op;
%page; %include access_audit_bin_header;
%page; %include access_audit_binary_def;
%page; %include access_audit_user_info;
%page; %include access_audit_ssobj_info;
%page; %include access_audit_names;
%page; %include aim_template;
%page; %include dir_header;
%page; %include dir_entry;
%page; %include dir_link;
%page; %include dir_name;
%page; %include syserr_constants;
%page; %include syserr_binary_def;
%page;
/* BEGIN MESSAGE DOCUMENTATION

   Message:
   access_audit_$ENTRY: (USER_ID) Unexpected error obtaining caller text pointer.  Caller="CALLING_PROC".

   S:	$info

   T:	$run

   M:	$err
   An error exists in the calling sequence to access_audit_.

   A:	$notify


   Message:
   access_audit_$ENTRY: (USER_ID) Encountered illegal meter index.  OperCode=XXXXXXXXXXXX  EventFlags=YYYYYYYYYYYY.(  Caller="CALLING_PROC".)

   S:	$log

   T:	$run

   M:	$err
   The access audit meters in active_hardcore_data are inconsistant
   with the format of the process access flags or the supplied
   operation code and/or event flags.

   A:	$notify


   Message:
   access_audit_$ENTRY: (USER_ID) Unable to get entry pointer for seg [#N | PATH] due to "MESSAGE".

   S:	$log

   T:	$run

   M:	$err
   A call to sum$getbranch_root_my or dc_find$obj_for_audit returned
   an unexpected error code.

   A:	$notify


   Message:
   access_audit_$ENTRY: (USER_ID) Unable to generate path for entry at PTR due to "MESSAGE".  Caller="CALLING_PROC".

   S:	$log

   T:	$run

   M:	$err
   A call to get_pathname_ returned an unexpected error code.

   A:	$notify


   Message:
   access_audit_: Insufficient room to allocate [ssobj|link] data.

   S:	$info

   T:	$run

   M:	$err
   An automatic data area is too small to accomodate the storage
   system object or link binary info.

   A:	$notify


   Message:
   access_audit_$ENTRY: (USER_ID) Unable to get UID path for directory seg #N due to "MESSAGE".   Caller="CALLER_PROC".

   S:	$log

   T:	$run

   M:	$err
   Although  the directory is locked, a failure occurred in
   uid_path_util$get.

   A:	$notify


   Message:
   access_audit_$ENTRY: (USER_ID) Unable to get raw access modes for entry PTR due to "MESSAGE".  Caller="CALLER_PROC".

   S:	$log

   T:	$run

   M:	$err
   Although the directory is locked a failure occurred in
   access_mode$raw.

   A:	$notify


   Message:
   access_audit_$UNKNOWN: (USER_ID) Illegal entrypoint index "N" detected in form_audit_message_text.  Caller="CALLING_PROC".

   S:	$info

   T:	$run

   M:	$err
   There is a coding error in access_audit_ where the entrypoint index
   is uninitialized or set to an incorrect value.

   A:	$notify
   

   Message:
   access_audit_$ENTRY: (USER_ID) Encountered illegal parameter combination.  OperCode=XXXXXXXXXXXX  EventFlags=YYYYYYYYYYYY.(  Caller="CALLING_PROC".)

   S:	$info

   T:	$run

   M:	$err
   There is an error in the access_operations_ entry or the eventflags
   passed to access audit.  The error was detected in the code which
   decides whether the caller needs to audit its event.  Because of
   the error, the event will be audited regardless of the process
   audit flags.

   A:	$notify


   Message:
   access_audit_$ENTRY: (USER_ID) Improper calling sequence (from "get_entry_pointer_and_class").  Caller="CALLING_PROC".

   S:	$info

   T:	$run

   M:	$err
   The entry was called with an improper argument combination.
   Most likely the entry will be (log check)_obj_ptr_(user) and
   the obj_ptr supplied will be null.

   A:	$notify


   Message:
   access_audit_$ENTRY: (USER_ID) Called with insufficient arguments (#args= ^d).(  Caller=""CALLING_PROC".)

   S:	$info

   T:	$run

   M:	$err
   access_audit_ was invoked with an improper calling sequence.  There
   may have been enough arguments to display the offending caller name.

   A:	$notify


   END MESSAGE DOCUMENTATION */

end access_audit_;
