/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1990   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(85-05-31,EJSharpe), approve(86-02-20,MCR7301),
     audit(86-04-07,Swenson), install(86-04-23,MR12.0-1044):
     fix bug where get_link_target would not update dir argument
  2) change(90-09-28,Schroth), approve(90-09-28,MCR8205),
     audit(90-10-04,WAAnderson), install(90-10-14,MR12.4-1042):
     Corrected dir_salvage entry to lock parent of dir to salvage after locking
     the dir itself.  This is in keeping with the documented protocol and
     corrects a potential dir locking deadly embrace.
                                                   END HISTORY COMMENTS */


/* The master module within directory control that finds directories or 
directory entries, checks access, audits successful accesses and attempted
access violations and produces correct user visible error codes.

Produced out of what once was find_, find_entry, find_dirsegno,
dir_control_error and parts of uid_path_util by Keith Loepere, June 1984.

Modified throughout 1984 by Keith Loepere for successful access auditing,
centralization of access decisions, etc.
Modified 84-11-27 by EJ Sharpe to change access_audit_ arg list
Modified 85-01-07 by Keith Loepere for obj_for_audit.
Modified 85-02-19 by Keith Loepere so that append through links returns the
   target path.
Modified 85-02-25 by Keith Loepere to bring back existence entrypoint.
Modified 85-04-01 by Keith Loepere for new access_audit_check_ep_ and fix
     to truncating MSFs.
Modified 85-04-08 by Keith Loepere to use fs_modes whenever possible,
     which has the advantage of understanding priv init objects.
Modified 85-05-08 by EJ Sharpe to add obj_delete_uid (non-privileged) and to
     make uid path searches obey AIM rules for making dir names known
Modified 85-05-15 by EJ Sharpe to change dir_write_raw_uid to mdir_set_quota_uid
*/

/* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */

dc_find: proc;
	return;

/* External */

dcl  active_all_rings_data$maxlinks	fixed bin ext;
dcl  dseg$			(0:4095) fixed bin (71) ext static;
dcl  error_table_$bad_uidpath		fixed bin (35) ext;
dcl  error_table_$badpath		fixed bin (35) ext;
dcl  error_table_$dirseg		fixed bin (35) ext;
dcl  error_table_$entlong		fixed bin (35) ext;
dcl  error_table_$incorrect_access	fixed bin (35) ext;
dcl  error_table_$link		fixed bin (35) ext;
dcl  error_table_$moderr		fixed bin (35) ext;
dcl  error_table_$mylock		fixed bin (35) ext;
dcl  error_table_$no_dir		fixed bin (35) ext;
dcl  error_table_$no_info		fixed bin (35) ext;
dcl  error_table_$no_s_permission	fixed bin (35) ext;
dcl  error_table_$namedup		fixed bin (35) ext;
dcl  error_table_$noentry		fixed bin (35) ext;
dcl  error_table_$not_link		fixed bin (35) ext;
dcl  error_table_$notadir		fixed bin (35) ext;
dcl  error_table_$oosw		fixed bin (35) ext;
dcl  error_table_$root		fixed bin (35) ext;
dcl  error_table_$seg_deleted		fixed bin (35) ext;
dcl  error_table_$segknown		fixed bin (35) ext;
dcl  error_table_$toomanylinks	fixed bin (35) ext;
dcl  pds$access_authorization		bit (72) aligned ext;

/* Entries */

dcl  access_audit_check_ep_$self	entry (bit (36) aligned, bit (36) aligned, ptr) returns (bit (1));
dcl  access_audit_check_ep_$user	entry (bit (36) aligned, bit (36) aligned, ptr, bit (72) aligned, bit (36) aligned) returns (bit (1));
dcl  access_audit_$log_entry_ptr	entry (char (*), fixed bin, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, fixed bin (18), char (*));
dcl  access_audit_$log_entry_ptr_user	entry (char (*), fixed bin, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, fixed bin (18), ptr, char (*));
dcl  access_mode$effective		entry (ptr, bit (36) aligned, bit (36) aligned, fixed bin (35));
dcl  access_mode$raw		entry (ptr, bit (36) aligned, bit (36) aligned, fixed bin (35));
dcl  access_mode$user_effmode		entry (ptr, char (32) aligned, bit (72) aligned, fixed bin (3), bit (36) aligned, bit (36) aligned, fixed bin (35));
dcl  aim_check_$greater_or_equal	entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
dcl  fs_modes$locked		entry (ptr, bit (36) aligned, bit (36) aligned, (3) fixed bin (3), fixed bin (35));
dcl  get_kstep			entry (fixed bin, ptr, fixed bin (35));
dcl  hash$search			entry (ptr, ptr, ptr, fixed bin (35));
dcl  level$get			entry () returns (fixed bin);
dcl  lock$dir_lock_read		entry (ptr, fixed bin (35));
dcl  lock$dir_lock_salvage		entry (ptr, bit (36) aligned, fixed bin (35));
dcl  lock$dir_lock_write		entry (ptr, fixed bin (35));
dcl  lock$dir_unlock		entry (ptr);
dcl  makeknown_			entry (ptr, fixed bin (17), fixed bin (17), fixed bin (35));
dcl  mlr_				entry (ptr, fixed bin (21), ptr, fixed bin (21));
dcl  mrl_				entry (ptr, fixed bin (21), ptr, fixed bin (21));
dcl  pathname_am$get_segno		entry (char (*) varying, fixed bin (17));
dcl  pathname_am$set		entry (char (*) varying, fixed bin (17));
dcl  read_allowed_			entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
dcl  sdw_util_$construct		entry (ptr, ptr);
dcl  sdw_util_$dissect		entry (ptr, ptr);
dcl  segno_usage$decrement		entry (fixed bin (17), fixed bin (35));
dcl  sum$getbranch			entry (ptr, bit (36) aligned, ptr, fixed bin (35));
dcl  sum$getbranch_root_my		entry (ptr, bit (36) aligned, ptr, fixed bin (35));
dcl  update_kste_access		entry (ptr, ptr, bit (36) aligned);
dcl  wired_utility_$grow_stack_frame	entry (fixed bin) returns (ptr);

/* Misc */

dcl  addcharno			builtin;
dcl  addr				builtin;
dcl  baseptr			builtin;
dcl  binary			builtin;
dcl  index			builtin;
dcl  length			builtin;
dcl  max				builtin;
dcl  min				builtin;
dcl  null				builtin;
dcl  ptr				builtin;
dcl  rel				builtin;
dcl  reverse			builtin;
dcl  rtrim			builtin;
dcl  segno			builtin;
dcl  size				builtin;
dcl  string			builtin;
dcl  substr			builtin;
dcl  unspec			builtin;

dcl  bad_dir_			condition;

/* Parameters */

dcl  a_audit_user_info_ptr		ptr parameter;
dcl  a_bc				fixed bin (24) parameter;
dcl  a_bc_delta			fixed bin (24) parameter;
dcl  a_chase_sw			fixed bin (1) parameter;
dcl  a_code			fixed bin (35) parameter;
dcl  a_detailed_operation		fixed bin (18) uns parameter;
dcl  a_dir_uid			bit (36) aligned parameter;
dcl  a_dirname			char (168) unal parameter;
dcl  a_dp				ptr parameter;
dcl  a_entryname			char (32) unal parameter;
dcl  a_ep				ptr parameter;
dcl  a_exmode			bit (36) aligned parameter;
dcl  a_kstep			ptr parameter;
dcl  a_mode			bit (36) aligned parameter;
dcl  a_pep			ptr parameter;
dcl  a_ppep			ptr parameter;
dcl  a_ringbr			(3) fixed bin (3) parameter;
dcl  a_segptr			ptr parameter;
dcl  a_unlocksw			bit (1) aligned parameter;
dcl  a_uidpath			(0:15) bit (36) aligned parameter;

/* Constants */

dcl  FIND_ALL			bit (4) aligned init ("1111"b) static options (constant);
dcl  FIND_DIR			bit (4) aligned init ("1000"b) static options (constant);
dcl  FIND_DIR_OR_LINK		bit (4) aligned init ("1100"b) static options (constant);
dcl  FIND_LINK			bit (4) aligned init ("0100"b) static options (constant);
dcl  FIND_LINK_OR_NOTHING		bit (4) aligned init ("0110"b) static options (constant);
dcl  FIND_NOTHING			bit (4) aligned init ("0010"b) static options (constant);
dcl  FIND_OBJECT_OR_LINK		bit (4) aligned init ("1101"b) static options (constant);
dcl  FIND_SEG			bit (4) aligned init ("0001"b) static options (constant);
dcl  ME				char (7) init ("dc_find") static options (constant);
dcl  READ_LOCK			bit (36) aligned init ("0"b) static options (constant);
dcl  WRITE_LOCK			bit (36) aligned init ("1"b) static options (constant);

/* Variables */

dcl  access_checker			variable entry (ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)); /* one of the access_mode$foo gets put here */
dcl  change_bc			bit (1) aligned;
dcl  chase_sw			fixed bin (1);
dcl  code				fixed bin (35);
dcl  dir_uid			bit (36) aligned;
dcl  dirmode			bit (36) aligned;
dcl  dirmode_raw			bit (1) aligned;
dcl  dirname			char (168) var;
dcl  entryname			char (32) aligned;
dcl  exmode			bit (36) aligned;
dcl  linkage_ring			fixed bin (3);
dcl  lock_for_writing		bit (36) aligned;
dcl  mode				bit (36) aligned;
dcl  1 my_makeknown_info		aligned like makeknown_info;
dcl  objmode			bit (36) aligned;
dcl  pdp				ptr;
dcl  pep				ptr;
dcl  ppdp				ptr;
dcl  ppep				ptr;
dcl  ringbr			(3) fixed bin (3);
dcl  1 sdwi			aligned like sdw_info;
dcl  segptr			ptr;
dcl  1 state			aligned,
       2 allow_searching_aim_isolated_dirs bit (1) aligned,
       2 allow_aim_isolated_final_dir	bit (1) aligned,
       2 dir_held			bit (1) aligned,
       2 dir_locked			bit (1) aligned,
       2 for_user			bit (1) aligned,	/* this is being done for someone else */
       2 parent_locked		bit (1) aligned,
       2 parent_parent_locked		bit (1) aligned,
       2 find_dir_has_work_area	bit (1) aligned,
       2 work_pathname_ptr		ptr,
       2 operation			bit (36) aligned,
       2 event_flags		bit (36) aligned,
       2 user			aligned like audit_user_info; /* user this is done for */
dcl  uidpath			(0:15) bit (36) aligned;
%page;
dir_for_append: entry (a_dirname, a_entryname, a_chase_sw, a_pep, a_dp, a_code);

/* Used by append to find a pointer into a directory into which to append.  
The dirname and entryname variables are updated to the target of the link if
chase is specified.  The directory is returned locked. */

	dirmode_raw = "0"b;
	go to dir_for_append_join;

dir_for_append_raw: entry (a_dirname, a_entryname, a_chase_sw, a_pep, a_dp, a_code);

	dirmode_raw = "1"b;				/* admin_gate_ */

dir_for_append_join:
	call dir_name_setup;
	dirmode = A_ACCESS;
	state.operation = access_operations_$fs_obj_contents_mod; /* obj creation is audited by append */
	addr (state.operation) -> encoded_access_op.detailed_operation = FS_OBJ_CREATE_BRANCH;

	entryname = a_entryname;
	lock_for_writing = "1"b;
	chase_sw = a_chase_sw;
	a_pep, pep = null;

	call find_$append;
	if code ^= 0 then go to RETURN;

	call sum$getbranch_root_my (dp, READ_LOCK, pep, code);
	if code = 0 then state.parent_locked = "1"b;
	else if code = error_table_$root then code = 0;
	else call fatal_error;
	pdp = ptr (pep, 0);

	if dirmode_raw then call access_mode$raw (pep, mode, exmode, code);
	else call get_dir_mode$locked (dp, exmode, code);
	if code ^= 0 then call fatal_error;
	if (exmode & dirmode) ^= dirmode then do;
	     call dir_control_error$append (pep, code);
	     call fatal_error;
	end;

	call audit_success$msg (pep, entryname);

	a_dirname = dirname;
	a_entryname = entryname;
	a_pep = pep;
	a_dp = dp;
	a_code = code;
	return;
%page;
dir_for_retrieve_append: entry (a_dirname, a_entryname, a_chase_sw, a_audit_user_info_ptr, a_pep, a_dp, a_code);

/* Used by append to find a pointer into a directory into which to append.  
The dirname and entryname variables are updated to the target of the link if
chase is specified.  The directory is returned locked. */

	call dir_name_setup;
	state.operation = access_operations_$fs_obj_contents_mod; /* obj creation audited by append */
	addr (state.operation) -> encoded_access_op.detailed_operation = FS_OBJ_CREATE_BRANCH;

	state.for_user = "1"b;
	state.user = a_audit_user_info_ptr -> audit_user_info;

	a_pep, pep = null;
	entryname = a_entryname;
	lock_for_writing = "1"b;
	chase_sw = a_chase_sw;

	call find_$append;
	if code ^= 0 then go to RETURN;

	call sum$getbranch_root_my (dp, READ_LOCK, pep, code);
	if code = 0 then state.parent_locked = "1"b;
	else if code = error_table_$root then code = 0;
	else call fatal_error;
	pdp = ptr (pep, 0);

	call access_mode$user_effmode (pep, state.user_id, state.authorization, (state.ring), mode, exmode, code);
	if code ^= 0 then call fatal_error;
	if (exmode & A_ACCESS) ^= A_ACCESS then do;
	     call dir_control_error$append (pep, code);
	     call fatal_error;
	end;

	call audit_success$msg (pep, entryname);

	a_dirname = dirname;
	a_entryname = entryname;
	a_pep = pep;
	a_dp = dp;
	a_code = code;
	return;
%page;
dir_initiate: entry (a_dirname, a_dp, a_code);

/* Make the dir known (set_wdir, etc.). */

	call dir_name_setup;
	state.operation = access_operations_$fs_obj_initiate;
	lock_for_writing = "0"b;

	call find_locked_dir;
	if code ^= 0 then go to RETURN;

	call sum$getbranch_root_my (dp, READ_LOCK, pep, code); /* needed for auditing */
	if code = 0 then state.parent_locked = "1"b;
	else if code = error_table_$root then code = 0;
	else call fatal_error;
	pdp = ptr (pep, 0);

	call get_dir_mode$locked (dp, exmode, code);	/* must have access to dir or parent */
	if code ^= 0 then call fatal_error;
	if exmode = "0"b then do;			/* check parent */
	     if pdp ^= null then do;
		call get_dir_mode (pdp, exmode, code);
		if code ^= 0 then call fatal_error;
	     end;
	     if exmode = "0"b then do;
		call dir_control_error$attributes (pep, code);
		call fatal_error;
	     end;
	end;

	call audit_success (pep);

	if state.parent_locked then call lock$dir_unlock (pdp); /* done with parent */

	a_dp = dp;
	a_code = code;
	return;
%page;
dir_move_quota: entry (a_dirname, a_pep, a_dp, a_code);

/* Used by quota moving.  Access checks are M on the target dir and M on the
parent.  NOTE also that the final target is allowed to be upgraded. */

	call dir_name_setup;
	state.operation = access_operations_$fs_obj_contents_mod;
	addr (state.operation) -> encoded_access_op.detailed_operation = FS_OBJ_MOVE_QUOTA;

	a_pep, pep = null;
	state.allow_aim_isolated_final_dir = "1"b;	/* This is the only known case where this is true. */
	lock_for_writing = "1"b;

	if dirname = ">" then do;
	     code = error_table_$root;
	     go to RETURN;
	end;

	call find_locked_dir;
	if code ^= 0 then go to RETURN;

	call sum$getbranch (dp, WRITE_LOCK, pep, code);
	if code ^= 0 then call fatal_error;
	pdp = ptr (pep, 0);
	state.parent_locked = "1"b;

	call get_dir_mode (pdp, exmode, code);
	if code ^= 0 then call fatal_error;
	if (exmode & M_ACCESS) ^= M_ACCESS | ^aim_check_$greater_or_equal (pep -> entry.access_class, dp -> dir.access_class) then do;
						/* user not allowed to see dir for access or aim isolated */
	     call dir_control_error$contents (pep, code);
	     call fatal_error;
	end;

	call access_mode$raw (pep, mode, exmode, code);
	if code ^= 0 then call fatal_error;
	if (exmode & M_ACCESS) ^= M_ACCESS then do;
	     call dir_control_error$contents (pep, code);
	     call fatal_error;
	end;

	call audit_success (pep);

	a_pep = pep;
	a_dp = dp;
	a_code = code;
	return;
%page;
dir_read: entry (a_dirname, a_dp, a_code);

/* These return a pointer to a locked directory.  The use of these are for 
cases in which the contents (name space, iacls) of a directory are desired.  
The access requirements are effective s access on the dir for read, m for 
write. */

	lock_for_writing = "0"b;
	dirmode = S_ACCESS;
	call dir_name_setup;
	state.operation = access_operations_$fs_obj_contents_read;
	go to dir_join;

dir_write: entry (a_dirname, a_detailed_operation, a_dp, a_code);

	lock_for_writing = "1"b;
	dirmode = M_ACCESS;
	call dir_name_setup;
	state.operation = access_operations_$fs_obj_contents_mod;
	addr (state.operation) -> encoded_access_op.detailed_operation = a_detailed_operation;
	go to dir_join;

dir_read_priv: entry (a_dirname, a_dp, a_code);

	lock_for_writing = "0"b;
	dirmode = "0"b;
	call dir_name_setup;
	state.operation = access_operations_$fs_obj_contents_read;
	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;
	go to dir_join;

dir_write_priv: entry (a_dirname, a_detailed_operation, a_dp, a_code);

	lock_for_writing = "1"b;
	dirmode = "0"b;
	call dir_name_setup;
	state.operation = access_operations_$fs_obj_contents_mod;
	addr (state.operation) -> encoded_access_op.detailed_operation = a_detailed_operation;
	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;

dir_join:
	call find_locked_dir;
	if code ^= 0 then go to RETURN;

	call sum$getbranch_root_my (dp, READ_LOCK, pep, code); /* needed for auditing */
	if code = 0 then state.parent_locked = "1"b;
	else if code = error_table_$root then code = 0;
	else call fatal_error;
	pdp = ptr (pep, 0);

	if dirmode ^= "0"b then do;
	     call get_dir_mode$locked (dp, exmode, code);
	     if code ^= 0 then call fatal_error;
	     if (exmode & dirmode) ^= dirmode then do;
		call dir_control_error$contents (pep, code);
		call fatal_error;
	     end;
	end;

	call audit_success (pep);

	if state.parent_locked then call lock$dir_unlock (pdp);

	a_dp = dp;				/* Success! */
	a_code = code;
	return;
%page;
dir_reclassify: entry (a_dirname, a_ppep, a_pep, a_dp, a_code);

/* Return a pointer to a dir, its entry and its parent's parent's entry for the
reclassify_node operation. */

	call dir_name_setup;
	state.operation = access_operations_$fs_obj_access_mod;
	addr (state.operation) -> encoded_access_op.detailed_operation = FS_OBJ_RECLASSIFY_NODE;
	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;
	a_pep, a_ppep, pep, ppep = null;
	lock_for_writing = "1"b;

	if dirname = ">" then do;
	     code = error_table_$root;
	     go to RETURN;
	end;

	call find_locked_dir;
	if code ^= 0 then go to RETURN;

	call sum$getbranch (dp, WRITE_LOCK, pep, code);
	if code ^= 0 then call fatal_error;
	pdp = ptr (pep, 0);
	state.parent_locked = "1"b;

	call access_mode$raw (pep, mode, exmode, code);	/* check raw mode on parent for reclassify */
	if code ^= 0 then call fatal_error;
	if (exmode & SM_ACCESS) ^= SM_ACCESS then do;
	     call dir_control_error$contents (pep, code);
	     call fatal_error;
	end;

	call sum$getbranch_root_my (pdp, READ_LOCK, ppep, code);
	if code = 0 then state.parent_parent_locked = "1"b;
	else if code = error_table_$root then code = 0;
	else call fatal_error;
	ppdp = ptr (ppep, 0);

	call access_mode$raw (ppep, mode, exmode, code);
	if code ^= 0 then call fatal_error;
	if (exmode & M_ACCESS) ^= M_ACCESS then do;
	     call dir_control_error$contents (pep, code);
	     call fatal_error;
	end;

	call audit_success (pep);

	a_ppep = ppep;
	a_pep = pep;
	a_dp = dp;
	a_code = code;
	return;
%page;
dir_salvage: entry (a_dirname, a_dir_uid, a_dp, a_code);

/* Entry used by the directory salvager.  It is like dir_write_priv except that
it uses a special locking primitive. */

	call dir_name_setup;
	state.operation = access_operations_$fs_obj_contents_mod;
	addr (state.operation) -> encoded_access_op.detailed_operation = FS_OBJ_DIR_SALVAGE;
	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;
	a_dir_uid = "0"b;

	call find_dir;
	if code ^= 0 then go to RETURN;

	dir.modify = "0"b;

	call lock$dir_lock_salvage (dp, dir_uid, code);
	if code ^= 0 then call fatal_error;

	call sum$getbranch_root_my (dp, READ_LOCK, pep, code); /* needed for auditing */
	if code = 0 then state.parent_locked = "1"b;
	else if code = error_table_$root then code = 0;
	else call fatal_error;
	pdp = ptr (pep, 0);

	call audit_success (pep);

	if state.parent_locked then call lock$dir_unlock (pdp);

	a_dir_uid = dir_uid;
	a_dp = dp;				/* Success! */
	a_code = code;
	return;
%page;
mdir_set_quota_uid: entry (a_uidpath, a_dirname, a_detailed_operation, a_pep, a_dp, a_code);

/* Returns a pointer to a directory when given a uid path.  Access requirements
are M on the dir. It is used by quota$mdir_set. */

	unspec (state) = "0"b;
	state.operation = access_operations_$fs_obj_contents_mod;
	addr (state.operation) -> encoded_access_op.detailed_operation = a_detailed_operation;
	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;
	state.allow_aim_isolated_final_dir = "1"b;

	dirmode = M_ACCESS;
	a_pep, pdp, pep, ep, a_dp, dp = null;
	code = 0;
	uidpath = a_uidpath;
	lock_for_writing = "0"b;			/* parent dir is not beign modified */

	call uid_path_util$find_dir;
	if code = error_table_$root then a_dirname = dirname; /* Return name so far */
	if code ^= 0 then go to RETURN;

	call lock$dir_lock_write (dp, code);
	if code ^= 0 then call fatal_error;
	state.dir_locked = "1"b;

	call sum$getbranch (dp, lock_for_writing, pep, code);
	if code ^= 0 then call fatal_error;
	pdp = ptr (pep, 0);
	state.parent_locked = "1"b;

	call access_mode$raw (pep, mode, exmode, code);
	if code ^= 0 then call fatal_error;
	if (exmode & dirmode) ^= dirmode then do;
	     call dir_control_error$contents (pep, code);
	     call fatal_error;
	end;

	call audit_success (pep);

	a_dirname = dirname;
	a_pep = pep;
	a_dp = dp;
	a_code = 0;
	return;
%page;
finished: entry (a_ep, a_unlocksw);

/* Undoes the result of a previous dc_find (non-ptr) call.  It unlocks the dir 
specified (if unlocksw is set) and dereferences the dir.  The proper 
termination for a directory found through a _ptr entry is to call 
lock$dir_unlock on it. */

	ep = a_ep;
	if ep ^= null then do;
	     if a_unlocksw then call lock$dir_unlock (ptr (ep, 0));
	     call segno_usage$decrement (segno (ep), (0));
	end;
	return;
%page;
link_target: entry (a_dirname, a_entryname, a_code);

/* Returns the path of the target of the (possible) link.  The user must have 
non-null access to the target dir or non-null access to the target (if it 
exists). */

	unspec (state) = "0"b;
	state.operation = access_operations_$fs_obj_prop_read;

	code = 0;
	dirname = rtrim (a_dirname);
	entryname = a_entryname;
	lock_for_writing = "0"b;

	call find_$link_target;
	if code ^= 0 then go to RETURN;

	if ep ^= null then do;			/* a target exists */
	     call get_dir_mode (dp, exmode, code);
	     if code ^= 0 then call fatal_error;
	     if exmode = N_ACCESS then do;		/* no dir access, check entry */
		call access_mode$effective (ep, mode, exmode, code);
		if code ^= 0 then call fatal_error;
		if ep -> entry.dirsw then mode = exmode;
		if mode = N_ACCESS then do;		/* null on both target dir and target */
		     call dir_control_error$attributes (ep, code);
		     call fatal_error;
		end;
	     end;

	     call audit_success (ep);
	end;
	else do;
	     state.operation = access_operations_$fs_obj_contents_read; /* reading names in dir */

	     call sum$getbranch_root_my (dp, READ_LOCK, pep, code); /* needed for auditing */
	     if code = 0 then state.parent_locked = "1"b;
	     else if code = error_table_$root then code = 0;
	     else call fatal_error;
	     pdp = ptr (pep, 0);

	     call get_dir_mode$locked (dp, exmode, code);
	     if code ^= 0 then call fatal_error;
	     if exmode = N_ACCESS then do;
		code = error_table_$no_info;
		call dir_control_error$name_non_existant (dp, code);
		call fatal_error;
	     end;

	     call audit_success (pep);

	     if state.parent_locked then call lock$dir_unlock (pdp);

	     code = error_table_$noentry;		/* tell of non-existance */
	end;

	call lock$dir_unlock (dp);
	call segno_usage$decrement (segno (dp), (0));	/* done with dir */

	a_dirname = dirname;
	a_entryname = entryname;
	a_code = code;
	return;
%page;
obj_attributes_read: entry (a_dirname, a_entryname, a_chase_sw, a_ep, a_code);

/* Return a pointer to an entry in a locked directory.  These entries are used 
when the attributes of an object (such as ring brackets) are desired that are
accessible for either effective s access on the parent dir or non-null access 
on the object (for read) or for m access on the parent dir or w/m access on 
the object (for write). */

	lock_for_writing = "0"b;
	dirmode = S_ACCESS;
	call obj_name_setup;
	state.operation = access_operations_$fs_obj_prop_read;
	go to obj_attributes_name_join;

obj_attributes_write: entry (a_dirname, a_entryname, a_chase_sw, a_detailed_operation, a_ep, a_code);

	lock_for_writing = "1"b;
	dirmode = M_ACCESS;
	call obj_name_setup;
	state.operation = access_operations_$fs_obj_attr_mod;
	addr (state.operation) -> encoded_access_op.detailed_operation = a_detailed_operation;
	go to obj_attributes_name_join;

obj_terminate: entry (a_dirname, a_entryname, a_chase_sw, a_ep, a_code);

	lock_for_writing = "0"b;
	dirmode = N_ACCESS;
	call obj_name_setup;
	state.operation = access_operations_$fs_obj_terminate;

obj_attributes_name_join:
	chase_sw = a_chase_sw;

	call find_;
	if code ^= 0 then go to RETURN;
	go to obj_attributes_join;

obj_existence_ptr: entry (a_segptr, a_ep, a_code);

	lock_for_writing = "0"b;
	dirmode = N_ACCESS;
	call obj_ptr_setup;
	state.operation = access_operations_$fs_obj_prop_read;
	go to obj_attributes_ptr_join;

obj_terminate_ptr: entry (a_segptr, a_ep, a_code);

	lock_for_writing = "0"b;
	dirmode = N_ACCESS;
	call obj_ptr_setup;
	state.operation = access_operations_$fs_obj_terminate;
	go to obj_attributes_ptr_join;

obj_attributes_read_ptr: entry (a_segptr, a_ep, a_code);

	lock_for_writing = "0"b;
	dirmode = S_ACCESS;
	call obj_ptr_setup;
	state.operation = access_operations_$fs_obj_prop_read;
	go to obj_attributes_ptr_join;

obj_attributes_write_ptr: entry (a_segptr, a_detailed_operation, a_ep, a_code);

	lock_for_writing = "1"b;
	dirmode = M_ACCESS;
	call obj_ptr_setup;
	state.operation = access_operations_$fs_obj_attr_mod;
	addr (state.operation) -> encoded_access_op.detailed_operation = a_detailed_operation;

obj_attributes_ptr_join:
	call find_segptr_branch;
	if code ^= 0 then
	     if code = error_table_$root & state.operation = access_operations_$fs_obj_terminate then go to obj_attribute_success;
	     else go to SEGPTR_FAILURE;

obj_attributes_join:
	call get_dir_mode (dp, exmode, code);
	if code ^= 0 then call fatal_error;
	if (exmode & dirmode) = dirmode then
	     if exmode = N_ACCESS then go to obj_attributes_check_target; /* dirmode of N_ACCESS can also bring us here */
	     else ;
	else do;					/* wrong parent access, check for access on target */
obj_attributes_check_target:
	     if ^ep -> entry.bs then go to obj_attributes_error; /* link */
	     if state.dir_held then			/* path entry */
		call access_mode$effective (ep, mode, exmode, code);
	     else call fs_modes$locked (segptr, mode, exmode, ringbr, code);
	     if code ^= 0 then call fatal_error;
	     if dirmode = M_ACCESS then do;		/* we need m/w if we do not have m on parent */
		if ep -> entry.dirsw then
		     if (exmode & M_ACCESS) ^= M_ACCESS then go to obj_attributes_error;
		     else ;
		else if (mode & W_ACCESS) ^= W_ACCESS then go to obj_attributes_error;
		else ;
	     end;
	     else do;				/* we'll allow since user has non-null on object */
		if ep -> entry.dirsw then mode = exmode;
		if mode = N_ACCESS then do;
obj_attributes_error:    call dir_control_error$attributes (ep, code);
		     call fatal_error;
		end;
		else ;
	     end;
	end;

obj_attribute_success:
	call audit_success (ep);

	a_ep = ep;				/* Success! */
	a_code = code;
	return;
%page;
obj_bc_delta_write: entry (a_dirname, a_entryname, a_bc_delta, a_ep, a_code);

/* Return a pointer to a directory entry.  These entries are called when the
caller wishes to change the bit_coount for an object.  The delta entries are 
called when the bit_count is to added to/subtracted from; the non-delta when
bc is to be set.  These entries have strange access requirements; w if a 
segment; for a directory, m if lowering the bc, a if increasing. */

	change_bc = "1"b;
	go to obj_bc_name_join;

obj_bc_write: entry (a_dirname, a_entryname, a_bc, a_ep, a_code);

	change_bc = "0"b;

obj_bc_name_join:
	call obj_name_setup;
	state.operation = access_operations_$fs_obj_contents_mod;
	addr (state.operation) -> encoded_access_op.detailed_operation = FS_OBJ_BC_MOD;
	lock_for_writing = "1"b;
	chase_sw = DC_FIND_CHASE;

	call find_;
	if code ^= 0 then go to RETURN;

	call access_mode$effective (ep, mode, exmode, code);
	if code ^= 0 then call fatal_error;
	go to obj_bc_join;

obj_bc_delta_write_ptr: entry (a_segptr, a_bc_delta, a_ep, a_code);

	change_bc = "1"b;
	go to obj_bc_ptr_join;

obj_bc_write_ptr: entry (a_segptr, a_bc, a_ep, a_code);

	change_bc = "0"b;

obj_bc_ptr_join:
	lock_for_writing = "1"b;

	call obj_ptr_setup;
	state.operation = access_operations_$fs_obj_contents_mod;
	addr (state.operation) -> encoded_access_op.detailed_operation = FS_OBJ_BC_MOD;

	call find_segptr_branch;
	if code ^= 0 then go to SEGPTR_FAILURE;

	call fs_modes$locked (segptr, mode, exmode, ringbr, code);
	if code ^= 0 then call fatal_error;

obj_bc_join:
	if ep -> entry.dirsw then do;
	     mode = exmode;
	     if change_bc then
		if a_bc_delta <= 0 then objmode = M_ACCESS; /* viewed as deleting components of msf */
		else objmode = A_ACCESS;		/* adding components */
	     else if ep -> entry.bc >= a_bc then objmode = M_ACCESS;
	     else objmode = A_ACCESS;
	end;
	else objmode = W_ACCESS;
	if (mode & objmode) ^= objmode then do;
	     call dir_control_error$contents (ep, code);
	     call fatal_error;
	end;

	call audit_success (ep);

	a_ep = ep;
	a_code = code;
	return;
%page;
obj_for_audit: entry (a_dirname, a_entryname, a_ep, a_code);

/* Returns a pointer to an entry in a locked directory.  No access check or
auditing are done, in as much as access_audit_ is calling us so that it can
audit somthing about the path supplied. */

	lock_for_writing = "0"b;
	call obj_name_setup;
	state.operation = access_operations_$fs_obj_prop_read; /* in case something goes wrong */
	chase_sw = DC_FIND_NO_CHASE;

	call find_;
	if code ^= 0 then go to RETURN;

	a_ep = ep;
	a_code = code;
	return;
%page;
obj_initiate: entry (a_dirname, a_entryname, a_ep, a_code);

/* Returns the entry pointer for the initiate function.  The access check is
non-null on the object.  The _dp versions take a directory pointer instead
of a directory name.  For these (used by fs_search), a simple dir look-up is
done.  If the object found is a link, though, we must perform a normal
branch lookup.  In this case, a_dp is set to null, warning the user that
his dp is no longer good and that finished must be called.  The raw version
only checks raw access on the target;  it also simulates dir priv by ignoring
the upgradedness of directories when searching them.  The auth version uses 
authorization access. */

	call obj_name_setup;
	state.operation = access_operations_$fs_obj_initiate;

	access_checker = access_mode$effective;
	go to initiate_name_join;

obj_initiate_raw: entry (a_dirname, a_entryname, a_ep, a_code);

	call obj_name_setup;
	state.operation = access_operations_$fs_obj_initiate;
	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;

	state.allow_searching_aim_isolated_dirs = "1"b;
	access_checker = access_mode$raw;

initiate_name_join:
	lock_for_writing = "0"b;
	chase_sw = DC_FIND_CHASE;

	call find_;
	if code = 0 then ;
	else if code = error_table_$root then do;
	     dp, ep = null;
	     code = 0;
	end;
	else go to RETURN;
	go to initiate_join;

obj_initiate_for_linker_dp: entry (a_dp, a_entryname, a_ep, a_code);

/* NOTE: we have a contract that the only caller of this is initiate_seg_count,
which in turn is only called by fs_search.  Since this is the case, we perform
an optimization that throws away information (providing no security 
violation).  For this entry, we merge the non-existance of the target with
no_info access to the target and call the result no_info in both cases. */

	unspec (state) = "0"b;
	state.operation = access_operations_$fs_obj_initiate;

	access_checker = access_mode$effective;

	lock_for_writing = "0"b;
	a_ep, ep = null;
	dp = a_dp;
	entryname = a_entryname;
	code = 0;

	call lock$dir_lock_read (dp, code);
	if code ^= 0 then go to RETURN;
	state.dir_locked = "1"b;

	call find_entry (dp, entryname, FIND_ALL, ep, code);
	if code ^= 0 then call fatal_error;
	if ep = null then do;			/* no such name */
	     code = error_table_$no_info;		/* don't bother distinguishing this from no_entry, fs_search doesn't care */
	     call fatal_error;
	end;

	if ^ep -> entry.bs then do;			/* link */
	     dirname = rtrim (substr (ep -> link.pathname, 1, ep -> link.pathname_size));
	     entryname = "";
	     call lock$dir_unlock (dp);
	     state.dir_locked = "0"b;
	     a_dp = null;				/* tell user his dp isn't good anymore; finished must be called */
	     call find_$link_target;
	     if code = 0 then do;
		if ep = null then do;		/* no such target */
		     code = error_table_$no_info;	/* don't bother distinguishing this from no_entry, fs_search doesn't care */
		     call fatal_error;
		end;
	     end;
	     else if code = error_table_$root then do;
		dp, ep = null;
		code = 0;
	     end;
	     else go to RETURN;
	end;

initiate_join:
	call access_checker (ep, mode, exmode, code);
	if code ^= 0 then call fatal_error;

/* We allow initiating dirs only if the mode and exmode are non_null. */

	if ep = null then				/* root */
	     if exmode = "0"b then go to obj_initiate_error;
	     else ;
	else if ep -> entry.dirsw then
	     if exmode = "0"b then go to obj_initiate_error;

	if mode = "0"b then do;
obj_initiate_error:
	     if ep = null then code = error_table_$dirseg;/* not nice to ask for root */
	     else if ep -> entry.dirsw then do;
		call dir_control_error$contents_info (ep, code); /* asking for dir is not considered a real violation */
		if code = error_table_$moderr then code = error_table_$dirseg;
	     end;
	     else call dir_control_error$contents (ep, code);
	     call fatal_error;
	end;

	call audit_success (ep);

	a_ep = ep;
	a_code = code;
	return;
%page;
obj_linkage_ring_ptr: entry (a_segptr, a_code);

/* Allows a user process to read the definitions for a lower ring gate by
lowering the ring number in the supplied pointer from within the call bracket 
into the read bracket. */

	unspec (state) = "0"b;
	state.operation = access_operations_$fs_obj_contents_read;

	ep = null;
	code = 0;
	segptr = a_segptr;

	lock_for_writing = "0"b;

	call find_segptr_branch;
	if code ^= 0 then go to SEGPTR_FAILURE;

	call fs_modes$locked (segptr, mode, exmode, ringbr, code);
	if code ^= 0 then call fatal_error;

	if (mode & E_ACCESS) ^= E_ACCESS then do;
	     call dir_control_error$attributes (ep, code);
	     call fatal_error;
	end;

	call audit_success (ep);

	call lock$dir_unlock (dp);

	linkage_ring = min (level$get (), ringbr (2));	/* let read through call bracket */

	addr (a_segptr) -> its_unsigned.ringno = linkage_ring;
	a_code = code;
	return;
%page;
obj_modes_ptr: entry (a_segptr, a_mode, a_exmode, a_ringbr, a_code);

/* Return the access modes the process has to the object, assuming it has some
access. */

	unspec (state) = "0"b;
	state.operation = access_operations_$fs_obj_prop_read;
	ep = null;
	code = 0;
	segptr = a_segptr;

	lock_for_writing = "0"b;

	call sum$getbranch_root_my (segptr, lock_for_writing, ep, code);
	if code ^= 0 then
	     if code = error_table_$root then do;
		code = 0;
		ep = null;
	     end;
	     else go to SEGPTR_FAILURE;
	else do;
	     dp = ptr (ep, 0);
	     state.dir_locked = "1"b;
	end;

	call fs_modes$locked (segptr, mode, exmode, ringbr, code);
	if code ^= 0 then call fatal_error;

	if ep = null then do;
	     mode = exmode;				/* root */
	     exmode = "0"b;
	end;
	else if ep -> entry.dirsw then do;
	     mode = exmode;				/* dir */
	     exmode = "0"b;
	end;

	if mode = "0"b then do;			/* make sure user is allowed to see no access */
	     if ep = null then dirmode = "0"b;		/* root */
	     else do;
		call get_dir_mode (dp, dirmode, code);
		if code ^= 0 then call fatal_error;
	     end;
	     if (dirmode & S_ACCESS) ^= S_ACCESS then do;
		call dir_control_error$attributes (ep, code);
		call fatal_error;
	     end;
	end;

	call audit_success (ep);

	if ep -> entry.dirsw then code = error_table_$dirseg;
	if state.dir_locked then call lock$dir_unlock (dp);

	a_mode = mode;
	a_exmode = exmode;
	a_ringbr = ringbr;
	a_code = code;
	return;
%page;
obj_reclassify: entry (a_dirname, a_entryname, a_pep, a_ep, a_code);

/* Return a pointer to a directory entry and its parent entry for the 
reclassify operation. */

	call obj_name_setup;
	state.operation = access_operations_$fs_obj_access_mod;
	addr (state.operation) -> encoded_access_op.detailed_operation = FS_OBJ_RECLASSIFY;
	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;

	lock_for_writing = "1"b;
	a_pep, pep = null;
	chase_sw = DC_FIND_NO_CHASE;

	call find_;
	if code ^= 0 then go to RETURN;

	call sum$getbranch_root_my (dp, READ_LOCK, pep, code);
	if code = 0 then state.parent_locked = "1"b;
	else if code = error_table_$root then code = 0;	/* dep is null but access_mode understands this */
	else call fatal_error;
	pdp = ptr (pep, 0);

	call access_mode$raw (pep, mode, exmode, code);	/* check raw mode on parent for reclassify */
	if code ^= 0 then call fatal_error;
	if (exmode & M_ACCESS) ^= M_ACCESS then do;
	     call dir_control_error$attributes (pep, code);
	     call fatal_error;
	end;

	call audit_success (ep);

	a_pep = pep;
	a_ep = ep;
	a_code = code;
	return;
%page;
obj_status_attributes_read: entry (a_dirname, a_entryname, a_chase_sw, a_ep, a_code);

/* Same as obj_attributes_read except that it returns the code no_s_permission 
if this is the case.  It is used by the status_ and status_long functions. */

	call obj_name_setup;
	state.operation = access_operations_$fs_obj_prop_read;

	lock_for_writing = "0"b;
	dirmode = S_ACCESS;
	chase_sw = a_chase_sw;

	call find_;
	if code ^= 0 then go to RETURN;

	call get_dir_mode (dp, exmode, code);
	if code ^= 0 then call fatal_error;
	if (exmode & dirmode) ^= dirmode then do;
	     if ep -> entry.bs then do;
		call access_mode$effective (ep, mode, exmode, code); /* look for non-null on object */
		if code ^= 0 then call fatal_error;
		if ep -> entry.dirsw then mode = exmode;
		if mode = N_ACCESS then do;
		     call dir_control_error$attributes (ep, code); /* We have no access on object; check access on parent dir for error code. */
		     call fatal_error;
		end;
		else call dir_control_error$status (ep, code); /* audit partial lack of access, return ep anyway */
	     end;
	     else do;
		call dir_control_error$attributes (ep, code); /* link */
		call fatal_error;
	     end;
	end;

	call audit_success (ep);

	a_ep = ep;				/* Success! */
	a_code = code;
	return;
%page;
obj_status_read: entry (a_dirname, a_entryname, a_chase_sw, a_ep, a_code);

/* Returns a pointer to an entry in a locked directory.  These entries are used
when the attributes of an object that are considered as belonging to the 
parent dir (acls, names) are desired.  The access requirements are effective s 
access on the dir for read, m for write. */

	lock_for_writing = "0"b;
	dirmode = S_ACCESS;
	call obj_name_setup;
	state.operation = access_operations_$fs_obj_prop_read;
	go to obj_status_name_join;

obj_status_read_priv: entry (a_dirname, a_entryname, a_chase_sw, a_ep, a_code);

	lock_for_writing = "0"b;
	dirmode = "0"b;
	call obj_name_setup;
	state.operation = access_operations_$fs_obj_prop_read;
	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;
	go to obj_status_name_join;

obj_access_write: entry (a_dirname, a_entryname, a_chase_sw, a_detailed_operation, a_ep, a_code);

	lock_for_writing = "1"b;
	dirmode = M_ACCESS;
	call obj_name_setup;
	state.operation = access_operations_$fs_obj_access_mod;
	addr (state.operation) -> encoded_access_op.detailed_operation = a_detailed_operation;
	go to obj_status_name_join;

obj_access_write_priv: entry (a_dirname, a_entryname, a_chase_sw, a_detailed_operation, a_ep, a_code);

	lock_for_writing = "1"b;
	dirmode = "0"b;
	call obj_name_setup;
	state.operation = access_operations_$fs_obj_access_mod;
	addr (state.operation) -> encoded_access_op.detailed_operation = a_detailed_operation;
	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;
	go to obj_status_name_join;

obj_delete: entry (a_dirname, a_entryname, a_chase_sw, a_ep, a_code);

	lock_for_writing = "1"b;
	dirmode = M_ACCESS;
	call obj_name_setup;
	state.operation = access_operations_$fs_obj_delete;
	go to obj_status_name_join;

obj_status_write: entry (a_dirname, a_entryname, a_chase_sw, a_detailed_operation, a_ep, a_code);

	lock_for_writing = "1"b;
	dirmode = M_ACCESS;
	call obj_name_setup;
	state.operation = access_operations_$fs_obj_status_mod;
	addr (state.operation) -> encoded_access_op.detailed_operation = a_detailed_operation;
	go to obj_status_name_join;

obj_delete_priv: entry (a_dirname, a_entryname, a_chase_sw, a_ep, a_code);

	lock_for_writing = "1"b;
	dirmode = "0"b;
	call obj_name_setup;
	state.operation = access_operations_$fs_obj_delete;
	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;
	go to obj_status_name_join;

obj_status_write_priv: entry (a_dirname, a_entryname, a_chase_sw, a_detailed_operation, a_ep, a_code);

	lock_for_writing = "1"b;
	dirmode = "0"b;
	call obj_name_setup;
	state.operation = access_operations_$fs_obj_status_mod;
	addr (state.operation) -> encoded_access_op.detailed_operation = a_detailed_operation;
	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;

obj_status_name_join:
	chase_sw = a_chase_sw;

	call find_;
	if code ^= 0 then go to RETURN;
	go to obj_status_join;

obj_status_read_ptr: entry (a_segptr, a_ep, a_code);

	lock_for_writing = "0"b;
	dirmode = S_ACCESS;
	call obj_ptr_setup;
	state.operation = access_operations_$fs_obj_prop_read;
	go to obj_status_ptr_join;

obj_status_read_priv_ptr: entry (a_segptr, a_ep, a_code);

	lock_for_writing = "0"b;
	dirmode = "0"b;
	call obj_ptr_setup;
	state.operation = access_operations_$fs_obj_prop_read;
	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;
	go to obj_status_ptr_join;

obj_delete_ptr: entry (a_segptr, a_ep, a_code);

	lock_for_writing = "1"b;
	dirmode = M_ACCESS;
	call obj_ptr_setup;
	state.operation = access_operations_$fs_obj_delete;
	go to obj_status_ptr_join;

obj_status_write_ptr: entry (a_segptr, a_detailed_operation, a_ep, a_code);

	lock_for_writing = "1"b;
	dirmode = M_ACCESS;
	call obj_ptr_setup;
	state.operation = access_operations_$fs_obj_status_mod;
	addr (state.operation) -> encoded_access_op.detailed_operation = a_detailed_operation;
	go to obj_status_ptr_join;

obj_status_write_priv_ptr: entry (a_segptr, a_detailed_operation, a_ep, a_code);

	lock_for_writing = "1"b;
	dirmode = "0"b;
	call obj_ptr_setup;
	state.operation = access_operations_$fs_obj_status_mod;
	addr (state.operation) -> encoded_access_op.detailed_operation = a_detailed_operation;
	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;

obj_status_ptr_join:
	call find_segptr_branch;
	if code ^= 0 then go to SEGPTR_FAILURE;

obj_status_join:
	if dirmode ^= "0"b then do;
	     call get_dir_mode (dp, exmode, code);
	     if code ^= 0 then call fatal_error;
	     if (exmode & dirmode) ^= dirmode then do;
		call dir_control_error$attributes (ep, code);
		call fatal_error;
	     end;
	end;

	call audit_success (ep);

	a_ep = ep;				/* Success! */
	a_code = code;
	return;
%page;
obj_status_read_uid: entry (a_uidpath, a_dirname, a_entryname, a_ep, a_code);

/* Like obj_status_read/write but are given a uid path. */


	lock_for_writing = "0"b;
	dirmode = S_ACCESS;
	unspec (state) = "0"b;
	state.operation = access_operations_$fs_obj_prop_read;
	go to obj_status_uid_join;

obj_status_read_priv_uid: entry (a_uidpath, a_dirname, a_entryname, a_ep, a_code);

	lock_for_writing = "0"b;
	dirmode = "0"b;
	unspec (state) = "0"b;
	state.operation = access_operations_$fs_obj_prop_read;
	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;
	go to obj_status_uid_join;

obj_status_read_raw_uid: entry (a_uidpath, a_dirname, a_entryname, a_ep, a_code);

	lock_for_writing = "0"b;
	dirmode = "0"b;
	unspec (state) = "0"b;
	state.operation = access_operations_$fs_obj_prop_read;
	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;
	state.allow_searching_aim_isolated_dirs = "1"b;


obj_status_uid_join:
	a_ep, ep = null;
	code = 0;
	uidpath = a_uidpath;

	call uid_path_util$find_entry;
	if code = error_table_$root then do;
	     a_dirname = dirname;			/* Return name so far */
	     go to RETURN;
	end;
	if code = error_table_$bad_uidpath then do;
	     if addr (state.event_flags) -> audit_event_flags.priv_op then
		a_dirname = dirname;		/* Return name so far if allowed */
	     go to RETURN;
	end;
	if code ^= 0 then go to RETURN;

	if dirmode ^= "0"b then do;			/* access required? */
	     /*** need to check access to object's parent */
	     call get_dir_mode (dp, exmode, code);
	     if code ^= 0 then call fatal_error;
	     if (exmode & dirmode) ^= dirmode then do;
		/*** not enough on parent, check entry (a dir itself) */
		call access_mode$effective (ep, mode, exmode, code);
		if code ^= 0 then call fatal_error;
		if exmode = "0"b then do;		/* any access would've been OK */
		     call dir_control_error$attributes (ep, code);
		     call fatal_error;
		end;
	     end;
	end;

	call audit_success (ep);

	a_dirname = dirname;
	a_entryname = entryname;
	a_ep = ep;
	a_code = code;
	return;
%page;
obj_delete_uid: entry (a_uidpath, a_dirname, a_entryname, a_ep, a_code);

	lock_for_writing = "1"b;
	dirmode = M_ACCESS;
	unspec (state) = "0"b;
	state.operation = access_operations_$fs_obj_delete;
	goto obj_delete_uid_join;

obj_delete_priv_uid: entry (a_uidpath, a_dirname, a_entryname, a_ep, a_code);

	lock_for_writing = "1"b;
	dirmode = "0"b;
	unspec (state) = "0"b;
	state.operation = access_operations_$fs_obj_delete;
	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;


obj_delete_uid_join:
	a_ep, ep = null;
	code = 0;
	uidpath = a_uidpath;

	call uid_path_util$find_entry;
	if code = error_table_$root then do;
	     a_dirname = dirname;			/* Return name so far */
	     go to RETURN;
	end;
	if code = error_table_$bad_uidpath then do;
	     if addr (state.event_flags) -> audit_event_flags.priv_op then
		a_dirname = dirname;		/* Return name so far if allowed */
	     go to RETURN;
	end;
	if code ^= 0 then go to RETURN;

	if dirmode ^= "0"b then do;
	     /*** need to check access to object's parent */
	     call get_dir_mode (dp, exmode, code);
	     if code ^= 0 then call fatal_error;
	     if (exmode & dirmode) ^= dirmode then do;
		call dir_control_error$attributes (ep, code);
		call fatal_error;
	     end;
	end;

	call audit_success (ep);

	a_dirname = dirname;
	a_entryname = entryname;
	a_ep = ep;
	a_code = code;
	return;
%page;
obj_truncate: entry (a_dirname, a_entryname, a_ep, a_code);

/* Returns a ptr to a directory entry when we want to truncate the object at 
hand.  Truncate has its own peculiarities in auditing.  The main access check 
is "w" on the target.  The raw entries ask for raw "w" on the target, as 
opposed to no requirement at all. */

	call obj_name_setup;
	state.operation = access_operations_$fs_obj_contents_mod;
	addr (state.operation) -> encoded_access_op.detailed_operation = FS_OBJ_TRUNCATE;

	lock_for_writing = "1"b;
	chase_sw = DC_FIND_CHASE;

	call find_;
	if code ^= 0 then go to RETURN;

	call access_mode$effective (ep, mode, exmode, code);
	if code ^= 0 then call fatal_error;
	go to obj_truncate_join;

obj_truncate_ptr: entry (a_segptr, a_ep, a_code);

	call obj_ptr_setup;
	state.operation = access_operations_$fs_obj_contents_mod;
	addr (state.operation) -> encoded_access_op.detailed_operation = FS_OBJ_TRUNCATE;

	lock_for_writing = "1"b;
	call find_segptr_branch;
	if code ^= 0 then go to SEGPTR_FAILURE;

	call fs_modes$locked (segptr, mode, exmode, ringbr, code);
	if code ^= 0 then call fatal_error;
	go to obj_truncate_join;

obj_truncate_raw_ptr: entry (a_segptr, a_ep, a_code);

	call obj_ptr_setup;
	state.operation = access_operations_$fs_obj_contents_mod;
	addr (state.operation) -> encoded_access_op.detailed_operation = FS_OBJ_TRUNCATE;
	addr (state.event_flags) -> audit_event_flags.priv_op = "1"b;

	lock_for_writing = "1"b;
	call find_segptr_branch;
	if code ^= 0 then go to SEGPTR_FAILURE;

	call access_mode$raw (ep, mode, exmode, code);
	if code ^= 0 then call fatal_error;

obj_truncate_join:
	objmode = W_ACCESS;
	if (mode & objmode) ^= objmode then do;
	     if ep -> entry.copysw then call dir_control_error$contents_info (ep, code); /* don't audit; user can make a copy to truncate */
	     else call dir_control_error$contents (ep, code);
	     if ep -> entry.dirsw then		/* MSF? */
		if code = error_table_$moderr then code = error_table_$dirseg;
	     call fatal_error;
	end;

	call audit_success (ep);

	a_ep = ep;
	a_code = code;
	return;
%page;
obj_volume_retrieve: entry (a_dirname, a_entryname, a_audit_user_info_ptr, a_ep, a_code);

/* Follows the unique access checks pertenant to the volume retriever. */

	call obj_name_setup;
	state.operation = access_operations_$fs_obj_contents_mod;
	addr (state.operation) -> encoded_access_op.detailed_operation = FS_OBJ_VOLUME_RETRIEVE;

	state.for_user = "1"b;
	state.user = a_audit_user_info_ptr -> audit_user_info;

	lock_for_writing = "0"b;
	chase_sw = DC_FIND_NO_CHASE;

	call find_;				/* modifying object contents, not entry */
	if code ^= 0 then go to RETURN;

	call access_mode$user_effmode (ep, state.user_id, state.authorization, (state.ring), mode, exmode, code);
	if code ^= 0 then call fatal_error;
	if ep -> entry.dirsw then do;
	     mode = exmode;
	     objmode = SM_ACCESS;
	end;
	else objmode = RW_ACCESS;
	if (mode & objmode) ^= objmode then do;		/* look at parent's mode */
	     call sum$getbranch (dp, READ_LOCK, pep, code);
	     if code ^= 0 then call fatal_error;
	     pdp = ptr (pep, 0);
	     state.parent_locked = "1"b;

	     call access_mode$user_effmode (pep, state.user_id, state.authorization, (state.ring), mode, exmode, code);
	     call lock$dir_unlock (pdp);		/* done with parent */
	     state.parent_locked = "0"b;
	     if code ^= 0 then call fatal_error;
	     if (exmode & SM_ACCESS) ^= SM_ACCESS then do;
		call dir_control_error$contents (ep, code);
		call fatal_error;
	     end;
	end;

	call audit_success (ep);

	a_ep = ep;
	a_code = code;
	return;
%page;
seg_fault: entry (a_kstep, a_ep, a_code);

/* Compute the sdw access fields and generate an error if the process has
null authorization access to the segment.  This is used by seg_fault.
The finding of the directory entry pointer is done in seg_fault so as to 
minimize the number of stack frames pushed when recursive seg faults are 
taken referencing the parent dir. */

	unspec (state) = "0"b;
	state.operation = access_operations_$fs_obj_contents_read;

	code = 0;
	kstep = a_kstep;
	ep = a_ep;

	if ep = null then do;
	     code = error_table_$seg_deleted;
	     call dir_control_error$name_non_existant (ptr (kstep -> kste.entryp, 0), code);
	     go to RETURN;
	end;

	if ep -> entry.dirsw then go to RETURN;		/* dir access is special cased in seg_fault */

	if kstep -> kste.dtbm ^= ep -> entry.dtem then	/* entry change, recompute access */
	     call update_kste_access (kstep, ep, mode);
	else mode = kstep -> kste.access;		/* else kste mode is good (possibly from a previous fs_modes call) */

	if mode = "0"b then do;
	     call dir_control_error$contents (ep, code);
	     go to RETURN;
	end;

	call sdw_util_$dissect (addr (dseg$ (kstep -> kste.segno)), addr (sdwi)); /* Take it apart to set access */

	if (mode & W_ACCESS) then do;
	     state.operation = access_operations_$fs_obj_contents_mod;
	     addr (state.operation) -> encoded_access_op.detailed_operation = FS_OBJ_CONNECT;
	end;

	if mode ^= string (sdwi.access) |
	     sdwi.r1 ^= ep -> entry.ring_brackets (1) |
	     sdwi.r2 ^= ep -> entry.ring_brackets (2) |
	     sdwi.r3 ^= ep -> entry.ring_brackets (3) then call audit_success (ep);

	sdwi.r1 = ep -> entry.ring_brackets (1);	/* Rings and access mode from the branch */
	sdwi.r2 = ep -> entry.ring_brackets (2);
	sdwi.r3 = ep -> entry.ring_brackets (3);

	string (sdwi.access) = substr (mode, 1, 4);
	if ^kstep -> kste.allow_write then sdwi.write = "0"b; /* Don't allow write access, no way */

	call sdw_util_$construct (addr (dseg$ (kstep -> kste.segno)), addr (sdwi)); /* Put it back together */

	a_code = code;
	return;
%page;
dir_name_setup: proc;

	unspec (state) = "0"b;
	a_dp, dp = null;
	code = 0;
	dirname = rtrim (a_dirname);
	return;
     end;

fatal_error: proc;

	if state.parent_parent_locked then call lock$dir_unlock (ppdp);
	if state.parent_locked then call lock$dir_unlock (pdp);
	if state.dir_locked then call lock$dir_unlock (dp);
	if state.dir_held then call segno_usage$decrement (segno (dp), (0));
	go to RETURN;
     end fatal_error;

obj_name_setup: proc;

	unspec (state) = "0"b;
	a_ep, ep = null;
	code = 0;
	dirname = rtrim (a_dirname);
	entryname = a_entryname;
	return;
     end;

obj_ptr_setup: proc;

	unspec (state) = "0"b;
	a_ep, ep = null;
	code = 0;
	segptr = a_segptr;
	return;
     end;
%page;
SEGPTR_FAILURE:
	if code = error_table_$seg_deleted then do;
	     call get_kstep (segno (segptr), kstep, code);
	     if code = 0 then do;
		state.operation = access_operations_$fs_obj_contents_read; /* audit failure as attempt to read names */
		code = error_table_$seg_deleted;
		call dir_control_error$name_non_existant (ptr (kstep -> kste.entryp, 0), code);
	     end;
	end;

RETURN:	a_code = code;
	return;
%page;
audit_success$msg: proc (a_ep, a_message);

dcl  a_ep				ptr parameter;
dcl  a_message			char (32) aligned parameter;

dcl  audit			bit (1) aligned;
dcl  ep				ptr;
dcl  message			char (32);

	addr (state.event_flags) -> audit_event_flags.grant = "1"b;
	message = a_message;
	go to check_audit;

audit_success: entry (a_ep);

	addr (state.event_flags) -> audit_event_flags.grant = "1"b;

audit_failure: entry (a_ep);

	message = "";
check_audit:
	ep = a_ep;
	if state.for_user then audit =
		access_audit_check_ep_$user (state.event_flags, state.operation, ep, state.user.authorization, state.user.audit_flags);
	else audit =
		access_audit_check_ep_$self (state.event_flags, state.operation, ep);
	if audit then
	     if state.for_user then
		call access_audit_$log_entry_ptr_user (ME, (state.ring), state.event_flags, state.operation, ep, code, null, 0, addr (state.user), message);
	     else call access_audit_$log_entry_ptr (ME, level$get (), state.event_flags, state.operation, ep, code, null, 0, message);
	return;
     end;
%page;
dir_control_error: proc;

/* Original version written by Kobziar (July 74) */

dcl  a_dp				ptr parameter;
dcl  a_ep				ptr parameter;
dcl  a_code			fixed bin (35) parameter;

dcl  code				fixed bin (35);
dcl  dp				ptr;
dcl  ep				ptr;
dcl  exmode			bit (36) aligned;
dcl  info_only			bit (1) aligned;	/* TRUE iff info entry called */
dcl  locked			bit (1) aligned;
dcl  mode				bit (36) aligned;
dcl  original_code			fixed bin (35);
dcl  pep				ptr;
%page;
dir_control_error$append: entry (a_ep, a_code);

/* Used for appending into a dir.  The only access consideration is on the dir
itself, since asking to append inside a dir is like asking for the names of
objects in the dir; we can not let the user know of the existance of objects
in a dir to which he has no access. */

	info_only = "0"b;

	ep = a_ep;				/* entry for dir being appended into */
	if ep = null then code = error_table_$incorrect_access; /* something wrong here */
	else do;
	     call get_mode_on_entry (ep);
	     if (exmode ^= N_ACCESS) then code = error_table_$incorrect_access; /* user has some access on dir, 
						hence can know of no access (=> not namedup) */
	     else code = error_table_$no_info;		/* no access on dir */
	end;
	go to return_error_code;
%page;
dir_control_error$attributes_info: entry (a_ep, a_code);
	info_only = "1"b;
	go to attributes_entry;

dir_control_error$attributes: entry (a_ep, a_code);
	info_only = "0"b;

/* These entries are called when we had insufficient access to examine/change 
the attributes of an object. */

attributes_entry:
	ep = a_ep;				/* copy entry pointer */
	if ep = null then code = error_table_$incorrect_access; /* if entry is the root */
	else do;

/* Check access on parent */

	     dp = ptr (ep, 0);			/* get ptr to directory */
	     call get_mode_on_dir (dp);
	     if (exmode ^= N_ACCESS) then code = error_table_$incorrect_access; /* user has some access on parent but apparently not enough */
	     else do;
		if ep -> entry.bs = "1"b then do;
		     call get_mode_on_entry (ep);	/* access on entry allows user to see entry */
		     if code ^= 0 then go to return_error_code_no_audit;

		     if ep -> entry.dirsw then mode = exmode; /* if a directory, look at the extended access */

		     if mode ^= N_ACCESS then code = error_table_$incorrect_access; /* user has some access on object but not enough */
		     else code = error_table_$no_info;
		end;
		else code = error_table_$no_info;	/* link */
	     end;
	end;
	go to return_error_code;
%page;
dir_control_error$contents_info: entry (a_ep, a_code);	/* Entry does not result in an auditing message */
	info_only = "1"b;
	go to contents_entry;

dir_control_error$contents: entry (a_ep, a_code);
	info_only = "0"b;

/* Entries called with an ep for an object whose contents in which we were
interested. */

contents_entry:
	ep = a_ep;				/* copy entry pointer */
	if rel (ep) = "0"b then code = error_table_$no_info; /* argument should always point to a directory entry */
	else if ep = null then code = error_table_$moderr;/* if entry represents the root */
	else if ep -> entry.bs = "0"b then code = error_table_$no_info; /* if passed a pointer to a link entry */
	else do;

/* check access of entry */

	     call get_mode_on_entry (ep);
	     if code ^= 0 then go to return_error_code_no_audit;

	     if ep -> entry.dirsw then mode = exmode;	/* if a directory, look at the extended access */

	     if mode ^= N_ACCESS then code = error_table_$moderr; /* user has some access but not apparently what was needed */
	     else do;

/* otherwise look at access on parent */

		dp = ptr (ep, 0);			/* get ptr to directory */
		call get_mode_on_dir (dp);
		if (exmode ^= N_ACCESS) then code = error_table_$moderr; /* return moderr if user has non-null access on parent */
		else code = error_table_$no_info;	/* return no_info if user has null access on parent */
	     end;
	end;
	go to return_error_code;
%page;
dir_control_error$name_existant: entry (a_ep, a_code);

/* This entry is called when a user tries to look up a name which isn't what's
desired.  We have to see if the user is allowed to know this.  The argument is
an entry ptr to the entry of the wrong type.  If the user is allowed to see 
the name non-existance, we return the input code.  Otherwise, we return 
no_info.

Audit when user couldn't see object.  One reason for this is because we
can't keep dirs from entering the address space and we want to audit attempts
to try directory names.  */

	original_code = a_code;
	code = 0;					/* clear error code */
	ep = a_ep;
	dp = ptr (ep, 0);
	if ep = null then code = original_code;		/* root? */
	else do;
	     call get_mode_on_dir (dp);
	     if (exmode ^= N_ACCESS) then code = original_code; /* user has some access on dir */
	     else do;
		if ep -> entry.bs then do;		/* see if user has access (can see) object */
		     call get_mode_on_entry (ep);
		     if code ^= 0 then go to return_error_code_no_audit;

		     if ep -> entry.dirsw then mode = exmode;
		     if (mode ^= N_ACCESS) then code = original_code;
		     else code = error_table_$no_info;
		end;
		else code = error_table_$no_info;
	     end;
	end;
	if code = error_table_$no_info then call audit_failure (ep);
	go to return_error_code_no_audit;
%page;
dir_control_error$name_non_existant: entry (a_dp, a_code);

/* This entry is called when a user tries to look up a name which isn't found.
We have to see if the user is allowed to know this.  The argument is a ptr
to a directory in which the name wasn't found.  If the user is allowed to see 
the name non-existance, we return the input code.  Otherwise, we return 
no_info.

Audit when user couldn't see object.  One reason for this is because we
can't keep dirs from entering the address space and we want to audit attempts
to try directory names.  */

	original_code = a_code;
	code = 0;					/* clear error code */
	dp = a_dp;

	locked = "0"b;
	pep = null;
	call sum$getbranch_root_my (dp, READ_LOCK, pep, code); /* needed for auditing */
	if code = 0 then locked = "1"b;
	else if code = error_table_$root | code = error_table_$mylock then ;
	else go to return_error_code_no_audit;

	call get_mode_on_entry (pep);
	if (exmode ^= N_ACCESS) then code = original_code;/* user has some access on dir */
	else code = error_table_$no_info;

	if code = error_table_$no_info then call audit_failure (pep);

	if locked then call lock$dir_unlock (ptr (pep, 0));
	go to return_error_code_no_audit;
%page;
dir_control_error$status: entry (a_ep, a_code);

/* This entry is called when the user had non-null access on an object but did
not have s permission on the parent.  It is only called when this circumstance
causes us to return some, but not all, information the user requested.  In this
case, we know what error to flag.  We simply audit and return 
no_s_permission. */

	info_only = "0"b;				/* For real */
	ep = a_ep;				/* copy argument */
	if ep = null then code = error_table_$incorrect_access; /* if entry is the root */
	else code = error_table_$no_s_permission;	/* branch - caller knows we have some access but not access on dir */
	go to return_error_code;
%page;
return_error_code:
	if ^info_only then				/* If a real violation */
	     call audit_failure (ep);

return_error_code_no_audit:
	a_code = code;
	return;
%page;
get_mode_on_dir: proc (a_dp);

dcl  a_dp				ptr parameter;

dcl  dp				ptr;
dcl  locked			bit (1) aligned;
dcl  pdp				ptr;
dcl  pep				ptr;

	     dp = a_dp;
	     if state.for_user then do;		/* need to get pep to figure out access */
		locked = "1"b;			/* set lock indicator on */
		call sum$getbranch_root_my (dp, READ_LOCK, pep, code); /* get pointer to parent directory */
		if code ^= 0 then			/* turn off lock indicator */
		     if code = error_table_$root | code = error_table_$mylock then do;
			locked = "0"b;		/* if already locked by us */
			code = 0;
		     end;
		     else go to return_error_code_no_audit;

		pdp = ptr (pep, 0);			/* get pointer to parent of parent */
		call get_mode_on_entry (pep);		/* look at the access on parent directory */
		if locked then call lock$dir_unlock (pdp);
		if code ^= 0 then go to return_error_code_no_audit;
	     end;
	     else call get_dir_mode (dp, exmode, code);	/* easier to get mode for caller than someone else */
	     return;
	end get_mode_on_dir;

get_mode_on_entry: proc (a_ep);

dcl  a_ep				ptr parameter;

dcl  ep				ptr;

	     ep = a_ep;
	     if state.for_user then call access_mode$user_effmode (ep, state.user_id, state.authorization, (state.ring), mode, exmode, code);
	     else call access_mode$effective (ep, mode, exmode, code); /* get mode and extended mode of entry */
	     return;
	end get_mode_on_entry;
     end dir_control_error;
%page;
find_: proc;

/* Original version written by R. Bratt (October 1974). */

/* This program returns a pointer to a directory entry in a specified 
directory.  It returns with the directory locked.  a_ep is non-null only for 
success; the code will be zero in this case.

The append entries return a pointer to a locked directory in which and entry
is to be appended.  These entries basically just ensure that the named object
doesn't exist.
*/

dcl  find_type			bit (4) aligned;	/* type of object (or nothing) acceptable to find */
dcl  links			fixed bin;

	code = 0;
	ep, dp = null ();
	call setup ();

	if chase_sw = DC_FIND_NO_CHASE then do;
	     call find_locked_dir;
	     if code ^= 0 then call abort;

	     call find_entry (dp, entryname, FIND_OBJECT_OR_LINK, ep, code);
	     if code ^= 0 then call abort;
	     return;
	end;
	else do;
	     find_type = FIND_OBJECT_OR_LINK;
	     call find_chasing_link;
	     do links = 1 to active_all_rings_data$maxlinks while (code = error_table_$link);
		call split_pathname ();
		call find_chasing_link;
	     end;

	     if code = error_table_$link then code = error_table_$toomanylinks;
	     if code ^= 0 then call abort;
	     return;
	end;
%page;
find_$append: entry;

/* This entry checks that the pathname supplied does not exist. */

	code = 0;
	dp = null ();
	call setup ();

	if chase_sw = DC_FIND_NO_CHASE then do;
	     call find_locked_dir;
	     if code ^= 0 then call abort;

	     call find_entry (dp, entryname, FIND_NOTHING, ep, code);
	     if code ^= 0 then call abort;
	     return;
	end;
	else do;

/* This entry makes sure that the final target doesn't exist.  It returns
a pointer to the final target dir and the updated pathname of the link
target. */

	     find_type = FIND_LINK_OR_NOTHING;
	     call find_chasing_link;
	     do links = 1 to active_all_rings_data$maxlinks while (code = error_table_$link);
		call split_pathname ();
		call find_chasing_link;
	     end;

	     if code = error_table_$link then code = error_table_$toomanylinks;
	     if code ^= 0 then call abort;
	     return;
	end;
%page;
find_$link_target: entry;

/* This entry finds the target of the specified link, whether existant or not.
It returns this final path. */

	code = 0;
	ep, dp = null ();
	call setup ();

	find_type = FIND_ALL;
	call find_chasing_link;
	do links = 1 to active_all_rings_data$maxlinks while (code = error_table_$link);
	     call split_pathname ();
	     call find_chasing_link;
	end;

	if code = error_table_$link then code = error_table_$toomanylinks;
	if code ^= 0 then call abort;
	return;
%page;
find_chasing_link: proc;

	     call find_locked_dir;
	     if code ^= 0 then call abort;

	     call find_entry (dp, entryname, find_type, ep, code);
	     if code ^= 0 then call abort;

	     if ep ^= null then
		if ^ep -> entry.bs then do;		/* link */
		     dirname = substr (ep -> link.pathname, 1, ep -> link.pathname_size);
		     code = error_table_$link;
		     call lock$dir_unlock (dp);
		     state.dir_locked = "0"b;
		     call segno_usage$decrement (segno (dp), (0));
		     state.dir_held = "0"b;
		end;
	     return;
	end find_chasing_link;
%page;
setup:	proc;
	     if entryname = "" then call split_pathname ();
	     return;
	end setup;

split_pathname: proc;

dcl  ename_len			fixed bin (17);
dcl  path_len			fixed bin (17);

	     if dirname = ">" then do;
		code = error_table_$root;
		call abort;
	     end;
	     ename_len = index (reverse (dirname), ">") - 1;
	     if ename_len < 1 then do;
		code = error_table_$badpath;
		call abort;
	     end;
	     if ename_len > 32 then do;
		code = error_table_$entlong;
		call abort;
	     end;
	     path_len = length (dirname) - ename_len - 1;
	     entryname = substr (dirname, path_len + 2, ename_len);
	     dirname = substr (dirname, 1, max (path_len, 1));
	     return;
	end split_pathname;

abort:	proc;

	     if state.dir_locked then do;
		call lock$dir_unlock (dp);
		state.dir_locked = "0"b;
	     end;
	     if state.dir_held then do;
		call segno_usage$decrement (segno (dp), (0));
		state.dir_held = "0"b;
	     end;
	     go to non_local_return;
	end abort;

non_local_return:
	return;
     end find_;
%page;
find_dir: proc;

/* Original version (find_dirsegno) written by R. Bratt (September 1974) */

/* find_dir resolves a directory pathname into a directory pointer.
   It initiates any directories which are in the path but unknown to the 
   process.  On exit only the target directory is marked as in use.

The operation of this program is as follows:

We maintain the pathname of the directory we want to find (and initiate) in
substr (work_pathname.string, 1, work_pathname.parent_len + work_pathname.son_len).

We start by walking up the hierarchy from the last directory in the path 
looking for one whose segno is known.  This will either be because we find it 
in the PAM, or because we hit the root (which can be implicitly made known).
The amount of the original pathname that we examing in this walk up is
substr (work_pathname.string, 1, work_pathname.parent_len).

When we find this segno, we can walk back down the hierarchy, making each
subordinate directory known.  As we make a subordinate directory known, we free
up its parent.  Eventually we find what we want.

If we encounter a link, we substitute the portion of the pathname that this 
link is with the target path of the link.  We then restart the search given
this new "expanded" pathname. */

/* Based */

dcl  parent_path			char (work_pathname.parent_len) aligned based (addr (work_pathname.string)); /* based form of working path */
dcl  parent_path_var		char (work_pathname.parent_len) aligned var based (addr (work_pathname.parent_len));
dcl  son_path			char (work_pathname.son_len) based (addcharno (addr (work_pathname.string), work_pathname.parent_len));
						/* This describes the characters after the parent path
					(path that has been found).  This describes ">" || entryname of the next
					dir (and any chars that follows). */
dcl  1 work_pathname		aligned based (state.work_pathname_ptr), /* work area for path expansion and name stripping (concealing) */
       2 parent_len			fixed bin (21),	/* this field makes the characters that follow look like a var string 
- this is how many chars we are currently examining */
       2 string			char (2048),	/* more than enough for... */
       2 son_len			fixed bin (21);	/* number of chars in string following parent chars */

/* Variables */

dcl  authorization			bit (72) aligned;
dcl  entry			char (32) aligned;
dcl  entry_len			fixed bin (21);
dcl  ep				ptr;
dcl  new_son_ptr			ptr;		/* after relocation after link */
dcl  numlinks			fixed bin;
dcl  old_son_ptr			ptr;		/* to str of son */
dcl  segnum			fixed bin (17);	/* segno of directory currently held */
dcl  son_segnum			fixed bin (17);	/* new dir being made active */
dcl  sub_path_len			fixed bin (21);	/* after stripping an entryname */
%page;
	code = 0;

/* work_pathname is not kept as an automatic area to minimize stack frame
size during certain ptr based calls.  We grow the stack frame big 
enough for work_pathname only when we need to. */

	if ^state.find_dir_has_work_area then do;
	     state.work_pathname_ptr = wired_utility_$grow_stack_frame (size (work_pathname));
	     state.find_dir_has_work_area = "1"b;
	end;

	if state.for_user then authorization = state.user.authorization;
	else authorization = pds$access_authorization;

	work_pathname.son_len = 0;
	work_pathname.parent_len = length (dirname);
	substr (work_pathname.string, 1, work_pathname.parent_len) = dirname;

	unspec (my_makeknown_info) = "0"b;
	my_makeknown_info.activate, my_makeknown_info.dirsw, my_makeknown_info.allow_write = "1"b;
	numlinks = 0;

Find_dir: call pathname_am$get_segno (parent_path_var, segnum);
	if segnum > -1 then do;			/* found in PAM */

/* See if this dir (=> any dir in path) aim isolated.  Normally, we would say
that it couldn't be to have made it into the PAM on a previous pass.  But,
real or simulated dir priv in the past could have brought it into our space.
We don't want to allow accessing it any more unless privs are still on. */

	     dp = baseptr (segnum);
	     state.dir_held = "1"b;
	     if /* tree */ ^read_allowed_ (authorization, dp -> dir.access_class) then
		if ^addr (authorization) -> aim_template.privileges.dir then /* user lacks dir priv */
		     if ^(state.allow_searching_aim_isolated_dirs | state.allow_aim_isolated_final_dir) then do;
			state.operation = access_operations_$fs_obj_contents_read;
			call sum$getbranch (dp, READ_LOCK, pep, code);
			if code ^= 0 then go to abort;
			pdp = ptr (pep, 0);
			call dir_control_error$attributes (pep, code);
			call lock$dir_unlock (pdp);
			go to abort;
		     end;

	     go to find_dir_return;
	end;

	if parent_path_var = ">" then do;
	     call activate_root;
	     dp = baseptr (segnum);
	     state.dir_held = "1"b;
	     go to find_dir_return;			/* Everyone can see root */
	end;

/* We must split the pathname and start walking up the hierarchy, until we
find a PAM match or hit the root. */

	do while (segnum < 0);			/* walk down until we find the segno for some dir in path */

/* Adjust working_length to split off entryname */

	     sub_path_len = work_pathname.parent_len - index (reverse (parent_path), ">");
	     if sub_path_len = 0 then ;		/* directory right off root */
	     else if sub_path_len >= work_pathname.parent_len - 1 then do;
		code = error_table_$badpath;		/* no ">" or last char is ">" */
		go to abort;
	     end;
	     work_pathname.son_len = work_pathname.son_len + (work_pathname.parent_len - sub_path_len); /* add last entryname found to son half of string */
	     work_pathname.parent_len = sub_path_len;

/* Try to find dir */

	     if work_pathname.parent_len = 0 then call activate_root; /* root */
	     else call pathname_am$get_segno (parent_path_var, segnum); /* marks segno as held if segno returned */
	end;
	dp = baseptr (segnum);
	state.dir_held = "1"b;

/* Now we walk back down the hierarchy, finding the sub-ordinate dirs to the 
one found above. */

	do while (work_pathname.son_len > 0);
	     entry_len = index (substr (son_path, 2), ">"); /* add the next entry back to the parent half of string */
	     if entry_len = 0 then entry_len = work_pathname.son_len - 1; /* last entryname in path */
	     else entry_len = entry_len - 1;		/* remove ">" */
	     if entry_len > 32 then do;
		code = error_table_$entlong;
		go to abort;
	     end;
	     entry = substr (son_path, 2, entry_len);
	     work_pathname.son_len = work_pathname.son_len - (entry_len + 1);
	     work_pathname.parent_len = work_pathname.parent_len + (entry_len + 1); /* add in entryname we're about to find */

	     call lock$dir_lock_read (dp, code);
	     if code ^= 0 then go to abort;
	     state.dir_locked = "1"b;

	     call find_entry (dp, entry, FIND_DIR_OR_LINK, ep, code);
	     if code ^= 0 then go to abort;

	     if ^ep -> entry.bs then do;		/* link */

/* We substitute the pathname resolved so far with the link pathname and start
all over. */

		numlinks = numlinks + 1;
		if ep -> link.pathname_size + work_pathname.son_len > length (work_pathname.string) |
		     numlinks > active_all_rings_data$maxlinks then do;
		     code = error_table_$toomanylinks;
		     go to abort;
		end;
		old_son_ptr = addcharno (addr (work_pathname.string), work_pathname.parent_len); /* move son portion down */
		new_son_ptr = addr (work_pathname.string); /* avoid compiler bug */
		new_son_ptr = addcharno (new_son_ptr, ep -> link.pathname_size);
		if work_pathname.parent_len < ep -> link.pathname_size then
		     call mrl_ (old_son_ptr, work_pathname.son_len, new_son_ptr, work_pathname.son_len); /* moving to the right */
		else call mlr_ (old_son_ptr, work_pathname.son_len, new_son_ptr, work_pathname.son_len); /* moving to the left */
		substr (work_pathname.string, 1, ep -> link.pathname_size) = substr (ep -> link.pathname, 1, ep -> link.pathname_size); /* insert link as new parent */
		work_pathname.parent_len = work_pathname.son_len + ep -> link.pathname_size; /* make whole string parent, start over */
		work_pathname.son_len = 0;
		dirname = parent_path;		/* update dirname, disregard truncation */
		call lock$dir_unlock (dp);		/* release dir holding link */
		state.dir_locked = "0"b;
		call segno_usage$decrement (segnum, (0));
		state.dir_held = "0"b;
		go to Find_dir;			/* must start from scratch */
	     end;

	     if /* tree */ ^read_allowed_ (authorization, ep -> entry.access_class) then /* dir aim protected */
		if ^addr (authorization) -> aim_template.privileges.dir then /* user lacks dir priv */
		     if ^state.allow_searching_aim_isolated_dirs then
			if ^(work_pathname.son_len = 0 & state.allow_aim_isolated_final_dir) then do;
			     state.operation = access_operations_$fs_obj_contents_read;
			     call dir_control_error$attributes (ep, code);
			     go to abort;
			end;

	     my_makeknown_info.entryp = ep;
	     my_makeknown_info.uid = ep -> entry.uid;
	     call makeknown_ (addr (my_makeknown_info), son_segnum, (0), code);
	     if code ^= 0 then
		if code ^= error_table_$segknown then go to abort;
	     call lock$dir_unlock (dp);		/* dir is locked during makeknown_ activate call */
	     state.dir_locked = "0"b;
	     call segno_usage$decrement (segnum, (0));	/* parent will be held by son */
	     segnum = son_segnum;			/* makeknown made dir held */
	     dp = baseptr (segnum);
	     call pathname_am$set (parent_path_var, segnum); /* remember this after all we had to do to find it */
	end;

find_dir_return:
	code = 0;
	return;

abort:	if state.dir_locked then do;
	     call lock$dir_unlock (dp);
	     state.dir_locked = "0"b;
	end;
	if state.dir_held then do;
	     call segno_usage$decrement (segnum, (0));
	     state.dir_held = "0"b;
	end;
	return;

activate_root: proc;

	     my_makeknown_info.uid = "777777777777"b3;
	     my_makeknown_info.entryp = null;
	     call makeknown_ (addr (my_makeknown_info), segnum, (0), code); /* marks segno as held */
	     if code ^= 0 then
		if code ^= error_table_$segknown then go to abort;
	     return;
	end activate_root;
     end find_dir;
%page;
find_entry: proc (a_dp, a_ename, a_type, a_ep, a_code);

/* Original version written by R. Bratt (September 1974) */

/* find_entry provides entries for finding a directory entry of
   a certain type given the segment number of the parent directory and
   the name of the desired entry (and its desired type).  Code will be zero
   only if an object of the desired type was found.  ep will be non-null
   only if the found object is existant. */

dcl  a_code			fixed bin (35) parameter;
dcl  a_dp				ptr parameter;
dcl  a_ename			char (32) aligned parameter;
dcl  a_ep				ptr parameter;
dcl  a_type			bit (4) aligned parameter;

dcl  authorization			bit (72) aligned;
dcl  code				fixed bin (35);
dcl  dp				ptr;
dcl  ep				ptr;
dcl  type				bit (4) aligned;
%page;
	a_code = 0;
	a_ep = null;
	dp = a_dp;
	type = a_type;

	if state.for_user then authorization = state.user.authorization;
	else authorization = pds$access_authorization;

	call hash$search (dp, addr (a_ename), ep, code);
	if code ^= 0 then do;
	     if code ^= error_table_$noentry then go to abort;
	     if (type & FIND_NOTHING) then do;
		code = 0;				/* user got what he wanted */
		return;
	     end;
	     if (type & FIND_SEG) then code = error_table_$noentry; /* if we'd accept a seg, we'd accept anything */
	     else if (type & FIND_DIR) then code = error_table_$no_dir; /* only a dir or link will do */
	     else code = error_table_$not_link;		/* only link would do */
	     state.operation = access_operations_$fs_obj_contents_read; /* audit failure as attempt to read names */
	     call dir_control_error$name_non_existant (dp, code);
	     go to abort;
	end;

/* Found name; make some checks on what's found */

	if ep -> entry.bs then do;
	     if (ep -> entry.dirsw & (ep -> entry.type ^= DIR_TYPE))
		| (^ep -> entry.dirsw & (ep -> entry.type ^= SEG_TYPE))
		| ep -> entry.owner ^= dp -> dir.uid then signal bad_dir_;
	     if ep -> entry.security_oosw & ^addr (authorization) -> privileges.soos then do;
		state.operation = access_operations_$fs_obj_prop_read;
		call dir_control_error$attributes_info (ep, code);
		if code = error_table_$incorrect_access then code = error_table_$oosw;
		go to abort;
	     end;
	     if /* tree */ ep -> entry.dirsw then
		if (type & FIND_DIR) = "0"b then
		     if (type & FIND_NOTHING) then code = error_table_$namedup;
		     else if (type & FIND_SEG) then code = error_table_$dirseg;
			else code = error_table_$not_link; /* only choice left */
		else ;
	     else if (type & FIND_SEG) = "0"b then
		     if (type & FIND_NOTHING) then code = error_table_$namedup;
		     else if (type & FIND_DIR) then code = error_table_$notadir;
			else code = error_table_$not_link; /* only choice left */
		else ;
	end;
	else do;					/* link */
	     if ep -> link.type ^= LINK_TYPE | ep -> link.owner ^= dp -> dir.uid then signal bad_dir_;
	     if (type & FIND_LINK) = "0"b then
		if (type & FIND_NOTHING) then code = error_table_$namedup;
		else code = error_table_$link;
	end;
	if code ^= 0 then do;
	     state.operation = access_operations_$fs_obj_prop_read; /* audit failure as attempt to read names */
	     call dir_control_error$name_existant (ep, code);
	     go to abort;
	end;

	a_ep = ep;
	return;

abort:	a_code = code;
	return;
     end find_entry;
%page;
find_locked_dir: proc;

	call find_dir;				/* this makes dir_held */
	if code ^= 0 then return;

	if lock_for_writing then call lock$dir_lock_write (dp, code);
	else call lock$dir_lock_read (dp, code);
	if code ^= 0 then do;
	     call segno_usage$decrement (segno (dp), (0));
	     state.dir_held = "0"b;
	     return;
	end;
	state.dir_locked = "1"b;
	return;
     end;
%page;
find_segptr_branch: proc;

	call sum$getbranch (segptr, lock_for_writing, ep, code);
	if code ^= 0 then return;
	dp = ptr (ep, 0);
	state.dir_locked = "1"b;
	return;
     end;
%page;
get_dir_mode: proc (a_segptr, a_mode, a_code);

/* Find the effective access to the dir, ignoring everything else. */

dcl  a_code			fixed bin (35) parameter;
dcl  a_mode			bit (36) aligned parameter;
dcl  a_segptr			ptr parameter;

dcl  code				fixed bin (35);
dcl  dp				ptr;
dcl  ep				ptr;
dcl  kstep			ptr;
dcl  lock_sw			bit (1) aligned;
dcl  mode				bit (36) aligned;
dcl  need_to_lock			bit (1) aligned;
dcl  rb				(3) fixed bin (3);
dcl  ring				fixed bin (3);
dcl  segptr			ptr;

	need_to_lock = "1"b;
	go to join;

get_dir_mode$locked: entry (a_segptr, a_mode, a_code);

/* Entry to use when parent directory of object that segptr indicates is 
locked. */

	need_to_lock = "0"b;

join:	a_mode = "0"b;
	segptr = a_segptr;

	mode = N_ACCESS;
	call get_kstep (segno (segptr), kstep, code);	/* get kst entry ptr for this seg */
	if code ^= 0 then go to abort;

	if kstep -> kste.uid = (36)"1"b then do;	/* special case the root */
	     lock_sw = "0"b;
	     dp, ep = null;				/* get access to root */
	     if kstep -> kste.dtbm = (36)"1"b then call update_kste_access (kstep, ep, mode);
	     mode = kstep -> kste.extended_access;	/* pick up directory access */
	     rb (1), rb (2), rb (3) = 7;
	end;
	else do;
	     lock_sw = "0"b;

/* lock parent and  get pointer to entry */
	     if need_to_lock then do;
		call sum$getbranch_root_my (segptr, READ_LOCK, ep, code);
		if code = 0 then lock_sw = "1"b;
		else if code = error_table_$mylock then code = 0;
		else go to abort;
	     end;
	     else ep = kstep -> kste.entryp;		/* kste entryp good if dir locked */

	     dp = ptr (ep, 0);			/* get pointer to parent directory */
	     if kstep -> kste.dtbm ^= ep -> entry.dtem then call update_kste_access (kstep, ep, mode);
	     mode = kstep -> kste.extended_access;
	     rb (*) = binary (kstep -> kste.ex_rb (*), 3);/* factor in extended ring brackets */
	     ring = level$get ();
	     if ring <= rb (1) then ;
	     else if ring <= rb (2) then mode = mode & S_ACCESS;
	     else mode = N_ACCESS;
	end;

	if lock_sw then call lock$dir_unlock (dp);
	a_mode = mode;

abort:	a_code = code;
	return;
     end get_dir_mode;
%page;
uid_path_util: proc;

/* Original version written March 1975 by Larry Johnson */

/* Variables */

dcl  authorization			bit (72) aligned;
dcl  current_depth			fixed bin;
dcl  entrysw			bit (1) aligned;
dcl  max_depth			fixed bin;
dcl  segnum			fixed bin;
dcl  son_segnum			fixed bin;

uid_path_util$find_entry: entry;
	entrysw = "1"b;
	go to join;

uid_path_util$find_dir: entry;
	entrysw = "0"b;

join:	ep, dp = null;
	dirname = "";
	entryname = "";
	code = 0;

	if state.for_user then authorization = state.user.authorization;
	else authorization = pds$access_authorization;

	if uidpath (0) ^= "777777777777"b3 then do;	/* All paths must start with root */
	     code = error_table_$bad_uidpath;
	     go to RETURN;
	end;
	do max_depth = 1 to 15 while (uidpath (max_depth));
	end;
	max_depth = max_depth - 1;
	if max_depth = 0 then do;
	     code = error_table_$root;
	     dirname = ">";
	     go to RETURN;
	end;

	unspec (my_makeknown_info) = "0"b;
	my_makeknown_info.dirsw, my_makeknown_info.allow_write,
	     my_makeknown_info.priv_init, my_makeknown_info.activate = "1"b;

	my_makeknown_info.entryp = null;		/* Start with root */
	my_makeknown_info.uid = "777777777777"b3;
	call makeknown_ (addr (my_makeknown_info), segnum, (0), code);
	if code ^= 0 then
	     if code ^= error_table_$segknown then go to abort;
	state.dir_held = "1"b;
	dp = baseptr (segnum);

	if entrysw then max_depth = max_depth - 1;
	if max_depth = 0 then dirname = ">";
	else dirname = "";
	do current_depth = 1 to max_depth;		/* Step down path */
	     call find_uid (uidpath (current_depth), READ_LOCK);

	     dirname = dirname || ">";
	     dirname = dirname || rtrim (entryname);

	     if /* tree */ ^read_allowed_ (authorization, ep -> entry.access_class) then /* dir aim protected */
		if ^addr (authorization) -> aim_template.privileges.dir then /* user lacks dir priv */
		     if ^state.allow_searching_aim_isolated_dirs then
			if ^(current_depth = max_depth & state.allow_aim_isolated_final_dir) then do;
			     state.operation = access_operations_$fs_obj_contents_read;
			     call dir_control_error$attributes (ep, code);
			     go to abort;
			end;

	     my_makeknown_info.uid = uidpath (current_depth);
	     my_makeknown_info.entryp = ep;
	     call makeknown_ (addr (my_makeknown_info), son_segnum, (0), code);
	     if code ^= 0 then
		if code ^= error_table_$segknown then go to abort;
	     call lock$dir_unlock (dp);		/* dir is kept locked during makeknown_ activate call */
	     state.dir_locked = "0"b;
	     call segno_usage$decrement (segnum, (0));	/* son will hold parent */
	     segnum = son_segnum;
	     dp = baseptr (segnum);
	end;

	if entrysw then call find_uid (uidpath (max_depth + 1), lock_for_writing);

	code = 0;
	return;

abort:	if state.dir_locked then do;
	     call lock$dir_unlock (dp);
	     state.dir_locked = "0"b;
	end;
	if state.dir_held then do;
	     call segno_usage$decrement (segno (dp), (0));
	     state.dir_held = "0"b;
	end;
RETURN:	return;
%page;
find_uid: proc (a_uid, a_typelock);

dcl  a_typelock			bit (36) aligned parameter;
dcl  a_uid			bit (36) aligned parameter;

dcl  ecount			fixed bin;
dcl  nnp				ptr;
dcl  num_entries_in_dir		fixed bin;
dcl  uid				bit (36) aligned;

	     uid = a_uid;

	     if a_typelock then call lock$dir_lock_write (dp, code);
	     else call lock$dir_lock_read (dp, code);
	     if code ^= 0 then go to abort;
	     state.dir_locked = "1"b;

	     num_entries_in_dir = dp -> dir.seg_count + dp -> dir.dir_count + dp -> dir.lcount;
	     ecount = 0;
	     do ep = ptr (dp, dp -> dir.entryfrp) repeat (ptr (dp, ep -> entry.efrp)) while (rel (ep));
		ecount = ecount + 1;
		if ecount > num_entries_in_dir then signal bad_dir_;
		if ep -> entry.bs then
		     if ep -> entry.owner ^= dp -> dir.uid then signal bad_dir_;
		     else if ep -> entry.type ^= SEG_TYPE & ep -> entry.type ^= DIR_TYPE then signal bad_dir_;
		     else ;
		else if ep -> link.owner ^= dp -> dir.uid then signal bad_dir_;
		else if ep -> link.type ^= LINK_TYPE then signal bad_dir_;
		if ep -> entry.uid = uid then
		     if ep -> entry.bs & ep -> entry.dirsw then do; /* Must be dir branch */
			nnp = addr (ep -> entry.primary_name);
			if nnp -> names.owner ^= ep -> entry.uid
			     | nnp -> names.type ^= NAME_TYPE
			     | nnp -> names.entry_rp ^= rel (ep) then signal bad_dir_;
			entryname = nnp -> names.name;
			return;
		     end;
		     else go to not_found;
	     end;

not_found:     code = error_table_$bad_uidpath;
	     go to abort;
	end find_uid;
     end uid_path_util;
%page; %include access_audit_encoded_op;
%page; %include access_audit_eventflags;
%page; %include access_audit_user_info;
%page; %include access_mode_values;
%page; %include aim_template;
%page; %include dc_find_dcls;
%page; %include dir_entry;
%page; %include dir_header;
%page; %include dir_link;
%page; %include dir_name;
%page; %include fs_obj_access_codes;
%page; %include fs_types;
%page; %include its;
%page; %include kst;
%page; %include makeknown_info;
%page; %include sdw_info;
     end dc_find;
