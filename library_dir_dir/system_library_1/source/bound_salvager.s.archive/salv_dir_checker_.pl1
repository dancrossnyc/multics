/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(86-05-13,GJohnson), approve(86-05-13,MCR7387),
     audit(86-05-13,Martinson), install(86-05-14,MR12.0-1056):
     Correct error message documentation.
  2) change(86-05-22,Lippard), approve(86-06-17,MCR7433),
     audit(86-06-26,Hartogs), install(86-07-11,MR12.0-1091):
     Make ascii_check detect case when name is all blanks, which will
     not hash properly.
                                                   END HISTORY COMMENTS */


/* format: style4,delnl,insnl,tree,ifthenstmt,indnoniterend */
salv_dir_checker_:
     proc (arg_source_ptr, arg_salv_ptr, error, arg_set_security_oosw, arg_new_dir_pages);

/* * This procedure checks the directory for syntatic errors, variation from the information supplied in the branch,
   * and makes plausibility checks on the contents of the information blocks.  If any errors
   * are found while checking the directory, it is rebuilt. The default action can be modified by these flags:
   *
   *	compact			Force a rebuild if at least one page can be saved.
   *	force_rebuild		Force a rebuild of the directory.
   *
   * The following are returned:
   *	new_dir_pages = 0		The directory was not rebuilt.
   *	new_dir_pages > 0		Number of pages in rebuilt directory.
   *
   *	set_security_oosw = "0"b	No AIM errors were detected.
   *	set_security_oosw = "1"b	An AIM error was detected.
   *
   *  AIM checking is only done if a branch was specified.  Protection auditing is done for AIM errors and
   *  change in ACL counts for entries.
   *	- The access class in the branch for the directory is not the same as the access class in the directory header.
   *	- Some branch in the directory has an invalid access class.
   *
   *  All corrections are made after the error message is printed.  The following conventions are used:
   *	SYSTEM	 0	Unexpected errors that indicate software/hardware bugs.
   *	LOSS	 2	Loss of information.
   *	CORRECTION 4	Correctable errors and changes in directory size.
   *	DUMP	 5	Debugging information.  (salvage_directory will dump the directory in the off line case
   *			for these messages.)
   *
   * Constructs used for performance reasons:
   *	- ONES is used as a constant since the copy builtin causes allocates and frees
   *	- The chain threading code is duplicated to prevent the cost of recursion.
*/
/* Written 3/77 by S.E. Barr */
/* Modified 6/77 to remove unreferenced access names after rebuilding directory. */
/* Modified December 1981 by C. Hornig for 205K directories */
/* Modified BIM 2/82 for zero length block protection, directed fault */
/* Modified March 1982 by J. Bongiovanni to eliminate use of FSDCT */
/* Modified 84-12-05 by EJ Sharpe to change protection_audit_ calls to access_audit_ */

/* parameters */

dcl  arg_new_dir_pages fixed bin;			/* Number of pages in rebuilt directory */
dcl  arg_salv_ptr ptr;				/* ptr to information about directory */
dcl  arg_set_security_oosw bit (1) aligned;		/* ON if the branch should be set security out-of-service */
dcl  arg_source_ptr ptr;				/* pointer to directory */
dcl  error entry options (variable);			/* error routine to print messages */

/* automatic */

dcl  audit bit (1) aligned;				/* ON, if have branch, so that audit will make sense */
dcl  branch_ptr ptr;				/* ptr to the branch for this directory */
dcl  check_access_names bit (1) aligned;		/* ON, it should free unused access names from list */
dcl  correct_oosw bit (1) aligned;			/* ON if should put directories back in service. */
dcl  count fixed bin;				/* number of valid blocks on list */
dcl  dir_access_class bit (72) aligned;			/* access class of directory for AIM */
dcl  dir_acl_cnt fixed bin;				/* total number of ACLs for directory */
dcl  dir_name_cnt fixed bin;				/* Value of htused (number of names in directory) */
dcl  dir_size fixed bin;				/* offset of last word in directory */
dcl  dir_uid bit (36) aligned;			/* UID of directory */
dcl  1 event_flags aligned like audit_event_flags;	/* particulars of the operation */
dcl  time bit (36) aligned;				/* Highest value allowed for dates */
dcl  output_area_ptr ptr;				/* ptr to area header in rebuilt directory */
dcl  prodigal_search bit (1) aligned;			/* ON if looking for blocks that can't be reached by chains */
dcl  rebuilding bit (1) aligned;			/* ON if rebuilding directory */
dcl  ring fixed bin;				/* ring number for initial ACLs */
dcl  salv_ptr ptr;					/* ptr to information about the directory */
dcl  scratch_ptr ptr;				/* ptr to scratch segment */
dcl  security_oos bit (1) aligned;			/* ON if directory should be set security out of service */
dcl  source_ptr ptr;				/* ptr to directory being verified */
dcl  stop_at_error bit (1) aligned;			/* ON if rebuild should occur at first uncorrectable error */
dcl  target_ptr ptr;				/* ptr to the new version of the directory */
dcl  trace bit (1) aligned;				/* ON if debugging information should be printed. */

/* based */

dcl  1 block_template aligned based,			/* First two words of all information blocks */
       2 frp bit (18) unaligned,
       2 brp bit (18) unaligned,
       2 type bit (18) unaligned,
       2 size fixed bin (17) unaligned;
dcl  directory_space char (dir_size + 1) aligned based (scratch_ptr);
dcl  1 info aligned like salv_args based (salv_ptr);
dcl  1 input_dir aligned like dir based (source_ptr);	/* original directory */
dcl  1 output_dir aligned like dir based (target_ptr);	/* rebuilt version of the directory */

/* internal static */

dcl  ONES char (1024) aligned int static;
dcl  block_sizes (9) fixed bin int static;
dcl  header_area_size fixed bin int static;		/* number of words in header + area header */
dcl  root_lvid bit (36) int static;
dcl  static_init bit (1) aligned int static init ("0"b);

/* external */

dcl  acc_name_$encode entry (ptr, ptr, fixed bin (35));
dcl  access_audit_$log_obj_class entry options (variable);	/* don't use log_entry_ptr entry for
						   fear of looping on bad dirs */
dcl  access_operations_$fs_obj_set_soos bit (36) aligned external;
dcl  access_operations_$fs_obj_access_mod bit (36) aligned external;
dcl  active_hardcore_data$alloc_sizes (8) ext fixed bin;
dcl  active_hardcore_data$dir_hdrsize ext fixed bin;
dcl  active_hardcore_data$hash_table_sizes (1) ext fixed bin;
dcl  active_hardcore_data$elcsize ext fixed bin;
dcl  active_hardcore_data$aclsize ext fixed bin;
dcl  active_hardcore_data$dir_arearp fixed bin (18) aligned ext;
dcl  active_hardcore_data$ensize ext fixed bin;
dcl  active_hardcore_data$esize ext static fixed bin;
dcl  active_hardcore_data$nalloc_sizes ext fixed bin;
dcl  active_hardcore_data$num_hash_table_sizes fixed bin ext;
dcl  aim_check_$equal entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
dcl  aim_check_$greater_or_equal entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
dcl  allocate_dir_ht_ entry (ptr, fixed bin, fixed bin (35));
dcl  display_access_class_ entry (bit (72) aligned, char (32) aligned);
dcl  fs_alloc$alloc entry (ptr, fixed bin, ptr, fixed bin (35));
dcl  fs_alloc$init entry (ptr, fixed bin, ptr, fixed bin);
dcl  fs_alloc$free entry (ptr, fixed bin, ptr);
dcl  level$get entry () returns (fixed bin);
dcl  pvt$root_lvid bit (36) ext;
dcl  hash$in entry (ptr, ptr, fixed bin (35));
dcl  hash$search entry (ptr, ptr, ptr, fixed bin (35));
dcl  syserr entry options (variable);
dcl  sys_info$access_class_ceiling ext static bit (72) aligned;
dcl  sys_info$default_dir_max_length ext static fixed bin (19);
dcl  salv_data$debugging_fault_dir_checker bit (1) aligned ext static;


dcl  (addr, rel, null, bit, copy, divide, fixed, index, ptr, string, substr, unspec, length, mod, rtrim) builtin;

/* constants */

dcl  BLOCK_NAME (9) char (20) int static options (constant)
	init ("access name", "ACL", "directory header", "directory", "link", "name", "segment", "entry", "hash table");
dcl  CORRECTION fixed bin int static options (constant) init (4);
dcl  DUMP fixed bin int static options (constant) init (5);
dcl  entry_type fixed bin int static options (constant) init (8);
dcl  INVALID_RP bit (18) unal int static options (constant) init ("000001"b3);
dcl  LOSS fixed bin int static options (constant) init (2);
dcl  ME char (17) int static options (constant) init ("salv_dir_checker_");
dcl  SYSTEM fixed bin int static options (constant) init (0);
%page;

	if salv_data$debugging_fault_dir_checker
	then begin;
declare  sfp pointer;
declare  1 sfp_val aligned like its_unsigned;
declare  falter bit (36) aligned based (sfp);

	     sfp_val.pad1 = ""b;
	     sfp_val.segno = 0;
	     sfp_val.ringno = 0;
	     sfp_val.pad2 = ""b;
	     sfp_val.its_mod = "47"b3;		/* Directed Fault 3 */
	     unspec (sfp) = unspec (sfp_val);
	     call syserr (SL_LOG_CRASH, "salv_dir_checker_: Faulting on purpose.");
	     sfp -> falter = "123456"b3;
	end;

	arg_new_dir_pages = 0;
	call setup;
	if valid_header () then do;
	     if ^rebuilding
	     then if info.compact then call check_free_list;
RESTART:
	     call mark_space_used (source_ptr, header_area_size);
	     stop_at_error = ^rebuilding;
	     dir_acl_cnt = 0;
	     if rebuilding then call setup_dir_header;

/* Check access names and check entries */

	     call process_list (input_dir.proj_frp, input_dir.proj_brp, (null), access_name_type, null,
		output_dir.proj_frp, output_dir.proj_brp, count);

	     call process_list (input_dir.pers_frp, input_dir.pers_brp, (null), access_name_type, null,
		output_dir.pers_frp, output_dir.pers_brp, count);

	     call entry_chain;

/* Check initial ACLs for segments and directories for each ring.  (There is no ring 0 initial ACL) */

	     do ring = 1 to 7;
		call process_list (input_dir.seg_frp (ring), input_dir.seg_brp (ring), (null), acle_type, null,
		     output_dir.seg_frp (ring), output_dir.seg_brp (ring), count);
		if count ^= input_dir.iacl_count (ring).seg then do;
		     call error (LOSS, ME, "Segment initial ACL count for ring ^d changed from ^d to ^d", ring,
			input_dir.iacl_count (ring).seg, count);
		     input_dir.iacl_count (ring).seg = count;
		     end;
		if rebuilding then output_dir.iacl_count (ring).seg = count;
		dir_acl_cnt = dir_acl_cnt + count;

		call process_list (input_dir.dir_frp (ring), input_dir.dir_brp (ring), (null), acle_type, null,
		     output_dir.dir_frp (ring), output_dir.dir_brp (ring), count);
		if count ^= input_dir.iacl_count (ring).dir then do;
		     call error (LOSS, ME, "Directory initial ACL count for ring ^d changed from ^d to ^d", ring,
			input_dir.iacl_count (ring).dir, count);
		     input_dir.iacl_count (ring).dir = count;
		     end;
		if rebuilding then output_dir.iacl_count (ring).dir = count;
		dir_acl_cnt = dir_acl_cnt + count;
	     end;
	     if dir_acl_cnt ^= input_dir.acle_total then do;
		call error (LOSS, ME, "ACL count changed from ^d to ^d", input_dir.acle_total, dir_acl_cnt);
		input_dir.acle_total = dir_acl_cnt;
		check_access_names = "1"b;
		end;
	     if rebuilding then do;
		output_dir.acle_total = dir_acl_cnt;	/* Replace kludge by correct value */
		if check_access_names then do;
		     call delete_unused_access_names (output_dir.pers_frp, output_dir.pers_brp);
		     call delete_unused_access_names (output_dir.proj_frp, output_dir.proj_brp);
		     end;
		end;
	     end;

	arg_set_security_oosw = security_oos;
	if rebuilding then call copy_directory;
	return;

START_REBUILD:
	rebuilding = "1"b;
	directory_space = "";
	call mark_space_used (ptr (source_ptr, input_dir.hash_table_rp),
	     (ptr (source_ptr, input_dir.hash_table_rp) -> hash_table.size));
	goto RESTART;
%page;
/* This procedure checks and/or rebuilds the entry chain.  After each entry is verified, its names are checked and
   in the case of segments and directories, the ACL chain is verified.
   At the end of the entry chain, the name count should match the total expected.  If it doesn't, the prodigal search
   is done.  This search checks the space not yet marked used, for valid entry or name blocks.
*/
entry_chain:
     proc;

dcl  back_rp bit (18);				/* back ptr expected */
dcl  dir_cnt fixed bin;				/* number of directoies found */
dcl  entry_rp bit (18);				/* relative pointer to entry block */
dcl  ep ptr;					/* ptr to entry block */
dcl  forward bit (1) aligned;				/* ON for forward loop; OFF for tracing back chain */
dcl  last_good_entry bit (18) unal;
dcl  link_cnt fixed bin;				/* number of links found */
dcl  name_cnt fixed bin;				/* total entry names in the directory */
dcl  seg_cnt fixed bin;				/* number of segments found */

	name_cnt, link_cnt, seg_cnt, dir_cnt = 0;
	forward = "1"b;
	back_rp = "0"b;

/* If the forward thread is zero, but the backward thread is non-zero, then force the forward chain to fail
   to salvage entries using the backward thread.
*/
	entry_rp = input_dir.entryfrp;
	if entry_rp = "0"b
	then if input_dir.entrybrp ^= "0"b then entry_rp = INVALID_RP;

	do while (entry_rp ^= "0"b);
	     ep = ptr (source_ptr, entry_rp);

/* If the block is not valid, then the back chain is used to recover the rest of the entries. */
/* The back chain is not started, if the back pointer specifies the same bad block.
*/
	     if ^valid_block (ep, entry_type, dir_uid, back_rp) then do;
		if trace then call trace_message ("Invalid block found on entry chain", ep);
		if stop_at_error then goto START_REBUILD;
		if ^forward
		then entry_rp = "0"b;
		else do;
		     forward = "0"b;
		     back_rp = INVALID_RP;		/* can't check back ptr while following the chain backward */
		     last_good_entry = entry_rp;
		     if entry_rp = input_dir.entrybrp
		     then entry_rp = "0"b;
		     else entry_rp = input_dir.entrybrp;
		     end;
		end;
	     else do;
		call mark_space_used (ep, 2);		/* Mark threads & size/type used */
		call process_entry (ep);

		if forward then do;
		     back_rp = entry_rp;
		     entry_rp = ep -> entry.efrp;
		     end;
		else do;
		     entry_rp = ep -> entry.ebrp;
		     if entry_rp = last_good_entry then entry_rp = "0"b;
		     end;
		end;
	end;

	if dir_name_cnt ^= name_cnt then do;
	     if stop_at_error then goto START_REBUILD;
	     call prodigal;
	     end;

/* Check and correct totals. */

	if seg_cnt ^= input_dir.seg_count then do;
	     call error (LOSS, ME, "Segment count changed from ^d to ^d", input_dir.seg_count, seg_cnt);
	     input_dir.seg_count = seg_cnt;
	     end;
	if dir_cnt ^= input_dir.dir_count then do;
	     call error (LOSS, ME, "Directory count changed from ^d to ^d", input_dir.dir_count, dir_cnt);
	     input_dir.dir_count = dir_cnt;
	     end;
	if link_cnt ^= input_dir.lcount then do;
	     call error (LOSS, ME, "Link count changed from ^d to ^d", input_dir.lcount, link_cnt);
	     input_dir.lcount = link_cnt;
	     end;

	if name_cnt ^= dir_name_cnt then do;
	     call error (LOSS, ME, "Name count changed from ^d to ^d", dir_name_cnt, name_cnt);
	     end;

	return;
%page;
/* This code checks and rebuilds one entry -- its contents, ACLs and names */
process_entry:
	proc (arg_ep);

dcl  arg_ep ptr;

dcl  ep ptr;
dcl  code fixed bin;
dcl  type_expected fixed bin;
dcl  (auth_valid, bc_auth_valid) bit (1);
dcl  count fixed bin;				/*  count of ACLs or names found on chain */
dcl  new_ep ptr;					/* ptr to entry in rebuilt directory */
	     ep = arg_ep;
	     new_ep = null;
	     type_expected = fixed (ep -> entry.type, 18);
	     call entry_contents;
	     if code ^= 0 then do;
		if trace then call trace_message ("Invalid entry contents", ep);
		return;
		end;

	     call mark_space_used (ep, (ep -> entry.size));

/* If the directory is being rebuilt, the entry is copied into the new directory, and then the name
   and ACL information is cleared.
*/
	     if rebuilding then do;
		call move (ep, output_dir.entryfrp, output_dir.entrybrp, (null), new_ep);
		new_ep -> entry.name_frp, new_ep -> entry.name_brp = "0"b;
		if ep -> entry.bs then new_ep -> entry.acl_frp, new_ep -> entry.acl_brp = "0"b;
		if type_expected = seg_type
		then output_dir.seg_count = output_dir.seg_count + 1;
		else if type_expected = link_type
		     then output_dir.lcount = output_dir.lcount + 1;
		     else if type_expected = dir_type then output_dir.dir_count = output_dir.dir_count + 1;
		end;
	     if type_expected = seg_type
	     then seg_cnt = seg_cnt + 1;
	     else if type_expected = dir_type
		then dir_cnt = dir_cnt + 1;
		else link_cnt = link_cnt + 1;

/* Check name list */
	     if ep -> entry.name_frp ^= rel (addr (ep -> entry.primary_name)) then do;
		if stop_at_error then goto START_REBUILD;
		call error (CORRECTION, ME, "Corrected primary name pointer for ^a", entry_name (ep));
		ep -> entry.name_frp = rel (addr (ep -> entry.primary_name));
		end;
	     call process_list (ep -> entry.name_frp, ep -> entry.name_brp, new_ep, name_type, ep,
		new_ep -> entry.name_frp, new_ep -> entry.name_brp, count);

/* If no names were good, add a unique name. */
	     if count = 0 then do;
		if stop_at_error then goto START_REBUILD;
		call get_unique_name (new_ep);
		count = 1;
		end;

/* Check number of names found against number expected. */

	     if ep -> entry.nnames ^= count then do;
		if stop_at_error then goto START_REBUILD;
		call error (LOSS, ME, "Corrected count of names from ^d to ^d for ^a", ep -> entry.nnames, count,
		     entry_name (new_ep));
		ep -> entry.nnames = count;
		end;
	     if rebuilding then new_ep -> entry.nnames = count;
	     name_cnt = name_cnt + count;

/* Check author */

	     call check_acl_ref (addr (ep -> entry.author), code);
	     auth_valid = (code = 0);
	     if ^auth_valid then do;
		code = 0;
		if stop_at_error then goto START_REBUILD;
		call error (LOSS, ME, "Invalid author found for ^a", entry_name (ep));
		end;

/* Check ACL list and set bc_author for directories and segments */

	     if ep -> entry.bs then do;
		call process_list (ep -> entry.acl_frp, ep -> entry.acl_brp, (null), acle_type, ep,
		     new_ep -> entry.acl_frp, new_ep -> entry.acl_brp, count);
		if ep -> entry.acle_count ^= count then do;
		     if stop_at_error then goto START_REBUILD;
		     call error (LOSS, ME, "Corrected count of ACLs from ^d to ^d for ^a", ep -> entry.acle_count, count,
			addr (ep -> entry.primary_name) -> names.name);
		     if audit
		     then call access_audit_$log_obj_class ("salv_dir_checker_", level$get (), unspec (event_flags),
			     access_operations_$fs_obj_access_mod, ep -> entry.access_class,
			     target (info.pathname, entry_name (ep)), 0, null (), 0,
			     "ACL count changed from ^d to ^d", ep -> entry.acle_count, count);
		     ep -> entry.acle_count = count;
		     end;
		dir_acl_cnt = dir_acl_cnt + count;

		call check_acl_ref (addr (ep -> entry.bc_author), code);
		bc_auth_valid = (code = 0);
		if ^bc_auth_valid then do;
		     code = 0;
		     if stop_at_error then goto START_REBUILD;
		     call error (LOSS, ME, "Invalid bit count author found for ^a", entry_name (ep));
		     end;
		if rebuilding then do;
		     new_ep -> entry.acle_count = count;
		     if bc_auth_valid
		     then call set_acl_ref (addr (ep -> entry.bc_author), addr (new_ep -> entry.bc_author));
		     else call set_acl_ref$damaged (null (), addr (new_ep -> entry.bc_author));
		     end;
		end;

	     if rebuilding
	     then if auth_valid
		then call set_acl_ref (addr (ep -> entry.author), addr (new_ep -> entry.author));
		else call set_acl_ref$damaged (null (), addr (new_ep -> entry.author));
%page;
entry_contents:
	     proc;

		code = 0;

		if ep -> entry.uid = "0"b then do;
		     if stop_at_error then goto START_REBUILD;
		     code = 1;
		     if prodigal_search then return;
		     call error (LOSS, ME, "Deleted ^a ^a with zero UID", BLOCK_NAME (type_expected), entry_name (ep));
		     return;
		     end;

/* Link */
		if type_expected = link_type then do;
		     call ascii_check (addr (ep -> link.pathname), (ep -> link.pathname_size), code);
		     if code ^= 0 then do;
			if stop_at_error then goto START_REBUILD;
			if ^prodigal_search then do;
			     if code = 1
			     then call error (LOSS, ME, "Deleted link ^a with non-ASCII pathname ^a", entry_name (ep),
				     ep -> link.pathname);
			     else call error (LOSS, ME, "Deleted link with blank pathname");
			     end;
			return;
			end;
		     if ep -> entry.bs then do;
			call error (CORRECTION, ME, "Corrected link branch switch for ^a", entry_name (ep));
			ep -> link.bs = "0"b;
			end;
		     call check_dates;
		     return;
		     end;

/* Segments and directories */
/* Print message for out-of-service switch.  Don't reset for online case. */

		if ep -> entry.dirsw & ep -> entry.oosw then do;
		     if correct_oosw then do;
			call error (CORRECTION, ME, "Directory ^a was put back in service", entry_name (ep));
			ep -> entry.oosw = "0"b;
			end;
		     else call error (LOSS, ME, "Directory ^a was found out-of-service", entry_name (ep));
		     end;

		if ^ep -> entry.bs then do;
		     call error (CORRECTION, ME, "Corrected ^a branch switch for ^a", BLOCK_NAME (type_expected),
			entry_name (ep));
		     ep -> entry.bs = "1"b;
		     end;
		if (ep -> entry.dirsw ^= (ep -> entry.type = DIR_TYPE)) then do;
		     call error (CORRECTION, ME, "Corrected directory switch for ^a", entry_name (ep));
		     ep -> entry.dirsw = (type_expected = dir_type);
		     end;
		call check_dates;
		if ^audit then return;		/* Can only check access, if have branch */

/* Multiple class segments are allowed for ring 0 and ring 1 segments only. */

		if ^ep -> entry.dirsw
		then if ep -> entry.multiple_class
		     then if fixed (ep -> entry.ring_brackets (3)) > 1 then do;
			     call error (LOSS, ME,
				"Access error for ^a - invalid ring brackets (^d) for multiple class segment",
				entry_name (ep), ep -> entry.ring_brackets (3));
			     security_oos = "0"b;
			     return;
			     end;

/*  Make sure access class is less than or equal maximum value. */

		if (ep -> entry.access_class & (^sys_info$access_class_ceiling)) = "0"b then do;

/* Multiple class segments and branches must be >= parent.
   Non-multiple class segments and branches must be = parent.
*/
		     if ep -> entry.multiple_class then do;
			if aim_check_$greater_or_equal (ep -> entry.access_class, dir_access_class) then return;
			end;
		     else if aim_check_$equal (ep -> entry.access_class, dir_access_class) then return;
		     end;

		call error (LOSS, ME, "Access class error for ^a, parent ^a, branch ^a", entry_name (ep),
		     cv_access (dir_access_class), cv_access (ep -> entry.access_class));
		call access_audit_$log_obj_class ("salv_dir_checker_", level$get (), unspec (event_flags),
		     access_operations_$fs_obj_set_soos, ep -> entry.access_class,
		     target (info.pathname, entry_name (ep)), 0, null (), 0, "Parent class: ^a",
		     cv_access (dir_access_class));
		ep -> entry.access_class = ep -> entry.access_class & sys_info$access_class_ceiling;
		security_oos = "1"b;

	     end entry_contents;
%page;
check_dates:
	     proc;

/* BUG fix: Fix, but do not print message for zero dtem. */
		if ep -> entry.dtem > time | ep -> entry.dtem = "0"b then do;
		     if ep -> entry.dtem ^= "0"b then do;
			call error (CORRECTION, ME, "Corrected dtem for ^a ^a",
			     BLOCK_NAME (fixed (ep -> entry.type, 18)), entry_name (ep));
			end;
		     ep -> entry.dtem = time;
		     end;

		if ep -> entry.type ^= LINK_TYPE then do;
		     if ep -> entry.dtd > time then do;
			call error (CORRECTION, ME, "Corrected dtd for ^a ^a",
			     BLOCK_NAME (fixed (ep -> entry.type, 18)), entry_name (ep));
			ep -> entry.dtd = "0"b;	/* So it will be dumped */
			end;
		     end;

	     end check_dates;

	end process_entry;
%page;
/* This procedure searches the directory for blocks that are not on the entry chain.
   The salvager has already marked the space that is occupied by valid entry, name and ACL blocks.  Only
   initial ACL's have not been marked.  The procedure loops through the directory area free chain and
   marks the blocks that have been released.  If there is any space left that is not marked used, the salvager
   tries to recover the missing blocks within that space.
*/
prodigal:
	proc;

dcl  (i, num_words) fixed bin;
dcl  code fixed bin;
dcl  bp ptr;
dcl  1 block aligned like block_template based (bp);

	     prodigal_search = "1"b;
	     if trace then call trace_message ("prodigal search", null);
	     trace = "0"b;

/* Loop through the unused space looking for name or entry blocks. */
	     i = 0;
	     do while (i < dir_size);
		num_words = index (substr (directory_space, i + 1, dir_size - i + 1), " ") - 1;
		if num_words = -1 then return;
		if num_words = 0
		then i = i + 2;
		else i = i + num_words + mod (num_words, 2);
		if i > dir_size - 3 then go to prodend;
		bp = ptr (source_ptr, i);
		if block.type = SEG_TYPE | block.type = DIR_TYPE | block.type = LINK_TYPE then do;
		     if valid_block (bp, (entry_type), dir_uid, (INVALID_RP)) then do;
			call process_entry (bp);
			end;

		     end;
		else if block.type = NAME_TYPE then call restore_name;
	     end;

prodend:
	     prodigal_search = "0"b;
	     trace = info.print_trace;
	     return;
%page;
/*  This procedure recovers a name block.  The name block must reference an entry that has already been verified. */
restore_name:
	     proc;

dcl  a_code fixed bin (35);
dcl  ep ptr;					/* ptr to entry block for name */
dcl  new_ep ptr;
dcl  np ptr;					/* ptr to name block */
dcl  p ptr;

/* Find entry block for the name.  If it has not yet been verified, check it. */

		np = bp;
		ep = ptr (source_ptr, np -> names.entry_rp);
		if valid_block (ep, entry_type, dir_uid, INVALID_RP) then do;
		     call process_entry (ep);
		     end;

		if fixed (rel (ep), 18) + block_sizes (entry_type) - 1 <= dir_size then do;
		     if substr (directory_space, fixed (rel (ep), 18) + 1, 1) = "E" then do;

/* Check structure and contents of name block. */
			if valid_block (np, name_type, ep -> entry.uid, (INVALID_RP)) then do;
			     call check_contents (np, name_type, ep, code);
			     if code = 0 then do;
				call mark_space_used (np, block_sizes (name_type));

/* Find entry block in rebuilt directory in order to connect the name to it. */
				p = addr (addr (ep -> entry.primary_name) -> names.name);
				call hash$search (target_ptr, p, new_ep, a_code);
				if a_code = 0
				then call move (np, new_ep -> entry.name_frp, new_ep -> entry.name_brp, new_ep,
					(null));
				end;
			     end;
			end;
		     end;
		return;

	     end restore_name;

	end prodigal;

     end entry_chain;
%page;
/* One directory chain is checked and or rebuilt. */
process_list:
     proc (head, tail, a_new_owner_bp, a_type_expected, a_entry_p, a_new_head, a_new_tail, a_count);

/* parameters */

dcl  head bit (18) unal;				/* head of list */
dcl  tail bit (18) unal;				/* end of list */
dcl  a_entry_p ptr;					/* ptr to entry block (used for ACLs and names) */
dcl  a_new_owner_bp ptr;				/* ptr to a_new entry block for threading names */
dcl  a_type_expected fixed bin;			/* type of blocks on list */
dcl  a_count fixed bin;				/* number of valid blocks found */
dcl  a_new_head bit (18) unal;			/* rebuild: head of list in new directory */
dcl  a_new_tail bit (18) unal;			/* rebuild: tail of list in new directory */

/* automatic */

dcl  back_rp bit (18);
dcl  block_rp bit (18);
dcl  bp ptr;
dcl  code fixed bin;
dcl  count fixed bin;
dcl  entry_p ptr;
dcl  forward bit (1) aligned;				/* ON for forward walk of list */
dcl  last_good_block bit (18) unal;			/* Last good block from forward walk. Used to terminate
						   backward walk. */
dcl  new_bp ptr;					/* ptr to block in new directory after the move */
dcl  new_head bit (18) unal;
dcl  new_tail bit (18) unal;
dcl  new_owner_bp ptr;				/* UID of owner block. */
dcl  owner_expected bit (36) aligned;
dcl  type_expected fixed bin;

dcl  1 block aligned like block_template based (bp);

	new_owner_bp = a_new_owner_bp;
	type_expected = a_type_expected;
	entry_p = a_entry_p;
	if rebuilding then do;
	     new_head = a_new_head;
	     new_tail = a_new_tail;
	     end;

/* For names and ACLs of entries the owner is the entry.  For all other blocks, the owner is the directory. */
	if entry_p ^= null
	then owner_expected = entry_p -> entry.uid;
	else owner_expected = dir_uid;
	count = 0;
	forward = "1"b;
	back_rp = "0"b;

/* If the forward thread is zero, but the backward thread is non-zero, then force the forward chain to fail
   to salvage those entries.
*/
	block_rp = head;
	if block_rp = "0"b
	then if tail ^= "0"b then block_rp = INVALID_RP;

	do while (block_rp ^= "0"b);
	     bp = ptr (source_ptr, block_rp);

/* If the block is not valid, then the back chain is used to recover the rest of the entries.
   ACL blocks can not be recoved this way, since the order is important.
*/
	     if ^valid_block (bp, type_expected, owner_expected, back_rp) then do;
		if trace then call trace_message ("Invalid block found on chain " || BLOCK_NAME (type_expected), bp);
		if stop_at_error then goto START_REBUILD;
		if ^forward
		then block_rp = "0"b;
		else do;
		     forward = "0"b;
		     if type_expected = acle_type
		     then block_rp = "0"b;
		     else do;
			back_rp = INVALID_RP;	/* can't check back ptr while following the chain backward */
			last_good_block = block_rp;
			if block_rp = tail
			then block_rp = "0"b;
			else block_rp = tail;
			end;
		     end;
		end;
	     else do;
		call mark_space_used (bp, 2);		/* Mark threads & size/type used */
		call check_contents (bp, type_expected, entry_p, code);
		if code = 0 then do;
		     call mark_space_used (bp, block_sizes (type_expected));
		     if rebuilding then do;
			call move (bp, new_head, new_tail, new_owner_bp, new_bp);
			if type_expected = acle_type
			then call set_acl_ref (addr (bp -> acl_entry.name), addr (new_bp -> acl_entry.name));
			else if type_expected = access_name_type then do;
				new_bp -> access_name.usage = 0;
				output_dir.acle_total = output_dir.acle_total + 1;
						/* This is a kludge. We move access names before
						   moving ACL entries, so the thread is quite
						   long even though dir.acle_total would be zero.
						   But acc_name_$encode (used to move ACLE) uses
						   acle_total to check for looped access name thread.
						   So we put in a number which will fool acc_name_.
						   What should really be done is to have a new
						   item, dir.access_name_total, but that is too much
						   work for right now. THVV */
				end;
			end;
		     count = count + 1;
		     end;
		else if trace
		     then call trace_message (rtrim (BLOCK_NAME (type_expected)) || " chain has invalid contents", bp)
			     ;
		if forward then do;
		     back_rp = block_rp;
		     block_rp = bp -> block.frp;
		     end;
		else do;
		     block_rp = bp -> block.brp;
		     if block_rp = last_good_block then block_rp = "0"b;
		     end;
		end;
	end;

	if rebuilding then do;
	     a_new_head = new_head;
	     a_new_tail = new_tail;
	     end;
	a_count = count;

	return;
     end process_list;
%page;
/* This procedure verifies the structure of a block.  It returns "0", if these conditions fail:
   1.  The block is within the directory and does not overlap any space that has been marked used.
   2.  The owner field matches the one expected.

   The following are not fatal errors and will be corrected. (except for the prodigal case)
   1.  The type and size fields found are not compatible with the type expected.
   2.  The back relative pointer is not the one expected.

   Any errors during a prodigal search, cause "0"b to be returned
*/
valid_block:
     proc (arg_tp, arg_type_expected, owner_expected, brp_expected) returns (bit (1) aligned);

/* parameters */

dcl  arg_tp ptr;					/* ptr to block */
dcl  arg_type_expected fixed bin;
dcl  owner_expected bit (36) aligned;
dcl  brp_expected bit (18) unal;

dcl  bp ptr;
dcl  type_expected fixed bin;
dcl  nwords fixed bin;
dcl  i fixed bin;
dcl  1 block aligned like block_template based (bp);


/* Check that the block falls within the directory and does not overlap previously accepted blocks. */

	bp = arg_tp;
	type_expected = arg_type_expected;
	if ^space_free (bp, block_sizes (type_expected)) then return ("0"b);

	goto btype (type_expected);

/* entry - directory, segment, link */
btype (8):
	if bp -> block.type = DIR_TYPE
	then type_expected = dir_type;
	else if bp -> block.type = SEG_TYPE
	     then type_expected = seg_type;
	     else if bp -> block.type = LINK_TYPE
		then type_expected = link_type;
		else return ("0"b);

	goto btype (type_expected);

/* access name */
btype (1):
	if bp -> access_name.owner ^= owner_expected then return ("0"b);
	goto CHECK_TYPE;

/* acl */
btype (2):
	if bp -> acl_entry.owner ^= owner_expected then return ("0"b);
	goto CHECK_TYPE;

/* segment or directory */
btype (7):
btype (4):
	if bp -> entry.owner ^= owner_expected then return ("0"b);
	goto CHECK_TYPE;

/* link */
/* The pathname size must be verified first, since the link structure uses it with the refer. */
btype (5):
	if bp -> link.pathname_size < 1 | bp -> link.pathname_size > 168 then return ("0"b);
	nwords = active_hardcore_data$elcsize + 3 + divide (bp -> link.pathname_size + 3, 4, 17, 0);
	do i = 1 to active_hardcore_data$nalloc_sizes while (nwords > active_hardcore_data$alloc_sizes (i));
	end;
	nwords = active_hardcore_data$alloc_sizes (i);
	if ^space_free (bp, nwords) then return ("0"b);
	if bp -> link.owner ^= owner_expected then return ("0"b);
	if bp -> link.size ^= nwords then do;
	     if prodigal_search then return ("0"b);
	     call error (CORRECTION, ME, "Corrected size field in link block");
	     bp -> link.size = nwords;
	     end;
	goto CHECK_BP;

/* name */
btype (6):
	if bp -> names.owner ^= owner_expected then return ("0"b);
	goto CHECK_TYPE;

/* The type and size fields must be correct for the prodigal search.  They will be corrected for the normal loop. */

CHECK_TYPE:
	if fixed (bp -> block.type, 18) ^= type_expected then do;
	     if prodigal_search then return ("0"b);
	     call error (CORRECTION, ME, "Invalid type in ^a block", BLOCK_NAME (type_expected));
	     bp -> block.type = bit (fixed (type_expected, 18), 18);
	     end;
	if bp -> block.size ^= block_sizes (type_expected) then do;
	     if prodigal_search then return ("0"b);
	     call error (CORRECTION, ME, "Corrected size field in ^a block", BLOCK_NAME (type_expected));
	     bp -> block.size = block_sizes (type_expected);
	     end;

/* Check and correct the back ptr.  Do not print message for prodigals since it  is assumed they are not on chains. */

CHECK_BP:
	if brp_expected ^= INVALID_RP
	then if bp -> block.brp ^= brp_expected then do;
		call error (CORRECTION, ME, "Corrected invalid back pointer in ^a", BLOCK_NAME (type_expected));
		bp -> block.brp = brp_expected;
		end;

	return ("1"b);

     end valid_block;
%page;
/* This procedure makes plausibility checks on the contents of the block.
   code = 0		No uncorrectable errors were found.
   code ^= 0		The block can not be salvaged.
*/
check_contents:
     proc (arg_bp, type_expected, entry_p, code);

dcl  arg_bp ptr;
dcl  type_expected fixed bin;
dcl  entry_p ptr;
dcl  code fixed bin;

dcl  a_code fixed bin (35);
dcl  bp ptr;
dcl  p ptr;

	code = 0;
	bp = arg_bp;
	goto check (type_expected);

/* access names must be ASCII */
check (1):
	call ascii_check (addr (bp -> access_name.name), length (bp -> access_name.name), code);
	if code ^= 0 then do;
	     if stop_at_error then goto START_REBUILD;
	     if code = 1
	     then call error (LOSS, ME, "Deleted non-ASCII access name ^a", bp -> access_name.name);
	     else call error (LOSS, ME, "Deleted blank access name");
	     end;
	if rebuilding
	then if bp -> access_name.usage = 0 then code = 1;

	return;

/* The ACL entry must point to valid person and project names and have an ASCII tag.  All access names are verified
   before any ACLs are checked. */
check (2):
	call check_acl_ref (addr (bp -> acl_entry.name), code);
	return;

/* The entry pointer must match the one expected.
   The name must contain only ASCII characters
   The name must not yet be in the hash table
*/
check (6):
	call ascii_check (addr (bp -> names.name), length (bp -> names.name), code);
	if code ^= 0 then do;
	     if stop_at_error then goto START_REBUILD;
	     if ^prodigal_search then do;
		if code = 1
		then call error (LOSS, ME, "Deleted non-ASCII name  ^a", bp -> names.name);
		else call error (LOSS, ME, "Deleted blank name");
		end;
	     return;
	     end;

/* Entry ptr check. */
	if rel (entry_p) ^= bp -> names.entry_rp then do;
	     if stop_at_error then goto START_REBUILD;
	     call error (CORRECTION, ME, "Corrected entry ptr for name ^a", bp -> names.name);
	     bp -> names.entry_rp = rel (entry_p);
	     end;

/* Name duplication check. */
	if rebuilding
	then p = target_ptr;
	else p = source_ptr;
	call hash$search (p, addr (bp -> names.name), (null), a_code);
	if a_code = 0 then do;
	     code = 1;
	     if stop_at_error then goto START_REBUILD;
	     if ^prodigal_search then call error (LOSS, ME, "Deleted duplicate name ^a", bp -> names.name);
	     return;
	     end;

/* Hash name back into source directory. */
	if ^rebuilding then do;
	     call hash$in (source_ptr, bp, a_code);
	     if a_code ^= 0 then do;
		call error (SYSTEM, ME, "Unexpected error from hash$in for ^a", bp -> names.name);
		goto START_REBUILD;
		end;
	     end;
	return;




     end check_contents;
%page;
/* This procedure turns on characters in the array directory_space to mark blocks of information that have been checked.
   This is done so that chains which loop back on themselves can be detected.  One character in directory_space
   corresponds to one word in the directory being checked.
   Entry blocks are special cased so that the primary name block, that is within the entry block, is left empty.

   The first character of the directory_space block is set:
   .	E	Entry block.  Used by prodigal search when a name has been found.
   .	A	Access name block.  Used in checking ACLs.  ACLs must point to verified access names.
*/
mark_space_used:
     proc (bp, num_words);

dcl  bp ptr;
dcl  num_words fixed bin;

dcl  start fixed bin;

dcl  1 block aligned based (bp) like block_template;

	start = fixed (rel (bp), 18) + 1;
	substr (directory_space, start, num_words) = substr (ONES, 1, num_words);

	if num_words > 2 then do;
	     if bp -> block.type = LINK_TYPE | bp -> block.type = DIR_TYPE | bp -> block.type = SEG_TYPE then do;
		substr (directory_space, start, 1) = "E";
		start = fixed (rel (addr (bp -> entry.primary_name)), 18) + 1;
		substr (directory_space, start, block_sizes (name_type)) = " ";
		end;
	     else if bp -> block.type = ACCESS_NAME_TYPE then substr (directory_space, start, 1) = "A";
	     end;

     end mark_space_used;



/* This procedure returns  "1"b, if the space specified is unused. */

space_free:
     proc (bp, num_words) returns (bit (1) aligned);

dcl  bp ptr;					/* pointer to block */
dcl  num_words fixed bin;				/* size of block */

dcl  start fixed bin;

	if num_words ^> 0 then call error (SYSTEM, ME, "salv_dir_checker_$space_fre called with num_words = 0");

	start = fixed (rel (bp), 18) + 1;
	if start + num_words - 2 > dir_size then return ("0"b);

/* HARDWARE BUG  get last character in, in case it is on a different page */
	if substr (directory_space, start + num_words - 1, 1) ^= " " then return ("0"b);
	return (substr (directory_space, start, num_words) = " ");

     end space_free;
%page;
/* This procedure is called to verify a name used in an ACL.  All access names are validated before any ACL's are
   checked.  The directory space array has an "A" at the start of all verified access names (stored by mark_space_used)
*/
check_acl_ref:
     proc (a_p, code);

dcl  a_p ptr;
dcl  p ptr;
dcl  code fixed bin;
dcl  1 name unal like acl_entry.name based (p);

	p = a_p;
	code = 0;
	if substr (unspec (name.tag), 1, 2) then do;
	     code = 1;
	     check_access_names = "1"b;
	     return;
	     end;
	if name.pers_rp ^= "0"b then call find_access_name (ptr (source_ptr, name.pers_rp));
	if code = 0
	then if name.proj_rp ^= "0"b then call find_access_name (ptr (source_ptr, name.proj_rp));
	if code = 1 then check_access_names = "1"b;




find_access_name:
	proc (np);

dcl  np ptr;

	     if fixed (rel (np), 18) + block_sizes (access_name_type) - 1 <= dir_size
	     then if substr (directory_space, fixed (rel (np), 18) + 1, 1) = "A" then return;
	     code = 1;

	end find_access_name;

     end check_acl_ref;




/* This procedure checks for ASCII characters.  ASCII characters have the 2 high order bits off. */

ascii_check:
     proc (name_ptr, num_chars, code);

dcl  name_ptr ptr;
dcl  num_chars fixed bin;
dcl  code fixed bin;

dcl  i fixed bin;
dcl  name bit (i) aligned based (name_ptr);

dcl  1 ascii_mask aligned static options (constant),
       2 part1 bit (9 * 16) init ((16)"110000000"b),
       2 part2 bit (9 * 16) init ((16)"110000000"b);

dcl  1 spaces aligned static options (constant),
       2 part1 bit (9 * 16) init ((16)"040"b3),
       2 part2 bit (9 * 16) init ((16)"040"b3);

	i = num_chars * 9;
	if (name & unspec (ascii_mask)) = "0"b
	then code = 0;
	else code = 1;

	if name = unspec (spaces) then code = 2;         /* Check to see if name is blank. */

     end ascii_check;
%page;
setup:
     proc;
	if ^static_init then do;
	     block_sizes (dir_header_type) = active_hardcore_data$dir_hdrsize;
	     block_sizes (seg_type), block_sizes (dir_type), block_sizes (entry_type) = active_hardcore_data$esize;
	     block_sizes (acle_type) = active_hardcore_data$aclsize;
	     block_sizes (access_name_type), block_sizes (name_type) = active_hardcore_data$ensize;
	     header_area_size = active_hardcore_data$dir_hdrsize + active_hardcore_data$nalloc_sizes + 2;
	     ONES = copy ("1", length (ONES));
	     root_lvid = pvt$root_lvid;
	     static_init = "1"b;
	     end;

	salv_ptr = arg_salv_ptr;
	branch_ptr = info.branch_ptr;
	source_ptr = arg_source_ptr;
	target_ptr = info.temp1_ptr;
	scratch_ptr = info.temp2_ptr;
	prodigal_search, check_access_names = "0"b;
	rebuilding = info.force_rebuild;
	correct_oosw = info.correct_oosw;
	trace = info.print_trace;
	security_oos = "0"b;
	time = info.salv_time;

/* Use the value in the area header if it is plausible. MR6.0 has garbage after the end of the area.
   After this release, unused portion of the last page of the directory will be zero, so the next
   version can use the current length.
*/
	dir_size = ptr (source_ptr, active_hardcore_data$dir_arearp) -> area.lu - 1;
	if dir_size > 1024 * info.current_length | dir_size < 1024 * (info.current_length - 1)
	then dir_size = info.current_length * 1024 - 1;
	directory_space = " ";

	string (event_flags) = ""b;
	event_flags.special_op = "1"b;
	event_flags.grant = "1"b;			/* can't know whether we're doing this under privileged
						   maint operation or as user who encountered a bad dir.
						   assume the latter... */

     end setup;
%page;
/* This procedure returns an entry name as characters, if it is ASCII or as octal, if it is not. */

entry_name:
     proc (ep) returns (char (32));

dcl  ep ptr;

dcl  string char (32 * 3);
dcl  np ptr;

dcl  code fixed bin;
dcl  word8 bit (288) aligned based;			/* the name as a bit string for formline_ */

	np = addr (ep -> entry.primary_name);
	call ascii_check (addr (np -> names.name), length (np -> names.name), code);
	if code = 0 then return (np -> names.name);
	call format ("^(^8w^)", addr (np -> names.name) -> word8, string);
	return (string);
     end entry_name;


format:
     proc (control_string, name_string, output_string) options (non_quick);

dcl  control_string char (*);
dcl  name_string bit (288) aligned;
dcl  output_string char (*);

dcl  formline_ entry (fixed bin, fixed bin, ptr, fixed bin, fixed bin);

	call formline_ (1, 2, addr (output_string), length (output_string), 0);

     end format;
%page;
/* Space for the block is allocated in the new directory and the new block is threaded onto the chain
   specified by the head and tail pointers.
   The primary name for an entry is contained within the entry block, so space is not allocated for it.
   Names are put in the hash table and their entry rel pointers set.
*/
move:
     proc (bp, head, tail, entry_bp, new_ptr);

dcl  bp ptr;					/* ptr to entry in old directory */
dcl  head bit (18) unal;				/* head of chain */
dcl  tail bit (18) unal;				/* tail of chain */
dcl  entry_bp ptr;					/* pointer to entry for a name block */
dcl  new_ptr ptr;					/* pointer to block in rebuilt directory */

dcl  code fixed bin (35);
dcl  num_words fixed bin;
dcl  last_ep ptr;					/* pointer to entry that was processed before the entry
						   for the this name. */

dcl  copy (num_words) bit (36) aligned based;
dcl  1 block aligned like block_template based (bp);

	num_words = bp -> block.size;

/* The first name on a chain is the primary name. */

	if bp -> block.type = NAME_TYPE & head = "0"b then do;
	     new_ptr = addr (entry_bp -> entry.primary_name);
	     end;
	else call fs_alloc$alloc (output_area_ptr, num_words, new_ptr, code);

	new_ptr -> copy = bp -> copy;
	new_ptr -> block.frp = "0"b;

	if head = "0"b then do;
	     head, tail = rel (new_ptr);
	     new_ptr -> block.brp = "0"b;
	     end;
	else do;
	     new_ptr -> block.brp = tail;
	     ptr (target_ptr, tail) -> block.frp = rel (new_ptr);
	     tail = rel (new_ptr);
	     end;

/* Names are hashed into the new directory.  This code special cases rebuilding a directory whose hash table size
   is about to grow.  The code in hash will walk the entry chain and put the names into the new hash table.
   The current entry must be removed from the entry chain, since its name is not yet in the hash table. */

	if new_ptr -> block.type = NAME_TYPE then do;
	     if output_dir.htused = output_dir.htsize then do;
		last_ep = ptr (target_ptr, entry_bp -> entry.ebrp);
		last_ep -> entry.efrp = "0"b;
		end;
	     else last_ep = null;
	     call hash$in (target_ptr, new_ptr, code);
	     if code ^= 0 then call error (SYSTEM, ME, "Unable to hash name ^a", new_ptr -> names.name);
	     ;
	     if last_ep ^= null then last_ep -> entry.efrp = rel (entry_bp);
	     new_ptr -> names.entry_rp = rel (entry_bp);
	     end;

     end move;
%page;
/* The ACL pointers to the access name and access project are changed to the locations in the rebuilt directory. */

set_acl_ref:
     proc (a_old_p, a_new_p);

dcl  a_old_p ptr;					/* ptr to access name structure in old directory */
dcl  a_new_p ptr;					/* ptr to access name structure in new directory */
dcl  p ptr;
dcl  code35 fixed bin (35);
dcl  1 acl_info aligned,				/* template for access name encoding */
       2 name,
         3 pers char (32),
         3 proj char (32),
         3 tag char (1),
       2 pad (2) bit (36);
dcl  1 name aligned like acl_entry.name based (p);

	p = a_old_p;
	if name.pers_rp = "0"b
	then acl_info.pers = "*";
	else acl_info.pers = ptr (source_ptr, name.pers_rp) -> access_name.name;

	if name.proj_rp = "0"b
	then acl_info.proj = "*";
	else acl_info.proj = ptr (source_ptr, name.proj_rp) -> access_name.name;
	acl_info.tag = name.tag;

join:
	call acc_name_$encode (a_new_p, addr (acl_info), code35);
	if code35 ^= 0 then do;
	     call error (SYSTEM, ME, "Unexpected error from acc_name_$encode ^w for ^a.^a.^a", code35, name.pers, name.proj,
		name.tag);
	     end;

	return;

set_acl_ref$damaged:
     entry (a_old_p, a_new_p);			/* Called to put in constant. */

	acl_info.pers = "Salvager";
	acl_info.proj = "SysDaemon";
	acl_info.tag = "z";

	go to join;


     end set_acl_ref;
%page;
/* If the compact option was specified, then the space on the free list is totaled.  If it contains a page or more
   space, then a rebuild is forced.  If any errors are detected, a rebuild is forced.
*/
check_free_list:
     proc;

dcl  bp ptr;
dcl  i fixed bin;
dcl  sum fixed bin;
dcl  1 block aligned like block_template based (bp);

	areap = ptr (source_ptr, input_dir.arearp);
	sum = 0;

	do i = 1 to area.nsizes;
	     do bp = ptr (source_ptr, area.array (i).fptr) repeat ptr (source_ptr, bp -> block.frp) while (rel (bp));

		if area.array (i).size ^> 0 then go to START_REBUILD;
		if ^space_free (bp, (area.array (i).size)) then goto START_REBUILD;
		sum = sum + area.array (i).size;
		if sum > 1024 then goto START_REBUILD;
		call mark_space_used (bp, (area.array (i).size));
	     end;
	end;

     end check_free_list;
%page;
/* Fields in the header are checked against values supplied in the branch and storage system constants
   Errors cause a message to be printed and the rebuilding flag to be set.  No corrections are made here,
   setup_header sets all fields using the branch information.

   "0"b	If the UID in the branch does not equal the UID in the header
   "1"b	The UID does match.

   If the access_class does not match, the branch will be set security_oos.
*/
valid_header:
     proc () returns (bit (1) aligned);

dcl  1 branch aligned based (branch_ptr) like entry;

dcl  num_buckets fixed bin;
dcl  i fixed bin;
dcl  block (i) bit (36) based (htp);
dcl  1 hash_table aligned based (htp),
       2 pad bit (36),
       2 type bit (18) unal,
       2 size fixed bin (17) unal,
       2 buckets (num_buckets) bit (18) unal;

	if branch_ptr = null then do;
	     audit = "0"b;

	     dir_uid = input_dir.uid;
	     end;
	else do;
	     audit = "1"b;

/* If the UID in the header doesn't match the one in the branch, then a valid empty directory will be created. */

	     if input_dir.uid ^= branch.uid then do;
		call error (LOSS, ME, "Invalid directory header - no information recovered");
		dir_name_cnt = 0;
		call setup_dir_header;
		rebuilding = "1"b;
		return ("0"b);
		end;

	     if input_dir.owner ^= branch.owner then call header_err ("owner");
	     if input_dir.pvid ^= branch.pvid then call header_err ("physical volume id");
	     if input_dir.sons_lvid ^= branch.sons_lvid then call header_err ("sons logical volume id");
	     if input_dir.vtocx ^= branch.vtocx then call header_err ("vtoc index");
	     if input_dir.master_dir ^= branch.master_dir then call header_err ("master directory switch");
	     if input_dir.master_dir_uid ^= info.master_dir_uid then call header_err ("master directory UID");
	     dir_uid = branch.uid;
	     dir_access_class = branch.access_class;

/* AIM check */
	     if input_dir.access_class ^= dir_access_class then do;
		call error (LOSS, ME, "Branch access class ^a does not match directory header access class ^a",
		     cv_access (branch.access_class), cv_access (input_dir.access_class));

/* BUG FIX: This field is not always set, due to a bug in reclassify.  Add check after 6.0 */
/*
   *		call access_audit_$log_obj_class ("salv_dir_checker_", level$get(), unspec(event_flags),
   *		     access_operations_$fs_obj_set_soos, branch.access_class, info.pathname, 0, null(), 0,
   *		     "Dir header class: ^a", cv_access (dir_access_class));
   *		     security_oos = "1"b;
*/
		end;
	     end;
	if input_dir.type ^= DIR_HEADER_TYPE then call header_err ("type");
	if input_dir.size ^= active_hardcore_data$dir_hdrsize then call header_err ("size");
	if input_dir.version_number ^= version_number_2 then call header_err ("version_number");
	if input_dir.arearp ^= bit (active_hardcore_data$dir_arearp, 18) then call header_err ("area pointer");

/* Check area header */

	areap = ptr (source_ptr, active_hardcore_data$dir_arearp);
	if area.nsizes ^= active_hardcore_data$nalloc_sizes
	then call header_err ("area header");
	else do;
	     do i = 1 to active_hardcore_data$nalloc_sizes;
		if area.array (i).size ^= active_hardcore_data$alloc_sizes (i) then do;
		     i = active_hardcore_data$nalloc_sizes;
		     call header_err ("area header");
		     end;
	     end;
	     end;

	if area.lw ^= sys_info$default_dir_max_length - 1 then call header_err ("area size");

/* Check hash block structure, clear the hash table information, and mark the space used.
   If rehashing is set, the procedure hash was rehashing to a larger table size when an error was detected. */

	dir_name_cnt = input_dir.htused;
	if ^input_dir.rehashing then do;
	     htp = ptr (source_ptr, input_dir.hash_table_rp);

/* This code depends on being the last check in valid_header. */
/* If the return statement inside is not executed, then the */
/* control point falls through to the error message */

	     if hash_table.size > 0			/* has to be believable */
	     then if space_free (htp, (hash_table.size)) then do;
		     do i = 1 to active_hardcore_data$num_hash_table_sizes
			while (input_dir.htsize ^= active_hardcore_data$hash_table_sizes (i));
		     end;
		     if i <= active_hardcore_data$num_hash_table_sizes then do;
			num_buckets = active_hardcore_data$hash_table_sizes (i);
			if input_dir.htused <= num_buckets | i = active_hardcore_data$num_hash_table_sizes then do;
			     i = hash_table.size;
			     if hash_table.type = HASH_TABLE_TYPE & block (i) = dir_uid then do;
				unspec (buckets) = "0"b;
				input_dir.htused = 0;
				call mark_space_used (htp, (hash_table.size));
				return ("1"b);
				end;
			     end;
			end;
		     end;
	     end;
	call error (CORRECTION, ME, "Invalid hash table found");
	rebuilding = "1"b;
	return ("1"b);




header_err:
	proc (string);

dcl  string char (*);

	     call error (CORRECTION, ME, "Corrected ^a in header", string);
	     rebuilding = "1"b;

	end header_err;
     end valid_header;
%page;
setup_dir_header:
     proc;

dcl  i fixed bin;

dcl  1 branch aligned like entry based (branch_ptr);

	unspec (output_dir) = "0"b;
	if branch_ptr ^= null then do;
	     output_dir.owner = branch.owner;
	     output_dir.uid = branch.uid;
	     output_dir.pvid = branch.pvid;
	     output_dir.sons_lvid = branch.sons_lvid;
	     output_dir.master_dir = branch.master_dir;
	     output_dir.access_class = branch.access_class;
	     output_dir.per_process_sw = branch.per_process_sw;
	     output_dir.vtocx = branch.vtocx;
	     if input_dir.force_rpv & branch.sons_lvid = root_lvid
	     then output_dir.force_rpv = "1"b;
	     else output_dir.force_rpv = "0"b;
	     end;

	output_dir.master_dir_uid = info.master_dir_uid;
	output_dir.tree_depth = info.tree_depth;
	output_dir.type = DIR_HEADER_TYPE;
	output_dir.size = active_hardcore_data$dir_hdrsize;
	output_dir.dts = time;
	output_dir.version_number = version_number_2;
	output_dir.arearp = bit (active_hardcore_data$dir_arearp, 18);
	i = sys_info$default_dir_max_length - fixed (output_dir.arearp, 18);
	output_area_ptr = ptr (target_ptr, active_hardcore_data$dir_arearp);
	call fs_alloc$init (output_area_ptr, i, addr (active_hardcore_data$alloc_sizes),
	     active_hardcore_data$nalloc_sizes);
	i = dir_name_cnt;
	if i < 0 | i > 5 * input_dir.htsize then i = 0;
	call allocate_dir_ht_ (target_ptr, i, (0));

     end setup_dir_header;
%page;
/* The rebuilt version is copied into the source.  The unused portion of the last page must be cleared so that
   it will not be "recovered" in a future prodigal search.
*/
copy_directory:
     proc;

dcl  num_pages fixed bin;				/* number of pages in new directory */
dcl  num_words fixed bin (18);			/* number of used words in directory. */
dcl  zero_len fixed bin;				/* number of unused words on last page */
dcl  1 copy_dir aligned based,
       2 contents (num_words) bit (36) aligned,
       2 zero bit (zero_len) aligned;

	num_words = output_area_ptr -> area.lu;		/* Note: lu is NEXT available block and offsets start at 0 */
	output_area_ptr -> area.lw = sys_info$default_dir_max_length - 1;

	num_pages = divide (num_words + 1023, 1024, 17, 0);
	if num_pages > info.current_length
	then call error (CORRECTION, ME, "Directory pages increased from ^d to ^d.", info.current_length, num_pages);
	if num_words > dir_size + 1
	then call error (CORRECTION, ME, "Directory length increased from ^d to ^d", dir_size + 1, num_words);
	zero_len = mod (num_words, 1024);
	if zero_len > 0 then do;
	     zero_len = (1024 - zero_len) * 36;
	     source_ptr -> copy_dir.zero = "0"b;
	     end;
	source_ptr -> copy_dir.contents = target_ptr -> copy_dir.contents;

	arg_new_dir_pages = num_pages;

     end copy_directory;
%page;
/*  This procedure supplies a unique primary name for an entry.  It is only called when rebuilding. */
get_unique_name:
     proc (ep);

dcl  ep ptr;					/* ptr to entry block */

dcl  1 new_name aligned like names;
dcl  unique_chars_ entry (bit (*)) returns (char (15));

	new_name.name = unique_chars_ ("0"b);
	new_name.owner = ep -> entry.uid;
	new_name.type = NAME_TYPE;
	new_name.size = active_hardcore_data$ensize;
	call move (addr (new_name), ep -> entry.name_frp, ep -> entry.name_brp, ep, (null));
	call error (LOSS, ME, "Unique name ^a supplied for ^a", new_name.name, BLOCK_NAME (fixed (ep -> entry.type, 18)));

	ep -> entry.nnames = 1;


     end get_unique_name;
%page;
/* This procedure prints debugging information. */

trace_message:
     proc (string, p);

dcl  string char (*);
dcl  p ptr;

	call error (DUMP, ME, "salv_dir_checker_ trace information - ^a at ^p", string, p);

     end trace_message;
%page;
cv_access:
     proc (access) returns (char (32) aligned);

dcl  access bit (72) aligned;
dcl  string char (32) aligned;

	call display_access_class_ (access, string);
	return (string);

     end cv_access;
%page;
/* This procedure searches the access_name list and frees any names with a zero access count.
   Unused access names occur because the access name list is recovered before any of the ACL's that reference them.
*/
delete_unused_access_names:
     proc (head, tail);

dcl  head bit (18) unal;
dcl  tail bit (18) unal;

dcl  bp ptr;
dcl  next_rp bit (18);

	do bp = ptr (target_ptr, head) repeat ptr (target_ptr, next_rp) while (rel (bp));

	     next_rp = bp -> access_name.frp;
	     if bp -> access_name.usage = 0 then do;
		if bp -> access_name.brp
		then ptr (target_ptr, bp -> access_name.brp) -> access_name.frp = bp -> access_name.frp;
		else head = bp -> access_name.frp;

		if bp -> access_name.frp
		then ptr (target_ptr, bp -> access_name.frp) -> access_name.brp = bp -> access_name.brp;
		else tail = bp -> access_name.brp;

		call fs_alloc$free (output_area_ptr, block_sizes (access_name_type), bp);
		end;
	end;

     end delete_unused_access_names;
%page;
target: proc (dir, ent) returns (char (*));

dcl	dir	char (*) parameter;
dcl	ent	char (*) parameter;

	if dir = ">"
	then return (">"||ent);
	else return (rtrim(dir)||">"||ent);

     end target;
%include dir_header;
%include dir_entry;
%include dir_link;
%include dir_acl;
%include dir_name;
%include dir_ht;
%include dir_allocation_area;
%include salv_args;
%include fs_types;
%include salv_data;
%include sys_log_constants;
%include its;
%include access_audit_eventflags;
%page;
/* BEGIN MESSAGE DOCUMENTATION

   Message:
   AUDIT (salv_dir_checker_): GRANTED modification of fs_obj access ADDED_INFO

   S: $access_audit

   T: Salvaging

   M: The salvager has truncated the ACL of a branch.

   A: $inform_ssa


   Message:
   ADUIT (salv_dir_checker_): GRANTED modification of security out-of-service ADDED_INFO

   S: $access_audit

   T: Salvaging

   M: The security-out-of-service switch has been set on
   a directory because of an AIM error.  The access class of
   a branch was not equal to that of the containing directory,
   or the access class in the directory's branch was not equal
   to the access class stored in its header.

   A: $inform_ssa


   Message:
   salv_dir_checker_: MESSAGE.

   S:     $log

   T:     Salvaging

   M:     Various messages are printed by salv_dir_checker_ indicating
   what salvaging is taking place--ACL counts being changed, entry counts
   being changed, unique names supplied for segments with invalid names,
   etc.

   A:     $ignore

   END MESSAGE DOCUMENTATION */

     end salv_dir_checker_;
