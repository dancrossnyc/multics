/****^  ******************************************************
        *                                                    *
        * Copyright, (C) Honeywell Bull Inc., 1987           *
        *                                                    *
        * Copyright (c) 1986 by Massachusetts Institute of   *
        * Technology and Honeywell Information Systems, Inc. *
        *                                                    *
        * Copyright (c) 1972 by Massachusetts Institute of   *
        * Technology and Honeywell Information Systems, Inc. *
        *                                                    *
        ****************************************************** */

/**** format: ind3,ll80,initcol6,indattr,^inddcls,dclind4,idind16	       */
/**** format: struclvlind2,^ifthenstmt,^ifthendo,^ifthen,^indnoniterdo       */
/**** format: ^inditerdo,^indnoniterend,^indthenelse,case,^indproc,^indend   */
/**** format: ^delnl,^insnl,comcol41,^indcom,^indblkcom,linecom,^indcomtxt   */
%page;
/* ***********************************+************************************* */
/* All error table  declarations, and (begin proc end) lines are marked with */
/* "<##>".   This is to aid in gleaning the information needed for proper    */
/*  return code documentation.				       */
/* ***********************************+************************************* */
/*							       */
/* Name: date_time_                                                          */
/*                                                                           */
/* The  date_time_  system  is  a  utility  which  encodes, decodes,         */
/* adjusts, or formats a Multics standard calendar clock value.  The         */
/* clock  reading  is  assumed  to be  in  microseconds  relative to         */
/* 1901-01-01  0:00 gmt.   The ASCII  times involved  may be  one of         */
/* several languages and in a choice of time zones around the world.         */
/*							       */
/* ***********************************+************************************* */


/* ***********************************+************************************* */
/*							       */
/* Status							       */
/*							       */
/* 0) Created: Jun, 1978 by J Falksen				       */
/*        a) based on old date_time_ and decode_clock_value_	       */
/* 1) Extended: Dec, 1978 by Gary Dixon				       */
/*        Added ability to handle wide range of dates		       */
/* 2) Extended: Apr, 1983 by jaf				       */
/*	updating to ioa_-like $format controls			       */
/* 3) Changed:  Apr, 1984 by jaf				       */
/*	enclosed code for each entrypoint in a BEGIN block. delete all     */
/*	first-level declarations of error codes. This forces each block    */
/*	to declare the codes it needs.  This may make it possible to find  */
/*	out the list of error codes each entry might return.	       */
/* 4) Changed: Nov, 1984 by jaf				       */
/*	change time_offset.dw into time_offset.dw.(flag val)	       */
/*	added $format_max_length				       */
/*							       */
/* ***********************************+************************************* */


/****^  HISTORY COMMENTS:
  1) change(86-08-15,GDixon), approve(86-09-04,MCR7532),
     audit(86-09-05,Martinson), install(86-09-16,MR12.0-1159):
     Fix stringsize error.  Change date_time_$format, $format_max_length and
     $valid_format to report location in error within the original time_format
     string (with keywords unexpanded), rather than within the expanded
     time_format string. (phx19124)
  2) change(86-08-16,GDixon), approve(86-09-04,MCR7532),
     audit(86-09-05,Martinson), install(86-09-16,MR12.0-1159):
     Correct problem which causes time_format "^za, ^dn" to be rejected.
     Problem stems from z a and comma all being interpreted as picture chars.
     Therefore, the "za" sequences needs to be special-cased. (date_time 30)
  3) change(88-05-29,GDixon), approve(88-06-15,MCR7918),
     audit(88-07-28,Lippard), install(88-08-02,MR12.2-1075):
      A) Correct bug in applying year offset from a leap_day
         (02/29/<leap_year>).  (date_time 31, phx21107)
  4) change(99-06-23,Haggett):
     Y2K
                                                   END HISTORY COMMENTS */

%page;
/* ***********************************+************************************* */
/* @@@@@@ ext proc .. date_time_				       */
/*							       */
/* ENTRY:  date_time_                                                        */
/*                                                                           */
/* The date_time_ subroutine converts a  system clock value to ASCII         */
/* representation.   It  will be  in  terms of  the  process default         */
/* language and zone.                                                        */
/*                                                                           */
/* USAGE:                                                                    */
/*    dcl date_time_ entry (fixed bin (71), char (*));                       */
/*    call date_time_ (clock, str);                                          */
/*                                                                           */
/* ARGUMENTS:                                                                */
/* clock (input)                                                             */
/*    is the clock value to be formatted                                     */
/* str (output)                                                              */
/*    is the resultant character string.                                     */
/*                                                                           */
/* NOTES:                                                                    */
/* The format string which produces the resultant string is:                 */
/*   "^my/^dm/^yc  ^Hd^99v.9MH ^za ^da"                                      */
/* which produces strings like this:                                         */
/*    07/14/83  1435.4 mst Thu                                               */
/* See  Multics Programmers'  Reference Manual for  a description of         */
/* acceptable strings.                                                       */
/*                                                                           */
/* The  ASCII representation  of time, which  date_time_ attempts to         */
/* return in string,  is 24 characters long.  If  string is declared         */
/* by the caller with a length of N and N is less than 24, then only         */
/* the first  N characters are  returned.  If N is  greater than 24,         */
/* then the result is returned padded on the right with spaces.              */
/*                                                                           */
/* If  clock  is  not  a valid  date,  "01/01/01  0000.0 gmt Tue" is         */
/* returned.                                                                 */
/*							       */
/* ***********************************+************************************* */

date_time_: proc (clock_value, str);

/* format: off						       */
dcl (
  clock_value	fixed bin (71),	/* standard clock value          [In]*/
  str		char (*)		/* return string 	            [Out]*/
    )		parm;		/* format: on		       */

      temp_clock = clock_value;
      go to date_time_rtn;		/* go join up with fstime code       */
				/* @@"END" date_time_	       */ %skip (4);
/*   Background:						       */
/*							       */
/* The Julian calendar is used for dates from 1/1/0001 to 10/04/1582.  This  */
/*  calendar has the same year/month/day structure as the Gregorian calendar */
/*  (the calendar we use now), except that every fourth year is a leap year, */
/*  including centential years.				       */
/*							       */
/* In 1582, Pope Gregory XIII reformed the Julian calendar.  The Julian      */
/*  calendar year of 365.25 days was too long.  The correct tropical (solar) */
/*  year is 365.242199 days long. By 1582, the error in the Julian calendar  */
/*  of 11 minutes, 14 seconds per year had caused the calendar date to be    */
/*  ten days earlier than it should have been.  Pope Gregory corrected this  */
/*  discrepancy be decreeing that the day following October 4, 1582 would be */
/*  October 15, 1582.  Thus, the year 1582 had only 355 days.    He then     */
/*  reformed the year calculation to avoid discrepancies in the future by    */
/*  removing 3 intercalary (leap) days every 400 years.  The pope decreed    */
/*  that centential years would not be leap years unless they were 0 mod     */
/*  400.  The reformed calendar is called the Gregorian calendar.	       */

/* The dates from October 5, 1582 to October 14, 1582 do not exist.	       */
/* The year 1582 presents a bit of a mess it terms of day-in-week, date,     */
/* and day-in-year.  This is what it looks like:			       */
/*							       */
/* day-in-week: |Mon... Thu| <no gap> |Fri  ...  Fri| <no gap> |Sat ...      */
/* day-in-year: |001... 277| <no gap> |278  ...  355|10 day gap|001 ...      */
/*        date: |1/1...10/4|10 day gap|10/15...12/31| <no gap> |1/1 ...      */
/*              |<--------------1582--------------->|          |<--1583--    */
/*							       */
/* The Gregorian calendar is used for dates from 10/15/1582 to 12/31/9999.   */
/*  This calendar has a leap year every 4 years, except:  leap year omitted  */
/*  when mod(year,100) = 0 but included when mod(year,400) = 0.	       */
/*							       */
/* The lower limit on dates of Jan 1, 0001 AD was picked:  to avoid	       */
/*  complexities of dates Before Christ;  because there was no stable	       */
/*  calendar system prior to 4 AD anyway. The upper limit on date of	       */
/*  Dec 31, 9999 was chosen to limit year numbers to 4 digits.	       */
/*							       */
/* ***********************************+************************************* */

/* ***********************************+************************************* */
/*							       */
/*    The leap year device is used to adjust the calendar year to match the  */
/*  astronomical year.  Every year divisible by 4 is a leap year except when */
/*  it's divisible by 100 but not 400.  The action of these 3 conditions     */
/*  results in 3 numeric cycles. Here is the derivation of the lengths of    */
/*  each of the cycles:					       */
/*                                                                           */
/*              4 *    365 + 1 =     1461 days in    4-yr cycle              */
/*             25 *   1461 - 1 =    36524 days in  100-yr cycle              */
/*              4 *  36524 + 1 =   146097 days in  400-yr cycle              */
/*							       */
/*    Plus we need to know this:				       */
dcl microseconds_per_day init (86400000000) /* 24*60*60*1e6		       */
		fixed bin (71) int static options (constant);

/*							       */
/* The base values used for the calendar work are the Julian values:	       */
/*	 0001        --> yc = 1	(year in calendar)		       */
/*	 0001-01-01  --> dc = 1	(day in calendar)		       */
/*	 0001-01-01m --> Uc = 0	(microsecond in calendar)	       */
/* The Julian calendar has but a single cycle which works directly on this   */
/*  base.  The number of microseconds of 1582-10-04 23:59:59.999999 +1 must  */
/*  equal  the number of microseconds of 1582-10-15 00:00:00.000000. The 1st */
/*  is the last Julian Usec, the 2nd is the first Gregorian one.  The Julian */
/*  method calculates out 577737 days for 1582-10-04, while the Gregorian    */
/*  method calculates out 577735 days for 1582-10-15. So when Gregorian work */
/*  is done, 2 days are subtracted in order to get to the base point of its  */
/*  3 cycles.						       */
/*							       */
/* Consider these several quantities:				       */

/* [ 1] Days from 0001-01-01 thru  1582-10-04.                               */
/*              #units  days/unit          days           years              */
/*    4-yr cycles: 395 *    1461    ->    577095    ->      1580             */
/*   excess years:   1 *     365    ->       365    ->         1             */
/*   days in year:                           277                             */
/*         TOTALS:  (Julian)              577737            1581             */
/*                        49,916,476,800 seconds.			       */

/* ** 1582-10-04 Julian is the same as 1582-10-14 Gregorian                  */
/* **   i.e. 1 day beyond either is 1582-10-15                               */
/*                                                                           */
/* [ 2] Days from 0001-01-01 thru  1582-10-14.                               */
/*              #units  days/unit          days           years              */
/*  400-yr cycles:   3 *  146097    ->    438291    ->      1200             */
/*  100-yr cycles:   3 *   36524    ->    109572    ->       300             */
/*    4-yr cycles:  20 *    1461    ->     29220    ->        80             */
/*   excess years:   1 *     365    ->       365    ->         1             */
/*   days in year:                           287                             */
/*         TOTALS:  (Gregorian)           577735            1581             */
/*                        49,916,304,000 seconds.			       */

/* [ 3] Days from 0001-01-01 thru  1900-12-31.                               */
/*              #units  days/unit          days           years              */
/*  400-yr cycles:   4 *  146097    ->    584388    ->      1600             */
/*  100-yr cycles:   2 *   36524    ->     73048    ->       200             */
/*    4-yr cycles:  24 *    1461    ->     35064    ->        96             */
/*   excess years:   3 *     365    ->      1095    ->         3             */
/*   days in year:                           365                             */
/*         TOTALS:  (Gregorian)           693960            1899             */
/*                        59,958,144,000 seconds.			       */

/* [ 4] Days from 0001-01-01 thru  9999-12-31.                               */
/*              #units  days/unit          days           years              */
/*  400-yr cycles:  24 *  146097    ->   3506328    ->      9600             */
/*  100-yr cycles:   3 *   36524    ->    109572    ->       300             */
/*    4-yr cycles:  24 *    1461    ->     35064    ->        96             */
/*   excess years:   2 *     365    ->       730    ->         2             */
/*   days in year:                           365                             */
/*         TOTALS:  (Gregorian)          3652059            9998             */
/*                       315,537,897,600 seconds.			       */

/* [ 5] Days from 0001-01-01 thru 1900-12-31.                                */
/*    [ 3]    693960                                                         */
/*  - [ 2]    577735                                                         */
/*  + [ 1]    577737                                                         */
/*            693962      59,958,316,800 seconds.			      **/
/*                                                                           */
/*    Since the Multics clock has zero => 1901-01-01, above is the number of */
/*    microseconds to subtract to give the clock reading of 0001-01-01 as    */
/*    the  Gregorian algorithm goes.				       */

/* [ 6] Days from 0001-01-01 thru 9999-12-31.                                */
/*    [ 4]   3652059                                                         */
/*  - [ 2]    577735                                                         */
/*  + [ 1]    577737                                                         */
/*  =        3652061     315,538,070,400 seconds.			       */
/*                                                                           */
/*    This is the maximum allowable value of the virtual clock in the        */
/*    interval to be covered.                                                */
/* ***********************************+************************************* */
/*	     So we must adjust Multics clock (base 1901-01-01m)	       */
/*                        to the virtual clock (base 0001-01-01m)	       */
/*	         And then partition into calendar ranges.		       */
/* ***********************************+************************************* */
dcl (
    begin_Gregorian init (049916476800e6), /* 1582-10-15 m		       */
    begin_Special   init (059958316800e6), /* 1901-01-01 m		       */
    end_Special     init (066238214400e6), /* 2100-01-01 m		       */
    M_vc_adjust	init (059958316800e6), /* 1901-01-01 m		       */
    max_vc_value	init (315538070400e6) /* 9999-12-31 23:59:59.999999     */
    )		fixed bin (71) int static options(constant); %page;
/* @@@@@@ ext proc .. format					       */
/* ***********************************+************************************* */
/*							       */
/* ENTRY:  date_time_$format                                                 */
/* This entry  does a generalized  formatting of a  Multics standard         */
/* calendar  clock  value.   A   format  string  is  supplied  which         */
/* describes the layout and content of the desired result.  The zone         */
/* and/or  language in  which the result  is to be  displayed may be         */
/* specified.                                                                */
/*                                                                           */
/* USAGE:                                                                    */
/*    dcl date_time_$format entry(char (*), fixed bin (71), char             */
/*       (*), char (*)) returns char (250) var;			       */
/*    result = date_time_$format (format, clock, zone, lang);	       */
/*                                                                           */
/* ARGUMENTS:                                                                */
/* format (input)                                                            */
/*    either a keyword, or an ioa-like control string describing the         */
/*    desired  result in  terms of literal  characters and date/time         */
/*    selectors.                                                             */
/* clock (input)                                                             */
/*    a clock value to be displayed                                          */
/* zone (input)                                                              */
/*    the  short  name of  the zone  in which  output time  value is         */
/*    expressed.  "system_zone"  means use the  system default zone.         */
/*    "" means use the per-process default zone.                             */
/* lang (input)                                                              */
/*    the language  in which month  names, day names  and time zones         */
/*    are  expressed.   "system_lang" means  use the  system default         */
/*    time  language.  ""  means use  per-process default  time lan-         */
/*    guage.                                                                 */
/* result (output)                                                           */
/*    is the string which is the result of the conversion.                   */
/*                                                                           */
/* NOTES:                                                                    */
/* The control string to date_time_$format  is either a keyword or a         */
/* character  string  consisting  of  text  and/or  selectors.   The         */
/* selectors are always identified by a leading circumflex character         */
/* (^).  There are 2 types  of selectors; ^<keyword>, which allows a	       */
/* keyword to be imbedded within a format, and the general form ^XX.	       */
/* XX is a 2 letter code which specifies what information is wanted.	       */
/* An optional PL/I picture specification  may be placed between the	       */
/* ^ and  XX if the  default form is  not adequate.  If  the control	       */
/* string does  not contain any circumflex  characters, it must then	       */
/* be one  of the known  set of keywords.   See Multics Programmers'	       */
/* Reference Manual for a description of acceptable strings.	       */
/*							       */
/* Each selector is introduced by a "^", ended with a 2-letter specifier,    */
/* and may have a picture specification in between.  Because of minute/month */
/* ambiguity, all time selectors are capitals.			       */
/*							       */
/*							       */
/*    The selectors of numeric data are made up of 2 letters taken from      */
/*    this sequence:					       */
/*                            c y m w d H M S U			       */
/*    These are calendar, year, month, week, day, Hour, Minute, Second,      */
/*    and  microsecond.  All  81 combinations are  not, however, valid.      */
/*    The form can generally be read as "unit of unit".  The first unit      */
/*    must always  be smaller than  the second one.  In  trying to keep      */
/*    the  specifiers  reasonably  mneumonic  (in English)  there  is a      */
/*    problem.  Both month and minute begin  with an "m".  To that end,      */
/*    all  date values  are used as  lower case letters  while all time      */
/*    values are in upper case.				       */
/*							       */
/*    It proves difficult to try to handle all the forms needed without      */
/*    any  glitches.  "hd"  is Hour  in Day  and is  thus 24-hour time.      */
/*    This is  not always what  is wanted.  "Hh"  is chosen as  Hour in      */
/*    half-day to get the 12-hour form  of time.  To go along with this      */
/*    there is "mi"  for Meridiem Indicator.  This gives  "A" or "P" to      */
/*    make up AM  or PM.  This does not give  "AM" or "PM" because ANSI      */
/*    standards  specify that  time be given  as "3P",  not "3PM".  The      */
/*    user   who  wants  the M  will  just add it, i.e. "^miM".	       */
/*							       */
/*    This  table shows  the complete  set of  control codes.   The row      */
/*    specifies what  unit is wanted, the  column specifies within what      */
/*    other unit, i.e.  ^Sy is "Seconds of Year".			       */ %skip (3);
/*                                  DATE/TIME SELECTORS		       */
/*           | of   | of   | of   | of   | of   | of   | of   | of   |       */
/*           |calen-|year  |month |week  | day  |hour  |minute|second|       */
/*    _______| dar  |      |      |      |      |      |      |      |       */
/*    micro- +------+------+------+------+------+------+------+------+       */
/*    second | ^Uc  | ^Uy  | ^Um  | ^Uw  | ^Ud  | ^UH  | ^UM  | ^US  |       */
/*           +------+------+------+------+------+------+------+------+       */
/*    second | ^Sc  | ^Sy  | ^Sm  | ^Sw  | ^Sd  | ^SH  | ^SM  |	       */
/*           +------+------+------+------+------+------+------+	       */
/*    minute | ^Mc  | ^My  | ^Mm  | ^Mw  | ^Md  | ^MH  |		       */
/*           +------+------+------+------+------+------+		       */
/*      hour | ^Hc  | ^Hy  | ^Hm  | ^Hw  | ^Hd  |			       */
/*           +------+------+------+------+------+			       */
/*       day | ^dc  | ^dy  | ^dm  | ^dw  |        month    day    zone       */
/*           +------+------+------+------+      +------+------+------+       */
/*     month |      | ^my  |             name   | ^mn  | ^dn  | ^zn  |       */
/*           +------+------+                    +------+------+------+       */
/*      year | ^yc  |                    abbrev | ^ma  | ^da  | ^za  |       */
/*           +------+                           +------+------+------+       */
/*           | ^Hh  | <-hour of half-day      differential    | ^zd  |       */
/*           +------+    (12 hour form)			  +------+       */
/*           | ^mi  | <-meridiem indicator			       */
/*           +------+					       */
/*	   | ^fw  | <-fiscal week (form: yyyyww)		       */
/*           +------+					       */
/*	   | ^fi  | <-fiscal indicator  ^fi^fw => FW318		       */
/*           +------+					       */

/* The optional picture is an enhanced PL/I picture.  In addition to the     */
/*  normal characters, "X", "O" & "Z" are also available.  Due to a conflict */
/*  with selectors (and it isn't very useful in this application) the	       */
/*  letters "dy" will give errors.				       */

/* "X" represents an optional character position in the displayed value.     */
/*     The character position is omitted if there is no corresponding	       */
/*     character in the value being displayed.  They must appear as the      */
/*     rightmost character positions in the picture specification, since     */
/*     this is the position in which nonsignificant spaces can occupy.       */
/*     This causes a selective ltrim operation on the displayed value.       */
/*     A selective trim means not all characters are removed, only up to the */
/*     number specified.					       */

/* "O" represents a truncated digit in the displayed value.  This allows a   */
/*     user to specify OO99 to get the year in century or OOO9 to get the    */
/*     year in decade. "O"s may appear anywhere in a picture specification.  */
/*     They are processed as "9" characters and the corresponding characters */
/*     in the result are dropped.				       */

/* "Z" represents a decimal digit in the displayed value.  Nonsignificant    */
/*     zeros to the left of the decimal point are omitted from the displayed */
/*     value when they occupy a "Z" digit position. Nonsignificant zeros to  */
/*     the right of the decimal point are omitted from the displayed value   */
/*     when they occupy a "Z" digit position. "Z" characters must appear as  */
/*     the leftmost or rightmost digit positions in a picture specification, */
/*     since these are the positions which nonsignificant zeros can occupy.  */
/*     This causes a selective ltrim or rtrim (of zero) operation on the     */
/*     displayed value.					       */ %skip (4);
/* This is a comparison of the characters which make up pictures with the    */
/*  characters which make up selectors:				       */
/*     "alphabet"	list of characters for reference		       */
/*     "enhanced"	enhanced picture characters			       */
/*     "selector1"	selector characters which appear 1st in pair	       */
/*     "selector2"	selector characters which appear 2nd in pair	       */
/*     "excluded"	regular picture characters excluded thru conflict	       */
/*							       */
/* alphabet    ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz	       */
/* selector1   .......H....M.....S.U..... ...d.f......m...........yz	       */
/* selector2   .......H....M.....S....... a.cd...hi...mn........w.y	       */
/* enhanced    ..............O........X.Z abcdef....k.......s..v.xyz9.,-+/   */
/* excluded    ..............................d....................y.......   */
/* **** Special casing allows f and z to be picture characters even though   */
/*  they are selector1 characters.				       */
/* ***********************************+************************************* */ %skip (2);
format: entry (format, clock_value, zone, language) returns (char (250)var);

/* format: off						       */
dcl (
  format		char (*),		/* ctl str specifying output     [In]*/
/*clock_value	fixed bin (71)	/* standard clock value 	   [In]*/
  zone		char (*),		/* specify output in this zone   [In]*/
  language	char (*)		/* specify output in this lang   [In]*/
    )		parm;		/* format: on		       */

        temp_clock = clock_value;
        
format_rtn: begin;			/* <<##>> */
dcl (
    error_table_$dt_unknown_time_language, /* <##> */
    error_table_$unknown_zone		/* <##> */
    )		fixed bin (35) ext static;
dcl sub_err_	entry() options(variable);

      testing_format, format_max = "0"b;
      errloc, errlocad.n, lcode = 0;	/* assume no errors.	       */
      lformat = format;		/* copy in his format string	       */
      if (time_defaults_$zone_delta = -1)
      then call date_time_$set_time_defaults;
      lang_index = get_word_index ((language), Language_table);
      if lang_index < 1
      then do;
         lcode = binary (error_table_$dt_unknown_time_language);
signal_sub_err_:
         call sub_err_ (lcode, "date_time_$format", ACTION_CANT_RESTART,
	  null (), 0, "^[
Format is: ""^a""^[ (^a)
 error at: ^vx^^^vx^^^;^3s
 error at: ^vx^^^]^]",
	  (errloc > 0), format,
	   (format ^= lformat), lformat, errloc, 
	   length(format) - errloc + length(" (") + 
	     errlocad.unadjusted_errloc,
	   errloc);
      end;
      zone_index = get_word_index ((zone), Zone_table);
      if zone_index < 1
      then do;
         if (verify (zone, "-+0123456789") ^= 0)
         then do;
	  lcode = binary (error_table_$unknown_zone);
	  goto signal_sub_err_;
         end;
         zone_index = 0;
      end;
      call Multics_2_vc (temp_clock, (zone), zone_index, lang_index, cal_val);
      if (lcode ^= 0)
      then goto signal_sub_err_;
      call do_format;
      if (lcode ^= 0)
      then goto signal_sub_err_;
%include sub_err_flags;
      end format_rtn;		/* <##> */
      return (lresult);
exit:				/* let anybody use this to get out   */
      return;
lcode_err_exit:
      code = lcode;
      return;			/* @@END format		       */%skip(2);
/* @@@@@@ ext proc .. format_max_length				       */
/*                                                                           */
/* ENTRY:  date_time_$format_max_length                                      */
/*                                                                           */
/* This entry returns the length of the biggest strings which can	       */
/* result from the given format string.				       */
/*                                                                           */
/* USAGE:                                                                    */
/*    dcl date_time_$format_max_length entry (char (*), char (*), char (*))  */
/*       returns (fixed bin);                                                */
/*    maxl = date_time_$format_max_length (format, zone, lang);	       */
/*                                                                           */
/* ARGUMENTS:                                                                */
/* format (input)                                                            */
/*    either a keyword, or an ioa-like control string describing the         */
/*    desired  result in  terms of literal  characters and date/time         */
/*    selectors.                                                             */
/* zone (input)                                                              */
/*    the  short  name of  the zone  in which  output time  value is         */
/*    expressed.  "system_zone"  means use the  system default zone.         */
/*    "" means use the per-process default zone.                             */
/* lang (input)                                                              */
/*    the language  in which month  names, day names  and time zones         */
/*    are  expressed.   "system_lang" means  use the  system default         */
/*    time  language.  ""  means use  per-process default  time lan-         */
/*    guage.                                                                 */
/* maxl (output)						       */
/*    is the length of the longest string which could result	       */
/*                                                                           */
/* NOTES:                                                                    */
/* Errors are reported in the same manner as date_time_$format.	       */

format_max_length: entry (format, zone, language) returns (fixed bin);

dcl format_max	bit (1);

fmt_max: begin;			/* <<##>> */
dcl (
    error_table_$dt_unknown_time_language, /* <##> */
    error_table_$unknown_zone		/* <##> */
    )		fixed bin (35) ext static;

      format_max = "1"b;
      testing_format = ""b;
      errloc, errlocad.n, lcode = 0;	/* assume no errors.	       */
      lformat = format;
      if (time_defaults_$zone_delta = -1)
      then call date_time_$set_time_defaults;
      lang_index = get_word_index ((language), Language_table);
      if lang_index < 1
      then do;
         lcode = binary (error_table_$dt_unknown_time_language);
         goto sub_err_return_0;
      end;
      zone_index = get_word_index ((zone), Zone_table);
      if zone_index < 1
      then do;
         lcode = binary (error_table_$unknown_zone);
         goto sub_err_return_0;
      end;
      Ptime_value = addr (decoded_clock); /* point to a structure	       */
      time_value.yc = 9999;		/* plug in a funny set of values     */
      time_value.my = 12;		/* The exact values are arbitrary,   */
      time_value.dm = 28;		/* ...but they all have no leading   */
      time_value.Hd = 12;		/* ...or trailing "0"s	       */
      time_value.MH = 34;
      time_value.SM = 56;
      time_value.US = 987654;
      time_value.fw = 198432;
      time_value.dy = 365;
      time_value.dc = 3652061;
      time_value.Uc = 315538070399999999;
      time_value.za = zone;
      time_value.zone_index = zone_index;
      time_value.leap_year = 0;

      call do_format$direct;
      if (lcode ^= 0)
      then goto sub_err_return_0;
      end fmt_max;
      return (length (lresult));%skip(5);
sub_err_return_0: begin;
         call sub_err_ (lcode, "date_time_$format_max_length", ACTION_CANT_RESTART,
	  null (), 0, "^[
Format is: ""^a""^[ (^a)
 error at: ^vx^^^vx^^^;^3s
 error at: ^vx^^^]^]",
	  (errloc > 0), format,
	   (format ^= lformat), lformat, errloc, 
	   length(format) - errloc + length(" (") + 
	     errlocad.unadjusted_errloc,
	   errloc);
dcl sub_err_	entry() options(variable);
%include sub_err_flags;
         end sub_err_return_0;
         return (0);%page;
/* @@@@@@ ext proc .. valid_format				       */
/*                                                                           */
/* ENTRY:  date_time_$valid_format                                           */
/*                                                                           */
/* This entry checks the validity of a format string using precisely         */
/* the same tests as date_time_$format.                                      */
/*                                                                           */
/* USAGE:                                                                    */
/*    dcl date_time_$valid_format entry (char (*), fixed bin, fixed          */
/*       bin (35));                                                          */
/*    call date_time_$valid_format (format, errloc, code);                   */
/*                                                                           */
/* ARGUMENTS:                                                                */
/* format (input)                                                            */
/*    either a keyword, or an ioa-like control string describing the         */
/*    desired  result in  terms of literal  characters and date/time         */
/*    selectors.                                                             */
/* errloc (output)                                                           */
/*    is the  character index in  the format string  where the error         */
/*    occured.   This is  meaningful only  if it  and code  are both         */
/*    non-zero.                                                              */
/* code (output)                                                             */
/*    is a standard  status code.  It can have  one of the following         */
/*    values--                                                               */
/*    error_table_$dt_bad_format_selector                                    */
/*    error_table_$bad_conversion				       */
/*    error_table_$dt_no_format_selector                                     */
/*    error_table_$picture_bad                                               */
/*    error_table_$picture_scale                                             */
/*    error_table_$picture_too_big                                           */
/*    error_table_$size_error                                                */
/*    error_table_$unimplemented_version                                     */

valid_format: entry (format, Aerrloc, code);
dcl (
  Aerrloc		fixed bin,	/* char index at error time     [Out]*/
  code		fixed bin (35)	/* return code		  [Out]*/
    )		parm;
dcl testing_format	bit (1);
valid_format_rtn: begin;		/* <<##>> */
      Aerrloc, errloc, errlocad.n = 0;
      testing_format = "1"b;
      format_max = ""b;
      code, lcode = 0;		/* assume no errors.	       */
/**** At this point in date_time_$format you will note that there is a check */
/**** to see if defaults need to be initialized.  Here it must NOT be done.  */
/**** This routine is designed to be able to run without the existence of    */
/**** time_info_.  Default initialization references time_info_.	       */
      lformat = format;		/* copy in his format string	       */
      lang_index = 1;
/**** Use a clock reading which tests all fields for their maximum width.    */
      call Multics_2_vc (
/****^   3124103399999999,		/* 1999-12-31 23:59:59.999999+0930   */
         4503599627370495,		/* 2043-09-17 23:53:47.370495 gmt    */
         "+0930", 0, lang_index, cal_val);
      if (lcode = 0)
      then call do_format;
      code = lcode;
      Aerrloc = errloc;
      return;			/* @@END valid_format	       */
      end valid_format_rtn;		/* <##> */ %page;
/* @@@@@@ ext proc .. from_clock				       */
/* ***********************************+************************************* */
/*							       */
/* ENTRY:  date_time_$from_clock                                             */
/*                                                                           */
/* Given a Multics standard calendar  clock value and an output time         */
/* zone name, return the month, day of the month, the year, the hour         */
/* of the day, the minute of the hour, the second of the minute, the         */
/* number of microseconds, the day in week, the day in year, and the         */
/* day in  clock.  The caller may  specify one of the  time zones in         */
/* the  time_info_  in  which  the  decoded  clock  value  is  to be         */
/* expressed, or may  request that the value be  expressed in one of         */
/* the default time zones.                                                   */
/*                                                                           */
/* USAGE:                                                                    */
/*    dcl date_time_$from_clock entry (fixed bin (71), char (*),             */
/*       ptr, fixed bin (35));                                               */
/*    call date_time_$from_clock (clock, zone, addr(time_value),             */
/*       code);                                                              */
/*                                                                           */
/* ARGUMENTS:                                                                */
/* clock (input)                                                             */
/*    is the clock value to be decoded.                                      */
/* zone (input)                                                              */
/*    the  short  name of  the zone  in which  output time  value is         */
/*    expressed.  "system_zone"  means use the  system default zone.         */
/*    "" means use the per-process default zone.                             */
/* time_value (output)                                                       */
/*    is  the  structure containing  time  parts.  The  structure is         */
/*    defined in time_value.incl.pl1.                                        */
/* code (output)                                                             */
/*    is a standard  status code.  It can have  one of the following         */
/*    values--                                                               */
/*    error_table_$dt_date_too_big                                           */
/*    error_table_$dt_date_too_small                                         */
/*    error_table_$dt_year_too_big                                           */
/*    error_table_$dt_year_too_small                                         */
/*    error_table_$unimplemented_version                                     */
/*    error_table_$unknown_zone                                              */
/*							       */
/* ***********************************+************************************* */ %skip (2);
from_clock: entry (clock_value, zone, APtime_value, code);

/* format: off						       */
dcl (
/*clock_value	fixed bin (71)	/* standard clock value 	   [In]*/
/*zone		char (*)		/* specify output in this zone   [In]*/
  APtime_value	ptr		/* ->output structure	   [In]*/
/*code		fixed bin (35);	/* standard return code	  [Out]*/
    )		parm;		/* format: on		       */

from_clock_rtn: begin;		/* <<##>> */
dcl (
    error_table_$unimplemented_version, /* <##> */
    error_table_$unknown_zone		/* <##> */
    )		fixed bin (35) ext static;

      Ptime_value = APtime_value;	/* Use callers output structure.     */
      if (time_value.version ^= Vtime_value_3) & (time_value.version ^= "3")
      then do;
         code = binary (error_table_$unimplemented_version);
         return;
      end;
      if (time_defaults_$zone_delta = -1)
      then call date_time_$set_time_defaults;
      lang_index = time_defaults_$language_index;
      zone_index = get_word_index ((zone), Zone_table);
      if zone_index < 1		/* zone given is not in table.       */
      then do;
/**** But wait! first check to see if it might be a zone differential	       */
         if (verify (zone, "-+0123456789") ^= 0)
         then do;
	  code = binary (error_table_$unknown_zone);
	  return;
         end;
         zone_index = 0;
      end; %skip (4);
      call Multics_2_vc (clock_value, (zone), zone_index, lang_index, cal_val);
      if (lcode = 0)
      then call fromclock;
      code = lcode;
      return;			/* @@END from_clock		       */
      end from_clock_rtn;		/* <##> */ %page;
/* @@@@@@ ext proc .. from_clock_interval			       */
/* ***********************************+************************************* */
/*							       */
/* ENTRY:  date_time_$from_clock_interval                                    */
/*                                                                           */
/* Given 2 clock values, return  the number of years, months, weeks,         */
/* days,  hours,  minutes, seconds,  and microseconds  between them.         */
/* The set of units to use is  specified, as well as whether any are         */
/* to include the fractional remainder.                                      */
/*                                                                           */
/* USAGE:                                                                    */
/*    dcl date_time_$from_clock_interval entry (fixed bin (71),              */
/*       fixed bin (71), ptr, fixed bin (35));                               */
/*    call date_time_$from_clock_interval (clock1, clock2, addr              */
/*       (time_offsets), code);                                              */
/*                                                                           */
/* ARGUMENTS:                                                                */
/* clock1 (input)                                                            */
/*    is the base  time value.  The output is  expressed relative to         */
/*    this value.                                                            */
/* clock2 (input)                                                            */
/*    is  the offset  time value.   clock1 is  in essence subtracted         */
/*    from this value.  If this value  is later, all results will be         */
/*    positive.   If  this value  is  earlier, all  results  will be         */
/*    negative.                                                              */
/* time_offsets (output)                                                     */
/*    is the structure containing  resulting time values.		       */
/* code (output)                                                             */
/*    is a standard  status code.  It can have  one of the following         */
/*    values--                                                               */
/*    error_table_$dt_bad_day_of_week                                        */
/*    error_table_$dt_bad_dm                                                 */
/*    error_table_$dt_bad_dy                                                 */
/*    error_table_$dt_bad_my                                                 */
/*    error_table_$dt_date_not_exist                                         */
/*    error_table_$dt_date_too_big                                           */
/*    error_table_$dt_date_too_small                                         */
/*    error_table_$dt_no_interval_units                                      */
/*    error_table_$dt_offset_too_big_negative                                */
/*    error_table_$dt_offset_too_big_positive                                */
/*    error_table_$dt_year_too_big                                           */
/*    error_table_$dt_year_too_small                                         */
/*    error_table_$unimplemented_version                                     */
/*							       */
/* ***********************************+************************************* */ %skip (2);
from_clock_interval: entry (Aref_clock, Aoff_clock, APtime_offset, code);

/* format: off						       */
dcl (
  Aref_clock	fixed bin (71),	/* reference time		   [In]*/
  Aoff_clock	fixed bin (71),	/* offset time		   [In]*/
  APtime_offset	ptr		/* ->output structure	   [In]*/
/*code		fixed bin (35)	/* return code		  [Out]*/
    )		parm;		/* format: on		       */

from_clock_interval_rtn: begin;	/* <<##>> */

dcl (
    error_table_$dt_no_interval_units	/* <##> */
    )		fixed bin (35) ext static;

      code, lcode = 0;
      lang_index = 1;		/* force to a valid value	       */
      Ptime_offset = APtime_offset;
      if (unspec (time_offset.flag) = ""b)
      then do;
         code = binary (error_table_$dt_no_interval_units);
         return;			/* gotta select SOME units	       */
      end;
      if (time_defaults_$zone_delta = -1)
      then call date_time_$set_time_defaults;

      time_offset.val.yr, time_offset.val.mo,
         time_offset.val.wk, time_offset.val.da,
         time_offset.val.hr, time_offset.val.min,
         time_offset.val.sec, time_offset.val.Usec = 0;
      t_interval = Aoff_clock - Aref_clock;
      if (t_interval = 0)
      then return;			/* no change		       */

/* ***********************************+************************************* */
/* The difference between the two values is dissected from the largest to    */
/*  the smallest.  The difference between the values is simple for Usec,     */
/*  sec, min, hr, da, and wk. They are always fixed in size.  But yr and mo  */
/*  are not so easy.  For these two, the reference value must be taken into  */
/*  account in order to know how big they are.			       */
/* ***********************************+************************************* */

      if (time_offset.flag.yr > 0)	/* Neither of these cases is nice    */
         | (time_offset.flag.mo > 0)
      then do;
         Ptime_value = addr (decoded_ref);
         call Multics_2_vc (Aref_clock, "gmt", time_info_$gmt_zone_index, 1, ref_val);
         cal_val = ref_val;
         if (lcode = 0)
         then call fromclock$no_FW;	/* decode the reference value	       */
         if (lcode ^= 0)
         then do;
	  code = lcode;
	  return;
         end;
         Ptime_value = addr (decoded_clock);
         call Multics_2_vc (Aoff_clock, "gmt", time_info_$gmt_zone_index, 1, off_val);
         cal_val = off_val;
         if (lcode = 0)
         then call fromclock$no_FW;	/* decode the offset value	       */
         if (lcode ^= 0)
         then do;
	  code = lcode;
	  return;
         end;
         Tyear = decoded_clock.yc - decoded_ref.yc;
         Tmonth = decoded_clock.my - decoded_ref.my;
         Tday = decoded_clock.dm - decoded_ref.dm;
         Tusec =
	  (off_val.x + off_val.dx - (decoded_clock.dc * 864) * 100000000)
	  - (ref_val.x + ref_val.dx - (decoded_ref.dc * 864) * 100000000);

         if (t_interval > 0)		/* (+) interval		       */
         then do;
	  if (Tusec < 0)		/* a day borrow is needed	       */
	  then Tday = Tday - 1;	/* ..so take one		       */
	  if (Tday < 0)		/* a month borrow is needed	       */
	  then Tmonth = Tmonth - 1;	/* ..so take one (days not worked on */
				/*  here, only checked in order to   */
				/*  adjust the month.)	       */
	  if (Tmonth < 0)		/* a year borrow is needed	       */
	  then do;		/* ..so take one		       */
	     Tyear = Tyear - 1;
	     Tmonth = Tmonth + 12;
	  end;
         end;
         else do;			/* (-) interval		       */
	  if (Tusec > 0)		/* need to borrow a day?	       */
	  then Tday = Tday + 1;
	  if (Tday > 0)		/* need to borrow a month?	       */
	  then Tmonth = Tmonth + 1;
	  if (Tmonth > 0)		/* need to borrow a year?	       */
	  then do;
	     Tyear = Tyear + 1;
	     Tmonth = Tmonth - 12;
	  end;
         end;
         unspec (auto_time_offset) = ""b;
         auto_time_offset.version = Vtime_offset_2;
         if (time_offset.flag.yr > 0)
         then do;
	  time_offset.val.yr = Tyear;
	  if (Tyear ^= 0)		/* don't waste my time if there is   */
	  then do;		/* ..no integer portion	       */
	     auto_time_offset.val.yr = Tyear;
	     auto_time_offset.flag.yr = 1;
	     cal_val = ref_val;
	     call apply_offset;
	     ref_val = cal_val;
	     if (lcode ^= 0)
	     then goto lcode_err_exit;
	     Ptime_value = addr (decoded_ref);
	     call fromclock$no_FW;	/* decompose the new value	       */
	     t_interval = off_val.x + off_val.dx - (ref_val.x + ref_val.dx);
				/*  figure interval left	       */
	  end;
/**** We have now set the year value, and removed that much from reference.  */
	  if (time_offset.flag.yr = 2)
	  then do;		/* they want the fraction, too       */
	     if (decoded_ref.yc = 1582)
	     then unit_size = 355;	/* figure out how big the year is    */
	     else unit_size = 365 + decoded_ref.leap_year;
	     time_offset.val.yr = time_offset.val.yr
	        + make_fraction (t_interval, unit_size * microseconds_per_day);
	  end;
         end;
         else Tmonth = Tmonth + 12 * Tyear;

         if (time_offset.flag.mo > 0)
         then do;
	  time_offset.val.mo = Tmonth;
	  if (Tmonth ^= 0)
	  then do;
	     auto_time_offset.flag.yr = 0;
	     auto_time_offset.flag.mo = 1;
	     auto_time_offset.val.mo = Tmonth;
	     cal_val = ref_val;
	     call apply_offset;
	     ref_val = cal_val;
	     if (lcode ^= 0)
	     then goto lcode_err_exit;
	     Ptime_value = addr (decoded_ref);
	     call fromclock$no_FW;	/* decompose the new value	       */
	     t_interval = off_val.x + off_val.dx - (ref_val.x + ref_val.dx);
				/*  figure interval left	       */
	  end;
/**** We have now set the month value, and removed that much from reference. */
	  if (time_offset.flag.mo = FRACTION)
	  then do;
	     unit_size = days_in_month (decoded_ref.my);
	     if (decoded_ref.my = FEBRUARY)
	     then unit_size = unit_size + decoded_ref.leap_year;
	     time_offset.val.mo = time_offset.val.mo
	        + make_fraction (t_interval, unit_size * microseconds_per_day);
	  end;
         end;
      end;
      do cur_unit = 3 to 8;
         if (time_offset_array.flag (cur_unit) > 0)
         then do;
	  unit_size = unit_sizes (cur_unit);
	  fb24 = divide (t_interval, unit_size, 24, 0);
	  t_interval = t_interval - fb24 * unit_size;
	  time_offset_array.val (cur_unit) = fb24;
	  if (time_offset_array.flag (cur_unit) = FRACTION)
	  then do;
	     time_offset_array.val (cur_unit)
	        = time_offset_array.val (cur_unit)
	        + make_fraction (t_interval, unit_size);
	  end;
         end;
      end;
      return;			/* @@END from_clock_interval	       */
      end from_clock_interval_rtn;	/* <##> */ %page;
/* @@@@@@ ext proc .. fstime					       */
/* ***********************************+************************************* */
/*							       */
/* ENTRY:  date_time_$fstime                                                 */
/*                                                                           */
/* This entry  performs the same  function as date_time_$date_time_,         */
/* given a 36-bit storage system date value.                                 */
/*                                                                           */
/* USAGE:                                                                    */
/*    dcl date_time_$fstime entry (bit (36) aligned, char (*));              */
/*    call date_time_$fstime (ssclock, str);                                 */
/*                                                                           */
/* ARGUMENTS:                                                                */
/* ssclock (input)                                                           */
/*    is an internal storage system clock value.                             */
/* str (output)                                                              */
/*    is the resultant character string                                      */
/*							       */
/* ***********************************+************************************* */ %skip (2);
fstime: entry (stime, str);

/* format: off						       */
dcl (
  stime		bit (36) aligned	/* "short" time value 	   [In]*/
/*str		char (*);		/* return string 	            [Out]*/
    )		parm;		/* format: on		       */

      temp_clock = 0;
      addr (temp_clock) -> fs_time_value.time = stime;

date_time_rtn: begin;		/* <<##>> */
      if (time_defaults_$zone_delta = -1)
      then call date_time_$set_time_defaults;
      lang_index = time_defaults_$language_index;
      string (standard) = "00/00/00  0000.0 gmt Tue";
      Ptime_value = addr (decoded_clock);
      time_value.version = Vtime_value_3;
      call Multics_2_vc (temp_clock, (time_defaults_$zone_short), time_defaults_$zone_index,
         lang_index, cal_val);
      if (lcode = 0)
      then call fromclock$no_FW;
      if (lcode = 0)
      then do;
         standard.yy = mod (time_value.yc, 100);
         standard.mm = time_value.my;
         standard.dd = time_value.dm;
         standard.HH = time_value.Hd;
/**** MM is pic "99.9". This statement calculates 10ths of minutes to go     */
/****  into this picture, while being efficient.			       */
         standard.MM = divide (time_value.MH * 60 + time_value.SM, 6, 17);
         standard.zz = substr(time_value.za,1,length(standard.zz));
         standard.da = ti_day.short (lang_index, time_value.dw);
      end;
      str = string (standard);
      return;

dcl 1 standard,
      2 mm	pic "99",
      2 xx1	char (1),		/* "/"			       */
      2 dd	pic "99",
      2 xx2	char (1),		/* "/"			       */
      2 yy	pic "99",
      2 HH	pic "bb99",
      2 MM	pic "99.9b",
      2 zz	char (4),
      2 da	char (3);		/* @@END fstime		       */
      end date_time_rtn;		/* <##> */ %skip (3);
/* @@@@@@ ext func .. get_time_info_index			       */
/* ***********************************+************************************* */
/*							       */
/* Entry: date_time_$get_time_info_index			       */
/*							       */
/* Given a word and a table specifier, return the index that word has        */
/*  in that table.  language and zone defaulting is handled here.	       */
/*							       */
/* Usage							       */
/*	dcl date_time_$get_time_info_index (char (*), bit (6))	       */
/*		returns (fixed bin);			       */
/*							       */
/*	an_index = date_time_$get_time_info_index (word, table);	       */
/*							       */
/* 1) word	is the word to look for.  It will be converted to a      */
/*		token by converting to lower-case. (In)		       */
/* 2) table	is the identifier of the table wanted. (In)	       */
/* 3) an_index	is the index in the specified table of the word.	       */
/*	-1	the word was not found at all.		       */
/*	0	the word was found, but was not in the wanted table.     */
/*							       */
/* *This is used by dti to look up offset and language.		       */
/* *This is used by tdft to look up a zone.			       */
/*							       */
/* convert_date_to_binary_ has its own version of this, both for speed and   */
/*  because its requirements are slightly different.  When it looks up a     */
/*  token, it has no idea what use is intended for it.  That happens later   */
/*  when the parsing is done.					       */
/*							       */
/* ***********************************+************************************* */ %skip (2);
get_time_info_index: entry (Atoken, Atable) returns (fixed bin);

dcl Atoken	char (*),		/* word to look for		       */
    Atable	fixed bin;	/* kind off thing it must be	       */

      return (get_word_index ((Atoken), Atable)); /* @@END get_time_info_index */ %page;
/* @@@@@@ ext proc .. hundredths				       */
/* ***********************************+************************************* */
/*							       */
/* Entry: date_time_$hundredths				       */
/*							       */
/* Given a Multics standard calendar  clock  value,  this  entry  point      */
/*  returns  a formatted  date  in  the form			       */
/*	"^my/^dm/^yc  ^Hd^99v.99MH ^za ^da"			       */
/* For the meaning of this string, see date_time_$format information below.  */
/*							       */
/* Usage							       */
/*							       */
/*        dcl date_time_$hundredths entry(fixed bin(71),char(*));	       */
/*							       */
/*        call date_time_$hundredths (clock,str);			       */
/*							       */
/* 1) clock         is the clock value to be formatted (In)		       */
/* 2) str           is the resultant character string (Out)		       */
/*							       */
/* ***********************************+************************************* */ %skip (2);
hundredths: entry (clock_value, str);

/* format: off						       */
/*clock_value	fixed bin (71)	/* standard clock value 	   [In]*/
/*str		char (*)		/* return string		  [Out]*/
				/* format: on		       */
hundredths_rtn: begin;		/* <<##>> */
      testing_format, format_max = "0"b;
      temp_clock = clock_value;
      lformat = "^my/^dm/^yc  ^Hd^99v.99MH ^xxxxza^xxxda";

      if (time_defaults_$zone_delta = -1)
      then call date_time_$set_time_defaults;
      lang_index = time_defaults_$language_index;
      call Multics_2_vc (temp_clock, (time_defaults_$zone_short), time_defaults_$zone_index,
         lang_index, cal_val);
      if (lcode = 0)
      then call do_format;
      str = lresult;
      return;			/* @@END hundredths		       */
      end hundredths_rtn;		/* <##> */
 %skip (3);
/* @@@@@@ ext proc .. offset_to_clock				       */
/* ***********************************+************************************* */
/*							       */
/* ENTRY:  date_time_$offset_to_clock                                        */
/*                                                                           */
/* This entry point  creates a new Multics clock  value by adjusting         */
/* an input clock  value to a specified day-of-week  and then adding         */
/* relative  date/time  offsets.    The  relative  date/time  values         */
/* include  a year  offset, month  offset, week  offset, day offset,         */
/* hour  offset,  minute  offset,  second  offset,  and  microsecond         */
/* offset.  Any  of these values  may be zero (no  offset from input         */
/* clock  value)  or  negative  (backwards offset  from  input clock         */
/* value).  In addition, an input time zone is specified.                    */
/*                                                                           */
/* USAGE:                                                                    */
/*    dcl date_time_$offset_to_clock entry (ptr, fixed bin (71),             */
/*       char (*), fixed bin (71), fixed bin (35));                          */
/*    call date_time_$offset_to_clock (addr(time_offsets), clock_in,         */
/*       zone, clock, code);                                                 */
/*                                                                           */
/* ARGUMENTS:                                                                */
/* time_offset (input)                                                       */
/*    is  the  structure  containing  time  offsets  to  be  aplied.         */
/*    Structure is defined in time_offsets.incl.pl1                          */
/* clock_in (input)                                                          */
/*    is the clock value to which offsets are applied                        */
/* zone (input)                                                              */
/*    is the zone in which clock_in is to be interpreted                     */
/* clock (output)                                                            */
/*    is the resulting clock value                                           */
/* code (output)                                                             */
/*    is a standard  status code.  It can have  one of the following         */
/*    values--                                                               */
/*    error_table_$dt_bad_day_of_week                                        */
/*    error_table_$dt_bad_dm                                                 */
/*    error_table_$dt_bad_dy                                                 */
/*    error_table_$dt_bad_my                                                 */
/*    error_table_$dt_date_not_exist                                         */
/*    error_table_$dt_date_too_big                                           */
/*    error_table_$dt_date_too_small                                         */
/*    error_table_$dt_offset_too_big_negative                                */
/*    error_table_$dt_offset_too_big_positive                                */
/*    error_table_$dt_year_too_big                                           */
/*    error_table_$dt_year_too_small                                         */
/*    error_table_$unimplemented_version                                     */
/*                                                                           */
/* NOTES:                                                                    */
/*                                                                           */
/* The order of applying  these  offsets  can affect  the  resultant	       */
/* clock  value.   In all cases,  the  order required  by  convert_-	       */
/* date_to_binary_  has been used.  The order is as follows:	       */
/*                                                                           */
/*   1) decode the input clock  value into absolute date/time values         */
/*      specified in  terms of the  input time zone.   This zone may         */
/*      affect the day-of-week represented by the input clock value,         */
/*      and hence, may affect any day-of-week offset adjustment.             */
/*   2) apply  any  day-of-week  offset  by  adding/subtracting days         */
/*      to/from the absolute date  until the day-of-week represented         */
/*      by the decoded clock value equals the specified day-of-week.         */
/*   3) apply  any  year  offset  to the  decoded  clock  value.  If         */
/*      applying  the year  offset results  in a  non-existant date,         */
/*      then use the previous  existing day, e.g.  "1583-10-10 -1yr"         */
/*      would yield 1582-10-04.                                              */
/*   4) apply  any  month offset  to  the decoded  clock  value.  If         */
/*      applying  the month  offset results in  a non-existent date,         */
/*      then use the  last day of the month  (taking leap years into         */
/*      account),  e.g.   "Jan 31  3 months"  would yield  April 31.         */
/*      instead.                                                             */
/*   5) apply  the day  offset, hour  offset, minute  offset, second         */
/*      offset, and microsecond offset.                                      */
/*   6) encode the  resultant absolute date/time  specification into         */
/*      the output clock value.                                              */
/*							       */
/* ***********************************+************************************* */ %skip (2);
offset_to_clock: entry (APtime_offset, clock_in_value, zone, clock_value, code);

/* format: off						       */
dcl (
/*APtime_offset	ptr		/* ->input structure	   [In]*/
  clock_in_value	fixed bin (71)	/* clock value 		   [In]*/
/*zone		char (*)		/* for clock_in_value	   [In]*/
/*clock_value	fixed bin (71)	/* adjusted clock value 	  [Out]*/
/*code		fixed bin (35)	/* standard return code	  [Out]*/
    )		parm;		/* format: on		       */

/* ***********************************+************************************* */
/*  Adjust a given clock value by applying a given set of offsets	       */
/*							       */
/* 	Begin by decoding input clock value into month, day, year, etc.    */
/*  Then add offset input arguments to these decoded values.  Finally,       */
/*  encode the sums.					       */
/*							       */
/* ***********************************+************************************* */

offset_to_clock_rtn: begin;		/* <<##>> */
dcl (
    error_table_$unimplemented_version	/* <##> */
    )		fixed bin (35) ext static;

      code, lcode = 0;
      Ptime_offset = APtime_offset;
      if time_offset.version ^= Vtime_offset_2
      then do;
         code = binary (error_table_$unimplemented_version);
         return;
      end;
      auto_time_offset = time_offset;	/* we want to modify structure       */
      call Multics_2_vc (clock_in_value, (zone),
         get_word_index ((zone), Zone_table), 1, cal_val);
      if (lcode = 0)
      then call apply_offset;
      if (lcode = 0)
      then call vc_2_Multics (cal_val, clock_value);
      code = lcode;
      return;			/* @@END offset_to_clock	       */
      end offset_to_clock_rtn;	/* <##> */ %page;
/* @@@@@@ ext func .. decimal_date_time_			       */
/* ***********************************+************************************* */
/* ***********************************+************************************* */
decimal_date_time_: entry (clock_value, str);
      ddt_sw = "1"b;
      goto request_id_rtn;

dcl ddt_sw	bit (1); %skip (5);
/* @@@@@@ ext func .. request_id_				       */
/* ***********************************+************************************* */
/*                                                                           */
/* ENTRY:  date_time_$request_id_                                            */
/*                                                                           */
/* Given a Multics standard clock  value, this entry point returns a         */
/* char(19)   formatted  date   (expressed  in  GMT)   in  the  form         */
/* "^yc^my^dm^Hd^MH^99.999999UM" (e.g.   830718105806.808512).  This         */
/* is a request id as used by ear and eor.                                   */
/*                                                                           */
/* USAGE:                                                                    */
/*    dcl date_time_$request_id_ entry(fixed bin (71)) returns (char         */
/*       (19));                                                              */
/*    result = date_time_$request_id_ (clock);                               */
/*                                                                           */
/* ARGUMENTS:                                                                */
/* clock (input)                                                             */
/*    is the clock value to be formatted                                     */
/* result (output)                                                           */
/*    is the resultant character string                                      */
/*                                                                           */
/* ***********************************+************************************* */

request_id_: entry (clock_value) returns (char (19));

/* format: off						       */
/*clock_value	fixed bin (71);	/* standard clock value 	   [In]*/
				/* format: on		       */

      ddt_sw = "0"b;
request_id_rtn: begin;		/* <<##>> */
      lcode = 0;
      Ptime_value = addr (decoded_clock);
      if (time_defaults_$zone_delta = -1)
      then call date_time_$set_time_defaults;
      lang_index = time_defaults_$language_index;
      call Multics_2_vc (clock_value, "gmt", time_info_$gmt_zone_index,
         lang_index, cal_val);
      if (lcode = 0)
      then call fromclock$no_FW;
      if (lcode ^= 0)
      then string (rqid) = "0000000000000000000";
      else do;
         pic4 = time_value.yc;
         rqid.yc = substr (pic4, 3, 2);
         rqid.my = time_value.my;
         rqid.dm = time_value.dm;
         rqid.Hd = time_value.Hd;
         rqid.MH = time_value.MH;
         rqid.SM = time_value.SM;
         rqid.US = time_value.US;
      end;
      end request_id_rtn;	
      if ^ddt_sw
      then return (string (rqid));
      str = string (rqid);
      return;

dcl 1 rqid,
      2 yc	char (2),
      2 (my, dm, Hd, MH, SM) pic "99",
      2 US	pic ".999999";	/* @@END request_id_	       */
				/* <##> */ %page;
/* @@@@@@ ext proc .. set_lang				       */
/* ***********************************+************************************* */
/*							       */
/* ENTRY:  date_time_$set_lang                                               */
/*                                                                           */
/* This entry sets or resets the user's default time language.               */
/*                                                                           */
/* USAGE:                                                                    */
/*    dcl date_time_$set_lang entry(char (*), fixed bin (35));               */
/*    call date_time_$set_lang (lang, code);                                 */
/*                                                                           */
/* ARGUMENTS:                                                                */
/* lang (input)                                                              */
/*    the language which is to be made current.  "system_lang" means         */
/*    use the system default time language.                                  */
/* code (output)                                                             */
/*    is a standard  status code.  It can have  one of the following         */
/*    values--                                                               */
/*    error_table_$dt_unknown_time_language                                  */
/*							       */
/* ***********************************+************************************* */ %skip (2);
/* ------------------------------------------------------------------------- */
/*	   Note that this setting does not affect lower rings.	       */
/* ------------------------------------------------------------------------- */
set_lang: entry (new_str, code);

/* format: off						       */
dcl new_str	char (*);		/* candidate language name	   [In]*/
/*code		fixed bin (35);    	/* error code		  [Out]*/
				/* format: on		       */
set_lang_rtn: begin;		/* <<##>> */
dcl (
    error_table_$dt_unknown_time_language  /* <##> */
    )		fixed bin (35) ext static;

      if (time_defaults_$zone_delta = -1)
      then call date_time_$set_time_defaults;
      code = 0;
      if new_str = ""		/* Reset to system default time      */
         | new_str = "system_lang"	/*  language.		       */
      then do;
         time_defaults_$language_index, lang_index
	  = time_info_$default_language_index;
         time_defaults_$language = ti_language.name (lang_index, lang_index);
      end;
      else do;
/**** Convert user-supplied lang name to index.			       */
         lang_index = get_word_index ((new_str), Language_table);
         if lang_index < 1		/* Name not found in	       */
				/*  time_info_$language_names?       */
         then code = binary (error_table_$dt_unknown_time_language);
         else do;
	  time_defaults_$language
	     = ti_language.name (lang_index, lang_index);
	  time_defaults_$language_index = lang_index;
         end;
      end;
      return;			/* @@END set_lang		       */
      end set_lang_rtn;		/* <##> */ %page;
/* @@@@@@ ext proc .. set_time_defaults				       */
/* ***********************************+************************************* */
/* ***********************************+************************************* */
/* ------------------------------------------------------------------------- */
/*	   Note that this setting does not effect lower rings.	       */
/* ------------------------------------------------------------------------- */
set_time_defaults: entry;

set_time_defaults_rtn: begin;		/* <<##>> */
dcl (
    error_table_$unimplemented_version	/* <##> */
    )		fixed bin (35) ext static;

      if time_info_$version ^= Vtime_info_2 /* Make sure we know format of   */
      then do;			/*  time_info_.		       */
         call com_err_ (error_table_$unimplemented_version,
	  "date_time_$set_time_defaults",
	  "^/Version ^a of the time_info_ is not supported.",
	  time_info_$version);
         return;
      end;
/**** Set process default formats				       */
      time_defaults_$date_time = ti_keyword.str (site_date_time);
      time_defaults_$date = ti_keyword.str (site_date);
      time_defaults_$time = ti_keyword.str (site_time);


/**** Set default time language.				       */
      time_defaults_$language_index, lang_index
         = time_info_$default_language_index;
      time_defaults_$language = ti_language.name (lang_index, lang_index);

/**** Set default time zone. These are the situations where this routine     */
/****  will be called.					       */
/**** 1) scs_and_init_clocks initializes sys_info_$time_zone (and then comes */
/****    back later under some condition).  If $zone_index <1 it CRASHes.    */
/**** 2) init_clocks sets sys_info$time_zone from the BOS CLOK config	       */
/****    parameter and then calls set_time_defaults.  Then if $zone_index    */
/****    is <1, it will ABORT so that the operator can set a known zone.     */
/**** 3) Anyplace else.  Since the system could not come up with an unknown  */
/****    zone in sys_info_, it isn't necessary to check for its being found. */

      zone_index = get_word_index ((sys_info$time_zone), Zone_table);

      time_defaults_$zone_index = zone_index;
      if (zone_index < 1)
      then zone_index = time_info_$gmt_zone_index;
      time_defaults_$zone_delta = ti_zone.delta (lang_index, zone_index);
      time_defaults_$zone_short = ti_zone.short (lang_index, zone_index);
      time_defaults_$zone_long = ti_zone.long (lang_index, zone_index);
      return;			/* @@END set_time_defaults	       */
      end set_time_defaults_rtn;	/* <##> */ %page;
/* @@@@@@ ext proc .. set_zone				       */
/* ***********************************+************************************* */
/*							       */
/* ENTRY:  date_time_$set_zone                                               */
/*                                                                           */
/* This entry sets or resets the user's default zone.                        */
/*                                                                           */
/* USAGE:                                                                    */
/*    dcl date_time_$set_zone entry(char (*), fixed bin (35));               */
/*    call date_time_$set_zone (zone, code);                                 */
/*                                                                           */
/* ARGUMENTS:                                                                */
/* zone (input)                                                              */
/*    the  short  name of  the  zone which  is  to be  made current.         */
/*    "system_zone" means use the system default zone.                       */
/* code (output)                                                             */
/*    is a standard  status code.  It can have  one of the following         */
/*    values--                                                               */
/*    error_table_$unknown_zone                                              */
/*							       */
/* ***********************************+************************************* */ %skip (2);
/* ------------------------------------------------------------------------- */
/*	   Note that this setting does not effect lower rings.	       */
/* ------------------------------------------------------------------------- */
set_zone: entry (new_str, code);

/* format: off						       */
/*new_str		char (*);		/* candidate zone name	   [In]*/
/*code		fixed bin (35);    	/* error code		  [Out]*/
				/* format: on		       */
set_zone_rtn: begin;		/* <<##>> */
dcl (
    error_table_$unknown_zone		/* <##> */
    )		fixed bin (35) ext static;

      if (time_defaults_$zone_delta = -1)
      then call date_time_$set_time_defaults;
      if new_str = ""		/* Restore system default time zone. */
         | new_str = "system_zone"
      then zone_index = get_word_index ((sys_info$time_zone), Zone_table);
      else do;
         zone_index = get_word_index ((new_str), Zone_table);
         if zone_index < 1		/* Conversion failed?	       */
         then do;
	  code = binary (error_table_$unknown_zone);
	  return;
         end;
      end;
      lang_index = time_defaults_$language_index;
      time_defaults_$zone_short = ti_zone.short (lang_index, zone_index);
      time_defaults_$zone_delta = ti_zone.delta (lang_index, zone_index);
      time_defaults_$zone_long = ti_zone.long (lang_index, zone_index);
      time_defaults_$zone_index = zone_index;
      code = 0;
      return;			/* @@END set_zone		       */
      end set_zone_rtn;		/* <##> */ %page;
/* @@@@@@ ext proc .. to_clock				       */
/* ***********************************+************************************* */
/*							       */
/* ENTRY:  date_time_$to_clock                                               */
/*                                                                           */
/* Given any  or all of  the following- years,  months, days, hours,         */
/* minutes, seconds, microseconds, day in  week, day in year, or day         */
/* in  clock, returns  a standard  clock value  which represents the         */
/* encoding  of these  values.  All the  values must  be valid, i.e.         */
/* hours ^> 23, etc.                                                         */
/*                                                                           */
/* USAGE:                                                                    */
/*    dcl date_time_$to_clock entry (ptr, fixed bin (71), fixed bin          */
/*       (35));                                                              */
/*    call date_time_$to_clock (addr (time_value), clock, code);             */
/*                                                                           */
/* ARGUMENTS:                                                                */
/* time_value (input)                                                        */
/*    is  the  structure containing  time  parts.  The  structure is         */
/*    defined in time_value.incl.pl1.                                        */
/* clock (output)                                                            */
/*    is the encoded clock value                                             */
/* code (output)                                                             */
/*    is a standard  status code.  It can have  one of the following         */
/*    values--                                                               */
/*    error_table_$bad_time                                                  */
/*    error_table_$dt_bad_day_of_week                                        */
/*    error_table_$dt_bad_dm                                                 */
/*    error_table_$dt_bad_dy                                                 */
/*    error_table_$dt_bad_my                                                 */
/*    error_table_$dt_conflict                                               */
/*    error_table_$dt_date_not_exist                                         */
/*    error_table_$dt_date_too_big                                           */
/*    error_table_$dt_date_too_small                                         */
/*    error_table_$unimplemented_version                                     */
/*    error_table_$unknown_zone                                              */
/*                                                                           */
/* NOTES:                                                                    */
/* "day"  (as  opposed  to "time")  data  is only  valid  in certain         */
/* combinations.  This table shows with  the *'s which fields may be         */
/* present together.  All others must be zero.                               */
/*                                                                           */
/*                 +-1-+-2-+-3-+-4-+                                         */
/*   time_value.yc | * | * |   |   |  In cases 1, 2, & 4, if dw is           */
/*   time_value.my | * |   |   |   |  present,  it is used to verify         */
/*   time_value.dm | * |   |   |   |  the value converted.                   */
/*   time_value.fw |   |   | * |   |                                         */
/*   time_value.dw |   |   |(*)|   |  In case 3 it actually defines          */
/*   time_value.dy |   | * |   |   |  a day.  If not present, Monday         */
/*   time_value.dc |   |   |   | * |  is assumed.                            */
/*                 +-v-+-v-+-v-+-v-+                                         */
/*                   |   |   |   +-clock_days = dc                           */
/*                   |   |   +-----clock_days = converted (fw,dw)            */
/*                   |   +---------clock_days = converted (yc,dy)            */
/*                   +-------------clock_days = converted (yc,my,dm)         */
/*							       */
/* ***********************************+************************************* */
to_clock: entry (APtime_value, clock_value, code);

/* format: off						       */
/*APtime_value	ptr		/* ->input structure.	   [In]*/
/*clock_value	fixed bin (71)	/* standard clock value	  [Out]*/
/*code		fixed bin (35)	/* standard return code	  [Out]*/
				/* format: on		       */

to_clock_rtn: begin;		/* <<##>> */
dcl (
    error_table_$bad_time,		/* <##> */
    error_table_$dt_bad_day_of_week,	/* <##> */
    error_table_$dt_bad_fw,		/* <##> */
    error_table_$dt_conflict,		/* <##> */
    error_table_$dt_date_too_big,	/* <##> */
    error_table_$dt_date_too_small,	/* <##> */
    error_table_$unknown_zone,	/* <##> */
    error_table_$unimplemented_version	/* <##> */
    )		fixed bin (35) ext static;
dcl combination	bit(6);
dcl fiscal_day_value fixed bin;


      Ptime_value = APtime_value;	/* point to caller's data	       */
      day_adjust = 0;
      if (time_value.Hd = 24) | (time_value.fw ^= 0)
      then do;			/* will need to modify the data,     */
         auto_time_value = time_value;	/* ..so make a copy.	       */
         Ptime_value = addr (auto_time_value);
         if (time_value.Hd = 24)
         then do;
	  time_value.Hd = 0;
	  day_adjust = 1;
         end;
      end;
      code, lcode = 0;
      if (time_value.version ^= Vtime_value_3) & (time_value.version ^= "3")
      then do;
         code = binary (error_table_$unimplemented_version);
         return;
      end;
      if (time_defaults_$zone_delta = -1)
      then call date_time_$set_time_defaults;
      lang_index = time_defaults_$language_index;

      if time_value.dw < 0		/*  0 ==> no check		       */
         | time_value.dw > 7		/* 1=Mon <= day_in_week <= 7=Sun;    */
      then do;
         code = binary (error_table_$dt_bad_day_of_week);
         return;
      end;
      if time_value.Hd < 0
         | time_value.Hd > 23		/* 24 hours per day		       */
         | time_value.MH < 0
         | time_value.MH > 59		/* 60 minutes per hour	       */
         | time_value.SM < 0
         | time_value.SM > 59		/* 60 seconds per minute	       */
         | time_value.US < 0
         | time_value.US >= 1000000
      then do;
         code = binary (error_table_$bad_time);
         return;
      end;
      if time_value.yc > 9999
      then goto toobig;

      substr (combination, 1, 1) = (time_value.yc ^= 0);
      substr (combination, 2, 1) = (time_value.my ^= 0);
      substr (combination, 3, 1) = (time_value.dm ^= 0);
      substr (combination, 4, 1) = (time_value.fw ^= 0);
      substr (combination, 5, 1) = (time_value.dy ^= 0);
      substr (combination, 6, 1) = (time_value.dc ^= 0);
      if (     combination = "111000"b)	/* year,month,day		       */
         | (   combination = "100010"b)	/* year,day-in-year		       */
      then do;
         call ymd_to_days;
         if (lcode ^= 0)
         then goto to_clock_exit;
      end;
      else if (combination = "000100"b) /* fiscal week		       */
      then do;
         fiscal_year_value = divide (time_value.fw, 100, 17, 0);
         fiscal_week_value = time_value.fw - fiscal_year_value * 100;
         if (fiscal_week_value < 1)
         then do;
err_dt_bad_fw:
	  code = binary (error_table_$dt_bad_fw);
	  return;
         end;
         time_value.yc = fiscal_year_value;
retry_fw:
         time_value.my = 1;
         time_value.dm = 1;
         call ymd_to_days;
         fiscal_day_value =		/*  yields   1=Mon ... 7=Sun	       */
	  (lclock_days + 4) - divide ((lclock_days + 4), 7, 11) * 7 + 1;
         time_value.my, time_value.dm = 0;
         time_value.dy = fiscal_week_value * 7 - fiscal_day_value - 5;
         if (fiscal_day_value > 4)
         then time_value.dy = time_value.dy + 7;
         if (time_value.dy < 1)
         then do;			/* FW[first] is in last year,	       */
	  fiscal_week_value = 53;	/* ..back up		       */
	  time_value.yc = time_value.yc - 1;
	  goto retry_fw;		/* ..and recalculate	       */
         end;
         if (time_value.dy > 366)
         then do;			/* years don't get that big	       */
	  if (time_value.yc = fiscal_year_value)
	  then goto err_dt_bad_fw;	/* user can't say that	       */
	  else time_value.dy = time_value.dy - 7; /* (but I can)	       */
         end;
         call ymd_to_days;
         if (lcode ^= 0)
         then goto to_clock_exit;
         if (time_value.dw ^= 0)	/* adjust to day-of-week given       */
         then lclock_days = lclock_days + time_value.dw -1;
         time_value.dw = 0;
      end;
      else if (combination = "000001"b) /* day-in-clock		       */
      then do;
         if (time_value.dc < 1)
         then do;
	  code = binary (error_table_$dt_date_too_small);
	  return;
         end;
         if (time_value.dc > 0)
         then if time_value.dc > 3652061 - day_adjust
         then do;
toobig:
	  code = binary (error_table_$dt_date_too_big);
	  return;
         end;
         lclock_days = time_value.dc;	/* ready to go		       */
         cal_val.J_G = None;
      end;
      else do;
         code = binary (error_table_$dt_conflict);
         return;
      end;

      lclock_days = lclock_days + day_adjust;

      zone_index = get_word_index ((time_value.za), Zone_table);
      if (zone_index < 1)
      then do;
         if (verify (time_value.za, "-+0123456789") ^= 0)
         then do;
	  code = binary (error_table_$unknown_zone);
	  return;
         end;
         zone_index = 0;
         cal_val.z = time_value.za;
         cal_val.dx
	  = convert (cal_val.dx, substr (cal_val.z, 2, 2)) * 3600000000
	  + convert (cal_val.dx, substr (cal_val.z, 4, 2)) * 60000000;
         if (substr (cal_val.z, 1, 1) = "+")
         then cal_val.dx = -cal_val.dx;
/****    This negates on "+" instead of "-" because our internal use of      */
/****    zone offsets is opposite that of a zone differential.	       */
      end;
      else do;
         cal_val.z = ti_zone.short (lang_index, zone_index);
         cal_val.dx = ti_zone.delta (lang_index, zone_index);
      end;
      time_value.zone_index = zone_index;

      cal_val.zi = zone_index;	/* format: off		       */
      cal_val.x = (         time_value.US
         +       1000000 * (time_value.SM
         +            60 * (time_value.MH
         +            60 * (time_value.Hd
         + precision (24 * (lclock_days - 1), 27))))); /* format: on	       */
/**** lclock_days contains a 1-based value, but we needed a 0-based number   */
/****  of days for use in computing the microsecond clock value.	       */

      if (time_value.dw ^= 0)
      then do;
         diw = (lclock_days + 4) - divide ((lclock_days + 4), 7, 11) * 7 + 1;
         if (time_value.dw ^= diw)
         then do;
	  code = error_table_$dt_bad_day_of_week;
	  return;
         end;
      end;
      else diw = 0;

      call vc_2_Multics (cal_val, clock_value);
to_clock_exit:
      code = lcode;
      return;			/* @@END to_clock		       */
      end to_clock_rtn;		/* <##> */%page;
/* ***********************************+************************************* */
/*                                                            _	       */
/*            o            _|_                                 |	       */
/*           __      _      |      _      _      _     ___     |	       */
/*            |    |/ \     |     / \   |/ \   |/ \    ___\    |	       */
/*            |    |   |    |    (__/   |      |   |  /   |    |	       */
/*	   _|_   |   |    \_    \_/   |      |   |  \__/|   _|_	       */
/*							       */
/* ***********************************+************************************* */

/* @@@@@@ int proc .. apply_offset				       */
/* ***********************************+************************************* */
/* apply a set of offsets to a calendar value			       */
/* ***********************************+************************************* */
apply_offset: proc;			/* <<##>> */

dcl 1 toa		like time_offset_array based (toa_p);
dcl toa_p		ptr;
dcl toa_i		fixed bin;
dcl overflow	condition;
dcl (
    error_table_$dt_bad_day_of_week,	/* <##> */
    error_table_$dt_offset_too_big_negative,  /* <##> */
    error_table_$dt_offset_too_big_positive   /* <##> */
    )		fixed bin (35) ext static;


      toa_p = addr (auto_time_offset);
      lang_index = 1;		/* force a valid amount	       */
      do i = 1 to 8;		/* make sure all unused fields       */
         if (toa.flag (i) = UNUSED)	/* ..are empty		       */
         then toa.val (i) = 0;
      end;
      if (auto_time_offset.dw.flag ^= UNUSED)
      then if auto_time_offset.dw.val < 1  /* validate user-specified	       */
         | auto_time_offset.dw.val > 7	/* ...day-of-week offset.	       */
      then do;
         lcode = binary (error_table_$dt_bad_day_of_week);
exit:    return;
      end;
      on overflow
         begin;
	  if (toa.val (toa_i) < 0)
	  then lcode = binary (error_table_$dt_offset_too_big_negative);
	  else lcode = binary (error_table_$dt_offset_too_big_positive);
	  goto exit;
         end;

/* First, apply any day-of-week offset to input clock value.  This offset is */
/*  negative if the previous day is to be used and positive if the next one. */
/*  If absolute value of the offset is the same as clock value day-of-week,  */
/*  add/subtract a week to get the needed occurence of that day-of-week;     */
/*  otherwise, add/subtract enough days (<7) to reach wanted day-of-week.    */

      if (auto_time_offset.dw.flag ^= UNUSED)
      then do;
         Ptime_value = addr (decoded_clock);
         call fromclock$no_FW;	/* decode base value	       */
         if lcode ^= 0
         then return;
         if (auto_time_offset.dw.flag > UNUSED)
         then do;
	  auto_time_offset.dw.val = auto_time_offset.dw.val
	     - decoded_clock.dw;
	  if (auto_time_offset.dw.val < 0)
	  | (auto_time_offset.dw.val = 0) & (auto_time_offset.dw.flag = AFTER)
	  then auto_time_offset.dw.val = auto_time_offset.dw.val + 7;
         end;
         else if (auto_time_offset.dw.flag < UNUSED)
         then do;
	  auto_time_offset.dw.val = auto_time_offset.dw.val
	     - decoded_clock.dw;
	  if (auto_time_offset.dw.val > 0)
	  | (auto_time_offset.dw.val = 0) & (auto_time_offset.dw.flag = BEFORE)
	  then auto_time_offset.dw.val = auto_time_offset.dw.val - 7;
         end;
/****    breaking 864e8 into 2 parts makes for better (inline) code.	       */
         cal_val.x = cal_val.x + 100000000 * (auto_time_offset.dw.val * 864);
      end;			/* ***** DAY-IN-WEEK  finished ***** */

      if (auto_time_offset.flag.yr > 0)
      then do;
         Ptime_value = addr (decoded_clock);
         call fromclock$no_FW;	/* decode values in terms of our     */
         if lcode ^= 0
         then return;
         toa_i = 1;			/* to help the condition handler     */
/****    Separate year offset into integer and fraction parts.	       */
         Tyear = auto_time_offset.val.yr;
         fld24 = auto_time_offset.val.yr - trunc (auto_time_offset.val.yr);
/****    Ensure that auto_time_value.yc gets set.			       */
         auto_time_value.yc = decoded_clock.yc + Tyear;
         if (Tyear ^= 0)
         then do;
	  auto_time_value.dm = decoded_clock.dm;
	  auto_time_value.my = decoded_clock.my;
	  auto_time_value.dy = 0;
/****       If decoded day # falls in the 10-day gap between Julian &	       */
/****       Gregorian calendars, push it back to the last valid day.	       */
	  if (auto_time_value.yc = 1582) & (auto_time_value.my = OCTOBER)
	     & (auto_time_value.dm > 4) & (auto_time_value.dm < 15)
	  then auto_time_value.dm = 4;
	  if auto_time_value.my = FEBRUARY & auto_time_value.dm = 29
	  then if calc_leap_day (auto_time_value.yc) = 0
	  then if Tyear < 0		/* adjust date when year offset from */
				/* 02/29/<leap_year> lands in a      */
				/* non-leap_year.		       */
	     then auto_time_value.dm = 28;
	     else do;
	        auto_time_value.my = MARCH;
	        auto_time_value.dm = 1;
	     end;
	  Ptime_value = addr (auto_time_value);
	  call ymd_to_days;		/* break down the adjusted year      */
	  if (lcode ^= 0)
	  then return;
	  cal_val.x = (decoded_clock.US + 1000000 * (decoded_clock.SM
	     + 60 * (decoded_clock.MH + 60 * (decoded_clock.Hd
	     + precision (24 * (lclock_days - 1), 27)))));
         end;
         else cal_val.J_G = None;
         if (fld24 ^= 0)
         then do;			/* apply fractional part, if any     */
/****       How many days in the year?				       */
	  if (auto_time_value.yc = 1582)
	  then unit_size = 355;
	  else unit_size = 365 + calc_leap_day (auto_time_value.yc);
/****       How many microseconds is that? (-1 bias helps roundoff problem)  */
	  unit_size = (unit_size * 864) * 100000000 - 1;
/****       Add in the number of Usec that the fraction represents.	       */
	  fld24 = convert (fld24, unit_size) * fld24;
	  cal_val.x = cal_val.x + convert (cal_val.x, fld24);
         end;
      end;

      if (auto_time_offset.flag.mo > 0)
      then do;
         Ptime_value = addr (decoded_clock);
         call fromclock$no_FW;	/* decode value		       */
         if lcode ^= 0
         then return;
         toa_i = 2;			/* to help the condition handler     */
/****    Separate month offset into integer and fraction parts.	       */
         Tmonth = auto_time_offset.val.mo;
         fld24 = auto_time_offset.val.mo - trunc (auto_time_offset.val.mo);
         Tmonth = Tmonth + decoded_clock.my;
/****    Tmonth, originally an offset, is now a month-in-year	       */
				/* rule:   1 <= month <= 12;	       */
         if (Tmonth < 1)		/*  enforce this rule by normalizing */
         then do;			/*  the month and year values.       */
	  Tyear = divide (Tmonth, 12, 17) - 1; /* -1 accounts for	       */
	  Tmonth = Tmonth - Tyear * 12; /* ..the 0 month #	       */
         end;
         else if (Tmonth > 12)	/* N year, 0 mon = N-1 year, 12 mon  */
         then do;
	  Tyear = divide (Tmonth - 1, 12, 17);
	  Tmonth = Tmonth - Tyear * 12;
         end;
         else Tyear = 0;
         Tyear = Tyear + decoded_clock.yc;
/****    If day # from decoded clock value is greater than # of days in the  */
/****    adjusted month, then set it to # of days in month; thus:	       */
/****	      May 31, 1973 -3 months				       */
/****    produces an intermediate result of:			       */
/****	      February 28, 1973				       */
         if Tmonth = FEBRUARY		/* if this is February	       */
         then Tday = 28 + calc_leap_day ((Tyear));
         else Tday = days_in_month (Tmonth);
         Tday = min (decoded_clock.dm, Tday);
/****    If decoded day # falls in the 10-day gap between Julian & Gregorian */
/****    calendars, push it back to the last valid day.  This mimics the     */
/****    action mentioned above.				       */
         if (Tyear = 1582) & (Tmonth = OCTOBER)
	  & (Tday > 4) & (Tday < 15)
         then Tday = 4;
         auto_time_value.dm = Tday;
         auto_time_value.my = Tmonth;
         auto_time_value.yc = Tyear;
         auto_time_value.dy = 0;
         Ptime_value = addr (auto_time_value);
         call ymd_to_days;		/* break down the adjusted yr/mo     */
         if (lcode ^= 0)
         then return;
         cal_val.x = (decoded_clock.US + 1000000 * (decoded_clock.SM
	  + 60 * (decoded_clock.MH + 60 * (decoded_clock.Hd
	  + precision (24 * (lclock_days - 1), 27)))));
         if (fld24 ^= 0)
         then do;			/* apply fractional part, if any     */
/****       How many days in the month?				       */
	  if Tmonth = FEBRUARY	/* if this is February	       */
	  then unit_size = 28 + calc_leap_day ((Tyear));
	  else unit_size = days_in_month (Tmonth);
/****       How many microseconds is that? (-1 bias helps roundoff problem)  */
	  unit_size = (unit_size * 864) * 100000000 - 1;
/****       Add in the number of Usec that the fraction represents.	       */
	  fld24 = convert (fld24, unit_size) * fld24;
	  cal_val.x = cal_val.x + convert (cal_val.x, fld24);
         end;
      end;
/**** Now take care of the easy ones:  wk, da, hr, min, sec, Usec.	       */
/****				3   4   5    6    7     8	       */
      do toa_i = 3 to 8;
         if (toa.flag (toa_i) > 0)
         then cal_val.x = cal_val.x
	       + convert (cal_val.x, toa.val (toa_i) * unit_sizes (toa_i));
      end;
      revert overflow;

   end apply_offset;		/* <##> */ %page;
/* @@@@@@ int func .. calc_leap_day				       */
/* ***********************************+************************************* */
/* ***********************************+************************************* */
calc_leap_day: proc (yr) returns (fixed bin); /* <<##>> */

dcl yr		fixed bin;

      if (yr > 1582)
      then return (1
	    - divide (yr - divide (yr, 4, 17) * 4 + 3, 4, 17)
	    + divide (yr - divide (yr, 100, 17) * 100 + 99, 100, 17)
	    - divide (yr - divide (yr, 400, 17) * 400 + 399, 400, 17));
      if (mod (yr, 4) = 0)
      then return (1);
      return (0);

   end calc_leap_day;		/* <##> */ %skip (4);
/* @@@@@@ int proc .. cv_fmt_kwd				       */
/* ***********************************+************************************* */
/* ***********************************+************************************* */

cv_fmt_kwd: proc (fmt_str) returns (char (256)var); /* <<##>> */

dcl fmt_str	char(512)var;

dcl (
    error_table_$dt_no_format_selector	/* <##> */
    )		fixed bin (35) ext static;
dcl ii		fixed bin;
dcl result	char (256)var;
dcl ct		fixed bin;

         lcode = 0;
         ct = 0;
         result = fmt_str;
check:
         if (result = "date_time")
         then result = time_defaults_$date_time;
         else if (result = "date")
         then result = time_defaults_$date;
         else if (result = "time")
         then result = time_defaults_$time;
         else do;
	  do ii = 1 to ti_keyword.number_kwd;
	     if (ti_keyword.name (ii) = result)
	     then do;
	        result = ti_keyword.str (ii);
	        goto found_kwd;
	     end;
	  end;
no_good:
	  lcode = binary (error_table_$dt_no_format_selector);
	  return(fmt_str);
found_kwd:
         end;
         if (index (result, "^") = 0)	/* if the keyword gave a keyword     */
         then do;
	  if (ct = 0)		/* ..and this is the first time      */
	  then do;		/* ..thru, give it another shot.     */
	     ct = 2;
	     goto check;
	  end;
	  goto no_good;		/* ..otherwise complain	       */
         end;
         return (result);

      end cv_fmt_kwd;

/* @@@@@@ int proc .. do_format				       */
/* ***********************************+************************************* */
/* ***********************************+************************************* */
do_format: proc;			/* <<##>> */

dcl i		fixed bin;

      Ptime_value = addr (decoded_clock); /* point to a structure	       */
      time_value.version = Vtime_value_3;
      call fromclock;		/* ..and get it filled in, in the    */
				/* ..zone specified or implied       */
error:
      if lcode ^= 0			/* report error to user.	       */
      then do;
         lresult = "01/01/01  0000.00 gmt Tue";
         return;
      end;
do_format$direct: entry;
      errloc = 1;			/* in case there's an error	       */
      if (index (lformat, "^") = 0)	/* if no ^'s, it must be a keyword   */
      then do;			/* ..get it translated	       */
         lformat = cv_fmt_kwd (lformat);
         errlocad.n = 1;
         errlocad.start(1) = 1;
         errlocad.enclosed_key(1) = 0;
         errlocad.old_len(1) = length(format);
         errlocad.new_len(1) = length(lformat);
         end;
      if (lcode ^= 0)
      then goto error;
      
      lresult = "";			/* set up to scan his format string  */
      format_i = 1;
      do while ((format_i <= length (lformat)) & (lcode = 0));
         i = index (substr (lformat, format_i), "^");
         if (i = 0)
         then i = length (lformat) - format_i + 1;
         else i = i - 1;
         if (i > 0)
         then lresult = lresult || substr (lformat, format_i, i);
         format_i = format_i + i;
         if (format_i <= length (lformat))
         then do;
	  call proc_selector;
         end;
      end;

   end do_format;			/* <##> */ %page;
/* @@@@@@ int proc .. fromclock				       */
/* ***********************************+************************************* */
/* Arguments to this proc are:				       */
/*   Ptime_value=  ptr to time_value output struc.		   [In]*/
/*   cal_val    =  calendar value in zone specified to be converted      [In]*/
/*   lcode      =  error code if nonzero			  [Out]*/
/* ***********************************+************************************* */
fromclock: proc;			/* <<##>> */
     do_FW = "1"b;
     goto start;

fromclock$no_FW: entry;
     do_FW = ""b;
start:     ;

dcl (
    error_table_$badcall	/* <##> */
    )		fixed bin (35) ext static;

dcl (A, B, C)	fixed bin;	/* factors for leap year calculation */
dcl lclock_seconds	fixed bin (36);
dcl lclock_minutes	fixed bin (31);
dcl lclock_hours	fixed bin (25);
dcl lclock_days	fixed bin (20);
dcl leap_day	fixed bin;	/* number of Feb 29's in this year.  */
dcl do_FW		bit (1);
dcl day_for_fiscal	fixed bin;
dcl fiscal_constant fixed bin;
dcl fiscal_week_value fixed bin;
dcl fiscal_year_value fixed bin;

      lcode = 0;
      time_value.zone_index = cal_val.zi;

/* ***********************************+************************************* */
/*							       */
/* 1) compute number of micro-seconds in excess of 1 second in clock value.  */
/* 2) compute number of seconds in excess of 1 minute in clock value.	       */
/* 3) compute number of minutes in excess of 1 hour in clock value.	       */
/* 4) compute number of hours in excess of 1 day in clock value.	       */
/*							       */
/* ***********************************+************************************* */
/* format: off		       */

      time_value.Uc = cal_val.x;
      time_value.za = cal_val.z;
      time_value.zone_index = cal_val.zi;

      lclock_seconds = divide (cal_val.x,                1000000, 39);
      time_value.US  = cal_val.x      - lclock_seconds * 1000000;

      lclock_minutes = divide (lclock_seconds,           60, 10);
      time_value.SM  = lclock_seconds - lclock_minutes * 60;

      lclock_hours   = divide (lclock_minutes,           60, 8);
      time_value.MH  = lclock_minutes - lclock_hours   * 60;

      lclock_days    = divide (lclock_hours,             24, 7);
      time_value.Hd  = lclock_hours  - lclock_days     * 24;
				/* format: on		       */
/**** Add 1 because Us 0 at beginning of day 1			       */
      time_value.dc = lclock_days + 1; %page;
      if (cal_val.J_G = Special)	/* this range does Julian type of    */
      then do;			/* ..breakdown (cheaper)	       */
         lclock_days = lclock_days + 13;
         goto Julian_style;
      end;
      if (cal_val.J_G = Gregorian)
      then do;

/* ***********************************+************************************* */
/*							       */
/*    G R E G O R I A N    D A T E S :  1582-10-15 thru 9999-12-31	       */
/* During this interval, the Gregorian leap calculation is used.	       */
/*							       */
/* Compute the year by dividing the whole number of days in the clock value  */
/*  into a whole number of 400 year groups plus a whole number of 100 year   */
/*  groups plus a whole number of 4 year groups plus a number of years in    */
/*  excess of the last 4 year group.				       */
/*							       */
/* ***********************************+************************************* */

         A, B, C = 1;		/* format: off */
         lclock_days = lclock_days - 2;	/* The base value of the Gregorian   */
				/* ..algorithm is 2 days before that */
				/* ..of the Julian.		       */

         num_of__400s = divide (lclock_days,     146097, 2);
         rest_of__400 =         lclock_days   -  146097 * num_of__400s;
              if (rest_of__400 >= 146097-366)
	    then C = 0;

         num_of__100s = divide ( rest_of__400,    36524, 1);
              if  (num_of__100s = 4)	/* Account for leap day every 4th    */
	    then num_of__100s = 3;	/*  century.		       */
         rest_of__100 =          rest_of__400 -   36524 * num_of__100s;
              if (rest_of__100 >= 36524-365)
	    then B = 0;

         num_of____4s = divide ( rest_of__100,     1461, 2);
         rest_of____4 =          rest_of__100 -    1461 * num_of____4s;
              if (rest_of____4 >= 1461-366)
	    then A = 0;

         num_of____1s = divide ( rest_of____4,      365, 1);
              if  (num_of____1s = 4)	/* Account for leap day every 4th    */
              then num_of____1s = 3;	/*  year			       */
         rest_of____1 =          rest_of____4 -     365 * num_of____1s + 1;
				/* Number of the day of the year.    */
         time_value.yc
            = num_of__400s * 400
            + num_of__100s * 100
            + num_of____4s * 4
            + num_of____1s + 1;
				/* format: on */
         time_value.dy = rest_of____1;
         if (time_value.yc = 1582)	/* Only 355 days in year 1582.       */
	  & (rest_of____1 >= 288)
         then time_value.dy = rest_of____1 - 10;

         leap_day = 1 - A + B - C;
      end; %page;
/* ***********************************+************************************* */
/*							       */
/*    J U L I A N   D A T E S :  0001-01-01 thru 1582-10-04		       */
/*							       */
/* Compute the year by dividing the whole number of days in the clock value  */
/*  into a whole number of 4 year groups plus a number of years in excess    */
/*  of the last 4 year group.					       */
/*							       */
/* ***********************************+************************************* */

      else if (cal_val.J_G = Julian)
      then do;
Julian_style:
         num_of____4s = divide (lclock_days, 1461, 17);
         rest_of____4 = lclock_days - (1461 * num_of____4s);
         num_of____1s = divide (rest_of____4, 365, 1);
         if (num_of____1s >= 3)	/* =4 on last day of leap year.      */
         then do;
	  num_of____1s = 3;
	  leap_day = 1;
         end;
         else leap_day = 0;

         rest_of____1 = rest_of____4 - (365 * num_of____1s) + 1;
         time_value.yc
	  = num_of____4s * 4
	  + num_of____1s + 1;
         time_value.dy = rest_of____1;


      end;
      else do;
         lcode = binary (error_table_$badcall);
         return;
      end; %page;
/* ***********************************+************************************* */
/* 0001-1-1 has dc=1 and is a Saturday(=6).  Calculate the day of the week   */
/* by removing the number of whole weeks and adjusting what is left.	       */
/* when dc=1 the formula will be (1+4)-(1+4)/7*7+1		       */
/* which works out to be           5  -    0    +1 = 6		       */
/* when dc=3 the formula will be (3+4)-(3+4)/7*7+1		       */
/* which works out to be           7  -    7    +1 = 1		       */
/* This show that the wrap around is at the right place.		       */
/* ***********************************+************************************* */

      time_value.dw			/*  yields   1=Mon ... 7=Sun	       */
         = (time_value.dc + 4) - divide ((time_value.dc + 4), 7, 11) * 7 + 1;

/* ***********************************+************************************* */
/*							       */
/*  Calculate the fiscal week.  This method is derived from equations in     */
/*  an article in Interface Age by R. W. Bemer; Feb 1979 p75-79	       */
/*							       */
/* ***********************************+************************************* */
      if do_FW
      then do;
         day_for_fiscal = divide (time_value.dy - 1, 7, 17);
         day_for_fiscal = time_value.dy - 1 - day_for_fiscal * 7;
         fiscal_constant = time_value.dw - day_for_fiscal + 6;
         if (fiscal_constant < 4)
         then fiscal_constant = fiscal_constant + 7;
         if (fiscal_constant > 10)
         then fiscal_constant = fiscal_constant - 7;

         fiscal_week_value
	  = divide (time_value.dy + fiscal_constant - 1, 7, 17);
         fiscal_year_value = time_value.yc;

/**** take care of the special cases				       */

         if (fiscal_week_value = 53)
         then do;
	  if fiscal_constant + leap_day < 10
	  then do;
	     fiscal_year_value = fiscal_year_value + 1;
	     fiscal_week_value = 1;
	  end;
         end;
         else if fiscal_week_value = 0
         then do;
	  fiscal_year_value = fiscal_year_value - 1;
	  fiscal_week_value = 53
	     - divide (fiscal_constant + 1 - calc_leap_day (fiscal_year_value), 6, 17);
         end;

				/* 9999-12-31=FW999952, so we don't  */
				/* ..have to check for year 10000    */
         time_value.fw = fiscal_year_value * 100 + fiscal_week_value;
      end;
/* ***********************************+************************************* */
/*							       */
/*      Compute the month of the year, and day of the month, using the       */
/*	algorithm of Richard A. Stone; Communications of the ACM;	       */
/*		 Vol 13, No 10; October, 1970; p 621.		       */
/*							       */
/* ***********************************+************************************* */

      if rest_of____1 > (59 + leap_day) /* make Feb have 30 days.	       */
      then rest_of____1 = rest_of____1 + 2 - leap_day;
      rest_of____1 = rest_of____1 + 91;
				/* get pseudo-month_number	       */
      time_value.my = divide (rest_of____1, 30.55, 2);
      time_value.dm = rest_of____1
         - precision ((30.55 * time_value.my), 3, 0);
				/* pseudo-month_number * 30.55 gives */
				/* ..number of days before the first */
				/* ..day of this month.  ITS MAGIC!  */
      time_value.my = time_value.my - 2;
				/* Algorithm says subtract 2 to get  */
				/*  real month no.		       */
      time_value.leap_year = leap_day;
      return;			/* All done!		       */
   end fromclock;			/* <##> */ %page;
/* @@@@@@ int proc .. get_word_index				       */
/* ***********************************+************************************* */
/* ***********************************+************************************* */

/*   A portion of this routine also exists in convert_date_to_binary_.rd.    */

get_word_index: proc (Atoken, Atable) returns (fixed bin);	 /* <<##>> */

dcl Atoken	char (32),	/* word to look for		       */
    Atable	fixed bin;	/* kind off thing it must be	       */

dcl (lb, hb)	fixed bin;
dcl symb		char (32);
dcl cur_token	fixed bin;
dcl e_count	fixed bin;

      if (Atable = Language_table)
      then do;
         if (Atoken = "")		/* User wants process default.       */
         then return (time_defaults_$language_index);
         if (Atoken = "system_lang")
         then return (time_info_$default_language_index);
      end;
      if (Atable = Zone_table)
      then do;
         if (Atoken = "")		/* User wants process default.       */
         then return (time_defaults_$zone_index);
         if (Atoken = "system_zone")
         then do;
	  symb = sys_info$time_zone;
	  goto search;
         end;
      end;
      item_p = null ();
      symb = translate (Atoken, az, AZ);/* get to normal form	       */
search:
      ti_token_p = addr (time_info_$tokens);
      lb = 1;			/* set lower bound of search	       */
      hb = ti_token.count;		/* set upper bound of search	       */
      do while (lb <= hb);		/* as long as range is non-null      */
         cur_token = divide (lb + hb, 2, 17); /* find center of range	       */
         if (ti_token.symbol (cur_token) = symb)
         then do;
	  item_p = addrel (addr (time_info_$version),
	     ti_token.list_r (cur_token));
	  goto found_token;
         end;
         if (ti_token.symbol (cur_token) < symb)
         then lb = cur_token + 1;
         else hb = cur_token - 1;
      end;
      return (-1);			/* Tell caller name was not there    */

found_token:
      do e_count = 1 to item.count;
         if (Atable = item.table (e_count))
         then return (item.element (e_count));
      end;
      return (0);			/* Tell caller name was there,       */
				/* ..but not the kind she wanted.    */

   end get_word_index;		/* <##> */ %skip (5);
/* @@@@@@ int func .. make_fraction				       */
/* ***********************************+************************************* */
/* ***********************************+************************************* */
make_fraction: proc (interval, units) returns (float dec (20)); /* <<##>> */

dcl (interval, units) fixed bin (71);

dcl (fldA, fldB)	float dec (24);
dcl fldC		float dec (20);

      fldA = convert (fldA, interval);
      fldB = convert (fldB, units);
      fldC = fldA / fldB;
      return (fldC);

   end make_fraction;		/* <##> */ %page;
/* @@@@@@ int proc .. Multics_2_vc				       */
Multics_2_vc: proc (Mval, zname, zval, lval, cval); /* <<##>> */

dcl Mval		fixed bin (71),	/* Multics value		 [IN]  */
    zname		char (5),		/* zone name in which to work  [IN]  */
				/* ""=> zone-name(zval) is used      */
    zval		fixed bin,	/* zone index of value	 [IN]  */
				/* 0 => zname is a zone differential */
				/*  and is converted.	       */
				/* >0=> zname assumed to match zval  */
    lval		fixed bin,	/* language in which working	 [IN]  */
				/* (needed when zname="")	       */
    1 cval	like cal_val;	/* virtual value, zoned	 [OUT] */

/* Convert a Multics clock value (org 1901-01-01 00:00:00.000000 gmt Tue)    */
/* into a virtual clock value (org 0001-01-01__00:00:00.000000_gmt_Sat) and  */
/* then adjust to the indicated time zone.			       */
/* The results are placed in a structure which contains		       */
/*   x	the adjusted value.					       */
/*  dx	the value to add to x to give GMT			       */
/*   z	the name of the zone related to dx			       */
/*  zi	the zone_index into ti_zone for this zone.		       */
/* J_G	which calendar system the value is in			       */

dcl (
    error_table_$dt_date_too_big,	/* <##> */
    error_table_$dt_date_too_small,	/* <##> */
    error_table_$dt_year_too_big,	/* <##> */
    error_table_$dt_year_too_small	/* <##> */
    )		fixed bin (35) ext static;

      lcode = 0;
/**** First adjust to an absolute virtual clock value, check range.	       */
      cval.x = Mval + M_vc_adjust;
      if (cval.x < 0)
      then do;			/* 0001-01-01__00:00:00.000000_gmt   */
         lcode = binary (error_table_$dt_date_too_small);
         return;
      end;
      if (cval.x >= max_vc_value)
      then do;			/* 9999-12-31__23:59:59.999999_gmt   */
         lcode = binary (error_table_$dt_date_too_big);
         return;
      end;
/**** Now zone adjust the value and keep associated info.		       */
/**** If zval=0 then zname is a zone differential.  This is a signed number  */
/****  pair (sHHMM) representing the hour and minute adjustment to GMT to    */
/****  given the needed local value, i.e. -0700 is Mountain Standard Time,   */
/****  +0530 is India Standard Time.				       */
      if (zval = 0)
      then do;
         cval.dx
	  = convert (cval.dx, substr (zname, 2, 2)) * 3600000000
	  + convert (cval.dx, substr (zname, 4, 2)) * 60000000;
         if (substr (zname, 1, 1) = "+")
         then cval.dx = -cval.dx;
      end;
      else cval.dx = ti_zone.delta (1, zval);
      cval.x = cval.x - cval.dx;
      cval.zi = zval;
      cval.z = zname;
      if (cval.z = "")
      then cval.z = ti_zone.short (lval, cval.zi);

/**** Now make sure it still is within bounds and see which calendar its in. */
      if (cval.x < begin_Special)	/* < 1901-01-01 00:00:00.000000      */
      then do;
         if (cval.x < begin_Gregorian)	/* < 1582-10-15 00:00:00.000000      */
         then do;
	  if (cval.x < 0)		/*    (ZAT == Zone Adjusted Time)    */
	  then do;		/* < 0001-01-01 00:00:00.000000 ZAT  */
	     lcode = binary (error_table_$dt_year_too_small);
	     return;
	  end;
	  cval.J_G = Julian;	/*   0001-01-01 thru 1582-10-04      */
         end;
         else cval.J_G = Gregorian;	/*   1582-10-15 thru 1900-12-31      */
      end;
      else if (cval.x < end_Special)
      then cval.J_G = Special;	/*   1901-01-01 thru 2099-12-31      */
      else do;
         if (cval.x >= max_vc_value)
         then do;			/* > 9999-12-31 23:59:59.999999 ZAT  */
	  lcode = binary (error_table_$dt_year_too_big);
	  return;
         end;
         cval.J_G = Gregorian;	/*   2100-01-01 thru 9999-12-31      */
      end;

      return;

   end Multics_2_vc;		/* <##> */ %skip (3);
/* @@@@@@ int proc .. proc_selector				       */
/* ***********************************+************************************* */
/* ***********************************+************************************* */
proc_selector: proc;		/* <<##>> */
dcl (
    error_table_$bad_conversion,	/* <##> */
    error_table_$dt_bad_format_selector,/* <##> */
    error_table_$picture_bad,		/* <##> */
    error_table_$picture_scale,	/* <##> */
    error_table_$picture_too_big,	/* <##> */
    error_table_$size_error		/* <##> */
    )		fixed bin (35) ext static;
				/* format: off */
dcl selector	(43)char(2)int static options (constant) init (
	"Hc",	/* 01 "(8)Z9"	Hour/calendar		       */
	"Hd",	/* 02 "99"	Hour/day			       */
	"Hh",	/* 03 "99"	Hour/half-day		       */
	"Hm",	/* 04 "(3)Z9"	Hour/month		       */
	"Hw",	/* 05 "(3)Z9"	Hour/week			       */
	"Hy",	/* 06 "(4)Z9"	Hour/year			       */
	"MH",	/* 07 "99"	Minute/Hour		       */
	"Mc",	/* 08 "(10)Z9"	Minute/calendar		       */
	"Md",	/* 09 "(4)Z9"	Minute/day		       */
	"Mm",	/* 10 "(5)Z9"	Minute/month		       */
	"Mw",	/* 11 "(5)Z9"	Minute/week		       */
	"My",	/* 12 "(6)Z9"	Minute/year		       */
	"SH",	/* 13 "(4)Z9"	Second/Hour		       */
	"SM",	/* 14 "99"	Second/Minute		       */
	"Sc",	/* 15 "(12)Z9"	Second/calendar		       */
	"Sd",	/* 16 "(5)Z9"	Second/day		       */
	"Sm",	/* 17 "(8)Z9"	Second/month		       */
	"Sw",	/* 18 "(6)Z9"	Second/week		       */
	"Sy",	/* 19 "(12)Z9"	Second/year		       */
	"UH",	/* 20 "(10)Z9"	Usecond/Hour (microsecond)	       */
	"UM",	/* 21 "(8)Z9"	Usecond/Minute		       */
	"US",	/* 22 "(5)Z9"	Usecond/Second		       */
	"Uc",	/* 23 "(18)Z9"	Usecond/calendar		       */
	"Ud",	/* 24 "(11)Z9"	Usecond/day		       */
	"Um",	/* 25 "(13)Z9"	Usecond/month		       */
	"Uw",	/* 26 "(12)Z9"	Usecond/week		       */
	"Uy",	/* 27 "(14)Z9"	Usecond/year		       */
	"da",	/* 28 "(8)X"	day abbrev		       */
	"dc",	/* 29 "(7)Z9"	day/calendar		       */
	"dm",	/* 30 "99"	day/month			       */
	"dn",	/* 31 "(32)X"	day name			       */
	"dw",	/* 32 "9"		day/week			       */
	"dy",	/* 33 "999"	day/year			       */
	"fw",	/* 34 "OOO999"	fiscal week		       */
	"ma",	/* 35 "(8)X"	month abbrev		       */
	"mi",	/* 36 "a"		meridiem indicator		       */
	"mn",	/* 37 "(32)X"	month name		       */
	"my",	/* 38 "99"	month/year		       */
	"yc",	/* 39 "OO99"	year/calendar		       */
	"za",	/* 40 "(8)X"	zone abbrev		       */
	"zn",	/* 41 "(64)X"	zone name			       */
	"fi",	/* 42 "(8)X"	fiscal indicator		       */
	"zd");	/* 43 "s9999"	zone differential		       */
				/* format: on */

dcl Ar_ct		fixed bin;
dcl assign_	entry (ptr, fixed bin, fixed bin (35), ptr, fixed bin,
		fixed bin (35));
dcl bit1		bit (1) unaligned based;
dcl buff		(20) fixed binary;
dcl conversion	condition;
dcl ftype		fixed bin;
dcl fx2		fixed bin;
dcl i1		fixed bin;
dcl i2		fixed bin;
dcl ii		fixed bin;
dcl pack_picture_	options (variable);
/**** pack_picture_ declares itself to be "(char(1), fixed bin, char(1))",   */
/****  but it does not play straight with it's arguments.		       */
dcl Pic		char (64);
dcl PIC		char (64);
dcl picl		fixed bin;
dcl picp		ptr;
dcl pictured	char (256) var;
dcl picture_code	fixed bin (15);	/* I think it's weird also.	       */
dcl picture_info_	entry (char (*) aligned, ptr, fixed bin (15));
dcl picv		char (picl) based (picp);
dcl Pic_l		fixed bin;
dcl pi_p		ptr;
dcl size		condition;
dcl target	char (128);
dcl target_length	fixed bin (35);
dcl temp		char (64);
dcl Ol_sw		bit (1);
dcl Zl_ct		fixed bin;
dcl Zr_ct		fixed bin;

dcl map_type	(24:28) fixed bin int static init (
		42,		/* character		       */
		18,		/* real fixed dec		       */
		22,		/* cplx fixed dec		       */
		20,		/* real float dec		       */
		24);		/* cplx float dec		       */

dcl 1 pi		like picture_image based (pi_p);
%include picture_image;


/**** see if a picture is here				       */
      Pic = "";
      Pic_l = 0;
      pi_p = addr (buff);
      pi.scale = 0;
      format_i = format_i + 1;	/* skip the "^"		       */
      if (substr (lformat, format_i, 1) = "^")
      then do;			/* Just wants a "^"		       */
         format_i = format_i + 1;
         lresult = lresult || "^";
exit_selector:
         return;
      end;
      if (substr (lformat, format_i, 1) = "<")
      then do;			/* imbedded ^<keyword>	       */
/****    Replace the keyword reference with it's associated string.	       */
/****    This is done in such a manner so as to avoid any string temporaries */
/****    other than the compiler assigned one to receive cv_fmt_kwd output.  */
/****    The "----------" comments below are intended to show how the pieces */
/****    of the string "BBB^<kk>AAA" are manipulated.  xxx is converted kk.  */
         errloc = format_i+1;		/* point to beginning of keyword     */
				/* ..in case an error occurs	       */
         temp_512_v			/* ------------"kk"		       */
	  = before (substr (lformat, errloc), ">");
         i = min(errlocad.n+1, hbound(errlocad.keywords,1));
         errlocad.start(i) = format_i-1;
         errlocad.enclosed_key(i) = 1;
         errlocad.old_len(i) = length(temp_512_v) + length("^<>");
				/* remember start/length of keyword. */
         temp_512_v			/* ------------"xxx"	       */
	  = cv_fmt_kwd (temp_512_v);
         if (lcode ^= 0)
         then goto err_exit;
         errlocad.new_len(i) = length(temp_512_v);
         errlocad.n = i;		/* remember length of keyword	       */
				/* replacement value, so errloc can  */
				/* be adjusted if an error occurs.   */
         temp_512_v = temp_512_v	/* ------------"xxxAAA"	       */
	  || after (substr (lformat, errloc), ">");
         format_i = format_i -1;	/* set scan index properly	       */
         lformat			/* ------------"BBB"	       */
	  = substr (lformat, 1, format_i-1);
         lformat			/* ------------"BBBxxxAAA"	       */
	  = lformat || temp_512_v;
         goto exit_selector;		/* and that's all we do, no output   */
      end;
      i = verify (substr (lformat, format_i), "abcefksvxzXZ9().,-+O012345678");
      if (i = 0)
      then i = length (lformat) - format_i + 1;
      else i = i - 1;
/**** There is some overlap between valid picture characters and selector    */
/**** characters.  This is not an ambiguity, but does require this special   */
/**** handling, since determining the picture length is very simplistic.     */
      if (substr (lformat, format_i + i - 1, length ("f")) = "f")
      then i = i - 1;
      else if (substr (lformat, format_i + i - 1, length ("zn")) = "zn")
         | (substr (lformat, format_i + i - 1, length ("zd")) = "zd")
      then i = i - 1;
      else if (i > 1) then do;	 /* ^za can be followed by .,+- et al*/
         ii = index(substr (lformat, format_i, i), "za");
         if ii > 0 
         then i = ii-1;
         end;
      if (i > 0)
      then do;
         Pic_l = i;
         if (Pic_l > length (Pic))
         then do;
	  lcode = binary (error_table_$picture_too_big);
	  errloc = format_i;
	  goto err_exit;
         end;
         Pic = substr (lformat, format_i, Pic_l);
         picloc = format_i;		/* in case there is an error later   */
         format_i = format_i + Pic_l;
      end;
      if (format_i ^< length (lformat))
      then do;			/* no room for selector	       */
         errloc = length (lformat) + 1;
         goto bad_selector;
      end;
      errloc = format_i;		/* set up in case failure next       */
      i = index (string (selector), substr (lformat, format_i, 2));
      if (i = 0)
      then do;
bad_selector:
         lcode = binary (error_table_$dt_bad_format_selector);
err_exit:
         errlocad.unadjusted_errloc = errloc;
         do i = lbound(errlocad.keywords,1) to errlocad.n;
	  if errloc > errlocad.start(i) then do;
	     if errloc > errlocad.start(i) - 1 + errlocad.new_len(i)
	     then errloc = errloc - errlocad.new_len(i)+errlocad.old_len(i);
	     else errloc = errlocad.start(i) + 
		         errlocad.enclosed_key(i)*length("^<");
	  end;
         end;
         return;
      end;
      ftype = divide (i + 1, 2, 17);
      format_i = format_i + 2;
      on condition (conversion)	/* just in case he blows it	       */
         begin;
	  lcode = binary (error_table_$bad_conversion);
	  goto err_exit;
         end;
      on condition (size)		/* just in case he blows it	       */
         begin;
	  lcode = binary (error_table_$size_error);
	  goto err_exit;
         end;
Pic_supplied:
      if (Pic ^= "")
      then do;
Pic_expand:
         picp = addr (Pic);
         picl = Pic_l;
         i = index (picv, "(");
         if (i > 0)
         then do;
	  if (i > 1)
	  then do;
	     if (substr (Pic, i - 1, length ("f")) = "f")
	     then goto Pic_expanded;	/* it's a scale factor	       */
	  end;
	  ii = index (picv, ")");
	  if (ii < i) | (ii = Pic_l)
	  then goto pic_syntax;
	  i1 = ii - i - 1;		/* length of the repeat number       */
	  i2 = convert (i2, substr (Pic, i + 1, i1));
	  Pic = substr (Pic, 1, i - 1)
	     || copy (substr (Pic, ii + 1, 1), i2 - 1)
	     || substr (Pic, ii + 1);
	  Pic_l = Pic_l - i1 - length ("()9") + i2;
	  goto Pic_expand;
         end;
Pic_expanded:
         Ar_ct = verify (reverse (substr (Pic, 1, Pic_l)), "X");
         if (Ar_ct = 0)
         then Ar_ct = Pic_l;
         else Ar_ct = Ar_ct - 1;
         if (Ar_ct > 0)
         then substr (Pic, Pic_l - Ar_ct + 1, Ar_ct) = copy ("x", Ar_ct);

         Zr_ct = verify (reverse (substr (Pic, 1, Pic_l)), "Z");
         if (Zr_ct ^= 0)		/* if its all Z's, use them left     */
         then do;
	  Zr_ct = Zr_ct - 1;
	  if (Zr_ct > 0)
	  then substr (Pic, Pic_l - Zr_ct + 1, Zr_ct) = copy ("9", Zr_ct);
         end;

         Zl_ct = verify (substr (Pic, 1, Pic_l), "Z");
         if (Zl_ct = 0)
         then Zl_ct = Pic_l;
         else Zl_ct = Zl_ct - 1;
         if (Zl_ct > 0)
         then substr (Pic, 1, Zl_ct) = copy ("z", Zl_ct);

/****    Os may appear scattered around in a picture.		       */
         if (index (substr (Pic, 1, Pic_l), "O") = 0)
         then Ol_sw = ""b;
         else do;			/* There is at least 1 O present     */
	  Ol_sw = "1"b;
	  PIC = Pic;		/* keep the original for reference.  */
	  i = index (PIC, "v");	/* ..The presence of a "v" does not  */
	  if (i ^= 0)		/* ..produce a result character, so  */
	  then do;		/* ..remove it.		       */
	     substr (PIC, i) = substr (PIC, i+1);
	     Pic_l = Pic_l - 1;
	  end;
/****       O's in the midst of z's cannot translate to 9's. Check for this  */
	  i = verify (Pic, "ZOz");
	  if (i = 0)
	  then i = Pic_l + 1;
	  if (i > 0)
	  then do;
	     i = i - 1;
	     substr (Pic, 1, i) = translate (substr (Pic, 1, i), "z", "O");
	  end;
	  Pic = translate (Pic, "9", "O");  /* make working copy "proper"  */
         end;

         call picture_info_ ((picv), pi_p, picture_code);
				/* let PL/I routine process it       */
         if (picture_code ^= 0)	/* Oh,			       */
         then do;			/* ...you didnt like that one!       */
	  if (picture_code = 434)
	  then lcode = binary (error_table_$picture_scale);
	  else if (picture_code < 434)
	  then lcode = binary (error_table_$picture_too_big);
	  else do;
pic_syntax:
	     lcode = binary (error_table_$picture_bad);
	  end;
	  errloc = picloc;
	  goto exit_selector;
         end;
         target_length = pi.prec + 262144 * (pi.scale - pi.scalefactor);
      end;
      fld24 = 0;
      if testing_format
      then goto exit_selector;
      goto sel (ftype); %page;
dcl pic25		pic "(25)-9";
dcl ch64		char (64) var; %skip (2);
sel_pic2:
      lresult = lresult || pic2;
      goto exit_selector;
sel_ascii:
      if (Pic_l = 0)
      then do;
         lresult = lresult || ch64;
         goto exit_selector;
      end;
      arg_p = addr (ch64);
      arg_t = 44;
      arg_l = length (ch64);
      goto sel_done;

sel_dec_pic:
      if (Pic_l = 0)
      then do;
         pic25 = fld24;
         lresult = lresult || ltrim (pic25);
         goto exit_selector;
      end;
sel_dec:
      arg_p = addr (fld24);
      arg_t = 20;
      arg_l = 24;
sel_done:
/**** picture_info_ has decided what type pack_picture_ is going to need     */
/**** to be able to get it's job done.  We must convert the value we have    */
/**** into that needed type.					       */
      begin;
/****    If a character value is assigned to a picture which has too few     */
/****    ..characters, assign_ signals stringsize.  The default system       */
/****    ..action is to truncate without comment.  We want that.  We don't   */
/****    ..want someone else's handler to get in the way so we make our own. */
         on stringsize system;
         call assign_ (addr (temp), map_type (pi.type), target_length,
	  arg_p, arg_t, arg_l);
dcl stringsize	condition;
      end;
      call pack_picture_ (addr (target) -> bit1, buff, temp);

      pictured = substr (target, 1, pi.varlength);

/**** The "O" processing must be done first, because the characters to be    */
/****  worked on are position dependant.			       */
      if Ol_sw
      then do;			/* copy all characters which did not */
         pictured = "";		/* ..have a "O" in the picture. Note */
         do i = 1 to Pic_l;		/* ..that "v" was removed above.     */
	  if (substr (PIC, i, 1) ^= "O")
	  then pictured = pictured || substr (target, i, 1);
         end;
      end;

      if (Ar_ct > 0)
      then do;			/* rtrim up to Ar_ct spaces	       */
         i = verify (reverse (pictured), " ");
         if (i = 0)
         then i = length (pictured);
         else i = i - 1;
         i = length (pictured) - min (i, Ar_ct);
         pictured = substr (pictured, 1, i);
      end;
      else if (Zr_ct > 0)		/* rtrim up to Zr_ct zeroes	       */
      then do;
         i = verify (reverse (pictured), "0");
         if (i = 0)
         then i = length (pictured);
         else i = i - 1;
         i = length (pictured) - min (i, Zr_ct);
         pictured = substr (pictured, 1, i);
      end;

      if (Zl_ct > 0)
      then do;			/* ltrim up to Zl_ct spaces	       */
         i = verify (pictured, " ");
         if (i = 0)
         then i = length (pictured);
         else i = i - 1;
         i = min (i, Zl_ct);
         if (i = length (pictured))
         then pictured = "";
         else pictured = substr (pictured, i + 1);
      end;

/**** After all that, add what's left to the string being built.	       */
      lresult = lresult || pictured;
      goto exit_selector; %page;
/**** Usecond is a 0-based quantity.  Thus any of the 1-based quantities     */
/****  will have to have 1 subtracted in order to "fit".		       */
sel (23):				/* "Uc", "(18)Z9"  Usec of calendar  */
      fld24 = cal_val.x;		/* Uc is 0-based		       */
      goto sel_dec_pic;

sel (27):				/* "Uy", "(14)Z9"	Usecond of year  */
      fld24 = time_value.dy - 1;	/*  dy is 1-based		       */
      goto sel (24);

sel (25):				/* "Um", "(13)Z9	Usecond of month */
      fld24 = time_value.dm - 1;	/* dm is 1-based		       */
      goto sel (24);

sel (26):				/* "Uw", "(12)Z9"	Usecond of week  */
      fld24 = time_value.dw - 1;	/* dw is 1-based  */

sel (24):				/* "Ud", "(11)Z9"	Usecond of day   */
      fld24 = fld24 * 24 + time_value.Hd; /* Hd is 0-based  */

sel (20):				/* "UH", "(10)Z9"	Usecond of Hour  */
      fld24 = fld24 * 60 + time_value.MH; /* MH is 0-based		       */

sel (21):				/* "UM", "(8)Z9"	Usecond of Minute*/
      fld24 = fld24 * 60 + time_value.SM; /* SM is 0-based		       */

sel (22):				/* "US", "(5)Z9"	Usecond of Second*/
      fld24 = fld24 * 1e6 + time_value.US; /* US is 0-based		       */
      goto sel_dec_pic;

sel (15):				/* "Sc", "(12)Z9"	Sec of calendar  */
      fld24 = convert (fld24, cal_val.x) / 1e6;
      goto sel_dec_pic;

sel (19):				/* "Sy", "(12)Z9"	Second of year   */
      fld24 = time_value.dy - 1;
      goto sel (16);

sel (17):				/* "Sm", "(8)Z9"	Second of month  */
      fld24 = time_value.dm - 1;
      goto sel (16);

sel (18):				/* "Sw", "(6)Z9"	Second of week   */
      fld24 = time_value.dw - 1;

sel (16):				/* "Sd", "(5)Z9"	Second of day    */
      fld24 = fld24 * 24 + time_value.Hd;

sel (13):				/* "SH", "(4)Z9"	Second of Hour   */
      fld24 = fld24 * 60 + time_value.MH;
      fld24 = fld24 * 60 + time_value.SM;
SM_fraction:
      if (pi.scale > 0)
      then fld24 = fld24 + convert (fld24, time_value.US) / 1e6;
      goto sel_dec_pic;

sel (14):				/* "SM", "99"	Second of Minute */
      if (Pic_l > 0)
      then do;
         fld24 = time_value.SM;
         goto SM_fraction;
      end;
      pic2 = time_value.SM;
      goto sel_pic2;

sel (08):				/* "Mc", "(10)Z9"	Min of calendar  */
      fld24 = convert (fld24, cal_val.x) / 6e7;	/* 60*1e6		       */
      goto sel_dec_pic;

sel (12):				/* "My", "(6)Z9"	Minute of year   */
      fld24 = time_value.dy - 1;
      goto sel (09);

sel (10):				/* "Mm", "(5)Z9"	Minute of month  */
      fld24 = time_value.dm - 1;
      goto sel (09);

sel (11):				/* "Mw", "(5)Z9"	Minute of week   */
      fld24 = time_value.dw - 1;

sel (09):				/* "Md", "(4)Z9"	Minute of day    */
      fld24 = fld24 * 24 + time_value.Hd;
      fld24 = fld24 * 60 + time_value.MH;
MH_fraction:
      if (pi.scale > 0)
      then do;
         fld24 = fld24 + convert (fld24, time_value.SM) / 60;
         fld24 = fld24 + convert (fld24, time_value.US) / 6e7; /* 60*1e6     */
      end;
      goto sel_dec_pic;

sel (07):				/* "MH", "99"	Minute of Hour   */
      if (Pic_l > 0)
      then do;
         fld24 = time_value.MH;
         goto MH_fraction;
      end;
      pic2 = time_value.MH;
      goto sel_pic2;

sel (01):				/* "Hc", "(8)Z9"	Hour of calendar */
      fld24 = convert (fld24, cal_val.x) / 36e8;	/* 60*60*1e6	       */
      goto sel_dec_pic;

sel (06):				/* "Hy", "(4)Z9"	Hour of year     */
      fld24 = time_value.dy - 1;
      goto Hday;

sel (04):				/* "Hm", "(3)Z9"	Hour of month    */
      fld24 = time_value.dm - 1;
      goto Hday;

sel (05):				/* "Hw", "(3)Z9"	Hour of week     */
      fld24 = time_value.dw - 1;
Hday:
      fld24 = fld24 * 24 + time_value.Hd;
Hd_fraction:
      if (pi.scale > 0)
      then do;
         fld24 = fld24 + convert (fld24, time_value.MH) / 60;
         fld24 = fld24 + convert (fld24, time_value.SM) / 36e2; /* 60*60     */
         fld24 = fld24 + convert (fld24, time_value.US) / 36e8; /* 60*60*1e6 */
      end;
      goto sel_dec_pic;

sel (02):				/* "Hd", "99"	Hour of day      */
      if (Pic_l > 0)
      then do;
         fld24 = time_value.Hd;
         goto Hd_fraction;
      end;
      pic2 = time_value.Hd;
      goto sel_pic2;

sel (03):				/* "Hh", "99"	Hour of half-day */
      fx2 = time_value.Hd;
      if (fx2 > 11) then fx2 = fx2 - 12;
      if (fx2 = 00) then fx2 = 12;
      if (Pic_l > 0)
      then do;
         fld24 = fx2;
         goto Hd_fraction;
      end;
      pic2 = fx2;
      goto sel_pic2;

sel (29):				/* "dc", "(7)Z9"	day of calendar  */
      fld24 = time_value.dc;
dc_fraction:
      if (pi.scale > 0)
      then do;
         fld24 = fld24 + convert (fld24, time_value.Hd) / 24;
         fld24 = fld24 + convert (fld24, time_value.MH) / 1440;  /* 24*60    */
         fld24 = fld24 + convert (fld24, time_value.SM) / 864e2; /* ..*60    */
         fld24 = fld24 + convert (fld24, time_value.US) / 864e8; /* ..*1e6   */
      end;
      goto sel_dec_pic;

sel (33):				/* "dy", "999"	day of year      */
      if (Pic_l = 0)
      then do;			/* if no specification,	       */
         Pic = "999";		/* ..we shall supply the default     */
         Pic_l = 3;			/* ..and go fake it.	       */
         goto Pic_expand;		/* ....(It'll be back)	       */
      end;			/* This is not optimized in any way  */
      fld24 = time_value.dy;		/* ..because it is felt to be a low  */
      goto dc_fraction;		/* ..usage datum.		       */

sel (30):				/* "dm", "99"	day of month     */
/****   Given: clock ^99v.9999dm feb15m ut -zone z +12hr		       */
/**** you get: 15.5000					       */
/**** i.e. 12 hours into feb15 is .5 day			       */

      if (Pic_l > 0)
      then do;
         fld24 = time_value.dm;
         goto dc_fraction;
      end;
      pic2 = time_value.dm;
      goto sel_pic2;

sel (32):				/* "dw", "9"	day of week      */
      if (Pic_l > 0)
      then do;
         fld24 = time_value.dw;
         goto dc_fraction;
      end;
      lresult = lresult || substr ("1234567", time_value.dw, 1);
      goto exit_selector;

sel (28):				/* "da", "(8)X"	day abbrev       */
      if format_max
      then do;
         ch64 = "";
         do i = 1 to 7;
	  if length (ch64) < length (ti_day.short (lang_index, i))
	  then ch64 = ti_day.short (lang_index, i);
         end;
      end;
      else ch64 = ti_day.short (lang_index, time_value.dw);
      goto sel_ascii;

sel (31):				/* "dn", "(15)X"	day name	       */
      if format_max
      then do;
         ch64 = "";
         do i = 1 to 7;
	  if length (ch64) < length (ti_day.long (lang_index, i))
	  then ch64 = ti_day.long (lang_index, i);
         end;
      end;
      else ch64 = ti_day.long (lang_index, time_value.dw);
      goto sel_ascii;

sel (42):				/* "fi", "aa"	fiscal indicator */
      ch64 = ti_word.word (lang_index, tiw_FiscalIndicator);
      goto sel_ascii;

sel (34):				/* "fw", "OOO999"	fiscal week      */
      if (Pic_l = 0)
      then do;			/* if no specification,	       */
         Pic = "OOO999";		/* ..we shall supply the default     */
         Pic_l = 6;			/* ..and go fake it.	       */
         goto Pic_expand;		/* ....(It'll be back)	       */
      end;
      fld24 = time_value.fw;
      goto sel_dec_pic;

sel (38):				/* "my", "99"	month of year    */
      if (Pic_l > 0)
      then do;
         fld24 = time_value.my;
         if (pi.scale ^= 0)
         then do;
/****       How many days in the month?				       */
	  if (time_value.my = FEBRUARY)
	  then unit_size = 28 + calc_leap_day ((time_value.yc));
	  else unit_size = days_in_month (time_value.my);
/****       How many microseconds is that? (-1 bias helps roundoff problem)  */
	  unit_size = (unit_size * 864) * 100000000 - 1;
	  t_interval = time_value.dm - 1;
	  t_interval = t_interval * 024 + time_value.Hd;
	  t_interval = t_interval * 060 + time_value.MH;
	  t_interval = t_interval * 060 + time_value.SM;
	  t_interval = t_interval * 1000000 + time_value.US;
	  fld24 = fld24 + make_fraction (t_interval, unit_size);
         end;
         goto sel_dec;
      end;
      pic2 = time_value.my;
      goto sel_pic2;

sel (37):				/* "mn", "(15)X"	month name       */
      if format_max
      then do;
         ch64 = "";
         do i = 1 to 12;
	  if length (ch64) < length (ti_month.long (lang_index, i))
	  then ch64 = ti_month.long (lang_index, i);
         end;
      end;
      else ch64 = ti_month.long (lang_index, time_value.my);
      goto sel_ascii;

sel (35):				/* "ma", "(8)X"	month abbrev     */
      if format_max
      then do;
         ch64 = "";
         do i = 1 to 12;
	  if length (ch64) < length (ti_month.short (lang_index, i))
	  then ch64 = ti_month.short (lang_index, i);
         end;
      end;
      else ch64 = ti_month.short (lang_index, time_value.my);
      goto sel_ascii;

sel (39):				/* "yc", "OO99"	year of calendar */
      if (Pic_l > 0)
      then do;
         fld24 = time_value.yc;
         if (pi.scale ^= 0)
         then do;
/****       How many days in the year?				       */
	  if (time_value.yc = 1582)
	  then unit_size = 355;
	  else unit_size = 365 + calc_leap_day (time_value.yc);
/****       How many microseconds is that? (-1 bias helps roundoff problem)  */
	  unit_size = (unit_size * 864) * 100000000 - 1;
	  t_interval = time_value.dy - 1;
	  t_interval = t_interval * 024 + time_value.Hd;
	  t_interval = t_interval * 060 + time_value.MH;
	  t_interval = t_interval * 060 + time_value.SM;
	  t_interval = t_interval * 1000000 + time_value.US;
	  fld24 = fld24 + make_fraction (t_interval, unit_size);
         end;
         goto sel_dec;
      end;
      pic2 = mod (time_value.yc, 100);
      goto sel_pic2;

sel (36):				/* "mi", "a"	meridiem indic.  */
      if (time_value.Hd < 12)
      then ch64 = "A";
      else ch64 = "P";
      goto sel_ascii;

sel (41):				/* "zn", "(64)X"	zone name	       */
      if format_max
      then do;
         ch64 = "";
         do i = 1 to ti_zone.number_zone;
	  if length (ch64) < length (ti_zone.long (lang_index, i))
	      then ch64 = ti_zone.long (lang_index, i);
         end;
      end;
      else ch64 = ti_zone.long (lang_index, time_value.zone_index);
      goto sel_ascii;

sel (40):				/* "za", "(8)X"	zone abbrev      */
      if format_max
      then do;
         ch64 = "";
         do i = 1 to ti_zone.number_zone;
	  if length (ch64) < length (ti_zone.short (lang_index, i))
	  then ch64 = ti_zone.short (lang_index, i);
         end;
      end;
      else ch64 = ti_zone.short (lang_index, time_value.zone_index);
      goto sel_ascii;

sel (43):				/* "zd", "s9999"	z. differential  */
      ch64 = zone_dif (ti_zone.delta (lang_index, time_value.zone_index));
      goto sel_ascii;

zone_dif: proc (td) returns (char (5));
dcl td		fixed bin (71);

dcl time		fixed bin (71);
dcl 1 result,
      2 s		char (1),
      2 (HH,MM)	pic "99";

	time = td;
	s = "-";			/* values stored in table have       */
	if (time < 0)		/* ..opposite sign from the way it   */
	then do;			/* ..is displayed.		       */
	   s = "+";
	   time = -time;
	end;
	HH, i = divide (time, 3600000000, 17, 0);
	time = time - i*3600000000;
	MM = divide (time, 60000000, 17, 0);
	return (string (result));
       end zone_dif;

   end proc_selector;		/* <##> */ %page;
/* @@@@@@ int proc .. vc_2_Multics				       */
/* ***********************************+************************************* */
/* ***********************************+************************************* */
vc_2_Multics: proc (cval, Mval);	/* <<##>> */

dcl 1 cval	like cal_val,	/* virtual value		   [In]*/
    Mval		fixed bin (71);	/* Multics value		  [Out]*/

dcl (
    error_table_$dt_date_too_big,	/* <##> */
    error_table_$dt_date_too_small	/* <##> */
    )		fixed bin (35) ext static;

      Mval = 0;
      if (cval.x > max_vc_value)
      then lcode = binary (error_table_$dt_date_too_big);
      else if (cval.x < 0)
      then lcode = binary (error_table_$dt_date_too_small);
      else Mval			/* make GMT Multics value	       */
	    = cval.x - M_vc_adjust + cval.dx;
      return;

   end vc_2_Multics;		/* <##> */ %page;
/* @@@@@@ int proc .. ymd_to_days				       */
/* ************************************************************************* */
/**** This converts either yc,my,dm  or yc,dy  into dc.	fw is ignored    */
/**** cal_val.J_G is set to reflect Julian or Gregorian		       */
/* ************************************************************************* */

ymd_to_days: proc;			/* <<##>> */

dcl adjustment	fixed bin;
dcl (
    error_table_$dt_bad_dm,		/* <##> */
    error_table_$dt_bad_dy,		/* <##> */
    error_table_$dt_bad_my,		/* <##> */
    error_table_$dt_date_not_exist	/* <##> */
    )		fixed bin (35) ext static;

/**** Figure out which calendar we are in.			       */
      cal_val.J_G = Gregorian;
      if (time_value.yc < 1583)
      then do;
         cal_val.J_G = Julian;
         if (time_value.yc = 1582)
         then do;			/* 1582 only had 355 days	       */
	  if (time_value.dy > 355)
	  then do;
	     lcode = binary (error_table_$dt_bad_dy);
	     return;
	  end;
	  if (time_value.dy > 277)	/* > 1582-10-04		       */
	     | (time_value.my > OCTOBER)
	  then cal_val.J_G = Gregorian;
	  else if (time_value.my = OCTOBER)
	  then do;
	     if (time_value.dm > 14)
	     then cal_val.J_G = Gregorian;
	     else if (time_value.dm > 4)
	     then do;
	        lcode = binary (error_table_$dt_date_not_exist);
	        return;
	     end;
	  end;
         end;
      end;
/**** Break down the date into the cycles it contains and find if leap year. */
      A, B, C = 1;
      lyear = time_value.yc - 1;	/* yc is 1-based, we need 0-based    */
      if (cal_val.J_G = Julian)
      then num_of__400s, num_of__100s = 0;
      else do;
         num_of__400s = divide (lyear, 400, 17);
         lyear = lyear - num_of__400s * 400;
         if (lyear = 399) then C = 0;

         num_of__100s = divide (lyear, 100, 17);
         lyear = lyear - num_of__100s * 100;
         if (lyear = 99) then B = 0;
      end;
      num_of____4s = divide (lyear, 4, 2);
      num_of____1s = lyear - num_of____4s * 4;

      if (num_of____1s >= 3)		/* =4 on last day of leap year       */
      then A = 0;
      leap_day = 1 - A + B - C;
/**** figure how many days in calendar prior to this year.		       */
      lclock_days
         = num_of__400s * 146097
         + num_of__100s * 36524
         + num_of____4s * 1461
         + num_of____1s * 365;

      if (time_value.dy > 0)
      then do;			/* day-in-year is given	       */
/****    Make sure day-in-year is a valid #. 1582 only has 355 days.	       */
         if (time_value.dy > 365 + leap_day)
	  | (time_value.yc = 1582 & time_value.dy > 355)
         then do;			/* not valid day-in-year	       */
	  lcode = binary (error_table_$dt_bad_dy);
	  return;
         end;

/****    The Gregorian cycles don't know anything about any missing 10 days. */
/****    The convention used here is that the days are numbered from 1:355   */
/****    in 1582.  Thus the last part of 1582 needs to be pushed up by 10 so */
/****    it falls in the right place in the cycle.		       */
         if (time_value.yc = 1582) & (time_value.dy > 277)
         then adjustment = 10;	/* kept separate for debug display   */
         else adjustment = 0;
/****    NOTE1: The base of the Gregorian cycles is 2 days different from    */
/****    the base of the Julian cycle.  We must adjust the numbers so that   */
/****    the day-in-calendar of 1582-10-04 is 1 less that of 1582-10-15,     */
/****    since this is the way it occurred.			       */
         if (cal_val.J_G = Gregorian)
         then lclock_days = lclock_days + 2;

         lclock_days = lclock_days + adjustment + time_value.dy;
      end;
      else do;
         if (time_value.my < 1)
	  | (time_value.my > 12)
         then do;			/* month must be 1:12	       */
	  lcode = binary (error_table_$dt_bad_my);
	  return;
         end;
         if (time_value.dm < 1)	/* N days per month		       */
	  | (time_value.dm > days_in_month (time_value.my)
	  + fixed (time_value.my = FEBRUARY) * leap_day)
         then do;			/* day must be 1:(SizeOfMonth)       */
	  lcode = binary (error_table_$dt_bad_dm);
	  return;
         end;
         lclock_days = lclock_days + before_month (time_value.my)
	  + leap_day * fixed (time_value.my > FEBRUARY) + time_value.dm;
         if (cal_val.J_G = Gregorian)	/* See NOTE1 above		       */
         then lclock_days = lclock_days + 2;
      end;

   end ymd_to_days;			/* <##> */ %page;
dcl (
    Gregorian	init (1),
    Julian	init (2),
    Special	init (3),
    None		init (4),
    FEBRUARY	init (2),
    MARCH		init (3),
    OCTOBER	init (10)
    )		fixed bin int static options (constant);

dcl (A, B, C)	fixed bin;
dcl lclock_days	fixed bin (27);
dcl leap_day	fixed bin;	/* number of Feb 29's in this year.  */
dcl lyear		fixed bin (35);
dcl rest_of__400	fixed bin;	/* days left from  400 year cycle    */
dcl rest_of__100	fixed bin;	/* days left from  100 year cycle    */
dcl rest_of____4	fixed bin;	/* days left from    4 year cycle    */
dcl rest_of____1	fixed bin;	/* days left from    1 year cycle    */

dcl num_of__400s	fixed bin;	/* number of  400 year cycles	       */
dcl num_of__100s	fixed bin;	/* number of  100 year cycles	       */
dcl num_of____4s	fixed bin;	/* number of    4 year cycles	       */
dcl num_of____1s	fixed bin;	/* number of      years left	       */
dcl cur_unit	fixed bin;
dcl day_adjust	fixed bin;
dcl diw		fixed bin;
dcl fb24		fixed bin (24);
dcl fiscal_week_value fixed bin (24);
dcl fiscal_year_value fixed bin (24);
dcl unit_sizes	(3:8) fixed bin (71) int static options (constant) init (
		6048e8, 864e8, 36e8, 6e7, 1e6, 1);
   /***		wk      da     hr    min  sec  Usec		       */
dcl temp_clock	fixed bin (71);	/* holds a Multics clock value       */
dcl arg_l		fixed bin (35);
dcl arg_p		ptr;
dcl arg_t		fixed bin;
dcl AZ		char (26) int static options (constant) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
dcl az		char (26) int static options (constant) init ("abcdefghijklmnopqrstuvwxyz");

dcl 1 cal_val,			/* x+dx gives virtual clock in GMT   */
      2 x		fixed bin (71),	/* calendar value		       */
      2 dx	fixed bin (71),	/* delta			       */
      2 z		char (5),		/* zone it's in		       */
      2 zi	fixed bin,	/* zone_index of cal_val.z	       */
				/* =0 => cal_val.z is differential   */
      2 J_G	fixed bin;	/* Julian/Gregorian indicator	       */
dcl 1 (ref_val, off_val) like cal_val;

/* format: off		       */
dcl (
/*		    0  1   2   3   4   5   6   7   8   9  10  11  12  13 */
/*		    . jan feb mar apr may jun jul aug sep oct nov dec .  */
    days_in_month init (0,031,028,031,030,031,030,031,031,030,031,030,031,000),
    before_month  init (0,000,031,059,090,120,151,181,212,243,273,304,334,365)
    )		(0:13) fixed bin int static options (constant);
				/* format: on		       */

dcl errloc	fixed bin;
dcl 1 errlocad	aligned,		/* error location adjustments.       */
      2 n		fixed bin,
      2 unadjusted_errloc
		fixed bin,
      2 keywords (20),
        3 start	fixed bin,	/* column in which keyword started.  */
        3 enclosed_key		/* =1 for ^<key>		       */
		fixed bin,	/* =0 for key		       */
        3 old_len	fixed bin,	/* length (original keyword).	       */
        3 new_len	fixed bin;	/* length (keyword value).	       */
dcl fld24		float dec (24);
dcl format_i	fixed bin;
dcl i		fixed bin;
dcl lang_index	fixed bin;
dcl lcode		fixed bin (35);
dcl lformat	char (512) var;
dcl temp_512_v	char (512) var;
dcl lresult	char (256) var;
dcl pic2		pic "99";
dcl pic4		pic "9999";
dcl picloc	fixed bin;
dcl sys_info$time_zone char (4) ext static;
dcl Tday		fixed bin;
dcl t_interval	fixed bin (71);
dcl Tmonth	fixed bin;
dcl Tusec		fixed bin (71);
dcl Tyear		fixed bin;
dcl unit_size	fixed bin (71);
dcl zone_index	fixed bin;

dcl 1 auto_time_value aligned like time_value;
dcl 1 auto_time_offset aligned like time_offset;
dcl 1 decoded_clock aligned like time_value;
dcl 1 decoded_ref	aligned like time_value;
dcl 1 fs_time_value aligned based,
      2 pad1	bit (20) unal,
      2 time	bit (36) unal,
      2 pad2	bit (16) unal;

dcl com_err_	entry options (variable);
dcl date_time_$set_time_defaults entry;

dcl (addr, addrel, after, before, convert, copy, divide, fixed, hbound, index,
    lbound, length, ltrim, min, mod, null, precision, reverse, string, substr,
    translate, trunc, unspec, verify) builtin; %page;
%include time_names;
%include time_info_search;
%include time_defaults_;
%include time_value;
%include time_offset;

/* ***********************************+************************************* */
/* During debugging, there is an internal procedure named binary which is    */
/*  central point thru which all error codes are set.  It allows me to catch */
/*  when error codes are being set.  Once debugging is complete, the	       */
/*  definition of it is deleted and the calls revert to the builtin, which   */
/*  has no effect on the generated code.			       */
/* ***********************************+************************************* */
dcl binary builtin;
   end date_time_;
