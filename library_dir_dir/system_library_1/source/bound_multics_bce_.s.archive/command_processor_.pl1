/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/* format: off */

/* The Multics Command Processor */

/* Created:  1 May 1976 by Steve Herbst */
/* Modified and reorganized by Jay Goldman, '77 */
/* Reorganized and fixed bugs: February-March 1978 by Gary Palter */
/* Modified: June 1978 by G. Palter to fix several bugs and implement new definition of |[, ||[, |], and |; */
/* Modified: 5-6 August 1978 by G. Palter to make command_processor_$af work properly */
/* Modified: 13 August 1978 by G. Palter to not forget about temporary segments */
/* Modified: 11 September 1978 by G. Palter to remove definition of |; */
/* Modified: 31 October 1978 by G. Palter to call fc_no_message when invoked as cp_$af */
/* Modified: 29 November 1978 by G. Palter to implement newer definition of |[ */
/* Modified: 23 June 1979 by G. Palter to make null iteration sets within brackets not be considered an error
      but instead return no value */
/* Modified: 13 July 1979 by G. Palter to fix a bug wherein an &if clause in an exec_com with unbalanced brackets
      causes a fault in match_iters */
/* Modified: 16 August 1979 by G. Palter to not bother to zero the automatic node block before returning */
/* Modified: 14 March 1980 by G. Palter to add faster simple command processing */
/* Modified: 31 March 1980 by G. Palter to add new directly callable interfaces and the subsystem entries */
/* Modified: 5 May 1980 by G. Palter to change calling sequence of eval_string entries and add include file for active
      string types */
/* Modified: 7 May 1980 by G. Palter to change calling sequence of subsys* entries to include a subsys_cp_info_ptr; this
      pointer is presently unused, however */
/* Modified: 3 October 1980 by G. Palter to fix bug #0016 -- the command processor takes an out_of_bounds fault when
      passed a zero-length input line (TR07834) */
/* Modified: 1 December 1980 by G. Palter to fix bug #0017 -- the command processor may cause the PL/1 free_based
      operator to take a random fault when processing a null command line */
/* Modified: May-June 1982 by G. Palter to (1) make simple_command_processor a quick block, (2) create the
      complex_command_processor internal procedure to hold all automatic storage not shared by the simple and complex
      command processor cases, (3) add support for tailoring the request line language within subsystems (eg: disabling
      iteration), (4) delete command_processor_$af (finally!), and (5) fix several bugs relating to temporary segment
      management and treatment of semicolons in active function/request return values (command_processor 5, 21, 22) */
/* Modified: March 1984 by Keith Loepere for non-existant error_table_$bad_subr_call */
/* Modified: July 1984 by G. Palter to use multiple permanent scratch segments in order to improve the performance of
      recursive invocations of the evaluate_active_string entrypoints such as those made by the LINUS Report Writer */


/****^  HISTORY COMMENTS:
  1) change(86-05-17,GDixon), approve(86-05-17,MCR7357),
     audit(86-06-16,Farley), install(86-07-17,MR12.0-1097):
     Change call to tct_ to reference find_char_$first_in_table instead. This
     subroutine has been renamed.
  2) change(86-05-17,DGHowe), approve(86-05-15,MCR7375),
     audit(86-07-15,Schroth), install(86-08-01,MR12.0-1108):
     added the ability to save the command name given on the command line to
     simple_command_processor and produce_argument_list.
  3) change(87-07-13,GWMay), approve(87-07-13,MCR7730), audit(87-08-10,JRGray),
     install(87-09-10,MR12.1-1104):
     Added the ability to pipe data between commands and files.
  4) change(87-09-10,GWMay), approve(87-09-10,MCR7730), audit(87-09-10,GDixon),
     install(87-09-10,MR12.1-1104):
     Changed position within the code where the pipe structure is suspended
     and restored.  Fixed several problems found by the security auditor.
  5) change(87-09-10,GWMay), approve(87-09-10,PBF7730), audit(87-09-14,GDixon),
     install(87-09-15,MR12.1-1107):
     Remove extra call to copy_thru_pipe from the process_pipe_command routine.
     Matching attaches are handled in the process_attach_description code.
  6) change(87-12-15,GWMay), approve(87-12-15,MCR7810), audit(87-12-15,GDixon),
     install(88-01-12,MR12.2-1011):
     Changed call main error return call to com_err_ to only output a newline
     when there is error text.
  7) change(88-02-03,GWMay), approve(88-02-25,MCR7848),
     audit(88-02-26,Fawcett), install(88-03-01,MR12.2-1029):
     Changed pipe facility to allow $ in the name of a command.
                                                   END HISTORY COMMENTS */
%page;
/*  LIMITATIONS AN KNOWN BUGS:  */

/*  1)  Nested iteration sets will not return the expected results.

        example:

        string (xxx_(a b) (c d)_yyy zzz)

        intermixes the inner interation set.

    2)  The pipe processing code cannot deal with pipes that are
        embedded as part of an active return string.

        examples:

        string "show;|cols";| xx
        ls;| [contents xx;|]

        string [[ioa_ "string (ab a bc cd ae ef);|match /a/";|]]

        Because the pipe code evaluates the command line as it is input,
        the value returned by the active string will not be diagnosed
        correctly as a pipe.
*/        
%page;
/* format: on,style4,delnl,insnl,ifthenstmt,ifthen */

command_processor_:
     procedure (P_line_ptr, P_line_len, P_code);


/* Parameters */

dcl  P_line_ptr pointer parameter;			/* command_processor_: -> line to process (input) */
dcl  P_line_len fixed binary (21) parameter;		/* command_processor_: length of line to process (input) */

dcl  P_line character (*) parameter;			/* *execute_line, *eval_string: line to process (input) */

dcl  P_return_value character (*) varying parameter;	/* *eval_string: result of evaluation (output) */

dcl  P_eval_string_options_ptr pointer parameter;		/* eval_string: -> options controlling interpretation of the
						   active string (unused at present) (input) */

dcl  P_active_string_type fixed binary parameter;		/* *eval_string: type of active string (input) */

dcl  P_cp_subsys_info_ptr pointer parameter;		/* subsys_*, validate_cp_subsys_info: -> options controlling
						   interpretation of the request line (input) */

dcl  P_subsystem_name character (*) parameter;		/* subsys_*: the subsystem (input) */
dcl  P_subsystem_info_ptr pointer parameter;		/* subsys_*: -> data used by the subsystem (input) */
dcl  P_execute_request entry (pointer, character (*), pointer, fixed binary (35)) variable parameter;
						/* subsys_*: procedure to lookup & execute request (input) */

dcl  P_old_execute_request entry (character (*), pointer, fixed binary (35)) variable parameter;
						/* execute_command_line_: same as above (input) */

dcl  P_code fixed binary (35) parameter;		/* *: status code (output) */


/* Local copies of parameters */

dcl  line character (line_len) unaligned based (line_ptr);
dcl  line_ptr pointer;
dcl  line_len fixed binary (21);

dcl  execute_request entry (pointer, character (*), pointer, fixed binary (35)) variable;
dcl  old_execute_request entry (character (*), pointer, fixed binary (35)) variable;

dcl  code fixed binary (35);
dcl  ignore_code fixed bin (35);			/* this value is for speed, never check it */

/* Remaining declarations */

dcl  multics_cp bit (1) aligned;			/* ON => Multics entry;  OFF => subsystem entry */
dcl  evaluate_string bit (1) aligned;			/* ON => called to evaluate an active string */
dcl  new_subsystem_call bit (1) aligned;		/* ON => new form of execute_request, etc */

dcl  null_cl bit (1) aligned;				/* ON => command line is only whitspace */

dcl  complex_line bit (1) aligned;			/* ON => command line contains quoting, iteration, active
						   strings, or commands with more than 32 arguments */

dcl  lss_on bit (1) aligned;				/* ON => running Limited Service System */

dcl  use_standard_language bit (1) aligned;		/* ON => can use PL/I builtins for search */

dcl  executing bit (1) aligned;			/* ON => executing a command at the moment */
dcl  abort_command_execution label variable;

dcl  top_level_string_type fixed binary;		/* for evaluating active strings: [], |[], ||[] */

dcl  start fixed binary (21);

dcl  error_message char (256) varying;

dcl  COMMAND_PROCESSOR_ character (32) static options (constant) initial ("command_processor_");
dcl  EXECUTE_COMMAND_LINE_ character (32) static options (constant) initial ("execute_command_line_");

dcl  MAX_STACK_EXTENSION fixed binary (21) static options (constant) initial (16384);
						/* do not extend stack more than 16 pages */
dcl  MIN_AF_RETURN_LTH fixed binary (21) static options (constant) initial (32768);
						/* always give active function at least 32K chars */

/* format: off */
dcl (error_table_$bad_file_name,
    error_table_$bad_pipe_syntax,
    error_table_$bad_subr_arg,
    error_table_$command_line_overflow,
    error_table_$mismatched_iter,
    error_table_$null_brackets,
    error_table_$no_file,
    error_table_$noentry,
    error_table_$unbalanced_brackets,
    error_table_$unbalanced_parentheses,
    error_table_$unbalanced_quotes,
    error_table_$unimplemented_version)
	fixed binary (35) external;
/* format: on */

dcl  sys_info$max_seg_size fixed binary (19) external;

dcl  absolute_pathname_ entry (char (*), char (*), fixed bin (35));
dcl  check_star_name_ entry (char (*), bit (36), fixed bin (2), fixed bin (35));
dcl  com_err_ entry () options (variable);
dcl  cu_$gen_call entry (pointer, pointer);
dcl  cu_$grow_stack_frame entry (fixed binary (21), pointer, fixed binary (35));
dcl  find_char_$first_in_table entry (char (*), char (512) aligned) returns (fixed bin (21)) reducible;
dcl  find_command_ entry (pointer, fixed binary, pointer, fixed binary (35));
dcl  find_command_$fc_no_message entry (pointer, fixed binary, pointer, fixed binary (35));
dcl  get_system_free_area_ entry () returns (pointer);
dcl  get_temp_segment_ entry (character (*), pointer, fixed binary (35));
dcl  get_wdir_ entry () returns (char (168));
dcl  hcs_$get_uid_file entry (char (*), char (*), bit (36) aligned, fixed bin (35));
dcl  pipe_$terminate entry (ptr, ptr, fixed bin (35));
dcl  release_temp_segment_ entry (character (*), pointer, fixed binary (35));
dcl  release_temp_segments_ entry (character (*), (*) pointer, fixed binary (35));
dcl  sub_err_ entry () options (variable);
dcl  transform_command_ entry (pointer, fixed binary, pointer, fixed binary (35));

dcl  (cleanup, command_abort_, request_abort_) condition;

dcl  (addr, addcharno, addrel, after, before, bit, currentsize, dimension, divide, fixed, hbound, index, lbound, length,
     ltrim, low, max, maxlength, min, mod, null, rank, rtrim, search, stacq, substr, unspec, verify) builtin;
%page;
/* Various combinations of those characters special to command language: many almost blank listing pages follow ... */

dcl  BREAKS character (12) static options (constant) initial (";()[]""|
	 ");						/* command language break characters and NL, HT, SP, VT, FF */

dcl  TOKEN_BREAKS character (6) static options (constant) initial ("""
	 ");						/* breaks for tokens only: " NL HT SP VT FF */

dcl  SIMPLE_BREAKS character (6) static options (constant) initial (";
	 ");						/* ; and whitespace (NL HT SP VT FF) */

dcl  NON_SIMPLE_BREAKS character (6) static options (constant) initial ("()[]""|");
						/* characters requiring special processing */

dcl  PIPE_BREAK character (2) static options (constant) initial (";|");

dcl  LEFT_BRACKET character (1) static options (constant) initial ("[");

dcl  RIGHT_BRACKET character (1) static options (constant) initial ("]");

dcl  VERTICAL_BAR character (1) static options (constant) initial ("|");

dcl  COMMAND_BREAKS character (2) static options (constant) initial (";
");						/* characters which separate command invocations (;, NL) */
dcl  SPACE character (1) internal static options (constant) init (" ");
%page;
/* Execute a Multics command line:  this entry is intended to be called only via cu_$cp */

/* command_processor_: entry (P_line_ptr, P_line_len, P_code); */

	multics_cp = "1"b;				/* not a subsystem invocation */
	new_subsystem_call = "0"b;
	evaluate_string = "0"b;
	line_ptr = P_line_ptr;
	line_len = P_line_len;
	go to CONTINUE_SETUP;


/* Evaluate a Multics active string */

eval_string:
     entry (P_eval_string_options_ptr, P_line, P_active_string_type, P_return_value, P_code);

	multics_cp = "1"b;				/* not a subsystem */
	new_subsystem_call = "0"b;
	evaluate_string = "1"b;
	top_level_string_type = max (P_active_string_type, NORMAL_ACTIVE_STRING);
	top_level_string_type = min (top_level_string_type, ATOMIC_ACTIVE_STRING);
						/* defaults to [] */
	go to SETUP;


/* Execute a subsystem request line:  the caller must supply a procedure which is used to find and execute each request */

subsys_execute_line:
     entry (P_subsystem_name, P_subsystem_info_ptr, P_execute_request, P_cp_subsys_info_ptr, P_line, P_code);

	multics_cp = "0"b;				/* this is a subsystem */
	new_subsystem_call = "1"b;
	evaluate_string = "0"b;
	lss_on = "0"b;
	go to SETUP;


/* Execute a subsystem request line:  this is an obsolete entry provided for compatibility */

execute_command_line_:
     entry (P_line, P_old_execute_request, P_code);

	multics_cp = "0"b;
	new_subsystem_call = "0"b;			/* use old fashioned calling sequence */
	evaluate_string = "0"b;
	lss_on = "0"b;
	go to SETUP;


/* Evaluate a subsystem active string */

subsys_eval_string:
     entry (P_subsystem_name, P_subsystem_info_ptr, P_execute_request, P_cp_subsys_info_ptr, P_line, P_active_string_type,
	P_return_value, P_code);

	multics_cp = "0"b;
	new_subsystem_call = "1"b;
	evaluate_string = "1"b;
	lss_on = "0"b;
	top_level_string_type = max (P_active_string_type, NORMAL_ACTIVE_STRING);
	top_level_string_type = min (top_level_string_type, ATOMIC_ACTIVE_STRING);
	go to SETUP;
%page;
/* Execute/evaluate the command/request line/active-string:  for simplicity, all future references will assume that a
   Multics command line is being executed */

SETUP:
	line_ptr = addr (P_line);			/* this point is reached by all but command_processor_ */
	line_len = length (P_line);

CONTINUE_SETUP:					/* command_processor_ joins here */
	error_message = "";
	code = 0;

	use_standard_language = "1"b;			/* until proven otherwise: assume normal case */

	if ^multics_cp then				/* subsystem entries: check for special request language */
	     if new_subsystem_call then
		if P_cp_subsys_info_ptr ^= null () then do;
		     cp_subsys_info_ptr = P_cp_subsys_info_ptr;
		     if cp_subsys_info.version ^= CP_SUBSYS_INFO_VERSION_1 then do;
RESIGNAL_INCOMPATIBLE_SUBSYSTEM_INFO:			/* wrong version is quite fatal */
			call sub_err_ (error_table_$unimplemented_version, COMMAND_PROCESSOR_, ACTION_CANT_RESTART,
			     null (), (0), "^24.3b from subsystem ^a.", unspec (cp_subsys_info.version),
			     P_subsystem_name);
			go to RESIGNAL_INCOMPATIBLE_SUBSYSTEM_INFO;
		     end;
		     use_standard_language = ^cp_subsys_info.non_standard_language;
		end;

	if evaluate_string then P_return_value = "";	/* initialize the return value */

	if use_standard_language then do;		/* can perform some short cuts for the normal language */
	     line_len = length (rtrim (line, SIMPLE_BREAKS));
	     start = verify (line, SIMPLE_BREAKS);	/* ... strip leading/trailing whitespace/null commands */
	     null_cl = (start = 0);
	     if null_cl then do;			/* ... the line is empty */
		complex_line = "0"b;
		go to SILENTLY_RETURN_FROM_CP;
	     end;
	end;
	else do;					/* have no idea what the whitespace characters are ... */
	     start = 1;				/* ... must scan the entire line */
	     null_cl = "1"b;			/* ... until proven otherwise by complex_command_processor */
	end;

	if multics_cp then
	     lss_on = cp_data_$under_lss;		/* running under Limited Service System */
	else do;					/* a subsystem entry: get the appropriate apply procedure */
	     if new_subsystem_call then
		execute_request = P_execute_request;
	     else old_execute_request = P_old_execute_request;
	end;

	if evaluate_string then			/* evaluating an active string: always a complex operation */
	     complex_line = "1"b;
	else if use_standard_language then		/* standard language: try faster command processor if OK */
						/* The pipe token ";|" does not need to be checked here  */
						/* because "|" is a non-simple break which will set the  */
						/* complex line switch on.			       */
	     complex_line = (search (substr (line, start), NON_SIMPLE_BREAKS) ^= 0);
	else complex_line = "1"b;			/* no idea what the language is like */

	if ^complex_line then do;			/* first try faster command processor ... */
	     executing = "0"b;			/* ... execution is not in progress */
	     abort_command_execution = SILENTLY_RETURN_FROM_CP;
	     if multics_cp then			/* ... establish appropriate abort handler once */
		on condition (command_abort_)
		     begin;
		     if executing then go to abort_command_execution;
		end;
	     else on condition (request_abort_)
		     begin;
		     if executing then go to abort_command_execution;
		end;
	     call simple_command_processor (line_ptr, line_len, start, complex_line);
	     if multics_cp then
		revert condition (command_abort_);
	     else revert condition (request_abort_);
	end;

	if complex_line then call complex_command_processor (line_ptr, line_len, start);

RETURN_FROM_CP:
	if (code ^= 0) & ^evaluate_string then
	     if multics_cp then call com_err_ (code, COMMAND_PROCESSOR_,
"^[^/^]^a", error_message ^= "", error_message);
	     else if new_subsystem_call then call com_err_ (code, P_subsystem_name, "^/^a", error_message);
	     else call com_err_ (code, EXECUTE_COMMAND_LINE_, "^/^a", error_message);

SILENTLY_RETURN_FROM_CP:
	if (code = 0) & null_cl then code = 100;

	P_code = code;

	return;
%page;
/* Simple command processor:  processes command lines which do not contain quoted strings, iteration, or active strings.
   Argument lists are constructed and commands invoked until either the entire command line is processed or a command
   invocation if found with more than 32 arguments in which case the full command processor must be used */

simple_command_processor:
     procedure (p_line_ptr, p_line_lth, p_start, p_complex_line) /* options (quick) */;


/* Parameters */

dcl  p_line_ptr pointer parameter;			/* -> command line to execute */
dcl  p_line_lth fixed binary (21) parameter;		/* length of above command line */
dcl  p_start fixed binary (21) parameter;		/* where to start in the command line */
dcl  p_complex_line bit (1) aligned parameter;		/* set ON => something in this command line was too much to
						   handle -- the normal processor must be used */


/* Local copies of parameters */

dcl  line character (line_lth) unaligned based (line_ptr);	/* command line being processed */
dcl  (line_lth, start) fixed binary (21);
dcl  line_ptr pointer;


/* Remaining declarations */

dcl  1 arg_list aligned,				/* the argument list being constructed */
       2 twice_n_arguments fixed binary (18) unaligned unsigned,
       2 tag bit (18) unaligned initial ("000004"b3),	/* PL/1 */
       2 twice_n_descriptors fixed binary (18) unaligned unsigned,
       2 has_command_name bit (1) unal,
       2 pad bit (17) unal,
       2 arg_ptrs (32) pointer,
       2 descriptor_ptrs (32) pointer,
       2 name,
         3 command_name_ptr pointer,
         3 command_name_length fixed bin (21);

dcl  1 descriptors (32) aligned,			/* descriptions of above arguments */
       2 bits bit (12) unaligned,			/* flag(1), type(6), packed(1), ndims(4) */
       2 size fixed binary (24) unaligned unsigned;

dcl  descriptor_ptrs_for_move bit (72 * n_arguments) aligned based;
						/* to move descriptor pointers to proper place in arglist */
dcl  command_name_for_move bit (144) aligned based;
dcl  arg_list_overlay (68) bit (72) based (addr (arg_list.arg_ptrs (1)));
dcl  saved_start fixed binary (21);			/* where each command start in case it aborts */

dcl  reading_command_name bit (1) aligned;		/* ON => picking up command name, not an argument */
dcl  end_of_command bit (1) aligned;			/* ON => reached the end of a command */

dcl  n_arguments fixed binary;			/* # of arguments for this command */

dcl  (token_lth, next_start) fixed binary (21);

dcl  command_name character (command_name_lth) unaligned based (command_name_ptr);
dcl  command_name_ptr pointer;			/* -> name of the command to invoke */
dcl  command_name_lth fixed binary;
dcl  command_entry_ptr pointer;			/* -> the actual command to be run */
%page;
	line_ptr = p_line_ptr;
	line_lth = p_line_lth;
	start = p_start;

	abort_command_execution = ABORT_COMMAND_EXECUTION;/* bypass PL/I's lexical scoping rules */

	do while (start <= line_lth);

	     saved_start = start;			/* save start of command in case not simple */

	     reading_command_name = "1"b;
	     end_of_command = "0"b;
	     n_arguments = 0;

	     do while (^end_of_command);

		token_lth = search (substr (line, start), SIMPLE_BREAKS) - 1;

		if token_lth = -1 then		/* rest of the command line */
		     token_lth = line_lth - start + 1;	/* break is one beyond the end */

		if reading_command_name then do;
		     command_name_ptr = addr (substr (line, start, 1));
		     command_name_lth = token_lth;
		     reading_command_name = "0"b;
		end;
		else do;
		     n_arguments = n_arguments + 1;
		     if n_arguments > hbound (arg_list.arg_ptrs, 1) then do;
			p_start = saved_start;	/* command has too many arguments: use full processor */
			p_complex_line = "1"b;
			return;
		     end;
		     arg_list.arg_ptrs (n_arguments) = addr (substr (line, start, 1));
		     arg_list.descriptor_ptrs (n_arguments) = addr (descriptors (n_arguments));
		     descriptors (n_arguments).bits = "5260"b3;
						/* unaligned, nonvarying string */
		     descriptors (n_arguments).size = token_lth;
		end;

		start = start + token_lth;		/* skip over token to delimiters */

		if (start > line_lth) then
		     end_of_command = "1"b;		/* entire line used */

		else do;				/* search for next token and check for end of a command
						   invocation (semicolon or newline in delimiters) */
		     next_start = verify (substr (line, start), SIMPLE_BREAKS);
		     if (next_start = 0) then do;	/* rest of line is delimiters */
			next_start = line_lth - start + 2;
			end_of_command = "1"b;
		     end;
		     else end_of_command = (search (substr (line, start, (next_start - 1)), COMMAND_BREAKS) ^= 0);
		     start = start + next_start - 1;
		end;
	     end;

	     arg_list.twice_n_arguments, arg_list.twice_n_descriptors = 2 * n_arguments;

/* save the name on the current argument list NOTE this is  a new structure */

	     arg_list.has_command_name = "1"b;
	     arg_list.name.command_name_length = command_name_lth;
	     arg_list.name.command_name_ptr = command_name_ptr;


	     if n_arguments < hbound (arg_list.arg_ptrs, 1) then do;
						/* need to move descriptor pointers down */
		addr (arg_list.arg_ptrs (n_arguments + 1)) -> descriptor_ptrs_for_move =
		     addr (arg_list.descriptor_ptrs) -> descriptor_ptrs_for_move;
		addr (arg_list_overlay (2 * n_arguments + 1)) -> command_name_for_move =
		     addr (arg_list.name) -> command_name_for_move;
	     end;


	     if multics_cp then do;			/* executing a Multics command line */
		if lss_on then do;			/* running within Limited Service System */
		     call transform_command_ (command_name_ptr, command_name_lth, cp_data_$command_table_ptr, code);
		     if code ^= 0 then go to SILENTLY_RETURN_FROM_CP;
		end;
		call find_command_ (command_name_ptr, command_name_lth, command_entry_ptr, code);
		if code ^= 0 then go to SILENTLY_RETURN_FROM_CP;
		executing = "1"b;			/* handle command_abort_ now */
		call cu_$gen_call (command_entry_ptr, addr (arg_list));
	     end;

	     else if new_subsystem_call		/* new type of subsystem request line */
	     then do;
		executing = "1"b;			/* handler request_abort_ now */
		call execute_request (P_subsystem_info_ptr, command_name, addr (arg_list), code);
		if code ^= 0 then go to SILENTLY_RETURN_FROM_CP;
	     end;

	     else do;				/* executing an old-fashioned subsystem request line */
		executing = "1"b;			/* handler request_abort_ now */
		call old_execute_request (command_name, addr (arg_list), code);
		if code ^= 0 then go to SILENTLY_RETURN_FROM_CP;
	     end;

ABORT_COMMAND_EXECUTION:
	     executing = "0"b;
	end;

	return;

     end simple_command_processor;
%page;
/* Complex command processor: processes command lines which contain quoted strings, iteration, or active strings.  In
   order to solve several bugs in the command processor, this procedure will have to be rewritten */

complex_command_processor:
     procedure (p_line_ptr, p_line_len, p_start) options (non_quick);


/* Parameters */

dcl  p_line_ptr pointer parameter;			/* -> the command line/active string */
dcl  p_line_len fixed binary (21) parameter;		/* length of the line */
dcl  p_start fixed binary (21) parameter;		/* where in the line to start procesing */


/* Local copies of paramerters */

dcl  (line_len, start) fixed binary (21);
dcl  line_ptr pointer;


/* Nodes */

dcl  1 atom aligned based,
       2 next pointer unaligned,			/* forward thread */
       2 pad1 pointer unaligned,
       2 string_ptr pointer unaligned,			/* pointer into command line */
       2 type fixed binary,
       2 pad2 fixed binary,
       2 string_len fixed binary (21),			/* length of substring */
       2 flags aligned,
         3 space bit (1);                                   /* followed by white space */

dcl  1 iter_begin aligned based,
       2 next pointer unaligned,			/* forward thread */
       2 end pointer unaligned,			/* forward thread to matching ) */
       2 parent pointer unaligned,			/* pointer to parent iter or af node */
       2 type fixed binary,
       2 delimiter_class fixed binary,			/* which of 8 possible end iteration set breaks to match */
       2 pad fixed binary (21),
       2 flags aligned,
         3 space bit (1);				/* this value is ignored */

dcl  1 iter_end aligned based,
       2 next pointer unaligned,			/* forward thread */
       2 begin pointer unaligned,			/* backward thread to matching ( */
       2 parent pointer unaligned,			/* pointer to parent iter or af node */
       2 type fixed binary,
       2 pad fixed binary,
       2 level fixed binary (21),			/* number of iter sets not ended */
       2 flags aligned,
         3 space bit (1);				/* if iteration set is followed by white space */

dcl  1 af aligned based,
       2 next pointer unaligned,			/* forward thread */
       2 prev pointer unaligned,			/* backward thread */
       2 parent pointer unaligned,			/* pointer to parent iter or af node */
       2 type fixed binary,
       2 delimiter_class fixed binary,			/* which of 8 possible end active string breaks to match */
       2 level fixed binary (21),			/* iter level at start of af */
       2 flags aligned,
         3 space bit (1),				/* this value is ignored */
         3 atom_sw bit (1),				/* result is to be a single atom */
         3 tokens_sw bit (1),				/* result is to be broken into tokens only */
         3 catenate_sw bit (1);			/* catenate results of iterations */

dcl  1 node aligned based,
       2 next pointer unaligned,			/* forward thread */
       2 af_prev pointer unaligned,			/* backward thread */
       2 af_iter_parent pointer unaligned,		/* pointer to parent iter or af node */
       2 type fixed binary,
       2 delimiter_class fixed binary,			/* which of 8 possible end iteration/active string breaks */
       2 len_or_level fixed binary (21),		/* length of character string for atom nodes, or
						   iter level at start of af or after iter_end */
       2 flags aligned,
         3 space bit (1),				/* followed by white space */
         3 af_atom_sw bit (1),			/* result is a single atom */
         3 af_tokens_sw bit (1),			/* result is to be broken into tokens only */
         3 af_catenate_sw bit (1);			/* catenate results of iterations */

/* format: off */
dcl (ATOM			initial (1),		/* a piece of text which will form part of an argument */
     BEGIN_ITERATION	initial (2),		/* start of an iteration set */
     END_ITERATION		initial (3),		/* end of one or more iteration sets */
     ACTIVE_STRING		initial (4),		/* an active string */
     END_OF_COMMAND		initial (5))		/* a command delimter returned by an active function */
	fixed binary static options (constant);
/* format: on */


/* Data used for scratch segment management:  The command processor maintains two lists of scratch segments -- the
   "permanent" scratch segments are obtained only once per-process and are shared amongst various invocations of the
   command processor through the use of a simple locking scheme.  (In actuality, the permanent segments will be released
   every cp_data_$scratch_release_factor uses to help keep process directory usage low).  The other list of scratch
   segments is a per-invocation list of temporary segments which are allocated and then released once per top-level
   command/request (ie: once per semicolon) */

dcl  scratch_lock_id bit (36) aligned;			/* unique identifier for acquiring "permanent" segments */

dcl  1 temporary_scratch_segment_list aligned based (temporary_scratch_segment_list_ptr),
       2 header,
         3 n_allocated fixed binary,			/* # of available temporary scratch segments */
         3 n_used fixed binary,			/* # actually in use at present */
       2 segment_ptrs (temporary_scratch_segment_list_n_allocated refer (temporary_scratch_segment_list.n_allocated))
	  pointer;

dcl  1 local_temporary_scratch_segment_list aligned,	/* initial set of temporary scratch segments */
       2 header like temporary_scratch_segment_list.header,
       2 segment_ptrs (8) pointer;

dcl  temporary_scratch_segment_list_ptr pointer;
dcl  temporary_scratch_segment_list_n_allocated fixed binary;


/* Remaining declarations */

dcl  1 dummy_node aligned like node;
dcl  1 dummy_af_node aligned like af;			/* top level active string for evaluate entries */

dcl  1 node_block aligned based (block_ptr),		/* block of thirty nodes */
       2 array (30) like node,			/* four words each */
       2 next pointer;				/* forward thread */
dcl  block_ptr pointer;
dcl  last_block_ptr pointer;				/* for chaining blocks */

dcl  node_index fixed binary (5);			/* index of free node in a block */

dcl  1 stack_space like node_block aligned;		/* space in stack for first block of nodes */

dcl  system_area area based (system_area_ptr);		/* area to allocate later blocks if needed */
dcl  system_area_ptr pointer;

dcl  atom_string character (atom_len) based (atom_ptr);
dcl  atom_len fixed binary (21);
dcl  atom_ptr pointer;

dcl  return_string character (return_len) aligned varying based (return_ptr);
dcl  return_ptr pointer;				/* -> AF return string */
dcl  return_len fixed binary (21);

dcl  1 full_language like cp_data_$standard_language aligned based (full_language_ptr);
dcl  full_language_ptr pointer;			/* defines the full language being interpreted */

dcl  1 token_language like cp_data_$standard_language aligned based (token_language_ptr);
dcl  token_language_ptr pointer;			/* defines the language with non-whitespace, non-quoting
						   special characters treated normally */

dcl  using_stack bit (1) aligned;			/* ON => arguments are being constructed on the stack */

dcl  last_np pointer;
dcl  (first_node, new_first_node) pointer;		/* node pointers for match_iters & read_list */
dcl  arg_count fixed binary;				/* number of arguments to command/af, set by match_iters */
dcl  (count, iter_count, iter_index) fixed binary;	/* number of iterations, set by match_iters */

/* format: off */
dcl (command		 initial ("0"b),		/* executing a command */
     active_function	 initial ("1"b))		/* evaluating an active function */
	bit (1) aligned static options (constant);
/* format: on */

dcl  make_list_depth fixed binary;			/* recursion depth of make_list procedure */
dcl  iter_level fixed binary;				/* depth of ()'s in line */
						/* for use by the pipe facility only */
dcl  command_pipe_control_ptr ptr;
dcl  1 command_pipe_control aligned based (command_pipe_control_ptr),
       2 Npipes_in_line fixed bin,			/* occurances of ;| in a line */
       2 Niters fixed bin,				/* iteration level		*/
       2 niters fixed bin,				/* iteration count		*/
       2 Sevaluate_pipe bit (1) aligned,		/* on = processing an active function */
       2 Sbuild_return_string bit (1) aligned,		/* on = build the af return str */
       2 Sinclude_NL_in_af_ret_str bit (1) aligned,	/* on = do not remove NLs from the ret str */
       2 Sterminate bit (1) aligned,			/* on = delete pipe files and free storage */
       2 pipe_input_path char (58),			/* built by pipe_$initiate */
       2 pipe_output_path char (58),			/* built by pipe_$initiate */
       2 previous_pipe_ptr ptr,			/* data before the ;| */
       2 previous_pipe_len fixed bin,
       2 current_pipe_ptr ptr,			/* current command line */
       2 current_pipe_len fixed bin,
       2 next_pipe_ptr ptr,				/* data after the next ;| */
       2 next_pipe_len fixed bin,
       2 input_ptr ptr,				/* input attachment */
       2 output_ptr ptr;				/* output attachment */
%page;
	command_pipe_control_ptr = null;
	line_ptr = p_line_ptr;
	line_len = p_line_len;
	start = p_start;

	system_area_ptr = get_system_free_area_ ();

	block_ptr = addr (stack_space);		/* initialize node allocation variables */
	unspec (node_block) = "0"b;
	node_block.next = null ();
	node_index = 0;

	call initialize_scratch_segments ("1"b);	/* setup scratch segment management */

	on condition (cleanup)
	     begin;				/* non-local goto in progress ... */
	     if command_pipe_control_ptr ^= null then do;
		call pipe_$terminate (addr (command_pipe_control.pipe_input_path),
		     addr (command_pipe_control.pipe_output_path), ignore_code);

		free command_pipe_control in (system_area);
		command_pipe_control_ptr = null;
	     end;

	     call free_nodes ("1"b);			/* ... don't zero automatic storage */
	     call release_scratch_segments ("1"b);	/* ... or setup scratch segments for another pass */
	end;

	if use_standard_language then			/* pick up character type from constant definition */
	     full_language_ptr, token_language_ptr = addr (cp_data_$standard_language);
	else do;					/* strange language: caller has supplied the definitions */
	     full_language_ptr = addr (cp_subsys_info.full_tct_table);
	     token_language_ptr = addr (cp_subsys_info.tokens_only_tct_table);
	end;
%page;
/* Process the line one command at a time -- a command invocation is delimited by non-quoted semicolons and newlines.
   Evaluating an active string in the command line may return semicolons -- this case is handled by make_list and
   match_iters */

	do while (start > 0);

	     iter_level = 0;			/* no unclosed iteration sets */
	     iter_count = 0;
	     iter_index = 0;
	     make_list_depth = 0;

	     return_ptr = null ();			/* no place for return values yet */
	     using_stack = "1"b;			/* read_list will use additional stack space if necessary */

	     unspec (dummy_node) = "0"b;
	     last_np = addr (dummy_node);
	     dummy_node.next = null ();
	     dummy_node.type = ATOM;

	     if evaluate_string then do;		/* evaluating active string: make dummy AF node */
		unspec (dummy_af_node) = "0"b;
		last_np = addr (dummy_af_node);
		dummy_af_node.type = ACTIVE_STRING;
		dummy_af_node.prev = addr (dummy_node); /* make sure result is seen */
		dummy_af_node.parent = null ();
		if (top_level_string_type = TOKENS_ONLY_ACTIVE_STRING) then dummy_af_node.tokens_sw = "1"b;
						/* caller requested |[] */
		else if (top_level_string_type = ATOMIC_ACTIVE_STRING) then dummy_af_node.atom_sw = "1"b;
						/* caller requested ||[] */
	     end;

	     call make_list (line_ptr, line_len, ("0"b), start, command_pipe_control_ptr);
						/* parse line up to first explicit semicolon */

	     do first_node = dummy_node.next		/* process this command */
		repeat (new_first_node)		/* and any within it from AF's */
		while (first_node ^= null ());
		call match_iters (first_node, evaluate_string, arg_count, iter_count, new_first_node);
		do iter_index = 1 to iter_count;	/* process parentheses */
		     if command_pipe_control_ptr ^= null then do;
			command_pipe_control.Niters = iter_count;
			command_pipe_control.niters = iter_index;
		     end;

		     if ^evaluate_string then
			call read_list (first_node, evaluate_string, arg_count, command_pipe_control_ptr);
		     else do;			/* cp_$af: get list as a string */
			call write_list (first_node, evaluate_string, arg_count, command_pipe_control_ptr);
			if (iter_index < iter_count) | (new_first_node ^= null ()) then
			     P_return_value = P_return_value || ";";
		     end;				/* if not last element of list */
		end;
	     end;

	     call free_nodes ((start = 0));		/* forget command but zero automatic only if more to do */
	     call release_scratch_segments ((start = 0));

	     if command_pipe_control_ptr ^= null then
		if command_pipe_control.Sterminate then do;
		     call pipe_$terminate (addr (command_pipe_control.pipe_input_path),
			addr (command_pipe_control.pipe_output_path), ignore_code);

		     free command_pipe_control in (system_area);
		     command_pipe_control_ptr = null;
		end;

	end;

	return;
%page;
/* Construct the token list:  Evaluates active strings and properly threads parentheses for use by match_iters and
   read_list */

make_list:
	procedure (p_line_ptr, p_line_len, p_token_breaks_sw, p_start, p_pipe_control_ptr);

dcl  p_line_ptr pointer parameter;
dcl  (p_line_len, p_start) fixed binary (21) parameter;
dcl  p_token_breaks_sw bit (1) aligned parameter;		/* controls if ()[}; recognized */
dcl  p_pipe_control_ptr ptr;

dcl  line_ptr pointer;				/* parameter copies */
dcl  (line_len, start, pipe_line_pos) fixed binary (21);
dcl  token_breaks_sw bit (1) aligned;

dcl  line character (line_len) based (line_ptr);
dcl  c (line_len) character (1) unaligned based (line_ptr);

dcl  af_is_atom bit (1) aligned;			/* ON => return value is not to be rescanned */
dcl  af_is_tokens bit (1) aligned;			/* ON => return value should be tokenized only */
dcl  catenate_values bit (1) aligned;			/* ON => iteration in active string catenates */
dcl  semicolon_in_af bit (1) aligned;			/* ON => command separator within an active string */

dcl  (pp, np, top_level_pp) pointer;
dcl  processing_type fixed binary (9);

dcl  (afp, first_node, new_first_node, af_line_ptr) pointer;
dcl  (the_character, next_character, next_next_character) character (1);
dcl  continue_scan bit (1) aligned;
dcl  (arg_count, iter_count, iter_index) fixed binary;
dcl  (af_line_len, af_start, idx) fixed binary (21);

dcl  sv_pipe_control_ptr ptr;
dcl  1 pipe_control aligned like command_pipe_control based (p_pipe_control_ptr);
dcl  current_pipe aligned char (pipe_control.current_pipe_len) based (pipe_control.current_pipe_ptr);
dcl  next_pipe aligned char (pipe_control.next_pipe_len) based (pipe_control.next_pipe_ptr);
dcl  after_bracket_idx fixed bin (21);

	     make_list_depth = make_list_depth + 1;
	     line_ptr = p_line_ptr;
	     line_len = p_line_len;
	     token_breaks_sw = p_token_breaks_sw;
	     start = p_start;
	     sv_pipe_control_ptr = null;

	     if (make_list_depth = 1) & evaluate_string then do;
		top_level_pp, pp = addr (dummy_af_node);/* need a psuedo "[" for string evaluation */
		semicolon_in_af = "0"b;		/* ... and be sure not to confuse it */
		afp = null ();
	     end;
	     else pp = null ();
%page;
/* Main scanning loop */

/* pipe line position offset equals the starting char less 1. */

	     pipe_line_pos = start - 1;

	     do while (start <= line_len);

		if token_breaks_sw then		/* ignore iteration, active strings, and multiple commands */
		     if use_standard_language then
			atom_len = search (substr (line, start), TOKEN_BREAKS) - 1;
		     else atom_len =
			     find_char_$first_in_table (substr (line, start), cp_subsys_info.tokens_only_tct_table)
			     - 1;
		else do;				/* allow all features defined in this language */
		     if use_standard_language then	/* ... default situation: all features are enabled */
			atom_len = search (substr (line, start), BREAKS) - 1;
		     else atom_len =
			     find_char_$first_in_table (substr (line, start), cp_subsys_info.full_tct_table) - 1;
		end;

		if atom_len = -1 then do;		/* rest of line is ordinary characters ... */
		     atom_len = line_len - start + 1;
		     call get_node ();		/* ... so create an ATOM node to represent it */
		     np -> atom.type = ATOM;
		     np -> atom.string_ptr = addr (c (start));
		     np -> atom.string_len = atom_len;
		     start = line_len + 1;		/* ... and force the scanning loop to terminate */
		end;

		else do;				/* have found a character with special meaning ... */
		     if atom_len > 0 then do;		/* ... some ordinary characters in front of it ... */
			call get_node ();		/* ... ... so create a node to hold onto them */
			np -> atom.type = ATOM;
			np -> atom.string_ptr = addr (c (start));
			np -> atom.string_len = atom_len;
			start = start + atom_len;	/* ... and position to the interesting character */
		     end;

		     af_is_atom = "0"b;		/* turn off any active string modifiers */
		     af_is_tokens = "0"b;
		     catenate_values = "0"b;
		     processing_type = get_type (c (start));
		     go to PROCESS_CHARACTER (processing_type);


/* Determine the processing type of the given character */

get_type:
     procedure (p_character) returns (fixed binary);

dcl  p_character character (1) unaligned parameter;

	if token_breaks_sw then
	     return (token_language.character_types (rank (p_character)));
	else return (full_language.character_types (rank (p_character)));

     end get_type;
%page;
/* Whitespace: separates tokens on the line but is otherwise ignored (space, horizontal/vertical tab, form feed, newline
   when scanning just for tokens */

PROCESS_WHITESPACE:
PROCESS_CHARACTER (1):
		     last_np -> node.space = "1"b;	/* separate this token from what (if anything) follows */
		     go to CONTINUE_SCAN;


/* Command separator: separates multiple commands on the line but is        */
/* otherwise ignored (semicolon) */

PROCESS_COMMAND_SEPARATOR:
PROCESS_CHARACTER (2):

/* The pipe facility is activated when the string ";|" exists within a command
   line.  Pipes are not available in limited service subsystems or subsystems
   that do not use the standard command language. */
	
                         if ^use_standard_language | lss_on then go to PROCESS_SEMICOLON;
		     if substr (line, start, length (PIPE_BREAK)) = PIPE_BREAK then do;
			if p_pipe_control_ptr = null then do;
						/* init values here to save on performance. */
			     allocate pipe_control in (system_area) set (p_pipe_control_ptr);
			     pipe_control.Npipes_in_line = 0;
			     pipe_control.Sterminate = "0"b;
			     pipe_control.Sevaluate_pipe = "0"b;
			     pipe_control.Sbuild_return_string = "0"b;
			     pipe_control.Sinclude_NL_in_af_ret_str = "0"b;
			     pipe_control.pipe_input_path = "";
			     pipe_control.pipe_output_path = "";
			     pipe_control.previous_pipe_ptr = null;
			     pipe_control.previous_pipe_len = 0;
			     pipe_control.current_pipe_ptr = null;
			     pipe_control.current_pipe_len = 0;
			     pipe_control.next_pipe_ptr = null;
			     pipe_control.next_pipe_len = 0;
			     pipe_control.input_ptr = null;
			     pipe_control.output_ptr = null;
			end;

			pipe_control.Npipes_in_line = pipe_control.Npipes_in_line + 1;

/* Construct pointers to the previous and current section of the command line
   delimited by pipe tokens and line extents. */

			pipe_control.previous_pipe_ptr = pipe_control.current_pipe_ptr;
			pipe_control.previous_pipe_len = pipe_control.current_pipe_len;
			pipe_control.current_pipe_ptr = addcharno (line_ptr, pipe_line_pos);
			pipe_control.current_pipe_len = start - pipe_line_pos - length (";");
			start = start + length (PIPE_BREAK);

			if pp ^= null () then
			     if pp -> node.type = ACTIVE_STRING then do;

/* Position the section pointer after the left bracket so that the pipe
   processor can figure out the type of thing being done.                   */

				after_bracket_idx = search (current_pipe, LEFT_BRACKET);
				pipe_control.current_pipe_ptr =
				     addcharno (pipe_control.current_pipe_ptr, after_bracket_idx);
				pipe_control.current_pipe_len = pipe_control.current_pipe_len - after_bracket_idx;

/* Look for the next character. It will be a vertical bar or a right        */
/* bracket.  If it isn't, an error will be reported when the end of the     */
/* active function is processed in PROCESS_END_ACTIVE_FUNCTION below.	      */

				pipe_control.Sevaluate_pipe = "1"b;
				if substr (line, start, length (VERTICAL_BAR)) = VERTICAL_BAR then do;
				     pipe_control.Sinclude_NL_in_af_ret_str = "1"b;
				     start = start + length (VERTICAL_BAR);
				end;
			     end;


/* Construct pointers to the next section of the command line delimited by
   pipe tokens and line extents.  The value of next_pipe may or may not be
   the entire contents of the next command or attach description
   processed.  The value will be the entire contents when there are no
   special characters within it.  It is not required for the string to be
   complete. Using this strategy, the value will contain the first special
   character.  The value is checked a by subroutine of process_pipe below.
   Whenever a the string contains special characters, a temporary pipe
   file will be used for output.  When the string does not contain special
   characters and is a valid attach description, then and only then, it is
   used as the output of the pipe. */

			pipe_control.next_pipe_len = search (substr (line, start), COMMAND_BREAKS);

			if pipe_control.next_pipe_len > 0 then do;
			     pipe_control.next_pipe_ptr = addcharno (line_ptr, start - 1);
			     pipe_control.next_pipe_len = pipe_control.next_pipe_len - 1;
			end;
			else do;
			     pipe_control.next_pipe_ptr = addcharno (line_ptr, start - 1);
			     if line_len >= start then
				pipe_control.next_pipe_len = line_len - (start - 1);
			     else pipe_control.next_pipe_len = 0;
			end;

/* If the pipe is to run as an active function, determine if this is the
   last section of the active string. If so, setup for the active function
   return string to be built.  If there is an include new line token in the
   middle of the pipe, report an error.  Otherwise, call the active function
   processor. */

			if pipe_control.Sevaluate_pipe then do;
			     if substr (ltrim (next_pipe), 1, length (RIGHT_BRACKET)) = RIGHT_BRACKET then
				pipe_control.Sbuild_return_string = "1"b;
			     else do;
				if pipe_control.Sinclude_NL_in_af_ret_str then do;
				     code = error_table_$bad_pipe_syntax;
				     error_message =
					"The string "";||"" may only appear at the end of pipe active strings.";
				     go to RETURN_FROM_CP;
				end;
			     end;

			     start = start - 1;	/* make_list adds 1 */
			     pipe_line_pos = start;
			     semicolon_in_af = "1"b;
			     call process_active_function (p_pipe_control_ptr);
			end;
		     end;

/* A regular semicolon was found.  If the pipe facility is "on", turn it off */

		     else do;
			if p_pipe_control_ptr ^= null then do;
			     pipe_control.Sterminate = "1"b;
			     pipe_control.previous_pipe_ptr = pipe_control.current_pipe_ptr;
			     pipe_control.previous_pipe_len = pipe_control.current_pipe_len;
			     pipe_control.current_pipe_ptr = addcharno (line_ptr, pipe_line_pos);
			     pipe_control.current_pipe_len = start - pipe_line_pos - 1;
			     pipe_control.next_pipe_ptr = null;
			     pipe_control.next_pipe_len = 0;
			end;
PROCESS_SEMICOLON:
			start = start + 1;		/* next command follows the ; */
			if (start > 0) & (pp ^= null ()) then
			     if pp -> node.type = ACTIVE_STRING then do;

/* Because the return string from a pipe is built at the end of the bracket
   pair, it is not possible to process active functions after pipe active
   functions.  If this were done, the return string would not be builr in the
   same sequence as the command line issued them.  If this is done, report
   an error message. */

				if p_pipe_control_ptr ^= null then
				     if pipe_control.Sevaluate_pipe then do;
					code = error_table_$bad_pipe_syntax;
					error_message =
					     "Nonpipe semicolons cannot appear after pipe breaks in pipe active strings."
					     ;
					go to RETURN_FROM_CP;
				     end;

				start = start - 1;	/* ... make_list will add 1 */
				pipe_line_pos = start;
				semicolon_in_af = "1"b;
				call process_active_function (p_pipe_control_ptr);
			     end;			/* ... above procedure doesn't return (sigh) */
		     end;

		     go to RETURN_FROM_MAKE_LIST;


/* Command separator or whitespace: separates multiple commands on the line when using the full language but is also
   recognized when scanning active function return values for tokens as being equivalent to whitespace (new-line) */

PROCESS_CHARACTER (3):
		     if token_breaks_sw then
			go to PROCESS_WHITESPACE;	/* nice and easy ... */
		     else go to PROCESS_COMMAND_SEPARATOR;
%page;
/* Single character token: appears as a one character argument to the command even if not surrounded by whitespace */

PROCESS_CHARACTER (4):
		     last_np -> node.space = "1"b;	/* forced separation */

		     call get_node ();		/* create an atom node for this character */
		     np -> atom.type = ATOM;
		     np -> atom.string_ptr = addr (c (start));
		     np -> atom.string_len = 1;
		     np -> atom.space = "1"b;		/* ... and separate it from whatever follows */
		     go to CONTINUE_SCAN;


/* Compound token: appears as an argument to the command even if not surrounded by whitespace; if several of this type of
   character appear on the line without any intervening characters, they are merged into a single argument (eg: ^=) */

PROCESS_CHARACTER (5):
		     last_np -> node.space = "1"b;	/* forced separation */

		     call get_node ();		/* create an atom for this and following compounded chars */
		     np -> atom.type = ATOM;
		     np -> atom.string_ptr = addr (c (start));
		     np -> atom.string_len = 0;
		     np -> atom.space = "1"b;		/* ... and separate them from whatever follows */

		     do while (start <= line_len);	/* scan until we hit end of compound token characters */
			processing_type = get_type (c (start));
			if processing_type = COMPOUND_TOKEN then
			     np -> atom.string_len = np -> atom.string_len + 1;
			else do;			/* found a non-compound character */
			     start = start - 1;	/* ... CONTINUE_SCAN label bumps this value */
			     go to CONTINUE_SCAN;
			end;
			start = start + 1;		/* move right along */
		     end;

		     go to RETURN_FROM_MAKE_LIST;	/* here iff rest of line was compound tokens */
%page;
/* Quote character -- begins and ends a quoted string: only the same character ends the quoted string (ie: "' isn't a
   completed string if both are quoting characters); within the string, any occurence of this character must be doubled */

PROCESS_CHARACTER (6):
		     the_character = c (start);	/* this is the only character that will stop us */

		     continue_scan = "1"b;		/* until we find the closing quote character */
		     do while (continue_scan);
			idx = index (substr (line, (start + 1)), the_character);
			if idx = 0 then do;		/* unbalanced quoting characters ... */
			     code = error_table_$unbalanced_quotes;
			     go to RETURN_FROM_CP;
			end;
			call get_node ();		/* make an atom for next piece of quoted string */
			np -> atom.type = ATOM;
			np -> atom.string_ptr = addr (c (start + 1));
			np -> atom.string_len = idx - 1;
			start = start + idx;	/* skip to next quoting character */
			if start < line_len then	/* check for literal quoted character within the string */
			     if substr (line, (start + 1), 1) = the_character then do;
				np -> atom.string_len = np -> atom.string_len + 1;
				start = start + 1;	/* ... yes: add one to the string and keep scanning */
			     end;
			     else continue_scan = "0"b;
			else continue_scan = "0"b;	/* ... no: have completed the string */
		     end;

		     go to CONTINUE_SCAN;		/* here iff we have a completed quoted string */


/* Active string modifier: modifies the interpretation of active strings; otherwise, treat as normal character (|) */

PROCESS_CHARACTER (7):
		     the_character = c (start);	/* pick up the modifier */

		     if start < line_len then		/* and the following character (if present) */
			next_character = substr (line, (start + 1), 1);
		     else next_character = low (1);

		     if start < (line_len - 1) then	/* and the character after that ... */
			next_next_character = substr (line, (start + 2), 1);
		     else next_next_character = low (1);

		     if (start < (line_len - 1)) & (next_character = the_character)
			& (get_type (next_next_character) >= BEGIN_ACTIVE_STRING_1)
			& (get_type (next_next_character) <= BEGIN_ACTIVE_STRING_8) then do;
			af_is_atom = "1"b;		/* ||[ -- do not scan active string result */
			start = start + 2;
			processing_type = get_type (next_next_character);
			go to PROCESS_BEGIN_ACTIVE_STRING;
		     end;

		     else if (start < line_len) & (get_type (next_character) >= BEGIN_ACTIVE_STRING_1)
			& (get_type (next_character) <= BEGIN_ACTIVE_STRING_8) then do;
			af_is_tokens = "1"b;	/* |[ -- rescan only for whitespace and quoted strings */
			start = start + 1;
			processing_type = get_type (next_character);
			go to PROCESS_BEGIN_ACTIVE_STRING;
		     end;

		     else if (start < line_len) & (get_type (next_character) >= END_ACTIVE_STRING_1)
			& (get_type (next_character) <= END_ACTIVE_STRING_8) then do;
			catenate_values = "1"b;	/* |] -- catenate iterated results */
			start = start + 1;
			processing_type = get_type (next_character);
			go to PROCESS_END_ACTIVE_STRING;
		     end;

		     else do;			/* nothing special about this occurence ... */
			call get_node ();		/* ... create a node to hold onto the character */
			np -> atom.type = ATOM;
			np -> atom.string_ptr = addr (c (start));
			np -> atom.string_len = 1;
			go to CONTINUE_SCAN;
		     end;
%page;
/* Begin an iteration set: there may be up to eight different groups of iteration set delimiters (left parenthesis) */

/* format: off */
PROCESS_CHARACTER (17):  PROCESS_CHARACTER (18):  PROCESS_CHARACTER (19):  PROCESS_CHARACTER (20):
PROCESS_CHARACTER (21):  PROCESS_CHARACTER (22):  PROCESS_CHARACTER (23):  PROCESS_CHARACTER (24): ;
						/* format: on */
		     call get_node ();		/* add an iteration node */
		     np -> iter_begin.type = BEGIN_ITERATION;
		     np -> iter_begin.parent = pp;
		     np -> iter_begin.delimiter_class = processing_type;

		     pp = np;			/* push parent */
		     iter_level = iter_level + 1;

		     go to CONTINUE_SCAN;


/* End an iteration set (right parenthesis) */

/* format: off */
PROCESS_CHARACTER (25):  PROCESS_CHARACTER (26):  PROCESS_CHARACTER (27):  PROCESS_CHARACTER (28):
PROCESS_CHARACTER (29):  PROCESS_CHARACTER (30):  PROCESS_CHARACTER (31):  PROCESS_CHARACTER (32): ;
						/* format: on */
		     if pp = null () then do;		/* no matching begin iteration set delimiter */
			code = error_table_$unbalanced_parentheses;
			go to RETURN_FROM_CP;
		     end;

		     else if pp -> node.type ^= BEGIN_ITERATION then do;
			code = error_table_$unbalanced_brackets;
			go to RETURN_FROM_CP;	/*  [) situation */
		     end;

		     else if pp -> iter_begin.delimiter_class ^= (processing_type - 8) then do;
			code = error_table_$unbalanced_parentheses;
			go to RETURN_FROM_CP;	/* previous begin iteration is of the wrong class */
		     end;

		     if last_np -> node.type = END_ITERATION then
			last_np -> node.space = "0"b; /* multiple end iterations: ignore intervening whitespace */

		     else do;			/* first end iteration so far */
			if last_np -> node.type = ATOM then last_np -> node.space = "1"b;
			call get_node ();		/* ... create an end iteration node */
			np -> node.type = END_ITERATION;
			np -> iter_end.begin = pp;
		     end;

		     iter_level = iter_level - 1;	/* one less unclosed iteration set */
		     last_np -> iter_end.level = iter_level;
		     last_np -> iter_end.parent = pp;
		     pp -> iter_begin.end = last_np;	/* let begin iteration node know where we are */
		     pp = pp -> iter_begin.parent;	/* pop parent */

		     go to CONTINUE_SCAN;
%page;
/* Begin an active string: there may be up to eight different groups of active string delimiters (left bracket) */

/* format: off */
PROCESS_BEGIN_ACTIVE_STRING:
PROCESS_CHARACTER (33):  PROCESS_CHARACTER (34):  PROCESS_CHARACTER (35):  PROCESS_CHARACTER (36):
PROCESS_CHARACTER (37):  PROCESS_CHARACTER (38):  PROCESS_CHARACTER (39):  PROCESS_CHARACTER (40): ;
						/* format: on */
		     call get_node ();		/* add an active string node */
		     np -> af.type = ACTIVE_STRING;
		     np -> af.parent = pp;
		     np -> af.delimiter_class = processing_type;

		     np -> af.atom_sw = af_is_atom;	/* record options known so far */
		     np -> af.tokens_sw = af_is_tokens;
		     np -> af.catenate_sw = "0"b;

		     if evaluate_string & (afp = top_level_pp) then top_level_pp = np;
						/* new top level of evaluate_active_string */
		     pp = np;			/* push parent */

		     np -> af.level = iter_level;	/* save iteration level */
		     iter_level = 0;		/* iteration sets in an active string are independent */

/* This case label is entered when a left bracket is found and after a
   semicolon or pipe token pair is found within an active string.  The value
   must be checked.  If this is a new active function and if there is a pipe
   active for the current level, the processing of the string as a pipe must
   be suspended.  Once done, this new active string can be evaluated on its
   own.  Processing of the new active function is ended and the previous
   pipe is restored when the right bracket is found. */

		     if p_pipe_control_ptr ^= null then
			if substr (line, start, length (LEFT_BRACKET)) = LEFT_BRACKET then do;
			     sv_pipe_control_ptr = p_pipe_control_ptr;

			     on condition (cleanup)
				begin;

			          if p_pipe_control_ptr ^= null then do;
				     call pipe_$terminate (addr (pipe_control.pipe_input_path),
					addr (pipe_control.pipe_output_path), ignore_code);
				     free pipe_control in (system_area);
				end;

/* Put back the command level pipe info if there is any */
				p_pipe_control_ptr = sv_pipe_control_ptr;
				sv_pipe_control_ptr = null;
			     end;
			     p_pipe_control_ptr = null;
			end;

		     go to CONTINUE_SCAN;


/* End an active string (right bracket) */

/* format: off */
PROCESS_END_ACTIVE_STRING:
PROCESS_CHARACTER (41):  PROCESS_CHARACTER (42):  PROCESS_CHARACTER (43):  PROCESS_CHARACTER (44):
PROCESS_CHARACTER (45):  PROCESS_CHARACTER (46):  PROCESS_CHARACTER (47):  PROCESS_CHARACTER (48): ;
						/* format: on */
		     if pp = null () then do;		/* no begin active string */
			code = error_table_$unbalanced_brackets;
			go to RETURN_FROM_CP;
		     end;

		     else if (make_list_depth = 1) & evaluate_string & (pp = top_level_pp) then do;
			code = error_table_$unbalanced_brackets;
			go to RETURN_FROM_CP;	/* evaluate_active_string: caller should've stripped this */
		     end;

		     else if pp -> node.type ^= ACTIVE_STRING then do;
			code = error_table_$unbalanced_parentheses;
			go to RETURN_FROM_CP;	/* (] situation */
		     end;

		     else if pp -> af.delimiter_class ^= (processing_type - 8) then do;
			code = error_table_$unbalanced_brackets;
			go to RETURN_FROM_CP;	/* previous begin active string is of the wrong class */
		     end;

		     if p_pipe_control_ptr ^= null then do;

/* If the pipe facility is in use as an active function, check for proper
   termination of the string. Then, terminate the pipe facility for this
   active string. */

			if return_ptr = null | ^pipe_control.Sbuild_return_string then do;
			     if current_pipe = "" then do;
				code = error_table_$null_brackets;
				go to RETURN_FROM_CP;
			     end;
			     else do;
				code = error_table_$bad_pipe_syntax;
				error_message = "Pipe active strings must end with "";|]"" or "";||]""";
				go to RETURN_FROM_CP;
			     end;
			end;

			call pipe_$terminate (addr (pipe_control.pipe_input_path),
			     addr (pipe_control.pipe_output_path), ignore_code);
			free pipe_control in (system_area);
			p_pipe_control_ptr = sv_pipe_control_ptr;
			sv_pipe_control_ptr = null;
			if p_pipe_control_ptr ^= null then revert cleanup;
		     end;

		     else if return_ptr = null then
			if pp -> af.next = null () then do;
			     code = error_table_$null_brackets;
			     go to RETURN_FROM_CP;
			end;

		     if p_pipe_control_ptr = null then do;
		        p_pipe_control_ptr = sv_pipe_control_ptr;
		        sv_pipe_control_ptr = null;
		        end;

		     semicolon_in_af = "0"b;

		     call process_active_function (p_pipe_control_ptr);

/* doesn't return */
%page;
CONTINUE_SCAN:					/* finished processing of special character ... */
		     start = start + 1;		/* ... so move on to the rest of the line (if any) */

		end;
	     end;


/* End of line */
	     if p_pipe_control_ptr ^= null then do;
		pipe_control.Sterminate = "1"b;
		pipe_control.previous_pipe_ptr = pipe_control.current_pipe_ptr;
		pipe_control.previous_pipe_len = pipe_control.current_pipe_len;
		pipe_control.current_pipe_ptr = addcharno (line_ptr, pipe_line_pos);
		pipe_control.current_pipe_len = start - pipe_line_pos - 1;
		pipe_control.next_pipe_ptr = null;
		pipe_control.next_pipe_len = 0;
	     end;

	     start = 0;				/* remember no more commands left on this line */

RETURN_FROM_MAKE_LIST:
	     if pp ^= null () then do;		/* possibly unbalanced line */
		if (make_list_depth = 1) & evaluate_string & (pp = top_level_pp) then
		     call process_active_function (p_pipe_control_ptr);
						/* end of evaluate_active_string: do it */
		if pp -> node.type = BEGIN_ITERATION then
		     code = error_table_$unbalanced_parentheses;
		else code = error_table_$unbalanced_brackets;
		go to RETURN_FROM_CP;
	     end;

	     p_start = start;			/* set result */

	     make_list_depth = make_list_depth - 1;
	     return;
%page;
/* Evaluates part of an active string:  Processes a single active function's portion of the active string.  The active
   function may be invoked several times as parentheses may have been used in this portion of the active string */

process_active_function:
	     procedure (pipe_control_ptr);

dcl  pipe_control_ptr ptr;
dcl  1 pipe_control aligned like command_pipe_control based (pipe_control_ptr);

dcl  nonvarying_return_string character (length (return_string)) unaligned based (addrel (addr (return_string), 1));


		last_np -> node.space = "1"b;		/* finish last argument to the active function */
		afp = pp;				/* save pointer to beginning of active function sublist */
		pp = afp -> af.parent;		/* pop parent */
		last_np = afp -> af.prev;		/* unthread from list */
		last_np -> node.next = null ();

		afp -> af.catenate_sw = catenate_values;/* ON if |] */


		do first_node = afp -> node.next	/* process the active function */
		     repeat (new_first_node)		/* ... and any returned command delimiters */
		     while (first_node ^= null ());

		     call match_iters (first_node, active_function, arg_count, iter_count, new_first_node);

/* pipes as active functions do not use the last argument as the return string
   so arg_count is reduced by 1. */

		     if pipe_control_ptr ^= null then
			if pipe_control.Sevaluate_pipe then
			     if arg_count > 0 then arg_count = arg_count - 1;

		     do iter_index = 1 to iter_count;
			if pipe_control_ptr = null then
			     call read_list (first_node, active_function, arg_count, null);
			else if pipe_control.Sevaluate_pipe then do;
						/* calling a pipe. set the call up as a command */
			     pipe_control.Niters = iter_count;
			     pipe_control.niters = iter_index;
			     call read_list (first_node, command, arg_count, pipe_control_ptr);
			end;
			else			/* regular af mixed with pipe af */
			     call read_list (first_node, active_function, arg_count, null);
			if return_ptr ^= null then
			     if ((length (return_string) = 0) & ^afp -> af.atom_sw)
				| (return_string = "" & p_pipe_control_ptr ^= null) then
				;		/* ignore null return value unless ||[ */

			     else do;		/* may have to process return value */
				if ^afp -> af.atom_sw & ^afp -> af.tokens_sw then
				     if use_standard_language then
					if search (return_string, BREAKS) ^= 0 then
					     call evaluate_af_result ();
					else call treat_af_result_as_atom ();
				     else if
					find_char_$first_in_table (nonvarying_return_string,
					cp_subsys_info.full_tct_table) ^= 0 then
					call evaluate_af_result ();
				     else call treat_af_result_as_atom ();

				else if afp -> af.atom_sw then call treat_af_result_as_atom ();

				else do;		/* don't recognize iteration, active strings, etc */
				     if use_standard_language then
					if search (return_string, TOKEN_BREAKS) ^= 0 then
					     call evaluate_af_result ();
					else call treat_af_result_as_atom ();
				     else if
					find_char_$first_in_table (nonvarying_return_string,
					cp_subsys_info.tokens_only_tct_table) ^= 0 then
					call evaluate_af_result ();
				     else call treat_af_result_as_atom ();
				end;

				if (iter_index = iter_count) & (new_first_node = null ()) then
				     last_np -> node.space = "0"b;
						/* last value from active function */
				else last_np -> node.space = ^(afp -> af.catenate_sw);
						/* intermediate value: normally space */
			     end;
		     end;
		end;


		iter_level = afp -> af.level;

		if semicolon_in_af then do;		/* if active string has more sub-parts */
		     semicolon_in_af = "0"b;
		     af_is_atom = afp -> af.atom_sw;	/* "quoting" result applies to all parts */
		     af_is_tokens = afp -> af.tokens_sw;
		     if pipe_control_ptr = null then last_np -> node.space = "1"b;
		     else if ^pipe_control.Sevaluate_pipe then last_np -> node.space = "1"b;

/* always separate sub-parts */
		     processing_type = afp -> af.delimiter_class;
		     go to PROCESS_BEGIN_ACTIVE_STRING;
		end;

		if (make_list_depth = 1) & evaluate_string & (afp = top_level_pp) then go to RETURN_FROM_MAKE_LIST;
						/* end of an evaluate_string entry */
		go to CONTINUE_SCAN;

/* Internal to process_active_function: rescans and re-evaluates the active function's return string */

evaluate_af_result:
		procedure ();

dcl  pipe_control_ptr		ptr;
dcl  1 pipe_control			aligned like command_pipe_control based (pipe_control_ptr);

		     af_line_ptr = addrel (return_ptr, 1);
		     af_line_len = length (return_string);
		     call return_string_advance ();

		     af_start = 1;
		     pipe_control_ptr = null;

		     on condition (cleanup)
			begin;

			if pipe_control_ptr ^= null then do;
			     call pipe_$terminate (addr (pipe_control.pipe_input_path),
				addr (pipe_control.pipe_output_path), ignore_code);
			     free pipe_control in (system_area);
			     p_pipe_control_ptr = null;
			end;
		     end;

		     call make_list (af_line_ptr, af_line_len, afp -> af.tokens_sw, af_start, pipe_control_ptr);

		     do while (af_start > 0);		/*  see if af value had semicolon */
			call get_node ();		/*  sets af_prev of new node */
			np -> node.type = END_OF_COMMAND;
			np -> node.af_prev -> atom.space = "1"b;
						/* previous node ends list */
			call make_list (af_line_ptr, af_line_len, afp -> af.tokens_sw, af_start, pipe_control_ptr);
			if pipe_control_ptr ^= null then do;
			     call pipe_$terminate (addr (pipe_control.pipe_input_path),
				addr (pipe_control.pipe_output_path), ignore_code);
			     free pipe_control in (system_area);
			     pipe_control_ptr = null;
			end;
		     end;

		     return;

		end evaluate_af_result;



/* Internal to process_active_function: makes the active function's return string appear as a single token in the expanded
   command line */

treat_af_result_as_atom:
		procedure ();

		     call get_node ();
		     np -> atom.type = ATOM;
		     np -> atom.string_ptr = addrel (return_ptr, 1);
		     np -> atom.string_len = length (return_string);

		     call return_string_advance ();

		     return;

		end treat_af_result_as_atom;

	     end process_active_function;
%page;
/* Internal to make_list:  "Allocate" a node, obtaining a new node_block if necessary */

get_node:
	     procedure ();

		null_cl = "0"b;			/* has to be something there or we wouldn't be here */

		node_index = node_index + 1;
		if node_index > hbound (node_block.array, 1) then do;
						/* allocate a new block */

		     last_block_ptr = block_ptr;

		     allocate node_block in (system_area) set (block_ptr);

		     unspec (node_block) = "0"b;
		     node_block.next = null ();
		     last_block_ptr -> node_block.next = block_ptr;
		     node_index = 1;
		end;

		np = addr (node_block.array (node_index));
						/* the node starts out as all zeroes */
		np -> node.next = null ();
		np -> node.af_prev = last_np;		/* in case node is af node */
		np -> node.af_iter_parent = null ();

		last_np -> node.next = np;
		last_np = np;

	     end get_node;



/* Internal to make_list:  Move return_ptr past the string just returned from the current active string invocation so that
   the result will not be lost */

return_string_advance:
	     procedure ();

		return_len = return_len - 4 * divide (length (return_string) + 3, 4, 21, 0) - 1;

		if return_len >= MIN_AF_RETURN_LTH then /* always give AF a certain minimum amount of space */
		     return_ptr = addrel (return_ptr, divide (length (return_string) + 7, 4, 17, 0));
		else return_ptr = null ();		/* not enough space left in this segment */

	     end return_string_advance;

	end make_list;
%page;
/* Compute number of iteration and arguments for the command and validate that matching iteration sets contain matching
   numbers of elements:  Two iteration sets are matching if either (1) they are connected (ie: the right parenthesis
   ending the first is not separated from the left parenthesis of the second by white space) or (2) they are top level
   iteration sets */

match_iters:
	procedure (p_first_node, p_command_type, p_arg_count, p_iter_count, p_new_first_node);

dcl  (p_first_node, p_new_first_node) pointer parameter;
dcl  p_command_type bit (1) aligned parameter;
dcl  (p_arg_count, p_iter_count) fixed binary parameter;

dcl  (p, pp) pointer;
dcl  first_iter bit (1) aligned;


	     first_iter = "1"b;
	     p_arg_count, p_iter_count = 0;
	     p_new_first_node = null ();		/* assume no semicolon left by AF */

	     p = p_first_node;
	     if p = null () then return;		/* empty list */
	     pp = null ();				/* pointer to last outer iteration set to be processed */
	     do while (p ^= null ());			/* to end of list */

		if p -> node.type = BEGIN_ITERATION then do;
						/* outer iteration set */
		     pp = p;			/* record pointer to iter node of iteration set */

		     call count_iteration ((p), count, 0, iter_level);
						/* iter_level should equal 0 */

		     if first_iter then do;
			first_iter = "0"b;
			p_iter_count = count;	/* save for later comparison */
		     end;
		     else if count ^= p_iter_count then do;
MISMATCH:
			code = error_table_$mismatched_iter;
			go to RETURN_FROM_CP;
		     end;

		     p_arg_count = p_arg_count + 1;	/* each outer iteration set is an argument */
		     if p ^= null () then		/* if iteration set does not end node list */
			if p -> node.next = null () then
						/* but node after it does */
			     p -> atom.space = "1"b;	/* list ends with atom */
			else ;
		end;
		else if p -> node.type = END_OF_COMMAND then do;
						/* semicolon embedded by an AF */
		     p_new_first_node = p -> node.next; /* remember where next piece is */
		     p -> node.af_prev -> node.next = null ();
						/* remove from chain */
		     p = null ();			/* do not look at rest */
		end;
		else do;				/* not ( or ; */
		     if p -> atom.next = null () then p -> atom.space = "1"b;
						/* last node in list */
		     if p -> node.space then p_arg_count = p_arg_count + 1;
		     p = p -> atom.next;
		end;
	     end;

	     if p_arg_count = 0 then
		p_iter_count = 0;			/* no arguments: this is an empty list */

	     else do;
		if p_command_type ^= active_function then p_arg_count = p_arg_count - 1;
						/* first argument is actually the command/AF name and should
						   not be included in the argument count: however, as AFs have
						   an extra argument (the return value), it isn't necessary to
						   change this value for AFs */
		if first_iter then p_iter_count = 1;	/* no iterations: read the list once */
	     end;

	     return;
%page;
/* Internal to match_iters:  processes a single iteration set (and any interation connected to it).  For example, (1 2) is
   a simple iteration set containing two (2) members; while (1 2)x(3 4) is a more complication expression involving two
   (2) connected iteration sets, but again only containing 2 members (1x3 and 2x4).  The iteration set (a (1 2)x(3 4) 5)x
   is an iteration set which contains four (4) members, namely ax, 1x3x, 2x4x, and 5x.

   Count_iteration returns the number of members in iteration_count and updates final_level to include all parentheses
   encountered in any of the nodes processed.  The node pointer variable 'p' is alsoupdated to point to the node following
   the node which ends the iteration set.  This is the first node unconnected to the iteration set */

count_iteration:
	     procedure (p_initial_p, p_iteration_count, p_parent_level, p_final_level);

dcl  p_initial_p pointer parameter;
dcl  (p_iteration_count, p_parent_level, p_final_level) fixed binary parameter;
dcl  (sub_count, temp_count) fixed binary;
dcl  (need_space, first_count) bit (1) aligned;

		p_iteration_count = 0;
		p_final_level = p_parent_level + 1;	/* count left paren */
		p = p_initial_p;			/* actually a no-op */

		p = p -> node.next;
		do while (p_final_level > p_parent_level);
		     if p = null () then go to MISMATCH;/* not enough )'s */
		     need_space = "1"b;		/* need to find a node which separates this
						   iteration set from rest of command line */
		     first_count = "1"b;		/* next iteration node begins an imbedded
						   iteration set which is not connected to previous one */

		     sub_count = 0;
		     do while (need_space);
			if p -> node.type = END_ITERATION then do;
			     if p -> node.next = null () then p -> node.space = "1"b;
			     pp = p -> iter_end.parent -> iter_begin.parent;
			     p_final_level = p -> iter_end.level;
			     if p_final_level < p_parent_level then do;
						/* multiple closure, pop one level */
				p_final_level = p_parent_level;
				need_space = "0"b;	/* do not advance to next node */
			     end;
			     else do;		/* closing one level */
				need_space = ^p -> iter_end.space;
				p = p -> iter_end.next;
			     end;
			end;
			else if p -> node.type = ATOM then do;
			     if p -> atom.space & (p_final_level = (p_parent_level + 1)) then
				sub_count = sub_count + 1;
			     if p -> node.next = null () then
						/* if last node in list */
				p -> node.space = "1"b;
			     need_space = ^p -> node.space;
			     p = p -> node.next;
			end;
			else if p -> node.type = BEGIN_ITERATION then do;
						/* another iteration  set */
			     if p_final_level = p_parent_level then do;
						/* this iteration is connected to */
				first_count = "0"b; /* initial iteration at p_parent_level+1 */
				sub_count = sub_count + p_iteration_count;
						/* save for later comparison */
				p_iteration_count = 0;
						/* compute iter count for connected iter */
			     end;			/* count the sub iteration */
			     call count_iteration ((p), temp_count, (p_final_level), p_final_level);
			     if first_count then do;
				sub_count = temp_count;
						/* save count of first iteration */
				first_count = "0"b;
			     end;
			     else if sub_count ^= temp_count then go to MISMATCH;
						/* this is count of an iter set connected to the first iter */
			     need_space = "0"b;
			end;
			else do;			/* semicolon in AF result embedded in parentheses ... */
			     code = error_table_$unbalanced_parentheses;
			     go to RETURN_FROM_CP;	/* ... is an error */
			end;
		     end;
		     p_iteration_count = p_iteration_count + sub_count;
						/* add to sum for parent iter set */
		end;

	     end count_iteration;

	end match_iters;
%page;
/* Create a command's argument list and either invoke it or produce a character string representation of the arguments:
   An argument list is generated (with descriptors) for the node list beginning at p_first_node */

produce_argument_list:
	procedure (p_first_node, p_command_type, p_arg_count);

dcl  p_first_node pointer parameter;
dcl  p_command_type bit (1) aligned parameter;
dcl  p_arg_count fixed binary parameter;
dcl  p_pipe_control_ptr ptr;

dcl  read_list_entry bit (1) aligned;

dcl  (p, pp) pointer;

dcl  start_arg bit (1) aligned;
dcl  null_iter bit (1) aligned;			/* ON means a null nested iter was found */
dcl  rethreaded bit (1) aligned;			/* ON if list already rethreaded */
dcl  (saved_level, argument_idx) fixed binary;

dcl  command_name character (arg_len (0)) unaligned based (command_name_ptr);
dcl  command_name_ptr pointer;
dcl  command_entry_ptr pointer;			/* command to call */

dcl  (extension_size, needed_space) fixed binary (21);
dcl  (arg_ptr, stack_ptr, space_ptr) pointer;
dcl  arg_space fixed binary (21);			/* number of chars left in space acquired */

dcl  object character (object_lth) unaligned based (object_ptr);
dcl  object_ptr pointer;
dcl  object_lth fixed binary (21);
dcl  suffix character (1) varying;

dcl  current_arg_len fixed binary (21);			/* number of chars in (non-simple) arg being developed */
dcl  current_arg character (current_arg_len) unaligned based (arg_ptr);

dcl  arg character (arg_space) unaligned based (arg_ptr);
dcl  arg_len (0:p_arg_count + 1) fixed binary automatic;

dcl  1 arg_list aligned automatic,
       2 twice_no_of_args fixed binary (18) unaligned unsigned,
       2 tag bit (18) unaligned initial ("000004"b3),
       2 twice_no_of_descriptors fixed binary (18) unaligned unsigned,
       2 has_command_name bit (1) unal,
       2 pad bit (17) unaligned initial ("0"b),
       2 arg_ptr (p_arg_count) pointer,
       2 descriptor_ptr (p_arg_count) pointer,
       2 name,
         3 command_name_ptr pointer,
         3 command_name_length fixed bin (21);

dcl  1 descriptor (p_arg_count) aligned automatic,
       2 bits bit (12) unaligned,			/* flag(1), type(6), packed(1), and ndims(4) */
       2 size fixed binary (24) unaligned unsigned;
%page;
/* Construct the argument list and then invoke the command */

read_list:
	entry (p_first_node, p_command_type, p_arg_count, p_pipe_control_ptr);

	     read_list_entry = "1"b;
	     go to RL_COMMON;



/* Construct the argument list and then produce a character string representation of the command invocation */

write_list:
	entry (p_first_node, p_command_type, p_arg_count, p_pipe_control_ptr);

	     read_list_entry = "0"b;


RL_COMMON:
	     count, current_arg_len, arg_space, extension_size = 0;
	     space_ptr = null ();
	     start_arg = "1"b;			/* need to get space for arg */
	     arg_ptr = null ();			/* just to catch programming errors */

	     p = p_first_node;

	     do while (p ^= null ());			/* to end of list */

		if p -> node.type = ATOM then do;	/* atom */
		     atom_ptr = p -> atom.string_ptr;
		     atom_len = p -> atom.string_len;
		     if start_arg & p -> atom.space then do;
						/* single command line token as arg */
			arg_len (count) = atom_len;
			if count = 0 then
			     command_name_ptr = atom_ptr;
			else arg_list.arg_ptr (count) = atom_ptr;
			current_arg_len = 0;
			count = count + 1;
			start_arg = "1"b;
		     end;
		     else do;
			call non_simple_arg ();
			if p -> atom.space then call end_arg ();
		     end;
		     p = p -> atom.next;
		end;

		else do;				/* iteration set */
		     rethreaded = "0"b;
		     iter_level = 1;
		     pp = p;			/* go inside; set parent pointer */

		     do p = p -> node.next repeat (p -> node.next) while (iter_level > 0);
						/* to end of outer iteration set */

			if p -> node.type = BEGIN_ITERATION then do;
						/* nested iteration */
			     if ^start_arg & rethreaded then rethreaded = "0"b;
						/* if connected iteration must rethread each iteration set */
			     iter_level = iter_level + 1;
			     pp = p;
			     if p -> iter_begin.next = p -> iter_begin.end then do;
						/* null iteration set */
				current_arg_len = 0;/* have to begin arg over */
				start_arg = "1"b;
				null_iter = "1"b;
				rethreaded = "0"b;
				go to skip_iter;
			     end;
			end;
			else do;
			     null_iter = "0"b;
			     atom_ptr = p -> atom.string_ptr;
			     atom_len = p -> atom.string_len;
			     if start_arg & (p -> atom.space) & (pp -> iter_begin.end -> iter_end.space)
				& (iter_level = 1) then do;
						/* single command line token as arg */
						/* depends upon whether right paren is followed by space */
						/* only simple tokens in the outermost iteration set
						   are not copied, to detect simple tokens when additional
						   levels of nesting are involved is quite complicated and not
						   deemed worth the effort for a very unlikely construct */
				arg_len (count) = atom_len;
				if count = 0 then
				     command_name_ptr = atom_ptr;
				else arg_list.arg_ptr (count) = atom_ptr;
				current_arg_len = 0;
				count = count + 1;
				start_arg = "1"b;
			     end;
			     else call non_simple_arg ();

			     if p -> atom.space then do;
						/* this atom ends an element of the iteration set */
				if ^rethreaded then do;
						/* rethread next iteration element */
				     rethreaded = "1"b;
						/* assume we can do the rethreading */
				     if p -> atom.next -> node.type ^= END_ITERATION then
					pp -> iter_begin.next = p -> atom.next;
						/* if not last element of iteration set */
				     else if p -> atom.next -> iter_end.space then do;
						/* if last element of iteration set followed by space */
					if iter_level = 1 then
					     p -> atom.next -> iter_end.parent -> iter_begin.next =
						p -> atom.next;
						/* and top level */
					else pp -> iter_begin.parent -> iter_begin.next =
						p -> atom.next -> iter_end.next;
						/* not top level, its done */
				     end;
				     else rethreaded = "0"b;
						/* last element of iteration set not followed by space */
						/* have to perform rethreading later */
				end;

/* Skip to the end of this iteration set */

skip_iter:
				saved_level = iter_level;
				p = pp -> iter_begin.end;
						/* move p to ) node */

				do while (iter_level > 0);
				     if p -> node.type = BEGIN_ITERATION then do;
						/* left paren, jump to right paren which matches */
					iter_level = iter_level + 1;
					pp = p;
					p = pp -> iter_begin.end;
				     end;

/* Node must be either an atom or iter_end node */
				     if p -> node.type = END_ITERATION then do;
					iter_level = p -> iter_end.level;
					pp = p -> iter_end.parent -> iter_begin.parent;
					if iter_level = 0 then
					     if p -> iter_end.space then
						if ^start_arg then
						     call end_arg ();
						else ;
						/* no arg needs to be ended */
					     else ;
						/* reached outermost ), but it is connected to something */
					else do;	/* reached end of nested iteration */
					     if iter_level >= saved_level then ;
						/* some other iter set */
					     else if p -> iter_end.space then
						if null_iter then
						     go to more_arg;
						/* finished with stuff connected to null iteration */
						else ;
						/* nested iter, nothing connected to it */
					     else if null_iter then ;
						/* end of iter connected to null iter */
					     else go to more_arg;
						/* nested iter with something attached */
					     p = p -> node.next;
					end;
				     end;
				     else if null_iter & p -> atom.space then go to more_arg;
						/* reached last node connected to null iteration */
				     else p = p -> node.next;
						/* an atom node */
				end;
			     end;
			end;
more_arg:
		     end;				/* p can be null at this point */
		end;
	     end;
%page;
	     if read_list_entry then do;

/* All arguments have been completed and the command or active function should be called */

		if p_command_type = active_function then
		     twice_no_of_args, twice_no_of_descriptors = 2 * count;
		else twice_no_of_args, twice_no_of_descriptors = 2 * (count - 1);

		do argument_idx = 1 to count - 1;
		     descriptor_ptr (argument_idx) = addr (descriptor (argument_idx));
		     descriptor (argument_idx).bits = "5260"b3;
		     descriptor (argument_idx).size = arg_len (argument_idx);
		end;				/* unaligned nonvarying strings */

		if p_command_type = active_function then do;
		     call setup_return_string ();	/* prepare the return string */
		     arg_list.arg_ptr (p_arg_count) = addrel (addr (return_string), 1);
		     descriptor_ptr (p_arg_count) = addr (descriptor (p_arg_count));
		     descriptor (p_arg_count).bits = "5320"b3;
						/* aligned, varying string */
		     descriptor (p_arg_count).size = return_len;
		end;


/* save the name on the current argument list NOTE this is  a new structure
*/

		arg_list.has_command_name = "1"b;
		arg_list.name.command_name_length = length (command_name);
		arg_list.name.command_name_ptr = command_name_ptr;
		command_entry_ptr = null;

		if multics_cp then on condition (command_abort_) go to ABORT_EXECUTION;
		else if p_command_type = command then on condition (request_abort_) go to ABORT_EXECUTION;


		if p_command_type = active_function | p_pipe_control_ptr = null then do;
						/* regular command call         */

		     call process_command (command_entry_ptr, code);
		     if code ^= 0 then go to SILENTLY_RETURN_FROM_CP;
		end;
		else do;				/* the pipe facility is invoked */
		     on condition (cleanup) call process_pipe_cleanup (p_pipe_control_ptr);

		     call process_pipe (p_pipe_control_ptr, command_name, code);
		     if code ^= 0 then go to RETURN_FROM_CP;
		end;

	     end;
%page;
	     else do;

/* All arguments have been completed and the list is to be retruned as a character string */

		do argument_idx = 0 to count - 1;

		     if (argument_idx ^= count - 1) then
			suffix = " ";		/* more to come */
		     else suffix = "";

		     if argument_idx = 0 then
			object_ptr = command_name_ptr;
		     else object_ptr = arg_list.arg_ptr (argument_idx);
		     object_lth = arg_len (argument_idx);

		     if length (P_return_value) + object_lth + length (suffix) > maxlength (P_return_value) then
			code = error_table_$command_line_overflow;

		     P_return_value = P_return_value || object;
						/* two statements generates better code */
		     P_return_value = P_return_value || suffix;

		     if code ^= 0 then go to SILENTLY_RETURN_FROM_CP;
						/* failure to fit */
		end;
	     end;
ABORT_EXECUTION:
	     return;
%page;
/* Internal to produce_argument_list:  moves the atom_string into the current_arg, obtaining more space if necessary */

non_simple_arg:
	     procedure () /* options (quick) */;	/* MUST BE A QUICK BLOCK */

		if current_arg_len + atom_len > arg_space then do;
		     needed_space = 16 * max (4, divide (currentsize (atom_string) + 15, 16, 21, 0));
		     extension_size = extension_size + needed_space;
		     if using_stack & (needed_space < 1024) & (extension_size < MAX_STACK_EXTENSION) then do;
						/* OK to continue extending the stack */
			call cu_$grow_stack_frame (needed_space, stack_ptr, ignore_code);
						/* grow_stack_frame always returns zero code */
			if space_ptr = null () then do;
			     space_ptr = stack_ptr;
			     arg_ptr = space_ptr;	/* first call, must initialize arg_ptr */
			end;
			arg_space = arg_space + 4 * needed_space;
		     end;

		     else do;			/* use space in a temporary segment */
			using_stack = "0"b;
			space_ptr = select_scratch_segment ();
			arg_space = 4 * sys_info$max_seg_size;
			if ^start_arg then do;
			     substr (space_ptr -> arg, 1, current_arg_len) = current_arg;
			     arg_space = arg_space - current_arg_len;
			end;
			arg_ptr = space_ptr;	/* have switched spaces */
		     end;
		end;

		substr (arg, current_arg_len + 1, atom_len) = atom_string;
		current_arg_len = current_arg_len + atom_len;
		start_arg = "0"b;			/* arg has been started */
		arg_space = arg_space - atom_len;

	     end non_simple_arg;
%page;
/* Internal to produce_argument_list:  complete construction of the current argument */

end_arg:
	     procedure ();

		if count = 0 then
		     command_name_ptr = arg_ptr;
		else arg_list.arg_ptr (count) = arg_ptr;
		arg_len (count) = current_arg_len;

		arg_ptr = addr (substr (arg, current_arg_len + 1, 1));
						/* get pointer to char after
						   last char of this arg */
		arg_space = arg_space - current_arg_len;

		count = count + 1;
		start_arg = "1"b;
		current_arg_len = 0;

	     end end_arg;



/* Internal to produce_argument_list:  Prepares the return string for an active function invocation */

setup_return_string:
	     procedure ();

		if return_ptr = null () then do;	/* first active function or last one used too much space */
		     return_ptr = select_scratch_segment ();
		     return_len = 4 * (sys_info$max_seg_size - 1);
		end;

		return_string = "";

		return;

	     end setup_return_string;
%page;
process_command:
	     proc (command_entry_ptr, code);

dcl  command_entry_ptr ptr,
     code fixed bin (35);

		if multics_cp then do;		/* executing Multics command line */
		     if lss_on then do;		/* running Limited Service System */
			call transform_command_ (command_name_ptr, arg_len (0), cp_data_$command_table_ptr, code);

			if code ^= 0 then go to SILENTLY_RETURN_FROM_CP;
		     end;

		     if command_entry_ptr = null then do;
			if evaluate_string then	/* be silent for cp_$af */
			     call find_command_$fc_no_message (command_name_ptr, arg_len (0), command_entry_ptr,
				code);

			else call find_command_ (command_name_ptr, arg_len (0), command_entry_ptr, code);

			if code ^= 0 then go to SILENTLY_RETURN_FROM_CP;

		     end;

		     call cu_$gen_call (command_entry_ptr, addr (arg_list));
		end;

		else if new_subsystem_call		/* executing a new-style subsystem request */
		then do;
		     call execute_request (P_subsystem_info_ptr, command_name, addr (arg_list), code);
		     if code ^= 0 then go to SILENTLY_RETURN_FROM_CP;
		end;

		else do;				/* executing an old-style subsystem request */
		     call old_execute_request (command_name, addr (arg_list), code);
		     if code ^= 0 then go to SILENTLY_RETURN_FROM_CP;
		end;
		return;

	     end process_command;
%page;

/* Internal to produce_argument_list: determines whether the entry is an io
   attachment or command, then processes accordingly. */

process_pipe:
	     proc (p_pipe_control_ptr, command_name, code);

dcl  p_pipe_control_ptr ptr parameter,				/* (input) - ptr 2 pipe control info */
     command_name char (*) parameter,				/* (input) - name of the command    */
     code fixed bin (35) parameter;				/* (output)- error status	      */

dcl  aligned_command_name char (32) aligned;
dcl  pipe_control_ptr ptr;
dcl  1 pipe_control aligned like command_pipe_control based (pipe_control_ptr);
dcl  Satds_match bit (1) aligned;
dcl  Sdefault_curr_to_vfile bit (1) aligned;
dcl  attach_description char (1024) aligned;
dcl  command_entry_ptr ptr;
dcl  current_pipe aligned char (pipe_control.current_pipe_len) based (pipe_control.current_pipe_ptr);
dcl  next_pipe aligned char (pipe_control.next_pipe_len) based (pipe_control.next_pipe_ptr);
dcl  previous_pipe aligned char (pipe_control.previous_pipe_len) based (pipe_control.previous_pipe_ptr);
dcl  pipeout_file_path char (168) aligned;
dcl  sv_pipe_path char (58);

dcl  FALSE bit (1) aligned internal static options (constant) init ("0"b),
     TRUE bit (1) aligned internal static options (constant) init ("1"b),
     INPUT bit (1) aligned internal static options (constant) init ("1"b),
     OUTPUT bit (1) aligned internal static options (constant) init ("0"b);

dcl  pipe_$initiate entry (ptr),
     pipe_$copy entry (ptr, ptr, fixed bin (35)),
     pipe_$attach_pipe entry (char (*) aligned, bit (1) aligned, bit (1) aligned, ptr, fixed bin (35)),
     pipe_$open_pipe entry (ptr, bit (1) aligned, fixed bin (35)),
     pipe_$get_return_string_nnl entry (ptr, ptr, fixed bin (21), fixed bin (35)),
     pipe_$get_return_string entry (ptr, ptr, fixed bin (21), fixed bin (35));

		pipe_control_ptr = p_pipe_control_ptr;
		command_entry_ptr = null;
		Satds_match = FALSE;

		if pipe_control.current_pipe_len = 0 then return;

		if substr (command_name, 1, length (VERTICAL_BAR)) = VERTICAL_BAR then
		     code = error_table_$bad_file_name;
		else call check_star_name_ (command_name,
		   CHECK_STAR_PROCESS_PATH |
		   CHECK_STAR_REJECT_WILD  |
		   CHECK_STAR_IGNORE_ENTRYPOINT, (0), code);

		if code ^= 0 then do;
		     error_message = command_name;
		     return;
		end;

		if pipe_control.Sevaluate_pipe then do;
		     if pipe_control.Sbuild_return_string then return_ptr = null;
		     call setup_return_string ();
		end;

/* only the command name needs to be checked to see if it is an atd */

	          aligned_command_name = command_name;
		if element_is_an_atd (aligned_command_name, command_entry_ptr, Sdefault_curr_to_vfile, code) then do;

/* This call builds a complete attach description for the current section of
   the command line.  The usage of the value next_pipe is discussed in
   make_list label PROCESS_CHARACTER (2) above.  Because the value may not be
   complete, it is necessary to build the attachment from the argument list. */

		     attach_description = make_command_line_attach ();
		     call process_attach_description (return_ptr, return_len, code);
		end;
		else call process_pipe_command (command_entry_ptr, command_name, return_ptr, return_len, code);

		return;
%page;
/* Internal to process_pipe: processes the current section of the command
   line if it is an attach description. */

process_attach_description:
		proc (af_return_str_ptr, af_return_str_len, code);

dcl  af_return_str_ptr ptr,				/* (input/output) ptr to return str */
     af_return_str_len fixed bin (21),			/* (input/output) len of return str */
     code fixed bin (35);				/* (output)       error status     */

		     code = 0;

/* If the element before the ";|" is an attach description, copy its
   contents to this attach description. */

		     if pipe_control.previous_pipe_ptr ^= null then do;
			call copy_thru_pipe (previous_pipe, attach_description, code);
			if code ^= 0 then return;

/* if the previous attach is the same as this one, the data was placed in a
   temp file.  Now copy the data from the temp file to the original */

			if Satds_match then do;
			     call copy_thru_pipe (pipe_control.pipe_output_path, attach_description, code);
			     if code ^= 0 then return;
			end;
		     end;

/* next_pipe_ptr is null when the attach description is the last element in an
   input command line. */
		     if pipe_control.next_pipe_ptr = null then return;

/* build the active function return string when this attach description
   preceeds the string ";|]" or ";||]". */

		     if pipe_control.Sbuild_return_string then do;
			if (pipe_control.niters < pipe_control.Niters) then
			     ;
			else call build_pipe_return_string (attach_description, af_return_str_ptr,
				af_return_str_len, code);
		     end;

/* If this attach description is the last thing in the line except ";|",
   use a default output file of "[wd]>pipeout". */

		     else if next_pipe = "" then do;
			pipeout_file_path =  rtrim (get_wdir_ ()) || ">pipeout";
			call copy_thru_pipe (attach_description, pipeout_file_path, code);
			end;
		       

/* if this element is an attach description that does not use any active
   functions, quotes or parens, do nothing.  Otherwise, copy its contents to
   the next element in the line.  This is because when the next pipe element
   is processed, this value will be the previous pipe value and because it
   has special characrters in it, the next element will expect a temp file. */

		     else if element_is_an_atd (current_pipe, null, Sdefault_curr_to_vfile, ignore_code) then ;

		     else do;

			call copy_thru_pipe (attach_description, ltrim (next_pipe), code);
			if code ^= 0 then return;

			if (pipe_control.niters < pipe_control.Niters) then
			     ;
			else do;

/* switch the pathnames of the input and output pipe work files so that
   the current output file will be used as input to the next element in
   the command line. */
			     sv_pipe_path = pipe_control.pipe_input_path;
			     pipe_control.pipe_input_path = pipe_control.pipe_output_path;
			     pipe_control.pipe_output_path = sv_pipe_path;
			end;
		     end;

		     return;
		end process_attach_description;
%page;
/* Internal to process_pipe: processes the current section of the command
   line if it is a command. */

process_pipe_command:
		proc (command_entry_ptr, command_name, af_return_str_ptr, af_return_str_len, code);

dcl  command_entry_ptr ptr,				/* (input) - ptr to entry to execute */
     command_name char (*),			/* (input) - name of command        */
     af_return_str_ptr ptr,				/* (input/output) ptr to return str */
     af_return_str_len fixed bin (21),			/* (input/output) len of return str */
     code fixed bin (35);				/* (output)- error status           */

		     code = 0;

		     call attach_input (previous_pipe, pipe_control.input_ptr, code);
		     if code ^= 0 then return;

		     if pipe_control.next_pipe_ptr ^= null then do;
			if next_pipe = "" then do;
			     pipeout_file_path =  rtrim (get_wdir_ ()) || ">pipeout";
			     call attach_output (previous_pipe, pipeout_file_path,
				pipe_control.output_ptr, Satds_match, code);
			     end;
			else call attach_output (previous_pipe, next_pipe, pipe_control.output_ptr, Satds_match,
				code);
			if code ^= 0 then return;
		     end;

		     call process_command (command_entry_ptr, code);
		     call process_pipe_cleanup (p_pipe_control_ptr);

		     if (pipe_control.niters < pipe_control.Niters) then
			;
		     else do;
			if pipe_control.Sbuild_return_string then
			     call build_pipe_return_string (pipe_control.pipe_output_path, af_return_str_ptr,
				af_return_str_len, code);

			sv_pipe_path = pipe_control.pipe_input_path;
			pipe_control.pipe_input_path = pipe_control.pipe_output_path;
			pipe_control.pipe_output_path = sv_pipe_path;
		     end;

		     return;
		end process_pipe_command;
%page;
/* Internal to process_pipe: compares two attach descriptions. */

atds_match:
		proc (attach_description_1, attach_description_2, Sdefault2) returns (bit (1) aligned);

dcl  attach_description_1 char (*) aligned,		/* (input) attach descrip. 1. */
     attach_description_2 char (*) aligned,		/* (input) attach descrip. 2. */
     Sdefault2 bit (1) aligned;			/* (input) atd2 is a vfile_ */

dcl  Sdefault1 bit (1) aligned,
     full_path1 char (1024),
     full_path2 char (1024),
     match_word1 char (32) varying,
     match_word2 char (32) varying,
     word_cnt1 fixed bin,
     word_cnt2 fixed bin,
     uid1 bit (36) aligned,
     uid2 bit (36) aligned;


		     word_cnt1 = 1;
		     word_cnt2 = 1;

/* if one of the attach descriptions is blank, they do not match. */

		     if attach_description_1 = SPACE | attach_description_2 = SPACE then return (FALSE);

/* If the first attach is defaulted to a vfile, set the match word to
   "vfile_".  Otherwise, set the match word to the first word in the
   attach description. */

		     if element_is_an_atd (attach_description_1, null, Sdefault1, ignore_code) then
			match_word1 = "vfile_";
		     else do;
			match_word1 = get_word (attach_description_1, word_cnt1);
			word_cnt1 = word_cnt1 + 1;
		     end;

/* If the secord attach is defaulted to a vfile, set the match word to
   "vfile_".  Otherwise, set the match word to the first word in the
   attach description. */

		     if Sdefault2 then
			match_word2 = "vfile_";
		     else do;
			match_word2 = get_word (attach_description_2, word_cnt2);
			word_cnt2 = word_cnt2 + 1;
		     end;

/* Here, the first words will always be the name of the I/O module used.
   If they do not match, the attach descriptions do not match. */

		     if match_word1 ^= match_word2 then return (FALSE);

/* If using vfile_, get the uid of the file begin attached to.   The uid
   is the only accurate means of determining if the two paths point to
   the same file. */

		     if match_word1 = "vfile_" then do;
			match_word1 = get_word (attach_description_1, word_cnt1);
			match_word2 = get_word (attach_description_2, word_cnt2);

			call absolute_pathname_ ((match_word1), full_path1, ignore_code);
			call hcs_$get_uid_file (full_path1, "", uid1, code);
			if code ^= 0 then do;
			     code = 0;
			     uid1 = TRUE;
			end;

			call absolute_pathname_ ((match_word2), full_path2, ignore_code);
			call hcs_$get_uid_file (full_path2, "", uid2, code);
			if code ^= 0 then do;
			     code = 0;
			     uid2 = FALSE;
			end;

			if uid1 = uid2 then return (TRUE);
			return (FALSE);
		     end;

/* Here, all I/O modules that are not vfile_ are checked.  If the first
   arguments to the I/O modules are the same, then return true. */

		     match_word1 = get_word (attach_description_1, word_cnt1);
		     match_word2 = get_word (attach_description_2, word_cnt2);

		     if match_word1 = match_word2 then return (TRUE);

/* Cases that are not handled by this routine include:

   1) mtape_ attach descriptions where the volume name is placed into the
   default arguments value within a value segment.  In this case,
   the attach description is incomplete.  Omitting the positional
   argument is a violation of the standard for I/O modules and mtape_
   should be changed to conform. */

		     return (FALSE);

get_word:
		     proc (word_list, word_to_return) returns (char (32) varying);

dcl  word_list char (*) aligned;
dcl  word_to_return fixed bin;
dcl  work_list char (1024) varying;
dcl  word char (32) varying;
dcl  i fixed bin;

/* If the attach description has a target attach, use only the target. */

			work_list = ltrim (after (word_list, "-target "));
			if work_list = "" then work_list = ltrim (word_list);

			do i = 1 to word_to_return;
			     word = before (work_list, SPACE);
			     work_list = after (work_list, SPACE);
			     work_list = ltrim (work_list);
			end;

			return (word);
		     end get_word;

		end atds_match;
%page;
/* Internal to process_pipe: attaches and opens user_input for use by
   the caller using the input attachment. */

attach_input:
		proc (input_atd, input_ptr, code);

dcl  input_atd char (*) aligned;			/* (input) - attach descipt/command */
dcl  input_ptr ptr;					/* (input/output) - ptr to input pipe info */
dcl  code fixed bin (35);				/* (output) - error status          */

dcl  Sdefault_to_vfile bit (1) aligned;

/* Attach and open the input based on type */

		     code = 0;
		     input_ptr = null;

		     if input_atd = "" then return;

		     input_atd = ltrim (input_atd);

/* If the input attachment is an attach description, attach and open it.
   Otherwise, attach and open the pipe input file. If there is no pipe input,
   there is an error. */

		     if element_is_an_atd (input_atd, null, Sdefault_to_vfile, ignore_code) then
			call pipe_$attach_pipe (input_atd, Sdefault_to_vfile, FALSE, input_ptr, code);

		     else do;			/* previous entry is a command */
			if pipe_control.pipe_input_path = "" then do;
			     code = error_table_$no_file;
			     return;
			end;

			else call pipe_$attach_pipe (pipe_control.pipe_input_path, TRUE, FALSE, input_ptr, code);
		     end;


		     if code ^= 0 then do;
			error_message = "While attaching " || rtrim (input_atd) || ".";
			return;
		     end;

		     call pipe_$open_pipe (input_ptr, INPUT, code);
		     if code ^= 0 then do;
			if code = error_table_$noentry then
			     error_message = "Unknown command or file " || input_atd || ".";
			else error_message = "While opening " || input_atd || " for input.";
			call process_pipe_cleanup (p_pipe_control_ptr);
			return;
		     end;
		     return;
		end attach_input;
%page;
/* Internal to process_pipe: attaches and opens user_output for use by
   the caller using the output attachment. */

attach_output:
		proc (input_atd, output_atd, output_ptr, Satds_match, code);

dcl  input_atd char (*) aligned;			/* (input) - input attachment       */
dcl  output_atd char (*) aligned;			/* (input) - output to be attached  */
dcl  output_ptr ptr;				/* (input/output) - ptr to output pipe info */
dcl  Satds_match bit (1) aligned;			/* (output) - ON = input matchs output */
dcl  code fixed bin (35);				/* (output) - error status          */

dcl  Sdefault_to_vfile bit (1) aligned;

		     code = 0;
		     output_ptr = null;

		     input_atd = ltrim (input_atd);
		     output_atd = ltrim (output_atd);

/* If the output attachment is an attach description and does not conflict
   with the input attachment, attach and open it.  Otherwise, attach and
   open the pipe output file. */

		     if element_is_an_atd (output_atd, null, Sdefault_to_vfile, ignore_code) then do;
			if atds_match (input_atd, output_atd, Sdefault_to_vfile) then
			     Satds_match = "1"b;
			else do;
			     call pipe_$attach_pipe (output_atd, Sdefault_to_vfile, TRUE, output_ptr, code);
			     Satds_match = "0"b;
			end;
		     end;

		     if output_ptr = null & code = 0 then do;
			if pipe_control.pipe_output_path = "" then
			     call pipe_$initiate (addr (pipe_control.pipe_output_path));

			call pipe_$attach_pipe (pipe_control.pipe_output_path, TRUE, TRUE, output_ptr, code);
		     end;

		     if code ^= 0 then do;
			error_message = "While attaching " || output_atd || ".";
			return;
		     end;

		     call pipe_$open_pipe (output_ptr, OUTPUT, code);
		     if code ^= 0 then do;
			error_message = "While opening " || output_atd || " for output.";
			call process_pipe_cleanup (p_pipe_control_ptr);
			return;
		     end;

		     return;
		end attach_output;
%page;
/* Internal to process_pipe: adds the information from the file given in
   the input_atd to the active function return string. */

build_pipe_return_string:
		proc (input_atd, pipe_return_string_ptr, pipe_return_string_len, code);

dcl  input_atd char (*) aligned,			/* (input) - return string file    */
     pipe_return_string_ptr ptr,			/* (input) - ptr to return string  */
     pipe_return_string_len fixed bin (21),		/* (input) - len of return string */
     code fixed bin (35);				/* (output) - error status         */

		     call attach_input (input_atd, pipe_control.input_ptr, code);
		     if code ^= 0 then return;

		     if pipe_control.Sinclude_NL_in_af_ret_str then
			call pipe_$get_return_string (pipe_control.input_ptr, pipe_return_string_ptr,
			     pipe_return_string_len, code);
		     else call pipe_$get_return_string_nnl (pipe_control.input_ptr, pipe_return_string_ptr,
			     pipe_return_string_len, code);

		     call process_pipe_cleanup (p_pipe_control_ptr);
		     return;
		end build_pipe_return_string;
%page;
/* Internal to process_pipe: copies the information from the file given in
   the input atd to the file given in the output atd. */

copy_thru_pipe:
		proc (copy_input_atd, copy_output_atd, code);

dcl  copy_input_atd aligned char (*),			/* (input) - input attach descript. */
     copy_output_atd aligned char (*),			/* (input) - output attach descript. */
     code fixed bin (35);				/* (output)- error status           */

		     call attach_input (copy_input_atd, pipe_control.input_ptr, code);

		     if code = error_table_$no_file then do;
			code = 0;
			return;
		     end;

		     if code = 0 then do;
			call attach_output (copy_input_atd, copy_output_atd, pipe_control.output_ptr, Satds_match,
			     code);
			if code = 0 then do;

			     call pipe_$copy (pipe_control.input_ptr, pipe_control.output_ptr, code);

			     if code ^= 0 then
				error_message =
				     "While copying data from " || ltrim (copy_input_atd) || " to "
				     || ltrim (copy_output_atd) || ".";
			end;
		     end;

		     call process_pipe_cleanup (p_pipe_control_ptr);

		     return;
		end copy_thru_pipe;
%page;
/* Internal to process_pipe: determines if the input pipe element is a valid
   attach description or command. */

element_is_an_atd:
		proc (pipe_element, p_command_entry_ptr, Sdefault_to_vfile, code) returns (bit (1) aligned);

dcl  pipe_element char (*) aligned,			/* (input) - element who type is to be determined */
     p_command_entry_ptr ptr,				/* (output)- if a command points to its entrypoint */
     Sdefault_to_vfile bit (1) aligned,			/* (output)- if an atd on = file name use vfile_  */
     code fixed bin (35);				/* (output)- error status                         */

dcl  dirname char (168),
     entryname char (32),
     io_module_attach_entry char (200);

dcl  command_entry_ptr ptr;

dcl  expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));

		     Sdefault_to_vfile = FALSE;
		     p_command_entry_ptr = null;

		     if ^multics_cp then return (FALSE);

		     pipe_element = ltrim (pipe_element);

		     if search (pipe_element, NON_SIMPLE_BREAKS) > 0 then return (FALSE);
				/* If entry already is an entry, it */
				/* is not an atd.		      */
		     if search (pipe_element, "$") > 0 then return (FALSE);
		     call find_command_$fc_no_message (addr (before (pipe_element, SPACE)),
			length (before (pipe_element, SPACE)), command_entry_ptr, code);
		     if code = 0 then do;
			p_command_entry_ptr = command_entry_ptr;
			return (FALSE);
		     end;

		     call expand_pathname_ (before (pipe_element, SPACE), dirname, entryname, code);

/* set the io module name to the entryname portion of the pipe element. If
   there is a pathname in the line, it is possible that a personal version
   of an i/o module is being used. */

		     io_module_attach_entry =
			before (ltrim (pipe_element), rtrim (entryname)) || rtrim (entryname) || "$"
			|| rtrim (entryname) || "attach";

		     call find_command_$fc_no_message (addr (io_module_attach_entry), length (io_module_attach_entry),
			command_entry_ptr, code);

		     if code = 0 then return (TRUE);


		     Sdefault_to_vfile = TRUE;
		     code = 0;
		     return (TRUE);

		end element_is_an_atd;
%page;
/* Internal to process_pipe: builds and returns an attach description and
   arguments using the argument list. */

make_command_line_attach:
		proc () returns (char (1024) varying);

dcl  command_line_attach char (1024) varying;

		     command_line_attach = "";
		     do argument_idx = 0 to count - 1;

			if (argument_idx ^= count - 1) then
			     suffix = " ";		/* more to come */
			else suffix = "";

			if argument_idx = 0 then
			     object_ptr = command_name_ptr;
			else object_ptr = arg_list.arg_ptr (argument_idx);
			object_lth = arg_len (argument_idx);

			if length (command_line_attach) + object_lth + length (suffix)
			     > maxlength (command_line_attach) then
			     code = error_table_$command_line_overflow;

			command_line_attach = command_line_attach || object;
						/* two statements generates better code */
			command_line_attach = command_line_attach || suffix;

			if code ^= 0 then go to SILENTLY_RETURN_FROM_CP;
						/* failure to fit */
		     end;
		     return (command_line_attach);
		end make_command_line_attach;

	     end process_pipe;

%page;

/* Internal to process_pipe:  closes and detaches user_input and user_output. */

process_pipe_cleanup:
	     proc (p_pipe_control_ptr);

dcl  p_pipe_control_ptr ptr;				/* (input) - ptr 2 pipe control info */

dcl  1 pipe_control aligned like command_pipe_control based (p_pipe_control_ptr);
dcl  pipe_$close_pipe entry (ptr, bit (1) aligned, fixed bin (35)),
     pipe_$detach_pipe entry (ptr, fixed bin (35));

		if pipe_control.input_ptr ^= null then do;
		     call pipe_$close_pipe (pipe_control.input_ptr, pipe_control.niters = pipe_control.Niters,
			ignore_code);
		     call pipe_$detach_pipe (pipe_control.input_ptr, ignore_code);
		end;

		if pipe_control.output_ptr ^= null then do;
		     call pipe_$close_pipe (pipe_control.output_ptr, "0"b, ignore_code);
		     call pipe_$detach_pipe (pipe_control.output_ptr, ignore_code);
		end;
		return;
	     end process_pipe_cleanup;

	end produce_argument_list;
%page;
/* Initialize scratch segment management */

initialize_scratch_segments:
	procedure (p_first_call);

dcl  p_first_call bit (1) aligned parameter;

	     if p_first_call then do;			/* only do the following stuff once per invocation ... */
		permanent_scratch_segment_list_ptr = addr (cp_data_$permanent_scratch_segment_list);
		cp_data_$scratch_lock_id = cp_data_$scratch_lock_id + 1;
		scratch_lock_id = bit (fixed (cp_data_$scratch_lock_id, 36, 0), 36);
	     end;

	     temporary_scratch_segment_list_ptr = addr (local_temporary_scratch_segment_list);
	     temporary_scratch_segment_list.n_allocated =
		dimension (local_temporary_scratch_segment_list.segment_ptrs, 1);
	     temporary_scratch_segment_list.n_used = 0;	/* not using any temporary scratch segments just yet */
	     temporary_scratch_segment_list.segment_ptrs (*) = null ();

	     return;

	end initialize_scratch_segments;



/* Select the next available scratch segment giving preference to the "permanent" segments */

select_scratch_segment:
	procedure () returns (pointer);

dcl  1 permanent_scratch_segment like permanent_scratch_segment_list.scratch_segments aligned
	based (permanent_scratch_segment_ptr);
dcl  (permanent_scratch_segment_ptr, old_temporary_scratch_segment_list_ptr, new_temporary_scratch_segment_list_ptr,
     segment_ptr) pointer;
dcl  idx fixed binary;

	     segment_ptr = null ();			/* haven't found one yet */

	     do idx = 1 to permanent_scratch_segment_list.n_scratch_segments while (segment_ptr = null ());
		permanent_scratch_segment_ptr = addr (permanent_scratch_segment_list.scratch_segments (idx));
		if stacq (permanent_scratch_segment.lock, scratch_lock_id, (36)"0"b) then do;
		     if permanent_scratch_segment.segment_ptr = null () then do;
			call get_temp_segment_ (COMMAND_PROCESSOR_, permanent_scratch_segment.segment_ptr, code);
			if code ^= 0 then go to RETURN_FROM_CP;
		     end;
		     permanent_scratch_segment.usage_count = permanent_scratch_segment.usage_count + 1;
		     segment_ptr = permanent_scratch_segment.segment_ptr;
		end;
	     end;

	     if segment_ptr = null () then do;		/* no permanent segments available */
		if temporary_scratch_segment_list.n_used = temporary_scratch_segment_list.n_allocated then do;
		     temporary_scratch_segment_list_n_allocated = 2 * temporary_scratch_segment_list.n_allocated;
		     old_temporary_scratch_segment_list_ptr = temporary_scratch_segment_list_ptr;
		     allocate temporary_scratch_segment_list in (system_area)
			set (new_temporary_scratch_segment_list_ptr);
		     new_temporary_scratch_segment_list_ptr -> temporary_scratch_segment_list.n_used =
			old_temporary_scratch_segment_list_ptr -> temporary_scratch_segment_list.n_used;
		     new_temporary_scratch_segment_list_ptr -> temporary_scratch_segment_list.segment_ptrs (*) =
			null ();
		     do idx = 1 to old_temporary_scratch_segment_list_ptr -> temporary_scratch_segment_list.n_used;
			new_temporary_scratch_segment_list_ptr
			     -> temporary_scratch_segment_list.segment_ptrs (idx) =
			     old_temporary_scratch_segment_list_ptr
			     -> temporary_scratch_segment_list.segment_ptrs (idx);
		     end;
		     temporary_scratch_segment_list_ptr = new_temporary_scratch_segment_list_ptr;
		     if old_temporary_scratch_segment_list_ptr ^= addr (local_temporary_scratch_segment_list) then
			free old_temporary_scratch_segment_list_ptr
			     -> temporary_scratch_segment_list in (system_area);
		end;
		temporary_scratch_segment_list.n_used, idx = temporary_scratch_segment_list.n_used + 1;
		call get_temp_segment_ (COMMAND_PROCESSOR_, temporary_scratch_segment_list.segment_ptrs (idx), code);
		if code ^= 0 then go to RETURN_FROM_CP;
		segment_ptr = temporary_scratch_segment_list.segment_ptrs (idx);
	     end;

	     return (segment_ptr);

	end select_scratch_segment;



/* Release any temporary scratch segments and mark all "permanent" segments selected by this invocation as available */

release_scratch_segments:
	procedure (p_last_call);

dcl  p_last_call bit (1) aligned parameter;

dcl  1 permanent_scratch_segment like permanent_scratch_segment_list.scratch_segments aligned
	based (permanent_scratch_segment_ptr);
dcl  permanent_scratch_segment_ptr pointer;
dcl  idx fixed binary;

	     do idx = 1 to permanent_scratch_segment_list.n_scratch_segments;
		permanent_scratch_segment_ptr = addr (permanent_scratch_segment_list.scratch_segments (idx));
		if permanent_scratch_segment.lock = scratch_lock_id then do;
		     if mod (permanent_scratch_segment.usage_count, cp_data_$scratch_release_factor) = 0 then do;
			call release_temp_segment_ (COMMAND_PROCESSOR_, permanent_scratch_segment.segment_ptr,
			     ignore_code);
			permanent_scratch_segment.usage_count = 0;
		     end;
		     if stacq (permanent_scratch_segment.lock, (36)"0"b, scratch_lock_id) then ;
		end;				/* mark it as available */
	     end;

	     if temporary_scratch_segment_list_ptr ^= null () then
		if temporary_scratch_segment_list.n_used > 0 then do;
		     call release_temp_segments_ (COMMAND_PROCESSOR_, temporary_scratch_segment_list.segment_ptrs (*),
			ignore_code);
		     temporary_scratch_segment_list.n_used = 0;
		     if temporary_scratch_segment_list_ptr ^= addr (local_temporary_scratch_segment_list) then do;
			free temporary_scratch_segment_list in (system_area);
			temporary_scratch_segment_list_ptr = null ();
		     end;
		end;

	     if ^p_last_call then			/* setup for the next top-level command/request */
		call initialize_scratch_segments ("0"b);

	     return;

	end release_scratch_segments;
%page;
/* Free all allocated node_blocks */

free_nodes:
	procedure (p_last_call);

dcl  p_last_call bit (1) aligned parameter;

	     last_block_ptr = addr (stack_space) -> node_block.next;
	     if last_block_ptr ^= null () then do;
		do block_ptr = last_block_ptr -> node_block.next repeat (block_ptr -> node_block.next)
		     while (block_ptr ^= null ());
		     free last_block_ptr -> node_block in (system_area);
		     last_block_ptr = block_ptr;
		end;
		free last_block_ptr -> node_block in (system_area);
	     end;

	     if p_last_call then			/* prevent attempts to free when nothing to free */
		addr (stack_space) -> node_block.next = null ();
	     else do;				/* still have work to do */
		block_ptr = addr (stack_space);
		unspec (node_block) = "0"b;
		node_block.next = null ();
		node_index = 0;
		addr (dummy_node) -> node.next = null ();
	     end;

	end free_nodes;

     end complex_command_processor;
%page;
/* Validates a subsystem's request language definition and builds the necessary TCT tables used in make_list above */

validate_cp_subsys_info:
     entry (P_cp_subsys_info_ptr, P_code);

	call validate_request_language (P_cp_subsys_info_ptr, P_code);
						/* use an internal procedure to avoid wasting stack space */
	return;


/* Internal procedure that does the actual work */

validate_request_language:
     procedure (p_cp_subsys_info_ptr, p_code) options (non_quick);

dcl  p_cp_subsys_info_ptr pointer parameter;
dcl  p_code fixed binary (35) parameter;

dcl  1 full_language like cp_data_$standard_language aligned based (addr (cp_subsys_info.full_tct_table));
dcl  1 token_language like cp_data_$standard_language aligned based (addr (cp_subsys_info.tokens_only_tct_table));

dcl  (begin_iterations, end_iterations, begin_active_strings, end_active_strings) bit (8);
dcl  (processing_type, idx) fixed binary;

	cp_subsys_info_ptr = p_cp_subsys_info_ptr;

	if cp_subsys_info.version ^= CP_SUBSYS_INFO_VERSION_1 then do;
	     p_code = error_table_$unimplemented_version;
	     return;
	end;

	if ^cp_subsys_info.non_standard_language then do;
	     p_code = 0;				/* subsystem uses the standard language which is always OK */
	     return;
	end;

	if unspec (cp_subsys_info.full_tct_table) = unspec (cp_data_$standard_language) then do;
	     cp_subsys_info.non_standard_language = "0"b;
	     p_code = 0;				/* it is the standard language after all */
	     return;
	end;

	begin_iterations, end_iterations, begin_active_strings, end_active_strings = ""b;

	do idx = lbound (full_language.character_types, 1) to hbound (full_language.character_types, 1);
	     processing_type = full_language.character_types (idx);

	     if (processing_type < NORMAL_CHARACTER)
		| ((processing_type > ACTIVE_STRING_MODIFIER) & (processing_type < BEGIN_ITERATION_1))
		| (processing_type > END_ACTIVE_STRING_8) then do;
		p_code = error_table_$bad_subr_arg;
		return;				/* unknown processing type specified */
	     end;

	     if (processing_type = WHITESPACE) | (processing_type = QUOTE_CHARACTER) then
		token_language.character_types (idx) = processing_type;
	     else if (processing_type = COMMAND_SEPARATOR_OR_WHITESPACE) then
		token_language.character_types (idx) = WHITESPACE;
	     else token_language.character_types (idx) = NORMAL_CHARACTER;

	     if (processing_type >= BEGIN_ITERATION_1) & (processing_type <= BEGIN_ITERATION_8) then
		substr (begin_iterations, (processing_type - BEGIN_ITERATION_1 + 1), 1) = "1"b;
	     if (processing_type >= END_ITERATION_1) & (processing_type <= END_ITERATION_8) then
		substr (end_iterations, (processing_type - END_ITERATION_1 + 1), 1) = "1"b;

	     if (processing_type >= BEGIN_ACTIVE_STRING_1) & (processing_type <= BEGIN_ACTIVE_STRING_8) then
		substr (begin_active_strings, (processing_type - BEGIN_ACTIVE_STRING_1 + 1), 1) = "1"b;
	     if (processing_type >= END_ACTIVE_STRING_1) & (processing_type <= END_ACTIVE_STRING_8) then
		substr (end_active_strings, (processing_type - END_ACTIVE_STRING_1 + 1), 1) = "1"b;
	end;

	if begin_iterations ^= end_iterations then p_code = error_table_$unbalanced_parentheses;

	else if begin_active_strings ^= end_active_strings then p_code = error_table_$unbalanced_brackets;

	else p_code = 0;				/* every begin/end iteration/active string has a match */

	return;

     end validate_request_language;
%page;
/* Enable the Limited Service Subsystem */

setup_lss:
     entry (P_table_ptr);

dcl  P_table_ptr pointer parameter;

	cp_data_$under_lss = "1"b;
	cp_data_$command_table_ptr = P_table_ptr;
	return;



/* Disable the Limited Service Subsystem */

reset_lss:
     entry ();

	cp_data_$under_lss = "0"b;
	return;



/* Obsolete entry points */

set_line:
     entry (P_newsize);

dcl  P_newsize fixed binary (21) parameter;

	call com_err_ (0, "command_processor_$set_line",
	     "There is no restriction on command line expansion.  Call ignored.");

	return;


get_line:
     entry (P_newsize);

	call com_err_ (0, "command_processor_$get_line", "There is no restriction on command line expansion.");

	P_newsize = MIN_AF_RETURN_LTH;

	return;
%page;
%include check_star_name;
%page;
%include cp_data_;
%page;
%include cp_character_types;

%include cp_active_string_types;

%include "_cp_subsys_info";
%page;
%include sub_err_flags;
     end command_processor_;
