
/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/* The hierarchy reloader/retriever */

/* Created:  February 1969 by R. C. Daley. */
/* Modified: 16 June 1970 by R. H. Campbell */
/* Modified: 21 October 1970 by R. J. Feiertag */
/* Modified: 10 May 1971 by R. A. Tilden */
/* Modified: 11 Nov 1973 by E. Stone to allow selected users to use 256K segs */
/* Modified: 22 July 1974 by R. E. Mullen for sec_seg + sec_dir types */
/* Modified: 21 October 1974 by A. Kobziar to handle access_mode field */
/* Modified: February 1975 by R. E. Mullen for tape, cpu, and paging speedups */
/* Modified: July 1975 by R. Bratt for new KST cleanup scheme, to burn our bridges behind us, to cleanup, and to fix an
   IACL reloading bug */
/* Modified: Autumn 1975 by R. E. Mullen to retune for NSS by not calling status_long for access_mode and to not set max
   length and entrybound when already set by create_branch_ */
/* Modified: February 1976 by R. Bratt to improve KST cleanup */
/* Modified: May 1976 by R. Bratt to handle deleted PVs */
/* Modified: September 1976 by R. Bratt to not do KST cleanup ditty */
/* Modified: 2 November 1977 by S. Herbst to add backup_load_ entry point */
/* Modified: 3 August 1979 by S. Herbst to add -trim and fix bugs */
/* Modified: 17 July 1980 by S. Herbst to test for phcs_ and hphcs_ access */
/* Modified: 6 November 1980 by G. Palter for version 3 backup_control structure */
/* Modified: 8 January 1981 by G.  Palter to fix a bug which prevented reloading all entries in a directory which already
   existed online if the reloading process didn't already have "sma" access on the directory */
/* Modified: December 1981 by C. Hornig to remove calls to hphcs_$set_dir_size */
/* Modified: 21 January 1982 by S. Herbst to test for access to system_privilege_ in addition to phcs_ and hphcs_ */
/* Modified: 5 February 1982 by S. Herbst to retrieve an entire MSF without haing to specify ">**" */
/* Modified: 23 March 1982 by S. Herbst to omit date comparision on second pass for directories */
/* Modified: May 1982 by Benson I. Margulies to do ACLs straight forwardly */
/* Modified: July 1982 by G. Palter to add features for IMFT support of AIM: enforce a minimum ring for all created
   branches, restore the access class of the branch even if in debug mode, and translate access classes between systems */
/* BIM: 10/82: removed acl printing */
/* BIM: 2/83: Consider status_for_backup version 0 equivalent to 2 to */
/* clean up after hardcore bug in 10.0 */
/* Modified February 1983, E. N. Kittlitz. 256K segments */
/* Modified 1985-03-21, BIM: fixed prehistoric busted condition handler.
   -------- -- Fixed not to force access in no-reload mode.
   phx18650 -- does not reset transparency switches.
   phx17329 -- mishandling empty acls.
   phx17310 -- unitialized variables in cross-dumping.
   phx16651 -- rqovers on the map do not always get to level 2.
   phx13714 -- catching command_error conditions */

/****^  HISTORY COMMENTS:
  1) change(87-07-15,GDixon), approve(87-07-15,MCR7617),
     audit(87-07-16,RBarstad), install(87-07-16,MR12.1-1041):
     Modified for change to backup_record_types.incl.pl1.
  2) change(88-05-11,Lippard), approve(88-05-02,MCR7881),
     audit(88-06-15,Fawcett), install(88-08-02,MR12.2-1074):
     Changed to add reloading of the audit_flag attribute. This changed the
     reload_set_version to 2.
                                                   END HISTORY COMMENTS */

/* format: style4,delnl,insnl,ifthenstmt,ifthen */


backup_load:
     procedure ();

dcl  (i, n, hcnt, scnt, type, htype) fixed bin,		/* temporary storage */
     (old_trans_sw, sys_type, ts) fixed bin (2),		/* Save previous settings of transparent switches. */
     bc fixed bin,					/* Segment bit count. */
     dtd_test bit (36) aligned,			/* time from  backup to test for later copy */
     (dtp, dtd, dtu, dtem, dtsm) fixed bin (52),		/* Storage for various times. */
     (np, ap, segptr, bp, aclp, ix) ptr,
     pp ptr,					/* Use in an incl file. */
     dump_date char (24),				/* Storage for conversion of time record written. */
     ring fixed bin (3),				/* ring number for reloading initial ACLs */
     old_dname char (168) varying init (""),		/* Previous directory name. */
     new_dir bit (1) aligned init ("1"b),		/* set if name header needs printing */
     optionsw fixed bin (2),				/* Copy of option switch. */
     save_ename char (32) aligned,			/* real pri name of reloaded seg */
     save_elen fixed bin,
     MRS fixed bin init (0),				/* if nonzero must read seg still */
     FRS fixed bin init (0),				/* if nonzero reload directly to target seg, else pdir */
     INITIALIZER bit (1) aligned init ("0"b),		/* "1"b => user has total access */
     hs_dirname char (168) varying aligned init (""),	/* last dir for which HAVE_SMA was called */
     hs_bit bit (1) init ("0"b),			/* result of HAVE_SMA call */
     USERID char (32),				/* used by HAVE_SMA intl proc */
     access_class bit (72) aligned,			/* access class of branch */
     (a_code, dir_priv_code, code) fixed bin (35),
     control_ptr ptr,				/* ptr to control structure for backup_load_ */
     octal_string character (32) aligned,
     dirname_dirname character (168),
     dirname_ename character (32);
dcl  old_256K_switch bit (2) aligned;

dcl  (cleanup, record_quota_overflow) condition;

dcl  label_index fixed bin;

dcl  temp_dir char (168) aligned,			/* TEMPORARY CODE */
     temp_entry char (32) aligned,			/* TEMPORARY CODE */
     temp_length fixed bin;				/* TEMPORARY CODE */


dcl  stptr ptr;					/* pointer to status_long return area */
dcl  1 status aligned,				/* status long return area */
       (
       2 type bit (2),
       2 nnames bit (16),
       2 nrp bit (18),
       2 dtm bit (36),
       2 dtu bit (36),
       2 mode bit (5),
       2 padding bit (13),
       2 records bit (18),
       2 dtd bit (36),
       2 dtem bit (36),
       2 acct bit (36),
       2 curlen bit (12),
       2 bitcnt bit (24),
       2 did bit (4),
       2 mdid bit (4),
       2 copysw bit (1),
       2 pad2 bit (9),
       2 rbs (0:2) bit (6),
       2 uid bit (36)
       ) unaligned;

dcl  1 inacl_info aligned,
       2 sia_relp (0:7) bit (18),
       2 sia_count (0:7) fixed bin,
       2 dia_relp (0:7) bit (18),
       2 dia_count (0:7) fixed bin;


dcl  rings (3) fixed bin (3);				/* Ring brackets for non directory segments */

dcl  reload_init bit (1) static initial ("1"b);		/* Internal static. */

dcl  line char (300) static,				/* Output line(s) buffer. */
     line_pointer ptr static,				/* Pointer to line buffer. */
     (hp, seg_buff) ptr static;

dcl  (phcs_sw, hphcs_sw, system_priv_sw) bit (1) init ("0"b);
						/* for testing access to gates */
dcl  text char (32) varying;

dcl  (
     error_table_$namedup,
     error_table_$noentry,
     error_table_$pvid_not_found,
     error_table_$vtoce_connection_fail,
     error_table_$moderr,
     error_table_$no_dir,
     error_table_$no_info,
     error_table_$no_e_permission,
     error_table_$incorrect_access,
     error_table_$rqover
     ) ext fixed bin (35);

dcl  sys_info$access_class_ceiling ext bit (72) aligned;
dcl  sys_info$default_max_length ext fixed bin (35);
dcl  sys_info$seg_size_256K fixed bin (19) ext;

dcl  linkage_error condition;

dcl  (addr, bit, clock, divide, fixed, max, min, null, pointer, substr, unspec, verify) builtin;

dcl  test_entry entry variable;

dcl  backup_control_mgr_$initiate entry (pointer, fixed binary (35)),
     backup_control_mgr_$terminate entry (pointer),
     backup_load_dir_list$build_tree
	entry (char (168) aligned, char (*) aligned, fixed bin, fixed bin (24), fixed bin (2), char (*) aligned,
	bit (72) aligned, fixed bin (35)),
     backup_load_dir_list entry (ptr, fixed bin (35)),
     backup_map_$name_line entry (ptr, fixed bin (21)),
     backup_map_$beginning_line entry (fixed bin (52), ptr, fixed bin),
     backup_map_$detail_line2
	entry (char (32) aligned, fixed bin (9), char (10) aligned, fixed bin (52), fixed bin (52), fixed bin (52),
	fixed bin (52), fixed bin (52)),
     (
     backup_map_$directory_line,
     backup_map_$on_line
     ) entry (ptr, fixed bin),
     backup_map_$error_line entry () options (variable),
     backup_map_$fs_error_line entry (fixed bin (35), char (*) aligned, char (*) aligned, char (*) aligned),
     backup_map_$terminal_line entry (fixed bin (52), fixed bin (35)),
     backup_util$add_names entry (char (168) aligned, char (32) aligned, ptr, fixed bin, bit (1)),
     backup_util$delete_name entry (char (168) aligned, char (32) aligned, fixed bin (35)),
     backup_util$give_access entry (char (168) aligned, char (32) aligned, fixed bin (35)),
     backup_util$idline entry (char (*), char (*), ptr, fixed bin),
     bk_input$input_init entry (fixed bin (35)),
     bk_input$rd_tape entry (ptr, fixed bin, ptr, fixed bin, fixed bin (35)),
     bk_retrieve$check_retrieval ext entry (fixed bin),
     bk_retrieve$flag_msf entry (fixed bin),
     bk_retrieve$parse_retrieval_control ext entry (char (168), fixed bin, ptr, fixed bin),
     bk_retrieve$parse_structure entry (ptr, fixed bin),
     bk_retrieve$report_retrieval ext entry,
     convert_aim_attributes_ entry (bit (72) aligned, character (32) aligned),
     cu_$arg_count entry (fixed bin),
     cu_$arg_list_ptr entry (ptr),
     cu_$level_get entry returns (fixed bin (3)),
     hcs_$set_256K_switch entry (bit (2) aligned, bit (2) aligned, fixed bin (35)),
     hcs_$proc_info entry (bit (36) aligned, char (32), char (32), bit (36) aligned),
     bk_arg_reader_$reload_arg_reader entry (fixed bin, ptr, fixed bin (35)),
     date_time_ entry (fixed bin (52), char (*)),
     unique_chars_ entry (bit (*) aligned) returns (char (15) aligned),
     expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));

dcl  hphcs_$set_for_reloader entry (char (*) aligned, char (*) aligned, ptr, fixed bin (35)),
     hphcs_$delentry_file entry (char (*) aligned, char (*) aligned, fixed bin (35)),
     hcs_$set_copysw entry (char (*) aligned, char (*) aligned, bit (1) aligned, fixed bin (35)),
     hcs_$set_entry_bound entry (char (*) aligned, char (*) aligned, fixed bin (14), fixed bin (35)),
     hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35)),
     hcs_$chname_file entry (char (*) aligned, char (*) aligned, char (*) aligned, char (*) aligned, fixed bin (35)),
     hcs_$list_inacl_all entry (char (*) aligned, ptr, ptr, ptr, fixed bin (35)),
     hcs_$set_max_length entry (char (*), char (*), fixed bin (19), fixed bin (35)),
     phcs_$set_max_length entry (char (*) aligned, char (*) aligned, fixed bin (19), fixed bin (35)),
						/* TEMPORARY CODE */
     hcs_$fs_get_path_name entry (ptr, char (*) aligned, fixed bin, char (*) aligned, fixed bin (35)),
						/* TEMPORARY CODE */
     hcs_$set_max_length_seg entry (ptr, fixed bin (19), fixed bin (35)),
     hcs_$set_safety_sw entry (char (*) aligned, char (*) aligned, bit (1), fixed bin (35)),
     (
     hcs_$replace_acl,
     hcs_$replace_dir_acl
     ) entry (char (*) aligned, char (*) aligned, ptr, fixed bin, bit (1), fixed bin (35)),
     (
     hcs_$replace_inacl,
     hcs_$replace_dir_inacl
     ) entry (char (*) aligned, char (*) aligned, ptr, fixed bin, bit (1), fixed bin (3), fixed bin (35)),
     (
     hcs_$set_ring_brackets,
     hcs_$set_dir_ring_brackets
     ) entry (char (*) aligned, char (*) aligned, (3) fixed bin (3), fixed bin (35)),
     hcs_$status_minf entry (char (*) aligned, char (*) aligned, fixed bin (1), fixed bin (2), fixed bin, fixed bin (35)),
     hcs_$get_user_effmode entry (char (*), char (*), char (*), fixed bin (5), fixed bin (5), fixed bin (35)),
     hcs_$status_long entry (char (*) aligned, char (*) aligned, fixed bin (1), ptr, ptr, fixed bin (35)),
     hcs_$terminate_noname entry (ptr, fixed bin (35)),
     hcs_$truncate_seg entry (ptr, fixed bin, fixed bin (35)),
     hcs_$initiate
	entry (char (*) aligned, char (*) aligned, char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35)),
     pathname_ entry (character (*), character (*)) returns (character (168)),
     system_privilege_$dir_priv_off entry (fixed binary (35)),
     system_privilege_$dir_priv_on entry (fixed binary (35)),
     system_privilege_$initiate
	entry (char (*) aligned, char (*) aligned, char (*), fixed bin, fixed bin (2), ptr, fixed bin (35)),
     system_privilege_$set_entry_audit_switch
	entry (char (*), char (*), bit (1), fixed bin (35)),
     translate_aim_attributes_ entry (pointer, bit (72) aligned, pointer, bit (72) aligned, fixed binary (35));

dcl  (
     bk_input$input_finish,
     com_err_,
     ioa_$rsnnl,
     ioa_$rs,
     hphcs_$suspend_quota,
     hphcs_$restore_quota
     ) external entry options (variable);

dcl  hphcs_$fs_get_trans_sw entry (fixed bin (2), fixed bin (2));

dcl  mover (scnt) based;				/* To move words into new segment */
dcl  call_limiter fixed bin (14);

/**/

%include backup_dir_list;
%page;
%include bk_ss_;
%page;
%include bk_nss_info;
%page;
%include reload_set_info;
%page;
%include backup_fs_times;
%page;
%include backup_control;
%page;
%include backup_preamble_header;
%page;
%include backup_record_types;

/**/
	bk_ss_$sub_entry = "0"b;

	if bk_ss_$myname = " " then bk_ss_$myname = "backup_load";
						/* set up name if called directly */

/*	read in arguments and set switches		*/

	call cu_$arg_count (i);			/* Get the number of input arguments */
	if i ^= 0 then do;				/* Don't bother if no args */
	     call cu_$arg_list_ptr (ap);		/* Get pointer to argument list */
	     call bk_arg_reader_$reload_arg_reader (1, ap, code);
						/* Do the work */
	     if code ^= 0 then do;			/* Uh Oh, Trouble */
		call com_err_ (code, "backup_load", "");
		return;
	     end;
	end;
	if ^bk_ss_$debugsw then do;			/* check phcs_ and hphcs_ access */
	     phcs_sw, hphcs_sw = "0"b;
	     on linkage_error
		begin;
		phcs_sw = "1"b;
		go to TRY2;
	     end;
	     test_entry = phcs_$set_max_length;		/* test access to phcs_ gate */
TRY2:
	     on linkage_error
		begin;
		hphcs_sw = "1"b;
		go to TRY3;
	     end;
	     test_entry = hphcs_$delentry_file;		/* test access to hphcs_ gate */
TRY3:
	     on linkage_error
		begin;
		system_priv_sw = "1"b;
		go to TRY4;
	     end;
	     test_entry = system_privilege_$initiate;	/* test access to system_privilege_ gate */
TRY4:
	     revert linkage_error;
	     if phcs_sw | hphcs_sw | system_priv_sw then do;
		text = "";
		call com_err_ (error_table_$moderr, bk_ss_$myname, "^[phcs_ ^]^[hphcs_ ^]^[system_privilege_^]
Use -debug control argument to avoid calling privileged gates.", phcs_sw, hphcs_sw, system_priv_sw);
		go to RETURN;
	     end;
	end;
	old_256K_switch = ""b;			/* initialize for cleanup */
	on cleanup
	     begin;
	     call hcs_$set_256K_switch (old_256K_switch, (""b), (0));
	end;
	go to COMMON;


backup_load_:
     entry (control_ptr, a_code);

	bk_ss_$sub_entry = "1"b;
	a_code = 0;

	call backup_control_mgr_$initiate (control_ptr, a_code);
	if a_code ^= 0 then return;

	dir_priv_code = -1;				/* for cleanup handler */
	old_256K_switch = ""b;			/* ditto */
	on condition (cleanup)
	     begin;
	     if dir_priv_code = 0 then call system_privilege_$dir_priv_off ((0));
	     call hcs_$set_256K_switch (old_256K_switch, (""b), (0));
	     call backup_control_mgr_$terminate (control_ptr);
	end;

	if bk_ss_$control_ptr -> backup_control.debug_sw then do;
	     bk_ss_$debugsw = "1"b;
	     bk_ss_$trimsw = "0"b;
	end;
	else bk_ss_$debugsw = "0"b;

	bk_ss_$mapsw = bk_ss_$control_ptr -> backup_control.map_sw;
	bk_ss_$no_reload = bk_ss_$control_ptr -> backup_control.no_reload_sw;
	bk_ss_$holdsw = bk_ss_$control_ptr -> backup_control.hold_sw;
	bk_ss_$allow_dir_overwrite = bk_ss_$control_ptr -> backup_control.allow_dir_overwrite;
	bk_ss_$preattached = bk_ss_$control_ptr -> backup_control.preattached;
	if bk_ss_$preattached then bk_ss_$data_iocb = bk_ss_$control_ptr -> backup_control.data_iocb;
	bk_ss_$sub_entry_errfile = bk_ss_$control_ptr -> backup_control.error_file;
	bk_ss_$onlysw = bk_ss_$control_ptr -> backup_control.first;

	bk_ss_$restore_access_class = bk_ss_$control_ptr -> backup_control.restore_access_class;
	if bk_ss_$restore_access_class then do;		/* turn on directory privilege */
	     on condition (linkage_error)
		begin;
		a_code = error_table_$moderr;
		go to RETURN;
	     end;
	     call system_privilege_$dir_priv_on (dir_priv_code);
	     if (dir_priv_code ^= 0) & (dir_priv_code ^= 1) then do;
		a_code = code;			/* couldn't get it */
		go to RETURN;
	     end;
	     revert condition (linkage_error);
	end;

	bk_ss_$enforce_minimum_ring = bk_ss_$control_ptr -> backup_control.enforce_minimum_ring;
	if bk_ss_$enforce_minimum_ring then bk_ss_$minimum_ring = bk_ss_$control_ptr -> backup_control.minimum_ring;

	bk_ss_$translate_access_class = bk_ss_$control_ptr -> backup_control.translate_access_class;
	if bk_ss_$translate_access_class then do;
	     bk_ss_$source_attributes_ptr = bk_ss_$control_ptr -> backup_control.source_attributes_ptr;
	     bk_ss_$target_attributes_ptr = bk_ss_$control_ptr -> backup_control.target_attributes_ptr;
	end;

	do i = 1 to bk_ss_$control_ptr -> backup_control.request_count;
	     if verify (bk_ss_$control_ptr -> backup_control.new_path (i), " ") = 0 then
		bk_ss_$control_ptr -> backup_control.new_path (i) = "";
						/* can't have new pathname all zeros */
	     bk_ss_$control_ptr -> backup_control.found (i) = "0"b;
	     bk_ss_$control_ptr -> backup_control.loaded (i) = "0"b;
	     bk_ss_$control_ptr -> backup_control.status_code (i) = 0;
	     bk_ss_$control_ptr -> backup_control.error_name = "";
	end;

	bk_ss_$qchecksw = "1"b;

	if bk_ss_$control_ptr -> backup_control.request_count = 0 then
	     bk_ss_$retrievesw = "0"b;
	else bk_ss_$retrievesw = "1"b;

	bk_ss_$myname = "backup_load_";

COMMON:
	call hcs_$set_256K_switch ("11"b, old_256K_switch, code);
						/* enable 256K connnections, ignore code */
	if reload_init then do;
	     call hcs_$make_seg ("", "reload_preamble", "", 01011b, hp, code);
	     call hcs_$make_seg ("", "reload_temp", "", 01011b, seg_buff, code);
						/* Make segment buffer. */
						/* THE FOLLOWING TWELVE LINES SHOULD BE REMOVED WHEN 256K SEGMENTS ARE INSTALLED. */
	     if ^bk_ss_$debugsw then do;		/* TEMPORARY CODE */
		call hcs_$fs_get_path_name (seg_buff, temp_dir, temp_length, temp_entry, code);
						/* TEMPORARY CODE */
		on linkage_error
		     begin;
		     if bk_ss_$sub_entry then
			call backup_map_$fs_error_line (error_table_$no_e_permission, (bk_ss_$myname), ">sl1",
			     "phcs_$set_max_length");
		     else call com_err_ (error_table_$no_e_permission, bk_ss_$myname,
			     ">sl1>phcs_$set_max_length^/Use -debug control argument.");
		     go to RETURN;
		end;
		call phcs_$set_max_length (temp_dir, temp_entry, sys_info$seg_size_256K, code);
						/* TEMPORARY CODE */
		revert linkage_error;
	     end;					/* TEMPORARY CODE */

	     call hcs_$set_max_length_seg (seg_buff, sys_info$seg_size_256K, code);
	     line_pointer = addr (line);		/* Set up pointer to line buffer. */
	     reload_init = ""b;
	end;

start:
	if bk_ss_$retrievesw then do;			/* Is this a retrieval */
	     if bk_ss_$sub_entry then
		call bk_retrieve$parse_structure (hp, label_index);
	     else call bk_retrieve$parse_retrieval_control (bk_ss_$rname, bk_ss_$rsize, hp, label_index);
						/* pass retrieve seg name */
						/* and preamble seg pointer for init */
	     go to loc_label (label_index);		/* go to appropriate place on return */
	end;

loc_label (1):
parsed:
	if ^bk_ss_$debugsw then do;			/* Check if this can be done. */
	     if ^bk_ss_$qchecksw then			/* Now check if it should be done */
		call hphcs_$suspend_quota;		/* Disable quota-checking. */
	     call hphcs_$fs_get_trans_sw (11b, old_trans_sw);
						/* Set transparent usage, modification switches. */
	     if (bk_ss_$myname = "reload") | (bk_ss_$myname = "iload") then do;
		if ^bk_ss_$qchecksw then
		     if ^bk_ss_$no_reload then FRS = 1; /* reload to target diectly */
	     end;
	end;
	call hcs_$proc_info ((""b), USERID, (""), (""b)); /* pid, pdir, lockid not needed */
	if USERID = "Initializer.SysDaemon.z" then INITIALIZER = "1"b;
	call bk_input$input_init (code);		/* initialize tape read package */
	if code ^= 0 then do;
	     call backup_map_$fs_error_line (code, "backup_load", "bk_input$input_init", "");
	     if bk_ss_$sub_entry then a_code = code;
	     go to terminate;			/* Give up. */
	end;
	n = 0;					/* set length of id line */
	if bk_ss_$mapsw then			/* Are we preparing a map listing? */
						/* Format id line */
	     call backup_util$idline (substr (bk_ss_$rname, 1, bk_ss_$rsize), "5 May 1982.", line_pointer, n);

	stptr = addr (status);			/* get pointer to status_long return structure */

	dtp = clock;				/* Get starting time. */
	call backup_map_$beginning_line (dtp, line_pointer, n);
						/* Begin reload. */


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * Main Processing Loop */


loc_label (2):
next:						/* get first of next logical record */
	if MRS ^= 0 then do;			/* must complete read of last seg */
	     call bk_input$rd_tape (null (), (0), seg_buff, scnt, code);
	     if code = 2 then code = 0;		/* ok if run onto new tape */
	     if code ^= 0 then go to TAPE_DONE;
	     call hcs_$truncate_seg (seg_buff, 0, (code));/* throw away data */
	     MRS = 0;				/* done with flushing read */
	end;

	if FRS = 0 then do;
	     call bk_input$rd_tape (hp, hcnt, seg_buff, scnt, code);
						/* read hdr, read seg to pdir */
	end;
	else do;					/* read hdr only, seg to pdir later */
	     call bk_input$rd_tape (hp, hcnt, null (), scnt, code);
						/* just header */
	     if scnt > 0 then MRS = 1;		/* remember to read seg later */
	end;


TAPE_DONE:
	if code ^= 0 then do;			/* check for end of last reload tape */
	     if code = 1 then code = 0;		/* Is this the end of the last tape? */
	     if bk_ss_$sub_entry then a_code = code;

/*	finish up and quit */

loc_label (3):
stop:
	     call bk_input$input_finish;		/* if done, clean up i/o */
loc_label (4):
terminate:
	     if bk_ss_$retrievesw then call bk_retrieve$report_retrieval;
						/* Report if doing a retrieval. */
loc_label (5):
reported:
	     if ^bk_ss_$debugsw then do;		/* Is this a real run? */
		if ^bk_ss_$qchecksw then		/* Should we restore quota checking? */
		     call hphcs_$restore_quota;	/* Enable quota-checking. */
		call hphcs_$fs_get_trans_sw (old_trans_sw, ts);
						/* Restore switch settings. */
	     end;
	     dtp = clock;				/* Get stopping time. */
	     call backup_map_$terminal_line (dtp, code);	/* Type normal or abnormal termination comment. */
	     call hcs_$truncate_seg (hp, 0, code);	/* Clean up the buffer segments. */
	     call hcs_$truncate_seg (seg_buff, 0, code);	/* .. */
	     if bk_ss_$myname = "backup_load" | bk_ss_$myname = "backup_load_" then bk_ss_$myname = " ";
						/* reset name if we set it */
RETURN:
	     call hcs_$set_256K_switch (old_256K_switch, (""b), (0));
	     if bk_ss_$sub_entry then do;
		if dir_priv_code = 0 then call system_privilege_$dir_priv_off ((0));
		call backup_control_mgr_$terminate (control_ptr);
	     end;
	     return;				/* end of job */
	end;					/* make check for physical volume recovery */
						/* and skip if pvnames don't match */
/**** CORRECT FOR BUG IN 10.0 WHERE status_version = 0 but SHOULD = 2. */

	if hp -> h.status_version = 0 then hp -> h.status_version = 2;

	if bk_ss_$pvsw & hp -> h.status_version >= 2 & hp -> h.nss_info_relp ^= "0"b then
	     if pointer (hp, hp -> h.nss_info_relp) -> bk_nss_info.pvname ^= bk_ss_$pvname then go to next;

	htype = hp -> h.record_type;			/* Pick up record type. */
	dtp = hp -> h.dtd;				/* pickup date and time record dumped */
	dtd_test = substr (bit (dtp, 52), 1, 36);	/* convert it to bit 36 for testing */

	call CHECK_FOR_NEW_DIRECTORY ();

	if bk_ss_$retrievesw then do;			/* If retrieval check for correct seg */
	     if bk_ss_$datesw			/* Has a comparison date been given? */
		then
		if dtp < bk_ss_$date then go to next;	/* Must be copy dumped on or after the given date */
	     call bk_retrieve$check_retrieval (label_index);
	     go to loc_label (label_index);		/* if match go to checked else to next */
	end;


	else if htype = ndc_directory_list then go to checked;
						/* 2nd pass for directory */

/*	On reload check dates to see if later version already present	*/

	else do;					/* Reload not retrieve */
	     if ^bk_ss_$no_reload then do;
get_dates:
		call hcs_$status_long (hp -> h.dname, hp -> h.ename, 0, stptr, null, code);
						/* get branch data */
		if code ^= 0 then
		     if code = error_table_$noentry then go to checked;
						/* New Segment */
		     else if code = error_table_$no_dir then go to checked;
						/* New segment in reload */
		     else if code = error_table_$moderr | code = error_table_$incorrect_access then do;
give_acc:
			call backup_util$give_access (hp -> h.dname, hp -> h.ename, code);
						/* Try to give ourselves access */
			if code ^= 0 then do;
			     call backup_map_$fs_error_line (code, "add_acl_entries backup_util$give_access",
				hp -> h.dname, hp -> h.ename);
			     go to next;
			end;
			else go to get_dates;	/* Go try again */
		     end;				/* end of easily recognizable errors */
		     else if ^bk_ss_$debugsw
			& (code = error_table_$pvid_not_found | code = error_table_$vtoce_connection_fail) then do;
			call hphcs_$delentry_file (hp -> h.dname, hp -> h.ename, code);
			if code = 0 then go to checked;
			if code = error_table_$moderr | code = error_table_$incorrect_access
			     | code = error_table_$no_info then
			     goto give_acc;
			call backup_map_$fs_error_line (code, "hphcs_$delentry_file", hp -> h.dname, hp -> h.ename);
			go to next;
		     end;

		     else do;			/* Strange error so give up */
			call backup_map_$fs_error_line (code, "hcs_$status_long", hp -> h.dname, hp -> h.ename);
			go to next;
		     end;

/*	Now actually check the dates		*/

		if dtd_test < status.dtm then		/* if dump earlier than seg in system */
		     if dtd_test < status.dtem then	/* and earlier than branch in system */
			if ^bk_ss_$ignore_dates then	/* and the system dates are not unmeaningless */
			     go to next;		/* then go get next */
	     end;					/* finished with date testing */
	end;

/*	Now start checking segment type on tape */

loc_label (6):
checked:
	type = 0;					/* Set up type for build_tree. */

	if (htype = ndc_directory | htype = ndc_directory_list | htype = sec_dir) & hp -> h.bitcnt ^= 0 then
						/* MSF */
	     call bk_retrieve$flag_msf (bk_ss_$retrieval_index);

	if bk_ss_$translate_access_class then do;	/* translate access class read from tape */
	     call translate_aim_attributes_ (bk_ss_$source_attributes_ptr, hp -> h.access_class,
		bk_ss_$target_attributes_ptr, access_class, code);
	     if code ^= 0 then do;
		call convert_aim_attributes_ (hp -> h.access_class, octal_string);
		call backup_map_$error_line (code, bk_ss_$myname, "Attempting to translate access class ^a for ^a.",
		     octal_string, pathname_ ((hp -> h.dname), (hp -> h.ename)));
		go to next;
	     end;
	     hp -> h.access_class = access_class;
	end;

	if htype = ndc_directory_list then do;		/* Is it the results of list_dir? */

/* Directory listing:  clean it out if "trim" was specified and reload the links */

do_directory_list:
	     type = 3;				/* Set up type code. */
	     optionsw = 0;				/* Set up option switch. */
	     call PRINT_HEADER ();

	     if (htype = ndc_directory_list) & ^bk_ss_$no_reload then
		if ^HAVE_SMA () then do;		/* force access so reload will work properly */
		     call expand_pathname_ ((hp -> h.dname), dirname_dirname, dirname_ename, (0));
						/* get it as two pieces */
		     call backup_util$give_access ((dirname_dirname), (dirname_ename), code);
		     if code ^= 0 then do;
			call backup_map_$fs_error_line (code, "backup_util$give_access", hp -> h.dname, "");
			go to next;		/* forget trying the rest: don't have sma on the dir */
		     end;
		end;

	     if bk_ss_$qchecksw then
		on record_quota_overflow
		     begin;
		     code = error_table_$rqover;
		     if bk_ss_$sub_entry then bk_ss_$control_ptr -> backup_control.loaded (bk_ss_$path_index) = "0"b;
		     call UNCREATE;
		     go to no_dir;
		end;
	     if bk_ss_$sub_entry then bk_ss_$trimsw = bk_ss_$control_ptr -> backup_control.trim_sw (bk_ss_$path_index);
	     call backup_load_dir_list (hp, code);	/* Go process the record. */
	     if bk_ss_$qchecksw then revert record_quota_overflow;
	     if code ^= 0 then do;			/* Comment if any errors. */
no_dir:
		call backup_map_$fs_error_line (code, "backup_load_dir_list", hp -> h.dname, "");
		go to next;
	     end;


/* Replace Initial ACL in as many rings as possible */

	     if (htype = ndc_directory_list) & ^bk_ss_$no_reload then do;
		unspec (inacl_info) = "0"b;		/* see if have to delete any existing ones */
		call hcs_$list_inacl_all (hp -> h.dname, null, null, addr (inacl_info), code);
		if code ^= 0 then do;
		     call backup_map_$fs_error_line (code, "hcs_$list_inacl_all", hp -> h.dname, "");
		     do ring = 0 to 7;		/* mark non zero to force setting */
			inacl_info.sia_count (ring) = 1;
			inacl_info.dia_count (ring) = 1;
		     end;
		end;

		do ring = cu_$level_get () to 7;	/* Replace all initial ACL's from this ring on up. */
		     if (hp -> h.inaclc (ring) > 0) | (inacl_info.sia_count (ring) > 0) then do;
			if hp -> h.inaclc (ring) = 0 then
			     aclp = null ();
			else aclp = pointer (hp, hp -> h.inaclp (ring));
						/* Get a pointer to initial ACL. */
			call hcs_$replace_inacl (hp -> h.dname, "", aclp, hp -> h.inaclc (ring), "1"b, ring, code);
			if code ^= 0 then		/* Replace the initial ACL. */
			     call backup_map_$fs_error_line (code, "hcs_$replace_inacl", hp -> h.dname, "");
		     end;

		     if (hp -> h.dir_inaclc (ring) > 0) | (inacl_info.dia_count (ring) > 0) then do;
			if hp -> h.inaclc (ring) = 0 then
			     aclp = null ();
			else aclp = pointer (hp, hp -> h.dir_inaclp (ring));
						/* Get a pointer to directory initial ACL. */
			call hcs_$replace_dir_inacl (hp -> h.dname, "", aclp, hp -> h.dir_inaclc (ring), "1"b, ring,
			     code);
			if code ^= 0 then		/* Replace the directory initial ACL. */
			     call backup_map_$fs_error_line (code, "hcs_$replace_dir_inacl", hp -> h.dname, "");
		     end;
		end;
	     end;

	     go to next;
	end;
	bp = pointer (hp, hp -> h.bp);		/* Get pointer to branch info. */
	np = pointer (hp, bp -> br (1).namerp);		/* Get pointer to name array. */
	optionsw = fixed (bp -> br (1).optionsw, 2);	/* Get option switch for call. */


/*	check for segment type record		*/

	if (htype = ndc_segment) | (htype = sec_seg) then go to load_it;
						/* Is the record of a complete segment? */


/*	check for directory type information in this record */

	if (htype = ndc_directory) | (htype = sec_dir) then do;
						/* Is it a directory's info? */
do_directory:
	     if bk_ss_$no_reload then go to load_it;
	     type = 2;				/* Set up type for build_tree. */

	     do i = 1 to fixed (bp -> br (1).nnames, 17); /* Examine each name. */
		ix = addr (np -> name (i));		/* Get pointer to this name element. */
		call hcs_$status_minf (hp -> h.dname, ix -> name (1).string, 0, sys_type, bc, code);
		if code ^= 0 then do;		/* Error detected? */
		     if code ^= error_table_$noentry then
						/* Entry missing, OK. */
			if code ^= error_table_$no_dir then
						/* Directory missing, OK. */
			     call backup_map_$fs_error_line (code, "status_minf in backup_load",
						/* Give comment. */
				hp -> h.dname, ix -> name (1).string);
		end;
		else if sys_type = 2 then do;		/* Entry exists, is it a directory? */


/*	See if a directory with a conflicting name exists.
   If so, then assume that it is the directory we are trying
   to reload so add all reload info (names acls etc.) to it. */

		     if i > 1 then do;		/* Ignore swap on first name. */
			np -> name (1).size = ix -> name (1).size;
						/* Replace first name with current one. */
			np -> name (1).string = ix -> name (1).string;
						/* .. */
			ix -> name (1).size = bit (hp -> h.elen, 17);
						/* Replace name with (first) name in header. */
			ix -> name (1).string = hp -> h.ename;
						/* .. */
			hp -> h.elen = fixed (np -> name (1).size, 17);
						/* Replace name in header with this one. */
			hp -> h.ename = np -> name (1).string;
						/* .. */
		     end;
		     go to load_it;			/* Go do normal processing. */
		end;
	     end;
	     go to load_it;				/* Go load the info. */
	end;
	call date_time_ (dtp, dump_date);		/* Convert the dump date. */
	call ioa_$rs ("Unrecognized record type ^d written ^a by ^a:^/^a>^a^/", line, n, htype, dump_date,
	     hp -> h.dumper_id, hp -> h.dname, hp -> h.ename);
	call backup_map_$on_line (line_pointer, n);
	go to next;				/* Go try the next record. */


/* * * * * * * * * * * * * * * * * * * * * Make entry for this segment or link. */


load_it:
	if MRS ^= 0 then do;			/* seg reload direct to target */
	     if ^(HAVE_SMA ()) then do;		/* dont dare */
		call bk_input$rd_tape (null (), (0), seg_buff, scnt, code);
		MRS = 0;
		if code ^= 0 then do;
		     if code = 2 then code = 0;
		     if code = 0 then
			go to next;
		     else go to TAPE_DONE;
		end;
	     end;
	     else do;
		save_ename = hp -> h.ename;		/* save real pri name */
		save_elen = hp -> h.elen;		/* and its length */
		hp -> h.ename = unique_chars_ (""b) || substr (save_ename, 1, 17);
						/* make funny name */
		hp -> h.elen = min (32, 15 + save_elen);
	     end;
	end;

	if (htype = sec_seg) | (htype = sec_dir) then do;
	     access_class = hp -> h.access_class;
	     if (access_class & (^sys_info$access_class_ceiling)) ^= "0"b then go to set_ac;
						/* pre AIM */
	     if htype = sec_seg then do;
		if hp -> h.switches.multiple_class then type = 4;
						/* a upgraded segment */
	     end;
	     else do;
		if hp -> h.switches.multiple_class then type = 5;
						/* a upgraded directory */
	     end;
	end;
	else do;
set_ac:
	     access_class = "0"b;			/* old branch */
	end;
	if bk_ss_$sub_entry then bk_ss_$trimsw = bk_ss_$control_ptr -> backup_control.trim_sw (bk_ss_$path_index);
	bk_ss_$hp = hp;
	call backup_load_dir_list$build_tree (hp -> h.dname, hp -> h.ename, type, hp -> h.bitcnt, optionsw, "",
	     access_class, code);
	if code ^= 0 then do;
	     call backup_map_$fs_error_line (code, "build_tree", hp -> h.dname, hp -> h.ename);
	     if bk_ss_$sub_entry then bk_ss_$control_ptr -> backup_control.loaded (bk_ss_$path_index) = "0"b;
	     go to next;				/* and go get next logical record */
	end;

	else if bk_ss_$sub_entry then bk_ss_$control_ptr -> backup_control.loaded (bk_ss_$path_index) = "1"b;

	unspec (reload_set_info) = "0"b;
	reload_set_info.version = reload_set_version_2;

	if ((htype = ndc_segment) | (htype = sec_seg)) then do;
	     if ^bk_ss_$debugsw then do;
		if hp -> h.max_length ^= sys_info$default_max_length then do;
						/* only set if create_branch_ didn't */
						/* already set correct value */
						/* thus possibly avoiding setfault */
		     reload_set_info.should_set.max_length = "1"b;
		     reload_set_info.max_length = hp -> h.max_length;
		end;
	     end;
	     else if ^bk_ss_$no_reload then do;
		call hcs_$set_max_length ((hp -> h.dname), (hp -> h.ename), (hp -> h.max_length), code);
		if code ^= 0 then			/* Attempt to set max length of segment. */
		     call backup_map_$fs_error_line (code, "hcs_$set_max_length", hp -> dname, hp -> ename);
	     end;
	end;					/*
						   /*	SKIP SEGMENT INITIATION AND COPYING IF NOT RELOADING
						   /*									*/
	if ^bk_ss_$no_reload then
	     if scnt > 0 then do;			/* Any segment to reload? */
		if MRS = 0 then do;			/* has been read to pdir already */
		     if bk_ss_$debugsw & ^bk_ss_$restore_access_class then
			call hcs_$initiate (hp -> h.dname, hp -> h.ename, "", 0, 1, segptr, code);
		     else call system_privilege_$initiate (hp -> h.dname, hp -> h.ename, "", 0, 1, segptr, code);
		     if code ^= 0 then do;
			call backup_map_$fs_error_line (code, "initiate", hp -> h.dname, hp -> h.ename);
			go to next;		/* go get next logical record */
		     end;

		     if bk_ss_$qchecksw		/* If checking quotas */
		     then do;
			on record_quota_overflow call handle_rqo;
			segptr -> mover = seg_buff -> mover;
						/* move it from temp seg */
			revert record_quota_overflow; /* revert the condition */
		     end;

		     else segptr -> mover = seg_buff -> mover;
						/* reload segment from temp i/o segment */

		     call hcs_$terminate_noname (segptr, code);
						/* terminate segment after reloading */
		     if code ^= 0 then		/* Print comment for error in terminate. */
			call backup_map_$fs_error_line (code, "terminate_noname", hp -> h.dname, hp -> h.ename);
		end;


		else do;				/* must still read seg & rename */

		     if bk_ss_$debugsw & ^bk_ss_$restore_access_class then
			call hcs_$initiate (hp -> h.dname, hp -> h.ename, "", 0, 1, segptr, code);
		     else call system_privilege_$initiate (hp -> h.dname, hp -> h.ename, "", 0, 1, segptr, code);
		     if code ^= 0 then do;
			call backup_map_$fs_error_line (code, "initiate", hp -> h.dname, hp -> h.ename);

			call UNCREATE;
			go to next;
		     end;				/* seg has been initiated, actually couldn't fail.. */
		     if bk_ss_$qchecksw then on record_quota_overflow call handle_rqo;
		     call bk_input$rd_tape (null (), (0), segptr, scnt, code);
						/* read data into seg */
		     if bk_ss_$qchecksw then revert record_quota_overflow;
		     MRS = 0;			/* remember this is done */
		     if code ^= 0 then do;		/* tape trouble or EOT */
			call UNCREATE;
			if code = 2 then code = 0;
			if code ^= 0 then
			     go to TAPE_DONE;	/* err or no more tapes */
			else go to next;
		     end;				/* code from tape nonzero */

		     call hcs_$terminate_noname (segptr, code);
		     if code ^= 0 then
			call backup_map_$fs_error_line (code, "terminate", hp -> h.dname, hp -> h.ename);
						/* now must put pri name on seg */
		     call hcs_$chname_file (hp -> h.dname, hp -> h.ename, hp -> h.ename, save_ename, code);
		     if code ^= 0 then do;
			if code = error_table_$namedup then do;
						/* only sensible err */
			     call backup_util$delete_name (hp -> h.dname, save_ename, code);
			     if code ^= 0 then do;	/* can't happen */
uncreate:
				if bk_ss_$sub_entry then do;
				     bk_ss_$control_ptr -> backup_control.status_code (bk_ss_$path_index) =
					error_table_$namedup;
				     bk_ss_$control_ptr -> backup_control.error_name (bk_ss_$path_index) =
					"backup_util$delete_name";
				     bk_ss_$control_ptr -> backup_control.loaded (bk_ss_$path_index) = "0"b;
				end;
				call UNCREATE;
				go to next;
			     end;
			     else do;		/* name was deleted */
				call hcs_$chname_file (hp -> h.dname, hp -> h.ename, hp -> h.ename, save_ename,
				     code);
				if code ^= 0 then go to uncreate;
			     end;
			end;
			else go to uncreate;
		     end;
		     hp -> h.ename = save_ename;
		     hp -> h.elen = save_elen;
		end;				/* end loading seg from tape */
	     end;					/* end loading seg */
	dtd = fixed (bp -> br (1).dtd, 52);		/* Get times from branch structure. */
	dtu = fixed (bp -> br (1).dtu, 52);
	dtem = fixed (bp -> br (1).dtbm, 52);
	dtsm = fixed (bp -> br (1).dtm, 52);
	call PRINT_HEADER ();
	if bk_ss_$mapsw then
	     call backup_map_$detail_line2 (hp -> h.ename, divide (scnt + 1023, 1024, 9, 0), RECORD_TYPE (htype), dtp,
		dtem, dtd, dtu, dtsm);

/* Distribute the no_reload checks so that maps can be better */

	if (htype = sec_seg) | (htype = sec_dir) | (htype = ndc_segment) | (htype = ndc_directory) then
	     if ^bk_ss_$debugsw then do;		/* Insert author and activity if possible */


/*	set the author		*/

		reload_set_info.should_set.author = "1"b;
		reload_set_info.author = addr (hp -> h.quota) -> author;

	     end;


/*	set bitcount author and safety switch as well as the audit_flag */

	if (htype = sec_seg) | (htype = sec_dir) | (htype = ndc_segment) | (htype = ndc_directory) then do;
	     if ^bk_ss_$debugsw then do;		/* Cannot set bitcount author in debug mode. */
		reload_set_info.should_set.bc_author = "1"b;
		reload_set_info.bc_author = hp -> h.bitcount_author;
		reload_set_info.should_set.safety_sw = "1"b;
		reload_set_info.safety_sw = hp -> h.switches.safety_sw;
		reload_set_info.should_set.audit_flag = "1"b;
		reload_set_info.audit_flag = hp -> h.switches.audit_flag;
	     end;

	     else do;
		if ^bk_ss_$no_reload then do;
		     call hcs_$set_safety_sw (hp -> dname, hp -> ename, (hp -> h.safety_sw), code);
		     if code ^= 0 & code ^= error_table_$incorrect_access then
			call backup_map_$fs_error_line (code, "hcs_$set_safety_sw", hp -> dname, hp -> ename);
                          call system_privilege_$set_entry_audit_switch ((hp -> dname), (hp -> ename), (hp -> h.audit_flag), code);
		      if code ^= 0 then call backup_map_$fs_error_line (code, "system_privilege_$set_entry_audit_switch", hp -> dname, hp -> ename);
		end;
	     end;
	end;


	if htype = sec_seg then do;
	     if hp -> h.switches.entrypt_sw = "0"b then
		call_limiter = 0;			/* not to be used */
	     else call_limiter = fixed (hp -> h.entrypt_bound, 14);
	     if ^bk_ss_$debugsw then do;
		if call_limiter ^= 0 then do;		/* avoid setfault if possible */
		     reload_set_info.should_set.entry_bound = "1"b;
		     reload_set_info.entry_bound = call_limiter;
		end;
	     end;
	     else do;
		if ^bk_ss_$no_reload then do;
		     call hcs_$set_entry_bound (hp -> h.dname, hp -> h.ename, call_limiter, code);
		     if code ^= 0 & code ^= error_table_$incorrect_access then
			call backup_map_$fs_error_line (code, "hcs_$set_entry_bound", hp -> h.dname, hp -> h.ename);
		end;
	     end;
	end;					/*	add names		*/

	i = fixed (bp -> br (1).nnames, 17);		/* how many names are there? */
	if i > 1 then call backup_util$add_names (hp -> h.dname, hp -> h.ename, np, i, "1"b);


/*	replace the acl 	*/

	if hp -> h.aclc = 0 then
	     aclp = null ();
	else aclp = pointer (hp, hp -> h.aclp);		/* Get pointer to array. */
	code = 0;

	if (htype = ndc_segment) | (htype = sec_seg) then do;
	     if ^bk_ss_$no_reload then do;
		call hcs_$replace_acl (hp -> h.dname, hp -> h.ename, aclp, hp -> h.aclc, "1"b, code);
		if code ^= 0 & code ^= error_table_$incorrect_access then
		     call backup_map_$fs_error_line (code, "hcs_$replace_acl", hp -> h.dname, hp -> h.ename);
		go to set_rb;			/* Now set the ring brackets. */
	     end;
	end;
	else if (htype = ndc_directory) | (htype = sec_dir) then do;
	     if ^bk_ss_$no_reload then do;
		call hcs_$replace_dir_acl (hp -> h.dname, hp -> h.ename, aclp, hp -> h.aclc, "0"b, code);

		if code ^= 0 & code ^= error_table_$incorrect_access then
		     call backup_map_$fs_error_line (code, "hcs_$replace_dir_acl", hp -> h.dname, hp -> h.ename);
		go to set_rb;
	     end;
	end;

/* Now reload the ring brackets */

	if bp -> br (1).rb1 = ""b then do;		/* if from old tape and no ring brackets defined */
	     i = 0;				/* set flag indicating default ring brackets set */
	     rings (1), rings (2), rings (3) = 4;	/* 4 rather than 5? questionable! */
	end;
	else do;					/* pick up ring brackets from branch information */
set_rb:
	     i = 1;				/* set flag */
	     rings (1) = fixed (bp -> br (1).rb1, 6);
	     rings (2) = fixed (bp -> br (1).rb2, 6);
	     rings (3) = fixed (bp -> br (1).rb3, 6);
	end;

	if bk_ss_$enforce_minimum_ring then do;
	     rings (1) = max (bk_ss_$minimum_ring, rings (1));
	     rings (2) = max (bk_ss_$minimum_ring, rings (2));
	     rings (3) = max (bk_ss_$minimum_ring, rings (3));
	end;

	if ^bk_ss_$no_reload then
	     if bp -> br (1).dirsw then
		call hcs_$set_dir_ring_brackets (hp -> h.dname, hp -> h.ename, rings, code);
	     else call hcs_$set_ring_brackets (hp -> h.dname, hp -> h.ename, rings, code);
	call print_rbs (rings);
	if code ^= 0 & code ^= error_table_$incorrect_access then
	     call backup_map_$fs_error_line (code, "set_ring_brackets", hp -> h.dname, hp -> h.ename);
	else if i = 0 then do;			/* check flag and put line in map (but not typed on-line) */
	     call ioa_$rs ("Default ring brackets assigned to ^a>^a", line, n, hp -> h.dname, hp -> h.ename);
	     call backup_map_$directory_line (line_pointer, n);
	end;


	if code = error_table_$incorrect_access then
	     call backup_map_$fs_error_line (code, "ACL, ring brackets, safety switch", hp -> h.dname, hp -> h.ename);

/*	set times		*/

	times.dtem = fixed (bp -> br (1).dtbm, 52);	/* Copy time modified from entry. */
	if ^bk_ss_$retrievesw then			/* Restore dtd if reload */
	     times.dtd = dtp;			/* Get time dumped from header. */
	else times.dtd = 0;				/* On retrieval set dtd to 0, force dumping */
	times.dtu = fixed (bp -> br (1).dtu, 52);	/* Copy time used from entry. */
	times.dtm = fixed (bp -> br (1).dtm, 52);	/* Copy time segment modified from entry. */
	if ^bk_ss_$no_reload then
	     if ^bk_ss_$debugsw then do;		/* Do if really reloading */
		reload_set_info.should_set.tpd = "1"b;
		reload_set_info.tpd = hp -> h.switches.tpd;
		reload_set_info.should_set.dtem, reload_set_info.should_set.dtd, reload_set_info.should_set.dtu,
		     reload_set_info.should_set.dtm = "1"b;
		reload_set_info.dtem = substr(bit (times.dtem, 52),1,36);
		reload_set_info.dtd = substr(bit (times.dtd, 52),1,36);
		reload_set_info.dtu = substr(bit (times.dtu, 52),1,36);
		reload_set_info.dtm = substr(bit (times.dtm, 52),1,36);
		call hphcs_$set_for_reloader (hp -> h.dname, hp -> h.ename, addr (reload_set_info), code);
		if code ^= 0 then
		     call backup_map_$fs_error_line (code, "hphcs_$set_for_reloader", hp -> h.dname, hp -> h.ename);

		if reload_set_info.author_code ^= 0 then
		     call backup_map_$fs_error_line ((reload_set_info.author_code), "set_for_reloader(author)",
			hp -> h.dname, hp -> h.ename);

		if reload_set_info.bc_author_code ^= 0 then
		     call backup_map_$fs_error_line ((reload_set_info.bc_author_code), "set_for_reloader(bc_author)",
			hp -> h.dname, hp -> h.ename);

		if reload_set_info.max_length_code ^= 0 then
		     call backup_map_$fs_error_line ((reload_set_info.max_length_code),
			"set_for_reloader(max_length)", hp -> h.dname, hp -> h.ename);

		if reload_set_info.entry_bound_code ^= 0 then
		     call backup_map_$fs_error_line ((reload_set_info.entry_bound_code),
			"set_for_reloader(entry_bound)", hp -> h.dname, hp -> h.ename);

	     end;

	go to next;				/* segment reloaded, get next logical record */

/**/

CHECK_FOR_NEW_DIRECTORY:
     proc ();
	if hp -> h.dname ^= old_dname then do;
	     old_dname = substr (hp -> h.dname, 1, hp -> h.dlen);
	     new_dir = "1"b;
	end;
	return;
     end CHECK_FOR_NEW_DIRECTORY;

PRINT_HEADER:
     proc ();
	if new_dir then do;
	     if bk_ss_$mapsw then call backup_map_$directory_line (addr (hp -> h.dname), hp -> h.dlen);
	     new_dir = "0"b;
	end;
	return;
     end PRINT_HEADER;

/* -------------------------------------------------- */

HAVE_SMA:
     proc returns (bit (1) aligned);


/* intl proc to make sure we have sma on parent before appending a unique
   named branch for later rename .
   get_user_effmode is called to get the mode, rather than
   status_ in order to avoid vtoc io.  However get user effmode
   does not correctly return the initializers access.   We know
   that access_mode, when really computing access will give the
   initializer access.  For this reason, and for the sake of efficiency,
   we do not wish to check the users access if the user is the
   initializer.
   For all other users we must check the access to make sure sma is
   there.  However if the directory for which access is to be computed
   is the same directory for which we las computed access, then we can
   just return the previously computed value.  This is another optimization.
   If the user is not initializer then if the directory is new then
   if the access computation is successful then we will remember that
   new dirname and access to it.
   10/01/75 -- RE Mullen */

dcl  ckdir char (168);
dcl  ckent char (32);
dcl  ckcode fixed bin (35);
dcl  effmode fixed bin (5);
	if INITIALIZER then return ("1"b);		/* always true */
	else if substr (hp -> h.dname, 1, hp -> h.dlen) = hs_dirname then return (hs_bit);
						/* access known */
						/* try to determine access */
	call expand_pathname_ (substr (hp -> h.dname, 1, hp -> h.dlen), ckdir, ckent, ckcode);
	if ckcode ^= 0 then return ("0"b);
	call hcs_$get_user_effmode (ckdir, ckent, USERID, cu_$level_get (), effmode, ckcode);
	if ckcode ^= 0 then
	     return ("0"b);
	else do;					/* update assoc mem */
	     if (bit (effmode) & "01011"b) = "01011"b then
		hs_bit = "1"b;
	     else hs_bit = "0"b;
	     hs_dirname = substr (hp -> h.dname, 1, hp -> h.dlen);
						/* remember name */
	end;

	return (hs_bit);				/* tell caller the result */

     end HAVE_SMA;



/* ----------------------------------------------------------- */


UNCREATE:
     proc;					/* to delete seg mistakenly appended */

dcl  hcs_$delentry_file entry (char (*) aligned, char (*) aligned, fixed bin (35));
dcl  uccode fixed bin (35);

	call hcs_$set_copysw (hp -> h.dname, hp -> h.ename, "0"b, uccode);
	call hcs_$delentry_file (hp -> h.dname, hp -> h.ename, uccode);
	if uccode ^= 0 then call backup_map_$fs_error_line (uccode, "deleting temp_seg", hp -> h.dname, hp -> h.ename);

     end UNCREATE;


handle_rqo:
     proc;					/* record_quota_overflow handler */


	code = error_table_$rqover;			/* set the error */
	call backup_map_$fs_error_line (code, "backup_load", hp -> h.dname, hp -> h.ename);
	call UNCREATE;
	if bk_ss_$sub_entry then do;
	     bk_ss_$control_ptr -> backup_control.loaded (bk_ss_$path_index) = "0"b;
	     go to next;
	end;
	go to next;

     end handle_rqo;

/**/

/* Prints ACLs and ring brackets for reload map */

printers:
     procedure ();

declare  text character (168);
declare  text_l fixed binary (21);

%include acl_structures;


/* Print ring brackets */

print_rbs:
     entry (rings);

declare  rings (3) fixed binary (3) parameter;

	call ioa_$rsnnl ("Ring Brackets:^35t^(^d ^)", text, text_l, rings);
	call backup_map_$name_line (addr (text), text_l);

	return;

     end printers;

     end backup_load;
