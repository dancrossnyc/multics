/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */


/****^  HISTORY COMMENTS:
  1) change(89-02-02,Huen), approve(89-02-02,MCR8057), audit(89-05-24,RWaters),
     install(89-05-31,MR12.3-1051):
     Fix Bug 204 in qedx
     editor - Ignore trailing whitespace after a quit request.
                                                   END HISTORY COMMENTS */

/* format: off */

/* Multics qedx Editor subroutine interface: the actual editor. */

/* Created:  August 1970 by R. C. Daley */
/* Modified: August 1977 by R.J.C. Kissel to fix long entryname and garbage word bugs */
/* Modified: 23 February 1979 by Steve Herbst to fix w and r error messages for MSFs */
/* Modified: 4 September 1981 by E. N. Kittlitz to add -pathname, -no_rw_path, r request with no pathname, and to
      eliminate b.default_len */ 
/* Modified: 14 July 1980 by T. Oke for gapped buffer management */
/* Modified: 3 March 1981 by S. G. Harris (UNCA) for read entry point */
/* Modified: 3 March 1982 by S. Herbst to merge all of above changes */
/* Modified: 16 April 1982 by S. Herbst to add quit query for modified buffers (subsequently removed, sigh) */
/* Modified: 5 May 1982 by S. Herbst to check that it has not been recursively interrupted */
/* Modified: 7 October 1982 by S. Herbst to fix "Substitution failed." bug inside recursed buffer */
/* Modified: 3 November 1982 by S. Herbst to fix ".a" bug in empty buffer */
/* Modified: January 1983 by G. Palter to make reentrant, convert into qedx_, re-enable quit query if requested by caller,
      accept the archive component pathname convention on input, rename quit-force to "qf" from "Q", and add trusted
      pathnames as in ted */
/* Modified April 1983 by Keith Loepere to make work in Bootload Multics */
/* Modified August 1983 by Keith Loepere for new bce switches */
/* Modified March 1985 by Keith Loepere to run in bce and Multics. */
/* Modified Jan 1989 by Huen (204) - Allow whitespace after a "q" request (such as q, Q, qf, etc) */

/* format: on,style4,delnl,insnl,ifthenstmt,ifthen */

qedx_:
     procedure (P_qedx_info_ptr, P_code);


dcl  P_qedx_info_ptr pointer parameter;			/* -> caller's initial buffers, etc. */
dcl  P_code fixed binary (35) parameter;

dcl  a_real_file bit (1) aligned;
dcl  b0_bp ptr;
dcl  b0_ifp ptr;
dcl  buffer_idx fixed binary;
dcl  callers_io_region_ptr pointer;
dcl  ch char (1);
dcl  cht char (1);
dcl  code fixed bin (35);
dcl  curbuf char (16) init ("0");
dcl  delim char (1);
dcl  error_sw ptr;					/* for "special" errors */
dcl  explicit_pathname bit (1) aligned;
dcl  fe fixed bin (21);
dcl  fle fixed bin (21);
dcl  fli fixed bin (21);
dcl  flsw bit (1);
dcl  fp ptr;
dcl  have_truncated_buffers bit (1) aligned;
dcl  i fixed bin (21);
dcl  ife fixed bin (21);				/* index of last char in file */
dcl  ifp ptr;					/* pointer to current file buffer */
dcl  ift fixed bin (21);
dcl  ignore_result bit (1) aligned;
dcl  il fixed bin (21);
dcl  ilb fixed bin (21);
dcl  iline char (512);
dcl  intsw bit (1);
dcl  j fixed bin (21);
dcl  je fixed bin (21);
dcl  k fixed bin (21);
dcl  ka fixed bin (21);
dcl  kx fixed bin (21);
dcl  l fixed bin (21);
dcl  le fixed bin (21);				/* index of last char of current line */
dcl  li fixed bin (21);				/* index of first char of current line */
dcl  lle fixed bin (21);				/* index of last char of addressed line */
dcl  lli fixed bin (21);				/* index of first char of addressed line */
dcl  llsw bit (1);
dcl  1 local_qbii aligned like qedx_buffer_io_info;
dcl  1 local_qid aligned like qid;			/* describes this invocation */
dcl  me fixed bin (21);
dcl  mi fixed bin (21);
dcl  ml fixed bin (21);
dcl  new_modes char (256);				/* for call to iox_$modes */
dcl  old_modes char (256);
dcl  output_routine entry (ptr, ptr, fixed bin (21), fixed bin (35)) variable;
dcl  output_sw ptr;					/* bce/iox_ switch for "special" output */
dcl  pfs fixed bin (35) init (0);
dcl  pi_label label;
dcl  pi_sw bit (1);
dcl  process_type fixed bin;
dcl  quit_force_sw bit (1);
dcl  saved_current_buffer character (16);
dcl  saved_ift fixed bin (21);			/* copy of ift during call to "promote" */
dcl  sdsw bit (1);
dcl  subsw bit (1);
dcl  sub_comp_string character (3) aligned init ("   ");
dcl  tbp ptr;
dcl  te fixed bin (21);				/* index of last character in tw line */
dcl  1 the_buffer aligned like qedx_info.buffers based (the_buffer_ptr);
dcl  the_buffer_ptr pointer;
dcl  the_pathname character (256);
dcl  ti fixed bin (21);				/* index of first unprocessed char in tw line */
dcl  tik fixed bin (21);
dcl  tname char (16);
dcl  tp ptr;					/* pointer to current typewriter input request line */
dcl  twbuff char (512);
dcl  was_empty bit (1) aligned;
dcl  xsw bit (1);
dcl  yes_sw bit (1);

/* ilb_offset is used for post-deletion of text during string substitution.
   Post deletion is necessary so the the string search /^ // on line 1 will
   not kill all spaces since first line anchoring tests for nothing before
   and pre-deletion to next search will ensure a re-match for ^ . */

dcl  ilb_offset fixed bin (21);

dcl  COMMANDS character (19) static options (constant) initial ("psaicdbmrwqg=xevn""Q");
dcl  command_index fixed binary;			/* current command being executed */

dcl  QEDX_ character (32) static options (constant) initial ("qedx_");

dcl  QEDX_INFO_VERSION_0 character (8) static options (constant) initial ("qxi_0001");

dcl  MODIFIED_BUFFERS_EXPLANATION character (104) static options (constant)
	initial ("If you quit now, your latest changes to the above buffers will not be
saved.  Do you still wish to quit?");

dcl  TRUNCATED_BUFFERS_EXPLANATION character (100) static options (constant)
	initial ("If you quit now, some of the contents of the above buffers will be
lost.  Do you still wish to quit?");

dcl  TRUSTED_PATHNAMES_EXPLANATION character (198) static options (constant)
	initial ("More than one pathname has been used with the read and write requests
in this buffer.  Do you want to ^a this buffer using the pathname ^a
which I consider to be the correct default for this buffer?");

dcl  1 t based (tp) aligned,				/* structure to treat request line as character array */
       2 c (sys_info$max_seg_size * 4) char (1) unaligned;

dcl  1 f based aligned,				/* structure to treat any file as character array */
       2 c (sys_info$max_seg_size * 4) char (1) unaligned;

dcl  a_string char (sys_info$max_seg_size * 4) based aligned;

dcl  CHASE fixed binary (1) static options (constant) initial (1);

dcl  EC character (1) static options (constant) initial ("");
						/* ancient conceal character = ASCII 031 */

dcl  NL character (1) static options (constant) initial ("
");

/* format: off */
dcl (error_table_$archive_component_modification, error_table_$archive_pathname, error_table_$bigarg, error_table_$dirseg,
     error_table_$fatal_error, error_table_$inconsistent, error_table_$moderr, error_table_$no_r_permission,
     error_table_$no_w_permission, error_table_$pathlong, error_table_$recoverable_error,
     error_table_$unimplemented_version)
	fixed binary (35) external;
/* format: on */
dcl  sys_info$max_seg_size fixed binary (19) external;
dcl  sys_info$service_system bit (1) aligned external;

dcl  (cleanup, program_interrupt, sub_request_abort_) condition;

dcl  bce_data$console_put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35)) external variable;
dcl  bce_data$put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35)) external variable;
dcl  iox_$user_output ptr ext;			/* pointer to iocb for user_output */
dcl  iox_$user_io ptr ext;				/* pointer to iocb for user_io */

dcl  bce_check_abort entry;
dcl  bce_query$yes_no entry options (variable);
dcl  bootload_fs_$flush_sys entry;
dcl  bootload_fs_$get_ptr entry (char (*), ptr, fixed bin (21), fixed bin (35));
dcl  bootload_fs_$put_ptr entry (char (*), fixed bin (21), bit (1) aligned, ptr, fixed bin (35));
dcl  check_entryname_ entry (char (*), fixed bin (35));
dcl  com_err_ entry () options (variable);
dcl  command_query_$yes_no entry options (variable);
dcl  cu_$cp entry (ptr, fixed bin (21), fixed bin (35));
dcl  edx_util_$edx_cleanup entry (ptr);
dcl  edx_util_$edx_init entry (ptr, ptr, ptr, ptr, fixed bin (35));
dcl  edx_util_$end_buffer entry (ptr, fixed bin (35));
dcl  edx_util_$get_buffer entry (ptr, ptr, fixed bin (21), fixed bin (21), char (16), ptr);
dcl  edx_util_$list_buffers entry (ptr, char (16), ptr);
dcl  edx_util_$list_modified_buffers entry (pointer, character (16), pointer);
dcl  edx_util_$list_single_buffer entry (pointer, character (16), pointer, pointer);
dcl  edx_util_$locate_buffer entry (ptr, char (16), ptr);
dcl  edx_util_$modified_buffers entry (ptr) returns (bit (1));
dcl  edx_util_$prime entry (ptr, ptr, fixed bin (21));
dcl  edx_util_$read_ptr entry (ptr, ptr, fixed bin (21), fixed bin (21));
dcl  edx_util_$resetread entry (ptr);
dcl  expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));
dcl  expand_pathname_$component entry (char (*), char (*), char (*), char (*), fixed bin (35));
dcl  get_addr_
	entry (ptr, ptr, fixed bin (21), fixed bin (21), ptr, fixed bin (21), fixed bin (21), fixed bin (21),
	fixed bin (21), fixed bin (21), fixed bin (21), fixed bin (21), fixed bin (35));
dcl  get_system_free_area_ entry () returns (ptr);
dcl  get_temp_segment_ entry (char (*), ptr, fixed bin (35));
dcl  hcs_$status_minf entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24), fixed bin (35));
dcl  initiate_file_$component entry (char (*), char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));
dcl  initiate_file_$create entry (char (*), char (*), bit (*), ptr, bit (1) aligned, fixed bin (24), fixed bin (35));
dcl  ioa_ entry () options (variable);
dcl  ioa_$ioa_switch entry () options (variable);
dcl  iox_$modes entry (ptr, char (*), char (*), fixed bin (35));
dcl  iox_$put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35));
dcl  mrl_ entry (ptr, fixed bin (21), ptr, fixed bin (21));
dcl  pathname_ entry (char (*), char (*)) returns (char (168));
dcl  pathname_$component entry (char (*), char (*), char (*)) returns (char (194));
dcl  qx_search_file_
	entry (ptr, ptr, fixed bin (21), fixed bin (21), ptr, fixed bin (21), fixed bin (21), fixed bin (21),
	fixed bin (21), fixed bin (21), fixed bin (21), fixed bin (35));
dcl  qx_search_file_$cleanup entry (ptr);
dcl  qx_search_file_$init entry (ptr);
dcl  release_temp_segment_ entry (char (*), ptr, fixed bin (35));
dcl  sub_err_ entry () options (variable);
dcl  terminate_file_ entry (ptr, fixed bin (24), bit (*), fixed bin (35));
dcl  user_info_$process_type entry (fixed bin);

dcl  (addr, divide, index, min, null, search, substr, length, reverse, rtrim, string) builtin;
%page;
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* qedx_: procedure (P_qedx_info_ptr, P_code); */

	if sys_info$service_system then do;
	     output_routine = iox_$put_chars;
	     output_sw = iox_$user_output;
	     error_sw = iox_$user_io;
	end;
	else do;
	     output_routine = bce_data$put_chars;
	     error_sw = addr (bce_data$console_put_chars);
	     output_sw = addr (bce_data$put_chars);
	end;

	qedx_info_ptr = P_qedx_info_ptr;

	if (qedx_info.version ^= QEDX_INFO_VERSION_0) & (qedx_info.version ^= QEDX_INFO_VERSION_1) then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;


/* Initialize per-invocation data */

	qid_ptr = addr (local_qid);			/* use the one in automatic */

	qid.editor_name = qedx_info.editor_name;
	qid.editor_area_ptr = get_system_free_area_ ();
	qid.qedx_info_ptr = qedx_info_ptr;		/* edx_util_, etc. may need it */

	qid.flags = qedx_info.header.flags, by name;	/* all the same flags */

	qid.edx_util_data_ptr,			/* for cleanup handler */
	     qid.regexp_data_ptr, callers_io_region_ptr = null ();

	on condition (cleanup) call cleanup_invocation_data ();

	call edx_util_$edx_init (qid_ptr, addr (twbuff), b0_ifp, b0_bp, code);
	if code ^= 0 then do;
	     call com_err_ (code, qid.editor_name, "Unable to initialize edx_util_.");
	     P_code = error_table_$fatal_error;
	     return;
	end;

	call get_buffer_state (b0_bp);		/* let buffer "0" be current (for now) */

	call qx_search_file_$init (qid_ptr);

	if qedx_info.caller_does_io then do;		/* need an I/O buffer */
	     call get_temp_segment_ (qid.editor_name, callers_io_region_ptr, code);
	     if code ^= 0 then do;
		call com_err_ (code, qid.editor_name, "Obtaining I/O buffer.");
		P_code = error_table_$fatal_error;
		go to RETURN_FROM_QEDX_;
	     end;
	end;


/* Initialize buffers to those supplied by the caller */

	do buffer_idx = 1 to qedx_info.n_buffers;
	     the_buffer_ptr = addr (qedx_info.buffers (buffer_idx));

	     call edx_util_$locate_buffer (qid_ptr, the_buffer.buffer_name, bp);
	     if bp = null () then do;			/* error already printed */
		P_code = error_table_$fatal_error;
		go to RETURN_FROM_QEDX_;
	     end;

	     call get_buffer_state (bp);
	     b.callers_idx = buffer_idx;		/* need to keep track of it */

	     if the_buffer.read_write_region then do;	/* read/write from caller's character string */
		if the_buffer.region_ptr = null () then do;
		     call sub_err_ (error_table_$inconsistent, QEDX_, ACTION_CANT_RESTART, null (), 0,
			"Input/output area required for buffer ^a was not supplied.", the_buffer.buffer_name);
		     P_code = error_table_$fatal_error;
		     go to RETURN_FROM_QEDX_;
		end;
		else if qedx_info.caller_does_io then do;
		     call sub_err_ (error_table_$inconsistent, QEDX_, ACTION_CANT_RESTART, null (), 0,
			"Input/output area can not be used for buffer ^a when caller performs I/O.",
			the_buffer.buffer_name);
		     P_code = error_table_$fatal_error; /* ... caller I/O only works with pathnames */
		     go to RETURN_FROM_QEDX_;
		end;
		else do;				/* ... and it's actually there */
		     a_real_file = "0"b;		/* ... ...don't terminate it */
		     the_pathname = the_buffer.buffer_pathname;
		     b.default_was_region = "1"b;
		     the_buffer.region_final_lth = the_buffer.region_initial_lth;
		end;
	     end;

	     else do;				/* read/write from the specified file */
		if the_buffer.buffer_pathname = "" then do;
		     call sub_err_ (error_table_$inconsistent, QEDX_, ACTION_CANT_RESTART, null (), 0,
			"Default pathname not specified for buffer ^a.", the_buffer.buffer_name);
		     P_code = error_table_$fatal_error;
		     go to RETURN_FROM_QEDX_;
		end;
		else do;				/* ... and there is a pathname given */
		     a_real_file = "1"b;
		     the_pathname = the_buffer.buffer_pathname;
		     b.default_was_region = "0"b;
		end;
	     end;

	     fle = ife;				/* put it at the end (of the empty buffer) */
	     if ^perform_read (a_real_file, the_pathname, "1"b) then do;
		P_code = error_table_$fatal_error;	/* ... didn't work (sigh) */
		go to RETURN_FROM_QEDX_;
	     end;

	     if qedx_info.version = QEDX_INFO_VERSION_1 then
		b.default_locked = the_buffer.locked_pathname;
	     else b.default_locked = ^the_buffer.locked_pathname;
						/* version 0 structure: this flag had the opposite meaning */

	     call save_buffer_state ();		/* save it */
	end;


/* Initialize everything else ... */

	pi_sw = "0"b;				/* set switch to ignore program interrupts */

	if sys_info$service_system then on condition (program_interrupt) call interrupt ();
						/* establish handler for program interrupt */
	else on condition (sub_request_abort_) call interrupt ();
						/* establish handler for request abort */

	tp = addr (iline);				/* initialize pointer to input line buffer */
	substr (iline, 1, 3) = "b0 ";			/* move to buffer zero */
	te = 3;

	do buffer_idx = 1 to qedx_info.n_buffers;	/* insure we execute all request buffers */
	     the_buffer_ptr = addr (qedx_info.buffers (buffer_idx));
	     if the_buffer.execute_buffer then do;
		if (te + length ("\b() ") + length (rtrim (the_buffer.buffer_name))) > length (iline) then do;
		     call com_err_ (error_table_$bigarg, qid.editor_name, "Preparing to execute buffer ^a.",
			the_buffer.buffer_name);
		     P_code = error_table_$fatal_error;
		     go to RETURN_FROM_QEDX_;
		end;
		substr (iline, (te + 1), (length ("\b() ") + length (rtrim (the_buffer.buffer_name)))) =
		     "\b(" || rtrim (the_buffer.buffer_name) || ") ";
		te = te + length ("\b() ") + length (rtrim (the_buffer.buffer_name));
	     end;
	end;

	substr (iline, te, 1) = NL;			/* makes sure initial requests are executed properly */

	call edx_util_$prime (qid_ptr, tp, te);		/* prime input stream to read in and execute macro */
%page;
/*		**** Start of working Code ****


   qedx returns here to process each new command line, from either the
   macro file, or the terminal,  if qedx is executing multiple commands from
   a single line, re-entry is made to the label next:, rather than nx_line:.

   At this point the basic command is cracked and addressing is determined. */


nx_line:
	ti = 1;					/* read next request line from input stream */
	call edx_util_$read_ptr (qid_ptr, tp, length (iline), te);

next:
	if ^sys_info$service_system then do;
	     intsw = "0"b;
	     call bce_check_abort;
	     if intsw = "1"b then go to RETURN_FROM_QEDX_;
	end;
	call save_buffer_state ();			/* save current buffer state */
	if ti >= te then go to nx_line;		/* check after each request if request line exhausted */
	intsw = "0"b;				/* reset previous program_interrupt (if any) */

	call get_addr_ (qid_ptr, tp, ti, te, ifp, ilb, ift, ife, li, le, fli, fle, code);
						/* find first address if any */
	if code = 0 then flsw, llsw = "0"b;		/* code = 0, no address found (use default) */
	else if code = 1 then do;			/* code = 1, */
	     flsw = "1"b;				/* single address found, */
	     llsw = "0"b;				/* use default for second address if needed */
	end;
	else if code < 4 then do;			/* code 2 or 3, */
	     flsw, llsw = "1"b;			/* both addresses found */
	     if code = 2 then
		call get_addr_ (qid_ptr, tp, ti, te, ifp, ilb, ift, ife, li, le, lli, lle, code);
						/* code 2 = "," */
	     else call get_addr_ (qid_ptr, tp, ti, te, ifp, ilb, ift, ife, fli, fle, lli, lle, code);
						/* code 3 = ";" */
	     if code = 4 then go to reg_err;		/* check for failure to match on regular expression */
	     if code > 4 then go to rq_err;		/* check for other error */
	end;
	else if code = 4 then do;			/* code = 4, */
reg_err:
	     call edx_util_$end_buffer (qid_ptr, code);	/* failure to match reg. expression, pop buffer stack */
	     if code ^= 0 then do;			/* if already at highest buffer level (0) */
		call ioa_ ("Search failed.");		/* print error message */
		go to rq_err;			/* treat as normal error */
	     end;
	     else go to nx_line;			/* resume input from next higher level */
	end;
	else if code > 4 then do;			/* code > 4, error detected in get_addr_ */
rq_err:
	     call edx_util_$resetread (qid_ptr);	/* reset buffer push down stack and tw input buffer */
	     go to nx_line;				/* read next line from console typewriter (level=0) */
	end;

	ch = t.c (ti);				/* pick up first character after address */
	ti = ti + 1;				/* bump request line character index */
	if ch = NL then				/* check for new-line character */
	     if flsw then
		go to print1;			/* print line pointed to by "." if address found */
	     else go to nx_line;			/* otherwise, ignore NL and read next request line */
	command_index = index (COMMANDS, ch);		/* which command given */
	pi_label = ACTION (0);			/* assume we will be an error */
	go to ACTION (command_index);			/* go do it */

ACTION (0):					/* here if unrecognized */
	call ioa_ ("^a: ^a not recognized as a request.", qid.editor_name, ch);
						/* here if request not understood */
	go to rq_err;				/* treat as any other error */
%page;
/*    **** read request ****

   Read in specified file after addressed line in current buffer file.

   Current line is left at the end of the readin section.

   Operation is performed by splitting the buffer under where the readin should
   occur and reading appending to the bottom of the top section.
   This leaves the gap below the readin section, which is where it will tend to
   speed initial editing commands on the readin section.
*/

ACTION (9):
read:
	call determine_file ("0"b, a_real_file, the_pathname, explicit_pathname);

	if ^flsw then fle = ife;			/* no address: append to end of file */

	if perform_read (a_real_file, the_pathname, explicit_pathname) then
	     go to nx_line;				/* successfull read */
	else go to rq_err;
%page;
/*    **** write request ****

   Write out the specified contents of the current buffer into the spec file.

   This operation is done without gap movement by calculating if the data is
   split across the gap, or entirely contained within either the top or bottom
   sections of the buffer.  If the data is contiguous, then a single substr is
   used, otherwise the section within the bottom, and the section within the
   top are separately written, with the top write appended on the bottom.

   The current line position is not altered by writing.
*/

ACTION (10):
write:
	call defaults (1, ife);			/* supply default addresses (1,$) if necessary */
	pi_label = wr_quit;				/* in case of quit */
	pi_sw = "1"b;				/* activate quit handler and label */

	call determine_file ("1"b, a_real_file, the_pathname, explicit_pathname);
						/* firgure out where it goes */

	if ^perform_write (a_real_file, the_pathname, explicit_pathname, "1"b) then go to rq_err;
						/* didn't work */

wr_quit:
	pi_sw = "0"b;				/* turn of pi handler */
	go to nx_line;				/* go pick up next qedx request line */
%page;
/* * * * * quit request .......... clean up and exit from qedx editor (i.e., return to caller) * * * * * * * * */

ACTION (19):					/* Q request: don't worry about modified buffers */
	quit_force_sw = "1"b;
	go to DO_QUIT_REQUEST;

ACTION (11):					/* q/qf request */
	if t.c (ti) = "f" then do;			/* ... it's qf: don't worry about modified buffers */
	     quit_force_sw = "1"b;
	     ti = ti + 1;
	end;
	else quit_force_sw = "0"b;			/* ... it's q: may query if modified buffers exist */

DO_QUIT_REQUEST:
          if (flsw) then do;	/* special syntax check for quit request */
               call ioa_ ("Syntax error in quit request.");
	     go to rq_err;
	end;
	/* Bug_204 : Ignore trailing whitespace after a quit request */
	if (t.c (ti) ^= NL) then do;
	     ti = ti + verify (substr (iline, ti), " 	") - 1;
               if (t.c (ti) ^= NL) then do;
	        call ioa_ ("Syntax error in quit request.");
	        go to rq_err;
	     end;
	end;
     

/* Check for modified buffers if caller so desires */

	if qid.query_if_modified & ^quit_force_sw then	/* ... but only if user doesn't want out */
	     if edx_util_$modified_buffers (qid_ptr) then do;

		if sys_info$service_system then
		     call user_info_$process_type (process_type);
		else process_type = 1;
		if process_type = 1 then do;		/* ... and only if interactive */
		     call ioa_$ioa_switch (error_sw, "Modified buffers exist:");
		     call edx_util_$list_modified_buffers (qid_ptr, (b.name), error_sw);

		     if sys_info$service_system then
			call command_query_$yes_no (yes_sw, 0, qid.editor_name, MODIFIED_BUFFERS_EXPLANATION,
			     "Do you still wish to quit and lose these changes?");
		     else call bce_query$yes_no (yes_sw, MODIFIED_BUFFERS_EXPLANATION);
		     if yes_sw then			/* ... is equivalent to using Q */
			quit_force_sw = "1"b;
		     else go to rq_err;		/* ... no: back to request loop */
		end;
	     end;

	if quit_force_sw then go to SET_OUTPUT_VALUES;	/* quit force: don't update anything requesting auto_write */


/* Update any buffers with auto-write and query if there are truncated buffers */

	saved_current_buffer = b.name;		/* in case user doesn't want to quit */
	call save_buffer_state ();

	have_truncated_buffers = "0"b;		/* need this locally */

	do buffer_idx = 1 to qedx_info.n_buffers;
	     the_buffer_ptr = addr (qedx_info.buffers (buffer_idx));
	     call edx_util_$locate_buffer (qid_ptr, the_buffer.buffer_name, bp);
	     call get_buffer_state (bp);		/* switch buffers */

	     if the_buffer.read_write_region then do;	/* check this buffer and/or write it */

		if the_buffer.auto_write then do;	/* ... write it */
		     fli = 1;			/* ... ... setup to write entire buffer */
		     lle = ife;
		     ignore_result = perform_write ("0"b, "", "0"b, "0"b);
		end;				/* put it back without error messages */

		if the_buffer.region_final_lth > the_buffer.region_max_lth then do;
		     if ^have_truncated_buffers then do;/* ... first truncated buffer */
			call ioa_$ioa_switch (error_sw, "Buffers which will be truncated:");
			have_truncated_buffers = "1"b;
		     end;
		     call edx_util_$list_single_buffer (qid_ptr, saved_current_buffer, output_sw, bp);
		end;
	     end;
	end;

	if have_truncated_buffers then do;		/* need permission for this ... */
	     if sys_info$service_system then
		call command_query_$yes_no (yes_sw, 0, qid.editor_name, TRUNCATED_BUFFERS_EXPLANATION,
		     "Do you still wish to quit?");
	     else call bce_query$yes_no (yes_sw, TRUNCATED_BUFFERS_EXPLANATION);
	     if ^yes_sw then do;			/* ... user got scared */
		call edx_util_$locate_buffer (qid_ptr, saved_current_buffer, bp);
		call get_buffer_state (bp);		/* ... back to where user thinks he is */
		go to rq_err;
	     end;
	end;


/* Set output parameters in query_info structure and P_code */

SET_OUTPUT_VALUES:
	qedx_info.quit_forced = quit_force_sw;		/* let caller know */
	qedx_info.buffers_truncated = "0"b;		/* until following check proves otherwise */

	do buffer_idx = 1 to qedx_info.n_buffers;
	     the_buffer_ptr = addr (qedx_info.buffers (buffer_idx));
	     if the_buffer.read_write_region then	/* ... only check those not using a file */
		if the_buffer.region_final_lth > the_buffer.region_max_lth then
		     qedx_info.buffers_truncated, the_buffer.truncated = "1"b;
	end;

	if qedx_info.quit_forced | qedx_info.buffers_truncated then
	     P_code = error_table_$recoverable_error;	/* caller beware */
	else P_code = 0;


/* Control arrives here when it is time to exit qedx (with P_code already set) */

RETURN_FROM_QEDX_:
	call cleanup_invocation_data ();

	return;
%page;
/*     **** Print value of current addressed line ****

   This entry is used to print a line from a single address, such as dot, relative
   or absolute.  The line addressed by lli,lle is printed.  New input line is
   forced by mating ti and te. */

print1:
	ti = te;					/* force nx_line call through next label */

/*    **** print request  print out specified portion of current buffer ****

   This code is directly the same as used in write, with the character stream
   going to the terminal, rather than the output file. */

ACTION (1):
print:
	call defaults (li, le);			/* supply default addresses (.,.) if necessary */
	pi_label = end_pr;				/* allow printing to be aborted */
	pi_sw = "1"b;				/* by means of a program interrupt */
	if lle <= ilb | fli >= ift then do;		/* portion addressed is purely in bottom or top */
	     i = lle - fli + 1;
	     call output_routine (output_sw, addr (ifp -> f.c (fli)), i, code);
	end;					/* print specified portion of buffer on user's console */
	else if fli <= ilb then do;			/* top in top, bottom in bottom */
	     i = lle - ift + 1 + ilb - fli;
	     call output_routine (output_sw, addr (ifp -> f.c (fli)), ilb - fli + 1, code);
						/* print specified portion of buffer on user's console */
	     call output_routine (output_sw, addr (ifp -> f.c (ift)), lle - ift + 1, code);
						/* print specified portion of buffer on user's console */
	end;
	pi_sw = "0"b;				/* turn off program interrupt handling */
end_pr:
	call last_line (lle);			/* set current line to last line printed */
	go to next;				/* go pick up next qedx request */
%page;
/*     **** delete request    delete specified lines from current buffer *** */

ACTION (6):
delete:
	call defaults (li, le);			/* supply default addresses (.,.) if necessary */
	call delete_text ();			/* flush the text */
	call next_line (ift);			/* reposition at line after last line deleted (if any) */
	b.modified = "1"b;				/*  deletion is a modification */
	go to next;				/* get next qedx request */



/* Actually deletes text (used also by the change request) */

delete_text:
     procedure ();

/* deletion is done to make gap movement minimized.  Three situations are
   considered.
   1.  Bottom of range is above gap.  Then only undeleted chars are moved and
   ift is moved to delete.
   2.  Top of range is below gap.  Then only undeleted chars are moved and
   ilb is moved down to delete.
   3.  Range spans gap.  The ift and ilb are updated and fli -> ift.
*/

	if lle <= ilb then do;			/* move chars up til end of range */
	     call open_gap (lle);
	     ilb = fli - 1;				/* set lower bound of delete */
	end;
	else if fli >= ift then do;			/* move chars down from bottom of range */
	     call open_gap ((fli - 1));		/* open gap in front of section to delete */
	     ift = lle + 1;				/* set upper bound of delete */
	end;
	else do;					/* range spans gap */
	     ilb = fli - 1;				/* delete lower end */
	     ift = lle + 1;				/* delete upper end */
	     fli = ift;				/* clear range */
	end;

	return;

     end delete_text;
%page;
/*     **** append, insert or change request, append after, insert before or replace addressed text. ****

   All actions are performed by calculating a split point for the buffer and
   then opening the gap at that point.  For change, one also moves the
   lower section top pointer to delete text before reading in the new
   text.

   Space allocation for reading of new text is done by input calling
   for possible buffer promotion prior to each line of input being moved from
   the working line buffer, to the temporary file buffer.

   The current line position is left at the last line input.
*/

ACTION (3):					/* append text after addressed line */
append:
	if ^flsw |				/* if no address given or */
	     fle > ife then				/* addres is "." and buffer empty then */
	     fle = le;				/* append after current line */
	call open_gap ((fle));			/* open gap after current line */
	go to in_mode;				/* join common console input code */

ACTION (4):					/* insert text before addressed line */
insert:
	if ^flsw then fli = li;			/* insert before current line if no address given */
	fle = fli - 1;				/* back up one line (.-1) */
	call open_gap ((fle));			/* open the gap before the current line */
	go to in_mode;				/* join common console input code */

ACTION (5):					/* replace addressed lines with input from console */
change:
	call defaults (li, le);
	call delete_text ();			/* get rid of the old text */
	b.modified = "1"b;				/* buffer is modified even if nothing is input here */


in_mode:						/* attempt to enter cheap input mode */
	if sys_info$service_system then do;
	     new_modes = "wake_tbl";
	     call iox_$modes (iox_$user_io, new_modes, old_modes, code);
	end;

	was_empty = (ilb < 1) & (ift > ife);		/* remember whether buffer was empty or not */

	pi_label = in_mode;				/* setup recovery info for promote */
	call input (ifp, ilb);			/* input from console, append to input buffer file */
	pi_label = nx_line;				/* kill input flag to promote */

/* If we have added a line which does not end in a newline then the gap spans
   within a line and violates standards.  Compact the line by finding the start
   and end of the last line entered and opening the gap before it.
*/

	call last_line (ilb);			/* position at last line input from console */
	call open_gap ((li - 1));			/* compact the possible split line */
	call next_line (li);			/* find end of current line (may be across gap) */

	if sys_info$service_system then do;
	     new_modes = "^wake_tbl";			/* turn off cheap input */
	     call iox_$modes (iox_$user_io, new_modes, old_modes, code);
	end;

	if was_empty then				/* if buffer was empty, can no longer trust default path */
	     b.default_untrusted = ^b.default_locked & (b.default_path ^= "");

	go to next;				/* get next qedx request */
%page;
/*     **** substitute request  s/string1/string2/ replaces all occurrences of string1 with string2 ****

   This operation is done through constant and non-standard buffer gap moves.
   This is the only operation in which the buffer gap would not be at a line
   boundary.  Moves are done as the scan through the line is done, with
   processed characters left in the bottom section and unprocessed
   characters in the top.  As processing continues characters move down to
   the bottom section.  This permits all additions to the buffer to be done
   by appending to the lower section, and deletions to be done by
   moving the top pointer of the bottom section, with the one exception
   being if the last substitution has been done such that fli>lle, then
   the lower pointer of the upper section is moved.  This is due to the
   action of the sdsw increment of fli to bypass the NL, and the requirement
   to delete immediately, since post deletion is not possible.

   Post deletion of text is used where the replacing string is null, or
   contains &'s.  In the case of null replacement the construct s/^.// would
   replace the entire line with null, unless post deletion was done.
   In the case of & replacement, we have to retain the original source matched
   by the & to replace, therefore post deletion is necessary.
   Otherwise immediate deletion is done to retain the ability to edit an
   entire segment.

   Post deletion of text is accomplished by setting up an ilb correction factor
   to be applied after the next qx_search_file_.  This is to prevent /^.// from
   matching all characters, since deletion immediately would result in the
   end of line moving up and being found again.  This post deletion requires
   substitute to always pass through a final qx_search_file_ which doesn't find
   the string.  When this occurs the correction is already done.  The exception
   is already noted above, and only occurs if fli is incremented when the
   string ended in *$.
*/

ACTION (2):
	pi_label = sub_done;			/* say we are a substitute */
substitute:
	call defaults (li, le);			/* provide default addresses in needed */
	delim = t.c (ti);				/* pick up string delimiter */
	intsw = "0"b;				/* trap interrupts in long substitutes */
	subsw = "0"b;				/* set switch for first string */
	sdsw = "0"b;				/* initiate star-dollar match switch */

	ilb_offset = 0;				/* no post-deletion needed */

	tik = ti + 1;				/* set index to first char of string1 */
	i = tik;					/* and hold it.  */
	sub_comp_string = delim || EC || "\";		/* set compare for  delim conceal two char conceal */

sub_search:
	k = search (substr (tp -> a_string, tik, te - tik + 1), sub_comp_string);
						/* search for delim or conceal char */

	if k = 0 then do;				/* syntax error -- no delimiter */
sub_err:
	     call ioa_ ("Syntax error in substitute request.");
	     go to rq_err;
	end;

	kx = index (sub_comp_string, t.c (tik + k - 1));	/* which character was found? */
	go to sub_case (kx);			/* process case found */

sub_case (1):
	if ^subsw then do;				/* working on first string */
	     j = tik + k;				/* set index, first char string2 */
	     il = j - 1 - i;			/* save length of string1 */
	     if substr (tp -> a_string, j - 3, 2) = "*$"	/* check last chars of string1 for star dollar */
		then
		if substr (tp -> a_string, j - 4, 1) ^= EC
						/* check for conceal character */
		     then
		     if (substr (tp -> a_string, j - 5, 2)) ^= "\c" then
			if (substr (tp -> a_string, j - 5, 2)) ^= "\C" then sdsw = "1"b;
						/* found star dollar */
	     tik = j;
	     subsw = "1"b;				/* working on second string, string2 */
	     go to sub_search;
	end;
	else go to sub2;				/* found end of string2 */

sub_case (2):
	if (ti + k) < te then do;			/* is there a char after the concealed char? */
	     tik = (tik + k) + 1;			/* skip concealed char */
	     go to sub_search;			/* and continue scan  */
	end;
	else go to sub_err;				/* no delimiter found */

sub_case (3):
	if (tik + k) > te then go to sub_err;		/* there is no char after the escape, 134 */
	if (t.c (tik + k) = "C") | (t.c (tik + k) = "c")	/* is this conceal symbol */
	     then
	     if (tik + k) + 1 < te			/* is more after concealed char */
	     then do;
		tik = tik + k + 2;			/* start at next char */
		go to sub_search;
	     end;
	     else go to sub_err;			/* no delimiter */
	else do;					/* this was not a conceal symbol */
	     tik = tik + k;				/* search continues at next char */
	     go to sub_search;
	end;

sub2:
	ti = tik + k;				/* set index to next character after substitue request */
	je = tik + k - 2;				/* get index of last character in strin2 */
	call open_gap ((fli - 1));			/* setup buffer for substitution */

	subsw = "0"b;				/* initialize switch to indicate nothing found yet */
sub_loop:
	call qx_search_file_ (qid_ptr, tp, i, il, ifp, fli, lle, mi, me, ilb, ift, code);
						/* try to match on string1 */
	ilb = ilb - ilb_offset;			/* post-delete previous stuff */
	ilb_offset = 0;				/* and don't delete more til we are ready */
	if ^sys_info$service_system then call bce_check_abort;
	if intsw then do;				/* interrupt in substitution */
	     call ioa_ ("^a: Interrupt during substitute, remainder unprocessed.", qid.editor_name);
	     intsw = "0"b;
	     goto sub_done;
	end;

	if code ^= 0 then goto sub_done;		/* if nothing found, all done */
	ml = me - mi + 1;				/* otherwise, get length of string found */
	subsw = "1"b;				/* indicate something found */
	il = 0;					/* use canned regular expression next time thru */
	l = mi - fli;				/* copy buffer up to char(mi) */
	if l > 0 then				/* .. (if anything to copy) */
	     fli = fli + l;				/* set point of copy */

/* ****	This is the only point at which the gap is part way through a line **** */
	call open_gap ((fli - 1));

	l = j;					/* set index to beginning of input string */
sub_string_search:					/* search input string for special symbols */
	k = search (substr (tp -> a_string, l, je - l + 1), "&\");
						/* search for special symbol &, conceal = 031, "\" */
	if k = 0 then do;				/* no special symbols */
	     if je >= j then			/* only process if sub string not null */
		if ml ^= 0 then do;
		     call promote ((je - l + 1 - ml));	/* make sure space exists */
						/* Check here to prevent inadvertant deletion of matched string */
		     ift = ift + ml;		/* immediate delete since no & present */
		     ml = -1;			/* indicate already deleted */
		end;

	     saved_ift = ift;
	     call promote ((je - l + 1));		/* make sure space exists */

	     substr (ifp -> a_string, ilb + 1, (je - l + 1)) = substr (tp -> a_string, l, (je - l + 1));
						/* insert string */
	     ilb = ilb + je - l + 1;			/* update output buffer length */
	     b.modified = "1"b;			/* substitute is a modify */
	     go to sub_next;			/* see if more substitution */
	end;

	kx = index ("&\", t.c (l + k - 1));		/* which one found/ */
	go to do_sub (kx);				/* go process it */

do_sub (1):					/* found &, insert matched string here */
	if k > 1 then do;				/* input non special chars before special */
	     call promote ((k - 1));			/* ensure space exists */
	     substr (ifp -> a_string, ilb + 1, k - 1) = substr (tp -> a_string, l, k - 1);
						/* copy nonspecial chars */
	     ilb = ilb + k - 1;			/* update output coount */
	     b.modified = "1"b;			/* substitute is a modify */
	end;

/* Insertion of the original matched text is done by copying from the top
   to the bottom sections.  This permits multiple inclusions of text.  This
   operation is safe since data is moved from the top to the
   bottom, and buffer promotion ensures that the gap is big enough to
   prevent overlap. */
	if ml > 0 then do;				/* length of matched string */
	     call promote ((ml));			/* ensure space exists */
	     substr (ifp -> a_string, ilb + 1, ml) = substr (ifp -> a_string, mi, ml);
						/* copy section */
	     ilb = ilb + ml;			/* update end of bottom */
	     b.modified = "1"b;			/* substitute is a modify */
	end;

	l = l + k;				/* update index into input string */

	go to sub_string_search;			/* and continue search */

do_sub (2):					/* found conceal character 031 */
	ka = 0;					/* single character conceal symbol */
do_sub_conceal:					/* append string to here plus concealed character */
	call promote ((k));				/* ensure space exists */
	substr (ifp -> a_string, ilb + 1, k) = substr (tp -> a_string, l, k - 1) || t.c (l + k + ka);
	ilb = ilb + k;				/* update output string index */
	b.modified = "1"b;				/* substitute is a modify */
	l = l + k + ka + 1;				/* update input string index */
	go to sub_string_search;			/* and continue search */

do_sub (3):					/* found "\" so check for following "c" */
	if (t.c (k + l) = "C") | (t.c (k + l) = "c") then do;
						/* if two character conceal symbol */
	     ka = 1;				/* then set special character counter */
	     go to do_sub_conceal;			/* found two character conceal symbol */
	end;
	else do;					/* some other character */
	     call promote ((k));			/* ensure space exists */
	     substr (ifp -> a_string, ilb + 1, k) = substr (tp -> a_string, l, k);
						/* copy up to and including "\" */
	     ilb = ilb + k;				/* update output buffer index */
	     b.modified = "1"b;			/* substitute is a modify */
	     l = l + k;				/* set input index */
	     go to sub_string_search;			/* and continue search */
	end;

sub_next:
	if ml = 0 then				/* if matched string was null */
	     fli = fli + 1;				/* ensure we find a different null string next time */
	else do;					/* if matched string not null, resume search */
	     fli = me + 1;				/* set index after last matched character */
	     if sdsw				/* for star dollar match, step over new line. */
		then
		fli = fli + 1;			/* update search index */
	     if ml < 0 then ilb_offset = 0;
	     else if fli > lle then ift = ift + ml;	/* delete text if we will quit */
	     else ilb_offset = ml;			/* post-delete matched section from buffer */
	end;

/* This gap opening is necessary due to post-deletion.  If we opened the
   gap purely at fli-1 then .*$ would cause us to post-delete the 'NL'.
   By opening the gap at the end of the matched string everything
   is okay. */

	if sdsw then				/* Check if fli is overstepped */
	     call open_gap ((fli - 2));
	else call open_gap ((fli - 1));
	if fli <= lle then go to sub_loop;		/* until end of addressed portion of buffer reached */
sub_done:
	call last_line (min (fli, lle));		/* find start of this line */
	call open_gap ((li - 1));			/* fixup gap to line boundary */
	call next_line (lle);			/* set current line to end of range */

/* The following call to last_line is necessary to find the true beginning
   of the current line, since last_line and next_line both set the other end
   of the line, one must have at least one of them supplied with a true end.
   The above next_line truely sets up the end of the line, the following
   last_line truely sets up the beginning. */

	call last_line (le);

/* **** After this point buffer is again following line gap standards **** */

	if ^subsw then do;				/* error if nothing found */
	     call edx_util_$end_buffer (qid_ptr, code);	/* attempt to pop buffer recursion stack */
	     if code = 0 then go to nx_line;		/* and continue execution in calling buffer */

	     call ioa_ ("Substitution failed.");	/* print error message if at recursion level 0 */
	     go to rq_err;				/* and treat as normal error */
	end;
	else go to next;				/* go pick up next request */
%page;
/* * * * *  execute request ... pass remainder of line to command processor (i.e. escape to command system) * */

ACTION (15):
execute:
	substr (tp -> a_string, 1, (ti - 1)) = " ";	/* blank out preceding portion of request line */
	pi_label = nx_line;				/* allow command to be aborted */
	if sys_info$service_system then do;
	     pi_sw = "1"b;				/* by means of a program interrupt */
	     call cu_$cp (tp, te, code);		/* pass request line to command processor */
	     pi_sw = "0"b;				/* disable program interrupt upon return */
	end;
	else call ioa_ ("^a: Escape to command level not allowed.", qid.editor_name);
	go to nx_line;				/* get fresh request line from input stream */



/* * * * * buffer request ..... change working buffer after saving status of current buffer * * * * * * * * * */

ACTION (7):
buffer:
	call save_buffer_state ();			/* save previous buffer's state */
	call edx_util_$get_buffer (qid_ptr, tp, ti, te, tname, tbp);
						/* pick up pointer to control block of new buffer */
	if tbp = null then go to rq_err;
	call get_buffer_state (tbp);			/* instantiate new one */
	go to next;
%page;
/*     **** move request   move addressed lines from current buffer into auxilliary buffer ****

   This move is directly borrowed from write, and print.  It does not alter the
   current line, or move the gap. */

ACTION (8):
move:
	call defaults (li, le);			/* provide default addresses in needed */
	call edx_util_$get_buffer (qid_ptr, tp, ti, te, tname, tbp);
						/* get pointer to control block of specified buffer */
	if tbp = null then go to rq_err;
	fp = tbp -> b.dp;				/* get pointer to buffer file */
	if lle <= ilb | fli >= ift then do;		/* portion addressed is purely in bottom or top */
	     fe = lle - fli + 1;
	     if fe > sys_info$max_seg_size * 4 then do;
move_overflow:
		call ioa_ ("^a: Buffer full!! Move not performed.", qid.editor_name);
		goto rq_err;
	     end;
	     substr (fp -> a_string, 1, fe) = substr (ifp -> a_string, fli, fe);
						/* copy specified portion of buffer into new buffer */
	end;
	else if fli <= ilb then do;			/* top in top, bottom in bottom */
	     fe = lle - ift + 1 + ilb - fli + 1;
	     if fe > sys_info$max_seg_size * 4 then goto move_overflow;
	     substr (fp -> a_string, 1, ilb - fli + 1) = substr (ifp -> a_string, fli, ilb - fli + 1);
	     substr (fp -> a_string, ilb - fli + 2, lle - ift + 1) = substr (ifp -> a_string, ift, lle - ift + 1);
	end;
	if fe < 4 * 4 * 1024 then i = 4 * 4 * 1024;
	else if fe < 16 * 4 * 1024 then i = 16 * 4 * 1024;
	else if fe < 64 * 4 * 1024 then i = 64 * 4 * 1024;
	else i = 255 * 4 * 1024;
	i = min (i, sys_info$max_seg_size * 4);

	tbp -> b.lb = fe;
	tbp -> b.de = i;				/* update buffer status */
	tbp -> b.ft = i + 1;			/* upper buffer is empty */
	tbp -> b.li = 1;				/* .. */
	tbp -> b.le = index (substr (fp -> a_string, 1, fe), NL);
	if tbp -> b.le = 0 then tbp -> b.le = fe;	/* set to last line */
	if tbp -> b.le = 0 then tbp -> b.le = ilb;	/* if no new line then set to end of buffer */
	tbp -> b.modified = "1"b;			/* target buffer is now modified */
	tbp -> b.default_untrusted = ^tbp -> b.default_locked & (tbp -> b.default_path ^= "");
						/* target's pathname is no longer trusted */
	go to delete;				/* now delete addressed lines from current buffer */
%page;
/* * * * * status ("x") request ..... list status of all buffers (current and auxiliary) * * * * * * * * * * * */

ACTION (14):
status:
	call save_buffer_state ();
	call edx_util_$list_buffers (qid_ptr, curbuf, output_sw);
	go to next;				/* and go pick up next qedx request */
%page;
/*     **** print current line number ("=") request   prints out line number of current line in buffer ****

   This is one of the grottier pieces of code, not due to poor coding, but due
   to poor design for a paging system.  = must read the entire temp file, and
   count line feeds until the current character index of the current line is
   reached.  The modifications done here are entirely to account for the gap in
   the middle of the buffer. */

ACTION (13):
cur_line:
	call defaults (li, le);			/* provide default addresses if necessary */
	call last_line (lle);			/* set current line to addressed line */
	if ifp -> f.c (lle) = NL then
	     j = 0;				/* watch out for last line with no new-line character */
	else j = 1;				/* .. */
	i = 1;					/* start with first character */
	do while (i <= lle);			/* up to last character of current line */
	     if i > ilb & i < ift then i = ift;		/* fixup gap entry */
retry_top:
	     if i >= ift then
		k = index (substr (ifp -> a_string, i, lle - i + 1), NL);
						/* find a new line */
	     else do;
		k = index (substr (ifp -> a_string, i, ilb - i + 1), NL);
						/* find a new line */
		if k = 0 & ift <= ife then do;	/* move to upper and continue line */
		     i = ift;
		     goto retry_top;
		end;
	     end;
	     if k = 0 then
		i = lle + 1;			/* done */
	     else j = j + 1;			/* add to count of new lines */
	     i = i + k;				/* start with next character  */
	end;
	call ioa_ ("^d", j);			/* print out line number */
	go to next;				/* get next qedx request */
%page;
/*     **** global/exclude request  repeat given request for lines containing (or not containing) reg. exp ****

   This command may move the gap, for deletion, if it finds a line which must
   be deleted.  At this point the gap will be opened below the next
   line to be processed.  This means all operations will execute on a
   contiguous buffer.  Deletion is done simply by moving the ift pointer up to
   indicate that the line no longer exists in the buffer. */

ACTION (16):
exclude:
	xsw = "1"b;				/* exclude request */
	go to gb1;				/* set switch and join common code */

ACTION (12):
global:
	xsw = "0"b;				/* global request */
gb1:
	call defaults (1, ife);			/* provide default addresses (1,$) if necessary */
	if ti > te then go to gb_err;			/* error if nothing follows g or v request */
	ch = t.c (ti);				/* get request following global request */
	if ch ^= "p" then
	     if ch ^= "d" then
		if ch ^= "=" then do;		/* check for valid global request */
gb_err:
		     call ioa_ ("Syntax error in global request.");
		     go to rq_err;
		end;
	delim = t.c (ti + 1);			/* pick up regular expression delimiter */
	i = ti + 2;				/* get index of first character of regular expression */
	do ti = i to te;				/* find end of regular expression */
	     cht = t.c (ti);			/* pickup one character */
	     if cht = delim then go to gb2;		/* found end of string */
	     else if cht = EC then ti = ti + 1;		/* escape in one character */
	     else if cht = "\" then
		if ti < te then
		     if (t.c (ti + 1) = "C") | (t.c (ti + 1) = "c") then ti = ti + 2;
						/* ... */
	end;
	go to gb_err;				/* error if end cannot be found */

gb2:
	il = ti - i;				/* get length of regular expression */
	ti = ti + 1;				/* leave request line index pointing to next character */
	l = 0;					/* initialize line counter */
	if ch ^= "=" then go to gb_loop;		/* count lines only for "=" request */
	do j = 1 to (fli - 1);			/* for "=" request up to starting line number */
	     if j > ilb & j < ift then j = ift;		/* move across gap */
	     if j <= fli - 1 then
		if ifp -> f.c (j) = NL then l = l + 1;	/* .. */
	end;
gb_loop:
	l = l + 1;				/* increment line counter */
	if fli > ilb & fli < ift then fli = ift;	/* move across gap */
	if fli > lle then goto gb_quit;
	le = index (substr (ifp -> a_string, fli, (lle - fli + 1)), NL);
						/* find end of next line */
	if le = 0 then
	     le = lle;				/* worry about no new-line at end of buffer */
	else le = fli + le - 1;			/* get index of end of line (NL character) */
	call qx_search_file_ (qid_ptr, tp, i, il, ifp, fli, le, mi, me, ilb, ift, code);
						/* search line for regular expression */
	if code > 1 then go to gb_quit;		/* bad regular expression */
	il = 0;					/* null regular expression to form // */
	if xsw then
	     if code ^= 0 then go to gb_test;		/* check for match on exclude request */
	if ^xsw then
	     if code = 0 then go to gb_test;		/* check for match on global request */
	fli = le + 1;				/* no match (global or exclude) skip to next line */
	go to gb_end;				/* .. */

gb_test:
	if ch = "p" then do;			/* match found, check for global print (p) request */
	     j = le - fli + 1;			/* compute number of characters in line to print */
	     pi_label = gb_quit;			/* in case of a quit */
	     pi_sw = "1"b;				/* activate the label */
	     call output_routine (output_sw, addr (ifp -> f.c (fli)), j, code);
						/* print line */
	     pi_sw = "0"b;				/* disable the label */
	     fli = le + 1;				/* move to next line */
	     if ^sys_info$service_system then call bce_check_abort;
	     if intsw then go to gb_quit;		/* abort request if program interrupt has occurred */
	end;
	else if ch = "d" then do;			/* check for global delete (d) request */
	     call open_gap ((fli - 1));		/* open gap below delete point */
	     ift = le + 1;				/* start of good text */
	     fli = ift;				/* move up index */
	     b.modified = "1"b;			/* deletion is a modification */
	     if ^sys_info$service_system then call bce_check_abort;
	     if intsw then go to gb_quit;		/* abort request if program interrupt has occurred */
	end;
	else if ch = "=" then do;			/* check for global "=" request (print line number) */
	     call ioa_ ("^d", l);			/* print line number */
	     fli = le + 1;				/* move to next line */
	     if ^sys_info$service_system then call bce_check_abort;
	     if intsw then go to gb_quit;		/* abort request if program interrupt has occurred */
	end;
gb_end:
	if fli <= lle then go to gb_loop;		/* check for last line processed */
gb_quit:
	if ch = "p" then call ioa_ ("");
	call last_line (lle);			/* when done, leave current line at last line processed */
	go to next;				/* and pick up next qedx request */
%page;
/* * * * * null request .......... change value of "." and get next request from input line */

ACTION (17):
nullrq:
	if ^flsw then go to next;			/* ignore request if no address given */
	call defaults (li, le);			/* provide default addresses if necessary */
	call last_line (lle);			/* change "." to last line addressed */
	go to next;


/* * * * * comment delimiter (") found ..... change value of "." to last line addressed and ignore rest of line */

ACTION (18):
comment:
	if ^flsw then go to nx_line;			/* ignore completely if no address given */
	call defaults (li, le);			/* provide default addresses if necessary */
	call last_line (lle);			/* change "." to last line addressed */
	go to nx_line;				/* ignore remainder of this request line */
%page;
/* * * * * * * * * * * * * * * * * * * *     INTERNAL PROCEDURES     * * * * * * * * * * * * * * * * * * * */

/* Cleans up the data structures used by this invocation of qedx_ */

cleanup_invocation_data:
     procedure ();

	if callers_io_region_ptr ^= null () then do;
	     call release_temp_segment_ (qid.editor_name, callers_io_region_ptr, (0));
	     callers_io_region_ptr = null ();
	end;

	call edx_util_$edx_cleanup (qid_ptr);

	call qx_search_file_$cleanup (qid_ptr);

	return;

     end cleanup_invocation_data;
%page;
/* Saves the current buffer's state variables */

save_buffer_state:
     procedure ();

	b.dp = ifp;
	b.de = ife;
	b.lb = ilb;
	b.ft = ift;
	b.li = li;
	b.le = le;

	return;

     end save_buffer_state;


/* Restores the state of the specifier buffer causing it to be current */

get_buffer_state:
     procedure (p_bp);

dcl  p_bp pointer parameter;

	bp = p_bp;				/* switch to new buffer */
	curbuf = b.name;				/* ... */

	ifp = b.dp;				/* pointer to buffer file */
	ife = b.de;				/* index of last character in buffer */
	ilb = b.lb;
	ift = b.ft;
	li = b.li;				/* index of first character of current line */
	le = b.le;				/* index of last character of current line */

	return;

     end get_buffer_state;
%page;
/* Determine the "file" to be read/written: only used by actual read/write requests */

determine_file:
     procedure (write_request, a_real_file, the_pathname, explicit_pathname);

dcl  write_request bit (1) aligned parameter;		/* an output operation */
dcl  a_real_file bit (1) aligned parameter;		/* set ON => using a "file" rather than caller's buffer */
dcl  the_pathname character (256) parameter;		/* set to the name of the "file" */
dcl  explicit_pathname bit (1) aligned parameter;		/* set ON => user supplied a pathname to the request */
dcl  l fixed binary (21);

	if b.callers_idx = 0 then			/* not a buffer known to our caller */
	     the_buffer_ptr = null ();
	else the_buffer_ptr = addr (qedx_info.buffers (b.callers_idx));

	do ti = ti to te while (t.c (ti) = " ");	/* skip leading blanks in path name */
	end;
	l = te - ti;				/* compute length of path name */

	if l > 0 then do;				/* have a pathname ... */
	     explicit_pathname = "1"b;
	     if qid.no_rw_path then do;		/* user specified path but is not allowed to do so */
		call ioa_ ("A pathname cannot be specified with the ^[w^;r^] request", write_request);
		go to rq_err;
	     end;
	     if l > length (the_pathname) then do;
		call com_err_ (error_table_$pathlong, qid.editor_name, "^a", substr (tp -> a_string, ti, l));
		b.default_untrusted = ^b.default_locked & (b.default_path ^= "");
		go to rq_err;
	     end;
	     a_real_file = "1"b;			/* will be reading from a segment all right */
	     the_pathname = substr (tp -> a_string, ti, l);
	end;					/* save the input pathname */

	else do;					/* determine source/destination */
	     explicit_pathname = "0"b;
	     a_real_file = ^b.default_is_region;	/* ... check if reading/writing a file */

	     if the_buffer_ptr ^= null () then		/* ... check that user may use default "pathname" */
		if the_buffer.read_write_region & b.default_is_region then
		     if (write_request & ^the_buffer.default_write_ok)
			| (^write_request & ^the_buffer.default_read_ok) then do;
			call ioa_ ("No pathname given.");
			go to rq_err;
		     end;

	     if ^write_request & b.default_is_region then /* can only read back original if buffer's empty */
		if ^((ift > ife) & (ilb < 1)) then do;
		     call ioa_ ("Cannot restore original text unless buffer is empty.");
		     go to rq_err;
		end;

	     if a_real_file then			/* verify that we have a pathname ... */
		if b.default_path ^= "" then
		     the_pathname = b.default_path;
		else do;
		     call ioa_ ("No pathname given.");
		     go to rq_err;
		end;
	end;

	return;

     end determine_file;
%page;
/* Read the "file" into the buffer: returns "1"b if successfull */

perform_read:
     procedure (a_real_file, the_pathname, explicit_pathname) returns (bit (1) aligned);

dcl  a_real_file bit (1) aligned parameter;		/* ON => reading from a real "file" vs. caller's buffer */
dcl  the_pathname character (256) parameter;		/* the file to be read */
dcl  explicit_pathname bit (1) aligned;			/* ON => above pathname given by the user */

dcl  file_ptr pointer;
dcl  dirname character (168);
dcl  (ename, component) character (32);
dcl  (was_empty, read_ok) bit (1) aligned;
dcl  trust_the_pathname bit (1);
dcl  (code, status_code) fixed binary (35);
dcl  file_bc fixed binary (24);
dcl  file_lth fixed binary (21);


/* Establish pointer/length of the "file" */

	if b.callers_idx = 0 then			/* our caller doesn't care about this buffer */
	     the_buffer_ptr = null ();
	else the_buffer_ptr = addr (qedx_info.buffers (b.callers_idx));

	if qedx_info.caller_does_io then do;		/* let the caller get the file for us */
	     local_qbii.version = QEDX_BUFFER_IO_INFO_VERSION_1;
	     local_qbii.editor_name = qid.editor_name;
	     local_qbii.pathname = the_pathname;
	     local_qbii.buffer_ptr = callers_io_region_ptr;
	     local_qbii.buffer_max_lth = 4 * sys_info$max_seg_size;
	     local_qbii.direction = QEDX_READ_FILE;
	     string (local_qbii.flags) = ""b;
	     local_qbii.default_pathname = ^explicit_pathname;
	     call qedx_info.buffer_io (addr (local_qbii), read_ok);
	     if ^read_ok then do;			/* caller will print any error messages */
		if explicit_pathname then b.default_untrusted = ^b.default_locked & (b.default_path ^= "");
		return ("0"b);
	     end;
	     file_ptr = callers_io_region_ptr;
	     file_lth = local_qbii.buffer_lth;
	end;

	else if a_real_file then do;			/* get it from an honest to God file */
	     if sys_info$service_system then do;
		call expand_pathname_$component (the_pathname, dirname, ename, component, code);
		if code ^= 0 then do;
		     call com_err_ (code, qid.editor_name, "^a", the_pathname);
		     if explicit_pathname then b.default_untrusted = ^b.default_locked & (b.default_path ^= "");
		     return ("0"b);
		end;
		call initiate_file_$component (dirname, ename, component, R_ACCESS, file_ptr, file_bc, code);
		if code ^= 0 then do;		/* can't get it */
		     if code = error_table_$dirseg then do;
			call hcs_$status_minf (dirname, ename, CHASE, 0, file_bc, status_code);
			if (status_code = 0) & (file_bc ^= 0) then
			     call com_err_ (0, qid.editor_name, "This operation is not allowed for an MSF. ^a",
				pathname_$component (dirname, ename, component));
			else call com_err_ (code, qid.editor_name, "^a",
				pathname_$component (dirname, ename, component));
		     end;
		     else call com_err_ (code, qid.editor_name, "^a", pathname_$component (dirname, ename, component))
			     ;
		     if explicit_pathname & (code ^= error_table_$moderr) & (code ^= error_table_$no_r_permission)
			then
			b.default_untrusted = ^b.default_locked & (b.default_path ^= "");
		     return ("0"b);
		end;
		file_lth = divide ((file_bc + 8), 9, 21, 0);
	     end;
	     else do;
		call bootload_fs_$get_ptr (the_pathname, file_ptr, file_lth, code);
		if code ^= 0 then do;
		     call com_err_ (code, qid.editor_name, "^a", the_pathname);
		     if explicit_pathname then b.default_untrusted = ^b.default_locked & (b.default_path ^= "");
		     return ("0"b);
		end;
	     end;
	end;

	else do;					/* read from the caller's buffer */
	     file_ptr = the_buffer.region_ptr;
	     file_lth = min (the_buffer.region_final_lth, the_buffer.region_max_lth);
	end;


/* Check if reading with an untrustworthy default pathname and ask for permission if so */

	if b.default_untrusted & ^explicit_pathname then do;
	     if sys_info$service_system then
		call command_query_$yes_no (trust_the_pathname, 0, qid.editor_name, TRUSTED_PATHNAMES_EXPLANATION,
		     "Do you wish to ^a with the untrustworthy default pathname ^a?", "read", the_pathname);
	     else call bce_query$yes_no (trust_the_pathname, TRUSTED_PATHNAMES_EXPLANATION);
	     if trust_the_pathname then
		;				/* user says it's OK ... */
	     else go to rq_err;			/* ... punt */
	end;

	else trust_the_pathname = "0"b;		/* be sure it's initialized */


/* Move the data into the buffer */

	was_empty = (ilb < 1) & (ift > ife);		/* remember whether buffer was empty or not */

	call open_gap ((fle));			/* open a gap to add after */
	call promote (file_lth);			/* ensure space exists */

	le = ift - 1;				/* mark end of buffer */
	ift = ift - file_lth;			/* setup location where we will read */

	substr (ifp -> a_string, ift, file_lth) = substr (file_ptr -> a_string, 1, file_lth);
						/* copy file */

	file_lth = le;				/* remember position of end of last line */
	call next_line (ift);			/* get end of first line of new data */
	call last_line (le);			/* get start of first line of data (and maybe more) */
	call open_gap ((li - 1));			/* open gap at start of line (which might be in lower) */
	call last_line (file_lth);			/* end of buffer has last line */
	call next_line (li);			/* ensure a whole line */


/* Set default pathname if necessary and cleanup */

	if b.default_locked then do;			/* pathname is locked */
	     b.default_untrusted = "0"b;
	     b.modified = ^was_empty | explicit_pathname; /* ... make sure 1,$dr works right */
	end;

	else if was_empty then do;			/* empty and not locked: set new default pathname */
	     if sys_info$service_system then
		if a_real_file & ^qedx_info.caller_does_io then
		     b.default_path = pathname_$component (dirname, ename, component);
		else b.default_path = the_pathname;	/* ... if not from a file it wasn't expanded */
	     else b.default_path = the_pathname;
	     b.default_is_region = ^a_real_file;	/* ... might have been caller's buffer */
	     b.default_untrusted = "0"b;		/* ... we trust the pathname again */
	     b.modified = "0"b;			/* ... and this buffer is no longer modified */
	end;

	else do;					/* buffer wasn't empty */
	     b.default_untrusted = (b.default_path ^= "");/* ... we can't trust the default anymore (if there is one) */
	     b.modified = "1"b;			/* ... and the buffer is modified */
	end;

	if sys_info$service_system then
	     if a_real_file & ^qedx_info.caller_does_io then
						/* terminate it when done */
		call terminate_file_ (file_ptr, 0, TERM_FILE_TERM, (0));

	return ("1"b);				/* success */

     end perform_read;
%page;
/* Write the specified portion of the buffer into the "file": returns "1"b if successful */

perform_write:
     procedure (a_real_file, the_pathname, explicit_pathname, issue_truncation_warning) returns (bit (1) aligned);

dcl  a_real_file bit (1) aligned parameter;		/* ON => writing to a file vs. caller's buffer */
dcl  the_pathname character (256) parameter;		/* the name of the file */
dcl  explicit_pathname bit (1) aligned parameter;		/* ON => user specified a pathname to the write request */
dcl  issue_truncation_warning bit (1) aligned parameter;	/* ON => if it won't fit in caller's buffer: tell the user */

dcl  file_ptr pointer;
dcl  dirname character (168);
dcl  ename character (32);
dcl  (split_data, write_ok, created_file, wrote_whole_buffer) bit (1) aligned;
dcl  trust_the_pathname bit (1);
dcl  (code, status_code) fixed binary (35);
dcl  file_bc fixed binary (24);
dcl  file_lth fixed binary (21);


	if b.callers_idx = 0 then			/* caller doesn't care about this buffer */
	     the_buffer_ptr = null ();
	else the_buffer_ptr = addr (qedx_info.buffers (b.callers_idx));

	if (lle <= ilb) | (fli >= ift) then do;		/* all data is in one half of the buffer */
	     split_data = "0"b;
	     file_lth = lle - fli + 1;
	end;
	else do;					/* data spans the gap */
	     split_data = "1"b;
	     file_lth = (ilb - fli + 1) + (lle - ift + 1);
	end;


/* Check if writing with an untrustworthy default pathname and ask for permission if so */

	if b.default_untrusted & ^explicit_pathname then do;
	     if sys_info$service_system then
		call command_query_$yes_no (trust_the_pathname, 0, qid.editor_name, TRUSTED_PATHNAMES_EXPLANATION,
		     "Do you wish to ^a with the untrustworthy default pathname ^a?", "write", the_pathname);
	     else call bce_query$yes_no (trust_the_pathname, TRUSTED_PATHNAMES_EXPLANATION);
	     if trust_the_pathname then		/* user says it's OK ... */
		b.default_untrusted = "0"b;
	     else go to rq_err;			/* ... punt */
	end;

	else trust_the_pathname = "0"b;		/* be sure this is properly initialized */


	if qedx_info.caller_does_io then do;

/* Caller does actual I/O: put the portion of the buffer being written into out buffer and have the caller write it */

	     call put_data (callers_io_region_ptr);

	     local_qbii.version = QEDX_BUFFER_IO_INFO_VERSION_1;
	     local_qbii.editor_name = qid.editor_name;
	     local_qbii.pathname = the_pathname;
	     local_qbii.buffer_ptr = callers_io_region_ptr;
	     local_qbii.buffer_lth = file_lth;
	     local_qbii.direction = QEDX_WRITE_FILE;
	     string (local_qbii.flags) = ""b;
	     local_qbii.default_pathname = ^explicit_pathname;

	     call qedx_info.buffer_io (addr (local_qbii), write_ok);
	     if ^write_ok then do;			/* failed: caller has already printed reason */
		if explicit_pathname then b.default_untrusted = ^b.default_locked & (b.default_path ^= "");
		return ("0"b);
	     end;
	end;


	else if a_real_file then do;
	     if sys_info$service_system then do;

/* A real file: initiate/create the file and then put the data into it (do not accept archive component pathnames) */

		call expand_pathname_ (the_pathname, dirname, ename, code);
		if code ^= 0 then do;
		     if code = error_table_$archive_pathname then code = error_table_$archive_component_modification;
		     call com_err_ (code, qid.editor_name, "^a", the_pathname);
		     if explicit_pathname & (code ^= error_table_$archive_component_modification) then
			b.default_untrusted = ^b.default_locked & (b.default_path ^= "");
		     return ("0"b);
		end;

		call initiate_file_$create (dirname, ename, RW_ACCESS, file_ptr, created_file, (0), code);
		if created_file then do;		/* insure that the file just created has an acceptable name */
		     call check_entryname_ (ename, code);
		     if code ^= 0 then do;		/* ... sorry: be sure to delete the unwanted file */
			call terminate_file_ (file_ptr, 0, TERM_FILE_DELETE, (0));
			call com_err_ (code, qid.editor_name, "^a", pathname_ (dirname, ename));
			if explicit_pathname then b.default_untrusted = ^b.default_locked & (b.default_path ^= "");
			return ("0"b);
		     end;
		end;

		if code ^= 0 then do;		/* unable to initiate/create it */
		     if code = error_table_$dirseg then do;
			call hcs_$status_minf (dirname, ename, CHASE, 0, file_bc, status_code);
			if (status_code = 0) & (file_bc ^= 0) then
			     call com_err_ (0, qid.editor_name, "This operation is not allowed for an MSF. ^a",
				pathname_ (dirname, ename));
			else call com_err_ (code, qid.editor_name, "^a", pathname_ (dirname, ename));
		     end;
		     else call com_err_ (code, qid.editor_name, "^a", pathname_ (dirname, ename));
		     if explicit_pathname & (code ^= error_table_$moderr) & (code ^= error_table_$no_r_permission)
			& (code ^= error_table_$no_w_permission) then
			b.default_untrusted = ^b.default_locked & (b.default_path ^= "");
		     return ("0"b);
		end;
	     end;
	     else do;
		call bootload_fs_$put_ptr (the_pathname, file_lth, "0"b, file_ptr, code);
		if code ^= 0 then do;
		     call com_err_ (code, qid.editor_name, "^a", the_pathname);
		     if explicit_pathname then b.default_untrusted = ^b.default_locked & (b.default_path ^= "");
		     return ("0"b);
		end;
	     end;

	     call put_data (file_ptr);		/* do it */

	     if sys_info$service_system then do;
		call terminate_file_ (file_ptr, (9 * file_lth), TERM_FILE_TRUNC_BC_TERM, code);
		if code ^= 0 then do;		/* couldn't cleanup */
		     call com_err_ (code, qid.editor_name, "^a", pathname_ (dirname, ename));
		     if explicit_pathname then b.default_untrusted = ^b.default_locked & (b.default_path ^= "");
		     return ("0"b);
		end;
	     end;
	     else call bootload_fs_$flush_sys;		/* force write */
	end;


	else do;

/* Using the caller's input/output area: put the data out and issue truncation warning if necessary */

	     the_buffer.region_final_lth = file_lth;
	     file_lth = min (file_lth, the_buffer.region_max_lth);

	     call put_data (the_buffer.region_ptr);	/* stuff it */

	     if issue_truncation_warning & (the_buffer.region_final_lth > the_buffer.region_max_lth) then
		call com_err_ (0, qid.editor_name, "Warning: Buffer ^a will be truncated on exit from the editor.",
		     b.name);
	end;


/* Set default pathname and reset modified flag as appropriate */

/* format: off */
	wrote_whole_buffer = ((1 > ilb) & ((fli = ift) & (lle = ife))) |
			 ((ift > ife) & ((fli = 1) & (lle = ilb))) |
			 (((1 <= ilb) & (ift <= ife)) & ((fli = 1) & (lle = ife)));
						/* format: on */

	if b.default_locked then do;			/* pathname is locked */
	     b.default_untrusted = "0"b;		/* ... stays modified unless the entire buffer was ... */
	     b.modified = b.modified & (^wrote_whole_buffer | explicit_pathname);
	end;					/* ... ... written to the default pathname */

	else if wrote_whole_buffer then do;		/* wrote it all and not locked: set new default pathname */
	     if sys_info$service_system then
		if a_real_file & ^qedx_info.caller_does_io then
		     b.default_path = pathname_ (dirname, ename);
		else b.default_path = the_pathname;	/* ... not a real file: pathname isn't expanded */
	     else b.default_path = the_pathname;
	     b.default_is_region = ^a_real_file;	/* ... might have been caller's buffer */
	     b.modified = "0"b;			/* ... it's now safe */
	     b.default_untrusted = "0"b;		/* ... and we trust this pathname */
	end;

	else b.default_untrusted = (b.default_path ^= "");/* didn't write everything */

	return ("1"b);				/* success */



/* Internal to perform_write: actually moves the data from our buffer into the output area */

put_data:
	procedure (p_file_ptr);

dcl  p_file_ptr pointer parameter;
dcl  (part1_lth, part2_lth) fixed binary (21);

	     if split_data then do;			/* data spans the gap ... */
		part1_lth = min ((ilb - fli + 1), file_lth);
		part2_lth = min ((lle - ift + 1), (file_lth - part1_lth));
		substr (p_file_ptr -> a_string, 1, part1_lth) = substr (ifp -> a_string, fli, part1_lth);
		if part2_lth > 0 then		/* it all really fits */
		     substr (p_file_ptr -> a_string, (part1_lth + 1), part2_lth) =
			substr (ifp -> a_string, ift, part2_lth);
	     end;

	     else substr (p_file_ptr -> a_string, 1, file_lth) = substr (ifp -> a_string, fli, file_lth);

	     return;

	end put_data;

     end perform_write;
%page;
/* Locate line ending with specified character (ale) */

last_line:
     procedure (ale);

dcl  ale fixed bin (21);				/* index of last character of line to be isolated */

dcl  i fixed bin (21);				/* position returned from index */

	if ale < ift & ale > ilb then			/* never - never land in the gap */
	     le = ilb;
	else le = ale;				/* position at last character of line */
						/* Modified last_line search to use index function across gapped buffer. */

	li = le - 1;				/* miss current NL */

retry:
	if li >= ift then do;
	     i = index (reverse (substr (ifp -> a_string, ift, li - ift + 1)), NL);
						/* search upper */
	     if i = 0 then
		if ilb > 0 then do;			/* move across gap to lower and re-try search */
		     li = ilb;
		     goto retry;
		end;
		else do;				/* this must be the first line */
		     li = ift;
		     return;
		end;
	end;
	else do;					/* search lower section */
	     if li < 1 then do;
		li = 1;				/* force to bottom */
		return;
	     end;
	     if li > ilb then li = ilb;		/* force across gap */
	     i = index (reverse (substr (ifp -> a_string, 1, li)), NL);
	     if i = 0 then do;			/* not found - force to 1st character */
		li = 1;
		return;
	     end;
	end;
	li = li - i + 1;				/* setup start index */

/* correct for overstep */

	if li = ilb then
	     li = ift;				/* force up */
	else li = li + 1;				/* correct for pointing at NL */
	return;					/* and return */

     end last_line;
%page;
/* Locate line beginning with specified character (ali) */

next_line:
     procedure (ali);

dcl  ali fixed bin (21);				/* index of first character of line */

	if ali <= ife then do;			/* if line address within the buffer file */
	     if ali < ift & ali > ilb then		/* never - never land in the gap */
		li = ift;
	     else li = ali;				/* isolate line within file */
retry_top:
	     if li <= ilb then do;
		le = index (substr (ifp -> a_string, li, (ilb - li + 1)), NL);
						/* attempt to find NL char at end of this line */
		if le = 0 & ift <= ife then do;
		     li = ift;
		     goto retry_top;
		end;
	     end;
	     else le = index (substr (ifp -> a_string, li, (ife - li + 1)), NL);
						/* attempt to find NL char at end of this line */
	     if le = 0 then
		le = ife;				/* if no NL found, set line end to end of file */
	     else le = (li - 1) + le;			/* otherwise, compute index of NL within entire file */
	end;
	else do;					/* if line address is outside of buffer file */
	     li = ife + 1;				/* set line beginning to next char to be added to file */
	     le = ife;				/* indicate address points outside of buffer */
	end;
	return;

     end next_line;
%page;
/* Compute default addresses if necessary */

defaults:
     procedure (afli, alle);

dcl  afli fixed bin (21),				/* default first index for first address */
     alle fixed bin (21);				/* default last index for last address */

dcl  (qfli, qlle) fixed bin (21);

	if afli > ilb & afli < ift then
	     qfli = ift;				/* fixup default in gap */
	else qfli = afli;

	if alle > ilb & alle < ift then
	     qlle = ift;
	else qlle = alle;


	if ^flsw then do;				/* if no addresses provided */
	     fli, lli = qfli;			/* fill in addresses with given defaults */
	     fle, lle = qlle;			/* .. */
	end;
	else if ^llsw then do;			/* if only one addr, make second addr same as first */
	     if fli > ilb & fli < ift then
		lli = ift;
	     else lli = fli;			/* .. */
	     if fle > ilb & fle < ift then
		lle = ift;
	     else lle = fle;			/* .. */
	end;
	if (ift > ife) & (ilb < 1) then do;		/* check for empty buffer */
	     call ioa_ ("Buffer empty.");
	     go to rq_err;
	end;
	if (fli = 0) | (lle = 0) | (fli > ife) then do;	/* check for address outside of buffer */
	     call ioa_ ("Address out of buffer.");
	     go to rq_err;
	end;
	if fli > lle then do;			/* check for address wrap-around */
	     call ioa_ ("Address wrap-around.");
	     go to rq_err;
	end;
	if fli > ife then fli = ilb;			/* over-range */
	if lli > ife then lli = ilb;
	if fle > ife then fle = ilb;
	if lle > ife then lle = ilb;
	return;

     end defaults;
%page;
/*     **** input data from input stream, append to text ****

   This command auxilliary for i,a, and c, calls promote to increase the size
   of the working text file, prior to moving data from the working line buffer.
   Promote will move the working file to the next aste pool boundary if space
   is available and is needed, and may abort the input command if no space is
   available in a 255K segment. */


input:
     procedure (afp, afe);				/* procedure to append data from console to either file */

dcl  afp ptr,					/* pointer to file to which data is to be appended */
     afe fixed bin (21);				/* index of (current) last character in file */


	if t.c (ti) = NL then go to rd_line;		/* check for NL immediately following input request */
	if t.c (ti) = " " then ti = ti + 1;		/* skip space following input request */
	if ti <= te then go to inp_search;		/* pick up any remaining characters from current line */
rd_line:
	call edx_util_$read_ptr (qid_ptr, tp, length (iline), te);
						/* read a line (or portion of line) from input stream */
	ti = 1;					/* initialize character index */

inp_search:
	k = search (substr (tp -> a_string, ti, te - ti + 1), "\");
						/* search for end input (034), conceal (031) or escape ("\") */

	if k = 0 then do;				/* no special symbol found */
	     k = te - ti + 2;			/* set up string length */
inp_move_string:
	     call promote (k - 1);			/* ensure space exists */
	     substr (afp -> a_string, afe + 1, (k - 1)) = substr (tp -> a_string, ti, (k - 1));
	     afe = afe + (k - 1);			/* update output string index */
	     if (k - 1) > 0 then b.modified = "1"b;
	     go to rd_line;				/* get the next line */
	end;

	kx = index ("\", t.c (ti + (k - 1)));		/* which symbol was found? */
	go to inp_case (kx);			/* handle it */

inp_case (1):
	ka = 0;					/* found single character terminate symbol */
inp_act (1):
inp_act (2):
inp_final:
	call promote (k - 1);			/* ensure space exists */
	substr (afp -> a_string, afe + 1, (k - 1)) = substr (tp -> a_string, ti, (k - 1));
						/* move last of input */
	afe = afe + (k - 1);			/* update output string index */
	if (k - 1) > 0 then b.modified = "1"b;
	ti = ti + k + ka;				/* update input string index */
	return;					/* done with input */

inp_case (2):
	ka = 0;					/* found single character conceal */
inp_act (3):
inp_act (4):
inp_conceal:
	if (ti + k + ka) > te then go to inp_move_string; /* check length for character to conceal */
	call promote (k);				/* ensure space xists */
	substr (afp -> a_string, afe + 1, k) = substr (tp -> a_string, ti, (k - 1)) || t.c (ti + k + ka);
						/* move string and concealed character */
	afe = afe + k;				/* update output string */
	if k > 0 then b.modified = "1"b;
	ti = (ti + k + ka) + 1;			/* update input string */
	if ti > te then
	     go to rd_line;				/* get the next input line */
	else go to inp_search;			/* continue the search */

inp_case (3):
	ka = 1;					/* escape character found */

	kx = index ("fFcC", t.c (ti + k));		/* is this end input or conceal */

	if kx = 0					/* it is neither */
	then do;
	     call promote (k);			/* ensure space exists */
	     substr (afp -> a_string, afe + 1, k) = substr (tp -> a_string, ti, k);
						/* copy everything */
	     afe = afe + k;				/* update output string */
	     if k > 0 then b.modified = "1"b;
	     ti = ti + k;				/* update input string */
	     if ti > te then
		go to rd_line;
	     else go to inp_search;
	end;

	go to inp_act (kx);				/* otherwise end input or conceal */


     end input;
%page;
/*     **** interrupt handling ****

   Interrupt handling is done in one of two modes, either we want to be interrupted
   and the current operation suspended, or we don't.  This interrupt processing
   includes some verbosity to indicate what has happened.
*/


interrupt:
     procedure ();					/* procedure to handle program interrupts */

	if pi_sw then do;				/* are we currently accepting program interrupts */
	     pi_sw = "0"b;				/* if so, reset enable switch */
	     go to pi_label;			/* and do a non-local go to specified location */
	end;
	else do;					/* if no label assigned to handle interrupt */
	     intsw = "1"b;				/* set switch to indicate interrupt occurred */
	     return;				/* and otherwise ignore the program interrupt */
	end;

     end interrupt;
%page;
/*     **** Promote ****

   This is an auxilliary routine called each time data is added to the working
   text buffer.  It will check to ensure that the gap is big enough to contain
   the data.  Otherwise it will grow the working file to a size great enough
   to contain the data. This is done by determining which aste pool size will
   be needed, and then moving the top section of the working buffer to the top
   of the new aste size.  Pointers are then cleaned up and editing can continue.

   If there cannot be enough space left in a max len segment, then promote will
   dump an error message to the terminal, and will abort the current operation.

   This will mean that the current line will be lost for terminal input, and
   that the entire read will not be done for reading.  */

promote:
     procedure (string_length);

dcl  string_length fixed bin (21);

dcl  (new_fe, new_ft) fixed bin (21);

dcl  offset_action fixed bin (21);

	if (ife - ift + 1) + (ilb) + string_length > ife then do;
						/* determine end of next pool */
	     new_fe = ife;
	     do while ((ife - ift + 1) + ilb + string_length > new_fe);
		if new_fe >= sys_info$max_seg_size * 4 then do;
						/* error on size */
		     if pi_label = sub_done then do;
			call ioa_ ("^a: Segment full!! Skipping remaining substitutions.", qid.editor_name);
			goto sub_done;
		     end;

		     if pi_label = in_mode then
			call ioa_ ("^a: Segment full!! Last line of input lost - back to command mode.",
			     qid.editor_name);
		     else call ioa_ ("^a: Read will not fit in buffer - read not performed.", qid.editor_name);
		     if pi_label = in_mode then call last_line (ilb);
						/* fixup last line input for input cleanup */
		     goto rq_err;
		end;
		else new_fe = min (new_fe * 4, sys_info$max_seg_size * 4);
	     end;
	     new_ft = ift - ife + new_fe;

	     if ife - ift >= 0 then do;		/* top exists and must be moved */
		call mrl_ (addr (substr (ifp -> a_string, ift)), (ife - ift + 1),
		     addr (substr (ifp -> a_string, new_ft)), (ife - ift + 1));
	     end;

/* update current line pointers if they fall within the upper part. */

	     offset_action = new_ft - ift;
	     if lle >= ift then lle = lle + offset_action;
	     if lli >= ift then lli = lli + offset_action;
	     if le >= ift then le = le + offset_action;
	     if li >= ift then li = li + offset_action;

	     if mi >= ift then mi = mi + offset_action;
	     if me >= ift then me = me + offset_action;
	     if fli >= ift then fli = fli + offset_action;

	     if b.ti >= ift then do;
		b.ti = b.ti + offset_action;
		b.te = b.te + offset_action;
	     end;

	     ife = new_fe;
	     ift = new_ft;
	end;

     end promote;
%page;
/* Open_gap is used to open a processing gap in the text buffer at the
   point of the current line.  This may require text to be moved up or down at
   the current gap.  When data has been moved appropriate pointers are cleaned
   up and moved if they were in the section of text which was moved. */

open_gap:
     procedure (gap_index);

/* gap is opened after the specified index */

dcl  gap_index fixed bin (21);

dcl  offset_action fixed bin (21);

dcl  gap fixed bin (21);

	if ilb ^= gap_index & ift - 1 ^= gap_index then do;
						/* gap not at  current index */
	     if gap_index <= ilb then do;		/* index in bottom, move upper bottom up */
		gap = ilb - gap_index;
		call mrl_ (addr (substr (ifp -> a_string, gap_index + 1)), gap,
		     addr (substr (ifp -> a_string, ift - gap)), gap);
		offset_action = -gap_index + ift - gap - 1;
						/* form offset for index movement */
		if li <= ilb & li > gap_index then li = li + offset_action;
		if le <= ilb & le > gap_index then le = le + offset_action;
		if lli <= ilb & lli > gap_index then lli = lli + offset_action;
		if lle <= ilb & lle > gap_index then lle = lle + offset_action;
		if fli <= ilb & fli > gap_index then fli = fli + offset_action;
		if fle <= ilb & fle > gap_index then fle = fle + offset_action;

		if b.ti <= ilb & b.ti > gap_index then b.ti = b.ti + offset_action;

		ift = ift - gap;
		ilb = ilb - gap;

		if b.ti <= ilb then
		     b.te = ilb;
		else b.te = ife;
	     end;
	     else do;
		gap = gap_index - ift + 1;
		substr (ifp -> a_string, ilb + 1, gap) = substr (ifp -> a_string, ift, gap);
		offset_action = -ift + ilb + 1;	/* offset for index move */
		if li >= ift & li <= gap_index then li = li + offset_action;
		if le >= ift & le <= gap_index then le = le + offset_action;
		if lli >= ift & lli <= gap_index then lli = lli + offset_action;
		if lle >= ift & lle <= gap_index then lle = lle + offset_action;

		if b.ti >= ift & b.ti <= gap_index then b.ti = b.ti + offset_action;

		if fli >= ift & fli <= gap_index then fli = fli + offset_action;
		if fle >= ift & fle <= gap_index then fle = fle + offset_action;
		ilb = ilb + gap;
		ift = ift + gap;
		if b.ti <= ilb then
		     b.te = ilb;
		else b.te = ife;

	     end;
	end;

     end open_gap;
%page;
%include qedx_internal_data;
%page;
%include qedx_info;
%page;
%include qedx_buffer_io_info;
%page;
%include access_mode_values;

%include sub_err_flags;

%include terminate_file;

     end qedx_;
