/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/****^  HISTORY COMMENTS:
  1) change(1986-04-17,LJAdams), approve(1986-04-17,MCR7327),
     audit(1986-04-17,Lippard), install(1986-04-24,MR12.0-1048):
     First installation of new module.
  2) change(1986-04-24,LJAdams), approve(1986-04-17,MCR7327),
     audit(1986-04-25,Gilcrease), install(1986-04-25,MR12.0-1049):
     PBF to Installation ID 1048.  Put heading on info seg
     display only if there are multiple info segs with
     the same name.
  3) change(1986-05-08,LJAdams), approve(1986-05-14,MCR7416),
     audit(1986-05-28,Gilcrease), install(1986-06-12,MR12.0-1074):
     Changed the algorithm in get_title_list to split lines properly.  For
     subroutine info segments, if -bf is requested, print a message indicating
     that no brief information is available and ask the user if detail info is
     wanted.  If the answer is no return to command level, if the answer is
     yes print the introductory paragraph.
  4) change(1986-07-24,LJAdams), approve(1986-07-31,MCR7506),
     audit(1986-10-29,GDixon), install(1986-10-30,MR12.0-1203):
     Fixed problem with help -title improperly displaying lines.
     
     Fixed problem with entry point lists not being displayed in groups of
     15 (format_list Mpgs = 1 then list.Npghs = 1).
     
     Fixed problem with extra blank line being displayed on More help? line.
     
     If ep foo$bar has been requested help will now immediately begin printing
     the ep description without first asking the user if he wants to see it.
     (phx0717)
     
     Fixed problem that typing scn with no arguments would remain at the same
     section instead of searching for the next match. (phx09952, phx06043)
     
     help -search will now include the section titles in the text being
     searched.
     
     help time_format.gi.info -bf should work (phx18720).
  5) change(1987-01-06,LJAdams), approve(1987-01-06,PBF7506),
     audit(1987-01-06,GDixon), install(1987-01-07,MR12.0-1262):
     Fixed problem in format_list that when the max array bounds had been met
     and more data still needed to be formatted the remaining data was
     ignored.  Array bounds are now being recomputed in this situation.
  6) change(1987-01-19,LJAdams), approve(1987-09-03,MCR7766),
     audit(1988-09-03,GDixon), install(1988-09-13,MR12.2-1109):
     Fixed problem with -bf not properly display List of... lines that started
     with a 1 or 2.
     
     Added to the rest response -all_entrypoints (-aep) which will print the
     rest of the remaining entrypoints. (phx05455, phx11988)
     
     The total length of entrypoints (:Entry:) was being miscalculated by one
     character.
     
     Added a -case_sensitive (-cs) and -non_case_sensitive (-ncs) to the
     section and search requests.  (phx09975)
     
     Added the -list_entry_points (lep) argument/response.
     (phx02785, phx03662, phx05841, phx08613)
     
     Added the list_requests (lr) option to help.
     
     Changed version to Vhelp_args_3.
  7) change(1988-02-17,LJAdams), approve(1988-03-07,MCR7857),
     audit(1988-09-03,GDixon), install(1988-09-13,MR12.2-1109):
     Changed to use the help_args.help_data_ptr which points to a second
     help_args structure that is used for the list_request operation.
     
     format_list was improperly formatting data if the terminal had a
     line length set to >80.  Lengthened line buffer to
     MAX_HELP_LINE_SIZE.
  8) change(2019-05-24,GDixon), approve(2019-05-24,MCR10056),
     audit(2019-06-01,Swenson), install(2019-06-01,MR12.6g-0021):
     Change help and help_ (which call the help_rql_ internal procedure) to always
     display dates in header lines and :Entry: subroutine headers in iso_date format.
  9) change(2021-02-15,GDixon), approve(2021-02-15,MCR10085),
     audit(2021-03-17,Swenson), install(2021-03-17,MR12.6g-0052):
     Create new old_help_rql_.pl1 based on help_rql_.pl1 source for use in
     preserving the old help command in bound_old_help_.
                                                   END HISTORY COMMENTS */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* Name:  help_rql_								*/
/*									*/
/* This subroutine implements the help command's request loop.			*/
/*									*/
/* Status									*/
/*									*/
/* 0) Created:  June 1983 by G C Dixon - by dividing help_ into subroutines.		*/
/* 1) Modified: April 1985 by L. Adams - rewrote parsing routines to                      */
/*              use line logic.                                                           */
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

/* format: style2,ind2,ll131,dclind4,idind15,comcol41,linecom,ifthen */
old_help_rql_:
  procedure (procedure_name, suffix, Phelp_args, Iinfo, Ninfos_printed, Ninfos, Nlast_info_no_brief_data, 
       Nlast_info_cross_ref, PDinfo_seg_, APseg, PDeps, Pquery_answers, PI_LABEL, Sprint_inhibit, Acode);

    dcl procedure_name char (*),
        suffix	   char (*),
        Iinfo	   fixed bin,	/* Number of the info being processed.		*/
        Ninfos_printed fixed bin,	/* Number of infos for which something has printed*/
        Ninfos	   fixed bin (24),	/* Number of infos handled during this invocation	*/
        Nlast_info_no_brief_data
		   fixed bin,	/* Last info processed not containing Syntax sect.*/
        Nlast_info_cross_ref
		   fixed bin,	/* Last info processed with Scross_ref on.	*/
				/* as diagnosed by get_brief_data.		*/
        PDinfo_seg_	   ptr,		/* ptr to structure describing the info.	*/
        APseg	   ptr,		/* ptr to base of seg containing the info.	*/
        PDeps	   ptr,		/* ptr to Deps structure.			*/
        Pquery_answers ptr,		/* ptr to list of allowed responses.		*/
        PI_LABEL	   label variable,	/* label to go to upon program interrupt.	*/
        Sprint_inhibit bit (1) aligned,
        Acode	   fixed bin (35);

    dcl Iep	   fixed bin,	/* subscript of current entry point or info	*/
				/*   (logical info segment) being processed.	*/
        Iunit	   fixed bin,	/* subscript of current unit (paragraph).	*/
        Iunit_end	   fixed bin,
        Iunit_search   fixed bin,	/* searching begins with this unit.		*/
        Iunit_syntax   (10) fixed bin,	/* indices of syntax units.			*/
        Lcount	   fixed bin,
        Linfo_name	   fixed bin,
        list_of	   bit (1),	/* indicates if list is a list of items           */
        Loutput	   fixed bin,
        Loutput_line   fixed bin,	/* Length of terminal user's output line.	*/
        Lpgh	   fixed bin,
        Lseg	   fixed bin (21),
        (Ncommon_units, Nconsecutive_bad_ops, Nuncommon_units, Nprint_units)
		   fixed bin,
        (Nlines, Nlines_titles)
		   fixed bin,
        (Nlists_of_args, Nlists_of_bf_args)
		   fixed bin,
        No_list_elements		/* number of list elements in the entry point list*/
		   fixed bin,
        Nep_pghs	   fixed bin,	/* number of pghs in entry point list		*/
        Nunit_bf_prt   fixed bin,	/* number of brief units to print.		*/
        (Plist, Plist_of_titles, Plist_of_cas)
		   ptr,
        Pcommon_units  ptr,
        PDlinfo	   ptr,
        Pep_list	   ptr,		/* ptr to the entry point list		*/
        Plist_base	   ptr,
        Plists_of_args (18) ptr,
        Pnext_free_space
		   ptr,		/* ptr to next free word location in temp	*/
				/*   seg containing help_args.		*/
        Poutput	   ptr,
        Ppgh	   ptr,
        Pseg	   ptr,
        save_title	   char (80) varying,
        Scase_sensitive
		   bit (1),
        Sdescription_present
		   bit (1),
        Sep_list_printed
		   bit (1),
        Sfirst_time	   bit (1),
        Sfirst_pgh	   bit (1),
        Sfound	   bit (1) aligned,
        Sremove_line   bit (1),
        Syntax_section bit (1),
        Sprt_args	   bit (1),
        Sprt_bf_heading
		   bit (1),
        Sprt_list_of   bit (1),
        Sprt_entry_pts bit (1),
        Sprt_one_paragraph
		   bit (1),
        Sloop	   bit (1) aligned,
        (Snl1, Snl2)   bit (1) aligned, /* Switches used to compute if NL should be output.*/
        ISnl3	   fixed bin,
        Ssearch	   bit (1) aligned, /* on if -section/-search searching to be done.	*/
        Sseen	   bit (1) aligned, /* on if pgh already seen by user.		*/
        answer	   char (500) varying,
        code	   fixed bin (35),
        ct_lines	   fixed bin,
        ep_name	   char (65) varying,
        (i, j)	   fixed bin,
        match_result   fixed bin,
        new_section	   char (88) varying,
				/* title of new section in which match pgh found	*/
        op	   fixed bin,
        query	   char (200) varying,
        query_type	   fixed bin,
        ref_name	   char (32) varying,
		        yes_sw	   bit (1);


    dcl 1 Deps	   aligned based (PDeps),
				/* structure defining all entry points in log info*/
	2 Nlines	   fixed bin,	/*   number of lines in log info.		*/
	2 N	   fixed bin,	/*   total number of entry points in log info.	*/
	2 linfo	   (0:0 refer (Deps.N)),
				/*   description of each entry point.		*/
	  3 date	   fixed bin (71),	/*     binary date assoc with entry point.	*/
	  3 Nep_names
		   fixed bin,	/*     number of entry point names.		*/
	  3 ep_name  (20) char (32) var,
				/*     name of the entry point.		*/
	  3 PDlinfo  ptr,		/*     ptr to paragraph descriptors for this info.*/
	  3 Pstart   ptr,		/*     first character of entry point info.	*/
	  3 L	   fixed bin,	/*     length (in chars) of entry point info.	*/
	  3 header   char (88) varying,
				/*     its heading line.			*/
	  3 Nlines   fixed bin,	/*     number of lines in entry point info.	*/
	  3 S,			/*     switches:				*/
	  ( 4 seen_by_user,		/*       this entry point seen by the user.	*/
	    4 old_format
	    )	   bit (1) unal,	/*       this entry point contains \006 chars.	*/
	    4 pad1   bit (34) unal;

    dcl 1 Dlinfo	   aligned based (PDlinfo),
				/* structure defining all paragraphs (units) in	*/
				/*   an entry point (misnamed linfo).		*/
	2 Nunits	   fixed bin,	/*   number of units in this ep.		*/
	2 Nsections  fixed bin,	/*   number of units beginning a section.	*/
	2 unit	   (0 refer (Dlinfo.Nunits)),
				/*   unit (paragraph) descriptors.		*/
	  3 Pstart   ptr,		/*     ptr to first char of unit (excl. title).	*/
	  3 title	   char (80) varying,
				/*     title of the unit.			*/
	  3 L	   fixed bin (21),	/*     length of the unit (in chars).		*/
	  3 Nlines   fixed bin,	/*     number of lines in the unit.		*/
	  3 S	   aligned,	/*     switches.				*/
	  ( 4 scn,		/*       unit begins a new section.		*/
	    4 seen_by_user,		/*       unit has been seen by user.		*/
	    4 ep_list,		/*       unit is an entry point list, to be 	*/
				/*       generated by help_.			*/
	    4 arg_list,		/*       unit is Arguments or Control args.	*/
	    4 syntax_list,		/*       unit is Syntax                           */
	    4 list_of_list
	    )	   bit (1) unal,	/*       unit is a list of itemsor examples.      */
	    4 pad1   bit (12) unal,
	  3 Icommon_unit
		   fixed bin (17) unal;
				/*     Index of common pgh in common_units.	*/

    dcl 1 LIST	   aligned based,	/* structure used to format list of things to be	*/
	2 header,			/* output in columns.			*/
	  3 N	   fixed bin,	/*   number of list elements.			*/
	  3 Nreal	   fixed bin,	/*   number of filled list elements.		*/
	  3 Npghs	   fixed bin,	/*   number of filled paragraphs of formatted out.*/
	  3 Nrows	   fixed bin,	/*   number of rows in formatted output.	*/
	  3 Ncols	   fixed bin,	/*   number of columns in formatted output.	*/
	  3 ML	   (6) fixed bin,	/*   length of longest element in each column.	*/
	  3 title	   char (80) varying,
				/*   title of output list.			*/
	  3 Iunit	   fixed bin,	/*   unit no of pgh containing list elements.	*/
	2 group	   (0 refer (LIST.N)),
	  3 arg	   char (88) varying,
				/*   the argument.				*/
	  3 Snot_found
		   fixed bin,	/*   = 1 if no match found for the argument.	*/
	2 print_array
		   (0 refer (LIST.Npghs), 0 refer (LIST.Nrows)),
	  3 line_out char (MAX_HELP_LINE_SIZE);
				/* Array of lines to be output to the screen.     */


    dcl 1 ca	   aligned,	/* current control_arg STRs.			*/
	2 header	   like LIST.header,
	2 group	   (100) like LIST.group;

    dcl 1 lr	   aligned,	/* list_request structure			*/
	2 N	   fixed bin,
	2 ca	   (100) char (32) varying;

    dcl 1 common_units (Ncommon_units) aligned like Dlinfo.unit based (Pcommon_units);

    dcl 1 list	   aligned based (Plist),
	2 header	   like LIST.header,
	2 group	   (0 refer (list.N)) like LIST.group,
	2 print_array
		   (0 refer (list.Npghs), 0 refer (list.Nrows)) like LIST.print_array;
				/*struc containing lists of things to be output.	*/

    dcl 1 list_base	   aligned based (Plist_base),
				/* struc locating lists of things to be output.	*/
	2 N	   fixed bin,	/*   number of output lists now allocated.	*/
	2 Nmax	   fixed bin,	/*   max number of list ptrs allocatable.	*/
	2 Ispace_used_set
		   fixed bin,	/*   index of last list on which space used set.	*/
	2 Plists	   (0 refer (list_base.Nmax)) ptr;
				/*   ptrs to allocated lists.			*/

    dcl output	   char (Loutput) based (Poutput);

    dcl pgh	   char (Lpgh) based (Ppgh);

    dcl 1 query_answers
		   aligned based (Pquery_answers),
	2 header	   like LIST.header,
	2 group	   (0 refer (query_answers.N)) like LIST.group;

%include query_info;

    dcl 1 scn	   aligned,	/* current section STRs.			*/
	2 header	   like LIST.header,
	2 group	   (100) like LIST.group;

    dcl seg_char	   (Lseg) char (1) based (Pseg);

    dcl 1 srh	   aligned,	/* current search STRs.			*/
	2 header	   like LIST.header,
	2 group	   (100) like LIST.group;

    dcl (addr, addrel, addcharno, currentsize, dim, dimension, divide, hbound, index, length, ltrim, 
         max, maxlength, min, mod, null, reverse, rtrim, search, substr, sum, translate, verify)
		   builtin;

    dcl command_query_ entry options (variable),
        command_query_$yes_no
		   entry () options (variable),
        convert_date_to_binary_
		   entry (char (*), fixed bin (71), fixed bin (35)),
        date_time_$format 
		   entry (char(*), fixed bin(71), char(*), char(*)) returns(char(250) var),
        get_line_length_$switch
		   entry (ptr, fixed bin (35)) returns (fixed bin),
        (
        ioa_,
        ioa_$nnl,
        ioa_$rsnnl
        )		   entry options (variable),
        iox_$control   entry (ptr, char (*), ptr, fixed bin (35)),
        iox_$put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35)),
        ipc_$block	   entry (ptr, ptr, fixed bin (35));

   dcl CONSC_LINE_ARG_ID
		   char (1) int static options (constant) init (""),
				/* consecutive line arguments = \022		*/
        FALSE	   bit (1) int aligned static options (constant) init ("0"b),
        HELP_LINE_SIZE fixed bin int static options (constant) init (79),
        HT	   char (1) int static options (constant) init ("	"),
        HT_SP	   char (2) int static options (constant) init ("	 "),
        HT_SP_NL	   char (3) int static options (constant) init (" 
"),
        HT_SP_NL_VT	   char (4) int static options (constant) init ("	 
"),
        MAX_HELP_LINE_SIZE
		   fixed bin int static options (constant) init (136),
        ME	   char (4) int static options (constant) init ("help"),
        MULTI_LINE_ARG_ID
		   char (1) int static options (constant) init (""),
				/* multiple line arguments = \021		*/
        NL	   char (1) int static options (constant) init ("
"),
        NL_NL	   char (2) int static options (constant) init ("

"),
        OLD_HELP_PGH_CHAR
		   char (1) aligned int static options (constant) init (""),
				/* \006  */
        SPACES	   char (MAX_HELP_LINE_SIZE) aligned int static options (constant) init (" "),
        SP	   char (1) int static options (constant) init (" "),
        SP_SP	   char (2) int static options (constant) init ("  "),
        SP_SP_SP	   char (3) int static options (constant) init ("   "),
        TRUE	   bit (1) int aligned static options (constant) init ("1"b),
        colon	   char (1) int static options (constant) init (":"),
       (ep_list	   init (5),
        normal	   init (1),
        new_entry	   init (4),
        return_from_list_requests
		   init (6),
        search_unseen  init (3),
        some_unseen	   init (2)) fixed bin int static options(constant),
       (error_table_$fatal_error,
        error_table_$noentry,
        error_table_$nomatch)
        		   fixed bin (35) ext static,
       (exact_match	   init (2),
        match	   init (1),
        no_match	   init (0)) fixed bin int static options (constant),
        iox_$user_output
		   ptr ext static;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* Parse up the physical info segment into entry point pieces.			*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

    Acode = 0;
    PI_LABEL = RETURN;		/* Before any output starts, a pi skips to next	*/
				/* info.					*/

    query_info.version = query_info_version_6;
				/* initialize query info values		*/
    query_info.yes_or_no_sw = FALSE;
    query_info.suppress_name_sw = TRUE;
    query_info.query_code = 0;

    call initialize_switches;

    Loutput_line = min (MAX_HELP_LINE_SIZE, get_line_length_$switch (iox_$user_output, code));
    if code ^= 0 then
      Loutput_line = HELP_LINE_SIZE;	/* Get user's terminal line size.		*/

    Sprint_inhibit = FALSE;		/* Printing is not inhibited yet.		*/
    ca.N, scn.N, srh.N = 0;		/* No control_arg, search or section args done.	*/
    ref_name = "";			/* No entry point reference name set yet.	*/
    Pseg = APseg;
    Lseg = Dinfo_seg_.I;		/* Address first char of logical info.		*/
    Pseg = addr (seg_char (Dinfo_seg_.I));
    Lseg = Dinfo_seg_.L;		/* Address all/only log info we are printing.	*/
    call info$init (Pseg, Lseg);
    call parse_info_into_entry_points (Pseg, Lseg, PDeps);
				/* Parse up the log info into entry points.	*/



/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* Various kinds of output (arguments and control arguments, section titles, 		*/
/* entry point names, etc) are output in columnar lists.  More than one list		*/
/* may exist at a time.  Initialize array of list pointers to keep track of them.	*/
/* The lists themselves are appended to the end of the segment containing		*/
/* the help_args structure, as are all of the variable size structures used in help_.	*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

    Pnext_free_space = addrel (PDeps, currentsize (Deps));
				/* reuse space for lists, etc each time that	*/
				/* process_info_seg is called.		*/
    Plist_base = get_list_base (Pnext_free_space, currentsize (Deps), 30);
				/* get space for gen'l purpose list of lists.	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* 1) Get space for the descriptor of the paragraphs (units) in the common (or only) part	*/
/*     of the logical info.  Parse this common part into pgh units.			*/
/* 2) If there are other entry point descriptions in the log info, then		*/
/*    get space for their paragraph descriptors.					*/
/*    Parse them up into pghs, and append to their descriptors the common units		*/
/*    (paragraphs included in all entry points) obtained from the common info		*/
/*    descriptors created in step 1 above.					*/
/*    All entry point parts must be parsed now to get line count of entire info right.	*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

    Ncommon_units = 0;		/* No common info has been found yet.		*/
    Pep_list = null;		/* Initialize entry point list ptr		*/
    PDlinfo = Pnext_free_space;	/* get space for paragraph descriptions of common	*/
				/* or only part of logical info.		*/
    call parse_entry_point_into_units (Deps.linfo (0), Pcommon_units, Ncommon_units, PDlinfo);
    Pnext_free_space = set_space_used (PDlinfo, currentsize (Dlinfo));
    if Deps.N > 0 then
      do;				/* handle log. info w/ several entry point parts.	*/
        do Nuncommon_units = 2 to Dlinfo.Nunits while (^Dlinfo.unit (Nuncommon_units).S.scn);
				/* Find paragraphs in common part which are	*/
				/* shared by (common to) all entry point parts.	*/
        end;
        Nuncommon_units = Nuncommon_units - 1;
        Ncommon_units = Dlinfo.Nunits - Nuncommon_units;
        if (Ncommon_units = 0) & (Nuncommon_units = 1) then
	if length (Dlinfo.unit (1).title) > length ("Entry points in") then
	  if substr (Dlinfo.unit (1).title, 1, length ("Entry points in ")) = "Entry points in " then
	    do;
	      Nuncommon_units = 0;
	      Ncommon_units = 1;
	    end;
        if Ncommon_units > 0 then
	do;
	  Pcommon_units = addr (Dlinfo.unit (Nuncommon_units + 1));
	end;
        else Pcommon_units = PDlinfo;
        do i = 1 to Ncommon_units;	/* Find section of common part containing	*/
				/*   help-generated list of entry points in info.	*/
	if length (common_units (i).title) > 15 then
				/* 15 = length("Entry points in ").	*/
	  if substr (common_units (i).title, 1, 15) = "Entry points in " then
	    do;
	      common_units (i).S.ep_list = TRUE;
	      j = i;
	      do i = i to Ncommon_units;
				/* Remove any pghs following this special one	*/
				/*   from the common part of the info.		*/
	        Deps.linfo (0).Nlines = Deps.linfo (0).Nlines - common_units (i).Nlines - 2;
	      end;		/* Subtract line count of pghs following the	*/
				/* "Entry points in " section.		*/
	      Ncommon_units = j;	/* "Entry points in " is last pgh of info.	*/
	      Dlinfo.Nunits = Nuncommon_units + Ncommon_units;
	    end;
        end;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
/* First we build an entry point list to determine how many paragraphs */
/* it will consist of.  Once we know how big we are going to have to   */
/* grow our original list we adjust the size of the original and then  */
/* rebuild ep_list so that we can save the formatted output (print)    */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

        if Ncommon_units > 0 then
	if common_units (Ncommon_units).S.ep_list then
	  do;
	    Plist = get_list (Plist_base);
	    save_title = common_units (Ncommon_units).title;
	    if ref_name = "" then
	      if suffix = "" then
	        ref_name = rtrim (Dinfo_seg_.ent);
	      else ref_name =
		      substr (Dinfo_seg_.ent, 1,
		      32 - length (suffix) - index (reverse (Dinfo_seg_.ent), reverse (suffix) || "."));
	    call get_ep_list (ref_name, PDeps, Plist);
	    No_list_elements = list.N;/* save for possible use in -bf		*/
	    call format_list (Plist, divide (No_list_elements, 5, 17, 0) + 1, 0);
	    Ncommon_units = Ncommon_units - 1;
	    Dlinfo.Nunits = Nuncommon_units + Ncommon_units + list.Npghs;
	    call give_list_back (Plist_base, Plist);
	    Pnext_free_space = set_space_used (PDlinfo, currentsize (Dlinfo));
	    Plist = get_list (Plist_base);
				/* Build entry point list pghs in temp seg.	*/
	    list.title = save_title;
	    call get_ep_list (ref_name, PDeps, Plist);
	    call format_list (Plist, divide (list.N, 5, 17, 0) + 1, 0);
	    call set_list_size (Plist_base, Plist);
	    Pep_list = Plist;
	    Nep_pghs = list.Npghs;
	    Poutput, Pnext_free_space = set_space_used (Plist, currentsize (list));
              Deps.linfo (0).Nlines = Deps.linfo (0).Nlines + 2 * Ncommon_units;
                                        /* Add non-ep list heading lines                  */
	    do i = 1 to list.Npghs;	/* Create new entry point list pghs.		*/
	      call output_list (Plist, i, Poutput, Loutput, Nlines);

	      j, Ncommon_units = Ncommon_units + 1;
	      common_units (j).Pstart = Poutput;
				/*   Add new pghs to end of common units.	*/
	      common_units (j).L = Loutput;
	      common_units (j).Nlines = Nlines;
	      common_units (j).S = FALSE;
	      if i = 1 then
	        do;		/*   Include section title for 1st pgh of ep list.*/
		common_units (j).title = list.title;
		common_units (j).S.scn = TRUE;
	        end;
	      else
	        do;		/*   No section title for subsequent pghs.	*/
		common_units (j).title = "";
	        end;
	      common_units (j).S.ep_list = TRUE;
				/*   Remember how pghs got there (for debugging).	*/
	      Poutput, Pnext_free_space = set_space_used (Poutput, currentsize (output));
	    end;			/*   Get space for next pgh.			*/
	    Dlinfo.Nunits = Nuncommon_units + Ncommon_units;
	    call give_list_back (Plist_base, Plist);
				/* Discard list containing entry point names.	*/
	  end;
        do i = 1 to Ncommon_units;	/* Mark all common units by number.		*/
	common_units (i).Icommon_unit = i;
				/* This will help avoid seeing common units in	*/
        end;			/* every entry point info.			*/
        PDlinfo = Pnext_free_space;
        do i = 1 to Deps.N;		/* Parse all other entry points to count lines.	*/
	call parse_entry_point_into_units (Deps.linfo (i), Pcommon_units, Ncommon_units, PDlinfo);
	PDlinfo, Pnext_free_space = set_space_used (PDlinfo, currentsize (Dlinfo));
        end;			/* Common pghs added to other entries when parsed.*/
      end;
    else
      do;
        Pcommon_units = PDlinfo;
        Ncommon_units = 0;
      end;
    if Deps.N >= 0 then		/* Deps.N will be less than 0 if info seg is blank*/
      Deps.Nlines = sum (Deps.linfo.Nlines);
				/* Count lines in total info.			*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
/*                                                                           */
/*  List entry point names                                                   */
/*                                                                           */
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

    if help_args.Sctl.lep & Pep_list ^= null & ^Sep_list_printed then
      do;
        Sprt_entry_pts = TRUE;
        Nlines = Nlines + 2;  /* Add count for header of entry pt list */
        call print_header ();
        call print_list (Pep_list, Sprint_inhibit);
      end;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* Copy -section and -search control arguments.					*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

    if help_args.Sctl.scn then
      do;				/* Copy -section args to local storage.		*/
        do i = 1 to min (help_args.Nscns, dim (scn.arg, 1));
	scn.arg (i) = help_args.scn (i);
        end;
        scn.N = i - 1;
      end;
    if help_args.Sctl.srh then
      do;				/* Copy -search args to local storage.		*/
        do i = 1 to min (help_args.Nsrhs, dim (srh.arg, 1));
	srh.arg (i) = help_args.srh (i);
        end;
        srh.N = i - 1;
      end;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* Find the correct logical info segment (info), if any was requested by user.		*/
/* If desired info was not found, then any searching required for the			*/
/* -section and -search control arguments cannot and will not be done, though the	*/
/* operands given with these control arguments are stored as the default values to be 	*/
/* used with the section and search requests if first issued without operands.		*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

    if Dinfo_seg_.ep = "" then
      do;				/* if no entry point requested,		*/
        if help_args.min_date_time ^= -1 then
	do;			/*   process 1st newer than given date/time	*/
	  do Iep = 0 to Deps.N while (help_args.min_date_time ^< Deps.linfo (Iep).date);
	  end;			/*   iff a nonzero date/time selector was given.	*/
	  if Iep > Deps.N then
	    Iep = 0;
	end;
        else if help_args.Sctl.scn | help_args.Sctl.srh then
	do;
	  Scase_sensitive = help_args.Sctl.cs;
	  Ssearch = FALSE;		/*   process 1st entry containing matches for	*/
	  Iunit = 1;		/*   -section and/or -search  ctl_args.		*/
	  if help_args.Sctl.scn & help_args.Sctl.srh then
	    do;
	      do Iep = 0 to Deps.N while (^Ssearch);
	        match_result = find_section (Deps.linfo (Iep).PDlinfo, scn, Scase_sensitive, Iunit);
	        if match_result ^= no_match then
		Ssearch = find_pgh (Deps.linfo (Iep).PDlinfo, srh, Iunit, Scase_sensitive,
		  new_section);
	      end;
	    end;
	  else if help_args.Sctl.scn then
	    do;
	      do Iep = 0 to Deps.N while (^Ssearch);
	        match_result = find_section (Deps.linfo (Iep).PDlinfo, scn, Scase_sensitive, Iunit);
	        Ssearch = (match_result ^= no_match);
	      end;
	    end;
	  else
	    do;
	      do Iep = 0 to Deps.N while (^Ssearch);
	        Ssearch = find_pgh (Deps.linfo (Iep).PDlinfo, srh, Iunit, Scase_sensitive,
		  new_section);
	      end;
	    end;
	  if ^Ssearch then
	    do;
	      Acode = error_table_$nomatch;
	      return;
	    end;
	  Iep = Iep - 1;
	end;
        else Iep = 0;		/* otherwise, process general description.	*/
        Ssearch = TRUE;
      end;

    else
      do;				/* else search for requested entry point.	*/
        Sfound = FALSE;
        do Iep = 1 to Deps.N while (^Sfound);
	do i = 1 to Deps.linfo (Iep).Nep_names while (^Sfound);
	  if Dinfo_seg_.ep = Deps.linfo (Iep).ep_name (i) then
	    Sfound = TRUE;
	end;
        end;
        if Sfound then
	do;
	  Iep = Iep - 1;
	  Ssearch = TRUE;		/* Do -section/-search matching if user asked.	*/
	end;
        else
	do;			/*   requested ep not found.			*/
	  if Dinfo_seg_.info_name = "" then
	    Linfo_name = 0;
	  else Linfo_name = length (rtrim (Dinfo_seg_.info_name)) + length (" ()");
	  if ^help_args.Sctl.inhibit_errors then
	    do;
	      Acode = error_table_$noentry;
	      return;
	    end;
	  Ssearch = FALSE;		/* Don't do -section/-search matching.		*/
	  Iep = 0;
	end;
      end;
    PDlinfo = Deps.linfo (Iep).PDlinfo; /* Address entry point user wants first.	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* When -header is given without other control arguments, generate a heading line	*/
/* containing full pathname of physical info segment, title line from logical		*/
/* info segment, line count of logical info segment, and count of logical info segments	*/
/* (infos) in physical info seg (excluding common portion at the beginning).		*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

    Ninfos_printed = Ninfos_printed + 1;/* Beyond this point, something must get printed.	*/
    if Dinfo_seg_.Scross_ref then
      do;				/* Just remark about existence of other versions	*/
				/* of an info.				*/
        if Ninfos_printed = 1 then
	do;
	  call ioa_ ("^a: No infos matching -section and -search control arguments were found.", procedure_name);
	  call ioa_ ("However, several infos appear more than once in the search paths.");
	  call ioa_ ("The following secondary info(s) match -section and -search control arguments.");
	end;
        else if Nlast_info_cross_ref ^= Iinfo - 1 then
	do;
	  call ioa_ ("^v/^a: Other versions of the info^[s^] above were found.  See also:", help_args.Lspace_between_infos,
	       procedure_name, Ninfos_printed > 2);
	end;
        call ioa_ ("  ^a^[>^]^a", Dinfo_seg_.dir, Dinfo_seg_.dir ^= ">", Dinfo_seg_.ent);
        Nlast_info_cross_ref = Iinfo;
        go to RETURN;
      end;
    else if help_args.Sctl.he_only then
      do;				/* When -header is given without other ctl_args	*/
				/*   output the header and return.		*/
        call print_header_only ();
        go to RETURN;
      end;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* The -brief control argument requests that the "Syntax" section (or "Usage" section of	*/
/* old format info segs) be output in full, along with a list of arguments and control	*/
/* arguments from the "Arguments" and "Control arguments" sections.			*/
/* 1) Find "Syntax" or "Usage" sections, and count lines in these sections.		*/
/* 2) Find "Arguments" and "Control arguments" sections, and build lists of arguments.	*/
/*    Count output lines in each list.						*/
/* 3) Output a header line, optionally given full pathname of physical info seg (-header)	*/
/*    as well as number of lines in the brief output, total lines in the info, and	*/
/*    count of (other) infos in this physical info seg.				*/
/* 4) Output the "Syntax" or "Usage" section.					*/
/* 5) Output the columnar lists of "Arguments" and "Control arguments".		*/
/* 6) Stop processing this physical info segment, and move on to the next specified	*/
/*    by user (if any).							*/
/*									*/
/* When -control_arg is given, output description of all args/ctl_args whose name lines	*/
/* contain match for substring identifier(s) given as operands by the user.		*/
/* 1) Find "Argument" and "Control argument" name lines which contain one of the	*/
/*    substrings given by the user after -control_arg.				*/
/* 2) Store those argument description lines in a list.				*/
/* 3) Print the argument description lines in the list after an appropriate heading.	*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

    if help_args.Sctl.bf | help_args.Sctl.ca then
      do;				/* Print argument descriptions when -ca given.	*/
        Nlines = 1;			/* Count lines to be output.			*/
				/*   Add 1 line for heading line.		*/

        Nunit_bf_prt = 0;		/* Initialize number of syntax units              */

        if help_args.Sctl.bf then
	do;
	  call get_brief_data (Deps.linfo (Iep).S.old_format, help_args.Sctl.he_pn, PDlinfo, Plist_base, Dinfo_seg_.dir,
                Dinfo_seg_.ent, Nlast_info_no_brief_data, Iinfo, Ninfos_printed, Iunit_syntax, Nunit_bf_prt,
                Nlists_of_bf_args, Nlines);
	  if Nunit_bf_prt = 0 then
	    go to RETURN;
	  if Ninfos > 1 then
	    call print_header ();
	end;
        else
	do;
	  Nunit_bf_prt = 0;
	  Nlists_of_bf_args = 0;
	end;

        if help_args.Sctl.ca & ^Sep_list_printed then
	do;			/* Get control argument descriptions.		*/
	  if Ninfos > 1 then
	    call print_header ();
	  Plist, Plist_of_cas = get_list (Plist_base);
	  list.N = help_args.Ncas;	/*   Begin by copying user-supplied arg names.	*/
	  list.arg = help_args.ca;
	  list.title = "-control_arg";/*   Get one list for each section with ctl args.	*/
	  call get_arg_descriptions (Plist_of_cas, PDlinfo, Plist_base, Deps.linfo (Iep).S.old_format, Plists_of_args,
	       Nlists_of_args);
	  do i = 1 to Nlists_of_args; /*   Count output lines in each list.  Lists are	*/
	    Plist = Plists_of_args (i);
				/*   separated by 2 1 line, with 1 line for	*/
	    Nlines = Nlines + list.N + 2;
				/*   title of section containing the args.	*/
	  end;
	end;

        if length (Deps.linfo (Iep).header) = 0 then
	do;
	  Nlines = Nlines - 2;	/* No title?  Remove its line count.		*/
	  if Nlines <= 0 then
	    Nlines = 1;
	end;

        Sprt_bf_heading = TRUE;	/* Being requested as an external ca               */
        call print_brief_data (PDlinfo, Plist_base, Iunit_syntax, Nunit_bf_prt, Nlists_of_bf_args, Nlines);

        if help_args.Sctl.ca then
	do;			/* Print ctl arg descriptions, section by sect.	*/
	  do j = 1 to Nlists_of_args;
	    Plist = Plists_of_args (j);
	    call ioa_ ("^[^/^]^a:", (j > 1 | Ninfos > 1 | (help_args.Sctl.bf & help_args.Sctl.ca)), list.title);
	    do i = 1 to list.N;
	      call ioa_ ("^a", list.arg (i));
	    end;
	  end;
	end;
        go to RETURN;		/*   Stop when -brief or -control_arg given.	*/
      end;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* When -title is given, output a heading line and titles of paragraph sections.	*/
/* The heading line contains:							*/
/* 1) The full pathname of the info segment (if -header was given).			*/
/* 2) The primary title line from the info selected by the user.			*/
/* 3) The count of section title lines to be output.				*/
/* 4) Count of total lines in logical info segment.				*/
/* 5) Count of (other) infos in this physical info segment.				*/
/* Output a list of section titles in columnar form.				*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


    PI_LABEL = QUERY;		/* once printing starts, pi skips to next query.	*/
    Iunit = 0;			/* No pghs printed so far.			*/
    if (print_pgh_titles ()) then
      do;				/* Print pgh titles when -title is given only if 	*/
				/* more than one title will be printed.		*/
        if length (Deps.linfo (Iep).header) > 0 then
	Nlines = 1;
        else Nlines = -1;
        Plist_of_titles = get_list (Plist_base);
        call get_title_list (PDlinfo, Plist_of_titles, 0);
        call format_list (Plist_of_titles, divide (Dlinfo.Nsections, 7, 17, 0) + 1, 1);
        Nlines = Nlines + Plist_of_titles -> list.Nrows + 1;
        if help_args.Sctl.all then
	do;
	  Nlines = Nlines + Deps.linfo (Iep).Nlines + 2;
	  if length (Deps.linfo (Iep).header) > 0 then
	    Nlines = Nlines - 2;
	end;
        call print_header ();
        call print_list (Plist_of_titles, Sprint_inhibit);
        Pnext_free_space = Plist_of_titles;
        list_base.N = list_base.N - 1;	/* Free list of titles.			*/
        if help_args.Sctl.all then
	do;
	  do Iunit = 1 to Dlinfo.Nunits;
	    call print_pgh_2nl (Dlinfo.unit (Iunit), Sprint_inhibit);
	  end;
	  go to QUERY;
	end;
      end;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* When -title not given, begin printing paragraphs.  Normally start with first pgh.	*/
/* However, if -section  is given, search for section whose title contains		*/
/* user-specified substrings.  Print first pgh of this section if found.		*/
/* If -search is given, search for pgh containing user-specified substrings.		*/
/* Start with first matching pgh.  If both -section and -search are given, position to	*/
/* matching section before searching more matching pgh.				*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


    else if ^Sep_list_printed then	/* If entrypoint list was printed do not print  	*/
      do;
        Iunit = 1;			/* Start searching in first unit.		*/
        new_section = "";
        if ^help_args.Sctl.all then
	if ^help_args.Sctl.title then
	  if help_args.Sctl.scn | help_args.Sctl.srh then
				/* Select pgh when -section given.		*/
	    do;			/* Select pgh when -search  given.		*/
	      Scase_sensitive = help_args.Sctl.cs;
	      if help_args.Sctl.scn then
	        do;		/* Search all section titles for one containing	*/
		match_result = find_section (PDlinfo, scn, Scase_sensitive, Iunit);
		if match_result = no_match then
		  return;
	        end;
	      if help_args.Sctl.srh then
	        do;		/* Search subsequent pghs for one containing	*/
		Ssearch = find_pgh (PDlinfo, srh, Iunit, Scase_sensitive, new_section);
		if ^Ssearch then
		  return;
	        end;
	    end;

        if help_args.Sctl.all then
	do;
	  Nlines = Deps.linfo (Iep).Nlines;
	  Nprint_units = Dlinfo.Nunits;
	end;
        else
	do;
	  Nlines = Dlinfo.unit (Iunit).Nlines + 2;
				/*   Add 2 for entry point heading.		*/
	  if length (Deps.linfo (Iep).header) = 0 then
	    Nlines = Nlines - 2;	/*   However, if no heading, subtract the 2 lines.*/
	  if new_section ^= "" then
	    if ^Dlinfo.unit (Iunit).S.scn then
	      Nlines = Nlines + 1;	/* Add 1 line for section title of matched pgh.	*/
	  Nprint_units = 1;		/* Print one pgh.  If -section and -search were	*/
				/* not given, print more pghs as well so long	*/
				/* as total lines fewer than help_args.max_Lpgh	*/
				/* and additional pghs shorter than min_Lpgh.	*/
                                        /* Do NOT add in the entry point list pgh         */
	  if ^(help_args.Sctl.scn | help_args.Sctl.srh) then
	    do while (Nlines_less_Lpgh () &
                ^Dlinfo.unit (Iunit + Nprint_units).ep_list);
	      Nlines = Dlinfo.unit (Iunit + Nprint_units).Nlines + 1 + Nlines;
	      Nprint_units = Nprint_units + 1;
	    end;
	end;
        call print_header ();

        if (new_section_nscn ()) then	/* new section - not seen			*/
	do;
	  call ioa_ ("^/^a:", new_section);
	  call print_pgh_nnl (Dlinfo.unit (Iunit), Sprint_inhibit);
	end;
        else if (prt_pgh_nnl ()) then	/* ^Sctl.he.pn & ^Sctl.he_info_name & 		*/
				/* ^Sctl.he_counts & length header = 0		*/
	call print_pgh_nnl (Dlinfo.unit (Iunit), Sprint_inhibit);
        else call print_pgh (Dlinfo.unit (Iunit), Sprint_inhibit);

        Sfirst_time = TRUE;

        do Iunit = Iunit + 1 to Iunit + Nprint_units - 1;
	if Dlinfo.unit (Iunit - 1).Nlines = 1 then
				/* if prior unit only had 1 line then print 2 blks*/
	  if ^Sfirst_time then
	    call print_pgh_2nl (Dlinfo.unit (Iunit), Sprint_inhibit);
	  else call print_pgh (Dlinfo.unit (Iunit), Sprint_inhibit);
	else call print_pgh (Dlinfo.unit (Iunit), Sprint_inhibit);
        end;
        Iunit = Iunit - 1;
      end;

QUERY:
    Nconsecutive_bad_ops = 0;		/* No errors in responses so far.		*/
    Ssearch = FALSE;		/* no searching for matching section/pgh underway.*/
    Sloop = TRUE;			/* Loop through all paragraphs of info.		*/
    Iunit = Iunit + 1;		/* Beginning with the next one.		*/
    if Sep_list_printed then		/* Entry list printed			*/
      query_type = ep_list;
    else query_type = normal;		/* Print normal section/pgh messages for now.	*/

    do while (Sloop);		/* Print remaining pghs under user control.	*/
      PI_LABEL = ASK;		/* Recompute query after most program_interrupt's.*/
      if Iunit > Dlinfo.Nunits then	/* Detect end_of_info and handle specially, but 	*/
        go to END_OF_INFO;		/* still remain within do group.		*/
      if Dlinfo.unit (Iunit).ep_list & Sep_list_printed then
         goto CONTINUE;		/* If entry pts list already printed dont reprint */

      if Dlinfo.unit (Iunit).ep_list & ^Sprt_entry_pts then
        do;	          	/* Print entry pts list only if requested         */
         Sep_list_printed = TRUE;
         goto CONTINUE;
        end;
     
      if Dlinfo.unit (Iunit).ep_list & No_list_elements = 1 then
                                        /* If entry pts list has only 1 element dont print.*/
         goto RETURN;
ASK:
      if query_type = normal | query_type = some_unseen | query_type = search_unseen |
         query_type = return_from_list_requests | query_type = ep_list then
        do;
	Sseen = seen_pgh (Dlinfo.unit (Iunit));
				/* Tell user in query if he's already seen pgh.	*/
	Nlines = Dlinfo.unit (Iunit).Nlines;
	Nprint_units = 1;		/* Normally print one pgh at a time.		*/
	query = "";
	if Dlinfo.unit (Iunit).S.scn | Iunit = 1 | query_type = return_from_list_requests |
            query_type = ep_list then
	  do;			/* However, if pgh begins a section and following	*/
	    if Iunit = 1 then
                do;
	       if ^Dlinfo.unit (1).S.scn then
	         query = "UNTITLED";
	       else query = Dlinfo.unit (Iunit).title;
                 if query_type = ep_list then
                                        /* Increment Nlines for ep list header             */
                   Nlines = Nlines + 2;
                end;
	    else if ^Dlinfo.unit (Iunit).S.scn then do;
	      do Iunit_search = Iunit-1 to 1 by -1 while(^Dlinfo.unit (Iunit_search).S.scn);
	        end;
	      if Iunit_search = 0 then
	        query = "UNTITLED";
	      else query = Dlinfo.unit (Iunit_search).title;
	      end;
	    else query = Dlinfo.unit (Iunit).title;
				/* pghs are shorter than min_Lpgh, print them	*/
				/* as well, until max_Lpgh lines are aggregated.	*/
	    do i = Iunit + Nprint_units to hbound(Dlinfo.unit,1)
	      while (ck_conditions (i));
	      Nlines = Nlines + Dlinfo.unit (i).Nlines + 2;
				/*   Must skip 2 lines between pghs to keep line	*/
				/*   count of total info equal to count of all	*/
				/*   printed lines.				*/
	      if Dlinfo.unit (i).S.scn then
	        do;
		query = query || "  &  ";
		if length (query) + length (Dlinfo.unit (i).title) + 12 > Loutput_line then
		  query = query || NL;
				/* 12 = length ( "(nnn lines)." )		*/
		query = query || Dlinfo.unit (i).title;
	        end;
	      Nprint_units = Nprint_units + 1;
	    end;			/*ck_conditions*/
	  end;			/*Iunit=1*/
	else
	  do;			/* If pgh doesn't begin a section, we can only	*/
				/* aggregate pghs in the current section.	*/
	    do i = Iunit + Nprint_units to hbound(Dlinfo.unit,1)
	      while (ck_more_conditions (i));
	      Nlines = Nlines + Dlinfo.unit (i).Nlines + 2;
	      Nprint_units = Nprint_units + 1;
	    end;
	  end;
        end;

      else if query_type = new_entry then
        do;
	call ct_pgh_lines;
	if Nlines + 2 < Deps.linfo (Iep).Nlines then
	  Lcount = length ("Entry:(99 lines follow;  999 lines in entry point)  More help?");
	else Lcount = length ("Entry:(999 lines in entry point)  More help?");
	Snl1 = (Lcount + 2 + length (Deps.linfo (Iep).header) + 3 > Loutput_line);
        end;
RE_ASK:
      Ssearch = FALSE;		/* searching for matching section/pgh is done.	*/
      PI_LABEL = ASK;		/* Routines branching here set PI_LABEL. Reset it.*/
      Sprint_inhibit = FALSE;
      if query_type = normal then
        do;
	call command_query_ (addr (query_info), answer, procedure_name,
	     "^[^/^]^[^a (^d line^[s^]).^[^/^;  ^]^2s^;^4s^d more line^[s^].  ^]^[Review^;More help^]?",
	     Dlinfo.unit (Iunit).S.scn & Dlinfo.unit (Iunit).Icommon_unit = 1 & Sseen, Dlinfo.unit (Iunit).S.scn,
	     query, Nlines, Nlines > 1, (length (query) + 24 > Loutput_line), Nlines, Nlines > 1, Sseen);
        end;
      else if query_type = some_unseen then
        call command_query_ (addr (query_info), answer, procedure_name,
	   "End of info.  Some paragraphs unseen.^/^[^a^;In:  ^a^] (^d line^[s^]).^[^/^;  ^]More help?",
	   Dlinfo.unit (Iunit).S.scn, query, Nlines, Nlines > 1, length (query) + 30 > Loutput_line);
      else if query_type = search_unseen then
        call command_query_ (addr (query_info), answer, procedure_name,
	   "^[^[^a^;In:  ^a^] (^d line^[s^])^;^2s^d more line^[s^]^].^[^/^;  ^]More help?", query ^= "",
	   Dlinfo.unit (Iunit).S.scn, query, Nlines, Nlines > 1, length (query) + 30 > Loutput_line);
      else if query_type = return_from_list_requests then do;
        if length(Deps.linfo(Iep).header) > 0 then
	new_section = Deps.linfo(Iep).header;
        else if length(rtrim(Dinfo_seg_.info_name)) > 0 then
	new_section = rtrim(Dinfo_seg_.info_name);
        else new_section = rtrim(Dinfo_seg_.ent);
        call command_query_ (addr (query_info), answer, procedure_name,
	"Returning to:  ^a^/^a (^d line^[s^]):^[^/^;  ^]^[Review^;More help^]?",
	new_section, query, Nlines, Nlines > 1, length (query) + 25 > Loutput_line, Sseen);
        query_type = normal;
        end;
      else if query_type = new_entry then
        call command_query_ (addr (query_info), answer, procedure_name,
	   "Entry:  ^a^[^/^;   ^](^[^d lines follow;  ^;^s^]^d lines in entry point).  ^[Review^;More help^]?",
	   Deps.linfo (Iep).header, Snl1, (Nlines + 2 < Deps.linfo (Iep).Nlines), Nlines, 
	   Deps.linfo (Iep).Nlines - 2, Sseen);
      else if query_type = ep_list then
        do;     
          if length(Deps.linfo(Iep).header) > 0 then
	  new_section = Deps.linfo(Iep).header;
          else if length(rtrim(Dinfo_seg_.info_name)) > 0 then
                 new_section = rtrim(Dinfo_seg_.info_name);
          else new_section = rtrim(Dinfo_seg_.ent);
          call command_query_ (addr (query_info), answer, procedure_name,
            "Returning to:  ^a^/^a (^d line^[s^]):^[^/^;  ^]^[Review^;More help^]?",
	  new_section, query, Nlines, Nlines > 1, length (query) + 25 > Loutput_line, Sseen);
          query_type = normal;
          Nprint_units = 1;
        end;

PARSE:
      call parse_answer (answer, op, ep_name, ca, scn, srh, lr);
      if op = hbound (do, 1) + 1 then
        do;			/* Count consecutive errors user makes in answer.	*/
	Nconsecutive_bad_ops = Nconsecutive_bad_ops + 1;
	go to ERROR;
        end;
      else Nconsecutive_bad_ops = 0;
      go to do (op);		/* Process request at user's beck and call.	*/

YES:
do (1):				/* yes					*/
      Iunit_end = Iunit + Nprint_units - 1;
      PI_LABEL = YES_END;		/* go to pgh user said, even if he pi's.	*/
      call print_pgh (Dlinfo.unit (Iunit), Sprint_inhibit);
      do Iunit = Iunit + 1 to Iunit + Nprint_units - 1;
        call print_pgh_2nl (Dlinfo.unit (Iunit), Sprint_inhibit);
      end;
YES_END:
      Iunit = Iunit_end;
      go to CONTINUE;

do (2):				/* no					*/
      go to RETURN;

do (3):				/* quit					*/
      go to QUIT;

do (4):				/* top					*/
      Iunit = 0;
      if length (Deps.linfo (Iep).header) > 0 then
        call ioa_ ("^a", Deps.linfo (Iep).header);
      go to CONTINUE;

do (5):				/* rest					*/
      Nlines_titles = Dlinfo.unit (Iunit).Nlines;
      do Iunit_end = Iunit + 1 to Dlinfo.Nunits;
        Nlines_titles = Nlines_titles + Dlinfo.unit (Iunit_end).Nlines + 2;
      end;
      Iunit_end = Iunit_end - 1;
REST:
      PI_LABEL = REST_END;
      call ioa_ ("(^d ^[lines follow^;line follows^])", Nlines_titles, Nlines_titles > 1);
      call print_pgh (Dlinfo.unit (Iunit), Sprint_inhibit);
      do Iunit = Iunit + 1 to Iunit_end;
        call print_pgh_2nl (Dlinfo.unit (Iunit), Sprint_inhibit);
      end;
REST_END:
      Iunit = Iunit_end;
      go to CONTINUE;

do (6):				/* rest -scn				*/
      Nlines_titles = Dlinfo.unit (Iunit).Nlines;
      do Iunit_end = Iunit + 1 to Dlinfo.Nunits while (^Dlinfo.unit (Iunit_end).S.scn);
        Nlines_titles = Nlines_titles + Dlinfo.unit (Iunit_end).Nlines + 2;
      end;
      Iunit_end = Iunit_end - 1;
      go to REST;

do (7):				/* rest -aep				*/
      if Deps.N = 0 then
        do;			/* No entry points found			*/
	call ioa_ ("No entrypoint names were found.");
	goto ERROR;
        end;

      if Iep = Deps.N then
        do;			/* No more entry points exist			*/
	call ioa_ ("There are no remaining entrypoints to display.");
	goto ERROR;
        end;

      do Iep = Iep + 1 to Deps.N;
        PDlinfo = Deps.linfo (Iep).PDlinfo;
        Iunit = 1;
        Nlines = Dlinfo.unit (Iunit).Nlines + 2;
        call ct_pgh_lines;
        call ioa_ ("^/Entry:  ^a^[^/^;   ^](^[^d lines follow;  ^;^s^]^d lines in entry point).",
	   Deps.linfo (Iep).header, Snl1, (Nlines + 2 < Deps.linfo (Iep).Nlines), Nlines, 
	   Deps.linfo (Iep).Nlines - 2);
        do Iunit = 1 to Dlinfo.Nunits;
	if ^Dlinfo.unit (Iunit).ep_list then
	  call print_pgh (Dlinfo.unit (Iunit), Sprint_inhibit);
        end;
      end;

      goto CONTINUE;

do (8):				/* rest -ep				*/
      if Deps.N = 0 then
        do;			/* No entry points found			*/
	call ioa_ ("No entrypoint names were found.");
	goto ERROR;
        end;

      if Iep = Deps.N then
        do;			/* No more entry points exist			*/
	call ioa_ ("There are no remaining entrypoints to display.");
	goto ERROR;
        end;

      if Deps.linfo (Iep,1).ep_name = "" then 
        do;                             /* This is not an entry point                     */
          call ioa_ ("^a is not an entry point", query);
          goto ERROR;
        end;
     
      PDlinfo = Deps.linfo (Iep).PDlinfo;
      Iunit = 1;
      Nlines = Dlinfo.unit (Iunit).Nlines + 2;

      do Iunit = 1 to Dlinfo.Nunits;
        if ^Dlinfo.unit (Iunit).ep_list then
           call print_pgh (Dlinfo.unit (Iunit), Sprint_inhibit);
      end;

      goto RE_ASK;
      

do (9):				/* skip					*/
      go to CONTINUE;

do (10):				/* skip -scn				*/
      do Iunit = Iunit + 1 to Dlinfo.Nunits while (^Dlinfo.unit (Iunit).S.scn);
      end;
      Iunit = Iunit - 1;
      go to CONTINUE;

do (11):				/* skip -ep				*/
do (12):				/* skip -rest				*/
      do Iunit = 1 to Dlinfo.Nunits while (^seen_pgh (Dlinfo.unit (Iunit)));
      end;			/* Has user seen any pgh of this entry?		*/
      if Iunit > Dlinfo.Nunits then	/* No.					*/
        Sseen = FALSE;
      else Sseen = TRUE;		/* If so, by skip -ep, he's saying he's seen all	*/
      go to CHECK_OTHER_ENTRIES;	/* he wants to of this entry.			*/

do (13):				/* skip -seen				*/
      new_section = "";
      Sfound = FALSE;
      do Iunit = Iunit + 1 to Dlinfo.Nunits while (^Sfound);
        if Dlinfo.unit (Iunit).S.scn then
	new_section = Dlinfo.unit (Iunit).title;
        Sfound = ^seen_pgh (Dlinfo.unit (Iunit));
      end;
      Iunit = Iunit - 1;
      if Sfound then
        do;
	query = new_section;
	query_type = search_unseen;
	go to ASK;
        end;
      else go to END_OF_INFO;

do (14):				/* title					*/
      Iunit_search = Iunit - 1;
TITLE:
      PI_LABEL = RE_ASK;
      Plist_of_titles = get_list (Plist_base);
      call get_title_list (PDlinfo, Plist_of_titles, Iunit_search);
      call format_list (Plist_of_titles, divide (Plist_of_titles -> list.N, 7, 17, 0) + 1, 1);
      Nlines_titles = Plist_of_titles -> list.Nrows;
      call ioa_ ("(^d ^[lines follow^;line follows^])", Nlines_titles, Nlines_titles > 1);
      call print_list (Plist_of_titles, Sprint_inhibit);
      Pnext_free_space = Plist_of_titles;
      list_base.N = list_base.N - 1;
      go to RE_ASK;

do (15):				/* title -top				*/
      Iunit_search = 0;
      go to TITLE;

do (16):				/* entry_point {ep_name} 			*/
      if ref_name = "" then
        if suffix = "" then
	ref_name = rtrim (Dinfo_seg_.ent);
        else ref_name =
	   substr (Dinfo_seg_.ent, 1, 32 - length (suffix) - index (reverse (Dinfo_seg_.ent), reverse (suffix) || "."));
      if ep_name = "" then		/* Look for main entry point (eg, ioa_$ioa_)	*/
        ep_name = ref_name;
      else
        do;
	i = index (ep_name, "$");	/* Look for hcs_$initiate rather than initiate	*/
	if i > 1 then
	  do;			/* Validate given reference name.		*/
	    if substr (ep_name, 1, i - 1) ^= ref_name then
	      do;
	        call ioa_ ("Reference name  ^a  invalid.  Entry point names must be of the form:
	^a$ENTRY_POINT_NAME
or just:	ENTRY_POINT_NAME", substr (ep_name, 1, i - 1), ref_name);
	        Nconsecutive_bad_ops = Nconsecutive_bad_ops + 1;
	        go to ERROR;
	      end;
	  end;
	if i > 0 then
	  if i < length (ep_name) then
	    ep_name = substr (ep_name, i + 1);
	  else ep_name = ref_name;
        end;
      Sfound = FALSE;		/* Find the requested entry point.		*/
      do i = 1 to Deps.N while (^Sfound);
        do j = 1 to Deps.linfo (i).Nep_names while (^Sfound);
	if ep_name = Deps.linfo (i).ep_name (j) then
	  Sfound = TRUE;
        end;
      end;
      if Sfound then
        do;
	Deps.linfo (Iep).S.seen_by_user = TRUE;
				/* user has seen all he wants of this entry point.*/
	Iep = i - 1;
	PDlinfo = Deps.linfo (Iep).PDlinfo;
	Iunit = 1;
	Nlines = Dlinfo.unit (Iunit).Nlines + 2;
	call ct_pgh_lines;
	call ioa_ ("Entry:  ^a^[^/^;   ^](^[^d lines follow;  ^;^s^]^d lines in entry point).", 
	     Deps.linfo (Iep).header, Snl1, (Nlines + 2 < Deps.linfo (Iep).Nlines), Nlines,
	     Deps.linfo (Iep).Nlines - 2);
	goto YES;
        end;
      else
        do;
	call ioa_ ("Entry point  ^a$^a  not found.", ref_name, ep_name);
	go to RE_ASK;
        end;

do (17):				/* section			          */
				/* section -ncs				*/
      Iunit_search = Iunit;
      Scase_sensitive = FALSE;
      goto SECTION;
do (18):				/* section -cs				*/
      Iunit_search = Iunit;
      Scase_sensitive = TRUE;
      goto SECTION;
do (19):				/* section -top				*/
				/* section -top -ncs                              */
      Iunit_search = 1;
      Scase_sensitive = FALSE;
      goto SECTION;      
do (20):                                /* section -top -cs                               */
      Iunit_search = 1;
      Scase_sensitive = TRUE;
SECTION:
      if scn.N = 0 then
        do;
	call ioa_$nnl ("No search strings given for section request.  ");
	Nconsecutive_bad_ops = Nconsecutive_bad_ops + 1;
	go to ERROR;
        end;
      if Dlinfo.unit (Iunit_search).S.scn then
        Iunit_search = Iunit_search + 1;
      match_result = find_section (PDlinfo, scn, Scase_sensitive, Iunit_search);
      if match_result = exact_match then
        do;
	Iunit = Iunit_search;
	Nprint_units = 1;
	call ioa_ ("(^d ^[lines follow^;line follows^])", Dlinfo.unit (Iunit).Nlines, Dlinfo.unit (Iunit).Nlines > 1);
	go to YES;
        end;
      else if match_result = match then
        do;
	Iunit = Iunit_search;	/* When found, don't aggregate paragraphs.	*/
	Ssearch = TRUE;
	query_type = normal;
	goto ASK;
        end;
      else
        do;			/* Search failed?  Paragraphs can be aggregated	*/
	call ioa_ ("No matching section found.");
	go to RE_ASK;		/* based upon user's next response.		*/
        end;

do (21):				/* search					*/
				/* search -ncs				*/
      Iunit_search = Iunit;
      Scase_sensitive = FALSE;
      goto SEARCH;
do (22):				/* search -cs				*/
      Iunit_search = Iunit;
      Scase_sensitive = TRUE;
      goto SEARCH;
do (23):				/* search -top				*/
				/* search -top -ncs                               */
      Iunit_search = 1;
      Scase_sensitive = FALSE;
      goto SEARCH;
do (24):                                /* search -top -cs                                */
      Iunit_search = 1;
      Scase_sensitive = TRUE;
SEARCH:
      if srh.N = 0 then
        do;
	call ioa_$nnl ("No search strings given for search request.  ");
	Nconsecutive_bad_ops = Nconsecutive_bad_ops + 1;
	go to ERROR;
        end;
      Ssearch = find_pgh (PDlinfo, srh, Iunit_search, Scase_sensitive, new_section);
      if Ssearch then
        do;			/* Found matching pgh?  Print it.		*/
	Iunit = Iunit_search;
	Ssearch = FALSE;
	Nlines = Dlinfo.unit (Iunit).Nlines;
	if new_section ^= "" & ^Dlinfo.unit (Iunit).S.scn then
	  do;
	    Nlines = Nlines + 1;
	    call ioa_ ("(^d lines follow)^2/^a:", Nlines, new_section);
	    call print_pgh_nnl (Dlinfo.unit (Iunit), Sprint_inhibit);
	  end;
	else
	  do;
	    call ioa_ ("(^d ^[lines follow^;line follows^])", Nlines, Nlines > 1);
	    call print_pgh (Dlinfo.unit (Iunit), Sprint_inhibit);
	  end;
	go to CONTINUE;
        end;
      else
        do;
	call ioa_ ("No matching paragraph found.");
	go to RE_ASK;
        end;


do (25):				/* brief					*/
      Nlines_titles = -1;
      call get_brief_data (Deps.linfo (Iep).S.old_format, help_args.Sctl.he_pn, PDlinfo, Plist_base, Dinfo_seg_.dir,
	 Dinfo_seg_.ent, Nlast_info_no_brief_data, Iinfo, Ninfos_printed, Iunit_syntax, Nunit_bf_prt, Nlists_of_bf_args,
	 Nlines_titles);
      if Nlines_titles > 0 then
        do;
	call ioa_ ("(^d ^[lines follow^;line follows^])", Nlines_titles, Nlines_titles > 1);
	Sprt_bf_heading = FALSE;	/* Internal bf request                          */
	call print_brief_data (PDlinfo, Plist_base, Iunit_syntax, Nunit_bf_prt, Nlists_of_bf_args, Nlines);
        end;
      else call ioa_ ("No brief data avaiable");
      go to RE_ASK;

do (26):				/* control_arg				*/
      Nlines_titles = -1;
      ca.title = "control_arg";
      call get_arg_descriptions (addr (ca), PDlinfo, Plist_base, Deps.linfo (Iep).S.old_format, Plists_of_args, Nlists_of_args);
      if Nlists_of_args > 0 then
        do;
	do i = 1 to Nlists_of_args;
	  Plist = Plists_of_args (i);
	  Nlines_titles = Nlines_titles + list.N + 2;
	end;
	call ioa_ ("(^d ^[lines follow^;line follows^])", Nlines_titles, Nlines_titles > 1);
	do j = 1 to Nlists_of_args;
	  Plist = Plists_of_args (j);
	  call ioa_ ("^/^a:", list.title);
	  do i = 1 to list.N;
	    call ioa_ ("^a", list.arg (i));
	  end;
	end;
	Pnext_free_space = Plists_of_args (1);
	list_base.N = 0;
        end;
      else call ioa_ ("No matching control arguments.");
      go to RE_ASK;

do (27):				/* . (= print name of caller)			*/
      call ioa_ ("^a", procedure_name);
      go to RE_ASK;

do (28):				/* ? (= list responses)			*/
      if query_answers.Nrows = 0 then
        call format_list (addr (query_answers), 5, 1);
      call print_list (addr (query_answers), Sprint_inhibit);
      go to RE_ASK;

do (29):				/* header					*/
      call print_header_only ();
      go to RE_ASK;

do (30):				/* list_entry_points			*/
      if Pep_list ^= null then
        do;
          Sprt_entry_pts = TRUE;
          Sep_list_printed = FALSE;
	call print_list (Pep_list, Sprint_inhibit);
	query_type = ep_list;
          goto ASK;
        end;
      else
        do;
	call ioa_ ("There are no entry points in this info segment.");
	goto ERROR;
        end;

do (31):				/* list_requests				*/
do (32):				/* help					*/
      call list_requests;
      query_type = return_from_list_requests;
      goto ASK;

ERROR:
      if Nconsecutive_bad_ops = 1 then
        do;			/* For first error, omit acceptable response	*/
				/* list, and just print mini query.		*/
	call command_query_ (addr (query_info), answer, procedure_name,
	     "^[^d ^[lines follow^;line follows^].^;^2s^]  ^[Review^;More help^]?", Nlines > 0, Nlines, Nlines > 1, Sseen);
	go to PARSE;
        end;
      call ioa_ ("Type ? for a list of allowed responses.");
				/* But if user errs more than once for given query*/
				/* tell user how to print responses		*/
      if Nconsecutive_bad_ops > 2 then
        go to RE_ASK;		/* If more than 2 consecutive errors, the user	*/
				/* may have forgotten original question.	*/
				/* Repeat it in  its entirety.		*/
      else call command_query_ (addr (query_info), answer, procedure_name,
	      "^[^d ^[lines follow^;line follows^].  ^;^2s^]^[Review^;More help^]?", Nlines > 0, Nlines, Nlines > 1, Sseen);
      go to PARSE;


END_OF_INFO:
      Sseen = TRUE;			/* Examine all pghs looking for unseen pgh.	*/
      new_section = "UNTITLED";	/* Remember section titles as we examine them.	*/

      if Dlinfo.Nunits > 0 then do Iunit = 1 to Dlinfo.Nunits while (Sseen);
        if Dlinfo.unit (Iunit).S.scn then
	new_section = Dlinfo.unit (Iunit).title;
        if Sep_list_printed & Dlinfo.unit (Iunit).S.ep_list 
           then ;
        else Sseen = seen_pgh (Dlinfo.unit (Iunit));
      end;			/* Look for unseen paragraphs.		*/
      if ^Sseen then
        do;			/* Some were found?				*/
	Iunit = Iunit - 1;		/* do group always increments 1 too many.	*/
	query = new_section;
	query_type = some_unseen;
	go to ASK;
        end;
      Sseen = TRUE;			/* This entry point has been seen.		*/

CHECK_OTHER_ENTRIES:
      if Deps.N = 0 then
        go to RETURN;		/* Only 1 part in log info?  We're done. 	*/
      else
        do;			/* Many entry points.			*/
	Deps.linfo (Iep).S.seen_by_user = Sseen;
				/* Mark whether or not we've seen this entry.	*/
	do i = Iep + 1 to Deps.N while (Deps.linfo (i).S.seen_by_user | help_args.min_date_time ^< Deps.linfo (i).date);
	end;			/* Look for unseen entries.			*/
	if i > Deps.N then
	  do;			/* All entries seen?			*/
	    do i = 1 to Iep - 1 while (Deps.linfo (i).S.seen_by_user | help_args.min_date_time ^< Deps.linfo (i).date);
	    end;
	    if Deps.linfo (i).S.seen_by_user | help_args.min_date_time ^< Deps.linfo (i).date then
	      go to RETURN;
	  end;
	Iep = i;			/* ith one is unseen.			*/
	PDlinfo = Deps.linfo (Iep).PDlinfo;
				/* access its paragraph descriptors.		*/
	Iunit = 1;
	if help_args.Sctl.all then
	  do;
	    Lcount = length ("Entry:(999 lines in entry point)");
	    Snl1 = (Lcount + 2 + length (Deps.linfo (Iep).header) + 3 > Loutput_line);
	    call ioa_ ("^v/Entry:  ^a^[^/^;   ^](^d lines in entry point)", help_args.Lspace_between_infos,
	         Deps.linfo (Iep).header, Snl1, Deps.linfo (Iep).Nlines - 2);
	    Nprint_units = Dlinfo.Nunits;
	    go to YES;
	  end;
	query_type = new_entry;
	go to ASK;
        end;

CONTINUE:
      Iunit = Iunit + 1;		/* Must implement looping ourselves because	*/
      Sloop = (Iunit <= Dlinfo.Nunits + 1);
				/* Dlinfo.Nunits will change when we switch to a	*/
      query_type = normal;		/* new entry point.  Loop would be:		*/


    end;				/*	do Iunit = Iunit+1 to Dlinfo.Nunits;	*/

RETURN:
    Acode = 0;
    return;

QUIT:
    Acode = error_table_$fatal_error;
    return;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


find_pgh:
  procedure (PDlinfo_, Srh, Iunit, Scase_sensitive, new_section) returns (bit (1) aligned);

    dcl PDlinfo_	   ptr parm;	/* ptr to descriptors for this log info seg. (In)	*/
    dcl 1 Srh	   aligned parm,	/* Paragraph search args. (In)		*/
	2 header	   like LIST.header,
	2 group	   (100) like LIST.group;
    dcl Iunit	   fixed bin;	/* Pgh to start searching (In)		*/
    dcl Scase_sensitive
		   bit(1) parm;	/* on if searching in case-sensitive fashion. (In)*/
    dcl new_section	   char (88) varying;
				/* Title of new section in which pgh occurs.	*/
				/* Pgh found. (Out)				*/

    dcl 1 Dlinfo_	   aligned based (PDlinfo_),
	2 Nunits	   fixed bin,	/* number of units (pghs) in this log info seg.	*/
	2 Nsections  fixed bin,	/* number of units having section title.	*/
	2 unit	   (0 refer (Dlinfo_.Nunits)) like Dlinfo.unit;
    dcl Ssearch	   bit (1) aligned;
    dcl (i, j)	   fixed bin;
    dcl PPgh	   ptr,
        LPgh	   fixed bin,
        Pgh	   char (LPgh) based (PPgh);

    if Srh.N = 0 then
      return (FALSE);		/* If nothing to search for, forget it.		*/
    j = 0;			/* Find length of longest pgh we will examine	*/
    do i = Iunit to Dlinfo_.Nunits;	/* so we can create temp storage into which	*/
      j = max (j, Dlinfo_.unit (i).L);	/* each pgh can be translated into lowercase.	*/
    end;

BLOCK:
    begin;
      dcl pgh	     char (j) varying;
      dcl srh	     (Srh.N) char (88) varying;
				/* translated paragraph search args.		*/

      do i = 1 to Srh.N;		/* translate search args to lower case.		*/
        if Scase_sensitive then
	srh (i) = Srh.arg (i);
        else srh (i) = translate (Srh.arg (i), "abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
      end;

      Ssearch = FALSE;		/* Search until matching section title found	*/
      new_section = "";

      do Iunit = Iunit to Dlinfo_.Nunits while (^Ssearch);
        if Dlinfo_.unit (Iunit).S.scn then
	new_section = Dlinfo_.unit (Iunit).title;
        if help_args.Sctl.srh & found_in_title () then
	Ssearch = TRUE;
        else
	do;
	  PPgh = Dlinfo_.unit (Iunit).Pstart;
	  LPgh = Dlinfo_.unit (Iunit).L;
	  if Scase_sensitive then
	    pgh = Pgh;
	  else pgh = translate (Pgh, "abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
				/* translate pgh to lower case.		*/
	  Ssearch = FALSE;		/* Assume title matches until proven otherwise.	*/
	  do i = 1 to dimension (srh, 1) while (^Ssearch);
	    j = index (pgh, srh (i));
	    if index (pgh, srh (i)) > 0 then
	      Ssearch = TRUE;
	  end;
	end;
      end;

      if Ssearch then		/* Match found?				*/
        Iunit = Iunit - 1;		/* do-group always increments one too many.	*/
      return (Ssearch);

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

found_in_title:
  procedure returns (bit (1) aligned);

    dcl title_search   char (80) varying;
				/* translated title to be searched		*/

    if Scase_sensitive then
      title_search = Dlinfo_.unit (Iunit).title;
    else title_search = translate (Dlinfo_.unit (Iunit).title, "abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
				/* translate title to lower case.		*/
    Ssearch = FALSE;		/* Assume title matches until proven otherwise.	*/
    do i = 1 to dimension (srh, 1) while (^Ssearch);
      if index (title_search, srh (i)) > 0 then
        Ssearch = TRUE;
    end;

    return (Ssearch);

  end found_in_title;

    end BLOCK;

  end find_pgh;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


find_section:
  procedure (PDlinfo_, Scn, Scase_sensitive, Iunit) returns (fixed bin);

    dcl PDlinfo_	   ptr parm;	/* ptr to `descriptors for this log info seg. (In)*/
    dcl 1 Scn	   aligned parm,	/* Section title search args.	(In)		*/
	2 header	   like LIST.header,
	2 group	   (100) like LIST.group;
    dcl Scase_sensitive
		   bit(1) parm;	/* on if searching in case-sensitive fashion. (In)*/
    dcl Iunit	   fixed bin parm;	/* Pgh to start searching (In)		*/
				/* Pgh found. (Out)				*/

    dcl 1 Dlinfo_	   aligned based (PDlinfo_),
	2 Nunits	   fixed bin,	/* number of units (pghs) in this log info seg.	*/
	2 Nsections  fixed bin,	/* number of units having section title.	*/
	2 unit	   (0 refer (Dlinfo_.Nunits)) like Dlinfo.unit;

    dcl scn	   (Scn.N) char (88) varying;
				/* translated section title search args.	*/
    dcl Ssearch	   bit (1) aligned;
    dcl i		   fixed bin;
    dcl result	   fixed bin;
    dcl temp	   char (88) varying;
    dcl title	   char (88) varying;

    if Scn.N = 0 then
      return (no_match);		/* if nothing to search for, forget it.		*/
    do i = 1 to Scn.N;		/* translate search args to lower case.		*/
      if Scase_sensitive then
        scn (i) = Scn.arg (i);
      else scn (i) = translate (Scn.arg (i), "abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
    end;
    Ssearch = FALSE;		/* Search until matching section title found	*/
    do Iunit = Iunit to Dlinfo_.Nunits while (^Ssearch);
      if Dlinfo_.unit (Iunit).S.scn then
        do;
	if Scase_sensitive then
	  title = Dlinfo_.unit (Iunit).title;
	else title = translate (Dlinfo_.unit (Iunit).title, "abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
				/* translate title to lower case.		*/
	Ssearch = TRUE;		/* Assume title matches until proven otherwise.	*/
	do i = 1 to dimension (scn, 1) while (Ssearch);
	  if index (title, scn (i)) = 0 then
	    Ssearch = FALSE;
	end;
        end;
    end;
    if Ssearch then
      do;				/* Match found?				*/
        Iunit = Iunit - 1;		/* do-group always increments one too many.	*/
        temp = scn (1);
        do i = 2 to Scn.N;
	temp = temp || " ";
	temp = temp || scn (i);
        end;
        if temp = title then		/* check for exact match (except for letter case).*/
	result = exact_match;
        else result = match;
      end;
    else result = no_match;
    return (result);

  end find_section;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


format_list:
  procedure (Plist, Mcols, Mpghs);	/* This procedure formats a list of values.	*/

    dcl Plist	   ptr,		/* ptr to argument list to be printed.		*/
        Mcols	   fixed bin,	/* maximum number of columns to be used in format.*/
        Mpghs	   fixed bin,	/* maximum pghs to be used. 0 means no limit.	*/
        Sprint_inhibit bit (1) aligned; /* on if printing suppressed by pi.		*/


    dcl (Icol, Ipgh, Irow)
		   fixed bin,
        Pspaces	   ptr,
        Continued_arg  bit (1) aligned,
        long_line	   bit (1),
        Smultiple_words
		   bit (1),
        one_line_paragraph
		   bit (1),
        one_line_list  bit (1),
        Sdoes_not_fit  bit (1) aligned,
        No_args	   fixed bin (24),
        last_line	   fixed bin,
        length_args	   fixed bin (24),
        i		   fixed bin,
        j		   fixed bin,
        save_N	   fixed bin;


    dcl 1 list	   aligned based (Plist),
	2 header	   like LIST.header,
	2 group	   (0 refer (list.N)) like LIST.group,
	2 print_array
		   (0 refer (list.Npghs), 0 refer (list.Nrows)) like LIST.print_array;

    dcl line_position  fixed bin (24);



/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* Format the arguments in as many columns as possible to reduce the output lines.	*/
/* However, if the output fits in 2 or more rows, the number of rows is chosen so that	*/
/* all columns but the final one are full.					*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */


    Sdoes_not_fit = TRUE;
    long_line = FALSE;
    Smultiple_words = FALSE;
    one_line_paragraph = FALSE;
    one_line_list = FALSE;

    if Mcols < 1 then		/* Allow caller to limit number of columns.	*/
      list.Ncols = dimension (list.ML, 1);
    else list.Ncols = min (Mcols, dimension (list.ML, 1));

    save_N = list.N;		/* If arguments are combined then total number of */
				/* elements must be reduced for row calculation.  */

    do list.Ncols = list.Ncols to 1 by -1 while (Sdoes_not_fit);
      list.Nrows = divide (save_N + list.Ncols - 1, list.Ncols, 17, 0);
				/* Compute how many rows are required to display	*/
				/*   the args in list.Ncols columns.		*/

ROW_RETURN:			/* Row array bounds exceeded - recompute bounds   */
      if Mpghs = 1 then		/* compute how many paragraphs are needed.	*/
        list.Npghs = 1;
      else
        do;
	list.Npghs = divide (list.Nrows + help_args.max_Lpgh - 2, help_args.max_Lpgh - 1, 17, 0);
	list.Nrows = divide (list.Nrows + list.Npghs - 1, list.Npghs, 17, 0);
        end;

      do i = 1 to list.Npghs;
        do j = 1 to list.Nrows;
	list.print_array (i, j).line_out = SPACES;
        end;
      end;

      ct_lines = 0;
      No_args = 0;
      list.ML (*) = 0;
      line_position = 0;
      length_args = 0;
      Continued_arg = FALSE;
      one_line_paragraph = FALSE;
      long_line = FALSE;
      Smultiple_words = FALSE;

      do Ipgh = 1 to list.Npghs;
        do Icol = 1 to list.Ncols;
	if Icol = 1 then
	  line_position = 1;
	else line_position = line_position + list.ML (Icol - 1) + 3;
	do Irow = 1 to list.Nrows;
	  if No_args < list.N then
	    do;
	      No_args = No_args + 1;
	      list.ML (Icol) = max (list.ML (Icol), length (list.arg (No_args)));
	      if sum (list.ML) + (list.Ncols - 1) * 3 > Loutput_line then
	        goto line_to_long;
	      if Icol = 1 then	/*Clear row before using*/
	        print_array (Ipgh, Irow).line_out = "";

	      if length(list.arg (No_args)) >= length(CONSC_LINE_ARG_ID) then
	      if substr (list.arg (No_args), 1, 1) = CONSC_LINE_ARG_ID | substr (list.arg (No_args), 1, 1) = MULTI_LINE_ARG_ID
		 then
	        goto check_args;


	      if list.N <= 3 then
	        do;		/*If multiple words in arg and total number of args < 3*/
				/*then put in one column*/
		if multiple_words () then
		  do;
		    line_position = 1;
		    list.Nrows = list.N;
		    do i = No_args to list.N;
		      print_array (Ipgh, Irow).line_out = SPACES;
		      substr (print_array (Ipgh, Irow).line_out, line_position) = list.arg (No_args);
		      if line_position = 1 then
		        ct_lines = ct_lines + 1;
		      No_args = No_args + 1;
		      Irow = Irow + 1;
		    end;
		    No_args = No_args - 1;
				/* decrement No_args			*/
		  end;
	        end;

	      if list.Nrows > 1 then
	        if list.Ncols = 1 then/*If one col max and line is < Loutput then print entire*/
				/*line on the same line - dont fold.                    */
		if No_args + 1 <= list.N then
		  if length (list.arg (No_args + 1)) >= 2 then
                        if  substr (list.arg (No_args + 1), 1, 2) = SP_SP then
		    if length (list.arg (No_args)) - 1 + length (list.arg (No_args + 1)) <= Loutput_line then
		      do;
		        length_args = length (list.arg (No_args)) - 1 + length (list.arg (No_args + 1));
		        line_position = 1;
		        if substr (list.arg (No_args + 1), 3, 1) = "-" then
			substr (print_array (Ipgh, Irow).line_out, line_position, length_args + 1) =
			     list.arg (No_args) || substr (list.arg (No_args + 1), 2);
		        else substr (print_array (Ipgh, Irow).line_out, line_position, length_args + 1) =
			        list.arg (No_args) || substr (list.arg (No_args + 1), 3);
		        No_args = No_args + 1;
		        save_N = save_N - 1;
		        if line_position = 1 then
			ct_lines = ct_lines + 1;
		      end;

	      if ^Smultiple_words then
	        do;
		substr (print_array (Ipgh, Irow).line_out, line_position, length (list.arg (No_args))) = list.arg (No_args);
		if line_position = 1 then
		  ct_lines = ct_lines + 1;
	        end;

	      if No_args + 1 <= list.N then
	        if length (list.arg (No_args + 1)) >= 2 then
                    if substr (list.arg (No_args + 1), 1, 2) = SP_SP then
		if Irow = list.Nrows then
		  Continued_arg = TRUE;

check_args:
	      if length(list.arg (No_args)) >= length(MULTI_LINE_ARG_ID) then
	        if substr (list.arg (No_args), 1, 1) = MULTI_LINE_ARG_ID then
		do;		/* Multi line arguments*/
		  if list.N = 2 then
		    one_line_paragraph = TRUE;
		  else one_line_paragraph = FALSE;

		  if No_args + 1 <= list.N then
		    if length (list.arg (No_args)) - 1 + length (list.arg (No_args + 1)) < 
                           Loutput_line then
		      do;
		        length_args = length (list.arg (No_args)) - 1 + length (list.arg (No_args + 1));
		        if length_args ^> list.ML (Icol) | one_line_paragraph then
			do;	/*Combine arg lines if length permits*/
			  if ^one_line_paragraph then
			    if substr (list.arg (No_args + 1), 3, 1) = "-" then
			      substr (print_array (Ipgh, Irow).line_out, line_position, length_args + 1) =
				 substr (list.arg (No_args), 2) || substr (list.arg (No_args + 1), 2);

			    else substr (print_array (Ipgh, Irow).line_out, line_position, length_args) =
				    substr (list.arg (No_args), 2) || substr (list.arg (No_args + 1), 3);
			  else substr (print_array (Ipgh, Irow).line_out, line_position, length_args) =
				  substr (list.arg (No_args), 2) || substr (list.arg (No_args + 1), 3);
			  list.ML (Icol) = max (list.ML (Icol), length (list.arg (No_args)));
			  if sum (list.ML) + (list.Ncols - 1) * 3 > Loutput_line then
			    goto line_to_long;
			  No_args = No_args + 1;
			  save_N = save_N - 1;
			  if line_position = 1 then
			    ct_lines = ct_lines + 1;
			end;
		        else
			do;
			  substr (print_array (Ipgh, Irow).line_out, line_position, length (list.arg (No_args))) =
			       substr (list.arg (No_args), 2) || SP;
			  if Irow = list.Nrows then
			    Continued_arg = TRUE;
			  if line_position = 1 then
			    ct_lines = ct_lines + 1;
			end;
		      end;
		    else
		      do;
		        substr (print_array (Ipgh, Irow).line_out, line_position, length (list.arg (No_args))) =
			   substr (list.arg (No_args), 2) || SP;
		        if Irow = list.Nrows then
			Continued_arg = TRUE;
		        if line_position = 1 then
			ct_lines = ct_lines + 1;
		      end;
		end;

	      if length(list.arg (No_args)) >= length(CONSC_LINE_ARG_ID) then
	        if substr (list.arg (No_args), 1, 1) = CONSC_LINE_ARG_ID then
		do;		/* Consecutive line argument*/
		  substr (print_array (Ipgh, Irow).line_out, line_position, length (list.arg (No_args))) =
		       substr (list.arg (No_args), 2) || SP;
		  if line_position = 1 then
		    ct_lines = ct_lines + 1;
		  if Irow = list.Nrows then
		    Continued_arg = TRUE;
		end;

	      do while (Continued_arg);
	        No_args = No_args + 1;
	        list.ML (Icol) = max (list.ML (Icol), length (list.arg (No_args)));
	        if sum (list.ML) + (list.Ncols - 1) * 3 > Loutput_line then
		goto line_to_long;

	        Irow = Irow + 1;
	        if Irow > list.Nrows then
		do;
		  list.Nrows = list.Nrows + 1;
		  print_array (Ipgh, Irow).line_out = "";
		end;

	        if Icol = 1 then	/*Clear row initially*/
		print_array (Ipgh, Irow).line_out = "";
	        if print_array (Ipgh, Irow).line_out = "" then
		ct_lines = ct_lines + 1;
				/*A continued arg does not necessarily begin in col 1*/
	        substr (print_array (Ipgh, Irow).line_out, line_position, length (list.arg (No_args))) = list.arg (No_args);
	        if No_args = dim (list.arg, 1) then
		Continued_arg = FALSE;
	        else if length (list.arg (No_args + 1)) >= 2 & substr (list.arg (No_args + 1), 1, 2) ^= SP_SP then
		Continued_arg = FALSE;
	      end;

	      if No_args = list.N & Ipgh = list.Npghs & Icol = 1 then
	        do while (Irow < list.Nrows);
				/*More rows defined than there are actual arguments for last pgh*/
		Irow = Irow + 1;
		print_array (Ipgh, Irow).line_out = SPACES;
	        end;

	    end;			/*No_args<list.N*/
	end;			/*Irow*/
        end;			/*Icol*/
      end;			/*Ipgh*/

      if Irow > list.Nrows & No_args < list.N then
        do;
	list.Nrows = list.Nrows + 1;
	goto ROW_RETURN;
        end;

      Sdoes_not_fit = FALSE;
line_to_long:
    end;				/*Sdoes_not_fit*/

    list.Ncols = list.Ncols + 1;	/* do group decrements one too many */

    return;

multiple_words:
  proc returns (bit (1));
    Smultiple_words = FALSE;
    do i = No_args to list.N;
      j = verify (list.arg (i), SP);	/* Find 1st none blank character of string	*/
      if index (substr (list.arg (i), j), ",") = 0 & index (substr (list.arg (i), j), SP) ^= 0 then
        Smultiple_words = TRUE;
      if length(list.arg (i)) >= length(CONSC_LINE_ARG_ID) then
      if substr (list.arg (i), 1, 1) = CONSC_LINE_ARG_ID | substr (list.arg (i), 1, 1) = MULTI_LINE_ARG_ID then
        do;
	Smultiple_words = FALSE;
	return (Smultiple_words);
        end;
    end;
    return (Smultiple_words);

  end multiple_words;

print_list_nnl:
  entry (Plist, Sprint_inhibit);

    if Sprint_inhibit then
      return;
    Pspaces = addr (SPACES);
    if length (list.title) > 0 then
      call ioa_ ("^a:", list.title);
    go to PRINT_LIST;



print_list:
  entry (Plist, Sprint_inhibit);	/* This entry point prints a list and its title.	*/

    if Sprint_inhibit then
      return;
    Pspaces = addr (SPACES);
    if length (list.title) > 0 then
      do;
        if one_line_pgh & ^multiple_syntax & bf_no_ARG_dsp & Sfirst_time then
	call ioa_ ("^a:", list.title);
        else call ioa_ ("^/^a:", list.title);
      end;
    else if one_line_pgh then
      do;
        if bf_no_ARG_dsp & ^multiple_syntax & Sfirst_time then
	;
        else call iox_$put_chars (iox_$user_output, addr (NL), length (NL), 0);
      end;
    else if ^multiple_syntax & Sfirst_time then
      ;
    else call iox_$put_chars (iox_$user_output, addr (NL), length (NL), 0);

    Sfirst_time = FALSE;


find_end_array:			/*Find end of actual data so extraneous blank lines are not output*/
    Ipgh = list.Npghs;
    do Irow = list.Nrows to 1 by -1 while (print_array (Ipgh, Irow).line_out = SPACES);
    end;
    last_line = Irow;


PRINT_LIST:
    if Sprt_entry_pts then
       goto PRINT_EP_LIST;

    do Ipgh = 1 to list.Npghs;	/* Output paragraphs, one at a time.		*/
      if Ipgh > 1 then
        call out (NL);
      if Ipgh = list.Npghs then	/* Set last line of actual data.                  */
        list.Nrows = last_line;
      do Irow = 1 to list.Nrows;	/* Output rows, one at a time.		*/
        call ioa_ ("^a", print_array (Ipgh, Irow).line_out);
      end;
      Irow = Irow - 1;                  /* Loop increments 1 past hbound		*/
    end;
    return;

PRINT_EP_LIST:			/* Print ep list given on command line				*/
    help_args.Sctl.lep = FALSE;
    Sprt_entry_pts = FALSE;
    Sep_list_printed = TRUE;

    do Ipgh = 1 to list.Npghs;	/* Output paragraphs, one at a time.		*/
      if Ipgh > 1 then do;
        if Ipgh = list.Npghs then
	call command_query_$yes_no (yes_sw, 0, procedure_name,
           "Do you want to continue printing the entry point list?", "^d more lines.  More entrypoints?", last_line);
        else call command_query_$yes_no (yes_sw, 0, procedure_name,
           "Do you want to continue printing the entry point list?", "^d more lines.  More entrypoints?", list.Nrows);
        if ^yes_sw then
             return;
      end;

      if Ipgh ^= list.Npghs then        /* Output rows, one at a time.		*/
        do Irow = 1 to list.Nrows;
          call ioa_ ("^a", print_array (Ipgh, Irow).line_out);
        end;
      else do Irow = 1 to last_line;    /* Only print non-blank rows                      */
             call ioa_ ("^a", print_array (Ipgh, Irow).line_out);
           end;

      Irow = Irow - 1;                  /* Loop increments 1 past hbound		*/
    end;
    return;

output_list:
  entry (Plist, Apgh, Poutput, Loutput, Nlines);
				/* output 1 pgh of multipgh list into a string.	*/

    dcl Apgh	   fixed bin,	/* Number of pgh to output.			*/
        Poutput	   ptr,		/* ptr to output string.			*/
        Loutput	   fixed bin,	/* length of output string.			*/
        output	   char (Loutput) based (Poutput),
        Nlines	   fixed bin;	/* Lines in the output.			*/

    Nlines = 0;
    Loutput = 0;
    Pspaces = addr (SPACES);
    Ipgh = Apgh;
    if Ipgh = 1 then		/* Output NL which would follow section title	*/
      if length (list.title) > 0 then
        do;			/* in a regular (non-made-up) section.		*/
	call out (NL);
	Nlines = Nlines + 1;
        end;
    do Irow = 1 to list.Nrows;
      if Ipgh = list.Npghs & print_array (Ipgh, Irow).line_out = " " then
        return;
      call out ((print_array (Ipgh, Irow).line_out));
      call out (NL);
      Nlines = Nlines + 1;
    end;
    return;


out:
  proc (str);

    dcl str	   char (*);

    Loutput = Loutput + length (str);
    substr (output, Loutput - length (str) + 1, length (str)) = str;

  end out;


  end format_list;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

    dcl line_text	   char (Lline_text) based (Pline_text),
        Pline_text	   ptr,
        Lline_text	   fixed bin (21),
        line_text_arr  (Lline_text) char (1) based (Pline_text),
        line	   char (Lline) based (Pline),
        Pline	   ptr,
        Lline	   fixed bin (21),
        line_arr	   (Lline) char (1) based (Pline),
        Lparg	   fixed bin (21),
        bf_no_ARG_dsp  bit (1) init ("0"b),
        new_paragraph  bit (1) init ("0"b),
        one_line_paragraph
		   bit (1) init ("0"b),
        multiple_syntax
		   bit (1) init ("0"b),
        one_line_pgh   bit (1),
        Number_lines   fixed bin,
        Sconsecutive_arg_lines
		   bit (1);


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


get_arg_descriptions:
  procedure (Plist_cas, PDlinfo_, Plist_base, Sreally_old_format, Plists_of_args, Nlists_of_args);
				/* This procedure builds a list of argument	*/
				/* descriptions which match user-given arg names.	*/

    dcl (Plist_cas, PDlinfo_, Plist_base)
		   ptr,
        Sreally_old_format
		   bit (1),
        Plists_of_args (*) ptr,
        Nlists_of_args fixed bin;

    dcl 1 list_cas	   aligned based (Plist_cas),
	2 header	   like LIST.header,
	2 group	   (0 refer (list_cas.N)) like LIST.group;
    dcl 1 Dlinfo_	   aligned based (PDlinfo_),
				/* structure defining all paragraphs (units) in	*/
				/*   an entry point (logical info seg - linfo).	*/
	2 Nunits	   fixed bin,	/*   number of units in this ep.		*/
	2 Nsections  fixed bin,	/*   number of units beginning a section.	*/
	2 unit	   (0 refer (Dlinfo_.Nunits)) like Dlinfo.unit;

    dcl 1 list_base	   aligned based (Plist_base),
				/* struc locating lists of things to be output.	*/
	2 N	   fixed bin,	/*   number of output lists now allocated.	*/
	2 Nmax	   fixed bin,	/*   max number of list ptrs allocatable.	*/
	2 Ispace_used_set
		   fixed bin,	/*   index of last list on which space used set.	*/
	2 Plists	   (0 refer (list_base.Nmax)) ptr;
				/*   ptrs to allocated lists.			*/
				/*   unit (paragraph) descriptors.		*/
    dcl 1 list_args	   aligned based (Plist_args),
	2 header	   like LIST.header,
	2 group	   (0 refer (list_args.N)) like LIST.group;
    dcl Plist_args	   ptr,
        args	   char (Lline) based (Pline);

    dcl Iunit	   fixed bin,
        k		   fixed bin,
        save_args	   char(200) varying;		/* no lines longer than 200 allowed. 	  */

    Nlists_of_args = 0;
    list_cas.Snot_found (*) = 1;

    do Iunit = 1 to Dlinfo_.Nunits;
      if Dlinfo_.unit (Iunit).S.arg_list then
        do;
	if Dlinfo_.unit (Iunit).S.scn then
	  do;
	    if Nlists_of_args > 0 then
	      if list_args.N = 0 then
	        list_args.title = Dlinfo_.unit (Iunit).title;
	      else go to NEXT_LIST;
	    else
	      do;
NEXT_LIST:
	        if Nlists_of_args >= dimension (Plists_of_args, 1) then
		;
	        else
		do;
		  Nlists_of_args = Nlists_of_args + 1;
		  Plist_args, Plists_of_args (Nlists_of_args) = get_list (Plist_base);
		  list_args.title = Dlinfo_.unit (Iunit).title;
		end;
	      end;
	  end;
	Pline_text = Dlinfo_.unit (Iunit).Pstart;
	Lline_text = Dlinfo_.unit (Iunit).L;
	call line$skip_blanks;	/* strip off leading blanks if existant*/
	do while (Lline_text > 0);	/* Search pgh for arguments.			*/
	  if line$next () then
	    do;
	      if line$blank () | line$HT_SP () then
	        do;
		Sconsecutive_arg_lines = FALSE;
	        end;
	      else
	        do;		/* find arg				*/
		call line$args;
		save_args = args;
		do k = 1 to list_cas.N;
		  if search (list_cas.arg (k), "ABCDEFGHIJKMNOPQRSTUVWXYZ") = 0 then
		    if ^Scase_sensitive then
		      save_args = translate (save_args, "abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
		  if index (save_args, list_cas.arg (k)) > 0 then
		    do;
		      list_cas.Snot_found (k) = 0;
		      list_args.N = list_args.N + 1;
		      list_args.arg (list_args.N) = args;
				/*get the argument      */
		      do while (line$desc ());
		        list_args.N = list_args.N + 1;
		        list_args.arg (list_args.N) = args;
		      end;	/*get desc*/
		    end;		/*found arg*/
		end;		/*k=1 to list_cas.N*/
END_LOOP:
	        end;		/*find arg*/
	    end;			/*line$next*/
	end;			/*Lline_text>0*/
        end;			/*arg list*/
    end;				/*Iunit=1 to Dlinfo.Nunits*/
    if Nlists_of_args > 0 then	/* May have unused list.  If so, free it.	*/
      if list_args.N = 0 then
        do;
	list_base.N = list_base.N - 1;
	Nlists_of_args = Nlists_of_args - 1;
        end;
    if sum (list_cas.Snot_found) > 0 then
      do;				/* Any control arg names given by user unmatched?	*/
        if Nlists_of_args = 0 then
	do;
	  Nlists_of_args = Nlists_of_args + 1;
	  Plist_args, Plists_of_args (Nlists_of_args) = get_list (Plist_base);
	  list_args.title = "NO MATCH FOR " || list_cas.title || " STRINGS";
	end;
        else
	do;
	  list_args.N = list_args.N + 1;
	  list_args.arg (list_args.N) = "";
	  list_args.N = list_args.N + 1;
	  list_args.arg (list_args.N) = "NO MATCH FOR " || list_cas.title || " STRINGS:";
	end;
        do k = 1 to list_cas.N;
	if list_cas.Snot_found (k) > 0 then
	  do;
	    list_args.N = list_args.N + 1;
	    list_args.arg (list_args.N) = "  ";
	    list_args.arg (list_args.N) = list_args.arg (list_args.N) || list_cas.arg (k);
	  end;
        end;
      end;

  end get_arg_descriptions;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


get_arg_list:
  procedure (unit, Plist, Sreally_old_format);
				/* This procedure builds a list of arguments.	*/

    dcl 1 unit	   aligned like Dlinfo.unit,
        Plist	   ptr;		/* ptr to space for arg list.			*/

    dcl 1 list	   aligned based (Plist),
	2 header	   like LIST.header,
	2 group	   (0 refer (list.N)) like LIST.group,
	2 print_array
		   (0 refer (list.Npghs), 0 refer (list.Nrows)) like LIST.print_array;

    dcl Sreally_old_format
		   bit (1),
        args	   char (Lline) based (Pline),
				/*contains the control argument  */
        (i, j, k)	   fixed bin (24),
        remove_N	   fixed bin;


    j = 0;
    Sfirst_time = TRUE;
    Sremove_line = FALSE;
    Pline_text = unit.Pstart;		/* address the paragraph.			*/
    Lline_text = unit.L;
    call line$skip_blanks;
    do while (Lline_text > 0);	/* search pgh for arguments.			*/
      if line$next () then
        do;
	if line = "" | line = " " then
	  Sconsecutive_arg_lines = FALSE;
	else
	  do;
	    i = index (HT_SP, line_arr (1));
				/*Check to see if line begins with a HT_SP*/
	    if i > 0 then
	      Sconsecutive_arg_lines = FALSE;
	    else
	      do;
	        list.N = list.N + 1;
	        if list_of & line$list_items () then
				/*List of items with no descriptions*/
		list.arg (list.N) = line;
	        else
		do;
		  call line$args;

		  if Sremove_line & Sfirst_time then
		    do;		/*Can only remove text following section title or*/
				/*extraneous text at the end of the pgh.         */
		      Sfirst_time = FALSE;
		      if Sdescription_present & list.N ^= 2 then
		        Sremove_line = FALSE;
		      if ^Sdescription_present & list_of then
		        Sremove_line = FALSE;
		      if Sremove_line then
		        remove_N = list.N;
		    end;

		  if Lline > maxlength (list.arg (list.N)) then
		    call long_lines;
		  else list.arg (list.N) = args;
		end;

	        if list_of & ^Sconsecutive_arg_lines then
		call list_of_lines;
	        else if Sconsecutive_arg_lines then
		call consecutive_lines;
	        else if length (list.arg (list.N)) > 18 & index (list.arg (list.N), " ") ^= 0 then
		call multi_line_arg;
	      end;
	  end;
        end;			/*line$next*/
    end;				/*Lline_text > 0*/

    if Sremove_line then
      do;
        if remove_N = 2 then
	do;
	  k = remove_N + 1;
	  do j = k to list.N while (substr (list.arg (j), 1, 2) = SP_SP);
	    list.arg (2) = substr (list.arg (j), 3);
	  end;
	  do i = 3 to list.N while (j <= list.N);
	    list.arg (i) = list.arg (j);
	    j = j + 1;
	  end;
	  list.N = i - 1;
	end;
        else if ^Sdescription_present then
				/*Eliminate extraneous text at end of pgh      */
	list.N = remove_N - 1;
      end;


list_of_lines:
  proc;

    if length (list.arg (list.N)) < 36 then
      do;
        if list.N > 1 then
	if substr (reverse (list.arg (list.N - 1)), 1, 1) = "," then
				/* if prior line ends in a comma assume this is a	*/
				/* continued line				*/
	  list.arg (list.N) = SP_SP || list.arg (list.N);
        return;
      end;
    list.N = list.N + 1;
    i = index (substr (list.arg (list.N - 1), 25, 12), ",");
				/* first position > 25 and <= 36 with a comma*/
    if i > 0 then
      i = 25 + i - 1;
    else
      do;				/* last position < 36 with a comma*/
        i = index (reverse (substr (list.arg (list.N - 1), 1, 36)), ",");
        if i > 0 then
	i = 36 - i + 1;
      end;
    if i = 0 then
      do;				/* closest word boundary*/
        i = index (reverse (substr (list.arg (list.N - 1), 1, 36)), SP);
        if i > 0 then
	i = 36 - i + 1;
      end;
    if i = 0 then
      i = index (substr (list.arg (list.N - 1), 36), SP);

    if i = 0 then
      i = 36;			/* if all else fails use length of 36 */
    list.arg (list.N) = SP_SP || ltrim (substr (list.arg (list.N - 1), i + 1));
    list.arg (list.N - 1) = MULTI_LINE_ARG_ID || substr (list.arg (list.N - 1), 1, i);
  end list_of_lines;


consecutive_lines:
  proc;

    j = index (list.arg (list.N), NL);
    if j > 0 then
      do;				/*Set up header line*/
        list.N = list.N + 1;
        list.arg (list.N) = SP_SP || substr (list.arg (list.N - 1), j + 1);
        list.arg (list.N - 1) = CONSC_LINE_ARG_ID || substr (list.arg (list.N - 1), 1, j - 1);

        k = index (list.arg (list.N - 1), HT_SP);
				/*Strip off trailing spaces/HT*/
        if k > 0 then
	list.arg (list.N - 1) = substr (list.arg (list.N - 1), 1, k - 1);
      end;

    j = index (list.arg (list.N), NL);	/*Multiple detail lines*/
    do while (j > 0);
      list.N = list.N + 1;
      list.arg (list.N) = SP_SP || substr (list.arg (list.N - 1), j + 1);
      list.arg (list.N - 1) = substr (list.arg (list.N - 1), 1, j - 1);
      k = index (list.arg (list.N - 1), HT_SP);
				/*strip off trailing spaces/HT*/
      if k > 0 then
        list.arg (list.N - 1) = substr (list.arg (list.N - 1), 1, k - 1);

      j = index (list.arg (list.N), NL);
    end;

  end consecutive_lines;


multi_line_arg:
  proc;				/*Multi line argument*/
    j = index (list.arg (list.N), "-"); /*find 1st argument*/
    i = index (substr (list.arg (list.N), 18), "-");
				/*find argument starting in position > 18*/

    if i ^= 0 then			/*add offset - 1*/
      i = i + 17;
    else
      do;				/*find 2nd argument in position < 18*/
        i = index (substr (list.arg (list.N), j + 1), "-");
        if i = 0 then
	do;
	  i = index (substr (list.arg (list.N), 18), ",");
				/*1st position > 18 with a comma or length of prior arg if >*/
	  if i ^= 0 then
	    i = i + 17;
	  else
	    do;
	      i = index (substr (list.arg (list.N), 18), " ");
				/*1st position > 18 with a blank*/
	      if i ^= 0 then
	        i = i + 17;
	      else
	        do;
		i = index (list.arg (list.N), " ");
		if i >= 18 then
		  i = 18;
	        end;
	    end;
	end;
      end;

    list.N = list.N + 1;
    list.arg (list.N) = SP_SP || substr (list.arg (list.N - 1), i);
    list.arg (list.N - 1) = MULTI_LINE_ARG_ID || substr (list.arg (list.N - 1), 1, i - 1);

    k = length (list.arg (list.N - 1));
    j = verify (reverse (list.arg (list.N - 1)), HT_SP);
				/*strip off trailing spaces/HT*/
    if j > 1 then
      list.arg (list.N - 1) = substr (list.arg (list.N - 1), 1, k - j + 1);

  end multi_line_arg;

long_lines:
  proc;
    j = index (line, NL);
    if j > 0 then
      do;				/*Set up header line*/
        list.arg (list.N) = CONSC_LINE_ARG_ID || substr (line, 1, j);
        if Lline - j > 0 then
	Pline = addr (line_arr (j + 1));
        Lline = Lline - j;
      end;

    do while (Lline > 0);		/*Set up detail lines*/
      j = index (line, NL);
      if j > 0 then
        do;
	list.N = list.N + 1;
	list.arg (list.N) = SP_SP || substr (line, 1, j);
	if Lline - j > 0 then
	  Pline = addr (line_arr (j + 1));
	Lline = Lline - j;
        end;
      else
        do;
	list.N = list.N + 1;
	list.arg (list.N) = SP_SP || line;
	Lline = 0;
        end;
    end;
  end long_lines;

  end get_arg_list;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


get_brief_data:
  proc (Sold_format, Sheader, PDlinfo_, Plist_base, dir, ent, Nlast_info_no_brief_data, Iinfo, Ninfos_printed, Iunit_syntax,
       Nunit_bf_prt, Nlists_of_bf_args, Nlines);

    dcl Sold_format	   bit (1) unal,	/* on if log info contains \006 chars.		*/
        Sheader	   bit (1) unal,	/* on if -header required.			*/
        PDlinfo_	   ptr,		/* ptr to pgh descriptors of log info.		*/
        Plist_base	   ptr,		/* ptr to list of lists.			*/
        dir	   char (168) unal, /* dir part of phys info seg's path.		*/
        ent	   char (32) unal,	/* ent part of phys info seg's path.		*/
        Nlast_info_no_brief_data
		   fixed bin,	/* Last info processed not containing Syntax sect.*/
        Iinfo	   fixed bin,	/* number of the info seg being processed.	*/
        Ninfos_printed fixed bin,	/* number of infos for which something printed.	*/
        Iunit_syntax   (10) fixed bin,	/* indices of Syntax sections.		*/
        Nunit_bf_prt   fixed bin,	/* count of brief sections to print.		*/
        Nlists_of_bf_args
		   fixed bin,	/* count of sections containing args/ctl_args.	*/
        Nlines	   fixed bin,
        save_lines	   fixed bin;

    dcl 1 Dlinfo_	   aligned based (PDlinfo_),
	2 Nunits	   fixed bin,	/* number of units (pghs) in this log info seg.	*/
	2 Nsections  fixed bin,	/* number of units having section title.	*/
	2 unit	   (0 refer (Dlinfo_.Nunits)) like Dlinfo.unit;

    dcl Iunit	   fixed bin,
        Plist	   ptr,
        (i, j, k)	   fixed bin;

    dcl 1 list_base	   aligned based (Plist_base),
	2 N	   fixed bin,	/* number of lists in this list ptr structure.	*/
	2 Nmax	   fixed bin,	/* max possible number of lists in structure.	*/
	2 Ispace_used_set
		   fixed bin,	/* index of last list on which space used was set.*/
	2 Plists	   (0 refer (list_base.Nmax)) ptr;
				/* pointers to list structures.		*/

    dcl 1 list	   aligned based (Plist),
	2 header	   like LIST.header,
	2 group	   (0 refer (list.N)) like LIST.group,
	2 print_array
		   (0 refer (list.Npghs), 0 refer (list.Nrows)) like LIST.print_array;

    dcl store_arg	   char (88) varying;

    Syntax_section, Sprt_list_of, Sprt_one_paragraph, Sprt_bf_heading = FALSE;
    Nunit_bf_prt = 0;
    save_lines = 0;


    do Iunit = 1 to Dlinfo_.Nunits while (^Dlinfo_.unit (Iunit).S.syntax_list);
    end;				/*   Search for the "Syntax" section.             */
    if Iunit <= Dlinfo.Nunits then
      do;
        Syntax_section = TRUE;
        do i = 1 to dimension (Iunit_syntax, 1) while (Iunit <= Dlinfo_.Nunits);
	Iunit_syntax (i) = Iunit;	/* Find & record location of syntax sections.     */
	Nunit_bf_prt = i;
	do Iunit = Iunit, Iunit + 1 to Dlinfo_.Nunits while (^Dlinfo_.unit (Iunit).S.scn);
	  Nlines = Nlines + Dlinfo_.unit (Iunit).Nlines + 1;
	end;			/* Count lines in each pgh of Syntax section.     */
				/* Add 1 line for blank line preceding each pgh.  */


	if ^Sold_format then
	  do Iunit = Iunit to Dlinfo_.Nunits
	       while (substr (Dlinfo_.unit (Iunit).title, 1, min (6, length (Dlinfo_.unit (Iunit).title))) ^= "Syntax");
	  end;
	else Iunit = Dlinfo_.Nunits + 1;
        end;
      end;

    save_lines = save_lines + Nlines;

    if ^Syntax_section then
      do;
        do Iunit = 1 to Dlinfo_.Nunits while (^Dlinfo_.unit (Iunit).S.arg_list);
        end;
        if Iunit <= Dlinfo_.Nunits then
	do;
	  Sprt_args = TRUE;
	  Nunit_bf_prt = 1;
	  goto end_ck;
	end;

        do Iunit = 1 to Dlinfo_.Nunits while (^Dlinfo_.unit (Iunit).S.list_of_list);
        end;
        if Iunit <= Dlinfo_.Nunits then
	do;
	  Sprt_list_of = TRUE;
	  Nunit_bf_prt = 1;
	  goto end_ck;
	end;

        Sprt_one_paragraph = TRUE;

end_ck:
      end;


    Iunit = 1;
    do while (Iunit <= Dlinfo_.Nunits); /* Search for "Arguments" & "Control arguments" & "List of  */
				/*   paragraphs to summarize these arguments.     */
      if Sprt_args | Syntax_section then
        do Iunit = Iunit to Dlinfo_.Nunits while (^Dlinfo_.unit (Iunit).S.arg_list);
        end;

      if Sprt_list_of then
        do Iunit = Iunit to Dlinfo_.Nunits while (^Dlinfo_.unit (Iunit).S.list_of_list);
				/* Search for List of                            */
        end;


      if Iunit <= Dlinfo_.Nunits then
        do;
	Plist = get_list (Plist_base);
	if Plist = null () then
	  Iunit = Dlinfo_.Nunits + 1;
	else
	  do;

	    if Sprt_one_paragraph then
	      do;
	        Nlines = Dlinfo_.unit (Iunit).Nlines;
	        Nlists_of_bf_args = list_base.N;
	        Nunit_bf_prt = 1;
	        return;
	      end;

	    list.title = Dlinfo_.unit (Iunit).title;
	    list.Iunit = Iunit;
	    if length (list.title) <= 17 then
	      do;
	        list.N = 1;
	        list.arg (1) = list.title;
	        list.arg (1) = list.arg (1) || ":";
	      end;		/* Put title on same line as arg names, unless	*/
				/* title is too long.			*/


	    do Iunit = Iunit, Iunit + 1 to Dlinfo_.Nunits while (^Dlinfo_.unit (Iunit).S.scn);
	      list_of = Dlinfo_.unit (Iunit).S.list_of_list;
				/* Switch to indicate unit is a list of items or examples*/
	      call get_arg_list (Dlinfo_.unit (Iunit), Plist, Sold_format);
	    end;
	    if Syntax_section & list.N > 0 & list.title = "Arguments" then
	      do;			/* Suppress Arguments list if all arg names	*/
				/* appear in Syntax section.			*/
	        if list.arg (1) = "Arguments:" then
		i = 2;
	        else i = 1;
	        Sfound = TRUE;
	        bf_no_ARG_dsp = FALSE;
	        do i = i to list.N while (Sfound);
		do j = 1 to Nunit_bf_prt while (Sfound);
		  Ppgh = Dlinfo_.unit (Iunit_syntax (j)).Pstart;
		  Lpgh = Dlinfo_.unit (Iunit_syntax (j)).L;
		  if list.arg (i) ^= "," then
		    store_arg = rtrim (list.arg (i), "])0123456789, ");
		  else store_arg = rtrim (list.arg (i), "])0123456789 ");
		  store_arg = ltrim (store_arg, "[(");
		  k = index (pgh, store_arg);
		  if k = 0 then
		    Sfound = FALSE;
		  else j = Nunit_bf_prt;
				/*Dont continue looking if found arg*/
		end;
	        end;
	        if Sfound then
		do;
		  list.N = 0;
		  bf_no_ARG_dsp = TRUE;
		end;
	      end;

	    if list.N = 1 then
	      if list.title = substr (list.arg (1), 1, length (list.arg (1)) - 1) then
	        list.N = 0;


	    if list.N > 0 then
	      do;
	        if list.title = substr (list.arg (1), 1, length (list.arg (1)) - 1) then
		list.title = "";
	        call format_list (Plist, 0, 1);
	        save_lines = save_lines + ct_lines + 1;
				/*One line for blank line preceeding pgh*/
	        if length (list.title) > 0 then
		save_lines = save_lines + 1;
	      end;
	    else list_base.N = list_base.N - 1;
	  end;
        end;
    end; 
    Nlists_of_bf_args = list_base.N;
    Nlines = save_lines;
    return;


print_brief_data:
  entry (PDlinfo_, Plist_base, Iunit_syntax, Nunit_bf_prt, Nlists_of_bf_args, Nlines);


    if Sprt_one_paragraph then
      do;
        if Sprt_bf_heading then
	do;
	  Nlines = Dlinfo_.unit (Iunit).Nlines + 2;
	  call print_header ();
	end;
        else Nlines = Dlinfo_.unit (Iunit).Nlines;
        call print_pgh (Dlinfo_.unit (Iunit), Sprint_inhibit);
        Nlists_of_bf_args = list_base.N;
        return;
      end;

    Iunit = 0;
    j = 1;			/* For -brief, print Syntax section and list of	*/
    do i = 1 to Nunit_bf_prt;		/* ctl args in order that their sections appear	*/
PRINT_NEXT_LIST:
      if j <= Nlists_of_bf_args then
        do;			/* in the info.				*/
	Plist = list_base.Plists (j); /*   Print lists of args.			*/
	if list.Iunit < Iunit_syntax (i) then
	  do;
	    call print_list (Plist, FALSE);
	    j = j + 1;
	    go to PRINT_NEXT_LIST;
	  end;
        end;

      Sfirst_time = TRUE;

      if Syntax_section then
        do Iunit = Iunit_syntax (i), Iunit + 1 to Dlinfo_.Nunits while (^Dlinfo_.unit (Iunit).S.scn);
	if Iunit = Iunit_syntax (1) then
	  multiple_syntax = FALSE;
	else multiple_syntax = TRUE;

	call print_pgh (Dlinfo_.unit (Iunit), FALSE);
        end;			/* Print syntax sections.			*/

      if ^multiple_syntax then
        Sfirst_time = FALSE;
    end;

    if Iunit > 1 then
      if Dlinfo_.unit (Iunit - 1).Nlines = 1 then
        one_line_pgh = TRUE;
      else one_line_pgh = FALSE;
    else one_line_pgh = FALSE;


    do j = j to Nlists_of_bf_args;	/* Print remaining lists of ctl args.		*/
      call print_list (list_base.Plists (j), FALSE);
    end;


    if Nlists_of_bf_args > 0 then
      do;
        Pnext_free_space = list_base.Plists (1);
        list_base.N = 0;
      end;
    return;

  end get_brief_data;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


get_ep_list:
  procedure (ref_name, PDeps_, Plist);	/* Create list of entry points in this phys. seg.	*/

    dcl ref_name	   char (32) varying,
        (PDeps_, Plist)
		   ptr;

    dcl 1 Deps_	   aligned based (PDeps_),
	2 Nlines	   fixed bin,
	2 N	   fixed bin,
	2 linfo	   (0:0 refer (Deps_.N)) like Deps.linfo;
    dcl 1 list	   aligned based (Plist),
	2 header	   like LIST.header,
	2 group	   (0 refer (list.N)) like LIST.group,
	2 print_array
		   (0 refer (list.Npghs), 0 refer (list.Nrows)) like LIST.print_array;

    dcl (i, j, k)	   fixed bin;

    do i = 1 to Deps.N;		/* Build list of all entry point info headers.	*/
      k, list.N = list.N + 1;
      if length (Deps_.linfo (i).header) > 0 then
        do;			/* If header already exists, use it.		*/
	list.arg (k) = Deps_.linfo (i).header;
	if length (list.arg (k)) > 21 then
	  do;			/* Split a long heading into several lines.	*/
	    j = 20 + index (substr (list.arg (k), 21), SP);
	    do while (j > 20);
	      k, list.N = list.N + 1;
	      list.arg (k) = "   ";
	      j = j + verify (substr (list.arg (k - 1), j), SP) - 1;
	      list.arg (k) = list.arg (k) || substr (list.arg (k - 1), j);
	      list.arg (k - 1) = rtrim (substr (list.arg (k - 1), 1, j - 1));
	      if length (list.arg (k)) > 21 then
	        j = 20 + index (substr (list.arg (k), 21), SP);
	      else j = 0;
	    end;
	  end;
        end;
      else
        do;			/* If doesn't exist, make one up.		*/
	list.arg (k) = ref_name;
	list.arg (k) = list.arg (k) || "$";
	list.arg (k) = list.arg (k) || Deps_.linfo (i).ep_name (1);
	do j = 2 to Deps_.linfo (i).Nep_names;
	  list.arg (k) = list.arg (k) || ",";
	  k, list.N = list.N + 1;
	  list.arg (k) = "   ";
	  list.arg (k) = list.arg (k) || ref_name;
	  list.arg (k) = list.arg (k) || "$";
	  list.arg (k) = list.arg (k) || Deps_.linfo (i).ep_name (j);
	end;
	Deps_.linfo (i).header = list.arg (k);
				/* Apply fruits of our labor by using header	*/
				/* in entry point info as well.		*/
        end;
    end;

  end get_ep_list;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


get_list:
  procedure (Plist_base) returns (ptr); /* This procedure allocates a new list in	*/
				/*   the help_args segment.			*/

    dcl Plist_base	   ptr;

    dcl 1 list_base	   aligned based (Plist_base),
	2 N	   fixed bin,	/* number of lists in this list ptr structure.	*/
	2 Nmax	   fixed bin,	/* max possible number of lists in structure.	*/
	2 Ispace_used_set
		   fixed bin,	/* index of last list on which space used was set.*/
	2 Plists	   (0 refer (list_base.Nmax)) ptr,
				/* pointers to list structures.		*/
        Plist	   ptr,
        1 list	   aligned based (Plist),
	2 header	   like LIST.header,
	2 group	   (0 refer (list.N)) like LIST.group,
	2 print_array
		   (0 refer (list.Npghs), 0 refer (list.Nrows)) like LIST.print_array;


    if list_base.N = dimension (list_base.Plists, 1) then
      return (null);		/* list of lists full.  Oops!			*/
    if list_base.Ispace_used_set > list_base.N then
      list_base.Ispace_used_set = 0;
    if list_base.Ispace_used_set < list_base.N - 1 then
      return (null);		/* someone forgot to set space used for a list	*/
				/* other than the last in  list of lists.	*/
    if list_base.Ispace_used_set = list_base.N - 1 then
      do;
        Plist = list_base.Plists (list_base.N);
				/* set space used for last list.		*/
        Pnext_free_space = set_space_used (Pnext_free_space, currentsize (list));
        list_base.Ispace_used_set = list_base.N;
      end;
    list_base.N = list_base.N + 1;	/* get new list.				*/
    Plist = Pnext_free_space;
    list_base.Plists (list_base.N) = Plist;
    list.N = 0;
    list.Nreal = 0;
    list.title = "";
    return (Plist);


set_list_size:
  entry (Plist_base, Plist);		/* This procedure sets the size of the current list*/

    if list_base.N = dimension (list_base.Plists, 1) then
      Plist = null;			/* list of lists full.  Oops!			*/
    if list_base.Ispace_used_set > list_base.N then
      list_base.Ispace_used_set = 0;
    if list_base.Ispace_used_set < list_base.N - 1 then
      Plist = null;			/* someone forgot to set space used for a list	*/
				/* other than the last in  list of lists.	*/
    if list_base.Ispace_used_set = list_base.N - 1 then
      do;
        Plist = list_base.Plists (list_base.N);
				/* set space used for last list.		*/
        Pnext_free_space = set_space_used (Pnext_free_space, currentsize (list));
        list_base.Ispace_used_set = list_base.N;
      end;
    return;


give_list_back:			/*return current list*/
  entry (Plist_base, Plist);

    if Plist ^= list_base.Plists (list_base.N) then
      do;
        call ioa_ ("help logic error");
        return;
      end;
    list_base.N = list_base.N - 1;
    Plist = null;
    return;

  end get_list;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


get_list_base:
  procedure (Pnext_free_space, space_used, Nmax) returns (ptr);

    dcl Pnext_free_space
		   ptr,		/* ptr to next free word of space in temp seg.	*/
        space_used	   fixed bin (21),	/* number of words used at that free word loc.	*/
        Nmax	   fixed bin,	/* number of lists to maintain in list of lists.	*/
        Plist_base	   ptr;		/* ptr to creates list of lists.		*/

    dcl 1 list_base	   aligned based (Plist_base),
	2 N	   fixed bin,	/* number of lists in this list ptr structure.	*/
	2 Nmax	   fixed bin,	/* max possible number of lists in structure.	*/
	2 Ispace_used_set
		   fixed bin,	/* index of last list on which space used was set.*/
	2 Plists	   (0 refer (list_base.Nmax)) ptr;
				/* pointers to list structures.		*/

    if space_used ^= 0 then		/* set space used by previous allocation.	*/
      Pnext_free_space = set_space_used (Pnext_free_space, space_used);
    Plist_base = Pnext_free_space;	/* get list of lists.			*/
    list_base.N = 0;		/* No lists listed yet.			*/
    list_base.Ispace_used_set = 0;
    list_base.Nmax = Nmax;
    if Nmax > 0 then		/* Size known?  Set space used.		*/
      Pnext_free_space = set_space_used (Pnext_free_space, currentsize (list_base));
    return (Plist_base);

  end get_list_base;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


get_title_list:
  procedure (PDlinfo_, Plist, Iunit_start);
				/* This entry builds a list of titles.		*/

    dcl PDlinfo_	   ptr,
        Plist	   ptr,
        Iunit_start	   fixed bin;	/* Current unit number.  Get title of following	*/
				/* units.					*/

    dcl Iunit	   fixed bin,
        Nlines	   fixed bin,
        Nlines_pic	   pic "zzzzz9",
        (i, j, k)	   fixed bin;
    dcl 1 Dlinfo_	   aligned based (PDlinfo_),
				/* structure defining all paragraphs (units) in	*/
				/*   an entry point (logical info seg - linfo).	*/
	2 Nunits	   fixed bin,	/*   number of units in this ep.		*/
	2 Nsections  fixed bin,	/*   number of units beginning a section.	*/
	2 unit	   (0 refer (Dlinfo_.Nunits)) like Dlinfo.unit;
				/*   unit (paragraph) descriptors.		*/
    dcl 1 list	   aligned based (Plist),
	2 header	   like LIST.header,
	2 group	   (0 refer (list.N)) like LIST.group,
	2 print_array
		   (0 refer (list.Npghs), 0 refer (list.Nrows)) like LIST.print_array;

    do Iunit = Iunit_start + 1 to Dlinfo_.Nunits;
      if (get_title ()) then
        do;
	k, list.N = list.N + 1;
	if Iunit = 1 then
	  if ^Dlinfo_.unit (1).S.scn then
	    list.arg (k) = "UNTITLED";
	  else list.arg (k) = Dlinfo_.unit (Iunit).title;
	else list.arg (k) = Dlinfo_.unit (Iunit).title;
	if length (list.arg (k)) > 21 then
	  do;			/* Split a long section title into several lines.	*/
	    j = 20 + index (substr (list.arg (k), 21), SP);
	    do while (j > 20);
	      k, list.N = list.N + 1;
	      list.arg (k) = "   ";
	      j = j + verify (substr (list.arg (k - 1), j), SP) - 1;
	      list.arg (k) = list.arg (k) || substr (list.arg (k - 1), j);
	      list.arg (k - 1) = MULTI_LINE_ARG_ID || rtrim (substr (list.arg (k - 1), 1, j - 1));
	      if length (list.arg (k)) > 21 then
	        j = 20 + index (substr (list.arg (k), 21), SP);
	      else j = 0;
	    end;
	  end;
	Nlines = Dlinfo_.unit (Iunit).Nlines;
				/* Count lines in  section.			*/
	do i = Iunit + 1 to Dlinfo_.Nunits while (^Dlinfo_.unit (i).S.scn);
	  Nlines = Nlines + Dlinfo_.unit (i).Nlines + 2;
	end;
	Iunit = i - 1;
	Nlines_pic = Nlines;
	list.arg (k) = list.arg (k) || " (";
	list.arg (k) = list.arg (k) || ltrim (Nlines_pic);
	list.arg (k) = list.arg (k) || ")";
        end;
    end;

get_title:
  proc returns (bit (1));

    if Dlinfo_.unit (Iunit).S.ep_list then
      return (FALSE);
    else if Dlinfo_.unit (Iunit).S.scn then
      return (TRUE);
    else if Iunit = 1 then
      return (TRUE);
    else return (FALSE);

  end get_title;

    if list.N = 0 then
      do;
        list.N = 1;
        list.arg (1) = "NO MORE TITLES";
      end;

  end get_title_list;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

dcl     Phelp_requests ptr;

list_requests:
  proc;

    dcl error_type	   fixed bin,
        code	   fixed bin (35);

    dcl 1 help_requests
		   aligned based (Phelp_requests) like help_args;

    Phelp_requests = help_args.help_data_ptr;

    if Phelp_requests = null then 
      do;
        call old_help_$init (ME, "info", "", Vhelp_args_3, help_args.help_data_ptr, code);
        if code ^= 0 then 
          do;
            call ioa_ ("Unable to initiate old_help_ for list request.");
            goto QUIT;
          end;
        Phelp_requests = help_args.help_data_ptr;
      end;
    
    help_requests.Npaths = 1;
    help_requests.path(1).value = ">doc>info>help_responses";
    help_requests.path(1).info_name = "";

    if lr.N > 0 then do;
      do i = 1 to lr.N;
        help_requests.Npaths = i;
        if i > 1 then
	help_requests.path (i).value = help_requests.path(1).value;
        if lr.ca (i) = "." | lr.ca (i) = "?" | lr.ca (i) = ".." then
	help_requests.path(i).S.info_name_not_starname = TRUE;
        help_requests.path (i).info_name = lr.ca (i);
      end;
      call ioa_ ("^/----------HELP RESPONSE^[S^;-^]---------", lr.N>1);
    end;
    else
    call ioa_ ("^/---------------------------------");

    call old_help_ (ME, Phelp_requests, "info", error_type, code);

    help_requests.Npaths = 0;
    call ioa_ ("---END OF RESPONSE DESCRIPTION---");
    return;

  end list_requests;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


parse_answer:
  proc (answer, op, ep_name, ca, scn, srh, lr);

    dcl answer	   char (500) varying,
        op	   fixed bin,	/* Operation specified by the answer.		*/
        ep_name	   char (65) varying,
				/* Name of entry point given  in ep request.	*/
        1 ca	   aligned,
	2 header	   like LIST.header,
	2 group	   (100) like LIST.group,
        1 scn	   aligned,
	2 header	   like LIST.header,
	2 group	   (100) like LIST.group,
        1 srh	   aligned,
	2 header	   like LIST.header,
	2 group	   (100) like LIST.group,
        1 lr	   aligned,
	2 N	   fixed bin,
	2 ca	   (100) char (32) varying;

    dcl (i, j, k)	   fixed bin,
        operation	   char (24) varying,  /* maxlength must be longer than longest defined_op */
        operand	   char (89) varying;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* The tables below define the following combinations of answers and control args.	*/
/*									*/
/*    OP_CODE OPERATION   OP_CODE OPERATION   OP_CODE OPERATION  OP_CODE OPERATION	*/
/*	 1  yes, y	 5  rest, r	 9  skip, s        14  title		*/
/*	 2  no, n		 6  rest -scn       10  skip -scn	   titles		*/
/*	 3  quit, q	 7  rest -aep 	11  skip -ep       15  title -top	*/
/*	 4  top, t	 8  rest -ep	12  skip -rest	   titles -top	*/
/*					13  skip -seen     16  entry_point {STR}*/
/*							   ep {STR}	*/
/*									*/
/*	17  section {STRs}			21  search {STRs}			*/
/*	    scn     {STRs}			    srh    {STRs}			*/
/*	    section {STRs} -ncs		    search {STRs} -ncs		*/
/*	    scn     {STRs} -ncs		    srh    {STRs} -ncs		*/
/*	18  section {STRs} -cs     		22  search {STRs} -cs     		*/
/*	    scn     {STRs} -cs       		    srh    {STRs} -cs     		*/
/*	19  section {STRs} -top		23  search {STRs} -top		*/
/*	    scn     {STRs} -top		    srh    {STRs} -top		*/
/*	    section {STRs} -top -ncs		    search {STRs} -top -ncs		*/
/*	    scn     {STRs} -top -ncs		    srh    {STRs} -top -ncs		*/
/*	20  section {STRs} -top -cs  		24  search {STRs} -top -cs  		*/
/*	    scn     {STRs} -top -cs  		    srh    {STRs} -top -cs  		*/
/*									*/
/*	25  brief				30  list_entry_points		*/
/*	    bf				    lep   			*/
/*	26  control_arg STRs		31  list_requests {STRs}		*/
/*	    ca STRs			    lr            {STRs}     		*/
/*	27  .				32  help                                */
/*	28  ?				    h                                   */
/*	29  header							*/
/*	    he								*/
/*									*/
/* -scn is the short name for -section.  Both are accepted.				*/
/* sc is obsolete short name for section.  It is still accepted, but -sc is not accept	*/
/*	as control arg in help requests.  It is accepted in command line, however.	*/
/* sh is obsolete short name for search.   It is still accepted.			*/
/* titles is in error, but is a common error for the title request.  Accept it anyway.	*/
/* -ep  is the short name for -entry_point.  Both are accepted.			*/
/* list_request and help both return help on a help response.                             */
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

    dcl defined_ops	   (36) char (20) varying int static options (constant) init (
		      "yes", "y", "no", "n",		/*  1 to  4 */
		      "quit", "q", "top", "t",	/*  5 to  8 */
		      "rest", "r", "skip", "s",	/*  9 to 12 */
		      "title", "titles",		/* 13 &  14 */
		      "entry_point", "ep",		/* 15 &  16 */
		      "section", "scn", "sc",		/* 17 to 19 */
		      "search", "srh", "sh",		/* 20 to 22 */
		      "brief", "bf",		/* 23 &  24 */
		      "control_arg", "ca",		/* 25 &  26 */
		      ".", "?", "header", "he",	/* 27 to 30 */
		      "list_entry_points", "lep",	/* 31 to 32 */
		      "list_requests", "lr",		/* 33 to 34 */
		      "help", "h"),			/* 35 to 36 */
        op_code	   (36) fixed bin int static options (constant) init (
		   /* "yes", "y", "no", "n",		*/  1,  1,  2,  2, 
		   /* "quit", "q", "top", "t",	*/  3,  3,  4,  4, 
		   /* "rest", "r", "skip", "s",	*/  5,  5,  9,  9, 
		   /* "title", "titles",		*/ 14, 14, 
		   /* "entry_point", "ep",		*/ 16, 16, 
		   /* "section", "scn", "sc",		*/ 17, 17, 17, 
		   /* "search", "srh", "sh",		*/ 21, 21, 21,
		   /* "brief", "bf",		*/ 25, 25,
		   /* "control_arg", "ca",		*/ 26, 26, 
		   /* ".", "?", "header", "he",	*/ 27, 28, 29, 29,
		   /* "list_entry_points", "lep",	*/ 30, 30,
		   /* "list_requests", "lr",		*/ 31, 31, 
		   /* "help", "h"),			*/ 32, 32);

    dcl prev_operand   fixed bin;
    dcl (OPERAND_NCS   init (0),        /* 0           -ncs    */
         OPERAND_CS	   init (1),        /* 1           -cs    */
         OPERAND_TOP   init (2))        /* 2           -top    */
		   fixed bin int static options(constant);

    k = 0;			/* No search  or section operands processed yet.	*/
    ca.N = 0;			/* Control_args must be given  with every ca req.	*/
    lr.N = 0;
    ep_name = "";
    i = search (answer, HT_SP);	/* Find end of request name in answer.		*/
    if i = 0 then
      i = length (answer) + 1;
    operation = substr (answer, 1, i - 1);
				/* Request name is our operation.		*/
    if length (operation) > maxlength (defined_ops (1)) then
      do;
RESPONSE_UNKNOWN:
        call ioa_$nnl ("Response unknown:  ^a.  ", substr (answer, 1, i - 1));
ERROR:
        op = hbound (parse_operand, 1) + 1;
				/* Error op code.				*/
        return;
      end;
    else if length (operation) = 0 then
      go to ERROR;			/* Just reask question for blank lines.		*/
    do j = 1 to dimension (defined_ops, 1) while (operation ^= defined_ops (j));
    end;				/* See if operation defined.			*/
    if j > dimension (defined_ops, 1) then
      go to RESPONSE_UNKNOWN;		/* No?  Report the error.			*/


    op = op_code (j);
    if i >= length (answer) then	/* Remainder of answer is operands.		*/
      answer = "";
    else answer = ltrim (substr (answer, i), HT_SP);
				/* Trim leading SP HT from operands.		*/
    do while (length (answer) > 0);	/* Process operands.			*/
      i = search (answer, HT_SP);
      if i = 0 then
        i = length (answer) + 1;
      operand = substr (answer, 1, i - 1);
      go to parse_operand (op);

parse_operand (1):			/* yes					*/
parse_operand (2):			/* no					*/
parse_operand (3):			/* quit					*/
parse_operand (4):			/* top					*/
      go to NO_OPERANDS;

parse_operand (5):			/* rest					*/
parse_operand (6):			/* rest -scn				*/
parse_operand (7):			/* rest -aep				*/
parse_operand (8):                      /* rest -ep                                       */
      if operand = "-section" | operand = "-scn" then
        op = op_code(j) + 1;
      else if operand = "-all_entrypoints" | operand = "-aep" then
        op = op_code(j) + 2;
      else if operand = "-entrypoint" | operand = "-ep" then
        op = op_code(j) + 3;
      else go to BAD_OPERAND;
      go to NEXT_OPERAND;

parse_operand (9):			/* skip					*/
parse_operand (10):			/* skip -scn				*/
parse_operand (11):			/* skip -ep				*/
parse_operand (12):			/* skip -rest				*/
parse_operand (13):			/* skip -seen				*/
      if operand = "-section" | operand = "-scn" then
        op = op_code(j) + 1;
      else if operand = "-entry_point" | operand = "-ep" then
        op = op_code(j) + 2;
      else if operand = "-rest" | operand = "-r" then
        op = op_code(j) + 3;
      else if operand = "-seen" then
        op = op_code(j) + 4;
      else go to BAD_OPERAND;
      go to NEXT_OPERAND;

parse_operand (14):			/* title					*/
parse_operand (15):			/* title -top				*/
      if operand = "-top" | operand = "-t" then
        op = op_code(j) + 1;
      else go to BAD_OPERAND;
      go to NEXT_OPERAND;

parse_operand (16):			/* entry_point or ep			*/
      if k > 0 then
        do;
	call ioa_ ("Only one entry point name can be given in  ^a  response.", operation);
	go to ERROR;
        end;
      if length (operand) > maxlength (ep_name) then
        do;
	call ioa_ ("Entry point name  ^a  is too long.", operand);
	go to ERROR;
        end;
      ep_name = operand;
      k = 1;
      go to NEXT_OPERAND;

parse_operand (17):			/* section				*/
				/* section -ncs				*/
parse_operand (18):			/* section -cs				*/
parse_operand (19):			/* section -top				*/
				/* section -top -ncs                              */
parse_operand (20):                     /* section -top -cs                               */
      if operand = "-non_case_sensitive" | operand = "-ncs" then
        do;
          prev_operand = op - op_code(j);
	if prev_operand >= OPERAND_TOP then
	  op = op_code(j) + OPERAND_NCS + OPERAND_TOP;
	else
	  op = op_code(j) + OPERAND_NCS;
        end;
      else if operand = "-case_sensitive" | operand = "-cs" then
        do;
          prev_operand = op - op_code(j);
	if prev_operand >= OPERAND_TOP then
	  op = op_code(j) + OPERAND_CS + OPERAND_TOP;
	else
	  op = op_code(j) + OPERAND_CS;
        end;
      else if operand = "-top" | operand = "-t" then
        do;
          prev_operand = op - op_code(j);
	if mod(prev_operand,OPERAND_TOP) = OPERAND_CS then
	  op = op_code(j) + OPERAND_TOP + OPERAND_CS;
	else
	  op = op_code(j) + OPERAND_TOP + OPERAND_NCS;
        end;
      else
        do;
	if length (operand) > maxlength (scn.group (1).arg) then
	  do;
	    Lcount = length("Operand    of    response is too long.");
	    Snl1 = (Lcount + i + length (operation) > Loutput_line);
	    call ioa_$nnl ("Operand  ^a^[^/^]  of  ^a  response is too long.  ",
	         substr (answer, 1, i - 1), Snl1, operation);
	    go to ERROR;
	  end;
	if k = dimension (scn.group, 1) then
	  do;
	    call ioa_$nnl ("More than ^d substrings given with  ^a  response.  ",
	      dimension (scn.group, 1), operation);
	    go to ERROR;
	  end;
	k, scn.N = k + 1;
	scn.arg (k) = operand;
        end;
      go to NEXT_OPERAND;

parse_operand (21):			/* search					*/
				/* search -ncs				*/
parse_operand (22):			/* search -cs				*/
parse_operand (23):			/* search -top				*/
				/* search -top -ncs                               */
parse_operand (24):                     /* search -top -cs                                */
      if operand = "-non_case_sensitive" | operand = "-ncs" then
        do;
          prev_operand = op - op_code(j);
	if prev_operand >= OPERAND_TOP then
	  op = op_code(j) + OPERAND_NCS + OPERAND_TOP;
	else
	  op = op_code(j) + OPERAND_NCS;
        end;
      else if operand = "-case_sensitive" | operand = "-cs" then
        do;
          prev_operand = op - op_code(j);
	if prev_operand >= OPERAND_TOP then
	  op = op_code(j) + OPERAND_CS + OPERAND_TOP;
	else
	  op = op_code(j) + OPERAND_CS;
        end;
      else if operand = "-top" | operand = "-t" then
        do;
          prev_operand = op - op_code(j);
	if mod(prev_operand,OPERAND_TOP) = OPERAND_CS then
	  op = op_code(j) + OPERAND_TOP + OPERAND_CS;
	else
	  op = op_code(j) + OPERAND_TOP + OPERAND_NCS;
        end;
      else
        do;
	if length (operand) > maxlength (srh.group (1).arg) then
	  do;
	    Lcount = 38;		/* 38 = length("Operand    of    response is too long.");	*/
	    Snl1 = (Lcount + i + length (operation) > Loutput_line);
	    call ioa_$nnl ("Operand  ^a^[^/^]  of  ^a  response is too long.  ",
	         substr (answer, 1, i - 1), Snl1, operation);
	    go to ERROR;
	  end;
	if k = dimension (srh.group, 1) then
	  do;
	    call ioa_$nnl ("More than ^d substrings given with  ^a  response.  ", dimension (srh.group, 1), operation);
	    go to ERROR;
	  end;
	k, srh.N = k + 1;
	srh.arg (k) = operand;
        end;
      go to NEXT_OPERAND;

parse_operand (25):			/* brief					*/
      go to NO_OPERANDS;

parse_operand (26):			/* control_arg STRs				*/
    dcl CONTROL_ARG_OP init(26) fixed bin int static options(constant);
      if length (operand) > maxlength (ca.group (1).arg) then
        do;
	Lcount = 38;		/* 38 = length("Operand    of    response is too long.");	*/
	Snl1 = (Lcount + i + length (operation) > Loutput_line);
	call ioa_$nnl ("Operand  ^a^[^/^]  of  ^a  response is too long.  ", substr (answer, 1, i - 1), Snl1, operation);
	go to ERROR;
        end;
      if k = dimension (ca.group, 1) then
        do;
	call ioa_$nnl ("More than  ^d  substrings given with  ^a  response.  ", dimension (ca.group, 1), operation);
	go to ERROR;
        end;
      k, ca.N = k + 1;
      ca.arg (k) = operand;
      go to NEXT_OPERAND;

parse_operand (27):			/* . (= print "help")			*/
parse_operand (28):			/* ? (= list requests)			*/
parse_operand (29):			/* header					*/
parse_operand (30):			/* list_entry_points			*/
      go to NO_OPERANDS;

parse_operand (31):			/* list_requests				*/
parse_operand (32):                     /* help request				*/
      lr.N = 0;
      if length (operand) > maxlength (lr.ca (1)) then
        do;
	Lcount = 38;		/* 38 = length("Operand    of    response is too long.");	*/
	Snl1 = (Lcount + i + length (operation) > Loutput_line);
	call ioa_$nnl ("Operand  ^a^[^/^]  of  ^a  response is too long.  ", substr (answer, 1, i - 1), Snl1, operation);
	go to ERROR;
        end;
      if k = dimension (lr.ca, 1) then
        do;
	call ioa_$nnl ("More than  ^d  substrings given with  ^a  response.  ", dimension (lr.ca, 1), operation);
	go to ERROR;
        end;
      k, lr.N = k + 1;
      lr.ca (k) = operand;
      go to NEXT_OPERAND;

NO_OPERANDS:
      call ioa_$nnl ("^a  response does not allow operands.  ", operation);
      go to ERROR;

BAD_OPERAND:
      call ioa_$nnl ("Operand  ^a  invalid for  ^a  operation.  ", operand, operation);
      go to ERROR;

NEXT_OPERAND:
      if i >= length (answer) then
        answer = "";
      else answer = ltrim (substr (answer, i), HT_SP);
    end;				/* Strip leading HT SP from next operand.	*/

    if op = CONTROL_ARG_OP then	/* control_arg STRs				*/
      if ca.N = 0 then
        do;
	call ioa_$nnl ("Substrings must be given with the  ^a  response.  ", operation);
	op = hbound (parse_operand, 1) + 1;
        end;

  end parse_answer;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


parse_entry_point_into_units:
  procedure (linfo, Pcommon_units, Ncommon_units, PDlinfo_);
				/* This procedure parses an entry point (logical 	*/
				/*   info segment) into units (paragraphs).	*/

    dcl 1 linfo	   aligned like Deps.linfo,
        Pcommon_units  ptr,
        Ncommon_units  fixed bin,
        PDlinfo_	   ptr;		/* ptr to descriptors for this log info seg.	*/

    dcl 1 Dlinfo_	   aligned based (PDlinfo_),
	2 Nunits	   fixed bin,	/* number of units (pghs) in this log info seg.	*/
	2 Nsections  fixed bin,	/* number of units having section title.	*/
	2 unit	   (0 refer (Dlinfo_.Nunits)) like Dlinfo.unit;

    dcl 1 common_units (Ncommon_units) aligned based (Pcommon_units) like Dlinfo.unit;

    dcl (i, j)	   fixed bin (24),
        new_paragraph  bit (1) init ("0"b),
        save_length	   fixed bin (21);

    Dlinfo_.Nunits = 0;
    Dlinfo_.Icommon_unit = 0;
    Dlinfo_.Nsections = 0;
    list_of = FALSE;
    linfo.PDlinfo = PDlinfo_;
    Pline_text, Pline = linfo.Pstart;
    Lline_text = linfo.L;
    save_length = 0;
    Lline = 0;
    Lparg = 0;
    Number_lines = 0;
    j = 0;			/*init counter */
    Dlinfo_.Nunits = 0;

    call line$skip_blanks;

    if ^line$skip_blank () then
      do;
        call ioa_ ("Empty info segment: ^a^[>^]^a", Dinfo_seg_.dir, Dinfo_seg_.dir ^= ">", Dinfo_seg_.ent);
        Ninfos_printed = 1;		/* Do not want no match error displayed upon return to help_ */
        goto RETURN;
      end;

    call line$generated;		/* strip off "List generated line..."		*/

    Sfirst_pgh = TRUE;		/* do not want to increment line ptr lst time	*/

    new_paragraph = TRUE;

    do while (line$next ());
      if Sfirst_pgh then
        Sfirst_pgh = FALSE;
      if new_paragraph then
        do;
	j = j + 1;
	Dlinfo_.Nunits = Dlinfo_.Nunits + 1;
	Dlinfo_.unit (j).title = "";
	Dlinfo_.unit (j).Pstart = Pline;
	Dlinfo_.unit (j).S = FALSE;
	Dlinfo_.unit (j).Icommon_unit = 0;
	Number_lines = 1;
	Lparg = Lline;

	if line$contains (colon) then
	  current_line_begins_section = TRUE;
	else current_line_begins_section = FALSE;

	if current_line_begins_section then
	  do;
	    Dlinfo_.unit (j).title = line$title ();

	    list_of = FALSE;
	    if length (Dlinfo_.unit (j).title) >= 8 then
	      if substr (Dlinfo_.unit (j).title, 1, 8) = "List of " then
	        list_of = TRUE;

	    if length (Dlinfo_.unit (j).title) >= 6 then
	      if substr (Dlinfo_.unit (j).title, 1, 6) = "Syntax" then
	        Dlinfo_.unit (j).S.syntax_list = TRUE;

	    Dlinfo_.unit (j).S.list_of_list = list_of;
	    Dlinfo_.unit (j).S.arg_list = section$arg_list (Dlinfo_.unit (j).title);

	    Dlinfo_.unit (j).Pstart = Pline;
	    Dlinfo_.unit (j).S.scn = TRUE;
	    Dlinfo_.Nsections = Dlinfo_.Nsections + 1;
	  end;

	else if j > 1 then
	  do;			/* propagate arg_list findings to all paragraphs  */
				/* of section				*/
	    if Dlinfo_.unit (j - 1).S.arg_list then
	      Dlinfo_.unit (j).S.arg_list = TRUE;
	    Dlinfo_.unit (j).S.list_of_list = list_of;
	  end;
        end;			/*new paragraph*/

      new_paragraph = line$new_pgh ();
      if new_paragraph then
        do;
	Dlinfo_.unit (j).L = Lparg + length (NL);
	Dlinfo_.unit (j).Nlines = Number_lines;
	call line$skip_blank_lines;	/* strip off blank lines			*/
        end;
    end;				/*line next*/

    Dlinfo_.unit (j).L = Lparg + length (NL);

    Dlinfo_.unit (j).Nlines = Number_lines;

    if Ncommon_units > 0 then
      do;				/* Add common units onto end of entry point part.	*/
        i = Dlinfo_.Nunits + 1;
        Dlinfo_.Nunits = Dlinfo_.Nunits + Ncommon_units;
        addr (Dlinfo_.unit (i)) -> common_units = common_units;
      end;

                      
    do i = 1 to Dlinfo_.Nunits;          /* Compute line count of entry point part.	*/
       if ^Dlinfo_.unit(i).ep_list then  /* Do not add in ep list lines                   */
         linfo.Nlines = linfo.Nlines + Dlinfo_.unit(i).Nlines;
    end;
 
    if length (linfo.header) > 0 then
      linfo.Nlines = linfo.Nlines + 2;

  end parse_entry_point_into_units;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


parse_info_into_entry_points:
  procedure (Aptr, LAline, PDeps_);	/* Parse logical info into 1 or more entry points	*/

    dcl Aptr	   ptr,
        LAline	   fixed bin (21),
        PDeps_	   ptr;

    dcl Lline1	   fixed bin (21),
        code	   fixed bin (35),
        i		   fixed bin (21),
        (j, k)	   fixed bin;

    dcl line1	   char (Lline1) based (Pline);

    dcl 1 Deps_	   aligned based (PDeps_),
	2 Nlines	   fixed bin,
	2 N	   fixed bin,
	2 linfo	   (0:0 refer (Deps_.N)) like Deps.linfo;

    Pline_text = Aptr;
    Lline_text = LAline;
    Deps_.N = -1;			/* At least 1 entry point will be found.	*/
    Deps_.Nlines = 0;		/* No lines counted yet in logical info.	*/
				/* Search for 1st log info seg divider.		*/
    do while (^line$end_of_info ());	/* record info about log. info seg.		*/
      Pline = Pline_text;
      Deps_.N, j = Deps_.N + 1;
      Deps_.linfo (j).Nep_names = 0;
      if ^line$entry () & (j = 0) then
        do;			/* This info has no :Entry: lines.		*/
	if line$blank () then
	  do;			/* Strip off leading SP HT NL chars.		*/
	    Deps_.N = Deps_.N - 1;	/* Empty entry.				*/
	    go to END_ENTRIES;
	  end;
        end;

      else
        do;
	Lline1 = index (line, NL);
	if Lline1 = 0 then
	  do;			/* This is last entry point in the info.          */
	    Deps_.N = Deps_.N - 1;
	    if Deps_.N = 0 then
	      do;
	        if Deps_.linfo.header (Deps_.N) = "" then
		Deps_.linfo (Deps_.N).L = LAline;
	        else Deps_.linfo (Deps_.N).L = Deps_.linfo (Deps_.N).L - length (NL);
	      end;
	    else Deps_.linfo (Deps_.N).L = Deps_.linfo (Deps_.N).L - length (NL_NL);
				/* Do not include ending info NLs as part of      */
				/*   length of entry			*/
	    go to END_ENTRIES;
	  end;
	i = index (line1, ":");	/* look for : ending first entry point name.	*/
	do while (i > 0);		/* Sample line looks like:			*/
				/* :Entry: rs: rsnnl: 05/25/78 ioa_$rs, ioa_$rsnnl*/
	  k, Deps_.linfo (j).Nep_names = Deps_.linfo (j).Nep_names + 1;
	  if k <= dim (Deps_.linfo.ep_name, 2) then
	    Deps_.linfo (j).ep_name (k) = ltrim (rtrim (substr (line, 1, i), "	 :"), "	 ");
	  if Lline - i > 0 then
	    Pline = addr (line_arr (i + 1));
	  Lline = Lline - i;
	  Lline1 = Lline1 - i;
	  i = index (line1, ":");
	end;
	if (j > 0) & (Deps_.linfo (j).Nep_names = 0) then
	  do;
	    Deps_.N = Deps_.N - 1;	/* All but common info must have entry point	*/
	    go to NEXT_ENTRY;	/* names.  But look!			*/
	  end;			/* No names!  Can never read this info via help	*/
	if line$blank () then
	  do;			/* Strip off HT SP NL from start of info	*/
	    Deps_.N = Deps_.N - 1;
	    go to NEXT_ENTRY;
	  end;
        end;

      i = verify (line, HT_SP_NL_VT);	/* Skip leading white space 			*/
      Pline = addr (line_arr (i));
      Lline = Lline - i + 1;

      Deps_.linfo (j).Pstart = Pline;
      Deps_.linfo (j).L = Lline;
      Deps_.linfo (j).Nlines = 0;
      Deps_.linfo (j).S = FALSE;
      Lline1 = index (line, NL);	/* header is first line of log. info seg.	*/
      if Lline1 >= Lline then
        do;			/* header is only line of file.		*/
	Deps_.linfo (j).header = "";
	Deps_.linfo (j).date = 0;
        end;
      else if Lline1 + 1 <= Lline then
        if line_arr (Lline1 + 1) = NL then
	do;			/* header line must be followed by 1 blank line, at  least.	*/
	  Deps_.linfo (j).header = ltrim (substr (line, 1, Lline1 - 1));
				/* Remainder should be an entry point name.	*/
	  Deps_.linfo (j).Pstart = addr (line_arr (Lline1 + 1));
	  Deps_.linfo (j).L = Lline - length (Deps_.linfo (j).header);
				/* Remove header from logical info.		*/
	  i = search (substr (line, 1, Lline1), "	 ");
	  if i = 0 then
	    Deps_.linfo (j).date = 0;
	  else
	    do;
	      call convert_date_to_binary_ (substr (line, 1, i - 1), Deps_.linfo (j).date, code);
	      if code ^= 0 then	/* No date!				*/
	        Deps_.linfo (j).date = 0;
                else do;			   /* Replace stored date with iso_date */
	        Deps_.linfo (j).header = substr (Deps_.linfo (j).header, i+1);
	        Deps_.linfo (j).header = 
	          date_time_$format ("iso_date", Deps_.linfo (j).date, "", "") || "  " || 
		ltrim (Deps_.linfo (j).header);
	      end;
	    end;
	end;
        else
	do;
	  Deps_.linfo (j).header = "";
	  Deps_.linfo (j).date = 0;
	end;
      if index (line1, OLD_HELP_PGH_CHAR) > 0 then
				/* check old format info segs with \006 chars	*/
        Deps_.linfo (j).S.old_format = TRUE;
NEXT_ENTRY:
      i = index (line_text, "


:Entry:");
    end;


END_ENTRIES:
  end parse_info_into_entry_points;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*    F U N C T I O N S                                                      */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


ck_conditions:
  proc(i) returns (bit (1));

    dcl i		    fixed bin parm;

    if Dlinfo.unit (i).ep_list = TRUE & No_list_elements = 1 then 
                                        /*   Do aggregate an ep list if it only contains  */
                                        /*    one element                                 */
       return (FALSE);   

    if i <= Dlinfo.Nunits then	/*   When aggregating sections, include all	*/
      if ^Ssearch then		/*   section titles in the query.		*/
        if Sseen = seen_pgh (Dlinfo.unit (i)) then
	if Dlinfo.unit (i).Nlines < help_args.min_Lpgh then
	  if Dlinfo.unit (i).Nlines + 2 + Nlines <= help_args.max_Lpgh then
	    return (TRUE);

    return (FALSE);

  end ck_conditions;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

ck_more_conditions:
  proc(i) returns (bit (1));

    dcl i		    fixed bin parm;

    if i <= Dlinfo.Nunits then	/* Note that, here and above, if current pgh	*/
      if ^Dlinfo.unit (i).S.scn then	/* has already been seen, then can only aggregate	*/
        if ^Ssearch then		/* following pgh if it has been seen as well.	*/
	if Sseen = seen_pgh (Dlinfo.unit (i)) then
	  if Dlinfo.unit (i).Nlines < help_args.min_Lpgh then
	    if Dlinfo.unit (i).Nlines + 2 + Nlines <= help_args.max_Lpgh then
	      return (TRUE);

    return (FALSE);

  end ck_more_conditions;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


ct_pgh_lines:
  proc;

    Sseen = Deps.linfo (Iep).S.seen_by_user;
    Nlines = Dlinfo.unit (Iunit).Nlines;
    Nprint_units = 1;
    do while (Nlines_less_Lpgh ());	/* Iunit+Nprint_units<=Dlinfo.Nunits		*/
				/* Nlines < Lpgh				*/
      Nlines = Dlinfo.unit (Iunit + Nprint_units).Nlines + 2 + Nlines;
      Nprint_units = Nprint_units + 1;
    end;

  end ct_pgh_lines;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

Nlines_less_Lpgh:
  proc returns (bit (1));

    if Iunit + Nprint_units <= Dlinfo.Nunits then
      if Dlinfo.unit (Iunit + Nprint_units).Nlines < help_args.min_Lpgh then
        if Dlinfo.unit (Iunit + Nprint_units).Nlines + 2 + Nlines <= help_args.max_Lpgh then
	return (TRUE);

    return (FALSE);

  end Nlines_less_Lpgh;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

new_section_nscn:
  proc returns (bit (1));

    if new_section ^= "" then
      if ^Dlinfo.unit (Iunit).S.scn then
        return (TRUE);

    return (FALSE);

  end new_section_nscn;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

print_pgh_titles:
  proc returns (bit (1));
    if help_args.Sctl.title then
      do;				/* print pgh titles when -title is given only if	*/
				/* more than one title will be printed		*/
        if (Dlinfo.Nsections > 1) then
	return (TRUE);
        else if Dlinfo.Nsections = 1 then
	if ^Dlinfo.unit (1).S.scn then
	  return (TRUE);
      end;

    return (FALSE);

  end print_pgh_titles;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

prt_pgh_nnl:
  proc returns (bit (1));

    if ^help_args.Sctl.he_pn then
      if ^help_args.Sctl.he_info_name then
        if ^help_args.Sctl.he_counts then
	if length (Deps.linfo (Iep).header) = 0 then
	  return (TRUE);

    return (FALSE);

  end prt_pgh_nnl;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


    dcl Linfo_seg	   fixed bin (21),
        Pinfo_seg	   ptr;


info$init:
  proc (APseg, ALseg);

    dcl ALseg	   fixed bin (21),
        APseg	   ptr;

    Linfo_seg = ALseg;
    Pinfo_seg = APseg;
    call line$init (APseg, ALseg);

  end info$init;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

initialize_switches:
  proc;

    Sdescription_present = FALSE;
    Sep_list_printed = FALSE;
    Sfirst_time = FALSE;
    Sfirst_pgh = FALSE;
    Sremove_line = FALSE;
    Syntax_section = FALSE;
    Sprt_args = FALSE;
    Sprt_bf_heading = FALSE;
    Sprt_list_of = FALSE;
    Sprt_entry_pts = FALSE;
    Sprt_one_paragraph = FALSE;
    Scase_sensitive = FALSE;

  end initialize_switches;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

line$args:
  proc;

    dcl Iline	   fixed bin (24),
        continue_line  bit (1) init ("0"b);

    if line ^= "," & substr (reverse (line), 1) = "," | (index (HT_SP, line_text_arr (1)) = 0 & index (NL, line_text_arr (1)) = 0)
         then			/* When line=comma - comma is being used as an arg*/
      continue_line = TRUE;
    else
      do;
        if list_of then		/*List of items*/
	return;
        Iline = index (line, SP_SP);
        if Iline = 0 then
	Iline = index (line, HT);
        if Iline ^= 0 then
	Lline = Iline - 1;
        return;
      end;

    if continue_line then
      do;				/*Determine if there are any consecutive arg*/
				/*lines other than the 1st set that do not  */
				/*end in a comma.                           */
        if Sfirst_time & substr (reverse (line), 1) ^= "," then
	Sremove_line = TRUE;
        else if Sremove_line & substr (reverse (line), 1) ^= "," then
	Sremove_line = FALSE;
      end;

    do while (continue_line & Lline_text > 0);
				/*Control arg continued on next line*/
      Sconsecutive_arg_lines = TRUE;
      Iline = index (line_text, NL);
      if Iline > 0 then
        do;
	if Lline_text - Iline > 0 then
	  Pline_text = addr (line_text_arr (Iline + 1));
	Lline_text = Lline_text - Iline;
	Lline = Lline + Iline;
        end;
      else
        do;
	Lline = Lline + Lline_text;
	Lline_text = 0;
	continue_line = FALSE;
        end;
      if substr (reverse (line), 1, 1) = "," | index (HT_SP, line_text_arr (1)) = 0 then
        ;
      else
        do;
	if Sremove_line & substr (line_text, 1, 3) = SP_SP_SP then
	  Sdescription_present = TRUE;
	else Sdescription_present = FALSE;
	continue_line = FALSE;
        end;
    end;

    return;

  end line$args;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

line$blank:
  proc returns (bit (1));
    dcl Iline	   fixed bin (24);


    Iline = verify (line, HT_SP_NL);
    if Iline = 0 then
      return (TRUE);
    if Iline > 1 then
      do;
        Pline = addr (line_arr (Iline));
        Lline = Lline - (Iline - 1);
      end;
    return (FALSE);

  end line$blank;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

line$contains:
  proc (t1) returns (bit (1));

    dcl Iline	   fixed bin (24),
        t1	   char (*);

    Iline = index (line, t1);
    if Iline = 0 then
      return (FALSE);
    return (TRUE);

  end line$contains;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

line$desc:
  proc returns (bit (1));

    dcl Iline	   fixed bin (24);

    if Lline_text ^> 0 then
      return (FALSE);

    Iline = index (line_text, NL);	/*Find length of current line*/
    Pline = Pline_text;

    if Iline = 0 then
      do;
        Lline = Lline_text;
        Lline_text = 0;
        return (TRUE);
      end;

    if index (HT_SP, line_text_arr (1)) = 0 & index (NL, line_text_arr (1)) = 0 then
      return (FALSE);

    if Iline + 2 <= Lline_text then	/* check for end of pgh			*/
      if index (line_text_arr (Iline + 1), NL) > 0 & index (line_text_arr (Iline + 2), NL) > 0 then
        do;
	Lline = Iline - 1;
	Lline_text = 0;
	return (TRUE);
        end;


    Lline = Iline - 1;
    if Lline_text - Iline > 0 then
      Pline_text = addr (line_text_arr (Iline + 1));
				/* Find start point of next line		*/
    Lline_text = Lline_text - Iline;
    return (TRUE);

  end line$desc;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


line$end_of_info:
  proc returns (bit (1));

    if length (line_text) + length (line) = 0 then
      return (TRUE);
    else return (FALSE);

  end line$end_of_info;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

line$entry:
  proc returns (bit (1));

    dcl Iline	   fixed bin (24);



    Iline = index (line_text, "


:Entry:");
    if Iline = 0 then
      do;
        Lline = Lline_text;
        Lline_text = 0;
        return (FALSE);
      end;
    else
      do;
        Lline = Iline - 1;
        if Lline_text - (Iline + 9) > 0 then
	Pline_text = addr (line_text_arr (Iline + 10));
        Lline_text = Lline_text - (Iline + 9);
        return (TRUE);
      end;

  end line$entry;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

line$HT_SP:
  proc returns (bit (1));

    dcl Iline	   fixed bin (24);

    Iline = index (HT_SP, line_arr (1));
    if Iline > 0 then
      return (TRUE);
    return (FALSE);

  end line$HT_SP;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

line$generated:
  proc;

    dcl Ibreak	   fixed bin (21),
        Inonwhite	   fixed bin (21),
        Iskip	   fixed bin (21),
        Lword_text	   fixed bin (21),
        Pword_text	   ptr;

    dcl word_text	   char (Lword_text) based (Pword_text),
        word_text_arr  (Lword_text) char (1) based (Pword_text),
        word	   (7) char (80) var,
        Nwords	   fixed bin;

    dcl WORD_BREAKS	   char (4) int static options (constant) init ("	 ()");
				/* HT SP ( and )				*/

    dcl Ptext	   ptr,		/* save ptr to where text starts so can adjust Pline_text*/
        Ltext	   fixed bin;

    Pword_text = Pline_text;
    Lword_text = Lline_text;

    do while (Lword_text > 0 & index (line_text, NL) = 1);
				/* skip any blank lines before text		*/
      if Lword_text - 1 > 0 then
        Pword_text = addr (word_text_arr (2));
      Lword_text = Lword_text - 1;
    end;

    Ptext = Pword_text;
    Ltext = Lword_text;

    Lword_text = index (line_text, NL);
    if Lword_text = 0 then
      Lword_text = length (line_text);
    Nwords = 0;
    word (*) = "";

    Inonwhite = verify (word_text, HT_SP);
				/* skip over white space			*/
    if Inonwhite = 0 then
      Lword_text = 0;
    else if Inonwhite > 1 then
      do;
        Pword_text = addr (word_text_arr (Inonwhite));
        Lword_text = length (word_text) - (Inonwhite - 1);
      end;

    do while (Lword_text > 0 & Nwords < dim (word, 1));
      Ibreak = search (word_text, WORD_BREAKS);
      if Ibreak = 0 then
        Ibreak = length (word_text) + 1;
      if Ibreak > 1 then
        do;
	Nwords = Nwords + 1;
	if Nwords <= dimension (word, 1) then
	  word (Nwords) = substr (word_text, 1, Ibreak - 1);
	if Lword_text - (Ibreak - 1) > 0 then
	  Pword_text = addr (word_text_arr (Ibreak));
	Lword_text = length (word_text) - (Ibreak - 1);
        end;
      Iskip = verify (word_text, WORD_BREAKS);
				/* skip over all consecutive breaks chars	*/
      if Iskip > 0 then
        do;
	Pword_text = addr (word_text_arr (Iskip));
	Lword_text = length (word_text) - (Iskip - 1);
        end;
      else Lword_text = 0;		/* nothing but break characters remain		*/
    end;

    if word (1) = "List" & word (2) = "is" & word (3) = "generated" & word (4) = "by" & word (5) = "the" & word (6) = "help"
         & word (7) = "command" then
      do;
        Pline_text = Ptext;
        Lline_text = Ltext;
        i = index (line_text, NL);
        if i = 0 then
	Lline_text = 0;
        else
	do;
	  if Lline_text - i > 0 then
	    Pline_text = addr (line_text_arr (i + 1));
	  Lline_text = Lline_text - i;
	end;
      end;

    return;

  end line$generated;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

line$init:
  proc (APseg, ALseg);

    dcl ALseg	   fixed bin (21),
        APseg	   ptr;

    Lline_text = ALseg;
    Pline_text = APseg;
    Number_lines = 0;
    call section$assert_line_begins_a_section (FALSE);

  end line$init;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

line$list_items:
  proc returns (bit (1));
    dcl Iline	   fixed bin (24);


    Iline = index (line_text, NL);
    if Iline = 1 then		/* blank line				*/
      return (TRUE);

    if Iline > 1 then
      if substr (line_text, 1, Iline - 1) = SP then
        return (TRUE);

    if length (line_text) >= 3 then	/* no description				*/
      if substr (line_text, 1, 3) ^= SP_SP_SP then
        return (TRUE);

    return (FALSE);

  end line$list_items;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

line$new_pgh:
  proc returns (bit (1));

    dcl Iline	   fixed bin (24);


    if length (line_text) = 0 then	/* on last line				*/
      return (FALSE);

    Iline = index (line_text, NL_NL);	/* looking for NL_NL for total of NL_NL_NL which  */
				/* indicates new pgh			*/
    if Iline = 1 then
      do;				/* found NL_NL_NL				*/

        if Lline_text - 2 > 0 then
	Pline_text = addr (line_text_arr (Iline + 2));
        Lline_text = (length (line_text) - 2);
        return (TRUE);
      end;
    return (FALSE);

  end line$new_pgh;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

line$next:
  proc returns (bit (1));

    dcl Iline	   fixed bin (24);

    if Sfirst_pgh then		/* do not increment line 1st time through	*/
				/* for procedure parse_entry_point_into_units	*/
      return (TRUE);

    if length (line_text) = 0 | verify (line_text, NL) = 0 then
      return (FALSE);

    Iline = index (line_text, NL);
    if Iline = 0 then
      do;
        Pline = addr (line_text);
        Lline, Iline = length (line_text);
        Lline_text = 0;
      end;
    else
      do;
        Pline = addr (line_text);
        Lline = Iline - 1;
        if Lline_text - Iline > 0 then
	Pline_text = addr (line_text_arr (Iline + 1));
        Lline_text = Lline_text - Iline;
      end;
    Number_lines = Number_lines + 1;
    Lparg = Lparg + Iline;
    return (TRUE);

  end line$next;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

line$skip_blank:
  proc returns (bit (1));

    do while (line = "");
      if ^line$next () then
        return (FALSE);
    end;
    return (TRUE);

  end line$skip_blank;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


line$skip_blank_lines:
  proc;

    dcl blk_line	   char (Lblk_line) based (Pblk_line),
        Pblk_line	   ptr,
        Lblk_line	   fixed bin,
        Sblk_line	   bit;

    Sblk_line = TRUE;

    do while (Sblk_line & Lline_text > 0);
      Pblk_line = Pline_text;
      Lblk_line = index (line_text, NL);
      if Lblk_line = 0 then
        do;
	Lblk_line = Lline_text;
	Lline_text = 0;
        end;
      if blk_line = "" then
        do;
	if Lline_text - Lblk_line > 0 then
	  Pline_text = addr (line_text_arr (Lblk_line + 1));
	Lline_text = Lline_text - Lblk_line;
        end;
      else Sblk_line = FALSE;
    end;

    return;

  end line$skip_blank_lines;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/


line$skip_blanks:
  proc;

    dcl Iline	   fixed bin (24);

    Iline = verify (line_text, "  ");
    if Iline = 0 then
      return;
    do while (Iline > 0);
      if line_text_arr (Iline) = NL then
        do;
	if Lline_text - Iline > 0 then
	  Pline_text = addr (line_text_arr (Iline + 1));
	Lline_text = Lline_text - Iline;
	Iline = verify (line_text, "  ");
        end;
      else Iline = 0;
    end;

    return;

  end line$skip_blanks;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

line$title:
  proc returns (char (200) varying);

    dcl Iline	   fixed bin (24),
        text	   char (200) varying;

    Iline = index (reverse (line), ":");/* need everything prior to last colon on line	*/
    if Iline = 0 then
      text = "";
    else
      do;
        Iline = Lline - (Iline - 1);	/* get char index of last colon in line		*/
        Lparg = Lparg - Iline;
        text = ltrim (substr (line, 1, Iline - 1));
				/* dont include colon			*/

        if Lline - Iline > 0 then
	do;
	  Pline = addr (line_arr (Iline + 1));
	  Lline = Lline - Iline;
	end;
        else
	do;
	  Pline = addcharno (addr (line_arr (Iline)), 1);
	  Lline = 0;
	end;
      end;
    return (text);


  end line$title;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

section$arg_list:
  proc (name) returns (bit (1));

    dcl name	   char (*) varying;

    if length (name) >= 16 then	/* Is section an arg_list section?*/
      if substr (name, 1, 16) = "Control argument" | substr (name, 1, 16) = "Control Argument" | 
         substr (name, 1, 8) = "Argument" | substr (name, 1, 8) = "List of " then
        return (TRUE);
      else ;
    else if length (name) >= 8 then
      if substr (name, 1, 8) = "Argument" | substr (name, 1, 8) = "List of " then
        return (TRUE);

    return (FALSE);

  end section$arg_list;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

    dcl current_line_begins_section
		   bit (1);

section$assert_line_begins_a_section:
  proc (setting);

    dcl setting	   bit (1) aligned;

    current_line_begins_section = setting;

  end section$assert_line_begins_a_section;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

print_header:
  proc ();			/* This procedure prints a regular heading line.	*/

    dcl Lcount	   fixed bin,
        Linfo_name	   fixed bin,
        Lpath	   fixed bin;
    dcl case	   fixed bin;
    dcl line	   char (256) varying;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* Output heading line before other info.  The heading spans at least 2 lines, and has 	*/
/* the form:								*/
/*	pathname   (line counts)						*/
/*	info_name:  info_title						*/
/*									*/
/* where all parts but the info_title are optional.				*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

    if help_args.Sctl.he_counts then
      do;				/* Do following only if line/entry counts wanted.	*/
        if Deps.N = 0 then		/*   No subroutine entry points.		*/
	if Nlines >= Deps.linfo (0).Nlines then
				/*     Only 1 paragraph.			*/
	  case = 1;
	else case = 2;		/*     Multiple paragraphs.			*/
        else
	do;			/*   Subroutine entry points.			*/
	  if Iep = 0 then		/*     Subroutine introduction.		*/
	    if Nlines >= Deps.linfo (0).Nlines then
	      case = 3;		/*       Only 1 paragraph.			*/
	    else case = 4;		/*       Multiple paragraphs.			*/
	  else			/*     A subroutine entry point.		*/
	       if Deps.N = 1 then	/*       Only 1 entry point.			*/
	    if Nlines >= Deps.linfo (Iep).Nlines then
	      case = 5;		/* 	 Only 1 paragraph.			*/
	    else case = 6;		/*	 Multiple paragraphs.		*/
	  else			/*       Multiple entry points.		*/
	       if Nlines >= Deps.linfo (Iep).Nlines then
	    case = 7;		/*	 Only 1 paragraph.			*/
	  else case = 8;		/*	 Multiple paragraphs.		*/
	end;
        go to FORM (case);

FORM (1):
        call ioa_$rsnnl ("^d line^[s^] in info", line, 0, Nlines, (Nlines > 1));
        if Nlines <= 0 then
	Nlines = 1;

        go to END_FORM;

FORM (2):
        call ioa_$rsnnl ("^d ^[lines follow^;line follows^];  ^d in info", line, 0, Nlines, (Nlines > 1),
	   Deps.linfo (Iep).Nlines);
        go to END_FORM;

FORM (3):
        call ioa_$rsnnl ("^d line^[s^] in introduction;  ^d lines, ^d entry point^[s^] in info",
           line, 0, Nlines, (Nlines > 1), Deps.Nlines, Deps.N, (Deps.N > 1));
        go to END_FORM;

FORM (4):
        call ioa_$rsnnl ("^d ^[lines follow^;line follows^], ^d in introduction;  ^d lines, ^d entry point^[s^] in info",
	   line, 0, Nlines, (Nlines > 1), Deps.linfo (Iep).Nlines, Deps.Nlines, Deps.N, (Deps.N > 1));
        go to END_FORM;

FORM (5):
        call ioa_$rsnnl ("^d line^[s^] in entry point", line, 0, Nlines, (Nlines > 1));
        go to END_FORM;

FORM (6):
        call ioa_$rsnnl ("^d ^[lines follow^;line follows^], ^d in entry point", line, 0, Nlines, (Nlines > 1),
	   Deps.linfo (Iep).Nlines);
        go to END_FORM;

FORM (7):
        call ioa_$rsnnl ("^d line^[s^] in entry point;  ^d lines, ^d other entry point^[s^] in info", line, 0, Nlines,
	   (Nlines > 1), Deps.Nlines, (Deps.N - 1), (Deps.N - 1 > 1));
        go to END_FORM;

FORM (8):
        call ioa_$rsnnl ("^d ^[lines follow^;line follows^], ^d in entry point;  ^d lines, ^d other entry point^[s^] in info",
	   line, 0, Nlines, (Nlines > 1), Deps.linfo (Iep).Nlines, Deps.Nlines, (Deps.N - 1), (Deps.N - 1 > 1));

END_FORM:
        Lcount = length (line);
      end;
    else Lcount = 0;

    if help_args.Sctl.he_pn then
      do;				/* Compute length of pathname for heading.	*/
        Lpath = length (rtrim (Dinfo_seg_.dir)) + length (rtrim (Dinfo_seg_.ent)) + length ("   ");
        if Dinfo_seg_.dir ^= ">" then
	Lpath = Lpath + 1;
      end;
    else Lpath = 0;

    if help_args.Sctl.he_info_name then
      do;				/* If info_name to be output, compute its length	*/
        Linfo_name = length (rtrim (Dinfo_seg_.info_name));
        if Linfo_name > 0 then	/* + colon + 2 spaces.			*/
	Linfo_name = Linfo_name + length (":  ");
      end;
    else Linfo_name = 0;

    if Lpath > 0 & Lcount > 0 then
      if Lpath + Lcount <= Loutput_line then
        ISnl3 = 2;
      else ISnl3 = 1;
    else ISnl3 = 3;

    if Lpath + Lcount > 0 then
      Snl1 = TRUE;
    else Snl1 = FALSE;

    if Linfo_name + length (Deps.linfo (Iep).header) >= 0 then
      Snl2 = TRUE;
    else Snl2 = FALSE;

    call ioa_$nnl ("^[^v/^;^s^]^[^a^[>^]^a^;^3s^]^[^/^;   ^;^]^[(^a)^;^s^]^[^/^]^[^a:  ^;^s^]^[^a^]^[^/^]",
         (Ninfos_printed > 1),	/* For all but the first info printed,		*/
         help_args.Lspace_between_infos,/*   output spaces between infos.		*/
         help_args.Sctl.he_pn,	/* Put pathname into heading.			*/
         Dinfo_seg_.dir, (Dinfo_seg_.dir ^= ">"), Dinfo_seg_.ent, ISnl3, help_args.Sctl.he_counts,
				/* Put line/entry point count into heading.	*/
         line,			/*   Description formulated above.		*/
         Snl1, (Linfo_name > 0),	/*Put info_name into heading.			*/
         Dinfo_seg_.info_name, (^Sprt_entry_pts), Deps.linfo (Iep).header,
				/* Heading line of info or entry point.		*/
         Snl2);

    return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


print_header_only:
  entry;				/* Print header for an info.			*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/*									*/
/* Output a special-format info heading line when only heading lines are being output.	*/
/* The idea is for the headings to occupy as few lines as possible.			*/
/*									*/
/* The heading line has the form:						*/
/*	pathname   info_name:  info_title   (line counts)				*/
/*									*/
/* where all fields but info_title are optional.					*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

    if help_args.Sctl.he_pn then
      do;
        Lpath = length (rtrim (Dinfo_seg_.dir)) + length (rtrim (Dinfo_seg_.ent)) + length ("   ");
        if Dinfo_seg_.dir ^= ">" then
	Lpath = Lpath + 1;
      end;			/* If pathname to be output, compute length of	*/
    else Lpath = 0;			/* path + 3 spaces.				*/

    if help_args.Sctl.he_info_name then
      do;				/* If info_name to be output, compute length of	*/
        Linfo_name = length (rtrim (Dinfo_seg_.info_name));
        if Linfo_name > 0 then	/* info_name + colon + 2 spaces.		*/
	Linfo_name = Linfo_name + length (":  ");
      end;
    else Linfo_name = 0;

    if help_args.Sctl.he_counts then
      do;				/* If line/entry point counts to be output,	*/
        if Dinfo_seg_.Scross_ref then	/* compute length of appropriate format + 3 spaces*/
	Lcount = length ("   (another version)");
        else if Deps.N = 0 then
	Lcount = length ("   (9999 lines in info)");
        else if Iep = 0 then
	Lcount = length ("   (9999 lines, 999 entries in info)");
        else Lcount = length ("   (9999 lines, 999 other entries in info)");
      end;
    else Lcount = 0;

    if Lpath + Linfo_name + length (Deps.linfo (Iep).header) + Lcount <= Loutput_line then
      do;
        Snl1 = FALSE;		/* Compute if heading must be broken into several	*/
        Snl2 = FALSE;		/* lines.  Break points are after pathname and	*/
      end;			/* before line/entry counts.			*/
    else if Lpath + Linfo_name + length (Deps.linfo (Iep).header) <= Loutput_line then
      do;
        Snl1 = FALSE;
        Snl2 = TRUE;
      end;
    else if Linfo_name + length (Deps.linfo (Iep).header) + Lcount <= Loutput_line then
      do;
        Snl1 = TRUE;
        Snl2 = FALSE;
      end;
    else
      do;
        Snl1 = (Lpath > 0);
        Snl2 = (Lcount > 0);
      end;

    call ioa_ ("^[^a^[>^]^a^;^3s^]^[^/^]   ^[^a:  ^;^s^]^a^[
^]^[   ^[(another version)^;(^d line^[s^]^[, ^[^d^s^;^s^d other^] ^[entries^;entry^]^;^4s^] in info)^]^]",
				/* Output long heading line.			*/
         help_args.Sctl.he_pn, Dinfo_seg_.dir, Dinfo_seg_.dir ^= ">", Dinfo_seg_.ent, Snl1, 
         Linfo_name > 0, Dinfo_seg_.info_name,
         Deps.linfo (Iep).header,	/* Output the  entry point heading.		*/
         Snl2, help_args.Sctl.he_counts, Dinfo_seg_.Scross_ref,
				/* Second occurence of info in another dir.	*/
         Deps.Nlines, (Deps.Nlines > 1),/* Output line count for all entry points.	*/
         ((Deps.N > 0) & (Iep = 0)) | (Deps.N > 1),
				/* Output count of entry points.		*/
         (Iep = 0),			/*   Looking at common part.  Output info about	*/
				/*   all entry points.			*/
         Deps.N, Deps.N - 1,		/*   Looking at entry point.  Output info about	*/
				/*   other entry points.			*/
         ((Iep = 0) & (Deps.N > 1)) | (Deps.N - 1 > 1));

  end print_header;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


print_pgh_2nl:
  procedure (unit, Sprint_inhibit);	/* This procedure prints a paragraph.		*/

    dcl 1 unit	   aligned like Dlinfo.unit,
        Sprint_inhibit bit (1) aligned;

    dcl code	   fixed bin (35);


    dcl 1 event_info   aligned,
	2 ev_chan	   fixed bin (71),
	2 message	   fixed bin (71),
	2 sender	   bit (36),
	2 origin,
	  3 dev_signal
		   bit (18) unal,
	  3 ring	   bit (18) unal,
	2 chan_index fixed bin;

    dcl 1 wait_list	   aligned int static,
	2 N	   fixed bin,
	2 ev_chan	   (1) fixed bin (71);

    dcl 1 write_status aligned int static,
	2 ev_chan	   fixed bin (71) init (0),
	2 output_pending
		   bit (1);

    if Sprint_inhibit then
      return;
    call ioa_ ("^/");
    go to PRINT_PGH;


print_pgh:
  entry (unit, Sprint_inhibit);

    if Sprint_inhibit then
      return;
    call ioa_ ("");


print_pgh_nnl:
  entry (unit, Sprint_inhibit);

    if Sprint_inhibit then
      return;
PRINT_PGH:
    if unit.ep_list then
      if Sep_list_printed then
        return;
      else Sep_list_printed = TRUE;

    if unit.S.scn then		/* Print section title, if any.		*/
      call ioa_$nnl ("^a:", unit.title);
    call iox_$put_chars (iox_$user_output, unit.Pstart, unit.L, code);
    call iox_$control (iox_$user_output, "write_status", addr (write_status), code);
    if (code = 0) & (write_status.output_pending) then
      do;				/* Wait until output on user's terminal before	*/
        wait_list.N = 1;		/* marking pgh seen.			*/
        wait_list.ev_chan (1) = write_status.ev_chan;
        call ipc_$block (addr (wait_list), addr (event_info), code);
      end;
    unit.S.seen_by_user = TRUE;	/* Keep track of what we've seen.		*/
    if unit.Icommon_unit > 0 then
      common_units (unit.Icommon_unit).S.seen_by_user = TRUE;

  end print_pgh_2nl;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


seen_pgh:
  proc (unit) returns (bit (1) aligned);/* Returns TRUE if pgh has been seen by user.	*/

    dcl 1 unit	   aligned like Dlinfo.unit,
        Sseen	   bit (1) aligned;

    if unit.Icommon_unit > 0 then
      Sseen = common_units (unit.Icommon_unit).S.seen_by_user;
    else Sseen = unit.S.seen_by_user;
    return (Sseen);

  end seen_pgh;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */


set_space_used:
  procedure (Pcurrent_space, size_current_space) returns (ptr);
				/* This procedure returns pointer to next free	*/
				/* word of storage in help_args temp segment.	*/
    dcl Pcurrent_space ptr,		/* ptr to last space allocated in the seg.	*/
        size_current_space
		   fixed bin (21),	/* amount of space used in structure last alloc.	*/
        Pnext_space	   ptr;		/* ptr to next free space.			*/

    Pnext_space = addrel (Pcurrent_space, size_current_space + mod (size_current_space, 2));
    return (Pnext_space);

  end set_space_used;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

%include old_help_args_;

%include old_help_cis_args_;

    dcl 1 Dinfo_seg_   aligned like Dinfo_seg based (PDinfo_seg_);

  end old_help_rql_;
