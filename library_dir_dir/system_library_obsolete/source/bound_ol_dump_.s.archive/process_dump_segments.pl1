/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(2016-02-24,Swenson), approve(2016-02-24,MCR10009),
     audit(2016-04-10,GDixon), install(2016-04-10,MR12.6e-0005):
     Fix references to (en de)code_clock_value_ to use 4-character time zone.
                                                   END HISTORY COMMENTS */

/* format: style4,delnl,insnl,ifthenstmt,indnoniterend */
process_dump_segments:
     proc (dump_ptrs, slt_ptr, definitions_ptr, nametbl_ptr, num_events, delta_time, long_report);



/* Routine to scan an FDUMP for interesting time-stamped events,
   sort these events by time (reverse order), and print them.

   The following events are considered as interesting:

   Machine Conditions (from BOS, prds, pds, mc_trace_buf)

   Traffic Control State Change Time

   Syserr Messages (from both syserr_data and syserr_log)

   Fim Frames in any stack

   Connects by device

   Disk queues (long report only)

   An array of pointers to FDUMP is passed as a parameter--this array
   is in order by FDUMP component (0, 1, 2, ...).  Also passed
   are pointers to copies of certain segments from the FDUMP (these
   are not within the FDUMP itself, but copied from it.

   Written March 1981 by J. Bongiovanni
   Modified April 1981 by Rich Coppola to add expanded path name/rel offset
   Modified July 1981 by J. Bongiovanni to add connects by device
   Modified January 1982 by J. Bongiovanni to add disk queues, mc_trace_buf
   Modified May 1982 by Rich Coppola for new ASTE
   Modified July 1982 by J. Bongiovanni for new time format in disk Q
   Modified May 1984 by T. Oke for new free disk queue.
   Modified May 1984 by T. Oke for adaptive optimization mods to disk queue.
*/


/* Parameter */

dcl  dump_ptrs (*) ptr;				/* pointers to FDUMP components		*/
dcl  slt_ptr ptr;					/*  copy of SLT from FDUMP			*/
dcl  definitions_ptr ptr;				/* copy of definitions from FDUMP		*/
dcl  nametbl_ptr ptr;				/* copy of Name Table from FDUMP		*/
dcl  num_events fixed bin;				/* number of events to print			*/
dcl  delta_time fixed bin (71);			/* interval of interest in microseconds		*/
dcl  long_report bit (1);				/* ON=>long report format, OFF=>1 line/event	*/





/* Automatic */

dcl  apt_array_p ptr;
dcl  apt_inx fixed bin;
dcl  apt_proc_found bit (1);
dcl  bmp ptr init (null);
dcl  bound_interceptors_ptr ptr;
dcl  code fixed bin (35);
dcl  cur_date_time char (17);
dcl  diskq_datap ptr;
dcl  dom fixed bin;
dcl  DOM pic "99";
dcl  dow fixed bin;
dcl  dump_seginx fixed bin;
dcl  dump_segno fixed bin;
dcl  earliest_recorded_time fixed bin (71);
dcl  earliest_time fixed bin (71);
dcl  event_inx fixed bin;
dcl  eventsp ptr;
dcl  first_print bit (1);
dcl  hr fixed bin;
dcl  HR pic "z9";
dcl  1 interesting_segs (N_INTERESTING_SEGS) aligned,
       2 segname char (32) unal
	  init ("prds", "pds", "tc_data", "syserr_data", "scs", "inzr_stk0", "iom_data", "disk_seg", "pvt", ""),
       2 segno fixed bin (18) init ((N_INTERESTING_SEGS) - 1),
       2 handler entry (ptr, bit (1) aligned) variable
	  init (process_prds, process_pds, process_tc_data, process_syserr_data, setup_from_scs, process_inzr_stk0,
	  process_iom_data, process_disk_queue, copy_pvt, process_mc_trace_buf),
       2 process_this_seg bit (1) init ((N_INTERESTING_SEGS) (1)"1"b);
dcl  last_date_time char (17);
dcl  last_sec fixed bin;
dcl  last_segno fixed bin;
dcl  micsec fixed bin (71);
dcl  MICSEC pic "999999";
dcl  minute fixed bin;
dcl  MIN pic "99";
dcl  mon fixed bin;
dcl  MON pic "99";
dcl  max_events fixed bin;
dcl  prds_processor bit (8) unal;
dcl  proc_no fixed bin;
dcl  process_number fixed bin;
dcl  sec fixed bin;
dcl  SEC pic "99";
dcl  seg_found bit (1);
dcl  seginx fixed bin;
dcl  segp ptr;
dcl  sortp ptr;
dcl  sortinx fixed bin;
dcl  sortinx1 fixed bin;
dcl  sortinxt fixed bin;
dcl  stack_found bit (1);
dcl  stack_inx fixed bin;
dcl  stack_segs (0:7) fixed bin;
dcl  temp_alloc_p ptr;
dcl  temp_seg_data_p ptr init (null ());
dcl  tsegp ptr;
dcl  words_copied fixed bin (18);
dcl  yr fixed bin;
dcl  YR pic "99";


/* Static */

dcl  CPU_TAG char (8) init ("abcdefgh") int static options (constant);
dcl  IOM_TAG char (4) init ("ABCD") int static options (constant);
dcl  MYNAME char (21) init ("process_dump_segments") int static options (constant);
dcl  N_INTERESTING_SEGS fixed bin init (10) int static options (constant);
dcl  MC_TRACE_BUF fixed bin init (10) int static options (constant);
						/* Index of mc_trace_buf */
dcl  Q_TIME_MOD fixed bin (71) init (1000000000000000000000000000000000000b) int static options (constant);


/* Based */

dcl  1 temp_seg_data aligned based (temp_seg_data_p),	/* info on temp segs allocated 		*/
       2 n_temp_segs fixed bin,			/* number temp segs allocated this way		*/
       2 temp_segp (0 refer (n_temp_segs)) ptr;		/* array of pointers to allocated temp segs	*/

dcl  1 time_stamped_events aligned based (eventsp),	/* events of interest from FDUMP		*/
       2 n_events fixed bin,				/* number of events found			*/
       2 events (0 refer (n_events)),
         3 time_stamp fixed bin (71),			/* time of event				*/
         3 delete_on_duplicate_time bit (1),		/* ON => delete this event if time the same as another */
         3 deleted bit (1),				/* ON => this event deleted */
         3 event_struct_ptr ptr,			/* structure of interest to event		*/
         3 event_display entry (char (*), ptr, fixed bin) variable,
						/* routine to print event	*/
         3 process_number fixed bin,			/* process number in FDUMP			*/
         3 apte_offset bit (18),			/* APTE offset or "0"b */
         3 added_info char (40) unal;			/* other data to be printed			*/

dcl  1 apt_array aligned based (apt_array_p),		/* used to translate apte offset to proc number */
       2 n_aptes fixed bin,
       2 apt_desc (0 refer (n_aptes)) aligned,
         3 offset bit (18) unal,			/* offset of apte in tc_data			*/
         3 procn fixed bin (17) unal;			/* process number in FDUMP			*/



dcl  1 diskq_data aligned based (diskq_datap),		/* extract of disk queue/devtab info */
       2 pvtx fixed bin,
       2 sect_sw bit (1),
       2 write_sw bit (1),
       2 coreadd fixed bin (25),
       2 sector fixed bin,
       2 cylinder fixed bin;

dcl  1 indirect_sort_array aligned based (sortp),		/* used for sorting time_stamped_events		*/
       2 sort_index (262144) fixed bin (18);





/* Entry */

dcl  com_err_ entry () options (variable);
dcl  copy_from_dump entry ((*) ptr, fixed bin, fixed bin (18), fixed bin (18), ptr, fixed bin (18), fixed bin (35));
dcl  decode_clock_value_$date_time
	entry (fixed bin (71), fixed bin, fixed bin, fixed bin, fixed bin, fixed bin, fixed bin, fixed bin (71),
	fixed bin, char (4), fixed bin (35));
dcl  get_bound_seg_info_ entry (ptr, fixed bin (24), ptr, ptr, ptr, fixed bin (35));
dcl  get_temp_segment_ entry (char (*), ptr, fixed bin (35));
dcl  hcs_$initiate_count entry (char (*), char (*), char (*), fixed bin (24), fixed bin (2), ptr, fixed bin (35));
dcl  hcs_$terminate_noname entry (ptr, fixed bin (35));
dcl  ioa_ entry () options (variable);
dcl  ioa_$nnl entry () options (variable);
dcl  ioa_$rsnnl entry options (variable);
dcl  release_temp_segment_ entry (char (*), ptr, fixed bin (35));
dcl  release_temp_segments_ entry (char (*), (*) ptr, fixed bin (35));
dcl  ring0_get_$definition_given_slt
	entry (ptr, char (*), char (*), fixed bin (18), fixed bin, fixed bin (35), ptr, ptr, ptr);
dcl  ring0_get_$name_given_slt entry (char (*), char (*), ptr, fixed bin (35), ptr, ptr);
dcl  ring0_get_$segptr_given_slt entry (char (*), char (*), ptr, fixed bin (35), ptr, ptr);


/* External */

dcl  sys_info$max_seg_size fixed bin (18) external;

/* Condition */

dcl  cleanup condition;

/* Builtin */

dcl  addr builtin;
dcl  addrel builtin;
dcl  baseno builtin;
dcl  baseptr builtin;
dcl  bin builtin;
dcl  clock builtin;
dcl  currentisze builtin;
dcl  divide builtin;
dcl  hbound builtin;
dcl  index builtin;
dcl  length builtin;
dcl  mod builtin;
dcl  null builtin;
dcl  ptr builtin;
dcl  rel builtin;
dcl  rtrim builtin;
dcl  size builtin;
dcl  substr builtin;
dcl  unspec builtin;

%page;

/* Initialize temporary segment allocation 							*/

	call get_temp_segment_ (MYNAME, temp_seg_data_p, code);
	if code ^= 0 then do;
	     call com_err_ (code, MYNAME, "Getting temp segment.");
	     return;
	     end;

/* Setup pointers and cleanup handler */

	on cleanup call cleanit;

	dumpptr = dump_ptrs (1);
	sltp = slt_ptr;
	eventsp = allocate_temp_seg ();
	tsegp = allocate_temp_seg ();
	temp_alloc_p = null ();
	pvtp = null ();


/* Find segment numbers of all interesting segments 						*/

	do seginx = 1 to N_INTERESTING_SEGS;
	     if segname (seginx) ^= "" then do;
		call ring0_get_$segptr_given_slt ("", segname (seginx), segp, code, slt_ptr, nametbl_ptr);
		if code = 0
		then interesting_segs.segno (seginx) = bin (baseno (segp), 18);
		else call com_err_ (code, MYNAME, "^a not found in dump", segname (seginx));
		end;
	end;

%page;
	prds_processor = "11111111"b;
	call ring0_get_$segptr_given_slt ("", "bound_interceptors", bound_interceptors_ptr, code, slt_ptr, nametbl_ptr);
	if code ^= 0 then bound_interceptors_ptr = null ();

	do stack_inx = 0 to hbound (stack_segs, 1);
	     stack_segs (stack_inx) = -1;
	end;
	proc_no = 0;
	last_segno = -1;
	earliest_recorded_time = clock ();		/* dump must be earlier than this		*/


	apt_array_p = allocate_temp_seg ();
	apt_array.n_aptes = 0;


/* First event is return to BOS								*/

	if delta_time = 0
	then earliest_time = 0;
	else earliest_time = dump.mctime - delta_time;
	n_events = 0;
	call add_an_event (bin (dump.mctime, 71), addr (dump.scu (0)), print_dump_mc, "RTB Machine Conditions", "0"b,
	     "0"b);

/* Go through segments dumped, building events in event array					*/

	do dump_seginx = 1 to dump.num_segs;
	     dump_segno = bin (dump.segs (dump_seginx).segno, 18);
	     if dump_segno < last_segno		/* new process dumped			*/
	     then do;
		proc_no = proc_no + 1;
		do stack_inx = 0 to hbound (stack_segs, 1);
		     stack_segs (stack_inx) = -1;
		end;
		interesting_segs (MC_TRACE_BUF).process_this_seg = "0"b;
						/* mc tracing is per-process */
		end;
	     last_segno = dump_segno;
	     if dump_segno <= slt.last_sup_seg		/* only hardcore segs are interesting		*/
		| interesting_segs (MC_TRACE_BUF).process_this_seg
						/* unless tracing machine conditions */
	     then do;
		seg_found = "0"b;
		seginx = 1;
		do while (^seg_found & seginx <= N_INTERESTING_SEGS);
		     if dump_segno = interesting_segs.segno (seginx)
		     then seg_found = "1"b;
		     else seginx = seginx + 1;
		end;
		if seg_found & interesting_segs (seginx).process_this_seg then do;
		     call copy_from_dump (dump_ptrs, dump_seginx, 0, sys_info$max_seg_size, tsegp, words_copied, code)
			;			/* copy entire seg to temporary area		*/
		     if code ^= 0 then do;
COPY_ERR:
			call com_err_ (code, MYNAME, "seg index ^d", dump_seginx);
			call cleanit;
			return;
			end;
		     call interesting_segs (seginx).handler (tsegp, interesting_segs (seginx).process_this_seg);
		     end;
		end;
	     stack_found = "0"b;
	     do stack_inx = 0 repeat stack_inx + 1 while (^stack_found & stack_inx <= hbound (stack_segs, 1));
		if stack_segs (stack_inx) = dump_segno then do;
		     call copy_from_dump (dump_ptrs, dump_seginx, 0, sys_info$max_seg_size, tsegp, words_copied, code)
			;
		     if code ^= 0 then goto COPY_ERR;
		     call process_user_stack (stack_inx, tsegp, dump_segno);
		     stack_found = "1"b;
		     end;
	     end;
	end;

/* Now extract messages from the syserr log which are within the interval of
   interest										*/

	call process_syserr_log (earliest_recorded_time, tsegp);


%page;

/* Sort event array by time stamp (tag sort)							*/

	sortp = allocate_temp_seg ();
	do sortinx = 1 to n_events;
	     sort_index (sortinx) = sortinx;
	end;

	do sortinx = 1 to n_events - 1;
	     do sortinx1 = sortinx + 1 to n_events;
		if events (sort_index (sortinx1)).time_stamp > events (sort_index (sortinx)).time_stamp then do;
		     sortinxt = sort_index (sortinx1);	/* swap pointers 				*/
		     sort_index (sortinx1) = sort_index (sortinx);
		     sort_index (sortinx) = sortinxt;
		     end;
		else if events (sort_index (sortinx1)).time_stamp = events (sort_index (sortinx)).time_stamp then do;
		     if events (sort_index (sortinx1)).delete_on_duplicate_time
		     then events (sort_index (sortinx1)).deleted = "1"b;
		     if events (sort_index (sortinx)).delete_on_duplicate_time
		     then events (sort_index (sortinx)).deleted = "1"b;
		     end;
	     end;
	end;

%page;

/* Print the sorted events by calling the print routine for each,
   passing the decoded time value								*/

	first_print = "1"b;
	last_date_time = " ";
	last_sec = -1;
	if num_events = 0
	then max_events = n_events;
	else max_events = min (n_events, num_events);
	do event_inx = 1 to max_events;
	     if ^events (sort_index (event_inx)).deleted then do;
		call decode_clock_value_$date_time (events (sort_index (event_inx)).time_stamp, mon, dom, yr, hr,
		     minute, sec, micsec, dow, "", code);
		if code = 0 then do;
		     MON = mon;
		     DOM = dom;
		     YR = mod (yr, 100);
		     HR = hr;
		     MIN = minute;
		     SEC = sec;
		     MICSEC = micsec;
		     cur_date_time = MON || "/" || DOM || "/" || YR || " " || HR || ":" || MIN;
		     if cur_date_time ^= last_date_time
		     then call ioa_ ("Events from ^a:^a.^a", cur_date_time, SEC, MICSEC);
		     if first_print then do;
			call ioa_ ("^4xTime^2xCPU Proc Event^27xCircumstances^/");
			first_print = "0"b;
			end;
		     last_date_time = cur_date_time;
		     if last_sec = sec
		     then call ioa_$nnl ("  .^6a  ", MICSEC);
		     else call ioa_$nnl ("^2a.^6a  ", SEC, MICSEC);
		     last_sec = sec;


/* Find FDUMP Process Number if necessary */

		     process_number = events (sort_index (event_inx)).process_number;

		     if events (sort_index (event_inx)).apte_offset ^= "0"b then do;
			apt_proc_found = "0"b;
			apt_inx = 1;
			do while (^apt_proc_found & apt_inx <= apt_array.n_aptes);
			     if events (sort_index (event_inx)).apte_offset = apt_array.apt_desc (apt_inx).offset
			     then do;
				apt_proc_found = "1"b;
				process_number = apt_array.apt_desc (apt_inx).procn;
				end;
			     else apt_inx = apt_inx + 1;
			end;
			end;


		     call events (sort_index (event_inx))
			.
			event_display (events (sort_index (event_inx)).added_info,
			events (sort_index (event_inx)).event_struct_ptr, process_number);
		     end;
		end;
	end;


GLOBAL_RETURN:
	call cleanit;
	return;


%page;
/* Internal procedure to add an event to the structure if its time
   is within the range of interest								*/


add_an_event:
     proc (etime, eptr, eroutine, eadded_info, delete_duplicate, apte_offset);


dcl  etime fixed bin (71);				/* time of event				*/
dcl  eptr ptr;					/* pointer to event structure			*/
dcl  eroutine entry (char (*), ptr, fixed bin) variable;	/* routine to print event			*/
dcl  eadded_info char (*);				/* clear-text info of interest		*/
dcl  delete_duplicate bit (1) aligned;			/* ON => delete this event if duplicate times */
dcl  apte_offset bit (18);				/* APTE offset or "0"b */


	if etime < earliest_time then return;
	n_events = n_events + 1;
	events (n_events).time_stamp = etime;
	events (n_events).event_struct_ptr = eptr;
	events (n_events).event_display = eroutine;
	events (n_events).added_info = eadded_info;
	events (n_events).process_number = proc_no;
	events (n_events).apte_offset = apte_offset;
	events (n_events).deleted = "0"b;
	events (n_events).delete_on_duplicate_time = delete_duplicate;

	if etime < earliest_recorded_time & etime ^= 0 then earliest_recorded_time = etime;

     end add_an_event;






%page;


/* Internal Procedure to allocate an additional temporary segment,
   and return a pointer to same								*/


allocate_temp_seg:
     proc returns (ptr);

	call get_temp_segment_ (MYNAME, temp_segp (n_temp_segs + 1), code);
	if code ^= 0 then do;
	     call com_err_ (code, MYNAME, "Getting temp seg.");
	     goto GLOBAL_RETURN;
	     end;

	n_temp_segs = n_temp_segs + 1;

	return (temp_segp (n_temp_segs));


     end allocate_temp_seg;


%page;

/* Internal Procedure for Cleanup								*/


cleanit:
     proc;

dcl  rcode fixed bin (35);

	if temp_seg_data_p ^= null () then do;
	     if n_temp_segs > 0 then call release_temp_segments_ (MYNAME, temp_segp, rcode);
	     call release_temp_segment_ (MYNAME, temp_seg_data_p, rcode);
	     temp_seg_data_p = null ();
	     end;


     end cleanit;

%page;
/* Internal Procedure to copy the PVT to a temporary segment. This
   is necessary to print some of the interesting stuff about disk
   queues
*/

copy_pvt:
     proc (temp_pvt_ptr, process_it);

dcl  temp_pvt_ptr ptr;
dcl  process_it bit (1) aligned;


	process_it = "1"b;				/* Only copy PVT once */
	pvtp = temp_pvt_ptr;			/* That wasn't too hard */
	temp_pvt_ptr = allocate_temp_seg ();

     end copy_pvt;

%page;

/* Internal Procedure to copy a part of a segment to a temporary segment.
   Additional temporary segments are allocated as necessary, and a pointer
   to the copy is returned									*/


copy_to_temporary:
     proc (dptr, dlength) returns (ptr);


dcl  dptr ptr;					/* pointer to part of segment to copy	*/
dcl  dlength fixed bin (18);				/* number of words to copy			*/



dcl  tlength fixed bin (18);
dcl  tptr ptr;
dcl  based_move (tlength) fixed bin (35) aligned based;


	tlength = divide (dlength + 63, 64, 18) * 64;	/* Make modulo 64				*/
	if temp_alloc_p = null ()			/* first time here				*/
	then temp_alloc_p = allocate_temp_seg ();
	else if bin (rel (temp_alloc_p), 18) + tlength > sys_info$max_seg_size then temp_alloc_p = allocate_temp_seg ();

	tptr = temp_alloc_p;
	temp_alloc_p = addrel (temp_alloc_p, tlength);
	tptr -> based_move = dptr -> based_move;
	return (tptr);


     end copy_to_temporary;

%page;

/*   This procedure is used to expand the seg name  */

expand_seg_name:
     proc (seg_name, seg_ptr, offrel, exp_seg_name);

dcl  seg_name char (*);
dcl  seg_ptr ptr;
dcl  offrel fixed bin (18);
dcl  exp_seg_name char (256) var;
dcl  dirname char (168);
dcl  bitcnt fixed bin (24) init (0);
dcl  genp ptr init (null);
dcl  ptrtmp ptr init (null);
dcl  sblkp ptr init (null);
dcl  xcode fixed bin (35) init (0);
dcl  (i, j, k) fixed bin init (0);
dcl  mblen fixed bin init (168);
dcl  ling fixed bin init (0);
dcl  var_str char (ling) based (ptrtmp);


dcl  1 oi_area aligned like object_info;

dcl  1 branch aligned,
       2 type bit (2) unal,
       2 nnames fixed bin (15) unal,
       2 nrp bit (18) unal,
       2 dtm bit (36) unal,
       2 dtu bit (36) unal,
       2 mode bit (5) unal,
       2 pad bit (13) unal,
       2 rec fixed bin (17) unal;





	dirname = ">library_dir_dir>hardcore>execution";

	genp = null;				/* make sure ptr is null */
	call hcs_$initiate_count (dirname, seg_name, "", bitcnt, 0, genp, xcode);
	if genp = null then do;
	     exp_seg_name = seg_name;
	     go to trmnme;
	     end;


	oi_area.version_number = object_info_version_2;
	call get_bound_seg_info_ (genp, bitcnt, addr (oi_area), bmp, sblkp, xcode);
	if xcode ^= 0 then do;
	     exp_seg_name = seg_name;
	     go to trmnme;
	     end;


/* We now have a ptr to the bind map */
	do i = 1 to n_components;
	     j = fixed (bindmap.component (i).text_start, 18);
	     k = fixed (bindmap.component (i).text_lng, 18);
	     if offrel >= j
	     then if offrel < j + k then do;		/* We found a match */
matchp:
		     ptrtmp = addrel (sblkp, bindmap.component (i).name_ptr);
		     ling = fixed (bindmap.component (i).name_lng, 18);
		     call ioa_$rsnnl ("^a$^a|^o", exp_seg_name, mblen, seg_name, var_str, offrel - j);
		     go to trmnme;			/* Go term segment */
		     end;
	     j = fixed (bindmap.component (i).stat_start, 18);
	     k = fixed (bindmap.component (i).stat_lng, 18);
	     if offrel >= j
	     then if offrel < j + k then go to matchp;	/* We found a match */
	     j = fixed (bindmap.component (i).symb_start, 18);
	     k = fixed (bindmap.component (i).symb_lng, 18);
	     if offrel >= j
	     then if offrel < j + k then go to matchp;	/* We found a match */
	end;
	exp_seg_name = seg_name;
trmnme:
	call hcs_$terminate_noname (genp, xcode);
	return;


     end expand_seg_name;


%page;


/* Internal Procedure to build a pointer to a segment name and entry name,
   given a pointer to the base of the segment and the names						*/


get_definition_ptr:
     proc (segname, entryname, base_ptr) returns (ptr);


dcl  segname char (*);				/* name of segment 				*/
dcl  entryname char (*);				/* name of entry into segment			*/
dcl  base_ptr ptr;					/* pointer to base of segment			*/


dcl  basep ptr;
dcl  code fixed bin (35);
dcl  offset fixed bin (18);
dcl  type fixed bin;

	basep = null ();
	call ring0_get_$definition_given_slt (basep, segname, entryname, offset, type, code, slt_ptr, nametbl_ptr,
	     definitions_ptr);
	if code ^= 0 then do;
	     call com_err_ (code, MYNAME, "Cannot find ^a$^a in dump.", segname, entryname);
	     return (null ());
	     end;

	return (ptr (base_ptr, offset));


     end get_definition_ptr;
%page;
/* Internal procedure to return the hardcore segment name given a pointer				*/


get_segment_name:
     proc (seg_ptr, seg_name) returns (bit (1));


dcl  seg_ptr ptr;					/* pointer to segment			*/
dcl  seg_name char (*);

dcl  dname char (168);
dcl  rcode fixed bin (35);

	call ring0_get_$name_given_slt (dname, seg_name, seg_ptr, rcode, slt_ptr, nametbl_ptr);
	if rcode = 0
	then return ("1"b);
	else return ("0"b);

     end get_segment_name;




%page;
/* Internal Procedure to print apte								*/


print_apte:
     proc (added_info, structp, process_n);


dcl  added_info char (*);
dcl  structp ptr;
dcl  process_n fixed bin;


dcl  state_name char (10);
dcl  process_na pic "zz9";




dcl  STATE_NAMES (0:6) char (10) int static options (constant)
	init ("Empty", "Running", "Ready", "Waiting", "Blocked", "Stopped", "ptlocking");
dcl  WAITING fixed bin init (3) int static options (constant);


	aptep = structp;
	if bin (apte.state, 18) > hbound (STATE_NAMES, 1)
	then state_name = "Invalid";
	else state_name = STATE_NAMES (bin (apte.state, 18));

	process_na = process_n;


/* Print the interesting information from the apte						*/


	call ioa_ ("^1a^2x^3a  APTE at ^6o changed to ^a^[ for ^w^;^s^]", substr (CPU_TAG, bin (apte.pr_tag, 3) + 1, 1),
	     process_na, bin (rel (structp), 18), state_name, (bin (apte.state, 18) = WAITING), apte.wait_event);


     end print_apte;
%page;
/* Internal Procedure to print Connect to Device information					*/


print_device_data:
     proc (added_info, structp, process_n);

dcl  added_info char (*);
dcl  structp ptr;
dcl  process_n fixed bin;				/* not meaningful for this data		*/

dcl  1 iom_dev_data aligned like per_device based (structp);

	call ioa_ ("^8xConnect to ^1a ^2d", substr (IOM_TAG, iom_dev_data.iom, 1), iom_dev_data.channel);


     end print_device_data;

%page;
/* Internam Procedure to print Disk Queue information */

print_disk_queue:
     proc (info, dq_data_ptr, process_char);

dcl  info char (*);
dcl  dq_data_ptr ptr;
dcl  process_char char (*);

dcl  dev_num char (2);
dcl  diskadd fixed bin;
dcl  fsx fixed bin;
dcl  p99 pic "99";
dcl  sect_sw bit (1);
dcl  subsys_name char (4);

	diskq_datap = dq_data_ptr;
	if pvtp = null () then do;			/* PVT not in dump - not to worry */
	     subsys_name = "dskX";
	     dev_num = "NN";
	     sect_sw = "1"b;			/* Can't translate to record */
	     diskadd = diskq_data.sector;
	     end;
	else do;
	     pvt_arrayp = addr (pvt.array);
	     pvtep = addr (pvt_array (diskq_data.pvtx));
	     subsys_name = pvte.devname;
	     dev_num = convert (p99, pvte.logical_area_number);
	     sect_sw = diskq_data.sect_sw;
	     if sect_sw
	     then diskadd = diskq_data.sector;
	     else do;
		fsx = pvte.device_type;
		diskadd =
		     diskq_data.cylinder * rec_per_cyl (fsx)
		     + divide (diskq_data.sector - diskq_data.cylinder * sect_per_cyl (fsx), sect_per_rec (fsx), 17);
		end;
	     end;


	call ioa_ ("^8xDisk Queue: ^a_^a: ^[W^;R^] ^[Sec^;Rec^] ^8o Mem ^8o", subsys_name, dev_num, diskq_data.write_sw,
	     sect_sw, diskadd, diskq_data.coreadd);

     end print_disk_queue;


%page;
/* Internal Procedure to print BOS machine conditions						*/


print_dump_mc:
     proc (added_info, structp, process_n);


dcl  added_info char (*);
dcl  structp ptr;
dcl  process_n fixed bin;				/* process number meaningless here		*/


	call print_scu_data (structp, added_info, "   ");


     end print_dump_mc;
%page;


/* Internal Procedure to print machine conditions 						*/

print_mc:
     proc (added_info, structp, process_n);


dcl  added_info char (*);
dcl  structp ptr;
dcl  process_n fixed bin;

dcl  process_na pic "zz9";
dcl  process_num char (3);

	process_na = process_n;
	process_num = process_na;
	call print_scu_data (addr (structp -> mc.scu (0)), added_info, process_num);


     end print_mc;
%page;
/* Internal procedure to extract parameters from syserr_log event for printing				*/

print_syserr_log:
     proc (added_info, structp, process_n);

dcl  added_info char (*);
dcl  structp ptr;
dcl  process_n fixed bin;


dcl  sequence fixed bin (35);
dcl  severity fixed bin;
dcl  textl fixed bin (21);
dcl  textp ptr;


	smess_ptr = structp;
	sequence = smess.seq_num;
	severity = smess.code;
	textl = smess.text_len;
	textp = addr (smess.text);
	call print_syserr_message (sequence, severity, "syserr_log", textl, textp);


     end print_syserr_log;

%page;
/* Internal procedure to print a syserr message							*/

print_syserr_message:
     proc (sequence, severity, log_name, textl, textp);


dcl  sequence fixed bin (35);				/* syserr sequence number			*/
dcl  severity fixed bin;				/* syserr severity code			*/
dcl  log_name char (*);				/* name of log where the message came from	*/
dcl  textl fixed bin (21);				/* length of message is chars			*/
dcl  textp ptr;					/* pointer to text of message			*/


dcl  linel fixed bin (21);
dcl  textl_done fixed bin (21);
dcl  textl_total fixed bin (21);
dcl  trim_eol fixed bin (21);


dcl  1 message based (textp),
       2 pad char (textl_done),
       2 this_line char (linel),
       2 rest char (textl_total - linel - textl_done);


dcl  LINE_MAX_LENGTH fixed bin init (79) int static options (constant);
dcl  TEXT_MAX_LENGTH fixed bin init (200) int static options (constant);


	call ioa_ ("^8xSyserr #^o (^a), severity ^o", sequence, log_name, severity);

	textl_total = min (TEXT_MAX_LENGTH, textl);
	textl_done = 0;
	linel = textl_total;
	if linel <= 0 then return;
	do while (linel > 0);
	     if linel > LINE_MAX_LENGTH then do;
		linel = LINE_MAX_LENGTH;
		trim_eol = index (substr (reverse (this_line), 1, 20), " ");
		linel = linel - trim_eol;
		end;
	     call ioa_ ("^21x^a", this_line);
	     textl_done = textl_done + linel;
	     linel = textl_total - textl_done;
	end;


     end print_syserr_message;
%page;
/* Internal procedure to prepare a syserr message from the wired log for printing			*/

print_wired_syserr:
     proc (added_info, structp, process_n);

dcl  added_info char (*);
dcl  structp ptr;
dcl  process_n fixed bin;

dcl  sequence fixed bin (35);
dcl  severity fixed bin;
dcl  textl fixed bin (21);
dcl  textp ptr;


	wmess_ptr = structp;
	sequence = wmess.seq_num;
	severity = wmess.code;
	textl = wmess.text_len;
	textp = addr (wmess.text);
	call print_syserr_message (sequence, severity, "syserr_data", textl, textp);

     end print_wired_syserr;


%page;
/* Internal procedure to print SCU data from machine conditions					*/

print_scu_data:
     proc (scu_data_ptr, info, process_char);

dcl  scu_data_ptr ptr;				/* pointer to scu data in machine conditions	*/
dcl  info char (*);					/* additional information to print		*/
dcl  process_char char (*);				/* process number printably			*/



dcl  cpu_alph char (1);
dcl  fault_no fixed bin;
dcl  fault_sub_type bit (36);
dcl  hardware_interrupt_level fixed bin;
dcl  hardware_interrupt_no pic "99";
dcl  interrupt_level pic "9";
dcl  interrupt_no fixed bin;
dcl  iom_number char (1);
dcl  line1 char (80) varying;
dcl  line2 char (80) varying;
dcl  ptsr bit (1);
dcl  p_ring pic "9";
dcl  seg_name char (32);
dcl  exp_seg_name char (256) varying;
dcl  seg_valid bit (1);
dcl  sub_type_inx fixed bin;

dcl  SR_IOA_STRING char (50) int static options (constant) init ("^21x^3a ^o|^o^[, ring ^1o^;^s^[ (^a)^;^s^]^]");
dcl  FAULT_TYPES (0:31) char (4) int static options (constant)
	init ("SDF", "STR", "MME", "FT1", "TRO", "CMD", "DRL", "LUF", "CON", "PAR", "IPR", "ONC", "SUF", "OFL", "DIV",
	"EXF", "DF0", "DF1", "DF2", "DF3", "ACV", "MME2", "MME3", "MME4", "FT2", "FT3", "INV", "INV", "INV", "INV",
	"INV", "TRB");
dcl  FAULT_TSR_VALID bit (32) init ("01110111011101101111111111000001"b) int static options (constant);

dcl  FAULT_MASK_INDEX (0:31) fixed bin int static options (constant) init (0, 1, (7) 0, 2, 3, 4, (8) 0, 5, (11) 0);
dcl  FAULT_MASKS (5) bit (21) aligned int static options (constant) init ("4140000"b3,
						/* Store					*/
	"0000030"b3,				/* Parity					*/
	"3600000"b3,				/* Illegal Procedure			*/
	"0000006"b3,				/* Operation Not Complete			*/
	"7777740"b3);				/* Access Violation				*/
dcl  FAULT_SUB_TYPES (5, 21) char (5) int static options (constant) init ("ISN", (4) (3)" ", "NEA", "OOB", (14) (3)" ",
						/* Store					*/
	(16) (3)" ", "PARU", "PARL", (3) (3)" ",	/* Parity					*/
	"   ", "IOC", "IA+IM", "ISP", "IPR", (16) (3)" ", /* Illegal Procedure			*/
	(18) (3)" ", "ONC1", "ONC2", "   ",		/* Operation Not Complete			*/
	"IRO", "OEB", "E-OFF", "ORB", "R-OFF", "OWB",	/* Access Violation				*/
	"W-OFF", "NO GA", "OCB", "OCALL", "BOC", "INRET", /* Access Violation				*/
	"CRT", "RALR", "AM-ER", "OOSB", (5) (1)" ");	/* Access Violation				*/

dcl  SC_IA_TYPES (1:15) char (43) var int static options (constant)
	init ("Unassigned (01). ", "Non-existent Address (02). ", "Stop on Condition (03). ", "Unassigned (04). ",
	"Data Parity, Store to SC (05). ", "Data Parity in Store (06). ", "Data Parity in Store AND Store to SC (07). ",
	"Not Control (10). ", "Port Not Enabled (11). ", "Illegal Command (12). ", "Store Not Ready ( 13). ",
	"ZAC Parity, Active Module to SC (14). ", "Data Parity, Active Module to SC (15). ",
	"ZAC Parity, SC to Store (16). ", "Data Parity, SC to Store (17). ");


	line2 = "";

	scup = scu_data_ptr;
	cpu_alph = substr (CPU_TAG, bin (scu.cpu_no, 3) + 1, 1);
	if scu.fi_flag then do;			/* Fault					*/
	     fault_no = bin (scu.fi_num, 17);
	     line1 = "Fault:  " || FAULT_TYPES (fault_no);
	     ptsr = substr (FAULT_TSR_VALID, fault_no + 1, 1);
	     if FAULT_MASK_INDEX (fault_no) ^= 0 then do; /* subtype of fault				*/
		fault_sub_type = unspec (scu.fd) & FAULT_MASKS (FAULT_MASK_INDEX (fault_no));
		sub_type_inx = index (fault_sub_type, "1"b);
		if sub_type_inx ^= 0
		then line1 = line1 || " (" || rtrim (FAULT_SUB_TYPES (FAULT_MASK_INDEX (fault_no), sub_type_inx))
			|| ")";
		end;
	     end;
	else do;					/* Interrupt				*/
	     ptsr = "0"b;
	     interrupt_no = bin (scu.fi_num, 5);
	     hardware_interrupt_level = divide (interrupt_no, 4, 17);
	     if hardware_interrupt_level = 0 | hardware_interrupt_level = 6 then do;
		hardware_interrupt_no = interrupt_no;
		line1 = "Interrupt: Number " || hardware_interrupt_no;
		end;
	     else do;
		interrupt_level = hardware_interrupt_level + mod (hardware_interrupt_level + 1, 2);
		iom_number = substr (IOM_TAG, mod (interrupt_no, 4) + 1, 1);
		line1 = "Interrupt: IOM " || iom_number || ", Level " || interrupt_level;
		end;
	     end;

	call ioa_ ("^1a^2x^3a^2x^32a^a", cpu_alph, process_char, line1, info);

	if line2 ^= "" then call ioa_ ("^28t^a", line2);

	if long_report then do;
	     if scu.ppr.prr = "0"b then seg_valid = get_segment_name (baseptr (bin (scu.ppr.psr, 15)), seg_name);
	     if (seg_valid) & (substr (seg_name, 1, 5) = "bound")
	     then call expand_seg_name (seg_name, baseptr (bin (scu.ppr.psr, 15)), bin (scu.ilc, 18), exp_seg_name);

	     else exp_seg_name = seg_name;

	     call ioa_ (SR_IOA_STRING, "by ", bin (scu.ppr.psr, 15), bin (scu.ilc, 18), scu.ppr.prr, scu.ppr.prr,
		seg_valid, exp_seg_name);
	     if ptsr then do;			/* print TSR/CA if valid			*/
		if scu.tpr.trr = "0"b then seg_valid = get_segment_name (baseptr (bin (scu.tpr.tsr, 15)), seg_name);
		if (seg_valid) & (substr (seg_name, 1, 5) = "bound")
		then call expand_seg_name (seg_name, baseptr (bin (scu.tpr.tsr, 15)), bin (scu.ca, 18), exp_seg_name);

		else exp_seg_name = seg_name;

		call ioa_ (SR_IOA_STRING, "ref", bin (scu.tpr.tsr, 15), bin (scu.ca, 18), scu.tpr.trr, scu.tpr.trr,
		     seg_valid, exp_seg_name);
		end;
	     end;



     end print_scu_data;
%page;
/* Internal Procedure to scan disk_seg and extract all queue entries */

process_disk_queue:
     proc (disk_seg_ptr, process_it);

dcl  disk_seg_ptr ptr;
dcl  process_it bit (1) aligned;

dcl  qx fixed bin;
dcl  sx fixed bin;
dcl  queue_time fixed bin (71);
dcl  queue_time_base fixed bin (71);
dcl  1 diskq_temp aligned like diskq_data;

	disksp = disk_seg_ptr;
	process_it = "0"b;
	if ^long_report then return;

	do qx = 1 to disk_data.free_q_size;
	     if disk_data.free_q_entries (qx).time ^= 0 then do;
		qp = addr (disk_data.free_q_entries (qx));
		diskq_temp.pvtx = quentry.pvtx;
		diskq_temp.write_sw = write_map (quentry.type);
		diskq_temp.sect_sw = sector_map (quentry.type);
		diskq_temp.coreadd = bin (quentry.coreadd, 25);
		diskq_temp.sector = bin (quentry.sector, 21);
		diskq_temp.cylinder = quentry.cylinder;
		queue_time = quentry.time;

		call add_an_event (queue_time, copy_to_temporary (addr (diskq_temp), size (diskq_temp)),
		     print_disk_queue, "Disk Queue", "0"b, "0"b);
	     end;
	end;

     end process_disk_queue;


%page;

/* Internal Procedure to scan a per-process machine condition trace buffer
   for machine conditions */

process_mc_trace_buf:
     proc (mctbp, process_it);

dcl  mctbp ptr;
dcl  process_it bit (1) aligned;

dcl  len fixed bin (21);
dcl  mcptr ptr;
dcl  mcx fixed bin;
dcl  mc_seg_offset char (30);

	process_it = "0"b;
	bp = mctbp;

	do mcx = 1 to mc_trace_buf.mc_cnt;
	     mcptr = addr (mc_trace_buf.mach_cond (mcx));
	     if addr (mcptr -> mc.scu (0)) -> scu.ppr.psr ^= "0"b then do;
		call ioa_$rsnnl ("mc_trace_buf (^o|^o)", mc_seg_offset, len, dump_segno, bin (rel (mcptr)));
		call add_an_event (bin (mcptr -> mc.fault_time, 54), copy_to_temporary (mcptr, size (mc)), print_mc,
		     mc_seg_offset, "1"b, "0"b);
		end;
	end;

     end process_mc_trace_buf;


%page;
/* Internal procedure to setup call to scan inzr_stk0						*/
process_inzr_stk0:
     proc (inzr_stk0_ptr, process_it);

dcl  inzr_stk0_ptr ptr;				/* pointer to copy of inzr_stk0		*/
dcl  process_it bit (1) aligned;			/* flag to process segment again		*/

dcl  code fixed bin (35);
dcl  segp ptr;

	process_it = "0"b;				/* only come here once			*/
	call ring0_get_$segptr_given_slt ("", "inzr_stk0", segp, code, slt_ptr, nametbl_ptr);
	if code ^= 0 then return;
	call walk_stack (inzr_stk0_ptr, bin (baseno (segp)), "inzr_stk0");

     end process_inzr_stk0;


%page;
/* Internal Procedure to scan iom_data for events of interest					*/

process_iom_data:
     proc (iom_data_p, process_it);

dcl  iom_data_p ptr;
dcl  process_it bit (1) aligned;

dcl  dev_no fixed bin;
dcl  per_device_p ptr;


	process_it = "0"b;				/* only come here once			*/
	iom_data_ptr = iom_data_p;
	if iom_data.n_devices > 0
	then do dev_no = 1 to iom_data.n_devices;
	     per_device_p = copy_to_temporary (addr (iom_data.per_device (dev_no)), size (per_device));
	     call add_an_event (iom_data.per_device (dev_no).connect_time, per_device_p, print_device_data,
		"per_device", "0"b, "0"b);
	end;


     end process_iom_data;


%page;

/* Internal Procedure to scan the PDS for events of interest					*/

process_pds:
     proc (pdsp, process_it);


dcl  pdsp ptr;					/* pointer to copied-out pds			*/
dcl  process_it bit (1) aligned;			/* flag to process this seg again		*/



dcl  aptp ptr;
dcl  bpp ptr;
dcl  mcptr ptr;
dcl  names_inx fixed bin;
dcl  pds_stacks_inx fixed bin;
dcl  pds_stacks_ptr ptr;


dcl  pds_names (3) char (32) int static options (constant) init ("page_fault_data", "fim_data", "signal_data");

dcl  based_flag fixed bin (35) based;
dcl  based_ptr ptr aligned based;
dcl  based_ptr_packed ptr unaligned based;
dcl  pds_stacks (0:7) ptr aligned based (pds_stacks_ptr);


	aptp = get_definition_ptr ("pds", "apt_ptr", pdsp);
	if aptp = null () then return;
	if rel (aptp -> based_ptr) = "0"b then return;

	apt_array.n_aptes = apt_array.n_aptes + 1;
	apt_array.apt_desc (n_aptes).offset = rel (aptp -> based_ptr);
	apt_array.apt_desc (n_aptes).procn = proc_no;


	do names_inx = 1 to hbound (pds_names, 1);
	     mcptr = validate_mc (pdsp, "pds", pds_names (names_inx));
	     if mcptr ^= null ()
	     then					/* machine condtions exist			*/
		call add_an_event (bin (mcptr -> mc.fault_time, 54), mcptr, print_mc,
		     "pds$" || rtrim (pds_names (names_inx)), "0"b, "0"b);
	end;

/* Extract stack segment numbers from the pds							*/

	pds_stacks_ptr = get_definition_ptr ("pds", "stacks", pdsp);
	if pds_stacks_ptr = null () then return;
	do pds_stacks_inx = 0 to hbound (pds_stacks, 1);
	     if pds_stacks (pds_stacks_inx) ^= null ()
	     then stack_segs (pds_stacks_inx) = bin (baseno (pds_stacks (pds_stacks_inx)), 17);
	     else stack_segs (pds_stacks_inx) = -1;
	end;

/* Check whether this process is tracing machine conditions */

	bpp = get_definition_ptr ("pds", "mc_trace_sw", pdsp);
	if bpp = null () then return;
	if bpp -> based_flag = 0 then return;
	bpp = get_definition_ptr ("pds", "mc_trace_buf", pdsp);
	if bpp = null () then return;
	interesting_segs (MC_TRACE_BUF).process_this_seg = "1"b;
	interesting_segs (MC_TRACE_BUF).segno = bin (baseno (bpp -> based_ptr_packed), 18);


     end process_pds;

%page;
/* Internal procedure to scan prds for interesting events						*/

process_prds:
     proc (prdsp, process_it);

dcl  prdsp ptr;					/* pointer to copied-out prds			*/
dcl  process_it bit (1) aligned;			/* flag to process prds again			*/



dcl  mcptr ptr;
dcl  names_inx fixed bin;
dcl  processor_tag fixed bin;
dcl  prtag_based fixed bin aligned based;
dcl  prtagp ptr;


dcl  apte_offset bit (18);
dcl  bpp ptr;
dcl  based_ptr ptr based;
dcl  prds_names (3) char (32) int static options (constant) init ("sys_trouble_data", "interrupt_data", "fim_data");

	prtagp = get_definition_ptr ("prds", "processor_tag", prdsp);
	if prtagp = null () then return;
	processor_tag = prtagp -> prtag_based;


	if ^substr (prds_processor, processor_tag + 1, 1) /* seen this prds before			*/
	then return;
	substr (prds_processor, processor_tag + 1, 1) = "0"b;
	if prds_processor = "0"b then process_it = "0"b;	/* last prds on system			*/

	bpp = get_definition_ptr ("prds", "apt_ptr", prdsp);
	if bpp = null ()
	then apte_offset = "0"b;
	else apte_offset = rel (bpp -> based_ptr);


	do names_inx = 1 to hbound (prds_names, 1);
	     mcptr = validate_mc (prdsp, "prds", prds_names (names_inx));
	     if mcptr ^= null () then do;
		call add_an_event (bin (mcptr -> mc.fault_time, 54), mcptr, print_mc,
		     "prds$" || rtrim (prds_names (names_inx)), (prds_names (names_inx) ^= "sys_trouble_data"),
		     apte_offset);
		end;
	end;


     end process_prds;
%page;
/* Internal procedure to extract messages from the wired syserr buffer				*/

process_syserr_data:
     proc (syserr_data_ptr, process_it);

dcl  syserr_data_ptr ptr;				/* pointer to copy of syserr_data		*/
dcl  process_it bit (1) aligned;			/* flag to process this seg again		*/

dcl  wlog_inx fixed bin;
dcl  wp ptr;
dcl  wtime fixed bin (71);


	process_it = "0"b;				/* only come here once			*/



	wlog_ptr = get_definition_ptr ("syserr_data", "wired_log_area", syserr_data_ptr);
	if wlog_ptr = null () then return;
	wmess_ptr = addr (wlog.buffer);

	if wlog.head.count < 1 then return;		/* no messages in buffer			*/

	do wlog_inx = 1 to wlog.head.count;
	     wp = copy_to_temporary (wmess_ptr, divide (length (unspec (wmess)), 36, 18));
	     wtime = wmess.time;
	     call add_an_event (wtime, wp, print_wired_syserr, "syserr_data", "0"b, "0"b);
	     wmess_ptr = addrel (wmess_ptr, divide (length (unspec (wmess)), 36, 18));
	end;


     end process_syserr_data;
%page;
/* Internal procedure to scan syserr log for messages within interval of interest			*/

process_syserr_log:
     proc (low_time, temp_ptr);


dcl  low_time fixed bin (71);				/* earliest time of interest			*/
dcl  temp_ptr ptr;					/* temporary segment we can use		*/


dcl  code fixed bin (35);
dcl  first_msg bit (18);
dcl  slog_done bit (1);
dcl  slog_found bit (1);
dcl  slog_inx fixed bin;
dcl  slog_no fixed bin;
dcl  slog_offset bit (18);
dcl  slog_p ptr;
dcl  slog_time fixed bin (71);
dcl  slog_tp ptr;
dcl  slog_words fixed bin (18);


dcl  MESS_MAX_SIZE fixed bin (18) init (1024) int static options (constant);

/* Find syserr_log in the dump								*/

	call ring0_get_$segptr_given_slt ("", "syserr_log", slog_p, code, slt_ptr, nametbl_ptr);
	if code ^= 0 then do;
SLOG_ERROR:
	     call com_err_ (code, MYNAME, "Error encountered processing syserr_log");
	     return;
	     end;

	slog_no = bin (baseno (slog_p), 18);
	slog_found = "0"b;
	slog_inx = 1;
	do while (^slog_found & slog_inx <= dump.num_segs);
	     if bin (dump.segs (slog_inx).segno, 18) = slog_no
	     then slog_found = "1"b;
	     else slog_inx = slog_inx + 1;
	end;
	if ^slog_found then goto SLOG_ERROR;

/* copy syserr_log header									*/

	call copy_from_dump (dump_ptrs, slog_inx, 0, size (slog_header), temp_ptr, slog_words, code);
	if code ^= 0 then goto SLOG_ERROR;

/* Romp through syserr_log, picking out events within the interval of
   interest--i.e., times less than earliest one found elsewhere					*/

	slog_ptr = temp_ptr;
	first_msg = slog.head.first;
	slog_offset = slog.head.last;
	slog_done = "0"b;

	do while (^slog_done);
	     if slog_offset = "0"b | slog_offset = first_msg
	     then slog_done = "1"b;
	     else do;
		call copy_from_dump (dump_ptrs, slog_inx, bin (slog_offset, 18), MESS_MAX_SIZE, temp_ptr, slog_words,
		     code);
		if code ^= 0 then goto SLOG_ERROR;
		smess_ptr = temp_ptr;
		slog_time = smess.time;
		if slog_time < low_time | slog_time > dump.mctime
		then slog_done = "1"b;
		else do;
		     slog_tp = copy_to_temporary (smess_ptr, min (currentsize (smess), MESS_MAX_SIZE));
		     call add_an_event (slog_time, slog_tp, print_syserr_log, "syserr_log", "0"b, "0"b);
		     slog_offset = smess.prev;
		     end;
		end;
	end;


     end process_syserr_log;


%page;
/* Internal procedure to scan tc_data for interesting events					*/


process_tc_data:
     proc (tc_data_ptr, process_it);


dcl  tc_data_ptr ptr;				/* pointer to copied-out tc_data		*/
dcl  process_it bit (1) aligned;


dcl  aptx fixed bin;
dcl  bp ptr;
dcl  num_aptes fixed bin;
dcl  size_of_apte fixed bin;
dcl  tp ptr;

dcl  EMPTY fixed bin init (0) int static options (constant);

dcl  based_fixed fixed bin (35) aligned based;


	process_it = "0"b;				/* only process tc_data once			*/



	bp = get_definition_ptr ("tc_data", "apt_size", tc_data_ptr);
	if bp = null () then return;
	num_aptes = bp -> based_fixed;
	if num_aptes <= 0 then return;
	bp = get_definition_ptr ("tc_data", "apt_entry_size", tc_data_ptr);
	if bp = null () then return;
	size_of_apte = bp -> based_fixed;
	if size_of_apte <= 0 then return;

	tp = copy_to_temporary (tc_data_ptr, sys_info$max_seg_size);
	aptep = get_definition_ptr ("tc_data", "apt", tp);
	if aptep = null () then return;

	do aptx = 1 to num_aptes;
	     if bin (apte.state, 18) ^= EMPTY & apte.state_change_time ^= 0
	     then call add_an_event (apte.state_change_time, aptep, print_apte, "apte", "0"b, rel (aptep));
	     aptep = addrel (aptep, size_of_apte);
	end;


     end process_tc_data;
%page;
/* Internal procedure to set up a stack for scanning						*/

process_user_stack:
     proc (ring_no, stack_ptr, stack_seg_no);

dcl  ring_no fixed bin;				/* ring number of stack in process		*/
dcl  stack_ptr ptr;					/* pointer to copy of stack			*/
dcl  stack_seg_no fixed bin;				/* segment number of stack in process		*/

dcl  ring_num pic "9";

	ring_num = ring_no;
	call walk_stack (stack_ptr, stack_seg_no, "stack_" || ring_num);

     end process_user_stack;
%page;
/* Internal procedure to get interesting data from scs 						*/

setup_from_scs:
     proc (scs_ptr, process_it);

dcl  scs_ptr ptr;					/* pointer to copy of scs			*/
dcl  process_it bit (1) aligned;			/* flag to process segment again		*/

dcl  proc_number fixed bin;
dcl  proc_exists_mask bit (36);
dcl  scs_proc_data_ptr ptr;

dcl  1 pdata (0:7) aligned like scs$processor_data based (scs_proc_data_ptr);

	process_it = "0"b;				/* process scs but once			*/
	proc_exists_mask = "0"b;
	scs_proc_data_ptr = get_definition_ptr ("scs", "processor_data", scs_ptr);
	if scs_proc_data_ptr = null () then return;

	do proc_number = 0 to hbound (pdata, 1);	/* find all cpus which might have been active	*/
	     if pdata (proc_number).online | pdata (proc_number).offline
	     then substr (proc_exists_mask, proc_number + 1, 1) = "1"b;
	end;
	prds_processor = prds_processor & proc_exists_mask;


     end setup_from_scs;


%page;
/* Internal procedure to check a named location for valid machine conditions.
   If machine conditions are stored, they are copied to temporary storage,
   and a pointer to the temporary storage area is returned						*/

validate_mc:
     proc (segptr, segname, mc_name) returns (ptr);


dcl  segptr ptr;					/* pointer to base of copy of segment		*/
dcl  segname char (*);				/* segment name				*/
dcl  mc_name char (*);				/* entry name where machine conditions are stored */

dcl  mcptr ptr;


	mcptr = get_definition_ptr (segname, mc_name, segptr);
	if mcptr = null () then return (mcptr);
	if addr (mcptr -> mc.scu (0)) -> scu.ppr.psr = "0"b then return (null ());
	return (copy_to_temporary (mcptr, size (mc)));


     end validate_mc;
%page;
/* Internal procedure to validate a stack pointer and construct a pointer
   to it.  The pointer is checked to contain the segment number of the stack,
   to point to a mod-16 location, and to be within the bounds defined by
   the stack_end_ptr.  A pointer to the frame in the copy of the stack is constructed 			*/

validate_stack_ptr:
     proc (stack_ptr, seg_num, stack_base_ptr) returns (ptr);

dcl  stack_ptr ptr;					/* stack pointer from FDUMP			*/
dcl  seg_num fixed bin;				/* segment number of stack in FDUMP		*/
dcl  stack_base_ptr ptr;				/* pointer to copy of stack			*/

	if baseno (stack_ptr) = "077777"b3
	then					/* if null ptr */
	     return (null ());			/* return */


	if addr (stack_ptr) -> its.mod then return (null ());
						/* return */
	if addr (stack_ptr) -> its.bit_offset then return (null ());
						/* return */
	if addr (stack_ptr) -> its.its_mod ^= ITS_MODIFIER then return (null ());

	if bin (baseno (stack_ptr)) ^= seg_num
	     | bin (rel (stack_ptr)) >= bin (rel (stack_base_ptr -> stack_header.stack_end_ptr))
	     | mod (bin (rel (stack_ptr)), 16) ^= 0
	     | bin (rel (stack_ptr)) < bin (rel (stack_base_ptr -> stack_header.stack_begin_ptr))
	     | rel (stack_ptr) = "0"b
	then return (null ());
	return (ptr (stack_base_ptr, rel (stack_ptr)));


     end validate_stack_ptr;

%page;
/* Internal procedure to walk a stack looking for fim-frames
   the walk is done forward, and only frames within the current segment
   are considered (there really shouldn't be any outside of it)					*/

walk_stack:
     proc (stack_ptr, stack_seg, stack_name);

dcl  stack_ptr ptr;					/* pointer to copy of stack			*/
dcl  stack_seg fixed bin;				/* segment number of stack			*/
dcl  stack_name char (*);				/* name of stack				*/


dcl  fim_cond_ptr ptr;
dcl  len fixed bin (21);
dcl  loop_count fixed bin;
dcl  next_frame_mc bit (1);
dcl  seg_offset char (13);


	sb = stack_ptr;
	loop_count = 1000;
	sp = validate_stack_ptr (stack_header.stack_begin_ptr, stack_seg, sb);
	if sp = null () then return;


	next_frame_mc = "0"b;
	do sp = sp repeat validate_stack_ptr (stack_frame.next_sp, stack_seg, sb)
	     while (sp ^= null () & loop_count > 0);
	     mcp = null ();
	     if next_frame_mc
		| (bound_interceptors_ptr ^= null ()
		& baseno (bound_interceptors_ptr) = baseno (stack_frame.return_ptr)) then do;
		mcp = addrel (sp, stack_frame_min_length);
		if addr (mc.scu (0)) -> scu.ppr.psr ^= "0"b then do;
		     call ioa_$rsnnl ("^a|^o", seg_offset, len, stack_name, bin (rel (sp)));
		     fim_cond_ptr = copy_to_temporary (mcp, size (mc));
		     call add_an_event (bin (mc.fault_time, 71), fim_cond_ptr, print_mc, seg_offset, "0"b, "0"b);
		     end;
		end;
	     next_frame_mc = "0"b;
	     if stack_frame_flags.signaller then next_frame_mc = "1"b;
	     loop_count = loop_count - 1;
	end;

     end walk_stack;
%page;
%include apte;
%page;
%include bind_map;
%page;
%include bos_dump;
%page;
%include dskdcl;
%page;
%include fs_dev_types;
%page;
%include iom_data;
%page;
%include its;
%page;
%include mc;
%page;
%include mc_trace_buf;
%page;
%include object_info;
%page;
%include pvt;
%page;
%include pvte;
%page;
%include scs;
%page;
%include slt;
%page;
%include stack_frame;
%page;
%include stack_header;
%page;
%include syserr_data;
%page;
%include syserr_log;



     end process_dump_segments;
