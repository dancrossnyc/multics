
/****^  HISTORY COMMENTS:
  1) change(2020-10-25,GDixon), approve(2021-02-23,MCR10089),
     audit(2021-03-31,Swenson), install(2021-03-31,MR12.6g-0053):
     Initial version created as part of help_ rewrite
  2) change(2020-11-18,GDixon), approve(2021-02-23,MCR10089),
     audit(2021-03-31,Swenson), install(2021-03-31,MR12.6g-0053):
      A) Change subroutine info seg end-of-block handling.  If entered
         via intro block, prompt user to see first unseen entrypoint
         blocks.  Otherwise, end output for the subroutine.
  3) change(2021-07-14,GDixon), approve(2021-07-14,MCR10089b),
     audit(2021-07-14,Swenson), install(2021-07-14,MR12.6g-0060):
      A) Fix uninitialized variable in $print_iPgh_range entry point
         setup.
                                                   END HISTORY COMMENTS */

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Replacements for  ssu_ Request Loop Replaceable Procedures			        */
	/*									        */
	/* The ssu_ reads subsystem request lines entered by the user via its ssu_$listen procedure.      */
	/* The subsystem listener in described in detail in the MPM Reference Guide, AG91-04.  See the    */
	/* section titled "Subsystem Request Loop" in section 4 of this guide.		        */
	/*									        */
	/* help_ uses "Replaceable Procedures" called by the ssu_ listener loop to provide the main       */
	/* services in displaying an info block:					        */
	/*   A) PROMPTING: describing upcoming sections of the info block, and asking the user if	        */
	/*      "More help?" is needed.						        */
	/*       - First step in suggesting which paragraphs to print next is to check whether any        */
	/*	 paragraphs are unseen.  If user has seen all paragraphs/sections, then branch to       */
	/*	 hi.NEXT_INFO_LABEL to display next info block in "selected info blocks" array.  This   */
	/*	 is main way to exit help_'s display_block and ssu_$listen.			        */
	/*   B) DISPLAYING PARAGRAPHS:						        */
	/*       - If the user responds "yes" to the "More help?" prompt, then display the upcoming       */
	/*	 paragraphs announced in the prior prompt.				        */
	/*       - If the user responds with something other than "yes" to the "More help?" prompt        */
	/*         detected by noting that a new print range has been selected, then display the revised  */
	/*	 print range.							        */
	/*       - If the user response contained an error, then display nothing.  This permits the prior */
	/*	 to be re-displayed so the user may correct the diagnosed error.		        */
	/*									        */
	/* The routines that implement these services are described and implemented below.	        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

help_listen_util_:					/* This entrypoint is never called by help_.	        */
     proc ();

  dcl  ioa_$nnl entry() options(variable);

  dcl  window_$clear_region entry (ptr, fixed bin, fixed bin, fixed bin, fixed bin, fixed bin(35));
  dcl  window_$get_cursor_position entry (ptr, fixed bin, fixed bin, fixed bin(35));

  dcl (char, currentsize, dim, length, ltrim, maxlength, null) builtin;

  dcl  ignore_code fixed bin(35);

     iPghP = iBlok.relatives.pghs.firstP;		/*  - Make Pgh/Sect structuress visible in symbol table.  */
     iSectP = iPgh.relatives.sectP;
     call ioa ("^a", Pgh);
     call ioa ("^a", Sect);
     return;

%page;
%include ssu_subroutine_dcls_;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

  dcl  section_part fixed bin (2);			/* Location of selected paragraphs to be added to print   */
						/*  range.				        */

  dcl (START_OF_SECTION  	init (0),			/* Constants describing parts of a section that can       */
       MIDDLE_OF_SECTION	init (1),			/*  appear in a range of paragraphs (the "print range")   */
       END_OF_SECTION	init (2),			/*  that will fit into the "info frame" on terminal page. */
       ALL_OF_SECTION	init (3)			/*  Returned by some_section_paragraphs_will_fit (below). */
       ) fixed bin (2) int static options(constant);	/* These constants appear here so they may be referenced  */
						/*  in PL/I label array constants in the code below.      */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
/*											        *
   The ssu_$listen LISTENER LOOP supervises printing of help paragraphs, display of "More help?" prompts, and
   processing for user's response to each prompt (the response is an ssu_ request line).  The LOOP consists of 
   four-steps described below.  The help_listen_util_ entry points are called in steps 1 and 4 of this LOOP.

	     When entering step 1:
	      If hi.selected.iPghP  ^= null,     it points to the actual "last paragraph printed" iPgh structure.
			         
                But if switching to a new section or paragraph...
	               If hi.iPghP   = null  &
	                  hi.iSectP  = null:     "last paragraph printed" appears to point to a paragraph 
					 before 1st section of block.
	               If hi.iPghP   = null  &
	                  hi.iSectP ^= null:     "last paragraph printed" appears to point to the paragraph 
	                                         before that section.

    Step 1:  Uses "last paragraph printed", hi.display_limit, and count of unseen paragraphs to determine
	   what paragraphs to display next; then tells user what they are...  via a "More help?" prompt.
	   ssu_$listen calls help_listen_util_$display_prompt to perform step 1.



	     When entering step 2 and for all subsequent steps:
	         hi.iPgh_print_range.startP   points to first iPgh to print.
			        .endP     points to last iPgh to print.


	         hi.selected.iPghP   = hi.iPgh_print_range.startP ("current paragraph" is first paragraph to be displayed)
                              .iSectP  = pointer to iSect describing section containing "current paragraph"

	         hi.prompt_repeatS   = T:  Nothing is printed by step 4; step 1 recomputes and displays "More help?" prompt. 

    Step 2:  ssu_$listen reads and processes the user's response to that "More help?" prompt.  
	    - It break's response line into one or more ssu_ requests.  
	    - Invokes each request (which is usually a help_ response routine).
	    - If user types an empty response line,  hi.prompt_repeatS = T  causes prior prompt to be redisplayed.

    Step 3:  Each help_responses_ routine can adjust hi.selected and hi.iPgh_print_range, 
	   or make no adjustments: these values select which paragraphs are to be displayed.

	   A response routine may also change:  
	     hi.display_limit:  can have one of the following four values.
			      DISPLAY_LIMIT_none         => display all paragraphs that fit on the video page.
			      DISPLAY_LIMIT_section	   => display only paragraphs of current section.
			      DISPLAY_LIMIT_unseen	   => display only unseen paragraphs.
			      DISPLAY_LIMIT_rest_unseen  => display all remaining unseen paragraphs.
             To display any paragraphs in step 4, a response routine must set:
	     hi.prompt_repeatS = F    => either the incoming hi.iPgh_print_range is displayed, 
				       or an adjusted hi.selected and/or hi.iPgh_print_range displayed.


	     When entering step 4:
	      If hi.iPgh_print_range  ^= null:    .startP and .endP delimit the exact set of paragraphs to display.
				 = null:  hi.selected values specify a new "current paragraph".
					help_listen_util_$set_iPgh_range is called to map that "current paragraph"
					 into a pair of hi.iPgh_print_range delimiter pointers.  
					 If hi.display_limit = DISPLAY_LIMIT_section, that print range is limited
					 to paragraphs of the current paragraph's section, from current pgh onward.

    Step 4:  If hi.prompt_repeatS ^= T, then display paragraphs of the hi.iPgh_print_range
	    - If hi.display_limit >= DISPLAY_LIMIT_unseen, then only unseen paragraphs in print range are displayed.

	   ssu_$listen calls help_listen_util_$print_iPgh_range to perform step 4.  After performing its work,
	   it returns back to ssu_$listen... which iterates again through LOOP.... starting at step 1.


   Code in help_'s display_block procedure enters the ssu_ LISTENER LOOP described above by:  
    - performing the part of step 1 that determines WHICH PARAGRAPHS TO PRINT first (w/o displaying a prompt)
      via a call to help_listen_util_$set_iPgh_range;
    - displaying a HEADER describing the info block, how many lines it contains, and how many will be printed first.
    - then calling the step 4 routine directly to PRINT those first PARAGRAPHS OF THE INFO BLOCK 
      via a call to help_listen_util_$print_iPgh_range; and finally 
    - calling ssu_$listen to start the LOOP at step 1.
/*											        *
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* ENTRY:  help_listen_util_$display_prompt					        */
	/*									        */
	/* REPLACES: ssu_ pre_request_line procedure.					        */
	/*									        */
	/* FUNCTION: use current location in info block (hi.iBlokP, hi.selected.iSectP, hi.selected.iPghP)*/
	/*	   to compute next hi.iPgh_print_range (range of paragraphs to be displayed next).      */
	/*           Then builds a prompt describing sections contained in the print range, and displays  */
	/*	   that "More help?" prompt.						        */
	/*									        */
	/*									        */
	/* ENTRY:  help_listen_util_$set_iPgh_print_range					        */
	/*									        */
	/* FUNCTION: alternate entrypoint that computes the next hi.iPgh_print_range values, but does not */
	/*	   display the prompt.  Called by help_ display_block to set range for first paragraphs */
	/* 	   displayed before the ssu_ request loop is entered; or called by our	        */
	/*           print_iPgh_range entry point to compute a new print range if user response to the    */
	/*	   "More help?" prompt selects a new section/paragraph to begin displaying.	        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

display_prompt:
     entry (AsciP);

/*dcl  AsciP ptr;					/* help_'s ssu_ subsystem sci_ptr		        */
  dcl  displayS bit(1) aligned;
     
     displayS = T;					/* prepare prompt strings for building new prompt.        */
     goto SET_DISPLAY_RANGE_COMMON;


set_iPgh_range:
     entry (AsciP);
     
     displayS = F;					/* setup for computing next hi.iPgh_print_range	        */
     goto SET_DISPLAY_RANGE_COMMON;
     

SET_DISPLAY_RANGE_COMMON:
     help_infoP = ssu_$get_info_ptr (AsciP);		/* Access help_'s shared data,		        */
     Phelp_args = hi.help_argsP;			/*  and help_$help_ caller's inputs.		        */
     iBlokP = hi.iBlokP;
     iSectP, iPghP = null();


/* -----------------------------------------------------------------
   Determine starting paragraph of display range.
   ----------------------------------------------------------------- */

  dcl  prompt (2: HELP_PROMPT_LINES_MAX) char(HELP_LINE_SIZE_MAX) var aligned;
						/* Array holding possible lines of the "prompt frame".    */
						/*  - First line of the frame is always a blank line.     */
     prompt(*) = "";				/*  - Initialize prompt line array.		        */


  dcl  first_unseen_pghP ptr,
      (unseen_pghs, unseen_pghs_earlier) fixed bin;

     first_unseen_pghP = null();			/* Initialize variables tested in debug_prompt.	        */
     unseen_pghs = 0;
     call debug_prompt("Ent");			/*  DB: state when $display_prompt is entered.	        */

     if  hi.display_limit = DISPLAY_LIMIT_unseen		/* If displaying only unseen paragraphs...	        */
      |  hi.display_limit = DISPLAY_LIMIT_rest_unseen  then 
UNSEEN_PARAGRAPHS_ONLY:
     do;
	do iPghP = iBlok.relatives.pghs.firstP		/*  - count unseen paragraphs within the block.	        */
	   repeat iPgh.sibs.blok.nextP while (iPghP ^= null() );
	     if  ^iPgh.seenS  then do;
		unseen_pghs = unseen_pghs + 1;
		if  first_unseen_pghP = null()  then
		     first_unseen_pghP = iPghP;
		end;
	     end;

	if  unseen_pghs <= 0  then			/* If no unseen pghs, move on to next info block.	        */
UNSEEN_PARAGRAPHS_NOT_FOUND:
  	do;
	     call debug_prompt ("uns0");		/*   DB: state if no unseen paragraphs found.	        */
	     iFileP = hi.iFileP;

	     if  hi.display_mode = DISPLAY_MODE_subroutine 
	      &  iFile.relatives.bloks.firstP ^= iFile.relatives.bloks.lastP  then 
SUBROUTINE_END_OF_BLOCK:
	     do;					/* For subroutine info_seg having several entrypoints...  */
		if  iBlokP = iFile.relatives.bloks.firstP  then do;
						/*  If looking at subroutine intro block...	        */
		     hi.iBlokP = iBlok.sib.nextP;	/*   - continue with display of first :Entry: block.      */
		     hi.selected = null();
		     call debug_prompt ("sInt");	/*   DB: subroutine intro => subr 1st ep block	        */
SUBROUTINE_ANOTHER_BLOCK:
		     iBlokP = hi.iBlokP;
		     hi.selected.iSectP = iBlok.relatives.sects.firstP;
		     hi.iPgh_print_range = null();
		     hi.display_limit = DISPLAY_LIMIT_section;
		     hi.prompt_repeatS = F;
		     goto hi.ANOTHER_BLOCK_LABEL;	/*   - non-local goto display_block's block switch code   */
		     end;
		
		else if  Dinfo_item.ep = ""  then do;	/*  If entered via subroutine intro block, user may be    */
						/*  hunting for a particular entrypoint.  If any unseen,  */
						/*   - continue with display of 1st unseen :Entry: block  */
		     do iBlokP = iFile.relatives.bloks.firstP
			repeat iBlok.sib.nextP  while (iBlokP ^= null() );
			if  ^iBlok.seenS  then do;
			     hi.iBlokP = iBlokP;
			     hi.selected = null();
			     call debug_prompt ("sEnt");
						/*   DB: subr intro ... => next unseen ep block	        */
			     goto SUBROUTINE_ANOTHER_BLOCK;
			     end;
			end;
		     end;
		end SUBROUTINE_END_OF_BLOCK;

	     goto hi.NEXT_INFO_LABEL;			/* Otherwise, we're done with this info block.	        */
	     end UNSEEN_PARAGRAPHS_NOT_FOUND;		/*  - non-local goto help_ NEXT_INFO label.	        */


	hi.selected.iPghP,  iPghP = first_unseen_pghP;	/* If unseen pghs found, prompt for first of these.       */
	hi.selected.iSectP, iSectP = iPgh.relatives.sectP;
	call debug_prompt("uns");			/*   DB: state if: unseen_only & unseen pghs found.       */
	end UNSEEN_PARAGRAPHS_ONLY;

     else do;					/* Not in an unseen state...			        */
	if  hi.selected.iPghP = null()  then do;	/*  - If no last-printed paragraph, start printing at ... */
	     if  hi.selected.iSectP ^= null()  then
		iSectP = hi.selected.iSectP;		/*     - "top" of selected section; OR		        */
	     else hi.selected.iSectP, iSectP = iBlok.relatives.sects.firstP;
						/*     - "top" of block			        */
	     iPghP = iSect.pghs.firstP;		/*  - Exam starts with 1st paragraph of selected section. */
	     end;

	else do;
	     iPghP = hi.selected.iPghP;		/*  - But if last-printed paragraph defined...	        */
	     if  iPgh.seenS  then			/*    and it has actually been seen...		        */
		iPghP = iPgh.sibs.blok.nextP;		/*     - start with successor paragraph...	        */

	     if  iPghP ^= null()  then		/*     - If more paragraphs in block...		        */
		hi.selected.iSectP, iSectP = iPgh.relatives.sectP;
						/*       it might be in another section chosen.	        */
	     end;
	call debug_prompt("^uns");			/*   DB: not unseen state, next pgh selected.	        */
	end;

     if  iPghP = null()  then do;			/* If positioned after last paragraph of info block...    */

	do iPghP = iBlok.relatives.pghs.firstP		/*  - count unseen paragraphs within the block.	        */
	   repeat iPgh.sibs.blok.nextP while (iPghP ^= null() );
	     if  ^iPgh.seenS  then do;
		unseen_pghs = unseen_pghs + 1;
		if  first_unseen_pghP = null()  then	/*  - remember location of first unseen pgh in block.     */
		     first_unseen_pghP = iPghP;
		end;
	     end;

	if  unseen_pghs <= 0  then do;		/* If none unseen?  Then move on to next info block.      */
	     call debug_prompt ("next");		/*   DB: state at end of block w/ no unseen pghs.	        */
	     iFileP = hi.iFileP;
	     if  hi.display_mode = DISPLAY_MODE_subroutine 
	      &  iFile.relatives.bloks.firstP ^= iFile.relatives.bloks.lastP  then 
						/* For subroutine info_seg having several blocks...       */
		goto SUBROUTINE_END_OF_BLOCK;		/*  - Check whether other entrypoints should be displayed */

	     goto hi.NEXT_INFO_LABEL;			/* Otherwise, we're done with this info seg.	        */
	     end;

	if  hi.display_limit = DISPLAY_LIMIT_rest_unseen  then
	     prompt(2) = END_OF_INFO;
	else do;
	     prompt(2) = END_OF_INFO;			/* Tell user last paragraph of info was displayed/skipped.*/
	     hi.display_limit = DISPLAY_LIMIT_unseen;	/* Limit output to unseen paragraphs.		        */
	     end;
	hi.clear_prompt_regionS = F;			/*  - don't clear prompt region after reaching End of Info*/
	iPghP = first_unseen_pghP;			/*  - ask user if unseen paragraphs should be printed.    */
	end;

     iSectP = iPgh.relatives.sectP;			/* Get section pointer for selected paragraph.	        */
     call debug_prompt("pmpt");			/*   DB: status after selecting next pgh to display       */

%page;
/* -----------------------------------------------------------------
   How many paragraphs can we fit into "info frame" of terminal page, 
   while still leaving room for a possible multi-line prompt string
   in the "prompt frame".

   GOAL: prompt for user's response line before terminal I/O Module's
         "more" handler interrupts help_ output.
   ----------------------------------------------------------------- */

  dcl (infoN,					/* Count of info paragraph lines in print range so far.   */
       cur_sectN,					/* Lines to be displayed from current section.	        */
       pI,					/* Index w/in multi-line prompt frame of current prompt   */
						/*  line being built; total prompt lines after prompt is  */
						/*   built.				        */
       part_linesN,					/* Count of lines in given part of paragraph print range. */
       promptN					/* Count of prompt lines being reserved at end of page.   */
						/*  These lines form the "prompt frame" reserved for the  */
						/*  next "More help?" prompt.			        */
       ) fixed bin;

  dcl (part_endP, part_startP) ptr;			/* Point to end/start paragraphs of those to be added     */
						/*  to print range.				        */
  dcl  last_pgh_sectP ptr;

  dcl  prompt_add char(HELP_LINE_SIZE_MAX) var;		/* Newest section title component to be added to prompt   */
						/*     SECTION-TITLE (LINE-COUNT)  &  ...	        */
						/* or  SECTION-TITLE (LINE-COUNT more)  & ...	        */

title:						/* quick procedure to normalize section titles.	        */
     proc() returns (char(71) var);
     
     if  iSectP ^= null()  then
	if  iSect.title.in_file ^= ""  then
	     return (iSect.title.in_file);
     return (INFO_SECTION_NO_TITLE_FABRICATION);
     end title;


  dcl (AMPERSAND	          	char( 5)  init( "  &  "                 		),
       ELLIPSIS			char( 4)  init( "... "				),
       END_OF_INFO            	char(14)  init( "End of info.  "			),
       LPAREN			char( 2)  init( " ("				),
       MORE_RPAREN            	char( 6)  init( " more)"				),
       MORE_HELP			char(14)  init( "  More help?  "			),
       NEWLINE_COUNT		fixed bin init( 1					),
       PARAGRAPH_UNSEEN		char(21)  init( "1 paragraph unseen.  "			),
       PARAGRAPHS_UNSEEN		char(21)  init( " paragraphs unseen.  "			),
       PRE_REST_PARAGRAPH_UNSEEN	char(29)  init( "1 earlier paragraph unseen.  "		),
       PRE_REST_PARAGRAPHS_UNSEEN	char(29)  init( " earlier paragraphs unseen.  "		),
       PERIOD			char( 1)  init( "."					),
       PERIOD_MORE_HELP		char(16)  init( ".  More help?  "			),
       RPAREN			char( 1)  init( ")"					)
       ) int static options(constant);

/* -----------------------------------------------------------------
   Set size of "prompt frame".
   ----------------------------------------------------------------- */
     if  ^displayS  then				/* Just figuring print range?  Don't let shortage of      */
	promptN = HELP_PROMPT_LINES_MAX;		/*  prompt line chars reduce count selected paragraphs.   */
     else if  help_args.max_Lpgh > HELP_PAGE_LENGTH_BIG  then
	promptN = HELP_PROMPT_LINES_MAX;		/* Set number of prompt lines reserved at end of page     */
     else if  help_args.max_Lpgh > HELP_PAGE_LENGTH_MID  then
	promptN = HELP_PROMPT_LINES_MID;		/*  based on page length.			        */
     else promptN = HELP_PROMPT_LINES_MIN;

     infoN = 0;					/* No lines of help text in range so far.	        */
     pI = lbound(prompt,1);				/* Set index to 1st non-blank prompt line.	        */


/* -----------------------------------------------------------------
   If in unseen_paragraphs_only mode  and  unseen paragraphs exist?
   ----------------------------------------------------------------- */
     if  unseen_pghs > 0  
      & (hi.display_limit = DISPLAY_LIMIT_unseen  |  hi.display_limit = DISPLAY_LIMIT_rest_unseen)  then do;
						/*  - looking at unseen paragraphs?		        */
	if  unseen_pghs > 1  then do;
	     prompt(pI) = prompt(pI) || ltrim(char(unseen_pghs)); 
	     if  hi.display_limit = DISPLAY_LIMIT_rest_unseen  then do;
		prompt(pI) = prompt(pI) || PRE_REST_PARAGRAPHS_UNSEEN;
		hi.display_limit = DISPLAY_LIMIT_unseen;
		end;
	     else prompt(pI) = prompt(pI) || PARAGRAPHS_UNSEEN;
	     end;
	else if  unseen_pghs = 1  then do;
	     prompt(pI) = prompt(pI) || PARAGRAPH_UNSEEN;
	     end;
	else if  hi.display_limit = DISPLAY_LIMIT_rest_unseen  then do;
	     prompt(pI) = prompt(pI) || PRE_REST_PARAGRAPH_UNSEEN;
	     hi.display_limit = DISPLAY_LIMIT_unseen;
	     end;
	else prompt(pI) = prompt(pI) || PARAGRAPH_UNSEEN;

	if  some_section_paragraphs_will_fit (promptN, infoN, CONSECUTIVE_UNSEEN_PARAGRAPHS_ONLY,
	     part_linesN, section_part, hi.iPgh_print_range.startP, hi.iPgh_print_range.endP)
						/* This internal proc uses iBlokP; usurps iSectP, iPghP.  */
						/*  - iPghP points to first paragraph to be printed in    */
						/*    paragraph range being constructed.	        */

	then do;					/* 1st paragraph(s) of print range do fit on page.        */
	     goto UNSEEN_TITLE (section_part);

UNSEEN_TITLE (START_OF_SECTION):
UNSEEN_TITLE (ALL_OF_SECTION):
	     prompt(pI) = prompt(pI) || title() || LPAREN || ltrim(char(part_linesN)) || RPAREN;
	     infoN = infoN + part_linesN;
	     goto END_PROMPT;			/*  - Entire section won't fit; end with this part        */

UNSEEN_TITLE (MIDDLE_OF_SECTION):
UNSEEN_TITLE (END_OF_SECTION):
	     prompt(pI) = prompt(pI) || title() || LPAREN || ltrim(char(part_linesN)) || MORE_RPAREN;
	     infoN = infoN + part_linesN;
	     goto END_PROMPT;			/*  - End of section won't fit; end with this part        */

	     end;

	else do;					/* 1st unseen paragraph won't fit on page.	        */
	     hi.iPgh_print_range.endP, iPghP = hi.iPgh_print_range.startP;
	     infoN = NEWLINE_COUNT + iPgh.line_count;	/*  - print it anyway.  Text will scroll off top of page. */
	     prompt(pI) = prompt(pI) || title() || LPAREN || ltrim(char(infoN)) || RPAREN;
	     goto END_PROMPT;			/*  - Such long paragraphs are NOT recommended!!	        */
	     end;
	end;

/* -----------------------------------------------------------------
   In every_paragraph mode...
   ----------------------------------------------------------------- */
     if  some_section_paragraphs_will_fit (promptN, infoN, ANY_PARAGRAPHS,
	part_linesN, section_part, hi.iPgh_print_range.startP, hi.iPgh_print_range.endP)
						/* This internal proc uses iBlokP; usurps iSectP, iPghP.  */
						/*  - iPghP points to first paragraph to be printed in    */
						/*    paragraph range being constructed.	        */

     then do;					/* 1st paragraph(s) of print range do fit on page.        */
	goto FIRST_TITLE (section_part);
	
FIRST_TITLE (START_OF_SECTION):
	prompt(pI) = title() || LPAREN || ltrim(char(part_linesN)) || RPAREN;
	infoN = infoN + part_linesN;
	goto END_PROMPT;				/*  - Entire section won't fit; end with this part        */

FIRST_TITLE (MIDDLE_OF_SECTION):
	prompt(pI) = title() || LPAREN || ltrim(char(part_linesN)) || MORE_RPAREN;
	infoN = infoN + part_linesN;
	goto END_PROMPT;				/*  - End of section won't fit; end with this part        */

FIRST_TITLE (END_OF_SECTION):
	prompt(pI) = title() || LPAREN || ltrim(char(part_linesN)) || MORE_RPAREN;
	infoN = infoN + part_linesN;
	if  hi.display_limit = DISPLAY_LIMIT_section  then
	     goto END_PROMPT;			/*  - End of section will fit.  Limit display?	        */
	else goto MORE_PGHS;

FIRST_TITLE (ALL_OF_SECTION):
	prompt(pI) = title() || LPAREN || ltrim(char(part_linesN)) || RPAREN;
	infoN = infoN + part_linesN;
	if  hi.display_limit = DISPLAY_LIMIT_section  then
	     goto END_PROMPT;			/*  - Entire section will fit.  Limit display?	        */
	else goto MORE_PGHS;
	end;

     else do;					/* 1st paragraph of print range won't fit on page!!!      */
	hi.iPgh_print_range.endP, iPghP = hi.iPgh_print_range.startP;
	infoN = iPgh.line_count + NEWLINE_COUNT;	/*  - print it anyway.  Text will scroll off top of page. */
	prompt(pI) = title() || LPAREN || ltrim(char(infoN)) || RPAREN;
	goto END_PROMPT;				/*  - Such long paragraphs are NOT recommended!!	        */
	end;
     
MORE_PGHS:					/* 1st paragraph of print range selected!  Will any more  */
     iPghP = hi.iPgh_print_range.endP;			/*  sections fit on page?			        */
     iPghP = iPgh.sibs.blok.nextP;
     if  iPghP = null()  then 
	goto END_PROMPT;
     iSectP = iPgh.relatives.sectP;
     
     if  some_section_paragraphs_will_fit (promptN, infoN, ANY_PARAGRAPHS,
           part_linesN, section_part, part_startP, part_endP)  then do;
	goto OTHER_TITLE (section_part);
	
OTHER_TITLE (START_OF_SECTION):			/*  - Entire section won't fit; end with this part        */
	prompt_add = title() || LPAREN || ltrim(char(part_linesN)) || RPAREN;
	goto TRY_TO_ADD_PROMPT;

OTHER_TITLE (MIDDLE_OF_SECTION):			/*  - End of section won't fit; end with this part        */
	prompt_add = title() || LPAREN || ltrim(char(part_linesN)) || MORE_RPAREN;
	goto TRY_TO_ADD_PROMPT;

OTHER_TITLE (END_OF_SECTION):				/*  - End of section will fit; check subsequent sections. */
	prompt_add = title() || LPAREN || ltrim(char(part_linesN)) || MORE_RPAREN;
	goto TRY_TO_ADD_PROMPT_AND_MORE_PGHS;

OTHER_TITLE (ALL_OF_SECTION):				/*  - Entire section will fit; check subsequent sections. */
	prompt_add = title() || LPAREN || ltrim(char(part_linesN)) || RPAREN;
	goto TRY_TO_ADD_PROMPT_AND_MORE_PGHS;

	end;
     else goto END_PROMPT;


TRY_TO_ADD_PROMPT_AND_MORE_PGHS:
     if  prompt_add_will_fit (promptN, prompt_add, prompt(*), pI)  then do;
          infoN = infoN + part_linesN;			/*  - New part fits into prompt lines.  Add paragraphs    */
	hi.iPgh_print_range.endP = part_endP;		/*    to end of print range.			        */
	end;
     goto MORE_PGHS;
     

TRY_TO_ADD_PROMPT:
     if  prompt_add_will_fit (promptN, prompt_add, prompt(*), pI)  then do;
	infoN = infoN + part_linesN;			/*  - New part fits into prompt lines.  Add paragraphs    */
	hi.iPgh_print_range.endP = part_endP;		/*    to end of print range.			        */
	end;

END_PROMPT:
     if  length(prompt(pI)) + length(PERIOD_MORE_HELP) + HELP_PROMPT_RESPONSE_MIN_SPACE > hi.terminal_lineL  then do;
	prompt(pI) = prompt(pI) || PERIOD;
	pI = pI + 1;
	prompt(pI) = MORE_HELP;
	end;
     else prompt(pI) = prompt(pI) || PERIOD_MORE_HELP;
     

FOUND_END_PARAGRAPH:
     hi.selected.iPghP  = hi.iPgh_print_range.startP;	/* Set hi.selected to starting pgh/section of print range */
     hi.selected.iSectP = hi.iPghP->iPgh.relatives.sectP;

     if  ^displayS  then do;				/* If just setting print range...		        */
	hi.header_Nlines_follow = infoN - NEWLINE_COUNT;	/*  - record count of lines to be displayed in header     */
						/*    before 1st paragraphs of block are printed.  All    */
						/*    this occurs before help_ request loop is entered.   */
	call debug_prompt ("ret");			/*   DB: state when $set_iPgh_range returns.	        */
	return;
	end;

/* -----------------------------------------------------------------
   Actually display the prompt.
   ----------------------------------------------------------------- */
DISPLAY_PROMPT:
     if  hi.video_iocbP ^= null()  then do;		/* If doing video output, get region holding this prompt. */
	call window_$get_cursor_position (hi.video_iocbP, hi.prompt_region.lineI, hi.prompt_region.colI, ignore_code);
	hi.prompt_region.colI = 1;
	hi.prompt_region.linesN = pI;
	hi.prompt_region.colsN = hi.terminal_lineL;
	hi.clear_prompt_regionS = F;
	end;

     call debug_prompt ("ret");			/*   DB: state when $display_prompt returns.	        */

     call newline(1);				/* Separate prompt from preceding output lines.	        */

     hi.print_inhibitS = F;				/* When printing prompt, remove any prior print-inhibit.  */
     do pI = lbound(prompt,1) to pI - 1;		/* Print all but last prompt line.		        */
	call ioa ("^a", prompt(pI));
	end;
     call ioa$nnl ("^va", length(prompt(pI)), prompt(pI));	/* Print last prompt line w/o trailing NL char.	        */
     hi.prompt_repeatS = T;				/*  - repeat prompt until some response clears this switch*/
     return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
%page;
prompt_add_will_fit:
	proc (ApromptN, Aprompt_add, Aprompt, ApI) returns (bit(1) aligned);
	
  dcl  ApromptN fixed bin;				/* Number of lines reserved in page for prompt.   (Input) */
  dcl  Aprompt_add char(*) var;			/* Prompt string to be added to the prompt.       (Input) */
  dcl  Aprompt (*) char (*) var;			/* Array of prompt lines being built.            (In/Out) */
  dcl  ApI fixed bin;				/* Index of current item being filled in prompt. (In/Out) */
	
	if  length(AMPERSAND) + length(Aprompt_add) > hi.terminal_lineL  then
	     Aprompt_add = before (Aprompt_add, LPAREN);	/* Truncate overlong prompt string.		        */
	if  length(AMPERSAND) + length(Aprompt_add) > hi.terminal_lineL  then	
	     Aprompt_add = substr (Aprompt_add, 1, hi.terminal_lineL - length(AMPERSAND) - length(ELLIPSIS) ) || ELLIPSIS;

	do ApI = ApI to ApromptN-1;			/* If filling early prompt lines...		        */
	     if  length(Aprompt(ApI)) + length(AMPERSAND) + length(Aprompt_add) +
	         length(PERIOD) <= hi.terminal_lineL  then do;
						/*  - If room for prompt at end of current prompt line,   */
		Aprompt(ApI) = Aprompt(ApI) || AMPERSAND || Aprompt_add;
		goto PROMPT_FITS;			/*    add prompt to end of current prompt line; but don't */
		end;				/*    add the trailing period yet.		        */
	     Aprompt(ApI+1) = "";			/*  - Else add prompt to beginning of new prompt line.    */
	     end;

						/* If filling last prompt line...		        */
	if  length(Aprompt(ApI)) + length(AMPERSAND) + length(Aprompt_add) + length(PERIOD_MORE_HELP) + 
	    HELP_PROMPT_RESPONSE_MIN_SPACE  <=  hi.terminal_lineL  then do;
	     Aprompt(ApI) = Aprompt(ApI) || AMPERSAND || Aprompt_add;
	     goto PROMPT_FITS;			/*  - Ensure room for ". More help?" plus user's response */
	     end;

	return (F);				/* New prompt won't fit anywhere in current prompt array. */

PROMPT_FITS:
	do ApI = ApI to lbound(Aprompt,1) by -1 while (Aprompt(ApI) = "");
	     end;					/* Adjust ApI to reflect only prompt lines that are set.  */
	return (T);

	end prompt_add_will_fit;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
%page;
  dcl (ANY_PARAGRAPHS                      init(F),	/* Selector for some_section_paragraphs_will_fit subr     */
       CONSECUTIVE_UNSEEN_PARAGRAPHS_ONLY  init(T)
       ) bit(1) aligned int static options(constant);

some_section_paragraphs_will_fit:
     	proc (ApromptN, AinfoN, Aselector, Apart_linesN, Apart_of_section, Apgh_start_partP, Apgh_end_partP) 
	returns (bit(1) aligned);

  dcl  ApromptN fixed bin;				/* Number of lines reserved in page for prompt.   (Input) */
  dcl  AinfoN fixed bin;				/* Count of lines in range prior to this call.    (Input) */
  dcl  Aselector bit(1) aligned;			/* =T: select only consecutive unseen paragraphs. (Input) */
  dcl  Apart_linesN fixed bin;			/* Count of lines in this part of range.         (Output) */
  dcl  Apart_of_section fixed bin (2);			/* Part of section designator.	         (Output) */
  dcl (Apgh_start_partP, Apgh_end_partP) ptr;		/* Point to 1st/last paragraphs of section that	        */
						/*  will fit in current page.                    (Output) */

	Apart_linesN     = 0;			/* Initialize return arguments.		        */
	Apgh_start_partP = iPghP;
	Apgh_end_partP   = null();
	Apart_of_section = MIDDLE_OF_SECTION;

	if  iPghP = null  then			/* ASSERT: should never be called with iPgh = null        */
	     return (F);

	if  iPghP = iSect.relatives.pghs.firstP  then	/* Check starting paragraph to see where it is in section */
	     Apart_of_section = START_OF_SECTION;

	do iPghP = iPghP				/* Will any paragraphs of this section fit?	        */
	    repeat iPgh.sibs.sect.nextP  while (iPghP ^= null() );
	     
	     if  Aselector = CONSECUTIVE_UNSEEN_PARAGRAPHS_ONLY  &  iPgh.seenS  then;
	     else if  AinfoN + Apart_linesN + NEWLINE_COUNT + iPgh.line_count + ApromptN < help_args.max_Lpgh  then do;
		Apart_linesN = Apart_linesN + NEWLINE_COUNT + iPgh.line_count;
		Apgh_end_partP = iPghP;		/*  - yes, this paragraph fits.		        */
		end;
	     else goto CHECK_ENDING_PARAGRAPH;		/*  - no, this paragraph does not fit.		        */
	     end;

CHECK_ENDING_PARAGRAPH:
	if  iPghP = null()  then do;			/* If remaining paragraphs of section fit...	        */
	     if  Apart_of_section = START_OF_SECTION  then
		Apart_of_section = ALL_OF_SECTION;
	     else Apart_of_section = END_OF_SECTION;	/* If last paragraph that fit ended section, tell user    */
	     return (T);
	     end;
	
	else if  iPghP = Apgh_start_partP		/* If starting paragraph is only paragraph that fits, but */
	      &  iPghP = Apgh_end_partP  then		/*   other paragraphs remain in this section.	        */
	     return (T);

	else if  iPghP = Apgh_start_partP  then		/* If starting paragraph won't fit, return no_fit.        */
	     return (F);				/*   Apgh_end_partP is null() if returning here.	        */
						/*   Caller must decide how to make this paragraph fit.   */
	return (T);				/* Paragraphs between start and end_part will fit.        */

     	end some_section_paragraphs_will_fit;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* ENTRY:  help_listen_util_$print_iPgh_range					        */
	/*									        */
	/* REPLACES: ssu_ post_request_line procedure.					        */
	/*									        */
	/* FUNCTION: use hi.iPgh_print_range to display the next set of paragraphs.  This range may have  */
	/*	   been adjusted by the user's response to previous "More help" prompt.  In such cases  */
	/*           the print range may need to be recomputed via help_listen_util_$set_iPgh_print_range.*/
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

print_iPgh_range:
     entry (AsciP);

     help_infoP = ssu_$get_info_ptr (AsciP);		/* Access help_'s shared data.		        */
     Phelp_args = hi.help_argsP;			/*  and help_$help_ caller's inputs.		        */
     if  hi.prompt_repeatS  then do;			/* Don't process print range if user's response had an    */
	hi.prompt_repeatS = F;			/*  error, or response printed something else.	        */
	return;					/*  Returning will repeat the prompt.		        */
	end;

  dcl (cur_lineI, cur_colI) fixed bin;

     if  hi.clear_prompt_regionS  then do;
	call window_$get_cursor_position (hi.video_iocbP, cur_lineI, cur_colI, ignore_code);	
	hi.prompt_region.lineI = cur_lineI - hi.prompt_region.linesN;
	call window_$clear_region (hi.video_iocbP, hi.prompt_region.lineI, hi.prompt_region.colI,
	     hi.prompt_region.linesN, hi.prompt_region.colsN, code);
	end;

     iBlokP = hi.iBlokP;

     if  hi.iPgh_print_range.startP = null()  then	/* If no print range set, set one from current "selected" */
	call set_iPgh_range (AsciP);

     if  hi.iPgh_print_range.startP = null()		/* ASSERT: .startP and .endP cannot be null.	        */
      |  hi.iPgh_print_range.endP   = null()  then do;
	call error (hi.sciP, 0, "[print_iPgh_range]  Invalid print range: startP = ^p, endP = ^p", hi.startP, hi.endP);
	goto hi.NEXT_INFO_LABEL;
	end;

     call debug_print();

     if  hi.display_limit = DISPLAY_LIMIT_rest_unseen  then
	goto PRINT_RANGE_REST_UNSEEN;

     iPghP = hi.iPgh_print_range.startP;		/* Print section title if paragraph is in mid-section.    */
     iSectP = iPgh.relatives.sectP;
     if  iPghP ^= iSect.relatives.pghs.firstP  then
     if  ^iSect.relatives.pghs.firstP->iPgh.seenS  then do; 
	call newline (1);
	call ioa ("^a:^/ ...", iSect.title.in_file);
	end;

     do iPghP = hi.iPgh_print_range.startP		/* Print the range of paragraphs.		        */
         repeat iPgh.sibs.blok.nextP  while (iPghP ^= null() );
	call newline (1);				/*  - blank line separates paragraphs from prior printing */

	do iLineP = iPgh.relatives.lines.firstP		/*  - print each paragraph line.		        */
	     repeat iLine.sibs.pgh.nextP  while (iLineP ^= null() );
	     call ioa ("^a", Line);
	     end;
	if  ^hi.print_inhibitS  then			/*  - mark paragraph as "seen by user".		        */
	     iPgh.seenS, iBlok.seenS = T;

	if  iPghP = hi.iPgh_print_range.endP  then	/*  - exit loop after printing last paragraph of range    */
	     goto PRINT_RANGE_ENDED;
	end;

PRINT_RANGE_ENDED:
     hi.prompt_repeatS = T;				/*  - Needed to prompt for new location and limit.        */

     call newline (1);				/* Blank line separates paragraph from what may come next */

     hi.selected.iPghP  = iPghP;			/* Last pgh printed becomes "selected" pgh.	        */
     if  iPghP ^= null()  then do;
	hi.selected.iSectP, iSectP = iPgh.relatives.sectP;

	if  hi.display_limit = DISPLAY_LIMIT_section  then
	if  iPghP = iSect.relatives.pghs.lastP  then
	     hi.display_limit = DISPLAY_LIMIT_none;	/*  - Turn off any  "paragraphs of section" only limit.   */
	end;
     else do;					/* Have reached final paragraph in block.	        */
	hi.selected.iSectP = null();
	hi.display_limit = DISPLAY_LIMIT_unseen;	/*  - Check for unseen paragraphs.		        */
	end;

     hi.iPgh_print_range = null();			/* Clear the print range.			        */
     return;
%page;

PRINT_RANGE_REST_UNSEEN:
     do iPghP = hi.iPgh_print_range.startP		/* Find first unseen paragraph in given print range.      */
         repeat iPgh.sibs.blok.nextP  while (iPghP ^= null() );
	if  ^iPgh.seenS  then
	     goto PRINT_FIRST_UNSEEN_OF_RANGE;
	
	if  iPghP = hi.iPgh_print_range.endP  then	/*  - exit loop if reached last paragraph of range        */
	     goto PRINT_RANGE_ENDED;
	end;
     goto PRINT_RANGE_ENDED;
     
PRINT_FIRST_UNSEEN_OF_RANGE:
     call newline (1);				/* Inform user these are remaining unseen paragraphs.     */
     call ioa ("Remaining unseen paragraphs ----");
     
UNSEEN_SECTIONS:
     do iSectP = iPgh.relatives.sectP			/* Print each chunk of consecutive unseen paragraphs      */
	repeat iSect.sib.nextP  while (iSectP ^= null()); /*  within a section.			        */

	if  iPghP = null()  then			/* For 1st unseen section, iPghP was set above.  For      */
	     iPghP = iSect.relatives.pghs.firstP;	/*  other possibly-unseen sections, set it to 1st pgh     */

	do iPghP = iPghP				/*  - Find first unseen paragraph in this section.        */
	    repeat iPgh.sibs.sect.nextP  while (iPghP ^= null() );
	     if  ^iPgh.seenS  then
		goto PRINT_FIRST_UNSEEN_OF_SECTION;
	
	     if  iPghP = hi.iPgh_print_range.endP  then	/*  - exit loop if reached last paragraph of range        */
		goto PRINT_RANGE_ENDED;
	     end;
	goto NO_MORE_UNSEEN_PARAGRAPHS_IN_SECTION;
	
	
PRINT_FIRST_UNSEEN_OF_SECTION:
	call newline (1);
	if  iPghP ^= iSect.relatives.pghs.firstP  then
	     call ioa ("^a:^/ ...", iSect.title.in_file);

PRINT_NEXT_CONSECUTIVE_UNSEEN_OF_SECTION:
	do iLineP = iPgh.relatives.lines.firstP		/*  - print each paragraph line.		        */
	     repeat iLine.sibs.pgh.nextP  while (iLineP ^= null() );
	     call ioa ("^a", Line);
	     end;
	if  ^hi.print_inhibitS  then			/*  - mark paragraph as "seen by user".		        */
	     iPgh.seenS, iBlok.seenS = T;

	if  iPghP = hi.iPgh_print_range.endP  then	/*  - does this paragraph end print range?	        */
	     goto PRINT_RANGE_ENDED;

	iPghP = iPgh.sibs.sect.nextP;			/*  - examine next paragraph of section.	        */
	if  iPghP ^= null()  then do;
	     if  ^iPgh.seenS  then do;		/*     - if unseen, print it as a consecutive paragraph   */
		call newline (1);
		goto PRINT_NEXT_CONSECUTIVE_UNSEEN_OF_SECTION;
		end;
	     else call ioa ("^/ ...");		/*     - let user know we skipped 1+ seen paragraphs      */

	     do iPghP = iPghP			/*  - Find next unseen paragraph in this section.        */
	         repeat iPgh.sibs.sect.nextP  while (iPghP ^= null() );
		if  ^iPgh.seenS  then
		     goto PRINT_NEXT_NONCONSECUTIVE_UNSEEN_OF_SECTION;
	
		if  iPghP = hi.iPgh_print_range.endP  then
		     goto PRINT_RANGE_ENDED;		/*  - exit loop if reached last paragraph of range        */
		end;
	     goto NO_MORE_UNSEEN_PARAGRAPHS_IN_SECTION;
	     
PRINT_NEXT_NONCONSECUTIVE_UNSEEN_OF_SECTION:
	     call ioa (" ...^/");
	     goto PRINT_NEXT_CONSECUTIVE_UNSEEN_OF_SECTION;

	     end;

NO_MORE_UNSEEN_PARAGRAPHS_IN_SECTION:
	end UNSEEN_SECTIONS;
     

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
%page;
debug_prompt:
     proc(location);

  dcl  location char(4) var;     

  dcl  sect_title char(75) var;
  dcl  db_iSectP ptr;

     if  help_args.pad2(6) = 1  then do;
	call ioa ("-- ^va ^[display: ^;set:     ^] limit: ^[none   ^;section^;unseen ^;restUns^]" 
                 || "^[  unseen_pghs: ^2d^;^s^17x^]^[   prompt_clear^]",
	     maxlength(location), location, displayS, hi.display_limit+1, 
	     unseen_pghs > 0, unseen_pghs, hi.clear_prompt_regionS);

	if  hi.selected.iSectP = null()  &  hi.selected.iPghP = null()  then 
	     call ioa ("   selected blok: ^p ^a", hi.iBlokP, hi.iBlokP->iBlok.names.nm(1) );

	else do;
	     if  hi.selected.iSectP = null()  then
		sect_title = "";
	     else sect_title = hi.selected.iSectP->iSect.title.in_file;
	     call ioa ("   selected pgh:  ^p ^30t sect: ^p ^a", hi.selected.iPghP, hi.selected.iSectP, sect_title);
	     end;

	if  first_unseen_pghP ^= null()  then do;
	     db_iSectP = first_unseen_pghP->iPgh.relatives.sectP;
	     sect_title = db_iSectP->iSect.title.in_file;
	     if  sect_title = ""  then
		sect_title = INFO_SECTION_NO_TITLE_FABRICATION;
	     call ioa (" 1st unseen pgh:  ^p ^30t sect: ^p ^a", first_unseen_pghP, db_iSectP, sect_title);
	     end;

	if  iSectP ^= null()  |  iPghP ^= null()  then do;
	     if  iSectP = null()  then
		sect_title = "";
	     else sect_title = iSect.title.in_file;
	     call ioa ("            pgh:  ^p ^30t sect: ^p ^a", iPghP, iSectP, sect_title);
	     end;

	if  location = "ret"  then do;
	     db_iSectP = hi.iPgh_print_range.startP->iPgh.relatives.sectP;
	     sect_title = db_iSectP->iSect.title.in_file;
	     if  sect_title = ""  then
		sect_title = INFO_SECTION_NO_TITLE_FABRICATION;
	     call ioa ("    range start:  ^p ^30t sect: ^p ^a", hi.iPgh_print_range.startP, db_iSectP, sect_title);

	     db_iSectP = hi.iPgh_print_range.endP->iPgh.relatives.sectP;
	     sect_title = db_iSectP->iSect.title.in_file;
	     if  sect_title = ""  then
		sect_title = INFO_SECTION_NO_TITLE_FABRICATION;
	     call ioa ("    range   end:  ^p ^30t sect: ^p ^a", hi.iPgh_print_range.endP,   db_iSectP, sect_title);
	     end;
	end;
     end debug_prompt;

debug_print:
     proc();
     
     if  help_args.pad2(6) = 1  then do;
	call ioa ("-- print   limit: ^[none   ^;section^;unseen ^;restUns^]^[   prompt_repeat^]^[   prompt_clear^]",
	     hi.display_limit+1, hi.prompt_repeatS, hi.clear_prompt_regionS);
	call ioa ("   range   startP: ^p   endP: ^p", hi.iPgh_print_range.startP, hi.iPgh_print_range.endP);
	end;
     end debug_print;
%page;
%include "_help_shared_data_";
%page;
%include help_args_;
%page;
%include help_cis_args_;
%page;
%include info_seg_dcls_;

     end help_listen_util_;
