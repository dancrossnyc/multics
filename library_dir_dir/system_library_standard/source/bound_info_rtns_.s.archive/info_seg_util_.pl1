
	
/****^  HISTORY COMMENTS:
  1) change(2020-10-25,GDixon), approve(2021-02-23,MCR10089),
     audit(2021-03-31,Swenson), install(2021-03-31,MR12.6g-0053):
      A) Initial version created for new verify_info command.
      B) Change $get_section_list to recognize list item continuation lines
         that begin with several space characters.
                                                   END HISTORY COMMENTS */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* SUBROUTINE:  info_seg_util_						        */
	/*									        */
	/* FUNCTIONS:  A set of utility routines called mainly by info_seg_verify_, but also used by      */
	/* info_seg_error_ and info_seg_parse_.						        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

info_seg_util_:
     proc ();
     
  dcl  ioa_ entry() options(variable);

  dcl (COMMA	   char (1) init (","),		/*  comma					        */
       HT_SP           char (2) init ("	 ")		/*  HT SP					        */
       ) int static options(constant);

  dcl  hcs_$chname_seg entry (ptr, char(*), char(*), fixed bin(35));

  dcl  info_seg_allocate_$List entry (ptr, ptr) returns(ptr);
  dcl  info_seg_allocate_$Operation_List entry (ptr, char(*) var, ptr) returns(ptr);

  dcl (error_table_$namedup,
       error_table_$noentry,
       error_table_$segnamedup
       ) fixed bin(35) external static;

  dcl (hbound, index, lbound, length, max, maxlength, null) builtin;

%page;
%include info_seg_dcls_;
%page;
/* -----------------------------------------------------------------
   ENTRY:  info_seg_util_$count_block_lines

   FUNCTION:  return count of iLine structures attached to given 
	    iBlok structure.
   -----------------------------------------------------------------  */

count_block_lines:
     entry (AiBlokP) returns(fixed bin);
     
  dcl  AiBlokP ptr;					/* Points to block whose line count is to be returned.    */
     
  dcl  line_count fixed bin init(0);

     do iLineP = AiBlokP->iBlok.lines.firstP
	repeat iLine.blok.nextP  while (iLineP ^= null() );
	line_count = line_count + 1;
	end;
     return (line_count);


/* -----------------------------------------------------------------
   ENTRY:  info_seg_util_$count_file_blocks

   FUNCTION:  return array of counts for each iBlok.divider type
	    attached to the given iFile structure.
   -----------------------------------------------------------------  */

count_file_blocks:
     entry (AiFileP, AiBloksNP);

  dcl  AiFileP ptr;					/* Points to info seg iFile descriptor.		        */
  dcl  AiBloksNP ptr;				/* Points to iBloksN structure provided by caller.        */

  dcl 1 iBN aligned like iBloksN based(AiBloksNP);

  dcl  iBloksN_arr (-1:hbound(iBlok_token,1)) fixed bin aligned based( addr(iBN.counts) );
						/* Array holding counts of block divider types.	        */
						/*  iBloksN_arr(-1) is a count of all blocks.	        */
						/*  iBloksN_arr(I) are counts, where I is an	        */
						/*    iBlok_divider_XXX value. */
     if iBN.version ^= iBloksN_version_2 then
	return;
     
     iBloksN_arr(*) = 0;				/* Zero elements of the array.		        */

     do iBlokP = AiFileP->iFile.bloks.firstP 
          repeat iBlok.nextP	while (iBlokP ^= null() );

	iBloksN_arr(-1) = iBloksN_arr(-1) + 1;
	iBloksN_arr(iBlok.divider) = iBloksN_arr(iBlok.divider) + 1;
	end;
     return;


/* -----------------------------------------------------------------
   ENTRY:  info_seg_util_$count_file_lines

   FUNCTION:  return iLine.line_in_file for final iLine structure
	    attached to a given iFile structure.  Since this value
	    is incremented by 1 as each line of the file is 
	    represented as a iLine structure, this value is equivalent
	    to a count of lines in the file (info segment).
   -----------------------------------------------------------------  */

count_file_lines:
     entry (AiFileP) returns(fixed bin);
     
/*dcl  AiFileP ptr;					/* Points to info seg iFile descriptor.		        */

     if  AiFileP->iFile.lines.lastP = null()  then
	return (0);
     else return (AiFileP->iFile.lines.lastP->iLine.line_in_file);

/* -----------------------------------------------------------------
   ENTRY:  info_seg_util_$count_files

   FUNCTION:  count iFile structures attached to info_seg_data structure.
   -----------------------------------------------------------------  */

count_files:
     entry (AisdP) returns(fixed bin);
     
  dcl  AisdP ptr;					/* Points to info_seg_data structure.		        */
  dcl 1 isd aligned like info_seg_data based (AisdP);

  dcl  file_count fixed bin;
     
     file_count = 0;
     do iFileP = isd.files.firstP
	repeat iFile.sib.nextP  while (iFileP ^= null() );
	file_count = file_count + 1;
	end;
     return (file_count);


/* -----------------------------------------------------------------
   ENTRY:  info_seg_util_$count_section_lines

   FUNCTION:  return count of lines in the iLine.sibs.sect thread.
   -----------------------------------------------------------------  */

count_section_lines:
     entry (AiSectP) returns(fixed bin);
     
/*dcl  AiSectP ptr;					/* Points to an info seg iSect descriptor.	        */

     line_count = 0;				/* Count lines in the section.		        */

     iSectP = AiSectP;
     if  iSectP = null()  then
	return (line_count);
     
     do iLineP = iSect.relatives.lines.firstP
	repeat iLine.sibs.sect.nextP  while (iLineP ^= null() );
	line_count = line_count + 1;
	end;
     return (line_count);
%page;
/* -----------------------------------------------------------------
   ENTRY:  info_seg_util_$get_section_list

   FUNCTION:   For Command/AF/Request/AR/IO_Module/GeneralInfo/SubsystemTopic 
	     blocks that define Arguments, Control_args, or "List of ..." items, 
	     construct a list of those item names.  This  iList is a 2-dimensional
	     array of items (primary index), with up to 4 item names recorded 
	     for each item (second index) tied to the iSect structure.

	     For "List of operations" and "List of control operations" sections
	     (or "List of requests" in a SubsystemTopic block of a multi-block info seg),
	     convert this iList to an Operation_List structure which is tied 
	     to the containing iBlok structure, as well as to iBlok's describing
	     each operation in the Operation_List.  info_seg_verify_ does elaborate
	     checking of Operation_Lists against blocks documenting those operations.

   Definition: 
     section format:	sections to be examined for list items
			are all formatted like a Control arguments:
			section.  Section lines are examined to 
			identify list items, which are recorded in
			an iList structure.


SECTION TITLE:				< Section must have a title.
   (optional introductory text)
ITEM_NAMEa				< List item names begin in column 1 of their line.
   (description of ITEMa)
ITEM_NAMEb, SHORT_NAMEb			< Up to 4 item names can appear in comma-separated list
   (description of ITEMb)
ITEM_NAMEc, SHORT_NAMEc,			< Comma-separated list can span two lines if 1st line ends w/ comma.
SHT_NAMEc, SH_NAMEc
   (description of ITEMc)

			If the section is "List of operations:", then the 
			(optional introductory text) should be present, and 
			should explain to user how to invoke operation-specific
			help segments describing each operation.  An example is
			shown below.

			verify_info could check for an introductory text line containing: 
			    help SHORT_COMMAND_NAME.OPERATION
			where SHORT_COMMAND_NAME is the shortest name on that
			command/request block, which must be defined via an 
			:Info: divider.

:Info: history_comment: hcom:  1988-03-10  history_comment, hcom
  ...


List of operations:
   Information about each history comment operation may be obtained
   by typing: help hcom.OPERATION
add
   adds a new history comment to a source program.
add_field, af
   add missing fields to an existing history comment.
  ...

   ----------------------------------------------------------------- */

get_section_list:					/* Every block with paragraphs has 1 or more sections.    */
     entry (AisdP, AiSectP);

/*dcl  AisdP ptr;					/* Points to info_seg_data structure (for allocations)    */
  dcl  AiSectP ptr;					/* Points to iSect for section containing the list.       */

     iSectP = AiSectP;				/* Access iSect structure and its parent structures.      */
     iBlokP = iSect.relatives.blokP;
     iFileP = iBlok.relatives.fileP;

GET_SPACE_FOR_iList_:				/* The iList_ structure declared below is very large.     */
  begin;						/*  Avoid large stack frames for other entrypoints in     */
						/*  this procedure.				        */

  dcl  item_line char(200) var;			/* Variables used for scanning section for list items     */
  dcl  item_line_continuedS bit(1) aligned;
  dcl  item_line_def_blankN fixed bin;
  dcl (itemI, nmI, nmI_minlength) fixed bin;
  dcl  token char(LENGTH_iList_item_name+8) var,
       tokenL fixed bin;

  dcl 1 iList_ aligned like iList;			/* Use a large automatic iList structure to capture list  */
						/*  items.  Later, they are stored in an exact-sized list.*/

     iList_.content.ID = iListID;			/* Initialize the automatic iList structure for new list  */
     iList_.content.L  = 0;				/*  (most of .content substructure is not used)	        */
     iList_.content.P  = null();
     iList_.parentSectP = addr(iSect);			/* Set iList.parentSectP to address of current section    */

     iList_.N, itemI = 0;				/* List starts out with empty item array.	        */
						/*   The automatic iList can hold up to 200 entries.      */

     item_line_continuedS = F;			/* Each list item's names assumed to appear on 1 line.    */
						/*   If 1st line ends with COMMA, 2nd line continues names*/
LIST_LINES:
     do iLineP = iSect.lines.firstP->iLine.sect.nextP
	repeat iLine.sect.nextP  while (iLineP ^= null() );

	if  verify(Line, HT_SP) = 0  then do;		/* Skip zero-length and all-blank lines.	        */
	     item_line_continuedS = F;		/*  - empty line ends possible continuation of item names */
	     goto COUNT_BLANK_DEF_LINE;
	     end;
	if  length(Line) <= length(INFO_LINE_INDENT)  |  item_line_continuedS  then
	     goto LIST_ITEM_LINE;			/* Short item name.				        */
	if  substr(Line, 1, length(INFO_LINE_INDENT)) = INFO_LINE_INDENT  then do;
	     item_line_continuedS = F;		/*  - definition line ends possible continuation of names */
	     goto COUNT_DEF_LINE;
	     end;

LIST_ITEM_LINE:
	if  ^item_line_continuedS  then do;		/* Start a new item in the list.		        */
	     itemI = itemI + 1;
	     if  itemI = dimension(iList_.items,1)  then do;
 		call ssu_$print_message (isd.sciP, 0, "iList_.items array overflow" ||
		     "^/^-FILE:  ^a>^a^/^-BLOK:  ^a^/^-SECT:  ^a",
		     iFile.dir, iFile.ent, iSect.relatives.blokP->iBlok.names.nm(1), iSect.title.in_file);
		goto NO_MORE_ITEMS;
		end;
	     iList_.N = itemI;
	     iList_.items(itemI).nmN, nmI = 0;
	     iList_.items(itemI).nameP = null();
	     iList_.items(itemI).defEndP  = null();
	     iList_.items(itemI).nm(*) = "";
	     item_line_def_blankN = 0;
	     end;
	item_line_continuedS = F;			/* Reset continued-item flag.			        */
						/*  - In general, one item can span 2 consecutive lines.  */
						/*    This code allows continuation until name array full */

	item_line = ltrim(Line, HT_SP);		/* Copy current section line into item_line string        */

ITEM_NAMES:
	do while (T);				/* Scan item_line looking for item names.	        */

	     tokenL = search(item_line, COMMA);		/*  - Look for end of next token.		        */
					
	     if  tokenL > 1  then 
		token = rtrim( substr(item_line, 1, tokenL-1) );
	     else token = rtrim(item_line);		/*  - No word break found?  Remainder of line is a name   */

	     if  length(token) = 0  then		/*  - But if no more tokens, then exit inner loop.        */
		goto NEXT_LIST_LINE;

	     nmI = nmI + 1;				/*  - Setup to add next name to current item.	        */
	     if  nmI > dimension(iList_.items.nm, 2)  then
		goto NEXT_LIST_LINE;		/*     - Stop if list item name array is full.	        */

	     if  nmI = 1  then
		iList_.items(itemI).nameP = iLineP;	/*     - Item names begin on this line.		        */
	     iList_.items(itemI).defEndP = iLineP;	/*     - Item names continue through this line.	        */

	     iList_.items(itemI).nmN = nmI;
	     iList_.items(itemI).nm(nmI) = token;	/*  - Save word for future reference		        */

	     item_line = after(item_line, token);	/*  - Remove token from item_line		        */
	     item_line = ltrim(item_line);
	     if  index(item_line, COMMA) = 1  &  
	         verify(item_line, INFO_LIST_WORD_BREAK) = 0  then do;
		item_line_continuedS = T;		/*  - Line ends with comma:			        */
		goto NEXT_LIST_LINE;		/*     - Item names may continue on next line.	        */
		end;
	     item_line = ltrim(item_line, INFO_LIST_WORD_BREAK);

	     end ITEM_NAMES;

COUNT_BLANK_DEF_LINE:				/* Count 1st blank definition line (line between pghs)    */
	if  itemI > 0  then
	     item_line_def_blankN = item_line_def_blankN + 1;
	goto NEXT_LIST_LINE;

COUNT_DEF_LINE:					/* Count non-blank definition line.		        */
	if  itemI > 0  then
	     iList_.items(itemI).defEndP = iLineP;	/*     - Item definition continues through this line.     */
	item_line_def_blankN = 0;

NEXT_LIST_LINE:
	end LIST_LINES;
     
NO_MORE_ITEMS:	
     if  iList_.N > 0  then				/* If any items were found, copy iLine into a List or     */
LIST_CHECK:					/*   Operation_List sized  to hold just the found items.  */
     do;

  dcl  case fixed bin;				/* Operation_List case for this block kind/section type   */
  dcl  opNameI fixed bin;
  dcl  testResultS bit(1) aligned;

	case = case_for_Operation_List (iBlok.kind, iSect.type);

	if  case = 0  then				/* Not an Operation_List candidate...		        */
	     ListP, iSect.relatives.listP = info_seg_allocate_$List (addr(isd), addr(iList_) );


	else if  case > 0   &			/* "List of operations" or "List of control operations"   */
						/*                      or "List of requests"	        */
	    iBlok.divider = iBlok_divider_Info     &	/*     Tying this to :Info: blok names ensures blok has   */
	    dim(Blok_names,1) > 0  then		/*     an :Info: divider.			        */
LIST_OF_OPERATIONS:
	do;
	     nmI_minlength = dimension(Blok_names,1);	/* Get shortest name on iBlok.		        */
	     do nmI = nmI_minlength-1 to 1 by -1;
		if  length(Blok_names(nmI)) < length(Blok_names(nmI_minlength))  then
		     nmI_minlength = nmI;
		end;
						/* Allocate Operation_List structure.		        */
	     Operation_ListP = info_seg_allocate_$Operation_List (
		addr(isd), Blok_names(nmI_minlength),  addr(iList_) );
	     					/*  - sets iList.blok_name to shortest name on the block. */

	     if  case = 3  then do;			/*  - assign Operation_List to iBlok, marking block       */
		iBlok.relatives.multi_control_listP = Operation_ListP;
		iBlok.syntax.multi_controlsS = T;	/*    as containing a "List of control operations" sect   */
		end;
	     else if  case = 4  then do;
		iBlok.relatives.multi_operation_listP = Operation_ListP;
		iBlok.syntax.request_summaryS = T;	/*    as containing a "List of requests" section	        */
		end;
	     else do;				/* case 1 or case 2 ...			        */
						/*  - assign this Operation_List to iBlok, marking block  */
		iBlok.relatives.multi_operation_listP = Operation_ListP;
		iBlok.syntax.multi_operationsS = T;	/*    as containing a "List of operations" section        */
		end;

	     do Operation_ListI = lbound(Operation_List.items,1)
	                       to hbound(Operation_List.items,1);
		if  case = 2  then			/* For IO_Module operations: open/close/detach, the       */
		     testResultS = all_unique( operation_names(*) )  &  all_iox_( operation_names(*) );
						/*  - detach, detach_iocb  name lengths don't descend.    */
		else testResultS = all_unique( operation_names(*) )  &  descending_lengths( operation_names(*) );

		if  ^testResultS  then do;
		     iSect.list_of_ops_bad_namesS = T;
		     goto END_LIST_CHECK;
		     end;
		end;

  dcl 1 iN300 aligned like iName300;

	     iN300.N = 0;				/* Make sure all item names in Operation_List are unique  */
	     do Operation_ListI = lbound(Operation_List.items,1) 
			   to hbound(Operation_List.items,1);
		do opNameI = lbound(operation_names,1) to hbound(operation_names,1);
		     iN300.N = iN300.N + 1;
		     if  length(operation_names(opNameI)) > maxlength(iN300.nm(1))  then do;
			iSect.list_of_ops_long_nameS = T;
			goto END_LIST_CHECK;
			end;
		     iN300.nm(iN300.N) = operation_names(opNameI);
		     end;
		end;
	     NamesP = addr(iN300);
	     if  ^all_unique( Names.nm(*) )  then
		iSect.list_of_ops_nonunique_namesS = T;

	     end LIST_OF_OPERATIONS;

						/* For non-operation lists, save exact-sized List	in iSect*/
	end LIST_CHECK;

END_LIST_CHECK:
     return;



case_for_Operation_List:
	proc (AiBlok_kind, AiSect_type) returns (fixed bin);
	
  dcl  AiBlok_kind fixed bin;
  dcl  AiSect_type fixed bin;

	if       AiSect_type = iSect_LIST_OF_REQUESTS  then
	     if  AiBlok_kind = iBlok_kind_SUBSYSTEM_SUMMARY  then
	          return (4);			/* CASE 4: "List of requests" in Subsystem_Summary        */
	     else return (0);			/* CASE 0: Not an Operation_List case.		        */
	else if  AiSect_type = iSect_LIST_OF_OPERATIONS  then	
	     if  AiBlok_kind = iBlok_kind_IO_MODULE  then
	          return (2);			/* CASE 2: "List of operations" in I/O Module	        */
	     else return (1);			/* CASE 1: "List of operations" in Cmd/AF/Req/AR	        */
	else if  AiSect_type = iSect_LIST_OF_CONTROL_OPERATIONS  then
	     return (3);				/* CASE 3: "List of control operations" in I/O Module     */
	else return (0);				/* CASE 0: Not an Operation_List case.		        */

	end case_for_Operation_List;

  end GET_SPACE_FOR_iList_;

%page;
/* --------------------------------------------------------------------------------
   ENTRY: info_seg_util_$identify_per_operation_blocks

   FUNCTION: Having found a multi-block info segment containing a block describing
	   a multi-operation command/request/IO_MODULE (iBlok.syntax.multi_operationsS = T),
	   identify each related block in that segment describing an individual operation by
	   setting: its iBlok.syntax.is_operationS = T; 
		  its iBlok.relatives.multi_operation_listP = Operation_ListP;
	   (Both multi-operation block and each per-operation block share the same 
	    list of operations array.)

   Requirements for an :Info: block documenting one operation: 
	       Does AiBlokP describe a command/request/IO_MODULE that performs
	          multiple operations?
	       Look for other bloks with header that: 
				   has no commas;
				   consists of 3 words: SHORT_COMMAND_NAME LONG_OPERATION_NAME operation
					          or: SHORT_REQUEST_NAME LONG_OPERATION_NAME operation
					          or: IO_MODULE_NAME LONG_OPERATION_NAME operation


   ENTRY: info_seg_util_$identify_per_control_blocks

   Function: Having found a multi-block info segment containing a block describing
	   a multi-control IO_Module (iBlok.syntax.multi_controlsS = T),
	   identify each block in that segment describing an individual control order by
	   setting: its iBlok.syntax.is_controlS = T; 
		  its iBlok.relatives.multi_control_listP = Operation_ListP;
	   (Both the multi-controls block and each per-control block will share the same
	    list of control operations array implemented in that IO_Module.

   Requirements for an :Info: block documenting one control order: 
	       Does some AiBlokP block claim to perform multiple control operations?
	       Look for other bloks with header that: 
				   has no commas;
				   consists of 3 words: IO_MODULE_NAME LONG_CONTROL_NAME operation


   ENTRY: info_seg_util_$identify_per_request_blocks

   FUNCTION: Having found a multi-block info segment containing a Subsystem_Summary block 
	   describing a list of subsystem operations (iBlok.syntax.request_summaryS = T),
	   identify each block in that segment describing an individual requests by
	   setting: its iBlok.syntax.is_requestS = T;
		  its iBlok.relatives.multi_operation_listP = Operation_ListP.
	   (Both request-summary block and each per-request block share the same
	    list of operations array performed by that subsystem.)

   Requirements for an :Info: block documenting one operation: 
	       Does AiBlokP describes a Subsystem_Summary block?
	       Look for other bloks with header that: 
				   has commas;
				   consists of Operation_List.array(Operation_ListI).operation_names

   NOTE:  These subroutines may be called before some of the operation-documenting blocks
          have been parsed for paragraphs and sections.  So code below may not depend
	upon references to section-related data other than for sections in the
	multi-operation/multi-control block (AiBlokP points to that block).
   -------------------------------------------------------------------------------- */
%page;
identify_per_operation_blocks:
     entry (AiBlokP);
     
/*dcl  AiBlokP ptr;					/* Points to multi-operation block defining the 	        */
						/*  List of operations  section, and its associated       */
						/*  operation name array.			        */
  dcl  case fixed bin;				/* Operation_List case for multi-op/request list usage.   */

     iBlokP = AiBlokP;

     if  ^iBlok.syntax.multi_operationsS  |  iBlok.relatives.multi_operation_listP = null()  then
	return;
     case = 1;					/* CASE 1: "List of operations"		        */
     Operation_ListP = iBlok.relatives.multi_operation_listP;
						/* Reference the "List of operations" array of items.     */
     goto IDENTIFY_COMMON;
     

identify_per_control_blocks:
     entry (AiBlokP);
     
/*dcl  AiBlokP ptr;					/* Points to multi-control block defining the 	        */
						/*  List of control operations  section, and its          */
						/*  associated operation name array.		        */
     iBlokP = AiBlokP;

     if  ^iBlok.syntax.multi_controlsS  |  iBlok.relatives.multi_control_listP = null()  then
	return;
     case = 2;					/* CASE 2: "List of control operations"		        */
     Operation_ListP = iBlok.relatives.multi_control_listP; /* Reference the "List of control operations" items.      */
     goto IDENTIFY_COMMON;
     

identify_per_request_blocks:
     entry (AiBlokP);
     
/*dcl  AiBlokP ptr;					/* Points to Subsystem_Summary block defining the	        */
						/*  List of requests  section, and its associated	        */
						/*  operation name array.			        */
  dcl  opNameI fixed bin;

     iBlokP = AiBlokP;

     if  ^iBlok.syntax.request_summaryS  |  iBlok.relatives.multi_operation_listP = null()  then
	return;
     case = 3;					/* CASE 3: "List of requests"			        */
     Operation_ListP = iBlok.relatives.multi_operation_listP;
						/* Reference the "List of requests" array of items.       */

IDENTIFY_COMMON:
     iSectP = Operation_List.parentSectP;		/* Reference the iSect defining this Operation_List       */
						/*  in the multi-operation/multi-control/request-summary  */
						/*  blok.  (See NOTE above.)			        */

     iFileP = iBlok.fileP;				/* Access file struct for info seg holding Operation_List */
SCAN_FOR_OP_BLOCKS:
     do iBlokP = iFile.bloks.firstP			/*  - Scan blocks of this file...		        */
	repeat iBlok.sib.nextP  while ( iBlokP ^= null() );
	if  iBlokP = AiBlokP  then			/*     - skip our input Operation_List holding block.     */
	     goto IDENTIFY_CHECK_NEXT_BLOCK;

	else if  case = 1  &  iBlok.relatives.multi_operation_listP = null()  then do;
CHECK_IF_AN_OP_BLOCK:	
	     if  index(iBlok.header.str, COMMA) = 0  then /* If blok header:    has no comma		        */
	     if  dim(Blok_words,1) = 3  then		/* 		  consists of 3 words	        */
	     if  Blok_words(3) = word_for_op_control()  then
						/*                    has 3rd word = "control"	        */
						/*                 or has 3rd word = "operation"	        */
	     if  Blok_words(1) = Operation_List.blok_name  then 
						/*                    has 1st word = Operation_List holder*/
IT_IS_AN_OP_BLOCK:
	     do;
						/*     - Look thru Operation_List for item matching 2nd   */
						/*       word in current block's header line.	        */
		do Operation_ListI = lbound(Operation_List.items,1)
		                  to hbound(Operation_List.items,1);
		     if  Blok_words(2) = operation_names(1)  then 
			goto BLOCK_IDENTIFIED;	/*                    has 2nd word = LONG_OPERATION_NAME  */
		     do opNameI = 2 to hbound(operation_names,1);
			if  Blok_words(2) = operation_names(opNameI)  then do;
			     iBlok.multi_op_header_bad_op_nameS = T;
						/*  - Header word(2) is not 1st operation/control name.   */
			     iSect.display_listS = T;	/*    Display items in  List of ... operations  section.  */
			     goto BLOCK_IDENTIFIED;
			     end;
			end;
		     end;
		iBlok.multi_op_name_not_listedS = T;	/*    Didn't find 2nd word in any Operation_List item.    */
		iSect.display_listS = T;		/*    Display items in  List of ... operations  section.  */
		end IT_IS_AN_OP_BLOCK;

	     else do;				/*  - Header word(1) is not Operation_List name	        */
		iBlok.multi_op_header_bad_cmdReqIOmod_nameS = T;
		goto IT_IS_AN_OP_BLOCK;		/*     - but... it's almost a per-op/control doc block.   */
		end;
	     end;
	else if  case = 2  &  iBlok.relatives.multi_control_listP = null()  &
	         iBlok.kind = iBlok_kind_IO_CONTROL  then
	     goto CHECK_IF_AN_OP_BLOCK;

	else if  case = 3  &  iBlok.relatives.multi_operation_listP = null()  &
	         is_Request_kind(iBlok.kind)  then do;

  dcl  exactMatchS bit(1) aligned;

	     do Operation_ListI = lbound(Operation_List.items,1)
		             to hbound(Operation_List.items,1);
		if  any_request_names_match( operation_names, Blok_words, exactMatchS )  then do;
		     if  exactMatchS  then 
			goto BLOCK_IDENTIFIED;
		     iSect.display_listS = T;
		     iBlok.bad_request_headerS = T;
		     goto BLOCK_IDENTIFIED;
		     end;
		end;
	     end;

	goto IDENTIFY_CHECK_NEXT_BLOCK;
	
BLOCK_IDENTIFIED:
	if  case = 1  then do;
	     iBlok.syntax.is_operationS = T;		/* Mark block as documenting op of multi_op command/req   */
	     iBlok.relatives.multi_operation_listP = Operation_ListP;
	     end;					/*  - Attach Operation_List to per-op block too.	        */
	else if  case = 2  then do;
	     iBlok.syntax.is_controlS = T;		/* Mark block as documenting control op of IO Module      */
	     iBlok.relatives.multi_control_listP = Operation_ListP;
	     end;					/*  - Attach Operation_List to per-control-op block too.  */
	else if  case = 3  then do;
	     iBlok.syntax.is_requestS = T;
	     iBlok.relatives.multi_operation_listP = Operation_ListP;
	     end;					/*  - Attach Operation_List to per-op block too.	        */
	Operation_List.per_operation_iBlokP(Operation_ListI) = iBlokP;
						/*  - Attach per-op block to Operation_List, so           */
						/*     info_seg_utils_$is_operation_format_block can set  */
						/*     Operation_ListI without having to search 	        */
						/*     Operation_List.items again.		        */
IDENTIFY_CHECK_NEXT_BLOCK:
	end SCAN_FOR_OP_BLOCKS;

OPERATION_LIST_CHECK:
     do Operation_ListI = lbound(Operation_List.items,1) 
		   to hbound(Operation_List.items,1);	/* Are any per-op iBlokP ptrs null?  		        */
	if  Operation_List.per_operation_iBlokP(Operation_ListI) = null()  then do;
	     iSect.list_of_ops_op_not_documentedS = T;	/*  - ERROR: some Operation_List item has no block        */
	     goto LIST_CHECK_DONE;
	     end;
	end OPERATION_LIST_CHECK;
     
LIST_CHECK_DONE:
     return;

word_for_op_control:
     	proc () returns (char(9) var);

	if  case = 2  then 	
	     return ("control"  );
	else return ("operation");
	end word_for_op_control;
%page;
/* -------------------------------------------------------------------------------- 
   ENTRY:  info_seg_util_$is_control_format_block
     
   Function: Returns data about given iBlok's relationship (if any) to an 
	   Operation_List defined by a multi-control IO_MODULE
	   block in this info segment.  AiBlokP may: point to the holder of the
	   Operation_List; or point to a block describing one control order in that
	   Operation_List; or point to a block not associated with Operation_List.

   -------------------------------------------------------------------------------- */

is_control_format_block:
     entry (AiBlokP, AOperation_ListP, AOperation_ListI) returns (bit(1) aligned);
     
/*dcl  AiBlokP ptr;					/* Points to possible multi-control block.            (in)*/
  dcl  AOperation_ListP ptr;				/* Points to Operation_List structure for controls.  (out)*/
  dcl  AOperation_ListI fixed bin;			/* Index in Operation_List.items and 		        */
						/*  Operation_List.per_operation_iBlokP of block.    (out)*/
       iBlokP = AiBlokP;

     if  iBlok.syntax.multi_controlsS  then do;		/* - For IO_MODULE blok holding the Operation_List ...    */
	AOperation_ListP = iBlok.relatives.multi_control_listP;
	AOperation_ListI = 0;			/*    - Just return pointer to Operation_List.	        */
	return (T);
	end;

     if  iBlok.syntax.is_controlS  then do;		/* - For IO_CONTROL blok describing one control order...  */
						/*    - Find this blok's control in Operation_List        */
	Operation_ListP = iBlok.relatives.multi_control_listP;
	do Operation_ListI = lbound(Operation_List.per_operation_iBlokP,1) 
	                  to hbound(Operation_List.per_operation_iBlokP,1);
	     if  Operation_List.per_operation_iBlokP(Operation_ListI) = iBlokP  then do;
		AOperation_ListP = Operation_ListP;	/*  - return pointer to the Operation_List	        */
		AOperation_ListI = Operation_ListI;	/*  - return item of blok's control order in that list.   */
						/*    This also makes oepration_names(*) array available. */
		return (T);
		end;
	     end;
	end;
     
     AOperation_ListP = null();			/* AiBlokP not associated with control Operation_List.    */
     AOperation_ListI = 0;
     return (F);
%page;
/* -------------------------------------------------------------------------------- 
   ENTRY:  info_seg_util_$is_operation_format_block

   Function: Returns data about given iBlok's relationship (if any) to an 
	   Operation_List defined by a multi-operation command/request/IO_MODULE
	   block in this info segment.  AiBlokP may: point to the holder of the
	   Operation_List; or point to a block describing one operation in that
	   Operation_List; or point to a block not associated with Operation_List.
   -------------------------------------------------------------------------------- */

is_operation_format_block:
     entry (AiBlokP, AOperation_ListP, AOperation_ListI) returns (bit(1) aligned);
     
/*dcl  AiBlokP ptr;					/* Points to a possible multi-operation block.	   (in) */
/*dcl  AOperation_ListP ptr;				/* Points to Operation_List structure for operation. (out)*/
/*dcl  AOperation_ListI fixed bin;			/* Index in Operation_List.items and 		        */
						/*  Operation_List.per_operation_iBlokP of block.    (out)*/
       iBlokP = AiBlokP;

     if  iBlok.syntax.multi_operationsS  |		/* - For blok holding the Operation_list...	        */
         iBlok.syntax.request_summaryS  then do;		/*   or the "List of requests" section...	        */
	AOperation_ListP = iBlok.relatives.multi_operation_listP;
	AOperation_ListI = 0;			/*    - Just return pointer to Operation_List.	        */
	return (T);
	end;

     if  iBlok.syntax.is_operationS  |			/* - For blok describing one op of multi-op command/req.. */
         iBlok.syntax.is_requestS  then do;		/*   or one of the requests in "List of requests"...      */
						/*    - Find this blok's operation in Operation_List      */
	Operation_ListP = iBlok.relatives.multi_operation_listP;
	do Operation_ListI = lbound(Operation_List.per_operation_iBlokP,1) 
	                  to hbound(Operation_List.per_operation_iBlokP,1);
	     if  Operation_List.per_operation_iBlokP(Operation_ListI) = iBlokP  then do;
		AOperation_ListP = Operation_ListP;	/*  - return pointer to Operation_List		        */
		AOperation_ListI = Operation_ListI;	/*  - return item of this blok's operation in that list.  */
						/*    This also makes operation_names(*) array available. */
		return (T);
		end;
	     end;
	end;
     
     AOperation_ListP = null();			/* AiBlokP not associated with any Operation_List	        */
     AOperation_ListI = 0;
     return (F);
%page;
/* -----------------------------------------------------------------
   ENTRY: info_seg_util_$is_Subroutine_kind

   FUNCTION: Test whether give block type represents one component
	   of a subroutine-type info segment.
   ----------------------------------------------------------------- */

is_Subroutine_kind:
     entry (AiBlok_kind) returns (bit(1) aligned);
	
  dcl  AiBlok_kind fixed bin;

     return ( AiBlok_kind = iBlok_kind_SUBROUTINE_INTRO       |
	    AiBlok_kind = iBlok_kind_SUBROUTINE_BRIEF_INTRO |
	    AiBlok_kind = iBlok_kind_SUBROUTINE_ENTRY
	    );

%page;
/* -----------------------------------------------------------------
   ENTRY: info_seg_util_$max_name_width

   FUNCTION: given an array of names (of arbitrary maxlength), 
	   returns actual length of the longest name in that array.
   ----------------------------------------------------------------- */
max_name_width:
     entry (Anames) returns(fixed bin);
     
  dcl  Anames (*) char(32) var;

  dcl  nmI fixed bin;				/* index into array of names.			        */
  dcl  nmL fixed bin;
     
     nmL = 0;
     do nmI = lbound(Anames,1) to hbound(Anames,1);
	nmL = max( nmL, length(Anames(nmI)) );
	end;
     return (nmL);

%page;
/* -----------------------------------------------------------------
   ENTRY: info_seg_util_$print_block_lines

   FUNCTION: given pointer to an iBlok and a line_range (start, count),
	   prints lines of that block that are within given range.
   ----------------------------------------------------------------- */

print_block_lines:
     entry (AiBlokP, Aline_range);
     
/*dcl  AiBlokP ptr;					/* Points to block whose lines are to be printed.	        */

  dcl 1 Aline_range aligned,				/* Aline_range.start and .count give relative starting    */
      2 (start, count) fixed bin;			/*  line and count of lines to be printed.	        */
						/*  If .start is negative n, the nth line from last       */
						/*  is used as the starting line.		        */

  dcl  content char(20) var;
  dcl  line_limitN fixed bin;
  
     if  Aline_range.start < 0  then do;		/* start < 0?  Count backward from last line of block for */
	line_limitN = -Aline_range.start - 1;		/*             abs(start) lines as range starting line.   */
	do iLineP = AiBlokP->iBlok.lines.lastP 
	     repeat iLine.blok.prevP 
	     while (iLineP ^= null()  &  line_limitN > 0);
	     line_limitN = line_limitN - 1;
	     end;
	if  iLineP = null()  then			/*   - Oops.  Block contains fewer than -start lines.     */
	     iLineP = AiBlokP->iBlok.lines.firstP;	/*            Range starts with first line of block.      */
	end;
     else  if Aline_range.start > 0  then do;		/* start > 0? Count forward to starting line in block.    */
	line_limitN = Aline_range.start - 1;
	do iLineP = AiBlokP->iBlok.lines.firstP 
	     repeat iLine.blok.nextP 
	     while (iLineP ^= null()  &  line_limitN > 0);
	     line_limitN = line_limitN - 1;
	     end;
	end;
     else iLineP = null();				/* start = 0?  Line range undefined.  Print nothing.      */
     line_limitN = Aline_range.count;
     content = "Block Lines";

     if  iLineP = null()   then return;
     if  line_limitN <= 0  then return;

     call ioa_ ("^/^-^71a   LINE  FLAGS", content);	/* Print heading for this output.		        */
     do iLineP = iLineP
          repeat iLine.blok.nextP 
	while (iLineP ^= null()  &  line_limitN > 0);
						/*  - Each line ends with error flags.		        */
	call ioa_("^7x | ^71a | ^4d ^[ blank^]^[ allWhite^]^[ endsWhite^]^[  nnl^]" ||
	     "^[ backspaces^]^[ unprintable^]^[ length (^d)^;^s^]", 
	     Line, iLine.line_in_file,
	     (iLine.L = 0), iLine.all_whitespaceS, iLine.ends_whitespaceS, iLine.NL_missingS,
	     iLine.backspaceS, iLine.unprintableS, iLine.overlengthS, iLine.L);
	line_limitN = line_limitN - 1;
	end;
     return;
%page;
/* -----------------------------------------------------------------
   ENTRY: info_seg_util_$print_file_lines

   FUNCTION: given pointer to an iFile and a line_range (start, count),
	   prints lines of that file that are within given range.
   ----------------------------------------------------------------- */

print_file_lines:
     entry (AiFileP, Aline_range);
     
/*dcl  AiFileP ptr;					/* Points to info seg iFile descriptor.		        */

/*dcl 1 Aline_range aligned like verify_info_data.lines.file;
						/* Aline_range.start and .count give relative starting    */
						/*  line and count of lines to be printed.	        */
						/*  If .start is negative n, the nth line from last       */
						/*  is used as the starting line.		        */

     if  Aline_range.start < 0  then do;		/* start < 0?  Count backward from last line of file for  */
	line_limitN = -Aline_range.start - 1;		/*             abs(start) lines as range starting line.   */
	do iLineP = AiFileP->iFile.lines.lastP 
	     repeat iLine.file.prevP 
	     while (iLineP ^= null()  &  line_limitN > 0);
	     line_limitN = line_limitN - 1;
	     end;
	if  iLineP = null()  then 			/*   - Oops.  File contains fewer than -start lines.      */
	     iLineP = AiFileP->iFile.lines.firstP;	/*            Range starts with first line of file.       */
	end;
     else  if Aline_range.start > 0  then do;		/* start > 0? Count forward to starting line in block.    */
	line_limitN = Aline_range.start - 1;
	do iLineP = AiFileP->iFile.lines.firstP 
	     repeat iLine.file.nextP 
	     while (iLineP ^= null()  &  line_limitN > 0);
	     line_limitN = line_limitN - 1;
	     end;
	end;
     else iLineP = null();				/* start = 0?  Line range undefined.  Print nothing.      */
     line_limitN = Aline_range.count;
     content = "Info Seg Lines";

     if  iLineP = null()   then return;
     if  line_limitN <= 0  then return;

     call ioa_ ("^/^-^71a   LINE  FLAGS", content);	/* Print heading for this output.		        */
     do iLineP = iLineP
          repeat iLine.file.nextP 
	while (iLineP ^= null()  &  line_limitN > 0);
						/*  - Each line ends with error flags.		        */
	call ioa_("^7x | ^71a | ^4d ^[ blank^]^[ allWhite^]^[ endsWhite^]^[  nnl^]" ||
	     "^[ backspaces^]^[ unprintable^]^[ length (^d)^;^s^]", 
	     Line, iLine.line_in_file,
	     (iLine.L = 0), iLine.all_whitespaceS, iLine.ends_whitespaceS, iLine.NL_missingS,
	     iLine.backspaceS, iLine.unprintableS, iLine.overlengthS, iLine.L);
	line_limitN = line_limitN - 1;
	end;
     return;
%page;
/* -------------------------------------------------------------------------------- 
   ENTRY:  info_seg_util_$set_names

   FUNCTION:  Removes current names from an info segment, replacing them with
	    a new set of names (perhaps containing some current names in a 
	    different order).
   -------------------------------------------------------------------------------- */

set_names:
     entry (AisdP, AiFileP, Anames, Aold_names);

/*dcl  AisdP ptr;					/* Points to info_seg_data structure (for allocations)    */
/*dcl  AiFileP ptr;					/* Points to info seg iFile descriptor.		        */     
/*dcl  Anames (*) char(32) var;			/* Names desired on the info seg.		        */
  dcl  Aold_names (*) char(32) var;			/* Names already on the info seg (perhaps in wrong order) */

  dcl (NO_OLD_NAME, NO_NEW_NAME) char(1) int static options(constant) init("");

     iFileP = AiFileP;
     call hcs_$chname_seg (iFile.P, NO_OLD_NAME, (Anames(1)), code);
						/* Ensure first desired name is a name on the info seg    */
     if  code = error_table_$segnamedup  then;		/*  - It is.				        */
     else if  code = error_table_$namedup  then do;
	call ssu_$print_message( isd.sciP, code, "Another entry has the name: ^a>^a", iFile.dir, Anames(1) );
	return;					/*  - Another entry in dir has that name...  Too bad.     */
	end;
     else if  code ^= 0  then do;
	call ssu_$print_message( isd.sciP, code, "Adding the name: ^a>^a", iFile.dir, Anames(1) );	 
	return;					/*  - Some other error (like insufficient access to dir)  */
	end;
     
     do nmI = lbound(Aold_names,1) to hbound(Aold_names,1);	/* Remove other existing names on info seg.	        */
	if  Aold_names(nmI) ^= Anames(1)  then do;
	     call hcs_$chname_seg (iFile.P, (Aold_names(nmI)), NO_NEW_NAME, code);
	     if  code ^= 0  then do;
		call ssu_$print_message( isd.sciP, code, "Deleting the name: ^a>^a", iFile.dir, Aold_names(nmI) );	 
		return;				/*  - Some error (like insufficient access to dir)        */
		end;
	     end;
	end;
     nmI = 2;

ADD_NAMES:
     do nmI = nmI to hbound(Anames,1);			/* Add other desired names to info seg.		        */
	call hcs_$chname_seg (iFile.P, NO_OLD_NAME, (Anames(nmI)), code);	
	if  code = error_table_$namedup  then do;
	     call ssu_$print_message( isd.sciP, code, "Another entry has the name: ^a>^a", iFile.dir, Anames(nmI) );
	     return;				/*  - Another entry in dir has that name...  Too bad.     */
	     end;
	else if  code = error_table_$segnamedup  then;	/*  - Ignore finding name already on the entry.	        */
	else if  code ^= 0  then do;
	     call ssu_$print_message( isd.sciP, code, "Adding the name: ^a>^a", iFile.dir, Anames(nmI) );	 
	     return;				/*  - Some other error (like insufficient access to dir)  */
	     end;					
	end;
     return;


/* -------------------------------------------------------------------------------- 
   ENTRY:  info_seg_util_$add_names

   FUNCTION:  Adds an array of new names to end of namelist for an existing info seg.
   -------------------------------------------------------------------------------- */

add_names:
     entry (AisdP, AiFileP, Anames);
     
     iFileP = AiFileP;
     nmI = 1;
     goto ADD_NAMES;


/* -------------------------------------------------------------------------------- 
   ENTRY:  info_seg_util_$delete_names_brief

   FUNCTION:  Removes an array of (perhaps) existing names from namelist of an 
	    existing info seg.  No error is reported if the name to be removed
	    is not actually present on that info seg.
   -------------------------------------------------------------------------------- */

delete_names_brief:
     entry (AisdP, AiFileP, Anames);
     
  dcl  ignore_code fixed bin(35);

     iFileP = AiFileP;
     do nmI = lbound(Anames,1) to hbound(Anames,1);	/* Remove (perhaps existing) names on info seg.	        */
	call hcs_$chname_seg (iFile.P, (Anames(nmI)), NO_NEW_NAME, code);
	if  code = error_table_$noentry  then;		/*  - Ignore if name to be deleted not found.	        */
	else if  code ^= 0  then do;
	     call ssu_$print_message( isd.sciP, code, "Deleting the name: ^a>^a", iFile.dir, Anames(nmI) );	 
	     return;				/*  - Some error (like insufficient access to dir)        */
	     end;
	end;
     return;
%page;
/* -----------------------------------------------------------------
   ENTRY: is_activeFunction_activeRequest_type
	is_Arguments_type
	is_Control_arguments_type
	is_List_type
	is_Syntax_type
 
   Function: test for particular types of sections.
   ----------------------------------------------------------------- */

is_activeFunction_activeRequest_type:
	entry (AiSect_type) returns (bit(1) aligned);     

  dcl  AiSect_type fixed bin;

	return ( IS_activeFunction_activeRequest_type(AiSect_type) );


is_Arguments_type:
	entry (AiSect_type) returns (bit(1) aligned);

	return ( IS_Arguments_type(AiSect_type) );
     

is_Control_arguments_type:
	entry (AiSect_type) returns (bit(1) aligned);

	return ( IS_Control_arguments_type(AiSect_type) );


is_List_type:
	entry (AiSect_type) returns (bit(1) aligned);
	
	return ( IS_List_type(AiSect_type) );


is_Syntax_type:
	entry (AiSect_type) returns (bit(1) aligned);

	return ( IS_Syntax_type(AiSect_type) );
%page;
/* -----------------------------------------------------------------
   INTERNAL SUBROUTINES:

   Function:  Examine an array of words, returning T if they obey
	    a characteristic property.
   ----------------------------------------------------------------- */	    

IS_activeFunction_activeRequest_type:
	proc (AiSect_type) returns (bit(1) aligned);     

  dcl  AiSect_type fixed bin;

	return ( AiSect_type = iSect_SYNTAX_AS_AN_ACTIVE_FUNCTION |
	         AiSect_type = iSect_SYNTAX_AS_AN_ACTIVE_REQUEST );


IS_Arguments_type:
	entry (AiSect_type) returns (bit(1) aligned);

	return ( AiSect_type = iSect_ARGUMENTS                  |
	         AiSect_type = iSect_ARGUMENTS_FOR_IO_CALL      |
	         AiSect_type = iSect_ARGUMENTS_FOR_IOX_CONTROL  |
	         AiSect_type = iSect_ARGUMENTS_FOR	      |
	         AiSect_type = iSect_ARGUMENTS_SUBSET 
	         );
     

IS_Control_arguments_type:
	entry (AiSect_type) returns (bit(1) aligned);

	return ( AiSect_type = iSect_CONTROL_ARGUMENTS                        |
	         AiSect_type = iSect_CONTROL_ARGUMENTS_AS_A_COMMAND           |
	         AiSect_type = iSect_CONTROL_ARGUMENTS_AS_A_REQUEST           |
	         AiSect_type = iSect_CONTROL_ARGUMENTS_AS_AN_ACTIVE_FUNCTION  |
	         AiSect_type = iSect_CONTROL_ARGUMENTS_AS_AN_ACTIVE_REQUEST   |
	         AiSect_type = iSect_CONTROL_ARGUMENTS_FOR_ATTACH_DESCRIPTION	|
	         AiSect_type = iSect_CONTROL_ARGUMENTS_FOR_OPEN_DESCRIPTION	|
	         AiSect_type = iSect_CONTROL_ARGUMENTS_FOR_CLOSE_DESCRIPTION  |
	         AiSect_type = iSect_CONTROL_ARGUMENTS_FOR_DETACH_DESCRIPTION	|
	         AiSect_type = iSect_CONTROL_ARGUMENTS_FOR		|
	         AiSect_type = iSect_CONTROL_ARGUMENTS_SUBSET                 );


IS_List_type:
	entry (AiSect_type) returns (bit(1) aligned);
	
	return ( IS_Arguments_type(AiSect_type)                 |
	         IS_Control_arguments_type(AiSect_type)	      |
	         AiSect_type = iSect_LIST_OF_CONTROL_OPERATIONS |
	         AiSect_type = iSect_LIST_OF_CONTROLS	      |
	         AiSect_type = iSect_LIST_OF_ELEMENTS	      |
	         AiSect_type = iSect_LIST_OF_IO_OPERATIONS      |
	         AiSect_type = iSect_LIST_OF_MODE_STRINGS	      |
	         AiSect_type = iSect_LIST_OF_OPENING_MODES      |
	         AiSect_type = iSect_LIST_OF_OPERATIONS	      |
	         AiSect_type = iSect_LIST_OF_REQUESTS	      |
	         AiSect_type = iSect_LIST_OF				
	         );
	

IS_Syntax_type:
	entry (AiSect_type) returns (bit(1) aligned);

	return ( IS_activeFunction_activeRequest_type(AiSect_type) |
	         AiSect_type = iSect_SYNTAX                        |	
	         AiSect_type = iSect_SYNTAX_AS_A_COMMAND	         |
	         AiSect_type = iSect_SYNTAX_OF_ATTACH_DESCRIPTION  |
	         AiSect_type = iSect_SYNTAX_OF_OPEN_DESCRIPTION    |
	         AiSect_type = iSect_SYNTAX_OF_CLOSE_DESCRIPTION   |
	         AiSect_type = iSect_SYNTAX_OF_DETACH_DESCRIPTION 
	         );

	end IS_activeFunction_activeRequest_type;

%page;
/* -----------------------------------------------------------------
   INTERNAL SUBROUTINES:

   Function:  Examine an array of words, returning T if they obey
	    a characteristic property.
   ----------------------------------------------------------------- */	    

all_unique:					/* All words unique?			        */
     proc (words) returns (bit(1) aligned);
     
  dcl  words (*) char(*) var;
  dcl (wdI, wdJ) fixed bin;

     if  dim(words,1) = 1  then			/* Only 1 word?  It's unique.			        */
	return (T);

     do wdI = lbound(words, 1) to hbound(words, 1);	/* Return F if word(i) = word(j) for i ^= j	        */
	do wdJ = wdI+1 to hbound(words, 1);
	     if  words(wdI) = words(wdJ)  then
		return (F);
	     end;
	end;
     return (T);					/* All words are unique.			        */
     

all_iox_:						/* All words are names of iox_ I/O operations?	        */
     entry (words) returns (bit(1) aligned);
     
     do wdI = lbound(words,1) to hbound(words,1);
	if  ^is_iox_operation( words(wdI) )  then
	     return (F);
	end;
     return (T);


descending_lengths:					/* Words appear in array in descending ordered of length? */
     entry (words) returns (bit(1) aligned);
     
  dcl  wdL fixed bin;
     
     wdL = 1000;
     do wdI = lbound(words, 1) to hbound(words, 1);	/* Return F if word(i) = word(j) for i ^= j	        */
	if  length(words(wdI)) > wdL  then 
	     return (F);				/*  - words not ordered by descending length	        */
	wdL = length(words(wdI));
	end;

     return (T);

     end all_unique;
%page;
/* -----------------------------------------------------------------
   SUBROUTINE:  any_request_names_match

   FUNCTION:  Compare names for one item in "List of requests"
	       with Request/AR block header words.
	    Report first item for which:
	     - any name matches a header word for the request.
	     - all names for that item match header words in count, value, and order.
   ----------------------------------------------------------------- */

any_request_names_match:
     proc (item_names, header_words, exactMatchS) returns (bit(1) aligned);

  dcl  item_names (*) char(*) var;
  dcl  header_words (*) char(*) var;
  dcl  exactMatchS bit(1) aligned;

  dcl (nmI, wdI) fixed bin;

     exactMatchS = F;				/* Assume not an exact match.			        */

     do nmI = lbound(item_names,1) to hbound(item_names,1);
	do wdI = lbound(header_words,1) to hbound(header_words,1);
	     if  item_names(nmI) = header_words(wdI)  then 
		goto ONE_MATCH;
	     end;
	end;
     return (F);					/* No matching names found.			        */

ONE_MATCH:					/* Check for an exact match...		        */
     if  dim(item_names,1) ^= dim(header_words,1)  |	/*  - Not exact if counts differ.		        */
         nmI > 1  |  nmI ^= wdI  then			/*  - Not exact if name order differs.		        */
	return (T);				/*  - One matching name found, not an exact match.        */

     do nmI = 2 to hbound(item_names,1);		/* item_name(1) = header_words(1) & counts are same...    */
	if  item_names(nmI) ^= header_words(nmI)  then
	     return (T);				/*  - One or more matching names, but some differ.        */
	end;
     exactMatchS = T;				/*  - Exact match!				        */
     return (T);

     end any_request_names_match;
%page;
/* -----------------------------------------------------------------
   INTERNAL FUNCTION:  is_iox_operation

   FUNCTION:  Check whether a given token represents a known iox_
	    I/O operation that may be performed by an I/O module.
   ----------------------------------------------------------------- */

is_iox_operation:
     proc (Atoken) returns(bit(1) aligned);
     
  dcl  Atoken char(*) var;

     return (					/* This list taken from: iocb.incl.pl1		        */
         Atoken = "open_file"       |  Atoken = "open"           |   /* setup / breakdown			        */
         Atoken = "close_file"      |  Atoken = "close"          |
         Atoken = "detach"	      |  Atoken = "detach_iocb"    
         );
     
  /*  Other I/O operations defined by iox_ don't have a standard interface or require standard section titles.
      So these other operations are excluded from the above list, thereby excluding them from use in an I/O Module
      "List of operations" section.

         Atoken = "get_chars"       |  Atoken = "get_line"       |   /* stream I/O
         Atoken = "put_chars"       |
         Atoken = "read_record"     |  Atoken = "write_record"   |   /* non-stream I/O
         Atoken = "rewrite_record"  |  Atoken = "delete_record"  |
         Atoken = "seek_key"	      |  Atoken = "read_key"	     |
         Atoken = "read_length"     |
         Atoken = "modes"           |  Atoken = "position"       |   /* other ops
         Atoken = "control"         
   */

     end is_iox_operation;
%page;
/* -----------------------------------------------------------------
   Function: test for particular blok kinds.
   ----------------------------------------------------------------- */

is_Request_kind:
	proc (AiBlok_kind) returns (bit(1) aligned);     

  dcl  AiBlok_kind fixed bin;

	return ( AiBlok_kind = iBlok_kind_REQUEST_AR	|
	         AiBlok_kind = iBlok_kind_REQUEST	|
	         AiBlok_kind = iBlok_kind_ACTIVE_REQUEST
	         );
	
is_Subroutine_kind:
	entry (AiBlok_kind) returns (bit(1) aligned);
	
	return ( AiBlok_kind = iBlok_kind_SUBROUTINE_INTRO       |
	         AiBlok_kind = iBlok_kind_SUBROUTINE_BRIEF_INTRO |
	         AiBlok_kind = iBlok_kind_SUBROUTINE_ENTRY
	         );

	end is_Request_kind;
%page;
%include ssu_subroutine_dcls_;

     end info_seg_util_;
