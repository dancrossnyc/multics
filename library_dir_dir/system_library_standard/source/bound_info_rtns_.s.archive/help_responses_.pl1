
/****^  HISTORY COMMENTS:
  1) change(2020-10-25,GDixon), approve(2021-02-23,MCR10089),
     audit(2021-03-31,Swenson), install(2021-03-31,MR12.6g-0053):
     Initial version created as part of help_ rewrite
  2) change(2020-11-04,GDixon), approve(2021-02-23,MCR10089),
     audit(2021-03-31,Swenson), install(2021-03-31,MR12.6g-0053):
      A) Fix calling sequence for help_util_$count_file_lines.
      B) Add list_entry_points -unseen control argument.
  3) change(2020-11-11,GDixon), approve(2021-02-23,MCR10089),
     audit(2021-03-31,Swenson), install(2021-03-31,MR12.6g-0053):
      A) Add top -section control arg.
      B) Add rest -top control arg.
      C) Add ep -match, -exact, and -unseen.
      D) Add lep -unseen.
  4) change(2020-11-22,GDixon), approve(2021-02-23,MCR10089),
     audit(2021-03-31,Swenson), install(2021-03-31,MR12.6g-0053):
      A) Change $brief response to check for iSect.listP ^= null() as an
         indication that section should be included in brief output.
  5) change(2021-03-01,GDixon), approve(2021-03-01,MCR10089),
     audit(2021-03-31,Swenson), install(2021-03-31,MR12.6g-0053):
      A) Setup correct iPghP pointer in help_responses_$search entry point.
                                                   END HISTORY COMMENTS */

help_responses_:
     procedure();

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* The following table is shown here as a summary of the requests implemented in this source file.*/
	/* The real tables are actually implemented in code in:				        */
	/*           help_requests_$summarize_requests					        */
	/*           help_request_tables_.alm						        */
	/*           help.info :[Info]: summary.topic					        */
	/*									        */
	/* All of these need to be kept synchronized.					        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*
  dcl  NONSUBR_RESPONSES (37) char (65) var int static options (constant) init (
	"yes, y",
	"rest {-section | -unseen} {-top},",
	"   r {-scn | -uns} {-t}",			/* List of allowed responses to questions asked by help_ 
	"skip {-section | -seen | -rest},",		/*  for non-subroutine block.			      
	"   s {-scn | -seen | -rest}",		/*  [Taken from older version of help_; now enhanced.]  
	"next, no, n",
	"quit, q",
	"",
	"brief, bf",
	"control_arg {STRs} {-case_sensitive},",
	"   ca {STRs} {-cs}",
	"",
	"titles {-top | -unseen},",
	" title {-t | -uns}",
	"section {STRs} {-case_sensitive} {-top},",
	"   scn  {STRs} {-cs} {-t}",
	"search  {STRs} {-case_sensitive} {-top},",
	"   srh  {STRs} {-cs} {-t},",
	"   sh   {STRs} {-cs} {-t}",
	"",
	"top {-section}, t {-scn}",
	"header, he",
	"",
	"unseen_paragraphs_only, unseen, uns",
	"every_paragraph_visible, every_pgh, every",
	"",
	"find_info {STRs} {-case_sensitive} {-top},",
	"   find   {STRs} {-cs} {-t}",
	"info {INFO_NAME} {-list|-ls}",
	"all_paragraphs, all",
	"",
	"help {RESPONSE_NAME} {-brief | -control_arg STR},",
	"   h {RESPONSE_NAME} {-bf | -ca STR}",
	"list_responses, list_requests, lr",
	"?",
	".",
	".. MULTICS_COMMAND_LINE"
	);

  dcl  SUBR_RESPONSES (42) char (65) var int static options (constant) init (
	"yes, y",
	"rest {-section | -unseen} {-top},",
	"   r {-scn | -uns} {-t}",			/* List of allowed responses to questions asked by help_ 
	"skip {-section | -seen | -rest}",		/*  for subroutine (intro/entrypoints) block.	      
	"   s {-scn | -seen | -rest},",		/*  [Taken from older version of help_; now enhanced.]  
	"next, no, n",			
	"quit, q",
	"",
	"brief, bf",
	"control_arg {STRs} {-case_sensitive},",
	"   ca {STRs} {-cs}",
	"",
	"titles {-top | -unseen},",
	" title {-t | -uns}",
	"section {STRs} {-case_sensitive} {-top},",
	"   scn  {STRs} {-cs} {-t}",
	"search  {STRs} {-case_sensitive} {-top},",
	"   srh  {STRs} {-cs} {-t},",
	"   sh   {STRs} {-cs} {-t}",
	"",
	"top {-section}, t {-scn}",
	"header, he",
	"",
	"unseen_paragraphs_only, unseen, uns",
	"every_paragraph_visible, every_pgh, every",
	"",
	"list_entry_points {-unseen},",
	"   list_ep {-uns},",
	"   lep {-uns}",
	"entry_point {-match | -exact} {EP_STR} {-unseen},",
	"   ep {-match | -exact} {EP_STR} {-uns}",
	"find_entry_point {STRs} {-case_sensitive} {-top},",
	"   find_ep {STRs} {-case_sensitive} {-top},",
	"   find {STRs} {-cs} {-t}",
	"all_entry_points, aep, all",
	"",
	"help {RESPONSE_NAME} {-brief | -control_arg STR},",
	"   h {RESPONSE_NAME} {-bf | -ca STR}",
	"list_responses, list_requests, lr",
	"?",
	".",
	".. MULTICS_COMMAND_LINE"
	);
 */
%page;
  dcl (DOLLAR_SIGN char(1) init("$"),
       RPAREN char(1) init(")"),
       SP_LPAREN char(2) init (" ("),
       SP_PARENS char(3) init (" ()"),
       SP_SP char(2) init ("  "),
       SP_SP_SP char(3) init ("   "),
       SP_SP_SP_PARENS char(5) init("   ()")
       ) int static options(constant);

  dcl  get_shortest_path_ entry (char(*)) returns(char(168)),

       help_util_$count_file_lines entry (ptr, ptr, ptr) returns(fixed bin),
       help_util_$execute entry (ptr, ptr, char(*)),
       help_util_$format_LIST entry (ptr, ptr, ptr, fixed bin, fixed bin),
       help_util_$format_one_use_LIST entry (ptr, ptr, ptr, fixed bin, fixed bin),
       help_util_$print_iSect_List entry (ptr, ptr, ptr),
       help_util_$print_iSect_List_match entry (ptr, ptr, ptr, ptr) returns(bit(1) aligned),
       help_util_$print_LIST entry (ptr, ptr, ptr),
       help_util_$print_section entry (ptr, ptr, ptr),

       info_seg_allocate_$iLine entry (ptr, fixed bin, ptr, fixed bin(21), bit(1) aligned) returns(ptr),
       info_seg_allocate_$iSect entry (ptr, fixed bin, ptr) returns(ptr),

       info_seg_parse_$append_STRING_to_block entry (ptr, ptr, ptr),
       info_seg_parse_$replace_STRING_in_section entry (ptr, ptr, ptr, ptr),

       info_seg_util_$count_file_blocks entry (ptr, ptr),
       info_seg_util_$is_Syntax_type entry (fixed bin) returns(bit(1) aligned),
       info_seg_util_$is_List_type entry (fixed bin) returns(bit(1) aligned),
       info_seg_util_$is_Subroutine_kind entry (fixed bin) returns(bit(1) aligned),

       ioa_$rsnnl entry() options(variable),
       pathname_ entry (char(*), char(*)) returns(char(168));
     
  dcl (after, before, length, null, string, substr, rtrim) builtin;

  dcl (error_table_$bad_arg,
       error_table_$badopt,
       error_table_$bigarg,
       error_table_$empty_file,
       error_table_$inconsistent,
       error_table_$noarg,
       error_table_$null_info_ptr,
       error_table_$too_many_args
       ) fixed bin(35) ext static;
%page;
%include info_seg_dcls_;
%page;
%include ssu_request_dcls_;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
/*											        *
   The ssu_$listen LISTENER LOOP supervises printing of help paragraphs, display of "More help?" prompts, and
   processing for user's response to each prompt (the response is an ssu_ request line).  The LOOP consists of the
   four-steps described below.  The response routines in help_responses_.pl1 are called in step 3 of this LOOP.

	     When entering step 1:
	      If hi.selected.iPghP  ^= null,     it points to the actual "last paragraph printed" iPgh structure.
			         
                But if switching to a new section or paragraph...
	               If hi.iPghP   = null  &
	                  hi.iSectP  = null:     "last paragraph printed" appears to point to a paragraph 
					 before 1st section of block.
	               If hi.iPghP   = null  &
	                  hi.iSectP ^= null:     "last paragraph printed" appears to point to the paragraph 
	                                         before that section.

    Step 1:  Uses "last paragraph printed", hi.display_limit, and count of unseen paragraphs to determine
	   what paragraphs to display next; then tells user what they are...  via a "More help?" prompt.
	   ssu_$listen calls help_listen_util_$display_prompt to perform step 1.



	     When entering step 2 and for all subsequent steps:
	         hi.iPgh_print_range.startP   points to first iPgh to print.
			        .endP     points to last iPgh to print.


	         hi.selected.iPghP   = hi.iPgh_print_range.startP ("current paragraph" is first paragraph to be displayed)
                              .iSectP  = pointer to iSect describing section containing "current paragraph"

	         hi.prompt_repeatS   = T:  Nothing is printed by step 4; step 1 recomputes and displays "More help?" prompt. 

    Step 2:  ssu_$listen reads and processes the user's response to that "More help?" prompt.  
	    - It break's response line into one or more ssu_ requests.  
	    - Invokes each request (which is usually a help_ response routine).
	    - If user types an empty response line,  hi.prompt_repeatS = T  causes prior prompt to be redisplayed.

    Step 3:  Each help_responses_ routine can adjust hi.selected and hi.iPgh_print_range, 
	   or make no adjustments: these values select which paragraphs are to be displayed.

	   A response routine may also change:  
	     hi.display_limit:  can have one of the following four values.
			      DISPLAY_LIMIT_none         => display all paragraphs that fit on the video page.
			      DISPLAY_LIMIT_section	   => display only paragraphs of current section.
			      DISPLAY_LIMIT_unseen	   => display only unseen paragraphs.
			      DISPLAY_LIMIT_rest_unseen  => display all remaining unseen paragraphs.
             To display any paragraphs in step 4, a response routine must set:
	     hi.prompt_repeatS = F    => either the incoming hi.iPgh_print_range is displayed, 
				       or an adjusted hi.selected and/or hi.iPgh_print_range displayed.


	     When entering step 4:
	      If hi.iPgh_print_range  ^= null:    .startP and .endP delimit the exact set of paragraphs to display.
				 = null:  hi.selected values specify a new "current paragraph".
					help_listen_util_$set_iPgh_range is called to map that "current paragraph"
					 into a pair of hi.iPgh_print_range delimiter pointers.  
					 If hi.display_limit = DISPLAY_LIMIT_section, that print range is limited
					 to paragraphs of the current paragraph's section, from current pgh onward.

    Step 4:  If hi.prompt_repeatS ^= T, then display paragraphs of the hi.iPgh_print_range
	    - If hi.display_limit >= DISPLAY_LIMIT_unseen, then only unseen paragraphs in print range are displayed.

	   ssu_$listen calls help_listen_util_$print_iPgh_range to perform step 4.  After performing its work,
	   it returns back to ssu_$listen... which iterates again through LOOP.... starting at step 1.
/*											        *
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* RESPONSE: all_paragraphs, all           (DISPLAY_MODE_non_subroutine)		        */
	/*           all_entry_points, aep, all    (DISPLAY_MODE_subroutine)			        */
	/*									        */
	/* Syntax as a response:  all_paragraphs   (DISPLAY_MODE_non_subroutine)		        */
	/*		      all_entry_points (DISPLAY_MODE_subroutine)			        */
	/*									        */
	/* Function: Jump to code that displays all paragraphs of current block, or all paragraphs of     */
	/*	   a subroutine's introduction block and every entrypoint block.		        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

all_paragraphs:
     entry (AsciP, help_infoP);
     
/*dcl  AsciP ptr;					/* help_ subsystem's sci_ptr			(Input) */
/*dcl  help_infoP  ptr;				/* points to the help_info (hi) data structure.   (Input) */
     
     call arg_setup (AsciP);				/* Error if any arguments given after the request name.   */
     if args_remain() then
	call response_error (AsciP, 0, "No arguments may be given.");

     hi.Sctl = F;
     hi.Sctl.all = T;

     iFileP = hi.iFileP;
     if  hi.display_mode = DISPLAY_MODE_subroutine  then	/* For subroutines, make introduction the current block.  */
	hi.iBlokP = iFile.relatives.bloks.firstP;

     goto hi.ALL_PARAGRAPHS_LABEL;			/* Transfer to code in display_block used by help -all    */
						/*  to display the current block, or all entrypoints of   */
						/*  a subroutine info seg.			        */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* RESPONSE: brief, bf							        */
	/*									        */
	/* Syntax as a help control:	-brief, -bf					        */
	/* Syntax as a response:	 brief,  bf					        */
	/*									        */
	/*  1) Displays Syntax... section(s)						        */
	/*  2) Displays item names for: Arguments..., Control arguments..., and List of ... sections      */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

brief:
     entry (AsciP, help_infoP);
     
/*dcl  AsciP ptr;					/* help_ subsystem's sci_ptr			(Input) */
/*dcl  help_infoP  ptr;				/* points to the help_info (hi) data structure.   (Input) */

     call arg_setup (AsciP);				/* Error if any arguments given after the request name.   */
     if args_remain() then
	call response_error (AsciP, 0, "No arguments may be given.");

     if  hi.iBlokP = null()  then
	call response_error (AsciP, error_table_$null_info_ptr, "Internal error: hi.iBlokP = null()");
     iBlokP = hi.iBlokP;

     if  hi.block_progress = BLOCK_PROGRESS_needs_header  then do;
						/* brief response invoked by help -brief	        */
	hi.header_Nlines_follow = 0;
	call help_util_$execute (AsciP, help_infoP, "header");
	end;					/*  - display a heading describing info seg.	        */

     do iSectP = iBlok.sects.firstP
	repeat iSect.sib.nextP  while (iSectP ^= null() );
	
	if  info_seg_util_$is_Syntax_type (iSect.type)  then
	     call help_util_$print_section (AsciP, help_infoP, iSectP);
	end;

     do iSectP = iBlok.sects.firstP
	repeat iSect.sib.nextP  while (iSectP ^= null() );
	
	if  iSect.listP ^= null() | info_seg_util_$is_List_type (iSect.type)  then
	     call help_util_$print_iSect_List (AsciP, help_infoP, iSectP);
	end;
     return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* RESPONSE: control_arg, ca							        */
	/*									        */
	/* Syntax as a help control:	-control_arg  STRs  {-case_sensitive}, -ca  STRs  {-cs}	        */
	/* Syntax as a response:   	 control_arg {STRs} {-case_sensitive},  ca {STRs} {-cs}	        */
	/*									        */
	/* Function: Displays item_name and description for any Arguments..., Control arguments..., or    */
	/*	   List of ... section item whose name matches the STR operands of -ca control arg or   */
	/*	   the ca response arguments.						        */
	/*									        */
	/*	   The help controls are processed by the help command.  They arrive here via           */
	/*	   help_args.Sctl.ca, help_args.Sctl.cs, and help_args.ca(*) values.		        */
	/*									        */
	/* 	   The "Syntax as a response:" is processed by this response routine.		        */
	/*           When invoked via a response to a help_ query, the STRs search strings are optional.  */
	/*	   If not provided, the search strings given in the help command line or the most       */
	/*	   recent response to a help query are used to display the earlier results again.       */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

control_arg:
     entry (AsciP, help_infoP);
     
/*dcl  AsciP ptr;					/* help_ subsystem's sci_ptr			(Input) */
/*dcl  help_infoP  ptr;				/* points to the help_info (hi) data structure.   (Input) */
     
     Phelp_args = hi.help_argsP;
     hi.section_search_matchedS = F;

  dcl 1 ca_cache_store aligned based (hi.CACHE_caP),	/* Cache of STRs from previous control_arg search.        */
      2 case_sensitiveS bit(1) aligned,			/*  T: search in case-sensitive manner.		        */
						/*  F: search in case-insensitive manner.	        */
      2 N fixed bin,				/* Number of items currently in the cache.	        */
      2 str (20) char(32) var;			/*  - Cache of STR values.			        */
     
  dcl 1 ca_cache aligned based (hi.CACHE_caP),
      2 case_sensitiveS bit(1) aligned,			/*  T: search in case-sensitive manner.		        */
						/*  F: search in case-insensitive manner.	        */
      2 N fixed bin,				/* Number of items currently in ca.		        */
      2 str (0 refer (ca_cache.N)) char(32) var;		/*  - Current STR values.			        */

     if  hi.CACHE_caP = null()  then do;		/* Get space for ca_cache_store for this help_ subsystem  */
	hi.CACHE_caP = hi.next_free_spaceP;
	call set_space_used (currentsize (ca_cache_store));
	ca_cache_store.case_sensitiveS = F;
	ca_cache_store.N = 0;
	ca_cache_store.str = "";
	end;

     if  ca_cache.N = 0  &  hi.Sctl.ca  then do;		/* Initialize ca_cache from help_args.ca values (if any)  */
	ca_cache_store.str = "";
	ca_cache.case_sensitiveS = hi.Sctl.cs;
	ca_cache.N = dim(help_args.ca,1);
	if  ca_cache.case_sensitiveS  then
	     ca_cache.str = help_args.ca;
	else ca_cache.str = translate (help_args.ca, LOWER_CASE, UPPER_CASE);
	end;
     

  dcl 1 ca_store aligned automatic,			/* Input arguments to the current control_arg search      */
      2 defaultable like ca_cache_store,
      2 arg_error bit(1) aligned;			/*  =T: User gave invalid control arg or positional arg   */

  dcl 1 ca aligned based (ca_storeP),
      2 defaultable,
        3 case_sensitiveS bit(1) aligned,		/*  T: search in case-sensitive manner.		        */
						/*  F: search in case-insensitive manner.	        */
        3 N fixed bin,				/* Number of items currently in ca.		        */
        3 str (0 refer (ca.N)) char(32) var,		/*  - Current STR values.			        */
      2 arg_error bit(1) aligned,			/*  =T: User gave invalid control arg or positional arg   */
       ca_storeP ptr;
     ca_storeP = addr(ca_store);

     ca_store.case_sensitiveS = F;			/*  - Get any input arguments to this response.	        */
     ca_store.N = 0;
     ca_store.str = "";
     ca_store.arg_error = F;

     call arg_setup (AsciP);				/* Process args/ctl_args given in the response.	        */
     if args_remain() then
	call Args_ca(ca_store);
     if  ca_store.arg_error  then
	call response_error (AsciP);			/*  - Error in user's response?  Abort response line.     */

     if  hi.display_mode = DISPLAY_MODE_help_request_loop then;
						/*  - Called by help_requests_$help?  Don't save args.    */
     else if  ca.N = 0  &  ca_cache.N > 0  then		/*  - If no input STRs given, use those in cache.	        */
	ca.defaultable = ca_cache;
     else if  ca.N > 0  then do;			/*  - Otherwise, overwrite cache w/ new STR and -cs value */
	if  ^ca.case_sensitiveS  then
	     ca.str = translate(ca.str, LOWER_CASE, UPPER_CASE);
	ca_cache = ca.defaultable;     
	end;

     if  dim(ca.str,1) = 0  then			/* Complain if no STRs given (or have default value)      */
	call response_error (AsciP, error_table_$noarg, 
	     "No search STRs were given, and" ||
	   "^/   the ^a response has no saved arguments from a prior use.", ssu_$get_request_name (AsciP) );
     if  hi.iBlokP = null()  then 			/* ASSERT: some info block should have been selected.     */
	call response_error (AsciP, error_table_$null_info_ptr, "Internal error: hi.iBlokP = null()");


     iBlokP = hi.iBlokP;				/* Address current block's iBlok structure.	        */

     if  hi.block_progress = BLOCK_PROGRESS_needs_header  then do;
						/* control_arg response invoked by help -control_arg ...  */
	hi.header_Nlines_follow = 0;
	call help_util_$execute (AsciP, help_infoP, "header");
	end;					/*  - display a heading describing info seg.	        */


  dcl  anything_printedS bit(1) aligned;

     anything_printedS = F;
     do iSectP = iBlok.sects.firstP			/* Examine List-type sections of this info block.	        */
	repeat iSect.sib.nextP  while (iSectP ^= null() );
	
	if  info_seg_util_$is_List_type (iSect.type)  then
	if  help_util_$print_iSect_List_match (AsciP, help_infoP, iSectP, addr(ca))  then 
	     anything_printedS = T;
	end;

     if  ^anything_printedS  then
	call response_error (AsciP, 0, "No item name matches:^/   control_arg:^v(  ^a^)",
	     ca.N, ca.str(*) );

     return;

%page;
/* ------------------------------------------------------------
   Process control_arg response arguments.
   ------------------------------------------------------------ */

Args_ca:
     proc (c);

  dcl 1 c aligned like ca_store;			/*  control arg specification data                   (in) */

     do while (args_remain());
	call ssu_$arg_ptr (AsciP, argI+1, argP, argL);	/* Conditionally read next arg to response	        */

	if isControlArg(arg) then do;

	     if       arg = "-cs"     | arg = "-case_sensitive"      then c.case_sensitiveS = T;
	     else if  arg = "-ncs"    | arg = "-non_case_sensitive"  then c.case_sensitiveS = T;

               else do;
		call error (AsciP, error_table_$badopt, "Unsupported control arg: ^a", arg);
		c.arg_error = T;
		end;
	     end;
	
	else do;					/* If arg is a -control_arg operand		        */
	     if  c.N < dim(c.str,1)  &  length(arg) <= maxlength(c.str(1))  then do;
		c.N = c.N + 1;
		c.str(c.N) = arg;
		end;

	     else if  c.N = dim(c.str,1)  then do;
		call error (AsciP, error_table_$too_many_args, "More than ^d STRs given: ^a", dim(c.str,1), arg);
		c.arg_error = T;
		end;

	     else do;
		call error (AsciP, error_table_$bigarg, 
		     "STR limited to ^d characters: ^a", maxlength(c.str(1)), arg);
		c.arg_error = T;
		end;
	     end;

	argI = argI + 1;				/* Record that we processed the arg just examined above.  */
	end;

     end Args_ca;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* RESPONSE: entry_point, entrypoint, ep					        */
	/*									        */
	/* Syntax as a response: entry_point {-match | -exact} {EP_STR} {-unseen}		        */
	/*		      entrypoint {-match | -exact} {EP_STR} {-uns}		        */
	/*		              ep {-match | -exact} {EP_STR} {-uns}		        */
	/*									        */
	/* Function: Searches subroutine :Entry: blocks for one whose entry point name equals EP_STR.     */
	/*           Selects that block for display.  If EP_STR is omitted, searches for an entry point   */
	/*           named for the subroutine reference name.  If -match is given, searches for an        */
	/*	   entry point name that contains EP_STR.				        */
	/*									        */
	/*	   If only -unseen is given, then searches for first unseen entry point, marking that   */
	/*	   entry point as "seen".  Thus, subsequent ep -uns responses will walk through the     */
	/*	   list of entry points.  If -unseen is given with an EP_STR, then searches for an      */
	/*	   unseen entry point whose entry point name contains EP_STR.		        */
	/*									        */
	/*           If EP_STR matches more than one entry point, displays a list of the matches and      */
	/*	   asks the user to issue a revised ep response with a more exact EP_STR argument.      */
	/*									        */
	/*     NOTE: Subroutines are invoked with the form:				        */
	/*	      call REFERENCE_NAME_$ENTRY_POINT_NAME (...);			        */
	/*           If the entry point name is the same as the reference name, this call could be:       */
	/*              call REFERENCE_NAME_$REFERENCE_NAME_ (...);				        */
	/*           but it is usually shortened to:					        */
	/*              call REFERENCE_NAME_ (...);					        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

entry_point:
     entry (AsciP, help_infoP);
     
/*dcl  AsciP ptr;					/* help_ subsystem's sci_ptr			(Input) */
/*dcl  help_infoP  ptr;				/* points to the help_info (hi) data structure.   (Input) */
     
     Phelp_args = hi.help_argsP;
     hi.section_search_matchedS = F;

  dcl 1 ep_store aligned,
      2 control_args,
        (3 unseenS,					/* -unseen 				        */
         3 matchS,					/* -match EP_STR				        */
         3 exactS,					/* -exact EP_STR				        */
         3 arg_error				/*  =T: User gave invalid control arg or positional arg   */
         ) bit(1) aligned,
      2 ep_str char(2*entrynameL + 1) var;		/* EP_STR (could be in the form: REFNAME_$EP_STR)	        */

     ep_store.control_args = F;
     ep_store.ep_str = "";

     call arg_setup (AsciP);
     if args_remain() then
	call Args_ep (ep_store);
     if  ep_store.arg_error  then
	call response_error (AsciP);			/*  - Error in user's response?  Abort response line.     */

/* ------------------------------------------------------------
   Get subroutine's refname_ from introduction block.
   Remove refname_$ if present in EP_STRING argument.
   ------------------------------------------------------------ */

     iFileP = hi.iFileP;				/* Access 1st info seg block.			        */
     iBlokP = iFile.relatives.bloks.firstP;

  dcl  refnames (2) char(entrynameL) var;		/* Only a few subroutines have two possible refnames      */
     refnames = "";					/*  (eg, graphic_macros_, gmc_  in graphic_macros_.info). */
  dcl  testname char(entrynameL) var;

     if  dim(Blok_words,1) >= 1  then			/* 1st (or 1st and 2nd) words of subroutine intro heading */
	refnames (1) = Blok_words(1);			/*  line are its refname_ value(s).		        */
     if  dim(Blok_words,1) >= 2  then
	refnames (2) = Blok_words(2);
     if  refnames(1) = ""  then
	call response_error (AsciP, 0, "No subroutine reference name in heading line of first block of info segment.");

     if  index(ep_store.ep_str, DOLLAR_SIGN) > 0  then do;	/* ep REFNAME_$EP_STR  =>  ep EP_STR		        */
	testname = before(ep_store.ep_str, DOLLAR_SIGN);
	if  testname = ""  then 
	     goto REFNAME_MATCH;
	if  testname = refnames(1) | testname = refnames(2)  then do;
REFNAME_MATCH: testname = after(ep_store.ep_str, DOLLAR_SIGN);
	     if  testname = ""  then 
		call response_error (AsciP, 0, "Empty EP_STR following $ in argument: ^a", ep_store.ep_str);
	     end;
	else call response_error (AsciP, 0, "Unknown reference name (^a) in argument: ^a", testname, ep_store.ep_str);
	end;
     else testname = ep_store.ep_str;


/* ------------------------------------------------------------
   Apply default EP_STRING.  
   Handle a 1-block subroutine info seg (e.g., match_star_name_.info).
   ------------------------------------------------------------ */

     if  ^ep_store.unseenS  &  testname = ""  then	/* ep WITHOUT -unseen  =>  ep REFNAME_		        */
	testname = refnames(1);

     if  iFile.relatives.bloks.firstP = iFile.relatives.bloks.lastP  then do;
						/* If 1-block info with refname_ = entrypoint_name, then  */
	if  index(refnames(1), testname) > 0  then do;
	     hi.prompt_repeatS = T;			/*  - We're already positioned in only block.  Stop now.  */
	     hi.section_search_matchedS = T;
	     return;
	     end;
	call response_error (AsciP, 0, "No match for entry point name: ^a", testname);
	end;					/*  - Report error.  This call does not return.	        */

/* ------------------------------------------------------------
   Search for matching entry points.
   ------------------------------------------------------------ */

  dcl  matching_iBlokP ptr;
     matching_iBlokP = null();
  dcl  nmI fixed bin;				/* Declare index of block divider names.	        */
     nmI = 1;
  dcl 1 u aligned like iName100;			/* Declare list of unseen entry points.		        */
     u.N = 0;
     u.nm = "";

ENTRY_POINT_SEARCH:
     do iBlokP = iBlok.sib.nextP			/* Search from first :Entry: after subr intro block.      */
         repeat iBlok.sib.nextP  while (iBlokP ^= null() );
	if  ep_store.unseenS  then do;		/*  -unseen?				        */
	     if  ^iBlok.seenS  then do;		/*    and block has not been seen...		        */
		if  ep_store.ep_str ^= ""  then	/*     EP_STR given?			        */
		     goto ENTRY_POINT_NAME_TEST;	/*      +yes => test names			        */
		else goto ENTRY_POINT_NAME_MATCH;	/*      +no  => unseen block matches		        */
		end;
	     end;
	else 
ENTRY_POINT_NAME_TEST:
	do nmI = lbound(Blok_names,1) to hbound(Blok_names,1);
	     if  ^ep_store.matchS  &  Blok_names(nmI) = testname  then
		goto ENTRY_POINT_NAME_EXACT_MATCH;
	     else if  ^ep_store.exactS  &  index(Blok_names(nmI), testname) > 0  then
		goto ENTRY_POINT_NAME_MATCH;
	     end;
	goto ENTRY_POINT_NEXT;

ENTRY_POINT_NAME_MATCH:
	if  matching_iBlokP = null()  then
	     matching_iBlokP = iBlokP;		/* Remember pointer to first matching :Entry: block.      */
	u.N = u.N + 1;				/* Add matching name to list of matching :Entry: blocks.  */
	u.nm(u.N) = Blok_names(nmI);
ENTRY_POINT_NEXT:
	end ENTRY_POINT_SEARCH;
     
     if  u.N = 0					/* Neither -exact nor -match given...		        */
      &  ^ep_store.exactS				/*  then an exact search was performed above.	        */
      &  ^ep_store.matchS  then do;			/*  - If exact match failed, search again with -match     */
	ep_store.matchS = T;
	iBlokP = iFile.relatives.bloks.firstP;		/*     - Search starts just after subr intro block.       */
	goto ENTRY_POINT_SEARCH;
	end;


/* ------------------------------------------------------------
   If one entry point selected, switch to that entry point's block.
   Otherwise, report results so user may give a further response.
   ------------------------------------------------------------ */

     if  u.N = 0  then do;				/* Report if no :Entry: block names matched.	        */
	call ioa ("No^[ unseen^] entry point^[s.^s^; name ^[match^;equal^]ed: ^a^]", 
	     ep_store.unseenS, testname = "", ep_store.matchS, testname);
	if  ep_store.unseenS  then			/* If -unseen given, all :Entry: blocks "seen" so we are  */
	     goto hi.NEXT_INFO_LABEL;			/*  done with subroutine info seg.		        */
	hi.prompt_repeatS = T;			/* Otherwise, reprompt to let user respond again.	        */
	return;
	end;
     
     if  u.N = 1  then do;				/* If one entrypoint matches, switch to that :Entry:      */
ENTRY_POINT_SELECT:
	if  ep_store.unseenS  then			/*  - If selecting unseen :Entry: blocks, stay with this  */
	     Dinfo_item.ep = "";			/*    subroutine info seg even if all paragraphs of       */
						/*    selected :Entry: block have been seen.	        */
						/*     [help_listen_util_$display_prompt stays with subr  */
						/*      info seg if Dinfo_item.ep is empty string.]       */

	iBlokP = matching_iBlokP;			/*  - Get pointer to only matching :Entry: block.	        */
	hi.section_search_matchedS = T;

	if  iBlokP = hi.iBlokP  then do;		/*  - We're already positioned in given block.  Stop now. */
	     hi.prompt_repeatS = T;
	     return;
	     end;
     
	hi.iBlokP = iBlokP;				/*  - Select "top" paragraph in matching block.	        */
	hi.selected, hi.iPgh_print_range = null();

	hi.display_limit = DISPLAY_LIMIT_section;	/*  - Automatically display first section of new block.   */
	hi.selected.iSectP = iBlok.relatives.sects.firstP;

	goto hi.ANOTHER_BLOCK_LABEL;			/*  - Switch to block in same info seg...	        */
	end;
	
     if  ep_store.unseenS  &  testname = ""  then do;	/*  -unseen with no EP_STR ...		        */
	call newline (1);
	call ioa ("Selecting the first of ^d unseen entry points.", u.N);
	goto ENTRY_POINT_SELECT;			/*    Choose the first unseen :Entry: block for display.  */
	end;
     
     call newline (1);				/*  Multiple :Entry: blocks match response arguments.     */
     call ioa ("^d^[ unseen^] entry points match: ^a", u.N, ep_store.unseenS, testname);
						/*   - Display the list.			        */
     do nmI = 1 to u.N;
	call ioa ("   ^a^[$^a^;^s^]", refnames(1), u.nm(nmI) ^= refnames(1), u.nm(nmI) );
	end;
     call newline (1);
     call ioa ("Please give a specific EP_STR argument to select one entry point for display.");
     hi.prompt_repeatS = T;				/*   - Ask user to be more specific.		        */
     hi.clear_prompt_regionS = F;			/*   - Do not clear prompts following ep request.	        */
     return;

ENTRY_POINT_NAME_EXACT_MATCH:
     matching_iBlokP = iBlokP;
     u.N = 1;
     u.nm(1) = Blok_names(nmI);
     goto ENTRY_POINT_SELECT;
%page;
/* ------------------------------------------------------------
   Process entry_point response arguments.
   ------------------------------------------------------------ */

Args_ep:
     proc (c);

  dcl 1 c aligned like ep_store;			/*  control arg specification data                   (in) */

     do while (args_remain());
	call ssu_$arg_ptr (AsciP, argI+1, argP, argL);	/* Conditionally read next arg to response	        */

	if isControlArg(arg) then do;

	     if       arg = "-uns"    | arg = "-unseen"     then  c.unseenS = T;
	     else if		  arg = "-match"      then do;  c.matchS = T; c.exactS = F;  end;
	     else if		  arg = "-exact"      then do;  c.exactS = T; c.matchS = F;  end;

	     else do;
		call error (AsciP, error_table_$badopt, "Unsupported control arg: ^a", arg);
		c.arg_error = T;
		end;
	     end;
	
	else do;					/* If arg is a ep_str argument		        */
	     if  c.ep_str = ""  &  length(arg) <= maxlength(c.ep_str)  then do;
		c.ep_str = arg;
		end;

	     else if  c.ep_str ^= ""  then do;
		call error (AsciP, error_table_$too_many_args, "More than 1 EP_STRING given: ^a", arg);
		c.arg_error = T;
		end;

	     else do;
		call error (AsciP, error_table_$bigarg, 
		     "EP_STRING limited to ^d characters: ^a", maxlength(c.ep_str), arg);
		c.arg_error = T;
		end;
	     end;

	argI = argI + 1;				/* Record that we processed the arg just examined above.  */
	end;

     end Args_ep;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* RESPONSE: every_paragraph_visible, every					        */
	/*									        */
	/* Syntax as a response:   every_paragraph_visible, every				        */
	/*									        */
	/* Function:								        */
	/*   1) changes hi.display_limit to DISPLAY_LIMIT_none.				        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

every_paragraph_visible:
     entry (AsciP, help_infoP);
     
/*dcl  AsciP ptr;					/* help_ subsystem's sci_ptr			(Input) */
/*dcl  help_infoP  ptr;				/* points to the help_info (hi) data structure.   (Input) */
     
     call arg_setup (AsciP);				/* Error if any arguments given after the request name.   */
     if args_remain() then
	call response_error (AsciP, 0, "No arguments may be given.");

     if  hi.iBlokP = null()  then 			/* ASSERT: some info block should have been selected.     */
	call response_error (AsciP, error_table_$null_info_ptr, "Internal error: hi.iBlokP = null()");

     hi.iPgh_print_range = null();			/* Turn off any current print range.		        */

     hi.display_limit = DISPLAY_LIMIT_none;
     hi.prompt_repeatS = T;				/*  - Needed to prompt for current location and limit.    */

     return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* RESPONSE: find_info, find	(hi.display_mode = DISPLAY_MODE_non_subroutine		        */
	/*	   find_ep, find    (hi.display_mode = DISPLAY_MODE_subroutine		        */
	/*									        */
	/* Syntax as a help control:  {-section  STRs | -search STRS}  {-case_sensitive},	        */
          /*                                {-scn  STRs | -srh STRs}     {-cs}			        */
	/*									        */
	/* Syntax as a response: find_info {STRs} {-case_sensitive} {-top}, (DISPLAY_MODE_non_subroutine) */
	/*                            find {STRs} {-cs} {-t}				        */
	/*                         find_ep {STRs} {-case_sensitive} {-top},     (DISPLAY_MODE_subroutine) */
	/*                            find {STRs} {-cs} {-t}				        */
	/*									        */
	/* Function: As a response, searches forward from the most recently-displayed block to find       */
	/*	   the next block with paragraph containing a string matching one of the STRs.  First   */
	/*	   of those subsequent blocks that matches becomes the current block selected for       */
	/*	   display.							        */
	/*									        */
	/*           As a help control, this routine is called only to locate the first subroutine        */
	/*	   entry point containing a paragraph matching one of the -srh or -scn strings.         */
	/*	   Note that the section title is included as part of paragraph text to be searched.    */
	/*									        */
	/*	   The find_ep arguments come initially from help_args.Sctl.scn, help_args.Sctl.cs, and */
	/*           help_args.scn(*) values; or from help_args.Sctl.srh, help_args.Sctl.cs, and          */
	/*           help_args.srh(*) values, or both.  If both are given, the STR values are merged.     */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

find_info:
     entry (AsciP, help_infoP);
     
/*dcl  AsciP ptr;					/* help_ subsystem's sci_ptr			(Input) */
/*dcl  help_infoP  ptr;				/* points to the help_info (hi) data structure.   (Input) */
     
     Phelp_args = hi.help_argsP;
     hi.section_search_matchedS = F;


  dcl 1 find_cache_store aligned based (hi.CACHE_findP),	/* Cache of STRs from previous find_info operation.       */
      2 case_sensitiveS bit(1) aligned,			/*  T: search in case-sensitive manner.		        */
						/*  F: search in case-insensitive manner.	        */
      2 N fixed bin,				/* Number of items currently in the cache.	        */
      2 str (20) char(32) var;			/*  - Cache of STR values.			        */
     
  dcl 1 find_cache aligned based (hi.CACHE_findP),
      2 case_sensitiveS bit(1) aligned,			/*  T: search in case-sensitive manner.		        */
						/*  F: search in case-insensitive manner.	        */
      2 N fixed bin,				/* Number of items currently in ca.		        */
      2 str (0 refer (find_cache.N)) char(32) var;	/*  - Current STR values.			        */

  dcl  findI fixed bin;

     if  hi.CACHE_findP = null()  then do;		/* Get space for ca_cache_store for this help_ subsystem  */
	hi.CACHE_findP = hi.next_free_spaceP;
	call set_space_used (currentsize (find_cache_store));
	find_cache_store.case_sensitiveS = F;
	find_cache_store.N = 0;
	find_cache_store.str = "";
	end;

     if  find_cache.N = 0				/* For subroutine info, help -search/-section args are    */
      &  hi.block_progress = BLOCK_PROGRESS_section_search	/*  implemented using find_ep response.  Load those       */
      &  (hi.Sctl.srh | hi.Sctl.scn)  then do;		/*  operands now.				        */
	find_cache_store.str = "";			/*  - Empty find_cache_store.			        */
	find_cache.case_sensitiveS = hi.Sctl.cs;	/*  - help -case_sensitive applies to -search/-section    */

	if  hi.Sctl.srh  then do;			/*  - Copy -search operands into find_cache	        */
	     do findI = lbound(help_args.srh,1) to hbound(help_args.srh,1) 
		while (find_cache.N < dim(find_cache_store.str,1));
		find_cache.N = find_cache.N + 1;
		if  find_cache.case_sensitiveS  then
		     find_cache.str(find_cache.N) = help_args.srh(findI);
		else find_cache.str(find_cache.N) = translate(help_args.srh(findI), LOWER_CASE, UPPER_CASE);
		end;
	     end;

	if  hi.Sctl.scn  then do;			/*  - Append -section operands to the find_cache.	        */
	     do findI = lbound(help_args.scn,1) to hbound(help_args.scn,1) 
		while (find_cache.N < dim(find_cache_store.str,1));
		find_cache.N = find_cache.N + 1;
		if  find_cache.case_sensitiveS  then
		     find_cache.str(find_cache.N) = help_args.scn(findI);
		else find_cache.str(find_cache.N) = translate(help_args.scn(findI), LOWER_CASE, UPPER_CASE);
		end;
	     end;
	end;


  dcl 1 find_store aligned automatic,			/* Input arguments to the current search response.        */
      2 arg_error bit(1) aligned,			/*  =T: User gave invalid control arg or positional arg   */
      2 topS bit(1) aligned,
      2 defaultable like find_cache_store;

  dcl 1 find aligned based (find_storeP),
      2 arg_error bit(1) aligned,			/*  =T: User gave invalid control arg or positional arg   */
      2 topS bit(1) aligned,
      2 defaultable,
        3 case_sensitiveS bit(1) aligned,		/*  T: search in case-sensitive manner.		        */
						/*  F: search in case-insensitive manner.	        */
        3 N fixed bin,				/* Number of items currently in find.		        */
        3 str (0 refer (find.N)) char(32) var,		/*  - Current STR values.			        */
       find_storeP ptr;
     find_storeP = addr(find_store);

     find_store.arg_error = F;			/*  - Get any input arguments to this response.	        */
     find_store.topS = F;
     find_store.case_sensitiveS = F;
     find_store.N = 0;
     find_store.str = "";

     call arg_setup (AsciP);
     if args_remain() then
	call Args_find (find_store);
     if  find_store.arg_error  then
	call response_error (AsciP);			/*  - Error in user's response?  Abort response line.     */

     if  find.N = 0  &  find_cache.N > 0  then		/*  - If no input STRs given, use those in cache.	        */
	find_store.defaultable = find_cache_store;
     else if  find.N > 0  then do;			/*  - Otherwise, overwrite cache w/ new STR and -cs value */
	if  ^find.case_sensitiveS  then
	     find.str = translate(find.str, LOWER_CASE, UPPER_CASE);
	find_cache_store = find_store.defaultable;     
	end;

     if  dim(find.str,1) = 0  then 			/* Complain if no STRs given (nor have default value)     */
	call response_error (AsciP, error_table_$noarg, 
	     "No search STRs were given, and" ||
	   "^/   the ^a response has no saved arguments from a prior use.", ssu_$get_request_name (AsciP) );

     iFileP = hi.iFileP;
     iBlokP = hi.iBlokP;				/* Starting from current block of info segment...	        */

     if  find.topS  then do;				/* -top?  Begin searching in first block of file.	        */
	iBlokP = iFile.relatives.bloks.firstP;
	if  iBlokP = null()  then 			/*  - Hmm, a file with no blocks.  It's possible but      */
						/*    not sure help could ever get to this response       */
						/*    program with such file.			        */
	     call response_error (AsciP, error_table_$empty_file, 
		"Info segment contains no info blocks.  No matching paragraph found.");
	end;
     else if  iBlokP = null()  then 			/* ASSERT: some info block should have been selected.     */
	call response_error (AsciP, error_table_$null_info_ptr, "Internal error: hi.iBlokP = null()");
						/*   - return if no current block defined for file.       */
     else if  hi.iBlokP = iFile.relatives.bloks.lastP  then /* Last block of file?  Then return with nomatch.	        */
	goto FIND_NO_MATCH;
     else iBlokP = iBlok.sib.nextP;			/* Begin searching in next block of file.	        */

     
line_matches_STR:					/* Line comparison routine.			        */
     	proc (line) returns (bit(1) aligned);
	
  dcl  line char(*);				/* Incoming line to examine.			        */

  dcl  line_ char(HELP_LINE_SIZE_MAX) var;		/* Space to translate an info line to lower case for      */
						/*   non-case-senstive searches.		        */

	if ^find.case_sensitiveS  then
	     line_ = translate (line, LOWER_CASE, UPPER_CASE);

	do findI = lbound(find.str,1) to hbound(find.str,1);
	     if  find.case_sensitiveS  then
		if  index(line, find.str(findI)) > 0  then
		     return (T);
		else;
	     else if  index(line_, find.str(findI)) > 0  then
		     return (T);
		else;
	     end;
	return (F);
	end line_matches_STR;
     

FIND_IN_BLOCKS:
     do iBlokP = iBlokP				/* Walk thru info blocks until a match is found.	        */
	repeat iBlok.sib.nextP  while (iBlokP ^= null() );

	if  iBlokP = hi.iBlokP  then			/* Don't inspect "current block" if -top given.	        */
	     goto FIND_NEXT_BLOCK;

	if  line_matches_STR (string(iBlok.header.reformatted))  then
	     goto FIND_MATCH;

	iPghP = iBlok.relatives.pghs.firstP;

FIND_IN_PARAGRAPHS:
	do iPghP = iPghP				/* Search forward thru paragraphs looking for  match.     */
	    repeat iPgh.sibs.blok.nextP  while (iPghP ^= null() );

	     do iLineP = iPgh.lines.firstP
		repeat iLine.sibs.blok.nextP  while (iLineP ^= null() );
		if  line_matches_STR (Line)  then
		     goto FIND_MATCH;
		end;
	     end FIND_IN_PARAGRAPHS;
FIND_NEXT_BLOCK:
	end FIND_IN_BLOCKS;

FIND_NO_MATCH:
     if  hi.block_progress = BLOCK_PROGRESS_display  then	/* Complain if user response found no match.	        */
	call ioa ("No matching header or paragraph found.");	
     hi.section_search_matchedS = F;			/*  - Report to calling environment: search found no pgh. */
     hi.prompt_repeatS = T;				/*  - Repeat prompt describing current sections.	        */
     return;					/*  - Silently return if help -search contro not matched. */

FIND_MATCH:
     hi.section_search_matchedS = T;			/* Report to caller that find op found desired block.     */

     if  iBlokP = hi.iBlokP  then;			/* If not switching blocks, don't change position in block*/
     else do;					/* Otherwise:				        */
	hi.iBlokP = iBlokP;				/*  - Select "top" paragraph in matching block.	        */
	hi.selected, hi.iPgh_print_range = null();
	goto hi.ANOTHER_BLOCK_LABEL;			/*  - Switching to other block in same info seg...        */
	end;
     return;
%page;
/* ------------------------------------------------------------
   Process find response arguments.
   ------------------------------------------------------------ */

Args_find:
     proc (c);

  dcl 1 c aligned like find_store;			/*  control arg specification data                   (in) */

     do while (args_remain());
	call ssu_$arg_ptr (AsciP, argI+1, argP, argL);	/* Conditionally read next arg to response	        */

	if isControlArg(arg) then do;

	     if       arg = "-cs"     | arg = "-case_sensitive"      then c.case_sensitiveS = T;
	     else if  arg = "-ncs"    | arg = "-non_case_sensitive"  then c.case_sensitiveS = T;

	     else if  arg = "-t"      | arg = "-top"                 then c.topS = T;
	     

               else do;
		call error (AsciP, error_table_$badopt, "Unsupported control arg: ^a", arg);
		c.arg_error = T;
		end;
	     end;
	
	else do;					/* If arg is a find_info argument		        */
	     if  c.N < dim(c.str,1)  &  length(arg) <= maxlength(c.str(1))  then do;
		c.N = c.N + 1;
		c.str(c.N) = arg;
		end;

	     else if  c.N = dim(c.str,1)  then do;
		call error (AsciP, error_table_$too_many_args, "More than ^d STRs given: ^a", dim(c.str,1), arg);
		c.arg_error = T;
		end;

	     else do;
		call error (AsciP, error_table_$bigarg, 
		     "STR limited to ^d characters: ^a", maxlength(c.str(1)), arg);
		c.arg_error = T;
		end;
	     end;

	argI = argI + 1;				/* Record that we processed the arg just examined above.  */
	end;

     end Args_find;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* RESPONSE: header, he							        */
	/*									        */
	/* Displays heading line(s) describing:						        */
	/*  - current info segment;							        */
	/*  - current info block, with count of total lines in block;			        */
	/*  - next section to display (if any) with a count of lines upcoming.		        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

header:
     entry (AsciP, help_infoP);
     
/*dcl  AsciP ptr;					/* help_ subsystem's sci_ptr			(Input) */
/*dcl  help_infoP  ptr;				/* points to the help_info (hi) data structure.   (Input) */
     
     Phelp_args = hi.help_argsP;

  dcl  another_blokS bit(1) aligned,
       Nlines_follow char(20) var,
       Nlines_in_info char(60) var,
       heading char(HELP_LINE_SIZE_MAX) var,
       ignore_len fixed bin(21),
       info_name char(60) var,
       nlS bit(1) aligned,
      (path, full_path) char(168) var;

  dcl  HEADING_COUNT fixed bin int static options(constant) init(2);

     call arg_setup (AsciP);				/* Error if any arguments given after the request name.   */
     if args_remain() then
	call response_error (AsciP, 0, "No arguments may be given.");

     if  hi.iBlokP = null()  then
	call response_error (AsciP, error_table_$null_info_ptr, "Internal error: hi.iBlokP = null()");

     iFileP = hi.iFileP;
     iBlokP = hi.iBlokP;

     full_path = rtrim (pathname_ (Dinfo_item.dir, Dinfo_item.ent));
     if  hi.Sctl.he_pn  then				/*  - Format pathname.			        */
	path = full_path;
     else path = "";

     if  Dinfo_item.Scross_ref  &  ^hi.Sctl.he_pn  then	/* Don't display cross_ref entries if header paths are    */
	return;					/*   not being displayed.			        */
     if  Dinfo_item.Scross_ref  then do;		/* Alternate version of info seg found later in search?   */

	if  hi.Dinfo_last_cross_refI = 0		/*  - Print an "Other versions..." caption.	        */
	 |  hi.Dinfo_last_cross_refI + 1 < hi.Dinfo_sort_ptrsI  then do;
	     call newline ((help_args.Lspace_between_infos));
	     call ioa ("^a: Other versions of the info above were found.  See also:",
	          ssu_$get_subsystem_name (hi.sciP) );
	     end;

	call ioa ("  ^a", full_path);			/*  - List pathname of other version(s).	        */

	hi.Dinfo_last_cross_refI = hi.Dinfo_sort_ptrsI;	/*  - Remember that we've already printed caption if a    */
						/*     2nd/3rd alternate is found.		        */
						/*  - Don't print heading for alternate versions.	        */

	hi.block_progress = BLOCK_PROGRESS_display;	/*  - Indicate a header already displayed.	        */
	return;					/*  - Don't do anything further with this info block.     */
	end;
%page;     
HEADER_common_data:
     info_name = "";				/* Assume no info_name has been given.		        */

     Nlines_follow, Nlines_in_info = "";
     if  ^hi.Sctl.he_counts then
	hi.header_Nlines_follow = 0;
     else if  hi.header_Nlines_follow > 0  then do;
	if  hi.block_progress = BLOCK_PROGRESS_needs_header  then
	     hi.header_Nlines_follow = hi.header_Nlines_follow + HEADING_COUNT;
	call ioa_$rsnnl ("^d ^[lines follow^;line follows^]; ",
	     Nlines_follow, ignore_len, hi.header_Nlines_follow, hi.header_Nlines_follow > 1);

	if  hi.header_Nlines_follow = iBlok.line_count  then
	     Nlines_follow = "";			/* No (nn lines follow;...) if entire block being printed */

	hi.header_Nlines_follow = 0;
	end;
     
     heading = rtrim (string (iBlok.header.reformatted));

     another_blokS = hi.another_blockS;
     hi.another_blockS = F;

     if  hi.display_mode = DISPLAY_MODE_subroutine  then
	goto HEADER_subroutine;


HEADER_nonsubroutine:
     if  another_blokS  then				/*  - Format Info: field.			        */
	info_name = SP_SP || after (iBlok_token(iBlok.divider), COLON) || SP_SP || Blok_names(1);
     else if ^hi.Sctl.he_pn  |  ^hi.Sctl.he_info_name  then;
     else if  hi.Sctl.he_info_name  then do;
	if  Dinfo_item.info_name ^= ""  then do;
	     do nmI = lbound(Blok_names,1) to hbound(Blok_names,1);
		if  Dinfo_item.info_name = Blok_names(nmI)  then do;
		     info_name = SP_SP || after (iBlok_token(iBlok.divider), COLON) || SP || rtrim(Dinfo_item.info_name);
		     goto HEADER_done_info_name;
		     end;
		end;

	     info_name = SP_SP || after (iBlok_token(iBlok.divider), COLON) || SP_SP || Blok_names(1);
	     end;
	end;
     

HEADER_done_info_name:
     if  hi.Sctl.he_counts  then
	call ioa_$rsnnl ("^d line^[s^] in info",
	     Nlines_in_info, ignore_len, iBlok.line_count, iBlok.line_count > 1);


     if  hi.Sctl.he_only  then do;			/* Only printing header for block, plus its heading line. */
						/*   Print all data listed above, plus heading line.      */

	nlS = (  length(path)            + length(info_name)        + length(SP_SP_SP) + length(heading) 
	       + length(SP_SP_SP_PARENS) + length(Nlines_in_info) ) > hi.terminal_lineL;
						/*  - Will header (including info heading) fit on 1 line? */

	call ioa ("^a^a^[^/^]^[^3x^]^a^[^3x(^a)^;^s^]", 
	     path, info_name, nlS, hi.Sctl.he_pn, heading, hi.Sctl.he_counts, Nlines_in_info);
						/* PATHNAME [  Info: INFO_NAME]  INFO_HEADING  LINES_INFO */

	hi.block_progress = BLOCK_PROGRESS_display;	/*  - Indicate a header already displayed.	        */
	hi.Sctl.he_only = F;			/*  - Turn off .he_only switch for this info seg.	        */
	return;					/*  - Don't do anything further with this info block.     */
	end;


     if  hi.block_progress = BLOCK_PROGRESS_needs_header  then do;

	nlS = (  length(path)          + length(info_name)        + length(SP_SP_SP_PARENS) 
	       + length(Nlines_follow) + length(Nlines_in_info) ) > hi.terminal_lineL;
						/*  - Will header info fit on 1 line?		        */

	if  hi.Sctl.he_pn | hi.Sctl.he_counts  then do;
	     call newline (1);
	     call ioa ("^a^a^[^/^]^[^3x(^va^a)^;^3s^]", 
	          path, info_name, nlS,
		hi.Sctl.he_counts, length(Nlines_follow),  Nlines_follow, Nlines_in_info);
	     end;					/* PATHNAME [ Info: INFO_NAME]  (LINES_FOLLOW; LINES_INFO)*/
	call newline (1);
	call ioa ("^a", heading);
	call newline (1);

	hi.block_progress = BLOCK_PROGRESS_display;
	return;
	end;

     else if  another_blokS  then do;
	call newline (1);
	call ioa ("^a^[^3x^]^[(^a)^;^s^]", 
	     after(info_name, SP_SP), hi.Sctl.he_pn, hi.Sctl.he_counts, Nlines_in_info);
	     					/* Info: INFO_NAME  (LINES_INFO)		        */
	call newline (1);
	call ioa ("^a", heading);
	call newline (1);

	hi.block_progress = BLOCK_PROGRESS_display;
	return;
	end;

     else do;					/* User entered "header" response?		        */
	call newline (1);				/*  - This always includes full pathname of info seg.     */
	call ioa ("^a^a^[^3x(^a)^;^s^]", 
	     full_path, info_name, hi.Sctl.he_counts, Nlines_in_info);
						/* PATHNAME [ Info: INFO_NAME]  (LINES_INFO)	        */
	call ioa ("^a", heading);
	call newline (1);

	hi.block_progress = BLOCK_PROGRESS_display;
	return;
	end;
     return;
%page;

HEADER_subroutine:
     iBloksN.version = iBloksN_version_2;
     call info_seg_util_$count_file_blocks (hi.iFileP, addr(iBloksN));
                                                            /* Count number of blocks found in info segment.          */

     if  iBloksN.all = 1  then 			/* 1-block subroutine (like match_star_name_.info)        */
	goto HEADER_subroutine_ONE_BLOCK;
     
     if  iBlok.kind = iBlok_kind_SUBROUTINE_ENTRY  then
	goto HEADER_subroutine_ENTRY_BLOCK;
     

HEADER_subroutine_INTRO_BLOCK:
     if ^hi.Sctl.he_counts then;
     else if  hi.Sctl.all  then 
	call ioa_$rsnnl ("^d lines; ^d entry point^[s^] in info",
	     Nlines_in_info, ignore_len, help_util_$count_file_lines (AsciP, help_infoP, iFileP), 
	     iBloksN.Entry, iBloksN.Entry > 1);
     else call ioa_$rsnnl ("^d lines in intro; ^d entry point^[s^] in info",
	     Nlines_in_info, ignore_len, iBlok.line_count, iBloksN.Entry, iBloksN.Entry > 1);


     if  hi.Sctl.he_only  then do;			/* Only printing header for block, plus its heading line. */
						/*   Print all data listed above, plus heading line.      */

	nlS = (  length(path)           + length(SP_SP_SP)   + length(heading)   + length(SP_SP_SP_PARENS)  
	       + length(Nlines_in_info) > hi.terminal_lineL);
						/*  - Will header (including info heading) fit on 1 line? */

	call newline (1);
	call ioa ("^a^[^/^]^[^3x^]^a^[^3x(^a)^;^s^]", 
	     path, nlS, hi.Sctl.he_pn, heading, hi.Sctl.he_counts, Nlines_in_info);
						/* PATHNAME   INFO_HEADING  (LINES_INFO; EPs_INFO)        */

	hi.block_progress = BLOCK_PROGRESS_display;	/*  - Indicate a header already displayed.	        */
	hi.Sctl.he_only = F;			/*  - Turn off .he_only switch for this info seg.	        */
	return;					/*  - Don't do anything further with this info block.     */
	end;


     if  hi.block_progress = BLOCK_PROGRESS_needs_header  then do;

	nlS = ( length(path) + length(SP_SP_SP_PARENS) + length(Nlines_in_info) > hi.terminal_lineL);
						/*  - Will header fit on 1 line?		        */

	if  hi.Sctl.he_pn | hi.Sctl.he_counts  then do;
	     call newline (1);
	     call ioa ("^a^[^/^]^[^3x(^va^a)^;^3s^]", 
	          path, nlS, 
		hi.Sctl.he_counts, length(Nlines_follow), Nlines_follow, Nlines_in_info);
	     end;					/* PATHNAME   (LINES_FOLLOW; LINES_INFO; EPs_INFO)        */
	call newline (1);
	call ioa ("^a", heading);
	call newline (1);

	hi.block_progress = BLOCK_PROGRESS_display;
	return;
	end;

     else do;					/* User entered "header" response?		        */
	call newline (1);
	call ioa ("^a^[^3x(^a)^]", 
	     full_path, hi.Sctl.he_counts, Nlines_in_info);    
						/* PATHNAME   (LINES_FOLLOW; LINES_INFO; EPs_INFO)        */
	call ioa ("^a", heading);
	call newline (1);

	hi.block_progress = BLOCK_PROGRESS_display;
	return;
	end;
     return;

HEADER_subroutine_ENTRY_BLOCK:
     if  hi.Sctl.he_counts  then
	call ioa_$rsnnl ("^d line^[s^] in entry point; ^[1 entry point^2s^;^d other entry point^[s^]^] in info",
	     Nlines_in_info, ignore_len, iBlok.line_count, iBlok.line_count > 1, 
	     iBloksN.Entry = 1, iBloksN.Entry-1, iBloksN.Entry-1 ^= 1);


     if  hi.Sctl.he_only  then do;			/* Only printing header for block, plus its heading line. */
						/*   Print all data listed above, plus heading line.      */

	nlS = (  length(path)             + length(SP_SP_SP)    + length(heading)   + length(SP_SP_SP_PARENS) 
	       + length(Nlines_in_info) ) > hi.terminal_lineL;
						/*  - Will header (including info heading) fit on 1 line? */

	call newline (1);
	call ioa ("^a^[^/^]^[^3x^]^a^[^3x(^a)^;^s^]", 
	     path, nlS, hi.Sctl.he_pn, heading, hi.Sctl.he_counts, Nlines_in_info);
						/* PATHNAME   INFO_HEADING  (LINES_INFO; EPs_INFO)        */

	hi.block_progress = BLOCK_PROGRESS_display;	/*  - Indicate a header already displayed.	        */
	hi.Sctl.he_only = F;			/*  - Turn off .he_only switch for this info seg.	        */
	return;					/*  - Don't do anything further with this info block.     */
	end;


     if  hi.block_progress = BLOCK_PROGRESS_needs_header  then do;

	nlS = (length(path) + length(SP_SP_SP_PARENS) + length(Nlines_in_info) ) > hi.terminal_lineL;
						/*  - Will header fit on 1 line?		        */

	if  hi.Sctl.he_pn | hi.Sctl.he_counts  then do;
	     call newline (1);
	     call ioa ("^a^[^/^]^[^3x(^va^a)^;^3s^]", 
	          path, nlS, 
		hi.Sctl.he_counts, length(Nlines_follow), Nlines_follow, Nlines_in_info);
	     end;					/* PATHNAME  (LINES_FOLLOW; LINES_INFO; EPs_INFO )        */
	call newline (1);
	call ioa ("Entry:  ^a", heading);
	call newline (1);

	hi.block_progress = BLOCK_PROGRESS_display;
	return;
	end;

     else if  another_blokS  then do;			/* Changed from intro or :Entry: to another :Entry:       */
	call newline (1);
	call ioa ("Entry:  ^a^[^3x(^a)^;^s^]", 
	     after(heading, SP_SP), hi.Sctl.he_counts, Nlines_in_info);
						/* Entry: ENTRYNAME  (LINES_INFO; EPs_INFO)	        */
	call newline (1);
	call ioa ("^a", heading);
	call newline (1);

	return;
	end;

     else do;					/* User entered "header" response?		        */
	call newline (1);
	call ioa ("^a^[^3x(^a)^;^s^]", 
	     full_path, hi.Sctl.he_counts, Nlines_in_info);
						/* PATHNAME  (LINES_FOLLOW; LINES_INFO; EPs_INFO )        */
	call ioa ("Entry:  ^a", heading);
	call newline (1);

	hi.block_progress = BLOCK_PROGRESS_display;
	return;
	end;
     return;

HEADER_subroutine_ONE_BLOCK:
     if  hi.Sctl.he_counts  then
	call ioa_$rsnnl ("^d line^[s^] & 1 entry point in info",
	     Nlines_in_info, ignore_len, iBlok.line_count, iBlok.line_count > 1);


     if  hi.Sctl.he_only  then do;			/* Only printing header for block, plus its heading line. */
						/*   Print all data listed above, plus heading line.      */

	nlS = (  length(path)             + length(SP_SP_SP)    + length(heading)   + length(SP_SP_SP_PARENS)
	       + length(Nlines_in_info) ) > hi.terminal_lineL;
						/*  - Will header (including info heading) fit on 1 line? */

	call newline (1);
	call ioa ("^a^[^/^]^[^3x^]^a^[^3x(^a)^;^s^]", 
	     path, nlS, hi.Sctl.he_pn, heading, hi.Sctl.he_counts, Nlines_in_info);
						/* PATHNAME  INFO_HEADING  (LINES_INFO EPs_INFO)	        */

	hi.block_progress = BLOCK_PROGRESS_display;	/*  - Indicate a header already displayed.	        */
	hi.Sctl.he_only = F;			/*  - Turn off .he_only switch for this info seg.	        */
	return;					/*  - Don't do anything further with this info block.     */
	end;


     if  hi.block_progress = BLOCK_PROGRESS_needs_header  then do;

	nlS = ( length(path) + length(SP_SP_SP_PARENS) + length(Nlines_in_info) > hi.terminal_lineL);
						/*  - Will header fit on 1 line?		        */

	if  hi.Sctl.he_pn | hi.Sctl.he_counts  then do;
	     call newline (1);
	     call ioa ("^a^[^/^]^[^3x(^a)^;^s^]", 
	          path, nlS, 
		hi.Sctl.he_counts, Nlines_in_info);
	     end;					/* PATHNAME  (EPs_INFO; LINES_INFO)		        */
	call newline(1);
	call ioa ("Entry:  ^a", heading);
	call newline (1);

	hi.block_progress = BLOCK_PROGRESS_display;
	return;
	end;

     else do;					/* User entered "header" response?		        */
	call newline (1);
	call ioa ("^a^[^3x(^a)^;^s^]", 
	     full_path, hi.Sctl.he_counts, Nlines_in_info);
						/* PATHNAME   (EPs_INFO; LINES_INFO)		        */
	call ioa ("Entry:  ^a", heading);
	call newline (1);

	hi.block_progress = BLOCK_PROGRESS_display;
	return;
	end;
     return;
     

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* RESPONSE: info								        */
	/*									        */
	/* Syntax as a response: info INFO_NAME						        */
	/*		     info {-list|-ls}					        */
	/*									        */
	/* Function: Searches all :Info: and :[Info]: blocks for one named INFO_NAME.  Selects that block */
	/*	   for display.  If -list is given, just lists all blocks of current info segment.      */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

info:
     entry (AsciP, help_infoP);
     
/*dcl  AsciP ptr;					/* help_ subsystem's sci_ptr			(Input) */
/*dcl  help_infoP  ptr;				/* points to the help_info (hi) data structure.   (Input) */
     
     Phelp_args = hi.help_argsP;
     hi.section_search_matchedS = F;

  dcl 1 info_store aligned,
      2 listS bit(1) aligned,				/*  =T: -list was given.			        */
      2 arg_error bit(1) aligned,			/*  =T: User gave invalid control arg or positional arg   */
      2 info_name char(entrynameL) var;

     info_store.listS = F;
     info_store.arg_error = F;
     info_store.info_name = "";

     call arg_setup (AsciP);
     if args_remain() then
	call Args_info (info_store);
     if  info_store.arg_error  then
	call response_error (AsciP);			/*  - Error in user's response?  Abort response line.     */

     if  info_store.info_name = ""  &  ^info_store.listS  then
	call response_error (AsciP, error_table_$noarg, "Please give an INFO_NAME or -list.");
     if  info_store.info_name ^= ""  &  info_store.listS  then 
	call response_error (AsciP, error_table_$inconsistent, "Please give either an INFO_NAME or -list.");
						/*  - These error messages do not return.	        */

     iFileP = hi.iFileP;				/* Access info seg iFile structure.		        */
     if  info_store.listS  then
	goto INFO_list;


/*dcl  nmI fixed bin;				/* Index into Blok_names array.		        */
     do iBlokP = iFile.relatives.bloks.firstP
         repeat iBlok.sib.nextP  while (iBlokP ^= null() );
	if  iBlok.divider = iBlok_divider_Info  
	 |  iBlok.divider = iBlok_divider_Info_no_ext_names  then do;

	     do nmI = lbound(Blok_names,1) to hbound(Blok_names,1);
		if  Blok_names(nmI) = info_store.info_name  then
		     goto INFO_NAME_matched;
		end;
	     end;
	end;
     
     hi.section_search_matchedS = F;
     call response_error (AsciP, 0, "No match for info block name: ^a", info_store.info_name);
						/*  - This error message does not return.	        */
     

     
INFO_NAME_matched:
     hi.section_search_matchedS = T;
     if  iBlokP = hi.iBlokP  then do;
	hi.prompt_repeatS = T;			/*  - We're already positioned in given block.  Stop now. */
	return;
	end;
     
     hi.iBlokP = iBlokP;				/* Select "top" paragraph in matching block.	        */
     hi.selected, hi.iPgh_print_range = null();
     goto hi.ANOTHER_BLOCK_LABEL;			/* Switching blocks in same info seg...		        */
						/*  - start over with heading for the chosen block.       */

INFO_list:
     hi.section_search_matchedS = F;
     
     call newline (1);
     call ioa ("Blocks in info segment: ^a", File_names(1));

     do iBlokP = iFile.relatives.bloks.firstP
         repeat iBlok.sib.nextP  while (iBlokP ^= null() );
	if  dim(Blok_names,1) > 0  then
	     call ioa ("^va  ^(^a: ^)", maxlength(iBlok_token(1)), iBlok_token(iBlok.divider), Blok_names(*) );
	else call ioa ("^va  UNNAMED-BLOCK", maxlength(iBlok_token(1)), iBlok_token(iBlok.divider));
	end;
     return;
%page;
/* ------------------------------------------------------------
   Process info response arguments.
   ------------------------------------------------------------ */

Args_info:
     proc (c);

  dcl 1 c aligned like info_store;			/*  control arg specification data                   (in) */

     do while (args_remain());
	call ssu_$arg_ptr (AsciP, argI+1, argP, argL);	/* Conditionally read next arg to response	        */

	if isControlArg(arg) then do;

	     if       arg = "-ls"  |  arg = "-list"           then c.listS = T;

               else do;
		call error (AsciP, error_table_$badopt, "Unsupported control arg: ^a", arg);
		c.arg_error = T;
		end;
	     end;

	else do;					/* If arg is a INFO_NAME argument		        */
	     if  c.info_name = ""  &  length(arg) <= maxlength(c.info_name)  then do;
		c.info_name = arg;
		end;

	     else if  c.info_name ^= ""  then do;
		call error (AsciP, error_table_$too_many_args, "More than 1 INFO_NAME given: ^a", arg);
		c.arg_error = T;
		end;

	     else do;
		call error (AsciP, error_table_$bigarg, 
		     "INFO_NAME limited to ^d characters: ^a", maxlength(c.info_name), arg);
		c.arg_error = T;
		end;
	     end;

	argI = argI + 1;				/* Record that we processed the arg just examined above.  */
	end;

     end Args_info;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* RESPONSE: list_entry_points, lep						        */
	/*									        */
	/* Syntax as a help control:   -list_entry_points, -lep				        */
	/* Syntax as a response:        list_entry_points {-unseen},			        */
	/*		                      list_ep {-uns},				        */
	/*		                          lep {-uns}				        */
	/*									        */
	/* Function: For a subroutine info segment, display list of :Entry: block heading lines.	        */
	/*									        */
	/*									        */
	/* HELPER ROUTINE:  lep_setup							        */
	/*									        */
	/* Function:								        */
	/* Called directly by help_'s display_block subroutine to perform the following operations:       */
	/*  1) Pre-allocate the entrypoint LIST structure.				        */
	/*  2) Check if subroutine info has an introduction section.  If so...		        */
	/*      A) Check if that section contains an "Entry points in" section.		        */
	/*          YES: Replace its placeholder "(List is generated by the help command)" with	        */
	/*               lines containing the entrypoints.				        */
	/*          NO:  Generate a new section at end of introduction section listing the entrypoints.   */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

list_entry_points:
     entry (AsciP, help_infoP);
     
/*dcl  AsciP ptr;					/* help_ subsystem's sci_ptr			(Input) */
/*dcl  help_infoP  ptr;				/* points to the help_info (hi) data structure.   (Input) */

  dcl 1 lep_store aligned automatic,			/* Input arguments to the current titles response.        */
      2 lep_setupS bit(1) aligned,
      2 control_args,
        3 unseenS bit(1) aligned,
      2 arg_error bit(1) aligned;			/*  =T: User gave invalid control arg or positional arg   */

     lep_store = F;

     call arg_setup (AsciP);				/* Get lep response's control arguments (if any).	        */
     if args_remain() then
	call Args_lep (lep_store);
     if  lep_store.arg_error  then			/*  - Return if user's response had argument errors.      */
	return;

     goto LEP_common;
     

lep_setup:
     entry (AsciP, help_infoP);
     
     if  hi.display_mode ^= DISPLAY_MODE_subroutine  then
	return;
     if  hi.iFileP = null()  |  hi.iBlokP = null()  then
	return;

     lep_store = F;
     lep_store.lep_setupS = T;
     goto LEP_common;
%page;

  dcl 1 eps aligned based (Peps),			/* Overlay of LIST struct in _help_shared_data_.incl.pl1  */
      2 header like LIST.header,
      2 title char (84),				/*   title of output list.			        */
      2 group (0 refer (eps.N)) like LIST.group,
      2 print_array (0 refer (eps.Npghs), 0 refer (eps.Nrows)),
        3 line_out char (HELP_LINE_SIZE_MAX),
       Peps ptr;

  dcl  MAX_EP_COLUMNS fixed bin int static options(constant) init(3);
  dcl  MAX_EP_PARAGRAPHS fixed bin int static options(constant) init(2);
  dcl  MIN_EP_COLUMNS fixed bin int static options(constant) init(1);
  dcl  subr_refname char(32) var;

LEP_common:
     iFileP = hi.iFileP;
     iBlokP = hi.iBlokP;				
     if  info_seg_util_$is_Subroutine_kind (iBlok.kind)  then do;
	subr_refname = before(Blok_words(1), DOLLAR_SIGN);
	if  subr_refname = ""  then
	     subr_refname = "UNKNOWN_SUBROUTINE_NAME_";
	end;
     else subr_refname = "UNKNOWN_SUBROUTINE_NAME_";

     Peps = hi.next_free_spaceP;
     eps.header = 0;
     eps.N = 0;

     if  lep_store.unseenS  then do;			/* list_entry_points -unseen			        */
	eps.title = "Unseen entry points in " || subr_refname || COLON;
	
	do iBlokP = iFile.relatives.bloks.firstP	/* Walk block list for subroutine entrypoint blocks.      */
	     repeat iBlok.sib.nextP  while (iBlokP ^= null() );
	     if  iBlok.kind = iBlok_kind_SUBROUTINE_ENTRY  
	      & ^iBlok.seenS  then do;
		eps.N = eps.N + 1;
		eps.group.arg(eps.N) = rtrim (string (iBlok.header.reformatted));
		end;
	     end;
	if  eps.N = 0  then 
	     call response_error (AsciP, 0, "All entry points have been seen.");
	
	if  eps.N <= MAX_EP_COLUMNS  then
	     call help_util_$format_one_use_LIST (AsciP, help_infoP, Peps, MIN_EP_COLUMNS, MAX_EP_PARAGRAPHS);
	else call help_util_$format_one_use_LIST (AsciP, help_infoP, Peps, MAX_EP_COLUMNS, MAX_EP_PARAGRAPHS);
						/* $format_list calls set_space_used to preserve LIST     */
						/*  - Throw away space used for this list.	        */
	
	goto LEP_display_LIST;
	end;

     else if  hi.LIST_entrypointsP = null()  then do;	/* No list built yet for this subroutine info seg?        */
	hi.LIST_entrypointsP = Peps;
	eps.title = "Entry points in " || subr_refname || COLON;
	
	do iBlokP = iFile.relatives.bloks.firstP
	     repeat iBlok.sib.nextP  while (iBlokP ^= null() );
	     if  iBlok.kind = iBlok_kind_SUBROUTINE_ENTRY  then do;
		eps.N = eps.N + 1;
		eps.group.arg(eps.N) = rtrim (string (iBlok.header.reformatted));
		end;
	     end;
	if  eps.N = 0  then do;
	     eps.N = 1;
	     eps.group.arg(1) = "(No entry points found in info segment.)";
	     end;
	eps.group.Snot_found = 0;
	
	if  eps.N <= MAX_EP_COLUMNS  then
	     call help_util_$format_LIST (AsciP, help_infoP, Peps, MIN_EP_COLUMNS, MAX_EP_PARAGRAPHS);
	else call help_util_$format_LIST (AsciP, help_infoP, Peps, MAX_EP_COLUMNS, MAX_EP_PARAGRAPHS);
						/* $format_list calls set_space_used to preserve LIST     */
	end;
     else Peps = hi.LIST_entrypointsP;

     if  ^lep_store.lep_setupS  then do;		/* Just displaying the entrypoint LIST?  Do it now.       */
LEP_display_LIST:
	if  hi.block_progress = BLOCK_PROGRESS_needs_header  then do;
						/* list_entry_points response invoked by help -lep        */
	     hi.header_Nlines_follow = 0;
	     call help_util_$execute (AsciP, help_infoP, "header");
	     end;					/*  - display a heading describing info seg.	        */

	call help_util_$print_LIST (AsciP, help_infoP, Peps);
	call newline (1);

	hi.prompt_repeatS = T;			/*  - Need to re-prompt after LIST is displayed.	        */
	return;
	end;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* The following code is constructing info_seg_ structures to fabricate a new or complete	        */
	/* "Entry points in SUBR_REFNAME_:" section and append it to the introduction iBlok of the        */
	/* info_seg_.  The segment itself is NOT modified; info_seg_'s view of segment contents is being  */
	/* extended, using lines stored in the eps structure (just created above).  info_seg_ routines    */
	/* are used to make the extension.						        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

     hi.STRING_entrypointsP = hi.next_free_spaceP;	/* Create region of contiguous characters to hold	        */
     STRING_entrypoints.L = 0;			/*  contents of "Entry points in ..." paragraph just      */
						/*  formatted above.			        */

     call STRING_cat (addr(STRING_entrypoints), rtrim(eps.title));
						/*  - section title line			        */

  dcl (pghI, rowI) fixed bin;
     pghI = 1;					/*  - entry points list formatted as a single paragraph.  */
     do rowI = lbound(eps.line_out, 2) to hbound(eps.line_out, 2);
	call STRING_cat (addr(STRING_entrypoints), rtrim(eps.line_out(pghI, rowI)) );
	end;


     iFileP = hi.iFileP;     
     iBlokP = iFile.relatives.bloks.firstP;

     if  iBlok.kind = iBlok_kind_SUBROUTINE_INTRO  then do;	/* A normal subroutine introduction block may or may not  */
     						/*  have an "Entry points in SUBR_REFNAME_" section.      */
	do iSectP = iBlok.relatives.sects.firstP
	     repeat iSect.sib.nextP  while (iSectP ^= null() );
	     if  iSect.type = iSect_ENTRY_POINTS_IN  then do;
		call info_seg_parse_$replace_STRING_in_section (hi.isdP, addr(STRING_entrypoints), iBlokP, iSectP);
		return;
		end;
	     end;
	call info_seg_parse_$append_STRING_to_block (hi.isdP, addr(STRING_entrypoints), iBlokP);
	end;
	
     else if  iBlok.kind = iBlok_kind_SUBROUTINE_BRIEF_INTRO  then do;
	iSectP = iBlok.relatives.sects.firstP;		/* Brief subr intro verified to have "Entry points in..." */
						/*  as its only section (by definition of "brief intro"). */
	call info_seg_parse_$replace_STRING_in_section (hi.isdP, addr(STRING_entrypoints), iBlokP, iSectP);
	end;
     return;

%page;
/* ------------------------------------------------------------
   Process list_entry_points response arguments.
   ------------------------------------------------------------ */

Args_lep:
     proc (c);

  dcl 1 c aligned like lep_store;			/*  control arg specification data                   (in) */

     do while (args_remain());
	call ssu_$arg_ptr (AsciP, argI+1, argP, argL);	/* Conditionally read next arg to response	        */

	if isControlArg(arg) then do;

	     if       arg = "-uns"  |  arg = "-unseen"           then c.unseenS = T;

               else do;
		call error (AsciP, error_table_$badopt, "Unsupported control arg: ^a", arg);
		c.arg_error = T;
		end;
	     end;
	
	else do;
	     call error (AsciP, error_table_$bad_arg, "Unsupported positional argument: ^a", arg);
	     c.arg_error = T;
	     end;

	argI = argI + 1;				/* Record that we processed the arg just examined above.  */
	end;

     end Args_lep;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

  dcl 1 STRING aligned based(STRING_P),			/* Basic form of STRING matches that of char(L) varying   */
      2 L fixed bin(21),
      2 text char(0 refer (STRING.L)),
       STRING_P ptr;

  dcl 1 STRING_entrypoints aligned based(hi.STRING_entrypointsP),
      2 L fixed bin(21),
      2 text char(0 refer (STRING_entrypoints.L));

STRING_cat:					/* Append the string: Atext || NL		        */
     proc (aSTRING_P, Atext);				/*  to STRING.text, adjusting STRING.L accordingly.       */

  dcl  aSTRING_P ptr;				/* Points to a STRING structure.		   (In) */
  dcl  Atext char(*);				/* Text of line (w/o its final NL) to be appended.   (In) */

  dcl  beginI fixed bin(21);

  dcl  NL char(1) int static options(constant) init("
");
     STRING_P = aSTRING_P;				/* Get pointer to STRING structure.		        */
     beginI = STRING.L + 1;				/* Get index of new text within STRING.text.	        */

     STRING.L = STRING.L + length(Atext) + length(NL);	/* Extend length of STRING.text to hold new text.	        */

     substr(STRING.text, beginI, length(Atext)) = Atext;	/* Add new text and line-ending NL to STRING.text.        */
     substr(STRING.text, length(STRING.text), length(NL)) = NL;
     
     end STRING_cat;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* RESPONSE: next, no, n							        */
	/*									        */
	/* Syntax as a response:   next						        */
	/*									        */
	/* Function: stop displaying current block; start displaying next block in PDinfo_segs.P list.    */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

next:
     entry (AsciP, help_infoP);
     
/*dcl  AsciP ptr;					/* help_ subsystem's sci_ptr			(Input) */
/*dcl  help_infoP  ptr;				/* points to the help_info (hi) data structure.   (Input) */
     
     call arg_setup (AsciP);				/* Error if any arguments given after the request name.   */
     if args_remain() then
	call response_error (AsciP, 0, "No arguments may be given.");

     goto hi.NEXT_INFO_LABEL;				/* Move on to next info block in PDinfo_seg.P list.       */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* RESPONSE: rest, r							        */
	/*									        */
	/* Syntax as a response:  rest {-section | -unseen } {-top},			        */
	/*		         r {-scn | -uns } {-t}				        */
	/*									        */
	/* Function: sets paragraph print range to display:				        */
	/*	    rest		remainder of info block				        */
	/*                             DISPLAY_LIMIT_unseen:  rest of unseen paragraphs in info block     */
	/*                               Sets hi.display_limit to DISPLAY_LIMIT_rest_unseen	        */
	/*	    rest -section	remainder of current (or upcoming) section		        */
	/*			   Sets hi.display_limit to DISPLAY_LIMIT_section.	        */
	/*			   -top sets hi.iPgh_print_range.startP to 1st pgh of section.      */
	/*            rest -unseen    remaining unseen paragraphs are displayed.		        */
	/*                               Sets hi.display_limit to DISPLAY_LIMIT_rest_unseen.	        */
	/*			   -top sets hi.iPgh_print_range.startP to 1st pgh of block.        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

rest:
     entry (AsciP, help_infoP);
     
/*dcl  AsciP ptr;					/* help_ subsystem's sci_ptr			(Input) */
/*dcl  help_infoP  ptr;				/* points to the help_info (hi) data structure.   (Input) */
     
     Phelp_args = hi.help_argsP;

  dcl 1 rest_args aligned automatic,			/* Input arguments to the current section response.       */
      2 rest_mode fixed bin,				/*  =REST_MODE_xxx				        */
      2 topS bit(1) aligned,				/*  =T: User gave -top			        */
      2 arg_error bit(1) aligned;			/*  =T: User gave invalid control arg or positional arg   */

  dcl (REST_MODE_none       init(0),
       REST_MODE_section    init(1),
       REST_MODE_unseen     init(2)
       ) fixed bin int static options(constant);

     rest_args.rest_mode = REST_MODE_none;
     rest_args.topS = F;
     rest_args.arg_error = F;

     call arg_setup (AsciP);
     if args_remain() then
	call Args_rest (rest_args, hi.display_mode);
     if  rest_args.arg_error  then			/* Return if user's response had argument errors.	        */
	call response_error (AsciP);			/*  - Error in user's response?  Abort response line.     */

     if  hi.iPgh_print_range.startP = null()  then	/* Access start of current print range...	        */
	goto hi.NEXT_INFO_LABEL;			/*  The "rest" response was entered at a help_ prompt.    */
						/*  That prompt describes a range of paragraphs to print. */
						/*  If no paragraph(s) setup for printing, then this code */
						/*  does not know how to proceed.  Skip to next info blok.*/

     iBlokP = hi.iBlokP;				/* Setup standard info structure pointers.	        */
     iPghP  = hi.iPgh_print_range.startP;
     iSectP = iPgh.relatives.sectP;

     goto REST (rest_args.rest_mode);
     
REST (REST_MODE_none):				/* rest:  extend range to print rest of block.	        */
     if  hi.display_limit = DISPLAY_LIMIT_unseen  then	/*  - If currently printing unseen paragraphs 1-by-1,     */
          goto REST (REST_MODE_unseen);			/*    then print remaining unseen paragraphs w/o prompts. */

     if  rest_args.topS  then				/* rest -top:       print paragraphs from "top" of block. */
          hi.iPgh_print_range.startP = iBlok.relatives.pghs.firstP;
     hi.iPgh_print_range.endP = iBlok.relatives.pghs.lastP;
     hi.prompt_repeatS = F;				/*  - Needed so print range will be displayed.	        */
     hi.clear_prompt_regionS = T;			/*  - Clear region containing previous prompt & response. */
     return;

REST (REST_MODE_section):				/* rest -section:   adjust range to print remaining       */
						/*                  paragraphs of this section.	        */
     if  rest_args.topS  then				/*      -top:       print pghs from "top" of section.     */
          hi.iPgh_print_range.startP = iSect.relatives.pghs.firstP;
     hi.iPgh_print_range.endP = iSect.relatives.pghs.lastP;
     hi.prompt_repeatS = F;				/*  - Needed so print range will be displayed.	        */
     if  hi.display_limit < DISPLAY_LIMIT_unseen
      & ^rest_args.topS  then				/*  - Clear region containing previous prompt & response. */
	hi.clear_prompt_regionS = T;
     return;

REST (REST_MODE_unseen):				/* rest -unseen:  adjust range to print all remaining     */
						/*                paragraphs which are unseen.	        */
     if  rest_args.topS  then				/*      -top:     print unseen pghs from "top" of block.  */
          hi.iPgh_print_range.startP = iBlok.relatives.pghs.firstP;
     hi.iPgh_print_range.endP = iBlok.relatives.pghs.lastP;	/*  - Extend print range to end of info block.	        */
     hi.display_limit = DISPLAY_LIMIT_rest_unseen;	/*  - Limit output to all remaining unseen paragraphs.    */
     hi.prompt_repeatS = F;				/*  - Needed so print range will be displayed.	        */
     return;
%page;
/* ------------------------------------------------------------
   Process rest response arguments.
   ------------------------------------------------------------ */

Args_rest:
     proc (c, mode);

  dcl 1 c aligned like rest_args;			/*  control arg specification data                   (in) */
  dcl  mode fixed bin;				/*  current display mode			   (in) */
  dcl  option fixed bin;

     do while (args_remain());
	option = REST_MODE_none;
	call ssu_$arg_ptr (AsciP, argI+1, argP, argL);	/* Conditionally read next arg to response	        */

	if isControlArg(arg) then do;

	     if        arg = "-scn"    | arg = "-section"             then  option = REST_MODE_section;

	     else if   arg = "-uns"    | arg = "-unseen"              then  option = REST_MODE_unseen;
	     else if   arg = "-t"      | arg = "-top"		  then  c.topS = T;

               else do;
		call error (AsciP, error_table_$badopt, "Unsupported control arg: ^a", arg);
		c.arg_error = T;
		end;

	     if  option ^= REST_MODE_none  then do;
		if  c.rest_mode = REST_MODE_none  then
		     c.rest_mode = option;
		else do;
		     call error (AsciP, error_table_$inconsistent, 
			"^a and -^[section^;unseen^]", arg, c.rest_mode);
		     c.arg_error = T;
		     end;
		end;
	     end;

	else do;
	     call error (AsciP, error_table_$bad_arg, "Unsupported positional argument: ^a", arg);
	     c.arg_error = T;
	     end;

	argI = argI + 1;				/* Record that we processed the arg just examined above.  */
	end;

     end Args_rest;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* RESPONSE: section, scn							        */
	/*									        */
	/* Syntax as a help control:   -section  STRs  {-case_sensitive},         -scn  STRs  {-cs}       */
	/* Syntax as a response:        section {STRs} {-case_sensitive} {-top},   scn {STRs} {-cs} {-t}  */
	/*									        */
	/* Function: searches forward from the most recently-displayed paragraph to find a section with   */
	/*	   title matching one of the STRs arguments.  The first section whose title matches is  */
	/*	   selected for display.						        */
	/*									        */
	/*	   The help controls are processed by the help command.  They arrive here via the       */
	/*	   help_args.Sctl.srh, help_args.Sctl.cs, and help_args.srh(*) values.	        */
	/*									        */
	/* 	   The "Syntax as a response:" is processed by this response routine.		        */
	/*           When invoked via a response to a help_ query, the STRs search strings are optional.  */
	/*	   If not provided, the search strings given in the help command line or in the most    */
	/*	   recent search response at a help query are used to again to select another section   */
	/*	   to display.							        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

section:
     entry (AsciP, help_infoP);
     
/*dcl  AsciP ptr;					/* help_ subsystem's sci_ptr			(Input) */
/*dcl  help_infoP  ptr;				/* points to the help_info (hi) data structure.   (Input) */
     
     Phelp_args = hi.help_argsP;
     hi.section_search_matchedS = F;

  dcl 1 scn_cache_store aligned based (hi.CACHE_scnP),	/* Cache of STRs from previous section search operation.  */
      2 case_sensitiveS bit(1) aligned,			/*  T: search in case-sensitive manner.		        */
						/*  F: search in case-insensitive manner.	        */

      2 N fixed bin,				/* Number of items currently in the cache.	        */
      2 str (20) char(32) var;			/*  - Cache of STR values.			        */
     
  dcl 1 scn_cache aligned based (hi.CACHE_scnP),
      2 case_sensitiveS bit(1) aligned,			/*  T: search in case-sensitive manner.		        */
						/*  F: search in case-insensitive manner.	        */
      2 N fixed bin,				/* Number of items currently in ca.		        */
      2 str (0 refer (scn_cache.N)) char(32) var;		/*  - Current STR values.			        */

  dcl  scnI fixed bin;

     if  hi.CACHE_scnP = null()  then do;		/* Get space for ca_cache_store for this help_ subsystem  */
	hi.CACHE_scnP = hi.next_free_spaceP;
	call set_space_used (currentsize (scn_cache_store));
	scn_cache_store.case_sensitiveS = F;
	scn_cache_store.N = 0;
	scn_cache_store.str = "";
	end;

     if  scn_cache.N = 0  &  hi.Sctl.scn  then do;	/* Initialize scn_cache from any help_args.scn values.    */
	scn_cache_store.str = "";
	scn_cache.case_sensitiveS = hi.Sctl.cs;

	do scnI = lbound(help_args.scn,1) to hbound(help_args.scn,1) 
	     while (scn_cache.N < dim(scn_cache_store.str,1));
	     scn_cache.N = scn_cache.N + 1;
	     if  scn_cache.case_sensitiveS  then
		scn_cache.str(scn_cache.N) = help_args.scn(scnI);
	     else scn_cache.str(scn_cache.N) = translate(help_args.scn(scnI), LOWER_CASE, UPPER_CASE);
	     end;
	end;


  dcl 1 scn_store aligned automatic,			/* Input arguments to the current section response.       */
      2 arg_error bit(1) aligned,			/*  =T: User gave invalid control arg or positional arg   */
      2 topS bit(1) aligned,
      2 defaultable like scn_cache_store;

  dcl 1 scn aligned based (scn_storeP),
      2 arg_error bit(1) aligned,			/*  =T: User gave invalid control arg or positional arg   */     
      2 topS bit(1) aligned,
      2 defaultable,
        3 case_sensitiveS bit(1) aligned,		/*  T: search in case-sensitive manner.		        */
						/*  F: search in case-insensitive manner.	        */
        3 N fixed bin,				/* Number of items currently in scn.		        */
        3 str (0 refer (scn.N)) char(32) var,		/*  - Current STR values.			        */
       scn_storeP ptr;
     scn_storeP = addr(scn_store);

     scn_store.arg_error = F;				/*  - Get any input arguments to this response.	        */
     scn_store.topS = F;
     scn_store.case_sensitiveS = F;
     scn_store.N = 0;
     scn_store.str = "";

     call arg_setup (AsciP);
     if args_remain() then
	call Args_scn_srh (scn_store);
     if  scn_store.arg_error  then			/* Return if user's response had argument errors.	        */
	call response_error (AsciP);			/*  - Error in user's response?  Abort response line.     */

     if  scn.N = 0  &  scn_cache.N > 0  then		/*  - If no input STRs given, use those in cache.	        */
	scn_store.defaultable = scn_cache_store;
     else if  scn.N > 0  then do;			/*  - Otherwise, overwrite cache w/ new STR and -cs value */
	if  ^scn.case_sensitiveS  then
	     scn.str = translate(scn.str, LOWER_CASE, UPPER_CASE);
	scn_cache_store = scn_store.defaultable;     
	end;


     if  dim(scn.str,1) = 0  then 			/* Complain if no STRs given (or have default value)      */
	call response_error (AsciP, error_table_$noarg, 
	     "No search STRs were given, and" ||
	   "^/   the ^a response has no saved arguments from a prior use.", ssu_$get_request_name (AsciP) );
     if  hi.iBlokP = null()  then 			/* ASSERT: some info block should have been selected.     */
	call response_error (AsciP, error_table_$null_info_ptr, "Internal error: hi.iBlokP = null()");
						/*  - These error messages do not return.	        */


     iBlokP = hi.iBlokP;				/* Address the current block's iBlok structure.	        */

     if  hi.iSectP = null()  
      |  scn.topS  then do;
	iSectP = iBlok.sects.firstP;
	if  iSect.title.in_file = ""  then		/* Skip 1st section if it has no title.		        */
	     iSectP = iSect.sib.nextP;		/*  NOTE: Only 1st section of block can lack a title.     */
	end;
     else iSectP = hi.iSectP->iSect.sib.nextP;
     
  dcl  title_ char(71) var;

     do iSectP = iSectP				/* Search forward thru sections looking for title match.  */
	repeat iSect.sib.nextP while (iSectP ^= null() );
	if  scn.case_sensitiveS  then
	     title_ = iSect.title.in_file;
	else title_ = translate (iSect.title.in_file, LOWER_CASE, UPPER_CASE);

	do scnI = lbound(scn.str,1) to hbound(scn.str,1);
	     if  index(title_, scn.str(scnI)) > 0  then
		goto SECTION_MATCH;
	     end;
	end;

     if  hi.block_progress = BLOCK_PROGRESS_display  then	/* Complain if user response found no match.	        */
	call ioa ("No matching section found.");	
     hi.prompt_repeatS = T;				/*  - Redisplay prompt about recommended paragraphs.      */
     hi.section_search_matchedS = F;			/*  - Report to calling environment: section not found.   */
     return;					/*  - Silent return if help -section control not matched. */

SECTION_MATCH:
     hi.selected.iSectP = iSectP;			/* Select matching section as next to be displayed.       */
     hi.selected.iPghP  = null();
     hi.iPgh_print_range = null();
     hi.display_limit = DISPLAY_LIMIT_section;
     hi.prompt_repeatS = F;				/*  - Needed to print the selected section.	        */

     hi.section_search_matchedS = T;			/* Report to calling environment that section was found.  */
     return;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* RESPONSE: search, srh							        */
	/*									        */
	/* Syntax as a help control:   -search  STRs  {-case_sensitive},         -srh  STRs  {-cs}        */
	/* Syntax as a response:        search {STRs} {-case_sensitive} {-top},   srh {STRs} {-cs} {-t}   */
	/*									        */
	/* Function: searches forward from the most recently-displayed paragraph to find another paragraph*/
	/*	   containing a line matching one of the STRs arguments.  The first matching paragraph  */
	/*	   is selected for display.						        */
	/*									        */
	/*	   The help controls are processed by the help command.  They arrive here via the       */
	/*	   help_args.Sctl.srh, help_args.Sctl.cs, and help_args.srh(*) values.	        */
	/*									        */
	/* 	   The "Syntax as a response:" is processed by this response routine.		        */
	/*           When invoked via a response to a help_ query, the STRs search strings are optional.  */
	/*	   If not provided, the search strings given in the help command line or in the most    */
	/*	   recent search response at a help query are used to again to select another section   */
	/*	   to display.							        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

search:
     entry (AsciP, help_infoP);
     
/*dcl  AsciP ptr;					/* help_ subsystem's sci_ptr			(Input) */
/*dcl  help_infoP  ptr;				/* points to the help_info (hi) data structure.   (Input) */
     
     Phelp_args = hi.help_argsP;
     hi.section_search_matchedS = F;


  dcl 1 srh_cache_store aligned based (hi.CACHE_srhP),	/* Cache of STRs from previous search operation.	        */
      2 case_sensitiveS bit(1) aligned,			/*  T: search in case-sensitive manner.		        */
						/*  F: search in case-insensitive manner.	        */
      2 N fixed bin,				/* Number of items currently in the cache.	        */
      2 str (20) char(32) var;			/*  - Cache of STR values.			        */
     
  dcl 1 srh_cache aligned based (hi.CACHE_srhP),
      2 case_sensitiveS bit(1) aligned,			/*  T: search in case-sensitive manner.		        */
						/*  F: search in case-insensitive manner.	        */
      2 N fixed bin,				/* Number of items currently in ca.		        */
      2 str (0 refer (srh_cache.N)) char(32) var;		/*  - Current STR values.			        */

  dcl  srhI fixed bin;

     if  hi.CACHE_srhP = null()  then do;		/* Get space for ca_cache_store for this help_ subsystem  */
	hi.CACHE_srhP = hi.next_free_spaceP;
	call set_space_used (currentsize (srh_cache_store));
	srh_cache_store.case_sensitiveS = F;
	srh_cache_store.N = 0;
	srh_cache_store.str = "";
	end;

     if  srh_cache.N = 0  &  hi.Sctl.srh  then do;	/* Initialize srh_cache from any help_args.srh values.    */
	srh_cache_store.str = "";
	srh_cache.case_sensitiveS = hi.Sctl.cs;

	do srhI = lbound(help_args.srh,1) to hbound(help_args.srh,1) 
	     while (srh_cache.N < dim(srh_cache_store.str,1));
	     srh_cache.N = srh_cache.N + 1;
	     if  srh_cache.case_sensitiveS  then
		srh_cache.str(srh_cache.N) = help_args.srh(srhI);
	     else srh_cache.str(srh_cache.N) = translate(help_args.srh(srhI), LOWER_CASE, UPPER_CASE);
	     end;
	end;
     

  dcl 1 srh_store aligned automatic,			/* Input arguments to the current search response.        */
      2 arg_error bit(1) aligned,			/*  =T: User gave invalid control arg or positional arg   */
      2 topS bit(1) aligned,
      2 defaultable like srh_cache_store;

  dcl 1 srh aligned based (srh_storeP),
      2 arg_error bit(1) aligned,			/*  =T: User gave invalid control arg or positional arg   */
      2 topS bit(1) aligned,
      2 defaultable,
        3 case_sensitiveS bit(1) aligned,		/*  T: search in case-sensitive manner.		        */
						/*  F: search in case-insensitive manner.	        */
        3 N fixed bin,				/* Number of items currently in srh.		        */
        3 str (0 refer (srh.N)) char(32) var,		/*  - Current STR values.			        */
       srh_storeP ptr;
     srh_storeP = addr(srh_store);

     srh_store.arg_error = F;				/*  - Get any input arguments to this response.	        */
     srh_store.topS = F;
     srh_store.case_sensitiveS = F;
     srh_store.N = 0;
     srh_store.str = "";

     call arg_setup (AsciP);
     if args_remain() then
	call Args_scn_srh (srh_store);
     if  srh_store.arg_error  then			/* Return if user's response had argument errors.	        */
	call response_error (AsciP);			/*  - Error in user's response?  Abort response line.     */

     if  srh.N = 0  &  srh_cache.N > 0  then		/*  - If no input STRs given, use those in cache.	        */
	srh_store.defaultable = srh_cache_store;
     else if  srh.N > 0  then do;			/*  - Otherwise, overwrite cache w/ new STR and -cs value */
	if  ^srh.case_sensitiveS  then
	     srh.str = translate(srh.str, LOWER_CASE, UPPER_CASE);
	srh_cache_store = srh_store.defaultable;     
	end;


     if  dim(srh.str,1) = 0  then 			/* Complain if no STRs given (nor have default value)     */
	call response_error (AsciP, error_table_$noarg, 
	     "No search STRs were given, and" ||
	   "^/   the ^a response has no saved arguments from a prior use.", ssu_$get_request_name (AsciP) );
     if  hi.iBlokP = null()  then 			/* ASSERT: some info block should have been selected.     */
	call response_error (AsciP, error_table_$null_info_ptr, "Internal error: hi.iBlokP = null()");
						/*  - These error messages do not return.	        */


     iBlokP = hi.iBlokP;				/* Address the current info block.		        */

     if (hi.iPghP = null()  &  hi.iSectP = null() )	/* At "top" of block, begin search w/ 1st paragraph.      */
      |  srh.topS  then do;
	iPghP  = iBlok.pghs.firstP;
	iSectP = iPgh.relatives.sectP;
	end;

     else if  hi.iPghP = null()			/* If section was selected, begin w/ its 1st paragraph.   */
           &  hi.iSectP ^= null()  then do;
	iSectP = hi.iSectP;
	iPghP  = iSect.pghs.firstP;
	end;
     else do;					/* Already in "current paragraph" to be displayed.        */
	iPghP  = hi.iPghP;
	iSectP = iPgh.relatives.sectP;
	end;

  dcl  line_ char(HELP_LINE_SIZE_MAX) var;		/* Space to translate an info line to lower case for      */
						/*   non-case-senstive searches.		        */

     do iPghP = iPghP				/* Search forward thru paragraphs looking for  match.     */
         repeat iPgh.sibs.blok.nextP  while (iPghP ^= null() );

	do iLineP = iPgh.lines.firstP
	     repeat iLine.sibs.blok.nextP  while (iLineP ^= null() );

	     if  ^srh.case_sensitiveS  then
		line_ = translate (Line, LOWER_CASE, UPPER_CASE);

	     do srhI = lbound(srh.str,1) to hbound(srh.str,1);
		if  srh.case_sensitiveS  then
		     if  index(Line, srh.str(srhI)) > 0  then
		          goto SEARCH_MATCH;
		     else;
		else if  index(line_, srh.str(srhI)) > 0  then
		          goto SEARCH_MATCH;
		     else;
		end;
	     end;
	end;

     if  hi.block_progress = BLOCK_PROGRESS_display  then	/* Complain if user response found no match.	        */
	call ioa ("No matching paragraph found.");	
     hi.section_search_matchedS = F;			/* Report to calling environment that search found no pgh.*/
     return;					/* Silently return if help -search ctl_arg did not match. */

SEARCH_MATCH:
     iPghP = iLine.relatives.pghP;			/* Select paragraph preceding match as "current paragraph"*/
     iPghP = iPgh.sibs.blok.prevP;			/*  so the matching paragraph becomes "next_to_print".    */

     if  iPghP = null()  then				/*  - 1st paragraph of block matched?		        */
	hi.selected = null();			/*    Start at "top" of block.		        */
     else do;					/*  - Otherwise, set previous paragraph as "selected".    */
	hi.selected.iPghP = iPghP;
	hi.selected.iSectP = iPgh.relatives.sectP;
	end;

     hi.iPgh_print_range = null();			/*  - Clear print range describing prior recommended pghs.*/
						/*     New print range based on hi.selected will be set.  */
     hi.prompt_repeatS = F;				/*  - Needed to print the selected section.	        */

     hi.section_search_matchedS = T;			/* Report to calling environment that search found a pgh. */
     return;
%page;
/* ------------------------------------------------------------
   Process section and search response arguments.
   ------------------------------------------------------------ */

Args_scn_srh:
     proc (c);

  dcl 1 c aligned like scn_store;			/*  control arg specification data                   (in) */

     do while (args_remain());
	call ssu_$arg_ptr (AsciP, argI+1, argP, argL);	/* Conditionally read next arg to response	        */

	if isControlArg(arg) then do;

	     if       arg = "-cs"     | arg = "-case_sensitive"      then c.case_sensitiveS = T;
	     else if  arg = "-ncs"    | arg = "-non_case_sensitive"  then c.case_sensitiveS = F;

	     else if  arg = "-t"      | arg = "-top"                 then c.topS = T;

               else do;
		call error (AsciP, error_table_$badopt, "Unsupported control arg: ^a", arg);
		c.arg_error = T;
		end;
	     end;
	
	else do;					/* If arg is a -section/-search operand		        */
	     if  c.N < dim(c.str,1)  &  length(arg) <= maxlength(c.str(1))  then do;
		c.N = c.N + 1;
		c.str(c.N) = arg;
		end;

	     else if  c.N = dim(c.str,1)  then do;
		call error (AsciP, error_table_$too_many_args, "More than ^d STRs given: ^a", dim(c.str,1), arg);
		c.arg_error = T;
		end;

	     else do;
		call error (AsciP, error_table_$bigarg, 
		     "STR limited to ^d characters: ^a", maxlength(c.str(1)), arg);
		c.arg_error = T;
		end;
	     end;

	argI = argI + 1;				/* Record that we processed the arg just examined above.  */
	end;

     end Args_scn_srh;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* RESPONSE: skip, s							        */
	/*									        */
	/* Syntax as a response:							        */
	/*     DISPLAY_MODE_non_subroutine:   skip {-section | -seen | -rest},		        */
	/*                                       s {-scn | -seen | -rest}			        */
	/*     DISPLAY_MODE_subroutine:       skip {-section | -seen | -rest},		        */
	/*			           s {-scn | -seen | -rest}			        */
	/*									        */
	/* Function: sets paragraph print range to display:				        */
	/*	    skip		prompt about sections/paragraphs beyond end of current print range  */
	/*            skip -section   prompt about sections beyond end of current section.                */
	/*	    skip -seen	print next unseen paragraph				        */
	/*			 sets hi.display_limit to DISPLAY_LIMIT_section		        */
	/*	    skip -rest      skip to bottom of info block; prompt if paragraphs are unseen.      */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

skip:
     entry (AsciP, help_infoP);
     
/*dcl  AsciP ptr;					/* help_ subsystem's sci_ptr			(Input) */
/*dcl  help_infoP  ptr;				/* points to the help_info (hi) data structure.   (Input) */
     
     Phelp_args = hi.help_argsP;

  dcl 1 skip_args aligned automatic,			/* Input arguments to the current section response.       */
      2 skip_mode fixed bin,
      2 arg_error bit(1) aligned;			/*  =T: User gave invalid control arg or positional arg   */

  dcl (SKIP_MODE_none     init(0),
       SKIP_MODE_section  init(1),
       SKIP_MODE_seen     init(2),
       SKIP_MODE_rest     init(3)
       ) fixed bin int static options(constant);

     skip_args.skip_mode = SKIP_MODE_none;
     skip_args.arg_error = F;

     call arg_setup (AsciP);
     if args_remain() then
	call Args_skip (skip_args, hi.display_mode);
     if  skip_args.arg_error  then			/* Return if user's response had argument errors.	        */
	call response_error (AsciP);			/*  - Error in user's response?  Abort response line.     */

     if  hi.iPgh_print_range.startP = null()
      |  hi.iPgh_print_range.endP = null()    then	/* Access start of current print range...	        */
	goto hi.NEXT_INFO_LABEL;			/*  The "skip" response was entered at a help_ prompt.    */
						/*  That prompt describes a range of paragraphs to print. */
						/*  If no paragraph(s) setup for printing, then this code */
						/*  does not know how to proceed.  Skip to next info blok.*/

     iBlokP = hi.iBlokP;				/* Setup standard info structure pointers.	        */
     iPghP  = hi.iPgh_print_range.startP;
     iSectP = iPgh.relatives.sectP;

     hi.clear_prompt_regionS = F;			/*  - Skipping to unseen means non-consecutive pghs.      */
     goto SKIP (skip_args.skip_mode);
     
SKIP (SKIP_MODE_none):				/* skip:  prompt about sections/paragraphs beyond end of  */
						/*        current print range.		        */
     if  hi.display_limit = DISPLAY_LIMIT_unseen  then	/*  - If currently printing unseen paragraphs 1-by-1,     */
          goto SKIP (SKIP_MODE_seen);			/*    then skip to next unseen paragraphs w/o prompts.    */

     hi.selected.iPghP, iPghP = hi.iPgh_print_range.endP;	/*  - Mark last paragraph of print range as "current pgh" */
     hi.selected.iSectP, iSectP = iPgh.relatives.sectP;	/*    and redo prompt.  New prompt describes section      */
						/*    beyond the "current paragraph".		        */
     hi.prompt_repeatS = T;				/*     - Needed to reprompt if unseen blocks remain.      */
     return;

SKIP (SKIP_MODE_section):				/* skip -section:   adjust range to prompt about section  */
						/*                  following 1st section of print range  */
     hi.selected.iSectP = iSectP;			/*  - Mark last paragraph of first section in print range */
     hi.selected.iPghP  = iSect.relatives.pghs.lastP;	/*    as "current paragraph", and redo prompt.  The new   */
						/*    prompt describes section beyond "current paragraph".*/
     hi.prompt_repeatS = T;				/*     - Needed to reprompt if unseen blocks remain.      */
     return;

SKIP (SKIP_MODE_seen):				/* skip -seen:  try to display next unseen paragraph and  */
     do iPghP = iPghP				/*              remainder of its section.	        */
         repeat iPgh.sibs.blok.nextP  while (iPghP ^= null() );
	if  ^iPgh.seenS  then do;
	     hi.selected.iSectP, iSectP = iPgh.relatives.sectP;
	     hi.selected.iPghP          = iPghP;
	     hi.iPgh_print_range.startP = iPghP;
	     hi.iPgh_print_range.endP   = iSect.relatives.pghs.lastP;
	     hi.prompt_repeatS = F;			/*   - Needed to actually print the new print range.      */
	     return;
	     end;
	end;
     goto SKIP(SKIP_MODE_rest);			/*   - Be explicit about flowing into next label...       */

SKIP (SKIP_MODE_rest):				/* skip -rest:  skip remaining paragraphs.  Prompt for    */
						/*              any unseen paragraphs.		        */
     hi.selected.iPghP, iPghP = iBlok.relatives.pghs.lastP;	/* - Mark last paragraph of block as "current paragraph". */
     hi.selected.iSectP, iSectP = iPgh.relatives.sectP;
     hi.prompt_repeatS = T;				/*    - Needed to reprompt if unseen blocks remain.       */
     return;

%page;
/* ------------------------------------------------------------
   Process skip response arguments.
   ------------------------------------------------------------ */

Args_skip:
     proc (c, mode);

  dcl 1 c aligned like skip_args;			/*  control arg specification data                   (in) */
  dcl  mode fixed bin;				/*  current display mode			   (in) */
  dcl  option fixed bin;

     do while (args_remain());
	option = SKIP_MODE_none;
	call ssu_$arg_ptr (AsciP, argI+1, argP, argL);	/* Conditionally read next arg to response	        */

	if isControlArg(arg) then do;

	     if                          arg = "-rest"                then  option = SKIP_MODE_rest;

	     else if   arg = "-scn"    | arg = "-section"             then  option = SKIP_MODE_section;

	     else if                     arg = "-seen"                then  option = SKIP_MODE_seen;


               else do;
		call error (AsciP, error_table_$badopt, "Unsupported control arg: ^a", arg);
		c.arg_error = T;
		end;

	     if  c.skip_mode = SKIP_MODE_none  then
		c.skip_mode = option;
	     else do;
		call error (AsciP, error_table_$inconsistent, 
		     "^a and -^[section^;seen^;rest^]", arg, c.skip_mode);
		c.arg_error = T;
		end;
	     end;
	
	else do;
	     call error (AsciP, error_table_$bad_arg, "Unsupported positional argument: ^a", arg);
	     c.arg_error = T;
	     end;

	argI = argI + 1;				/* Record that we processed the arg just examined above.  */
	end;

     end Args_skip;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* RESPONSE: titles, title							        */
	/*									        */
	/* Syntax as help control:   -titles, -title					        */
	/* Syntax as a response:      titles {-top | -unseen},  title {-t | -uns}		        */
	/*									        */
	/* Function: Displays section titles from top of current block, or below current position in      */
	/*	   that block.							        */
	/*									        */
	/*	   The "Syntax as a command:" is processed by the help command.  It arrives here via    */
	/*	   help_args.Sctl.titles.						        */
	/*									        */
	/* 	   The "Syntax as a response:" is processed by this response routine.		        */
	/* 	   By default, the response lists section titles remaining after the current section.   */
	/*	   If -top is given, all section titles are listed.  If -unseen is given, titles of     */
	/*	   all sections containing unseen paragraphs are listed.  -unseen is the default if     */
	/*           currently viewing unseen_paragraphs_only.				        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

titles:
     entry (AsciP, help_infoP);
     
/*dcl  AsciP ptr;					/* help_ subsystem's sci_ptr			(Input) */
/*dcl  help_infoP  ptr;				/* points to the help_info (hi) data structure.   (Input) */

  dcl 1 title_args aligned automatic,			/* Input arguments to the current titles response.        */
      2 topS bit(1) aligned,
      2 unseenS bit(1) aligned,
      2 arg_error bit(1) aligned;			/*  =T: User gave invalid control arg or positional arg   */
     
     title_args = F;				/*  - Get any input arguments to this response.	        */

     call arg_setup (AsciP);
     if args_remain() then
	call Args_title (title_args);
     if  title_args.arg_error  then			/* Return if user's response had argument errors.	        */
	call response_error (AsciP);			/*  - Error in user's response?  Abort response line.     */

     if  hi.iBlokP = null()  then 			/* ASSERT: some info block should have been selected.     */
	call response_error (AsciP, error_table_$null_info_ptr, "Internal error: hi.iBlokP = null()");


     iBlokP = hi.iBlokP;				/* Access current block's iBlok structure.	        */

     if  hi.block_progress = BLOCK_PROGRESS_needs_header  then do;
						/* titles response invoked by help -titles	        */
	hi.header_Nlines_follow = 0;
	call help_util_$execute (AsciP, help_infoP, "header");
	end;					/*  - display a heading describing info seg.	        */

     if  title_args.topS  then			/* -top: show all section titles in current block...      */
	iSectP = iBlok.sects.firstP;
     else if  title_args.unseenS  then			/* -unseen: show all unseen titles in the current block...*/
	iSectP = iBlok.sects.firstP;
						/* OR Defaults  ...				        */
     else if  hi.display_limit = DISPLAY_LIMIT_unseen  then do;
	iSectP = iBlok.sects.firstP;			/*   unseen_paragraphs_only:  show only all unseen titles.*/
	title_args.unseenS = T;
	end;

     else if  hi.iPghP ^= null()  then			/*     OR show titles beyond current paragraph...	        */
	iSectP = hi.iPghP -> iPgh.relatives.sectP -> iSect.sib.nextP;
     else if  hi.iSectP ^= null()  then			/*     OR show titles beyond current section...	        */
	iSectP = hi.iSectP -> iSect.sib.nextP;
     else iSectP = iBlok.sects.firstP;			/*     OR must show all titles in current block...        */

  dcl 1 L		   aligned based (pLIST),		/* Overlay of LIST structure.			        */
      2 header	   like LIST.header,		/*  - array bounds and counts.		        */
      2 title	   char (84),			/*  - "section title" of output list.		        */
      2 group	   (0 refer (L.N)) like LIST.group,	/*  - .arg(*) are elements in the list.		        */
      2 arr	   (0 refer (L.Npghs), 0 refer (L.Nrows)) like LIST.print_array,
						/*  - .line_out(*) are rows of list to be displayed.      */
						/*    Each row contains Ncols of .arg(I) items.	        */
						/*     (see LIST dcl in _help_shared_data_.incl.pl1)      */
       pLIST	   ptr,
       Nlines	   char(8) var;

     pLIST = hi.next_free_spaceP;			/* Get space for a 1-use list.  It must be built and      */
						/*  displayed before any other ref to hi.next_free_spaceP */

  dcl  sect_title char(75) var;

     L.header = 0;					/* Initialize the list.			        */
     sect_title = "Section Titles";
     if  title_args.unseenS  then
	sect_title = sect_title || " with unseen paragraphs";
     else if  iSectP ^= iBlok.sects.firstP  then
	sect_title = sect_title || " that follow current paragraph";
     sect_title = sect_title || COLON;
     L.title = sect_title;

  dcl  found_unseenS bit(1) aligned;
  dcl  NEWLINE_COUNT fixed bin int static options(constant) init(1);

     do iSectP = iSectP
	repeat iSect.sib.nextP  while (iSectP ^= null() );

	sect_title = iSect.title.in_file;

	if  title_args.unseenS  then do;		/* Look for an unseen paragraph in this section.	        */
	     found_unseenS = F;
	     do iPghP = iSect.relatives.pghs.firstP
	         repeat iPgh.sibs.sect.nextP  while (iPghP ^= null & ^found_unseenS);
		if  ^iPgh.seenS  then
		     found_unseenS = T;
		end;
	     if  found_unseenS  then
		if  sect_title = ""  then		/*    NOTE: Only 1st section of block can lack a title.   */
		     sect_title = INFO_SECTION_NO_TITLE_FABRICATION;
	          else;
	     else sect_title = "";
	     end;
	else if  sect_title = ""  then
	     sect_title = INFO_SECTION_NO_TITLE_FABRICATION;

	if  sect_title ^= ""  then do;		/* Display non-blank section titles.		        */
	     Nlines = ltrim (char (iSect.line_count + NEWLINE_COUNT));
	     L.N = L.N + 1;
	     if  length(sect_title) + length(Nlines) + length(SP_PARENS) <= maxlength(L.arg(L.N))  then
		L.arg(L.N) = sect_title || SP_LPAREN || Nlines || RPAREN;
	     else L.arg(L.N) = sect_title;
	     end;
	end;

     if  L.N = 0  then do;
	sect_title = before(L.title, COLON);
	call response_error (AsciP, 0, "Found no ^a.", sect_title);
	end;
     

  dcl  titles_LIST_TITLE fixed bin int static options(constant) init(1);
  dcl  MAX_RESPONSES_COLUMNS fixed bin int static options(constant) init(5);
  dcl  MAX_RESPONSES_PARAGRAPHS fixed bin int static options(constant) init(1);
     
     call help_util_$format_one_use_LIST (AsciP, help_infoP, pLIST, MAX_RESPONSES_COLUMNS, MAX_RESPONSES_PARAGRAPHS);
     
     if  hi.block_progress = BLOCK_PROGRESS_needs_header  then do;
	hi.header_Nlines_follow = L.Nrows + titles_LIST_TITLE;
	call help_util_$execute (AsciP, help_infoP, "header");
	end;

     call help_util_$print_LIST (AsciP, help_infoP, pLIST);
     call newline(1);

     return;					/* The LIST just printed has now been released and        */
						/*  will be overwritten by other storage.	        */
%page;
/* ------------------------------------------------------------
   Process titles response arguments.
   ------------------------------------------------------------ */

Args_title:
     proc (c);

  dcl 1 c aligned like title_args;			/*  control arg specification data                   (in) */

     do while (args_remain());
	call ssu_$arg_ptr (AsciP, argI+1, argP, argL);	/* Conditionally read next arg to response	        */

	if isControlArg(arg) then do;

	     if       arg = "-t"    | arg = "-top"               then c.topS = T;

	     else if  arg = "-uns"  |  arg = "-unseen"           then c.unseenS = T;


               else do;
		call error (AsciP, error_table_$badopt, "Unsupported control arg: ^a", arg);
		c.arg_error = T;
		end;
	     end;
	
	else do;
	     call error (AsciP, error_table_$bad_arg, "Unsupported positional argument: ^a", arg);
	     c.arg_error = T;
	     end;

	argI = argI + 1;				/* Record that we processed the arg just examined above.  */
	end;

     end Args_title;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* RESPONSE: top, t								        */
	/*									        */
	/* Syntax as a response:   top {-section}					        */
	/*                           t {-scn}						        */
	/*									        */
	/* Function: moves pointer to next section to display to top of current block, or current section.*/
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

top:
     entry (AsciP, help_infoP);
     
/*dcl  AsciP ptr;					/* help_ subsystem's sci_ptr			(Input) */
/*dcl  help_infoP  ptr;				/* points to the help_info (hi) data structure.   (Input) */
     
  dcl 1 top_args aligned automatic,			/* Input arguments to the current titles response.        */
      2 control_args,
        3 sectionS bit(1) aligned,
      2 arg_error bit(1) aligned;			/*  =T: User gave invalid control arg or positional arg   */

     top_args = F;

     call arg_setup (AsciP);				/* Get lep response's control arguments (if any).	        */
     if args_remain() then
	call Args_top (top_args);
     if  top_args.arg_error  then			/*  - Return if user's response had argument errors.      */
	call response_error (AsciP);			/*  - Error in user's response?  Abort response line.     */

     if  hi.iBlokP = null()  then 			/* ASSERT: some info block should have been selected.     */
	call response_error (AsciP, error_table_$null_info_ptr, "Internal error: hi.iBlokP = null()");


     if  hi.display_limit = DISPLAY_LIMIT_section  then
	hi.display_limit = DISPLAY_LIMIT_none;		/*  - Turn off any section display limit.	        */


     if  top_args.sectionS  then			/* top -section: 				        */
     if  hi.selected.iPghP ^= null()  then do;		/*   If we've displayed a current paragraph, then jump to */
						/*    beginning of its section and display that section.  */
	iPghP = hi.selected.iPghP;
	iSectP = iPgh.relatives.sectP;
	
	hi.selected = null();			/*   Clear most recent paragraph, and print range.        */
	hi.iPgh_print_range = null();
	
	hi.selected.iSectP = iSectP;			/*   Print the entire section without questions.          */
	hi.iPgh_print_range.startP = iSect.pghs.firstP;
	hi.iPgh_print_range.endP   = iSect.pghs.lastP;

	hi.prompt_repeatS = F;			/*   Begin printing paragraph w/o prompt.	        */
	return;
	end;

     hi.selected = null();				/* top: Set most recent section/paragraph to null.        */
     hi.iPgh_print_range = null();

     iBlokP = hi.iBlokP;
     call newline (1);				/*  - Print block heading line identifying block to user  */
     call ioa ("^a", string (iBlok.header.reformatted));
     call newline (1);

     hi.prompt_repeatS = T;				/*  - Needed to prompt for new location.	        */

     return;
%page;
/* ------------------------------------------------------------
   Process top response arguments.
   ------------------------------------------------------------ */

Args_top:
     proc (c);

  dcl 1 c aligned like top_args;			/*  control arg specification data                   (in) */

     do while (args_remain());
	call ssu_$arg_ptr (AsciP, argI+1, argP, argL);	/* Conditionally read next arg to response	        */

	if isControlArg(arg) then do;

	     if       arg = "-scn"  |  arg = "-section"  then c.sectionS = T;

               else do;
		call error (AsciP, error_table_$badopt, "Unsupported control arg: ^a", arg);
		c.arg_error = T;
		end;
	     end;
	
	else do;
	     call error (AsciP, error_table_$bad_arg, "Unsupported positional argument: ^a", arg);
	     c.arg_error = T;
	     end;

	argI = argI + 1;				/* Record that we processed the arg just examined above.  */
	end;

     end Args_top;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* RESPONSE: unseen_paragraphs_only						        */
	/*									        */
	/* Syntax as a response:   unseen_paragraphs_only, unseen, uns			        */
	/*									        */
	/* Function:								        */
	/*   1) moves pointer to next section to display to top of current block.		        */
	/*   2) changes hi.display_limit to DISPLAY_LIMIT_unseen.				        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

unseen_paragraphs_only:
     entry (AsciP, help_infoP);
     
/*dcl  AsciP ptr;					/* help_ subsystem's sci_ptr			(Input) */
/*dcl  help_infoP  ptr;				/* points to the help_info (hi) data structure.   (Input) */
     
     call arg_setup (AsciP);				/* Error if any arguments given after the request name.   */
     if args_remain() then
	call response_error (AsciP, 0, "No arguments may be given.");

     if  hi.iBlokP = null()  then 			/* ASSERT: some info block should have been selected.     */
	call response_error (AsciP, error_table_$null_info_ptr, "Internal error: hi.iBlokP = null()");

     hi.selected = null();				/* top: Clear the most recent section/paragraph selection.*/
     hi.iPgh_print_range = null();

     hi.display_limit = DISPLAY_LIMIT_unseen;
     hi.prompt_repeatS = T;				/*  - Needed to prompt for new location and limit.        */

     return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* RESPONSE: yes, y								        */
	/*									        */
	/* Syntax as a response:   yes,						        */
	/*                           y						        */
	/*									        */
	/* Function: Accepts paragraph print range displayed in most recent prompt.		        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

yes:
     entry (AsciP, help_infoP);
     
/*dcl  AsciP ptr;					/* help_ subsystem's sci_ptr			(Input) */
/*dcl  help_infoP  ptr;				/* points to the help_info (hi) data structure.   (Input) */
     
     call arg_setup (AsciP);				/* Error if any arguments given after the request name.   */
     if args_remain() then
	call response_error (AsciP, 0, "No arguments may be given.");

     if  hi.display_limit < DISPLAY_LIMIT_unseen  then	/*  - Clear region containing previous prompt & response. */
	hi.clear_prompt_regionS = T;
     hi.prompt_repeatS = F;				/*  - Needed to print the pending sections in prompt.     */
     return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
%page;
%include help_args_;
%page;
%include help_cis_args_;
%page;
%include "_help_shared_data_";

     end help_responses_;
