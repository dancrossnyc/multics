/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
/* Status									*/
/*									*/
/* 0) Created:   November, 1969   by T. H. VanVleck				*/
/* 1) Modified:  February, 1975   by T. H. VanVleck - complete rewrite		*/
/* 2) Modified:  September,1976   by Steve Herbst - accept -pathname ctl_arg		*/
/* 3) Modified:  June, 1977	    by Paul Green - diagnose zero-length info segs	*/
/* 4) Modified:  October, 1978    by Gary Dixon - complete rewrite; split into help	*/
/*				command and separate help_ subroutine.		*/
/*				Add support for check_info_segs.		*/
/* 5) Modified:  April, 1985      by L. Adams - rewrote parsing routines to use line logic*/
/*									*/
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */

/****^  HISTORY COMMENTS:
  1) change(1986-03-05,LJAdams), approve(1986-03-05,MCR7327),
     audit(1986-04-17,Lippard), install(1986-04-24,MR12.0-1048):
     Changed routines to use line parsing.
  2) change(1986-05-08,LJAdams), approve(1986-05-14,MCR7416),
     audit(1986-06-06,Gilcrease), install(1986-06-12,MR12.0-1074):
     Changed sort so that the ep identifier is included.  This is so that
     separate infos are maintained for each entry_point is given on the
     command line.
  3) change(1986-09-04,LJAdams), approve(1986-09-04,MCR7506),
     audit(1986-10-29,GDixon), install(1986-10-30,MR12.0-1203):
     Moved error messages for no match on srh/section and entry point not
     found here to avoid printing duplicate error messages per info seg
     found in search path.
  4) change(1987-01-20,LJAdams), approve(1987-09-03,MCR7766),
     audit(1988-08-14,GDixon), install(1988-09-13,MR12.2-1109):
     Changed to version Vhelp_args_3.
  5) change(1988-02-17,LJAdams), approve(1988-03-07,MCR7857),
     audit(1988-08-14,GDixon), install(1988-09-13,MR12.2-1109):
     Changed to check the help_args.help_data_ptr to determine if it is a
     list_request operation.  This is because when checking the validity of
     names the lr operation must allow the (. .. ?) symbols.
  6) change(1988-03-14,LJAdams), approve(1988-06-01,MCR7873),
     audit(1988-08-14,GDixon), install(1988-09-13,MR12.2-1109):
     Changed VPDinfo_seg_1 to VPDinfo_seg_2.  Changed sort to eliminate
     duplicates from sorting 360 bits to sorting 396 bits. (phx21111)
  7) change(2020-07-30,GDixon), approve(2021-02-23,MCR10089),
     audit(2021-03-31,Swenson), install(2021-03-31,MR12.6g-0053):
      A) Rewrote entire help_ program.  User interface changes include:
      B) Support new block divider keywords that begin blocks in an info segment.
      C) Change default for min_Lpgh from 4 to 15 lines.
         Change default for max_Lpgh from 15 to terminal's page length.
      D) Add ALL_PARAGRAPHS label constant for use by new all_paragraphs response.
      E) For subroutine info seg, -section/-search use find_ep to look for matching
         entrypoint, then call section/search response to position within that ep.
                                                   END HISTORY COMMENTS */
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* SUBROUTINE:  help_							        */
	/*									        */
	/* This subroutine implements the help command.  It performs the following functions.	        */
	/*									        */
	/* 1) Finds info segments.							        */
	/* 2) Selects particular infos within multi-info segments.				        */
	/* 3) Sorts the list of infos to be processed.					        */
	/* 4) Processes each info, implementing all help control arguments and query responses.	        */
	/*									        */
	/* The subroutine may also be used to implement a help-style information facility in	        */
	/* other subsystems.  Information segments (with an info suffix or another suffix) are	        */
	/* selected and printed, based upon information given primarily in a help_args structure,	        */
	/* which is declared in help_args_.incl.pl1.					        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* ENTRYPOINT:  help_							        */
	/*									        */
	/* This entrypoint builds a list of info segments selected by help_args input data; then sorts    */
	/* that list; then walks though the list one item at a time, calling info_seg_ to parse the       */
	/* info segment into blocks; then enters the help_ ssu_ request loop to display that parsed info  */
	/* segment.								        */
	/*									        */
	/*									        */
	/* Usage									        */
	/*									        */
	/* The help_ subroutine must be invoked by a sequence of calls.			        */
	/*									        */
	/* 1) call help_$init to get temp segment containing help_args structure and stores the	        */
	/*    current info_segments search rules in the structure.				        */
	/* 2) call help_ one or more times to select and print info segments.			        */
	/* 3) call help_$term to release the temp segment.				        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

help_:
     procedure (procedure_name, Phelp_args, suffix, progress, Acode);

  dcl						/* 	Parameters			        */
       procedure_name char (*),			/* Caller of help_ and help_$init.		        */
						/*   1) Owns temp segment help_args are stored in.        */
						/*   2) Name used in error messages.		        */
/*     Phelp_args	   ptr,				/* ptr to argument struct returned by help_$init	        */
						/* This ptr really declared in include seg:	        */
						/*  help_args_.incl.pl1			        */
       suffix	   char (*),			/* Suffix on segs to be processed. Normally "info"        */
						/* but may be some other suffix or "" to omit	        */
						/* suffix processing.			        */
       progress	   fixed bin,			/* =1: bad help_args version			        */
						/* =2: no pathnames given.			        */
						/* =3: evaluating pathnames.			        */
						/* =4: finding help segs.			        */
						/* =5: -section/-search & printing help segs.	        */
       Acode	   fixed bin (35);			/* Return code.				        */

  dcl  PDeps	   ptr,
       Ptemp	   ptr,
       fcn	   fixed bin,			/* Function to be performed by this invocation.	        */
      (
       HELP	   init (0),			/*   help_				        */
       CIS	   init (1)			/*   help_$check_info_segs			        */
       )		   fixed bin int static options (constant),
      (i, j)	   fixed bin,
       offset	   fixed bin (35);

  dcl  bit36	   bit (36) aligned based,
       bit72	   bit (72) aligned based,
       bit360	   bit (360) aligned based;
%page;
  dcl (addr, addrel, binary, char, charno, clock, currentsize, dim, dimension, divide, empty, hbound, index, lbound, length,
       ltrim, mod, null, ptr, rel, reverse, rtrim, search, string, substr, unspec, verify)
		   builtin;

  dcl (cleanup, program_interrupt)
		   condition;

  dcl  convert_date_to_binary_ entry (char (*), fixed bin (71), fixed bin (35)),
       get_line_length_$switch entry (ptr, fixed bin (35)) returns (fixed bin),
       get_page_length_$switch entry (ptr, fixed bin (35)) returns (fixed bin),
       hcs_$get_uid_file entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
       hcs_$truncate_seg entry (ptr, fixed bin, fixed bin (35)),

       help_listen_util_$display_prompt entry (ptr),
       help_listen_util_$print_iPgh_range entry (ptr),
       help_listen_util_$set_iPgh_range entry (ptr),
       help_request_tables_$for_non_subroutine_info entry options(variable),
       help_request_tables_$for_subroutine_info entry options(variable),
       help_requests_$unknown_response entry (ptr, ptr, char(*), ptr, bit(1) aligned),
       help_responses_$lep_setup entry (ptr, ptr),
       help_util_$execute entry (ptr, ptr, char(*)),
       help_util_$print_section entry (ptr, ptr, ptr),

       info_seg_$examine_iFile entry (ptr, char(*), char(*), bit(36) aligned, fixed bin(35)) returns(ptr),
       info_seg_$init_for_help_ entry (ptr, fixed bin(35)),
       info_seg_$parse_iFile entry (ptr, ptr),
       info_seg_$reinitialize entry (ptr),
       info_seg_$terminate entry (ptr),
       info_seg_$unthread_iBlok entry (ptr),

       info_seg_util_$count_files entry (ptr) returns (fixed bin),
       info_seg_util_$is_Subroutine_kind entry (fixed bin) returns(bit(1) aligned),

       match_star_name_ entry (char (*), char (*), fixed bin (35)),
       pathname_$component entry (char (*), char (*), char (*)) returns (char (194)),
       release_temp_segment_ entry (char (*), ptr, fixed bin (35)),
       search_paths_$get entry (char (*), bit (36), char (*), ptr, ptr, fixed bin, ptr, fixed bin (35)),

       sort_items_$bit entry (ptr, fixed bin),
       sort_items_$char entry (ptr, fixed bin),

       ssu_$set_procedure entry (ptr, char(*), entry, fixed bin(35));


  dcl (error_table_$bad_seg,
       error_table_$improper_data_format,
       error_table_$inconsistent,
       error_table_$incorrect_access,
       error_table_$moderr,
       error_table_$no_s_permission,
       error_table_$noarg,
       error_table_$noentry,
       error_table_$no_info,
       error_table_$nomatch,
       error_table_$unimplemented_version,
       error_table_$zero_length_seg,
       ssu_et_$subsystem_aborted
       ) fixed bin (35) ext static,

       iox_$user_input ptr ext static,			/* Used to obtain input (responses) from the user.        */
       iox_$user_output ptr ext static,			/* Used to check for line and page length of output lines */
       iox_$user_io ptr ext static,			/* Used to check for video-based input.		        */
       video_data_$terminal_iocb ptr ext static;
%page;
						/* Include file placed here so constants may be	        */
						/*  referenced in label array values below.	        */
%include info_seg_dcls_;
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

     fcn = HELP;					/* Perform a help function.			        */
     go to HELP_COMMON;



	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* ENTRYPOINT:  help_$check_info_segs						        */
	/*									        */
	/* This entrypoint generates the list of info segments to be processed by the		        */
	/* check_info_segs command.  It finds info segments modified since a given date, sorts	        */
	/* the list and returns it for check_info_segs to process.				        */
	/*									        */
	/* Usage									        */
	/*									        */
	/* 1) call help_$init to get temp segment containing help_args and the output list.	        */
	/* 2) call help_$check_info_segs to build and sort the list of segments to be processed.	        */
	/* 3) call help_$term to release the temp segment.				        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

check_info_segs:
     entry (procedure_name, Phelp_args, suffix, progress, Acode, APPDinfo_seg);

  dcl  APPDinfo_seg    ptr;				/* Ptr to output structure returned by		        */
						/*   help_$check_info_segs			        */

     fcn = CIS;					/* Perform a check_info_segs function.		        */
     APPDinfo_seg = null();				/*  - initialize output argument for this function.       */
     

/* --------------------------------------------------------------------------------
   progress = 1:  Check version of help_args input structure.
   -------------------------------------------------------------------------------- */

HELP_COMMON:
     progress = 1;				
     Acode = 0;					/* Initialize error code.			        */

     if  help_args.version = 1 | help_args.version = 2  then do
	help_args.version = Vhelp_args_3;		/*  - Ver 1 and 2 are upwards-compatible with 3 by setting*/
	help_args.sci_ptr = null;			/*    variables added in later versions to their default  */
	help_args.help_data_ptr = null;		/*    values.				        */
	help_args.Sctl.inhibit_errors = F;
	end;
     if  help_args.version ^= Vhelp_args_3  then do;	/*  - Report error if unsupported version.	        */
	Acode = error_table_$unimplemented_version;
	return;
	end;


/* --------------------------------------------------------------------------------
   progress = 2:  Check that info seg paths (input data for this call) were given.
   -------------------------------------------------------------------------------- */

     progress = 2;					/* Make sure info file names were given.	        */
     if  help_args.Npaths ^> 0  then do;
	Acode = error_table_$noarg;
	return;
	end;


/* --------------------------------------------------------------------------------
   progress = 3:  
    A) Access help_info (hi) and info_seg_data (isd) structures.
    B) Adjust temp segment hi.next_free_spaceP based on current size of
       help_args structure.  Presumably, caller added path(*) array
       elements.
    C) Evaluate input help_args.path(*) for incorrect usage errors.
   -------------------------------------------------------------------------------- */

     progress = 3;					/* Access hidden help_info structure, and other	        */
						/*  structures that precede help_args in temp seg	        */
						/*  (see _help_shared_data_.incl.pl1)		        */
						/* Then evaluate input paths...		        */

     help_infoP = ptr (Phelp_args, 0);			/*  - Structure at Position 1 in temp seg.	        */
     hi.help_ptrs = null();				/*     - remove storage from any previous help_ call.     */
     hi.help_labels = SUBSYSTEM_ABORTED;		/*     - provide some value for pi/abort labels.	        */
     hi.help_numbers = 0;
     hi.info_ptrs = null();
     hi.info_switches = F;

/*dcl 1 isd aligned like info_seg_data based (hi.isdP);	/*  - Structure at Position 2 in temp seg	        */
						/*     - setting help_infoP makes hi.isdP accessible.     */
						/*     - isd is really setup in help_$init, which	        */
						/*       prepares this structure for calls to	        */
						/*       info_seg_$init_for_help_		        */

     hi.next_free_spaceP = Phelp_args;			/*  - Structure at Position 3 in temp seg.	        */
						/*     - Phelp_args should be exact value returned to     */
						/*       caller of help_$init			        */
     call set_space_used (currentsize (help_args));	/*     - reset hi.next_free_spaceP w/ current help_args   */
						/*       size.				        */


     do i = 1 to help_args.Npaths;			/*  - Examine/expand/evaluate input paths.	        */
	call evaluate_path (help_args.path (i), suffix);
	if Acode = 0 then				/*     - no errors found earlier?		        */
	     Acode = help_args.path.code (i);		/*        - return first error that occurs, so caller     */
	end;					/*          knows there are errors.  Caller responsible   */
     if Acode ^= 0 then				/*          for displaying any errors in 	        */
	return;					/*          help_args.path.code(i) elements.	        */

%page;
/* --------------------------------------------------------------------------------
   progress = 4: Prepare to do directory searching, and to look inside 
	       found info segments for any info blocks they may contain.
   -------------------------------------------------------------------------------- */

     progress = 4;					/* From here on, help_ exits by restoring help_args       */
						/*  temp segment to its length when help_ was called.     */
						/* help_$check_info_segs returns with structures in the   */
						/*  temp segment after the help_args structure.	        */

     hi.help_numbers.terminal_lineL = min (HELP_LINE_SIZE_MAX, get_line_length_$switch (iox_$user_output, code));
     if code ^= 0 then
	hi.terminal_lineL = HELP_LINE_SIZE_DEFAULT;	/* Get user's terminal line size.		        */
     if  ^help_args.Sctl.no_video  &  video_data_$terminal_iocb ^= null()  then
	hi.video_iocbP = iox_$user_io;		/* Setup for prompt/response overwrite if video_invoked   */
     else hi.video_iocbP = null();			/*  No overwrite if -no_video or [not [wdc video_invoked]]*/
     hi.prompt_region = 0;
     hi.clear_prompt_regionS = F;
     hi.help_video_data.hvd_pad = F;

     hi.help_numbers.infos_printedN = 0;		/*  - No info segs printed so far.		        */
						/*      (tested at EXIT_NO_MATCH label below)	        */
     hi.help_numbers.newline_Nblanks_output = 0;		/*  - No newlines emitted yet.		        */

     if  fcn = HELP  &  isd.areaP = null()  then do;	/* Prepare to parse info segs into one or more blocks.    */
						/*  - Init not needed now if done in prior call to help_. */
						/*     (info_seg_$init_for_help_ sets isd.areaP non-null) */
						/*  - info_seg_ is not used by: help_$check_info_segs     */
						/*      (fcn = CIS)				        */
	call info_seg_$init_for_help_ (addr (isd), Acode);
	if  Acode ^= 0  then			/*      Note: isd storage was setup by help_$init	        */
	     return;
	end;

/* -----------------------------------------------------------------
   Directory search generates a Dinfo structure stored in temp seg
    (after help_args structure).
   Subsequent call to parse info seg into blocks adds one
     Dinfo.seg(I) array element for each matching info block.  
      - For purposes of Dinfo structure, a subroutine info w/ :Entry:
        dividers is treated as a "single block describing the subroutine".
   ----------------------------------------------------------------- */

    hi.Dinfo_arrayP, PDinfo = hi.next_free_spaceP;	/*  - Structure at Position 4 in temp seg.	        */
						/*     - Get space (after help_args) for Dinfo structure  */
						/*     PDinfo and Dinfo are declared in:	        */
						/*        _help_shared_data_.incl.pl1  &	        */
						/*        help_cis_args_.incl.pl1		        */

    Dinfo.N = 0;					/*  - Dinfo.seg(I) items start as info seg descriptions   */
						/*    (1 or more for each help_args.path(*) item).        */

    do i = 1 to help_args.Npaths;			/*  - Star convention and info_seg search paths means     */
						/*    each info path can add several Dinfo.seg(I) items.  */
						/*    Each .seg(I) is then expanded to include one        */
						/*    .seg(I) item for each matching info block found in  */
						/*    one of those info segs.			        */

         if  help_args.path (i).S.less_greater		/*     - dir components given in help_args.path(i)?       */
 	|  help_args.Nsearch_dirs = 0  then		/*      OR caller gave no info search paths?	        */
	    call get_info_seg_list (suffix, fcn, help_args.path (i).dir (*), help_args.path (i), PDinfo);
						/*        - don't use info_segs (or other) search paths   */
         else call get_info_seg_list (suffix, fcn, help_args.search_dirs (*), help_args.path (i), PDinfo);
         end;					/*        - do use info_segs (or other) search paths.     */

    if  Dinfo.N <= 0  then				/*  - Stop if no matching Dinfo_seg (blocks) were found.  */
         go to EXIT_NO_MATCH;
    call set_space_used ( currentsize (Dinfo) );		/* Record space used for Dinfo structure in temp segment. */

%page;
/* --------------------------------------------------------------------------------
   progress = 5:  Create an array of pointers to Dinfo.seg(I) items that can be sorted
	        based on values at various offsets within each Dinfo.seg(I) structure.
   -------------------------------------------------------------------------------- */

     progress = 5;					/* Infos selected by starname.  Any other errors	        */
						/*  reported via Acode describe info selection by	        */
						/*  -search and -section criteria (done below).	        */

     hi.Dinfo_sort_ptrsP, PPDinfo_seg = hi.next_free_spaceP;/*  - Structure at Position 5 in temp seg.	        */
						/*     PDinfo_seg is declared in help_cis_args_.incl.pl1  */

     PDinfo_seg.version = VPDinfo_seg_3;		/* PDinfo_seg is returned by help_$check_info_segs so it  */
						/*  has: a .version element.			        */
     PDinfo_seg.N = Dinfo.N;				/*       a .N element: count of ptrs returned.	        */
						/*       a .P element: points to each Dinfo.seg(*) item.  */
						/*     - these pointers get sorted by next steps.	        */

			/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
			/*							*/
			/* Sort pointers to found blocks three times:			*/
			/*  1st:  sort on  Dinfo.seg.uid/.I/.E/.X  combo to detect duplicate	*/
			/*	infos.  Duplicates are eliminated from list.		*/
			/*  2nd:  sort on Dinfo.seg.ent to identify versions of info seg in	*/
			/*	different dirs.					*/
			/*  3rd:  sort on Dinfo.seg.Scross_ref/.ent combination to		*/
			/*	alphabetize output.					*/
			/*							*/
			/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

     if  Dinfo.N = 1  then				/*   Skip sorting if only 1 info seg/block was found.     */
	PDinfo_seg.P (1) = addr (Dinfo.seg (1).ent);

     else 					/*   1st:  sort on  Dinfo.seg.uid/.I/.E/.X combo	        */
SORT_STEP_1:					/* 	 to detect duplicate infos.		        */
     do;
	do i = 1 to Dinfo.N;
	     PDinfo_seg.P (i) = addr (Dinfo.seg (i).uid); /*   - point to Dinfo.seg.uid of array element	        */
	     Dinfo.seg (i).X = i;			/*   - .X indicates order in which blocks were found      */
	     end;					/*     relative to help_args.paths input specification,   */
						/*     & order of help_args.search_dirs (info_segs paths) */

	call sort_items_$bit (addr (PDinfo_seg.N), 11 * BITS_PER_WORD);
						/*   - Sort on content of 11 words starting at	        */
						/*     Dinfo.seg(*).uid :  1 for uid		        */
						/*                         1 for block offset w/in info   */
						/*                         8 for info seg entryname       */
						/*                         1 for order found by search    */

	offset = binary (rel (addr (Dinfo.seg (1).ent))) - binary (rel (addr (Dinfo.seg (1).uid)));
						/*  - Compute offset to change pointers from	        */
						/*    Dinfo.seg.uid to point to Dinfo.seg.ent	        */

	do i = 1 to Dinfo.N while (PDinfo_seg.P (i) -> bit72 = "0"b);
	     PDinfo_seg.P (i) = addrel (PDinfo_seg.P (i), offset);
	     end;					/* Adjust offset in ERROR entries.  These have duplicate  */
						/*  .uid/.I combos (zero bits set when error detected).   */
						/*  Avoid eliminating these duplicates so the	        */
						/*  errors can be reported.  The 1st sort call (above)    */
						/*  moved pointers to such error items to top of list.    */

	if i > Dinfo.N then				/* If all info segs are in error, skip the	        */
	     go to SKIP_ELIMINATION;			/*  elimination of duplicates.		        */
	j = i - 1;				/* j+1 will be index of pointer to retained items in      */
						/*  the CHECK(i) code below.			        */

	go to CHECK (fcn);				/* Checking differs by help_ entrypoint.	        */

CHECK (HELP):
	do i = i to Dinfo.N - 1;			/* Eliminate duplicate .uid/.I/.E combos for non-errant   */
						/*  Dinfo.seg(I) items.			        */
	     if  PDinfo_seg.P (i) -> bit360 ^= PDinfo_seg.P (i + 1) -> bit360  then do;
		j = j + 1;			/*   (Only retain unique .uid/.I/.E combos.)	        */
		PDinfo_seg.P (j) = addrel (PDinfo_seg.P (i), offset);
		end;
	     else PDinfo_seg.P (i + 1) = PDinfo_seg.P (i);
	     end;					/*   (Retain info found earliest in search rules).        */
	go to END_CHECK;

CHECK (CIS):
	do i = i to Dinfo.N - 1;			/* Eliminate duplicate .uid combos.		        */
	     if  PDinfo_seg.P (i) -> bit36 ^= PDinfo_seg.P (i + 1) -> bit36  then do;
		j = j + 1;			/*   (Only retain unique .uid combos.)		        */
		PDinfo_seg.P (j) = addrel (PDinfo_seg.P (i), offset);
		end;
	     else PDinfo_seg.P (i + 1) = PDinfo_seg.P (i);
	     end;					/*   (Retain info found earliest in search rules).        */

END_CHECK:
	j = j + 1;				/*   (Always retain the last entry in the list.)	        */
	PDinfo_seg.P (j) = addrel (PDinfo_seg.P (i), offset);
	PDinfo_seg.N = j;				/*   Reset count of pointers to those being retained.     */

	end SORT_STEP_1;

%page;
SKIP_ELIMINATION:					/*   2nd:  sort on Dinfo.seg.ent to identify	        */
						/* 	 versions of info seg in different dirs.        */

     call set_space_used ( currentsize(PDinfo_seg) );	/* Record space used by PDinfo_seg structure in temp seg  */
						/*  now that duplicates have been eliminated.	        */

     if  PDinfo_seg.N = 1  then do;
	PDinfo_seg.P (1) = addr (Dinfo.seg (1).Scross_ref);
	goto SORT_END;
	end;

     else
SORT_STEP_2:
     do;						/* Sort alphabetically by ent to identify info	        */
						/*  segments appearing in more than one search dir.       */
	call sort_items_$char (addr (PDinfo_seg.N), length(Dinfo.seg (1).ent) );

	offset = binary (rel (addr (Dinfo.seg (1).Scross_ref))) - binary (rel (addr (Dinfo.seg (1).ent)));
						/* Compute offset to change pointers from	        */
						/*   Dinfo.seg.ent to point to Dinfo.seg.Scross_ref       */

	PDinfo_seg.P (1) = addrel (PDinfo_seg.P (1), offset);
	do i = 1 to Dinfo.N - 1;			/* Check for entry of same name in different dirs.        */
	     PDinfo_seg.P (i + 1) = addrel (PDinfo_seg.P (i + 1), offset);
	     if  PDinfo_seg.P (i) -> Dinfo_seg.ent  = PDinfo_seg.P (i + 1) -> Dinfo_seg.ent
	       & PDinfo_seg.P (i) -> Dinfo_seg.uid ^= PDinfo_seg.P (i + 1) -> Dinfo_seg.uid
	       & PDinfo_seg.P (i) -> Dinfo_seg.uid ^= "0"b  &  "0"b ^= PDinfo_seg.P (i + 1) -> Dinfo_seg.uid  then do;
						/* Mark all but entry found earliest in search	        */
						/*  rules with a cross reference flag.		        */

		if  binary (rel (PDinfo_seg.P (i)), 18) < binary (rel (PDinfo_seg.P (i + 1)), 18)  then do;
		     Ptemp = PDinfo_seg.P (i);	/*  - Swap to make ptr to first found item later in list. */
		     PDinfo_seg.P (i) = PDinfo_seg.P (i + 1);
		     PDinfo_seg.P (i + 1) = Ptemp;
		     end;
		PDinfo_seg.P (i) -> Dinfo_seg.Scross_ref = T;
		end;				/*  - Turn on Scross_ref in dup item (now lowest in list) */
	     end;
	end SORT_STEP_2;

SORT_STEP_3:
     if PDinfo_seg.N > 1 then 			/*   3rd:  sort on Dinfo.seg.Scross_ref/.ent	        */
						/* 	 combination to alphabetize output.	        */
	call sort_items_$char (addr (PDinfo_seg.N), 
			   CHARS_PER_WORD + length(Dinfo.seg (1).ent) );
     

SORT_END:
     if  fcn = CIS  then do;
	APPDinfo_seg = PPDinfo_seg;			/* Return pointer to PDinfo_seg to help_$check_info_segs  */
	return;					/*  caller.				        */
	end;
%page;
						/* help_$help_ continues processing...		        */
     call ssu_$set_prompt_mode (hi.sciP, DONT_PROMPT);	/*  - Disable ssu_ prompting...		        */

     call ssu_$set_procedure (hi.sciP, "pre_request_line", help_listen_util_$display_prompt, code);
						/*  - help_ does its own prompts with info section titles */
     if  code ^= 0  then do;				/*    and "More help?" query.			        */
	call error (hi.sciP, code, "Replacing ssu_ pre_request_line procedure.");
	goto SUBSYSTEM_ABORTED;
	end;

     call ssu_$set_procedure (hi.sciP, "post_request_line", help_listen_util_$print_iPgh_range, code);
						/*  - help_ is called by ssu_$listen to actually display  */
     if  code ^= 0  then do;				/*    "selected" info block paragraphs.		        */
	call error (hi.sciP, code, "Replacing ssu_ post_request_line procedure.");
	goto SUBSYSTEM_ABORTED;
	end;

     call ssu_$set_procedure (hi.sciP, "unknown_request", help_requests_$unknown_response, code);
						/*  - help_ diagnoses "Unknown request ..." as an	        */
     if  code ^= 0  then do;				/*    "Unknown response ..."			        */
	call error (hi.sciP, code, "Replacing ssu_ unknown_request procedure.");
	goto SUBSYSTEM_ABORTED;
	end;


     hi.PI_LABEL = PROCESS;				/* Establish pi handler: enter PROCESS loop	        */

     on program_interrupt begin;
	hi.print_inhibitS = T;			/* Tell help_ to stop printing stuff about current info   */
	go to hi.PI_LABEL;				/*  block, and branch to code for next "More help?"       */
	end;					/*  prompt (or display of next info segment).	        */

     call ssu_$set_procedure (hi.sciP, "program_interrupt", help_program_interrupt_, code);
     if  code ^= 0  then do;				/* Tell ssu_listen_ to use our program_interrupt handler. */
	call error (hi.sciP, code, "Replacing ssu_ program_interrupt procedure.");
	goto SUBSYSTEM_ABORTED;
	end;

     	help_program_interrupt_:			/* Procedure passed to ssu_$set_procedure to replace the  */
               procedure (AsciP);			/*  "program_interrupt" handler of ssu_$listen.	        */

            dcl  AsciP ptr;				/* This is the ssu_ control info ptr, which it ignores.   */
						/*  All data referenced via entry variable's display ptr. */

               hi.print_inhibitS = T;			/* Tell help_ to stop printing stuff about current info   */
	     hi.prompt_repeatS = T;			/*  block, and to displaynext "More help?" prompt.        */

						/* This procedure returns to ssu_$listen handler, which   */
						/*  branches to its READ_REQUEST label, which calls the   */
						/*  pre-request-line procedure as its first action.       */
	     end help_program_interrupt_;		/*  That proc is our help_listen_util_$display_prompt     */


%page;
PROCESS:
     code = 0;
WALK_POINTERS_TO_INFO_BLOCKS:
     do i = 1 to PDinfo_seg.N while (code = 0);		/* Process each listed info in alphabetical order.        */

	hi.PI_LABEL, hi.NEXT_INFO_LABEL = NEXT_INFO;	/*  - Once inside PROCESS loop, pi jumps to NEXT_INFO     */
						/*    "next" response also jumps to NEXT_INFO	        */

	hi.info_ptrs = null();			/* Setup environment for processing new info block.       */

	if  hi.display_mode ^= DISPLAY_MODE_unset  then do;    
						/* Remove use of any prior ssu_ request table.	        */
	     if  hi.display_mode = DISPLAY_MODE_non_subroutine  then
		call ssu_$delete_request_table (hi.sciP, addr(help_request_tables_$for_non_subroutine_info), code);
	     else if  hi.display_mode = DISPLAY_MODE_subroutine  then
		call ssu_$delete_request_table (hi.sciP, addr(help_request_tables_$for_subroutine_info), code);
	     hi.display_mode = DISPLAY_MODE_unset;
	     end;

	hi.Dinfo_sort_ptrsI = i;			/*  - Record index of PDinfo_seg.P we're using now, so    */
						/*    responses know index of Dinfo_item being displayed. */

	hi.DinfoP = PDinfo_seg.P (i);			/*  - Save pointer to selected Dinfo_item being displayed.*/

	if  Dinfo_item.code ^= 0  then		/* Print any error encountered finding info seg/block     */
	     go to INFO_ERROR;


	if  info_seg_util_$count_files (addr (isd)) > 10  then
REINITIALIZE:  call info_seg_$reinitialize (addr (isd));	/* Avoid having more than 10 info segs initiated	        */

	iFileP =					/* Get threaded list of blocks in this info seg.	        */
	     info_seg_$examine_iFile (addr (isd), Dinfo_item.dir, Dinfo_item.ent, Dinfo_item.uid,
				Dinfo_item.code);	/*   NOTE: This finds/re-uses the blocks parsed in prior  */
						/*         call to info_seg_$examine_iFile (in	        */
						/*         get_info_seg_list) if fewer than 10 info segs  */
						/*	 are in the list.  But if info_seg_$reinitialize*/
						/*         has released that earlier storage, this call   */
						/*	 reparses the info seg.		        */

	if  iFileP = null ()  &			/* No iFile returned but got other iFiles earlier	        */
	    isd.files.firstP ^= null ()  then
	     go to REINITIALIZE;			/*  - Release storage for prior files so this	        */
						/*    new file can be processed.		        */

	if  iFileP = null()  then do;			/*  - Info seg parse failure.  (Highly unlikely!)	        */
	     Dinfo_item.code = error_table_$improper_data_format;
	     go to INFO_ERROR;
	     end;

	call info_seg_$parse_iFile (addr (isd), addr (iFile));
						/* Complete parsing each info block into sections and     */
						/*  paragraphs.				        */

	iBlokP = iFile.bloks.lastP;			/*   - Unthread any history comment block from list.      */
	if iBlokP ^= null () then			/*     NOTE: history comment may have been unthreaded     */
	if iBlok.divider = iBlok_divider_hcom  |	/*           during prior call to info_seg_$examine_iFile */
	   iBlok.divider = iBlok_divider_hcom_obsolete	/*           in get_info_seg_list_ procedure.  But that   */
	then					/*           $examine_iFile data could have been released */
	     call info_seg_$unthread_iBlok (iBlokP);	/*           by an info_seg_$reinitialize call.	        */
	

	go to INFO_STRUCT (iFile.structure);		/*  Range of iFile.structure values checked by earlier    */
						/*  call to get_info_seg_list.		        */

INFO_STRUCT (iFile_structure_INFO_HCOM):		/* Seg with :Info: or :[Info]: dividers.	        */
INFO_STRUCT (iFile_structure_INFO):
	do iBlokP = iFile.bloks.firstP		/*  - Find iBlok referenced by Dinfo_item.	        */
	     repeat iBlok.sib.nextP  while (iBlokP ^= null() );
	     if  charno(iBlok.P) = Dinfo_item.I  then do; /*  - Display that block.			        */
		call display_block();		/*    NOTE: This could be single-entrypoint subroutine    */
		go to NEXT_INFO;			/*          like match_star_name_$match_star_name_;       */
		end;				/*          display_block will decide.		        */
	     end;
	Dinfo_item.code = error_table_$noentry;		/* Matching iBlok not found.  It was there when	        */
	go to INFO_ERROR;				/*  get_info_seg_list just referenced it...	        */

INFO_STRUCT (iFile_structure_NO_DIVIDERS):		/* Seg with no dividers.  
	iBlokP = iFile.bloks.firstP;			/*  - Display the only block in the info segment.	        */
	call display_block();			/*    NOTE: This could be single-entrypoint subroutine    */
	go to NEXT_INFO;				/*          like match_star_name_$match_star_name_;       */
						/*          display_block will decide.		        */


INFO_STRUCT (iFile_structure_INFO_SUBROUTINE_HCOM):	/* Seg with :Entry: dividers.			        */
INFO_STRUCT (iFile_structure_INFO_SUBROUTINE):
INFO_STRUCT (iFile_structure_SUBROUTINE):
	iBlokP = iFile.bloks.firstP;			/*  - Display subroutine intro block if no entrypoint     */
	if  Dinfo_item.ep = ""  then do;		/*    name was given.			        */
	     call display_block();
	     go to NEXT_INFO;
	     end;

  dcl  epI fixed bin;				/*  - Search for :Entry: block matching entrypoint name.  */
	do iBlokP = iBlok.sib.nextP
	     repeat iBlok.sib.nextP  while (iBlokP ^= null() );
	     do epI = lbound(Blok_names,1) to hbound(Blok_names,1);
		if  Blok_names(epI) = Dinfo_item.ep  then do;
		     call display_block();
		     go to NEXT_INFO;
		     end;
		end;
               end;

	Dinfo_item.code = error_table_$noentry;		/*  - Report error if no block for given entrypoint name. */
	call error (hi.sciP, Dinfo_item.code,
	     " Looking for entry point: ^a^/   in ^[link^;segment^;directory^]: ^a^[>^]^a", 
	     Dinfo_item.ep,
	     binary (Dinfo_item.segment_type, 2) + 1, 
	     Dinfo_item.dir, Dinfo_item.dir ^= ">", Dinfo_item.ent);
	hi.infos_printedN = hi.infos_printedN + 1;	/*     -  error about info counts as "printing it".       */
	go to NEXT_INFO;
	

INFO_ERROR:
	call error (hi.sciP, Dinfo_item.code, 
	     " ^[Looking for an info block matching: ^a^/   in^;^sFor^] ^[link^;segment^;directory^]: ^a^[>^]^a", 
	     (Dinfo_item.info_name ^= ""), Dinfo_item.info_name,
	     binary (Dinfo_item.segment_type, 2) + 1, 
	     Dinfo_item.dir, Dinfo_item.dir ^= ">", Dinfo_item.ent);
						/*     -  error about info IS NOT "printing it".	        */
						/*        Do NOT increment hi.infos_printedN here!        */
						/*        That breaks multi-call of help_ in probe/mbuild */

NEXT_INFO:					/* This label is used by help_'s "next" response routine. */
	hi.next_free_spaceP = addr(PDinfo_seg);		/* Release space used to display last info from temp seg. */
	call set_space_used ( currentsize(PDinfo_seg) );	/* Record space used by PDinfo_seg structure in temp seg  */
						/*  to make hi.next_free_spaceP point to the doubleword   */
						/*  after the PDinfo_seg array.		        */

	end WALK_POINTERS_TO_INFO_BLOCKS;

SUBSYSTEM_ABORTED:					/* This exit is used by help_'s "quit" response.	        */
EXIT_NO_MATCH:					/* This exit is used only by fcn = HELP.	        */
     if hi.infos_printedN = 0 then			/* -section and -search didn't find any match.	        */
	Acode = error_table_$nomatch;

     if  isd.areaP ^= null()  then			/* Terminate all info segments, and cleanup storage used  */
	call info_seg_$reinitialize (addr(isd));	/*  by the info_seg_ facility.		        */

     hi.next_free_spaceP = hi.help_argsP;		/* Remove temp seg data beyond the current help_args      */
     call set_space_used ( currentsize(help_args) );	/*  structure.				        */
     call hcs_$truncate_seg (Phelp_args, binary (rel (Phelp_args)) + currentsize (help_args), 0);
						/* help_ is now ready to be called again.	        */

     return;					/* This is the main return from help_$help_ to its caller */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
/*											        *
  ORDER OF PROCESSING help_args.Sctl arguments:           [taken from earlier version of help_ routine: help_rql_.pl1]

   - Some help_args values continue selection of which info blocks to display;
     they examine info block attributes and/or contents.  These include:

     help_args
      .min_date_time mostly ignored by help_$help_;  help_$init disables this test; never set by help.pl1). 


      .Sctl.scn:     copy -section args to local storage \  arg values become defaults if 1st...Ith response given 
      .Sctl.srh	 copy -search args to local storage  /   w/o args.  Each time args are given, the new args become
						 defaults for later responses given without args.
       for hi.display_mode = 
           non_subroutine: If block does not have any section with title matching a -section STR; and/or 
		       if block does not have any paragraph matching a -search STR ...
		        then that block is totally ignored by display_block (see below). 
		        If a second instance of file was found later in info_seg search paths, 
		        that file is promoted to primary candidate and is also tested for 
		        matching the -section titles and/or -search paragraphs.

	     subroutine: With no  entrypoint name given (ie, iBlok points to subr intro block):
		        then select an :Entry: block by searching through all :Entry: blocks 
		        looking for -section/search match.  First matching block is selected for display.
		        If no matching :Entry: block found, display subroutine intro block ignoring -section/-search.
		       With specific entrypoint given: 
		        then -section/search applies only to that :Entry: block as described for non-subroutine block.


   - Other help_args values control how info block is displayed...

      .Sctl.he	 Display only a header for selected info block.


      .Sctl.bf	 Display only brief summary of Syntax, Arguments, Control arguments and List of ... sections.
		 For hi.display_mode = subroutine, this control arg is ignored unless an :Entry: block is selected.

      .Sctl.ca	 Display only description of matching Argument, Control argument or List of ... items.
		 For hi.display_mode = subroutine, this control arg is ignored unless an :Entry: block is selected.

      .Sctl.lep:	 Ignored for hi.display_mode = non_subroutine.
		 For hi.display_mode = subroutine:
		  create and print list of entrypoint names for any subroutine block.  Then prompt
		  user before displaying subroutine introduction block, so user may use ep request
		  to select a subr_$entrypoint block to display instead.  
		  [NOTE: If -lep is not given, the subr_ introduction block is displayed automatically 
		         (along with a list of entrypoints), then the user is prompted.  Thus, 
		         -lep suppresses auto-display of subr_ introduction.]


      .Sctl.all:	 Display without prompting user... 

       for hi.display_mode = 
	 non_subroutine: all lines in current block 

	     subroutine: with no  entrypoint name given:  all intro and Entry blocks;
		       with specific entrypoint given:  all lines for that :Entry: block.


      .Sctl.title	 Display section titles of current block.  Then prompt for first section(s) of block.
/*											        *
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* INTERNAL PROCEDURE:  display_block						        */
	/*									        */
	/*  REFERENCES caller-supplied variables instead of parameters:			        */
	/*   help_infoP     points to help_info (hi) structure containing global help_ information.       */
	/*   hi.DinfoP	points to Dinfo_item structure for current item in "selected info blocks".    */
	/*   iFileP	points to iFile structure for info seg containing block to be displayed.      */
	/*									        */
	/*  This scheme permits display_block to use caller-declarations for Dinfo_item, iFile, and iBlok */
	/*  structures.  Values for three variables above are NOT changed by display_block.	        */
	/*									        */
	/*  USURPS caller-supplied variables:						        */
	/*   iBlokP	points to iBlok structure for block to be displayed.  Set by caller, this     */
	/*                  is changed only if user response selects a different block to display in      */
	/*		same info segment; iBlokP then points to iBlok of new block to display before */
	/*		branching to hi.ANOTHER_BLOCK_LABEL. (e.g., find_ep or find responses)        */
	/*   iSectP         points to iSect structure for current section.			        */
	/*   iPgh		points to iPgh  structure for a paragraph of interest.		        */
	/*   iLineP	points to iLine structure for a line of interest.			        */
	/*									        */
	/*  Shared REFERENCE and USURPing of variables permits the complex structures based on these      */
	/*  variables to be declared only once in their respective include files, rather than having to   */
	/*  be declared again in many support subroutines and response routines.		        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

display_block:					
     proc ();

     if  iFileP = null()  then do;			/* Assert: caller's iFileP should not be null().	        */
	call error (hi.sciP, error_table_$noentry, " iFileP null in: ^a^[>^]^a^[$^a^;^s^]^[ info: ^a^;^s^]",
	     Dinfo_item.dir, (Dinfo_item.dir ^= ">"), Dinfo_item.ent, 
	     (Dinfo_item.ep ^= ""), Dinfo_item.ep,
	     (Dinfo_item.info_name ^= ""), Dinfo_item.info_name);
	return;
	end;

     if  iBlokP = null()  then do;			/* Assert: caller's iBlokP should not be null().	        */
	call error (hi.sciP, error_table_$noentry, " iBlokP null in: ^a^[>^]^a^[$^a^;^s^]^[ info: ^a^;^s^]",
	     Dinfo_item.dir, (Dinfo_item.dir ^= ">"), Dinfo_item.ent, 
	     (Dinfo_item.ep ^= ""), Dinfo_item.ep,
	     (Dinfo_item.info_name ^= ""), Dinfo_item.info_name);
	return;
	end;

/* ----------------------------------------------------------------------
    Setup appropriate ssu_ request table.
   ---------------------------------------------------------------------- */

  dcl  TABLE_POSITION_1 fixed bin int static options(constant) init(1);

     hi.info_numbers = 0;				/* Reset progress, display mode/limit, line counts        */
     hi.info_switches = F;

     if  info_seg_util_$is_Subroutine_kind (iBlok.kind)  then do;
	hi.display_mode = DISPLAY_MODE_subroutine;	/* Subroutine block				        */
	call ssu_$add_request_table (hi.sciP, addr(help_request_tables_$for_subroutine_info), 
	     TABLE_POSITION_1, code);
	end;
     else do;					/* Non-subroutine block			        */
	hi.display_mode = DISPLAY_MODE_non_subroutine;
	call ssu_$add_request_table (hi.sciP, addr(help_request_tables_$for_non_subroutine_info), 
	     TABLE_POSITION_1, code);
	end;
     if  code ^= 0  then do;
	call error (hi.sciP, code, 
	     "Unexpected error while setting up ssu_ ^[non-subroutine^;subroutine^;help^] request table",
	     hi.display_mode);
	goto hi.SUBSYSTEM_ABORT_LABEL;
	end;



/* --------------------------------------------------------------------------------
    Step 0:  Before calling ssu_$listen, assure that...

     hi.storage          = null   =>  all storage associated with display of
			        prior block now released from the temp seg.

     hi.selected.iPghP   = null  \
			    =>  "Current paragraph" is at "top" of block
     hi.selected.iSectP  = null  /


     hi.iPgh_print_range = null   =>  No "paragraph print range" has been set.
   -------------------------------------------------------------------------------- */

     hi.info_ptrs = null();				/* Holds hi.storage, hi.selected, hi.iPgh_print_range     */

     hi.iFileP = iFileP;				/* Save caller-supplied pointers to info_seg_ structures  */
     hi.iBlokP = iBlokP;				/*  for this block.				        */

     hi.block_progress = BLOCK_PROGRESS_new_block;	/* Begin processing a new info block.		        */

     hi.info_switches.Sctl = help_args.Sctl;		/*  - Copy caller's control args to help_ storage for     */
						/*    this info seg.			        */
%page;
/* --------------------------------------------------------------------------------
   Check block against help -section and help -search constraints.
    - If block contains no matching section titles and/or paragraphs, it is skipped.  
      But... if another version of file was found in a different search directory, 
      that version is examined instead (in the next call to display_block).
   -------------------------------------------------------------------------------- */

     hi.block_progress = BLOCK_PROGRESS_section_search;	/* Apply -section/-search control args to this block.     */

  dcl  J fixed bin;

     if  hi.display_mode = DISPLAY_MODE_subroutine 	/* For subroutine info_seg having several blocks...       */
      &  iFile.relatives.bloks.firstP ^= iFile.relatives.bloks.lastP 
      &  iBlokP = iFile.relatives.bloks.firstP  then do;	/*  where no $entrypointname was given in pathname...     */
	if  hi.Sctl.scn | hi.Sctl.srh  then do;		/*  then search for a matching :Entry: block.	        */
	     call help_util_$execute (hi.sciP, help_infoP, "find_ep");
	     if  hi.prompt_repeatS  then		/*  - If argument error was reported, do nothing further. */
		goto hi.SUBSYSTEM_ABORT_LABEL;
	     if  ^hi.section_search_matchedS  then	/*  - If no block matches -scn/-srh, ignore subr info seg */
		goto EP_SEARCH_FAILED;
	     end;
	end;
     
     if  hi.Sctl.scn  then do;			/* Look for particular section title in info block.       */
	call help_util_$execute (hi.sciP, help_infoP, "section");
	if  hi.prompt_repeatS  then			/*  - If argument error was reported, do nothing further. */
	     goto hi.SUBSYSTEM_ABORT_LABEL;
	if  hi.section_search_matchedS  then do;	/*  - If found, limit display to matching section.        */
	     hi.display_limit = DISPLAY_LIMIT_section;
	     goto DISPLAY_matched;
	     end;
	end;

     if  hi.Sctl.srh  then do;			/* Search for particular strings in info block.	        */
	call help_util_$execute (hi.sciP, help_infoP, "search");
	if  hi.prompt_repeatS  then			/*  - If argument error was reported, do nothing further. */
	     goto hi.SUBSYSTEM_ABORT_LABEL;
	if  hi.section_search_matchedS  then do;	/*  - If found, limit display to matching pgh plus any    */
	     hi.display_limit = DISPLAY_LIMIT_section;	/*    other paragraphs following it in that section.      */
	     goto DISPLAY_matched;
	     end;
	end;


     if  hi.Sctl.scn | hi.Sctl.srh  then do;		/* All searching failed...			        */
EP_SEARCH_FAILED:					/*  - Ignore this info block silently...	        */
	J = hi.Dinfo_sort_ptrsI;			/*    but if next block has same name, consider it to be  */
						/*    a non-duplicate.  Next call to display_block will   */
	if  J < PDinfo_seg.N  then			/*    search within it for possible match.	        */
	if  PDinfo_seg.P (J+1) -> Dinfo_item.Scross_ref  then
	     PDinfo_seg.P (J+1) -> Dinfo_item.Scross_ref = F;
	return;
	end;

/* --------------------------------------------------------------------------------
    Step 0a:  Before calling ssu_$listen:

     - If -section succeeded: "Current paragraph" is at "top" of section with
			matching section title.
            hi.selected.iSectP    points to matching section (i.e., to that section's iSect structure)
	  hi.selected.iPghP     = null  

            hi.iPgh_print_range   = null (i.e., No "print range" has been set.)

     - If -search succeeded:  "Current paragraph" selects paragraph matched by
			the -search STR.  This could be in same section matched
			by any -section STR (if one was given), or in paragraph
			of a subsequent section.
	  hi.selected.iPghP     points to matching paragraph (i.e., to that paragraph's iPgh structure)
            hi.selected.iSectP    points to section containing matching paragraph

            hi.iPgh_print_range   = null (i.e., No "paragraph print range" has been set.)
   -------------------------------------------------------------------------------- */
%page;
/* --------------------------------------------------------------------------------
   Block has passed all constraints.  
    - Process help control args that display specific info from the block without 
      prompting.  These include:
         -header  -brief  -control_arg  -titles  -lep  -all
   -------------------------------------------------------------------------------- */

DISPLAY_matched:
     hi.block_progress = BLOCK_PROGRESS_needs_header;	/* Block header not displayed as yet.  Do it only once    */
						/*  in the code that follows.  When invoked, the "header" */
						/*  response sets progress to: BLOCK_PROGRESS_display     */

     hi.infos_printedN = hi.infos_printedN + 1;		/* Count info as having been printed.		        */

     if  hi.Sctl.he_only				/* Implement -header help control arg...	        */
      |  Dinfo_item.Scross_ref  then do;		/*   - If only printing a header, do that now and return. */
						/*     Same also if only reporting another version of     */
						/*     info seg was found in a later search directory.    */
	call help_util_$execute (hi.sciP, help_infoP, "header");
	return;
	end;


     if  hi.display_mode = DISPLAY_MODE_subroutine  then	/* For subroutines, prepare to invoke list_entry_points   */
						/*  request.  Side-effect is to replace placeholder       */
						/*  "Entry points in SUBR_REFNAME_:" section with a       */
						/*  help_-generated list of entry points fabricated by    */
						/*  this call.				        */
	call help_responses_$lep_setup (hi.sciP, help_infoP);

     

ALL_PARAGRAPHS:					/* The "all_paragraphs" request branches to this label,   */
						/*  with hi.Sctl.XXX = F, and  hi.Sctl.all = T  AND...    */
						/*   for non_subroutine: hi.iBlokP at current block       */
						/*   for subroutine:     hi.iBlokP at subr intro block    */

     if  hi.Sctl.all  then do;			/* Implement first parts of -all: 		        */
	hi.selected = null();			/*  - Position to "top" of info block (in case -search    */
	hi.iPgh_print_range = null();			/*    or -section repositioned in code above).	        */
	call help_util_$execute (hi.sciP, help_infoP, "header");	
	end;					/*  - Display a header documenting lines in the block.    */
						/*  - Continue processing...			        */
						/*    Show any -bf/-ca/-titles output before block lines. */

     if  hi.Sctl.bf  then				/* Implement -brief: show brief summary of info block.    */
						/*  (If -brief given w/o -all, "brief" request will call  */
						/*   the "header" request if needed.)		        */
	call help_util_$execute (hi.sciP, help_infoP, "brief");

     if  hi.Sctl.ca  then				/* Implement -control_arg: show data about particular     */
						/*    args or control args.			        */
						/*  (If -ca given w/o -all, "control_arg" request calls   */
						/*   the "header" request if needed.)		        */
	call help_util_$execute (hi.sciP, help_infoP, "control_arg");

     if  hi.Sctl.title  then				/* Implement -titles: show section title name/count       */
						/*  (If -titles given w/o -all, "titles" request calls    */
						/*   the "header" request if needed.)		        */
	call help_util_$execute (hi.sciP, help_infoP, "titles -top");
     

     if  hi.Sctl.lep  &  hi.display_mode = DISPLAY_MODE_subroutine  then do;
						/* Implement -lep: show headers for all entrypoints       */
	call help_util_$execute (hi.sciP, help_infoP, "list_entry_points");

						/*  - Normalize hi.selected to get an iSectP.	        */
	if  hi.iSectP = null()  &  hi.iPghP = null()  then
	     iSectP = iBlok.relatives.sects.firstP;	/*     - If "top", select first section of block.	        */
	else if  hi.iSectP = null  &  hi.iPghP ^= null()  then do;
	     iPghP = hi.iPghP;			/*     - If -search found paragraph, select that section  */
	     iSectP = iPgh.relatives.sectP;
	     end;					/*     - Otherwise, don't change "current section"        */

	if  iSect.type = iSect_ENTRY_POINTS_IN  then do;	/*  - We've just displayed "Entry points in ..." list.    */
						/*    If "current paragraph" resides in that section,     */
						/*     move it to the next section or first ep block.     */
	     if  iSect.sib.nextP ^= null()  then do;
		hi.iSectP = iSect.sib.nextP;		/*     - Move to section beyond "Entry points in..."      */
		hi.iPghP  = null();
		end;
	     else if  iBlok.sib.nextP ^= null  then do;
		hi.iBlokP, iBlokP = iBlok.sib.nextP;	/*     - Move to first subroutine :Entry: block.	        */
		hi.selected = null();
		hi.another_blockS = T;
		end;
	     end;
	end;

     if  hi.Sctl.all  then 
DISPLAY_ALL: 
     do;						/* Remainder of -all:			        */
	iBlokP = hi.iBlokP;				/*  - Reset iBlokP to current block being displayed.      */
						/*    This could differ from code above when the	        */
						/*    all_paragraphs request transfers to the	        */
						/*    ALL_PARAGRAPHS label above.		        */

	call newline(1);				/*  - Separate header from 1st section of info block.     */

	do iSectP = iBlok.sects.firstP		/*  - Show info block sections.		        */
	     repeat iSect.sib.nextP while (iSectP ^= null() );
	     call help_util_$print_section (hi.sciP, help_infoP, iSectP);
	     end;

	call newline (1);				/*  - Separate final block section from any content of    */
						/*    of subsequent info blocks.		        */

	if  iBlok.kind = iBlok_kind_SUBROUTINE_INTRO	/* For subroutine intro, -all prints all entrypoints.     */
	 |  iBlok.kind = iBlok_kind_SUBROUTINE_BRIEF_INTRO  then do;
	     do iBlokP = iBlok.sib.nextP
		repeat iBlok.sib.nextP  while (iBlokP ^= null() );
		if  iBlok.kind = iBlok_kind_SUBROUTINE_ENTRY  then do;
		     call newline (help_args.Lspace_between_infos);

		     hi.iBlokP = iBlokP;
		     hi.another_blockS = T;
		     call help_util_$execute (hi.sciP, help_infoP, "header");	

		     do iSectP = iBlok.sects.firstP	/*  - Show info block sections.		        */
			repeat iSect.sib.nextP while (iSectP ^= null() );
			call help_util_$print_section (hi.sciP, help_infoP, iSectP);
			end;
		     end;
		end;
	     end;
	end DISPLAY_ALL;

     if  hi.Sctl.bf  |  hi.Sctl.ca  |  hi.Sctl.all  then	/* If -brief, -ca or -all help control args given, we've  */
	return;					/*   done those steps.  Return now.		        */

%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
/*											        *
   The ssu_$listen LISTENER LOOP supervises printing of help paragraphs, display of "More help?" prompts, and
   processing of user's response to each prompt (the response is an ssu_ request line).  The LOOP consists of 
   four-steps:

	     When entering step 1:
	      If hi.selected.iPghP  ^= null,     it points to the actual "last paragraph printed" iPgh structure.
			         
                But if switching to a new section or paragraph...
	               If hi.iPghP   = null  &
	                  hi.iSectP  = null:     "last paragraph printed" appears to point to a paragraph 
					 before 1st section of block.
	               If hi.iPghP   = null  &
	                  hi.iSectP ^= null:     "last paragraph printed" appears to point to the paragraph 
	                                         before that section.

    Step 1:  Uses "last paragraph printed", hi.display_limit, and count of unseen paragraphs to determine
	   what paragraphs to display next; then tells user what they are...  via a "More help?" prompt.
	   ssu_$listen calls help_listen_util_$display_prompt to perform step 1.



	     When entering step 2 and for all subsequent steps:
	         hi.iPgh_print_range.startP   points to first iPgh to print.
			        .endP     points to last iPgh to print.


	         hi.selected.iPghP   = hi.iPgh_print_range.startP ("current paragraph" is first paragraph to be displayed)
                              .iSectP  = pointer to iSect describing section containing "current paragraph"

	         hi.prompt_repeatS   = T:  Nothing is printed by step 4; step 1 recomputes and displays "More help?" prompt. 

    Step 2:  ssu_$listen reads and processes the user's response to that "More help?" prompt.  
	    - It break's response line into one or more ssu_ requests.  
	    - Invokes each request (which is usually a help_ response routine).
	    - If user types an empty response line,  hi.prompt_repeatS = T  causes prior prompt to be redisplayed.

    Step 3:  Each help_responses_ routine can adjust hi.selected and hi.iPgh_print_range, 
	   or make no adjustments: these values select which paragraphs are to be displayed.

	   A response routine may also change:  
	     hi.display_limit:  can have one of the following four values.
			      DISPLAY_LIMIT_none         => display all paragraphs that fit on the video page.
			      DISPLAY_LIMIT_section	   => display only paragraphs of current section.
			      DISPLAY_LIMIT_unseen	   => display only unseen paragraphs.
			      DISPLAY_LIMIT_rest_unseen  => display all remaining unseen paragraphs.
             To display any paragraphs in step 4, a response routine must set:
	     hi.prompt_repeatS = F    => either the incoming hi.iPgh_print_range is displayed, 
				       or an adjusted hi.selected and/or hi.iPgh_print_range displayed.


	     When entering step 4:
	      If hi.iPgh_print_range  ^= null:  hi.iPgh_print_range.startP and .endP delimit the exact set of 
                                                   paragraphs to display.
				 = null:  if both .startP is null, then...
					 hi.selected values specify a new "current paragraph".  
					 In that case, help_listen_util_$set_iPgh_range is called to map 
					 that "current paragraph" into a new pair of hi.iPgh_print_range 
					 .startP and .endP pointers.  
					   If hi.display_limit = DISPLAY_LIMIT_section, that print range is
					   to paragraphs of the "current paragraph"s section, 
					   limited from that current paragraph onward.

    Step 4:  If hi.prompt_repeatS ^= T, then display paragraphs of the hi.iPgh_print_range
	    - If hi.display_limit >= DISPLAY_LIMIT_unseen, then only unseen paragraphs in print range are displayed.

	   ssu_$listen calls help_listen_util_$print_iPgh_range to perform step 4.  After performing its work,
	   it returns back to ssu_$listen... which iterates again through LOOP.... starting at step 1.


   The code below enters the ssu_ LISTENER LOOP described above by:  
    - performing the part of step 1 that determines WHICH PARAGRAPHS TO PRINT first (w/o displaying a prompt);
    - displaying a HEADER describing the info block, how many lines it contains, and how many lines will be printed first.
    - then calling the step 4 routine directly to PRINT those first PARAGRAPHS OF THE INFO BLOCK; and finally 
    - calling ssu_$listen to start the LOOP at step 1.

/*											        *
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
%page;
/* -----------------------------------------------------------------
   Print header for info block, and first few paragraphs.
   Then enter the ssu_ listener which supervises the 
   help_ prompt/response loop.
   ----------------------------------------------------------------- */

BLOCK_DISPLAY_BEGINS:				/* Begin display of selected info seg block.	        */
     hi.ANOTHER_BLOCK_LABEL = ANOTHER_BLOCK_OF_SAME_INFO_SEG;
						/*  - find_info, find_ep or ep response branches back here*/
						/*    when user asks for different block of info seg.     */
     hi.ALL_PARAGRAPHS_LABEL = ALL_PARAGRAPHS;		/*  - all_paragraphs or all_entrypoints branches back     */
						/*    here to display "all" of current block/subroutine   */

     iBlokP = hi.iBlokP;				/*  - Make sure iBlokP points to possibly just-switched   */
						/*    block.  Block selection can occur:	        */
						/*     above: for help SUBR_ -search STRING	        */
						/*     below: at ANOTHER_BLOCK_OF_SAME_INFO_SEG label     */
						/*            after: "find_ep", "find_info", "ep", or     */
						/*                   "info" responses, or END_OF_INFO     */
						/*                   when walking thru unseen SUBR blocks */
						/*    Since iBlokP isn't referenecd in code below, this   */
						/*    is useful primarily when debugging help_.	        */

     if  hi.infos_printedN > 1  then			/*  - Two blank lines separate one info block from next   */
	call newline (2);

     if  hi.display_limit > DISPLAY_LIMIT_section  then	/*  - Turn off unseen and rest_unseen display limits      */
	hi.display_limit = DISPLAY_LIMIT_none;		/*    each time a new block is processed.	        */

     if  hi.block_progress = BLOCK_PROGRESS_needs_header | hi.another_blockS then do;
						/*  - Need some kind of header displayed for this block.  */
	call help_listen_util_$set_iPgh_range (hi.sciP);	/*     - Set initial paragraph print range.	        */
						/*       This sets hi.header_Nlines_follow for that range.*/
	call help_util_$execute  (hi.sciP, help_infoP, "header");
						/*     - Then display a header for the block.	        */
	end;

     if  ^hi.prompt_repeatS  then			/*  - Print the first range of paragraphs.	        */
	call help_listen_util_$print_iPgh_range (hi.sciP);

     call ssu_$listen (hi.sciP, iox_$user_input, code);	/*  - Let ssu_ listener supervise printing rest of block. */
     if  code = ssu_et_$subsystem_aborted  then
	goto SUBSYSTEM_ABORTED;
     else if  code ^= 0  then
	call error (hi.sciP, code, "calling ssu_$listen as help_ prompt/response routine.");
     return;					/*  - End of displaying this block.		        */
						/*     - Return to help_ caller of display_block().       */

/* -----------------------------------------------------------------
   Branch here with hi.iBlokP set to block to be displayed, and 
   hi.selected = null() (start at "top" of block).  Used by:
    - entry_point (ep), info, and find_ep (find) responses;
    - help_listen_util_$display_prompt goes here if displaying 
      a subroutine intro block, to continue with 
      first entrypoint description for that subroutine.
   ----------------------------------------------------------------- */

ANOTHER_BLOCK_OF_SAME_INFO_SEG:			/* When transferring in from find_XXX response...	        */
     call newline (help_args.Lspace_between_infos);	/*  - Separate prior block's data from data in new block. */
     hi.info_switches.another_blockS = T;		/*  - Display a block-change HEADING line for new block.  */
     hi.clear_prompt_regionS = F;			/*  - Do not clear prompts at point of switching blocks.  */
     goto BLOCK_DISPLAY_BEGINS;

     end display_block;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

evaluate_path:
     procedure (info_path, suffix);

  dcl 1 info_path aligned like help_args.path,
       suffix char (*);

  dcl  i fixed bin;

  dcl  check_star_name_$entry entry (char (*), fixed bin (35)),
       expand_pathname_$add_suffix entry (char (*), char (*), char (*), char (*), fixed bin (35));

     info_path.dir (1) = "";				/* Initialize to unset so caller can depend on these      */
     info_path.ent = "";				/*  values.				        */
     info_path.ep = "";

     info_path.S.less_greater = (search (info_path.value, "<>") > 0);
						/* Was some part of dir given?		        */

     i = index (reverse (info_path.value), "$");		/* Was entrypoint name given?			        */
     if  info_path.S.less_greater  then			/*  - Must allow $ in entry names forming dir part of path*/
     if  search (reverse (info_path.value), "<>") < i  then
	i = 0;
     if  i > 0  then				/*  - Save entrypoint name from user in his path input    */
	info_path.ep = substr (info_path.value, length (info_path.value) - i + 2);
     else info_path.ep = "";


     call expand_pathname_$add_suffix (substr (info_path.value, 1, length (info_path.value) - i), suffix, 
	info_path.dir (1), info_path.ent, info_path.code);
     if  info_path.code ^= 0  then			/* separate pathname into dir/ent parts, add info suffix  */
	return;

     if  info_path.S.pn_ctl_arg  then			/* if -pn given, assume relative pathname follows.        */
	info_path.S.less_greater = T;			/*  (Note we've already expanded path on this assumption.)*/
     

     if  info_path.info_name = ""  then do;		/* info_name usually = entryname w/o suffix.	        */
	info_path.S.separate_info_name = F;
	if suffix = "" then
	     info_path.info_name = info_path.ent;
	else info_path.info_name =
	     substr (info_path.ent, 1, 32 - length (suffix) - index (reverse (info_path.ent), reverse (suffix) || "."));
	end;
     else info_path.S.separate_info_name = T;


     call check_star_name_$entry (info_path.ent, info_path.code);

     if  info_path.code = 0  then do;			/* 0 means no starname given...		        */
	info_path.S.starname_ent = F;			/*   -ep argument allowed when starname not given.        */
	if  help_args.Sctl.ep & info_path.ep = ""  then	/*   Default ep name = entryname w/o suffix.	        */
	     if  suffix = ""  then
	          info_path.ep = info_path.ent;
	     else info_path.ep =
		substr (info_path.ent, 1, 32 - length (suffix) - index (reverse (info_path.ent), reverse (suffix) || "."));
	end;

     else if  info_path.code = 1  |  info_path.code = 2  then do;
	info_path.code = 0;				/* 1 or 2 means starname was given...		        */
	info_path.S.starname_ent = T;
	if help_args.Sctl.ep | (info_path.ep ^= "") then	/*   forbid -ep if starname was given.		        */
	     info_path.code = error_table_$inconsistent;
	end;

     if  info_path.code ^= 0  then			/* Stop evaluation if error detected.		        */
	return;


     if info_path.S.separate_info_name then do;		/* Check star-ness of user-supplied info_name.	        */
	if  info_path.S.info_name_not_starname  then	/*  - Caller asserts that info_name not starname	        */
	     info_path.S.starname_info_name = F;
	else do;
	     call check_star_name_$entry (info_path.info_name, info_path.code);
	     if  info_path.code = 1  |  info_path.code = 2  then do;
		info_path.code = 0;			/*  1 or 2 means info_name is a starname...	        */
		info_path.S.starname_info_name = T;
		end;
	     else info_path.S.starname_info_name = F;
	     end;
	end;
     else info_path.S.starname_info_name = info_path.S.starname_ent;

     end evaluate_path;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

get_info_seg_list:					/* Find info blocks matching info_path		        */
     procedure (suffix, fcn, dirs, info_path, PDinfo_);

						/* 	Input Parameters			        */
  dcl  suffix char (*),				/* help_$init (or caller) provided suffix for info segs.  */
       fcn fixed bin,				/*  = HELP: help_ is our caller.		        */
						/*  = CIS:  help_$check_info_segs is our caller.	        */
       dirs (*) char (168) unaligned,			/* Array of directories in which to look for info segs.   */
						/*  - Could be a specific pathname given by user; or      */
						/*  - Array of info_seg (or other) search paths given in  */
						/*    help_args.search_dirs			        */
      1 info_path aligned like help_args.path,		/* Structure holding one user-provided search request.    */
       PDinfo_ ptr;					/* Points to storage reserved by caller for Dinfo struct. */
						/*  - We declare this as Dinfo_ structure below.	        */

  dcl  I fixed bin (21),
       Nstart fixed bin,
       block_date fixed bin (71),
       code fixed bin (35),
       (i, j, k) fixed bin,
       linfo_name char (32),				/* info name without the suffix.		        */
       sinfo_name char (32),				/* info name with the suffix.			        */
       saved_date fixed bin (71),
       some_block_foundS bit (1) aligned,
       uid bit (36) aligned;

  dcl 1 Dinfo_ aligned based (PDinfo_),			/* Our view of caller's Dinfo structure.	        */
      2 N	fixed bin,
      2 item (0 refer (Dinfo_.N)),
        3 seg like Dinfo_seg;

  dcl  hcs_$star_dir_list_ entry (char (*), char (*), fixed bin (3), ptr, fixed bin, fixed bin, ptr, ptr, fixed bin (35)),
       hcs_$status_long entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));
%page;
     Nstart = Dinfo_.N;				/* Remember count of info segs found earlier, 	        */
						/*   to see if we find matches for current path.	        */

     star_list_names_ptr, star_list_branch_ptr = null ();
     on cleanup call free_dir_list ();			/* Prep to free storage by hcs_$star_dir_list_	        */

ENTRIES_IN_DIRS:
     do i = lbound (dirs, 1) to hbound (dirs, 1);		/* Search for info path in each directory to be searched. */
						/*  May be looking in info_segs search paths.	        */
	star_select_sw = star_ALL_ENTRIES;
	call hcs_$star_dir_list_ (dirs (i), info_path.ent, star_select_sw, addr (hi_area), star_branch_count, star_link_count,
	     star_list_branch_ptr, star_list_names_ptr, code);

	if code = 0 then
STARNAME_PROCESSING:
	do;
WALK_HCS_STAR_ARRAY:
	     do j = 1 to star_branch_count + star_link_count;
						/* Process segs/links found in this directory.	        */
		k, Dinfo_.N = Dinfo_.N + 1;
		Dinfo_.seg (k).Scross_ref = F;
		Dinfo_.seg (k).dir = dirs (i);
		Dinfo_.seg (k).ent = star_list_names (star_dir_list_branch (j).nindex);
		Dinfo_.seg (k).info_name = "";
		Dinfo_.seg (k).ep, Dinfo_.seg (k).E = info_path.ep;
		Dinfo_.seg (k).segment_type = star_dir_list_branch (j).type;

						/* Process by entry type...			        */
		if  star_dir_list_branch (j).type = star_SEGMENT  then do;
						/*  - For an info segment...			        */
		     Dinfo_.seg (k).L = divide (star_dir_list_branch (j).bit_count, BITS_PER_CHAR, 24, 0);
		     Dinfo_.seg (k).date = numeric_date (star_dir_list_branch (j).dtem);
		     Dinfo_.seg (k).mode = substr (star_dir_list_branch (j).mode, 2, 3);
						/*     - extract access "rew" mode bits from "trewa".     */
		     Dinfo_.seg (k).code = 0;		/*     - no errors encountered as yet for this info seg   */

		     if Dinfo_.seg (k).L = 0 then	/*        - Oops, info seg empty?		        */
			Dinfo_.seg (k).code = error_table_$zero_length_seg;

		     else if (star_dir_list_branch (j).bit_count - (BITS_PER_CHAR * Dinfo_.seg (k).L)) > 0 then
						/*        - bits after last whole character?	        */
						/*           [equiv to: mod(Bit_count, BIT_PER_CHAR) > 0] */
			Dinfo_.seg (k).code = error_table_$bad_seg;
		     end;

		else if  star_dir_list_branch (j).type = star_LINK  then 
CHASE_LINK:	do;				/*  - For link: chase link looking for target info seg    */
		     call hcs_$status_long (Dinfo_.seg (k).dir, Dinfo_.seg (k).ent, 1, 
			addr (branch), null (), code);

		     if  (code = 0)  |  (code = error_table_$no_s_permission)  then do;
			if branch.type = Segment then do;
						/*     - Get info equivalent to above directly from branch*/
						/*       NOTE: we may not have "s" access to target dir   */
			     Dinfo_.seg (k).L = divide (binary (branch.bit_count, 24), BITS_PER_CHAR, 24, 0);
			     Dinfo_.seg (k).date = numeric_date (branch.dtem);
			     Dinfo_.seg (k).mode = substr (branch.mode, 2, 3);
			     Dinfo_.seg (k).code = 0;
			     if Dinfo_.seg (k).L = 0 then
				Dinfo_.seg (k).code = error_table_$zero_length_seg;
			     else if (binary (branch.bit_count, 24) - (BITS_PER_CHAR * Dinfo_.seg (k).L)) > 0 then
				Dinfo_.seg (k).code = error_table_$bad_seg;
			     end;

			else if  branch.type = Link  then do;
						/*  - circular link or link chain too long	        */
			     Dinfo_.seg (k).L = 0;
			     Dinfo_.seg (k).date = 0;
			     Dinfo_.seg (k).mode = "0"b;
			     Dinfo_.seg (k).code = error_table_$noentry;
			     end;

			else do;			/*  - Silently skip matching directories.	        */
			     Dinfo_.N = Dinfo_.N - 1;
						/*    Forget everything we've done for this entry */
			     go to SKIP_ENTRY;
			     end;
			end;

		     else do;			/*  - Error: no access to the link target.	        */
			Dinfo_.seg (k).L = 0;
			Dinfo_.seg (k).date = 0;
			Dinfo_.seg (k).mode = "0"b;
			Dinfo_.seg (k).code = code;
			end;
		     end CHASE_LINK;

		else do;				/*  - Silently skip matching directories.	        */
		     Dinfo_.N = Dinfo_.N - 1;
		     go to SKIP_ENTRY;
		     end;

		if  Dinfo_.seg (k).code = 0  then do;	/*  - If no errors found while searching...	        */

		     if (Dinfo_.seg (k).mode & R_ACCESS) then
						/*    - If can read info seg...		        */
			if help_args.min_date_time ^< Dinfo_.seg (k).date then
			     Dinfo_.N = Dinfo_.N - 1; /*       - Skip seg if older than help_args.min_date_time */
		          else ;			/*    - Else continue with this seg.		        */
		     else Dinfo_.seg (k).code = error_table_$moderr;
		     end;				/*  - Error: user has no read access to info seg.	        */

SKIP_ENTRY:	end WALK_HCS_STAR_ARRAY;

	     call free_dir_list ();
	     end STARNAME_PROCESSING;
%page;
	else if  (code = error_table_$incorrect_access | code = error_table_$no_info) & ^info_path.S.starname_ent  then
NON_STARNAME_PROCESSING:
	do;					/* If user does not have "s" permission to dir,	        */
						/*  - look for a specific help seg.		        */
	     call hcs_$status_long (dirs (i), info_path.ent, 1, addr (branch), null (), code);

	     if  (code = error_table_$no_s_permission) | (code = 0)  then do;
		if  branch.type ^= Directory  then do;
		     k, Dinfo_.N = Dinfo_.N + 1;
		     Dinfo_.seg (k).Scross_ref = F;
		     Dinfo_.seg (k).dir = dirs (i);
		     Dinfo_.seg (k).ent = info_path.ent;
		     Dinfo_.seg (k).info_name = "";
		     Dinfo_.seg (k).ep = info_path.ep;
		     Dinfo_.seg (k).E = info_path.ep;
		     Dinfo_.seg (k).segment_type = branch.type;

		     if  branch.type = Segment  then do;
			Dinfo_.seg (k).L = divide (binary (branch.bit_count, 24), BITS_PER_CHAR, 24, 0);
			Dinfo_.seg (k).date = numeric_date (branch.dtem);
			Dinfo_.seg (k).mode = substr (branch.mode, 2, 3);
			if  Dinfo_.seg (k).mode & R_ACCESS  then
			     Dinfo_.seg (k).code = 0;
			else Dinfo_.seg (k).code = error_table_$moderr;

			if  Dinfo_.seg (k).L = 0  then
			     Dinfo_.seg (k).code = error_table_$zero_length_seg;
			else if  binary (branch.bit_count, 24) - BITS_PER_CHAR * Dinfo_.seg (k).L > 0  then
			     Dinfo_.seg (k).code = error_table_$bad_seg;
			else if  code = 0  then
			     if  help_args.min_date_time ^< Dinfo_.seg (k).date  then
			          Dinfo_.N = Dinfo_.N - 1;
			end;
		     else do;			/* Give error for link target being a link.	        */
			Dinfo_.seg (k).L = 0;
			Dinfo_.seg (k).date = 0;
			Dinfo_.seg (k).mode = "0"b;
			Dinfo_.seg (k).code = error_table_$noentry;
			end;
		     end;
		end;
	     else if  code = error_table_$noentry  then;
	     else go to DIR_ERROR;

	     end NON_STARNAME_PROCESSING;

	else if  code = error_table_$nomatch  then;

	else do;					/* hcs_$star_dir_list fatal error looking in this dir.    */
DIR_ERROR:     call error (hi.sciP, code, " Looking for info segments in ^a.", dirs (i));
	     if dim (dirs, 1) = 1 then
		return;				/* Avoid getting nomatch error in addition to	        */
	     end;					/* this one when only 1 dir to look into.	        */

	end ENTRIES_IN_DIRS;
%page;
     do i = Nstart + 1 to Dinfo_.N;			/* Supply uid for all just-found info segs.	        */
	call hcs_$get_uid_file (Dinfo_.seg (i).dir, Dinfo_.seg (i).ent, uid, code);
	if  code ^= 0  &  Dinfo_.seg (i).code = 0  then
	     Dinfo_.seg (i).code = code;
	else if  code = 0  then
	     Dinfo_.seg (i).uid = uid;
	end;

     if  fcn = CIS  then do;				/* For help_$check_info_segs...		        */
	do i = Nstart + 1 to Dinfo_.N;		/*  - in Dinfo_.seg entries just added...	        */
	     if  Dinfo_.seg (i).code ^= 0  then do;	/*    if found an error in any of these...	        */
		Dinfo_.seg (i).uid = "0"b;
		Dinfo_.seg (i).I = 0;		/*     - zero fields so caller cannot try to	        */
		Dinfo_.seg (i).E = "";		/*       further process this problem entry.	        */
		end;
	     end;
	return;					/*  - don't try to look inside info seg for blocks        */
	end;


     if  Dinfo_.N = Nstart  then do;			/* For help_, if no entries found for this path	        */
						/*  - print error message on behalf of caller	        */
         if  info_path.S.starname_ent  then
	    code = error_table_$nomatch;
         else code = error_table_$noentry;
         call error (hi.sciP, code, " ^[-pn ^]^a", info_path.S.pn_ctl_arg, info_path.value);
         return;
         end;
%page;
EXAMINE_INFO_SEG:					/* For help_, w/ no errors encountered for path...        */
						/*  - Look in just-added info segs for :Info:	        */
     do i = Nstart + 1 to Dinfo_.N;			/*    and :[Info]: info block dividers.		        */

						/* NOTE: Dinfo_.N is incremented below, but new items     */
						/*  are NOT processed by this do group.  do-statement     */
						/*  evaluates Dinfo_.N when first entering the do-group.  */
						/*  Subsequent increments to Dinfo_.N add items that are  */
						/*  beyond the original Dinfo_.N limit of this do-group.  */

	if  info_seg_util_$count_files (addr (isd)) > 10  then
REINITIALIZE:  call info_seg_$reinitialize (addr (isd));	/* Avoid having more than 10 info segs initiated.	        */

	iFileP =
	     info_seg_$examine_iFile (addr (isd), Dinfo_.seg (i).dir, Dinfo_.seg (i).ent, Dinfo_.seg (i).uid,
			          Dinfo_.seg (i).code);
						/* Get chain of blocks found in this info seg	        */

	if  iFileP = null ()  &			/* No iFile returned but got other iFiles earlier	        */
	    isd.files.firstP ^= null ()  then
	     go to REINITIALIZE;			/*  - Release storage for prior files so this	        */
						/*    new file can be processed.		        */

	if  Dinfo_.seg (i).code ^= 0  then		/* Report any errors in initiating this new file	        */
	     go to BLOCKS_error;			/*   ASSERT: .code ^= 0  if iFileP = null()	        */

	if  help_args.pad2(6) = 3  then		/* -db 3 given?				        */
	     call ioa ("DEBUG 3: iFile.caseI = ^d,  .structure = ^d", iFile.caseI, iFile.structure);

	if  iFile.structure <= iFile_struc_err_UNSET
	  | iFile.structure >  iFile_structure_INFO  then do;
	     Dinfo_.seg (i).code = error_table_$improper_data_format;
	     go to BLOCKS_error;			/* Info seg has unrecognized/bad block structure	        */
	     end;

	go to INFO_STRUCTURE (iFile.structure);		/* Next steps vary by structure of info segment.          */
	

INFO_STRUCTURE (iFile_structure_INFO_HCOM):		/* Info Segment with blocks...		        */
						/*  - Each block treated as a separate info by help_.     */
	iBlokP = iFile.bloks.lastP;
	if  iBlokP ^= null ()  then			/*     - Unthread history comment block from list.        */
	if  iBlok.divider = iBlok_divider_hcom | iBlok.divider = iBlok_divider_hcom_obsolete  then
	     call info_seg_$unthread_iBlok (iBlokP);

INFO_STRUCTURE (iFile_structure_INFO):			/* Info Segment with blocks but no History Comment...     */
	saved_date = Dinfo_.seg (i).date;		/*  - save info seg dtcm for any block w/o header date.   */
	Dinfo_.seg (i).info_name = info_path.info_name;
						/* save info_name which found this info, for use in any   */
						/*  subsequent error message.			        */

	some_block_foundS = F;			/* 1st matching block's data will go into existing        */
						/*   Dinfo_.seg(i); but no match found yet.	        */
	
CHECK_BLOCKS:
	do iBlokP = iFile.bloks.firstP		/* Check block divider names versus input spec	        */
	     repeat iBlok.sib.nextP while (iBlokP ^= null ());
	     if  iBlok.no_namesS  then		/*  - skip block with no divider names.		        */
		goto NEXT_BLOCK;

	     call convert_date_to_binary_ (iBlok.header.iso_date, block_date, code);
	     if  code ^= 0  then
		block_date = saved_date;
	     if  help_args.min_date_time ^< block_date  then
		go to NEXT_BLOCK;			/*  - skip blocks older than min_date_time	        */

CHECK_BLOCK_NAMES:
	     do j = lbound (Blok_names, 1) to hbound (Blok_names, 1);
		if  info_path.S.starname_info_name  then do;
		     call match_star_name_ ((Blok_names (j)), info_path.info_name, code);
		     if code ^= 0 then
			go to NAME_MISMATCH;
		     end;
		else if Blok_names (j) ^= info_path.info_name then
		     go to NAME_MISMATCH;

		if  ^info_path.S.separate_info_name  then do;
						/* AVOID POTENTIAL BUG:  Lookup of info seg by	        */
						/* uid could subvert test to see if divider name	        */
						/* is really a name on the info seg.  Check if	        */
						/* divider name really exists on info segment.	        */
		     if  iBlok.divider = iBlok_divider_Info_no_ext_names  then
			go to NAME_MISMATCH;	/*  :[Info]: divider name never on phys. info seg	        */

		     if  suffix ^= ""  then		/* Look for this block name as name on phys. info	        */
			sinfo_name = Blok_names (j) || "." || suffix;
		     else sinfo_name = Blok_names (j);
						/* NOTE: If user has no "s" (status) access on containing */
						/*  directory, getting list of external names on seg is   */
						/*  not allowed hcs_$status_long, etc.  But...            */
						/*  hcs_$get_uid_file can look in that dir for a given    */
						/*  info_name; if found file, uid is returned even in     */
						/*  directory to which user has no s permission.	        */
		     call hcs_$get_uid_file (Dinfo_.seg (i).dir, sinfo_name, uid, code);
						/*  - Is block divider name also external name?	        */
						/*    We already know the info seg's uid.	        */
		     if  uid ^= Dinfo_.seg (i).uid  then
			go to NAME_MISMATCH;	/*      - It is not.			        */
		     end;
		go to BLOCK_MATCHES;

NAME_MISMATCH:	end CHECK_BLOCK_NAMES;

	     go to NEXT_BLOCK;			/* None of names on this block match input spec	        */

%page;
BLOCK_MATCHES:
	     if  ^some_block_foundS  then do;		/* k = i: overwrite original Dinfo_(i) element.	        */
						/*        with data specific to matching block.	        */
		k = i;
		some_block_foundS = T;
		end;
	     else	do;				/* Already overwrote Dinfo_(i) element, so create a new   */
						/*  one to hold data specific to 2nd...Nth matching blocks*/
		k, Dinfo_.N = Dinfo_.N + 1;		/*   - This new entry is NOT examined by later	        */
						/*     iterations thru EXAMINE_INFO_SEG do-group.	        */
						/*     See NOTE at that label - above.		        */
		Dinfo_.seg (k) = Dinfo_.seg (i);	/*  - copy data from original Dinfo_.item(i) to	        */
		end;				/*    new Dinfo_.item(k) structure.		        */

	     if ^info_path.S.separate_info_name then
		Dinfo_.seg (k).ent = sinfo_name;	/*  - In case of starname, use this block name as	        */
						/*    name by which phys. info seg was found.	        */
	     Dinfo_.seg (k).date = block_date;		/*  - Use date in block header line as date modified      */
						/*    for this block.			        */

	     Dinfo_.seg (k).I = charno (iBlok.P);	/*  - Save offset of block text w/in info seg so we can   */
						/*    later identify (perhaps recreated) iBlok structure  */
						/*    for this block.			        */
					 	/*     charno gives 0-based offset w/in info of 1st char  */
						/*     of block. (iBlok.P points to :Info: divider token).*/

	     Dinfo_.seg (k).L = length (Blok);		/*  length of block content (including any divider)       */

	     Dinfo_.seg (k).info_name = Blok_names (j);	/* Name by which block was selected in CHECK_BLOCK_NAMES  */
						/*  do-group above.				        */

	     if  ^(info_path.S.starname_info_name | info_path.S.separate_info_name)  then
		go to NEXT_INFO_SEG;		/* If condition true, only one block can match input spec */

NEXT_BLOCK:    end CHECK_BLOCKS;

	if  ^some_block_foundS  then 
NO_BLOCK_MATCHES:
	do;
	     if  info_path.S.starname_info_name  then
		Dinfo_.seg (i).code = error_table_$nomatch;
	     else Dinfo_.seg (i).code = error_table_$noentry;
	     end NO_BLOCK_MATCHES;

	go to NEXT_INFO_SEG;

%page;
INFO_STRUCTURE (iFile_structure_INFO_SUBROUTINE_HCOM):	/* Subroutine Info Seg...			        */
						/*  to be treated in Dinfo_.seg list as a single block;   */
						/*  but info_seg_ treats each :Entry: as a separate block.*/
	iBlokP = iFile.bloks.lastP;
	if  iBlokP ^= null () then			/*   - Unthread history comment block from list	        */
	if  iBlok.divider = iBlok_divider_hcom | iBlok.divider = iBlok_divider_hcom_obsolete  then do;
	     call info_seg_$unthread_iBlok (iBlokP);
	     Dinfo_.seg (k).L = Dinfo_.seg (k).L - length (Blok);
	     end;					/*   - Remove HCom length from length of total info seg   */
						/*     Blok starts at divider, and includes rest of block */

INFO_STRUCTURE (iFile_structure_INFO_SUBROUTINE):		/* Subroutine Info Seg without History Comment...	        */
INFO_STRUCTURE (iFile_structure_SUBROUTINE):
	go to NEXT_INFO_SEG;			/*   - Entire info segment (minus history comment)        */
						/*     is the block to be displayed.		        */


INFO_STRUCTURE (iFile_structure_NO_DIVIDERS):		/* Info Segment without blocks...		        */
	go to NEXT_INFO_SEG;			/*   - Entire info segment is selected for display.       */


BLOCKS_error:
	if  Dinfo_.seg (i).code ^= 0  then do;
	     Dinfo_.seg (i).uid = "0"b;		/* If error occurred during processing, mark	        */
	     Dinfo_.seg (i).I = 0;			/* info to cause error message to be printed.	        */
	     Dinfo_.seg (i).E = "";
	     end;

NEXT_INFO_SEG:
	end EXAMINE_INFO_SEG;
     return;

%page;
free_dir_list:					/* Free storage allocated by hcs_$star_dir_list	        */
	proc ();

	if  star_list_names_ptr ^= null ()  then
	     free star_list_names in (hi_area);
	if  star_list_branch_ptr ^= null ()  then
	     free star_dir_list_branch in (hi_area);

	end free_dir_list;
%page;
%include star_structures;
%page;
%include status_structures;

  dcl 1 branch aligned like status_branch;

     end get_info_seg_list;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
%page;
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */

numeric_date:
  procedure (bit_date) returns (fixed bin (71));
				/* This procedure converts a file system date	*/
				/* to a numeric clock value.  A file system date	*/
				/* is the high-order 36 bits of a 52 bit clock	*/
				/* value.					*/

    dcl bit_date	   bit (36) unal,
        num_date	   fixed bin (71);


    num_date = 0;
    substr (unspec (num_date), 21, 36) = bit_date;
    return (num_date);

  end numeric_date;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* ENTRYPOINT:  help_$init							        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

init:
     entry (procedure_name, search_list_name, search_list_ref_dir, Vrequired, Phelp_args, Acode);

  dcl  search_list_name char (*),			/* Name of search list used in finding infos.     (input) */
       search_list_ref_dir char (*),			/* Referencing dir used in  search rules.         (input) */
       Vrequired fixed bin;				/* Required version of help_args structure.       (input) */

     Phelp_args = null();				/* Initial values for our output arguments.	        */
     Acode = 0;

     if  Vrequired ^= Vhelp_args_3  &  Vrequired ^= 2  &  Vrequired ^= 1 then  do;
	Acode = error_table_$unimplemented_version;	/* Complain if requested version unknown to this code.    */
	return;
	end;

/* -----------------------------------------------------------------
   Create the help_ ssu_ subsystem.
   ----------------------------------------------------------------- */

  dcl  my_sciP ptr;
  dcl  NO_INFO_DIRECTORY char (0) int static options(constant) init("");
  dcl  NO_REQUEST_TABLE ptr int static options(constant) init(null());
  dcl  NULL_INFO_PTR ptr int static options(constant) init(null());

     my_sciP = null();				/* Prepare to cleanup ssu_ invocation if stack unwound    */
     on cleanup call init_janitor (my_sciP, Phelp_args);	/*  before help_$init returns to caller.	        */

     call ssu_$create_invocation (procedure_name, HELP_VERSION_02, NULL_INFO_PTR, NO_REQUEST_TABLE,
	NO_INFO_DIRECTORY, my_sciP, Acode);		/* help_ now runs in its own ssu_ subsystem.	        */
     if  Acode ^= 0  then
	return;

/* -----------------------------------------------------------------
   Get temporary segment (from ssu_) to hold help_args structure
   (and lots of other structures).
   ----------------------------------------------------------------- */

  dcl  HELP_ARGS_COMMENT char (9) int static options(constant) init("help_args");

     call ssu_$get_temp_segment (my_sciP, HELP_ARGS_COMMENT, Phelp_args);
						/* Obtain a temporary segment: storage zeroed because     */
						/*  $get_temp_segment truncates segment to 0-length and   */
						/*  new pages added to segment are all zeros.	        */

/* -----------------------------------------------------------------
   Initialize 1st structure stored in temp segment: help_info (hi)
    - The help_info structure is declared in: _help_shared_data_.incl.pl1
      NOTE: Elements in help_info, their attributes, and overall size
            of help_info structure do not change, no matter how often the
	  help_$help_ entry point is called.
   ----------------------------------------------------------------- */

     help_infoP = Phelp_args;				/* help_info (hi) begins at base of temp seg (Position 1) */

     call ssu_$set_info_ptr (my_sciP, help_infoP);	/* Make addr(help_info) the ssu_ info_ptr passed to each  */
						/*  help_ response program.			        */

     hi.init_ptrs = null();				/* Initialize help_info elements that are not zeroes:     */
     hi.help_ptrs = null();				/*  - .help_numbers, .help_video_data, .help_switches     */
     hi.help_video_data.video_iocbP = null();		/*    are already zeroed by ssu_$get_temp_segment.        */
     hi.info_ptrs = null();
     hi.help_labels = INIT_FAILED;


  dcl  HELP_AREA_IS_STANDARD_AREA ptr int static options(constant) init(null());
  dcl  HELP_AREA_TAG char (19) int static options(constant) init("help_ standard area");

     call ssu_$get_area (my_sciP, HELP_AREA_IS_STANDARD_AREA, HELP_AREA_TAG, hi.areaP);
						/*  - .areaP points to area w/ "standard characteristics" */


     hi.sciP = my_sciP;				/*  - .sciP  points to help_'s ssu_ invocation.	        */


     hi.init_ptrs.next_free_spaceP = help_infoP;		/*  - Free space in temp seg begins at base of segment.   */

     call set_space_used (currentsize (hi) );		/*     - Record length of help_info (hi) structure as     */
						/*       "used space" in the temp segment.	        */
     

     
/* -----------------------------------------------------------------
   Initialize 2nd structure stored in temp segment: info_seg_data (isd)
    - The info_seg_data structure is declared in: info_seg_dcls_.incl.pl1
      It is the structure passed among info_seg_$XXX entrypoints.
   ----------------------------------------------------------------- */

  dcl 1 isd aligned like info_seg_data based (hi.isdP);
     
     hi.isdP = hi.next_free_spaceP;			/* info_seg_data (isd) is next in temp seg   (Position 2) */
     isd.version = info_seg_data_version_01;		/*  - help_ calls info_seg_$initialize w/ this structure. */
     isd.standalone_invocationS = F;
     isd.ptrs = null();
     isd.relatives = null();

     isd.sciP = hi.sciP;				/*  - share help_'s ssu_ subsystem for errors, etc.       */
     isd.std_areaP = hi.areaP;			/*  - share help_'s standard allocation area.	        */

     call set_space_used (currentsize (isd));		/* Record length of info_seg_data (isd) structures as     */
						/*  "used space" in the temp segment.		        */

/* -----------------------------------------------------------------
   Initialize 3rd structure stored in temp segment: help_args
    - The help_args structure is declared in: help_args_.incl.pl1
   ----------------------------------------------------------------- */

     hi.help_argsP, Phelp_args = hi.next_free_spaceP;	/* help_args structure is next in temp seg   (Position 3) */

     help_args.version = Vrequired;			/*    - Initialize other parts of help_args.	        */
     help_args.Sctl = "0"b;
     help_args.Npaths = 0;
     help_args.Ncas = 0;
     help_args.Nsrhs = 0;
     help_args.min_Lpgh = INFO_LINES_PER_PARAGRAPH;
     help_args.max_Lpgh = get_page_length_$switch (null(), code);
						/*    - Show more help output without prompting.	        */
     help_args.Lspace_between_infos = INFO_BLANK_LINES_BEFORE_PARAGRAPH;
     help_args.min_date_time = -1;			/*    - Selection of only infos modified after given time */
						/*      is disabled by default.		        */

     help_args.sci_ptr = null();			/*    - help_ no longer refers to these pointers.  Any    */
     help_args.help_data_ptr = null();			/*      caller-provided ssu_ subsystem is ignored.        */

/* -----------------------------------------------------------------
     - Get list of search paths in which help_ will look for 
       info segments.  
        - cleanup on-unit above releases all allocated storage.  (The
	entire hi_area is released by ssu_$destroy_invocation.)
     - Save list in: help_args.Nsearch_dirs and .search_dirs
   ----------------------------------------------------------------- */

     if  search_list_name ^= ""  then do;		/*    - Initialize info_segment search paths.	        */
	call search_paths_$get (search_list_name, sl_control_default, search_list_ref_dir, null(), addr(hi_area), 
	     sl_info_version_1, sl_info_p, Acode);
	if  Acode = 0  then do;
	     help_args.Nsearch_dirs = sl_info.num_paths;	/*      Copy search paths to: help_args.search_dirs(*)    */
	     if  help_args.Nsearch_dirs > 0  then
		help_args.search_dirs (*) = sl_info.paths (*).pathname;
	     free sl_info in (hi_area);		/*      Free search_ paths_$get allocated storage.        */
	     end;
	else help_args.Nsearch_dirs = 0;		/*     - Failed to find named search paths.	        */
	end;
     else help_args.Nsearch_dirs = 0;			/*     - No search_paths name given?  Disable search paths*/

     call set_space_used (currentsize (help_args));	/* Record length of help_args structure as "used space"   */
						/*  in the temp segment.  But caller will change size of  */
						/*  by adding .path array elements.		        */
						/* help_ recalculates this value each time it is called.  */

/* -----------------------------------------------------------------
   At this point, help_args is fully initialized.  
    - From this point on, our caller is responsible for calling 
      help_$term if stack is unwound; no need to explicitly 
      revert cleanup condition; return statement does that.
   ----------------------------------------------------------------- */

     return;					/* Return to caller of help_$init.		        */

INIT_FAILED:
     call init_janitor (my_sciP, Phelp_args);
     return;
     

init_janitor:
     proc (AsciP, Ahelp_argsP);
     
  dcl (AsciP, Ahelp_argsP) ptr;

     if  AsciP ^= null()  then
	call ssu_$destroy_invocation (AsciP);		/*  - Destroy help_ ssu_ subsystem.		        */
     Ahelp_argsP = null();				/*  - Set caller's Phelp_args pointer to null so caller   */
     						/*    does not try to call help_$term before help_args    */
						/*    has been initialized.			        */
     end init_janitor;


%page;
%include "_help_shared_data_";
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* ENTRYPOINT:  help_$term							        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

term:
     entry (procedure_name, Phelp_args, Acode);

     Acode = 0;					/* Set output parameter (which is never used).            */

     if Phelp_args = null then			/* If pointer to help_args structure still null, then     */
	return;					/*  nothing to terminate.			        */

     help_infoP = ptr (Phelp_args, 0);			/* Access hidden help_info structure at base of temp seg  */

     if  hi.isdP ^= null()  then			/* Terminate any info segments remaining initiated; and   */
	call info_seg_$terminate (addr(isd));		/*  release no-free areas created by info_seg_.	        */


  dcl  needsDestruction bit(1) aligned;

     needsDestruction = (hi.sciP ^= null);		/* Destroy help_ ssu_ subsystem.		        */
     call standalone_cleanup_handler (needsDestruction, hi.sciP);
						/*  This routine is in: ssu_invoker_dcls_.incl.pl1        */

     Phelp_args = null();				/*  NOTE: The above call also releases the temp seg       */
						/*        pointed to by Phelp_args.		        */
     return;				

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
%page;
%include arg_list;
%page;
%include help_args_;
%page;
%include help_cis_args_;
%page;
%include access_mode_values;
%page;
%include sl_info;

%include sl_control_s;
%page;
%include ssu_invoker_dcls_;
%page;
%include ssu_prompt_modes;
%page;
%include system_constants;

  end help_;
