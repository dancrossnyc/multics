
/****^  HISTORY COMMENTS:
  1) change(2020-12-07,GDixon), approve(2021-02-23,MCR10089),
     audit(2021-03-31,Swenson), install(2021-03-31,MR12.6g-0053):
     Initial version of info_seg_verify_iFile_.pl1.
                                                   END HISTORY COMMENTS */

%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* ENTRY:  info_seg_verify_iFile_						        */
	/*									        */
	/* FUNCTION: verifies format of a specified info segment parsed by the info_seg_ subroutine.      */
	/*									        */
	/*									        */
	/* Syntax:								        */
	/*    declare info_seg_verify_iFile_ entry (ptr, ptr);				        */
	/*									        */
	/*    call info_seg_verify_iFile_ (verify_info_dataP, iFileP);			        */
	/*									        */
	/*									        */
	/* Arguments:								        */
	/* verify_info_dataP							        */
	/*    points to the verify_info_data structure (see verify_info_data.incl.pl1).		        */
	/* iFileP									        */
	/*    points to an iFile structure defining the file whose format is to be verified.  That iFile  */
	/*    structure must include all data structures provided by info_seg_$parse_iFile.	        */
	/*									        */
	/* Error Severity:								        */
	/* The second argument to info_seg_error_ and info_seg_error_$name_list is an error severity      */
	/* indicator.  The value given in this argument has the following meaning:		        */
	/*									        */
	/* Severity 5								        */
	/*    structural errors preventing parsing of the info segment into blocks, sections,	        */
	/*    paragraphs, and lines.							        */
	/* Severity 4								        */
	/*    errors that should be corrected before installing the info segment.		        */
	/* Severity 3								        */
	/*    errors in following info segment guidelines, a few of which may qualify as valid	        */
	/*    exceptions.								        */
	/* Severity 2								        */
	/*    even less important errors.						        */
	/* Severity 1								        */
	/*    warnings of expected situations, such as use of an non-typical section title.	        */
	/* Severity 0								        */
	/*    a call to info_seg_error_$name_list may use this value if it needs to print out a list of   */
	/*    names that supplement the information in an earlier error message.		        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

info_seg_verify_iFile_:
     proc(AvidP, AiFileP);
     
  dcl  AvidP ptr,					/* Input argument to info_seg_ routines, pointing to      */
      1 vid aligned like verify_info_data based (AvidP);	/*  the verify_info_data structure.		        */

  dcl  AiFileP ptr;					/* Pointer to iFile for info seg to be verified.	        */


  dcl  command_query_$yes_no entry() options(variable);
  dcl  cv_entry_ entry (char(*), ptr, fixed bin(35)) returns(entry);

  dcl  ioa_ entry() options(variable);

  dcl  info_seg_error_ entry () options(variable);
  dcl  info_seg_error_$name_list entry (ptr, fixed bin, char(*), fixed bin, fixed bin, (*) char(32) var);
  dcl  info_seg_error_$nl_after_error entry options(variable);
  dcl  info_seg_error_$set_error_emitted entry (bit(1) aligned);

  dcl  info_seg_util_$add_names entry (ptr, ptr, (*) char(32) var);
  dcl  info_seg_util_$count_block_lines entry (ptr) returns(fixed bin);
  dcl  info_seg_util_$count_file_blocks entry (ptr, ptr);
  dcl  info_seg_util_$count_file_lines entry (ptr) returns(fixed bin);
  dcl  info_seg_util_$count_section_lines entry (ptr) returns(fixed bin);
  dcl  info_seg_util_$delete_names_brief entry (ptr, ptr, (*) char(32) var);
  dcl  info_seg_util_$is_control_format_block entry (ptr, ptr, fixed bin) returns(bit(1) aligned);
  dcl  info_seg_util_$is_operation_format_block entry (ptr, ptr, fixed bin) returns(bit(1) aligned);
  dcl  info_seg_util_$print_block_lines entry (ptr, 1 aligned, 2 fixed bin aligned, 2 fixed bin aligned);
  dcl  info_seg_util_$print_file_lines entry (ptr, 1 aligned, 2 fixed bin aligned, 2 fixed bin aligned);
  dcl  info_seg_util_$set_names entry (ptr, ptr, (*) char(32) var, (*) char(32) var);

  dcl  info_seg_verify_$section_title entry (fixed bin) returns(char(40) var);

  dcl  requote_string_ entry (char(*)) returns(char(*));

  dcl (error_table_$fatal_error
       ) fixed bin(35) ext static;

						/* INTERNAL CONSTANTS			        */
  dcl (BACKSLASH_QUOTE_COLON
		   char (3) init ("\"":"),		/*  backslash quote-mark colon		        */
       COMMA	   char (1) init (","),		/*  comma					        */
       COMMA_SP	   char (2) init (", "),		/*  comma space				        */
       COMMA_SP_HT	   char (3) init (", 	"),	/*  comma space horizontal-tab		        */
       DOLLAR_SIGN     char (1) init ("$"),		/*  dollar_sign				        */
       IO_MODULE_attach_EP_SUFFIX
       		   char (6) init ("attach"),		/*  as in: IO_MODULE_NAME_$IO_MODULE_NAME_attach	        */
       LETTERS         char(52) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"),
						/*  alphabetic letters - 1st letter in seg reference name */
						/*                     or entrypoint name.	        */
       NO_REF_NAME_    char (1) var init(""),		/*  empty reference name			        */
       SP_HT	   char (2) var init(" 	"),	/*  space horizontal-tab			        */
       SP_SP	   char (2) var init("  ")		/*  space space				        */
       ) int static options(constant);

						/* INTERNAL CONSTANTS declared separately because they    */
						/*  reference other constants declared in the group above.*/
  dcl  LETTERS_DIGITS_UNDERSCORE 
                       char(63) init(LETTERS || "0123456789_") int static options(constant);
						/*  alphanumerics underscore - other letters in a	        */
						/*                     reference_name or entrypoint_name. */
  dcl  LETTERS_DIGITS_UNDERSCORE_DOLLAR 
                       char(64) init(LETTERS_DIGITS_UNDERSCORE || DOLLAR_SIGN) int static options(constant);
						/*  alphanumerics underscore dollar_sign - other letters  */
						/*                     that can appear in a 	        */
						/*		   reference_name$entrypoint_name.    */


  dcl (addr, after, before, bin, dim, hbound, index, lbound, length, max, 
       maxlength, reverse, search, string, substr, verify) builtin;

%page;
%include info_seg_dcls_;
%page;
%include verify_info_data;
%page;
/* -----------------------------------------------------------------
   Address the iFile describing the info segment.  It contains 
   results from info_seg_$parse_iFile.
   ----------------------------------------------------------------- */

     iFileP = AiFileP;


/* -------------------------------------------------------------------------------------
    ADDITIONAL VERIFICATION CHECKS:

    Most info segment errors were detected as part of parsing the info segment.
    These are reported by flags in the iXXX structures returned by info_seg_$parse_iFile.
    Final verification checks are made here; additional flags are set to note final errors.
     (These additional flags are marked with + bullet in their comment in info_seg_data_.incl.pl1.)

  
    SUPPORT VARs:

    As the additional checks are made, checking code sets "support variables" that:
     - act as inputs to subsequent checks, so these checks don't have to repeat code
       done in the earlier checks.
     - support more informative error messages, if the additional check sets an error flag.
       This helps to provide more specific information about the error, rather than just
       reporting that such error was detected.

    These support variables are declared and initialized just before calling the check
    routine that sets or builds them.


    POSSIBLE ADDED TESTING (for future version of this procedure):
     A) Add section title cardinality checks.  At least check:
         - "1 allowed" 
         - "1 required" (if not a block kind id trait)
   ------------------------------------------------------------------------------------- */

  dcl  iBlok_newest_epP ptr init(null());		/* SUPPORT VAR: For a subroutine info seg, get ptr to its */
						/*  most-recently-changed entrypoint block.	        */
						/*  If non-null(), this block's header will be displayed  */
						/*  to aid user in knowing which subr ep has a newer      */
						/*  header date than the intro block.		        */
						/*  - Used in subsequent checks and in error messages.    */

     call check_subr_header_dates();			/* verify subroutine header line date consistency	        */



  dcl  io_module_refname char(29) var init("");		/* SUPPORT VAR: iBlok_kind_IO_MODULE word(1), which is    */
						/*              the I/O module's REF_NAME_	        */

  dcl  subr_intro_refname char(29) var init("");		/* SUPPORT VAR: iBlok_kind_SUBROUTINE_INTRO word(1),      */
						/*              which is the subroutine's REF_NAME_       */
						/*  - Used in subsequent checks and in error messages.    */

     call check_header_line_words();			/* verify words in header line conform to guidelines      */
     
     if  subr_intro_refname ^= ""  then
	call check_subr_intro_sections();		/* verify title/contents of "Entry points in SUBR_REF_"   */



  dcl  iBlok_HCOM_or_nullP ptr init(null());		/* SUPPORT VAR: xxx_HCOM block in known file structures.  */
						/*  - Used when scanning blocks to know when final        */
						/*    documentation-related block has been scanned.  The  */
						/*    Hcom block (if present) is always the final block   */
						/*    in the iFile.bloks list.		        */

  dcl 1 need_names aligned like iName300;		/* SUPPORT VAR: External names which should appear on     */
     need_names.N = 0;				/*              info segment.			        */
						/*  - Used in subsequent checks and in error messages.    */
  dcl  need_File_names (need_names.N) char(32) var based(addr(need_names.nm(1)));
						/*  - Overlay for used portion of need_names array.       */

     iBloksN.version = iBloksN_version_2;		/* Count blocks in file by divider.		        */
     call info_seg_util_$count_file_blocks (addr(iFile), addr(iBloksN));

     call check_block_divider_names();			/* verify that block divider names conform to all rules   */
     
     
  dcl 1 extra_names aligned like iName300;		/* SUPPORT VAR: External names that are: extra 	        */
  dcl 1 missing_names aligned like iName300;		/*                                       missing	        */
     extra_names.N, missing_names.N = 0;
  dcl  namesExtra   (extra_names.N)   char(32) var aligned based(addr(extra_names.nm(1)));
  dcl  namesMissing (missing_names.N) char(32) var aligned based(addr(missing_names.nm(1)));

     call check_file_names();				/* verify seg names conform to all rules	        */

%page;
/* -----------------------------------------------------------------
   DISPLAY FILE DATA: 
    - count and display errors.
    - display of info seg block and section structure.
   ----------------------------------------------------------------- */

  dcl  all_names char(120) var;			/* List of all names on a block, in one character string. */
  dcl  short_name char(73) var;			/* Temporary string used in various ways.	        */
  dcl  display_title char(73) var;			/* Temporary string holding display version of sect title */

  dcl  mode fixed bin,				/* Display mode for verification data:		        */
      (NO_PRINTING         init(0),			/*  0: no display; just total errors found (if any)       */
       NORMAL_OUTPUT       init(1),			/*  1: normal display			        */
       ADD_DIVIDER_STARTER init(2)			/*  2: add a divider starter to end of block lead-in line */
       ) fixed bin int static options(constant);

  dcl  NAME_LIST_INDENT fixed bin int static options(constant) init(11);
  dcl  NAME_WIDTH_UNKNOWN fixed bin int static options(constant) init(0);

  dcl (col1, col2) char(32) var;			/* Name values in rows of 2-column name list.	        */

  dcl (addL,					/* Amount added to length of syntax piece for AF/AR.      */
       case,					/* Case for an ioa_ control switch array.	        */
       foundI,					/* Character index into Syntax.str(I) element.	        */
       nmI,					/* Index through names array.			        */
       sI,					/* Index through Syntax.str array.		        */
       sL,					/* Max length of Syntax.str(*) elements.	        */
       ubound					/* upper-bound of array dimensions on several name arrays */
       ) fixed bin;

/* -----------------------------------------------------------------
   FILE-LEVEL data starts:
    - Report information/errors about the info seg (iFile structure).

      NOTE:  info_seg_error_ calls made below also check the 
	   vid.totalsS switch, suppressing output if it is set.
	   But those calls still do error counting, so must be
	   made even for NO_PRINTING.  However, many of those
	   info_seg_error_ calls are avoided when -brief
	   is given; error counts are incorrect in such cases.
   ----------------------------------------------------------------- */

     if  vid.totalsS  then				/* Initial mode setting is based on totalsS switch.       */
	mode = NO_PRINTING;
     else mode = NORMAL_OUTPUT;

     call info_seg_error_$set_error_emitted (F);		/* Any error messages apply to new file, so do reset.     */

     if  mode > NO_PRINTING  then 			/* Print file location.			        */
	call ioa_ ("^/FILE: ^a>^a", iFile.dir, iFile.ent );    

     if  iFile.structure = iFile_struc_err_UNSET  then	/* iFile.structure should always be set to non-zero value */
	call ssu_$abort_subsystem (vid.isd.sciP, error_table_$fatal_error, "CODING ERROR: iFile.structure was never set.");

     if  iFile.structure < iFile_struc_err_UNSET  then do;	/* Display error information about file structure.        */
	if  iFile.zero_lengthS  then
	     call info_seg_error_ (AvidP, 5, "Info segment is zero-length."  );
	else if  iFile.all_nulS  then
	     call info_seg_error_ (AvidP, 5, "Info segment contains only NUL (\000) characters.");
	else if  iFile.ends_nulS  then
	     call info_seg_error_ (AvidP, 4, "Info segment ends with NUL (\000) characters.");
	else if  iFile.all_white_nulS  then
	     call info_seg_error_ (AvidP, 5, "Info segment contains only SP, HT, NL and NUL characters." );
	else call info_seg_error_ (AvidP, 5, (iFile_structure.display_label(iFile.caseI)) );

	if  iFile.structure = iFile_struc_err_SUBROUTINE_INFO_MIX |
	    iFile.structure = iFile_struc_err_INFO_SUBROUTINE_MIX |
	    iFile.structure = iFile_struc_err_MISSING_1st_INFO    |
	    iFile.structure = iFile_struc_err_STRUCTURE_UNKNOWN   then
	     mode = ADD_DIVIDER_STARTER;		/* Append divider starter (:Entry:, :Info: or :hcom:)     */
						/*  string to block lead-in line to show unsupported      */
	end;					/*  block groupings.			        */

     else if  mode > NO_PRINTING  then do;		/* Display information about known good file structure.   */
	call ioa_ ("^7x structure:  ^va   lines: ^4d",
	      maxlength(iFile_structure.display_label(iFile.caseI)), iFile_structure.display_label(iFile.caseI),
	      info_seg_util_$count_file_lines (addr(iFile)) );
	end;

     if  mode > NO_PRINTING  &  vid.fileS  then do;	/* Debug data about how iFile.structure was determined.   */
	call ioa_ ("^-   spec:  ^2d [^va]    ^[   N: ^2d^;^s^]^[   I: ^2d^;^s^]^[   [I]: ^2d^;^s^]^[   E: ^2d^;^s^]^[   H: ^2d^;^s^]" ||
		 "^76t blocks: ^4d",
	      iFile.caseI, 	maxlength(iFile_structure.spec(iFile.caseI)), iFile_structure.spec(iFile.caseI),
	      iBloksN.None               > 0, iBloksN.None,
	      iBloksN.Info               > 0, iBloksN.Info,
	      iBloksN.Info_no_ext_names  > 0, iBloksN.Info_no_ext_names,
	      iBloksN.Entry		   > 0, iBloksN.Entry,
	      (iBloksN.hcom + 
	       iBloksN.hcom_obsolete)    > 0, iBloksN.hcom + iBloksN.hcom_obsolete,
	      iBloksN.all 
	      );
	end;

     if  mode > NO_PRINTING  then do;			/* If -db file:1,N  or  file name errors, then...	        */
	if  (dim(File_names,1) > 0 )  &		/*  - Print file names.			        */
	    (vid.fileS                |  iFile.names_missing_info_suffixS  |
	    iFile.names_extraS        |  iFile.name_order_warningS         |
	    iFile.names_missingS      )  then do;
	     ubound = max(hbound(File_names,1), hbound(need_File_names,1));
	     if  ubound <= 10  then do;		/*     - For short name list, expand it here.	        */
		call ioa_ ("^- ^32a^[  ^a^;^s^]", " names:", 
		     (iFile.name_order_warningS | vid.fileS),
		       "  recommended name order:");
		do nmI = lbound(File_names,1) to ubound;
		     if  nmI <= hbound(File_names,1)  then
			col1 = File_names(nmI);	/* Avoid subscriptrange conditions.		        */
		     else col1 = "";
		     col2 = "";
		     if  (iFile.name_order_warningS | vid.fileS)  then
			if  nmI <= hbound(need_File_names,1)  then
			     col2 = need_File_names(nmI);
		     call ioa_ ("^-^3x ^32a^2x ^a", col1, col2);
		     end;
		end;
	     else do;				/* For longer name list, print names in separate tables.  */
		call info_seg_error_$name_list( AvidP, 0, "^-  names:",
		     NAME_LIST_INDENT, NAME_WIDTH_UNKNOWN, File_names(*) );
		if  iFile.name_order_warningS  then
		     call info_seg_error_$name_list( AvidP, 0, "^/^-  recommended name order:",
		          NAME_LIST_INDENT, NAME_WIDTH_UNKNOWN, need_File_names(*) );
		end;
	     call info_seg_error_$set_error_emitted (T);	/* Record that output has been emitted so NL precedes     */
	     end;					/*  next output lines.			        */
	end;

FILE_NAMING_ERRORS:					/* Count/report file naming errors.		        */
     if (iFile.names_missing_info_suffixS  |  iFile.names_missingS  |
         iFile.name_order_warningS         |  iFile.names_extraS  )  then
	call info_seg_error_$nl_after_error();		/* Insert NL here to separate errors from name list.      */

     if  iFile.name_order_warningS  then
	call info_seg_error_ (AvidP, 2, "File names do not follow recommended name order (see list above).");
     if  iFile.names_missingS  then
	call info_seg_error_$name_list (AvidP, 4, "Expected names not found on the info segment:",
	     NAME_LIST_INDENT, NAME_WIDTH_UNKNOWN, namesMissing);

     if (iFile.name_order_warningS  |  iFile.names_missingS)  &
         mode > NO_PRINTING  &  vid.naming > VI_NAMING_off  then do;
	call ioa_( "^7x  Correcting the above naming errors...");
	call info_seg_util_$set_names (addr(vid.isd), iFileP, need_File_names, File_names);
						/* Existing File_names are removed; need_File_names added */
	end;					/*  with names in preferred need_File_names order.        */

     if  iFile.names_missing_info_suffixS  then		/* Names not ending in .info are also in namesExtra array */
	call info_seg_error_ (AvidP, 4, "One or more file names do not end with the .^a suffix.", info_seg_suffix);

     if  iFile.names_extraS  then do;
	if  mode > NO_PRINTING  &  vid.naming > VI_NAMING_off  then 
	     call info_seg_util_$delete_names_brief (addr(vid.isd), iFileP, namesExtra);
						/* Because we may not have called $set_names above, must  */
						/*  explicitly delete unexpected names from mid-list.     */
						/*  They may be re-added to end of namelist further below.*/
	if vid.naming = VI_NAMING_off  then		
	     call info_seg_error_$name_list (AvidP, 2, "Unexpected names found on the info segment:",
	          NAME_LIST_INDENT, NAME_WIDTH_UNKNOWN, namesExtra);
	else if vid.naming = VI_NAMING_force  then		
	     call info_seg_error_$name_list (AvidP, 2, "Deleting unexpected names found on the info segment:",
	          NAME_LIST_INDENT, NAME_WIDTH_UNKNOWN, namesExtra);
	end;
%page;
/* -----------------------------------------------------------------
   BLOCK-LEVEL data starts:
    - Report information about the blocks (iBlok structures).
    - Report iBlok.errors.
   ----------------------------------------------------------------- */

     iBlokP = iFile.bloks.firstP;			/* Note: even an info seg with no dividers has one block  */
     if  iBlokP = null()  then			/*  - No blocks found?  It's a very empty info segment.   */
	return;					/*    Nothing further can be printed/counted.	        */

     if  mode > NO_PRINTING  then do;			/* 1 or more dividers were found.  Show titles for        */
	call ioa_ ("^/^4x Line  ^va  ^a",		/*   columns in block lead-in lines.		        */
	     maxlength (iBlok_kind_display_string(iBlok.kind)), "  Kind", "   Block Names" );
	call info_seg_error_$set_error_emitted (F);
	end;

SCAN_BLOCKS:
     do iBlokP = iFile.bloks.firstP
	repeat iBlok.nextP  while (iBlokP ^= null() );

	all_names = "";				/* Gather block names in a single string.	        */
	if  iBlok.kind = iBlok_kind_HISTORY_COMMENT then;
	else if  iBlok.names.N > 0  then do;
	     do nmI = 1 to iBlok.names.N;
		if  search(Blok_names(nmI), BACKSLASH_QUOTE_COLON) > 0  then
		     all_names = all_names || requote_string_ ( (Blok_names(nmI)) ) || "  ";
		else all_names = all_names || Blok_names(nmI) || "  ";
		end;
	     end;
	else if  iBlok.wordN > 0 then do;
	     do nmI = 1 to iBlok.wordN;
		if  length(Blok_words(nmI)) <= 32 then
		     all_names = all_names || Blok_words(nmI) || "  ";
		end;
	     end;
	else if  subr_intro_refname ^= ""  then		/* For subroutine with intro in block w/o :Info: divider  */
	     all_names = subr_intro_refname;		/*  use its reference name as the block name.	        */

	if  mode > NO_PRINTING  then do;		/* Display block lead-in line.		        */
						/*  - Determine case for Operations Format blocks	        */
	     case = 1;				/*     - Block not related to Operations Format	        */
	     if  iBlok.multi_operationsS  &  iBlok.multi_controlsS  then  
		case = 2;				/*     - Block describes overall IO Module with both      */
						/*       List of operations  & List of control operations */
	     else if  iBlok.multi_operationsS  then  
		case = 3;				/*     - Block describes overall command/req/IO Module    */
						/*       with List of Operations section.	        */
	     else if  iBlok.multi_controlsS  then
		case = 4;				/*     - Block describes overall IO Module with 	        */
						/*       List of control operations  section. 	        */
	     else if  iBlok.is_operationS  then
		case = 5;				/*     - Block describes one operation of cmd/req/IO Mod  */
	     else if  iBlok.is_controlS  then
		case = 6;				/*     - Block describes one control order of IO Module   */
	     else if  iBlok.request_summaryS  then
	          case = 7;				/*     - Block is Subsystem_Summary with List of Requests */
	     else if  iBlok.is_requestS  then
		case = 8;				/*     - Block describes one subsystem Request/AR	        */

	     call info_seg_error_$nl_after_error();	/* Separate prior file-related errors from block lead-in  */

	     call ioa_ (				/* Display lead-in line for each block's data.	        */
		    " --- ^4d ^va  ^[^a^;^s^]^75t " ||
		"^[ ^8a^;^s^]" ||
		"^[^; multi-op multi-control^; multi-op^; multi-control^; opDoc^; controlDoc^; reqSummary^; reqDoc^]" ||
		"^[ >ss^]" ||

		"^[^[ fewBlanks^]^[ manyBlanks^]^[ badNames^]^[ longNames^]^[ noNames^]^[ manyNames^]^[ noParagraphs^]" ||
		  "^[ missingHeader^]^[ bigHeader^]^[ longHeader^]^[ noDate^]^[ badDate^]^[ nonISOdate^]^[ oldDate^]" ||
		  "^[ badHeader^]^[ epNotFound^]^[ bad:[Info]:^]^[ hcom_obs^]" ||
		  "^[ wrongDividerNames^]^[orderDividerNames^]" ||
		  "^[ badSectOrder^]^[ noSyntax^]^[ manySyntax^]^[^[ ellipsisArgs^; noArgs^]^;^s^]" ||
		  "^[ noCtlArgs^]^[ missingArgumentOpNames^]^[ badHeaderWord1^]^[ badHeaderWord2^]^;^24s^]",

		iBlok.line_in_file,
		 maxlength (iBlok_kind_display_string(iBlok.kind)), iBlok_kind_display_string(iBlok.kind),
		 length(all_names) < 30, all_names,
		(mode = ADD_DIVIDER_STARTER), iBlok_token(iBlok.divider),
		case,
		iBlok.has_subsystem_pathS,

		(vid.briefS),			/*  - display abbreviated Block Error Keywords	        */
		 iBlok.few_blank_lines_before_blockS, iBlok.many_blank_lines_before_blockS,
		 iBlok.bad_namesS, iBlok.long_namesS, iBlok.no_namesS, iBlok.many_namesS, iBlok.no_paragraphsS,
		 iBlok.missing_headerS, iBlok.big_headerS, iBlok.long_headerS, 
		  iBlok.missing_dateS, iBlok.bad_dateS, iBlok.non_iso_dateS, iBlok.older_subr_intro_dateS,
		 (iBlok.bad_subr_intro_headerS | iBlok.bad_subr_headerS | iBlok.bad_cmd_af_req_headerS | 
		  iBlok.bad_request_headerS),    iBlok.bad_subr_epS, iBlok.bad_dividerS, iBlok.obsolete_dividerS,
		 iBlok.bad_divider_namesS, iBlok.order_divider_namesS, iBlok.bad_section_orderS, 
		  iBlok.no_Syntax_sectionS, iBlok.many_Syntax_sectionsS, 
		 iBlok.needs_ArgumentsS, 
		    iBlok.syntax.has_ellipsisS, 
		 iBlok.needs_Control_argumentsS, iBlok.multi_op_Arguments_missing_op_namesS,
                       iBlok.multi_op_header_bad_cmdReqIOmod_nameS,
		  (iBlok.multi_op_header_bad_op_nameS | iBlok.multi_op_name_not_listedS)
		);

	     if  length(all_names) >= 30  then		/* Block names too long to fit in lead-in line?	        */
						/*  - display them on a separate line.		        */
		call ioa_ ("^vt ^a", max(1,74-length(all_names)), all_names);

	     all_names = "";
	     if  vid.blockS  then do;			/* -debug block				        */
		do nmI = 1 to iBlok.header.wordN;	/*   - Gather words in block header as a single string.   */
		     if  all_names ^= ""  then
			all_names = all_names || ", ";
		     all_names = all_names || Blok_words(nmI);
		     end;
		if  all_names ^= ""  then
		     all_names = "(" || all_names || ")";
		end;
	     if  vid.blockS  &  string(iBlok.syntax) ^= "0"b  then do;
						/*   - Display info learned from block Syntax... section  */
		call ioa_ ("^- syntax: ^[ function^]^[ command/request^]^[ AF/AR^]" || 
			            "^[ arguments^]^[ control_args^]^[ ellipsis^]",
		     iBlok.is_function_procedureS, iBlok.is_command_requestS, iBlok.is_activeFunction_activeRequestS,
		     iBlok.has_argumentsS, iBlok.has_control_argsS, iBlok.has_ellipsisS);
		end;

	     if  (iBlok.divider > iBlok_divider_None)  then do;
						/* Display block divider if diagnosed w/ errors.	        */
		if      (iBlok.bad_namesS  |  iBlok.long_namesS  |  iBlok.many_namesS)  then do;
		     iLineP = iBlok.lines.firstP;	/*   - For divider with name problems, show 1st blok line */
		     call ioa_ ("^9x divider:  ^a:", reverse(after(reverse(Line), COLON)));
		     end;
		else if  iBlok.names.N = 0  &  (iBlok.bad_dividerS  |  iBlok.no_namesS  |  iBlok.obsolete_dividerS)
		then
		     call ioa_ ("^9x divider:  ^a", iBlok_token(iBlok.divider));
		else if  iBlok.names.N > 0  &  
		        (iBlok.order_divider_namesS  |  iBlok.bad_divider_namesS  |  iBlok.bad_dividerS  |
		         iBlok.obsolete_dividerS)
		then  				/*   - rebuild divider			        */
		     call ioa_ ("^9x divider:  ^a^( ^a:^)", iBlok_token(iBlok.divider), Blok_names(*) );
		end;

	     if  iBlok.header.str ^= "" &
	        (vid.blockS                          | iBlokP = iBlok_newest_epP       |
	         iBlok.big_headerS		     | iBlok.missing_headerS           | iBlok.long_headerS        | 
	         iBlok.missing_dateS		     | iBlok.bad_dateS	         |
	         iBlok.non_iso_dateS		     | iBlok.older_subr_intro_dateS    | 
	         iBlok.bad_subr_intro_headerS	     | iBlok.bad_subr_headerS          | iBlok.bad_subr_epS        |
	         iBlok.bad_cmd_af_req_headerS	     | iBlok.bad_request_headerS       |
	         iBlok.bad_divider_namesS	     | iBlok.order_divider_namesS      | 
	         iBlok.multi_op_header_bad_op_nameS  | iBlok.multi_op_name_not_listedS |
	         iBlok.multi_op_header_bad_cmdReqIOmod_nameS
	         )
	     then do;				/* Display block header if errors, or -debug block        */
		call ioa_ ("^10x header:  ^a  ^a", iBlok.header.str, all_names);
		if ^(index(iBlok.header.str, iBlok.header.reformatted.iso_date) = 1  &
		     index(reverse(iBlok.header.str), reverse(rtrim(iBlok.header.reformatted.rest)))  = 1)  then
		     call ioa_ ("^7x recommend:  ^a", string(iBlok.header.reformatted) );
		call info_seg_error_$set_error_emitted (T);
		end;
	     end;

	if  ^vid.briefS  then			/* -long: Report full errors noted in iBlok structure.    */
BLOCK_ERROR_MESSAGES:
	do;
	     if  iBlok.many_blank_lines_before_blockS &
	         iBlokP = iFile.bloks.firstP  then
		call info_seg_error_ (AvidP, 3, "Please remove blank lines from start of info segment.");
	     else if  iBlok.few_blank_lines_before_blockS  |  iBlok.many_blank_lines_before_blockS  then
		call info_seg_error_ (AvidP, 3, "^[More^;Fewer^] than ^d blank lines precede block.", 
		     iBlok.many_blank_lines_before_blockS, INFO_BLANK_LINES_BEFORE_PARAGRAPH);

	     if  iBlok.bad_namesS   then  call info_seg_error_ (AvidP, 4, "Block has one or more invalid names.");
	     if  iBlok.long_namesS  then 
		call info_seg_error_ (AvidP, 4, 
		     "Block has names longer than ^d characters." ||
		 "^[^/^2- Help limits subroutine entrypoint names to ^d characters.^;^s^]",
		     maxlength(iBlok.names.nm(1)),
		     iBlok.kind = iBlok_kind_SUBROUTINE_ENTRY, INFO_CHARS_PER_SUBROUTINE_ENTRYPOINT_NAME);
	     if  iBlok.no_namesS       then  call info_seg_error_ (AvidP, 4, "Block has no names.");
	     if  iBlok.many_namesS     then  call info_seg_error_ (AvidP, 4, "Block has more than ^d names.", iBlok.names.N);

	     if  iBlok.missing_headerS  then
		call info_seg_error_ (AvidP, 4, "Header words missing.", 
		     INFO_LINES_PER_HEADER);
	     if  iBlok.big_headerS  then 
		call info_seg_error_ (AvidP, 4, "Header formed from more than ^d lines.", 
		     INFO_LINES_PER_HEADER);
	     if  iBlok.long_headerS  then 
		call info_seg_error_ (AvidP, 3, "Header longer than ^d characters.", 
		     INFO_CHARS_PER_HEADER);
	     if  iBlok.missing_dateS  then  
		call info_seg_error_ (AvidP, 4, "Header has no date string.");
	     if  iBlok.bad_dateS  then  
		call info_seg_error_ (AvidP, 4, "Header date has bad format.");
	     if  iBlok.non_iso_dateS  then  
		call info_seg_error_ (AvidP, 4, "Use an iso_date in the header.");

	     if  iBlok.older_subr_intro_dateS  then
		call info_seg_error_ (AvidP, 4, "Subroutine intro header date < newest entrypoint header date.");
	     if  iBlok.bad_subr_intro_headerS  then
		call info_seg_error_ (AvidP, 3, 
		     "Subroutine intro header words should each be a reference_name" ||
		     "^/^2- (begin with a letter, followed by letter/digit/underscore characters); and if more" ||
		     "^/^2- than one reference_name is given, then names appear in a comma-separated list of" || 
		     "^/^2- words ordered by descending lengths.");
	     if  iBlok.bad_subr_epS  &  dim(Blok_words,1) > 0  then
		call info_seg_error_ (AvidP, 1,
		     "Warning: ^[Some entrypoints were^s^;The entrypoint ^a was^] not found by cv_entry_.",
		     dim(Blok_words,1) > 1, Blok_words(1));
	     if  iBlok.bad_subr_headerS  then
		call info_seg_error_ (AvidP, 4, 
		     "Subroutine entrypoint header words must each begin with ""^a"" then" ||
		     "^/^2- an optional $entrypoint_name; and if more than one name is given, then" ||
		     "^/^2- names appear in a comma-separated list of words.", subr_intro_refname);

	     if  iBlok.bad_cmd_af_req_headerS  then
		call info_seg_error_ (AvidP, 3, 
		     "^[Command/active function^;Request/active request^] header words should each be a reference_name" ||
		     "^/^2- (begin with a letter, followed by letter/digit/underscore characters) and" ||
		     "^/^2- appear in a comma-separated list of words ordered by descending lengths.",
		     (iBlok.kind = iBlok_kind_COMMAND_AF | iBlok.kind = iBlok_kind_COMMAND | 
		      iBlok.kind = iBlok_kind_ACTIVE_FUNCTION)
		     );
	     if  iBlok.bad_request_headerS  then do;
		if  iBlok.syntax.is_requestS  then
		if  info_seg_util_$is_operation_format_block( iBlokP, Operation_ListP, Operation_ListI)  then do;
		    call info_seg_error_ (AvidP, 4,
		         "Header request names should match ""List of requests"" section" || 
		       "^/^2- in the summary.topic block." ||
		       "^/^7x recommend:  ^v(^a, ^)^a",
		         dim(operation_names,1)-1, operation_names(*) );
		    end;
		end;

	     if  iBlok.bad_dividerS  then do;		/* Improper use of :[Info]: divider		        */
		if       iBlok.syntax.has_subsystem_pathS  then
		     call info_seg_error_ (AvidP, 4,
		          "Subsystem uses ssu_-supplied help request; use an :Info: block divider" ||
			"^/^2- to place divider names as external names on info segment.");
		else if  is_Command_IO_GENERAL_kind(iBlok.kind)  then
		     call info_seg_error_ (AvidP, 4,
		          "^a info block must use :Info: block divider to indicate that" ||
			"^/^2- divider names should appear as external names on info segment.",
			iBlok_kind_display_string(iBlok.kind) );
		end;
	     if  iBlok.obsolete_dividerS  then do;	/* Use of :Internal: divider			        */
		call info_seg_error_ (AvidP, 4,
		     "^a must use :hcom: block divider with no divider names, date, or heading." ||
		     "^/^7x recommend:  :hcom:", iBlok_kind_display_string(iBlok.kind) );
		end;

	     if  iBlok.bad_divider_namesS  |  iBlok.order_divider_namesS  then do;
		if  iBlok.kind = iBlok_kind_GENERAL_INFO  then do;
						/* Hcom looks like a GENERAL_INFO block if	        */
						/*   :Info: history_comment.gi		        */
		     call info_seg_error_ (AvidP, 4,	/* is used, instead of :hcom:			        */
		          "History comment divider and header should be: " || 
			"^/^2- ^a", iBlok_token(iBlok_divider_hcom));
		     end;
		else if  iBlok.kind = iBlok_kind_SUBROUTINE_INTRO |
		         iBlok.kind = iBlok_kind_SUBROUTINE_BRIEF_INTRO  then
		     call info_seg_error_ (AvidP, 4, 
		          "Subroutine intro divider should be:" || 
			"^/^2- ^a ^(^a: ^)  ISO_DATE ...", iBlok_token(iBlok.divider), Blok_words(*) );
		else if  iBlok.kind = iBlok_kind_SUBROUTINE_ENTRY  then do;
		     call get_entrypoint_names(Blok_words, subr_intro_refname);
		     if  ^iBlok.long_namesS  then
			call info_seg_error_ (AvidP, 4, 
			     "Subroutine entrypoint divider should be:" || 
			   "^/^2- ^a ^v(^a: ^)  ISO_DATE ..." || 
			 "^[^/^2-   (names in that order)^]", 
			iBlok_token(iBlok.divider), dim(entrypoint_names,1), entrypoint_names(*), 
			dim(entrypoint_names,1) > 1 );
		     end;
		else if  is_Command_Request_IO_kind( iBlok.kind )  then do;
		     if  iBlok.syntax.is_operationS  then
		     if  info_seg_util_$is_operation_format_block( iBlokP, Operation_ListP, Operation_ListI)  then do;
CONTROL_FORMAT_DIVIDER_NAMES_BAD:
			NamesP = names_for_current_operation();
			call info_seg_error_ (AvidP, 3, 
			     "Block divider should be:" || 
			     "^/^2- ^a ^v(^a: ^)  ISO_DATE ..." || 
			     "^[^/^2-   (names in that order)^]", 
			     iBlok_token(iBlok.divider), dim(Names.nm,1), Names.nm(*), 
			     dim(Names.nm,1) > 1 );
			goto DIVIDER_NAMES_BAD_DONE;
			end;
		     if  iBlok.syntax.is_controlS  then
		     if  info_seg_util_$is_control_format_block( iBlokP, Operation_ListP, Operation_ListI)  then 
			goto CONTROL_FORMAT_DIVIDER_NAMES_BAD;

		     call info_seg_error_ (AvidP, 3, 
		          "Block divider should be:" || 
			"^/^2- ^a ^v(^a: ^)  ISO_DATE ..." || 
			"^[^/^2-   (names in that order)^]", 
			iBlok_token(iBlok.divider), dim(Blok_words,1), Blok_words(*), 
			dim(Blok_words,1) > 1 );
		     end;
DIVIDER_NAMES_BAD_DONE:
		end;

	     if  iBlok.no_paragraphsS  then do;
		if  iBlok.kind = iBlok_kind_HISTORY_COMMENT  then;
		else call info_seg_error_ (AvidP, 4, "Block has no paragraphs.");
		end;
	     if  iBlok.no_Syntax_sectionS  then
		call info_seg_error_ (AvidP, 3, "Block has no Syntax section.");
	     if  iBlok.many_Syntax_sectionsS  then
		call info_seg_error_ (AvidP, 3, "Block has more than ^[2 Syntax sections^;1 Syntax section^].",
		     (iBlok.syntax.is_command_requestS & iBlok.syntax.is_activeFunction_activeRequestS) );
	     if  iBlok.needs_ArgumentsS  then
		call info_seg_error_ (AvidP, 3, "Block^[ syntax uses ellipsis (...), so^] needs an ""Arguments"" section.",
		     iBlok.syntax.has_ellipsisS);
	     if  iBlok.needs_Control_argumentsS  then
		call info_seg_error_ (AvidP, 3, "Block needs a ""Control arguments"" section.");


	     if  iBlok.syntax.is_operationS  then	/* - Block describes one op of a multi-op command/req?    */
		if  info_seg_util_$is_operation_format_block( iBlokP, Operation_ListP, Operation_ListI)  then;
						/*    - Access Operation_List's operation_names array.    */
	          else;
	     else if  iBlok.syntax.is_controlS  then	/* - Block describes one control of a multi-control IO Mod*/
		if  info_seg_util_$is_control_format_block( iBlokP, Operation_ListP, Operation_ListI)  then;
						/*    - Access control order's  operation_names array.    */

	     if  iBlok.multi_op_Arguments_missing_op_namesS  then
		call info_seg_error_ (AvidP, 4, 
		     "^[""Arguments for io_call""^;Arguments^] section should list all names for" ||
		     "^/^2- this operation: ^v(^a, ^)^a", 
		     iBlok.syntax.is_controlS  | 
		      (iBlok.syntax.is_operationS  &  iBlok.kind = iBlok_kind_IO_OPERATION),
		     dim(operation_names,1)-1, operation_names(*) );

	     if  iBlok.multi_op_header_bad_cmdReqIOmod_nameS  then do;
		case = 2;				/*    - Assume this info seg describes a command/AF.      */
		if  Operation_List.parentSectP->iSect.relatives.blokP->iBlok.kind = iBlok_kind_IO_MODULE   then
		     case = 1;			/*    - It's really an IO Module		        */
		else if  is_Request_kind( Operation_List.parentSectP->iSect.relatives.blokP->iBlok.kind )  then
		     case = 3;			/*    - It's really a request/AR		        */
		call info_seg_error_ (AvidP, 4, 
		     "Block header 1st word should be ^[IO_MODULE^;SHORT_COMMAND^;SHORT_REQUEST^]_NAME: ^a",
		     case, Operation_List.blok_name);
		end;
	     if  iBlok.multi_op_header_bad_op_nameS  then
		call info_seg_error_ (AvidP, 4, 
		     "Block header 2nd word should be FIRST_^[CONTROL_ORDER^;OPERATION^]_NAME: ^a",
		     iBlok.syntax.is_controlS, operation_names(1));

	     if  iBlok.multi_op_name_not_listedS  then
		call info_seg_error_ (AvidP, 4, 
		     "The ^[control order^;operation^] in block header 2nd word ""^a"" was not found" ||
		     "^/^2- in ""List of ^[control ^]operations"" section of ""^a"" block", 
		     iBlok.syntax.is_controlS, Blok_words(2), iBlok.syntax.is_controlS, Blok_words(1) );

	     end BLOCK_ERROR_MESSAGES;

	/* NOTE:  This error message is also a label for the section sequence numbers, and should therefore come    */
	/*        right before 1st section title is displayed by loop below.  The arrow in message points to list   */
	/*        of section sequence numbers that appear at end of each section title line for bad_section_orderS  */
	/*	blocks.									        */
	if  iBlok.bad_section_orderS  then 
	     call info_seg_error_ (AvidP, 2, "Recommend sections be re-ordered in ascending sequence--v");


/* -----------------------------------------------------------------
   SECTION-LEVEL data starts:
    - Display section titles within block:
       - each title followed by any section-related iSect.errors.
       - report errors for any paragraphs in each section.
   ----------------------------------------------------------------- */

	if  iBlok.kind = iBlok_kind_HISTORY_COMMENT  then /* History Comments have no sections, paragraphs, etc.    */
	     goto FEW_ERRORS_FOR_HISTORY_COMMENT;	/*  - Display only 1 error for History Comment blocks.    */

SCAN_SECTIONS_OF_BLOCK:
	do iSectP = iBlok.sects.firstP
	     repeat iSect.nextP  while (iSectP ^= null() );

	     SyntaxP = addr(iSect.syntax);		/*  - Check for use of shortest command/request name in   */
						/*    Syntax... section.			        */
	     if  Syntax.N > 0  &  iBlok.wordN > 1  &	/*     - IO_CONTROL block Syntax sections are not scanned */
	        (iBlok.syntax.is_operationS  |  ^iSect.syntax_missing_namesS)
	     then do;
		if  iBlok.syntax.is_operationS  then do;
		     iSect.syntax_missing_namesS = F;	/*  - For multi-op operation doc, use only following test */
		     short_name = Operation_List.blok_name || SP || find_shortest_word(operation_names);
		     end;
		else short_name = find_shortest_word(Blok_words);
		do sI = lbound(Syntax.str, 1) to hbound(Syntax.str, 1);
		     foundI = index(Syntax.str(sI), short_name);
		     if  foundI > 0  then do;
			if  foundI + length(short_name) > length(Syntax.str(sI))  then
			     goto FOUND_SHORT_NAME;
			else if  substr(Syntax.str(sI), foundI+length(short_name), 1) = SP  then
			     goto FOUND_SHORT_NAME;
			end;
		     end;
		iSect.syntax_missing_short_nameS = T;
FOUND_SHORT_NAME:	end;

	     if  iSect.untitledS  then		/* Select section title to display below.	        */
		display_title = " <untitled>";	/*  - Section has no title.			        */
	     else display_title = iSect.title.in_file;	/*  - Section title used in display.		        */

	     if  iBlok.syntax.is_controlS  &  iSect.type = iSect_CONTROL_ORDER  then do;
		iLineP = iSect.relatives.lines.firstP;	/*  - Section is a Control order		        */
		display_title = ltrim(rtrim(Line));	/*     Use:  Control order:  LONG_NAME, SHORT_NAME        */
		end;

	     if  mode > NO_PRINTING  then
	       call ioa_( "^4x ^4d   ^a" ||
		        "^75t^[ ^3d^;^s^]" || 

		      "^[^[ badTitle^]^[ blankTitle^]^[ longTitle^]^[ nonStandard^]^[ SyntaxTitleWrong^]" || 
		        "^[ badSubrSyntax^]^[ missing[^]^[ missing]^]"   || 
		        "^[ missingNames^]^[ noShortName^]"     ||
		        "^[ -ctl_arguments^]^[ -ctl_argument^]" ||
		        "^[ badItemNames^]^[ longItemNames^]^[ nonUniqueItems^]" ||
		        "^[ opNoDoc^]" ||
		        "^[ badOrderList^]^[ badOrderNames^]^[ badEntryPointsIn^]^;^17s^]",
		iSect.line_in_file,	display_title,	/*  - Section title lead-in line.		        */
		(iBlok.bad_section_orderS  &  iSect.sequence > 0),
		 iSect.sequence,

		(vid.briefS),			/* -brief: display abbreviated section error keys	        */
		 iSect.bad_titleS, iSect.blank_titleS, iSect.long_titleS, iSect.unrecognized_titleS, 
		  iSect.syntax_title_wrong_for_kindS,
		 iSect.syntax_for_subroutine_invalidS, iSect.syntax_missing_left_bracketS, 
		  iSect.syntax_missing_right_bracketS,
		 iSect.syntax_missing_namesS, iSect.syntax_missing_short_nameS, 
		 iSect.syntax_uses_control_argumentsS, iSect.syntax_uses_control_argumentS,
		 iSect.list_of_ops_bad_namesS, iSect.list_of_ops_long_nameS, iSect.list_of_ops_nonunique_namesS,
		 iSect.list_of_ops_op_not_documentedS,
		 iSect.control_order_bad_listS, iSect.control_order_bad_name_orderS, iSect.bad_entry_points_inS );

	     if  (addr(iSect.syntax)->Syntax.N > 0)  &  
                     (vid.sectionS                        |
	           (iBlok.many_Syntax_sectionsS          | iBlok.needs_ArgumentsS               |
		  iBlok.needs_Control_argumentsS       | iSect.syntax_missing_left_bracketS   | 
		  iSect.syntax_for_subroutine_invalidS | iSect.syntax_missing_right_bracketS  | 
	            iSect.syntax_missing_namesS          | iSect.syntax_missing_short_nameS     | 
		  iSect.syntax_uses_control_argumentsS | iSect.syntax_uses_control_argumentS) )
	     then do;				/* -debug section, or errors diagnosed in Syntax...       */
		call ioa_ ("^-  syntax items:");
		addL, sL = 0;
		if  iSect.type = iSect_SYNTAX_AS_AN_ACTIVE_FUNCTION  |
		    iSect.type = iSect_SYNTAX_AS_AN_ACTIVE_REQUEST  then
		     addL = length("[  ]");
		SyntaxP = addr(iSect.syntax);
		do sI = 1 to Syntax.N;
		     sL = max(sL, length(Syntax.str(sI))+addL );
		     end;

		do sI = 1 to Syntax.N;		/* If Syntax.N > 1, cannot tell which Syntax(i) is        */
						/*  missing brackets.			        */
		     call ioa_ ("^-   | ^[[ ^]^va^[ ]^] |", 
			addL>0 & ^iSect.syntax_missing_left_bracketS, sL-addL, Syntax.str(sI), 
			addL>0 & ^iSect.syntax_missing_right_bracketS );
		     end;
		end;

	     if  vid.listS                           |	/* Display "List of operations" or "Arguments" or	        */
	         (iSect.display_listS                |	/*  "List of control operations" or		        */
		iSect.list_of_ops_bad_namesS       |	/*  "Control arguments" or "List of..." item names.       */
		iSect.list_of_ops_long_nameS       |
		iSect.list_of_ops_nonunique_namesS |
	          iSect.list_of_ops_op_not_documentedS)
	     then do;				/* -db list, or errors found in section		        */
		if  iBlok.syntax.multi_operationsS  &	
		    iSect.type = iSect_LIST_OF_OPERATIONS  &
		    iBlok.relatives.multi_operation_listP ^= null()  then do;
		     Operation_ListP = iBlok.relatives.multi_operation_listP;
DISPLAY_OPERATION_FORMAT_LIST:
		     do Operation_ListI = lbound(Operation_List.items,1) to hbound(Operation_List.items,1);
			call ioa_ ("^-    ^v(^a, ^)^a", dim(operation_names,1)-1, operation_names(*) );
			end;
		     end;
		else if  iBlok.syntax.multi_controlsS  &	
		    iSect.type = iSect_LIST_OF_CONTROL_OPERATIONS  &
		    iBlok.relatives.multi_control_listP ^= null()  then do;
		     Operation_ListP = iBlok.relatives.multi_control_listP;
		     goto DISPLAY_OPERATION_FORMAT_LIST;
		     end;
		else if  iBlok.syntax.request_summaryS  then do;
		     Operation_ListP = iBlok.relatives.multi_operation_listP;
		     goto DISPLAY_OPERATION_FORMAT_LIST;
		     end;
		else if  iSect.relatives.listP ^= null()  then do;
		     ListP = iSect.listP;
		     do ListI = lbound(List.items,1) to hbound(List.items,1);
			call ioa_ ("^-    ^v(^a, ^)^a", dim(List_item_names,1)-1, List_item_names(*) );
			end;
		     end;
		end;

	     if  ^vid.briefS  then			/* -long: report full errors noted in iSect structure.    */
SECTION_ERROR_MESSAGES:
	     do;
		if  iSect.bad_titleS  then
		     call info_seg_error_ (AvidP, 3, "Section title falls outside current guidelines." ||
		          "^[^/^7x recommend:  ^a:^;^s^]", iSect.title.should_be ^= "", iSect.title.should_be);
		if  iSect.syntax_title_wrong_for_kindS  then
		     call info_seg_error_ (AvidP, 4, "Section title not used for a ^a block." || 
		     "^/^7x recommend:  ^a:", iBlok_kind_display_string(iBlok.kind), iSect.title.should_be);
		if  iSect.blank_titleS  then  
		     call info_seg_error_ (AvidP, 3, "Section title contains only SP and HT characters.");
		if  iSect.long_titleS  then
		     call info_seg_error_ (AvidP, 3, "More than ^d characters in section title.", 
		          INFO_CHARS_PER_TITLE);
		if  iSect.bad_entry_points_inS  then
		     call info_seg_error_ (AvidP, 4, 
		            "Placeholder section has invalid format.  It should contain 2 lines." ||
			"^/^7x recommend:  ^a:" ||
			"^/^2-   ^a", iSect.title.should_be, INFO_SUBROUTINE_INTRO_ENTRY_POINTS_IN_CONTENTS);

		if ^(iSect.bad_titleS | iSect.syntax_title_wrong_for_kindS | iSect.blank_titleS  |  
		     iSect.bad_entry_points_inS)  &
		    iSect.title.in_file ^= iSect.title.should_be  &  iSect.title.should_be ^= ""  then
						/*   - Handle unrecognized_titleS stemming from wrong     */
						/*     capitalization, or just a non-typical title.       */
		     call info_seg_error_ (AvidP, 2, "Section title falls outside current guidelines." || 
			"^/^7x recommend:  ^a:", 
		          iSect.title.should_be);


		if  iSect.syntax_for_subroutine_invalidS  then
		     call info_seg_error_ (AvidP, 4, 
		          "Please give ""declare"" or ""dcl"" statement for the subroutine, followed by" || 
			"^/^2-its ""call"" or function value assignment (=) in subroutine syntax.");
		if  iSect.syntax_missing_left_bracketS  then
		     call info_seg_error_ (AvidP, 4, 
		          "Missing left-bracket ([) in active string syntax.");
		if  iSect.syntax_missing_right_bracketS  then
		     call info_seg_error_ (AvidP, 4, 
		          "Missing right-bracket (]) in active string syntax.");
		if  iSect.syntax_missing_namesS  then
		     if  iBlok.syntax.is_operationS  then
		          call info_seg_error_ (AvidP, 4,
			     "SHORT_COMMAND_NAME SHORT_OPERATION_NAME does not appear in syntax.");
		     else call info_seg_error_ (AvidP, 4, "None of the words in the header line appear in syntax.");
		if  iSect.syntax_missing_short_nameS  then
		     call info_seg_error_ (AvidP, 2, "Short name^[^;s^] ""^a"" ^[does^;do^] not appear in syntax.", 
		          index(short_name, SP)=0, short_name, index(short_name, SP)=0);
		if  iSect.syntax_uses_control_argumentsS  then
		     call info_seg_error_ (AvidP, 4, "Use -control_args instead of -control_arguments.");
		if  iSect.syntax_uses_control_argumentS  then
		     call info_seg_error_ (AvidP, 4, "Use -control_arg instead of -control_argument.");

		if  iSect.list_of_ops_bad_namesS  then do;
		     if  iSect.type = iSect_LIST_OF_OPERATIONS  then
			if  iBlok.kind = iBlok_kind_IO_MODULE  then
			     call info_seg_error_ (AvidP, 4, 
			          "Names for an I/O operation may be:" || 
			        "^/^2-open_file, open      [or just open_file  if iox_$open        not implemented]" ||
			        "^/^2-close_file, close    [or just close_file if iox_$close       not implemented]" ||
			        "^/^2-detach, detach_iocb  [or just detach     if iox_$detach_iocb not implemented]" );
		          else  call info_seg_error_ (AvidP, 4, 
			          "Names for an operation must be unique with longer name(s) first.");
		     else if  iSect.type = iSect_LIST_OF_CONTROL_OPERATIONS  then
			call info_seg_error_ (AvidP, 4, 
			     "Names for an I/O control order must be unique with longer name(s) first.");
						/* "unique" in above 2 msgs refers to unique-ness of      */
		     end;				/*   names in an item array (operation_names array)       */
		if  iSect.list_of_ops_long_nameS  then
		     call info_seg_error_ (AvidP, 4, "One or more names are longer than ^d characters.", entrynameL);
						/* Can't think of a reason for names longer than 32.      */
						/*  Array of 32-char names used to check name uniqueness. */
		if  iSect.list_of_ops_nonunique_namesS  then
		     call info_seg_error_ (AvidP, 4, "One or more names appears several times in this list.");
		if  iSect.list_of_ops_op_not_documentedS  then do;
		     all_names = "";
		     do Operation_ListI = lbound(Operation_List.items,1) to hbound(Operation_List.items,1);
			if  Operation_List.per_operation_iBlokP(Operation_ListI) = null()  then
			     all_names = all_names || Operation_List.items(Operation_ListI).nm(1) || SP_SP;
			end;
		     if  iBlok.syntax.request_summaryS  then
			call info_seg_error_ (AvidP, 2, 
			     "Requests having no documentation block:" ||
			   "^/^2-   ^a" ||
			   "^/^2- Ignore error if subsystem help request can find" ||
			   "^/^2- documentation for these requests in other info segs.",
			     all_names);
		     else call info_seg_error_ (AvidP, 4, "Operations having no documentation block: ^/^2- ^a", all_names);
		     end;

		if  iSect.control_order_bad_listS  then 
		     call info_seg_error_ (AvidP, 4, "Section should begin:^/^2-^a LONG_NAME{, SHORT_NAME}", 
		          info_seg_verify_$section_title( iSect_CONTROL_ORDER ));
		if  iSect.control_order_bad_name_orderS  then do;
		     if  iBlok.syntax.is_controlS  then
		     if  info_seg_util_$is_control_format_block( iBlokP, Operation_ListP, Operation_ListI)  then
			call info_seg_error_ (AvidP, 4, "Section should begin:^/^2-^a  ^v(^a, ^)^a", 
			     info_seg_verify_$section_title( iSect_CONTROL_ORDER ), 
			     dim(operation_names,1)-1, operation_names(*) );
		     end;

		end SECTION_ERROR_MESSAGES;
	     end SCAN_SECTIONS_OF_BLOCK;

/* --------------------------------------------------------------------------------
   SECTION-, PARAGRAPH-, and LINE-LEVEL data:
    In current block, collect/report section, paragraph and line numbers having 
    various types of errors.  All errors of given type are collected and reported
    in a single error message.
   -------------------------------------------------------------------------------- */

	eSerr = 0;				/*  - Zero all line numbers and Lerr.N counts for sect err*/
	call collect_block_section_errors (addr(eSerr), addr(iBlok));
						/*  - Walk thru all sections of block, recording line     */
						/*    number having each of the known sect-related error. */
	LerrP = addr(eSerr.unrecognized_title);
	if  Lerr.N > 0  then call info_seg_error_ (AvidP, 1, 
	     "^d ^[sections have^;section has^] a nonstandard title" || 
	     "^[.  First ^d sections begin^;, beginning^] on line:^(^/^2-  ^10(^d  ^)^)",
	     Lerr.actualN, Lerr.actualN > 1, Lerr.actualN > Lerr.N, Lerr.no(*) );



	ePerr = 0;				/*  - Zero all line numbers and Lerr.N counts for pgh err */
	call collect_block_paragraph_errors (addr(ePerr), addr(iBlok));
						/*  - Walk thru all paragraphs of block, recording line   */
						/*    number having each of known paragraph-related error */

	LerrP = addr(ePerr.long_paragraph);		/*  - Report lines having each known error type.	        */
	if  Lerr.N > 0  then call info_seg_error_ (AvidP, 2,
	     "^d ^[paragraphs have^;paragraph has^] more than ^d lines" || 
	     "^[.  First ^d paragraphs begin^;, beginning^] on line:^(^/^2-  ^10(^d  ^)^)",
	     Lerr.actualN, Lerr.actualN > 1, INFO_LINES_PER_PARAGRAPH, Lerr.actualN > Lerr.N, Lerr.no(*) );

	LerrP = addr(ePerr.few_blank_lines_before_paragraph);
	if  Lerr.N > 0  then call info_seg_error_ (AvidP, 3,
	     "^d ^[paragraphs have^;paragraph has^] less than ^d lines preceding paragraph" || 
	     "^[.  First ^d are:^;:^]^(^/^2-  ^10(^d  ^)^)",
	     Lerr.actualN, Lerr.actualN > 1, INFO_BLANK_LINES_BEFORE_PARAGRAPH, 
	     Lerr.actualN > Lerr.N, Lerr.no(*) );

	LerrP = addr(ePerr.many_blank_lines_before_paragraph);
	if  Lerr.N > 0  then call info_seg_error_ (AvidP, 3,
	     "^d ^[paragraphs have^;paragraph has^] more than ^d lines preceding paragraph" || 
	     "^[.  First ^d are:^;:^]^(^/^2-  ^10(^d  ^)^)",
	     Lerr.actualN, Lerr.actualN > 1, INFO_BLANK_LINES_BEFORE_PARAGRAPH, 
	     Lerr.actualN > Lerr.N, Lerr.no(*) );


	eLerr = 0;				/*  - Zero all line numbers and Lerr.N counts for line err*/
	call collect_block_line_errors (addr(eLerr), addr(iBlok));
						/*  - Walk thru all lines of block, recording line number */
						/*    having each of the known line-related errors.       */

	LerrP = addr(eLerr.all_whitespace);		/*  - Report lines having each known error type.	        */
	if  Lerr.N > 0  then call info_seg_error_ (AvidP, 3, 
	     "^d ^[lines have^;line has^] only horizontal-tab and space characters" || 
	     "^[.  First ^d are:^;:^]^(^/^2-  ^10(^d  ^)^)",
	     Lerr.actualN, Lerr.actualN > 1, Lerr.actualN > Lerr.N, Lerr.no(*) );

	LerrP = addr(eLerr.ends_whitespace);
	if  Lerr.N > 0  then call info_seg_error_ (AvidP, 3, 
	     "^d ^[lines^;line^] ends with horizontal-tab and space characters^[.  First ^d are:^;:^]^(^/^2-  ^10(^d  ^)^)",
	     Lerr.actualN, Lerr.actualN > 1, Lerr.actualN > Lerr.N, Lerr.no(*) );

	LerrP = addr(eLerr.overlength);
	if  Lerr.N > 0  then call info_seg_error_ (AvidP, 3, 
	     "^d ^[lines are^;line is^] longer than ^d characters^[.  First ^d are:^;:^]^(^/^2-  ^10(^d  ^)^)",
	     Lerr.actualN, Lerr.actualN > 1, INFO_CHARS_PER_LINE, Lerr.actualN > Lerr.N, Lerr.no(*) );

	LerrP = addr(eLerr.backspace);
	if  Lerr.N > 0  then call info_seg_error_ (AvidP, 2, 
	     "^d ^[lines have^;line has^] backspace characters^[.  First ^d are:^;:^]^(^/^2-  ^10(^d  ^)^)",
	     Lerr.actualN, Lerr.actualN > 1, Lerr.actualN > Lerr.N, Lerr.no(*) );

	LerrP = addr(eLerr.unprintable);
	if  Lerr.N > 0  then call info_seg_error_ (AvidP, 3, 
	     "^d ^[lines have^;line has^] control or DEL characters^[.  First ^d are:^;:^]^(^/^2-  ^10(^d  ^)^)",
	     Lerr.actualN, Lerr.actualN > 1, Lerr.actualN > Lerr.N, Lerr.no(*) );

/* --------------------------------------------------------------------------------
   SECTION-, PARAGRAPH-, and LINE-LEVEL data: ends
   -------------------------------------------------------------------------------- */


FEW_ERRORS_FOR_HISTORY_COMMENT:
	iLineP = iBlok.lines.lastP;
	if  iLine.NL_missingS  then			/*    - Only last line of info seg can have this error.   */
	     call info_seg_error_ (AvidP, 4, 
	          "Last line does not end with a newline character:^(  ^d^)", iLine.line_in_file );


/* -----------------------------------------------------------------
   -block START:COUNT   
     Display block lines if debugging at block-level.
   ----------------------------------------------------------------- */

	if  mode = NO_PRINTING  then;
	else if  vid.lines.blok.start ^= 0 & 
	         iFile.structure ^= iFile_struc_err_EMPTY_INFO  then do;
	     call info_seg_util_$print_block_lines (iBlokP, vid.lines.blok);
	     call info_seg_error_$set_error_emitted (T);
	     end;

	end SCAN_BLOCKS;

/* --------------------------------------------------------------------------------
   BLOCK-LEVEL data: ends
   -------------------------------------------------------------------------------- */


/* -----------------------------------------------------------------
   -lines START:COUNT
     Display file line content.
   ----------------------------------------------------------------- */

     if  mode = NO_PRINTING  then;			/* Display no file lines if asking just for totals.       */

     else if  iFile.structure = iFile_struc_err_EMPTY_INFO  then do;
						/* Display any lines of empty info segment.	        */
  dcl 1 first_20_lines aligned like verify_info_data.lines.file;

	first_20_lines.start = 1;
	first_20_lines.count = 20;
	call info_seg_util_$print_file_lines (iFileP, first_20_lines);
	end;

     else if  vid.lines.file.start ^= 0  then 		/* Display requested lines of entire info segment.        */
	call info_seg_util_$print_file_lines (iFileP, vid.lines.file);


/* -----------------------------------------------------------------
   Ask user if unexpected info seg names should be deleted.
    - If no: re-add unexpected names at end of name list.
   ----------------------------------------------------------------- */

     if  mode > NO_PRINTING  &  iFile.names_extraS  &  vid.naming = VI_NAMING_query  then do;

  dcl  yesS bit(1) aligned;

	call ioa_("");
	call info_seg_error_$name_list (AvidP, 2, "Unexpected names found on the info segment:",
	     NAME_LIST_INDENT, NAME_WIDTH_UNKNOWN, namesExtra);
	call command_query_$yes_no (yesS, 0, ssu_$get_subsystem_and_request_name(vid.isd.sciP), 
               "Do you want to delete the unexpected names shown above?", "Delete the names above?");
	if  ^yesS  then				/* Not deleting unexpected names?  Re-add then at end     */
						/*  of namelist.				        */
	     call info_seg_util_$add_names( addr(vid.isd), iFileP, namesExtra );
	end;

/* --------------------------------------------------------------------------------
   FILE-LEVEL data: ends
   -------------------------------------------------------------------------------- */

     return;
%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Individual routines beyond this point check for additional errors, and were invoked near the   */
	/* beginning of this program.	 Each begins with a FUNCTION section, describing the checks made.   */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


/* -------------------------------------------------------------------------------------
   INTERNAL SUBROUTINE:  check_block_divider_names

   FUNCTION: verify that block divider names conform to all rules.

   OBSERVATION:  Names on "General Info" blocks are difficult to verify.  Particular name suffix
	       causes a block to be treated as a "General Info" kind.  See output of: vi -rules block

   OBSERVATION:  Names on "Subroutine Topic" blocks are difficult to verify.  Particular name suffix
	       causes a block to be treated as a "Subsystem Topic" kind; but so can use of
	       particular section title.  See output of: vi -rule block

   OBSERVATION:  Names on "Subsystem Request...", "Subsystem Summary" and "Subsystem Topic" blocks
	       might not appear as external names on the containing info segment.  Whether they do
	       or don't depends upon the subsystem's overall strategy for storing and finding
	       data used by its internal help request.  
	        1) ssu_ is documented to store help data in separate info segs in subdirectories 
		 below >doc>subsystem; and uses per-subsystem info search paths set when the 
		 ssu_ invocation is created locate those info segs.  Such subsystems use the
		 ssu-provided help and list_help requests to select segs to display using these
		 search paths.
                  2) Subsystems like probe, mbuild, and ted provide their own help request that
		 searches the command's info segment (via help_) looking for :[Info]: blocks 
		 containing subsystem request and topic descriptions.  Names of :[Info]: blocks 
		 are not external names on the command's info segment; so such segments may be
		 stored in >doc>info or >doc>priv without fear that request/topic names will 
		 conflict with names of other Multics commands or general info topics.

	RULE:  Different name checks are applied for each info block kind.
          RULE:  Info block divider names stem from header line names for most block kinds.
	RULE:  Requirements for external names on info segment vary depending divider ilk.
	        - :Entry: and :[Info]: divider names are not placed on containing info segment.
	        - :Info: divider names are placed on containing info segment (with .info suffix).
	        - Info segments with no dividers have external name(s) stemming from block kind.
		BEWARE: Sometimes "block kind" is determined by examining external names on the
		        info segment (as in info segs ending in .gi.info, etc.).
		        See output of: verify_info -rules block  (Rules 4 and 5)


             INFO BLOCK KIND              NAMES THAT SHOULD APPEAR IN THE DIVIDER

   Names on :Entry: dividers --------  -----------------------------
               Subroutine entrypoint:  For each name in block header line, use ENTRYPOINT_NAME portion.
			            (eg, :Entry: chname_file:  1982-03-08  hcs_$chname_file )
			          - If block header line describes more than one entrypoint,
			            all ENTRYPOINT_NAME values should be given as divider names
				  (eg, :Entry: ioa_: nnl:  2019-05-24  ioa_, ioa_$nnl )
				       \-- divider -----/  \-- header --------------/
			         External names: No ENTRYPOINT_NAMEs appear as external names on the info segment.


   Names on :Info: & :[Info]: divs --  -----------------------------
             Subroutine Introduction:  For each name in block header line, use REF_NAME_ portion.
			            (eg, :Info: hcs_:  1987-09-20  hcs_ )
				       \-divider--/  \--header------/
			         External names:  REF_NAME_.info should always appear as external name on info seg.


      Command and/or Active Function:  All names given in block header line, in same order as header line names.
			            (eg, :Info: add_name: an:  1990-07-09  add_name, an )
				       \-- divider -------/  \-- header ------------/

			         EXCEPTION: in Operation Format, each divider name consists of: 
				   - short name of the command;
				   - dot (.) separator; and 
				   - long or short operation name for the operation being described.  
			           All long and short operation names (as given in "List of operations" mentioned above)
			           should be given as one of the divider names.

			         External names for :Info: divider (or seg w/o a divider): 
			           Each divider name for :Info: divider (or each header name for info seg w/o divider)
			           should appear as external name on info segment, in order given in header line,
				 with .info suffix added to name.  
			         External names for :[Info]: divider: no divider names are used as external names.

    Subsystem Request/Active Request:  All names given in block header line, in same order as header line names. 
			            (eg, :Info: stack: sk:  1982-05-04  stack, sk )
				       \-- divider ----/  \-- header ---------/

			         EXCEPTION: in Operation Format, each divider name consists of: 
				   - short name of the request;
				   - dot (.) separator; and 
				   - long or short operation name for the operation being described.  
			           All long and short operation names (as given in "List of operations" mentioned above)
			           should be given as one of the divider names.  

			         External names for :Info: divider (or seg w/o a divider): 
			           Each divider name for :Info: divider (or each header name for info seg w/o divider)
			           should appear as external name on info segment, in order given in header line,
				 with .info suffix added to name.  
			         External names for :[Info]: divider: no divider names are used as external names.

                     Subsystem Topic:  Divider names do not depend upon heading.  Author of topic must determine 
			         appropriate names to search for this topic.
			          - One way to force block to be treated as Subsystem Topic block kind: 
				   give it at least one divider name ending in .topic.
			            (eg, :Info: summary.topic: summary:  1988-09-30  General information about probe )
				       \-- divider -----------------/  \-- header -------------------------------/
				- Another way: 1st section of block has title beginning: "Notes on ..."

			         External names for :Info: divider (or seg w/o a divider): 
			           Author-chosen name appears as external name on info segment 
				 with .info suffix added to name.
			         External names for :[Info]: divider: no divider names are used as external names.


                           IO Module:  First name given in block header should appear as the divider name.
			            (eg, :Info: mtape_:  1988-04-12 mtape_ I/O module)
				       \--divider---/  \-- header ----------------/
			         External names: This name also appears as external name on info segment.

                        IO Operation:  1st and 2nd header words (joined by a period) appear as the divider name.
			           - In addition, if main info block "List of operations" includes an alternate name
			             for this operation, that name also appears as a divider name.
			            (eg, :Info: mtape_.open_file: mtape_.open:  2020-06-17  mtape_ open_file operation)
				       \-- divider ------------------------/  \-- header --------------------------/
			         This happens when I/O module supports both the operation calling for a description
			         (like the "open description"), plus the description-less version of same operation.
			         External names: all divider names appear as external names on the info segment.

                          IO Control:  First and second names (joined by a period) appear as the divider name.
			         In addition, if main info block "List of control operations" includes a second
			         (alternate name) for this control order, that name also appears as a divider name.
			            (eg, :Info: mtape_.file_status: mtape_.fst:  2020-06-17  mtape_ file_status control)
			           This happens when I/O module control order has a long name, and a short name usuable
			           when the control is invoke via io_call command.
			         External names: all divider names appear as external names on the info segment.


                        General Info:  All names by which block should be accessed by external help command
			         (without the .info suffix).   (unverifiable)
			            (eg, :Info: info_seg.gi: info_seg:  2019-05-28  Info Segment Standards )
				       \-- divider ----------------/  \-- header ----------------------/
			         At least one name with one of the special suffix values for General Info segs.
			          - Method to force block to be treated as a General Info block kind.
				- For list of suffixes, see Rule 5 in output of:  vi -block  
			         External names: Each divider name should appear as external name on info segment, 
			         in order names are given in divider.

   Names on :hcom: divider ----------  -----------------------------
                     History Comment:  This divider type has no divider names or heading line.
			         External names: none

   Names on :Internal: divider ------  -----------------------------
                     History Comment:  This divider type is obsolete.  Use the :hcom: divider instead.
			            (eg, :Internal: history_comment.gi:  2020-08-02  history_comment )
				       \-- divider -----------------/  \-- header ---------------/
			         External names: when this divider is used, name did not appear as external name info seg.
   ------------------------------------------------------------------------------------- */
%page;
check_block_divider_names:
     proc();

/* -----------------------------------------------------------------
    1) Organize checks by info seg file structure.
    2) While processing blocks, gather "external names" (names that 
       should appear on info seg) to later compare with actual names.
   ----------------------------------------------------------------- */


     if  iFile.structure > 0  then
	goto BLOCK_NAMES_FOR (iFile.structure);		/* Block names check depends on file structure...	        */
     else goto FILE_STRUCTURE_ERROR;			/*  - Skip name checks for unknown/bad structures.        */
     

BLOCK_NAMES_FOR (iFile_structure_INFO_SUBROUTINE_HCOM):	/* One of three possible structures for subroutine info   */
						/*    which has a history comment.		        */
     iBlokP, iBlok_HCOM_or_nullP = iFile.bloks.lastP;	/*  - Get ptr to block beyond last subr entrypoint block  */
						/*    which has been verified to be the HCOM block.       */
     if  iBlok.divider = iBlok_divider_hcom_obsolete  then
	iBlok.obsolete_dividerS = T;
     else if  dim(Blok_names,1) > 0  then
	iBlok.bad_divider_namesS = T;
     else iBlok.no_namesS = F;			/*  - History comment SHOULD have no names.	        */
     

BLOCK_NAMES_FOR (iFile_structure_INFO_SUBROUTINE):
BLOCK_NAMES_FOR (iFile_structure_SUBROUTINE):
     iBlokP = iFile.bloks.firstP;			/* First block known to be: Subroutine Intro	        */
     if  dim(Blok_words,1) > 0  then do;
	if  dim(Blok_names,1) > 0  then 		/*  - Are there names in both header and divider?	        */
	     call compare_names (Blok_words, Blok_names, NO_REF_NAME_, 
			     iBlok.bad_divider_namesS, iBlok.order_divider_namesS);
						/*     - Compare those name arrays.		        */

	else if  iFile.structure = iFile_structure_SUBROUTINE  then;
						/*  - Subroutine intro has no divider, no names to check. */

	else iBlok.bad_divider_namesS = T;		/*  - Subroutine intro divider exists w/ no names!        */


	subr_intro_refname = Blok_words(1);		/*  - Save first REF_NAME_ for checks of SUBROUTINE_ENTRY */
						/*    names.				        */
	call add_names (Blok_words, addr(need_names));	/*  - All words in subr intro header are REF_NAME_s, which*/
						/*    should appear as external names on the segment.     */
SUBROUTINE_ENTRY_BLOCKS:
	do iBlokP = iBlok.nextP			/*  - Do name(s) in each ep header match divider name(s)? */
	     repeat iBlok.nextP  while (iBlokP ^= iBlok_HCOM_or_nullP);
	     if  dim(Blok_words,1) > 0  &  dim(Blok_names,1) > 0  then
		call compare_names (Blok_words, Blok_names, subr_intro_refname, 
			          iBlok.bad_divider_namesS, iBlok.order_divider_namesS);
	     else iBlok.bad_divider_namesS = T;
	     end SUBROUTINE_ENTRY_BLOCKS;
	end;
     goto END_OF_BLOCK_NAMES_CHECK;


					
BLOCK_NAMES_FOR (iFile_structure_INFO_HCOM):		/* All blocks have a divider.			        */

     iBlokP, iBlok_HCOM_or_nullP = iFile.bloks.lastP;	/*  - Get ptr to block beyond last subr entrypoint block  */
						/*    which has been verified to be the HCOM block.       */
     if  iBlok.divider = iBlok_divider_hcom_obsolete  then
	iBlok.obsolete_dividerS = T;
     else if  dim(Blok_names,1) > 0  then
	iBlok.bad_divider_namesS = T;
     else iBlok.no_namesS = F;			/*  - History comment SHOULD have no names.	        */

BLOCK_NAMES_FOR (iFile_structure_INFO):
NON_SUBROUTINE_MULTI_BLOCK:
     do iBlokP = iFile.bloks.firstP			/*  - Check names on all blocks in info seg.	        */
          repeat iBlok.nextP  while (iBlokP ^= null() );
	if  dim(Blok_names,1) = 0  then		/*     - Are there block names to check?	        */
	     iBlok.bad_divider_namesS = T;		/*        - Error if block divider has no names.	        */
	else do;
	     goto NAMES_FOR_KIND (iBlok.kind);		/*     - Divider names depend upon block kind.	        */

NAMES_FOR_KIND (iBlok_kind_SUBROUTINE_ENTRY):		/* Standalone subroutine entry description can appear in  */
						/* an info seg with :Info: blocks, if its ref_name equals */
						/* its entrypoint_name.  Examples are:		        */
						/*    hcom_validation_rtn_.info   match_star_name_.info   */
						/* Since the subroutine documentation may be describing   */
						/* a user-supplied routine which may not exist, no check  */
						/* is made to test existence/spelling of subroutine name. */
     if  dim(Blok_words,1) = 1  &  dim(Blok_names,1) = 1  then
     if  Blok_words(1) = Blok_names(1)  then
     if  verify(Blok_words(1), LETTERS_DIGITS_UNDERSCORE) = 0  then
          call add_names (Blok_words, addr(need_names));
     goto NC_NEXT_BLOCK;


NAMES_FOR_KIND (iBlok_kind_SUBSYSTEM_SUMMARY):		/* No expectations for subsystem topic block names.       */
NAMES_FOR_KIND (iBlok_kind_SUBSYSTEM_TOPIC):
               if  iBlok.syntax.has_subsystem_pathS  then 	/*        - In >subsystem> subtree...		        */
	          if  iBlok.divider = iBlok_divider_Info_no_ext_names  then 
		     iBlok.bad_dividerS = T;		/*           all names should be external	        */

	     if  iBlok.divider = iBlok_divider_Info_no_ext_names  then;
						/*         - Names for :[Info]: divider not external.     */
	     else call add_names (Blok_names, addr(need_names));
	     goto NC_NEXT_BLOCK;

NAMES_FOR_KIND (iBlok_kind_REQUEST_AR):			/*     - Subsystem request names appear on info seg if    */
NAMES_FOR_KIND (iBlok_kind_REQUEST):			/*       divider is :Info: or seg resides in >subsystem>  */
NAMES_FOR_KIND (iBlok_kind_ACTIVE_REQUEST):		/*       subtree.				        */
               if  iBlok.syntax.has_subsystem_pathS  then 	/*        - In >subsystem> subtree...		        */
	          if  iBlok.divider = iBlok_divider_Info_no_ext_names  then
		     iBlok.bad_dividerS = T;		/*           all names should be external	        */
	     goto SUBSYSTEM_REQUEST;		


NAMES_FOR_KIND (iBlok_kind_COMMAND_AF):			/*     - All header words are command/AF names which      */
NAMES_FOR_KIND (iBlok_kind_COMMAND):			/*       should appear as external names on info segment  */
NAMES_FOR_KIND (iBlok_kind_ACTIVE_FUNCTION):		/*        - check names.			        */
	     if  iBlok.divider = iBlok_divider_Info_no_ext_names  then
	          iBlok.bad_dividerS = T;		/*        - Names of command/AF should always be external */
SUBSYSTEM_REQUEST:
	     if  iBlok.syntax.is_operationS  then 
	     if  info_seg_util_$is_operation_format_block( iBlokP, Operation_ListP, Operation_ListI)
	     then do;
		NamesP = names_for_current_operation();
		if  iBlok.divider = iBlok_divider_Info_no_ext_names  then;
						/*         - Names for :[Info]: divider not external.     */
		else call add_names (Names.nm, addr(need_names));
		call compare_names (Names.nm, Blok_names, NO_REF_NAME_,
			          iBlok.bad_divider_namesS, iBlok.order_divider_namesS);		
		goto NC_NEXT_BLOCK;
		end;

	     if  iBlok.divider = iBlok_divider_Info_no_ext_names  then;
						/*         - Names for :[Info]: divider not external.     */
	     else call add_names (Blok_words, addr(need_names));

	     call compare_names (Blok_words, Blok_names, NO_REF_NAME_, 
			     iBlok.bad_divider_namesS, iBlok.order_divider_namesS);
	     goto NC_NEXT_BLOCK;


NAMES_FOR_KIND (iBlok_kind_IO_MODULE):			/* First header word should appear as a divider name.     */
	     if  iBlok.divider = iBlok_divider_Info_no_ext_names  then
	          iBlok.bad_dividerS = T;		/*        - Names of I/O Module should always be external */
	     if  dim(Blok_words,1) > 0  then do;
	          iName10.N = 1;
		iName10.nm(1) = Blok_words(1);	/*  - header content (if it exists) was verified above.   */
		NamesP = addr(iName10);
		call add_names (Names.nm, addr(need_names));
		call compare_names (Names.nm, Blok_names, NO_REF_NAME_,
			          iBlok.bad_divider_namesS, iBlok.order_divider_namesS);
		end;
	     goto NC_NEXT_BLOCK;
	     
NAMES_FOR_KIND (iBlok_kind_IO_OPERATION):
	     if  iBlok.divider = iBlok_divider_Info_no_ext_names  then
	          iBlok.bad_dividerS = T;		/*        - Names of IO Operation always  external        */

				 		/* If operation found in "List of operations" section,    */
	     if  iBlok.syntax.is_operationS  then	/*  then check for names as they appear in that list.     */
	     if  info_seg_util_$is_operation_format_block( iBlokP, Operation_ListP, Operation_ListI)
	     then do;
		NamesP = names_for_current_operation();
		call add_names (Names.nm, addr(need_names));
		call compare_names (Names.nm, Blok_names, NO_REF_NAME_,
			          iBlok.bad_divider_namesS, iBlok.order_divider_namesS);		
		end;
						/* Blocks not in "List of operations" have no external    */
	     goto NC_NEXT_BLOCK;			/*  names (until user fixes that omission).	        */

NAMES_FOR_KIND (iBlok_kind_IO_CONTROL):
	     if  iBlok.divider = iBlok_divider_Info_no_ext_names  then
	          iBlok.bad_dividerS = T;		/*        - Names of IO Control always  external	        */

			         			/* If control found in "List of control operations" sect, */
	     if  iBlok.syntax.is_controlS  then		/*  then check for names as they appear in that list.     */
	     if  info_seg_util_$is_control_format_block( iBlokP, Operation_ListP, Operation_ListI)
	     then do;
		NamesP = names_for_current_operation();
		call add_names (Names.nm, addr(need_names));
		call compare_names (Names.nm, Blok_names, NO_REF_NAME_,
			          iBlok.bad_divider_namesS, iBlok.order_divider_namesS);		
		end;
						/* Blocks not in "List of control operations" have no     */
	     goto NC_NEXT_BLOCK;			/*  external names (until user fixes that omission).      */
	     

NAMES_FOR_KIND (iBlok_kind_GENERAL_INFO):
	     if  iBlok.divider = iBlok_divider_Info_no_ext_names  then
	          iBlok.bad_dividerS = T;		/*        - Names of General Info are always  external    */

				 		/* No expectations for general info block names; but      */
	     if  dim(Blok_names,1) = 1  then		/*  - If it looks like a history comment block,	        */
	     if  index(Blok_names(1), "history_comment") > 0  then do;
		iBlok.bad_divider_namesS = T;		/*    then set divider name error.		        */
		goto NC_NEXT_BLOCK;
		end;

	     call add_names (Blok_names, addr(need_names));
	     goto NC_NEXT_BLOCK;			/*  - Else all divider names should appear as external    */
						/*    names on the info segment.		        */

NAMES_FOR_KIND (iBlok_kind_HISTORY_COMMENT):		/* History comments have no divider name or header.       */
						/*   Testing was done above (in per-structure tests).     */

NAMES_FOR_KIND (iBlok_kind_SUBROUTINE_INTRO):		/* These are handled in iFile_structure SUBROUTINE above  */
NAMES_FOR_KIND (iBlok_kind_SUBROUTINE_BRIEF_INTRO):	/*   so these two labels should never be used.	        */
						/*   Labels document these cases are covered.	        */

NAMES_FOR_KIND (iBlok_kind_Header_Only):		/* No expectations for names on unpopulated blocks, or    */
NAMES_FOR_KIND (iBlok_kind_Unknown):			/*   blocks of unknown kind.			        */
	     end;
NC_NEXT_BLOCK:
	end NON_SUBROUTINE_MULTI_BLOCK;
     goto END_OF_BLOCK_NAMES_CHECK;
     

BLOCK_NAMES_FOR (iFile_structure_NO_DIVIDERS):		/* Info seg has one block, without a divider	        */
     iBlokP = iFile.bloks.firstP;
     if  iBlokP = null()  then 
	goto END_OF_BLOCK_NAMES_CHECK;
     goto SINGLE_BLOCK_NAMES_FOR_KIND (iBlok.kind);
     
SINGLE_BLOCK_NAMES_FOR_KIND (iBlok_kind_SUBROUTINE_ENTRY):	/* A subroutine entrypoint named: REF_NAME_$REF_NAME_     */
						/* can be described in an info segment w/o dividers.      */
						/* An example is: match_star_name_.info		        */
						/*   header:  DATE_MOD  ref_name_		        */
						/* So external name should be: ref_name_.info	        */

SINGLE_BLOCK_NAMES_FOR_KIND (iBlok_kind_COMMAND_AF):
SINGLE_BLOCK_NAMES_FOR_KIND (iBlok_kind_COMMAND):
SINGLE_BLOCK_NAMES_FOR_KIND (iBlok_kind_ACTIVE_FUNCTION):
     call add_names (Blok_words, addr(need_names));	/*     - All header words are command/AF names which      */
     goto END_OF_BLOCK_NAMES_CHECK;			/*       should appear as external names on info segment  */


SINGLE_BLOCK_NAMES_FOR_KIND (iBlok_kind_REQUEST_AR):	/* Subsystem-related single-block info segments using the */
SINGLE_BLOCK_NAMES_FOR_KIND (iBlok_kind_REQUEST):		/*  >doc>subsystem>... method for help data should have   */
SINGLE_BLOCK_NAMES_FOR_KIND (iBlok_kind_ACTIVE_REQUEST):	/*  all header words as external names on the info seg.   */
     call add_names (Blok_words, addr(need_names));
     goto END_OF_BLOCK_NAMES_CHECK;
     

SINGLE_BLOCK_NAMES_FOR_KIND (iBlok_kind_SUBSYSTEM_SUMMARY): /* Subsystem-related kinds that are only used in a        */
SINGLE_BLOCK_NAMES_FOR_KIND (iBlok_kind_SUBSYSTEM_TOPIC):	/*  Subsystem Multi-Block Info Segment.  No expectations. */

SINGLE_BLOCK_NAMES_FOR_KIND (iBlok_kind_SUBROUTINE_INTRO):	/* Subroutine info seg do not use single-block structure  */
SINGLE_BLOCK_NAMES_FOR_KIND (iBlok_kind_SUBROUTINE_BRIEF_INTRO):

SINGLE_BLOCK_NAMES_FOR_KIND (iBlok_kind_GENERAL_INFO):	/* No expectations for general info block names.	        */

SINGLE_BLOCK_NAMES_FOR_KIND (iBlok_kind_IO_MODULE):	/* IO Module cannot appear in single-block info seg       */
SINGLE_BLOCK_NAMES_FOR_KIND (iBlok_kind_IO_OPERATION):	/* IO Operation cannot appear in single-block info seg    */
SINGLE_BLOCK_NAMES_FOR_KIND (iBlok_kind_IO_CONTROL):	/* IO Control order cannot appear in single-block info seg*/
SINGLE_BLOCK_NAMES_FOR_KIND (iBlok_kind_HISTORY_COMMENT):	/* History comment cannot appear in single-block info seg */

SINGLE_BLOCK_NAMES_FOR_KIND (iBlok_kind_Header_Only):	/* No expectations for names on unpopulated blocks, or    */
SINGLE_BLOCK_NAMES_FOR_KIND (iBlok_kind_Unknown):		/*   blocks of unknown kind.			        */

FILE_STRUCTURE_ERROR:
END_OF_BLOCK_NAMES_CHECK:
     return;

     end check_block_divider_names;
%page;
/* -------------------------------------------------------------------------------------
   INTERNAL SUBROUTINE:  check_file_names

   FUNCTION: verify seg names conform to all rules.

   OBSERVATION:  External help and list_help commands can only find info segments by their segment names.

	RULE:  Info segment names all have a final suffix of: .info
	RULE:  Order of names on segment:
                  - For single-block info segments:  should match order of names in block header line.
	        - For multi-block  info segments:  should match order of names in block dividers (which
					    for command/AFs should match order of names in 
					    the block header line).

             INFO BLOCK KIND              NAME CHECK RULE
   Multi-block info segment names ---  -----------------------------
                          Subroutine:  Only segment name is REF_NAME_.info (eg, hcs_.info)
      Command and/or Active Function:  All names in its header (eg, probe.info, pb.info)
                           IO Module:  First name in its header (eg, mtape_.info)
		    IO Operation:  <Operation_List.blok_name>.OPERATION_NAME.info (eg, mtape_.open_file.info)
		      IO Control:  <Operation_List.blok_name>.CONTROL_NAME.info (eg, mtape_.file_status.info)
                        General Info:  All names in :Info: divider for the general info block
			            (eg, info_seg.gi.info, info_seg.info )

   Single-block info segment names --  -----------------------------
      Command and/or Active Function:  All names in the header (eg, list.info, ls.info)
                        General Info:  All names by which info segment should be 
			         located by external help and list_help commands. (unverifiable)

   ------------------------------------------------------------------------------------- */

check_file_names:
     proc();
     
     if  iFile.names.N > 0  then do;
	if  each_word_matches_STR_regex (File_names, ".\(STR)$", (info_seg_suffix))  then;
	else  iFile.names_missing_info_suffixS = T;	/* All names must end with: .info		        */

	if  dim(need_File_names,1) > 0  then do;	/* More name checks if header/divider names suggest       */
						/*  a set of names in an expected order.	        */
	     call do_names_exist_in_order (need_File_names, File_names, addr(missing_names), addr(extra_names), 
				  iFile.name_order_warningS);
	     iFile.names_missingS = (missing_names.N > 0);
	     iFile.names_extraS   = (extra_names.N > 0);
	     end;
	end;
     return;
     

do_names_exist_in_order:
	proc (desired_names, names, missing_namesP, extra_namesP, name_order_warningS);

  dcl  desired_names (*) char(32) var;
  dcl  names (*) char(32) var;
  dcl  missing_namesP ptr;
  dcl  extra_namesP ptr;     
  dcl  name_order_warningS bit(1) unal;
     
  dcl 1 extra_names   aligned like iName300 based(extra_namesP);
  dcl 1 missing_names aligned like iName300 based(missing_namesP);     

  dcl (dnmI, nmI, last_found_nmI) fixed bin;

	do dnmI = lbound(desired_names,1) to hbound(desired_names,1);
	     do nmI = lbound(names,1) to hbound(names,1);	/* Are some desired names missing?		        */
		if  desired_names(dnmI) = names(nmI)  then 
		     goto DESIRED_NAME_MATCHED;
		end;
	     if  missing_names.N < dim(missing_names.nm,1)  then do;
		missing_names.N = missing_names.N + 1;	/*  - Log missing name for display in error message.      */
		missing_names.nm(missing_names.N) = desired_names(dnmI);
		end;
DESIRED_NAME_MATCHED:
	     end;

	do nmI = lbound(names,1) to hbound(names,1);	/* Are some actual file names not in desired list?        */
	     do dnmI = lbound(desired_names,1) to hbound(desired_names,1);
		if  desired_names(dnmI) = names(nmI)  then 
		     goto NAME_MATCHED;
		end;
	     if  extra_names.N < dim(extra_names.nm,1)  then do;
		extra_names.N = extra_names.N + 1;	/*  - Log extra name for display in warning message.      */
		extra_names.nm(extra_names.N) = names(nmI);
		end;
NAME_MATCHED:  end;
     
	name_order_warningS = (missing_names.N > 0);
	last_found_nmI = 0;
	if  ^name_order_warningS  then do;		/* If no desired names were missing, check for desired    */
						/*  name order.				        */
	     do dnmI = lbound(desired_names,1) to hbound(desired_names,1);
		do nmI = lbound(names,1) to hbound(names,1);
		     if  desired_names(dnmI) = names(nmI)  then do;
			if  dnmI > nmI  |  nmI < last_found_nmI  then do;
						/* If index of desired names comes after index in actual  */
			     name_order_warningS = T;	/*  names, then misordering has occurred.	        */
			     return;
			     end;			/*  NOTE: dnmI could be < nmI  if names has extra_names   */
			last_found_nmI = nmI;
			goto NAME_ORDER_MATCHED;
			end;
		     end;
		name_order_warningS = T;		/* Desired name not found.			        */
NAME_ORDER_MATCHED: end;
	     end;

	end do_names_exist_in_order;

     end check_file_names;
%page;
/* -------------------------------------------------------------------------------------
   INTERNAL SUBROUTINE:  check_header_line_words

   FUNCTION: verify words in header line conform to content guidelines.

          RULE:  Information in the block header line controls most name checking.
	RULE:  Content guidelines differ for each info block kind.

             INFO BLOCK KIND              CONTENT GUIDELINE - Words in block header line
   ----------------------------------  -------------------------------------------------
             Subroutine Introduction:  single REF_NAME_ for the subroutine (eg, hcs_)

               Subroutine Entrypoint:  REF_NAME_$ENTRYPOINT_NAME for the entrypoint (eg, hcs_$chname_file).
			          - If :Entry: block describes more than one entrypoint,
			            all REF_NAME_$ENTRYPOINT_NAME items should be given as comma-separated list
				  (eg, ioa_, ioa_$nnl)   
				  [Note:  when REF_NAME_ and ENTRYPOINT_NAME are the same string,
					just give  REF_NAME_   (eg, use ioa_ rather than ioa_$ioa_)]

      Command and/or Active Function:  All names by which command/AF may be invoked (eg, list, ls)
			          - names in a comma-separated list (eg, NAME1, NAME2, ..., NAMEn)
			          - names ordered by length, with longest names appearing first in list; but
				  if several commands share same info block, keep short name adjacent to 
				  corresponding long name (eg, LONG_NAME1, SHORT_NAME1, ..., LONG_NAMEn, SHORT_NAMEn).
			         EXCEPTIONS:
			          - :Info: hcom.add:  <iso_date>  hcom add operation
				    - For a Command/AF info describing operation variants (for a command that performs
				      many different operations), the following will differ from normal commands:
				       - header line content
				       - divider names
				       - Syntax as a...  content, etc.  
				      See Operations Format below.

    Subsystem Request/Active Request:  All names by which request/AR may be invoked (eg, stack, sk)
			          - names in a comma-separated list (eg, NAME1, NAME2, ..., NAMEn)
			          - names ordered by length, with longest names appearing first in list; but
				  if several commands share same info block, keep short name adjacent to 
				  corresponding long name (eg, LONG_NAME1, SHORT_NAME1, ..., LONG_NAMEn, SHORT_NAMEn).
			         EXCEPTIONS:
			          - A few subsystem Request/Active Request programs may support multiple operations,
				   just like command/AFs.  (See Operations Format below.)

                   Subsystem Summary:  2 words:  SUBSYSTEM_LONG_NAME Requests

                           IO Module:  3 words:  IO_MODULE_NAME I/O module

                        IO Operation:  3 words:  IO_MODULE_NAME OPERATION_LONG_NAME operation

                          IO Control:  3 words:  IO_MODULE_NAME CONTROL_LONG_NAME control

        Subsystem Topic/General Info:  No particular names or words expected, or compared with other names.

                     History Comment:  has no specific header line; usually doesn't have a real header, but
			         just begins with the :hcom: divider.
   ----------------------------------  ------------------------------------------------- */
%page;
/* -------------------------------------------------------------------------------------
   FUNCTION (continued):
	   Verify words in header line conform to special content guidelines for
	   programs that perform multiple operations (Operations Format).

   Operations Format -- for Commands and Requests:  

	   Command/AF/Request/AR programs that perform multiple operations document the 
	   calling sequence for each operation in a separate :Info: block within the 
	   info segment documenting that Command/AF/Request/AR.  Known examples include:
	      bj_mgr_call, command_usage_count, history_comment, io_call, 
	      library_descriptor, transaction_call, window_call, ls_request_server, 
	      mbuild_type, reconfigure, update_seg


    In Operations Format, the first command/AF info block contains sections like those 
    in the info segment for the history_comment command (hcom.info).  
    The block introducing the overall purpose and syntax of the history_comment command
    is used below as an example of Operations Format.

     - Operations Format Example #1: first block describes overall command/AF.

	:Info: history_comment: hcom:  1988-03-10  history_comment, hcom

	Syntax as an active function:
	   [hcom OPERATION PATH {args} {-control_args}]


	Syntax as a command:  hcom OPERATION PATH {args} {-control_args}


	Function:  adds, checks, displays, formats and updates software change
	history comments within a given source module.


	Arguments:
	OPERATION
	   designates the operation to be performed.  See "List of operations"
	   below.
	PATH
	   is the name of a source code program that requires history comments.
	   The language suffix must be included.
	args
	   are optional arguments appropriate to the particular operation being
	   performed.


	List of operations:
	   Information about each history comment operation may be obtained
	   by typing: help hcom.OPERATION
	add
	   adds a new history comment to a source program.
	add_field, af
	   add missing fields to an existing history comment.
	...
    
    Since the "List of operations" section gives both long and short names for each operation,
    verify_info uses that information to verify divider names and header content in the 
    subsequent info blocks describing a particular operation.



    In most command/AF/request/AR blocks, all the words in the header line must appear
    as names in the divider.  These same words (with .info suffix) appear on the 
    info segment itself.  However...

    For info blocks describing a particular operation of a multi-operation command, 
    different rules apply to:
     - header content, 
     - divider names, and
     - names on the info segment.
    These rules are part of "Operation Format".


    RULE for an :Info: block describing one particular operation:

      In Operations Format, each operation has its own info block describing 
      syntax for that particular operation.

       Operations Format - block header line (3 words):  SHORT_COMMAND_NAME LONG_OPERATION_NAME operation

            Use of this header signifies the info block is using the "Operation Format".


       Operations Format - block divider name(s) format:
        - short name of the command;
        - dot (.) separator; and 
        - long or short operation name for the operation being described.  

	  All long and short operation names (as given in the "List of operations" mentioned above)
	  should be given as one of the divider names.  


       Operations Format - Syntax as a... section(s) format:
            Syntax as a command: 
	     SHORT_COMMAND_NAME SHORT_OPERATION_NAME ... 

	  Syntax as an active function:
	    [SHORT_COMMAND_NAME SHORT_OPERATION_NAME ...] 

	  That is:
	    - short command/AF name;
	    - short operation name;
	    - arguments and control arguments.

       Operations Format - Arguments section:
            Includes the long and short forms of the operation name.
	  That's the only place in the per-operation info block where both long/short names
	  appear, so these operation names should not be omitted from the Arguments section.


     - Operations Format Example #2: subsequent block(s) describing one operation performed 
       by the command/AF.

	:Info: hcom.add_field: hcom.af:  1988-03-10  hcom add_field operation

	Syntax as a command:  hcom af path {comment_specs} {-control_args}


	Function:  inserts missing fields in selected comments.


	Arguments:
	add_field, af
	   the operation to be performed.
	PATH
	   is the name of a source code program that requires history comments.
	   The language suffix must be included.  An archive pathname may be
	   given.

   ------------------------------------------------------------------------------------- */
%page;
/* ------------------------------------------------------------------------------------- 
   Operations Format for I/O Modules:

    I/O Modules also use operations format to describe each of their setup operations that
    accept a description-style argument:  attach, open_file, close_file, detach


   IO_Module Header and Sections:

    The following example from mtape_ shows layout and content of the main info block for
    an I/O module, called the IO_Module info block.  Note the following items:

     - Block divider name: giving the I/O module name.
     - Block heading line: names the I/O module.
     - Use of two Syntax... sections: 
        - one showing attach via the io_call command; 
        - second showing syntax of the attach description argument to iox_$attach_iocb.
     - Arguments and Control arguments: describing elements of the attach description
       for this I/O module.
     - List of opening modes section: shows which iox_ opening modes are supported by 
       this I/O module.
     - List of operations section: list which of the iox_ setup operations (iox_$open_file, 
       iox_$close_file and iox_$detach) are supported by I/O Module.  each of these 
       operations requires a description string argument.
         (triggers Operations Format for describing each supported operation)
     - List of i/o operations section: shows which iox_ operations are supported by
       this I/O module.
     - List of controls section: shows control orders given in an iox_$control call
       are supported by this I/O module. 
         (triggers Operations Format for describing each control order)


     - Operations Format Example #3: description of an I/O module using Operation Format

	:Info: mtape_:  1988-04-12  mtape_ I/O module

	Syntax as a command:
	  io_call attach SWITCH_NAME mtape_ VOLUME_SPECs {-control_args}


	Syntax of attach description:
	  mtape_ VOLUME_SPECs {-control_args}


	Function:  The mtape_ I/O module supports I/O to/from ANSI standard and
	IBM standard labeled, unlabeled and DOS formatted tape volumes.


	Arguments:
	 (arguments in the attach description)


	Control arguments:
	 (control args in the attach description)

	...

	List of opening modes:
	   The following I/O opening modes are supported by mtape_.
	sequential_input
	sequential_output


	List of operations:
	   mtape_ uses the following I/O setup operations.  For details on any
	   operation, type: help mtape_.OPERATION

	open_file, open
	   opens an mtape_ I/O switch for reading or writing a file from the
	   attached volume set.
	close_file, close
	   closes an mtape_ I/O switch to end operations on the current file.
	detach, detach_iocb
	   detaches an mtape_ I/O switch to end operations on the volume set.


	List of i/o operations:
	   The following iox_ operations are supported by mtape_.  For
	   details about any operation, type: help iox_$OPERATION
	read_record
	   read records from an mtape_ file, when opened for sequential_input.
	write_record
	   write records to an mtape_ file, when opened for sequential_output.
	position
	   accepts all types of positioning when the I/O switch is open
	   for sequential_input except type 3 (which is for stream_input
	   only).
	control
	   execute a special mtape_ operation.  See "List of controls" below.


	List of controls:
	   The following control orders are supported by mtape_.  For details
	   about any control order, refer to the mtape_ I/O module description
	   in the manual: Multics Subroutines and I/O Modules (AG93).

	file_status, fst
	   returns a pointer to a structure that contains the status of
	   the current file specified by the open description.  File
	   attribute as well as error summary information is included.
	   The format of the structure returned is defined by the
	   "mtape_fst" structure which can be found in the include file
	   "mtape_file_status.incl.pl1".  If the pointer is given as
	   null, then mtape_ will allocate the structure for the user.

	 ...
                   ------------------------------


    An I/O Module that supports one or more of the setup operations includes a
    per-operation info block describing each setup operation.  This kind of block
    is called an IO_Operation block.  It describes each details of the setup
    operation and its description string.

    The example below shows the IO_operation block describing the mtape_ operations: 
       close_file, close

      NOTE: mtape_supports both close_file and close setup operations.  Both
        are documented in a single IO_Operation info block, since the description-less
        close operation is implemented by calling iox_$close_file with an empty string
        as the close description.  This uses default values for all close control arguments.
        The Function section notes this implementation of the close operation.

     Note the following items:

       - Block divider name(s): giving 
	 IO_MODULE_NAME.SETUP_OP_NAME: IO_MODULE_NAME.ALTERNATE_SET_OP_NAME:
       - Block heading line (3 words): 
	 IO_MODULE_NAME SETUP_OP_NAME operation
       - Use of two Syntax... sections: 
	- one showing setup operation via the io_call command; 
	- second showing syntax of the setup's description argument in this case
	  given as an argument to iox_$close_file).
       - Control arguments: describing elements of the close description
         for this I/O module.


     - Operations Format Example #4: an I/O Operation block describing one setup operation 
       implemented by the I/O module.

	:Info: mtape_.close_file: mtape_.close:  2020-06-17  mtape_ close_file operation

	Syntax as a command:
	   io_call close_file SWITCH_NAME {-control_args}


	Syntax of close description:
	   {-control_args}


	Function:
	Closing a file is accomplished by calling the iox_$close_file
	entry which accepts as one of its arguments a character string
	"close description".  The close description supplies close option
	information to the selected per-format module.

	The iox_$close entry is also supported.  It passes an empty string
	description to the close_file entry, thereby applying default close
	description values.


	Control arguments:
	-close_position STR, -cls_pos STR
	   specifies where to physically position the tape volume
	   within the bounds of the file that is being closed.  The
	   values of STR are case insensitive and may be selected from
	   "bof" (for beginning of file), "eof" (for end of file) and
	   "leave" to leave the tape positioned where it is.  (Default
	   close position is "leave".)

                   ------------------------------


     An I/O Module that does not support open_file, close_file and detach (operations
     that take a description argument) can omit the "List of operations" section, and
     instead include the description-less equivalents in their "List of i/o operations"
     section.  

     - Operations Format Example #5: an I/O Module block describing no setup operations
       implemented by the I/O module.  The open, close, and detach_iocb are listed as
       operations in the "List of i/o operations" section.

       The vfile_ IO_Module info block shows how this is done:

	:Info: vfile_:  1987-07-03  vfile_ I/O Module

	Syntax as a command:
	   io_call attach SWITCH_NAME vfile_ path {-control_args}


	Syntax of attach description:
	   vfile_ path {-control_args}
	...


	List of i/o operations:
	   The following iox_ operations are supported by mtape_.  For
	   details about any operation, type: help iox_$OPERATION
	open
	get_chars
	get_line
	put_chars
	read_record
	write_record
	rewrite_record
	delete_record
	seek_key
	read_key
	read_length
	position
	control
	close
	detach_iocb

                   ------------------------------


    An I/O module that wants to include detailed documentation for its control orders
    may list those orders in a "List of control operations" section, and provide an
    IO_Control info block for each control operation.  An example from the vfile_
    IO_Module info block is shown below.  

      Note that only the io_call control interface implements the long name (add_key) and
        short name (ak) for the add_key control order; the long name must be given when 
        calling iox_$control.


     - Operations Format Example #6: an I/O Module block showing how to trigger use
       of Operations Format for certain control orders implmented by the I/O module.

	:Info: vfile_:  1987-07-03  vfile_ I/O module
	...

	List of control operations:
	   vfile_ supports the following control operations.  For details on any
	   operation, type: help vfile_.OPERATION
	add_key, ak
	   creates a new index entry with a given key and record descriptor.
	delete_key, dk
	   deletes a specified index entry.
	...


    An IO_Control info block documents each such control operation.  An example from
    vfile_ is shown below.

     Note the following items:

       - Block divider name(s): giving 
	 IO_MODULE_NAME.ORDER_LONG_NAME: IO_MODULE_NAME.ORDER_SHORT_NAME:
       - Block heading line (3 words): 
	 IO_MODULE_NAME ORDER_LONG_NAME operation
       - Control order section: giving ORDER_LONG_NAME, ORDER_SHORT_NAME
         plus a brief description of the control order.
       - First of two Syntax... sections: 
	- showing use of the control order via iox_$control subroutine;
       - Arguments for iox_$control: describing arguments passed to the 
         iox_$control subroutine for this control order.
       - List of elements section: describing each element of the structure
         pointed to by the info_ptr argument.
       - Section Syntax... section:
	- showing use of the control order via io_call command.
       - Arguments for io_call: describing arguments that may be given to
         io_call to fill ing the ak_info structure elements.


     - Operations Format Example #7: an I/O Control block showing how to trigger use
       of Operations Format for describing a given control order.

	:Info: vfile_.add_key: vfile_.ak:  1987-07-03  vfile_ add_key control


	Control order:  add_key, ak
	Creates a new index entry with a given key and record descriptor.

	The I/O switch must be open for direct_output, direct_update,
	keyed_sequential_output, or keyed_sequential_update.  Current and
	next record positions are unchanged.


	Syntax:
	   call iox_$control (iocb_ptr, "add_key", info_ptr, code);
        

	Arguments for iox_$control:
	iocb_ptr
	   points to the I/O Control Block (IOCB) describing the I/O switch
	   receiving the control order. (Input)
	file_status, fst
	   is the name of the current control order. (Input)	


	info_ptr
	   points to the following structure. (Input)

	  dcl 1 ak_info          based (info_ptr),
	      2 flags            aligned,
	        3 input_key      bit(1) unal,
	        3 input_desc     bit(1) unal,
	        3 mbz            bit(34) unal,
	      2 descrip          fixed bin(35),
	      2 key_len          fixed bin,
	      2 key              char(256 refer(ak_info.key_len));


	code
	   May be one of the following:
	     error_table_$key_duplication
	     error_table_$too_many_refs
	     error_table_$no_key


	List of elements:
	input_key
	   indicates whether the new key is given in the info 
	   structure. (Input)
	input_desc
	   indicates whether the new descriptor is given in the info 
	   structure. (Input)
	descrip
	   is used only if the variable input_descrip is set to "1"b.
	   The descriptor is stored into the index together with its
	   associated key. (Input)
	key_len
	   is the length of the key_string. (Input)
	key
	   is used only if ak_info.input_key is set to "1"b.  It defines 
	   the key to be added to the index with the appropriate record 
	   descriptor. (Input)
	mbz
	   must be set to zero by the user. (Input)


	Syntax as a command:
	   io_call control SWITCH_NAME ak {flags} key {descrip}


	Arguments for io_call:
	control
	   is the operation being performed.
	SWITCHNAME
	   is the name of an I/O switch attached to the mtape_ I/O module.
	add_key, ak
	   the control order being performed.
	flags
	   is a string of two bits corresponding to the switch
	   settings for input_key and input_descrip.  If one argument is
	   given, it is interpreted as a key to be added to the current
	   record, i.e., flags defaults to "10"b
	key
	   is a character string that must be given if flags.input_key is set.
	descrip
	   is an octal descriptor that must be supplied if flags.input_descrip 
	   is set.  This descriptor is stored in ak_info.descrip.

   ------------------------------------------------------------------------------------- */
%page;
check_header_line_words:
     proc();
     
  dcl  wdI fixed bin;				/* Index into Blok_words array		        */
  dcl (names_no_matchS, order_no_matchS) bit(1) unal;	/* Flags used for name comparison.		        */
  dcl  subr_header char(100) var;
     
     ListP = null();				/* Before 1st block, no command/request performing        */
						/*  "List of operations:" has been found.	        */
BLOCK_HEADERS:
     do iBlokP = iFile.bloks.firstP			/* Walk through list of blocks.		        */
	repeat iBlok.nextP  while (iBlokP ^= null() );
	goto HEADER_CONTENT(iBlok.kind);
	
HEADER_CONTENT (iBlok_kind_SUBROUTINE_INTRO):		/* Subroutine intro header line must be: 	        */
HEADER_CONTENT (iBlok_kind_SUBROUTINE_BRIEF_INTRO):	/*   ISO_DATE  REF_NAME_			        */
	if  iBlok.header.wordN >= 1  then do;
	     subr_intro_refname = Blok_words(1);	/*  - Get REF_NAME_ for checks of SUBROUTINE_ENTRY header */
	     if  all_unique (Blok_words)    &  descending_lengths (Blok_words)  &
	         all_REF_NAME_ (Blok_words) &
	         source_matches_each_WORD_regex (iBlok.header.rest, "\(STR), |\(STR)$", Blok_words)  then;
						/* - substitute Blok_word elements as STR 	        */
	     else  iBlok.bad_subr_intro_headerS = T;
	     end;
	else  iBlok.bad_subr_intro_headerS = T;
	goto HC_NEXT_BLOCK;

HEADER_CONTENT (iBlok_kind_SUBROUTINE_ENTRY):		/* Subroutine entrypoint header line must be:	        */
	if  subr_intro_refname = ""  then;		/*   ISO_DATE  REF_NAME_$ENTRYPOINT  or  REF_NAME_        */
	else if  iBlok.header.wordN >= 1 then do;
	     if  all_unique( Blok_words )  &  all_REF_NAME_$EP_NAME( Blok_words )  &
	         each_word_matches_STR_regex( Blok_words, "^\(STR)$|^\(STR)\$", subr_intro_refname )  then;
						/* - substitute subr_intro_refname as STR	        */
	     else do;
		iBlok.bad_subr_headerS = T;		/*    - If header line bad, recommend a better version    */
		subr_header = "";
		do wdI = lbound(Blok_words,1) to hbound(Blok_words,1);
		     if  Blok_words(wdI) = subr_intro_refname  then
			subr_header = subr_header || subr_intro_refname;
		     else if  index(Blok_words(wdI), DOLLAR_SIGN) = 0  then 
			subr_header = subr_header || subr_intro_refname || DOLLAR_SIGN || Blok_words(wdI);
		     else if  after(Blok_words(wdI), DOLLAR_SIGN) = subr_intro_refname  then
			subr_header = subr_header || subr_intro_refname;
		     else subr_header = subr_header || subr_intro_refname || DOLLAR_SIGN || 
			after(Blok_words(wdI), DOLLAR_SIGN);
		     if  wdI < hbound(Blok_words,1)  then
			subr_header = subr_header || COMMA_SP;
		     end;
		iBlok.rest = subr_header;
		end;
	     if  ^all_entrypoints_exist( Blok_words )  then
		iBlok.bad_subr_epS = T;
	     end;
	else  iBlok.bad_subr_headerS = T;
	goto HC_NEXT_BLOCK;	

HEADER_CONTENT (iBlok_kind_COMMAND_AF):
HEADER_CONTENT (iBlok_kind_COMMAND):
HEADER_CONTENT (iBlok_kind_ACTIVE_FUNCTION):
HEADER_CONTENT (iBlok_kind_REQUEST_AR):
HEADER_CONTENT (iBlok_kind_REQUEST):
HEADER_CONTENT (iBlok_kind_ACTIVE_REQUEST):
	if  iBlok.syntax.is_operationS  then		/* - Block describes one op of a multi-op command/req?    */
						/*   It's header already validated during parse via       */
						/*   info_seg_util_$identify_per_operation_blocks()       */
	if  info_seg_util_$is_operation_format_block( iBlokP, Operation_ListP, Operation_ListI)  then do;

	     do iSectP = iBlok.sects.firstP		/*   Verify "List of operations" names same as in this    */
		repeat iSect.sib.nextP		/*   block's "Arguments" section.		        */
		while ( iSectP ^= null() );
		if  is_Arguments_type(iSect.type)  &
		    iSect.relatives.listP ^= null()  then do;

		     ListP = iSect.relatives.listP;	/*   Examine items in Arguments section.	        */
		     do ListI = lbound(List.items,1) to hbound(List.items,1);
						/*    - If item names match value/order of operation      */
						/*      names, there is no error.		        */
			call compare_names( operation_names, List_item_names, NO_REF_NAME_,
			     names_no_matchS, order_no_matchS);
			if  ^(names_no_matchS | order_no_matchS)  then
			     goto HC_NEXT_BLOCK;	/*  operation_names were found in Arguments item.	        */
			end;			/*  So far, item dimension or name values don't match.    */
		     iSect.display_listS = T;
		     end;
		end;
	     iBlok.multi_op_Arguments_missing_op_namesS = T;
	     goto HC_NEXT_BLOCK;			/* All items in all Arguments sections examined, but      */
	     end;					/*  operation_names were not found.		        */

	if  iBlok.header.wordN >= 1 then do;		/* For non-operation-format blocks...		        */
	     if  all_unique (Blok_words)  &  descending_lengths (Blok_words)  &
	         all_REF_NAME_ (Blok_words) &
	         source_matches_each_WORD_regex (iBlok.header.rest, "\(STR), |\(STR)$", Blok_words)  then;
						/* - substitute Blok_word elements as STR 	        */
	     else  iBlok.bad_cmd_af_req_headerS = T;
	     end;
	else  iBlok.bad_cmd_af_req_headerS = T;
	goto HC_NEXT_BLOCK;	


HEADER_CONTENT (iBlok_kind_IO_MODULE):			/* Block has "Syntax as attach description" section, but  */
          if  dim(Blok_words,1) = 3  then		/*  must check block header content:		        */
	if  Blok_words(2) = "I/O"  &			/*     IO_MODULE_NAME I/O module		        */
	    Blok_words(3) = "module"  then
	if  entrypoint_exists( Blok_words(1) || DOLLAR_SIGN || Blok_words(1) || IO_MODULE_attach_EP_SUFFIX )  then do;
	     io_module_refname = Blok_words(1);		/*  An I/O module must always provide an attach	        */
     	     goto HC_NEXT_BLOCK;			/*  entrypoint as in:  vfile_$vfile_attach	        */
	     end;
	iBlok.bad_io_module_headerS = T;
	goto HC_NEXT_BLOCK;

HEADER_CONTENT (iBlok_kind_IO_OPERATION):
	if  iBlok.syntax.is_operationS  then		/* - Block describes one setup operation of an I/O Module.*/
						/*   It's header already validated during parse via       */
						/*   info_seg_util_$identify_per_operation_blocks()       */
	if  info_seg_util_$is_operation_format_block( iBlokP, Operation_ListP, Operation_ListI)  then do;

	     do iSectP = iBlok.sects.firstP		/*   Verify "List of operations" names same as	        */
		repeat iSect.sib.nextP		/*   in this block's "Arguments for io_call" section.     */
		while ( iSectP ^= null() );
		if  iSect.type = iSect_ARGUMENTS_FOR_IO_CALL  &
		    iSect.relatives.listP ^= null()  then do;

		     ListP = iSect.relatives.listP;	/*   Examine items in  Arguments for io_call  section.    */
		     do ListI = lbound(List.items,1) to hbound(List.items,1);
						/*    - If item names match value/order of operation      */
						/*      names, there is no error.		        */

			call compare_names( operation_names, List_item_names, NO_REF_NAME_,
			     names_no_matchS, order_no_matchS);
			if  ^(names_no_matchS | order_no_matchS)  then
			     goto HC_NEXT_BLOCK;	/*  operation_names were found in Arguments item.	        */
			end;			/*  So far, item dimension or name values don't match.    */
		     iBlok.multi_op_Arguments_missing_op_namesS = T;
		     iSect.display_listS = T;
		     end;
		end;

     	     goto HC_NEXT_BLOCK;
	     end;
	iBlok.multi_op_name_not_listedS = T;		/* Arrive here for an IO_OPERATION without main info      */
						/*    having a "List of operations" section containing    */
						/*    this operation name.  This is an error.	        */

          if  dim(Blok_words,1) = 3  then		/*  must check block header content:		        */
	if  Blok_words(1) = io_module_refname then	/*     IO_MODULE_NAME OPERATION_NAME module	        */
	if  Blok_words(3) = "operation"  then
     	     goto HC_NEXT_BLOCK;
	iBlok.bad_io_module_headerS = T;
	goto HC_NEXT_BLOCK;

HEADER_CONTENT (iBlok_kind_IO_CONTROL):
	if  iBlok.syntax.is_controlS  then		/* - Block describes one control of multi-control I/O Mod */
						/*   It's header already validated during parse via       */
						/*   info_seg_util_$identify_per_control_blocks()	        */
	if  info_seg_util_$is_control_format_block( iBlokP, Operation_ListP, Operation_ListI)  then do;

	     					/* Check name list on "Control order" section 1st line.   */
						/*    Control order:  add_key, ak		        */
						/* That namelist should match operation_names array.      */

	     iSectP = iBlok.sects.firstP;		/* IO_Control begins with section: "Control order"        */
	     NamesP = get_control_order_names();	/*  - Get names from 1st line of this section.	        */
						/*    NB: This call can set: iSect.control_order_bad_listS*/
						/*        if 1st line has unexpected format.	        */
	     if  dim(Names.nm,1) > 0  then do;
		call compare_names( operation_names, Names.nm, NO_REF_NAME_,
		     names_no_matchS, order_no_matchS); /*  - Are all names present, in same order as in the      */
						/*    main info block "List of control operations" list?  */
		if  (names_no_matchS | order_no_matchS)  then do;
		     iSect.control_order_bad_name_orderS = T;
		     Operation_List.parentSectP->iSect.display_listS = T;
		     end;				/*     - Show "List of control operations" section names  */

		end;

	     do iSectP = iSect.sib.nextP		/*   Verify "List of control operations" names same as    */
		repeat iSect.sib.nextP		/*   in this block's "Arguments for io_call" section.     */
		while ( iSectP ^= null() );
		if  iSect.type = iSect_ARGUMENTS_FOR_IO_CALL  &
		    iSect.relatives.listP ^= null()  then do;

		     ListP = iSect.relatives.listP;	/*   Examine items in  Arguments for io_call  section.    */
		     do ListI = lbound(List.items,1) to hbound(List.items,1);
						/*    - If item names match value/order of operation      */
						/*      names, there is no error.		        */
			call compare_names( operation_names, List_item_names, NO_REF_NAME_,
			     names_no_matchS, order_no_matchS);
			if  ^(names_no_matchS | order_no_matchS)  then
			     goto HC_NEXT_BLOCK;	/*  operation_names were found in Arguments item.	        */
			end;			/*  So far, item dimension or name values don't match.    */
		     iBlok.multi_op_Arguments_missing_op_namesS = T;
		     iSect.display_listS = T;
		     end;
		end;
	     goto HC_NEXT_BLOCK;
	     end;
	iBlok.multi_op_name_not_listedS = T;		/* Arrive here for an IO_CONTROL without main info        */
						/*    having a "List of control operations" section       */
						/*    containing this operation name.  This is an error.  */

          if  dim(Blok_words,1) = 3  then		/*  must check block header content:		        */
	if  Blok_words(1) = io_module_refname then	/*     IO_MODULE_NAME CONTROL_ORDER_NAME control	        */
	if  Blok_words(3) = "control"  then
     	     goto HC_NEXT_BLOCK;
	iBlok.bad_io_module_headerS = T;
	goto HC_NEXT_BLOCK;
	
	

HEADER_CONTENT (iBlok_kind_HISTORY_COMMENT):
	iBlok.missing_headerS = F;			/* History comment SHOULD have no header words.	        */
	if  iBlok.divider = iBlok_divider_hcom_obsolete  then do;
	     iBlok.obsolete_dividerS = T;		/* Diagnose use of :Internal: instead of :hcom:	        */
	     string(iBlok.header.reformatted) = "";
	     end;
	goto HC_NEXT_BLOCK;

HEADER_CONTENT (iBlok_kind_GENERAL_INFO):		/* Skip checking GENERAL_INFO segs, but old form of       */
	if  dim(Blok_words,1) = 1  then		/*  history comment can look like a GENERAL_INFO if       */
						/*  divider word was :Info: instead of :Internal:	        */
	if  index(Blok_words(1), "history_comment") > 0  then do;
	     iBlok.obsolete_dividerS = T;
	     iBlok.bad_divider_namesS = T;		/*  NOW: :Info: should be :hcom:		        */
	     string(iBlok.header.reformatted) = "";	/*        and heading should be empty.		        */
	     end;
	goto HC_NEXT_BLOCK;				/*  Report this as a possible divider names issue.        */

HEADER_CONTENT (iBlok_kind_SUBSYSTEM_SUMMARY):		/* No checks on header content/format for these blocks    */
HEADER_CONTENT (iBlok_kind_SUBSYSTEM_TOPIC):
HEADER_CONTENT (iBlok_kind_Header_Only):
HEADER_CONTENT (iBlok_kind_Unknown):
HC_NEXT_BLOCK:
	end BLOCK_HEADERS;

     end check_header_line_words;
%page;
/* -----------------------------------------------------------------
   INTERNAL SUBROUTINE:  check_subr_header_dates

   FUNCTION:  verify subroutine header line date consistency with...

     RULE:  subroutine_intro_date >= max( entrypoint_date... )

   For an info segment documenting a group of subroutine entrypoints, 
   the introduction (first block of the segment) must have a header line
   naming the overall subroutine.  The date in this header line must change
   whenever one of the subroutine entrypoint (:Entry:) blocks changes.
   This enables the check_info_segs command to determine that the subroutine
   info segment has changed in some way.
   ----------------------------------------------------------------- */

check_subr_header_dates:
     proc();

     if  iFile.structure = iFile_structure_INFO_SUBROUTINE_HCOM |
         iFile.structure = iFile_structure_INFO_SUBROUTINE      |
         iFile.structure = iFile_structure_SUBROUTINE           then do;
						/* First block of info segment is the introduction.       */
						/* Blocks 2 thru last (or last-1 if there is a history    */
						/* comment) document subroutine entrypoints.	        */
						/* This block organization was verified when determining  */
						/* file structure.				        */

	do iBlokP = iFile.bloks.firstP -> iBlok.nextP	/* Find newest entrypoint block in info segment, 	        */
						/*  starting with block 2.			        */
	     repeat iBlok.nextP  while (iBlokP ^= null());
	     if  iBlok.kind = iBlok_kind_SUBROUTINE_ENTRY  then do;
		if  iBlok.missing_dateS  |  iBlok.bad_dateS  then;
						/*  - No date to compare with subroutine_intro_date       */
		else if  iBlok_newest_epP = null()  then
		     iBlok_newest_epP = iBlokP;	/*  - Save first valid entrypoint iBlokP for comparisons  */
		else if  iBlok.iso_date > iBlok_newest_epP-> iBlok.iso_date  then
		     iBlok_newest_epP = iBlokP;	/*  - Current entrypoint date more recent than prior      */
						/*    blocks?  Save that iBlokP.		        */
		end;
	     end;

	iBlokP = iFile.bloks.firstP;			/* Get pointer to subroutine intro block.	        */
	if  iBlok_newest_epP ^= null()  then
	if  iBlok.kind = iBlok_kind_SUBROUTINE_INTRO       |      /* superfluous test: kind already verified when   */
	    iBlok.kind = iBlok_kind_SUBROUTINE_BRIEF_INTRO  then  /* determining file structure.  Test to ensure.   */
	if ^(iBlok.missing_dateS  |  iBlok.bad_dateS)  then       /* Hopefully, intro block has a valid date.       */
	if  iBlok.iso_date < iBlok_newest_epP-> iBlok.iso_date  then do;
						/*  - Intro date older than most recent entrypoint date?  */
	     iBlok.older_subr_intro_dateS = T;		/*     - Remember this error in the intro date block.     */
	     iBlok.iso_date = iBlok_newest_epP-> iBlok.iso_date;
						/*     - Record minimum required date as block's iso_date */
						/*       as recommended date in the error message.        */
	     end;
	if  ^iBlok.older_subr_intro_dateS  then		/* Make sure newest entrypoint's header is not displayed  */
	     iBlok_newest_epP = null();		/*  if this error was NOT detected.		        */
	end;

     end check_subr_header_dates;
%page;
/* -----------------------------------------------------------------
   INTERNAL SUBROUTINE:  check_subr_intro_sections

   FUNCTION:  if subroutine info has an intro block, check whether it
	    has an "Entry points in ..." section, and contents of 
	    that section.

     RULE:  Title of "Entry points in ..." section ends with SUBROUTINE_REFNAME_
     RULE:  Content of "Entry points in ..." section is constant:
               "   (List is generated by the help command.)"

   For an info segment documenting a group of subroutine entrypoints, 
   the introduction (first block of the segment) must have a header line
   naming the overall subroutine.  The date in this header line must change
   whenever one of the subroutine entrypoint (:Entry:) blocks changes.
   This enables the check_info_segs command to determine that the subroutine
   info segment has changed in some way.
   ----------------------------------------------------------------- */

check_subr_intro_sections:
     proc();

  dcl  section_title_words char(71) var;

     if  iFile.structure = iFile_structure_INFO_SUBROUTINE_HCOM |
         iFile.structure = iFile_structure_INFO_SUBROUTINE      |
         iFile.structure = iFile_structure_SUBROUTINE           then do;
						/* First block of info segment is the introduction.       */
						/* Blocks 2 thru last (or last-1 if there is a history    */
						/* comment) document subroutine entrypoints.	        */
						/* This block organization was verified when determining  */
						/* file structure.				        */

	iBlokP = iFile.bloks.firstP;			/* Does subroutine intro block have "Entry points in ..." */
	do iSectP = iBlok.relatives.sects.firstP	/*  section?				        */
	     repeat iSect.sib.nextP  while (iSectP ^= null() );
	     if  iSect.type = iSect_ENTRY_POINTS_IN  then
		goto CHECK_SUBR_ENTRY_POINTS_IN_CONTENTS;
	     end;
	return;


CHECK_SUBR_ENTRY_POINTS_IN_CONTENTS:			/* If "Entry points in REFNAME_" section appears, check   */
	section_title_words = iSect.title.should_be;	/*  its contents.				        */
	section_title_words = after(section_title_words, iSect_title.title(iSect.type));

	if  section_title_words ^= subr_intro_refname  then 
	     goto BAD_EP_IN;			/*  - Is correct subroutine refname_ given?	        */

	if  info_seg_util_$count_section_lines(iSectP) ^= 2  then 
	     goto BAD_EP_IN;			/*  - Does it contain correct placeholder line, to        */
						/*    indicate in dprinted info seg what help would be    */
	iLineP = iSect.relatives.lines.firstP;		/*    printing?				        */
	if  after(Line, iSect.title.in_file) ^= COLON  then
	     goto BAD_EP_IN;
	iLineP = iLine.sibs.sect.nextP;
	if  ltrim(rtrim(Line)) ^= INFO_SUBROUTINE_INTRO_ENTRY_POINTS_IN_CONTENTS  then
	     goto BAD_EP_IN;

	if  index(Line, INFO_LINE_INDENT) ^= 1  then
	     goto BAD_EP_IN;
	return;

BAD_EP_IN:
	iSect.bad_entry_points_inS = T;
	end;

     end check_subr_intro_sections;
%page;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* SUBROUTINES:  Prepare to handle Operation Format as a command/AF/Request/AR variant.	        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* --------------------------------------------------------------------------------
   SUBROUTINE:  names_for_current_operation

   Function:  Construct names to appear in :Info: divider for block describing one
              operation of a multi-op command/request.  These names (with .info suffix)
	    also should appear on info segment for a command/AF.

   Requirement: Names have form:  SHORT_COMMAND_REQ_NAME.OPERATION_NAME

   References:  Operation_ListP describing operations of the multi-op command/request.

	      Operation_ListI identifying Operation_List.items(ListI) for operation
	      described by current block.
   -------------------------------------------------------------------------------- */

names_for_current_operation:				/* Must be called after Operation_ListP and 	        */
     proc() returns (ptr);				/*  Operation_ListI have been set via 		        */
						/*  info_seg_util_$is_operation_format_block	OR      */
						/*  info_seg_util_$is_control_format_block	        */

  dcl  opNameI fixed bin;				/* Index into operation_names array.		        */

     iName10.N = 0;
     
     do opNameI = lbound(operation_names,1) to hbound(operation_names,1);
	iName10.N = iName10.N + 1;
	iName10.nm(iName10.N) = Operation_List.blok_name || "." || operation_names(opNameI);
	end;
     return (addr(iName10));

     end names_for_current_operation;

%page;
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* UTILITIES:  Error Instance collection data structures and routines.		        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

  dcl 1 eLine aligned based,				/* Structure defining a line number array for lines with  */
      2 N fixed bin,				/* a particular type of error.		        */
      2 actualN fixed bin,
      2 line_in_file (50) fixed bin;			/*  - Line numbers having this error. 		        */

  dcl 1 eLerr aligned,				/* Structure for eLine substructure per line error type.  */
      2 (all_whitespace,				/*  - Line contains only whitespace chars.	        */
         ends_whitespace,				/*  - Line contains non-whitespace chars, but ends with 
						/*    whitespace chars.			        */
         overlength,				/*  - Line length exceeds INFO_CHARS_PER_LINE.	        */
         backspace,					/*  - Line contains BS (backspace) characters.	        */
         unprintable				/*  - Line contains characters not in INFO_PRINTABLE.     */
         ) like eLine;

  dcl 1 ePerr aligned,				/* Structure for eLine substructure per pgh error type.   */
      2 (long_paragraph,				/*  - iPgh.line_count >INFO_LINES_PER_PARAGRAPH	        */
         few_blank_lines_before_paragraph,		/*  - pgh preceded by <INFO_BLANK_LINES_BEFORE_PARAGRAPH  */
						/*    blank or all-white lines.		        */
         many_blank_lines_before_paragraph		/*  - pgh preceded by >INFO_BLANK_LINES_BEFORE_PARAGRAPH  */
         ) like eLine;

  dcl 1 eSerr aligned,				/* Structure for eLine substructgure per sect error type. */
      2 (unrecognized_title				/*  - Section title not known to info_seg_.	        */
         ) like eLine;

  dcl 1 Lerr aligned based (LerrP),			/* Overlay for one eLine structure giving access to the   */
      2 N fixed bin,				/*  filled-in portion of the array.		        */
      2 actualN fixed bin,
      2 no (0 refer (Lerr.N)),
     LerrP ptr;

collect_block_line_errors:				/* Collect line numbers of blocks in which particular     */
     proc (AeLP, AiBlokP);				/*  errors have been detected.		        */

  dcl  AeLP ptr;
  dcl  AiBlokP ptr;

  dcl 1 eL aligned like eLerr based(AeLP);

     do iLineP = AiBlokP->iBlok.lines.firstP
          repeat iLine.blok.nextP  while (iLineP ^= null() );

          if  iLine.all_whitespaceS   then call record_Lerror (addr(eL.all_whitespace),  addr(iLine));
          if  iLine.ends_whitespaceS  then call record_Lerror (addr(eL.ends_whitespace), addr(iLine));
          if  iLine.overlengthS       then call record_Lerror (addr(eL.overlength),      addr(iLine));
          if  iLine.backspaceS        then call record_Lerror (addr(eL.backspace),       addr(iLine));
          if  iLine.unprintableS      then call record_Lerror (addr(eL.unprintable),     addr(iLine));

          end;
     return;

record_Lerror:					/* Count and collect line number of one error instance.   */
          proc (ALerrorP, AiLineP);

  dcl  ALerrorP ptr;
  dcl  AiLineP  ptr;
     
  dcl 1 Lerror aligned like Lerr based (ALerrorP);

	Lerror.actualN = Lerror.actualN + 1;
	if  Lerror.N < hbound(ALerrorP->eLine.line_in_file,1)  then do;
	     Lerror.N = Lerror.N + 1;
	     Lerror.no(Lerror.N) = AiLineP->iLine.line_in_file;
	     end;

	end record_Lerror;
%page;
collect_block_paragraph_errors:			/* Collect line numbers of blocks in which particular     */
     entry (AePerrP, AiBlokP);			/*  errors have been detected.		        */

  dcl  AePerrP ptr;

  dcl 1 eP aligned like ePerr based(AePerrP);

     do iPghP = AiBlokP->iBlok.pghs.firstP
          repeat iPgh.blok.nextP  while (iPghP ^= null() );

	if  iPgh.long_paragraphS  then 
	if  iPgh.relatives.sectP->iSect.type ^= iSect_LIST_OF_REQUESTS  then
						/* Don't report over-length paragraphs in such sections   */
	     call record_Perror (addr(eP.long_paragraph),                    addr(iPgh));
          if  iPgh.few_blank_lines_before_paragraphS   then 
	     call record_Perror (addr(eP.few_blank_lines_before_paragraph),  addr(iPgh));
          if  iPgh.many_blank_lines_before_paragraphS  then 
	     call record_Perror (addr(eP.many_blank_lines_before_paragraph), addr(iPgh));
          end;
     return;

record_Perror:					/* Count and collect line number for one error instance.  */
          proc (ALerrorP, AiPghP);

  dcl  ALerrorP ptr;
  dcl  AiPghP  ptr;
     
  dcl 1 Lerror aligned like Lerr based (ALerrorP);

	Lerror.actualN = Lerror.actualN + 1;
	if  Lerror.N < hbound(ALerrorP->eLine.line_in_file,1)  then do;
	     Lerror.N = Lerror.N + 1;
	     Lerror.no(Lerror.N) = AiPghP->iPgh.line_in_file;
	     end;

	end record_Perror;
%page;
collect_block_section_errors:
     entry (AeSP, AiBlokP);

  dcl  AeSP ptr;

  dcl 1 eS aligned like eSerr based(AeSP);

     do iSectP = AiBlokP->iBlok.sects.firstP
	repeat iSect.nextP  while(iSectP ^= null() );
	if  iSect.unrecognized_titleS  then call record_Serror (addr(eS.unrecognized_title), addr(iSect));
	end;
     return;
     
record_Serror:					/* Count and collect line number of one error instance.   */
          proc (ALerrorP, AiSectP);

  dcl  ALerrorP ptr;
  dcl  AiSectP  ptr;
     
  dcl 1 Lerror aligned like Lerr based (ALerrorP);

	Lerror.actualN = Lerror.actualN + 1;
	if  Lerror.N < hbound(ALerrorP->eLine.line_in_file,1)  then do;
	     Lerror.N = Lerror.N + 1;
	     Lerror.no(Lerror.N) = AiSectP->iSect.line_in_file;
	     end;

	end record_Serror;


     end collect_block_line_errors;
%page;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* Name-related Subroutines:							        */
	/*									        */
	/* The following subroutines are called as internal procedures by info_seg_verify_iFile code.     */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


/* -----------------------------------------------------------------
   SUBROUTINE:  add_names

   FUNCTION:  Add one or more names to a given name list.
   ----------------------------------------------------------------- */

  dcl  add_names_error_printedS bit(1) aligned init(F);	/* Switch to limit number of need_names array ovf errors  */
  dcl  info_suffix char(5) int static options(constant) init("." || info_seg_suffix);

add_names:
     proc (Anames, Aadded_namesP);
     
  dcl  Anames (*) char(*) var;
  dcl  Aadded_namesP ptr;

  dcl 1 added_names aligned like iName300 based(Aadded_namesP);

  dcl  nmI fixed bin;
     
     do nmI = lbound(Anames,1) to hbound(Anames,1);
	if  ^valid_entryname( Anames(nmI) )  then;
	else if  added_names.N < hbound(added_names.nm,1)  then do;
	     added_names.N = added_names.N + 1;
	     added_names.nm(added_names.N) = Anames(nmI) || info_suffix;
	     end;
	else if  added_names.N = hbound(added_names.nm,1)  then do;
	     if  ^add_names_error_printedS  then
		call info_seg_error_ (AvidP, 5, "info_seg_verify_ added_names.nm overflow: too many block names." ||
					  "^/^- FILE: ^a>^a", iFile.dir, iFile.ent);
	     add_names_error_printedS = T;
	     return;
	     end;
	end;

valid_entryname:
	proc(Aname) returns (bit(1) aligned);             /* Rules taken from entryname.gi.info for a               */
                                                            /*   "reasonably valid entryname".                        */
  dcl  Aname char(*) var;

	if  length(Aname)  > 0  then
	 if  length(Aname) <= 32  then
	  if  verify(substr(Aname,1,1), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_") = 0  then
	   if  verify (Aname, " !&+-./0123456789:ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz^_~") = 0  then
	    if  index(Aname,"::") = 0  then
	     if  index(Aname,"..") = 0  then
	      if  substr(Aname, length(Aname), 1) ^=  "."  then
		return("1"b);
	return("0"b);

	end valid_entryname;

     end add_names;
%page;
/* -----------------------------------------------------------------
   SUBROUTINE:  compare_names

   FUNCTION:  Compare two name lists, reporting errors if:
	     - names in the two lists differ;
	     - names in the two lists have a different ordering.
   ----------------------------------------------------------------- */

  dcl  pl1_max_identifier_length init(256) int static options(constant);
						/* From: PL/I Language Specification AG94-02, p 2-5       */
  dcl 1 eNames aligned,
      2 N fixed bin,				/*  - number of array elements currently in use.	        */
      2 nm (10) char(pl1_max_identifier_length) var,	/*  - array holding names in the list.		        */
       entrypoint_names (eNames.N) char(pl1_max_identifier_length) var aligned based(addr(eNames.nm(1)));

compare_names:
     proc (desired_names, names, subr_ref_name, bad_names_errorS, order_names_errorS);

  dcl  desired_names (*) char(*) var;
  dcl  names (*) char(*) var;
  dcl  subr_ref_name char(*) var;
  dcl (bad_names_errorS, order_names_errorS) bit(1) unal;
     
  dcl (dnmI, nmI) fixed bin;
     
     order_names_errorS = F;				/* Assume names are in desired_names order.	        */
     if  dim(desired_names,1) ^= dim(names,1)  then do;	/* If counts differ, the two lists can't match.	        */
	bad_names_errorS = T;
	return;
	end;					/* NOTE: If lists are same length & some desired_names(I) */
						/*       is not matched, some name(I) is also not matched */

     bad_names_errorS = F;				/* Otherwise, start with assumption that the lists match  */

DESIRED_NAMES:
     do dnmI = lbound(desired_names,1) to hbound(desired_names,1);
	do nmI = lbound(names,1) to hbound(names,1);
	     if  subr_ref_name = NO_REF_NAME_  then do;
		if  desired_names(dnmI) = names(nmI)  then do;
NAMES_MATCH:	     if  dnmI ^= nmI  then
			order_names_errorS = T;
		     goto NEXT_DESIRED_NAME;
		     end;
		end;

	     else if  name_without_ref_name(desired_names(dnmI), subr_ref_name) = names(nmI)  then
		goto NAMES_MATCH;			/* subr_ref_name present 			        */
	     end;
	bad_names_errorS = T;			/* No name(nmI) matched desired_name(dnmI)	        */

NEXT_DESIRED_NAME:

	end DESIRED_NAMES;
     return;

/* -----------------------------------------------------------------
   SUBROUTINE:  get_entrypoint_names

   FUNCTION:  Given subroutine :Entry: header names, construct
	    entrypoint names that should appear in the divider list.
   ----------------------------------------------------------------- */


get_entrypoint_names:
     entry (desired_names, subr_ref_name);
     
     eNames.N = 0;
     
     do dnmI = lbound(desired_names,1) to min( hbound(desired_names,1), hbound(eNames.nm,1) );
	eNames.N = dnmI;
	if  desired_names(dnmI) = subr_ref_name  then
	     eNames.nm(dnmI) = name_without_ref_name(desired_names(dnmI), subr_ref_name);
	else if  index(desired_names(dnmI), subr_ref_name || DOLLAR_SIGN) = 1  then
	     eNames.nm(dnmI) = name_without_ref_name(desired_names(dnmI), subr_ref_name);
	else if  index(desired_names(dnmI), DOLLAR_SIGN) > 0  then
	     eNames.nm(dnmI) = subr_ref_name || DOLLAR_SIGN || after(desired_names(dnmI), DOLLAR_SIGN);
	else eNames.nm(dnmI) = subr_ref_name;
	end;
     return;
     

name_without_ref_name:
	proc (Aname, Aref_name) returns( char(72) var );

  dcl  Aname char(*) var;
  dcl  Aref_name char(*) var;

	if  index(Aname, Aref_name || DOLLAR_SIGN) = 1  then
	     return (after(Aname, DOLLAR_SIGN));
	return (Aname);

	end name_without_ref_name;

     end compare_names;
%page;
/* -----------------------------------------------------------------
   SUBROUTINE:  all_REF_NAME_

   FUNCTION:  Returns T if all header line words follow rules of
	    a subroutine or command/request reference name.
	    Note that PL/I reference names can be longer than 72,
	    but commands, requests, and subroutines are typically
	    limited to 32 chars (including the .info suffix).

     NOTE: 72 comes from max recommends info seg line length+1 to
	    detect over-length lines, words, etc.
   ----------------------------------------------------------------- */

all_REF_NAME_:
     proc (words) returns (bit(1) aligned);
     
  dcl  words (*) char(72) var;
  dcl (wdI, wdJ) fixed bin;

     do wdI = lbound(words, 1) to hbound(words, 1);	/* Return F if word(i) ^= <letter>[<letter>|<digit>|_]... */
	if  verify(substr(words(wdI),1,1), LETTERS) = 0 &
	    verify(words(wdI), LETTERS_DIGITS_UNDERSCORE) = 0 then;
	else if  word_ends(words(wdI), ".compin") then;	/* Accept header words in *.compin.info segs like	        */
						/*  arg_list.compin.info			        */
	else if  word_ends(words(wdI), ".ec") then;	/* Accept header words in *.ec.info segs like	        */
						/*  compare_pl1.ec.info			        */
	else if  iBlok.kind = iBlok_kind_REQUEST &	/* Special request names:  ?  ..  .		        */
	         verify(words(wdI), INFO_REQUEST_NAME_CHARS) = 0  then;
	else  return (F);
	end;
     return (T);


/* -----------------------------------------------------------------
   SUBROUTINE:  all_REF_NAME_$EP_NAME

   FUNCTION:  Returns T if all header line words are valid
	    subroutine REF_NAME_$EP_NAME constructs.
   ----------------------------------------------------------------- */

all_REF_NAME_$EP_NAME:
     entry (words) returns (bit(1) aligned);

     do wdI = lbound(words, 1) to hbound(words, 1);	/* Return F if word ^= <letter>[<letter>|<digit>|_|$]...  */
	if  ^is_REF_NAME_ (words(wdI))  then		/*  and entrypoint not found by cv_entry_	        */
	     return (F);
	end;
     return (T);


/* -----------------------------------------------------------------
   SUBROUTINE:  all_entrypoints_exist

   FUNCTION:  Returns T if all header line words are findable
	    by cv_entry_.
   ----------------------------------------------------------------- */

all_entrypoints_exist:
     entry (words) returns (bit(1) aligned);
     
  dcl  code fixed bin(35);
  dcl  valid_entry entry variable;

     do wdI = lbound(words, 1) to hbound(words, 1);	/* Return F if any word not findable by cv_entry_	        */
	if ^entrypoint_exists( (words(wdI)) ) then
	     return (F);
	end;
     return (T);


/* -----------------------------------------------------------------
   SUBROUTINE:  all_unique

   FUNCTION:  Returns T if all input words are unique (do not duplicate
	    any other word in the list).
   ----------------------------------------------------------------- */

all_unique:
     entry (words) returns (bit(1) aligned);

     if  dim(words,1) = 1  then			/* Only 1 word?  It's unique.			        */
	return (T);

     do wdI = lbound(words, 1) to hbound(words, 1);	/* Return F if word(i) = word(j) for i ^= j	        */
	do wdJ = wdI+1 to hbound(words, 1);
	     if  words(wdI) = words(wdJ)  then
		return (F);
	     end;
	end;
     return (T);					/* All words are unique.			        */
     

/* -----------------------------------------------------------------
   SUBROUTINE:  descending_lengths

   FUNCTION:  Returns T if all each word in an array is at least as
	    long as words coming later in the array.
   ----------------------------------------------------------------- */
descending_lengths:
     entry (words) returns (bit(1) aligned);
     
  dcl  wdL fixed bin;
     
     wdL = 1000;
     if  word_ends(words(1), ".compin")  then		/* Files documenting .compin macros don't need descending */
	return (T);				/*   lengths in their header words.		        */
     do wdI = lbound(words, 1) to hbound(words, 1);	/* Return F if word(i) = word(j) for i ^= j	        */
	if  length(words(wdI)) > wdL  then 
	     return (F);				/*  - words not ordered by descending length	        */
	wdL = length(words(wdI));
	end;

     return (T);

     end all_REF_NAME_;


/* -----------------------------------------------------------------
   SUBROUTINE:  find_shortest_word

   FUNCTION:  Returns the first word in an array that is not longer
	    than any other word in the array.
   ----------------------------------------------------------------- */
find_shortest_word:
     proc (words) returns (char(72) var);

  dcl  words (*) char(*) var;
     
  dcl (wdI, wdL, wdOut) fixed bin;

     wdOut = 0;					/* Found no word as yet.			        */
     wdL = maxlength(words(1)) + 1;			/* Start with word length longer than maxlength(words)    */
     do wdI = lbound(words,1) to hbound(words,1);		/* Scan list, looking for a shorter word.	        */
	if  length(words(wdI)) < wdL  then do;		/*  - Take later word over earlier word of same length.   */
	     wdOut = wdI;
	     wdL = length(words(wdI));
	     end;
	end;
     if  wdOut = 0  then				/* Oops, no words in list?			        */
	return ("");
     else return (words(wdOut));			/* Found shortest word.			        */

     end find_shortest_word;


/* -----------------------------------------------------------------
   SUBROUTINE:  word_ends

   FUNCTION:  Returns T if final substring within a word matches
	    the end_str parameter.
   ----------------------------------------------------------------- */
word_ends:
     proc (word, end_str) returns (bit(1) aligned);

  dcl  word char(*) var;
  dcl  end_str char(*);
     
  dcl  i fixed bin;
     
     i = index(word, end_str);
     if  i > 0  then
     if  i = length(word) - length(end_str) + 1  then
	return (T);
     return (F);

     end word_ends;
%page;

	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
	/*									        */
	/* INTRODUCTION:  Simplified, special-cased regular expression matching.		        */
	/*									        */
	/* While full qedx regular expression match does exist via search_file_$silent, the routines      */
	/* below provide inexpensive, special-purpose regex-like searches to test an array of words.      */
	/*									        */
	/*									        */
	/* LIMITED REGEX SYNTAX:							        */
	/*   <partA>|<partB>  If either <partA> or <partB> regex matches a word, then word matches        */
	/*		  entire regex.						        */
	/*   ^                when used as the first character of a regular expression, signifies	        */
	/*                    the (imaginary) character preceding the first character on a line.	        */
	/*   $                when used as the last character of a regular expression, signifies	        */
	/*                    the (imaginary) character following the last character on a line.	        */
	/*   \$               suppresses the meaning of the $ sequence, allowing match of dollar sign     */
	/*                    character.						        */
	/*   \(STR)           portion of the regex that is replaced by value of the STR parameter.        */
	/*									        */
	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/* -----------------------------------------------------------------
   SUBROUTINE:  each_word_matches_STR_regex

   FUNCTION: returns T if each element of words array matches the 
	   regular expression, where \(STR) is replaced in the 
	   regex by the STR string parameter value.

   EXAMPLE:  if  each_word_matches_STR_regex (Blok_words, "^\(STR)$|^\(STR)\$", SUBR_REF_NAME_)  then;

     Looks for each Blok_words item matching either contents of SUBR_REF_NAME_ 
     parameter, or contents of SUBR_REF_NAME_ || "$" and other chars.  
     That is, does the item look like a valid subroutine entrypoint name.
   ----------------------------------------------------------------- */

each_word_matches_STR_regex:
     proc (words, regex, STR) returns (bit(1) aligned);
     
  dcl  words (*) char(*) var;
  dcl  regex char(*);
  dcl  STR char(*) var;
     
  dcl (regexA, regexB) char(100) var;
  dcl  wdI fixed bin;

     regexA = before(regex, "|");
     regexB = after (regex, "|");

     do wdI = lbound(words, 1) to hbound(words, 1);
	if       match_simple_regex (regexA, STR, words(wdI))  then;
	else if  match_simple_regex (regexB, STR, words(wdI))  then;
	else  return (F);
	end;
     return (T);
     

/* -----------------------------------------------------------------
   SUBROUTINE:  source_matches_each_WORD_regex

   FUNCTION: returns T if each element of words array when substituted
	   into the regular expression for \(STR) finds a match in
	   the Asource string.

   EXAMPLE:  if  source_matches_each_WORD_regex (iBlok.header.rest, "\(STR), |\(STR)$", Blok_words)  then;

     Looks for each Blok_words item appearing as part of a comma-separated list.
   ----------------------------------------------------------------- */

source_matches_each_WORD_regex:
     entry (Asource, regex, words) returns (bit(1) aligned);
     
  dcl  Asource char(*);
  dcl  source char(100) var;

     source = rtrim(Asource);
     regexA = before(regex, "|");
     regexB = after (regex, "|");

     do wdI = lbound(words, 1) to hbound(words, 1);
	if       match_simple_regex (regexA, words(wdI), source)  then;
	else if  match_simple_regex (regexB, words(wdI), source)  then;
	else  return (F);
	end;
     return (T);
%page;

/* INTERNAL FUNCTION:  Implements the regex matching engine for our limited set of regular expressions.	        */
match_simple_regex:
          proc (Aregex, with_STR, word) returns (bit(1) aligned);
	
  dcl  Aregex char(*) var;
  dcl  with_STR char(*) var;
  dcl  word char(*) var;

  dcl (begins, ends) fixed bin;
  dcl (ANYWHERE_IN_WORD	          init(1),
       (BEGINNING_OF_WORD, END_OF_WORD) init(2),
       DOLLAR_ENDS_WORD	          init(3)
       ) int static options(constant);

  dcl  regex char(100) var;

	regex = Aregex;
	do while (index(regex, "\(STR)") > 0);
	     regex = before(regex, "\(STR)") || with_STR || after(regex, "\(STR)");
	     end;

	begins, ends = ANYWHERE_IN_WORD;
	if  substr(regex,1,1) = "^"  then do;
	     begins = BEGINNING_OF_WORD;
	     regex = substr(regex,2);
	     end;
	if  substr(regex,length(regex)-1,2) = "\$"  then do;
	     ends = DOLLAR_ENDS_WORD;
	     regex = substr(regex, 1, length(regex)-2);
	     end;
	else if  substr(regex,length(regex),1) = "$"  then do;
	     ends = END_OF_WORD;
	     regex = substr(regex, 1, length(regex)-1);
	     end;
	do while (index(regex, "\$") > 0);
	     regex = before(regex, "\$") || "$" || after(regex, "\$");
	     end;
	
	if  begins = ANYWHERE_IN_WORD   &  ends = ANYWHERE_IN_WORD  then
	     return (index(word, regex) > 0);
	if  begins = BEGINNING_OF_WORD  &  ends = ANYWHERE_IN_WORD  then
	     return (index(word, regex) = 1);
	if  begins = ANYWHERE_IN_WORD   &  ends = END_OF_WORD  then
	     return (index( reverse(word), reverse(regex)) = 1);
	if  begins = BEGINNING_OF_WORD  &  ends = END_OF_WORD  then
	     return (word = regex);

	if  begins = BEGINNING_OF_WORD  &  ends = DOLLAR_ENDS_WORD  then
	     return (index( word, regex || DOLLAR_SIGN) = 1);
	if  begins = ANYWHERE_IN_WORD   &  ends = DOLLAR_ENDS_WORD  then
	     return (index( reverse(word), DOLLAR_SIGN || reverse(regex)) = 1);
	return (F);

	end match_simple_regex;

     end each_word_matches_STR_regex;
%page;
/* -----------------------------------------------------------------
   SUBROUTINE:  entrypoint_exists

   FUNCTION:  Returns T if given ep_name is findable by cv_entry_.
   ----------------------------------------------------------------- */

entrypoint_exists:
     proc (ep_name) returns (bit(1) aligned);
     
  dcl  ep_name char(*);

  dcl  code fixed bin(35);
  dcl  valid_entry entry variable;

     valid_entry = cv_entry_ (ep_name, null(), code);
     return (code = 0);

     end entrypoint_exists;


/* -----------------------------------------------------------------
   SUBROUTINE:  get_control_order_names

   Function: parses name list on top line of "Control order" section.
	   Supported formats:
       		Control order:  LONG_CONTROL_NAME, SHORT_CONTROL_NAME
       		Control order:  LONG_CONTROL_NAME

   Returns:  pointer to iName10 structure containing the array of control
	   names found following the "Control order:" section title.
	   Sets iSect.control_order_bad_listS if format isn't one of forms
	   shown above.
						
   References:  caller-supplied value of iSectP, which points to the 
	      "Control order" section.

       Usurps:  iLineP
   ----------------------------------------------------------------- */

get_control_order_names:
     proc () returns (ptr);

     iName10.N = 0;					/* Save order names in iName10 automatic structure.       */

  dcl  first_line char(84) var;
  dcl  token char(84) var;
  dcl  tokenL fixed bin;

     iLineP = iSect.lines.firstP;			/* Expect syntax:  Control order: LONG_CTRL, SHORT_CTRL   */

     first_line = ltrim( after( Line, info_seg_verify_$section_title(iSect_CONTROL_ORDER) ), SP_HT);
						/* Remove "Control order:" section title from line.       */
						/*  Remainder of line is comma-separated list of names.   */

     if  length(first_line) > 0  then do;		/* - Are there any names on line?		        */
	token = rtrim(before(first_line, COMMA), SP_HT);	/*    - Yes.  First name is text preceding any COMMA      */

	first_line = ltrim(after(first_line, COMMA), SP_HT);
						/* Remove that first name from our scan variable.	        */
	if  length(token) > 0  then do;		/* - Is first name non-blank (anything before COMMA)?     */
	     iName10.N = 1;
	     iName10.nm(1) = token;			/*    - Yes.  Save first name in our name array.	        */
	     end;
	else iSect.control_order_bad_listS = T;		/* ERROR   Control order: , token		        */
	end;

     if  ^iSect.control_order_bad_listS  then
     if  length(first_line) > 0  then do;		/* - Are there name(s) remaining on the line?	        */
	iName10.N = 2;
	tokenL = search(first_line, COMMA_SP_HT);	/*    - Yes.  Save second name in our array.	        */
	if  tokenL = 0  then do;
	     iName10.nm(2) = first_line;
	     first_line = "";
	     end;
	else do;
	     iName10.nm(2) = substr(first_line, 1, tokenL-1);
	     first_line = ltrim(substr(first_line,tokenL), SP_HT);
	     end;
	iSect.control_order_bad_listS = (length(first_line) > 0);
						/* ERROR   Control order: token, token ... 	        */
	end;					/*          [something follows 2nd token on line]	        */

     if  iSect.control_order_bad_listS  then
	iName10.N = 0;
     return ( addr(iName10) );

     end get_control_order_names;
%page;
/* -----------------------------------------------------------------
   SUBROUTINE:  is_Arguments_type

   FUNCTION:    returns T if an iSect.type value could be title of 
	      a section containing a command/request/IO_module 
	      operation name.
   ----------------------------------------------------------------- */
is_Arguments_type:
     proc (AiSect_type) returns (bit(1) aligned);

  dcl  AiSect_type fixed bin;

     return ( AiSect_type = iSect_ARGUMENTS        |
	    AiSect_type = iSect_ARGUMENTS_FOR    |
	    AiSect_type = iSect_ARGUMENTS_SUBSET |
	    AiSect_type = iSect_ARGUMENTS_FOR_IO_CALL
	    );

     end is_Arguments_type;

is_REF_NAME_:
     proc (Aname) returns(bit(1) aligned);
     
  dcl  Aname char(*) var;

     if  length(Aname) < 1  then			/* Empty name				        */
	return (F);
     if  verify(substr(Aname,1,1), LETTERS) > 0  then	/* name does not begin with LETTER		        */
	return (F);
     if  verify(Aname, LETTERS_DIGITS_UNDERSCORE_DOLLAR) > 0  then
          return (F);				/* name contains chars not allowed in PL/I identifier     */
     if  before(Aname, DOLLAR_SIGN) = after(Aname, DOLLAR_SIGN)  then
	return (F);				/* REF_NAME_$REF_NAME_  (should be just REF_NAME_)        */

     return (T);

     end is_REF_NAME_;

/* -----------------------------------------------------------------
   Function: test for particular blok kinds.
   ----------------------------------------------------------------- */

is_Command_kind:
	proc (AiBlok_kind) returns (bit(1) aligned);

  dcl  AiBlok_kind fixed bin;

	return ( iBlok.kind = iBlok_kind_COMMAND_AF       | 
	         iBlok.kind = iBlok_kind_COMMAND	| 
	         iBlok.kind = iBlok_kind_ACTIVE_FUNCTION
	         );

is_Command_Request_IO_kind:
	entry (AiBlok_kind) returns (bit(1) aligned);

	return ( is_Command_kind(AiBlok_kind)             |
	         is_Request_kind(AiBlok_kind)             |
	         is_IO_kind(AiBlok_kind)
	         );

is_Command_IO_GENERAL_kind:
	entry (AiBlok_kind) returns (bit(1) aligned);

	return ( is_Command_kind(AiBlok_kind)             |
	         is_IO_kind(AiBlok_kind)		|
	         iBlok.kind = iBlok_kind_GENERAL_INFO
	         );

is_IO_kind:
	entry (AiBlok_kind) returns (bit(1) aligned);     

	return ( iBlok.kind = iBlok_kind_IO_MODULE	|
	         iBlok.kind = iBlok_kind_IO_CONTROL	|
	         iBlok.kind = iBlok_kind_IO_OPERATION 
	         );	

is_Request_kind:
	entry (AiBlok_kind) returns (bit(1) aligned);     

	return ( AiBlok_kind = iBlok_kind_REQUEST_AR	|
	         AiBlok_kind = iBlok_kind_REQUEST	|
	         AiBlok_kind = iBlok_kind_ACTIVE_REQUEST
	         );
	
	end is_Command_kind;

%page;
%include ssu_subroutine_dcls_;

     end info_seg_verify_iFile_;
