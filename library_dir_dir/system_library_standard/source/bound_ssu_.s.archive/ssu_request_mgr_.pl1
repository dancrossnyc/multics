/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   *********************************************************** */


/* Subsystem request table management: includes entries to manipulate the list of request tables used by the subsystem,
   entries to search the request tables, and the summarize_requests and list_requests request */

/* Created:  3 May 1980 by W. Olin Sibert from subsystem_request_mgr_ */
/* Modified: 16 December 1981 by Jay Pattin for new list_requests and to add summarize_requests and find_request_name */
/* Modified: 12 February 1982 by G. Palter to merge in the actual code of the list/summarize_requests requests which were
   moved from ssu_misc_requests */
/* Modified: 28 February 1982 by G. Palter for new output format for list_requests and the dont_summarize and dont_list
   request table flags */
/* Modified: 2 August 1982 by Jay Pattin for unknown requests and to eliminate the listing of duplicate request names
   in list_requests and summarize_requests */
/* Modified: 22 August 1982 by Jay Pattin to make request tables into a hash table */

/* format: style4,delnl,insnl,ifthenstmt,ifthen */


ssu_request_mgr_:
     procedure ();

	return;					/* not an entrypoint */


/* Parameters */

dcl  P_sci_ptr pointer parameter;
dcl  P_code fixed binary (35) parameter;

dcl  P_rqt_ptr pointer parameter;			/* add_request_table, delete_request_table: -> the table */
dcl  P_position fixed binary parameter;			/* add_request_table: where to place the table in the list */

dcl  P_rtl_ptr pointer parameter;			/* list_request_tables, set_requests_tables: -> the list */
dcl  P_callers_area_ptr pointer parameter;		/* list_request_tables: -> area where list is allocated */
dcl  P_request_tables_list_version fixed binary parameter;	/* list_request_tables: version of the list user expects */

dcl  P_request_name character (*) parameter;		/* locate_request, find_request_name: a request name */
dcl  P_request_data_ptr pointer parameter;		/* locate_request: -> request_data structure to be filled in */
dcl  P_request_entry entry variable parameter;		/* find_request_name: the request whose name is desired */

dcl  P_info_ptr pointer parameter;			/* summarize_requests, list_requests */


/* The list of request tables being used by this subsystem */

dcl  1 request_tables aligned based (sci.request_tables_ptr),
       2 n_tables fixed binary,
       2 pad bit (36),
       2 hash_table_ptr pointer,
       2 tables (request_tables_n_tables refer (request_tables.n_tables)) like request_tables_list.tables;

dcl  1 hash_table aligned based (request_tables.hash_table_ptr),
       2 n_slots fixed binary,
       2 chains (2000) fixed binary,			/* the actual hash table: first slot in each chain */
       2 slots (0 refer (hash_table.n_slots)),
         3 name character (32),
         3 rq_data_ptr pointer,
         3 first_name_switch bit (1) aligned,		/* ON => first unique name for this request */
         3 next_slot fixed binary;

dcl  request_tables_n_tables fixed binary;
dcl  new_request_tables_ptr pointer;


/* Local copies of parameters */

dcl  code fixed binary (35);

dcl  position fixed binary;

dcl  callers_area area based (callers_area_ptr);
dcl  callers_area_ptr pointer;

dcl  request_name character (32);


/* Remaining declarations */

dcl  1 summary_info aligned based (summary_info_ptr),
       2 total_lines fixed binary,
       2 print_line (0 refer (summary_info.total_lines)),
         3 continuation bit (1) aligned,
         3 line char (36) varying;
dcl  summary_info_ptr ptr;

dcl  1 entry_variable aligned,			/* internal representation of an entry variable */
       2 code_ptr pointer,
       2 env_ptr pointer;

dcl  1 fdo aligned like format_document_options;

dcl  output_buffer character (4 * sys_info$max_seg_size) based (output_buffer_ptr);
dcl  output_buffer_ptr pointer;

dcl  (lh_request_name, help_request_name) character (32);

dcl  code2 fixed binary (35);

dcl  (n_arguments, max_request_strings) fixed binary;

dcl  (entry1, entry2) entry variable;

dcl  (rqt_idx, rq_idx, idx, jdx) fixed binary;
dcl  (one_name_size, two_name_size, max_name_size) fixed binary;
dcl  line_length fixed binary;

dcl  (columns, col_len, this_line, lines_per_col) fixed binary;
dcl  col_offset (0:5) fixed binary;

dcl  (match, found_bad_table) bit (1) aligned;

dcl  SUMMARIZE_REQUESTS character (32) static options (constant) initial ("summarize_requests");
dcl  LIST_REQUESTS character (32) static options (constant) initial ("list_request");
dcl  SSU_REQUEST_MGR_ character (32) static options (constant) initial ("ssu_request_mgr_");

dcl  WHITESPACE character (2) static options (constant) initial (" 	");

dcl  SP character (1) static options (constant) initial (" ");
dcl  NL character (1) static options (constant) initial ("
");

dcl  DELIMITERS character (5) static options (constant) initial (" .-_$");
						/* break chars for request name matching */

dcl  sys_info$max_seg_size fixed binary (19) external;

/* format: off */
dcl (error_table_$badopt, error_table_$inconsistent, error_table_$noalloc, error_table_$noarg,
     error_table_$unimplemented_version, ssu_et_$blank_request_name, ssu_et_$no_matching_requests,
     ssu_et_$invalid_request_table, ssu_et_$request_name_too_long, ssu_et_$request_not_found,
     ssu_et_$request_table_not_found, ssu_et_$unimplemented_request, ssu_et_$unknown_request)
	fixed binary (35) external;
/* format: on */

dcl  iox_$user_output pointer external;

dcl  format_document_$string entry (character (*), character (*), fixed binary (21), pointer, fixed binary (35));
dcl  get_line_length_$switch entry (pointer, fixed binary (35)) returns (fixed binary);
dcl  get_ring_ entry () returns (fixed binary (3));
dcl  hash_index_ entry (pointer, fixed binary, fixed binary, fixed binary) returns (fixed binary);
dcl  hcs_$combine_linkage entry (pointer, fixed binary (3), fixed binary (35));
dcl  ioa_ entry () options (variable);
dcl  ioa_$nnl entry () options (variable);
dcl  ssu_$abort_line entry () options (variable);
dcl  ssu_$arg_count entry (pointer, fixed binary);
dcl  ssu_$arg_ptr entry (pointer, fixed binary, pointer, fixed binary (21));
dcl  ssu_$get_default_procedure entry (pointer, character (*), entry, fixed binary (35));
dcl  ssu_$get_procedure entry (pointer, character (*), entry, fixed binary (35));
dcl  ssu_$get_subsystem_and_request_name entry (pointer) returns (character (72) varying);
dcl  ssu_$get_temp_segment entry (pointer, character (*), pointer);
dcl  ssu_$print_message entry () options (variable);
dcl  ssu_$release_temp_segment entry (pointer, pointer);

/* format: off */
dcl (ssu_requests_$help, ssu_requests_$list_help, ssu_requests_$list_requests)
	entry ();
/* format: on */

dcl  (area, cleanup, linkage_error) condition;

dcl  (addr, addrel, baseno, binary, codeptr, divide, environmentptr, index, length, ltrim, max, maxlength, min, mod, null,
     pointer, rtrim, stackframeptr, substr, unspec, verify) builtin;
%page;
/* Initialize the list of request tables (invoked by ssu_invocation_) */

init_request_tables:
     entry (P_sci_ptr);

	sci_ptr = P_sci_ptr;
	sci.request_tables_ptr = null ();

	return;



/* Release the request tables list (invoked from ssu_invocation_) */

term_request_tables:
     entry (P_sci_ptr);

	sci_ptr = P_sci_ptr;

	if sci.request_tables_ptr ^= null () then do;
	     if request_tables.hash_table_ptr ^= null () then
		call ssu_$release_temp_segment (sci_ptr, request_tables.hash_table_ptr);
	     free request_tables in (sci_parent_area);
	end;

	sci.request_tables_ptr = null ();

	return;
%page;
/* Add a request table to the list used by this subsystem */

add_request_table:
     entry (P_sci_ptr, P_rqt_ptr, P_position, P_code);

	call ssu_check_sci (P_sci_ptr);

	sci_ptr = P_sci_ptr;
	P_code = 0;				/* assume success */

	call validate_request_table (P_rqt_ptr, code);
	if code ^= 0 then do;
	     P_code = code;
	     return;
	end;

	if sci.request_tables_ptr = null () then
	     request_tables_n_tables = 1;
	else request_tables_n_tables = request_tables.n_tables + 1;

	new_request_tables_ptr = null ();		/* for cleanup handler */

	on condition (cleanup)
	     begin;
		if new_request_tables_ptr ^= null () then
		     free new_request_tables_ptr -> request_tables in (sci_parent_area);
	     end;

	allocate request_tables in (sci_parent_area) set (new_request_tables_ptr);

	if sci.request_tables_ptr = null () then position = 1;
						/* first table */
	else if P_position > request_tables.n_tables then position = request_tables.n_tables + 1;
						/* add to the end of the list */
	else if P_position <= 0 then position = 1;	/* add to the beginning */
	else position = P_position;			/* add in an explicit place */

	do idx = 1 to position - 1;
	     new_request_tables_ptr -> request_tables.tables (idx) = request_tables.tables (idx);
	end;
	new_request_tables_ptr -> request_tables.tables (position).table_ptr = P_rqt_ptr;
	new_request_tables_ptr -> request_tables.tables (position).table_valid = "1"b;

	do idx = position + 1 to new_request_tables_ptr -> request_tables.n_tables;
	     new_request_tables_ptr -> request_tables.tables (idx) = request_tables.tables (idx - 1);
	end;

	call build_hash_table ();			/* this will swap rtl_ptr in sci and free old copy */

	return;
%page;
/* Delete a request table from the list used by this subsystem */

delete_request_table:
     entry (P_sci_ptr, P_rqt_ptr, P_code);

	call ssu_check_sci (P_sci_ptr);

	sci_ptr = P_sci_ptr;

	match = "0"b;				/* haven't found it yet */

	if sci.request_tables_ptr = null () then
	     P_code = ssu_et_$request_table_not_found;

	else do;
	     do idx = 1 to request_tables.n_tables while (^match);
		if request_tables.tables (idx).table_ptr = P_rqt_ptr then match = "1"b;
	     end;

	     if match then do;			/* found it: idx identifies next entry in list */
		if request_tables.n_tables = 1 then do;
		     if request_tables.hash_table_ptr ^= null () then
			call ssu_$release_temp_segment (sci_ptr, request_tables.hash_table_ptr);
		     free request_tables in (sci_parent_area);
		     sci.request_tables_ptr = null ();
		end;
		else do;
		     new_request_tables_ptr = null ();

		     on condition (cleanup)
			begin;
			     if new_request_tables_ptr ^= null () then
				free new_request_tables_ptr -> request_tables in (sci_parent_area);
			end;

		     request_tables_n_tables = request_tables.n_tables - 1;
		     allocate request_tables in (sci_parent_area) set (new_request_tables_ptr);
		     do jdx = 1 to idx - 2;
			new_request_tables_ptr -> request_tables.tables (jdx) = request_tables.tables (jdx);
		     end;
		     do jdx = idx to request_tables.n_tables;
			new_request_tables_ptr -> request_tables.tables (jdx - 1) = request_tables.tables (jdx);
		     end;

		     call build_hash_table ();	/* recompute hash table */
		end;
		P_code = 0;			/* success */
	     end;
	     else P_code = ssu_et_$request_table_not_found;
	end;

	return;
%page;
/* Return the list of request tables used by this subsystem */

list_request_tables:
     entry (P_sci_ptr, P_callers_area_ptr, P_request_tables_list_version, P_rtl_ptr, P_code);

	if P_request_tables_list_version ^= REQUEST_TABLES_LIST_VERSION_1 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;

	call ssu_check_sci (P_sci_ptr);

	sci_ptr = P_sci_ptr;
	callers_area_ptr = P_callers_area_ptr;

	on condition (area)
	     begin;
		P_code = error_table_$noalloc;
		go to RETURN_FROM_LIST_REQUEST_TABLES;
	     end;

	if sci.request_tables_ptr ^= null () then
	     request_tables_list_n_tables = request_tables.n_tables;
	else request_tables_list_n_tables = 0;		/* there are no request tables: return an empty list */

	allocate request_tables_list in (callers_area) set (rtl_ptr);

	request_tables_list.version = REQUEST_TABLES_LIST_VERSION_1;

	if sci.request_tables_ptr ^= null () then
	     do idx = 1 to request_tables.n_tables;
	     request_tables_list.tables (idx) = request_tables.tables (idx);
	end;

	P_rtl_ptr = rtl_ptr;
	P_code = 0;				/* success */

RETURN_FROM_LIST_REQUEST_TABLES:
	return;
%page;
/* Replace the list of request tables with that supplied by the caller */

set_request_tables:
     entry (P_sci_ptr, P_rtl_ptr, P_code);

	call ssu_check_sci (P_sci_ptr);

	sci_ptr = P_sci_ptr;
	rtl_ptr = P_rtl_ptr;

	if request_tables_list.version ^= REQUEST_TABLES_LIST_VERSION_1 then do;
	     P_code = error_table_$unimplemented_version;
	     return;
	end;

	found_bad_table = "0"b;			/* assume user's list is OK */

	do idx = 1 to request_tables_list.n_tables;
	     request_tables_list.tables (idx).table_valid = "1"b;
	     call validate_request_table (request_tables_list.tables (idx).table_ptr, code);
	     if code ^= 0 then do;			/* not a request table */
		if ^found_bad_table then P_code = code;
		found_bad_table = "1"b;		/* remember reason for the first bad table */
		request_tables_list.tables (idx).table_valid = "0"b;
	     end;
	end;

	if found_bad_table then return;		/* return code is already set */

	request_tables_n_tables = request_tables_list.n_tables;

	new_request_tables_ptr = null ();

	on condition (cleanup)
	     begin;
		if new_request_tables_ptr ^= null () then
		     free new_request_tables_ptr -> request_tables in (sci_parent_area);
	     end;

	allocate request_tables in (sci_parent_area) set (new_request_tables_ptr);

	do idx = 1 to new_request_tables_ptr -> request_tables.n_tables;
	     new_request_tables_ptr -> request_tables.tables (idx) = request_tables_list.tables (idx);
	end;

	call build_hash_table ();

	P_code = 0;				/* success */

	return;
%page;
/* Validate that the caller has a real request table */

validate_request_table:
     procedure (p_rqt_ptr, p_code);

dcl  p_rqt_ptr pointer parameter;
dcl  p_code fixed binary (35) parameter;

	if (substr (unspec (p_rqt_ptr), 31, 6) ^= "43"b3) then p_code = ssu_et_$invalid_request_table;

	else if (p_rqt_ptr = null ()) then p_code = ssu_et_$invalid_request_table;

	else if (p_rqt_ptr -> rqt.version ^= RQT_VERSION_4) then p_code = ssu_et_$invalid_request_table;

	else p_code = 0;				/* it passes */

	return;

     end validate_request_table;
%page;
/* Makes a hash table of all the request names for fast lookup */

build_hash_table:
     procedure ();

dcl  (old_request_tables_ptr, new_hash_table_ptr) pointer;
dcl  first_name_switch bit (1) aligned;

	new_hash_table_ptr = null ();			/* for cleanup handler */

	on condition (cleanup)
	     begin;
		if new_hash_table_ptr ^= null () then call ssu_$release_temp_segment (sci_ptr, new_hash_table_ptr);
	     end;

	call ssu_$get_temp_segment (sci_ptr, SSU_REQUEST_MGR_, new_hash_table_ptr);

	do rqt_idx = 1 to new_request_tables_ptr -> request_tables.n_tables;
	     if new_request_tables_ptr -> request_tables.tables (rqt_idx).table_valid then do;
		rqt_ptr = new_request_tables_ptr -> request_tables.tables (rqt_idx).table_ptr;
		do rq_idx = 1 to rqt.n_requests;
		     rq_data_ptr = addr (rqt.requests (rq_idx));
		     request_name_list_ptr = pointer (rqt_ptr, rq_data.namelist_loc);
		     first_name_switch = "1"b;
		     do idx = 1 to request_name_list.n_names;
			call check_one_name (request_name_list.name (idx));
		     end;
		end;
	     end;
	end;

	old_request_tables_ptr = sci.request_tables_ptr;

	new_request_tables_ptr -> request_tables.hash_table_ptr = new_hash_table_ptr;
	sci.request_tables_ptr = new_request_tables_ptr;	/* switch to new tables */
	new_request_tables_ptr, new_hash_table_ptr = null ();
						/* don't let the cleanup handlers at now permanent tables */

	if old_request_tables_ptr ^= null () then do;	/* get rid of old request tables list */
	     if old_request_tables_ptr -> request_tables.hash_table_ptr ^= null then
		call ssu_$release_temp_segment (sci_ptr, old_request_tables_ptr -> request_tables.hash_table_ptr);
	     free old_request_tables_ptr -> request_tables in (sci_parent_area);
	end;

	return;
%page;
/* Internal to build_hash_table: checks the given name */

check_one_name:
	procedure (this_name);

dcl  this_name character (32);
dcl  (chain_idx, slot_idx) fixed binary;

	     chain_idx = hash_index_ (addr (this_name), length (rtrim (this_name)), 0, 2000) + 1;

	     do slot_idx = new_hash_table_ptr -> hash_table.chains (chain_idx)
		repeat new_hash_table_ptr -> hash_table.slots.next_slot (slot_idx) while (slot_idx ^= 0);
		if new_hash_table_ptr -> hash_table.slots (slot_idx).name = this_name then return;
	     end;

	     new_hash_table_ptr -> hash_table.n_slots, slot_idx = new_hash_table_ptr -> hash_table.n_slots + 1;
						/* here iff its unique */

	     new_hash_table_ptr -> hash_table.slots (slot_idx).name = this_name;
	     new_hash_table_ptr -> hash_table.slots (slot_idx).rq_data_ptr = rq_data_ptr;
	     new_hash_table_ptr -> hash_table.slots (slot_idx).first_name_switch = first_name_switch;
	     first_name_switch = "0"b;		/* have definitely made first entry for this request */

	     new_hash_table_ptr -> hash_table.slots (slot_idx).next_slot =
		new_hash_table_ptr -> hash_table.chains (chain_idx);
	     new_hash_table_ptr -> hash_table.chains (chain_idx) = slot_idx;

	     return;

	end check_one_name;

     end build_hash_table;
%page;
/* Lookup a request and return all available information on it from the request table */

locate_request:
     entry (P_sci_ptr, P_request_name, P_request_data_ptr, P_code);

	call ssu_check_sci (P_sci_ptr);

	sci_ptr = P_sci_ptr;
	request_name = P_request_name;
	request_data_ptr = P_request_data_ptr;

	rq_data_ptr = lookup_request (request_name);	/* find name in request tables */

	if code ^= 0 then do;			/* couldn't find it */
	     P_code = code;
	     return;
	end;

	request_name_list_ptr = pointer (rq_data_ptr, rq_data.namelist_loc);
						/* copy all the so-called "permanent" info */
	request_data.full_name = request_name_list.name (1);
	request_data.name_list_ptr = request_name_list_ptr;

	request_data.info_string.ptr = pointer (rq_data_ptr, rq_data.info_string.loc);
	request_data.info_string.lth = rq_data.info_string.lth;

	request_data.flags = rq_data.flags;
	unspec (request_data.pad) = ""b;

	request_data.call_info.arg_list_ptr = null ();	/* fill this in as blank */
	request_data.call_info.arg_count = 0;
	request_data.call_info.af_sw = "0"b;
	request_data.call_info.rv_ptr = null ();
	request_data.call_info.rv_lth = 0;

	if rq_data.unknown then			/* catch unknown requests */
	     P_code = ssu_et_$unknown_request;
	else if rq_data.unimplemented then		/* catch unimplemented requests */
	     P_code = ssu_et_$unimplemented_request;

	else do;					/* see if we can actually access it */
	     entry_variable.code_ptr = pointer (rq_data_ptr, rq_data.code_loc);
						/* find the procedure */
	     entry_variable.env_ptr = null ();		/* always an external procedure */
	     unspec (request_data.entry) = unspec (entry_variable);
	     P_code = 0;				/* success */
	end;

	return;
%page;
/* Scans the list of request tables for the specified request name */

lookup_request:
     procedure (request_name) returns (pointer);

dcl  request_name character (32);
dcl  (chain_idx, slot_idx) fixed binary;

	if sci.request_tables_ptr = null () then do;	/* no request tables: can't have any requests */
	     code = ssu_et_$unknown_request;
	     return (null ());
	end;

	if length (ltrim (rtrim (request_name, WHITESPACE), WHITESPACE)) > 32 then do;
	     code = ssu_et_$request_name_too_long;
	     return (null ());
	end;

	if verify (request_name, WHITESPACE) = 0 then do;
	     code = ssu_et_$blank_request_name;
	     return (null ());
	end;

	chain_idx = hash_index_ (addr (request_name), length (rtrim (request_name)), 0, 2000) + 1;

	do slot_idx = hash_table.chains (chain_idx) repeat hash_table.slots.next_slot (slot_idx) while (slot_idx ^= 0);
	     if hash_table.slots (slot_idx).name = request_name then do;
		code = 0;
		return (hash_table.slots (slot_idx).rq_data_ptr);
	     end;
	end;

	code = ssu_et_$unknown_request;		/* didn't find it */
	return (null ());

     end lookup_request;
%page;
/* Given an entry variable, returns the primary name of the request which that entry represents (if any) */

find_request_name:
     entry (P_sci_ptr, P_request_entry, P_request_name, P_code);

	sci_ptr = P_sci_ptr;

	call find_request_name_subr (P_request_entry, P_request_name, P_code);

	return;



/* Internal procedure which does all the work (called from the summarize_requests and list_requests requests) */

find_request_name_subr:
     procedure (p_request_entry, p_request_name, p_code);

dcl  p_request_entry entry variable parameter;
dcl  p_request_name character (*) parameter;
dcl  p_code fixed binary (35) parameter;

	if sci.request_tables_ptr = null () then do;	/* no request tables */
	     p_request_name = "";
	     p_code = ssu_et_$request_not_found;
	     return;
	end;

	do rqt_idx = 1 to request_tables.n_tables;	/* loop through all tables */
	     if request_tables.tables (rqt_idx).table_valid then do;
						/* ... it's a good table */
		rqt_ptr = request_tables.tables (rqt_idx).table_ptr;
		if find_request_name_in_table (p_request_entry, p_request_name) then do;
		     p_code = 0;			/* found a match here */
		     return;
		end;
	     end;
	end;

	p_request_name = "";			/* here iff the request wasn't found anywhere */
	p_code = ssu_et_$request_not_found;

	return;
%page;
/* Internal to find_request_name_subr: search a single request table for the given entry variable */

/* format: off */

/* Each request table entry contains the offset of a code sequence of the form:
	epaq	*
	lprp4	7|stack_header.lot_ptr,*au
	call6	4|link_offset,*

   If the request procedure and the request table have been bound together, the last instruction above will be simply:
      call6	procedure_offset

   In order to compare the caller's entry variable, we need to look at the link (which we might snap when we reference it)
   as it is the link that is the actual entry invoked.  In order to look at the link, we need a pointer to the linkage of
   the request table; if necessary, we will combine the request table's linkage.  Ugh! */

/* format: on */

find_request_name_in_table:
	procedure (p_request_entry, p_request_name) returns (bit (1) aligned);

dcl  p_request_entry entry variable parameter;
dcl  p_request_name character (*) parameter;

dcl  1 lot aligned based (stack_header.lot_ptr),		/* the LOT */
       2 lot_pointers (0:stack_header.cur_lot_size - 1) pointer unaligned;

dcl  1 lot_pointer aligned based (lot_pointer_ptr),	/* have to check for lot faults ... */
       2 lot_fault bit (3) unaligned,
       2 mbz bit (27) unaligned;
dcl  lot_pointer_ptr pointer;
dcl  linkage_ptr pointer;

dcl  1 code_sequence aligned based (cs_ptr),
       2 epaq_lprp4 bit (72),				/* don't actually reference these two */
       2 call6,
         3 link_offset bit (18) unaligned,
         3 op_code_and_modifiers bit (18) unaligned;
dcl  cs_ptr pointer;

dcl  (
     CALL6_ABSOLUTE initial ("713000"b3),		/* call6 offset */
     CALL6_PR4_STAR initial ("713120"b3)		/* call6 pr4|offset,* */
     ) bit (18) static options (constant);

dcl  word bit (36) aligned;
dcl  based_word based bit (36) aligned;
dcl  the_entry pointer based (the_entry_ptr);
dcl  the_entry_ptr pointer;
dcl  test_rq_data_ptr pointer;

	     if environmentptr (p_request_entry) ^= null () then return ("0"b);
						/* only external entries in the request table */

	     sb = pointer (stackframeptr (), 0);
	     lot_pointer_ptr = addr (lot.lot_pointers (binary (baseno (rqt_ptr), 18, 0)));

	     if (lot_pointer.lot_fault = "111"b) & (lot_pointer.mbz = ""b) then do;
		call hcs_$combine_linkage (rqt_ptr, get_ring_ (), code);
		if code ^= 0 then			/* couldn't combine the linkage (sigh) ... */
		     return ("0"b);			/* ... so claim it's not there */
	     end;

	     linkage_ptr = lot.lot_pointers (binary (baseno (rqt_ptr), 18, 0));

	     do rq_idx = 1 to rqt.n_requests;
		rq_data_ptr = addr (rqt.requests (rq_idx));
		request_name_list_ptr = pointer (rqt_ptr, rq_data.namelist_loc);
		if ^rq_data.flags.unimplemented & ^rq_data.flags.unknown then do;
		     cs_ptr = pointer (rqt_ptr, rq_data.code_loc);
		     if (code_sequence.op_code_and_modifiers = CALL6_ABSOLUTE) then do;
						/* bound segment: get entry directly from the instruction */
			the_entry_ptr = pointer (rqt_ptr, code_sequence.link_offset);
			if codeptr (p_request_entry) = the_entry_ptr then do;
FOUND_THE_REQUEST:
			     do idx = 1 to request_name_list.n_names;
						/* If the name is in the hash table, it isn't a duplicate */
				test_rq_data_ptr = lookup_request (request_name_list.name (idx));
				if test_rq_data_ptr = rq_data_ptr then do;
				     p_request_name = request_name_list.name (idx);
				     return ("1"b);
				end;
			     end;
			end;
		     end;
		     else if (code_sequence.op_code_and_modifiers = CALL6_PR4_STAR) then do;
						/* unbound segment: must indirect through linkage */
			the_entry_ptr = addrel (linkage_ptr, "000"b || substr (code_sequence.link_offset, 4, 15));
			on condition (linkage_error)	/* in case we can't find what it references ... */
			     go to SKIP_THIS_REQUEST;
			word = the_entry -> based_word;
						/* reference through it to snap the link if necessary */
			revert condition (linkage_error);
			if codeptr (p_request_entry) = the_entry then go to FOUND_THE_REQUEST;
						/* found it! */
		     end;
		end;
SKIP_THIS_REQUEST:
	     end;

	     return ("0"b);				/* didn't find it */

	end find_request_name_in_table;

     end find_request_name_subr;
%page;
/* Standard summarize_requests request: prints a multi-columnar listing of all requests available to the subsystem which
   have non-null documentation strings */

summarize_requests:
     entry (P_sci_ptr, P_info_ptr);

	sci_ptr = P_sci_ptr;

	call ssu_$arg_count (sci_ptr, n_arguments);
	if n_arguments ^= 0 then call ssu_$abort_line (sci_ptr, 0, "No arguments may be given.");

	if sci.request_tables_ptr = null () then	/* eh? */
	     call ssu_$abort_line (sci_ptr, 0, "There are no ^a requests.", sci.subsystem_name);

	call ioa_ ("Available ^a requests:^/", sci.subsystem_name);


/* Compute the number of columns to use in the summary: use the longest single request name with a gutter of 4 spaces */

	call compute_request_name_widths ("1"b, "0"b);	/* get length of longest name */

	line_length = get_line_length_$switch (iox_$user_output, code);
	if code ^= 0 then line_length = 72;		/* enforce the "standard" */

	columns = divide (line_length, (one_name_size + 4), 17, 0);
						/* how many columns will fit */
	if columns > 5 then columns = 5;		/* let's be arbitrary here, too many doesn't look nice */

	col_len = divide (line_length, columns, 17, 0) - 4;


/* Build the line fragments which will form the content of the columns */

	summary_info_ptr = null ();			/* for cleanup handler */
	on condition (cleanup)
	     begin;
		if summary_info_ptr ^= null () then call ssu_$release_temp_segment (sci_ptr, summary_info_ptr);
	     end;

	call ssu_$get_temp_segment (sci_ptr, SUMMARIZE_REQUESTS, summary_info_ptr);

	summary_info.total_lines = 0;

	idx = 1;
	do while (idx <= hash_table.n_slots);
	     rq_data_ptr = hash_table.slots (idx).rq_data_ptr;
	     request_name_list_ptr = pointer (rq_data_ptr, rq_data.namelist_loc);
	     if ^rq_data.flags.unimplemented & ^rq_data.flags.dont_summarize & ^rq_data.flags.unknown then
		call add_request_to_list ();
	     else idx = idx + 1;
	end;


/* Find the first line fragment to be printed in each column */

	lines_per_col = divide (summary_info.total_lines, columns, 17, 0);
						/* approximate number of lines in each column */

	col_offset (0) = 0;
	col_offset (columns) = summary_info.total_lines;

	do idx = 1 to columns - 1;
	     col_offset (idx) = idx * lines_per_col;
	end;

	jdx = mod (summary_info.total_lines, columns);	/* distribute the leftover lines evenly */
	do idx = 1 to columns - 1;
	     col_offset (idx) = col_offset (idx) + min (idx, jdx);
	end;


/* Print the lines */

	do rq_idx = 1 to col_offset (1);
	     do idx = 0 to columns - 1;
		this_line = rq_idx + col_offset (idx);
		if this_line <= col_offset (idx + 1) then
		     call ioa_$nnl ("^a^[^s^;^vt^]", summary_info.line (this_line), (idx = columns - 1), col_len + 5);
	     end;
	     call ioa_ ();
	end;

	call ssu_$release_temp_segment (sci_ptr, summary_info_ptr);


/* If the subsystem defines the list_requests request, point the user at it (using the proper name) */

	call find_request_name_subr (ssu_requests_$list_requests, request_name, code);
	if code = 0 then call ioa_ ("^/Type ""^a"" for a short description of the requests.", request_name);

	return;
%page;
/* Put the names of this request into the list of line fragments splitting the names where constrained by column width */

add_request_to_list:
     procedure ();

dcl  (name_idx, name_lth) fixed binary;
dcl  name_string character (80) varying;
dcl  this_name character (32) varying;

	name_string = rtrim (hash_table.slots (idx).name);

	do idx = (idx + 1) repeat (idx + 1)
	     while ((idx <= hash_table.n_slots) & ^hash_table.slots (idx).first_name_switch);
	     this_name = rtrim (hash_table.slots (idx).name);
	     name_lth = length (this_name) + 2;		/* extra two is for the ', ' */

	     if length (name_string) + name_lth > col_len then do;
						/* won't fit on this line */
		summary_info.total_lines = summary_info.total_lines + 1;
		summary_info.line (summary_info.total_lines) = name_string || ",";
		name_string = "   " || this_name;
	     end;

	     else do;
		if length (name_string) ^= 0 then name_string = name_string || ", ";
		name_string = name_string || this_name;
	     end;
	end;

	if name_string ^= "" then do;			/* be sure to output the remainder */
	     summary_info.total_lines = summary_info.total_lines + 1;
	     summary_info.line (summary_info.total_lines) = name_string;
	end;

	return;

     end add_request_to_list;
%page;
/* Standard list_requests request: lists the names and brief descriptions of all requests or of those requests whose name
   contains any of a given set of strings */

list_requests:
     entry (P_sci_ptr, P_info_ptr);

	sci_ptr = P_sci_ptr;

	call ssu_$arg_count (sci_ptr, n_arguments);

	if sci.request_tables_ptr = null () then	/* eh? */
	     call ssu_$abort_line (sci_ptr, 0, "There are no ^a requests.", sci.subsystem_name);

	max_request_strings = max (1, n_arguments);	/* PL/I doesn't like zero-length arrays */


LIST_REQUESTS_BODY:
	begin;

dcl  request_strings (max_request_strings) character (32) varying;
dcl  matched_request_string (max_request_strings) bit (1) aligned;
dcl  n_request_strings fixed binary;			/* the actual number present */

dcl  list_all_requests bit (1) aligned;			/* ON => also show requests without documentation strings */
dcl  exact_matches_only bit (1) aligned;

dcl  argument character (argument_lth) based (argument_ptr);
dcl  argument_lth fixed binary (21);
dcl  argument_ptr pointer;

dcl  (listed_a_request, didnt_find_a_request) bit (1) aligned;
dcl  arg_idx fixed binary;


	     n_request_strings = 0;			/* haven't seen any yet */

	     list_all_requests, exact_matches_only = "0"b;

	     do arg_idx = 1 to n_arguments;
		call ssu_$arg_ptr (sci_ptr, arg_idx, argument_ptr, argument_lth);
		if index (argument, "-") = 1 then do;
		     if (argument = "-all") | (argument = "-a") then list_all_requests = "1"b;
		     else if (argument = "-exact") then exact_matches_only = "1"b;
		     else call ssu_$abort_line (sci_ptr, error_table_$badopt, """^a""", argument);
		end;
		else do;				/* a string to be matched */
		     if argument_lth > maxlength (request_strings (1)) then
			call ssu_$abort_line (sci_ptr, ssu_et_$request_name_too_long, "^a", argument);
		     n_request_strings = n_request_strings + 1;
		     request_strings (n_request_strings) = argument;
		end;
	     end;

	     if exact_matches_only & (n_request_strings = 0) then
		call ssu_$abort_line (sci_ptr, error_table_$noarg, "Request names must be given with ""-exact"".");


/* Print generally usefull information when listing all requests */

	     if n_request_strings = 0 then do;

		call ioa_ ("Summary of ^a requests:^/", sci.subsystem_name);

		call ssu_$get_procedure (sci_ptr, "cpescape", entry1, (0));
		call ssu_$get_default_procedure (sci_ptr, "cpescape", entry2, (0));
		if entry1 = entry2 then call ioa_ ("Use "".. COMMAND_LINE"" to escape a command line to Multics.");

		call find_request_name_subr (ssu_requests_$list_help, lh_request_name, code);
		call find_request_name_subr (ssu_requests_$help, help_request_name, code2);
		if (code = 0) & (code2 = 0) then
		     call ioa_ ("Type ""^a"" for a list of topics available to the ^a request.", lh_request_name,
			help_request_name);
		else if (code ^= 0) & (code2 = 0) then
		     call ioa_ ("Type ""^a -topics"" for a list of available topics.", help_request_name);
		if code2 = 0 then
		     call ioa_ ("Type ""^a TOPIC"" for more information on a given topic.", help_request_name);

		if (entry1 = entry2) | (code = 0) | (code2 = 0) then call ioa_ ("");
	     end;					/* separate usefull info from the actual list */


/* Pass through all the request tables and list all request which match the selection criteria */

	     output_buffer_ptr = null ();		/* for cleanup handler */
	     on condition (cleanup)
		begin;
		     if output_buffer_ptr ^= null () then call ssu_$release_temp_segment (sci_ptr, output_buffer_ptr);
		end;

	     call ssu_$get_temp_segment (sci_ptr, LIST_REQUESTS, output_buffer_ptr);

	     line_length = get_line_length_$switch (iox_$user_output, code);
	     if code ^= 0 then line_length = 72;	/* enforce the "standard" */

	     fdo.version_number = format_document_version_1;
	     string (fdo.switches) = ""b;		/* fill in constant parts */
	     fdo.literal_sw = "1"b;			/* no embedded controls */
	     fdo.galley_sw = "1"b;			/* no page breaks */
	     if exact_matches_only then do;		/* one request per string ... */
		fdo.indentation = 3;		/* ... description indented under names ... */
		fdo.line_length = line_length;	/* ... and uses full terminal width */
	     end;
	     else do;				/* multiple requests ... */
		fdo.indentation = 0;		/* ... description to right of names ... */
		fdo.line_length = 0;		/* ... line length varies (see below) ... */
		call compute_request_name_widths ("0"b, list_all_requests);
		if one_name_size < (two_name_size - 6) then
		     max_name_size = one_name_size + 3;
		else max_name_size = two_name_size + 3;
	     end;					/* ... and space for names also varies */

	     listed_a_request = "0"b;
	     matched_request_string (*) = "0"b;

	     if exact_matches_only then
		do idx = 1 to n_request_strings;
		rq_data_ptr = lookup_request ((request_strings (idx)));
		if rq_data_ptr ^= null () then do;
		     request_name_list_ptr = pointer (rq_data_ptr, rq_data.namelist_loc);
		     listed_a_request, matched_request_string (idx) = "1"b;
		     call list_single_request ();
		end;
	     end;

	     else do idx = 1 to hash_table.n_slots;
		if hash_table.slots (idx).first_name_switch then do;
		     rq_data_ptr = hash_table.slots (idx).rq_data_ptr;
		     request_name_list_ptr = pointer (rq_data_ptr, rq_data.namelist_loc);

		     if (list_all_requests | (^rq_data.flags.unimplemented & ^rq_data.flags.dont_list))
			& ^rq_data.flags.unknown then do;

			request_info_string_ptr = pointer (rq_data_ptr, rq_data.info_string.loc);
			request_info_string_lth = rq_data.info_string.lth;
			if matching_name () then do;
			     listed_a_request = "1"b;
			     call list_single_request ();
			end;
		     end;
		end;
	     end;

	     call ssu_$release_temp_segment (sci_ptr, output_buffer_ptr);
	     output_buffer_ptr = null ();

	     if exact_matches_only then do;
		didnt_find_a_request = "0"b;
		do idx = 1 to n_request_strings;
		     if ^matched_request_string (idx) then do;
			didnt_find_a_request = "1"b;
			call ssu_$print_message (sci_ptr, 0, "Unknown request ""^a"".", request_strings (idx));
		     end;
		end;
		if didnt_find_a_request then		/* rest of the request line may be disastrous */
		     call ssu_$abort_line (sci_ptr, 0);
	     end;

	     else if ^listed_a_request then call ssu_$abort_line (sci_ptr, ssu_et_$no_matching_requests);
%page;
/* Internal to list_requests begin block: returns true if any of this request's names meets the selection criteria.  If
   exact matches are being sought, check all names (rather than stopping on first match) to insure that any request
   matching more than one of the user's names properly marks all those strings as matched */

matching_name:
     procedure () returns (bit (1) aligned);

dcl  (name_idx, idx, position) fixed binary;
dcl  found_some_matches bit (1) aligned;
dcl  test_rq_data_ptr pointer;

	if n_request_strings = 0 then			/* listing all requests */
	     return ("1"b);

	found_some_matches = "0"b;

	do name_idx = 1 to request_name_list.n_names;
	     request_name = rtrim (request_name_list.name (name_idx));
	     test_rq_data_ptr = lookup_request (request_name);
	     if rq_data_ptr = test_rq_data_ptr then do;
		do idx = 1 to n_request_strings;
		     position = index (request_name, request_strings (idx));
		     if (position ^= 0) then
			if (position = 1) then return ("1"b);
			else if (position = length (request_name) - length (request_strings (idx)) + 1) then
			     return ("1"b);
			else if (index (DELIMITERS, substr (request_name, (position - 1), 1)) ^= 0) then
			     return ("1"b);
			else if (index (DELIMITERS,
				substr (request_name, (position + length (request_strings (idx))), 1)) ^= 0) then
			     return ("1"b);
		end;
	     end;
	end;

	return (found_some_matches);

     end matching_name;
%page;
/* Internal to list_requests begin block: shows a single request */

list_single_request:
     procedure ();

dcl  (output_buffer_used, formatted_name_list_position, formatted_name_list_lth, formatted_info_string_position,
     formatted_info_string_lth, name_start, name_lth, info_start, info_lth) fixed binary (21);
dcl  idx fixed binary;
dcl  test_rq_data_ptr pointer;
dcl  (first_line, have_names, have_info) bit (1) aligned;


/* Construct the list of request names */

	output_buffer_used = 0;

	do idx = 1 to request_name_list.n_names;
	     request_name = rtrim (request_name_list.name (idx));
	     test_rq_data_ptr = lookup_request (request_name);
	     if rq_data_ptr = test_rq_data_ptr then do;
		if output_buffer_used > 0 then do;	/* ... a comma separated list */
		     substr (output_buffer, (output_buffer_used + 1), 2) = ", ";
		     output_buffer_used = output_buffer_used + 2;
		end;
		name_lth = length (rtrim (request_name));
		substr (output_buffer, (output_buffer_used + 1), name_lth) = rtrim (request_name);
		output_buffer_used = output_buffer_used + name_lth;
	     end;
	end;

	if output_buffer_used = 0 then return;		/* No names found */


/* Only one request matches each string: display at least two lines; the first line contains all the request names; the
   second and subsequent lines contains the brief description slightly indented */

	if exact_matches_only then do;

	     call ioa_ ("^a^[^2x(unimplemented)^]", substr (output_buffer, 1, output_buffer_used),
		rq_data.flags.unimplemented);

	     if length (request_info_string) = 0 then
		call ioa_ ("^3x(No brief description available.)");

	     else do;
		call format_document_$string (request_info_string, output_buffer, output_buffer_used, addr (fdo), (0))
		     ;
		begin;
dcl  formatted_string character (output_buffer_used) defined (output_buffer) position (1);
		     output_buffer_used = length (rtrim (formatted_string, NL));
		end;				/* format_document_ doesn't always add 1 newline */
		begin;
dcl  formatted_string character (output_buffer_used) defined (output_buffer) position (1);
		     call ioa_ ("^a", formatted_string);
		end;
	     end;
	end;


/* More than one request matches each string (if any): display the request names and descriptions on a single line if
   possible; otherwise, split the appropriate strings and indent subsequent lines by a small amount */

	else do;

	     formatted_name_list_position = output_buffer_used + 1;
	     begin;				/* now format it */
dcl  unformatted_name_list character (output_buffer_used) defined (output_buffer) position (1);
dcl  rest_of_output_buffer character (length (output_buffer) - output_buffer_used) unaligned
	defined (output_buffer) position (output_buffer_used + 1);
		fdo.line_length = max_name_size - 3;	/* ... insure there's room for the overflow */
		call format_document_$string (unformatted_name_list, rest_of_output_buffer, formatted_name_list_lth,
		     addr (fdo), (0));
	     end;
	     begin;
dcl  name_list character (formatted_name_list_lth) unaligned defined (output_buffer)
	position (formatted_name_list_position);
		formatted_name_list_lth = length (rtrim (name_list, NL)) + 1;
		substr (name_list, formatted_name_list_lth, 1) = NL;
	     end;					/* format_document_ sometimes doesn't add trailing newlines */

	     output_buffer_used = output_buffer_used + formatted_name_list_lth;
	     formatted_info_string_position = output_buffer_used + 1;
	     begin;				/* format the documentation string */
dcl  rest_of_output_buffer character (length (output_buffer) - output_buffer_used) unaligned
	defined (output_buffer) position (output_buffer_used + 1);
		fdo.line_length = line_length - max_name_size - 6;
		if fdo.line_length < 21 then		/* don't let it get too short ... */
		     fdo.line_length = 131071;	/* ... so don't split the documentation string */
		call format_document_$string (request_info_string, rest_of_output_buffer, formatted_info_string_lth,
		     addr (fdo), (0));
	     end;
	     begin;
dcl  info_string character (formatted_info_string_lth) unaligned defined (output_buffer)
	position (formatted_info_string_position);
		formatted_info_string_lth = length (rtrim (info_string, NL)) + 1;
		substr (info_string, formatted_info_string_lth, 1) = NL;
	     end;					/* format_document_ sometimes doesn't add trailing newlines */

	     begin;				/* output the results ... */

dcl  name_list character (formatted_name_list_lth) unaligned defined (output_buffer)
	position (formatted_name_list_position);
dcl  info_string character (formatted_info_string_lth) unaligned defined (output_buffer)
	position (formatted_info_string_position);

		first_line, have_names = "1"b;	/* requests have to have some names */
		have_info = (info_string ^= NL);	/* info string might have been empty */
		name_start, info_start = 1;

		do while (have_names | have_info);
		     if have_names then name_lth = index (substr (name_list, name_start), NL) - 1;
		     if have_info then info_lth = index (substr (info_string, info_start), NL) - 1;
		     if have_names & have_info then
			call ioa_ ("^[^3x^]^a^vt^[^3x^]^a", ^first_line, substr (name_list, name_start, name_lth),
			     (max_name_size + 3), ^first_line, substr (info_string, info_start, info_lth));
		     else if have_names then do;
			call ioa_ ("^[^3x^]^a", ^first_line, translate (substr (name_list, name_start), SP, NL));
			name_lth = length (name_list);/* all the remaining names are on this line */
		     end;
		     else call ioa_ ("^vt^[^3x^]^a", (max_name_size + 3), ^first_line,
			     substr (info_string, info_start, info_lth));
		     name_start = name_start + name_lth + 1;
		     info_start = info_start + info_lth + 1;
		     have_names = (name_start < length (name_list));
		     have_info = (info_start < length (info_string));
		     first_line = "0"b;
		end;
	     end;
	end;

	return;

     end list_single_request;

	end LIST_REQUESTS_BODY;

	return;
%page;
/* Computes the amount of room needed for the longest primary request name and the longest combination of a primary
   request name and its first short name */

compute_request_name_widths:
     procedure (p_summarize, p_include_all);

dcl  (p_summarize, p_include_all) bit (1) aligned parameter;
dcl  exclude bit (1) aligned;

	one_name_size = 0;
	two_name_size = 0;

	do idx = 1 to hash_table.n_slots;
	     rq_data_ptr = hash_table.slots (idx).rq_data_ptr;

	     if p_summarize then
		exclude = rq_data.flags.dont_summarize;
	     else exclude = rq_data.flags.dont_list;

	     if (p_include_all | (^rq_data.flags.unimplemented & ^exclude)) & ^rq_data.flags.unknown then do;
		request_name_list_ptr = pointer (rq_data_ptr, rq_data.namelist_loc);

		if request_name_list.n_names >= 2 then
		     two_name_size =
			max (two_name_size,
			length (rtrim (request_name_list.name (1))) + length (rtrim (request_name_list.name (2)))
			+ 2);

		else two_name_size = max (two_name_size, length (rtrim (request_name_list.name (1))));

		one_name_size = max (one_name_size, length (rtrim (request_name_list.name (1))));
	     end;
	end;

	return;

     end compute_request_name_widths;
%page;
%include "_ssu_check_sci";
%page;
%include "_ssu_sci";
%page;
%include "_ssu_request_table";
%page;
%include "_ssu_request_data";
%page;
%include ssu_request_tables_list;
%page;
%include stack_header;
%page;
%include format_document_options;

     end ssu_request_mgr_;
