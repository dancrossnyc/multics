/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(1988-05-16,Huen), approve(1988-05-16,MCR7841),
     audit(1988-05-25,RWaters), install(1988-07-05,MR12.2-1054):
     Fix kermit 15, 16, 17, and 18.
  2) change(1989-01-02,Huen), approve(1989-01-02,MCR8027),
     audit(1989-01-25,Lee), install(1989-03-01,MR12.3-1020):
     Fix kermit bugs: PC_File_Transfer 18, 20, and 23.
  3) change(2018-05-26,Anthony), approve(2018-05-26,MCR10049),
     audit(2018-05-26,GDixon), install(2018-05-27,MR12.6g-0013):
     Fix kermit buffer overrun error.
                                                   END HISTORY COMMENTS */


kermit_pad_: proc;
  
  /********************************************************************/
  /*							*/
  /*n	kermit_pad_					*/
  /*							*/
  /*d	This routine is the Packet Assembler/Disassembler that is	*/
  /*d	responsible for taking text and formatting it into packets	*/
  /*d	and taking incoming packets and decoding them.		*/
  /*							*/
  /*l	Written:	84-10-15	by Dean Elhard			*/
  /*l	Modified: 86-09-29  by Don Kozlowski - Check if the server	*/
  /*l		kermit will honour the encoding of Receive_init	*/
  /*l		packets before the encoding is done. (kermit 12)	*/
  /*l     Modified: 87-06-12  by Don Kozlowski - Move  CR and NL      */
  /*l               constant definitions to include file. (kermit 15) */
  /*l     Modified: 87-06-12  by S.Huen - Add extended packet length  */
  /*l               support based on D. Kozlowski version.(kermit 16) */
  /*l	Modified:	87-07-22	by Don Kozlowski - Add packet_fix and	*/
  /*l		packet_type to get around optimizer bug.	*/
  /*l		for msf file support. (kermit 18)		*/
  /*l	Modified:	87-08-26	by Don Kozlowski - use offsets into	*/
  /*l		packet in decode_data procedure. (kermit 18)	*/
  /*							*/
  /********************************************************************/
  
  /* constants */
  
  dcl true		bit (1) static options (constant) init ("1"b);
  dcl false		bit (1) static options (constant) init ("0"b);
  
  dcl Seconds_to_microseconds fixed bin (71) static options (constant)
			     init (1000000);
  
  dcl Transmit		char (1) static options (constant) init (">");
  dcl Receive		char (1) static options (constant) init ("<");
  
  dcl Char_encoding_offset	fixed bin static options (constant) init (32);
  dcl Max_packet_size	fixed bin static options (constant) init (1500);
  dcl No_eight_bit_encoding	char (1) static options (constant) init ("N");
  dcl No_repeat_encoding	char (1) static options (constant) init (" ");
  dcl Binary_file_type	char (1) static options (constant) init ("B");
  dcl Ascii_file_type	char (1) static options (constant) init ("A");
  
  dcl Eight_bit_byte_size	fixed bin (8) static options (constant) init (8);
  
  dcl Receive_init_packet_type char (1) static options (constant) init ("R");
  dcl Send_init_packet_type	char (1) static options (constant) init ("S");
  dcl Ack_packet_type	char (1) static options (constant) init ("Y");
  dcl Server_init_packet_type char (1) static options (constant) init ("I");
  
  dcl Ascii_ctl_limit	fixed bin static options (constant) init (31);
  dcl Ascii_printable_limit	fixed bin static options (constant) init (126);
  dcl Ascii_pad_char	fixed bin static options (constant) init (127);
  
  dcl Max_repeat_encoding	fixed bin static options (constant) init (94);
  dcl Min_repeat_encoding	fixed bin static options (constant) init (4);
  
  dcl Mark_parity		char (1) static options (constant) init ("M");
  dcl Space_parity		char (1) static options (constant) init ("S");
  dcl No_parity		char (1) static options (constant) init ("N");
  
  /* parameters */
  
  dcl A_infop		ptr parameter;
  dcl A_crnl		bit (1) parameter;
  dcl A_rcvd		fixed bin (21) parameter;
  dcl A_sent		fixed bin (21) parameter;
  dcl A_size		fixed bin (21) parameter;
  dcl A_datal		fixed bin (21) parameter;
  dcl A_datap		ptr parameter;
  dcl A_code		fixed bin (35) parameter;
  dcl A_bufl		fixed bin (21) parameter;
  dcl A_bufp		ptr parameter;
  dcl A_seq_no		fixed bin parameter;
  dcl A_type		char (1) parameter;
  
  /* procedures */
  
  dcl add_char_offset_	entry (ptr, fixed bin(21)) 
			    returns(ptr) reducible;
  dcl iox_$control		entry (ptr, char(*), ptr, fixed bin(35));
  dcl iox_$put_chars	entry (ptr, ptr, fixed bin(21), fixed bin(35));
  dcl timed_io_$get_chars	entry (ptr, fixed bin(71), ptr, fixed bin(21),
			     fixed bin(21), fixed bin(35));
  
  /* external */
  
  dcl error_table_$line_status_pending
			external fixed bin (35);
  dcl error_table_$timeout
			external fixed bin (35);
  dcl kermit_et_$cannot_decode
			external fixed bin (35);
  dcl kermit_et_$crc_error	external fixed bin (35);
  dcl kermit_et_$length_mismatch
			external fixed bin (35);
  dcl kermit_et_$mangled_packet
			external fixed bin (35);
  dcl kermit_et_$unimplemented_check_type
			external fixed bin (35);
  dcl sys_info$max_seg_size	external fixed bin (35);
  
  /* based */
  
  /* automatic */
  
  dcl ec			fixed bin (35);
  dcl packet		char (Max_packet_size) varying;
  
  /* builtin */
  
  dcl addr		builtin;
  dcl addrel		builtin;
  dcl bin			builtin;
  dcl bool		builtin;
  dcl byte		builtin;  
  dcl copy		builtin;
  dcl index		builtin;
  dcl length		builtin;
  dcl min	                    builtin;
  dcl mod			builtin;
  dcl null		builtin;
  dcl rank		builtin;
  dcl rtrim		builtin;
  dcl string                  builtin;  
  dcl substr                  builtin;
  dcl unspec                  builtin;
  dcl verify		builtin;
  
  /* include files */
  

%include kermit_dcls;

%include kermit_info;

%include kermit_mode_info;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


send: entry (A_infop,	/* subsystem info pointer		*/
	   A_type,	/* packet type			*/
	   A_datap,	/* pointer to the data buffer		*/
	   A_datal,	/* length of the data buffer		*/
	   A_seq_no,	/* packet sequence number		*/
	   A_sent,	/* number of chars sent from buffer	*/
	   A_size,	/* length of packet in chars		*/
	   A_code);	/* returned status code		*/
  
  /********************************************************************/
  /*							*/
  /*n	Name:	kermit_pad_$send			external	*/
  /*i	Input:	packet_type, data, sequence_no, info_ptr	*/
  /*f	Function:	calls encode_data to encode the data, calls	*/
  /*f		append_ctl_info to add the sequence_number and	*/
  /*f		length, calls append_checksum to calculate and	*/
  /*f		add the checksum, and the calls transmit_packet	*/
  /*f		to add parity if required and send the packet to	*/
  /*f		the remote system.				*/
  /*o	Output:	error_code, characters_transmitted, packet_size	*/
  /*							*/
  /*l	Written:	84-10-15	by Dean Elhard			*/
  /*							*/
  /********************************************************************/
  
  call encode_data (A_infop, A_type, A_datap, A_datal, packet,
			A_sent, ec);
  
  call append_ctl_info (A_infop, A_seq_no, packet);
  
  call append_checksum (A_infop, packet, A_code);
  if A_code ^= 0
    then return;
    
  A_size = length (packet) + 2;
  
  call transmit_packet (A_infop, packet, A_code);
  if A_code = 0
    then A_code = ec;
    
  return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


receive: entry (A_infop,	/* subsystem info pointer		*/
	      A_type,	/* packet type received		*/
	      A_bufp,	/* pointer to text buffer		*/
	      A_bufl,	/* length of text buffer		*/
	      A_seq_no,	/* sequence number of packet received	*/
	      A_rcvd,	/* number of decoded chars received	*/
	      A_size,	/* size or received packet		*/
	      A_crnl,	/* flag if CR/NL encoding spans packet	*/
	      A_code);	/* output status code		*/

  /********************************************************************/
  /*							*/
  /*n	Name:	kermit_pad_$receive			external	*/
  /*i	Input:	info_ptr					*/
  /*f	Function:	calls receive_packet to get the packet, then	*/
  /*f		calls validate_checksum to make sure the checksum	*/
  /*f		is correct and to remove it from the packet, then	*/
  /*f		calls check_ctl_info to extract the sequence_no	*/
  /*f		and validate that the length is correct,	*/
  /*f		and then calls decode_data to decode the data	*/
  /*f		section of the packet.			*/
  /*o	Output:	data, packet_type, sequence_number, packet_size,	*/
  /*o		chars_recieved, spanned_cr/nl_flag, error_code	*/
  /*							*/
  /*l	Written:	84-10-15	by Dean Elhard			*/
  /*							*/
  /********************************************************************/
  
  A_rcvd = 0;
  A_size = 0;
  A_seq_no = 0;
  
  call receive_packet (A_infop, packet, A_size, A_code);
  if A_code ^= 0
    then return;
    
  call validate_checksum (A_infop, packet, A_code);
  if A_code ^= 0
    then return;
    
  call check_ctl_info (A_infop, packet, A_seq_no, A_code);
  if A_code ^= 0
    then return;
    
  call decode_data (A_infop, A_bufp, A_bufl, A_type, packet, A_rcvd,
		A_crnl, A_code);
  
  return;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


encode_data: proc (infop,	/* subsystem info pointer		*/
	         type,	/* packet type to encode		*/
	         datap,	/* ptr to data to be encoded		*/
	         datal,	/* length of data to be encoded	*/
	         packet,	/* encoded data packet		*/
	         n_sent,	/* number of characters encoded	*/
	         ec);	/* error code			*/
  
  /********************************************************************/
  /*							*/
  /*n	Name:	encode_data			internal	*/
  /*i	Input:	data, type, info_ptr			*/
  /*f	Function:	for each character until the buffer is full, call	*/
  /*f		encode_char to encode it into a sequence.  If the	*/
  /*f		sequence can be added to the packet,  add it and	*/
  /*f		continue, otherwise, prepend the type and quit	*/
  /*f		returning the number of chars encoded.		*/
  /*o	Output:	error_code, encoded_data, characters_encoded	*/
  /*							*/
  /*l	Written:	84-10-15	by Dean Elhard			*/
  /*l     Modified: 89-01-02  by S.Huen - kermit should use the packet*/
  /*l               length and control quoting character expected by  */
  /*l               the external kermit. (pc_18)                      */
  /*							*/
  /********************************************************************/
  
  /* parameters */
  
  dcl infop		ptr;
  dcl type		char (1);
  dcl datap		ptr;
  dcl datal		fixed bin (21);
  dcl packet		char (*) varying;
  dcl n_sent		fixed bin (21);
  dcl ec			fixed bin (35);
  
  /* based */
  
  dcl data		char (datal) based (datap);
  
  /* automatic */
  
  dcl t_selector (1:8)	fixed bin;
  dcl p_selector (1:2)	fixed bin;
  dcl 01 perm_modes		aligned,
       02 line_byte_size	fixed bin (8) unaligned,
       02 file_type		char (1) unaligned;
  dcl 01 capabilities	aligned,
       02 bit_string,
         03 eight_bit	bit (1) unaligned,
         03 repeat		bit (1) unaligned,
         03 binary		bit (1) unaligned,
         03 raw		bit (1) unaligned,
         03 ext_header	bit (1) unaligned,
         03 mbz		bit (33) unaligned,
       02 max_len		fixed bin;
	   

  dcl 01 modes		aligned,
       02 maxl		fixed bin (8) unaligned,
       02 quote		char (1) unaligned,
       02 eight_bit		char (1) unaligned,
       02 repeat		char (1) unaligned,
       02 check_type	fixed bin (8) unaligned,
       02 capas		bit (9) unaligned,
       02 maxlnx1		fixed bin (9) unsigned unaligned,
       02 maxlnx2		fixed bin (9) unsigned unaligned;

  dcl done		bit (1);
  dcl subsetp		ptr;
  dcl subsetl		fixed bin (21);
  dcl sequence		char (5) varying;
  dcl n_chars		fixed bin;
  dcl header_size		fixed bin;  
  packet = "";
  ec = 0;
  
  /* fetch the packet length, check type and prefix characters	*/
  /* Fix bug 18 - Fetch the correct packet length and control quoting characters */
  
  t_selector (1) = O_maxl;
  t_selector (2) = O_quote_char;
  t_selector (3) = G_eight_bit_char;
  t_selector (4) = G_repeat_char;
  t_selector (5) = G_check_type;
  t_selector (6) = G_capabilities;
  t_selector (7) = O_max_lenx1;
  t_selector (8) = O_max_lenx2;
  
  call kermit_mode_mgr_$retrieve (infop, Temporary, t_selector,
			addr (modes), ec);
  
  /* fetch the line type					*/
  
  p_selector (1) = Line_byte_size;
  p_selector (2) = File_type;
  
  call kermit_mode_mgr_$retrieve (infop, Permanent, p_selector,
			addr (perm_modes), ec);
  
  string (capabilities.bit_string) = ""b;
  
  /* determine the capabilities from the line type and prefix chars	*/
  if modes.capas & Ext_Headers         /* extended packet headers	      */
       then do;
       capabilities.ext_header = true;
       capabilities.max_len = modes.maxlnx1 * 95 + modes.maxlnx2;
       end;
  else capabilities.max_len = modes.maxl;

  if modes.eight_bit ^= No_eight_bit_encoding
    then capabilities.eight_bit = true;
  if modes.repeat ^= No_repeat_encoding
    then capabilities.repeat = true;
    
  if perm_modes.line_byte_size = Eight_bit_byte_size
    then do;
      capabilities.raw = true;
      capabilities.eight_bit = false;
    end;
  
  if perm_modes.file_type = Binary_file_type
    then capabilities.binary = true;
    
  n_sent = 0;
  done = false;
  if capabilities.ext_header & (datal > 94)
       then header_size = 6;       /* Extended length packet header     */
  else header_size = 3;	         /* Normal packet header	      */

  
  /* skip encoding if there is no data to send			*/
  
  if datal = 0
    then do;
      n_sent = 0;
      packet = "";
    end;
    
   /* Do not encode send_init, server_init, ack, and receive_init      */
   /* packets before determining whether the server kermit will        */
   /* honour its encoding.                                             */
  
  else if type = Send_init_packet_type |
	type = Receive_init_packet_type |
	type = Ack_packet_type |
	type = Server_init_packet_type
    then do;
      n_sent = min (datal, capabilities.max_len);
      packet = substr (data, 1, n_sent);
    end;
    else do while (^done);
      subsetp = add_char_offset_ (datap, (n_sent));
      subsetl = datal - n_sent;
      
      call encode_char (infop, subsetp, subsetl, sequence, n_chars,
			modes.quote, modes.eight_bit, modes.repeat,
			string (capabilities.bit_string));
      
      if length(packet) + length(sequence) > capabilities.max_len - modes.check_type - header_size
        then done = true;
        else do;
	packet = packet || sequence;
	n_sent = n_sent + n_chars;
	if n_sent >= datal
	  then done = true;
        end;
    end;
  
  /* prepend the packet type					*/

  packet = type || packet;

end encode_data;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


append_ctl_info: proc (infop,		/* subsystem info pointer	*/
		   seq_no,	/* sequence number to add	*/
		   packet);	/* packed to add info to	*/
  
  /********************************************************************/
  /*							*/
  /*n	Name:	append_ctl_info			internal	*/
  /*i	Input:	encoded_data, info_ptr, sequence_no		*/
  /*f	Function:	gets the checksum type from the temp modes to	*/
  /*f		calculate the length of the packet, encodes the	*/
  /*f		length and sequence number and adds them to the	*/
  /*f		packet.					*/
  /*o	Output:	partial_packet				*/
  /*							*/
  /*l	Written:	84-10-15	by Dean Elhard			*/
  /*							*/
  /********************************************************************/
  
  /* parameters */
  
  dcl infop		ptr;
  dcl packet		char (*) varying;
  dcl seq_no		fixed bin;
  
  /* automatic */
  
  dcl selector (1:1)	fixed bin init (G_check_type);
  dcl chk_tp		fixed bin (8) unal;
  dcl ec			fixed bin (35);
  dcl (len, lenx1, lenx2)	fixed bin;
  dcl check		fixed bin;
  dcl hcheck		fixed bin (9) unsigned;
  dcl packet_fix		char (1);
  call kermit_mode_mgr_$retrieve (infop, Temporary, selector, 
			addr (chk_tp), ec);
   
  /* calculate the length of the packet				*/
  
  len = length (packet) + chk_tp + 1;

  /* prepend the encoded length and sequence number		*/
  if len > 94
       then do;
       packet_fix = packet;	         /* Use packet_fix to strip off first */
			         /* character of packet since substr  */
			         /* doesn't work with -optimize	here  */
       len = len - 2;	         /* Calculate size after header	      */
       lenx1 = (len / 95) + Char_encoding_offset;
       lenx2 = mod (len, 95) + Char_encoding_offset;
       check = (Char_encoding_offset * 2) + seq_no
	  + rank (packet_fix) + lenx1 + lenx2;

       hcheck = mod(check + (mod (check, 256) / 64), 64) + Char_encoding_offset;
       packet = substr (packet, 2);
       packet = byte (Char_encoding_offset) ||   /* Len = 0 	      */
	      byte (seq_no + Char_encoding_offset) ||
	      packet_fix ||	         /* Type		      */
	      byte (lenx1) || byte (lenx2) ||
	      byte (hcheck) || packet;
       end;
     else packet = byte (len + Char_encoding_offset) ||
	byte (seq_no + Char_encoding_offset) || packet;
  
end append_ctl_info;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


append_checksum: proc (infop,		/* subsystem info pointer	*/
		   packet,	/* packet to add checksum to	*/
		   ec);		/* error code		*/
  
  /********************************************************************/
  /*							*/
  /*n	Name:	append_checksum			internal	*/
  /*i	Input:	partial_packet, info_ptr			*/
  /*f	Function:	calls calculate_checksum to get the checksum	*/
  /*f		value, and appends it to the partial packet	*/
  /*o	Output:	packet					*/
  /*							*/
  /*l	Written:	84-10-15	by Dean Elhard			*/
  /*							*/
  /********************************************************************/
  
  /* parameters */
  
  dcl infop		ptr;
  dcl packet		char (*) varying;
  dcl ec			fixed bin (35);
  
  /* automatic */
  
  dcl checksum		char (3) varying;
  
  call calculate_checksum (infop, packet, checksum, ec);
  if ec ^= 0
    then return;
    
  packet = packet || checksum;
  
end append_checksum;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


transmit_packet: proc (infop,		/* subsystem info pointer	*/
		   packet,	/* packet to transmit	*/
		   ec);		/* error code		*/
    
  /********************************************************************/
  /*							*/
  /*n	Name:	transmit_packet			internal	*/
  /*i	Input:	packet, info_ptr				*/
  /*f	Function:	prepends the mark character and the EOL		*/
  /*f		character, calls set_parity to set the parity	*/
  /*f		bits on the data if mark or space parity is	*/
  /*f		selected, appends the appropriate number of pad	*/
  /*f		characters and transmits the packet to the remote	*/
  /*f		computer.					*/
  /*o	Output:	error_code				*/
  /*							*/
  /*l	Written:	84-10-15	by Dean Elhard			*/
  /*l	Modified:	84-11-06	by Dean Elhard to handle line_status	*/
  /*							*/
  /********************************************************************/
  
  /* parameters */
  
  dcl infop		ptr;
  dcl packet		char (*) varying;
  dcl ec			fixed bin (35);
  
  /* based */
  
  dcl 01 comm_info		aligned like kermit_comm_info
			     based (info.comm_infop);
  dcl 01 info		aligned like kermit_info based (infop);
  
  /* automatic */
  
  dcl selector (1:4)	fixed bin;
  dcl 01 modes		aligned,
       02 start_ch		char (1) unaligned,
       02 eol_ch		char (1) unaligned,
       02 pad_char		char (1) unaligned,
       02 pad_count		fixed bin (8) unaligned;
  
  selector (1) = G_start_char;
  selector (2) = O_eol_char;
  selector (3) = O_pad_char;
  selector (4) = O_n_pads;
  
  call kermit_mode_mgr_$retrieve (infop, Temporary, selector,
			addr (modes), ec);
  
  /* add the mark and eol characters to the packet		*/
  
  packet = modes.start_ch || packet || modes.eol_ch;
  
  if modes.eol_ch ^= CR
    then packet = packet || CR;
    
  /* add any padding that may be required			*/
  
  packet = copy (modes.pad_char, modes.pad_count) || packet;
  
  /* set the parity on the packet				*/
  
  call set_parity (infop, packet);
  
  /* send the packet to the remote system			*/
  
  ec = error_table_$line_status_pending;
  
  do while (ec = error_table_$line_status_pending);
    call iox_$put_chars (comm_info.ft_iocbp, addrel (addr (packet), 1),
		length (packet), ec);
    if ec = error_table_$line_status_pending
      then call process_line_status (infop);
  end;
  
  if ec = 0 & comm_info.debug_segp ^= null
    then call debug_log (infop, Transmit, (packet));
    
end transmit_packet;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


receive_packet: proc (infop,		/* subsystem info pointer	*/
		  packet,		/* packet received		*/
		  char_count,	/* packet length		*/
		  ec);		/* error code		*/
  
  /********************************************************************/
  /*							*/
  /*n	Name:	receive_packet			internal	*/
  /*i	Input:	info_ptr					*/
  /*f	Function:	reads a line of text in from the remote system,	*/
  /*f		and calls strip_parity to remove the parity bits	*/
  /*f		Then the mark and EOL characters are removed.	*/
  /*o	Output:	packet, char_count, error_code		*/
  /*							*/
  /*l	Written:	84-10-15	by Dean Elhard			*/
  /*l	Modified:	84-11-06	by Dean Elhard to handle line_status	*/
  /*							*/
  /********************************************************************/
  
  /* parameters */
  
  dcl infop		ptr;
  dcl packet		char (*) varying;
  dcl char_count		fixed bin (21);
  dcl ec			fixed bin (35);
  
  /* based */
  
  dcl 01 info		aligned like kermit_info based (infop);
  dcl input_buffer		char (comm_info.input_buffer.bufferl)
			     based (comm_info.input_buffer.bufferp);
  dcl 01 comm_info		aligned like kermit_comm_info
			     based (info.comm_infop);
  
  
  /* automatic */
  
  dcl buffer_len		fixed bin (21);
  dcl eol_index		fixed bin (21);
  dcl start_index		fixed bin (21);
  dcl input_time		fixed bin (71);
  dcl add_to_buffer		char (chars_read) based (buffer_offsetp);
  dcl buffer_offsetp	ptr;	      
  dcl chars_read		fixed bin (21);
  dcl 01 modes		aligned,
       02 timeout		fixed bin (8) unaligned,
       02 start_ch		char (1) unaligned,
       02 eol_char		char (1) unaligned;
  dcl selector (1:3)	fixed bin;
  
  selector (1) = I_timeout;
  selector (2) = G_start_char;
  selector (3) = I_eol_char;
  
  call kermit_mode_mgr_$retrieve (infop, Temporary, selector,
			addr (modes), ec);
  
  /* calculate the timeout time value				*/
  
  input_time = modes.timeout * Seconds_to_microseconds;
  buffer_len = sys_info$max_seg_size * 4;
  
  packet = "";
  
  do while (length (packet) = 0);
       eol_index = 0;
       do while (eol_index = 0);
	  eol_index = index (input_buffer, modes.eol_char);
	  /* if eol is a CR, check for a NL instead.  It may be translated.   */
	  if eol_index = 0 & modes.eol_char = CR
	       then eol_index = index (input_buffer, NL);
	  buffer_offsetp = add_char_offset_ (
	       comm_info.input_buffer.bufferp, 
	       comm_info.input_buffer.bufferl);
      
		  /* read a packet from the remote system	      */
	  if eol_index = 0 then      /* Wait patiently for it	      */
	       call timed_io_$get_chars (comm_info.ft_iocbp, input_time,
	       buffer_offsetp, buffer_len - comm_info.input_buffer.bufferl,
	       chars_read, ec);
	  else		         /* Don't wait around for it	      */
	       call timed_io_$get_chars (comm_info.ft_iocbp, 1,
	       buffer_offsetp, buffer_len - comm_info.input_buffer.bufferl,
	       chars_read, ec);
	  
	  comm_info.input_buffer.bufferl = comm_info.input_buffer.bufferl + chars_read;
	  if ec = 0 & comm_info.debug_segp ^= null
	       then call debug_log (infop, Receive, (add_to_buffer));
      
	  if ec = error_table_$timeout & eol_index ^= 0
	       then ec = 0;	         /* We can ignore this	      */

	  if ec = error_table_$line_status_pending
	       then do;
	       call process_line_status (infop);
	       end;
	  else if ec ^= 0 
	       then return;
	  /* strip the parity bits off the received packet	      */
	  call strip_parity (infop, add_to_buffer);
	  end;
       packet = substr (input_buffer, 1, eol_index - 1);
       input_buffer = substr (input_buffer, eol_index + 1);
       comm_info.input_buffer.bufferl = comm_info.input_buffer.bufferl - eol_index;
       
    /* find the start character in the received packet		*/
    
    start_index = index (packet, modes.start_ch);
    if start_index = 0 then packet = "";    /* Nothing there	      */
    else do;
         packet = substr (packet, start_index + 1);
         char_count = length(packet) + 2;
         start_index = index (input_buffer, modes.start_ch);
         if start_index > 0 then do;
	    eol_index = index (substr (input_buffer, start_index),
	         modes.eol_char);
	  /* if eol is a CR, check for a NL instead.  It may be translated.  */
	    if eol_index = 0 & modes.eol_char = CR
	         then eol_index = index (substr (input_buffer, start_index),
	         NL);
	    if eol_index > 0
	         then packet = "";   /* Discard it, check next packet   */
	    end;
         end;
  end;

end receive_packet;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


validate_checksum: proc (infop,	/* subsystem info pointer	*/
		     packet,	/* packet to be validated	*/
		     ec);		/* error code		*/
  
  /********************************************************************/
  /*							*/
  /*n	Name:	validate_checksum			internal	*/
  /*i	Input:	packet, info_ptr				*/
  /*f	Function:	calculates a checksum for the packet and compares	*/
  /*f		it with the checksum in the packet. If the	*/
  /*f		checksums match, the checksum is stripped from	*/
  /*f		the packet.				*/
  /*o	Output:	packet, error_code				*/
  /*							*/
  /*l	Written:	84-10-15	by Dean Elhard			*/
  /*							*/
  /********************************************************************/
  
  /* parameters */
  
  dcl infop		ptr;
  dcl packet		char (*) varying;
  dcl ec			fixed bin (35);
  
  /* automatic */
  
  dcl selector (1:1)	fixed bin;
  dcl ck_type		fixed bin (8) unaligned;
  dcl new_packet		char (Max_packet_size) varying;
  dcl received_checksum	char (3) varying;
  dcl calculated_checksum	char (3) varying;
  
  selector (1) = G_check_type;
  
  call kermit_mode_mgr_$retrieve (infop, Temporary, selector,
			addr (ck_type), ec);
  
  /* make sure there are enough characters in the packet to contain	*/
  /* a length, sequence number, and checksum			*/
  
  if length (packet) < ck_type + 2
    then do;
      ec = kermit_et_$mangled_packet;
      return;
    end;
    
  /* extract the portion of the packet excluding the checksum	*/
  
  new_packet = substr (packet, 1, length(packet)-ck_type);
  
  /* extract the transmitted checksum				*/
  
  received_checksum = substr (packet, length(packet)+1-ck_type, ck_type);
  
  /* calculate a checksum from the packet			*/
  
  call calculate_checksum (infop, new_packet, calculated_checksum, ec);
  if ec ^= 0
    then return;
    
  /* see if the calculated checksum matches the received checksum	*/
  
  if calculated_checksum ^= received_checksum
    then ec = kermit_et_$crc_error;
    
  packet = new_packet;
  
end validate_checksum;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


check_ctl_info: proc (infop,	/* subsystem info pointer		*/
		  packet,	/* packet to check			*/
		  seq_no,	/* sequence no extracted from packet	*/
		  ec);	/* error code			*/
  
  /********************************************************************/
  /*							*/
  /*n	Name:	check_ctl_info			internal	*/
  /*i	Input:	partial_packet, info_ptr			*/
  /*f	Function:	decodes the length and sequence_no from the	*/
  /*f		partial_packet and validates that the length is	*/
  /*f		correct and returns the sequence number		*/
  /*o	Output:	encoded_data, seq_no, error_code		*/
  /*							*/
  /*l	Written:	84-10-15	by Dean Elhard			*/
  /*							*/
  /********************************************************************/
  
  /* parameters */
  
  dcl infop		ptr;
  dcl packet		char (*) varying;
  dcl seq_no		fixed bin;
  dcl ec			fixed bin (35);
  
  /* automatic */
  
  dcl selector (1:1)	fixed bin;
  dcl ck_type		fixed bin (8) unaligned;
  dcl len			fixed bin;
  dcl check		fixed bin;
  dcl hcheck		fixed bin (9) unsigned;
  dcl packet_fix		char(3);  

  selector (1) = G_check_type;
  
  call kermit_mode_mgr_$retrieve (infop, Temporary, selector,
			addr (ck_type), ec);
  
  /* make sure the packet has enough characters to contain the length	*/
  /* byte and encoded sequence number				*/
  
  if length (packet) < 2
    then do;
      ec = kermit_et_$mangled_packet;
      return;
    end;
    
  /* decode the sequence number				*/
  
  seq_no = rank (substr (packet, 2, 1)) - Char_encoding_offset;
  
  /* check that the length byte matches the actual packet length	*/
  
  len = rank (substr (packet, 1, 1)) - Char_encoding_offset;
  if len = 0
       then do;		         /* extended packet header	      */
       check = rank (substr (packet, 1, 1)) + rank (substr (packet, 2, 1))
	   + rank (substr (packet, 3, 1)) + rank (substr (packet, 4, 1))
	   + rank (substr (packet, 5, 1));
       hcheck = mod(check + (mod (check, 256) / 64), 64);
       if hcheck ^= rank (substr (packet, 6, 1)) - Char_encoding_offset
	  then do;
	  ec = kermit_et_$mangled_packet;
	  return;
	  end;
       len = (rank (substr (packet, 4, 1)) - Char_encoding_offset) * 95
	  + rank (substr (packet, 5, 1)) - Char_encoding_offset;
       if len ^= length (packet) + ck_type - 6
	  then ec = kermit_et_$length_mismatch;
       packet_fix = packet;
       packet = substr (packet_fix, 3, 1) || substr (packet, 7);
       end;
  else do;
       if len ^= length (packet) + ck_type - 1
	  then ec = kermit_et_$length_mismatch;
       packet = substr (packet, 3);
       end;
  
  
end check_ctl_info;
    
/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


decode_data: proc (infop,	/* subsystem info pointer		*/
	         bufp,	/* decoded text buffer pointer	*/
	         bufl,	/* decoded text buffer length		*/
	         type,	/* packet type			*/
	         packet,	/* packet to be decoded		*/
	         rcvd,	/* received character count		*/
	         crnl_sw,	/* spanned CR/NL pair switch		*/
	         ec);	/* error code			*/
  
  /********************************************************************/
  /*							*/
  /*n	Name:	decode_data			internal	*/
  /*i	Input:	encoded_data, info_ptr			*/
  /*f	Function:	removes the prefix encoding characters and	*/
  /*f		returns the decoded text.			*/
  /*o	Output:	data					*/
  /*							*/
  /*l	Written:	84-10-15	by Dean Elhard			*/
  /*							*/
  /********************************************************************/
  
  /* parameters */
  
  dcl infop		ptr;
  dcl bufp		ptr;
  dcl bufl		fixed bin (21);
  dcl type		char (1);
  dcl packet		char (*) varying;
  dcl rcvd		fixed bin (21);
  dcl crnl_sw		bit (1);
  dcl ec			fixed bin (35);
  
  /* based */
  
  dcl buf			char (bufl) based (bufp);
  
  /* automatic */
  
  dcl pkt_len		fixed bin;
  dcl pkt_chr		fixed bin;
  dcl 01 capabilities	aligned,
       02 eight_bit		bit (1) unaligned,
       02 repeat		bit (1) unaligned,
       02 mbz		bit (34) unaligned;
  dcl t_selector (1:3)	fixed bin;
  dcl p_selector (1:2)	fixed bin;
  dcl 01 modes		aligned,
       02 quote		char (1) unaligned,
       02 eight_bit		char (1) unaligned,
       02 repeat		char (1) unaligned;
  dcl 01 perm_modes		aligned,
       02 line_byte_size	fixed bin (8) unaligned,
       02 file_type		char (1) unaligned;
  dcl sequence		char (Max_repeat_encoding) varying;
  dcl seql		fixed bin;
  
  rcvd = 0;
  pkt_len = length (packet);
  pkt_chr = 1;
  /* make sure we have something to decode			*/
  
  if pkt_len = 0
    then do;
      ec = kermit_et_$mangled_packet;
      return;
    end;
    
  /* extract the type from the packet				*/
  
  type = substr (packet, 1, 1);
  pkt_chr = 2;
  
  /* Do not decode send_init, server_init and ack packets.            */
  /* Decode receive_init packet only.                                 */
  
  if type = Send_init_packet_type |
/*     type = Receive_init_packet_type | * for compatibility with phx: */
     type = Server_init_packet_type |
     type = Ack_packet_type
    then do;
      rcvd = pkt_len - 1;
      substr (buf, 1, rcvd) = substr (packet, 2);
      return;
    end;
    
  t_selector (1) = I_quote_char;
  t_selector (2) = G_eight_bit_char;
  t_selector (3) = G_repeat_char;
  
  call kermit_mode_mgr_$retrieve (infop, Temporary, t_selector,
			addr (modes), ec);
  
  p_selector (1) = Line_byte_size;
  p_selector (2) = File_type;
  
  call kermit_mode_mgr_$retrieve (infop, Permanent, p_selector,
			addr (perm_modes), ec);
  
  string (capabilities) = ""b;
  
  /* calculate the capabilities from the prefix chars and file type	*/
  
  if modes.eight_bit ^= No_eight_bit_encoding &
     perm_modes.line_byte_size ^= Eight_bit_byte_size
    then capabilities.eight_bit = true;
  if modes.repeat ^= No_repeat_encoding
    then capabilities.repeat = true;
    
  do while (pkt_chr <= pkt_len);
    call decode_char (infop, packet, pkt_chr, pkt_len, sequence, modes.quote,
         			modes.eight_bit, modes.repeat,
         			string (capabilities), ec);
    if ec ^= 0
      then return;
      
    /* handle special decoding of CR/NL to nl and detection of	*/
    /* CR/NL sequences spanning multiple packets			*/
    
    if sequence = NL & perm_modes.file_type = Ascii_file_type
      then if rcvd = 0
        then crnl_sw = true;
        else if substr (buf, rcvd, 1) = CR
	then rcvd = rcvd - 1;
    
    /* append the decoded sequence to the buffer			*/
    
    seql = length (sequence);
    if rcvd + seql > bufl  then do;
      ec = kermit_et_$cannot_decode;
      return;
    end;
    substr (buf, rcvd+1, seql) = sequence;
    rcvd = rcvd + seql;
  end;
  
end decode_data;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


encode_char: proc (infop,		/* subsystem info pointer	*/
	         datap,		/* ptr to data to encode	*/
	         datal,		/* length of data to encode	*/
	         sequence,		/* resulting output sequence	*/
	         char_count,	/* number of chars encoded	*/
	         quote_ch,		/* control quote char	*/
	         eight_bit_ch,	/* 8-bit prefix char	*/
	         repeat_ch,		/* repeat prefix char	*/
	         capability_str);	/* capability flags		*/
  
  /********************************************************************/
  /*							*/
  /*n	Name:	encode_char			internal	*/
  /*i	Input:	info_ptr, data, quote_char, 8bit_char,		*/
  /*i		repeat_char				*/
  /*f	Function:	encodes the first character(s) in the data passed	*/
  /*f		returning the encoded sequence and the number of	*/
  /*f		characters encoded.				*/
  /*o	Output:	encoded_sequence, char_count			*/
  /*							*/
  /*l	Written:	84-10-15	by Dean Elhard			*/
  /*l	Modified:	84-11-15	by Dean Elhard for correct encoding of	*/
  /*l			8-bit characters over 8-bit lines	*/
  /*l	Modified:	85-03-26	by M. Mallmes for correct encoding of	*/
  /*l			8-bit characters over 8-bit lines	*/
  /*l			when optimized.			*/
  /*							*/
  /********************************************************************/
  
  /* parameters */
  
  dcl infop		ptr;
  dcl datap		ptr;
  dcl datal		fixed bin (21);
  dcl sequence		char (*) varying;
  dcl char_count		fixed bin;
  dcl quote_ch		char (1);
  dcl eight_bit_ch		char (1);
  dcl repeat_ch		char (1);
  dcl capability_str	bit (38) aligned;
  
/*  constants  */

  dcl Bit_8_mask		bit (9) aligned static options (constant) init ("200"b3);
  dcl Clear_bit_8		bit (9) aligned static options (constant) init ("577"b3);
  dcl Clear_bit_9		bit (9) aligned static options (constant) init ("377"b3);

  /* based */
  
  dcl data		char (datal) based (datap);
  dcl 01 capabilities	aligned based (addr (capability_str)),
       02 eight_bit		bit (1) unaligned,
       02 repeat		bit (1) unaligned,
       02 binary		bit (1) unaligned,
       02 raw		bit (1) unaligned,
       02 mbz		bit (32) unaligned;
  dcl char_to_code            char (1) aligned;
			
  /* automatic */
  
  dcl bit_8_value		bit (9) aligned;
  
  /* don't bother if there is no data */
  
  if datal = 0
    then return;
    
  char_to_code =  substr (data, 1, 1);
  
  /* clear the ninth bit if set */
  
  unspec (char_to_code) = (unspec (char_to_code) & Clear_bit_9);
  
  /* get the mask for the 8th bit  */

  bit_8_value = (unspec (char_to_code) & Bit_8_mask);

  /*  clear the 8th bit  */

  unspec (char_to_code) = (unspec (char_to_code) & Clear_bit_8);

  /* clear the eighth bit flag if we cannot send the eighth bit */
  
  if ^capabilities.raw & ^capabilities.eight_bit
    then bit_8_value = "0"b;
      
  if capabilities.eight_bit & (bit_8_value ^= "0"b)
    then sequence = eight_bit_ch;
    else sequence = "";
  
  /* see if we are encoding one of our prefix characters */
  
  if char_to_code = quote_ch |
     (char_to_code = eight_bit_ch & capabilities.eight_bit) |
     (char_to_code = repeat_ch & capabilities.repeat)
    then do;
      if capabilities.raw then unspec (char_to_code) = (unspec (char_to_code) | bit_8_value);
      sequence = sequence || quote_ch || char_to_code;
    end;
    
  /* see if we are encoding an newline character */
  
  else if rank (char_to_code) = NL_fixed & (bit_8_value = "0"b) &
	^capabilities.binary
    then sequence = quote_ch || "M" || quote_ch || "J";
    
  /* see if we are encoding a normal control character */
  
  else if rank (char_to_code) <= Ascii_ctl_limit
    then do;
      if capabilities.raw then unspec (char_to_code) = (unspec (char_to_code) | bit_8_value);
      sequence = sequence || quote_ch || ctl_encode  (rank (char_to_code));
    end;
    
  /* see if we are encoding a normal printing character */
  
  else if  rank (char_to_code) <= Ascii_printable_limit
    then do;
      if capabilities.raw then unspec (char_to_code) = (unspec (char_to_code) | bit_8_value);
      sequence = sequence || char_to_code;
    end;
    
  /* see if we are encoding a pad character (177 octal) */
  
  else if  rank (char_to_code) = Ascii_pad_char
    then do;
      if capabilities.raw then unspec (char_to_code) = (unspec (char_to_code) | bit_8_value);
      sequence = sequence || quote_ch || ctl_encode (rank (char_to_code));
    end;
    else sequence = sequence || char_to_code;
  
  char_count = verify (data, substr (data, 1, 1)) - 1;
  if char_count < 0
    then char_count = datal;
    
  /* don't try to repeat encode newlines due to special NL encoding */
  
  if rank (char_to_code) = NL_fixed & (bit_8_value = "0"b) & ^capabilities.binary
    then char_count = 1;
    
  /* limit encoding count to max representable repeat value */
  
  else if char_count > Max_repeat_encoding
    then char_count = Max_repeat_encoding;
    
  /* don't encode if there are not enough chars to make it worthwhile */
  
  if char_count > Min_repeat_encoding & capabilities.repeat
    then sequence = repeat_ch ||
		byte (char_count + Char_encoding_offset) || sequence;
    else char_count = 1;
    
end encode_char;


/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


set_parity: proc (infop,	/* subsystem info pointer		*/
	        packet);	/* packet to set parity on		*/
  
  /********************************************************************/
  /*							*/
  /*n	Name:	set_parity			internal	*/
  /*i	Input:	complete_packet, info_ptr			*/
  /*f	Function:	if mark or space parity is in effect, set the	*/
  /*f		eighth bit of each character in the packet	*/
  /*f		appropriately				*/
  /*o	Output:	complete_packet				*/
  /*							*/
  /*l	Written:	84-10-15	by Dean Elhard			*/
  /*							*/
  /********************************************************************/
  
  /* parameters */
  
  dcl infop		ptr;
  dcl packet		char (*) varying;
  
  /* automatic */
  
  dcl ec			fixed bin (35);
  dcl mask		bit (Max_packet_size * 9) varying;
  dcl parity		char (1) unal;
  dcl selector (1:1)	fixed bin init (G_parity);
  dcl workspace		bit (Max_packet_size * 9) varying;
  dcl 01 wksp_overlay	based (addr (workspace)),
       02 len		fixed bin (24),
       02 chars		char (Max_packet_size);
  
  /* get the prevailing parity				*/
  
  call kermit_mode_mgr_$retrieve (infop, Temporary, selector,
			addr (parity), ec);
  
  /* ***** NB. kludge to get around PL/I padded-reference bug ***** */
  
  if rank (parity) = rank (Mark_parity) | rank (parity) = rank (Space_parity)
    then do;
      wksp_overlay.chars = packet;
      wksp_overlay.len = 9 * length (packet);
      mask = copy ("200"b3, length (packet));
  
  /* ***** NB. kludge to get around PL/I padded-reference bug ***** */
  
      if rank (parity) = rank (Mark_parity)
        then workspace = workspace | mask;
        else workspace = workspace & ^mask;
      packet = substr (wksp_overlay.chars, 1, length (packet));
    end;
    
end set_parity;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


strip_parity: proc (infop,	/* subsystem info pointer		*/
	          packet);	/* packet to strip parity from	*/
  
  /********************************************************************/
  /*							*/
  /*n	Name:	strip_parity			internal	*/
  /*i	Input:	complete_packet, info_ptr			*/
  /*f	Function:	zeroes the parity bits on an incoming packet	*/
  /*o	Output:	complete_packet				*/
  /*							*/
  /*l	Written:	84-10-15	by Dean Elhard			*/
  /*							*/
  /********************************************************************/
  
  /* parameters */
  
  dcl infop		ptr;
  dcl packet		char (*);
  
  /* automatic */
  
  dcl selector (1:1)	fixed bin init (G_parity);
  dcl parity		char (1) unal;
  dcl workspace		bit (length (packet) * 9) based (addr (packet));
  dcl ec			fixed bin (35);
  
  call kermit_mode_mgr_$retrieve (infop, Temporary, selector,
			addr (parity), ec);
  
  /* for anything except "No Parity", strip the parity bit */
  
  /* ***** NB. kludge to get around PL/I padded-reference bug ***** */
  
  if rank (parity) ^= rank (No_parity)
    then workspace = bool(workspace, copy("600"b3, length(packet)), "0010"b);
    else workspace = bool(workspace, copy("400"b3, length(packet)), "0010"b);
  
end strip_parity;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


decode_char: proc (infop,		/* subsystem info pointer	*/
	         packet,		/* packet to decode from	*/
	         pkt_chr,		/* offset in packet		*/
	         pkt_len,		/* packet length		*/
	         sequence,		/* decoded character sequence	*/
	         quote_ch,		/* control quote character	*/
	         eight_bit_ch,	/* 8 bit prefix character	*/
	         repeat_ch,		/* repeat prefix character	*/
	         capability_str,	/* decode capability string	*/
	         ec);		/* error code		*/
  
  /********************************************************************/
  /*							*/
  /*n	Name:	decode_char			internal	*/
  /*i	Input:	info_ptr, packet, quote_char, 8bit_char,	*/
  /*i		repeat_char, capabilities			*/
  /*f	Function:	decodes the first sequence in the packet based	*/
  /*f		on the current capabilities and prefix chars	*/
  /*f		and returns the resulting sequence.  The encoded	*/
  /*f		sequence is stripped from the start of the packet	*/
  /*o	Output:	decoded_sequence, packet, error_code		*/
  /*							*/
  /*l	Written:	84-10-23	by Dean Elhard			*/
  /*l	Modified:	84-10-28	by Dean Elhard to fix decoding of	*/
  /*l			prefix characters			*/
  /*l	Modified:	84-11-15	by Dean Elhard for correct decoding of	*/
  /*l			8-bit characters over 8-bit lines	*/
  /*							*/
  /********************************************************************/
  
  /* parameters */
  
  dcl infop		ptr;
  dcl packet		char (*) varying;
  dcl (pkt_chr, pkt_len)	fixed bin;
  dcl sequence		char (*) varying;
  dcl quote_ch		char (1);
  dcl eight_bit_ch		char (1);
  dcl repeat_ch		char (1);
  dcl capability_str	bit (36) aligned;
  dcl ec			fixed bin (35);
  
  /* based */
  
  dcl 01 capabilities	aligned based (addr (capability_str)),
       02 eight_bit		bit (1) unaligned,
       02 repeat		bit (1) unaligned,
       02 mbz		bit (34) unaligned;
  dcl 01 char_overlay	unaligned based (addr (decoded_char)),
       02 bit_9		bit (1) unaligned,
       02 bit_8		bit (1) unaligned,
       02 ascii_bits	bit (7) unaligned;
  dcl 01 seven_bit_overlay	unaligned based (addr (seven_bit_char)),
       02 bit_9		bit (1) unaligned,
       02 bit_8		bit (1) unaligned,
       02 ascii_bits	bit (7) unaligned;
  
  /* automatic */
  
  dcl repeat_count		fixed bin;
  dcl set_eighth_bit	bit (1);
  dcl seven_bit_char	char (1);
  dcl control_decode	bit (1);
  dcl decoded_char		char (1);
  
  /* check if there is a repeat prefix on the sequence		*/
  
  if capabilities.repeat & substr (packet, pkt_chr, 1) = repeat_ch
    then do;
      
      /* if there are not enough chars in the packet for a repeat	*/
      /* sequence, abort the packet decodeing			*/
      
      if pkt_len - pkt_chr < 2
        then do;
	ec = kermit_et_$cannot_decode;
	return;
        end;
        
      /* decode the repeat count and strip the prefix and count	*/
      
      repeat_count = rank (substr (packet, pkt_chr + 1, 1)) - Char_encoding_offset;
      pkt_chr = pkt_chr + 2;
    end;
    else repeat_count = 1;
  
  /* see if there is an eight-bit prefix on the sequence		*/
  
  if capabilities.eight_bit & substr (packet, pkt_chr, 1) = eight_bit_ch
    then do;
      
      /* if there are not enought characters in the packet for a	*/
      /* eight-bit prefixed sequence, then yell			*/
      
      if pkt_len - pkt_chr < 1
        then do;
	ec = kermit_et_$cannot_decode;
	return;
        end;
        
      /* set the eight-bit flag and strip the prefix		*/
      
      set_eighth_bit = true;
      pkt_chr = pkt_chr + 1;
    end;
    else set_eighth_bit = false;
  
  /* see if there is a control prefix on the sequence		*/
  
  if substr (packet, pkt_chr, 1) = quote_ch
    then do;
      
      /* if there are not enough characters in the packet to contain	*/
      /* a valid control-prefixed sequence, then yell		*/
      
      if pkt_len - pkt_chr < 1
        then do;
	ec = kermit_et_$cannot_decode;
	return;
        end;
        
      /* set the flag indicating that control decoding is required	*/
      /* and strip the control prefix from the packet		*/
      
      control_decode = true;
      pkt_chr = pkt_chr + 1;
    end;
    else control_decode = false;
  
  /* extract the target character of the sequence from the packet	*/
  
  decoded_char = substr (packet, pkt_chr, 1);
  pkt_chr = pkt_chr + 1;
  
  seven_bit_char = decoded_char;
  seven_bit_overlay.bit_8 = false;
  
  /* perform control decoding if required special casing control	*/
  /* encoded prefix characters				*/
  
  if control_decode
    then if (seven_bit_char ^= quote_ch) &
	  ((seven_bit_char ^= eight_bit_ch) | ^capabilities.eight_bit) &
	  ((seven_bit_char ^= repeat_ch) | ^capabilities.repeat)
      then decoded_char = ctl_encode (rank (decoded_char));
    
  /* perform eight-bit decoding if required			*/
  
  if set_eighth_bit
    then char_overlay.bit_8 = true;
    
  /* copy the character as required by repeat prefixing		*/
  
  sequence = copy (decoded_char, repeat_count);
  
end decode_char;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


calculate_checksum: proc (infop,	/* subsystem info pointer	*/
		      packet,	/* packet do calc cksum for	*/
		      checksum,	/* calculated checksum	*/
		      ec);	/* error code		*/
  
  /********************************************************************/
  /*							*/
  /*n	Name:	calculate_checksum			internal	*/
  /*i	Input:	packet, info_ptr				*/
  /*f	Function:	calculates the checksum based on the prevailing	*/
  /*f		checksum type and returns the character sequence	*/
  /*f		representing the checksum			*/
  /*o	Output:	checksum, error_code			*/
  /*							*/
  /*l	Written:	84-10-15	by Dean Elhard			*/
  /*							*/
  /********************************************************************/
  
  /* parameters */
  
  dcl infop		ptr;
  dcl packet		char (*) varying;
  dcl checksum		char (*) varying;
  dcl ec			fixed bin (35);
  
  /* automatic */
  
  dcl check_type		fixed bin (8) unal;
  dcl i			fixed bin;
  dcl selector (1:1)	fixed bin init (G_check_type);
  dcl six_seven_mask	bit (36) aligned static options (constant)
			     init ("000000000300"b3);
  dcl sum			fixed bin (35) aligned;
  dcl sum_bits		bit (36) aligned based (addr (sum));
  dcl zero_five_mask	bit (36) aligned static options (constant)
			     init ("000000000077"b3);
  
  /* get the current checksum type				*/
  
  call kermit_mode_mgr_$retrieve (infop, Temporary, selector,
			addr (check_type), 0);
  
  ec = 0;
  
  /* check type 1  -  single character encoded checksum		*/
  
  if check_type = 1
    then do;
      sum = 0;
      
      /* sum the ascii values of the packet			*/
      
      do i = 1 to length (packet);
        sum = sum + rank (substr (packet, i, 1));
      end;
      
      /* adjust the checksum into a 6 bit value			*/
      
      sum = sum + (bin (sum_bits & six_seven_mask) / 64);
      sum_bits = sum_bits & zero_five_mask;
      
      /* encode the checksum into a printable ascii character	*/
      
      checksum = byte (sum + Char_encoding_offset);
    end;
    
  /* no other checksum types are currently supported		*/
  
    else ec = kermit_et_$unimplemented_check_type;
  
end calculate_checksum;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


ctl_encode: proc (value_to_encode) returns (char (1)) reducible;
  
  /********************************************************************/
  /*							*/
  /*n	Name:	ctl_encode			internal	*/
  /*i	Input:	ascii_value				*/
  /*f	Function:	performs the kermit ctl() encoding function which	*/
  /*f		toggles bit 7 in the specified value.		*/
  /*o	Output:	encoded_char				*/
  /*							*/
  /*l	Written:	84-10-18	by Dean Elhard			*/
  /*							*/
  /********************************************************************/
  
  /* parameters */
  
  dcl value_to_encode	fixed bin (35) aligned;
  
  /* based */
  
  dcl bit_overlay		bit (36) aligned based (addr (value_to_encode));
  dcl 01 char_overlay	aligned based (addr (encoded_value)),
       02 pad		char (3) unaligned,
       02 encoded_char	char (1) unaligned;
  
  /* automatic */
  
  dcl encoded_value		bit (36) aligned;
  
  /* control encode by XORing the ascii value with 64		*/
  
  encoded_value = bool (bit_overlay, "000000000100"b3, "0110"b);
  
  return (char_overlay.encoded_char);
  
end ctl_encode;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


process_line_status: proc (infop);
  
  /********************************************************************/
  /*							*/
  /*n	Name:	process_line_status			internal	*/
  /*i	Input:	info_ptr					*/
  /*f	Function:	clears the line status on the file transfer	*/
  /*f		switch.					*/
  /*o	Output:	none					*/
  /*							*/
  /*l	Written:	84-11-05	by Dean Elhard			*/
  /*							*/
  /********************************************************************/
  
  /* parameters */
  
  dcl infop		ptr;
  
  /* based */
  
  dcl 01 info		aligned like kermit_info based (infop);
  dcl 01 comm_info		aligned like kermit_comm_info
			     based (info.comm_infop);
  
  /* automatic */
  
  dcl ls_data		bit (72) aligned;
  dcl ec			fixed bin (35);
  
  call iox_$control (comm_info.ft_iocbp, "line_status", addr (ls_data), ec);
  
end process_line_status;

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */

/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */


debug_log: proc (infop, direction, data);
  
  /********************************************************************/
  /*  							*/
  /*n	Name:	debug_log				internal	*/
  /*i	Input:	info_ptr, direction, packet_data		*/
  /*f	Function:	logs the packet traffic in a segment to aid in	*/
  /*f		debugging.				*/
  /*o	Output:	none					*/
  /*							*/
  /*l	Written:	84-11-15	by Dean Elhard			*/
  /*							*/
  /********************************************************************/
  
  /* parameters */
  
  dcl infop		ptr;
  dcl direction		char (1);
  dcl data		char (*);
  
  /* based */
  
  dcl 01 info		aligned like kermit_info based (infop);
  dcl 01 comm_info		aligned like kermit_comm_info
			     based (info.comm_infop);
  
  /* automatic */
  
  dcl str			char (4000);
  
  /* insert direction marker					*/
  str = direction || data || NL;
  call iox_$put_chars (comm_info.debug_segp, addr (str), length (rtrim (str)), ec);

end debug_log;

end kermit_pad_;
