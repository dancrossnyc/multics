/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   * Copyright (c) 1972 by Massachusetts Institute of        *
   * Technology and Honeywell Information Systems, Inc.      *
   *                                                         *
   *********************************************************** */

/* DESCRIPTION:
   Format a PL/I program given a list of tokens and statements.  For most
   statements, as much of the statement is put on a line as possible.  If a
   statement will not fit on one line, parenthesis nesting and the precedence
   of each token is used to determine where to break the statement across
   lines.  This default formatting is done by format_other.  Most of this
   program handles special cases that format_other would not format correctly.
   Some token types are changed by format_pl1_stmt_type_ because some tokens
   require different precedences in different contexts.  This procedure
   assumes the token type needs no further refinement.  The steps are:

   1) Convert a statement into items.  Items are tokens and comments.  The
   item structure has many fields that facilitate formatting.
   2) Figure out how to format the statement by modifying the item structure.
   3) Copy the items for a statement into the output string using the item
   structure control information.
   4) This procedure keeps track of the syntactic nesting of the program in
   the unit_stack.  The unit_stack is kept current after each statement by
   adjust_unit_stack.

   Maintenance Instructions:

   To add another token type:

   1) Add an entry to the precedence array.
   2) Add entries to the last_space_class and this_space_class arrays
   in make_items.  If necessary, add entries to the space_table
   array in make_items.

   To add another PL/I statement:

   1) If the statement needs special formatting, change
   format_one_statement.

   To add another macro:

   1) If the macro needs special formatting, change
   format_one_statement.

   To add another declare statement attribute:

   1) If the attribute consists of an identifier or an identifier
   followed by something in parentheses, and no special formatting
   is needed, no change is necessary.  Otherwise, change
   attribute_set.

   To add another formatting mode:

   1) Change the style stucture in format_pl1_dcls.incl.pl1 to include
   space for the new mode.
   2) Add a declaration that starts with "mode_" to
   format_pl1_dcls.incl.pl1 to reference the mode in the current
   style.  This declaration is used only by this procedure.
   3) For a switch mode, add entries to the switch_mode_names and
   switch_antonym_names arrays.  For a value mode, add an entry to
   the value_mode_names array.  These arrays are in
   format_pl1_dcls.incl.pl1.
   4) Add a default value for the new mode in each style in the styles
   array of structures in format_pl1_dcls.incl.pl1.
   5) Change this procedure to use the new "mode_" declaration.

   To add another numbered style:

   1) Add new entries to the styles array of structures in
   format_pl1_dcls.incl.pl1 that defines a default value for each
   mode in the new style.
*/

/* HISTORY:
Written by Paul Green, 11/01/77.
Rewritten by Monte Davidoff, 07/17/78.
Modified:
09/03/83 by Jim Lippard:  to not go into an infinite loop on
            "dcl a defined (b;".
06/05/84 by R. Michael Tague:  Handle the % macro statments of pmac.  Changed
            pop_unit so that a multiple closure error message will be printed
            when a labeled end statement is used to close a %if or %else
            statement instead of the proper closure with a %endif.
            Added the elsedo formatting option.
11/15/84 by R. Michael Tague:  Changed the formatting of "else if" to always
            place the if statement exactly one space after the else.
02/12/85 by R. Michael Tague:  Changed comparisons with percent_statement to
            use the is_macro_statement.  This was a bug, I should have changed 
            it 06/05/84.  Fixed so that the trailing comma that comes after
            a literal will stay on the line with the literal when the literal
	  is the only thing on the line but still the line is too long.
*/

/* format: style5,^indcomtxt */

format_pl1_:
        procedure (P_temp_segs);

        declare P_temp_segs		(*) pointer;    /* (Input) array of temporary segment pointers */

/* automatic */

        declare copy_position		fixed binary (21);
					      /* index in output segment of next character to write */
        declare item_ptr		pointer;	      /* pointer to base of item array */
        declare left_margin		fixed binary;   /* current indentation level column */
        declare line_position		fixed binary;   /* column next character will be written into */
        declare looked_ahead		bit (1) aligned;/* on if next statement will fit on the current line */
        declare off_region_ptr	pointer;	      /* pointer to first character not to format */
        declare text_after_end_msg	bit (1) aligned;/* on if printed text after end of program message */
        declare unit_stack_index	fixed binary;   /* number of entries in unit stack */
        declare unit_stack_ptr	pointer;	      /* pointer to base of unit_stack */

/* based */

        declare 1 item		(
				divide (sys_info$max_seg_size
				- binary (rel (item_ptr), 18), 5, 17))
				aligned based (item_ptr),
	        2 string_size	fixed binary (21) unaligned,
	        2 comment_ind_len	fixed binary (3) unsigned unaligned,
	        2 pad1		bit (2) unaligned,
	        2 type		fixed binary (8) unaligned,
	        2 string_ptr	pointer unaligned,
	        2 paren_depth	fixed binary (8) unaligned,
	        2 precedence	fixed binary (9) unsigned unaligned,
	        2 last_col		fixed binary (17) unaligned,
	        2 next_token	fixed binary (17) unaligned,
	        2 header		unaligned,
		3 tab		bit (1),
		3 need_space	fixed binary (1) unsigned,
		3 tab_blkcom	bit (1),
		3 insnl		bit (1),
		3 pad2		bit (5),
		3 amount		fixed binary (9) unsigned,
	        2 trailer		unaligned,
		3 NP		bit (1),
		3 pad3		bit (8),
		3 VTs		fixed binary (9) unsigned,
		3 NLs		fixed binary (9) unsigned,
	        2 flags		unaligned,
		3 control_comment	bit (1),
		3 gave_error_msg	bit (1),
		3 indcomtxt	bit (1),
		3 pad4		bit (6);

        declare 1 unit_stack		(
				divide (sys_info$max_seg_size
				- binary (rel (unit_stack_ptr), 18), 4,
				17)) aligned based (unit_stack_ptr),
	        2 type		fixed binary (17) unaligned,
	        2 label_start	fixed binary (17) unaligned,
	        2 label_end		fixed binary (17) unaligned,
	        2 close_left_margin	fixed binary (17) unaligned,
	        2 previous_left_margin
				fixed binary (17) unaligned,
	        2 flags		unaligned,
		3 case		bit (1),
		3 in_else_clause	bit (1),
		3 pad		bit (16),
	        2 construct_ptr	pointer unaligned;

/* builtin */

        declare (addr, after, before, binary, copy, divide, hbound, index,
	      length, ltrim, max, min, null, rel, reverse, rtrim, search,
	      size, substr, unspec, verify)
				builtin;

/* internal static */

        declare close_comment		char (2) internal static
				options (constant) initial ("*/");
        declare open_comment		char (2) internal static
				options (constant) initial ("/*");
        declare tab_interval		fixed binary (4) internal static
				options (constant) initial (10);

        declare (
	      NO_UNIT		initial (0),
	      BEGIN_UNIT		initial (1),
	      DO_UNIT		initial (2),
	      PROCEDURE_UNIT	initial (3),
	      IF_UNIT		initial (4),
	      ELSE_UNIT		initial (5),
	      ON_UNIT		initial (6),
	      PERCENT_IF_UNIT	initial (7)
	      )			fixed binary internal static
				options (constant);

        declare BS			char (1) internal static
				options (constant) initial ("");
        declare HT			char (1) internal static
				options (constant) initial ("	");
        declare HT_BS_NL_VT_NP	char (5) internal static
				options (constant) initial ("	
");
        declare HT_SP		char (2) internal static
				options (constant) initial ("	 ");

        declare precedence		(0:53) fixed binary (9)
				unsigned internal static
				options (constant) initial (15,
					      /* no_token */
				15,	      /* invalid_char */
				15,	      /* identifier */
				3,	      /* keyword_token */
				15,	      /* isub */
				10,	      /* infix + */
				10,	      /* infix - */
				11,	      /* * */
				11,	      /* / */
				12,	      /* ** */
				12,	      /* ^ */
				7,	      /* & */
				6,	      /* | */
				9,	      /* || */
				8,	      /* = */
				8,	      /* ^= */
				8,	      /* < */
				8,	      /* > */
				8,	      /* <= */
				8,	      /* >= */
				8,	      /* ^> */
				8,	      /* ^< */
				12,	      /* prefix + */
				12,	      /* prefix - */
				4,	      /* assignment */
				15,	      /* : */
				15,	      /* ; */
				2,	      /* , */
				14,	      /* . */
				13,	      /* -> */
				17,	      /* ( */
				1,	      /* ) */
				15,	      /* % */
				5,	      /* target , */
				16,	      /* comment */
				0,	      /* nl_vt_np_token */
				(18) 15);	      /* constants */

        declare HT_SP_NL_VT_NP	char (5) internal static
				options (constant) initial ("	 
");
        declare NL			char (1) internal static
				options (constant) initial ("
");
        declare NP			char (1) internal static
				options (constant) initial ("");
        declare SP			char (1) internal static
				options (constant) initial ("");
        declare VT			char (1) internal static
				options (constant) initial ("");

/* entry */

        declare ioa_		entry options (variable);

        declare char_offset_		entry (pointer)
				returns (fixed binary (21)) reducible;

/* more internal static */

        declare NL_VT_NP		char (3) internal static
				options (constant) initial ("
");
%include format_pl1_dcls;

/* program */

        temp_segs (*) = P_temp_segs (*);
        global.output_length = 0;

        copy_position = 1;
        line_position = 1;
        looked_ahead = "0"b;
        text_after_end_msg = "0"b;

        unit_stack_ptr = addr (token (global.n_tokens + 2));
        unspec (unit_stack (1)) = ""b;
        unit_stack (1).type = NO_UNIT;
        unit_stack_index = 1;

        item_ptr = addr (stmt (global.n_stmts + 2));
        unspec (item (1)) = ""b;
        item (1).type = no_token;
        item (1).string_ptr = null;
        item (1).trailer.NLs = 1;

        begin;
	      declare n_items	        fixed binary;
	      declare prevailing_style_item   fixed binary;

	      left_margin = 1;
	      n_items = 1;
	      call make_items (1, 1, "1"b, "0"b, n_items);
	      call set_prevailing_style (n_items, prevailing_style_item);

	      if global.ca.long
		& unspec (global.prevailing_style)
		^= unspec (global.command_line_style) then
		    call format_pl1_long_ (temp_segs (*),
		        (item (prevailing_style_item).string_ptr));

	      n_items = 1;
	      call make_items (1, 1, "1"b, "1"b, n_items);

	      if prevailing_style_item <= n_items then
		    if global.ca.force then
			  call delete_and_record_new_prevailing_style_comment
			      (prevailing_style_item, n_items);
		    else
			  call copy_items (2, n_items);

	      else
		    do;
		    call copy_items (2, n_items);
		    call record_style;
		    end;
        end;

        begin;
	      declare last_stmt_type	        fixed binary (8);
	      declare stmtx		        fixed binary;

	      last_stmt_type = unknown_statement;
	      stmtx = 2;
	      do while (stmtx <= global.n_stmts);
		    call format_one_statement (stmtx, last_stmt_type);
	      end;
        end;

        if off_region_ptr ^= null then
	      call copy_off_region (global.source_length);

        do unit_stack_index = unit_stack_index to 2 by -1;
	      if (unit_stack (unit_stack_index).type = BEGIN_UNIT
		| unit_stack (unit_stack_index).type = DO_UNIT
		| unit_stack (unit_stack_index).type = PROCEDURE_UNIT)
		& (^global.rdc_source | unit_stack_index > 2) then
		    call error (3, "Missing end statement.",
		        unit_stack (unit_stack_index).construct_ptr);

	      else if unit_stack (unit_stack_index).type = PERCENT_IF_UNIT
		then
		    call error (3, "Missing %endif macro.",
		        unit_stack (unit_stack_index).construct_ptr);
        end;

unrecoverable_error:
        global.output_length = copy_position - 1;

        return;

/* Find the prevailing style comment and set the prevailing style. */

set_prevailing_style:
        procedure (n_items, prevailing_style_item);

        declare n_items		fixed binary;   /* (Input) index of last item before the first token */
        declare prevailing_style_item	fixed binary;   /* (Output) index of prevailing style comment,
					         or n_items + 1 if none */

        declare item_string		char (item (prevailing_style_item)
				.string_size)
				based (item (prevailing_style_item)
				.string_ptr);

        do prevailing_style_item = 2 to n_items
	  while (^item (prevailing_style_item).control_comment);
        end;

        if prevailing_style_item <= n_items then
	      call format_pl1_modes_ (temp_segs (*),
		before (after (item_string, control_comment_indicator),
		close_comment), addr (item_string), "0"b,
		item (prevailing_style_item).gave_error_msg);

        else if global.ca.require_style_comment then
	      call error (2,
		"Program does not already contain a prevailing style control comment.",
		null);

        if global.ca.force then
	      begin;
	      declare 1 control_com_style     aligned like style;

	      declare command_line_modes      char (global.modes_length)
				        based (global.modes_ptr);

	      control_com_style = global.current_style;
	      call format_pl1_modes_ (temp_segs (*), command_line_modes, null,
		"0"b, "1"b);

	      if unspec (control_com_style) = unspec (global.current_style)
		then
		    global.ca.force = "0"b;
	      end;

        global.prevailing_style = global.current_style;
        left_margin = mode_initcol;

        if mode_on then
	      off_region_ptr = null;
        else
	      off_region_ptr = global.source_ptr;
        end set_prevailing_style;

/* Delete an existing prevailing style control comment and optionally record a new one. */

delete_and_record_new_prevailing_style_comment:
        procedure (prevailing_style_item, n_items);

        declare prevailing_style_item	fixed binary;   /* (Input) index of prevailing style comment */
        declare n_items		fixed binary;   /* (Input) index of last item before the first token */

        call copy_items (2, prevailing_style_item - 1);

        if off_region_ptr = null then
	      call record_style;

        else
	      do;
	      call copy_off_region (
		char_offset_ ((item (prevailing_style_item).string_ptr)));
	      call record_style;

	      if prevailing_style_item < n_items then
		    off_region_ptr =
		        item (prevailing_style_item + 1).string_ptr;

	      else if global.n_tokens > 1 then
		    off_region_ptr = token (2).string_ptr;
	      end;

        call copy_items (prevailing_style_item + 1, n_items);
        end delete_and_record_new_prevailing_style_comment;

/* Record the prevailing style in the output segment. */

record_style:
        procedure;

        if ^global.ca.record_style then
	      return;

        if off_region_ptr = null then
	      call format_pl1_record_style_ (temp_segs (*), copy_position,
		line_position);

        else if global.n_tokens <= 1 then
	      do;
	      call copy_off_region (global.source_length);
	      call format_pl1_record_style_ (temp_segs (*), copy_position,
		line_position);
	      end;

        else
	      do;
	      call copy_off_region (char_offset_ ((token (2).string_ptr)));
	      call format_pl1_record_style_ (temp_segs (*), copy_position,
		line_position);
	      off_region_ptr = token (2).string_ptr;
	      end;
        end record_style;

/* Format a statement. */

format_one_statement:
        procedure (stmtx, last_stmt_type);

        declare stmtx		fixed binary;   /* (Updated) statement to format */
        declare last_stmt_type	fixed binary (8);
					      /* (Updated) type of the last statement */

        declare n_items		fixed binary;
        declare label_start		fixed binary;
        declare label_end		fixed binary;
        declare last_stmt_item	fixed binary;
        declare stmt_type		fixed binary (8);

        if stmt (stmtx).type = condition_prefix_list then
	      do;
	      call format_prefix_list (stmtx);
	      if stmtx > global.n_stmts then
		    return;
	      end;

        if stmt (stmtx).type = label_prefix_list then
	      do;
	      label_start = stmt (stmtx).start;
	      label_end = stmt (stmtx).end;

	      call format_prefix_list (stmtx);
	      if stmtx > global.n_stmts then
		    return;
	      end;

        else
	      do;
	      label_start = 0;
	      label_end = 0;
	      end;

        stmt_type = stmt (stmtx).type;
        call convert_stmt_to_items (stmtx, 1, "0"b, n_items);

        if stmt_type = assignment_statement then
	      call format_assignment (n_items);

        else if stmt_type = begin_statement then
	      call format_begin (n_items, last_stmt_type, label_start,
		label_end);

        else if stmt_type = declare_statement then
	      call format_declare (n_items);

        else if stmt_type = do_statement then
	      call format_do (n_items, last_stmt_type, label_start, label_end)
		;

        else if stmt_type = end_statement then
	      call format_end (n_items);

        else if stmt_type = if_statement then
	      call format_if (last_stmt_type, n_items);

        else if stmt_type = else_clause then
	      call format_else (n_items);

        else if stmt_type = on_statement then
	      call format_on (n_items);

        else if stmt_type = procedure_statement then
	      call format_procedure (n_items, label_start, label_end);

        else if stmt_type = entry_statement then
	      call format_entry (n_items);

        else if stmt_type = percent_if_statement then
	      call format_percent_if_macros (n_items, "1"b, "1"b, "1"b);

        else if stmt_type = percent_elseif_statement then
	      call format_percent_if_macros (n_items, "0"b, "1"b, "1"b);

        else if stmt_type = percent_else_statement then
	      call format_percent_if_macros (n_items, "0"b, "1"b, "0"b);

        else if stmt_type = percent_endif_statement then
	      call format_percent_if_macros (n_items, "0"b, "0"b, "0"b);

        else if is_macro_statement (stmt_type) then
	      call format_other (2, n_items, 1, mode_lineconind, "1"b);

        else
	      call format_other (2, n_items, left_margin, mode_lineconind,
		"1"b);

        do last_stmt_item = n_items by -1
	  while (item (last_stmt_item).type = comment_token);
        end;

        call copy_items (2, last_stmt_item);

        if ^is_macro_whitespace (stmt_type) then
	      do;
	      call adjust_unit_stack (stmt_type, next_statement (stmtx));
	      last_stmt_type = stmt_type;
	      end;

        call copy_items (last_stmt_item + 1, n_items);

        stmtx = stmtx + 1;

        return;

format_prefix_list:
        procedure (stmtx);

        declare stmtx		fixed binary;   /* (Updated) prefix list to format */

        declare first_prefix_item	fixed binary;
        declare itemx		fixed binary;
        declare n_items		fixed binary;

        call convert_stmt_to_items (stmtx, 1, "0"b, n_items);

        do first_prefix_item = 2 repeat itemx + 1
	  while (first_prefix_item <= n_items);
	      item (first_prefix_item).header.need_space = 1;

	      do itemx = first_prefix_item to n_items
		while (item (itemx).type ^= colon);
	      end;

	      do itemx = itemx to n_items
		while (item (itemx + 1).type = comment_token);
		    call insert_tab (itemx + 1, mode_comcol);
	      end;

	      if stmt (stmtx).type = condition_prefix_list then
		    call format_other (first_prefix_item, itemx, 1, 0, "1"b)
		        ;
	      else
		    call format_other (first_prefix_item, itemx, 1,
		        mode_lineconind, "1"b);
        end;

        call copy_items (2, n_items);
        stmtx = stmtx + 1;
        end format_prefix_list;

/* Convert the tokens in a statement to items. */

convert_stmt_to_items:
        procedure (P_stmtx, initial_itemx, P_reconverting, P_itemx);

        declare P_stmtx		fixed binary;   /* (Input) statement to convert */
        declare initial_itemx		fixed binary;   /* (Input) last used item */
        declare P_reconverting	bit (1) aligned;/* (Input) on if stmt has already been converted in place */
        declare P_itemx		fixed binary;   /* (Output) last item that was converted */

        declare first_in_item_array	bit (1) aligned;
        declare itemx		fixed binary;
        declare reconverting		bit (1) aligned;
        declare stmtx		fixed binary;
        declare tokenx		fixed binary;

        stmtx = P_stmtx;
        itemx = initial_itemx;
        first_in_item_array = initial_itemx = 1;
        reconverting = P_reconverting;

        do tokenx = stmt (stmtx).start to stmt (stmtx).end;
	      call make_items (stmtx, tokenx, first_in_item_array,
		reconverting, itemx);
        end;

        P_itemx = itemx;

        item (initial_itemx + 1).header.need_space = 1;
        item (initial_itemx + 1).header.amount = 1;

        if itemx >= hbound (item, 1) then
	      call error (4, "Too many tokens and comments in a statement.",
		item (itemx).string_ptr);

        unspec (item (itemx + 1)) = ""b;
        item (itemx + 1).type = no_token;
        item (itemx + 1).string_ptr = token (stmt (stmtx).end + 1).string_ptr;

        if first_in_item_array & ^reconverting
	  & stmt (stmtx).type ^= unknown_statement
	  & (token (stmt (stmtx).end).type = semi_colon
	  | ^is_macro_statement (stmt (stmtx + 1).type)
	  | is_macro_whitespace (stmt (stmtx + 1).type)) then
	      if item (itemx).paren_depth > 1
		| item (itemx).paren_depth = 1
		& item (itemx).type ^= right_parn then
		    call error (2, "Missing right parenthesis.",
		        item (2).string_ptr);

	      else if item (itemx).paren_depth < 0
		| item (itemx).paren_depth = 0
		& item (itemx).type = right_parn then
		    call error (2, "Missing left parenthesis.",
		        item (2).string_ptr);
        end convert_stmt_to_items;

/* Adjust the unit stack for the next statement. */

adjust_unit_stack:
        procedure (last_stmt_type, stmtx);

        declare last_stmt_type	fixed binary (8);
					      /* (Input) type of the last statement */
        declare stmtx		fixed binary;   /* (Input) index of the next statement */

        if unit_stack (unit_stack_index).type = ON_UNIT
	  & (last_stmt_type ^= on_statement
	  | stmt (stmtx).type = on_statement
	  | stmt (stmtx).type = if_statement) then
	      call pop_unit (0, left_margin, left_margin);

        if last_stmt_type ^= if_statement & last_stmt_type ^= else_clause then
	      if stmt (stmtx).type = else_clause then
		    begin;		      /* pop unit stack through matching then */
		    declare loop		      bit (1) aligned;

		    loop = "1"b;
		    do while (loop);
			  if unit_stack (unit_stack_index).type = IF_UNIT
			      then
				do;
				loop = "0"b;
				unit_stack (unit_stack_index).type =
				    ELSE_UNIT;
				left_margin =
				    unit_stack (unit_stack_index)
				    .close_left_margin;

				if (^unit_stack (unit_stack_index).case
				    |
				    ^unit_stack (unit_stack_index)
				    .in_else_clause
				    & stmt (next_statement (stmtx)).type
				    ^= if_statement) & mode_indthenelse
				    then
				        left_margin =
					  left_margin + mode_ind;
				end;

			  else if unit_stack (unit_stack_index).type
			      = ELSE_UNIT then
				call pop_unit (0, 0, left_margin);

			  else
				do;
				loop = "0"b;
				call error (3,
				    "No if statement preceding else clause.",
				    token (stmt (stmtx).start)
				    .string_ptr);
				end;
		    end;
		    end;

	      else
		    do while (unit_stack (unit_stack_index).type = IF_UNIT
		        | unit_stack (unit_stack_index).type = ELSE_UNIT);
			  call pop_unit (0, 0, left_margin);
		    end;
        end adjust_unit_stack;

format_procedure:
        procedure (n_items, label_start, label_end);

        declare n_items		fixed binary;   /* (Input) number of items in the statement */
        declare label_start		fixed binary;   /* (Input) first label token */
        declare label_end		fixed binary;   /* (Input) last label token */

        declare previous_left_margin	fixed binary;
        declare procedure_nest_depth	fixed binary;
        declare unitx		fixed binary;

        previous_left_margin = left_margin;

        procedure_nest_depth = 0;
        do unitx = unit_stack_index to 2 by -1;
	      if unit_stack (unit_stack_index).type = PROCEDURE_UNIT then
		    procedure_nest_depth = procedure_nest_depth + 1;
        end;

        if procedure_nest_depth < 2 | ^mode_indproc then
	      left_margin = mode_ind + 1;

        call format_other (2, n_items, left_margin, mode_lineconind, "1"b);

        call push_unit (PROCEDURE_UNIT, label_start, label_end, left_margin,
	  previous_left_margin);
        if mode_indprocbody then
	      left_margin = left_margin + mode_ind;
        end format_procedure;

format_assignment:
        procedure (n_items);

        declare n_items		fixed binary;   /* (Input) number of items in the statement */

        if mode_equalind = 0 then
	      call format_other (2, n_items, left_margin, mode_lineconind,
		"1"b);
        else
	      begin;
	      declare assignment_item	        fixed binary;
	      do assignment_item = 2 to n_items
		while (item (assignment_item).type ^= assignment);
	      end;

	      call format_other (2, assignment_item - 1, left_margin,
		mode_lineconind, "0"b);
	      call format_other (assignment_item, n_items,
		left_margin + mode_equalind, mode_lineconind, "1"b);
	      end;
        end format_assignment;

format_begin:
        procedure (n_items, last_stmt_type, label_start, label_end);

        declare n_items		fixed binary;   /* (Input) number of items in the statement */
        declare last_stmt_type	fixed binary (8);
					      /* (Input) type of the last nonwhitespace stmt */
        declare label_start		fixed binary;   /* (Input) first label token */
        declare label_end		fixed binary;   /* (Input) last label token */

        declare previous_left_margin	fixed binary;

        call format_other (2, n_items, left_margin, mode_lineconind, "1"b);

        previous_left_margin = left_margin;

        if last_stmt_type ^= if_statement & last_stmt_type ^= else_clause
	  & last_stmt_type ^= on_statement then
	      do;
	      if mode_indbegin then
		    do;
		    left_margin = left_margin + mode_ind;
		    call push_unit (BEGIN_UNIT, label_start, label_end,
		        indent_margin (mode_indbeginend, left_margin),
		        previous_left_margin);
		    end;
	      else
		    call push_unit (BEGIN_UNIT, label_start, label_end,
		        left_margin, previous_left_margin);
	      end;
        else
	      do;
	      if mode_indthenbegin then
		    left_margin = left_margin + mode_ind;
	      call push_unit (BEGIN_UNIT, label_start, label_end,
		indent_margin (mode_indthenbeginend, left_margin),
		previous_left_margin);
	      end;

        end format_begin;

format_do:
        procedure (n_items, last_stmt_type, label_start, label_end);

        declare n_items		fixed binary;   /* (Input) number of items in the statement */
        declare last_stmt_type	fixed binary (8);
					      /* (Input) type of the last non whitespace stmt */
        declare label_start		fixed binary;   /* (Input) first label token */
        declare label_end		fixed binary;   /* (Input) last label token */

        declare indent_end		bit (1);
        declare previous_left_margin	fixed binary;

        call format_other (2, n_items, left_margin, mode_lineconind, "1"b);

        previous_left_margin = left_margin;

        if last_stmt_type = if_statement | last_stmt_type = else_clause
	  | last_stmt_type = on_statement then
	      if stmt (stmtx).subtype = subtype_noniterative_do then
		    do;
		    if mode_indnoniterdo then
			  left_margin = left_margin + mode_ind;

		    indent_end = mode_indnoniterend;
		    end;

	      else
		    do;
		    if mode_inditerdo then
			  left_margin = left_margin + mode_ind;

		    indent_end = mode_indend;
		    end;

        else
	      do;
	      left_margin = left_margin + mode_ind;
	      indent_end = mode_indend;
	      end;

        call push_unit (DO_UNIT, label_start, label_end,
	  indent_margin (indent_end, left_margin), previous_left_margin);
        end format_do;

format_entry:
        procedure (n_items);

        declare n_items		fixed binary;   /* (Input) number of items in the statement */

        declare unitx		fixed binary;

        do unitx = unit_stack_index to 2 by -1
	  while (unit_stack (unitx).type ^= PROCEDURE_UNIT);
        end;

        if unit_stack (unitx).type = PROCEDURE_UNIT then
	      call format_other (2, n_items,
		(unit_stack (unitx).close_left_margin), mode_lineconind,
		"1"b);
        else
	      call format_other (2, n_items, mode_ind + 1, mode_lineconind,
		"1"b);
        end format_entry;

format_end:
        procedure (n_items);

        declare n_items		fixed binary;   /* (Input) number of items in the statement */

        declare previous_left_margin	fixed binary;

        if unit_stack_index = 2 & stmtx < global.n_stmts & ^text_after_end_msg
	  then
	      do;
	      call error (3, "Text follows logical end of program.",
		token (stmt (stmtx + 1).start).string_ptr);
	      text_after_end_msg = "1"b;
	      end;

        if unit_stack_index > 1 then
	      if token (stmt (stmtx).start + 1).type = identifier then
		    call pop_unit (stmt (stmtx).start + 1, left_margin,
		        previous_left_margin);
	      else
		    call pop_unit (0, left_margin, previous_left_margin);

        else
	      do;
	      left_margin = 1;
	      previous_left_margin = mode_ind + 1;
	      call error (3, "End statement follows logical end of program.",
		item (2).string_ptr);
	      end;

        call format_other (2, n_items, left_margin, mode_lineconind, "1"b);

        left_margin = previous_left_margin;
        end format_end;

/* ************************************************************************
   * format_if - procedure to format an if statement.		    *
   *   previous_left_margin - left margin when this proc is entered.	    *
   *   if_statement_left_margin - the column this if statement will begin *
   *	   in.  This is used to get "else if" statements so that the if *
   *	   begins one space after the else regardless of mode_ind.	    *
   *   if_statement_lineconind - this is an adjustment to the line        *
   *	   continuation value so that line continuations are placed     *
   *         mode_lineconind from the begining of the "else if" instead   *
   *	   mode_lineconind from the "if".  We are treating "else if" as *
   *	   if it were one statement.				    *
   ************************************************************************ */

format_if:
        procedure (last_stmt_type, n_items);

        declare last_stmt_type	fixed binary (8);
					      /* (Input) type of the last statement */
        declare n_items		fixed binary;   /* (Input) number of items in the statement */

        declare current_mode_case	bit (1) aligned;
        declare then_item		fixed binary;
        declare previous_left_margin	fixed binary;
        declare if_statement_left_margin
				fixed binary;
        declare if_statement_lineconind fixed binary;

        declare third_item_string	char (item (3).string_size)
				based (item (3).string_ptr);

        current_mode_case = mode_case;

        if last_stmt_type = if_statement | last_stmt_type = else_clause then
	      current_mode_case = unit_stack (unit_stack_index).case;

        if item (3).type = comment_token then
	      if third_item_string = case_control_comment then
		    current_mode_case = "1"b;

	      else if third_item_string = tree_control_comment then
		    current_mode_case = "0"b;

        previous_left_margin = left_margin;

        if last_stmt_type = else_clause & current_mode_case then
	      do;
	      left_margin = unit_stack (unit_stack_index).close_left_margin;
	      if_statement_left_margin = left_margin + length ("else") + 1;
	      if_statement_lineconind =
		mode_lineconind - (length ("else") + 1);
	      end;
        else
	      do;
	      if_statement_left_margin = previous_left_margin;
	      if_statement_lineconind = mode_lineconind;
	      end;

        call push_unit (IF_UNIT, 0, 0, left_margin, previous_left_margin);
        unit_stack (unit_stack_index).case = current_mode_case;
        unit_stack (unit_stack_index).in_else_clause =
	  last_stmt_type = else_clause;

        if mode_indthenelse then
	      left_margin = left_margin + mode_ind;

        do then_item = n_items by -1
	  while (item (then_item).type = comment_token);
        end;

        if is_ifthenstmt (stmtx, last_stmt_type, current_mode_case)
	  & mode_ifthenstmt then
	      begin;
	      declare last_item	        fixed binary;
	      declare may_be_ifthenstmt       bit (1) aligned;

	      call convert_stmt_to_items (stmtx + 1, n_items, "0"b, last_item)
		;

	      may_be_ifthenstmt = "1"b;

	      if stmt (stmtx + 1).type = on_statement then
		    if may_be_one_line_on_unit (stmtx + 1) then
			  call convert_stmt_to_items (stmtx + 2,
			      (last_item), "0"b, last_item);
		    else
			  may_be_ifthenstmt = "0"b;

	      if may_be_ifthenstmt then
		    do;
		    call format_other (2, last_item,
		        if_statement_left_margin, if_statement_lineconind,
		        "1"b);
		    call look_ahead_if_is_on_one_line (stmtx, 2, last_item,
		        looked_ahead);
		    end;
	      end;

        else if stmt (stmtx + 1).subtype = subtype_noniterative_do
	  & mode_ifthendo then
	      begin;
	      declare itemx		        fixed binary;
	      declare last_item	        fixed binary;
	      declare then_item_NLs	        fixed binary;

	      call convert_stmt_to_items (stmtx + 1, n_items, "0"b, last_item)
		;
	      then_item_NLs = item (then_item).trailer.NLs;
	      call format_other (2, last_item, if_statement_left_margin,
		if_statement_lineconind, "1"b);

	      do itemx = last_item by -1
		while (item (itemx).type = comment_token);
	      end;

	      do itemx = itemx to then_item by -1
		while (^item (itemx).header.tab);
	      end;

	      if itemx < then_item & ^mode_thendo then
		    looked_ahead = "1"b;
	      else
		    do;
		    item (then_item).trailer.NLs = then_item_NLs;
		    call convert_stmt_to_items (stmtx + 1, n_items, "0"b,
		        last_item);
		    call format_other (then_item, last_item, left_margin,
		        mode_lineconind, "1"b);
		    call look_ahead_if_is_on_one_line (stmtx, then_item,
		        last_item, looked_ahead);
		    end;
	      end;

        if ^looked_ahead then
	      if mode_ifthen then
		    begin;
		    declare itemx		      fixed binary;

		    do itemx = then_item + 1 by 1
		        while (item (itemx).type = comment_token);
			  call insert_tab (itemx, mode_comcol);
		    end;

		    call format_other (2, n_items, if_statement_left_margin,
		        if_statement_lineconind, "0"b);

		    end;

	      else
		    begin;
		    declare itemx		      fixed binary;

		    do itemx = then_item - 1 by -1
		        while (item (itemx).type = comment_token);
			  call insert_tab (itemx, mode_comcol);
		    end;

		    call format_other (2, then_item - 1,
		        if_statement_left_margin, if_statement_lineconind,
		        "1"b);
		    call format_other (then_item, n_items, left_margin,
		        mode_lineconind, "0"b);
		    end;

        if mode_ifthen then
	      left_margin = left_margin + mode_ind;
        else
	      left_margin =
		left_margin + clause_indentation (stmt (stmtx + 1).type);

        return;

is_ifthenstmt:
        procedure (stmtx, last_stmt_type, case) returns (bit (1) aligned);

        declare stmtx		fixed binary;   /* (Input) current if statement */
        declare last_stmt_type	fixed binary (8);
					      /* (Input) type of last statement */
        declare case		bit (1) aligned;/* (Input) current mode case */

        if ^is_independent_statement (stmt (stmtx + 1).type)
	  | stmt (stmtx + 1).type = if_statement then
	      return ("0"b);

        if stmt (stmtx + 2).type ^= else_clause then
	      return ("1"b);

        return (case
	  & (last_stmt_type = else_clause
	  | stmt (next_statement (stmtx + 2)).type = if_statement));
        end is_ifthenstmt;

        end format_if;

format_else:
        procedure (n_items);

        declare n_items		fixed binary;   /* (Input) number of items in the statement */

        if stmt (stmtx + 1).subtype = subtype_noniterative_do & mode_ifthendo
	  then
	      begin;
	      declare last_item	        fixed binary;

	      call convert_stmt_to_items (stmtx + 1, n_items, "0"b, last_item)
		;
	      call format_other (2, last_item, left_margin, mode_lineconind,
		"1"b);
	      call look_ahead_if_is_on_one_line (stmtx, 2, last_item,
		looked_ahead);
	      end;

        if ^looked_ahead then
	      if mode_elsestmt then
		    call format_other (2, n_items, left_margin,
		        mode_lineconind, "0"b);
	      else
		    do;
		    if stmt (stmtx + 1).type = if_statement
		        & unit_stack (unit_stack_index).case then
			  call format_other (2, n_items, left_margin,
			      mode_lineconind, "0"b);
		    else
			  call format_other (2, n_items, left_margin,
			      mode_lineconind, "1"b);
		    end;

        if mode_elsestmt then
	      left_margin =
		left_margin + clause_indentation (stmt (stmtx + 1).type);
        else
	      left_margin = left_margin + mode_ind;
        end format_else;

clause_indentation:
        procedure (clause_type) returns (fixed binary);

        declare clause_type		fixed binary (8) unaligned;
					      /* (Input) type of then clause or else clause */

/* length ("then") = length ("else") */

        if is_independent_statement (clause_type) then
	      return (max (length ("then") + 1, mode_ind));
        else
	      return (mode_ind);
        end clause_indentation;

next_statement:
        procedure (this_stmtx) returns (fixed binary);

        declare this_stmtx		fixed binary;   /* (Input) current statement */

        declare stmtx		fixed binary;

        do stmtx = this_stmtx + 1 by 1
	  while (stmt (stmtx).type = condition_prefix_list
	  | stmt (stmtx).type = label_prefix_list
	  | is_macro_whitespace (stmt (stmtx).type));
        end;

        return (stmtx);
        end next_statement;

format_on:
        procedure (n_items);

        declare n_items		fixed binary;   /* (Input) number of items in the statement */

        if may_be_one_line_on_unit (stmtx) then
	      if ^looked_ahead then
		    begin;
		    declare last_item	      fixed binary;

		    call convert_stmt_to_items (stmtx + 1, n_items, "0"b,
		        last_item);
		    call format_other (2, last_item, left_margin,
		        mode_lineconind, "1"b);
		    call look_ahead_if_is_on_one_line (stmtx, 2, last_item,
		        looked_ahead);
		    end;

        if ^looked_ahead then
	      call format_other (2, n_items, left_margin, mode_lineconind,
		"1"b);

        call push_unit (ON_UNIT, 0, 0, left_margin, left_margin);
        left_margin = left_margin + mode_ind;
        end format_on;

may_be_one_line_on_unit:
        procedure (stmtx) returns (bit (1) aligned);

        declare stmtx		fixed binary;   /* (Input) on statement index */

        return (is_independent_statement (stmt (stmtx + 1).type)
	  & stmt (stmtx + 1).type ^= if_statement
	  & stmt (stmtx + 1).type ^= on_statement
	  & stmt (stmtx + 1).type ^= return_statement
	  & stmt (stmtx + 1).type ^= revert_statement);
        end may_be_one_line_on_unit;

look_ahead_if_is_on_one_line:
        procedure (stmtx, first_item, last_item, looked_ahead);

        declare stmtx		fixed binary;   /* (Input) current statement */
        declare first_item		fixed binary;   /* (Input) first item to check */
        declare last_item		fixed binary;   /* (Input) last item to check */
        declare looked_ahead		bit (1) aligned;/* (Output) on if next statement fits on the current line */

        declare itemx		fixed binary;
        declare last_stmt_item	fixed binary;

        do last_stmt_item = last_item by -1
	  while (item (last_stmt_item).type = comment_token);
        end;

        if item (last_stmt_item).type ^= semi_colon then
	      last_stmt_item = last_item + 1;

        do itemx = first_item to last_stmt_item - 1
	  while (item (itemx).trailer.NLs = 0);
        end;

        looked_ahead = itemx >= last_stmt_item;

        if ^looked_ahead then
	      call convert_stmt_to_items (stmtx, 1, "1"b, itemx);
        end look_ahead_if_is_on_one_line;

format_percent_if_macros:
        procedure (n_items, first_clause, start_clause, has_percent_then);

        declare n_items		fixed binary;   /* (Input) number of items in the macro */
        declare first_clause		bit (1) aligned;/* (Input) on to start new macro: %if */
        declare start_clause		bit (1) aligned;/* (Input) on to start new clause: %if, %elseif, %else */
        declare has_percent_then	bit (1) aligned;/* (Input) on if macro has %then: %if, %elseif */

        declare itemx		fixed binary;

        if ^first_clause then
	      if start_clause then
		    do;
		    do while (unit_stack (unit_stack_index).type
		        ^= PERCENT_IF_UNIT & unit_stack_index >= 2);
			  call pop_unit (0, 0, left_margin);
		    end;

		    if unit_stack (unit_stack_index).type = PERCENT_IF_UNIT
		        then
			  call pop_unit (0, left_margin, left_margin);
		    else
			  call error (3, "No preceding %if macro.",
			      item (2).string_ptr);
		    end;

	      else
		    begin;
		    declare unitx		      fixed binary;

		    do unitx = unit_stack_index to 2 by -1
		        while (unit_stack (unitx).type ^= PERCENT_IF_UNIT);
		    end;

		    if unit_stack (unitx).type = PERCENT_IF_UNIT then
			  do;
			  do unitx = unitx + 1 to unit_stack_index;
				unit_stack (unitx - 1) =
				    unit_stack (unitx);
			  end;

			  unit_stack_index = unit_stack_index - 1;
			  end;

		    else
			  call error (3,
			      "No %if macro preceding %endif macro.",
			      item (2).string_ptr);
		    end;

        if start_clause then
	      call push_unit (PERCENT_IF_UNIT, 0, 0, left_margin, left_margin)
		;

        do itemx = n_items by -1 while (item (itemx).type = comment_token);
	      call insert_tab (itemx, mode_comcol);
        end;

        call format_other (2, n_items, 1, mode_lineconind, "1"b);

        if has_percent_then & item (itemx).header.tab then
	      call insert_tab (itemx, 1);
        end format_percent_if_macros;

format_declare:
        procedure (n_items);

        declare n_items		fixed binary;   /* (Input) number of items in the statement */

        declare declare_margin	fixed binary;
        declare factored_level_number	bit (1) aligned;
        declare id_start_col		fixed binary;
        declare itemx		fixed binary;
        declare levels_ptr		pointer;
        declare levelx		fixed binary;
        declare tokenx		fixed binary;

        declare levels		(0:sys_info$max_seg_size
				- binary (rel (levels_ptr), 18) - 1)
				fixed binary based (levels_ptr);

        tokenx = n_items + 1;
        do itemx = tokenx to 2 by -1;
	      item (itemx).next_token = tokenx;

	      if item (itemx).type ^= comment_token then
		    tokenx = itemx;
        end;

        levels_ptr = addr (item (n_items + 2));
        levels (0) = -1;
        levelx = 0;

        factored_level_number = "0"b;
        itemx = 2;

        if mode_inddcls then
	      declare_margin = left_margin;
        else
	      declare_margin = 1;

        if item (itemx).string_size = length ("dcl") then
	      id_start_col = declare_margin + mode_dclind;
        else
	      id_start_col = declare_margin + mode_declareind;

        call insert_tab (itemx, declare_margin);

        itemx = item (itemx).next_token;
        call declaration_list;

        itemx = item (itemx).next_token;
        call insert_NL (itemx - 1, 0);

        return;

declaration_list:
        procedure;

        declare declare_stack_index	fixed binary;
        declare declare_stack_ptr	pointer;

        declare 1 declare_stack	(
				divide (sys_info$max_seg_size
				- binary (rel (declare_stack_ptr), 18),
				2, 17)) aligned
				based (declare_stack_ptr),
	        2 state		fixed binary (17) unaligned,
	        2 flags		unaligned,
		3 has_level_number	bit (1),
		3 pad		bit (17),
	        2 component_start	fixed binary (17);

        declare item_string		char (item (itemx).string_size)
				based (item (itemx).string_ptr);

        declare (
	      START_COMPONENT	initial (0),
	      WANT_RIGHT_PAREN	initial (1),
	      WANT_ATTRIBUTE_SET	initial (2)
	      )			fixed binary internal static
				options (constant);

        declare_stack_ptr = addr (unit_stack (unit_stack_index + 1));
        declare_stack_index = 0;

        call push_declare_stack_entry (declare_stack_index);
        do while (declare_stack_index > 0);
	      if declare_stack (declare_stack_index).state = START_COMPONENT
		then
		    do;
		    declare_stack (declare_stack_index).state =
		        WANT_ATTRIBUTE_SET;
		    declare_stack (declare_stack_index).has_level_number =
		        "0"b;
		    declare_stack (declare_stack_index).component_start =
		        itemx;

		    if item (itemx).type = dec_integer then
			  begin;
			  declare level		    fixed binary;

			  level = binary (item_string, 17);

			  do levelx = levelx to 1 by -1
			      while (levels (levelx) >= level);
			  end;

			  if levelx >= hbound (levels, 1) then
				call error (4, "Too many levels.",
				    item (itemx).string_ptr);

			  levelx = levelx + 1;
			  levels (levelx) = level;
			  declare_stack (declare_stack_index)
			      .has_level_number = "1"b;

			  if factored_level_number then
				call error (3,
				    "Level number within the scope of a factored level number.",
				    item (itemx).string_ptr);

			  itemx = item (itemx).next_token;
			  end;

		    else if ^factored_level_number
		        & item (itemx).type ^= left_parn then
			  levelx = 0;

		    call insert_tab (declare_stack (declare_stack_index)
		        .component_start, structure_id_start_col (levelx));

		    if item (itemx).type = identifier then
			  itemx = item (itemx).next_token;

		    else if item (itemx).type = left_parn then
			  begin;
			  declare ix		    fixed binary;

			  factored_level_number =
			      declare_stack (declare_stack_index)
			      .has_level_number;

			  call completely_factored_declaration_list (
			      itemx, ix);
			  if ix > 0 then
				itemx = ix;
			  else
				do;
				itemx = item (itemx).next_token;
				declare_stack (declare_stack_index)
				    .state = WANT_RIGHT_PAREN;
				call push_declare_stack_entry (
				    declare_stack_index);
				end;
			  end;

		    else if ^is_macro_statement (stmt (stmtx + 1).type) then
			  call error (3,
			      "Syntax error in declaration component.",
			      item (itemx).string_ptr);
		    end;

	      else if declare_stack (declare_stack_index).state
		= WANT_RIGHT_PAREN then
		    do;
		    declare_stack (declare_stack_index).state =
		        WANT_ATTRIBUTE_SET;

		    if item (itemx).type = right_parn then
			  begin;
			  declare ix		    fixed binary;

			  do ix = itemx - 1 by -1
			      while (item (ix).type = comment_token);
				call insert_tab (ix, mode_comcol);
			  end;

			  call insert_NL (itemx - 1,
			      structure_id_start_col (levelx));
			  itemx = item (itemx).next_token;
			  end;

		    else if ^is_macro_statement (stmt (stmtx + 1).type) then
			  call error (3,
			      "Missing right parenthesis after declaration list.",
			      item (itemx).string_ptr);

		    if declare_stack (declare_stack_index).has_level_number
		        then
			  factored_level_number = "0"b;
		    end;

	      else
		    do;			      /* WANT_ATTRIBUTE_SET */
		    call attribute_set (id_start_col + mode_idind, itemx);

		    if mode_indattr then
			  if declare_stack (declare_stack_index)
			      .has_level_number then
				call tab_continuation_lines (
				    declare_stack (declare_stack_index)
				    .component_start + 1, itemx,
				    structure_id_start_col (levelx)
				    + mode_ind);
			  else
				call tab_continuation_lines (
				    declare_stack (declare_stack_index)
				    .component_start + 1, itemx,
				    structure_id_start_col (levelx));

		    else if item (itemx).type = comma
		        | item (itemx).type = semi_colon then
			  call format_other (
			      declare_stack (declare_stack_index)
			      .component_start, itemx,
			      structure_id_start_col (levelx),
			      mode_lineconind, "0"b);
		    else
			  call format_other (
			      declare_stack (declare_stack_index)
			      .component_start, itemx - 1,
			      structure_id_start_col (levelx),
			      mode_lineconind, "0"b);

		    if item (itemx).type = comma then
			  do;
			  itemx = item (itemx).next_token;
			  call insert_NL (itemx - 1, 0);
			  declare_stack (declare_stack_index).state =
			      START_COMPONENT;
			  end;

		    else
			  declare_stack_index = declare_stack_index - 1;
		    end;
        end;

        return;

push_declare_stack_entry:
        procedure (declare_stack_index);

        declare declare_stack_index	fixed binary;   /* (Updated) top of the declare_stack */

        if declare_stack_index >= hbound (declare_stack, 1) then
	      call error (4, "Declaration lists nested too deep.",
		item (itemx).string_ptr);

        declare_stack_index = declare_stack_index + 1;
        unspec (declare_stack (declare_stack_index)) = ""b;
        declare_stack (declare_stack_index).state = START_COMPONENT;
        end push_declare_stack_entry;

/* Format a declaration list if it has all the attributes factored, doesn't
   contain any comments, and the identifiers don't contain dollar signs. */

completely_factored_declaration_list:
        procedure (first_item, last_item);

        declare first_item		fixed binary;   /* (Input) left paren preceding declaration list */
        declare last_item		fixed binary;   /* (Output) item after right paren of declaration component,
					         or 0 if not a completely factored declaration list */

        declare itemx		fixed binary;

        declare item_string		char (item (itemx).string_size)
				based (item (itemx).string_ptr);

        last_item = 0;
        itemx = first_item + 1;

        if item (itemx).type ^= identifier then
	      return;

        do itemx = itemx + 1 repeat itemx + 1 while (item (itemx).type = comma);
	      itemx = itemx + 1;

	      if item (itemx).type ^= identifier then
		    return;

	      if index (item_string, "$") > 0 then
		    return;
        end;

        if item (itemx).type ^= right_parn then
	      return;

        if ^factored_level_number then
	      levelx = 0;

        if declare_stack (declare_stack_index).has_level_number then
	      call format_other (declare_stack (declare_stack_index)
		.component_start, itemx, structure_id_start_col (levelx),
		mode_lineconind, "0"b);
        else
	      call format_other (declare_stack (declare_stack_index)
		.component_start, itemx, structure_id_start_col (levelx), 0,
		"0"b);

        if declare_stack (declare_stack_index).has_level_number then
	      factored_level_number = "0"b;

        last_item = itemx + 1;
        end completely_factored_declaration_list;

attribute_set:
        procedure (start_col, itemx);

        declare start_col		fixed binary;   /* (Input) column the attributes start in */
        declare itemx		fixed binary;   /* (Updated) current item */

        declare first_item		fixed binary;
        declare initial_paren_depth	fixed binary;

        declare item_string		char (item (itemx).string_size)
				based (item (itemx).string_ptr);

        first_item = itemx;
        do while (item (itemx).type ^= comma & item (itemx).type ^= semi_colon
	  & item (itemx).type ^= right_parn & item (itemx).type ^= no_token);
	      if item (itemx).type = identifier then
		    do;
		    item (itemx).type = keyword_token;
		    item (itemx).precedence = precedence (keyword_token);

/*		     if item_string = "entry"
   then call entry_attribute;
   else if item_string = "returns"
   then call returns_attribute;
   else if item_string = "generic"
   then call generic_attribute;
   else */

		    if item_string = "like" then
			  do;
			  itemx = item (itemx).next_token;

			  if item (itemx).type = identifier then
				do;
				itemx = item (itemx).next_token;
				do while (item (itemx).type = period);
				        itemx = item (itemx).next_token;

				        if item (itemx).type
					  = identifier then
					      itemx =
						item (itemx)
						.next_token;
				end;
				end;
			  end;

		    else if item_string = "defined" | item_string = "def"
		        then
			  do;
			  initial_paren_depth = item (itemx).paren_depth;
			  do itemx = item (itemx).next_token
			      repeat item (itemx).next_token
			      while (item (itemx).paren_depth
			      > initial_paren_depth & itemx < n_items
			      | item (itemx).type ^= comma
			      & item (itemx).type ^= semi_colon
			      & item (itemx).type ^= right_parn
			      & (item (itemx).type ^= identifier
			      |
			      ^
			      could_end_a_reference (item (itemx - 1)
			      .type)));
			  end;
			  end;

		    else
			  itemx = item (itemx).next_token;
		    end;

	      else if item (itemx).type = left_parn then
		    do;
		    initial_paren_depth = item (itemx).paren_depth;
		    do itemx = item (itemx).next_token
		        repeat item (itemx).next_token
		        while (item (itemx).paren_depth
		        >= initial_paren_depth);
		    end;
		    end;

	      else
		    itemx = item (itemx).next_token;
        end;

        if first_item < itemx & mode_indattr then
	      if item (itemx).type = comma | item (itemx).type = semi_colon
		then
		    call format_other (first_item, itemx, start_col, 0,
		        "0"b);
	      else
		    call format_other (first_item, itemx - 1, start_col, 0,
		        "0"b);

        return;

could_end_a_reference:
        procedure (type) returns (bit (1) aligned);

        declare type		fixed binary (8) unaligned;
					      /* (Input) token type which might end a reference */

        return (type = identifier | type = isub | type = right_parn
	  | min_constant_token <= type & type <= max_constant_token);
        end could_end_a_reference;

        end attribute_set;

structure_id_start_col:
        procedure (level) returns (fixed binary);

        declare level		fixed binary;   /* (Input) current normalized structure level */

        return (id_start_col + mode_struclvlind * max (0, level - 1));
        end structure_id_start_col;

        end declaration_list;

        end format_declare;

/* Format items using the precedence rules. */

format_other:
        procedure (first_item, last_item, start_col, continuation_indent,
	  insert_final_NL_sw);

        declare first_item		fixed binary;   /* (Input) first item to format */
        declare last_item		fixed binary;   /* (Input) last item to format */
        declare start_col		fixed binary;   /* (Input) left margin for this statement fragment */
        declare continuation_indent	fixed binary;   /* (Input) number of columns to indent continuation lines */
        declare insert_final_NL_sw	bit (1) aligned;/* (Input) on to insert a NL after last_item */

        declare first_on_line		fixed binary;
        declare ix			fixed binary;
        declare last_line_pos		fixed binary;

        declare ix_item_string	char (item (ix).string_size)
				based (item (ix).string_ptr);
        declare last_ix_item_string	char (item (ix - 1).string_size)
				based (item (ix - 1).string_ptr);

        if looked_ahead then
	      do;
	      looked_ahead = "0"b;
	      return;
	      end;

        call insert_tab (first_item, start_col);
        call tab_continuation_lines (first_item + 1, last_item,
	  start_col + continuation_indent);

        if ^mode_insnl then
	      return;

        first_on_line = first_item;
        do while (first_on_line <= last_item);
	      do ix = first_on_line to last_item
		while (item (ix - 1).last_col <= mode_ll
		| ix = first_on_line);
		    if item (ix).header.tab then
			  do;
			  first_on_line = ix;
			  last_line_pos = -1;
			  end;

		    else if item (ix - 1).type = char_string
		        | item (ix - 1).type = comment_token then
			  if search (last_ix_item_string, NL_VT_NP) = 0
			      then
				last_line_pos = item (ix - 1).last_col;
			  else
				last_line_pos =
				    last_line_position (1,
				    last_ix_item_string);

		    else
			  last_line_pos = item (ix - 1).last_col;

		    if item (ix).type = char_string
		        | item (ix).type = comment_token then
			  item (ix).last_col =
			      next_line_position (last_line_pos
			      + item (ix).header.amount + 1,
			      ix_item_string) - 1;
		    else
			  item (ix).last_col =
			      last_line_pos + item (ix).header.amount
			      + item (ix).string_size;
	      end;

	      if item (ix - 1).last_col <= mode_ll then
		    first_on_line = ix;
	      else
		    begin;
		    declare last_on_line	      fixed binary;
		    declare low_paren_depth	      fixed binary;
		    declare low_precedence	      fixed binary;

		    last_on_line = ix - 1;
		    do first_on_line = first_on_line to last_on_line
		        while (item (first_on_line).last_col
		        < start_col + continuation_indent);
		    end;

		    if item_should_end_line (item (last_on_line).type) then
			  do;
			  low_paren_depth = 1f5;
			  low_precedence = 1f5;
			  end;

		    else
			  do;
			  low_paren_depth =
			      item (last_on_line).paren_depth;
			  low_precedence = item (last_on_line).precedence;
			  end;

		    do ix = first_on_line + 1 to last_on_line - 1;
			  if item (ix).paren_depth < low_paren_depth
			      | item (ix).paren_depth = low_paren_depth
			      & item (ix).precedence <= low_precedence
			      then
				do;
				last_on_line = ix;
				low_paren_depth = item (ix).paren_depth;
				low_precedence = item (ix).precedence;
				end;
		    end;

		    if ^item_should_end_line (item (last_on_line).type) then
			  if first_on_line < last_on_line then
				last_on_line = last_on_line - 1;
			  else if item (last_on_line + 1).type = comma
			      then
				last_on_line = last_on_line + 1;

		    call insert_NL (last_on_line,
		        start_col + continuation_indent);
		    first_on_line = last_on_line + 1;
		    end;
        end;

        if insert_final_NL_sw then
	      call insert_NL (last_item, 0);

        return;

item_should_end_line:
        procedure (type) returns (bit (1) aligned);

        declare type		fixed binary (8) unaligned;
					      /* (Input) token type */

        return (type = comma | type = target_comma | type = right_parn
	  | type = assignment);
        end item_should_end_line;

        end format_other;

push_unit:
        procedure (unit_type, label_start, label_end, close_left_margin,
	  previous_left_margin);

        declare unit_type		fixed binary;   /* (Input) type of unit to push */
        declare label_start		fixed binary;   /* (Input) first token in the statement's label prefixes */
        declare label_end		fixed binary;   /* (Input) last token in the statement's label prefixes */
        declare close_left_margin	fixed binary;   /* (Input) left margin for corresponding 'end' statement */
        declare previous_left_margin	fixed binary;   /* (Input) left margin for next statement */

        if unit_stack_index >= hbound (unit_stack, 1) then
	      call error (4, "Blocks nested too deep.",
		token (stmt (stmtx).start).string_ptr);

        unit_stack_index = unit_stack_index + 1;
        unspec (unit_stack (unit_stack_index)) = ""b;
        unit_stack (unit_stack_index).type = unit_type;
        unit_stack (unit_stack_index).label_start = label_start;
        unit_stack (unit_stack_index).label_end = label_end;
        unit_stack (unit_stack_index).close_left_margin = close_left_margin;
        unit_stack (unit_stack_index).previous_left_margin =
	  previous_left_margin;
        unit_stack (unit_stack_index).construct_ptr =
	  token (stmt (stmtx).start).string_ptr;
        end push_unit;

pop_unit:
        procedure (label_token, close_left_margin, previous_left_margin);

        declare label_token		fixed binary;   /* (Input) end statement label token, 0 if none */
        declare close_left_margin	fixed binary;   /* (Output) left margin for end statement */
        declare previous_left_margin	fixed binary;   /* (Output) left margin for the next statement */

        declare matched		bit (1) aligned;
        declare multiple_closure_msg	bit (1) aligned;
        declare tx			fixed binary;

        declare label_string		char (token (label_token).string_size)
				based (token (label_token).string_ptr);
        declare tx_token_string	char (token (tx).string_size)
				based (token (tx).string_ptr);

        multiple_closure_msg = "0"b;
        matched = label_token = 0;
        do while (^matched & unit_stack_index >= 2);
	      if unit_stack (unit_stack_index).label_start > 0 then
		    do tx = unit_stack (unit_stack_index).label_start
		        to unit_stack (unit_stack_index).label_end
		        while (^matched);
			  if token (tx).type = identifier
			      & token (tx + 1).type = colon then
				matched =
				    label_string = tx_token_string;
		    end;

	      if ^matched then
		    do;
		    if unit_stack (unit_stack_index).type = BEGIN_UNIT
		        | unit_stack (unit_stack_index).type = DO_UNIT
		        | unit_stack (unit_stack_index).type
		        = PROCEDURE_UNIT
		        | unit_stack (unit_stack_index).type
		        = PERCENT_IF_UNIT then
			  do;
			  if ^multiple_closure_msg then
				do;
				call error (1,
				    "Labeled end statement terminates more than one block or group.",
				    token (label_token).string_ptr);
				multiple_closure_msg = "1"b;
				end;

			  call error (1,
			      "Block or group terminated by labeled end statement.",
			      unit_stack (unit_stack_index).construct_ptr)
			      ;
			  end;

		    unit_stack_index = unit_stack_index - 1;
		    end;
        end;

        if matched then
	      do;
	      close_left_margin =
		unit_stack (unit_stack_index).close_left_margin;
	      previous_left_margin =
		unit_stack (unit_stack_index).previous_left_margin;
	      unit_stack_index = unit_stack_index - 1;
	      end;

        else
	      do;
	      close_left_margin = 1;
	      previous_left_margin = 1;
	      call error (3, "No match for labeled end statement.",
		token (label_token).string_ptr);
	      end;
        end pop_unit;

/* Ensure starting columns for continuation lines are specified. */

tab_continuation_lines:
        procedure (first_item, last_item, continuation_col);

        declare first_item		fixed binary;   /* (Input) first item to check */
        declare last_item		fixed binary;   /* (Input) last item to check */
        declare continuation_col	fixed binary;   /* (Input) default continuation line starting column */

        declare itemx		fixed binary;

        do itemx = first_item to last_item;
	      if item (itemx - 1).trailer.NLs > 0 & ^item (itemx).header.tab
		then
		    call insert_tab (itemx, continuation_col);
        end;
        end tab_continuation_lines;

/* Insert a NL in the statement. */

insert_NL:
        procedure (itemx, start_col);

        declare itemx		fixed binary;   /* (Input) index of last item on the line */
        declare start_col		fixed binary;   /* (Input) starting column of first item on the next line,
					         0 if none */

        if item (itemx).trailer.NLs = 0 & mode_insnl then
	      item (itemx).trailer.NLs = 1;

        if start_col > 0 then
	      call insert_tab (itemx + 1, start_col);
        end insert_NL;

/* Insert a tab to a particular column in the statement. */

insert_tab:
        procedure (itemx, start_col);

        declare itemx		fixed binary;   /* (Input) index of item to be moved over */
        declare start_col		fixed binary;   /* (Input) new starting column */

        if item (itemx).type = comment_token & item (itemx).header.tab then
	      return;

        item (itemx).header.tab = "1"b;
        item (itemx).header.amount = start_col;
        end insert_tab;

        end format_one_statement;

/* Convert a token and its trailers to items.

   Puts white space between two items if necessary.
*/
make_items:
        procedure (stmtx, tokenx, scan_control_comments, keep_gave_error_msg,
	  itemx);

        declare stmtx		fixed binary;   /* (Input) statement that the token is in */
        declare tokenx		fixed binary;   /* (Input) token to convert */
        declare scan_control_comments	bit (1) aligned;/* (Input) on to look for control comments */
        declare keep_gave_error_msg	bit (1) aligned;/* (Input) on to keep old value of item.gave_error_msg
					         in trailer items */
        declare itemx		fixed binary;   /* (Updated) last item */

        declare is_after_statement	bit (1) aligned;
        declare last_trailer_type	fixed binary (8);
        declare last_type		fixed binary (8);
        declare loop		bit (1) aligned;
        declare next_comment_in_col_1	bit (1) aligned;
        declare 1 style_before_trailers aligned like style;
        declare this_type		fixed binary (8);
        declare trailerx		fixed binary;

        declare trailer_string	char (trailer (trailerx).string_size)
				based (trailer (trailerx).string_ptr);

        declare last_space_class	(0:53) fixed binary (3) internal
				static options (constant)
				initial ((10) 1, 2,
					      /* ^ */
				(11) 1, 2,      /* prefix + */
				2,	      /* prefix - */
				1,	      /* assignment */
				2,	      /* : */
				1,	      /* ; */
				1,	      /* , */
				2,	      /* . */
				1,	      /* -> */
				3,	      /* ( */
				4,	      /* ) */
				2,	      /* % */
				1,	      /* target , */
				5,	      /* comment */
				(19) (1));

        declare this_space_class	(0:53) fixed binary (3) internal
				static options (constant)
				initial ((25) 1, 4,
					      /* : */
				2,	      /* ; */
				2,	      /* , */
				4,	      /* . */
				1,	      /* -> */
				1,	      /* ( */
				2,	      /* ) */
				4,	      /* % */
				2,	      /* target , */
				5,	      /* comment */
				1,	      /* nl_vt_np_token */
				3,	      /* bit_string */
				3,	      /* char_string */
				(16) (1));

        declare space_table		(5, 5) fixed binary (1)
				unsigned internal static
				options (constant)
				initial (1, 0, 1, 0, 1,
					      /* last space class 1 */
				0, 0, 0, 0, 1,  /* last space class 2 */
				0, 0, 0, 0, 0,  /* last space class 3 */
				1, 0, 0, 0, 1,  /* last space class 4 */
				1, 0, 1, 1, 1); /* last space class 5 */

        this_type = token (tokenx).type;
        last_type = item (itemx).type;

        if itemx >= hbound (item, 1) then
	      call error (4, "Too many tokens and comments in a statement.",
		token (tokenx).string_ptr);

        itemx = itemx + 1;
        unspec (item (itemx)) = ""b;
        item (itemx).type = this_type;
        item (itemx).string_ptr = token (tokenx).string_ptr;
        item (itemx).string_size = token (tokenx).string_size;

        if last_type = right_parn then
	      item (itemx).paren_depth = item (itemx - 1).paren_depth - 1;
        else
	      item (itemx).paren_depth = item (itemx - 1).paren_depth;

        if this_type = left_parn then
	      item (itemx).paren_depth = item (itemx).paren_depth + 1;

        item (itemx).precedence = precedence (this_type);

        if item (itemx - 1).trailer.NLs = 0 then
	      item (itemx).header.amount, item (itemx).header.need_space =
		space_table (last_space_class (last_type),
		this_space_class (this_type));

        if token (tokenx).trailer_index = 0 then
	      return;

        style_before_trailers = global.current_style;

        is_after_statement =
	  this_type = no_token | this_type = semi_colon
	  | is_macro_statement (stmt (stmtx).type)
	  & tokenx = stmt (stmtx).end;
        next_comment_in_col_1 =
	  this_type = no_token
	  | this_type = semi_colon & is_macro_statement (stmt (stmtx).type);
        last_trailer_type = no_token;

        loop = "1"b;
        do trailerx = token (tokenx).trailer_index by 1 while (loop);
	      if trailer (trailerx).type = nl_vt_np_token then
		    if is_after_statement | ^mode_delnl then
			  begin;
			  declare i		    fixed
						    binary (21);

			  next_comment_in_col_1 =
			      trailer_string ^= NL
			      | last_trailer_type = nl_vt_np_token
			      | next_comment_in_col_1;
			  do i = 1 to length (trailer_string);
				if substr (trailer_string, i, 1) = NL
				    then
				        item (itemx).trailer.NLs =
					  item (itemx).trailer.NLs
					  + 1;

				else if substr (trailer_string, i, 1)
				    = VT then
				        do;
				        item (itemx).trailer.VTs =
					  item (itemx).trailer.VTs
					  + 1;
				        item (itemx).trailer.NLs = 0;
				        end;

				else
				        do;     /* NP */
				        item (itemx).trailer.NP = "1"b;
				        item (itemx).trailer.VTs = 0;
				        item (itemx).trailer.NLs = 0;
				        end;
			  end;
			  end;
		    else
			  ;		      /* ignore vertical white space within stmt in delnl mode */

	      else
		    begin;		      /* comment trailer */
		    declare category	      fixed binary (2);
		    declare old_gave_error_msg      bit (1) aligned;

		    call adjust_vertical_white_space_after_item (itemx);

		    if this_type = semi_colon
		        & trailerx = token (tokenx).trailer_index + 1
		        & ^item (itemx).trailer.NP
		        & item (itemx).trailer.VTs = 0
		        & item (itemx).trailer.NLs = 1 & mode_delnl then
			  item (itemx).trailer.NLs = 0;

		    if itemx >= hbound (item, 1) then
			  call error (4,
			      "Too many tokens and comments in a statement.",
			      trailer (trailerx).string_ptr);

		    itemx = itemx + 1;
		    old_gave_error_msg = item (itemx).gave_error_msg;
		    unspec (item (itemx)) = ""b;
		    item (itemx).type = comment_token;
		    item (itemx).string_ptr = trailer (trailerx).string_ptr;
		    item (itemx).string_size =
		        trailer (trailerx).string_size;

		    if item (itemx - 1).type = right_parn then
			  item (itemx).paren_depth =
			      item (itemx - 1).paren_depth - 1;
		    else
			  item (itemx).paren_depth =
			      item (itemx - 1).paren_depth;

		    item (itemx).precedence = precedence (comment_token);
		    item (itemx).header.need_space =
		        space_table (
		        last_space_class (item (itemx - 1).type),
		        this_space_class (comment_token));
		    item (itemx).gave_error_msg =
		        old_gave_error_msg & keep_gave_error_msg;

		    do category = length (comment_indicator_extra_chars)
		        to 1 by -1
		        while (
		        substr (trailer_string, length (open_comment) + 1,
		        min (length (trailer_string)
		        - length (open_comment) - length (close_comment),
		        category))
		        ^=
		        substr (comment_indicator_extra_chars, 1, category))
		        ;
		    end;

		    item (itemx).comment_ind_len =
		        length (open_comment) + category;
		    item (itemx).header.insnl = category > 0;

		    if substr (trailer_string,
		        item (itemx).comment_ind_len + 1,
		        length (comment_indicator_no_indcomtxt))
		        = comment_indicator_no_indcomtxt then
			  item (itemx).comment_ind_len =
			      item (itemx).comment_ind_len
			      + length (comment_indicator_no_indcomtxt);
		    else
			  item (itemx).indcomtxt = "1"b;

		    if category = 0 then
			  if next_comment_in_col_1 then
				if mode_indcom & tokenx > 1 then
				        category = 2;
				else
				        category = 3;

			  else if is_after_statement | this_type = comma
			      | this_type = target_comma then
				category = 1;

		    if category = 3 then
			  do;
			  item (itemx).header.tab = "1"b;
			  item (itemx).header.amount = 1;
			  end;

		    else if category = 2 then
			  do;
			  item (itemx).header.tab = "1"b;
			  item (itemx).header.amount =
			      indent_margin (mode_indblkcom, left_margin);
			  item (itemx).header.tab_blkcom =
			      tokenx = stmt (stmtx).end;
			  end;

		    else if category = 1 then
			  do;
			  item (itemx).header.tab = "1"b;
			  item (itemx).header.amount = mode_comcol;
			  end;

		    else
			  do;
			  item (itemx).header.amount =
			      item (itemx).header.need_space;

			  if trailer (trailerx).continued & mode_linecom
			      then
				if trailer (trailerx + 1).type
				    = nl_vt_np_token then
				        do;
				        item (itemx).header.tab = "1"b;
				        item (itemx).header.amount =
					  mode_comcol;

				        if mode_delnl then
					      item (itemx).trailer
						.NLs = 1;
				        end;
			  end;

		    if scan_control_comments then
			  if is_control_comment (trailer_string,
			      (item (itemx).comment_ind_len),
			      item (itemx).gave_error_msg) then
				if is_after_statement then
				        do;
				        item (itemx).control_comment =
					  "1"b;
				        call format_pl1_modes_ (
					  temp_segs (*),
					  before (
					  after (trailer_string,
					  control_comment_indicator),
					  close_comment),
					  addr (trailer_string), "1"b,
					  item (itemx).gave_error_msg)
					  ;
				        end;

				else
				        call error (2,
					  "Control comment within statement.",
					  item (itemx).string_ptr);
		    end;

	      last_trailer_type = trailer (trailerx).type;
	      loop = trailer (trailerx).continued;
        end;
        call adjust_vertical_white_space_after_item (itemx);

        global.current_style = style_before_trailers;

        return;

adjust_vertical_white_space_after_item:
        procedure (itemx);

        declare itemx		fixed binary;   /* (Input) item to adjust */

        if (item (itemx).trailer.NP | item (itemx).trailer.VTs > 0)
	  & item (itemx).trailer.NLs = 0 then
	      item (itemx).trailer.NLs = 1;

        if item (itemx).type = comment_token & item (itemx).header.tab
	  & item (itemx).trailer.NLs = 0 & mode_insnl then
	      item (itemx).trailer.NLs = 1;
        end adjust_vertical_white_space_after_item;

is_control_comment:
        procedure (comment, comment_ind_len, gave_error_msg)
	  returns (bit (1) aligned);

        declare comment		char (*);	      /* (Input) comment which may be a control comment */
        declare comment_ind_len	fixed binary (3);
					      /* (Input) comment indicator length */
        declare gave_error_msg	bit (1);	      /* (Updated) on if printed it's a bad control comment */

        declare control_comment	bit (1) aligned;

        if index (comment, control_comment_indicator) = 0 then
	      return ("0"b);

        if verify (
	  before (substr (comment, comment_ind_len + 1),
	  control_comment_indicator), HT_SP) ^= 0 then
	      return ("0"b);

        control_comment =
	  search (
	  ltrim (
	  rtrim (
	  before (after (comment, control_comment_indicator), close_comment),
	  HT_SP), HT_SP), HT_SP) = 0;

        if ^control_comment & ^gave_error_msg then
	      do;
	      call error (2, "Invalid syntax in control comment.",
		addr (comment));
	      gave_error_msg = "1"b;
	      end;

        return (control_comment);
        end is_control_comment;

        end make_items;

/* Copy all items in a statement into the output segment. */

copy_items:
        procedure (first_item, last_item);

        declare first_item		fixed binary;   /* (Input) index of first item to copy */
        declare last_item		fixed binary;   /* (Input) index of last item to copy */

        declare itemx		fixed binary;

        declare item_string		char (item (itemx).string_size)
				based (item (itemx).string_ptr);

        do itemx = first_item to last_item;
	      if item (itemx).header.tab_blkcom then
		    item (itemx).header.amount =
		        indent_margin (mode_indblkcom, left_margin);

	      if item (itemx).control_comment then
		    do;
		    call format_pl1_modes_ (temp_segs (*),
		        before (
		        after (item_string, control_comment_indicator),
		        close_comment), addr (item_string), "1"b,
		        item (itemx).gave_error_msg);

		    if off_region_ptr = null then
			  if mode_on then
				call copy_item (itemx, "111"b);
			  else
				do;
				call copy_item (itemx, "100"b);
				off_region_ptr =
				    item (itemx).string_ptr;
				end;

		    else if mode_on then
			  do;
			  call copy_off_region (
			      char_offset_ ((item (itemx).string_ptr)));
			  call copy_item (itemx, "011"b);
			  end;
		    end;

	      else if mode_on then
		    call copy_item (itemx, "111"b);
        end;

        return;

/* Copy one item into the output segment. */

copy_item:
        procedure (itemx, copy_sws);

        declare itemx		fixed binary;   /* (Input) item to copy */
        declare copy_sws		bit (3) aligned;/* (Input) on to copy header, item, trailer, respectively */

        declare item_string		char (item (itemx).string_size)
				based (item (itemx).string_ptr);

        if substr (copy_sws, 1, 1) & item (itemx).header.amount > 0 then
	      begin;
	      declare col_to_go	        fixed binary;
	      declare tabs		        fixed binary;

	      if item (itemx).header.tab then
		    col_to_go = item (itemx).header.amount;
	      else
		    col_to_go = line_position + item (itemx).header.amount;

	      if col_to_go < line_position
		| col_to_go = line_position & line_position > 1
		& item (itemx).type ^= comment_token then
		    if mode_insnl | item (itemx).header.insnl then
			  do;
			  call copy_string (NL);
			  line_position = 1;
			  end;

		    else
			  col_to_go =
			      line_position
			      + item (itemx).header.need_space;

	      tabs = divide (col_to_go - 1, tab_interval, 17)
		- divide (line_position - 1, tab_interval, 17);
	      if tabs > 0 & col_to_go - line_position > 1 then
		    do;
		    call copy_char (HT, tabs);
		    line_position =
		        tab_interval
		        * divide (col_to_go - 1, tab_interval, 17) + 1;
		    end;

	      if line_position < col_to_go then
		    do;
		    call copy_char (SP, col_to_go - line_position);
		    line_position = col_to_go;
		    end;
	      end;

        if substr (copy_sws, 2, 1) then
	      if item (itemx).type = comment_token
		& (^global.rdc_source | index (item_string, "/*++") ^= 1)
		& item (itemx).indcomtxt & mode_indcomtxt then
		    begin;
		    declare comment_close_ind_len   fixed binary (21);
		    declare comment_text_len	      fixed binary (21);
		    declare scan_index	      fixed binary (21);

		    comment_text_len =
		        length (item_string)
		        - item (itemx).comment_ind_len
		        - length (close_comment);
		    comment_close_ind_len = length (close_comment);

		    scan_index =
		        verify (
		        reverse (
		        substr (item_string,
		        item (itemx).comment_ind_len + 1, comment_text_len))
		        , comment_indicator_extra_chars) - 1;
		    if scan_index < 0 then
			  scan_index = comment_text_len;

		    scan_index =
		        min (scan_index,
		        length (comment_indicator_extra_chars));
		    comment_text_len = comment_text_len - scan_index;
		    comment_close_ind_len =
		        comment_close_ind_len + scan_index;

		    if comment_text_len
		        >= length (comment_indicator_no_indcomtxt) then
			  if substr (item_string,
			      item (itemx).comment_ind_len
			      + comment_text_len
			      - length (comment_indicator_no_indcomtxt)
			      + 1,
			      length (comment_indicator_no_indcomtxt))
			      = comment_indicator_no_indcomtxt then
				do;
				comment_text_len =
				    comment_text_len
				    -
				    length (
				    comment_indicator_no_indcomtxt);
				comment_close_ind_len =
				    comment_close_ind_len
				    +
				    length (
				    comment_indicator_no_indcomtxt);
				end;

		    begin;
			  declare comment_close_ind	    char (
						    comment_close_ind_len
						    )
						    defined (
						    item_string)
						    position (
						    item (itemx)
						    .comment_ind_len
						    +
						    comment_text_len
						    + 1);
			  declare comment_indicator	    char (
						    item (itemx)
						    .
						    comment_ind_len)
						    defined (
						    item_string);
			  declare comment_text	    char (
						    comment_text_len)
						    defined (
						    item_string)
						    position (
						    item (itemx)
						    .comment_ind_len
						    + 1);

			  call indent_comment (comment_indicator,
			      comment_text, comment_close_ind,
			      (item (itemx).header.tab),
			      item (itemx).header.amount - 1,
			      line_position);
		    end;
		    end;

	      else
		    do;
		    call copy_string (item_string);

		    if item (itemx).type = char_string
		        | item (itemx).type = comment_token then
			  line_position =
			      last_line_position (line_position,
			      item_string);
		    else
			  line_position =
			      line_position + length (item_string);
		    end;

        if substr (copy_sws, 3, 1) & item (itemx).trailer.NLs > 0 then
	      do;
	      if (item (itemx).trailer.NP | item (itemx).trailer.VTs > 0)
		& line_position > 1 then
		    call copy_string (NL);

	      if item (itemx).trailer.NP then
		    call copy_string (NP);

	      call copy_char (VT, (item (itemx).trailer.VTs));
	      call copy_char (NL, (item (itemx).trailer.NLs));

	      line_position = 1;
	      end;

        return;

indent_comment:
        procedure (comment_indicator, comment_text, comment_close_ind, tab,
	  comment_indentation, line_position);

        declare comment_indicator	char (*);	      /* (Input) what the comment starts with */
        declare comment_text		char (*);	      /* (Input) text of comment to indent */
        declare comment_close_ind	char (*);	      /* (Input) what the comment ends with */
        declare tab			bit (1) aligned;/* (Input) on for block comments */
        declare comment_indentation	fixed binary;   /* (Input) number of columns to indent comment */
        declare line_position		fixed binary;   /* (Output) output segment line position */

        declare line_length		fixed binary (21);
        declare n_HT		fixed binary;
        declare n_SP		fixed binary;
        declare scan_index		fixed binary (21);
        declare scan_position		fixed binary (21);

        if tab then
	      begin;
	      declare text_indentation        fixed binary;

	      text_indentation =
		comment_indentation + length (comment_indicator || SP);
	      n_HT = divide (text_indentation, tab_interval, 17);
	      n_SP = text_indentation - tab_interval * n_HT;
	      end;

        call copy_string (comment_indicator);

        scan_position = 1;
        do while (scan_position <= length (comment_text));
	      scan_index =
		search (substr (comment_text, scan_position), NL_VT_NP) - 1;
	      if scan_index < 0 then
		    do;
		    scan_index =
		        length (substr (comment_text, scan_position));
		    line_length = scan_index;
		    end;

	      else
		    line_length =
		        length (
		        rtrim (
		        substr (comment_text, scan_position, scan_index),
		        HT_SP));

	      if scan_position = 1 then
		    begin;
		    declare line		      char (line_length)
					      defined (comment_text);

		    if verify (line, HT_SP) = 1 then
			  call copy_string (SP);

		    call copy_string (line);
		    end;

	      else if tab then
		    begin;
		    declare trim_length	      fixed binary (21);

		    trim_length =
		        length (
		        ltrim (
		        substr (comment_text, scan_position, line_length),
		        HT_SP));
		    if trim_length > 0 then
			  begin;
			  declare trimmed_line	    char (
						    trim_length)
						    defined (
						    comment_text)
						    position (
						    scan_position
						    + line_length
						    - trim_length);

			  call copy_char (HT, n_HT);
			  call copy_char (SP, n_SP);
			  call copy_string (trimmed_line);
			  end;
		    end;

	      else
		    begin;
		    declare line		      char (line_length)
					      defined (comment_text)
					      position (scan_position)
					      ;

		    call copy_string (line);
		    end;

	      scan_position = scan_position + scan_index;

	      scan_index =
		verify (substr (comment_text, scan_position), NL_VT_NP) - 1;
	      if scan_index < 0 then
		    scan_index =
		        length (substr (comment_text, scan_position));

	      begin;
		    declare vertical_white_space    char (scan_index)
					      defined (comment_text)
					      position (scan_position)
					      ;

		    call copy_string (vertical_white_space);
	      end;

	      scan_position = scan_position + scan_index;
        end;

        if tab
	  & index (NL_VT_NP, substr (output_string, copy_position - 1, 1)) > 0
	  then
	      do;
	      n_HT = divide (comment_indentation, tab_interval, 17);
	      call copy_char (HT, n_HT);
	      call copy_char (SP, comment_indentation - tab_interval * n_HT);
	      end;

        else if
	  index (HT_SP_NL_VT_NP, substr (output_string, copy_position - 1, 1))
	  = 0 then
	      call copy_string (SP);

        call copy_string (comment_close_ind);

        begin;
	      declare output	        char (copy_position - 1)
				        defined (output_string);

	      line_position = last_line_position (1, output);
        end;
        end indent_comment;

/* Copy one character several times into the output segment.

   The complicated case statement is just to get better code out of the compiler.
*/
copy_char:
        procedure (char, number);

        declare char		char (1);	      /* (Input) character to place in the output segment */
        declare number		fixed binary;   /* (Input) how many times to copy the character */

        if char = SP then
	      substr (output_string, copy_position, number) = "";

        else if char = HT then
	      substr (output_string, copy_position, number) =
		copy (HT, number);

        else if char = NL then
	      substr (output_string, copy_position, number) =
		copy (NL, number);

        else if char = VT then
	      substr (output_string, copy_position, number) =
		copy (VT, number);

        else
	      substr (output_string, copy_position, number) =
		copy (char, number);

        copy_position = copy_position + number;
        end copy_char;

        end copy_item;

        end copy_items;

/* Copy an off region into the output segment. */

copy_off_region:
        procedure (stop_position);

        declare stop_position		fixed binary (21);
					      /* (Input) last character to copy */

        declare off_region_length	fixed binary (21);

        declare off_region_string	char (off_region_length)
				based (off_region_ptr);

        off_region_length = stop_position - char_offset_ (off_region_ptr);

        call copy_string (off_region_string);
        line_position = last_line_position (line_position, off_region_string);

        off_region_ptr = null;
        end copy_off_region;

/* Copy a string into the output segment. */

copy_string:
        procedure (string);

        declare string		char (*);	      /* (Input) string to place in the output segment */

        substr (output_string, copy_position, length (string)) = string;
        copy_position = copy_position + length (string);
        end copy_string;

/* Calculate an indented margin. */

indent_margin:
        procedure (indent, margin) returns (fixed binary);

        declare indent		bit (1);	      /* (Input) on to indent to margin */
        declare margin		fixed binary;   /* (Input) margin to indent to */

        if indent then
	      return (margin);
        else
	      return (max (margin - mode_ind, 1));
        end indent_margin;

/* Calculate the line position after a string. */

last_line_position:
        procedure (line_position, string) returns (fixed binary);

        declare line_position		fixed binary;   /* (Input) line position string starts on */
        declare string		char (*);	      /* (Input) string to place at line_position */

        declare last_line_length	fixed binary (21);

        last_line_length = search (reverse (string), NL_VT_NP) - 1;
        if last_line_length < 0 then
	      return (next_line_position (line_position, string));

        begin;
	      declare last_line	        char (last_line_length)
				        defined (string)
				        position (length (string)
				        - last_line_length + 1);

	      return (next_line_position (1, last_line));
        end;
        end last_line_position;

/* Calculate the line position after a string on its first line, i.e. before any vertical white space. */

next_line_position:
        procedure (start_line_position, string) returns (fixed binary);

        declare start_line_position	fixed binary;   /* (Input) line position string start on */
        declare string		char (*);	      /* (Input) string to place at start_line_position */

        declare line_position		fixed binary (21);
        declare scan_index		fixed binary (21);
        declare scan_position		fixed binary (21);

        line_position = start_line_position;
        scan_position = 1;
        do while (scan_position <= length (string));
	      scan_index =
		search (substr (string, scan_position), HT_BS_NL_VT_NP) - 1;
	      if scan_index < 0 then
		    scan_index = length (substr (string, scan_position));

	      line_position = line_position + scan_index;
	      scan_position = scan_position + scan_index + 1;

	      if scan_position - 1 <= length (string) then
		    if substr (string, scan_position - 1, 1) = HT then
			  line_position =
			      tab_interval
			      *
			      divide (line_position + tab_interval - 1,
			      tab_interval, 17) + 1;

		    else if substr (string, scan_position - 1, 1) = BS then
			  line_position = line_position - 1;

		    else
			  scan_position = length (string) + 1;
        end;

        return (line_position);
        end next_line_position;

/* Print an error message. */

error:
        procedure (severity, error_string, source_ptr);

        declare severity		fixed binary (35);
					      /* (Input) severity of the error */
        declare error_string		char (*);	      /* (Input) error message */
        declare source_ptr		pointer unaligned;
					      /* (Input) pointer to error in source */

        call format_pl1_error_ (temp_segs (*), severity, error_string,
	  (source_ptr));

        if severity >= 4 then
	      goto unrecoverable_error;
        end error;

        end format_pl1_;

