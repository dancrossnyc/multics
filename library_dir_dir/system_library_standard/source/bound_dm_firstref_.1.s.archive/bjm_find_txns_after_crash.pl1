/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(86-01-07,Pierret), approve(86-01-30,MCR7331),
     audit(86-04-28,Newcomb), install(86-05-06,MR12.0-1054):
     Changed to check the tid in bj_rec_hdr and log an error if it is less than
     or equal to 0.
                                                   END HISTORY COMMENTS */


/* HISTORY PRIOR TO INITIAL INSTALLATION:

Written by Lee A. Newcomb, 11/15/82.
Modified:
12/06/82 by L. A. Newcomb:  handle Check_mode and fill in bj_txte.bj_uid.
03/02/83 by L. A. Newcomb: to recognize file_manager_ rollback and
	  post-commit handlers, and the begin commit mark;  this is
	  preparation for their actual use, more work is needed.  In
	  addition, the program is brought up-to-date with modifications
	  made to the bj_txt.
04/29/83 by L. A. Newcomb:  Added setting of bj_txte.(last_completed_operation
            ok_to_write) so writing an abort mark will work; initialized entry
            counts in the TDT and TXT; expanded inline documentation.
05/18/83 by Lindsey L. Spratt:  Changed to use the version 3 TDT.
12/06/83 by L. A. Newcomb:  Renamed before_journal_manager_static_ to
            bjm_data_ and moved some cells from dm_data_ to bjm_data_.
06/07/84 by Lee Baldwin:  Renamed dm_error_$bj_first_txn_record_type_bad to
            $bj_bad first_txn_record_type, $bj_inconsistent_txn_records to
            $bj_unexpected_eot_mark, and $bj_prev_rec_id_wrong to
            $wrong_prev_rec_id.
06/11/84 by Lee Baldwin:  Renamed dm_error_$bj_bad_txn_id_in_prev_record
            to $bj_rec_txn_id_mismatch.
10/24/84 by Lee A. Newcomb:  Changed user id in TDT to "<PRE-CRASH>" from
            "<GUESS WHO>" and did some small fixing up of format.
12/10/84 by R. Michael Tague:  Changed incl name to dm_daemon_sv_codes.
01/16/85 by Lee A. Newcomb:  Fixed to use dm_log_sv_codes.incl.pl1 instead of
            the obsolete dm_daemon_sv_codes.incl.pl1; fixed the BJM entry
            protocol to only invoke the cleanup procedure if we can set
            bj_data_$bj_operation; minor format changes.
02/28/85 by Lee A. Newcomb:  Added understanding FM_(ROLLBACK
            POSTCOMMIT)_HANDLER's can be first records of a txn chain; removed
            tests for HANDLER records as they are not currently supported;
            reset code at each step through the GET_PREVIOUS_LOOP as
            check_mode would cause an error to occur for each record read
            after the one in error was read; fixed to set the txn state to
            TM_COMMIT_WRITING_MARK_STATE when a BEGIN_COMMIT record is found
            so we will roll the txn forward.
03/04/85 by Lee A. Newcomb:  Fixed to report txn ID's in decimal and not read
            past a ROLLED_BACK mark in the FIND_FIRST_RECORD do group.
03/05/85 by Steve Herbst: Replaced dm_log_ with dm_misc_util_$log.
03/19/85 by Steve Herbst: Fixed to initialize bjm_data_$bj_code.

END HISTORY PRIOR TO INITIAL INSTALLATION */


/* DESCRIPTION:

	bjm_find_txns_after_crash is THE program to read a before journal
     opened for crash recovery.  ANY CHANGES TO BJM_WRITE OR BJ_TXTE_UTIL
     SHOULD BE EXAMINED TO BE SURE THEY DO NOT INVALIDATE ASSUMPTIONS MADE
     IN THIS MODULE.  Likewise, any changes to this module should be sure
     to not contradict the journal writing mechanisms in the above modules.

	This program is contracted to find all unfinished transactions in a
     before journal (BJ) that was open during a crash.  Its intended caller is
     dm_recovery_.  Two lists are created for "registering" txns: unfinished
     txns to be rolled back or, if multi-phase commits, to be completed; and
     finished txns (i.e., a commit or abort mark is in the BJ for the txn).
     These two lists are kept in temp.  segs.  in the process' [pd] for
     accounting purposes.  However, ONLY INFORMATION NEEDED FOR RECOVERY OF THE
     UNFINISHED TRANSACTIONS IS RETURNED TO THE CALLER.  This data is returned
     in two structures provided by the caller that are currently images of the
     tm_tdt and bj_txt.  No information on any found, finished txns is returned
     to the caller.

	Currently, if any error in processing is encountered, a non-zero code
     is returned and no data is returned.  The exception to this is when
     check mode is enabled; then the fact that too many or few unfinished
     (active) transactions were found is reported.  The entire journal will be
     swept in reverse order and the bj_storage_get loop will not be reached
     (N.B., it is theoretically possible for check_mode to find non-existant
     errors).  In general, if a "fatal" error occurs, the caller's lists will
     contain the data acquired up to the time the error happens.

	The main procedure is responsible for detecting gross errors (e.g.
     multiple commit or abort marks for the same transaction).  The error
     detection should stand out when the main proc.  is read as it is all
     over the place.  Besides the normal clean_up proc., there are four
     other internal procedures, in two sets.  The first set is called to see
     if a transaction has been recognized as either finished or unfinished.
     These do a simple sequential search through the lists of finished or
     unfinished transactons, returning true or false; they also set
     "txn_idx", the slot into the appropriate list where this transaction's
     data is kept.  If false is returned, txn_idx is zero indicating a new
     transaction has been encountered in the journal.  The second set
     registers the data for the transaction in the appropriate list.  They
     also do consistency checking (e.g., the owner's process_id is the same
     in all records of the transaction).  These two require txn_idx to be
     set to the proper index into the list(s), zero (register a new txn), or
     -1 (must find the correct position in the lists).

	Note: changes will have to be made when checkpoints, multi-phase
     commits, and any change to the before journal record structure are
     made.  Also, the effect of "orphan" records in the journal must be
     examined and allowances made for them if necessary.
*/

/* format: style2,ll79,ind3,^indprocbody,ifthendo,ifthen,^indnoniterdo,^inddcls,dclind5,idind35,linecom */
%page;
bjm_find_txns_after_crash:
   proc (p_old_tm_tdt_ptr, p_old_bj_txt_ptr, p_bj_oid, p_check_mode, p_code);

/* START OF DECLARATIONS */

/* Parameters */
dcl  (
     p_old_tm_tdt_ptr		ptr,
     p_old_bj_txt_ptr		ptr,
     p_bj_oid			bit (36) aligned,
     p_check_mode			bit (1) aligned,	/* sweep the entire journal for inconsistencies? */
     p_code			fixed bin (35)	/* OUTPUT: normal error code, recovery fails if ^= 0 */
     )				parameter;

/* Automatic */
dcl  (
     bit_bucket			bit (1) aligned,
     bj_oid			bit (36) aligned,	/* local holder of param. */
     bj_rec_id			bit (36) aligned,
     bj_uid			bit (36) aligned,	/* for error reporting */
     check_mode			bit (1) aligned,	/* local holder of param. */
     clean_code			fixed bin (35),
     code				fixed bin (35),	/* local holder of error code */
     finished_txns_list_p		ptr,		/* local finished txn list loc. */
     get_previous_loop		bit (1) aligned,	/* so register_unknown knows how to cmp rec_id's */
     last_bj_rec_id			bit (36) aligned,	/* for error reporting in get_previous loop */
     1 local_bj_rec_hdr		aligned like bj_rec_hdr,
						/* local copy since it's small */
     n_registered_finished_txns	fixed bin,	/* # of finished txns found */
     n_registered_unfinished_txns	fixed bin,	/* # of unfinished txns found */
     n_unfinished_txns		fixed bin,	/* # of unfinished txns recorded in last bj rec. */
     old_bj_txt_p			ptr,		/* local of loc. of caller's bjm data list */
     old_tm_tdt_p			ptr,		/* local of loc. of caller's tm data list */
     txn_idx			fixed bin,	/* used for loops in is_("" un)finished_txn */
     unfinished_txns_list_p		ptr		/* local unfinished txn list loc. */
     )				automatic;

/* Based */

/* the next two structures are used to keep track of the transactions found */
/*     in the before journal.  Extra data is currently being kept during */
/*     development phase to help detect errors in recording journal records */
/*     (if they occur). */

dcl  1 finished_txns_list		dim (1:n_registered_finished_txns)
				aligned based (finished_txns_list_p),
       2 txn_id			bit (36),
       2 owners_process_id		bit (36),		/* of txn owner */
       2 n_effective_records_written	fixed bin (36) unsigned,
						/* would have matched bj_txte.tx_rec_no */
       2 n_effective_records_read	fixed bin (36) unsigned,
						/* never to exceed ...written */
       2 prev_rec_id		bit (36),		/* may restart after rollback mark found */
       2 rollback_mark_found		bit (1);		/* allows extra records after ...written = ...read */

dcl  1 unfinished_txns_list		dim (1:n_registered_unfinished_txns)
				aligned based (unfinished_txns_list_p),
						/* most data kept in tm_tdt and bj_txt */
       2 n_effective_records_read	fixed bin (36) unsigned,
						/* never to exceed bj_txte.n_rec_written */
       2 prev_rec_id		bit (36),		/* may restart after rollback mark found */
       2 rollback_mark_found		bit (1);		/* allows extra records after ...written = ...read */

/* Builtin */
dcl  (addr, bin, null, unspec)	builtin;

/* Condition */
dcl  cleanup			condition;

/* Entry */
dcl  (
     bj_cleanup_tables$handler	entry (fixed bin (35)),
     bj_oid_util$get_uid		entry (bit (36) aligned)
				returns (bit (36) aligned),
     bj_storage_get_header		entry (bit (36) aligned,
				bit (36) aligned, ptr),
     bj_storage_get_header$last	entry (bit (36) aligned,
				bit (36) aligned, ptr),
     bj_storage_get_header$previous	entry (bit (36) aligned,
				bit (36) aligned, ptr),
     dm_misc_util_$log		entry options (variable),
     get_temp_segment_		entry (char (*), ptr, fixed bin (35)),
     release_temp_segment_		entry (char (*), ptr, fixed bin (35))
     )				external;

/* External */
dcl  (
     dm_error_$bj_rec_txn_id_mismatch,
     dm_error_$bj_first_txn_rec_not_found,
     dm_error_$bj_bad_first_txn_record_type,
     dm_error_$bj_bad_tid,
     dm_error_$bj_unexpected_eot_mark,
     dm_error_$bj_neg_txns_in_unfinished_rec,
     dm_error_$bj_wrong_prev_rec_id,
     dm_error_$bj_rec_process_id_mismatch,
     dm_error_$bj_recursive_invoc,
     dm_error_$bj_too_few_records,
     dm_error_$bj_too_few_unfinished_txns,
     dm_error_$bj_too_many_unfinished_txns,
     dm_error_$bj_wrong_numb_txn_records,
     dm_error_$bj_zero_txns_in_unfinished_rec,
     error_table_$unimplemented_version
     )				fixed bin (35) ext static;

/* END OF DECLARATIONS */
%page;
COPY_INPUT_AND_INIT_OUTPUT_PARAMETERS:
   do;
      old_tm_tdt_p = p_old_tm_tdt_ptr;
      if old_tm_tdt_p -> tm_tdt.version ^= TM_TDT_VERSION_3 then do;
         p_code = error_table_$unimplemented_version;
         return;
      end;
      old_bj_txt_p = p_old_bj_txt_ptr;
      if old_bj_txt_p -> bj_txt.version ^= BJ_TXT_VERSION_1 then do;
         p_code = error_table_$unimplemented_version;
         return;
      end;

      bj_oid = p_bj_oid;
      bj_uid = bj_oid_util$get_uid (bj_oid);		/* we want the UID for reporting errors */
      check_mode = p_check_mode;
      p_code = 0;					/* let's be optimistic */

   end COPY_INPUT_AND_INIT_OUTPUT_PARAMETERS;

BJM_STANDARD_ENTRY_PROTOCOL:
   do;

      if bjm_data_$bj_operation ^= "" then do;
         code = dm_error_$bj_recursive_invoc;
         go to no_cleanup_return;
      end;

SET_CLEANUP_HANDLER:
      do;

/* N.B. we do not cross rings for now as this should only	*/
/* be used as this should be used from DM ring only.	*/
/* However, we must be able to reset bj_operation before it */
/* we set it.					*/

         finished_txns_list_p, unfinished_txns_list_p = null ();
         code = 0;
         on cleanup call clean_up ();

      end SET_CLEANUP_HANDLER;

      bjm_data_$bj_operation = "bjm_find_txns_after_crash";
      bjm_data_$bj_code = 0;

   end BJM_STANDARD_ENTRY_PROTOCOL;
%page;
GET_TEMP_STORAGE:
   call get_temp_segment_ ("bjm_find_txns_after_crash", finished_txns_list_p,
        code);
   if code ^= 0 then do;
      call dm_misc_util_$log (LOG_SV, code, "bjm_find_txns_after_crash",
	 "Unable to get temp. storage for finished txn. list.");
      go to clean_and_return;
   end;

   call get_temp_segment_ ("bjm_find_txns_after_crash", unfinished_txns_list_p,
        code);
   if code ^= 0 then do;
      call dm_misc_util_$log (LOG_SV, code, "bjm_find_txns_after_crash",
	 "Unable to get temp. storage for unfinished txn. list.");
      go to clean_and_return;
   end;


SET_COUNTERS:
   do;
      n_registered_unfinished_txns,			/* initialize these for the register_* procs. */
	 n_registered_finished_txns, old_tm_tdt_p -> tm_tdt.entry_count,
	 old_bj_txt_p -> bj_txt.n_entries_used = 0;
   end SET_COUNTERS;

   bj_rec_hdr_ptr = addr (local_bj_rec_hdr);		/* for convience */
%page;
GET_LAST_JOURNAL_RECORD:				/* must get the last record of the journal to start things off; better known */
						/*     as the head chasing the tail.  Must set up bj_... error handling, */
						/*     though I can't think why getting the last record hdr would blow up */
						/*     Note the special mercy given if check_mode is true. */
   bjm_data_$bj_exit_err = cannot_get_last_journal_record;
   call bj_storage_get_header$last (bj_oid, bj_rec_id, bj_rec_hdr_ptr);

   if bj_rec_id = ""b then				/* no records in journal ==> nothing to do */
      go to clean_and_return;

   n_unfinished_txns = bj_rec_hdr.n_txn;		/* # of active txns in before journal */

   if n_unfinished_txns < 0 then do;			/* a negative # of active txns?? */

      code = dm_error_$bj_neg_txns_in_unfinished_rec;
      call dm_misc_util_$log (LOG_SV, code, "bjm_find_txns_after_crash",
	 "Last journal record, BJ uid ^o, record id ^o.", bj_uid, bj_rec_id);
      if check_mode then
         go to register_last_record;			/* keep plugging */
      else go to clean_and_return;			/* or use the die_immediate instruction */
   end;

   if n_unfinished_txns = 0 then do;			/* better be a commit or abort */

      if bj_rec_hdr.type ^= BJ_RECORD_TYPE.COMMITTED
	 & bj_rec_hdr.type ^= BJ_RECORD_TYPE.ABORTED then do;

         code = dm_error_$bj_zero_txns_in_unfinished_rec;
         call dm_misc_util_$log (LOG_SV, code, "bjm_find_txns_after_crash",
	    "Invalid last before journal record, BJ uid ^o, record id ^o.",
	    bj_uid, bj_rec_id);
      end;
      if check_mode then
         go to register_last_record;			/* we sweep the whole journal */
      else go to clean_and_return;			/* or nothing to do */
   end;

   else go to register_last_record;
%page;
cannot_get_last_journal_record:
   do;

/* we come here if a non-local goto is done by the bj_storage_get_header$last */
/*     call.  Even check_mode can't save us this time. */

      code = bjm_data_$bj_code;
      call dm_misc_util_$log (LOG_SV, code, "bjm_find_txns_after_crash",
	 "Unable to read last record in before journal, BJ uid ^o.", bj_uid);
      go to clean_and_return;
   end;
%skip (4);
register_last_record:
   do;

/* If we get here, we have the header of the last record in the journal. */
/*     Since our lists of txns. are empty, must always add the txn. data. */
/*     Remember, if we decide the record is active, register_unfinished_txn */
/*     will decrement n_unfinished_txns. */

      txn_idx = 0;					/* know the txn list is empty */

      if bj_rec_hdr.type = BJ_RECORD_TYPE.COMMITTED
	 | bj_rec_hdr.type = BJ_RECORD_TYPE.ABORTED then
         call register_finished_txn (code);
      else call register_unfinished_txn (code);

      if code ^= 0 then do;				/* can't do a thing */

         call dm_misc_util_$log (LOG_SV, code, "bjm_find_txns_after_crash",
	    "Could not register last BJ record, BJ uid ^o, record id ^o.",
	    bj_uid, bj_rec_id);
         if ^check_mode then
	  go to clean_and_return;
      end;
   end;
%page;
/* Now loop until all unfinished txns have been found and	*/
/* most or all of the data required for recovery has been	*/
/* recorded in the caller's storage.  If check_mode is on,	*/
/* we will never leave this loop until all journal records	*/
/* have been read or an error is taken by the		*/
/* get_header$previous call.  If check_mode is off, the	*/
/* get_header loop (following this loop) will be used to	*/
/* make sure all recovery data has been found.		*/

FIND_AND_REGISTER_TRANSACTONS:
   do;
      get_previous_loop = "1"b;			/* for register_unfinished... */
      last_bj_rec_id = ""b;				/* for error reporting */
      bjm_data_$bj_exit_err = cannot_get_previous_record;

/* Loop until we have what we think are all active txns or the entire */
/* BJ has been read backwards chronologically (latter if check_mode on). */
/* Note we clear any error from the code cell; this is only	*/
/* really useful if we are in check_mode as any error found	*/
/* will stay with us for ALL records read from that point	*/
/* on; as the setting is cheap, we do not bother to test	*/
/* check_mode to see if we need to set code to zero.	*/

GET_PREVIOUS_LOOP:
      do while (n_unfinished_txns > 0 | check_mode);

         code = 0;
         call bj_storage_get_header$previous (bj_oid, bj_rec_id,
	    bj_rec_hdr_ptr);

         if bj_rec_id = ""b then do;			/* We have read all the records in the BJ. */

	  if ^check_mode then do;			/* should not happen unless in check mode */
	     code = dm_error_$bj_too_few_records;	/* by definition */
	     call dm_misc_util_$log (LOG_SV, code,
		"bjm_find_txns_after_crash",
		"In get_previous loop, BJ uid ^o, last read record id ^o.",
		bj_uid, last_bj_rec_id);
	     go to clean_and_return;
	  end;

	  if n_unfinished_txns > 0 then do;		/* we missed some active txns */
	     code = dm_error_$bj_too_few_unfinished_txns;
	     call dm_misc_util_$log (LOG_SV, code,
		"bjm_find_txns_after_crash",
		"BJ uid ^o, last read record id ^o.", bj_uid,
		last_bj_rec_id);
	  end;
	  else if n_unfinished_txns < 0 then do;	/* we got too many active txns */
	     code = dm_error_$bj_too_many_unfinished_txns;
	     call dm_misc_util_$log (LOG_SV, code,
		"bjm_find_txns_after_crash",
		"BJ uid ^o, last read record id ^o.", bj_uid, bj_rec_id);
	  end;
	  else do;				/* must check all 1st records of active txns found */
						/* if code stays zero, no problems in journal */
	     do txn_idx = 1 to n_registered_unfinished_txns;
	        if unfinished_txns_list.prev_rec_id (txn_idx) ^= ""b then do;
		 code = dm_error_$bj_first_txn_rec_not_found;
		 call dm_misc_util_$log (LOG_SV, code,
		      "bjm_find_txns_after_crash",
		      "While in check_mode with all transactions found, BJ uid ^o, txn id ^d.",
		      bj_uid,
		      bin (old_tm_tdt_p -> tm_tdt.entry (txn_idx).txn_id));
	        end;
	     end;					/* of checking for 1st records */
	  end;

	  go to clean_and_return;
         end;					/* end beginning of BJ check */

/* LOOP CONTINUED ON NEXT PAGE */
%page;
/* LOOP CONTINUED FROM PREVIOUS PAGE */

         if bj_rec_hdr.n_txn < 0 then do;
	  code = dm_error_$bj_neg_txns_in_unfinished_rec;
	  call dm_misc_util_$log (LOG_SV, code, "bjm_find_txns_after_crash",
	       "During bj_storage_get_header$previous loop, BJ uid ^o, record id ^o.",
	       bj_uid, bj_rec_id);
	  if check_mode then
	     go to end_get_previous_loop;		/* continue reading */
	  else go to clean_and_return;
         end;

         if bin (bj_rec_hdr.tid) <= 0 then do;
	  code = dm_error_$bj_bad_tid;
	  call dm_misc_util_$log (LOG_SV, code, "bjm_find_txns_after_crash",
	       "During bj_storage_get_header$previous loop, BJ uid ^o, record id ^o, TID ^d.",
	       bj_uid, bj_rec_id, bin (bj_rec_hdr.tid));
	  if check_mode then
	     go to end_get_previous_loop;		/* continue reading */
	  else go to clean_and_return;
         end;

         if bj_rec_hdr.type = BJ_RECORD_TYPE.COMMITTED
	    | bj_rec_hdr.type = BJ_RECORD_TYPE.ABORTED then do;

	  if is_unfinished_txn () then do;		/* finished and then unfinished? */

	     code = dm_error_$bj_unexpected_eot_mark;
	     call dm_misc_util_$log (LOG_SV, code,
		"bjm_find_txns_after_crash",
		"Commit or abort mark found ahead of a before image.  "
		|| "BJ uid ^o, record id ^o, txn id ^d.", bj_uid,
		bj_rec_id, bin (bj_rec_hdr.tid));
	     if check_mode then
	        go to end_get_previous_loop;
	     else go to clean_and_return;
	  end;

	  if is_finished_txn () then do;		/* can't be finished more than once */

	     code = dm_error_$bj_unexpected_eot_mark;
	     call dm_misc_util_$log (LOG_SV, code,
		"bjm_find_txns_after_crash",
		"Multiple commit or abort marks found for the same txn.  BJ uid ^o, "
		|| "record id ^o, txn id ^d.", bj_uid, bj_rec_id,
		bin (bj_rec_hdr.tid));
	     if check_mode then
	        go to end_get_previous_loop;
	     else go to clean_and_return;
	  end;

/* LOOP CONTINUED ON NEXT PAGE */
%page;
/* LOOP CONTINUED FROM PREVIOUS PAGE */
/* OK, it's a good record and is_finished_txn has set txn_idx to 0 for us. */
/*     Add the record to the list of finished transactions. */

	  call register_finished_txn (code);

	  if code ^= 0 then do;
finsihed_txn_reg_err:				/* to avoid some duplication later */
	     call dm_misc_util_$log (LOG_SV, code,
		"bjm_find_txns_after_crash",
		"Error registering finished txn., BJ uid ^o, record id ^o, txn id ^d.",
		bj_uid, bj_rec_id, bin (bj_rec_hdr.tid));
	     if check_mode then
	        go to end_get_previous_loop;
	     else go to clean_and_return;
	  end;
         end;

         else if ^is_finished_txn () then do;		/* if not a before image of an already finished txn */

	  txn_idx = -1;				/* must find the place in lists */
	  call register_unfinished_txn (code);		/* will affect n_unfinished_txns */
	  if code ^= 0 then do;

	     call dm_misc_util_$log (LOG_SV, code,
		"bjm_find_txns_after_crash",
		"Error registering unfinished txn., BJ uid ^o, record id ^o, txn id ^d.",
		bj_uid, bj_rec_id, bin (bj_rec_hdr.tid));
	     if check_mode then
	        go to end_get_previous_loop;
	     else go to clean_and_return;
	  end;
         end;
         else do;					/* for now do consistency checking on finished txn */

	  call register_finished_txn (code);		/* is_finsihed_txn call still has txn_idx set */
	  if code ^= 0 then
	     go to finsihed_txn_reg_err;		/* just being a bit lazy */
         end;

end_get_previous_loop:
         last_bj_rec_id = bj_rec_id;			/* for error reporting only */

      end GET_PREVIOUS_LOOP;

   end FIND_AND_REGISTER_TRANSACTONS;

   go to GET_FIRST_RECORD_FOR_UNFINISHED_TXNS;		/* this loop worked, skip its unwinding handler */
%page;
cannot_get_previous_record:
   do;

/* We come here if bj_storage_get_header$previous call takes an error and */
/* unwinds.  We don't care about check_mode in this case. */

      code = bjm_data_$bj_code;

      call dm_misc_util_$log (LOG_SV, code, "bjm_find_txns_after_crash",
	 "A call to bj_storage_get_previous in recovery phase failed, BJ uid ^o, last read record id ^o.",
	 bj_uid, bj_rec_id);
      go to clean_and_return;
   end;
%page;
/* GET LOOP */

/* We now have a list of all unfinished txns in the before journal being */
/*     used.  If the 1st record in the journal for a txn. has not yet been */
/*     found, find it.  For now, any error will cause processing to stop. */
/*     It is not advised to attempt to rollback any txns with the data */
/*     gathered before the error.  Note: this loop will never be executed if */
/*     check_mode is on. */

GET_FIRST_RECORD_FOR_UNFINISHED_TXNS:
   do;
      get_previous_loop = ""b;			/* for register_unfinished... */
      bjm_data_$bj_exit_err = cannot_get_a_record;

WALK_UNFINISHED_TXNS_LIST:
      do txn_idx = 1 to n_registered_unfinished_txns;	/* get 1st record of the unfinished txns */

FIND_FIRST_RECORD:					/* done when previous record ID is null, or we have found a	*/
						/* ROLLED_BACK mark with checkpoint ID zero (in this case,	*/
						/* we cannot trust previous records have not been		*/
						/* recycled).  THIS CODE WILL NEED MODIFICATION WHEN A	*/
						/* CHECKPOINT FACILITY IS AVAILABLE.			*/
         do while (unfinished_txns_list.prev_rec_id (txn_idx) ^= ""b
	    & ^unfinished_txns_list.rollback_mark_found (txn_idx));

	  call bj_storage_get_header (bj_oid,
	       unfinished_txns_list.prev_rec_id (txn_idx), bj_rec_hdr_ptr);

	  if bj_rec_hdr.n_txn < 0 then do;

	     code = dm_error_$bj_neg_txns_in_unfinished_rec;
	     call dm_misc_util_$log (LOG_SV, code,
		"bjm_find_txns_after_crash",
		"During bj_storage_get_header loop, BJ uid ^o, record id ^o.",
		bj_uid, unfinished_txns_list.prev_rec_id (txn_idx));
	     go to clean_and_return;
	  end;
	  if bj_rec_hdr.n_txn = 0 then do;

	     code = dm_error_$bj_zero_txns_in_unfinished_rec;
	     call dm_misc_util_$log (LOG_SV, code,
		"bjm_find_txns_after_crash",
		"During bj_storage_get_header loop, BJ uid ^o, record id ^o.",
		bj_uid, unfinished_txns_list.prev_rec_id (txn_idx));
	     go to clean_and_return;
	  end;

	  if bj_rec_hdr.type = BJ_RECORD_TYPE.COMMITTED | /* finished and then unfinished?? */
	       bj_rec_hdr.type = BJ_RECORD_TYPE.ABORTED then do;

	     code = dm_error_$bj_unexpected_eot_mark;
	     call dm_misc_util_$log (LOG_SV, code,
		"bjm_find_txns_after_crash",
		"Commit or abort mark found ahead of before image.  BJ uid ^o, record id ^o, txn id ^d.",
		bj_uid, unfinished_txns_list.prev_rec_id (txn_idx),
		bin (old_tm_tdt_p -> tm_tdt.entry (txn_idx).txn_id));
	     go to clean_and_return;
	  end;
%page;
	  if bj_rec_hdr.tid ^= old_tm_tdt_p -> tm_tdt.entry (txn_idx).txn_id
	  then do;

	     code = dm_error_$bj_rec_txn_id_mismatch;
	     call dm_misc_util_$log (LOG_SV, code,
		"bjm_find_txns_after_crash",
		"During bj_storage_get_header loop, BJ uid ^o, record id ^o, txn id ^d.",
		bj_uid, unfinished_txns_list.prev_rec_id (txn_idx),
		bin (old_tm_tdt_p -> tm_tdt.entry (txn_idx).txn_id));
	     go to clean_and_return;
	  end;

	  call register_unfinished_txn (code);		/* merges in required data for caller */

	  if code ^= 0 then do;
	     call dm_misc_util_$log (LOG_SV, code,
		"bjm_find_txns_after_crash",
		"Error while looking for 1st record of unfinished txn. BJ uid ^o, record id ^o, txn id ^d.",
		bj_uid, unfinished_txns_list.prev_rec_id (txn_idx),
		bin (old_tm_tdt_p -> tm_tdt.entry (txn_idx).txn_id));
	     go to clean_and_return;
	  end;

         end FIND_FIRST_RECORD;			/* of getting 1st record for a single txn */

      end WALK_UNFINISHED_TXNS_LIST;			/* of getting all txns 1st records */

   end GET_FIRST_RECORD_FOR_UNFINISHED_TXNS;

   go to clean_and_return;				/* loop worked, skip its unwinding handler */
%skip (4);
cannot_get_a_record:				/* come here if get call unwinds */
   do;

      code = bjm_data_$bj_code;

      call dm_misc_util_$log (LOG_SV, code, "bjm_find_txns_after_crash",
	 "A call to bj_storage_get in recovery phase failed, BJ uid ^o, record id ^o, txn id ^d.",
	 bj_uid, unfinished_txns_list.prev_rec_id (txn_idx),
	 bin (old_tm_tdt_p -> tm_tdt.entry (txn_idx).txn_id));
      go to clean_and_return;
   end;
%skip (6);
/* we're DONE, error or not */
clean_and_return:
   call clean_up ();
no_cleanup_return:
   p_code = code;					/* in case clean_up took error */

   return;
%page;
is_finished_txn:
   proc () returns (bit (1) aligned);

/* This procedure does a simple look through the finished_txns_list to see */
/*     if the txn we are working over has had a commit or abort mark found */
/*     in a previously read before image.  If so, "1"b is returned, */
/*     otherwise, ""b. N.B., txn_idx is left as a residue for the */
/*     registering routines for efficency, and zeroed if the txn id is */
/*     not found. */

   do txn_idx = 1 to n_registered_finished_txns;

      if finished_txns_list.txn_id (txn_idx) = bj_rec_hdr.tid then
         return ("1"b);
   end;

   txn_idx = 0;					/* for registering proc. */
   return (""b);					/* did not find the txn id in the temp list */

   end is_finished_txn;
%skip (6);
is_unfinished_txn:
   proc () returns (bit (1) aligned);

/* This procedure does a simple look to see if the txn we are working over */
/*     has never had a commit or abort mark found in a previously read */
/*     before image.  If so, "1"b is returned, otherwise, ""b.  N.B. see */
/*     is_finished_txn proc for use of txn_idx */

   do txn_idx = 1 to n_registered_unfinished_txns;

      if old_tm_tdt_p -> tm_tdt.entry (txn_idx).txn_id = bj_rec_hdr.tid then
         return ("1"b);
   end;

   txn_idx = 0;					/* let registering routines know a new entry needed */
   return (""b);					/* did not find the txn id in the temp list */

   end is_unfinished_txn;
%page;
register_finished_txn:
   proc (temp_code);

/* This proc. records a list of finished txns for later searching. */
/*     Some consistency checking will also be done. */
/*     Note the only way for a txn. to get registered initially is for a */
/*     commit or abort record to be found.  This fact is used in the */
/*     "if txn_idx = 0" do group which does the initial registration. */

dcl  temp_code			fixed bin (35) parameter;

   if txn_idx = -1 then				/* must get it */
      bit_bucket = is_finished_txn ();

   if txn_idx = 0 then do;				/* totally new data */
      n_registered_finished_txns, txn_idx = n_registered_finished_txns + 1;

      finished_txns_list.txn_id (txn_idx) = bj_rec_hdr.tid;
      finished_txns_list.owners_process_id (txn_idx) = bj_rec_hdr.process_id;
      finished_txns_list.n_effective_records_written (txn_idx) =
	 bj_rec_hdr.tx_rec_no;
      finished_txns_list.n_effective_records_read (txn_idx) = 1;

      if bj_rec_hdr.prev_rec_id = ""b then do;		/* must verify some things */
         temp_code = dm_error_$bj_bad_first_txn_record_type;
         if check_mode then
	  go to finish_initializing_data;		/* so we don't lose error code */
         else return;
      end;

      if bj_rec_hdr.tx_rec_no <= 1 then do;
         temp_code = dm_error_$bj_wrong_numb_txn_records;
         if ^check_mode then
	  return;
      end;

finish_initializing_data:
      finished_txns_list.prev_rec_id (txn_idx) = bj_rec_hdr.prev_rec_id;
      finished_txns_list.rollback_mark_found (txn_idx) = ""b;


      return;					/* done with initial data recording */
   end;
%page;
/* THIS TRANSACTION ALREADY IN LIST, so do some consistency checking */
/*     compared to what we expected to find.  If the checks pass, update */
/*     some of the saved data for future possible checks.  Note this code */
/*     only called if we are in the get_previous calling loop. */

   if bj_rec_hdr.process_id ^= finished_txns_list.owners_process_id (txn_idx)
   then do;
      temp_code = dm_error_$bj_rec_process_id_mismatch;
      if check_mode then
         go to update_data;
      else return;
   end;

   if finished_txns_list.rollback_mark_found (txn_idx) then /* no more checks are meaningfull */
      if check_mode then
         go to update_data;
      else return;

   if bj_rec_id ^= finished_txns_list.prev_rec_id (txn_idx) then do;
      temp_code = dm_error_$bj_wrong_prev_rec_id;
      if check_mode then
         go to update_data;
      else return;
   end;

   if bj_rec_hdr.prev_rec_id = ""b then do;

      if bj_rec_hdr.type ^= BJ_RECORD_TYPE.ROLLED_BACK
	 & bj_rec_hdr.type ^= BJ_RECORD_TYPE.FM_POSTCOMMIT_HANDLER
	 & bj_rec_hdr.type ^= BJ_RECORD_TYPE.FM_ROLLBACK_HANDLER
	 & bj_rec_hdr.type ^= BJ_RECORD_TYPE.BEFORE_IMAGE then do;

         temp_code = dm_error_$bj_bad_first_txn_record_type;
         if check_mode then
	  go to update_data;
         else return;
      end;
%page;
/* must be last record to read */
      if finished_txns_list.n_effective_records_read (txn_idx)
	 ^= finished_txns_list.n_effective_records_written (txn_idx) - 1
      then do;

         temp_code = dm_error_$bj_wrong_numb_txn_records;
         if check_mode then
	  go to update_data;
         else return;
      end;
   end;

/* checks out, OK to update registered data */

update_data:
   finished_txns_list.n_effective_records_read (txn_idx) =
        finished_txns_list.n_effective_records_read (txn_idx) + 1;
   if bj_rec_hdr.type = BJ_RECORD_TYPE.ROLLED_BACK then
      finished_txns_list.rollback_mark_found (txn_idx) = "1"b;
   finished_txns_list.prev_rec_id (txn_idx) = bj_rec_hdr.prev_rec_id;


   return;					/* free again */

   end register_finished_txn;
%page;
register_unfinished_txn:
   proc (temp_code);

/* This procedure is responsible for maintaining the internal list of */
/*     unfinished txns.  There is actually a second important function for */
/*     this proc.:  to update the caller's list of information needed to */
/*     rollback the txns.  The internal list is kept for consistency checks */

dcl  temp_code			fixed bin (35) parameter;

   if txn_idx = -1 then				/* must get it */
      bit_bucket = is_unfinished_txn ();		/* and this does it */

   if txn_idx = 0 then do;				/* a new one comes into the fold */

      if n_unfinished_txns <= 0 & ^check_mode then do;	/* don't do this test in check_mode */
         temp_code = dm_error_$bj_too_many_unfinished_txns;
         return;
      end;

      n_unfinished_txns = n_unfinished_txns - 1;		/* one less to look for */
      n_registered_unfinished_txns, txn_idx,
	 old_tm_tdt_p -> tm_tdt.entry_count,
	 old_bj_txt_p -> bj_txt.max_n_entries,
	 old_bj_txt_p -> bj_txt.n_entries_used =
	 n_registered_unfinished_txns + 1;		/* the next slot */

/* fill in new slot with data available first, the internal list */

      unfinished_txns_list.n_effective_records_read (txn_idx) = 1;
      unfinished_txns_list.prev_rec_id (txn_idx) = bj_rec_hdr.prev_rec_id;
      if bj_rec_hdr.prev_rec_id = ""b then do;

         if bj_rec_hdr.type ^= BJ_RECORD_TYPE.ROLLED_BACK
	    & bj_rec_hdr.type ^= BJ_RECORD_TYPE.BEFORE_IMAGE
	    & bj_rec_hdr.type ^= BJ_RECORD_TYPE.FM_ROLLBACK_HANDLER
	    & bj_rec_hdr.type ^= BJ_RECORD_TYPE.FM_POSTCOMMIT_HANDLER
         then do;

	  temp_code = dm_error_$bj_bad_first_txn_record_type;
	  if check_mode then
	     go to finish_initializing_data;
	  else return;
         end;

         if bj_rec_hdr.tx_rec_no < 1 then do;

	  temp_code = dm_error_$bj_wrong_numb_txn_records;
	  if check_mode then
	     go to finish_initializing_data;
	  else return;
         end;
      end;
%page;
finish_initializing_data:
      if bj_rec_hdr.type = BJ_RECORD_TYPE.ROLLED_BACK then
         unfinished_txns_list.rollback_mark_found (txn_idx) = "1"b;
      else unfinished_txns_list.rollback_mark_found (txn_idx) = ""b;

/* Initialize the tdt and txt entries and fill in common data after zeroing */
/* the entries.  tm_recover_after_crash and bjm_rebuild_after_crash are */
/* responsible for filling any values left zeroed that must be set for */
/* tm_adjust and cannot be set in this procedure. */

/* The following TDT entry elements are set to zero and left that way: */
/*	all mbzN's, event_channel, abandoned_sw, date_time_created, mode, */
/*	error_code, daemon_adjust_count, return_idx, and all flags and */
/*	post_commit_flags. */
/* The following TXT entry elements are set to zero and left that way: */
/*	bj_uid, all operator_info, curr_checkpoint_rec_id, */
/*	n_bytes_written, last_fm_postcommit_handler_rec_id, all */
/*	append_state, pad_entry_to_32_words */

      unspec (old_tm_tdt_p -> tm_tdt.entry (txn_idx)),
	 unspec (old_bj_txt_p -> bj_txt.entry (txn_idx)) = ""b;
      old_tm_tdt_p -> tm_tdt.entry (txn_idx).txn_id,
	 old_bj_txt_p -> bj_txt.entry (txn_idx).tid = bj_rec_hdr.tid;
      old_tm_tdt_p -> tm_tdt.entry (txn_idx).process_id,
	 old_bj_txt_p -> bj_txt.entry (txn_idx).owner_info.process_id =
	 bj_rec_hdr.process_id;

      if bj_rec_hdr.type = BJ_RECORD_TYPE.BEGIN_COMMIT then do;
         old_tm_tdt_p -> tm_tdt.entry (txn_idx).state =
	    TM_COMMIT_WRITING_MARK_STATE;
         old_bj_txt_p -> bj_txt.entry (txn_idx).last_completed_operation =
	    BJ_RECORD_TYPE.BEGIN_COMMIT;
      end;
      else old_tm_tdt_p -> tm_tdt.entry (txn_idx).state =
	      TM_ABORT_FLUSHING_TXN_STATE;
      old_bj_txt_p -> bj_txt.entry (txn_idx).bj_uid = bj_uid;
      old_bj_txt_p -> bj_txt.entry (txn_idx).last_bj_rec_id = bj_rec_id;
      old_bj_txt_p -> bj_txt.entry (txn_idx).n_rec_written =/* === n_effective_records_written in finished */
	 bj_rec_hdr.tx_rec_no;
      old_bj_txt_p -> bj_txt.entry (txn_idx).last_completed_operation =
	 bj_rec_hdr.type;
      old_bj_txt_p -> bj_txt.entry (txn_idx).ok_to_write = "1"b;
						/* so we can write mark */

/* NEED TEST ON POST COMMIT HANDLER HERE WHEN IMPLEMENTED */
      if bj_rec_hdr.prev_rec_id = ""b then
         old_bj_txt_p -> bj_txt.entry (txn_idx).first_bj_rec_id = bj_rec_id;

/* fill in things we don't currently get */
      old_tm_tdt_p -> tm_tdt.owner_name = "<PRE-CRASH>";

      return;					/* done initilizing this txn in our lists */
   end;

/* register_unfinished_txn CONTINUED ON NEXT PAGE */
%page;
/* CONTINUATION OF register_unfinished_txn PROC */

KNOWN_UNFINISHED_TXN:				/* so do some consistency checking */
   if bj_rec_hdr.process_id
        ^= old_tm_tdt_p -> tm_tdt.entry (txn_idx).process_id then do;

      temp_code = dm_error_$bj_rec_process_id_mismatch;
      if ^check_mode then
         return;
   end;

   if unfinished_txns_list.rollback_mark_found (txn_idx) & ^check_mode then
						/* we have the active part of the chain */
      return;					/* no more checks are meaningful */

/* special check if we are in get_previous call loop */

   if get_previous_loop then
      if n_unfinished_txns >= 0 then			/* must check prev_rec_id against curr. one */
         if bj_rec_id ^= unfinished_txns_list.prev_rec_id (txn_idx) then do;

	  temp_code = dm_error_$bj_wrong_prev_rec_id;
	  if check_mode then
	     go to update_data;
	  else return;
         end;

/* register_unfinished_txn CONTINUED ON NEXT PAGE */
%page;
/* CONTINUATION OF register_unfinished_txn PROC */

   if bj_rec_hdr.prev_rec_id = ""b then do;		/* better be 1st image, handler, or rollback */

      if bj_rec_hdr.type ^= BJ_RECORD_TYPE.ROLLED_BACK
	 & bj_rec_hdr.type ^= BJ_RECORD_TYPE.BEFORE_IMAGE
	 & bj_rec_hdr.type ^= BJ_RECORD_TYPE.FM_ROLLBACK_HANDLER
	 & bj_rec_hdr.type ^= BJ_RECORD_TYPE.FM_POSTCOMMIT_HANDLER then do;

         temp_code = dm_error_$bj_bad_first_txn_record_type;
         if check_mode then
	  go to update_data;
         else return;
      end;

      if unfinished_txns_list.n_effective_records_read (txn_idx) ^=
						/* must be last record to read */
	 old_bj_txt_p -> bj_txt.entry (txn_idx).n_rec_written - 1 then do;

         temp_code = dm_error_$bj_wrong_numb_txn_records;
         if check_mode then
	  go to update_data;
         else return;
      end;
   end;

/* checks out, OK to register new data */

update_data:
   unfinished_txns_list.n_effective_records_read (txn_idx) =
        unfinished_txns_list.n_effective_records_read (txn_idx) + 1;

   if bj_rec_hdr.type = BJ_RECORD_TYPE.ROLLED_BACK then
      unfinished_txns_list.rollback_mark_found (txn_idx) = "1"b;

   if bj_rec_hdr.prev_rec_id = ""b then
      if get_previous_loop then
         old_bj_txt_p -> bj_txt.entry (txn_idx).first_bj_rec_id = bj_rec_id;
      else old_bj_txt_p -> bj_txt.entry (txn_idx).first_bj_rec_id =
	      unfinished_txns_list.prev_rec_id (txn_idx);

   unfinished_txns_list.prev_rec_id (txn_idx) = bj_rec_hdr.prev_rec_id;

/* MUST ADD TEST/UPDATE OF USER POSTCOMMIT HANDLER RECORD WHEN IMPLEMENTED */

   return;					/* free at last */

   end register_unfinished_txn;
%page;
clean_up:
   proc ();

   call release_temp_segment_ ("bjm_find_txns_after_crash",
        finished_txns_list_p, clean_code);

   if clean_code ^= 0 then
      call dm_misc_util_$log (LOG_SV, clean_code, "bjm_find_txns_after_crash",
	 "Unable to release temp. storage for finished txn. list.");

   if code = 0 then
      code = clean_code;


   call release_temp_segment_ ("bjm_find_txns_after_crash",
        unfinished_txns_list_p, clean_code);

   if clean_code ^= 0 then
      call dm_misc_util_$log (LOG_SV, clean_code, "bjm_find_txns_after_crash",
	 "Unable to release temp. storage for unfinished txn. list.");

   if code = 0 then
      code = clean_code;


   call bj_cleanup_tables$handler (clean_code);

   if clean_code ^= 0 then
      call dm_misc_util_$log (LOG_SV, clean_code, "bjm_find_txns_after_crash",
	 "Unable to cleanup BJ tables.");

   if code = 0 then
      code = clean_code;


   bjm_data_$bj_operation = "";			/* ALWAYS release our hold */
   bjm_data_$bj_exit_err = bjm_data_$bj_default_error_label;

   return;

   end clean_up;
%page;
%include dm_bj_records;
%page;
%include dm_bj_txt;
%page;
%include dm_tm_tdt;
%page;
%include dm_log_sv_codes;
%page;
%include dm_tm_states;
%page;
%include dm_bj_global_error_info;


   end bjm_find_txns_after_crash;
