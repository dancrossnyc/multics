/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        *********************************************************** */


/*****************************************************************************/
/*							       */
/*   DESCRIPTION:						       */
/*							       */
/*        This IO module is analogous to g115_.  It handles remote batch to  */
/*   a Level 6M Satellite over an X.25 connection in the same way that g115_ */
/*   does remote batch over an RCI connection.  It uses tty_ to do its IO.   */
/*   The four possible devices which are supported, reader, punch, printer,  */
/*   and teleprinter, all use the same communications channel, therefore,    */
/*   the channel name can not contain stars.			       */
/*							       */
/*****************************************************************************/


/****^  HISTORY COMMENTS:
  1) change(82-06-01,RKissel), approve(), audit(), install():
     Written.
  2) change(87-03-17,LJAdams), approve(87-04-03,MCR7646),
     audit(87-05-05,Gilcrease), install(87-05-14,MR12.1-1030):
     Changed ttd_version to ttd_version_3.
                                                   END HISTORY COMMENTS */


/* format: style3,linecom,ifthenstmt,indthenelse,^indnoniterdo,indnoniterend,initcol3,dclind5,idind32 */

rbf_:
     proc ();

ERROR_EXIT:
	return;

/* Parameter */

dcl  a_buffer_len		       fixed bin (21) parameter;
dcl  a_bufferp		       ptr parameter;
dcl  a_code		       fixed bin (35) parameter;
dcl  a_comerr_sw		       bit (1) parameter;
dcl  a_infop		       ptr parameter;
dcl  a_iocbp		       ptr parameter;
dcl  a_new_modes		       char (*) parameter;
dcl  a_old_modes		       char (*) parameter;
dcl  a_open_mode		       fixed bin parameter;
dcl  a_option		       (*) char (*) var parameter;
dcl  a_order		       char (*) parameter;
dcl  a_record_len		       fixed bin (21) parameter;
dcl  a_recordp		       ptr parameter;

/* Automatic */

dcl  1 auto_area_info	       aligned like area_info;
dcl  1 auto_ttd		       aligned like terminal_type_data;

dcl  based_area		       area (sys_info$max_seg_size) based (areap);

dcl  bcd_equiv		       (0:63) char (1) unal defined (bcd_equiv_string);
dcl  code			       fixed bin (35);
dcl  comerr_sw		       bit (1);
dcl  dummy_arg		       char (32);
dcl  i			       fixed bin;
dcl  input_trp		       ptr;
dcl  iocbp		       ptr;
dcl  mask			       bit (36) aligned;
dcl  next_attach_description	       char (256) varying unaligned;
dcl  next_attach_options	       char (256) varying unaligned;
dcl  next_channel		       char (32) varying unaligned;
dcl  next_io_module		       char (32) varying unaligned;
dcl  next_io_switch_name	       char (32) varying unaligned;
dcl  open_mode		       fixed bin;
dcl  output_chars_to_write	       fixed bin (21);
dcl  output_trp		       ptr;
dcl  my_attach_description	       char (256) var;
dcl  slew_by_count_char	       (0:15) char (1) unaligned defined (legal_slew_chars) pos (2);
dcl  temp_ptr		       ptr;

/* Structure to define per-attachment data for each rbf_ switch attachment. */

dcl  radp			       ptr;

dcl  1 rbf_attach_data	       based (radp),
       2 attach_description	       char (256) var,
       2 open_description	       char (256) var,
       2 modes		       char (256) var,
       2 translations,				/* translation tables */
         3 input		       char (512),
         3 output		       char (512),
       2 terminal_type	       char (32),
       2 device		       char (32),		/* name of generic type of remote device */
       2 device_type	       fixed bin,		/* generic device in fixed bin form */
       2 comm_data_ptr	       ptr;		/* common data for this attachment. */

/* Structure for holding communication line specific data for all attachments to this line. */

dcl  cdbp			       ptr;		/* pointer to the comm data block. */

dcl  1 comm_data_block	       aligned based (cdbp),
       2 forward_ptr	       ptr,		/* Forward data block chain. */
       2 backward_ptr	       ptr,		/* Backward data block chain. */
       2 comm_channel	       char (32) unaligned,	/* Name of the channel for this RBF station. */
       2 comm_io_module	       char (32) unaligned,	/* Name of the IO module to use. */
       2 comm_iocbp		       ptr,		/* iocb ptr for this RBF station. */
       2 comm_event_channel	       fixed bin (71),	/* event channel used by the IO module. */
       2 timer_event_channel	       fixed bin (71),	/* event channel for use by runout control. */
       2 temp_seg_ptrs	       (2) ptr,		/* 1 is input buffer, 2 is output buffer */
       2 temp_seg_lens	       (2) fixed bin (21),
       2 number_of_attachments       fixed bin,
       2 input_chars_read	       fixed bin (21),
       2 input_buffer_position       fixed bin (21),
       2 flags		       aligned,
         3 comm_attached	       bit (1) unaligned,
         3 comm_open	       bit (1) unaligned,
         3 we_just_wrote	       bit (1) unaligned,
         3 pad		       bit (33) unaligned;

dcl  input_buffer		       char (input_buffer_len) based (input_buffer_ptr);
dcl  input_buffer_ptr	       ptr defined (comm_data_block.temp_seg_ptrs (1));
dcl  input_buffer_len	       fixed bin (21) defined (comm_data_block.temp_seg_lens (1));

dcl  output_buffer		       char (output_buffer_len) based (output_buffer_ptr);
dcl  output_buffer_ptr	       ptr defined (comm_data_block.temp_seg_ptrs (2));
dcl  output_buffer_len	       fixed bin (21) defined (comm_data_block.temp_seg_lens (2));

/* Builtin Functions and Conditions */

dcl  addr			       builtin;
dcl  bin			       builtin;
dcl  codeptr		       builtin;
dcl  collate9		       builtin;
dcl  copy			       builtin;
dcl  currentsize		       builtin;
dcl  dimension		       builtin;
dcl  divide		       builtin;
dcl  hbound		       builtin;
dcl  index		       builtin;
dcl  lbound		       builtin;
dcl  length		       builtin;
dcl  null			       builtin;
dcl  rtrim		       builtin;
dcl  substr		       builtin;
dcl  translate		       builtin;
dcl  unspec		       builtin;
dcl  verify		       builtin;

dcl  any_other		       condition;
dcl  cleanup		       condition;

/* Internal Static */

dcl  areap		       ptr int static init (null);
dcl  debug_flag		       bit (1) int static init ("0"b);
dcl  first_cdbp		       ptr internal static init (null ());
dcl  last_cdbp		       ptr internal static init (null ());

/* Internal Constants */

dcl  bcd_equiv_string	       char (64) unal int static options (constant)
			       init ("0123456789[#@:>? ABCDEFGHI&.](<\^JKLMNOPQR-$*);'+/STUVWXYZ_,%=""!");
dcl  CR			       char (1) internal static options (constant) init ("");
dcl  default_modes		       char (14) init ("8bit,rawi,rawo") int static options (constant);
dcl  device_names		       (4) char (32) int static options (constant)
			       init ("teleprinter", "reader", "printer", "punch");
dcl  legal_slew_chars	       char (19) int static options (constant) init (" 0123456789[#@:>?AB");
						/* printer slew codes, in order:
						   Top of form - space
						   slew 0 to 15 lines - 0...?
						   VFU_1 - A, VFU_2 - B */
dcl  lowercase		       char (26) int static options (constant) init ("abcdefghijklmnopqrstuvwxyz");
dcl  MY_NAME		       char (4) int static options (constant) init ("rbf_");
dcl  REL_SECONDS		       bit (2) int static options (constant) init ("11"b);
dcl  space		       char (1) int static options (constant) init (" ");
dcl  uppercase		       char (26) int static options (constant) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZ");

/* The following are RBF specific constants. */

dcl  1 RBF		       aligned internal static options (constant),
						/* This group defines input/output media codes associated with records within the text of a message block */
       2 media_codes	       unal,
         3 bcd_input_mc	       char (1) init ("H"),	/* Input media code for BCD data - 110 octal */
         3 bin_input_mc	       char (1) init ("P"),	/* Input media code for Binary data - 120 octal */
         3 printer_mc	       char (1) init ("L"),	/* printer output media code - 114 octal */
         3 punch_bcd_mc	       char (1) init ("O"),	/* punch output media code (BCD data)  - 117 octal */
         3 punch_bin_mc	       char (1) init ("W"),	/* punch output media code (Binary data)  - 127 octal */
         3 teleprinter_mc	       char (1) init ("N"),	/* teleprinter output media code - 116 octal */
						/* This group defines the message format codes which apply to all records in a single message block */
       2 format_codes	       unal,
         3 info_ns_nc	       bit (9) init ("110"b3),/* information message, no split, no compression */
         3 info_ns_c	       bit (9) init ("111"b3),/* information message, no split, compression */
         3 info_s_nc	       bit (9) init ("112"b3),/* information message, split, no compression */
         3 info_s_c		       bit (9) init ("113"b3),/* information message, split, compression */
         3 special_nc	       bit (9) init ("104"b3),/* Special control record, no compression */
         3 special_c	       bit (9) init ("105"b3),/* Special control record, compression */
						/* This group defines reserved characters which appear in the message block */
       2 char_codes		       unal,
         3 stx_char		       bit (9) init ("002"b3),/* start-of-text (STX) char */
         3 etx_char		       bit (9) init ("003"b3),/* end-of-text (ETX) char */
         3 soh_char		       bit (9) init ("001"b3),/* start-of-header (SOH) char */
         3 addr_code_char	       bit (9) init ("100"b3),/* address code character */
         3 id_code_char	       bit (9) init ("100"b3),/* identification code character */
         3 RS		       char (1) init (""),	/* record separator - 036 octal */
         3 CC		       char (1) init (""),	/* compression character code - 037 octal */
						/* The maximum size of a single rci message from SOH to ETX */
       2 max_msg_len	       fixed bin init (324);	/* max data in a message */

/* External Entries */

dcl  com_err_		       entry () options (variable);
dcl  continue_to_signal_	       entry (fixed bin (35));
dcl  convert_ipc_code_	       entry (fixed bin (35));
dcl  get_system_free_area_	       entry () returns (ptr);
dcl  get_temp_segments_	       entry (char (*), (*) ptr, fixed bin (35));
dcl  hcs_$set_ips_mask	       entry (bit (36) aligned, bit (36) aligned);
dcl  hcs_$reset_ips_mask	       entry (bit (36) aligned, bit (36) aligned);
dcl  ipc_$block		       entry (ptr, ptr, fixed bin (35));
dcl  ipc_$create_ev_chn	       entry (fixed bin (71), fixed bin (35));
dcl  ipc_$delete_ev_chn	       entry (fixed bin (71), fixed bin (35));
dcl  ipc_$drain_chn		       entry (fixed bin (71), fixed bin (35));
dcl  l6_tran_util_$get_chars	       entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
dcl  l6_tran_util_$put_chars	       entry (ptr, ptr, fixed bin (21), fixed bin (35));
dcl  mode_string_$parse	       entry (char (*), ptr, ptr, fixed bin (35));
dcl  release_temp_segments_	       entry (char (*), (*) ptr, fixed bin (35));
dcl  timer_manager_$alarm_wakeup     entry (fixed bin (71), bit (2), fixed bin (71));
dcl  timer_manager_$reset_alarm_wakeup
			       entry (fixed bin (71));
dcl  ttt_info_$terminal_data	       entry (char (*), fixed bin, fixed bin, ptr, fixed bin (35));
dcl  unique_chars_		       entry (bit (*)) returns (char (15));

/* External Constants */

dcl  error_table_$bad_mode	       fixed bin (35) ext static;
dcl  error_table_$bad_mode_value     fixed bin (35) ext static;
dcl  error_table_$badopt	       fixed bin (35) ext static;
dcl  error_table_$eof_record	       fixed bin (35) ext static;
dcl  error_table_$improper_data_format
			       fixed bin (35) ext static;
dcl  error_table_$invalid_read       fixed bin (35) ext static;
dcl  error_table_$long_record	       fixed bin (35) ext static;
dcl  error_table_$noarg	       fixed bin (35) ext static;
dcl  error_table_$not_attached       fixed bin (35) ext static;
dcl  error_table_$not_closed	       fixed bin (35) ext static;
dcl  error_table_$not_detached       fixed bin (35) ext static;
dcl  error_table_$not_open	       fixed bin (35) ext static;
dcl  error_table_$null_info_ptr      fixed bin (35) ext static;
dcl  error_table_$short_record       fixed bin (35) ext static;
dcl  error_table_$smallarg	       fixed bin (35) ext static;
dcl  error_table_$unimplemented_version
			       fixed bin (35) ext static;
dcl  error_table_$wrong_no_of_args   fixed bin (35) ext static;

dcl  sys_info$max_seg_size	       fixed bin (35) ext static;

rbf_attach:
     entry (a_iocbp, a_option, a_comerr_sw, a_code);

	comerr_sw = debug_flag | a_comerr_sw;
	iocbp = a_iocbp;

/* See if we are already attached. */

	if iocbp -> iocb.attach_descrip_ptr ^= null
	     then do;
		a_code = error_table_$not_detached;
		return;
		end;

/* Get an area to work in if we don't already have one. */

	if areap = null () then areap = get_system_free_area_ ();

/* Make a quick consistency check, must have: -tty arg -comm arg -device arg. */

	if hbound (a_option, 1) < 6
	     then call Abort_Attach (error_table_$wrong_no_of_args, MY_NAME, "Invalid attach description", "");

/* Initialize for the cleanup handler. */

	next_io_module = "";
	next_channel = "";
	next_attach_options = "";
	my_attach_description = "";

	cdbp = null ();
	radp = null ();

	on cleanup call Attach_Cleanup ();

/* Allocate a structure to hold our attach data, and initialize it. */

	allocate rbf_attach_data in (based_area) set (radp);

	rbf_attach_data.attach_description = "";
	rbf_attach_data.open_description = "";
	rbf_attach_data.modes = default_modes;
	rbf_attach_data.translations = "";
	rbf_attach_data.terminal_type = "";
	rbf_attach_data.device = "";
	rbf_attach_data.device_type = 0;
	rbf_attach_data.comm_data_ptr = null ();

/* Process the attachment arguments. */

	my_attach_description = MY_NAME;

	do i = 1 to hbound (a_option, 1);

	     my_attach_description = my_attach_description || space || a_option (i);

	     if a_option (i) = "-device" then rbf_attach_data.device = Get_Option_Arg (i);

	     else if a_option (i) = "-tty" then next_channel = Get_Option_Arg (i);

	     else if a_option (i) = "-comm" then next_io_module = Get_Option_Arg (i);

	     else if a_option (i) = "-ascii" then ;

	     else if a_option (i) = "-ebcdic" then ;

	     else if a_option (i) = "-physical_line_length" | a_option (i) = "-pll" then dummy_arg = Get_Option_Arg (i);

	     else if a_option (i) = "-delay" then dummy_arg = Get_Option_Arg (i);

	     else if a_option (i) = "-terminal_type" | a_option (i) = "-ttp"
		then rbf_attach_data.terminal_type = Get_Option_Arg (i);

	     else next_attach_options = next_attach_options || space || a_option (i);
	end;					/* do i = ... */

/* Make some checks on the arguments. */

	if next_io_module ^= "tty_" then call Abort_Attach (0, MY_NAME, "Invalid or missing -comm option", "");

	if next_channel = "" then call Abort_Attach (0, MY_NAME, "No -tty option given", "");

	do i = lbound (device_names, 1) to hbound (device_names, 1) while (rbf_attach_data.device ^= device_names (i));
	end;

	if i > hbound (device_names, 1)
	     then call Abort_Attach (error_table_$badopt, MY_NAME, "Invalid device specified", "");
	     else rbf_attach_data.device_type = i;

/* Get translation information and then set input and output translation. */

	if rbf_attach_data.terminal_type ^= ""
	     then do;
		rbf_attach_data.terminal_type = translate (rbf_attach_data.terminal_type, uppercase, lowercase);

		auto_ttd.version = ttd_version_3;
		call ttt_info_$terminal_data (rbf_attach_data.terminal_type, -1, 0, addr (auto_ttd), code);
		if code ^= 0 then call Abort_Attach (code, MY_NAME, "Unknown terminal type specified", "");

		input_trp = auto_ttd.tables.input_tr_ptr;
		output_trp = auto_ttd.tables.output_tr_ptr;
		end;

	     else do;
		input_trp = null ();
		output_trp = null ();
		end;

	call Set_Translation (rbf_attach_data.translations.input, input_trp);
	call Set_Translation (rbf_attach_data.translations.output, output_trp);

/* Now see if we already know about the target channel. */

	do temp_ptr = first_cdbp repeat (temp_ptr -> comm_data_block.forward_ptr)
	     while (temp_ptr ^= null () & cdbp = null ());
	     if temp_ptr -> comm_data_block.comm_channel = next_channel then cdbp = temp_ptr;
	end;

/* See if we found a comm_data_block, if not create and initialize one. */

	if cdbp = null ()
	     then do;
		allocate comm_data_block in (based_area) set (cdbp);

		comm_data_block.forward_ptr = null ();
		comm_data_block.backward_ptr = last_cdbp;
		comm_data_block.comm_channel = next_channel;
		comm_data_block.comm_io_module = next_io_module;
		comm_data_block.comm_iocbp = null ();
		comm_data_block.comm_event_channel = 0;
		comm_data_block.timer_event_channel = 0;
		comm_data_block.temp_seg_ptrs (*) = null ();
						/* Input and output buffers. */
		comm_data_block.temp_seg_lens (*) = sys_info$max_seg_size;
		comm_data_block.number_of_attachments = 0;
		comm_data_block.input_chars_read = 0;
		comm_data_block.input_buffer_position = 1;
		comm_data_block.flags = "0"b;

		/*** Get temp segments for the input and output buffers. */

		call get_temp_segments_ (MY_NAME, comm_data_block.temp_seg_ptrs, code);
		if code ^= 0 then call Abort_Attach (code, MY_NAME, "Unable to get input and output buffers", "");

		/*** Get an event channel for use by the timer used by the runout control order. */

		call ipc_$create_ev_chn (comm_data_block.timer_event_channel, code);
		if code ^= 0
		     then do;
			call convert_ipc_code_ (code);
			call Abort_Attach (code, MY_NAME, "Unable to get a timer event channel during attachment.",
			     "");
			end;

		/*** Link it into the chain of comm_data_blocks. */

		if first_cdbp = null ()
		     then first_cdbp = cdbp;
		     else last_cdbp -> comm_data_block.forward_ptr = cdbp;

		last_cdbp = cdbp;
		end;

/* Finish setting up our attach description data. */

	rbf_attach_data.comm_data_ptr = cdbp;

/* If necessary, attach and open the communications IO module we will use. */

	if ^comm_data_block.flags.comm_attached
	     then do;				/* We need to attach. */
		next_io_switch_name = MY_NAME || "." || unique_chars_ (""b);
		next_attach_description = next_io_module || space || next_channel || space || next_attach_options;

		call iox_$attach_name ((next_io_switch_name), comm_data_block.comm_iocbp, (next_attach_description),
		     codeptr (rbf_attach), code);
		if code ^= 0 then call Abort_Attach (code, MY_NAME, "Unable to attach communications channel", "");

		comm_data_block.flags.comm_attached = "1"b;
		comm_data_block.flags.comm_open = "0"b;
		end;				/* We need to attach. */

	if ^comm_data_block.flags.comm_open
	     then do;				/* We need to open. */
		call iox_$open (comm_data_block.comm_iocbp, Stream_input_output, "0"b, code);
		if code ^= 0 then call Abort_Attach (code, MY_NAME, "Unable to open the communications switch.", "");

		/*** Set initial modes. */

		call iox_$modes (comm_data_block.comm_iocbp, default_modes, (""), code);
		if code ^= 0
		     then call Abort_Attach (code, MY_NAME,
			     "Unable to set initial modes on the communications switch.", "");

		/*** Get the event channel used by the comm module. */

		call iox_$control (comm_data_block.comm_iocbp, "get_event_channel",
		     addr (comm_data_block.comm_event_channel), code);
		if code ^= 0
		     then call Abort_Attach (code, MY_NAME,
			     "Unable to get the event channel for the communications switch.", "");

		comm_data_block.flags.comm_open = "1"b;
		end;				/* We need to open. */

/* Remember that we have attached a device to this channel. */

	comm_data_block.number_of_attachments = comm_data_block.number_of_attachments + 1;

/* Make changes to iocb. */

	mask = "0"b;
	on any_other call Any_Other_Handler ();

	call hcs_$set_ips_mask ("0"b, mask);

	iocbp -> iocb.attach_descrip_ptr = addr (rbf_attach_data.attach_description);
	iocbp -> iocb.attach_data_ptr = radp;
	iocbp -> iocb.open = rbf_open;
	iocbp -> iocb.detach_iocb = rbf_detach_iocb;

	call iox_$propagate (iocbp);

	call hcs_$reset_ips_mask (mask, mask);

	revert any_other;

	return;

rbf_detach_iocb:
     entry (a_iocbp, a_code);

	a_code = 0;
	iocbp = a_iocbp;

/* Make sure that switch is closed and attached. */

	if iocbp -> iocb.attach_descrip_ptr = null
	     then do;
		a_code = error_table_$not_attached;
		return;
		end;

	if iocbp -> iocb.open_descrip_ptr ^= null
	     then do;
		a_code = error_table_$not_closed;
		return;
		end;

	radp = iocbp -> iocb.attach_data_ptr;
	cdbp = rbf_attach_data.comm_data_ptr;

/* Remove this device from the communications data. */

	comm_data_block.number_of_attachments = comm_data_block.number_of_attachments - 1;

	call Attach_Cleanup ();			/* Get rid of everything we should. */

	mask = "0"b;
	on any_other call Any_Other_Handler;

	call hcs_$set_ips_mask ("0"b, mask);

	iocbp -> attach_descrip_ptr = null;

	call iox_$propagate (iocbp);

	call hcs_$reset_ips_mask (mask, mask);

	revert any_other;

	return;

rbf_open:
     entry (a_iocbp, a_open_mode, a_comerr_sw, a_code);

	a_code = 0;
	iocbp = a_iocbp -> iocb.actual_iocb_ptr;

/* Make sure that switch is attached and closed. */

	if iocbp -> iocb.attach_descrip_ptr = null
	     then do;
		a_code = error_table_$not_attached;
		return;
		end;

	if iocbp -> iocb.open_descrip_ptr ^= null
	     then do;
		a_code = error_table_$not_closed;
		return;
		end;

	radp = iocbp -> iocb.attach_data_ptr;

/* Check opening modes. */

	open_mode = a_open_mode;

	if ^((open_mode = Sequential_input) | (open_mode = Sequential_output) | (open_mode = Sequential_input_output))
	     then do;
		a_code = error_table_$bad_mode;
		return;
		end;

	rbf_attach_data.open_description = rtrim (iox_modes (open_mode));

	mask = "0"b;
	on any_other call Any_Other_Handler;

	call hcs_$set_ips_mask ("0"b, mask);

	if open_mode = Sequential_input | open_mode = Sequential_input_output
	     then iocbp -> iocb.read_record = rbf_read_record;

	if open_mode = Sequential_output | open_mode = Sequential_input_output
	     then iocbp -> iocb.write_record = rbf_write_record;

	iocbp -> iocb.control = rbf_control;
	iocbp -> iocb.modes = rbf_modes;
	iocbp -> iocb.close = rbf_close;
	iocbp -> iocb.detach_iocb = rbf_detach_iocb;
	iocbp -> iocb.open_descrip_ptr = addr (rbf_attach_data.open_description);

	call iox_$propagate (iocbp);

	call hcs_$reset_ips_mask (mask, mask);

	revert any_other;

	return;

rbf_close:
     entry (a_iocbp, a_code);

	a_code = 0;
	iocbp = a_iocbp -> iocb.actual_iocb_ptr;

/* Make sure that switch is attached and open. */

	if iocbp -> iocb.attach_descrip_ptr = null ()
	     then do;
		a_code = error_table_$not_attached;
		return;
		end;

	if iocbp -> iocb.open_descrip_ptr = null
	     then do;
		a_code = error_table_$not_open;
		return;
		end;

	mask = "0"b;
	on any_other call Any_Other_Handler;

	call hcs_$set_ips_mask ("0"b, mask);

	iocbp -> iocb.open_descrip_ptr = null;
	iocbp -> iocb.open = rbf_open;
	iocbp -> iocb.detach_iocb = rbf_detach_iocb;

	iocbp -> iocb.control = iox_$err_no_operation;
	iocbp -> iocb.modes = iox_$err_no_operation;
	iocbp -> iocb.read_record = iox_$err_no_operation;
	iocbp -> iocb.write_record = iox_$err_no_operation;

	call iox_$propagate (iocbp);

	call hcs_$reset_ips_mask (mask, mask);

	revert any_other;

	return;

rbf_read_record:
     entry (a_iocbp, a_bufferp, a_buffer_len, a_record_len, a_code);

dcl  compression_count	       fixed bin;
dcl  current_char		       char (1);
dcl  end_of_record		       bit (1);
dcl  error_code		       fixed bin (35);
dcl  read_record_state	       fixed bin;
dcl  user_buffer_len	       fixed bin (21);


	iocbp = a_iocbp -> iocb.actual_iocb_ptr;
	a_record_len = 0;
	a_code = 0;

	radp = iocbp -> iocb.attach_data_ptr;
	cdbp = rbf_attach_data.comm_data_ptr;

	if rbf_attach_data.device_type ^= TELEPRINTER_DEVICE & rbf_attach_data.device_type ^= READER_DEVICE
	     then do;				/* can't read from all devices */
		a_code = error_table_$invalid_read;
		return;
		end;

/* Validate that there is room in the buffer to hold some actual data in addition to a terminal_io_record header. */

	terminal_io_record_ptr = a_bufferp;

	user_buffer_len = a_buffer_len - divide (length (unspec (terminal_io_record.header)), 9, 21);

	if user_buffer_len <= 0
	     then do;
		a_code = error_table_$smallarg;
		return;
		end;

	terminal_io_record_data_chars_varying_max_len = user_buffer_len;

/* Initialize the return structure. */

	terminal_io_record.version = terminal_io_record_version_1;
	terminal_io_record.device_type = 0;
	terminal_io_record.slew_type = SLEW_BY_COUNT;
	terminal_io_record.slew_count = 1;
	terminal_io_record.flags = "0"b;
	terminal_io_record.element_size = 9;
	terminal_io_record.n_elements = 0;		/* Initially the null string. */

/* Check to see if we have to tell the L6 that he can send, this is also done in the read_status order. */

	if comm_data_block.flags.we_just_wrote
	     then do;				/* Tell him he can send. */
		call Check_Write_Status (code);
		if code ^= 0 then goto READ_ERROR;

		call Send_EOM (code);
		if code ^= 0 then goto READ_ERROR;

		call Check_Write_Status (code);
		if code ^= 0 then goto READ_ERROR;

		comm_data_block.flags.we_just_wrote = "0"b;
		end;				/* Tell him he can send. */


/* Read in the record, one character at a time since there may be compressed text. */

	read_record_state = 1;
	error_code = 0;
	end_of_record = "0"b;

	do while (^end_of_record);

	     if comm_data_block.input_buffer_position > comm_data_block.input_chars_read
		then do;				/* We need some more data. */
		     call l6_tran_util_$get_chars (comm_data_block.comm_iocbp, input_buffer_ptr, input_buffer_len,
			comm_data_block.input_chars_read, code);
		     if code ^= error_table_$short_record & code ^= 0 then goto READ_ERROR;

		     comm_data_block.input_buffer_position = 1;
		     end;				/* We need some more data. */

	     current_char = substr (input_buffer, comm_data_block.input_buffer_position, 1);

	     goto RECORD_PARSER (read_record_state);

RECORD_PARSER (1):					/* Handle the media code. */
	     if current_char = RBF.media_codes.bcd_input_mc then terminal_io_record.device_type = READER_DEVICE;

	     else if current_char = RBF.media_codes.bin_input_mc
		then do;
		     terminal_io_record.device_type = READER_DEVICE;
		     terminal_io_record.flags.binary = "1"b;
		     end;

	     else if current_char = RBF.media_codes.teleprinter_mc
		then terminal_io_record.device_type = TELEPRINTER_DEVICE;

	     else do;				/* Not an input record but read it anyway. */
		terminal_io_record.device_type = 0;
		error_code = error_table_$improper_data_format;
		end;

	     comm_data_block.input_buffer_position = comm_data_block.input_buffer_position + 1;
	     read_record_state = 2;

	     goto NEXT_STATE;

RECORD_PARSER (2):					/* Handle normal char, compression char, or EOR char. */
	     if current_char = RBF.char_codes.CC then read_record_state = 3;
						/* Decompress the previous char. */

	     else if current_char = RBF.char_codes.RS then end_of_record = "1"b;
						/* We are done. */

	     else do;				/* A normal character. */
		if length (terminal_io_record_data_chars_varying) < user_buffer_len
		     then terminal_io_record_data_chars_varying =
			     terminal_io_record_data_chars_varying || current_char;
		     else error_code = error_table_$long_record;
						/* Must throw it away. */

		read_record_state = 2;
		end;

	     comm_data_block.input_buffer_position = comm_data_block.input_buffer_position + 1;

	     goto NEXT_STATE;

RECORD_PARSER (3):					/* Handle the compression count character. */
	     compression_count = index (bcd_equiv_string, current_char);

	     if compression_count <= 1
		then do;				/* Min is 2, max is 63. */
		     if current_char < substr (bcd_equiv_string, 2, 1)
			then compression_count = 2;
			else compression_count = 63;
		     end;

	     if user_buffer_len - length (terminal_io_record_data_chars_varying) < compression_count
		then do;				/* Not enough room in the user buffer. */
		     error_code = error_table_$long_record;
		     compression_count = user_buffer_len - length (terminal_io_record_data_chars_varying);

		     if compression_count <= 0 then compression_count = 0;
		     end;

	     terminal_io_record_data_chars_varying =
		terminal_io_record_data_chars_varying
		||
		copy (
		substr (terminal_io_record_data_chars_varying, length (terminal_io_record_data_chars_varying), 1),
		compression_count);

	     comm_data_block.input_buffer_position = comm_data_block.input_buffer_position + 1;
	     read_record_state = 2;

	     goto NEXT_STATE;

NEXT_STATE:
	end;					/* Loop through the record. */

/* Finally, do the translation and we are done. */

	terminal_io_record_data_chars_varying =
	     translate (terminal_io_record_data_chars_varying, rbf_attach_data.translations.input, collate9 ());

/* Check for a $*$ card, and if it is one, then give back a zero length record. */

	if length (terminal_io_record_data_chars_varying) >= 3
	     then if substr (terminal_io_record_data_chars_varying, 1, 3) = "$*$"
		     then terminal_io_record.n_elements = 0;

/* Check for an end of file record from the card reader and return the right code. */

	if terminal_io_record_data_chars_varying = "++EOF" | terminal_io_record_data_chars_varying = "++eof"
	     then error_code = error_table_$eof_record;

	a_record_len = 4 * currentsize (terminal_io_record);
	a_code = error_code;

	return;

READ_ERROR:
	a_code = code;

	return;

rbf_write_record:
     entry (a_iocbp, a_recordp, a_record_len, a_code);

dcl  media_code		       char (1);
dcl  rep_count		       fixed bin;
dcl  slew_char		       char (1);
dcl  slew_count		       fixed bin (18);

	iocbp = a_iocbp -> iocb.actual_iocb_ptr;
	a_code = 0;

	radp = iocbp -> iocb.attach_data_ptr;
	cdbp = rbf_attach_data.comm_data_ptr;
	terminal_io_record_ptr = a_recordp;

/* Check arguments for inconsistencies. */

	if terminal_io_record.version ^= terminal_io_record_version_1
	     then do;
		a_code = error_table_$unimplemented_version;
		return;
		end;

	if terminal_io_record.preslew
	     then do;
		a_code = error_table_$improper_data_format;
		return;
		end;

/* Set media code and slew character. */

	slew_count = 0;

	if terminal_io_record.device_type = TELEPRINTER_DEVICE
	     then do;
		media_code = RBF.media_codes.teleprinter_mc;
		slew_char = CR;
		end;

	else if terminal_io_record.device_type = PRINTER_DEVICE
	     then do;
		media_code = RBF.media_codes.printer_mc;

		if terminal_io_record.slew_type = SLEW_BY_COUNT
		     then do;
			slew_count = terminal_io_record.slew_count;

			if slew_count < lbound (slew_by_count_char, 1)
			     then do;
				a_code = error_table_$improper_data_format;
				return;
				end;

			if slew_count > hbound (slew_by_count_char, 1)
			     then do;
				slew_char = slew_by_count_char (hbound (slew_by_count_char, 1));
						/* Do the most we can. */
				slew_count = slew_count - hbound (slew_by_count_char, 1);
						/* Figure what is left. */
				end;

			     else do;
				slew_char = slew_by_count_char (slew_count);
				slew_count = 0;	/* Nothing left. */
				end;
			end;

		else if terminal_io_record.slew_type = SLEW_TO_TOP_OF_PAGE then slew_char = space;

		else if terminal_io_record.slew_type = SLEW_TO_INSIDE_PAGE then slew_char = space;

		else if terminal_io_record.slew_type = SLEW_TO_OUTSIDE_PAGE then slew_char = space;

		else if terminal_io_record.slew_type = SLEW_TO_CHANNEL then slew_char = space;

		else slew_char = "1";		/* All undefined slew types default to this */
		end;

	else if terminal_io_record.device_type = PUNCH_DEVICE
	     then do;
		if terminal_io_record.flags.binary
		     then media_code = RBF.media_codes.punch_bin_mc;
		     else media_code = RBF.media_codes.punch_bcd_mc;
		end;

	else media_code = "";

/* If the data is binary, turn it into 6 bit chunks, otherwise, translate it. */

	if (terminal_io_record.binary & terminal_io_record.element_size ^= 1)
	     | (^terminal_io_record.binary & terminal_io_record.element_size ^= 9)
	     then do;
		a_code = error_table_$improper_data_format;
		return;
		end;

	if terminal_io_record.binary
	     then do;
		terminal_io_record.n_elements = divide (terminal_io_record.n_elements + 5, 6, 18);
		terminal_io_record.element_size = 6;

		substr (output_buffer, 1, 1) = media_code;

		do i = 1 to terminal_io_record.n_elements;
		     substr (output_buffer, i + 1, 1) = bcd_equiv (bin (terminal_io_record.data.bits (i), 6));
		end;
		end;

	     else do;
		substr (output_buffer, 1, 1) = media_code;
		substr (output_buffer, 2, terminal_io_record.n_elements) =
		     translate (terminal_io_record_data_chars, rbf_attach_data.translations.output, collate9 ());
		end;

	output_chars_to_write = terminal_io_record.n_elements + 1;
						/* Add the media_code length. */

/* Perform data compression (except on teleprinter output). */

	if rbf_attach_data.device_type ^= TELEPRINTER_DEVICE
	     then do;
		i = 2;

		do while (i <= output_chars_to_write);	/* Do this since we may modify the counters. */

		     rep_count =
			verify (substr (output_buffer, i, output_chars_to_write - i + 1),
			substr (output_buffer, i, 1)) - 1;

		     if rep_count < 0 then rep_count = output_chars_to_write - i + 1;
						/* everything matched. */

		     if rep_count > 64 then rep_count = 64;
						/* This is the limit. */

		     if rep_count <= 3
			then i = i + 1;		/* no compression needed. */

			else do;			/* compress this one. */
			     substr (output_buffer, i + 1, 1) = RBF.char_codes.CC;
			     substr (output_buffer, i + 2, 1) = bcd_equiv (rep_count - 1);

			     i = i + 3;
			     output_chars_to_write = output_chars_to_write - rep_count + 3;

			     substr (output_buffer, i, output_chars_to_write - i + 1) =
				substr (output_buffer, i + rep_count - 3, output_chars_to_write - i + 1);
						/* Shift the end of the data over the compressed chars. */
			     end;
		end;				/* Compression loop. */
		end;				/* Perform data compression. */

/* Now add slew control if necessary, and add the final record separator character. */

	if media_code = RBF.media_codes.printer_mc | media_code = RBF.media_codes.teleprinter_mc
	     then do;				/* Handle devices that slew. */
		substr (output_buffer, output_chars_to_write + 1, 2) = slew_char || RBF.char_codes.RS;
		output_chars_to_write = output_chars_to_write + 2;

		if slew_count > 0
		     then do;			/* Send null records to finish slewing. */
			do while (slew_count > hbound (slew_by_count_char, 1));
			     substr (output_buffer, output_chars_to_write + 1, 3) =
				media_code || slew_by_count_char (hbound (slew_by_count_char, 1))
				|| RBF.char_codes.RS;
			     output_chars_to_write = output_chars_to_write + 3;
			     slew_count = slew_count - hbound (slew_by_count_char, 1);
			end;

			if slew_count > 0
			     then do;		/* Get the last bit. */
				substr (output_buffer, output_chars_to_write + 1, 3) =
				     media_code || slew_by_count_char (slew_count) || RBF.char_codes.RS;
				output_chars_to_write = output_chars_to_write + 3;
				end;
			end;			/* Send null records to finish slewing. */
		end;				/* Handle devices that slew. */

	     else do;
		substr (output_buffer, output_chars_to_write + 1, 1) = RBF.char_codes.RS;
		output_chars_to_write = output_chars_to_write + 1;
		end;

/* Transmit record to comm_io_module io switch. */

	call l6_tran_util_$put_chars (comm_data_block.comm_iocbp, output_buffer_ptr, output_chars_to_write, a_code);

/* Set a flag so the control and read_record entries can send the $*$EOM record. */

	if rbf_attach_data.device_type = TELEPRINTER_DEVICE then comm_data_block.flags.we_just_wrote = "1"b;

	return;

rbf_control:
     entry (a_iocbp, a_order, a_infop, a_code);


	a_code = 0;

	iocbp = a_iocbp -> iocb.actual_iocb_ptr;

/* Make sure the switch is attached and open. */

	if iocbp -> iocb.attach_descrip_ptr = null
	     then do;
		a_code = error_table_$not_attached;
		return;
		end;

	if iocbp -> iocb.open_descrip_ptr = null
	     then do;
		a_code = error_table_$not_open;
		return;
		end;

	radp = iocbp -> iocb.attach_data_ptr;
	cdbp = rbf_attach_data.comm_data_ptr;

	if a_order = "end_write_mode"
	     then do;				/* Handle end_write_mode. */
		call Check_Write_Status (code);
		if code ^= 0 then goto CONTROL_ERROR;

		call Send_EOM (code);
		if code ^= 0 then goto CONTROL_ERROR;

		call Check_Write_Status (code);
		if code ^= 0 then goto CONTROL_ERROR;
		end;				/* Handle end_write_mode. */

	else if a_order = "runout"
	     then do;				/* Handle runout. */
		call Check_Write_Status (code);
		if code ^= 0 then goto CONTROL_ERROR;
		end;				/* Handle runout. */

	else if a_order = "read_status"
	     then do;				/* Handle read_status. */
		tty_read_status_info_ptr = a_infop;

		if tty_read_status_info_ptr = null ()
		     then do;
			a_code = error_table_$null_info_ptr;
			return;
			end;

		if comm_data_block.flags.we_just_wrote
		     then do;			/* Tell him he can send. */
			call Check_Write_Status (code);
			if code ^= 0 then goto CONTROL_ERROR;

			call Send_EOM (code);
			if code ^= 0 then goto CONTROL_ERROR;

			call Check_Write_Status (code);
			if code ^= 0 then goto CONTROL_ERROR;

			comm_data_block.flags.we_just_wrote = "0"b;
			end;			/* Tell him he can send. */

/*
   We will assume that if we have any input then it is at least one record,
   even if it is only a $*$ card.  The same is true if tty_ has some input
   that we have'nt read yet.  Therefore, if we have any input, then our caller
   will not go blocked if he calls read_record.  If we don't then tty_ will
   return the right results.  That is, if it has some input, then we won't go
   blocked when we try to read a complete record, and if it does not have
   input, then it will send a wakeup when it gets some.
*/

		if comm_data_block.input_buffer_position <= comm_data_block.input_chars_read
		     then tty_read_status_info.input_pending = "1"b;
		     else tty_read_status_info.input_pending = "0"b;

		/*** If we have input then just get the event channel else let tty_ do the work. */

		if tty_read_status_info.input_pending
		     then call iox_$control (comm_data_block.comm_iocbp, "get_event_channel",
			     addr (tty_read_status_info.event_channel), a_code);
		     else call iox_$control (comm_data_block.comm_iocbp, "read_status", a_infop, a_code);
		end;				/* Handle read_status. */

	else if a_order = "select_device" | a_order = "reset" | a_order = "binary_punch" then ;
						/* Ignore, done by magic in terminal_io_record. */

/* Pass all other control orders on to the communications switch. */

	else call iox_$control (comm_data_block.comm_iocbp, a_order, a_infop, a_code);

	return;

CONTROL_ERROR:
	a_code = code;

	return;

rbf_modes:
     entry (a_iocbp, a_new_modes, a_old_modes, a_code);

	a_code = 0;
	a_old_modes = "";

	iocbp = a_iocbp -> iocb.actual_iocb_ptr;

/* Make sure the switch is attached and open. */

	if iocbp -> iocb.attach_descrip_ptr = null
	     then do;
		a_code = error_table_$not_attached;
		return;
		end;

	if iocbp -> iocb.open_descrip_ptr = null
	     then do;
		a_code = error_table_$not_open;
		return;
		end;

	radp = iocbp -> iocb.attach_data_ptr;

	call mode_string_$parse (a_new_modes, areap, mode_string_info_ptr, a_code);
	if a_code ^= 0 then return;

	if mode_string_info.version ^= mode_string_info_version_2
	     then do;
		a_code = error_table_$unimplemented_version;
		return;
		end;

	do i = lbound (mode_string_info.modes, 1) to hbound (mode_string_info.modes, 1);
	     if mode_string_info.modes (i).mode_name = "rawi" | mode_string_info.modes (i).mode_name = "rawo"
		| mode_string_info.modes (i).mode_name = "8bit"
		then do;
		     if ^(mode_string_info.modes (i).boolean_valuep & mode_string_info.modes (i).boolean_value)
			then do;
			     a_code = error_table_$bad_mode_value;
			     return;
			     end;
		     end;
		else do;
		     a_code = error_table_$bad_mode;
		     return;
		     end;
	end;

	a_old_modes = rbf_attach_data.modes;
	rbf_attach_data.modes = a_new_modes;

	return;

/* Internal routines */

Get_Option_Arg:
     proc (idx) returns (char (*) var);

dcl  idx			       fixed bin parameter;

	idx = idx + 1;

	if idx > hbound (a_option, 1)
	     then call Abort_Attach (error_table_$noarg, MY_NAME, "No argument after ^a", (a_option (idx - 1)));

	my_attach_description = my_attach_description || space || a_option (idx);

	return (a_option (idx));

     end Get_Option_Arg;

Any_Other_Handler:
     proc ();

	if mask then call hcs_$reset_ips_mask (mask, mask);

	mask = "0"b;

	call continue_to_signal_ ((0));

     end Any_Other_Handler;

Attach_Cleanup:
     proc ();

dcl  code			       fixed bin (35);


	if radp ^= null then free rbf_attach_data in (based_area);

	if cdbp ^= null ()
	     then do;
		if comm_data_block.number_of_attachments = 0
		     then do;
			if input_buffer_ptr ^= null () | output_buffer_ptr ^= null ()
			     then call release_temp_segments_ (MY_NAME, comm_data_block.temp_seg_ptrs, code);

			if comm_data_block.comm_iocbp ^= null ()
			     then do;
				call iox_$close (comm_data_block.comm_iocbp, code);
				call iox_$detach_iocb (comm_data_block.comm_iocbp, code);
				call iox_$destroy_iocb (comm_data_block.comm_iocbp, code);
				end;

			if comm_data_block.timer_event_channel ^= 0
			     then call ipc_$delete_ev_chn (comm_data_block.timer_event_channel, code);

			call Free_Comm_Data_Block ();
			end;
		end;

	return;

     end Attach_Cleanup;

Abort_Attach:
     proc (code, prog_name, control_str, arg_value);

dcl  code			       fixed bin (35) parameter;
dcl  prog_name		       char (*) parameter;
dcl  control_str		       char (*) parameter;
dcl  arg_value		       char (*) parameter;

	call Attach_Cleanup;

	call Abort (code, prog_name, control_str, arg_value);

     end Abort_Attach;

Abort:
     proc (code, prog_name, control_str, arg_value);

dcl  code			       fixed bin (35) parameter;
dcl  prog_name		       char (*) parameter;
dcl  control_str		       char (*) parameter;
dcl  arg_value		       char (*) parameter;


	if comerr_sw then call com_err_ (code, prog_name, control_str, arg_value);
	a_code = code;

	go to ERROR_EXIT;

     end Abort;

Check_Write_Status:
     proc (code);

/*
   This routine checks the write_status and loops until the write is complete.
   The timer is needed since write_status does not guarantee to send a
   wakeup if output_pending is set.
*/

dcl  code			       fixed bin (35) parameter;

dcl  1 event_info		       aligned,
       2 channel_id		       fixed bin (71),
       2 message		       fixed bin (71),
       2 sender		       bit (36),
       2 origin,
         3 dev_signal	       bit (18) unaligned,
         3 ring		       bit (18) unaligned,
       2 channel_index	       fixed bin;

dcl  1 wait_list		       aligned,
       2 nchan		       fixed bin,
       2 pad		       fixed bin,
       2 channel_id		       (2) fixed bin (71);

dcl  1 write_status_info	       aligned,
       2 ev_chan		       fixed bin (71),
       2 output_pending	       bit (1);

/* Set up a wait list for blocking in write_status. */

	wait_list.nchan = 2;
	wait_list.pad = 0;
	wait_list.channel_id (1) = comm_data_block.comm_event_channel;
	wait_list.channel_id (2) = comm_data_block.timer_event_channel;

	call iox_$control (comm_data_block.comm_iocbp, "write_status", addr (write_status_info), code);
	if code ^= 0 then return;

	do while (write_status_info.output_pending & write_status_info.ev_chan ^= 0);

	     call timer_manager_$alarm_wakeup (1, REL_SECONDS, comm_data_block.timer_event_channel);

	     call ipc_$block (addr (wait_list), addr (event_info), code);
	     if code ^= 0
		then do;
		     call convert_ipc_code_ (code);
		     return;
		     end;

	     call timer_manager_$reset_alarm_wakeup (comm_data_block.timer_event_channel);

	     call ipc_$drain_chn (comm_data_block.timer_event_channel, code);
	     if code ^= 0
		then do;
		     call convert_ipc_code_ (code);
		     return;
		     end;

	     call iox_$control (comm_data_block.comm_iocbp, "write_status", addr (write_status_info), code);
	     if code ^= 0 then return;
	end;					/* Write status loop. */

	return;

     end Check_Write_Status;

Free_Comm_Data_Block:
     proc ();

/* Unlinks and frees what cdbp points to. */

	if comm_data_block.backward_ptr = null ()
	     then first_cdbp = comm_data_block.forward_ptr;
						/* It was the head of the chain. */
	     else comm_data_block.backward_ptr -> comm_data_block.forward_ptr = comm_data_block.forward_ptr;

	if comm_data_block.forward_ptr = null ()
	     then last_cdbp = comm_data_block.backward_ptr;
						/* It was the tail of the chain. */
	     else comm_data_block.forward_ptr -> comm_data_block.backward_ptr = comm_data_block.backward_ptr;

	free comm_data_block in (based_area);
	cdbp = null ();

	return;

     end Free_Comm_Data_Block;

Send_EOM:
     proc (P_code);

dcl  P_code		       fixed bin (35) parameter;

	output_chars_to_write = length ("$*$EOM" || RBF.char_codes.RS);
	substr (output_buffer, 1, output_chars_to_write) = "$*$EOM" || RBF.char_codes.RS;

	call l6_tran_util_$put_chars (comm_data_block.comm_iocbp, output_buffer_ptr, output_chars_to_write, P_code);


	return;

     end Send_EOM;

Set_Translation:
     proc (translate_table, trans_strucp);

dcl  translate_table	       char (512) parameter;
dcl  trans_strucp		       ptr parameter;

dcl  translate_string_len	       fixed bin (21);
dcl  translate_stringp	       ptr;
dcl  translate_string	       char (translate_string_len) based (translate_stringp);


	if trans_strucp = null
	     then translate_table = collate9 ();

	     else do;
		translate_stringp = addr (trans_strucp -> cv_trans_struc.cv_trans.value);
		translate_string_len = dimension (trans_strucp -> cv_trans_struc.cv_trans.value, 1);

		translate_table = translate_string;

		if length (translate_table) > translate_string_len
		     then substr (translate_table, translate_string_len + 1) =
			     copy ("", length (translate_table) - translate_string_len);
		end;

	return;

     end Set_Translation;

%include iox_dcls;

%include iocb;

%include iox_modes;

%include mode_string_info;

%include area_info;

%include terminal_type_data;

%include tty_convert;

%include tty_read_status_info;

%include terminal_io_record;

debug_on:
     entry ();

	debug_flag = "1"b;

	return;


debug_off:
     entry ();

	debug_flag = "0"b;

	return;

     end rbf_;
