/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(87-03-05,Parisek), approve(87-07-23,MCR7716),
     audit(87-08-07,Fawcett), install(87-08-11,MR12.1-1080):
     Continue execution with next exec_com line when abs_io_data.noabort
     is ON.
  2) change(87-09-02,Parisek), approve(87-09-02,PBF7716),
     audit(87-09-03,Farley), install(87-09-10,MR12.1-1104):
     Handle a nobort operation only if severity 1 errors occur.
                                                   END HISTORY COMMENTS */


/* Original coding: 25 June 1979 by J. Spencer Love
   Modified: 19 August 1981 by Steve Herbst not to loop if &detach gets an error.
   Modified: 14 February 1982 by Gary Palter for new calling sequence of ec_data.eval_string and to convert from
   command_processor_$af to cu_$evaluate_active_string.
   Modified: 7 June 1982 by J. Spencer Love to improve error checking for &then and &else clauses.			*/
/* Recompiled for changes to abs_data structure 04/12/83 S. Herbst */

/* format: style3,ifthenstmt,indcomtxt,indproc,idind30 */

abs_io_v1_get_line:
     procedure (P_iocb_ptr, P_buffer_ptr, P_buffer_len, P_actual_len, P_status);

declare	P_iocb_ptr		ptr,		/* ptr to IOCB of abs_io_ or syn_ attached to abs_io_	*/
	P_buffer_ptr		ptr,		/* ptr to caller's input buffer			*/
	P_buffer_len		fixed bin (21),	/* maximum length (in chars) of caller's buffer		*/
	P_actual_len		fixed bin (21),	/* length of data actually returned			*/
	P_status			fixed bin (35);	/* standard system error code				*/

declare	(addr, binary, char, codeptr, copy, divide, index, length, ltrim, max, min, mod, null, rank, rtrim, search,
	string, substr, unspec, verify)
				builtin;

declare	(area, cleanup)		condition;

declare	IS			char (input_string.len) based (input_string.ptr),
	old_IS_pos		fixed bin (21);

declare	CL_len			fixed bin (21),
	CL_pos			fixed bin (21),
	CL_ptr			ptr,
	CL			char (CL_len) based (CL_ptr),
	not_in_CL			bit (1) aligned,
	old_CL_pos		fixed bin (21);

declare	RS_len			fixed bin (21),
	RS_pos			fixed bin (21),
	RS_ptr			ptr,
	RS			char (RS_len) based (RS_ptr),
	old_RS_len		fixed bin (21);
%page;
declare	arg_idx			fixed bin,
	break			fixed bin,
	buffer_allocated		bit (1) aligned,
	buffer_len		fixed bin (21),
	buffer_ptr		ptr,
	control			fixed bin,
	copy_len			fixed bin (21),
	from_sw			bit (1) aligned,
	get_next_line		local label variable,
	hash			fixed bin,
	input_reset_sw		bit (1) aligned,
	iocb_ptr			ptr,
	len			fixed bin (21),
	quote_modifier		fixed bin,
	start			fixed bin (21),
	state			fixed bin,
	saved_hash		fixed bin,
	saved_label_ptr		ptr,
	saved_state		fixed bin,
	scanning_clause		bit (1) aligned,
	status			fixed bin (35),
	test			bit (1) aligned,
	twoL			fixed bin (21),
	width			fixed bin;

declare	1 ready_mode		aligned,
	  2 flag			bit (1) unaligned,
	  2 pad			bit (35) unaligned;

declare	ec_name			char (arg_info.ec_name_len) based (arg_info.ec_name_ptr),
	ec_path			char (arg_info.ec_path_len) based (arg_info.ec_path_ptr),
	P_buffer			char (P_actual_len) based (P_buffer_ptr),
	allocated_chars		char (abs_data.allocated_chars_len) based (abs_data.allocated_chars_ptr),
	return_arg		char (ec_data.return_len) varying based (ec_data.return_ptr);

declare	arg_string		char (arg_array (arg_idx).len) based (arg_array (arg_idx).ptr);

declare	1 arg_array		(abs_data.arg_count) aligned based (abs_data.arg_ptr),
	  2 ptr			ptr,
	  2 len			fixed bin (21),
	  2 quotes		fixed bin (21);
%page;
declare	INIT			bit (1) aligned static options (constant) initial ("0"b),
	UPDATE			bit (1) aligned static options (constant) initial ("1"b);

declare	NL			char (1) static options (constant) initial ("
");

declare	NL_THEN_AMP		char (2) static options (constant) initial ("
&");

declare	SPACE			char (1) static options (constant) initial (" "),
	TRUE			char (4) static options (constant) initial ("true"),
	FALSE			char (5) static options (constant) initial ("false"),
	TRACE_THEN		char (6) static options (constant) initial ("&then "),
	TRACE_ELSE		char (6) static options (constant) initial ("&else ");

declare	RANK_ZERO			fixed bin static options (constant) initial (48),
	RANK_AMP_ADJ		fixed bin static options (constant) initial (-10),
	RANK_F_ADJ		fixed bin static options (constant) initial (54);

declare	NONE			fixed bin static options (constant) initial (0),
	QUOTE			fixed bin static options (constant) initial (1),
	REQUOTE			fixed bin static options (constant) initial (2);

declare	NORMAL			fixed bin static options (constant) initial (0),
	SEARCHING_FOR_LABEL		fixed bin static options (constant) initial (1),
	MUST_BE_LABEL		fixed bin static options (constant) initial (2),
	MUST_BE_THEN		fixed bin static options (constant) initial (3),
	SKIPPING_CLAUSE		fixed bin static options (constant) initial (4);

declare	DATA			fixed bin static options (constant) initial (-1),
	COMMENT			fixed bin static options (constant) initial (0),
	ELSE			fixed bin static options (constant) initial (6),
	GOTO			fixed bin static options (constant) initial (7),
	LABEL			fixed bin static options (constant) initial (10),
	THEN			fixed bin static options (constant) initial (16);

declare	LOW			(12) fixed bin static options (constant)
				initial (1, 2, 5, 6, 7, 8, 10, 11, 12, 13, 16, 17);

declare	HIGH			(12) fixed bin static options (constant)
				initial (1, 4, 5, 6, 7, 9, 10, 11, 12, 15, 16, 17);

declare	KEYWORD			(17) char (12) varying static options (constant)
				initial ("attach", "command_line", "comment_line", "control_line", "detach",
				"else", "goto", "if", "input_line", "label", "print", "quit", "ready",
				"ready_proc", "return", "then", "version");

declare	TRACE			(-1:17) bit (1) aligned static options (constant)
				initial ("0"b, "0"b, (5) ("1"b), "0"b, "1"b, "0"b, (7) ("1"b), "0"b, "0"b);

declare	SKIPABLE			(-1:17) bit (1) aligned static options (constant)
				initial ("1"b, "0"b, (5) ("1"b), "0"b, "1"b, "0"b, "1"b, "0"b, (5) ("1"b), "0"b,
				"1"b);

declare	WHITE			char (5) static options (constant) initial ("
	 ");					/* FF VT NL HT SP					*/

declare	(
	error_table_$noalloc,
	error_table_$command_line_overflow,
	error_table_$end_of_info,
	error_table_$long_record
	)			fixed bin (35) external,
	iox_$user_output		ptr external,
	iox_$user_input		ptr external;

declare	abs_io_control$attach	entry (ptr, ptr, fixed bin (35)),
	abs_io_control$detach	entry (ptr, ptr, fixed bin (35)),
	abs_io_control$sleep	entry (ptr),
	active_fnc_err_		entry () options (variable),
	com_err_			entry () options (variable),
	cu_$arg_list_ptr		entry () returns (ptr),
	cu_$arg_ptr		entry (fixed bin, ptr, fixed bin (21), fixed bin (35)),
	cu_$evaluate_active_string	entry (ptr, char (*), fixed bin, char (*) var, fixed bin (35)),
	cu_$set_ready_mode		entry (1 aligned like ready_mode),
	hcs_$fs_get_path_name	entry (ptr, char (*), fixed bin, char (*), fixed bin (35)),
	ioa_$general_rs		entry (ptr, fixed bin, fixed bin, char (*), fixed bin, bit (1), bit (1)),
	ioa_$nnl			entry options (variable),
	iox_$find_iocb		entry (char (*), ptr, fixed bin (35)),
	iox_$get_line		entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35)),
	iox_$put_chars		entry (ptr, ptr, fixed bin (21), fixed bin (35)),
	logout			entry options (variable),
	signal_io_error_		entry (char (*), ptr, fixed bin (35));
%page;
/* abs_io_v1_get_line: procedure (P_iocb_ptr, P_buffer_ptr, P_buffer_len, P_actual_len, P_status);  */

	call get_ptrs (INIT);			/* the usual housekeeping to interface to the I/O system	*/

	input_reset_sw = "0"b;

/* recursion check. used to protect against &if [io get_line &ec_switch] (e.g., &if [query ...] in absentee)		*/

	do while (abs_data.active);			/* Loop until bit is cleared asynchronously, if set	*/
	     if attachedp ()
	     then do;				/* Not our problem; we can offload this request to attachee */
		     call iox_$get_line (abs_data.attach.save_ptr, P_buffer_ptr, P_buffer_len, P_actual_len, P_status)
			;
		     return;
		end;

	     call signal_io_error_ ("Attempt to invoke parser recursively.  Check for invalid ""&if"" test.", iocb_ptr,
		0);

	     call get_ptrs (INIT);			/* world may have changed, so reinit our view of it	*/
	end;

	on cleanup abs_data.active = "0"b;		/* Protect against non-local goto			*/

	abs_data.active = "1"b;			/* Prevent recursive invocation of this I/O switch	*/

/* Handle abnormal situations:  no data left, or partial line remaining.  Initialize for exit paths as needed.	*/

	if abs_data.eof then go to END_OF_FILE;		/* No data left, just exit without doing any work		*/

	if abs_data.chars_len > 0 then go to CONTINUE_LONG_RECORD;

/* Timed input mode:  used in absentee processes to simulate interactive usage patterns				*/

	if abs_data.timed_input then call abs_io_control$sleep (abs_data_ptr);

/* Now initialize variables for the scan...								*/

	width = 0;				/* width of modifier field, e.g., f, q, r, qf, rf, f&n, etc */
	quote_modifier = NONE;			/* quote processing to be done to current parameter	*/
	from_sw = "0"b;				/* current parameter doesn't (yet) have f as in &f	*/
	saved_hash = -1;				/* used by &goto... valid range 0:60			*/

/* Hack nested &if statements where we returned something and have to skip the rest of a compound statement		*/

	if abs_data.nest_level > abs_data.expected_nest_level
	then state = SKIPPING_CLAUSE;			/* In the middle of an &if:  if we're here, skip the rest	*/
	else state = NORMAL;

	if abs_data.else_clause_len > 0 then go to CONTINUE_WITH_PENDING_ELSE_CLAUSE;
						/* not finished with last line, can't expand another yet	*/

	buffer_allocated = "0"b;			/* Initially expanding into P_buffer			*/
	get_next_line = EXPAND_NEXT_LINE;		/* Normal setting.  Used by &if nesting get control back.	*/
	CL_len = 0;				/* No statements scanned yet, so don't skip anything	*/
%page;
EXPAND_NEXT_LINE:
	input_string.position = input_string.position + CL_len;
						/* Position to the beginning of the next statement	*/
	if input_string.position >= input_string.len then go to END_OF_FILE;
						/* If we've gone too far, punt now			*/

	CL_ptr = addr (substr (IS, input_string.position + 1));
	CL_len = index (substr (IS, input_string.position + 1), NL);
	if CL_len = 0 then go to NO_NEW_LINE;		/* Must be at end of file, print warning and &quit	*/

	not_in_CL = "0"b;				/* Use original line in input seg, no expansions so far	*/
	scanning_clause = "0"b;			/* We are not currently within an &then or &else clause	*/

	CL_pos = index (CL, "&") - 1;			/* Find the first ampersand in the current line		*/
	if CL_pos < 0 then go to COPY_REST;		/* No ampersands in line.  Skip expansion loop.		*/

	RS_len, old_CL_pos, old_RS_len = 0;		/* So far we've expanded nothing			*/
	RS_ptr = buffer_ptr;			/* We will expand to here, if necessary			*/
	twoL = 1;					/* This is 2**(quote depth), used for requoting		*/

	if CL_pos = 0
	then do;					/* First char is ampersand.  Special case for fast comments */
		break = index ("0123456789efinqracdglptv", substr (CL, 2, 1)) - 1;
		if break < 0 then go to COMMENT_LINE;	/* If it's a comment, we needn't expand it or return it	*/
		if break < 10 then go to EXPAND_ARG_NUMBER;
						/* A digit.  Get whole number and expand argument		*/
		if break < 16 then go to EXPAND (break);/* Might be expandable, investigate further		*/
		go to EXPAND_AGAIN;			/* This might be a keyword, but we can't handle it now.	*/
	     end;
%page;
/* This is the loop which expands lines from the input segment.  It is entered here if the first character on the line
   is not an ampersand.  If the first character is an ampersand, it will have been handled on the previous page as a
   performance hack to not expand comment lines.  If no expandable constructs are encountered, the line will still be
   in the input segment.  If expansion is done, it is initially into the caller-provided buffer, but if that is too
   small, a larger buffer will be allocated and expansion will use it until the next line is returned to the caller.	*/

EXPAND_LOOP:
	break = index ("0123456789efinqr", substr (CL, CL_pos + 2, 1)) - 1;
	if break < 0 then go to EXPAND_AGAIN;		/* Not expandable. skip it				*/
	if break < 10 then go to EXPAND_ARG_NUMBER;	/* A digit.  Get whole number and expand argument		*/
	go to EXPAND (break);			/* Might be expandable... investigate further		*/

EXPAND (10):					/* &e						*/
	if substr (CL, CL_pos + 3, 1) ^= "c" then go to EXPAND_AGAIN;
						/* performance hack for &else				*/

	if substr (CL, CL_pos + 4, min (CL_len, 5)) = "_name" then call emit_ec_name ();
	else if substr (CL, CL_pos + 4, min (CL_len - 3, 4)) = "_dir" then call emit_ec_dir ();
	else if substr (CL, CL_pos + 4, min (CL_len - 3, 7)) = "_switch" then call emit_ec_switch ();

	go to EXPAND_AGAIN;

EXPAND (11):					/* &f						*/
	from_sw = "1"b;

	go to EXPAND_MODIFIER;

EXPAND (12):					/* &i						*/
	if substr (CL, CL_pos + 3, 1) ^= "s" then go to EXPAND_AGAIN;
						/* Performance hack for &if				*/

	if substr (CL, CL_pos + 4, min (CL_len - 3, 6)) = "_absin" then call predicate (abs_data.absentee, 8);
	else if substr (CL, CL_pos + 4, min (CL_len - 3, 16)) = "_active_function"
	then call predicate (functionp (), 18);
	else if substr (CL, CL_pos + 4, min (CL_len - 3, 3)) = "_af" then call predicate (functionp (), 5);
	else if substr (CL, CL_pos + 4, min (CL_len - 3, 9)) = "_attached" then call predicate (attachedp (), 11);
	else if substr (CL, CL_pos + 4, min (CL_len - 3, 11)) = "_input_line" then call predicate (input_linep (), 13);

	go to EXPAND_AGAIN;

EXPAND (13):					/* &n:  The number of arguments given for substitution	*/
	call emit_arg_count ();

	go to EXPAND_AGAIN;

EXPAND (14):					/* &q						*/
	quote_modifier = QUOTE;

	go to EXPAND_MODIFIER;

EXPAND (15):					/* &r						*/
	quote_modifier = REQUOTE;

EXPAND_MODIFIER:
	width = width + 1;
	break = rank (substr (CL, CL_pos + width + 2, 1)) - RANK_ZERO;
	if break = RANK_F_ADJ & ^from_sw
	then do;
		from_sw = "1"b;
		go to EXPAND_MODIFIER;
	     end;
	if break = RANK_AMP_ADJ
	then if substr (CL, CL_pos + width + 3, 1) = "n"
	     then do;				/* &..&n:  Appropriately modified last argument		*/
		     arg_idx = abs_data.arg_count;
		     width = width + 2;
		     go to COPY_ARG;
		end;
	if break < 0 | break > 9
	then do;					/* Construct isn't really a parameter, skip it		*/
		width = 0;			/* Reset these to default values, save the work elsewhere	*/
		quote_modifier = NONE;
		from_sw = "0"b;
		go to EXPAND_AGAIN;
	     end;

EXPAND_ARG_NUMBER:
	arg_idx = 0;
	do break = break repeat (rank (substr (CL, CL_pos + width + 2, 1)) - RANK_ZERO) while (break >= 0 & break <= 9);
	     if arg_idx <= abs_data.arg_count then arg_idx = 10 * arg_idx + break;
	     width = width + 1;
	end;

COPY_ARG:
	call copy_up_to_ampersand (width);		/* Skip construct (width chars long)			*/
	width = 0;
	if from_sw
	then do;					/* User specified range of arguments to expand		*/
		from_sw = "0"b;
		do arg_idx = max (1, arg_idx) to abs_data.arg_count;
		     call copy_string (arg_string, quote_modifier);
		     if arg_idx ^= abs_data.arg_count then call copy_string (SPACE, NONE);
		end;
	     end;
	else if arg_idx = 0 then call copy_string (ec_path, quote_modifier);
	else if arg_idx <= abs_data.arg_count then call copy_string (arg_string, quote_modifier);
	quote_modifier = NONE;

EXPAND_AGAIN:
	CL_pos = CL_pos + 1;			/* Skip ampersand					*/
	break = index (substr (CL, CL_pos + 1), "&") - 1;
	if break >= 0
	then do;					/* Any more ampersands in line?			*/
		CL_pos = CL_pos + break;
		go to EXPAND_LOOP;
	     end;

COPY_REST:
	if not_in_CL
	then do;					/* Copy rest of line if any expansions			*/
		copy_len = CL_len - old_CL_pos;
		call check_len (copy_len);
		substr (RS, RS_len - copy_len + 1, copy_len) = substr (CL, old_CL_pos + 1, copy_len);
	     end;
	else do;					/* Use unexpanded string, we may not need to copy it	*/
		RS_len = CL_len;
		RS_ptr = CL_ptr;
	     end;
%page;
/* We come here to identify the current request line as a statement, command, or expansion to be returned.
   We can get here by falling through from expansion, or to identify an &then or &else clause.			*/

CHECK_CONTROL:

	if substr (RS, 1, min (1, RS_len)) = "&"
	then do;					/* If first char is ampersand, hash on second char	*/
		break = index ("acdegilpqrtv", substr (RS, 2, 1));
		if break = 0 then go to COMMENT_LINE;
		len = search (substr (RS, 3), WHITE);	/* Get length of possible keyword			*/
		do control = LOW (break) to HIGH (break);
		     if KEYWORD (control) = substr (RS, 2, len)
		     then do;			/* Got a match! so just space RS_pos over it		*/
			     RS_pos = verify (substr (RS, len + 3), WHITE) + len + 1;
			     if RS_pos = len + 1 then RS_pos = RS_len;
			     go to STATE (state);	/* And we're off to an action routine (of some sort)	*/
			end;
		end;

		if len > 4
		then if break = 4
		     then if substr (RS, 2, 4) = "else"
			then call warning (0,
				"Whitespace must follow the ""&else"" keyword or the line is a comment.");
			else ;
		     else if break = 11
		     then if substr (RS, 2, 4) = "then"
			then call warning (0,
				"Whitespace must follow the ""&then"" keyword or the line is a comment.");

COMMENT_LINE:
		control = COMMENT;			/* We have a leading ampersand but no keyword. Ignore it	*/
	     end;
	else control = DATA;			/* No ampersand so this line can be returned to user	*/

	go to STATE (state);			/* Off to the wars (someone will handle this line)	*/

STATE (0):					/* NORMAL:  we come here if not in search or conditional	*/
	if TRACE (control) then call trace_output (abs_data.control_line, RS);

	go to CONTROL (control);			/* This is where we really head off to the action routine	*/
%page;
CONTINUE_LONG_RECORD:
	buffer_allocated = "1"b;			/* Tell exit routine to take data out of buffer		*/
	CL_len = 0;				/* Don't skip over statement since we did no expansion	*/
	scanning_clause = "0"b;			/* Init this for tastefulness sake			*/
	not_in_CL = "1"b;				/* Not from input segment				*/
	RS_len = abs_data.chars_len;			/* set RS to pending string				*/
	RS_ptr = abs_data.chars_ptr;

CONTROL (-1):					/* DATA = data to return to caller			*/
	if not_in_CL & ^buffer_allocated & ^scanning_clause
	then P_actual_len = RS_len;			/* All done since all data is already in caller's buffer	*/
	else do;					/* Otherwise copy as much as will fit			*/
		P_actual_len = min (P_buffer_len, RS_len);
		P_buffer = RS_ptr -> P_buffer;	/* If it doesn't all fit, stash the rest for later calls	*/
		if P_actual_len < RS_len
		then if not_in_CL
		     then do;			/* We have an allocated buffer, and characters in it	*/
			     abs_data.chars_ptr = addr (substr (RS, P_actual_len + 1));
			     abs_data.chars_len = RS_len - P_actual_len;
			end;
		     else do;			/* this means no pending &else clause or full buffer	*/
			     RS_ptr = addr (substr (RS, P_actual_len + 1));
			     abs_data.chars_len, RS_len = RS_len - P_actual_len;
			     call allocate_buffer (RS_len);
			     abs_data.chars_ptr = RS_ptr;
			end;
		else abs_data.chars_len = 0;
	     end;

	if abs_data.allocated_chars_ptr ^= null () & abs_data.chars_len <= 0 & abs_data.else_clause_len <= 0
	then free allocated_chars;			/* We don't need the buffer anymore so we can dump it	*/

	input_string.position = input_string.position + CL_len;
						/* Step over statement so we will get next one later	*/

	if input_linep ()
	then call trace_output (abs_data.input_line, P_buffer);
	else call trace_output (abs_data.command_line, P_buffer);

	if abs_data.chars_len > 0
	then P_status = error_table_$long_record;	/* Pending chars exist so tell caller			*/
	else P_status = 0;

EGRESS:
	abs_data.active = "0"b;
	return;
%page;
NO_NEW_LINE:
	if state = SEARCHING_FOR_LABEL then go to STATE (SEARCHING_FOR_LABEL);
						/* &goto should field this				*/

	if state = MUST_BE_LABEL then go to UNSTUCK_LABEL;/* User has edited his ec				*/

	call warning (0, "The last line did not end in a newline and was ignored.");

END_OF_FILE:
	if state = MUST_BE_LABEL then go to UNSTUCK_LABEL;/* User has edited his ec.				*/

	if state = MUST_BE_THEN
	then call error (0, "The end of file was encountered when a ""&then"" statement was expected.");

	abs_data.eof = "1"b;			/* Make sure that end of file is remembered		*/

	if ^input_reset_sw
	then do;					/* Mustn't leave &attach in effect			*/
		input_reset_sw = "1"b;

		call reset_input ();
	     end;

	if abs_data.absentee then call logout ();

	P_actual_len = 0;				/* Tell user what happened and how much data he got	*/
	P_status = error_table_$end_of_info;

	go to EGRESS;				/* Only one exit allowed for cleanup purposes		*/
%page;
/* The following small serving of spaghetti is used to implement &goto and &label.  Labels are kept in chained buckets
   in a small hash table.  Buckets are allocated the first time a label is seen, whether it it in a &label or a &goto.
   There is no limit on the length of labels and the characters in a label, except that leading and trailing whitespace
   are removed from them.  The blank label is allowed.  Label search is defined to find the first instance of a label
   starting from the top of the file, so duplicate instances of the same label are ignored.  The hashed label scheme is
   a large performance improvement in big exec_coms.							*/

CONTROL (7):					/* &goto						*/
	abs_data.nest_level = 0;			/* reset nest state, so parser doesn't think we are	*/
	abs_data.else_clause_len = 0;			/* still in if statement or have else clause pending.	*/
	get_next_line = EXPAND_NEXT_LINE;		/* also set scanner back to normal			*/

	input_string.limit = max (input_string.limit, input_string.position + CL_len);
						/* save farthest point in case backward branch		*/
	go to GET_CURRENT_LABEL;			/* now go parse statement				*/

CONTROL (10):					/* &label						*/
	if scanning_clause then call error (0, "A label may not follow ""&then"" or ""&else"".");

	if input_string.limit > input_string.position then go to get_next_line;
						/* Have we seen this label already?			*/

GET_CURRENT_LABEL:
	current_label_ptr = addr (substr (RS, RS_pos + 1));
	current_label_len = length (rtrim (substr (RS, RS_pos + 1), WHITE));
	hash =
	     mod (binary (unspec (char (substr (current_label, 1, min (2, current_label_len)), 2)), 18)
	     + current_label_len, 61);

	if hash = saved_hash			/* cheap test -- saved_hash = -1 if not looking		*/
	then if current_label = saved_label_ptr -> label.name
	     then do;
		     saved_hash = -1;		/* reset saved_hash to illegal value for test		*/
		     if state = MUST_BE_LABEL
		     then do;			/* Label found in hash table has been verified		*/
			     state = NORMAL;
			     go to get_next_line;
			end;
		     state = NORMAL;		/* reset from SEARCHING_FOR_LABEL			*/
		     label_ptr = saved_label_ptr;	/* so saved block will be threaded properly		*/
		     go to THREAD_IN_LABEL;
		end;

	if state = MUST_BE_LABEL then go to UNSTUCK_LABEL;/* User has edited the input file.			*/

	if abs_data.labels_ptr = null () then call allocate_hash_table ();

	do label_ptr = abs_data.labels_ptr -> hash_table (hash) repeat (label.next_ptr) while (label_ptr ^= null ());
	     if current_label = label.name		/* if match then three possible actions			*/
	     then if control = LABEL			/* for label we just go to next line, which in		*/
		then if state = NORMAL		/* search mode calls for special action to		*/
		     then go to get_next_line;	/* only scan control lines for efficiency		*/
		     else go to GET_NEXT_LABEL_LINE;
		else do;
			saved_hash = hash;
			saved_label_ptr = label_ptr;
			old_IS_pos = input_string.position;
			input_string.position = label.statement_pos;
			if input_string.position > 0
			then if substr (IS, input_string.position, 1) ^= NL then go to UNSTUCK_LABEL;
			state = MUST_BE_LABEL;
			CL_len = 0;
			go to get_next_line;
		     end;
	end;

	on area call error (error_table_$noalloc, "Allocating label ""^a"".", current_label);

	allocate label in (abs_data.work_area);		/* we need a new label cell since we now know this label	*/
						/* has never been seen before.  length is arbitrary	*/
	revert area;

	if control = GOTO
	then do;
		saved_hash = hash;			/* we do this for cheap compare above			*/
		saved_label_ptr = label_ptr;		/* we will need this later for compare and threading in	*/
		old_IS_pos = input_string.position;	/* this is for line number in error message		*/
		state = SEARCHING_FOR_LABEL;		/* set state to ignore everything but labels		*/
		input_string.position = input_string.limit - CL_len;
		go to GET_NEXT_LABEL_LINE;		/* start search beyond what we've already seen		*/
	     end;

THREAD_IN_LABEL:
	label.statement_pos = input_string.position;	/* set label to beginning of its line			*/
	label.next_ptr = abs_data.labels_ptr -> hash_table (hash);
	abs_data.labels_ptr -> hash_table (hash) = label_ptr;

	if state = NORMAL then go to get_next_line;	/* We are done unless still skipping			*/

GET_NEXT_LABEL_LINE:
	input_string.position = input_string.position + CL_len;
	CL_len = index (substr (IS, input_string.position), NL_THEN_AMP) - 1;
						/* search for next control string			*/
	if CL_len >= 0 then go to get_next_line;	/* Found something; check it out			*/

	input_string.position = old_IS_pos;		/* Restore position for error message.			*/
	call error (0, "Label ""^a"" not found.", saved_label_ptr -> label.name);

STATE (1):					/* SEARCHING_FOR_LABEL				*/
	if control = LABEL
	then go to GET_CURRENT_LABEL;			/* in this state we ignore everything but &label lines	*/
	else go to GET_NEXT_LABEL_LINE;		/* since efficient label search is critical		*/

STATE (2):					/* MUST_BE_LABEL					*/
	if control = LABEL then go to GET_CURRENT_LABEL;

UNSTUCK_LABEL:
	input_string.position = old_IS_pos;
	state = NORMAL;
	call error (0, "Label ""^a"" is unstuck.  Active programs may not be edited.", saved_label_ptr -> label.name);
%page;
CONTROL (0):					/* COMMENT LINE					*/
	if scanning_clause then call error (0, "A comment may not follow ""&then"" or ""&else"".");

	call trace_output (abs_data.comment_line, CL);

	go to get_next_line;

CONTROL (11):					/* &print						*/
	call ioa_$nnl (substr (RS, min (RS_pos + 1, RS_len)));
	go to get_next_line;

CONTROL (12):					/* &quit						*/
	if RS_pos ^= RS_len then call warning (0, "No arguments are required by ""&quit"".");

	go to END_OF_FILE;

CONTROL (15):					/* &return					*/
	if RS_pos = RS_len then RS_pos = RS_pos - 1;	/* Newline at end of null return string is not white space	*/

	RS_ptr = addr (substr (RS, RS_pos + 1));	/* Adjust RS to only be argument of statement		*/
	RS_len = RS_len - RS_pos;

	if functionp ()
	then do;
		RS_len = RS_len - 1;		/* Don't return newline at end for active function	*/
		if RS_len > ec_data.return_len
		then call warning (error_table_$command_line_overflow,
			"Expanded value length of ^d characters exceeds return argument length of ^d characters.",
			RS_len, ec_data.return_len);
		return_arg = RS;
	     end;
	else call iox_$put_chars (iox_$user_output, RS_ptr, RS_len, status);

	go to END_OF_FILE;

CONTROL (17):
	call error (0, "The ""&version"" statement may only be the first line of the program.");
%page;
CONTROL (1):					/* &attach					*/
	if RS_pos ^= RS_len then call warning (0, "No arguments are required by ""&attach"".");

	if ec_data_ptr ^= null () & ^attachedp ()
	then do;
		call abs_io_control$attach (abs_data_ptr, null (), status);
		if status ^= 0 then call error (status, "Error while performing ""&attach"".");
	     end;

	go to get_next_line;

CONTROL (5):					/* &detach					*/
	if RS_pos ^= RS_len then call warning (0, "No arguments are required by ""&detach"".");

	input_string.position = input_string.position + CL_len;
						/* Adjust position in case call to reset_input fails	*/
	CL_len = 0;				/* Make sure that it isn't adjusted twice if it doesn't	*/

	call reset_input ();			/* Do &detach, call get_line for saved switch if input line */

	go to get_next_line;

reset_input:
     procedure ();

	if attachedp ()
	then do;
		call abs_io_control$detach (abs_data_ptr, null (), status);
		if status ^= 0 then call error (status, "Error while performing ""&detach"".");
		if input_linep ()
		then do;
			call iox_$get_line (iox_$user_input, P_buffer_ptr, P_buffer_len, P_actual_len, P_status);
			go to EGRESS;
		     end;
	     end;

	return;
     end;
%page;
CONTROL (13):					/* &ready						*/
	string (ready_mode) = ""b;
	ready_mode.flag = trace_mode ();

	if ec_data_ptr ^= null ()
	then if codeptr (ec_data.set_ready_mode) ^= null ()
	     then call ec_data.set_ready_mode (ready_mode);
	     else call cu_$set_ready_mode (ready_mode);
	else call cu_$set_ready_mode (ready_mode);

	go to get_next_line;

CONTROL (14):					/* &ready_proc					*/
	test = trace_mode ();
	if ec_data_ptr ^= null () then ec_data.call_ready_proc = test;
	go to get_next_line;

trace_mode:
     procedure () returns (bit (1) aligned);

	if RS_len = RS_pos
	then do;
		call warning (0, "Missing keyword in mode statement.  ""on"" assumed.");
		return ("1"b);
	     end;

	RS_len = length (rtrim (RS, WHITE));

	if substr (RS, RS_pos + 1) = "on" | substr (RS, RS_pos + 1) = "true" then return ("1"b);
	if substr (RS, RS_pos + 1) = "off" | substr (RS, RS_pos + 1) = "false" then return ("0"b);
	call warning (0, "Illegal keyword in mode statement.  ""on"" assumed.");

	return ("1"b);
     end;
%page;
CONTROL (2):					/* &command_line					*/
	call trace_control (abs_data.command_line);
	go to get_next_line;

CONTROL (3):					/* &comment_line					*/
	call trace_control (abs_data.comment_line);
	go to get_next_line;

CONTROL (4):					/* &control_line					*/
	call trace_control (abs_data.control_line);
	go to get_next_line;

CONTROL (9):					/* &input_line					*/
	call trace_control (abs_data.input_line);
	go to get_next_line;

trace_control:
     procedure (trace_structure);

declare	1 trace_structure		aligned like abs_data.command_line;

	if RS_len = RS_pos
	then do;
		call warning (0, "Missing keyword in tracing statement.  ""on"" assumed.");
		trace_structure.on = "1"b;
		return;
	     end;

	len = search (substr (RS, RS_pos + 2), WHITE);	/* Find end of keyword				*/
	RS_len = length (rtrim (RS, WHITE));		/* Find end of tokens on line				*/

	if substr (RS, RS_pos + 1) = "on" | substr (RS, RS_pos + 1) = "true" then trace_structure.on = "1"b;
	else if substr (RS, RS_pos + 1) = "off" | substr (RS, RS_pos + 1) = "false" then trace_structure.on = "0"b;
	else if substr (RS, RS_pos + 1, len) = "output_switch" | substr (RS, RS_pos + 1, len) = "osw"
	then if RS_pos + len >= RS_len
	     then trace_structure.iocb = null ();
	     else do;
		     RS_pos = RS_pos + len + verify (substr (RS, RS_pos + len + 2), WHITE);
		     call iox_$find_iocb (substr (RS, RS_pos + 1), trace_structure.iocb, status);
		     if status ^= 0 then call error (status, "Finding stream ""^a"".", substr (RS, RS_pos + 1));
		end;
	else do;
		call warning (0, "Invalid keyword in tracing statement.  ""on"" assumed.");
		trace_structure.on = "1"b;
	     end;

	return;

     end trace_control;
%page;
trace_output:
     procedure (trace_structure, line);

declare	1 trace_structure		aligned like abs_data.command_line,
	line			char (*);

declare	switch			ptr;

	do while (trace_structure.on);		/* Do this only if tracing is enabled.			*/
	     if trace_structure.iocb = null ()
	     then switch = iox_$user_output;		/* Default					*/
	     else switch = trace_structure.iocb;

	     call iox_$put_chars (switch, addr (line), length (line), status);
	     if status = 0 then return;		/* Exit if line successfully traced			*/

	     call signal_io_error_ ("Unable to do trace output.  Correct I/O attachments and type ""start"".", switch,
		status);

	     call get_ptrs (UPDATE);			/* Make sure user didn't do too good a job of "correction"	*/
	end;

	return;

     end trace_output;

/* This procedure copies parameters and gets pointers to our databases.  It is called when abs_io_v1_get_line is
   entered and after calling signal_io_error_ to make sure that nothing has changed that we care about.		*/

get_ptrs:
     procedure (update);

declare	update			bit (1) aligned;

	iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;

	if update
	then do;
		do while (abs_data_ptr ^= iocb_ptr -> iocb.attach_data_ptr);
		     call signal_io_error_ ("Attachment of " || abs_data.io_module_name || " has been moved.",
			P_iocb_ptr, 0);
		     iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
		end;
		return;
	     end;

	abs_data_ptr = iocb_ptr -> iocb.attach_data_ptr;
	ec_data_ptr = abs_data.ec_data_ptr;
	buffer_ptr = P_buffer_ptr;
	buffer_len = P_buffer_len;

	return;

     end get_ptrs;
%page;
CONTROL (8):					/* &if						*/
	start = find_clause ("&then");

	if RS_len = RS_pos | start = RS_pos then call error (0, "Missing conditional in ""&if"" statement.");

	if start >= 0
	then do;
		old_RS_len = RS_len;		/* Save for locating &then clause			*/
		RS_len = start;			/* Delay assignment for benefit of error message routine.	*/
	     end;

	RS_len = length (rtrim (RS, WHITE));

	abs_data.nest_level = abs_data.nest_level + 1;

	if state = NORMAL
	then do;
		call trace_output (abs_data.control_line, RS);
		call trace_output (abs_data.control_line, NL);
		abs_data.expected_nest_level = abs_data.nest_level;
		if ^conditional () then state = SKIPPING_CLAUSE;
	     end;

	if start < 0
	then do;
		saved_state = state;
		state = MUST_BE_THEN;
		go to EXPAND_NEXT_LINE;		/* Go direct, don't mess around. This state is indivisible	*/
	     end;

	RS_ptr = addr (substr (RS, start + 1));
	RS_len = old_RS_len - start;

	RS_pos = verify (substr (RS, 6), WHITE) + 4;	/* Find beginning of clause beyond "&then"		*/
	if RS_pos = 4 then RS_pos = RS_len;
%page;
CONTINUE_THEN:
	if abs_data.else_clause_len <= 0
	then do;					/* maybe we even have the &else			*/
		start = find_clause ("&else");
		if start >= 0
		then do;				/* We do. Copy the whole line into an allocated buffer	*/
			if ^not_in_CL | ^buffer_allocated then call allocate_buffer (RS_len);
			abs_data.else_clause_len = RS_len - start;
			abs_data.else_clause_ptr = addr (substr (RS, start + 1));
			RS_len = length (rtrim (substr (RS, 1, start), WHITE)) + 1;
			substr (RS, RS_len, 1) = NL;	/* Break the line.  We'll get rest of the line next time	*/
			get_next_line = GET_PENDING_ELSE_CLAUSE;
		     end;
	     end;

	if RS_pos >= RS_len then RS_pos = RS_len - 1;	/* Newline at end of null line is not white space		*/

	RS_ptr = addr (substr (RS, RS_pos + 1));	/* Step over &then or &else and following whitespace	*/
	RS_len = RS_len - RS_pos;

	if state = NORMAL
	then do;					/* This clause will be executed.  First, we trace ourself.	*/
		if control = THEN
		then call trace_output (abs_data.control_line, TRACE_THEN);
		else call trace_output (abs_data.control_line, TRACE_ELSE);

		abs_data.expected_nest_level = 0;	/* After taking this clause we skip until back at top level */

		if abs_data.else_clause_len = 0 & abs_data.nest_level > 0
		then get_next_line = ENTER_SKIPPING_CLAUSE_STATE;
	     end;					/* Arrange to set state to skipping after taking clause	*/

	scanning_clause = "1"b;			/* Comments and labels are forbidden in clauses		*/

	go to CHECK_CONTROL;			/* Prepare to execute clause				*/

STATE (3):					/* MUST_BE_THEN					*/
	if control = COMMENT then go to get_next_line;	/* comments are allowed between &if and &else statements	*/

	if control ^= THEN then call error (0, "Missing ""&then"" keyword following ""&if"" statement.");

	state = saved_state;			/* pop state saved in &if (NORMAL or SKIPPING_CLAUSE)	*/

	go to CONTINUE_THEN;

CONTROL (16):					/* &then:  this can't be reached by a legitimate clause	*/
	call error (0, "Unexpected ""&then"" statement.");
%page;
CONTINUE_WITH_PENDING_ELSE_CLAUSE:
	buffer_allocated = "1"b;			/* We have just reentered, so initialize--this must be	*/
	CL_len = 0;				/* We haven't done any expansion this time, so don't skip	*/
	not_in_CL = "1"b;				/* in an allocated buffer, not in the input file		*/

GET_PENDING_ELSE_CLAUSE:
	RS_len = abs_data.else_clause_len;		/* Set RS to pending &else clause in allocated buffer	*/
	RS_ptr = abs_data.else_clause_ptr;
	abs_data.else_clause_len = 0;			/* Unmark pending &else clause storage			*/

	RS_pos = verify (substr (RS, 6), WHITE) + 4;	/* Set RS_pos as if we came from CHECK_CONTROL		*/
	if RS_pos = 4 then RS_pos = RS_len;		/* Locate it at first non-white char or at end of line	*/

	get_next_line = EXPAND_NEXT_LINE;		/* Reset this since we don't want to come back here	*/

	control = ELSE;				/* This is the only kind of statement that is ever pending	*/

CONTROL (6):					/* &else						*/
	if abs_data.nest_level <= 0 then call error (0, "Unexpected ""&else"" statement.");

	abs_data.nest_level = abs_data.nest_level - 1;	/* Implement nesting here				*/
	if abs_data.nest_level < abs_data.expected_nest_level
	then state = NORMAL;
	else state = SKIPPING_CLAUSE;

	go to CONTINUE_THEN;

STATE (4):					/* SKIPPING_CLAUSE					*/
	if ^scanning_clause
	then if control = ELSE | control = COMMENT
	     then go to CONTROL (control);		/* &else or comments are part of nested compound statement	*/
	     else do;				/* anything else ends compound statement		*/
		     scanning_clause = "0"b;		/* comments and &labels are legal again			*/
		     state = NORMAL;		/* nested statement must end here			*/
		     abs_data.nest_level = 0;		/* so reset back to top level				*/
		     go to STATE (NORMAL);
		end;

	if SKIPABLE (control)
	then go to get_next_line;
	else go to CONTROL (control);

ENTER_SKIPPING_CLAUSE_STATE:
	state = SKIPPING_CLAUSE;			/* We have taken a clause, so we skip rest of if statement	*/

	get_next_line = EXPAND_NEXT_LINE;		/* Reset this, we don't need to come here again		*/

	go to EXPAND_NEXT_LINE;
%page;
/* This function is called from &if to find &then and from &then or &else to find an &else which follows on the same
   line.  The contract of the function is to return the length of the string preceding the keyword, which must be
   delimited on BOTH sides by whitespace.  If it is followed by a newline, that is considered whitespace.  If the
   clause is not found, the -1 is returned.								*/

find_clause:
     procedure (keyword) returns (fixed bin (21));

declare	keyword			char (*),
	keyword_pos		fixed bin (21),
	start_keyword		fixed bin (21);

	keyword_pos = RS_pos;			/* start with first unidentified character		*/

	start_keyword = index (substr (RS, RS_pos + 1), keyword) - 1;

	if start_keyword < 0 then return (-1);

	keyword_pos = RS_pos + start_keyword;

	if index (WHITE, substr (RS, keyword_pos + length (keyword) + 1, 1)) - 1 < 0
	     | index (WHITE, substr (RS, keyword_pos, 1)) - 1 < 0
	then call warning (0, "Whitespace must surround the ""^a"" keyword.", keyword);

	return (keyword_pos);

     end find_clause;
%page;

/* This procedure implements knowledge of the syntax of &if conditionals (except for detection of missing conditionals,
   which is done in &if).  The forms accepted are "true", "false", "[...]", "|[...]", and "||[...]".  The forms
   containing brackets are evaluated by calling cu_$evaluate_active_string with the string contained between them.  A
   zero error code must be returned, and the returned value must be either "true" or "false".			*/

conditional:
     procedure () returns (bit (1) aligned);

declare	AF_len			fixed bin (21),
	AF_ptr			ptr,
	AF			char (AF_len) based (AF_ptr),
	bars_len			fixed bin,
	value			char (8) varying;

	if substr (RS, RS_pos + 1) = "true" then return ("1"b);

	if substr (RS, RS_pos + 1) = "false" then return ("0"b);

	if substr (RS, RS_pos + 1, 1) = "|"
	then if substr (RS, RS_pos + 2, 1) = "|"
	     then bars_len = 2;
	     else bars_len = 1;
	else bars_len = 0;

	if substr (RS, RS_pos + bars_len + 1, 1) ^= "[" | substr (RS, RS_len) ^= "]"
	then call error (0, "Malformed conditional in ""&if"" statement.");

	AF_ptr = addr (substr (RS, RS_pos + bars_len + 2));
	AF_len = RS_len - RS_pos - bars_len - 2;	/* do not pass brackets surrounding if expression		*/

	if ec_data_ptr ^= null ()
	then if codeptr (ec_data.eval_string) ^= null ()
	     then call ec_data.eval_string (null (), AF, (bars_len + 1), value, status);
	     else call cu_$evaluate_active_string (null (), AF, (bars_len + 1), value, status);
	else call cu_$evaluate_active_string (null (), AF, (bars_len + 1), value, status);

	if status ^= 0 then call error (status, "Evaluating ""&if"" clause.");

	if value = "true" then return ("1"b);

	if value = "false" then return ("0"b);

	call error (0, "Illegal value ""^a"" returned by active function.", value);

     end conditional;
%page;
/* This utility predicate knows how to determine if some switch is &attached.  It has been designed to be easily
   extended to other cases than the usual &attach in exec_com using the io_call command or iox_$control		*/

attachedp:
     procedure () returns (bit (1) aligned);

	return (abs_data.attach.target_ptr ^= null ());

     end attachedp;

/* This utility predicate knows how to determine if the current line is an input line				*/

input_linep:
     procedure () returns (bit (1) aligned);

	if ec_data_ptr = null () then return ("0"b);	/* Can't be input unless someone tells us so		*/

	return (ec_data.input_line);

     end input_linep;

/* This utility predicate knows how to tell if we were invoked as an active function				*/

functionp:
     procedure () returns (bit (1) aligned);

	if ec_data_ptr = null ()
	then return ("0"b);				/* Can't return a value if we don't have a place to put it	*/
	else return (ec_data.active_function);

     end functionp;
%page;
emit_ec_name:
     procedure ();					/* &ec_name:  The entryname of the input file, sans suffix	*/

	call copy_up_to_ampersand (7);
	call copy_string (ec_name, QUOTE);

     end emit_ec_name;

emit_ec_dir:
     procedure ();					/* &ec_dir:  The dir containing the input file		*/
						/* This is used to simulate referencing_dir		*/
declare	ec_dir_buf		char (168),
	ec_dir_len		fixed bin,
	ec_dir			char (ec_dir_len) based (addr (ec_dir_buf));

	call copy_up_to_ampersand (6);
	call hcs_$fs_get_path_name (input_string.ptr, ec_dir_buf, ec_dir_len, (""), (0));
	call copy_string (ec_dir, QUOTE);

     end emit_ec_dir;

emit_ec_switch:
     procedure ();					/* &ec_switch:  The I/O switch to read input lines from	*/

declare	ec_switch			char (ec_switch_len) based,
	ec_switch_len		fixed bin;

	call copy_up_to_ampersand (9);
	if ec_data_ptr = null ()
	then do;
		ec_switch_len = length (rtrim (iocb_ptr -> iocb.name));
		call copy_string (addr (iocb_ptr -> iocb.name) -> ec_switch, QUOTE);
	     end;
	else do;
		ec_switch_len = length (rtrim (ec_data.switch_ptr -> iocb.name));
		call copy_string (addr (ec_data.switch_ptr -> iocb.name) -> ec_switch, QUOTE);
	     end;

     end emit_ec_switch;
%page;
emit_arg_count:
     procedure ();

declare	arg_count_pic		picture "zzzzzzzz9",
	arg_count_len		fixed bin,
	arg_count			char (arg_count_len) based (addr (substr (arg_count_pic, 10 - arg_count_len)));

	call copy_up_to_ampersand (1);
	arg_count_pic = abs_data.arg_count;
	arg_count_len = length (ltrim (arg_count_pic));
	call copy_string (arg_count, NONE);

     end emit_arg_count;

predicate:
     procedure (test, width);

declare	test			bit (1) aligned,
	width			fixed bin;

	call copy_up_to_ampersand (width);
	if test
	then call copy_string (TRUE, NONE);
	else call copy_string (FALSE, NONE);

	return;

     end predicate;

copy_up_to_ampersand:
     procedure (width);

declare	width			fixed bin;

	len = CL_pos - old_CL_pos;
	if len > 0
	then do;
		call check_len (len);
		substr (RS, RS_len - len + 1, len) = substr (CL, old_CL_pos + 1, len);
	     end;

	CL_pos = CL_pos + width;
	old_CL_pos = CL_pos + 1;

	not_in_CL = "1"b;				/* Make sure that we know some expansion was encountered	*/

	return;

     end copy_up_to_ampersand;
%page;
copy_string:
     procedure (arg_string, quote_modifier);

declare	arg_string		char (*),
	quote_modifier		fixed bin;

declare	(arg_pos, quote_pos, quote_len)
				fixed bin (21);

	if quote_modifier = NONE
	then do;
		call check_len (length (arg_string));
		substr (RS, RS_len - length (arg_string) + 1) = arg_string;
		return;
	     end;

	arg_pos = 0;

QLOOP:
	quote_len = index (substr (RS, old_RS_len + 1), """") - 1;
	if quote_len >= 0
	then do;
		old_RS_len = old_RS_len + quote_len;
		quote_len = verify (substr (RS, old_RS_len + 1), """") - 1;
		if quote_len < 0 then quote_len = RS_len - old_RS_len;
		old_RS_len = old_RS_len + quote_len;
		if mod (quote_len, twoL) = 0
		then do while (mod (quote_len, 2 * twoL) ^= 0);
			quote_len = quote_len - twoL;
			twoL = 2 * twoL;
		     end;
		else do while (quote_len ^= 0);
			twoL = divide (twoL, 2, 17, 0);
			quote_len = mod (quote_len, twoL);
		     end;
		go to QLOOP;
	     end;
	else old_RS_len = RS_len;

	if quote_modifier = REQUOTE
	then do;					/* insert quotes if requoting				*/
		call check_len (twoL);
		substr (RS, RS_len - twoL + 1, twoL) = copy ("""", twoL);
		twoL = 2 * twoL;			/* increase quote depth by one			*/
	     end;

DBL_LOOP:
	quote_pos = index (substr (arg_string, arg_pos + 1), """") - 1;
	if quote_pos >= 0
	then do;
		call check_len (quote_pos);
		substr (RS, RS_len - quote_pos + 1, quote_pos) = substr (arg_string, arg_pos + 1, quote_pos);
		arg_pos = arg_pos + quote_pos + 1;
		call check_len (twoL);
		substr (RS, RS_len - twoL + 1, twoL) = copy ("""", twoL);
		if arg_pos < length (arg_string)
		then go to DBL_LOOP;
		else go to APPEND;
	     end;

	quote_pos = length (arg_string) - arg_pos;
	if quote_pos > 0
	then do;					/* something after last quote in arg			*/
		call check_len (quote_pos);
		substr (RS, RS_len - quote_pos + 1, quote_pos) = substr (arg_string, arg_pos + 1, quote_pos);
	     end;

APPEND:
	if quote_modifier = REQUOTE
	then do;					/* append quotes if requoting				*/
		twoL = divide (twoL, 2, 17, 0);
		call check_len (twoL);
		substr (RS, RS_len - twoL + 1, twoL) = copy ("""", twoL);
	     end;
	old_RS_len = RS_len;

	return;

     end copy_string;
%page;
check_len:
     proc (len);					/* routine to make sure we don't overflow input buffer	*/

declare	len			fixed bin (21),
	new_RS_len		fixed bin (21);

	new_RS_len = RS_len + len;

	if new_RS_len > buffer_len then call allocate_buffer (new_RS_len);

	RS_len = new_RS_len;

	return;

     end check_len;

allocate_buffer:
     procedure (required_len);

declare	required_len		fixed bin (21),
	new_RS_ptr		ptr,
	new_RS			char (buffer_len) based (new_RS_ptr);

	not_in_CL = "1"b;				/* RS will not be eq to CL after this			*/
	buffer_allocated = "1"b;

	if abs_data.allocated_chars_ptr ^= null ()
	then if required_len <= abs_data.allocated_chars_len
	     then do;				/* Reuse allocated buffer if possible			*/
		     abs_data.allocated_chars_ptr -> RS = RS;
		     buffer_ptr, RS_ptr = abs_data.allocated_chars_ptr;
		     return;
		end;

	buffer_len = divide (16 * required_len + 15, 8, 21, 0);
	if buffer_len > 1044320
	then if required_len > 1044320
	     then call error (0, "Expanded line exceeds implementation restriction of 1044320 characters in length.");
	     else buffer_len = 1044320;		/* Biggest string that can fit in an extensible area	*/

	on area call error (error_table_$noalloc, "Allocating buffer (^d words).", required_len);

	allocate new_RS in (abs_data.work_area);

	revert area;

	new_RS_ptr -> RS = RS;

	if abs_data.allocated_chars_ptr ^= null () then free allocated_chars;

	abs_data.allocated_chars_ptr, buffer_ptr, RS_ptr = new_RS_ptr;
	abs_data.allocated_chars_len = buffer_len;

	return;

     end allocate_buffer;
%page;
allocate_hash_table:
     procedure ();

	on area call error (error_table_$noalloc, "Allocating label hash table.");

	allocate hash_table set (abs_data.labels_ptr) in (abs_data.work_area);

	revert area;

     end allocate_hash_table;
%page;
error:
     procedure () options (variable);

declare	complain			entry () variable options (variable),
	line_len			fixed bin (21),
	line_number		fixed bin (21),
	line_ptr			ptr,
	line_start		fixed bin (21),
	line			char (line_len) based (line_ptr),
	message			char (256),
	severity			bit (1),
	status_ptr		ptr,
	status			fixed bin (25) based (status_ptr),
	who			char (72) varying;

	severity = "1"b;
	go to ERROR_COMMON;

warning:
     entry options (variable);

	severity = "0"b;

ERROR_COMMON:
	call cu_$arg_ptr (1, status_ptr, (0), (0));
	call ioa_$general_rs (cu_$arg_list_ptr (), 2, 3, message, (0), "1"b, "0"b);

	line_number = 0;
	do line_start = 0 repeat (line_start + line_len + 1)
	     while ((line_start <= input_string.position) & (line_start < input_string.len));

	     line_len = index (substr (IS, line_start + 1), NL) - 1;
	     if line_len < 0 then line_len = input_string.len - line_start;
	     line_number = line_number + 1;
	     line_ptr = addr (substr (IS, line_start + 1));
	end;

	if ec_data_ptr = null ()
	then do;
		complain = com_err_;
		who = rtrim (abs_data.io_module_name);
	     end;
	else do;
		if codeptr (ec_data.error) = null () then
		     if ec_data.active_function
		     then complain = active_fnc_err_;
		     else complain = com_err_;
		else complain = ec_data.error;
		who = ec_data.who_am_i;
	     end;

	call complain (status, who, "^[^/^]^[Error^;Warning^] on line #^d of ^a:^/^a^/SOURCE:^-^a", status ^= 0,
	     severity, line_number, ec_path, message, line);

	if ^severity then return;

	if abs_data.noabort then do;
	     get_next_line = EXPAND_NEXT_LINE;
	     go to get_next_line;
	end;

	state = NORMAL;				/* Prevent looping if state is a MUST_BE state.		*/

	go to END_OF_FILE;

     end error;
%page;
%include abs_io_data;
%page;
%include abs_io_hash;
%page;
%include ec_data;
%page;
%include iocb;

     end abs_io_v1_get_line;
