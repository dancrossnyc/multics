/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        *                                                         *
        *********************************************************** */



/****^  HISTORY COMMENTS:
  1) change(86-03-13,Herbst), approve(86-04-17,MCR7376),
     audit(86-04-17,Kissel), install(86-04-22,MR12.0-1041):
     Fixed bug where &goto from &on unit was not resetting auto_in_handler_sw.
  2) change(87-02-20,Parisek), approve(87-07-23,MCR7716),
     audit(87-08-07,Fawcett), install(87-08-11,MR12.1-1080):
     If caller of exec_com_ is call_ec_ then turn on the exec_com_info.noabort
     flag for subsequent notification to subroutines to not abort after an
     ec severity 1 error.
  3) change(88-08-08,TLNguyen), approve(88-08-08,MCR7934),
     audit(88-08-26,Parisek), install(88-09-16,MR12.2-1111):
     Make the &exit statement and the &goto LABEL statement constructed within
     the &on unit work as documented.
  4) change(88-09-29,TLNguyen), approve(88-09-29,PBF7934),
     audit(88-09-29,Parisek), install(88-10-04,MR12.2-1128):
     Add the local turned_on_in_handler_sw flag in the invoke_handler
     internal procedure.  This flag is used to control how
     abs_data.in_handler_sw gets set/reset based on its current state
     (ie, ON if OFF; OFF if ON).  Remove setting/resetting of
     abs_data.in_handler_sw within the any_other handler.
                                                   END HISTORY COMMENTS */


/* format: off */

absentee_listen_:
     procedure (P_initial_command_line);

/* Initial coding: 25 June 1979 by J. Spencer Love */
/* Modified: 8 June 1980 by J. Spencer Love for exec_com_ and absentee_listen_ */
/* Added get_ec_version_ 07/28/81 S. Herbst */
/* Modified for new abs_io_, April 1982, E. N. Kittlitz */
/* Fixed get_ec_version_ to use uniquely-named IO switch 05/24/82 S. Herbst */
/* Changed wording of "not found using search list" message 07/26/82 S. Herbst */
/* Added $execute_handler and code to execute an &on unit 01/06/83 S. Herbst */
/* Fixed to turn off ec_data.input_line while executing handler 06/03/83 S. Herbst */
/* Fixed so that all entry points initialize "initialized" and "state" 10/05/83 S. Herbst */
/* Fixed to do a PL/1 nonlocal goto to parent ec's stack frame for &goto inside an &on unit 11/17/83 S. Herbst */
/* Fixed get_ec_version_ to return the right character position 11/30/83 S. Herbst */
/* Changed to support exec_com command control args -trace, -no_trace, -trace_default 03/22/84 S. Herbst */
/* Fixed $exec_com to initialize exec_com_info_ptr to null 08/10/84 S. Herbst */
/* Fixed $absentee_listen_ to set ec_info.switch_ptr = iox_$user_io instead of null 09/17/84 Steve Herbst */
/* Fixed &on any_other, ec_data.input_line="0"b executing cleanup handler 10/25/84 Steve Herbst */
/* Changed $absentee_listen_ to call listen_, which knows about release/start, etc. 12/03/84 Steve Herbst */
/* Changed all entry points to deal with release/start as listen_ does 12/07/84 Steve Herbst */
/* Commented out support for release/start except via $absentee_listen_ 12/12/84 Steve Herbst */
/* Fixed any_other handler to use auto recursion flag in case user_i/o detached 01/04/85 Steve Herbst */
/* Fixed bug where revert_output or discard_output turns off abs_data.in_handler_sw 01/14/85 Steve Herbst */


declare	P_abs_data_ptr		ptr parameter,
	P_caller			char (*) parameter,
	P_code			fixed bin (35) parameter,
	P_condition_info_ptr	ptr parameter,
	P_continue_to_signal_sw	bit (1) aligned parameter,
	P_dn			char (*) parameter,
	P_ec_info_ptr		ptr parameter,
	P_en			char (*) parameter,
	P_exec_com_info_ptr		ptr parameter,
	P_goto_label_len		fixed bin (21) parameter,
	P_goto_label_ptr		ptr parameter,
	P_handler_node_ptr		ptr parameter,
	P_initial_command_line	char (*) varying parameter,
	P_initial_string		char (*) parameter,
	P_pathname		char (*) parameter,
	P_search_list		char (*) parameter,
	P_search_name		char (*) parameter,
	P_subsystem_dir_ptr		ptr parameter,
	P_suffix			char (*) parameter,
	P_text_pos		fixed bin (21) parameter,
	P_version			fixed bin parameter;

declare	(addr, addrel, baseno, charno, clock, codeptr, copy, index, length, null, rtrim, stackframeptr, string, substr, unspec)
				builtin;

declare	(any_other, cleanup, stringsize)
				condition;

declare	auto_in_handler_sw		bit (1) aligned,	  /* to prevent looping of any_other handler */
	auto_cond_name		char (32);

declare	arg_count			fixed bin,
	arg_len			fixed bin (21),
	arg_ptr			ptr,
	arg			char (arg_len) based (arg_ptr),
	arg_list_ptr		ptr,
	actual_len		fixed bin (21),
	buffer			char (512),
	command_sw		bit (1) aligned,
	cond_name			char (32),
	continue_to_signal_sw	bit (1) aligned,
	entry_point_name		char (32),
	goto_label		char (goto_label_len) based (goto_label_ptr),
	goto_label_len		fixed bin (21),
	goto_label_ptr		ptr,
	handler_found_sw		bit (1) aligned,
	i			fixed bin,
	initialized		bit (1) aligned,
	p			ptr,
	path			char (168),
	path_arg_pos		fixed bin,
	read_len			fixed bin (21),
	read_ptr			ptr,
	ready_procedure		entry (1 aligned like ready_mode) variable,
	saved_abs_data_ptr		ptr,
	saved_in_handler_sw		bit (1),
	seg_ptr			ptr,
	spno			bit (18) aligned,
	state			fixed bin,
	status			fixed bin (35),
	X_status			fixed bin (35),
	whoami			char (32),
	work_len			fixed bin (21),
	work_ptr			ptr,
	work_string		char (work_len) based (work_ptr);

declare	1 listener_control		aligned like based_listener_control;

declare	1 ec_info			aligned like ec_data;

declare	1 trace_info		aligned like ec_trace_info;

declare   1 local_condition_info	aligned like condition_info;

declare	1 ready_mode		aligned,
	  2 flag			bit (1) unaligned,
	  2 pad			bit (35) unaligned;

declare   (TRACE_OFF init ("1"b),
	 TRACE_ON init ("0"b))	bit (1) int static options (constant);

declare	(
	IN_OUTER_PROC		init (0),
	IN_INITIALIZE_EC_INFO	init (1),
	IN_FIND_EC		init (-1)
	)			fixed bin int static options (constant);
declare	stream_input		fixed bin static options (constant) initial (1);

declare	(
	error_table_$badopt,
	error_table_$end_of_info,
	error_table_$long_record,
	error_table_$not_act_fnc,
	error_table_$pathlong
	)			fixed bin (35) external,
	iox_$user_io		ptr external,
	sys_info$max_seg_size	fixed bin (35) external;

dcl abs_io_$allocate_abs_data entry (ptr);
dcl abs_io_$initialize_abs_data entry (ptr);
dcl abs_io_v2_get_line$goto entry (ptr, ptr, char (*)) returns (fixed bin (35));
dcl absentee_listen_$execute_handler entry
	(ptr, ptr, ptr, ptr, ptr, ptr, fixed bin (21), bit (1) aligned, fixed bin (35));

declare	active_fnc_err_		entry options (variable),
	active_fnc_err_$af_suppress_name
				entry options (variable),
	com_err_			entry options (variable),
	com_err_$suppress_name	entry options (variable),
	continue_to_signal_		entry (fixed bin (35)),
	cu_$af_return_arg_rel	entry (fixed bin, ptr, fixed bin (21), fixed bin (35), ptr),
	cu_$arg_list_ptr		entry () returns (ptr),
	cu_$arg_ptr		entry (fixed bin, ptr, fixed bin (21), fixed bin (35)),
	cu_$arg_ptr_rel		entry (fixed bin, ptr, fixed bin (21), fixed bin (35), ptr),
	cu_$generate_call		entry (entry, ptr),
	cu_$cp			entry (ptr, fixed bin (21), fixed bin (35)),
	cu_$ready_proc		entry () options (variable),
	expand_pathname_$add_suffix	entry (char (*), char (*), char (*), char (*), fixed bin (35)),
	find_condition_info_	entry (ptr, ptr, fixed bin (35)),
	get_temp_segment_		entry (char (*), ptr, fixed bin (35)),
	iox_$attach_name		entry (char (*), ptr, char (*), ptr, fixed bin (35)),
	iox_$control		entry (ptr, char (*), ptr, fixed bin (35)),
	iox_$detach_iocb		entry (ptr, fixed bin (35)),
	iox_$destroy_iocb		entry (ptr, fixed bin (35)),
	iox_$find_iocb		entry (char (*), ptr, fixed bin (35)),
	iox_$get_line		entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35)),
	iox_$open			entry (ptr, fixed bin, bit (1) aligned, fixed bin (35)),
	release_temp_segment_	entry (char (*), ptr, fixed bin (35)),
	request_id_		entry (fixed bin (71)) returns (char (19)),
	requote_string_		entry (char (*)) returns (char (*)),
	signal_io_error_		entry (char (*), ptr, fixed bin (35)),
	unique_chars_		entry (bit (*)) returns (char (15));
%page;
/* Called by initialize_process_, this entry point is the listener for an absentee process. */

/* absentee_listen_:
   procedure (P_initial_command_line);								*/

	entry_point_name = "absentee_listen_";

	exec_com_info_ptr = null;
	state = IN_OUTER_PROC;			/* Tell cleanup handler we have nothing for it to do	*/
	initialized = "0"b;

	on cleanup call clean_up ();

	call initialize_ec_info ();

	ec_info.who_am_i, whoami = "Absentee facility";

	ec_info.switch_ptr = iox_$user_io;

	abs_data_ptr = ec_info.switch_ptr -> iocb.attach_data_ptr;
	initialized = "1"b;

	call iox_$control (iox_$user_io, "set_ec_data_ptr", addr (ec_info), status);
	if status ^= 0 then call complain (status, ec_info.who_am_i, "Setting ec data.");

	unspec (listener_control) = "0"b;
	listener_control.prev_ptr = null;
	listener_control.level = 1;
	sp = stackframeptr ();			/* count the stack frame number */
	spno = baseno (sp);
	i = 0;
	do while (baseno (sp -> stack_frame.prev_sp) = spno & sp ^= null);
	     i = i + 1;
	     sp = sp -> stack_frame.prev_sp;
	end;
	listener_control.frame = i;
	listener_control.release_all, listener_control.release, listener_control.new_release = RELEASE_LABEL;
	listener_control.start = START_LABEL;
	listen_static_data_.control_ptr = addr (listener_control);

	abs_data.listener_pl1_label, abs_data.get_line_pl1_label = CONTINUE;

	call cu_$cp (addrel (addr (P_initial_command_line), 1), length (P_initial_command_line), status);

	if status ^= 0 & status ^= 100 then call complain (status, ec_info.who_am_i, "Executing initial command line.");

	go to COMMON;
%page;
exec_com_:
     entry (P_pathname, P_initial_string, P_caller, P_exec_com_info_ptr, P_code);

	entry_point_name = "exec_com_";

	exec_com_info_ptr = P_exec_com_info_ptr;
	state = IN_OUTER_PROC;
	initialized = "0"b;

	on cleanup call clean_up;

	call initialize_ec_info ();

	if unspec (exec_com_info.error) ^= ""b & codeptr (exec_com_info.error) ^= null ()
	then ec_info.error = exec_com_info.error;
	if unspec (exec_com_info.eval_string) ^= ""b & codeptr (exec_com_info.eval_string) ^= null ()
	then ec_info.eval_string = exec_com_info.eval_string;
	if unspec (exec_com_info.execute_line) ^= ""b & codeptr (exec_com_info.execute_line) ^= null ()
	then ec_info.execute_line = exec_com_info.execute_line;
	if unspec (exec_com_info.ready) ^= ""b & codeptr (exec_com_info.ready) ^= null ()
	then ready_procedure = exec_com_info.ready;
	if unspec (exec_com_info.set_ready_mode) ^= ""b & codeptr (exec_com_info.set_ready_mode) ^= null ()
	then ec_info.set_ready_mode = exec_com_info.set_ready_mode;

	ec_info.call_ready_proc = "0"b;
	ec_info.who_am_i = P_caller;
	whoami = "exec_com_";

	call attach_ec ("ec_input_", P_pathname);

	initialized = "1"b;

	arg_list_ptr = exec_com_info.arg_list_ptr;

	call check_arg_list (exec_com_info.arg_list_ptr);

	call set_args (exec_com_info.first_arg);

	if ec_info.who_am_i = "call_ec_" then 
	     abs_data.switches.noabort = "1"b;
	else abs_data.switches.noabort = ""b;
	if codeptr (exec_com_info.execute_line) ^= null () & unspec (exec_com_info.execute_line) ^= ""b
	then call exec_com_info.execute_line (addr (P_initial_string), length (P_initial_string), status);
	else call cu_$cp (addr (P_initial_string), length (P_initial_string), status);

	if status ^= 0 & status ^= 100 then call complain (status, ec_info.who_am_i, "Executing initial command line.");

	abs_data.listener_pl1_label, abs_data.get_line_pl1_label = CONTINUE;

	go to COMMON;
%page;
exec_com:
ec:
     entry () options (variable);

	entry_point_name = "exec_com";

	exec_com_info_ptr = null;
	state = IN_OUTER_PROC;
	initialized = "0"b;

	on cleanup call clean_up ();

	call initialize_ec_info ();
	command_sw = "1"b;

	ec_info.set_ready_mode = set_ready_mode;
	ec_info.who_am_i, whoami = "exec_com";

	arg_list_ptr = cu_$arg_list_ptr ();

	call check_arg_list (arg_list_ptr);

	if arg_count < 1
	then do;
COMMAND_USAGE:
		if ec_info.active_function
		then call active_fnc_err_$af_suppress_name (0, whoami, "Usage:  [ec {-control_args} path {ec_args}]");
		else call com_err_$suppress_name (0, whoami, "Usage:  ec {-control_args} path {ec_args}");
		go to EGRESS;
	     end;

	path_arg_pos = 0;
	do i = 1 to arg_count while (path_arg_pos = 0);
	     call cu_$arg_ptr (i, arg_ptr, arg_len, (0));
	     if index (arg, "-") = 1 then do;
		if arg = "-no_trace" | arg = "-trace" then do;
		     i = i + 1;
		     if i > arg_count then do;
			call com_err_ (0, ec_info.who_am_i, "No value specified for ^a", arg);
			go to EGRESS;
		     end;
		end;
		else if arg = "-trace_default" then;
		else do;
		     call com_err_ (error_table_$badopt, ec_info.who_am_i, "^a", arg);
		     go to EGRESS;
		end;
	     end;
	     else path_arg_pos = i;
	end;

	if path_arg_pos = 0 then go to COMMAND_USAGE;

	call cu_$arg_ptr_rel (path_arg_pos, arg_ptr, arg_len, (0), arg_list_ptr);

	call attach_ec ("ec_input_", find_ec ("ec", "exec_com", null ()));

	initialized = "1"b;

	unspec (trace_info) = "0"b;

	do i = 1 to path_arg_pos - 1;
	     call cu_$arg_ptr (i, arg_ptr, arg_len, (0));
	     if index (arg, "-") = 1 then do;
		if arg = "-no_trace" then do;
		     i = i + 1;
		     call cu_$arg_ptr (i, arg_ptr, arg_len, (0));
		     call set_trace (TRACE_OFF, arg);
		end;
		else if arg = "-trace" then do;
		     i = i + 1;
		     call cu_$arg_ptr (i, arg_ptr, arg_len, (0));
		     call set_trace (TRACE_ON, arg);
		end;
		else if arg = "-trace_default" then unspec (trace_info) = "0"b;
	     end;
	end;

	call iox_$control (ec_info.switch_ptr, "set_trace", addr (trace_info), status);
	if status ^= 0 then call complain (status, ec_info.who_am_i, "Setting -trace information.");

	call set_args (path_arg_pos + 1);

	if ec_info.active_function then ec_info.call_ready_proc = "0"b;
	status = 100;				/* Suppress initial call to ready proc			*/

	abs_data.listener_pl1_label, abs_data.get_line_pl1_label = CONTINUE;

	go to COMMON;
%page;
execute_handler: entry (P_exec_com_info_ptr, P_ec_info_ptr, P_abs_data_ptr, P_handler_node_ptr,
		     P_condition_info_ptr, P_goto_label_ptr, P_goto_label_len, P_continue_to_signal_sw, P_code);

/* This entry point executes the text of an &on unit as if it were a separate exec_com, remembering whether it
   has exited by means of a nonlocal &goto */

	entry_point_name = "execute_handler";

	P_goto_label_ptr = null;

	state = IN_OUTER_PROC;
	initialized = "0"b;

	exec_com_info_ptr = P_exec_com_info_ptr;
	ec_info = P_ec_info_ptr -> ec_data;
	handler_node_ptr = P_handler_node_ptr;

/* Set up a new abs_data for executing the handler */

	abs_data_ptr = null;

	on cleanup call clean_up;

	call abs_io_$allocate_abs_data (abs_data_ptr);

	abs_data = P_abs_data_ptr -> abs_data;		/* will use some old information */

	abs_data.active = "0"b;

	call abs_io_$initialize_abs_data (abs_data_ptr);	/* and some new information */

	initialized = "1"b;

/* Set defaults for an &on handler */

	abs_data.io_module_name = "abs_io_";

	abs_data.input_string.ptr = handler_node.ptr;
	abs_data.input_string.len = handler_node.len;
	abs_data.input_string.start, abs_data.input_string.position = 1;
	abs_data.input_string.limit = 0;

	abs_data.active, abs_data.label_search_sw = "0"b;
	abs_data.command_line.on, abs_data.comment_line.on, abs_data.control_line.on, abs_data.input_line.on = "0"b;
	unspec (abs_data.if_info) = "0"b;
	abs_data.prev_if_ptr = null;
	unspec (abs_data.on_info) = "0"b;
	abs_data.cleanup_handler_ptr, abs_data.first_handler_ptr, abs_data.goto_label_ptr = null;

	abs_data.on_info.in_handler_sw = "1"b;
	abs_data.on_info.handler_node_ptr = P_handler_node_ptr;
	abs_data.on_info.condition_name = P_condition_info_ptr -> condition_info.condition_name;
	abs_data.on_info.mc_ptr = P_condition_info_ptr -> condition_info.mc_ptr;
	abs_data.on_info.info_ptr = P_condition_info_ptr -> condition_info.info_ptr;
	abs_data.on_info.wc_ptr = P_condition_info_ptr -> condition_info.wc_ptr;
	abs_data.on_info.was_attached_sw = (P_abs_data_ptr -> abs_data.attach.victim_ptr ^= null);

	abs_data.work_area = P_abs_data_ptr -> abs_data.work_area;  /* use the same area; copy it back when done */

	saved_abs_data_ptr, abs_data.on_info.parent_abs_data_ptr = ec_info.switch_ptr -> iocb.attach_data_ptr;
	ec_info.switch_ptr -> iocb.attach_data_ptr = abs_data_ptr;

	ec_info.call_ready_proc = "0"b;

	go to COMMON;
%page;
COMMON:

/* Handle all conditions. This is for the benefit of &on and, in the case of
   cleanup, for popping a listener level. */

	auto_in_handler_sw = "0"b;
	auto_cond_name = "";

	on any_other begin;

	     call find_condition_info_ (null, addr (local_condition_info), 0);
	     cond_name = local_condition_info.condition_name;

	     if cond_name = "cleanup" then do;	/* pop listener level */
		listen_static_data_.control_ptr =
		listen_static_data_.control_ptr -> based_listener_control.prev_ptr;
		if listen_static_data_.control_ptr = null then listen_static_data_.first_level_sw = "1"b;
	     end;

	     if ^auto_in_handler_sw | cond_name ^= auto_cond_name then do;  /* prevent looping */

		auto_in_handler_sw = "1"b;
		auto_cond_name = cond_name;

		continue_to_signal_sw = "1"b;		/* default if no handlers invoked */

		handler_found_sw = "0"b;

		p = abs_data.on_info.first_handler_ptr;
		do while (p ^= null);                   /* walk down to chain of handler nodes to find a matching condition name */

		     if p -> handler_node.condition_name = cond_name then do;
			handler_found_sw = "1"b;

			call invoke_handler (p);      /* execute the text of a specified condition handler (&on unit) */
		     end;
		     else p = p -> handler_node.next_ptr;
		end;

		if ^handler_found_sw then do;		/* look for an any_other handler */
		     p = abs_data.on_info.first_handler_ptr;
		     do while (p ^= null);
			if p -> handler_node.condition_name = "any_other" then do;
			     call invoke_handler (p);
			end;
			else p = p -> handler_node.next_ptr;
		     end;
		end;

		if continue_to_signal_sw then call continue_to_signal_ ((0));  /* very important! */

		auto_in_handler_sw = "0"b;
	     end;
	end;
%page;
LISTENER_LOOP:

/* The following routine reads lines from the input file and passes them on to the command processor. It communicates
   with abs_io_ through the attach_data block (it gets a pointer to this via a control order) in order to determine
   when command vs. input lines are being read and what the ready mode is.					*/

	do while ("1"b);
	     if ec_info.call_ready_proc & status ^= 100 then call invoke_ready_procedure ();

	     ec_info.input_line = "0"b;

	     read_ptr, work_ptr = addr (buffer);
	     read_len = length (buffer);
	     work_len = 0;
	     do while (status ^= 0 | work_len = 0);
		call iox_$get_line (ec_info.switch_ptr, read_ptr, read_len, actual_len, status);
		work_len = work_len + actual_len;
		if status ^= 0
		then if status = error_table_$end_of_info
		     then if work_len = 0
			then go to EGRESS;		/* all done */
			else status = 0;		/* abs_io_ wont do this, but if there is a partial line...	*/
		     else if status = error_table_$long_record & seg_ptr = null ()
		     then do;			/* too big; get a temp segment and put it there instead	*/
			     call get_temp_segment_ (whoami, seg_ptr, X_status);
			     if X_status ^= 0
			     then call complain (X_status, ec_info.who_am_i, "Getting temp segment.");
			     work_ptr = seg_ptr;
			     work_string = substr (buffer, 1, work_len);
			     read_ptr = addr (substr (work_string, work_len + 1));
			     read_len = (sys_info$max_seg_size * 4) - work_len;
			end;
		     else call signal_io_error_ ("Error while reading command line.", ec_info.switch_ptr, status);
	     end;

	     ec_info.input_line = "1"b;		/* anything read after this point is an input line	*/

	     saved_in_handler_sw = abs_data.in_handler_sw;  /* I don't know why, but a revert_output or
						     discard_output zeroes this flag! */
	     if codeptr (ec_info.execute_line) ^= null ()
	     then call ec_info.execute_line (work_ptr, work_len, status);
	     else call cu_$cp (work_ptr, work_len, status);

	     abs_data.in_handler_sw = saved_in_handler_sw;

CONTINUE:
	     if seg_ptr ^= null () then call release_temp_segment_ (whoami, seg_ptr, status);
	end;

	go to EGRESS;
%page;
RELEASE_LABEL:					/* transferred to by the release command */

	abs_data.active = "0"b;

	go to LISTENER_LOOP;




START_LABEL:					/* transferred to by the start command */

	listen_static_data_.control_ptr = listen_static_data_.control_ptr -> based_listener_control.prev_ptr;

	return;
%page;
get_ec_version_:
     entry (P_dn, P_en, P_version, P_text_pos, P_code);

/* Returns version number of ec and position of first character following the "&version N" stmt if any.
   Called by program that adds copyright notices to exec_com's. */

	state = IN_OUTER_PROC;
	initialized = "0"b;

	call initialize_ec_info ();

	on cleanup
	     begin;
		if ec_info.switch_ptr ^= null ()
		then do;
			call iox_$detach_iocb (ec_info.switch_ptr, (0));
			call iox_$destroy_iocb (ec_info.switch_ptr, (0));
		     end;
	     end;

	if P_dn = ">"
	then path = ">" || P_en;
	else path = rtrim (P_dn) || ">" || P_en;

	call iox_$attach_name (unique_chars_ ("0"b), ec_info.switch_ptr, "ec_input_ " || requote_string_ (rtrim (path)),
	     codeptr (exec_com), status);
	if status ^= 0
	then do;
		P_code = status;
		if ec_info.switch_ptr ^= null () then call iox_$destroy_iocb (ec_info.switch_ptr, (0));
		return;
	     end;

	abs_data_ptr = ec_info.switch_ptr -> iocb.attach_data_ptr;

	initialized = "1"b;

	P_version = abs_data.open_data.parser_version;
	P_text_pos = abs_data.input_string.start;
	if P_version = 1 then	  /* version 1 positions to newline after the "&version 1" */
	     P_text_pos = P_text_pos + 1;		/* user wants position of char after newline */
	P_code = 0;

	call iox_$detach_iocb (ec_info.switch_ptr, status);
	if status = 0 then call iox_$destroy_iocb (ec_info.switch_ptr, status);

	return;
%page;
invoke_handler: proc (P_node_ptr);

dcl P_node_ptr ptr;
dcl (goto_sw, saved_input_line_sw, turned_on_in_handler_sw) bit (1) aligned;

	saved_input_line_sw = ec_info.input_line;
	ec_info.input_line = "0"b;

	turned_on_in_handler_sw = "0"b;
	if ^abs_data.in_handler_sw then		/* turn on, if not already on */
	     abs_data.in_handler_sw, turned_on_in_handler_sw = "1"b;
	call absentee_listen_$execute_handler (exec_com_info_ptr, addr (ec_info), abs_data_ptr,
	     P_node_ptr, addr (local_condition_info), goto_label_ptr, goto_label_len,
	     continue_to_signal_sw, 0);

	if goto_label_ptr ^= null then do;
	     goto_sw = "1"b;
	     status = abs_io_v2_get_line$goto (abs_data_ptr, addr (ec_info), goto_label);
	     if status ^= 0 then go to EGRESS;
	end;
	else goto_sw = "0"b;

	ec_info.input_line = saved_input_line_sw;

	if turned_on_in_handler_sw then		/* only turn off, if we turned it on */
	     abs_data.in_handler_sw = "0"b;

	if goto_sw then do;
	     abs_data.active, auto_in_handler_sw = "0"b;

/* Implementing nonlocal &goto from inside an &on unit (handler). This is
   done by a PL/1 nonlocal goto so that interrupted actions are not continued.
   If the handler was invoked while in abs_io_v2_get_line, the target of the
   goto is that procedure's START: label, to process the &label statement.
   If the handler was invoked while inside cu_$cp (ec_info.input_line = "1"b),
   the target of the goto is absentee_listen_'s CONTINUE: label, to put us
   back in the listener loop. */

	     if ec_info.input_line then go to abs_data.listener_pl1_label;
	     else go to abs_data.get_line_pl1_label;
	end;

	P_node_ptr = null;				/* handler invoked; stop the caller's loop */

	return;

end invoke_handler;
%page;
invoke_ready_procedure:
     procedure ();

	if codeptr (ready_procedure) ^= null () then call ready_procedure (ready_mode);
						/* This case is for exec_com_, if given a value		*/

	else if command_sw then call cu_$ready_proc (ready_mode);
						/* This case is for the exec_com command		*/

	else call cu_$ready_proc ();			/* This case is for absentee, or exec_com_ default	*/

	return;

     end invoke_ready_procedure;



set_ready_mode:
     procedure (P_ready_mode);

declare	1 P_ready_mode		aligned like ready_mode;

	ready_mode = P_ready_mode;

	return;

     end set_ready_mode;
%page;
complain:
     procedure () options (variable);

declare	arg_list_ptr		ptr,
	based_status_ptr		ptr,
	based_status		fixed bin (35) based (based_status_ptr);

	arg_list_ptr = cu_$arg_list_ptr ();

	if state = IN_FIND_EC
	then do;					/* In exec_com_$find_ec.  Set return values and punt	*/
		P_pathname = "";
		call cu_$arg_ptr (1, based_status_ptr, (0), (0));
		P_code = based_status;
	     end;

	else if codeptr (ec_info.error) ^= null () then call cu_$generate_call (ec_info.error, arg_list_ptr);

	else if ec_info.active_function then call cu_$generate_call (active_fnc_err_, arg_list_ptr);
	else call cu_$generate_call (com_err_, arg_list_ptr);

	go to EGRESS;

     end complain;

EGRESS:
	call finish_up ();

	return;
%page;
clean_up:
     procedure ();

dcl saved_input_line_sw bit (1) aligned;

	saved_input_line_sw = ec_info.input_line;
	ec_info.input_line = "0"b;

	if initialized then
	  if abs_data.on_info.cleanup_handler_ptr ^= null then  /* there is an "&on cleanup" */
	    if abs_data.on_info.cleanup_handler_ptr -> handler_node.condition_name = "cleanup" then do;
						/* and it's not disabled by &resignal */

	     local_condition_info.condition_name = "cleanup";
	     local_condition_info.mc_ptr, local_condition_info.info_ptr, local_condition_info.wc_ptr = null;

	     call absentee_listen_$execute_handler (exec_com_info_ptr, addr (ec_info), abs_data_ptr,
		abs_data.on_info.cleanup_handler_ptr, addr (local_condition_info), null, 0, "0"b, 0);
						/* don't honor any nonlocal &goto inside it */

	end;

	ec_info.input_line = saved_input_line_sw;

	call finish_up ();

end clean_up;
%page;
finish_up: procedure ();

dcl goto_label char (abs_data.goto_label_len) based (abs_data.goto_label_ptr);
declare	status		fixed bin (35);
declare	iox_$close	entry (ptr, fixed bin (35));

	if state = IN_INITIALIZE_EC_INFO
	then do;					/* clean up after initialize_ec_info */

		if ec_info.switch_ptr ^= null & abs_data_ptr ^= null then
		     if ^abs_data.in_handler_sw then do;
			call iox_$control (ec_info.switch_ptr, "handle_cleanup", addr (ec_info), status);
			call iox_$close (ec_info.switch_ptr, status);
			call iox_$detach_iocb (ec_info.switch_ptr, status);
			call iox_$destroy_iocb (ec_info.switch_ptr, status);
		     end;

		if seg_ptr ^= null () then call release_temp_segment_ (whoami, seg_ptr, status);
	     end;

	if initialized then
	  if abs_data_ptr ^= null then
	     if entry_point_name = "execute_handler" then do;

		P_continue_to_signal_sw = abs_data.on_info.continue_to_signal_sw;

		if abs_data.goto_sw then do;		/* leaving &on unit via &goto */
						/* label must be allocated in parent's area */
		     allocate goto_label in (saved_abs_data_ptr -> abs_data.work_area)
			set (P_goto_label_ptr);	/* set args of absentee_listen_$execute_handler */
		     P_goto_label_ptr -> goto_label = abs_data.goto_label_ptr -> goto_label;
		     P_goto_label_len = abs_data.goto_label_len;

		     saved_abs_data_ptr -> abs_data.goto_statement_pos = abs_data.goto_statement_pos
			+ charno (abs_data.input_string.ptr)
			- charno (saved_abs_data_ptr -> abs_data.input_string.ptr);
		     saved_abs_data_ptr -> abs_data.goto_statement_len = abs_data.goto_statement_len;
		end;

		saved_abs_data_ptr -> abs_data.output_file = abs_data.output_file;
		saved_abs_data_ptr -> abs_data.variables_ptr = abs_data.variables_ptr;

		free abs_data;			/* free the &on unit's private abs_data */
						/* and restore the parent's: */

		abs_data_ptr, ec_info.switch_ptr -> attach_data_ptr = saved_abs_data_ptr;
	     end;

	return;

end finish_up;
%page;
initialize_ec_info:
     procedure ();

declare	null_entry_value		entry variable;

	unspec (null_entry_value) = copy (unspec (null ()), 2);
	ready_procedure = null_entry_value;
	string (ready_mode) = ""b;
	command_sw = "0"b;

	seg_ptr = null ();

	ec_info.version_id = ec_data_version_id;
	ec_info.version = ec_data_version_1;
	ec_info.active_function = "0"b;
	ec_info.return_len = 0;
	ec_info.return_ptr = null ();
	ec_info.execute_line = null_entry_value;
	ec_info.eval_string = null_entry_value;
	ec_info.set_ready_mode = null_entry_value;
	ec_info.error = null_entry_value;
	ec_info.switch_ptr = null ();
	ec_info.id_string = request_id_ (clock ());
	ec_info.input_line = "1"b;
	ec_info.call_ready_proc = "1"b;

	abs_data_ptr = null;

	state = IN_INITIALIZE_EC_INFO;

	return;

     end initialize_ec_info;
%page;
attach_ec:
     procedure (P_switch_name, P_path);

dcl (P_switch_name, P_path) char (*);
declare	code			fixed bin (35);
declare	sub_error_		condition;

	condition_info_ptr = addr (local_condition_info);

	on sub_error_
	     begin;
		call find_condition_info_ (null (), condition_info_ptr, code);
		if code = 0
		then do;
			sub_error_info_ptr = condition_info.info_ptr;
			call complain (sub_error_info.status_code, ec_info.who_am_i, "^a",
			     sub_error_info.info_string);
		     end;
		else call continue_to_signal_ ((0));
	     end;

	call iox_$attach_name (ec_info.id_string || "." || rtrim (whoami), ec_info.switch_ptr,
	     rtrim (P_switch_name) || " " || requote_string_ (rtrim (P_path)),
	     codeptr (exec_com) /* Pick up bound-in version by default */, status);

	if status ^= 0 then call complain (status, ec_info.who_am_i, "Attaching ^a.", P_path);

	call iox_$open (ec_info.switch_ptr, stream_input, "0"b, status);
	if status ^= 0 then call complain (status, ec_info.who_am_i, "Opening ^a.", P_path);

	revert sub_error_;

	call iox_$control (ec_info.switch_ptr, "set_ec_data_ptr", addr (ec_info), status);
	if status ^= 0 then call complain (status, ec_info.who_am_i, "Setting ec data.");

	abs_data_ptr = ec_info.switch_ptr -> iocb.attach_data_ptr;

	return;

     end attach_ec;
%page;
check_arg_list:
     procedure (P_arg_list_ptr);

declare	P_arg_list_ptr		ptr;

	call cu_$af_return_arg_rel (arg_count, ec_info.return_ptr, ec_info.return_len, status, P_arg_list_ptr);
	if status = 0 then ec_info.active_function = "1"b;
	else if status ^= error_table_$not_act_fnc
	then call complain (status, ec_info.who_am_i, "Getting argument list.");

	return;

     end check_arg_list;



set_args:
     procedure (first_arg);

declare	(first_arg, args_index, i)	fixed bin;

declare	1 args			aligned,		/* adjustable automatic storage			*/
	  2 count			fixed bin,
	  2 e			(arg_count - first_arg + 1),
	    3 ptr			ptr unaligned,
	    3 len			fixed bin (21);

	args.count = arg_count - first_arg + 1;
	args_index = 0;

	do i = first_arg to arg_count;
	     call cu_$arg_ptr_rel (i, arg_ptr, arg_len, status, arg_list_ptr);
	     args_index = args_index + 1;
	     args (args_index).ptr = arg_ptr;
	     args (args_index).len = arg_len;
	end;

	call iox_$control (ec_info.switch_ptr, "set_argument_ptrs", addr (args), status);
	if status ^= 0 then call complain (status, ec_info.who_am_i, "Setting arguments.");

	return;

     end set_args;
%page;
exec_com_$find_ec:
     entry (P_search_name, P_suffix, P_search_list, P_subsystem_dir_ptr, P_pathname, P_code);

	state = IN_FIND_EC;				/* Tell complain that we are find_ec			*/
	initialized = "0"b;

	arg_ptr = addr (P_search_name);		/* find_ec uses based variable "arg" as input		*/
	arg_len = length (rtrim (P_search_name));

	on stringsize go to PATHNAME_TOO_LONG;		/* Complain if "returns (char (*))" result too big	*/

(stringsize):
	P_pathname = find_ec (P_suffix, P_search_list, P_subsystem_dir_ptr);
	P_code = 0;				/* find_ec aborted through complain if it failed */

	return;

PATHNAME_TOO_LONG:
	P_pathname = "";
	P_code = error_table_$pathlong;

	return;
%page;
find_ec:
     procedure (suffix, search_list, subsystem_dir_ptr) returns (char (*));

declare	suffix			char (*) parameter,
	search_list		char (*) parameter,
	subsystem_dir_ptr		ptr parameter;

declare	(length, null, reverse, rtrim, search)
				builtin;

declare	dirname			char (168),
	entryname			char (32),
	entryname_len		fixed bin (21),
	must_search		bit (1) aligned,
	path_len			fixed bin (21),
	path			char (path_len) based (arg_ptr),
	pathname			char (169 + arg_len) varying,
	search_dirname		char (168),
	subsystem_dir		char (168);

declare	(
	error_table_$badpath,
	error_table_$no_search_list
	)			fixed bin (35) external;

declare	hcs_$fs_get_path_name	entry (ptr, char (*), fixed bin, char (*), fixed bin (35)),
	search_paths_$find_dir	entry (char (*), ptr, char (*), char (*), char (*), fixed bin (35));


	must_search = "0"b;
	path_len = arg_len;

	entryname_len = search (reverse (arg), "<>") - 1;
	if entryname_len < 0
	then do;
		entryname_len = arg_len;
		if search_list ^= "" then must_search = "1"b;
	     end;
	else if entryname_len = 0
	then call complain (error_table_$badpath, ec_info.who_am_i, "No file name given.  ^a", arg);

	call expand_pathname_$add_suffix (path, suffix, dirname, entryname, status);
	if status ^= 0 then call complain (status, ec_info.who_am_i, "^a", path);

	if must_search
	then do;
		if subsystem_dir_ptr = null ()
		then subsystem_dir = "";
		else do;
			call hcs_$fs_get_path_name (subsystem_dir_ptr, subsystem_dir, (0), (""), status);
			if status ^= 0 then subsystem_dir = "";
		     end;

		call search_paths_$find_dir (search_list, null (), entryname, subsystem_dir, search_dirname, status);
		if status = 0 then dirname = search_dirname;
		else if status ^= error_table_$no_search_list
		then call complain (status, ec_info.who_am_i, "^a using ^a search list.", entryname, search_list);
	     end;

	pathname = rtrim (dirname);
	if length (pathname) ^= 1 then pathname = pathname || ">";
	pathname = pathname || entryname;

	return (pathname);

     end find_ec;
%page;
set_trace: proc (P_off_sw, P_str);

/* Parses list of trace terms separated by commas and does the work. */

dcl P_off_sw bit (1);
dcl P_str char (*);
dcl (i, str_len) fixed bin (21);
dcl 1 tracing,
   2 types,
    3 (command, comment, control, input) bit (1) unaligned,
   2 (on, off, output_switch, prefix_sw) bit (1) unaligned,
   2 expand fixed bin,
   2 prefix char (32) varying,
   2 iocb ptr;

	unspec (tracing) = "0"b;

	str_len = length (P_str);
begin;
dcl buffer char (str_len) varying;

	buffer = P_str;
	do while (buffer ^= "");
	     i = index (buffer, ",");
	     if i = 0 then do;
		call set_term (P_off_sw, (buffer));
		buffer = "";
	     end;
	     else do;
		call set_term (P_off_sw, substr (buffer, 1, i - 1));
		buffer = substr (buffer, i + 1);
	     end;
	end;

	if ^tracing.on & ^tracing.off then tracing.on = "1"b;

	if unspec (tracing.types) = "0"b then unspec (tracing.types) = "1111"b;

	if tracing.command then call set_one_trace (trace_info.command_line, "COMMAND");
	if tracing.input then call set_one_trace (trace_info.input_line, "INPUT");
	if tracing.control then call set_one_trace (trace_info.control_line, "CONTROL");
	if tracing.comment then call set_one_trace (trace_info.comment_line, "COMMENT");
end;

	return;


set_one_trace: proc (P_line, P_type);

dcl 1 P_line aligned like ec_trace_info.command_line;
dcl P_type char (*);

	P_line.explicit_sw = "1"b;

	if tracing.on then do;
	     P_line.on = "1"b;
	     if P_line.expand = 0 then		/* apply defaults for expansion tracing */
		if abs_data.absentee then P_line.expand = EXPANDED;
		else if P_type = "COMMENT" | P_type = "CONTROL" then P_line.expand = UNEXPANDED;
		else P_line.expand = EXPANDED;
	end;
	if tracing.off then P_line.on = "0"b;
	if tracing.expand ^= 0 then P_line.expand = tracing.expand;
	if tracing.prefix_sw then P_line.prefix = tracing.prefix;
	if tracing.output_switch then P_line.iocb = tracing.iocb;

end set_one_trace;
%page;
/* More procs internal to set_trace */

set_term: proc (P_off_sw, P_str);

/* Handles a single trace keyword or keyword pair ("prefix=STR"). */

dcl P_off_sw bit (1);
dcl P_str char (*);
dcl i fixed bin;

	i = index (P_str, "=");
	if i ^= 0 then call set_keyword (P_off_sw, substr (P_str, 1, i - 1), "1"b, substr (P_str, i + 1));
	else call set_keyword (P_off_sw, P_str, "0"b, "");

	return;


set_keyword: proc (P_off_sw, P_keyword, P_value_sw, P_value);

/* Does the work for a single trace keyword or keyword pair. */

dcl (P_off_sw, P_value_sw) bit (1);
dcl (P_keyword, P_value) char (*);

	if P_keyword = "command" then
	     if P_value_sw then do;
BAD_TRACE_SYNTAX:
		call complain (0, ec_info.who_am_i, "Syntax error in argument to -^[no_^]trace", P_off_sw);
		go to EGRESS;
	     end;
	     else tracing.command = "1"b;
	else if P_keyword = "comment" then
	     if P_value_sw then go to BAD_TRACE_SYNTAX;
	     else tracing.comment = "1"b;
	else if P_keyword = "control" then
	     if P_value_sw then go to BAD_TRACE_SYNTAX;
	     else tracing.control = "1"b;
	else if P_keyword = "input" then
	     if P_value_sw then go to BAD_TRACE_SYNTAX;
	     else tracing.input = "1"b;
	else if P_keyword = "all_types" then
	     if P_value_sw then go to BAD_TRACE_SYNTAX;
	     else tracing.command, tracing.comment, tracing.control, tracing.input = "1"b;

	else if P_off_sw | open_data.parser_version <= 1 then do;
	     call complain (0, ec_info.who_am_i, "Invalid keyword specified for ^[-no_^]trace", P_off_sw);
	     go to EGRESS;
	end;

	if P_keyword = "command" | P_keyword = "comment" | P_keyword = "control" | P_keyword = "input" then do;
	     if P_off_sw then tracing.off = "1"b;
	end;

	else if P_keyword = "unexpanded" then
	     if P_value_sw then go to BAD_TRACE_SYNTAX;
	     else if abs_data.parser_version = 1 then do;
BAD_V1_TRACE_MODE:
		call complain (0, ec_info.who_am_i, "Invalid trace mode ""^a"" for a Version 1 ec.", P_keyword);
		go to EGRESS;
	     end;
	     else tracing.expand = UNEXPANDED;
	else if P_keyword = "expanded" then
	     if P_value_sw then go to BAD_TRACE_SYNTAX;
	     else if abs_data.parser_version = 1 then go to BAD_V1_TRACE_MODE;
	     else tracing.expand = EXPANDED;
	else if P_keyword = "all" | P_keyword = "all_expansions" then
	     if P_value_sw then go to BAD_TRACE_SYNTAX;
	     else if abs_data.parser_version = 1 then go to BAD_V1_TRACE_MODE;
	     else tracing.expand = ALL;
	else if P_keyword = "both" then
	     if P_value_sw then go to BAD_TRACE_SYNTAX;
	     else if abs_data.parser_version = 1 then go to BAD_V1_TRACE_MODE;
	     else tracing.expand = BOTH;

	else if P_keyword = "prefix" then
	     if ^P_value_sw then go to BAD_TRACE_SYNTAX;
	     else if abs_data.parser_version = 1 then go to BAD_V1_TRACE_MODE;
	     else do;
		tracing.prefix_sw = "1"b;
		tracing.prefix = P_value;
	     end;

	else if P_keyword = "output_switch" | P_keyword = "osw" then
	     if ^P_value_sw then go to BAD_TRACE_SYNTAX;
	     else if abs_data.parser_version = 1 then go to BAD_V1_TRACE_MODE;
	     else do;
		call iox_$find_iocb (P_value, tracing.iocb, status);
		if status ^= 0 then do;
		     call complain (status, ec_info.who_am_i, "Finding I/O switch ""^a""", P_value);
		     go to EGRESS;
		end;
		tracing.output_switch = "1"b;
	     end;

	else do;
	     call complain (0, ec_info.who_am_i, "Invalid -^[no_^]trace keyword ^a", P_off_sw, P_keyword);
	     go to EGRESS;
	end;

end set_keyword;

end set_term;

end set_trace;
%page;
%include abs_io_data;
%page;
%include abs_io_handler_node;
%page;
%include condition_info;
%page;
%include condition_info_header;
%page;
%include ec_data;
%page;
%include ec_trace_info;
%page;
%include exec_com_info;
%page;
%include iocb;
%page;
%include listener_info;
%page;
%include stack_frame;
%page;
%include sub_error_info;


end absentee_listen_;
