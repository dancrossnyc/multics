/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1987                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(86-03-13,Herbst), approve(86-04-17,MCR7376),
     audit(86-04-17,Kissel), install(86-04-22,MR12.0-1041):
     Fixed bug causing extra null arg for "&||[af_returning_null_string]".
  2) change(86-04-23,Herbst), approve(86-04-23,MCR7376),
     audit(86-04-25,Kissel), install(86-04-29,MR12.0-1041):
     Fixed to consider open and closed parens inside a quoted string as literal
     characters unless a ")" closes a "&(" since variable references &(...) are
     expanded even in quoted strings. Did the same for brackets and "&[".
  3) change(86-04-30,Herbst), approve(86-04-30,MCR7376),
     audit(86-04-30,Kissel), install(86-05-01,MR12.0-1052):
     Fixed ")" inside quoted string to close &q(1) as well as &(foo).
  4) change(86-05-22,Herbst), approve(86-05-22,MCR7376),
     audit(86-05-16,Kissel), install(86-05-22,MR12.0-1058):
     Backed out previous changes to () and [] handling recognizing that all
     except &() and &[] should be ignored by exec_com itself.
  5) change(87-02-16,Parisek), approve(87-07-23,MCR7716),
     audit(87-08-07,Fawcett), install(87-08-11,MR12.1-1080):
     If abs_data.noabort is ON then update next statement data.
  6) change(87-08-18,Parisek), approve(87-08-18,PBF7716),
     audit(87-09-03,Farley), install(87-09-10,MR12.1-1104):
     Conditionally get next ec statement when noabort flag is on.
  7) change(89-12-04,LZimmerman), approve(89-12-04,MCR8145),
     audit(89-12-08,Kallstrom), install(90-05-17,MR12.4-1009):
     Add literal &CR.
                                                   END HISTORY COMMENTS */


/* format: off */

abs_io_expand_: proc (A_xd, A_code);

/* Written 09/05/80 by Steve Herbst */

/* Fixed to return blank lines 10/07/81 S. Herbst */
/* Changed &set to see quotes, added &r(var) etc., added &print_switch{_nnl} 10/20/81 S. Herbst */
/* Fixed &q(1) bug, &then&quit bug 02/04/82 S. Herbst */
/* Modified: 16 February 1982 by G. Palter to call ec_data.eval_string when appropriate */
/* Fixed it to handle &ready_proc (as well as &ready), and reject &thenquit but not &then&quit 03/24/82 S. Herbst */
/* Fixed &if-&then-&else to be impervious to recursive get_line 04/20/82 S. Herbst */
/* Removed 1000-char limit on &[...] strings 06/01/82 S. Herbst */
/* Fixed to ignore trailing white space 07/08/82 S. Herbst */
/* Sped up the label search, changed to use addcharno 10/06/82 S. Herbst */
/* Fixed &set foo "" and arg parsing with <SP><NL>&+ 12/07/82 */
/* Fixed &+ continuation interrupted by one or more comment lines 12/14/82 S. Herbst */
/* Fixed fault taken parsing white space 01/03/83 S. Herbst */
/* Fixed get_next_statement to skip leading white space on line after &-comment 02/07/83 S. Herbst */
/* Fixed not to skip every other blank line 02/10/83 S. Herbst */
/* Fixed to skip trailing white space before returning, to distinguish it from blank line 02/24/83 S. Herbst */
/* Fixed to not rtrim variable values 03/01/83 S. Herbst */
/* Fixed to handle &then || NL || &+ 03/07/83 S. Herbst */
/* Added keywords &on, &begin, &revert, etc. 04/07/83 S. Herbst */
/* Changed to look at abs_data.trim_whitespace_sw for input lines (&attach &trim off) 06/02/83 S. Herbst */
/* Added &list_variables (&lsv) 06/07/83 S. Herbst */
/* Fixed to recognize &"" as a null string arg, as in: &set a &"" b &"" 11/18/83 S. Herbst */
/* Fixed bug making it possible to overflow allocated region for expansion 12/28/83 S. Herbst */
/* Fixed expansion bug caused by freeing allocated buffer used by pushed state 01/24/84 S. Herbst */
/* Fixed to allocate variables in abs_data.work_area, not system free area 05/16/84 S. Herbst */
/* Fixed to preserve &"" and "" as null arguments 07/18/84 S. Herbst */
/* Fixed to accept &end on same line as handler text 08/10/84 S. Herbst */
/* Fixed to compute quotes for &r and &q correctly when nested inside parens 08/14/84 S. Herbst */
/* Fixed to ignore mismatch of non-ec parentheses, as in (...) 08/20/84 S. Herbst */
/* Fixed bug causing extra null arg parsing 'one &[string " two"]' 08/20/84 S. Herbst */


dcl 1 state,
   2 keyword,
    3 name char (32) varying,
    3 number fixed bin,
    3 paren_sw bit (1) unaligned,
    3 bracket_sw bit (1) unaligned,
    3 af_type fixed bin,
    3 name_switches unaligned,
     4 control_word_sw bit (1),
     4 allow_arg_sw bit (1),
     4 require_arg_sw bit (1),
     4 require_number_sw bit (1),
     4 digit_arg_sw bit (1),
    3 param_switches,
     4 f_sw bit (1),
     4 n_sw bit (1),
     4 q_sw bit (1),
     4 r_sw bit (1),
   2 quote_factor fixed bin,				/* 2**(quote depth up to state.qscan_start)-1 for doubling */
   2 qscan_start fixed bin (21),
   2 iafter_pos fixed bin (21),			/* for tracing */
   2 optr_len,
    3 optr ptr,
    3 omax_len fixed bin (21),
    3 olen fixed bin (21),
    3 opos fixed bin (21);

dcl 1 state_stack (100) like state;


dcl 1 alloc_info aligned,				/* for allocating long lines */
   2 allocated_sw bit (1) aligned,
   2 alloc_ptr ptr,
   2 alloc_len fixed bin (21);

dcl 1 alloc_stack (100) aligned,
   2 allocated_sw_stack bit (1) aligned,
   2 alloc_ptr_stack ptr,
   2 alloc_len_stack fixed bin (21);
%page;
dcl 1 PARAM_KEYWORD int static options (constant),
   2 name char (32) varying init ("&"),
   2 number fixed bin init (1),
   2 paren_sw bit (1) unaligned init ("0"b),
   2 bracket_sw bit (1) unaligned init ("0"b),
   2 af_type fixed bin init (0),
   2 name_switches unaligned,
    3 control_word_sw bit (1) init ("0"b),
    3 allow_arg_sw bit (1) init ("1"b),
    3 require_arg_sw bit (1) init ("1"b),
    3 require_number_sw bit (1) init ("1"b),
    3 digit_arg_sw bit (1) init ("0"b),
   2 param_switches unaligned,
    3 f_sw bit (1) init ("0"b),
    3 n_sw bit (1) init ("0"b),
    3 q_sw bit (1) init ("0"b),
    3 r_sw bit (1) init ("0"b);


dcl (A_pos, A_len) fixed bin (21);			/* for $expand_label */
dcl A_label_val_ptr ptr;				/* for $expand_label */
dcl A_label_val_len fixed bin (21);			/* for $expand_label */
dcl A_vars_ptr ptr;					/* for $set */
dcl (A_var, A_val) char (*);				/* for $set */
dcl A_code fixed bin (35);

dcl 1 A_xd aligned like expand_data;
%page;
/* Based */

dcl xd_area area based (A_xd.area_ptr);

dcl 1 iptr_len,
   2 iptr ptr,
   2 ilen fixed bin (21),
   2 ipos fixed bin (21);

dcl input_overlay char (overlay_len) based (overlay_ptr);
dcl input char (ilen) based (iptr);
dcl output char (state.olen) based (state.optr);
dcl saved_arg char (saved_arg_len) varying based (saved_arg_ptr);


dcl alloc_string char (alloc_len) based (alloc_ptr);
dcl allocated_buffer char (A_xd.allocated_buffer_len) based (A_xd.allocated_ptr);
dcl caller_buffer char (A_xd.caller_buffer_len) based (A_xd.caller_buffer_ptr);


dcl 1 command_args (command_args_count) based (command_args_ptr),
   2 ptr ptr,
   2 len fixed bin (21),
   2 quote_count fixed bin (21);
dcl command_arg char (command_args (arg_index).len) based (command_args (arg_index).ptr);

dcl ec_name char (arg_info.ec_name_len) based (arg_info.ec_name_ptr);
dcl ec_path char (arg_info.ec_path_len) based (arg_info.ec_path_ptr);

dcl parsed_arg char (parsed_args.len (parsed_arg_index)) based (parsed_args.ptr (parsed_arg_index));


/* Constants */

dcl TF (0:1) char (8) varying int static options (constant) init ("false", "true");
dcl DEFAULT_ARG char (1) int static options (constant) init ("
");						/* no arg specified to a keyword */
dcl (CONTROL init ("1"b), NONCONTROL init ("0"b)) bit (1) int static options (constant);
dcl (QDOUBLE init ("0"b), REQUOTE init ("1"b)) bit (1) int static options (constant);
dcl UNDEFINED fixed bin int static options (constant) init (-1);
dcl (BK_TYPE init (1), BAR_BK_TYPE init (2), BAR_BAR_BK_TYPE init (3)) fixed bin int static options (constant);
dcl (PARAM_REF init (1), VAR_REF init (2), AF_REF init (3), MAX_KEY init (100)) fixed bin int static options (constant);

dcl DIGITS char (10) int static options (constant) init ("0123456789");
dcl ALPHA char (27) int static options (constant) init ("abcdefghijklmnopqrstuvwxyz_");
dcl DELIMS char (4) int static options (constant) init ("() 	");
dcl SP char (1) int static options (constant) init (" ");
dcl HT char (1) int static options (constant) init ("	");
dcl BS char (1) int static options (constant) init ("");
dcl NL char (1) int static options (constant) init ("
");
dcl VT char (1) int static options (constant) init ("");
dcl FF char (1) int static options (constant) init ("");
dcl CR char (1) int static options (constant) init ("
");

/* The control statement keywords */
/* NOTE: Do not change this array without changing the ACTION() and SKIP() labels in abs_io_v2_get_line */
/*	Also change abs_io_v2_get_line vars ELSE_ACTION, IF_ACTION, and THEN_ACTION */

dcl STMTS_STRING char (STMTS_LEN) aligned based (addr (STMTS));
dcl STMTS (39) char (32) aligned int static options (constant) init
	("&attach",	"&begin",		"&call",		"&default",	"&detach",
	 "&do",		"&else",		"&end",		"&exit",		"&entry",
	 "&function",	"&goto",		"&if",		"&label",		"&leave",
	 "&list_variables",	"&lsv",		"&on",		"&print",		"&print_nnl",
	 "&print_switch",	"&print_switch_nnl","&procedure",	"&proc",		"&quit",
	 "&ready",	"&ready_mode",	"&ready_proc",	"&repeat",	""/*"&resignal*/,
	 "&return",	"&revert",	"&set",		"&signal",	"&then",
	 "&trace",	"&until",		"&version",	"&while");

dcl STMT_SWITCHES (39) bit (3) int static options (constant) init
						/* parse_args, no_args, then_else_allowed */
	("100"b,		"110"b,		"100"b,		"100"b,		"100"b,
	 "110"b,		"010"b,		"110"b,		"100"b,		"100"b,
	 "100"b,		"000"b,		"001"b,		"000"b,		"100"b,
	 "100"b,		"100"b,		"100"b,		"000"b,		"000"b,
	 "000"b,		"000"b,		"100"b,		"100"b,		"010"b,
	 "100"b,		"100"b,		"100"b,		"100"b,		"100"b,
	 "000"b,		"100"b,		"100"b,		"000"b,		"011"b,
	 "100"b,		"100"b,		"100"b,		"100"b);

dcl 1 STMT_SW_OVERLAY (39) based (addr (STMT_SWITCHES)),
   2 (PARSE_ARGS_SW, NO_ARGS_SW, THEN_ELSE_ALLOWED_SW) bit (1) unaligned;

/* The expandable keywords */
/* NOTE: Do not change this array without changing the labels in expand internal procedure */

dcl NAMES_STRING char (NAMES_LEN) aligned based (addr (NAMES));
dcl NAMES (38) char (32) aligned int static options (constant) init
	("&condition_info_ptr",  "&cond_info_ptr",  "&condition_name",  "&cond_name",	"&ec_dir",
	 "&ec_name",	"&ec_path",	"&ec_switch",	"&handlers",	"&in_handler",
	 "&is_absin",	"&is_active_function",  "&is_af",	"&is_attached",	"&is_defined",
	 "&is_input_line",	"&n",		""/*&quote*/,	""/*&requote*/,	""/*&unquote*/,
	 "&was_attached",	"&AMP",		"&BS",		"&CR",		"&FF",
	"&HT",		"&LF",		"&NL",		"&NP",		"&QT",
	"&SP",		"&VT",		"&begin",		"&do",		"&else",
	"&end",		"&if",		"&then");

dcl NAME_SWITCHES (38) bit (5) int static options (constant) init
					/* control_wd, allow_arg, require_arg, require_num, digit_ok (params) */
(	"00000"b,		"00000"b,		"00000"b,		"00000"b,		"00000"b,
	"00000"b,		"00000"b,		"00000"b,		"00000"b,		"00000"b,
	"00000"b,		"00000"b,		"00000"b,		"00000"b,		"01100"b,
	"00000"b,		"00000"b,		"01100"b,		"01100"b,		"01100"b,
	"00000"b,		"01010"b,		"01010"b,		"01010"b,		"01010"b,
	"01010"b,		"01010"b,		"01010"b,		"01010"b,		"01010"b,
	"01010"b,		"01010"b,		"10000"b,		"10000"b,		"10000"b,
	"10000"b,		"10000"b,		"10000"b);

/* The &words not to be expanded (stmt control-args) */

dcl DONT_EXPAND_STRING char (DONT_EXPAND_LEN) aligned based (addr (DONT_EXPAND));
dcl DONT_EXPAND (22) char (32) aligned int static options (constant) init
	("&all", "&both", "&command", "&comment", "&continue", "&control", "&ex", "&exclude", "&expanded",
	 "&input", "&match", "&osw", "&output_switch", "&prefix", "&trim", "&undef", "&undefined",
	 "&unexpanded", "&val", "&value", "&var", "&variable");

/* The parameter prefixes */

dcl PARAMS_STRING char (PARAMS_LEN) aligned based (addr (PARAMS));
dcl PARAMS (10) char (8) aligned int static options (constant) init
	("&q", "&qf", "&q&n", "&qf&n",
	 "&r", "&rf", "&r&n", "&rf&n",
	 "&f", "&f&n");
dcl PARAM_SWITCHES (10) bit (4) int static options (constant) init  /* f, n, q, r */
	("0010"b, "1010"b, "0110"b, "1110"b,
	 "0001"b, "1001"b, "0101"b, "1101"b,
	 "1000"b, "1100"b);

/* Static */

dcl WHITE char (4) int static;			/* to be initialized to SP || HT || VT || FF */
dcl init_sw bit (1) int static init ("0"b);
dcl MAX_CHARS fixed bin (21) int static options (constant) init (261120 * 4);  /* max chars in a seg */
dcl (DONT_EXPAND_LEN, NAMES_LEN, PARAMS_LEN, STMTS_LEN) fixed bin int static;
dcl (ELSE_ACTION, IF_ACTION, SET_ACTION, THEN_ACTION) fixed bin int static;


/* Automatic */

dcl 1 trace aligned like abs_data.command_line;

dcl (auto_saved_arg, trace_buffer) char (1000) varying;
dcl search_chars char (12) varying;
dcl tf_string char (8) varying;

dcl char5 char (5);
dcl char3 char (3);
dcl char2 char (2);
dcl (next_char, next_next_char, searched_char) char (1);

dcl (added_arg_inside_quotes_sw, control_line_sw, delete_sw, eof_sw, expand_label_sw, found_sw) bit (1);
dcl (got_next_stmt, inside_quotes_sw, label_search_sw, no_args_sw, null_arg_sw, parse_args_sw, saved_arg_allocated_sw) bit (1);
dcl (skip_sw, then_else_allowed_sw, trace_sw) bit (1);

dcl (command_args_ptr, overlay_ptr, saved_arg_ptr) ptr;

dcl (arg_index, arg_limit, arg_max, arg_start, command_args_count, nest_level, parsed_arg_index) fixed bin;
dcl (i, istart, j, no_args_ipos, overlay_len, saved_arg_len, saved_ilen, saved_ipos, skip_count) fixed (21);
dcl (temp_i, temp_istart, temp_white_len, white_len) fixed bin (21);
dcl ic (6) fixed bin (21);
dcl code fixed bin (35);

dcl error_table_$badsyntax fixed bin (35) ext;
dcl error_table_$command_line_overflow fixed bin (35) ext;
dcl error_table_$end_of_info fixed bin (35) ext;
dcl error_table_$oldnamerr fixed bin (35) ext;

dcl iox_$user_output ptr ext;

dcl cu_$evaluate_active_string entry (ptr, char (*), fixed bin, char (*) varying, fixed bin (35));
dcl cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin);
dcl get_system_free_area_ entry returns (ptr);
dcl hcs_$fs_get_path_name entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
dcl (ioa_$ioa_switch_nnl, ioa_$rsnnl) entry options (variable);
dcl requote_string_ entry (char(*)) returns(char(*));
dcl unique_chars_ entry (bit (*)) returns (char (15));
dcl value_$defined entry (ptr, bit (36), char (*), fixed bin (35)) returns (bit (1) aligned);
dcl value_$delete entry (ptr, bit (36), char (*), fixed bin (35));
dcl value_$get_alloc entry (ptr, bit (36), char (*), ptr, ptr, fixed bin (21), fixed bin (35));
dcl value_$init_seg entry (ptr, fixed bin, ptr, fixed bin (19), fixed bin (35));
dcl value_$set entry options (variable);

dcl (addcharno, addr, codeptr, copy, divide, fixed, hbound, index, length) builtin;
dcl (max, maxlength, min, mod, null, rtrim, search, substr, unspec, verify) builtin;

dcl (area, bad_area_format, bad_area_initialization) condition;
%page;
	trace_sw = "1"b;
	expand_label_sw, got_next_stmt, label_search_sw, skip_sw = "0"b;
	go to COMMON;

expand_label: entry (A_xd, A_pos, A_len, A_label_val_ptr, A_label_val_len, A_code);  /* expands a &label for search */

	expand_label_sw = "1"b;
	got_next_stmt, label_search_sw, skip_sw, trace_sw = "0"b;
	A_code = 0;
	abs_data_ptr = A_xd.abs_data_ptr;
	overlay_ptr = input_string.ptr;
	overlay_len = input_string.len;
	iptr = addcharno (overlay_ptr, A_pos + length ("&label ") - 1);  /* position to rest of line */
	ilen = A_len - length ("&label ");
	ipos, istart, nest_level = 1;
	no_args_sw, parse_args_sw = "0"b;
	state.optr = A_xd.caller_buffer_ptr;
	state.omax_len = A_xd.caller_buffer_len;
	state.olen = 0;
	go to START_EXPANDING;

label_search: entry (A_xd, A_code);

	label_search_sw = "1"b;			/* executing a &goto */
	expand_label_sw, got_next_stmt, skip_sw, trace_sw = "0"b;
	go to COMMON;

skip:	entry (A_xd, A_code);

	skip_sw = "1"b;				/* skipping &then or &else clause */
	expand_label_sw, label_search_sw, trace_sw = "0"b;
COMMON:
	if ^init_sw then do;
	     init_sw = "1"b;
	     STMTS_LEN = length (STMTS (1)) * hbound (STMTS, 1);
	     NAMES_LEN = length (NAMES (1)) * hbound (NAMES, 1);
	     DONT_EXPAND_LEN = length (DONT_EXPAND (1)) * hbound (DONT_EXPAND, 1);
	     PARAMS_LEN= length (PARAMS (1)) * hbound (PARAMS, 1);

	     IF_ACTION = lookup_stmt ("&if");
	     THEN_ACTION = lookup_stmt ("&then");
	     ELSE_ACTION = lookup_stmt ("&else");
	     SET_ACTION = lookup_stmt ("&set");

	     WHITE = SP || HT || VT || FF;		/* white space */
	end;

	A_code = 0;

	nest_level, state.quote_factor, state.qscan_start = 1;
	added_arg_inside_quotes_sw, inside_quotes_sw, null_arg_sw, parse_args_sw = "0"b;

	abs_data_ptr = A_xd.abs_data_ptr;
	ec_data_ptr = abs_data.ec_data_ptr;

	saved_arg_ptr = addr (auto_saved_arg);
	saved_arg_len = maxlength (auto_saved_arg);
	saved_arg_allocated_sw = "0"b;

	overlay_ptr = input_string.ptr;
	overlay_len = input_string.len;
SKIP_LOOP:					/* label for $skip to ignore some keywords */
	iptr = addcharno (overlay_ptr, A_xd.input_pos - 1);
	ilen = overlay_len - A_xd.input_pos + 1;

	i = index (input, NL);			/* skip prev line's trailing whitespace and NL */
	if i ^= 0 then do;
	     if i = 1 then skip_count = 0;		/* just a blank line; don't skip it */
	     else if verify (substr (input, 1, i - 1), WHITE) = 0 then skip_count = i;
	     else skip_count = 0;
	     A_xd.input_pos = A_xd.input_pos + skip_count;
	     iptr = addcharno (iptr, skip_count);
	     ilen = ilen - skip_count;
	end;

	if ilen = 0 then do;
	     A_code = error_table_$end_of_info;
	     return;
	end;

	if label_search_sw then do;
	     char3 = substr (input, 1, 3);
	     if char3 ^= "&be" & char3 ^= "&do" & char3 ^= "&en" & char3 ^= "&la" then do;
						/* not at a &begin, &do, &end or &label stmt */
		call find_next_occurrence ("&begin", A_xd.next_begin_pos, ic (1));
		call find_next_occurrence ("&do", A_xd.next_do_pos, ic (2));
		call find_next_occurrence ("&end", A_xd.next_end_pos, ic (3));
		call find_next_occurrence ("&label", A_xd.next_label_pos, ic (4));
		call find_next_occurrence ("&""", A_xd.next_quote_pos, ic (5));
		call find_next_occurrence ("&-", A_xd.next_comment_pos, ic (6));
		i = MAX_CHARS;
		do j = 1 to hbound (ic, 1);
		     if ic (j) ^= 0 then i = min (i, ic (j));
		end;
		if i = 0 | i = MAX_CHARS then
NO_LABEL:		     if abs_data.in_handler_sw then do;
			A_code = error_table_$end_of_info;
			go to RETURN;
		     end;
		     else do;
			A_xd.this_statement.pos = abs_data.goto_statement_pos;
			A_xd.this_statement.len = abs_data.goto_statement_len;
			call error ("Searching for label """ || rtrim (A_xd.searching_for) || """");
		     end;
		char3 = substr (input_overlay, i, 3);
		if substr (char3, 1, 2) = "&""" then do;  /* skip &"..." */
		     inside_quotes_sw = "1"b;
		     i = i + 2;			/* first skip the &" */
		     do while (inside_quotes_sw);
			j = index (substr (input_overlay, i), """");
			if j = 0 then call error ("Missing end quote for &""");
			if substr (input_overlay, i + j, 1) = """" then  /* imbedded double quote */
			     i = i + j + 1;		/* skip over it and continue inside string */
			else inside_quotes_sw = "0"b;
		     end;
		end;
		else if substr (char3, 1, 2) = "&-" then do;  /* skip comment */
		     j = index (substr (input_overlay, i + 1), NL);  /* skip past end of line */
		     if j = 0 then go to NO_LABEL;
		     i = i + j;
		end;
		A_xd.input_pos = i;
		go to SKIP_LOOP;
	     end;
	end;

	istart = 1;

	A_xd.this_statement.pos = A_xd.input_pos;
	abs_data.next_action = UNDEFINED;

NL_LOOP:	i = index (substr (input, istart), NL);		/* find end of this line */
	if i = 0 then
	     if abs_data.in_handler_sw then i = ilen;	/* tolerate partial line in handler; must be followed by &end */
	     else call error ("Last line does not end in newline; ignored.");
	else if i = 1 then do;			/* null line */
	     A_xd.input_pos = A_xd.input_pos + 1;
	     A_xd.caller_actual_len, A_xd.this_statement.len = 0;
RETURN_NULL_LINE:
	     if trace_sw & command_line.on then call print_trace ("", command_line, NONCONTROL);

	     abs_data.this_action = 0;
	     go to GET_NEXT_STMT;
	end;
	else if i + istart + 1 < ilen then do;		/* not the last line */
	     if substr (input, i + istart - 1, 1) = NL then do;  /* include continuation lines */
		white_len = verify (substr (input, i + istart), WHITE) - 1;
		if white_len = -1 then white_len = 0;
		char2 = substr (input, i + istart + white_len, 2);
		if char2 = "&-" then do;		/* might be continuation broken by comment line */
		     temp_istart = istart;
		     temp_i = i;
		     temp_white_len = white_len;
		     do while (char2 = "&-");		/* or any number of comment lines */
			temp_istart = temp_istart + temp_i + temp_white_len;
			temp_i = index (substr (input, temp_istart), NL);
			temp_white_len = verify (substr (input, temp_i + temp_istart), WHITE) - 1;
			if temp_white_len = -1 then temp_white_len = 0;
			char2 = substr (input, temp_i + temp_istart + temp_white_len, 2);
		     end;
		     if char2 = "&+" then do;		/* yes, it is part of a continuation */
			istart = temp_istart;
			i = temp_i;
			white_len = temp_white_len;
		     end;
		end;
		if char2 = "&+" then do;
		     istart = istart + i + white_len;	/* skip to after the &+ */
		     go to NL_LOOP;
		end;
	     end;
	end;
	saved_ilen = ilen;
	ilen = i + istart - 2;			/* leave off last NL */
	if A_xd.is_input & ^abs_data.trim_whitespace_sw then ipos = 1;
	else do;
	     ipos = verify (input, WHITE);	     	     	     /* skip leading whitespace */
	     if ipos = 0 then do;	     	     	     /* all whitespace */
		A_xd.input_pos = A_xd.input_pos + ilen + 1;
		A_xd.caller_actual_len, A_xd.this_statement.len = ilen;
		substr (caller_buffer, 1, ilen) = substr (input, 1, ilen);
		go to RETURN_NULL_LINE;
	     end;
	end;

	A_xd.this_statement.pos = A_xd.input_pos;
	A_xd.this_statement.len = ilen;

	state.optr = A_xd.caller_buffer_ptr;
	state.omax_len = A_xd.caller_buffer_len;
	state.olen = 0;
	allocated_sw = "0"b;

/* Find out whether it's a control line */

	if substr (input, ipos, 1) = "&" then		/* begins with & */
	     if ilen = ipos then do;			/* & on line by itself = error */
		state.keyword.name = "&";
		go to BAD_AMP_WORD;
	     end;
	     else if substr (input, ipos + 1, 1) = "&" then do;  /* && = & */

		call add_output (state.optr_len, "&");

		ipos = ipos + 2;
		abs_data.this_action = 0;
		go to NOT_CONTROL;
	     end;
	     else if substr (input, ipos + 1, 1) = "-" then do;  /* &-  (comment) */
		if abs_data.comment_line.on & trace_sw & ipos + 1 < ilen then

		     call trace_comment (substr (input, ipos + 2));

		A_xd.input_pos = A_xd.input_pos + ilen + 1;
		go to SKIP_LOOP;
	     end;
	     else do;

		state.keyword.name = "&";		/* prepare to look up a stmt keyword */
		do i = ipos + 1 to ilen while (index (WHITE || "&", substr (input, i, 1)) = 0);
		     state.keyword.name = state.keyword.name || substr (input, i, 1);

		     abs_data.this_action = lookup_stmt ((state.keyword.name));

		     if abs_data.this_action ^= 0 then go to CONTROL_STMT;  /* yes, a statement keyword */
		end;
		go to NOT_CONTROL;

/* A control statement */

CONTROL_STMT:

/* So far we only know it STARTS with a valid control word; it might be the &ready of &ready_proc, or &thenfoo */

		state.keyword.name = "&";		/* make sure we get the whole keyword */
		do i = ipos + 1 to ilen while (index (ALPHA, substr (input, i, 1)) ^= 0);
		     state.keyword.name = state.keyword.name || substr (input, i, 1);
		end;

		abs_data.this_action = lookup_stmt ((state.keyword.name));

		if abs_data.this_action = 0 then	/* could be "&thenfoo", for example */
		     call error ("Invalid statement keyword " || state.keyword.name);

		control_line_sw = CONTROL;
		trace = abs_data.control_line;	/* get trace info for control lines */

		ipos = ipos + length (state.keyword.name);  /* skip the control statement keyword */
		i = verify (substr (input, ipos), WHITE);  /* and the following whitespace */
		if i = 0 then do;			/* done (no args) */
		     ipos, no_args_ipos = ilen + 1;

CONTROL_NOARG:	     if trace_sw & trace.on & (trace.expand = UNEXPANDED | trace.expand = BOTH) then

			call trace_unexpanded (input, trace);

		     go to RETURN_STRING;
		end;
		ipos = ipos + i - 1;		/* skip the whitespace */
		if i = 1 then no_args_ipos = ipos - 1;	/* no white space following control word */
		else no_args_ipos = ipos - 2;		/* restore later if no_args_sw */

		no_args_sw = NO_ARGS_SW (abs_data.this_action);
						/* whether no args is acceptable for this stmt */
		if no_args_sw &
		     (abs_data.this_action = THEN_ACTION | abs_data.this_action = ELSE_ACTION) then
			go to CONTROL_NOARG;	/* don't even look for a comment */

		then_else_allowed_sw = THEN_ELSE_ALLOWED_SW (abs_data.this_action);
						/* whether this stmt can be followed by &then or &else */

		if trace_sw & abs_data.if_sw then do;	  /* test whether to trace */
		     if (abs_data.this_action = THEN_ACTION & ^abs_data.true_sw)
						/* don't trace &then after "&if false" */
		      | (abs_data.this_action = ELSE_ACTION & abs_data.true_sw) then 
						/* don't trace &else after "&if true" */
			     trace_sw = "0"b;
		end;

		parse_args_sw = ^skip_sw & PARSE_ARGS_SW (abs_data.this_action);
		if parse_args_sw then do;		/* parse args separated by whitespace */

		     parsed_args_count = 20;		/* grow later if necessary */
		     if A_xd.area_ptr = null then A_xd.area_ptr = get_system_free_area_ ();

		     allocate parsed_args in (xd_area) set (parsed_args_ptr);

		     parsed_args.count = 0;
		     A_xd.parsed_args_ptr = parsed_args_ptr;
		end;

		else A_xd.parsed_args_ptr, A_xd.arg_ptr = null;  /* take rest of line as single arg */
	     end;

	else do;
	     abs_data.this_action = 0;
NOT_CONTROL:					/* either command line, input line, or comment */
	     no_args_sw, parse_args_sw = "0"b;
	     A_xd.parsed_args_ptr, A_xd.arg_ptr = null;

	     trace = A_xd.trace_lines;
	     control_line_sw = NONCONTROL;
	end;

	if parse_args_sw | then_else_allowed_sw then search_chars = "&()[]" || NL || WHITE;
	else search_chars = "&()[]" || NL;

	inside_quotes_sw = "0"b;
	if abs_data.this_action = SET_ACTION then search_chars = search_chars || """";
						/* see quotes only for &set statement */

	if trace_sw & trace.on then do;
	     if trace.iocb = null then trace.iocb = iox_$user_output;
	     if trace.expand = UNEXPANDED | trace.expand = BOTH then call trace_unexpanded (input, trace);
	end;

START_EXPANDING:
	A_xd.expanded_sw = "0"b;			/* assume until var or param is expanded */

	eof_sw, null_arg_sw = "0"b;

	do while (^eof_sw);

	     i = search (substr (input, ipos), search_chars);  /* next & ) NL also WHITE if parsing args */
	     if i = 0 then do;			/* no more ampersands */
		if nest_level > 1 then		/* see if any unclosed construct */
		     do j = nest_level - 1 by -1 to 1;
			if state_stack (j).keyword.number ^= 0 then
			     if state_stack (j).keyword.number = AF_REF then call error ("No closing bracket.");
			     else call error ("No closing parenthesis.");
		     end;
		if ipos <= ilen then call add_output (state.optr_len, substr (input, ipos));

		ipos = ilen + 1;
		go to RETURN_STRING;
	     end;

	     if i > 1 then call add_output (state.optr_len, substr (input, ipos, i - 1));

	     ipos = ipos + i;

	     searched_char = substr (input, ipos - 1, 1);

	     if searched_char = NL then do;		/* NL || &+ */
CONTIN:		ipos = ipos + verify (substr (input, ipos), WHITE) - 1;
						/* skip white space on next line before &+ or &- */
		if substr (input, ipos, 2) = "&+" then ipos = ipos + 2;  /* if it's &+, skip that too */
	     end;

	     else if searched_char = """" then do;	/* only for parsing &set args */

		if nest_level > 1 then call add_output (state.optr_len, """");
						/* only strip quotes from &set args */

		if ^inside_quotes_sw then do;
		     inside_quotes_sw = "1"b;
		     added_arg_inside_quotes_sw = "0"b;
		end;
		else if substr (input, ipos, 1) = """" then do;  /* double quote is a " inside string */

		     call add_output (state.optr_len, """");
		     ipos = ipos + 1;
		end;
		else do;				/* single quote ends it */
		     if output = "" & parse_args_sw & ^added_arg_inside_quotes_sw then null_arg_sw = "1"b;

		     inside_quotes_sw, added_arg_inside_quotes_sw = "0"b;
		end;
	     end;

	     else if searched_char = ")" then do;

		if nest_level = 1 then call add_output (state.optr_len, ")");
		else do;

		     call save_arg;			/* allocate bigger if necessary */

		     call pop_state (nest_level, state);

		     if state.keyword.number = 0 then
			call add_output (state.optr_len, saved_arg || ")");  /* just (...) */

		     else if state.keyword.number = AF_REF then  /* &[...) */
			call error ("Mismatched brackets.");

		     else do;		     		     /* &(...) or &keyword(...) */

EXPAND_ONE:		if trace.on then state.iafter_pos = ipos;

			if ^skip_sw then call expand (state, saved_arg);	/* add expansion to output */
		     end;
		end;
	     end;

	     else if searched_char = "]" then do;	/* end of &[...] or [...] */

		if nest_level = 1 then call add_output (state.optr_len, "]");
		else do;

		     call save_arg;			/* allocate bigger if necessary */

		     call pop_state (nest_level, state);

		     if state.keyword.number = 0 then
			call add_output (state.optr_len, saved_arg || "]");  /* just [...] */

		     else if nest_level < 1 then call error ("Excess right bracket.");

		     else if state.keyword.number = AF_REF then go to EXPAND_ONE;  /* &[...] */
		     else call error ("Mismatched bracket.");
		end;
	     end;

	     else if searched_char = "(" then do;	/* just plain (...) */

		unspec (state.keyword) = "0"b;
		state.keyword.number = 0;		/* not an exec_com construct */
						/* but have to parse it because ) closes either it or &( */
		call push_state (nest_level, state);

		call add_output (state.optr_len, "(");
	     end;

	     else if searched_char = "[" then do;	/* just plain [...] */

		unspec (state.keyword) = "0"b;
		state.keyword.number = 0;		/* not an exec_com construct */
						/* but we have to parse it because ] closes either it or &[ */
		call push_state (nest_level, state);

		call add_output (state.optr_len, "[");
	     end;

	     else if searched_char = "&" then do;	/* start of a stmt or expandable construct */

		if i >= ilen then call error ("Invalid construct ""&""");

		state.keyword.paren_sw = "0"b;	/* assume till ( encountered */
		if trace.on then do;
		     state.iafter_pos = ipos - 1;
		end;

		next_char = substr (input, ipos, 1);

		if next_char = "-" then do;		/* &-  (comment) */

		     if ipos > 2 & state.olen > 0 & (^A_xd.is_input | abs_data.trim_whitespace_sw) then
						/* strip preceding whitespace from expanded line */
			state.olen = length (rtrim (output, WHITE));

		     i = index (substr (input, ipos + 1), NL);  /* end of line */

		     if i = 0 then do;		/* no continuation */
			if abs_data.comment_line.on & trace_sw then

			     call trace_comment (substr (input, ipos + 1));

			ipos = ilen + 1;		/* skip over comment */
			go to RETURN_STRING;
		     end;
		     else do;			/* continued on next line */
			if abs_data.comment_line.on & trace_sw then

			     call trace_comment (substr (input, ipos + 1, i - 1));

			ipos = ipos + i + 1;	/* position of the &+ or &- */
			go to CONTIN;
		     end;
		end;

/* Not a comment */

		if no_args_sw then go to RETURN_STRING;

		else if next_char = """" then do;	/* &"..." */
		     ipos = ipos + 1;		/* position to after first quote */

		     if trace_sw & trace.on & trace.expand = ALL then do;  /* trace before expanding quoted string */

			call trace_expanded (state, trace_buffer);

			trace_buffer = trace_buffer || substr (input, state.iafter_pos);

			call print_trace ((trace_buffer), trace, control_line_sw);
		     end;

		     call get_quoted_string (input, iptr_len.ipos, state, "0"b);
		end;

		else if next_char = "&" then do;	/* && */

		     if trace.on & trace.expand = ALL then do;  /* trace before expanding && */
			if state.olen > 0 then	/* not beginning of line */
			     trace_buffer = output || substr (input, state.iafter_pos);
			else trace_buffer = substr (input, state.iafter_pos);

			call print_trace ((trace_buffer), trace, control_line_sw);
		     end;

		     call add_output (state.optr_len, "&");  /* translates to a single ; */

		     ipos = ipos + 1;
		end;

		else if next_char = "!" then do;	/* &! = unique name, same for every instance */
		     if abs_data.unique_name = "" then
			abs_data.unique_name = rtrim (unique_chars_ ("0"b));

		     call add_output (state.optr_len, (abs_data.unique_name));

		     ipos = ipos + 1;
		end;

		else do;				/* &CONSTRUCT */
		     if next_char = "(" then do;	/* &(...) */
			unspec (state.keyword) = "0"b;
			state.keyword.number = VAR_REF;
			state.keyword.name = "&";
OPEN_PAREN:		ipos = ipos + 1;		/* skip the ( */
			state.keyword.paren_sw = "1"b;

			call push_state (nest_level, state);
		     end;

		     else if next_char = "[" then do;	/* &[...] */
			ipos = ipos + 1;		/* skip past it */
			unspec(state.keyword) = "0"b;
			state.keyword.af_type = BK_TYPE;
OPEN_AF:			state.keyword.number = AF_REF;
			state.keyword.name = "&";
			state.keyword.bracket_sw = "1"b;

			call push_state (nest_level, state);
		     end;

		     else if next_char = "|" then do;  /* might be &|[ or &||[ */
			if ipos = ilen then go to BAD_AMP_WORD;  /* just &| by itself */
			next_next_char = substr (input, ipos + 1, 1);
			if next_next_char = "[" then do;  /* &|[ */
			     ipos = ipos + 2;	/* skip past it */
			     unspec (state.keyword) = "0"b;
			     state.keyword.af_type = BAR_BK_TYPE;
			     go to OPEN_AF;
			end;
			else if next_next_char = "|" then  /* &||... */
			     if ipos + 2 <= ilen then
				if substr (input, ipos + 2, 1) = "[" then do;  /* &||[ */
				     ipos = ipos + 3;  /* skip past it */
				     unspec (state.keyword) = "0"b;
				     state.keyword.af_type = BAR_BAR_BK_TYPE;
				     go to OPEN_AF;
				end;

			go to BAD_AMP_WORD;		/* some other &|string */
		     end;

		     else do;
			if index (DIGITS, next_char) ^= 0 then do;  /* &1, &2, etc. */
			     ipos, state.iafter_pos = ipos + 1;
			     state.keyword = PARAM_KEYWORD;
			     saved_arg = next_char;
			     go to EXPAND_ONE;
			end;

			else if index ("fqr", next_char) ^= 0 then do;  /* &q1, &rf&n, etc. */
			     i = search (substr (input, ipos), DIGITS || "( " || DELIMS || NL);
			     if i = 0 then do;
				state.keyword.name = substr (input, ipos - 1);
				i = ilen - ipos + 2;
			     end;
			     else state.keyword.name = substr (input, ipos - 1, i);

			     if known_param (state.keyword, (state.keyword.name)) then do;

				ipos, state.iafter_pos = ipos + i - 1;

				if state.n_sw then	/* &q&n, &rf&n, etc. */
				     go to EXPAND_ONE;  /* no need to get numeric arg */

				next_char = substr (input, ipos, 1);
				if index (DIGITS, next_char) ^= 0 then do;  /* &qf1, etc. */
				     saved_arg = next_char;
				     ipos, state.iafter_pos = ipos + 1;  /* skip the digit */
				     go to EXPAND_ONE;
				end;
				else go to KNOWN;
			     end;
			end;

			state.keyword.name = "&";	/* &keyword to look up a char at a time */
			saved_ipos = ipos - 2;	/* to be restored if keyword is &then, &else, etc. */
			found_sw = "0"b;

			do while (^found_sw);

			     state.keyword.name = state.keyword.name || next_char;

			     ipos = ipos + 1;

			     if known_dont_expand (state.keyword.name) then do;
						/* an &word that's a stmt control-arg */

				call add_output (state.optr_len, (state.keyword.name));

				go to END_AMP_WORD;
			     end;

			     if known (state.keyword) then found_sw = "1"b;

			     else do;
				if ipos > ilen then
BAD_AMP_WORD:			     if index (STMTS_STRING, state.keyword.name || " ") ^= 0 then call error
					("Misused statement keyword """ || state.keyword.name || """");
				     else call error ("Unrecognized keyword """ || state.keyword.name || """");

				next_char = substr (input, ipos);
				if index (DELIMS, next_char) ^= 0 then go to BAD_AMP_WORD;
			     end;
			end;

			if state.keyword.control_word_sw then do;  /* another stmt on line: &then, &else, &do */

			     if nest_level > 1 then
				call error ("Nested control statement keyword """ || state.keyword.name || """");

			     abs_data.next_action = lookup_stmt ((state.keyword.name));

			     A_xd.next_statement.pos = saved_ipos + 1;
			     A_xd.next_statement.len,
				A_xd.next_statement.keyword_len = length (state.keyword.name);

			     ipos = saved_ipos;	/* save next stmt for next call to abs_io_expand_ */
			     go to RETURN_STRING;
			end;

KNOWN:			if ^state.keyword.allow_arg_sw then do;  /* don't look for an argument */
NO_ARG:			     saved_arg = DEFAULT_ARG;
			     go to EXPAND_ONE;
			end;

			else if ipos > ilen then
			     if state.keyword.require_arg_sw then
MISSING_ARG:			call error ("Missing argument for """ || state.keyword.name || """");
			     else go to NO_ARG;

			else if substr (input, ipos, 1) = "(" then go to OPEN_PAREN;  /* argument in parens */

			else if state.keyword.digit_arg_sw then  /* accepts a single digit arg: q1, f1, etc. */
			     if index (DIGITS, next_char) ^= 0 then do;
				saved_arg = next_char;
				ipos = ipos + 1;
				go to EXPAND_ONE;
			     end;
			     else go to MISSING_ARG;
			else if ^state.keyword.require_arg_sw then go to NO_ARG;
			else go to MISSING_ARG;
		     end;
END_AMP_WORD:	end;
	     end;					/* end of (searched_char = "&") case */

	     else do;				/* white space; we're parsing args or finding &then */

		if no_args_sw then go to RETURN_STRING;

		i = verify (substr (input, ipos - 1), WHITE);
		if i ^= 0 then
		     if substr (input, ipos + i - 2, 1) = NL then do;  /* end of line before &+ */
			ipos = ipos + i - 2;		/* just skip white space, don't end arg */
			go to NEXT_DELIM;
		     end;
		     else if ilen > ipos + i then
			if substr (input, ipos + i - 2, 2) = "&-" &  /* before comment */
			     index (substr (input, ipos + i), NL) ^= 0 then do;  /* followed by &+ */
				ipos = ipos + i - 2;  /* same: skip white space and don't end arg */
				go to NEXT_DELIM;
			     end;

		if nest_level = 1 & ^inside_quotes_sw then do;  /* outside (), [], or "", this whitesp delimits an arg */

		     if i = 0 then do;		/* end of statement */
			if ipos - 2 < ilen & A_xd.is_input & ^abs_data.trim_whitespace_sw then

			     call add_output (state.optr_len, substr (input, ipos - 1));

			ipos = ilen + 1;		/* else just skip the trailing whitespace */
			eof_sw = "1"b;
		     end;

		     else do;

			if then_else_allowed_sw & ipos + i + 1 < ilen then do;  /* room for &then or &else */
			     char5 = substr (input, ipos + i - 2, 5);
			     if (char5 = "&then" | char5 = "&else") &  /* IS then or else followed by white */
			       (ipos + i + 2 = ilen | index (WHITE, substr (input, ipos + i + 3, 1)) ^= 0) then do;
				ipos = ipos + i - 3;  /* skip whitespace before &then or &else */
				if char5 = "&then" then abs_data.next_action = THEN_ACTION;
				else abs_data.next_action = ELSE_ACTION;

				if nest_level > 1 then  /* not valid inside () or [] */
				     if state.keyword.number = AF_REF then
					call error ("Missing right bracket.");
				     else call error ("Missing right parenthesis.");
				if state.quote_factor > 1 then call error ("Unbalanced quotes.");
				go to RETURN_STRING;
			     end;
			end;

			if parse_args_sw then do;	/* if separating args */
			     ipos = ipos + i - 2;	/* skip white space */

			     if nest_level = 1 & state.quote_factor = 1 /* outside () [] "" */ then do;

				call add_arg (state);  /* pick up the arg we have delimited */

				null_arg_sw = "0"b;
			     end;
			end;
			else do;			/* pick up whitespace */

ADD_SPACE:		     call add_output (state.optr_len, substr (input, ipos - 1, i - 1));

			     ipos = ipos + i - 2;
			end;
		     end;
		end;

		else if i > 0 then go to ADD_SPACE;	/* leave white space intact inside () [] */
NEXT_DELIM:    end;
	end;

RETURN_STRING:
	if inside_quotes_sw then call error ("Unbalanced quotes in &set statement.");

	do while (nest_level > 1 & state.keyword.number = 0);  /* still inside non-ec construct like ( or [ */
	     saved_arg = output;

	     call pop_state (nest_level, state);

	     call add_output (state.optr_len, (saved_arg));
	end;
	if nest_level > 1 then
	     do j = nest_level - 1 by -1 to 1;
		if state_stack (j).keyword.number ^= 0 then
		     if state_stack (j).keyword.number = AF_REF then call error ("Missing right bracket.");
		     else call error ("Missing right parenthesis.");
	     end;

	if expand_label_sw then do;
	     A_label_val_ptr = state.optr;
	     A_label_val_len = state.olen;
	end;

	if no_args_sw then do;			/* we were just looking for comments */
	     ipos = no_args_ipos;
	     parse_args_sw = "0"b;
	     state.olen = 0;
	     state.quote_factor, state.qscan_start = 1;
	end;

	if trace_sw & trace.on & trace.expand ^= UNEXPANDED
	  & abs_data.this_action ^= THEN_ACTION & abs_data.this_action ^= ELSE_ACTION then
	     if parse_args_sw then do;		/* have to print already parsed args too */
		trace_buffer = "";
		if A_xd.parsed_args_ptr ^= null then
		     do parsed_arg_index = 1 to A_xd.parsed_args_ptr -> parsed_args.count;
			trace_buffer = trace_buffer || parsed_arg || " ";
		     end;

		call print_trace (trace_buffer || output, trace, control_line_sw);
	     end;

	     else call print_trace (output, trace, control_line_sw);

	if parse_args_sw then do;
	     if state.olen > 0 then call add_arg (state);  /* there is a last unsaved arg in output buffer */
	     else if null_arg_sw then do;		/* there is an unsaved null arg */
		null_arg_sw = "0"b;
		call add_arg (state);
	     end;
	end;
	else do;					/* the one arg is all of output */
	     if abs_data.this_action = IF_ACTION & skip_sw & state.olen = 0 then
						/* didn't expand skipped &if clause, so fake it */
		call add_output (state.optr_len, "false");  /* otherwise, caller will say "Malformed conditional" */

	     A_xd.arg_ptr = state.optr;
	     A_xd.arg_len = state.olen;
	end;

	if allocated_sw then			/* not using caller's buffer anymore */
	     if abs_data.this_action ^= 0 then do;	/* have to preserve args */
		A_xd.caller_actual_len = 0;		/* return only allocated storage */
		A_xd.allocated_ptr = alloc_ptr;
		A_xd.allocated_buffer_len = alloc_len;
		A_xd.allocated_len = state.olen;
	     end;
	     else do;				/* command or input line; can copy back */
		if state.olen <= A_xd.caller_buffer_len then do;  /* will all fit in caller's buffer */
		     A_xd.caller_actual_len = state.olen;
		     A_xd.allocated_ptr = null;
		     A_xd.allocated_buffer_len, A_xd.allocated_len = 0;
		end;
		else do;				/* part in caller's part in allocated */
		     A_xd.caller_actual_len = A_xd.caller_buffer_len;  /* as much in caller's as fits */
		     A_xd.allocated_buffer_len, A_xd.allocated_len = state.olen - A_xd.caller_actual_len;

		     allocate allocated_buffer in (xd_area) set (A_xd.allocated_ptr);

		     allocated_buffer = substr (output, A_xd.caller_actual_len + 1);
		end;

		substr (caller_buffer, 1, A_xd.caller_actual_len) = substr (alloc_string, 1, A_xd.caller_actual_len);

		free alloc_string in (xd_area);	/* done with our own copy */
	     end;

	else A_xd.caller_actual_len = state.olen;	/* no copying necessary */

	if ^expand_label_sw then do;
	     A_xd.input_pos = A_xd.input_pos + ipos;

/* Skip trailing white space if any */

	     if substr (input_overlay, A_xd.input_pos - 1, 1) ^= NL then  /* not at end of line */
		if ^A_xd.is_input | abs_data.trim_whitespace_sw then do;
		     i = index (substr (input_overlay, A_xd.input_pos), NL);
		     if i = 1 then A_xd.input_pos = A_xd.input_pos + 1;  /* one char to skip, must be white space */
		     else if i ^= 0 then
			if verify (substr (input_overlay, A_xd.input_pos, i - 1), WHITE) = 0 then
			     A_xd.input_pos = A_xd.input_pos + i;  /* skip however much white space */
		end;

/* Skip continuation sequence if any */

	     i = verify (substr (input_overlay, A_xd.input_pos), WHITE);
	     if i ^= 0 then
		if substr (input_overlay, A_xd.input_pos + i - 1, 1) = "&" then
		     if substr (input_overlay, A_xd.input_pos + i, 1) = "+" then
			A_xd.input_pos = A_xd.input_pos + i + 1;

	end;

GET_NEXT_STMT:
	if abs_data.next_action = UNDEFINED & A_xd.input_pos + 1 < input_string.len then do;
						/* look-ahead for abs_io_v2_get_line's sake */
	     call get_next_stmt (input_string.ptr, input_string.len, A_xd.input_pos, A_xd.next_statement);

	     abs_data.next_action = A_xd.next_statement.action;
	end;

RETURN:
	if saved_arg_allocated_sw then free saved_arg_ptr -> saved_arg in (xd_area);

	if ^got_next_stmt & abs_data.noabort then do;
	     call get_next_stmt (input_string.ptr, input_string.len, A_xd.input_pos, A_xd.next_statement);
	end;

	return;
%page;
add_arg: proc (P_state);

/* Adds another parsed_arg to the structure */

dcl 1 P_state like state;
dcl temp_ptr ptr;

	if parsed_args.count >= parsed_args_count then call grow_parsed_args;

	parsed_args.count = parsed_args.count + 1;
	parsed_args.ptr (parsed_args.count) = P_state.optr;
	parsed_args.len (parsed_args.count) = P_state.olen;

	temp_ptr = P_state.optr;			/* avoids PL/1 addcharno bug involving parameters */
	P_state.optr = addcharno (temp_ptr, P_state.olen);
	P_state.omax_len = P_state.omax_len - P_state.olen;  /* stay within allocated range */
	P_state.olen = 0;
	P_state.quote_factor, P_state.qscan_start = 1;
	if inside_quotes_sw then added_arg_inside_quotes_sw = "1"b;

end add_arg;
%page;
add_output: proc (P_ptr_len, P_str);

/* Appends another parsed part (P_str) to the output buffer */

dcl 1 P_ptr_len like state.optr_len;
dcl P_str char (*);
dcl output char (P_ptr_len.olen) based (P_ptr_len.optr);
dcl str_len fixed bin;

	if skip_sw & abs_data.this_action ^= IF_ACTION then return;

	str_len = length (P_str);

	if P_ptr_len.olen + str_len > P_ptr_len.omax_len then do;  /* need to allocate bigger buffer */
	     alloc_len = P_ptr_len.omax_len + str_len + 200;

	     allocate alloc_string in (xd_area) set (alloc_ptr);

	     substr (alloc_string, 1, P_ptr_len.olen) = substr (output, 1, P_ptr_len.olen);
/*	     if allocated_sw then free P_ptr_len.optr -> alloc_string;  */  /* might destroy pushed state */
	     allocated_sw = "1"b;
	     P_ptr_len.optr = alloc_ptr;
	     P_ptr_len.omax_len = alloc_len;
	end;

	P_ptr_len.olen = P_ptr_len.olen + str_len;
	substr (output, P_ptr_len.olen - str_len + 1, str_len) = P_str;

end add_output;
%page;
add_quoted_output: proc (P_ptr_len, P_str, P_requote_sw);

/* Same as add_output but quotes or requotes P_str */
dcl 1 P_ptr_len like state.optr_len;
dcl P_str char (*);
dcl P_requote_sw bit (1);
dcl (quote_len, quote_pos, scan_len) fixed bin (21);

	if skip_sw then return;

/* Bring quote-level scan up to date first */

	if state.qscan_start <= state.olen then do;	/* quote-level scan not up to date yet */
	     if state.qscan_start = 1 & nest_level > 1 then  /* recurse to scan outer level */
		state.quote_factor = compute_nested_quote_factor (nest_level - 1);
	     call compute_quote_factor (state);		/* now compute factor at current level */
	end;

/* Now knowing the quote level at which P_str is to be inserted, modify P_str */

	if P_requote_sw = REQUOTE then do;
						/* insert right number of leading quotes */
	     call add_output (P_ptr_len, copy ("""", state.quote_factor));

	     state.quote_factor = 2 * state.quote_factor;  /* up one for open quote */
	end;

	scan_len = 0;
DOUBLE_LOOP:					/* perform quote doubling while appending P_str */
	quote_pos = index (substr (P_str, scan_len + 1), """");
	if quote_pos > 0 then do;

	     call add_output (P_ptr_len, substr (P_str, scan_len + 1, quote_pos - 1));

	     scan_len = scan_len + quote_pos;
						/* repeat next quote the right number of times */
	     call add_output (P_ptr_len, copy ("""", state.quote_factor));

	     if scan_len < length (P_str) then go to DOUBLE_LOOP;
	     else go to CLOSE_REQUOTE;
	end;

	quote_pos = length (P_str) - scan_len;		/* length of string yet to be added */
	if quote_pos > 0 then

	     call add_output (P_ptr_len, substr (P_str, scan_len + 1, quote_pos));  /* rest of string */

CLOSE_REQUOTE:
	if P_requote_sw = REQUOTE then do;
	     state.quote_factor = divide (state.quote_factor, 2, 17, 0);  /* down one for close quote */
						/* append right number of trailing quotes */
	     call add_output (P_ptr_len, copy ("""", state.quote_factor));
	end;

	state.qscan_start = state.olen + 1;		/* scan is up to date */

	return;


compute_nested_quote_factor: proc (P_level) returns (fixed bin);

/* This internal procedure completes the quote scan up through nest level P_level */

dcl P_level fixed bin;

	if P_level = 0 then return (1);		/* should never happen */

	if state_stack (P_level).qscan_start <= state_stack (P_level).olen then do;  /* not up to date */
	     if state_stack (P_level).qscan_start = 1 & P_level > 1 then  /* recurse */
		state_stack (P_level).quote_factor = compute_nested_quote_factor (P_level - 1);
	     call compute_quote_factor (state_stack (P_level));
	end;

	return (state_stack (P_level).quote_factor);

end compute_nested_quote_factor;


compute_quote_factor: proc (P_state);

/* This internal procedure does the actual scan for a given level */

dcl 1 P_state like state;
dcl local_output char (P_state.olen) based (P_state.optr);

COUNT_LOOP:
	quote_pos = index (substr (local_output, P_state.qscan_start), """");
	if quote_pos > 0 then do;

	     P_state.qscan_start = P_state.qscan_start + quote_pos - 1;
	     quote_len = verify (substr (local_output, P_state.qscan_start), """") - 1; /* number of consecutive quotes */
	     if quote_len < 0 then quote_len = P_state.olen - P_state.qscan_start + 1;
	     P_state.qscan_start = P_state.qscan_start + quote_len;

	     if mod (quote_len, P_state.quote_factor) = 0 then  /* if a multiple of the depth, then */
						/* keep incrementing depth (doubling factor) */
		do while (mod (quote_len, 2 * P_state.quote_factor) ^= 0);
		     quote_len = quote_len - P_state.quote_factor;
		     P_state.quote_factor = 2 * P_state.quote_factor;
		end;

	     else do while (quote_len ^= 0);		/* else keep decrementing depth (undoubling) */
		P_state.quote_factor = divide (P_state.quote_factor, 2, 17, 0);
		quote_len = mod (quote_len, P_state.quote_factor);
	     end;

	     go to COUNT_LOOP;
	end;

	else P_state.qscan_start = P_state.olen + 1;

end compute_quote_factor;

end add_quoted_output;
%page;
error: proc (P_string);

/* Causes abs_io_v2_get_line to print error message and abort ec */
dcl P_string char (*);

	A_code = error_table_$badsyntax;
	A_xd.error_msg = P_string;
	go to RETURN;

end error;
%page;
expand: proc (P_state, P_arg);

dcl 1 P_state like state;
dcl P_arg char (*) varying;
dcl value_str char (value_len) based (value_ptr);
dcl value_var_str char (value_len) varying based (value_ptr);
dcl based_area area based (A_xd.area_ptr);
dcl value_buffer char (1000) varying;
dcl path_string char (168);
dcl short_string char (32) varying;
dcl switch_name char (32);
dcl (alloc_err_sw, traced_sw) bit (1);
dcl (p, value_ptr) ptr;
dcl value_len fixed bin (21);
dcl (i, numeric_arg) fixed bin;

	if P_state.keyword.number > MAX_KEY then go to BAD_AMP_WORD;

	traced_sw = "0"b;

START:	if P_state.keyword.require_number_sw & ^P_state.keyword.n_sw then do;  /* requires numeric arg */
	     if P_arg = DEFAULT_ARG then numeric_arg = 1;	/* default for &AMP, etc. */
	     else do;
		numeric_arg = cv_dec_check_ ((P_arg), code);
		if code ^= 0 then
		     if P_state.keyword.number = PARAM_REF then
			if P_state.keyword.f_sw then
			     call error ("Invalid parameter number """ || P_arg || """");
			else go to VAR_REF;		/* &r(var), &q(var) */
		     else call error ("Invalid numeric argument """ || P_arg || """ for " || P_state.keyword.name);
	     end;
	end;

	if trace_sw & trace.on & trace.expand = ALL & ^traced_sw then do;  /* trace before each expansion */

	     traced_sw = "1"b;

	     call trace_expanded (P_state, trace_buffer);  /* start with what's already been expanded */

	     trace_buffer = trace_buffer || P_state.keyword.name;
	     if P_arg ^= DEFAULT_ARG then		/* some arg was specified */
		if P_state.keyword.paren_sw then	/* arg is enclosed in parens */
		     trace_buffer = trace_buffer || "(" || P_arg || ")";
		else if P_state.keyword.bracket_sw then do;  /* arg is enclosed in brackets &[...] */
		     if P_state.keyword.af_type = BAR_BAR_BK_TYPE then short_string = "||[";
		     else if P_state.keyword.af_type = BAR_BK_TYPE then short_string = "|[";
		     else short_string = "[";
		     trace_buffer = trace_buffer || short_string || P_arg || "]";
		end;
		else trace_buffer = trace_buffer || P_arg;
	     if P_state.iafter_pos <= ilen then		/* not end of line */
		trace_buffer = trace_buffer || substr (input, P_state.iafter_pos);

	     call print_trace ((trace_buffer), trace, control_line_sw);
	end;

	go to EXPAND (P_state.keyword.number);

EXPAND (1):					/* parameter reference */
	A_xd.expanded_sw = "1"b;
/* OBSOLETE
	if P_arg = "0" then do;		(This is the V1 meaning)
	     if P_state.q_sw | P_state.r_sw then

		call add_quoted_output (P_state.optr_len, ec_path, P_state.r_sw);

	     else call add_output (P_state.optr_len, ec_path);

	     return;
	end;
END OF OBSOLETE */
	if P_arg = "0" then				/* &0 is invalid in Version 2 */
	     call error ("Invalid parameter &0");

	arg_max = max (abs_data.arg_count, abs_data.default_arg_count);

	if P_state.n_sw then arg_start = arg_max;	/* &n = last arg */
	else do;
	     arg_start = numeric_arg;
	     if arg_start > arg_max then return;	/* no arg => null string */
	end;

	if P_state.f_sw & ^P_state.n_sw then arg_limit = arg_max;
	else arg_limit = arg_start;

	command_args_ptr = abs_data.arg_ptr;
	command_args_count = abs_data.arg_count;

	do arg_index = arg_start to arg_limit;		/* append each ec arg in range */
						/* arg_limit = max (#args, #defaults) */
	     if arg_index > abs_data.arg_count then do;	/* see if default is defined */
		command_args_ptr = abs_data.default_arg_ptr;
		command_args_count = abs_data.default_arg_count;
		if command_args (arg_index).ptr = null then  /* &undefined = no default value */
		     go to NEXT_ARG;
	     end;

	     if P_state.r_sw then

		call add_quoted_output (P_state.optr_len, command_arg, P_state.r_sw);

	     else call parse_value (P_state, command_arg);

	     if arg_index < arg_limit then call parse_value (P_state, " ");
NEXT_ARG:	end;

	return;

EXPAND (2):					/* variable reference */
VAR_REF:
	A_xd.expanded_sw = "1"b;
	if P_arg = "" then call error ("Invalid variable reference ""&()""");
	if verify (P_arg, DIGITS) = 0 & P_arg ^= "" then do;  /* &(3), etc. */
	     P_state.keyword = PARAM_KEYWORD;
	     go to START;				/* convert numeric arg and retry as parameter */
	end;

	if abs_data.variables_ptr = null then abs_data.variables_ptr = init_variables ();  /* this ec's value seg */

	call value_$get_alloc (abs_data.variables_ptr, "01"b,  /* call this entry because it allocates */
	     (P_arg), A_xd.area_ptr, value_ptr, value_len, code);
	if code ^= 0 then
	     if code ^= error_table_$oldnamerr then do;
		A_code = code;
		A_xd.error_msg = "Error in local value assignments.";
		go to RETURN;
	     end;
	     else if P_arg = "" then call error ("No value for null string.");
	     else call error ("No value for """ || P_arg || """");

	if P_state.q_sw | P_state.r_sw then
	     call add_quoted_output (P_state.optr_len, value_str, P_state.r_sw);

	else call add_output (P_state.optr_len, value_str);

	if value_str = "" & parse_args_sw then null_arg_sw = "1"b;

	free value_str in (xd_area);

	return;

EXPAND (3):					/* active function reference &[...] */
	A_xd.expanded_sw = "1"b;
	value_ptr = addr (value_buffer);		/* start with this and see if big enough */
	value_len = maxlength (value_buffer);
CALL_EVALUATE:

	if ec_data_ptr ^= null () then
	     if codeptr (ec_data.eval_string) ^= null () then do;	/* an af evaluation routine was specified */
		call ec_data.eval_string (null, (P_arg), P_state.keyword.af_type, value_var_str, code);
		go to EVALUATE_CALLED;
	     end;
	call cu_$evaluate_active_string (null, (P_arg), P_state.keyword.af_type, value_var_str, code);
EVALUATE_CALLED:
	if code ^= 0 then do;
	     if code = error_table_$command_line_overflow then do;
		if value_len > maxlength (value_buffer) then free value_var_str in (based_area);

		value_len = value_len * 2;
		alloc_err_sw = "0"b;
		on area alloc_err_sw = "1"b;
		on bad_area_format alloc_err_sw = "1"b;
		on bad_area_initialization alloc_err_sw = "1"b;

		allocate value_var_str in (based_area) set (value_ptr);

		revert area;
		revert bad_area_format;
		revert bad_area_initialization;

		if ^alloc_err_sw then go to CALL_EVALUATE;
	     end;
	     A_code = code;
	     A_xd.error_msg = "Evaluating active function.";
	     go to RETURN;
	end;

	if P_state.keyword.af_type = BAR_BAR_BK_TYPE then

	     if value_var_str = "" & nest_level = 1 then call add_arg (P_state);

	     else call add_output (P_state.optr_len, rtrim (value_var_str));

	else call parse_value (P_state, rtrim (value_var_str));

	if value_len > maxlength (value_buffer) then free value_var_str in (based_area);

	return;

EXPAND (4):					/* &condition_info_ptr */
	go to COND_INFO_PTR;

EXPAND (5):					/* &cond_info_ptr */
COND_INFO_PTR:
	call ioa_$rsnnl ("^p", switch_name, i, abs_data.condition_info.info_ptr);

	call add_output (P_state.optr_len, substr (switch_name, 1, i));

	return;

EXPAND (6):					/* &condition_name */
	go to COND_NAME;

EXPAND (7):					/* &cond_name */
COND_NAME:
	if abs_data.on_info.in_handler_sw then	/* null string if not in &on unit */
	     call add_output (P_state.optr_len, rtrim (abs_data.on_info.condition_name));

	return;

EXPAND (8):					/* &ec_dir */
	call hcs_$fs_get_path_name (input_string.ptr, path_string, i, (""), code);

	call add_quoted_output (P_state.optr_len, substr (path_string, 1, i), QDOUBLE);

	return;

EXPAND (9):					/* &ec_name */
	call add_quoted_output (P_state.optr_len, ec_name, QDOUBLE);
	return;

EXPAND (10):					/* &ec_path */
	call add_quoted_output (P_state.optr_len, ec_path, QDOUBLE);
	return;

EXPAND (11):					/* &ec_switch */
	if ec_data.switch_ptr = null then switch_name = "user_i/o";
	else switch_name = ec_data.switch_ptr -> iocb.name;

	call add_quoted_output (P_state.optr_len, rtrim (switch_name), QDOUBLE);

	return;

EXPAND (12):					/* &handlers */
	if abs_data.cleanup_handler_ptr ^= null then value_buffer = """cleanup""";
	else value_buffer = "";

	do p = abs_data.first_handler_ptr repeat (p -> handler_node.next_ptr) while (p ^= null);
	     if value_buffer ^= "" then value_buffer = value_buffer || " ";
	     value_buffer = value_buffer || requote_string_ (rtrim (p -> handler_node.condition_name));
	end;

	call add_output (P_state.optr_len, (value_buffer));

	return;

EXPAND (13):					/* &in_handler (NOT IMPLEMENTED) */
	go to BAD_AMP_WORD;

EXPAND (14):					/* &is_absin */
	call add_output (P_state.optr_len, (TF (fixed (A_xd.is_absin))));

	return;

EXPAND (15):					/* &is_active_function */
	go to IS_AF;

EXPAND (16):					/* &is_af */
IS_AF:
	call add_output (P_state.optr_len, (TF (fixed (A_xd.is_af))));

	return;

EXPAND (17):					/* &is_attached */
	call add_output (P_state.optr_len, (TF (fixed (abs_data.attach.victim_ptr ^= null))));

	return;

EXPAND (18):					/* &is_defined */
	if verify (P_arg, DIGITS) = 0 & P_arg ^= "" then do;  /* for number: true if ec arg or defined by &default */
	     numeric_arg = cv_dec_check_ ((P_arg), code);
	     if code ^= 0 then go to IS_VAR;
	     if numeric_arg <= abs_data.arg_count then tf_string = "true";
	     else if numeric_arg > abs_data.default_arg_count then tf_string = "false";
	     else do;
		command_args_ptr = abs_data.default_arg_ptr;
		command_args_count = abs_data.default_arg_count;
		if command_args (numeric_arg).ptr = null then tf_string = "false";
		else tf_string = "true";
	     end;

	     call add_output (P_state.optr_len, (tf_string));

	     return;
	end;
IS_VAR:						/* for non-numeric: true if defined by &set */
	if abs_data.variables_ptr = null then abs_data.variables_ptr = init_variables ();

	call add_output (P_state.optr_len,
	     (TF (fixed (value_$defined (abs_data.variables_ptr, "01"b, (P_arg), code)))));

	if code ^= 0 then call error ("Format error in variables.");

	return;

EXPAND (19):					/* &is_input_line */
	call add_output (P_state.optr_len, (TF (fixed (A_xd.is_input))));

	return;

EXPAND (20):					/* &n */
	call ioa_$rsnnl ("^d", short_string, 32, abs_data.arg_count);

	call add_output (P_state.optr_len, (short_string));

	return;

EXPAND (21):					/* &quote (...) (NOT IMPLEMENTED) */
/*
	call add_quoted_output (P_state.optr_len, (P_arg), QDOUBLE);
*/

	go to BAD_AMP_WORD;

EXPAND (22):					/* &requote (...) (NOT IMPLEMENTED) */
/*
	call add_quoted_output (P_state.optr_len, (P_arg), REQUOTE);
*/

	go to BAD_AMP_WORD;

EXPAND (23):					/* &unquote (...) (NOT IMPLEMENTED) */
	go to BAD_AMP_WORD;

EXPAND (24):					/* &was_attached */
	call add_output (P_state.optr_len, (TF (fixed (abs_data.in_handler_sw & abs_data.was_attached_sw))));

	return;

EXPAND (25):					/* &AMP */
	call add_output (P_state.optr_len, copy ("&", numeric_arg));
	return;

EXPAND (26):					/* &BS */
	call add_output (P_state.optr_len, copy (BS, numeric_arg));
	return;

EXPAND (27):					/* &CR */
	call add_output (P_state.optr_len, copy (CR, numeric_arg));
	return;

EXPAND (28):					/* &FF, &NP */
	call add_output (P_state.optr_len, copy (FF, numeric_arg));
	return;

EXPAND (29):					/* &HT */
	call add_output (P_state.optr_len, copy ("	", numeric_arg));
	return;

EXPAND (30):					/* &LF */
	call add_output (P_state.optr_len, copy (NL, numeric_arg));
	return;

EXPAND (31):					/* &NL */
	call add_output (P_state.optr_len, copy (NL, numeric_arg));
	return;

EXPAND (32):					/* &NP = &FF */
	call add_output (P_state.optr_len, copy (FF, numeric_arg));
	return;


EXPAND (33):					/* &QT */
	call add_output (P_state.optr_len, copy ("""", numeric_arg));
	return;

EXPAND (34):					/* &SP */
	call add_output (P_state.optr_len, copy (" ", numeric_arg));
	return;

EXPAND (35):					/* &VT */
	call add_output (P_state.optr_len, copy (VT, numeric_arg));
	return;

end expand;
%page;
find_next_occurrence: proc (P_str, P_saved_pos, P_pos);

/* Find the next occurrence P_pos of the string P_str starting at A_xd.input_pos.
P_saved_pos is one of the saved "next occurrence" values in A_xd, e.g. A_xd.next_do_pos.
If the value of P_saved_pos is already beyond A_xd.input_pos, just set P_pos = P_saved_pos.
Otherwise, compute P_pos and set P_saved_pos = P_pos. */

dcl P_str char (*);
dcl (P_pos, P_saved_pos, i) fixed bin (21);

	if P_saved_pos >= A_xd.input_pos then P_pos = P_saved_pos;
	else do;
	     i = index (input, P_str);
	     if i = 0 then P_pos = MAX_CHARS;		/* agreed meaning is "no more left" */
	     else P_pos = A_xd.input_pos + i - 1;
	     P_saved_pos = P_pos;
	end;

end find_next_occurrence;
%page;
get_next_stmt: proc (A_ptr, A_len, A_pos, A_stmt);

/* For abs_io_v2_get_line's look-ahead: type, po & length of next stmt keyword */
dcl A_ptr ptr;
dcl (A_len, A_pos) fixed bin (21);
dcl 1 A_stmt aligned like expand_data.this_statement;
dcl str char (A_len) based (A_ptr);
dcl key_name char (32);
dcl (i, j, k) fixed bin (21);

	got_next_stmt = "1"b;     
 	if abs_data.noabort then do;
 	     i = index ( substr (str, A_pos), NL) + A_pos - 1;
 	     j = i + 1;
 	     abs_data.position = j;
 	     abs_data.limit = i;
	end;
	i = verify (substr (str, A_pos), WHITE || NL);
	if i = 0 then do;
NO_NEXT:	     A_stmt.action = UNDEFINED;			/* no next statement */
	     A_stmt.pos, A_stmt.len, A_stmt.keyword_len = 0;

	     return;
	end;

	j = A_pos + i - 1;
SEE_NEXT:	if substr (str, j, 1) ^= "&" then do;		/* a non-control line */
	     A_stmt.action, A_stmt.len, A_stmt.keyword_len = 0;
	     return;
	end;

	if substr (str, j + 1, 1) = "-" then do;	/* skip &- comment line */
	     k = index (substr (str, j), NL);
	     if k = 0 then go to NO_NEXT;
	     j = j + k;
	     j = j + verify (substr (str, j), WHITE) - 1;	/* skip leading white space */
	     go to SEE_NEXT;
	end;

	else do;
	     k = search (substr (str, j), WHITE || NL || "(");  /* find end of next token (stmt keyword?) */
	     if k = 0 then key_name = substr (str, j);
	     else key_name = substr (str, j, k - 1);

	     A_stmt.action = lookup_stmt (key_name);

	     if A_stmt.action ^= 0 then
		A_stmt.len, A_stmt.keyword_len = length (rtrim (key_name));
	     else A_stmt.len, A_stmt.keyword_len = 0;	/* non-control line */
	end;

	A_stmt.pos = j;

end get_next_stmt;
%page;
get_quoted_string: proc (P_str, P_ipos, P_state, P_q_sw);

/* Called at &", finds matching end quote and saves string */

dcl P_str char (*);
dcl P_ipos fixed bin (21);
dcl 1 P_state like state;
dcl P_q_sw bit (1);

dcl inside_quotes_sw bit (1);
dcl (i, ipos) fixed bin (21);

	inside_quotes_sw = "1"b;			/* caller saw the &" */
	ipos = P_ipos;

	do while (inside_quotes_sw);

	     i = index (substr (P_str, ipos), """");
	     if i = 0 then call error ("Missing end quote for &""");

	     if ipos + i <= length (P_str) & substr (P_str, ipos + i, 1) = """" then do;
						/* imbedded double quote (= 1 quote) */

		if P_q_sw then call add_quoted_output (P_state.optr_len, substr (P_str, ipos, i - 1) || """", "0"b);

		else call add_output (P_state.optr_len, substr (P_str, ipos, i - 1) || """");

		ipos = ipos + i + 1;
	     end;
	     else do;				/* single quote: closes string */

		if P_q_sw then call add_quoted_output (P_state.optr_len, substr (P_str, ipos, i - 1), "0"b);

		else call add_output (P_state.optr_len, substr (P_str, ipos, i - 1));

		P_ipos = ipos + i;
		inside_quotes_sw = "0"b;
	     end;
	end;

	if output = "" & parse_args_sw then null_arg_sw = "1"b;

end get_quoted_string;
%page;
grow_parsed_args: proc;

/* Allocates more room for the parsed_args structure */
/* Implicit arguments are parsed_args_ptr and parsed_args_count */

dcl old_parsed_args_ptr ptr;

	old_parsed_args_ptr = parsed_args_ptr;
	parsed_args_count = parsed_args_count * 2;	/* more room */

	allocate parsed_args in (xd_area) set (parsed_args_ptr);

	parsed_args_ptr -> parsed_args.count = old_parsed_args_ptr -> parsed_args.count;
	parsed_args_ptr -> parsed_args = old_parsed_args_ptr -> parsed_args;
	A_xd.parsed_args_ptr = parsed_args_ptr;

	free old_parsed_args_ptr -> parsed_args in (xd_area);

end grow_parsed_args;
%page;
init_variables: proc returns (ptr);

/* Gets ptr to this ec's private "value seg" */

dcl value_header (72) fixed aligned based;
dcl variables_ptr ptr;
dcl code fixed bin (35);

	allocate value_header in (abs_data.work_area) set (variables_ptr);

	call value_$init_seg (variables_ptr, 1 /* non-shareable */, addr (abs_data.work_area), 0, code);
	if code ^= 0 then call error ("Unable to allocate variables.");

	return (variables_ptr);

end init_variables;
%page;
known: proc (P_keyword) returns (bit (1));

/* TRUE & fills in P_keyword if P_keyword.name is found in NAMES */

dcl 1 P_keyword like state.keyword;
dcl i fixed bin;

	i = index (NAMES_STRING, P_keyword.name || " ");

	if i = 0 then return ("0"b);
	i = divide (i + length (NAMES (1)), length (NAMES (1)), 17, 0);
	P_keyword.number = i + 3;			/* 1 = PARAM; 3 = VAR; 3 = AF */
	unspec (P_keyword.name_switches) = NAME_SWITCHES (i);
	unspec (P_keyword.param_switches) = "0"b;
	return ("1"b);

end known;
%page;
known_dont_expand: proc (P_name) returns (bit (1));

/* TRUE if P_name is found in DONT_EXPAND (a &keyword that's a stmt control-arg) */

dcl P_name char (32) varying;
dcl i fixed bin;

	i = index (DONT_EXPAND_STRING, P_name || " ");

	return (i ^= 0);

end known_dont_expand;
%page;
known_param: proc (P_keyword, P_name) returns (bit (1));

/* TRUE & fills in P_keyword for parameter prefixes &q, &r, etc. */

dcl 1 P_keyword like state.keyword;
dcl P_name char (32) varying;
dcl i fixed bin;

	i = index (PARAMS_STRING, P_keyword.name || " ");

	if i = 0 then return ("0"b);
	i = divide (i + length (PARAMS (1)), length (PARAMS (1)), 17, 0);
	P_keyword = PARAM_KEYWORD;
	P_keyword.name = P_name;
	unspec (P_keyword.param_switches) = PARAM_SWITCHES (i);
	return ("1"b);

end known_param;
%page;
lookup_stmt: proc (A_key_name) returns (fixed bin);

/* Sees whether A_key_name is a beginning-of-stmt keyword */

dcl A_key_name char (32);

	return (divide (index (STMTS_STRING, A_key_name) + length (STMTS (1)) - 1,
		length (STMTS (1)), 17, 0));

end lookup_stmt;
%page;
parse_value: proc (P_state, P_str);

/* Adds to the output string, meanwhile parsing into arguments */

dcl 1 P_state like state;
dcl P_str char (*);
dcl (vbreak, vstart) fixed bin (21);

	if parse_args_sw & nest_level < 2 & P_state.quote_factor = 1 & ^inside_quotes_sw then do;


	     vstart = 1;
PARSE_ARG:
	     vbreak = search (substr (P_str, vstart), WHITE || "&""");
	     if vbreak ^= 0 then do;

		call add (substr (P_str, vstart, vbreak - 1));

		if substr (P_str, vstart + vbreak - 1, 1) = "&" then
		     if substr (P_str, vstart + vbreak, 1) = """" then do;  /*  &"..."  */
			vstart = vstart + vbreak + 1;

			call get_quoted_string (P_str, vstart, P_state, P_state.q_sw);
		     end;
		     else vstart = vstart + vbreak;	/* continue searching */

		else if substr (P_str, vstart + vbreak - 1, 1) = """" then do;  /* handle regular "..." too */
		     vstart = vstart + vbreak;	/* position past the first quote */

		     call get_quoted_string (P_str, vstart, P_state, P_state.q_sw);
		end;

		else do;
		     if verify (output, WHITE) ^= 0 then call add_arg (P_state);

		     vbreak = vstart + vbreak - 1;	     /* actual position of the start of the white space */
		     vstart = verify (substr (P_str, vbreak), WHITE);
		     if vstart ^= 0 then do;
			vstart = vbreak + vstart - 1;
			go to PARSE_ARG;
		     end;
		end;
	     end;

	     else call add (substr (P_str, vstart));
	end;

	else call add (P_str);


add: proc (P_str);

/* Appends the string either quote_doubled or plain depending on P_state.q_sw */

dcl P_str char (*);

	if P_state.q_sw then call add_quoted_output (P_state.optr_len, P_str, "0"b);

	else call add_output (P_state.optr_len, P_str);

end add;

end parse_value;
%page;
pop_state: proc (P_nest_level, P_state);

/* Process close paren */

dcl P_nest_level fixed bin;
dcl 1 P_state like state;

	P_nest_level = max (P_nest_level - 1, 1);
	P_state = state_stack (P_nest_level);
	alloc_info = alloc_stack (P_nest_level);

end pop_state;
%page;
print_trace: proc (P_str, P_trace, P_control_sw);

dcl P_str char (*);
dcl 1 P_trace aligned like abs_data.command_line;
dcl P_control_sw bit (1);
dcl control_word char (32) varying;

	if ^trace_sw then return;

	if P_control_sw = CONTROL then control_word = rtrim (STMTS (abs_data.this_action)) || " ";
	else control_word = "";

	if P_trace.iocb = null then P_trace.iocb = iox_$user_output;

	call ioa_$ioa_switch_nnl (P_trace.iocb, P_trace.prefix || control_word || "^a^/", P_str);

end print_trace;
%page;
push_state: proc (P_nest_level, P_state);

/* Processes open paren */

dcl P_nest_level fixed bin;
dcl 1 P_state like state;

	state_stack (P_nest_level) = P_state;
	alloc_stack (P_nest_level) = alloc_info;
	P_nest_level = P_nest_level + 1;
	state.optr = addcharno (state.optr, state.olen);
	state.omax_len = state.omax_len - state.olen;	/* stay within allocated range */
	state.olen = 0;
	state.quote_factor, state.qscan_start = 1;

end push_state;
%page;
save_arg: proc;

/* This procedure allocates a bigger saved_arg buffer if necessary to hold a long &[...] or other arg */

	if state.olen > saved_arg_len then do;

	     if saved_arg_allocated_sw then free saved_arg_ptr -> saved_arg in (xd_area);

	     saved_arg_len = state.olen;
	     if A_xd.area_ptr = null then A_xd.area_ptr = get_system_free_area_ ();

	     allocate saved_arg in (xd_area) set (saved_arg_ptr);

	     saved_arg_allocated_sw = "1"b;
	end;

	saved_arg = output;

end save_arg;
%page;
trace_comment: proc (P_str);

dcl P_str char (*);

	if abs_data.comment_line.prefix = "" then

	     call print_trace ("&-" || P_str, abs_data.comment_line, NONCONTROL);

	else call print_trace (P_str, abs_data.comment_line, NONCONTROL);

end trace_comment;
%page;
trace_expanded: proc (P_state, P_buffer);

dcl 1 P_state like state;
dcl P_buffer char (*) varying;
dcl open_char char (4) varying;
dcl i fixed bin;

	     P_buffer = "";

	     if parse_args_sw then do;		/* have to print parsed args too */
		if A_xd.parsed_args_ptr ^= null then
		     do parsed_arg_index = 1 to A_xd.parsed_args_ptr -> parsed_args.count;
						/* traced &set line should show arg grouping */
			if search (parsed_arg, """" || WHITE) ^= 0 & abs_data.this_action = SET_ACTION then
			     P_buffer = P_buffer || requote_string_ (parsed_arg) || " ";
			else P_buffer = P_buffer || parsed_arg || " ";
		     end;
	     end;

	     do i = 1 to nest_level - 1;			/* pick up expanded text of each nesting */
		if state_stack (i).olen > 0 then
		     P_buffer = P_buffer ||
			substr (state_stack (i).optr -> output, 1, state_stack (i).olen);

		if state_stack (i).keyword.number = 0 then open_char = "";
		else if state_stack (i).keyword.number = AF_REF then
		     if state_stack (i).keyword.af_type = BAR_BAR_BK_TYPE then open_char = "||[";
		     else if state_stack (i).keyword.af_type = BAR_BK_TYPE then open_char = "|[";
		     else open_char = "[";
		else open_char = "(";
		P_buffer = P_buffer || state_stack (i).keyword.name || open_char;
	     end;
	     if P_state.olen > 0 then P_buffer = P_buffer || output;

end trace_expanded;
%page;
trace_unexpanded: proc (P_str, P_trace);

dcl P_str char (*);
dcl 1 P_trace aligned like abs_data.command_line;

	if substr (P_str, 1, 5) = "&then" | substr (P_str, 1, 5) = "&else" | P_str = " &do" then return;

	if P_trace.iocb = null then P_trace.iocb = iox_$user_output;

	call ioa_$ioa_switch_nnl (P_trace.iocb, P_trace.prefix || "^a^/", P_str);

end trace_unexpanded;
%page;
/* OTHER EXTERNAL ENTRIES TO abs_io_expand_ */


set: entry (A_vars_ptr, A_var, A_val, A_code);

/* Called by abs_io_v2_get_line to perform &set using abs_data.variables_ptr */

	delete_sw = "0"b;
SET:
	if verify (A_var, DIGITS) = 0 & A_var ^= "" then  /* parameter reference */
	     call error ("Attempt to &set the value of an argument.");
	else do;

	     if A_vars_ptr = null then A_vars_ptr = init_variables ();

	     if delete_sw then call value_$delete (A_vars_ptr, "01"b, A_var, A_code);

	     else call value_$set (A_vars_ptr, "01"b, A_var, A_val, "", A_code);
	end;

	return;

/* end of abs_io_expand_$set */


delete: entry (A_vars_ptr, A_var, A_val, A_code);

/* Called by abs_io_v2_get_line to implement "&set var_name &undefined" */
/* NOTE: calling sequence has to be the same as $set to use common code. */

	delete_sw = "1"b;
	go to SET;

/* end of abs_io_expand_$delete */
%page;
%include abs_io_data;
%page;
%include abs_io_expand;
%page;
%include abs_io_handler_node;
%page;
%include ec_data;
%page;
%include iocb;



end abs_io_expand_;
