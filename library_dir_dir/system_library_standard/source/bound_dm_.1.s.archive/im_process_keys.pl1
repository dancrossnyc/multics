/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
   *                                                         *
   *********************************************************** */

/* DESCRIPTION:

         This subroutine takes all of the leaf keys in a range (specified by
     the element_id of the low key and the element_id of the high key), and
     processes those which pass the supplied filter (identified by
     p_specification_ptr) according to the specified operation (get, delete,
     count, or position).  

     Getting keys consists of creating simple_typed_vector representations of
     them and adding these STVs to a typed_vector_array, which is returned to
     the caller.  Deleting keys is accomplished by calling im_general_delete
     on each key to be deleted.  The "count" processing is simply achieved by
     incrementing a counter. The "position" processing simply stops with the
     first key found to satisfy the filters.

     The index_cursor is set in different ways, depending on the operation
     (see SET_INDEX_CURSOR for the details).

     All of the external entries have the following input parameters in common:
     p_index_cursor_ptr, p_work_area_ptr, p_field_table_ptr, p_id_list_ptr,
     p_specification_ptr, p_and_group_id_list_ptr,
     p_number_of_fully_structural_fields, p_partial_structural_field_id, and
     p_first_key_id_string, p_last_key_id_string.
     
     
     They all have p_code as an output parameter.
     
     For the other parameters:
     
     
     get - p_typed_vector_array_ptr (input/output)

     position - p_number_of_keys_accepted (input/output)
     
     delete - p_key_count_array_ptr, p_number_of_keys_accepted (input/output)
     
     count - p_number_of_keys_accepted (input/output)


     POSITION_INFO:     

     All of the information which is global in this procedure is gathered
     together in a structure called global_position_info.  The global data is
     largely concerned with information related to (or derived from) the
     current position in the index, hence the name of the structure.  There
     are 3 major types of procedures which know about the structure of
     position_info, the GET_*, SET_* and RESET_* procedures.  The other
     procedures which know about the structure of position_info are NOTE_*
     procedures, INITIALIZE_POSITION, NODE_IS_DELETED,
     DECREMENT_LAST_KEY_ID_SLOT_INDEX, and FREE_VECTOR_STORAGE.  Each of these
     procedures only references a very limited portion of the position_info
     structure, using the other procedures (where possible) to access other
     portions of the position_info structure.
     
     ***All other procedures rely entirely on the aforementioned procedures to
     use any of the data in position_info.***
     
     The kind of data in position_info is logically divided into variables
     and constants.  The constants are only referenced by GET_* procedures,
     and never change after being initialized by INITIALIZE_POSITION.
     
     The variables are again of two kinds, those for which the value is
     generated from other info in position_info,  and those which are
     explicitly set (via a SET_* routine).  Each of the generated variables in
     position_info is dependent on the value of (at least) one of the
     explicitly set values.  Therefore, whenever a SET_* procedure is invoked,
     it must RESET_* all of the generated variables which depend on it, as
     well as RESET_*'ing the explicitly set values whose correct
     interpretation depends on the variable being SET_*.
     
     A GET_* of a generated variable will generate the value for that variable
     if there is no valid value for it already.  (RESET_*'ing a generated
     variable sets the variable to "invalid", as does INITIALIZE_POSITION.)

     The elements of the position_info structure are as follows:

     - entire_vector_ptr
         This points at a vector which contains all of the fields in the
       current key.  This value is GENERATED by GET_ENTIRE_VECTOR, RESET by
       RESET_VECTORS.  It depends on key_buffer_contains_current_key.

     - field_table_ptr
         This is a CONSTANT, from p_field_table_ptr.  

     - first_key_id_string
         This is a CONSTANT from p_first_key_id_string.  

     - flags.header_buffer_contains_current_header
         Indicates the validity of the header buffer contents.  This value is
       GENERATED by GET_CI_HEADER, RESET by RESET_CI_HEADER. It depends on
       node_id. 

     - flags.key_buffer_contains_current_key
         Indicates the validity of the key buffer contents.  This value is
       GENERATED by GET_KEY, RESET by RESET_KEY. It depends on slot_index.

     - flags.node_is_deleted
         Indicates that the current node was deleted by the deletion of the
       current key. This value is SET by NOTE_NODE_IS_DELETED, RESET by
       RESET_NODE_ID. 

     - flags.vector_in_use
         Indicates the selected_vector is to be saved for use in the output.
       This value is SET by NOTE_VECTOR_IN_USE, RESET by RESET_VECTORS.

     - header_buffer_length
         This is a CONSTANT from length(unspec(local_leaf_ci_header)). 

     - header_buffer_ptr
         This buffer holds the leaf_ci_header for the current node.  This is a
       CONSTANT from addr(local_leaf_ci_header). 

     - id_list_ptr
         This is a CONSTANT from p_id_list_ptr. 

     - index_cursor_ptr
         This is a CONSTANT from p_index_cursor_ptr. 

     - key_buffer_length
         This is a CONSTANT from  length(key_buffer). 

     - key_buffer_ptr
         This buffer holds the data string for the current leaf key.  This is
       a CONSTANT from addr(key_buffer).

     - last_key_id_string
         This is SET by INITIALIZE_POSITION and DECREMENT_LAST_KEY_SLOT_INDEX. 

     - lk_string_length
         This is the length of the data string for the current leaf key. This
       value is GENERATED by GET_KEY, RESET by RESET_KEY.  It depends on
       slot_index.

     - node_id
         The current node id.  This value is SET by SET_NODE_ID, RESET by
       RESET_NODE_ID. 

     - node_ptr
         The ptr to the current node.  This value is GENERATED by
       GET_NODE_PTR, RESET by RESET_NODE_PTR.  It depends on node_id. 

     - selected_vector_ptr
         This points to a vector which contains only those fields listed by
       p_id_list. This value is GENERATED by GET_SELECTED_VECTOR, RESET by
       RESET_VECTORS.  It depends on key_buffer_contains_current_key.

     - slot_index
         This is the slot index of the current key.  This value is SET by
       SET_SLOT_INDEX, RESET by RESET_SLOT_INDEX. 

     - work_area_ptr
         This is a CONSTANT from p_work_area_ptr. 

*/

/* HISTORY:

Written by Lindsey L. Spratt, 06/21/82.
Modified:
07/07/82 by Lindsey Spratt:  Added the use of the sequential_specification.
	  Added the p_sequential_specification_ptr to the calling sequence.
07/13/82 by Lindsey Spratt:  Added the p_range and p_range_type parameters.
	  If p_range is greater than 0, then no more than p_range vectors
	  will be put in the typed_vector_array (including any which may
	  have already been present in the array).  If p_range_type equals
	  HIGH_RANGE_TYPE, then the vectors will be taken from the high end
	  of the given interval first (i.e., get_keys_in_reverse is turned
	  on).
08/06/82 by Lindsey Spratt:  Changed from im_add_keys_to_array to
	  im_process_keys.  There are now two entry points, get and delete.
	  A "get" switch was added to distinguish which entry was called.
	  The delete entry invokes im_general_delete on all of the matching
	  keys.
08/09/82 by Matthew Pierret:  Removed offset and length arguments from calls
            to collection_manager_$get_element.
08/17/82 by Matthew Pierret:  Changed call to im_compare_sequential to call to
            data_mgmt_util_$compare_sequential.
08/19/82 by Lindsey Spratt:  Added the p_id_list_ptr parameter to the "get"
	  call and passed the pointer on to the dmu_$cv_string_to_vector
	  utility.
08/26/82 by Lindsey Spratt:  Added the "position" entry.  Added the "delete"
	  switch which , in combination with the "get" switch, distinguishes
	  between the three entries, get, delete and position.
	  Also, added setting of the index_cursor to the correct position.
10/07/82 by Lindsey Spratt:  Changed to use the search_specification version
	  2. Added the "count" entry.  Changes to all calling sequences.
10/18/82 by Lindsey Spratt:  Fixed to create a "full" simple_typed_vector for
	  the call to im_compare_subset, rather than use the p_id_list_ptr.
	  This vector is freed when using the "get" entry and the
	  p_id_list_ptr is not equal to null.
10/19/82 by Lindsey Spratt:  Changed to get the last key positioned to, when
	  executing the "position" entry and the last key positioned to was
	  not gotten in the course of doing comparisons.  This is done so
	  that the index_cursor.key_check_value can be set.
10/21/82 by Lindsey Spratt:  Added code to implement the numeric specification.
10/27/82 by Lindsey Spratt:  Changed KEY_LOOP to always initialize
	  leaf_key_ptr to null, then for each place which needs to have the
	  leaf_key value to check that leaf_key_ptr ^= null before using the
	  value.  If it is null, then the value is
	  retrieved at that time.
10/29/82 by Lindsey Spratt:  Added updating of the key counts.  Changed the
	  calling sequence of delete to include the pointer to the
	  key_count_array.
11/09/82 by Lindsey Spratt:  Removed the index_header_ptr from all entry
	  sequences.  Changed to use new calling sequence of
	  im_general_delete which does not use the index_header_ptr.
12/09/82 by Lindsey Spratt:  Fixed to set the element_id_string when the
	  leaf_key_ptr is null and the current key is supposed to be deleted.
12/10/82 by Lindsey Spratt:  Fixed deletion to set the current_slot_index to 0
	  after a successful deletion of the last key in the current
	  ci.  The various positioning activities were changed to be
	  cognizant of this protocol.
01/20/83 by Matthew Pierret: Fixed to set p_typed_vector_array_ptr after
            allocating a new typed_vector_array.
02/28/83 by Lindsey Spratt:  Changed to use the new index_cursor (version 3)
	  and the new im_set_cursor module for setting it.
03/23/83 by Lindsey Spratt:  Changed to use version 2 of the field_table.
	  Also, uppercased the internal procedure names.
04/28/83 by Lindsey L. Spratt:  Fixed the AFTER_END routine to return true if
            the current CI is the "last" one and the next key to be processed
            is in the next CI.
05/23/83 by Matthew Pierret: Changed to use version 4 of specification_head.
            Split dm_specification.incl.pl1 into dm_specification_head,
            dm_specification and dm_range_types.incl.pl1.
11/07/83 by Lindsey L. Spratt:  Converted to use the buffered access method of
            the collection_manager_.  Also, made minor changes to the coding
            style including:  Added unique prefixes to all variables local to
            an internal procedure; and, converted all error reporting to be
            done through an internal procedure ERROR_RETURN, so that calls to
            internal procedures only return when they are successful and no
            code need be passed or checked by the caller.
11/17/83 by Lindsey L. Spratt:  Fixed to put a modified node buffer after the
            KEY_LOOP.
11/28/83 by Lindsey L. Spratt:  Fixed to not replace the current ci/node when
            the node is deleted.
03/27/84 by Matthew Pierret:  Changed to get a pointer to the current ci/node
            instead of setting up a buffer, and accessing it via 
            collection_manager_$simple_get_element_ptr. Replaced 
            SETUP_NODE_BUFFER with GET_NEW_NODE, which gets a pointer to a
            ci/node and sets the value of the current node. Removed all
            logic relating to replacing the node buffer (PUT_NODE_BUFFER,
            current_node_has_been_modified) as modifications are now 
            actually done by im_general_delete (and its subroutines).
05/04/84 by Matthew Pierret:  Changed to use FIELD_TABLE_VERSION_3.  Chnaged
            value of myname to be im_process_keys.
05/10/84 by Matthew Pierret:  Changed to align key_buffer on an even-word
            boundary.
06/07/84 by Matthew Pierret:  Re-named cm_$simple_get_element_ptr to
            cm_$simple_get_by_ci_ptr.
10/02/84 by Lindsey L. Spratt:  Changed to have $get as the main entry point
            (the proc statement label).  Changed a loop that was using
            (vector_slot_index + 1) as its initial value for its loop index to
            use the more meaningful (typed_vector_array.number_of_vectors +
            1).
10/17/84 by Lindsey L. Spratt:  Completely restructured the code.  Introduced
	  the position_info structure, added many internal procedures, and
	  added a great deal of documentation.
*/

/* format: style2,ind3 */

im_process_keys$get:
   proc (p_index_cursor_ptr, p_work_area_ptr, p_field_table_ptr, p_id_list_ptr, p_specification_ptr,
        p_and_group_id_list_ptr, p_number_of_fully_structural_fields, p_partial_structural_field_id,
        p_first_key_id_string, p_last_key_id_string, p_typed_vector_array_ptr, p_code);


/* START OF DECLARATIONS */
/* Parameter */

      dcl	    p_index_cursor_ptr     ptr parameter;
      dcl	    p_work_area_ptr	       ptr parameter;
      dcl	    p_field_table_ptr      ptr parameter;
      dcl	    p_id_list_ptr	       ptr parameter;
      dcl	    p_specification_ptr    ptr parameter;
      dcl	    p_and_group_id_list_ptr
			       ptr parameter;
      dcl	    p_number_of_fully_structural_fields
			       fixed bin (17);
      dcl	    p_partial_structural_field_id
			       fixed bin (17);
      dcl	    p_first_key_id_string  bit (36) aligned parameter;
      dcl	    p_last_key_id_string   bit (36) aligned parameter;
      dcl	    p_typed_vector_array_ptr
			       ptr parameter;
      dcl	    p_key_count_array_ptr  ptr parameter;
      dcl	    p_number_of_keys_accepted
			       fixed bin (35) parameter;
      dcl	    p_code	       fixed bin (35) parameter;

/* Automatic */

      dcl	    operation	       fixed bin init (0);

      dcl	    (number_of_keys_accepted, input_number_of_keys_accepted, position_count, range_size)
			       fixed bin (35) init (0);
      dcl	    finished	       bit (1) aligned;
      dcl	    (get_keys_in_reverse_order, is_search_specification, key_satisfies_specification, set_cursor)
			       bit (1) aligned init ("0"b);
      dcl	    key_count	       fixed bin (35);
      dcl	    1 local_leaf_ci_header like leaf_ci_header;
      dcl	    local_key_buffer       (DOUBLE_WORDS_PER_PAGE) fixed bin (71);
						/* Forces even-word alignment */

      dcl	    global_position_info_ptr
			       ptr init (null);

      dcl	    1 global_position_info aligned like position_info;


/* Based */

      dcl	    1 position_info	       aligned based,
	      2 entire_vector_ptr  ptr,
	      2 field_table_ptr    ptr,
	      2 first_key_id_string
			       bit (36) aligned,
	      2 flags	       aligned,
	        3 header_buffer_contains_current_header
			       bit (1) unaligned,
	        3 key_buffer_contains_current_key
			       bit (1) unaligned,
	        3 node_is_deleted  bit (1) unaligned,
	        3 vector_in_use    bit (1) unaligned,
	        3 pad	       bit (32) unaligned,
	      2 header_buffer_length
			       fixed bin (35),
	      2 header_buffer_ptr  ptr,
	      2 id_list_ptr	       ptr,
	      2 index_cursor_ptr   ptr,
	      2 key_buffer_length  fixed bin (35),
	      2 key_buffer_ptr     ptr,
	      2 last_key_id_string bit (36) aligned,
	      2 lk_string_length   fixed bin (35),
	      2 node_id	       fixed bin (24) unsigned,
	      2 node_ptr	       ptr,
	      2 selected_vector_ptr
			       ptr,
	      2 slot_index	       fixed bin (12) unsigned,
	      2 work_area_ptr      ptr;

      dcl	    key_buffer	       bit (BITS_PER_PAGE) aligned based (addr (local_key_buffer));

/* Builtin */

      dcl	    (addr, abs, bin, divide, length, null, string, unspec)
			       builtin;

/* Constant */

      dcl	    myname	       init ("im_process_keys") char (32) varying internal static options (constant);

      dcl	    NULL_PSEUDO_FIELD_VALUE
			       init ("0"b) bit (36) internal static options (constant);
      dcl	    IS_BEING_DELETED       init ("0"b) bit (1) aligned internal static options (constant);

      dcl	    (
	    COUNT_OPERATION	       init (1),
	    DELETE_OPERATION       init (2),
	    GET_OPERATION	       init (3),
	    POSITION_OPERATION     init (4),
	    BITS_PER_BYTE	       init (9),
	    BITS_PER_PAGE	       init (1024 * 36),
	    DOUBLE_WORDS_PER_PAGE  init (512),
	    VECTOR_SLOT_PAD	       init (100),
	    LIMIT_TO_STOP_INFINITE_LOOPING
			       init (1e6)
	    )		       fixed bin (35) internal static options (constant);

/* Entry */

      dcl	    hash_index_	       entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35)) returns (fixed bin (35));

      dcl	    im_general_delete      entry (ptr, ptr, ptr, bit (36) aligned, bit (1) aligned, fixed bin (35));
      dcl	    im_compare_subset      entry (ptr, ptr, ptr, bit (1) aligned, bit (*), fixed bin (35));
      dcl	    im_update_key_counts   entry (ptr, ptr, ptr, ptr, bit (1) aligned, ptr, bit (36) aligned, ptr,
			       fixed bin (35), ptr, fixed bin (35));

      dcl	    im_set_cursor$at_current
			       entry (ptr, bit (36) aligned, ptr, fixed bin (24), fixed bin (35));
      dcl	    im_set_cursor$no_current
			       entry (ptr, bit (36) aligned, ptr, fixed bin (24), fixed bin (35));
      dcl	    im_set_cursor$at_beginning
			       entry (ptr, bit (36) aligned, ptr, fixed bin (24), fixed bin (35));
      dcl	    im_set_cursor$at_end   entry (ptr, bit (36) aligned, ptr, fixed bin (24), fixed bin (35));

      dcl	    data_format_util_$compare_sequential
			       entry (ptr, ptr, ptr, fixed bin (17), fixed bin (17), bit (*), bit (1) aligned,
			       fixed bin (35));
      dcl	    sub_err_	       entry options (variable);
      dcl	    data_format_util_$cv_string_to_vector
			       entry (ptr, ptr, ptr, fixed bin (35), ptr, ptr, fixed bin (35));

/* External */

      dcl	    (
	    error_table_$unimplemented_version,
	    dm_error_$wrong_cursor_type,
	    dm_error_$bad_first_key_idx,
	    dm_error_$bad_last_key_idx,
	    dm_error_$bad_leaf_node,
	    dm_error_$programming_error
	    )		       fixed bin (35) ext;


/* END OF DECLARATIONS */

/* The main entry is - 
get:
   entry (p_index_cursor_ptr, p_work_area_ptr, p_field_table_ptr, p_id_list_ptr, p_specification_ptr,
      p_and_group_id_list_ptr, p_number_of_fully_structural_fields, p_partial_structural_field_id, p_first_key_id_string,
      p_last_key_id_string, p_typed_vector_array_ptr, p_code);
*/

      operation = GET_OPERATION;
      typed_vector_array_ptr = p_typed_vector_array_ptr;
      call CHECK_VERSION ((typed_vector_array.version), (TYPED_VECTOR_ARRAY_VERSION_2), "typed_vector_array");
      goto JOIN;

position:
   entry (p_index_cursor_ptr, p_work_area_ptr, p_field_table_ptr, p_specification_ptr, p_and_group_id_list_ptr,
        p_number_of_fully_structural_fields, p_partial_structural_field_id, p_first_key_id_string, p_last_key_id_string,
        p_number_of_keys_accepted, p_code);

      operation = POSITION_OPERATION;
      typed_vector_array_ptr = null;
      goto JOIN;

delete:
   entry (p_index_cursor_ptr, p_work_area_ptr, p_field_table_ptr, p_specification_ptr, p_and_group_id_list_ptr,
        p_number_of_fully_structural_fields, p_partial_structural_field_id, p_first_key_id_string, p_last_key_id_string,
        p_key_count_array_ptr, p_number_of_keys_accepted, p_code);
      operation = DELETE_OPERATION;
      typed_vector_array_ptr = null;
      goto JOIN;

count:
   entry (p_index_cursor_ptr, p_work_area_ptr, p_field_table_ptr, p_specification_ptr, p_and_group_id_list_ptr,
        p_number_of_fully_structural_fields, p_partial_structural_field_id, p_first_key_id_string, p_last_key_id_string,
        p_number_of_keys_accepted, p_code);

      operation = COUNT_OPERATION;
      typed_vector_array_ptr = null;
      goto JOIN;
%page;
/*   The operation of the top level of this program (starting with JOIN), is as
     follows:

     - Set up the global data (copied from the parameters, largely), and
       initialize various control variables based on the specification.
     - For a numeric_specification, make the current position whatever the spec
       says.

     - Find all of the keys between the current position and the end of the
       interval (last_key_id, if getting keys in forward order, first_key_id if
       getting keys in reverse order).
     - For each of these keys, check against the "filters" (the search_spec and
       the subset_spec).
     - For the keys which pass the filter, do the operation appropriate to the
       external entry (ADD_KEY_TO_OUTPUT for get, DELETE_KEY_FROM_INDEX for 
       delete, others just need to have the accepted-keys count incremented).

     - Finally, prepare for returning to the caller by setting the output
     parameters as appropriate.
*/

JOIN:
      p_code = 0;
      index_cursor_ptr = p_index_cursor_ptr;
      if index_cursor.type ^= INDEX_CURSOR_TYPE
      then call sub_err_ (dm_error_$wrong_cursor_type, myname, "s", null, 0,
	      "^/Expected an index cursor, type ^d. Received a cursor of type ^d.", INDEX_CURSOR_TYPE,
	      index_cursor.type);

      call CHECK_VERSION ((index_cursor.version), (INDEX_CURSOR_VERSION_3), "index_cursor");

      specification_head_ptr = p_specification_ptr;
      call CHECK_VERSION (specification_head.version, SPECIFICATION_VERSION_4, "specification");


      field_table_ptr = p_field_table_ptr;
      call CHECK_VERSION_CHAR (field_table.version, FIELD_TABLE_VERSION_3, "field_table");

      call INTERPRET_SPECIFICATION (p_specification_ptr, p_first_key_id_string, is_search_specification,
	 search_specification_ptr, numeric_specification_ptr, get_keys_in_reverse_order, range_size, position_count);

      global_position_info_ptr = addr (global_position_info);

      call INITIALIZE_POSITION (index_cursor_ptr, addr (local_leaf_ci_header), length (unspec (local_leaf_ci_header)),
	 addr (key_buffer), length (key_buffer), field_table_ptr, p_work_area_ptr, p_first_key_id_string,
	 p_last_key_id_string, p_id_list_ptr, get_keys_in_reverse_order, global_position_info_ptr);


      if operation = GET_OPERATION
      then number_of_keys_accepted, input_number_of_keys_accepted = typed_vector_array.number_of_vectors;
      else number_of_keys_accepted, input_number_of_keys_accepted = p_number_of_keys_accepted;

      finished = "0"b;

      if ^is_search_specification
      then call FIND_POSITION (get_keys_in_reverse_order, global_position_info_ptr, position_count, finished);

KEY_LOOP:
      do key_count = 1 to LIMIT_TO_STOP_INFINITE_LOOPING while (^finished);

         if is_search_specification
         then call SEARCH_SPEC_COMPARISON (search_specification_ptr, p_and_group_id_list_ptr,
	         p_number_of_fully_structural_fields, p_partial_structural_field_id, global_position_info_ptr,
	         key_satisfies_specification);
         else key_satisfies_specification = "1"b;

         if key_satisfies_specification & specification_head.subset_specification_ptr ^= null
         then call SUBSET_SPEC_COMPARISON (specification_head.subset_specification_ptr, global_position_info_ptr,
	         key_satisfies_specification);


         if key_satisfies_specification
         then
	  do;
	     set_cursor = "1"b;
	     if operation = GET_OPERATION
	     then call ADD_KEY_TO_OUTPUT (global_position_info_ptr, typed_vector_array_ptr, number_of_keys_accepted);
	     else if operation = DELETE_OPERATION
	     then call DELETE_KEY_FROM_INDEX (get_keys_in_reverse_order, global_position_info_ptr,
		     number_of_keys_accepted, p_key_count_array_ptr);
	     else number_of_keys_accepted = number_of_keys_accepted + 1;
	  end;


         call SETUP_NEXT_KEY (operation, is_search_specification, range_size, get_keys_in_reverse_order,
	    key_satisfies_specification, global_position_info_ptr, number_of_keys_accepted, finished);

      end KEY_LOOP;

      if key_count > LIMIT_TO_STOP_INFINITE_LOOPING
      then call sub_err_ (dm_error_$programming_error, myname, ACTION_CANT_RESTART, null, 0,
	      "^/This program was apparently infinitely looping processing a range of keys.
This either indicates a damaged index or an internal programming logic problem.
The first key id is ^.3b, and the last key id is ^.3b.", p_first_key_id_string, p_last_key_id_string);

      if operation = GET_OPERATION
      then
         do;
	  if get_keys_in_reverse_order
	  then call REVERSE_VECTOR_SLOTS (input_number_of_keys_accepted, typed_vector_array_ptr);
	  p_typed_vector_array_ptr = typed_vector_array_ptr;
         end;
      else p_number_of_keys_accepted = number_of_keys_accepted;


      if set_cursor
      then call SET_INDEX_CURSOR (operation, global_position_info_ptr);

MAIN_RETURN:
      return;



FINISH:
   proc ();
   end;

ERROR_RETURN:
   proc (er_p_code);
      dcl	    er_p_code	       fixed bin (35);
      p_code = er_p_code;
      call FINISH;
      goto MAIN_RETURN;
   end ERROR_RETURN;

%page;
ADD_KEY_TO_OUTPUT:
   proc (akto_p_position_info_ptr, akto_p_typed_vector_array_ptr, akto_p_number_of_keys_accepted);

      dcl	    akto_p_position_info_ptr
			       ptr parameter;
      dcl	    akto_p_typed_vector_array_ptr
			       ptr parameter;
      dcl	    akto_p_number_of_keys_accepted
			       fixed bin (35) parameter;

      dcl	    akto_code	       fixed bin (35) init (0);
      dcl	    akto_new_tva_ptr       ptr init (null);
      dcl	    akto_old_tva_ptr       ptr init (null);
      dcl	    akto_vector_ptr	       ptr;
      dcl	    akto_vector_slot_idx   fixed bin;
      dcl	    akto_work_area	       area based (akto_work_area_ptr);
      dcl	    akto_work_area_ptr     ptr init (null);


      call GET_SELECTED_VECTOR (akto_p_position_info_ptr, akto_vector_ptr);

      akto_p_typed_vector_array_ptr -> typed_vector_array.number_of_vectors =
	 akto_p_typed_vector_array_ptr -> typed_vector_array.number_of_vectors + 1;
      if akto_p_typed_vector_array_ptr -> typed_vector_array.number_of_vectors
	 <= akto_p_typed_vector_array_ptr -> typed_vector_array.number_of_vector_slots
      then akto_p_typed_vector_array_ptr
	      -> typed_vector_array
	      .vector_slot (akto_p_typed_vector_array_ptr -> typed_vector_array.number_of_vectors) = akto_vector_ptr;
      else
         do;
	  call GET_WORK_AREA (akto_p_position_info_ptr, akto_work_area_ptr);
	  tva_number_of_vector_slots =
	       akto_p_typed_vector_array_ptr -> typed_vector_array.number_of_vectors + VECTOR_SLOT_PAD;
	  tva_number_of_dimensions = akto_p_typed_vector_array_ptr -> typed_vector_array.number_of_dimensions;
	  tva_maximum_dimension_name_length =
	       akto_p_typed_vector_array_ptr -> typed_vector_array.maximum_dimension_name_length;

	  akto_old_tva_ptr = akto_p_typed_vector_array_ptr;

	  alloc typed_vector_array in (akto_work_area) set (akto_new_tva_ptr);

	  akto_new_tva_ptr -> typed_vector_array.version = TYPED_VECTOR_ARRAY_VERSION_2;
	  akto_new_tva_ptr -> typed_vector_array.number_of_vectors =
	       akto_old_tva_ptr -> typed_vector_array.number_of_vectors;
	  akto_new_tva_ptr -> typed_vector_array.dimension_table =
	       akto_old_tva_ptr -> typed_vector_array.dimension_table;
	  do akto_vector_slot_idx = 1 to akto_new_tva_ptr -> typed_vector_array.number_of_vectors - 1;
	     akto_new_tva_ptr -> typed_vector_array.vector_slot (akto_vector_slot_idx) =
		akto_old_tva_ptr -> typed_vector_array.vector_slot (akto_vector_slot_idx);
	  end;
	  akto_new_tva_ptr
	       -> typed_vector_array.vector_slot (akto_new_tva_ptr -> typed_vector_array.number_of_vectors) =
	       akto_vector_ptr;
	  do akto_vector_slot_idx = akto_new_tva_ptr -> typed_vector_array.number_of_vectors + 1
	       to akto_new_tva_ptr -> typed_vector_array.number_of_vector_slots;
	     akto_new_tva_ptr -> typed_vector_array.vector_slot (akto_vector_slot_idx) = null;
	  end;
	  free akto_old_tva_ptr -> typed_vector_array in (akto_work_area);
	  akto_p_typed_vector_array_ptr = akto_new_tva_ptr;
         end;
      akto_p_number_of_keys_accepted = akto_p_typed_vector_array_ptr -> typed_vector_array.number_of_vectors;

      call NOTE_VECTOR_IN_USE (akto_p_position_info_ptr);
   end ADD_KEY_TO_OUTPUT;
%page;
AFTER_END:
   proc (ae_p_position_info_ptr, ae_p_ci, ae_p_index) returns (bit (1) aligned);
      dcl	    ae_p_position_info_ptr ptr parameter;
      dcl	    ae_p_ci	       fixed bin (24) unsigned parameter;
      dcl	    ae_p_index	       fixed bin (12) unsigned parameter;

      dcl	    1 ae_last_key_id       based (addr (ae_last_key_id_string)) like element_id;
      dcl	    ae_last_key_id_string  bit (36) aligned;
      dcl	    1 ae_leaf_ci_header    based (ae_leaf_ci_header_ptr) like leaf_ci_header;
      dcl	    ae_leaf_ci_header_ptr  ptr;

      call GET_CI_HEADER (ae_p_position_info_ptr, ae_leaf_ci_header_ptr);
      call GET_LAST_KEY_ID (ae_p_position_info_ptr, ae_last_key_id_string);

      return ((ae_p_ci = ae_last_key_id.control_interval_id & (ae_p_index > ae_last_key_id.index | ae_p_index = 0))
	 | ((ae_p_index = 0 | ae_p_index > ae_leaf_ci_header.common.key_range.last)
	 & ae_leaf_ci_header.common.next_id = 0));	/* ae_p_index = 0 indicates that the current ci is empty. */
   end AFTER_END;

BEFORE_BEGINNING:
   proc (bb_p_position_info_ptr, bb_p_ci, bb_p_index) returns (bit (1) aligned);
      dcl	    bb_p_position_info_ptr ptr parameter;
      dcl	    bb_p_ci	       fixed bin (24) unsigned parameter;
      dcl	    bb_p_index	       fixed bin (12) unsigned parameter;

      dcl	    1 bb_first_key_id      based (addr (bb_first_key_id_string)) like element_id;
      dcl	    bb_first_key_id_string bit (36) aligned;
      dcl	    1 bb_leaf_ci_header    based (bb_leaf_ci_header_ptr) like leaf_ci_header;
      dcl	    bb_leaf_ci_header_ptr  ptr;

      call GET_CI_HEADER (bb_p_position_info_ptr, bb_leaf_ci_header_ptr);
      call GET_FIRST_KEY_ID (bb_p_position_info_ptr, bb_first_key_id_string);

      return ((bb_p_ci = bb_first_key_id.control_interval_id & bb_p_index < bb_first_key_id.index)
	 | (bb_leaf_ci_header.common.previous_id = 0 & bb_leaf_ci_header.common.key_range.first > bb_p_index));

   end BEFORE_BEGINNING;
%page;
CHECK_VERSION:
   proc (cv_p_received_version, cv_p_expected_version, cv_p_structure_name);

      dcl	    cv_p_received_version  fixed bin (35);
      dcl	    cv_p_expected_version  fixed bin (35);
      dcl	    cv_p_structure_name    char (*);

      if cv_p_received_version ^= cv_p_expected_version
      then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
	      "^/Expected version ^d of the ^a structure.
Received version ^d, instead.", cv_p_expected_version, cv_p_structure_name, cv_p_received_version);

   end CHECK_VERSION;

CHECK_VERSION_CHAR:
   proc (cvc_p_expected_version, cvc_p_received_version, cvc_p_structure_name);
      dcl	    (cvc_p_expected_version, cvc_p_received_version)
			       char (8) aligned;
      dcl	    cvc_p_structure_name   char (*) parameter;

      if cvc_p_expected_version ^= cvc_p_received_version
      then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
	      "^/Expected version ^a of the ^a structure.  
Received version ^a, instead.", cvc_p_expected_version, cvc_p_structure_name, cvc_p_received_version);
   end CHECK_VERSION_CHAR;
%page;
DECREMENT_LAST_KEY_SLOT_INDEX:
   proc (dlksi_p_position_info_ptr);
      dcl	    dlksi_p_position_info_ptr
			       ptr parameter;
      dcl	    1 dlksi_p_position_info
			       based (dlksi_p_position_info_ptr) aligned like position_info;

      addr (dlksi_p_position_info.last_key_id_string) -> element_id.index =
	 addr (dlksi_p_position_info.last_key_id_string) -> element_id.index - 1;

   end DECREMENT_LAST_KEY_SLOT_INDEX;




DELETE_KEY_FROM_INDEX:
   proc (dkfi_p_get_keys_in_reverse_order, dkfi_p_position_info_ptr, dkfi_p_number_of_keys_accepted,
        dkfi_p_key_count_array_ptr);

      dcl	    dkfi_p_get_keys_in_reverse_order
			       bit (1) aligned parameter;
      dcl	    dkfi_p_position_info_ptr
			       ptr parameter;
      dcl	    dkfi_p_number_of_keys_accepted
			       fixed bin (35) parameter;
      dcl	    dkfi_p_key_count_array_ptr
			       ptr parameter;


      dcl	    dkfi_code	       fixed bin (35) init (0);
      dcl	    dkfi_deleted_node      bit (1) aligned init ("0"b);
      dcl	    1 dkfi_element_id      based (addr (dkfi_element_id_string)) like element_id;
      dcl	    dkfi_element_id_string bit (36) aligned;
      dcl	    dkfi_field_table_ptr   ptr;
      dcl	    dkfi_index_cursor_ptr  ptr;
      dcl	    1 dkfi_last_key_id     based (addr (dkfi_last_key_id_string)) like element_id;
      dcl	    dkfi_last_key_id_string
			       bit (36) aligned;
      dcl	    dkfi_leaf_ci_header_ptr
			       ptr;
      dcl	    dkfi_leaf_key_ptr      ptr;
      dcl	    dkfi_lk_string_length  fixed bin (35);
      dcl	    dkfi_node_id	       fixed bin (24) unsigned;
      dcl	    dkfi_node_ptr	       ptr;
      dcl	    dkfi_slot_index	       fixed bin (12) unsigned;
      dcl	    dkfi_work_area_ptr     ptr;

      call GET_WORK_AREA (dkfi_p_position_info_ptr, dkfi_work_area_ptr);
      call GET_FIELD_TABLE (dkfi_p_position_info_ptr, dkfi_field_table_ptr);
      call GET_INDEX_CURSOR (dkfi_p_position_info_ptr, dkfi_index_cursor_ptr);
      call GET_CI_HEADER (dkfi_p_position_info_ptr, dkfi_leaf_ci_header_ptr);
      call GET_NODE_ID (dkfi_p_position_info_ptr, dkfi_node_id);
      call GET_NODE_PTR (dkfi_p_position_info_ptr, dkfi_node_ptr);
      call GET_SLOT_INDEX (dkfi_p_position_info_ptr, dkfi_slot_index);
      call GET_KEY (dkfi_p_position_info_ptr, dkfi_leaf_key_ptr, dkfi_lk_string_length);
      call GET_LAST_KEY_ID (dkfi_p_position_info_ptr, dkfi_last_key_id_string);

      dkfi_element_id.control_interval_id = dkfi_node_id;
      dkfi_element_id.index = dkfi_slot_index;

      call im_update_key_counts (dkfi_node_ptr, dkfi_index_cursor_ptr, dkfi_work_area_ptr, dkfi_field_table_ptr,
	 IS_BEING_DELETED, dkfi_leaf_ci_header_ptr, dkfi_element_id_string, dkfi_leaf_key_ptr, dkfi_lk_string_length,
	 dkfi_p_key_count_array_ptr, dkfi_code);
      if dkfi_code ^= 0
      then call ERROR_RETURN (dkfi_code);

      dkfi_p_number_of_keys_accepted = dkfi_p_number_of_keys_accepted + 1;

      call im_general_delete (dkfi_node_ptr, dkfi_index_cursor_ptr, dkfi_leaf_ci_header_ptr, dkfi_element_id_string,
	 dkfi_deleted_node, dkfi_code);		/* This modifies the contents of the control interval */
						/* at which dkfi_p_current_node_ptr points. */
      if dkfi_code ^= 0
      then call ERROR_RETURN (dkfi_code);

      if dkfi_deleted_node
      then call NOTE_NODE_IS_DELETED (dkfi_p_position_info_ptr);


      if dkfi_last_key_id.control_interval_id = dkfi_node_id & ^dkfi_p_get_keys_in_reverse_order
      then call DECREMENT_LAST_KEY_SLOT_INDEX (dkfi_p_position_info_ptr);
   end DELETE_KEY_FROM_INDEX;
%page;
FIND_POSITION:
   proc (fp_p_get_keys_in_reverse_order, fp_p_position_info_ptr, fp_p_position_count, fp_p_finished);

      dcl	    fp_p_get_keys_in_reverse_order
			       bit (1) aligned parameter;
      dcl	    fp_p_position_info_ptr ptr parameter;
      dcl	    fp_p_position_count    fixed bin (35) parameter;
      dcl	    fp_p_finished	       bit (1) aligned parameter;


      dcl	    1 fp_leaf_ci_header    based (fp_leaf_ci_header_ptr) like leaf_ci_header;
      dcl	    fp_leaf_ci_header_ptr  ptr;
      dcl	    fp_node_id	       fixed bin (24) unsigned;
      dcl	    fp_position_change     fixed bin (35) init (0);
      dcl	    fp_slot_index	       fixed bin (12) unsigned;

      call GET_NODE_ID (fp_p_position_info_ptr, fp_node_id);
      call GET_CI_HEADER (fp_p_position_info_ptr, fp_leaf_ci_header_ptr);
      call GET_SLOT_INDEX (fp_p_position_info_ptr, fp_slot_index);

      if fp_p_get_keys_in_reverse_order
      then
         do;
	  fp_position_change = fp_p_position_count;	/* Try to move the entire distance. */
	  if BEFORE_BEGINNING (fp_p_position_info_ptr, fp_node_id, fp_slot_index - fp_position_change)
	  then fp_p_finished = "1"b;
	  else if fp_slot_index - fp_position_change >= fp_leaf_ci_header.common.key_range.first
	  then call SET_SLOT_INDEX (fp_slot_index - fp_position_change, fp_p_position_info_ptr);
	  else
	     do;
	        do while (^BEFORE_BEGINNING (fp_p_position_info_ptr, fp_node_id, fp_slot_index - fp_position_change)
		   & (fp_slot_index - fp_position_change < fp_leaf_ci_header.common.key_range.first));
		 fp_position_change =
		      fp_position_change - (fp_slot_index - fp_leaf_ci_header.common.key_range.first + 1);

		 fp_node_id = fp_leaf_ci_header.common.previous_id;
		 call SET_NODE_ID (fp_node_id, fp_p_position_info_ptr);

		 call GET_CI_HEADER (fp_p_position_info_ptr, fp_leaf_ci_header_ptr);
		 fp_slot_index = fp_leaf_ci_header.common.key_range.last;
	        end;
	        call SET_SLOT_INDEX (fp_slot_index, fp_p_position_info_ptr);
	        if BEFORE_BEGINNING (fp_p_position_info_ptr, fp_node_id, fp_slot_index - fp_position_change)
	        then fp_p_finished = "1"b;
	        else
		 do;
		    fp_p_position_count = 0;
		    fp_slot_index = fp_slot_index - fp_position_change;
		    call SET_SLOT_INDEX (fp_slot_index, fp_p_position_info_ptr);
		 end;
	     end;
         end;
      else
         do;
	  fp_position_change = fp_p_position_count;
	  if AFTER_END (fp_p_position_info_ptr, fp_node_id, fp_slot_index + fp_position_change)
	  then fp_p_finished = "1"b;
	  else if fp_slot_index + fp_position_change <= fp_leaf_ci_header.common.key_range.last
	  then call SET_SLOT_INDEX (fp_slot_index + fp_position_change, fp_p_position_info_ptr);
	  else
	     do;
	        do while (^AFTER_END (fp_p_position_info_ptr, fp_node_id, fp_slot_index + fp_position_change)
		   & (fp_slot_index + fp_position_change > fp_leaf_ci_header.common.key_range.last));
		 fp_position_change =
		      fp_position_change - (fp_leaf_ci_header.common.key_range.last - fp_slot_index + 1);

		 fp_node_id = fp_leaf_ci_header.common.next_id;
		 call SET_NODE_ID (fp_node_id, fp_p_position_info_ptr);

		 call GET_CI_HEADER (fp_p_position_info_ptr, fp_leaf_ci_header_ptr);
		 fp_slot_index = fp_leaf_ci_header.common.key_range.first;
	        end;
	        call SET_SLOT_INDEX (fp_slot_index, fp_p_position_info_ptr);

	        if AFTER_END (fp_p_position_info_ptr, fp_node_id, fp_slot_index + fp_position_change)
	        then fp_p_finished = "1"b;
	        else
		 do;
		    fp_slot_index = fp_slot_index + fp_position_change;
		    call SET_SLOT_INDEX (fp_slot_index, fp_p_position_info_ptr);
		 end;
	     end;
	  fp_p_position_count = 0;
         end;

   end FIND_POSITION;
%page;
FREE_ENTIRE_VECTOR:
   proc (fev_p_vector_ptr);
      dcl	    fev_p_vector_ptr       ptr parameter;

      dcl	    fev_based_dummy	       fixed bin based;
      dcl	    fev_dimension_idx      fixed bin (35) init (0);

      do fev_dimension_idx = 1 to fev_p_vector_ptr -> simple_typed_vector.number_of_dimensions;
         free fev_p_vector_ptr -> simple_typed_vector.dimension (fev_dimension_idx).value_ptr -> fev_based_dummy;
      end;
      free fev_p_vector_ptr -> simple_typed_vector;
      fev_p_vector_ptr = null;

   end FREE_ENTIRE_VECTOR;




GET_CI_HEADER:
   proc (gch_p_position_info_ptr, gch_p_leaf_ci_header_ptr);
      dcl	    gch_p_position_info_ptr
			       ptr parameter;
      dcl	    gch_p_leaf_ci_header_ptr
			       ptr parameter;

      dcl	    gch_code	       fixed bin (35) init (0);
      dcl	    gch_collection_id      bit (36) aligned;
      dcl	    1 gch_element_id       aligned based (addr (gch_element_id_string)) like element_id;
      dcl	    gch_element_id_string  bit (36) aligned;
      dcl	    gch_node_id	       fixed bin (24) unsigned;
      dcl	    gch_node_ptr	       ptr;
      dcl	    1 gch_p_position_info  based (gch_p_position_info_ptr) aligned like position_info;

      if ^gch_p_position_info.header_buffer_contains_current_header
      then
         do;
	  call GET_COLLECTION_ID (gch_p_position_info_ptr, gch_collection_id);
	  call GET_NODE_ID (gch_p_position_info_ptr, gch_node_id);
	  call GET_NODE_PTR (gch_p_position_info_ptr, gch_node_ptr);

	  gch_element_id.control_interval_id = gch_node_id;
	  gch_element_id.index = DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT;

	  call collection_manager_$simple_get_by_ci_ptr (gch_node_ptr, gch_collection_id, gch_element_id_string,
	       gch_p_position_info.header_buffer_ptr, gch_p_position_info.header_buffer_length, (0), gch_code);
	  if gch_code ^= 0
	  then call ERROR_RETURN (gch_code);
	  if ^gch_p_position_info.header_buffer_ptr -> common_ci_header.is_leaf
	  then call ERROR_RETURN (dm_error_$bad_leaf_node);
	  else if gch_p_position_info.header_buffer_ptr -> leaf_ci_header.common.key_range.first < 0
	  then call ERROR_RETURN (dm_error_$bad_first_key_idx);
	  else if gch_p_position_info.header_buffer_ptr -> leaf_ci_header.common.key_range.last
		  < gch_p_position_info.header_buffer_ptr -> leaf_ci_header.common.key_range.first
	  then call ERROR_RETURN (dm_error_$bad_last_key_idx);
	  gch_p_position_info.header_buffer_contains_current_header = "1"b;
         end;
      gch_p_leaf_ci_header_ptr = gch_p_position_info.header_buffer_ptr;

      return;
   end GET_CI_HEADER;
%page;
GET_COLLECTION_ID:
   proc (gci_p_position_info_ptr, gci_p_collection_id);
      dcl	    gci_p_position_info_ptr
			       ptr parameter;
      dcl	    gci_p_collection_id    bit (36) aligned parameter;

      gci_p_collection_id = gci_p_position_info_ptr -> position_info.index_cursor_ptr -> index_cursor.collection_id;

   end GET_COLLECTION_ID;



GET_ENTIRE_VECTOR:
   proc (gev_p_position_info_ptr, gev_p_vector_ptr);
      dcl	    gev_p_position_info_ptr
			       ptr parameter;
      dcl	    gev_p_vector_ptr       ptr parameter;

      dcl	    1 gev_p_position_info  aligned based (gev_p_position_info_ptr) like position_info;

      dcl	    gev_code	       fixed bin (35);
      dcl	    gev_field_table_ptr    ptr;
      dcl	    gev_leaf_key_ptr       ptr;
      dcl	    gev_lk_string_length   fixed bin (35);
      dcl	    gev_work_area_ptr      ptr;

      if gev_p_position_info.entire_vector_ptr = null
      then
         do;

	  call GET_KEY (gev_p_position_info_ptr, gev_leaf_key_ptr, gev_lk_string_length);
	  call GET_FIELD_TABLE (gev_p_position_info_ptr, gev_field_table_ptr);
	  call GET_WORK_AREA (gev_p_position_info_ptr, gev_work_area_ptr);

	  call data_format_util_$cv_string_to_vector (gev_field_table_ptr, gev_work_area_ptr, gev_leaf_key_ptr,
	       gev_lk_string_length, null (), gev_p_position_info.entire_vector_ptr, gev_code);
	  if gev_code ^= 0
	  then call ERROR_RETURN (gev_code);

         end;
      gev_p_vector_ptr = gev_p_position_info.entire_vector_ptr;

   end GET_ENTIRE_VECTOR;
%page;
GET_FIELD_TABLE:
   proc (gft_p_position_info_ptr, gft_p_field_table_ptr);
      dcl	    gft_p_position_info_ptr
			       ptr parameter;
      dcl	    gft_p_field_table_ptr  ptr parameter;

      gft_p_field_table_ptr = gft_p_position_info_ptr -> position_info.field_table_ptr;

   end GET_FIELD_TABLE;


GET_FILE_OPENING_ID:
   proc (gfoi_p_position_info_ptr, gfoi_p_file_opening_id);
      dcl	    gfoi_p_position_info_ptr
			       ptr parameter;
      dcl	    gfoi_p_file_opening_id bit (36) aligned parameter;

      gfoi_p_file_opening_id = gfoi_p_position_info_ptr -> position_info.index_cursor_ptr -> index_cursor.file_opening_id;

   end GET_FILE_OPENING_ID;


GET_FIRST_KEY_ID:
   proc (gfki_p_position_info_ptr, gfki_p_first_key_id_string);
      dcl	    gfki_p_position_info_ptr
			       ptr parameter;
      dcl	    gfki_p_first_key_id_string
			       bit (36) aligned parameter;

      gfki_p_first_key_id_string = gfki_p_position_info_ptr -> position_info.first_key_id_string;

   end GET_FIRST_KEY_ID;


GET_INDEX_CURSOR:
   proc (gic_p_position_info_ptr, gic_p_index_cursor_ptr);
      dcl	    gic_p_position_info_ptr
			       ptr parameter;
      dcl	    gic_p_index_cursor_ptr ptr parameter;

      gic_p_index_cursor_ptr = gic_p_position_info_ptr -> position_info.index_cursor_ptr;
   end GET_INDEX_CURSOR;
%page;
GET_KEY:
   proc (gk_p_position_info_ptr, gk_p_leaf_key_ptr, gk_p_leaf_key_string_length);
      dcl	    gk_p_position_info_ptr ptr parameter;
      dcl	    gk_p_leaf_key_ptr      ptr parameter;
      dcl	    gk_p_leaf_key_string_length
			       fixed bin (35) parameter;

      dcl	    gk_code	       fixed bin (35);
      dcl	    gk_collection_id       bit (36) aligned;
      dcl	    1 gk_element_id	       aligned based (addr (gk_element_id_string)) like element_id;
      dcl	    gk_element_id_string   bit (36) aligned;
      dcl	    gk_node_id	       fixed bin (24) unsigned;
      dcl	    gk_node_ptr	       ptr;
      dcl	    1 gk_p_position_info   based (gk_p_position_info_ptr) aligned like position_info;
      dcl	    gk_slot_index	       fixed bin (12) unsigned;

      if ^gk_p_position_info.key_buffer_contains_current_key
      then
         do;
	  call GET_COLLECTION_ID (gk_p_position_info_ptr, gk_collection_id);
	  call GET_NODE_ID (gk_p_position_info_ptr, gk_node_id);
	  call GET_NODE_PTR (gk_p_position_info_ptr, gk_node_ptr);
	  call GET_SLOT_INDEX (gk_p_position_info_ptr, gk_slot_index);

	  gk_element_id.control_interval_id = gk_node_id;
	  gk_element_id.index = gk_slot_index;

	  call collection_manager_$simple_get_by_ci_ptr (gk_node_ptr, gk_collection_id, gk_element_id_string,
	       gk_p_position_info.key_buffer_ptr, gk_p_position_info.key_buffer_length,
	       gk_p_position_info.lk_string_length, gk_code);
	  if gk_code ^= 0
	  then call ERROR_RETURN (gk_code);
	  gk_p_position_info.key_buffer_contains_current_key = "1"b;
         end;

      gk_p_leaf_key_ptr = gk_p_position_info.key_buffer_ptr;
      gk_p_leaf_key_string_length = gk_p_position_info.lk_string_length;


   end GET_KEY;



GET_LAST_KEY_ID:
   proc (glki_p_position_info_ptr, glki_p_last_key_id_string);
      dcl	    glki_p_position_info_ptr
			       ptr parameter;
      dcl	    glki_p_last_key_id_string
			       bit (36) aligned parameter;

      glki_p_last_key_id_string = glki_p_position_info_ptr -> position_info.last_key_id_string;

   end GET_LAST_KEY_ID;


GET_NODE_ID:
   proc (gni_p_position_info_ptr, gni_p_node_id);
      dcl	    gni_p_position_info_ptr
			       ptr parameter;
      dcl	    gni_p_node_id	       fixed bin (24) unsigned parameter;

      gni_p_node_id = gni_p_position_info_ptr -> position_info.node_id;

   end GET_NODE_ID;
%page;
GET_NODE_PTR:
   proc (gnp_p_position_info_ptr, gnp_p_node_ptr);
      dcl	    gnp_p_position_info_ptr
			       ptr parameter;
      dcl	    gnp_p_node_ptr	       ptr parameter;

      dcl	    gnp_code	       fixed bin (35);
      dcl	    gnp_collection_id      bit (36) aligned;
      dcl	    gnp_file_opening_id    bit (36) aligned;
      dcl	    gnp_node_id	       fixed bin (24) unsigned;
      dcl	    1 gnp_p_position_info  based (gnp_p_position_info_ptr) aligned like position_info;

      if gnp_p_position_info.node_ptr = null
      then
         do;
	  call GET_FILE_OPENING_ID (gnp_p_position_info_ptr, gnp_file_opening_id);
	  call GET_COLLECTION_ID (gnp_p_position_info_ptr, gnp_collection_id);
	  call GET_NODE_ID (gnp_p_position_info_ptr, gnp_node_id);

	  call collection_manager_$get_control_interval_ptr (gnp_file_opening_id, gnp_collection_id, gnp_node_id,
	       gnp_p_position_info.node_ptr, gnp_code);
	  if gnp_code ^= 0
	  then call ERROR_RETURN (gnp_code);
         end;

      gnp_p_node_ptr = gnp_p_position_info.node_ptr;
   end GET_NODE_PTR;
%page;
GET_SELECTED_VECTOR:
   proc (gsv_p_position_info_ptr, gsv_p_vector_ptr);

      dcl	    gsv_p_position_info_ptr
			       ptr parameter;
      dcl	    gsv_p_vector_ptr       ptr parameter;

      dcl	    gsv_code	       fixed bin (35);
      dcl	    gsv_field_table_ptr    ptr;
      dcl	    gsv_leaf_key_ptr       ptr;
      dcl	    gsv_lk_string_length   fixed bin (35);
      dcl	    1 gsv_p_position_info  based (gsv_p_position_info_ptr) aligned like position_info;
      dcl	    gsv_work_area_ptr      ptr;

      if gsv_p_position_info.selected_vector_ptr = null
      then if gsv_p_position_info.id_list_ptr = null
	 then call GET_ENTIRE_VECTOR (gsv_p_position_info_ptr, gsv_p_position_info.selected_vector_ptr);
	 else
	    do;

	       call GET_KEY (gsv_p_position_info_ptr, gsv_leaf_key_ptr, gsv_lk_string_length);
	       call GET_FIELD_TABLE (gsv_p_position_info_ptr, gsv_field_table_ptr);
	       call GET_WORK_AREA (gsv_p_position_info_ptr, gsv_work_area_ptr);

	       call data_format_util_$cv_string_to_vector (gsv_field_table_ptr, gsv_work_area_ptr, gsv_leaf_key_ptr,
		  gsv_lk_string_length, gsv_p_position_info.id_list_ptr, gsv_p_position_info.selected_vector_ptr,
		  gsv_code);
	       if gsv_code ^= 0
	       then call ERROR_RETURN (gsv_code);
	    end;
      gsv_p_vector_ptr = gsv_p_position_info.selected_vector_ptr;

   end GET_SELECTED_VECTOR;


GET_SLOT_INDEX:
   proc (gsi_p_position_info_ptr, gsi_p_slot_index);
      dcl	    gsi_p_position_info_ptr
			       ptr parameter;
      dcl	    gsi_p_slot_index       fixed bin (12) unsigned parameter;

      gsi_p_slot_index = gsi_p_position_info_ptr -> position_info.slot_index;
   end GET_SLOT_INDEX;



GET_WORK_AREA:
   proc (gci_p_position_info_ptr, gci_p_work_area_ptr);
      dcl	    gci_p_position_info_ptr
			       ptr parameter;
      dcl	    gci_p_work_area_ptr    ptr parameter;

      gci_p_work_area_ptr = gci_p_position_info_ptr -> position_info.work_area_ptr;

   end GET_WORK_AREA;
%page;
INITIALIZE_POSITION:
   proc (ip_p_index_cursor_ptr, ip_p_header_buffer_ptr, ip_p_header_buffer_length, ip_p_key_buffer_ptr,
        ip_p_key_buffer_length, ip_p_field_table_ptr, ip_p_work_area_ptr, ip_p_first_key_id_string,
        ip_p_last_key_id_string, ip_p_id_list_ptr, ip_p_get_keys_in_reverse_order, ip_p_position_info_ptr);

      dcl	    ip_p_index_cursor_ptr  ptr parameter;
      dcl	    ip_p_header_buffer_ptr ptr parameter;
      dcl	    ip_p_header_buffer_length
			       fixed bin (35) parameter;
      dcl	    ip_p_key_buffer_ptr    ptr parameter;
      dcl	    ip_p_key_buffer_length fixed bin (35) parameter;
      dcl	    ip_p_field_table_ptr   ptr parameter;
      dcl	    ip_p_work_area_ptr     ptr parameter;
      dcl	    ip_p_first_key_id_string
			       bit (36) aligned;
      dcl	    ip_p_last_key_id_string
			       bit (36) aligned;
      dcl	    ip_p_id_list_ptr       ptr parameter;
      dcl	    ip_p_get_keys_in_reverse_order
			       bit (1) aligned parameter;
      dcl	    ip_p_position_info_ptr ptr parameter;

      dcl	    1 ip_p_position_info   based (ip_p_position_info_ptr) aligned like position_info;

      ip_p_position_info.node_ptr = null;
      ip_p_position_info.entire_vector_ptr = null;
      ip_p_position_info.selected_vector_ptr = null;
      ip_p_position_info.lk_string_length = 0;
      ip_p_position_info.node_id = 0;
      ip_p_position_info.slot_index = 0;
      string (ip_p_position_info.flags) = "0"b;
      ip_p_position_info.index_cursor_ptr = ip_p_index_cursor_ptr;
      ip_p_position_info.key_buffer_length = ip_p_key_buffer_length;
      ip_p_position_info.key_buffer_ptr = ip_p_key_buffer_ptr;
      ip_p_position_info.header_buffer_length = ip_p_header_buffer_length;
      ip_p_position_info.header_buffer_ptr = ip_p_header_buffer_ptr;
      ip_p_position_info.field_table_ptr = ip_p_field_table_ptr;
      ip_p_position_info.work_area_ptr = ip_p_work_area_ptr;
      ip_p_position_info.first_key_id_string = ip_p_first_key_id_string;
      ip_p_position_info.last_key_id_string = ip_p_last_key_id_string;
      ip_p_position_info.id_list_ptr = ip_p_id_list_ptr;


      if ip_p_get_keys_in_reverse_order
      then
         do;
	  call SET_NODE_ID ((addr (ip_p_last_key_id_string) -> element_id.control_interval_id), ip_p_position_info_ptr);
	  call SET_SLOT_INDEX ((addr (p_last_key_id_string) -> element_id.index), ip_p_position_info_ptr);
         end;
      else
         do;
	  call SET_NODE_ID ((addr (ip_p_first_key_id_string) -> element_id.control_interval_id), ip_p_position_info_ptr)
	       ;
	  call SET_SLOT_INDEX ((addr (ip_p_first_key_id_string) -> element_id.index), ip_p_position_info_ptr);
         end;


   end INITIALIZE_POSITION;
%page;
INTERPRET_SPECIFICATION:
   proc (is_p_specification_head_ptr, is_p_first_key_id_string, is_p_is_search_specification,
        is_p_search_specification_ptr, is_p_numeric_specification_ptr, is_p_get_keys_in_reverse_order, is_p_range_size,
        is_p_position_count);

      dcl	    is_p_specification_head_ptr
			       ptr parameter;
      dcl	    is_p_first_key_id_string
			       bit (36) aligned parameter;
      dcl	    is_p_is_search_specification
			       bit (1) aligned parameter;
      dcl	    is_p_search_specification_ptr
			       ptr parameter;
      dcl	    is_p_numeric_specification_ptr
			       ptr parameter;
      dcl	    is_p_get_keys_in_reverse_order
			       bit (1) aligned parameter;
      dcl	    is_p_range_size	       fixed bin (35) parameter;
      dcl	    is_p_position_count    fixed bin (35) parameter;


      if is_p_specification_head_ptr -> specification_head.type = ABSOLUTE_SEARCH_SPECIFICATION_TYPE
	 | is_p_specification_head_ptr -> specification_head.type = RELATIVE_SEARCH_SPECIFICATION_TYPE
      then
         do;
	  is_p_is_search_specification = "1"b;
	  is_p_search_specification_ptr = is_p_specification_head_ptr;
	  is_p_get_keys_in_reverse_order =
	       (is_p_first_key_id_string = "0"b
	       | is_p_search_specification_ptr -> search_specification.range.type = HIGH_RANGE_TYPE);
	  is_p_range_size = is_p_search_specification_ptr -> search_specification.range.size;
         end;
      else if is_p_specification_head_ptr -> specification_head.type = ABSOLUTE_NUMERIC_SPECIFICATION_TYPE
	      | is_p_specification_head_ptr -> specification_head.type = RELATIVE_NUMERIC_SPECIFICATION_TYPE
      then
         do;
	  is_p_is_search_specification = "0"b;
	  is_p_numeric_specification_ptr = is_p_specification_head_ptr;
	  is_p_get_keys_in_reverse_order =
	       (is_p_numeric_specification_ptr -> numeric_specification.position_number < 0);
	  is_p_range_size = is_p_numeric_specification_ptr -> numeric_specification.range_size;
	  is_p_position_count = abs (is_p_numeric_specification_ptr -> numeric_specification.position_number);
         end;
      else call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
	      "^/The specification structure does not have a recognizable type.  
Recognized types are ^d, ^d, ^d, or ^d.  Received type was ^d.", ABSOLUTE_SEARCH_SPECIFICATION_TYPE,
	      RELATIVE_SEARCH_SPECIFICATION_TYPE, ABSOLUTE_NUMERIC_SPECIFICATION_TYPE,
	      RELATIVE_NUMERIC_SPECIFICATION_TYPE, is_p_specification_head_ptr -> specification_head.type);

   end INTERPRET_SPECIFICATION;
%page;
NODE_IS_DELETED:
   proc (nie_p_position_info_ptr) returns (bit (1) aligned);
      dcl	    nie_p_position_info_ptr
			       ptr parameter;

      return (nie_p_position_info_ptr -> position_info.node_is_deleted);
   end NODE_IS_DELETED;



NOTE_NODE_IS_DELETED:
   proc (nnid_p_position_info_ptr);
      dcl	    nnid_p_position_info_ptr
			       ptr parameter;

      nnid_p_position_info_ptr -> position_info.node_is_deleted = "1"b;
      nnid_p_position_info_ptr -> position_info.node_ptr = null;
   end NOTE_NODE_IS_DELETED;


NOTE_VECTOR_IN_USE:
   proc (nviu_p_position_info_ptr);
      dcl	    nviu_p_position_info_ptr
			       ptr parameter;

      nviu_p_position_info_ptr -> position_info.vector_in_use = "1"b;
   end NOTE_VECTOR_IN_USE;
%page;
RESET_CI_HEADER:
   proc (rch_p_position_info_ptr);
      dcl	    rch_p_position_info_ptr
			       ptr parameter;
      rch_p_position_info_ptr -> position_info.header_buffer_contains_current_header = "0"b;
   end RESET_CI_HEADER;


RESET_KEY:
   proc (rk_p_position_info_ptr);
      dcl	    rk_p_position_info_ptr ptr parameter;
      call RESET_VECTORS (rk_p_position_info_ptr);
      rk_p_position_info_ptr -> position_info.key_buffer_contains_current_key = "0"b;
      rk_p_position_info_ptr -> position_info.lk_string_length = 0;
   end RESET_KEY;


RESET_NODE_ID:
   proc (rni_p_position_info_ptr);

      dcl	    rni_p_position_info_ptr
			       ptr parameter;

      rni_p_position_info_ptr -> position_info.node_id = 0;
      rni_p_position_info_ptr -> position_info.node_is_deleted = "0"b;

      call RESET_CI_HEADER (rni_p_position_info_ptr);
      call RESET_NODE_PTR (rni_p_position_info_ptr);
      call RESET_SLOT_INDEX (rni_p_position_info_ptr);

   end RESET_NODE_ID;


RESET_NODE_PTR:
   proc (rnp_p_position_info_ptr);
      dcl	    rnp_p_position_info_ptr
			       ptr parameter;
      rnp_p_position_info_ptr -> position_info.node_ptr = null ();
   end RESET_NODE_PTR;


RESET_SLOT_INDEX:
   proc (rsi_p_position_info_ptr);
      dcl	    rsi_p_position_info_ptr
			       ptr parameter;
      call RESET_KEY (rsi_p_position_info_ptr);
      rsi_p_position_info_ptr -> position_info.slot_index = 0;
   end RESET_SLOT_INDEX;
%page;
RESET_VECTORS:
   proc (rv_p_position_info_ptr);
      dcl	    rv_p_position_info_ptr ptr parameter;

      dcl	    1 rv_p_position_info   based (rv_p_position_info_ptr) aligned like position_info;

/* If the entire and selected vectors are the same vector, avoid trying to free
it twice (or freeing it as the entire_vector when the vector, as the
selected_vector, should not be freed because it is in the output array)
by setting the entire_vector_ptr to null.
*/

      if rv_p_position_info.entire_vector_ptr = rv_p_position_info.selected_vector_ptr
      then rv_p_position_info.entire_vector_ptr = null;

      if rv_p_position_info.entire_vector_ptr ^= null
      then call FREE_ENTIRE_VECTOR (rv_p_position_info.entire_vector_ptr);

      if ^rv_p_position_info.vector_in_use & rv_p_position_info.selected_vector_ptr ^= null
      then call FREE_ENTIRE_VECTOR (rv_p_position_info.selected_vector_ptr);

      rv_p_position_info.selected_vector_ptr = null;
      rv_p_position_info.entire_vector_ptr = null;
      rv_p_position_info.vector_in_use = "0"b;

   end RESET_VECTORS;
%page;
REVERSE_VECTOR_SLOTS:
   proc (rvs_p_input_number_of_keys_accepted, rvs_p_typed_vector_array_ptr);
      dcl	    rvs_p_input_number_of_keys_accepted
			       fixed bin (35) parameter;
      dcl	    rvs_p_typed_vector_array_ptr
			       ptr parameter;

      dcl	    rvs_vector_slot_idx    fixed bin (35) init (0);
      dcl	    rvs_vector_ptr	       ptr init (null);

      do rvs_vector_slot_idx = rvs_p_input_number_of_keys_accepted + 1
	 to
	 divide (rvs_p_typed_vector_array_ptr -> typed_vector_array.number_of_vectors
	 - rvs_p_input_number_of_keys_accepted, 2, 35, 0) + rvs_p_input_number_of_keys_accepted;
         rvs_vector_ptr = rvs_p_typed_vector_array_ptr -> typed_vector_array.vector_slot (rvs_vector_slot_idx);
         rvs_p_typed_vector_array_ptr -> typed_vector_array.vector_slot (rvs_vector_slot_idx) =
	    rvs_p_typed_vector_array_ptr
	    -> typed_vector_array
	    .
	    vector_slot (rvs_p_typed_vector_array_ptr -> typed_vector_array.number_of_vectors - rvs_vector_slot_idx + 1)
	    ;
         rvs_p_typed_vector_array_ptr
	    -> typed_vector_array
	    .
	    vector_slot (rvs_p_typed_vector_array_ptr -> typed_vector_array.number_of_vectors - rvs_vector_slot_idx + 1)
	    = rvs_vector_ptr;
      end;
   end REVERSE_VECTOR_SLOTS;
%page;
SEARCH_SPEC_COMPARISON:
   proc (sesc_p_search_specification_ptr, sesc_p_and_group_id_list_ptr, sesc_p_number_of_fully_structural_fields,
        sesc_p_partial_structural_field_id, sesc_p_position_info_ptr, sesc_p_key_satisfies_specification);

      dcl	    sesc_p_search_specification_ptr
			       ptr parameter;
      dcl	    sesc_p_and_group_id_list_ptr
			       ptr parameter;
      dcl	    sesc_p_number_of_fully_structural_fields
			       fixed bin parameter;
      dcl	    sesc_p_partial_structural_field_id
			       fixed bin (17) parameter;
      dcl	    sesc_p_position_info_ptr
			       ptr parameter;
      dcl	    sesc_p_key_satisfies_specification
			       bit (1) aligned parameter;

      dcl	    sesc_code	       fixed bin (35) init (0);
      dcl	    sesc_field_table_ptr   ptr init (null);
      dcl	    sesc_leaf_key_ptr      ptr init (null);
      dcl	    sesc_lk_string_length  fixed bin (35) init (0);



      call GET_FIELD_TABLE (sesc_p_position_info_ptr, sesc_field_table_ptr);

      if (sesc_p_search_specification_ptr -> search_specification.number_of_and_groups = 0
	 & sesc_p_and_group_id_list_ptr = null)
	 | (sesc_p_number_of_fully_structural_fields = sesc_field_table_ptr -> field_table.number_of_fields)
      then sesc_p_key_satisfies_specification = "1"b;
      else
         do;
	  call GET_KEY (sesc_p_position_info_ptr, sesc_leaf_key_ptr, sesc_lk_string_length);

	  lk_string_length = sesc_lk_string_length;	/* The global variable lk_string_length is used here because leaf_key references it. */
	  call data_format_util_$compare_sequential (sesc_field_table_ptr, sesc_p_search_specification_ptr,
	       sesc_p_and_group_id_list_ptr, sesc_p_number_of_fully_structural_fields,
	       sesc_p_partial_structural_field_id, sesc_leaf_key_ptr -> leaf_key.string,
	       sesc_p_key_satisfies_specification, sesc_code);
	  if sesc_code ^= 0
	  then call ERROR_RETURN (sesc_code);
         end;

   end SEARCH_SPEC_COMPARISON;
%page;
SET_INDEX_CURSOR:
   proc (sc_p_operation, sc_p_position_info_ptr);

      dcl	    sc_p_operation	       fixed bin parameter;
      dcl	    sc_p_position_info_ptr ptr parameter;

      dcl	    sc_code	       fixed bin (35) init (0);
      dcl	    sc_index_cursor_ptr    ptr;
      dcl	    sc_leaf_ci_header_ptr  ptr;
      dcl	    1 sc_leaf_ci_header    based (sc_leaf_ci_header_ptr) like leaf_ci_header;
      dcl	    sc_leaf_key_ptr	       ptr;
      dcl	    sc_lk_string_length    fixed bin (35);
      dcl	    sc_node_id	       fixed bin (24) unsigned;
      dcl	    sc_slot_index	       fixed bin (12) unsigned;

      dcl	    sc_element_id_string   bit (36) aligned;
      dcl	    1 sc_element_id	       based (addr (sc_element_id_string)) like element_id;


      call GET_INDEX_CURSOR (sc_p_position_info_ptr, sc_index_cursor_ptr);
      call GET_CI_HEADER (sc_p_position_info_ptr, sc_leaf_ci_header_ptr);
      call GET_KEY (sc_p_position_info_ptr, sc_leaf_key_ptr, sc_lk_string_length);
      call GET_NODE_ID (sc_p_position_info_ptr, sc_node_id);
      call GET_SLOT_INDEX (sc_p_position_info_ptr, sc_slot_index);

      sc_element_id.control_interval_id = sc_node_id;
      sc_element_id.index = sc_slot_index;

      if sc_p_operation = GET_OPERATION
      then
         do;
	  call im_set_cursor$at_current (sc_index_cursor_ptr, sc_element_id_string, sc_leaf_key_ptr,
	       (sc_lk_string_length), sc_code);
	  if sc_code ^= 0
	  then call ERROR_RETURN (sc_code);
         end;
      else if sc_p_operation = POSITION_OPERATION
      then
         do;
	  call GET_KEY (sc_p_position_info_ptr, sc_leaf_key_ptr, sc_lk_string_length);
	  call im_set_cursor$at_current (sc_index_cursor_ptr, sc_element_id_string, sc_leaf_key_ptr,
	       (sc_lk_string_length), sc_code);
	  if sc_code ^= 0
	  then call ERROR_RETURN (sc_code);
         end;
      else if sc_p_operation = DELETE_OPERATION
      then
         do;
	  if sc_slot_index > sc_leaf_ci_header.common.key_range.last | NODE_IS_DELETED (sc_p_position_info_ptr)
	  then
	     do;
	        sc_node_id = sc_leaf_ci_header.common.next_id;
	        call SET_NODE_ID (sc_node_id, sc_p_position_info_ptr);
	        if sc_node_id ^= 0
	        then
		 do;
		    call GET_CI_HEADER (sc_p_position_info_ptr, sc_leaf_ci_header_ptr);
		    sc_slot_index = sc_leaf_ci_header.common.key_range.first;
		    call SET_SLOT_INDEX (sc_slot_index, sc_p_position_info_ptr);
		 end;

	     end;
	  if sc_node_id > 0
	  then
	     do;
	        call GET_KEY (sc_p_position_info_ptr, sc_leaf_key_ptr, sc_lk_string_length);

	        sc_element_id.control_interval_id = sc_node_id;
	        sc_element_id.index = sc_slot_index;

	        call im_set_cursor$at_current (sc_index_cursor_ptr, sc_element_id_string, sc_leaf_key_ptr,
		   (sc_lk_string_length), sc_code);
	        if sc_code ^= 0
	        then call ERROR_RETURN (sc_code);
	     end;
	  else
	     do;
	        call im_set_cursor$at_end (sc_index_cursor_ptr, "0"b, null, 0, sc_code);
	        if sc_code ^= 0
	        then call ERROR_RETURN (sc_code);
	     end;
         end;
   end SET_INDEX_CURSOR;
%page;
SET_NODE_ID:
   proc (sni_p_node_id, sni_p_position_info_ptr);

/* This subroutine sets the current node id and gets a pointer to it. */

      dcl	    sni_p_node_id	       fixed bin (24) unsigned;
      dcl	    sni_p_position_info_ptr
			       ptr parameter;

      if sni_p_position_info_ptr -> position_info.node_id > 0
      then call RESET_NODE_ID (sni_p_position_info_ptr);

      sni_p_position_info_ptr -> position_info.node_id = sni_p_node_id;
   end SET_NODE_ID;



SET_SLOT_INDEX:
   proc (ssi_p_slot_index, ssi_p_position_info_ptr);
      dcl	    ssi_p_slot_index       fixed bin (12) unsigned parameter;
      dcl	    ssi_p_position_info_ptr
			       ptr parameter;

      if ssi_p_position_info_ptr -> position_info.slot_index > 0
      then call RESET_SLOT_INDEX (ssi_p_position_info_ptr);

      ssi_p_position_info_ptr -> position_info.slot_index = ssi_p_slot_index;


   end SET_SLOT_INDEX;
%page;
/* This procedure determines if there is a "next" key, and, if so, it advances
the current position to that next key.
*/

SETUP_NEXT_KEY:
   proc (snk_p_operation, snk_p_is_search_specification, snk_p_range_size, snk_p_get_keys_in_reverse_order,
        snk_p_key_satisfies_specification, snk_p_position_info_ptr, snk_p_number_of_keys_accepted, snk_p_finished);

      dcl	    snk_p_operation	       fixed bin parameter;
      dcl	    snk_p_is_search_specification
			       bit (1) aligned parameter;
      dcl	    snk_p_range_size       fixed bin (35) parameter;
      dcl	    snk_p_get_keys_in_reverse_order
			       bit (1) aligned parameter;
      dcl	    snk_p_key_satisfies_specification
			       bit (1) aligned parameter;
      dcl	    snk_p_position_info_ptr
			       ptr parameter;
      dcl	    snk_p_number_of_keys_accepted
			       fixed bin (35) parameter;
      dcl	    snk_p_finished	       bit (1) aligned parameter;


      dcl	    snk_leaf_ci_header_ptr ptr init (null);
      dcl	    1 snk_leaf_ci_header   based (snk_leaf_ci_header_ptr) like leaf_ci_header;
      dcl	    snk_node_id	       fixed bin (24) unsigned;
      dcl	    snk_position_change    fixed bin (35) init (0);
      dcl	    snk_slot_index	       fixed bin (12) unsigned;

      snk_p_finished = "0"b;

      if snk_p_range_size > 0 & snk_p_number_of_keys_accepted = snk_p_range_size
      then
         do;
	  snk_p_finished = "1"b;
	  return;
         end;
      else
REALLY_LOOK:
         do;

	  call GET_NODE_ID (snk_p_position_info_ptr, snk_node_id);
	  call GET_SLOT_INDEX (snk_p_position_info_ptr, snk_slot_index);
	  call GET_CI_HEADER (snk_p_position_info_ptr, snk_leaf_ci_header_ptr);

	  if snk_p_is_search_specification
	  then
	     do;
	        if snk_p_get_keys_in_reverse_order
	        then
		 do;
		    snk_position_change = 1;
		    if BEFORE_BEGINNING (snk_p_position_info_ptr, snk_node_id, snk_slot_index - snk_position_change)
		    then
		       do;
			snk_p_finished = "1"b;
			return;
		       end;
		    else if snk_slot_index - snk_position_change >= snk_leaf_ci_header.common.key_range.first
		    then call SET_SLOT_INDEX (snk_slot_index - snk_position_change, snk_p_position_info_ptr);
		    else
		       do;
			call SET_NODE_ID ((snk_leaf_ci_header.common.previous_id), snk_p_position_info_ptr);
			call GET_CI_HEADER (snk_p_position_info_ptr, snk_leaf_ci_header_ptr);

			call SET_SLOT_INDEX ((snk_leaf_ci_header.common.key_range.last), snk_p_position_info_ptr);
		       end;
		 end;
	        else
		 do;
		    snk_position_change = bin (snk_p_operation ^= DELETE_OPERATION);
		    if AFTER_END (snk_p_position_info_ptr, snk_node_id, snk_slot_index + snk_position_change)
		         | (snk_p_operation = POSITION_OPERATION & snk_p_key_satisfies_specification)
		    then
		       do;
			snk_p_finished = "1"b;
			return;
		       end;
		    else if snk_slot_index + snk_position_change <= snk_leaf_ci_header.common.key_range.last
			    & snk_slot_index ^= 0
		    then call SET_SLOT_INDEX (snk_slot_index + snk_position_change, snk_p_position_info_ptr);
		    else
		       do;
			call SET_NODE_ID ((snk_leaf_ci_header.common.next_id), snk_p_position_info_ptr);
			call GET_CI_HEADER (snk_p_position_info_ptr, snk_leaf_ci_header_ptr);
			call SET_SLOT_INDEX ((DEFAULT_INITIAL_KEY_SLOT), snk_p_position_info_ptr);
		       end;
		 end;
	     end;
	  else
FINISH_NUMERIC:
	     do;
	        if snk_p_range_size = 0 & snk_p_key_satisfies_specification
	        then
		 do;
		    snk_p_finished = "1"b;
		    return;
		 end;

	        else if snk_p_get_keys_in_reverse_order
	        then
		 do;
		    snk_position_change = 1;
		    if BEFORE_BEGINNING (snk_p_position_info_ptr, snk_node_id, snk_slot_index - snk_position_change)
		    then
		       do;
			snk_p_finished = "1"b;
			return;
		       end;
		    else if snk_slot_index - snk_position_change >= snk_leaf_ci_header.common.key_range.first
		    then call SET_SLOT_INDEX (snk_slot_index - snk_position_change, snk_p_position_info_ptr);
		    else
		       do;
			call SET_NODE_ID ((snk_leaf_ci_header.common.previous_id), snk_p_position_info_ptr);
			call GET_CI_HEADER (snk_p_position_info_ptr, snk_leaf_ci_header_ptr);

			call SET_SLOT_INDEX ((snk_leaf_ci_header.common.key_range.last), snk_p_position_info_ptr);
		       end;
		 end;
	        else
		 do;
		    snk_position_change = bin (snk_p_operation ^= DELETE_OPERATION);
		    if AFTER_END (snk_p_position_info_ptr, snk_node_id, snk_slot_index + snk_position_change)
		    then
		       do;
			snk_p_finished = "1"b;
			return;
		       end;
		    else if snk_slot_index + snk_position_change <= snk_leaf_ci_header.common.key_range.last
			    & snk_slot_index ^= 0
		    then call SET_SLOT_INDEX (snk_slot_index + snk_position_change, snk_p_position_info_ptr);
		    else
		       do;
			call SET_NODE_ID ((snk_leaf_ci_header.common.next_id), snk_p_position_info_ptr);
			call GET_CI_HEADER (snk_p_position_info_ptr, snk_leaf_ci_header_ptr);

			call SET_SLOT_INDEX ((snk_leaf_ci_header.common.key_range.first), snk_p_position_info_ptr);
		       end;
		 end;
	     end FINISH_NUMERIC;
         end REALLY_LOOK;
   end SETUP_NEXT_KEY;
%page;
/* This procedure determines if the current key satisfies the subset
specification.
*/

SUBSET_SPEC_COMPARISON:
   proc (susc_p_subset_specification_ptr, susc_p_position_info_ptr, susc_p_key_satisfies_specification);

      dcl	    susc_p_subset_specification_ptr
			       ptr parameter;
      dcl	    susc_p_position_info_ptr
			       ptr parameter;
      dcl	    susc_p_key_satisfies_specification
			       bit (1) aligned parameter;

      dcl	    susc_code	       fixed bin (35) init (0);
      dcl	    susc_vector_ptr	       ptr init (null);
      dcl	    susc_work_area_ptr     ptr;

      call GET_ENTIRE_VECTOR (susc_p_position_info_ptr, susc_vector_ptr);

      call GET_WORK_AREA (susc_p_position_info_ptr, susc_work_area_ptr);

      call im_compare_subset (susc_p_subset_specification_ptr, susc_vector_ptr, susc_work_area_ptr,
	 susc_p_key_satisfies_specification, NULL_PSEUDO_FIELD_VALUE, susc_code);
      if susc_code ^= 0
      then call ERROR_RETURN (susc_code);
   end SUBSET_SPEC_COMPARISON;
%page;
%page;
%include dm_im_cursor;
%page;
%include vu_typed_vector_array;
%page;
%include sub_err_flags;
%page;
%include dm_element_id;
%page;
%include dm_im_ci_header;
%page;
%include dm_im_key;
%page;
%include dm_collmgr_entry_dcls;
%page;
%include dm_specification;
%page;
%include dm_specification_head;
%page;
%include dm_range_constants;
%page;
%include dm_field_table;
%page;
%include dm_ci_lengths;
%page;
%include vu_typed_vector;
   end im_process_keys$get;
