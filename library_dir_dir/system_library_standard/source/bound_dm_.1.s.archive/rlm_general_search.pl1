/* ***********************************************************
   *                                                         *
   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
   *                                                         *
   *********************************************************** */

/* DESCRIPTION:

         This   module   searches   through  a  relation,  using  either  the
     record_manager_ or the  index_manager_,  returning  either  an  arbitrary
     subset  of  the  attributes  of  the  tuples  found  (as specified by the
     attribute id_list), or a list of element ids (which identify  the  tuples
     found).
*/

/* HISTORY:

Written by Lindsey L. Spratt, 09/23/82.
Modified:
11/12/82 by Lindsey Spratt: Changed to use version 3 of the
	  search_specification.  This means using the interval_list
	  structure which the index_manager_ may return in calls to the
	  record_manager_, and doing the conversion of the
	  search_specification field_ids to support search specs with
	  constraints on fields not present in the index being searched.
11/22/82 by Lindsey Spratt:  Added the get_array_by_spec entry and changed the
	  get_by_spec entry to be get_list_by_spec.
12/06/82 by Lindsey Spratt:  Fixed get_duplicate_key_count to a largely
	  "independent" entry, since it is the only entry which does not use
	  a specification.Also, changed code to allow for the
	  specification_ptr being null.  Changed to convert record_not_found
	  and key_not_found errors to mdbm_error_$tuple_not_found error
	  codes.
12/16/82 by Matthew Pierret:  Made to set p_element_id_list_ptr to null.
01/18/83 by Matthew Pierret:  
            Changed to not pass p_code to vector_util_$free_typed_vector_array
            in the finish procedure. It would reset p_code to 0.
02/07/83 by Lindsey Spratt:  Changed to not allocate anything but final
	  results in the caller-provided area, and to never free from the
	  caller's area.  This requires doing a full copy of the resulting
	  typed_vector_array or element_id_list.  The work_area is the
	  dm_data_$area_ptr area.
02/28/83 by Lindsey Spratt:  Changed to use version 3 index_cursor.
03/04/83 by Matthew Pierret: Changed to use the structures attribute_info,
            relation_opening_info, and index_attribute_map instead of the
            previously kept relation_info structure. Changed CHECK_VERSION
            CHECK_VERSION_FB, and added a new CHECK_VERSION which checks
            char(8)aligned versions. Removed references to dm_data$area_ptr.
            The work_area_ptr is now gotten using get_dm_free_area_ ().
            Changed work_area_ptr to be "internal static init (null)" so that
            only one call to get_dm_free_area_ need be made per process.
03/11/83 by Matthew Pierret: Changed to use mrds_error_ instead of mdbm_error_.
04/01/83 by Matthew Pierret: Changed to use dm_error_$tuple_not_found instead
            of mrds_error_$==. Added the entries $get_list_and_ids and
            $get_array_and_ids. Added use of CV_ERROR_TO_TUPLE_NOT_FOUND_RETURN
            to translate appropriate error codes to dm_error_$tuple_not_found,
            clean up and return. Added record_manager_ $get_records_and_ids
            and $get_records_and_ids_by_interval. Changed 
            record_field_is_in_index to all_desired_fields_are_in_index.
            Upper-cased finish. Added format comment after declarations which
            allows for comments to start at one indentation level before the
            current indentation level.
            Removed the check to see if a record_cursor was supplied
            via the $get_duplicate_key_count entry in the SEARCH_RECORDS
            do-group.  It is impossible to reach this point in the code
            when called through $get_duplicate_key_count.
05/05/83 by Matthew Pierret:  Changed entries which return a p_element_id_list
            to not allocate a new structure if p_element_id_list_ptr is not
            null.  Rather, just set the number of elements and fill in the
            identifiers.  It is not assumed that the value of
            peil.number_of_elements constitutes an upper bound.
05/31/83 by Matthew Pierret:  Added CV_V3_TO_V4_SPEC as a temporary means of
            converting the version 3 specifications passed in by MRDS to 
            the version 4 specifications used by index/record_managers.
06/07/83 by Lindsey L. Spratt:  Fixed the initialization of the value_field_id
            to -1 to only be done when the number of and groups is > 0.  This
            was overwriting the storage of the following allocation when the
            noag = 0, since PL1 assumes that there is always at least 1
            element in an array (even if its a 0-refer-extent based array).
06/08/83 by Matthew Pierret: Changed to support relation_cursors and
            relation_specifications. Removed the temporary CV_V3_TO_V4_SPEC.
            Changed interfaces as follows:
            - moved p_id_list_ptr immediately before p_caller_area_ptr in all
            calling sequences which have these two parameters;
            - added p_index_collection_id parameter to $get_duplicate_key_count
            to determine the index on which to operate (this determination
            previously was made by checking the cursor supplied);
            - moved p_relation_cursor_ptr to the beginning of all calling
            sequences for consistency.
            Added dm_specification_head.incl.pl1, dm_range_constants.incl.pl1.
            Changed basic searching technology with respect as follows:
            - each and-group is processed as a separate index and/or record
            search;
            - search_specifications are modified so as to exclude tuples found
            in previous and-group searches by toggling the NOT bit in the 
            operator codes;
            - if the desired number of tuples are found before the end of the
            relation is reached, the specification and cursor currently being
            used to search an index or record collection is maintained in the
            relation_cursor.
06/13/83 by Matthew Pierret:  Changed record_manager_$*_by_intervals to
            correctly be =$=_by_interval.
06/20/83 by Matthew Pierret:  Fixed incorrect ordering of arguments to
            record_manager_$get_ids_by_interval.
06/22/83 by Lindsey L. Spratt:  Moved SEARCH_RECORD_COLLECTION and
            SEARCH_INDEX into internal procedures.  Fixed AND_GROUP_LOOP to
            continue searching with the next and_group if the current
            and_group selects no tuples.
06/23/83 by Lindsey L. Spratt:  Fixed $get_duplicate_key_count to recognize
            p_number_of_duplicate_fields = -1 as a request for a count of all
            of the keys (available as the 0-th element in the
            key_count_array).  Also, changed myname to "rlm_general_search".
            Changed to handle relative searches better.  The search_spec was
            being re-used without paying attention to whether the field_ids
            were left set up for an index search or a record search.  This
            caused problems with a relative search which involved an index
            (whether or not there was also a record search).
07/30/83 by Matthew Pierret:  Made to free the old internal specification
            when resetting the cursor. Changed to allocate and copy the values
            in the relation_search_specification for use by the internal
            search_specification, rather than just making ss.value_ptr
            point to the same place as rss.value_ptr.  This is because the 
            values are used accross calls, and the caller might free the values
            and allocate new ones between calls.
08/11/83 by Matthew Pierret:  Removed the SET_CURRENT_NUMBER_OF_AND_GROUPS
            subroutine, replacing it with all 3 lines in-line.
            Made to free values copied for the internal search_specification.
            Removed attempts to not return data from the same tuple more than
            once.  Right now MRDS doesn't assume that we do, so why bother?
            ****                                                         ****
            **** Later, we will have to change this to strip duplicates. ****
            ****                                                         ****
            Changed to not copy specification values until the cursor is reset.
            This eliminates unnecessray copying. Changed SEARCH_INDEX and
            SEARCH_RECORD_COLLECTION to use a local code. Changed to allow
            an internal search_specification to have 0 and-groups.
09/13/83 by Matthew Pierret:  Removed $get_duplicate_key_count (moved it to
            rlm_get_approximate_count)
09/16/83 by Matthew Pierret:  Added frees of typed_vector_arrays and
            element_id_lists throughout much of the code.  Failure to free
            these structures and the structures to which they point was
            causing a great deal of extra space to hang around past its
            welcome. Added frees of interval_lists.            
01/19/84 by Matthew Pierret:  Changed FINISH to never free constraint values
            in the internal_specification because these values are actually
            the values pointed to by the caller's
            relation_search_specification.  These constraint values are only
            copied into the relation_manager_'s work area when resetting the
            cursor.
01/23/84 by Matthew Pierret:  Changed FINISH to correctly null
            return_eil_or_tva_array.ptr instead of return_eil_or_tva_array_ptr
            after freeing each typed_vector_array.
04/13/84 by Lee Baldwin:  Some of the record_manager_ entrypoints have been
            renamed, and their calling sequences changed (*): get_records_by_id_list(*),
            get_records_and_ids_by_spec(*), get_records_by_spec(*), get_record_ids_by_spec,
            get_record_ids_by_interval.
04/27/84 by Lee Baldwin:  Changed the calling sequence of
            record_manager_$get_record_bount_by_interval which no longer takes
            a work_area_ptr.  
05/02/84 by Lee Baldwin:  Changed name of index_manager_$get_count to 
            $get_key_count_by_spec.
05/08/84 by Matthew Pierret:  Changed to free typed_vector_arrays with the
            internal procedure FREE_TYPED_VECTOR_ARRAY.
05/29/84 by Matthew Pierret:  Changed to use RELATION_HEADER_VERSION_3.  Made
            temporary fix to restrict the maximum number of tuples to accept
            to that which can be held in a fixed bin (17) value.  This should
            be changed to fixed bin (35) by changing the declaration of
            range.size and range_size in the specification structures.
06/07/84 by Lee Baldwin:  Renamed dm_error_$rel_cursor_pos_bad to
            $bad_rel_cursor_pos.
10/28/84 by Lindsey L. Spratt:  Changed to use version 2 interval_list, and to
            check the version of this structure.
11/02/84 by Stanford S.  Cox: MAIN: Added version check of relation_cursor,
            chg to copy parameters.  FINISH: Chg to call FREE_SPEC*, add free
            of structures alloc in RETURN*.  FREE_SPEC*: Chg to also free
            numeric specs.  COPY_VALUE: Removed based clause from
            cv_value_string dcl.  SETUP_INT_SPEC: Asgn. MAX_FB35_VALUE to
            max_#_tuples.  RTVL: Chg.  typed_vector_list_ptr check to be an
            if-then-else, moved typed_vector_list to MAIN.  RTVA: Chg.
            typed_vector_array_ptr check to be an if-then-else, added
            typed_vector_array version check, chg.  tva to use explicit ptr
            refs so local tva not reqd.  REIL: Chg.  element_id_list check to
            be an if-then-else, chg.  eil to use explicit ptr refs so local
            eil not reqd.  
11/30/84 by Stanford S. Cox: RECORD_DATA: Chg nested if structure which calls
	  RECORD*RETURN. FTVA: Chg to return if tva_ptr is null. SI: Chg to
	  free eil. SIC: Chg to delete sic_cursor_ptr if ^null. RTVA: Add
	  call to sub_err.
12/02/84 by Lindsey L. Spratt:  Changed to use dm_vector_util_ instead of
            vector_util_.
12/08/84 by Lindsey L. Spratt:  Renamed dm_error_$rel_cursor_pos_bad to
            $bad_rel_cursor_pos.
01/17/84 by Stanford S. Cox: FINISH: Chg to free internal spec instead of
	  calling FREE_SPECIFICATION.
03/01/85 by S. Cox: Removed declared & unreferenced variables.
03/10/85 by Lindsey Spratt: Fixed to FINISH to check
	  local_typed_vector_array_ptr ^= null (instead of
	  local_typed_vector_list_ptr ^= null) before freeing
	  the local_typed_vector_array.
03/11/85 by Lindsey L. Spratt:  Fixed RETURN_TYPED_VECTOR_ARRAY to set the
            number_of_vectors in the output tva (pointed at by
            rtva_typed_vector_array_ptr).
03/19/85 by Lindsey L. Spratt:  Fixed to handle the TUPLE_ID_FIELD_ID when
            doing a get for which all of the desired fields are in the index
            being searched.
*/

/* format: style2,ind3 */

rlm_general_search:
   proc ();
      return;					/* Not a legal entry. */

/* START OF DECLARATIONS */
/* Parameter */

      dcl	    p_specification_ptr    ptr parameter;
      dcl	    p_caller_area_ptr      ptr parameter;
      dcl	    p_id_list_ptr	       ptr parameter;
      dcl	    p_relation_cursor_ptr  ptr parameter;
      dcl	    p_element_id_list_ptr  ptr parameter;
      dcl	    p_typed_vector_array_ptr
			       ptr parameter;
      dcl	    p_typed_vector_list_ptr
			       ptr parameter;
      dcl	    p_tuple_count	       fixed bin (35) parameter;
      dcl	    p_code	       fixed bin (35) parameter;

/* Automatic */

      dcl	    (local_typed_vector_list_ptr, local_typed_vector_array_ptr, local_element_id_list_ptr)
			       ptr;

      dcl	    (caller_area_ptr, interval_element_id_list_ptr, old_search_specification_ptr, internal_specification_ptr,
	    internal_cursor_ptr, internal_record_cursor_ptr, return_eil_or_tva_array_ptr, return_tva_array_ptr)
			       ptr init (null);

      dcl	    (current_collection_id, previous_collection_id)
			       bit (36) aligned init ("0"b);

      dcl	    (current_index_idx, record_id_idx, index_id_idx, element_idx, current_and_group_idx, and_group_idx,
	    return_structure_idx)  fixed bin;

      dcl	    (maximum_number_of_tuples_to_accept, number_of_and_groups, number_of_tuples_accepted,
	    number_of_tuples_accepted_by_this_and_group, reota_number_of_entries, rta_number_of_entries)
			       fixed bin (35) init (0);

      dcl	    (all_desired_fields_are_in_index, get_id, get_typed_vector_list, get_tuple, get_tuples_and_ids, get_count,
	    search_records, is_search_specification, is_numeric_specification, is_relative_specification, found_tuple)
			       bit (1) aligned init ("0"b);

      dcl	    1 local_relation_cursor
			       aligned like relation_cursor;

      dcl	    1 local_id_list,
	      2 version	       fixed bin (35),
	      2 number_of_ids      fixed bin (17),
	      2 id	       (1) fixed bin (17);

      dcl	    1 local_return_eil_or_tva_entry
			       (1) like return_eil_or_tva_array;
						/* used if only 1 entry of return= needed */

      dcl	    1 local_return_tva_entry
			       (1) like return_tva_array;
						/* used if only 1 entry of return= needed */

/* Based */

      dcl	    work_area	       area (1024) based (work_area_ptr);
      dcl	    caller_area	       area (1024) based (caller_area_ptr);
      dcl	    based_bit_36_aligned   bit (36) aligned based;
      dcl	    1 return_eil_or_tva_array
			       (reota_number_of_entries) aligned based (return_eil_or_tva_array_ptr),
	      2 flags	       unal,
	        3 is_element_id_list
			       bit (1) unal,
	        3 mbz	       bit (71) unal,
	      2 ptr	       ptr;

      dcl	    1 return_tva_array     (rta_number_of_entries) aligned based (return_tva_array_ptr),
	      2 ptr	       ptr;

/* Builtin */

      dcl	    (addr, hbound, max, min, null, unspec)
			       builtin;

/* Condition */

      dcl	    cleanup	       condition;

/* Constant */

      dcl	    (
	    myname	       init ("rlm_general_search") char (32) varying,
	    BITS_PER_BYTE	       init (9) fixed bin,
	    BITS_PER_WORD	       init (36) fixed bin,
	    MAX_FB17_VALUE	       init (131071) fixed bin,
	    MAXIMUM_FB35_VALUE     init (3e10) fixed bin (35),
	    TUPLE_ID_FIELD_ID      init (-1) fixed bin (35)
	    )		       internal static options (constant);
      dcl	    (
	    IS_ELEMENT_ID_LIST     init ("1"b),
	    IS_TYPED_VECTOR_ARRAY  init ("0"b),
	    IS_RECORD_COLLECTION   init ("1"b),
	    IS_INDEX_COLLECTION    init ("0"b),
	    USE_RELATION_CURSOR    init ("1"b),
	    USE_PREVIOUS_CURSOR    init ("0"b)
	    )		       bit (1) aligned internal static options (constant);

/* Entry */

      dcl	    get_dm_free_area_      entry () returns (ptr);
      dcl	    rlm_opening_info$get   entry (bit (36) aligned, ptr, fixed bin (35));
      dcl	    sub_err_	       entry () options (variable);
      dcl	    dm_vector_util_$copy_typed_vector
			       entry (ptr, ptr, ptr, ptr, fixed bin (35));

/* External */

      dcl	    (
	    dm_error_$bad_rel_cursor_pos,
	    dm_error_$index_not_in_relation,
	    dm_error_$key_not_found,
	    dm_error_$programming_error,
	    dm_error_$record_not_found,
	    dm_error_$rel_cursor_spec_mismatch,
	    dm_error_$tuple_not_found,
	    error_table_$unimplemented_version
	    )		       fixed bin (35) ext;

/* Static */

      dcl	    work_area_ptr	       ptr init (null) internal static;

/* END OF DECLARATIONS */

/* format: ^indblkcom,indcomtxt */

get_list_by_spec:
   entry (p_relation_cursor_ptr, p_specification_ptr, p_id_list_ptr, p_caller_area_ptr, p_typed_vector_list_ptr, p_code);
      get_tuple = "1"b;
      get_typed_vector_list = "1"b;
      caller_area_ptr = p_caller_area_ptr;
      local_typed_vector_list_ptr = p_typed_vector_list_ptr;
      if p_id_list_ptr ^= null
      then call CHECK_VERSION_FB ("id_list", p_id_list_ptr -> id_list.version, (ID_LIST_VERSION_1));
      goto JOIN;

get_array_by_spec:
   entry (p_relation_cursor_ptr, p_specification_ptr, p_id_list_ptr, p_caller_area_ptr, p_typed_vector_array_ptr, p_code);
      get_tuple = "1"b;
      get_typed_vector_list = "0"b;
      caller_area_ptr = p_caller_area_ptr;
      local_typed_vector_array_ptr = p_typed_vector_array_ptr;
      if p_id_list_ptr ^= null
      then call CHECK_VERSION_FB ("id_list", p_id_list_ptr -> id_list.version, (ID_LIST_VERSION_1));
      goto JOIN;


get_id:
   entry (p_relation_cursor_ptr, p_specification_ptr, p_caller_area_ptr, p_element_id_list_ptr, p_code);
      get_id = "1"b;
      caller_area_ptr = p_caller_area_ptr;
      local_element_id_list_ptr = p_element_id_list_ptr;
      if p_element_id_list_ptr ^= null
      then call CHECK_VERSION_FB ("element_id_list", p_element_id_list_ptr -> element_id_list.version,
	      ELEMENT_ID_LIST_VERSION_1);
      goto JOIN;

get_count:
   entry (p_relation_cursor_ptr, p_specification_ptr, p_tuple_count, p_code);
      get_count = "1"b;
      caller_area_ptr = null;
      goto JOIN;

get_list_and_ids:
   entry (p_relation_cursor_ptr, p_specification_ptr, p_id_list_ptr, p_caller_area_ptr, p_element_id_list_ptr,
        p_typed_vector_list_ptr, p_code);

      get_tuples_and_ids = "1"b;
      get_typed_vector_list = "1"b;
      caller_area_ptr = p_caller_area_ptr;
      local_typed_vector_list_ptr = p_typed_vector_list_ptr;
      local_element_id_list_ptr = p_element_id_list_ptr;
      if p_id_list_ptr ^= null
      then call CHECK_VERSION_FB ("id_list", p_id_list_ptr -> id_list.version, (ID_LIST_VERSION_1));
      if p_element_id_list_ptr ^= null
      then call CHECK_VERSION_FB ("element_id_list", p_element_id_list_ptr -> element_id_list.version,
	      ELEMENT_ID_LIST_VERSION_1);
      goto JOIN;

get_array_and_ids:
   entry (p_relation_cursor_ptr, p_specification_ptr, p_id_list_ptr, p_caller_area_ptr, p_element_id_list_ptr,
        p_typed_vector_array_ptr, p_code);

      get_tuples_and_ids = "1"b;
      get_typed_vector_list = "0"b;
      caller_area_ptr = p_caller_area_ptr;
      local_typed_vector_array_ptr = p_typed_vector_array_ptr;
      local_element_id_list_ptr = p_element_id_list_ptr;
      if p_id_list_ptr ^= null
      then call CHECK_VERSION_FB ("id_list", p_id_list_ptr -> id_list.version, (ID_LIST_VERSION_1));
      if p_element_id_list_ptr ^= null
      then call CHECK_VERSION_FB ("element_id_list", p_element_id_list_ptr -> element_id_list.version,
	      ELEMENT_ID_LIST_VERSION_1);

      goto JOIN;
%page;
JOIN:
      relation_cursor_ptr = p_relation_cursor_ptr;
      call CHECK_VERSION ("relation_cursor", relation_cursor.version, RELATION_CURSOR_VERSION_2);
      if work_area_ptr = null
      then work_area_ptr = get_dm_free_area_ ();

      id_list_ptr, element_id_list_ptr, typed_vector_array_ptr, relation_search_specification_ptr,
	 search_specification_ptr, relation_numeric_specification_ptr, numeric_specification_ptr,
	 internal_specification_ptr, internal_cursor_ptr = null;

      specification_head_ptr = p_specification_ptr;
      if specification_head_ptr ^= null
      then
         do;
	  call CHECK_VERSION_FB ("specification", specification_head.version, SPECIFICATION_VERSION_4);


	  if specification_head.type = ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
	       | specification_head.type = RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
	  then
	     do;
	        is_search_specification = "1"b;
	        relation_search_specification_ptr = specification_head_ptr;
	     end;
	  else if specification_head.type = ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
	       | specification_head.type = RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
	  then
	     do;
	        is_numeric_specification = "1"b;
	        relation_numeric_specification_ptr = specification_head_ptr;
	     end;

	  if specification_head.type = RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
	       | specification_head.type = RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
	  then is_relative_specification = "1"b;
         end;

/**** Set up opening information structures. */

      call rlm_opening_info$get (relation_cursor.file_opening_id, relation_opening_info_ptr, p_code);
      if p_code ^= 0
      then call ERROR_RETURN (p_code);

      call CHECK_VERSION ("relation_opening_info", relation_opening_info.version, RELATION_OPENING_INFO_VERSION_2);

      relation_header_ptr = relation_opening_info.relation_header_ptr;
      call CHECK_VERSION ("relation_header", relation_header.version, RELATION_HEADER_VERSION_3);

      attribute_info_ptr = relation_opening_info.attribute_info_ptr;
      call CHECK_VERSION ("attribute_info", attribute_info.version, ATTRIBUTE_INFO_VERSION_1);

      index_attribute_map_ptr = relation_opening_info.index_attribute_map_ptr;
      call CHECK_VERSION ("index_attribute_map", index_attribute_map.version, INDEX_ATTRIBUTE_MAP_VERSION_2);

/**** Set up current state of search. */

      if is_search_specification
      then number_of_and_groups = relation_search_specification.number_of_and_groups;
      else number_of_and_groups = 1;

      call CHECK_CURSOR_STATE (is_relative_specification, is_search_specification, is_numeric_specification,
	 current_and_group_idx);			/* Also returns current_and_group_idx */

      on cleanup call FINISH ();

      call SETUP_INTERNAL_SPECIFICATION (is_search_specification, is_numeric_specification, is_relative_specification,
	 internal_specification_ptr, maximum_number_of_tuples_to_accept);
						/* Returns internal_specification_ptr, maximum...accept */
      call SETUP_RETURN_STRUCTURES (max (1, number_of_and_groups), (get_id | get_tuples_and_ids),
	 (get_tuple | get_tuples_and_ids), return_eil_or_tva_array_ptr, return_tva_array_ptr);

AND_GROUP_LOOP:
      do and_group_idx = current_and_group_idx to number_of_and_groups
	 while (number_of_tuples_accepted < maximum_number_of_tuples_to_accept);

      /*** Satisfy the constraints of each and-group. */

         search_records = "0"b;

         previous_collection_id = current_collection_id;
         call SET_CURRENT_COLLECTION_ID (is_search_specification, is_numeric_specification, and_group_idx,
	    current_collection_id, current_index_idx);	/* Set the collection_id from the specification. */

         if is_relative_specification & and_group_idx = current_and_group_idx
         then
	  do;

	  /*** This is the first and-group of a relative specification to be processed.
	       Use the internal cursor already present in the relation_cursor. */

	     call SETUP_INTERNAL_CURSOR (USE_RELATION_CURSOR, (current_index_idx = -1), current_collection_id, ("0"b),
		internal_cursor_ptr);
	  end;
         else
	  do;

	  /*** This is not a relative search, or this is not the first and-group processed.
	       Setup a cursor and a specification to satisfy the constraints of this and-group.
	       Re-use the previous internal cursor if the same collection is being searched. */

	     call SETUP_INTERNAL_CURSOR (USE_PREVIOUS_CURSOR, (current_index_idx = -1), current_collection_id,
		previous_collection_id, internal_cursor_ptr);
						/* Get an index or record cursor for the current collection. */

	     call SETUP_INTERNAL_SPECIFICATION_FOR_THIS_AND_GROUP (internal_specification_ptr, and_group_idx,
		is_search_specification, is_numeric_specification,
		(maximum_number_of_tuples_to_accept - number_of_tuples_accepted));
						/* Convert this and-group into a proper internal specification. */
	  end;

         if current_index_idx = -1
         then call SEARCH_RECORD_COLLECTION (found_tuple);
         else call SEARCH_INDEX (found_tuple);

         if found_tuple
         then
RECORD_DATA:
	  do;
	     return_structure_idx = max (1, and_group_idx);

	     if get_id
	     then if search_records
		then call RECORD_IDS_TO_RETURN (IS_ELEMENT_ID_LIST, return_structure_idx, element_id_list_ptr,
			number_of_tuples_accepted_by_this_and_group);
		else if get_tuples_and_ids
		then call RECORD_IDS_TO_RETURN (IS_ELEMENT_ID_LIST, return_structure_idx, element_id_list_ptr,
			number_of_tuples_accepted_by_this_and_group);
		else call RECORD_IDS_TO_RETURN (IS_TYPED_VECTOR_ARRAY, return_structure_idx, typed_vector_array_ptr,
			number_of_tuples_accepted_by_this_and_group);
	     else if get_tuple
	     then call RECORD_TUPLES_TO_RETURN (return_structure_idx, typed_vector_array_ptr,
		     number_of_tuples_accepted_by_this_and_group);
	     else if get_tuples_and_ids
	     then
	        do;
		 if search_records
		 then call RECORD_IDS_TO_RETURN (IS_ELEMENT_ID_LIST, return_structure_idx, element_id_list_ptr,
			 number_of_tuples_accepted_by_this_and_group);
		 else if get_tuples_and_ids
		 then call RECORD_IDS_TO_RETURN (IS_ELEMENT_ID_LIST, return_structure_idx, element_id_list_ptr,
			 number_of_tuples_accepted_by_this_and_group);
		 else call RECORD_IDS_TO_RETURN (IS_TYPED_VECTOR_ARRAY, return_structure_idx, typed_vector_array_ptr,
			 number_of_tuples_accepted_by_this_and_group);
		 call RECORD_TUPLES_TO_RETURN (return_structure_idx, typed_vector_array_ptr,
		      number_of_tuples_accepted_by_this_and_group);
	        end;

	     number_of_tuples_accepted = number_of_tuples_accepted + number_of_tuples_accepted_by_this_and_group;
	  end RECORD_DATA;

      end AND_GROUP_LOOP;

      and_group_idx = and_group_idx - 1;

      if ^get_count
      then if number_of_tuples_accepted = 0
	 then p_code = dm_error_$tuple_not_found;
	 else
	    do;
	       if get_tuple | get_tuples_and_ids
	       then if get_typed_vector_list
		  then call RETURN_TYPED_VECTOR_LIST (number_of_tuples_accepted, local_typed_vector_list_ptr);
		  else call RETURN_TYPED_VECTOR_ARRAY (number_of_tuples_accepted, local_typed_vector_array_ptr);

	       if get_id | get_tuples_and_ids
	       then call RETURN_ELEMENT_ID_LIST (number_of_tuples_accepted, local_element_id_list_ptr);

	       call RESET_CURSOR (and_group_idx, current_collection_id, internal_specification_ptr, search_records,
		  internal_cursor_ptr, is_search_specification);
	    end;

      if get_typed_vector_list
      then p_typed_vector_list_ptr = local_typed_vector_list_ptr;
      if get_id | get_tuples_and_ids
      then p_element_id_list_ptr = local_element_id_list_ptr;
      if (get_tuple | get_tuples_and_ids) & ^get_typed_vector_list
      then p_typed_vector_array_ptr = local_typed_vector_array_ptr;
      call FINISH;
RETURN:
      return;
%page;
FINISH:
   proc;

      dcl	    f_tva_idx	       fixed bin;

      if get_typed_vector_list
      then if p_typed_vector_list_ptr = null & local_typed_vector_list_ptr ^= null
	 then free local_typed_vector_list_ptr -> typed_vector_list;
      if get_id | get_tuples_and_ids
      then if p_element_id_list_ptr = null & local_element_id_list_ptr ^= null
	 then free local_element_id_list_ptr -> element_id_list;
      if (get_tuple | get_tuples_and_ids) & ^get_typed_vector_list
      then if p_typed_vector_array_ptr = null & local_typed_vector_array_ptr ^= null
	 then free local_typed_vector_array_ptr -> typed_vector_array;

      if typed_vector_array_ptr ^= null
      then call FREE_TYPED_VECTOR_ARRAY (typed_vector_array_ptr);

      if id_list_ptr ^= null & id_list_ptr ^= addr (local_id_list) & id_list_ptr ^= p_id_list_ptr
      then free id_list in (work_area);

      if element_id_list_ptr ^= null
      then free element_id_list in (work_area);

      if interval_element_id_list_ptr ^= null
      then free interval_element_id_list_ptr -> element_id_list in (work_area);

      if interval_list_ptr ^= null
      then call FREE_INTERVAL_LIST (interval_list_ptr);

      if relation_cursor.flags.current_state_is_consistent
      then
         do;
	  if internal_specification_ptr ^= null
	       & internal_specification_ptr ^= relation_cursor.current.specification_ptr
	  then if is_numeric_specification
	       then free internal_specification_ptr -> numeric_specification in (work_area);
	       else free internal_specification_ptr -> search_specification;

	  if internal_cursor_ptr ^= null & internal_cursor_ptr ^= relation_cursor.current.cursor_ptr
	  then if current_collection_id = relation_header.record_collection_id
	       then call record_manager_$destroy_cursor (internal_cursor_ptr, (0));
	       else call index_manager_$destroy_cursor (internal_cursor_ptr, (0));
         end;

      if internal_record_cursor_ptr ^= null & internal_record_cursor_ptr ^= relation_cursor.current.cursor_ptr
      then call record_manager_$destroy_cursor (internal_record_cursor_ptr, (0));

      if return_tva_array_ptr ^= null
      then
         do;
	  do f_tva_idx = 1 to hbound (return_tva_array, 1);
	     if return_tva_array (f_tva_idx).ptr ^= null
	     then call FREE_TYPED_VECTOR_ARRAY (return_tva_array (f_tva_idx).ptr);
	  end;
	  if return_tva_array_ptr ^= addr (local_return_tva_entry)
	  then free return_tva_array in (work_area);
         end;

      if return_eil_or_tva_array_ptr ^= null
      then
         do;
	  do f_tva_idx = 1 to hbound (return_eil_or_tva_array, 1);
	     if return_eil_or_tva_array (f_tva_idx).ptr ^= null
	     then if return_eil_or_tva_array (f_tva_idx).flags.is_element_id_list
		then free return_eil_or_tva_array (f_tva_idx).ptr -> element_id_list;
		else call FREE_TYPED_VECTOR_ARRAY (return_eil_or_tva_array (f_tva_idx).ptr);
	  end;
	  if return_eil_or_tva_array_ptr ^= addr (local_return_eil_or_tva_entry)
	  then free return_eil_or_tva_array in (work_area);
	  else return_eil_or_tva_array_ptr = null;
         end;

   end FINISH;

ERROR_RETURN:
   proc (er_code);

      dcl	    er_code	       fixed bin (35);

      p_code = er_code;
      call FINISH;
      goto RETURN;


   end ERROR_RETURN;
%page;
CHECK_VERSION:
   proc (cv_structure_name, cv_received_version, cv_expected_version);
      dcl	    cv_received_version    char (8) aligned;
      dcl	    cv_expected_version    char (8) aligned;
      dcl	    cv_structure_name      char (*);

      if cv_received_version ^= cv_expected_version
      then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
	      "^/Expected version ^8a of the ^a structure.
Received version ^8a instead.", cv_expected_version, cv_structure_name, cv_received_version);

   end CHECK_VERSION;


CHECK_VERSION_FB:
   proc (cvf_structure_name, cvf_received_version, cvf_expected_version);
      dcl	    cvf_received_version   fixed bin (35);
      dcl	    cvf_expected_version   fixed bin (35);
      dcl	    cvf_structure_name     char (*);

      if cvf_received_version ^= cvf_expected_version
      then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
	      "^/Expected version ^d of the ^a structure.
Received version ^d instead.", cvf_expected_version, cvf_structure_name, cvf_received_version);

   end CHECK_VERSION_FB;
%page;
CHECK_CURSOR_STATE:
   proc (ccs_is_relative_specification, ccs_is_search_specification, ccs_is_numeric_specification, ccs_and_group_idx);

      dcl	    ccs_and_group_idx      fixed bin;
      dcl	    ccs_is_relative_specification
			       bit (1) aligned;
      dcl	    ccs_is_search_specification
			       bit (1) aligned;
      dcl	    ccs_is_numeric_specification
			       bit (1) aligned;

      call CHECK_VERSION ("relation_cursor", relation_cursor.version, RELATION_CURSOR_VERSION_2);

      if ccs_is_relative_specification
      then
CCS_RELATIVE_CURSOR_CHECK:
         do;
	  if ^relation_cursor.flags.current_state_is_consistent
	  then call sub_err_ (dm_error_$bad_rel_cursor_pos, myname, ACTION_CANT_RESTART, null, 0,
		  "^/The relative specification cannot be satisfied because the relation cursor^/does not completely describe a current position."
		  );

	  if relation_cursor.current.cursor_ptr = null
	  then call sub_err_ (dm_error_$bad_rel_cursor_pos, myname, ACTION_CANT_RESTART, null, 0,
		  "^/The relative specification cannot be satisfied because the relation cursor^/does not completely describe a current position."
		  );

	  if ccs_is_numeric_specification
	  then
	     do;
	        if relation_cursor.current.specification_ptr = null
	        then call sub_err_ (dm_error_$rel_cursor_spec_mismatch, myname, ACTION_CANT_RESTART, null, 0,
		        "^/Expected a numeric specification; received a null specification.");
	        if relation_cursor.current.specification_ptr -> specification_head.type
		   ^= ABSOLUTE_NUMERIC_SPECIFICATION_TYPE
		   & relation_cursor.current.specification_ptr -> specification_head.type
		   ^= RELATIVE_NUMERIC_SPECIFICATION_TYPE
	        then call sub_err_ (dm_error_$rel_cursor_spec_mismatch, myname, ACTION_CANT_RESTART, null, 0,
		        "^/Expected a search specification; received a numeric specification.");
	        if relation_numeric_specification.collection_id ^= relation_cursor.current.collection_id
	        then call sub_err_ (dm_error_$rel_cursor_spec_mismatch, myname, ACTION_CANT_RESTART, null, 0,
		        "^/Expected a specification for collection ^.3bo; received one for ^.3bo.",
		        relation_cursor.current.collection_id, relation_numeric_specification.collection_id);
	     end;
	  else if ccs_is_search_specification
	  then
	     do;
	        if relation_cursor.current.specification_ptr = null
	        then call sub_err_ (dm_error_$rel_cursor_spec_mismatch, myname, ACTION_CANT_RESTART, null, 0,
		        "^/Expected a search specification; received a null specification.");
	        if relation_cursor.current.specification_ptr -> specification_head.type
		   ^= ABSOLUTE_SEARCH_SPECIFICATION_TYPE
		   & relation_cursor.current.specification_ptr -> specification_head.type
		   ^= RELATIVE_SEARCH_SPECIFICATION_TYPE
	        then call sub_err_ (dm_error_$rel_cursor_spec_mismatch, myname, ACTION_CANT_RESTART, null, 0,
		        "^/Expected a numeric specification; received a search specification.");
	        if (relation_search_specification.number_of_and_groups > 0 & relation_cursor.current.and_group_idx < 1)
		   | relation_cursor.current.and_group_idx > relation_search_specification.number_of_and_groups
	        then call sub_err_ (dm_error_$rel_cursor_spec_mismatch, myname, ACTION_CANT_RESTART, null, 0,
		        "^/The current and-group is ^d; the given search specification has^/^[no^s^;^d^] and-group^[s^].",
		        relation_cursor.current.and_group_idx,
		        (relation_search_specification.number_of_and_groups = 0),
		        relation_search_specification.number_of_and_groups,
		        (relation_search_specification.number_of_and_groups ^= 1));
	        ;
	        if relation_search_specification.and_group (relation_cursor.current.and_group_idx).flags
		   .collection_id_supplied
	        then if relation_search_specification.and_group (relation_cursor.current.and_group_idx)
		        .search_collection_id ^= relation_cursor.current.collection_id
		   then call sub_err_ (dm_error_$rel_cursor_spec_mismatch, myname, ACTION_CANT_RESTART, null, 0,
			   "^/Expected a specification for collection ^.3bo; received one for ^.3bo.",
			   relation_cursor.current.collection_id,
			   relation_search_specification.and_group (relation_cursor.current.and_group_idx)
			   .search_collection_id);
		   else ;
	        else if relation_cursor.current.collection_id ^= relation_header.record_collection_id
	        then call sub_err_ (dm_error_$rel_cursor_spec_mismatch, myname, ACTION_CANT_RESTART, null, 0,
		        "^/Expected a specification for collection ^.3bo; received on with no^/collection specified.",
		        relation_cursor.current.collection_id);
	     end;
	  else if relation_cursor.current.specification_ptr ^= null
	  then call sub_err_ (dm_error_$rel_cursor_spec_mismatch, myname, ACTION_CANT_RESTART, null, 0,
		  "^/Expected a non-null specification; received a null specification.");

	  ccs_and_group_idx = relation_cursor.current.and_group_idx;
         end CCS_RELATIVE_CURSOR_CHECK;
      else if ccs_is_search_specification
      then ccs_and_group_idx = min (1, relation_search_specification.number_of_and_groups);
      else ccs_and_group_idx = 1;

      return;

   end CHECK_CURSOR_STATE;
%page;
CV_SEARCH_SPECIFICATION_FOR_INDEX:
   proc (cssfi_number_of_fields, cssfi_index_idx, cssfi_search_specification_ptr, cssfi_search_records);

/* This subroutine converts the attribute_ids in the internal specification
   into field_ids for the given index.  If an attribute is not a field in a
   key, the attribute_id is negated.  This tells inex_manager_ to ignore
   the constraint.  If constraint.value_field_id is -1 (indicating no
   value_field_id) or if value_field_id and field_id are in the index, then
   both are translated.  Otherwise, the value of value_field_id is left
   unchanged and the value of field_id is negated.  Reference is made to
   and_group (1) since an internal_specification contains only one and group.

   As a side-effect, this subroutine also
   determines if the search can be satisfied entirely by searching the index,
   or if it is necessry to also search the records. */

      dcl	    cssfi_number_of_fields fixed bin parameter;
      dcl	    cssfi_index_idx	       fixed bin parameter;
      dcl	    cssfi_search_specification_ptr
			       ptr parameter;
      dcl	    cssfi_search_records   bit (1) aligned parameter;

      dcl	    cssfi_field_map	       (cssfi_number_of_fields) fixed bin;
      dcl	    (cssfi_field_id, cssfi_value_field_id, cssfi_temp_value_field_id)
			       fixed bin init (0);
      dcl	    (cssfi_field_idx, cssfi_constraint_idx, cssfi_index_field_idx)
			       fixed bin;

      search_specification_ptr = cssfi_search_specification_ptr;

      do cssfi_field_idx = 1 to cssfi_number_of_fields;
         cssfi_field_map (cssfi_field_idx) = -cssfi_field_idx;
      end;

      do cssfi_index_field_idx = 1 to index_attribute_map.index (cssfi_index_idx).number_of_attributes;
         cssfi_field_map (index_attribute_map.index (cssfi_index_idx).attribute_id (cssfi_index_field_idx)) =
	    cssfi_index_field_idx;
      end;

      cssfi_search_records = "0"b;

      do cssfi_constraint_idx = 1 to search_specification.and_group (1).number_of_constraints;
         cssfi_field_id = cssfi_field_map (search_specification.and_group (1).constraint (cssfi_constraint_idx).field_id);
         cssfi_value_field_id = search_specification.and_group (1).constraint (cssfi_constraint_idx).value_field_id;

         if cssfi_value_field_id <= 0
         then
	  do;
	     search_specification.and_group (1).constraint (cssfi_constraint_idx).field_id = cssfi_field_id;
	     if cssfi_field_id < 0
	     then cssfi_search_records = "1"b;
	  end;
         else
	  do;
	     cssfi_temp_value_field_id = cssfi_field_map (cssfi_value_field_id);
	     if cssfi_temp_value_field_id > 0 & cssfi_field_id > 0
	     then
	        do;
		 search_specification.and_group (1).constraint (cssfi_constraint_idx).field_id = cssfi_field_id;
		 search_specification.and_group (1).constraint (cssfi_constraint_idx).value_field_id =
		      cssfi_temp_value_field_id;
	        end;
	     else
	        do;
		 search_specification.and_group (1).constraint (cssfi_constraint_idx).field_id =
		      -(search_specification.and_group (1).constraint (cssfi_constraint_idx).field_id);
		 cssfi_search_records = "1"b;
	        end;
	  end;
      end;

   end CV_SEARCH_SPECIFICATION_FOR_INDEX;
%page;
CV_SEARCH_SPECIFICATION_FOR_RECORDS:
   proc (cssfr_search_specification_ptr);

/* This routine converts the field_ids in the internal specification into
   field_ids of record.  This routine is called to undo the effects of
   CV_SEARCH_SPECIFICATION_FOR_INDEX by simply negating the field_ids.
   On input, the constraints which were not satisfied by the index search
   have negative field_ids; those that were have positive field_ids.
   This routine switches the sign of the field_ids so that those constraints
   that were satisfied by the index search will be ignored, and those that
   were previously ignored will be satisfied.  value_field_ids are not changed
   because value_field_ids for un-satisfied constraints were never negated. */

      dcl	    cssfr_search_specification_ptr
			       ptr parameter;

      dcl	    cssfr_constraint_idx   fixed bin;

INVERT_SEARCH_SPECIFICATION:
   entry (cssfr_search_specification_ptr);

      do cssfr_constraint_idx = 1
	 to cssfr_search_specification_ptr -> search_specification.and_group (1).number_of_constraints;
         cssfr_search_specification_ptr -> search_specification.and_group (1).constraint (cssfr_constraint_idx).field_id =
	    -cssfr_search_specification_ptr
	    -> search_specification.and_group (1).constraint (cssfr_constraint_idx).field_id;
      end;

   end CV_SEARCH_SPECIFICATION_FOR_RECORDS;
%page;
COPY_VALUE:
   proc (cv_arg_descriptor_ptr, cv_source_value_ptr, cv_target_value_ptr);

      dcl	    cv_arg_descriptor_ptr  ptr parameter;
      dcl	    cv_source_value_ptr    ptr parameter;
      dcl	    cv_target_value_ptr    ptr parameter;
      dcl	    cv_value_string_size   fixed bin (35) init (0);
      dcl	    cv_value_string	       bit (cv_value_string_size) based;
      dcl	    cv_based_real_fix_bin_1u
			       fixed bin (35) unal based;
      dcl	    cv_code	       fixed bin (35) init (0);

      dcl	    data_format_util_$get_data_bit_length
			       entry (bit (36) aligned, fixed bin (35), fixed bin (35));

      arg_descriptor_ptr = cv_arg_descriptor_ptr;
      if arg_descriptor.type = varying_char_dtype
      then cv_value_string_size = cv_source_value_ptr -> cv_based_real_fix_bin_1u * BITS_PER_BYTE + BITS_PER_WORD;
      else if arg_descriptor.type = varying_bit_dtype
      then cv_value_string_size = cv_source_value_ptr -> cv_based_real_fix_bin_1u + BITS_PER_WORD;
      else call data_format_util_$get_data_bit_length (unspec (arg_descriptor), cv_value_string_size, cv_code);
      if cv_code ^= 0
      then call ERROR_RETURN (cv_code);
      alloc cv_value_string in (relation_cursor.work_area_ptr -> work_area) set (cv_target_value_ptr);
      cv_target_value_ptr -> cv_value_string = cv_source_value_ptr -> cv_value_string;

      return;


%include std_descriptor_types;
%include arg_descriptor;

   end COPY_VALUE;
%page;
FREE_INTERVAL_LIST:
   proc (fil_p_interval_list_ptr);

      dcl	    fil_p_interval_list_ptr
			       ptr;
      dcl	    fil_interval_idx       fixed bin;

      if fil_p_interval_list_ptr ^= null
      then
         do;
	  do fil_interval_idx = 1 to hbound (fil_p_interval_list_ptr -> interval_list.interval, 1);
	     if fil_p_interval_list_ptr -> interval_list.interval (fil_interval_idx).and_group_id_list_ptr ^= null
	     then free fil_p_interval_list_ptr -> interval_list.interval (fil_interval_idx).and_group_id_list_ptr
		     -> id_list;
	  end;
	  free fil_p_interval_list_ptr -> interval_list;
         end;

      return;

   end FREE_INTERVAL_LIST;
%page;
FREE_SPECIFICATION:
   proc (fs_specification_ptr);

      dcl	    fs_specification_ptr   ptr parameter;
      dcl	    fs_and_group_idx       fixed bin init (-1);
      dcl	    fs_constraint_idx      fixed bin init (-1);
      dcl	    fs_dummy_value	       bit (1) based;

      if fs_specification_ptr -> specification_head.type = ABSOLUTE_NUMERIC_SPECIFICATION_TYPE
	 | fs_specification_ptr -> specification_head.type = RELATIVE_NUMERIC_SPECIFICATION_TYPE
      then free fs_specification_ptr -> numeric_specification;
      else if fs_specification_ptr -> specification_head.type = ABSOLUTE_SEARCH_SPECIFICATION_TYPE
	 | fs_specification_ptr -> specification_head.type = RELATIVE_SEARCH_SPECIFICATION_TYPE
      then
         do;
	  do fs_and_group_idx = 1 to fs_specification_ptr -> search_specification.number_of_and_groups;
	     do fs_constraint_idx = 1
		to fs_specification_ptr -> search_specification.and_group (fs_and_group_idx).number_of_constraints;
	        free fs_specification_ptr
		   -> search_specification.and_group (fs_and_group_idx).constraint (fs_constraint_idx).value_ptr
		   -> fs_dummy_value;
	     end;
	  end;
         end;
      return;

   end FREE_SPECIFICATION;
%page;
FREE_TYPED_VECTOR_ARRAY:
   proc (ftva_typed_vector_array_ptr);

      dcl	    ftva_typed_vector_array_ptr
			       ptr parameter;
      dcl	    ftva_vector_ptr	       ptr;
      dcl	    ftva_vector_idx	       fixed bin;
      dcl	    ftva_value_idx	       fixed bin;
      dcl	    ftva_dummy_value       bit (1) based;

      if ftva_typed_vector_array_ptr ^= null ()
      then
         do;
	  do ftva_vector_idx = 1 to ftva_typed_vector_array_ptr -> typed_vector_array.number_of_vectors;
	     if ftva_typed_vector_array_ptr -> typed_vector_array.vector_slot (ftva_vector_idx) ^= null
	     then
	        do;
		 ftva_vector_ptr = ftva_typed_vector_array_ptr -> typed_vector_array.vector_slot (ftva_vector_idx);
		 if ftva_vector_ptr -> simple_typed_vector.type = SIMPLE_TYPED_VECTOR_TYPE
		 then
		    do;
		       do ftva_value_idx = 1 to ftva_vector_ptr -> simple_typed_vector.number_of_dimensions;
			if ftva_vector_ptr -> simple_typed_vector.value_ptr (ftva_value_idx) ^= null
			then
			   do;
			      free ftva_vector_ptr -> simple_typed_vector.value_ptr (ftva_value_idx)
				 -> ftva_dummy_value;
			      ftva_vector_ptr -> simple_typed_vector.value_ptr (ftva_value_idx) = null;
			   end;
		       end;

		       free ftva_vector_ptr -> simple_typed_vector;
		       ftva_typed_vector_array_ptr -> typed_vector_array.vector_slot (ftva_vector_idx) = null;
		    end;
	        end;
	  end;

	  free ftva_typed_vector_array_ptr -> typed_vector_array;
	  ftva_typed_vector_array_ptr = null;

	  return;
         end;

   end FREE_TYPED_VECTOR_ARRAY;
%page;
RECORD_IDS_TO_RETURN:
   proc (ritr_is_element_id_list, ritr_and_group_idx, ritr_eil_or_tva_ptr, ritr_number_of_tuple_ids);

/* This subroutine records the location of a data structure containing
   the tuple ids found by a particular and-group. The data structure is
   either an element_id_list or a typed_vector_array containing simple_typed_vectors of a single dimension. */

      dcl	    ritr_is_element_id_list
			       bit (1) aligned;
      dcl	    ritr_and_group_idx     fixed bin;
      dcl	    ritr_eil_or_tva_ptr    ptr;
      dcl	    ritr_number_of_tuple_ids
			       fixed bin (35);

      return_eil_or_tva_array (ritr_and_group_idx).flags.is_element_id_list = ritr_is_element_id_list;
      return_eil_or_tva_array (ritr_and_group_idx).ptr = ritr_eil_or_tva_ptr;

      if ritr_is_element_id_list
      then ritr_number_of_tuple_ids = ritr_eil_or_tva_ptr -> element_id_list.number_of_elements;
      else ritr_number_of_tuple_ids = ritr_eil_or_tva_ptr -> typed_vector_array.number_of_vectors;

      ritr_eil_or_tva_ptr = null;

      return;

   end RECORD_IDS_TO_RETURN;
%page;
RECORD_TUPLES_TO_RETURN:
   proc (rttr_and_group_idx, rttr_tva_ptr, rttr_number_of_tuples);

/* This subroutine records the location of typed_vector_array containing
   the tuples found by a particular and-group. */

      dcl	    rttr_and_group_idx     fixed bin;
      dcl	    rttr_tva_ptr	       ptr;
      dcl	    rttr_number_of_tuples  fixed bin (35);


      return_tva_array (rttr_and_group_idx).ptr = rttr_tva_ptr;

      rttr_number_of_tuples = rttr_tva_ptr -> typed_vector_array.number_of_vectors;

      rttr_tva_ptr = null;

      return;

   end RECORD_TUPLES_TO_RETURN;
%page;
RESET_CURSOR:
   proc (rc_and_group_idx, rc_collection_id, rc_specification_ptr, rc_search_records, rc_cursor_ptr,
        rc_is_search_specification);

/* This subroutine destroys information kept to maintain the previous
   current state, replacing with information about the new current state.
*/

      dcl	    rc_and_group_idx       fixed bin parameter;
      dcl	    rc_collection_id       bit (36) aligned parameter;
      dcl	    rc_specification_ptr   ptr parameter;
      dcl	    rc_search_records      bit (1) aligned parameter;
      dcl	    rc_cursor_ptr	       ptr parameter;
      dcl	    rc_is_search_specification
			       bit (1) aligned parameter;
      dcl	    rc_constraint_idx      fixed bin init (-1);
      dcl	    rc_value_ptr	       ptr init (null);
      dcl	    rc_code	       fixed bin (35) init (0);

      relation_cursor.flags.current_state_is_consistent = "0"b;

      if relation_cursor.current.cursor_ptr ^= null
      then if relation_cursor.current.cursor_ptr ^= rc_cursor_ptr
	 then if relation_cursor.current.collection_id = relation_header.record_collection_id
	      then call record_manager_$destroy_cursor (relation_cursor.current.cursor_ptr, rc_code);
	      else call index_manager_$destroy_cursor (relation_cursor.current.cursor_ptr, rc_code);

      if relation_cursor.current.specification_ptr ^= null
      then if rc_specification_ptr ^= relation_cursor.current.specification_ptr
	 then call FREE_SPECIFICATION (relation_cursor.current.specification_ptr);

      relation_cursor.current.and_group_idx = rc_and_group_idx;
      relation_cursor.current.collection_id = rc_collection_id;
      relation_cursor.current.specification_ptr = rc_specification_ptr;
      relation_cursor.current.search_index_and_record_collection = rc_search_records;
      relation_cursor.current.cursor_ptr = rc_cursor_ptr;

      if rc_specification_ptr ^= null & rc_is_search_specification & rc_and_group_idx > 0
      then
         do;

         /*** Copy values from relation_search_specification to internal specification. */

	  do rc_constraint_idx = 1 to relation_search_specification.and_group (rc_and_group_idx).number_of_constraints;
	     call COPY_VALUE (
		addr (attribute_info
		.
		attribute (relation_search_specification.and_group (rc_and_group_idx).constraint (rc_constraint_idx)
		.field_id).descriptor),
		relation_search_specification.and_group (rc_and_group_idx).constraint (rc_constraint_idx).value_ptr,
		rc_value_ptr);
	     rc_specification_ptr -> search_specification.and_group (1).constraint (rc_constraint_idx).value_ptr =
		rc_value_ptr;
	  end;
         end;

      rc_cursor_ptr, rc_specification_ptr = null;

      if rc_code = 0
      then relation_cursor.flags.current_state_is_consistent = "1"b;

      return;

   end RESET_CURSOR;
%page;
SEARCH_INDEX:
   proc (si_p_found_tuple);

      dcl	    si_p_found_tuple       bit (1) aligned parameter;
      dcl	    si_code	       fixed bin (35) init (0);

   /*** An index collection was specified. As much of the internal specification as possible
        will be satisfied by searching the index. If fields are constrained which
        are not in the index, then the record collection will also be searched. */



      if is_search_specification & internal_specification_ptr ^= null
      then if is_relative_specification & and_group_idx = current_and_group_idx
	 then
	    do;
	       search_records = relation_cursor.current.search_index_and_record_collection;
	       if search_records
	       then call INVERT_SEARCH_SPECIFICATION (internal_specification_ptr);
						/* The search_spec was set up for use with */
						/* the record_collection by the previous */
						/* invocation.  Inverting the field ids */
						/* make the ones for the indexed fields */
						/* positive and the ones for the record */
						/* collection negative. */
	    end;
	 else call CV_SEARCH_SPECIFICATION_FOR_INDEX ((attribute_info.number_of_attributes), current_index_idx,
		 internal_specification_ptr, search_records);


      call TRANSLATE_ID_LIST ();			/* Sets id_list_ptr and all_desired_fields_are_in_index. */

      if get_count & ^search_records
      then
         do;
	  call index_manager_$get_key_count_by_spec (internal_specification_ptr, internal_cursor_ptr, p_tuple_count,
	       si_code);
	  if si_code ^= 0
	  then call SI_ERROR_RETURN (si_code, dm_error_$key_not_found);
         end;
      else
         do;
	  call index_manager_$get_key (internal_specification_ptr, id_list_ptr, work_area_ptr, internal_cursor_ptr,
	       typed_vector_array_ptr, interval_list_ptr, si_code);
	  if si_code ^= 0
	  then call SI_ERROR_RETURN (si_code, dm_error_$key_not_found);
	  call CHECK_VERSION ("interval_list", interval_list.version, INTERVAL_LIST_VERSION_2);
         end;

      if search_records
      then
SEARCH_RECORDS:
         do;

         /*** The index search did not satisfy all of the constraints of the specification.
	    Set up an interval_element_id_list and use it in searching the tuple records
	    associated with the keys which were selected by the index search. */

	  call CV_SEARCH_SPECIFICATION_FOR_RECORDS (internal_specification_ptr);
	  eil_number_of_elements = typed_vector_array.number_of_vectors;
	  element_id_list_ptr = null;
	  alloc element_id_list in (work_area) set (interval_element_id_list_ptr);
	  interval_element_id_list_ptr -> element_id_list.version = ELEMENT_ID_LIST_VERSION_1;

	  do element_idx = 1 to typed_vector_array.number_of_vectors;
	     interval_element_id_list_ptr -> element_id_list.id (element_idx) =
		typed_vector_array.vector_slot (element_idx) -> simple_typed_vector.value_ptr (1)
		-> based_bit_36_aligned;
	  end;

	  call FREE_TYPED_VECTOR_ARRAY (typed_vector_array_ptr);

	  if internal_record_cursor_ptr = null
	  then call SETUP_INTERNAL_CURSOR (USE_PREVIOUS_CURSOR, IS_RECORD_COLLECTION,
		  relation_header.record_collection_id, ("0"b), internal_record_cursor_ptr);

	  if get_id
	  then call record_manager_$get_record_ids_by_interval (interval_element_id_list_ptr,
		  internal_specification_ptr, interval_list_ptr, work_area_ptr, internal_record_cursor_ptr,
		  element_id_list_ptr, si_code);
	  else if get_tuple
	  then call record_manager_$get_records_by_interval (interval_element_id_list_ptr, p_id_list_ptr,
		  internal_specification_ptr, interval_list_ptr, work_area_ptr, (TYPED_VECTOR_ARRAY_VERSION_2),
		  internal_record_cursor_ptr, typed_vector_array_ptr, si_code);
	  else if get_tuples_and_ids
	  then call record_manager_$get_records_and_ids_by_interval (interval_element_id_list_ptr, p_id_list_ptr,
		  internal_specification_ptr, interval_list_ptr, work_area_ptr, (TYPED_VECTOR_ARRAY_VERSION_2),
		  internal_record_cursor_ptr, element_id_list_ptr, typed_vector_array_ptr, si_code);
	  else call record_manager_$get_record_count_by_interval (interval_element_id_list_ptr,
		  internal_specification_ptr, interval_list_ptr, internal_record_cursor_ptr, p_tuple_count, si_code);

	  if si_code ^= 0
	  then call SI_ERROR_RETURN (si_code, dm_error_$record_not_found);
	  free interval_element_id_list_ptr -> element_id_list;
         end SEARCH_RECORDS;
      else if ^all_desired_fields_are_in_index & (get_tuple | get_tuples_and_ids)
      then
GET_DATA_FROM_RECORD_COLLECTION:
         do;
	  eil_number_of_elements = typed_vector_array.number_of_vectors;
	  alloc element_id_list in (work_area);
	  element_id_list.version = ELEMENT_ID_LIST_VERSION_1;

	  do element_idx = 1 to typed_vector_array.number_of_vectors;
	     element_id_list.id (element_idx) =
		typed_vector_array.vector_slot (element_idx) -> simple_typed_vector.value_ptr (1)
		-> based_bit_36_aligned;
	  end;

	  call FREE_TYPED_VECTOR_ARRAY (typed_vector_array_ptr);

	  call record_manager_$get_records_by_id_list (element_id_list_ptr, p_id_list_ptr, work_area_ptr,
	       (relation_opening_info.per_process.record_cursor_ptr), typed_vector_array_ptr, si_code);
	  if si_code ^= 0
	  then call ERROR_RETURN (si_code);

         end GET_DATA_FROM_RECORD_COLLECTION;

SI_MAIN_RETURN:
      si_p_found_tuple = (si_code = 0);

      call FREE_INTERVAL_LIST (interval_list_ptr);

      return;

SI_ERROR_RETURN:
   proc (ser_code, ser_non_fatal_code);

      dcl	    (ser_code, ser_non_fatal_code)
			       fixed bin (35);

      if ser_code ^= ser_non_fatal_code & ser_code ^= 0
      then call ERROR_RETURN (ser_code);

      goto SI_MAIN_RETURN;

   end SI_ERROR_RETURN;

   end SEARCH_INDEX;
%page;
SEARCH_RECORD_COLLECTION:
   proc (src_p_found_tuple);

      dcl	    src_p_found_tuple      bit (1) aligned parameter;
      dcl	    src_code	       fixed bin (35) init (0);

   /*** The caller specified the record collection should be used to
        satisfy the constraints of this and group.
        All searching will be done on the record collection directly. */

      search_records = "1"b;

      if get_id
      then call record_manager_$get_record_ids_by_spec (internal_specification_ptr, work_area_ptr, internal_cursor_ptr,
	      element_id_list_ptr, src_code);
      else if get_tuple
      then call record_manager_$get_records_by_spec (internal_specification_ptr, p_id_list_ptr, work_area_ptr,
	      internal_cursor_ptr, typed_vector_array_ptr, src_code);
      else if get_tuples_and_ids
      then call record_manager_$get_records_and_ids_by_spec (internal_specification_ptr, p_id_list_ptr, work_area_ptr,
	      internal_cursor_ptr, element_id_list_ptr, typed_vector_array_ptr, src_code);

      else if get_count
      then call record_manager_$get_record_count (internal_specification_ptr, internal_cursor_ptr, p_tuple_count,
	      src_code);
      if src_code ^= 0
      then if src_code ^= dm_error_$record_not_found
	 then call ERROR_RETURN (src_code);

      src_p_found_tuple = (src_code = 0);
      return;
   end SEARCH_RECORD_COLLECTION;
%page;
SET_CURRENT_COLLECTION_ID:
   proc (scci_is_search_specification, scci_is_numeric_specification, scci_and_group_idx, scci_collection_id,
        scci_index_idx);

/* This subroutine returns the value of the collection_id specified by the caller
   for this and-group or for this numeric specification, or, if none
   is specified, returns the record_collection_id. The element in the index attribute
   map containing the index collection, or -1 if collection is not an index, is returned.
*/

      dcl	    scci_is_search_specification
			       bit (1) aligned;
      dcl	    scci_is_numeric_specification
			       bit (1) aligned;
      dcl	    scci_and_group_idx     fixed bin;
      dcl	    scci_collection_id     bit (36) aligned;
      dcl	    scci_index_idx	       fixed bin;

      if scci_is_search_specification
      then if relation_search_specification.number_of_and_groups <= 0
	 then scci_collection_id = relation_header.record_collection_id;
	 else if relation_search_specification.and_group (scci_and_group_idx).flags.collection_id_supplied
	 then scci_collection_id = relation_search_specification.and_group (scci_and_group_idx).search_collection_id;
	 else scci_collection_id = relation_header.record_collection_id;
      else if scci_is_numeric_specification
      then scci_collection_id = relation_numeric_specification.collection_id;
      else scci_collection_id = relation_header.record_collection_id;

      if scci_collection_id = relation_header.record_collection_id
      then scci_index_idx = -1;
      else
         do;
	  do scci_index_idx = 1 to hbound (index_attribute_map.index, 1)
	       while (index_attribute_map.index (scci_index_idx).collection_id ^= scci_collection_id);
	  end;
	  if scci_index_idx > hbound (index_attribute_map.index, 1)
	  then call ERROR_RETURN (dm_error_$index_not_in_relation);
         end;

      return;

   end SET_CURRENT_COLLECTION_ID;
%page;
SETUP_INTERNAL_CURSOR:
   proc (sic_from_relation_cursor, sic_is_record_collection, sic_collection_id, sic_previous_collection_id,
        sic_cursor_ptr);

/* This subroutine function creates a cursor for the given collection, returning
   a pointer to the cursor. */

      dcl	    (sic_collection_id, sic_previous_collection_id)
			       bit (36) aligned;
      dcl	    (sic_from_relation_cursor, sic_is_record_collection)
			       bit (1) aligned;
      dcl	    sic_code	       fixed bin (35);
      dcl	    sic_cursor_ptr	       ptr;

      if sic_from_relation_cursor
      then
         do;

         /*** If the relation_cursor already has a cursor for this collection, use it
	    rather than create a new one. */

	  if relation_cursor.current.collection_id = sic_collection_id & relation_cursor.current.cursor_ptr ^= null
	  then sic_cursor_ptr = relation_cursor.current.cursor_ptr;
	  else
	     do;
	        if relation_cursor.current.collection_id ^= sic_collection_id
	        then call DESTROY_CURSOR;
	        call CREATE_CURSOR;
	     end;
         end;
      else
         do;
	  if sic_cursor_ptr = null
	  then call CREATE_CURSOR;
	  else if sic_collection_id ^= sic_previous_collection_id
	  then
	     do;
	        call DESTROY_CURSOR;
	        call CREATE_CURSOR;
	     end;
         end;

      return;					/* Effective end of SETUP_INTERNAL_CURSOR */



/**** Subroutines of SETUP_INTERNAL_CURSOR follow. ****/
%page;
/**** Begin subroutines of SETUP_INTERNAL_CURSOR. ****/

CREATE_CURSOR:
   proc ();

      if sic_is_record_collection
      then call record_manager_$create_cursor (relation_cursor.file_opening_id, sic_collection_id,
	      relation_cursor.work_area_ptr, sic_cursor_ptr, sic_code);
      else call index_manager_$create_cursor (relation_cursor.file_opening_id, sic_collection_id,
	      relation_cursor.work_area_ptr, sic_cursor_ptr, sic_code);
      if sic_code ^= 0
      then call ERROR_RETURN (sic_code);

   end CREATE_CURSOR;

DESTROY_CURSOR:
   proc ();

      if sic_is_record_collection
      then call record_manager_$destroy_cursor (sic_cursor_ptr, sic_code);
      else call index_manager_$destroy_cursor (sic_cursor_ptr, sic_code);
      if sic_code ^= 0
      then call ERROR_RETURN (sic_code);

   end DESTROY_CURSOR;

/**** End of subroutines of SETUP_INTERNAL_CURSOR. ****/

   end SETUP_INTERNAL_CURSOR;
%page;
SETUP_INTERNAL_SPECIFICATION:
   proc (sis_is_search_specification, sis_is_numeric_specification, sis_is_relative_specification, sis_specification_ptr,
        sis_maximum_number_of_tuples_to_accept);

      dcl	    sis_is_search_specification
			       bit (1) aligned;
      dcl	    sis_is_numeric_specification
			       bit (1) aligned;
      dcl	    sis_is_relative_specification
			       bit (1) aligned;
      dcl	    sis_specification_ptr  ptr;
      dcl	    sis_maximum_number_of_tuples_to_accept
			       fixed bin (35);

      if sis_is_relative_specification
      then
         do;
	  sis_specification_ptr = relation_cursor.current.specification_ptr;

	  if sis_is_numeric_specification
	  then
	     do;
	        sis_specification_ptr -> numeric_specification.type = RELATIVE_NUMERIC_SPECIFICATION_TYPE;
	        sis_specification_ptr -> numeric_specification.range_size = relation_numeric_specification.range_size;
	        sis_specification_ptr -> numeric_specification.position_number =
		   relation_numeric_specification.position_number;
	     end;
	  else if sis_is_search_specification
	  then
	     do;
	        sis_specification_ptr -> search_specification.head.type = RELATIVE_SEARCH_SPECIFICATION_TYPE;
	        sis_specification_ptr -> search_specification.range.size = relation_search_specification.range.size;
	     end;
         end;
      else if sis_is_search_specification
      then
         do;
	  ss_number_of_and_groups = max (0, min (1, relation_search_specification.number_of_and_groups));
	  ss_maximum_number_of_constraints = relation_search_specification.maximum_number_of_constraints;
	  alloc search_specification in (relation_cursor.work_area_ptr -> work_area) set (sis_specification_ptr);
	  sis_specification_ptr -> search_specification.head = relation_search_specification.head;
	  sis_specification_ptr -> search_specification.head.type = ABSOLUTE_SEARCH_SPECIFICATION_TYPE;
	  sis_specification_ptr -> search_specification.range = relation_search_specification.range;

	  if sis_specification_ptr -> search_specification.number_of_and_groups > 0
	  then sis_specification_ptr -> search_specification.and_group (1).number_of_constraints = 0;
         end;
      else if sis_is_numeric_specification
      then
         do;
	  alloc numeric_specification in (relation_cursor.work_area_ptr -> work_area) set (sis_specification_ptr);
	  sis_specification_ptr -> numeric_specification.head = relation_numeric_specification.head;
	  sis_specification_ptr -> numeric_specification.head.type = ABSOLUTE_NUMERIC_SPECIFICATION_TYPE;
	  sis_specification_ptr -> numeric_specification.position_number =
	       relation_numeric_specification.position_number;
	  sis_specification_ptr -> numeric_specification.range_size = relation_numeric_specification.range_size;
	  sis_specification_ptr -> numeric_specification.pad = "0"b;
         end;
      else sis_specification_ptr = null;

      if sis_is_search_specification
      then if relation_search_specification.range.type ^= ALL_RANGE_TYPE
	 then sis_maximum_number_of_tuples_to_accept = relation_search_specification.range.size;
	 else sis_maximum_number_of_tuples_to_accept = MAXIMUM_FB35_VALUE;
      else if sis_is_numeric_specification
      then sis_maximum_number_of_tuples_to_accept = relation_numeric_specification.range_size;
      else sis_maximum_number_of_tuples_to_accept = MAXIMUM_FB35_VALUE;

      return;

   end SETUP_INTERNAL_SPECIFICATION;
%page;
SETUP_INTERNAL_SPECIFICATION_FOR_THIS_AND_GROUP:
   proc (sisftag_specification_ptr, sisftag_and_group_idx, sisftag_is_search_specification,
        sisftag_is_numeric_specification, sisftag_maximum_number_of_tuples_to_accept);

      dcl	    sisftag_specification_ptr
			       ptr;
      dcl	    sisftag_is_search_specification
			       bit (1) aligned;
      dcl	    sisftag_is_numeric_specification
			       bit (1) aligned;
      dcl	    sisftag_maximum_number_of_tuples_to_accept
			       fixed bin (35);
      dcl	    sisftag_total_number_of_constraints
			       fixed bin init (0);
      dcl	    (sisftag_constraint_idx, sisftag_and_group_idx)
			       fixed bin;

      if sisftag_is_numeric_specification
      then sisftag_specification_ptr -> numeric_specification.range_size =
	      min (MAX_FB17_VALUE, sisftag_maximum_number_of_tuples_to_accept);

      else if sisftag_is_search_specification
      then
         do;
	  sisftag_specification_ptr -> search_specification.range.size =
	       min (MAX_FB17_VALUE, sisftag_maximum_number_of_tuples_to_accept);

	  if sisftag_specification_ptr -> search_specification.number_of_and_groups > 0
	  then
	     do;
	        sisftag_specification_ptr -> search_specification.and_group (1).number_of_constraints =
		   relation_search_specification.and_group (sisftag_and_group_idx).number_of_constraints;
	        do sisftag_constraint_idx = 1
		   to relation_search_specification.and_group (sisftag_and_group_idx).number_of_constraints;

	        /*** Copy the constraints for this and group from the relation specification to
		   the internal specification. */

		 sisftag_specification_ptr -> search_specification.and_group (1).constraint (sisftag_constraint_idx) =
		      relation_search_specification.and_group (sisftag_and_group_idx)
		      .constraint (sisftag_constraint_idx);
	        end;

	     end;
         end;

      return;


   end SETUP_INTERNAL_SPECIFICATION_FOR_THIS_AND_GROUP;
%page;
SETUP_RETURN_STRUCTURES:
   proc (srs_maximum_number_of_return_structures, srs_setup_for_ids, srs_setup_for_tuples,
        srs_return_eil_or_tva_array_ptr, srs_return_tva_array_ptr);

/* This subroutine sets up two arrays of pointers to return structures,
   element_id_lists or typed_vector_arrays, for those entries that return
   such data.  In each array, there is one entry for each and group.
   If more than one and-group is specified, the array is allocated. If only one
   and-group is specified, or if a numeric or null specification is specified,
   an automatic one element array is used. */

      dcl	    srs_maximum_number_of_return_structures
			       fixed bin (35);
      dcl	    srs_setup_for_ids      bit (1) aligned;
      dcl	    srs_setup_for_tuples   bit (1) aligned;
      dcl	    srs_return_eil_or_tva_array_ptr
			       ptr;
      dcl	    srs_return_tva_array_ptr
			       ptr;

      if srs_setup_for_ids
      then
         do;
	  reota_number_of_entries = max (1, srs_maximum_number_of_return_structures);

	  if srs_maximum_number_of_return_structures <= 1
	  then srs_return_eil_or_tva_array_ptr = addr (local_return_eil_or_tva_entry);
	  else
	     do;
	        alloc return_eil_or_tva_array in (work_area);
	        srs_return_eil_or_tva_array_ptr = return_eil_or_tva_array_ptr;
	     end;

	  unspec (srs_return_eil_or_tva_array_ptr -> return_eil_or_tva_array) = ""b;
	  srs_return_eil_or_tva_array_ptr -> return_eil_or_tva_array (*).flags.is_element_id_list = "0"b;
	  srs_return_eil_or_tva_array_ptr -> return_eil_or_tva_array (*).flags.mbz = "0"b;
	  srs_return_eil_or_tva_array_ptr -> return_eil_or_tva_array (*).ptr = null;
         end;

      if srs_setup_for_tuples
      then
         do;
	  rta_number_of_entries = max (1, srs_maximum_number_of_return_structures);

	  if srs_maximum_number_of_return_structures <= 1
	  then srs_return_tva_array_ptr = addr (local_return_tva_entry);
	  else
	     do;
	        alloc return_tva_array in (work_area);
	        srs_return_tva_array_ptr = return_tva_array_ptr;
	     end;

	  unspec (srs_return_tva_array_ptr -> return_tva_array) = ""b;
	  srs_return_tva_array_ptr -> return_tva_array (*).ptr = null;
         end;

      return;

   end SETUP_RETURN_STRUCTURES;
%page;
TRANSLATE_ID_LIST:
   proc ();


      if get_id | get_tuples_and_ids | (get_count & search_records)
      then
         do;

         /*** Tuple_ids are needed to return to the caller or to be used in
	    getting tuples from the record collection. Get the tuple_ids of keys
	    which match the specification in a typed_vector_array. This typed_vector_array
	    must be converted to an element_id_list later. */

	  all_desired_fields_are_in_index = "0"b;
	  local_id_list.id (1) = index_attribute_map.index (current_index_idx).number_of_attributes + 1;
	  local_id_list.version = ID_LIST_VERSION_1;
	  local_id_list.number_of_ids = 1;
	  id_list_ptr = addr (local_id_list);
         end;
      else if get_tuple
      then
         do;
	  all_desired_fields_are_in_index = "0"b;
	  id_list_ptr = null;
	  if ^search_records
	  then
	     do;

	     /*** The specification can be satisfied completely by searching the index.
		Determine if all fields to be returned to the caller are also in the index,
		and build an id_list that identifies the desired fields in the key (the fields
		in the key may have different ids than the fields in the tuple). */

	        all_desired_fields_are_in_index = "1"b;

	        if p_id_list_ptr ^= null
	        then
TRANSLATE_SPECIFIED_ID_LIST:				/* Translate the tuple field ids to key field ids. */
		 do;
		    il_number_of_ids = p_id_list_ptr -> id_list.number_of_ids;
		    alloc id_list in (work_area);
		    id_list.version = ID_LIST_VERSION_1;

RECORD_ID_LOOP:
		    do record_id_idx = 1 to id_list.number_of_ids while (all_desired_fields_are_in_index);

		       if p_id_list_ptr -> id_list.id (record_id_idx) = TUPLE_ID_FIELD_ID
		       then id_list.id (record_id_idx) =
			       index_attribute_map.index (current_index_idx).number_of_attributes + 1;
		       else
			do;
INDEX_ID_LOOP:
			   do index_id_idx = 1
			        to index_attribute_map.index (current_index_idx).number_of_attributes
			        while (p_id_list_ptr -> id_list.id (record_id_idx)
			        ^= index_attribute_map.index (current_index_idx).attribute_id (index_id_idx));
			   end INDEX_ID_LOOP;
			   if index_id_idx <= index_attribute_map.index (current_index_idx).number_of_attributes
			   then id_list.id (record_id_idx) = index_id_idx;
			   else all_desired_fields_are_in_index = "0"b;
						/* This tuple field is not present in the key. */
			end;
		    end RECORD_ID_LOOP;

		 end TRANSLATE_SPECIFIED_ID_LIST;
	        else if attribute_info.number_of_attributes
		   = index_attribute_map.index (current_index_idx).number_of_attributes
	        then
TRANSLATE_DEFAULT_ID_LIST:				/* The key contains all tuple fields. */
		 do;
		    all_desired_fields_are_in_index = "1"b;
		    il_number_of_ids = attribute_info.number_of_attributes;
		    alloc id_list in (work_area);
		    id_list.version = ID_LIST_VERSION_1;
		    do index_id_idx = 1 to il_number_of_ids;
		       id_list.id (index_attribute_map.index (current_index_idx).attribute_id (index_id_idx)) =
			  index_id_idx;
		    end;

		 end TRANSLATE_DEFAULT_ID_LIST;
	        else
		 do;
		    id_list_ptr = null;
		    all_desired_fields_are_in_index = "0"b;
		 end;
	     end;
	  if ^all_desired_fields_are_in_index
	  then
	     do;

	     /*** There exists at least one desired field which is not in the index.
		Getting this field will require getting the tuple record from the record collection,
		so there is no need to get fields from the index.
		Set up an id_list which will retrieve only the tuple_id field from keys.
		Free any id_list that was created
		previously, as it won't be needed after all. */

	        local_id_list.id (1) = index_attribute_map.index (current_index_idx).number_of_attributes + 1;
	        local_id_list.number_of_ids = 1;
	        local_id_list.version = ID_LIST_VERSION_1;
	        if id_list_ptr ^= null
	        then free id_list in (work_area);
	        id_list_ptr = addr (local_id_list);
	     end;
         end;

      return;

   end TRANSLATE_ID_LIST;
%page;
RETURN_TYPED_VECTOR_LIST:
   proc (rtvl_number_of_vectors, rtvl_typed_vector_list_ptr);


   /*** The caller expects the tuples to be returned in a typed_vector_list.
        Convert the typed_vector_array in the work_area to a typed_vector_list
        in the caller_area. */

      dcl	    rtvl_number_of_vectors fixed bin (35);	/* total number of vectors in return typed_vector_list */
      dcl	    rtvl_typed_vector_list_ptr
			       ptr;
      dcl	    rtvl_code	       fixed bin (35);
      dcl	    rtvl_tva_idx	       fixed bin;		/* index into return_tva_array */
      dcl	    rtvl_vector_idx	       fixed bin;		/* index into current typed_vector_array */
      dcl	    rtvl_return_vector_idx fixed bin;		/* index into typed_vector_list */

      if rtvl_number_of_vectors <= 0
      then return;

      if rtvl_typed_vector_list_ptr ^= null
      then
         do;

         /*** The caller provided a typed_vector_list. Do not allocate a new one. */

	  typed_vector_list_ptr = rtvl_typed_vector_list_ptr;
         end;
      else
         do;

         /*** The caller did not provide a typed_vector_list.
	    Allocate a new one. */

	  tvl_maximum_number_of_vectors = rtvl_number_of_vectors;
	  alloc typed_vector_list in (caller_area);	/* freed in FINISH if necessary */
	  typed_vector_list.version = TYPED_VECTOR_LIST_VERSION_1;
	  typed_vector_list.pad = 0;
         end;

      typed_vector_list.number_of_vectors = rtvl_number_of_vectors;

      rtvl_return_vector_idx = 1;
      do rtvl_tva_idx = 1 to hbound (return_tva_array, 1) while (rtvl_return_vector_idx <= rtvl_number_of_vectors);

         if return_tva_array (rtvl_tva_idx).ptr ^= null
         then
	  do;
	     do rtvl_vector_idx = 1 to return_tva_array (rtvl_tva_idx).ptr -> typed_vector_array.number_of_vectors;

	        call dm_vector_util_$copy_typed_vector (caller_area_ptr, return_tva_array (rtvl_tva_idx).ptr,
		   return_tva_array (rtvl_tva_idx).ptr -> typed_vector_array.vector_slot (rtvl_vector_idx),
		   typed_vector_list.vector_ptr (rtvl_return_vector_idx), rtvl_code);
	        if rtvl_code ^= 0
	        then call ERROR_RETURN (rtvl_code);
	        rtvl_return_vector_idx = rtvl_return_vector_idx + 1;
	     end;

	     call FREE_TYPED_VECTOR_ARRAY (return_tva_array (rtvl_tva_idx).ptr);

	  end;
      end;

      rtvl_typed_vector_list_ptr = typed_vector_list_ptr;

      return;

   end RETURN_TYPED_VECTOR_LIST;
%page;
RETURN_TYPED_VECTOR_ARRAY:
   proc (rtva_number_of_vectors, rtva_typed_vector_array_ptr);

/* Allocate a typed_vector_array in the caller's area and copy the
   vectors in the various temporary typed_vector_arrays from the
   work_area to the caller's area. */

      dcl	    rtva_number_of_vectors fixed bin (35);
      dcl	    rtva_typed_vector_array_ptr
			       ptr;
      dcl	    dm_vector_util_$init_typed_vector_array
			       entry options (variable);
      dcl	    rtva_code	       fixed bin (35) init (0);
      dcl	    (
	    rtva_dimension_idx,			/* index into dimension_table */
	    rtva_return_vector_idx,			/* index into return typed_vector_array */
	    rtva_tva_idx,				/* index into return_tva_array */
	    rtva_vector_idx				/* index into current typed_vector_array */
	    )		       fixed bin;

      if rtva_number_of_vectors <= 0
      then return;

      do rtva_tva_idx = 1 to hbound (return_tva_array, 1) while (return_tva_array (rtva_tva_idx).ptr = null);
      end;
      if rtva_tva_idx > hbound (return_tva_array, 1)
      then call sub_err_ (dm_error_$programming_error, myname, ACTION_CANT_RESTART, null, 0,
	      "There are ^d tuples to return, but no vector structure has been allocated.", rtva_number_of_vectors);

      if rtva_typed_vector_array_ptr ^= null
      then
        /*** The caller supplied a typed_vector_array. Do not allocate a new one. */
	 rtva_typed_vector_array_ptr -> typed_vector_array.number_of_vectors = rtva_number_of_vectors;
      else
         do;

         /*** The caller did not provide a typed_vector_array. Allocate one in the
	    caller_area. */

	  call dm_vector_util_$init_typed_vector_array (caller_area_ptr, rtva_number_of_vectors,
	       return_tva_array (rtva_tva_idx).ptr -> typed_vector_array.number_of_dimensions,
	       return_tva_array (rtva_tva_idx).ptr -> typed_vector_array.maximum_dimension_name_length,
	       rtva_typed_vector_array_ptr, rtva_code);
	  if rtva_code ^= 0
	  then call ERROR_RETURN (rtva_code);
	  call CHECK_VERSION_FB ("typed_vector_array", rtva_typed_vector_array_ptr -> typed_vector_array.version,
	       (TYPED_VECTOR_ARRAY_VERSION_2));

	  unspec (rtva_typed_vector_array_ptr -> typed_vector_array.dimension_table) = ""b;

	  do rtva_dimension_idx = 1 to rtva_typed_vector_array_ptr -> typed_vector_array.number_of_dimensions;
(nosubrg):
	     rtva_typed_vector_array_ptr -> typed_vector_array.dimension_table (rtva_dimension_idx) =
		return_tva_array (rtva_tva_idx).ptr -> typed_vector_array.dimension_table (rtva_dimension_idx);
	  end;
         end;

      rtva_typed_vector_array_ptr -> typed_vector_array.number_of_vectors = rtva_number_of_vectors;
      rtva_return_vector_idx = 1;
      do rtva_tva_idx = rtva_tva_idx to hbound (return_tva_array, 1)
	 while (rtva_return_vector_idx <= rtva_number_of_vectors);

         if return_tva_array (rtva_tva_idx).ptr ^= null
         then
	  do;
	     do rtva_vector_idx = 1 to return_tva_array (rtva_tva_idx).ptr -> typed_vector_array.number_of_vectors;

	        call dm_vector_util_$copy_typed_vector (caller_area_ptr, return_tva_array (rtva_tva_idx).ptr,
		   return_tva_array (rtva_tva_idx).ptr -> typed_vector_array.vector_slot (rtva_vector_idx),
		   rtva_typed_vector_array_ptr -> typed_vector_array.vector_slot (rtva_return_vector_idx), rtva_code);
	        if rtva_code ^= 0
	        then call ERROR_RETURN (rtva_code);
	        rtva_return_vector_idx = rtva_return_vector_idx + 1;
	     end;
	     call FREE_TYPED_VECTOR_ARRAY (return_tva_array (rtva_tva_idx).ptr);
	  end;
      end;

      return;

   end RETURN_TYPED_VECTOR_ARRAY;
%page;
RETURN_ELEMENT_ID_LIST:
   proc (reil_number_of_ids, reil_element_id_list_ptr);

/* This subroutine allocates an element_id_list in the caller's area large
   enough to hold all of the ids to be returned.  It is referenced by explicit
   ptr to prevent conflict with element_id_lists alloc when processing the search.
   Ids are copied from the element_id_lists and typed_vector_arrays (holding
   simple_typed_vectors with a single value, a tuple id) recorded in the
   return_eil_or_tva_array. */

      dcl	    reil_number_of_ids     fixed bin (35);
      dcl	    reil_element_id_list_ptr
			       ptr;
      dcl	    (
	    reil_eil_or_tva_idx,			/* index into return_eil_or_tva_array */
	    reil_return_id_idx,			/* index into return element_id_list */
	    reil_id_idx				/* index into current eil or tva */
	    )		       fixed bin;
      dcl	    reil_code	       fixed bin (35) init (0);
      dcl	    reil_based_b36a	       bit (36) aligned based;/* for element_id */

      if reil_number_of_ids <= 0
      then return;					/* No tuples found. */
      if reil_element_id_list_ptr ^= null
      then
        /*** The caller supplied an element_id_list. Do not allocate a new one. */
	 reil_element_id_list_ptr -> element_id_list.number_of_elements = reil_number_of_ids;
      else
         do;
         /*** The caller did not supply an element_id_list. Allocate one in the
	    caller area. */

	  eil_number_of_elements = reil_number_of_ids;
	  alloc element_id_list in (caller_area) set (reil_element_id_list_ptr);
						/* freed in FINISH if necessary */
	  reil_element_id_list_ptr -> element_id_list.version = ELEMENT_ID_LIST_VERSION_1;
         end;

      reil_return_id_idx = 0;

      do reil_eil_or_tva_idx = 1 to hbound (return_eil_or_tva_array, 1);

         if return_eil_or_tva_array (reil_eil_or_tva_idx).ptr ^= null
         then
	  do;
	     if return_eil_or_tva_array (reil_eil_or_tva_idx).is_element_id_list
	     then
	        do;
		 do reil_id_idx = 1
		      to return_eil_or_tva_array (reil_eil_or_tva_idx).ptr -> element_id_list.number_of_elements;
		    reil_return_id_idx = reil_return_id_idx + 1;
		    reil_element_id_list_ptr -> element_id_list.id (reil_return_id_idx) =
		         return_eil_or_tva_array (reil_eil_or_tva_idx).ptr -> element_id_list.id (reil_id_idx);
		 end;
		 free return_eil_or_tva_array (reil_eil_or_tva_idx).ptr -> element_id_list;
		 return_eil_or_tva_array (reil_eil_or_tva_idx).ptr = null;
	        end;
	     else
	        do;
		 do reil_id_idx = 1
		      to return_eil_or_tva_array (reil_eil_or_tva_idx).ptr -> typed_vector_array.number_of_vectors;
		    ;
		    reil_return_id_idx = reil_return_id_idx + 1;
		    reil_element_id_list_ptr -> element_id_list.id (reil_return_id_idx) =
		         return_eil_or_tva_array (reil_eil_or_tva_idx).ptr
		         -> typed_vector_array.vector_slot (reil_id_idx) -> simple_typed_vector.value_ptr (1)
		         -> reil_based_b36a;
		 end;
		 call FREE_TYPED_VECTOR_ARRAY (return_eil_or_tva_array (reil_eil_or_tva_idx).ptr);
	        end;

	  end;
      end;

      return;

   end RETURN_ELEMENT_ID_LIST;
%page;
%include dm_rlm_cursor;
%page;
%include dm_rlm_opening_info;
%page;
%include dm_rlm_header;
%page;
%include dm_rlm_attribute_info;
%page;
%include dm_rlm_index_attr_map;
%page;
%include dm_relation_spec;
%page;
%include dm_specification_head;
%page;
%include vu_typed_vector_array;
%page;
%include vu_typed_vector;
%page;
%include dm_id_list;
%page;
%include dm_element_id_list;
%page;
%include dm_interval_list;
%page;
%include dm_specification;
%page;
%include dm_range_constants;
%page;
%include sub_err_flags;
%page;
%include dm_rcdmgr_entry_dcls;
%page;
%include dm_idxmgr_entry_dcls;
%page;
%include dm_typed_vector_list;

   end rlm_general_search;
